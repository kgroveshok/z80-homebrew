# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 80 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd 9d e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 3f e3			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 b3 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c8 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 79 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd dd 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 80 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd dd 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 80 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd dd 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 79 ea				ld hl, (store_tmp1) 
8110 11 83 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd dd 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd dd 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd dd 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd dd 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd dd 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 80 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 82 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd dd 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd dd 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 80 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 80 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd dd 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 81 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd dd 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd dd 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 80 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 81 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 83 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 8c ea			ld hl, store_page+3+9 
82b5 3a 65 ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 80 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd dd 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd dd 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd dd 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 83 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd dd 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 80 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd dd 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd dd 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 80 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd dd 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 80 ea			ld a, (store_page)	; get file id 
8410 32 74 ea			ld (store_tmpid), a 
8413			 
8413 3a 82 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 73 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 80 ea			ld (store_page), a 
841f 32 81 ea			ld (store_page+1),a 
8422 11 80 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd dd 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 73 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 74 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd dd 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 80 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 80 ea			ld (store_page), a 
8482 32 81 ea			ld (store_page+1),a 
8485 11 80 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd dd 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd dd 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd dd 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd dd 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd dd 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 80 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 80 ea			ld (store_page),a 
85a3				 
85a3 32 74 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 80 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd dd 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 80 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd dd 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 6b ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd dd 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 6b ea			ld (store_tmppageid), hl 
8615				 
8615 3a 74 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 80 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 81 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 82 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 83 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd dd 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd dd 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd dd 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 6b ea			ld hl,(store_tmppageid) 
868b 11 80 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd dd 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 74 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd dd 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 7e ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 7c ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd dd 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd dd 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 71 ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 7c ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 71 ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 72 ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 73 ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd dd 94			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 73 ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 71 ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 72 ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 73 ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd dd 94			call break_point_state  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 7b ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 71 ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 72 ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 73 ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd dd 94			call break_point_state  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 7c ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 7e ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 7e ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 71 ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 72 ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 73 ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd dd 94			call break_point_state  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 71 ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 72 ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 73 ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd dd 94			call break_point_state  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 71 ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 7c ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 7c ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 71 ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 72 ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 73 ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd dd 94			call break_point_state  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 71 ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 72 ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 73 ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd dd 94			call break_point_state  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 71 ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 72 ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 73 ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd dd 94			call break_point_state  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 71 ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 72 ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 73 ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd dd 94			call break_point_state  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 74 ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 74 ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 6b ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 71 ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 72 ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 73 ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd dd 94			call break_point_state  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 80 ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 71 ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 72 ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 73 ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd dd 94			call break_point_state  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 82 ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 82 ea			ld (store_page+2), a 
88e3 32 73 ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 71 ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 72 ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 73 ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd dd 94			call break_point_state  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 6b ea			ld hl, (store_tmppageid) 
8905 11 80 ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 6b ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 71 ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 72 ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 73 ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd dd 94			call break_point_state  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 80 ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 74 ea				ld a, (store_tmpid) 
894b 32 80 ea				ld (store_page), a   ; file id 
894e 3a 73 ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 81 ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 82 ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 71 ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 72 ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 73 ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd dd 94			call break_point_state  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 6b ea			ld hl, (store_tmppageid) 
8985 11 80 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 71 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 72 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 73 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd dd 94			call break_point_state  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 74 ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 80 ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 81 ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a cc eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 cc eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd 82 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 cd eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 cd eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a d2 eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b7 ed				ld hl, display_fb0 
8a48 22 d2 eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd cb 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 16 ed				ld hl, display_fb1 
8a69 22 d2 eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a d2 eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a d2 eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a d2 eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a d2 eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a d2 eb			ld hl, (display_fb_active) 
8ad6 cd b4 e2			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 79 ea				ld (store_tmp1), hl 
8ae3 32 77 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b7 ed				ld hl, display_fb0 
8ae9 22 d2 eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 75 ea				ld (store_tmp3), a   ; display row count 
8af7 3a 77 ea				ld a,( store_tmp2) 
8afa 32 78 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 78 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 79 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 75 ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 78 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 78 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 75 ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 75 ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 77 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 40 e3				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 77 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 77 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 77 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 77 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 77 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 16 ed				ld hl, display_fb1 
8ba6 22 d2 eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a b1 eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 b1 eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b7 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b9 eb		        ld hl,LFSRSeed+6 
8bf9 11 ba eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a ab eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 ab eb		    ld (seed1),hl 
8c0f 2a a9 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a9 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a af eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 af eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 6c ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c7 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 66 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 65 ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 66 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 66 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 65 ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 65 ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 66 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 6f ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 6d ee			ld de, (input_start) 
8d5e 3a 6a ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 65 ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 68 ee				ld a,(input_at_cursor) 
8d6e 11 c7 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 6d ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 60 ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd 46 e3				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 6d ee				ld hl, (input_start) 
8d8d 3a 5b ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 6f ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 6a ee				ld a, (input_at_pos) 
8d9e 32 68 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 5b ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 6f ee				ld (input_ptr), hl 
8dc6 3a 68 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 68 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 6f ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 6f ee				ld (input_ptr), hl 
8de5 3a 68 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 68 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 5b ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 5b ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 6f ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 6f ee				ld (input_ptr), hl 
8e05					 
8e05 3a 68 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 68 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 65 ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 66 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 5b ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 5b ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 68 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 68 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 6f ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 6f ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 65 ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 66 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 6d ee				ld hl, (input_start) 
8e4e 22 6f ee				ld (input_ptr), hl 
8e51			 
8e51 3a 6a ee				ld a, (input_at_pos) 
8e54 32 68 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 5b ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 ee e5				ld hl, os_cli_cmd 
8e5f 11 ed e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 5b ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 5b ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 6f ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 6f ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 68 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 68 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 65 ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 66 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 68 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 5b ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 68 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 68 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 6f ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 6f ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 6f ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 6f ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 65 ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 66 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 6d ee				ld hl, (input_start) 
8eef 3a 60 ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 60 ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 5b ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 5b ee				ld (input_cursor), a 
8f17			 
8f17 3a 68 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 68 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 6d ee				ld hl, (input_start) 
8f24 3a 60 ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 6d ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 6f ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 6c ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 5b ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 6f ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c7 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 6a ee				ld a,(input_at_pos) 
8f58 cd a4 e2		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 6d ee	            	LD   de, (input_start) 
8f5f cd 9e e2		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd 46 e3				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 6f ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c7 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 6f ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 6f ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 6f ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 6f ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 6f ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c7 e2			ld hl, scratch 
8fb2 11 ed e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c7 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 6f ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 6a 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 fb e2			ld (scratch+52),a 
90b3				 
90b3 21 f9 e2			ld hl,scratch+50 
90b6 22 ea e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				ld a, 0 
917f				ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				ld a, 0 
917f				ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				ld a, 0 
917f				ld (os_view_disable), a 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 64 e3		      ld    HL, heap_start 
9183 22 5f e3		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 61 e3		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 a9 e2		      ld    HL, heap_start+heap_size-4 
918f 22 64 e3		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 45 ff		      ld    HL, heap_size-4 
9195 22 66 e3		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 ab e2		      ld    (heap_start+heap_size-2), HL 
919e 22 a9 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 5f e3		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 5f e3		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			if SOUND_ENABLE  
933c				include "firmware_sound.asm"  
933c			endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 6c 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347 fe 01			cp 1 
9349 cc 9a 93			call z, .savetostore 
934c			 
934c fe 02			cp 2 
934e			if STARTUP_V1 
934e cc 86 93			call z, .selautoload 
9351			endif 
9351			 
9351			if STARTUP_V2 
9351				call z, .enautoload 
9351			endif 
9351 fe 03			cp 3 
9353 cc 7c 93			call z, .disautoload 
9356 fe 04			cp 4 
9358 cc 90 93			call z, .selbank 
935b fe 05			cp 5 
935d cc a4 93			call z, .debug_tog 
9360 fe 06			cp 6 
9362 cc e7 94			call z, .bpsgo 
9365 fe 07			cp 7 
9367 cc ca 93			call z, hardware_diags 
936a			if STARTUP_V2 
936a				cp 8 
936a				call z, create_startup 
936a			endif 
936a 18 d0			jr config 
936c			 
936c			.configmn: 
936c d8 96			dw prom_c3 
936e ef 96			dw prom_c2 
9370 04 97			dw prom_c2a 
9372 1a 97			dw prom_c2b 
9374			;	dw prom_c4 
9374 37 97			dw prom_m4 
9376 52 97			dw prom_m4b 
9378 5a 97			dw prom_c1 
937a			if STARTUP_V2 
937a				dw prom_c9 
937a			endif 
937a 00 00			dw 0 
937c				 
937c			 
937c			if STARTUP_V2 
937c			.enautoload: 
937c				if STORAGE_SE 
937c				ld a, $fe      ; bit 0 clear 
937c				ld (spi_device), a 
937c			 
937c				call storage_get_block_0 
937c			 
937c				ld a, 1 
937c				ld (store_page+STORE_0_AUTOFILE), a 
937c			 
937c					ld hl, 0 
937c					ld de, store_page 
937c				call storage_write_block	 ; save update 
937c				else 
937c			 
937c				ld hl, prom_notav 
937c				ld de, prom_empty 
937c				call info_panel 
937c				endif 
937c			 
937c			 
937c				ret 
937c			endif 
937c			 
937c			.disautoload: 
937c				if STORAGE_SE 
937c				ld a, $fe      ; bit 0 clear 
937c				ld (spi_device), a 
937c			 
937c				call storage_get_block_0 
937c			 
937c				ld a, 0 
937c				ld (store_page+STORE_0_AUTOFILE), a 
937c			 
937c					ld hl, 0 
937c					ld de, store_page 
937c				call storage_write_block	 ; save update 
937c				else 
937c			 
937c 21 69 97			ld hl, prom_notav 
937f 11 7f 97			ld de, prom_empty 
9382 cd 40 8a			call info_panel 
9385				endif 
9385			 
9385			 
9385 c9				ret 
9386			 
9386			if STARTUP_V1 
9386			 
9386			; Select auto start 
9386			 
9386			.selautoload: 
9386			 
9386				 
9386				if STORAGE_SE 
9386			 
9386					call config_dir 
9386				        ld hl, scratch 
9386					ld a, 0 
9386					call menu 
9386			 
9386					cp 0 
9386					ret z 
9386			 
9386					dec a 
9386			 
9386			 
9386					; locate menu option 
9386			 
9386					ld hl, scratch 
9386					call table_lookup 
9386			 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "ALl" 
9386						CALLMONITOR 
9386					endif 
9386					; with the pointer to the menu it, the byte following the zero term is the file id 
9386			 
9386					ld a, 0 
9386					ld bc, 50   ; max of bytes to look at 
9386					cpir  
9386			 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "ALb" 
9386						CALLMONITOR 
9386					endif 
9386					;inc hl 
9386			 
9386					ld a, (hl)   ; file id 
9386					 
9386				        ; save bank and file ids 
9386			 
9386					push af 
9386			 
9386			; TODO need to save to block 0 on bank 1	 
9386			 
9386					call storage_get_block_0 
9386			 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "AL0" 
9386						CALLMONITOR 
9386					endif 
9386					pop af 
9386			 
9386					ld (store_page+STORE_0_FILERUN),a 
9386					 
9386					; save bank id 
9386			 
9386					ld a,(spi_device) 
9386					ld (store_page+STORE_0_BANKRUN),a 
9386			 
9386					; enable auto run of store file 
9386			 
9386					ld a, 1 
9386					ld (store_page+STORE_0_AUTOFILE),a 
9386			 
9386					; save buffer 
9386			 
9386					ld hl, 0 
9386					ld de, store_page 
9386					if DEBUG_FORTH_WORDS 
9386						DMARK "ALw" 
9386						CALLMONITOR 
9386					endif 
9386				call storage_write_block	 ; save update 
9386			  
9386			 
9386			 
9386			 
9386					ld hl, scratch 
9386					call config_fdir 
9386			 
9386				else 
9386			 
9386 21 69 97			ld hl, prom_notav 
9389 11 7f 97			ld de, prom_empty 
938c cd 40 8a			call info_panel 
938f			 
938f				endif 
938f c9				ret 
9390			endif 
9390			 
9390			 
9390			; Select storage bank 
9390			 
9390			.selbank: 
9390			 
9390				if STORAGE_SE 
9390				else 
9390			 
9390 21 69 97			ld hl, prom_notav 
9393 11 7f 97			ld de, prom_empty 
9396 cd 40 8a			call info_panel 
9399				endif 
9399				 
9399 c9				ret 
939a			 
939a			if STORAGE_SE 
939a			 
939a			.config_ldir:   
939a				; Load storage bank labels into menu array 
939a			 
939a				 
939a			 
939a			 
939a				ret 
939a			 
939a			 
939a			endif 
939a			 
939a			 
939a			; Save user words to storage 
939a			 
939a			.savetostore: 
939a			 
939a				if STORAGE_SE 
939a			 
939a					call config_dir 
939a				        ld hl, scratch 
939a					ld a, 0 
939a					call menu 
939a					 
939a					ld hl, scratch 
939a					call config_fdir 
939a			 
939a				else 
939a			 
939a 21 69 97			ld hl, prom_notav 
939d 11 7f 97			ld de, prom_empty 
93a0 cd 40 8a			call info_panel 
93a3			 
93a3				endif 
93a3			 
93a3 c9				ret 
93a4			 
93a4			if STARTUP_V2 
93a4			 
93a4			create_startup: 
93a4			 
93a4				ld a, 0 
93a4				ld hl, .crstart 
93a4				call menu 
93a4			 
93a4				cp 0 
93a4				ret z 
93a4			 
93a4				cp 1 
93a4				call z, .genlsword 
93a4				cp 2 
93a4				call z, .genedword 
93a4			 
93a4				cp 3 
93a4				call z, .gendemword 
93a4			 
93a4				cp 4 
93a4				call z, .genutlword 
93a4				cp 5 
93a4				call z, .genspiword 
93a4				cp 6 
93a4				call z, .genkeyword 
93a4				jr create_startup 
93a4			 
93a4			.genlsword: 
93a4				ld hl, crs_s1 
93a4				ld de, .lsworddef 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			.genedword: 
93a4				ld de, .edworddef 
93a4				ld hl, crs_s2 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			.gendemword: 
93a4				ld de, .demoworddef 
93a4				ld hl, crs_s3 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			.genutlword: 
93a4				ld hl, crs_s4 
93a4				ld de, .utilwordef 
93a4				call .genfile 
93a4				ret 
93a4			.genspiword: 
93a4				ld hl, crs_s5 
93a4				ld de, .spiworddef 
93a4				call .genfile 
93a4				ret 
93a4			.genkeyword: 
93a4				ld hl, crs_s6 
93a4				ld de, .keyworddef 
93a4				call .genfile 
93a4				ret 
93a4			 
93a4			; hl - points to file name 
93a4			; de - points to strings to add to file 
93a4			 
93a4			.genfile: 
93a4				push hl 
93a4				push de 
93a4			 
93a4				call clear_display 
93a4				ld a, display_row_1 
93a4				ld de, .genfiletxt 
93a4				call str_at_display 
93a4				call update_display 
93a4			 
93a4				pop de 
93a4				pop hl 
93a4			 
93a4			 
93a4				push de 
93a4				call storage_create 
93a4				; id in hl 
93a4				pop de   ; table of strings to add 
93a4			 
93a4			.genloop: 
93a4			 
93a4				push hl ; save id for next time around 
93a4				push de ; save de for next time around 
93a4			 
93a4				ex de, hl 
93a4				call loadwordinhl 
93a4				ex de, hl 
93a4			 
93a4				; need hl to be the id 
93a4				; need de to be the string ptr 
93a4				 
93a4				call storage_append 
93a4			 
93a4				pop de 
93a4				pop hl 
93a4			 
93a4				inc de 
93a4				inc de 
93a4			 
93a4				ld a,(de) 
93a4				cp 0 
93a4				jr nz, .genloop 
93a4				inc de 
93a4				ld a, (de) 
93a4				dec de 
93a4				cp 0 
93a4				jr nz, .genloop	 
93a4			 
93a4				ret 
93a4			 
93a4			.genfiletxt:  db "Creating file...",0 
93a4			 
93a4			.utilwordef: 
93a4				dw strncpy 
93a4				dw type 
93a4				dw clrstack 
93a4				dw longread 
93a4				dw start1 
93a4				dw start2 
93a4				dw start3b 
93a4				dw start3c 
93a4				dw list 
93a4				dw 0 
93a4			 
93a4			.lsworddef: 
93a4				dw start3b 
93a4				dw 0 
93a4			 
93a4			.edworddef: 
93a4				dw edit1 
93a4				dw edit2 
93a4				dw edit3 
93a4				dw 0 
93a4			 
93a4			.demoworddef: 
93a4				dw test5 
93a4				dw test6 
93a4				dw test7 
93a4				dw test8 
93a4				dw test9 
93a4				dw test10 
93a4				dw game1 
93a4				dw game1a 
93a4				dw game1b 
93a4				dw game1c 
93a4				dw game1d 
93a4				dw game1s 
93a4				dw game1t 
93a4				dw game1f 
93a4				dw game1z 
93a4				dw game1zz 
93a4				dw ssv2 
93a4				dw ssv3 
93a4				dw ssv4 
93a4				dw ssv5 
93a4				dw ssv1 
93a4				dw ssv1cpm	 
93a4				dw game2b 
93a4				dw game2bf 
93a4				dw game2mba 
93a4				dw game2mbas	 
93a4				dw game2mbht 
93a4				dw game2mbms 
93a4				dw game2mb 
93a4				dw game3w 
93a4				dw game3p 
93a4				dw game3sc 
93a4				dw game3vsi 
93a4				dw game3vs 
93a4				dw 0 
93a4			 
93a4			 
93a4			.spiworddef: 
93a4			 
93a4			    dw spi1 
93a4			    dw spi2 
93a4			    dw spi3 
93a4			    dw spi4 
93a4			    dw spi5 
93a4			    dw spi6 
93a4			    dw spi7 
93a4			 
93a4			    dw spi8 
93a4			    dw spi9 
93a4			    dw spi10 
93a4			    dw 0 
93a4			 
93a4			.keyworddef: 
93a4			 
93a4				dw keyup 
93a4				dw keydown 
93a4				dw keyleft 
93a4				dw keyright 
93a4				dw 	keyf1 
93a4				dw keyf2 
93a4				dw keyf3 
93a4				dw keyf4 
93a4				dw keyf5 
93a4				dw keyf6 
93a4				dw keyf7 
93a4				dw keyf8 
93a4				dw keyf9 
93a4				dw keyf10 
93a4				dw keyf11 
93a4				dw keyf12 
93a4				dw keytab 
93a4				dw keycr 
93a4				dw keyhome 
93a4				dw keyend 
93a4				dw keybs 
93a4				dw 0 
93a4			 
93a4			.crstart: 
93a4				dw crs_s1 
93a4				dw crs_s2 
93a4				dw crs_s3 
93a4				dw crs_s4 
93a4				dw crs_s5 
93a4				dw crs_s6 
93a4				dw 0 
93a4			 
93a4			endif 
93a4			 
93a4			 
93a4			if STORAGE_SE 
93a4			 
93a4			config_fdir: 
93a4				; using the scratch dir go through and release the memory allocated for each string 
93a4				 
93a4				ld hl, scratch 
93a4			.cfdir:	ld e,(hl) 
93a4				inc hl 
93a4				ld d,(hl) 
93a4				inc hl 
93a4			 
93a4				ex de, hl 
93a4				call ishlzero 
93a4				ret z     ; return on null pointer 
93a4				call free 
93a4				ex de, hl 
93a4				jr .cfdir 
93a4			 
93a4			 
93a4				ret 
93a4			 
93a4			 
93a4			config_dir: 
93a4			 
93a4				; for the config menus that need to build a directory of storage call this routine 
93a4				; it will construct a menu in scratch to pass to menu 
93a4			 
93a4				; open storage device 
93a4			 
93a4				; execute DIR to build a list of files and their ids into scratch in menu format 
93a4				; once the menu has finished then will need to call config_fdir to release the strings 
93a4				 
93a4				; c = number items 
93a4			 
93a4				 
93a4				call storage_get_block_0 
93a4			 
93a4				ld hl, store_page     ; get current id count 
93a4				ld b, (hl) 
93a4				ld c, 0    ; count of files   
93a4			 
93a4			 
93a4				ld hl, scratch 
93a4				ld (store_tmp2), hl    ; location to poke strings 
93a4			 
93a4				; check for empty drive 
93a4			 
93a4				ld a, 0 
93a4				cp b 
93a4				jp z, .dirdone 
93a4			 
93a4				 
93a4					if DEBUG_FORTH_WORDS 
93a4						DMARK "Cdc" 
93a4						CALLMONITOR 
93a4					endif 
93a4			 
93a4			 
93a4			.diritem:	 
93a4				push bc 
93a4				; for each of the current ids do a search for them and if found push to stack 
93a4			 
93a4					ld hl, STORE_BLOCK_PHY 
93a4					ld d, 0		 ; look for extent 0 of block id as this contains file name 
93a4					ld e,b 
93a4			 
93a4					call storage_findnextid 
93a4			 
93a4			 
93a4					; if found hl will be non zero 
93a4			 
93a4					call ishlzero 
93a4					jr z, .dirnotfound 
93a4			 
93a4					; increase count 
93a4			 
93a4					pop bc	 
93a4					inc c 
93a4					push bc 
93a4					 
93a4			 
93a4					; get file header and push the file name 
93a4			 
93a4					ld de, store_page 
93a4					call storage_read_block 
93a4			 
93a4					; push file id to stack 
93a4				 
93a4					ld a, (store_page) 
93a4					ld h, 0 
93a4					ld l, a 
93a4			 
93a4					;call forth_push_numhl 
93a4					; TODO store id 
93a4			 
93a4					push hl 
93a4			 
93a4					; push extent count to stack  
93a4				 
93a4					ld hl, store_page+3 
93a4			 
93a4					; get file name length 
93a4			 
93a4					call strlenz   
93a4			 
93a4					inc hl   ; cover zero term 
93a4					inc hl  ; stick the id at the end of the area 
93a4			 
93a4					push hl 
93a4					pop bc    ; move length to bc 
93a4			 
93a4					call malloc 
93a4			 
93a4					; TODO save malloc area to scratch 
93a4			 
93a4					ex de, hl 
93a4					ld hl, (store_tmp2) 
93a4					ld (hl), e 
93a4					inc hl 
93a4					ld (hl), d 
93a4					inc hl 
93a4					ld (store_tmp2), hl 
93a4			 
93a4					 
93a4			 
93a4					;pop hl   ; get source 
93a4			;		ex de, hl    ; swap aronund	 
93a4			 
93a4					ld hl, store_page+3 
93a4					if DEBUG_FORTH_WORDS 
93a4						DMARK "CFd" 
93a4						CALLMONITOR 
93a4					endif 
93a4					ldir 
93a4			 
93a4					; de is past string, move back one and store id 
93a4					 
93a4					dec de 
93a4			 
93a4					; store file id 
93a4			 
93a4					pop hl 
93a4					ex de,hl 
93a4					ld (hl), e 
93a4			 
93a4					if DEBUG_FORTH_WORDS 
93a4						DMARK "Cdi" 
93a4						CALLMONITOR 
93a4					endif 
93a4					 
93a4			.dirnotfound: 
93a4					pop bc     
93a4					djnz .diritem 
93a4				 
93a4			.dirdone:	 
93a4			 
93a4					ld a, 0 
93a4					ld hl, (store_tmp2) 
93a4					ld (hl), a 
93a4					inc hl 
93a4					ld (hl), a 
93a4					inc hl 
93a4					; push a count of the dir items found 
93a4			 
93a4			;		ld h, 0 
93a4			;		ld l, c 
93a4			 
93a4				ret 
93a4			 
93a4			endif 
93a4			 
93a4			 
93a4			; Settings 
93a4			; Run  
93a4			 
93a4			 
93a4			 
93a4			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
93a4			;;hd_menu2:   db "        2: Editor",0   
93a4			;hd_menu2:   db "        2: Editor       6: Menu",0   
93a4			;hd_menu3:   db "        3: Storage",0 
93a4			;hd_menu4:   db "0=quit  4: Debug",0 
93a4			;hd_don:     db "ON",0 
93a4			;hd_doff:     db "OFF",0 
93a4			; 
93a4			; 
93a4			; 
93a4			;hardware_diags_old:       
93a4			; 
93a4			;.diagmenu: 
93a4			;	call clear_display 
93a4			;	ld a, display_row_1 
93a4			;	ld de, hd_menu1 
93a4			;	call str_at_display 
93a4			; 
93a4			;	ld a, display_row_2 
93a4			;	ld de, hd_menu2 
93a4			;	call str_at_display 
93a4			; 
93a4			;	ld a, display_row_3 
93a4			;	ld de, hd_menu3 
93a4			;	call str_at_display 
93a4			; 
93a4			;	ld a,  display_row_4 
93a4			;	ld de, hd_menu4 
93a4			;	call str_at_display 
93a4			; 
93a4			;	; display debug state 
93a4			; 
93a4			;	ld de, hd_don 
93a4			;	ld a, (os_view_disable) 
93a4			;	cp 0 
93a4			;	jr z, .distog 
93a4			;	ld de, hd_doff 
93a4			;.distog: ld a, display_row_4+17 
93a4			;	call str_at_display 
93a4			; 
93a4			;	call update_display 
93a4			; 
93a4			;	call cin_wait 
93a4			; 
93a4			; 
93a4			; 
93a4			;	cp '4' 
93a4			;	jr nz, .diagn1 
93a4			; 
93a4			;	; debug toggle 
93a4			; 
93a4			;	ld a, (os_view_disable) 
93a4			;	ld b, '*' 
93a4			;	cp 0 
93a4			;	jr z, .debtog 
93a4			;	ld b, 0 
93a4			;.debtog:	 
93a4			;	ld a,b 
93a4			;	ld (os_view_disable),a 
93a4			; 
93a4			;.diagn1: cp '0' 
93a4			;	 ret z 
93a4			; 
93a4			;;	cp '1' 
93a4			;;       jp z, matrix	 
93a4			;;   TODO keyboard matrix test 
93a4			; 
93a4			;	cp '2' 
93a4			;	jp z, .diagedit 
93a4			; 
93a4			;;	cp '6' 
93a4			;;	jp z, .menutest 
93a4			;;if ENABLE_BASIC 
93a4			;;	cp '6' 
93a4			;;	jp z, basic 
93a4			;;endif 
93a4			 ; 
93a4			;	jp .diagmenu 
93a4			; 
93a4			; 
93a4			;	ret 
93a4			 
93a4			 
93a4			.debug_tog: 
93a4 21 eb 93			ld hl, .menudebug 
93a7				 
93a7 3a b8 e2			ld a, (os_view_disable) 
93aa fe 2a			cp '*' 
93ac 20 04			jr nz,.tdon  
93ae 3e 01			ld a, 1 
93b0 18 02			jr .tog1 
93b2 3e 00		.tdon: ld a, 0 
93b4			 
93b4			.tog1: 
93b4 cd e0 8a			call menu 
93b7 fe 00			cp 0 
93b9 c8				ret z 
93ba fe 01			cp 1    ; disable debug 
93bc 28 04			jr z, .dtog0 
93be 3e 2a			ld a, '*' 
93c0 18 02			jr .dtogset 
93c2 3e 00		.dtog0: ld a, 0 
93c4 32 b8 e2		.dtogset:  ld (os_view_disable), a 
93c7 c3 a4 93			jp .debug_tog 
93ca			 
93ca			 
93ca			hardware_diags:       
93ca			 
93ca			.diagm: 
93ca 21 dd 93			ld hl, .menuitems 
93cd 3e 00			ld a, 0 
93cf cd e0 8a			call menu 
93d2			 
93d2 fe 00		         cp 0 
93d4 c8				 ret z 
93d5			 
93d5 fe 02			cp 2 
93d7 ca 36 94			jp z, .diagedit 
93da			 
93da			;	cp '6' 
93da			;	jp z, .menutest 
93da			;if ENABLE_BASIC 
93da			;	cp '6' 
93da			;	jp z, basic 
93da			;endif 
93da			  
93da c3 ca 93			jp .diagm 
93dd			 
93dd				 
93dd f1 93		.menuitems:   	dw .m1 
93df fc 93				dw .m2 
93e1 03 94				dw .m3 
93e3 0b 94				dw .m5 
93e5 11 94				dw .m5a 
93e7 1a 94				dw .m5b 
93e9 00 00				dw 0 
93eb			 
93eb			.menudebug: 
93eb 23 94				dw .m6 
93ed 2c 94				dw .m7 
93ef 00 00				dw 0 
93f1			 
93f1 .. 00		.m1:   db "Key Matrix",0 
93fc .. 00		.m2:   db "Editor",0 
9403 .. 00		.m3:   db "Storage",0 
940b .. 00		.m5:   db "Sound",0 
9411 .. 00		.m5a:  db "RAM Test",0 
941a .. 00		.m5b:  db "LCD Test",0 
9423			 
9423 .. 00		.m6:   db "Debug ON",0 
942c .. 00		.m7:   db "Debug OFF",0 
9436			 
9436			; debug editor 
9436			 
9436			.diagedit: 
9436			 
9436 21 c7 e2			ld hl, scratch 
9439			;	ld bc, 250 
9439			;	ldir 
9439				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9439 3e 00			ld a, 0 
943b 77				ld (hl), a 
943c 23				inc hl 
943d 77				ld (hl), a 
943e 23				inc hl 
943f 77				ld (hl), a 
9440			 
9440 cd af 8a		        call clear_display 
9443 cd d2 8a			call update_display 
9446				;ld a, 1 
9446				;ld (hardware_diag), a 
9446			.diloop: 
9446 3e 00			ld a, display_row_1 
9448 0e 00			ld c, 0 
944a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
944c 1e 28			ld e, 40 
944e			 
944e 21 c7 e2			ld hl, scratch	 
9451 cd 09 8d			call input_str 
9454			 
9454 3e 28			ld a, display_row_2 
9456 11 c7 e2			ld de, scratch 
9459 cd c2 8a			call str_at_display 
945c cd d2 8a			call update_display 
945f			 
945f c3 46 94			jp .diloop 
9462			 
9462			 
9462			; pass word in hl 
9462			; a has display location 
9462			display_word_at: 
9462 f5				push af 
9463 e5				push hl 
9464 7c				ld a,h 
9465 21 cc e5			ld hl, os_word_scratch 
9468 cd dd 8f			call hexout 
946b e1				pop hl 
946c 7d				ld a,l 
946d 21 ce e5			ld hl, os_word_scratch+2 
9470 cd dd 8f			call hexout 
9473 21 d0 e5			ld hl, os_word_scratch+4 
9476 3e 00			ld a,0 
9478 77				ld (hl),a 
9479 11 cc e5			ld de,os_word_scratch 
947c f1				pop af 
947d cd c2 8a				call str_at_display 
9480 c9				ret 
9481			 
9481			display_ptr_state: 
9481			 
9481				; to restore afterwards 
9481			 
9481 d5				push de 
9482 c5				push bc 
9483 e5				push hl 
9484 f5				push af 
9485			 
9485				; for use in here 
9485			 
9485			;	push bc 
9485			;	push de 
9485			;	push hl 
9485			;	push af 
9485			 
9485 cd af 8a			call clear_display 
9488			 
9488 11 5b 96			ld de, .ptrstate 
948b 3e 00			ld a, display_row_1 
948d cd c2 8a			call str_at_display 
9490			 
9490				; display debug step 
9490			 
9490			 
9490 11 71 ee			ld de, debug_mark 
9493 3e 26			ld a, display_row_1+display_cols-2 
9495 cd c2 8a			call str_at_display 
9498			 
9498				; display a 
9498 11 65 96			ld de, .ptrcliptr 
949b 3e 28			ld a, display_row_2 
949d cd c2 8a			call str_at_display 
94a0			 
94a0 f1				pop af 
94a1 2a 46 ea			ld hl,(cli_ptr) 
94a4 3e 30			ld a, display_row_2+8 
94a6 cd 62 94			call display_word_at 
94a9			 
94a9			 
94a9				; display hl 
94a9			 
94a9			 
94a9 11 6d 96			ld de, .ptrclioptr 
94ac 3e 32			ld a, display_row_2+10 
94ae cd c2 8a			call str_at_display 
94b1			; 
94b1			;	pop hl 
94b1 3e 35			ld a, display_row_2+13 
94b3 2a 44 ea			ld hl,(cli_origptr) 
94b6 cd 62 94			call display_word_at 
94b9			; 
94b9			;	 
94b9			;	; display de 
94b9			 
94b9			;	ld de, .regstatede 
94b9			;	ld a, display_row_3 
94b9			;	call str_at_display 
94b9			 
94b9			;	pop de 
94b9			;	ld h,d 
94b9			;	ld l, e 
94b9			;	ld a, display_row_3+3 
94b9			;	call display_word_at 
94b9			 
94b9			 
94b9				; display bc 
94b9			 
94b9			;	ld de, .regstatebc 
94b9			;	ld a, display_row_3+10 
94b9			;	call str_at_display 
94b9			 
94b9			;	pop bc 
94b9			;	ld h,b 
94b9			;	ld l, c 
94b9			;	ld a, display_row_3+13 
94b9			;	call display_word_at 
94b9			 
94b9			 
94b9				; display dsp 
94b9			 
94b9			;	ld de, .regstatedsp 
94b9			;	ld a, display_row_4 
94b9			;	call str_at_display 
94b9			 
94b9				 
94b9			;	ld hl,(cli_data_sp) 
94b9			;	ld a, display_row_4+4 
94b9			;	call display_word_at 
94b9			 
94b9				; display rsp 
94b9			 
94b9 11 9c 96			ld de, .regstatersp 
94bc 3e 82			ld a, display_row_4+10 
94be cd c2 8a			call str_at_display 
94c1			 
94c1				 
94c1 2a f8 e9			ld hl,(cli_ret_sp) 
94c4 3e 86			ld a, display_row_4+14 
94c6 cd 62 94			call display_word_at 
94c9			 
94c9 cd d2 8a			call update_display 
94cc			 
94cc cd f2 89			call delay1s 
94cf cd f2 89			call delay1s 
94d2 cd f2 89			call delay1s 
94d5			 
94d5			 
94d5 cd cb 9a			call next_page_prompt 
94d8			 
94d8				; restore  
94d8			 
94d8 f1				pop af 
94d9 e1				pop hl 
94da c1				pop bc 
94db d1				pop de 
94dc c9				ret 
94dd			 
94dd			break_point_state: 
94dd f5				push af 
94de			 
94de				; see if disabled 
94de			 
94de 3a b8 e2			ld a, (os_view_disable) 
94e1 fe 2a			cp '*' 
94e3 20 02			jr nz, .bpsgo 
94e5 f1				pop af 
94e6 c9				ret 
94e7			 
94e7			.bpsgo: 
94e7 f1				pop af 
94e8 f5				push af 
94e9 22 b4 e2			ld (os_view_hl), hl 
94ec ed 53 b2 e2		ld (os_view_de), de 
94f0 ed 43 b0 e2		ld (os_view_bc), bc 
94f4 e5				push hl 
94f5 6f				ld l, a 
94f6 26 00			ld h, 0 
94f8 22 b6 e2			ld (os_view_af),hl 
94fb			 
94fb 21 b7 ed				ld hl, display_fb0 
94fe 22 d2 eb				ld (display_fb_active), hl 
9501 e1				pop hl	 
9502			 
9502 3e 31			ld a, '1' 
9504 fe 2a		.bps1:  cp '*' 
9506 20 03			jr nz, .bps1b 
9508 32 b8 e2			ld (os_view_disable),a 
950b fe 31		.bps1b:  cp '1' 
950d 20 14			jr nz, .bps2 
950f			 
950f				; display reg 
950f			 
950f				 
950f			 
950f 3a b6 e2			ld a, (os_view_af) 
9512 2a b4 e2			ld hl, (os_view_hl) 
9515 ed 5b b2 e2		ld de, (os_view_de) 
9519 ed 4b b0 e2		ld bc, (os_view_bc) 
951d cd b7 95			call display_reg_state 
9520 c3 a3 95			jp .bpschk 
9523			 
9523 fe 32		.bps2:  cp '2' 
9525 20 08			jr nz, .bps3 
9527				 
9527				; display hl 
9527 2a b4 e2			ld hl, (os_view_hl) 
952a cd a1 96			call display_dump_at_hl 
952d			 
952d 18 74			jr .bpschk 
952f			 
952f fe 33		.bps3:  cp '3' 
9531 20 08			jr nz, .bps4 
9533			 
9533			        ; display de 
9533 2a b2 e2			ld hl, (os_view_de) 
9536 cd a1 96			call display_dump_at_hl 
9539			 
9539 18 68			jr .bpschk 
953b fe 34		.bps4:  cp '4' 
953d 20 08			jr nz, .bps5 
953f			 
953f			        ; display bc 
953f 2a b0 e2			ld hl, (os_view_bc) 
9542 cd a1 96			call display_dump_at_hl 
9545			 
9545 18 5c			jr .bpschk 
9547 fe 35		.bps5:  cp '5' 
9549 20 08		        jr nz, .bps7 
954b			 
954b				; display cur ptr 
954b 2a 46 ea			ld hl, (cli_ptr) 
954e cd a1 96			call display_dump_at_hl 
9551			 
9551 18 50			jr .bpschk 
9553 fe 36		.bps7:  cp '6' 
9555 20 08			jr nz, .bps8b 
9557				 
9557				; display cur orig ptr 
9557 2a 44 ea			ld hl, (cli_origptr) 
955a cd a1 96			call display_dump_at_hl 
955d 18 44			jr .bpschk 
955f fe 37		.bps8b:  cp '7' 
9561 20 08			jr nz, .bps9 
9563				 
9563				; display dsp 
9563 2a f4 e9			ld hl, (cli_data_sp) 
9566 cd a1 96			call display_dump_at_hl 
9569			 
9569 18 38			jr .bpschk 
956b fe 39		.bps9:  cp '9' 
956d 20 05			jr nz, .bps8c 
956f				 
956f				; display SP 
956f			;	ld hl, sp 
956f cd a1 96			call display_dump_at_hl 
9572			 
9572 18 2f			jr .bpschk 
9574 fe 38		.bps8c:  cp '8' 
9576 20 08			jr nz, .bps8d 
9578				 
9578				; display rsp 
9578 2a f8 e9			ld hl, (cli_ret_sp) 
957b cd a1 96			call display_dump_at_hl 
957e			 
957e 18 23			jr .bpschk 
9580 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9582 20 05			jr nz, .bps8 
9584 cd c1 98			call monitor 
9587			 
9587 18 1a			jr .bpschk 
9589 fe 30		.bps8:  cp '0' 
958b 20 16			jr nz, .bpschk 
958d			 
958d 21 16 ed				ld hl, display_fb1 
9590 22 d2 eb				ld (display_fb_active), hl 
9593 cd d2 8a				call update_display 
9596			 
9596				;ld a, (os_view_af) 
9596 2a b4 e2			ld hl, (os_view_hl) 
9599 ed 5b b2 e2		ld de, (os_view_de) 
959d ed 4b b0 e2		ld bc, (os_view_bc) 
95a1 f1				pop af 
95a2 c9				ret 
95a3			 
95a3			.bpschk:   
95a3 cd f2 89			call delay1s 
95a6 3e 9f		ld a,display_row_4 + display_cols - 1 
95a8 11 c9 9a		        ld de, endprg 
95ab cd c2 8a			call str_at_display 
95ae cd d2 8a			call update_display 
95b1 cd 40 e3			call cin_wait 
95b4			 
95b4 c3 04 95			jp .bps1 
95b7			 
95b7			 
95b7			display_reg_state: 
95b7			 
95b7				; to restore afterwards 
95b7			 
95b7 d5				push de 
95b8 c5				push bc 
95b9 e5				push hl 
95ba f5				push af 
95bb			 
95bb				; for use in here 
95bb			 
95bb c5				push bc 
95bc d5				push de 
95bd e5				push hl 
95be f5				push af 
95bf			 
95bf cd af 8a			call clear_display 
95c2			 
95c2 11 77 96			ld de, .regstate 
95c5 3e 00			ld a, display_row_1 
95c7 cd c2 8a			call str_at_display 
95ca			 
95ca				; display debug step 
95ca			 
95ca			 
95ca 11 71 ee			ld de, debug_mark 
95cd 3e 25			ld a, display_row_1+display_cols-3 
95cf cd c2 8a			call str_at_display 
95d2			 
95d2				; display a 
95d2 11 93 96			ld de, .regstatea 
95d5 3e 28			ld a, display_row_2 
95d7 cd c2 8a			call str_at_display 
95da			 
95da e1				pop hl 
95db			;	ld h,0 
95db			;	ld l, a 
95db 3e 2b			ld a, display_row_2+3 
95dd cd 62 94			call display_word_at 
95e0			 
95e0			 
95e0				; display hl 
95e0			 
95e0			 
95e0 11 87 96			ld de, .regstatehl 
95e3 3e 32			ld a, display_row_2+10 
95e5 cd c2 8a			call str_at_display 
95e8			 
95e8 e1				pop hl 
95e9 3e 35			ld a, display_row_2+13 
95eb cd 62 94			call display_word_at 
95ee			 
95ee				 
95ee				; display de 
95ee			 
95ee 11 8b 96			ld de, .regstatede 
95f1 3e 50			ld a, display_row_3 
95f3 cd c2 8a			call str_at_display 
95f6			 
95f6 e1				pop hl 
95f7			;	ld h,d 
95f7			;	ld l, e 
95f7 3e 53			ld a, display_row_3+3 
95f9 cd 62 94			call display_word_at 
95fc			 
95fc			 
95fc				; display bc 
95fc			 
95fc 11 8f 96			ld de, .regstatebc 
95ff 3e 5a			ld a, display_row_3+10 
9601 cd c2 8a			call str_at_display 
9604			 
9604 e1				pop hl 
9605			;	ld h,b 
9605			;	ld l, c 
9605 3e 5d			ld a, display_row_3+13 
9607 cd 62 94			call display_word_at 
960a			 
960a			 
960a				; display dsp 
960a			 
960a 11 97 96			ld de, .regstatedsp 
960d 3e 78			ld a, display_row_4 
960f cd c2 8a			call str_at_display 
9612			 
9612				 
9612 2a f4 e9			ld hl,(cli_data_sp) 
9615 3e 7c			ld a, display_row_4+4 
9617 cd 62 94			call display_word_at 
961a			 
961a				; display rsp 
961a			 
961a 11 9c 96			ld de, .regstatersp 
961d 3e 82			ld a, display_row_4+10 
961f cd c2 8a			call str_at_display 
9622			 
9622				 
9622 2a f8 e9			ld hl,(cli_ret_sp) 
9625 3e 86			ld a, display_row_4+14 
9627 cd 62 94			call display_word_at 
962a			 
962a cd d2 8a			call update_display 
962d			 
962d			;	call delay1s 
962d			;	call delay1s 
962d			;	call delay1s 
962d			 
962d			 
962d			;	call next_page_prompt 
962d			 
962d				; restore  
962d			 
962d f1				pop af 
962e e1				pop hl 
962f c1				pop bc 
9630 d1				pop de 
9631 c9				ret 
9632			 
9632 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9646 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
965b .. 00		.ptrstate:	db "Ptr State",0 
9665 .. 00		.ptrcliptr:     db "cli_ptr",0 
966d .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9677 .. 00		.regstate:	db "Reg State (1/0)",0 
9687 .. 00		.regstatehl:	db "HL:",0 
968b .. 00		.regstatede:	db "DE:",0 
968f .. 00		.regstatebc:	db "BC:",0 
9693 .. 00		.regstatea:	db "A :",0 
9697 .. 00		.regstatedsp:	db "DSP:",0 
969c .. 00		.regstatersp:	db "RSP:",0 
96a1			 
96a1			display_dump_at_hl: 
96a1 e5				push hl 
96a2 d5				push de 
96a3 c5				push bc 
96a4 f5				push af 
96a5			 
96a5 22 ea e5			ld (os_cur_ptr),hl	 
96a8 cd af 8a			call clear_display 
96ab cd d3 99			call dumpcont 
96ae			;	call delay1s 
96ae			;	call next_page_prompt 
96ae			 
96ae			 
96ae f1				pop af 
96af c1				pop bc 
96b0 d1				pop de 
96b1 e1				pop hl 
96b2 c9				ret 
96b3			 
96b3			;if ENABLE_BASIC 
96b3			;	include "nascombasic.asm" 
96b3			;	basic: 
96b3			;	include "forth/FORTH.ASM" 
96b3			;endif 
96b3			 
96b3			; eof 
96b3			 
96b3			 
# End of file firmware_diags.asm
96b3			  
96b3			include "firmware_prompts.asm"  
96b3			; Prompts  
96b3			 
96b3			; boot messages 
96b3			 
96b3 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c8 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d8			 
96d8			 
96d8			; config menus 
96d8			 
96d8 .. 00		prom_c3: db "Add Dictionary To File",0 
96ef			 
96ef			if STARTUP_V1 
96ef .. 00		prom_c2: db "Select Autoload File",0 
9704 .. 00		prom_c2a: db "Disable Autoload File", 0 
971a			endif 
971a			 
971a			if STARTUP_V2 
971a			prom_c2: db "Enable Autoload Files",0 
971a			prom_c2a: db "Disable Autoload Files", 0 
971a			 
971a			crs_s1: db "*ls-word", 0 
971a			crs_s2: db "*ed-word", 0 
971a			crs_s3: db "*Demo-Programs", 0 
971a			crs_s4: db "*Utils", 0 
971a			crs_s5: db "*SPI-Addons", 0 
971a			crs_s6: db "*Key-constants", 0 
971a			 
971a			 
971a			 
971a			endif 
971a .. 00		prom_c2b: db "Select Storage Bank",0 
972e .. 00		prom_c4: db "Settings",0 
9737 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9752 .. 00		prom_m4b:   db "Monitor",0 
975a .. 00		prom_c1: db "Hardware Diags",0 
9769			 
9769			 
9769			if STARTUP_V2 
9769			prom_c9: db "Create Startup Files",0 
9769			endif 
9769			 
9769 .. 00		prom_notav:    db "Feature not available",0 
977f .. 00		prom_empty:    db "",0 
9780			 
9780			; eof 
9780			 
# End of file firmware_prompts.asm
9780			  
9780			  
9780			; eof  
9780			  
# End of file firmware.asm
9780			 
9780			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9780			;if BASE_KEV  
9780			;baseram: equ 08000h 
9780			;endif 
9780			 
9780			;if BASE_SC114 
9780			;baseram:     equ    endofcode 
9780			;endif 
9780			 
9780			 
9780			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9780			 
9780			; start system 
9780			 
9780			coldstart: 
9780				; set sp 
9780				; di/ei 
9780			 
9780 f3				di 
9781 31 00 f0			ld sp, tos 
9784			;	ei 
9784			 
9784				; init spinner 
9784 3e 00			ld a,0 
9786 32 cc eb			ld (display_active), a 
9789			 
9789				; disable breakpoint by default 
9789			 
9789 3e 2a			ld a,'*' 
978b 32 b8 e2			ld (os_view_disable),a 
978e			 
978e				; init hardware 
978e			 
978e				; init keyboard and screen hardware 
978e			 
978e cd 1c 80			call hardware_init 
9791			 
9791			 
9791 cd f2 89			call delay1s 
9794 3e 58			ld a, display_row_3+8 
9796 11 03 80			ld de, buildtime 
9799 cd c2 8a			call str_at_display 
979c cd d2 8a			call update_display 
979f			 
979f cd f2 89			call delay1s 
97a2 cd f2 89			call delay1s 
97a5 cd f2 89			call delay1s 
97a8			 
97a8				; detect if any keys are held down to enable breakpoints at start up 
97a8			 
97a8 cd 46 e3			call cin  
97ab fe 00			cp 0 
97ad 28 03			jr z, .nokeys 
97af			 
97af				;call hardware_diags 
97af cd 3c 93			call config 
97b2			 
97b2			;	ld de, .bpen 
97b2			;	ld a, display_row_4 
97b2			;	call str_at_display 
97b2			;	call update_display 
97b2			; 
97b2			;	ld a,0 
97b2			;	ld (os_view_disable),a 
97b2			; 
97b2			;.bpwait: 
97b2			;	call cin 
97b2			;	cp 0 
97b2			;	jr z, .bpwait 
97b2			;	jr .nokeys 
97b2			; 
97b2			; 
97b2			;.bpen:  db "Break points enabled!",0 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			.nokeys: 
97b2			 
97b2			 
97b2				 
97b2			 
97b2			;jp  testkey 
97b2			 
97b2			;call storage_get_block_0 
97b2			; 
97b2			;ld hl, 0 
97b2			;ld de, store_page 
97b2			;call storage_read_block 
97b2			 
97b2				 
97b2			;ld hl, 10 
97b2			;ld de, store_page 
97b2			;call storage_read_block 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			 
97b2			;stop:	nop 
97b2			;	jp stop 
97b2			 
97b2			 
97b2			 
97b2			main: 
97b2 cd af 8a			call clear_display 
97b5 cd d2 8a			call update_display 
97b8			 
97b8			 
97b8			 
97b8			;	call testlcd 
97b8			 
97b8			 
97b8			 
97b8 cd d0 9e			call forth_init 
97bb			 
97bb			 
97bb			warmstart: 
97bb cd a6 9e			call forth_warmstart 
97be			 
97be				; run startup word load 
97be			        ; TODO prevent this running at warmstart after crash  
97be			 
97be				if STARTUP_ENABLE 
97be			 
97be					if STARTUP_V1 
97be			 
97be						if STORAGE_SE 
97be							call forth_autoload 
97be						endif 
97be cd ed e1					call forth_startup 
97c1					endif 
97c1			 
97c1					if STARTUP_V2 
97c1			 
97c1						if STORAGE_SE 
97c1							call forth_autoload 
97c1						else 
97c1							call forth_startup 
97c1						endif 
97c1			 
97c1			 
97c1					endif 
97c1			 
97c1				endif 
97c1			 
97c1				; show free memory after boot 
97c1 11 5b 98			ld de, freeram 
97c4 3e 00			ld a, display_row_1 
97c6 cd c2 8a			call str_at_display 
97c9			 
97c9			; Or use heap_size word???? 
97c9 21 ad e2			ld hl, heap_end 
97cc 11 64 e3			ld de, heap_start 
97cf ed 52			sbc hl, de 
97d1 e5				push hl 
97d2 7c				ld a,h	         	 
97d3 21 cc e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97d6 cd dd 8f			call hexout 
97d9 e1			   	pop hl 
97da			 
97da 7d				ld a,l 
97db 21 ce e5			ld hl, os_word_scratch+2 
97de cd dd 8f			call hexout 
97e1 21 d0 e5			ld hl, os_word_scratch+4 
97e4 3e 00			ld a, 0 
97e6 77				ld (hl),a 
97e7 11 cc e5			ld de, os_word_scratch 
97ea 3e 0d			ld a, display_row_1 + 13 
97ec cd c2 8a			call str_at_display 
97ef cd d2 8a			call update_display 
97f2			 
97f2			 
97f2				;call demo 
97f2			 
97f2			 
97f2				; init scratch input area for cli commands 
97f2			 
97f2 21 ee e5			ld hl, os_cli_cmd 
97f5 3e 00			ld a,0 
97f7 77				ld (hl),a 
97f8 23				inc hl 
97f9 77				ld (hl),a 
97fa			 
97fa 3e 00			ld a,0 
97fc 32 ed e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97ff			 
97ff 32 ea e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9802 32 eb e5			ld (os_cur_ptr+1),a	 
9805			 
9805 32 cc e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9808 32 cd e5			ld (os_word_scratch+1),a	 
980b				 
980b			 
980b				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
980b 21 ee e5			ld hl, os_cli_cmd 
980e			 
980e 3e 00			ld a, 0		 ; init cli input 
9810 77				ld (hl), a 
9811 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9813			cli: 
9813				; show cli prompt 
9813				;push af 
9813				;ld a, 0 
9813				;ld de, prompt 
9813				;call str_at_display 
9813			 
9813				;call update_display 
9813				;pop af 
9813				;inc a 
9813				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9813 0e 00			ld c, 0 
9815 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9817 1e 28			ld e, 40 
9819			 
9819 21 ee e5			ld hl, os_cli_cmd 
981c			 
981c				STACKFRAME OFF $fefe $9f9f 
981c				if DEBUG_STACK_IMB 
981c					if OFF 
981c						exx 
981c						ld de, $fefe 
981c						ld a, d 
981c						ld hl, curframe 
981c						call hexout 
981c						ld a, e 
981c						ld hl, curframe+2 
981c						call hexout 
981c						ld hl, $fefe 
981c						push hl 
981c						ld hl, $9f9f 
981c						push hl 
981c						exx 
981c					endif 
981c				endif 
981c			endm 
# End of macro STACKFRAME
981c			 
981c cd 09 8d			call input_str 
981f			 
981f				STACKFRAMECHK OFF $fefe $9f9f 
981f				if DEBUG_STACK_IMB 
981f					if OFF 
981f						exx 
981f						ld hl, $9f9f 
981f						pop de   ; $9f9f 
981f						call cmp16 
981f						jr nz, .spnosame 
981f						ld hl, $fefe 
981f						pop de   ; $fefe 
981f						call cmp16 
981f						jr z, .spfrsame 
981f						.spnosame: call showsperror 
981f						.spfrsame: nop 
981f						exx 
981f					endif 
981f				endif 
981f			endm 
# End of macro STACKFRAMECHK
981f			 
981f				; copy input to last command 
981f			 
981f 21 ee e5			ld hl, os_cli_cmd 
9822 11 ed e6			ld de, os_last_cmd 
9825 01 ff 00			ld bc, 255 
9828 ed b0			ldir 
982a			 
982a				; wipe current buffer 
982a			 
982a			;	ld a, 0 
982a			;	ld hl, os_cli_cmd 
982a			;	ld de, os_cli_cmd+1 
982a			;	ld bc, 254 
982a			;	ldir 
982a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
982a			;	call strcpy 
982a			;	ld a, 0 
982a			;	ld (hl), a 
982a			;	inc hl 
982a			;	ld (hl), a 
982a			;	inc hl 
982a			;	ld (hl), a 
982a			 
982a				; switch frame buffer to program  
982a			 
982a 21 16 ed				ld hl, display_fb1 
982d 22 d2 eb				ld (display_fb_active), hl 
9830			 
9830			;	nop 
9830				STACKFRAME ON $fbfe $8f9f 
9830				if DEBUG_STACK_IMB 
9830					if ON 
9830						exx 
9830						ld de, $fbfe 
9830						ld a, d 
9830						ld hl, curframe 
9830						call hexout 
9830						ld a, e 
9830						ld hl, curframe+2 
9830						call hexout 
9830						ld hl, $fbfe 
9830						push hl 
9830						ld hl, $8f9f 
9830						push hl 
9830						exx 
9830					endif 
9830				endif 
9830			endm 
# End of macro STACKFRAME
9830				; first time into the parser so pass over the current scratch pad 
9830 21 ee e5			ld hl,os_cli_cmd 
9833				; tokenise the entered statement(s) in HL 
9833 cd 4e 9f			call forthparse 
9836			        ; exec forth statements in top of return stack 
9836 cd 8e 9f			call forthexec 
9839				;call forthexec_cleanup 
9839			;	call parsenext 
9839			 
9839				STACKFRAMECHK ON $fbfe $8f9f 
9839				if DEBUG_STACK_IMB 
9839					if ON 
9839						exx 
9839						ld hl, $8f9f 
9839						pop de   ; $8f9f 
9839						call cmp16 
9839						jr nz, .spnosame 
9839						ld hl, $fbfe 
9839						pop de   ; $fbfe 
9839						call cmp16 
9839						jr z, .spfrsame 
9839						.spnosame: call showsperror 
9839						.spfrsame: nop 
9839						exx 
9839					endif 
9839				endif 
9839			endm 
# End of macro STACKFRAMECHK
9839				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9839			 
9839 3e 78			ld a, display_row_4 
983b 11 6d 98			ld de, endprog 
983e			 
983e cd d2 8a			call update_display		 
9841			 
9841 cd cb 9a			call next_page_prompt 
9844			 
9844				; switch frame buffer to cli 
9844			 
9844 21 b7 ed				ld hl, display_fb0 
9847 22 d2 eb				ld (display_fb_active), hl 
984a			 
984a			 
984a cd af 8a		        call clear_display 
984d cd d2 8a			call update_display		 
9850			 
9850 21 ee e5			ld hl, os_cli_cmd 
9853			 
9853 3e 00			ld a, 0		 ; init cli input 
9855 77				ld (hl), a 
9856			 
9856				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9856			 
9856				; now on last line 
9856			 
9856				; TODO scroll screen up 
9856			 
9856				; TODO instead just clear screen and place at top of screen 
9856			 
9856			;	ld a, 0 
9856			;	ld (f_cursor_ptr),a 
9856			 
9856				;call clear_display 
9856				;call update_display 
9856			 
9856				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9856 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9858 c3 13 98			jp cli 
985b			 
985b .. 00		freeram: db "Free bytes: $",0 
9869 ..			asc: db "1A2F" 
986d .. 00		endprog: db "End prog...",0 
9879			 
9879			testenter2:   
9879 21 f9 e2			ld hl,scratch+50 
987c 22 ea e5			ld (os_cur_ptr),hl 
987f c3 13 98			jp cli 
9882			 
9882			testenter:  
9882			 
9882 21 69 98			ld hl,asc 
9885			;	ld a,(hl) 
9885			;	call nibble2val 
9885 cd 33 90			call get_byte 
9888			 
9888			 
9888			;	ld a,(hl) 
9888			;	call atohex 
9888			 
9888			;	call fourehexhl 
9888 32 f9 e2			ld (scratch+50),a 
988b			 
988b			 
988b			 
988b 21 6b 98			ld hl,asc+2 
988e			;	ld a, (hl) 
988e			;	call nibble2val 
988e cd 33 90			call get_byte 
9891			 
9891			;	call fourehexhl 
9891 32 fb e2			ld (scratch+52),a 
9894				 
9894 21 f9 e2			ld hl,scratch+50 
9897 22 ea e5			ld (os_cur_ptr),hl 
989a c3 13 98			jp cli 
989d			 
989d			enter:	 
989d 3a cb e2			ld a,(scratch+4) 
98a0 fe 00			cp 0 
98a2 28 0c			jr z, .entercont 
98a4				; no, not a null term line so has an address to work out.... 
98a4			 
98a4 21 c9 e2			ld hl,scratch+2 
98a7 cd 93 90			call get_word_hl 
98aa			 
98aa 22 ea e5			ld (os_cur_ptr),hl	 
98ad c3 13 98			jp cli 
98b0			 
98b0			 
98b0			.entercont:  
98b0			 
98b0 21 c9 e2			ld hl, scratch+2 
98b3 cd 33 90			call get_byte 
98b6			 
98b6 2a ea e5		   	ld hl,(os_cur_ptr) 
98b9 77					ld (hl),a 
98ba 23					inc hl 
98bb 22 ea e5				ld (os_cur_ptr),hl 
98be				 
98be			; get byte  
98be			 
98be			 
98be c3 13 98			jp cli 
98c1			 
98c1			 
98c1			; basic monitor support 
98c1			 
98c1			monitor: 
98c1				;  
98c1 cd af 8a			call clear_display 
98c4 3e 00			ld a, 0 
98c6 11 0e 99			ld de, .monprompt 
98c9 cd c2 8a			call str_at_display 
98cc cd d2 8a			call update_display 
98cf			 
98cf				; get a monitor command 
98cf			 
98cf 0e 00			ld c, 0     ; entry at top left 
98d1 16 64			ld d, 100   ; max buffer size 
98d3 1e 0f			ld e, 15    ; input scroll area 
98d5 3e 00			ld a, 0     ; init string 
98d7 21 c5 e4			ld hl, os_input 
98da 77				ld (hl), a 
98db 23				inc hl 
98dc 77				ld (hl), a 
98dd 21 c5 e4			ld hl, os_input 
98e0 3e 01			ld a, 1     ; init string 
98e2 cd 09 8d			call input_str 
98e5			 
98e5 cd af 8a		        call clear_display 
98e8 cd d2 8a			call update_display		 
98eb			 
98eb 3a c5 e4			ld a, (os_input) 
98ee cd 31 91			call toUpper 
98f1 fe 48		        cp 'H' 
98f3 28 6f		        jr z, .monhelp 
98f5 fe 44			cp 'D'		; dump 
98f7 ca 85 99			jp z, .mondump	 
98fa fe 43			cp 'C'		; dump 
98fc ca 9f 99			jp z, .moncdump	 
98ff fe 4d			cp 'M'		; dump 
9901 ca 10 99			jp z, .moneditstart 
9904 fe 55			cp 'U'		; dump 
9906 28 14			jr z, .monedit	 
9908 fe 51			cp 'Q'		; dump 
990a c8				ret z	 
990b			 
990b			 
990b				; TODO "S" to access symbol by name and not need the address 
990b				; TODO "F" to find a string in memory 
990b			 
990b c3 c1 98			jp monitor 
990e			 
990e .. 00		.monprompt: db ">", 0 
9910			 
9910			.moneditstart: 
9910				; get starting address 
9910			 
9910 21 c7 e4			ld hl,os_input+2 
9913 cd 93 90			call get_word_hl 
9916			 
9916 22 ea e5			ld (os_cur_ptr),hl	 
9919			 
9919 c3 c1 98			jp monitor 
991c			 
991c			.monedit: 
991c				; get byte to load 
991c			 
991c 21 c7 e4			ld hl,os_input+2 
991f cd 33 90			call get_byte 
9922			 
9922				; get address to update 
9922 2a ea e5			ld hl, (os_cur_ptr) 
9925			 
9925				; update byte 
9925			 
9925 77				ld (hl), a 
9926			 
9926				; move to next address and save it 
9926			 
9926 23				inc hl 
9927 22 ea e5			ld (os_cur_ptr),hl	 
992a			 
992a c3 c1 98			jp monitor 
992d			 
992d			 
992d .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9941 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
995d .. 00		.monhelptext3:  db "Q-Quit",0 
9964			        
9964			.monhelp: 
9964 3e 00			ld a, display_row_1 
9966 11 2d 99		        ld de, .monhelptext1 
9969			 
9969 cd c2 8a			call str_at_display 
996c 3e 28			ld a, display_row_2 
996e 11 41 99		        ld de, .monhelptext2 
9971					 
9971 cd c2 8a			call str_at_display 
9974 3e 50			ld a, display_row_3 
9976 11 5d 99		        ld de, .monhelptext3 
9979					 
9979 cd c2 8a			call str_at_display 
997c cd d2 8a			call update_display		 
997f			 
997f cd cb 9a			call next_page_prompt 
9982 c3 c1 98			jp monitor 
9985			 
9985			.mondump:    
9985 21 c7 e4			ld hl,os_input+2 
9988 cd 93 90			call get_word_hl 
998b			 
998b 22 ea e5			ld (os_cur_ptr),hl	 
998e cd d3 99			call dumpcont 
9991 3e 78			ld a, display_row_4 
9993 11 6d 98			ld de, endprog 
9996			 
9996 cd d2 8a			call update_display		 
9999			 
9999 cd cb 9a			call next_page_prompt 
999c c3 c1 98			jp monitor 
999f			.moncdump: 
999f cd d3 99			call dumpcont 
99a2 3e 78			ld a, display_row_4 
99a4 11 6d 98			ld de, endprog 
99a7			 
99a7 cd d2 8a			call update_display		 
99aa			 
99aa cd cb 9a			call next_page_prompt 
99ad c3 c1 98			jp monitor 
99b0			 
99b0			 
99b0			; TODO symbol access  
99b0			 
99b0			.symbols:     ;; A list of symbols that can be called up  
99b0 b7 ed			dw display_fb0 
99b2 .. 00			db "fb0",0  
99b6 80 ea		     	dw store_page 
99b8 .. 00			db "store_page",0 
99c3			 
99c3			 
99c3			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99c3			 
99c3 3a c8 e2			ld a,(scratch+1) 
99c6 fe 00			cp 0 
99c8 28 09			jr z, dumpcont 
99ca			 
99ca				; no, not a null term line so has an address to work out.... 
99ca			 
99ca 21 c9 e2			ld hl,scratch+2 
99cd cd 93 90			call get_word_hl 
99d0			 
99d0 22 ea e5			ld (os_cur_ptr),hl	 
99d3			 
99d3			 
99d3			 
99d3			dumpcont: 
99d3			 
99d3				; dump bytes at ptr 
99d3			 
99d3			 
99d3 3e 00			ld a, display_row_1 
99d5 2a d2 eb			ld hl, (display_fb_active) 
99d8 cd dc 8c			call addatohl 
99db cd 03 9a			call .dumpbyterow 
99de			 
99de 3e 28			ld a, display_row_2 
99e0 2a d2 eb			ld hl, (display_fb_active) 
99e3 cd dc 8c			call addatohl 
99e6 cd 03 9a			call .dumpbyterow 
99e9			 
99e9			 
99e9 3e 50			ld a, display_row_3 
99eb 2a d2 eb			ld hl, (display_fb_active) 
99ee cd dc 8c			call addatohl 
99f1 cd 03 9a			call .dumpbyterow 
99f4			 
99f4 3e 78			ld a, display_row_4 
99f6 2a d2 eb			ld hl, (display_fb_active) 
99f9 cd dc 8c			call addatohl 
99fc cd 03 9a			call .dumpbyterow 
99ff			 
99ff cd d2 8a			call update_display 
9a02			;		jp cli 
9a02 c9				ret 
9a03			 
9a03			.dumpbyterow: 
9a03			 
9a03				;push af 
9a03			 
9a03 e5				push hl 
9a04			 
9a04				; calc where to poke the ascii 
9a04			if display_cols == 20 
9a04				ld a, 16 
9a04			else 
9a04 3e 1f			ld a, 31 
9a06			endif 
9a06			 
9a06 cd dc 8c			call addatohl 
9a09 22 cc e5			ld (os_word_scratch),hl  		; save pos for later 
9a0c			 
9a0c			 
9a0c			; display decoding address 
9a0c 2a ea e5		   	ld hl,(os_cur_ptr) 
9a0f			 
9a0f 7c				ld a,h 
9a10 e1				pop hl 
9a11 e5				push hl 
9a12			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9a12 cd dd 8f			call hexout 
9a15 2a ea e5		   	ld hl,(os_cur_ptr) 
9a18			 
9a18 7d				ld a,l 
9a19 e1				pop hl 
9a1a 23				inc hl 
9a1b 23				inc hl 
9a1c e5				push hl 
9a1d			;	ld hl, os_word_scratch+2 
9a1d cd dd 8f			call hexout 
9a20 e1				pop hl 
9a21 23				inc hl 
9a22 23				inc hl 
9a23				;ld hl, os_word_scratch+4 
9a23 3e 3a			ld a, ':' 
9a25 77				ld (hl),a 
9a26 23				inc hl 
9a27				;ld a, 0 
9a27				;ld (hl),a 
9a27				;ld de, os_word_scratch 
9a27				;pop af 
9a27				;push af 
9a27			;		ld a, display_row_2 
9a27			;		call str_at_display 
9a27			;		call update_display 
9a27			 
9a27			 
9a27			;pop af 
9a27			;	add 5 
9a27			 
9a27			if display_cols == 20 
9a27				ld b, 4 
9a27			else 
9a27 06 08			ld b, 8 
9a29			endif	 
9a29			 
9a29			.dumpbyte: 
9a29 c5				push bc 
9a2a e5				push hl 
9a2b			 
9a2b			 
9a2b 2a ea e5		   	ld hl,(os_cur_ptr) 
9a2e 7e					ld a,(hl) 
9a2f			 
9a2f					; poke the ascii to display 
9a2f 2a cc e5				ld hl,(os_word_scratch) 
9a32 77					ld (hl),a 
9a33 23					inc hl 
9a34 22 cc e5				ld (os_word_scratch),hl 
9a37			 
9a37					 
9a37			 
9a37			 
9a37 e1					pop hl 
9a38 e5					push hl 
9a39			 
9a39 cd dd 8f				call hexout 
9a3c			 
9a3c					 
9a3c 2a ea e5		   	ld hl,(os_cur_ptr) 
9a3f 23				inc hl 
9a40 22 ea e5		   	ld (os_cur_ptr),hl 
9a43			 
9a43 e1					pop hl 
9a44 23					inc hl 
9a45 23					inc hl 
9a46 23					inc hl 
9a47			 
9a47			 
9a47			 
9a47					;ld a,0 
9a47					;ld (os_word_scratch+2),a 
9a47					;pop af 
9a47					;push af 
9a47			 
9a47					;ld de, os_word_scratch 
9a47					;call str_at_display 
9a47			;		call update_display 
9a47			;		pop af 
9a47 c1					pop bc 
9a48 c6 03				add 3 
9a4a 10 dd			djnz .dumpbyte 
9a4c			 
9a4c				 
9a4c			 
9a4c c9				ret 
9a4d			 
9a4d			jump:	 
9a4d			 
9a4d 21 c9 e2			ld hl,scratch+2 
9a50 cd 93 90			call get_word_hl 
9a53				;ld hl,(scratch+2) 
9a53				;call fourehexhl 
9a53			 
9a53 22 ea e5			ld (os_cur_ptr),hl	 
9a56			 
9a56 e9				jp (hl) 
9a57			 
9a57			 
9a57			 
9a57			; TODO implement a basic monitor mode to start with 
9a57			 
9a57			 
9a57			 
9a57			 
9a57			 
9a57			 
9a57			 
9a57			 
9a57			 
9a57			; testing and demo code during development 
9a57			 
9a57			 
9a57 .. 00		str1: db "Enter some text...",0 
9a6a .. 00		clear: db "                    ",0 
9a7f			 
9a7f			demo: 
9a7f			 
9a7f			 
9a7f			 
9a7f			;	call update_display 
9a7f			 
9a7f				; init scratch input area for testing 
9a7f 21 c7 e2			ld hl, scratch	 
9a82 3e 00			ld a,0 
9a84 77				ld (hl),a 
9a85			 
9a85			 
9a85 3e 28		            LD   A, display_row_2 
9a87			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a87 11 57 9a		            LD   DE, str1 
9a8a cd c2 8a			call str_at_display 
9a8d			 
9a8d			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a8d			cloop:	 
9a8d 3e 50		            LD   A, display_row_3 
9a8f			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a8f 11 6a 9a		            LD   DE, clear 
9a92			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a92 cd c2 8a				call str_at_display 
9a95 3e 78			ld a, display_row_4 
9a97 11 c7 9a			ld de, prompt 
9a9a			 
9a9a cd c2 8a				call str_at_display 
9a9d cd d2 8a			call update_display 
9aa0			 
9aa0 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9aa2 16 0a			ld d, 10 
9aa4 21 c7 e2			ld hl, scratch	 
9aa7 cd 09 8d			call input_str 
9aaa			 
9aaa			;	call clear_display 
9aaa			;'	call update_display 
9aaa			 
9aaa 3e 00		            LD   A, display_row_1 
9aac			;            CALL fLCD_Pos       ;Position cursor to location in A 
9aac 11 6a 9a		            LD   DE, clear 
9aaf cd c2 8a				call str_at_display 
9ab2			;            CALL fLCD_Str       ;Display string pointed to by DE 
9ab2 3e 00		            LD   A, display_row_1 
9ab4			;            CALL fLCD_Pos       ;Position cursor to location in A 
9ab4 11 c7 e2		            LD   DE, scratch 
9ab7			;            CALL fLCD_Str       ;Display string pointed to by DE 
9ab7 cd c2 8a				call str_at_display 
9aba cd d2 8a			call update_display 
9abd			 
9abd 3e 00				ld a,0 
9abf 21 c7 e2			ld hl, scratch 
9ac2 77				ld (hl),a 
9ac3			 
9ac3 00				nop 
9ac4 c3 8d 9a			jp cloop 
9ac7			 
9ac7			 
9ac7			 
9ac7			; OS Prompt 
9ac7			 
9ac7 .. 00		prompt: db ">",0 
9ac9 .. 00		endprg: db "?",0 
9acb			 
9acb			 
9acb			; handy next page prompt 
9acb			next_page_prompt: 
9acb e5				push hl 
9acc d5				push de 
9acd f5				push af 
9ace c5				push bc 
9acf			 
9acf 3e 9f			ld a,display_row_4 + display_cols - 1 
9ad1 11 c9 9a		        ld de, endprg 
9ad4 cd c2 8a			call str_at_display 
9ad7 cd d2 8a			call update_display 
9ada cd 40 e3			call cin_wait 
9add c1				pop bc 
9ade f1				pop af 
9adf d1				pop de 
9ae0 e1				pop hl 
9ae1			 
9ae1			 
9ae1 c9				ret 
9ae2			 
9ae2			 
9ae2			; forth parser 
9ae2			 
9ae2			; My forth kernel 
9ae2			include "forth_kernel.asm" 
9ae2			; 
9ae2			; kernel to the forth OS 
9ae2			 
9ae2			DS_TYPE_STR: equ 1     ; string type 
9ae2			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9ae2			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9ae2			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9ae2			 
9ae2			FORTH_PARSEV1: equ 0 
9ae2			FORTH_PARSEV2: equ 0 
9ae2			FORTH_PARSEV3: equ 0 
9ae2			FORTH_PARSEV4: equ 0 
9ae2			FORTH_PARSEV5: equ 1 
9ae2			 
9ae2			;if FORTH_PARSEV5 
9ae2			;	FORTH_END_BUFFER: equ 0 
9ae2			;else 
9ae2			FORTH_END_BUFFER: equ 127 
9ae2			;endif 
9ae2			 
9ae2			FORTH_TRUE: equ 1 
9ae2			FORTH_FALSE: equ 0 
9ae2			 
9ae2			if FORTH_PARSEV4 
9ae2			include "forth_stackops.asm" 
9ae2			endif 
9ae2			 
9ae2			if FORTH_PARSEV5 
9ae2			include "forth_stackopsv5.asm" 
9ae2			 
9ae2			; Stack operations for v5 parser on wards 
9ae2			; * DATA stack 
9ae2			; * LOOP stack 
9ae2			; * RETURN stack 
9ae2			 
9ae2			 
9ae2			 
9ae2			FORTH_CHK_DSP_UNDER: macro 
9ae2				push hl 
9ae2				push de 
9ae2				ld hl,(cli_data_sp) 
9ae2				ld de, cli_data_stack 
9ae2				call cmp16 
9ae2				jp c, fault_dsp_under 
9ae2				pop de 
9ae2				pop hl 
9ae2				endm 
9ae2			 
9ae2			 
9ae2			FORTH_CHK_RSP_UNDER: macro 
9ae2				push hl 
9ae2				push de 
9ae2				ld hl,(cli_ret_sp) 
9ae2				ld de, cli_ret_stack 
9ae2				call cmp16 
9ae2				jp c, fault_rsp_under 
9ae2				pop de 
9ae2				pop hl 
9ae2				endm 
9ae2			 
9ae2			FORTH_CHK_LOOP_UNDER: macro 
9ae2				push hl 
9ae2				push de 
9ae2				ld hl,(cli_loop_sp) 
9ae2				ld de, cli_loop_stack 
9ae2				call cmp16 
9ae2				jp c, fault_loop_under 
9ae2				pop de 
9ae2				pop hl 
9ae2				endm 
9ae2			 
9ae2			FORTH_ERR_TOS_NOTSTR: macro 
9ae2				; TOSO might need more for checks when used 
9ae2				push af 
9ae2				ld a,(hl) 
9ae2				cp DS_TYPE_STR 
9ae2				jp nz, type_faultn   
9ae2				pop af 
9ae2				endm 
9ae2			 
9ae2			FORTH_ERR_TOS_NOTNUM: macro 
9ae2				push af 
9ae2				ld a,(hl) 
9ae2				cp DS_TYPE_INUM 
9ae2				jp nz, type_faultn   
9ae2				pop af 
9ae2				endm 
9ae2			 
9ae2			 
9ae2			; increase data stack pointer and save hl to it 
9ae2				 
9ae2			FORTH_DSP_NEXT: macro 
9ae2				call macro_forth_dsp_next 
9ae2				endm 
9ae2			 
9ae2			 
9ae2			macro_forth_dsp_next: 
9ae2				if DEBUG_FORTH_STACK_GUARD 
9ae2 cd ce df				call check_stacks 
9ae5				endif 
9ae5 e5				push hl 
9ae6 d5				push de 
9ae7 eb				ex de,hl 
9ae8 2a f4 e9			ld hl,(cli_data_sp) 
9aeb 23				inc hl 
9aec 23				inc hl 
9aed			 
9aed			; PARSEV5 
9aed 23				inc hl 
9aee 22 f4 e9			ld (cli_data_sp),hl 
9af1 73				ld (hl), e 
9af2 23				inc hl 
9af3 72				ld (hl), d 
9af4 d1				pop de 
9af5 e1				pop hl 
9af6				if DEBUG_FORTH_STACK_GUARD 
9af6 cd ce df				call check_stacks 
9af9				endif 
9af9 c9				ret 
9afa			 
9afa			 
9afa			; increase ret stack pointer and save hl to it 
9afa				 
9afa			FORTH_RSP_NEXT: macro 
9afa				call macro_forth_rsp_next 
9afa				endm 
9afa			 
9afa			macro_forth_rsp_next: 
9afa				if DEBUG_FORTH_STACK_GUARD 
9afa cd ce df				call check_stacks 
9afd				endif 
9afd e5				push hl 
9afe d5				push de 
9aff eb				ex de,hl 
9b00 2a f8 e9			ld hl,(cli_ret_sp) 
9b03 23				inc hl 
9b04 23				inc hl 
9b05 22 f8 e9			ld (cli_ret_sp),hl 
9b08 73				ld (hl), e 
9b09 23				inc hl 
9b0a 72				ld (hl), d 
9b0b d1				pop de 
9b0c e1				pop hl 
9b0d				if DEBUG_FORTH_STACK_GUARD 
9b0d cd ce df				call check_stacks 
9b10				endif 
9b10 c9				ret 
9b11			 
9b11			; get current ret stack pointer and save to hl  
9b11				 
9b11			FORTH_RSP_TOS: macro 
9b11				call macro_forth_rsp_tos 
9b11				endm 
9b11			 
9b11			macro_forth_rsp_tos: 
9b11				;push de 
9b11 2a f8 e9			ld hl,(cli_ret_sp) 
9b14 cd 4c 9b			call loadhlptrtohl 
9b17				;ld e, (hl) 
9b17				;inc hl 
9b17				;ld d, (hl) 
9b17				;ex de, hl 
9b17					if DEBUG_FORTH_WORDS 
9b17			;			DMARK "RST" 
9b17						CALLMONITOR 
9b17 cd dd 94			call break_point_state  
9b1a				endm  
# End of macro CALLMONITOR
9b1a					endif 
9b1a				;pop de 
9b1a c9				ret 
9b1b			 
9b1b			; pop ret stack pointer 
9b1b				 
9b1b			FORTH_RSP_POP: macro 
9b1b				call macro_forth_rsp_pop 
9b1b				endm 
9b1b			 
9b1b			 
9b1b			macro_forth_rsp_pop: 
9b1b				if DEBUG_FORTH_STACK_GUARD 
9b1b			;		DMARK "RPP" 
9b1b cd ce df				call check_stacks 
9b1e					FORTH_CHK_RSP_UNDER 
9b1e e5				push hl 
9b1f d5				push de 
9b20 2a f8 e9			ld hl,(cli_ret_sp) 
9b23 11 b2 e9			ld de, cli_ret_stack 
9b26 cd fa 8c			call cmp16 
9b29 da e2 e0			jp c, fault_rsp_under 
9b2c d1				pop de 
9b2d e1				pop hl 
9b2e				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b2e				endif 
9b2e e5				push hl 
9b2f 2a f8 e9			ld hl,(cli_ret_sp) 
9b32			 
9b32			 
9b32				if FORTH_ENABLE_FREE 
9b32			 
9b32					; get pointer 
9b32			 
9b32					push de 
9b32					push hl 
9b32			 
9b32					ld e, (hl) 
9b32					inc hl 
9b32					ld d, (hl) 
9b32			 
9b32					ex de, hl 
9b32					call free 
9b32			 
9b32					pop hl 
9b32					pop de 
9b32			 
9b32			 
9b32				endif 
9b32			 
9b32			 
9b32 2b				dec hl 
9b33 2b				dec hl 
9b34 22 f8 e9			ld (cli_ret_sp), hl 
9b37				; do stack underflow checks 
9b37 e1				pop hl 
9b38				if DEBUG_FORTH_STACK_GUARD 
9b38 cd ce df				call check_stacks 
9b3b					FORTH_CHK_RSP_UNDER 
9b3b e5				push hl 
9b3c d5				push de 
9b3d 2a f8 e9			ld hl,(cli_ret_sp) 
9b40 11 b2 e9			ld de, cli_ret_stack 
9b43 cd fa 8c			call cmp16 
9b46 da e2 e0			jp c, fault_rsp_under 
9b49 d1				pop de 
9b4a e1				pop hl 
9b4b				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b4b				endif 
9b4b c9				ret 
9b4c			 
9b4c			 
9b4c			 
9b4c			; routine to load word pointed to by hl into hl 
9b4c			 
9b4c			loadhlptrtohl: 
9b4c			 
9b4c d5				push de 
9b4d 5e				ld e, (hl) 
9b4e 23				inc hl 
9b4f 56				ld d, (hl) 
9b50 eb				ex de, hl 
9b51 d1				pop de 
9b52			 
9b52 c9				ret 
9b53			 
9b53			 
9b53			 
9b53			 
9b53			 
9b53			; push a number held in HL onto the data stack 
9b53			; entry point for pushing a value when already in hl used in function above 
9b53			 
9b53			forth_push_numhl: 
9b53			 
9b53 e5				push hl    ; save value to push 
9b54			 
9b54			if DEBUG_FORTH_PUSH 
9b54				; see if disabled 
9b54			 
9b54			 
9b54 f5				push af 
9b55 3a b8 e2			ld a, (os_view_disable) 
9b58 fe 2a			cp '*' 
9b5a 28 34			jr z, .pskip2 
9b5c e5				push hl 
9b5d e5			push hl 
9b5e cd af 8a			call clear_display 
9b61 e1			pop hl 
9b62 7c				ld a,h 
9b63 21 cc e5			ld hl, os_word_scratch 
9b66 cd dd 8f			call hexout 
9b69 e1				pop hl 
9b6a 7d				ld a,l 
9b6b 21 ce e5			ld hl, os_word_scratch+2 
9b6e cd dd 8f			call hexout 
9b71			 
9b71 21 d0 e5			ld hl, os_word_scratch+4 
9b74 3e 00			ld a,0 
9b76 77				ld (hl),a 
9b77 11 cc e5			ld de,os_word_scratch 
9b7a 3e 28				ld a, display_row_2 
9b7c cd c2 8a				call str_at_display 
9b7f 11 b3 cb			ld de, .push_num 
9b82 3e 00			ld a, display_row_1 
9b84			 
9b84 cd c2 8a				call str_at_display 
9b87			 
9b87			 
9b87 cd d2 8a			call update_display 
9b8a cd f2 89			call delay1s 
9b8d cd f2 89			call delay1s 
9b90			.pskip2:  
9b90			 
9b90 f1				pop af 
9b91			endif	 
9b91			 
9b91			 
9b91				FORTH_DSP_NEXT 
9b91 cd e2 9a			call macro_forth_dsp_next 
9b94				endm 
# End of macro FORTH_DSP_NEXT
9b94			 
9b94 2a f4 e9			ld hl, (cli_data_sp) 
9b97			 
9b97				; save item type 
9b97 3e 02			ld a,  DS_TYPE_INUM 
9b99 77				ld (hl), a 
9b9a 23				inc hl 
9b9b			 
9b9b				; get word off stack 
9b9b d1				pop de 
9b9c 7b				ld a,e 
9b9d 77				ld (hl), a 
9b9e 23				inc hl 
9b9f 7a				ld a,d 
9ba0 77				ld (hl), a 
9ba1			 
9ba1			if DEBUG_FORTH_PUSH 
9ba1 2b				dec hl 
9ba2 2b				dec hl 
9ba3 2b				dec hl 
9ba4						DMARK "PH5" 
9ba4 f5				push af  
9ba5 3a b9 9b			ld a, (.dmark)  
9ba8 32 71 ee			ld (debug_mark),a  
9bab 3a ba 9b			ld a, (.dmark+1)  
9bae 32 72 ee			ld (debug_mark+1),a  
9bb1 3a bb 9b			ld a, (.dmark+2)  
9bb4 32 73 ee			ld (debug_mark+2),a  
9bb7 18 03			jr .pastdmark  
9bb9 ..			.dmark: db "PH5"  
9bbc f1			.pastdmark: pop af  
9bbd			endm  
# End of macro DMARK
9bbd				CALLMONITOR 
9bbd cd dd 94			call break_point_state  
9bc0				endm  
# End of macro CALLMONITOR
9bc0			endif	 
9bc0			 
9bc0 c9				ret 
9bc1			 
9bc1			 
9bc1			; Push a string to stack pointed to by hl 
9bc1			 
9bc1			forth_push_str: 
9bc1			 
9bc1			if DEBUG_FORTH_PUSH 
9bc1						DMARK "PSQ" 
9bc1 f5				push af  
9bc2 3a d6 9b			ld a, (.dmark)  
9bc5 32 71 ee			ld (debug_mark),a  
9bc8 3a d7 9b			ld a, (.dmark+1)  
9bcb 32 72 ee			ld (debug_mark+1),a  
9bce 3a d8 9b			ld a, (.dmark+2)  
9bd1 32 73 ee			ld (debug_mark+2),a  
9bd4 18 03			jr .pastdmark  
9bd6 ..			.dmark: db "PSQ"  
9bd9 f1			.pastdmark: pop af  
9bda			endm  
# End of macro DMARK
9bda				CALLMONITOR 
9bda cd dd 94			call break_point_state  
9bdd				endm  
# End of macro CALLMONITOR
9bdd			endif	 
9bdd			    
9bdd e5				push hl 
9bde e5				push hl 
9bdf			 
9bdf			;	ld a, 0   ; find end of string 
9bdf cd 3a 91			call strlenz 
9be2			if DEBUG_FORTH_PUSH 
9be2						DMARK "PQ2" 
9be2 f5				push af  
9be3 3a f7 9b			ld a, (.dmark)  
9be6 32 71 ee			ld (debug_mark),a  
9be9 3a f8 9b			ld a, (.dmark+1)  
9bec 32 72 ee			ld (debug_mark+1),a  
9bef 3a f9 9b			ld a, (.dmark+2)  
9bf2 32 73 ee			ld (debug_mark+2),a  
9bf5 18 03			jr .pastdmark  
9bf7 ..			.dmark: db "PQ2"  
9bfa f1			.pastdmark: pop af  
9bfb			endm  
# End of macro DMARK
9bfb				CALLMONITOR 
9bfb cd dd 94			call break_point_state  
9bfe				endm  
# End of macro CALLMONITOR
9bfe			endif	 
9bfe eb				ex de, hl 
9bff e1				pop hl   ; get ptr to start of string 
9c00			if DEBUG_FORTH_PUSH 
9c00						DMARK "PQ3" 
9c00 f5				push af  
9c01 3a 15 9c			ld a, (.dmark)  
9c04 32 71 ee			ld (debug_mark),a  
9c07 3a 16 9c			ld a, (.dmark+1)  
9c0a 32 72 ee			ld (debug_mark+1),a  
9c0d 3a 17 9c			ld a, (.dmark+2)  
9c10 32 73 ee			ld (debug_mark+2),a  
9c13 18 03			jr .pastdmark  
9c15 ..			.dmark: db "PQ3"  
9c18 f1			.pastdmark: pop af  
9c19			endm  
# End of macro DMARK
9c19				CALLMONITOR 
9c19 cd dd 94			call break_point_state  
9c1c				endm  
# End of macro CALLMONITOR
9c1c			endif	 
9c1c 19				add hl,de 
9c1d			if DEBUG_FORTH_PUSH 
9c1d						DMARK "PQE" 
9c1d f5				push af  
9c1e 3a 32 9c			ld a, (.dmark)  
9c21 32 71 ee			ld (debug_mark),a  
9c24 3a 33 9c			ld a, (.dmark+1)  
9c27 32 72 ee			ld (debug_mark+1),a  
9c2a 3a 34 9c			ld a, (.dmark+2)  
9c2d 32 73 ee			ld (debug_mark+2),a  
9c30 18 03			jr .pastdmark  
9c32 ..			.dmark: db "PQE"  
9c35 f1			.pastdmark: pop af  
9c36			endm  
# End of macro DMARK
9c36				CALLMONITOR 
9c36 cd dd 94			call break_point_state  
9c39				endm  
# End of macro CALLMONITOR
9c39			endif	 
9c39			 
9c39 2b				dec hl    ; see if there is an optional trailing double quote 
9c3a 7e				ld a,(hl) 
9c3b fe 22			cp '"' 
9c3d 20 03			jr nz, .strnoq 
9c3f 3e 00			ld a, 0      ; get rid of double quote 
9c41 77				ld (hl), a 
9c42 23			.strnoq: inc hl 
9c43			 
9c43 3e 00			ld a, 0 
9c45 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c46			 
9c46 13				inc de ; add one for the type string 
9c47 13				inc de ; add one for null term??? 
9c48			 
9c48				; tos is get string pointer again 
9c48				; de contains space to allocate 
9c48				 
9c48 d5				push de 
9c49			 
9c49 eb				ex de, hl 
9c4a			 
9c4a				;push af 
9c4a			 
9c4a			if DEBUG_FORTH_PUSH 
9c4a						DMARK "PHm" 
9c4a f5				push af  
9c4b 3a 5f 9c			ld a, (.dmark)  
9c4e 32 71 ee			ld (debug_mark),a  
9c51 3a 60 9c			ld a, (.dmark+1)  
9c54 32 72 ee			ld (debug_mark+1),a  
9c57 3a 61 9c			ld a, (.dmark+2)  
9c5a 32 73 ee			ld (debug_mark+2),a  
9c5d 18 03			jr .pastdmark  
9c5f ..			.dmark: db "PHm"  
9c62 f1			.pastdmark: pop af  
9c63			endm  
# End of macro DMARK
9c63				CALLMONITOR 
9c63 cd dd 94			call break_point_state  
9c66				endm  
# End of macro CALLMONITOR
9c66			endif	 
9c66 cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c69				if DEBUG_FORTH_MALLOC_GUARD 
9c69 cc 0b cc				call z,malloc_error 
9c6c				endif 
9c6c			 
9c6c				 
9c6c c1				pop bc    ; get length 
9c6d d1				pop de   ;  get string start    
9c6e			 
9c6e				; hl has destination from malloc 
9c6e			 
9c6e eb				ex de, hl    ; prep for ldir 
9c6f			 
9c6f d5				push de   ; save malloc area for DSP later 
9c70				;push hl   ; save malloc area for DSP later 
9c70			 
9c70			if DEBUG_FORTH_PUSH 
9c70						DMARK "PHc" 
9c70 f5				push af  
9c71 3a 85 9c			ld a, (.dmark)  
9c74 32 71 ee			ld (debug_mark),a  
9c77 3a 86 9c			ld a, (.dmark+1)  
9c7a 32 72 ee			ld (debug_mark+1),a  
9c7d 3a 87 9c			ld a, (.dmark+2)  
9c80 32 73 ee			ld (debug_mark+2),a  
9c83 18 03			jr .pastdmark  
9c85 ..			.dmark: db "PHc"  
9c88 f1			.pastdmark: pop af  
9c89			endm  
# End of macro DMARK
9c89				CALLMONITOR 
9c89 cd dd 94			call break_point_state  
9c8c				endm  
# End of macro CALLMONITOR
9c8c			endif	 
9c8c			 
9c8c			 
9c8c ed b0			ldir 
9c8e			 
9c8e			 
9c8e				; push malloc to data stack     macro?????  
9c8e			 
9c8e				FORTH_DSP_NEXT 
9c8e cd e2 9a			call macro_forth_dsp_next 
9c91				endm 
# End of macro FORTH_DSP_NEXT
9c91			 
9c91				; save value and type 
9c91			 
9c91 2a f4 e9			ld hl, (cli_data_sp) 
9c94			 
9c94				; save item type 
9c94 3e 01			ld a,  DS_TYPE_STR 
9c96 77				ld (hl), a 
9c97 23				inc hl 
9c98			 
9c98				; get malloc word off stack 
9c98 d1				pop de 
9c99 73				ld (hl), e 
9c9a 23				inc hl 
9c9b 72				ld (hl), d 
9c9c			 
9c9c			 
9c9c			 
9c9c			if DEBUG_FORTH_PUSH 
9c9c 2a f4 e9			ld hl, (cli_data_sp) 
9c9f						DMARK "PHS" 
9c9f f5				push af  
9ca0 3a b4 9c			ld a, (.dmark)  
9ca3 32 71 ee			ld (debug_mark),a  
9ca6 3a b5 9c			ld a, (.dmark+1)  
9ca9 32 72 ee			ld (debug_mark+1),a  
9cac 3a b6 9c			ld a, (.dmark+2)  
9caf 32 73 ee			ld (debug_mark+2),a  
9cb2 18 03			jr .pastdmark  
9cb4 ..			.dmark: db "PHS"  
9cb7 f1			.pastdmark: pop af  
9cb8			endm  
# End of macro DMARK
9cb8				CALLMONITOR 
9cb8 cd dd 94			call break_point_state  
9cbb				endm  
# End of macro CALLMONITOR
9cbb			;	ex de,hl 
9cbb			endif	 
9cbb				; in case of spaces, skip the ptr past the copied string 
9cbb				;pop af 
9cbb				;ld (cli_origptr),hl 
9cbb			 
9cbb c9				ret 
9cbc			 
9cbc			 
9cbc			 
9cbc			; TODO ascii push input onto stack given hl to start of input 
9cbc			 
9cbc			; identify type 
9cbc			; if starts with a " then a string 
9cbc			; otherwise it is a number 
9cbc			;  
9cbc			; if a string 
9cbc			;     scan for ending " to get length of string to malloc for + 1 
9cbc			;     malloc 
9cbc			;     put pointer to string on stack first byte flags as string 
9cbc			; 
9cbc			; else a number 
9cbc			;    look for number format identifier 
9cbc			;    $xx hex 
9cbc			;    %xxxxx bin 
9cbc			;    xxxxx decimal 
9cbc			;    convert number to 16bit word.  
9cbc			;    malloc word + 1 with flag to identiy as num 
9cbc			;    put pointer to number on stack 
9cbc			;   
9cbc			;  
9cbc			  
9cbc			forth_apush: 
9cbc				; kernel push 
9cbc			 
9cbc			if DEBUG_FORTH_PUSH 
9cbc						DMARK "PSH" 
9cbc f5				push af  
9cbd 3a d1 9c			ld a, (.dmark)  
9cc0 32 71 ee			ld (debug_mark),a  
9cc3 3a d2 9c			ld a, (.dmark+1)  
9cc6 32 72 ee			ld (debug_mark+1),a  
9cc9 3a d3 9c			ld a, (.dmark+2)  
9ccc 32 73 ee			ld (debug_mark+2),a  
9ccf 18 03			jr .pastdmark  
9cd1 ..			.dmark: db "PSH"  
9cd4 f1			.pastdmark: pop af  
9cd5			endm  
# End of macro DMARK
9cd5				CALLMONITOR 
9cd5 cd dd 94			call break_point_state  
9cd8				endm  
# End of macro CALLMONITOR
9cd8			endif	 
9cd8				; identify input type 
9cd8			 
9cd8 7e				ld a,(hl) 
9cd9 fe 22			cp '"' 
9cdb 28 0a			jr z, .fapstr 
9cdd fe 24			cp '$' 
9cdf ca 07 9d			jp z, .faphex 
9ce2 fe 25			cp '%' 
9ce4 ca ef 9c			jp z, .fapbin 
9ce7			;	cp 'b' 
9ce7			;	jp z, .fabin 
9ce7				; else decimal 
9ce7			 
9ce7				; TODO do decimal conversion 
9ce7				; decimal is stored as a 16bit word 
9ce7			 
9ce7				; by default everything is a string if type is not detected 
9ce7			.fapstr: ; 
9ce7 fe 22			cp '"' 
9ce9 20 01			jr nz, .strnoqu 
9ceb 23				inc hl 
9cec			.strnoqu: 
9cec c3 c1 9b			jp forth_push_str 
9cef			 
9cef			 
9cef			 
9cef			.fapbin:    ; push a binary string.  
9cef 11 00 00			ld de, 0   ; hold a 16bit value 
9cf2			 
9cf2 23			.fapbinshift:	inc hl  
9cf3 7e				ld a,(hl) 
9cf4 fe 00			cp 0     ; done scanning  
9cf6 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cf8			 
9cf8				; left shift de 
9cf8 eb				ex de, hl	 
9cf9 29				add hl, hl 
9cfa			 
9cfa				; is 1 
9cfa fe 31			cp '1' 
9cfc 20 02			jr nz, .binzero 
9cfe cb 4d			bit 1, l 
9d00			.binzero: 
9d00 eb				ex de, hl	 ; save current de 
9d01 18 ef			jr .fapbinshift 
9d03			 
9d03			.fapbdone: 
9d03 eb				ex de, hl 
9d04 c3 53 9b			jp forth_push_numhl 
9d07			 
9d07			 
9d07			.faphex:   ; hex is always stored as a 16bit word 
9d07				; skip number prefix 
9d07 23				inc hl 
9d08				; turn ascii into number 
9d08 cd 93 90			call get_word_hl	; ret 16bit word in hl 
9d0b			 
9d0b c3 53 9b			jp forth_push_numhl 
9d0e			 
9d0e 00				 nop 
9d0f			 
9d0f			.fabin:   ; TODO bin conversion 
9d0f			 
9d0f			 
9d0f c9				ret 
9d10			 
9d10			 
9d10			; get either a string ptr or a 16bit word from the data stack 
9d10			 
9d10			FORTH_DSP: macro 
9d10				call macro_forth_dsp 
9d10				endm 
9d10			 
9d10			macro_forth_dsp: 
9d10				; data stack pointer points to current word on tos 
9d10			 
9d10 2a f4 e9			ld hl,(cli_data_sp) 
9d13			 
9d13				if DEBUG_FORTH_PUSH 
9d13						DMARK "DSP" 
9d13 f5				push af  
9d14 3a 28 9d			ld a, (.dmark)  
9d17 32 71 ee			ld (debug_mark),a  
9d1a 3a 29 9d			ld a, (.dmark+1)  
9d1d 32 72 ee			ld (debug_mark+1),a  
9d20 3a 2a 9d			ld a, (.dmark+2)  
9d23 32 73 ee			ld (debug_mark+2),a  
9d26 18 03			jr .pastdmark  
9d28 ..			.dmark: db "DSP"  
9d2b f1			.pastdmark: pop af  
9d2c			endm  
# End of macro DMARK
9d2c			 
9d2c cd 40 cc				call display_data_sp 
9d2f				;call break_point_state 
9d2f				;rst 030h 
9d2f				CALLMONITOR 
9d2f cd dd 94			call break_point_state  
9d32				endm  
# End of macro CALLMONITOR
9d32				endif 
9d32			 
9d32 c9				ret 
9d33			 
9d33			; return hl to start of value on stack 
9d33			 
9d33			FORTH_DSP_VALUE: macro 
9d33				call macro_forth_dsp_value 
9d33				endm 
9d33			 
9d33			macro_forth_dsp_value: 
9d33			 
9d33				FORTH_DSP 
9d33 cd 10 9d			call macro_forth_dsp 
9d36				endm 
# End of macro FORTH_DSP
9d36			 
9d36 d5				push de 
9d37			 
9d37 23				inc hl ; skip type 
9d38			 
9d38 5e				ld e, (hl) 
9d39 23				inc hl 
9d3a 56				ld d, (hl) 
9d3b eb				ex de,hl  
9d3c			 
9d3c d1				pop de 
9d3d			 
9d3d c9				ret 
9d3e			 
9d3e			; return hl to start of value to second item on stack 
9d3e			 
9d3e			FORTH_DSP_VALUEM1: macro 
9d3e				call macro_forth_dsp_value_m1 
9d3e				endm 
9d3e			 
9d3e			macro_forth_dsp_value_m1: 
9d3e			 
9d3e				FORTH_DSP 
9d3e cd 10 9d			call macro_forth_dsp 
9d41				endm 
# End of macro FORTH_DSP
9d41			 
9d41 2b				dec hl 
9d42 2b				dec hl 
9d43			;	dec hl 
9d43			 
9d43 d5				push de 
9d44			 
9d44 5e				ld e, (hl) 
9d45 23				inc hl 
9d46 56				ld d, (hl) 
9d47 eb				ex de,hl  
9d48			 
9d48 d1				pop de 
9d49			 
9d49 c9				ret 
9d4a			 
9d4a				 
9d4a			 
9d4a			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d4a			 
9d4a			FORTH_DSP_POP: macro 
9d4a				call macro_forth_dsp_pop 
9d4a				endm 
9d4a			 
9d4a			 
9d4a			; get the tos data type 
9d4a			 
9d4a			FORTH_DSP_TYPE:   macro 
9d4a			 
9d4a				;FORTH_DSP_VALUE 
9d4a				FORTH_DSP 
9d4a				 
9d4a				; hl points to value 
9d4a				; check type 
9d4a			 
9d4a				ld a,(hl) 
9d4a			 
9d4a				endm 
9d4a			 
9d4a			; load the tos value into hl 
9d4a			 
9d4a			 
9d4a			FORTH_DSP_VALUEHL:  macro 
9d4a				call macro_dsp_valuehl 
9d4a				endm 
9d4a			 
9d4a			 
9d4a			 
9d4a			macro_dsp_valuehl: 
9d4a				FORTH_DSP_VALUE 
9d4a cd 33 9d			call macro_forth_dsp_value 
9d4d				endm 
# End of macro FORTH_DSP_VALUE
9d4d			 
9d4d				;FORTH_ERR_TOS_NOTNUM 
9d4d			 
9d4d				;inc hl   ; skip type id 
9d4d			 
9d4d			;	push de 
9d4d			; 
9d4d			;	ld e, (hl) 
9d4d			;	inc hl 
9d4d			;	ld d, (hl) 
9d4d			;	ex de,hl  
9d4d			 
9d4d			;	pop de 
9d4d			 
9d4d				if DEBUG_FORTH_PUSH 
9d4d						DMARK "DVL" 
9d4d f5				push af  
9d4e 3a 62 9d			ld a, (.dmark)  
9d51 32 71 ee			ld (debug_mark),a  
9d54 3a 63 9d			ld a, (.dmark+1)  
9d57 32 72 ee			ld (debug_mark+1),a  
9d5a 3a 64 9d			ld a, (.dmark+2)  
9d5d 32 73 ee			ld (debug_mark+2),a  
9d60 18 03			jr .pastdmark  
9d62 ..			.dmark: db "DVL"  
9d65 f1			.pastdmark: pop af  
9d66			endm  
# End of macro DMARK
9d66				CALLMONITOR 
9d66 cd dd 94			call break_point_state  
9d69				endm  
# End of macro CALLMONITOR
9d69				endif 
9d69 c9				ret 
9d6a			 
9d6a			forth_apushstrhl:      
9d6a				; push of string requires use of cli_origptr 
9d6a				; bodge use 
9d6a			 
9d6a				; get current cli_origptr, save, update with temp pointer  
9d6a ed 5b 44 ea		ld de, (cli_origptr) 
9d6e 22 44 ea			ld (cli_origptr), hl 
9d71 d5				push de 
9d72 cd bc 9c			call forth_apush 
9d75 d1				pop de 
9d76 ed 53 44 ea		ld (cli_origptr), de 
9d7a c9			        ret	 
9d7b			 
9d7b			 
9d7b			; increase loop stack pointer and save hl to it 
9d7b				 
9d7b			FORTH_LOOP_NEXT: macro 
9d7b				call macro_forth_loop_next 
9d7b				;nop 
9d7b				endm 
9d7b			 
9d7b			macro_forth_loop_next: 
9d7b				if DEBUG_FORTH_STACK_GUARD 
9d7b cd ce df				call check_stacks 
9d7e				endif 
9d7e e5				push hl 
9d7f d5				push de 
9d80 eb				ex de,hl 
9d81 2a f6 e9			ld hl,(cli_loop_sp) 
9d84 23				inc hl 
9d85 23				inc hl 
9d86					if DEBUG_FORTH_WORDS 
9d86						DMARK "LNX" 
9d86 f5				push af  
9d87 3a 9b 9d			ld a, (.dmark)  
9d8a 32 71 ee			ld (debug_mark),a  
9d8d 3a 9c 9d			ld a, (.dmark+1)  
9d90 32 72 ee			ld (debug_mark+1),a  
9d93 3a 9d 9d			ld a, (.dmark+2)  
9d96 32 73 ee			ld (debug_mark+2),a  
9d99 18 03			jr .pastdmark  
9d9b ..			.dmark: db "LNX"  
9d9e f1			.pastdmark: pop af  
9d9f			endm  
# End of macro DMARK
9d9f						CALLMONITOR 
9d9f cd dd 94			call break_point_state  
9da2				endm  
# End of macro CALLMONITOR
9da2					endif 
9da2 22 f6 e9			ld (cli_loop_sp),hl 
9da5 73				ld (hl), e 
9da6 23				inc hl 
9da7 72				ld (hl), d 
9da8 d1				pop de    ; been reversed so save a swap on restore 
9da9 e1				pop hl 
9daa				if DEBUG_FORTH_STACK_GUARD 
9daa cd ce df				call check_stacks 
9dad				endif 
9dad c9				ret 
9dae			 
9dae			; get current ret stack pointer and save to hl  
9dae				 
9dae			FORTH_LOOP_TOS: macro 
9dae				call macro_forth_loop_tos 
9dae				endm 
9dae			 
9dae			macro_forth_loop_tos: 
9dae d5				push de 
9daf 2a f6 e9			ld hl,(cli_loop_sp) 
9db2 5e				ld e, (hl) 
9db3 23				inc hl 
9db4 56				ld d, (hl) 
9db5 eb				ex de, hl 
9db6 d1				pop de 
9db7 c9				ret 
9db8			 
9db8			; pop loop stack pointer 
9db8				 
9db8			FORTH_LOOP_POP: macro 
9db8				call macro_forth_loop_pop 
9db8				endm 
9db8			 
9db8			 
9db8			macro_forth_loop_pop: 
9db8				if DEBUG_FORTH_STACK_GUARD 
9db8					DMARK "LPP" 
9db8 f5				push af  
9db9 3a cd 9d			ld a, (.dmark)  
9dbc 32 71 ee			ld (debug_mark),a  
9dbf 3a ce 9d			ld a, (.dmark+1)  
9dc2 32 72 ee			ld (debug_mark+1),a  
9dc5 3a cf 9d			ld a, (.dmark+2)  
9dc8 32 73 ee			ld (debug_mark+2),a  
9dcb 18 03			jr .pastdmark  
9dcd ..			.dmark: db "LPP"  
9dd0 f1			.pastdmark: pop af  
9dd1			endm  
# End of macro DMARK
9dd1 cd ce df				call check_stacks 
9dd4					FORTH_CHK_LOOP_UNDER 
9dd4 e5				push hl 
9dd5 d5				push de 
9dd6 2a f6 e9			ld hl,(cli_loop_sp) 
9dd9 11 30 e9			ld de, cli_loop_stack 
9ddc cd fa 8c			call cmp16 
9ddf da e8 e0			jp c, fault_loop_under 
9de2 d1				pop de 
9de3 e1				pop hl 
9de4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9de4				endif 
9de4 e5				push hl 
9de5 2a f6 e9			ld hl,(cli_loop_sp) 
9de8 2b				dec hl 
9de9 2b				dec hl 
9dea 22 f6 e9			ld (cli_loop_sp), hl 
9ded				; TODO do stack underflow checks 
9ded e1				pop hl 
9dee				if DEBUG_FORTH_STACK_GUARD 
9dee cd ce df				call check_stacks 
9df1					FORTH_CHK_LOOP_UNDER 
9df1 e5				push hl 
9df2 d5				push de 
9df3 2a f6 e9			ld hl,(cli_loop_sp) 
9df6 11 30 e9			ld de, cli_loop_stack 
9df9 cd fa 8c			call cmp16 
9dfc da e8 e0			jp c, fault_loop_under 
9dff d1				pop de 
9e00 e1				pop hl 
9e01				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9e01				endif 
9e01 c9				ret 
9e02			 
9e02			macro_forth_dsp_pop: 
9e02			 
9e02 e5				push hl 
9e03			 
9e03				; release malloc data 
9e03			 
9e03				if DEBUG_FORTH_STACK_GUARD 
9e03 cd ce df				call check_stacks 
9e06					FORTH_CHK_DSP_UNDER 
9e06 e5				push hl 
9e07 d5				push de 
9e08 2a f4 e9			ld hl,(cli_data_sp) 
9e0b 11 2e e8			ld de, cli_data_stack 
9e0e cd fa 8c			call cmp16 
9e11 da dc e0			jp c, fault_dsp_under 
9e14 d1				pop de 
9e15 e1				pop hl 
9e16				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e16				endif 
9e16				;ld hl,(cli_data_sp) 
9e16			if DEBUG_FORTH_DOT 
9e16				DMARK "DPP" 
9e16 f5				push af  
9e17 3a 2b 9e			ld a, (.dmark)  
9e1a 32 71 ee			ld (debug_mark),a  
9e1d 3a 2c 9e			ld a, (.dmark+1)  
9e20 32 72 ee			ld (debug_mark+1),a  
9e23 3a 2d 9e			ld a, (.dmark+2)  
9e26 32 73 ee			ld (debug_mark+2),a  
9e29 18 03			jr .pastdmark  
9e2b ..			.dmark: db "DPP"  
9e2e f1			.pastdmark: pop af  
9e2f			endm  
# End of macro DMARK
9e2f				CALLMONITOR 
9e2f cd dd 94			call break_point_state  
9e32				endm  
# End of macro CALLMONITOR
9e32			endif	 
9e32			 
9e32			 
9e32			if FORTH_ENABLE_DSPPOPFREE 
9e32			 
9e32				FORTH_DSP 
9e32 cd 10 9d			call macro_forth_dsp 
9e35				endm 
# End of macro FORTH_DSP
9e35			 
9e35 7e				ld a, (hl) 
9e36 fe 01			cp DS_TYPE_STR 
9e38 20 23			jr nz, .skippopfree 
9e3a			 
9e3a				FORTH_DSP_VALUEHL 
9e3a cd 4a 9d			call macro_dsp_valuehl 
9e3d				endm 
# End of macro FORTH_DSP_VALUEHL
9e3d 00				nop 
9e3e			if DEBUG_FORTH_DOT 
9e3e				DMARK "DPf" 
9e3e f5				push af  
9e3f 3a 53 9e			ld a, (.dmark)  
9e42 32 71 ee			ld (debug_mark),a  
9e45 3a 54 9e			ld a, (.dmark+1)  
9e48 32 72 ee			ld (debug_mark+1),a  
9e4b 3a 55 9e			ld a, (.dmark+2)  
9e4e 32 73 ee			ld (debug_mark+2),a  
9e51 18 03			jr .pastdmark  
9e53 ..			.dmark: db "DPf"  
9e56 f1			.pastdmark: pop af  
9e57			endm  
# End of macro DMARK
9e57				CALLMONITOR 
9e57 cd dd 94			call break_point_state  
9e5a				endm  
# End of macro CALLMONITOR
9e5a			endif	 
9e5a cd 6d 92			call free 
9e5d			.skippopfree: 
9e5d				 
9e5d			 
9e5d			endif 
9e5d			 
9e5d			if DEBUG_FORTH_DOT_KEY 
9e5d				DMARK "DP2" 
9e5d				CALLMONITOR 
9e5d			endif	 
9e5d			 
9e5d				; move pointer down 
9e5d			 
9e5d 2a f4 e9			ld hl,(cli_data_sp) 
9e60 2b				dec hl 
9e61 2b				dec hl 
9e62			; PARSEV5 
9e62 2b				dec hl 
9e63 22 f4 e9			ld (cli_data_sp), hl 
9e66			 
9e66				if DEBUG_FORTH_STACK_GUARD 
9e66 cd ce df				call check_stacks 
9e69					FORTH_CHK_DSP_UNDER 
9e69 e5				push hl 
9e6a d5				push de 
9e6b 2a f4 e9			ld hl,(cli_data_sp) 
9e6e 11 2e e8			ld de, cli_data_stack 
9e71 cd fa 8c			call cmp16 
9e74 da dc e0			jp c, fault_dsp_under 
9e77 d1				pop de 
9e78 e1				pop hl 
9e79				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e79				endif 
9e79			 
9e79 e1				pop hl 
9e7a			 
9e7a c9				ret 
9e7b			 
9e7b			getwordathl: 
9e7b				; hl points to an address 
9e7b				; load hl with the word at that address 
9e7b			 
9e7b d5				push de 
9e7c			 
9e7c 5e				ld e, (hl) 
9e7d 23				inc hl 
9e7e 56				ld d, (hl) 
9e7f eb				ex de, hl 
9e80			 
9e80 d1				pop de 
9e81 c9				ret 
9e82			 
9e82			 
9e82			 
9e82			 
9e82			 
9e82			; eof 
9e82			 
# End of file forth_stackopsv5.asm
9e82			endif 
9e82			 
9e82			loadwordinhl:	 
9e82			 
9e82 d5				push de 
9e83			 
9e83 5e				ld e, (hl) 
9e84 23				inc hl 
9e85 56				ld d, (hl) 
9e86 eb				ex de,hl  
9e87			 
9e87 d1				pop de 
9e88			 
9e88 c9				ret 
9e89			 
9e89			user_word_eol:  
9e89				; hl contains the pointer to where to create a linked list item from the end 
9e89				; of the user dict to continue on at the system word dict 
9e89				 
9e89				; poke the stub of the word list linked list to repoint to rom words 
9e89			 
9e89				; stub format 
9e89				; db   word id 
9e89				; dw    link to next word 
9e89			        ; db char length of token 
9e89				; db string + 0 term 
9e89				; db exec code....  
9e89			 
9e89 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e8b 77				ld (hl), a		; word id 
9e8c 23				inc hl 
9e8d			 
9e8d 11 58 a0			ld de, sysdict 
9e90 73				ld (hl), e		; next word link ie system dict 
9e91 23				inc hl 
9e92 72				ld (hl), d		; next word link ie system dict 
9e93 23				inc hl	 
9e94			 
9e94			;	ld (hl), sysdict		; next word link ie system dict 
9e94			;	inc hl 
9e94			;	inc hl 
9e94			 
9e94			;	inc hl 
9e94			;	inc hl 
9e94			 
9e94 3e 02			ld a, 2			; word length is 0 
9e96 77				ld (hl), a	 
9e97 23				inc hl 
9e98			 
9e98 3e 7e			ld a, '~'			; word length is 0 
9e9a 77				ld (hl), a	 
9e9b 23				inc hl 
9e9c 3e 00			ld a, 0			; save empty word 
9e9e 77				ld (hl), a 
9e9f			 
9e9f c9				ret 
9ea0			 
9ea0				 
9ea0			 
9ea0			forthexec_cleanup: 
9ea0				FORTH_RSP_POP 
9ea0 cd 1b 9b			call macro_forth_rsp_pop 
9ea3				endm 
# End of macro FORTH_RSP_POP
9ea3 c9				ret 
9ea4			 
9ea4			forth_call_hl: 
9ea4				; taking hl 
9ea4 e5				push hl 
9ea5 c9				ret 
9ea6			 
9ea6			; this is called to reset Forth system but keep existing uwords etc 
9ea6			 
9ea6			forth_warmstart: 
9ea6				; setup stack over/under flow checks 
9ea6				if DEBUG_FORTH_STACK_GUARD 
9ea6 cd b4 df				call chk_stk_init 
9ea9				endif 
9ea9			 
9ea9				; init stack pointers  - * these stacks go upwards *  
9ea9 21 b2 e9			ld hl, cli_ret_stack 
9eac 22 f8 e9			ld (cli_ret_sp), hl	 
9eaf				; set bottom of stack 
9eaf 3e 00			ld a,0 
9eb1 77				ld (hl),a 
9eb2 23				inc hl 
9eb3 77				ld (hl),a 
9eb4			 
9eb4 21 2e e8			ld hl, cli_data_stack 
9eb7 22 f4 e9			ld (cli_data_sp), hl	 
9eba				; set bottom of stack 
9eba 3e 00			ld a,0 
9ebc 77				ld (hl),a 
9ebd 23				inc hl 
9ebe 77				ld (hl),a 
9ebf			 
9ebf 21 30 e9			ld hl, cli_loop_stack 
9ec2 22 f6 e9			ld (cli_loop_sp), hl	 
9ec5				; set bottom of stack 
9ec5 3e 00			ld a,0 
9ec7 77				ld (hl),a 
9ec8 23				inc hl 
9ec9 77				ld (hl),a 
9eca			 
9eca				; init extent of current open file 
9eca			 
9eca 3e 00			ld a, 0 
9ecc 32 70 ea			ld (store_openext), a 
9ecf			 
9ecf c9				ret 
9ed0			 
9ed0			 
9ed0			; Cold Start - this is called to setup the whole Forth system 
9ed0			 
9ed0			forth_init: 
9ed0			 
9ed0				; setup stack over/under flow checks 
9ed0			 
9ed0			;	if DEBUG_FORTH_STACK_GUARD 
9ed0			;		call chk_stk_init 
9ed0			;	endif 
9ed0			 
9ed0				; enable auto display updates (slow.....) 
9ed0			 
9ed0 3e 01			ld a, 1 
9ed2 32 42 ea			ld (cli_autodisplay), a 
9ed5			 
9ed5				; if storage is in use disable long reads for now 
9ed5 3e 00			ld a, 0 
9ed7 32 7b ea			ld (store_longread), a 
9eda			 
9eda			 
9eda				; show start up screen 
9eda			 
9eda cd af 8a			call clear_display 
9edd			 
9edd 3e 00			ld a,0 
9edf 32 64 ea			ld (f_cursor_ptr), a 
9ee2			 
9ee2				; set start of word list in start of ram - for use when creating user words 
9ee2			 
9ee2 21 55 e3			ld hl, baseram 
9ee5 22 c4 e5			ld (os_last_new_uword), hl 
9ee8 cd 89 9e			call user_word_eol 
9eeb				 
9eeb			;		call display_data_sp 
9eeb			;		call next_page_prompt 
9eeb			 
9eeb			 
9eeb			 
9eeb			 
9eeb c9				ret 
9eec			 
9eec .. 00		.bootforth: db " Forth Kernel Init ",0 
9f00			 
9f00			; TODO push to stack 
9f00			 
9f00			;  
9f00			 
9f00			if FORTH_PARSEV2 
9f00			 
9f00			 
9f00				include "forth_parserv2.asm" 
9f00			 
9f00			endif 
9f00			 
9f00			 
9f00			; parse cli version 1 
9f00			 
9f00			if FORTH_PARSEV1 
9f00			 
9f00			 
9f00			 
9f00			      include "forth_parserv1.asm" 
9f00			endif 
9f00				 
9f00			if FORTH_PARSEV3 
9f00			 
9f00			 
9f00			 
9f00			      include "forth_parserv3.asm" 
9f00				include "forth_wordsv3.asm" 
9f00			endif 
9f00			 
9f00			if FORTH_PARSEV4 
9f00			 
9f00			 
9f00			 
9f00			      include "forth_parserv4.asm" 
9f00				include "forth_wordsv4.asm" 
9f00			endif 
9f00			 
9f00			if FORTH_PARSEV5 
9f00			 
9f00			 
9f00			 
9f00			      include "forth_parserv5.asm" 
9f00			 
9f00			 
9f00			; A better parser without using malloc and string copies all over the place.  
9f00			; Exec in situ should be faster 
9f00			 
9f00			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9f00			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9f00			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9f00			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9f00			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9f00			WORD_SYS_END: equ 0   ; Opcode for all user words 
9f00			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9f00			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9f00			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9f00			 
9f00			; Core word preamble macro 
9f00			 
9f00			CWHEAD:   macro nxtword opcode lit len opflags 
9f00				db WORD_SYS_CORE+opcode             
9f00				; internal op code number 
9f00				dw nxtword            
9f00				; link to next dict word block 
9f00				db len + 1 
9f00				; literal length of dict word inc zero term 
9f00				db lit,0              
9f00				; literal dict word 
9f00			        ; TODO db opflags        
9f00				endm 
9f00			 
9f00			 
9f00			NEXTW: macro  
9f00				jp macro_next 
9f00				endm 
9f00			 
9f00			macro_next: 
9f00			if DEBUG_FORTH_PARSE_KEY 
9f00				DMARK "NXT" 
9f00				CALLMONITOR 
9f00			endif	 
9f00			;	inc hl  ; skip token null term  
9f00 ed 4b 46 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f04 ed 5b 44 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f08 2a c8 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f0b			if DEBUG_FORTH_PARSE_KEY 
9f0b				DMARK "}AA" 
9f0b				CALLMONITOR 
9f0b			endif	 
9f0b c3 0e a0			jp execnext 
9f0e				;jp exec1 
9f0e			       
9f0e			 
9f0e			 
9f0e			; Another go at the parser to compile  
9f0e			 
9f0e			 
9f0e			; TODO rework parser to change all of the string words to byte tokens 
9f0e			; TODO do a search for  
9f0e			 
9f0e			; TODO first run normal parser to zero term sections 
9f0e			; TODO for each word do a token look up to get the op code 
9f0e			; TODO need some means to flag to the exec that this is a byte code form    
9f0e			 
9f0e			 
9f0e			forthcompile: 
9f0e			 
9f0e			; 
9f0e			; line parse: 
9f0e			;       parse raw input buffer 
9f0e			;       tokenise the words 
9f0e			;       malloc new copy (for looping etc) 
9f0e			;       copy to malloc + current pc in line to start of string and add line term 
9f0e			;       save on new rsp 
9f0e			; 
9f0e			 
9f0e			; hl to point to the line to tokenise 
9f0e			 
9f0e			;	push hl 
9f0e 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f11			 
9f11			;	ld a,0		; string term on input 
9f11			;	call strlent 
9f11			 
9f11			;	ld (os_tok_len), hl	 ; save string length 
9f11			 
9f11			;if DEBUG_FORTH_TOK 
9f11			;	ex de,hl		 
9f11			;endif 
9f11			 
9f11			;	pop hl 		; get back string pointer 
9f11			 
9f11			if DEBUG_FORTH_TOK 
9f11						DMARK "TOc" 
9f11				CALLMONITOR 
9f11			endif 
9f11 7e			.cptoken2:    ld a,(hl) 
9f12 23				inc hl 
9f13 fe 7f			cp FORTH_END_BUFFER 
9f15 28 29			jr z, .cptokendone2 
9f17 fe 00			cp 0 
9f19 28 25			jr z, .cptokendone2 
9f1b fe 22			cp '"' 
9f1d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f1f fe 20			cp ' ' 
9f21 20 ee			jr nz,  .cptoken2 
9f23			 
9f23			; TODO consume comments held between ( and ) 
9f23			 
9f23				; we have a space so change to zero term for dict match later 
9f23 2b				dec hl 
9f24 3e 00			ld a,0 
9f26 77				ld (hl), a 
9f27 23				inc hl 
9f28 18 e7			jr .cptoken2 
9f2a				 
9f2a			 
9f2a			.cptokenstr2: 
9f2a				; skip all white space until either eol (because forgot to term) or end double quote 
9f2a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f2a				;inc hl ; skip current double quote 
9f2a 7e				ld a,(hl) 
9f2b 23				inc hl 
9f2c fe 22			cp '"' 
9f2e 28 e1			jr z, .cptoken2 
9f30 fe 7f			cp FORTH_END_BUFFER 
9f32 28 0c			jr z, .cptokendone2 
9f34 fe 00			cp 0 
9f36 28 08			jr z, .cptokendone2 
9f38 fe 20			cp ' ' 
9f3a 28 02			jr z, .cptmp2 
9f3c 18 ec			jr .cptokenstr2 
9f3e			 
9f3e			.cptmp2:	; we have a space so change to zero term for dict match later 
9f3e				;dec hl 
9f3e				;ld a,"-"	; TODO remove this when working 
9f3e				;ld (hl), a 
9f3e				;inc hl 
9f3e 18 ea			jr .cptokenstr2 
9f40			 
9f40			.cptokendone2: 
9f40				;inc hl 
9f40 3e 7f			ld a, FORTH_END_BUFFER 
9f42 77				ld (hl),a 
9f43 23				inc hl 
9f44 3e 21			ld a, '!' 
9f46 77				ld (hl),a 
9f47			 
9f47 2a c8 e5			ld hl,(os_tok_ptr) 
9f4a			         
9f4a			if DEBUG_FORTH_TOK 
9f4a						DMARK "Tc1" 
9f4a				CALLMONITOR 
9f4a			endif 
9f4a			 
9f4a				; push exec string to top of return stack 
9f4a				FORTH_RSP_NEXT 
9f4a cd fa 9a			call macro_forth_rsp_next 
9f4d				endm 
# End of macro FORTH_RSP_NEXT
9f4d c9				ret 
9f4e			 
9f4e			; Another go at the parser need to simplify the process 
9f4e			 
9f4e			forthparse: 
9f4e			 
9f4e			; 
9f4e			; line parse: 
9f4e			;       parse raw input buffer 
9f4e			;       tokenise the words 
9f4e			;       malloc new copy (for looping etc) 
9f4e			;       copy to malloc + current pc in line to start of string and add line term 
9f4e			;       save on new rsp 
9f4e			; 
9f4e			 
9f4e			; hl to point to the line to tokenise 
9f4e			 
9f4e			;	push hl 
9f4e 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f51			 
9f51			;	ld a,0		; string term on input 
9f51			;	call strlent 
9f51			 
9f51			;	ld (os_tok_len), hl	 ; save string length 
9f51			 
9f51			;if DEBUG_FORTH_TOK 
9f51			;	ex de,hl		 
9f51			;endif 
9f51			 
9f51			;	pop hl 		; get back string pointer 
9f51			 
9f51			if DEBUG_FORTH_TOK 
9f51						DMARK "TOK" 
9f51				CALLMONITOR 
9f51			endif 
9f51 7e			.ptoken2:    ld a,(hl) 
9f52 23				inc hl 
9f53 fe 7f			cp FORTH_END_BUFFER 
9f55 28 29			jr z, .ptokendone2 
9f57 fe 00			cp 0 
9f59 28 25			jr z, .ptokendone2 
9f5b fe 22			cp '"' 
9f5d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f5f fe 20			cp ' ' 
9f61 20 ee			jr nz,  .ptoken2 
9f63			 
9f63			; TODO consume comments held between ( and ) 
9f63			 
9f63				; we have a space so change to zero term for dict match later 
9f63 2b				dec hl 
9f64 3e 00			ld a,0 
9f66 77				ld (hl), a 
9f67 23				inc hl 
9f68 18 e7			jr .ptoken2 
9f6a				 
9f6a			 
9f6a			.ptokenstr2: 
9f6a				; skip all white space until either eol (because forgot to term) or end double quote 
9f6a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f6a				;inc hl ; skip current double quote 
9f6a 7e				ld a,(hl) 
9f6b 23				inc hl 
9f6c fe 22			cp '"' 
9f6e 28 e1			jr z, .ptoken2 
9f70 fe 7f			cp FORTH_END_BUFFER 
9f72 28 0c			jr z, .ptokendone2 
9f74 fe 00			cp 0 
9f76 28 08			jr z, .ptokendone2 
9f78 fe 20			cp ' ' 
9f7a 28 02			jr z, .ptmp2 
9f7c 18 ec			jr .ptokenstr2 
9f7e			 
9f7e			.ptmp2:	; we have a space so change to zero term for dict match later 
9f7e				;dec hl 
9f7e				;ld a,"-"	; TODO remove this when working 
9f7e				;ld (hl), a 
9f7e				;inc hl 
9f7e 18 ea			jr .ptokenstr2 
9f80			 
9f80			.ptokendone2: 
9f80				;inc hl 
9f80 3e 7f			ld a, FORTH_END_BUFFER 
9f82 77				ld (hl),a 
9f83 23				inc hl 
9f84 3e 21			ld a, '!' 
9f86 77				ld (hl),a 
9f87			 
9f87 2a c8 e5			ld hl,(os_tok_ptr) 
9f8a			         
9f8a			if DEBUG_FORTH_TOK 
9f8a						DMARK "TK1" 
9f8a				CALLMONITOR 
9f8a			endif 
9f8a			 
9f8a				; push exec string to top of return stack 
9f8a				FORTH_RSP_NEXT 
9f8a cd fa 9a			call macro_forth_rsp_next 
9f8d				endm 
# End of macro FORTH_RSP_NEXT
9f8d c9				ret 
9f8e			 
9f8e			; 
9f8e			;	; malloc size + buffer pointer + if is loop flag 
9f8e			;	ld hl,(os_tok_len) 		 ; get string length 
9f8e			; 
9f8e			;	ld a,l 
9f8e			; 
9f8e			;	cp 0			; we dont want to use a null string 
9f8e			;	ret z 
9f8e			; 
9f8e			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f8e			; 
9f8e			;	add 5     ; TODO when certain not over writing memory remove 
9f8e			; 
9f8e			;		 
9f8e			; 
9f8e			;if DEBUG_FORTH_TOK 
9f8e			;			DMARK "TKE" 
9f8e			;	CALLMONITOR 
9f8e			;endif 
9f8e			; 
9f8e			;	ld l,a 
9f8e			;	ld h,0 
9f8e			;;	push hl   ; save required space for the copy later 
9f8e			;	call malloc 
9f8e			;if DEBUG_FORTH_TOK 
9f8e			;			DMARK "TKM" 
9f8e			;	CALLMONITOR 
9f8e			;endif 
9f8e			;	if DEBUG_FORTH_MALLOC_GUARD 
9f8e			;		push af 
9f8e			;		call ishlzero 
9f8e			;;		ld a, l 
9f8e			;;		add h 
9f8e			;;		cp 0 
9f8e			;		pop af 
9f8e			;		 
9f8e			;		call z,malloc_error 
9f8e			;	endif 
9f8e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f8e			; 
9f8e			; 
9f8e			;if DEBUG_FORTH_TOK 
9f8e			;			DMARK "TKR" 
9f8e			;	CALLMONITOR 
9f8e			;endif 
9f8e			; 
9f8e			;	FORTH_RSP_NEXT 
9f8e			; 
9f8e			;	;inc hl	 ; go past current buffer pointer 
9f8e			;	;inc hl 
9f8e			;	;inc hl   ; and past if loop flag 
9f8e			;		; TODO Need to set flag  
9f8e			; 
9f8e			;	 
9f8e			;	 
9f8e			;	ex de,hl	; malloc is dest 
9f8e			;	ld hl, (os_tok_len) 
9f8e			;;	pop bc 
9f8e			;	ld c, l                
9f8e			;	ld b,0 
9f8e			;	ld hl, (os_tok_ptr) 
9f8e			; 
9f8e			;if DEBUG_FORTH_TOK 
9f8e			;			DMARK "TKT" 
9f8e			;	CALLMONITOR 
9f8e			;endif 
9f8e			; 
9f8e			;	; do str cpy 
9f8e			; 
9f8e			;	ldir      ; copy byte in hl to de 
9f8e			; 
9f8e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f8e			; 
9f8e			;if DEBUG_FORTH_TOK 
9f8e			; 
9f8e			;			DMARK "TKY" 
9f8e			;	CALLMONITOR 
9f8e			;endif 
9f8e			;	;ld a,0 
9f8e			;	;ld a,FORTH_END_BUFFER 
9f8e			;	ex de, hl 
9f8e			;	;dec hl			 ; go back over the space delim at the end of word 
9f8e			;	;ld (hl),a 
9f8e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f8e			;	ld a,FORTH_END_BUFFER 
9f8e			;	ld (hl),a 
9f8e			;	inc hl 
9f8e			;	ld a,FORTH_END_BUFFER 
9f8e			;	ld (hl),a 
9f8e			; 
9f8e			;	; init the malloc area data 
9f8e			;	; set pc for in current area 
9f8e			;	;ld hl, (os_tok_malloc) 
9f8e			;	;inc hl 
9f8e			;	;inc hl 
9f8e			;	;inc hl 
9f8e			;	;ex de,hl 
9f8e			;	;ld hl, (os_tok_malloc) 
9f8e			;	;ld (hl),e 
9f8e			;	;inc hl 
9f8e			;	;ld (hl),d 
9f8e			; 
9f8e			; 
9f8e			;	ld hl,(os_tok_malloc) 
9f8e			;if DEBUG_FORTH_PARSE_KEY 
9f8e			;			DMARK "TKU" 
9f8e			;	CALLMONITOR 
9f8e			;endif 
9f8e			; 
9f8e			;	ret 
9f8e			 
9f8e			forthexec: 
9f8e			 
9f8e			; line exec: 
9f8e			; forth parser 
9f8e			 
9f8e			; 
9f8e			;       get current exec line on rsp 
9f8e			 
9f8e				FORTH_RSP_TOS 
9f8e cd 11 9b			call macro_forth_rsp_tos 
9f91				endm 
# End of macro FORTH_RSP_TOS
9f91			 
9f91			;       restore current pc - hl points to malloc of data 
9f91			 
9f91				;ld e, (hl) 
9f91				;inc hl 
9f91				;ld d, (hl) 
9f91				;ex de,hl 
9f91			 
9f91			 
9f91			exec1: 
9f91 22 c8 e5			ld (os_tok_ptr), hl 
9f94			 
9f94				; copy our PC to working vars  
9f94 22 46 ea			ld (cli_ptr), hl 
9f97 22 44 ea			ld (cli_origptr), hl 
9f9a			 
9f9a 7e				ld a,(hl) 
9f9b fe 7f			cp FORTH_END_BUFFER 
9f9d c8				ret z 
9f9e			 
9f9e				; skip any nulls 
9f9e			 
9f9e fe 00			cp 0 
9fa0 20 03			jr nz, .execword 
9fa2 23				inc hl 
9fa3 18 ec			jr exec1 
9fa5			 
9fa5			 
9fa5			.execword: 
9fa5			 
9fa5			 
9fa5			 
9fa5			if DEBUG_FORTH_PARSE_KEY 
9fa5						DMARK "KYQ" 
9fa5				CALLMONITOR 
9fa5			endif 
9fa5			;       while at start of word: 
9fa5			; get start of dict (in user area first) 
9fa5			 
9fa5 21 55 e3		ld hl, baseram 
9fa8			;ld hl, sysdict 
9fa8 22 48 ea		ld (cli_nextword),hl 
9fab			;           match word at pc 
9fab			;           exec word 
9fab			;           or push to dsp 
9fab			;           forward to next token 
9fab			;           if line term pop rsp and exit 
9fab			;        
9fab			 
9fab			if DEBUG_FORTH_PARSE_KEY 
9fab						DMARK "KYq" 
9fab				CALLMONITOR 
9fab			endif 
9fab			 
9fab			; 
9fab			; word comp 
9fab			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9fab			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9fab			;    move to start of word  
9fab			;    compare word to cli_token 
9fab			 
9fab			.execpnword:	; HL at start of a word in the dictionary to check 
9fab			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9fab			;	ld (cli_ptr), hl 
9fab			 
9fab 2a 48 ea			ld hl,(cli_nextword) 
9fae			 
9fae cd 51 a0			call forth_tok_next 
9fb1			; tok next start here 
9fb1			;	; TODO skip compiled symbol for now 
9fb1			;	inc hl 
9fb1			; 
9fb1			;	; save pointer to next word 
9fb1			; 
9fb1			;	; hl now points to the address of the next word pointer  
9fb1			;	ld e, (hl) 
9fb1			;	inc hl 
9fb1			;	ld d, (hl) 
9fb1			;	inc l 
9fb1			; 
9fb1			;	ex de,hl 
9fb1			;if DEBUG_FORTH_PARSE_NEXTWORD 
9fb1			;	push bc 
9fb1			;	ld bc, (cli_nextword) 
9fb1			;			DMARK "NXW" 
9fb1			;	CALLMONITOR 
9fb1			;	pop bc 
9fb1			;endif 
9fb1			; tok next end here 
9fb1 22 48 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9fb4 eb				ex de, hl 
9fb5			 
9fb5			 
9fb5				; save the pointer of the current token - 1 to check against 
9fb5				 
9fb5 22 4c ea			ld (cli_token), hl   
9fb8				; TODO maybe remove below save if no debug 
9fb8				; save token string ptr for any debug later 
9fb8 23				inc hl  
9fb9 22 4e ea			ld (cli_origtoken), hl 
9fbc 2b				dec hl 
9fbd				; save pointer to the start of the next dictionay word 
9fbd 7e				ld a,(hl)   ; get string length 
9fbe 47				ld b,a 
9fbf			.execpnwordinc:  
9fbf 23				inc hl 
9fc0 10 fd			djnz .execpnwordinc 
9fc2 22 4a ea			ld (cli_execword), hl      ; save start of this words code 
9fc5			 
9fc5				; now check the word token against the string being parsed 
9fc5			 
9fc5 2a 4c ea			ld hl,(cli_token) 
9fc8 23				inc hl     ; skip string length (use zero term instead to end) 
9fc9 22 4c ea			ld (cli_token), hl 
9fcc			 
9fcc			if DEBUG_FORTH_PARSE_KEY 
9fcc						DMARK "KY2" 
9fcc			endif 
9fcc			if DEBUG_FORTH_PARSE_EXEC 
9fcc				; see if disabled 
9fcc			 
9fcc				ld a, (os_view_disable) 
9fcc				cp '*' 
9fcc				jr z, .skip 
9fcc			 
9fcc				push hl 
9fcc				push hl 
9fcc				call clear_display 
9fcc				ld de, .compword 
9fcc				ld a, display_row_1 
9fcc				call str_at_display 
9fcc				pop de 
9fcc				ld a, display_row_2 
9fcc				call str_at_display 
9fcc				ld hl,(cli_ptr) 
9fcc				ld a,(hl) 
9fcc			        ld hl, os_word_scratch 
9fcc				ld (hl),a 
9fcc				ld a,0 
9fcc				inc hl 
9fcc				ld (hl),a 	 
9fcc				ld de, os_word_scratch 
9fcc				ld a, display_row_2+10 
9fcc				call str_at_display 
9fcc				call update_display 
9fcc				ld a, 100 
9fcc				call aDelayInMS 
9fcc				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fcc				call delay250ms 
9fcc				endif 
9fcc				pop hl 
9fcc			.skip:  
9fcc			endif	 
9fcc			.execpnchar:    ; compare char between token and string to parse 
9fcc			 
9fcc			if DEBUG_FORTH_PARSE_KEY 
9fcc						DMARK "Ky3" 
9fcc			endif 
9fcc			if DEBUG_FORTH_PARSE_EXEC 
9fcc				; see if disabled 
9fcc			 
9fcc				ld a, (os_view_disable) 
9fcc				cp '*' 
9fcc				jr z, .skip2 
9fcc			 
9fcc			;	call clear_display 
9fcc			ld hl,(cli_token) 
9fcc			ld a,(hl) 
9fcc			ld (os_word_scratch),a 
9fcc				ld hl,(cli_ptr) 
9fcc			ld a,(hl) 
9fcc				ld (os_word_scratch+1),a 
9fcc				ld a,0 
9fcc				ld (os_word_scratch+2),a 
9fcc				ld de,os_word_scratch 
9fcc				ld a,display_row_4 
9fcc				call str_at_display 
9fcc				call update_display 
9fcc			.skip2:  
9fcc			endif 
9fcc 2a 4c ea			ld hl,(cli_token) 
9fcf 7e				ld a, (hl)	 ; char in word token 
9fd0 23				inc hl 		; move to next char 
9fd1 22 4c ea			ld (cli_token), hl ; and save it 
9fd4 47				ld b,a 
9fd5			 
9fd5 2a 46 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fd8 7e				ld a,(hl) 
9fd9 23				inc hl 
9fda 22 46 ea			ld (cli_ptr), hl		; move to next char 
9fdd cd 31 91			call toUpper 		; make sure the input string matches case 
9fe0			 
9fe0			if DEBUG_FORTH_PARSE 
9fe0			endif 
9fe0			 
9fe0				; input stream end of token is a space so get rid of it 
9fe0			 
9fe0			;	cp ' ' 
9fe0			;	jr nz, .pnskipspace 
9fe0			; 
9fe0			;	ld a, 0		; make same term as word token term 
9fe0			; 
9fe0			;.pnskipspace: 
9fe0			 
9fe0			if DEBUG_FORTH_PARSE_KEY 
9fe0						DMARK "KY7" 
9fe0			endif 
9fe0 b8				cp b 
9fe1 c2 f7 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fe4				 
9fe4			;    if same 
9fe4			;       scan for string terms 0 for token and 32 for input 
9fe4			 
9fe4				 
9fe4			if DEBUG_FORTH_PARSE_KEY 
9fe4						DMARK "KY8" 
9fe4			endif 
9fe4			 
9fe4 80				add b			 
9fe5 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fe7							; TODO need to make sure last word in zero term string is accounted for 
9fe7 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fe9			 
9fe9			 
9fe9				; at end of both strings so both are exact match 
9fe9			 
9fe9			;       skip ptr for next word 
9fe9			 
9fe9 2a 46 ea			ld hl,(cli_ptr) 	; at input string term 
9fec 23				inc hl			 ; at next char 
9fed 22 46 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9ff0 22 44 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9ff3				 
9ff3				 
9ff3			if DEBUG_FORTH_PARSE_KEY 
9ff3						DMARK "KY3" 
9ff3			endif 
9ff3			 
9ff3			 
9ff3			 
9ff3			;       exec code block 
9ff3			if DEBUG_FORTH_JP 
9ff3				call clear_display 
9ff3				call update_display 
9ff3				call delay1s 
9ff3				ld hl, (cli_execword)     ; save for next check if no match on this word 
9ff3				ld a,h 
9ff3				ld hl, os_word_scratch 
9ff3				call hexout 
9ff3				ld hl, (cli_execword)     ; save for next check if no match on this word 
9ff3				ld a,l 
9ff3				ld hl, os_word_scratch+2 
9ff3				call hexout 
9ff3				ld hl, os_word_scratch+4 
9ff3				ld a,0 
9ff3				ld (hl),a 
9ff3				ld de,os_word_scratch 
9ff3				call str_at_display 
9ff3					ld a, display_row_2 
9ff3					call str_at_display 
9ff3				ld de, (cli_origtoken) 
9ff3				ld a, display_row_1+10 
9ff3					call str_at_display 
9ff3			 
9ff3				ld a,display_row_1 
9ff3				ld de, .foundword 
9ff3				ld a, display_row_3 
9ff3				call str_at_display 
9ff3				call update_display 
9ff3				call delay1s 
9ff3				call delay1s 
9ff3				call delay1s 
9ff3			endif 
9ff3			 
9ff3			if DEBUG_FORTH_PARSE_KEY 
9ff3						DMARK "KYj" 
9ff3			endif 
9ff3				; TODO save the word pointer in this exec 
9ff3			 
9ff3 2a 4a ea			ld hl,(cli_execword) 
9ff6 e9				jp (hl) 
9ff7			 
9ff7			 
9ff7			;    if not same 
9ff7			;	scan for zero term 
9ff7			;	get ptr for next word 
9ff7			;	goto word comp 
9ff7			 
9ff7			.execpnskipword:	; get pointer to next word 
9ff7 2a 48 ea			ld hl,(cli_nextword) 
9ffa			 
9ffa 7e				ld a,(hl) 
9ffb fe 00			cp WORD_SYS_END 
9ffd			;	cp 0 
9ffd 28 09			jr z, .execendofdict			 ; at end of words 
9fff			 
9fff			if DEBUG_FORTH_PARSE_KEY 
9fff						DMARK "KY4" 
9fff			endif 
9fff			if DEBUG_FORTH_PARSE_EXEC 
9fff			 
9fff				; see if disabled 
9fff			 
9fff				ld a, (os_view_disable) 
9fff				cp '*' 
9fff				jr z, .noskip 
9fff			 
9fff			 
9fff				ld de, .nowordfound 
9fff				ld a, display_row_3 
9fff				call str_at_display 
9fff				call update_display 
9fff				ld a, 100 
9fff				call aDelayInMS 
9fff				 
9fff				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fff					call delay250ms 
9fff				endif 
9fff			.noskip:  
9fff			 
9fff			endif	 
9fff			 
9fff 2a 44 ea			ld hl,(cli_origptr) 
a002 22 46 ea			ld (cli_ptr),hl 
a005			 
a005			if DEBUG_FORTH_PARSE_KEY 
a005						DMARK "KY5" 
a005			endif 
a005 c3 ab 9f			jp .execpnword			; else go to next word 
a008			 
a008			.execendofdict:  
a008			 
a008			if DEBUG_FORTH_PARSE_KEY 
a008						DMARK "KYe" 
a008			endif 
a008			if DEBUG_FORTH_PARSE_EXEC 
a008				; see if disabled 
a008			 
a008				ld a, (os_view_disable) 
a008				cp '*' 
a008				jr z, .ispskip 
a008			 
a008				call clear_display 
a008				call update_display 
a008				call delay1s 
a008				ld de, (cli_origptr) 
a008				ld a, display_row_1 
a008				call str_at_display 
a008				 
a008				ld de, .enddict 
a008				ld a, display_row_3 
a008				call str_at_display 
a008				call update_display 
a008				ld a, 100 
a008				call aDelayInMS 
a008				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a008				call delay1s 
a008				call delay1s 
a008				call delay1s 
a008				endif 
a008			.ispskip:  
a008				 
a008			endif	 
a008			 
a008			 
a008			 
a008				; if the word is not a keyword then must be a literal so push it to stack 
a008			 
a008			; push token to stack to end of word 
a008			 
a008				STACKFRAME ON $1efe $2f9f 
a008				if DEBUG_STACK_IMB 
a008					if ON 
a008						exx 
a008						ld de, $1efe 
a008						ld a, d 
a008						ld hl, curframe 
a008						call hexout 
a008						ld a, e 
a008						ld hl, curframe+2 
a008						call hexout 
a008						ld hl, $1efe 
a008						push hl 
a008						ld hl, $2f9f 
a008						push hl 
a008						exx 
a008					endif 
a008				endif 
a008			endm 
# End of macro STACKFRAME
a008			 
a008 2a c8 e5		ld hl,(os_tok_ptr) 
a00b cd bc 9c		call forth_apush 
a00e			 
a00e				STACKFRAMECHK ON $1efe $2f9f 
a00e				if DEBUG_STACK_IMB 
a00e					if ON 
a00e						exx 
a00e						ld hl, $2f9f 
a00e						pop de   ; $2f9f 
a00e						call cmp16 
a00e						jr nz, .spnosame 
a00e						ld hl, $1efe 
a00e						pop de   ; $1efe 
a00e						call cmp16 
a00e						jr z, .spfrsame 
a00e						.spnosame: call showsperror 
a00e						.spfrsame: nop 
a00e						exx 
a00e					endif 
a00e				endif 
a00e			endm 
# End of macro STACKFRAMECHK
a00e			 
a00e			execnext: 
a00e			 
a00e			if DEBUG_FORTH_PARSE_KEY 
a00e						DMARK "KY>" 
a00e			endif 
a00e			; move past token to next word 
a00e			 
a00e 2a c8 e5		ld hl, (os_tok_ptr) 
a011 3e 00		ld a, 0 
a013 01 ff 00		ld bc, 255     ; input buffer size 
a016 ed b1		cpir 
a018			 
a018			if DEBUG_FORTH_PARSE_KEY 
a018						DMARK "KY!" 
a018				CALLMONITOR 
a018			endif	 
a018			; TODO this might place hl on the null, so will need to forward on??? 
a018			;inc hl   ; see if this gets onto the next item 
a018			 
a018			 
a018			; TODO pass a pointer to the buffer to push 
a018			; TODO call function to push 
a018			 
a018			; look for end of input 
a018			 
a018			;inc hl 
a018			;ld a,(hl) 
a018			;cp FORTH_END_BUFFER 
a018			;ret z 
a018			 
a018			 
a018 c3 91 9f		jp exec1 
a01b			 
a01b			 
a01b			 
a01b			 
a01b			 
a01b			 
a01b			 
a01b			 
a01b			 
a01b			findnexttok: 
a01b			 
a01b				; hl is pointer to move 
a01b				; de is the token to locate 
a01b			 
a01b					if DEBUG_FORTH 
a01b						DMARK "NTK" 
a01b						CALLMONITOR 
a01b					endif 
a01b d5				push de 
a01c			 
a01c			.fnt1:	 
a01c				; find first char of token to locate 
a01c			 
a01c 1a				ld a, (de) 
a01d 4f				ld c,a 
a01e 7e				ld a,(hl) 
a01f cd 31 91			call toUpper 
a022					if DEBUG_FORTH 
a022						DMARK "NT1" 
a022						CALLMONITOR 
a022					endif 
a022 b9				cp c 
a023			 
a023 28 03			jr z, .fnt2cmpmorefirst	 
a025			 
a025				; first char not found move to next char 
a025			 
a025 23				inc hl 
a026 18 f4			jr .fnt1 
a028			 
a028			.fnt2cmpmorefirst:	 
a028				; first char of token found.  
a028			 
a028 e5				push hl     ; save start of token just in case it is the right one 
a029 d9				exx 
a02a e1				pop hl        ; save it to hl' 
a02b d9				exx 
a02c			 
a02c			 
a02c			.fnt2cmpmore:	 
a02c				; compare the rest 
a02c				 
a02c 23				inc hl 
a02d 13				inc de 
a02e				 
a02e 1a				ld a, (de) 
a02f 4f				ld c,a 
a030 7e				ld a,(hl) 
a031 cd 31 91			call toUpper 
a034			 
a034					if DEBUG_FORTH 
a034						DMARK "NT2" 
a034						CALLMONITOR 
a034					endif 
a034				; c has the token to find char 
a034				; a has the mem to scan char 
a034			 
a034 b9				cp c 
a035 28 04			jr z,.fntmatch1 
a037			 
a037				; they are not the same 
a037			 
a037					if DEBUG_FORTH 
a037						DMARK "NT3" 
a037						CALLMONITOR 
a037					endif 
a037 d1				pop de	; reset de token to look for 
a038 d5				push de 
a039 18 e1			jr .fnt1 
a03b				 
a03b			.fntmatch1: 
a03b			 
a03b				; is the same char a null which means we might have a full hit? 
a03b					if DEBUG_FORTH 
a03b						DMARK "NT4" 
a03b						CALLMONITOR 
a03b					endif 
a03b			 
a03b fe 00			cp 0 
a03d 28 0b			jr z, .fntmatchyes 
a03f			 
a03f				; are we at the end of the token to find? 
a03f			 
a03f					if DEBUG_FORTH 
a03f						DMARK "NT5" 
a03f						CALLMONITOR 
a03f					endif 
a03f 3e 00			ld a, 0 
a041 b9				cp c 
a042			 
a042 c2 2c a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a045			 
a045					if DEBUG_FORTH 
a045						DMARK "NT6" 
a045						CALLMONITOR 
a045					endif 
a045				; token to find is exhusted but no match to stream 
a045			 
a045				; restore tok pointer and continue on 
a045 d1				pop de 
a046 d5				push de 
a047 c3 1c a0			jp .fnt1 
a04a			 
a04a			 
a04a			.fntmatchyes: 
a04a			 
a04a				; hl now contains the end of the found token 
a04a			 
a04a				; get rid of saved token pointer to find 
a04a			 
a04a d1				pop de 
a04b			 
a04b					if DEBUG_FORTH 
a04b						DMARK "NT9" 
a04b						CALLMONITOR 
a04b					endif 
a04b			 
a04b				; hl will be on the null term so forward on 
a04b			 
a04b				; get back the saved start of the token 
a04b			 
a04b d9				exx 
a04c e5				push hl     ; save start of token just in case it is the right one 
a04d d9				exx 
a04e e1				pop hl        ; save it to hl 
a04f			 
a04f c9				ret 
a050			 
a050			 
a050			; LIST needs to find a specific token   
a050			; FORGET needs to find a spefici token 
a050			 
a050			; SAVE needs to find all tokens by flag 
a050			; WORDS just needs to scan through all  by flag 
a050			; UWORDS needs to scan through all by flag 
a050			 
a050			 
a050			; given hl as pointer to start of dict look up string 
a050			; return hl as pointer to start of word block 
a050			; or 0 if not found 
a050			 
a050			forth_find_tok: 
a050 c9				ret 
a051			 
a051			; given hl as pointer to dict structure 
a051			; move to the next dict block structure 
a051			 
a051			forth_tok_next: 
a051				; hl now points to the address of the next word pointer  
a051				; TODO skip compiled symbol for now 
a051			;	push de 
a051 23				inc hl 
a052 5e				ld e, (hl) 
a053 23				inc hl 
a054 56				ld d, (hl) 
a055 23				inc hl 
a056			 
a056 eb				ex de,hl 
a057			if DEBUG_FORTH_PARSE_NEXTWORD 
a057				push bc 
a057				ld bc, (cli_nextword) 
a057						DMARK "NXW" 
a057				CALLMONITOR 
a057				pop bc 
a057			endif 
a057			;	pop de	 
a057 c9				ret 
a058			 
a058			 
a058			 
a058			; eof 
# End of file forth_parserv5.asm
a058				include "forth_wordsv4.asm" 
a058			 
a058			; the core word dictionary v4 
a058			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a058			 
a058			; this is a linked list for each of the system words used 
a058			; user defined words will follow the same format but will be in ram 
a058			 
a058			 
a058			; 
a058			; 
a058			; define linked list: 
a058			; 
a058			; 1. compiled byte op code 
a058			; 2. len of text word 
a058			; 3. text word 
a058			; 4. ptr to next dictionary word 
a058			; 5. asm, calls etc for the word 
a058			; 
a058			;  if 1 == 0 then last word in dict  
a058			;   
a058			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a058			;  
a058			;  
a058			; create basic standard set of words 
a058			; 
a058			;  
a058			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a058			; 2DUP 2DROP 2SWAP  
a058			; @ C@ - get byte  
a058			; ! C! - store byte 
a058			; 0< true if less than zero 
a058			; 0= true if zero 
a058			; < >  
a058			; = true if same 
a058			; variables 
a058			 
a058			 
a058			; Hardware specific words I may need 
a058			; 
a058			; IN OUT  
a058			; calls to key util functions 
a058			; calls to hardward abstraction stuff 
a058			; easy control of frame buffers and lcd i/o 
a058			; keyboard  
a058			 
a058			 
a058			;DICT: macro 
a058			; op_code, len, word, next 
a058			;    word: 
a058			;    db op_code 
a058			;    ds word zero term 
a058			;    dw next 
a058			;    endm 
a058			 
a058			 
a058			 
a058			 
a058			; op code 1 is a flag for user define words which are to be handled differently 
a058			 
a058			 
a058			; 
a058			; 
a058			;    TODO on entry to a word this should be the expected environment 
a058			;    hl - tos value if number then held, if string this is the ptr 
a058			;    de -  
a058			 
a058			 
a058			; opcode ranges 
a058			; 0 - end of word dict 
a058			; 255 - user define words 
a058			 
a058			sysdict: 
a058			include "forth_opcodes.asm" 
a058			; op codes for forth keywords 
a058			; free to use code 0  
a058				OPCODE_HEAP: equ  1 
a058				OPCODE_EXEC: equ 2 
a058				OPCODE_DUP: equ 3 
a058				OPCODE_SWAP: equ 4 
a058				OPCODE_COLN: equ 5 
a058				OPCODE_SCOLN: equ 6 
a058				OPCODE_DROP: equ 7 
a058				OPCODE_DUP2: equ 8 
a058				OPCODE_DROP2: equ 9 
a058				OPCODE_SWAP2: equ 10 
a058				OPCODE_AT: equ 11 
a058				OPCODE_CAT: equ 12 
a058				OPCODE_BANG: equ 13 
a058				OPCODE_CBANG: equ 14 
a058				OPCODE_SCALL: equ 15 
a058				OPCODE_DEPTH: equ 16 
a058				OPCODE_OVER: equ 17 
a058				OPCODE_PAUSE: equ 18 
a058				OPCODE_PAUSES: equ 19 
a058				OPCODE_ROT: equ 20 
a058			;free to reuse	OPCODE_WORDS: equ 21 
a058			        OPCODE_NOT: equ 21 
a058				OPCODE_UWORDS: equ 22 
a058				OPCODE_BP: equ 23 
a058				OPCODE_MONITOR: equ 24  
a058				OPCODE_MALLOC: equ 25 
a058				OPCODE_FREE: equ 26 
a058				OPCODE_LIST: equ 27 
a058				OPCODE_FORGET: equ 28 
a058				OPCODE_NOP: equ 29 
a058				OPCODE_COMO: equ 30 
a058				OPCODE_COMC: equ 31 
a058			;free to reuse	OPCODE_ENDCORE: equ 32 
a058				OPCODE_AFTERSOUND: equ 33 
a058				OPCODE_GP2: equ 34 
a058				OPCODE_GP3: equ 35 
a058				OPCODE_GP4: equ 36 
a058				OPCODE_SIN: equ 37 
a058				OPCODE_SOUT: equ 38 
a058				OPCODE_SPIO: equ 39 
a058				OPCODE_SPICEH: equ 40 
a058				OPCODE_SPIOb: equ 41 
a058				OPCODE_SPII: equ 42 
a058				OPCODE_SESEL: equ 43 
a058				OPCODE_CARTDEV: equ 44 
a058			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a058				OPCODE_FB: equ 46 
a058				OPCODE_EMIT: equ 47 
a058				OPCODE_DOTH: equ 48 
a058				OPCODE_DOTF: equ 49 
a058				OPCODE_DOT: equ 50 
a058				OPCODE_CLS: equ 51 
a058				OPCODE_DRAW: equ 52 
a058				OPCODE_DUMP: equ 53 
a058				OPCODE_CDUMP: equ 54 
a058				OPCODE_DAT: equ 55 
a058				OPCODE_HOME: equ 56 
a058				OPCODE_SPACE: equ 57 
a058				OPCODE_SPACES: equ 58 
a058				OPCODE_SCROLL: equ 59 
a058				OPCODE_ATQ: equ 60 
a058				OPCODE_AUTODSP: equ 61 
a058				OPCODE_MENU: equ 62 
a058			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a058				OPCODE_THEN: equ 64 
a058				OPCODE_ELSE: equ 65 
a058				OPCODE_DO: equ 66 
a058				OPCODE_LOOP: equ 67 
a058				OPCODE_I: equ 68 
a058				OPCODE_DLOOP: equ 69  
a058				OPCODE_REPEAT: equ 70  
a058				OPCODE_UNTIL: equ 71 
a058				OPCODE_ENDFLOW: equ 72 
a058				OPCODE_WAITK: equ 73 
a058				OPCODE_ACCEPT: equ 74 
a058				OPCODE_EDIT: equ 75 
a058			;free to reuse	OPCODE_ENDKEY: equ 76 
a058				OPCODE_LZERO: equ 77 
a058				OPCODE_TZERO: equ 78 
a058				OPCODE_LESS: equ 79 
a058				OPCODE_GT: equ 80 
a058				OPCODE_EQUAL: equ 81  
a058			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a058				OPCODE_NEG: equ 83 
a058				OPCODE_DIV: equ 84 
a058				OPCODE_MUL: equ 85 
a058				OPCODE_MIN: equ 86 
a058				OPCODE_MAX: equ 87 
a058				OPCODE_RND16: equ 88 
a058				OPCODE_RND8: equ 89 
a058				OPCODE_RND: equ 90 
a058			;free to reuse	OPCODE_ENDMATHS: equ 91  
a058				OPCODE_BYNAME: equ 92 
a058				OPCODE_DIR: equ 93 
a058				OPCODE_SAVE: equ 94 
a058				OPCODE_LOAD: equ 95 
a058				OPCODE_BSAVE: equ 96 
a058				OPCODE_BLOAD: equ 97 
a058				OPCODE_SEO: equ 98  
a058				OPCODE_SEI: equ 99 
a058				OPCODE_SFREE: equ 100 
a058				OPCODE_SIZE: equ 101 
a058				OPCODE_CREATE: equ 102 
a058				OPCODE_APPEND: equ 103 
a058				OPCODE_SDEL: equ 104 
a058				OPCODE_OPEN: equ 105 
a058				OPCODE_READ: equ 106 
a058				OPCODE_EOF: equ 106 
a058				OPCODE_FORMAT: equ 107 
a058				OPCODE_LABEL: equ 108 
a058				OPCODE_LABELS: equ 109 
a058			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a058				OPCODE_UPPER: equ 111 
a058				OPCODE_LOWER: equ 112 
a058				OPCODE_SUBSTR: equ 113 
a058				OPCODE_LEFT: equ 114 
a058				OPCODE_RIGHT: equ 115 
a058				OPCODE_STR2NUM: equ 116 
a058				OPCODE_NUM2STR: equ 117 
a058				OPCODE_CONCAT: equ 118 
a058				OPCODE_FIND: equ 119 
a058				OPCODE_LEN: equ 120 
a058				OPCODE_CHAR: equ 121 
a058			; free to reuse	OPCODE_STRLEN: equ 122 
a058			; free to reuse	OPCODE_ENDSTR: equ 123 
a058				OPCODE_V0S: equ 124 
a058				OPCODE_V0Q: equ 125 
a058				OPCODE_V1S: equ 126 
a058				OPCODE_V1Q: equ 127 
a058				OPCODE_V2S: equ 128 
a058				OPCODE_V2Q: equ 129 
a058				OPCODE_V3S: equ 130 
a058				OPCODE_V3Q: equ 131 
a058			;free to reuse	OPCODE_END: equ 132 
a058				OPCODE_ZDUP: equ 133 
a058			 
a058			; eof 
# End of file forth_opcodes.asm
a058			 
a058			include "forth_words_core.asm" 
a058			 
a058			; | ## Core Words 
a058			 
a058			;if MALLOC_4 
a058			 
a058			.HEAP: 
a058				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a058 15				db WORD_SYS_CORE+OPCODE_HEAP             
a059 97 a0			dw .EXEC            
a05b 05				db 4 + 1 
a05c .. 00			db "HEAP",0              
a061				endm 
# End of macro CWHEAD
a061			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a061			; | | u1 - Current number of bytes in the heap 
a061			; | | u2 - Remaining bytes left on the heap 
a061			; | |  
a061			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a061			 
a061			 
a061					if DEBUG_FORTH_WORDS_KEY 
a061						DMARK "HEP" 
a061 f5				push af  
a062 3a 76 a0			ld a, (.dmark)  
a065 32 71 ee			ld (debug_mark),a  
a068 3a 77 a0			ld a, (.dmark+1)  
a06b 32 72 ee			ld (debug_mark+1),a  
a06e 3a 78 a0			ld a, (.dmark+2)  
a071 32 73 ee			ld (debug_mark+2),a  
a074 18 03			jr .pastdmark  
a076 ..			.dmark: db "HEP"  
a079 f1			.pastdmark: pop af  
a07a			endm  
# End of macro DMARK
a07a						CALLMONITOR 
a07a cd dd 94			call break_point_state  
a07d				endm  
# End of macro CALLMONITOR
a07d					endif 
a07d 2a 5f e3				ld hl, (free_list )      
a080 11 64 e3				ld de, heap_start 
a083			 
a083 ed 52				sbc hl, de  
a085			 
a085 cd 53 9b				call forth_push_numhl 
a088			 
a088			 
a088 ed 5b 5f e3			ld de, (free_list )      
a08c 21 ad e2				ld hl, heap_end 
a08f			 
a08f ed 52				sbc hl, de 
a091			 
a091 cd 53 9b				call forth_push_numhl 
a094					 
a094			 
a094					 
a094			 
a094			 
a094			 
a094					NEXTW 
a094 c3 00 9f			jp macro_next 
a097				endm 
# End of macro NEXTW
a097			;endif 
a097			 
a097			.EXEC: 
a097			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a097			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a097			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a097			;; > > 
a097			;; > >   
a097			;	STACKFRAME OFF $5efe $5f9f 
a097			; 
a097			;		if DEBUG_FORTH_WORDS_KEY 
a097			;			DMARK "EXE" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			; 
a097			;	FORTH_DSP_VALUEHL 
a097			; 
a097			;	FORTH_DSP_POP 
a097			; 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX1" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;;	ld e,(hl) 
a097			;;	inc hl 
a097			;;	ld d,(hl) 
a097			;;	ex de,hl 
a097			; 
a097			;;		if DEBUG_FORTH_WORDS 
a097			;;			DMARK "EX2" 
a097			;;			CALLMONITOR 
a097			;;		endif 
a097			;	push hl 
a097			; 
a097			;	;ld a, 0 
a097			;	;ld a, FORTH_END_BUFFER 
a097			;	call strlenz 
a097			;	inc hl   ; include zero term to copy 
a097			;	inc hl   ; include term 
a097			;	inc hl   ; include term 
a097			;	ld b,0 
a097			;	ld c,l 
a097			;	pop hl 
a097			;	ld de, execscratch 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX3" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	ldir 
a097			; 
a097			; 
a097			;	ld hl, execscratch 
a097			; 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EXe" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			; 
a097			;	call forthparse 
a097			;	call forthexec 
a097			;;	call forthexec_cleanup 
a097			;;	call forthparse 
a097			;;	call forthexec 
a097			; 
a097			;	STACKFRAMECHK OFF $5efe $5f9f 
a097			; 
a097			;	; an immediate word so no need to process any more words 
a097			;	ret 
a097			;	NEXTW 
a097			 
a097			; dead code - old version  
a097			;	FORTH_RSP_NEXT 
a097			 
a097			;  
a097			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a097			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a097			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a097			;	push hl 
a097			;	push de 
a097			;	push bc 
a097			; 
a097			; 
a097			;		if DEBUG_FORTH_WORDS_KEY 
a097			;			DMARK "EXR" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			; 
a097			; 
a097			; 
a097			;	;v5 FORTH_DSP_VALUE 
a097			;	FORTH_DSP_VALUEHL 
a097			; 
a097			;	; TODO do string type checks 
a097			; 
a097			;;v5	inc hl   ; skip type 
a097			; 
a097			;	push hl  ; source code  
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX1" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	ld a, 0 
a097			;	call strlent 
a097			; 
a097			;	inc hl 
a097			;	inc hl 
a097			;	inc hl 
a097			;	inc hl 
a097			; 
a097			;	push hl    ; size 
a097			; 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX2" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	call malloc 
a097			; 
a097			;	ex de, hl    ; de now contains malloc area 
a097			;	pop bc   	; get byte count 
a097			;	pop hl      ; get string to copy 
a097			; 
a097			;	push de     ; save malloc for free later 
a097			; 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX3" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	ldir       ; duplicate string 
a097			; 
a097			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a097			;	 
a097			;	; TODO fix the parse would be better than this...  
a097			;	ex de, hl 
a097			;	dec hl 
a097			;	ld a, 0 
a097			;	ld (hl), a 
a097			;	dec hl 
a097			;	ld a, ' ' 
a097			;	ld (hl), a 
a097			;	dec hl 
a097			;	ld (hl), a 
a097			; 
a097			;	dec hl 
a097			;	ld (hl), a 
a097			; 
a097			; 
a097			;	FORTH_DSP_POP  
a097			; 
a097			;	pop hl     
a097			;	push hl    ; save malloc area 
a097			; 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX4" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			; 
a097			;	call forthparse 
a097			;	call forthexec 
a097			;	 
a097			;	pop hl 
a097			;	if DEBUG_FORTH_WORDS 
a097			;		DMARK "EX5" 
a097			;		CALLMONITOR 
a097			;	endif 
a097			; 
a097			;	if FORTH_ENABLE_FREE 
a097			;	call free 
a097			;	endif 
a097			; 
a097			;	if DEBUG_FORTH_WORDS 
a097			;		DMARK "EX6" 
a097			;		CALLMONITOR 
a097			;	endif 
a097			; 
a097			;	pop bc 
a097			;	pop de 
a097			;	pop hl 
a097			;;	FORTH_RSP_POP	  
a097			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a097			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a097			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a097			; 
a097			;	if DEBUG_FORTH_WORDS 
a097			;		DMARK "EX7" 
a097			;		CALLMONITOR 
a097			;	endif 
a097			;	NEXTW 
a097			 
a097			;.STKEXEC: 
a097			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a097			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a097			; 
a097			; 
a097			;		if DEBUG_FORTH_WORDS_KEY 
a097			;			DMARK "STX" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			; 
a097			;	FORTH_DSP_VALUEHL 
a097			; 
a097			;	ld (store_tmp1), hl    ; count 
a097			; 
a097			;	FORTH_DSP_POP 
a097			;.stkexec1: 
a097			;	ld hl, (store_tmp1)   ; count 
a097			;	ld a, 0 
a097			;	cp l 
a097			;	ret z 
a097			; 
a097			;	dec hl 
a097			;	ld (store_tmp1), hl    ; count 
a097			;	 
a097			;	FORTH_DSP_VALUEHL 
a097			;	push hl 
a097			;	 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EXp" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	FORTH_DSP_POP 
a097			; 
a097			;	call strlenz 
a097			;	inc hl   ; include zero term to copy 
a097			;	inc hl   ; include zero term to copy 
a097			;	inc hl   ; include zero term to copy 
a097			;	ld b,0 
a097			;	ld c,l 
a097			;	pop hl 
a097			;	ld de, execscratch 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EX3" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	ldir 
a097			; 
a097			; 
a097			;	ld hl, execscratch 
a097			; 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EXP" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			; 
a097			;	call forthparse 
a097			;	ld hl, execscratch 
a097			;		if DEBUG_FORTH_WORDS 
a097			;			DMARK "EXx" 
a097			;			CALLMONITOR 
a097			;		endif 
a097			;	call forthexec 
a097			; 
a097			;	jp .stkexec1 
a097			; 
a097			;	ret 
a097			 
a097			 
a097			.DUP: 
a097				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a097 17				db WORD_SYS_CORE+OPCODE_DUP             
a098 0d a1			dw .ZDUP            
a09a 04				db 3 + 1 
a09b .. 00			db "DUP",0              
a09f				endm 
# End of macro CWHEAD
a09f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a09f			 
a09f					if DEBUG_FORTH_WORDS_KEY 
a09f						DMARK "DUP" 
a09f f5				push af  
a0a0 3a b4 a0			ld a, (.dmark)  
a0a3 32 71 ee			ld (debug_mark),a  
a0a6 3a b5 a0			ld a, (.dmark+1)  
a0a9 32 72 ee			ld (debug_mark+1),a  
a0ac 3a b6 a0			ld a, (.dmark+2)  
a0af 32 73 ee			ld (debug_mark+2),a  
a0b2 18 03			jr .pastdmark  
a0b4 ..			.dmark: db "DUP"  
a0b7 f1			.pastdmark: pop af  
a0b8			endm  
# End of macro DMARK
a0b8						CALLMONITOR 
a0b8 cd dd 94			call break_point_state  
a0bb				endm  
# End of macro CALLMONITOR
a0bb					endif 
a0bb			 
a0bb					FORTH_DSP 
a0bb cd 10 9d			call macro_forth_dsp 
a0be				endm 
# End of macro FORTH_DSP
a0be			 
a0be 7e					ld a, (HL) 
a0bf fe 01				cp DS_TYPE_STR 
a0c1 20 25				jr nz, .dupinum 
a0c3			 
a0c3					; push another string 
a0c3			 
a0c3					FORTH_DSP_VALUEHL     		 
a0c3 cd 4a 9d			call macro_dsp_valuehl 
a0c6				endm 
# End of macro FORTH_DSP_VALUEHL
a0c6			 
a0c6				if DEBUG_FORTH_WORDS 
a0c6					DMARK "DUs" 
a0c6 f5				push af  
a0c7 3a db a0			ld a, (.dmark)  
a0ca 32 71 ee			ld (debug_mark),a  
a0cd 3a dc a0			ld a, (.dmark+1)  
a0d0 32 72 ee			ld (debug_mark+1),a  
a0d3 3a dd a0			ld a, (.dmark+2)  
a0d6 32 73 ee			ld (debug_mark+2),a  
a0d9 18 03			jr .pastdmark  
a0db ..			.dmark: db "DUs"  
a0de f1			.pastdmark: pop af  
a0df			endm  
# End of macro DMARK
a0df					CALLMONITOR 
a0df cd dd 94			call break_point_state  
a0e2				endm  
# End of macro CALLMONITOR
a0e2				endif 
a0e2 cd c1 9b				call forth_push_str 
a0e5			 
a0e5					NEXTW 
a0e5 c3 00 9f			jp macro_next 
a0e8				endm 
# End of macro NEXTW
a0e8			 
a0e8			 
a0e8			.dupinum: 
a0e8					 
a0e8			 
a0e8			 
a0e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0e8 cd 4a 9d			call macro_dsp_valuehl 
a0eb				endm 
# End of macro FORTH_DSP_VALUEHL
a0eb			 
a0eb				; TODO add floating point number detection 
a0eb			 
a0eb				if DEBUG_FORTH_WORDS 
a0eb					DMARK "DUi" 
a0eb f5				push af  
a0ec 3a 00 a1			ld a, (.dmark)  
a0ef 32 71 ee			ld (debug_mark),a  
a0f2 3a 01 a1			ld a, (.dmark+1)  
a0f5 32 72 ee			ld (debug_mark+1),a  
a0f8 3a 02 a1			ld a, (.dmark+2)  
a0fb 32 73 ee			ld (debug_mark+2),a  
a0fe 18 03			jr .pastdmark  
a100 ..			.dmark: db "DUi"  
a103 f1			.pastdmark: pop af  
a104			endm  
# End of macro DMARK
a104					CALLMONITOR 
a104 cd dd 94			call break_point_state  
a107				endm  
# End of macro CALLMONITOR
a107				endif 
a107			 
a107 cd 53 9b				call forth_push_numhl 
a10a					NEXTW 
a10a c3 00 9f			jp macro_next 
a10d				endm 
# End of macro NEXTW
a10d			.ZDUP: 
a10d				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a10d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a10e 45 a1			dw .SWAP            
a110 05				db 4 + 1 
a111 .. 00			db "?DUP",0              
a116				endm 
# End of macro CWHEAD
a116			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a116			 
a116					if DEBUG_FORTH_WORDS_KEY 
a116						DMARK "qDU" 
a116 f5				push af  
a117 3a 2b a1			ld a, (.dmark)  
a11a 32 71 ee			ld (debug_mark),a  
a11d 3a 2c a1			ld a, (.dmark+1)  
a120 32 72 ee			ld (debug_mark+1),a  
a123 3a 2d a1			ld a, (.dmark+2)  
a126 32 73 ee			ld (debug_mark+2),a  
a129 18 03			jr .pastdmark  
a12b ..			.dmark: db "qDU"  
a12e f1			.pastdmark: pop af  
a12f			endm  
# End of macro DMARK
a12f						CALLMONITOR 
a12f cd dd 94			call break_point_state  
a132				endm  
# End of macro CALLMONITOR
a132					endif 
a132					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a132 cd 4a 9d			call macro_dsp_valuehl 
a135				endm 
# End of macro FORTH_DSP_VALUEHL
a135			 
a135 e5					push hl 
a136			 
a136					; is it a zero? 
a136			 
a136 3e 00				ld a, 0 
a138 84					add h 
a139 85					add l 
a13a			 
a13a e1					pop hl 
a13b			 
a13b fe 00				cp 0 
a13d 28 03				jr z, .dup2orig 
a13f			 
a13f			 
a13f cd 53 9b				call forth_push_numhl 
a142			 
a142			 
a142				; TODO add floating point number detection 
a142			 
a142			.dup2orig: 
a142			 
a142					NEXTW 
a142 c3 00 9f			jp macro_next 
a145				endm 
# End of macro NEXTW
a145			.SWAP: 
a145				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a145 18				db WORD_SYS_CORE+OPCODE_SWAP             
a146 84 a1			dw .COLN            
a148 05				db 4 + 1 
a149 .. 00			db "SWAP",0              
a14e				endm 
# End of macro CWHEAD
a14e			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a14e					if DEBUG_FORTH_WORDS_KEY 
a14e						DMARK "SWP" 
a14e f5				push af  
a14f 3a 63 a1			ld a, (.dmark)  
a152 32 71 ee			ld (debug_mark),a  
a155 3a 64 a1			ld a, (.dmark+1)  
a158 32 72 ee			ld (debug_mark+1),a  
a15b 3a 65 a1			ld a, (.dmark+2)  
a15e 32 73 ee			ld (debug_mark+2),a  
a161 18 03			jr .pastdmark  
a163 ..			.dmark: db "SWP"  
a166 f1			.pastdmark: pop af  
a167			endm  
# End of macro DMARK
a167						CALLMONITOR 
a167 cd dd 94			call break_point_state  
a16a				endm  
# End of macro CALLMONITOR
a16a					endif 
a16a			 
a16a					FORTH_DSP_VALUEHL 
a16a cd 4a 9d			call macro_dsp_valuehl 
a16d				endm 
# End of macro FORTH_DSP_VALUEHL
a16d e5					push hl     ; w2 
a16e			 
a16e					FORTH_DSP_POP 
a16e cd 02 9e			call macro_forth_dsp_pop 
a171				endm 
# End of macro FORTH_DSP_POP
a171			 
a171					FORTH_DSP_VALUEHL 
a171 cd 4a 9d			call macro_dsp_valuehl 
a174				endm 
# End of macro FORTH_DSP_VALUEHL
a174			 
a174					FORTH_DSP_POP 
a174 cd 02 9e			call macro_forth_dsp_pop 
a177				endm 
# End of macro FORTH_DSP_POP
a177			 
a177 d1					pop de     ; w2	, hl = w1 
a178			 
a178 eb					ex de, hl 
a179 d5					push de 
a17a			 
a17a cd 53 9b				call forth_push_numhl 
a17d			 
a17d e1					pop hl 
a17e			 
a17e cd 53 9b				call forth_push_numhl 
a181					 
a181			 
a181					NEXTW 
a181 c3 00 9f			jp macro_next 
a184				endm 
# End of macro NEXTW
a184			.COLN: 
a184				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a184 19				db WORD_SYS_CORE+OPCODE_COLN             
a185 10 a3			dw .SCOLN            
a187 02				db 1 + 1 
a188 .. 00			db ":",0              
a18a				endm 
# End of macro CWHEAD
a18a			; | : ( -- )         Create new word | DONE 
a18a			 
a18a					if DEBUG_FORTH_WORDS_KEY 
a18a						DMARK "CLN" 
a18a f5				push af  
a18b 3a 9f a1			ld a, (.dmark)  
a18e 32 71 ee			ld (debug_mark),a  
a191 3a a0 a1			ld a, (.dmark+1)  
a194 32 72 ee			ld (debug_mark+1),a  
a197 3a a1 a1			ld a, (.dmark+2)  
a19a 32 73 ee			ld (debug_mark+2),a  
a19d 18 03			jr .pastdmark  
a19f ..			.dmark: db "CLN"  
a1a2 f1			.pastdmark: pop af  
a1a3			endm  
# End of macro DMARK
a1a3						CALLMONITOR 
a1a3 cd dd 94			call break_point_state  
a1a6				endm  
# End of macro CALLMONITOR
a1a6					endif 
a1a6				STACKFRAME OFF $8efe $989f 
a1a6				if DEBUG_STACK_IMB 
a1a6					if OFF 
a1a6						exx 
a1a6						ld de, $8efe 
a1a6						ld a, d 
a1a6						ld hl, curframe 
a1a6						call hexout 
a1a6						ld a, e 
a1a6						ld hl, curframe+2 
a1a6						call hexout 
a1a6						ld hl, $8efe 
a1a6						push hl 
a1a6						ld hl, $989f 
a1a6						push hl 
a1a6						exx 
a1a6					endif 
a1a6				endif 
a1a6			endm 
# End of macro STACKFRAME
a1a6				; get parser buffer length  of new word 
a1a6			 
a1a6				 
a1a6			 
a1a6					; move tok past this to start of name defintition 
a1a6					; TODO get word to define 
a1a6					; TODO Move past word token 
a1a6					; TODO get length of string up to the ';' 
a1a6			 
a1a6 2a c8 e5			ld hl, (os_tok_ptr) 
a1a9 23				inc hl 
a1aa 23				inc hl 
a1ab			 
a1ab 3e 3b			ld a, ';' 
a1ad cd 45 91			call strlent 
a1b0			 
a1b0 7d				ld a,l 
a1b1 32 c3 e2			ld (os_new_parse_len), a 
a1b4			 
a1b4			 
a1b4			if DEBUG_FORTH_UWORD 
a1b4 ed 5b c8 e5		ld de, (os_tok_ptr) 
a1b8						DMARK ":01" 
a1b8 f5				push af  
a1b9 3a cd a1			ld a, (.dmark)  
a1bc 32 71 ee			ld (debug_mark),a  
a1bf 3a ce a1			ld a, (.dmark+1)  
a1c2 32 72 ee			ld (debug_mark+1),a  
a1c5 3a cf a1			ld a, (.dmark+2)  
a1c8 32 73 ee			ld (debug_mark+2),a  
a1cb 18 03			jr .pastdmark  
a1cd ..			.dmark: db ":01"  
a1d0 f1			.pastdmark: pop af  
a1d1			endm  
# End of macro DMARK
a1d1				CALLMONITOR 
a1d1 cd dd 94			call break_point_state  
a1d4				endm  
# End of macro CALLMONITOR
a1d4			endif 
a1d4			 
a1d4			; 
a1d4			;  new word memory layout: 
a1d4			;  
a1d4			;    : adg 6666 ;  
a1d4			; 
a1d4			;    db   1     ; user defined word  
a1d4 23				inc hl    
a1d5			;    dw   sysdict 
a1d5 23				inc hl 
a1d6 23				inc hl 
a1d7			;    db <word len>+1 (for null) 
a1d7 23				inc hl 
a1d8			;    db .... <word> 
a1d8			; 
a1d8			 
a1d8 23				inc hl    ; some extras for the word preamble before the above 
a1d9 23				inc hl 
a1da 23				inc hl 
a1db 23				inc hl 
a1dc 23				inc hl 
a1dd 23				inc hl 
a1de 23				inc hl  
a1df 23				inc hl 
a1e0 23				inc hl 
a1e1 23				inc hl 
a1e2 23				inc hl 
a1e3 23				inc hl 
a1e4 23				inc hl 
a1e5 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1e6			;       exec word buffer 
a1e6			;	<ptr word>   
a1e6 23				inc hl 
a1e7 23				inc hl 
a1e8			;       <word list><null term> 7F final term 
a1e8			 
a1e8			 
a1e8			if DEBUG_FORTH_UWORD 
a1e8						DMARK ":02" 
a1e8 f5				push af  
a1e9 3a fd a1			ld a, (.dmark)  
a1ec 32 71 ee			ld (debug_mark),a  
a1ef 3a fe a1			ld a, (.dmark+1)  
a1f2 32 72 ee			ld (debug_mark+1),a  
a1f5 3a ff a1			ld a, (.dmark+2)  
a1f8 32 73 ee			ld (debug_mark+2),a  
a1fb 18 03			jr .pastdmark  
a1fd ..			.dmark: db ":02"  
a200 f1			.pastdmark: pop af  
a201			endm  
# End of macro DMARK
a201				CALLMONITOR 
a201 cd dd 94			call break_point_state  
a204				endm  
# End of macro CALLMONITOR
a204			endif 
a204			 
a204				 
a204					; malloc the size 
a204			 
a204 cd a3 91				call malloc 
a207 22 c5 e2				ld (os_new_malloc), hl     ; save malloc start 
a20a			 
a20a			;    db   1     ; user defined word  
a20a 3e 01				ld a, WORD_SYS_UWORD  
a20c 77					ld (hl), a 
a20d				 
a20d 23				inc hl    
a20e			;    dw   sysdict 
a20e 11 58 a0			ld de, sysdict       ; continue on with the scan to the system dict 
a211 73				ld (hl), e 
a212 23				inc hl 
a213 72				ld (hl), d 
a214 23				inc hl 
a215			 
a215			 
a215			;    Setup dict word 
a215			 
a215 23				inc hl 
a216 22 bf e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a219			 
a219				; 1. get length of dict word 
a219			 
a219			 
a219 2a c8 e5			ld hl, (os_tok_ptr) 
a21c 23				inc hl 
a21d 23				inc hl    ; position to start of dict word 
a21e 3e 00			ld a, 0 
a220 cd 45 91			call strlent 
a223			 
a223			 
a223 23				inc hl    ; to include null??? 
a224			 
a224				; write length of dict word 
a224			 
a224 ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a228 1b				dec de 
a229 eb				ex de, hl 
a22a 73				ld (hl), e 
a22b eb				ex de, hl 
a22c			 
a22c				 
a22c			 
a22c				; copy  
a22c 4d				ld c, l 
a22d 06 00			ld b, 0 
a22f ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a233 2a c8 e5			ld hl, (os_tok_ptr) 
a236 23				inc hl 
a237 23				inc hl    ; position to start of dict word 
a238				 
a238			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a238				 
a238				; TODO need to convert word to upper case 
a238			 
a238			ucasetok:	 
a238 7e				ld a,(hl) 
a239 cd 31 91			call toUpper 
a23c 77				ld (hl),a 
a23d ed a0			ldi 
a23f f2 38 a2		 	jp p, ucasetok 
a242			 
a242			 
a242			 
a242				; de now points to start of where the word body code should be placed 
a242 ed 53 bf e2		ld (os_new_work_ptr), de 
a246				; hl now points to the words to throw at forthexec which needs to be copied 
a246 22 bd e2			ld (os_new_src_ptr), hl 
a249			 
a249				; TODO add 'call to forthexec' 
a249			 
a249			if DEBUG_FORTH_UWORD 
a249 c5				push bc 
a24a ed 4b c5 e2		ld bc, (os_new_malloc) 
a24e						DMARK ":0x" 
a24e f5				push af  
a24f 3a 63 a2			ld a, (.dmark)  
a252 32 71 ee			ld (debug_mark),a  
a255 3a 64 a2			ld a, (.dmark+1)  
a258 32 72 ee			ld (debug_mark+1),a  
a25b 3a 65 a2			ld a, (.dmark+2)  
a25e 32 73 ee			ld (debug_mark+2),a  
a261 18 03			jr .pastdmark  
a263 ..			.dmark: db ":0x"  
a266 f1			.pastdmark: pop af  
a267			endm  
# End of macro DMARK
a267				CALLMONITOR 
a267 cd dd 94			call break_point_state  
a26a				endm  
# End of macro CALLMONITOR
a26a c1				pop bc 
a26b			endif 
a26b			 
a26b			 
a26b				; create word preamble which should be: 
a26b			 
a26b			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a26b			 
a26b				;    ld hl, <word code> 
a26b				;    jp user_exec 
a26b			        ;    <word code bytes> 
a26b			 
a26b			 
a26b			;	inc de     ; TODO ??? or are we already past the word's null 
a26b eb				ex de, hl 
a26c			 
a26c 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a26e			 
a26e 23				inc hl 
a26f 22 b9 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a272 23				inc hl 
a273			 
a273 23				inc hl 
a274 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a276			 
a276 01 39 cb			ld bc, user_exec 
a279 23				inc hl 
a27a 71				ld (hl), c     ; poke address of user_exec 
a27b 23				inc hl 
a27c 70				ld (hl), b     
a27d			 ; 
a27d			;	inc hl 
a27d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a27d			; 
a27d			; 
a27d			;	ld bc, macro_forth_rsp_next 
a27d			;	inc hl 
a27d			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a27d			;	inc hl 
a27d			;	ld (hl), b     
a27d			 ; 
a27d			;	inc hl 
a27d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a27d			; 
a27d			; 
a27d			;	inc hl 
a27d			;	ld bc, forthexec 
a27d			;	ld (hl), c     ; poke address of forthexec 
a27d			;	inc hl 
a27d			;	ld (hl), b      
a27d			; 
a27d			;	inc hl 
a27d			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a27d			; 
a27d			;	ld bc, user_dict_next 
a27d			;	inc hl 
a27d			;	ld (hl), c     ; poke address of forthexec 
a27d			;	inc hl 
a27d			;	ld (hl), b      
a27d			 
a27d				; hl is now where we need to copy the word byte data to save this 
a27d			 
a27d 23				inc hl 
a27e 22 bb e2			ld (os_new_exec), hl 
a281				 
a281				; copy definition 
a281			 
a281 eb				ex de, hl 
a282			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a282			;	inc de    ; skip the PC for this parse 
a282 3a c3 e2			ld a, (os_new_parse_len) 
a285 4f				ld c, a 
a286 06 00			ld b, 0 
a288 ed b0			ldir		 ; copy defintion 
a28a			 
a28a			 
a28a				; poke the address of where the new word bytes live for forthexec 
a28a			 
a28a 2a b9 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a28d			 
a28d ed 5b bb e2		ld de, (os_new_exec)      
a291				 
a291 73				ld (hl), e 
a292 23				inc hl 
a293 72				ld (hl), d 
a294			 
a294					; TODO copy last user dict word next link to this word 
a294					; TODO update last user dict word to point to this word 
a294			; 
a294			; hl f923 de 812a ; bc 811a 
a294			 
a294			if DEBUG_FORTH_UWORD 
a294 c5				push bc 
a295 ed 4b c5 e2		ld bc, (os_new_malloc) 
a299						DMARK ":0A" 
a299 f5				push af  
a29a 3a ae a2			ld a, (.dmark)  
a29d 32 71 ee			ld (debug_mark),a  
a2a0 3a af a2			ld a, (.dmark+1)  
a2a3 32 72 ee			ld (debug_mark+1),a  
a2a6 3a b0 a2			ld a, (.dmark+2)  
a2a9 32 73 ee			ld (debug_mark+2),a  
a2ac 18 03			jr .pastdmark  
a2ae ..			.dmark: db ":0A"  
a2b1 f1			.pastdmark: pop af  
a2b2			endm  
# End of macro DMARK
a2b2				CALLMONITOR 
a2b2 cd dd 94			call break_point_state  
a2b5				endm  
# End of macro CALLMONITOR
a2b5 c1				pop bc 
a2b6			endif 
a2b6			if DEBUG_FORTH_UWORD 
a2b6 c5				push bc 
a2b7 ed 4b c5 e2		ld bc, (os_new_malloc) 
a2bb 03				inc bc 
a2bc 03				inc bc 
a2bd 03				inc bc 
a2be 03				inc bc 
a2bf 03				inc bc 
a2c0 03				inc bc 
a2c1 03				inc bc 
a2c2 03				inc bc 
a2c3			 
a2c3						DMARK ":0B" 
a2c3 f5				push af  
a2c4 3a d8 a2			ld a, (.dmark)  
a2c7 32 71 ee			ld (debug_mark),a  
a2ca 3a d9 a2			ld a, (.dmark+1)  
a2cd 32 72 ee			ld (debug_mark+1),a  
a2d0 3a da a2			ld a, (.dmark+2)  
a2d3 32 73 ee			ld (debug_mark+2),a  
a2d6 18 03			jr .pastdmark  
a2d8 ..			.dmark: db ":0B"  
a2db f1			.pastdmark: pop af  
a2dc			endm  
# End of macro DMARK
a2dc				CALLMONITOR 
a2dc cd dd 94			call break_point_state  
a2df				endm  
# End of macro CALLMONITOR
a2df c1				pop bc 
a2e0			endif 
a2e0			 
a2e0			; update word dict linked list for new word 
a2e0			 
a2e0			 
a2e0 2a c4 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2e3 23			inc hl     ; move to next work linked list ptr 
a2e4			 
a2e4 ed 5b c5 e2	ld de, (os_new_malloc)		 ; new next word 
a2e8 73			ld (hl), e 
a2e9 23			inc hl 
a2ea 72			ld (hl), d 
a2eb			 
a2eb			if DEBUG_FORTH_UWORD 
a2eb ed 4b c4 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2ef			endif 
a2ef			 
a2ef ed 53 c4 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2f3			 
a2f3			 
a2f3			if DEBUG_FORTH_UWORD 
a2f3						DMARK ":0+" 
a2f3 f5				push af  
a2f4 3a 08 a3			ld a, (.dmark)  
a2f7 32 71 ee			ld (debug_mark),a  
a2fa 3a 09 a3			ld a, (.dmark+1)  
a2fd 32 72 ee			ld (debug_mark+1),a  
a300 3a 0a a3			ld a, (.dmark+2)  
a303 32 73 ee			ld (debug_mark+2),a  
a306 18 03			jr .pastdmark  
a308 ..			.dmark: db ":0+"  
a30b f1			.pastdmark: pop af  
a30c			endm  
# End of macro DMARK
a30c				CALLMONITOR 
a30c cd dd 94			call break_point_state  
a30f				endm  
# End of macro CALLMONITOR
a30f			endif 
a30f			 
a30f				STACKFRAMECHK OFF $8efe $989f 
a30f				if DEBUG_STACK_IMB 
a30f					if OFF 
a30f						exx 
a30f						ld hl, $989f 
a30f						pop de   ; $989f 
a30f						call cmp16 
a30f						jr nz, .spnosame 
a30f						ld hl, $8efe 
a30f						pop de   ; $8efe 
a30f						call cmp16 
a30f						jr z, .spfrsame 
a30f						.spnosame: call showsperror 
a30f						.spfrsame: nop 
a30f						exx 
a30f					endif 
a30f				endif 
a30f			endm 
# End of macro STACKFRAMECHK
a30f			 
a30f c9			ret    ; dont process any remaining parser tokens as they form new word 
a310			 
a310			 
a310			 
a310			 
a310			;		NEXT 
a310			.SCOLN: 
a310			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a310 06				db OPCODE_SCOLN 
a311 5c a3			dw .DROP 
a313 02				db 2 
a314 .. 00			db ";",0           
a316			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a316					if DEBUG_FORTH_WORDS_KEY 
a316						DMARK "SCN" 
a316 f5				push af  
a317 3a 2b a3			ld a, (.dmark)  
a31a 32 71 ee			ld (debug_mark),a  
a31d 3a 2c a3			ld a, (.dmark+1)  
a320 32 72 ee			ld (debug_mark+1),a  
a323 3a 2d a3			ld a, (.dmark+2)  
a326 32 73 ee			ld (debug_mark+2),a  
a329 18 03			jr .pastdmark  
a32b ..			.dmark: db "SCN"  
a32e f1			.pastdmark: pop af  
a32f			endm  
# End of macro DMARK
a32f						CALLMONITOR 
a32f cd dd 94			call break_point_state  
a332				endm  
# End of macro CALLMONITOR
a332					endif 
a332					FORTH_RSP_TOS 
a332 cd 11 9b			call macro_forth_rsp_tos 
a335				endm 
# End of macro FORTH_RSP_TOS
a335 e5					push hl 
a336					FORTH_RSP_POP 
a336 cd 1b 9b			call macro_forth_rsp_pop 
a339				endm 
# End of macro FORTH_RSP_POP
a339 e1					pop hl 
a33a			;		ex de,hl 
a33a 22 c8 e5				ld (os_tok_ptr),hl 
a33d			 
a33d			if DEBUG_FORTH_UWORD 
a33d						DMARK "SCL" 
a33d f5				push af  
a33e 3a 52 a3			ld a, (.dmark)  
a341 32 71 ee			ld (debug_mark),a  
a344 3a 53 a3			ld a, (.dmark+1)  
a347 32 72 ee			ld (debug_mark+1),a  
a34a 3a 54 a3			ld a, (.dmark+2)  
a34d 32 73 ee			ld (debug_mark+2),a  
a350 18 03			jr .pastdmark  
a352 ..			.dmark: db "SCL"  
a355 f1			.pastdmark: pop af  
a356			endm  
# End of macro DMARK
a356				CALLMONITOR 
a356 cd dd 94			call break_point_state  
a359				endm  
# End of macro CALLMONITOR
a359			endif 
a359					NEXTW 
a359 c3 00 9f			jp macro_next 
a35c				endm 
# End of macro NEXTW
a35c			 
a35c			.DROP: 
a35c				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a35c 1b				db WORD_SYS_CORE+OPCODE_DROP             
a35d 87 a3			dw .DUP2            
a35f 05				db 4 + 1 
a360 .. 00			db "DROP",0              
a365				endm 
# End of macro CWHEAD
a365			; | DROP ( w -- )   drop the TOS item   | DONE 
a365					if DEBUG_FORTH_WORDS_KEY 
a365						DMARK "DRP" 
a365 f5				push af  
a366 3a 7a a3			ld a, (.dmark)  
a369 32 71 ee			ld (debug_mark),a  
a36c 3a 7b a3			ld a, (.dmark+1)  
a36f 32 72 ee			ld (debug_mark+1),a  
a372 3a 7c a3			ld a, (.dmark+2)  
a375 32 73 ee			ld (debug_mark+2),a  
a378 18 03			jr .pastdmark  
a37a ..			.dmark: db "DRP"  
a37d f1			.pastdmark: pop af  
a37e			endm  
# End of macro DMARK
a37e						CALLMONITOR 
a37e cd dd 94			call break_point_state  
a381				endm  
# End of macro CALLMONITOR
a381					endif 
a381					FORTH_DSP_POP 
a381 cd 02 9e			call macro_forth_dsp_pop 
a384				endm 
# End of macro FORTH_DSP_POP
a384					NEXTW 
a384 c3 00 9f			jp macro_next 
a387				endm 
# End of macro NEXTW
a387			.DUP2: 
a387				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a387 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a388 cc a3			dw .DROP2            
a38a 05				db 4 + 1 
a38b .. 00			db "2DUP",0              
a390				endm 
# End of macro CWHEAD
a390			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a390					if DEBUG_FORTH_WORDS_KEY 
a390						DMARK "2DU" 
a390 f5				push af  
a391 3a a5 a3			ld a, (.dmark)  
a394 32 71 ee			ld (debug_mark),a  
a397 3a a6 a3			ld a, (.dmark+1)  
a39a 32 72 ee			ld (debug_mark+1),a  
a39d 3a a7 a3			ld a, (.dmark+2)  
a3a0 32 73 ee			ld (debug_mark+2),a  
a3a3 18 03			jr .pastdmark  
a3a5 ..			.dmark: db "2DU"  
a3a8 f1			.pastdmark: pop af  
a3a9			endm  
# End of macro DMARK
a3a9						CALLMONITOR 
a3a9 cd dd 94			call break_point_state  
a3ac				endm  
# End of macro CALLMONITOR
a3ac					endif 
a3ac					FORTH_DSP_VALUEHL 
a3ac cd 4a 9d			call macro_dsp_valuehl 
a3af				endm 
# End of macro FORTH_DSP_VALUEHL
a3af e5					push hl      ; 2 
a3b0			 
a3b0					FORTH_DSP_POP 
a3b0 cd 02 9e			call macro_forth_dsp_pop 
a3b3				endm 
# End of macro FORTH_DSP_POP
a3b3					 
a3b3					FORTH_DSP_VALUEHL 
a3b3 cd 4a 9d			call macro_dsp_valuehl 
a3b6				endm 
# End of macro FORTH_DSP_VALUEHL
a3b6			;		push hl      ; 1 
a3b6			 
a3b6					FORTH_DSP_POP 
a3b6 cd 02 9e			call macro_forth_dsp_pop 
a3b9				endm 
# End of macro FORTH_DSP_POP
a3b9			 
a3b9			;		pop hl       ; 1 
a3b9 d1					pop de       ; 2 
a3ba			 
a3ba cd 53 9b				call forth_push_numhl 
a3bd eb					ex de, hl 
a3be cd 53 9b				call forth_push_numhl 
a3c1			 
a3c1					 
a3c1 eb					ex de, hl 
a3c2			 
a3c2 cd 53 9b				call forth_push_numhl 
a3c5 eb					ex de, hl 
a3c6 cd 53 9b				call forth_push_numhl 
a3c9			 
a3c9			 
a3c9					NEXTW 
a3c9 c3 00 9f			jp macro_next 
a3cc				endm 
# End of macro NEXTW
a3cc			.DROP2: 
a3cc				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3cc 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3cd fb a3			dw .SWAP2            
a3cf 06				db 5 + 1 
a3d0 .. 00			db "2DROP",0              
a3d6				endm 
# End of macro CWHEAD
a3d6			; | 2DROP ( w w -- )    Double drop | DONE 
a3d6					if DEBUG_FORTH_WORDS_KEY 
a3d6						DMARK "2DR" 
a3d6 f5				push af  
a3d7 3a eb a3			ld a, (.dmark)  
a3da 32 71 ee			ld (debug_mark),a  
a3dd 3a ec a3			ld a, (.dmark+1)  
a3e0 32 72 ee			ld (debug_mark+1),a  
a3e3 3a ed a3			ld a, (.dmark+2)  
a3e6 32 73 ee			ld (debug_mark+2),a  
a3e9 18 03			jr .pastdmark  
a3eb ..			.dmark: db "2DR"  
a3ee f1			.pastdmark: pop af  
a3ef			endm  
# End of macro DMARK
a3ef						CALLMONITOR 
a3ef cd dd 94			call break_point_state  
a3f2				endm  
# End of macro CALLMONITOR
a3f2					endif 
a3f2					FORTH_DSP_POP 
a3f2 cd 02 9e			call macro_forth_dsp_pop 
a3f5				endm 
# End of macro FORTH_DSP_POP
a3f5					FORTH_DSP_POP 
a3f5 cd 02 9e			call macro_forth_dsp_pop 
a3f8				endm 
# End of macro FORTH_DSP_POP
a3f8					NEXTW 
a3f8 c3 00 9f			jp macro_next 
a3fb				endm 
# End of macro NEXTW
a3fb			.SWAP2: 
a3fb				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3fb 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3fc 24 a4			dw .AT            
a3fe 06				db 5 + 1 
a3ff .. 00			db "2SWAP",0              
a405				endm 
# End of macro CWHEAD
a405			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a405					if DEBUG_FORTH_WORDS_KEY 
a405						DMARK "2SW" 
a405 f5				push af  
a406 3a 1a a4			ld a, (.dmark)  
a409 32 71 ee			ld (debug_mark),a  
a40c 3a 1b a4			ld a, (.dmark+1)  
a40f 32 72 ee			ld (debug_mark+1),a  
a412 3a 1c a4			ld a, (.dmark+2)  
a415 32 73 ee			ld (debug_mark+2),a  
a418 18 03			jr .pastdmark  
a41a ..			.dmark: db "2SW"  
a41d f1			.pastdmark: pop af  
a41e			endm  
# End of macro DMARK
a41e						CALLMONITOR 
a41e cd dd 94			call break_point_state  
a421				endm  
# End of macro CALLMONITOR
a421					endif 
a421					NEXTW 
a421 c3 00 9f			jp macro_next 
a424				endm 
# End of macro NEXTW
a424			.AT: 
a424				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a424 1f				db WORD_SYS_CORE+OPCODE_AT             
a425 56 a4			dw .CAT            
a427 02				db 1 + 1 
a428 .. 00			db "@",0              
a42a				endm 
# End of macro CWHEAD
a42a			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a42a			 
a42a					if DEBUG_FORTH_WORDS_KEY 
a42a						DMARK "AT." 
a42a f5				push af  
a42b 3a 3f a4			ld a, (.dmark)  
a42e 32 71 ee			ld (debug_mark),a  
a431 3a 40 a4			ld a, (.dmark+1)  
a434 32 72 ee			ld (debug_mark+1),a  
a437 3a 41 a4			ld a, (.dmark+2)  
a43a 32 73 ee			ld (debug_mark+2),a  
a43d 18 03			jr .pastdmark  
a43f ..			.dmark: db "AT."  
a442 f1			.pastdmark: pop af  
a443			endm  
# End of macro DMARK
a443						CALLMONITOR 
a443 cd dd 94			call break_point_state  
a446				endm  
# End of macro CALLMONITOR
a446					endif 
a446			.getbyteat:	 
a446					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a446 cd 4a 9d			call macro_dsp_valuehl 
a449				endm 
# End of macro FORTH_DSP_VALUEHL
a449					 
a449			;		push hl 
a449				 
a449					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a449 cd 02 9e			call macro_forth_dsp_pop 
a44c				endm 
# End of macro FORTH_DSP_POP
a44c			 
a44c			;		pop hl 
a44c			 
a44c 7e					ld a, (hl) 
a44d			 
a44d 6f					ld l, a 
a44e 26 00				ld h, 0 
a450 cd 53 9b				call forth_push_numhl 
a453			 
a453					NEXTW 
a453 c3 00 9f			jp macro_next 
a456				endm 
# End of macro NEXTW
a456			.CAT: 
a456				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a456 20				db WORD_SYS_CORE+OPCODE_CAT             
a457 7f a4			dw .BANG            
a459 03				db 2 + 1 
a45a .. 00			db "C@",0              
a45d				endm 
# End of macro CWHEAD
a45d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a45d					if DEBUG_FORTH_WORDS_KEY 
a45d						DMARK "CAA" 
a45d f5				push af  
a45e 3a 72 a4			ld a, (.dmark)  
a461 32 71 ee			ld (debug_mark),a  
a464 3a 73 a4			ld a, (.dmark+1)  
a467 32 72 ee			ld (debug_mark+1),a  
a46a 3a 74 a4			ld a, (.dmark+2)  
a46d 32 73 ee			ld (debug_mark+2),a  
a470 18 03			jr .pastdmark  
a472 ..			.dmark: db "CAA"  
a475 f1			.pastdmark: pop af  
a476			endm  
# End of macro DMARK
a476						CALLMONITOR 
a476 cd dd 94			call break_point_state  
a479				endm  
# End of macro CALLMONITOR
a479					endif 
a479 c3 46 a4				jp .getbyteat 
a47c					NEXTW 
a47c c3 00 9f			jp macro_next 
a47f				endm 
# End of macro NEXTW
a47f			.BANG: 
a47f				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a47f 21				db WORD_SYS_CORE+OPCODE_BANG             
a480 b5 a4			dw .CBANG            
a482 02				db 1 + 1 
a483 .. 00			db "!",0              
a485				endm 
# End of macro CWHEAD
a485			; | ! ( x w -- ) Store x at address w      | DONE 
a485					if DEBUG_FORTH_WORDS_KEY 
a485						DMARK "BNG" 
a485 f5				push af  
a486 3a 9a a4			ld a, (.dmark)  
a489 32 71 ee			ld (debug_mark),a  
a48c 3a 9b a4			ld a, (.dmark+1)  
a48f 32 72 ee			ld (debug_mark+1),a  
a492 3a 9c a4			ld a, (.dmark+2)  
a495 32 73 ee			ld (debug_mark+2),a  
a498 18 03			jr .pastdmark  
a49a ..			.dmark: db "BNG"  
a49d f1			.pastdmark: pop af  
a49e			endm  
# End of macro DMARK
a49e						CALLMONITOR 
a49e cd dd 94			call break_point_state  
a4a1				endm  
# End of macro CALLMONITOR
a4a1					endif 
a4a1			 
a4a1			.storebyteat:		 
a4a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a1 cd 4a 9d			call macro_dsp_valuehl 
a4a4				endm 
# End of macro FORTH_DSP_VALUEHL
a4a4					 
a4a4 e5					push hl 
a4a5				 
a4a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4a5 cd 02 9e			call macro_forth_dsp_pop 
a4a8				endm 
# End of macro FORTH_DSP_POP
a4a8			 
a4a8					; get byte to poke 
a4a8			 
a4a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4a8 cd 4a 9d			call macro_dsp_valuehl 
a4ab				endm 
# End of macro FORTH_DSP_VALUEHL
a4ab e5					push hl 
a4ac			 
a4ac			 
a4ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ac cd 02 9e			call macro_forth_dsp_pop 
a4af				endm 
# End of macro FORTH_DSP_POP
a4af			 
a4af			 
a4af d1					pop de 
a4b0 e1					pop hl 
a4b1			 
a4b1 73					ld (hl),e 
a4b2			 
a4b2			 
a4b2					NEXTW 
a4b2 c3 00 9f			jp macro_next 
a4b5				endm 
# End of macro NEXTW
a4b5			.CBANG: 
a4b5				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a4b5 22				db WORD_SYS_CORE+OPCODE_CBANG             
a4b6 de a4			dw .SCALL            
a4b8 03				db 2 + 1 
a4b9 .. 00			db "C!",0              
a4bc				endm 
# End of macro CWHEAD
a4bc			; | C!  ( x w -- ) Store x at address w  | DONE 
a4bc					if DEBUG_FORTH_WORDS_KEY 
a4bc						DMARK "CBA" 
a4bc f5				push af  
a4bd 3a d1 a4			ld a, (.dmark)  
a4c0 32 71 ee			ld (debug_mark),a  
a4c3 3a d2 a4			ld a, (.dmark+1)  
a4c6 32 72 ee			ld (debug_mark+1),a  
a4c9 3a d3 a4			ld a, (.dmark+2)  
a4cc 32 73 ee			ld (debug_mark+2),a  
a4cf 18 03			jr .pastdmark  
a4d1 ..			.dmark: db "CBA"  
a4d4 f1			.pastdmark: pop af  
a4d5			endm  
# End of macro DMARK
a4d5						CALLMONITOR 
a4d5 cd dd 94			call break_point_state  
a4d8				endm  
# End of macro CALLMONITOR
a4d8					endif 
a4d8 c3 a1 a4				jp .storebyteat 
a4db					NEXTW 
a4db c3 00 9f			jp macro_next 
a4de				endm 
# End of macro NEXTW
a4de			.SCALL: 
a4de				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4de 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4df 12 a5			dw .DEPTH            
a4e1 05				db 4 + 1 
a4e2 .. 00			db "CALL",0              
a4e7				endm 
# End of macro CWHEAD
a4e7			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4e7					if DEBUG_FORTH_WORDS_KEY 
a4e7						DMARK "CLL" 
a4e7 f5				push af  
a4e8 3a fc a4			ld a, (.dmark)  
a4eb 32 71 ee			ld (debug_mark),a  
a4ee 3a fd a4			ld a, (.dmark+1)  
a4f1 32 72 ee			ld (debug_mark+1),a  
a4f4 3a fe a4			ld a, (.dmark+2)  
a4f7 32 73 ee			ld (debug_mark+2),a  
a4fa 18 03			jr .pastdmark  
a4fc ..			.dmark: db "CLL"  
a4ff f1			.pastdmark: pop af  
a500			endm  
# End of macro DMARK
a500						CALLMONITOR 
a500 cd dd 94			call break_point_state  
a503				endm  
# End of macro CALLMONITOR
a503					endif 
a503			 
a503					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a503 cd 4a 9d			call macro_dsp_valuehl 
a506				endm 
# End of macro FORTH_DSP_VALUEHL
a506			 
a506			;		push hl 
a506			 
a506					; destroy value TOS 
a506			 
a506					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a506 cd 02 9e			call macro_forth_dsp_pop 
a509				endm 
# End of macro FORTH_DSP_POP
a509			 
a509						 
a509			;		pop hl 
a509			 
a509					; how to do a call with hl???? save SP? 
a509 cd a4 9e				call forth_call_hl 
a50c			 
a50c			 
a50c					; TODO push value back onto stack for another op etc 
a50c			 
a50c cd 53 9b				call forth_push_numhl 
a50f					NEXTW 
a50f c3 00 9f			jp macro_next 
a512				endm 
# End of macro NEXTW
a512			.DEPTH: 
a512				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a512 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a513 4f a5			dw .OVER            
a515 06				db 5 + 1 
a516 .. 00			db "DEPTH",0              
a51c				endm 
# End of macro CWHEAD
a51c			; | DEPTH ( -- u ) Push count of stack | DONE 
a51c					; take current TOS and remove from base value div by two to get count 
a51c					if DEBUG_FORTH_WORDS_KEY 
a51c						DMARK "DEP" 
a51c f5				push af  
a51d 3a 31 a5			ld a, (.dmark)  
a520 32 71 ee			ld (debug_mark),a  
a523 3a 32 a5			ld a, (.dmark+1)  
a526 32 72 ee			ld (debug_mark+1),a  
a529 3a 33 a5			ld a, (.dmark+2)  
a52c 32 73 ee			ld (debug_mark+2),a  
a52f 18 03			jr .pastdmark  
a531 ..			.dmark: db "DEP"  
a534 f1			.pastdmark: pop af  
a535			endm  
# End of macro DMARK
a535						CALLMONITOR 
a535 cd dd 94			call break_point_state  
a538				endm  
# End of macro CALLMONITOR
a538					endif 
a538			 
a538			 
a538 2a f4 e9			ld hl, (cli_data_sp) 
a53b 11 2e e8			ld de, cli_data_stack 
a53e ed 52			sbc hl,de 
a540				 
a540				; div by size of stack item 
a540			 
a540 5d				ld e,l 
a541 0e 03			ld c, 3 
a543 cd 6c 8c			call Div8 
a546			 
a546 6f				ld l,a 
a547 26 00			ld h,0 
a549			 
a549				;srl h 
a549				;rr l 
a549			 
a549 cd 53 9b				call forth_push_numhl 
a54c					NEXTW 
a54c c3 00 9f			jp macro_next 
a54f				endm 
# End of macro NEXTW
a54f			.OVER: 
a54f				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a54f 42				db WORD_SYS_CORE+46             
a550 96 a5			dw .PAUSE            
a552 05				db 4 + 1 
a553 .. 00			db "OVER",0              
a558				endm 
# End of macro CWHEAD
a558			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a558					if DEBUG_FORTH_WORDS_KEY 
a558						DMARK "OVR" 
a558 f5				push af  
a559 3a 6d a5			ld a, (.dmark)  
a55c 32 71 ee			ld (debug_mark),a  
a55f 3a 6e a5			ld a, (.dmark+1)  
a562 32 72 ee			ld (debug_mark+1),a  
a565 3a 6f a5			ld a, (.dmark+2)  
a568 32 73 ee			ld (debug_mark+2),a  
a56b 18 03			jr .pastdmark  
a56d ..			.dmark: db "OVR"  
a570 f1			.pastdmark: pop af  
a571			endm  
# End of macro DMARK
a571						CALLMONITOR 
a571 cd dd 94			call break_point_state  
a574				endm  
# End of macro CALLMONITOR
a574					endif 
a574			 
a574					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a574 cd 4a 9d			call macro_dsp_valuehl 
a577				endm 
# End of macro FORTH_DSP_VALUEHL
a577 e5					push hl    ; n2 
a578					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a578 cd 02 9e			call macro_forth_dsp_pop 
a57b				endm 
# End of macro FORTH_DSP_POP
a57b			 
a57b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a57b cd 4a 9d			call macro_dsp_valuehl 
a57e				endm 
# End of macro FORTH_DSP_VALUEHL
a57e e5					push hl    ; n1 
a57f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a57f cd 02 9e			call macro_forth_dsp_pop 
a582				endm 
# End of macro FORTH_DSP_POP
a582			 
a582 d1					pop de     ; n1 
a583 e1					pop hl     ; n2 
a584			 
a584 d5					push de 
a585 e5					push hl 
a586 d5					push de 
a587			 
a587					; push back  
a587			 
a587 e1					pop hl 
a588 cd 53 9b				call forth_push_numhl 
a58b e1					pop hl 
a58c cd 53 9b				call forth_push_numhl 
a58f e1					pop hl 
a590 cd 53 9b				call forth_push_numhl 
a593					NEXTW 
a593 c3 00 9f			jp macro_next 
a596				endm 
# End of macro NEXTW
a596			 
a596			.PAUSE: 
a596				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a596 43				db WORD_SYS_CORE+47             
a597 cb a5			dw .PAUSES            
a599 08				db 7 + 1 
a59a .. 00			db "PAUSEMS",0              
a5a2				endm 
# End of macro CWHEAD
a5a2			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a5a2					if DEBUG_FORTH_WORDS_KEY 
a5a2						DMARK "PMS" 
a5a2 f5				push af  
a5a3 3a b7 a5			ld a, (.dmark)  
a5a6 32 71 ee			ld (debug_mark),a  
a5a9 3a b8 a5			ld a, (.dmark+1)  
a5ac 32 72 ee			ld (debug_mark+1),a  
a5af 3a b9 a5			ld a, (.dmark+2)  
a5b2 32 73 ee			ld (debug_mark+2),a  
a5b5 18 03			jr .pastdmark  
a5b7 ..			.dmark: db "PMS"  
a5ba f1			.pastdmark: pop af  
a5bb			endm  
# End of macro DMARK
a5bb						CALLMONITOR 
a5bb cd dd 94			call break_point_state  
a5be				endm  
# End of macro CALLMONITOR
a5be					endif 
a5be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5be cd 4a 9d			call macro_dsp_valuehl 
a5c1				endm 
# End of macro FORTH_DSP_VALUEHL
a5c1			;		push hl    ; n2 
a5c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5c1 cd 02 9e			call macro_forth_dsp_pop 
a5c4				endm 
# End of macro FORTH_DSP_POP
a5c4			;		pop hl 
a5c4			 
a5c4 7d					ld a, l 
a5c5 cd d7 89				call aDelayInMS 
a5c8				       NEXTW 
a5c8 c3 00 9f			jp macro_next 
a5cb				endm 
# End of macro NEXTW
a5cb			.PAUSES:  
a5cb				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5cb 44				db WORD_SYS_CORE+48             
a5cc 3a a6			dw .ROT            
a5ce 06				db 5 + 1 
a5cf .. 00			db "PAUSE",0              
a5d5				endm 
# End of macro CWHEAD
a5d5			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5d5					if DEBUG_FORTH_WORDS_KEY 
a5d5						DMARK "PAU" 
a5d5 f5				push af  
a5d6 3a ea a5			ld a, (.dmark)  
a5d9 32 71 ee			ld (debug_mark),a  
a5dc 3a eb a5			ld a, (.dmark+1)  
a5df 32 72 ee			ld (debug_mark+1),a  
a5e2 3a ec a5			ld a, (.dmark+2)  
a5e5 32 73 ee			ld (debug_mark+2),a  
a5e8 18 03			jr .pastdmark  
a5ea ..			.dmark: db "PAU"  
a5ed f1			.pastdmark: pop af  
a5ee			endm  
# End of macro DMARK
a5ee						CALLMONITOR 
a5ee cd dd 94			call break_point_state  
a5f1				endm  
# End of macro CALLMONITOR
a5f1					endif 
a5f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5f1 cd 4a 9d			call macro_dsp_valuehl 
a5f4				endm 
# End of macro FORTH_DSP_VALUEHL
a5f4			;		push hl    ; n2 
a5f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5f4 cd 02 9e			call macro_forth_dsp_pop 
a5f7				endm 
# End of macro FORTH_DSP_POP
a5f7			;		pop hl 
a5f7 45					ld b, l 
a5f8					if DEBUG_FORTH_WORDS 
a5f8						DMARK "PAU" 
a5f8 f5				push af  
a5f9 3a 0d a6			ld a, (.dmark)  
a5fc 32 71 ee			ld (debug_mark),a  
a5ff 3a 0e a6			ld a, (.dmark+1)  
a602 32 72 ee			ld (debug_mark+1),a  
a605 3a 0f a6			ld a, (.dmark+2)  
a608 32 73 ee			ld (debug_mark+2),a  
a60b 18 03			jr .pastdmark  
a60d ..			.dmark: db "PAU"  
a610 f1			.pastdmark: pop af  
a611			endm  
# End of macro DMARK
a611						CALLMONITOR 
a611 cd dd 94			call break_point_state  
a614				endm  
# End of macro CALLMONITOR
a614					endif 
a614 c5			.pauses1:	push bc 
a615 cd f2 89				call delay1s 
a618 c1					pop bc 
a619					if DEBUG_FORTH_WORDS 
a619						DMARK "PA1" 
a619 f5				push af  
a61a 3a 2e a6			ld a, (.dmark)  
a61d 32 71 ee			ld (debug_mark),a  
a620 3a 2f a6			ld a, (.dmark+1)  
a623 32 72 ee			ld (debug_mark+1),a  
a626 3a 30 a6			ld a, (.dmark+2)  
a629 32 73 ee			ld (debug_mark+2),a  
a62c 18 03			jr .pastdmark  
a62e ..			.dmark: db "PA1"  
a631 f1			.pastdmark: pop af  
a632			endm  
# End of macro DMARK
a632						CALLMONITOR 
a632 cd dd 94			call break_point_state  
a635				endm  
# End of macro CALLMONITOR
a635					endif 
a635 10 dd				djnz .pauses1 
a637			 
a637				       NEXTW 
a637 c3 00 9f			jp macro_next 
a63a				endm 
# End of macro NEXTW
a63a			.ROT: 
a63a				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a63a 45				db WORD_SYS_CORE+49             
a63b 88 a6			dw .UWORDS            
a63d 04				db 3 + 1 
a63e .. 00			db "ROT",0              
a642				endm 
# End of macro CWHEAD
a642			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a642					if DEBUG_FORTH_WORDS_KEY 
a642						DMARK "ROT" 
a642 f5				push af  
a643 3a 57 a6			ld a, (.dmark)  
a646 32 71 ee			ld (debug_mark),a  
a649 3a 58 a6			ld a, (.dmark+1)  
a64c 32 72 ee			ld (debug_mark+1),a  
a64f 3a 59 a6			ld a, (.dmark+2)  
a652 32 73 ee			ld (debug_mark+2),a  
a655 18 03			jr .pastdmark  
a657 ..			.dmark: db "ROT"  
a65a f1			.pastdmark: pop af  
a65b			endm  
# End of macro DMARK
a65b						CALLMONITOR 
a65b cd dd 94			call break_point_state  
a65e				endm  
# End of macro CALLMONITOR
a65e					endif 
a65e			 
a65e					FORTH_DSP_VALUEHL 
a65e cd 4a 9d			call macro_dsp_valuehl 
a661				endm 
# End of macro FORTH_DSP_VALUEHL
a661 e5					push hl    ; u3  
a662			 
a662					FORTH_DSP_POP 
a662 cd 02 9e			call macro_forth_dsp_pop 
a665				endm 
# End of macro FORTH_DSP_POP
a665			   
a665					FORTH_DSP_VALUEHL 
a665 cd 4a 9d			call macro_dsp_valuehl 
a668				endm 
# End of macro FORTH_DSP_VALUEHL
a668 e5					push hl     ; u2 
a669			 
a669					FORTH_DSP_POP 
a669 cd 02 9e			call macro_forth_dsp_pop 
a66c				endm 
# End of macro FORTH_DSP_POP
a66c			 
a66c					FORTH_DSP_VALUEHL 
a66c cd 4a 9d			call macro_dsp_valuehl 
a66f				endm 
# End of macro FORTH_DSP_VALUEHL
a66f e5					push hl     ; u1 
a670			 
a670					FORTH_DSP_POP 
a670 cd 02 9e			call macro_forth_dsp_pop 
a673				endm 
# End of macro FORTH_DSP_POP
a673			 
a673 c1					pop bc      ; u1 
a674 e1					pop hl      ; u2 
a675 d1					pop de      ; u3 
a676			 
a676			 
a676 c5					push bc 
a677 d5					push de 
a678 e5					push hl 
a679			 
a679			 
a679 e1					pop hl 
a67a cd 53 9b				call forth_push_numhl 
a67d			 
a67d e1					pop hl 
a67e cd 53 9b				call forth_push_numhl 
a681			 
a681 e1					pop hl 
a682 cd 53 9b				call forth_push_numhl 
a685					 
a685			 
a685			 
a685			 
a685			 
a685			 
a685				       NEXTW 
a685 c3 00 9f			jp macro_next 
a688				endm 
# End of macro NEXTW
a688			 
a688			.UWORDS: 
a688				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a688 50				db WORD_SYS_CORE+60             
a689 4a a7			dw .BP            
a68b 07				db 6 + 1 
a68c .. 00			db "UWORDS",0              
a693				endm 
# End of macro CWHEAD
a693			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a693			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a693			; | | Following the count are the individual words. 
a693			; | | 
a693			; | | e.g. UWORDS 
a693			; | | BOX DIRLIST 2 
a693			; | |  
a693			; | | Can be used to save the words to storage via: 
a693			; | | UWORDS $01 DO $01 APPEND LOOP 
a693				if DEBUG_FORTH_WORDS_KEY 
a693					DMARK "UWR" 
a693 f5				push af  
a694 3a a8 a6			ld a, (.dmark)  
a697 32 71 ee			ld (debug_mark),a  
a69a 3a a9 a6			ld a, (.dmark+1)  
a69d 32 72 ee			ld (debug_mark+1),a  
a6a0 3a aa a6			ld a, (.dmark+2)  
a6a3 32 73 ee			ld (debug_mark+2),a  
a6a6 18 03			jr .pastdmark  
a6a8 ..			.dmark: db "UWR"  
a6ab f1			.pastdmark: pop af  
a6ac			endm  
# End of macro DMARK
a6ac					CALLMONITOR 
a6ac cd dd 94			call break_point_state  
a6af				endm  
# End of macro CALLMONITOR
a6af				endif 
a6af 21 55 e3				ld hl, baseram 
a6b2					;ld hl, baseusermem 
a6b2 01 00 00				ld bc, 0    ; start a counter 
a6b5			 
a6b5				; skip dict stub 
a6b5			 
a6b5 cd 51 a0				call forth_tok_next 
a6b8			 
a6b8			 
a6b8			; while we have words to look for 
a6b8			 
a6b8 7e			.douscan:	ld a, (hl)      
a6b9				if DEBUG_FORTH_WORDS 
a6b9					DMARK "UWs" 
a6b9 f5				push af  
a6ba 3a ce a6			ld a, (.dmark)  
a6bd 32 71 ee			ld (debug_mark),a  
a6c0 3a cf a6			ld a, (.dmark+1)  
a6c3 32 72 ee			ld (debug_mark+1),a  
a6c6 3a d0 a6			ld a, (.dmark+2)  
a6c9 32 73 ee			ld (debug_mark+2),a  
a6cc 18 03			jr .pastdmark  
a6ce ..			.dmark: db "UWs"  
a6d1 f1			.pastdmark: pop af  
a6d2			endm  
# End of macro DMARK
a6d2					CALLMONITOR 
a6d2 cd dd 94			call break_point_state  
a6d5				endm  
# End of macro CALLMONITOR
a6d5				endif 
a6d5 fe 00				cp WORD_SYS_END 
a6d7 28 4d				jr z, .udone 
a6d9 fe 01				cp WORD_SYS_UWORD 
a6db 20 44				jr nz, .nuword 
a6dd			 
a6dd				if DEBUG_FORTH_WORDS 
a6dd					DMARK "UWu" 
a6dd f5				push af  
a6de 3a f2 a6			ld a, (.dmark)  
a6e1 32 71 ee			ld (debug_mark),a  
a6e4 3a f3 a6			ld a, (.dmark+1)  
a6e7 32 72 ee			ld (debug_mark+1),a  
a6ea 3a f4 a6			ld a, (.dmark+2)  
a6ed 32 73 ee			ld (debug_mark+2),a  
a6f0 18 03			jr .pastdmark  
a6f2 ..			.dmark: db "UWu"  
a6f5 f1			.pastdmark: pop af  
a6f6			endm  
# End of macro DMARK
a6f6					CALLMONITOR 
a6f6 cd dd 94			call break_point_state  
a6f9				endm  
# End of macro CALLMONITOR
a6f9				endif 
a6f9					; we have a uword so push its name to the stack 
a6f9			 
a6f9 e5				   	push hl  ; save so we can move to next dict block 
a6fa			 
a6fa					; skip opcode 
a6fa 23					inc hl  
a6fb					; skip next ptr 
a6fb 23					inc hl  
a6fc 23					inc hl 
a6fd					; skip len 
a6fd 23					inc hl 
a6fe				if DEBUG_FORTH_WORDS 
a6fe					DMARK "UWt" 
a6fe f5				push af  
a6ff 3a 13 a7			ld a, (.dmark)  
a702 32 71 ee			ld (debug_mark),a  
a705 3a 14 a7			ld a, (.dmark+1)  
a708 32 72 ee			ld (debug_mark+1),a  
a70b 3a 15 a7			ld a, (.dmark+2)  
a70e 32 73 ee			ld (debug_mark+2),a  
a711 18 03			jr .pastdmark  
a713 ..			.dmark: db "UWt"  
a716 f1			.pastdmark: pop af  
a717			endm  
# End of macro DMARK
a717					CALLMONITOR 
a717 cd dd 94			call break_point_state  
a71a				endm  
# End of macro CALLMONITOR
a71a				endif 
a71a 03					inc bc 
a71b			 
a71b c5					push bc 
a71c cd c1 9b				call forth_push_str 
a71f c1					pop bc 
a720			 
a720 e1					pop hl 	 
a721			 
a721 cd 51 a0		.nuword:	call forth_tok_next 
a724 18 92				jr .douscan  
a726			 
a726			.udone:		 ; push count of uwords found 
a726 c5					push bc 
a727 e1					pop hl 
a728			 
a728				if DEBUG_FORTH_WORDS 
a728					DMARK "UWc" 
a728 f5				push af  
a729 3a 3d a7			ld a, (.dmark)  
a72c 32 71 ee			ld (debug_mark),a  
a72f 3a 3e a7			ld a, (.dmark+1)  
a732 32 72 ee			ld (debug_mark+1),a  
a735 3a 3f a7			ld a, (.dmark+2)  
a738 32 73 ee			ld (debug_mark+2),a  
a73b 18 03			jr .pastdmark  
a73d ..			.dmark: db "UWc"  
a740 f1			.pastdmark: pop af  
a741			endm  
# End of macro DMARK
a741					CALLMONITOR 
a741 cd dd 94			call break_point_state  
a744				endm  
# End of macro CALLMONITOR
a744				endif 
a744 cd 53 9b				call forth_push_numhl 
a747			 
a747			 
a747				       NEXTW 
a747 c3 00 9f			jp macro_next 
a74a				endm 
# End of macro NEXTW
a74a			 
a74a			.BP: 
a74a				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a74a 54				db WORD_SYS_CORE+64             
a74b 80 a7			dw .MONITOR            
a74d 03				db 2 + 1 
a74e .. 00			db "BP",0              
a751				endm 
# End of macro CWHEAD
a751			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a751			; | | $00 Will enable the break points within specific code paths 
a751			; | | $01 Will disable break points 
a751			; | |  
a751			; | | By default break points are off. Either the above can be used to enable them 
a751			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a751			; | | and on release of the pressed key a message will be disaplayed to notify 
a751			; | | that break points are enabled. Pressing any key will then continue boot process. 
a751					; get byte count 
a751					if DEBUG_FORTH_WORDS_KEY 
a751						DMARK "BP." 
a751 f5				push af  
a752 3a 66 a7			ld a, (.dmark)  
a755 32 71 ee			ld (debug_mark),a  
a758 3a 67 a7			ld a, (.dmark+1)  
a75b 32 72 ee			ld (debug_mark+1),a  
a75e 3a 68 a7			ld a, (.dmark+2)  
a761 32 73 ee			ld (debug_mark+2),a  
a764 18 03			jr .pastdmark  
a766 ..			.dmark: db "BP."  
a769 f1			.pastdmark: pop af  
a76a			endm  
# End of macro DMARK
a76a						CALLMONITOR 
a76a cd dd 94			call break_point_state  
a76d				endm  
# End of macro CALLMONITOR
a76d					endif 
a76d			 
a76d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a76d cd 4a 9d			call macro_dsp_valuehl 
a770				endm 
# End of macro FORTH_DSP_VALUEHL
a770			 
a770			;		push hl 
a770			 
a770					; destroy value TOS 
a770			 
a770					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a770 cd 02 9e			call macro_forth_dsp_pop 
a773				endm 
# End of macro FORTH_DSP_POP
a773			 
a773			;		pop hl 
a773			 
a773 3e 00				ld a,0 
a775 bd					cp l 
a776 28 02				jr z, .bpset 
a778 3e 2a				ld a, '*' 
a77a			 
a77a 32 b8 e2		.bpset:		ld (os_view_disable), a 
a77d			 
a77d			 
a77d					NEXTW 
a77d c3 00 9f			jp macro_next 
a780				endm 
# End of macro NEXTW
a780			 
a780			 
a780			.MONITOR: 
a780				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a780 55				db WORD_SYS_CORE+65             
a781 b3 a7			dw .MALLOC            
a783 08				db 7 + 1 
a784 .. 00			db "MONITOR",0              
a78c				endm 
# End of macro CWHEAD
a78c			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a78c			; | | At start the current various registers will be displayed with contents. 
a78c			; | | Top right corner will show the most recent debug marker seen. 
a78c			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a78c			; | | and the return stack pointer (RSP). 
a78c			; | | Pressing: 
a78c			; | |    1 - Initial screen 
a78c			; | |    2 - Display a data dump of HL 
a78c			; | |    3 - Display a data dump of DE 
a78c			; | |    4 - Display a data dump of BC 
a78c			; | |    5 - Display a data dump of HL 
a78c			; | |    6 - Display a data dump of DSP 
a78c			; | |    7 - Display a data dump of RSP 
a78c			; | |    8 - Display a data dump of what is at DSP 
a78c			; | |    9 - Display a data dump of what is at RSP 
a78c			; | |    0 - Exit monitor and continue running. This will also enable break points 
a78c			; | |    * - Disable break points 
a78c			; | |    # - Enter traditional monitor mode 
a78c			; | | 
a78c			; | | Monitor Mode 
a78c			; | | ------------ 
a78c			; | | A prompt of '>' will be shown for various commands: 
a78c			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a78c			; | |    C - Continue display a data dump from the last set address 
a78c			; | |    M xxxx - Set start of memory edit at address xx 
a78c			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a78c			; | |    Q - Return to previous 
a78c					if DEBUG_FORTH_WORDS_KEY 
a78c						DMARK "MON" 
a78c f5				push af  
a78d 3a a1 a7			ld a, (.dmark)  
a790 32 71 ee			ld (debug_mark),a  
a793 3a a2 a7			ld a, (.dmark+1)  
a796 32 72 ee			ld (debug_mark+1),a  
a799 3a a3 a7			ld a, (.dmark+2)  
a79c 32 73 ee			ld (debug_mark+2),a  
a79f 18 03			jr .pastdmark  
a7a1 ..			.dmark: db "MON"  
a7a4 f1			.pastdmark: pop af  
a7a5			endm  
# End of macro DMARK
a7a5						CALLMONITOR 
a7a5 cd dd 94			call break_point_state  
a7a8				endm  
# End of macro CALLMONITOR
a7a8					endif 
a7a8 3e 00				ld a, 0 
a7aa 32 b8 e2				ld (os_view_disable), a 
a7ad			 
a7ad					CALLMONITOR 
a7ad cd dd 94			call break_point_state  
a7b0				endm  
# End of macro CALLMONITOR
a7b0			 
a7b0			;	call monitor 
a7b0			 
a7b0					NEXTW 
a7b0 c3 00 9f			jp macro_next 
a7b3				endm 
# End of macro NEXTW
a7b3			 
a7b3			 
a7b3			.MALLOC: 
a7b3				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a7b3 56				db WORD_SYS_CORE+66             
a7b4 dc a7			dw .MALLOC2            
a7b6 06				db 5 + 1 
a7b7 .. 00			db "ALLOT",0              
a7bd				endm 
# End of macro CWHEAD
a7bd			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7bd					if DEBUG_FORTH_WORDS_KEY 
a7bd						DMARK "ALL" 
a7bd f5				push af  
a7be 3a d2 a7			ld a, (.dmark)  
a7c1 32 71 ee			ld (debug_mark),a  
a7c4 3a d3 a7			ld a, (.dmark+1)  
a7c7 32 72 ee			ld (debug_mark+1),a  
a7ca 3a d4 a7			ld a, (.dmark+2)  
a7cd 32 73 ee			ld (debug_mark+2),a  
a7d0 18 03			jr .pastdmark  
a7d2 ..			.dmark: db "ALL"  
a7d5 f1			.pastdmark: pop af  
a7d6			endm  
# End of macro DMARK
a7d6						CALLMONITOR 
a7d6 cd dd 94			call break_point_state  
a7d9				endm  
# End of macro CALLMONITOR
a7d9					endif 
a7d9 c3 03 a8				jp .mallocc 
a7dc			.MALLOC2: 
a7dc				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7dc 56				db WORD_SYS_CORE+66             
a7dd 1a a8			dw .FREE            
a7df 07				db 6 + 1 
a7e0 .. 00			db "MALLOC",0              
a7e7				endm 
# End of macro CWHEAD
a7e7			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7e7					; get byte count 
a7e7					if DEBUG_FORTH_WORDS_KEY 
a7e7						DMARK "MAL" 
a7e7 f5				push af  
a7e8 3a fc a7			ld a, (.dmark)  
a7eb 32 71 ee			ld (debug_mark),a  
a7ee 3a fd a7			ld a, (.dmark+1)  
a7f1 32 72 ee			ld (debug_mark+1),a  
a7f4 3a fe a7			ld a, (.dmark+2)  
a7f7 32 73 ee			ld (debug_mark+2),a  
a7fa 18 03			jr .pastdmark  
a7fc ..			.dmark: db "MAL"  
a7ff f1			.pastdmark: pop af  
a800			endm  
# End of macro DMARK
a800						CALLMONITOR 
a800 cd dd 94			call break_point_state  
a803				endm  
# End of macro CALLMONITOR
a803					endif 
a803			.mallocc: 
a803					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a803 cd 4a 9d			call macro_dsp_valuehl 
a806				endm 
# End of macro FORTH_DSP_VALUEHL
a806			 
a806			;		push hl 
a806			 
a806					; destroy value TOS 
a806			 
a806					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a806 cd 02 9e			call macro_forth_dsp_pop 
a809				endm 
# End of macro FORTH_DSP_POP
a809			 
a809			;		pop hl 
a809 cd a3 91				call malloc 
a80c				if DEBUG_FORTH_MALLOC_GUARD 
a80c f5					push af 
a80d cd 05 8d				call ishlzero 
a810			;		ld a, l 
a810			;		add h 
a810			;		cp 0 
a810 f1					pop af 
a811					 
a811 cc 0b cc				call z,malloc_error 
a814				endif 
a814			 
a814 cd 53 9b				call forth_push_numhl 
a817					NEXTW 
a817 c3 00 9f			jp macro_next 
a81a				endm 
# End of macro NEXTW
a81a			 
a81a			.FREE: 
a81a				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a81a 57				db WORD_SYS_CORE+67             
a81b 4b a8			dw .LIST            
a81d 05				db 4 + 1 
a81e .. 00			db "FREE",0              
a823				endm 
# End of macro CWHEAD
a823			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a823					if DEBUG_FORTH_WORDS_KEY 
a823						DMARK "FRE" 
a823 f5				push af  
a824 3a 38 a8			ld a, (.dmark)  
a827 32 71 ee			ld (debug_mark),a  
a82a 3a 39 a8			ld a, (.dmark+1)  
a82d 32 72 ee			ld (debug_mark+1),a  
a830 3a 3a a8			ld a, (.dmark+2)  
a833 32 73 ee			ld (debug_mark+2),a  
a836 18 03			jr .pastdmark  
a838 ..			.dmark: db "FRE"  
a83b f1			.pastdmark: pop af  
a83c			endm  
# End of macro DMARK
a83c						CALLMONITOR 
a83c cd dd 94			call break_point_state  
a83f				endm  
# End of macro CALLMONITOR
a83f					endif 
a83f					; get address 
a83f			 
a83f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a83f cd 4a 9d			call macro_dsp_valuehl 
a842				endm 
# End of macro FORTH_DSP_VALUEHL
a842			 
a842			;		push hl 
a842			 
a842					; destroy value TOS 
a842			 
a842					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a842 cd 02 9e			call macro_forth_dsp_pop 
a845				endm 
# End of macro FORTH_DSP_POP
a845			 
a845			;		pop hl 
a845			if FORTH_ENABLE_MALLOCFREE 
a845 cd 6d 92				call free 
a848			endif 
a848					NEXTW 
a848 c3 00 9f			jp macro_next 
a84b				endm 
# End of macro NEXTW
a84b			.LIST: 
a84b				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a84b 5c				db WORD_SYS_CORE+72             
a84c 39 aa			dw .FORGET            
a84e 05				db 4 + 1 
a84f .. 00			db "LIST",0              
a854				endm 
# End of macro CWHEAD
a854			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a854			; | | The quoted word must be in upper case. 
a854				if DEBUG_FORTH_WORDS_KEY 
a854					DMARK "LST" 
a854 f5				push af  
a855 3a 69 a8			ld a, (.dmark)  
a858 32 71 ee			ld (debug_mark),a  
a85b 3a 6a a8			ld a, (.dmark+1)  
a85e 32 72 ee			ld (debug_mark+1),a  
a861 3a 6b a8			ld a, (.dmark+2)  
a864 32 73 ee			ld (debug_mark+2),a  
a867 18 03			jr .pastdmark  
a869 ..			.dmark: db "LST"  
a86c f1			.pastdmark: pop af  
a86d			endm  
# End of macro DMARK
a86d					CALLMONITOR 
a86d cd dd 94			call break_point_state  
a870				endm  
# End of macro CALLMONITOR
a870				endif 
a870			 
a870					FORTH_DSP_VALUEHL 
a870 cd 4a 9d			call macro_dsp_valuehl 
a873				endm 
# End of macro FORTH_DSP_VALUEHL
a873			 
a873 e5					push hl 
a874					FORTH_DSP_POP 
a874 cd 02 9e			call macro_forth_dsp_pop 
a877				endm 
# End of macro FORTH_DSP_POP
a877 c1					pop bc 
a878			 
a878			; Start format of scratch string 
a878			 
a878 21 c7 e2				ld hl, scratch 
a87b			 
a87b 3e 3a				ld a, ':' 
a87d 77					ld (hl),a 
a87e 23					inc hl 
a87f 3e 20				ld a, ' ' 
a881 77					ld (hl), a 
a882			 
a882					; Get ptr to the word we need to look up 
a882			 
a882			;		FORTH_DSP_VALUEHL 
a882					;v5 FORTH_DSP_VALUE 
a882				; TODO type check 
a882			;		inc hl    ; Skip type check  
a882			;		push hl 
a882			;		ex de, hl    ; put into DE 
a882			 
a882			 
a882 21 55 e3				ld hl, baseram 
a885					;ld hl, baseusermem 
a885			 
a885 e5			push hl   ; sacreifical push 
a886			 
a886			.ldouscanm: 
a886 e1				pop hl 
a887			.ldouscan: 
a887				if DEBUG_FORTH_WORDS 
a887					DMARK "LSs" 
a887 f5				push af  
a888 3a 9c a8			ld a, (.dmark)  
a88b 32 71 ee			ld (debug_mark),a  
a88e 3a 9d a8			ld a, (.dmark+1)  
a891 32 72 ee			ld (debug_mark+1),a  
a894 3a 9e a8			ld a, (.dmark+2)  
a897 32 73 ee			ld (debug_mark+2),a  
a89a 18 03			jr .pastdmark  
a89c ..			.dmark: db "LSs"  
a89f f1			.pastdmark: pop af  
a8a0			endm  
# End of macro DMARK
a8a0					CALLMONITOR 
a8a0 cd dd 94			call break_point_state  
a8a3				endm  
# End of macro CALLMONITOR
a8a3				endif 
a8a3				; skip dict stub 
a8a3 cd 51 a0				call forth_tok_next 
a8a6			 
a8a6			 
a8a6			; while we have words to look for 
a8a6			 
a8a6 7e				ld a, (hl)      
a8a7				if DEBUG_FORTH_WORDS 
a8a7					DMARK "LSk" 
a8a7 f5				push af  
a8a8 3a bc a8			ld a, (.dmark)  
a8ab 32 71 ee			ld (debug_mark),a  
a8ae 3a bd a8			ld a, (.dmark+1)  
a8b1 32 72 ee			ld (debug_mark+1),a  
a8b4 3a be a8			ld a, (.dmark+2)  
a8b7 32 73 ee			ld (debug_mark+2),a  
a8ba 18 03			jr .pastdmark  
a8bc ..			.dmark: db "LSk"  
a8bf f1			.pastdmark: pop af  
a8c0			endm  
# End of macro DMARK
a8c0					CALLMONITOR 
a8c0 cd dd 94			call break_point_state  
a8c3				endm  
# End of macro CALLMONITOR
a8c3				endif 
a8c3					;cp WORD_SYS_END 
a8c3					;jp z, .lunotfound 
a8c3			 
a8c3					; if we hit non uwords then gone too far 
a8c3 fe 01				cp WORD_SYS_UWORD 
a8c5 c2 f5 a9				jp nz, .lunotfound 
a8c8			 
a8c8				if DEBUG_FORTH_WORDS 
a8c8					DMARK "LSu" 
a8c8 f5				push af  
a8c9 3a dd a8			ld a, (.dmark)  
a8cc 32 71 ee			ld (debug_mark),a  
a8cf 3a de a8			ld a, (.dmark+1)  
a8d2 32 72 ee			ld (debug_mark+1),a  
a8d5 3a df a8			ld a, (.dmark+2)  
a8d8 32 73 ee			ld (debug_mark+2),a  
a8db 18 03			jr .pastdmark  
a8dd ..			.dmark: db "LSu"  
a8e0 f1			.pastdmark: pop af  
a8e1			endm  
# End of macro DMARK
a8e1					CALLMONITOR 
a8e1 cd dd 94			call break_point_state  
a8e4				endm  
# End of macro CALLMONITOR
a8e4				endif 
a8e4			 
a8e4					; found a uword but is it the one we want... 
a8e4			 
a8e4 c5					push bc     ; uword to find is on bc 
a8e5 d1					pop de 
a8e6			 
a8e6 e5					push hl  ; to save the ptr 
a8e7			 
a8e7					; skip opcode 
a8e7 23					inc hl  
a8e8					; skip next ptr 
a8e8 23					inc hl  
a8e9 23					inc hl 
a8ea					; skip len 
a8ea 23					inc hl 
a8eb			 
a8eb				if DEBUG_FORTH_WORDS 
a8eb					DMARK "LSc" 
a8eb f5				push af  
a8ec 3a 00 a9			ld a, (.dmark)  
a8ef 32 71 ee			ld (debug_mark),a  
a8f2 3a 01 a9			ld a, (.dmark+1)  
a8f5 32 72 ee			ld (debug_mark+1),a  
a8f8 3a 02 a9			ld a, (.dmark+2)  
a8fb 32 73 ee			ld (debug_mark+2),a  
a8fe 18 03			jr .pastdmark  
a900 ..			.dmark: db "LSc"  
a903 f1			.pastdmark: pop af  
a904			endm  
# End of macro DMARK
a904					CALLMONITOR 
a904 cd dd 94			call break_point_state  
a907				endm  
# End of macro CALLMONITOR
a907				endif 
a907 cd 72 91				call strcmp 
a90a c2 86 a8				jp nz, .ldouscanm 
a90d				 
a90d			 
a90d			 
a90d					; we have a uword so push its name to the stack 
a90d			 
a90d			;	   	push hl  ; save so we can move to next dict block 
a90d e1			pop hl 
a90e			 
a90e				if DEBUG_FORTH_WORDS 
a90e					DMARK "LSm" 
a90e f5				push af  
a90f 3a 23 a9			ld a, (.dmark)  
a912 32 71 ee			ld (debug_mark),a  
a915 3a 24 a9			ld a, (.dmark+1)  
a918 32 72 ee			ld (debug_mark+1),a  
a91b 3a 25 a9			ld a, (.dmark+2)  
a91e 32 73 ee			ld (debug_mark+2),a  
a921 18 03			jr .pastdmark  
a923 ..			.dmark: db "LSm"  
a926 f1			.pastdmark: pop af  
a927			endm  
# End of macro DMARK
a927					CALLMONITOR 
a927 cd dd 94			call break_point_state  
a92a				endm  
# End of macro CALLMONITOR
a92a				endif 
a92a			 
a92a					; skip opcode 
a92a 23					inc hl  
a92b					; skip next ptr 
a92b 23					inc hl  
a92c 23					inc hl 
a92d					; skip len 
a92d 7e					ld a, (hl)   ; save length to add 
a92e				if DEBUG_FORTH_WORDS 
a92e					DMARK "LS2" 
a92e f5				push af  
a92f 3a 43 a9			ld a, (.dmark)  
a932 32 71 ee			ld (debug_mark),a  
a935 3a 44 a9			ld a, (.dmark+1)  
a938 32 72 ee			ld (debug_mark+1),a  
a93b 3a 45 a9			ld a, (.dmark+2)  
a93e 32 73 ee			ld (debug_mark+2),a  
a941 18 03			jr .pastdmark  
a943 ..			.dmark: db "LS2"  
a946 f1			.pastdmark: pop af  
a947			endm  
# End of macro DMARK
a947					CALLMONITOR 
a947 cd dd 94			call break_point_state  
a94a				endm  
# End of macro CALLMONITOR
a94a				endif 
a94a			 
a94a					; save this location 
a94a				 
a94a e5					push hl 
a94b			 
a94b 23					inc hl 
a94c 11 c9 e2				ld de, scratch+2 
a94f 4f					ld c, a 
a950 06 00				ld b, 0 
a952			 
a952				if DEBUG_FORTH_WORDS 
a952					DMARK "LSn" 
a952 f5				push af  
a953 3a 67 a9			ld a, (.dmark)  
a956 32 71 ee			ld (debug_mark),a  
a959 3a 68 a9			ld a, (.dmark+1)  
a95c 32 72 ee			ld (debug_mark+1),a  
a95f 3a 69 a9			ld a, (.dmark+2)  
a962 32 73 ee			ld (debug_mark+2),a  
a965 18 03			jr .pastdmark  
a967 ..			.dmark: db "LSn"  
a96a f1			.pastdmark: pop af  
a96b			endm  
# End of macro DMARK
a96b					CALLMONITOR 
a96b cd dd 94			call break_point_state  
a96e				endm  
# End of macro CALLMONITOR
a96e				endif 
a96e			 
a96e					; copy uword name to scratch 
a96e			 
a96e ed b0				ldir 
a970			 
a970 1b					dec de 
a971 3e 20				ld a, ' '    ; change null to space 
a973 12					ld (de), a 
a974			 
a974 13					inc de 
a975			 
a975 d5					push de 
a976 c1					pop bc     ; move scratch pointer to end of word name and save it 
a977			 
a977 e1					pop hl 
a978 7e					ld a, (hl) 
a979					;inc hl 
a979					; skip word string 
a979 cd dc 8c				call addatohl 
a97c			 
a97c 23					inc hl 
a97d			 
a97d				if DEBUG_FORTH_WORDS 
a97d					DMARK "LS3" 
a97d f5				push af  
a97e 3a 92 a9			ld a, (.dmark)  
a981 32 71 ee			ld (debug_mark),a  
a984 3a 93 a9			ld a, (.dmark+1)  
a987 32 72 ee			ld (debug_mark+1),a  
a98a 3a 94 a9			ld a, (.dmark+2)  
a98d 32 73 ee			ld (debug_mark+2),a  
a990 18 03			jr .pastdmark  
a992 ..			.dmark: db "LS3"  
a995 f1			.pastdmark: pop af  
a996			endm  
# End of macro DMARK
a996					CALLMONITOR 
a996 cd dd 94			call break_point_state  
a999				endm  
# End of macro CALLMONITOR
a999				endif 
a999					; should now be at the start of the machine code to setup the eval of the uword 
a999					; now locate the ptr to the string defintion 
a999			 
a999					; skip ld hl, 
a999					; then load the ptr 
a999			; TODO use get from hl ptr 
a999 23					inc hl 
a99a 5e					ld e, (hl) 
a99b 23					inc hl 
a99c 56					ld d, (hl) 
a99d eb					ex de, hl 
a99e			 
a99e			 
a99e				if DEBUG_FORTH_WORDS 
a99e					DMARK "LSt" 
a99e f5				push af  
a99f 3a b3 a9			ld a, (.dmark)  
a9a2 32 71 ee			ld (debug_mark),a  
a9a5 3a b4 a9			ld a, (.dmark+1)  
a9a8 32 72 ee			ld (debug_mark+1),a  
a9ab 3a b5 a9			ld a, (.dmark+2)  
a9ae 32 73 ee			ld (debug_mark+2),a  
a9b1 18 03			jr .pastdmark  
a9b3 ..			.dmark: db "LSt"  
a9b6 f1			.pastdmark: pop af  
a9b7			endm  
# End of macro DMARK
a9b7					CALLMONITOR 
a9b7 cd dd 94			call break_point_state  
a9ba				endm  
# End of macro CALLMONITOR
a9ba				endif 
a9ba			 
a9ba			; cant push right now due to tokenised strings  
a9ba			 
a9ba			; get the destination of where to copy this definition to. 
a9ba			 
a9ba c5					push bc 
a9bb d1					pop de 
a9bc			 
a9bc 7e			.listl:         ld a,(hl) 
a9bd fe 00				cp 0 
a9bf 28 09				jr z, .lreplsp     ; replace zero with space 
a9c1					;cp FORTH_END_BUFFER 
a9c1 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9c3 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9c5				 
a9c5					; just copy this char as is then 
a9c5			 
a9c5 12					ld (de), a 
a9c6			 
a9c6 23			.listnxt:	inc hl 
a9c7 13					inc de 
a9c8 18 f2				jr .listl 
a9ca			 
a9ca 3e 20		.lreplsp:	ld a,' ' 
a9cc 12					ld (de), a 
a9cd 18 f7				jr .listnxt 
a9cf			 
a9cf			; close up uword def 
a9cf			 
a9cf			.listdone: 
a9cf 12					ld (de), a 
a9d0 13					inc de 
a9d1 3e 00				ld a, 0 
a9d3 12					ld (de), a 
a9d4			 
a9d4			; now have def so clean up and push to stack 
a9d4			 
a9d4 21 c7 e2				ld hl, scratch 
a9d7				if DEBUG_FORTH_WORDS 
a9d7					DMARK "Ltp" 
a9d7 f5				push af  
a9d8 3a ec a9			ld a, (.dmark)  
a9db 32 71 ee			ld (debug_mark),a  
a9de 3a ed a9			ld a, (.dmark+1)  
a9e1 32 72 ee			ld (debug_mark+1),a  
a9e4 3a ee a9			ld a, (.dmark+2)  
a9e7 32 73 ee			ld (debug_mark+2),a  
a9ea 18 03			jr .pastdmark  
a9ec ..			.dmark: db "Ltp"  
a9ef f1			.pastdmark: pop af  
a9f0			endm  
# End of macro DMARK
a9f0					CALLMONITOR 
a9f0 cd dd 94			call break_point_state  
a9f3				endm  
# End of macro CALLMONITOR
a9f3				endif 
a9f3			 
a9f3 18 1f			jr .listpush 
a9f5			 
a9f5			;.lnuword:	pop hl 
a9f5			;		call forth_tok_next 
a9f5			;		jp .ldouscan  
a9f5			 
a9f5			.lunotfound:		  
a9f5			 
a9f5				if DEBUG_FORTH_WORDS 
a9f5					DMARK "LSn" 
a9f5 f5				push af  
a9f6 3a 0a aa			ld a, (.dmark)  
a9f9 32 71 ee			ld (debug_mark),a  
a9fc 3a 0b aa			ld a, (.dmark+1)  
a9ff 32 72 ee			ld (debug_mark+1),a  
aa02 3a 0c aa			ld a, (.dmark+2)  
aa05 32 73 ee			ld (debug_mark+2),a  
aa08 18 03			jr .pastdmark  
aa0a ..			.dmark: db "LSn"  
aa0d f1			.pastdmark: pop af  
aa0e			endm  
# End of macro DMARK
aa0e					CALLMONITOR 
aa0e cd dd 94			call break_point_state  
aa11				endm  
# End of macro CALLMONITOR
aa11				endif 
aa11			 
aa11					 
aa11			;		FORTH_DSP_POP 
aa11			;		ld hl, .luno 
aa11			 
aa11					NEXTW			 
aa11 c3 00 9f			jp macro_next 
aa14				endm 
# End of macro NEXTW
aa14			 
aa14			.listpush: 
aa14				if DEBUG_FORTH_WORDS 
aa14					DMARK "LS>" 
aa14 f5				push af  
aa15 3a 29 aa			ld a, (.dmark)  
aa18 32 71 ee			ld (debug_mark),a  
aa1b 3a 2a aa			ld a, (.dmark+1)  
aa1e 32 72 ee			ld (debug_mark+1),a  
aa21 3a 2b aa			ld a, (.dmark+2)  
aa24 32 73 ee			ld (debug_mark+2),a  
aa27 18 03			jr .pastdmark  
aa29 ..			.dmark: db "LS>"  
aa2c f1			.pastdmark: pop af  
aa2d			endm  
# End of macro DMARK
aa2d					CALLMONITOR 
aa2d cd dd 94			call break_point_state  
aa30				endm  
# End of macro CALLMONITOR
aa30				endif 
aa30 cd c1 9b				call forth_push_str 
aa33			 
aa33			 
aa33			 
aa33					NEXTW 
aa33 c3 00 9f			jp macro_next 
aa36				endm 
# End of macro NEXTW
aa36			 
aa36			;.luno:    db "Word not found",0 
aa36			 
aa36			 
aa36			 
aa36			 
aa36			 
aa36			;		push hl   ; save pointer to start of uword def string 
aa36			; 
aa36			;; look for FORTH_EOL_LINE 
aa36			;		ld a, FORTH_END_BUFFER 
aa36			;		call strlent 
aa36			; 
aa36			;		inc hl		 ; space for coln def 
aa36			;		inc hl 
aa36			;		inc hl          ; space for terms 
aa36			;		inc hl 
aa36			; 
aa36			;		ld a, 20   ; TODO get actual length 
aa36			;		call addatohl    ; include a random amount of room for the uword name 
aa36			; 
aa36			;		 
aa36			;	if DEBUG_FORTH_WORDS 
aa36			;		DMARK "Lt1" 
aa36			;		CALLMONITOR 
aa36			;	endif 
aa36			;		 
aa36			; 
aa36			;; malloc space for the string because we cant change it 
aa36			; 
aa36			;		call malloc 
aa36			;	if DEBUG_FORTH_MALLOC_GUARD 
aa36			;		push af 
aa36			;		call ishlzero 
aa36			;		pop af 
aa36			;		 
aa36			;		call z,malloc_error 
aa36			;	endif 
aa36			; 
aa36			;	if DEBUG_FORTH_WORDS 
aa36			;		DMARK "Lt2" 
aa36			;		CALLMONITOR 
aa36			;	endif 
aa36			;		pop de 
aa36			;		push hl    ; push the malloc to release later 
aa36			;		push hl   ;  push back a copy for the later stack push 
aa36			;		 
aa36			;; copy the string swapping out the zero terms for spaces 
aa36			; 
aa36			;		; de has our source 
aa36			;		; hl has our dest 
aa36			; 
aa36			;; add the coln def 
aa36			; 
aa36			;		ld a, ':' 
aa36			;		ld (hl), a 
aa36			;		inc hl 
aa36			;		ld a, ' ' 
aa36			;		ld (hl), a 
aa36			;		inc hl 
aa36			; 
aa36			;; add the uname word 
aa36			;		push de   ; save our string for now 
aa36			;		ex de, hl 
aa36			; 
aa36			;		FORTH_DSP_VALUE 
aa36			;		;v5 FORTH_DSP_VALUE 
aa36			; 
aa36			;		inc hl   ; skip type but we know by now this is OK 
aa36			; 
aa36			;.luword:	ld a,(hl) 
aa36			;		cp 0 
aa36			;		jr z, .luword2 
aa36			;		ld (de), a 
aa36			;		inc de 
aa36			;		inc hl 
aa36			;		jr .luword 
aa36			; 
aa36			;.luword2:	ld a, ' ' 
aa36			;		ld (de), a 
aa36			;;		inc hl 
aa36			;;		inc de 
aa36			;;		ld (de), a 
aa36			;;		inc hl 
aa36			;		inc de 
aa36			; 
aa36			;		ex de, hl 
aa36			;		pop de 
aa36			;		 
aa36			;		 
aa36			; 
aa36			;; detoken that string and copy it 
aa36			; 
aa36			;	if DEBUG_FORTH_WORDS 
aa36			;		DMARK "Lt2" 
aa36			;		CALLMONITOR 
aa36			;	endif 
aa36			;.ldetok:	ld a, (de) 
aa36			;		cp FORTH_END_BUFFER 
aa36			;		jr z, .ldetokend 
aa36			;		; swap out any zero term for space 
aa36			;		cp 0 
aa36			;		jr nz, .ldetoknext 
aa36			;		ld a, ' ' 
aa36			; 
aa36			;	if DEBUG_FORTH_WORDS 
aa36			;		DMARK "LtS" 
aa36			;		CALLMONITOR 
aa36			;	endif 
aa36			;.ldetoknext:	ld (hl), a 
aa36			;		inc de 
aa36			;		inc hl 
aa36			;		jr .ldetok 
aa36			; 
aa36			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa36			;		ld (hl), a  
aa36			; 
aa36			;; free that temp malloc 
aa36			; 
aa36			;		pop hl    
aa36			; 
aa36			;	if DEBUG_FORTH_WORDS 
aa36			;		DMARK "Lt4" 
aa36			;		CALLMONITOR 
aa36			;	endif 
aa36			;		call forth_apushstrhl 
aa36			; 
aa36			;		; get rid of temp malloc area 
aa36			; 
aa36			;		pop hl 
aa36			;		call free 
aa36			; 
aa36			;		jr .ludone 
aa36			; 
aa36			;.lnuword:	pop hl 
aa36			;		call forth_tok_next 
aa36			;		jp .ldouscan  
aa36			; 
aa36			;.ludone:		 pop hl 
aa36			; 
aa36					NEXTW 
aa36 c3 00 9f			jp macro_next 
aa39				endm 
# End of macro NEXTW
aa39			 
aa39			.FORGET: 
aa39				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa39 5d				db WORD_SYS_CORE+73             
aa3a b2 aa			dw .NOP            
aa3c 07				db 6 + 1 
aa3d .. 00			db "FORGET",0              
aa44				endm 
# End of macro CWHEAD
aa44			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa44			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa44			; | |  
aa44			; | | e.g. "MORE" forget 
aa44					if DEBUG_FORTH_WORDS_KEY 
aa44						DMARK "FRG" 
aa44 f5				push af  
aa45 3a 59 aa			ld a, (.dmark)  
aa48 32 71 ee			ld (debug_mark),a  
aa4b 3a 5a aa			ld a, (.dmark+1)  
aa4e 32 72 ee			ld (debug_mark+1),a  
aa51 3a 5b aa			ld a, (.dmark+2)  
aa54 32 73 ee			ld (debug_mark+2),a  
aa57 18 03			jr .pastdmark  
aa59 ..			.dmark: db "FRG"  
aa5c f1			.pastdmark: pop af  
aa5d			endm  
# End of macro DMARK
aa5d						CALLMONITOR 
aa5d cd dd 94			call break_point_state  
aa60				endm  
# End of macro CALLMONITOR
aa60					endif 
aa60			 
aa60				; find uword 
aa60			        ; update start of word with "_" 
aa60				; replace uword with deleted flag 
aa60			 
aa60			 
aa60			;	if DEBUG_FORTH_WORDS 
aa60			;		DMARK "FOG" 
aa60			;		CALLMONITOR 
aa60			;	endif 
aa60			 
aa60			 
aa60					; Get ptr to the word we need to look up 
aa60			 
aa60					FORTH_DSP_VALUEHL 
aa60 cd 4a 9d			call macro_dsp_valuehl 
aa63				endm 
# End of macro FORTH_DSP_VALUEHL
aa63					;v5 FORTH_DSP_VALUE 
aa63				; TODO type check 
aa63			;		inc hl    ; Skip type check  
aa63 e5					push hl 
aa64 c1					pop bc 
aa65			;		ex de, hl    ; put into DE 
aa65			 
aa65			 
aa65 21 55 e3				ld hl, baseram 
aa68					;ld hl, baseusermem 
aa68			 
aa68				; skip dict stub 
aa68			;	call forth_tok_next 
aa68 e5			push hl   ; sacreifical push 
aa69			 
aa69			.fldouscanm: 
aa69 e1				pop hl 
aa6a			.fldouscan: 
aa6a			;	if DEBUG_FORTH_WORDS 
aa6a			;		DMARK "LSs" 
aa6a			;		CALLMONITOR 
aa6a			;	endif 
aa6a				; skip dict stub 
aa6a cd 51 a0				call forth_tok_next 
aa6d			 
aa6d			 
aa6d			; while we have words to look for 
aa6d			 
aa6d 7e				ld a, (hl)      
aa6e			;	if DEBUG_FORTH_WORDS 
aa6e			;		DMARK "LSk" 
aa6e			;		CALLMONITOR 
aa6e			;	endif 
aa6e fe 00				cp WORD_SYS_END 
aa70 ca ac aa				jp z, .flunotfound 
aa73 fe 01				cp WORD_SYS_UWORD 
aa75 c2 6a aa				jp nz, .fldouscan 
aa78			 
aa78			;	if DEBUG_FORTH_WORDS 
aa78			;		DMARK "LSu" 
aa78			;		CALLMONITOR 
aa78			;	endif 
aa78			 
aa78					; found a uword but is it the one we want... 
aa78			 
aa78 c5					push bc     ; uword to find is on bc 
aa79 d1					pop de 
aa7a			 
aa7a e5					push hl  ; to save the ptr 
aa7b			 
aa7b					; skip opcode 
aa7b 23					inc hl  
aa7c					; skip next ptr 
aa7c 23					inc hl  
aa7d 23					inc hl 
aa7e					; skip len 
aa7e 23					inc hl 
aa7f			 
aa7f			;	if DEBUG_FORTH_WORDS 
aa7f			;		DMARK "LSc" 
aa7f			;		CALLMONITOR 
aa7f			;	endif 
aa7f cd 72 91				call strcmp 
aa82 c2 69 aa				jp nz, .fldouscanm 
aa85			; 
aa85			; 
aa85			;; while we have words to look for 
aa85			; 
aa85			;.fdouscan:	ld a, (hl)      
aa85			;	if DEBUG_FORTH_WORDS 
aa85			;		DMARK "LSs" 
aa85			;		CALLMONITOR 
aa85			;	endif 
aa85			;		cp WORD_SYS_END 
aa85			;		jp z, .fudone 
aa85			;		cp WORD_SYS_UWORD 
aa85			;		jp nz, .fnuword 
aa85			; 
aa85			;	if DEBUG_FORTH_WORDS 
aa85			;		DMARK "FGu" 
aa85			;		CALLMONITOR 
aa85			;	endif 
aa85			; 
aa85			;		; found a uword but is it the one we want... 
aa85			; 
aa85			; 
aa85			;	        pop de   ; get back the dsp name 
aa85			;		push de 
aa85			; 
aa85			;		push hl  ; to save the ptr 
aa85			; 
aa85			;		; skip opcode 
aa85			;		inc hl  
aa85			;		; skip next ptr 
aa85			;		inc hl  
aa85			;		inc hl 
aa85			;		; skip len 
aa85			;		inc hl 
aa85			; 
aa85			;	if DEBUG_FORTH_WORDS 
aa85			;		DMARK "FGc" 
aa85			;		CALLMONITOR 
aa85			;	endif 
aa85			;		call strcmp 
aa85			;		jp nz, .fnuword 
aa85			 
aa85			 
aa85 e1			pop hl 
aa86			 
aa86				 
aa86				if DEBUG_FORTH_WORDS 
aa86					DMARK "FGm" 
aa86 f5				push af  
aa87 3a 9b aa			ld a, (.dmark)  
aa8a 32 71 ee			ld (debug_mark),a  
aa8d 3a 9c aa			ld a, (.dmark+1)  
aa90 32 72 ee			ld (debug_mark+1),a  
aa93 3a 9d aa			ld a, (.dmark+2)  
aa96 32 73 ee			ld (debug_mark+2),a  
aa99 18 03			jr .pastdmark  
aa9b ..			.dmark: db "FGm"  
aa9e f1			.pastdmark: pop af  
aa9f			endm  
# End of macro DMARK
aa9f					CALLMONITOR 
aa9f cd dd 94			call break_point_state  
aaa2				endm  
# End of macro CALLMONITOR
aaa2				endif 
aaa2			 
aaa2			 
aaa2			 
aaa2					; we have a uword so push its name to the stack 
aaa2			 
aaa2			;	   	push hl  ; save so we can move to next dict block 
aaa2			;pop hl 
aaa2			 
aaa2					; update opcode to deleted 
aaa2 3e 03				ld a, WORD_SYS_DELETED 
aaa4 77					ld (hl), a 
aaa5			 
aaa5 23					inc hl  
aaa6					; skip next ptr 
aaa6 23					inc hl  
aaa7 23					inc hl 
aaa8					; skip len 
aaa8 23					inc hl 
aaa9			 
aaa9					; TODO change parser to skip deleted words but for now mark it out 
aaa9 3e 5f				ld a, "_" 
aaab 77					ld  (hl),a 
aaac			 
aaac			;		jr .fudone 
aaac			; 
aaac			;.fnuword:	pop hl 
aaac			;		call forth_tok_next 
aaac			;		jp .fdouscan  
aaac			 
aaac			.flunotfound:		  
aaac			 
aaac			 
aaac					 
aaac					FORTH_DSP_POP 
aaac cd 02 9e			call macro_forth_dsp_pop 
aaaf				endm 
# End of macro FORTH_DSP_POP
aaaf			;		ld hl, .luno 
aaaf			;.fudone:		 pop hl 
aaaf					NEXTW 
aaaf c3 00 9f			jp macro_next 
aab2				endm 
# End of macro NEXTW
aab2			.NOP: 
aab2				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aab2 61				db WORD_SYS_CORE+77             
aab3 d9 aa			dw .COMO            
aab5 04				db 3 + 1 
aab6 .. 00			db "NOP",0              
aaba				endm 
# End of macro CWHEAD
aaba			; | NOP (  --  ) Do nothing | DONE 
aaba					if DEBUG_FORTH_WORDS_KEY 
aaba						DMARK "NOP" 
aaba f5				push af  
aabb 3a cf aa			ld a, (.dmark)  
aabe 32 71 ee			ld (debug_mark),a  
aac1 3a d0 aa			ld a, (.dmark+1)  
aac4 32 72 ee			ld (debug_mark+1),a  
aac7 3a d1 aa			ld a, (.dmark+2)  
aaca 32 73 ee			ld (debug_mark+2),a  
aacd 18 03			jr .pastdmark  
aacf ..			.dmark: db "NOP"  
aad2 f1			.pastdmark: pop af  
aad3			endm  
# End of macro DMARK
aad3						CALLMONITOR 
aad3 cd dd 94			call break_point_state  
aad6				endm  
# End of macro CALLMONITOR
aad6					endif 
aad6				       NEXTW 
aad6 c3 00 9f			jp macro_next 
aad9				endm 
# End of macro NEXTW
aad9			.COMO: 
aad9				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aad9 6e				db WORD_SYS_CORE+90             
aada 2b ab			dw .COMC            
aadc 02				db 1 + 1 
aadd .. 00			db "(",0              
aadf				endm 
# End of macro CWHEAD
aadf			; | ( ( -- )  Start of comment | DONE 
aadf			 
aadf			 
aadf 2a c8 e5				ld hl, ( os_tok_ptr) 
aae2 11 26 ab			ld de, .closepar 
aae5					 
aae5					if DEBUG_FORTH_WORDS 
aae5						DMARK ").." 
aae5 f5				push af  
aae6 3a fa aa			ld a, (.dmark)  
aae9 32 71 ee			ld (debug_mark),a  
aaec 3a fb aa			ld a, (.dmark+1)  
aaef 32 72 ee			ld (debug_mark+1),a  
aaf2 3a fc aa			ld a, (.dmark+2)  
aaf5 32 73 ee			ld (debug_mark+2),a  
aaf8 18 03			jr .pastdmark  
aafa ..			.dmark: db ").."  
aafd f1			.pastdmark: pop af  
aafe			endm  
# End of macro DMARK
aafe						CALLMONITOR 
aafe cd dd 94			call break_point_state  
ab01				endm  
# End of macro CALLMONITOR
ab01					endif 
ab01 cd 1b a0			call findnexttok  
ab04			 
ab04					if DEBUG_FORTH_WORDS 
ab04						DMARK "IF5" 
ab04 f5				push af  
ab05 3a 19 ab			ld a, (.dmark)  
ab08 32 71 ee			ld (debug_mark),a  
ab0b 3a 1a ab			ld a, (.dmark+1)  
ab0e 32 72 ee			ld (debug_mark+1),a  
ab11 3a 1b ab			ld a, (.dmark+2)  
ab14 32 73 ee			ld (debug_mark+2),a  
ab17 18 03			jr .pastdmark  
ab19 ..			.dmark: db "IF5"  
ab1c f1			.pastdmark: pop af  
ab1d			endm  
# End of macro DMARK
ab1d						CALLMONITOR 
ab1d cd dd 94			call break_point_state  
ab20				endm  
# End of macro CALLMONITOR
ab20					endif 
ab20				; replace below with ) exec using tok_ptr 
ab20 22 c8 e5			ld (os_tok_ptr), hl 
ab23 c3 91 9f			jp exec1 
ab26			 
ab26 .. 00			.closepar:   db ")",0 
ab28			 
ab28				       NEXTW 
ab28 c3 00 9f			jp macro_next 
ab2b				endm 
# End of macro NEXTW
ab2b			.COMC: 
ab2b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab2b 6f				db WORD_SYS_CORE+91             
ab2c 34 ab			dw .SCRATCH            
ab2e 02				db 1 + 1 
ab2f .. 00			db ")",0              
ab31				endm 
# End of macro CWHEAD
ab31			; | ) ( -- )  End of comment |  DONE  
ab31				       NEXTW 
ab31 c3 00 9f			jp macro_next 
ab34				endm 
# End of macro NEXTW
ab34			 
ab34			.SCRATCH: 
ab34				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab34 6f				db WORD_SYS_CORE+91             
ab35 6f ab			dw .INC            
ab37 08				db 7 + 1 
ab38 .. 00			db "SCRATCH",0              
ab40				endm 
# End of macro CWHEAD
ab40			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab40			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab40			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab40			; | |  
ab40			; | | e.g.    : score $00 scratch ; 
ab40			; | |  
ab40			; | | $00 score ! 
ab40			; | | $01 score +! 
ab40			; | |  
ab40			; | | e.g.   : varword $0a scratch ;  
ab40			; | | 
ab40			; | | $8000 varword ! 
ab40					if DEBUG_FORTH_WORDS_KEY 
ab40						DMARK "SCR" 
ab40 f5				push af  
ab41 3a 55 ab			ld a, (.dmark)  
ab44 32 71 ee			ld (debug_mark),a  
ab47 3a 56 ab			ld a, (.dmark+1)  
ab4a 32 72 ee			ld (debug_mark+1),a  
ab4d 3a 57 ab			ld a, (.dmark+2)  
ab50 32 73 ee			ld (debug_mark+2),a  
ab53 18 03			jr .pastdmark  
ab55 ..			.dmark: db "SCR"  
ab58 f1			.pastdmark: pop af  
ab59			endm  
# End of macro DMARK
ab59						CALLMONITOR 
ab59 cd dd 94			call break_point_state  
ab5c				endm  
# End of macro CALLMONITOR
ab5c					endif 
ab5c			 
ab5c					FORTH_DSP_VALUEHL 
ab5c cd 4a 9d			call macro_dsp_valuehl 
ab5f				endm 
# End of macro FORTH_DSP_VALUEHL
ab5f				 
ab5f					FORTH_DSP_POP 
ab5f cd 02 9e			call macro_forth_dsp_pop 
ab62				endm 
# End of macro FORTH_DSP_POP
ab62			 
ab62 7d					ld a, l 
ab63 21 ec e7				ld hl, os_var_array 
ab66 cd dc 8c				call addatohl 
ab69			 
ab69 cd 53 9b				call forth_push_numhl 
ab6c			 
ab6c				       NEXTW 
ab6c c3 00 9f			jp macro_next 
ab6f				endm 
# End of macro NEXTW
ab6f			 
ab6f			.INC: 
ab6f				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab6f 6f				db WORD_SYS_CORE+91             
ab70 c3 ab			dw .DEC            
ab72 03				db 2 + 1 
ab73 .. 00			db "+!",0              
ab76				endm 
# End of macro CWHEAD
ab76			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab76					if DEBUG_FORTH_WORDS_KEY 
ab76						DMARK "+s_" 
ab76 f5				push af  
ab77 3a 8b ab			ld a, (.dmark)  
ab7a 32 71 ee			ld (debug_mark),a  
ab7d 3a 8c ab			ld a, (.dmark+1)  
ab80 32 72 ee			ld (debug_mark+1),a  
ab83 3a 8d ab			ld a, (.dmark+2)  
ab86 32 73 ee			ld (debug_mark+2),a  
ab89 18 03			jr .pastdmark  
ab8b ..			.dmark: db "+s_"  
ab8e f1			.pastdmark: pop af  
ab8f			endm  
# End of macro DMARK
ab8f						CALLMONITOR 
ab8f cd dd 94			call break_point_state  
ab92				endm  
# End of macro CALLMONITOR
ab92					endif 
ab92			 
ab92					FORTH_DSP_VALUEHL 
ab92 cd 4a 9d			call macro_dsp_valuehl 
ab95				endm 
# End of macro FORTH_DSP_VALUEHL
ab95			 
ab95 e5					push hl   ; save address 
ab96			 
ab96					FORTH_DSP_POP 
ab96 cd 02 9e			call macro_forth_dsp_pop 
ab99				endm 
# End of macro FORTH_DSP_POP
ab99			 
ab99					FORTH_DSP_VALUEHL 
ab99 cd 4a 9d			call macro_dsp_valuehl 
ab9c				endm 
# End of macro FORTH_DSP_VALUEHL
ab9c			 
ab9c					FORTH_DSP_POP 
ab9c cd 02 9e			call macro_forth_dsp_pop 
ab9f				endm 
# End of macro FORTH_DSP_POP
ab9f			 
ab9f					; hl contains value to add to byte at a 
ab9f				 
ab9f eb					ex de, hl 
aba0			 
aba0 e1					pop hl 
aba1			 
aba1					if DEBUG_FORTH_WORDS 
aba1						DMARK "INC" 
aba1 f5				push af  
aba2 3a b6 ab			ld a, (.dmark)  
aba5 32 71 ee			ld (debug_mark),a  
aba8 3a b7 ab			ld a, (.dmark+1)  
abab 32 72 ee			ld (debug_mark+1),a  
abae 3a b8 ab			ld a, (.dmark+2)  
abb1 32 73 ee			ld (debug_mark+2),a  
abb4 18 03			jr .pastdmark  
abb6 ..			.dmark: db "INC"  
abb9 f1			.pastdmark: pop af  
abba			endm  
# End of macro DMARK
abba						CALLMONITOR 
abba cd dd 94			call break_point_state  
abbd				endm  
# End of macro CALLMONITOR
abbd					endif 
abbd			 
abbd 7e					ld a,(hl) 
abbe 83					add e 
abbf 77					ld (hl),a 
abc0			 
abc0			 
abc0			 
abc0				       NEXTW 
abc0 c3 00 9f			jp macro_next 
abc3				endm 
# End of macro NEXTW
abc3			 
abc3			.DEC: 
abc3				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abc3 6f				db WORD_SYS_CORE+91             
abc4 14 ac			dw .INC2            
abc6 03				db 2 + 1 
abc7 .. 00			db "-!",0              
abca				endm 
# End of macro CWHEAD
abca			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abca					if DEBUG_FORTH_WORDS_KEY 
abca						DMARK "-s_" 
abca f5				push af  
abcb 3a df ab			ld a, (.dmark)  
abce 32 71 ee			ld (debug_mark),a  
abd1 3a e0 ab			ld a, (.dmark+1)  
abd4 32 72 ee			ld (debug_mark+1),a  
abd7 3a e1 ab			ld a, (.dmark+2)  
abda 32 73 ee			ld (debug_mark+2),a  
abdd 18 03			jr .pastdmark  
abdf ..			.dmark: db "-s_"  
abe2 f1			.pastdmark: pop af  
abe3			endm  
# End of macro DMARK
abe3						CALLMONITOR 
abe3 cd dd 94			call break_point_state  
abe6				endm  
# End of macro CALLMONITOR
abe6					endif 
abe6			 
abe6					FORTH_DSP_VALUEHL 
abe6 cd 4a 9d			call macro_dsp_valuehl 
abe9				endm 
# End of macro FORTH_DSP_VALUEHL
abe9			 
abe9 e5					push hl   ; save address 
abea			 
abea					FORTH_DSP_POP 
abea cd 02 9e			call macro_forth_dsp_pop 
abed				endm 
# End of macro FORTH_DSP_POP
abed			 
abed					FORTH_DSP_VALUEHL 
abed cd 4a 9d			call macro_dsp_valuehl 
abf0				endm 
# End of macro FORTH_DSP_VALUEHL
abf0			 
abf0					; hl contains value to add to byte at a 
abf0				 
abf0 eb					ex de, hl 
abf1			 
abf1 e1					pop hl 
abf2			 
abf2					if DEBUG_FORTH_WORDS 
abf2						DMARK "DEC" 
abf2 f5				push af  
abf3 3a 07 ac			ld a, (.dmark)  
abf6 32 71 ee			ld (debug_mark),a  
abf9 3a 08 ac			ld a, (.dmark+1)  
abfc 32 72 ee			ld (debug_mark+1),a  
abff 3a 09 ac			ld a, (.dmark+2)  
ac02 32 73 ee			ld (debug_mark+2),a  
ac05 18 03			jr .pastdmark  
ac07 ..			.dmark: db "DEC"  
ac0a f1			.pastdmark: pop af  
ac0b			endm  
# End of macro DMARK
ac0b						CALLMONITOR 
ac0b cd dd 94			call break_point_state  
ac0e				endm  
# End of macro CALLMONITOR
ac0e					endif 
ac0e			 
ac0e 7e					ld a,(hl) 
ac0f 93					sub e 
ac10 77					ld (hl),a 
ac11			 
ac11			 
ac11			 
ac11				       NEXTW 
ac11 c3 00 9f			jp macro_next 
ac14				endm 
# End of macro NEXTW
ac14			 
ac14			.INC2: 
ac14				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac14 6f				db WORD_SYS_CORE+91             
ac15 be ac			dw .DEC2            
ac17 04				db 3 + 1 
ac18 .. 00			db "+2!",0              
ac1c				endm 
# End of macro CWHEAD
ac1c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac1c			 
ac1c					if DEBUG_FORTH_WORDS_KEY 
ac1c						DMARK "+2s" 
ac1c f5				push af  
ac1d 3a 31 ac			ld a, (.dmark)  
ac20 32 71 ee			ld (debug_mark),a  
ac23 3a 32 ac			ld a, (.dmark+1)  
ac26 32 72 ee			ld (debug_mark+1),a  
ac29 3a 33 ac			ld a, (.dmark+2)  
ac2c 32 73 ee			ld (debug_mark+2),a  
ac2f 18 03			jr .pastdmark  
ac31 ..			.dmark: db "+2s"  
ac34 f1			.pastdmark: pop af  
ac35			endm  
# End of macro DMARK
ac35						CALLMONITOR 
ac35 cd dd 94			call break_point_state  
ac38				endm  
# End of macro CALLMONITOR
ac38					endif 
ac38			 
ac38					; Address 
ac38			 
ac38					FORTH_DSP_VALUEHL 
ac38 cd 4a 9d			call macro_dsp_valuehl 
ac3b				endm 
# End of macro FORTH_DSP_VALUEHL
ac3b			 
ac3b e5					push hl    ; save address 
ac3c			 
ac3c					; load content into de 
ac3c			 
ac3c 5e					ld e,(hl) 
ac3d 23					inc hl 
ac3e 56					ld d, (hl) 
ac3f			 
ac3f					if DEBUG_FORTH_WORDS 
ac3f						DMARK "+2a" 
ac3f f5				push af  
ac40 3a 54 ac			ld a, (.dmark)  
ac43 32 71 ee			ld (debug_mark),a  
ac46 3a 55 ac			ld a, (.dmark+1)  
ac49 32 72 ee			ld (debug_mark+1),a  
ac4c 3a 56 ac			ld a, (.dmark+2)  
ac4f 32 73 ee			ld (debug_mark+2),a  
ac52 18 03			jr .pastdmark  
ac54 ..			.dmark: db "+2a"  
ac57 f1			.pastdmark: pop af  
ac58			endm  
# End of macro DMARK
ac58						CALLMONITOR 
ac58 cd dd 94			call break_point_state  
ac5b				endm  
# End of macro CALLMONITOR
ac5b					endif 
ac5b			 
ac5b					FORTH_DSP_POP 
ac5b cd 02 9e			call macro_forth_dsp_pop 
ac5e				endm 
# End of macro FORTH_DSP_POP
ac5e			 
ac5e					; Get value to add 
ac5e			 
ac5e					FORTH_DSP_VALUE 
ac5e cd 33 9d			call macro_forth_dsp_value 
ac61				endm 
# End of macro FORTH_DSP_VALUE
ac61			 
ac61					if DEBUG_FORTH_WORDS 
ac61						DMARK "+2v" 
ac61 f5				push af  
ac62 3a 76 ac			ld a, (.dmark)  
ac65 32 71 ee			ld (debug_mark),a  
ac68 3a 77 ac			ld a, (.dmark+1)  
ac6b 32 72 ee			ld (debug_mark+1),a  
ac6e 3a 78 ac			ld a, (.dmark+2)  
ac71 32 73 ee			ld (debug_mark+2),a  
ac74 18 03			jr .pastdmark  
ac76 ..			.dmark: db "+2v"  
ac79 f1			.pastdmark: pop af  
ac7a			endm  
# End of macro DMARK
ac7a						CALLMONITOR 
ac7a cd dd 94			call break_point_state  
ac7d				endm  
# End of macro CALLMONITOR
ac7d					endif 
ac7d			 
ac7d 19					add hl, de 
ac7e			 
ac7e					if DEBUG_FORTH_WORDS 
ac7e						DMARK "+2+" 
ac7e f5				push af  
ac7f 3a 93 ac			ld a, (.dmark)  
ac82 32 71 ee			ld (debug_mark),a  
ac85 3a 94 ac			ld a, (.dmark+1)  
ac88 32 72 ee			ld (debug_mark+1),a  
ac8b 3a 95 ac			ld a, (.dmark+2)  
ac8e 32 73 ee			ld (debug_mark+2),a  
ac91 18 03			jr .pastdmark  
ac93 ..			.dmark: db "+2+"  
ac96 f1			.pastdmark: pop af  
ac97			endm  
# End of macro DMARK
ac97						CALLMONITOR 
ac97 cd dd 94			call break_point_state  
ac9a				endm  
# End of macro CALLMONITOR
ac9a					endif 
ac9a			 
ac9a					; move result to de 
ac9a			 
ac9a eb					ex de, hl 
ac9b			 
ac9b					; Address 
ac9b			 
ac9b e1					pop hl 
ac9c			 
ac9c					; save it back 
ac9c			 
ac9c 73					ld (hl), e 
ac9d 23					inc hl 
ac9e 72					ld (hl), d 
ac9f			 
ac9f					if DEBUG_FORTH_WORDS 
ac9f						DMARK "+2e" 
ac9f f5				push af  
aca0 3a b4 ac			ld a, (.dmark)  
aca3 32 71 ee			ld (debug_mark),a  
aca6 3a b5 ac			ld a, (.dmark+1)  
aca9 32 72 ee			ld (debug_mark+1),a  
acac 3a b6 ac			ld a, (.dmark+2)  
acaf 32 73 ee			ld (debug_mark+2),a  
acb2 18 03			jr .pastdmark  
acb4 ..			.dmark: db "+2e"  
acb7 f1			.pastdmark: pop af  
acb8			endm  
# End of macro DMARK
acb8						CALLMONITOR 
acb8 cd dd 94			call break_point_state  
acbb				endm  
# End of macro CALLMONITOR
acbb					endif 
acbb			 
acbb			 
acbb			 
acbb			 
acbb			 
acbb				       NEXTW 
acbb c3 00 9f			jp macro_next 
acbe				endm 
# End of macro NEXTW
acbe			 
acbe			.DEC2: 
acbe				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
acbe 6f				db WORD_SYS_CORE+91             
acbf 6a ad			dw .GET2            
acc1 04				db 3 + 1 
acc2 .. 00			db "-2!",0              
acc6				endm 
# End of macro CWHEAD
acc6			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acc6			 
acc6			 
acc6					if DEBUG_FORTH_WORDS_KEY 
acc6						DMARK "-2s" 
acc6 f5				push af  
acc7 3a db ac			ld a, (.dmark)  
acca 32 71 ee			ld (debug_mark),a  
accd 3a dc ac			ld a, (.dmark+1)  
acd0 32 72 ee			ld (debug_mark+1),a  
acd3 3a dd ac			ld a, (.dmark+2)  
acd6 32 73 ee			ld (debug_mark+2),a  
acd9 18 03			jr .pastdmark  
acdb ..			.dmark: db "-2s"  
acde f1			.pastdmark: pop af  
acdf			endm  
# End of macro DMARK
acdf						CALLMONITOR 
acdf cd dd 94			call break_point_state  
ace2				endm  
# End of macro CALLMONITOR
ace2					endif 
ace2			 
ace2					; Address 
ace2			 
ace2					FORTH_DSP_VALUEHL 
ace2 cd 4a 9d			call macro_dsp_valuehl 
ace5				endm 
# End of macro FORTH_DSP_VALUEHL
ace5			 
ace5 e5					push hl    ; save address 
ace6			 
ace6					; load content into de 
ace6			 
ace6 5e					ld e,(hl) 
ace7 23					inc hl 
ace8 56					ld d, (hl) 
ace9			 
ace9					if DEBUG_FORTH_WORDS 
ace9						DMARK "-2a" 
ace9 f5				push af  
acea 3a fe ac			ld a, (.dmark)  
aced 32 71 ee			ld (debug_mark),a  
acf0 3a ff ac			ld a, (.dmark+1)  
acf3 32 72 ee			ld (debug_mark+1),a  
acf6 3a 00 ad			ld a, (.dmark+2)  
acf9 32 73 ee			ld (debug_mark+2),a  
acfc 18 03			jr .pastdmark  
acfe ..			.dmark: db "-2a"  
ad01 f1			.pastdmark: pop af  
ad02			endm  
# End of macro DMARK
ad02						CALLMONITOR 
ad02 cd dd 94			call break_point_state  
ad05				endm  
# End of macro CALLMONITOR
ad05					endif 
ad05			 
ad05					FORTH_DSP_POP 
ad05 cd 02 9e			call macro_forth_dsp_pop 
ad08				endm 
# End of macro FORTH_DSP_POP
ad08			 
ad08					; Get value to remove 
ad08			 
ad08					FORTH_DSP_VALUE 
ad08 cd 33 9d			call macro_forth_dsp_value 
ad0b				endm 
# End of macro FORTH_DSP_VALUE
ad0b			 
ad0b					if DEBUG_FORTH_WORDS 
ad0b						DMARK "-2v" 
ad0b f5				push af  
ad0c 3a 20 ad			ld a, (.dmark)  
ad0f 32 71 ee			ld (debug_mark),a  
ad12 3a 21 ad			ld a, (.dmark+1)  
ad15 32 72 ee			ld (debug_mark+1),a  
ad18 3a 22 ad			ld a, (.dmark+2)  
ad1b 32 73 ee			ld (debug_mark+2),a  
ad1e 18 03			jr .pastdmark  
ad20 ..			.dmark: db "-2v"  
ad23 f1			.pastdmark: pop af  
ad24			endm  
# End of macro DMARK
ad24						CALLMONITOR 
ad24 cd dd 94			call break_point_state  
ad27				endm  
# End of macro CALLMONITOR
ad27					endif 
ad27			 
ad27 eb					ex de, hl 
ad28 ed 52				sbc hl, de 
ad2a			 
ad2a					if DEBUG_FORTH_WORDS 
ad2a						DMARK "-2d" 
ad2a f5				push af  
ad2b 3a 3f ad			ld a, (.dmark)  
ad2e 32 71 ee			ld (debug_mark),a  
ad31 3a 40 ad			ld a, (.dmark+1)  
ad34 32 72 ee			ld (debug_mark+1),a  
ad37 3a 41 ad			ld a, (.dmark+2)  
ad3a 32 73 ee			ld (debug_mark+2),a  
ad3d 18 03			jr .pastdmark  
ad3f ..			.dmark: db "-2d"  
ad42 f1			.pastdmark: pop af  
ad43			endm  
# End of macro DMARK
ad43						CALLMONITOR 
ad43 cd dd 94			call break_point_state  
ad46				endm  
# End of macro CALLMONITOR
ad46					endif 
ad46			 
ad46					; move result to de 
ad46			 
ad46 eb					ex de, hl 
ad47			 
ad47					; Address 
ad47			 
ad47 e1					pop hl 
ad48			 
ad48					; save it back 
ad48			 
ad48 73					ld (hl), e 
ad49 23					inc hl 
ad4a 72					ld (hl), d 
ad4b			 
ad4b					if DEBUG_FORTH_WORDS 
ad4b						DMARK "-2e" 
ad4b f5				push af  
ad4c 3a 60 ad			ld a, (.dmark)  
ad4f 32 71 ee			ld (debug_mark),a  
ad52 3a 61 ad			ld a, (.dmark+1)  
ad55 32 72 ee			ld (debug_mark+1),a  
ad58 3a 62 ad			ld a, (.dmark+2)  
ad5b 32 73 ee			ld (debug_mark+2),a  
ad5e 18 03			jr .pastdmark  
ad60 ..			.dmark: db "-2e"  
ad63 f1			.pastdmark: pop af  
ad64			endm  
# End of macro DMARK
ad64						CALLMONITOR 
ad64 cd dd 94			call break_point_state  
ad67				endm  
# End of macro CALLMONITOR
ad67					endif 
ad67			 
ad67			 
ad67			 
ad67			 
ad67			 
ad67				       NEXTW 
ad67 c3 00 9f			jp macro_next 
ad6a				endm 
# End of macro NEXTW
ad6a			.GET2: 
ad6a				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad6a 6f				db WORD_SYS_CORE+91             
ad6b 9a ad			dw .BANG2            
ad6d 03				db 2 + 1 
ad6e .. 00			db "2@",0              
ad71				endm 
# End of macro CWHEAD
ad71			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad71					if DEBUG_FORTH_WORDS_KEY 
ad71						DMARK "2A_" 
ad71 f5				push af  
ad72 3a 86 ad			ld a, (.dmark)  
ad75 32 71 ee			ld (debug_mark),a  
ad78 3a 87 ad			ld a, (.dmark+1)  
ad7b 32 72 ee			ld (debug_mark+1),a  
ad7e 3a 88 ad			ld a, (.dmark+2)  
ad81 32 73 ee			ld (debug_mark+2),a  
ad84 18 03			jr .pastdmark  
ad86 ..			.dmark: db "2A_"  
ad89 f1			.pastdmark: pop af  
ad8a			endm  
# End of macro DMARK
ad8a						CALLMONITOR 
ad8a cd dd 94			call break_point_state  
ad8d				endm  
# End of macro CALLMONITOR
ad8d					endif 
ad8d			 
ad8d					FORTH_DSP_VALUEHL 
ad8d cd 4a 9d			call macro_dsp_valuehl 
ad90				endm 
# End of macro FORTH_DSP_VALUEHL
ad90			 
ad90 5e					ld e, (hl) 
ad91 23					inc hl 
ad92 56					ld d, (hl) 
ad93			 
ad93 eb					ex de, hl 
ad94			 
ad94 cd 53 9b				call forth_push_numhl 
ad97			 
ad97				       NEXTW 
ad97 c3 00 9f			jp macro_next 
ad9a				endm 
# End of macro NEXTW
ad9a			.BANG2: 
ad9a				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad9a 6f				db WORD_SYS_CORE+91             
ad9b d2 ad			dw .CONFIG            
ad9d 03				db 2 + 1 
ad9e .. 00			db "2!",0              
ada1				endm 
# End of macro CWHEAD
ada1			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ada1					if DEBUG_FORTH_WORDS_KEY 
ada1						DMARK "2S_" 
ada1 f5				push af  
ada2 3a b6 ad			ld a, (.dmark)  
ada5 32 71 ee			ld (debug_mark),a  
ada8 3a b7 ad			ld a, (.dmark+1)  
adab 32 72 ee			ld (debug_mark+1),a  
adae 3a b8 ad			ld a, (.dmark+2)  
adb1 32 73 ee			ld (debug_mark+2),a  
adb4 18 03			jr .pastdmark  
adb6 ..			.dmark: db "2S_"  
adb9 f1			.pastdmark: pop af  
adba			endm  
# End of macro DMARK
adba						CALLMONITOR 
adba cd dd 94			call break_point_state  
adbd				endm  
# End of macro CALLMONITOR
adbd					endif 
adbd			 
adbd					FORTH_DSP_VALUEHL 
adbd cd 4a 9d			call macro_dsp_valuehl 
adc0				endm 
# End of macro FORTH_DSP_VALUEHL
adc0			 
adc0 e5					push hl   ; save address 
adc1			 
adc1			 
adc1					FORTH_DSP_POP 
adc1 cd 02 9e			call macro_forth_dsp_pop 
adc4				endm 
# End of macro FORTH_DSP_POP
adc4			 
adc4					 
adc4					FORTH_DSP_VALUEHL 
adc4 cd 4a 9d			call macro_dsp_valuehl 
adc7				endm 
# End of macro FORTH_DSP_VALUEHL
adc7			 
adc7					FORTH_DSP_POP 
adc7 cd 02 9e			call macro_forth_dsp_pop 
adca				endm 
# End of macro FORTH_DSP_POP
adca			 
adca eb					ex de, hl    ; value now in de 
adcb			 
adcb e1					pop hl 
adcc			 
adcc 73					ld (hl), e 
adcd			 
adcd 23					inc hl 
adce			 
adce 72					ld (hl), d 
adcf			 
adcf			 
adcf				       NEXTW 
adcf c3 00 9f			jp macro_next 
add2				endm 
# End of macro NEXTW
add2			.CONFIG: 
add2				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
add2 6f				db WORD_SYS_CORE+91             
add3 e3 ad			dw .ENDCORE            
add5 07				db 6 + 1 
add6 .. 00			db "CONFIG",0              
addd				endm 
# End of macro CWHEAD
addd			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
addd			 
addd cd 3c 93				call config 
ade0					NEXTW 
ade0 c3 00 9f			jp macro_next 
ade3				endm 
# End of macro NEXTW
ade3			.ENDCORE: 
ade3			 
ade3			; eof 
ade3			 
ade3			 
# End of file forth_words_core.asm
ade3			include "forth_words_flow.asm" 
ade3			 
ade3			; | ## Program Flow Words 
ade3			 
ade3			.IF: 
ade3				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ade3 1e				db WORD_SYS_CORE+10             
ade4 d8 ae			dw .THEN            
ade6 03				db 2 + 1 
ade7 .. 00			db "IF",0              
adea				endm 
# End of macro CWHEAD
adea			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
adea			; 
adea					if DEBUG_FORTH_WORDS_KEY 
adea						DMARK "IF." 
adea f5				push af  
adeb 3a ff ad			ld a, (.dmark)  
adee 32 71 ee			ld (debug_mark),a  
adf1 3a 00 ae			ld a, (.dmark+1)  
adf4 32 72 ee			ld (debug_mark+1),a  
adf7 3a 01 ae			ld a, (.dmark+2)  
adfa 32 73 ee			ld (debug_mark+2),a  
adfd 18 03			jr .pastdmark  
adff ..			.dmark: db "IF."  
ae02 f1			.pastdmark: pop af  
ae03			endm  
# End of macro DMARK
ae03						CALLMONITOR 
ae03 cd dd 94			call break_point_state  
ae06				endm  
# End of macro CALLMONITOR
ae06					endif 
ae06			; eval TOS 
ae06			 
ae06				FORTH_DSP_VALUEHL 
ae06 cd 4a 9d			call macro_dsp_valuehl 
ae09				endm 
# End of macro FORTH_DSP_VALUEHL
ae09			 
ae09			;	push hl 
ae09				FORTH_DSP_POP 
ae09 cd 02 9e			call macro_forth_dsp_pop 
ae0c				endm 
# End of macro FORTH_DSP_POP
ae0c			;	pop hl 
ae0c			 
ae0c					if DEBUG_FORTH_WORDS 
ae0c						DMARK "IF1" 
ae0c f5				push af  
ae0d 3a 21 ae			ld a, (.dmark)  
ae10 32 71 ee			ld (debug_mark),a  
ae13 3a 22 ae			ld a, (.dmark+1)  
ae16 32 72 ee			ld (debug_mark+1),a  
ae19 3a 23 ae			ld a, (.dmark+2)  
ae1c 32 73 ee			ld (debug_mark+2),a  
ae1f 18 03			jr .pastdmark  
ae21 ..			.dmark: db "IF1"  
ae24 f1			.pastdmark: pop af  
ae25			endm  
# End of macro DMARK
ae25						CALLMONITOR 
ae25 cd dd 94			call break_point_state  
ae28				endm  
# End of macro CALLMONITOR
ae28					endif 
ae28 b7				or a        ; clear carry flag 
ae29 11 00 00			ld de, 0 
ae2c eb				ex de,hl 
ae2d ed 52			sbc hl, de 
ae2f c2 b9 ae			jp nz, .iftrue 
ae32			 
ae32					if DEBUG_FORTH_WORDS 
ae32						DMARK "IF2" 
ae32 f5				push af  
ae33 3a 47 ae			ld a, (.dmark)  
ae36 32 71 ee			ld (debug_mark),a  
ae39 3a 48 ae			ld a, (.dmark+1)  
ae3c 32 72 ee			ld (debug_mark+1),a  
ae3f 3a 49 ae			ld a, (.dmark+2)  
ae42 32 73 ee			ld (debug_mark+2),a  
ae45 18 03			jr .pastdmark  
ae47 ..			.dmark: db "IF2"  
ae4a f1			.pastdmark: pop af  
ae4b			endm  
# End of macro DMARK
ae4b						CALLMONITOR 
ae4b cd dd 94			call break_point_state  
ae4e				endm  
# End of macro CALLMONITOR
ae4e					endif 
ae4e			 
ae4e			; if not true then skip to THEN 
ae4e			 
ae4e				; TODO get tok_ptr 
ae4e				; TODO consume toks until we get to THEN 
ae4e			 
ae4e 2a c8 e5			ld hl, (os_tok_ptr) 
ae51					if DEBUG_FORTH_WORDS 
ae51						DMARK "IF3" 
ae51 f5				push af  
ae52 3a 66 ae			ld a, (.dmark)  
ae55 32 71 ee			ld (debug_mark),a  
ae58 3a 67 ae			ld a, (.dmark+1)  
ae5b 32 72 ee			ld (debug_mark+1),a  
ae5e 3a 68 ae			ld a, (.dmark+2)  
ae61 32 73 ee			ld (debug_mark+2),a  
ae64 18 03			jr .pastdmark  
ae66 ..			.dmark: db "IF3"  
ae69 f1			.pastdmark: pop af  
ae6a			endm  
# End of macro DMARK
ae6a						CALLMONITOR 
ae6a cd dd 94			call break_point_state  
ae6d				endm  
# End of macro CALLMONITOR
ae6d						 
ae6d					endif 
ae6d 11 b4 ae			ld de, .ifthen 
ae70					if DEBUG_FORTH_WORDS 
ae70						DMARK "IF4" 
ae70 f5				push af  
ae71 3a 85 ae			ld a, (.dmark)  
ae74 32 71 ee			ld (debug_mark),a  
ae77 3a 86 ae			ld a, (.dmark+1)  
ae7a 32 72 ee			ld (debug_mark+1),a  
ae7d 3a 87 ae			ld a, (.dmark+2)  
ae80 32 73 ee			ld (debug_mark+2),a  
ae83 18 03			jr .pastdmark  
ae85 ..			.dmark: db "IF4"  
ae88 f1			.pastdmark: pop af  
ae89			endm  
# End of macro DMARK
ae89						CALLMONITOR 
ae89 cd dd 94			call break_point_state  
ae8c				endm  
# End of macro CALLMONITOR
ae8c					endif 
ae8c cd 1b a0			call findnexttok  
ae8f			 
ae8f					if DEBUG_FORTH_WORDS 
ae8f						DMARK "IF5" 
ae8f f5				push af  
ae90 3a a4 ae			ld a, (.dmark)  
ae93 32 71 ee			ld (debug_mark),a  
ae96 3a a5 ae			ld a, (.dmark+1)  
ae99 32 72 ee			ld (debug_mark+1),a  
ae9c 3a a6 ae			ld a, (.dmark+2)  
ae9f 32 73 ee			ld (debug_mark+2),a  
aea2 18 03			jr .pastdmark  
aea4 ..			.dmark: db "IF5"  
aea7 f1			.pastdmark: pop af  
aea8			endm  
# End of macro DMARK
aea8						CALLMONITOR 
aea8 cd dd 94			call break_point_state  
aeab				endm  
# End of macro CALLMONITOR
aeab					endif 
aeab				; TODO replace below with ; exec using tok_ptr 
aeab 22 c8 e5			ld (os_tok_ptr), hl 
aeae c3 91 9f			jp exec1 
aeb1				NEXTW 
aeb1 c3 00 9f			jp macro_next 
aeb4				endm 
# End of macro NEXTW
aeb4			 
aeb4 .. 00		.ifthen:  db "THEN",0 
aeb9			 
aeb9			.iftrue:		 
aeb9				; Exec next words normally 
aeb9			 
aeb9				; if true then exec following IF as normal 
aeb9					if DEBUG_FORTH_WORDS 
aeb9						DMARK "IFT" 
aeb9 f5				push af  
aeba 3a ce ae			ld a, (.dmark)  
aebd 32 71 ee			ld (debug_mark),a  
aec0 3a cf ae			ld a, (.dmark+1)  
aec3 32 72 ee			ld (debug_mark+1),a  
aec6 3a d0 ae			ld a, (.dmark+2)  
aec9 32 73 ee			ld (debug_mark+2),a  
aecc 18 03			jr .pastdmark  
aece ..			.dmark: db "IFT"  
aed1 f1			.pastdmark: pop af  
aed2			endm  
# End of macro DMARK
aed2						CALLMONITOR 
aed2 cd dd 94			call break_point_state  
aed5				endm  
# End of macro CALLMONITOR
aed5					endif 
aed5			 
aed5					NEXTW 
aed5 c3 00 9f			jp macro_next 
aed8				endm 
# End of macro NEXTW
aed8			.THEN: 
aed8				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
aed8 1f				db WORD_SYS_CORE+11             
aed9 00 af			dw .ELSE            
aedb 05				db 4 + 1 
aedc .. 00			db "THEN",0              
aee1				endm 
# End of macro CWHEAD
aee1			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
aee1					if DEBUG_FORTH_WORDS_KEY 
aee1						DMARK "THN" 
aee1 f5				push af  
aee2 3a f6 ae			ld a, (.dmark)  
aee5 32 71 ee			ld (debug_mark),a  
aee8 3a f7 ae			ld a, (.dmark+1)  
aeeb 32 72 ee			ld (debug_mark+1),a  
aeee 3a f8 ae			ld a, (.dmark+2)  
aef1 32 73 ee			ld (debug_mark+2),a  
aef4 18 03			jr .pastdmark  
aef6 ..			.dmark: db "THN"  
aef9 f1			.pastdmark: pop af  
aefa			endm  
# End of macro DMARK
aefa						CALLMONITOR 
aefa cd dd 94			call break_point_state  
aefd				endm  
# End of macro CALLMONITOR
aefd					endif 
aefd					NEXTW 
aefd c3 00 9f			jp macro_next 
af00				endm 
# End of macro NEXTW
af00			.ELSE: 
af00				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af00 20				db WORD_SYS_CORE+12             
af01 28 af			dw .DO            
af03 03				db 2 + 1 
af04 .. 00			db "ELSE",0              
af09				endm 
# End of macro CWHEAD
af09			; | ELSE ( -- ) Not supported - does nothing | TODO 
af09			 
af09					if DEBUG_FORTH_WORDS_KEY 
af09						DMARK "ELS" 
af09 f5				push af  
af0a 3a 1e af			ld a, (.dmark)  
af0d 32 71 ee			ld (debug_mark),a  
af10 3a 1f af			ld a, (.dmark+1)  
af13 32 72 ee			ld (debug_mark+1),a  
af16 3a 20 af			ld a, (.dmark+2)  
af19 32 73 ee			ld (debug_mark+2),a  
af1c 18 03			jr .pastdmark  
af1e ..			.dmark: db "ELS"  
af21 f1			.pastdmark: pop af  
af22			endm  
# End of macro DMARK
af22						CALLMONITOR 
af22 cd dd 94			call break_point_state  
af25				endm  
# End of macro CALLMONITOR
af25					endif 
af25			 
af25			 
af25					NEXTW 
af25 c3 00 9f			jp macro_next 
af28				endm 
# End of macro NEXTW
af28			.DO: 
af28				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af28 21				db WORD_SYS_CORE+13             
af29 4f b0			dw .LOOP            
af2b 03				db 2 + 1 
af2c .. 00			db "DO",0              
af2f				endm 
# End of macro CWHEAD
af2f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af2f			 
af2f					if DEBUG_FORTH_WORDS_KEY 
af2f						DMARK "DO." 
af2f f5				push af  
af30 3a 44 af			ld a, (.dmark)  
af33 32 71 ee			ld (debug_mark),a  
af36 3a 45 af			ld a, (.dmark+1)  
af39 32 72 ee			ld (debug_mark+1),a  
af3c 3a 46 af			ld a, (.dmark+2)  
af3f 32 73 ee			ld (debug_mark+2),a  
af42 18 03			jr .pastdmark  
af44 ..			.dmark: db "DO."  
af47 f1			.pastdmark: pop af  
af48			endm  
# End of macro DMARK
af48						CALLMONITOR 
af48 cd dd 94			call break_point_state  
af4b				endm  
# End of macro CALLMONITOR
af4b					endif 
af4b			;  push pc to rsp stack past the DO 
af4b			 
af4b 2a c8 e5				ld hl, (os_tok_ptr) 
af4e 23					inc hl   ; D 
af4f 23					inc hl  ; O 
af50 23					inc hl   ; null 
af51					if DEBUG_FORTH_WORDS 
af51						DMARK "DO2" 
af51 f5				push af  
af52 3a 66 af			ld a, (.dmark)  
af55 32 71 ee			ld (debug_mark),a  
af58 3a 67 af			ld a, (.dmark+1)  
af5b 32 72 ee			ld (debug_mark+1),a  
af5e 3a 68 af			ld a, (.dmark+2)  
af61 32 73 ee			ld (debug_mark+2),a  
af64 18 03			jr .pastdmark  
af66 ..			.dmark: db "DO2"  
af69 f1			.pastdmark: pop af  
af6a			endm  
# End of macro DMARK
af6a						CALLMONITOR 
af6a cd dd 94			call break_point_state  
af6d				endm  
# End of macro CALLMONITOR
af6d					endif 
af6d					FORTH_RSP_NEXT 
af6d cd fa 9a			call macro_forth_rsp_next 
af70				endm 
# End of macro FORTH_RSP_NEXT
af70					if DEBUG_FORTH_WORDS 
af70						DMARK "DO3" 
af70 f5				push af  
af71 3a 85 af			ld a, (.dmark)  
af74 32 71 ee			ld (debug_mark),a  
af77 3a 86 af			ld a, (.dmark+1)  
af7a 32 72 ee			ld (debug_mark+1),a  
af7d 3a 87 af			ld a, (.dmark+2)  
af80 32 73 ee			ld (debug_mark+2),a  
af83 18 03			jr .pastdmark  
af85 ..			.dmark: db "DO3"  
af88 f1			.pastdmark: pop af  
af89			endm  
# End of macro DMARK
af89						CALLMONITOR 
af89 cd dd 94			call break_point_state  
af8c				endm  
# End of macro CALLMONITOR
af8c					endif 
af8c			 
af8c					;if DEBUG_FORTH_WORDS 
af8c				;		push hl 
af8c			;		endif  
af8c			 
af8c			; get counters from data stack 
af8c			 
af8c			 
af8c					FORTH_DSP_VALUEHL 
af8c cd 4a 9d			call macro_dsp_valuehl 
af8f				endm 
# End of macro FORTH_DSP_VALUEHL
af8f e5					push hl		 ; hl now has starting counter which needs to be tos 
af90			 
af90					if DEBUG_FORTH_WORDS 
af90						DMARK "DO4" 
af90 f5				push af  
af91 3a a5 af			ld a, (.dmark)  
af94 32 71 ee			ld (debug_mark),a  
af97 3a a6 af			ld a, (.dmark+1)  
af9a 32 72 ee			ld (debug_mark+1),a  
af9d 3a a7 af			ld a, (.dmark+2)  
afa0 32 73 ee			ld (debug_mark+2),a  
afa3 18 03			jr .pastdmark  
afa5 ..			.dmark: db "DO4"  
afa8 f1			.pastdmark: pop af  
afa9			endm  
# End of macro DMARK
afa9						CALLMONITOR 
afa9 cd dd 94			call break_point_state  
afac				endm  
# End of macro CALLMONITOR
afac					endif 
afac					FORTH_DSP_POP 
afac cd 02 9e			call macro_forth_dsp_pop 
afaf				endm 
# End of macro FORTH_DSP_POP
afaf			 
afaf					if DEBUG_FORTH_WORDS 
afaf						DMARK "DO5" 
afaf f5				push af  
afb0 3a c4 af			ld a, (.dmark)  
afb3 32 71 ee			ld (debug_mark),a  
afb6 3a c5 af			ld a, (.dmark+1)  
afb9 32 72 ee			ld (debug_mark+1),a  
afbc 3a c6 af			ld a, (.dmark+2)  
afbf 32 73 ee			ld (debug_mark+2),a  
afc2 18 03			jr .pastdmark  
afc4 ..			.dmark: db "DO5"  
afc7 f1			.pastdmark: pop af  
afc8			endm  
# End of macro DMARK
afc8						CALLMONITOR 
afc8 cd dd 94			call break_point_state  
afcb				endm  
# End of macro CALLMONITOR
afcb					endif 
afcb			 
afcb					FORTH_DSP_VALUEHL 
afcb cd 4a 9d			call macro_dsp_valuehl 
afce				endm 
# End of macro FORTH_DSP_VALUEHL
afce			;		push hl		 ; hl now has starting limit counter 
afce			 
afce					if DEBUG_FORTH_WORDS 
afce						DMARK "DO6" 
afce f5				push af  
afcf 3a e3 af			ld a, (.dmark)  
afd2 32 71 ee			ld (debug_mark),a  
afd5 3a e4 af			ld a, (.dmark+1)  
afd8 32 72 ee			ld (debug_mark+1),a  
afdb 3a e5 af			ld a, (.dmark+2)  
afde 32 73 ee			ld (debug_mark+2),a  
afe1 18 03			jr .pastdmark  
afe3 ..			.dmark: db "DO6"  
afe6 f1			.pastdmark: pop af  
afe7			endm  
# End of macro DMARK
afe7						CALLMONITOR 
afe7 cd dd 94			call break_point_state  
afea				endm  
# End of macro CALLMONITOR
afea					endif 
afea					FORTH_DSP_POP 
afea cd 02 9e			call macro_forth_dsp_pop 
afed				endm 
# End of macro FORTH_DSP_POP
afed			 
afed			; put counters on the loop stack 
afed			 
afed			;		pop hl			 ; limit counter 
afed d1					pop de			; start counter 
afee			 
afee					; push limit counter 
afee			 
afee					if DEBUG_FORTH_WORDS 
afee						DMARK "DO7" 
afee f5				push af  
afef 3a 03 b0			ld a, (.dmark)  
aff2 32 71 ee			ld (debug_mark),a  
aff5 3a 04 b0			ld a, (.dmark+1)  
aff8 32 72 ee			ld (debug_mark+1),a  
affb 3a 05 b0			ld a, (.dmark+2)  
affe 32 73 ee			ld (debug_mark+2),a  
b001 18 03			jr .pastdmark  
b003 ..			.dmark: db "DO7"  
b006 f1			.pastdmark: pop af  
b007			endm  
# End of macro DMARK
b007						CALLMONITOR 
b007 cd dd 94			call break_point_state  
b00a				endm  
# End of macro CALLMONITOR
b00a					endif 
b00a					FORTH_LOOP_NEXT 
b00a cd 7b 9d			call macro_forth_loop_next 
b00d				endm 
# End of macro FORTH_LOOP_NEXT
b00d			 
b00d					; push start counter 
b00d			 
b00d eb					ex de, hl 
b00e					if DEBUG_FORTH_WORDS 
b00e						DMARK "DO7" 
b00e f5				push af  
b00f 3a 23 b0			ld a, (.dmark)  
b012 32 71 ee			ld (debug_mark),a  
b015 3a 24 b0			ld a, (.dmark+1)  
b018 32 72 ee			ld (debug_mark+1),a  
b01b 3a 25 b0			ld a, (.dmark+2)  
b01e 32 73 ee			ld (debug_mark+2),a  
b021 18 03			jr .pastdmark  
b023 ..			.dmark: db "DO7"  
b026 f1			.pastdmark: pop af  
b027			endm  
# End of macro DMARK
b027						CALLMONITOR 
b027 cd dd 94			call break_point_state  
b02a				endm  
# End of macro CALLMONITOR
b02a					endif 
b02a					FORTH_LOOP_NEXT 
b02a cd 7b 9d			call macro_forth_loop_next 
b02d				endm 
# End of macro FORTH_LOOP_NEXT
b02d			 
b02d			 
b02d					; init first round of I counter 
b02d			 
b02d 22 ec e5				ld (os_current_i), hl 
b030			 
b030					if DEBUG_FORTH_WORDS 
b030						DMARK "DO8" 
b030 f5				push af  
b031 3a 45 b0			ld a, (.dmark)  
b034 32 71 ee			ld (debug_mark),a  
b037 3a 46 b0			ld a, (.dmark+1)  
b03a 32 72 ee			ld (debug_mark+1),a  
b03d 3a 47 b0			ld a, (.dmark+2)  
b040 32 73 ee			ld (debug_mark+2),a  
b043 18 03			jr .pastdmark  
b045 ..			.dmark: db "DO8"  
b048 f1			.pastdmark: pop af  
b049			endm  
# End of macro DMARK
b049						CALLMONITOR 
b049 cd dd 94			call break_point_state  
b04c				endm  
# End of macro CALLMONITOR
b04c					endif 
b04c			 
b04c					NEXTW 
b04c c3 00 9f			jp macro_next 
b04f				endm 
# End of macro NEXTW
b04f			.LOOP: 
b04f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b04f 22				db WORD_SYS_CORE+14             
b050 67 b1			dw .I            
b052 05				db 4 + 1 
b053 .. 00			db "LOOP",0              
b058				endm 
# End of macro CWHEAD
b058			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b058			 
b058				; pop tos as current loop count to hl 
b058			 
b058				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b058			 
b058				FORTH_LOOP_TOS 
b058 cd ae 9d			call macro_forth_loop_tos 
b05b				endm 
# End of macro FORTH_LOOP_TOS
b05b e5				push hl 
b05c			 
b05c					if DEBUG_FORTH_WORDS_KEY 
b05c						DMARK "LOP" 
b05c f5				push af  
b05d 3a 71 b0			ld a, (.dmark)  
b060 32 71 ee			ld (debug_mark),a  
b063 3a 72 b0			ld a, (.dmark+1)  
b066 32 72 ee			ld (debug_mark+1),a  
b069 3a 73 b0			ld a, (.dmark+2)  
b06c 32 73 ee			ld (debug_mark+2),a  
b06f 18 03			jr .pastdmark  
b071 ..			.dmark: db "LOP"  
b074 f1			.pastdmark: pop af  
b075			endm  
# End of macro DMARK
b075						CALLMONITOR 
b075 cd dd 94			call break_point_state  
b078				endm  
# End of macro CALLMONITOR
b078					endif 
b078				; next item on the stack is the limit. get it 
b078			 
b078			 
b078				FORTH_LOOP_POP 
b078 cd b8 9d			call macro_forth_loop_pop 
b07b				endm 
# End of macro FORTH_LOOP_POP
b07b			 
b07b				FORTH_LOOP_TOS 
b07b cd ae 9d			call macro_forth_loop_tos 
b07e				endm 
# End of macro FORTH_LOOP_TOS
b07e			 
b07e d1				pop de		 ; de = i, hl = limit 
b07f			 
b07f					if DEBUG_FORTH_WORDS 
b07f						DMARK "LP1" 
b07f f5				push af  
b080 3a 94 b0			ld a, (.dmark)  
b083 32 71 ee			ld (debug_mark),a  
b086 3a 95 b0			ld a, (.dmark+1)  
b089 32 72 ee			ld (debug_mark+1),a  
b08c 3a 96 b0			ld a, (.dmark+2)  
b08f 32 73 ee			ld (debug_mark+2),a  
b092 18 03			jr .pastdmark  
b094 ..			.dmark: db "LP1"  
b097 f1			.pastdmark: pop af  
b098			endm  
# End of macro DMARK
b098						CALLMONITOR 
b098 cd dd 94			call break_point_state  
b09b				endm  
# End of macro CALLMONITOR
b09b					endif 
b09b			 
b09b				; go back to previous word 
b09b			 
b09b d5				push de    ; save I for inc later 
b09c			 
b09c			 
b09c				; get limit 
b09c				;  is I at limit? 
b09c			 
b09c			 
b09c					if DEBUG_FORTH_WORDS 
b09c						DMARK "LP1" 
b09c f5				push af  
b09d 3a b1 b0			ld a, (.dmark)  
b0a0 32 71 ee			ld (debug_mark),a  
b0a3 3a b2 b0			ld a, (.dmark+1)  
b0a6 32 72 ee			ld (debug_mark+1),a  
b0a9 3a b3 b0			ld a, (.dmark+2)  
b0ac 32 73 ee			ld (debug_mark+2),a  
b0af 18 03			jr .pastdmark  
b0b1 ..			.dmark: db "LP1"  
b0b4 f1			.pastdmark: pop af  
b0b5			endm  
# End of macro DMARK
b0b5						CALLMONITOR 
b0b5 cd dd 94			call break_point_state  
b0b8				endm  
# End of macro CALLMONITOR
b0b8					endif 
b0b8			 
b0b8 ed 52			sbc hl, de 
b0ba			 
b0ba			 
b0ba				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b0ba			 
b0ba 20 26				jr nz, .loopnotdone 
b0bc			 
b0bc e1				pop hl   ; get rid of saved I 
b0bd				FORTH_LOOP_POP     ; get rid of limit 
b0bd cd b8 9d			call macro_forth_loop_pop 
b0c0				endm 
# End of macro FORTH_LOOP_POP
b0c0			 
b0c0				FORTH_RSP_POP     ; get rid of DO ptr 
b0c0 cd 1b 9b			call macro_forth_rsp_pop 
b0c3				endm 
# End of macro FORTH_RSP_POP
b0c3			 
b0c3			if DEBUG_FORTH_WORDS 
b0c3						DMARK "LP>" 
b0c3 f5				push af  
b0c4 3a d8 b0			ld a, (.dmark)  
b0c7 32 71 ee			ld (debug_mark),a  
b0ca 3a d9 b0			ld a, (.dmark+1)  
b0cd 32 72 ee			ld (debug_mark+1),a  
b0d0 3a da b0			ld a, (.dmark+2)  
b0d3 32 73 ee			ld (debug_mark+2),a  
b0d6 18 03			jr .pastdmark  
b0d8 ..			.dmark: db "LP>"  
b0db f1			.pastdmark: pop af  
b0dc			endm  
# End of macro DMARK
b0dc				CALLMONITOR 
b0dc cd dd 94			call break_point_state  
b0df				endm  
# End of macro CALLMONITOR
b0df			endif 
b0df			 
b0df					NEXTW 
b0df c3 00 9f			jp macro_next 
b0e2				endm 
# End of macro NEXTW
b0e2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b0e2			 
b0e2			.loopnotdone: 
b0e2			 
b0e2 e1				pop hl    ; get I 
b0e3 23				inc hl 
b0e4			 
b0e4			   	; save new I 
b0e4			 
b0e4			 
b0e4					; set I counter 
b0e4			 
b0e4 22 ec e5				ld (os_current_i), hl 
b0e7			 
b0e7					if DEBUG_FORTH_WORDS 
b0e7						DMARK "LPN" 
b0e7 f5				push af  
b0e8 3a fc b0			ld a, (.dmark)  
b0eb 32 71 ee			ld (debug_mark),a  
b0ee 3a fd b0			ld a, (.dmark+1)  
b0f1 32 72 ee			ld (debug_mark+1),a  
b0f4 3a fe b0			ld a, (.dmark+2)  
b0f7 32 73 ee			ld (debug_mark+2),a  
b0fa 18 03			jr .pastdmark  
b0fc ..			.dmark: db "LPN"  
b0ff f1			.pastdmark: pop af  
b100			endm  
# End of macro DMARK
b100					CALLMONITOR 
b100 cd dd 94			call break_point_state  
b103				endm  
# End of macro CALLMONITOR
b103					endif 
b103					 
b103				FORTH_LOOP_NEXT 
b103 cd 7b 9d			call macro_forth_loop_next 
b106				endm 
# End of macro FORTH_LOOP_NEXT
b106			 
b106			 
b106					if DEBUG_FORTH_WORDS 
b106 eb						ex de,hl 
b107					endif 
b107			 
b107			;	; get DO ptr 
b107			; 
b107					if DEBUG_FORTH_WORDS 
b107						DMARK "LP7" 
b107 f5				push af  
b108 3a 1c b1			ld a, (.dmark)  
b10b 32 71 ee			ld (debug_mark),a  
b10e 3a 1d b1			ld a, (.dmark+1)  
b111 32 72 ee			ld (debug_mark+1),a  
b114 3a 1e b1			ld a, (.dmark+2)  
b117 32 73 ee			ld (debug_mark+2),a  
b11a 18 03			jr .pastdmark  
b11c ..			.dmark: db "LP7"  
b11f f1			.pastdmark: pop af  
b120			endm  
# End of macro DMARK
b120					CALLMONITOR 
b120 cd dd 94			call break_point_state  
b123				endm  
# End of macro CALLMONITOR
b123					endif 
b123				FORTH_RSP_TOS 
b123 cd 11 9b			call macro_forth_rsp_tos 
b126				endm 
# End of macro FORTH_RSP_TOS
b126			 
b126					if DEBUG_FORTH_WORDS 
b126						DMARK "LP8" 
b126 f5				push af  
b127 3a 3b b1			ld a, (.dmark)  
b12a 32 71 ee			ld (debug_mark),a  
b12d 3a 3c b1			ld a, (.dmark+1)  
b130 32 72 ee			ld (debug_mark+1),a  
b133 3a 3d b1			ld a, (.dmark+2)  
b136 32 73 ee			ld (debug_mark+2),a  
b139 18 03			jr .pastdmark  
b13b ..			.dmark: db "LP8"  
b13e f1			.pastdmark: pop af  
b13f			endm  
# End of macro DMARK
b13f					CALLMONITOR 
b13f cd dd 94			call break_point_state  
b142				endm  
# End of macro CALLMONITOR
b142					endif 
b142				;push hl 
b142			 
b142				; not going to DO any more 
b142				; get rid of the RSP pointer as DO will add it back in 
b142				;FORTH_RSP_POP 
b142				;pop hl 
b142			 
b142				;ld hl,(cli_ret_sp) 
b142				;ld e, (hl) 
b142				;inc hl 
b142				;ld d, (hl) 
b142				;ex de,hl 
b142 22 c8 e5			ld (os_tok_ptr), hl 
b145					if DEBUG_FORTH_WORDS 
b145						DMARK "LP<" 
b145 f5				push af  
b146 3a 5a b1			ld a, (.dmark)  
b149 32 71 ee			ld (debug_mark),a  
b14c 3a 5b b1			ld a, (.dmark+1)  
b14f 32 72 ee			ld (debug_mark+1),a  
b152 3a 5c b1			ld a, (.dmark+2)  
b155 32 73 ee			ld (debug_mark+2),a  
b158 18 03			jr .pastdmark  
b15a ..			.dmark: db "LP<"  
b15d f1			.pastdmark: pop af  
b15e			endm  
# End of macro DMARK
b15e					CALLMONITOR 
b15e cd dd 94			call break_point_state  
b161				endm  
# End of macro CALLMONITOR
b161				endif 
b161 c3 91 9f			jp exec1 
b164			 
b164					 
b164			 
b164			 
b164					NEXTW 
b164 c3 00 9f			jp macro_next 
b167				endm 
# End of macro NEXTW
b167			.I:  
b167			 
b167				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b167 5e				db WORD_SYS_CORE+74             
b168 92 b1			dw .DLOOP            
b16a 02				db 1 + 1 
b16b .. 00			db "I",0              
b16d				endm 
# End of macro CWHEAD
b16d			; | I ( -- ) Current loop counter | DONE 
b16d					if DEBUG_FORTH_WORDS_KEY 
b16d						DMARK "I.." 
b16d f5				push af  
b16e 3a 82 b1			ld a, (.dmark)  
b171 32 71 ee			ld (debug_mark),a  
b174 3a 83 b1			ld a, (.dmark+1)  
b177 32 72 ee			ld (debug_mark+1),a  
b17a 3a 84 b1			ld a, (.dmark+2)  
b17d 32 73 ee			ld (debug_mark+2),a  
b180 18 03			jr .pastdmark  
b182 ..			.dmark: db "I.."  
b185 f1			.pastdmark: pop af  
b186			endm  
# End of macro DMARK
b186						CALLMONITOR 
b186 cd dd 94			call break_point_state  
b189				endm  
# End of macro CALLMONITOR
b189					endif 
b189			 
b189 2a ec e5				ld hl,(os_current_i) 
b18c cd 53 9b				call forth_push_numhl 
b18f			 
b18f					NEXTW 
b18f c3 00 9f			jp macro_next 
b192				endm 
# End of macro NEXTW
b192			.DLOOP: 
b192				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b192 5f				db WORD_SYS_CORE+75             
b193 73 b2			dw .REPEAT            
b195 06				db 5 + 1 
b196 .. 00			db "-LOOP",0              
b19c				endm 
# End of macro CWHEAD
b19c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b19c				; pop tos as current loop count to hl 
b19c					if DEBUG_FORTH_WORDS_KEY 
b19c						DMARK "-LP" 
b19c f5				push af  
b19d 3a b1 b1			ld a, (.dmark)  
b1a0 32 71 ee			ld (debug_mark),a  
b1a3 3a b2 b1			ld a, (.dmark+1)  
b1a6 32 72 ee			ld (debug_mark+1),a  
b1a9 3a b3 b1			ld a, (.dmark+2)  
b1ac 32 73 ee			ld (debug_mark+2),a  
b1af 18 03			jr .pastdmark  
b1b1 ..			.dmark: db "-LP"  
b1b4 f1			.pastdmark: pop af  
b1b5			endm  
# End of macro DMARK
b1b5						CALLMONITOR 
b1b5 cd dd 94			call break_point_state  
b1b8				endm  
# End of macro CALLMONITOR
b1b8					endif 
b1b8			 
b1b8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b1b8			 
b1b8				FORTH_LOOP_TOS 
b1b8 cd ae 9d			call macro_forth_loop_tos 
b1bb				endm 
# End of macro FORTH_LOOP_TOS
b1bb e5				push hl 
b1bc			 
b1bc					if DEBUG_FORTH_WORDS 
b1bc						DMARK "-LP" 
b1bc f5				push af  
b1bd 3a d1 b1			ld a, (.dmark)  
b1c0 32 71 ee			ld (debug_mark),a  
b1c3 3a d2 b1			ld a, (.dmark+1)  
b1c6 32 72 ee			ld (debug_mark+1),a  
b1c9 3a d3 b1			ld a, (.dmark+2)  
b1cc 32 73 ee			ld (debug_mark+2),a  
b1cf 18 03			jr .pastdmark  
b1d1 ..			.dmark: db "-LP"  
b1d4 f1			.pastdmark: pop af  
b1d5			endm  
# End of macro DMARK
b1d5						CALLMONITOR 
b1d5 cd dd 94			call break_point_state  
b1d8				endm  
# End of macro CALLMONITOR
b1d8					endif 
b1d8				; next item on the stack is the limit. get it 
b1d8			 
b1d8			 
b1d8				FORTH_LOOP_POP 
b1d8 cd b8 9d			call macro_forth_loop_pop 
b1db				endm 
# End of macro FORTH_LOOP_POP
b1db			 
b1db				FORTH_LOOP_TOS 
b1db cd ae 9d			call macro_forth_loop_tos 
b1de				endm 
# End of macro FORTH_LOOP_TOS
b1de			 
b1de d1				pop de		 ; de = i, hl = limit 
b1df			 
b1df					if DEBUG_FORTH_WORDS 
b1df						DMARK "-L1" 
b1df f5				push af  
b1e0 3a f4 b1			ld a, (.dmark)  
b1e3 32 71 ee			ld (debug_mark),a  
b1e6 3a f5 b1			ld a, (.dmark+1)  
b1e9 32 72 ee			ld (debug_mark+1),a  
b1ec 3a f6 b1			ld a, (.dmark+2)  
b1ef 32 73 ee			ld (debug_mark+2),a  
b1f2 18 03			jr .pastdmark  
b1f4 ..			.dmark: db "-L1"  
b1f7 f1			.pastdmark: pop af  
b1f8			endm  
# End of macro DMARK
b1f8						CALLMONITOR 
b1f8 cd dd 94			call break_point_state  
b1fb				endm  
# End of macro CALLMONITOR
b1fb					endif 
b1fb			 
b1fb				; go back to previous word 
b1fb			 
b1fb d5				push de    ; save I for inc later 
b1fc			 
b1fc			 
b1fc				; get limit 
b1fc				;  is I at limit? 
b1fc			 
b1fc			 
b1fc					if DEBUG_FORTH_WORDS 
b1fc						DMARK "-L1" 
b1fc f5				push af  
b1fd 3a 11 b2			ld a, (.dmark)  
b200 32 71 ee			ld (debug_mark),a  
b203 3a 12 b2			ld a, (.dmark+1)  
b206 32 72 ee			ld (debug_mark+1),a  
b209 3a 13 b2			ld a, (.dmark+2)  
b20c 32 73 ee			ld (debug_mark+2),a  
b20f 18 03			jr .pastdmark  
b211 ..			.dmark: db "-L1"  
b214 f1			.pastdmark: pop af  
b215			endm  
# End of macro DMARK
b215						CALLMONITOR 
b215 cd dd 94			call break_point_state  
b218				endm  
# End of macro CALLMONITOR
b218					endif 
b218			 
b218 ed 52			sbc hl, de 
b21a			 
b21a			 
b21a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b21a			 
b21a 20 26				jr nz, .mloopnotdone 
b21c			 
b21c e1				pop hl   ; get rid of saved I 
b21d				FORTH_LOOP_POP     ; get rid of limit 
b21d cd b8 9d			call macro_forth_loop_pop 
b220				endm 
# End of macro FORTH_LOOP_POP
b220			 
b220				FORTH_RSP_POP     ; get rid of DO ptr 
b220 cd 1b 9b			call macro_forth_rsp_pop 
b223				endm 
# End of macro FORTH_RSP_POP
b223			 
b223			if DEBUG_FORTH_WORDS 
b223						DMARK "-L>" 
b223 f5				push af  
b224 3a 38 b2			ld a, (.dmark)  
b227 32 71 ee			ld (debug_mark),a  
b22a 3a 39 b2			ld a, (.dmark+1)  
b22d 32 72 ee			ld (debug_mark+1),a  
b230 3a 3a b2			ld a, (.dmark+2)  
b233 32 73 ee			ld (debug_mark+2),a  
b236 18 03			jr .pastdmark  
b238 ..			.dmark: db "-L>"  
b23b f1			.pastdmark: pop af  
b23c			endm  
# End of macro DMARK
b23c				CALLMONITOR 
b23c cd dd 94			call break_point_state  
b23f				endm  
# End of macro CALLMONITOR
b23f			endif 
b23f			 
b23f					NEXTW 
b23f c3 00 9f			jp macro_next 
b242				endm 
# End of macro NEXTW
b242				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b242			 
b242			.mloopnotdone: 
b242			 
b242 e1				pop hl    ; get I 
b243 2b				dec hl 
b244			 
b244			   	; save new I 
b244			 
b244			 
b244					; set I counter 
b244			 
b244 22 ec e5				ld (os_current_i), hl 
b247			 
b247					 
b247				FORTH_LOOP_NEXT 
b247 cd 7b 9d			call macro_forth_loop_next 
b24a				endm 
# End of macro FORTH_LOOP_NEXT
b24a			 
b24a			 
b24a					if DEBUG_FORTH_WORDS 
b24a eb						ex de,hl 
b24b					endif 
b24b			 
b24b			;	; get DO ptr 
b24b			; 
b24b				FORTH_RSP_TOS 
b24b cd 11 9b			call macro_forth_rsp_tos 
b24e				endm 
# End of macro FORTH_RSP_TOS
b24e			 
b24e				;push hl 
b24e			 
b24e				; not going to DO any more 
b24e				; get rid of the RSP pointer as DO will add it back in 
b24e				;FORTH_RSP_POP 
b24e				;pop hl 
b24e			 
b24e			 
b24e 22 c8 e5			ld (os_tok_ptr), hl 
b251					if DEBUG_FORTH_WORDS 
b251						DMARK "-L<" 
b251 f5				push af  
b252 3a 66 b2			ld a, (.dmark)  
b255 32 71 ee			ld (debug_mark),a  
b258 3a 67 b2			ld a, (.dmark+1)  
b25b 32 72 ee			ld (debug_mark+1),a  
b25e 3a 68 b2			ld a, (.dmark+2)  
b261 32 73 ee			ld (debug_mark+2),a  
b264 18 03			jr .pastdmark  
b266 ..			.dmark: db "-L<"  
b269 f1			.pastdmark: pop af  
b26a			endm  
# End of macro DMARK
b26a					CALLMONITOR 
b26a cd dd 94			call break_point_state  
b26d				endm  
# End of macro CALLMONITOR
b26d				endif 
b26d c3 91 9f			jp exec1 
b270			 
b270					 
b270			 
b270			 
b270			 
b270				NEXTW 
b270 c3 00 9f			jp macro_next 
b273				endm 
# End of macro NEXTW
b273			 
b273			 
b273			 
b273			 
b273			.REPEAT: 
b273				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b273 71				db WORD_SYS_CORE+93             
b274 c6 b2			dw .UNTIL            
b276 06				db 5 + 1 
b277 .. 00			db "REPEAT",0              
b27e				endm 
# End of macro CWHEAD
b27e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b27e			;  push pc to rsp stack past the REPEAT 
b27e					if DEBUG_FORTH_WORDS_KEY 
b27e						DMARK "REP" 
b27e f5				push af  
b27f 3a 93 b2			ld a, (.dmark)  
b282 32 71 ee			ld (debug_mark),a  
b285 3a 94 b2			ld a, (.dmark+1)  
b288 32 72 ee			ld (debug_mark+1),a  
b28b 3a 95 b2			ld a, (.dmark+2)  
b28e 32 73 ee			ld (debug_mark+2),a  
b291 18 03			jr .pastdmark  
b293 ..			.dmark: db "REP"  
b296 f1			.pastdmark: pop af  
b297			endm  
# End of macro DMARK
b297						CALLMONITOR 
b297 cd dd 94			call break_point_state  
b29a				endm  
# End of macro CALLMONITOR
b29a					endif 
b29a			 
b29a 2a c8 e5				ld hl, (os_tok_ptr) 
b29d 23					inc hl   ; R 
b29e 23					inc hl  ; E 
b29f 23					inc hl   ; P 
b2a0 23					inc hl   ; E 
b2a1 23					inc hl   ; A 
b2a2 23					inc hl   ; T 
b2a3 23					inc hl   ; zero 
b2a4					FORTH_RSP_NEXT 
b2a4 cd fa 9a			call macro_forth_rsp_next 
b2a7				endm 
# End of macro FORTH_RSP_NEXT
b2a7			 
b2a7			 
b2a7					if DEBUG_FORTH_WORDS 
b2a7						DMARK "REP" 
b2a7 f5				push af  
b2a8 3a bc b2			ld a, (.dmark)  
b2ab 32 71 ee			ld (debug_mark),a  
b2ae 3a bd b2			ld a, (.dmark+1)  
b2b1 32 72 ee			ld (debug_mark+1),a  
b2b4 3a be b2			ld a, (.dmark+2)  
b2b7 32 73 ee			ld (debug_mark+2),a  
b2ba 18 03			jr .pastdmark  
b2bc ..			.dmark: db "REP"  
b2bf f1			.pastdmark: pop af  
b2c0			endm  
# End of macro DMARK
b2c0						;pop bc    ; TODO BUG ?????? what is this for???? 
b2c0						CALLMONITOR 
b2c0 cd dd 94			call break_point_state  
b2c3				endm  
# End of macro CALLMONITOR
b2c3					endif 
b2c3			 
b2c3					NEXTW 
b2c3 c3 00 9f			jp macro_next 
b2c6				endm 
# End of macro NEXTW
b2c6			;	       NEXTW 
b2c6			 
b2c6			.UNTIL: 
b2c6				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b2c6 72				db WORD_SYS_CORE+94             
b2c7 5d b3			dw .ENDFLOW            
b2c9 06				db 5 + 1 
b2ca .. 00			db "UNTIL",0              
b2d0				endm 
# End of macro CWHEAD
b2d0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b2d0			 
b2d0				; pop tos as check 
b2d0			 
b2d0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b2d0			 
b2d0				FORTH_DSP_VALUEHL 
b2d0 cd 4a 9d			call macro_dsp_valuehl 
b2d3				endm 
# End of macro FORTH_DSP_VALUEHL
b2d3			 
b2d3					if DEBUG_FORTH_WORDS_KEY 
b2d3						DMARK "UNT" 
b2d3 f5				push af  
b2d4 3a e8 b2			ld a, (.dmark)  
b2d7 32 71 ee			ld (debug_mark),a  
b2da 3a e9 b2			ld a, (.dmark+1)  
b2dd 32 72 ee			ld (debug_mark+1),a  
b2e0 3a ea b2			ld a, (.dmark+2)  
b2e3 32 73 ee			ld (debug_mark+2),a  
b2e6 18 03			jr .pastdmark  
b2e8 ..			.dmark: db "UNT"  
b2eb f1			.pastdmark: pop af  
b2ec			endm  
# End of macro DMARK
b2ec						CALLMONITOR 
b2ec cd dd 94			call break_point_state  
b2ef				endm  
# End of macro CALLMONITOR
b2ef					endif 
b2ef			 
b2ef			;	push hl 
b2ef				FORTH_DSP_POP 
b2ef cd 02 9e			call macro_forth_dsp_pop 
b2f2				endm 
# End of macro FORTH_DSP_POP
b2f2			 
b2f2			;	pop hl 
b2f2			 
b2f2				; test if true 
b2f2			 
b2f2 cd 05 8d			call ishlzero 
b2f5			;	ld a,l 
b2f5			;	add h 
b2f5			; 
b2f5			;	cp 0 
b2f5			 
b2f5 20 3e			jr nz, .untilnotdone 
b2f7			 
b2f7					if DEBUG_FORTH_WORDS 
b2f7						DMARK "UNf" 
b2f7 f5				push af  
b2f8 3a 0c b3			ld a, (.dmark)  
b2fb 32 71 ee			ld (debug_mark),a  
b2fe 3a 0d b3			ld a, (.dmark+1)  
b301 32 72 ee			ld (debug_mark+1),a  
b304 3a 0e b3			ld a, (.dmark+2)  
b307 32 73 ee			ld (debug_mark+2),a  
b30a 18 03			jr .pastdmark  
b30c ..			.dmark: db "UNf"  
b30f f1			.pastdmark: pop af  
b310			endm  
# End of macro DMARK
b310						CALLMONITOR 
b310 cd dd 94			call break_point_state  
b313				endm  
# End of macro CALLMONITOR
b313					endif 
b313			 
b313			 
b313			 
b313				FORTH_RSP_POP     ; get rid of DO ptr 
b313 cd 1b 9b			call macro_forth_rsp_pop 
b316				endm 
# End of macro FORTH_RSP_POP
b316			 
b316			if DEBUG_FORTH_WORDS 
b316						DMARK "UN>" 
b316 f5				push af  
b317 3a 2b b3			ld a, (.dmark)  
b31a 32 71 ee			ld (debug_mark),a  
b31d 3a 2c b3			ld a, (.dmark+1)  
b320 32 72 ee			ld (debug_mark+1),a  
b323 3a 2d b3			ld a, (.dmark+2)  
b326 32 73 ee			ld (debug_mark+2),a  
b329 18 03			jr .pastdmark  
b32b ..			.dmark: db "UN>"  
b32e f1			.pastdmark: pop af  
b32f			endm  
# End of macro DMARK
b32f				CALLMONITOR 
b32f cd dd 94			call break_point_state  
b332				endm  
# End of macro CALLMONITOR
b332			endif 
b332			 
b332					NEXTW 
b332 c3 00 9f			jp macro_next 
b335				endm 
# End of macro NEXTW
b335				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b335			 
b335			.untilnotdone: 
b335			 
b335			 
b335			;	; get DO ptr 
b335			; 
b335				FORTH_RSP_TOS 
b335 cd 11 9b			call macro_forth_rsp_tos 
b338				endm 
# End of macro FORTH_RSP_TOS
b338			 
b338				;push hl 
b338			 
b338				; not going to DO any more 
b338				; get rid of the RSP pointer as DO will add it back in 
b338				;FORTH_RSP_POP 
b338				;pop hl 
b338			 
b338			 
b338 22 c8 e5			ld (os_tok_ptr), hl 
b33b					if DEBUG_FORTH_WORDS 
b33b						DMARK "UN<" 
b33b f5				push af  
b33c 3a 50 b3			ld a, (.dmark)  
b33f 32 71 ee			ld (debug_mark),a  
b342 3a 51 b3			ld a, (.dmark+1)  
b345 32 72 ee			ld (debug_mark+1),a  
b348 3a 52 b3			ld a, (.dmark+2)  
b34b 32 73 ee			ld (debug_mark+2),a  
b34e 18 03			jr .pastdmark  
b350 ..			.dmark: db "UN<"  
b353 f1			.pastdmark: pop af  
b354			endm  
# End of macro DMARK
b354					CALLMONITOR 
b354 cd dd 94			call break_point_state  
b357				endm  
# End of macro CALLMONITOR
b357				endif 
b357 c3 91 9f			jp exec1 
b35a			 
b35a					 
b35a			 
b35a			 
b35a					NEXTW 
b35a c3 00 9f			jp macro_next 
b35d				endm 
# End of macro NEXTW
b35d			 
b35d			 
b35d			.ENDFLOW: 
b35d			 
b35d			; eof 
b35d			 
# End of file forth_words_flow.asm
b35d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b35d			include "forth_words_logic.asm" 
b35d			 
b35d			; | ## Logic Words 
b35d			 
b35d			.NOT: 
b35d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b35d 2d				db WORD_SYS_CORE+25             
b35e a5 b3			dw .IS            
b360 04				db 3 + 1 
b361 .. 00			db "NOT",0              
b365				endm 
# End of macro CWHEAD
b365			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b365					if DEBUG_FORTH_WORDS_KEY 
b365						DMARK "NOT" 
b365 f5				push af  
b366 3a 7a b3			ld a, (.dmark)  
b369 32 71 ee			ld (debug_mark),a  
b36c 3a 7b b3			ld a, (.dmark+1)  
b36f 32 72 ee			ld (debug_mark+1),a  
b372 3a 7c b3			ld a, (.dmark+2)  
b375 32 73 ee			ld (debug_mark+2),a  
b378 18 03			jr .pastdmark  
b37a ..			.dmark: db "NOT"  
b37d f1			.pastdmark: pop af  
b37e			endm  
# End of macro DMARK
b37e						CALLMONITOR 
b37e cd dd 94			call break_point_state  
b381				endm  
# End of macro CALLMONITOR
b381					endif 
b381					FORTH_DSP 
b381 cd 10 9d			call macro_forth_dsp 
b384				endm 
# End of macro FORTH_DSP
b384 7e					ld a,(hl)	; get type of value on TOS 
b385 fe 02				cp DS_TYPE_INUM  
b387 28 03				jr z, .noti 
b389					NEXTW 
b389 c3 00 9f			jp macro_next 
b38c				endm 
# End of macro NEXTW
b38c			.noti:          FORTH_DSP_VALUEHL 
b38c cd 4a 9d			call macro_dsp_valuehl 
b38f				endm 
# End of macro FORTH_DSP_VALUEHL
b38f			;		push hl 
b38f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b38f cd 02 9e			call macro_forth_dsp_pop 
b392				endm 
# End of macro FORTH_DSP_POP
b392			;		pop hl 
b392 3e 00				ld a,0 
b394 bd					cp l 
b395 28 04				jr z, .not2t 
b397 2e 00				ld l, 0 
b399 18 02				jr .notip 
b39b			 
b39b 2e ff		.not2t:		ld l, 255 
b39d			 
b39d 26 00		.notip:		ld h, 0	 
b39f			 
b39f cd 53 9b				call forth_push_numhl 
b3a2					NEXTW 
b3a2 c3 00 9f			jp macro_next 
b3a5				endm 
# End of macro NEXTW
b3a5			 
b3a5			.IS: 
b3a5				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b3a5 2d				db WORD_SYS_CORE+25             
b3a6 cb b3			dw .LZERO            
b3a8 03				db 2 + 1 
b3a9 .. 00			db "IS",0              
b3ac				endm 
# End of macro CWHEAD
b3ac			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3ac					if DEBUG_FORTH_WORDS_KEY 
b3ac						DMARK "IS." 
b3ac f5				push af  
b3ad 3a c1 b3			ld a, (.dmark)  
b3b0 32 71 ee			ld (debug_mark),a  
b3b3 3a c2 b3			ld a, (.dmark+1)  
b3b6 32 72 ee			ld (debug_mark+1),a  
b3b9 3a c3 b3			ld a, (.dmark+2)  
b3bc 32 73 ee			ld (debug_mark+2),a  
b3bf 18 03			jr .pastdmark  
b3c1 ..			.dmark: db "IS."  
b3c4 f1			.pastdmark: pop af  
b3c5			endm  
# End of macro DMARK
b3c5						CALLMONITOR 
b3c5 cd dd 94			call break_point_state  
b3c8				endm  
# End of macro CALLMONITOR
b3c8					endif 
b3c8					NEXTW 
b3c8 c3 00 9f			jp macro_next 
b3cb				endm 
# End of macro NEXTW
b3cb			.LZERO: 
b3cb				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b3cb 2d				db WORD_SYS_CORE+25             
b3cc d5 b3			dw .TZERO            
b3ce 03				db 2 + 1 
b3cf .. 00			db "0<",0              
b3d2				endm 
# End of macro CWHEAD
b3d2			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b3d2					NEXTW 
b3d2 c3 00 9f			jp macro_next 
b3d5				endm 
# End of macro NEXTW
b3d5			.TZERO: 
b3d5				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b3d5 2e				db WORD_SYS_CORE+26             
b3d6 1c b4			dw .LESS            
b3d8 03				db 2 + 1 
b3d9 .. 00			db "0=",0              
b3dc				endm 
# End of macro CWHEAD
b3dc			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b3dc				; TODO add floating point number detection 
b3dc					;v5 FORTH_DSP_VALUE 
b3dc					if DEBUG_FORTH_WORDS_KEY 
b3dc						DMARK "0=." 
b3dc f5				push af  
b3dd 3a f1 b3			ld a, (.dmark)  
b3e0 32 71 ee			ld (debug_mark),a  
b3e3 3a f2 b3			ld a, (.dmark+1)  
b3e6 32 72 ee			ld (debug_mark+1),a  
b3e9 3a f3 b3			ld a, (.dmark+2)  
b3ec 32 73 ee			ld (debug_mark+2),a  
b3ef 18 03			jr .pastdmark  
b3f1 ..			.dmark: db "0=."  
b3f4 f1			.pastdmark: pop af  
b3f5			endm  
# End of macro DMARK
b3f5						CALLMONITOR 
b3f5 cd dd 94			call break_point_state  
b3f8				endm  
# End of macro CALLMONITOR
b3f8					endif 
b3f8					FORTH_DSP 
b3f8 cd 10 9d			call macro_forth_dsp 
b3fb				endm 
# End of macro FORTH_DSP
b3fb 7e					ld a,(hl)	; get type of value on TOS 
b3fc fe 02				cp DS_TYPE_INUM  
b3fe 28 00				jr z, .tz_inum 
b400			 
b400				if FORTH_ENABLE_FLOATMATH 
b400					jr .tz_done 
b400			 
b400				endif 
b400					 
b400			 
b400			.tz_inum: 
b400					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b400 cd 4a 9d			call macro_dsp_valuehl 
b403				endm 
# End of macro FORTH_DSP_VALUEHL
b403			 
b403			;		push hl 
b403			 
b403					; destroy value TOS 
b403			 
b403					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b403 cd 02 9e			call macro_forth_dsp_pop 
b406				endm 
# End of macro FORTH_DSP_POP
b406			 
b406			;		pop hl 
b406			 
b406 3e 00				ld a,0 
b408			 
b408 bd					cp l 
b409 20 08				jr nz, .tz_notzero 
b40b			 
b40b bc					cp h 
b40c			 
b40c 20 05				jr nz, .tz_notzero 
b40e			 
b40e			 
b40e 21 01 00				ld hl, FORTH_TRUE 
b411 18 03				jr .tz_done 
b413			 
b413 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b416			 
b416					; push value back onto stack for another op etc 
b416			 
b416			.tz_done: 
b416 cd 53 9b				call forth_push_numhl 
b419			 
b419					NEXTW 
b419 c3 00 9f			jp macro_next 
b41c				endm 
# End of macro NEXTW
b41c			.LESS: 
b41c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b41c 2f				db WORD_SYS_CORE+27             
b41d 85 b4			dw .GT            
b41f 02				db 1 + 1 
b420 .. 00			db "<",0              
b422				endm 
# End of macro CWHEAD
b422			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b422				; TODO add floating point number detection 
b422					if DEBUG_FORTH_WORDS_KEY 
b422						DMARK "LES" 
b422 f5				push af  
b423 3a 37 b4			ld a, (.dmark)  
b426 32 71 ee			ld (debug_mark),a  
b429 3a 38 b4			ld a, (.dmark+1)  
b42c 32 72 ee			ld (debug_mark+1),a  
b42f 3a 39 b4			ld a, (.dmark+2)  
b432 32 73 ee			ld (debug_mark+2),a  
b435 18 03			jr .pastdmark  
b437 ..			.dmark: db "LES"  
b43a f1			.pastdmark: pop af  
b43b			endm  
# End of macro DMARK
b43b						CALLMONITOR 
b43b cd dd 94			call break_point_state  
b43e				endm  
# End of macro CALLMONITOR
b43e					endif 
b43e					FORTH_DSP 
b43e cd 10 9d			call macro_forth_dsp 
b441				endm 
# End of macro FORTH_DSP
b441					;v5 FORTH_DSP_VALUE 
b441 7e					ld a,(hl)	; get type of value on TOS 
b442 fe 02				cp DS_TYPE_INUM  
b444 28 00				jr z, .less_inum 
b446			 
b446				if FORTH_ENABLE_FLOATMATH 
b446					jr .less_done 
b446			 
b446				endif 
b446					 
b446			 
b446			.less_inum: 
b446					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b446 cd 4a 9d			call macro_dsp_valuehl 
b449				endm 
# End of macro FORTH_DSP_VALUEHL
b449			 
b449 e5					push hl  ; u2 
b44a			 
b44a					; destroy value TOS 
b44a			 
b44a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44a cd 02 9e			call macro_forth_dsp_pop 
b44d				endm 
# End of macro FORTH_DSP_POP
b44d			 
b44d			 
b44d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b44d cd 4a 9d			call macro_dsp_valuehl 
b450				endm 
# End of macro FORTH_DSP_VALUEHL
b450			 
b450 e5					push hl    ; u1 
b451			 
b451					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b451 cd 02 9e			call macro_forth_dsp_pop 
b454				endm 
# End of macro FORTH_DSP_POP
b454			 
b454			 
b454 b7			 or a      ;clear carry flag 
b455 01 00 00		 ld bc, FORTH_FALSE 
b458 e1			  pop hl    ; u1 
b459 d1			  pop de    ; u2 
b45a ed 52		  sbc hl,de 
b45c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b45e			 
b45e 01 01 00		 ld bc, FORTH_TRUE 
b461			.lscont:  
b461 c5					push bc 
b462 e1					pop hl 
b463			 
b463					if DEBUG_FORTH_WORDS 
b463						DMARK "LT1" 
b463 f5				push af  
b464 3a 78 b4			ld a, (.dmark)  
b467 32 71 ee			ld (debug_mark),a  
b46a 3a 79 b4			ld a, (.dmark+1)  
b46d 32 72 ee			ld (debug_mark+1),a  
b470 3a 7a b4			ld a, (.dmark+2)  
b473 32 73 ee			ld (debug_mark+2),a  
b476 18 03			jr .pastdmark  
b478 ..			.dmark: db "LT1"  
b47b f1			.pastdmark: pop af  
b47c			endm  
# End of macro DMARK
b47c						CALLMONITOR 
b47c cd dd 94			call break_point_state  
b47f				endm  
# End of macro CALLMONITOR
b47f					endif 
b47f cd 53 9b				call forth_push_numhl 
b482			 
b482					NEXTW 
b482 c3 00 9f			jp macro_next 
b485				endm 
# End of macro NEXTW
b485			.GT: 
b485				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b485 30				db WORD_SYS_CORE+28             
b486 ee b4			dw .EQUAL            
b488 02				db 1 + 1 
b489 .. 00			db ">",0              
b48b				endm 
# End of macro CWHEAD
b48b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b48b				; TODO add floating point number detection 
b48b					if DEBUG_FORTH_WORDS_KEY 
b48b						DMARK "GRT" 
b48b f5				push af  
b48c 3a a0 b4			ld a, (.dmark)  
b48f 32 71 ee			ld (debug_mark),a  
b492 3a a1 b4			ld a, (.dmark+1)  
b495 32 72 ee			ld (debug_mark+1),a  
b498 3a a2 b4			ld a, (.dmark+2)  
b49b 32 73 ee			ld (debug_mark+2),a  
b49e 18 03			jr .pastdmark  
b4a0 ..			.dmark: db "GRT"  
b4a3 f1			.pastdmark: pop af  
b4a4			endm  
# End of macro DMARK
b4a4						CALLMONITOR 
b4a4 cd dd 94			call break_point_state  
b4a7				endm  
# End of macro CALLMONITOR
b4a7					endif 
b4a7					FORTH_DSP 
b4a7 cd 10 9d			call macro_forth_dsp 
b4aa				endm 
# End of macro FORTH_DSP
b4aa					;FORTH_DSP_VALUE 
b4aa 7e					ld a,(hl)	; get type of value on TOS 
b4ab fe 02				cp DS_TYPE_INUM  
b4ad 28 00				jr z, .gt_inum 
b4af			 
b4af				if FORTH_ENABLE_FLOATMATH 
b4af					jr .gt_done 
b4af			 
b4af				endif 
b4af					 
b4af			 
b4af			.gt_inum: 
b4af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4af cd 4a 9d			call macro_dsp_valuehl 
b4b2				endm 
# End of macro FORTH_DSP_VALUEHL
b4b2			 
b4b2 e5					push hl  ; u2 
b4b3			 
b4b3					; destroy value TOS 
b4b3			 
b4b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4b3 cd 02 9e			call macro_forth_dsp_pop 
b4b6				endm 
# End of macro FORTH_DSP_POP
b4b6			 
b4b6			 
b4b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4b6 cd 4a 9d			call macro_dsp_valuehl 
b4b9				endm 
# End of macro FORTH_DSP_VALUEHL
b4b9			 
b4b9 e5					push hl    ; u1 
b4ba			 
b4ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4ba cd 02 9e			call macro_forth_dsp_pop 
b4bd				endm 
# End of macro FORTH_DSP_POP
b4bd			 
b4bd			 
b4bd b7			 or a      ;clear carry flag 
b4be 01 00 00		 ld bc, FORTH_FALSE 
b4c1 e1			  pop hl    ; u1 
b4c2 d1			  pop de    ; u2 
b4c3 ed 52		  sbc hl,de 
b4c5 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b4c7			 
b4c7 01 01 00		 ld bc, FORTH_TRUE 
b4ca			.gtcont:  
b4ca c5					push bc 
b4cb e1					pop hl 
b4cc			 
b4cc					if DEBUG_FORTH_WORDS 
b4cc						DMARK "GT1" 
b4cc f5				push af  
b4cd 3a e1 b4			ld a, (.dmark)  
b4d0 32 71 ee			ld (debug_mark),a  
b4d3 3a e2 b4			ld a, (.dmark+1)  
b4d6 32 72 ee			ld (debug_mark+1),a  
b4d9 3a e3 b4			ld a, (.dmark+2)  
b4dc 32 73 ee			ld (debug_mark+2),a  
b4df 18 03			jr .pastdmark  
b4e1 ..			.dmark: db "GT1"  
b4e4 f1			.pastdmark: pop af  
b4e5			endm  
# End of macro DMARK
b4e5						CALLMONITOR 
b4e5 cd dd 94			call break_point_state  
b4e8				endm  
# End of macro CALLMONITOR
b4e8					endif 
b4e8 cd 53 9b				call forth_push_numhl 
b4eb			 
b4eb					NEXTW 
b4eb c3 00 9f			jp macro_next 
b4ee				endm 
# End of macro NEXTW
b4ee			.EQUAL: 
b4ee				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b4ee 31				db WORD_SYS_CORE+29             
b4ef 59 b5			dw .ENDLOGIC            
b4f1 02				db 1 + 1 
b4f2 .. 00			db "=",0              
b4f4				endm 
# End of macro CWHEAD
b4f4			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b4f4				; TODO add floating point number detection 
b4f4					if DEBUG_FORTH_WORDS_KEY 
b4f4						DMARK "EQ." 
b4f4 f5				push af  
b4f5 3a 09 b5			ld a, (.dmark)  
b4f8 32 71 ee			ld (debug_mark),a  
b4fb 3a 0a b5			ld a, (.dmark+1)  
b4fe 32 72 ee			ld (debug_mark+1),a  
b501 3a 0b b5			ld a, (.dmark+2)  
b504 32 73 ee			ld (debug_mark+2),a  
b507 18 03			jr .pastdmark  
b509 ..			.dmark: db "EQ."  
b50c f1			.pastdmark: pop af  
b50d			endm  
# End of macro DMARK
b50d						CALLMONITOR 
b50d cd dd 94			call break_point_state  
b510				endm  
# End of macro CALLMONITOR
b510					endif 
b510					FORTH_DSP 
b510 cd 10 9d			call macro_forth_dsp 
b513				endm 
# End of macro FORTH_DSP
b513					;v5 FORTH_DSP_VALUE 
b513 7e					ld a,(hl)	; get type of value on TOS 
b514 fe 02				cp DS_TYPE_INUM  
b516 28 00				jr z, .eq_inum 
b518			 
b518				if FORTH_ENABLE_FLOATMATH 
b518					jr .eq_done 
b518			 
b518				endif 
b518					 
b518			 
b518			.eq_inum: 
b518					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b518 cd 4a 9d			call macro_dsp_valuehl 
b51b				endm 
# End of macro FORTH_DSP_VALUEHL
b51b			 
b51b e5					push hl 
b51c			 
b51c					; destroy value TOS 
b51c			 
b51c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b51c cd 02 9e			call macro_forth_dsp_pop 
b51f				endm 
# End of macro FORTH_DSP_POP
b51f			 
b51f			 
b51f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b51f cd 4a 9d			call macro_dsp_valuehl 
b522				endm 
# End of macro FORTH_DSP_VALUEHL
b522			 
b522					; one value on hl get other one back 
b522			 
b522 e5					push hl 
b523			 
b523					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b523 cd 02 9e			call macro_forth_dsp_pop 
b526				endm 
# End of macro FORTH_DSP_POP
b526			 
b526 0e 00				ld c, FORTH_FALSE 
b528			 
b528 e1					pop hl 
b529 d1					pop de 
b52a			 
b52a 7b					ld a, e 
b52b bd					cp l 
b52c			 
b52c 20 06				jr nz, .eq_done 
b52e			 
b52e 7a					ld a, d 
b52f bc					cp h 
b530			 
b530 20 02				jr nz, .eq_done 
b532			 
b532 0e 01				ld c, FORTH_TRUE 
b534					 
b534			 
b534			 
b534			.eq_done: 
b534			 
b534					; TODO push value back onto stack for another op etc 
b534			 
b534 26 00				ld h, 0 
b536 69					ld l, c 
b537					if DEBUG_FORTH_WORDS 
b537						DMARK "EQ1" 
b537 f5				push af  
b538 3a 4c b5			ld a, (.dmark)  
b53b 32 71 ee			ld (debug_mark),a  
b53e 3a 4d b5			ld a, (.dmark+1)  
b541 32 72 ee			ld (debug_mark+1),a  
b544 3a 4e b5			ld a, (.dmark+2)  
b547 32 73 ee			ld (debug_mark+2),a  
b54a 18 03			jr .pastdmark  
b54c ..			.dmark: db "EQ1"  
b54f f1			.pastdmark: pop af  
b550			endm  
# End of macro DMARK
b550						CALLMONITOR 
b550 cd dd 94			call break_point_state  
b553				endm  
# End of macro CALLMONITOR
b553					endif 
b553 cd 53 9b				call forth_push_numhl 
b556			 
b556					NEXTW 
b556 c3 00 9f			jp macro_next 
b559				endm 
# End of macro NEXTW
b559			 
b559			 
b559			.ENDLOGIC: 
b559			; eof 
b559			 
b559			 
# End of file forth_words_logic.asm
b559			include "forth_words_maths.asm" 
b559			 
b559			; | ## Maths Words 
b559			 
b559			.PLUS:	 
b559				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b559 15				db WORD_SYS_CORE+1             
b55a b7 b5			dw .NEG            
b55c 02				db 1 + 1 
b55d .. 00			db "+",0              
b55f				endm 
# End of macro CWHEAD
b55f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b55f					if DEBUG_FORTH_WORDS_KEY 
b55f						DMARK "PLU" 
b55f f5				push af  
b560 3a 74 b5			ld a, (.dmark)  
b563 32 71 ee			ld (debug_mark),a  
b566 3a 75 b5			ld a, (.dmark+1)  
b569 32 72 ee			ld (debug_mark+1),a  
b56c 3a 76 b5			ld a, (.dmark+2)  
b56f 32 73 ee			ld (debug_mark+2),a  
b572 18 03			jr .pastdmark  
b574 ..			.dmark: db "PLU"  
b577 f1			.pastdmark: pop af  
b578			endm  
# End of macro DMARK
b578						CALLMONITOR 
b578 cd dd 94			call break_point_state  
b57b				endm  
# End of macro CALLMONITOR
b57b					endif 
b57b					; add top two values and push back result 
b57b			 
b57b					;for v5 FORTH_DSP_VALUE 
b57b					FORTH_DSP 
b57b cd 10 9d			call macro_forth_dsp 
b57e				endm 
# End of macro FORTH_DSP
b57e 7e					ld a,(hl)	; get type of value on TOS 
b57f fe 02				cp DS_TYPE_INUM  
b581 28 03				jr z, .dot_inum 
b583			 
b583					NEXTW 
b583 c3 00 9f			jp macro_next 
b586				endm 
# End of macro NEXTW
b586			 
b586			; float maths 
b586			 
b586				if FORTH_ENABLE_FLOATMATH 
b586						inc hl      ; now at start of numeric as string 
b586			 
b586					if DEBUG_FORTH_MATHS 
b586						DMARK "ADD" 
b586				CALLMONITOR 
b586					endif 
b586			 
b586					;ld ix, hl 
b586					call CON 
b586			 
b586			 
b586					push hl 
b586					 
b586					 
b586			 
b586						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b586			 
b586					; get next number 
b586			 
b586						FORTH_DSP_VALUE 
b586			 
b586						inc hl      ; now at start of numeric as string 
b586			 
b586					;ld ix, hl 
b586					call CON 
b586			 
b586					push hl 
b586			 
b586			 
b586						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b586			 
b586						; TODO do add 
b586			 
b586						call IADD 
b586			 
b586						; TODO get result back as ascii 
b586			 
b586						; TODO push result  
b586			 
b586			 
b586			 
b586						jr .dot_done 
b586				endif 
b586			 
b586			.dot_inum: 
b586			 
b586			 
b586					if DEBUG_FORTH_DOT 
b586						DMARK "+IT" 
b586 f5				push af  
b587 3a 9b b5			ld a, (.dmark)  
b58a 32 71 ee			ld (debug_mark),a  
b58d 3a 9c b5			ld a, (.dmark+1)  
b590 32 72 ee			ld (debug_mark+1),a  
b593 3a 9d b5			ld a, (.dmark+2)  
b596 32 73 ee			ld (debug_mark+2),a  
b599 18 03			jr .pastdmark  
b59b ..			.dmark: db "+IT"  
b59e f1			.pastdmark: pop af  
b59f			endm  
# End of macro DMARK
b59f				CALLMONITOR 
b59f cd dd 94			call break_point_state  
b5a2				endm  
# End of macro CALLMONITOR
b5a2					endif 
b5a2			 
b5a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a2 cd 4a 9d			call macro_dsp_valuehl 
b5a5				endm 
# End of macro FORTH_DSP_VALUEHL
b5a5			 
b5a5				; TODO add floating point number detection 
b5a5			 
b5a5 e5					push hl 
b5a6			 
b5a6					; destroy value TOS 
b5a6			 
b5a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5a6 cd 02 9e			call macro_forth_dsp_pop 
b5a9				endm 
# End of macro FORTH_DSP_POP
b5a9			 
b5a9			 
b5a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a9 cd 4a 9d			call macro_dsp_valuehl 
b5ac				endm 
# End of macro FORTH_DSP_VALUEHL
b5ac			 
b5ac					; one value on hl get other one back 
b5ac			 
b5ac d1					pop de 
b5ad			 
b5ad					; do the add 
b5ad			 
b5ad 19					add hl,de 
b5ae			 
b5ae					; save it 
b5ae			 
b5ae			;		push hl	 
b5ae			 
b5ae					; 
b5ae			 
b5ae					; destroy value TOS 
b5ae			 
b5ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ae cd 02 9e			call macro_forth_dsp_pop 
b5b1				endm 
# End of macro FORTH_DSP_POP
b5b1			 
b5b1					; TODO push value back onto stack for another op etc 
b5b1			 
b5b1			;		pop hl 
b5b1			 
b5b1			.dot_done: 
b5b1 cd 53 9b				call forth_push_numhl 
b5b4			 
b5b4					NEXTW 
b5b4 c3 00 9f			jp macro_next 
b5b7				endm 
# End of macro NEXTW
b5b7			.NEG: 
b5b7			 
b5b7				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b5b7 17				db WORD_SYS_CORE+3             
b5b8 fa b5			dw .DIV            
b5ba 02				db 1 + 1 
b5bb .. 00			db "-",0              
b5bd				endm 
# End of macro CWHEAD
b5bd			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b5bd					if DEBUG_FORTH_WORDS_KEY 
b5bd						DMARK "SUB" 
b5bd f5				push af  
b5be 3a d2 b5			ld a, (.dmark)  
b5c1 32 71 ee			ld (debug_mark),a  
b5c4 3a d3 b5			ld a, (.dmark+1)  
b5c7 32 72 ee			ld (debug_mark+1),a  
b5ca 3a d4 b5			ld a, (.dmark+2)  
b5cd 32 73 ee			ld (debug_mark+2),a  
b5d0 18 03			jr .pastdmark  
b5d2 ..			.dmark: db "SUB"  
b5d5 f1			.pastdmark: pop af  
b5d6			endm  
# End of macro DMARK
b5d6						CALLMONITOR 
b5d6 cd dd 94			call break_point_state  
b5d9				endm  
# End of macro CALLMONITOR
b5d9					endif 
b5d9			 
b5d9			 
b5d9				; TODO add floating point number detection 
b5d9					; v5 FORTH_DSP_VALUE 
b5d9					FORTH_DSP 
b5d9 cd 10 9d			call macro_forth_dsp 
b5dc				endm 
# End of macro FORTH_DSP
b5dc 7e					ld a,(hl)	; get type of value on TOS 
b5dd fe 02				cp DS_TYPE_INUM  
b5df 28 03				jr z, .neg_inum 
b5e1			 
b5e1					NEXTW 
b5e1 c3 00 9f			jp macro_next 
b5e4				endm 
# End of macro NEXTW
b5e4			 
b5e4			; float maths 
b5e4			 
b5e4				if FORTH_ENABLE_FLOATMATH 
b5e4					jr .neg_done 
b5e4			 
b5e4				endif 
b5e4					 
b5e4			 
b5e4			.neg_inum: 
b5e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5e4 cd 4a 9d			call macro_dsp_valuehl 
b5e7				endm 
# End of macro FORTH_DSP_VALUEHL
b5e7			 
b5e7 e5					push hl 
b5e8			 
b5e8					; destroy value TOS 
b5e8			 
b5e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e8 cd 02 9e			call macro_forth_dsp_pop 
b5eb				endm 
# End of macro FORTH_DSP_POP
b5eb			 
b5eb			 
b5eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5eb cd 4a 9d			call macro_dsp_valuehl 
b5ee				endm 
# End of macro FORTH_DSP_VALUEHL
b5ee			 
b5ee					; one value on hl get other one back 
b5ee			 
b5ee d1					pop de 
b5ef			 
b5ef					; do the sub 
b5ef			;		ex de, hl 
b5ef			 
b5ef ed 52				sbc hl,de 
b5f1			 
b5f1					; save it 
b5f1			 
b5f1			;		push hl	 
b5f1			 
b5f1					; 
b5f1			 
b5f1					; destroy value TOS 
b5f1			 
b5f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5f1 cd 02 9e			call macro_forth_dsp_pop 
b5f4				endm 
# End of macro FORTH_DSP_POP
b5f4			 
b5f4					; TODO push value back onto stack for another op etc 
b5f4			 
b5f4			;		pop hl 
b5f4			 
b5f4 cd 53 9b				call forth_push_numhl 
b5f7			.neg_done: 
b5f7			 
b5f7					NEXTW 
b5f7 c3 00 9f			jp macro_next 
b5fa				endm 
# End of macro NEXTW
b5fa			.DIV: 
b5fa				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b5fa 18				db WORD_SYS_CORE+4             
b5fb 47 b6			dw .MUL            
b5fd 02				db 1 + 1 
b5fe .. 00			db "/",0              
b600				endm 
# End of macro CWHEAD
b600			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b600					if DEBUG_FORTH_WORDS_KEY 
b600						DMARK "DIV" 
b600 f5				push af  
b601 3a 15 b6			ld a, (.dmark)  
b604 32 71 ee			ld (debug_mark),a  
b607 3a 16 b6			ld a, (.dmark+1)  
b60a 32 72 ee			ld (debug_mark+1),a  
b60d 3a 17 b6			ld a, (.dmark+2)  
b610 32 73 ee			ld (debug_mark+2),a  
b613 18 03			jr .pastdmark  
b615 ..			.dmark: db "DIV"  
b618 f1			.pastdmark: pop af  
b619			endm  
# End of macro DMARK
b619						CALLMONITOR 
b619 cd dd 94			call break_point_state  
b61c				endm  
# End of macro CALLMONITOR
b61c					endif 
b61c				; TODO add floating point number detection 
b61c					; v5 FORTH_DSP_VALUE 
b61c					FORTH_DSP 
b61c cd 10 9d			call macro_forth_dsp 
b61f				endm 
# End of macro FORTH_DSP
b61f 7e					ld a,(hl)	; get type of value on TOS 
b620 fe 02				cp DS_TYPE_INUM  
b622 28 03				jr z, .div_inum 
b624			 
b624				if FORTH_ENABLE_FLOATMATH 
b624					jr .div_done 
b624			 
b624				endif 
b624					NEXTW 
b624 c3 00 9f			jp macro_next 
b627				endm 
# End of macro NEXTW
b627			.div_inum: 
b627			 
b627					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b627 cd 4a 9d			call macro_dsp_valuehl 
b62a				endm 
# End of macro FORTH_DSP_VALUEHL
b62a			 
b62a e5					push hl    ; to go to bc 
b62b			 
b62b					; destroy value TOS 
b62b			 
b62b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b62b cd 02 9e			call macro_forth_dsp_pop 
b62e				endm 
# End of macro FORTH_DSP_POP
b62e			 
b62e			 
b62e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b62e cd 4a 9d			call macro_dsp_valuehl 
b631				endm 
# End of macro FORTH_DSP_VALUEHL
b631			 
b631					; hl to go to de 
b631			 
b631 e5					push hl 
b632			 
b632 c1					pop bc 
b633 d1					pop de		 
b634			 
b634			 
b634					if DEBUG_FORTH_MATHS 
b634						DMARK "DIV" 
b634				CALLMONITOR 
b634					endif 
b634					; one value on hl but move to a get other one back 
b634			 
b634			        
b634 cd 39 8c			call Div16 
b637			 
b637			;	push af	 
b637 e5				push hl 
b638 c5				push bc 
b639			 
b639					if DEBUG_FORTH_MATHS 
b639						DMARK "DI1" 
b639				CALLMONITOR 
b639					endif 
b639			 
b639					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b639 cd 02 9e			call macro_forth_dsp_pop 
b63c				endm 
# End of macro FORTH_DSP_POP
b63c			 
b63c			 
b63c			 
b63c e1					pop hl    ; result 
b63d			 
b63d cd 53 9b				call forth_push_numhl 
b640			 
b640 e1					pop hl    ; reminder 
b641			;		ld h,0 
b641			;		ld l,d 
b641			 
b641 cd 53 9b				call forth_push_numhl 
b644			.div_done: 
b644					NEXTW 
b644 c3 00 9f			jp macro_next 
b647				endm 
# End of macro NEXTW
b647			.MUL: 
b647				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b647 19				db WORD_SYS_CORE+5             
b648 8c b6			dw .MIN            
b64a 02				db 1 + 1 
b64b .. 00			db "*",0              
b64d				endm 
# End of macro CWHEAD
b64d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b64d				; TODO add floating point number detection 
b64d					if DEBUG_FORTH_WORDS_KEY 
b64d						DMARK "MUL" 
b64d f5				push af  
b64e 3a 62 b6			ld a, (.dmark)  
b651 32 71 ee			ld (debug_mark),a  
b654 3a 63 b6			ld a, (.dmark+1)  
b657 32 72 ee			ld (debug_mark+1),a  
b65a 3a 64 b6			ld a, (.dmark+2)  
b65d 32 73 ee			ld (debug_mark+2),a  
b660 18 03			jr .pastdmark  
b662 ..			.dmark: db "MUL"  
b665 f1			.pastdmark: pop af  
b666			endm  
# End of macro DMARK
b666						CALLMONITOR 
b666 cd dd 94			call break_point_state  
b669				endm  
# End of macro CALLMONITOR
b669					endif 
b669					FORTH_DSP 
b669 cd 10 9d			call macro_forth_dsp 
b66c				endm 
# End of macro FORTH_DSP
b66c					; v5 FORTH_DSP_VALUE 
b66c 7e					ld a,(hl)	; get type of value on TOS 
b66d fe 02				cp DS_TYPE_INUM  
b66f 28 03				jr z, .mul_inum 
b671			 
b671				if FORTH_ENABLE_FLOATMATH 
b671					jr .mul_done 
b671			 
b671				endif 
b671			 
b671					NEXTW 
b671 c3 00 9f			jp macro_next 
b674				endm 
# End of macro NEXTW
b674			.mul_inum:	 
b674			 
b674					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b674 cd 4a 9d			call macro_dsp_valuehl 
b677				endm 
# End of macro FORTH_DSP_VALUEHL
b677			 
b677 e5					push hl 
b678			 
b678					; destroy value TOS 
b678			 
b678					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b678 cd 02 9e			call macro_forth_dsp_pop 
b67b				endm 
# End of macro FORTH_DSP_POP
b67b			 
b67b			 
b67b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b67b cd 4a 9d			call macro_dsp_valuehl 
b67e				endm 
# End of macro FORTH_DSP_VALUEHL
b67e			 
b67e					; one value on hl but move to a get other one back 
b67e			 
b67e 7d					ld a, l 
b67f			 
b67f d1					pop de 
b680			 
b680					; do the mull 
b680			;		ex de, hl 
b680			 
b680 cd 5f 8c				call Mult16 
b683					; save it 
b683			 
b683			;		push hl	 
b683			 
b683					; 
b683			 
b683					; destroy value TOS 
b683			 
b683					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b683 cd 02 9e			call macro_forth_dsp_pop 
b686				endm 
# End of macro FORTH_DSP_POP
b686			 
b686					; TODO push value back onto stack for another op etc 
b686			 
b686			;		pop hl 
b686			 
b686 cd 53 9b				call forth_push_numhl 
b689			 
b689			.mul_done: 
b689					NEXTW 
b689 c3 00 9f			jp macro_next 
b68c				endm 
# End of macro NEXTW
b68c			 
b68c			 
b68c			 
b68c			 
b68c			.MIN: 
b68c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b68c 49				db WORD_SYS_CORE+53             
b68d 0d b7			dw .MAX            
b68f 04				db 3 + 1 
b690 .. 00			db "MIN",0              
b694				endm 
# End of macro CWHEAD
b694			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b694					if DEBUG_FORTH_WORDS_KEY 
b694						DMARK "MIN" 
b694 f5				push af  
b695 3a a9 b6			ld a, (.dmark)  
b698 32 71 ee			ld (debug_mark),a  
b69b 3a aa b6			ld a, (.dmark+1)  
b69e 32 72 ee			ld (debug_mark+1),a  
b6a1 3a ab b6			ld a, (.dmark+2)  
b6a4 32 73 ee			ld (debug_mark+2),a  
b6a7 18 03			jr .pastdmark  
b6a9 ..			.dmark: db "MIN"  
b6ac f1			.pastdmark: pop af  
b6ad			endm  
# End of macro DMARK
b6ad						CALLMONITOR 
b6ad cd dd 94			call break_point_state  
b6b0				endm  
# End of macro CALLMONITOR
b6b0					endif 
b6b0					; get u2 
b6b0			 
b6b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b0 cd 4a 9d			call macro_dsp_valuehl 
b6b3				endm 
# End of macro FORTH_DSP_VALUEHL
b6b3			 
b6b3 e5					push hl   ; u2 
b6b4			 
b6b4					; destroy value TOS 
b6b4			 
b6b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b4 cd 02 9e			call macro_forth_dsp_pop 
b6b7				endm 
# End of macro FORTH_DSP_POP
b6b7			 
b6b7					; get u1 
b6b7			 
b6b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b7 cd 4a 9d			call macro_dsp_valuehl 
b6ba				endm 
# End of macro FORTH_DSP_VALUEHL
b6ba			 
b6ba e5					push hl  ; u1 
b6bb			 
b6bb					; destroy value TOS 
b6bb			 
b6bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6bb cd 02 9e			call macro_forth_dsp_pop 
b6be				endm 
# End of macro FORTH_DSP_POP
b6be			 
b6be b7			 or a      ;clear carry flag 
b6bf e1			  pop hl    ; u1 
b6c0 d1			  pop de    ; u2 
b6c1 e5				push hl   ; saved in case hl is lowest 
b6c2 ed 52		  sbc hl,de 
b6c4 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b6c6			 
b6c6 e1				pop hl 
b6c7					if DEBUG_FORTH_WORDS 
b6c7						DMARK "MIN" 
b6c7 f5				push af  
b6c8 3a dc b6			ld a, (.dmark)  
b6cb 32 71 ee			ld (debug_mark),a  
b6ce 3a dd b6			ld a, (.dmark+1)  
b6d1 32 72 ee			ld (debug_mark+1),a  
b6d4 3a de b6			ld a, (.dmark+2)  
b6d7 32 73 ee			ld (debug_mark+2),a  
b6da 18 03			jr .pastdmark  
b6dc ..			.dmark: db "MIN"  
b6df f1			.pastdmark: pop af  
b6e0			endm  
# End of macro DMARK
b6e0						CALLMONITOR 
b6e0 cd dd 94			call break_point_state  
b6e3				endm  
# End of macro CALLMONITOR
b6e3					endif 
b6e3 cd 53 9b				call forth_push_numhl 
b6e6			 
b6e6				       NEXTW 
b6e6 c3 00 9f			jp macro_next 
b6e9				endm 
# End of macro NEXTW
b6e9			 
b6e9			.mincont:  
b6e9 c1				pop bc   ; tidy up 
b6ea eb				ex de , hl  
b6eb					if DEBUG_FORTH_WORDS 
b6eb						DMARK "MI1" 
b6eb f5				push af  
b6ec 3a 00 b7			ld a, (.dmark)  
b6ef 32 71 ee			ld (debug_mark),a  
b6f2 3a 01 b7			ld a, (.dmark+1)  
b6f5 32 72 ee			ld (debug_mark+1),a  
b6f8 3a 02 b7			ld a, (.dmark+2)  
b6fb 32 73 ee			ld (debug_mark+2),a  
b6fe 18 03			jr .pastdmark  
b700 ..			.dmark: db "MI1"  
b703 f1			.pastdmark: pop af  
b704			endm  
# End of macro DMARK
b704						CALLMONITOR 
b704 cd dd 94			call break_point_state  
b707				endm  
# End of macro CALLMONITOR
b707					endif 
b707 cd 53 9b				call forth_push_numhl 
b70a			 
b70a				       NEXTW 
b70a c3 00 9f			jp macro_next 
b70d				endm 
# End of macro NEXTW
b70d			.MAX: 
b70d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b70d 4a				db WORD_SYS_CORE+54             
b70e 8e b7			dw .RND16            
b710 04				db 3 + 1 
b711 .. 00			db "MAX",0              
b715				endm 
# End of macro CWHEAD
b715			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b715					if DEBUG_FORTH_WORDS_KEY 
b715						DMARK "MAX" 
b715 f5				push af  
b716 3a 2a b7			ld a, (.dmark)  
b719 32 71 ee			ld (debug_mark),a  
b71c 3a 2b b7			ld a, (.dmark+1)  
b71f 32 72 ee			ld (debug_mark+1),a  
b722 3a 2c b7			ld a, (.dmark+2)  
b725 32 73 ee			ld (debug_mark+2),a  
b728 18 03			jr .pastdmark  
b72a ..			.dmark: db "MAX"  
b72d f1			.pastdmark: pop af  
b72e			endm  
# End of macro DMARK
b72e						CALLMONITOR 
b72e cd dd 94			call break_point_state  
b731				endm  
# End of macro CALLMONITOR
b731					endif 
b731					; get u2 
b731			 
b731					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b731 cd 4a 9d			call macro_dsp_valuehl 
b734				endm 
# End of macro FORTH_DSP_VALUEHL
b734			 
b734 e5					push hl   ; u2 
b735			 
b735					; destroy value TOS 
b735			 
b735					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b735 cd 02 9e			call macro_forth_dsp_pop 
b738				endm 
# End of macro FORTH_DSP_POP
b738			 
b738					; get u1 
b738			 
b738					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b738 cd 4a 9d			call macro_dsp_valuehl 
b73b				endm 
# End of macro FORTH_DSP_VALUEHL
b73b			 
b73b e5					push hl  ; u1 
b73c			 
b73c					; destroy value TOS 
b73c			 
b73c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b73c cd 02 9e			call macro_forth_dsp_pop 
b73f				endm 
# End of macro FORTH_DSP_POP
b73f			 
b73f b7			 or a      ;clear carry flag 
b740 e1			  pop hl    ; u1 
b741 d1			  pop de    ; u2 
b742 e5				push hl   ; saved in case hl is lowest 
b743 ed 52		  sbc hl,de 
b745 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b747			 
b747 e1				pop hl 
b748					if DEBUG_FORTH_WORDS 
b748						DMARK "MAX" 
b748 f5				push af  
b749 3a 5d b7			ld a, (.dmark)  
b74c 32 71 ee			ld (debug_mark),a  
b74f 3a 5e b7			ld a, (.dmark+1)  
b752 32 72 ee			ld (debug_mark+1),a  
b755 3a 5f b7			ld a, (.dmark+2)  
b758 32 73 ee			ld (debug_mark+2),a  
b75b 18 03			jr .pastdmark  
b75d ..			.dmark: db "MAX"  
b760 f1			.pastdmark: pop af  
b761			endm  
# End of macro DMARK
b761						CALLMONITOR 
b761 cd dd 94			call break_point_state  
b764				endm  
# End of macro CALLMONITOR
b764					endif 
b764 cd 53 9b				call forth_push_numhl 
b767			 
b767				       NEXTW 
b767 c3 00 9f			jp macro_next 
b76a				endm 
# End of macro NEXTW
b76a			 
b76a			.maxcont:  
b76a c1				pop bc   ; tidy up 
b76b eb				ex de , hl  
b76c					if DEBUG_FORTH_WORDS 
b76c						DMARK "MA1" 
b76c f5				push af  
b76d 3a 81 b7			ld a, (.dmark)  
b770 32 71 ee			ld (debug_mark),a  
b773 3a 82 b7			ld a, (.dmark+1)  
b776 32 72 ee			ld (debug_mark+1),a  
b779 3a 83 b7			ld a, (.dmark+2)  
b77c 32 73 ee			ld (debug_mark+2),a  
b77f 18 03			jr .pastdmark  
b781 ..			.dmark: db "MA1"  
b784 f1			.pastdmark: pop af  
b785			endm  
# End of macro DMARK
b785						CALLMONITOR 
b785 cd dd 94			call break_point_state  
b788				endm  
# End of macro CALLMONITOR
b788					endif 
b788 cd 53 9b				call forth_push_numhl 
b78b				       NEXTW 
b78b c3 00 9f			jp macro_next 
b78e				endm 
# End of macro NEXTW
b78e			 
b78e			.RND16: 
b78e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b78e 4e				db WORD_SYS_CORE+58             
b78f bd b7			dw .RND8            
b791 06				db 5 + 1 
b792 .. 00			db "RND16",0              
b798				endm 
# End of macro CWHEAD
b798			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b798					if DEBUG_FORTH_WORDS_KEY 
b798						DMARK "R16" 
b798 f5				push af  
b799 3a ad b7			ld a, (.dmark)  
b79c 32 71 ee			ld (debug_mark),a  
b79f 3a ae b7			ld a, (.dmark+1)  
b7a2 32 72 ee			ld (debug_mark+1),a  
b7a5 3a af b7			ld a, (.dmark+2)  
b7a8 32 73 ee			ld (debug_mark+2),a  
b7ab 18 03			jr .pastdmark  
b7ad ..			.dmark: db "R16"  
b7b0 f1			.pastdmark: pop af  
b7b1			endm  
# End of macro DMARK
b7b1						CALLMONITOR 
b7b1 cd dd 94			call break_point_state  
b7b4				endm  
# End of macro CALLMONITOR
b7b4					endif 
b7b4 cd 03 8c				call prng16  
b7b7 cd 53 9b				call forth_push_numhl 
b7ba				       NEXTW 
b7ba c3 00 9f			jp macro_next 
b7bd				endm 
# End of macro NEXTW
b7bd			.RND8: 
b7bd				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b7bd 60				db WORD_SYS_CORE+76             
b7be f2 b7			dw .RND            
b7c0 05				db 4 + 1 
b7c1 .. 00			db "RND8",0              
b7c6				endm 
# End of macro CWHEAD
b7c6			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b7c6					if DEBUG_FORTH_WORDS_KEY 
b7c6						DMARK "RN8" 
b7c6 f5				push af  
b7c7 3a db b7			ld a, (.dmark)  
b7ca 32 71 ee			ld (debug_mark),a  
b7cd 3a dc b7			ld a, (.dmark+1)  
b7d0 32 72 ee			ld (debug_mark+1),a  
b7d3 3a dd b7			ld a, (.dmark+2)  
b7d6 32 73 ee			ld (debug_mark+2),a  
b7d9 18 03			jr .pastdmark  
b7db ..			.dmark: db "RN8"  
b7de f1			.pastdmark: pop af  
b7df			endm  
# End of macro DMARK
b7df						CALLMONITOR 
b7df cd dd 94			call break_point_state  
b7e2				endm  
# End of macro CALLMONITOR
b7e2					endif 
b7e2 2a af eb				ld hl,(xrandc) 
b7e5 23					inc hl 
b7e6 cd 1d 8c				call xrnd 
b7e9 6f					ld l,a	 
b7ea 26 00				ld h,0 
b7ec cd 53 9b				call forth_push_numhl 
b7ef				       NEXTW 
b7ef c3 00 9f			jp macro_next 
b7f2				endm 
# End of macro NEXTW
b7f2			.RND: 
b7f2				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b7f2 60				db WORD_SYS_CORE+76             
b7f3 f8 b8			dw .ENDMATHS            
b7f5 04				db 3 + 1 
b7f6 .. 00			db "RND",0              
b7fa				endm 
# End of macro CWHEAD
b7fa			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b7fa			 
b7fa					if DEBUG_FORTH_WORDS_KEY 
b7fa						DMARK "RND" 
b7fa f5				push af  
b7fb 3a 0f b8			ld a, (.dmark)  
b7fe 32 71 ee			ld (debug_mark),a  
b801 3a 10 b8			ld a, (.dmark+1)  
b804 32 72 ee			ld (debug_mark+1),a  
b807 3a 11 b8			ld a, (.dmark+2)  
b80a 32 73 ee			ld (debug_mark+2),a  
b80d 18 03			jr .pastdmark  
b80f ..			.dmark: db "RND"  
b812 f1			.pastdmark: pop af  
b813			endm  
# End of macro DMARK
b813						CALLMONITOR 
b813 cd dd 94			call break_point_state  
b816				endm  
# End of macro CALLMONITOR
b816					endif 
b816					 
b816					FORTH_DSP_VALUEHL    ; upper range 
b816 cd 4a 9d			call macro_dsp_valuehl 
b819				endm 
# End of macro FORTH_DSP_VALUEHL
b819			 
b819 22 b3 eb				ld (LFSRSeed), hl	 
b81c			 
b81c					if DEBUG_FORTH_WORDS 
b81c						DMARK "RN1" 
b81c f5				push af  
b81d 3a 31 b8			ld a, (.dmark)  
b820 32 71 ee			ld (debug_mark),a  
b823 3a 32 b8			ld a, (.dmark+1)  
b826 32 72 ee			ld (debug_mark+1),a  
b829 3a 33 b8			ld a, (.dmark+2)  
b82c 32 73 ee			ld (debug_mark+2),a  
b82f 18 03			jr .pastdmark  
b831 ..			.dmark: db "RN1"  
b834 f1			.pastdmark: pop af  
b835			endm  
# End of macro DMARK
b835						CALLMONITOR 
b835 cd dd 94			call break_point_state  
b838				endm  
# End of macro CALLMONITOR
b838					endif 
b838					FORTH_DSP_POP 
b838 cd 02 9e			call macro_forth_dsp_pop 
b83b				endm 
# End of macro FORTH_DSP_POP
b83b			 
b83b					FORTH_DSP_VALUEHL    ; low range 
b83b cd 4a 9d			call macro_dsp_valuehl 
b83e				endm 
# End of macro FORTH_DSP_VALUEHL
b83e			 
b83e					if DEBUG_FORTH_WORDS 
b83e						DMARK "RN2" 
b83e f5				push af  
b83f 3a 53 b8			ld a, (.dmark)  
b842 32 71 ee			ld (debug_mark),a  
b845 3a 54 b8			ld a, (.dmark+1)  
b848 32 72 ee			ld (debug_mark+1),a  
b84b 3a 55 b8			ld a, (.dmark+2)  
b84e 32 73 ee			ld (debug_mark+2),a  
b851 18 03			jr .pastdmark  
b853 ..			.dmark: db "RN2"  
b856 f1			.pastdmark: pop af  
b857			endm  
# End of macro DMARK
b857						CALLMONITOR 
b857 cd dd 94			call break_point_state  
b85a				endm  
# End of macro CALLMONITOR
b85a					endif 
b85a 22 b5 eb				ld (LFSRSeed+2), hl 
b85d			 
b85d					FORTH_DSP_POP 
b85d cd 02 9e			call macro_forth_dsp_pop 
b860				endm 
# End of macro FORTH_DSP_POP
b860			 
b860 e5					push hl 
b861			 
b861 e1			.inrange:	pop hl 
b862 cd 03 8c				call prng16  
b865					if DEBUG_FORTH_WORDS 
b865						DMARK "RN3" 
b865 f5				push af  
b866 3a 7a b8			ld a, (.dmark)  
b869 32 71 ee			ld (debug_mark),a  
b86c 3a 7b b8			ld a, (.dmark+1)  
b86f 32 72 ee			ld (debug_mark+1),a  
b872 3a 7c b8			ld a, (.dmark+2)  
b875 32 73 ee			ld (debug_mark+2),a  
b878 18 03			jr .pastdmark  
b87a ..			.dmark: db "RN3"  
b87d f1			.pastdmark: pop af  
b87e			endm  
# End of macro DMARK
b87e						CALLMONITOR 
b87e cd dd 94			call break_point_state  
b881				endm  
# End of macro CALLMONITOR
b881					endif 
b881					 
b881					; if the range is 8bit knock out the high byte 
b881			 
b881 ed 5b b3 eb			ld de, (LFSRSeed)     ; check high level 
b885			 
b885 3e 00				ld a, 0 
b887 ba					cp d  
b888 20 1e				jr nz, .hirange 
b88a 26 00				ld h, 0   ; knock it down to 8bit 
b88c			 
b88c					if DEBUG_FORTH_WORDS 
b88c						DMARK "RNk" 
b88c f5				push af  
b88d 3a a1 b8			ld a, (.dmark)  
b890 32 71 ee			ld (debug_mark),a  
b893 3a a2 b8			ld a, (.dmark+1)  
b896 32 72 ee			ld (debug_mark+1),a  
b899 3a a3 b8			ld a, (.dmark+2)  
b89c 32 73 ee			ld (debug_mark+2),a  
b89f 18 03			jr .pastdmark  
b8a1 ..			.dmark: db "RNk"  
b8a4 f1			.pastdmark: pop af  
b8a5			endm  
# End of macro DMARK
b8a5						CALLMONITOR 
b8a5 cd dd 94			call break_point_state  
b8a8				endm  
# End of macro CALLMONITOR
b8a8					endif 
b8a8			.hirange:   
b8a8 e5					push hl  
b8a9 b7					or a  
b8aa ed 52		                sbc hl, de 
b8ac			 
b8ac					;call cmp16 
b8ac			 
b8ac 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8ae e1					pop hl 
b8af e5					push hl 
b8b0			 
b8b0					if DEBUG_FORTH_WORDS 
b8b0						DMARK "RN4" 
b8b0 f5				push af  
b8b1 3a c5 b8			ld a, (.dmark)  
b8b4 32 71 ee			ld (debug_mark),a  
b8b7 3a c6 b8			ld a, (.dmark+1)  
b8ba 32 72 ee			ld (debug_mark+1),a  
b8bd 3a c7 b8			ld a, (.dmark+2)  
b8c0 32 73 ee			ld (debug_mark+2),a  
b8c3 18 03			jr .pastdmark  
b8c5 ..			.dmark: db "RN4"  
b8c8 f1			.pastdmark: pop af  
b8c9			endm  
# End of macro DMARK
b8c9						CALLMONITOR 
b8c9 cd dd 94			call break_point_state  
b8cc				endm  
# End of macro CALLMONITOR
b8cc					endif 
b8cc ed 5b b5 eb			ld de, (LFSRSeed+2)   ; check low range 
b8d0					;call cmp16 
b8d0				 
b8d0 b7					or a  
b8d1 ed 52		                sbc hl, de 
b8d3 38 8c				jr c, .inrange 
b8d5			 
b8d5 e1					pop hl 
b8d6					 
b8d6					if DEBUG_FORTH_WORDS 
b8d6						DMARK "RNd" 
b8d6 f5				push af  
b8d7 3a eb b8			ld a, (.dmark)  
b8da 32 71 ee			ld (debug_mark),a  
b8dd 3a ec b8			ld a, (.dmark+1)  
b8e0 32 72 ee			ld (debug_mark+1),a  
b8e3 3a ed b8			ld a, (.dmark+2)  
b8e6 32 73 ee			ld (debug_mark+2),a  
b8e9 18 03			jr .pastdmark  
b8eb ..			.dmark: db "RNd"  
b8ee f1			.pastdmark: pop af  
b8ef			endm  
# End of macro DMARK
b8ef						CALLMONITOR 
b8ef cd dd 94			call break_point_state  
b8f2				endm  
# End of macro CALLMONITOR
b8f2					endif 
b8f2			 
b8f2			 
b8f2 cd 53 9b				call forth_push_numhl 
b8f5				       NEXTW 
b8f5 c3 00 9f			jp macro_next 
b8f8				endm 
# End of macro NEXTW
b8f8			 
b8f8			.ENDMATHS: 
b8f8			 
b8f8			; eof 
b8f8			 
# End of file forth_words_maths.asm
b8f8			include "forth_words_display.asm" 
b8f8			 
b8f8			; | ## Display Words 
b8f8			 
b8f8			.ACT: 
b8f8			 
b8f8				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b8f8 62				db WORD_SYS_CORE+78             
b8f9 44 b9			dw .INFO            
b8fb 07				db 6 + 1 
b8fc .. 00			db "ACTIVE",0              
b903				endm 
# End of macro CWHEAD
b903			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b903			;  
b903			; | | e.g. $ff $00 do active . $01 pause loop 
b903			 
b903					if DEBUG_FORTH_WORDS_KEY 
b903						DMARK "ACT" 
b903 f5				push af  
b904 3a 18 b9			ld a, (.dmark)  
b907 32 71 ee			ld (debug_mark),a  
b90a 3a 19 b9			ld a, (.dmark+1)  
b90d 32 72 ee			ld (debug_mark+1),a  
b910 3a 1a b9			ld a, (.dmark+2)  
b913 32 73 ee			ld (debug_mark+2),a  
b916 18 03			jr .pastdmark  
b918 ..			.dmark: db "ACT"  
b91b f1			.pastdmark: pop af  
b91c			endm  
# End of macro DMARK
b91c						CALLMONITOR 
b91c cd dd 94			call break_point_state  
b91f				endm  
# End of macro CALLMONITOR
b91f					endif 
b91f cd 06 8a				call active 
b922					if DEBUG_FORTH_WORDS 
b922						DMARK "ACp" 
b922 f5				push af  
b923 3a 37 b9			ld a, (.dmark)  
b926 32 71 ee			ld (debug_mark),a  
b929 3a 38 b9			ld a, (.dmark+1)  
b92c 32 72 ee			ld (debug_mark+1),a  
b92f 3a 39 b9			ld a, (.dmark+2)  
b932 32 73 ee			ld (debug_mark+2),a  
b935 18 03			jr .pastdmark  
b937 ..			.dmark: db "ACp"  
b93a f1			.pastdmark: pop af  
b93b			endm  
# End of macro DMARK
b93b						CALLMONITOR 
b93b cd dd 94			call break_point_state  
b93e				endm  
# End of macro CALLMONITOR
b93e					endif 
b93e cd c1 9b				call forth_push_str 
b941			 
b941					NEXTW 
b941 c3 00 9f			jp macro_next 
b944				endm 
# End of macro NEXTW
b944			.INFO: 
b944			 
b944				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b944 62				db WORD_SYS_CORE+78             
b945 61 b9			dw .ATP            
b947 05				db 4 + 1 
b948 .. 00			db "INFO",0              
b94d				endm 
# End of macro CWHEAD
b94d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b94d					FORTH_DSP_VALUEHL 
b94d cd 4a 9d			call macro_dsp_valuehl 
b950				endm 
# End of macro FORTH_DSP_VALUEHL
b950			 
b950					FORTH_DSP_POP 
b950 cd 02 9e			call macro_forth_dsp_pop 
b953				endm 
# End of macro FORTH_DSP_POP
b953			 
b953 e5					push hl 
b954			 
b954					FORTH_DSP_VALUEHL 
b954 cd 4a 9d			call macro_dsp_valuehl 
b957				endm 
# End of macro FORTH_DSP_VALUEHL
b957			 
b957					FORTH_DSP_POP 
b957 cd 02 9e			call macro_forth_dsp_pop 
b95a				endm 
# End of macro FORTH_DSP_POP
b95a			 
b95a d1					pop de 
b95b			 
b95b cd 40 8a				call info_panel 
b95e			 
b95e			 
b95e					NEXTW 
b95e c3 00 9f			jp macro_next 
b961				endm 
# End of macro NEXTW
b961			.ATP: 
b961				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b961 62				db WORD_SYS_CORE+78             
b962 d8 b9			dw .FB            
b964 04				db 3 + 1 
b965 .. 00			db "AT?",0              
b969				endm 
# End of macro CWHEAD
b969			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b969					if DEBUG_FORTH_WORDS_KEY 
b969						DMARK "AT?" 
b969 f5				push af  
b96a 3a 7e b9			ld a, (.dmark)  
b96d 32 71 ee			ld (debug_mark),a  
b970 3a 7f b9			ld a, (.dmark+1)  
b973 32 72 ee			ld (debug_mark+1),a  
b976 3a 80 b9			ld a, (.dmark+2)  
b979 32 73 ee			ld (debug_mark+2),a  
b97c 18 03			jr .pastdmark  
b97e ..			.dmark: db "AT?"  
b981 f1			.pastdmark: pop af  
b982			endm  
# End of macro DMARK
b982						CALLMONITOR 
b982 cd dd 94			call break_point_state  
b985				endm  
# End of macro CALLMONITOR
b985					endif 
b985 3a 64 ea				ld a, (f_cursor_ptr) 
b988			 
b988			if DEBUG_FORTH_WORDS 
b988				DMARK "AT?" 
b988 f5				push af  
b989 3a 9d b9			ld a, (.dmark)  
b98c 32 71 ee			ld (debug_mark),a  
b98f 3a 9e b9			ld a, (.dmark+1)  
b992 32 72 ee			ld (debug_mark+1),a  
b995 3a 9f b9			ld a, (.dmark+2)  
b998 32 73 ee			ld (debug_mark+2),a  
b99b 18 03			jr .pastdmark  
b99d ..			.dmark: db "AT?"  
b9a0 f1			.pastdmark: pop af  
b9a1			endm  
# End of macro DMARK
b9a1				CALLMONITOR 
b9a1 cd dd 94			call break_point_state  
b9a4				endm  
# End of macro CALLMONITOR
b9a4			endif	 
b9a4					; count the number of rows 
b9a4			 
b9a4 06 00				ld b, 0 
b9a6 4f			.atpr:		ld c, a    ; save in case we go below zero 
b9a7 d6 28				sub display_cols 
b9a9 f2 af b9				jp p, .atprunder 
b9ac 04					inc b 
b9ad 18 f7				jr .atpr 
b9af			.atprunder:	 
b9af			if DEBUG_FORTH_WORDS 
b9af				DMARK "A?2" 
b9af f5				push af  
b9b0 3a c4 b9			ld a, (.dmark)  
b9b3 32 71 ee			ld (debug_mark),a  
b9b6 3a c5 b9			ld a, (.dmark+1)  
b9b9 32 72 ee			ld (debug_mark+1),a  
b9bc 3a c6 b9			ld a, (.dmark+2)  
b9bf 32 73 ee			ld (debug_mark+2),a  
b9c2 18 03			jr .pastdmark  
b9c4 ..			.dmark: db "A?2"  
b9c7 f1			.pastdmark: pop af  
b9c8			endm  
# End of macro DMARK
b9c8				CALLMONITOR 
b9c8 cd dd 94			call break_point_state  
b9cb				endm  
# End of macro CALLMONITOR
b9cb			endif	 
b9cb 26 00				ld h, 0 
b9cd 69					ld l, c 
b9ce cd 53 9b				call forth_push_numhl 
b9d1 68					ld l, b  
b9d2 cd 53 9b				call forth_push_numhl 
b9d5			 
b9d5			 
b9d5				NEXTW 
b9d5 c3 00 9f			jp macro_next 
b9d8				endm 
# End of macro NEXTW
b9d8			 
b9d8			.FB: 
b9d8				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b9d8 1b				db WORD_SYS_CORE+7             
b9d9 26 ba			dw .EMIT            
b9db 03				db 2 + 1 
b9dc .. 00			db "FB",0              
b9df				endm 
# End of macro CWHEAD
b9df			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b9df			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b9df			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b9df			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b9df					if DEBUG_FORTH_WORDS_KEY 
b9df						DMARK "FB." 
b9df f5				push af  
b9e0 3a f4 b9			ld a, (.dmark)  
b9e3 32 71 ee			ld (debug_mark),a  
b9e6 3a f5 b9			ld a, (.dmark+1)  
b9e9 32 72 ee			ld (debug_mark+1),a  
b9ec 3a f6 b9			ld a, (.dmark+2)  
b9ef 32 73 ee			ld (debug_mark+2),a  
b9f2 18 03			jr .pastdmark  
b9f4 ..			.dmark: db "FB."  
b9f7 f1			.pastdmark: pop af  
b9f8			endm  
# End of macro DMARK
b9f8						CALLMONITOR 
b9f8 cd dd 94			call break_point_state  
b9fb				endm  
# End of macro CALLMONITOR
b9fb					endif 
b9fb			 
b9fb					FORTH_DSP_VALUEHL 
b9fb cd 4a 9d			call macro_dsp_valuehl 
b9fe				endm 
# End of macro FORTH_DSP_VALUEHL
b9fe			 
b9fe 7d					ld a, l 
b9ff fe 01				cp 1 
ba01 20 05				jr nz, .fbn1 
ba03 21 16 ed				ld hl, display_fb1 
ba06 18 15				jr .fbset 
ba08 fe 02		.fbn1:		cp 2 
ba0a 20 05				jr nz, .fbn2 
ba0c 21 d4 eb				ld hl, display_fb2 
ba0f 18 0c				jr .fbset 
ba11 fe 03		.fbn2:		cp 3 
ba13 20 05				jr nz, .fbn3 
ba15 21 75 ec				ld hl, display_fb3 
ba18 18 03				jr .fbset 
ba1a			.fbn3:		 ; if invalid number select first 
ba1a 21 16 ed				ld hl, display_fb1 
ba1d 22 d2 eb		.fbset:		ld (display_fb_active), hl 
ba20			 
ba20					FORTH_DSP_POP 
ba20 cd 02 9e			call macro_forth_dsp_pop 
ba23				endm 
# End of macro FORTH_DSP_POP
ba23			 
ba23					NEXTW 
ba23 c3 00 9f			jp macro_next 
ba26				endm 
# End of macro NEXTW
ba26			 
ba26			 
ba26			.EMIT: 
ba26				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba26 1b				db WORD_SYS_CORE+7             
ba27 77 ba			dw .DOTH            
ba29 05				db 4 + 1 
ba2a .. 00			db "EMIT",0              
ba2f				endm 
# End of macro CWHEAD
ba2f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba2f					; get value off TOS and display it 
ba2f			 
ba2f					if DEBUG_FORTH_WORDS_KEY 
ba2f						DMARK "EMT" 
ba2f f5				push af  
ba30 3a 44 ba			ld a, (.dmark)  
ba33 32 71 ee			ld (debug_mark),a  
ba36 3a 45 ba			ld a, (.dmark+1)  
ba39 32 72 ee			ld (debug_mark+1),a  
ba3c 3a 46 ba			ld a, (.dmark+2)  
ba3f 32 73 ee			ld (debug_mark+2),a  
ba42 18 03			jr .pastdmark  
ba44 ..			.dmark: db "EMT"  
ba47 f1			.pastdmark: pop af  
ba48			endm  
# End of macro DMARK
ba48						CALLMONITOR 
ba48 cd dd 94			call break_point_state  
ba4b				endm  
# End of macro CALLMONITOR
ba4b					endif 
ba4b			 
ba4b					FORTH_DSP_VALUEHL 
ba4b cd 4a 9d			call macro_dsp_valuehl 
ba4e				endm 
# End of macro FORTH_DSP_VALUEHL
ba4e			 
ba4e 7d					ld a,l 
ba4f			 
ba4f					; TODO write to display 
ba4f			 
ba4f 32 c5 e4				ld (os_input), a 
ba52 3e 00				ld a, 0 
ba54 32 c6 e4				ld (os_input+1), a 
ba57					 
ba57 3a 64 ea				ld a, (f_cursor_ptr) 
ba5a 11 c5 e4				ld de, os_input 
ba5d cd c2 8a				call str_at_display 
ba60			 
ba60			 
ba60 3a 42 ea				ld a,(cli_autodisplay) 
ba63 fe 00				cp 0 
ba65 28 03				jr z, .enoupdate 
ba67 cd d2 8a						call update_display 
ba6a					.enoupdate: 
ba6a			 
ba6a 3a 64 ea				ld a, (f_cursor_ptr) 
ba6d 3c					inc a 
ba6e 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
ba71			 
ba71			 
ba71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba71 cd 02 9e			call macro_forth_dsp_pop 
ba74				endm 
# End of macro FORTH_DSP_POP
ba74			  
ba74			 
ba74					NEXTW 
ba74 c3 00 9f			jp macro_next 
ba77				endm 
# End of macro NEXTW
ba77			.DOTH: 
ba77				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
ba77 1c				db WORD_SYS_CORE+8             
ba78 a7 ba			dw .DOTF            
ba7a 03				db 2 + 1 
ba7b .. 00			db ".-",0              
ba7e				endm 
# End of macro CWHEAD
ba7e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
ba7e					; get value off TOS and display it 
ba7e					if DEBUG_FORTH_WORDS_KEY 
ba7e						DMARK "DTD" 
ba7e f5				push af  
ba7f 3a 93 ba			ld a, (.dmark)  
ba82 32 71 ee			ld (debug_mark),a  
ba85 3a 94 ba			ld a, (.dmark+1)  
ba88 32 72 ee			ld (debug_mark+1),a  
ba8b 3a 95 ba			ld a, (.dmark+2)  
ba8e 32 73 ee			ld (debug_mark+2),a  
ba91 18 03			jr .pastdmark  
ba93 ..			.dmark: db "DTD"  
ba96 f1			.pastdmark: pop af  
ba97			endm  
# End of macro DMARK
ba97						CALLMONITOR 
ba97 cd dd 94			call break_point_state  
ba9a				endm  
# End of macro CALLMONITOR
ba9a					endif 
ba9a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
ba9c 3e 00			ld a, 0 
ba9e 32 43 ea			ld (cli_mvdot), a 
baa1 c3 fe ba			jp .dotgo 
baa4				NEXTW 
baa4 c3 00 9f			jp macro_next 
baa7				endm 
# End of macro NEXTW
baa7			.DOTF: 
baa7				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
baa7 1c				db WORD_SYS_CORE+8             
baa8 d5 ba			dw .DOT            
baaa 03				db 2 + 1 
baab .. 00			db ".>",0              
baae				endm 
# End of macro CWHEAD
baae			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
baae					; get value off TOS and display it 
baae			        ; TODO BUG adds extra spaces 
baae			        ; TODO BUG handle numerics? 
baae					if DEBUG_FORTH_WORDS_KEY 
baae						DMARK "DTC" 
baae f5				push af  
baaf 3a c3 ba			ld a, (.dmark)  
bab2 32 71 ee			ld (debug_mark),a  
bab5 3a c4 ba			ld a, (.dmark+1)  
bab8 32 72 ee			ld (debug_mark+1),a  
babb 3a c5 ba			ld a, (.dmark+2)  
babe 32 73 ee			ld (debug_mark+2),a  
bac1 18 03			jr .pastdmark  
bac3 ..			.dmark: db "DTC"  
bac6 f1			.pastdmark: pop af  
bac7			endm  
# End of macro DMARK
bac7						CALLMONITOR 
bac7 cd dd 94			call break_point_state  
baca				endm  
# End of macro CALLMONITOR
baca					endif 
baca 3e 01			ld a, 1 
bacc 32 43 ea			ld (cli_mvdot), a 
bacf c3 fe ba			jp .dotgo 
bad2				NEXTW 
bad2 c3 00 9f			jp macro_next 
bad5				endm 
# End of macro NEXTW
bad5			 
bad5			.DOT: 
bad5				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bad5 1c				db WORD_SYS_CORE+8             
bad6 b1 bc			dw .CLS            
bad8 02				db 1 + 1 
bad9 .. 00			db ".",0              
badb				endm 
# End of macro CWHEAD
badb			        ; | . ( u -- ) Display TOS | DONE 
badb					; get value off TOS and display it 
badb			 
badb					if DEBUG_FORTH_WORDS_KEY 
badb						DMARK "DOT" 
badb f5				push af  
badc 3a f0 ba			ld a, (.dmark)  
badf 32 71 ee			ld (debug_mark),a  
bae2 3a f1 ba			ld a, (.dmark+1)  
bae5 32 72 ee			ld (debug_mark+1),a  
bae8 3a f2 ba			ld a, (.dmark+2)  
baeb 32 73 ee			ld (debug_mark+2),a  
baee 18 03			jr .pastdmark  
baf0 ..			.dmark: db "DOT"  
baf3 f1			.pastdmark: pop af  
baf4			endm  
# End of macro DMARK
baf4						CALLMONITOR 
baf4 cd dd 94			call break_point_state  
baf7				endm  
# End of macro CALLMONITOR
baf7					endif 
baf7 3e 00			ld a, 0 
baf9 32 43 ea			ld (cli_mvdot), a 
bafc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bafe				 
bafe			 
bafe			.dotgo: 
bafe			 
bafe			; move up type to on stack for parserv5 
bafe					FORTH_DSP 
bafe cd 10 9d			call macro_forth_dsp 
bb01				endm 
# End of macro FORTH_DSP
bb01				;FORTH_DSP_VALUE  
bb01			 
bb01			if DEBUG_FORTH_DOT 
bb01				DMARK "DOT" 
bb01 f5				push af  
bb02 3a 16 bb			ld a, (.dmark)  
bb05 32 71 ee			ld (debug_mark),a  
bb08 3a 17 bb			ld a, (.dmark+1)  
bb0b 32 72 ee			ld (debug_mark+1),a  
bb0e 3a 18 bb			ld a, (.dmark+2)  
bb11 32 73 ee			ld (debug_mark+2),a  
bb14 18 03			jr .pastdmark  
bb16 ..			.dmark: db "DOT"  
bb19 f1			.pastdmark: pop af  
bb1a			endm  
# End of macro DMARK
bb1a				CALLMONITOR 
bb1a cd dd 94			call break_point_state  
bb1d				endm  
# End of macro CALLMONITOR
bb1d			endif	 
bb1d			;		.print: 
bb1d			 
bb1d 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb1e 23				inc hl   ; position to the actual value 
bb1f fe 01			cp DS_TYPE_STR 
bb21 20 06			jr nz, .dotnum1  
bb23			 
bb23			; display string 
bb23				FORTH_DSP_VALUE  
bb23 cd 33 9d			call macro_forth_dsp_value 
bb26				endm 
# End of macro FORTH_DSP_VALUE
bb26 eb				ex de,hl 
bb27 18 49			jr .dotwrite 
bb29			 
bb29			.dotnum1: 
bb29 fe 02			cp DS_TYPE_INUM 
bb2b 20 44			jr nz, .dotflot 
bb2d			 
bb2d			 
bb2d			; display number 
bb2d			 
bb2d			;	push hl 
bb2d			;	call clear_display 
bb2d			;	pop hl 
bb2d			 
bb2d 5e				ld e, (hl) 
bb2e 23				inc hl 
bb2f 56				ld d, (hl) 
bb30 21 c7 e2			ld hl, scratch 
bb33			if DEBUG_FORTH_DOT 
bb33				DMARK "DT1" 
bb33 f5				push af  
bb34 3a 48 bb			ld a, (.dmark)  
bb37 32 71 ee			ld (debug_mark),a  
bb3a 3a 49 bb			ld a, (.dmark+1)  
bb3d 32 72 ee			ld (debug_mark+1),a  
bb40 3a 4a bb			ld a, (.dmark+2)  
bb43 32 73 ee			ld (debug_mark+2),a  
bb46 18 03			jr .pastdmark  
bb48 ..			.dmark: db "DT1"  
bb4b f1			.pastdmark: pop af  
bb4c			endm  
# End of macro DMARK
bb4c				CALLMONITOR 
bb4c cd dd 94			call break_point_state  
bb4f				endm  
# End of macro CALLMONITOR
bb4f			endif	 
bb4f			 
bb4f cd e9 90			call uitoa_16 
bb52 eb				ex de,hl 
bb53			 
bb53			if DEBUG_FORTH_DOT 
bb53				DMARK "DT2" 
bb53 f5				push af  
bb54 3a 68 bb			ld a, (.dmark)  
bb57 32 71 ee			ld (debug_mark),a  
bb5a 3a 69 bb			ld a, (.dmark+1)  
bb5d 32 72 ee			ld (debug_mark+1),a  
bb60 3a 6a bb			ld a, (.dmark+2)  
bb63 32 73 ee			ld (debug_mark+2),a  
bb66 18 03			jr .pastdmark  
bb68 ..			.dmark: db "DT2"  
bb6b f1			.pastdmark: pop af  
bb6c			endm  
# End of macro DMARK
bb6c				CALLMONITOR 
bb6c cd dd 94			call break_point_state  
bb6f				endm  
# End of macro CALLMONITOR
bb6f			endif	 
bb6f			 
bb6f			;	ld de, os_word_scratch 
bb6f 18 01			jr .dotwrite 
bb71			 
bb71 00			.dotflot:   nop 
bb72			; TODO print floating point number 
bb72			 
bb72			.dotwrite:		 
bb72			 
bb72					; if c is set then set all '-' to spaces 
bb72					; need to also take into account .>  
bb72			 
bb72 3e 01				ld a, 1 
bb74 b9					cp c 
bb75 20 67				jr nz, .nodashswap 
bb77			 
bb77					; DE has the string to write, working with HL 
bb77			 
bb77 06 ff				ld b, 255 
bb79 d5					push de 
bb7a e1					pop hl 
bb7b			 
bb7b			if DEBUG_FORTH_DOT 
bb7b				DMARK "DT-" 
bb7b f5				push af  
bb7c 3a 90 bb			ld a, (.dmark)  
bb7f 32 71 ee			ld (debug_mark),a  
bb82 3a 91 bb			ld a, (.dmark+1)  
bb85 32 72 ee			ld (debug_mark+1),a  
bb88 3a 92 bb			ld a, (.dmark+2)  
bb8b 32 73 ee			ld (debug_mark+2),a  
bb8e 18 03			jr .pastdmark  
bb90 ..			.dmark: db "DT-"  
bb93 f1			.pastdmark: pop af  
bb94			endm  
# End of macro DMARK
bb94				CALLMONITOR 
bb94 cd dd 94			call break_point_state  
bb97				endm  
# End of macro CALLMONITOR
bb97			endif	 
bb97 7e			.dashscan:	ld a, (hl) 
bb98 fe 00				cp 0 
bb9a 28 42				jr z, .nodashswap 
bb9c fe 2d				cp '-' 
bb9e 20 03				jr nz, .dashskip 
bba0 3e 20				ld a, ' ' 
bba2 77					ld (hl), a 
bba3 23			.dashskip:	inc hl 
bba4			if DEBUG_FORTH_DOT 
bba4				DMARK "D-2" 
bba4 f5				push af  
bba5 3a b9 bb			ld a, (.dmark)  
bba8 32 71 ee			ld (debug_mark),a  
bbab 3a ba bb			ld a, (.dmark+1)  
bbae 32 72 ee			ld (debug_mark+1),a  
bbb1 3a bb bb			ld a, (.dmark+2)  
bbb4 32 73 ee			ld (debug_mark+2),a  
bbb7 18 03			jr .pastdmark  
bbb9 ..			.dmark: db "D-2"  
bbbc f1			.pastdmark: pop af  
bbbd			endm  
# End of macro DMARK
bbbd				CALLMONITOR 
bbbd cd dd 94			call break_point_state  
bbc0				endm  
# End of macro CALLMONITOR
bbc0			endif	 
bbc0 10 d5				djnz .dashscan 
bbc2			 
bbc2			if DEBUG_FORTH_DOT 
bbc2				DMARK "D-1" 
bbc2 f5				push af  
bbc3 3a d7 bb			ld a, (.dmark)  
bbc6 32 71 ee			ld (debug_mark),a  
bbc9 3a d8 bb			ld a, (.dmark+1)  
bbcc 32 72 ee			ld (debug_mark+1),a  
bbcf 3a d9 bb			ld a, (.dmark+2)  
bbd2 32 73 ee			ld (debug_mark+2),a  
bbd5 18 03			jr .pastdmark  
bbd7 ..			.dmark: db "D-1"  
bbda f1			.pastdmark: pop af  
bbdb			endm  
# End of macro DMARK
bbdb				CALLMONITOR 
bbdb cd dd 94			call break_point_state  
bbde				endm  
# End of macro CALLMONITOR
bbde			endif	 
bbde			 
bbde			.nodashswap: 
bbde			 
bbde			if DEBUG_FORTH_DOT 
bbde				DMARK "D-o" 
bbde f5				push af  
bbdf 3a f3 bb			ld a, (.dmark)  
bbe2 32 71 ee			ld (debug_mark),a  
bbe5 3a f4 bb			ld a, (.dmark+1)  
bbe8 32 72 ee			ld (debug_mark+1),a  
bbeb 3a f5 bb			ld a, (.dmark+2)  
bbee 32 73 ee			ld (debug_mark+2),a  
bbf1 18 03			jr .pastdmark  
bbf3 ..			.dmark: db "D-o"  
bbf6 f1			.pastdmark: pop af  
bbf7			endm  
# End of macro DMARK
bbf7				CALLMONITOR 
bbf7 cd dd 94			call break_point_state  
bbfa				endm  
# End of macro CALLMONITOR
bbfa			endif	 
bbfa			 
bbfa d5					push de   ; save string start in case we need to advance print 
bbfb			 
bbfb 3a 64 ea				ld a, (f_cursor_ptr) 
bbfe cd c2 8a				call str_at_display 
bc01 3a 42 ea				ld a,(cli_autodisplay) 
bc04 fe 00				cp 0 
bc06 28 03				jr z, .noupdate 
bc08 cd d2 8a						call update_display 
bc0b					.noupdate: 
bc0b			 
bc0b			 
bc0b					; see if we need to advance the print position 
bc0b			 
bc0b e1					pop hl   ; get back string 
bc0c			;		ex de,hl 
bc0c			 
bc0c 3a 43 ea				ld a, (cli_mvdot) 
bc0f			if DEBUG_FORTH_DOT 
bc0f			;		ld e,a 
bc0f				DMARK "D>1" 
bc0f f5				push af  
bc10 3a 24 bc			ld a, (.dmark)  
bc13 32 71 ee			ld (debug_mark),a  
bc16 3a 25 bc			ld a, (.dmark+1)  
bc19 32 72 ee			ld (debug_mark+1),a  
bc1c 3a 26 bc			ld a, (.dmark+2)  
bc1f 32 73 ee			ld (debug_mark+2),a  
bc22 18 03			jr .pastdmark  
bc24 ..			.dmark: db "D>1"  
bc27 f1			.pastdmark: pop af  
bc28			endm  
# End of macro DMARK
bc28				CALLMONITOR 
bc28 cd dd 94			call break_point_state  
bc2b				endm  
# End of macro CALLMONITOR
bc2b			endif	 
bc2b fe 00				cp 0 
bc2d 28 44				jr z, .noadv 
bc2f					; yes, lets advance the print position 
bc2f 3e 00				ld a, 0 
bc31 cd 45 91				call strlent 
bc34			if DEBUG_FORTH_DOT 
bc34				DMARK "D-?" 
bc34 f5				push af  
bc35 3a 49 bc			ld a, (.dmark)  
bc38 32 71 ee			ld (debug_mark),a  
bc3b 3a 4a bc			ld a, (.dmark+1)  
bc3e 32 72 ee			ld (debug_mark+1),a  
bc41 3a 4b bc			ld a, (.dmark+2)  
bc44 32 73 ee			ld (debug_mark+2),a  
bc47 18 03			jr .pastdmark  
bc49 ..			.dmark: db "D-?"  
bc4c f1			.pastdmark: pop af  
bc4d			endm  
# End of macro DMARK
bc4d				CALLMONITOR 
bc4d cd dd 94			call break_point_state  
bc50				endm  
# End of macro CALLMONITOR
bc50			endif	 
bc50 3a 64 ea				ld a, (f_cursor_ptr) 
bc53 85					add a,l 
bc54					;call addatohl 
bc54					;ld a, l 
bc54 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
bc57			 
bc57			if DEBUG_FORTH_DOT 
bc57				DMARK "D->" 
bc57 f5				push af  
bc58 3a 6c bc			ld a, (.dmark)  
bc5b 32 71 ee			ld (debug_mark),a  
bc5e 3a 6d bc			ld a, (.dmark+1)  
bc61 32 72 ee			ld (debug_mark+1),a  
bc64 3a 6e bc			ld a, (.dmark+2)  
bc67 32 73 ee			ld (debug_mark+2),a  
bc6a 18 03			jr .pastdmark  
bc6c ..			.dmark: db "D->"  
bc6f f1			.pastdmark: pop af  
bc70			endm  
# End of macro DMARK
bc70				CALLMONITOR 
bc70 cd dd 94			call break_point_state  
bc73				endm  
# End of macro CALLMONITOR
bc73			endif	 
bc73			 
bc73			.noadv:	 
bc73			 
bc73					if DEBUG_FORTH_DOT_WAIT 
bc73							call next_page_prompt 
bc73					endif	 
bc73			; TODO this pop off the stack causes a crash. i dont know why 
bc73			 
bc73			 
bc73			if DEBUG_FORTH_DOT 
bc73				DMARK "DTh" 
bc73 f5				push af  
bc74 3a 88 bc			ld a, (.dmark)  
bc77 32 71 ee			ld (debug_mark),a  
bc7a 3a 89 bc			ld a, (.dmark+1)  
bc7d 32 72 ee			ld (debug_mark+1),a  
bc80 3a 8a bc			ld a, (.dmark+2)  
bc83 32 73 ee			ld (debug_mark+2),a  
bc86 18 03			jr .pastdmark  
bc88 ..			.dmark: db "DTh"  
bc8b f1			.pastdmark: pop af  
bc8c			endm  
# End of macro DMARK
bc8c				CALLMONITOR 
bc8c cd dd 94			call break_point_state  
bc8f				endm  
# End of macro CALLMONITOR
bc8f			endif	 
bc8f			 
bc8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc8f cd 02 9e			call macro_forth_dsp_pop 
bc92				endm 
# End of macro FORTH_DSP_POP
bc92			 
bc92			if DEBUG_FORTH_DOT 
bc92				DMARK "DTi" 
bc92 f5				push af  
bc93 3a a7 bc			ld a, (.dmark)  
bc96 32 71 ee			ld (debug_mark),a  
bc99 3a a8 bc			ld a, (.dmark+1)  
bc9c 32 72 ee			ld (debug_mark+1),a  
bc9f 3a a9 bc			ld a, (.dmark+2)  
bca2 32 73 ee			ld (debug_mark+2),a  
bca5 18 03			jr .pastdmark  
bca7 ..			.dmark: db "DTi"  
bcaa f1			.pastdmark: pop af  
bcab			endm  
# End of macro DMARK
bcab				CALLMONITOR 
bcab cd dd 94			call break_point_state  
bcae				endm  
# End of macro CALLMONITOR
bcae			endif	 
bcae			 
bcae			 
bcae					NEXTW 
bcae c3 00 9f			jp macro_next 
bcb1				endm 
# End of macro NEXTW
bcb1			 
bcb1			.CLS: 
bcb1				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bcb1 35				db WORD_SYS_CORE+33             
bcb2 de bc			dw .DRAW            
bcb4 04				db 3 + 1 
bcb5 .. 00			db "CLS",0              
bcb9				endm 
# End of macro CWHEAD
bcb9			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bcb9					if DEBUG_FORTH_WORDS_KEY 
bcb9						DMARK "CLS" 
bcb9 f5				push af  
bcba 3a ce bc			ld a, (.dmark)  
bcbd 32 71 ee			ld (debug_mark),a  
bcc0 3a cf bc			ld a, (.dmark+1)  
bcc3 32 72 ee			ld (debug_mark+1),a  
bcc6 3a d0 bc			ld a, (.dmark+2)  
bcc9 32 73 ee			ld (debug_mark+2),a  
bccc 18 03			jr .pastdmark  
bcce ..			.dmark: db "CLS"  
bcd1 f1			.pastdmark: pop af  
bcd2			endm  
# End of macro DMARK
bcd2						CALLMONITOR 
bcd2 cd dd 94			call break_point_state  
bcd5				endm  
# End of macro CALLMONITOR
bcd5					endif 
bcd5 cd af 8a				call clear_display 
bcd8 c3 ec bd				jp .home		; and home cursor 
bcdb					NEXTW 
bcdb c3 00 9f			jp macro_next 
bcde				endm 
# End of macro NEXTW
bcde			 
bcde			.DRAW: 
bcde				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bcde 36				db WORD_SYS_CORE+34             
bcdf 09 bd			dw .DUMP            
bce1 05				db 4 + 1 
bce2 .. 00			db "DRAW",0              
bce7				endm 
# End of macro CWHEAD
bce7			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bce7					if DEBUG_FORTH_WORDS_KEY 
bce7						DMARK "DRW" 
bce7 f5				push af  
bce8 3a fc bc			ld a, (.dmark)  
bceb 32 71 ee			ld (debug_mark),a  
bcee 3a fd bc			ld a, (.dmark+1)  
bcf1 32 72 ee			ld (debug_mark+1),a  
bcf4 3a fe bc			ld a, (.dmark+2)  
bcf7 32 73 ee			ld (debug_mark+2),a  
bcfa 18 03			jr .pastdmark  
bcfc ..			.dmark: db "DRW"  
bcff f1			.pastdmark: pop af  
bd00			endm  
# End of macro DMARK
bd00						CALLMONITOR 
bd00 cd dd 94			call break_point_state  
bd03				endm  
# End of macro CALLMONITOR
bd03					endif 
bd03 cd d2 8a				call update_display 
bd06					NEXTW 
bd06 c3 00 9f			jp macro_next 
bd09				endm 
# End of macro NEXTW
bd09			 
bd09			.DUMP: 
bd09				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd09 37				db WORD_SYS_CORE+35             
bd0a 41 bd			dw .CDUMP            
bd0c 05				db 4 + 1 
bd0d .. 00			db "DUMP",0              
bd12				endm 
# End of macro CWHEAD
bd12			; | DUMP ( x -- ) With address x display dump   | DONE 
bd12			; TODO pop address to use off of the stack 
bd12					if DEBUG_FORTH_WORDS_KEY 
bd12						DMARK "DUM" 
bd12 f5				push af  
bd13 3a 27 bd			ld a, (.dmark)  
bd16 32 71 ee			ld (debug_mark),a  
bd19 3a 28 bd			ld a, (.dmark+1)  
bd1c 32 72 ee			ld (debug_mark+1),a  
bd1f 3a 29 bd			ld a, (.dmark+2)  
bd22 32 73 ee			ld (debug_mark+2),a  
bd25 18 03			jr .pastdmark  
bd27 ..			.dmark: db "DUM"  
bd2a f1			.pastdmark: pop af  
bd2b			endm  
# End of macro DMARK
bd2b						CALLMONITOR 
bd2b cd dd 94			call break_point_state  
bd2e				endm  
# End of macro CALLMONITOR
bd2e					endif 
bd2e cd af 8a				call clear_display 
bd31			 
bd31					; get address 
bd31			 
bd31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd31 cd 4a 9d			call macro_dsp_valuehl 
bd34				endm 
# End of macro FORTH_DSP_VALUEHL
bd34				 
bd34					; save it for cdump 
bd34			 
bd34 22 ea e5				ld (os_cur_ptr),hl 
bd37			 
bd37					; destroy value TOS 
bd37			 
bd37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd37 cd 02 9e			call macro_forth_dsp_pop 
bd3a				endm 
# End of macro FORTH_DSP_POP
bd3a			 
bd3a cd d3 99				call dumpcont	; skip old style of param parsing	 
bd3d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd3e					NEXTW 
bd3e c3 00 9f			jp macro_next 
bd41				endm 
# End of macro NEXTW
bd41			.CDUMP: 
bd41				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd41 38				db WORD_SYS_CORE+36             
bd42 71 bd			dw .DAT            
bd44 06				db 5 + 1 
bd45 .. 00			db "CDUMP",0              
bd4b				endm 
# End of macro CWHEAD
bd4b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd4b					if DEBUG_FORTH_WORDS_KEY 
bd4b						DMARK "CDP" 
bd4b f5				push af  
bd4c 3a 60 bd			ld a, (.dmark)  
bd4f 32 71 ee			ld (debug_mark),a  
bd52 3a 61 bd			ld a, (.dmark+1)  
bd55 32 72 ee			ld (debug_mark+1),a  
bd58 3a 62 bd			ld a, (.dmark+2)  
bd5b 32 73 ee			ld (debug_mark+2),a  
bd5e 18 03			jr .pastdmark  
bd60 ..			.dmark: db "CDP"  
bd63 f1			.pastdmark: pop af  
bd64			endm  
# End of macro DMARK
bd64						CALLMONITOR 
bd64 cd dd 94			call break_point_state  
bd67				endm  
# End of macro CALLMONITOR
bd67					endif 
bd67 cd af 8a				call clear_display 
bd6a cd d3 99				call dumpcont	 
bd6d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bd6e					NEXTW 
bd6e c3 00 9f			jp macro_next 
bd71				endm 
# End of macro NEXTW
bd71			 
bd71			 
bd71			 
bd71			 
bd71			.DAT: 
bd71				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bd71 3d				db WORD_SYS_CORE+41             
bd72 c7 bd			dw .HOME            
bd74 03				db 2 + 1 
bd75 .. 00			db "AT",0              
bd78				endm 
# End of macro CWHEAD
bd78			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bd78					if DEBUG_FORTH_WORDS_KEY 
bd78						DMARK "AT." 
bd78 f5				push af  
bd79 3a 8d bd			ld a, (.dmark)  
bd7c 32 71 ee			ld (debug_mark),a  
bd7f 3a 8e bd			ld a, (.dmark+1)  
bd82 32 72 ee			ld (debug_mark+1),a  
bd85 3a 8f bd			ld a, (.dmark+2)  
bd88 32 73 ee			ld (debug_mark+2),a  
bd8b 18 03			jr .pastdmark  
bd8d ..			.dmark: db "AT."  
bd90 f1			.pastdmark: pop af  
bd91			endm  
# End of macro DMARK
bd91						CALLMONITOR 
bd91 cd dd 94			call break_point_state  
bd94				endm  
# End of macro CALLMONITOR
bd94					endif 
bd94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd94 cd 4a 9d			call macro_dsp_valuehl 
bd97				endm 
# End of macro FORTH_DSP_VALUEHL
bd97			 
bd97			 
bd97					; TODO save cursor row 
bd97 7d					ld a,l 
bd98 fe 02				cp 2 
bd9a 20 04				jr nz, .crow3 
bd9c 3e 28				ld a, display_row_2 
bd9e 18 12				jr .ccol1 
bda0 fe 03		.crow3:		cp 3 
bda2 20 04				jr nz, .crow4 
bda4 3e 50				ld a, display_row_3 
bda6 18 0a				jr .ccol1 
bda8 fe 04		.crow4:		cp 4 
bdaa 20 04				jr nz, .crow1 
bdac 3e 78				ld a, display_row_4 
bdae 18 02				jr .ccol1 
bdb0 3e 00		.crow1:		ld a,display_row_1 
bdb2 f5			.ccol1:		push af			; got row offset 
bdb3 6f					ld l,a 
bdb4 26 00				ld h,0 
bdb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdb6 cd 02 9e			call macro_forth_dsp_pop 
bdb9				endm 
# End of macro FORTH_DSP_POP
bdb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdb9 cd 4a 9d			call macro_dsp_valuehl 
bdbc				endm 
# End of macro FORTH_DSP_VALUEHL
bdbc					; TODO save cursor col 
bdbc f1					pop af 
bdbd 85					add l		; add col offset 
bdbe 32 64 ea				ld (f_cursor_ptr), a 
bdc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdc1 cd 02 9e			call macro_forth_dsp_pop 
bdc4				endm 
# End of macro FORTH_DSP_POP
bdc4			 
bdc4					; calculate  
bdc4			 
bdc4					NEXTW 
bdc4 c3 00 9f			jp macro_next 
bdc7				endm 
# End of macro NEXTW
bdc7			 
bdc7			 
bdc7			.HOME: 
bdc7				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bdc7 41				db WORD_SYS_CORE+45             
bdc8 f4 bd			dw .SPACE            
bdca 05				db 4 + 1 
bdcb .. 00			db "HOME",0              
bdd0				endm 
# End of macro CWHEAD
bdd0			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bdd0					if DEBUG_FORTH_WORDS_KEY 
bdd0						DMARK "HOM" 
bdd0 f5				push af  
bdd1 3a e5 bd			ld a, (.dmark)  
bdd4 32 71 ee			ld (debug_mark),a  
bdd7 3a e6 bd			ld a, (.dmark+1)  
bdda 32 72 ee			ld (debug_mark+1),a  
bddd 3a e7 bd			ld a, (.dmark+2)  
bde0 32 73 ee			ld (debug_mark+2),a  
bde3 18 03			jr .pastdmark  
bde5 ..			.dmark: db "HOM"  
bde8 f1			.pastdmark: pop af  
bde9			endm  
# End of macro DMARK
bde9						CALLMONITOR 
bde9 cd dd 94			call break_point_state  
bdec				endm  
# End of macro CALLMONITOR
bdec					endif 
bdec 3e 00		.home:		ld a, 0		; and home cursor 
bdee 32 64 ea				ld (f_cursor_ptr), a 
bdf1					NEXTW 
bdf1 c3 00 9f			jp macro_next 
bdf4				endm 
# End of macro NEXTW
bdf4			 
bdf4			 
bdf4			.SPACE: 
bdf4				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bdf4 46				db WORD_SYS_CORE+50             
bdf5 2a be			dw .SPACES            
bdf7 03				db 2 + 1 
bdf8 .. 00			db "BL",0              
bdfb				endm 
# End of macro CWHEAD
bdfb			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bdfb					if DEBUG_FORTH_WORDS_KEY 
bdfb						DMARK "BL." 
bdfb f5				push af  
bdfc 3a 10 be			ld a, (.dmark)  
bdff 32 71 ee			ld (debug_mark),a  
be02 3a 11 be			ld a, (.dmark+1)  
be05 32 72 ee			ld (debug_mark+1),a  
be08 3a 12 be			ld a, (.dmark+2)  
be0b 32 73 ee			ld (debug_mark+2),a  
be0e 18 03			jr .pastdmark  
be10 ..			.dmark: db "BL."  
be13 f1			.pastdmark: pop af  
be14			endm  
# End of macro DMARK
be14						CALLMONITOR 
be14 cd dd 94			call break_point_state  
be17				endm  
# End of macro CALLMONITOR
be17					endif 
be17 3e 20				ld a, " " 
be19 32 c7 e2				ld (scratch),a 
be1c 3e 00				ld a, 0 
be1e 32 c8 e2				ld (scratch+1),a 
be21 21 c7 e2				ld hl, scratch 
be24 cd c1 9b				call forth_push_str 
be27					 
be27				       NEXTW 
be27 c3 00 9f			jp macro_next 
be2a				endm 
# End of macro NEXTW
be2a			 
be2a			;.blstr: db " ", 0 
be2a			 
be2a			.SPACES: 
be2a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be2a 47				db WORD_SYS_CORE+51             
be2b c5 be			dw .SCROLL            
be2d 07				db 6 + 1 
be2e .. 00			db "SPACES",0              
be35				endm 
# End of macro CWHEAD
be35			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be35					if DEBUG_FORTH_WORDS_KEY 
be35						DMARK "SPS" 
be35 f5				push af  
be36 3a 4a be			ld a, (.dmark)  
be39 32 71 ee			ld (debug_mark),a  
be3c 3a 4b be			ld a, (.dmark+1)  
be3f 32 72 ee			ld (debug_mark+1),a  
be42 3a 4c be			ld a, (.dmark+2)  
be45 32 73 ee			ld (debug_mark+2),a  
be48 18 03			jr .pastdmark  
be4a ..			.dmark: db "SPS"  
be4d f1			.pastdmark: pop af  
be4e			endm  
# End of macro DMARK
be4e						CALLMONITOR 
be4e cd dd 94			call break_point_state  
be51				endm  
# End of macro CALLMONITOR
be51					endif 
be51			 
be51			 
be51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be51 cd 4a 9d			call macro_dsp_valuehl 
be54				endm 
# End of macro FORTH_DSP_VALUEHL
be54			 
be54 e5					push hl    ; u 
be55					if DEBUG_FORTH_WORDS 
be55						DMARK "SPA" 
be55 f5				push af  
be56 3a 6a be			ld a, (.dmark)  
be59 32 71 ee			ld (debug_mark),a  
be5c 3a 6b be			ld a, (.dmark+1)  
be5f 32 72 ee			ld (debug_mark+1),a  
be62 3a 6c be			ld a, (.dmark+2)  
be65 32 73 ee			ld (debug_mark+2),a  
be68 18 03			jr .pastdmark  
be6a ..			.dmark: db "SPA"  
be6d f1			.pastdmark: pop af  
be6e			endm  
# End of macro DMARK
be6e						CALLMONITOR 
be6e cd dd 94			call break_point_state  
be71				endm  
# End of macro CALLMONITOR
be71					endif 
be71			 
be71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be71 cd 02 9e			call macro_forth_dsp_pop 
be74				endm 
# End of macro FORTH_DSP_POP
be74 e1					pop hl 
be75 0e 00				ld c, 0 
be77 45					ld b, l 
be78 21 c7 e2				ld hl, scratch  
be7b			 
be7b					if DEBUG_FORTH_WORDS 
be7b						DMARK "SP2" 
be7b f5				push af  
be7c 3a 90 be			ld a, (.dmark)  
be7f 32 71 ee			ld (debug_mark),a  
be82 3a 91 be			ld a, (.dmark+1)  
be85 32 72 ee			ld (debug_mark+1),a  
be88 3a 92 be			ld a, (.dmark+2)  
be8b 32 73 ee			ld (debug_mark+2),a  
be8e 18 03			jr .pastdmark  
be90 ..			.dmark: db "SP2"  
be93 f1			.pastdmark: pop af  
be94			endm  
# End of macro DMARK
be94						CALLMONITOR 
be94 cd dd 94			call break_point_state  
be97				endm  
# End of macro CALLMONITOR
be97					endif 
be97 3e 20				ld a, ' ' 
be99			.spaces1:	 
be99 77					ld (hl),a 
be9a 23					inc hl 
be9b					 
be9b 10 fc				djnz .spaces1 
be9d 3e 00				ld a,0 
be9f 77					ld (hl),a 
bea0 21 c7 e2				ld hl, scratch 
bea3					if DEBUG_FORTH_WORDS 
bea3						DMARK "SP3" 
bea3 f5				push af  
bea4 3a b8 be			ld a, (.dmark)  
bea7 32 71 ee			ld (debug_mark),a  
beaa 3a b9 be			ld a, (.dmark+1)  
bead 32 72 ee			ld (debug_mark+1),a  
beb0 3a ba be			ld a, (.dmark+2)  
beb3 32 73 ee			ld (debug_mark+2),a  
beb6 18 03			jr .pastdmark  
beb8 ..			.dmark: db "SP3"  
bebb f1			.pastdmark: pop af  
bebc			endm  
# End of macro DMARK
bebc						CALLMONITOR 
bebc cd dd 94			call break_point_state  
bebf				endm  
# End of macro CALLMONITOR
bebf					endif 
bebf cd c1 9b				call forth_push_str 
bec2			 
bec2				       NEXTW 
bec2 c3 00 9f			jp macro_next 
bec5				endm 
# End of macro NEXTW
bec5			 
bec5			 
bec5			 
bec5			.SCROLL: 
bec5				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bec5 53				db WORD_SYS_CORE+63             
bec6 f2 be			dw .SCROLLD            
bec8 07				db 6 + 1 
bec9 .. 00			db "SCROLL",0              
bed0				endm 
# End of macro CWHEAD
bed0			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bed0					if DEBUG_FORTH_WORDS_KEY 
bed0						DMARK "SCR" 
bed0 f5				push af  
bed1 3a e5 be			ld a, (.dmark)  
bed4 32 71 ee			ld (debug_mark),a  
bed7 3a e6 be			ld a, (.dmark+1)  
beda 32 72 ee			ld (debug_mark+1),a  
bedd 3a e7 be			ld a, (.dmark+2)  
bee0 32 73 ee			ld (debug_mark+2),a  
bee3 18 03			jr .pastdmark  
bee5 ..			.dmark: db "SCR"  
bee8 f1			.pastdmark: pop af  
bee9			endm  
# End of macro DMARK
bee9						CALLMONITOR 
bee9 cd dd 94			call break_point_state  
beec				endm  
# End of macro CALLMONITOR
beec					endif 
beec			 
beec cd 71 8a			call scroll_up 
beef			;	call update_display 
beef			 
beef					NEXTW 
beef c3 00 9f			jp macro_next 
bef2				endm 
# End of macro NEXTW
bef2			 
bef2			 
bef2			 
bef2			;		; get dir 
bef2			; 
bef2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bef2			; 
bef2			;		push hl 
bef2			; 
bef2			;		; destroy value TOS 
bef2			; 
bef2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bef2			; 
bef2			;		; get count 
bef2			; 
bef2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bef2			; 
bef2			;		push hl 
bef2			; 
bef2			;		; destroy value TOS 
bef2			; 
bef2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bef2			; 
bef2			;		; one value on hl get other one back 
bef2			; 
bef2			;		pop bc    ; count 
bef2			; 
bef2			;		pop de   ; dir 
bef2			; 
bef2			; 
bef2			;		ld b, c 
bef2			; 
bef2			;.scrolldir:     push bc 
bef2			;		push de 
bef2			; 
bef2			;		ld a, 0 
bef2			;		cp e 
bef2			;		jr z, .scrollup  
bef2			;		call scroll_down 
bef2			;		jr .scrollnext 
bef2			;.scrollup:	call scroll_up 
bef2			; 
bef2			;		 
bef2			;.scrollnext: 
bef2			;		pop de 
bef2			;		pop bc 
bef2			;		djnz .scrolldir 
bef2			; 
bef2			; 
bef2			; 
bef2			; 
bef2			; 
bef2			;		NEXTW 
bef2			 
bef2			.SCROLLD: 
bef2				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bef2 53				db WORD_SYS_CORE+63             
bef3 20 bf			dw .ATQ            
bef5 08				db 7 + 1 
bef6 .. 00			db "SCROLLD",0              
befe				endm 
# End of macro CWHEAD
befe			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
befe					if DEBUG_FORTH_WORDS_KEY 
befe						DMARK "SCD" 
befe f5				push af  
beff 3a 13 bf			ld a, (.dmark)  
bf02 32 71 ee			ld (debug_mark),a  
bf05 3a 14 bf			ld a, (.dmark+1)  
bf08 32 72 ee			ld (debug_mark+1),a  
bf0b 3a 15 bf			ld a, (.dmark+2)  
bf0e 32 73 ee			ld (debug_mark+2),a  
bf11 18 03			jr .pastdmark  
bf13 ..			.dmark: db "SCD"  
bf16 f1			.pastdmark: pop af  
bf17			endm  
# End of macro DMARK
bf17						CALLMONITOR 
bf17 cd dd 94			call break_point_state  
bf1a				endm  
# End of macro CALLMONITOR
bf1a					endif 
bf1a			 
bf1a cd 95 8a			call scroll_down 
bf1d			;	call update_display 
bf1d			 
bf1d					NEXTW 
bf1d c3 00 9f			jp macro_next 
bf20				endm 
# End of macro NEXTW
bf20			 
bf20			 
bf20			.ATQ: 
bf20				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf20 62				db WORD_SYS_CORE+78             
bf21 7e bf			dw .AUTODSP            
bf23 04				db 3 + 1 
bf24 .. 00			db "AT@",0              
bf28				endm 
# End of macro CWHEAD
bf28			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf28					if DEBUG_FORTH_WORDS_KEY 
bf28						DMARK "ATA" 
bf28 f5				push af  
bf29 3a 3d bf			ld a, (.dmark)  
bf2c 32 71 ee			ld (debug_mark),a  
bf2f 3a 3e bf			ld a, (.dmark+1)  
bf32 32 72 ee			ld (debug_mark+1),a  
bf35 3a 3f bf			ld a, (.dmark+2)  
bf38 32 73 ee			ld (debug_mark+2),a  
bf3b 18 03			jr .pastdmark  
bf3d ..			.dmark: db "ATA"  
bf40 f1			.pastdmark: pop af  
bf41			endm  
# End of macro DMARK
bf41						CALLMONITOR 
bf41 cd dd 94			call break_point_state  
bf44				endm  
# End of macro CALLMONITOR
bf44					endif 
bf44			 
bf44			 
bf44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf44 cd 4a 9d			call macro_dsp_valuehl 
bf47				endm 
# End of macro FORTH_DSP_VALUEHL
bf47			 
bf47					; TODO save cursor row 
bf47 7d					ld a,l 
bf48 fe 02				cp 2 
bf4a 20 04				jr nz, .crow3aq 
bf4c 3e 28				ld a, display_row_2 
bf4e 18 12				jr .ccol1aq 
bf50 fe 03		.crow3aq:		cp 3 
bf52 20 04				jr nz, .crow4aq 
bf54 3e 50				ld a, display_row_3 
bf56 18 0a				jr .ccol1aq 
bf58 fe 04		.crow4aq:		cp 4 
bf5a 20 04				jr nz, .crow1aq 
bf5c 3e 78				ld a, display_row_4 
bf5e 18 02				jr .ccol1aq 
bf60 3e 00		.crow1aq:		ld a,display_row_1 
bf62 f5			.ccol1aq:		push af			; got row offset 
bf63 6f					ld l,a 
bf64 26 00				ld h,0 
bf66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf66 cd 02 9e			call macro_forth_dsp_pop 
bf69				endm 
# End of macro FORTH_DSP_POP
bf69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf69 cd 4a 9d			call macro_dsp_valuehl 
bf6c				endm 
# End of macro FORTH_DSP_VALUEHL
bf6c					; TODO save cursor col 
bf6c f1					pop af 
bf6d 85					add l		; add col offset 
bf6e			 
bf6e					; add current frame buffer address 
bf6e 2a d2 eb				ld hl, (display_fb_active) 
bf71 cd dc 8c				call addatohl 
bf74			 
bf74			 
bf74			 
bf74			 
bf74					; get char frame buffer location offset in hl 
bf74			 
bf74 7e					ld a,(hl) 
bf75 26 00				ld h, 0 
bf77 6f					ld l, a 
bf78			 
bf78 cd 53 9b				call forth_push_numhl 
bf7b			 
bf7b			 
bf7b					NEXTW 
bf7b c3 00 9f			jp macro_next 
bf7e				endm 
# End of macro NEXTW
bf7e			 
bf7e			.AUTODSP: 
bf7e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bf7e 63				db WORD_SYS_CORE+79             
bf7f 94 bf			dw .MENU            
bf81 05				db 4 + 1 
bf82 .. 00			db "ADSP",0              
bf87				endm 
# End of macro CWHEAD
bf87			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bf87			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bf87			 
bf87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf87 cd 4a 9d			call macro_dsp_valuehl 
bf8a				endm 
# End of macro FORTH_DSP_VALUEHL
bf8a			 
bf8a			;		push hl 
bf8a			 
bf8a					; destroy value TOS 
bf8a			 
bf8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf8a cd 02 9e			call macro_forth_dsp_pop 
bf8d				endm 
# End of macro FORTH_DSP_POP
bf8d			 
bf8d			;		pop hl 
bf8d			 
bf8d 7d					ld a,l 
bf8e 32 42 ea				ld (cli_autodisplay), a 
bf91				       NEXTW 
bf91 c3 00 9f			jp macro_next 
bf94				endm 
# End of macro NEXTW
bf94			 
bf94			.MENU: 
bf94				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bf94 70				db WORD_SYS_CORE+92             
bf95 3d c0			dw .ENDDISPLAY            
bf97 05				db 4 + 1 
bf98 .. 00			db "MENU",0              
bf9d				endm 
# End of macro CWHEAD
bf9d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bf9d			 
bf9d			;		; get number of items on the stack 
bf9d			; 
bf9d				 
bf9d					FORTH_DSP_VALUEHL 
bf9d cd 4a 9d			call macro_dsp_valuehl 
bfa0				endm 
# End of macro FORTH_DSP_VALUEHL
bfa0				 
bfa0					if DEBUG_FORTH_WORDS_KEY 
bfa0						DMARK "MNU" 
bfa0 f5				push af  
bfa1 3a b5 bf			ld a, (.dmark)  
bfa4 32 71 ee			ld (debug_mark),a  
bfa7 3a b6 bf			ld a, (.dmark+1)  
bfaa 32 72 ee			ld (debug_mark+1),a  
bfad 3a b7 bf			ld a, (.dmark+2)  
bfb0 32 73 ee			ld (debug_mark+2),a  
bfb3 18 03			jr .pastdmark  
bfb5 ..			.dmark: db "MNU"  
bfb8 f1			.pastdmark: pop af  
bfb9			endm  
# End of macro DMARK
bfb9						CALLMONITOR 
bfb9 cd dd 94			call break_point_state  
bfbc				endm  
# End of macro CALLMONITOR
bfbc					endif 
bfbc			 
bfbc 45					ld b, l	 
bfbd 05					dec b 
bfbe			 
bfbe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfbe cd 02 9e			call macro_forth_dsp_pop 
bfc1				endm 
# End of macro FORTH_DSP_POP
bfc1			 
bfc1			 
bfc1					; go directly through the stack to pluck out the string pointers and build an array 
bfc1			 
bfc1			;		FORTH_DSP 
bfc1			 
bfc1					; hl contains top most stack item 
bfc1				 
bfc1 11 c7 e2				ld de, scratch 
bfc4			 
bfc4			.mbuild: 
bfc4			 
bfc4					FORTH_DSP_VALUEHL 
bfc4 cd 4a 9d			call macro_dsp_valuehl 
bfc7				endm 
# End of macro FORTH_DSP_VALUEHL
bfc7			 
bfc7					if DEBUG_FORTH_WORDS 
bfc7						DMARK "MN3" 
bfc7 f5				push af  
bfc8 3a dc bf			ld a, (.dmark)  
bfcb 32 71 ee			ld (debug_mark),a  
bfce 3a dd bf			ld a, (.dmark+1)  
bfd1 32 72 ee			ld (debug_mark+1),a  
bfd4 3a de bf			ld a, (.dmark+2)  
bfd7 32 73 ee			ld (debug_mark+2),a  
bfda 18 03			jr .pastdmark  
bfdc ..			.dmark: db "MN3"  
bfdf f1			.pastdmark: pop af  
bfe0			endm  
# End of macro DMARK
bfe0						CALLMONITOR 
bfe0 cd dd 94			call break_point_state  
bfe3				endm  
# End of macro CALLMONITOR
bfe3					endif 
bfe3 eb					ex de, hl 
bfe4 73					ld (hl), e 
bfe5 23					inc hl 
bfe6 72					ld (hl), d 
bfe7 23					inc hl 
bfe8 eb					ex de, hl 
bfe9			 
bfe9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfe9 cd 02 9e			call macro_forth_dsp_pop 
bfec				endm 
# End of macro FORTH_DSP_POP
bfec			 
bfec 10 d6				djnz .mbuild 
bfee			 
bfee					; done add term 
bfee			 
bfee eb					ex de, hl 
bfef 36 00				ld (hl), 0 
bff1 23					inc hl 
bff2 36 00				ld (hl), 0 
bff4			 
bff4				 
bff4					 
bff4 21 c7 e2				ld hl, scratch 
bff7			 
bff7					if DEBUG_FORTH_WORDS 
bff7						DMARK "MNx" 
bff7 f5				push af  
bff8 3a 0c c0			ld a, (.dmark)  
bffb 32 71 ee			ld (debug_mark),a  
bffe 3a 0d c0			ld a, (.dmark+1)  
c001 32 72 ee			ld (debug_mark+1),a  
c004 3a 0e c0			ld a, (.dmark+2)  
c007 32 73 ee			ld (debug_mark+2),a  
c00a 18 03			jr .pastdmark  
c00c ..			.dmark: db "MNx"  
c00f f1			.pastdmark: pop af  
c010			endm  
# End of macro DMARK
c010						CALLMONITOR 
c010 cd dd 94			call break_point_state  
c013				endm  
# End of macro CALLMONITOR
c013					endif 
c013			 
c013			 
c013			 
c013 3e 00				ld a, 0 
c015 cd e0 8a				call menu 
c018			 
c018			 
c018 6f					ld l, a 
c019 26 00				ld h, 0 
c01b			 
c01b					if DEBUG_FORTH_WORDS 
c01b						DMARK "MNr" 
c01b f5				push af  
c01c 3a 30 c0			ld a, (.dmark)  
c01f 32 71 ee			ld (debug_mark),a  
c022 3a 31 c0			ld a, (.dmark+1)  
c025 32 72 ee			ld (debug_mark+1),a  
c028 3a 32 c0			ld a, (.dmark+2)  
c02b 32 73 ee			ld (debug_mark+2),a  
c02e 18 03			jr .pastdmark  
c030 ..			.dmark: db "MNr"  
c033 f1			.pastdmark: pop af  
c034			endm  
# End of macro DMARK
c034						CALLMONITOR 
c034 cd dd 94			call break_point_state  
c037				endm  
# End of macro CALLMONITOR
c037					endif 
c037			 
c037 cd 53 9b				call forth_push_numhl 
c03a			 
c03a			 
c03a			 
c03a			 
c03a				       NEXTW 
c03a c3 00 9f			jp macro_next 
c03d				endm 
# End of macro NEXTW
c03d			 
c03d			 
c03d			.ENDDISPLAY: 
c03d			 
c03d			; eof 
# End of file forth_words_display.asm
c03d			include "forth_words_str.asm" 
c03d			 
c03d			; | ## String Words 
c03d			 
c03d			.PTR:   
c03d			 
c03d				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c03d 48				db WORD_SYS_CORE+52             
c03e 6a c0			dw .STYPE            
c040 04				db 3 + 1 
c041 .. 00			db "PTR",0              
c045				endm 
# End of macro CWHEAD
c045			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c045			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c045			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c045			 
c045					if DEBUG_FORTH_WORDS_KEY 
c045						DMARK "PTR" 
c045 f5				push af  
c046 3a 5a c0			ld a, (.dmark)  
c049 32 71 ee			ld (debug_mark),a  
c04c 3a 5b c0			ld a, (.dmark+1)  
c04f 32 72 ee			ld (debug_mark+1),a  
c052 3a 5c c0			ld a, (.dmark+2)  
c055 32 73 ee			ld (debug_mark+2),a  
c058 18 03			jr .pastdmark  
c05a ..			.dmark: db "PTR"  
c05d f1			.pastdmark: pop af  
c05e			endm  
# End of macro DMARK
c05e						CALLMONITOR 
c05e cd dd 94			call break_point_state  
c061				endm  
# End of macro CALLMONITOR
c061					endif 
c061					FORTH_DSP_VALUEHL 
c061 cd 4a 9d			call macro_dsp_valuehl 
c064				endm 
# End of macro FORTH_DSP_VALUEHL
c064 cd 53 9b				call forth_push_numhl 
c067			 
c067			 
c067					NEXTW 
c067 c3 00 9f			jp macro_next 
c06a				endm 
# End of macro NEXTW
c06a			.STYPE: 
c06a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c06a 48				db WORD_SYS_CORE+52             
c06b b9 c0			dw .UPPER            
c06d 06				db 5 + 1 
c06e .. 00			db "STYPE",0              
c074				endm 
# End of macro CWHEAD
c074			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c074					if DEBUG_FORTH_WORDS_KEY 
c074						DMARK "STY" 
c074 f5				push af  
c075 3a 89 c0			ld a, (.dmark)  
c078 32 71 ee			ld (debug_mark),a  
c07b 3a 8a c0			ld a, (.dmark+1)  
c07e 32 72 ee			ld (debug_mark+1),a  
c081 3a 8b c0			ld a, (.dmark+2)  
c084 32 73 ee			ld (debug_mark+2),a  
c087 18 03			jr .pastdmark  
c089 ..			.dmark: db "STY"  
c08c f1			.pastdmark: pop af  
c08d			endm  
# End of macro DMARK
c08d						CALLMONITOR 
c08d cd dd 94			call break_point_state  
c090				endm  
# End of macro CALLMONITOR
c090					endif 
c090					FORTH_DSP 
c090 cd 10 9d			call macro_forth_dsp 
c093				endm 
# End of macro FORTH_DSP
c093					;v5 FORTH_DSP_VALUE 
c093			 
c093 7e					ld a, (hl) 
c094			 
c094 f5					push af 
c095			 
c095			; Dont destroy TOS		FORTH_DSP_POP 
c095			 
c095 f1					pop af 
c096			 
c096 fe 01				cp DS_TYPE_STR 
c098 28 09				jr z, .typestr 
c09a			 
c09a fe 02				cp DS_TYPE_INUM 
c09c 28 0a				jr z, .typeinum 
c09e			 
c09e 21 b7 c0				ld hl, .tna 
c0a1 18 0a				jr .tpush 
c0a3			 
c0a3 21 b3 c0		.typestr:	ld hl, .tstr 
c0a6 18 05				jr .tpush 
c0a8 21 b5 c0		.typeinum:	ld hl, .tinum 
c0ab 18 00				jr .tpush 
c0ad			 
c0ad			.tpush: 
c0ad			 
c0ad cd c1 9b				call forth_push_str 
c0b0			 
c0b0					NEXTW 
c0b0 c3 00 9f			jp macro_next 
c0b3				endm 
# End of macro NEXTW
c0b3 .. 00		.tstr:	db "s",0 
c0b5 .. 00		.tinum:  db "i",0 
c0b7 .. 00		.tna:   db "?", 0 
c0b9			 
c0b9			 
c0b9			.UPPER: 
c0b9				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c0b9 48				db WORD_SYS_CORE+52             
c0ba f4 c0			dw .LOWER            
c0bc 06				db 5 + 1 
c0bd .. 00			db "UPPER",0              
c0c3				endm 
# End of macro CWHEAD
c0c3			; | UPPER ( s -- s ) Upper case string s  | DONE 
c0c3					if DEBUG_FORTH_WORDS_KEY 
c0c3						DMARK "UPR" 
c0c3 f5				push af  
c0c4 3a d8 c0			ld a, (.dmark)  
c0c7 32 71 ee			ld (debug_mark),a  
c0ca 3a d9 c0			ld a, (.dmark+1)  
c0cd 32 72 ee			ld (debug_mark+1),a  
c0d0 3a da c0			ld a, (.dmark+2)  
c0d3 32 73 ee			ld (debug_mark+2),a  
c0d6 18 03			jr .pastdmark  
c0d8 ..			.dmark: db "UPR"  
c0db f1			.pastdmark: pop af  
c0dc			endm  
# End of macro DMARK
c0dc						CALLMONITOR 
c0dc cd dd 94			call break_point_state  
c0df				endm  
# End of macro CALLMONITOR
c0df					endif 
c0df			 
c0df					FORTH_DSP 
c0df cd 10 9d			call macro_forth_dsp 
c0e2				endm 
# End of macro FORTH_DSP
c0e2					 
c0e2			; TODO check is string type 
c0e2			 
c0e2					FORTH_DSP_VALUEHL 
c0e2 cd 4a 9d			call macro_dsp_valuehl 
c0e5				endm 
# End of macro FORTH_DSP_VALUEHL
c0e5			; get pointer to string in hl 
c0e5			 
c0e5 7e			.toup:		ld a, (hl) 
c0e6 fe 00				cp 0 
c0e8 28 07				jr z, .toupdone 
c0ea			 
c0ea cd 49 90				call to_upper 
c0ed			 
c0ed 77					ld (hl), a 
c0ee 23					inc hl 
c0ef 18 f4				jr .toup 
c0f1			 
c0f1					 
c0f1			 
c0f1			 
c0f1			; for each char convert to upper 
c0f1					 
c0f1			.toupdone: 
c0f1			 
c0f1			 
c0f1					NEXTW 
c0f1 c3 00 9f			jp macro_next 
c0f4				endm 
# End of macro NEXTW
c0f4			.LOWER: 
c0f4				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c0f4 48				db WORD_SYS_CORE+52             
c0f5 2f c1			dw .TCASE            
c0f7 06				db 5 + 1 
c0f8 .. 00			db "LOWER",0              
c0fe				endm 
# End of macro CWHEAD
c0fe			; | LOWER ( s -- s ) Lower case string s  | DONE 
c0fe					if DEBUG_FORTH_WORDS_KEY 
c0fe						DMARK "LWR" 
c0fe f5				push af  
c0ff 3a 13 c1			ld a, (.dmark)  
c102 32 71 ee			ld (debug_mark),a  
c105 3a 14 c1			ld a, (.dmark+1)  
c108 32 72 ee			ld (debug_mark+1),a  
c10b 3a 15 c1			ld a, (.dmark+2)  
c10e 32 73 ee			ld (debug_mark+2),a  
c111 18 03			jr .pastdmark  
c113 ..			.dmark: db "LWR"  
c116 f1			.pastdmark: pop af  
c117			endm  
# End of macro DMARK
c117						CALLMONITOR 
c117 cd dd 94			call break_point_state  
c11a				endm  
# End of macro CALLMONITOR
c11a					endif 
c11a			 
c11a					FORTH_DSP 
c11a cd 10 9d			call macro_forth_dsp 
c11d				endm 
# End of macro FORTH_DSP
c11d					 
c11d			; TODO check is string type 
c11d			 
c11d					FORTH_DSP_VALUEHL 
c11d cd 4a 9d			call macro_dsp_valuehl 
c120				endm 
# End of macro FORTH_DSP_VALUEHL
c120			; get pointer to string in hl 
c120			 
c120 7e			.tolow:		ld a, (hl) 
c121 fe 00				cp 0 
c123 28 07				jr z, .tolowdone 
c125			 
c125 cd 52 90				call to_lower 
c128			 
c128 77					ld (hl), a 
c129 23					inc hl 
c12a 18 f4				jr .tolow 
c12c			 
c12c					 
c12c			 
c12c			 
c12c			; for each char convert to low 
c12c					 
c12c			.tolowdone: 
c12c					NEXTW 
c12c c3 00 9f			jp macro_next 
c12f				endm 
# End of macro NEXTW
c12f			.TCASE: 
c12f				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c12f 48				db WORD_SYS_CORE+52             
c130 65 c2			dw .SUBSTR            
c132 06				db 5 + 1 
c133 .. 00			db "TCASE",0              
c139				endm 
# End of macro CWHEAD
c139			; | TCASE ( s -- s ) Title case string s  | DONE 
c139					if DEBUG_FORTH_WORDS_KEY 
c139						DMARK "TCS" 
c139 f5				push af  
c13a 3a 4e c1			ld a, (.dmark)  
c13d 32 71 ee			ld (debug_mark),a  
c140 3a 4f c1			ld a, (.dmark+1)  
c143 32 72 ee			ld (debug_mark+1),a  
c146 3a 50 c1			ld a, (.dmark+2)  
c149 32 73 ee			ld (debug_mark+2),a  
c14c 18 03			jr .pastdmark  
c14e ..			.dmark: db "TCS"  
c151 f1			.pastdmark: pop af  
c152			endm  
# End of macro DMARK
c152						CALLMONITOR 
c152 cd dd 94			call break_point_state  
c155				endm  
# End of macro CALLMONITOR
c155					endif 
c155			 
c155					FORTH_DSP 
c155 cd 10 9d			call macro_forth_dsp 
c158				endm 
# End of macro FORTH_DSP
c158					 
c158			; TODO check is string type 
c158			 
c158					FORTH_DSP_VALUEHL 
c158 cd 4a 9d			call macro_dsp_valuehl 
c15b				endm 
# End of macro FORTH_DSP_VALUEHL
c15b			; get pointer to string in hl 
c15b			 
c15b					if DEBUG_FORTH_WORDS 
c15b						DMARK "TC1" 
c15b f5				push af  
c15c 3a 70 c1			ld a, (.dmark)  
c15f 32 71 ee			ld (debug_mark),a  
c162 3a 71 c1			ld a, (.dmark+1)  
c165 32 72 ee			ld (debug_mark+1),a  
c168 3a 72 c1			ld a, (.dmark+2)  
c16b 32 73 ee			ld (debug_mark+2),a  
c16e 18 03			jr .pastdmark  
c170 ..			.dmark: db "TC1"  
c173 f1			.pastdmark: pop af  
c174			endm  
# End of macro DMARK
c174						CALLMONITOR 
c174 cd dd 94			call break_point_state  
c177				endm  
# End of macro CALLMONITOR
c177					endif 
c177			 
c177					; first time in turn to upper case first char 
c177			 
c177 7e					ld a, (hl) 
c178 c3 02 c2				jp .totsiptou 
c17b			 
c17b			 
c17b 7e			.tot:		ld a, (hl) 
c17c fe 00				cp 0 
c17e ca 46 c2				jp z, .totdone 
c181			 
c181					if DEBUG_FORTH_WORDS 
c181						DMARK "TC2" 
c181 f5				push af  
c182 3a 96 c1			ld a, (.dmark)  
c185 32 71 ee			ld (debug_mark),a  
c188 3a 97 c1			ld a, (.dmark+1)  
c18b 32 72 ee			ld (debug_mark+1),a  
c18e 3a 98 c1			ld a, (.dmark+2)  
c191 32 73 ee			ld (debug_mark+2),a  
c194 18 03			jr .pastdmark  
c196 ..			.dmark: db "TC2"  
c199 f1			.pastdmark: pop af  
c19a			endm  
# End of macro DMARK
c19a						CALLMONITOR 
c19a cd dd 94			call break_point_state  
c19d				endm  
# End of macro CALLMONITOR
c19d					endif 
c19d					; check to see if current char is a space 
c19d			 
c19d fe 20				cp ' ' 
c19f 28 21				jr z, .totsp 
c1a1 cd 52 90				call to_lower 
c1a4					if DEBUG_FORTH_WORDS 
c1a4						DMARK "TC3" 
c1a4 f5				push af  
c1a5 3a b9 c1			ld a, (.dmark)  
c1a8 32 71 ee			ld (debug_mark),a  
c1ab 3a ba c1			ld a, (.dmark+1)  
c1ae 32 72 ee			ld (debug_mark+1),a  
c1b1 3a bb c1			ld a, (.dmark+2)  
c1b4 32 73 ee			ld (debug_mark+2),a  
c1b7 18 03			jr .pastdmark  
c1b9 ..			.dmark: db "TC3"  
c1bc f1			.pastdmark: pop af  
c1bd			endm  
# End of macro DMARK
c1bd						CALLMONITOR 
c1bd cd dd 94			call break_point_state  
c1c0				endm  
# End of macro CALLMONITOR
c1c0					endif 
c1c0 18 63				jr .totnxt 
c1c2			 
c1c2			.totsp:         ; on a space, find next char which should be upper 
c1c2			 
c1c2					if DEBUG_FORTH_WORDS 
c1c2						DMARK "TC4" 
c1c2 f5				push af  
c1c3 3a d7 c1			ld a, (.dmark)  
c1c6 32 71 ee			ld (debug_mark),a  
c1c9 3a d8 c1			ld a, (.dmark+1)  
c1cc 32 72 ee			ld (debug_mark+1),a  
c1cf 3a d9 c1			ld a, (.dmark+2)  
c1d2 32 73 ee			ld (debug_mark+2),a  
c1d5 18 03			jr .pastdmark  
c1d7 ..			.dmark: db "TC4"  
c1da f1			.pastdmark: pop af  
c1db			endm  
# End of macro DMARK
c1db						CALLMONITOR 
c1db cd dd 94			call break_point_state  
c1de				endm  
# End of macro CALLMONITOR
c1de					endif 
c1de					;; 
c1de			 
c1de fe 20				cp ' ' 
c1e0 20 20				jr nz, .totsiptou 
c1e2 23					inc hl 
c1e3 7e					ld a, (hl) 
c1e4					if DEBUG_FORTH_WORDS 
c1e4						DMARK "TC5" 
c1e4 f5				push af  
c1e5 3a f9 c1			ld a, (.dmark)  
c1e8 32 71 ee			ld (debug_mark),a  
c1eb 3a fa c1			ld a, (.dmark+1)  
c1ee 32 72 ee			ld (debug_mark+1),a  
c1f1 3a fb c1			ld a, (.dmark+2)  
c1f4 32 73 ee			ld (debug_mark+2),a  
c1f7 18 03			jr .pastdmark  
c1f9 ..			.dmark: db "TC5"  
c1fc f1			.pastdmark: pop af  
c1fd			endm  
# End of macro DMARK
c1fd						CALLMONITOR 
c1fd cd dd 94			call break_point_state  
c200				endm  
# End of macro CALLMONITOR
c200					endif 
c200 18 c0				jr .totsp 
c202 fe 00		.totsiptou:    cp 0 
c204 28 40				jr z, .totdone 
c206					; not space and not zero term so upper case it 
c206 cd 49 90				call to_upper 
c209			 
c209					if DEBUG_FORTH_WORDS 
c209						DMARK "TC6" 
c209 f5				push af  
c20a 3a 1e c2			ld a, (.dmark)  
c20d 32 71 ee			ld (debug_mark),a  
c210 3a 1f c2			ld a, (.dmark+1)  
c213 32 72 ee			ld (debug_mark+1),a  
c216 3a 20 c2			ld a, (.dmark+2)  
c219 32 73 ee			ld (debug_mark+2),a  
c21c 18 03			jr .pastdmark  
c21e ..			.dmark: db "TC6"  
c221 f1			.pastdmark: pop af  
c222			endm  
# End of macro DMARK
c222						CALLMONITOR 
c222 cd dd 94			call break_point_state  
c225				endm  
# End of macro CALLMONITOR
c225					endif 
c225			 
c225			 
c225			.totnxt: 
c225			 
c225 77					ld (hl), a 
c226 23					inc hl 
c227					if DEBUG_FORTH_WORDS 
c227						DMARK "TC7" 
c227 f5				push af  
c228 3a 3c c2			ld a, (.dmark)  
c22b 32 71 ee			ld (debug_mark),a  
c22e 3a 3d c2			ld a, (.dmark+1)  
c231 32 72 ee			ld (debug_mark+1),a  
c234 3a 3e c2			ld a, (.dmark+2)  
c237 32 73 ee			ld (debug_mark+2),a  
c23a 18 03			jr .pastdmark  
c23c ..			.dmark: db "TC7"  
c23f f1			.pastdmark: pop af  
c240			endm  
# End of macro DMARK
c240						CALLMONITOR 
c240 cd dd 94			call break_point_state  
c243				endm  
# End of macro CALLMONITOR
c243					endif 
c243 c3 7b c1				jp .tot 
c246			 
c246					 
c246			 
c246			 
c246			; for each char convert to low 
c246					 
c246			.totdone: 
c246					if DEBUG_FORTH_WORDS 
c246						DMARK "TCd" 
c246 f5				push af  
c247 3a 5b c2			ld a, (.dmark)  
c24a 32 71 ee			ld (debug_mark),a  
c24d 3a 5c c2			ld a, (.dmark+1)  
c250 32 72 ee			ld (debug_mark+1),a  
c253 3a 5d c2			ld a, (.dmark+2)  
c256 32 73 ee			ld (debug_mark+2),a  
c259 18 03			jr .pastdmark  
c25b ..			.dmark: db "TCd"  
c25e f1			.pastdmark: pop af  
c25f			endm  
# End of macro DMARK
c25f						CALLMONITOR 
c25f cd dd 94			call break_point_state  
c262				endm  
# End of macro CALLMONITOR
c262					endif 
c262					NEXTW 
c262 c3 00 9f			jp macro_next 
c265				endm 
# End of macro NEXTW
c265			 
c265			.SUBSTR: 
c265				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c265 48				db WORD_SYS_CORE+52             
c266 c3 c2			dw .LEFT            
c268 07				db 6 + 1 
c269 .. 00			db "SUBSTR",0              
c270				endm 
# End of macro CWHEAD
c270			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c270			 
c270					if DEBUG_FORTH_WORDS_KEY 
c270						DMARK "SST" 
c270 f5				push af  
c271 3a 85 c2			ld a, (.dmark)  
c274 32 71 ee			ld (debug_mark),a  
c277 3a 86 c2			ld a, (.dmark+1)  
c27a 32 72 ee			ld (debug_mark+1),a  
c27d 3a 87 c2			ld a, (.dmark+2)  
c280 32 73 ee			ld (debug_mark+2),a  
c283 18 03			jr .pastdmark  
c285 ..			.dmark: db "SST"  
c288 f1			.pastdmark: pop af  
c289			endm  
# End of macro DMARK
c289						CALLMONITOR 
c289 cd dd 94			call break_point_state  
c28c				endm  
# End of macro CALLMONITOR
c28c					endif 
c28c			; TODO check string type 
c28c					FORTH_DSP_VALUEHL 
c28c cd 4a 9d			call macro_dsp_valuehl 
c28f				endm 
# End of macro FORTH_DSP_VALUEHL
c28f			 
c28f e5					push hl      ; string length 
c290			 
c290					FORTH_DSP_POP 
c290 cd 02 9e			call macro_forth_dsp_pop 
c293				endm 
# End of macro FORTH_DSP_POP
c293			 
c293					FORTH_DSP_VALUEHL 
c293 cd 4a 9d			call macro_dsp_valuehl 
c296				endm 
# End of macro FORTH_DSP_VALUEHL
c296			 
c296 e5					push hl     ; start char 
c297			 
c297					FORTH_DSP_POP 
c297 cd 02 9e			call macro_forth_dsp_pop 
c29a				endm 
# End of macro FORTH_DSP_POP
c29a			 
c29a			 
c29a					FORTH_DSP_VALUE 
c29a cd 33 9d			call macro_forth_dsp_value 
c29d				endm 
# End of macro FORTH_DSP_VALUE
c29d			 
c29d d1					pop de    ; get start post offset 
c29e			 
c29e 19					add hl, de    ; starting offset 
c29f			 
c29f c1					pop bc 
c2a0 c5					push bc      ; grab size of string 
c2a1			 
c2a1 e5					push hl    ; save string start  
c2a2			 
c2a2 26 00				ld h, 0 
c2a4 69					ld l, c 
c2a5 23					inc hl 
c2a6 23					inc hl 
c2a7			 
c2a7 cd a3 91				call malloc 
c2aa				if DEBUG_FORTH_MALLOC_GUARD 
c2aa cc 0b cc				call z,malloc_error 
c2ad				endif 
c2ad			 
c2ad eb					ex de, hl      ; save malloc area for string copy 
c2ae e1					pop hl    ; get back source 
c2af c1					pop bc    ; get length of string back 
c2b0			 
c2b0 d5					push de    ; save malloc area for after we push 
c2b1 ed b0				ldir     ; copy substr 
c2b3			 
c2b3			 
c2b3 eb					ex de, hl 
c2b4 3e 00				ld a, 0 
c2b6 77					ld (hl), a   ; term substr 
c2b7			 
c2b7					 
c2b7 e1					pop hl    ; get malloc so we can push it 
c2b8 e5					push hl   ; save so we can free it afterwards 
c2b9			 
c2b9 cd c1 9b				call forth_push_str 
c2bc			 
c2bc e1					pop hl 
c2bd cd 6d 92				call free 
c2c0			 
c2c0					 
c2c0					 
c2c0			 
c2c0			 
c2c0					NEXTW 
c2c0 c3 00 9f			jp macro_next 
c2c3				endm 
# End of macro NEXTW
c2c3			 
c2c3			.LEFT: 
c2c3				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c2c3 48				db WORD_SYS_CORE+52             
c2c4 eb c2			dw .RIGHT            
c2c6 05				db 4 + 1 
c2c7 .. 00			db "LEFT",0              
c2cc				endm 
# End of macro CWHEAD
c2cc			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c2cc					if DEBUG_FORTH_WORDS_KEY 
c2cc						DMARK "LEF" 
c2cc f5				push af  
c2cd 3a e1 c2			ld a, (.dmark)  
c2d0 32 71 ee			ld (debug_mark),a  
c2d3 3a e2 c2			ld a, (.dmark+1)  
c2d6 32 72 ee			ld (debug_mark+1),a  
c2d9 3a e3 c2			ld a, (.dmark+2)  
c2dc 32 73 ee			ld (debug_mark+2),a  
c2df 18 03			jr .pastdmark  
c2e1 ..			.dmark: db "LEF"  
c2e4 f1			.pastdmark: pop af  
c2e5			endm  
# End of macro DMARK
c2e5						CALLMONITOR 
c2e5 cd dd 94			call break_point_state  
c2e8				endm  
# End of macro CALLMONITOR
c2e8					endif 
c2e8			 
c2e8					NEXTW 
c2e8 c3 00 9f			jp macro_next 
c2eb				endm 
# End of macro NEXTW
c2eb			.RIGHT: 
c2eb				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c2eb 48				db WORD_SYS_CORE+52             
c2ec 14 c3			dw .STR2NUM            
c2ee 06				db 5 + 1 
c2ef .. 00			db "RIGHT",0              
c2f5				endm 
# End of macro CWHEAD
c2f5			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c2f5					if DEBUG_FORTH_WORDS_KEY 
c2f5						DMARK "RIG" 
c2f5 f5				push af  
c2f6 3a 0a c3			ld a, (.dmark)  
c2f9 32 71 ee			ld (debug_mark),a  
c2fc 3a 0b c3			ld a, (.dmark+1)  
c2ff 32 72 ee			ld (debug_mark+1),a  
c302 3a 0c c3			ld a, (.dmark+2)  
c305 32 73 ee			ld (debug_mark+2),a  
c308 18 03			jr .pastdmark  
c30a ..			.dmark: db "RIG"  
c30d f1			.pastdmark: pop af  
c30e			endm  
# End of macro DMARK
c30e						CALLMONITOR 
c30e cd dd 94			call break_point_state  
c311				endm  
# End of macro CALLMONITOR
c311					endif 
c311			 
c311					NEXTW 
c311 c3 00 9f			jp macro_next 
c314				endm 
# End of macro NEXTW
c314			 
c314			 
c314			.STR2NUM: 
c314				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c314 48				db WORD_SYS_CORE+52             
c315 a0 c3			dw .NUM2STR            
c317 08				db 7 + 1 
c318 .. 00			db "STR2NUM",0              
c320				endm 
# End of macro CWHEAD
c320			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c320			 
c320			 
c320			; TODO STR type check to do 
c320					if DEBUG_FORTH_WORDS_KEY 
c320						DMARK "S2N" 
c320 f5				push af  
c321 3a 35 c3			ld a, (.dmark)  
c324 32 71 ee			ld (debug_mark),a  
c327 3a 36 c3			ld a, (.dmark+1)  
c32a 32 72 ee			ld (debug_mark+1),a  
c32d 3a 37 c3			ld a, (.dmark+2)  
c330 32 73 ee			ld (debug_mark+2),a  
c333 18 03			jr .pastdmark  
c335 ..			.dmark: db "S2N"  
c338 f1			.pastdmark: pop af  
c339			endm  
# End of macro DMARK
c339						CALLMONITOR 
c339 cd dd 94			call break_point_state  
c33c				endm  
# End of macro CALLMONITOR
c33c					endif 
c33c			 
c33c					;FORTH_DSP 
c33c					FORTH_DSP_VALUE 
c33c cd 33 9d			call macro_forth_dsp_value 
c33f				endm 
# End of macro FORTH_DSP_VALUE
c33f					;inc hl 
c33f			 
c33f eb					ex de, hl 
c340					if DEBUG_FORTH_WORDS 
c340						DMARK "S2a" 
c340 f5				push af  
c341 3a 55 c3			ld a, (.dmark)  
c344 32 71 ee			ld (debug_mark),a  
c347 3a 56 c3			ld a, (.dmark+1)  
c34a 32 72 ee			ld (debug_mark+1),a  
c34d 3a 57 c3			ld a, (.dmark+2)  
c350 32 73 ee			ld (debug_mark+2),a  
c353 18 03			jr .pastdmark  
c355 ..			.dmark: db "S2a"  
c358 f1			.pastdmark: pop af  
c359			endm  
# End of macro DMARK
c359						CALLMONITOR 
c359 cd dd 94			call break_point_state  
c35c				endm  
# End of macro CALLMONITOR
c35c					endif 
c35c cd d1 90				call string_to_uint16 
c35f			 
c35f					if DEBUG_FORTH_WORDS 
c35f						DMARK "S2b" 
c35f f5				push af  
c360 3a 74 c3			ld a, (.dmark)  
c363 32 71 ee			ld (debug_mark),a  
c366 3a 75 c3			ld a, (.dmark+1)  
c369 32 72 ee			ld (debug_mark+1),a  
c36c 3a 76 c3			ld a, (.dmark+2)  
c36f 32 73 ee			ld (debug_mark+2),a  
c372 18 03			jr .pastdmark  
c374 ..			.dmark: db "S2b"  
c377 f1			.pastdmark: pop af  
c378			endm  
# End of macro DMARK
c378						CALLMONITOR 
c378 cd dd 94			call break_point_state  
c37b				endm  
# End of macro CALLMONITOR
c37b					endif 
c37b			;		push hl 
c37b					FORTH_DSP_POP 
c37b cd 02 9e			call macro_forth_dsp_pop 
c37e				endm 
# End of macro FORTH_DSP_POP
c37e			;		pop hl 
c37e					 
c37e					if DEBUG_FORTH_WORDS 
c37e						DMARK "S2b" 
c37e f5				push af  
c37f 3a 93 c3			ld a, (.dmark)  
c382 32 71 ee			ld (debug_mark),a  
c385 3a 94 c3			ld a, (.dmark+1)  
c388 32 72 ee			ld (debug_mark+1),a  
c38b 3a 95 c3			ld a, (.dmark+2)  
c38e 32 73 ee			ld (debug_mark+2),a  
c391 18 03			jr .pastdmark  
c393 ..			.dmark: db "S2b"  
c396 f1			.pastdmark: pop af  
c397			endm  
# End of macro DMARK
c397						CALLMONITOR 
c397 cd dd 94			call break_point_state  
c39a				endm  
# End of macro CALLMONITOR
c39a					endif 
c39a cd 53 9b				call forth_push_numhl	 
c39d			 
c39d				 
c39d				       NEXTW 
c39d c3 00 9f			jp macro_next 
c3a0				endm 
# End of macro NEXTW
c3a0			.NUM2STR: 
c3a0				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3a0 48				db WORD_SYS_CORE+52             
c3a1 af c3			dw .CONCAT            
c3a3 08				db 7 + 1 
c3a4 .. 00			db "NUM2STR",0              
c3ac				endm 
# End of macro CWHEAD
c3ac			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c3ac			 
c3ac			;		; malloc a string to target 
c3ac			;		ld hl, 10     ; TODO max string size should be fine 
c3ac			;		call malloc 
c3ac			;		push hl    ; save malloc location 
c3ac			; 
c3ac			; 
c3ac			;; TODO check int type 
c3ac			;		FORTH_DSP_VALUEHL 
c3ac			;		ld a, l 
c3ac			;		call DispAToASCII   
c3ac			;;TODO need to chage above call to dump into string 
c3ac			; 
c3ac			; 
c3ac			 
c3ac				       NEXTW 
c3ac c3 00 9f			jp macro_next 
c3af				endm 
# End of macro NEXTW
c3af			 
c3af			.CONCAT: 
c3af				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3af 48				db WORD_SYS_CORE+52             
c3b0 62 c4			dw .FIND            
c3b2 07				db 6 + 1 
c3b3 .. 00			db "CONCAT",0              
c3ba				endm 
# End of macro CWHEAD
c3ba			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c3ba			 
c3ba			; TODO check string type 
c3ba			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c3ba			 
c3ba					if DEBUG_FORTH_WORDS_KEY 
c3ba						DMARK "CON" 
c3ba f5				push af  
c3bb 3a cf c3			ld a, (.dmark)  
c3be 32 71 ee			ld (debug_mark),a  
c3c1 3a d0 c3			ld a, (.dmark+1)  
c3c4 32 72 ee			ld (debug_mark+1),a  
c3c7 3a d1 c3			ld a, (.dmark+2)  
c3ca 32 73 ee			ld (debug_mark+2),a  
c3cd 18 03			jr .pastdmark  
c3cf ..			.dmark: db "CON"  
c3d2 f1			.pastdmark: pop af  
c3d3			endm  
# End of macro DMARK
c3d3						CALLMONITOR 
c3d3 cd dd 94			call break_point_state  
c3d6				endm  
# End of macro CALLMONITOR
c3d6					endif 
c3d6			 
c3d6			 
c3d6					FORTH_DSP_VALUE 
c3d6 cd 33 9d			call macro_forth_dsp_value 
c3d9				endm 
# End of macro FORTH_DSP_VALUE
c3d9 e5					push hl   ; s2 
c3da			 
c3da					FORTH_DSP_POP 
c3da cd 02 9e			call macro_forth_dsp_pop 
c3dd				endm 
# End of macro FORTH_DSP_POP
c3dd			 
c3dd					FORTH_DSP_VALUE 
c3dd cd 33 9d			call macro_forth_dsp_value 
c3e0				endm 
# End of macro FORTH_DSP_VALUE
c3e0			 
c3e0 e5					push hl   ; s1 
c3e1			 
c3e1					FORTH_DSP_POP 
c3e1 cd 02 9e			call macro_forth_dsp_pop 
c3e4				endm 
# End of macro FORTH_DSP_POP
c3e4					 
c3e4			 
c3e4					; copy s1 
c3e4			 
c3e4				 
c3e4					; save ptr 
c3e4 e1					pop hl  
c3e5 e5					push hl 
c3e6 3e 00				ld a, 0 
c3e8 cd 45 91				call strlent 
c3eb					;inc hl    ; zer0 
c3eb 06 00				ld b, 0 
c3ed 4d					ld c, l 
c3ee e1					pop hl		 
c3ef 11 c7 e2				ld de, scratch	 
c3f2					if DEBUG_FORTH_WORDS 
c3f2						DMARK "CO1" 
c3f2 f5				push af  
c3f3 3a 07 c4			ld a, (.dmark)  
c3f6 32 71 ee			ld (debug_mark),a  
c3f9 3a 08 c4			ld a, (.dmark+1)  
c3fc 32 72 ee			ld (debug_mark+1),a  
c3ff 3a 09 c4			ld a, (.dmark+2)  
c402 32 73 ee			ld (debug_mark+2),a  
c405 18 03			jr .pastdmark  
c407 ..			.dmark: db "CO1"  
c40a f1			.pastdmark: pop af  
c40b			endm  
# End of macro DMARK
c40b						CALLMONITOR 
c40b cd dd 94			call break_point_state  
c40e				endm  
# End of macro CALLMONITOR
c40e					endif 
c40e ed b0				ldir 
c410			 
c410 e1					pop hl 
c411 e5					push hl 
c412 d5					push de 
c413			 
c413			 
c413 3e 00				ld a, 0 
c415 cd 45 91				call strlent 
c418 23					inc hl    ; zer0 
c419 23					inc hl 
c41a 06 00				ld b, 0 
c41c 4d					ld c, l 
c41d d1					pop de 
c41e e1					pop hl		 
c41f					if DEBUG_FORTH_WORDS 
c41f						DMARK "CO2" 
c41f f5				push af  
c420 3a 34 c4			ld a, (.dmark)  
c423 32 71 ee			ld (debug_mark),a  
c426 3a 35 c4			ld a, (.dmark+1)  
c429 32 72 ee			ld (debug_mark+1),a  
c42c 3a 36 c4			ld a, (.dmark+2)  
c42f 32 73 ee			ld (debug_mark+2),a  
c432 18 03			jr .pastdmark  
c434 ..			.dmark: db "CO2"  
c437 f1			.pastdmark: pop af  
c438			endm  
# End of macro DMARK
c438						CALLMONITOR 
c438 cd dd 94			call break_point_state  
c43b				endm  
# End of macro CALLMONITOR
c43b					endif 
c43b ed b0				ldir 
c43d			 
c43d			 
c43d			 
c43d 21 c7 e2				ld hl, scratch 
c440					if DEBUG_FORTH_WORDS 
c440						DMARK "CO5" 
c440 f5				push af  
c441 3a 55 c4			ld a, (.dmark)  
c444 32 71 ee			ld (debug_mark),a  
c447 3a 56 c4			ld a, (.dmark+1)  
c44a 32 72 ee			ld (debug_mark+1),a  
c44d 3a 57 c4			ld a, (.dmark+2)  
c450 32 73 ee			ld (debug_mark+2),a  
c453 18 03			jr .pastdmark  
c455 ..			.dmark: db "CO5"  
c458 f1			.pastdmark: pop af  
c459			endm  
# End of macro DMARK
c459						CALLMONITOR 
c459 cd dd 94			call break_point_state  
c45c				endm  
# End of macro CALLMONITOR
c45c					endif 
c45c			 
c45c cd c1 9b				call forth_push_str 
c45f			 
c45f			 
c45f			 
c45f			 
c45f				       NEXTW 
c45f c3 00 9f			jp macro_next 
c462				endm 
# End of macro NEXTW
c462			 
c462			 
c462			.FIND: 
c462				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c462 4b				db WORD_SYS_CORE+55             
c463 20 c5			dw .LEN            
c465 05				db 4 + 1 
c466 .. 00			db "FIND",0              
c46b				endm 
# End of macro CWHEAD
c46b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c46b			 
c46b					if DEBUG_FORTH_WORDS_KEY 
c46b						DMARK "FND" 
c46b f5				push af  
c46c 3a 80 c4			ld a, (.dmark)  
c46f 32 71 ee			ld (debug_mark),a  
c472 3a 81 c4			ld a, (.dmark+1)  
c475 32 72 ee			ld (debug_mark+1),a  
c478 3a 82 c4			ld a, (.dmark+2)  
c47b 32 73 ee			ld (debug_mark+2),a  
c47e 18 03			jr .pastdmark  
c480 ..			.dmark: db "FND"  
c483 f1			.pastdmark: pop af  
c484			endm  
# End of macro DMARK
c484						CALLMONITOR 
c484 cd dd 94			call break_point_state  
c487				endm  
# End of macro CALLMONITOR
c487					endif 
c487			 
c487			; TODO check string type 
c487					FORTH_DSP_VALUE 
c487 cd 33 9d			call macro_forth_dsp_value 
c48a				endm 
# End of macro FORTH_DSP_VALUE
c48a			 
c48a e5					push hl    
c48b 7e					ld a,(hl)    ; char to find   
c48c			; TODO change char to substr 
c48c			 
c48c f5					push af 
c48d					 
c48d			 
c48d			 
c48d					if DEBUG_FORTH_WORDS 
c48d						DMARK "FN1" 
c48d f5				push af  
c48e 3a a2 c4			ld a, (.dmark)  
c491 32 71 ee			ld (debug_mark),a  
c494 3a a3 c4			ld a, (.dmark+1)  
c497 32 72 ee			ld (debug_mark+1),a  
c49a 3a a4 c4			ld a, (.dmark+2)  
c49d 32 73 ee			ld (debug_mark+2),a  
c4a0 18 03			jr .pastdmark  
c4a2 ..			.dmark: db "FN1"  
c4a5 f1			.pastdmark: pop af  
c4a6			endm  
# End of macro DMARK
c4a6						CALLMONITOR 
c4a6 cd dd 94			call break_point_state  
c4a9				endm  
# End of macro CALLMONITOR
c4a9					endif 
c4a9			 
c4a9					FORTH_DSP_POP 
c4a9 cd 02 9e			call macro_forth_dsp_pop 
c4ac				endm 
# End of macro FORTH_DSP_POP
c4ac			 
c4ac					; string to search 
c4ac			 
c4ac					FORTH_DSP_VALUE 
c4ac cd 33 9d			call macro_forth_dsp_value 
c4af				endm 
# End of macro FORTH_DSP_VALUE
c4af			 
c4af d1					pop de  ; d is char to find  
c4b0			 
c4b0					if DEBUG_FORTH_WORDS 
c4b0						DMARK "FN2" 
c4b0 f5				push af  
c4b1 3a c5 c4			ld a, (.dmark)  
c4b4 32 71 ee			ld (debug_mark),a  
c4b7 3a c6 c4			ld a, (.dmark+1)  
c4ba 32 72 ee			ld (debug_mark+1),a  
c4bd 3a c7 c4			ld a, (.dmark+2)  
c4c0 32 73 ee			ld (debug_mark+2),a  
c4c3 18 03			jr .pastdmark  
c4c5 ..			.dmark: db "FN2"  
c4c8 f1			.pastdmark: pop af  
c4c9			endm  
# End of macro DMARK
c4c9						CALLMONITOR 
c4c9 cd dd 94			call break_point_state  
c4cc				endm  
# End of macro CALLMONITOR
c4cc					endif 
c4cc					 
c4cc 01 00 00				ld bc, 0 
c4cf 7e			.findchar:      ld a,(hl) 
c4d0 fe 00				cp 0   		 
c4d2 28 27				jr z, .finddone     
c4d4 ba					cp d 
c4d5 28 20				jr z, .foundchar 
c4d7 03					inc bc 
c4d8 23					inc hl 
c4d9					if DEBUG_FORTH_WORDS 
c4d9						DMARK "FN3" 
c4d9 f5				push af  
c4da 3a ee c4			ld a, (.dmark)  
c4dd 32 71 ee			ld (debug_mark),a  
c4e0 3a ef c4			ld a, (.dmark+1)  
c4e3 32 72 ee			ld (debug_mark+1),a  
c4e6 3a f0 c4			ld a, (.dmark+2)  
c4e9 32 73 ee			ld (debug_mark+2),a  
c4ec 18 03			jr .pastdmark  
c4ee ..			.dmark: db "FN3"  
c4f1 f1			.pastdmark: pop af  
c4f2			endm  
# End of macro DMARK
c4f2						CALLMONITOR 
c4f2 cd dd 94			call break_point_state  
c4f5				endm  
# End of macro CALLMONITOR
c4f5					endif 
c4f5 18 d8				jr .findchar 
c4f7			 
c4f7			 
c4f7 c5			.foundchar:	push bc 
c4f8 e1					pop hl 
c4f9 18 03				jr .findexit 
c4fb			 
c4fb			 
c4fb							 
c4fb			 
c4fb			.finddone:     ; got to end of string with no find 
c4fb 21 00 00				ld hl, 0 
c4fe			.findexit: 
c4fe			 
c4fe					if DEBUG_FORTH_WORDS 
c4fe						DMARK "FNd" 
c4fe f5				push af  
c4ff 3a 13 c5			ld a, (.dmark)  
c502 32 71 ee			ld (debug_mark),a  
c505 3a 14 c5			ld a, (.dmark+1)  
c508 32 72 ee			ld (debug_mark+1),a  
c50b 3a 15 c5			ld a, (.dmark+2)  
c50e 32 73 ee			ld (debug_mark+2),a  
c511 18 03			jr .pastdmark  
c513 ..			.dmark: db "FNd"  
c516 f1			.pastdmark: pop af  
c517			endm  
# End of macro DMARK
c517						CALLMONITOR 
c517 cd dd 94			call break_point_state  
c51a				endm  
# End of macro CALLMONITOR
c51a					endif 
c51a cd 53 9b			call forth_push_numhl 
c51d			 
c51d				       NEXTW 
c51d c3 00 9f			jp macro_next 
c520				endm 
# End of macro NEXTW
c520			 
c520			.LEN: 
c520				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c520 4c				db WORD_SYS_CORE+56             
c521 8a c5			dw .ASC            
c523 06				db 5 + 1 
c524 .. 00			db "COUNT",0              
c52a				endm 
# End of macro CWHEAD
c52a			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c52a			 
c52a					if DEBUG_FORTH_WORDS_KEY 
c52a						DMARK "CNT" 
c52a f5				push af  
c52b 3a 3f c5			ld a, (.dmark)  
c52e 32 71 ee			ld (debug_mark),a  
c531 3a 40 c5			ld a, (.dmark+1)  
c534 32 72 ee			ld (debug_mark+1),a  
c537 3a 41 c5			ld a, (.dmark+2)  
c53a 32 73 ee			ld (debug_mark+2),a  
c53d 18 03			jr .pastdmark  
c53f ..			.dmark: db "CNT"  
c542 f1			.pastdmark: pop af  
c543			endm  
# End of macro DMARK
c543						CALLMONITOR 
c543 cd dd 94			call break_point_state  
c546				endm  
# End of macro CALLMONITOR
c546					endif 
c546			; TODO check string type 
c546					FORTH_DSP_VALUE 
c546 cd 33 9d			call macro_forth_dsp_value 
c549				endm 
# End of macro FORTH_DSP_VALUE
c549			 
c549			 
c549					if DEBUG_FORTH_WORDS 
c549						DMARK "CN?" 
c549 f5				push af  
c54a 3a 5e c5			ld a, (.dmark)  
c54d 32 71 ee			ld (debug_mark),a  
c550 3a 5f c5			ld a, (.dmark+1)  
c553 32 72 ee			ld (debug_mark+1),a  
c556 3a 60 c5			ld a, (.dmark+2)  
c559 32 73 ee			ld (debug_mark+2),a  
c55c 18 03			jr .pastdmark  
c55e ..			.dmark: db "CN?"  
c561 f1			.pastdmark: pop af  
c562			endm  
# End of macro DMARK
c562						CALLMONITOR 
c562 cd dd 94			call break_point_state  
c565				endm  
# End of macro CALLMONITOR
c565					endif 
c565 cd 3a 91				call strlenz 
c568					if DEBUG_FORTH_WORDS 
c568						DMARK "CNl" 
c568 f5				push af  
c569 3a 7d c5			ld a, (.dmark)  
c56c 32 71 ee			ld (debug_mark),a  
c56f 3a 7e c5			ld a, (.dmark+1)  
c572 32 72 ee			ld (debug_mark+1),a  
c575 3a 7f c5			ld a, (.dmark+2)  
c578 32 73 ee			ld (debug_mark+2),a  
c57b 18 03			jr .pastdmark  
c57d ..			.dmark: db "CNl"  
c580 f1			.pastdmark: pop af  
c581			endm  
# End of macro DMARK
c581						CALLMONITOR 
c581 cd dd 94			call break_point_state  
c584				endm  
# End of macro CALLMONITOR
c584					endif 
c584			 
c584 cd 53 9b				call forth_push_numhl 
c587			 
c587			 
c587			 
c587				       NEXTW 
c587 c3 00 9f			jp macro_next 
c58a				endm 
# End of macro NEXTW
c58a			.ASC: 
c58a				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c58a 4d				db WORD_SYS_CORE+57             
c58b f8 c5			dw .CHR            
c58d 04				db 3 + 1 
c58e .. 00			db "ASC",0              
c592				endm 
# End of macro CWHEAD
c592			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c592					if DEBUG_FORTH_WORDS_KEY 
c592						DMARK "ASC" 
c592 f5				push af  
c593 3a a7 c5			ld a, (.dmark)  
c596 32 71 ee			ld (debug_mark),a  
c599 3a a8 c5			ld a, (.dmark+1)  
c59c 32 72 ee			ld (debug_mark+1),a  
c59f 3a a9 c5			ld a, (.dmark+2)  
c5a2 32 73 ee			ld (debug_mark+2),a  
c5a5 18 03			jr .pastdmark  
c5a7 ..			.dmark: db "ASC"  
c5aa f1			.pastdmark: pop af  
c5ab			endm  
# End of macro DMARK
c5ab						CALLMONITOR 
c5ab cd dd 94			call break_point_state  
c5ae				endm  
# End of macro CALLMONITOR
c5ae					endif 
c5ae					FORTH_DSP_VALUE 
c5ae cd 33 9d			call macro_forth_dsp_value 
c5b1				endm 
# End of macro FORTH_DSP_VALUE
c5b1					;v5 FORTH_DSP_VALUE 
c5b1			;		inc hl      ; now at start of numeric as string 
c5b1			 
c5b1 e5					push hl 
c5b2			 
c5b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5b2 cd 02 9e			call macro_forth_dsp_pop 
c5b5				endm 
# End of macro FORTH_DSP_POP
c5b5			 
c5b5 e1					pop hl 
c5b6			 
c5b6					if DEBUG_FORTH_WORDS 
c5b6						DMARK "AS1" 
c5b6 f5				push af  
c5b7 3a cb c5			ld a, (.dmark)  
c5ba 32 71 ee			ld (debug_mark),a  
c5bd 3a cc c5			ld a, (.dmark+1)  
c5c0 32 72 ee			ld (debug_mark+1),a  
c5c3 3a cd c5			ld a, (.dmark+2)  
c5c6 32 73 ee			ld (debug_mark+2),a  
c5c9 18 03			jr .pastdmark  
c5cb ..			.dmark: db "AS1"  
c5ce f1			.pastdmark: pop af  
c5cf			endm  
# End of macro DMARK
c5cf						CALLMONITOR 
c5cf cd dd 94			call break_point_state  
c5d2				endm  
# End of macro CALLMONITOR
c5d2					endif 
c5d2					; push the content of a onto the stack as a value 
c5d2			 
c5d2 7e					ld a,(hl)   ; get char 
c5d3 26 00				ld h,0 
c5d5 6f					ld l,a 
c5d6					if DEBUG_FORTH_WORDS 
c5d6						DMARK "AS2" 
c5d6 f5				push af  
c5d7 3a eb c5			ld a, (.dmark)  
c5da 32 71 ee			ld (debug_mark),a  
c5dd 3a ec c5			ld a, (.dmark+1)  
c5e0 32 72 ee			ld (debug_mark+1),a  
c5e3 3a ed c5			ld a, (.dmark+2)  
c5e6 32 73 ee			ld (debug_mark+2),a  
c5e9 18 03			jr .pastdmark  
c5eb ..			.dmark: db "AS2"  
c5ee f1			.pastdmark: pop af  
c5ef			endm  
# End of macro DMARK
c5ef						CALLMONITOR 
c5ef cd dd 94			call break_point_state  
c5f2				endm  
# End of macro CALLMONITOR
c5f2					endif 
c5f2 cd 53 9b				call forth_push_numhl 
c5f5			 
c5f5				       NEXTW 
c5f5 c3 00 9f			jp macro_next 
c5f8				endm 
# End of macro NEXTW
c5f8			 
c5f8			.CHR: 
c5f8				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c5f8 4d				db WORD_SYS_CORE+57             
c5f9 34 c6			dw .ENDSTR            
c5fb 04				db 3 + 1 
c5fc .. 00			db "CHR",0              
c600				endm 
# End of macro CWHEAD
c600			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c600					if DEBUG_FORTH_WORDS_KEY 
c600						DMARK "CHR" 
c600 f5				push af  
c601 3a 15 c6			ld a, (.dmark)  
c604 32 71 ee			ld (debug_mark),a  
c607 3a 16 c6			ld a, (.dmark+1)  
c60a 32 72 ee			ld (debug_mark+1),a  
c60d 3a 17 c6			ld a, (.dmark+2)  
c610 32 73 ee			ld (debug_mark+2),a  
c613 18 03			jr .pastdmark  
c615 ..			.dmark: db "CHR"  
c618 f1			.pastdmark: pop af  
c619			endm  
# End of macro DMARK
c619						CALLMONITOR 
c619 cd dd 94			call break_point_state  
c61c				endm  
# End of macro CALLMONITOR
c61c					endif 
c61c					FORTH_DSP_VALUEHL 
c61c cd 4a 9d			call macro_dsp_valuehl 
c61f				endm 
# End of macro FORTH_DSP_VALUEHL
c61f			 
c61f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c61f cd 02 9e			call macro_forth_dsp_pop 
c622				endm 
# End of macro FORTH_DSP_POP
c622			 
c622					; save asci byte as a zero term string and push string 
c622			 
c622 7d					ld a,l 
c623 32 c7 e2				ld (scratch), a 
c626			 
c626 3e 00				ld a, 0 
c628 32 c8 e2				ld (scratch+1), a 
c62b			 
c62b 21 c7 e2				ld hl, scratch 
c62e cd c1 9b				call forth_push_str 
c631			 
c631			 
c631				       NEXTW 
c631 c3 00 9f			jp macro_next 
c634				endm 
# End of macro NEXTW
c634			 
c634			 
c634			 
c634			 
c634			.ENDSTR: 
c634			; eof 
c634			 
# End of file forth_words_str.asm
c634			include "forth_words_key.asm" 
c634			 
c634			; | ## Keyboard Words 
c634			 
c634			.KEY: 
c634				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c634 3e				db WORD_SYS_CORE+42             
c635 64 c6			dw .WAITK            
c637 04				db 3 + 1 
c638 .. 00			db "KEY",0              
c63c				endm 
# End of macro CWHEAD
c63c			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c63c			 
c63c					if DEBUG_FORTH_WORDS_KEY 
c63c						DMARK "KEY" 
c63c f5				push af  
c63d 3a 51 c6			ld a, (.dmark)  
c640 32 71 ee			ld (debug_mark),a  
c643 3a 52 c6			ld a, (.dmark+1)  
c646 32 72 ee			ld (debug_mark+1),a  
c649 3a 53 c6			ld a, (.dmark+2)  
c64c 32 73 ee			ld (debug_mark+2),a  
c64f 18 03			jr .pastdmark  
c651 ..			.dmark: db "KEY"  
c654 f1			.pastdmark: pop af  
c655			endm  
# End of macro DMARK
c655						CALLMONITOR 
c655 cd dd 94			call break_point_state  
c658				endm  
# End of macro CALLMONITOR
c658					endif 
c658			; TODO currently waits 
c658 cd 46 e3				call cin 
c65b					;call cin_wait 
c65b 6f					ld l, a 
c65c 26 00				ld h, 0 
c65e cd 53 9b				call forth_push_numhl 
c661					NEXTW 
c661 c3 00 9f			jp macro_next 
c664				endm 
# End of macro NEXTW
c664			.WAITK: 
c664				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c664 3f				db WORD_SYS_CORE+43             
c665 96 c6			dw .ACCEPT            
c667 06				db 5 + 1 
c668 .. 00			db "WAITK",0              
c66e				endm 
# End of macro CWHEAD
c66e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c66e					if DEBUG_FORTH_WORDS_KEY 
c66e						DMARK "WAI" 
c66e f5				push af  
c66f 3a 83 c6			ld a, (.dmark)  
c672 32 71 ee			ld (debug_mark),a  
c675 3a 84 c6			ld a, (.dmark+1)  
c678 32 72 ee			ld (debug_mark+1),a  
c67b 3a 85 c6			ld a, (.dmark+2)  
c67e 32 73 ee			ld (debug_mark+2),a  
c681 18 03			jr .pastdmark  
c683 ..			.dmark: db "WAI"  
c686 f1			.pastdmark: pop af  
c687			endm  
# End of macro DMARK
c687						CALLMONITOR 
c687 cd dd 94			call break_point_state  
c68a				endm  
# End of macro CALLMONITOR
c68a					endif 
c68a cd 40 e3				call cin_wait 
c68d 6f					ld l, a 
c68e 26 00				ld h, 0 
c690 cd 53 9b				call forth_push_numhl 
c693					NEXTW 
c693 c3 00 9f			jp macro_next 
c696				endm 
# End of macro NEXTW
c696			.ACCEPT: 
c696				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c696 40				db WORD_SYS_CORE+44             
c697 f4 c6			dw .EDIT            
c699 07				db 6 + 1 
c69a .. 00			db "ACCEPT",0              
c6a1				endm 
# End of macro CWHEAD
c6a1			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6a1					; TODO crashes on push 
c6a1					if DEBUG_FORTH_WORDS_KEY 
c6a1						DMARK "ACC" 
c6a1 f5				push af  
c6a2 3a b6 c6			ld a, (.dmark)  
c6a5 32 71 ee			ld (debug_mark),a  
c6a8 3a b7 c6			ld a, (.dmark+1)  
c6ab 32 72 ee			ld (debug_mark+1),a  
c6ae 3a b8 c6			ld a, (.dmark+2)  
c6b1 32 73 ee			ld (debug_mark+2),a  
c6b4 18 03			jr .pastdmark  
c6b6 ..			.dmark: db "ACC"  
c6b9 f1			.pastdmark: pop af  
c6ba			endm  
# End of macro DMARK
c6ba						CALLMONITOR 
c6ba cd dd 94			call break_point_state  
c6bd				endm  
# End of macro CALLMONITOR
c6bd					endif 
c6bd 21 c5 e4				ld hl, os_input 
c6c0 3e 00				ld a, 0 
c6c2 77					ld (hl),a 
c6c3 3a 64 ea				ld a,(f_cursor_ptr) 
c6c6 16 64				ld d, 100 
c6c8 0e 00				ld c, 0 
c6ca 1e 28				ld e, 40 
c6cc cd 09 8d				call input_str 
c6cf					; TODO perhaps do a type check and wrap in quotes if not a number 
c6cf 21 c5 e4				ld hl, os_input 
c6d2					if DEBUG_FORTH_WORDS 
c6d2						DMARK "AC1" 
c6d2 f5				push af  
c6d3 3a e7 c6			ld a, (.dmark)  
c6d6 32 71 ee			ld (debug_mark),a  
c6d9 3a e8 c6			ld a, (.dmark+1)  
c6dc 32 72 ee			ld (debug_mark+1),a  
c6df 3a e9 c6			ld a, (.dmark+2)  
c6e2 32 73 ee			ld (debug_mark+2),a  
c6e5 18 03			jr .pastdmark  
c6e7 ..			.dmark: db "AC1"  
c6ea f1			.pastdmark: pop af  
c6eb			endm  
# End of macro DMARK
c6eb						CALLMONITOR 
c6eb cd dd 94			call break_point_state  
c6ee				endm  
# End of macro CALLMONITOR
c6ee					endif 
c6ee cd c1 9b				call forth_push_str 
c6f1					NEXTW 
c6f1 c3 00 9f			jp macro_next 
c6f4				endm 
# End of macro NEXTW
c6f4			 
c6f4			.EDIT: 
c6f4				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c6f4 40				db WORD_SYS_CORE+44             
c6f5 96 c7			dw .DEDIT            
c6f7 05				db 4 + 1 
c6f8 .. 00			db "EDIT",0              
c6fd				endm 
# End of macro CWHEAD
c6fd			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c6fd			 
c6fd					; TODO does not copy from stack 
c6fd					if DEBUG_FORTH_WORDS_KEY 
c6fd						DMARK "EDT" 
c6fd f5				push af  
c6fe 3a 12 c7			ld a, (.dmark)  
c701 32 71 ee			ld (debug_mark),a  
c704 3a 13 c7			ld a, (.dmark+1)  
c707 32 72 ee			ld (debug_mark+1),a  
c70a 3a 14 c7			ld a, (.dmark+2)  
c70d 32 73 ee			ld (debug_mark+2),a  
c710 18 03			jr .pastdmark  
c712 ..			.dmark: db "EDT"  
c715 f1			.pastdmark: pop af  
c716			endm  
# End of macro DMARK
c716						CALLMONITOR 
c716 cd dd 94			call break_point_state  
c719				endm  
# End of macro CALLMONITOR
c719					endif 
c719			 
c719					;FORTH_DSP 
c719					FORTH_DSP_VALUEHL 
c719 cd 4a 9d			call macro_dsp_valuehl 
c71c				endm 
# End of macro FORTH_DSP_VALUEHL
c71c			;		inc hl    ; TODO do type check 
c71c			 
c71c			;		call get_word_hl 
c71c e5					push hl 
c71d					if DEBUG_FORTH_WORDS 
c71d						DMARK "EDp" 
c71d f5				push af  
c71e 3a 32 c7			ld a, (.dmark)  
c721 32 71 ee			ld (debug_mark),a  
c724 3a 33 c7			ld a, (.dmark+1)  
c727 32 72 ee			ld (debug_mark+1),a  
c72a 3a 34 c7			ld a, (.dmark+2)  
c72d 32 73 ee			ld (debug_mark+2),a  
c730 18 03			jr .pastdmark  
c732 ..			.dmark: db "EDp"  
c735 f1			.pastdmark: pop af  
c736			endm  
# End of macro DMARK
c736						CALLMONITOR 
c736 cd dd 94			call break_point_state  
c739				endm  
# End of macro CALLMONITOR
c739					endif 
c739				;	ld a, 0 
c739 cd 3a 91				call strlenz 
c73c 23					inc hl 
c73d			 
c73d 06 00				ld b, 0 
c73f 4d					ld c, l 
c740			 
c740 e1					pop hl 
c741 11 c5 e4				ld de, os_input 
c744					if DEBUG_FORTH_WORDS_KEY 
c744						DMARK "EDc" 
c744 f5				push af  
c745 3a 59 c7			ld a, (.dmark)  
c748 32 71 ee			ld (debug_mark),a  
c74b 3a 5a c7			ld a, (.dmark+1)  
c74e 32 72 ee			ld (debug_mark+1),a  
c751 3a 5b c7			ld a, (.dmark+2)  
c754 32 73 ee			ld (debug_mark+2),a  
c757 18 03			jr .pastdmark  
c759 ..			.dmark: db "EDc"  
c75c f1			.pastdmark: pop af  
c75d			endm  
# End of macro DMARK
c75d						CALLMONITOR 
c75d cd dd 94			call break_point_state  
c760				endm  
# End of macro CALLMONITOR
c760					endif 
c760 ed b0				ldir 
c762			 
c762			 
c762 21 c5 e4				ld hl, os_input 
c765					;ld a, 0 
c765					;ld (hl),a 
c765 3a 64 ea				ld a,(f_cursor_ptr) 
c768 16 64				ld d, 100 
c76a 0e 00				ld c, 0 
c76c 1e 28				ld e, 40 
c76e cd 09 8d				call input_str 
c771					; TODO perhaps do a type check and wrap in quotes if not a number 
c771 21 c5 e4				ld hl, os_input 
c774					if DEBUG_FORTH_WORDS 
c774						DMARK "ED1" 
c774 f5				push af  
c775 3a 89 c7			ld a, (.dmark)  
c778 32 71 ee			ld (debug_mark),a  
c77b 3a 8a c7			ld a, (.dmark+1)  
c77e 32 72 ee			ld (debug_mark+1),a  
c781 3a 8b c7			ld a, (.dmark+2)  
c784 32 73 ee			ld (debug_mark+2),a  
c787 18 03			jr .pastdmark  
c789 ..			.dmark: db "ED1"  
c78c f1			.pastdmark: pop af  
c78d			endm  
# End of macro DMARK
c78d						CALLMONITOR 
c78d cd dd 94			call break_point_state  
c790				endm  
# End of macro CALLMONITOR
c790					endif 
c790 cd c1 9b				call forth_push_str 
c793					NEXTW 
c793 c3 00 9f			jp macro_next 
c796				endm 
# End of macro NEXTW
c796			 
c796			.DEDIT: 
c796				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c796 40				db WORD_SYS_CORE+44             
c797 f8 c7			dw .ENDKEY            
c799 06				db 5 + 1 
c79a .. 00			db "DEDIT",0              
c7a0				endm 
# End of macro CWHEAD
c7a0			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7a0			 
c7a0					; TODO does not copy from stack 
c7a0					if DEBUG_FORTH_WORDS_KEY 
c7a0						DMARK "DED" 
c7a0 f5				push af  
c7a1 3a b5 c7			ld a, (.dmark)  
c7a4 32 71 ee			ld (debug_mark),a  
c7a7 3a b6 c7			ld a, (.dmark+1)  
c7aa 32 72 ee			ld (debug_mark+1),a  
c7ad 3a b7 c7			ld a, (.dmark+2)  
c7b0 32 73 ee			ld (debug_mark+2),a  
c7b3 18 03			jr .pastdmark  
c7b5 ..			.dmark: db "DED"  
c7b8 f1			.pastdmark: pop af  
c7b9			endm  
# End of macro DMARK
c7b9						CALLMONITOR 
c7b9 cd dd 94			call break_point_state  
c7bc				endm  
# End of macro CALLMONITOR
c7bc					endif 
c7bc			 
c7bc					;FORTH_DSP 
c7bc					FORTH_DSP_VALUEHL 
c7bc cd 4a 9d			call macro_dsp_valuehl 
c7bf				endm 
# End of macro FORTH_DSP_VALUEHL
c7bf			;		inc hl    ; TODO do type check 
c7bf			 
c7bf			;		call get_word_hl 
c7bf e5					push hl 
c7c0 e5					push hl 
c7c1					FORTH_DSP_POP 
c7c1 cd 02 9e			call macro_forth_dsp_pop 
c7c4				endm 
# End of macro FORTH_DSP_POP
c7c4 e1					pop hl 
c7c5					if DEBUG_FORTH_WORDS 
c7c5						DMARK "EDp" 
c7c5 f5				push af  
c7c6 3a da c7			ld a, (.dmark)  
c7c9 32 71 ee			ld (debug_mark),a  
c7cc 3a db c7			ld a, (.dmark+1)  
c7cf 32 72 ee			ld (debug_mark+1),a  
c7d2 3a dc c7			ld a, (.dmark+2)  
c7d5 32 73 ee			ld (debug_mark+2),a  
c7d8 18 03			jr .pastdmark  
c7da ..			.dmark: db "EDp"  
c7dd f1			.pastdmark: pop af  
c7de			endm  
# End of macro DMARK
c7de						CALLMONITOR 
c7de cd dd 94			call break_point_state  
c7e1				endm  
# End of macro CALLMONITOR
c7e1					endif 
c7e1				;	ld a, 0 
c7e1 cd 3a 91				call strlenz 
c7e4 23					inc hl 
c7e5			 
c7e5 06 00				ld b, 0 
c7e7 4d					ld c, l 
c7e8			 
c7e8 e1					pop hl 
c7e9			 
c7e9					;ld a, 0 
c7e9					;ld (hl),a 
c7e9 3a 64 ea				ld a,(f_cursor_ptr) 
c7ec 16 64				ld d, 100 
c7ee 0e 00				ld c, 0 
c7f0 1e 28				ld e, 40 
c7f2 cd 09 8d				call input_str 
c7f5					; TODO perhaps do a type check and wrap in quotes if not a number 
c7f5					NEXTW 
c7f5 c3 00 9f			jp macro_next 
c7f8				endm 
# End of macro NEXTW
c7f8			 
c7f8			 
c7f8			.ENDKEY: 
c7f8			; eof 
c7f8			 
# End of file forth_words_key.asm
c7f8			include "forth_words_const.asm" 
c7f8			 
c7f8			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c7f8			 
c7f8			 
c7f8			.SPITIME: 
c7f8				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c7f8 77				db WORD_SYS_CORE+99             
c7f9 0d c8			dw .VA            
c7fb 08				db 7 + 1 
c7fc .. 00			db "SPITIME",0              
c804				endm 
# End of macro CWHEAD
c804			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c804			; 
c804			; | If using BANK devices then leave as is. 
c804			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c804			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c804			 
c804 21 6a ea				ld hl, spi_clktime  
c807 cd 53 9b				call forth_push_numhl 
c80a			 
c80a					NEXTW 
c80a c3 00 9f			jp macro_next 
c80d				endm 
# End of macro NEXTW
c80d			 
c80d			 
c80d			.VA: 
c80d				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c80d 77				db WORD_SYS_CORE+99             
c80e 1d c8			dw .SYMBOL            
c810 03				db 2 + 1 
c811 .. 00			db "VA",0              
c814				endm 
# End of macro CWHEAD
c814			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c814 21 2e ea				ld hl, cli_var_array 
c817 cd 53 9b				call forth_push_numhl 
c81a			 
c81a					NEXTW 
c81a c3 00 9f			jp macro_next 
c81d				endm 
# End of macro NEXTW
c81d			 
c81d			.SYMBOL: 
c81d				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c81d 77				db WORD_SYS_CORE+99             
c81e 55 c9			dw .ENDCONST            
c820 07				db 6 + 1 
c821 .. 00			db "SYMBOL",0              
c828				endm 
# End of macro CWHEAD
c828			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c828			; | 
c828			; | The value is the number reference and the final address is pushed to stack 
c828			 
c828					if DEBUG_FORTH_WORDS_KEY 
c828						DMARK "SYM" 
c828 f5				push af  
c829 3a 3d c8			ld a, (.dmark)  
c82c 32 71 ee			ld (debug_mark),a  
c82f 3a 3e c8			ld a, (.dmark+1)  
c832 32 72 ee			ld (debug_mark+1),a  
c835 3a 3f c8			ld a, (.dmark+2)  
c838 32 73 ee			ld (debug_mark+2),a  
c83b 18 03			jr .pastdmark  
c83d ..			.dmark: db "SYM"  
c840 f1			.pastdmark: pop af  
c841			endm  
# End of macro DMARK
c841						CALLMONITOR 
c841 cd dd 94			call break_point_state  
c844				endm  
# End of macro CALLMONITOR
c844					endif 
c844			 
c844					FORTH_DSP_VALUEHL 
c844 cd 4a 9d			call macro_dsp_valuehl 
c847				endm 
# End of macro FORTH_DSP_VALUEHL
c847			 
c847 7d					ld a, l     
c848			 
c848			 
c848					if DEBUG_FORTH_WORDS 
c848						DMARK "SY1" 
c848 f5				push af  
c849 3a 5d c8			ld a, (.dmark)  
c84c 32 71 ee			ld (debug_mark),a  
c84f 3a 5e c8			ld a, (.dmark+1)  
c852 32 72 ee			ld (debug_mark+1),a  
c855 3a 5f c8			ld a, (.dmark+2)  
c858 32 73 ee			ld (debug_mark+2),a  
c85b 18 03			jr .pastdmark  
c85d ..			.dmark: db "SY1"  
c860 f1			.pastdmark: pop af  
c861			endm  
# End of macro DMARK
c861						CALLMONITOR 
c861 cd dd 94			call break_point_state  
c864				endm  
# End of macro CALLMONITOR
c864					endif 
c864					 
c864 f5					push af	 
c865					FORTH_DSP_POP 
c865 cd 02 9e			call macro_forth_dsp_pop 
c868				endm 
# End of macro FORTH_DSP_POP
c868 f1					pop af 
c869			 
c869 cb 27				sla a  
c86b				 
c86b					 
c86b					if DEBUG_FORTH_WORDS 
c86b						DMARK "SY" 
c86b f5				push af  
c86c 3a 80 c8			ld a, (.dmark)  
c86f 32 71 ee			ld (debug_mark),a  
c872 3a 81 c8			ld a, (.dmark+1)  
c875 32 72 ee			ld (debug_mark+1),a  
c878 3a 82 c8			ld a, (.dmark+2)  
c87b 32 73 ee			ld (debug_mark+2),a  
c87e 18 02			jr .pastdmark  
c880 ..			.dmark: db "SY"  
c882 f1			.pastdmark: pop af  
c883			endm  
# End of macro DMARK
c883						CALLMONITOR 
c883 cd dd 94			call break_point_state  
c886				endm  
# End of macro CALLMONITOR
c886					endif 
c886			 
c886 21 95 c8				ld hl, sym_table 
c889 cd dc 8c				call addatohl 
c88c cd 82 9e				call loadwordinhl 
c88f cd 53 9b				call forth_push_numhl 
c892			 
c892			 
c892				       NEXTW 
c892 c3 00 9f			jp macro_next 
c895				endm 
# End of macro NEXTW
c895			 
c895			sym_table: 
c895			 
c895			; 0 
c895 42 ea		dw cli_autodisplay 
c897 50 ea		dw cli_buffer 
c899 f4 e9		dw cli_data_sp 
c89b 2e e8		dw cli_data_stack 
c89d 4a ea		dw cli_execword 
c89f f6 e9		dw cli_loop_sp 
c8a1 30 e9		dw cli_loop_stack 
c8a3 43 ea		dw cli_mvdot 
c8a5 48 ea		dw cli_nextword 
c8a7 44 ea		dw cli_origptr 
c8a9 4e ea		dw cli_origtoken 
c8ab			; 11 
c8ab 46 ea		dw cli_ptr 
c8ad f8 e9		dw cli_ret_sp 
c8af b2 e9		dw cli_ret_stack 
c8b1 4c ea		dw cli_token 
c8b3 2e ea		dw cli_var_array 
c8b5 cb eb		dw cursor_col 
c8b7 c9 eb		dw cursor_ptr 
c8b9 ca eb		dw cursor_row 
c8bb c7 eb		dw cursor_shape 
c8bd 71 ee		dw debug_mark 
c8bf			; 21 
c8bf b7 ed		dw display_fb0 
c8c1 16 ed		dw display_fb1 
c8c3 d4 eb		dw display_fb2 
c8c5 75 ec		dw display_fb3 
c8c7 d2 eb		dw display_fb_active 
c8c9 c6 e3		dw execscratch 
c8cb 64 ea		dw f_cursor_ptr 
c8cd 75 ee		dw hardware_word 
c8cf 68 ee		dw input_at_cursor 
c8d1 6a ee		dw input_at_pos 
c8d3			; 31 
c8d3 66 ee		dw input_cur_flash 
c8d5 65 ee		dw input_cur_onoff 
c8d7 5b ee		dw input_cursor 
c8d9 6b ee		dw input_display_size 
c8db 60 ee		dw input_len 
c8dd 6f ee		dw input_ptr 
c8df 6c ee		dw input_size 
c8e1 6d ee		dw input_start 
c8e3 09 8d		dw input_str 
c8e5 69 ee		dw input_under_cursor 
c8e7			; 41 
c8e7 5a ee		dw key_actual_pressed 
c8e9 85 ee		dw key_fa 
c8eb 81 ee		dw key_face_held 
c8ed 84 ee		dw key_fb 
c8ef 83 ee		dw key_fc 
c8f1 82 ee		dw key_fd 
c8f3 8b ee		dw key_held 
c8f5 8a ee		dw key_held_prev 
c8f7 3f e3		dw key_init 
c8f9 86 ee		dw key_repeat_ct 
c8fb			; 51 
c8fb 05 00		dw key_rows 
c8fd 58 ee		dw key_shift 
c8ff 59 ee		dw key_symbol 
c901 8c ee		dw keyscan_scancol 
c903 96 ee		dw keyscan_table 
c905 f5 ee		dw keyscan_table_row1 
c907 ea ee		dw keyscan_table_row2 
c909 df ee		dw keyscan_table_row3 
c90b d4 ee		dw keyscan_table_row4 
c90d c9 ee		dw keyscan_table_row5 
c90f			; 61 
c90f ee e5		dw os_cli_cmd 
c911 ea e5		dw os_cur_ptr 
c913 ec e5		dw os_current_i 
c915 c5 e4		dw os_input 
c917 ed e6		dw os_last_cmd 
c919 c4 e5		dw os_last_new_uword 
c91b b8 e2		dw os_view_disable 
c91d b4 e2		dw os_view_hl 
c91f cc e5		dw os_word_scratch 
c921 c3 00		dw portbctl 
c923			; 71 
c923 c1 00		dw portbdata 
c925 69 ea		dw spi_cartdev 
c927 68 ea		dw spi_cartdev2 
c929 6a ea		dw spi_clktime 
c92b 66 ea		dw spi_device 
c92d 65 ea		dw spi_device_id 
c92f 67 ea		dw spi_portbyte 
c931 ad eb		dw stackstore 
c933			if STORAGE_SE 
c933			dw storage_actl 
c933			dw storage_adata 
c933			else 
c933 00 00		dw 0 
c935 00 00		dw 0 
c937			endif 
c937			; 81 
c937 69 88		dw storage_append 
c939			if STORAGE_SE 
c939			dw storage_bctl 
c939			else 
c939 00 00		dw 0 
c93b			endif 
c93b 99 eb		dw store_bank_active 
c93d 6d ea		dw store_filecache 
c93f 7b ea		dw store_longread 
c941 71 ea		dw store_openaddr 
c943 70 ea		dw store_openext 
c945 6f ea		dw store_openmaxext 
c947 80 ea		dw store_page 
c949 7c ea		dw store_readbuf 
c94b			; 91 
c94b 73 ea		dw store_readcont 
c94d 7e ea		dw store_readptr 
c94f 73 ea		dw store_tmpext 
c951 74 ea		dw store_tmpid 
c953 6b ea		dw store_tmppageid 
c955			 
c955			 
c955			.ENDCONST: 
c955			 
c955			; eof 
c955			 
c955			 
# End of file forth_words_const.asm
c955			 
c955			if STORAGE_SE 
c955			   	include "forth_words_storage.asm" 
c955			endif 
c955				include "forth_words_device.asm" 
c955			; Device related words 
c955			 
c955			; | ## Device Words 
c955			 
c955			;if SOUND_ENABLE 
c955			;.NOTE: 
c955			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c955			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c955			;		if DEBUG_FORTH_WORDS_KEY 
c955			;			DMARK "NTE" 
c955			;			CALLMONITOR 
c955			;		endif 
c955			; 
c955			;	 
c955			; 
c955			;		NEXTW 
c955			;.AFTERSOUND: 
c955			;endif 
c955			 
c955			 
c955			USE_GPIO: equ 0 
c955			 
c955			if USE_GPIO 
c955			.GP1: 
c955				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c955			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c955					NEXTW 
c955			.GP2: 
c955				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c955			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c955			 
c955					NEXTW 
c955			 
c955			.GP3: 
c955				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c955			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c955			 
c955					NEXTW 
c955			 
c955			.GP4: 
c955				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c955			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c955			 
c955					NEXTW 
c955			.SIN: 
c955			 
c955			 
c955			endif 
c955			 
c955			 
c955				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c955 33				db WORD_SYS_CORE+31             
c956 8a c9			dw .SOUT            
c958 03				db 2 + 1 
c959 .. 00			db "IN",0              
c95c				endm 
# End of macro CWHEAD
c95c			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c95c					if DEBUG_FORTH_WORDS_KEY 
c95c						DMARK "IN." 
c95c f5				push af  
c95d 3a 71 c9			ld a, (.dmark)  
c960 32 71 ee			ld (debug_mark),a  
c963 3a 72 c9			ld a, (.dmark+1)  
c966 32 72 ee			ld (debug_mark+1),a  
c969 3a 73 c9			ld a, (.dmark+2)  
c96c 32 73 ee			ld (debug_mark+2),a  
c96f 18 03			jr .pastdmark  
c971 ..			.dmark: db "IN."  
c974 f1			.pastdmark: pop af  
c975			endm  
# End of macro DMARK
c975						CALLMONITOR 
c975 cd dd 94			call break_point_state  
c978				endm  
# End of macro CALLMONITOR
c978					endif 
c978					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c978 cd 4a 9d			call macro_dsp_valuehl 
c97b				endm 
# End of macro FORTH_DSP_VALUEHL
c97b			 
c97b e5					push hl 
c97c			 
c97c					; destroy value TOS 
c97c			 
c97c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c97c cd 02 9e			call macro_forth_dsp_pop 
c97f				endm 
# End of macro FORTH_DSP_POP
c97f			 
c97f					; one value on hl get other one back 
c97f			 
c97f c1					pop bc 
c980			 
c980					; do the sub 
c980			;		ex de, hl 
c980			 
c980 ed 68				in l,(c) 
c982			 
c982					; save it 
c982			 
c982 26 00				ld h,0 
c984			 
c984					; TODO push value back onto stack for another op etc 
c984			 
c984 cd 53 9b				call forth_push_numhl 
c987					NEXTW 
c987 c3 00 9f			jp macro_next 
c98a				endm 
# End of macro NEXTW
c98a			.SOUT: 
c98a				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c98a 34				db WORD_SYS_CORE+32             
c98b dd c9			dw .SPIO            
c98d 04				db 3 + 1 
c98e .. 00			db "OUT",0              
c992				endm 
# End of macro CWHEAD
c992			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c992					if DEBUG_FORTH_WORDS_KEY 
c992						DMARK "OUT" 
c992 f5				push af  
c993 3a a7 c9			ld a, (.dmark)  
c996 32 71 ee			ld (debug_mark),a  
c999 3a a8 c9			ld a, (.dmark+1)  
c99c 32 72 ee			ld (debug_mark+1),a  
c99f 3a a9 c9			ld a, (.dmark+2)  
c9a2 32 73 ee			ld (debug_mark+2),a  
c9a5 18 03			jr .pastdmark  
c9a7 ..			.dmark: db "OUT"  
c9aa f1			.pastdmark: pop af  
c9ab			endm  
# End of macro DMARK
c9ab						CALLMONITOR 
c9ab cd dd 94			call break_point_state  
c9ae				endm  
# End of macro CALLMONITOR
c9ae					endif 
c9ae			 
c9ae					; get port 
c9ae			 
c9ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9ae cd 4a 9d			call macro_dsp_valuehl 
c9b1				endm 
# End of macro FORTH_DSP_VALUEHL
c9b1			 
c9b1 e5					push hl 
c9b2			 
c9b2					; destroy value TOS 
c9b2			 
c9b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9b2 cd 02 9e			call macro_forth_dsp_pop 
c9b5				endm 
# End of macro FORTH_DSP_POP
c9b5			 
c9b5					; get byte to send 
c9b5			 
c9b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9b5 cd 4a 9d			call macro_dsp_valuehl 
c9b8				endm 
# End of macro FORTH_DSP_VALUEHL
c9b8			 
c9b8			;		push hl 
c9b8			 
c9b8					; destroy value TOS 
c9b8			 
c9b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9b8 cd 02 9e			call macro_forth_dsp_pop 
c9bb				endm 
# End of macro FORTH_DSP_POP
c9bb			 
c9bb					; one value on hl get other one back 
c9bb			 
c9bb			;		pop hl 
c9bb			 
c9bb c1					pop bc 
c9bc			 
c9bc					if DEBUG_FORTH_WORDS 
c9bc						DMARK "OUT" 
c9bc f5				push af  
c9bd 3a d1 c9			ld a, (.dmark)  
c9c0 32 71 ee			ld (debug_mark),a  
c9c3 3a d2 c9			ld a, (.dmark+1)  
c9c6 32 72 ee			ld (debug_mark+1),a  
c9c9 3a d3 c9			ld a, (.dmark+2)  
c9cc 32 73 ee			ld (debug_mark+2),a  
c9cf 18 03			jr .pastdmark  
c9d1 ..			.dmark: db "OUT"  
c9d4 f1			.pastdmark: pop af  
c9d5			endm  
# End of macro DMARK
c9d5						CALLMONITOR 
c9d5 cd dd 94			call break_point_state  
c9d8				endm  
# End of macro CALLMONITOR
c9d8					endif 
c9d8			 
c9d8 ed 69				out (c), l 
c9da			 
c9da					NEXTW 
c9da c3 00 9f			jp macro_next 
c9dd				endm 
# End of macro NEXTW
c9dd			 
c9dd			 
c9dd			.SPIO: 
c9dd			 
c9dd			if STORAGE_SE 
c9dd				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9dd			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9dd			 
c9dd					call spi_ce_low 
c9dd			    NEXTW 
c9dd			 
c9dd			.SPICEH: 
c9dd				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9dd			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9dd			 
c9dd					call spi_ce_high 
c9dd			    NEXTW 
c9dd			 
c9dd			 
c9dd			.SPIOb: 
c9dd			 
c9dd				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9dd			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9dd			 
c9dd					if DEBUG_FORTH_WORDS_KEY 
c9dd						DMARK "SPo" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd					; get port 
c9dd			 
c9dd			 
c9dd					; get byte to send 
c9dd			 
c9dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9dd			 
c9dd			;		push hl    ; u1  
c9dd			 
c9dd					; destroy value TOS 
c9dd			 
c9dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9dd			 
c9dd					; one value on hl get other one back 
c9dd			 
c9dd			;		pop hl   ; u2 - addr 
c9dd			 
c9dd					; TODO Send SPI byte 
c9dd			 
c9dd			;		push hl 
c9dd			;		call spi_ce_low 
c9dd			;		pop hl 
c9dd					ld a, l 
c9dd					call spi_send_byte 
c9dd			;		call spi_ce_high 
c9dd			 
c9dd					NEXTW 
c9dd			 
c9dd			.SPII: 
c9dd				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9dd			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9dd					if DEBUG_FORTH_WORDS_KEY 
c9dd						DMARK "SPi" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd			 
c9dd					; TODO Get SPI byte 
c9dd			 
c9dd					call spi_read_byte 
c9dd			 
c9dd					if DEBUG_FORTH_WORDS 
c9dd						DMARK "Si2" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd					ld h, 0 
c9dd					ld l, a 
c9dd					if DEBUG_FORTH_WORDS 
c9dd						DMARK "Si3" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd					call forth_push_numhl 
c9dd			 
c9dd					NEXTW 
c9dd			 
c9dd			 
c9dd			 
c9dd			.SESEL: 
c9dd				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9dd			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9dd					if DEBUG_FORTH_WORDS_KEY 
c9dd						DMARK "BNK" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd			 
c9dd					ld a, 255 
c9dd					ld (spi_cartdev), a 
c9dd			 
c9dd					; get bank 
c9dd			 
c9dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9dd			 
c9dd			;		push hl 
c9dd			 
c9dd					; destroy value TOS 
c9dd			 
c9dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9dd			 
c9dd					; one value on hl get other one back 
c9dd			 
c9dd			;		pop hl 
c9dd			 
c9dd			 
c9dd					ld c, SPI_CE_HIGH 
c9dd					ld b, '0'    ; human readable bank number 
c9dd			 
c9dd					ld a, l 
c9dd			 
c9dd					if DEBUG_FORTH_WORDS 
c9dd						DMARK "BNK" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd			 
c9dd					; active low 
c9dd			 
c9dd					cp 0 
c9dd					jr z, .bset 
c9dd					cp 1 
c9dd					jr nz, .b2 
c9dd					res 0, c 
c9dd					ld b, '1'    ; human readable bank number 
c9dd			.b2:		cp 2 
c9dd					jr nz, .b3 
c9dd					res 1, c 
c9dd					ld b, '2'    ; human readable bank number 
c9dd			.b3:		cp 3 
c9dd					jr nz, .b4 
c9dd					res 2, c 
c9dd					ld b, '3'    ; human readable bank number 
c9dd			.b4:		cp 4 
c9dd					jr nz, .b5 
c9dd					res 3, c 
c9dd					ld b, '4'    ; human readable bank number 
c9dd			.b5:		cp 5 
c9dd					jr nz, .bset 
c9dd					res 4, c 
c9dd					ld b, '5'    ; human readable bank number 
c9dd			 
c9dd			.bset: 
c9dd					ld a, c 
c9dd					ld (spi_device),a 
c9dd					ld a, b 
c9dd					ld (spi_device_id),a 
c9dd					if DEBUG_FORTH_WORDS 
c9dd						DMARK "BN2" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd			 
c9dd					; set default SPI clk pulse time as disabled for BANK use 
c9dd			 
c9dd					ld a, 0 
c9dd					ld (spi_clktime), a 
c9dd			 
c9dd					NEXTW 
c9dd			 
c9dd			.CARTDEV: 
c9dd				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9dd			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9dd					if DEBUG_FORTH_WORDS_KEY 
c9dd						DMARK "CDV" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd			 
c9dd					; disable se storage bank selection 
c9dd			 
c9dd					ld a, SPI_CE_HIGH		; ce high 
c9dd					ld (spi_device), a 
c9dd			 
c9dd					; get bank 
c9dd			 
c9dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9dd			 
c9dd			;		push hl 
c9dd			 
c9dd					; destroy value TOS 
c9dd			 
c9dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9dd			 
c9dd					; one value on hl get other one back 
c9dd			 
c9dd			;		pop hl 
c9dd			 
c9dd					; active low 
c9dd			 
c9dd					ld c, 255 
c9dd			 
c9dd					ld a, l 
c9dd					if DEBUG_FORTH_WORDS 
c9dd						DMARK "CDV" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd					cp 0 
c9dd					jr z, .cset 
c9dd					cp 1 
c9dd					jr nz, .c2 
c9dd					res 0, c 
c9dd			.c2:		cp 2 
c9dd					jr nz, .c3 
c9dd					res 1, c 
c9dd			.c3:		cp 3 
c9dd					jr nz, .c4 
c9dd					res 2, c 
c9dd			.c4:		cp 4 
c9dd					jr nz, .c5 
c9dd					res 3, c 
c9dd			.c5:		cp 5 
c9dd					jr nz, .c6 
c9dd					res 4, c 
c9dd			.c6:		cp 6 
c9dd					jr nz, .c7 
c9dd					res 5, c 
c9dd			.c7:		cp 7 
c9dd					jr nz, .c8 
c9dd					res 6, c 
c9dd			.c8:		cp 8 
c9dd					jr nz, .cset 
c9dd					res 7, c 
c9dd			.cset:		ld a, c 
c9dd					ld (spi_cartdev),a 
c9dd			 
c9dd					if DEBUG_FORTH_WORDS 
c9dd						DMARK "CD2" 
c9dd						CALLMONITOR 
c9dd					endif 
c9dd			 
c9dd					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9dd			 
c9dd					ld a, $0a 
c9dd					ld (spi_clktime), a 
c9dd					NEXTW 
c9dd			endif 
c9dd			 
c9dd			.ENDDEVICE: 
c9dd			; eof 
c9dd			 
# End of file forth_words_device.asm
c9dd			 
c9dd			; var handler 
c9dd			 
c9dd			 
c9dd			.VARS: 
c9dd				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9dd 77				db WORD_SYS_CORE+99             
c9de 8e ca			dw .V0            
c9e0 04				db 3 + 1 
c9e1 .. 00			db "VAR",0              
c9e5				endm 
# End of macro CWHEAD
c9e5			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
c9e5			;| 
c9e5			;| The variable name should consist of a single letter. e.g. "a" 
c9e5			;! If a full string is passed then only the first char is looked at 
c9e5			;| Any other char could exceed bounds checks!  
c9e5			 
c9e5					if DEBUG_FORTH_WORDS_KEY 
c9e5						DMARK "VAR" 
c9e5 f5				push af  
c9e6 3a fa c9			ld a, (.dmark)  
c9e9 32 71 ee			ld (debug_mark),a  
c9ec 3a fb c9			ld a, (.dmark+1)  
c9ef 32 72 ee			ld (debug_mark+1),a  
c9f2 3a fc c9			ld a, (.dmark+2)  
c9f5 32 73 ee			ld (debug_mark+2),a  
c9f8 18 03			jr .pastdmark  
c9fa ..			.dmark: db "VAR"  
c9fd f1			.pastdmark: pop af  
c9fe			endm  
# End of macro DMARK
c9fe						CALLMONITOR 
c9fe cd dd 94			call break_point_state  
ca01				endm  
# End of macro CALLMONITOR
ca01					endif 
ca01			 
ca01					FORTH_DSP_VALUEHL 
ca01 cd 4a 9d			call macro_dsp_valuehl 
ca04				endm 
# End of macro FORTH_DSP_VALUEHL
ca04			 
ca04 7e					ld a, (hl)    ; get first char on of the string 
ca05			 
ca05			 
ca05					if DEBUG_FORTH_WORDS 
ca05						DMARK "VR1" 
ca05 f5				push af  
ca06 3a 1a ca			ld a, (.dmark)  
ca09 32 71 ee			ld (debug_mark),a  
ca0c 3a 1b ca			ld a, (.dmark+1)  
ca0f 32 72 ee			ld (debug_mark+1),a  
ca12 3a 1c ca			ld a, (.dmark+2)  
ca15 32 73 ee			ld (debug_mark+2),a  
ca18 18 03			jr .pastdmark  
ca1a ..			.dmark: db "VR1"  
ca1d f1			.pastdmark: pop af  
ca1e			endm  
# End of macro DMARK
ca1e						CALLMONITOR 
ca1e cd dd 94			call break_point_state  
ca21				endm  
# End of macro CALLMONITOR
ca21					endif 
ca21					 
ca21 f5					push af	 
ca22					FORTH_DSP_POP 
ca22 cd 02 9e			call macro_forth_dsp_pop 
ca25				endm 
# End of macro FORTH_DSP_POP
ca25 f1					pop af 
ca26			 
ca26					; convert to upper 
ca26			 
ca26 cd 49 90				call to_upper 
ca29					if DEBUG_FORTH_WORDS 
ca29						DMARK "Vaa" 
ca29 f5				push af  
ca2a 3a 3e ca			ld a, (.dmark)  
ca2d 32 71 ee			ld (debug_mark),a  
ca30 3a 3f ca			ld a, (.dmark+1)  
ca33 32 72 ee			ld (debug_mark+1),a  
ca36 3a 40 ca			ld a, (.dmark+2)  
ca39 32 73 ee			ld (debug_mark+2),a  
ca3c 18 03			jr .pastdmark  
ca3e ..			.dmark: db "Vaa"  
ca41 f1			.pastdmark: pop af  
ca42			endm  
# End of macro DMARK
ca42						CALLMONITOR 
ca42 cd dd 94			call break_point_state  
ca45				endm  
# End of macro CALLMONITOR
ca45					endif 
ca45 06 41				ld b, 'A' 
ca47 90					sub b			; set offset 
ca48					if DEBUG_FORTH_WORDS 
ca48						DMARK "Vbb" 
ca48 f5				push af  
ca49 3a 5d ca			ld a, (.dmark)  
ca4c 32 71 ee			ld (debug_mark),a  
ca4f 3a 5e ca			ld a, (.dmark+1)  
ca52 32 72 ee			ld (debug_mark+1),a  
ca55 3a 5f ca			ld a, (.dmark+2)  
ca58 32 73 ee			ld (debug_mark+2),a  
ca5b 18 03			jr .pastdmark  
ca5d ..			.dmark: db "Vbb"  
ca60 f1			.pastdmark: pop af  
ca61			endm  
# End of macro DMARK
ca61						CALLMONITOR 
ca61 cd dd 94			call break_point_state  
ca64				endm  
# End of macro CALLMONITOR
ca64					endif 
ca64 cb 27				sla a  
ca66				 
ca66					 
ca66					if DEBUG_FORTH_WORDS 
ca66						DMARK "VR2" 
ca66 f5				push af  
ca67 3a 7b ca			ld a, (.dmark)  
ca6a 32 71 ee			ld (debug_mark),a  
ca6d 3a 7c ca			ld a, (.dmark+1)  
ca70 32 72 ee			ld (debug_mark+1),a  
ca73 3a 7d ca			ld a, (.dmark+2)  
ca76 32 73 ee			ld (debug_mark+2),a  
ca79 18 03			jr .pastdmark  
ca7b ..			.dmark: db "VR2"  
ca7e f1			.pastdmark: pop af  
ca7f			endm  
# End of macro DMARK
ca7f						CALLMONITOR 
ca7f cd dd 94			call break_point_state  
ca82				endm  
# End of macro CALLMONITOR
ca82					endif 
ca82			 
ca82 21 fa e9				ld hl, cli_var_array2 
ca85 cd dc 8c				call addatohl 
ca88 cd 53 9b				call forth_push_numhl 
ca8b			 
ca8b			 
ca8b				       NEXTW 
ca8b c3 00 9f			jp macro_next 
ca8e				endm 
# End of macro NEXTW
ca8e			.V0: 
ca8e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
ca8e 78				db WORD_SYS_CORE+100             
ca8f a6 ca			dw .V0Q            
ca91 04				db 3 + 1 
ca92 .. 00			db "V0!",0              
ca96				endm 
# End of macro CWHEAD
ca96			;| V0! ( u1 -- )  Store value to v0  | DONE 
ca96			 
ca96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca96 cd 4a 9d			call macro_dsp_valuehl 
ca99				endm 
# End of macro FORTH_DSP_VALUEHL
ca99			 
ca99 11 2e ea				ld de, cli_var_array 
ca9c			 
ca9c eb					ex de, hl 
ca9d 73					ld (hl), e 
ca9e 23					inc hl 
ca9f 72					ld (hl), d 
caa0			 
caa0					; destroy value TOS 
caa0			 
caa0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caa0 cd 02 9e			call macro_forth_dsp_pop 
caa3				endm 
# End of macro FORTH_DSP_POP
caa3			 
caa3				       NEXTW 
caa3 c3 00 9f			jp macro_next 
caa6				endm 
# End of macro NEXTW
caa6			.V0Q: 
caa6				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
caa6 79				db WORD_SYS_CORE+101             
caa7 b7 ca			dw .V1S            
caa9 04				db 3 + 1 
caaa .. 00			db "V0@",0              
caae				endm 
# End of macro CWHEAD
caae			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
caae 2a 2e ea				ld hl, (cli_var_array) 
cab1 cd 53 9b				call forth_push_numhl 
cab4			 
cab4				       NEXTW 
cab4 c3 00 9f			jp macro_next 
cab7				endm 
# End of macro NEXTW
cab7			.V1S: 
cab7				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cab7 7a				db WORD_SYS_CORE+102             
cab8 cf ca			dw .V1Q            
caba 04				db 3 + 1 
cabb .. 00			db "V1!",0              
cabf				endm 
# End of macro CWHEAD
cabf			;| V1! ( u1 -- )  Store value to v1 | DONE 
cabf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cabf cd 4a 9d			call macro_dsp_valuehl 
cac2				endm 
# End of macro FORTH_DSP_VALUEHL
cac2			 
cac2 11 30 ea				ld de, cli_var_array+2 
cac5				 
cac5 eb					ex de, hl 
cac6 73					ld (hl), e 
cac7 23					inc hl 
cac8 72					ld (hl), d 
cac9			 
cac9					; destroy value TOS 
cac9			 
cac9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cac9 cd 02 9e			call macro_forth_dsp_pop 
cacc				endm 
# End of macro FORTH_DSP_POP
cacc				       NEXTW 
cacc c3 00 9f			jp macro_next 
cacf				endm 
# End of macro NEXTW
cacf			.V1Q: 
cacf				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cacf 7b				db WORD_SYS_CORE+103             
cad0 e0 ca			dw .V2S            
cad2 04				db 3 + 1 
cad3 .. 00			db "V1@",0              
cad7				endm 
# End of macro CWHEAD
cad7			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cad7 2a 30 ea				ld hl, (cli_var_array+2) 
cada cd 53 9b				call forth_push_numhl 
cadd				       NEXTW 
cadd c3 00 9f			jp macro_next 
cae0				endm 
# End of macro NEXTW
cae0			.V2S: 
cae0				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cae0 7c				db WORD_SYS_CORE+104             
cae1 f8 ca			dw .V2Q            
cae3 04				db 3 + 1 
cae4 .. 00			db "V2!",0              
cae8				endm 
# End of macro CWHEAD
cae8			;| V2! ( u1 -- )  Store value to v2 | DONE 
cae8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cae8 cd 4a 9d			call macro_dsp_valuehl 
caeb				endm 
# End of macro FORTH_DSP_VALUEHL
caeb			 
caeb 11 32 ea				ld de, cli_var_array+4 
caee				 
caee eb					ex de, hl 
caef 73					ld (hl), e 
caf0 23					inc hl 
caf1 72					ld (hl), d 
caf2			 
caf2					; destroy value TOS 
caf2			 
caf2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
caf2 cd 02 9e			call macro_forth_dsp_pop 
caf5				endm 
# End of macro FORTH_DSP_POP
caf5				       NEXTW 
caf5 c3 00 9f			jp macro_next 
caf8				endm 
# End of macro NEXTW
caf8			.V2Q: 
caf8				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
caf8 7d				db WORD_SYS_CORE+105             
caf9 09 cb			dw .V3S            
cafb 04				db 3 + 1 
cafc .. 00			db "V2@",0              
cb00				endm 
# End of macro CWHEAD
cb00			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb00 2a 32 ea				ld hl, (cli_var_array+4) 
cb03 cd 53 9b				call forth_push_numhl 
cb06				       NEXTW 
cb06 c3 00 9f			jp macro_next 
cb09				endm 
# End of macro NEXTW
cb09			.V3S: 
cb09				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb09 7c				db WORD_SYS_CORE+104             
cb0a 21 cb			dw .V3Q            
cb0c 04				db 3 + 1 
cb0d .. 00			db "V3!",0              
cb11				endm 
# End of macro CWHEAD
cb11			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb11 cd 4a 9d			call macro_dsp_valuehl 
cb14				endm 
# End of macro FORTH_DSP_VALUEHL
cb14			 
cb14 11 34 ea				ld de, cli_var_array+6 
cb17				 
cb17 eb					ex de, hl 
cb18 73					ld (hl), e 
cb19 23					inc hl 
cb1a 72					ld (hl), d 
cb1b			 
cb1b					; destroy value TOS 
cb1b			 
cb1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb1b cd 02 9e			call macro_forth_dsp_pop 
cb1e				endm 
# End of macro FORTH_DSP_POP
cb1e				       NEXTW 
cb1e c3 00 9f			jp macro_next 
cb21				endm 
# End of macro NEXTW
cb21			.V3Q: 
cb21				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb21 7d				db WORD_SYS_CORE+105             
cb22 32 cb			dw .END            
cb24 04				db 3 + 1 
cb25 .. 00			db "V3@",0              
cb29				endm 
# End of macro CWHEAD
cb29			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb29 2a 34 ea				ld hl, (cli_var_array+6) 
cb2c cd 53 9b				call forth_push_numhl 
cb2f				       NEXTW 
cb2f c3 00 9f			jp macro_next 
cb32				endm 
# End of macro NEXTW
cb32			 
cb32			 
cb32			 
cb32			 
cb32			 
cb32			; end of dict marker 
cb32			 
cb32 00			.END:    db WORD_SYS_END 
cb33 00 00			dw 0 
cb35 00				db 0 
cb36			 
cb36			; use to jp here for user dict words to save on macro expansion  
cb36			 
cb36			user_dict_next: 
cb36				NEXTW 
cb36 c3 00 9f			jp macro_next 
cb39				endm 
# End of macro NEXTW
cb39			 
cb39			 
cb39			user_exec: 
cb39				;    ld hl, <word code> 
cb39				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb39				;    call forthexec 
cb39				;    jp user_dict_next   (NEXT) 
cb39			        ;    <word code bytes> 
cb39 eb				ex de, hl 
cb3a 2a c8 e5			ld hl,(os_tok_ptr) 
cb3d				 
cb3d				FORTH_RSP_NEXT 
cb3d cd fa 9a			call macro_forth_rsp_next 
cb40				endm 
# End of macro FORTH_RSP_NEXT
cb40			 
cb40			if DEBUG_FORTH_UWORD 
cb40						DMARK "UEX" 
cb40 f5				push af  
cb41 3a 55 cb			ld a, (.dmark)  
cb44 32 71 ee			ld (debug_mark),a  
cb47 3a 56 cb			ld a, (.dmark+1)  
cb4a 32 72 ee			ld (debug_mark+1),a  
cb4d 3a 57 cb			ld a, (.dmark+2)  
cb50 32 73 ee			ld (debug_mark+2),a  
cb53 18 03			jr .pastdmark  
cb55 ..			.dmark: db "UEX"  
cb58 f1			.pastdmark: pop af  
cb59			endm  
# End of macro DMARK
cb59				CALLMONITOR 
cb59 cd dd 94			call break_point_state  
cb5c				endm  
# End of macro CALLMONITOR
cb5c			endif 
cb5c			 
cb5c			 
cb5c			 
cb5c eb				ex de, hl 
cb5d 22 c8 e5			ld (os_tok_ptr), hl 
cb60				 
cb60				; Don't use next - Skips the first word in uword. 
cb60			 
cb60 c3 91 9f			jp exec1 
cb63			;	NEXT 
cb63			 
cb63			 
cb63			; eof 
# End of file forth_wordsv4.asm
cb63			endif 
cb63			;;;;;;;;;;;;;; Debug code 
cb63			 
cb63			 
cb63			;if DEBUG_FORTH_PARSE 
cb63 .. 00		.nowordfound: db "No match",0 
cb6c .. 00		.compword:	db "Comparing word ",0 
cb7c .. 00		.nextwordat:	db "Next word at",0 
cb89 .. 00		.charmatch:	db "Char match",0 
cb94			;endif 
cb94			if DEBUG_FORTH_JP 
cb94			.foundword:	db "Word match. Exec..",0 
cb94			endif 
cb94			;if DEBUG_FORTH_PUSH 
cb94 .. 00		.enddict:	db "Dict end. Push.",0 
cba4 .. 00		.push_str:	db "Pushing string",0 
cbb3 .. 00		.push_num:	db "Pushing number",0 
cbc2 .. 00		.data_sp:	db "SP:",0 
cbc6 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbd8 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cbea .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cbfc			;endif 
cbfc			;if DEBUG_FORTH_MALLOC 
cbfc .. 00		.push_malloc:	db "Malloc address",0 
cc0b			;endif 
cc0b			 
cc0b			 
cc0b			 
cc0b			; display malloc address and current data stack pointer  
cc0b			 
cc0b			malloc_error: 
cc0b d5				push de 
cc0c f5				push af 
cc0d e5				push hl 
cc0e cd af 8a			call clear_display 
cc11 11 33 cc			ld de, .mallocerr 
cc14 3e 00			ld a,0 
cc16			;	ld de,os_word_scratch 
cc16 cd c2 8a			call str_at_display 
cc19 3e 11			ld a, display_row_1+17 
cc1b 11 71 ee			ld de, debug_mark 
cc1e cd c2 8a			call str_at_display 
cc21 cd d2 8a			call update_display 
cc24				;call break_point_state 
cc24 cd 40 e3			call cin_wait 
cc27			 
cc27 3e 20			ld a, ' ' 
cc29 32 b8 e2			ld (os_view_disable), a 
cc2c e1				pop hl 
cc2d f1				pop af 
cc2e d1				pop de	 
cc2f				CALLMONITOR 
cc2f cd dd 94			call break_point_state  
cc32				endm  
# End of macro CALLMONITOR
cc32 c9				ret 
cc33			 
cc33 .. 00		.mallocerr: 	db "Malloc Error",0 
cc40			;if DEBUG_FORTH_PUSH 
cc40			display_data_sp: 
cc40 f5				push af 
cc41			 
cc41				; see if disabled 
cc41			 
cc41 3a b8 e2			ld a, (os_view_disable) 
cc44 fe 2a			cp '*' 
cc46 28 67			jr z, .skipdsp 
cc48			 
cc48 e5				push hl 
cc49 e5				push hl 
cc4a e5			push hl 
cc4b cd af 8a			call clear_display 
cc4e e1			pop hl 
cc4f 7c				ld a,h 
cc50 21 cc e5			ld hl, os_word_scratch 
cc53 cd dd 8f			call hexout 
cc56 e1				pop hl 
cc57 7d				ld a,l 
cc58 21 ce e5			ld hl, os_word_scratch+2 
cc5b cd dd 8f			call hexout 
cc5e 21 d0 e5			ld hl, os_word_scratch+4 
cc61 3e 00			ld a,0 
cc63 77				ld (hl),a 
cc64 11 cc e5			ld de,os_word_scratch 
cc67 3e 28				ld a, display_row_2 
cc69 cd c2 8a				call str_at_display 
cc6c 11 c6 cb			ld de, .wordinhl 
cc6f 3e 00			ld a, display_row_1 
cc71			 
cc71 cd c2 8a				call str_at_display 
cc74 11 71 ee			ld de, debug_mark 
cc77 3e 11			ld a, display_row_1+17 
cc79			 
cc79 cd c2 8a				call str_at_display 
cc7c			 
cc7c				; display current data stack pointer 
cc7c 11 c2 cb			ld de,.data_sp 
cc7f 3e 30				ld a, display_row_2 + 8 
cc81 cd c2 8a				call str_at_display 
cc84			 
cc84 2a f4 e9			ld hl,(cli_data_sp) 
cc87 e5				push hl 
cc88 7c				ld a,h 
cc89 21 cc e5			ld hl, os_word_scratch 
cc8c cd dd 8f			call hexout 
cc8f e1				pop hl 
cc90 7d				ld a,l 
cc91 21 ce e5			ld hl, os_word_scratch+2 
cc94 cd dd 8f			call hexout 
cc97 21 d0 e5			ld hl, os_word_scratch+4 
cc9a 3e 00			ld a,0 
cc9c 77				ld (hl),a 
cc9d 11 cc e5			ld de,os_word_scratch 
cca0 3e 33				ld a, display_row_2 + 11 
cca2 cd c2 8a				call str_at_display 
cca5			 
cca5			 
cca5 cd d2 8a			call update_display 
cca8 cd f2 89			call delay1s 
ccab cd f2 89			call delay1s 
ccae e1				pop hl 
ccaf			.skipdsp: 
ccaf f1				pop af 
ccb0 c9				ret 
ccb1			 
ccb1			display_data_malloc: 
ccb1			 
ccb1 f5				push af 
ccb2 e5				push hl 
ccb3 e5				push hl 
ccb4 e5			push hl 
ccb5 cd af 8a			call clear_display 
ccb8 e1			pop hl 
ccb9 7c				ld a,h 
ccba 21 cc e5			ld hl, os_word_scratch 
ccbd cd dd 8f			call hexout 
ccc0 e1				pop hl 
ccc1 7d				ld a,l 
ccc2 21 ce e5			ld hl, os_word_scratch+2 
ccc5 cd dd 8f			call hexout 
ccc8 21 d0 e5			ld hl, os_word_scratch+4 
cccb 3e 00			ld a,0 
cccd 77				ld (hl),a 
ccce 11 cc e5			ld de,os_word_scratch 
ccd1 3e 28				ld a, display_row_2 
ccd3 cd c2 8a				call str_at_display 
ccd6 11 fc cb			ld de, .push_malloc 
ccd9 3e 00			ld a, display_row_1 
ccdb			 
ccdb cd c2 8a				call str_at_display 
ccde			 
ccde				; display current data stack pointer 
ccde 11 c2 cb			ld de,.data_sp 
cce1 3e 30				ld a, display_row_2 + 8 
cce3 cd c2 8a				call str_at_display 
cce6			 
cce6 2a f4 e9			ld hl,(cli_data_sp) 
cce9 e5				push hl 
ccea 7c				ld a,h 
cceb 21 cc e5			ld hl, os_word_scratch 
ccee cd dd 8f			call hexout 
ccf1 e1				pop hl 
ccf2 7d				ld a,l 
ccf3 21 ce e5			ld hl, os_word_scratch+2 
ccf6 cd dd 8f			call hexout 
ccf9 21 d0 e5			ld hl, os_word_scratch+4 
ccfc 3e 00			ld a,0 
ccfe 77				ld (hl),a 
ccff 11 cc e5			ld de,os_word_scratch 
cd02 3e 33				ld a, display_row_2 + 11 
cd04 cd c2 8a				call str_at_display 
cd07			 
cd07 cd d2 8a			call update_display 
cd0a cd f2 89			call delay1s 
cd0d cd f2 89			call delay1s 
cd10 e1				pop hl 
cd11 f1				pop af 
cd12 c9				ret 
cd13			;endif 
cd13			 
cd13			include "forth_autostart.asm" 
cd13			; list of commands to perform at system start up 
cd13			 
cd13			startcmds: 
cd13			;	dw test11 
cd13			;	dw test12 
cd13			;	dw test13 
cd13			;	dw test14 
cd13			;	dw test15 
cd13			;	dw test16 
cd13			;	dw test17 
cd13			;	dw ifthtest1 
cd13			;	dw ifthtest2 
cd13			;	dw ifthtest3 
cd13			;	dw mmtest1 
cd13			;	dw mmtest2 
cd13			;	dw mmtest3 
cd13			;	dw mmtest4 
cd13			;	dw mmtest5 
cd13			;	dw mmtest6 
cd13			;	dw iftest1 
cd13			;	dw iftest2 
cd13			;	dw iftest3 
cd13			;	dw looptest1 
cd13			;	dw looptest2 
cd13			;	dw test1 
cd13			;	dw test2 
cd13			;	dw test3 
cd13			;	dw test4 
cd13			;	dw game2r 
cd13			;	dw game2b1 
cd13			;	dw game2b2 
cd13			 
cd13				; start up words that are actually useful 
cd13			 
cd13 1b ce		    dw spi1 
cd15 74 ce		    dw spi2 
cd17 02 cf		    dw spi3 
cd19 aa ce		    dw spi4 
cd1b d5 ce		    dw spi5 
cd1d 68 cf		    dw spi6 
cd1f bd cf		    dw spi7 
cd21			 
cd21 15 d0		    dw spi8 
cd23 34 d0		    dw spi9 
cd25 8c d0		    dw spi10 
cd27			 
cd27			; file editor 
cd27 8d cd			dw edit1 
cd29 ae cd			dw edit2 
cd2b e3 cd			dw edit3 
cd2d			 
cd2d ff d0			dw longread 
cd2f 46 d1			dw clrstack 
cd31 79 d1			dw type 
cd33 64 d3			dw stest 
cd35 9d d1			dw strncpy 
cd37 fa d2			dw list 
cd39 fe d1			dw start1 
cd3b 0e d2			dw start2 
cd3d			;	dw start3 
cd3d 1f d2			dw start3b 
cd3f 9a d2			dw start3c 
cd41			 
cd41				; (unit) testing words 
cd41			 
cd41 db d3			dw mtesta 
cd43 90 d4			dw mtestb 
cd45 33 d5			dw mtestc 
cd47 e8 d5			dw mtestd 
cd49 8c d6			dw mteste 
cd4b			 
cd4b				; demo/game words 
cd4b			 
cd4b 98 dd		        dw game3w 
cd4d c6 dd		        dw game3p 
cd4f e4 dd		        dw game3sc 
cd51 15 de		        dw game3vsi 
cd53 41 de		        dw game3vs 
cd55				 
cd55 8b db			dw game2b 
cd57 f9 db			dw game2bf 
cd59 43 dc			dw game2mba 
cd5b d9 dc			dw game2mbas 
cd5d 1b dd			dw game2mb 
cd5f			 
cd5f 4c d8			dw game1 
cd61 5d d8			dw game1a 
cd63 bf d8			dw game1b 
cd65 f4 d8			dw game1c 
cd67 2a d9			dw game1d 
cd69 5b d9			dw game1s 
cd6b 6f d9			dw game1t 
cd6d 84 d9			dw game1f 
cd6f b8 d9			dw game1z 
cd71 fc d9			dw game1zz 
cd73			 
cd73 42 d7			dw test5 
cd75 7a d7			dw test6 
cd77 b2 d7			dw test7 
cd79 c6 d7			dw test8 
cd7b f2 d7			dw test9 
cd7d 08 d8			dw test10 
cd7f				 
cd7f d3 da		        dw ssv5 
cd81 b7 da		        dw ssv4 
cd83 9b da		        dw ssv3 
cd85 65 da		        dw ssv2 
cd87 ec da		        dw ssv1 
cd89 34 db		        dw ssv1cpm 
cd8b			;	dw keyup 
cd8b			;	dw keydown 
cd8b			;	dw keyleft 
cd8b			;	dw keyright 
cd8b			;	dw 	keyf1 
cd8b			;	dw keyf2 
cd8b			;	dw keyf3 
cd8b			;	dw keyf4 
cd8b			;	dw keyf5 
cd8b			;	dw keyf6 
cd8b			;	dw keyf7 
cd8b			;	dw keyf8 
cd8b			;	dw keyf9 
cd8b			;	dw keyf10 
cd8b			;	dw keyf11 
cd8b			;	dw keyf12 
cd8b			;	dw keytab 
cd8b			;	dw keycr 
cd8b			;	dw keyhome 
cd8b			;	dw keyend 
cd8b			;	dw keybs 
cd8b 00 00			db 0, 0	 
cd8d			 
cd8d			 
cd8d			; File Editor 
cd8d			 
cd8d			; ( id - ) use 'e' to edit the displayed line 
cd8d .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cdae .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cde3			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cde3 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
ce1b			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
ce1b			 
ce1b			; SPI Net support words 
ce1b			 
ce1b			; v0! = node to send to 
ce1b			; ( str count - ) 
ce1b .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce74			 
ce74			; spiputchr ( char node - ) 
ce74 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ceaa			 
ceaa			; spigetchr ( - n ) 
ceaa .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
ced5			 
ced5			; getnode ( - n ) 
ced5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cf02			 
cf02			; ( str node - )  
cf02 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf68			; store string ( str i - ) 
cf68			 
cf68			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf68 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfbd			 
cfbd			; get string ( addr i -  )    TO FIX 
cfbd			 
cfbd .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d015			 
d015			 
d015			; NETCHAT (TODO) 
d015			; Program to allow two nodes to chat with eachother 
d015			; 
d015			; v0 - target node 
d015			;  
d015			; accept input at 0,0 
d015			; if input is string send spitype to target node 
d015			; starting at row 2,0 , while spigetchr is not zero ->  
d015			; 
d015			; 
d015			; TODO add paging of get request 
d015			 
d015			; ( node - ) 
d015 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d034 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d08c .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
d0ff			 
d0ff			 
d0ff			; Long read of currently open file 
d0ff .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d146			 
d146			; clear stack  
d146			 
d146 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
d179			 
d179			; type ( addr count - ) 
d179 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
d19d			 
d19d			; some direct memory words 
d19d			; strncpy ( len t f -- t ) 
d19d			 
d19d .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1fe			 
d1fe .. 00		start1:     	db ": bpon $00 bp ;",0 
d20e .. 00		start2:     	db ": bpoff $01 bp ;",0 
d21f .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d29a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2fa			 
d2fa			 
d2fa			; a handy word to list items on the stack 
d2fa			 
d2fa .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d364			 
d364			 
d364			; test stack  
d364			; rnd8 stest 
d364			 
d364 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d3db			 
d3db			; random malloc and free cycles 
d3db			 
d3db .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d490			 
d490			; fixed malloc and free cycles 
d490			 
d490 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d533			 
d533			; fixed double string push and drop cycle  
d533			 
d533 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5e8			 
d5e8			; consistent fixed string push and drop cycle  
d5e8			 
d5e8 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d68c			 
d68c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d742			 
d742			;test1:		db ": aa 1 2 3 ;", 0 
d742			;test2:     	db "111 aa 888 999",0 
d742			;test3:     	db ": bb 77 ;",0 
d742			;test4:     	db "$02 $01 do i . loop bb",0 
d742			 
d742 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d77a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d7b2 .. 00		test7:     	db ": box hline vline ;",0 
d7c6 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7f2 .. 00		test9:     	db ": sw $01 adsp world ;",0 
d808 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d82d .. 00		test11:     	db "hello create .",0 
d83c .. 00		test12:     	db "hello2 create .",0 
d84c			 
d84c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d84c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d84c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d84c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d84c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d84c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d84c			 
d84c			;iftest1:     	db "$0001 IF cls .",0 
d84c			;iftest2:     	db "$0000 IF cls .",0 
d84c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d84c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d84c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d84c			 
d84c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d84c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d84c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d84c			 
d84c			 
d84c			 
d84c			; a small guess the number game 
d84c			 
d84c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d85d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d8bf			 
d8bf .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d8f4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d92a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d95b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d96f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d984 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d9b8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d9fc			 
d9fc			; Using 'ga' save a high score across multiple runs using external storage 
d9fc			 
d9fc .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
da65			 
da65			 
da65			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
da65			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
da65			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
da65			 
da65			; simple screen saver to test code memory reuse to destruction 
da65			 
da65 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
da9b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dab7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dad3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
daec .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
db34 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
db8b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
db8b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
db8b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
db8b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
db8b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
db8b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
db8b			 
db8b			 
db8b			 
db8b			; minesweeper/battleship finding game 
db8b			; draws a game board of random ship/mine positions 
db8b			; user enters coords to see if it hits on 
db8b			; game ends when all are hit 
db8b			; when hit or miss says how many may be in the area 
db8b			 
db8b			; setup the game board and then hide it 
db8b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dbf9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dc43			; prompt for where to target 
dc43 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dcd9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dcfe			; TODO see if the entered coords hits or misses pushes char hit of miss 
dcfe .. 00		game2mbht:      db ": mbckht nop ;",0 
dd0d .. 00		game2mbms:      db ": mbcms nop ;",0 
dd1b			; TODO how many might be near by 
dd1b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
dd98			 
dd98			; Game 3 
dd98			 
dd98			; Vert scroller ski game - avoid the trees! 
dd98			 
dd98			; v0 score (ie turns) 
dd98			; v1 player pos 
dd98			; v2 left wall 
dd98			; v3 right wall 
dd98			 
dd98			; Draw side walls randomly 
dd98			 
dd98 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
ddc6			 
ddc6			; Draw player 
ddc6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
dde4			 
dde4			; TODO Get Key 
dde4			 
dde4			; TODO Move left right 
dde4			 
dde4			; scroll and move walls a bit 
dde4			 
dde4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
de15			 
de15			; main game loop 
de15			 
de15 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
de41 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
de80			 
de80			; key board defs 
de80			 
de80 .. 00		keyup:       db ": keyup $05 ;",0 
de8e .. 00		keydown:       db ": keydown $0a ;",0 
de9e .. 00		keyleft:       db ": keyleft $0b ;",0 
deae .. 00		keyright:       db ": keyright $0c ;",0 
debf .. 00		keyf1:       db ": keyf1 $10 ;",0 
decd .. 00		keyf2:       db ": keyf2 $11 ;",0 
dedb .. 00		keyf3:       db ": keyf3 $12 ;",0 
dee9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
def7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
df05 .. 00		keyf6:       db ": keyf6 $15 ;",0 
df13 .. 00		keyf7:       db ": keyf7 $16 ;",0 
df21 .. 00		keyf8:       db ": keyf8 $17 ;",0 
df2f .. 00		keyf9:       db ": keyf9 $18 ;",0 
df3d .. 00		keyf10:       db ": keyf10 $19 ;",0 
df4c .. 00		keyf11:       db ": keyf11 $1a ;",0 
df5b .. 00		keyf12:       db ": keyf12 $1b ;",0 
df6a			 
df6a .. 00		keytab:       db ": keytab $09 ;",0 
df79 .. 00		keycr:       db ": keycr $0d ;",0 
df87 .. 00		keyhome:       db ": keyhome $0e ;",0 
df97 .. 00		keyend:       db ": keyend $0f ;",0 
dfa6 .. 00		keybs:       db ": keybs $08 ;",0 
dfb4			 
dfb4			   
dfb4			 
dfb4			 
dfb4			 
dfb4			; eof 
# End of file forth_autostart.asm
dfb4			 
dfb4			 
dfb4			 
dfb4			; stack over and underflow checks 
dfb4			 
dfb4			; init the words to detect the under/overflow 
dfb4			 
dfb4			chk_stk_init: 
dfb4				; a vague random number to check so we dont get any "lucky" hits 
dfb4 3e 2d			ld a, 45 
dfb6 6f				ld l, a 
dfb7 00				nop 
dfb8 3e 17			ld a, 23 
dfba 67				ld h, a 
dfbb			 
dfbb 22 ae e2			ld (chk_word), hl     ; the word we need to check against 
dfbe			 
dfbe			;	ld (chk_stund), hl	; stack points.... 
dfbe 22 00 ef			ld (chk_stovr), hl 
dfc1 22 f2 e9			ld (chk_ret_und), hl 
dfc4 22 b0 e9			ld (chk_ret_ovr), hl 
dfc7 22 2e e9			ld (chk_loop_ovr), hl 
dfca 22 2c e8			ld (chk_data_ovr), hl 
dfcd c9				ret 
dfce				 
dfce			check_stacks: 
dfce				; check all stack words 
dfce			 
dfce e5				push hl 
dfcf d5				push de 
dfd0			 
dfd0			;	ld de,(chk_word) 
dfd0			;	ld hl, (chk_stund)	; stack points.... 
dfd0			;	if DEBUG_STK_FAULT 
dfd0			;		DMARK "FAa" 
dfd0			;		CALLMONITOR 
dfd0			;	endif 
dfd0			;	call cmp16 
dfd0			;	jp z, .chk_faulta 
dfd0			; 
dfd0			;	ld de, sfaultsu 
dfd0			;	jp .chk_fault 
dfd0			 
dfd0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
dfd3 ed 5b ae e2		ld de,(chk_word) 
dfd7				if DEBUG_STK_FAULT 
dfd7					DMARK "FAb" 
dfd7					CALLMONITOR 
dfd7				endif 
dfd7 cd fa 8c			call cmp16 
dfda 28 06			jr z, .chk_fault1 
dfdc 11 7d e0			ld de, sfaultso 
dfdf c3 31 e0			jp .chk_fault 
dfe2			.chk_fault1:  
dfe2 2a f2 e9			ld hl, (chk_ret_und) 
dfe5 ed 5b ae e2		ld de,(chk_word) 
dfe9				if DEBUG_STK_FAULT 
dfe9					DMARK "FAU" 
dfe9					CALLMONITOR 
dfe9				endif 
dfe9 cd fa 8c			call cmp16 
dfec ca f5 df			jp z, .chk_fault2 
dfef 11 8d e0			ld de, sfaultru 
dff2 c3 31 e0			jp .chk_fault 
dff5			.chk_fault2:  
dff5 2a b0 e9			ld hl, (chk_ret_ovr) 
dff8 ed 5b ae e2		ld de,(chk_word) 
dffc				if DEBUG_STK_FAULT 
dffc					DMARK "FA1" 
dffc					CALLMONITOR 
dffc				endif 
dffc cd fa 8c			call cmp16 
dfff ca 08 e0			jp z, .chk_fault3 
e002 11 9b e0			ld de, sfaultro 
e005 c3 31 e0			jp .chk_fault 
e008			.chk_fault3:  
e008 2a 2e e9			ld hl, (chk_loop_ovr) 
e00b ed 5b ae e2		ld de,(chk_word) 
e00f				if DEBUG_STK_FAULT 
e00f					DMARK "FA2" 
e00f					CALLMONITOR 
e00f				endif 
e00f cd fa 8c			call cmp16 
e012 ca 1b e0			jp z, .chk_fault4 
e015 11 b5 e0			ld de, sfaultlo 
e018 c3 31 e0			jp .chk_fault 
e01b			.chk_fault4:  
e01b 2a 2c e8			ld hl, (chk_data_ovr) 
e01e ed 5b ae e2		ld de,(chk_word) 
e022				if DEBUG_STK_FAULT 
e022					DMARK "FA3" 
e022					CALLMONITOR 
e022				endif 
e022 cd fa 8c			call cmp16 
e025 ca 2e e0			jp z, .chk_fault5 
e028 11 cf e0			ld de, sfaultdo 
e02b c3 31 e0			jp .chk_fault 
e02e			 
e02e			 
e02e			.chk_fault5:  
e02e d1				pop de 
e02f e1				pop hl 
e030			 
e030 c9				ret 
e031			 
e031 cd af 8a		.chk_fault: 	call clear_display 
e034 3e 28				ld a, display_row_2 
e036 cd c2 8a				call str_at_display 
e039 11 5f e0				   ld de, .stackfault 
e03c 3e 00				ld a, display_row_1 
e03e cd c2 8a				call str_at_display 
e041 11 71 ee				    ld de, debug_mark 
e044 3e 11				ld a, display_row_1+17 
e046 cd c2 8a				call str_at_display 
e049 cd d2 8a				call update_display 
e04c			 
e04c				; prompt before entering montior for investigating issue 
e04c			 
e04c 3e 78			ld a, display_row_4 
e04e 11 6d 98			ld de, endprog 
e051			 
e051 cd d2 8a			call update_display		 
e054			 
e054 cd cb 9a			call next_page_prompt 
e057			 
e057 d1				pop de 
e058 e1				pop hl 
e059 cd c1 98				call monitor 
e05c c3 bb 97				jp warmstart 
e05f					;jp 0 
e05f					;halt 
e05f			 
e05f			 
e05f			 
e05f .. 00		.stackfault: 	db "Stack fault:",0 
e06c			 
e06c .. 00		sfaultsu: 	db	"Stack under flow",0 
e07d .. 00		sfaultso: 	db	"Stack over flow",0 
e08d .. 00		sfaultru:	db "RTS underflow",0 
e09b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e0b5 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e0cf .. 00		sfaultdo:	db "DTS overflow", 0 
e0dc			 
e0dc			 
e0dc			fault_dsp_under: 
e0dc 11 ee e0			ld de, .dsp_under 
e0df c3 9e e1			jp .show_fault 
e0e2			 
e0e2			fault_rsp_under: 
e0e2 11 fc e0			ld de, .rsp_under 
e0e5 c3 9e e1			jp .show_fault 
e0e8			fault_loop_under: 
e0e8 11 0a e1			ld de, .loop_under 
e0eb c3 9e e1			jp .show_fault 
e0ee			 
e0ee .. 00		.dsp_under: db "DSP Underflow",0 
e0fc .. 00		.rsp_under: db "RSP Underflow",0 
e10a .. 00		.loop_under: db "LOOP Underflow",0 
e119			 
e119			 
e119 d5			type_faultn: 	push de 
e11a e5					push hl 
e11b cd af 8a				call clear_display 
e11e 11 45 e1				   ld de, .typefaultn 
e121 3e 00				ld a, display_row_1 
e123 cd c2 8a				call str_at_display 
e126 11 71 ee				    ld de, debug_mark 
e129 3e 11				ld a, display_row_1+17 
e12b cd c2 8a				call str_at_display 
e12e cd d2 8a				call update_display 
e131			 
e131				; prompt before entering montior for investigating issue 
e131			 
e131 3e 78			ld a, display_row_4 
e133 11 6d 98			ld de, endprog 
e136			 
e136 cd d2 8a			call update_display		 
e139			 
e139 cd cb 9a			call next_page_prompt 
e13c			 
e13c e5					push hl 
e13d d5					push de 
e13e cd c1 98				call monitor 
e141 c3 bb 97				jp warmstart 
e144 76					halt 
e145			 
e145			 
e145 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e15c			 
e15c d5			type_faults: 	push de 
e15d e5					push hl 
e15e cd af 8a				call clear_display 
e161 11 87 e1				   ld de, .typefaults 
e164 3e 00				ld a, display_row_1 
e166 cd c2 8a				call str_at_display 
e169 11 71 ee				    ld de, debug_mark 
e16c 3e 11				ld a, display_row_1+17 
e16e cd c2 8a				call str_at_display 
e171 cd d2 8a				call update_display 
e174			 
e174				; prompt before entering montior for investigating issue 
e174			 
e174 3e 78			ld a, display_row_4 
e176 11 6d 98			ld de, endprog 
e179			 
e179 cd d2 8a			call update_display		 
e17c			 
e17c cd cb 9a			call next_page_prompt 
e17f			 
e17f e1					pop hl 
e180 d1					pop de 
e181 cd c1 98				call monitor 
e184 c3 bb 97				jp warmstart 
e187			 
e187			 
e187 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e19e			 
e19e			.show_fault: 	 
e19e d5					push de 
e19f cd af 8a				call clear_display 
e1a2 d1					pop de 
e1a3 3e 00				ld a, display_row_1 
e1a5 cd c2 8a				call str_at_display 
e1a8 11 71 ee				    ld de, debug_mark 
e1ab 3e 11				ld a, display_row_1+17 
e1ad cd c2 8a				call str_at_display 
e1b0 cd d2 8a				call update_display 
e1b3			 
e1b3				; prompt before entering montior for investigating issue 
e1b3			 
e1b3 3e 78			ld a, display_row_4 
e1b5 11 6d 98			ld de, endprog 
e1b8			 
e1b8 cd d2 8a			call update_display		 
e1bb			 
e1bb cd cb 9a			call next_page_prompt 
e1be			 
e1be e1					pop hl 
e1bf d1					pop de 
e1c0 cd c1 98				call monitor 
e1c3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e1c3			; TODO Make optional fault restart to cli or warm boot? 
e1c3					;jp warmstart 
e1c3 c3 13 98				jp cli 
e1c6 76					halt 
e1c7			 
e1c7			; handle the auto run of code from files in storage 
e1c7			 
e1c7			 
e1c7			include "forth_startup.asm" 
e1c7			; Which startup method to use? 
e1c7			; 
e1c7			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e1c7			; followed by loading of a list of scripts in eeprom 
e1c7			 
e1c7			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e1c7			; from eeprom 
e1c7			 
e1c7			; Select with define in main stubs 
e1c7			 
e1c7			if STARTUP_V1 
e1c7				include "forth_startupv1.asm" 
e1c7			; Startup script loading version 1 
e1c7			 
e1c7			; If SE storage is available first stage is to use the selected file 
e1c7			; then go through the eeprom list 
e1c7			 
e1c7 .. 00		sprompt1: db "Startup load...",0 
e1d7 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e1ed			 
e1ed			 
e1ed			 
e1ed			 
e1ed			forth_startup: 
e1ed 21 13 cd			ld hl, startcmds 
e1f0 3e 00			ld a, 0 
e1f2 32 ed e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e1f5			 
e1f5 e5			.start1:	push hl 
e1f6 cd af 8a			call clear_display 
e1f9 11 c7 e1			ld de, sprompt1 
e1fc 3e 00		        ld a, display_row_1 
e1fe cd c2 8a			call str_at_display 
e201 11 d7 e1			ld de, sprompt2 
e204 3e 28		        ld a, display_row_2 
e206 cd c2 8a			call str_at_display 
e209 e1				pop hl 
e20a e5				push hl 
e20b 5e				ld e,(hl) 
e20c 23				inc hl 
e20d 56				ld d,(hl) 
e20e 3e 50		        ld a, display_row_3 
e210 cd c2 8a			call str_at_display 
e213 cd d2 8a			call update_display 
e216			 
e216			 
e216 3a ed e6			ld a, (os_last_cmd) 
e219 fe 00			cp 0 
e21b 28 05			jr z, .startprompt 
e21d cd e6 89			call delay250ms 
e220 18 24			jr .startdo 
e222				 
e222				 
e222			 
e222			.startprompt: 
e222			 
e222 3e 9f			ld a,display_row_4 + display_cols - 1 
e224 11 c9 9a		        ld de, endprg 
e227 cd c2 8a			call str_at_display 
e22a cd d2 8a			call update_display 
e22d cd f2 89			call delay1s 
e230 cd 40 e3			call cin_wait 
e233						 
e233 fe 2a			cp '*' 
e235 28 5e			jr z, .startupend1 
e237 fe 23			cp '#' 
e239 20 07			jr nz, .startno 
e23b 3e 01			ld a, 1 
e23d 32 ed e6			ld (os_last_cmd),a 
e240 18 04			jr .startdo 
e242 fe 31		.startno:	cp '1' 
e244 28 3a			jr z,.startnxt  
e246			 
e246				; exec startup line 
e246			.startdo:	 
e246 e1				pop hl 
e247 e5				push hl 
e248				 
e248 5e				ld e,(hl) 
e249 23				inc hl 
e24a 56				ld d,(hl) 
e24b eb				ex de,hl 
e24c			 
e24c e5				push hl 
e24d			 
e24d 3e 00			ld a, 0 
e24f				;ld a, FORTH_END_BUFFER 
e24f cd 45 91			call strlent 
e252 23				inc hl   ; include zero term to copy 
e253 06 00			ld b,0 
e255 4d				ld c,l 
e256 e1				pop hl 
e257 11 c7 e2			ld de, scratch 
e25a ed b0			ldir 
e25c			 
e25c			 
e25c 21 c7 e2			ld hl, scratch 
e25f cd 4e 9f			call forthparse 
e262 cd 8e 9f			call forthexec 
e265 cd a0 9e			call forthexec_cleanup 
e268			 
e268 3e 78			ld a, display_row_4 
e26a 11 6d 98			ld de, endprog 
e26d			 
e26d cd d2 8a			call update_display		 
e270			 
e270 3a ed e6			ld a, (os_last_cmd) 
e273 fe 00			cp 0 
e275 20 09			jr nz, .startnxt 
e277 cd cb 9a			call next_page_prompt 
e27a cd af 8a		        call clear_display 
e27d cd d2 8a			call update_display		 
e280			 
e280				; move onto next startup line? 
e280			.startnxt: 
e280			 
e280 cd e6 89			call delay250ms 
e283 e1				pop hl 
e284			 
e284 23				inc hl 
e285 23				inc hl 
e286			 
e286 e5				push hl 
e287 5e				ld e, (hl) 
e288 23				inc hl 
e289 56				ld d, (hl) 
e28a e1				pop hl 
e28b				; TODO replace 0 test 
e28b			 
e28b eb				ex de, hl 
e28c cd 05 8d			call ishlzero 
e28f			;	ld a,e 
e28f			;	add d 
e28f			;	cp 0    ; any left to do? 
e28f eb				ex de, hl 
e290 c2 f5 e1			jp nz, .start1 
e293 18 01			jr .startupend 
e295			 
e295 e1			.startupend1: pop hl 
e296			.startupend: 
e296			 
e296 cd af 8a			call clear_display 
e299 cd d2 8a			call update_display 
e29c c9				ret 
e29d			if STORAGE_SE 
e29d			 
e29d			sprompt3: db "Loading from start-up file?:",0 
e29d			sprompt4: db "(Y=Any key/N=No)",0 
e29d			 
e29d			 
e29d			forth_autoload: 
e29d			 
e29d				; load block 0 of store 1 
e29d				 
e29d				ld a, $fe      ; bit 0 clear 
e29d				ld (spi_device), a 
e29d			 
e29d				call storage_get_block_0 
e29d			 
e29d				ld a, (store_page+STORE_0_AUTOFILE) 
e29d			 
e29d				cp 0 
e29d				ret z     ; auto start not enabled 
e29d			 
e29d				call clear_display 
e29d			 
e29d				; set bank 
e29d			 
e29d					ld a, (store_page+STORE_0_BANKRUN) 
e29d					ld (spi_device), a 
e29d			 
e29d				; get file id to load from and get the file name to display 
e29d			 
e29d					ld a, (store_page+STORE_0_FILERUN) 
e29d			 
e29d					ld l, 0 
e29d					ld h, a 
e29d					ld de, store_page 
e29d			 
e29d					if DEBUG_FORTH_WORDS 
e29d						DMARK "ASp" 
e29d						CALLMONITOR 
e29d					endif 
e29d					call storage_read 
e29d			 
e29d					if DEBUG_FORTH_WORDS 
e29d						DMARK "ASr" 
e29d						CALLMONITOR 
e29d					endif 
e29d			 
e29d					call ishlzero 
e29d					ret z             ; file not found 
e29d			 
e29d					ld a, display_row_2 + 10 
e29d					ld de, store_page+3 
e29d					call str_at_display 
e29d				 
e29d			; 
e29d			 
e29d				ld a, display_row_1+5 
e29d				ld de, sprompt3 
e29d				call str_at_display 
e29d				ld a, display_row_3+15 
e29d				ld de, sprompt4 
e29d				call str_at_display 
e29d			 
e29d				call update_display 
e29d			 
e29d				call cin_wait 
e29d				cp 'n' 
e29d				ret z 
e29d				cp 'N' 
e29d				ret z 
e29d			 
e29d				call delay1s 
e29d			 
e29d				ld a, (store_page+2) 
e29d				ld (store_openmaxext), a    ; save count of ext 
e29d				ld a, 1  
e29d				ld (store_openext), a    ; save count of ext 
e29d			 
e29d			.autof:  
e29d				ld l , a 
e29d				 
e29d				ld a, (store_page) 
e29d				ld h, a	 
e29d				ld de, store_page 
e29d					if DEBUG_FORTH_WORDS 
e29d						DMARK "ASl" 
e29d						CALLMONITOR 
e29d					endif 
e29d					call storage_read 
e29d				call ishlzero 
e29d				ret z 
e29d			;	jr z, .autoend 
e29d			 
e29d					if DEBUG_FORTH_WORDS 
e29d						DMARK "ASc" 
e29d						CALLMONITOR 
e29d					endif 
e29d				ld de, store_page+2 
e29d				ld a, display_row_4 
e29d				call str_at_display 
e29d			 
e29d				call update_display 
e29d				call delay250ms 
e29d			 
e29d			 
e29d			 
e29d				ld hl, store_page+2 
e29d				call forthparse 
e29d				call forthexec 
e29d				call forthexec_cleanup 
e29d			 
e29d				 
e29d				ld a, (store_openext) 
e29d				inc a 
e29d				ld (store_openext), a    ; save count of ext 
e29d			 
e29d				jr .autof 
e29d			;.autofdone: 
e29d			; 
e29d			;		if DEBUG_FORTH_WORDS 
e29d			;			DMARK "ASx" 
e29d			;			CALLMONITOR 
e29d			;		endif 
e29d			;;	call clear_display 
e29d			;	ret 
e29d			 
e29d			 
e29d			 
e29d			endif 
# End of file forth_startupv1.asm
e29d			endif 
e29d			if STARTUP_V2 
e29d				include "forth_startupv2.asm" 
e29d			endif 
e29d			 
# End of file forth_startup.asm
e29d			 
e29d			; eof 
# End of file forth_kernel.asm
e29d			;include "nascombasic.asm" 
e29d			 
e29d			 
e29d			; find out where the code ends if loaded into RAM (for SC114) 
e29d			;endofcode:  
e29d			;	nop 
e29d			 
e29d			 
e29d			; eof 
e29d			 
# End of file main.asm
e29d			;include "firmware_lcd_4x40.asm" 
e29d			;;include "firmware_lcd_4x20.asm" 
e29d			include "firmware_serial_display.asm" 
e29d			 
e29d			; Serial display interface for SC114 
e29d			 
e29d			 
e29d			display_row_1: equ 0 
e29d			display_row_2: equ display_row_1+display_cols 
e29d			display_row_3: equ display_row_2 + display_cols 
e29d			display_row_4: equ display_row_3 + display_cols 
e29d			 
e29d			kLCDWidth:  EQU display_cols             ;Width in characters 
e29d			kLCD_Line1: EQU 0x00  
e29d			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e29d			; E1 
e29d			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e29d			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e29d			 
e29d			lcd_init: 
e29d				; no init as handled by the SCM bios 
e29d c9				ret 
e29e			 
e29e			 
e29e			; low level functions for direct screen writes 
e29e			 
e29e			; output char at pos? 
e29e			fLCD_Str: 
e29e			        ;out (SC114_SIO_1_OUT),a 
e29e c5				push bc 
e29f 0e 02			ld c, $02 
e2a1 f7				rst $30 
e2a2 c1				pop bc 
e2a3 c9				ret 
e2a4			 
e2a4			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e2a4			fLCD_Pos: 
e2a4				; use ASCII escape to position 
e2a4			        ;out (SC114_SIO_1_OUT),a 
e2a4 c5				push bc 
e2a5 0e 02			ld c, $02 
e2a7 f7				rst $30 
e2a8 c1				pop bc 
e2a9			 
e2a9 c9				ret 
e2aa			 
e2aa			; output char at pos 
e2aa			fLCD_Data: 
e2aa			      ;  out (SC114_SIO_1_OUT),a 
e2aa c5				push bc 
e2ab 0e 02			ld c, $02 
e2ad f7				rst $30 
e2ae c1				pop bc 
e2af			 
e2af c9				ret 
e2b0			 
e2b0			; ascii cls  
e2b0			 
e2b0 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e2b4			 
e2b4			; write the frame buffer given in hl to hardware  
e2b4			write_display: 
e2b4			 
e2b4			API: equ 0 
e2b4			 
e2b4			if API 
e2b4				push bc 
e2b4				ld b, 4 
e2b4			 
e2b4			        ld (display_write_tmp), hl 	  
e2b4			 
e2b4				; clear and home cursor 
e2b4			 
e2b4				ld c, 6 
e2b4				ld de, .cls 
e2b4				rst $30 
e2b4			 
e2b4			 
e2b4			.writeln: 
e2b4			 
e2b4				ld de, (display_write_tmp) 
e2b4				ld c, 6 
e2b4				rst $30 
e2b4				ld c, 7 
e2b4				rst $30 
e2b4			 
e2b4				ld hl, (display_write_tmp) 
e2b4				ld de, display_cols 
e2b4				add hl,de 
e2b4				ld (display_write_tmp),hl 
e2b4			 
e2b4				djnz  .writeln 
e2b4			 
e2b4				pop bc 
e2b4			 
e2b4			 
e2b4				ret 
e2b4			endif 
e2b4 e5				push hl 
e2b5 c5				push bc 
e2b6 d5				push de 
e2b7			 
e2b7			;	ld c, 2 
e2b7			;	;ld de, .cls 
e2b7			;	ld a, 27 
e2b7			;	rst $30 
e2b7			;	ld c, 2 
e2b7			;	;ld de, .cls 
e2b7			;	ld a, '[' 
e2b7			;	rst $30 
e2b7			; 
e2b7			;	ld c, 2 
e2b7			;	;ld de, .cls 
e2b7			;	ld a, 'H' 
e2b7			;	rst $30 
e2b7			; 
e2b7			 
e2b7 0e 02			ld c, 2 
e2b9				;ld de, .cls 
e2b9 3e 1b			ld a, 27 
e2bb f7				rst $30 
e2bc			 
e2bc			 
e2bc 0e 02			ld c, 2 
e2be				;ld de, .cls 
e2be 3e 5b			ld a, '[' 
e2c0 f7				rst $30 
e2c1 0e 02			ld c, 2 
e2c3				;ld de, .cls 
e2c3 3e 32			ld a, '2' 
e2c5 f7				rst $30 
e2c6 0e 02			ld c, 2 
e2c8				;ld de, .cls 
e2c8 3e 4a			ld a, 'J' 
e2ca f7				rst $30 
e2cb d1				pop de 
e2cc c1				pop bc 
e2cd e1				pop hl 
e2ce			 
e2ce			 
e2ce 22 cf eb		        ld (display_write_tmp), hl 	  
e2d1 3e 00			ld a, kLCD_Line1 
e2d3			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e2d3 06 28			ld b, display_cols 
e2d5 ed 5b cf eb		ld de, (display_write_tmp) 
e2d9 cd 37 e3			call write_len_string 
e2dc				 
e2dc			 
e2dc e5			push hl 
e2dd d5			push de 
e2de c5			push bc 
e2df 0e 07			ld c, 7 
e2e1 f7				rst $30 
e2e2 c1			pop bc 
e2e3 d1			pop de 
e2e4 e1			pop hl 
e2e5			 
e2e5				 
e2e5 2a cf eb			ld hl, (display_write_tmp) 
e2e8 11 28 00			ld de, display_cols 
e2eb 19				add hl,de 
e2ec 22 cf eb			ld (display_write_tmp),hl 
e2ef			 
e2ef				 
e2ef 3e 28			ld a, kLCD_Line2 
e2f1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e2f1 06 28			ld b, display_cols 
e2f3 ed 5b cf eb		ld de, (display_write_tmp) 
e2f7 cd 37 e3			call write_len_string 
e2fa				 
e2fa 2a cf eb			ld hl, (display_write_tmp) 
e2fd 11 28 00			ld de, display_cols 
e300 19				add hl,de 
e301 22 cf eb			ld (display_write_tmp),hl 
e304			 
e304 e5			push hl 
e305 d5			push de 
e306 c5			push bc 
e307 0e 07			ld c, 7 
e309 f7				rst $30 
e30a c1			pop bc 
e30b d1			pop de 
e30c e1			pop hl 
e30d			 
e30d				 
e30d 3e 50			ld a, kLCD_Line3 
e30f			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e30f 06 28			ld b, display_cols 
e311 ed 5b cf eb		ld de, (display_write_tmp) 
e315 cd 37 e3			call write_len_string 
e318				 
e318 2a cf eb			ld hl, (display_write_tmp) 
e31b 11 28 00			ld de, display_cols 
e31e 19				add hl,de 
e31f 22 cf eb			ld (display_write_tmp),hl 
e322			 
e322 e5			push hl 
e323 d5			push de 
e324 c5			push bc 
e325 0e 07			ld c, 7 
e327 f7				rst $30 
e328 c1			pop bc 
e329 d1			pop de 
e32a e1			pop hl 
e32b			 
e32b				 
e32b 3e 78			ld a, kLCD_Line4 
e32d			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e32d 06 28			ld b, display_cols 
e32f ed 5b cf eb		ld de, (display_write_tmp) 
e333 cd 37 e3			call write_len_string 
e336 c9					ret 
e337			 
e337			 
e337				; write out a fixed length string given in b from de 
e337			 
e337 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e338 cd aa e2		            CALL fLCD_Data      ;Write character to display 
e33b 13				inc de 
e33c 10 f9			djnz write_len_string 
e33e c9				ret 
e33f			 
e33f			 
e33f			; eof 
# End of file firmware_serial_display.asm
e33f			;include "firmware_key_5x10.asm" 
e33f			;;include "firmware_key_4x10.asm" 
e33f			include "firmware_key_serial.asm" 
e33f			; Serial keyboard interface for SC114 
e33f			 
e33f			key_init: 
e33f				; no init as handled by the SCM bios 
e33f c9				ret 
e340			 
e340			 
e340			cin_wait: 
e340			;	ld a, 0 
e340			;	ret 
e340			 
e340				;in a,(SC114_SIO_1_IN) 
e340			        ; Use SCM API to get from whatever console device we are using 
e340 c5				push bc 
e341 0e 01			ld c, $01 
e343 f7				rst $30 
e344 c1				pop bc 
e345 c9				ret 
e346			 
e346			cin: 
e346			 
e346			 
e346 c5				push bc 
e347			 
e347				; any key waiting to process? 
e347 0e 03			ld c, $03 
e349 f7				rst $30 
e34a 28 05			jr z, .cin_skip 
e34c			 
e34c				; yep, get it 
e34c			 
e34c 0e 01			ld c, $01 
e34e f7				rst $30 
e34f c1				pop bc 
e350 c9				ret 
e351			.cin_skip: 
e351 3e 00			ld a, 0 
e353 c1				pop bc 
e354 c9				ret 
e355			 
e355			 
e355			 
e355			 
# End of file firmware_key_serial.asm
e355			endofcode:  
e355			baseram:  
e355 00				nop 
e356			 
e356			heap_start: equ baseram+15  ; Starting address of heap 
e356			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e356			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e356			;VDU:  EQU     endofcode           ; BASIC Work space 
e356			; eof 
e356			 
# End of file os_mega_sc114.asm
e356
