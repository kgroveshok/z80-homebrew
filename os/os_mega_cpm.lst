# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 8b 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd a8 63				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 96 64			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 be 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 d3 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 79 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd e8 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 80 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd e8 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 80 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd e8 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 79 ea				ld hl, (store_tmp1) 
0210 11 83 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd e8 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd e8 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd e8 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd e8 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd e8 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 80 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 82 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd e8 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd e8 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 80 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 80 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd e8 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 81 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd e8 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd e8 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 80 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 81 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 83 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 8c ea			ld hl, store_page+3+9 
03b5 3a 65 ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 80 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd e8 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd e8 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd e8 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 83 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd e8 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 80 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd e8 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd e8 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 80 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd e8 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 80 ea			ld a, (store_page)	; get file id 
0510 32 74 ea			ld (store_tmpid), a 
0513			 
0513 3a 82 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 73 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 80 ea			ld (store_page), a 
051f 32 81 ea			ld (store_page+1),a 
0522 11 80 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd e8 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 73 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 74 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd e8 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 80 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 80 ea			ld (store_page), a 
0582 32 81 ea			ld (store_page+1),a 
0585 11 80 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd e8 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd e8 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd e8 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd e8 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd e8 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 80 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 80 ea			ld (store_page),a 
06a3				 
06a3 32 74 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 80 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd e8 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 80 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd e8 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 6b ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd e8 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 6b ea			ld (store_tmppageid), hl 
0715				 
0715 3a 74 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 80 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 81 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 82 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 83 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd e8 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd e8 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd e8 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 6b ea			ld hl,(store_tmppageid) 
078b 11 80 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd e8 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 74 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd e8 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 7e ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 7c ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd e8 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd e8 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 71 ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 7c ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 71 ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 72 ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 73 ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd e8 15			call break_point_state  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 73 ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 71 ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 72 ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 73 ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd e8 15			call break_point_state  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 7b ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 7c ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 71 ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 72 ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 73 ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd e8 15			call break_point_state  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 7c ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 7e ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 7e ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 71 ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 72 ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 73 ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd e8 15			call break_point_state  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 71 ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 72 ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 73 ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd e8 15			call break_point_state  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 71 ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 7c ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 7c ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 71 ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 72 ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 73 ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd e8 15			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 71 ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 72 ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 73 ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd e8 15			call break_point_state  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 71 ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 72 ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 73 ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd e8 15			call break_point_state  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 71 ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 72 ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 73 ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd e8 15			call break_point_state  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 74 ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 74 ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 6b ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 71 ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 72 ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 73 ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd e8 15			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 80 ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 71 ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 72 ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 73 ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd e8 15			call break_point_state  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 82 ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 82 ea			ld (store_page+2), a 
09e3 32 73 ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 71 ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 72 ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 73 ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd e8 15			call break_point_state  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 6b ea			ld hl, (store_tmppageid) 
0a05 11 80 ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 6b ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 71 ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 72 ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 73 ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd e8 15			call break_point_state  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 80 ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 74 ea				ld a, (store_tmpid) 
0a4b 32 80 ea				ld (store_page), a   ; file id 
0a4e 3a 73 ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 81 ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 82 ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 71 ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 72 ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 73 ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd e8 15			call break_point_state  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 6b ea			ld hl, (store_tmppageid) 
0a85 11 80 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 71 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 72 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 73 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd e8 15			call break_point_state  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 74 ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 80 ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 81 ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a cc eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 cc eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 8d 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 cd eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 cd eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a d2 eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b7 ed				ld hl, display_fb0 
0b53 22 d2 eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd d6 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 16 ed				ld hl, display_fb1 
0b74 22 d2 eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a d2 eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a d2 eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a d2 eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a d2 eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a d2 eb			ld hl, (display_fb_active) 
0be1 cd e5 63			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 79 ea				ld (store_tmp1), hl 
0bee 32 77 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b7 ed				ld hl, display_fb0 
0bf4 22 d2 eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 75 ea				ld (store_tmp3), a   ; display row count 
0c02 3a 77 ea				ld a,( store_tmp2) 
0c05 32 78 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 78 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 79 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 75 ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 78 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 78 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 75 ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 75 ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 77 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 97 64				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 77 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 77 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 77 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 77 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 77 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 16 ed				ld hl, display_fb1 
0cb1 22 d2 eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a b1 eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 b1 eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b7 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b9 eb		        ld hl,LFSRSeed+6 
0d04 11 ba eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a ab eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 ab eb		    ld (seed1),hl 
0d1a 2a a9 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a9 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a af eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 af eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 6c ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c7 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 66 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 65 ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 66 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 66 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 65 ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 65 ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 66 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 6f ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 6d ee			ld de, (input_start) 
0e69 3a 6a ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 65 ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 68 ee				ld a,(input_at_cursor) 
0e79 11 c7 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 6d ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 60 ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 9f 64				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 6d ee				ld hl, (input_start) 
0e98 3a 5b ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 6f ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 6a ee				ld a, (input_at_pos) 
0ea9 32 68 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 5b ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 6f ee				ld (input_ptr), hl 
0ed1 3a 68 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 68 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 6f ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 6f ee				ld (input_ptr), hl 
0ef0 3a 68 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 68 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 5b ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 5b ee				ld (input_cursor), a 
0f09			 
0f09 2a 6f ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 6f ee				ld (input_ptr), hl 
0f10					 
0f10 3a 68 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 68 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 65 ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 66 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 5b ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 5b ee				ld (input_cursor), a 
0f37			 
0f37 3a 68 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 68 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 6f ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 6f ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 65 ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 66 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 6d ee				ld hl, (input_start) 
0f59 22 6f ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 6a ee				ld a, (input_at_pos) 
0f5f 32 68 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 5b ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 ee e5				ld hl, os_cli_cmd 
0f6a 11 ed e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 5b ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 5b ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 6f ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 6f ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 68 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 68 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 65 ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 66 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 68 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 5b ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 68 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 68 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 6f ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 6f ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 6f ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 6f ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 65 ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 66 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 6d ee				ld hl, (input_start) 
0ffa 3a 60 ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 60 ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 5b ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 5b ee				ld (input_cursor), a 
1022			 
1022 3a 68 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 68 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 6d ee				ld hl, (input_start) 
102f 3a 60 ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 6a ee		input_str_prev:	ld (input_at_pos), a 
1042 22 6d ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 6f ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 6c ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 5b ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 6f ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c7 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 6a ee				ld a,(input_at_pos) 
1063 cd b4 63		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 6d ee	            	LD   de, (input_start) 
106a cd a9 63		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 9f 64				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 6f ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c7 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 6f ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 6f ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 6f ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 6f ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 6f ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c7 e2			ld hl, scratch 
10bd 11 ed e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c7 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 6f ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 75 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 fb e2			ld (scratch+52),a 
11be				 
11be 21 f9 e2			ld hl,scratch+50 
11c1 22 ea e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				ld a, 0 
128a				ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				ld a, 0 
128a				ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				ld a, 0 
128a				ld (os_view_disable), a 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 c7 64		      ld    HL, heap_start 
128e 22 c2 64		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 c4 64		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a9 e2		      ld    HL, heap_start+heap_size-4 
129a 22 c7 64		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 e2 7d		      ld    HL, heap_size-4 
12a0 22 c9 64		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 ab e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a9 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 c2 64		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 c2 64		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			if SOUND_ENABLE  
1447				include "firmware_sound.asm"  
1447			endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 77 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452 fe 01			cp 1 
1454 cc a5 14			call z, .savetostore 
1457			 
1457 fe 02			cp 2 
1459			if STARTUP_V1 
1459 cc 91 14			call z, .selautoload 
145c			endif 
145c			 
145c			if STARTUP_V2 
145c				call z, .enautoload 
145c			endif 
145c fe 03			cp 3 
145e cc 87 14			call z, .disautoload 
1461 fe 04			cp 4 
1463 cc 9b 14			call z, .selbank 
1466 fe 05			cp 5 
1468 cc af 14			call z, .debug_tog 
146b fe 06			cp 6 
146d cc f2 15			call z, .bpsgo 
1470 fe 07			cp 7 
1472 cc d5 14			call z, hardware_diags 
1475			if STARTUP_V2 
1475				cp 8 
1475				call z, create_startup 
1475			endif 
1475 18 d0			jr config 
1477			 
1477			.configmn: 
1477 e3 17			dw prom_c3 
1479 fa 17			dw prom_c2 
147b 0f 18			dw prom_c2a 
147d 25 18			dw prom_c2b 
147f			;	dw prom_c4 
147f 42 18			dw prom_m4 
1481 5d 18			dw prom_m4b 
1483 65 18			dw prom_c1 
1485			if STARTUP_V2 
1485				dw prom_c9 
1485			endif 
1485 00 00			dw 0 
1487				 
1487			 
1487			if STARTUP_V2 
1487			.enautoload: 
1487				if STORAGE_SE 
1487				ld a, $fe      ; bit 0 clear 
1487				ld (spi_device), a 
1487			 
1487				call storage_get_block_0 
1487			 
1487				ld a, 1 
1487				ld (store_page+STORE_0_AUTOFILE), a 
1487			 
1487					ld hl, 0 
1487					ld de, store_page 
1487				call storage_write_block	 ; save update 
1487				else 
1487			 
1487				ld hl, prom_notav 
1487				ld de, prom_empty 
1487				call info_panel 
1487				endif 
1487			 
1487			 
1487				ret 
1487			endif 
1487			 
1487			.disautoload: 
1487				if STORAGE_SE 
1487				ld a, $fe      ; bit 0 clear 
1487				ld (spi_device), a 
1487			 
1487				call storage_get_block_0 
1487			 
1487				ld a, 0 
1487				ld (store_page+STORE_0_AUTOFILE), a 
1487			 
1487					ld hl, 0 
1487					ld de, store_page 
1487				call storage_write_block	 ; save update 
1487				else 
1487			 
1487 21 74 18			ld hl, prom_notav 
148a 11 8a 18			ld de, prom_empty 
148d cd 4b 0b			call info_panel 
1490				endif 
1490			 
1490			 
1490 c9				ret 
1491			 
1491			if STARTUP_V1 
1491			 
1491			; Select auto start 
1491			 
1491			.selautoload: 
1491			 
1491				 
1491				if STORAGE_SE 
1491			 
1491					call config_dir 
1491				        ld hl, scratch 
1491					ld a, 0 
1491					call menu 
1491			 
1491					cp 0 
1491					ret z 
1491			 
1491					dec a 
1491			 
1491			 
1491					; locate menu option 
1491			 
1491					ld hl, scratch 
1491					call table_lookup 
1491			 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "ALl" 
1491						CALLMONITOR 
1491					endif 
1491					; with the pointer to the menu it, the byte following the zero term is the file id 
1491			 
1491					ld a, 0 
1491					ld bc, 50   ; max of bytes to look at 
1491					cpir  
1491			 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "ALb" 
1491						CALLMONITOR 
1491					endif 
1491					;inc hl 
1491			 
1491					ld a, (hl)   ; file id 
1491					 
1491				        ; save bank and file ids 
1491			 
1491					push af 
1491			 
1491			; TODO need to save to block 0 on bank 1	 
1491			 
1491					call storage_get_block_0 
1491			 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "AL0" 
1491						CALLMONITOR 
1491					endif 
1491					pop af 
1491			 
1491					ld (store_page+STORE_0_FILERUN),a 
1491					 
1491					; save bank id 
1491			 
1491					ld a,(spi_device) 
1491					ld (store_page+STORE_0_BANKRUN),a 
1491			 
1491					; enable auto run of store file 
1491			 
1491					ld a, 1 
1491					ld (store_page+STORE_0_AUTOFILE),a 
1491			 
1491					; save buffer 
1491			 
1491					ld hl, 0 
1491					ld de, store_page 
1491					if DEBUG_FORTH_WORDS 
1491						DMARK "ALw" 
1491						CALLMONITOR 
1491					endif 
1491				call storage_write_block	 ; save update 
1491			  
1491			 
1491			 
1491			 
1491					ld hl, scratch 
1491					call config_fdir 
1491			 
1491				else 
1491			 
1491 21 74 18			ld hl, prom_notav 
1494 11 8a 18			ld de, prom_empty 
1497 cd 4b 0b			call info_panel 
149a			 
149a				endif 
149a c9				ret 
149b			endif 
149b			 
149b			 
149b			; Select storage bank 
149b			 
149b			.selbank: 
149b			 
149b				if STORAGE_SE 
149b				else 
149b			 
149b 21 74 18			ld hl, prom_notav 
149e 11 8a 18			ld de, prom_empty 
14a1 cd 4b 0b			call info_panel 
14a4				endif 
14a4				 
14a4 c9				ret 
14a5			 
14a5			if STORAGE_SE 
14a5			 
14a5			.config_ldir:   
14a5				; Load storage bank labels into menu array 
14a5			 
14a5				 
14a5			 
14a5			 
14a5				ret 
14a5			 
14a5			 
14a5			endif 
14a5			 
14a5			 
14a5			; Save user words to storage 
14a5			 
14a5			.savetostore: 
14a5			 
14a5				if STORAGE_SE 
14a5			 
14a5					call config_dir 
14a5				        ld hl, scratch 
14a5					ld a, 0 
14a5					call menu 
14a5					 
14a5					ld hl, scratch 
14a5					call config_fdir 
14a5			 
14a5				else 
14a5			 
14a5 21 74 18			ld hl, prom_notav 
14a8 11 8a 18			ld de, prom_empty 
14ab cd 4b 0b			call info_panel 
14ae			 
14ae				endif 
14ae			 
14ae c9				ret 
14af			 
14af			if STARTUP_V2 
14af			 
14af			create_startup: 
14af			 
14af				ld a, 0 
14af				ld hl, .crstart 
14af				call menu 
14af			 
14af				cp 0 
14af				ret z 
14af			 
14af				cp 1 
14af				call z, .genlsword 
14af				cp 2 
14af				call z, .genedword 
14af			 
14af				cp 3 
14af				call z, .gendemword 
14af			 
14af				cp 4 
14af				call z, .genutlword 
14af				cp 5 
14af				call z, .genspiword 
14af				cp 6 
14af				call z, .genkeyword 
14af				jr create_startup 
14af			 
14af			.genlsword: 
14af				ld hl, crs_s1 
14af				ld de, .lsworddef 
14af				call .genfile 
14af				ret 
14af			 
14af			.genedword: 
14af				ld de, .edworddef 
14af				ld hl, crs_s2 
14af				call .genfile 
14af				ret 
14af			 
14af			.gendemword: 
14af				ld de, .demoworddef 
14af				ld hl, crs_s3 
14af				call .genfile 
14af				ret 
14af			 
14af			.genutlword: 
14af				ld hl, crs_s4 
14af				ld de, .utilwordef 
14af				call .genfile 
14af				ret 
14af			.genspiword: 
14af				ld hl, crs_s5 
14af				ld de, .spiworddef 
14af				call .genfile 
14af				ret 
14af			.genkeyword: 
14af				ld hl, crs_s6 
14af				ld de, .keyworddef 
14af				call .genfile 
14af				ret 
14af			 
14af			; hl - points to file name 
14af			; de - points to strings to add to file 
14af			 
14af			.genfile: 
14af				push hl 
14af				push de 
14af			 
14af				call clear_display 
14af				ld a, display_row_1 
14af				ld de, .genfiletxt 
14af				call str_at_display 
14af				call update_display 
14af			 
14af				pop de 
14af				pop hl 
14af			 
14af			 
14af				push de 
14af				call storage_create 
14af				; id in hl 
14af				pop de   ; table of strings to add 
14af			 
14af			.genloop: 
14af			 
14af				push hl ; save id for next time around 
14af				push de ; save de for next time around 
14af			 
14af				ex de, hl 
14af				call loadwordinhl 
14af				ex de, hl 
14af			 
14af				; need hl to be the id 
14af				; need de to be the string ptr 
14af				 
14af				call storage_append 
14af			 
14af				pop de 
14af				pop hl 
14af			 
14af				inc de 
14af				inc de 
14af			 
14af				ld a,(de) 
14af				cp 0 
14af				jr nz, .genloop 
14af				inc de 
14af				ld a, (de) 
14af				dec de 
14af				cp 0 
14af				jr nz, .genloop	 
14af			 
14af				ret 
14af			 
14af			.genfiletxt:  db "Creating file...",0 
14af			 
14af			.utilwordef: 
14af				dw strncpy 
14af				dw type 
14af				dw clrstack 
14af				dw longread 
14af				dw start1 
14af				dw start2 
14af				dw start3b 
14af				dw start3c 
14af				dw list 
14af				dw 0 
14af			 
14af			.lsworddef: 
14af				dw start3b 
14af				dw 0 
14af			 
14af			.edworddef: 
14af				dw edit1 
14af				dw edit2 
14af				dw edit3 
14af				dw 0 
14af			 
14af			.demoworddef: 
14af				dw test5 
14af				dw test6 
14af				dw test7 
14af				dw test8 
14af				dw test9 
14af				dw test10 
14af				dw game1 
14af				dw game1a 
14af				dw game1b 
14af				dw game1c 
14af				dw game1d 
14af				dw game1s 
14af				dw game1t 
14af				dw game1f 
14af				dw game1z 
14af				dw game1zz 
14af				dw ssv2 
14af				dw ssv3 
14af				dw ssv4 
14af				dw ssv5 
14af				dw ssv1 
14af				dw ssv1cpm	 
14af				dw game2b 
14af				dw game2bf 
14af				dw game2mba 
14af				dw game2mbas	 
14af				dw game2mbht 
14af				dw game2mbms 
14af				dw game2mb 
14af				dw game3w 
14af				dw game3p 
14af				dw game3sc 
14af				dw game3vsi 
14af				dw game3vs 
14af				dw 0 
14af			 
14af			 
14af			.spiworddef: 
14af			 
14af			    dw spi1 
14af			    dw spi2 
14af			    dw spi3 
14af			    dw spi4 
14af			    dw spi5 
14af			    dw spi6 
14af			    dw spi7 
14af			 
14af			    dw spi8 
14af			    dw spi9 
14af			    dw spi10 
14af			    dw 0 
14af			 
14af			.keyworddef: 
14af			 
14af				dw keyup 
14af				dw keydown 
14af				dw keyleft 
14af				dw keyright 
14af				dw 	keyf1 
14af				dw keyf2 
14af				dw keyf3 
14af				dw keyf4 
14af				dw keyf5 
14af				dw keyf6 
14af				dw keyf7 
14af				dw keyf8 
14af				dw keyf9 
14af				dw keyf10 
14af				dw keyf11 
14af				dw keyf12 
14af				dw keytab 
14af				dw keycr 
14af				dw keyhome 
14af				dw keyend 
14af				dw keybs 
14af				dw 0 
14af			 
14af			.crstart: 
14af				dw crs_s1 
14af				dw crs_s2 
14af				dw crs_s3 
14af				dw crs_s4 
14af				dw crs_s5 
14af				dw crs_s6 
14af				dw 0 
14af			 
14af			endif 
14af			 
14af			 
14af			if STORAGE_SE 
14af			 
14af			config_fdir: 
14af				; using the scratch dir go through and release the memory allocated for each string 
14af				 
14af				ld hl, scratch 
14af			.cfdir:	ld e,(hl) 
14af				inc hl 
14af				ld d,(hl) 
14af				inc hl 
14af			 
14af				ex de, hl 
14af				call ishlzero 
14af				ret z     ; return on null pointer 
14af				call free 
14af				ex de, hl 
14af				jr .cfdir 
14af			 
14af			 
14af				ret 
14af			 
14af			 
14af			config_dir: 
14af			 
14af				; for the config menus that need to build a directory of storage call this routine 
14af				; it will construct a menu in scratch to pass to menu 
14af			 
14af				; open storage device 
14af			 
14af				; execute DIR to build a list of files and their ids into scratch in menu format 
14af				; once the menu has finished then will need to call config_fdir to release the strings 
14af				 
14af				; c = number items 
14af			 
14af				 
14af				call storage_get_block_0 
14af			 
14af				ld hl, store_page     ; get current id count 
14af				ld b, (hl) 
14af				ld c, 0    ; count of files   
14af			 
14af			 
14af				ld hl, scratch 
14af				ld (store_tmp2), hl    ; location to poke strings 
14af			 
14af				; check for empty drive 
14af			 
14af				ld a, 0 
14af				cp b 
14af				jp z, .dirdone 
14af			 
14af				 
14af					if DEBUG_FORTH_WORDS 
14af						DMARK "Cdc" 
14af						CALLMONITOR 
14af					endif 
14af			 
14af			 
14af			.diritem:	 
14af				push bc 
14af				; for each of the current ids do a search for them and if found push to stack 
14af			 
14af					ld hl, STORE_BLOCK_PHY 
14af					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14af					ld e,b 
14af			 
14af					call storage_findnextid 
14af			 
14af			 
14af					; if found hl will be non zero 
14af			 
14af					call ishlzero 
14af					jr z, .dirnotfound 
14af			 
14af					; increase count 
14af			 
14af					pop bc	 
14af					inc c 
14af					push bc 
14af					 
14af			 
14af					; get file header and push the file name 
14af			 
14af					ld de, store_page 
14af					call storage_read_block 
14af			 
14af					; push file id to stack 
14af				 
14af					ld a, (store_page) 
14af					ld h, 0 
14af					ld l, a 
14af			 
14af					;call forth_push_numhl 
14af					; TODO store id 
14af			 
14af					push hl 
14af			 
14af					; push extent count to stack  
14af				 
14af					ld hl, store_page+3 
14af			 
14af					; get file name length 
14af			 
14af					call strlenz   
14af			 
14af					inc hl   ; cover zero term 
14af					inc hl  ; stick the id at the end of the area 
14af			 
14af					push hl 
14af					pop bc    ; move length to bc 
14af			 
14af					call malloc 
14af			 
14af					; TODO save malloc area to scratch 
14af			 
14af					ex de, hl 
14af					ld hl, (store_tmp2) 
14af					ld (hl), e 
14af					inc hl 
14af					ld (hl), d 
14af					inc hl 
14af					ld (store_tmp2), hl 
14af			 
14af					 
14af			 
14af					;pop hl   ; get source 
14af			;		ex de, hl    ; swap aronund	 
14af			 
14af					ld hl, store_page+3 
14af					if DEBUG_FORTH_WORDS 
14af						DMARK "CFd" 
14af						CALLMONITOR 
14af					endif 
14af					ldir 
14af			 
14af					; de is past string, move back one and store id 
14af					 
14af					dec de 
14af			 
14af					; store file id 
14af			 
14af					pop hl 
14af					ex de,hl 
14af					ld (hl), e 
14af			 
14af					if DEBUG_FORTH_WORDS 
14af						DMARK "Cdi" 
14af						CALLMONITOR 
14af					endif 
14af					 
14af			.dirnotfound: 
14af					pop bc     
14af					djnz .diritem 
14af				 
14af			.dirdone:	 
14af			 
14af					ld a, 0 
14af					ld hl, (store_tmp2) 
14af					ld (hl), a 
14af					inc hl 
14af					ld (hl), a 
14af					inc hl 
14af					; push a count of the dir items found 
14af			 
14af			;		ld h, 0 
14af			;		ld l, c 
14af			 
14af				ret 
14af			 
14af			endif 
14af			 
14af			 
14af			; Settings 
14af			; Run  
14af			 
14af			 
14af			 
14af			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14af			;;hd_menu2:   db "        2: Editor",0   
14af			;hd_menu2:   db "        2: Editor       6: Menu",0   
14af			;hd_menu3:   db "        3: Storage",0 
14af			;hd_menu4:   db "0=quit  4: Debug",0 
14af			;hd_don:     db "ON",0 
14af			;hd_doff:     db "OFF",0 
14af			; 
14af			; 
14af			; 
14af			;hardware_diags_old:       
14af			; 
14af			;.diagmenu: 
14af			;	call clear_display 
14af			;	ld a, display_row_1 
14af			;	ld de, hd_menu1 
14af			;	call str_at_display 
14af			; 
14af			;	ld a, display_row_2 
14af			;	ld de, hd_menu2 
14af			;	call str_at_display 
14af			; 
14af			;	ld a, display_row_3 
14af			;	ld de, hd_menu3 
14af			;	call str_at_display 
14af			; 
14af			;	ld a,  display_row_4 
14af			;	ld de, hd_menu4 
14af			;	call str_at_display 
14af			; 
14af			;	; display debug state 
14af			; 
14af			;	ld de, hd_don 
14af			;	ld a, (os_view_disable) 
14af			;	cp 0 
14af			;	jr z, .distog 
14af			;	ld de, hd_doff 
14af			;.distog: ld a, display_row_4+17 
14af			;	call str_at_display 
14af			; 
14af			;	call update_display 
14af			; 
14af			;	call cin_wait 
14af			; 
14af			; 
14af			; 
14af			;	cp '4' 
14af			;	jr nz, .diagn1 
14af			; 
14af			;	; debug toggle 
14af			; 
14af			;	ld a, (os_view_disable) 
14af			;	ld b, '*' 
14af			;	cp 0 
14af			;	jr z, .debtog 
14af			;	ld b, 0 
14af			;.debtog:	 
14af			;	ld a,b 
14af			;	ld (os_view_disable),a 
14af			; 
14af			;.diagn1: cp '0' 
14af			;	 ret z 
14af			; 
14af			;;	cp '1' 
14af			;;       jp z, matrix	 
14af			;;   TODO keyboard matrix test 
14af			; 
14af			;	cp '2' 
14af			;	jp z, .diagedit 
14af			; 
14af			;;	cp '6' 
14af			;;	jp z, .menutest 
14af			;;if ENABLE_BASIC 
14af			;;	cp '6' 
14af			;;	jp z, basic 
14af			;;endif 
14af			 ; 
14af			;	jp .diagmenu 
14af			; 
14af			; 
14af			;	ret 
14af			 
14af			 
14af			.debug_tog: 
14af 21 f6 14			ld hl, .menudebug 
14b2				 
14b2 3a b8 e2			ld a, (os_view_disable) 
14b5 fe 2a			cp '*' 
14b7 20 04			jr nz,.tdon  
14b9 3e 01			ld a, 1 
14bb 18 02			jr .tog1 
14bd 3e 00		.tdon: ld a, 0 
14bf			 
14bf			.tog1: 
14bf cd eb 0b			call menu 
14c2 fe 00			cp 0 
14c4 c8				ret z 
14c5 fe 01			cp 1    ; disable debug 
14c7 28 04			jr z, .dtog0 
14c9 3e 2a			ld a, '*' 
14cb 18 02			jr .dtogset 
14cd 3e 00		.dtog0: ld a, 0 
14cf 32 b8 e2		.dtogset:  ld (os_view_disable), a 
14d2 c3 af 14			jp .debug_tog 
14d5			 
14d5			 
14d5			hardware_diags:       
14d5			 
14d5			.diagm: 
14d5 21 e8 14			ld hl, .menuitems 
14d8 3e 00			ld a, 0 
14da cd eb 0b			call menu 
14dd			 
14dd fe 00		         cp 0 
14df c8				 ret z 
14e0			 
14e0 fe 02			cp 2 
14e2 ca 41 15			jp z, .diagedit 
14e5			 
14e5			;	cp '6' 
14e5			;	jp z, .menutest 
14e5			;if ENABLE_BASIC 
14e5			;	cp '6' 
14e5			;	jp z, basic 
14e5			;endif 
14e5			  
14e5 c3 d5 14			jp .diagm 
14e8			 
14e8				 
14e8 fc 14		.menuitems:   	dw .m1 
14ea 07 15				dw .m2 
14ec 0e 15				dw .m3 
14ee 16 15				dw .m5 
14f0 1c 15				dw .m5a 
14f2 25 15				dw .m5b 
14f4 00 00				dw 0 
14f6			 
14f6			.menudebug: 
14f6 2e 15				dw .m6 
14f8 37 15				dw .m7 
14fa 00 00				dw 0 
14fc			 
14fc .. 00		.m1:   db "Key Matrix",0 
1507 .. 00		.m2:   db "Editor",0 
150e .. 00		.m3:   db "Storage",0 
1516 .. 00		.m5:   db "Sound",0 
151c .. 00		.m5a:  db "RAM Test",0 
1525 .. 00		.m5b:  db "LCD Test",0 
152e			 
152e .. 00		.m6:   db "Debug ON",0 
1537 .. 00		.m7:   db "Debug OFF",0 
1541			 
1541			; debug editor 
1541			 
1541			.diagedit: 
1541			 
1541 21 c7 e2			ld hl, scratch 
1544			;	ld bc, 250 
1544			;	ldir 
1544				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1544 3e 00			ld a, 0 
1546 77				ld (hl), a 
1547 23				inc hl 
1548 77				ld (hl), a 
1549 23				inc hl 
154a 77				ld (hl), a 
154b			 
154b cd ba 0b		        call clear_display 
154e cd dd 0b			call update_display 
1551				;ld a, 1 
1551				;ld (hardware_diag), a 
1551			.diloop: 
1551 3e 00			ld a, display_row_1 
1553 0e 00			ld c, 0 
1555 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1557 1e 28			ld e, 40 
1559			 
1559 21 c7 e2			ld hl, scratch	 
155c cd 14 0e			call input_str 
155f			 
155f 3e 28			ld a, display_row_2 
1561 11 c7 e2			ld de, scratch 
1564 cd cd 0b			call str_at_display 
1567 cd dd 0b			call update_display 
156a			 
156a c3 51 15			jp .diloop 
156d			 
156d			 
156d			; pass word in hl 
156d			; a has display location 
156d			display_word_at: 
156d f5				push af 
156e e5				push hl 
156f 7c				ld a,h 
1570 21 cc e5			ld hl, os_word_scratch 
1573 cd e8 10			call hexout 
1576 e1				pop hl 
1577 7d				ld a,l 
1578 21 ce e5			ld hl, os_word_scratch+2 
157b cd e8 10			call hexout 
157e 21 d0 e5			ld hl, os_word_scratch+4 
1581 3e 00			ld a,0 
1583 77				ld (hl),a 
1584 11 cc e5			ld de,os_word_scratch 
1587 f1				pop af 
1588 cd cd 0b				call str_at_display 
158b c9				ret 
158c			 
158c			display_ptr_state: 
158c			 
158c				; to restore afterwards 
158c			 
158c d5				push de 
158d c5				push bc 
158e e5				push hl 
158f f5				push af 
1590			 
1590				; for use in here 
1590			 
1590			;	push bc 
1590			;	push de 
1590			;	push hl 
1590			;	push af 
1590			 
1590 cd ba 0b			call clear_display 
1593			 
1593 11 66 17			ld de, .ptrstate 
1596 3e 00			ld a, display_row_1 
1598 cd cd 0b			call str_at_display 
159b			 
159b				; display debug step 
159b			 
159b			 
159b 11 71 ee			ld de, debug_mark 
159e 3e 26			ld a, display_row_1+display_cols-2 
15a0 cd cd 0b			call str_at_display 
15a3			 
15a3				; display a 
15a3 11 70 17			ld de, .ptrcliptr 
15a6 3e 28			ld a, display_row_2 
15a8 cd cd 0b			call str_at_display 
15ab			 
15ab f1				pop af 
15ac 2a 46 ea			ld hl,(cli_ptr) 
15af 3e 30			ld a, display_row_2+8 
15b1 cd 6d 15			call display_word_at 
15b4			 
15b4			 
15b4				; display hl 
15b4			 
15b4			 
15b4 11 78 17			ld de, .ptrclioptr 
15b7 3e 32			ld a, display_row_2+10 
15b9 cd cd 0b			call str_at_display 
15bc			; 
15bc			;	pop hl 
15bc 3e 35			ld a, display_row_2+13 
15be 2a 44 ea			ld hl,(cli_origptr) 
15c1 cd 6d 15			call display_word_at 
15c4			; 
15c4			;	 
15c4			;	; display de 
15c4			 
15c4			;	ld de, .regstatede 
15c4			;	ld a, display_row_3 
15c4			;	call str_at_display 
15c4			 
15c4			;	pop de 
15c4			;	ld h,d 
15c4			;	ld l, e 
15c4			;	ld a, display_row_3+3 
15c4			;	call display_word_at 
15c4			 
15c4			 
15c4				; display bc 
15c4			 
15c4			;	ld de, .regstatebc 
15c4			;	ld a, display_row_3+10 
15c4			;	call str_at_display 
15c4			 
15c4			;	pop bc 
15c4			;	ld h,b 
15c4			;	ld l, c 
15c4			;	ld a, display_row_3+13 
15c4			;	call display_word_at 
15c4			 
15c4			 
15c4				; display dsp 
15c4			 
15c4			;	ld de, .regstatedsp 
15c4			;	ld a, display_row_4 
15c4			;	call str_at_display 
15c4			 
15c4				 
15c4			;	ld hl,(cli_data_sp) 
15c4			;	ld a, display_row_4+4 
15c4			;	call display_word_at 
15c4			 
15c4				; display rsp 
15c4			 
15c4 11 a7 17			ld de, .regstatersp 
15c7 3e 82			ld a, display_row_4+10 
15c9 cd cd 0b			call str_at_display 
15cc			 
15cc				 
15cc 2a f8 e9			ld hl,(cli_ret_sp) 
15cf 3e 86			ld a, display_row_4+14 
15d1 cd 6d 15			call display_word_at 
15d4			 
15d4 cd dd 0b			call update_display 
15d7			 
15d7 cd f2 0a			call delay1s 
15da cd f2 0a			call delay1s 
15dd cd f2 0a			call delay1s 
15e0			 
15e0			 
15e0 cd d6 1b			call next_page_prompt 
15e3			 
15e3				; restore  
15e3			 
15e3 f1				pop af 
15e4 e1				pop hl 
15e5 c1				pop bc 
15e6 d1				pop de 
15e7 c9				ret 
15e8			 
15e8			break_point_state: 
15e8 f5				push af 
15e9			 
15e9				; see if disabled 
15e9			 
15e9 3a b8 e2			ld a, (os_view_disable) 
15ec fe 2a			cp '*' 
15ee 20 02			jr nz, .bpsgo 
15f0 f1				pop af 
15f1 c9				ret 
15f2			 
15f2			.bpsgo: 
15f2 f1				pop af 
15f3 f5				push af 
15f4 22 b4 e2			ld (os_view_hl), hl 
15f7 ed 53 b2 e2		ld (os_view_de), de 
15fb ed 43 b0 e2		ld (os_view_bc), bc 
15ff e5				push hl 
1600 6f				ld l, a 
1601 26 00			ld h, 0 
1603 22 b6 e2			ld (os_view_af),hl 
1606			 
1606 21 b7 ed				ld hl, display_fb0 
1609 22 d2 eb				ld (display_fb_active), hl 
160c e1				pop hl	 
160d			 
160d 3e 31			ld a, '1' 
160f fe 2a		.bps1:  cp '*' 
1611 20 03			jr nz, .bps1b 
1613 32 b8 e2			ld (os_view_disable),a 
1616 fe 31		.bps1b:  cp '1' 
1618 20 14			jr nz, .bps2 
161a			 
161a				; display reg 
161a			 
161a				 
161a			 
161a 3a b6 e2			ld a, (os_view_af) 
161d 2a b4 e2			ld hl, (os_view_hl) 
1620 ed 5b b2 e2		ld de, (os_view_de) 
1624 ed 4b b0 e2		ld bc, (os_view_bc) 
1628 cd c2 16			call display_reg_state 
162b c3 ae 16			jp .bpschk 
162e			 
162e fe 32		.bps2:  cp '2' 
1630 20 08			jr nz, .bps3 
1632				 
1632				; display hl 
1632 2a b4 e2			ld hl, (os_view_hl) 
1635 cd ac 17			call display_dump_at_hl 
1638			 
1638 18 74			jr .bpschk 
163a			 
163a fe 33		.bps3:  cp '3' 
163c 20 08			jr nz, .bps4 
163e			 
163e			        ; display de 
163e 2a b2 e2			ld hl, (os_view_de) 
1641 cd ac 17			call display_dump_at_hl 
1644			 
1644 18 68			jr .bpschk 
1646 fe 34		.bps4:  cp '4' 
1648 20 08			jr nz, .bps5 
164a			 
164a			        ; display bc 
164a 2a b0 e2			ld hl, (os_view_bc) 
164d cd ac 17			call display_dump_at_hl 
1650			 
1650 18 5c			jr .bpschk 
1652 fe 35		.bps5:  cp '5' 
1654 20 08		        jr nz, .bps7 
1656			 
1656				; display cur ptr 
1656 2a 46 ea			ld hl, (cli_ptr) 
1659 cd ac 17			call display_dump_at_hl 
165c			 
165c 18 50			jr .bpschk 
165e fe 36		.bps7:  cp '6' 
1660 20 08			jr nz, .bps8b 
1662				 
1662				; display cur orig ptr 
1662 2a 44 ea			ld hl, (cli_origptr) 
1665 cd ac 17			call display_dump_at_hl 
1668 18 44			jr .bpschk 
166a fe 37		.bps8b:  cp '7' 
166c 20 08			jr nz, .bps9 
166e				 
166e				; display dsp 
166e 2a f4 e9			ld hl, (cli_data_sp) 
1671 cd ac 17			call display_dump_at_hl 
1674			 
1674 18 38			jr .bpschk 
1676 fe 39		.bps9:  cp '9' 
1678 20 05			jr nz, .bps8c 
167a				 
167a				; display SP 
167a			;	ld hl, sp 
167a cd ac 17			call display_dump_at_hl 
167d			 
167d 18 2f			jr .bpschk 
167f fe 38		.bps8c:  cp '8' 
1681 20 08			jr nz, .bps8d 
1683				 
1683				; display rsp 
1683 2a f8 e9			ld hl, (cli_ret_sp) 
1686 cd ac 17			call display_dump_at_hl 
1689			 
1689 18 23			jr .bpschk 
168b fe 23		.bps8d:  cp '#'     ; access monitor sub system 
168d 20 05			jr nz, .bps8 
168f cd cc 19			call monitor 
1692			 
1692 18 1a			jr .bpschk 
1694 fe 30		.bps8:  cp '0' 
1696 20 16			jr nz, .bpschk 
1698			 
1698 21 16 ed				ld hl, display_fb1 
169b 22 d2 eb				ld (display_fb_active), hl 
169e cd dd 0b				call update_display 
16a1			 
16a1				;ld a, (os_view_af) 
16a1 2a b4 e2			ld hl, (os_view_hl) 
16a4 ed 5b b2 e2		ld de, (os_view_de) 
16a8 ed 4b b0 e2		ld bc, (os_view_bc) 
16ac f1				pop af 
16ad c9				ret 
16ae			 
16ae			.bpschk:   
16ae cd f2 0a			call delay1s 
16b1 3e 9f		ld a,display_row_4 + display_cols - 1 
16b3 11 d4 1b		        ld de, endprg 
16b6 cd cd 0b			call str_at_display 
16b9 cd dd 0b			call update_display 
16bc cd 97 64			call cin_wait 
16bf			 
16bf c3 0f 16			jp .bps1 
16c2			 
16c2			 
16c2			display_reg_state: 
16c2			 
16c2				; to restore afterwards 
16c2			 
16c2 d5				push de 
16c3 c5				push bc 
16c4 e5				push hl 
16c5 f5				push af 
16c6			 
16c6				; for use in here 
16c6			 
16c6 c5				push bc 
16c7 d5				push de 
16c8 e5				push hl 
16c9 f5				push af 
16ca			 
16ca cd ba 0b			call clear_display 
16cd			 
16cd 11 82 17			ld de, .regstate 
16d0 3e 00			ld a, display_row_1 
16d2 cd cd 0b			call str_at_display 
16d5			 
16d5				; display debug step 
16d5			 
16d5			 
16d5 11 71 ee			ld de, debug_mark 
16d8 3e 25			ld a, display_row_1+display_cols-3 
16da cd cd 0b			call str_at_display 
16dd			 
16dd				; display a 
16dd 11 9e 17			ld de, .regstatea 
16e0 3e 28			ld a, display_row_2 
16e2 cd cd 0b			call str_at_display 
16e5			 
16e5 e1				pop hl 
16e6			;	ld h,0 
16e6			;	ld l, a 
16e6 3e 2b			ld a, display_row_2+3 
16e8 cd 6d 15			call display_word_at 
16eb			 
16eb			 
16eb				; display hl 
16eb			 
16eb			 
16eb 11 92 17			ld de, .regstatehl 
16ee 3e 32			ld a, display_row_2+10 
16f0 cd cd 0b			call str_at_display 
16f3			 
16f3 e1				pop hl 
16f4 3e 35			ld a, display_row_2+13 
16f6 cd 6d 15			call display_word_at 
16f9			 
16f9				 
16f9				; display de 
16f9			 
16f9 11 96 17			ld de, .regstatede 
16fc 3e 50			ld a, display_row_3 
16fe cd cd 0b			call str_at_display 
1701			 
1701 e1				pop hl 
1702			;	ld h,d 
1702			;	ld l, e 
1702 3e 53			ld a, display_row_3+3 
1704 cd 6d 15			call display_word_at 
1707			 
1707			 
1707				; display bc 
1707			 
1707 11 9a 17			ld de, .regstatebc 
170a 3e 5a			ld a, display_row_3+10 
170c cd cd 0b			call str_at_display 
170f			 
170f e1				pop hl 
1710			;	ld h,b 
1710			;	ld l, c 
1710 3e 5d			ld a, display_row_3+13 
1712 cd 6d 15			call display_word_at 
1715			 
1715			 
1715				; display dsp 
1715			 
1715 11 a2 17			ld de, .regstatedsp 
1718 3e 78			ld a, display_row_4 
171a cd cd 0b			call str_at_display 
171d			 
171d				 
171d 2a f4 e9			ld hl,(cli_data_sp) 
1720 3e 7c			ld a, display_row_4+4 
1722 cd 6d 15			call display_word_at 
1725			 
1725				; display rsp 
1725			 
1725 11 a7 17			ld de, .regstatersp 
1728 3e 82			ld a, display_row_4+10 
172a cd cd 0b			call str_at_display 
172d			 
172d				 
172d 2a f8 e9			ld hl,(cli_ret_sp) 
1730 3e 86			ld a, display_row_4+14 
1732 cd 6d 15			call display_word_at 
1735			 
1735 cd dd 0b			call update_display 
1738			 
1738			;	call delay1s 
1738			;	call delay1s 
1738			;	call delay1s 
1738			 
1738			 
1738			;	call next_page_prompt 
1738			 
1738				; restore  
1738			 
1738 f1				pop af 
1739 e1				pop hl 
173a c1				pop bc 
173b d1				pop de 
173c c9				ret 
173d			 
173d .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1751 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1766 .. 00		.ptrstate:	db "Ptr State",0 
1770 .. 00		.ptrcliptr:     db "cli_ptr",0 
1778 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1782 .. 00		.regstate:	db "Reg State (1/0)",0 
1792 .. 00		.regstatehl:	db "HL:",0 
1796 .. 00		.regstatede:	db "DE:",0 
179a .. 00		.regstatebc:	db "BC:",0 
179e .. 00		.regstatea:	db "A :",0 
17a2 .. 00		.regstatedsp:	db "DSP:",0 
17a7 .. 00		.regstatersp:	db "RSP:",0 
17ac			 
17ac			display_dump_at_hl: 
17ac e5				push hl 
17ad d5				push de 
17ae c5				push bc 
17af f5				push af 
17b0			 
17b0 22 ea e5			ld (os_cur_ptr),hl	 
17b3 cd ba 0b			call clear_display 
17b6 cd de 1a			call dumpcont 
17b9			;	call delay1s 
17b9			;	call next_page_prompt 
17b9			 
17b9			 
17b9 f1				pop af 
17ba c1				pop bc 
17bb d1				pop de 
17bc e1				pop hl 
17bd c9				ret 
17be			 
17be			;if ENABLE_BASIC 
17be			;	include "nascombasic.asm" 
17be			;	basic: 
17be			;	include "forth/FORTH.ASM" 
17be			;endif 
17be			 
17be			; eof 
17be			 
17be			 
# End of file firmware_diags.asm
17be			  
17be			include "firmware_prompts.asm"  
17be			; Prompts  
17be			 
17be			; boot messages 
17be			 
17be .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17d3 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17e3			 
17e3			 
17e3			; config menus 
17e3			 
17e3 .. 00		prom_c3: db "Add Dictionary To File",0 
17fa			 
17fa			if STARTUP_V1 
17fa .. 00		prom_c2: db "Select Autoload File",0 
180f .. 00		prom_c2a: db "Disable Autoload File", 0 
1825			endif 
1825			 
1825			if STARTUP_V2 
1825			prom_c2: db "Enable Autoload Files",0 
1825			prom_c2a: db "Disable Autoload Files", 0 
1825			 
1825			crs_s1: db "*ls-word", 0 
1825			crs_s2: db "*ed-word", 0 
1825			crs_s3: db "*Demo-Programs", 0 
1825			crs_s4: db "*Utils", 0 
1825			crs_s5: db "*SPI-Addons", 0 
1825			crs_s6: db "*Key-constants", 0 
1825			 
1825			 
1825			 
1825			endif 
1825 .. 00		prom_c2b: db "Select Storage Bank",0 
1839 .. 00		prom_c4: db "Settings",0 
1842 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
185d .. 00		prom_m4b:   db "Monitor",0 
1865 .. 00		prom_c1: db "Hardware Diags",0 
1874			 
1874			 
1874			if STARTUP_V2 
1874			prom_c9: db "Create Startup Files",0 
1874			endif 
1874			 
1874 .. 00		prom_notav:    db "Feature not available",0 
188a .. 00		prom_empty:    db "",0 
188b			 
188b			; eof 
188b			 
# End of file firmware_prompts.asm
188b			  
188b			  
188b			; eof  
188b			  
# End of file firmware.asm
188b			 
188b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
188b			;if BASE_KEV  
188b			;baseram: equ 08000h 
188b			;endif 
188b			 
188b			;if BASE_SC114 
188b			;baseram:     equ    endofcode 
188b			;endif 
188b			 
188b			 
188b			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
188b			 
188b			; start system 
188b			 
188b			coldstart: 
188b				; set sp 
188b				; di/ei 
188b			 
188b f3				di 
188c 31 00 f0			ld sp, tos 
188f			;	ei 
188f			 
188f				; init spinner 
188f 3e 00			ld a,0 
1891 32 cc eb			ld (display_active), a 
1894			 
1894				; disable breakpoint by default 
1894			 
1894 3e 2a			ld a,'*' 
1896 32 b8 e2			ld (os_view_disable),a 
1899			 
1899				; init hardware 
1899			 
1899				; init keyboard and screen hardware 
1899			 
1899 cd 1c 01			call hardware_init 
189c			 
189c			 
189c cd f2 0a			call delay1s 
189f 3e 58			ld a, display_row_3+8 
18a1 11 03 01			ld de, buildtime 
18a4 cd cd 0b			call str_at_display 
18a7 cd dd 0b			call update_display 
18aa			 
18aa cd f2 0a			call delay1s 
18ad cd f2 0a			call delay1s 
18b0 cd f2 0a			call delay1s 
18b3			 
18b3				; detect if any keys are held down to enable breakpoints at start up 
18b3			 
18b3 cd 9f 64			call cin  
18b6 fe 00			cp 0 
18b8 28 03			jr z, .nokeys 
18ba			 
18ba				;call hardware_diags 
18ba cd 47 14			call config 
18bd			 
18bd			;	ld de, .bpen 
18bd			;	ld a, display_row_4 
18bd			;	call str_at_display 
18bd			;	call update_display 
18bd			; 
18bd			;	ld a,0 
18bd			;	ld (os_view_disable),a 
18bd			; 
18bd			;.bpwait: 
18bd			;	call cin 
18bd			;	cp 0 
18bd			;	jr z, .bpwait 
18bd			;	jr .nokeys 
18bd			; 
18bd			; 
18bd			;.bpen:  db "Break points enabled!",0 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			.nokeys: 
18bd			 
18bd			 
18bd				 
18bd			 
18bd			;jp  testkey 
18bd			 
18bd			;call storage_get_block_0 
18bd			; 
18bd			;ld hl, 0 
18bd			;ld de, store_page 
18bd			;call storage_read_block 
18bd			 
18bd				 
18bd			;ld hl, 10 
18bd			;ld de, store_page 
18bd			;call storage_read_block 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			 
18bd			;stop:	nop 
18bd			;	jp stop 
18bd			 
18bd			 
18bd			 
18bd			main: 
18bd cd ba 0b			call clear_display 
18c0 cd dd 0b			call update_display 
18c3			 
18c3			 
18c3			 
18c3			;	call testlcd 
18c3			 
18c3			 
18c3			 
18c3 cd db 1f			call forth_init 
18c6			 
18c6			 
18c6			warmstart: 
18c6 cd b1 1f			call forth_warmstart 
18c9			 
18c9				; run startup word load 
18c9			        ; TODO prevent this running at warmstart after crash  
18c9			 
18c9				if STARTUP_ENABLE 
18c9			 
18c9					if STARTUP_V1 
18c9			 
18c9						if STORAGE_SE 
18c9							call forth_autoload 
18c9						endif 
18c9 cd f8 62					call forth_startup 
18cc					endif 
18cc			 
18cc					if STARTUP_V2 
18cc			 
18cc						if STORAGE_SE 
18cc							call forth_autoload 
18cc						else 
18cc							call forth_startup 
18cc						endif 
18cc			 
18cc			 
18cc					endif 
18cc			 
18cc				endif 
18cc			 
18cc				; show free memory after boot 
18cc 11 66 19			ld de, freeram 
18cf 3e 00			ld a, display_row_1 
18d1 cd cd 0b			call str_at_display 
18d4			 
18d4			; Or use heap_size word???? 
18d4 21 ad e2			ld hl, heap_end 
18d7 11 c7 64			ld de, heap_start 
18da ed 52			sbc hl, de 
18dc e5				push hl 
18dd 7c				ld a,h	         	 
18de 21 cc e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18e1 cd e8 10			call hexout 
18e4 e1			   	pop hl 
18e5			 
18e5 7d				ld a,l 
18e6 21 ce e5			ld hl, os_word_scratch+2 
18e9 cd e8 10			call hexout 
18ec 21 d0 e5			ld hl, os_word_scratch+4 
18ef 3e 00			ld a, 0 
18f1 77				ld (hl),a 
18f2 11 cc e5			ld de, os_word_scratch 
18f5 3e 0d			ld a, display_row_1 + 13 
18f7 cd cd 0b			call str_at_display 
18fa cd dd 0b			call update_display 
18fd			 
18fd			 
18fd				;call demo 
18fd			 
18fd			 
18fd				; init scratch input area for cli commands 
18fd			 
18fd 21 ee e5			ld hl, os_cli_cmd 
1900 3e 00			ld a,0 
1902 77				ld (hl),a 
1903 23				inc hl 
1904 77				ld (hl),a 
1905			 
1905 3e 00			ld a,0 
1907 32 ed e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
190a			 
190a 32 ea e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
190d 32 eb e5			ld (os_cur_ptr+1),a	 
1910			 
1910 32 cc e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1913 32 cd e5			ld (os_word_scratch+1),a	 
1916				 
1916			 
1916				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1916 21 ee e5			ld hl, os_cli_cmd 
1919			 
1919 3e 00			ld a, 0		 ; init cli input 
191b 77				ld (hl), a 
191c 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
191e			cli: 
191e				; show cli prompt 
191e				;push af 
191e				;ld a, 0 
191e				;ld de, prompt 
191e				;call str_at_display 
191e			 
191e				;call update_display 
191e				;pop af 
191e				;inc a 
191e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
191e 0e 00			ld c, 0 
1920 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1922 1e 28			ld e, 40 
1924			 
1924 21 ee e5			ld hl, os_cli_cmd 
1927			 
1927				STACKFRAME OFF $fefe $9f9f 
1927				if DEBUG_STACK_IMB 
1927					if OFF 
1927						exx 
1927						ld de, $fefe 
1927						ld a, d 
1927						ld hl, curframe 
1927						call hexout 
1927						ld a, e 
1927						ld hl, curframe+2 
1927						call hexout 
1927						ld hl, $fefe 
1927						push hl 
1927						ld hl, $9f9f 
1927						push hl 
1927						exx 
1927					endif 
1927				endif 
1927			endm 
# End of macro STACKFRAME
1927			 
1927 cd 14 0e			call input_str 
192a			 
192a				STACKFRAMECHK OFF $fefe $9f9f 
192a				if DEBUG_STACK_IMB 
192a					if OFF 
192a						exx 
192a						ld hl, $9f9f 
192a						pop de   ; $9f9f 
192a						call cmp16 
192a						jr nz, .spnosame 
192a						ld hl, $fefe 
192a						pop de   ; $fefe 
192a						call cmp16 
192a						jr z, .spfrsame 
192a						.spnosame: call showsperror 
192a						.spfrsame: nop 
192a						exx 
192a					endif 
192a				endif 
192a			endm 
# End of macro STACKFRAMECHK
192a			 
192a				; copy input to last command 
192a			 
192a 21 ee e5			ld hl, os_cli_cmd 
192d 11 ed e6			ld de, os_last_cmd 
1930 01 ff 00			ld bc, 255 
1933 ed b0			ldir 
1935			 
1935				; wipe current buffer 
1935			 
1935			;	ld a, 0 
1935			;	ld hl, os_cli_cmd 
1935			;	ld de, os_cli_cmd+1 
1935			;	ld bc, 254 
1935			;	ldir 
1935				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1935			;	call strcpy 
1935			;	ld a, 0 
1935			;	ld (hl), a 
1935			;	inc hl 
1935			;	ld (hl), a 
1935			;	inc hl 
1935			;	ld (hl), a 
1935			 
1935				; switch frame buffer to program  
1935			 
1935 21 16 ed				ld hl, display_fb1 
1938 22 d2 eb				ld (display_fb_active), hl 
193b			 
193b			;	nop 
193b				STACKFRAME ON $fbfe $8f9f 
193b				if DEBUG_STACK_IMB 
193b					if ON 
193b						exx 
193b						ld de, $fbfe 
193b						ld a, d 
193b						ld hl, curframe 
193b						call hexout 
193b						ld a, e 
193b						ld hl, curframe+2 
193b						call hexout 
193b						ld hl, $fbfe 
193b						push hl 
193b						ld hl, $8f9f 
193b						push hl 
193b						exx 
193b					endif 
193b				endif 
193b			endm 
# End of macro STACKFRAME
193b				; first time into the parser so pass over the current scratch pad 
193b 21 ee e5			ld hl,os_cli_cmd 
193e				; tokenise the entered statement(s) in HL 
193e cd 59 20			call forthparse 
1941			        ; exec forth statements in top of return stack 
1941 cd 99 20			call forthexec 
1944				;call forthexec_cleanup 
1944			;	call parsenext 
1944			 
1944				STACKFRAMECHK ON $fbfe $8f9f 
1944				if DEBUG_STACK_IMB 
1944					if ON 
1944						exx 
1944						ld hl, $8f9f 
1944						pop de   ; $8f9f 
1944						call cmp16 
1944						jr nz, .spnosame 
1944						ld hl, $fbfe 
1944						pop de   ; $fbfe 
1944						call cmp16 
1944						jr z, .spfrsame 
1944						.spnosame: call showsperror 
1944						.spfrsame: nop 
1944						exx 
1944					endif 
1944				endif 
1944			endm 
# End of macro STACKFRAMECHK
1944				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1944			 
1944 3e 78			ld a, display_row_4 
1946 11 78 19			ld de, endprog 
1949			 
1949 cd dd 0b			call update_display		 
194c			 
194c cd d6 1b			call next_page_prompt 
194f			 
194f				; switch frame buffer to cli 
194f			 
194f 21 b7 ed				ld hl, display_fb0 
1952 22 d2 eb				ld (display_fb_active), hl 
1955			 
1955			 
1955 cd ba 0b		        call clear_display 
1958 cd dd 0b			call update_display		 
195b			 
195b 21 ee e5			ld hl, os_cli_cmd 
195e			 
195e 3e 00			ld a, 0		 ; init cli input 
1960 77				ld (hl), a 
1961			 
1961				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1961			 
1961				; now on last line 
1961			 
1961				; TODO scroll screen up 
1961			 
1961				; TODO instead just clear screen and place at top of screen 
1961			 
1961			;	ld a, 0 
1961			;	ld (f_cursor_ptr),a 
1961			 
1961				;call clear_display 
1961				;call update_display 
1961			 
1961				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1961 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1963 c3 1e 19			jp cli 
1966			 
1966 .. 00		freeram: db "Free bytes: $",0 
1974 ..			asc: db "1A2F" 
1978 .. 00		endprog: db "End prog...",0 
1984			 
1984			testenter2:   
1984 21 f9 e2			ld hl,scratch+50 
1987 22 ea e5			ld (os_cur_ptr),hl 
198a c3 1e 19			jp cli 
198d			 
198d			testenter:  
198d			 
198d 21 74 19			ld hl,asc 
1990			;	ld a,(hl) 
1990			;	call nibble2val 
1990 cd 3e 11			call get_byte 
1993			 
1993			 
1993			;	ld a,(hl) 
1993			;	call atohex 
1993			 
1993			;	call fourehexhl 
1993 32 f9 e2			ld (scratch+50),a 
1996			 
1996			 
1996			 
1996 21 76 19			ld hl,asc+2 
1999			;	ld a, (hl) 
1999			;	call nibble2val 
1999 cd 3e 11			call get_byte 
199c			 
199c			;	call fourehexhl 
199c 32 fb e2			ld (scratch+52),a 
199f				 
199f 21 f9 e2			ld hl,scratch+50 
19a2 22 ea e5			ld (os_cur_ptr),hl 
19a5 c3 1e 19			jp cli 
19a8			 
19a8			enter:	 
19a8 3a cb e2			ld a,(scratch+4) 
19ab fe 00			cp 0 
19ad 28 0c			jr z, .entercont 
19af				; no, not a null term line so has an address to work out.... 
19af			 
19af 21 c9 e2			ld hl,scratch+2 
19b2 cd 9e 11			call get_word_hl 
19b5			 
19b5 22 ea e5			ld (os_cur_ptr),hl	 
19b8 c3 1e 19			jp cli 
19bb			 
19bb			 
19bb			.entercont:  
19bb			 
19bb 21 c9 e2			ld hl, scratch+2 
19be cd 3e 11			call get_byte 
19c1			 
19c1 2a ea e5		   	ld hl,(os_cur_ptr) 
19c4 77					ld (hl),a 
19c5 23					inc hl 
19c6 22 ea e5				ld (os_cur_ptr),hl 
19c9				 
19c9			; get byte  
19c9			 
19c9			 
19c9 c3 1e 19			jp cli 
19cc			 
19cc			 
19cc			; basic monitor support 
19cc			 
19cc			monitor: 
19cc				;  
19cc cd ba 0b			call clear_display 
19cf 3e 00			ld a, 0 
19d1 11 19 1a			ld de, .monprompt 
19d4 cd cd 0b			call str_at_display 
19d7 cd dd 0b			call update_display 
19da			 
19da				; get a monitor command 
19da			 
19da 0e 00			ld c, 0     ; entry at top left 
19dc 16 64			ld d, 100   ; max buffer size 
19de 1e 0f			ld e, 15    ; input scroll area 
19e0 3e 00			ld a, 0     ; init string 
19e2 21 c5 e4			ld hl, os_input 
19e5 77				ld (hl), a 
19e6 23				inc hl 
19e7 77				ld (hl), a 
19e8 21 c5 e4			ld hl, os_input 
19eb 3e 01			ld a, 1     ; init string 
19ed cd 14 0e			call input_str 
19f0			 
19f0 cd ba 0b		        call clear_display 
19f3 cd dd 0b			call update_display		 
19f6			 
19f6 3a c5 e4			ld a, (os_input) 
19f9 cd 3c 12			call toUpper 
19fc fe 48		        cp 'H' 
19fe 28 6f		        jr z, .monhelp 
1a00 fe 44			cp 'D'		; dump 
1a02 ca 90 1a			jp z, .mondump	 
1a05 fe 43			cp 'C'		; dump 
1a07 ca aa 1a			jp z, .moncdump	 
1a0a fe 4d			cp 'M'		; dump 
1a0c ca 1b 1a			jp z, .moneditstart 
1a0f fe 55			cp 'U'		; dump 
1a11 28 14			jr z, .monedit	 
1a13 fe 51			cp 'Q'		; dump 
1a15 c8				ret z	 
1a16			 
1a16			 
1a16				; TODO "S" to access symbol by name and not need the address 
1a16				; TODO "F" to find a string in memory 
1a16			 
1a16 c3 cc 19			jp monitor 
1a19			 
1a19 .. 00		.monprompt: db ">", 0 
1a1b			 
1a1b			.moneditstart: 
1a1b				; get starting address 
1a1b			 
1a1b 21 c7 e4			ld hl,os_input+2 
1a1e cd 9e 11			call get_word_hl 
1a21			 
1a21 22 ea e5			ld (os_cur_ptr),hl	 
1a24			 
1a24 c3 cc 19			jp monitor 
1a27			 
1a27			.monedit: 
1a27				; get byte to load 
1a27			 
1a27 21 c7 e4			ld hl,os_input+2 
1a2a cd 3e 11			call get_byte 
1a2d			 
1a2d				; get address to update 
1a2d 2a ea e5			ld hl, (os_cur_ptr) 
1a30			 
1a30				; update byte 
1a30			 
1a30 77				ld (hl), a 
1a31			 
1a31				; move to next address and save it 
1a31			 
1a31 23				inc hl 
1a32 22 ea e5			ld (os_cur_ptr),hl	 
1a35			 
1a35 c3 cc 19			jp monitor 
1a38			 
1a38			 
1a38 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a4c .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a68 .. 00		.monhelptext3:  db "Q-Quit",0 
1a6f			        
1a6f			.monhelp: 
1a6f 3e 00			ld a, display_row_1 
1a71 11 38 1a		        ld de, .monhelptext1 
1a74			 
1a74 cd cd 0b			call str_at_display 
1a77 3e 28			ld a, display_row_2 
1a79 11 4c 1a		        ld de, .monhelptext2 
1a7c					 
1a7c cd cd 0b			call str_at_display 
1a7f 3e 50			ld a, display_row_3 
1a81 11 68 1a		        ld de, .monhelptext3 
1a84					 
1a84 cd cd 0b			call str_at_display 
1a87 cd dd 0b			call update_display		 
1a8a			 
1a8a cd d6 1b			call next_page_prompt 
1a8d c3 cc 19			jp monitor 
1a90			 
1a90			.mondump:    
1a90 21 c7 e4			ld hl,os_input+2 
1a93 cd 9e 11			call get_word_hl 
1a96			 
1a96 22 ea e5			ld (os_cur_ptr),hl	 
1a99 cd de 1a			call dumpcont 
1a9c 3e 78			ld a, display_row_4 
1a9e 11 78 19			ld de, endprog 
1aa1			 
1aa1 cd dd 0b			call update_display		 
1aa4			 
1aa4 cd d6 1b			call next_page_prompt 
1aa7 c3 cc 19			jp monitor 
1aaa			.moncdump: 
1aaa cd de 1a			call dumpcont 
1aad 3e 78			ld a, display_row_4 
1aaf 11 78 19			ld de, endprog 
1ab2			 
1ab2 cd dd 0b			call update_display		 
1ab5			 
1ab5 cd d6 1b			call next_page_prompt 
1ab8 c3 cc 19			jp monitor 
1abb			 
1abb			 
1abb			; TODO symbol access  
1abb			 
1abb			.symbols:     ;; A list of symbols that can be called up  
1abb b7 ed			dw display_fb0 
1abd .. 00			db "fb0",0  
1ac1 80 ea		     	dw store_page 
1ac3 .. 00			db "store_page",0 
1ace			 
1ace			 
1ace			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ace			 
1ace 3a c8 e2			ld a,(scratch+1) 
1ad1 fe 00			cp 0 
1ad3 28 09			jr z, dumpcont 
1ad5			 
1ad5				; no, not a null term line so has an address to work out.... 
1ad5			 
1ad5 21 c9 e2			ld hl,scratch+2 
1ad8 cd 9e 11			call get_word_hl 
1adb			 
1adb 22 ea e5			ld (os_cur_ptr),hl	 
1ade			 
1ade			 
1ade			 
1ade			dumpcont: 
1ade			 
1ade				; dump bytes at ptr 
1ade			 
1ade			 
1ade 3e 00			ld a, display_row_1 
1ae0 2a d2 eb			ld hl, (display_fb_active) 
1ae3 cd e7 0d			call addatohl 
1ae6 cd 0e 1b			call .dumpbyterow 
1ae9			 
1ae9 3e 28			ld a, display_row_2 
1aeb 2a d2 eb			ld hl, (display_fb_active) 
1aee cd e7 0d			call addatohl 
1af1 cd 0e 1b			call .dumpbyterow 
1af4			 
1af4			 
1af4 3e 50			ld a, display_row_3 
1af6 2a d2 eb			ld hl, (display_fb_active) 
1af9 cd e7 0d			call addatohl 
1afc cd 0e 1b			call .dumpbyterow 
1aff			 
1aff 3e 78			ld a, display_row_4 
1b01 2a d2 eb			ld hl, (display_fb_active) 
1b04 cd e7 0d			call addatohl 
1b07 cd 0e 1b			call .dumpbyterow 
1b0a			 
1b0a cd dd 0b			call update_display 
1b0d			;		jp cli 
1b0d c9				ret 
1b0e			 
1b0e			.dumpbyterow: 
1b0e			 
1b0e				;push af 
1b0e			 
1b0e e5				push hl 
1b0f			 
1b0f				; calc where to poke the ascii 
1b0f			if display_cols == 20 
1b0f				ld a, 16 
1b0f			else 
1b0f 3e 1f			ld a, 31 
1b11			endif 
1b11			 
1b11 cd e7 0d			call addatohl 
1b14 22 cc e5			ld (os_word_scratch),hl  		; save pos for later 
1b17			 
1b17			 
1b17			; display decoding address 
1b17 2a ea e5		   	ld hl,(os_cur_ptr) 
1b1a			 
1b1a 7c				ld a,h 
1b1b e1				pop hl 
1b1c e5				push hl 
1b1d			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b1d cd e8 10			call hexout 
1b20 2a ea e5		   	ld hl,(os_cur_ptr) 
1b23			 
1b23 7d				ld a,l 
1b24 e1				pop hl 
1b25 23				inc hl 
1b26 23				inc hl 
1b27 e5				push hl 
1b28			;	ld hl, os_word_scratch+2 
1b28 cd e8 10			call hexout 
1b2b e1				pop hl 
1b2c 23				inc hl 
1b2d 23				inc hl 
1b2e				;ld hl, os_word_scratch+4 
1b2e 3e 3a			ld a, ':' 
1b30 77				ld (hl),a 
1b31 23				inc hl 
1b32				;ld a, 0 
1b32				;ld (hl),a 
1b32				;ld de, os_word_scratch 
1b32				;pop af 
1b32				;push af 
1b32			;		ld a, display_row_2 
1b32			;		call str_at_display 
1b32			;		call update_display 
1b32			 
1b32			 
1b32			;pop af 
1b32			;	add 5 
1b32			 
1b32			if display_cols == 20 
1b32				ld b, 4 
1b32			else 
1b32 06 08			ld b, 8 
1b34			endif	 
1b34			 
1b34			.dumpbyte: 
1b34 c5				push bc 
1b35 e5				push hl 
1b36			 
1b36			 
1b36 2a ea e5		   	ld hl,(os_cur_ptr) 
1b39 7e					ld a,(hl) 
1b3a			 
1b3a					; poke the ascii to display 
1b3a 2a cc e5				ld hl,(os_word_scratch) 
1b3d 77					ld (hl),a 
1b3e 23					inc hl 
1b3f 22 cc e5				ld (os_word_scratch),hl 
1b42			 
1b42					 
1b42			 
1b42			 
1b42 e1					pop hl 
1b43 e5					push hl 
1b44			 
1b44 cd e8 10				call hexout 
1b47			 
1b47					 
1b47 2a ea e5		   	ld hl,(os_cur_ptr) 
1b4a 23				inc hl 
1b4b 22 ea e5		   	ld (os_cur_ptr),hl 
1b4e			 
1b4e e1					pop hl 
1b4f 23					inc hl 
1b50 23					inc hl 
1b51 23					inc hl 
1b52			 
1b52			 
1b52			 
1b52					;ld a,0 
1b52					;ld (os_word_scratch+2),a 
1b52					;pop af 
1b52					;push af 
1b52			 
1b52					;ld de, os_word_scratch 
1b52					;call str_at_display 
1b52			;		call update_display 
1b52			;		pop af 
1b52 c1					pop bc 
1b53 c6 03				add 3 
1b55 10 dd			djnz .dumpbyte 
1b57			 
1b57				 
1b57			 
1b57 c9				ret 
1b58			 
1b58			jump:	 
1b58			 
1b58 21 c9 e2			ld hl,scratch+2 
1b5b cd 9e 11			call get_word_hl 
1b5e				;ld hl,(scratch+2) 
1b5e				;call fourehexhl 
1b5e			 
1b5e 22 ea e5			ld (os_cur_ptr),hl	 
1b61			 
1b61 e9				jp (hl) 
1b62			 
1b62			 
1b62			 
1b62			; TODO implement a basic monitor mode to start with 
1b62			 
1b62			 
1b62			 
1b62			 
1b62			 
1b62			 
1b62			 
1b62			 
1b62			 
1b62			; testing and demo code during development 
1b62			 
1b62			 
1b62 .. 00		str1: db "Enter some text...",0 
1b75 .. 00		clear: db "                    ",0 
1b8a			 
1b8a			demo: 
1b8a			 
1b8a			 
1b8a			 
1b8a			;	call update_display 
1b8a			 
1b8a				; init scratch input area for testing 
1b8a 21 c7 e2			ld hl, scratch	 
1b8d 3e 00			ld a,0 
1b8f 77				ld (hl),a 
1b90			 
1b90			 
1b90 3e 28		            LD   A, display_row_2 
1b92			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b92 11 62 1b		            LD   DE, str1 
1b95 cd cd 0b			call str_at_display 
1b98			 
1b98			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b98			cloop:	 
1b98 3e 50		            LD   A, display_row_3 
1b9a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b9a 11 75 1b		            LD   DE, clear 
1b9d			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b9d cd cd 0b				call str_at_display 
1ba0 3e 78			ld a, display_row_4 
1ba2 11 d2 1b			ld de, prompt 
1ba5			 
1ba5 cd cd 0b				call str_at_display 
1ba8 cd dd 0b			call update_display 
1bab			 
1bab 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bad 16 0a			ld d, 10 
1baf 21 c7 e2			ld hl, scratch	 
1bb2 cd 14 0e			call input_str 
1bb5			 
1bb5			;	call clear_display 
1bb5			;'	call update_display 
1bb5			 
1bb5 3e 00		            LD   A, display_row_1 
1bb7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb7 11 75 1b		            LD   DE, clear 
1bba cd cd 0b				call str_at_display 
1bbd			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bbd 3e 00		            LD   A, display_row_1 
1bbf			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bbf 11 c7 e2		            LD   DE, scratch 
1bc2			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bc2 cd cd 0b				call str_at_display 
1bc5 cd dd 0b			call update_display 
1bc8			 
1bc8 3e 00				ld a,0 
1bca 21 c7 e2			ld hl, scratch 
1bcd 77				ld (hl),a 
1bce			 
1bce 00				nop 
1bcf c3 98 1b			jp cloop 
1bd2			 
1bd2			 
1bd2			 
1bd2			; OS Prompt 
1bd2			 
1bd2 .. 00		prompt: db ">",0 
1bd4 .. 00		endprg: db "?",0 
1bd6			 
1bd6			 
1bd6			; handy next page prompt 
1bd6			next_page_prompt: 
1bd6 e5				push hl 
1bd7 d5				push de 
1bd8 f5				push af 
1bd9 c5				push bc 
1bda			 
1bda 3e 9f			ld a,display_row_4 + display_cols - 1 
1bdc 11 d4 1b		        ld de, endprg 
1bdf cd cd 0b			call str_at_display 
1be2 cd dd 0b			call update_display 
1be5 cd 97 64			call cin_wait 
1be8 c1				pop bc 
1be9 f1				pop af 
1bea d1				pop de 
1beb e1				pop hl 
1bec			 
1bec			 
1bec c9				ret 
1bed			 
1bed			 
1bed			; forth parser 
1bed			 
1bed			; My forth kernel 
1bed			include "forth_kernel.asm" 
1bed			; 
1bed			; kernel to the forth OS 
1bed			 
1bed			DS_TYPE_STR: equ 1     ; string type 
1bed			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bed			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bed			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bed			 
1bed			FORTH_PARSEV1: equ 0 
1bed			FORTH_PARSEV2: equ 0 
1bed			FORTH_PARSEV3: equ 0 
1bed			FORTH_PARSEV4: equ 0 
1bed			FORTH_PARSEV5: equ 1 
1bed			 
1bed			;if FORTH_PARSEV5 
1bed			;	FORTH_END_BUFFER: equ 0 
1bed			;else 
1bed			FORTH_END_BUFFER: equ 127 
1bed			;endif 
1bed			 
1bed			FORTH_TRUE: equ 1 
1bed			FORTH_FALSE: equ 0 
1bed			 
1bed			if FORTH_PARSEV4 
1bed			include "forth_stackops.asm" 
1bed			endif 
1bed			 
1bed			if FORTH_PARSEV5 
1bed			include "forth_stackopsv5.asm" 
1bed			 
1bed			; Stack operations for v5 parser on wards 
1bed			; * DATA stack 
1bed			; * LOOP stack 
1bed			; * RETURN stack 
1bed			 
1bed			 
1bed			 
1bed			FORTH_CHK_DSP_UNDER: macro 
1bed				push hl 
1bed				push de 
1bed				ld hl,(cli_data_sp) 
1bed				ld de, cli_data_stack 
1bed				call cmp16 
1bed				jp c, fault_dsp_under 
1bed				pop de 
1bed				pop hl 
1bed				endm 
1bed			 
1bed			 
1bed			FORTH_CHK_RSP_UNDER: macro 
1bed				push hl 
1bed				push de 
1bed				ld hl,(cli_ret_sp) 
1bed				ld de, cli_ret_stack 
1bed				call cmp16 
1bed				jp c, fault_rsp_under 
1bed				pop de 
1bed				pop hl 
1bed				endm 
1bed			 
1bed			FORTH_CHK_LOOP_UNDER: macro 
1bed				push hl 
1bed				push de 
1bed				ld hl,(cli_loop_sp) 
1bed				ld de, cli_loop_stack 
1bed				call cmp16 
1bed				jp c, fault_loop_under 
1bed				pop de 
1bed				pop hl 
1bed				endm 
1bed			 
1bed			FORTH_ERR_TOS_NOTSTR: macro 
1bed				; TOSO might need more for checks when used 
1bed				push af 
1bed				ld a,(hl) 
1bed				cp DS_TYPE_STR 
1bed				jp nz, type_faultn   
1bed				pop af 
1bed				endm 
1bed			 
1bed			FORTH_ERR_TOS_NOTNUM: macro 
1bed				push af 
1bed				ld a,(hl) 
1bed				cp DS_TYPE_INUM 
1bed				jp nz, type_faultn   
1bed				pop af 
1bed				endm 
1bed			 
1bed			 
1bed			; increase data stack pointer and save hl to it 
1bed				 
1bed			FORTH_DSP_NEXT: macro 
1bed				call macro_forth_dsp_next 
1bed				endm 
1bed			 
1bed			 
1bed			macro_forth_dsp_next: 
1bed				if DEBUG_FORTH_STACK_GUARD 
1bed cd d9 60				call check_stacks 
1bf0				endif 
1bf0 e5				push hl 
1bf1 d5				push de 
1bf2 eb				ex de,hl 
1bf3 2a f4 e9			ld hl,(cli_data_sp) 
1bf6 23				inc hl 
1bf7 23				inc hl 
1bf8			 
1bf8			; PARSEV5 
1bf8 23				inc hl 
1bf9 22 f4 e9			ld (cli_data_sp),hl 
1bfc 73				ld (hl), e 
1bfd 23				inc hl 
1bfe 72				ld (hl), d 
1bff d1				pop de 
1c00 e1				pop hl 
1c01				if DEBUG_FORTH_STACK_GUARD 
1c01 cd d9 60				call check_stacks 
1c04				endif 
1c04 c9				ret 
1c05			 
1c05			 
1c05			; increase ret stack pointer and save hl to it 
1c05				 
1c05			FORTH_RSP_NEXT: macro 
1c05				call macro_forth_rsp_next 
1c05				endm 
1c05			 
1c05			macro_forth_rsp_next: 
1c05				if DEBUG_FORTH_STACK_GUARD 
1c05 cd d9 60				call check_stacks 
1c08				endif 
1c08 e5				push hl 
1c09 d5				push de 
1c0a eb				ex de,hl 
1c0b 2a f8 e9			ld hl,(cli_ret_sp) 
1c0e 23				inc hl 
1c0f 23				inc hl 
1c10 22 f8 e9			ld (cli_ret_sp),hl 
1c13 73				ld (hl), e 
1c14 23				inc hl 
1c15 72				ld (hl), d 
1c16 d1				pop de 
1c17 e1				pop hl 
1c18				if DEBUG_FORTH_STACK_GUARD 
1c18 cd d9 60				call check_stacks 
1c1b				endif 
1c1b c9				ret 
1c1c			 
1c1c			; get current ret stack pointer and save to hl  
1c1c				 
1c1c			FORTH_RSP_TOS: macro 
1c1c				call macro_forth_rsp_tos 
1c1c				endm 
1c1c			 
1c1c			macro_forth_rsp_tos: 
1c1c				;push de 
1c1c 2a f8 e9			ld hl,(cli_ret_sp) 
1c1f cd 57 1c			call loadhlptrtohl 
1c22				;ld e, (hl) 
1c22				;inc hl 
1c22				;ld d, (hl) 
1c22				;ex de, hl 
1c22					if DEBUG_FORTH_WORDS 
1c22			;			DMARK "RST" 
1c22						CALLMONITOR 
1c22 cd e8 15			call break_point_state  
1c25				endm  
# End of macro CALLMONITOR
1c25					endif 
1c25				;pop de 
1c25 c9				ret 
1c26			 
1c26			; pop ret stack pointer 
1c26				 
1c26			FORTH_RSP_POP: macro 
1c26				call macro_forth_rsp_pop 
1c26				endm 
1c26			 
1c26			 
1c26			macro_forth_rsp_pop: 
1c26				if DEBUG_FORTH_STACK_GUARD 
1c26			;		DMARK "RPP" 
1c26 cd d9 60				call check_stacks 
1c29					FORTH_CHK_RSP_UNDER 
1c29 e5				push hl 
1c2a d5				push de 
1c2b 2a f8 e9			ld hl,(cli_ret_sp) 
1c2e 11 b2 e9			ld de, cli_ret_stack 
1c31 cd 05 0e			call cmp16 
1c34 da ed 61			jp c, fault_rsp_under 
1c37 d1				pop de 
1c38 e1				pop hl 
1c39				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c39				endif 
1c39 e5				push hl 
1c3a 2a f8 e9			ld hl,(cli_ret_sp) 
1c3d			 
1c3d			 
1c3d				if FORTH_ENABLE_FREE 
1c3d			 
1c3d					; get pointer 
1c3d			 
1c3d					push de 
1c3d					push hl 
1c3d			 
1c3d					ld e, (hl) 
1c3d					inc hl 
1c3d					ld d, (hl) 
1c3d			 
1c3d					ex de, hl 
1c3d					call free 
1c3d			 
1c3d					pop hl 
1c3d					pop de 
1c3d			 
1c3d			 
1c3d				endif 
1c3d			 
1c3d			 
1c3d 2b				dec hl 
1c3e 2b				dec hl 
1c3f 22 f8 e9			ld (cli_ret_sp), hl 
1c42				; do stack underflow checks 
1c42 e1				pop hl 
1c43				if DEBUG_FORTH_STACK_GUARD 
1c43 cd d9 60				call check_stacks 
1c46					FORTH_CHK_RSP_UNDER 
1c46 e5				push hl 
1c47 d5				push de 
1c48 2a f8 e9			ld hl,(cli_ret_sp) 
1c4b 11 b2 e9			ld de, cli_ret_stack 
1c4e cd 05 0e			call cmp16 
1c51 da ed 61			jp c, fault_rsp_under 
1c54 d1				pop de 
1c55 e1				pop hl 
1c56				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c56				endif 
1c56 c9				ret 
1c57			 
1c57			 
1c57			 
1c57			; routine to load word pointed to by hl into hl 
1c57			 
1c57			loadhlptrtohl: 
1c57			 
1c57 d5				push de 
1c58 5e				ld e, (hl) 
1c59 23				inc hl 
1c5a 56				ld d, (hl) 
1c5b eb				ex de, hl 
1c5c d1				pop de 
1c5d			 
1c5d c9				ret 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			; push a number held in HL onto the data stack 
1c5e			; entry point for pushing a value when already in hl used in function above 
1c5e			 
1c5e			forth_push_numhl: 
1c5e			 
1c5e e5				push hl    ; save value to push 
1c5f			 
1c5f			if DEBUG_FORTH_PUSH 
1c5f				; see if disabled 
1c5f			 
1c5f			 
1c5f f5				push af 
1c60 3a b8 e2			ld a, (os_view_disable) 
1c63 fe 2a			cp '*' 
1c65 28 34			jr z, .pskip2 
1c67 e5				push hl 
1c68 e5			push hl 
1c69 cd ba 0b			call clear_display 
1c6c e1			pop hl 
1c6d 7c				ld a,h 
1c6e 21 cc e5			ld hl, os_word_scratch 
1c71 cd e8 10			call hexout 
1c74 e1				pop hl 
1c75 7d				ld a,l 
1c76 21 ce e5			ld hl, os_word_scratch+2 
1c79 cd e8 10			call hexout 
1c7c			 
1c7c 21 d0 e5			ld hl, os_word_scratch+4 
1c7f 3e 00			ld a,0 
1c81 77				ld (hl),a 
1c82 11 cc e5			ld de,os_word_scratch 
1c85 3e 28				ld a, display_row_2 
1c87 cd cd 0b				call str_at_display 
1c8a 11 be 4c			ld de, .push_num 
1c8d 3e 00			ld a, display_row_1 
1c8f			 
1c8f cd cd 0b				call str_at_display 
1c92			 
1c92			 
1c92 cd dd 0b			call update_display 
1c95 cd f2 0a			call delay1s 
1c98 cd f2 0a			call delay1s 
1c9b			.pskip2:  
1c9b			 
1c9b f1				pop af 
1c9c			endif	 
1c9c			 
1c9c			 
1c9c				FORTH_DSP_NEXT 
1c9c cd ed 1b			call macro_forth_dsp_next 
1c9f				endm 
# End of macro FORTH_DSP_NEXT
1c9f			 
1c9f 2a f4 e9			ld hl, (cli_data_sp) 
1ca2			 
1ca2				; save item type 
1ca2 3e 02			ld a,  DS_TYPE_INUM 
1ca4 77				ld (hl), a 
1ca5 23				inc hl 
1ca6			 
1ca6				; get word off stack 
1ca6 d1				pop de 
1ca7 7b				ld a,e 
1ca8 77				ld (hl), a 
1ca9 23				inc hl 
1caa 7a				ld a,d 
1cab 77				ld (hl), a 
1cac			 
1cac			if DEBUG_FORTH_PUSH 
1cac 2b				dec hl 
1cad 2b				dec hl 
1cae 2b				dec hl 
1caf						DMARK "PH5" 
1caf f5				push af  
1cb0 3a c4 1c			ld a, (.dmark)  
1cb3 32 71 ee			ld (debug_mark),a  
1cb6 3a c5 1c			ld a, (.dmark+1)  
1cb9 32 72 ee			ld (debug_mark+1),a  
1cbc 3a c6 1c			ld a, (.dmark+2)  
1cbf 32 73 ee			ld (debug_mark+2),a  
1cc2 18 03			jr .pastdmark  
1cc4 ..			.dmark: db "PH5"  
1cc7 f1			.pastdmark: pop af  
1cc8			endm  
# End of macro DMARK
1cc8				CALLMONITOR 
1cc8 cd e8 15			call break_point_state  
1ccb				endm  
# End of macro CALLMONITOR
1ccb			endif	 
1ccb			 
1ccb c9				ret 
1ccc			 
1ccc			 
1ccc			; Push a string to stack pointed to by hl 
1ccc			 
1ccc			forth_push_str: 
1ccc			 
1ccc			if DEBUG_FORTH_PUSH 
1ccc						DMARK "PSQ" 
1ccc f5				push af  
1ccd 3a e1 1c			ld a, (.dmark)  
1cd0 32 71 ee			ld (debug_mark),a  
1cd3 3a e2 1c			ld a, (.dmark+1)  
1cd6 32 72 ee			ld (debug_mark+1),a  
1cd9 3a e3 1c			ld a, (.dmark+2)  
1cdc 32 73 ee			ld (debug_mark+2),a  
1cdf 18 03			jr .pastdmark  
1ce1 ..			.dmark: db "PSQ"  
1ce4 f1			.pastdmark: pop af  
1ce5			endm  
# End of macro DMARK
1ce5				CALLMONITOR 
1ce5 cd e8 15			call break_point_state  
1ce8				endm  
# End of macro CALLMONITOR
1ce8			endif	 
1ce8			    
1ce8 e5				push hl 
1ce9 e5				push hl 
1cea			 
1cea			;	ld a, 0   ; find end of string 
1cea cd 45 12			call strlenz 
1ced			if DEBUG_FORTH_PUSH 
1ced						DMARK "PQ2" 
1ced f5				push af  
1cee 3a 02 1d			ld a, (.dmark)  
1cf1 32 71 ee			ld (debug_mark),a  
1cf4 3a 03 1d			ld a, (.dmark+1)  
1cf7 32 72 ee			ld (debug_mark+1),a  
1cfa 3a 04 1d			ld a, (.dmark+2)  
1cfd 32 73 ee			ld (debug_mark+2),a  
1d00 18 03			jr .pastdmark  
1d02 ..			.dmark: db "PQ2"  
1d05 f1			.pastdmark: pop af  
1d06			endm  
# End of macro DMARK
1d06				CALLMONITOR 
1d06 cd e8 15			call break_point_state  
1d09				endm  
# End of macro CALLMONITOR
1d09			endif	 
1d09 eb				ex de, hl 
1d0a e1				pop hl   ; get ptr to start of string 
1d0b			if DEBUG_FORTH_PUSH 
1d0b						DMARK "PQ3" 
1d0b f5				push af  
1d0c 3a 20 1d			ld a, (.dmark)  
1d0f 32 71 ee			ld (debug_mark),a  
1d12 3a 21 1d			ld a, (.dmark+1)  
1d15 32 72 ee			ld (debug_mark+1),a  
1d18 3a 22 1d			ld a, (.dmark+2)  
1d1b 32 73 ee			ld (debug_mark+2),a  
1d1e 18 03			jr .pastdmark  
1d20 ..			.dmark: db "PQ3"  
1d23 f1			.pastdmark: pop af  
1d24			endm  
# End of macro DMARK
1d24				CALLMONITOR 
1d24 cd e8 15			call break_point_state  
1d27				endm  
# End of macro CALLMONITOR
1d27			endif	 
1d27 19				add hl,de 
1d28			if DEBUG_FORTH_PUSH 
1d28						DMARK "PQE" 
1d28 f5				push af  
1d29 3a 3d 1d			ld a, (.dmark)  
1d2c 32 71 ee			ld (debug_mark),a  
1d2f 3a 3e 1d			ld a, (.dmark+1)  
1d32 32 72 ee			ld (debug_mark+1),a  
1d35 3a 3f 1d			ld a, (.dmark+2)  
1d38 32 73 ee			ld (debug_mark+2),a  
1d3b 18 03			jr .pastdmark  
1d3d ..			.dmark: db "PQE"  
1d40 f1			.pastdmark: pop af  
1d41			endm  
# End of macro DMARK
1d41				CALLMONITOR 
1d41 cd e8 15			call break_point_state  
1d44				endm  
# End of macro CALLMONITOR
1d44			endif	 
1d44			 
1d44 2b				dec hl    ; see if there is an optional trailing double quote 
1d45 7e				ld a,(hl) 
1d46 fe 22			cp '"' 
1d48 20 03			jr nz, .strnoq 
1d4a 3e 00			ld a, 0      ; get rid of double quote 
1d4c 77				ld (hl), a 
1d4d 23			.strnoq: inc hl 
1d4e			 
1d4e 3e 00			ld a, 0 
1d50 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d51			 
1d51 13				inc de ; add one for the type string 
1d52 13				inc de ; add one for null term??? 
1d53			 
1d53				; tos is get string pointer again 
1d53				; de contains space to allocate 
1d53				 
1d53 d5				push de 
1d54			 
1d54 eb				ex de, hl 
1d55			 
1d55				;push af 
1d55			 
1d55			if DEBUG_FORTH_PUSH 
1d55						DMARK "PHm" 
1d55 f5				push af  
1d56 3a 6a 1d			ld a, (.dmark)  
1d59 32 71 ee			ld (debug_mark),a  
1d5c 3a 6b 1d			ld a, (.dmark+1)  
1d5f 32 72 ee			ld (debug_mark+1),a  
1d62 3a 6c 1d			ld a, (.dmark+2)  
1d65 32 73 ee			ld (debug_mark+2),a  
1d68 18 03			jr .pastdmark  
1d6a ..			.dmark: db "PHm"  
1d6d f1			.pastdmark: pop af  
1d6e			endm  
# End of macro DMARK
1d6e				CALLMONITOR 
1d6e cd e8 15			call break_point_state  
1d71				endm  
# End of macro CALLMONITOR
1d71			endif	 
1d71 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d74				if DEBUG_FORTH_MALLOC_GUARD 
1d74 cc 16 4d				call z,malloc_error 
1d77				endif 
1d77			 
1d77				 
1d77 c1				pop bc    ; get length 
1d78 d1				pop de   ;  get string start    
1d79			 
1d79				; hl has destination from malloc 
1d79			 
1d79 eb				ex de, hl    ; prep for ldir 
1d7a			 
1d7a d5				push de   ; save malloc area for DSP later 
1d7b				;push hl   ; save malloc area for DSP later 
1d7b			 
1d7b			if DEBUG_FORTH_PUSH 
1d7b						DMARK "PHc" 
1d7b f5				push af  
1d7c 3a 90 1d			ld a, (.dmark)  
1d7f 32 71 ee			ld (debug_mark),a  
1d82 3a 91 1d			ld a, (.dmark+1)  
1d85 32 72 ee			ld (debug_mark+1),a  
1d88 3a 92 1d			ld a, (.dmark+2)  
1d8b 32 73 ee			ld (debug_mark+2),a  
1d8e 18 03			jr .pastdmark  
1d90 ..			.dmark: db "PHc"  
1d93 f1			.pastdmark: pop af  
1d94			endm  
# End of macro DMARK
1d94				CALLMONITOR 
1d94 cd e8 15			call break_point_state  
1d97				endm  
# End of macro CALLMONITOR
1d97			endif	 
1d97			 
1d97			 
1d97 ed b0			ldir 
1d99			 
1d99			 
1d99				; push malloc to data stack     macro?????  
1d99			 
1d99				FORTH_DSP_NEXT 
1d99 cd ed 1b			call macro_forth_dsp_next 
1d9c				endm 
# End of macro FORTH_DSP_NEXT
1d9c			 
1d9c				; save value and type 
1d9c			 
1d9c 2a f4 e9			ld hl, (cli_data_sp) 
1d9f			 
1d9f				; save item type 
1d9f 3e 01			ld a,  DS_TYPE_STR 
1da1 77				ld (hl), a 
1da2 23				inc hl 
1da3			 
1da3				; get malloc word off stack 
1da3 d1				pop de 
1da4 73				ld (hl), e 
1da5 23				inc hl 
1da6 72				ld (hl), d 
1da7			 
1da7			 
1da7			 
1da7			if DEBUG_FORTH_PUSH 
1da7 2a f4 e9			ld hl, (cli_data_sp) 
1daa						DMARK "PHS" 
1daa f5				push af  
1dab 3a bf 1d			ld a, (.dmark)  
1dae 32 71 ee			ld (debug_mark),a  
1db1 3a c0 1d			ld a, (.dmark+1)  
1db4 32 72 ee			ld (debug_mark+1),a  
1db7 3a c1 1d			ld a, (.dmark+2)  
1dba 32 73 ee			ld (debug_mark+2),a  
1dbd 18 03			jr .pastdmark  
1dbf ..			.dmark: db "PHS"  
1dc2 f1			.pastdmark: pop af  
1dc3			endm  
# End of macro DMARK
1dc3				CALLMONITOR 
1dc3 cd e8 15			call break_point_state  
1dc6				endm  
# End of macro CALLMONITOR
1dc6			;	ex de,hl 
1dc6			endif	 
1dc6				; in case of spaces, skip the ptr past the copied string 
1dc6				;pop af 
1dc6				;ld (cli_origptr),hl 
1dc6			 
1dc6 c9				ret 
1dc7			 
1dc7			 
1dc7			 
1dc7			; TODO ascii push input onto stack given hl to start of input 
1dc7			 
1dc7			; identify type 
1dc7			; if starts with a " then a string 
1dc7			; otherwise it is a number 
1dc7			;  
1dc7			; if a string 
1dc7			;     scan for ending " to get length of string to malloc for + 1 
1dc7			;     malloc 
1dc7			;     put pointer to string on stack first byte flags as string 
1dc7			; 
1dc7			; else a number 
1dc7			;    look for number format identifier 
1dc7			;    $xx hex 
1dc7			;    %xxxxx bin 
1dc7			;    xxxxx decimal 
1dc7			;    convert number to 16bit word.  
1dc7			;    malloc word + 1 with flag to identiy as num 
1dc7			;    put pointer to number on stack 
1dc7			;   
1dc7			;  
1dc7			  
1dc7			forth_apush: 
1dc7				; kernel push 
1dc7			 
1dc7			if DEBUG_FORTH_PUSH 
1dc7						DMARK "PSH" 
1dc7 f5				push af  
1dc8 3a dc 1d			ld a, (.dmark)  
1dcb 32 71 ee			ld (debug_mark),a  
1dce 3a dd 1d			ld a, (.dmark+1)  
1dd1 32 72 ee			ld (debug_mark+1),a  
1dd4 3a de 1d			ld a, (.dmark+2)  
1dd7 32 73 ee			ld (debug_mark+2),a  
1dda 18 03			jr .pastdmark  
1ddc ..			.dmark: db "PSH"  
1ddf f1			.pastdmark: pop af  
1de0			endm  
# End of macro DMARK
1de0				CALLMONITOR 
1de0 cd e8 15			call break_point_state  
1de3				endm  
# End of macro CALLMONITOR
1de3			endif	 
1de3				; identify input type 
1de3			 
1de3 7e				ld a,(hl) 
1de4 fe 22			cp '"' 
1de6 28 0a			jr z, .fapstr 
1de8 fe 24			cp '$' 
1dea ca 12 1e			jp z, .faphex 
1ded fe 25			cp '%' 
1def ca fa 1d			jp z, .fapbin 
1df2			;	cp 'b' 
1df2			;	jp z, .fabin 
1df2				; else decimal 
1df2			 
1df2				; TODO do decimal conversion 
1df2				; decimal is stored as a 16bit word 
1df2			 
1df2				; by default everything is a string if type is not detected 
1df2			.fapstr: ; 
1df2 fe 22			cp '"' 
1df4 20 01			jr nz, .strnoqu 
1df6 23				inc hl 
1df7			.strnoqu: 
1df7 c3 cc 1c			jp forth_push_str 
1dfa			 
1dfa			 
1dfa			 
1dfa			.fapbin:    ; push a binary string.  
1dfa 11 00 00			ld de, 0   ; hold a 16bit value 
1dfd			 
1dfd 23			.fapbinshift:	inc hl  
1dfe 7e				ld a,(hl) 
1dff fe 00			cp 0     ; done scanning  
1e01 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e03			 
1e03				; left shift de 
1e03 eb				ex de, hl	 
1e04 29				add hl, hl 
1e05			 
1e05				; is 1 
1e05 fe 31			cp '1' 
1e07 20 02			jr nz, .binzero 
1e09 cb 4d			bit 1, l 
1e0b			.binzero: 
1e0b eb				ex de, hl	 ; save current de 
1e0c 18 ef			jr .fapbinshift 
1e0e			 
1e0e			.fapbdone: 
1e0e eb				ex de, hl 
1e0f c3 5e 1c			jp forth_push_numhl 
1e12			 
1e12			 
1e12			.faphex:   ; hex is always stored as a 16bit word 
1e12				; skip number prefix 
1e12 23				inc hl 
1e13				; turn ascii into number 
1e13 cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1e16			 
1e16 c3 5e 1c			jp forth_push_numhl 
1e19			 
1e19 00				 nop 
1e1a			 
1e1a			.fabin:   ; TODO bin conversion 
1e1a			 
1e1a			 
1e1a c9				ret 
1e1b			 
1e1b			 
1e1b			; get either a string ptr or a 16bit word from the data stack 
1e1b			 
1e1b			FORTH_DSP: macro 
1e1b				call macro_forth_dsp 
1e1b				endm 
1e1b			 
1e1b			macro_forth_dsp: 
1e1b				; data stack pointer points to current word on tos 
1e1b			 
1e1b 2a f4 e9			ld hl,(cli_data_sp) 
1e1e			 
1e1e				if DEBUG_FORTH_PUSH 
1e1e						DMARK "DSP" 
1e1e f5				push af  
1e1f 3a 33 1e			ld a, (.dmark)  
1e22 32 71 ee			ld (debug_mark),a  
1e25 3a 34 1e			ld a, (.dmark+1)  
1e28 32 72 ee			ld (debug_mark+1),a  
1e2b 3a 35 1e			ld a, (.dmark+2)  
1e2e 32 73 ee			ld (debug_mark+2),a  
1e31 18 03			jr .pastdmark  
1e33 ..			.dmark: db "DSP"  
1e36 f1			.pastdmark: pop af  
1e37			endm  
# End of macro DMARK
1e37			 
1e37 cd 4b 4d				call display_data_sp 
1e3a				;call break_point_state 
1e3a				;rst 030h 
1e3a				CALLMONITOR 
1e3a cd e8 15			call break_point_state  
1e3d				endm  
# End of macro CALLMONITOR
1e3d				endif 
1e3d			 
1e3d c9				ret 
1e3e			 
1e3e			; return hl to start of value on stack 
1e3e			 
1e3e			FORTH_DSP_VALUE: macro 
1e3e				call macro_forth_dsp_value 
1e3e				endm 
1e3e			 
1e3e			macro_forth_dsp_value: 
1e3e			 
1e3e				FORTH_DSP 
1e3e cd 1b 1e			call macro_forth_dsp 
1e41				endm 
# End of macro FORTH_DSP
1e41			 
1e41 d5				push de 
1e42			 
1e42 23				inc hl ; skip type 
1e43			 
1e43 5e				ld e, (hl) 
1e44 23				inc hl 
1e45 56				ld d, (hl) 
1e46 eb				ex de,hl  
1e47			 
1e47 d1				pop de 
1e48			 
1e48 c9				ret 
1e49			 
1e49			; return hl to start of value to second item on stack 
1e49			 
1e49			FORTH_DSP_VALUEM1: macro 
1e49				call macro_forth_dsp_value_m1 
1e49				endm 
1e49			 
1e49			macro_forth_dsp_value_m1: 
1e49			 
1e49				FORTH_DSP 
1e49 cd 1b 1e			call macro_forth_dsp 
1e4c				endm 
# End of macro FORTH_DSP
1e4c			 
1e4c 2b				dec hl 
1e4d 2b				dec hl 
1e4e			;	dec hl 
1e4e			 
1e4e d5				push de 
1e4f			 
1e4f 5e				ld e, (hl) 
1e50 23				inc hl 
1e51 56				ld d, (hl) 
1e52 eb				ex de,hl  
1e53			 
1e53 d1				pop de 
1e54			 
1e54 c9				ret 
1e55			 
1e55				 
1e55			 
1e55			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e55			 
1e55			FORTH_DSP_POP: macro 
1e55				call macro_forth_dsp_pop 
1e55				endm 
1e55			 
1e55			 
1e55			; get the tos data type 
1e55			 
1e55			FORTH_DSP_TYPE:   macro 
1e55			 
1e55				;FORTH_DSP_VALUE 
1e55				FORTH_DSP 
1e55				 
1e55				; hl points to value 
1e55				; check type 
1e55			 
1e55				ld a,(hl) 
1e55			 
1e55				endm 
1e55			 
1e55			; load the tos value into hl 
1e55			 
1e55			 
1e55			FORTH_DSP_VALUEHL:  macro 
1e55				call macro_dsp_valuehl 
1e55				endm 
1e55			 
1e55			 
1e55			 
1e55			macro_dsp_valuehl: 
1e55				FORTH_DSP_VALUE 
1e55 cd 3e 1e			call macro_forth_dsp_value 
1e58				endm 
# End of macro FORTH_DSP_VALUE
1e58			 
1e58				;FORTH_ERR_TOS_NOTNUM 
1e58			 
1e58				;inc hl   ; skip type id 
1e58			 
1e58			;	push de 
1e58			; 
1e58			;	ld e, (hl) 
1e58			;	inc hl 
1e58			;	ld d, (hl) 
1e58			;	ex de,hl  
1e58			 
1e58			;	pop de 
1e58			 
1e58				if DEBUG_FORTH_PUSH 
1e58						DMARK "DVL" 
1e58 f5				push af  
1e59 3a 6d 1e			ld a, (.dmark)  
1e5c 32 71 ee			ld (debug_mark),a  
1e5f 3a 6e 1e			ld a, (.dmark+1)  
1e62 32 72 ee			ld (debug_mark+1),a  
1e65 3a 6f 1e			ld a, (.dmark+2)  
1e68 32 73 ee			ld (debug_mark+2),a  
1e6b 18 03			jr .pastdmark  
1e6d ..			.dmark: db "DVL"  
1e70 f1			.pastdmark: pop af  
1e71			endm  
# End of macro DMARK
1e71				CALLMONITOR 
1e71 cd e8 15			call break_point_state  
1e74				endm  
# End of macro CALLMONITOR
1e74				endif 
1e74 c9				ret 
1e75			 
1e75			forth_apushstrhl:      
1e75				; push of string requires use of cli_origptr 
1e75				; bodge use 
1e75			 
1e75				; get current cli_origptr, save, update with temp pointer  
1e75 ed 5b 44 ea		ld de, (cli_origptr) 
1e79 22 44 ea			ld (cli_origptr), hl 
1e7c d5				push de 
1e7d cd c7 1d			call forth_apush 
1e80 d1				pop de 
1e81 ed 53 44 ea		ld (cli_origptr), de 
1e85 c9			        ret	 
1e86			 
1e86			 
1e86			; increase loop stack pointer and save hl to it 
1e86				 
1e86			FORTH_LOOP_NEXT: macro 
1e86				call macro_forth_loop_next 
1e86				;nop 
1e86				endm 
1e86			 
1e86			macro_forth_loop_next: 
1e86				if DEBUG_FORTH_STACK_GUARD 
1e86 cd d9 60				call check_stacks 
1e89				endif 
1e89 e5				push hl 
1e8a d5				push de 
1e8b eb				ex de,hl 
1e8c 2a f6 e9			ld hl,(cli_loop_sp) 
1e8f 23				inc hl 
1e90 23				inc hl 
1e91					if DEBUG_FORTH_WORDS 
1e91						DMARK "LNX" 
1e91 f5				push af  
1e92 3a a6 1e			ld a, (.dmark)  
1e95 32 71 ee			ld (debug_mark),a  
1e98 3a a7 1e			ld a, (.dmark+1)  
1e9b 32 72 ee			ld (debug_mark+1),a  
1e9e 3a a8 1e			ld a, (.dmark+2)  
1ea1 32 73 ee			ld (debug_mark+2),a  
1ea4 18 03			jr .pastdmark  
1ea6 ..			.dmark: db "LNX"  
1ea9 f1			.pastdmark: pop af  
1eaa			endm  
# End of macro DMARK
1eaa						CALLMONITOR 
1eaa cd e8 15			call break_point_state  
1ead				endm  
# End of macro CALLMONITOR
1ead					endif 
1ead 22 f6 e9			ld (cli_loop_sp),hl 
1eb0 73				ld (hl), e 
1eb1 23				inc hl 
1eb2 72				ld (hl), d 
1eb3 d1				pop de    ; been reversed so save a swap on restore 
1eb4 e1				pop hl 
1eb5				if DEBUG_FORTH_STACK_GUARD 
1eb5 cd d9 60				call check_stacks 
1eb8				endif 
1eb8 c9				ret 
1eb9			 
1eb9			; get current ret stack pointer and save to hl  
1eb9				 
1eb9			FORTH_LOOP_TOS: macro 
1eb9				call macro_forth_loop_tos 
1eb9				endm 
1eb9			 
1eb9			macro_forth_loop_tos: 
1eb9 d5				push de 
1eba 2a f6 e9			ld hl,(cli_loop_sp) 
1ebd 5e				ld e, (hl) 
1ebe 23				inc hl 
1ebf 56				ld d, (hl) 
1ec0 eb				ex de, hl 
1ec1 d1				pop de 
1ec2 c9				ret 
1ec3			 
1ec3			; pop loop stack pointer 
1ec3				 
1ec3			FORTH_LOOP_POP: macro 
1ec3				call macro_forth_loop_pop 
1ec3				endm 
1ec3			 
1ec3			 
1ec3			macro_forth_loop_pop: 
1ec3				if DEBUG_FORTH_STACK_GUARD 
1ec3					DMARK "LPP" 
1ec3 f5				push af  
1ec4 3a d8 1e			ld a, (.dmark)  
1ec7 32 71 ee			ld (debug_mark),a  
1eca 3a d9 1e			ld a, (.dmark+1)  
1ecd 32 72 ee			ld (debug_mark+1),a  
1ed0 3a da 1e			ld a, (.dmark+2)  
1ed3 32 73 ee			ld (debug_mark+2),a  
1ed6 18 03			jr .pastdmark  
1ed8 ..			.dmark: db "LPP"  
1edb f1			.pastdmark: pop af  
1edc			endm  
# End of macro DMARK
1edc cd d9 60				call check_stacks 
1edf					FORTH_CHK_LOOP_UNDER 
1edf e5				push hl 
1ee0 d5				push de 
1ee1 2a f6 e9			ld hl,(cli_loop_sp) 
1ee4 11 30 e9			ld de, cli_loop_stack 
1ee7 cd 05 0e			call cmp16 
1eea da f3 61			jp c, fault_loop_under 
1eed d1				pop de 
1eee e1				pop hl 
1eef				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eef				endif 
1eef e5				push hl 
1ef0 2a f6 e9			ld hl,(cli_loop_sp) 
1ef3 2b				dec hl 
1ef4 2b				dec hl 
1ef5 22 f6 e9			ld (cli_loop_sp), hl 
1ef8				; TODO do stack underflow checks 
1ef8 e1				pop hl 
1ef9				if DEBUG_FORTH_STACK_GUARD 
1ef9 cd d9 60				call check_stacks 
1efc					FORTH_CHK_LOOP_UNDER 
1efc e5				push hl 
1efd d5				push de 
1efe 2a f6 e9			ld hl,(cli_loop_sp) 
1f01 11 30 e9			ld de, cli_loop_stack 
1f04 cd 05 0e			call cmp16 
1f07 da f3 61			jp c, fault_loop_under 
1f0a d1				pop de 
1f0b e1				pop hl 
1f0c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f0c				endif 
1f0c c9				ret 
1f0d			 
1f0d			macro_forth_dsp_pop: 
1f0d			 
1f0d e5				push hl 
1f0e			 
1f0e				; release malloc data 
1f0e			 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e cd d9 60				call check_stacks 
1f11					FORTH_CHK_DSP_UNDER 
1f11 e5				push hl 
1f12 d5				push de 
1f13 2a f4 e9			ld hl,(cli_data_sp) 
1f16 11 2e e8			ld de, cli_data_stack 
1f19 cd 05 0e			call cmp16 
1f1c da e7 61			jp c, fault_dsp_under 
1f1f d1				pop de 
1f20 e1				pop hl 
1f21				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f21				endif 
1f21				;ld hl,(cli_data_sp) 
1f21			if DEBUG_FORTH_DOT 
1f21				DMARK "DPP" 
1f21 f5				push af  
1f22 3a 36 1f			ld a, (.dmark)  
1f25 32 71 ee			ld (debug_mark),a  
1f28 3a 37 1f			ld a, (.dmark+1)  
1f2b 32 72 ee			ld (debug_mark+1),a  
1f2e 3a 38 1f			ld a, (.dmark+2)  
1f31 32 73 ee			ld (debug_mark+2),a  
1f34 18 03			jr .pastdmark  
1f36 ..			.dmark: db "DPP"  
1f39 f1			.pastdmark: pop af  
1f3a			endm  
# End of macro DMARK
1f3a				CALLMONITOR 
1f3a cd e8 15			call break_point_state  
1f3d				endm  
# End of macro CALLMONITOR
1f3d			endif	 
1f3d			 
1f3d			 
1f3d			if FORTH_ENABLE_DSPPOPFREE 
1f3d			 
1f3d				FORTH_DSP 
1f3d cd 1b 1e			call macro_forth_dsp 
1f40				endm 
# End of macro FORTH_DSP
1f40			 
1f40 7e				ld a, (hl) 
1f41 fe 01			cp DS_TYPE_STR 
1f43 20 23			jr nz, .skippopfree 
1f45			 
1f45				FORTH_DSP_VALUEHL 
1f45 cd 55 1e			call macro_dsp_valuehl 
1f48				endm 
# End of macro FORTH_DSP_VALUEHL
1f48 00				nop 
1f49			if DEBUG_FORTH_DOT 
1f49				DMARK "DPf" 
1f49 f5				push af  
1f4a 3a 5e 1f			ld a, (.dmark)  
1f4d 32 71 ee			ld (debug_mark),a  
1f50 3a 5f 1f			ld a, (.dmark+1)  
1f53 32 72 ee			ld (debug_mark+1),a  
1f56 3a 60 1f			ld a, (.dmark+2)  
1f59 32 73 ee			ld (debug_mark+2),a  
1f5c 18 03			jr .pastdmark  
1f5e ..			.dmark: db "DPf"  
1f61 f1			.pastdmark: pop af  
1f62			endm  
# End of macro DMARK
1f62				CALLMONITOR 
1f62 cd e8 15			call break_point_state  
1f65				endm  
# End of macro CALLMONITOR
1f65			endif	 
1f65 cd 78 13			call free 
1f68			.skippopfree: 
1f68				 
1f68			 
1f68			endif 
1f68			 
1f68			if DEBUG_FORTH_DOT_KEY 
1f68				DMARK "DP2" 
1f68				CALLMONITOR 
1f68			endif	 
1f68			 
1f68				; move pointer down 
1f68			 
1f68 2a f4 e9			ld hl,(cli_data_sp) 
1f6b 2b				dec hl 
1f6c 2b				dec hl 
1f6d			; PARSEV5 
1f6d 2b				dec hl 
1f6e 22 f4 e9			ld (cli_data_sp), hl 
1f71			 
1f71				if DEBUG_FORTH_STACK_GUARD 
1f71 cd d9 60				call check_stacks 
1f74					FORTH_CHK_DSP_UNDER 
1f74 e5				push hl 
1f75 d5				push de 
1f76 2a f4 e9			ld hl,(cli_data_sp) 
1f79 11 2e e8			ld de, cli_data_stack 
1f7c cd 05 0e			call cmp16 
1f7f da e7 61			jp c, fault_dsp_under 
1f82 d1				pop de 
1f83 e1				pop hl 
1f84				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f84				endif 
1f84			 
1f84 e1				pop hl 
1f85			 
1f85 c9				ret 
1f86			 
1f86			getwordathl: 
1f86				; hl points to an address 
1f86				; load hl with the word at that address 
1f86			 
1f86 d5				push de 
1f87			 
1f87 5e				ld e, (hl) 
1f88 23				inc hl 
1f89 56				ld d, (hl) 
1f8a eb				ex de, hl 
1f8b			 
1f8b d1				pop de 
1f8c c9				ret 
1f8d			 
1f8d			 
1f8d			 
1f8d			 
1f8d			 
1f8d			; eof 
1f8d			 
# End of file forth_stackopsv5.asm
1f8d			endif 
1f8d			 
1f8d			loadwordinhl:	 
1f8d			 
1f8d d5				push de 
1f8e			 
1f8e 5e				ld e, (hl) 
1f8f 23				inc hl 
1f90 56				ld d, (hl) 
1f91 eb				ex de,hl  
1f92			 
1f92 d1				pop de 
1f93			 
1f93 c9				ret 
1f94			 
1f94			user_word_eol:  
1f94				; hl contains the pointer to where to create a linked list item from the end 
1f94				; of the user dict to continue on at the system word dict 
1f94				 
1f94				; poke the stub of the word list linked list to repoint to rom words 
1f94			 
1f94				; stub format 
1f94				; db   word id 
1f94				; dw    link to next word 
1f94			        ; db char length of token 
1f94				; db string + 0 term 
1f94				; db exec code....  
1f94			 
1f94 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f96 77				ld (hl), a		; word id 
1f97 23				inc hl 
1f98			 
1f98 11 63 21			ld de, sysdict 
1f9b 73				ld (hl), e		; next word link ie system dict 
1f9c 23				inc hl 
1f9d 72				ld (hl), d		; next word link ie system dict 
1f9e 23				inc hl	 
1f9f			 
1f9f			;	ld (hl), sysdict		; next word link ie system dict 
1f9f			;	inc hl 
1f9f			;	inc hl 
1f9f			 
1f9f			;	inc hl 
1f9f			;	inc hl 
1f9f			 
1f9f 3e 02			ld a, 2			; word length is 0 
1fa1 77				ld (hl), a	 
1fa2 23				inc hl 
1fa3			 
1fa3 3e 7e			ld a, '~'			; word length is 0 
1fa5 77				ld (hl), a	 
1fa6 23				inc hl 
1fa7 3e 00			ld a, 0			; save empty word 
1fa9 77				ld (hl), a 
1faa			 
1faa c9				ret 
1fab			 
1fab				 
1fab			 
1fab			forthexec_cleanup: 
1fab				FORTH_RSP_POP 
1fab cd 26 1c			call macro_forth_rsp_pop 
1fae				endm 
# End of macro FORTH_RSP_POP
1fae c9				ret 
1faf			 
1faf			forth_call_hl: 
1faf				; taking hl 
1faf e5				push hl 
1fb0 c9				ret 
1fb1			 
1fb1			; this is called to reset Forth system but keep existing uwords etc 
1fb1			 
1fb1			forth_warmstart: 
1fb1				; setup stack over/under flow checks 
1fb1				if DEBUG_FORTH_STACK_GUARD 
1fb1 cd bf 60				call chk_stk_init 
1fb4				endif 
1fb4			 
1fb4				; init stack pointers  - * these stacks go upwards *  
1fb4 21 b2 e9			ld hl, cli_ret_stack 
1fb7 22 f8 e9			ld (cli_ret_sp), hl	 
1fba				; set bottom of stack 
1fba 3e 00			ld a,0 
1fbc 77				ld (hl),a 
1fbd 23				inc hl 
1fbe 77				ld (hl),a 
1fbf			 
1fbf 21 2e e8			ld hl, cli_data_stack 
1fc2 22 f4 e9			ld (cli_data_sp), hl	 
1fc5				; set bottom of stack 
1fc5 3e 00			ld a,0 
1fc7 77				ld (hl),a 
1fc8 23				inc hl 
1fc9 77				ld (hl),a 
1fca			 
1fca 21 30 e9			ld hl, cli_loop_stack 
1fcd 22 f6 e9			ld (cli_loop_sp), hl	 
1fd0				; set bottom of stack 
1fd0 3e 00			ld a,0 
1fd2 77				ld (hl),a 
1fd3 23				inc hl 
1fd4 77				ld (hl),a 
1fd5			 
1fd5				; init extent of current open file 
1fd5			 
1fd5 3e 00			ld a, 0 
1fd7 32 70 ea			ld (store_openext), a 
1fda			 
1fda c9				ret 
1fdb			 
1fdb			 
1fdb			; Cold Start - this is called to setup the whole Forth system 
1fdb			 
1fdb			forth_init: 
1fdb			 
1fdb				; setup stack over/under flow checks 
1fdb			 
1fdb			;	if DEBUG_FORTH_STACK_GUARD 
1fdb			;		call chk_stk_init 
1fdb			;	endif 
1fdb			 
1fdb				; enable auto display updates (slow.....) 
1fdb			 
1fdb 3e 01			ld a, 1 
1fdd 32 42 ea			ld (cli_autodisplay), a 
1fe0			 
1fe0				; if storage is in use disable long reads for now 
1fe0 3e 00			ld a, 0 
1fe2 32 7b ea			ld (store_longread), a 
1fe5			 
1fe5			 
1fe5				; show start up screen 
1fe5			 
1fe5 cd ba 0b			call clear_display 
1fe8			 
1fe8 3e 00			ld a,0 
1fea 32 64 ea			ld (f_cursor_ptr), a 
1fed			 
1fed				; set start of word list in start of ram - for use when creating user words 
1fed			 
1fed 21 b8 64			ld hl, baseram 
1ff0 22 c4 e5			ld (os_last_new_uword), hl 
1ff3 cd 94 1f			call user_word_eol 
1ff6				 
1ff6			;		call display_data_sp 
1ff6			;		call next_page_prompt 
1ff6			 
1ff6			 
1ff6			 
1ff6			 
1ff6 c9				ret 
1ff7			 
1ff7 .. 00		.bootforth: db " Forth Kernel Init ",0 
200b			 
200b			; TODO push to stack 
200b			 
200b			;  
200b			 
200b			if FORTH_PARSEV2 
200b			 
200b			 
200b				include "forth_parserv2.asm" 
200b			 
200b			endif 
200b			 
200b			 
200b			; parse cli version 1 
200b			 
200b			if FORTH_PARSEV1 
200b			 
200b			 
200b			 
200b			      include "forth_parserv1.asm" 
200b			endif 
200b				 
200b			if FORTH_PARSEV3 
200b			 
200b			 
200b			 
200b			      include "forth_parserv3.asm" 
200b				include "forth_wordsv3.asm" 
200b			endif 
200b			 
200b			if FORTH_PARSEV4 
200b			 
200b			 
200b			 
200b			      include "forth_parserv4.asm" 
200b				include "forth_wordsv4.asm" 
200b			endif 
200b			 
200b			if FORTH_PARSEV5 
200b			 
200b			 
200b			 
200b			      include "forth_parserv5.asm" 
200b			 
200b			 
200b			; A better parser without using malloc and string copies all over the place.  
200b			; Exec in situ should be faster 
200b			 
200b			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
200b			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
200b			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
200b			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
200b			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
200b			WORD_SYS_END: equ 0   ; Opcode for all user words 
200b			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
200b			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
200b			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
200b			 
200b			; Core word preamble macro 
200b			 
200b			CWHEAD:   macro nxtword opcode lit len opflags 
200b				db WORD_SYS_CORE+opcode             
200b				; internal op code number 
200b				dw nxtword            
200b				; link to next dict word block 
200b				db len + 1 
200b				; literal length of dict word inc zero term 
200b				db lit,0              
200b				; literal dict word 
200b			        ; TODO db opflags        
200b				endm 
200b			 
200b			 
200b			NEXTW: macro  
200b				jp macro_next 
200b				endm 
200b			 
200b			macro_next: 
200b			if DEBUG_FORTH_PARSE_KEY 
200b				DMARK "NXT" 
200b				CALLMONITOR 
200b			endif	 
200b			;	inc hl  ; skip token null term  
200b ed 4b 46 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
200f ed 5b 44 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2013 2a c8 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2016			if DEBUG_FORTH_PARSE_KEY 
2016				DMARK "}AA" 
2016				CALLMONITOR 
2016			endif	 
2016 c3 19 21			jp execnext 
2019				;jp exec1 
2019			       
2019			 
2019			 
2019			; Another go at the parser to compile  
2019			 
2019			 
2019			; TODO rework parser to change all of the string words to byte tokens 
2019			; TODO do a search for  
2019			 
2019			; TODO first run normal parser to zero term sections 
2019			; TODO for each word do a token look up to get the op code 
2019			; TODO need some means to flag to the exec that this is a byte code form    
2019			 
2019			 
2019			forthcompile: 
2019			 
2019			; 
2019			; line parse: 
2019			;       parse raw input buffer 
2019			;       tokenise the words 
2019			;       malloc new copy (for looping etc) 
2019			;       copy to malloc + current pc in line to start of string and add line term 
2019			;       save on new rsp 
2019			; 
2019			 
2019			; hl to point to the line to tokenise 
2019			 
2019			;	push hl 
2019 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
201c			 
201c			;	ld a,0		; string term on input 
201c			;	call strlent 
201c			 
201c			;	ld (os_tok_len), hl	 ; save string length 
201c			 
201c			;if DEBUG_FORTH_TOK 
201c			;	ex de,hl		 
201c			;endif 
201c			 
201c			;	pop hl 		; get back string pointer 
201c			 
201c			if DEBUG_FORTH_TOK 
201c						DMARK "TOc" 
201c				CALLMONITOR 
201c			endif 
201c 7e			.cptoken2:    ld a,(hl) 
201d 23				inc hl 
201e fe 7f			cp FORTH_END_BUFFER 
2020 28 29			jr z, .cptokendone2 
2022 fe 00			cp 0 
2024 28 25			jr z, .cptokendone2 
2026 fe 22			cp '"' 
2028 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
202a fe 20			cp ' ' 
202c 20 ee			jr nz,  .cptoken2 
202e			 
202e			; TODO consume comments held between ( and ) 
202e			 
202e				; we have a space so change to zero term for dict match later 
202e 2b				dec hl 
202f 3e 00			ld a,0 
2031 77				ld (hl), a 
2032 23				inc hl 
2033 18 e7			jr .cptoken2 
2035				 
2035			 
2035			.cptokenstr2: 
2035				; skip all white space until either eol (because forgot to term) or end double quote 
2035			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2035				;inc hl ; skip current double quote 
2035 7e				ld a,(hl) 
2036 23				inc hl 
2037 fe 22			cp '"' 
2039 28 e1			jr z, .cptoken2 
203b fe 7f			cp FORTH_END_BUFFER 
203d 28 0c			jr z, .cptokendone2 
203f fe 00			cp 0 
2041 28 08			jr z, .cptokendone2 
2043 fe 20			cp ' ' 
2045 28 02			jr z, .cptmp2 
2047 18 ec			jr .cptokenstr2 
2049			 
2049			.cptmp2:	; we have a space so change to zero term for dict match later 
2049				;dec hl 
2049				;ld a,"-"	; TODO remove this when working 
2049				;ld (hl), a 
2049				;inc hl 
2049 18 ea			jr .cptokenstr2 
204b			 
204b			.cptokendone2: 
204b				;inc hl 
204b 3e 7f			ld a, FORTH_END_BUFFER 
204d 77				ld (hl),a 
204e 23				inc hl 
204f 3e 21			ld a, '!' 
2051 77				ld (hl),a 
2052			 
2052 2a c8 e5			ld hl,(os_tok_ptr) 
2055			         
2055			if DEBUG_FORTH_TOK 
2055						DMARK "Tc1" 
2055				CALLMONITOR 
2055			endif 
2055			 
2055				; push exec string to top of return stack 
2055				FORTH_RSP_NEXT 
2055 cd 05 1c			call macro_forth_rsp_next 
2058				endm 
# End of macro FORTH_RSP_NEXT
2058 c9				ret 
2059			 
2059			; Another go at the parser need to simplify the process 
2059			 
2059			forthparse: 
2059			 
2059			; 
2059			; line parse: 
2059			;       parse raw input buffer 
2059			;       tokenise the words 
2059			;       malloc new copy (for looping etc) 
2059			;       copy to malloc + current pc in line to start of string and add line term 
2059			;       save on new rsp 
2059			; 
2059			 
2059			; hl to point to the line to tokenise 
2059			 
2059			;	push hl 
2059 22 c8 e5			ld (os_tok_ptr), hl  ; save ptr to string 
205c			 
205c			;	ld a,0		; string term on input 
205c			;	call strlent 
205c			 
205c			;	ld (os_tok_len), hl	 ; save string length 
205c			 
205c			;if DEBUG_FORTH_TOK 
205c			;	ex de,hl		 
205c			;endif 
205c			 
205c			;	pop hl 		; get back string pointer 
205c			 
205c			if DEBUG_FORTH_TOK 
205c						DMARK "TOK" 
205c				CALLMONITOR 
205c			endif 
205c 7e			.ptoken2:    ld a,(hl) 
205d 23				inc hl 
205e fe 7f			cp FORTH_END_BUFFER 
2060 28 29			jr z, .ptokendone2 
2062 fe 00			cp 0 
2064 28 25			jr z, .ptokendone2 
2066 fe 22			cp '"' 
2068 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
206a fe 20			cp ' ' 
206c 20 ee			jr nz,  .ptoken2 
206e			 
206e			; TODO consume comments held between ( and ) 
206e			 
206e				; we have a space so change to zero term for dict match later 
206e 2b				dec hl 
206f 3e 00			ld a,0 
2071 77				ld (hl), a 
2072 23				inc hl 
2073 18 e7			jr .ptoken2 
2075				 
2075			 
2075			.ptokenstr2: 
2075				; skip all white space until either eol (because forgot to term) or end double quote 
2075			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2075				;inc hl ; skip current double quote 
2075 7e				ld a,(hl) 
2076 23				inc hl 
2077 fe 22			cp '"' 
2079 28 e1			jr z, .ptoken2 
207b fe 7f			cp FORTH_END_BUFFER 
207d 28 0c			jr z, .ptokendone2 
207f fe 00			cp 0 
2081 28 08			jr z, .ptokendone2 
2083 fe 20			cp ' ' 
2085 28 02			jr z, .ptmp2 
2087 18 ec			jr .ptokenstr2 
2089			 
2089			.ptmp2:	; we have a space so change to zero term for dict match later 
2089				;dec hl 
2089				;ld a,"-"	; TODO remove this when working 
2089				;ld (hl), a 
2089				;inc hl 
2089 18 ea			jr .ptokenstr2 
208b			 
208b			.ptokendone2: 
208b				;inc hl 
208b 3e 7f			ld a, FORTH_END_BUFFER 
208d 77				ld (hl),a 
208e 23				inc hl 
208f 3e 21			ld a, '!' 
2091 77				ld (hl),a 
2092			 
2092 2a c8 e5			ld hl,(os_tok_ptr) 
2095			         
2095			if DEBUG_FORTH_TOK 
2095						DMARK "TK1" 
2095				CALLMONITOR 
2095			endif 
2095			 
2095				; push exec string to top of return stack 
2095				FORTH_RSP_NEXT 
2095 cd 05 1c			call macro_forth_rsp_next 
2098				endm 
# End of macro FORTH_RSP_NEXT
2098 c9				ret 
2099			 
2099			; 
2099			;	; malloc size + buffer pointer + if is loop flag 
2099			;	ld hl,(os_tok_len) 		 ; get string length 
2099			; 
2099			;	ld a,l 
2099			; 
2099			;	cp 0			; we dont want to use a null string 
2099			;	ret z 
2099			; 
2099			;;	add 3    ; prefix malloc with buffer for current word ptr 
2099			; 
2099			;	add 5     ; TODO when certain not over writing memory remove 
2099			; 
2099			;		 
2099			; 
2099			;if DEBUG_FORTH_TOK 
2099			;			DMARK "TKE" 
2099			;	CALLMONITOR 
2099			;endif 
2099			; 
2099			;	ld l,a 
2099			;	ld h,0 
2099			;;	push hl   ; save required space for the copy later 
2099			;	call malloc 
2099			;if DEBUG_FORTH_TOK 
2099			;			DMARK "TKM" 
2099			;	CALLMONITOR 
2099			;endif 
2099			;	if DEBUG_FORTH_MALLOC_GUARD 
2099			;		push af 
2099			;		call ishlzero 
2099			;;		ld a, l 
2099			;;		add h 
2099			;;		cp 0 
2099			;		pop af 
2099			;		 
2099			;		call z,malloc_error 
2099			;	endif 
2099			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2099			; 
2099			; 
2099			;if DEBUG_FORTH_TOK 
2099			;			DMARK "TKR" 
2099			;	CALLMONITOR 
2099			;endif 
2099			; 
2099			;	FORTH_RSP_NEXT 
2099			; 
2099			;	;inc hl	 ; go past current buffer pointer 
2099			;	;inc hl 
2099			;	;inc hl   ; and past if loop flag 
2099			;		; TODO Need to set flag  
2099			; 
2099			;	 
2099			;	 
2099			;	ex de,hl	; malloc is dest 
2099			;	ld hl, (os_tok_len) 
2099			;;	pop bc 
2099			;	ld c, l                
2099			;	ld b,0 
2099			;	ld hl, (os_tok_ptr) 
2099			; 
2099			;if DEBUG_FORTH_TOK 
2099			;			DMARK "TKT" 
2099			;	CALLMONITOR 
2099			;endif 
2099			; 
2099			;	; do str cpy 
2099			; 
2099			;	ldir      ; copy byte in hl to de 
2099			; 
2099			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2099			; 
2099			;if DEBUG_FORTH_TOK 
2099			; 
2099			;			DMARK "TKY" 
2099			;	CALLMONITOR 
2099			;endif 
2099			;	;ld a,0 
2099			;	;ld a,FORTH_END_BUFFER 
2099			;	ex de, hl 
2099			;	;dec hl			 ; go back over the space delim at the end of word 
2099			;	;ld (hl),a 
2099			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2099			;	ld a,FORTH_END_BUFFER 
2099			;	ld (hl),a 
2099			;	inc hl 
2099			;	ld a,FORTH_END_BUFFER 
2099			;	ld (hl),a 
2099			; 
2099			;	; init the malloc area data 
2099			;	; set pc for in current area 
2099			;	;ld hl, (os_tok_malloc) 
2099			;	;inc hl 
2099			;	;inc hl 
2099			;	;inc hl 
2099			;	;ex de,hl 
2099			;	;ld hl, (os_tok_malloc) 
2099			;	;ld (hl),e 
2099			;	;inc hl 
2099			;	;ld (hl),d 
2099			; 
2099			; 
2099			;	ld hl,(os_tok_malloc) 
2099			;if DEBUG_FORTH_PARSE_KEY 
2099			;			DMARK "TKU" 
2099			;	CALLMONITOR 
2099			;endif 
2099			; 
2099			;	ret 
2099			 
2099			forthexec: 
2099			 
2099			; line exec: 
2099			; forth parser 
2099			 
2099			; 
2099			;       get current exec line on rsp 
2099			 
2099				FORTH_RSP_TOS 
2099 cd 1c 1c			call macro_forth_rsp_tos 
209c				endm 
# End of macro FORTH_RSP_TOS
209c			 
209c			;       restore current pc - hl points to malloc of data 
209c			 
209c				;ld e, (hl) 
209c				;inc hl 
209c				;ld d, (hl) 
209c				;ex de,hl 
209c			 
209c			 
209c			exec1: 
209c 22 c8 e5			ld (os_tok_ptr), hl 
209f			 
209f				; copy our PC to working vars  
209f 22 46 ea			ld (cli_ptr), hl 
20a2 22 44 ea			ld (cli_origptr), hl 
20a5			 
20a5 7e				ld a,(hl) 
20a6 fe 7f			cp FORTH_END_BUFFER 
20a8 c8				ret z 
20a9			 
20a9				; skip any nulls 
20a9			 
20a9 fe 00			cp 0 
20ab 20 03			jr nz, .execword 
20ad 23				inc hl 
20ae 18 ec			jr exec1 
20b0			 
20b0			 
20b0			.execword: 
20b0			 
20b0			 
20b0			 
20b0			if DEBUG_FORTH_PARSE_KEY 
20b0						DMARK "KYQ" 
20b0				CALLMONITOR 
20b0			endif 
20b0			;       while at start of word: 
20b0			; get start of dict (in user area first) 
20b0			 
20b0 21 b8 64		ld hl, baseram 
20b3			;ld hl, sysdict 
20b3 22 48 ea		ld (cli_nextword),hl 
20b6			;           match word at pc 
20b6			;           exec word 
20b6			;           or push to dsp 
20b6			;           forward to next token 
20b6			;           if line term pop rsp and exit 
20b6			;        
20b6			 
20b6			if DEBUG_FORTH_PARSE_KEY 
20b6						DMARK "KYq" 
20b6				CALLMONITOR 
20b6			endif 
20b6			 
20b6			; 
20b6			; word comp 
20b6			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20b6			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20b6			;    move to start of word  
20b6			;    compare word to cli_token 
20b6			 
20b6			.execpnword:	; HL at start of a word in the dictionary to check 
20b6			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20b6			;	ld (cli_ptr), hl 
20b6			 
20b6 2a 48 ea			ld hl,(cli_nextword) 
20b9			 
20b9 cd 5c 21			call forth_tok_next 
20bc			; tok next start here 
20bc			;	; TODO skip compiled symbol for now 
20bc			;	inc hl 
20bc			; 
20bc			;	; save pointer to next word 
20bc			; 
20bc			;	; hl now points to the address of the next word pointer  
20bc			;	ld e, (hl) 
20bc			;	inc hl 
20bc			;	ld d, (hl) 
20bc			;	inc l 
20bc			; 
20bc			;	ex de,hl 
20bc			;if DEBUG_FORTH_PARSE_NEXTWORD 
20bc			;	push bc 
20bc			;	ld bc, (cli_nextword) 
20bc			;			DMARK "NXW" 
20bc			;	CALLMONITOR 
20bc			;	pop bc 
20bc			;endif 
20bc			; tok next end here 
20bc 22 48 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20bf eb				ex de, hl 
20c0			 
20c0			 
20c0				; save the pointer of the current token - 1 to check against 
20c0				 
20c0 22 4c ea			ld (cli_token), hl   
20c3				; TODO maybe remove below save if no debug 
20c3				; save token string ptr for any debug later 
20c3 23				inc hl  
20c4 22 4e ea			ld (cli_origtoken), hl 
20c7 2b				dec hl 
20c8				; save pointer to the start of the next dictionay word 
20c8 7e				ld a,(hl)   ; get string length 
20c9 47				ld b,a 
20ca			.execpnwordinc:  
20ca 23				inc hl 
20cb 10 fd			djnz .execpnwordinc 
20cd 22 4a ea			ld (cli_execword), hl      ; save start of this words code 
20d0			 
20d0				; now check the word token against the string being parsed 
20d0			 
20d0 2a 4c ea			ld hl,(cli_token) 
20d3 23				inc hl     ; skip string length (use zero term instead to end) 
20d4 22 4c ea			ld (cli_token), hl 
20d7			 
20d7			if DEBUG_FORTH_PARSE_KEY 
20d7						DMARK "KY2" 
20d7			endif 
20d7			if DEBUG_FORTH_PARSE_EXEC 
20d7				; see if disabled 
20d7			 
20d7				ld a, (os_view_disable) 
20d7				cp '*' 
20d7				jr z, .skip 
20d7			 
20d7				push hl 
20d7				push hl 
20d7				call clear_display 
20d7				ld de, .compword 
20d7				ld a, display_row_1 
20d7				call str_at_display 
20d7				pop de 
20d7				ld a, display_row_2 
20d7				call str_at_display 
20d7				ld hl,(cli_ptr) 
20d7				ld a,(hl) 
20d7			        ld hl, os_word_scratch 
20d7				ld (hl),a 
20d7				ld a,0 
20d7				inc hl 
20d7				ld (hl),a 	 
20d7				ld de, os_word_scratch 
20d7				ld a, display_row_2+10 
20d7				call str_at_display 
20d7				call update_display 
20d7				ld a, 100 
20d7				call aDelayInMS 
20d7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20d7				call delay250ms 
20d7				endif 
20d7				pop hl 
20d7			.skip:  
20d7			endif	 
20d7			.execpnchar:    ; compare char between token and string to parse 
20d7			 
20d7			if DEBUG_FORTH_PARSE_KEY 
20d7						DMARK "Ky3" 
20d7			endif 
20d7			if DEBUG_FORTH_PARSE_EXEC 
20d7				; see if disabled 
20d7			 
20d7				ld a, (os_view_disable) 
20d7				cp '*' 
20d7				jr z, .skip2 
20d7			 
20d7			;	call clear_display 
20d7			ld hl,(cli_token) 
20d7			ld a,(hl) 
20d7			ld (os_word_scratch),a 
20d7				ld hl,(cli_ptr) 
20d7			ld a,(hl) 
20d7				ld (os_word_scratch+1),a 
20d7				ld a,0 
20d7				ld (os_word_scratch+2),a 
20d7				ld de,os_word_scratch 
20d7				ld a,display_row_4 
20d7				call str_at_display 
20d7				call update_display 
20d7			.skip2:  
20d7			endif 
20d7 2a 4c ea			ld hl,(cli_token) 
20da 7e				ld a, (hl)	 ; char in word token 
20db 23				inc hl 		; move to next char 
20dc 22 4c ea			ld (cli_token), hl ; and save it 
20df 47				ld b,a 
20e0			 
20e0 2a 46 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20e3 7e				ld a,(hl) 
20e4 23				inc hl 
20e5 22 46 ea			ld (cli_ptr), hl		; move to next char 
20e8 cd 3c 12			call toUpper 		; make sure the input string matches case 
20eb			 
20eb			if DEBUG_FORTH_PARSE 
20eb			endif 
20eb			 
20eb				; input stream end of token is a space so get rid of it 
20eb			 
20eb			;	cp ' ' 
20eb			;	jr nz, .pnskipspace 
20eb			; 
20eb			;	ld a, 0		; make same term as word token term 
20eb			; 
20eb			;.pnskipspace: 
20eb			 
20eb			if DEBUG_FORTH_PARSE_KEY 
20eb						DMARK "KY7" 
20eb			endif 
20eb b8				cp b 
20ec c2 02 21			jp nz, .execpnskipword	 ; no match so move to next word 
20ef				 
20ef			;    if same 
20ef			;       scan for string terms 0 for token and 32 for input 
20ef			 
20ef				 
20ef			if DEBUG_FORTH_PARSE_KEY 
20ef						DMARK "KY8" 
20ef			endif 
20ef			 
20ef 80				add b			 
20f0 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20f2							; TODO need to make sure last word in zero term string is accounted for 
20f2 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20f4			 
20f4			 
20f4				; at end of both strings so both are exact match 
20f4			 
20f4			;       skip ptr for next word 
20f4			 
20f4 2a 46 ea			ld hl,(cli_ptr) 	; at input string term 
20f7 23				inc hl			 ; at next char 
20f8 22 46 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20fb 22 44 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20fe				 
20fe				 
20fe			if DEBUG_FORTH_PARSE_KEY 
20fe						DMARK "KY3" 
20fe			endif 
20fe			 
20fe			 
20fe			 
20fe			;       exec code block 
20fe			if DEBUG_FORTH_JP 
20fe				call clear_display 
20fe				call update_display 
20fe				call delay1s 
20fe				ld hl, (cli_execword)     ; save for next check if no match on this word 
20fe				ld a,h 
20fe				ld hl, os_word_scratch 
20fe				call hexout 
20fe				ld hl, (cli_execword)     ; save for next check if no match on this word 
20fe				ld a,l 
20fe				ld hl, os_word_scratch+2 
20fe				call hexout 
20fe				ld hl, os_word_scratch+4 
20fe				ld a,0 
20fe				ld (hl),a 
20fe				ld de,os_word_scratch 
20fe				call str_at_display 
20fe					ld a, display_row_2 
20fe					call str_at_display 
20fe				ld de, (cli_origtoken) 
20fe				ld a, display_row_1+10 
20fe					call str_at_display 
20fe			 
20fe				ld a,display_row_1 
20fe				ld de, .foundword 
20fe				ld a, display_row_3 
20fe				call str_at_display 
20fe				call update_display 
20fe				call delay1s 
20fe				call delay1s 
20fe				call delay1s 
20fe			endif 
20fe			 
20fe			if DEBUG_FORTH_PARSE_KEY 
20fe						DMARK "KYj" 
20fe			endif 
20fe				; TODO save the word pointer in this exec 
20fe			 
20fe 2a 4a ea			ld hl,(cli_execword) 
2101 e9				jp (hl) 
2102			 
2102			 
2102			;    if not same 
2102			;	scan for zero term 
2102			;	get ptr for next word 
2102			;	goto word comp 
2102			 
2102			.execpnskipword:	; get pointer to next word 
2102 2a 48 ea			ld hl,(cli_nextword) 
2105			 
2105 7e				ld a,(hl) 
2106 fe 00			cp WORD_SYS_END 
2108			;	cp 0 
2108 28 09			jr z, .execendofdict			 ; at end of words 
210a			 
210a			if DEBUG_FORTH_PARSE_KEY 
210a						DMARK "KY4" 
210a			endif 
210a			if DEBUG_FORTH_PARSE_EXEC 
210a			 
210a				; see if disabled 
210a			 
210a				ld a, (os_view_disable) 
210a				cp '*' 
210a				jr z, .noskip 
210a			 
210a			 
210a				ld de, .nowordfound 
210a				ld a, display_row_3 
210a				call str_at_display 
210a				call update_display 
210a				ld a, 100 
210a				call aDelayInMS 
210a				 
210a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
210a					call delay250ms 
210a				endif 
210a			.noskip:  
210a			 
210a			endif	 
210a			 
210a 2a 44 ea			ld hl,(cli_origptr) 
210d 22 46 ea			ld (cli_ptr),hl 
2110			 
2110			if DEBUG_FORTH_PARSE_KEY 
2110						DMARK "KY5" 
2110			endif 
2110 c3 b6 20			jp .execpnword			; else go to next word 
2113			 
2113			.execendofdict:  
2113			 
2113			if DEBUG_FORTH_PARSE_KEY 
2113						DMARK "KYe" 
2113			endif 
2113			if DEBUG_FORTH_PARSE_EXEC 
2113				; see if disabled 
2113			 
2113				ld a, (os_view_disable) 
2113				cp '*' 
2113				jr z, .ispskip 
2113			 
2113				call clear_display 
2113				call update_display 
2113				call delay1s 
2113				ld de, (cli_origptr) 
2113				ld a, display_row_1 
2113				call str_at_display 
2113				 
2113				ld de, .enddict 
2113				ld a, display_row_3 
2113				call str_at_display 
2113				call update_display 
2113				ld a, 100 
2113				call aDelayInMS 
2113				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2113				call delay1s 
2113				call delay1s 
2113				call delay1s 
2113				endif 
2113			.ispskip:  
2113				 
2113			endif	 
2113			 
2113			 
2113			 
2113				; if the word is not a keyword then must be a literal so push it to stack 
2113			 
2113			; push token to stack to end of word 
2113			 
2113				STACKFRAME ON $1efe $2f9f 
2113				if DEBUG_STACK_IMB 
2113					if ON 
2113						exx 
2113						ld de, $1efe 
2113						ld a, d 
2113						ld hl, curframe 
2113						call hexout 
2113						ld a, e 
2113						ld hl, curframe+2 
2113						call hexout 
2113						ld hl, $1efe 
2113						push hl 
2113						ld hl, $2f9f 
2113						push hl 
2113						exx 
2113					endif 
2113				endif 
2113			endm 
# End of macro STACKFRAME
2113			 
2113 2a c8 e5		ld hl,(os_tok_ptr) 
2116 cd c7 1d		call forth_apush 
2119			 
2119				STACKFRAMECHK ON $1efe $2f9f 
2119				if DEBUG_STACK_IMB 
2119					if ON 
2119						exx 
2119						ld hl, $2f9f 
2119						pop de   ; $2f9f 
2119						call cmp16 
2119						jr nz, .spnosame 
2119						ld hl, $1efe 
2119						pop de   ; $1efe 
2119						call cmp16 
2119						jr z, .spfrsame 
2119						.spnosame: call showsperror 
2119						.spfrsame: nop 
2119						exx 
2119					endif 
2119				endif 
2119			endm 
# End of macro STACKFRAMECHK
2119			 
2119			execnext: 
2119			 
2119			if DEBUG_FORTH_PARSE_KEY 
2119						DMARK "KY>" 
2119			endif 
2119			; move past token to next word 
2119			 
2119 2a c8 e5		ld hl, (os_tok_ptr) 
211c 3e 00		ld a, 0 
211e 01 ff 00		ld bc, 255     ; input buffer size 
2121 ed b1		cpir 
2123			 
2123			if DEBUG_FORTH_PARSE_KEY 
2123						DMARK "KY!" 
2123				CALLMONITOR 
2123			endif	 
2123			; TODO this might place hl on the null, so will need to forward on??? 
2123			;inc hl   ; see if this gets onto the next item 
2123			 
2123			 
2123			; TODO pass a pointer to the buffer to push 
2123			; TODO call function to push 
2123			 
2123			; look for end of input 
2123			 
2123			;inc hl 
2123			;ld a,(hl) 
2123			;cp FORTH_END_BUFFER 
2123			;ret z 
2123			 
2123			 
2123 c3 9c 20		jp exec1 
2126			 
2126			 
2126			 
2126			 
2126			 
2126			 
2126			 
2126			 
2126			 
2126			findnexttok: 
2126			 
2126				; hl is pointer to move 
2126				; de is the token to locate 
2126			 
2126					if DEBUG_FORTH 
2126						DMARK "NTK" 
2126						CALLMONITOR 
2126					endif 
2126 d5				push de 
2127			 
2127			.fnt1:	 
2127				; find first char of token to locate 
2127			 
2127 1a				ld a, (de) 
2128 4f				ld c,a 
2129 7e				ld a,(hl) 
212a cd 3c 12			call toUpper 
212d					if DEBUG_FORTH 
212d						DMARK "NT1" 
212d						CALLMONITOR 
212d					endif 
212d b9				cp c 
212e			 
212e 28 03			jr z, .fnt2cmpmorefirst	 
2130			 
2130				; first char not found move to next char 
2130			 
2130 23				inc hl 
2131 18 f4			jr .fnt1 
2133			 
2133			.fnt2cmpmorefirst:	 
2133				; first char of token found.  
2133			 
2133 e5				push hl     ; save start of token just in case it is the right one 
2134 d9				exx 
2135 e1				pop hl        ; save it to hl' 
2136 d9				exx 
2137			 
2137			 
2137			.fnt2cmpmore:	 
2137				; compare the rest 
2137				 
2137 23				inc hl 
2138 13				inc de 
2139				 
2139 1a				ld a, (de) 
213a 4f				ld c,a 
213b 7e				ld a,(hl) 
213c cd 3c 12			call toUpper 
213f			 
213f					if DEBUG_FORTH 
213f						DMARK "NT2" 
213f						CALLMONITOR 
213f					endif 
213f				; c has the token to find char 
213f				; a has the mem to scan char 
213f			 
213f b9				cp c 
2140 28 04			jr z,.fntmatch1 
2142			 
2142				; they are not the same 
2142			 
2142					if DEBUG_FORTH 
2142						DMARK "NT3" 
2142						CALLMONITOR 
2142					endif 
2142 d1				pop de	; reset de token to look for 
2143 d5				push de 
2144 18 e1			jr .fnt1 
2146				 
2146			.fntmatch1: 
2146			 
2146				; is the same char a null which means we might have a full hit? 
2146					if DEBUG_FORTH 
2146						DMARK "NT4" 
2146						CALLMONITOR 
2146					endif 
2146			 
2146 fe 00			cp 0 
2148 28 0b			jr z, .fntmatchyes 
214a			 
214a				; are we at the end of the token to find? 
214a			 
214a					if DEBUG_FORTH 
214a						DMARK "NT5" 
214a						CALLMONITOR 
214a					endif 
214a 3e 00			ld a, 0 
214c b9				cp c 
214d			 
214d c2 37 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2150			 
2150					if DEBUG_FORTH 
2150						DMARK "NT6" 
2150						CALLMONITOR 
2150					endif 
2150				; token to find is exhusted but no match to stream 
2150			 
2150				; restore tok pointer and continue on 
2150 d1				pop de 
2151 d5				push de 
2152 c3 27 21			jp .fnt1 
2155			 
2155			 
2155			.fntmatchyes: 
2155			 
2155				; hl now contains the end of the found token 
2155			 
2155				; get rid of saved token pointer to find 
2155			 
2155 d1				pop de 
2156			 
2156					if DEBUG_FORTH 
2156						DMARK "NT9" 
2156						CALLMONITOR 
2156					endif 
2156			 
2156				; hl will be on the null term so forward on 
2156			 
2156				; get back the saved start of the token 
2156			 
2156 d9				exx 
2157 e5				push hl     ; save start of token just in case it is the right one 
2158 d9				exx 
2159 e1				pop hl        ; save it to hl 
215a			 
215a c9				ret 
215b			 
215b			 
215b			; LIST needs to find a specific token   
215b			; FORGET needs to find a spefici token 
215b			 
215b			; SAVE needs to find all tokens by flag 
215b			; WORDS just needs to scan through all  by flag 
215b			; UWORDS needs to scan through all by flag 
215b			 
215b			 
215b			; given hl as pointer to start of dict look up string 
215b			; return hl as pointer to start of word block 
215b			; or 0 if not found 
215b			 
215b			forth_find_tok: 
215b c9				ret 
215c			 
215c			; given hl as pointer to dict structure 
215c			; move to the next dict block structure 
215c			 
215c			forth_tok_next: 
215c				; hl now points to the address of the next word pointer  
215c				; TODO skip compiled symbol for now 
215c			;	push de 
215c 23				inc hl 
215d 5e				ld e, (hl) 
215e 23				inc hl 
215f 56				ld d, (hl) 
2160 23				inc hl 
2161			 
2161 eb				ex de,hl 
2162			if DEBUG_FORTH_PARSE_NEXTWORD 
2162				push bc 
2162				ld bc, (cli_nextword) 
2162						DMARK "NXW" 
2162				CALLMONITOR 
2162				pop bc 
2162			endif 
2162			;	pop de	 
2162 c9				ret 
2163			 
2163			 
2163			 
2163			; eof 
# End of file forth_parserv5.asm
2163				include "forth_wordsv4.asm" 
2163			 
2163			; the core word dictionary v4 
2163			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2163			 
2163			; this is a linked list for each of the system words used 
2163			; user defined words will follow the same format but will be in ram 
2163			 
2163			 
2163			; 
2163			; 
2163			; define linked list: 
2163			; 
2163			; 1. compiled byte op code 
2163			; 2. len of text word 
2163			; 3. text word 
2163			; 4. ptr to next dictionary word 
2163			; 5. asm, calls etc for the word 
2163			; 
2163			;  if 1 == 0 then last word in dict  
2163			;   
2163			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2163			;  
2163			;  
2163			; create basic standard set of words 
2163			; 
2163			;  
2163			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2163			; 2DUP 2DROP 2SWAP  
2163			; @ C@ - get byte  
2163			; ! C! - store byte 
2163			; 0< true if less than zero 
2163			; 0= true if zero 
2163			; < >  
2163			; = true if same 
2163			; variables 
2163			 
2163			 
2163			; Hardware specific words I may need 
2163			; 
2163			; IN OUT  
2163			; calls to key util functions 
2163			; calls to hardward abstraction stuff 
2163			; easy control of frame buffers and lcd i/o 
2163			; keyboard  
2163			 
2163			 
2163			;DICT: macro 
2163			; op_code, len, word, next 
2163			;    word: 
2163			;    db op_code 
2163			;    ds word zero term 
2163			;    dw next 
2163			;    endm 
2163			 
2163			 
2163			 
2163			 
2163			; op code 1 is a flag for user define words which are to be handled differently 
2163			 
2163			 
2163			; 
2163			; 
2163			;    TODO on entry to a word this should be the expected environment 
2163			;    hl - tos value if number then held, if string this is the ptr 
2163			;    de -  
2163			 
2163			 
2163			; opcode ranges 
2163			; 0 - end of word dict 
2163			; 255 - user define words 
2163			 
2163			sysdict: 
2163			include "forth_opcodes.asm" 
2163			; op codes for forth keywords 
2163			; free to use code 0  
2163				OPCODE_HEAP: equ  1 
2163				OPCODE_EXEC: equ 2 
2163				OPCODE_DUP: equ 3 
2163				OPCODE_SWAP: equ 4 
2163				OPCODE_COLN: equ 5 
2163				OPCODE_SCOLN: equ 6 
2163				OPCODE_DROP: equ 7 
2163				OPCODE_DUP2: equ 8 
2163				OPCODE_DROP2: equ 9 
2163				OPCODE_SWAP2: equ 10 
2163				OPCODE_AT: equ 11 
2163				OPCODE_CAT: equ 12 
2163				OPCODE_BANG: equ 13 
2163				OPCODE_CBANG: equ 14 
2163				OPCODE_SCALL: equ 15 
2163				OPCODE_DEPTH: equ 16 
2163				OPCODE_OVER: equ 17 
2163				OPCODE_PAUSE: equ 18 
2163				OPCODE_PAUSES: equ 19 
2163				OPCODE_ROT: equ 20 
2163			;free to reuse	OPCODE_WORDS: equ 21 
2163			        OPCODE_NOT: equ 21 
2163				OPCODE_UWORDS: equ 22 
2163				OPCODE_BP: equ 23 
2163				OPCODE_MONITOR: equ 24  
2163				OPCODE_MALLOC: equ 25 
2163				OPCODE_FREE: equ 26 
2163				OPCODE_LIST: equ 27 
2163				OPCODE_FORGET: equ 28 
2163				OPCODE_NOP: equ 29 
2163				OPCODE_COMO: equ 30 
2163				OPCODE_COMC: equ 31 
2163			;free to reuse	OPCODE_ENDCORE: equ 32 
2163				OPCODE_AFTERSOUND: equ 33 
2163				OPCODE_GP2: equ 34 
2163				OPCODE_GP3: equ 35 
2163				OPCODE_GP4: equ 36 
2163				OPCODE_SIN: equ 37 
2163				OPCODE_SOUT: equ 38 
2163				OPCODE_SPIO: equ 39 
2163				OPCODE_SPICEH: equ 40 
2163				OPCODE_SPIOb: equ 41 
2163				OPCODE_SPII: equ 42 
2163				OPCODE_SESEL: equ 43 
2163				OPCODE_CARTDEV: equ 44 
2163			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2163				OPCODE_FB: equ 46 
2163				OPCODE_EMIT: equ 47 
2163				OPCODE_DOTH: equ 48 
2163				OPCODE_DOTF: equ 49 
2163				OPCODE_DOT: equ 50 
2163				OPCODE_CLS: equ 51 
2163				OPCODE_DRAW: equ 52 
2163				OPCODE_DUMP: equ 53 
2163				OPCODE_CDUMP: equ 54 
2163				OPCODE_DAT: equ 55 
2163				OPCODE_HOME: equ 56 
2163				OPCODE_SPACE: equ 57 
2163				OPCODE_SPACES: equ 58 
2163				OPCODE_SCROLL: equ 59 
2163				OPCODE_ATQ: equ 60 
2163				OPCODE_AUTODSP: equ 61 
2163				OPCODE_MENU: equ 62 
2163			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2163				OPCODE_THEN: equ 64 
2163				OPCODE_ELSE: equ 65 
2163				OPCODE_DO: equ 66 
2163				OPCODE_LOOP: equ 67 
2163				OPCODE_I: equ 68 
2163				OPCODE_DLOOP: equ 69  
2163				OPCODE_REPEAT: equ 70  
2163				OPCODE_UNTIL: equ 71 
2163				OPCODE_ENDFLOW: equ 72 
2163				OPCODE_WAITK: equ 73 
2163				OPCODE_ACCEPT: equ 74 
2163				OPCODE_EDIT: equ 75 
2163			;free to reuse	OPCODE_ENDKEY: equ 76 
2163				OPCODE_LZERO: equ 77 
2163				OPCODE_TZERO: equ 78 
2163				OPCODE_LESS: equ 79 
2163				OPCODE_GT: equ 80 
2163				OPCODE_EQUAL: equ 81  
2163			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2163				OPCODE_NEG: equ 83 
2163				OPCODE_DIV: equ 84 
2163				OPCODE_MUL: equ 85 
2163				OPCODE_MIN: equ 86 
2163				OPCODE_MAX: equ 87 
2163				OPCODE_RND16: equ 88 
2163				OPCODE_RND8: equ 89 
2163				OPCODE_RND: equ 90 
2163			;free to reuse	OPCODE_ENDMATHS: equ 91  
2163				OPCODE_BYNAME: equ 92 
2163				OPCODE_DIR: equ 93 
2163				OPCODE_SAVE: equ 94 
2163				OPCODE_LOAD: equ 95 
2163				OPCODE_BSAVE: equ 96 
2163				OPCODE_BLOAD: equ 97 
2163				OPCODE_SEO: equ 98  
2163				OPCODE_SEI: equ 99 
2163				OPCODE_SFREE: equ 100 
2163				OPCODE_SIZE: equ 101 
2163				OPCODE_CREATE: equ 102 
2163				OPCODE_APPEND: equ 103 
2163				OPCODE_SDEL: equ 104 
2163				OPCODE_OPEN: equ 105 
2163				OPCODE_READ: equ 106 
2163				OPCODE_EOF: equ 106 
2163				OPCODE_FORMAT: equ 107 
2163				OPCODE_LABEL: equ 108 
2163				OPCODE_LABELS: equ 109 
2163			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2163				OPCODE_UPPER: equ 111 
2163				OPCODE_LOWER: equ 112 
2163				OPCODE_SUBSTR: equ 113 
2163				OPCODE_LEFT: equ 114 
2163				OPCODE_RIGHT: equ 115 
2163				OPCODE_STR2NUM: equ 116 
2163				OPCODE_NUM2STR: equ 117 
2163				OPCODE_CONCAT: equ 118 
2163				OPCODE_FIND: equ 119 
2163				OPCODE_LEN: equ 120 
2163				OPCODE_CHAR: equ 121 
2163			; free to reuse	OPCODE_STRLEN: equ 122 
2163			; free to reuse	OPCODE_ENDSTR: equ 123 
2163				OPCODE_V0S: equ 124 
2163				OPCODE_V0Q: equ 125 
2163				OPCODE_V1S: equ 126 
2163				OPCODE_V1Q: equ 127 
2163				OPCODE_V2S: equ 128 
2163				OPCODE_V2Q: equ 129 
2163				OPCODE_V3S: equ 130 
2163				OPCODE_V3Q: equ 131 
2163			;free to reuse	OPCODE_END: equ 132 
2163				OPCODE_ZDUP: equ 133 
2163			 
2163			; eof 
# End of file forth_opcodes.asm
2163			 
2163			include "forth_words_core.asm" 
2163			 
2163			; | ## Core Words 
2163			 
2163			;if MALLOC_4 
2163			 
2163			.HEAP: 
2163				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2163 15				db WORD_SYS_CORE+OPCODE_HEAP             
2164 a2 21			dw .EXEC            
2166 05				db 4 + 1 
2167 .. 00			db "HEAP",0              
216c				endm 
# End of macro CWHEAD
216c			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
216c			; | | u1 - Current number of bytes in the heap 
216c			; | | u2 - Remaining bytes left on the heap 
216c			; | |  
216c			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
216c			 
216c			 
216c					if DEBUG_FORTH_WORDS_KEY 
216c						DMARK "HEP" 
216c f5				push af  
216d 3a 81 21			ld a, (.dmark)  
2170 32 71 ee			ld (debug_mark),a  
2173 3a 82 21			ld a, (.dmark+1)  
2176 32 72 ee			ld (debug_mark+1),a  
2179 3a 83 21			ld a, (.dmark+2)  
217c 32 73 ee			ld (debug_mark+2),a  
217f 18 03			jr .pastdmark  
2181 ..			.dmark: db "HEP"  
2184 f1			.pastdmark: pop af  
2185			endm  
# End of macro DMARK
2185						CALLMONITOR 
2185 cd e8 15			call break_point_state  
2188				endm  
# End of macro CALLMONITOR
2188					endif 
2188 2a c2 64				ld hl, (free_list )      
218b 11 c7 64				ld de, heap_start 
218e			 
218e ed 52				sbc hl, de  
2190			 
2190 cd 5e 1c				call forth_push_numhl 
2193			 
2193			 
2193 ed 5b c2 64			ld de, (free_list )      
2197 21 ad e2				ld hl, heap_end 
219a			 
219a ed 52				sbc hl, de 
219c			 
219c cd 5e 1c				call forth_push_numhl 
219f					 
219f			 
219f					 
219f			 
219f			 
219f			 
219f					NEXTW 
219f c3 0b 20			jp macro_next 
21a2				endm 
# End of macro NEXTW
21a2			;endif 
21a2			 
21a2			.EXEC: 
21a2			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21a2			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21a2			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21a2			;; > > 
21a2			;; > >   
21a2			;	STACKFRAME OFF $5efe $5f9f 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS_KEY 
21a2			;			DMARK "EXE" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			; 
21a2			;	FORTH_DSP_VALUEHL 
21a2			; 
21a2			;	FORTH_DSP_POP 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX1" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;;	ld e,(hl) 
21a2			;;	inc hl 
21a2			;;	ld d,(hl) 
21a2			;;	ex de,hl 
21a2			; 
21a2			;;		if DEBUG_FORTH_WORDS 
21a2			;;			DMARK "EX2" 
21a2			;;			CALLMONITOR 
21a2			;;		endif 
21a2			;	push hl 
21a2			; 
21a2			;	;ld a, 0 
21a2			;	;ld a, FORTH_END_BUFFER 
21a2			;	call strlenz 
21a2			;	inc hl   ; include zero term to copy 
21a2			;	inc hl   ; include term 
21a2			;	inc hl   ; include term 
21a2			;	ld b,0 
21a2			;	ld c,l 
21a2			;	pop hl 
21a2			;	ld de, execscratch 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX3" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	ldir 
21a2			; 
21a2			; 
21a2			;	ld hl, execscratch 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EXe" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			; 
21a2			;	call forthparse 
21a2			;	call forthexec 
21a2			;;	call forthexec_cleanup 
21a2			;;	call forthparse 
21a2			;;	call forthexec 
21a2			; 
21a2			;	STACKFRAMECHK OFF $5efe $5f9f 
21a2			; 
21a2			;	; an immediate word so no need to process any more words 
21a2			;	ret 
21a2			;	NEXTW 
21a2			 
21a2			; dead code - old version  
21a2			;	FORTH_RSP_NEXT 
21a2			 
21a2			;  
21a2			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21a2			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21a2			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21a2			;	push hl 
21a2			;	push de 
21a2			;	push bc 
21a2			; 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS_KEY 
21a2			;			DMARK "EXR" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			; 
21a2			; 
21a2			; 
21a2			;	;v5 FORTH_DSP_VALUE 
21a2			;	FORTH_DSP_VALUEHL 
21a2			; 
21a2			;	; TODO do string type checks 
21a2			; 
21a2			;;v5	inc hl   ; skip type 
21a2			; 
21a2			;	push hl  ; source code  
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX1" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	ld a, 0 
21a2			;	call strlent 
21a2			; 
21a2			;	inc hl 
21a2			;	inc hl 
21a2			;	inc hl 
21a2			;	inc hl 
21a2			; 
21a2			;	push hl    ; size 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX2" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	call malloc 
21a2			; 
21a2			;	ex de, hl    ; de now contains malloc area 
21a2			;	pop bc   	; get byte count 
21a2			;	pop hl      ; get string to copy 
21a2			; 
21a2			;	push de     ; save malloc for free later 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX3" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	ldir       ; duplicate string 
21a2			; 
21a2			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21a2			;	 
21a2			;	; TODO fix the parse would be better than this...  
21a2			;	ex de, hl 
21a2			;	dec hl 
21a2			;	ld a, 0 
21a2			;	ld (hl), a 
21a2			;	dec hl 
21a2			;	ld a, ' ' 
21a2			;	ld (hl), a 
21a2			;	dec hl 
21a2			;	ld (hl), a 
21a2			; 
21a2			;	dec hl 
21a2			;	ld (hl), a 
21a2			; 
21a2			; 
21a2			;	FORTH_DSP_POP  
21a2			; 
21a2			;	pop hl     
21a2			;	push hl    ; save malloc area 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX4" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			; 
21a2			;	call forthparse 
21a2			;	call forthexec 
21a2			;	 
21a2			;	pop hl 
21a2			;	if DEBUG_FORTH_WORDS 
21a2			;		DMARK "EX5" 
21a2			;		CALLMONITOR 
21a2			;	endif 
21a2			; 
21a2			;	if FORTH_ENABLE_FREE 
21a2			;	call free 
21a2			;	endif 
21a2			; 
21a2			;	if DEBUG_FORTH_WORDS 
21a2			;		DMARK "EX6" 
21a2			;		CALLMONITOR 
21a2			;	endif 
21a2			; 
21a2			;	pop bc 
21a2			;	pop de 
21a2			;	pop hl 
21a2			;;	FORTH_RSP_POP	  
21a2			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21a2			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21a2			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21a2			; 
21a2			;	if DEBUG_FORTH_WORDS 
21a2			;		DMARK "EX7" 
21a2			;		CALLMONITOR 
21a2			;	endif 
21a2			;	NEXTW 
21a2			 
21a2			;.STKEXEC: 
21a2			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21a2			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21a2			; 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS_KEY 
21a2			;			DMARK "STX" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			; 
21a2			;	FORTH_DSP_VALUEHL 
21a2			; 
21a2			;	ld (store_tmp1), hl    ; count 
21a2			; 
21a2			;	FORTH_DSP_POP 
21a2			;.stkexec1: 
21a2			;	ld hl, (store_tmp1)   ; count 
21a2			;	ld a, 0 
21a2			;	cp l 
21a2			;	ret z 
21a2			; 
21a2			;	dec hl 
21a2			;	ld (store_tmp1), hl    ; count 
21a2			;	 
21a2			;	FORTH_DSP_VALUEHL 
21a2			;	push hl 
21a2			;	 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EXp" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	FORTH_DSP_POP 
21a2			; 
21a2			;	call strlenz 
21a2			;	inc hl   ; include zero term to copy 
21a2			;	inc hl   ; include zero term to copy 
21a2			;	inc hl   ; include zero term to copy 
21a2			;	ld b,0 
21a2			;	ld c,l 
21a2			;	pop hl 
21a2			;	ld de, execscratch 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EX3" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	ldir 
21a2			; 
21a2			; 
21a2			;	ld hl, execscratch 
21a2			; 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EXP" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			; 
21a2			;	call forthparse 
21a2			;	ld hl, execscratch 
21a2			;		if DEBUG_FORTH_WORDS 
21a2			;			DMARK "EXx" 
21a2			;			CALLMONITOR 
21a2			;		endif 
21a2			;	call forthexec 
21a2			; 
21a2			;	jp .stkexec1 
21a2			; 
21a2			;	ret 
21a2			 
21a2			 
21a2			.DUP: 
21a2				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21a2 17				db WORD_SYS_CORE+OPCODE_DUP             
21a3 18 22			dw .ZDUP            
21a5 04				db 3 + 1 
21a6 .. 00			db "DUP",0              
21aa				endm 
# End of macro CWHEAD
21aa			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21aa			 
21aa					if DEBUG_FORTH_WORDS_KEY 
21aa						DMARK "DUP" 
21aa f5				push af  
21ab 3a bf 21			ld a, (.dmark)  
21ae 32 71 ee			ld (debug_mark),a  
21b1 3a c0 21			ld a, (.dmark+1)  
21b4 32 72 ee			ld (debug_mark+1),a  
21b7 3a c1 21			ld a, (.dmark+2)  
21ba 32 73 ee			ld (debug_mark+2),a  
21bd 18 03			jr .pastdmark  
21bf ..			.dmark: db "DUP"  
21c2 f1			.pastdmark: pop af  
21c3			endm  
# End of macro DMARK
21c3						CALLMONITOR 
21c3 cd e8 15			call break_point_state  
21c6				endm  
# End of macro CALLMONITOR
21c6					endif 
21c6			 
21c6					FORTH_DSP 
21c6 cd 1b 1e			call macro_forth_dsp 
21c9				endm 
# End of macro FORTH_DSP
21c9			 
21c9 7e					ld a, (HL) 
21ca fe 01				cp DS_TYPE_STR 
21cc 20 25				jr nz, .dupinum 
21ce			 
21ce					; push another string 
21ce			 
21ce					FORTH_DSP_VALUEHL     		 
21ce cd 55 1e			call macro_dsp_valuehl 
21d1				endm 
# End of macro FORTH_DSP_VALUEHL
21d1			 
21d1				if DEBUG_FORTH_WORDS 
21d1					DMARK "DUs" 
21d1 f5				push af  
21d2 3a e6 21			ld a, (.dmark)  
21d5 32 71 ee			ld (debug_mark),a  
21d8 3a e7 21			ld a, (.dmark+1)  
21db 32 72 ee			ld (debug_mark+1),a  
21de 3a e8 21			ld a, (.dmark+2)  
21e1 32 73 ee			ld (debug_mark+2),a  
21e4 18 03			jr .pastdmark  
21e6 ..			.dmark: db "DUs"  
21e9 f1			.pastdmark: pop af  
21ea			endm  
# End of macro DMARK
21ea					CALLMONITOR 
21ea cd e8 15			call break_point_state  
21ed				endm  
# End of macro CALLMONITOR
21ed				endif 
21ed cd cc 1c				call forth_push_str 
21f0			 
21f0					NEXTW 
21f0 c3 0b 20			jp macro_next 
21f3				endm 
# End of macro NEXTW
21f3			 
21f3			 
21f3			.dupinum: 
21f3					 
21f3			 
21f3			 
21f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21f3 cd 55 1e			call macro_dsp_valuehl 
21f6				endm 
# End of macro FORTH_DSP_VALUEHL
21f6			 
21f6				; TODO add floating point number detection 
21f6			 
21f6				if DEBUG_FORTH_WORDS 
21f6					DMARK "DUi" 
21f6 f5				push af  
21f7 3a 0b 22			ld a, (.dmark)  
21fa 32 71 ee			ld (debug_mark),a  
21fd 3a 0c 22			ld a, (.dmark+1)  
2200 32 72 ee			ld (debug_mark+1),a  
2203 3a 0d 22			ld a, (.dmark+2)  
2206 32 73 ee			ld (debug_mark+2),a  
2209 18 03			jr .pastdmark  
220b ..			.dmark: db "DUi"  
220e f1			.pastdmark: pop af  
220f			endm  
# End of macro DMARK
220f					CALLMONITOR 
220f cd e8 15			call break_point_state  
2212				endm  
# End of macro CALLMONITOR
2212				endif 
2212			 
2212 cd 5e 1c				call forth_push_numhl 
2215					NEXTW 
2215 c3 0b 20			jp macro_next 
2218				endm 
# End of macro NEXTW
2218			.ZDUP: 
2218				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2218 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2219 50 22			dw .SWAP            
221b 05				db 4 + 1 
221c .. 00			db "?DUP",0              
2221				endm 
# End of macro CWHEAD
2221			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2221			 
2221					if DEBUG_FORTH_WORDS_KEY 
2221						DMARK "qDU" 
2221 f5				push af  
2222 3a 36 22			ld a, (.dmark)  
2225 32 71 ee			ld (debug_mark),a  
2228 3a 37 22			ld a, (.dmark+1)  
222b 32 72 ee			ld (debug_mark+1),a  
222e 3a 38 22			ld a, (.dmark+2)  
2231 32 73 ee			ld (debug_mark+2),a  
2234 18 03			jr .pastdmark  
2236 ..			.dmark: db "qDU"  
2239 f1			.pastdmark: pop af  
223a			endm  
# End of macro DMARK
223a						CALLMONITOR 
223a cd e8 15			call break_point_state  
223d				endm  
# End of macro CALLMONITOR
223d					endif 
223d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
223d cd 55 1e			call macro_dsp_valuehl 
2240				endm 
# End of macro FORTH_DSP_VALUEHL
2240			 
2240 e5					push hl 
2241			 
2241					; is it a zero? 
2241			 
2241 3e 00				ld a, 0 
2243 84					add h 
2244 85					add l 
2245			 
2245 e1					pop hl 
2246			 
2246 fe 00				cp 0 
2248 28 03				jr z, .dup2orig 
224a			 
224a			 
224a cd 5e 1c				call forth_push_numhl 
224d			 
224d			 
224d				; TODO add floating point number detection 
224d			 
224d			.dup2orig: 
224d			 
224d					NEXTW 
224d c3 0b 20			jp macro_next 
2250				endm 
# End of macro NEXTW
2250			.SWAP: 
2250				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2250 18				db WORD_SYS_CORE+OPCODE_SWAP             
2251 8f 22			dw .COLN            
2253 05				db 4 + 1 
2254 .. 00			db "SWAP",0              
2259				endm 
# End of macro CWHEAD
2259			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2259					if DEBUG_FORTH_WORDS_KEY 
2259						DMARK "SWP" 
2259 f5				push af  
225a 3a 6e 22			ld a, (.dmark)  
225d 32 71 ee			ld (debug_mark),a  
2260 3a 6f 22			ld a, (.dmark+1)  
2263 32 72 ee			ld (debug_mark+1),a  
2266 3a 70 22			ld a, (.dmark+2)  
2269 32 73 ee			ld (debug_mark+2),a  
226c 18 03			jr .pastdmark  
226e ..			.dmark: db "SWP"  
2271 f1			.pastdmark: pop af  
2272			endm  
# End of macro DMARK
2272						CALLMONITOR 
2272 cd e8 15			call break_point_state  
2275				endm  
# End of macro CALLMONITOR
2275					endif 
2275			 
2275					FORTH_DSP_VALUEHL 
2275 cd 55 1e			call macro_dsp_valuehl 
2278				endm 
# End of macro FORTH_DSP_VALUEHL
2278 e5					push hl     ; w2 
2279			 
2279					FORTH_DSP_POP 
2279 cd 0d 1f			call macro_forth_dsp_pop 
227c				endm 
# End of macro FORTH_DSP_POP
227c			 
227c					FORTH_DSP_VALUEHL 
227c cd 55 1e			call macro_dsp_valuehl 
227f				endm 
# End of macro FORTH_DSP_VALUEHL
227f			 
227f					FORTH_DSP_POP 
227f cd 0d 1f			call macro_forth_dsp_pop 
2282				endm 
# End of macro FORTH_DSP_POP
2282			 
2282 d1					pop de     ; w2	, hl = w1 
2283			 
2283 eb					ex de, hl 
2284 d5					push de 
2285			 
2285 cd 5e 1c				call forth_push_numhl 
2288			 
2288 e1					pop hl 
2289			 
2289 cd 5e 1c				call forth_push_numhl 
228c					 
228c			 
228c					NEXTW 
228c c3 0b 20			jp macro_next 
228f				endm 
# End of macro NEXTW
228f			.COLN: 
228f				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
228f 19				db WORD_SYS_CORE+OPCODE_COLN             
2290 1b 24			dw .SCOLN            
2292 02				db 1 + 1 
2293 .. 00			db ":",0              
2295				endm 
# End of macro CWHEAD
2295			; | : ( -- )         Create new word | DONE 
2295			 
2295					if DEBUG_FORTH_WORDS_KEY 
2295						DMARK "CLN" 
2295 f5				push af  
2296 3a aa 22			ld a, (.dmark)  
2299 32 71 ee			ld (debug_mark),a  
229c 3a ab 22			ld a, (.dmark+1)  
229f 32 72 ee			ld (debug_mark+1),a  
22a2 3a ac 22			ld a, (.dmark+2)  
22a5 32 73 ee			ld (debug_mark+2),a  
22a8 18 03			jr .pastdmark  
22aa ..			.dmark: db "CLN"  
22ad f1			.pastdmark: pop af  
22ae			endm  
# End of macro DMARK
22ae						CALLMONITOR 
22ae cd e8 15			call break_point_state  
22b1				endm  
# End of macro CALLMONITOR
22b1					endif 
22b1				STACKFRAME OFF $8efe $989f 
22b1				if DEBUG_STACK_IMB 
22b1					if OFF 
22b1						exx 
22b1						ld de, $8efe 
22b1						ld a, d 
22b1						ld hl, curframe 
22b1						call hexout 
22b1						ld a, e 
22b1						ld hl, curframe+2 
22b1						call hexout 
22b1						ld hl, $8efe 
22b1						push hl 
22b1						ld hl, $989f 
22b1						push hl 
22b1						exx 
22b1					endif 
22b1				endif 
22b1			endm 
# End of macro STACKFRAME
22b1				; get parser buffer length  of new word 
22b1			 
22b1				 
22b1			 
22b1					; move tok past this to start of name defintition 
22b1					; TODO get word to define 
22b1					; TODO Move past word token 
22b1					; TODO get length of string up to the ';' 
22b1			 
22b1 2a c8 e5			ld hl, (os_tok_ptr) 
22b4 23				inc hl 
22b5 23				inc hl 
22b6			 
22b6 3e 3b			ld a, ';' 
22b8 cd 50 12			call strlent 
22bb			 
22bb 7d				ld a,l 
22bc 32 c3 e2			ld (os_new_parse_len), a 
22bf			 
22bf			 
22bf			if DEBUG_FORTH_UWORD 
22bf ed 5b c8 e5		ld de, (os_tok_ptr) 
22c3						DMARK ":01" 
22c3 f5				push af  
22c4 3a d8 22			ld a, (.dmark)  
22c7 32 71 ee			ld (debug_mark),a  
22ca 3a d9 22			ld a, (.dmark+1)  
22cd 32 72 ee			ld (debug_mark+1),a  
22d0 3a da 22			ld a, (.dmark+2)  
22d3 32 73 ee			ld (debug_mark+2),a  
22d6 18 03			jr .pastdmark  
22d8 ..			.dmark: db ":01"  
22db f1			.pastdmark: pop af  
22dc			endm  
# End of macro DMARK
22dc				CALLMONITOR 
22dc cd e8 15			call break_point_state  
22df				endm  
# End of macro CALLMONITOR
22df			endif 
22df			 
22df			; 
22df			;  new word memory layout: 
22df			;  
22df			;    : adg 6666 ;  
22df			; 
22df			;    db   1     ; user defined word  
22df 23				inc hl    
22e0			;    dw   sysdict 
22e0 23				inc hl 
22e1 23				inc hl 
22e2			;    db <word len>+1 (for null) 
22e2 23				inc hl 
22e3			;    db .... <word> 
22e3			; 
22e3			 
22e3 23				inc hl    ; some extras for the word preamble before the above 
22e4 23				inc hl 
22e5 23				inc hl 
22e6 23				inc hl 
22e7 23				inc hl 
22e8 23				inc hl 
22e9 23				inc hl  
22ea 23				inc hl 
22eb 23				inc hl 
22ec 23				inc hl 
22ed 23				inc hl 
22ee 23				inc hl 
22ef 23				inc hl 
22f0 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22f1			;       exec word buffer 
22f1			;	<ptr word>   
22f1 23				inc hl 
22f2 23				inc hl 
22f3			;       <word list><null term> 7F final term 
22f3			 
22f3			 
22f3			if DEBUG_FORTH_UWORD 
22f3						DMARK ":02" 
22f3 f5				push af  
22f4 3a 08 23			ld a, (.dmark)  
22f7 32 71 ee			ld (debug_mark),a  
22fa 3a 09 23			ld a, (.dmark+1)  
22fd 32 72 ee			ld (debug_mark+1),a  
2300 3a 0a 23			ld a, (.dmark+2)  
2303 32 73 ee			ld (debug_mark+2),a  
2306 18 03			jr .pastdmark  
2308 ..			.dmark: db ":02"  
230b f1			.pastdmark: pop af  
230c			endm  
# End of macro DMARK
230c				CALLMONITOR 
230c cd e8 15			call break_point_state  
230f				endm  
# End of macro CALLMONITOR
230f			endif 
230f			 
230f				 
230f					; malloc the size 
230f			 
230f cd ae 12				call malloc 
2312 22 c5 e2				ld (os_new_malloc), hl     ; save malloc start 
2315			 
2315			;    db   1     ; user defined word  
2315 3e 01				ld a, WORD_SYS_UWORD  
2317 77					ld (hl), a 
2318				 
2318 23				inc hl    
2319			;    dw   sysdict 
2319 11 63 21			ld de, sysdict       ; continue on with the scan to the system dict 
231c 73				ld (hl), e 
231d 23				inc hl 
231e 72				ld (hl), d 
231f 23				inc hl 
2320			 
2320			 
2320			;    Setup dict word 
2320			 
2320 23				inc hl 
2321 22 bf e2			ld (os_new_work_ptr), hl     ; save start of dict word  
2324			 
2324				; 1. get length of dict word 
2324			 
2324			 
2324 2a c8 e5			ld hl, (os_tok_ptr) 
2327 23				inc hl 
2328 23				inc hl    ; position to start of dict word 
2329 3e 00			ld a, 0 
232b cd 50 12			call strlent 
232e			 
232e			 
232e 23				inc hl    ; to include null??? 
232f			 
232f				; write length of dict word 
232f			 
232f ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2333 1b				dec de 
2334 eb				ex de, hl 
2335 73				ld (hl), e 
2336 eb				ex de, hl 
2337			 
2337				 
2337			 
2337				; copy  
2337 4d				ld c, l 
2338 06 00			ld b, 0 
233a ed 5b bf e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
233e 2a c8 e5			ld hl, (os_tok_ptr) 
2341 23				inc hl 
2342 23				inc hl    ; position to start of dict word 
2343				 
2343			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2343				 
2343				; TODO need to convert word to upper case 
2343			 
2343			ucasetok:	 
2343 7e				ld a,(hl) 
2344 cd 3c 12			call toUpper 
2347 77				ld (hl),a 
2348 ed a0			ldi 
234a f2 43 23		 	jp p, ucasetok 
234d			 
234d			 
234d			 
234d				; de now points to start of where the word body code should be placed 
234d ed 53 bf e2		ld (os_new_work_ptr), de 
2351				; hl now points to the words to throw at forthexec which needs to be copied 
2351 22 bd e2			ld (os_new_src_ptr), hl 
2354			 
2354				; TODO add 'call to forthexec' 
2354			 
2354			if DEBUG_FORTH_UWORD 
2354 c5				push bc 
2355 ed 4b c5 e2		ld bc, (os_new_malloc) 
2359						DMARK ":0x" 
2359 f5				push af  
235a 3a 6e 23			ld a, (.dmark)  
235d 32 71 ee			ld (debug_mark),a  
2360 3a 6f 23			ld a, (.dmark+1)  
2363 32 72 ee			ld (debug_mark+1),a  
2366 3a 70 23			ld a, (.dmark+2)  
2369 32 73 ee			ld (debug_mark+2),a  
236c 18 03			jr .pastdmark  
236e ..			.dmark: db ":0x"  
2371 f1			.pastdmark: pop af  
2372			endm  
# End of macro DMARK
2372				CALLMONITOR 
2372 cd e8 15			call break_point_state  
2375				endm  
# End of macro CALLMONITOR
2375 c1				pop bc 
2376			endif 
2376			 
2376			 
2376				; create word preamble which should be: 
2376			 
2376			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2376			 
2376				;    ld hl, <word code> 
2376				;    jp user_exec 
2376			        ;    <word code bytes> 
2376			 
2376			 
2376			;	inc de     ; TODO ??? or are we already past the word's null 
2376 eb				ex de, hl 
2377			 
2377 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2379			 
2379 23				inc hl 
237a 22 b9 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
237d 23				inc hl 
237e			 
237e 23				inc hl 
237f 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2381			 
2381 01 44 4c			ld bc, user_exec 
2384 23				inc hl 
2385 71				ld (hl), c     ; poke address of user_exec 
2386 23				inc hl 
2387 70				ld (hl), b     
2388			 ; 
2388			;	inc hl 
2388			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2388			; 
2388			; 
2388			;	ld bc, macro_forth_rsp_next 
2388			;	inc hl 
2388			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2388			;	inc hl 
2388			;	ld (hl), b     
2388			 ; 
2388			;	inc hl 
2388			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2388			; 
2388			; 
2388			;	inc hl 
2388			;	ld bc, forthexec 
2388			;	ld (hl), c     ; poke address of forthexec 
2388			;	inc hl 
2388			;	ld (hl), b      
2388			; 
2388			;	inc hl 
2388			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2388			; 
2388			;	ld bc, user_dict_next 
2388			;	inc hl 
2388			;	ld (hl), c     ; poke address of forthexec 
2388			;	inc hl 
2388			;	ld (hl), b      
2388			 
2388				; hl is now where we need to copy the word byte data to save this 
2388			 
2388 23				inc hl 
2389 22 bb e2			ld (os_new_exec), hl 
238c				 
238c				; copy definition 
238c			 
238c eb				ex de, hl 
238d			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
238d			;	inc de    ; skip the PC for this parse 
238d 3a c3 e2			ld a, (os_new_parse_len) 
2390 4f				ld c, a 
2391 06 00			ld b, 0 
2393 ed b0			ldir		 ; copy defintion 
2395			 
2395			 
2395				; poke the address of where the new word bytes live for forthexec 
2395			 
2395 2a b9 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2398			 
2398 ed 5b bb e2		ld de, (os_new_exec)      
239c				 
239c 73				ld (hl), e 
239d 23				inc hl 
239e 72				ld (hl), d 
239f			 
239f					; TODO copy last user dict word next link to this word 
239f					; TODO update last user dict word to point to this word 
239f			; 
239f			; hl f923 de 812a ; bc 811a 
239f			 
239f			if DEBUG_FORTH_UWORD 
239f c5				push bc 
23a0 ed 4b c5 e2		ld bc, (os_new_malloc) 
23a4						DMARK ":0A" 
23a4 f5				push af  
23a5 3a b9 23			ld a, (.dmark)  
23a8 32 71 ee			ld (debug_mark),a  
23ab 3a ba 23			ld a, (.dmark+1)  
23ae 32 72 ee			ld (debug_mark+1),a  
23b1 3a bb 23			ld a, (.dmark+2)  
23b4 32 73 ee			ld (debug_mark+2),a  
23b7 18 03			jr .pastdmark  
23b9 ..			.dmark: db ":0A"  
23bc f1			.pastdmark: pop af  
23bd			endm  
# End of macro DMARK
23bd				CALLMONITOR 
23bd cd e8 15			call break_point_state  
23c0				endm  
# End of macro CALLMONITOR
23c0 c1				pop bc 
23c1			endif 
23c1			if DEBUG_FORTH_UWORD 
23c1 c5				push bc 
23c2 ed 4b c5 e2		ld bc, (os_new_malloc) 
23c6 03				inc bc 
23c7 03				inc bc 
23c8 03				inc bc 
23c9 03				inc bc 
23ca 03				inc bc 
23cb 03				inc bc 
23cc 03				inc bc 
23cd 03				inc bc 
23ce			 
23ce						DMARK ":0B" 
23ce f5				push af  
23cf 3a e3 23			ld a, (.dmark)  
23d2 32 71 ee			ld (debug_mark),a  
23d5 3a e4 23			ld a, (.dmark+1)  
23d8 32 72 ee			ld (debug_mark+1),a  
23db 3a e5 23			ld a, (.dmark+2)  
23de 32 73 ee			ld (debug_mark+2),a  
23e1 18 03			jr .pastdmark  
23e3 ..			.dmark: db ":0B"  
23e6 f1			.pastdmark: pop af  
23e7			endm  
# End of macro DMARK
23e7				CALLMONITOR 
23e7 cd e8 15			call break_point_state  
23ea				endm  
# End of macro CALLMONITOR
23ea c1				pop bc 
23eb			endif 
23eb			 
23eb			; update word dict linked list for new word 
23eb			 
23eb			 
23eb 2a c4 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23ee 23			inc hl     ; move to next work linked list ptr 
23ef			 
23ef ed 5b c5 e2	ld de, (os_new_malloc)		 ; new next word 
23f3 73			ld (hl), e 
23f4 23			inc hl 
23f5 72			ld (hl), d 
23f6			 
23f6			if DEBUG_FORTH_UWORD 
23f6 ed 4b c4 e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23fa			endif 
23fa			 
23fa ed 53 c4 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23fe			 
23fe			 
23fe			if DEBUG_FORTH_UWORD 
23fe						DMARK ":0+" 
23fe f5				push af  
23ff 3a 13 24			ld a, (.dmark)  
2402 32 71 ee			ld (debug_mark),a  
2405 3a 14 24			ld a, (.dmark+1)  
2408 32 72 ee			ld (debug_mark+1),a  
240b 3a 15 24			ld a, (.dmark+2)  
240e 32 73 ee			ld (debug_mark+2),a  
2411 18 03			jr .pastdmark  
2413 ..			.dmark: db ":0+"  
2416 f1			.pastdmark: pop af  
2417			endm  
# End of macro DMARK
2417				CALLMONITOR 
2417 cd e8 15			call break_point_state  
241a				endm  
# End of macro CALLMONITOR
241a			endif 
241a			 
241a				STACKFRAMECHK OFF $8efe $989f 
241a				if DEBUG_STACK_IMB 
241a					if OFF 
241a						exx 
241a						ld hl, $989f 
241a						pop de   ; $989f 
241a						call cmp16 
241a						jr nz, .spnosame 
241a						ld hl, $8efe 
241a						pop de   ; $8efe 
241a						call cmp16 
241a						jr z, .spfrsame 
241a						.spnosame: call showsperror 
241a						.spfrsame: nop 
241a						exx 
241a					endif 
241a				endif 
241a			endm 
# End of macro STACKFRAMECHK
241a			 
241a c9			ret    ; dont process any remaining parser tokens as they form new word 
241b			 
241b			 
241b			 
241b			 
241b			;		NEXT 
241b			.SCOLN: 
241b			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
241b 06				db OPCODE_SCOLN 
241c 67 24			dw .DROP 
241e 02				db 2 
241f .. 00			db ";",0           
2421			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2421					if DEBUG_FORTH_WORDS_KEY 
2421						DMARK "SCN" 
2421 f5				push af  
2422 3a 36 24			ld a, (.dmark)  
2425 32 71 ee			ld (debug_mark),a  
2428 3a 37 24			ld a, (.dmark+1)  
242b 32 72 ee			ld (debug_mark+1),a  
242e 3a 38 24			ld a, (.dmark+2)  
2431 32 73 ee			ld (debug_mark+2),a  
2434 18 03			jr .pastdmark  
2436 ..			.dmark: db "SCN"  
2439 f1			.pastdmark: pop af  
243a			endm  
# End of macro DMARK
243a						CALLMONITOR 
243a cd e8 15			call break_point_state  
243d				endm  
# End of macro CALLMONITOR
243d					endif 
243d					FORTH_RSP_TOS 
243d cd 1c 1c			call macro_forth_rsp_tos 
2440				endm 
# End of macro FORTH_RSP_TOS
2440 e5					push hl 
2441					FORTH_RSP_POP 
2441 cd 26 1c			call macro_forth_rsp_pop 
2444				endm 
# End of macro FORTH_RSP_POP
2444 e1					pop hl 
2445			;		ex de,hl 
2445 22 c8 e5				ld (os_tok_ptr),hl 
2448			 
2448			if DEBUG_FORTH_UWORD 
2448						DMARK "SCL" 
2448 f5				push af  
2449 3a 5d 24			ld a, (.dmark)  
244c 32 71 ee			ld (debug_mark),a  
244f 3a 5e 24			ld a, (.dmark+1)  
2452 32 72 ee			ld (debug_mark+1),a  
2455 3a 5f 24			ld a, (.dmark+2)  
2458 32 73 ee			ld (debug_mark+2),a  
245b 18 03			jr .pastdmark  
245d ..			.dmark: db "SCL"  
2460 f1			.pastdmark: pop af  
2461			endm  
# End of macro DMARK
2461				CALLMONITOR 
2461 cd e8 15			call break_point_state  
2464				endm  
# End of macro CALLMONITOR
2464			endif 
2464					NEXTW 
2464 c3 0b 20			jp macro_next 
2467				endm 
# End of macro NEXTW
2467			 
2467			.DROP: 
2467				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2467 1b				db WORD_SYS_CORE+OPCODE_DROP             
2468 92 24			dw .DUP2            
246a 05				db 4 + 1 
246b .. 00			db "DROP",0              
2470				endm 
# End of macro CWHEAD
2470			; | DROP ( w -- )   drop the TOS item   | DONE 
2470					if DEBUG_FORTH_WORDS_KEY 
2470						DMARK "DRP" 
2470 f5				push af  
2471 3a 85 24			ld a, (.dmark)  
2474 32 71 ee			ld (debug_mark),a  
2477 3a 86 24			ld a, (.dmark+1)  
247a 32 72 ee			ld (debug_mark+1),a  
247d 3a 87 24			ld a, (.dmark+2)  
2480 32 73 ee			ld (debug_mark+2),a  
2483 18 03			jr .pastdmark  
2485 ..			.dmark: db "DRP"  
2488 f1			.pastdmark: pop af  
2489			endm  
# End of macro DMARK
2489						CALLMONITOR 
2489 cd e8 15			call break_point_state  
248c				endm  
# End of macro CALLMONITOR
248c					endif 
248c					FORTH_DSP_POP 
248c cd 0d 1f			call macro_forth_dsp_pop 
248f				endm 
# End of macro FORTH_DSP_POP
248f					NEXTW 
248f c3 0b 20			jp macro_next 
2492				endm 
# End of macro NEXTW
2492			.DUP2: 
2492				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2492 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2493 d7 24			dw .DROP2            
2495 05				db 4 + 1 
2496 .. 00			db "2DUP",0              
249b				endm 
# End of macro CWHEAD
249b			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
249b					if DEBUG_FORTH_WORDS_KEY 
249b						DMARK "2DU" 
249b f5				push af  
249c 3a b0 24			ld a, (.dmark)  
249f 32 71 ee			ld (debug_mark),a  
24a2 3a b1 24			ld a, (.dmark+1)  
24a5 32 72 ee			ld (debug_mark+1),a  
24a8 3a b2 24			ld a, (.dmark+2)  
24ab 32 73 ee			ld (debug_mark+2),a  
24ae 18 03			jr .pastdmark  
24b0 ..			.dmark: db "2DU"  
24b3 f1			.pastdmark: pop af  
24b4			endm  
# End of macro DMARK
24b4						CALLMONITOR 
24b4 cd e8 15			call break_point_state  
24b7				endm  
# End of macro CALLMONITOR
24b7					endif 
24b7					FORTH_DSP_VALUEHL 
24b7 cd 55 1e			call macro_dsp_valuehl 
24ba				endm 
# End of macro FORTH_DSP_VALUEHL
24ba e5					push hl      ; 2 
24bb			 
24bb					FORTH_DSP_POP 
24bb cd 0d 1f			call macro_forth_dsp_pop 
24be				endm 
# End of macro FORTH_DSP_POP
24be					 
24be					FORTH_DSP_VALUEHL 
24be cd 55 1e			call macro_dsp_valuehl 
24c1				endm 
# End of macro FORTH_DSP_VALUEHL
24c1			;		push hl      ; 1 
24c1			 
24c1					FORTH_DSP_POP 
24c1 cd 0d 1f			call macro_forth_dsp_pop 
24c4				endm 
# End of macro FORTH_DSP_POP
24c4			 
24c4			;		pop hl       ; 1 
24c4 d1					pop de       ; 2 
24c5			 
24c5 cd 5e 1c				call forth_push_numhl 
24c8 eb					ex de, hl 
24c9 cd 5e 1c				call forth_push_numhl 
24cc			 
24cc					 
24cc eb					ex de, hl 
24cd			 
24cd cd 5e 1c				call forth_push_numhl 
24d0 eb					ex de, hl 
24d1 cd 5e 1c				call forth_push_numhl 
24d4			 
24d4			 
24d4					NEXTW 
24d4 c3 0b 20			jp macro_next 
24d7				endm 
# End of macro NEXTW
24d7			.DROP2: 
24d7				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24d7 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24d8 06 25			dw .SWAP2            
24da 06				db 5 + 1 
24db .. 00			db "2DROP",0              
24e1				endm 
# End of macro CWHEAD
24e1			; | 2DROP ( w w -- )    Double drop | DONE 
24e1					if DEBUG_FORTH_WORDS_KEY 
24e1						DMARK "2DR" 
24e1 f5				push af  
24e2 3a f6 24			ld a, (.dmark)  
24e5 32 71 ee			ld (debug_mark),a  
24e8 3a f7 24			ld a, (.dmark+1)  
24eb 32 72 ee			ld (debug_mark+1),a  
24ee 3a f8 24			ld a, (.dmark+2)  
24f1 32 73 ee			ld (debug_mark+2),a  
24f4 18 03			jr .pastdmark  
24f6 ..			.dmark: db "2DR"  
24f9 f1			.pastdmark: pop af  
24fa			endm  
# End of macro DMARK
24fa						CALLMONITOR 
24fa cd e8 15			call break_point_state  
24fd				endm  
# End of macro CALLMONITOR
24fd					endif 
24fd					FORTH_DSP_POP 
24fd cd 0d 1f			call macro_forth_dsp_pop 
2500				endm 
# End of macro FORTH_DSP_POP
2500					FORTH_DSP_POP 
2500 cd 0d 1f			call macro_forth_dsp_pop 
2503				endm 
# End of macro FORTH_DSP_POP
2503					NEXTW 
2503 c3 0b 20			jp macro_next 
2506				endm 
# End of macro NEXTW
2506			.SWAP2: 
2506				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2506 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2507 2f 25			dw .AT            
2509 06				db 5 + 1 
250a .. 00			db "2SWAP",0              
2510				endm 
# End of macro CWHEAD
2510			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2510					if DEBUG_FORTH_WORDS_KEY 
2510						DMARK "2SW" 
2510 f5				push af  
2511 3a 25 25			ld a, (.dmark)  
2514 32 71 ee			ld (debug_mark),a  
2517 3a 26 25			ld a, (.dmark+1)  
251a 32 72 ee			ld (debug_mark+1),a  
251d 3a 27 25			ld a, (.dmark+2)  
2520 32 73 ee			ld (debug_mark+2),a  
2523 18 03			jr .pastdmark  
2525 ..			.dmark: db "2SW"  
2528 f1			.pastdmark: pop af  
2529			endm  
# End of macro DMARK
2529						CALLMONITOR 
2529 cd e8 15			call break_point_state  
252c				endm  
# End of macro CALLMONITOR
252c					endif 
252c					NEXTW 
252c c3 0b 20			jp macro_next 
252f				endm 
# End of macro NEXTW
252f			.AT: 
252f				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
252f 1f				db WORD_SYS_CORE+OPCODE_AT             
2530 61 25			dw .CAT            
2532 02				db 1 + 1 
2533 .. 00			db "@",0              
2535				endm 
# End of macro CWHEAD
2535			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2535			 
2535					if DEBUG_FORTH_WORDS_KEY 
2535						DMARK "AT." 
2535 f5				push af  
2536 3a 4a 25			ld a, (.dmark)  
2539 32 71 ee			ld (debug_mark),a  
253c 3a 4b 25			ld a, (.dmark+1)  
253f 32 72 ee			ld (debug_mark+1),a  
2542 3a 4c 25			ld a, (.dmark+2)  
2545 32 73 ee			ld (debug_mark+2),a  
2548 18 03			jr .pastdmark  
254a ..			.dmark: db "AT."  
254d f1			.pastdmark: pop af  
254e			endm  
# End of macro DMARK
254e						CALLMONITOR 
254e cd e8 15			call break_point_state  
2551				endm  
# End of macro CALLMONITOR
2551					endif 
2551			.getbyteat:	 
2551					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2551 cd 55 1e			call macro_dsp_valuehl 
2554				endm 
# End of macro FORTH_DSP_VALUEHL
2554					 
2554			;		push hl 
2554				 
2554					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2554 cd 0d 1f			call macro_forth_dsp_pop 
2557				endm 
# End of macro FORTH_DSP_POP
2557			 
2557			;		pop hl 
2557			 
2557 7e					ld a, (hl) 
2558			 
2558 6f					ld l, a 
2559 26 00				ld h, 0 
255b cd 5e 1c				call forth_push_numhl 
255e			 
255e					NEXTW 
255e c3 0b 20			jp macro_next 
2561				endm 
# End of macro NEXTW
2561			.CAT: 
2561				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2561 20				db WORD_SYS_CORE+OPCODE_CAT             
2562 8a 25			dw .BANG            
2564 03				db 2 + 1 
2565 .. 00			db "C@",0              
2568				endm 
# End of macro CWHEAD
2568			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2568					if DEBUG_FORTH_WORDS_KEY 
2568						DMARK "CAA" 
2568 f5				push af  
2569 3a 7d 25			ld a, (.dmark)  
256c 32 71 ee			ld (debug_mark),a  
256f 3a 7e 25			ld a, (.dmark+1)  
2572 32 72 ee			ld (debug_mark+1),a  
2575 3a 7f 25			ld a, (.dmark+2)  
2578 32 73 ee			ld (debug_mark+2),a  
257b 18 03			jr .pastdmark  
257d ..			.dmark: db "CAA"  
2580 f1			.pastdmark: pop af  
2581			endm  
# End of macro DMARK
2581						CALLMONITOR 
2581 cd e8 15			call break_point_state  
2584				endm  
# End of macro CALLMONITOR
2584					endif 
2584 c3 51 25				jp .getbyteat 
2587					NEXTW 
2587 c3 0b 20			jp macro_next 
258a				endm 
# End of macro NEXTW
258a			.BANG: 
258a				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
258a 21				db WORD_SYS_CORE+OPCODE_BANG             
258b c0 25			dw .CBANG            
258d 02				db 1 + 1 
258e .. 00			db "!",0              
2590				endm 
# End of macro CWHEAD
2590			; | ! ( x w -- ) Store x at address w      | DONE 
2590					if DEBUG_FORTH_WORDS_KEY 
2590						DMARK "BNG" 
2590 f5				push af  
2591 3a a5 25			ld a, (.dmark)  
2594 32 71 ee			ld (debug_mark),a  
2597 3a a6 25			ld a, (.dmark+1)  
259a 32 72 ee			ld (debug_mark+1),a  
259d 3a a7 25			ld a, (.dmark+2)  
25a0 32 73 ee			ld (debug_mark+2),a  
25a3 18 03			jr .pastdmark  
25a5 ..			.dmark: db "BNG"  
25a8 f1			.pastdmark: pop af  
25a9			endm  
# End of macro DMARK
25a9						CALLMONITOR 
25a9 cd e8 15			call break_point_state  
25ac				endm  
# End of macro CALLMONITOR
25ac					endif 
25ac			 
25ac			.storebyteat:		 
25ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ac cd 55 1e			call macro_dsp_valuehl 
25af				endm 
# End of macro FORTH_DSP_VALUEHL
25af					 
25af e5					push hl 
25b0				 
25b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25b0 cd 0d 1f			call macro_forth_dsp_pop 
25b3				endm 
# End of macro FORTH_DSP_POP
25b3			 
25b3					; get byte to poke 
25b3			 
25b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b3 cd 55 1e			call macro_dsp_valuehl 
25b6				endm 
# End of macro FORTH_DSP_VALUEHL
25b6 e5					push hl 
25b7			 
25b7			 
25b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25b7 cd 0d 1f			call macro_forth_dsp_pop 
25ba				endm 
# End of macro FORTH_DSP_POP
25ba			 
25ba			 
25ba d1					pop de 
25bb e1					pop hl 
25bc			 
25bc 73					ld (hl),e 
25bd			 
25bd			 
25bd					NEXTW 
25bd c3 0b 20			jp macro_next 
25c0				endm 
# End of macro NEXTW
25c0			.CBANG: 
25c0				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25c0 22				db WORD_SYS_CORE+OPCODE_CBANG             
25c1 e9 25			dw .SCALL            
25c3 03				db 2 + 1 
25c4 .. 00			db "C!",0              
25c7				endm 
# End of macro CWHEAD
25c7			; | C!  ( x w -- ) Store x at address w  | DONE 
25c7					if DEBUG_FORTH_WORDS_KEY 
25c7						DMARK "CBA" 
25c7 f5				push af  
25c8 3a dc 25			ld a, (.dmark)  
25cb 32 71 ee			ld (debug_mark),a  
25ce 3a dd 25			ld a, (.dmark+1)  
25d1 32 72 ee			ld (debug_mark+1),a  
25d4 3a de 25			ld a, (.dmark+2)  
25d7 32 73 ee			ld (debug_mark+2),a  
25da 18 03			jr .pastdmark  
25dc ..			.dmark: db "CBA"  
25df f1			.pastdmark: pop af  
25e0			endm  
# End of macro DMARK
25e0						CALLMONITOR 
25e0 cd e8 15			call break_point_state  
25e3				endm  
# End of macro CALLMONITOR
25e3					endif 
25e3 c3 ac 25				jp .storebyteat 
25e6					NEXTW 
25e6 c3 0b 20			jp macro_next 
25e9				endm 
# End of macro NEXTW
25e9			.SCALL: 
25e9				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25e9 23				db WORD_SYS_CORE+OPCODE_SCALL             
25ea 1d 26			dw .DEPTH            
25ec 05				db 4 + 1 
25ed .. 00			db "CALL",0              
25f2				endm 
# End of macro CWHEAD
25f2			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25f2					if DEBUG_FORTH_WORDS_KEY 
25f2						DMARK "CLL" 
25f2 f5				push af  
25f3 3a 07 26			ld a, (.dmark)  
25f6 32 71 ee			ld (debug_mark),a  
25f9 3a 08 26			ld a, (.dmark+1)  
25fc 32 72 ee			ld (debug_mark+1),a  
25ff 3a 09 26			ld a, (.dmark+2)  
2602 32 73 ee			ld (debug_mark+2),a  
2605 18 03			jr .pastdmark  
2607 ..			.dmark: db "CLL"  
260a f1			.pastdmark: pop af  
260b			endm  
# End of macro DMARK
260b						CALLMONITOR 
260b cd e8 15			call break_point_state  
260e				endm  
# End of macro CALLMONITOR
260e					endif 
260e			 
260e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260e cd 55 1e			call macro_dsp_valuehl 
2611				endm 
# End of macro FORTH_DSP_VALUEHL
2611			 
2611			;		push hl 
2611			 
2611					; destroy value TOS 
2611			 
2611					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2611 cd 0d 1f			call macro_forth_dsp_pop 
2614				endm 
# End of macro FORTH_DSP_POP
2614			 
2614						 
2614			;		pop hl 
2614			 
2614					; how to do a call with hl???? save SP? 
2614 cd af 1f				call forth_call_hl 
2617			 
2617			 
2617					; TODO push value back onto stack for another op etc 
2617			 
2617 cd 5e 1c				call forth_push_numhl 
261a					NEXTW 
261a c3 0b 20			jp macro_next 
261d				endm 
# End of macro NEXTW
261d			.DEPTH: 
261d				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
261d 24				db WORD_SYS_CORE+OPCODE_DEPTH             
261e 5a 26			dw .OVER            
2620 06				db 5 + 1 
2621 .. 00			db "DEPTH",0              
2627				endm 
# End of macro CWHEAD
2627			; | DEPTH ( -- u ) Push count of stack | DONE 
2627					; take current TOS and remove from base value div by two to get count 
2627					if DEBUG_FORTH_WORDS_KEY 
2627						DMARK "DEP" 
2627 f5				push af  
2628 3a 3c 26			ld a, (.dmark)  
262b 32 71 ee			ld (debug_mark),a  
262e 3a 3d 26			ld a, (.dmark+1)  
2631 32 72 ee			ld (debug_mark+1),a  
2634 3a 3e 26			ld a, (.dmark+2)  
2637 32 73 ee			ld (debug_mark+2),a  
263a 18 03			jr .pastdmark  
263c ..			.dmark: db "DEP"  
263f f1			.pastdmark: pop af  
2640			endm  
# End of macro DMARK
2640						CALLMONITOR 
2640 cd e8 15			call break_point_state  
2643				endm  
# End of macro CALLMONITOR
2643					endif 
2643			 
2643			 
2643 2a f4 e9			ld hl, (cli_data_sp) 
2646 11 2e e8			ld de, cli_data_stack 
2649 ed 52			sbc hl,de 
264b				 
264b				; div by size of stack item 
264b			 
264b 5d				ld e,l 
264c 0e 03			ld c, 3 
264e cd 77 0d			call Div8 
2651			 
2651 6f				ld l,a 
2652 26 00			ld h,0 
2654			 
2654				;srl h 
2654				;rr l 
2654			 
2654 cd 5e 1c				call forth_push_numhl 
2657					NEXTW 
2657 c3 0b 20			jp macro_next 
265a				endm 
# End of macro NEXTW
265a			.OVER: 
265a				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
265a 42				db WORD_SYS_CORE+46             
265b a1 26			dw .PAUSE            
265d 05				db 4 + 1 
265e .. 00			db "OVER",0              
2663				endm 
# End of macro CWHEAD
2663			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2663					if DEBUG_FORTH_WORDS_KEY 
2663						DMARK "OVR" 
2663 f5				push af  
2664 3a 78 26			ld a, (.dmark)  
2667 32 71 ee			ld (debug_mark),a  
266a 3a 79 26			ld a, (.dmark+1)  
266d 32 72 ee			ld (debug_mark+1),a  
2670 3a 7a 26			ld a, (.dmark+2)  
2673 32 73 ee			ld (debug_mark+2),a  
2676 18 03			jr .pastdmark  
2678 ..			.dmark: db "OVR"  
267b f1			.pastdmark: pop af  
267c			endm  
# End of macro DMARK
267c						CALLMONITOR 
267c cd e8 15			call break_point_state  
267f				endm  
# End of macro CALLMONITOR
267f					endif 
267f			 
267f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267f cd 55 1e			call macro_dsp_valuehl 
2682				endm 
# End of macro FORTH_DSP_VALUEHL
2682 e5					push hl    ; n2 
2683					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2683 cd 0d 1f			call macro_forth_dsp_pop 
2686				endm 
# End of macro FORTH_DSP_POP
2686			 
2686					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2686 cd 55 1e			call macro_dsp_valuehl 
2689				endm 
# End of macro FORTH_DSP_VALUEHL
2689 e5					push hl    ; n1 
268a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
268a cd 0d 1f			call macro_forth_dsp_pop 
268d				endm 
# End of macro FORTH_DSP_POP
268d			 
268d d1					pop de     ; n1 
268e e1					pop hl     ; n2 
268f			 
268f d5					push de 
2690 e5					push hl 
2691 d5					push de 
2692			 
2692					; push back  
2692			 
2692 e1					pop hl 
2693 cd 5e 1c				call forth_push_numhl 
2696 e1					pop hl 
2697 cd 5e 1c				call forth_push_numhl 
269a e1					pop hl 
269b cd 5e 1c				call forth_push_numhl 
269e					NEXTW 
269e c3 0b 20			jp macro_next 
26a1				endm 
# End of macro NEXTW
26a1			 
26a1			.PAUSE: 
26a1				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26a1 43				db WORD_SYS_CORE+47             
26a2 d6 26			dw .PAUSES            
26a4 08				db 7 + 1 
26a5 .. 00			db "PAUSEMS",0              
26ad				endm 
# End of macro CWHEAD
26ad			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26ad					if DEBUG_FORTH_WORDS_KEY 
26ad						DMARK "PMS" 
26ad f5				push af  
26ae 3a c2 26			ld a, (.dmark)  
26b1 32 71 ee			ld (debug_mark),a  
26b4 3a c3 26			ld a, (.dmark+1)  
26b7 32 72 ee			ld (debug_mark+1),a  
26ba 3a c4 26			ld a, (.dmark+2)  
26bd 32 73 ee			ld (debug_mark+2),a  
26c0 18 03			jr .pastdmark  
26c2 ..			.dmark: db "PMS"  
26c5 f1			.pastdmark: pop af  
26c6			endm  
# End of macro DMARK
26c6						CALLMONITOR 
26c6 cd e8 15			call break_point_state  
26c9				endm  
# End of macro CALLMONITOR
26c9					endif 
26c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c9 cd 55 1e			call macro_dsp_valuehl 
26cc				endm 
# End of macro FORTH_DSP_VALUEHL
26cc			;		push hl    ; n2 
26cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26cc cd 0d 1f			call macro_forth_dsp_pop 
26cf				endm 
# End of macro FORTH_DSP_POP
26cf			;		pop hl 
26cf			 
26cf 7d					ld a, l 
26d0 cd d7 0a				call aDelayInMS 
26d3				       NEXTW 
26d3 c3 0b 20			jp macro_next 
26d6				endm 
# End of macro NEXTW
26d6			.PAUSES:  
26d6				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26d6 44				db WORD_SYS_CORE+48             
26d7 45 27			dw .ROT            
26d9 06				db 5 + 1 
26da .. 00			db "PAUSE",0              
26e0				endm 
# End of macro CWHEAD
26e0			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26e0					if DEBUG_FORTH_WORDS_KEY 
26e0						DMARK "PAU" 
26e0 f5				push af  
26e1 3a f5 26			ld a, (.dmark)  
26e4 32 71 ee			ld (debug_mark),a  
26e7 3a f6 26			ld a, (.dmark+1)  
26ea 32 72 ee			ld (debug_mark+1),a  
26ed 3a f7 26			ld a, (.dmark+2)  
26f0 32 73 ee			ld (debug_mark+2),a  
26f3 18 03			jr .pastdmark  
26f5 ..			.dmark: db "PAU"  
26f8 f1			.pastdmark: pop af  
26f9			endm  
# End of macro DMARK
26f9						CALLMONITOR 
26f9 cd e8 15			call break_point_state  
26fc				endm  
# End of macro CALLMONITOR
26fc					endif 
26fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26fc cd 55 1e			call macro_dsp_valuehl 
26ff				endm 
# End of macro FORTH_DSP_VALUEHL
26ff			;		push hl    ; n2 
26ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ff cd 0d 1f			call macro_forth_dsp_pop 
2702				endm 
# End of macro FORTH_DSP_POP
2702			;		pop hl 
2702 45					ld b, l 
2703					if DEBUG_FORTH_WORDS 
2703						DMARK "PAU" 
2703 f5				push af  
2704 3a 18 27			ld a, (.dmark)  
2707 32 71 ee			ld (debug_mark),a  
270a 3a 19 27			ld a, (.dmark+1)  
270d 32 72 ee			ld (debug_mark+1),a  
2710 3a 1a 27			ld a, (.dmark+2)  
2713 32 73 ee			ld (debug_mark+2),a  
2716 18 03			jr .pastdmark  
2718 ..			.dmark: db "PAU"  
271b f1			.pastdmark: pop af  
271c			endm  
# End of macro DMARK
271c						CALLMONITOR 
271c cd e8 15			call break_point_state  
271f				endm  
# End of macro CALLMONITOR
271f					endif 
271f c5			.pauses1:	push bc 
2720 cd f2 0a				call delay1s 
2723 c1					pop bc 
2724					if DEBUG_FORTH_WORDS 
2724						DMARK "PA1" 
2724 f5				push af  
2725 3a 39 27			ld a, (.dmark)  
2728 32 71 ee			ld (debug_mark),a  
272b 3a 3a 27			ld a, (.dmark+1)  
272e 32 72 ee			ld (debug_mark+1),a  
2731 3a 3b 27			ld a, (.dmark+2)  
2734 32 73 ee			ld (debug_mark+2),a  
2737 18 03			jr .pastdmark  
2739 ..			.dmark: db "PA1"  
273c f1			.pastdmark: pop af  
273d			endm  
# End of macro DMARK
273d						CALLMONITOR 
273d cd e8 15			call break_point_state  
2740				endm  
# End of macro CALLMONITOR
2740					endif 
2740 10 dd				djnz .pauses1 
2742			 
2742				       NEXTW 
2742 c3 0b 20			jp macro_next 
2745				endm 
# End of macro NEXTW
2745			.ROT: 
2745				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2745 45				db WORD_SYS_CORE+49             
2746 93 27			dw .UWORDS            
2748 04				db 3 + 1 
2749 .. 00			db "ROT",0              
274d				endm 
# End of macro CWHEAD
274d			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
274d					if DEBUG_FORTH_WORDS_KEY 
274d						DMARK "ROT" 
274d f5				push af  
274e 3a 62 27			ld a, (.dmark)  
2751 32 71 ee			ld (debug_mark),a  
2754 3a 63 27			ld a, (.dmark+1)  
2757 32 72 ee			ld (debug_mark+1),a  
275a 3a 64 27			ld a, (.dmark+2)  
275d 32 73 ee			ld (debug_mark+2),a  
2760 18 03			jr .pastdmark  
2762 ..			.dmark: db "ROT"  
2765 f1			.pastdmark: pop af  
2766			endm  
# End of macro DMARK
2766						CALLMONITOR 
2766 cd e8 15			call break_point_state  
2769				endm  
# End of macro CALLMONITOR
2769					endif 
2769			 
2769					FORTH_DSP_VALUEHL 
2769 cd 55 1e			call macro_dsp_valuehl 
276c				endm 
# End of macro FORTH_DSP_VALUEHL
276c e5					push hl    ; u3  
276d			 
276d					FORTH_DSP_POP 
276d cd 0d 1f			call macro_forth_dsp_pop 
2770				endm 
# End of macro FORTH_DSP_POP
2770			   
2770					FORTH_DSP_VALUEHL 
2770 cd 55 1e			call macro_dsp_valuehl 
2773				endm 
# End of macro FORTH_DSP_VALUEHL
2773 e5					push hl     ; u2 
2774			 
2774					FORTH_DSP_POP 
2774 cd 0d 1f			call macro_forth_dsp_pop 
2777				endm 
# End of macro FORTH_DSP_POP
2777			 
2777					FORTH_DSP_VALUEHL 
2777 cd 55 1e			call macro_dsp_valuehl 
277a				endm 
# End of macro FORTH_DSP_VALUEHL
277a e5					push hl     ; u1 
277b			 
277b					FORTH_DSP_POP 
277b cd 0d 1f			call macro_forth_dsp_pop 
277e				endm 
# End of macro FORTH_DSP_POP
277e			 
277e c1					pop bc      ; u1 
277f e1					pop hl      ; u2 
2780 d1					pop de      ; u3 
2781			 
2781			 
2781 c5					push bc 
2782 d5					push de 
2783 e5					push hl 
2784			 
2784			 
2784 e1					pop hl 
2785 cd 5e 1c				call forth_push_numhl 
2788			 
2788 e1					pop hl 
2789 cd 5e 1c				call forth_push_numhl 
278c			 
278c e1					pop hl 
278d cd 5e 1c				call forth_push_numhl 
2790					 
2790			 
2790			 
2790			 
2790			 
2790			 
2790				       NEXTW 
2790 c3 0b 20			jp macro_next 
2793				endm 
# End of macro NEXTW
2793			 
2793			.UWORDS: 
2793				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2793 50				db WORD_SYS_CORE+60             
2794 55 28			dw .BP            
2796 07				db 6 + 1 
2797 .. 00			db "UWORDS",0              
279e				endm 
# End of macro CWHEAD
279e			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
279e			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
279e			; | | Following the count are the individual words. 
279e			; | | 
279e			; | | e.g. UWORDS 
279e			; | | BOX DIRLIST 2 
279e			; | |  
279e			; | | Can be used to save the words to storage via: 
279e			; | | UWORDS $01 DO $01 APPEND LOOP 
279e				if DEBUG_FORTH_WORDS_KEY 
279e					DMARK "UWR" 
279e f5				push af  
279f 3a b3 27			ld a, (.dmark)  
27a2 32 71 ee			ld (debug_mark),a  
27a5 3a b4 27			ld a, (.dmark+1)  
27a8 32 72 ee			ld (debug_mark+1),a  
27ab 3a b5 27			ld a, (.dmark+2)  
27ae 32 73 ee			ld (debug_mark+2),a  
27b1 18 03			jr .pastdmark  
27b3 ..			.dmark: db "UWR"  
27b6 f1			.pastdmark: pop af  
27b7			endm  
# End of macro DMARK
27b7					CALLMONITOR 
27b7 cd e8 15			call break_point_state  
27ba				endm  
# End of macro CALLMONITOR
27ba				endif 
27ba 21 b8 64				ld hl, baseram 
27bd					;ld hl, baseusermem 
27bd 01 00 00				ld bc, 0    ; start a counter 
27c0			 
27c0				; skip dict stub 
27c0			 
27c0 cd 5c 21				call forth_tok_next 
27c3			 
27c3			 
27c3			; while we have words to look for 
27c3			 
27c3 7e			.douscan:	ld a, (hl)      
27c4				if DEBUG_FORTH_WORDS 
27c4					DMARK "UWs" 
27c4 f5				push af  
27c5 3a d9 27			ld a, (.dmark)  
27c8 32 71 ee			ld (debug_mark),a  
27cb 3a da 27			ld a, (.dmark+1)  
27ce 32 72 ee			ld (debug_mark+1),a  
27d1 3a db 27			ld a, (.dmark+2)  
27d4 32 73 ee			ld (debug_mark+2),a  
27d7 18 03			jr .pastdmark  
27d9 ..			.dmark: db "UWs"  
27dc f1			.pastdmark: pop af  
27dd			endm  
# End of macro DMARK
27dd					CALLMONITOR 
27dd cd e8 15			call break_point_state  
27e0				endm  
# End of macro CALLMONITOR
27e0				endif 
27e0 fe 00				cp WORD_SYS_END 
27e2 28 4d				jr z, .udone 
27e4 fe 01				cp WORD_SYS_UWORD 
27e6 20 44				jr nz, .nuword 
27e8			 
27e8				if DEBUG_FORTH_WORDS 
27e8					DMARK "UWu" 
27e8 f5				push af  
27e9 3a fd 27			ld a, (.dmark)  
27ec 32 71 ee			ld (debug_mark),a  
27ef 3a fe 27			ld a, (.dmark+1)  
27f2 32 72 ee			ld (debug_mark+1),a  
27f5 3a ff 27			ld a, (.dmark+2)  
27f8 32 73 ee			ld (debug_mark+2),a  
27fb 18 03			jr .pastdmark  
27fd ..			.dmark: db "UWu"  
2800 f1			.pastdmark: pop af  
2801			endm  
# End of macro DMARK
2801					CALLMONITOR 
2801 cd e8 15			call break_point_state  
2804				endm  
# End of macro CALLMONITOR
2804				endif 
2804					; we have a uword so push its name to the stack 
2804			 
2804 e5				   	push hl  ; save so we can move to next dict block 
2805			 
2805					; skip opcode 
2805 23					inc hl  
2806					; skip next ptr 
2806 23					inc hl  
2807 23					inc hl 
2808					; skip len 
2808 23					inc hl 
2809				if DEBUG_FORTH_WORDS 
2809					DMARK "UWt" 
2809 f5				push af  
280a 3a 1e 28			ld a, (.dmark)  
280d 32 71 ee			ld (debug_mark),a  
2810 3a 1f 28			ld a, (.dmark+1)  
2813 32 72 ee			ld (debug_mark+1),a  
2816 3a 20 28			ld a, (.dmark+2)  
2819 32 73 ee			ld (debug_mark+2),a  
281c 18 03			jr .pastdmark  
281e ..			.dmark: db "UWt"  
2821 f1			.pastdmark: pop af  
2822			endm  
# End of macro DMARK
2822					CALLMONITOR 
2822 cd e8 15			call break_point_state  
2825				endm  
# End of macro CALLMONITOR
2825				endif 
2825 03					inc bc 
2826			 
2826 c5					push bc 
2827 cd cc 1c				call forth_push_str 
282a c1					pop bc 
282b			 
282b e1					pop hl 	 
282c			 
282c cd 5c 21		.nuword:	call forth_tok_next 
282f 18 92				jr .douscan  
2831			 
2831			.udone:		 ; push count of uwords found 
2831 c5					push bc 
2832 e1					pop hl 
2833			 
2833				if DEBUG_FORTH_WORDS 
2833					DMARK "UWc" 
2833 f5				push af  
2834 3a 48 28			ld a, (.dmark)  
2837 32 71 ee			ld (debug_mark),a  
283a 3a 49 28			ld a, (.dmark+1)  
283d 32 72 ee			ld (debug_mark+1),a  
2840 3a 4a 28			ld a, (.dmark+2)  
2843 32 73 ee			ld (debug_mark+2),a  
2846 18 03			jr .pastdmark  
2848 ..			.dmark: db "UWc"  
284b f1			.pastdmark: pop af  
284c			endm  
# End of macro DMARK
284c					CALLMONITOR 
284c cd e8 15			call break_point_state  
284f				endm  
# End of macro CALLMONITOR
284f				endif 
284f cd 5e 1c				call forth_push_numhl 
2852			 
2852			 
2852				       NEXTW 
2852 c3 0b 20			jp macro_next 
2855				endm 
# End of macro NEXTW
2855			 
2855			.BP: 
2855				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2855 54				db WORD_SYS_CORE+64             
2856 8b 28			dw .MONITOR            
2858 03				db 2 + 1 
2859 .. 00			db "BP",0              
285c				endm 
# End of macro CWHEAD
285c			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
285c			; | | $00 Will enable the break points within specific code paths 
285c			; | | $01 Will disable break points 
285c			; | |  
285c			; | | By default break points are off. Either the above can be used to enable them 
285c			; | | or if a key is held down during start up the spashscreen will appear to freeze 
285c			; | | and on release of the pressed key a message will be disaplayed to notify 
285c			; | | that break points are enabled. Pressing any key will then continue boot process. 
285c					; get byte count 
285c					if DEBUG_FORTH_WORDS_KEY 
285c						DMARK "BP." 
285c f5				push af  
285d 3a 71 28			ld a, (.dmark)  
2860 32 71 ee			ld (debug_mark),a  
2863 3a 72 28			ld a, (.dmark+1)  
2866 32 72 ee			ld (debug_mark+1),a  
2869 3a 73 28			ld a, (.dmark+2)  
286c 32 73 ee			ld (debug_mark+2),a  
286f 18 03			jr .pastdmark  
2871 ..			.dmark: db "BP."  
2874 f1			.pastdmark: pop af  
2875			endm  
# End of macro DMARK
2875						CALLMONITOR 
2875 cd e8 15			call break_point_state  
2878				endm  
# End of macro CALLMONITOR
2878					endif 
2878			 
2878					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2878 cd 55 1e			call macro_dsp_valuehl 
287b				endm 
# End of macro FORTH_DSP_VALUEHL
287b			 
287b			;		push hl 
287b			 
287b					; destroy value TOS 
287b			 
287b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
287b cd 0d 1f			call macro_forth_dsp_pop 
287e				endm 
# End of macro FORTH_DSP_POP
287e			 
287e			;		pop hl 
287e			 
287e 3e 00				ld a,0 
2880 bd					cp l 
2881 28 02				jr z, .bpset 
2883 3e 2a				ld a, '*' 
2885			 
2885 32 b8 e2		.bpset:		ld (os_view_disable), a 
2888			 
2888			 
2888					NEXTW 
2888 c3 0b 20			jp macro_next 
288b				endm 
# End of macro NEXTW
288b			 
288b			 
288b			.MONITOR: 
288b				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
288b 55				db WORD_SYS_CORE+65             
288c be 28			dw .MALLOC            
288e 08				db 7 + 1 
288f .. 00			db "MONITOR",0              
2897				endm 
# End of macro CWHEAD
2897			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2897			; | | At start the current various registers will be displayed with contents. 
2897			; | | Top right corner will show the most recent debug marker seen. 
2897			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2897			; | | and the return stack pointer (RSP). 
2897			; | | Pressing: 
2897			; | |    1 - Initial screen 
2897			; | |    2 - Display a data dump of HL 
2897			; | |    3 - Display a data dump of DE 
2897			; | |    4 - Display a data dump of BC 
2897			; | |    5 - Display a data dump of HL 
2897			; | |    6 - Display a data dump of DSP 
2897			; | |    7 - Display a data dump of RSP 
2897			; | |    8 - Display a data dump of what is at DSP 
2897			; | |    9 - Display a data dump of what is at RSP 
2897			; | |    0 - Exit monitor and continue running. This will also enable break points 
2897			; | |    * - Disable break points 
2897			; | |    # - Enter traditional monitor mode 
2897			; | | 
2897			; | | Monitor Mode 
2897			; | | ------------ 
2897			; | | A prompt of '>' will be shown for various commands: 
2897			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2897			; | |    C - Continue display a data dump from the last set address 
2897			; | |    M xxxx - Set start of memory edit at address xx 
2897			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2897			; | |    Q - Return to previous 
2897					if DEBUG_FORTH_WORDS_KEY 
2897						DMARK "MON" 
2897 f5				push af  
2898 3a ac 28			ld a, (.dmark)  
289b 32 71 ee			ld (debug_mark),a  
289e 3a ad 28			ld a, (.dmark+1)  
28a1 32 72 ee			ld (debug_mark+1),a  
28a4 3a ae 28			ld a, (.dmark+2)  
28a7 32 73 ee			ld (debug_mark+2),a  
28aa 18 03			jr .pastdmark  
28ac ..			.dmark: db "MON"  
28af f1			.pastdmark: pop af  
28b0			endm  
# End of macro DMARK
28b0						CALLMONITOR 
28b0 cd e8 15			call break_point_state  
28b3				endm  
# End of macro CALLMONITOR
28b3					endif 
28b3 3e 00				ld a, 0 
28b5 32 b8 e2				ld (os_view_disable), a 
28b8			 
28b8					CALLMONITOR 
28b8 cd e8 15			call break_point_state  
28bb				endm  
# End of macro CALLMONITOR
28bb			 
28bb			;	call monitor 
28bb			 
28bb					NEXTW 
28bb c3 0b 20			jp macro_next 
28be				endm 
# End of macro NEXTW
28be			 
28be			 
28be			.MALLOC: 
28be				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28be 56				db WORD_SYS_CORE+66             
28bf e7 28			dw .MALLOC2            
28c1 06				db 5 + 1 
28c2 .. 00			db "ALLOT",0              
28c8				endm 
# End of macro CWHEAD
28c8			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28c8					if DEBUG_FORTH_WORDS_KEY 
28c8						DMARK "ALL" 
28c8 f5				push af  
28c9 3a dd 28			ld a, (.dmark)  
28cc 32 71 ee			ld (debug_mark),a  
28cf 3a de 28			ld a, (.dmark+1)  
28d2 32 72 ee			ld (debug_mark+1),a  
28d5 3a df 28			ld a, (.dmark+2)  
28d8 32 73 ee			ld (debug_mark+2),a  
28db 18 03			jr .pastdmark  
28dd ..			.dmark: db "ALL"  
28e0 f1			.pastdmark: pop af  
28e1			endm  
# End of macro DMARK
28e1						CALLMONITOR 
28e1 cd e8 15			call break_point_state  
28e4				endm  
# End of macro CALLMONITOR
28e4					endif 
28e4 c3 0e 29				jp .mallocc 
28e7			.MALLOC2: 
28e7				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28e7 56				db WORD_SYS_CORE+66             
28e8 25 29			dw .FREE            
28ea 07				db 6 + 1 
28eb .. 00			db "MALLOC",0              
28f2				endm 
# End of macro CWHEAD
28f2			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28f2					; get byte count 
28f2					if DEBUG_FORTH_WORDS_KEY 
28f2						DMARK "MAL" 
28f2 f5				push af  
28f3 3a 07 29			ld a, (.dmark)  
28f6 32 71 ee			ld (debug_mark),a  
28f9 3a 08 29			ld a, (.dmark+1)  
28fc 32 72 ee			ld (debug_mark+1),a  
28ff 3a 09 29			ld a, (.dmark+2)  
2902 32 73 ee			ld (debug_mark+2),a  
2905 18 03			jr .pastdmark  
2907 ..			.dmark: db "MAL"  
290a f1			.pastdmark: pop af  
290b			endm  
# End of macro DMARK
290b						CALLMONITOR 
290b cd e8 15			call break_point_state  
290e				endm  
# End of macro CALLMONITOR
290e					endif 
290e			.mallocc: 
290e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
290e cd 55 1e			call macro_dsp_valuehl 
2911				endm 
# End of macro FORTH_DSP_VALUEHL
2911			 
2911			;		push hl 
2911			 
2911					; destroy value TOS 
2911			 
2911					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2911 cd 0d 1f			call macro_forth_dsp_pop 
2914				endm 
# End of macro FORTH_DSP_POP
2914			 
2914			;		pop hl 
2914 cd ae 12				call malloc 
2917				if DEBUG_FORTH_MALLOC_GUARD 
2917 f5					push af 
2918 cd 10 0e				call ishlzero 
291b			;		ld a, l 
291b			;		add h 
291b			;		cp 0 
291b f1					pop af 
291c					 
291c cc 16 4d				call z,malloc_error 
291f				endif 
291f			 
291f cd 5e 1c				call forth_push_numhl 
2922					NEXTW 
2922 c3 0b 20			jp macro_next 
2925				endm 
# End of macro NEXTW
2925			 
2925			.FREE: 
2925				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2925 57				db WORD_SYS_CORE+67             
2926 56 29			dw .LIST            
2928 05				db 4 + 1 
2929 .. 00			db "FREE",0              
292e				endm 
# End of macro CWHEAD
292e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
292e					if DEBUG_FORTH_WORDS_KEY 
292e						DMARK "FRE" 
292e f5				push af  
292f 3a 43 29			ld a, (.dmark)  
2932 32 71 ee			ld (debug_mark),a  
2935 3a 44 29			ld a, (.dmark+1)  
2938 32 72 ee			ld (debug_mark+1),a  
293b 3a 45 29			ld a, (.dmark+2)  
293e 32 73 ee			ld (debug_mark+2),a  
2941 18 03			jr .pastdmark  
2943 ..			.dmark: db "FRE"  
2946 f1			.pastdmark: pop af  
2947			endm  
# End of macro DMARK
2947						CALLMONITOR 
2947 cd e8 15			call break_point_state  
294a				endm  
# End of macro CALLMONITOR
294a					endif 
294a					; get address 
294a			 
294a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
294a cd 55 1e			call macro_dsp_valuehl 
294d				endm 
# End of macro FORTH_DSP_VALUEHL
294d			 
294d			;		push hl 
294d			 
294d					; destroy value TOS 
294d			 
294d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
294d cd 0d 1f			call macro_forth_dsp_pop 
2950				endm 
# End of macro FORTH_DSP_POP
2950			 
2950			;		pop hl 
2950			if FORTH_ENABLE_MALLOCFREE 
2950 cd 78 13				call free 
2953			endif 
2953					NEXTW 
2953 c3 0b 20			jp macro_next 
2956				endm 
# End of macro NEXTW
2956			.LIST: 
2956				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2956 5c				db WORD_SYS_CORE+72             
2957 44 2b			dw .FORGET            
2959 05				db 4 + 1 
295a .. 00			db "LIST",0              
295f				endm 
# End of macro CWHEAD
295f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
295f			; | | The quoted word must be in upper case. 
295f				if DEBUG_FORTH_WORDS_KEY 
295f					DMARK "LST" 
295f f5				push af  
2960 3a 74 29			ld a, (.dmark)  
2963 32 71 ee			ld (debug_mark),a  
2966 3a 75 29			ld a, (.dmark+1)  
2969 32 72 ee			ld (debug_mark+1),a  
296c 3a 76 29			ld a, (.dmark+2)  
296f 32 73 ee			ld (debug_mark+2),a  
2972 18 03			jr .pastdmark  
2974 ..			.dmark: db "LST"  
2977 f1			.pastdmark: pop af  
2978			endm  
# End of macro DMARK
2978					CALLMONITOR 
2978 cd e8 15			call break_point_state  
297b				endm  
# End of macro CALLMONITOR
297b				endif 
297b			 
297b					FORTH_DSP_VALUEHL 
297b cd 55 1e			call macro_dsp_valuehl 
297e				endm 
# End of macro FORTH_DSP_VALUEHL
297e			 
297e e5					push hl 
297f					FORTH_DSP_POP 
297f cd 0d 1f			call macro_forth_dsp_pop 
2982				endm 
# End of macro FORTH_DSP_POP
2982 c1					pop bc 
2983			 
2983			; Start format of scratch string 
2983			 
2983 21 c7 e2				ld hl, scratch 
2986			 
2986 3e 3a				ld a, ':' 
2988 77					ld (hl),a 
2989 23					inc hl 
298a 3e 20				ld a, ' ' 
298c 77					ld (hl), a 
298d			 
298d					; Get ptr to the word we need to look up 
298d			 
298d			;		FORTH_DSP_VALUEHL 
298d					;v5 FORTH_DSP_VALUE 
298d				; TODO type check 
298d			;		inc hl    ; Skip type check  
298d			;		push hl 
298d			;		ex de, hl    ; put into DE 
298d			 
298d			 
298d 21 b8 64				ld hl, baseram 
2990					;ld hl, baseusermem 
2990			 
2990 e5			push hl   ; sacreifical push 
2991			 
2991			.ldouscanm: 
2991 e1				pop hl 
2992			.ldouscan: 
2992				if DEBUG_FORTH_WORDS 
2992					DMARK "LSs" 
2992 f5				push af  
2993 3a a7 29			ld a, (.dmark)  
2996 32 71 ee			ld (debug_mark),a  
2999 3a a8 29			ld a, (.dmark+1)  
299c 32 72 ee			ld (debug_mark+1),a  
299f 3a a9 29			ld a, (.dmark+2)  
29a2 32 73 ee			ld (debug_mark+2),a  
29a5 18 03			jr .pastdmark  
29a7 ..			.dmark: db "LSs"  
29aa f1			.pastdmark: pop af  
29ab			endm  
# End of macro DMARK
29ab					CALLMONITOR 
29ab cd e8 15			call break_point_state  
29ae				endm  
# End of macro CALLMONITOR
29ae				endif 
29ae				; skip dict stub 
29ae cd 5c 21				call forth_tok_next 
29b1			 
29b1			 
29b1			; while we have words to look for 
29b1			 
29b1 7e				ld a, (hl)      
29b2				if DEBUG_FORTH_WORDS 
29b2					DMARK "LSk" 
29b2 f5				push af  
29b3 3a c7 29			ld a, (.dmark)  
29b6 32 71 ee			ld (debug_mark),a  
29b9 3a c8 29			ld a, (.dmark+1)  
29bc 32 72 ee			ld (debug_mark+1),a  
29bf 3a c9 29			ld a, (.dmark+2)  
29c2 32 73 ee			ld (debug_mark+2),a  
29c5 18 03			jr .pastdmark  
29c7 ..			.dmark: db "LSk"  
29ca f1			.pastdmark: pop af  
29cb			endm  
# End of macro DMARK
29cb					CALLMONITOR 
29cb cd e8 15			call break_point_state  
29ce				endm  
# End of macro CALLMONITOR
29ce				endif 
29ce					;cp WORD_SYS_END 
29ce					;jp z, .lunotfound 
29ce			 
29ce					; if we hit non uwords then gone too far 
29ce fe 01				cp WORD_SYS_UWORD 
29d0 c2 00 2b				jp nz, .lunotfound 
29d3			 
29d3				if DEBUG_FORTH_WORDS 
29d3					DMARK "LSu" 
29d3 f5				push af  
29d4 3a e8 29			ld a, (.dmark)  
29d7 32 71 ee			ld (debug_mark),a  
29da 3a e9 29			ld a, (.dmark+1)  
29dd 32 72 ee			ld (debug_mark+1),a  
29e0 3a ea 29			ld a, (.dmark+2)  
29e3 32 73 ee			ld (debug_mark+2),a  
29e6 18 03			jr .pastdmark  
29e8 ..			.dmark: db "LSu"  
29eb f1			.pastdmark: pop af  
29ec			endm  
# End of macro DMARK
29ec					CALLMONITOR 
29ec cd e8 15			call break_point_state  
29ef				endm  
# End of macro CALLMONITOR
29ef				endif 
29ef			 
29ef					; found a uword but is it the one we want... 
29ef			 
29ef c5					push bc     ; uword to find is on bc 
29f0 d1					pop de 
29f1			 
29f1 e5					push hl  ; to save the ptr 
29f2			 
29f2					; skip opcode 
29f2 23					inc hl  
29f3					; skip next ptr 
29f3 23					inc hl  
29f4 23					inc hl 
29f5					; skip len 
29f5 23					inc hl 
29f6			 
29f6				if DEBUG_FORTH_WORDS 
29f6					DMARK "LSc" 
29f6 f5				push af  
29f7 3a 0b 2a			ld a, (.dmark)  
29fa 32 71 ee			ld (debug_mark),a  
29fd 3a 0c 2a			ld a, (.dmark+1)  
2a00 32 72 ee			ld (debug_mark+1),a  
2a03 3a 0d 2a			ld a, (.dmark+2)  
2a06 32 73 ee			ld (debug_mark+2),a  
2a09 18 03			jr .pastdmark  
2a0b ..			.dmark: db "LSc"  
2a0e f1			.pastdmark: pop af  
2a0f			endm  
# End of macro DMARK
2a0f					CALLMONITOR 
2a0f cd e8 15			call break_point_state  
2a12				endm  
# End of macro CALLMONITOR
2a12				endif 
2a12 cd 7d 12				call strcmp 
2a15 c2 91 29				jp nz, .ldouscanm 
2a18				 
2a18			 
2a18			 
2a18					; we have a uword so push its name to the stack 
2a18			 
2a18			;	   	push hl  ; save so we can move to next dict block 
2a18 e1			pop hl 
2a19			 
2a19				if DEBUG_FORTH_WORDS 
2a19					DMARK "LSm" 
2a19 f5				push af  
2a1a 3a 2e 2a			ld a, (.dmark)  
2a1d 32 71 ee			ld (debug_mark),a  
2a20 3a 2f 2a			ld a, (.dmark+1)  
2a23 32 72 ee			ld (debug_mark+1),a  
2a26 3a 30 2a			ld a, (.dmark+2)  
2a29 32 73 ee			ld (debug_mark+2),a  
2a2c 18 03			jr .pastdmark  
2a2e ..			.dmark: db "LSm"  
2a31 f1			.pastdmark: pop af  
2a32			endm  
# End of macro DMARK
2a32					CALLMONITOR 
2a32 cd e8 15			call break_point_state  
2a35				endm  
# End of macro CALLMONITOR
2a35				endif 
2a35			 
2a35					; skip opcode 
2a35 23					inc hl  
2a36					; skip next ptr 
2a36 23					inc hl  
2a37 23					inc hl 
2a38					; skip len 
2a38 7e					ld a, (hl)   ; save length to add 
2a39				if DEBUG_FORTH_WORDS 
2a39					DMARK "LS2" 
2a39 f5				push af  
2a3a 3a 4e 2a			ld a, (.dmark)  
2a3d 32 71 ee			ld (debug_mark),a  
2a40 3a 4f 2a			ld a, (.dmark+1)  
2a43 32 72 ee			ld (debug_mark+1),a  
2a46 3a 50 2a			ld a, (.dmark+2)  
2a49 32 73 ee			ld (debug_mark+2),a  
2a4c 18 03			jr .pastdmark  
2a4e ..			.dmark: db "LS2"  
2a51 f1			.pastdmark: pop af  
2a52			endm  
# End of macro DMARK
2a52					CALLMONITOR 
2a52 cd e8 15			call break_point_state  
2a55				endm  
# End of macro CALLMONITOR
2a55				endif 
2a55			 
2a55					; save this location 
2a55				 
2a55 e5					push hl 
2a56			 
2a56 23					inc hl 
2a57 11 c9 e2				ld de, scratch+2 
2a5a 4f					ld c, a 
2a5b 06 00				ld b, 0 
2a5d			 
2a5d				if DEBUG_FORTH_WORDS 
2a5d					DMARK "LSn" 
2a5d f5				push af  
2a5e 3a 72 2a			ld a, (.dmark)  
2a61 32 71 ee			ld (debug_mark),a  
2a64 3a 73 2a			ld a, (.dmark+1)  
2a67 32 72 ee			ld (debug_mark+1),a  
2a6a 3a 74 2a			ld a, (.dmark+2)  
2a6d 32 73 ee			ld (debug_mark+2),a  
2a70 18 03			jr .pastdmark  
2a72 ..			.dmark: db "LSn"  
2a75 f1			.pastdmark: pop af  
2a76			endm  
# End of macro DMARK
2a76					CALLMONITOR 
2a76 cd e8 15			call break_point_state  
2a79				endm  
# End of macro CALLMONITOR
2a79				endif 
2a79			 
2a79					; copy uword name to scratch 
2a79			 
2a79 ed b0				ldir 
2a7b			 
2a7b 1b					dec de 
2a7c 3e 20				ld a, ' '    ; change null to space 
2a7e 12					ld (de), a 
2a7f			 
2a7f 13					inc de 
2a80			 
2a80 d5					push de 
2a81 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a82			 
2a82 e1					pop hl 
2a83 7e					ld a, (hl) 
2a84					;inc hl 
2a84					; skip word string 
2a84 cd e7 0d				call addatohl 
2a87			 
2a87 23					inc hl 
2a88			 
2a88				if DEBUG_FORTH_WORDS 
2a88					DMARK "LS3" 
2a88 f5				push af  
2a89 3a 9d 2a			ld a, (.dmark)  
2a8c 32 71 ee			ld (debug_mark),a  
2a8f 3a 9e 2a			ld a, (.dmark+1)  
2a92 32 72 ee			ld (debug_mark+1),a  
2a95 3a 9f 2a			ld a, (.dmark+2)  
2a98 32 73 ee			ld (debug_mark+2),a  
2a9b 18 03			jr .pastdmark  
2a9d ..			.dmark: db "LS3"  
2aa0 f1			.pastdmark: pop af  
2aa1			endm  
# End of macro DMARK
2aa1					CALLMONITOR 
2aa1 cd e8 15			call break_point_state  
2aa4				endm  
# End of macro CALLMONITOR
2aa4				endif 
2aa4					; should now be at the start of the machine code to setup the eval of the uword 
2aa4					; now locate the ptr to the string defintion 
2aa4			 
2aa4					; skip ld hl, 
2aa4					; then load the ptr 
2aa4			; TODO use get from hl ptr 
2aa4 23					inc hl 
2aa5 5e					ld e, (hl) 
2aa6 23					inc hl 
2aa7 56					ld d, (hl) 
2aa8 eb					ex de, hl 
2aa9			 
2aa9			 
2aa9				if DEBUG_FORTH_WORDS 
2aa9					DMARK "LSt" 
2aa9 f5				push af  
2aaa 3a be 2a			ld a, (.dmark)  
2aad 32 71 ee			ld (debug_mark),a  
2ab0 3a bf 2a			ld a, (.dmark+1)  
2ab3 32 72 ee			ld (debug_mark+1),a  
2ab6 3a c0 2a			ld a, (.dmark+2)  
2ab9 32 73 ee			ld (debug_mark+2),a  
2abc 18 03			jr .pastdmark  
2abe ..			.dmark: db "LSt"  
2ac1 f1			.pastdmark: pop af  
2ac2			endm  
# End of macro DMARK
2ac2					CALLMONITOR 
2ac2 cd e8 15			call break_point_state  
2ac5				endm  
# End of macro CALLMONITOR
2ac5				endif 
2ac5			 
2ac5			; cant push right now due to tokenised strings  
2ac5			 
2ac5			; get the destination of where to copy this definition to. 
2ac5			 
2ac5 c5					push bc 
2ac6 d1					pop de 
2ac7			 
2ac7 7e			.listl:         ld a,(hl) 
2ac8 fe 00				cp 0 
2aca 28 09				jr z, .lreplsp     ; replace zero with space 
2acc					;cp FORTH_END_BUFFER 
2acc fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ace 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ad0				 
2ad0					; just copy this char as is then 
2ad0			 
2ad0 12					ld (de), a 
2ad1			 
2ad1 23			.listnxt:	inc hl 
2ad2 13					inc de 
2ad3 18 f2				jr .listl 
2ad5			 
2ad5 3e 20		.lreplsp:	ld a,' ' 
2ad7 12					ld (de), a 
2ad8 18 f7				jr .listnxt 
2ada			 
2ada			; close up uword def 
2ada			 
2ada			.listdone: 
2ada 12					ld (de), a 
2adb 13					inc de 
2adc 3e 00				ld a, 0 
2ade 12					ld (de), a 
2adf			 
2adf			; now have def so clean up and push to stack 
2adf			 
2adf 21 c7 e2				ld hl, scratch 
2ae2				if DEBUG_FORTH_WORDS 
2ae2					DMARK "Ltp" 
2ae2 f5				push af  
2ae3 3a f7 2a			ld a, (.dmark)  
2ae6 32 71 ee			ld (debug_mark),a  
2ae9 3a f8 2a			ld a, (.dmark+1)  
2aec 32 72 ee			ld (debug_mark+1),a  
2aef 3a f9 2a			ld a, (.dmark+2)  
2af2 32 73 ee			ld (debug_mark+2),a  
2af5 18 03			jr .pastdmark  
2af7 ..			.dmark: db "Ltp"  
2afa f1			.pastdmark: pop af  
2afb			endm  
# End of macro DMARK
2afb					CALLMONITOR 
2afb cd e8 15			call break_point_state  
2afe				endm  
# End of macro CALLMONITOR
2afe				endif 
2afe			 
2afe 18 1f			jr .listpush 
2b00			 
2b00			;.lnuword:	pop hl 
2b00			;		call forth_tok_next 
2b00			;		jp .ldouscan  
2b00			 
2b00			.lunotfound:		  
2b00			 
2b00				if DEBUG_FORTH_WORDS 
2b00					DMARK "LSn" 
2b00 f5				push af  
2b01 3a 15 2b			ld a, (.dmark)  
2b04 32 71 ee			ld (debug_mark),a  
2b07 3a 16 2b			ld a, (.dmark+1)  
2b0a 32 72 ee			ld (debug_mark+1),a  
2b0d 3a 17 2b			ld a, (.dmark+2)  
2b10 32 73 ee			ld (debug_mark+2),a  
2b13 18 03			jr .pastdmark  
2b15 ..			.dmark: db "LSn"  
2b18 f1			.pastdmark: pop af  
2b19			endm  
# End of macro DMARK
2b19					CALLMONITOR 
2b19 cd e8 15			call break_point_state  
2b1c				endm  
# End of macro CALLMONITOR
2b1c				endif 
2b1c			 
2b1c					 
2b1c			;		FORTH_DSP_POP 
2b1c			;		ld hl, .luno 
2b1c			 
2b1c					NEXTW			 
2b1c c3 0b 20			jp macro_next 
2b1f				endm 
# End of macro NEXTW
2b1f			 
2b1f			.listpush: 
2b1f				if DEBUG_FORTH_WORDS 
2b1f					DMARK "LS>" 
2b1f f5				push af  
2b20 3a 34 2b			ld a, (.dmark)  
2b23 32 71 ee			ld (debug_mark),a  
2b26 3a 35 2b			ld a, (.dmark+1)  
2b29 32 72 ee			ld (debug_mark+1),a  
2b2c 3a 36 2b			ld a, (.dmark+2)  
2b2f 32 73 ee			ld (debug_mark+2),a  
2b32 18 03			jr .pastdmark  
2b34 ..			.dmark: db "LS>"  
2b37 f1			.pastdmark: pop af  
2b38			endm  
# End of macro DMARK
2b38					CALLMONITOR 
2b38 cd e8 15			call break_point_state  
2b3b				endm  
# End of macro CALLMONITOR
2b3b				endif 
2b3b cd cc 1c				call forth_push_str 
2b3e			 
2b3e			 
2b3e			 
2b3e					NEXTW 
2b3e c3 0b 20			jp macro_next 
2b41				endm 
# End of macro NEXTW
2b41			 
2b41			;.luno:    db "Word not found",0 
2b41			 
2b41			 
2b41			 
2b41			 
2b41			 
2b41			;		push hl   ; save pointer to start of uword def string 
2b41			; 
2b41			;; look for FORTH_EOL_LINE 
2b41			;		ld a, FORTH_END_BUFFER 
2b41			;		call strlent 
2b41			; 
2b41			;		inc hl		 ; space for coln def 
2b41			;		inc hl 
2b41			;		inc hl          ; space for terms 
2b41			;		inc hl 
2b41			; 
2b41			;		ld a, 20   ; TODO get actual length 
2b41			;		call addatohl    ; include a random amount of room for the uword name 
2b41			; 
2b41			;		 
2b41			;	if DEBUG_FORTH_WORDS 
2b41			;		DMARK "Lt1" 
2b41			;		CALLMONITOR 
2b41			;	endif 
2b41			;		 
2b41			; 
2b41			;; malloc space for the string because we cant change it 
2b41			; 
2b41			;		call malloc 
2b41			;	if DEBUG_FORTH_MALLOC_GUARD 
2b41			;		push af 
2b41			;		call ishlzero 
2b41			;		pop af 
2b41			;		 
2b41			;		call z,malloc_error 
2b41			;	endif 
2b41			; 
2b41			;	if DEBUG_FORTH_WORDS 
2b41			;		DMARK "Lt2" 
2b41			;		CALLMONITOR 
2b41			;	endif 
2b41			;		pop de 
2b41			;		push hl    ; push the malloc to release later 
2b41			;		push hl   ;  push back a copy for the later stack push 
2b41			;		 
2b41			;; copy the string swapping out the zero terms for spaces 
2b41			; 
2b41			;		; de has our source 
2b41			;		; hl has our dest 
2b41			; 
2b41			;; add the coln def 
2b41			; 
2b41			;		ld a, ':' 
2b41			;		ld (hl), a 
2b41			;		inc hl 
2b41			;		ld a, ' ' 
2b41			;		ld (hl), a 
2b41			;		inc hl 
2b41			; 
2b41			;; add the uname word 
2b41			;		push de   ; save our string for now 
2b41			;		ex de, hl 
2b41			; 
2b41			;		FORTH_DSP_VALUE 
2b41			;		;v5 FORTH_DSP_VALUE 
2b41			; 
2b41			;		inc hl   ; skip type but we know by now this is OK 
2b41			; 
2b41			;.luword:	ld a,(hl) 
2b41			;		cp 0 
2b41			;		jr z, .luword2 
2b41			;		ld (de), a 
2b41			;		inc de 
2b41			;		inc hl 
2b41			;		jr .luword 
2b41			; 
2b41			;.luword2:	ld a, ' ' 
2b41			;		ld (de), a 
2b41			;;		inc hl 
2b41			;;		inc de 
2b41			;;		ld (de), a 
2b41			;;		inc hl 
2b41			;		inc de 
2b41			; 
2b41			;		ex de, hl 
2b41			;		pop de 
2b41			;		 
2b41			;		 
2b41			; 
2b41			;; detoken that string and copy it 
2b41			; 
2b41			;	if DEBUG_FORTH_WORDS 
2b41			;		DMARK "Lt2" 
2b41			;		CALLMONITOR 
2b41			;	endif 
2b41			;.ldetok:	ld a, (de) 
2b41			;		cp FORTH_END_BUFFER 
2b41			;		jr z, .ldetokend 
2b41			;		; swap out any zero term for space 
2b41			;		cp 0 
2b41			;		jr nz, .ldetoknext 
2b41			;		ld a, ' ' 
2b41			; 
2b41			;	if DEBUG_FORTH_WORDS 
2b41			;		DMARK "LtS" 
2b41			;		CALLMONITOR 
2b41			;	endif 
2b41			;.ldetoknext:	ld (hl), a 
2b41			;		inc de 
2b41			;		inc hl 
2b41			;		jr .ldetok 
2b41			; 
2b41			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b41			;		ld (hl), a  
2b41			; 
2b41			;; free that temp malloc 
2b41			; 
2b41			;		pop hl    
2b41			; 
2b41			;	if DEBUG_FORTH_WORDS 
2b41			;		DMARK "Lt4" 
2b41			;		CALLMONITOR 
2b41			;	endif 
2b41			;		call forth_apushstrhl 
2b41			; 
2b41			;		; get rid of temp malloc area 
2b41			; 
2b41			;		pop hl 
2b41			;		call free 
2b41			; 
2b41			;		jr .ludone 
2b41			; 
2b41			;.lnuword:	pop hl 
2b41			;		call forth_tok_next 
2b41			;		jp .ldouscan  
2b41			; 
2b41			;.ludone:		 pop hl 
2b41			; 
2b41					NEXTW 
2b41 c3 0b 20			jp macro_next 
2b44				endm 
# End of macro NEXTW
2b44			 
2b44			.FORGET: 
2b44				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b44 5d				db WORD_SYS_CORE+73             
2b45 bd 2b			dw .NOP            
2b47 07				db 6 + 1 
2b48 .. 00			db "FORGET",0              
2b4f				endm 
# End of macro CWHEAD
2b4f			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b4f			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b4f			; | |  
2b4f			; | | e.g. "MORE" forget 
2b4f					if DEBUG_FORTH_WORDS_KEY 
2b4f						DMARK "FRG" 
2b4f f5				push af  
2b50 3a 64 2b			ld a, (.dmark)  
2b53 32 71 ee			ld (debug_mark),a  
2b56 3a 65 2b			ld a, (.dmark+1)  
2b59 32 72 ee			ld (debug_mark+1),a  
2b5c 3a 66 2b			ld a, (.dmark+2)  
2b5f 32 73 ee			ld (debug_mark+2),a  
2b62 18 03			jr .pastdmark  
2b64 ..			.dmark: db "FRG"  
2b67 f1			.pastdmark: pop af  
2b68			endm  
# End of macro DMARK
2b68						CALLMONITOR 
2b68 cd e8 15			call break_point_state  
2b6b				endm  
# End of macro CALLMONITOR
2b6b					endif 
2b6b			 
2b6b				; find uword 
2b6b			        ; update start of word with "_" 
2b6b				; replace uword with deleted flag 
2b6b			 
2b6b			 
2b6b			;	if DEBUG_FORTH_WORDS 
2b6b			;		DMARK "FOG" 
2b6b			;		CALLMONITOR 
2b6b			;	endif 
2b6b			 
2b6b			 
2b6b					; Get ptr to the word we need to look up 
2b6b			 
2b6b					FORTH_DSP_VALUEHL 
2b6b cd 55 1e			call macro_dsp_valuehl 
2b6e				endm 
# End of macro FORTH_DSP_VALUEHL
2b6e					;v5 FORTH_DSP_VALUE 
2b6e				; TODO type check 
2b6e			;		inc hl    ; Skip type check  
2b6e e5					push hl 
2b6f c1					pop bc 
2b70			;		ex de, hl    ; put into DE 
2b70			 
2b70			 
2b70 21 b8 64				ld hl, baseram 
2b73					;ld hl, baseusermem 
2b73			 
2b73				; skip dict stub 
2b73			;	call forth_tok_next 
2b73 e5			push hl   ; sacreifical push 
2b74			 
2b74			.fldouscanm: 
2b74 e1				pop hl 
2b75			.fldouscan: 
2b75			;	if DEBUG_FORTH_WORDS 
2b75			;		DMARK "LSs" 
2b75			;		CALLMONITOR 
2b75			;	endif 
2b75				; skip dict stub 
2b75 cd 5c 21				call forth_tok_next 
2b78			 
2b78			 
2b78			; while we have words to look for 
2b78			 
2b78 7e				ld a, (hl)      
2b79			;	if DEBUG_FORTH_WORDS 
2b79			;		DMARK "LSk" 
2b79			;		CALLMONITOR 
2b79			;	endif 
2b79 fe 00				cp WORD_SYS_END 
2b7b ca b7 2b				jp z, .flunotfound 
2b7e fe 01				cp WORD_SYS_UWORD 
2b80 c2 75 2b				jp nz, .fldouscan 
2b83			 
2b83			;	if DEBUG_FORTH_WORDS 
2b83			;		DMARK "LSu" 
2b83			;		CALLMONITOR 
2b83			;	endif 
2b83			 
2b83					; found a uword but is it the one we want... 
2b83			 
2b83 c5					push bc     ; uword to find is on bc 
2b84 d1					pop de 
2b85			 
2b85 e5					push hl  ; to save the ptr 
2b86			 
2b86					; skip opcode 
2b86 23					inc hl  
2b87					; skip next ptr 
2b87 23					inc hl  
2b88 23					inc hl 
2b89					; skip len 
2b89 23					inc hl 
2b8a			 
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "LSc" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a cd 7d 12				call strcmp 
2b8d c2 74 2b				jp nz, .fldouscanm 
2b90			; 
2b90			; 
2b90			;; while we have words to look for 
2b90			; 
2b90			;.fdouscan:	ld a, (hl)      
2b90			;	if DEBUG_FORTH_WORDS 
2b90			;		DMARK "LSs" 
2b90			;		CALLMONITOR 
2b90			;	endif 
2b90			;		cp WORD_SYS_END 
2b90			;		jp z, .fudone 
2b90			;		cp WORD_SYS_UWORD 
2b90			;		jp nz, .fnuword 
2b90			; 
2b90			;	if DEBUG_FORTH_WORDS 
2b90			;		DMARK "FGu" 
2b90			;		CALLMONITOR 
2b90			;	endif 
2b90			; 
2b90			;		; found a uword but is it the one we want... 
2b90			; 
2b90			; 
2b90			;	        pop de   ; get back the dsp name 
2b90			;		push de 
2b90			; 
2b90			;		push hl  ; to save the ptr 
2b90			; 
2b90			;		; skip opcode 
2b90			;		inc hl  
2b90			;		; skip next ptr 
2b90			;		inc hl  
2b90			;		inc hl 
2b90			;		; skip len 
2b90			;		inc hl 
2b90			; 
2b90			;	if DEBUG_FORTH_WORDS 
2b90			;		DMARK "FGc" 
2b90			;		CALLMONITOR 
2b90			;	endif 
2b90			;		call strcmp 
2b90			;		jp nz, .fnuword 
2b90			 
2b90			 
2b90 e1			pop hl 
2b91			 
2b91				 
2b91				if DEBUG_FORTH_WORDS 
2b91					DMARK "FGm" 
2b91 f5				push af  
2b92 3a a6 2b			ld a, (.dmark)  
2b95 32 71 ee			ld (debug_mark),a  
2b98 3a a7 2b			ld a, (.dmark+1)  
2b9b 32 72 ee			ld (debug_mark+1),a  
2b9e 3a a8 2b			ld a, (.dmark+2)  
2ba1 32 73 ee			ld (debug_mark+2),a  
2ba4 18 03			jr .pastdmark  
2ba6 ..			.dmark: db "FGm"  
2ba9 f1			.pastdmark: pop af  
2baa			endm  
# End of macro DMARK
2baa					CALLMONITOR 
2baa cd e8 15			call break_point_state  
2bad				endm  
# End of macro CALLMONITOR
2bad				endif 
2bad			 
2bad			 
2bad			 
2bad					; we have a uword so push its name to the stack 
2bad			 
2bad			;	   	push hl  ; save so we can move to next dict block 
2bad			;pop hl 
2bad			 
2bad					; update opcode to deleted 
2bad 3e 03				ld a, WORD_SYS_DELETED 
2baf 77					ld (hl), a 
2bb0			 
2bb0 23					inc hl  
2bb1					; skip next ptr 
2bb1 23					inc hl  
2bb2 23					inc hl 
2bb3					; skip len 
2bb3 23					inc hl 
2bb4			 
2bb4					; TODO change parser to skip deleted words but for now mark it out 
2bb4 3e 5f				ld a, "_" 
2bb6 77					ld  (hl),a 
2bb7			 
2bb7			;		jr .fudone 
2bb7			; 
2bb7			;.fnuword:	pop hl 
2bb7			;		call forth_tok_next 
2bb7			;		jp .fdouscan  
2bb7			 
2bb7			.flunotfound:		  
2bb7			 
2bb7			 
2bb7					 
2bb7					FORTH_DSP_POP 
2bb7 cd 0d 1f			call macro_forth_dsp_pop 
2bba				endm 
# End of macro FORTH_DSP_POP
2bba			;		ld hl, .luno 
2bba			;.fudone:		 pop hl 
2bba					NEXTW 
2bba c3 0b 20			jp macro_next 
2bbd				endm 
# End of macro NEXTW
2bbd			.NOP: 
2bbd				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bbd 61				db WORD_SYS_CORE+77             
2bbe e4 2b			dw .COMO            
2bc0 04				db 3 + 1 
2bc1 .. 00			db "NOP",0              
2bc5				endm 
# End of macro CWHEAD
2bc5			; | NOP (  --  ) Do nothing | DONE 
2bc5					if DEBUG_FORTH_WORDS_KEY 
2bc5						DMARK "NOP" 
2bc5 f5				push af  
2bc6 3a da 2b			ld a, (.dmark)  
2bc9 32 71 ee			ld (debug_mark),a  
2bcc 3a db 2b			ld a, (.dmark+1)  
2bcf 32 72 ee			ld (debug_mark+1),a  
2bd2 3a dc 2b			ld a, (.dmark+2)  
2bd5 32 73 ee			ld (debug_mark+2),a  
2bd8 18 03			jr .pastdmark  
2bda ..			.dmark: db "NOP"  
2bdd f1			.pastdmark: pop af  
2bde			endm  
# End of macro DMARK
2bde						CALLMONITOR 
2bde cd e8 15			call break_point_state  
2be1				endm  
# End of macro CALLMONITOR
2be1					endif 
2be1				       NEXTW 
2be1 c3 0b 20			jp macro_next 
2be4				endm 
# End of macro NEXTW
2be4			.COMO: 
2be4				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2be4 6e				db WORD_SYS_CORE+90             
2be5 36 2c			dw .COMC            
2be7 02				db 1 + 1 
2be8 .. 00			db "(",0              
2bea				endm 
# End of macro CWHEAD
2bea			; | ( ( -- )  Start of comment | DONE 
2bea			 
2bea			 
2bea 2a c8 e5				ld hl, ( os_tok_ptr) 
2bed 11 31 2c			ld de, .closepar 
2bf0					 
2bf0					if DEBUG_FORTH_WORDS 
2bf0						DMARK ").." 
2bf0 f5				push af  
2bf1 3a 05 2c			ld a, (.dmark)  
2bf4 32 71 ee			ld (debug_mark),a  
2bf7 3a 06 2c			ld a, (.dmark+1)  
2bfa 32 72 ee			ld (debug_mark+1),a  
2bfd 3a 07 2c			ld a, (.dmark+2)  
2c00 32 73 ee			ld (debug_mark+2),a  
2c03 18 03			jr .pastdmark  
2c05 ..			.dmark: db ").."  
2c08 f1			.pastdmark: pop af  
2c09			endm  
# End of macro DMARK
2c09						CALLMONITOR 
2c09 cd e8 15			call break_point_state  
2c0c				endm  
# End of macro CALLMONITOR
2c0c					endif 
2c0c cd 26 21			call findnexttok  
2c0f			 
2c0f					if DEBUG_FORTH_WORDS 
2c0f						DMARK "IF5" 
2c0f f5				push af  
2c10 3a 24 2c			ld a, (.dmark)  
2c13 32 71 ee			ld (debug_mark),a  
2c16 3a 25 2c			ld a, (.dmark+1)  
2c19 32 72 ee			ld (debug_mark+1),a  
2c1c 3a 26 2c			ld a, (.dmark+2)  
2c1f 32 73 ee			ld (debug_mark+2),a  
2c22 18 03			jr .pastdmark  
2c24 ..			.dmark: db "IF5"  
2c27 f1			.pastdmark: pop af  
2c28			endm  
# End of macro DMARK
2c28						CALLMONITOR 
2c28 cd e8 15			call break_point_state  
2c2b				endm  
# End of macro CALLMONITOR
2c2b					endif 
2c2b				; replace below with ) exec using tok_ptr 
2c2b 22 c8 e5			ld (os_tok_ptr), hl 
2c2e c3 9c 20			jp exec1 
2c31			 
2c31 .. 00			.closepar:   db ")",0 
2c33			 
2c33				       NEXTW 
2c33 c3 0b 20			jp macro_next 
2c36				endm 
# End of macro NEXTW
2c36			.COMC: 
2c36				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c36 6f				db WORD_SYS_CORE+91             
2c37 3f 2c			dw .SCRATCH            
2c39 02				db 1 + 1 
2c3a .. 00			db ")",0              
2c3c				endm 
# End of macro CWHEAD
2c3c			; | ) ( -- )  End of comment |  DONE  
2c3c				       NEXTW 
2c3c c3 0b 20			jp macro_next 
2c3f				endm 
# End of macro NEXTW
2c3f			 
2c3f			.SCRATCH: 
2c3f				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c3f 6f				db WORD_SYS_CORE+91             
2c40 7a 2c			dw .INC            
2c42 08				db 7 + 1 
2c43 .. 00			db "SCRATCH",0              
2c4b				endm 
# End of macro CWHEAD
2c4b			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c4b			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c4b			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c4b			; | |  
2c4b			; | | e.g.    : score $00 scratch ; 
2c4b			; | |  
2c4b			; | | $00 score ! 
2c4b			; | | $01 score +! 
2c4b			; | |  
2c4b			; | | e.g.   : varword $0a scratch ;  
2c4b			; | | 
2c4b			; | | $8000 varword ! 
2c4b					if DEBUG_FORTH_WORDS_KEY 
2c4b						DMARK "SCR" 
2c4b f5				push af  
2c4c 3a 60 2c			ld a, (.dmark)  
2c4f 32 71 ee			ld (debug_mark),a  
2c52 3a 61 2c			ld a, (.dmark+1)  
2c55 32 72 ee			ld (debug_mark+1),a  
2c58 3a 62 2c			ld a, (.dmark+2)  
2c5b 32 73 ee			ld (debug_mark+2),a  
2c5e 18 03			jr .pastdmark  
2c60 ..			.dmark: db "SCR"  
2c63 f1			.pastdmark: pop af  
2c64			endm  
# End of macro DMARK
2c64						CALLMONITOR 
2c64 cd e8 15			call break_point_state  
2c67				endm  
# End of macro CALLMONITOR
2c67					endif 
2c67			 
2c67					FORTH_DSP_VALUEHL 
2c67 cd 55 1e			call macro_dsp_valuehl 
2c6a				endm 
# End of macro FORTH_DSP_VALUEHL
2c6a				 
2c6a					FORTH_DSP_POP 
2c6a cd 0d 1f			call macro_forth_dsp_pop 
2c6d				endm 
# End of macro FORTH_DSP_POP
2c6d			 
2c6d 7d					ld a, l 
2c6e 21 ec e7				ld hl, os_var_array 
2c71 cd e7 0d				call addatohl 
2c74			 
2c74 cd 5e 1c				call forth_push_numhl 
2c77			 
2c77				       NEXTW 
2c77 c3 0b 20			jp macro_next 
2c7a				endm 
# End of macro NEXTW
2c7a			 
2c7a			.INC: 
2c7a				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c7a 6f				db WORD_SYS_CORE+91             
2c7b ce 2c			dw .DEC            
2c7d 03				db 2 + 1 
2c7e .. 00			db "+!",0              
2c81				endm 
# End of macro CWHEAD
2c81			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c81					if DEBUG_FORTH_WORDS_KEY 
2c81						DMARK "+s_" 
2c81 f5				push af  
2c82 3a 96 2c			ld a, (.dmark)  
2c85 32 71 ee			ld (debug_mark),a  
2c88 3a 97 2c			ld a, (.dmark+1)  
2c8b 32 72 ee			ld (debug_mark+1),a  
2c8e 3a 98 2c			ld a, (.dmark+2)  
2c91 32 73 ee			ld (debug_mark+2),a  
2c94 18 03			jr .pastdmark  
2c96 ..			.dmark: db "+s_"  
2c99 f1			.pastdmark: pop af  
2c9a			endm  
# End of macro DMARK
2c9a						CALLMONITOR 
2c9a cd e8 15			call break_point_state  
2c9d				endm  
# End of macro CALLMONITOR
2c9d					endif 
2c9d			 
2c9d					FORTH_DSP_VALUEHL 
2c9d cd 55 1e			call macro_dsp_valuehl 
2ca0				endm 
# End of macro FORTH_DSP_VALUEHL
2ca0			 
2ca0 e5					push hl   ; save address 
2ca1			 
2ca1					FORTH_DSP_POP 
2ca1 cd 0d 1f			call macro_forth_dsp_pop 
2ca4				endm 
# End of macro FORTH_DSP_POP
2ca4			 
2ca4					FORTH_DSP_VALUEHL 
2ca4 cd 55 1e			call macro_dsp_valuehl 
2ca7				endm 
# End of macro FORTH_DSP_VALUEHL
2ca7			 
2ca7					FORTH_DSP_POP 
2ca7 cd 0d 1f			call macro_forth_dsp_pop 
2caa				endm 
# End of macro FORTH_DSP_POP
2caa			 
2caa					; hl contains value to add to byte at a 
2caa				 
2caa eb					ex de, hl 
2cab			 
2cab e1					pop hl 
2cac			 
2cac					if DEBUG_FORTH_WORDS 
2cac						DMARK "INC" 
2cac f5				push af  
2cad 3a c1 2c			ld a, (.dmark)  
2cb0 32 71 ee			ld (debug_mark),a  
2cb3 3a c2 2c			ld a, (.dmark+1)  
2cb6 32 72 ee			ld (debug_mark+1),a  
2cb9 3a c3 2c			ld a, (.dmark+2)  
2cbc 32 73 ee			ld (debug_mark+2),a  
2cbf 18 03			jr .pastdmark  
2cc1 ..			.dmark: db "INC"  
2cc4 f1			.pastdmark: pop af  
2cc5			endm  
# End of macro DMARK
2cc5						CALLMONITOR 
2cc5 cd e8 15			call break_point_state  
2cc8				endm  
# End of macro CALLMONITOR
2cc8					endif 
2cc8			 
2cc8 7e					ld a,(hl) 
2cc9 83					add e 
2cca 77					ld (hl),a 
2ccb			 
2ccb			 
2ccb			 
2ccb				       NEXTW 
2ccb c3 0b 20			jp macro_next 
2cce				endm 
# End of macro NEXTW
2cce			 
2cce			.DEC: 
2cce				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cce 6f				db WORD_SYS_CORE+91             
2ccf 1f 2d			dw .INC2            
2cd1 03				db 2 + 1 
2cd2 .. 00			db "-!",0              
2cd5				endm 
# End of macro CWHEAD
2cd5			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cd5					if DEBUG_FORTH_WORDS_KEY 
2cd5						DMARK "-s_" 
2cd5 f5				push af  
2cd6 3a ea 2c			ld a, (.dmark)  
2cd9 32 71 ee			ld (debug_mark),a  
2cdc 3a eb 2c			ld a, (.dmark+1)  
2cdf 32 72 ee			ld (debug_mark+1),a  
2ce2 3a ec 2c			ld a, (.dmark+2)  
2ce5 32 73 ee			ld (debug_mark+2),a  
2ce8 18 03			jr .pastdmark  
2cea ..			.dmark: db "-s_"  
2ced f1			.pastdmark: pop af  
2cee			endm  
# End of macro DMARK
2cee						CALLMONITOR 
2cee cd e8 15			call break_point_state  
2cf1				endm  
# End of macro CALLMONITOR
2cf1					endif 
2cf1			 
2cf1					FORTH_DSP_VALUEHL 
2cf1 cd 55 1e			call macro_dsp_valuehl 
2cf4				endm 
# End of macro FORTH_DSP_VALUEHL
2cf4			 
2cf4 e5					push hl   ; save address 
2cf5			 
2cf5					FORTH_DSP_POP 
2cf5 cd 0d 1f			call macro_forth_dsp_pop 
2cf8				endm 
# End of macro FORTH_DSP_POP
2cf8			 
2cf8					FORTH_DSP_VALUEHL 
2cf8 cd 55 1e			call macro_dsp_valuehl 
2cfb				endm 
# End of macro FORTH_DSP_VALUEHL
2cfb			 
2cfb					; hl contains value to add to byte at a 
2cfb				 
2cfb eb					ex de, hl 
2cfc			 
2cfc e1					pop hl 
2cfd			 
2cfd					if DEBUG_FORTH_WORDS 
2cfd						DMARK "DEC" 
2cfd f5				push af  
2cfe 3a 12 2d			ld a, (.dmark)  
2d01 32 71 ee			ld (debug_mark),a  
2d04 3a 13 2d			ld a, (.dmark+1)  
2d07 32 72 ee			ld (debug_mark+1),a  
2d0a 3a 14 2d			ld a, (.dmark+2)  
2d0d 32 73 ee			ld (debug_mark+2),a  
2d10 18 03			jr .pastdmark  
2d12 ..			.dmark: db "DEC"  
2d15 f1			.pastdmark: pop af  
2d16			endm  
# End of macro DMARK
2d16						CALLMONITOR 
2d16 cd e8 15			call break_point_state  
2d19				endm  
# End of macro CALLMONITOR
2d19					endif 
2d19			 
2d19 7e					ld a,(hl) 
2d1a 93					sub e 
2d1b 77					ld (hl),a 
2d1c			 
2d1c			 
2d1c			 
2d1c				       NEXTW 
2d1c c3 0b 20			jp macro_next 
2d1f				endm 
# End of macro NEXTW
2d1f			 
2d1f			.INC2: 
2d1f				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d1f 6f				db WORD_SYS_CORE+91             
2d20 c9 2d			dw .DEC2            
2d22 04				db 3 + 1 
2d23 .. 00			db "+2!",0              
2d27				endm 
# End of macro CWHEAD
2d27			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d27			 
2d27					if DEBUG_FORTH_WORDS_KEY 
2d27						DMARK "+2s" 
2d27 f5				push af  
2d28 3a 3c 2d			ld a, (.dmark)  
2d2b 32 71 ee			ld (debug_mark),a  
2d2e 3a 3d 2d			ld a, (.dmark+1)  
2d31 32 72 ee			ld (debug_mark+1),a  
2d34 3a 3e 2d			ld a, (.dmark+2)  
2d37 32 73 ee			ld (debug_mark+2),a  
2d3a 18 03			jr .pastdmark  
2d3c ..			.dmark: db "+2s"  
2d3f f1			.pastdmark: pop af  
2d40			endm  
# End of macro DMARK
2d40						CALLMONITOR 
2d40 cd e8 15			call break_point_state  
2d43				endm  
# End of macro CALLMONITOR
2d43					endif 
2d43			 
2d43					; Address 
2d43			 
2d43					FORTH_DSP_VALUEHL 
2d43 cd 55 1e			call macro_dsp_valuehl 
2d46				endm 
# End of macro FORTH_DSP_VALUEHL
2d46			 
2d46 e5					push hl    ; save address 
2d47			 
2d47					; load content into de 
2d47			 
2d47 5e					ld e,(hl) 
2d48 23					inc hl 
2d49 56					ld d, (hl) 
2d4a			 
2d4a					if DEBUG_FORTH_WORDS 
2d4a						DMARK "+2a" 
2d4a f5				push af  
2d4b 3a 5f 2d			ld a, (.dmark)  
2d4e 32 71 ee			ld (debug_mark),a  
2d51 3a 60 2d			ld a, (.dmark+1)  
2d54 32 72 ee			ld (debug_mark+1),a  
2d57 3a 61 2d			ld a, (.dmark+2)  
2d5a 32 73 ee			ld (debug_mark+2),a  
2d5d 18 03			jr .pastdmark  
2d5f ..			.dmark: db "+2a"  
2d62 f1			.pastdmark: pop af  
2d63			endm  
# End of macro DMARK
2d63						CALLMONITOR 
2d63 cd e8 15			call break_point_state  
2d66				endm  
# End of macro CALLMONITOR
2d66					endif 
2d66			 
2d66					FORTH_DSP_POP 
2d66 cd 0d 1f			call macro_forth_dsp_pop 
2d69				endm 
# End of macro FORTH_DSP_POP
2d69			 
2d69					; Get value to add 
2d69			 
2d69					FORTH_DSP_VALUE 
2d69 cd 3e 1e			call macro_forth_dsp_value 
2d6c				endm 
# End of macro FORTH_DSP_VALUE
2d6c			 
2d6c					if DEBUG_FORTH_WORDS 
2d6c						DMARK "+2v" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 71 ee			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 72 ee			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 73 ee			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "+2v"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd e8 15			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88 19					add hl, de 
2d89			 
2d89					if DEBUG_FORTH_WORDS 
2d89						DMARK "+2+" 
2d89 f5				push af  
2d8a 3a 9e 2d			ld a, (.dmark)  
2d8d 32 71 ee			ld (debug_mark),a  
2d90 3a 9f 2d			ld a, (.dmark+1)  
2d93 32 72 ee			ld (debug_mark+1),a  
2d96 3a a0 2d			ld a, (.dmark+2)  
2d99 32 73 ee			ld (debug_mark+2),a  
2d9c 18 03			jr .pastdmark  
2d9e ..			.dmark: db "+2+"  
2da1 f1			.pastdmark: pop af  
2da2			endm  
# End of macro DMARK
2da2						CALLMONITOR 
2da2 cd e8 15			call break_point_state  
2da5				endm  
# End of macro CALLMONITOR
2da5					endif 
2da5			 
2da5					; move result to de 
2da5			 
2da5 eb					ex de, hl 
2da6			 
2da6					; Address 
2da6			 
2da6 e1					pop hl 
2da7			 
2da7					; save it back 
2da7			 
2da7 73					ld (hl), e 
2da8 23					inc hl 
2da9 72					ld (hl), d 
2daa			 
2daa					if DEBUG_FORTH_WORDS 
2daa						DMARK "+2e" 
2daa f5				push af  
2dab 3a bf 2d			ld a, (.dmark)  
2dae 32 71 ee			ld (debug_mark),a  
2db1 3a c0 2d			ld a, (.dmark+1)  
2db4 32 72 ee			ld (debug_mark+1),a  
2db7 3a c1 2d			ld a, (.dmark+2)  
2dba 32 73 ee			ld (debug_mark+2),a  
2dbd 18 03			jr .pastdmark  
2dbf ..			.dmark: db "+2e"  
2dc2 f1			.pastdmark: pop af  
2dc3			endm  
# End of macro DMARK
2dc3						CALLMONITOR 
2dc3 cd e8 15			call break_point_state  
2dc6				endm  
# End of macro CALLMONITOR
2dc6					endif 
2dc6			 
2dc6			 
2dc6			 
2dc6			 
2dc6			 
2dc6				       NEXTW 
2dc6 c3 0b 20			jp macro_next 
2dc9				endm 
# End of macro NEXTW
2dc9			 
2dc9			.DEC2: 
2dc9				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dc9 6f				db WORD_SYS_CORE+91             
2dca 75 2e			dw .GET2            
2dcc 04				db 3 + 1 
2dcd .. 00			db "-2!",0              
2dd1				endm 
# End of macro CWHEAD
2dd1			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dd1			 
2dd1			 
2dd1					if DEBUG_FORTH_WORDS_KEY 
2dd1						DMARK "-2s" 
2dd1 f5				push af  
2dd2 3a e6 2d			ld a, (.dmark)  
2dd5 32 71 ee			ld (debug_mark),a  
2dd8 3a e7 2d			ld a, (.dmark+1)  
2ddb 32 72 ee			ld (debug_mark+1),a  
2dde 3a e8 2d			ld a, (.dmark+2)  
2de1 32 73 ee			ld (debug_mark+2),a  
2de4 18 03			jr .pastdmark  
2de6 ..			.dmark: db "-2s"  
2de9 f1			.pastdmark: pop af  
2dea			endm  
# End of macro DMARK
2dea						CALLMONITOR 
2dea cd e8 15			call break_point_state  
2ded				endm  
# End of macro CALLMONITOR
2ded					endif 
2ded			 
2ded					; Address 
2ded			 
2ded					FORTH_DSP_VALUEHL 
2ded cd 55 1e			call macro_dsp_valuehl 
2df0				endm 
# End of macro FORTH_DSP_VALUEHL
2df0			 
2df0 e5					push hl    ; save address 
2df1			 
2df1					; load content into de 
2df1			 
2df1 5e					ld e,(hl) 
2df2 23					inc hl 
2df3 56					ld d, (hl) 
2df4			 
2df4					if DEBUG_FORTH_WORDS 
2df4						DMARK "-2a" 
2df4 f5				push af  
2df5 3a 09 2e			ld a, (.dmark)  
2df8 32 71 ee			ld (debug_mark),a  
2dfb 3a 0a 2e			ld a, (.dmark+1)  
2dfe 32 72 ee			ld (debug_mark+1),a  
2e01 3a 0b 2e			ld a, (.dmark+2)  
2e04 32 73 ee			ld (debug_mark+2),a  
2e07 18 03			jr .pastdmark  
2e09 ..			.dmark: db "-2a"  
2e0c f1			.pastdmark: pop af  
2e0d			endm  
# End of macro DMARK
2e0d						CALLMONITOR 
2e0d cd e8 15			call break_point_state  
2e10				endm  
# End of macro CALLMONITOR
2e10					endif 
2e10			 
2e10					FORTH_DSP_POP 
2e10 cd 0d 1f			call macro_forth_dsp_pop 
2e13				endm 
# End of macro FORTH_DSP_POP
2e13			 
2e13					; Get value to remove 
2e13			 
2e13					FORTH_DSP_VALUE 
2e13 cd 3e 1e			call macro_forth_dsp_value 
2e16				endm 
# End of macro FORTH_DSP_VALUE
2e16			 
2e16					if DEBUG_FORTH_WORDS 
2e16						DMARK "-2v" 
2e16 f5				push af  
2e17 3a 2b 2e			ld a, (.dmark)  
2e1a 32 71 ee			ld (debug_mark),a  
2e1d 3a 2c 2e			ld a, (.dmark+1)  
2e20 32 72 ee			ld (debug_mark+1),a  
2e23 3a 2d 2e			ld a, (.dmark+2)  
2e26 32 73 ee			ld (debug_mark+2),a  
2e29 18 03			jr .pastdmark  
2e2b ..			.dmark: db "-2v"  
2e2e f1			.pastdmark: pop af  
2e2f			endm  
# End of macro DMARK
2e2f						CALLMONITOR 
2e2f cd e8 15			call break_point_state  
2e32				endm  
# End of macro CALLMONITOR
2e32					endif 
2e32			 
2e32 eb					ex de, hl 
2e33 ed 52				sbc hl, de 
2e35			 
2e35					if DEBUG_FORTH_WORDS 
2e35						DMARK "-2d" 
2e35 f5				push af  
2e36 3a 4a 2e			ld a, (.dmark)  
2e39 32 71 ee			ld (debug_mark),a  
2e3c 3a 4b 2e			ld a, (.dmark+1)  
2e3f 32 72 ee			ld (debug_mark+1),a  
2e42 3a 4c 2e			ld a, (.dmark+2)  
2e45 32 73 ee			ld (debug_mark+2),a  
2e48 18 03			jr .pastdmark  
2e4a ..			.dmark: db "-2d"  
2e4d f1			.pastdmark: pop af  
2e4e			endm  
# End of macro DMARK
2e4e						CALLMONITOR 
2e4e cd e8 15			call break_point_state  
2e51				endm  
# End of macro CALLMONITOR
2e51					endif 
2e51			 
2e51					; move result to de 
2e51			 
2e51 eb					ex de, hl 
2e52			 
2e52					; Address 
2e52			 
2e52 e1					pop hl 
2e53			 
2e53					; save it back 
2e53			 
2e53 73					ld (hl), e 
2e54 23					inc hl 
2e55 72					ld (hl), d 
2e56			 
2e56					if DEBUG_FORTH_WORDS 
2e56						DMARK "-2e" 
2e56 f5				push af  
2e57 3a 6b 2e			ld a, (.dmark)  
2e5a 32 71 ee			ld (debug_mark),a  
2e5d 3a 6c 2e			ld a, (.dmark+1)  
2e60 32 72 ee			ld (debug_mark+1),a  
2e63 3a 6d 2e			ld a, (.dmark+2)  
2e66 32 73 ee			ld (debug_mark+2),a  
2e69 18 03			jr .pastdmark  
2e6b ..			.dmark: db "-2e"  
2e6e f1			.pastdmark: pop af  
2e6f			endm  
# End of macro DMARK
2e6f						CALLMONITOR 
2e6f cd e8 15			call break_point_state  
2e72				endm  
# End of macro CALLMONITOR
2e72					endif 
2e72			 
2e72			 
2e72			 
2e72			 
2e72			 
2e72				       NEXTW 
2e72 c3 0b 20			jp macro_next 
2e75				endm 
# End of macro NEXTW
2e75			.GET2: 
2e75				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e75 6f				db WORD_SYS_CORE+91             
2e76 a5 2e			dw .BANG2            
2e78 03				db 2 + 1 
2e79 .. 00			db "2@",0              
2e7c				endm 
# End of macro CWHEAD
2e7c			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e7c					if DEBUG_FORTH_WORDS_KEY 
2e7c						DMARK "2A_" 
2e7c f5				push af  
2e7d 3a 91 2e			ld a, (.dmark)  
2e80 32 71 ee			ld (debug_mark),a  
2e83 3a 92 2e			ld a, (.dmark+1)  
2e86 32 72 ee			ld (debug_mark+1),a  
2e89 3a 93 2e			ld a, (.dmark+2)  
2e8c 32 73 ee			ld (debug_mark+2),a  
2e8f 18 03			jr .pastdmark  
2e91 ..			.dmark: db "2A_"  
2e94 f1			.pastdmark: pop af  
2e95			endm  
# End of macro DMARK
2e95						CALLMONITOR 
2e95 cd e8 15			call break_point_state  
2e98				endm  
# End of macro CALLMONITOR
2e98					endif 
2e98			 
2e98					FORTH_DSP_VALUEHL 
2e98 cd 55 1e			call macro_dsp_valuehl 
2e9b				endm 
# End of macro FORTH_DSP_VALUEHL
2e9b			 
2e9b 5e					ld e, (hl) 
2e9c 23					inc hl 
2e9d 56					ld d, (hl) 
2e9e			 
2e9e eb					ex de, hl 
2e9f			 
2e9f cd 5e 1c				call forth_push_numhl 
2ea2			 
2ea2				       NEXTW 
2ea2 c3 0b 20			jp macro_next 
2ea5				endm 
# End of macro NEXTW
2ea5			.BANG2: 
2ea5				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ea5 6f				db WORD_SYS_CORE+91             
2ea6 dd 2e			dw .CONFIG            
2ea8 03				db 2 + 1 
2ea9 .. 00			db "2!",0              
2eac				endm 
# End of macro CWHEAD
2eac			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2eac					if DEBUG_FORTH_WORDS_KEY 
2eac						DMARK "2S_" 
2eac f5				push af  
2ead 3a c1 2e			ld a, (.dmark)  
2eb0 32 71 ee			ld (debug_mark),a  
2eb3 3a c2 2e			ld a, (.dmark+1)  
2eb6 32 72 ee			ld (debug_mark+1),a  
2eb9 3a c3 2e			ld a, (.dmark+2)  
2ebc 32 73 ee			ld (debug_mark+2),a  
2ebf 18 03			jr .pastdmark  
2ec1 ..			.dmark: db "2S_"  
2ec4 f1			.pastdmark: pop af  
2ec5			endm  
# End of macro DMARK
2ec5						CALLMONITOR 
2ec5 cd e8 15			call break_point_state  
2ec8				endm  
# End of macro CALLMONITOR
2ec8					endif 
2ec8			 
2ec8					FORTH_DSP_VALUEHL 
2ec8 cd 55 1e			call macro_dsp_valuehl 
2ecb				endm 
# End of macro FORTH_DSP_VALUEHL
2ecb			 
2ecb e5					push hl   ; save address 
2ecc			 
2ecc			 
2ecc					FORTH_DSP_POP 
2ecc cd 0d 1f			call macro_forth_dsp_pop 
2ecf				endm 
# End of macro FORTH_DSP_POP
2ecf			 
2ecf					 
2ecf					FORTH_DSP_VALUEHL 
2ecf cd 55 1e			call macro_dsp_valuehl 
2ed2				endm 
# End of macro FORTH_DSP_VALUEHL
2ed2			 
2ed2					FORTH_DSP_POP 
2ed2 cd 0d 1f			call macro_forth_dsp_pop 
2ed5				endm 
# End of macro FORTH_DSP_POP
2ed5			 
2ed5 eb					ex de, hl    ; value now in de 
2ed6			 
2ed6 e1					pop hl 
2ed7			 
2ed7 73					ld (hl), e 
2ed8			 
2ed8 23					inc hl 
2ed9			 
2ed9 72					ld (hl), d 
2eda			 
2eda			 
2eda				       NEXTW 
2eda c3 0b 20			jp macro_next 
2edd				endm 
# End of macro NEXTW
2edd			.CONFIG: 
2edd				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2edd 6f				db WORD_SYS_CORE+91             
2ede ee 2e			dw .ENDCORE            
2ee0 07				db 6 + 1 
2ee1 .. 00			db "CONFIG",0              
2ee8				endm 
# End of macro CWHEAD
2ee8			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ee8			 
2ee8 cd 47 14				call config 
2eeb					NEXTW 
2eeb c3 0b 20			jp macro_next 
2eee				endm 
# End of macro NEXTW
2eee			.ENDCORE: 
2eee			 
2eee			; eof 
2eee			 
2eee			 
# End of file forth_words_core.asm
2eee			include "forth_words_flow.asm" 
2eee			 
2eee			; | ## Program Flow Words 
2eee			 
2eee			.IF: 
2eee				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2eee 1e				db WORD_SYS_CORE+10             
2eef e3 2f			dw .THEN            
2ef1 03				db 2 + 1 
2ef2 .. 00			db "IF",0              
2ef5				endm 
# End of macro CWHEAD
2ef5			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ef5			; 
2ef5					if DEBUG_FORTH_WORDS_KEY 
2ef5						DMARK "IF." 
2ef5 f5				push af  
2ef6 3a 0a 2f			ld a, (.dmark)  
2ef9 32 71 ee			ld (debug_mark),a  
2efc 3a 0b 2f			ld a, (.dmark+1)  
2eff 32 72 ee			ld (debug_mark+1),a  
2f02 3a 0c 2f			ld a, (.dmark+2)  
2f05 32 73 ee			ld (debug_mark+2),a  
2f08 18 03			jr .pastdmark  
2f0a ..			.dmark: db "IF."  
2f0d f1			.pastdmark: pop af  
2f0e			endm  
# End of macro DMARK
2f0e						CALLMONITOR 
2f0e cd e8 15			call break_point_state  
2f11				endm  
# End of macro CALLMONITOR
2f11					endif 
2f11			; eval TOS 
2f11			 
2f11				FORTH_DSP_VALUEHL 
2f11 cd 55 1e			call macro_dsp_valuehl 
2f14				endm 
# End of macro FORTH_DSP_VALUEHL
2f14			 
2f14			;	push hl 
2f14				FORTH_DSP_POP 
2f14 cd 0d 1f			call macro_forth_dsp_pop 
2f17				endm 
# End of macro FORTH_DSP_POP
2f17			;	pop hl 
2f17			 
2f17					if DEBUG_FORTH_WORDS 
2f17						DMARK "IF1" 
2f17 f5				push af  
2f18 3a 2c 2f			ld a, (.dmark)  
2f1b 32 71 ee			ld (debug_mark),a  
2f1e 3a 2d 2f			ld a, (.dmark+1)  
2f21 32 72 ee			ld (debug_mark+1),a  
2f24 3a 2e 2f			ld a, (.dmark+2)  
2f27 32 73 ee			ld (debug_mark+2),a  
2f2a 18 03			jr .pastdmark  
2f2c ..			.dmark: db "IF1"  
2f2f f1			.pastdmark: pop af  
2f30			endm  
# End of macro DMARK
2f30						CALLMONITOR 
2f30 cd e8 15			call break_point_state  
2f33				endm  
# End of macro CALLMONITOR
2f33					endif 
2f33 b7				or a        ; clear carry flag 
2f34 11 00 00			ld de, 0 
2f37 eb				ex de,hl 
2f38 ed 52			sbc hl, de 
2f3a c2 c4 2f			jp nz, .iftrue 
2f3d			 
2f3d					if DEBUG_FORTH_WORDS 
2f3d						DMARK "IF2" 
2f3d f5				push af  
2f3e 3a 52 2f			ld a, (.dmark)  
2f41 32 71 ee			ld (debug_mark),a  
2f44 3a 53 2f			ld a, (.dmark+1)  
2f47 32 72 ee			ld (debug_mark+1),a  
2f4a 3a 54 2f			ld a, (.dmark+2)  
2f4d 32 73 ee			ld (debug_mark+2),a  
2f50 18 03			jr .pastdmark  
2f52 ..			.dmark: db "IF2"  
2f55 f1			.pastdmark: pop af  
2f56			endm  
# End of macro DMARK
2f56						CALLMONITOR 
2f56 cd e8 15			call break_point_state  
2f59				endm  
# End of macro CALLMONITOR
2f59					endif 
2f59			 
2f59			; if not true then skip to THEN 
2f59			 
2f59				; TODO get tok_ptr 
2f59				; TODO consume toks until we get to THEN 
2f59			 
2f59 2a c8 e5			ld hl, (os_tok_ptr) 
2f5c					if DEBUG_FORTH_WORDS 
2f5c						DMARK "IF3" 
2f5c f5				push af  
2f5d 3a 71 2f			ld a, (.dmark)  
2f60 32 71 ee			ld (debug_mark),a  
2f63 3a 72 2f			ld a, (.dmark+1)  
2f66 32 72 ee			ld (debug_mark+1),a  
2f69 3a 73 2f			ld a, (.dmark+2)  
2f6c 32 73 ee			ld (debug_mark+2),a  
2f6f 18 03			jr .pastdmark  
2f71 ..			.dmark: db "IF3"  
2f74 f1			.pastdmark: pop af  
2f75			endm  
# End of macro DMARK
2f75						CALLMONITOR 
2f75 cd e8 15			call break_point_state  
2f78				endm  
# End of macro CALLMONITOR
2f78						 
2f78					endif 
2f78 11 bf 2f			ld de, .ifthen 
2f7b					if DEBUG_FORTH_WORDS 
2f7b						DMARK "IF4" 
2f7b f5				push af  
2f7c 3a 90 2f			ld a, (.dmark)  
2f7f 32 71 ee			ld (debug_mark),a  
2f82 3a 91 2f			ld a, (.dmark+1)  
2f85 32 72 ee			ld (debug_mark+1),a  
2f88 3a 92 2f			ld a, (.dmark+2)  
2f8b 32 73 ee			ld (debug_mark+2),a  
2f8e 18 03			jr .pastdmark  
2f90 ..			.dmark: db "IF4"  
2f93 f1			.pastdmark: pop af  
2f94			endm  
# End of macro DMARK
2f94						CALLMONITOR 
2f94 cd e8 15			call break_point_state  
2f97				endm  
# End of macro CALLMONITOR
2f97					endif 
2f97 cd 26 21			call findnexttok  
2f9a			 
2f9a					if DEBUG_FORTH_WORDS 
2f9a						DMARK "IF5" 
2f9a f5				push af  
2f9b 3a af 2f			ld a, (.dmark)  
2f9e 32 71 ee			ld (debug_mark),a  
2fa1 3a b0 2f			ld a, (.dmark+1)  
2fa4 32 72 ee			ld (debug_mark+1),a  
2fa7 3a b1 2f			ld a, (.dmark+2)  
2faa 32 73 ee			ld (debug_mark+2),a  
2fad 18 03			jr .pastdmark  
2faf ..			.dmark: db "IF5"  
2fb2 f1			.pastdmark: pop af  
2fb3			endm  
# End of macro DMARK
2fb3						CALLMONITOR 
2fb3 cd e8 15			call break_point_state  
2fb6				endm  
# End of macro CALLMONITOR
2fb6					endif 
2fb6				; TODO replace below with ; exec using tok_ptr 
2fb6 22 c8 e5			ld (os_tok_ptr), hl 
2fb9 c3 9c 20			jp exec1 
2fbc				NEXTW 
2fbc c3 0b 20			jp macro_next 
2fbf				endm 
# End of macro NEXTW
2fbf			 
2fbf .. 00		.ifthen:  db "THEN",0 
2fc4			 
2fc4			.iftrue:		 
2fc4				; Exec next words normally 
2fc4			 
2fc4				; if true then exec following IF as normal 
2fc4					if DEBUG_FORTH_WORDS 
2fc4						DMARK "IFT" 
2fc4 f5				push af  
2fc5 3a d9 2f			ld a, (.dmark)  
2fc8 32 71 ee			ld (debug_mark),a  
2fcb 3a da 2f			ld a, (.dmark+1)  
2fce 32 72 ee			ld (debug_mark+1),a  
2fd1 3a db 2f			ld a, (.dmark+2)  
2fd4 32 73 ee			ld (debug_mark+2),a  
2fd7 18 03			jr .pastdmark  
2fd9 ..			.dmark: db "IFT"  
2fdc f1			.pastdmark: pop af  
2fdd			endm  
# End of macro DMARK
2fdd						CALLMONITOR 
2fdd cd e8 15			call break_point_state  
2fe0				endm  
# End of macro CALLMONITOR
2fe0					endif 
2fe0			 
2fe0					NEXTW 
2fe0 c3 0b 20			jp macro_next 
2fe3				endm 
# End of macro NEXTW
2fe3			.THEN: 
2fe3				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fe3 1f				db WORD_SYS_CORE+11             
2fe4 0b 30			dw .ELSE            
2fe6 05				db 4 + 1 
2fe7 .. 00			db "THEN",0              
2fec				endm 
# End of macro CWHEAD
2fec			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fec					if DEBUG_FORTH_WORDS_KEY 
2fec						DMARK "THN" 
2fec f5				push af  
2fed 3a 01 30			ld a, (.dmark)  
2ff0 32 71 ee			ld (debug_mark),a  
2ff3 3a 02 30			ld a, (.dmark+1)  
2ff6 32 72 ee			ld (debug_mark+1),a  
2ff9 3a 03 30			ld a, (.dmark+2)  
2ffc 32 73 ee			ld (debug_mark+2),a  
2fff 18 03			jr .pastdmark  
3001 ..			.dmark: db "THN"  
3004 f1			.pastdmark: pop af  
3005			endm  
# End of macro DMARK
3005						CALLMONITOR 
3005 cd e8 15			call break_point_state  
3008				endm  
# End of macro CALLMONITOR
3008					endif 
3008					NEXTW 
3008 c3 0b 20			jp macro_next 
300b				endm 
# End of macro NEXTW
300b			.ELSE: 
300b				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
300b 20				db WORD_SYS_CORE+12             
300c 33 30			dw .DO            
300e 03				db 2 + 1 
300f .. 00			db "ELSE",0              
3014				endm 
# End of macro CWHEAD
3014			; | ELSE ( -- ) Not supported - does nothing | TODO 
3014			 
3014					if DEBUG_FORTH_WORDS_KEY 
3014						DMARK "ELS" 
3014 f5				push af  
3015 3a 29 30			ld a, (.dmark)  
3018 32 71 ee			ld (debug_mark),a  
301b 3a 2a 30			ld a, (.dmark+1)  
301e 32 72 ee			ld (debug_mark+1),a  
3021 3a 2b 30			ld a, (.dmark+2)  
3024 32 73 ee			ld (debug_mark+2),a  
3027 18 03			jr .pastdmark  
3029 ..			.dmark: db "ELS"  
302c f1			.pastdmark: pop af  
302d			endm  
# End of macro DMARK
302d						CALLMONITOR 
302d cd e8 15			call break_point_state  
3030				endm  
# End of macro CALLMONITOR
3030					endif 
3030			 
3030			 
3030					NEXTW 
3030 c3 0b 20			jp macro_next 
3033				endm 
# End of macro NEXTW
3033			.DO: 
3033				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3033 21				db WORD_SYS_CORE+13             
3034 5a 31			dw .LOOP            
3036 03				db 2 + 1 
3037 .. 00			db "DO",0              
303a				endm 
# End of macro CWHEAD
303a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
303a			 
303a					if DEBUG_FORTH_WORDS_KEY 
303a						DMARK "DO." 
303a f5				push af  
303b 3a 4f 30			ld a, (.dmark)  
303e 32 71 ee			ld (debug_mark),a  
3041 3a 50 30			ld a, (.dmark+1)  
3044 32 72 ee			ld (debug_mark+1),a  
3047 3a 51 30			ld a, (.dmark+2)  
304a 32 73 ee			ld (debug_mark+2),a  
304d 18 03			jr .pastdmark  
304f ..			.dmark: db "DO."  
3052 f1			.pastdmark: pop af  
3053			endm  
# End of macro DMARK
3053						CALLMONITOR 
3053 cd e8 15			call break_point_state  
3056				endm  
# End of macro CALLMONITOR
3056					endif 
3056			;  push pc to rsp stack past the DO 
3056			 
3056 2a c8 e5				ld hl, (os_tok_ptr) 
3059 23					inc hl   ; D 
305a 23					inc hl  ; O 
305b 23					inc hl   ; null 
305c					if DEBUG_FORTH_WORDS 
305c						DMARK "DO2" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 71 ee			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 72 ee			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 73 ee			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "DO2"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd e8 15			call break_point_state  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078					FORTH_RSP_NEXT 
3078 cd 05 1c			call macro_forth_rsp_next 
307b				endm 
# End of macro FORTH_RSP_NEXT
307b					if DEBUG_FORTH_WORDS 
307b						DMARK "DO3" 
307b f5				push af  
307c 3a 90 30			ld a, (.dmark)  
307f 32 71 ee			ld (debug_mark),a  
3082 3a 91 30			ld a, (.dmark+1)  
3085 32 72 ee			ld (debug_mark+1),a  
3088 3a 92 30			ld a, (.dmark+2)  
308b 32 73 ee			ld (debug_mark+2),a  
308e 18 03			jr .pastdmark  
3090 ..			.dmark: db "DO3"  
3093 f1			.pastdmark: pop af  
3094			endm  
# End of macro DMARK
3094						CALLMONITOR 
3094 cd e8 15			call break_point_state  
3097				endm  
# End of macro CALLMONITOR
3097					endif 
3097			 
3097					;if DEBUG_FORTH_WORDS 
3097				;		push hl 
3097			;		endif  
3097			 
3097			; get counters from data stack 
3097			 
3097			 
3097					FORTH_DSP_VALUEHL 
3097 cd 55 1e			call macro_dsp_valuehl 
309a				endm 
# End of macro FORTH_DSP_VALUEHL
309a e5					push hl		 ; hl now has starting counter which needs to be tos 
309b			 
309b					if DEBUG_FORTH_WORDS 
309b						DMARK "DO4" 
309b f5				push af  
309c 3a b0 30			ld a, (.dmark)  
309f 32 71 ee			ld (debug_mark),a  
30a2 3a b1 30			ld a, (.dmark+1)  
30a5 32 72 ee			ld (debug_mark+1),a  
30a8 3a b2 30			ld a, (.dmark+2)  
30ab 32 73 ee			ld (debug_mark+2),a  
30ae 18 03			jr .pastdmark  
30b0 ..			.dmark: db "DO4"  
30b3 f1			.pastdmark: pop af  
30b4			endm  
# End of macro DMARK
30b4						CALLMONITOR 
30b4 cd e8 15			call break_point_state  
30b7				endm  
# End of macro CALLMONITOR
30b7					endif 
30b7					FORTH_DSP_POP 
30b7 cd 0d 1f			call macro_forth_dsp_pop 
30ba				endm 
# End of macro FORTH_DSP_POP
30ba			 
30ba					if DEBUG_FORTH_WORDS 
30ba						DMARK "DO5" 
30ba f5				push af  
30bb 3a cf 30			ld a, (.dmark)  
30be 32 71 ee			ld (debug_mark),a  
30c1 3a d0 30			ld a, (.dmark+1)  
30c4 32 72 ee			ld (debug_mark+1),a  
30c7 3a d1 30			ld a, (.dmark+2)  
30ca 32 73 ee			ld (debug_mark+2),a  
30cd 18 03			jr .pastdmark  
30cf ..			.dmark: db "DO5"  
30d2 f1			.pastdmark: pop af  
30d3			endm  
# End of macro DMARK
30d3						CALLMONITOR 
30d3 cd e8 15			call break_point_state  
30d6				endm  
# End of macro CALLMONITOR
30d6					endif 
30d6			 
30d6					FORTH_DSP_VALUEHL 
30d6 cd 55 1e			call macro_dsp_valuehl 
30d9				endm 
# End of macro FORTH_DSP_VALUEHL
30d9			;		push hl		 ; hl now has starting limit counter 
30d9			 
30d9					if DEBUG_FORTH_WORDS 
30d9						DMARK "DO6" 
30d9 f5				push af  
30da 3a ee 30			ld a, (.dmark)  
30dd 32 71 ee			ld (debug_mark),a  
30e0 3a ef 30			ld a, (.dmark+1)  
30e3 32 72 ee			ld (debug_mark+1),a  
30e6 3a f0 30			ld a, (.dmark+2)  
30e9 32 73 ee			ld (debug_mark+2),a  
30ec 18 03			jr .pastdmark  
30ee ..			.dmark: db "DO6"  
30f1 f1			.pastdmark: pop af  
30f2			endm  
# End of macro DMARK
30f2						CALLMONITOR 
30f2 cd e8 15			call break_point_state  
30f5				endm  
# End of macro CALLMONITOR
30f5					endif 
30f5					FORTH_DSP_POP 
30f5 cd 0d 1f			call macro_forth_dsp_pop 
30f8				endm 
# End of macro FORTH_DSP_POP
30f8			 
30f8			; put counters on the loop stack 
30f8			 
30f8			;		pop hl			 ; limit counter 
30f8 d1					pop de			; start counter 
30f9			 
30f9					; push limit counter 
30f9			 
30f9					if DEBUG_FORTH_WORDS 
30f9						DMARK "DO7" 
30f9 f5				push af  
30fa 3a 0e 31			ld a, (.dmark)  
30fd 32 71 ee			ld (debug_mark),a  
3100 3a 0f 31			ld a, (.dmark+1)  
3103 32 72 ee			ld (debug_mark+1),a  
3106 3a 10 31			ld a, (.dmark+2)  
3109 32 73 ee			ld (debug_mark+2),a  
310c 18 03			jr .pastdmark  
310e ..			.dmark: db "DO7"  
3111 f1			.pastdmark: pop af  
3112			endm  
# End of macro DMARK
3112						CALLMONITOR 
3112 cd e8 15			call break_point_state  
3115				endm  
# End of macro CALLMONITOR
3115					endif 
3115					FORTH_LOOP_NEXT 
3115 cd 86 1e			call macro_forth_loop_next 
3118				endm 
# End of macro FORTH_LOOP_NEXT
3118			 
3118					; push start counter 
3118			 
3118 eb					ex de, hl 
3119					if DEBUG_FORTH_WORDS 
3119						DMARK "DO7" 
3119 f5				push af  
311a 3a 2e 31			ld a, (.dmark)  
311d 32 71 ee			ld (debug_mark),a  
3120 3a 2f 31			ld a, (.dmark+1)  
3123 32 72 ee			ld (debug_mark+1),a  
3126 3a 30 31			ld a, (.dmark+2)  
3129 32 73 ee			ld (debug_mark+2),a  
312c 18 03			jr .pastdmark  
312e ..			.dmark: db "DO7"  
3131 f1			.pastdmark: pop af  
3132			endm  
# End of macro DMARK
3132						CALLMONITOR 
3132 cd e8 15			call break_point_state  
3135				endm  
# End of macro CALLMONITOR
3135					endif 
3135					FORTH_LOOP_NEXT 
3135 cd 86 1e			call macro_forth_loop_next 
3138				endm 
# End of macro FORTH_LOOP_NEXT
3138			 
3138			 
3138					; init first round of I counter 
3138			 
3138 22 ec e5				ld (os_current_i), hl 
313b			 
313b					if DEBUG_FORTH_WORDS 
313b						DMARK "DO8" 
313b f5				push af  
313c 3a 50 31			ld a, (.dmark)  
313f 32 71 ee			ld (debug_mark),a  
3142 3a 51 31			ld a, (.dmark+1)  
3145 32 72 ee			ld (debug_mark+1),a  
3148 3a 52 31			ld a, (.dmark+2)  
314b 32 73 ee			ld (debug_mark+2),a  
314e 18 03			jr .pastdmark  
3150 ..			.dmark: db "DO8"  
3153 f1			.pastdmark: pop af  
3154			endm  
# End of macro DMARK
3154						CALLMONITOR 
3154 cd e8 15			call break_point_state  
3157				endm  
# End of macro CALLMONITOR
3157					endif 
3157			 
3157					NEXTW 
3157 c3 0b 20			jp macro_next 
315a				endm 
# End of macro NEXTW
315a			.LOOP: 
315a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
315a 22				db WORD_SYS_CORE+14             
315b 72 32			dw .I            
315d 05				db 4 + 1 
315e .. 00			db "LOOP",0              
3163				endm 
# End of macro CWHEAD
3163			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3163			 
3163				; pop tos as current loop count to hl 
3163			 
3163				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3163			 
3163				FORTH_LOOP_TOS 
3163 cd b9 1e			call macro_forth_loop_tos 
3166				endm 
# End of macro FORTH_LOOP_TOS
3166 e5				push hl 
3167			 
3167					if DEBUG_FORTH_WORDS_KEY 
3167						DMARK "LOP" 
3167 f5				push af  
3168 3a 7c 31			ld a, (.dmark)  
316b 32 71 ee			ld (debug_mark),a  
316e 3a 7d 31			ld a, (.dmark+1)  
3171 32 72 ee			ld (debug_mark+1),a  
3174 3a 7e 31			ld a, (.dmark+2)  
3177 32 73 ee			ld (debug_mark+2),a  
317a 18 03			jr .pastdmark  
317c ..			.dmark: db "LOP"  
317f f1			.pastdmark: pop af  
3180			endm  
# End of macro DMARK
3180						CALLMONITOR 
3180 cd e8 15			call break_point_state  
3183				endm  
# End of macro CALLMONITOR
3183					endif 
3183				; next item on the stack is the limit. get it 
3183			 
3183			 
3183				FORTH_LOOP_POP 
3183 cd c3 1e			call macro_forth_loop_pop 
3186				endm 
# End of macro FORTH_LOOP_POP
3186			 
3186				FORTH_LOOP_TOS 
3186 cd b9 1e			call macro_forth_loop_tos 
3189				endm 
# End of macro FORTH_LOOP_TOS
3189			 
3189 d1				pop de		 ; de = i, hl = limit 
318a			 
318a					if DEBUG_FORTH_WORDS 
318a						DMARK "LP1" 
318a f5				push af  
318b 3a 9f 31			ld a, (.dmark)  
318e 32 71 ee			ld (debug_mark),a  
3191 3a a0 31			ld a, (.dmark+1)  
3194 32 72 ee			ld (debug_mark+1),a  
3197 3a a1 31			ld a, (.dmark+2)  
319a 32 73 ee			ld (debug_mark+2),a  
319d 18 03			jr .pastdmark  
319f ..			.dmark: db "LP1"  
31a2 f1			.pastdmark: pop af  
31a3			endm  
# End of macro DMARK
31a3						CALLMONITOR 
31a3 cd e8 15			call break_point_state  
31a6				endm  
# End of macro CALLMONITOR
31a6					endif 
31a6			 
31a6				; go back to previous word 
31a6			 
31a6 d5				push de    ; save I for inc later 
31a7			 
31a7			 
31a7				; get limit 
31a7				;  is I at limit? 
31a7			 
31a7			 
31a7					if DEBUG_FORTH_WORDS 
31a7						DMARK "LP1" 
31a7 f5				push af  
31a8 3a bc 31			ld a, (.dmark)  
31ab 32 71 ee			ld (debug_mark),a  
31ae 3a bd 31			ld a, (.dmark+1)  
31b1 32 72 ee			ld (debug_mark+1),a  
31b4 3a be 31			ld a, (.dmark+2)  
31b7 32 73 ee			ld (debug_mark+2),a  
31ba 18 03			jr .pastdmark  
31bc ..			.dmark: db "LP1"  
31bf f1			.pastdmark: pop af  
31c0			endm  
# End of macro DMARK
31c0						CALLMONITOR 
31c0 cd e8 15			call break_point_state  
31c3				endm  
# End of macro CALLMONITOR
31c3					endif 
31c3			 
31c3 ed 52			sbc hl, de 
31c5			 
31c5			 
31c5				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31c5			 
31c5 20 26				jr nz, .loopnotdone 
31c7			 
31c7 e1				pop hl   ; get rid of saved I 
31c8				FORTH_LOOP_POP     ; get rid of limit 
31c8 cd c3 1e			call macro_forth_loop_pop 
31cb				endm 
# End of macro FORTH_LOOP_POP
31cb			 
31cb				FORTH_RSP_POP     ; get rid of DO ptr 
31cb cd 26 1c			call macro_forth_rsp_pop 
31ce				endm 
# End of macro FORTH_RSP_POP
31ce			 
31ce			if DEBUG_FORTH_WORDS 
31ce						DMARK "LP>" 
31ce f5				push af  
31cf 3a e3 31			ld a, (.dmark)  
31d2 32 71 ee			ld (debug_mark),a  
31d5 3a e4 31			ld a, (.dmark+1)  
31d8 32 72 ee			ld (debug_mark+1),a  
31db 3a e5 31			ld a, (.dmark+2)  
31de 32 73 ee			ld (debug_mark+2),a  
31e1 18 03			jr .pastdmark  
31e3 ..			.dmark: db "LP>"  
31e6 f1			.pastdmark: pop af  
31e7			endm  
# End of macro DMARK
31e7				CALLMONITOR 
31e7 cd e8 15			call break_point_state  
31ea				endm  
# End of macro CALLMONITOR
31ea			endif 
31ea			 
31ea					NEXTW 
31ea c3 0b 20			jp macro_next 
31ed				endm 
# End of macro NEXTW
31ed				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31ed			 
31ed			.loopnotdone: 
31ed			 
31ed e1				pop hl    ; get I 
31ee 23				inc hl 
31ef			 
31ef			   	; save new I 
31ef			 
31ef			 
31ef					; set I counter 
31ef			 
31ef 22 ec e5				ld (os_current_i), hl 
31f2			 
31f2					if DEBUG_FORTH_WORDS 
31f2						DMARK "LPN" 
31f2 f5				push af  
31f3 3a 07 32			ld a, (.dmark)  
31f6 32 71 ee			ld (debug_mark),a  
31f9 3a 08 32			ld a, (.dmark+1)  
31fc 32 72 ee			ld (debug_mark+1),a  
31ff 3a 09 32			ld a, (.dmark+2)  
3202 32 73 ee			ld (debug_mark+2),a  
3205 18 03			jr .pastdmark  
3207 ..			.dmark: db "LPN"  
320a f1			.pastdmark: pop af  
320b			endm  
# End of macro DMARK
320b					CALLMONITOR 
320b cd e8 15			call break_point_state  
320e				endm  
# End of macro CALLMONITOR
320e					endif 
320e					 
320e				FORTH_LOOP_NEXT 
320e cd 86 1e			call macro_forth_loop_next 
3211				endm 
# End of macro FORTH_LOOP_NEXT
3211			 
3211			 
3211					if DEBUG_FORTH_WORDS 
3211 eb						ex de,hl 
3212					endif 
3212			 
3212			;	; get DO ptr 
3212			; 
3212					if DEBUG_FORTH_WORDS 
3212						DMARK "LP7" 
3212 f5				push af  
3213 3a 27 32			ld a, (.dmark)  
3216 32 71 ee			ld (debug_mark),a  
3219 3a 28 32			ld a, (.dmark+1)  
321c 32 72 ee			ld (debug_mark+1),a  
321f 3a 29 32			ld a, (.dmark+2)  
3222 32 73 ee			ld (debug_mark+2),a  
3225 18 03			jr .pastdmark  
3227 ..			.dmark: db "LP7"  
322a f1			.pastdmark: pop af  
322b			endm  
# End of macro DMARK
322b					CALLMONITOR 
322b cd e8 15			call break_point_state  
322e				endm  
# End of macro CALLMONITOR
322e					endif 
322e				FORTH_RSP_TOS 
322e cd 1c 1c			call macro_forth_rsp_tos 
3231				endm 
# End of macro FORTH_RSP_TOS
3231			 
3231					if DEBUG_FORTH_WORDS 
3231						DMARK "LP8" 
3231 f5				push af  
3232 3a 46 32			ld a, (.dmark)  
3235 32 71 ee			ld (debug_mark),a  
3238 3a 47 32			ld a, (.dmark+1)  
323b 32 72 ee			ld (debug_mark+1),a  
323e 3a 48 32			ld a, (.dmark+2)  
3241 32 73 ee			ld (debug_mark+2),a  
3244 18 03			jr .pastdmark  
3246 ..			.dmark: db "LP8"  
3249 f1			.pastdmark: pop af  
324a			endm  
# End of macro DMARK
324a					CALLMONITOR 
324a cd e8 15			call break_point_state  
324d				endm  
# End of macro CALLMONITOR
324d					endif 
324d				;push hl 
324d			 
324d				; not going to DO any more 
324d				; get rid of the RSP pointer as DO will add it back in 
324d				;FORTH_RSP_POP 
324d				;pop hl 
324d			 
324d				;ld hl,(cli_ret_sp) 
324d				;ld e, (hl) 
324d				;inc hl 
324d				;ld d, (hl) 
324d				;ex de,hl 
324d 22 c8 e5			ld (os_tok_ptr), hl 
3250					if DEBUG_FORTH_WORDS 
3250						DMARK "LP<" 
3250 f5				push af  
3251 3a 65 32			ld a, (.dmark)  
3254 32 71 ee			ld (debug_mark),a  
3257 3a 66 32			ld a, (.dmark+1)  
325a 32 72 ee			ld (debug_mark+1),a  
325d 3a 67 32			ld a, (.dmark+2)  
3260 32 73 ee			ld (debug_mark+2),a  
3263 18 03			jr .pastdmark  
3265 ..			.dmark: db "LP<"  
3268 f1			.pastdmark: pop af  
3269			endm  
# End of macro DMARK
3269					CALLMONITOR 
3269 cd e8 15			call break_point_state  
326c				endm  
# End of macro CALLMONITOR
326c				endif 
326c c3 9c 20			jp exec1 
326f			 
326f					 
326f			 
326f			 
326f					NEXTW 
326f c3 0b 20			jp macro_next 
3272				endm 
# End of macro NEXTW
3272			.I:  
3272			 
3272				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3272 5e				db WORD_SYS_CORE+74             
3273 9d 32			dw .DLOOP            
3275 02				db 1 + 1 
3276 .. 00			db "I",0              
3278				endm 
# End of macro CWHEAD
3278			; | I ( -- ) Current loop counter | DONE 
3278					if DEBUG_FORTH_WORDS_KEY 
3278						DMARK "I.." 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 71 ee			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 72 ee			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 73 ee			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "I.."  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291						CALLMONITOR 
3291 cd e8 15			call break_point_state  
3294				endm  
# End of macro CALLMONITOR
3294					endif 
3294			 
3294 2a ec e5				ld hl,(os_current_i) 
3297 cd 5e 1c				call forth_push_numhl 
329a			 
329a					NEXTW 
329a c3 0b 20			jp macro_next 
329d				endm 
# End of macro NEXTW
329d			.DLOOP: 
329d				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
329d 5f				db WORD_SYS_CORE+75             
329e 7e 33			dw .REPEAT            
32a0 06				db 5 + 1 
32a1 .. 00			db "-LOOP",0              
32a7				endm 
# End of macro CWHEAD
32a7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32a7				; pop tos as current loop count to hl 
32a7					if DEBUG_FORTH_WORDS_KEY 
32a7						DMARK "-LP" 
32a7 f5				push af  
32a8 3a bc 32			ld a, (.dmark)  
32ab 32 71 ee			ld (debug_mark),a  
32ae 3a bd 32			ld a, (.dmark+1)  
32b1 32 72 ee			ld (debug_mark+1),a  
32b4 3a be 32			ld a, (.dmark+2)  
32b7 32 73 ee			ld (debug_mark+2),a  
32ba 18 03			jr .pastdmark  
32bc ..			.dmark: db "-LP"  
32bf f1			.pastdmark: pop af  
32c0			endm  
# End of macro DMARK
32c0						CALLMONITOR 
32c0 cd e8 15			call break_point_state  
32c3				endm  
# End of macro CALLMONITOR
32c3					endif 
32c3			 
32c3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32c3			 
32c3				FORTH_LOOP_TOS 
32c3 cd b9 1e			call macro_forth_loop_tos 
32c6				endm 
# End of macro FORTH_LOOP_TOS
32c6 e5				push hl 
32c7			 
32c7					if DEBUG_FORTH_WORDS 
32c7						DMARK "-LP" 
32c7 f5				push af  
32c8 3a dc 32			ld a, (.dmark)  
32cb 32 71 ee			ld (debug_mark),a  
32ce 3a dd 32			ld a, (.dmark+1)  
32d1 32 72 ee			ld (debug_mark+1),a  
32d4 3a de 32			ld a, (.dmark+2)  
32d7 32 73 ee			ld (debug_mark+2),a  
32da 18 03			jr .pastdmark  
32dc ..			.dmark: db "-LP"  
32df f1			.pastdmark: pop af  
32e0			endm  
# End of macro DMARK
32e0						CALLMONITOR 
32e0 cd e8 15			call break_point_state  
32e3				endm  
# End of macro CALLMONITOR
32e3					endif 
32e3				; next item on the stack is the limit. get it 
32e3			 
32e3			 
32e3				FORTH_LOOP_POP 
32e3 cd c3 1e			call macro_forth_loop_pop 
32e6				endm 
# End of macro FORTH_LOOP_POP
32e6			 
32e6				FORTH_LOOP_TOS 
32e6 cd b9 1e			call macro_forth_loop_tos 
32e9				endm 
# End of macro FORTH_LOOP_TOS
32e9			 
32e9 d1				pop de		 ; de = i, hl = limit 
32ea			 
32ea					if DEBUG_FORTH_WORDS 
32ea						DMARK "-L1" 
32ea f5				push af  
32eb 3a ff 32			ld a, (.dmark)  
32ee 32 71 ee			ld (debug_mark),a  
32f1 3a 00 33			ld a, (.dmark+1)  
32f4 32 72 ee			ld (debug_mark+1),a  
32f7 3a 01 33			ld a, (.dmark+2)  
32fa 32 73 ee			ld (debug_mark+2),a  
32fd 18 03			jr .pastdmark  
32ff ..			.dmark: db "-L1"  
3302 f1			.pastdmark: pop af  
3303			endm  
# End of macro DMARK
3303						CALLMONITOR 
3303 cd e8 15			call break_point_state  
3306				endm  
# End of macro CALLMONITOR
3306					endif 
3306			 
3306				; go back to previous word 
3306			 
3306 d5				push de    ; save I for inc later 
3307			 
3307			 
3307				; get limit 
3307				;  is I at limit? 
3307			 
3307			 
3307					if DEBUG_FORTH_WORDS 
3307						DMARK "-L1" 
3307 f5				push af  
3308 3a 1c 33			ld a, (.dmark)  
330b 32 71 ee			ld (debug_mark),a  
330e 3a 1d 33			ld a, (.dmark+1)  
3311 32 72 ee			ld (debug_mark+1),a  
3314 3a 1e 33			ld a, (.dmark+2)  
3317 32 73 ee			ld (debug_mark+2),a  
331a 18 03			jr .pastdmark  
331c ..			.dmark: db "-L1"  
331f f1			.pastdmark: pop af  
3320			endm  
# End of macro DMARK
3320						CALLMONITOR 
3320 cd e8 15			call break_point_state  
3323				endm  
# End of macro CALLMONITOR
3323					endif 
3323			 
3323 ed 52			sbc hl, de 
3325			 
3325			 
3325				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3325			 
3325 20 26				jr nz, .mloopnotdone 
3327			 
3327 e1				pop hl   ; get rid of saved I 
3328				FORTH_LOOP_POP     ; get rid of limit 
3328 cd c3 1e			call macro_forth_loop_pop 
332b				endm 
# End of macro FORTH_LOOP_POP
332b			 
332b				FORTH_RSP_POP     ; get rid of DO ptr 
332b cd 26 1c			call macro_forth_rsp_pop 
332e				endm 
# End of macro FORTH_RSP_POP
332e			 
332e			if DEBUG_FORTH_WORDS 
332e						DMARK "-L>" 
332e f5				push af  
332f 3a 43 33			ld a, (.dmark)  
3332 32 71 ee			ld (debug_mark),a  
3335 3a 44 33			ld a, (.dmark+1)  
3338 32 72 ee			ld (debug_mark+1),a  
333b 3a 45 33			ld a, (.dmark+2)  
333e 32 73 ee			ld (debug_mark+2),a  
3341 18 03			jr .pastdmark  
3343 ..			.dmark: db "-L>"  
3346 f1			.pastdmark: pop af  
3347			endm  
# End of macro DMARK
3347				CALLMONITOR 
3347 cd e8 15			call break_point_state  
334a				endm  
# End of macro CALLMONITOR
334a			endif 
334a			 
334a					NEXTW 
334a c3 0b 20			jp macro_next 
334d				endm 
# End of macro NEXTW
334d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
334d			 
334d			.mloopnotdone: 
334d			 
334d e1				pop hl    ; get I 
334e 2b				dec hl 
334f			 
334f			   	; save new I 
334f			 
334f			 
334f					; set I counter 
334f			 
334f 22 ec e5				ld (os_current_i), hl 
3352			 
3352					 
3352				FORTH_LOOP_NEXT 
3352 cd 86 1e			call macro_forth_loop_next 
3355				endm 
# End of macro FORTH_LOOP_NEXT
3355			 
3355			 
3355					if DEBUG_FORTH_WORDS 
3355 eb						ex de,hl 
3356					endif 
3356			 
3356			;	; get DO ptr 
3356			; 
3356				FORTH_RSP_TOS 
3356 cd 1c 1c			call macro_forth_rsp_tos 
3359				endm 
# End of macro FORTH_RSP_TOS
3359			 
3359				;push hl 
3359			 
3359				; not going to DO any more 
3359				; get rid of the RSP pointer as DO will add it back in 
3359				;FORTH_RSP_POP 
3359				;pop hl 
3359			 
3359			 
3359 22 c8 e5			ld (os_tok_ptr), hl 
335c					if DEBUG_FORTH_WORDS 
335c						DMARK "-L<" 
335c f5				push af  
335d 3a 71 33			ld a, (.dmark)  
3360 32 71 ee			ld (debug_mark),a  
3363 3a 72 33			ld a, (.dmark+1)  
3366 32 72 ee			ld (debug_mark+1),a  
3369 3a 73 33			ld a, (.dmark+2)  
336c 32 73 ee			ld (debug_mark+2),a  
336f 18 03			jr .pastdmark  
3371 ..			.dmark: db "-L<"  
3374 f1			.pastdmark: pop af  
3375			endm  
# End of macro DMARK
3375					CALLMONITOR 
3375 cd e8 15			call break_point_state  
3378				endm  
# End of macro CALLMONITOR
3378				endif 
3378 c3 9c 20			jp exec1 
337b			 
337b					 
337b			 
337b			 
337b			 
337b				NEXTW 
337b c3 0b 20			jp macro_next 
337e				endm 
# End of macro NEXTW
337e			 
337e			 
337e			 
337e			 
337e			.REPEAT: 
337e				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
337e 71				db WORD_SYS_CORE+93             
337f d1 33			dw .UNTIL            
3381 06				db 5 + 1 
3382 .. 00			db "REPEAT",0              
3389				endm 
# End of macro CWHEAD
3389			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3389			;  push pc to rsp stack past the REPEAT 
3389					if DEBUG_FORTH_WORDS_KEY 
3389						DMARK "REP" 
3389 f5				push af  
338a 3a 9e 33			ld a, (.dmark)  
338d 32 71 ee			ld (debug_mark),a  
3390 3a 9f 33			ld a, (.dmark+1)  
3393 32 72 ee			ld (debug_mark+1),a  
3396 3a a0 33			ld a, (.dmark+2)  
3399 32 73 ee			ld (debug_mark+2),a  
339c 18 03			jr .pastdmark  
339e ..			.dmark: db "REP"  
33a1 f1			.pastdmark: pop af  
33a2			endm  
# End of macro DMARK
33a2						CALLMONITOR 
33a2 cd e8 15			call break_point_state  
33a5				endm  
# End of macro CALLMONITOR
33a5					endif 
33a5			 
33a5 2a c8 e5				ld hl, (os_tok_ptr) 
33a8 23					inc hl   ; R 
33a9 23					inc hl  ; E 
33aa 23					inc hl   ; P 
33ab 23					inc hl   ; E 
33ac 23					inc hl   ; A 
33ad 23					inc hl   ; T 
33ae 23					inc hl   ; zero 
33af					FORTH_RSP_NEXT 
33af cd 05 1c			call macro_forth_rsp_next 
33b2				endm 
# End of macro FORTH_RSP_NEXT
33b2			 
33b2			 
33b2					if DEBUG_FORTH_WORDS 
33b2						DMARK "REP" 
33b2 f5				push af  
33b3 3a c7 33			ld a, (.dmark)  
33b6 32 71 ee			ld (debug_mark),a  
33b9 3a c8 33			ld a, (.dmark+1)  
33bc 32 72 ee			ld (debug_mark+1),a  
33bf 3a c9 33			ld a, (.dmark+2)  
33c2 32 73 ee			ld (debug_mark+2),a  
33c5 18 03			jr .pastdmark  
33c7 ..			.dmark: db "REP"  
33ca f1			.pastdmark: pop af  
33cb			endm  
# End of macro DMARK
33cb						;pop bc    ; TODO BUG ?????? what is this for???? 
33cb						CALLMONITOR 
33cb cd e8 15			call break_point_state  
33ce				endm  
# End of macro CALLMONITOR
33ce					endif 
33ce			 
33ce					NEXTW 
33ce c3 0b 20			jp macro_next 
33d1				endm 
# End of macro NEXTW
33d1			;	       NEXTW 
33d1			 
33d1			.UNTIL: 
33d1				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33d1 72				db WORD_SYS_CORE+94             
33d2 68 34			dw .ENDFLOW            
33d4 06				db 5 + 1 
33d5 .. 00			db "UNTIL",0              
33db				endm 
# End of macro CWHEAD
33db			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33db			 
33db				; pop tos as check 
33db			 
33db				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33db			 
33db				FORTH_DSP_VALUEHL 
33db cd 55 1e			call macro_dsp_valuehl 
33de				endm 
# End of macro FORTH_DSP_VALUEHL
33de			 
33de					if DEBUG_FORTH_WORDS_KEY 
33de						DMARK "UNT" 
33de f5				push af  
33df 3a f3 33			ld a, (.dmark)  
33e2 32 71 ee			ld (debug_mark),a  
33e5 3a f4 33			ld a, (.dmark+1)  
33e8 32 72 ee			ld (debug_mark+1),a  
33eb 3a f5 33			ld a, (.dmark+2)  
33ee 32 73 ee			ld (debug_mark+2),a  
33f1 18 03			jr .pastdmark  
33f3 ..			.dmark: db "UNT"  
33f6 f1			.pastdmark: pop af  
33f7			endm  
# End of macro DMARK
33f7						CALLMONITOR 
33f7 cd e8 15			call break_point_state  
33fa				endm  
# End of macro CALLMONITOR
33fa					endif 
33fa			 
33fa			;	push hl 
33fa				FORTH_DSP_POP 
33fa cd 0d 1f			call macro_forth_dsp_pop 
33fd				endm 
# End of macro FORTH_DSP_POP
33fd			 
33fd			;	pop hl 
33fd			 
33fd				; test if true 
33fd			 
33fd cd 10 0e			call ishlzero 
3400			;	ld a,l 
3400			;	add h 
3400			; 
3400			;	cp 0 
3400			 
3400 20 3e			jr nz, .untilnotdone 
3402			 
3402					if DEBUG_FORTH_WORDS 
3402						DMARK "UNf" 
3402 f5				push af  
3403 3a 17 34			ld a, (.dmark)  
3406 32 71 ee			ld (debug_mark),a  
3409 3a 18 34			ld a, (.dmark+1)  
340c 32 72 ee			ld (debug_mark+1),a  
340f 3a 19 34			ld a, (.dmark+2)  
3412 32 73 ee			ld (debug_mark+2),a  
3415 18 03			jr .pastdmark  
3417 ..			.dmark: db "UNf"  
341a f1			.pastdmark: pop af  
341b			endm  
# End of macro DMARK
341b						CALLMONITOR 
341b cd e8 15			call break_point_state  
341e				endm  
# End of macro CALLMONITOR
341e					endif 
341e			 
341e			 
341e			 
341e				FORTH_RSP_POP     ; get rid of DO ptr 
341e cd 26 1c			call macro_forth_rsp_pop 
3421				endm 
# End of macro FORTH_RSP_POP
3421			 
3421			if DEBUG_FORTH_WORDS 
3421						DMARK "UN>" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 71 ee			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 72 ee			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 73 ee			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "UN>"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a				CALLMONITOR 
343a cd e8 15			call break_point_state  
343d				endm  
# End of macro CALLMONITOR
343d			endif 
343d			 
343d					NEXTW 
343d c3 0b 20			jp macro_next 
3440				endm 
# End of macro NEXTW
3440				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3440			 
3440			.untilnotdone: 
3440			 
3440			 
3440			;	; get DO ptr 
3440			; 
3440				FORTH_RSP_TOS 
3440 cd 1c 1c			call macro_forth_rsp_tos 
3443				endm 
# End of macro FORTH_RSP_TOS
3443			 
3443				;push hl 
3443			 
3443				; not going to DO any more 
3443				; get rid of the RSP pointer as DO will add it back in 
3443				;FORTH_RSP_POP 
3443				;pop hl 
3443			 
3443			 
3443 22 c8 e5			ld (os_tok_ptr), hl 
3446					if DEBUG_FORTH_WORDS 
3446						DMARK "UN<" 
3446 f5				push af  
3447 3a 5b 34			ld a, (.dmark)  
344a 32 71 ee			ld (debug_mark),a  
344d 3a 5c 34			ld a, (.dmark+1)  
3450 32 72 ee			ld (debug_mark+1),a  
3453 3a 5d 34			ld a, (.dmark+2)  
3456 32 73 ee			ld (debug_mark+2),a  
3459 18 03			jr .pastdmark  
345b ..			.dmark: db "UN<"  
345e f1			.pastdmark: pop af  
345f			endm  
# End of macro DMARK
345f					CALLMONITOR 
345f cd e8 15			call break_point_state  
3462				endm  
# End of macro CALLMONITOR
3462				endif 
3462 c3 9c 20			jp exec1 
3465			 
3465					 
3465			 
3465			 
3465					NEXTW 
3465 c3 0b 20			jp macro_next 
3468				endm 
# End of macro NEXTW
3468			 
3468			 
3468			.ENDFLOW: 
3468			 
3468			; eof 
3468			 
# End of file forth_words_flow.asm
3468			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3468			include "forth_words_logic.asm" 
3468			 
3468			; | ## Logic Words 
3468			 
3468			.NOT: 
3468				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3468 2d				db WORD_SYS_CORE+25             
3469 b0 34			dw .IS            
346b 04				db 3 + 1 
346c .. 00			db "NOT",0              
3470				endm 
# End of macro CWHEAD
3470			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3470					if DEBUG_FORTH_WORDS_KEY 
3470						DMARK "NOT" 
3470 f5				push af  
3471 3a 85 34			ld a, (.dmark)  
3474 32 71 ee			ld (debug_mark),a  
3477 3a 86 34			ld a, (.dmark+1)  
347a 32 72 ee			ld (debug_mark+1),a  
347d 3a 87 34			ld a, (.dmark+2)  
3480 32 73 ee			ld (debug_mark+2),a  
3483 18 03			jr .pastdmark  
3485 ..			.dmark: db "NOT"  
3488 f1			.pastdmark: pop af  
3489			endm  
# End of macro DMARK
3489						CALLMONITOR 
3489 cd e8 15			call break_point_state  
348c				endm  
# End of macro CALLMONITOR
348c					endif 
348c					FORTH_DSP 
348c cd 1b 1e			call macro_forth_dsp 
348f				endm 
# End of macro FORTH_DSP
348f 7e					ld a,(hl)	; get type of value on TOS 
3490 fe 02				cp DS_TYPE_INUM  
3492 28 03				jr z, .noti 
3494					NEXTW 
3494 c3 0b 20			jp macro_next 
3497				endm 
# End of macro NEXTW
3497			.noti:          FORTH_DSP_VALUEHL 
3497 cd 55 1e			call macro_dsp_valuehl 
349a				endm 
# End of macro FORTH_DSP_VALUEHL
349a			;		push hl 
349a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
349a cd 0d 1f			call macro_forth_dsp_pop 
349d				endm 
# End of macro FORTH_DSP_POP
349d			;		pop hl 
349d 3e 00				ld a,0 
349f bd					cp l 
34a0 28 04				jr z, .not2t 
34a2 2e 00				ld l, 0 
34a4 18 02				jr .notip 
34a6			 
34a6 2e ff		.not2t:		ld l, 255 
34a8			 
34a8 26 00		.notip:		ld h, 0	 
34aa			 
34aa cd 5e 1c				call forth_push_numhl 
34ad					NEXTW 
34ad c3 0b 20			jp macro_next 
34b0				endm 
# End of macro NEXTW
34b0			 
34b0			.IS: 
34b0				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34b0 2d				db WORD_SYS_CORE+25             
34b1 d6 34			dw .LZERO            
34b3 03				db 2 + 1 
34b4 .. 00			db "IS",0              
34b7				endm 
# End of macro CWHEAD
34b7			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34b7					if DEBUG_FORTH_WORDS_KEY 
34b7						DMARK "IS." 
34b7 f5				push af  
34b8 3a cc 34			ld a, (.dmark)  
34bb 32 71 ee			ld (debug_mark),a  
34be 3a cd 34			ld a, (.dmark+1)  
34c1 32 72 ee			ld (debug_mark+1),a  
34c4 3a ce 34			ld a, (.dmark+2)  
34c7 32 73 ee			ld (debug_mark+2),a  
34ca 18 03			jr .pastdmark  
34cc ..			.dmark: db "IS."  
34cf f1			.pastdmark: pop af  
34d0			endm  
# End of macro DMARK
34d0						CALLMONITOR 
34d0 cd e8 15			call break_point_state  
34d3				endm  
# End of macro CALLMONITOR
34d3					endif 
34d3					NEXTW 
34d3 c3 0b 20			jp macro_next 
34d6				endm 
# End of macro NEXTW
34d6			.LZERO: 
34d6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34d6 2d				db WORD_SYS_CORE+25             
34d7 e0 34			dw .TZERO            
34d9 03				db 2 + 1 
34da .. 00			db "0<",0              
34dd				endm 
# End of macro CWHEAD
34dd			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34dd					NEXTW 
34dd c3 0b 20			jp macro_next 
34e0				endm 
# End of macro NEXTW
34e0			.TZERO: 
34e0				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34e0 2e				db WORD_SYS_CORE+26             
34e1 27 35			dw .LESS            
34e3 03				db 2 + 1 
34e4 .. 00			db "0=",0              
34e7				endm 
# End of macro CWHEAD
34e7			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34e7				; TODO add floating point number detection 
34e7					;v5 FORTH_DSP_VALUE 
34e7					if DEBUG_FORTH_WORDS_KEY 
34e7						DMARK "0=." 
34e7 f5				push af  
34e8 3a fc 34			ld a, (.dmark)  
34eb 32 71 ee			ld (debug_mark),a  
34ee 3a fd 34			ld a, (.dmark+1)  
34f1 32 72 ee			ld (debug_mark+1),a  
34f4 3a fe 34			ld a, (.dmark+2)  
34f7 32 73 ee			ld (debug_mark+2),a  
34fa 18 03			jr .pastdmark  
34fc ..			.dmark: db "0=."  
34ff f1			.pastdmark: pop af  
3500			endm  
# End of macro DMARK
3500						CALLMONITOR 
3500 cd e8 15			call break_point_state  
3503				endm  
# End of macro CALLMONITOR
3503					endif 
3503					FORTH_DSP 
3503 cd 1b 1e			call macro_forth_dsp 
3506				endm 
# End of macro FORTH_DSP
3506 7e					ld a,(hl)	; get type of value on TOS 
3507 fe 02				cp DS_TYPE_INUM  
3509 28 00				jr z, .tz_inum 
350b			 
350b				if FORTH_ENABLE_FLOATMATH 
350b					jr .tz_done 
350b			 
350b				endif 
350b					 
350b			 
350b			.tz_inum: 
350b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350b cd 55 1e			call macro_dsp_valuehl 
350e				endm 
# End of macro FORTH_DSP_VALUEHL
350e			 
350e			;		push hl 
350e			 
350e					; destroy value TOS 
350e			 
350e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350e cd 0d 1f			call macro_forth_dsp_pop 
3511				endm 
# End of macro FORTH_DSP_POP
3511			 
3511			;		pop hl 
3511			 
3511 3e 00				ld a,0 
3513			 
3513 bd					cp l 
3514 20 08				jr nz, .tz_notzero 
3516			 
3516 bc					cp h 
3517			 
3517 20 05				jr nz, .tz_notzero 
3519			 
3519			 
3519 21 01 00				ld hl, FORTH_TRUE 
351c 18 03				jr .tz_done 
351e			 
351e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3521			 
3521					; push value back onto stack for another op etc 
3521			 
3521			.tz_done: 
3521 cd 5e 1c				call forth_push_numhl 
3524			 
3524					NEXTW 
3524 c3 0b 20			jp macro_next 
3527				endm 
# End of macro NEXTW
3527			.LESS: 
3527				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3527 2f				db WORD_SYS_CORE+27             
3528 90 35			dw .GT            
352a 02				db 1 + 1 
352b .. 00			db "<",0              
352d				endm 
# End of macro CWHEAD
352d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
352d				; TODO add floating point number detection 
352d					if DEBUG_FORTH_WORDS_KEY 
352d						DMARK "LES" 
352d f5				push af  
352e 3a 42 35			ld a, (.dmark)  
3531 32 71 ee			ld (debug_mark),a  
3534 3a 43 35			ld a, (.dmark+1)  
3537 32 72 ee			ld (debug_mark+1),a  
353a 3a 44 35			ld a, (.dmark+2)  
353d 32 73 ee			ld (debug_mark+2),a  
3540 18 03			jr .pastdmark  
3542 ..			.dmark: db "LES"  
3545 f1			.pastdmark: pop af  
3546			endm  
# End of macro DMARK
3546						CALLMONITOR 
3546 cd e8 15			call break_point_state  
3549				endm  
# End of macro CALLMONITOR
3549					endif 
3549					FORTH_DSP 
3549 cd 1b 1e			call macro_forth_dsp 
354c				endm 
# End of macro FORTH_DSP
354c					;v5 FORTH_DSP_VALUE 
354c 7e					ld a,(hl)	; get type of value on TOS 
354d fe 02				cp DS_TYPE_INUM  
354f 28 00				jr z, .less_inum 
3551			 
3551				if FORTH_ENABLE_FLOATMATH 
3551					jr .less_done 
3551			 
3551				endif 
3551					 
3551			 
3551			.less_inum: 
3551					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3551 cd 55 1e			call macro_dsp_valuehl 
3554				endm 
# End of macro FORTH_DSP_VALUEHL
3554			 
3554 e5					push hl  ; u2 
3555			 
3555					; destroy value TOS 
3555			 
3555					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3555 cd 0d 1f			call macro_forth_dsp_pop 
3558				endm 
# End of macro FORTH_DSP_POP
3558			 
3558			 
3558					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3558 cd 55 1e			call macro_dsp_valuehl 
355b				endm 
# End of macro FORTH_DSP_VALUEHL
355b			 
355b e5					push hl    ; u1 
355c			 
355c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
355c cd 0d 1f			call macro_forth_dsp_pop 
355f				endm 
# End of macro FORTH_DSP_POP
355f			 
355f			 
355f b7			 or a      ;clear carry flag 
3560 01 00 00		 ld bc, FORTH_FALSE 
3563 e1			  pop hl    ; u1 
3564 d1			  pop de    ; u2 
3565 ed 52		  sbc hl,de 
3567 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3569			 
3569 01 01 00		 ld bc, FORTH_TRUE 
356c			.lscont:  
356c c5					push bc 
356d e1					pop hl 
356e			 
356e					if DEBUG_FORTH_WORDS 
356e						DMARK "LT1" 
356e f5				push af  
356f 3a 83 35			ld a, (.dmark)  
3572 32 71 ee			ld (debug_mark),a  
3575 3a 84 35			ld a, (.dmark+1)  
3578 32 72 ee			ld (debug_mark+1),a  
357b 3a 85 35			ld a, (.dmark+2)  
357e 32 73 ee			ld (debug_mark+2),a  
3581 18 03			jr .pastdmark  
3583 ..			.dmark: db "LT1"  
3586 f1			.pastdmark: pop af  
3587			endm  
# End of macro DMARK
3587						CALLMONITOR 
3587 cd e8 15			call break_point_state  
358a				endm  
# End of macro CALLMONITOR
358a					endif 
358a cd 5e 1c				call forth_push_numhl 
358d			 
358d					NEXTW 
358d c3 0b 20			jp macro_next 
3590				endm 
# End of macro NEXTW
3590			.GT: 
3590				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3590 30				db WORD_SYS_CORE+28             
3591 f9 35			dw .EQUAL            
3593 02				db 1 + 1 
3594 .. 00			db ">",0              
3596				endm 
# End of macro CWHEAD
3596			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3596				; TODO add floating point number detection 
3596					if DEBUG_FORTH_WORDS_KEY 
3596						DMARK "GRT" 
3596 f5				push af  
3597 3a ab 35			ld a, (.dmark)  
359a 32 71 ee			ld (debug_mark),a  
359d 3a ac 35			ld a, (.dmark+1)  
35a0 32 72 ee			ld (debug_mark+1),a  
35a3 3a ad 35			ld a, (.dmark+2)  
35a6 32 73 ee			ld (debug_mark+2),a  
35a9 18 03			jr .pastdmark  
35ab ..			.dmark: db "GRT"  
35ae f1			.pastdmark: pop af  
35af			endm  
# End of macro DMARK
35af						CALLMONITOR 
35af cd e8 15			call break_point_state  
35b2				endm  
# End of macro CALLMONITOR
35b2					endif 
35b2					FORTH_DSP 
35b2 cd 1b 1e			call macro_forth_dsp 
35b5				endm 
# End of macro FORTH_DSP
35b5					;FORTH_DSP_VALUE 
35b5 7e					ld a,(hl)	; get type of value on TOS 
35b6 fe 02				cp DS_TYPE_INUM  
35b8 28 00				jr z, .gt_inum 
35ba			 
35ba				if FORTH_ENABLE_FLOATMATH 
35ba					jr .gt_done 
35ba			 
35ba				endif 
35ba					 
35ba			 
35ba			.gt_inum: 
35ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ba cd 55 1e			call macro_dsp_valuehl 
35bd				endm 
# End of macro FORTH_DSP_VALUEHL
35bd			 
35bd e5					push hl  ; u2 
35be			 
35be					; destroy value TOS 
35be			 
35be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35be cd 0d 1f			call macro_forth_dsp_pop 
35c1				endm 
# End of macro FORTH_DSP_POP
35c1			 
35c1			 
35c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35c1 cd 55 1e			call macro_dsp_valuehl 
35c4				endm 
# End of macro FORTH_DSP_VALUEHL
35c4			 
35c4 e5					push hl    ; u1 
35c5			 
35c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35c5 cd 0d 1f			call macro_forth_dsp_pop 
35c8				endm 
# End of macro FORTH_DSP_POP
35c8			 
35c8			 
35c8 b7			 or a      ;clear carry flag 
35c9 01 00 00		 ld bc, FORTH_FALSE 
35cc e1			  pop hl    ; u1 
35cd d1			  pop de    ; u2 
35ce ed 52		  sbc hl,de 
35d0 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35d2			 
35d2 01 01 00		 ld bc, FORTH_TRUE 
35d5			.gtcont:  
35d5 c5					push bc 
35d6 e1					pop hl 
35d7			 
35d7					if DEBUG_FORTH_WORDS 
35d7						DMARK "GT1" 
35d7 f5				push af  
35d8 3a ec 35			ld a, (.dmark)  
35db 32 71 ee			ld (debug_mark),a  
35de 3a ed 35			ld a, (.dmark+1)  
35e1 32 72 ee			ld (debug_mark+1),a  
35e4 3a ee 35			ld a, (.dmark+2)  
35e7 32 73 ee			ld (debug_mark+2),a  
35ea 18 03			jr .pastdmark  
35ec ..			.dmark: db "GT1"  
35ef f1			.pastdmark: pop af  
35f0			endm  
# End of macro DMARK
35f0						CALLMONITOR 
35f0 cd e8 15			call break_point_state  
35f3				endm  
# End of macro CALLMONITOR
35f3					endif 
35f3 cd 5e 1c				call forth_push_numhl 
35f6			 
35f6					NEXTW 
35f6 c3 0b 20			jp macro_next 
35f9				endm 
# End of macro NEXTW
35f9			.EQUAL: 
35f9				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35f9 31				db WORD_SYS_CORE+29             
35fa 64 36			dw .ENDLOGIC            
35fc 02				db 1 + 1 
35fd .. 00			db "=",0              
35ff				endm 
# End of macro CWHEAD
35ff			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35ff				; TODO add floating point number detection 
35ff					if DEBUG_FORTH_WORDS_KEY 
35ff						DMARK "EQ." 
35ff f5				push af  
3600 3a 14 36			ld a, (.dmark)  
3603 32 71 ee			ld (debug_mark),a  
3606 3a 15 36			ld a, (.dmark+1)  
3609 32 72 ee			ld (debug_mark+1),a  
360c 3a 16 36			ld a, (.dmark+2)  
360f 32 73 ee			ld (debug_mark+2),a  
3612 18 03			jr .pastdmark  
3614 ..			.dmark: db "EQ."  
3617 f1			.pastdmark: pop af  
3618			endm  
# End of macro DMARK
3618						CALLMONITOR 
3618 cd e8 15			call break_point_state  
361b				endm  
# End of macro CALLMONITOR
361b					endif 
361b					FORTH_DSP 
361b cd 1b 1e			call macro_forth_dsp 
361e				endm 
# End of macro FORTH_DSP
361e					;v5 FORTH_DSP_VALUE 
361e 7e					ld a,(hl)	; get type of value on TOS 
361f fe 02				cp DS_TYPE_INUM  
3621 28 00				jr z, .eq_inum 
3623			 
3623				if FORTH_ENABLE_FLOATMATH 
3623					jr .eq_done 
3623			 
3623				endif 
3623					 
3623			 
3623			.eq_inum: 
3623					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3623 cd 55 1e			call macro_dsp_valuehl 
3626				endm 
# End of macro FORTH_DSP_VALUEHL
3626			 
3626 e5					push hl 
3627			 
3627					; destroy value TOS 
3627			 
3627					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3627 cd 0d 1f			call macro_forth_dsp_pop 
362a				endm 
# End of macro FORTH_DSP_POP
362a			 
362a			 
362a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
362a cd 55 1e			call macro_dsp_valuehl 
362d				endm 
# End of macro FORTH_DSP_VALUEHL
362d			 
362d					; one value on hl get other one back 
362d			 
362d e5					push hl 
362e			 
362e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
362e cd 0d 1f			call macro_forth_dsp_pop 
3631				endm 
# End of macro FORTH_DSP_POP
3631			 
3631 0e 00				ld c, FORTH_FALSE 
3633			 
3633 e1					pop hl 
3634 d1					pop de 
3635			 
3635 7b					ld a, e 
3636 bd					cp l 
3637			 
3637 20 06				jr nz, .eq_done 
3639			 
3639 7a					ld a, d 
363a bc					cp h 
363b			 
363b 20 02				jr nz, .eq_done 
363d			 
363d 0e 01				ld c, FORTH_TRUE 
363f					 
363f			 
363f			 
363f			.eq_done: 
363f			 
363f					; TODO push value back onto stack for another op etc 
363f			 
363f 26 00				ld h, 0 
3641 69					ld l, c 
3642					if DEBUG_FORTH_WORDS 
3642						DMARK "EQ1" 
3642 f5				push af  
3643 3a 57 36			ld a, (.dmark)  
3646 32 71 ee			ld (debug_mark),a  
3649 3a 58 36			ld a, (.dmark+1)  
364c 32 72 ee			ld (debug_mark+1),a  
364f 3a 59 36			ld a, (.dmark+2)  
3652 32 73 ee			ld (debug_mark+2),a  
3655 18 03			jr .pastdmark  
3657 ..			.dmark: db "EQ1"  
365a f1			.pastdmark: pop af  
365b			endm  
# End of macro DMARK
365b						CALLMONITOR 
365b cd e8 15			call break_point_state  
365e				endm  
# End of macro CALLMONITOR
365e					endif 
365e cd 5e 1c				call forth_push_numhl 
3661			 
3661					NEXTW 
3661 c3 0b 20			jp macro_next 
3664				endm 
# End of macro NEXTW
3664			 
3664			 
3664			.ENDLOGIC: 
3664			; eof 
3664			 
3664			 
# End of file forth_words_logic.asm
3664			include "forth_words_maths.asm" 
3664			 
3664			; | ## Maths Words 
3664			 
3664			.PLUS:	 
3664				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3664 15				db WORD_SYS_CORE+1             
3665 c2 36			dw .NEG            
3667 02				db 1 + 1 
3668 .. 00			db "+",0              
366a				endm 
# End of macro CWHEAD
366a			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
366a					if DEBUG_FORTH_WORDS_KEY 
366a						DMARK "PLU" 
366a f5				push af  
366b 3a 7f 36			ld a, (.dmark)  
366e 32 71 ee			ld (debug_mark),a  
3671 3a 80 36			ld a, (.dmark+1)  
3674 32 72 ee			ld (debug_mark+1),a  
3677 3a 81 36			ld a, (.dmark+2)  
367a 32 73 ee			ld (debug_mark+2),a  
367d 18 03			jr .pastdmark  
367f ..			.dmark: db "PLU"  
3682 f1			.pastdmark: pop af  
3683			endm  
# End of macro DMARK
3683						CALLMONITOR 
3683 cd e8 15			call break_point_state  
3686				endm  
# End of macro CALLMONITOR
3686					endif 
3686					; add top two values and push back result 
3686			 
3686					;for v5 FORTH_DSP_VALUE 
3686					FORTH_DSP 
3686 cd 1b 1e			call macro_forth_dsp 
3689				endm 
# End of macro FORTH_DSP
3689 7e					ld a,(hl)	; get type of value on TOS 
368a fe 02				cp DS_TYPE_INUM  
368c 28 03				jr z, .dot_inum 
368e			 
368e					NEXTW 
368e c3 0b 20			jp macro_next 
3691				endm 
# End of macro NEXTW
3691			 
3691			; float maths 
3691			 
3691				if FORTH_ENABLE_FLOATMATH 
3691						inc hl      ; now at start of numeric as string 
3691			 
3691					if DEBUG_FORTH_MATHS 
3691						DMARK "ADD" 
3691				CALLMONITOR 
3691					endif 
3691			 
3691					;ld ix, hl 
3691					call CON 
3691			 
3691			 
3691					push hl 
3691					 
3691					 
3691			 
3691						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3691			 
3691					; get next number 
3691			 
3691						FORTH_DSP_VALUE 
3691			 
3691						inc hl      ; now at start of numeric as string 
3691			 
3691					;ld ix, hl 
3691					call CON 
3691			 
3691					push hl 
3691			 
3691			 
3691						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3691			 
3691						; TODO do add 
3691			 
3691						call IADD 
3691			 
3691						; TODO get result back as ascii 
3691			 
3691						; TODO push result  
3691			 
3691			 
3691			 
3691						jr .dot_done 
3691				endif 
3691			 
3691			.dot_inum: 
3691			 
3691			 
3691					if DEBUG_FORTH_DOT 
3691						DMARK "+IT" 
3691 f5				push af  
3692 3a a6 36			ld a, (.dmark)  
3695 32 71 ee			ld (debug_mark),a  
3698 3a a7 36			ld a, (.dmark+1)  
369b 32 72 ee			ld (debug_mark+1),a  
369e 3a a8 36			ld a, (.dmark+2)  
36a1 32 73 ee			ld (debug_mark+2),a  
36a4 18 03			jr .pastdmark  
36a6 ..			.dmark: db "+IT"  
36a9 f1			.pastdmark: pop af  
36aa			endm  
# End of macro DMARK
36aa				CALLMONITOR 
36aa cd e8 15			call break_point_state  
36ad				endm  
# End of macro CALLMONITOR
36ad					endif 
36ad			 
36ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ad cd 55 1e			call macro_dsp_valuehl 
36b0				endm 
# End of macro FORTH_DSP_VALUEHL
36b0			 
36b0				; TODO add floating point number detection 
36b0			 
36b0 e5					push hl 
36b1			 
36b1					; destroy value TOS 
36b1			 
36b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b1 cd 0d 1f			call macro_forth_dsp_pop 
36b4				endm 
# End of macro FORTH_DSP_POP
36b4			 
36b4			 
36b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b4 cd 55 1e			call macro_dsp_valuehl 
36b7				endm 
# End of macro FORTH_DSP_VALUEHL
36b7			 
36b7					; one value on hl get other one back 
36b7			 
36b7 d1					pop de 
36b8			 
36b8					; do the add 
36b8			 
36b8 19					add hl,de 
36b9			 
36b9					; save it 
36b9			 
36b9			;		push hl	 
36b9			 
36b9					; 
36b9			 
36b9					; destroy value TOS 
36b9			 
36b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b9 cd 0d 1f			call macro_forth_dsp_pop 
36bc				endm 
# End of macro FORTH_DSP_POP
36bc			 
36bc					; TODO push value back onto stack for another op etc 
36bc			 
36bc			;		pop hl 
36bc			 
36bc			.dot_done: 
36bc cd 5e 1c				call forth_push_numhl 
36bf			 
36bf					NEXTW 
36bf c3 0b 20			jp macro_next 
36c2				endm 
# End of macro NEXTW
36c2			.NEG: 
36c2			 
36c2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36c2 17				db WORD_SYS_CORE+3             
36c3 05 37			dw .DIV            
36c5 02				db 1 + 1 
36c6 .. 00			db "-",0              
36c8				endm 
# End of macro CWHEAD
36c8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36c8					if DEBUG_FORTH_WORDS_KEY 
36c8						DMARK "SUB" 
36c8 f5				push af  
36c9 3a dd 36			ld a, (.dmark)  
36cc 32 71 ee			ld (debug_mark),a  
36cf 3a de 36			ld a, (.dmark+1)  
36d2 32 72 ee			ld (debug_mark+1),a  
36d5 3a df 36			ld a, (.dmark+2)  
36d8 32 73 ee			ld (debug_mark+2),a  
36db 18 03			jr .pastdmark  
36dd ..			.dmark: db "SUB"  
36e0 f1			.pastdmark: pop af  
36e1			endm  
# End of macro DMARK
36e1						CALLMONITOR 
36e1 cd e8 15			call break_point_state  
36e4				endm  
# End of macro CALLMONITOR
36e4					endif 
36e4			 
36e4			 
36e4				; TODO add floating point number detection 
36e4					; v5 FORTH_DSP_VALUE 
36e4					FORTH_DSP 
36e4 cd 1b 1e			call macro_forth_dsp 
36e7				endm 
# End of macro FORTH_DSP
36e7 7e					ld a,(hl)	; get type of value on TOS 
36e8 fe 02				cp DS_TYPE_INUM  
36ea 28 03				jr z, .neg_inum 
36ec			 
36ec					NEXTW 
36ec c3 0b 20			jp macro_next 
36ef				endm 
# End of macro NEXTW
36ef			 
36ef			; float maths 
36ef			 
36ef				if FORTH_ENABLE_FLOATMATH 
36ef					jr .neg_done 
36ef			 
36ef				endif 
36ef					 
36ef			 
36ef			.neg_inum: 
36ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ef cd 55 1e			call macro_dsp_valuehl 
36f2				endm 
# End of macro FORTH_DSP_VALUEHL
36f2			 
36f2 e5					push hl 
36f3			 
36f3					; destroy value TOS 
36f3			 
36f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f3 cd 0d 1f			call macro_forth_dsp_pop 
36f6				endm 
# End of macro FORTH_DSP_POP
36f6			 
36f6			 
36f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f6 cd 55 1e			call macro_dsp_valuehl 
36f9				endm 
# End of macro FORTH_DSP_VALUEHL
36f9			 
36f9					; one value on hl get other one back 
36f9			 
36f9 d1					pop de 
36fa			 
36fa					; do the sub 
36fa			;		ex de, hl 
36fa			 
36fa ed 52				sbc hl,de 
36fc			 
36fc					; save it 
36fc			 
36fc			;		push hl	 
36fc			 
36fc					; 
36fc			 
36fc					; destroy value TOS 
36fc			 
36fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fc cd 0d 1f			call macro_forth_dsp_pop 
36ff				endm 
# End of macro FORTH_DSP_POP
36ff			 
36ff					; TODO push value back onto stack for another op etc 
36ff			 
36ff			;		pop hl 
36ff			 
36ff cd 5e 1c				call forth_push_numhl 
3702			.neg_done: 
3702			 
3702					NEXTW 
3702 c3 0b 20			jp macro_next 
3705				endm 
# End of macro NEXTW
3705			.DIV: 
3705				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3705 18				db WORD_SYS_CORE+4             
3706 52 37			dw .MUL            
3708 02				db 1 + 1 
3709 .. 00			db "/",0              
370b				endm 
# End of macro CWHEAD
370b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
370b					if DEBUG_FORTH_WORDS_KEY 
370b						DMARK "DIV" 
370b f5				push af  
370c 3a 20 37			ld a, (.dmark)  
370f 32 71 ee			ld (debug_mark),a  
3712 3a 21 37			ld a, (.dmark+1)  
3715 32 72 ee			ld (debug_mark+1),a  
3718 3a 22 37			ld a, (.dmark+2)  
371b 32 73 ee			ld (debug_mark+2),a  
371e 18 03			jr .pastdmark  
3720 ..			.dmark: db "DIV"  
3723 f1			.pastdmark: pop af  
3724			endm  
# End of macro DMARK
3724						CALLMONITOR 
3724 cd e8 15			call break_point_state  
3727				endm  
# End of macro CALLMONITOR
3727					endif 
3727				; TODO add floating point number detection 
3727					; v5 FORTH_DSP_VALUE 
3727					FORTH_DSP 
3727 cd 1b 1e			call macro_forth_dsp 
372a				endm 
# End of macro FORTH_DSP
372a 7e					ld a,(hl)	; get type of value on TOS 
372b fe 02				cp DS_TYPE_INUM  
372d 28 03				jr z, .div_inum 
372f			 
372f				if FORTH_ENABLE_FLOATMATH 
372f					jr .div_done 
372f			 
372f				endif 
372f					NEXTW 
372f c3 0b 20			jp macro_next 
3732				endm 
# End of macro NEXTW
3732			.div_inum: 
3732			 
3732					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3732 cd 55 1e			call macro_dsp_valuehl 
3735				endm 
# End of macro FORTH_DSP_VALUEHL
3735			 
3735 e5					push hl    ; to go to bc 
3736			 
3736					; destroy value TOS 
3736			 
3736					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3736 cd 0d 1f			call macro_forth_dsp_pop 
3739				endm 
# End of macro FORTH_DSP_POP
3739			 
3739			 
3739					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3739 cd 55 1e			call macro_dsp_valuehl 
373c				endm 
# End of macro FORTH_DSP_VALUEHL
373c			 
373c					; hl to go to de 
373c			 
373c e5					push hl 
373d			 
373d c1					pop bc 
373e d1					pop de		 
373f			 
373f			 
373f					if DEBUG_FORTH_MATHS 
373f						DMARK "DIV" 
373f				CALLMONITOR 
373f					endif 
373f					; one value on hl but move to a get other one back 
373f			 
373f			        
373f cd 44 0d			call Div16 
3742			 
3742			;	push af	 
3742 e5				push hl 
3743 c5				push bc 
3744			 
3744					if DEBUG_FORTH_MATHS 
3744						DMARK "DI1" 
3744				CALLMONITOR 
3744					endif 
3744			 
3744					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3744 cd 0d 1f			call macro_forth_dsp_pop 
3747				endm 
# End of macro FORTH_DSP_POP
3747			 
3747			 
3747			 
3747 e1					pop hl    ; result 
3748			 
3748 cd 5e 1c				call forth_push_numhl 
374b			 
374b e1					pop hl    ; reminder 
374c			;		ld h,0 
374c			;		ld l,d 
374c			 
374c cd 5e 1c				call forth_push_numhl 
374f			.div_done: 
374f					NEXTW 
374f c3 0b 20			jp macro_next 
3752				endm 
# End of macro NEXTW
3752			.MUL: 
3752				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3752 19				db WORD_SYS_CORE+5             
3753 97 37			dw .MIN            
3755 02				db 1 + 1 
3756 .. 00			db "*",0              
3758				endm 
# End of macro CWHEAD
3758			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3758				; TODO add floating point number detection 
3758					if DEBUG_FORTH_WORDS_KEY 
3758						DMARK "MUL" 
3758 f5				push af  
3759 3a 6d 37			ld a, (.dmark)  
375c 32 71 ee			ld (debug_mark),a  
375f 3a 6e 37			ld a, (.dmark+1)  
3762 32 72 ee			ld (debug_mark+1),a  
3765 3a 6f 37			ld a, (.dmark+2)  
3768 32 73 ee			ld (debug_mark+2),a  
376b 18 03			jr .pastdmark  
376d ..			.dmark: db "MUL"  
3770 f1			.pastdmark: pop af  
3771			endm  
# End of macro DMARK
3771						CALLMONITOR 
3771 cd e8 15			call break_point_state  
3774				endm  
# End of macro CALLMONITOR
3774					endif 
3774					FORTH_DSP 
3774 cd 1b 1e			call macro_forth_dsp 
3777				endm 
# End of macro FORTH_DSP
3777					; v5 FORTH_DSP_VALUE 
3777 7e					ld a,(hl)	; get type of value on TOS 
3778 fe 02				cp DS_TYPE_INUM  
377a 28 03				jr z, .mul_inum 
377c			 
377c				if FORTH_ENABLE_FLOATMATH 
377c					jr .mul_done 
377c			 
377c				endif 
377c			 
377c					NEXTW 
377c c3 0b 20			jp macro_next 
377f				endm 
# End of macro NEXTW
377f			.mul_inum:	 
377f			 
377f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377f cd 55 1e			call macro_dsp_valuehl 
3782				endm 
# End of macro FORTH_DSP_VALUEHL
3782			 
3782 e5					push hl 
3783			 
3783					; destroy value TOS 
3783			 
3783					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3783 cd 0d 1f			call macro_forth_dsp_pop 
3786				endm 
# End of macro FORTH_DSP_POP
3786			 
3786			 
3786					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3786 cd 55 1e			call macro_dsp_valuehl 
3789				endm 
# End of macro FORTH_DSP_VALUEHL
3789			 
3789					; one value on hl but move to a get other one back 
3789			 
3789 7d					ld a, l 
378a			 
378a d1					pop de 
378b			 
378b					; do the mull 
378b			;		ex de, hl 
378b			 
378b cd 6a 0d				call Mult16 
378e					; save it 
378e			 
378e			;		push hl	 
378e			 
378e					; 
378e			 
378e					; destroy value TOS 
378e			 
378e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378e cd 0d 1f			call macro_forth_dsp_pop 
3791				endm 
# End of macro FORTH_DSP_POP
3791			 
3791					; TODO push value back onto stack for another op etc 
3791			 
3791			;		pop hl 
3791			 
3791 cd 5e 1c				call forth_push_numhl 
3794			 
3794			.mul_done: 
3794					NEXTW 
3794 c3 0b 20			jp macro_next 
3797				endm 
# End of macro NEXTW
3797			 
3797			 
3797			 
3797			 
3797			.MIN: 
3797				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3797 49				db WORD_SYS_CORE+53             
3798 18 38			dw .MAX            
379a 04				db 3 + 1 
379b .. 00			db "MIN",0              
379f				endm 
# End of macro CWHEAD
379f			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
379f					if DEBUG_FORTH_WORDS_KEY 
379f						DMARK "MIN" 
379f f5				push af  
37a0 3a b4 37			ld a, (.dmark)  
37a3 32 71 ee			ld (debug_mark),a  
37a6 3a b5 37			ld a, (.dmark+1)  
37a9 32 72 ee			ld (debug_mark+1),a  
37ac 3a b6 37			ld a, (.dmark+2)  
37af 32 73 ee			ld (debug_mark+2),a  
37b2 18 03			jr .pastdmark  
37b4 ..			.dmark: db "MIN"  
37b7 f1			.pastdmark: pop af  
37b8			endm  
# End of macro DMARK
37b8						CALLMONITOR 
37b8 cd e8 15			call break_point_state  
37bb				endm  
# End of macro CALLMONITOR
37bb					endif 
37bb					; get u2 
37bb			 
37bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37bb cd 55 1e			call macro_dsp_valuehl 
37be				endm 
# End of macro FORTH_DSP_VALUEHL
37be			 
37be e5					push hl   ; u2 
37bf			 
37bf					; destroy value TOS 
37bf			 
37bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37bf cd 0d 1f			call macro_forth_dsp_pop 
37c2				endm 
# End of macro FORTH_DSP_POP
37c2			 
37c2					; get u1 
37c2			 
37c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c2 cd 55 1e			call macro_dsp_valuehl 
37c5				endm 
# End of macro FORTH_DSP_VALUEHL
37c5			 
37c5 e5					push hl  ; u1 
37c6			 
37c6					; destroy value TOS 
37c6			 
37c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c6 cd 0d 1f			call macro_forth_dsp_pop 
37c9				endm 
# End of macro FORTH_DSP_POP
37c9			 
37c9 b7			 or a      ;clear carry flag 
37ca e1			  pop hl    ; u1 
37cb d1			  pop de    ; u2 
37cc e5				push hl   ; saved in case hl is lowest 
37cd ed 52		  sbc hl,de 
37cf 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37d1			 
37d1 e1				pop hl 
37d2					if DEBUG_FORTH_WORDS 
37d2						DMARK "MIN" 
37d2 f5				push af  
37d3 3a e7 37			ld a, (.dmark)  
37d6 32 71 ee			ld (debug_mark),a  
37d9 3a e8 37			ld a, (.dmark+1)  
37dc 32 72 ee			ld (debug_mark+1),a  
37df 3a e9 37			ld a, (.dmark+2)  
37e2 32 73 ee			ld (debug_mark+2),a  
37e5 18 03			jr .pastdmark  
37e7 ..			.dmark: db "MIN"  
37ea f1			.pastdmark: pop af  
37eb			endm  
# End of macro DMARK
37eb						CALLMONITOR 
37eb cd e8 15			call break_point_state  
37ee				endm  
# End of macro CALLMONITOR
37ee					endif 
37ee cd 5e 1c				call forth_push_numhl 
37f1			 
37f1				       NEXTW 
37f1 c3 0b 20			jp macro_next 
37f4				endm 
# End of macro NEXTW
37f4			 
37f4			.mincont:  
37f4 c1				pop bc   ; tidy up 
37f5 eb				ex de , hl  
37f6					if DEBUG_FORTH_WORDS 
37f6						DMARK "MI1" 
37f6 f5				push af  
37f7 3a 0b 38			ld a, (.dmark)  
37fa 32 71 ee			ld (debug_mark),a  
37fd 3a 0c 38			ld a, (.dmark+1)  
3800 32 72 ee			ld (debug_mark+1),a  
3803 3a 0d 38			ld a, (.dmark+2)  
3806 32 73 ee			ld (debug_mark+2),a  
3809 18 03			jr .pastdmark  
380b ..			.dmark: db "MI1"  
380e f1			.pastdmark: pop af  
380f			endm  
# End of macro DMARK
380f						CALLMONITOR 
380f cd e8 15			call break_point_state  
3812				endm  
# End of macro CALLMONITOR
3812					endif 
3812 cd 5e 1c				call forth_push_numhl 
3815			 
3815				       NEXTW 
3815 c3 0b 20			jp macro_next 
3818				endm 
# End of macro NEXTW
3818			.MAX: 
3818				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3818 4a				db WORD_SYS_CORE+54             
3819 99 38			dw .RND16            
381b 04				db 3 + 1 
381c .. 00			db "MAX",0              
3820				endm 
# End of macro CWHEAD
3820			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3820					if DEBUG_FORTH_WORDS_KEY 
3820						DMARK "MAX" 
3820 f5				push af  
3821 3a 35 38			ld a, (.dmark)  
3824 32 71 ee			ld (debug_mark),a  
3827 3a 36 38			ld a, (.dmark+1)  
382a 32 72 ee			ld (debug_mark+1),a  
382d 3a 37 38			ld a, (.dmark+2)  
3830 32 73 ee			ld (debug_mark+2),a  
3833 18 03			jr .pastdmark  
3835 ..			.dmark: db "MAX"  
3838 f1			.pastdmark: pop af  
3839			endm  
# End of macro DMARK
3839						CALLMONITOR 
3839 cd e8 15			call break_point_state  
383c				endm  
# End of macro CALLMONITOR
383c					endif 
383c					; get u2 
383c			 
383c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383c cd 55 1e			call macro_dsp_valuehl 
383f				endm 
# End of macro FORTH_DSP_VALUEHL
383f			 
383f e5					push hl   ; u2 
3840			 
3840					; destroy value TOS 
3840			 
3840					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3840 cd 0d 1f			call macro_forth_dsp_pop 
3843				endm 
# End of macro FORTH_DSP_POP
3843			 
3843					; get u1 
3843			 
3843					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3843 cd 55 1e			call macro_dsp_valuehl 
3846				endm 
# End of macro FORTH_DSP_VALUEHL
3846			 
3846 e5					push hl  ; u1 
3847			 
3847					; destroy value TOS 
3847			 
3847					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3847 cd 0d 1f			call macro_forth_dsp_pop 
384a				endm 
# End of macro FORTH_DSP_POP
384a			 
384a b7			 or a      ;clear carry flag 
384b e1			  pop hl    ; u1 
384c d1			  pop de    ; u2 
384d e5				push hl   ; saved in case hl is lowest 
384e ed 52		  sbc hl,de 
3850 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3852			 
3852 e1				pop hl 
3853					if DEBUG_FORTH_WORDS 
3853						DMARK "MAX" 
3853 f5				push af  
3854 3a 68 38			ld a, (.dmark)  
3857 32 71 ee			ld (debug_mark),a  
385a 3a 69 38			ld a, (.dmark+1)  
385d 32 72 ee			ld (debug_mark+1),a  
3860 3a 6a 38			ld a, (.dmark+2)  
3863 32 73 ee			ld (debug_mark+2),a  
3866 18 03			jr .pastdmark  
3868 ..			.dmark: db "MAX"  
386b f1			.pastdmark: pop af  
386c			endm  
# End of macro DMARK
386c						CALLMONITOR 
386c cd e8 15			call break_point_state  
386f				endm  
# End of macro CALLMONITOR
386f					endif 
386f cd 5e 1c				call forth_push_numhl 
3872			 
3872				       NEXTW 
3872 c3 0b 20			jp macro_next 
3875				endm 
# End of macro NEXTW
3875			 
3875			.maxcont:  
3875 c1				pop bc   ; tidy up 
3876 eb				ex de , hl  
3877					if DEBUG_FORTH_WORDS 
3877						DMARK "MA1" 
3877 f5				push af  
3878 3a 8c 38			ld a, (.dmark)  
387b 32 71 ee			ld (debug_mark),a  
387e 3a 8d 38			ld a, (.dmark+1)  
3881 32 72 ee			ld (debug_mark+1),a  
3884 3a 8e 38			ld a, (.dmark+2)  
3887 32 73 ee			ld (debug_mark+2),a  
388a 18 03			jr .pastdmark  
388c ..			.dmark: db "MA1"  
388f f1			.pastdmark: pop af  
3890			endm  
# End of macro DMARK
3890						CALLMONITOR 
3890 cd e8 15			call break_point_state  
3893				endm  
# End of macro CALLMONITOR
3893					endif 
3893 cd 5e 1c				call forth_push_numhl 
3896				       NEXTW 
3896 c3 0b 20			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			 
3899			.RND16: 
3899				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3899 4e				db WORD_SYS_CORE+58             
389a c8 38			dw .RND8            
389c 06				db 5 + 1 
389d .. 00			db "RND16",0              
38a3				endm 
# End of macro CWHEAD
38a3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38a3					if DEBUG_FORTH_WORDS_KEY 
38a3						DMARK "R16" 
38a3 f5				push af  
38a4 3a b8 38			ld a, (.dmark)  
38a7 32 71 ee			ld (debug_mark),a  
38aa 3a b9 38			ld a, (.dmark+1)  
38ad 32 72 ee			ld (debug_mark+1),a  
38b0 3a ba 38			ld a, (.dmark+2)  
38b3 32 73 ee			ld (debug_mark+2),a  
38b6 18 03			jr .pastdmark  
38b8 ..			.dmark: db "R16"  
38bb f1			.pastdmark: pop af  
38bc			endm  
# End of macro DMARK
38bc						CALLMONITOR 
38bc cd e8 15			call break_point_state  
38bf				endm  
# End of macro CALLMONITOR
38bf					endif 
38bf cd 0e 0d				call prng16  
38c2 cd 5e 1c				call forth_push_numhl 
38c5				       NEXTW 
38c5 c3 0b 20			jp macro_next 
38c8				endm 
# End of macro NEXTW
38c8			.RND8: 
38c8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38c8 60				db WORD_SYS_CORE+76             
38c9 fd 38			dw .RND            
38cb 05				db 4 + 1 
38cc .. 00			db "RND8",0              
38d1				endm 
# End of macro CWHEAD
38d1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38d1					if DEBUG_FORTH_WORDS_KEY 
38d1						DMARK "RN8" 
38d1 f5				push af  
38d2 3a e6 38			ld a, (.dmark)  
38d5 32 71 ee			ld (debug_mark),a  
38d8 3a e7 38			ld a, (.dmark+1)  
38db 32 72 ee			ld (debug_mark+1),a  
38de 3a e8 38			ld a, (.dmark+2)  
38e1 32 73 ee			ld (debug_mark+2),a  
38e4 18 03			jr .pastdmark  
38e6 ..			.dmark: db "RN8"  
38e9 f1			.pastdmark: pop af  
38ea			endm  
# End of macro DMARK
38ea						CALLMONITOR 
38ea cd e8 15			call break_point_state  
38ed				endm  
# End of macro CALLMONITOR
38ed					endif 
38ed 2a af eb				ld hl,(xrandc) 
38f0 23					inc hl 
38f1 cd 28 0d				call xrnd 
38f4 6f					ld l,a	 
38f5 26 00				ld h,0 
38f7 cd 5e 1c				call forth_push_numhl 
38fa				       NEXTW 
38fa c3 0b 20			jp macro_next 
38fd				endm 
# End of macro NEXTW
38fd			.RND: 
38fd				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38fd 60				db WORD_SYS_CORE+76             
38fe 03 3a			dw .ENDMATHS            
3900 04				db 3 + 1 
3901 .. 00			db "RND",0              
3905				endm 
# End of macro CWHEAD
3905			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3905			 
3905					if DEBUG_FORTH_WORDS_KEY 
3905						DMARK "RND" 
3905 f5				push af  
3906 3a 1a 39			ld a, (.dmark)  
3909 32 71 ee			ld (debug_mark),a  
390c 3a 1b 39			ld a, (.dmark+1)  
390f 32 72 ee			ld (debug_mark+1),a  
3912 3a 1c 39			ld a, (.dmark+2)  
3915 32 73 ee			ld (debug_mark+2),a  
3918 18 03			jr .pastdmark  
391a ..			.dmark: db "RND"  
391d f1			.pastdmark: pop af  
391e			endm  
# End of macro DMARK
391e						CALLMONITOR 
391e cd e8 15			call break_point_state  
3921				endm  
# End of macro CALLMONITOR
3921					endif 
3921					 
3921					FORTH_DSP_VALUEHL    ; upper range 
3921 cd 55 1e			call macro_dsp_valuehl 
3924				endm 
# End of macro FORTH_DSP_VALUEHL
3924			 
3924 22 b3 eb				ld (LFSRSeed), hl	 
3927			 
3927					if DEBUG_FORTH_WORDS 
3927						DMARK "RN1" 
3927 f5				push af  
3928 3a 3c 39			ld a, (.dmark)  
392b 32 71 ee			ld (debug_mark),a  
392e 3a 3d 39			ld a, (.dmark+1)  
3931 32 72 ee			ld (debug_mark+1),a  
3934 3a 3e 39			ld a, (.dmark+2)  
3937 32 73 ee			ld (debug_mark+2),a  
393a 18 03			jr .pastdmark  
393c ..			.dmark: db "RN1"  
393f f1			.pastdmark: pop af  
3940			endm  
# End of macro DMARK
3940						CALLMONITOR 
3940 cd e8 15			call break_point_state  
3943				endm  
# End of macro CALLMONITOR
3943					endif 
3943					FORTH_DSP_POP 
3943 cd 0d 1f			call macro_forth_dsp_pop 
3946				endm 
# End of macro FORTH_DSP_POP
3946			 
3946					FORTH_DSP_VALUEHL    ; low range 
3946 cd 55 1e			call macro_dsp_valuehl 
3949				endm 
# End of macro FORTH_DSP_VALUEHL
3949			 
3949					if DEBUG_FORTH_WORDS 
3949						DMARK "RN2" 
3949 f5				push af  
394a 3a 5e 39			ld a, (.dmark)  
394d 32 71 ee			ld (debug_mark),a  
3950 3a 5f 39			ld a, (.dmark+1)  
3953 32 72 ee			ld (debug_mark+1),a  
3956 3a 60 39			ld a, (.dmark+2)  
3959 32 73 ee			ld (debug_mark+2),a  
395c 18 03			jr .pastdmark  
395e ..			.dmark: db "RN2"  
3961 f1			.pastdmark: pop af  
3962			endm  
# End of macro DMARK
3962						CALLMONITOR 
3962 cd e8 15			call break_point_state  
3965				endm  
# End of macro CALLMONITOR
3965					endif 
3965 22 b5 eb				ld (LFSRSeed+2), hl 
3968			 
3968					FORTH_DSP_POP 
3968 cd 0d 1f			call macro_forth_dsp_pop 
396b				endm 
# End of macro FORTH_DSP_POP
396b			 
396b e5					push hl 
396c			 
396c e1			.inrange:	pop hl 
396d cd 0e 0d				call prng16  
3970					if DEBUG_FORTH_WORDS 
3970						DMARK "RN3" 
3970 f5				push af  
3971 3a 85 39			ld a, (.dmark)  
3974 32 71 ee			ld (debug_mark),a  
3977 3a 86 39			ld a, (.dmark+1)  
397a 32 72 ee			ld (debug_mark+1),a  
397d 3a 87 39			ld a, (.dmark+2)  
3980 32 73 ee			ld (debug_mark+2),a  
3983 18 03			jr .pastdmark  
3985 ..			.dmark: db "RN3"  
3988 f1			.pastdmark: pop af  
3989			endm  
# End of macro DMARK
3989						CALLMONITOR 
3989 cd e8 15			call break_point_state  
398c				endm  
# End of macro CALLMONITOR
398c					endif 
398c					 
398c					; if the range is 8bit knock out the high byte 
398c			 
398c ed 5b b3 eb			ld de, (LFSRSeed)     ; check high level 
3990			 
3990 3e 00				ld a, 0 
3992 ba					cp d  
3993 20 1e				jr nz, .hirange 
3995 26 00				ld h, 0   ; knock it down to 8bit 
3997			 
3997					if DEBUG_FORTH_WORDS 
3997						DMARK "RNk" 
3997 f5				push af  
3998 3a ac 39			ld a, (.dmark)  
399b 32 71 ee			ld (debug_mark),a  
399e 3a ad 39			ld a, (.dmark+1)  
39a1 32 72 ee			ld (debug_mark+1),a  
39a4 3a ae 39			ld a, (.dmark+2)  
39a7 32 73 ee			ld (debug_mark+2),a  
39aa 18 03			jr .pastdmark  
39ac ..			.dmark: db "RNk"  
39af f1			.pastdmark: pop af  
39b0			endm  
# End of macro DMARK
39b0						CALLMONITOR 
39b0 cd e8 15			call break_point_state  
39b3				endm  
# End of macro CALLMONITOR
39b3					endif 
39b3			.hirange:   
39b3 e5					push hl  
39b4 b7					or a  
39b5 ed 52		                sbc hl, de 
39b7			 
39b7					;call cmp16 
39b7			 
39b7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39b9 e1					pop hl 
39ba e5					push hl 
39bb			 
39bb					if DEBUG_FORTH_WORDS 
39bb						DMARK "RN4" 
39bb f5				push af  
39bc 3a d0 39			ld a, (.dmark)  
39bf 32 71 ee			ld (debug_mark),a  
39c2 3a d1 39			ld a, (.dmark+1)  
39c5 32 72 ee			ld (debug_mark+1),a  
39c8 3a d2 39			ld a, (.dmark+2)  
39cb 32 73 ee			ld (debug_mark+2),a  
39ce 18 03			jr .pastdmark  
39d0 ..			.dmark: db "RN4"  
39d3 f1			.pastdmark: pop af  
39d4			endm  
# End of macro DMARK
39d4						CALLMONITOR 
39d4 cd e8 15			call break_point_state  
39d7				endm  
# End of macro CALLMONITOR
39d7					endif 
39d7 ed 5b b5 eb			ld de, (LFSRSeed+2)   ; check low range 
39db					;call cmp16 
39db				 
39db b7					or a  
39dc ed 52		                sbc hl, de 
39de 38 8c				jr c, .inrange 
39e0			 
39e0 e1					pop hl 
39e1					 
39e1					if DEBUG_FORTH_WORDS 
39e1						DMARK "RNd" 
39e1 f5				push af  
39e2 3a f6 39			ld a, (.dmark)  
39e5 32 71 ee			ld (debug_mark),a  
39e8 3a f7 39			ld a, (.dmark+1)  
39eb 32 72 ee			ld (debug_mark+1),a  
39ee 3a f8 39			ld a, (.dmark+2)  
39f1 32 73 ee			ld (debug_mark+2),a  
39f4 18 03			jr .pastdmark  
39f6 ..			.dmark: db "RNd"  
39f9 f1			.pastdmark: pop af  
39fa			endm  
# End of macro DMARK
39fa						CALLMONITOR 
39fa cd e8 15			call break_point_state  
39fd				endm  
# End of macro CALLMONITOR
39fd					endif 
39fd			 
39fd			 
39fd cd 5e 1c				call forth_push_numhl 
3a00				       NEXTW 
3a00 c3 0b 20			jp macro_next 
3a03				endm 
# End of macro NEXTW
3a03			 
3a03			.ENDMATHS: 
3a03			 
3a03			; eof 
3a03			 
# End of file forth_words_maths.asm
3a03			include "forth_words_display.asm" 
3a03			 
3a03			; | ## Display Words 
3a03			 
3a03			.ACT: 
3a03			 
3a03				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a03 62				db WORD_SYS_CORE+78             
3a04 4f 3a			dw .INFO            
3a06 07				db 6 + 1 
3a07 .. 00			db "ACTIVE",0              
3a0e				endm 
# End of macro CWHEAD
3a0e			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a0e			;  
3a0e			; | | e.g. $ff $00 do active . $01 pause loop 
3a0e			 
3a0e					if DEBUG_FORTH_WORDS_KEY 
3a0e						DMARK "ACT" 
3a0e f5				push af  
3a0f 3a 23 3a			ld a, (.dmark)  
3a12 32 71 ee			ld (debug_mark),a  
3a15 3a 24 3a			ld a, (.dmark+1)  
3a18 32 72 ee			ld (debug_mark+1),a  
3a1b 3a 25 3a			ld a, (.dmark+2)  
3a1e 32 73 ee			ld (debug_mark+2),a  
3a21 18 03			jr .pastdmark  
3a23 ..			.dmark: db "ACT"  
3a26 f1			.pastdmark: pop af  
3a27			endm  
# End of macro DMARK
3a27						CALLMONITOR 
3a27 cd e8 15			call break_point_state  
3a2a				endm  
# End of macro CALLMONITOR
3a2a					endif 
3a2a cd 11 0b				call active 
3a2d					if DEBUG_FORTH_WORDS 
3a2d						DMARK "ACp" 
3a2d f5				push af  
3a2e 3a 42 3a			ld a, (.dmark)  
3a31 32 71 ee			ld (debug_mark),a  
3a34 3a 43 3a			ld a, (.dmark+1)  
3a37 32 72 ee			ld (debug_mark+1),a  
3a3a 3a 44 3a			ld a, (.dmark+2)  
3a3d 32 73 ee			ld (debug_mark+2),a  
3a40 18 03			jr .pastdmark  
3a42 ..			.dmark: db "ACp"  
3a45 f1			.pastdmark: pop af  
3a46			endm  
# End of macro DMARK
3a46						CALLMONITOR 
3a46 cd e8 15			call break_point_state  
3a49				endm  
# End of macro CALLMONITOR
3a49					endif 
3a49 cd cc 1c				call forth_push_str 
3a4c			 
3a4c					NEXTW 
3a4c c3 0b 20			jp macro_next 
3a4f				endm 
# End of macro NEXTW
3a4f			.INFO: 
3a4f			 
3a4f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a4f 62				db WORD_SYS_CORE+78             
3a50 6c 3a			dw .ATP            
3a52 05				db 4 + 1 
3a53 .. 00			db "INFO",0              
3a58				endm 
# End of macro CWHEAD
3a58			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a58					FORTH_DSP_VALUEHL 
3a58 cd 55 1e			call macro_dsp_valuehl 
3a5b				endm 
# End of macro FORTH_DSP_VALUEHL
3a5b			 
3a5b					FORTH_DSP_POP 
3a5b cd 0d 1f			call macro_forth_dsp_pop 
3a5e				endm 
# End of macro FORTH_DSP_POP
3a5e			 
3a5e e5					push hl 
3a5f			 
3a5f					FORTH_DSP_VALUEHL 
3a5f cd 55 1e			call macro_dsp_valuehl 
3a62				endm 
# End of macro FORTH_DSP_VALUEHL
3a62			 
3a62					FORTH_DSP_POP 
3a62 cd 0d 1f			call macro_forth_dsp_pop 
3a65				endm 
# End of macro FORTH_DSP_POP
3a65			 
3a65 d1					pop de 
3a66			 
3a66 cd 4b 0b				call info_panel 
3a69			 
3a69			 
3a69					NEXTW 
3a69 c3 0b 20			jp macro_next 
3a6c				endm 
# End of macro NEXTW
3a6c			.ATP: 
3a6c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a6c 62				db WORD_SYS_CORE+78             
3a6d e3 3a			dw .FB            
3a6f 04				db 3 + 1 
3a70 .. 00			db "AT?",0              
3a74				endm 
# End of macro CWHEAD
3a74			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a74					if DEBUG_FORTH_WORDS_KEY 
3a74						DMARK "AT?" 
3a74 f5				push af  
3a75 3a 89 3a			ld a, (.dmark)  
3a78 32 71 ee			ld (debug_mark),a  
3a7b 3a 8a 3a			ld a, (.dmark+1)  
3a7e 32 72 ee			ld (debug_mark+1),a  
3a81 3a 8b 3a			ld a, (.dmark+2)  
3a84 32 73 ee			ld (debug_mark+2),a  
3a87 18 03			jr .pastdmark  
3a89 ..			.dmark: db "AT?"  
3a8c f1			.pastdmark: pop af  
3a8d			endm  
# End of macro DMARK
3a8d						CALLMONITOR 
3a8d cd e8 15			call break_point_state  
3a90				endm  
# End of macro CALLMONITOR
3a90					endif 
3a90 3a 64 ea				ld a, (f_cursor_ptr) 
3a93			 
3a93			if DEBUG_FORTH_WORDS 
3a93				DMARK "AT?" 
3a93 f5				push af  
3a94 3a a8 3a			ld a, (.dmark)  
3a97 32 71 ee			ld (debug_mark),a  
3a9a 3a a9 3a			ld a, (.dmark+1)  
3a9d 32 72 ee			ld (debug_mark+1),a  
3aa0 3a aa 3a			ld a, (.dmark+2)  
3aa3 32 73 ee			ld (debug_mark+2),a  
3aa6 18 03			jr .pastdmark  
3aa8 ..			.dmark: db "AT?"  
3aab f1			.pastdmark: pop af  
3aac			endm  
# End of macro DMARK
3aac				CALLMONITOR 
3aac cd e8 15			call break_point_state  
3aaf				endm  
# End of macro CALLMONITOR
3aaf			endif	 
3aaf					; count the number of rows 
3aaf			 
3aaf 06 00				ld b, 0 
3ab1 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ab2 d6 28				sub display_cols 
3ab4 f2 ba 3a				jp p, .atprunder 
3ab7 04					inc b 
3ab8 18 f7				jr .atpr 
3aba			.atprunder:	 
3aba			if DEBUG_FORTH_WORDS 
3aba				DMARK "A?2" 
3aba f5				push af  
3abb 3a cf 3a			ld a, (.dmark)  
3abe 32 71 ee			ld (debug_mark),a  
3ac1 3a d0 3a			ld a, (.dmark+1)  
3ac4 32 72 ee			ld (debug_mark+1),a  
3ac7 3a d1 3a			ld a, (.dmark+2)  
3aca 32 73 ee			ld (debug_mark+2),a  
3acd 18 03			jr .pastdmark  
3acf ..			.dmark: db "A?2"  
3ad2 f1			.pastdmark: pop af  
3ad3			endm  
# End of macro DMARK
3ad3				CALLMONITOR 
3ad3 cd e8 15			call break_point_state  
3ad6				endm  
# End of macro CALLMONITOR
3ad6			endif	 
3ad6 26 00				ld h, 0 
3ad8 69					ld l, c 
3ad9 cd 5e 1c				call forth_push_numhl 
3adc 68					ld l, b  
3add cd 5e 1c				call forth_push_numhl 
3ae0			 
3ae0			 
3ae0				NEXTW 
3ae0 c3 0b 20			jp macro_next 
3ae3				endm 
# End of macro NEXTW
3ae3			 
3ae3			.FB: 
3ae3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ae3 1b				db WORD_SYS_CORE+7             
3ae4 31 3b			dw .EMIT            
3ae6 03				db 2 + 1 
3ae7 .. 00			db "FB",0              
3aea				endm 
# End of macro CWHEAD
3aea			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3aea			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3aea			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3aea			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3aea					if DEBUG_FORTH_WORDS_KEY 
3aea						DMARK "FB." 
3aea f5				push af  
3aeb 3a ff 3a			ld a, (.dmark)  
3aee 32 71 ee			ld (debug_mark),a  
3af1 3a 00 3b			ld a, (.dmark+1)  
3af4 32 72 ee			ld (debug_mark+1),a  
3af7 3a 01 3b			ld a, (.dmark+2)  
3afa 32 73 ee			ld (debug_mark+2),a  
3afd 18 03			jr .pastdmark  
3aff ..			.dmark: db "FB."  
3b02 f1			.pastdmark: pop af  
3b03			endm  
# End of macro DMARK
3b03						CALLMONITOR 
3b03 cd e8 15			call break_point_state  
3b06				endm  
# End of macro CALLMONITOR
3b06					endif 
3b06			 
3b06					FORTH_DSP_VALUEHL 
3b06 cd 55 1e			call macro_dsp_valuehl 
3b09				endm 
# End of macro FORTH_DSP_VALUEHL
3b09			 
3b09 7d					ld a, l 
3b0a fe 01				cp 1 
3b0c 20 05				jr nz, .fbn1 
3b0e 21 16 ed				ld hl, display_fb1 
3b11 18 15				jr .fbset 
3b13 fe 02		.fbn1:		cp 2 
3b15 20 05				jr nz, .fbn2 
3b17 21 d4 eb				ld hl, display_fb2 
3b1a 18 0c				jr .fbset 
3b1c fe 03		.fbn2:		cp 3 
3b1e 20 05				jr nz, .fbn3 
3b20 21 75 ec				ld hl, display_fb3 
3b23 18 03				jr .fbset 
3b25			.fbn3:		 ; if invalid number select first 
3b25 21 16 ed				ld hl, display_fb1 
3b28 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3b2b			 
3b2b					FORTH_DSP_POP 
3b2b cd 0d 1f			call macro_forth_dsp_pop 
3b2e				endm 
# End of macro FORTH_DSP_POP
3b2e			 
3b2e					NEXTW 
3b2e c3 0b 20			jp macro_next 
3b31				endm 
# End of macro NEXTW
3b31			 
3b31			 
3b31			.EMIT: 
3b31				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b31 1b				db WORD_SYS_CORE+7             
3b32 82 3b			dw .DOTH            
3b34 05				db 4 + 1 
3b35 .. 00			db "EMIT",0              
3b3a				endm 
# End of macro CWHEAD
3b3a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b3a					; get value off TOS and display it 
3b3a			 
3b3a					if DEBUG_FORTH_WORDS_KEY 
3b3a						DMARK "EMT" 
3b3a f5				push af  
3b3b 3a 4f 3b			ld a, (.dmark)  
3b3e 32 71 ee			ld (debug_mark),a  
3b41 3a 50 3b			ld a, (.dmark+1)  
3b44 32 72 ee			ld (debug_mark+1),a  
3b47 3a 51 3b			ld a, (.dmark+2)  
3b4a 32 73 ee			ld (debug_mark+2),a  
3b4d 18 03			jr .pastdmark  
3b4f ..			.dmark: db "EMT"  
3b52 f1			.pastdmark: pop af  
3b53			endm  
# End of macro DMARK
3b53						CALLMONITOR 
3b53 cd e8 15			call break_point_state  
3b56				endm  
# End of macro CALLMONITOR
3b56					endif 
3b56			 
3b56					FORTH_DSP_VALUEHL 
3b56 cd 55 1e			call macro_dsp_valuehl 
3b59				endm 
# End of macro FORTH_DSP_VALUEHL
3b59			 
3b59 7d					ld a,l 
3b5a			 
3b5a					; TODO write to display 
3b5a			 
3b5a 32 c5 e4				ld (os_input), a 
3b5d 3e 00				ld a, 0 
3b5f 32 c6 e4				ld (os_input+1), a 
3b62					 
3b62 3a 64 ea				ld a, (f_cursor_ptr) 
3b65 11 c5 e4				ld de, os_input 
3b68 cd cd 0b				call str_at_display 
3b6b			 
3b6b			 
3b6b 3a 42 ea				ld a,(cli_autodisplay) 
3b6e fe 00				cp 0 
3b70 28 03				jr z, .enoupdate 
3b72 cd dd 0b						call update_display 
3b75					.enoupdate: 
3b75			 
3b75 3a 64 ea				ld a, (f_cursor_ptr) 
3b78 3c					inc a 
3b79 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
3b7c			 
3b7c			 
3b7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7c cd 0d 1f			call macro_forth_dsp_pop 
3b7f				endm 
# End of macro FORTH_DSP_POP
3b7f			  
3b7f			 
3b7f					NEXTW 
3b7f c3 0b 20			jp macro_next 
3b82				endm 
# End of macro NEXTW
3b82			.DOTH: 
3b82				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b82 1c				db WORD_SYS_CORE+8             
3b83 b2 3b			dw .DOTF            
3b85 03				db 2 + 1 
3b86 .. 00			db ".-",0              
3b89				endm 
# End of macro CWHEAD
3b89			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b89					; get value off TOS and display it 
3b89					if DEBUG_FORTH_WORDS_KEY 
3b89						DMARK "DTD" 
3b89 f5				push af  
3b8a 3a 9e 3b			ld a, (.dmark)  
3b8d 32 71 ee			ld (debug_mark),a  
3b90 3a 9f 3b			ld a, (.dmark+1)  
3b93 32 72 ee			ld (debug_mark+1),a  
3b96 3a a0 3b			ld a, (.dmark+2)  
3b99 32 73 ee			ld (debug_mark+2),a  
3b9c 18 03			jr .pastdmark  
3b9e ..			.dmark: db "DTD"  
3ba1 f1			.pastdmark: pop af  
3ba2			endm  
# End of macro DMARK
3ba2						CALLMONITOR 
3ba2 cd e8 15			call break_point_state  
3ba5				endm  
# End of macro CALLMONITOR
3ba5					endif 
3ba5 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ba7 3e 00			ld a, 0 
3ba9 32 43 ea			ld (cli_mvdot), a 
3bac c3 09 3c			jp .dotgo 
3baf				NEXTW 
3baf c3 0b 20			jp macro_next 
3bb2				endm 
# End of macro NEXTW
3bb2			.DOTF: 
3bb2				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bb2 1c				db WORD_SYS_CORE+8             
3bb3 e0 3b			dw .DOT            
3bb5 03				db 2 + 1 
3bb6 .. 00			db ".>",0              
3bb9				endm 
# End of macro CWHEAD
3bb9			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bb9					; get value off TOS and display it 
3bb9			        ; TODO BUG adds extra spaces 
3bb9			        ; TODO BUG handle numerics? 
3bb9					if DEBUG_FORTH_WORDS_KEY 
3bb9						DMARK "DTC" 
3bb9 f5				push af  
3bba 3a ce 3b			ld a, (.dmark)  
3bbd 32 71 ee			ld (debug_mark),a  
3bc0 3a cf 3b			ld a, (.dmark+1)  
3bc3 32 72 ee			ld (debug_mark+1),a  
3bc6 3a d0 3b			ld a, (.dmark+2)  
3bc9 32 73 ee			ld (debug_mark+2),a  
3bcc 18 03			jr .pastdmark  
3bce ..			.dmark: db "DTC"  
3bd1 f1			.pastdmark: pop af  
3bd2			endm  
# End of macro DMARK
3bd2						CALLMONITOR 
3bd2 cd e8 15			call break_point_state  
3bd5				endm  
# End of macro CALLMONITOR
3bd5					endif 
3bd5 3e 01			ld a, 1 
3bd7 32 43 ea			ld (cli_mvdot), a 
3bda c3 09 3c			jp .dotgo 
3bdd				NEXTW 
3bdd c3 0b 20			jp macro_next 
3be0				endm 
# End of macro NEXTW
3be0			 
3be0			.DOT: 
3be0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3be0 1c				db WORD_SYS_CORE+8             
3be1 bc 3d			dw .CLS            
3be3 02				db 1 + 1 
3be4 .. 00			db ".",0              
3be6				endm 
# End of macro CWHEAD
3be6			        ; | . ( u -- ) Display TOS | DONE 
3be6					; get value off TOS and display it 
3be6			 
3be6					if DEBUG_FORTH_WORDS_KEY 
3be6						DMARK "DOT" 
3be6 f5				push af  
3be7 3a fb 3b			ld a, (.dmark)  
3bea 32 71 ee			ld (debug_mark),a  
3bed 3a fc 3b			ld a, (.dmark+1)  
3bf0 32 72 ee			ld (debug_mark+1),a  
3bf3 3a fd 3b			ld a, (.dmark+2)  
3bf6 32 73 ee			ld (debug_mark+2),a  
3bf9 18 03			jr .pastdmark  
3bfb ..			.dmark: db "DOT"  
3bfe f1			.pastdmark: pop af  
3bff			endm  
# End of macro DMARK
3bff						CALLMONITOR 
3bff cd e8 15			call break_point_state  
3c02				endm  
# End of macro CALLMONITOR
3c02					endif 
3c02 3e 00			ld a, 0 
3c04 32 43 ea			ld (cli_mvdot), a 
3c07 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c09				 
3c09			 
3c09			.dotgo: 
3c09			 
3c09			; move up type to on stack for parserv5 
3c09					FORTH_DSP 
3c09 cd 1b 1e			call macro_forth_dsp 
3c0c				endm 
# End of macro FORTH_DSP
3c0c				;FORTH_DSP_VALUE  
3c0c			 
3c0c			if DEBUG_FORTH_DOT 
3c0c				DMARK "DOT" 
3c0c f5				push af  
3c0d 3a 21 3c			ld a, (.dmark)  
3c10 32 71 ee			ld (debug_mark),a  
3c13 3a 22 3c			ld a, (.dmark+1)  
3c16 32 72 ee			ld (debug_mark+1),a  
3c19 3a 23 3c			ld a, (.dmark+2)  
3c1c 32 73 ee			ld (debug_mark+2),a  
3c1f 18 03			jr .pastdmark  
3c21 ..			.dmark: db "DOT"  
3c24 f1			.pastdmark: pop af  
3c25			endm  
# End of macro DMARK
3c25				CALLMONITOR 
3c25 cd e8 15			call break_point_state  
3c28				endm  
# End of macro CALLMONITOR
3c28			endif	 
3c28			;		.print: 
3c28			 
3c28 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c29 23				inc hl   ; position to the actual value 
3c2a fe 01			cp DS_TYPE_STR 
3c2c 20 06			jr nz, .dotnum1  
3c2e			 
3c2e			; display string 
3c2e				FORTH_DSP_VALUE  
3c2e cd 3e 1e			call macro_forth_dsp_value 
3c31				endm 
# End of macro FORTH_DSP_VALUE
3c31 eb				ex de,hl 
3c32 18 49			jr .dotwrite 
3c34			 
3c34			.dotnum1: 
3c34 fe 02			cp DS_TYPE_INUM 
3c36 20 44			jr nz, .dotflot 
3c38			 
3c38			 
3c38			; display number 
3c38			 
3c38			;	push hl 
3c38			;	call clear_display 
3c38			;	pop hl 
3c38			 
3c38 5e				ld e, (hl) 
3c39 23				inc hl 
3c3a 56				ld d, (hl) 
3c3b 21 c7 e2			ld hl, scratch 
3c3e			if DEBUG_FORTH_DOT 
3c3e				DMARK "DT1" 
3c3e f5				push af  
3c3f 3a 53 3c			ld a, (.dmark)  
3c42 32 71 ee			ld (debug_mark),a  
3c45 3a 54 3c			ld a, (.dmark+1)  
3c48 32 72 ee			ld (debug_mark+1),a  
3c4b 3a 55 3c			ld a, (.dmark+2)  
3c4e 32 73 ee			ld (debug_mark+2),a  
3c51 18 03			jr .pastdmark  
3c53 ..			.dmark: db "DT1"  
3c56 f1			.pastdmark: pop af  
3c57			endm  
# End of macro DMARK
3c57				CALLMONITOR 
3c57 cd e8 15			call break_point_state  
3c5a				endm  
# End of macro CALLMONITOR
3c5a			endif	 
3c5a			 
3c5a cd f4 11			call uitoa_16 
3c5d eb				ex de,hl 
3c5e			 
3c5e			if DEBUG_FORTH_DOT 
3c5e				DMARK "DT2" 
3c5e f5				push af  
3c5f 3a 73 3c			ld a, (.dmark)  
3c62 32 71 ee			ld (debug_mark),a  
3c65 3a 74 3c			ld a, (.dmark+1)  
3c68 32 72 ee			ld (debug_mark+1),a  
3c6b 3a 75 3c			ld a, (.dmark+2)  
3c6e 32 73 ee			ld (debug_mark+2),a  
3c71 18 03			jr .pastdmark  
3c73 ..			.dmark: db "DT2"  
3c76 f1			.pastdmark: pop af  
3c77			endm  
# End of macro DMARK
3c77				CALLMONITOR 
3c77 cd e8 15			call break_point_state  
3c7a				endm  
# End of macro CALLMONITOR
3c7a			endif	 
3c7a			 
3c7a			;	ld de, os_word_scratch 
3c7a 18 01			jr .dotwrite 
3c7c			 
3c7c 00			.dotflot:   nop 
3c7d			; TODO print floating point number 
3c7d			 
3c7d			.dotwrite:		 
3c7d			 
3c7d					; if c is set then set all '-' to spaces 
3c7d					; need to also take into account .>  
3c7d			 
3c7d 3e 01				ld a, 1 
3c7f b9					cp c 
3c80 20 67				jr nz, .nodashswap 
3c82			 
3c82					; DE has the string to write, working with HL 
3c82			 
3c82 06 ff				ld b, 255 
3c84 d5					push de 
3c85 e1					pop hl 
3c86			 
3c86			if DEBUG_FORTH_DOT 
3c86				DMARK "DT-" 
3c86 f5				push af  
3c87 3a 9b 3c			ld a, (.dmark)  
3c8a 32 71 ee			ld (debug_mark),a  
3c8d 3a 9c 3c			ld a, (.dmark+1)  
3c90 32 72 ee			ld (debug_mark+1),a  
3c93 3a 9d 3c			ld a, (.dmark+2)  
3c96 32 73 ee			ld (debug_mark+2),a  
3c99 18 03			jr .pastdmark  
3c9b ..			.dmark: db "DT-"  
3c9e f1			.pastdmark: pop af  
3c9f			endm  
# End of macro DMARK
3c9f				CALLMONITOR 
3c9f cd e8 15			call break_point_state  
3ca2				endm  
# End of macro CALLMONITOR
3ca2			endif	 
3ca2 7e			.dashscan:	ld a, (hl) 
3ca3 fe 00				cp 0 
3ca5 28 42				jr z, .nodashswap 
3ca7 fe 2d				cp '-' 
3ca9 20 03				jr nz, .dashskip 
3cab 3e 20				ld a, ' ' 
3cad 77					ld (hl), a 
3cae 23			.dashskip:	inc hl 
3caf			if DEBUG_FORTH_DOT 
3caf				DMARK "D-2" 
3caf f5				push af  
3cb0 3a c4 3c			ld a, (.dmark)  
3cb3 32 71 ee			ld (debug_mark),a  
3cb6 3a c5 3c			ld a, (.dmark+1)  
3cb9 32 72 ee			ld (debug_mark+1),a  
3cbc 3a c6 3c			ld a, (.dmark+2)  
3cbf 32 73 ee			ld (debug_mark+2),a  
3cc2 18 03			jr .pastdmark  
3cc4 ..			.dmark: db "D-2"  
3cc7 f1			.pastdmark: pop af  
3cc8			endm  
# End of macro DMARK
3cc8				CALLMONITOR 
3cc8 cd e8 15			call break_point_state  
3ccb				endm  
# End of macro CALLMONITOR
3ccb			endif	 
3ccb 10 d5				djnz .dashscan 
3ccd			 
3ccd			if DEBUG_FORTH_DOT 
3ccd				DMARK "D-1" 
3ccd f5				push af  
3cce 3a e2 3c			ld a, (.dmark)  
3cd1 32 71 ee			ld (debug_mark),a  
3cd4 3a e3 3c			ld a, (.dmark+1)  
3cd7 32 72 ee			ld (debug_mark+1),a  
3cda 3a e4 3c			ld a, (.dmark+2)  
3cdd 32 73 ee			ld (debug_mark+2),a  
3ce0 18 03			jr .pastdmark  
3ce2 ..			.dmark: db "D-1"  
3ce5 f1			.pastdmark: pop af  
3ce6			endm  
# End of macro DMARK
3ce6				CALLMONITOR 
3ce6 cd e8 15			call break_point_state  
3ce9				endm  
# End of macro CALLMONITOR
3ce9			endif	 
3ce9			 
3ce9			.nodashswap: 
3ce9			 
3ce9			if DEBUG_FORTH_DOT 
3ce9				DMARK "D-o" 
3ce9 f5				push af  
3cea 3a fe 3c			ld a, (.dmark)  
3ced 32 71 ee			ld (debug_mark),a  
3cf0 3a ff 3c			ld a, (.dmark+1)  
3cf3 32 72 ee			ld (debug_mark+1),a  
3cf6 3a 00 3d			ld a, (.dmark+2)  
3cf9 32 73 ee			ld (debug_mark+2),a  
3cfc 18 03			jr .pastdmark  
3cfe ..			.dmark: db "D-o"  
3d01 f1			.pastdmark: pop af  
3d02			endm  
# End of macro DMARK
3d02				CALLMONITOR 
3d02 cd e8 15			call break_point_state  
3d05				endm  
# End of macro CALLMONITOR
3d05			endif	 
3d05			 
3d05 d5					push de   ; save string start in case we need to advance print 
3d06			 
3d06 3a 64 ea				ld a, (f_cursor_ptr) 
3d09 cd cd 0b				call str_at_display 
3d0c 3a 42 ea				ld a,(cli_autodisplay) 
3d0f fe 00				cp 0 
3d11 28 03				jr z, .noupdate 
3d13 cd dd 0b						call update_display 
3d16					.noupdate: 
3d16			 
3d16			 
3d16					; see if we need to advance the print position 
3d16			 
3d16 e1					pop hl   ; get back string 
3d17			;		ex de,hl 
3d17			 
3d17 3a 43 ea				ld a, (cli_mvdot) 
3d1a			if DEBUG_FORTH_DOT 
3d1a			;		ld e,a 
3d1a				DMARK "D>1" 
3d1a f5				push af  
3d1b 3a 2f 3d			ld a, (.dmark)  
3d1e 32 71 ee			ld (debug_mark),a  
3d21 3a 30 3d			ld a, (.dmark+1)  
3d24 32 72 ee			ld (debug_mark+1),a  
3d27 3a 31 3d			ld a, (.dmark+2)  
3d2a 32 73 ee			ld (debug_mark+2),a  
3d2d 18 03			jr .pastdmark  
3d2f ..			.dmark: db "D>1"  
3d32 f1			.pastdmark: pop af  
3d33			endm  
# End of macro DMARK
3d33				CALLMONITOR 
3d33 cd e8 15			call break_point_state  
3d36				endm  
# End of macro CALLMONITOR
3d36			endif	 
3d36 fe 00				cp 0 
3d38 28 44				jr z, .noadv 
3d3a					; yes, lets advance the print position 
3d3a 3e 00				ld a, 0 
3d3c cd 50 12				call strlent 
3d3f			if DEBUG_FORTH_DOT 
3d3f				DMARK "D-?" 
3d3f f5				push af  
3d40 3a 54 3d			ld a, (.dmark)  
3d43 32 71 ee			ld (debug_mark),a  
3d46 3a 55 3d			ld a, (.dmark+1)  
3d49 32 72 ee			ld (debug_mark+1),a  
3d4c 3a 56 3d			ld a, (.dmark+2)  
3d4f 32 73 ee			ld (debug_mark+2),a  
3d52 18 03			jr .pastdmark  
3d54 ..			.dmark: db "D-?"  
3d57 f1			.pastdmark: pop af  
3d58			endm  
# End of macro DMARK
3d58				CALLMONITOR 
3d58 cd e8 15			call break_point_state  
3d5b				endm  
# End of macro CALLMONITOR
3d5b			endif	 
3d5b 3a 64 ea				ld a, (f_cursor_ptr) 
3d5e 85					add a,l 
3d5f					;call addatohl 
3d5f					;ld a, l 
3d5f 32 64 ea				ld (f_cursor_ptr), a   ; save new pos 
3d62			 
3d62			if DEBUG_FORTH_DOT 
3d62				DMARK "D->" 
3d62 f5				push af  
3d63 3a 77 3d			ld a, (.dmark)  
3d66 32 71 ee			ld (debug_mark),a  
3d69 3a 78 3d			ld a, (.dmark+1)  
3d6c 32 72 ee			ld (debug_mark+1),a  
3d6f 3a 79 3d			ld a, (.dmark+2)  
3d72 32 73 ee			ld (debug_mark+2),a  
3d75 18 03			jr .pastdmark  
3d77 ..			.dmark: db "D->"  
3d7a f1			.pastdmark: pop af  
3d7b			endm  
# End of macro DMARK
3d7b				CALLMONITOR 
3d7b cd e8 15			call break_point_state  
3d7e				endm  
# End of macro CALLMONITOR
3d7e			endif	 
3d7e			 
3d7e			.noadv:	 
3d7e			 
3d7e					if DEBUG_FORTH_DOT_WAIT 
3d7e							call next_page_prompt 
3d7e					endif	 
3d7e			; TODO this pop off the stack causes a crash. i dont know why 
3d7e			 
3d7e			 
3d7e			if DEBUG_FORTH_DOT 
3d7e				DMARK "DTh" 
3d7e f5				push af  
3d7f 3a 93 3d			ld a, (.dmark)  
3d82 32 71 ee			ld (debug_mark),a  
3d85 3a 94 3d			ld a, (.dmark+1)  
3d88 32 72 ee			ld (debug_mark+1),a  
3d8b 3a 95 3d			ld a, (.dmark+2)  
3d8e 32 73 ee			ld (debug_mark+2),a  
3d91 18 03			jr .pastdmark  
3d93 ..			.dmark: db "DTh"  
3d96 f1			.pastdmark: pop af  
3d97			endm  
# End of macro DMARK
3d97				CALLMONITOR 
3d97 cd e8 15			call break_point_state  
3d9a				endm  
# End of macro CALLMONITOR
3d9a			endif	 
3d9a			 
3d9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d9a cd 0d 1f			call macro_forth_dsp_pop 
3d9d				endm 
# End of macro FORTH_DSP_POP
3d9d			 
3d9d			if DEBUG_FORTH_DOT 
3d9d				DMARK "DTi" 
3d9d f5				push af  
3d9e 3a b2 3d			ld a, (.dmark)  
3da1 32 71 ee			ld (debug_mark),a  
3da4 3a b3 3d			ld a, (.dmark+1)  
3da7 32 72 ee			ld (debug_mark+1),a  
3daa 3a b4 3d			ld a, (.dmark+2)  
3dad 32 73 ee			ld (debug_mark+2),a  
3db0 18 03			jr .pastdmark  
3db2 ..			.dmark: db "DTi"  
3db5 f1			.pastdmark: pop af  
3db6			endm  
# End of macro DMARK
3db6				CALLMONITOR 
3db6 cd e8 15			call break_point_state  
3db9				endm  
# End of macro CALLMONITOR
3db9			endif	 
3db9			 
3db9			 
3db9					NEXTW 
3db9 c3 0b 20			jp macro_next 
3dbc				endm 
# End of macro NEXTW
3dbc			 
3dbc			.CLS: 
3dbc				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3dbc 35				db WORD_SYS_CORE+33             
3dbd e9 3d			dw .DRAW            
3dbf 04				db 3 + 1 
3dc0 .. 00			db "CLS",0              
3dc4				endm 
# End of macro CWHEAD
3dc4			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3dc4					if DEBUG_FORTH_WORDS_KEY 
3dc4						DMARK "CLS" 
3dc4 f5				push af  
3dc5 3a d9 3d			ld a, (.dmark)  
3dc8 32 71 ee			ld (debug_mark),a  
3dcb 3a da 3d			ld a, (.dmark+1)  
3dce 32 72 ee			ld (debug_mark+1),a  
3dd1 3a db 3d			ld a, (.dmark+2)  
3dd4 32 73 ee			ld (debug_mark+2),a  
3dd7 18 03			jr .pastdmark  
3dd9 ..			.dmark: db "CLS"  
3ddc f1			.pastdmark: pop af  
3ddd			endm  
# End of macro DMARK
3ddd						CALLMONITOR 
3ddd cd e8 15			call break_point_state  
3de0				endm  
# End of macro CALLMONITOR
3de0					endif 
3de0 cd ba 0b				call clear_display 
3de3 c3 f7 3e				jp .home		; and home cursor 
3de6					NEXTW 
3de6 c3 0b 20			jp macro_next 
3de9				endm 
# End of macro NEXTW
3de9			 
3de9			.DRAW: 
3de9				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3de9 36				db WORD_SYS_CORE+34             
3dea 14 3e			dw .DUMP            
3dec 05				db 4 + 1 
3ded .. 00			db "DRAW",0              
3df2				endm 
# End of macro CWHEAD
3df2			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3df2					if DEBUG_FORTH_WORDS_KEY 
3df2						DMARK "DRW" 
3df2 f5				push af  
3df3 3a 07 3e			ld a, (.dmark)  
3df6 32 71 ee			ld (debug_mark),a  
3df9 3a 08 3e			ld a, (.dmark+1)  
3dfc 32 72 ee			ld (debug_mark+1),a  
3dff 3a 09 3e			ld a, (.dmark+2)  
3e02 32 73 ee			ld (debug_mark+2),a  
3e05 18 03			jr .pastdmark  
3e07 ..			.dmark: db "DRW"  
3e0a f1			.pastdmark: pop af  
3e0b			endm  
# End of macro DMARK
3e0b						CALLMONITOR 
3e0b cd e8 15			call break_point_state  
3e0e				endm  
# End of macro CALLMONITOR
3e0e					endif 
3e0e cd dd 0b				call update_display 
3e11					NEXTW 
3e11 c3 0b 20			jp macro_next 
3e14				endm 
# End of macro NEXTW
3e14			 
3e14			.DUMP: 
3e14				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e14 37				db WORD_SYS_CORE+35             
3e15 4c 3e			dw .CDUMP            
3e17 05				db 4 + 1 
3e18 .. 00			db "DUMP",0              
3e1d				endm 
# End of macro CWHEAD
3e1d			; | DUMP ( x -- ) With address x display dump   | DONE 
3e1d			; TODO pop address to use off of the stack 
3e1d					if DEBUG_FORTH_WORDS_KEY 
3e1d						DMARK "DUM" 
3e1d f5				push af  
3e1e 3a 32 3e			ld a, (.dmark)  
3e21 32 71 ee			ld (debug_mark),a  
3e24 3a 33 3e			ld a, (.dmark+1)  
3e27 32 72 ee			ld (debug_mark+1),a  
3e2a 3a 34 3e			ld a, (.dmark+2)  
3e2d 32 73 ee			ld (debug_mark+2),a  
3e30 18 03			jr .pastdmark  
3e32 ..			.dmark: db "DUM"  
3e35 f1			.pastdmark: pop af  
3e36			endm  
# End of macro DMARK
3e36						CALLMONITOR 
3e36 cd e8 15			call break_point_state  
3e39				endm  
# End of macro CALLMONITOR
3e39					endif 
3e39 cd ba 0b				call clear_display 
3e3c			 
3e3c					; get address 
3e3c			 
3e3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e3c cd 55 1e			call macro_dsp_valuehl 
3e3f				endm 
# End of macro FORTH_DSP_VALUEHL
3e3f				 
3e3f					; save it for cdump 
3e3f			 
3e3f 22 ea e5				ld (os_cur_ptr),hl 
3e42			 
3e42					; destroy value TOS 
3e42			 
3e42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e42 cd 0d 1f			call macro_forth_dsp_pop 
3e45				endm 
# End of macro FORTH_DSP_POP
3e45			 
3e45 cd de 1a				call dumpcont	; skip old style of param parsing	 
3e48 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e49					NEXTW 
3e49 c3 0b 20			jp macro_next 
3e4c				endm 
# End of macro NEXTW
3e4c			.CDUMP: 
3e4c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e4c 38				db WORD_SYS_CORE+36             
3e4d 7c 3e			dw .DAT            
3e4f 06				db 5 + 1 
3e50 .. 00			db "CDUMP",0              
3e56				endm 
# End of macro CWHEAD
3e56			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e56					if DEBUG_FORTH_WORDS_KEY 
3e56						DMARK "CDP" 
3e56 f5				push af  
3e57 3a 6b 3e			ld a, (.dmark)  
3e5a 32 71 ee			ld (debug_mark),a  
3e5d 3a 6c 3e			ld a, (.dmark+1)  
3e60 32 72 ee			ld (debug_mark+1),a  
3e63 3a 6d 3e			ld a, (.dmark+2)  
3e66 32 73 ee			ld (debug_mark+2),a  
3e69 18 03			jr .pastdmark  
3e6b ..			.dmark: db "CDP"  
3e6e f1			.pastdmark: pop af  
3e6f			endm  
# End of macro DMARK
3e6f						CALLMONITOR 
3e6f cd e8 15			call break_point_state  
3e72				endm  
# End of macro CALLMONITOR
3e72					endif 
3e72 cd ba 0b				call clear_display 
3e75 cd de 1a				call dumpcont	 
3e78 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e79					NEXTW 
3e79 c3 0b 20			jp macro_next 
3e7c				endm 
# End of macro NEXTW
3e7c			 
3e7c			 
3e7c			 
3e7c			 
3e7c			.DAT: 
3e7c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e7c 3d				db WORD_SYS_CORE+41             
3e7d d2 3e			dw .HOME            
3e7f 03				db 2 + 1 
3e80 .. 00			db "AT",0              
3e83				endm 
# End of macro CWHEAD
3e83			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e83					if DEBUG_FORTH_WORDS_KEY 
3e83						DMARK "AT." 
3e83 f5				push af  
3e84 3a 98 3e			ld a, (.dmark)  
3e87 32 71 ee			ld (debug_mark),a  
3e8a 3a 99 3e			ld a, (.dmark+1)  
3e8d 32 72 ee			ld (debug_mark+1),a  
3e90 3a 9a 3e			ld a, (.dmark+2)  
3e93 32 73 ee			ld (debug_mark+2),a  
3e96 18 03			jr .pastdmark  
3e98 ..			.dmark: db "AT."  
3e9b f1			.pastdmark: pop af  
3e9c			endm  
# End of macro DMARK
3e9c						CALLMONITOR 
3e9c cd e8 15			call break_point_state  
3e9f				endm  
# End of macro CALLMONITOR
3e9f					endif 
3e9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9f cd 55 1e			call macro_dsp_valuehl 
3ea2				endm 
# End of macro FORTH_DSP_VALUEHL
3ea2			 
3ea2			 
3ea2					; TODO save cursor row 
3ea2 7d					ld a,l 
3ea3 fe 02				cp 2 
3ea5 20 04				jr nz, .crow3 
3ea7 3e 28				ld a, display_row_2 
3ea9 18 12				jr .ccol1 
3eab fe 03		.crow3:		cp 3 
3ead 20 04				jr nz, .crow4 
3eaf 3e 50				ld a, display_row_3 
3eb1 18 0a				jr .ccol1 
3eb3 fe 04		.crow4:		cp 4 
3eb5 20 04				jr nz, .crow1 
3eb7 3e 78				ld a, display_row_4 
3eb9 18 02				jr .ccol1 
3ebb 3e 00		.crow1:		ld a,display_row_1 
3ebd f5			.ccol1:		push af			; got row offset 
3ebe 6f					ld l,a 
3ebf 26 00				ld h,0 
3ec1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec1 cd 0d 1f			call macro_forth_dsp_pop 
3ec4				endm 
# End of macro FORTH_DSP_POP
3ec4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec4 cd 55 1e			call macro_dsp_valuehl 
3ec7				endm 
# End of macro FORTH_DSP_VALUEHL
3ec7					; TODO save cursor col 
3ec7 f1					pop af 
3ec8 85					add l		; add col offset 
3ec9 32 64 ea				ld (f_cursor_ptr), a 
3ecc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ecc cd 0d 1f			call macro_forth_dsp_pop 
3ecf				endm 
# End of macro FORTH_DSP_POP
3ecf			 
3ecf					; calculate  
3ecf			 
3ecf					NEXTW 
3ecf c3 0b 20			jp macro_next 
3ed2				endm 
# End of macro NEXTW
3ed2			 
3ed2			 
3ed2			.HOME: 
3ed2				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3ed2 41				db WORD_SYS_CORE+45             
3ed3 ff 3e			dw .SPACE            
3ed5 05				db 4 + 1 
3ed6 .. 00			db "HOME",0              
3edb				endm 
# End of macro CWHEAD
3edb			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3edb					if DEBUG_FORTH_WORDS_KEY 
3edb						DMARK "HOM" 
3edb f5				push af  
3edc 3a f0 3e			ld a, (.dmark)  
3edf 32 71 ee			ld (debug_mark),a  
3ee2 3a f1 3e			ld a, (.dmark+1)  
3ee5 32 72 ee			ld (debug_mark+1),a  
3ee8 3a f2 3e			ld a, (.dmark+2)  
3eeb 32 73 ee			ld (debug_mark+2),a  
3eee 18 03			jr .pastdmark  
3ef0 ..			.dmark: db "HOM"  
3ef3 f1			.pastdmark: pop af  
3ef4			endm  
# End of macro DMARK
3ef4						CALLMONITOR 
3ef4 cd e8 15			call break_point_state  
3ef7				endm  
# End of macro CALLMONITOR
3ef7					endif 
3ef7 3e 00		.home:		ld a, 0		; and home cursor 
3ef9 32 64 ea				ld (f_cursor_ptr), a 
3efc					NEXTW 
3efc c3 0b 20			jp macro_next 
3eff				endm 
# End of macro NEXTW
3eff			 
3eff			 
3eff			.SPACE: 
3eff				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3eff 46				db WORD_SYS_CORE+50             
3f00 35 3f			dw .SPACES            
3f02 03				db 2 + 1 
3f03 .. 00			db "BL",0              
3f06				endm 
# End of macro CWHEAD
3f06			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f06					if DEBUG_FORTH_WORDS_KEY 
3f06						DMARK "BL." 
3f06 f5				push af  
3f07 3a 1b 3f			ld a, (.dmark)  
3f0a 32 71 ee			ld (debug_mark),a  
3f0d 3a 1c 3f			ld a, (.dmark+1)  
3f10 32 72 ee			ld (debug_mark+1),a  
3f13 3a 1d 3f			ld a, (.dmark+2)  
3f16 32 73 ee			ld (debug_mark+2),a  
3f19 18 03			jr .pastdmark  
3f1b ..			.dmark: db "BL."  
3f1e f1			.pastdmark: pop af  
3f1f			endm  
# End of macro DMARK
3f1f						CALLMONITOR 
3f1f cd e8 15			call break_point_state  
3f22				endm  
# End of macro CALLMONITOR
3f22					endif 
3f22 3e 20				ld a, " " 
3f24 32 c7 e2				ld (scratch),a 
3f27 3e 00				ld a, 0 
3f29 32 c8 e2				ld (scratch+1),a 
3f2c 21 c7 e2				ld hl, scratch 
3f2f cd cc 1c				call forth_push_str 
3f32					 
3f32				       NEXTW 
3f32 c3 0b 20			jp macro_next 
3f35				endm 
# End of macro NEXTW
3f35			 
3f35			;.blstr: db " ", 0 
3f35			 
3f35			.SPACES: 
3f35				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f35 47				db WORD_SYS_CORE+51             
3f36 d0 3f			dw .SCROLL            
3f38 07				db 6 + 1 
3f39 .. 00			db "SPACES",0              
3f40				endm 
# End of macro CWHEAD
3f40			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f40					if DEBUG_FORTH_WORDS_KEY 
3f40						DMARK "SPS" 
3f40 f5				push af  
3f41 3a 55 3f			ld a, (.dmark)  
3f44 32 71 ee			ld (debug_mark),a  
3f47 3a 56 3f			ld a, (.dmark+1)  
3f4a 32 72 ee			ld (debug_mark+1),a  
3f4d 3a 57 3f			ld a, (.dmark+2)  
3f50 32 73 ee			ld (debug_mark+2),a  
3f53 18 03			jr .pastdmark  
3f55 ..			.dmark: db "SPS"  
3f58 f1			.pastdmark: pop af  
3f59			endm  
# End of macro DMARK
3f59						CALLMONITOR 
3f59 cd e8 15			call break_point_state  
3f5c				endm  
# End of macro CALLMONITOR
3f5c					endif 
3f5c			 
3f5c			 
3f5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f5c cd 55 1e			call macro_dsp_valuehl 
3f5f				endm 
# End of macro FORTH_DSP_VALUEHL
3f5f			 
3f5f e5					push hl    ; u 
3f60					if DEBUG_FORTH_WORDS 
3f60						DMARK "SPA" 
3f60 f5				push af  
3f61 3a 75 3f			ld a, (.dmark)  
3f64 32 71 ee			ld (debug_mark),a  
3f67 3a 76 3f			ld a, (.dmark+1)  
3f6a 32 72 ee			ld (debug_mark+1),a  
3f6d 3a 77 3f			ld a, (.dmark+2)  
3f70 32 73 ee			ld (debug_mark+2),a  
3f73 18 03			jr .pastdmark  
3f75 ..			.dmark: db "SPA"  
3f78 f1			.pastdmark: pop af  
3f79			endm  
# End of macro DMARK
3f79						CALLMONITOR 
3f79 cd e8 15			call break_point_state  
3f7c				endm  
# End of macro CALLMONITOR
3f7c					endif 
3f7c			 
3f7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7c cd 0d 1f			call macro_forth_dsp_pop 
3f7f				endm 
# End of macro FORTH_DSP_POP
3f7f e1					pop hl 
3f80 0e 00				ld c, 0 
3f82 45					ld b, l 
3f83 21 c7 e2				ld hl, scratch  
3f86			 
3f86					if DEBUG_FORTH_WORDS 
3f86						DMARK "SP2" 
3f86 f5				push af  
3f87 3a 9b 3f			ld a, (.dmark)  
3f8a 32 71 ee			ld (debug_mark),a  
3f8d 3a 9c 3f			ld a, (.dmark+1)  
3f90 32 72 ee			ld (debug_mark+1),a  
3f93 3a 9d 3f			ld a, (.dmark+2)  
3f96 32 73 ee			ld (debug_mark+2),a  
3f99 18 03			jr .pastdmark  
3f9b ..			.dmark: db "SP2"  
3f9e f1			.pastdmark: pop af  
3f9f			endm  
# End of macro DMARK
3f9f						CALLMONITOR 
3f9f cd e8 15			call break_point_state  
3fa2				endm  
# End of macro CALLMONITOR
3fa2					endif 
3fa2 3e 20				ld a, ' ' 
3fa4			.spaces1:	 
3fa4 77					ld (hl),a 
3fa5 23					inc hl 
3fa6					 
3fa6 10 fc				djnz .spaces1 
3fa8 3e 00				ld a,0 
3faa 77					ld (hl),a 
3fab 21 c7 e2				ld hl, scratch 
3fae					if DEBUG_FORTH_WORDS 
3fae						DMARK "SP3" 
3fae f5				push af  
3faf 3a c3 3f			ld a, (.dmark)  
3fb2 32 71 ee			ld (debug_mark),a  
3fb5 3a c4 3f			ld a, (.dmark+1)  
3fb8 32 72 ee			ld (debug_mark+1),a  
3fbb 3a c5 3f			ld a, (.dmark+2)  
3fbe 32 73 ee			ld (debug_mark+2),a  
3fc1 18 03			jr .pastdmark  
3fc3 ..			.dmark: db "SP3"  
3fc6 f1			.pastdmark: pop af  
3fc7			endm  
# End of macro DMARK
3fc7						CALLMONITOR 
3fc7 cd e8 15			call break_point_state  
3fca				endm  
# End of macro CALLMONITOR
3fca					endif 
3fca cd cc 1c				call forth_push_str 
3fcd			 
3fcd				       NEXTW 
3fcd c3 0b 20			jp macro_next 
3fd0				endm 
# End of macro NEXTW
3fd0			 
3fd0			 
3fd0			 
3fd0			.SCROLL: 
3fd0				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fd0 53				db WORD_SYS_CORE+63             
3fd1 fd 3f			dw .SCROLLD            
3fd3 07				db 6 + 1 
3fd4 .. 00			db "SCROLL",0              
3fdb				endm 
# End of macro CWHEAD
3fdb			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fdb					if DEBUG_FORTH_WORDS_KEY 
3fdb						DMARK "SCR" 
3fdb f5				push af  
3fdc 3a f0 3f			ld a, (.dmark)  
3fdf 32 71 ee			ld (debug_mark),a  
3fe2 3a f1 3f			ld a, (.dmark+1)  
3fe5 32 72 ee			ld (debug_mark+1),a  
3fe8 3a f2 3f			ld a, (.dmark+2)  
3feb 32 73 ee			ld (debug_mark+2),a  
3fee 18 03			jr .pastdmark  
3ff0 ..			.dmark: db "SCR"  
3ff3 f1			.pastdmark: pop af  
3ff4			endm  
# End of macro DMARK
3ff4						CALLMONITOR 
3ff4 cd e8 15			call break_point_state  
3ff7				endm  
# End of macro CALLMONITOR
3ff7					endif 
3ff7			 
3ff7 cd 7c 0b			call scroll_up 
3ffa			;	call update_display 
3ffa			 
3ffa					NEXTW 
3ffa c3 0b 20			jp macro_next 
3ffd				endm 
# End of macro NEXTW
3ffd			 
3ffd			 
3ffd			 
3ffd			;		; get dir 
3ffd			; 
3ffd			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ffd			; 
3ffd			;		push hl 
3ffd			; 
3ffd			;		; destroy value TOS 
3ffd			; 
3ffd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffd			; 
3ffd			;		; get count 
3ffd			; 
3ffd			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ffd			; 
3ffd			;		push hl 
3ffd			; 
3ffd			;		; destroy value TOS 
3ffd			; 
3ffd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffd			; 
3ffd			;		; one value on hl get other one back 
3ffd			; 
3ffd			;		pop bc    ; count 
3ffd			; 
3ffd			;		pop de   ; dir 
3ffd			; 
3ffd			; 
3ffd			;		ld b, c 
3ffd			; 
3ffd			;.scrolldir:     push bc 
3ffd			;		push de 
3ffd			; 
3ffd			;		ld a, 0 
3ffd			;		cp e 
3ffd			;		jr z, .scrollup  
3ffd			;		call scroll_down 
3ffd			;		jr .scrollnext 
3ffd			;.scrollup:	call scroll_up 
3ffd			; 
3ffd			;		 
3ffd			;.scrollnext: 
3ffd			;		pop de 
3ffd			;		pop bc 
3ffd			;		djnz .scrolldir 
3ffd			; 
3ffd			; 
3ffd			; 
3ffd			; 
3ffd			; 
3ffd			;		NEXTW 
3ffd			 
3ffd			.SCROLLD: 
3ffd				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ffd 53				db WORD_SYS_CORE+63             
3ffe 2b 40			dw .ATQ            
4000 08				db 7 + 1 
4001 .. 00			db "SCROLLD",0              
4009				endm 
# End of macro CWHEAD
4009			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4009					if DEBUG_FORTH_WORDS_KEY 
4009						DMARK "SCD" 
4009 f5				push af  
400a 3a 1e 40			ld a, (.dmark)  
400d 32 71 ee			ld (debug_mark),a  
4010 3a 1f 40			ld a, (.dmark+1)  
4013 32 72 ee			ld (debug_mark+1),a  
4016 3a 20 40			ld a, (.dmark+2)  
4019 32 73 ee			ld (debug_mark+2),a  
401c 18 03			jr .pastdmark  
401e ..			.dmark: db "SCD"  
4021 f1			.pastdmark: pop af  
4022			endm  
# End of macro DMARK
4022						CALLMONITOR 
4022 cd e8 15			call break_point_state  
4025				endm  
# End of macro CALLMONITOR
4025					endif 
4025			 
4025 cd a0 0b			call scroll_down 
4028			;	call update_display 
4028			 
4028					NEXTW 
4028 c3 0b 20			jp macro_next 
402b				endm 
# End of macro NEXTW
402b			 
402b			 
402b			.ATQ: 
402b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
402b 62				db WORD_SYS_CORE+78             
402c 89 40			dw .AUTODSP            
402e 04				db 3 + 1 
402f .. 00			db "AT@",0              
4033				endm 
# End of macro CWHEAD
4033			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4033					if DEBUG_FORTH_WORDS_KEY 
4033						DMARK "ATA" 
4033 f5				push af  
4034 3a 48 40			ld a, (.dmark)  
4037 32 71 ee			ld (debug_mark),a  
403a 3a 49 40			ld a, (.dmark+1)  
403d 32 72 ee			ld (debug_mark+1),a  
4040 3a 4a 40			ld a, (.dmark+2)  
4043 32 73 ee			ld (debug_mark+2),a  
4046 18 03			jr .pastdmark  
4048 ..			.dmark: db "ATA"  
404b f1			.pastdmark: pop af  
404c			endm  
# End of macro DMARK
404c						CALLMONITOR 
404c cd e8 15			call break_point_state  
404f				endm  
# End of macro CALLMONITOR
404f					endif 
404f			 
404f			 
404f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
404f cd 55 1e			call macro_dsp_valuehl 
4052				endm 
# End of macro FORTH_DSP_VALUEHL
4052			 
4052					; TODO save cursor row 
4052 7d					ld a,l 
4053 fe 02				cp 2 
4055 20 04				jr nz, .crow3aq 
4057 3e 28				ld a, display_row_2 
4059 18 12				jr .ccol1aq 
405b fe 03		.crow3aq:		cp 3 
405d 20 04				jr nz, .crow4aq 
405f 3e 50				ld a, display_row_3 
4061 18 0a				jr .ccol1aq 
4063 fe 04		.crow4aq:		cp 4 
4065 20 04				jr nz, .crow1aq 
4067 3e 78				ld a, display_row_4 
4069 18 02				jr .ccol1aq 
406b 3e 00		.crow1aq:		ld a,display_row_1 
406d f5			.ccol1aq:		push af			; got row offset 
406e 6f					ld l,a 
406f 26 00				ld h,0 
4071					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4071 cd 0d 1f			call macro_forth_dsp_pop 
4074				endm 
# End of macro FORTH_DSP_POP
4074					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4074 cd 55 1e			call macro_dsp_valuehl 
4077				endm 
# End of macro FORTH_DSP_VALUEHL
4077					; TODO save cursor col 
4077 f1					pop af 
4078 85					add l		; add col offset 
4079			 
4079					; add current frame buffer address 
4079 2a d2 eb				ld hl, (display_fb_active) 
407c cd e7 0d				call addatohl 
407f			 
407f			 
407f			 
407f			 
407f					; get char frame buffer location offset in hl 
407f			 
407f 7e					ld a,(hl) 
4080 26 00				ld h, 0 
4082 6f					ld l, a 
4083			 
4083 cd 5e 1c				call forth_push_numhl 
4086			 
4086			 
4086					NEXTW 
4086 c3 0b 20			jp macro_next 
4089				endm 
# End of macro NEXTW
4089			 
4089			.AUTODSP: 
4089				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4089 63				db WORD_SYS_CORE+79             
408a 9f 40			dw .MENU            
408c 05				db 4 + 1 
408d .. 00			db "ADSP",0              
4092				endm 
# End of macro CWHEAD
4092			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4092			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4092			 
4092					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092 cd 55 1e			call macro_dsp_valuehl 
4095				endm 
# End of macro FORTH_DSP_VALUEHL
4095			 
4095			;		push hl 
4095			 
4095					; destroy value TOS 
4095			 
4095					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4095 cd 0d 1f			call macro_forth_dsp_pop 
4098				endm 
# End of macro FORTH_DSP_POP
4098			 
4098			;		pop hl 
4098			 
4098 7d					ld a,l 
4099 32 42 ea				ld (cli_autodisplay), a 
409c				       NEXTW 
409c c3 0b 20			jp macro_next 
409f				endm 
# End of macro NEXTW
409f			 
409f			.MENU: 
409f				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
409f 70				db WORD_SYS_CORE+92             
40a0 48 41			dw .ENDDISPLAY            
40a2 05				db 4 + 1 
40a3 .. 00			db "MENU",0              
40a8				endm 
# End of macro CWHEAD
40a8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
40a8			 
40a8			;		; get number of items on the stack 
40a8			; 
40a8				 
40a8					FORTH_DSP_VALUEHL 
40a8 cd 55 1e			call macro_dsp_valuehl 
40ab				endm 
# End of macro FORTH_DSP_VALUEHL
40ab				 
40ab					if DEBUG_FORTH_WORDS_KEY 
40ab						DMARK "MNU" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 71 ee			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 72 ee			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 73 ee			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "MNU"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4						CALLMONITOR 
40c4 cd e8 15			call break_point_state  
40c7				endm  
# End of macro CALLMONITOR
40c7					endif 
40c7			 
40c7 45					ld b, l	 
40c8 05					dec b 
40c9			 
40c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c9 cd 0d 1f			call macro_forth_dsp_pop 
40cc				endm 
# End of macro FORTH_DSP_POP
40cc			 
40cc			 
40cc					; go directly through the stack to pluck out the string pointers and build an array 
40cc			 
40cc			;		FORTH_DSP 
40cc			 
40cc					; hl contains top most stack item 
40cc				 
40cc 11 c7 e2				ld de, scratch 
40cf			 
40cf			.mbuild: 
40cf			 
40cf					FORTH_DSP_VALUEHL 
40cf cd 55 1e			call macro_dsp_valuehl 
40d2				endm 
# End of macro FORTH_DSP_VALUEHL
40d2			 
40d2					if DEBUG_FORTH_WORDS 
40d2						DMARK "MN3" 
40d2 f5				push af  
40d3 3a e7 40			ld a, (.dmark)  
40d6 32 71 ee			ld (debug_mark),a  
40d9 3a e8 40			ld a, (.dmark+1)  
40dc 32 72 ee			ld (debug_mark+1),a  
40df 3a e9 40			ld a, (.dmark+2)  
40e2 32 73 ee			ld (debug_mark+2),a  
40e5 18 03			jr .pastdmark  
40e7 ..			.dmark: db "MN3"  
40ea f1			.pastdmark: pop af  
40eb			endm  
# End of macro DMARK
40eb						CALLMONITOR 
40eb cd e8 15			call break_point_state  
40ee				endm  
# End of macro CALLMONITOR
40ee					endif 
40ee eb					ex de, hl 
40ef 73					ld (hl), e 
40f0 23					inc hl 
40f1 72					ld (hl), d 
40f2 23					inc hl 
40f3 eb					ex de, hl 
40f4			 
40f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f4 cd 0d 1f			call macro_forth_dsp_pop 
40f7				endm 
# End of macro FORTH_DSP_POP
40f7			 
40f7 10 d6				djnz .mbuild 
40f9			 
40f9					; done add term 
40f9			 
40f9 eb					ex de, hl 
40fa 36 00				ld (hl), 0 
40fc 23					inc hl 
40fd 36 00				ld (hl), 0 
40ff			 
40ff				 
40ff					 
40ff 21 c7 e2				ld hl, scratch 
4102			 
4102					if DEBUG_FORTH_WORDS 
4102						DMARK "MNx" 
4102 f5				push af  
4103 3a 17 41			ld a, (.dmark)  
4106 32 71 ee			ld (debug_mark),a  
4109 3a 18 41			ld a, (.dmark+1)  
410c 32 72 ee			ld (debug_mark+1),a  
410f 3a 19 41			ld a, (.dmark+2)  
4112 32 73 ee			ld (debug_mark+2),a  
4115 18 03			jr .pastdmark  
4117 ..			.dmark: db "MNx"  
411a f1			.pastdmark: pop af  
411b			endm  
# End of macro DMARK
411b						CALLMONITOR 
411b cd e8 15			call break_point_state  
411e				endm  
# End of macro CALLMONITOR
411e					endif 
411e			 
411e			 
411e			 
411e 3e 00				ld a, 0 
4120 cd eb 0b				call menu 
4123			 
4123			 
4123 6f					ld l, a 
4124 26 00				ld h, 0 
4126			 
4126					if DEBUG_FORTH_WORDS 
4126						DMARK "MNr" 
4126 f5				push af  
4127 3a 3b 41			ld a, (.dmark)  
412a 32 71 ee			ld (debug_mark),a  
412d 3a 3c 41			ld a, (.dmark+1)  
4130 32 72 ee			ld (debug_mark+1),a  
4133 3a 3d 41			ld a, (.dmark+2)  
4136 32 73 ee			ld (debug_mark+2),a  
4139 18 03			jr .pastdmark  
413b ..			.dmark: db "MNr"  
413e f1			.pastdmark: pop af  
413f			endm  
# End of macro DMARK
413f						CALLMONITOR 
413f cd e8 15			call break_point_state  
4142				endm  
# End of macro CALLMONITOR
4142					endif 
4142			 
4142 cd 5e 1c				call forth_push_numhl 
4145			 
4145			 
4145			 
4145			 
4145				       NEXTW 
4145 c3 0b 20			jp macro_next 
4148				endm 
# End of macro NEXTW
4148			 
4148			 
4148			.ENDDISPLAY: 
4148			 
4148			; eof 
# End of file forth_words_display.asm
4148			include "forth_words_str.asm" 
4148			 
4148			; | ## String Words 
4148			 
4148			.PTR:   
4148			 
4148				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4148 48				db WORD_SYS_CORE+52             
4149 75 41			dw .STYPE            
414b 04				db 3 + 1 
414c .. 00			db "PTR",0              
4150				endm 
# End of macro CWHEAD
4150			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4150			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4150			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4150			 
4150					if DEBUG_FORTH_WORDS_KEY 
4150						DMARK "PTR" 
4150 f5				push af  
4151 3a 65 41			ld a, (.dmark)  
4154 32 71 ee			ld (debug_mark),a  
4157 3a 66 41			ld a, (.dmark+1)  
415a 32 72 ee			ld (debug_mark+1),a  
415d 3a 67 41			ld a, (.dmark+2)  
4160 32 73 ee			ld (debug_mark+2),a  
4163 18 03			jr .pastdmark  
4165 ..			.dmark: db "PTR"  
4168 f1			.pastdmark: pop af  
4169			endm  
# End of macro DMARK
4169						CALLMONITOR 
4169 cd e8 15			call break_point_state  
416c				endm  
# End of macro CALLMONITOR
416c					endif 
416c					FORTH_DSP_VALUEHL 
416c cd 55 1e			call macro_dsp_valuehl 
416f				endm 
# End of macro FORTH_DSP_VALUEHL
416f cd 5e 1c				call forth_push_numhl 
4172			 
4172			 
4172					NEXTW 
4172 c3 0b 20			jp macro_next 
4175				endm 
# End of macro NEXTW
4175			.STYPE: 
4175				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4175 48				db WORD_SYS_CORE+52             
4176 c4 41			dw .UPPER            
4178 06				db 5 + 1 
4179 .. 00			db "STYPE",0              
417f				endm 
# End of macro CWHEAD
417f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
417f					if DEBUG_FORTH_WORDS_KEY 
417f						DMARK "STY" 
417f f5				push af  
4180 3a 94 41			ld a, (.dmark)  
4183 32 71 ee			ld (debug_mark),a  
4186 3a 95 41			ld a, (.dmark+1)  
4189 32 72 ee			ld (debug_mark+1),a  
418c 3a 96 41			ld a, (.dmark+2)  
418f 32 73 ee			ld (debug_mark+2),a  
4192 18 03			jr .pastdmark  
4194 ..			.dmark: db "STY"  
4197 f1			.pastdmark: pop af  
4198			endm  
# End of macro DMARK
4198						CALLMONITOR 
4198 cd e8 15			call break_point_state  
419b				endm  
# End of macro CALLMONITOR
419b					endif 
419b					FORTH_DSP 
419b cd 1b 1e			call macro_forth_dsp 
419e				endm 
# End of macro FORTH_DSP
419e					;v5 FORTH_DSP_VALUE 
419e			 
419e 7e					ld a, (hl) 
419f			 
419f f5					push af 
41a0			 
41a0			; Dont destroy TOS		FORTH_DSP_POP 
41a0			 
41a0 f1					pop af 
41a1			 
41a1 fe 01				cp DS_TYPE_STR 
41a3 28 09				jr z, .typestr 
41a5			 
41a5 fe 02				cp DS_TYPE_INUM 
41a7 28 0a				jr z, .typeinum 
41a9			 
41a9 21 c2 41				ld hl, .tna 
41ac 18 0a				jr .tpush 
41ae			 
41ae 21 be 41		.typestr:	ld hl, .tstr 
41b1 18 05				jr .tpush 
41b3 21 c0 41		.typeinum:	ld hl, .tinum 
41b6 18 00				jr .tpush 
41b8			 
41b8			.tpush: 
41b8			 
41b8 cd cc 1c				call forth_push_str 
41bb			 
41bb					NEXTW 
41bb c3 0b 20			jp macro_next 
41be				endm 
# End of macro NEXTW
41be .. 00		.tstr:	db "s",0 
41c0 .. 00		.tinum:  db "i",0 
41c2 .. 00		.tna:   db "?", 0 
41c4			 
41c4			 
41c4			.UPPER: 
41c4				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41c4 48				db WORD_SYS_CORE+52             
41c5 ff 41			dw .LOWER            
41c7 06				db 5 + 1 
41c8 .. 00			db "UPPER",0              
41ce				endm 
# End of macro CWHEAD
41ce			; | UPPER ( s -- s ) Upper case string s  | DONE 
41ce					if DEBUG_FORTH_WORDS_KEY 
41ce						DMARK "UPR" 
41ce f5				push af  
41cf 3a e3 41			ld a, (.dmark)  
41d2 32 71 ee			ld (debug_mark),a  
41d5 3a e4 41			ld a, (.dmark+1)  
41d8 32 72 ee			ld (debug_mark+1),a  
41db 3a e5 41			ld a, (.dmark+2)  
41de 32 73 ee			ld (debug_mark+2),a  
41e1 18 03			jr .pastdmark  
41e3 ..			.dmark: db "UPR"  
41e6 f1			.pastdmark: pop af  
41e7			endm  
# End of macro DMARK
41e7						CALLMONITOR 
41e7 cd e8 15			call break_point_state  
41ea				endm  
# End of macro CALLMONITOR
41ea					endif 
41ea			 
41ea					FORTH_DSP 
41ea cd 1b 1e			call macro_forth_dsp 
41ed				endm 
# End of macro FORTH_DSP
41ed					 
41ed			; TODO check is string type 
41ed			 
41ed					FORTH_DSP_VALUEHL 
41ed cd 55 1e			call macro_dsp_valuehl 
41f0				endm 
# End of macro FORTH_DSP_VALUEHL
41f0			; get pointer to string in hl 
41f0			 
41f0 7e			.toup:		ld a, (hl) 
41f1 fe 00				cp 0 
41f3 28 07				jr z, .toupdone 
41f5			 
41f5 cd 54 11				call to_upper 
41f8			 
41f8 77					ld (hl), a 
41f9 23					inc hl 
41fa 18 f4				jr .toup 
41fc			 
41fc					 
41fc			 
41fc			 
41fc			; for each char convert to upper 
41fc					 
41fc			.toupdone: 
41fc			 
41fc			 
41fc					NEXTW 
41fc c3 0b 20			jp macro_next 
41ff				endm 
# End of macro NEXTW
41ff			.LOWER: 
41ff				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41ff 48				db WORD_SYS_CORE+52             
4200 3a 42			dw .TCASE            
4202 06				db 5 + 1 
4203 .. 00			db "LOWER",0              
4209				endm 
# End of macro CWHEAD
4209			; | LOWER ( s -- s ) Lower case string s  | DONE 
4209					if DEBUG_FORTH_WORDS_KEY 
4209						DMARK "LWR" 
4209 f5				push af  
420a 3a 1e 42			ld a, (.dmark)  
420d 32 71 ee			ld (debug_mark),a  
4210 3a 1f 42			ld a, (.dmark+1)  
4213 32 72 ee			ld (debug_mark+1),a  
4216 3a 20 42			ld a, (.dmark+2)  
4219 32 73 ee			ld (debug_mark+2),a  
421c 18 03			jr .pastdmark  
421e ..			.dmark: db "LWR"  
4221 f1			.pastdmark: pop af  
4222			endm  
# End of macro DMARK
4222						CALLMONITOR 
4222 cd e8 15			call break_point_state  
4225				endm  
# End of macro CALLMONITOR
4225					endif 
4225			 
4225					FORTH_DSP 
4225 cd 1b 1e			call macro_forth_dsp 
4228				endm 
# End of macro FORTH_DSP
4228					 
4228			; TODO check is string type 
4228			 
4228					FORTH_DSP_VALUEHL 
4228 cd 55 1e			call macro_dsp_valuehl 
422b				endm 
# End of macro FORTH_DSP_VALUEHL
422b			; get pointer to string in hl 
422b			 
422b 7e			.tolow:		ld a, (hl) 
422c fe 00				cp 0 
422e 28 07				jr z, .tolowdone 
4230			 
4230 cd 5d 11				call to_lower 
4233			 
4233 77					ld (hl), a 
4234 23					inc hl 
4235 18 f4				jr .tolow 
4237			 
4237					 
4237			 
4237			 
4237			; for each char convert to low 
4237					 
4237			.tolowdone: 
4237					NEXTW 
4237 c3 0b 20			jp macro_next 
423a				endm 
# End of macro NEXTW
423a			.TCASE: 
423a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
423a 48				db WORD_SYS_CORE+52             
423b 70 43			dw .SUBSTR            
423d 06				db 5 + 1 
423e .. 00			db "TCASE",0              
4244				endm 
# End of macro CWHEAD
4244			; | TCASE ( s -- s ) Title case string s  | DONE 
4244					if DEBUG_FORTH_WORDS_KEY 
4244						DMARK "TCS" 
4244 f5				push af  
4245 3a 59 42			ld a, (.dmark)  
4248 32 71 ee			ld (debug_mark),a  
424b 3a 5a 42			ld a, (.dmark+1)  
424e 32 72 ee			ld (debug_mark+1),a  
4251 3a 5b 42			ld a, (.dmark+2)  
4254 32 73 ee			ld (debug_mark+2),a  
4257 18 03			jr .pastdmark  
4259 ..			.dmark: db "TCS"  
425c f1			.pastdmark: pop af  
425d			endm  
# End of macro DMARK
425d						CALLMONITOR 
425d cd e8 15			call break_point_state  
4260				endm  
# End of macro CALLMONITOR
4260					endif 
4260			 
4260					FORTH_DSP 
4260 cd 1b 1e			call macro_forth_dsp 
4263				endm 
# End of macro FORTH_DSP
4263					 
4263			; TODO check is string type 
4263			 
4263					FORTH_DSP_VALUEHL 
4263 cd 55 1e			call macro_dsp_valuehl 
4266				endm 
# End of macro FORTH_DSP_VALUEHL
4266			; get pointer to string in hl 
4266			 
4266					if DEBUG_FORTH_WORDS 
4266						DMARK "TC1" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 71 ee			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 72 ee			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 73 ee			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "TC1"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f						CALLMONITOR 
427f cd e8 15			call break_point_state  
4282				endm  
# End of macro CALLMONITOR
4282					endif 
4282			 
4282					; first time in turn to upper case first char 
4282			 
4282 7e					ld a, (hl) 
4283 c3 0d 43				jp .totsiptou 
4286			 
4286			 
4286 7e			.tot:		ld a, (hl) 
4287 fe 00				cp 0 
4289 ca 51 43				jp z, .totdone 
428c			 
428c					if DEBUG_FORTH_WORDS 
428c						DMARK "TC2" 
428c f5				push af  
428d 3a a1 42			ld a, (.dmark)  
4290 32 71 ee			ld (debug_mark),a  
4293 3a a2 42			ld a, (.dmark+1)  
4296 32 72 ee			ld (debug_mark+1),a  
4299 3a a3 42			ld a, (.dmark+2)  
429c 32 73 ee			ld (debug_mark+2),a  
429f 18 03			jr .pastdmark  
42a1 ..			.dmark: db "TC2"  
42a4 f1			.pastdmark: pop af  
42a5			endm  
# End of macro DMARK
42a5						CALLMONITOR 
42a5 cd e8 15			call break_point_state  
42a8				endm  
# End of macro CALLMONITOR
42a8					endif 
42a8					; check to see if current char is a space 
42a8			 
42a8 fe 20				cp ' ' 
42aa 28 21				jr z, .totsp 
42ac cd 5d 11				call to_lower 
42af					if DEBUG_FORTH_WORDS 
42af						DMARK "TC3" 
42af f5				push af  
42b0 3a c4 42			ld a, (.dmark)  
42b3 32 71 ee			ld (debug_mark),a  
42b6 3a c5 42			ld a, (.dmark+1)  
42b9 32 72 ee			ld (debug_mark+1),a  
42bc 3a c6 42			ld a, (.dmark+2)  
42bf 32 73 ee			ld (debug_mark+2),a  
42c2 18 03			jr .pastdmark  
42c4 ..			.dmark: db "TC3"  
42c7 f1			.pastdmark: pop af  
42c8			endm  
# End of macro DMARK
42c8						CALLMONITOR 
42c8 cd e8 15			call break_point_state  
42cb				endm  
# End of macro CALLMONITOR
42cb					endif 
42cb 18 63				jr .totnxt 
42cd			 
42cd			.totsp:         ; on a space, find next char which should be upper 
42cd			 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "TC4" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 71 ee			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 72 ee			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 73 ee			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "TC4"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6						CALLMONITOR 
42e6 cd e8 15			call break_point_state  
42e9				endm  
# End of macro CALLMONITOR
42e9					endif 
42e9					;; 
42e9			 
42e9 fe 20				cp ' ' 
42eb 20 20				jr nz, .totsiptou 
42ed 23					inc hl 
42ee 7e					ld a, (hl) 
42ef					if DEBUG_FORTH_WORDS 
42ef						DMARK "TC5" 
42ef f5				push af  
42f0 3a 04 43			ld a, (.dmark)  
42f3 32 71 ee			ld (debug_mark),a  
42f6 3a 05 43			ld a, (.dmark+1)  
42f9 32 72 ee			ld (debug_mark+1),a  
42fc 3a 06 43			ld a, (.dmark+2)  
42ff 32 73 ee			ld (debug_mark+2),a  
4302 18 03			jr .pastdmark  
4304 ..			.dmark: db "TC5"  
4307 f1			.pastdmark: pop af  
4308			endm  
# End of macro DMARK
4308						CALLMONITOR 
4308 cd e8 15			call break_point_state  
430b				endm  
# End of macro CALLMONITOR
430b					endif 
430b 18 c0				jr .totsp 
430d fe 00		.totsiptou:    cp 0 
430f 28 40				jr z, .totdone 
4311					; not space and not zero term so upper case it 
4311 cd 54 11				call to_upper 
4314			 
4314					if DEBUG_FORTH_WORDS 
4314						DMARK "TC6" 
4314 f5				push af  
4315 3a 29 43			ld a, (.dmark)  
4318 32 71 ee			ld (debug_mark),a  
431b 3a 2a 43			ld a, (.dmark+1)  
431e 32 72 ee			ld (debug_mark+1),a  
4321 3a 2b 43			ld a, (.dmark+2)  
4324 32 73 ee			ld (debug_mark+2),a  
4327 18 03			jr .pastdmark  
4329 ..			.dmark: db "TC6"  
432c f1			.pastdmark: pop af  
432d			endm  
# End of macro DMARK
432d						CALLMONITOR 
432d cd e8 15			call break_point_state  
4330				endm  
# End of macro CALLMONITOR
4330					endif 
4330			 
4330			 
4330			.totnxt: 
4330			 
4330 77					ld (hl), a 
4331 23					inc hl 
4332					if DEBUG_FORTH_WORDS 
4332						DMARK "TC7" 
4332 f5				push af  
4333 3a 47 43			ld a, (.dmark)  
4336 32 71 ee			ld (debug_mark),a  
4339 3a 48 43			ld a, (.dmark+1)  
433c 32 72 ee			ld (debug_mark+1),a  
433f 3a 49 43			ld a, (.dmark+2)  
4342 32 73 ee			ld (debug_mark+2),a  
4345 18 03			jr .pastdmark  
4347 ..			.dmark: db "TC7"  
434a f1			.pastdmark: pop af  
434b			endm  
# End of macro DMARK
434b						CALLMONITOR 
434b cd e8 15			call break_point_state  
434e				endm  
# End of macro CALLMONITOR
434e					endif 
434e c3 86 42				jp .tot 
4351			 
4351					 
4351			 
4351			 
4351			; for each char convert to low 
4351					 
4351			.totdone: 
4351					if DEBUG_FORTH_WORDS 
4351						DMARK "TCd" 
4351 f5				push af  
4352 3a 66 43			ld a, (.dmark)  
4355 32 71 ee			ld (debug_mark),a  
4358 3a 67 43			ld a, (.dmark+1)  
435b 32 72 ee			ld (debug_mark+1),a  
435e 3a 68 43			ld a, (.dmark+2)  
4361 32 73 ee			ld (debug_mark+2),a  
4364 18 03			jr .pastdmark  
4366 ..			.dmark: db "TCd"  
4369 f1			.pastdmark: pop af  
436a			endm  
# End of macro DMARK
436a						CALLMONITOR 
436a cd e8 15			call break_point_state  
436d				endm  
# End of macro CALLMONITOR
436d					endif 
436d					NEXTW 
436d c3 0b 20			jp macro_next 
4370				endm 
# End of macro NEXTW
4370			 
4370			.SUBSTR: 
4370				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4370 48				db WORD_SYS_CORE+52             
4371 ce 43			dw .LEFT            
4373 07				db 6 + 1 
4374 .. 00			db "SUBSTR",0              
437b				endm 
# End of macro CWHEAD
437b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
437b			 
437b					if DEBUG_FORTH_WORDS_KEY 
437b						DMARK "SST" 
437b f5				push af  
437c 3a 90 43			ld a, (.dmark)  
437f 32 71 ee			ld (debug_mark),a  
4382 3a 91 43			ld a, (.dmark+1)  
4385 32 72 ee			ld (debug_mark+1),a  
4388 3a 92 43			ld a, (.dmark+2)  
438b 32 73 ee			ld (debug_mark+2),a  
438e 18 03			jr .pastdmark  
4390 ..			.dmark: db "SST"  
4393 f1			.pastdmark: pop af  
4394			endm  
# End of macro DMARK
4394						CALLMONITOR 
4394 cd e8 15			call break_point_state  
4397				endm  
# End of macro CALLMONITOR
4397					endif 
4397			; TODO check string type 
4397					FORTH_DSP_VALUEHL 
4397 cd 55 1e			call macro_dsp_valuehl 
439a				endm 
# End of macro FORTH_DSP_VALUEHL
439a			 
439a e5					push hl      ; string length 
439b			 
439b					FORTH_DSP_POP 
439b cd 0d 1f			call macro_forth_dsp_pop 
439e				endm 
# End of macro FORTH_DSP_POP
439e			 
439e					FORTH_DSP_VALUEHL 
439e cd 55 1e			call macro_dsp_valuehl 
43a1				endm 
# End of macro FORTH_DSP_VALUEHL
43a1			 
43a1 e5					push hl     ; start char 
43a2			 
43a2					FORTH_DSP_POP 
43a2 cd 0d 1f			call macro_forth_dsp_pop 
43a5				endm 
# End of macro FORTH_DSP_POP
43a5			 
43a5			 
43a5					FORTH_DSP_VALUE 
43a5 cd 3e 1e			call macro_forth_dsp_value 
43a8				endm 
# End of macro FORTH_DSP_VALUE
43a8			 
43a8 d1					pop de    ; get start post offset 
43a9			 
43a9 19					add hl, de    ; starting offset 
43aa			 
43aa c1					pop bc 
43ab c5					push bc      ; grab size of string 
43ac			 
43ac e5					push hl    ; save string start  
43ad			 
43ad 26 00				ld h, 0 
43af 69					ld l, c 
43b0 23					inc hl 
43b1 23					inc hl 
43b2			 
43b2 cd ae 12				call malloc 
43b5				if DEBUG_FORTH_MALLOC_GUARD 
43b5 cc 16 4d				call z,malloc_error 
43b8				endif 
43b8			 
43b8 eb					ex de, hl      ; save malloc area for string copy 
43b9 e1					pop hl    ; get back source 
43ba c1					pop bc    ; get length of string back 
43bb			 
43bb d5					push de    ; save malloc area for after we push 
43bc ed b0				ldir     ; copy substr 
43be			 
43be			 
43be eb					ex de, hl 
43bf 3e 00				ld a, 0 
43c1 77					ld (hl), a   ; term substr 
43c2			 
43c2					 
43c2 e1					pop hl    ; get malloc so we can push it 
43c3 e5					push hl   ; save so we can free it afterwards 
43c4			 
43c4 cd cc 1c				call forth_push_str 
43c7			 
43c7 e1					pop hl 
43c8 cd 78 13				call free 
43cb			 
43cb					 
43cb					 
43cb			 
43cb			 
43cb					NEXTW 
43cb c3 0b 20			jp macro_next 
43ce				endm 
# End of macro NEXTW
43ce			 
43ce			.LEFT: 
43ce				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43ce 48				db WORD_SYS_CORE+52             
43cf f6 43			dw .RIGHT            
43d1 05				db 4 + 1 
43d2 .. 00			db "LEFT",0              
43d7				endm 
# End of macro CWHEAD
43d7			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43d7					if DEBUG_FORTH_WORDS_KEY 
43d7						DMARK "LEF" 
43d7 f5				push af  
43d8 3a ec 43			ld a, (.dmark)  
43db 32 71 ee			ld (debug_mark),a  
43de 3a ed 43			ld a, (.dmark+1)  
43e1 32 72 ee			ld (debug_mark+1),a  
43e4 3a ee 43			ld a, (.dmark+2)  
43e7 32 73 ee			ld (debug_mark+2),a  
43ea 18 03			jr .pastdmark  
43ec ..			.dmark: db "LEF"  
43ef f1			.pastdmark: pop af  
43f0			endm  
# End of macro DMARK
43f0						CALLMONITOR 
43f0 cd e8 15			call break_point_state  
43f3				endm  
# End of macro CALLMONITOR
43f3					endif 
43f3			 
43f3					NEXTW 
43f3 c3 0b 20			jp macro_next 
43f6				endm 
# End of macro NEXTW
43f6			.RIGHT: 
43f6				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
43f6 48				db WORD_SYS_CORE+52             
43f7 1f 44			dw .STR2NUM            
43f9 06				db 5 + 1 
43fa .. 00			db "RIGHT",0              
4400				endm 
# End of macro CWHEAD
4400			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4400					if DEBUG_FORTH_WORDS_KEY 
4400						DMARK "RIG" 
4400 f5				push af  
4401 3a 15 44			ld a, (.dmark)  
4404 32 71 ee			ld (debug_mark),a  
4407 3a 16 44			ld a, (.dmark+1)  
440a 32 72 ee			ld (debug_mark+1),a  
440d 3a 17 44			ld a, (.dmark+2)  
4410 32 73 ee			ld (debug_mark+2),a  
4413 18 03			jr .pastdmark  
4415 ..			.dmark: db "RIG"  
4418 f1			.pastdmark: pop af  
4419			endm  
# End of macro DMARK
4419						CALLMONITOR 
4419 cd e8 15			call break_point_state  
441c				endm  
# End of macro CALLMONITOR
441c					endif 
441c			 
441c					NEXTW 
441c c3 0b 20			jp macro_next 
441f				endm 
# End of macro NEXTW
441f			 
441f			 
441f			.STR2NUM: 
441f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
441f 48				db WORD_SYS_CORE+52             
4420 ab 44			dw .NUM2STR            
4422 08				db 7 + 1 
4423 .. 00			db "STR2NUM",0              
442b				endm 
# End of macro CWHEAD
442b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
442b			 
442b			 
442b			; TODO STR type check to do 
442b					if DEBUG_FORTH_WORDS_KEY 
442b						DMARK "S2N" 
442b f5				push af  
442c 3a 40 44			ld a, (.dmark)  
442f 32 71 ee			ld (debug_mark),a  
4432 3a 41 44			ld a, (.dmark+1)  
4435 32 72 ee			ld (debug_mark+1),a  
4438 3a 42 44			ld a, (.dmark+2)  
443b 32 73 ee			ld (debug_mark+2),a  
443e 18 03			jr .pastdmark  
4440 ..			.dmark: db "S2N"  
4443 f1			.pastdmark: pop af  
4444			endm  
# End of macro DMARK
4444						CALLMONITOR 
4444 cd e8 15			call break_point_state  
4447				endm  
# End of macro CALLMONITOR
4447					endif 
4447			 
4447					;FORTH_DSP 
4447					FORTH_DSP_VALUE 
4447 cd 3e 1e			call macro_forth_dsp_value 
444a				endm 
# End of macro FORTH_DSP_VALUE
444a					;inc hl 
444a			 
444a eb					ex de, hl 
444b					if DEBUG_FORTH_WORDS 
444b						DMARK "S2a" 
444b f5				push af  
444c 3a 60 44			ld a, (.dmark)  
444f 32 71 ee			ld (debug_mark),a  
4452 3a 61 44			ld a, (.dmark+1)  
4455 32 72 ee			ld (debug_mark+1),a  
4458 3a 62 44			ld a, (.dmark+2)  
445b 32 73 ee			ld (debug_mark+2),a  
445e 18 03			jr .pastdmark  
4460 ..			.dmark: db "S2a"  
4463 f1			.pastdmark: pop af  
4464			endm  
# End of macro DMARK
4464						CALLMONITOR 
4464 cd e8 15			call break_point_state  
4467				endm  
# End of macro CALLMONITOR
4467					endif 
4467 cd dc 11				call string_to_uint16 
446a			 
446a					if DEBUG_FORTH_WORDS 
446a						DMARK "S2b" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 71 ee			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 72 ee			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 73 ee			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "S2b"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483						CALLMONITOR 
4483 cd e8 15			call break_point_state  
4486				endm  
# End of macro CALLMONITOR
4486					endif 
4486			;		push hl 
4486					FORTH_DSP_POP 
4486 cd 0d 1f			call macro_forth_dsp_pop 
4489				endm 
# End of macro FORTH_DSP_POP
4489			;		pop hl 
4489					 
4489					if DEBUG_FORTH_WORDS 
4489						DMARK "S2b" 
4489 f5				push af  
448a 3a 9e 44			ld a, (.dmark)  
448d 32 71 ee			ld (debug_mark),a  
4490 3a 9f 44			ld a, (.dmark+1)  
4493 32 72 ee			ld (debug_mark+1),a  
4496 3a a0 44			ld a, (.dmark+2)  
4499 32 73 ee			ld (debug_mark+2),a  
449c 18 03			jr .pastdmark  
449e ..			.dmark: db "S2b"  
44a1 f1			.pastdmark: pop af  
44a2			endm  
# End of macro DMARK
44a2						CALLMONITOR 
44a2 cd e8 15			call break_point_state  
44a5				endm  
# End of macro CALLMONITOR
44a5					endif 
44a5 cd 5e 1c				call forth_push_numhl	 
44a8			 
44a8				 
44a8				       NEXTW 
44a8 c3 0b 20			jp macro_next 
44ab				endm 
# End of macro NEXTW
44ab			.NUM2STR: 
44ab				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44ab 48				db WORD_SYS_CORE+52             
44ac ba 44			dw .CONCAT            
44ae 08				db 7 + 1 
44af .. 00			db "NUM2STR",0              
44b7				endm 
# End of macro CWHEAD
44b7			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
44b7			 
44b7			;		; malloc a string to target 
44b7			;		ld hl, 10     ; TODO max string size should be fine 
44b7			;		call malloc 
44b7			;		push hl    ; save malloc location 
44b7			; 
44b7			; 
44b7			;; TODO check int type 
44b7			;		FORTH_DSP_VALUEHL 
44b7			;		ld a, l 
44b7			;		call DispAToASCII   
44b7			;;TODO need to chage above call to dump into string 
44b7			; 
44b7			; 
44b7			 
44b7				       NEXTW 
44b7 c3 0b 20			jp macro_next 
44ba				endm 
# End of macro NEXTW
44ba			 
44ba			.CONCAT: 
44ba				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44ba 48				db WORD_SYS_CORE+52             
44bb 6d 45			dw .FIND            
44bd 07				db 6 + 1 
44be .. 00			db "CONCAT",0              
44c5				endm 
# End of macro CWHEAD
44c5			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44c5			 
44c5			; TODO check string type 
44c5			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44c5			 
44c5					if DEBUG_FORTH_WORDS_KEY 
44c5						DMARK "CON" 
44c5 f5				push af  
44c6 3a da 44			ld a, (.dmark)  
44c9 32 71 ee			ld (debug_mark),a  
44cc 3a db 44			ld a, (.dmark+1)  
44cf 32 72 ee			ld (debug_mark+1),a  
44d2 3a dc 44			ld a, (.dmark+2)  
44d5 32 73 ee			ld (debug_mark+2),a  
44d8 18 03			jr .pastdmark  
44da ..			.dmark: db "CON"  
44dd f1			.pastdmark: pop af  
44de			endm  
# End of macro DMARK
44de						CALLMONITOR 
44de cd e8 15			call break_point_state  
44e1				endm  
# End of macro CALLMONITOR
44e1					endif 
44e1			 
44e1			 
44e1					FORTH_DSP_VALUE 
44e1 cd 3e 1e			call macro_forth_dsp_value 
44e4				endm 
# End of macro FORTH_DSP_VALUE
44e4 e5					push hl   ; s2 
44e5			 
44e5					FORTH_DSP_POP 
44e5 cd 0d 1f			call macro_forth_dsp_pop 
44e8				endm 
# End of macro FORTH_DSP_POP
44e8			 
44e8					FORTH_DSP_VALUE 
44e8 cd 3e 1e			call macro_forth_dsp_value 
44eb				endm 
# End of macro FORTH_DSP_VALUE
44eb			 
44eb e5					push hl   ; s1 
44ec			 
44ec					FORTH_DSP_POP 
44ec cd 0d 1f			call macro_forth_dsp_pop 
44ef				endm 
# End of macro FORTH_DSP_POP
44ef					 
44ef			 
44ef					; copy s1 
44ef			 
44ef				 
44ef					; save ptr 
44ef e1					pop hl  
44f0 e5					push hl 
44f1 3e 00				ld a, 0 
44f3 cd 50 12				call strlent 
44f6					;inc hl    ; zer0 
44f6 06 00				ld b, 0 
44f8 4d					ld c, l 
44f9 e1					pop hl		 
44fa 11 c7 e2				ld de, scratch	 
44fd					if DEBUG_FORTH_WORDS 
44fd						DMARK "CO1" 
44fd f5				push af  
44fe 3a 12 45			ld a, (.dmark)  
4501 32 71 ee			ld (debug_mark),a  
4504 3a 13 45			ld a, (.dmark+1)  
4507 32 72 ee			ld (debug_mark+1),a  
450a 3a 14 45			ld a, (.dmark+2)  
450d 32 73 ee			ld (debug_mark+2),a  
4510 18 03			jr .pastdmark  
4512 ..			.dmark: db "CO1"  
4515 f1			.pastdmark: pop af  
4516			endm  
# End of macro DMARK
4516						CALLMONITOR 
4516 cd e8 15			call break_point_state  
4519				endm  
# End of macro CALLMONITOR
4519					endif 
4519 ed b0				ldir 
451b			 
451b e1					pop hl 
451c e5					push hl 
451d d5					push de 
451e			 
451e			 
451e 3e 00				ld a, 0 
4520 cd 50 12				call strlent 
4523 23					inc hl    ; zer0 
4524 23					inc hl 
4525 06 00				ld b, 0 
4527 4d					ld c, l 
4528 d1					pop de 
4529 e1					pop hl		 
452a					if DEBUG_FORTH_WORDS 
452a						DMARK "CO2" 
452a f5				push af  
452b 3a 3f 45			ld a, (.dmark)  
452e 32 71 ee			ld (debug_mark),a  
4531 3a 40 45			ld a, (.dmark+1)  
4534 32 72 ee			ld (debug_mark+1),a  
4537 3a 41 45			ld a, (.dmark+2)  
453a 32 73 ee			ld (debug_mark+2),a  
453d 18 03			jr .pastdmark  
453f ..			.dmark: db "CO2"  
4542 f1			.pastdmark: pop af  
4543			endm  
# End of macro DMARK
4543						CALLMONITOR 
4543 cd e8 15			call break_point_state  
4546				endm  
# End of macro CALLMONITOR
4546					endif 
4546 ed b0				ldir 
4548			 
4548			 
4548			 
4548 21 c7 e2				ld hl, scratch 
454b					if DEBUG_FORTH_WORDS 
454b						DMARK "CO5" 
454b f5				push af  
454c 3a 60 45			ld a, (.dmark)  
454f 32 71 ee			ld (debug_mark),a  
4552 3a 61 45			ld a, (.dmark+1)  
4555 32 72 ee			ld (debug_mark+1),a  
4558 3a 62 45			ld a, (.dmark+2)  
455b 32 73 ee			ld (debug_mark+2),a  
455e 18 03			jr .pastdmark  
4560 ..			.dmark: db "CO5"  
4563 f1			.pastdmark: pop af  
4564			endm  
# End of macro DMARK
4564						CALLMONITOR 
4564 cd e8 15			call break_point_state  
4567				endm  
# End of macro CALLMONITOR
4567					endif 
4567			 
4567 cd cc 1c				call forth_push_str 
456a			 
456a			 
456a			 
456a			 
456a				       NEXTW 
456a c3 0b 20			jp macro_next 
456d				endm 
# End of macro NEXTW
456d			 
456d			 
456d			.FIND: 
456d				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
456d 4b				db WORD_SYS_CORE+55             
456e 2b 46			dw .LEN            
4570 05				db 4 + 1 
4571 .. 00			db "FIND",0              
4576				endm 
# End of macro CWHEAD
4576			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4576			 
4576					if DEBUG_FORTH_WORDS_KEY 
4576						DMARK "FND" 
4576 f5				push af  
4577 3a 8b 45			ld a, (.dmark)  
457a 32 71 ee			ld (debug_mark),a  
457d 3a 8c 45			ld a, (.dmark+1)  
4580 32 72 ee			ld (debug_mark+1),a  
4583 3a 8d 45			ld a, (.dmark+2)  
4586 32 73 ee			ld (debug_mark+2),a  
4589 18 03			jr .pastdmark  
458b ..			.dmark: db "FND"  
458e f1			.pastdmark: pop af  
458f			endm  
# End of macro DMARK
458f						CALLMONITOR 
458f cd e8 15			call break_point_state  
4592				endm  
# End of macro CALLMONITOR
4592					endif 
4592			 
4592			; TODO check string type 
4592					FORTH_DSP_VALUE 
4592 cd 3e 1e			call macro_forth_dsp_value 
4595				endm 
# End of macro FORTH_DSP_VALUE
4595			 
4595 e5					push hl    
4596 7e					ld a,(hl)    ; char to find   
4597			; TODO change char to substr 
4597			 
4597 f5					push af 
4598					 
4598			 
4598			 
4598					if DEBUG_FORTH_WORDS 
4598						DMARK "FN1" 
4598 f5				push af  
4599 3a ad 45			ld a, (.dmark)  
459c 32 71 ee			ld (debug_mark),a  
459f 3a ae 45			ld a, (.dmark+1)  
45a2 32 72 ee			ld (debug_mark+1),a  
45a5 3a af 45			ld a, (.dmark+2)  
45a8 32 73 ee			ld (debug_mark+2),a  
45ab 18 03			jr .pastdmark  
45ad ..			.dmark: db "FN1"  
45b0 f1			.pastdmark: pop af  
45b1			endm  
# End of macro DMARK
45b1						CALLMONITOR 
45b1 cd e8 15			call break_point_state  
45b4				endm  
# End of macro CALLMONITOR
45b4					endif 
45b4			 
45b4					FORTH_DSP_POP 
45b4 cd 0d 1f			call macro_forth_dsp_pop 
45b7				endm 
# End of macro FORTH_DSP_POP
45b7			 
45b7					; string to search 
45b7			 
45b7					FORTH_DSP_VALUE 
45b7 cd 3e 1e			call macro_forth_dsp_value 
45ba				endm 
# End of macro FORTH_DSP_VALUE
45ba			 
45ba d1					pop de  ; d is char to find  
45bb			 
45bb					if DEBUG_FORTH_WORDS 
45bb						DMARK "FN2" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 71 ee			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 72 ee			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 73 ee			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "FN2"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd e8 15			call break_point_state  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7					 
45d7 01 00 00				ld bc, 0 
45da 7e			.findchar:      ld a,(hl) 
45db fe 00				cp 0   		 
45dd 28 27				jr z, .finddone     
45df ba					cp d 
45e0 28 20				jr z, .foundchar 
45e2 03					inc bc 
45e3 23					inc hl 
45e4					if DEBUG_FORTH_WORDS 
45e4						DMARK "FN3" 
45e4 f5				push af  
45e5 3a f9 45			ld a, (.dmark)  
45e8 32 71 ee			ld (debug_mark),a  
45eb 3a fa 45			ld a, (.dmark+1)  
45ee 32 72 ee			ld (debug_mark+1),a  
45f1 3a fb 45			ld a, (.dmark+2)  
45f4 32 73 ee			ld (debug_mark+2),a  
45f7 18 03			jr .pastdmark  
45f9 ..			.dmark: db "FN3"  
45fc f1			.pastdmark: pop af  
45fd			endm  
# End of macro DMARK
45fd						CALLMONITOR 
45fd cd e8 15			call break_point_state  
4600				endm  
# End of macro CALLMONITOR
4600					endif 
4600 18 d8				jr .findchar 
4602			 
4602			 
4602 c5			.foundchar:	push bc 
4603 e1					pop hl 
4604 18 03				jr .findexit 
4606			 
4606			 
4606							 
4606			 
4606			.finddone:     ; got to end of string with no find 
4606 21 00 00				ld hl, 0 
4609			.findexit: 
4609			 
4609					if DEBUG_FORTH_WORDS 
4609						DMARK "FNd" 
4609 f5				push af  
460a 3a 1e 46			ld a, (.dmark)  
460d 32 71 ee			ld (debug_mark),a  
4610 3a 1f 46			ld a, (.dmark+1)  
4613 32 72 ee			ld (debug_mark+1),a  
4616 3a 20 46			ld a, (.dmark+2)  
4619 32 73 ee			ld (debug_mark+2),a  
461c 18 03			jr .pastdmark  
461e ..			.dmark: db "FNd"  
4621 f1			.pastdmark: pop af  
4622			endm  
# End of macro DMARK
4622						CALLMONITOR 
4622 cd e8 15			call break_point_state  
4625				endm  
# End of macro CALLMONITOR
4625					endif 
4625 cd 5e 1c			call forth_push_numhl 
4628			 
4628				       NEXTW 
4628 c3 0b 20			jp macro_next 
462b				endm 
# End of macro NEXTW
462b			 
462b			.LEN: 
462b				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
462b 4c				db WORD_SYS_CORE+56             
462c 95 46			dw .ASC            
462e 06				db 5 + 1 
462f .. 00			db "COUNT",0              
4635				endm 
# End of macro CWHEAD
4635			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4635			 
4635					if DEBUG_FORTH_WORDS_KEY 
4635						DMARK "CNT" 
4635 f5				push af  
4636 3a 4a 46			ld a, (.dmark)  
4639 32 71 ee			ld (debug_mark),a  
463c 3a 4b 46			ld a, (.dmark+1)  
463f 32 72 ee			ld (debug_mark+1),a  
4642 3a 4c 46			ld a, (.dmark+2)  
4645 32 73 ee			ld (debug_mark+2),a  
4648 18 03			jr .pastdmark  
464a ..			.dmark: db "CNT"  
464d f1			.pastdmark: pop af  
464e			endm  
# End of macro DMARK
464e						CALLMONITOR 
464e cd e8 15			call break_point_state  
4651				endm  
# End of macro CALLMONITOR
4651					endif 
4651			; TODO check string type 
4651					FORTH_DSP_VALUE 
4651 cd 3e 1e			call macro_forth_dsp_value 
4654				endm 
# End of macro FORTH_DSP_VALUE
4654			 
4654			 
4654					if DEBUG_FORTH_WORDS 
4654						DMARK "CN?" 
4654 f5				push af  
4655 3a 69 46			ld a, (.dmark)  
4658 32 71 ee			ld (debug_mark),a  
465b 3a 6a 46			ld a, (.dmark+1)  
465e 32 72 ee			ld (debug_mark+1),a  
4661 3a 6b 46			ld a, (.dmark+2)  
4664 32 73 ee			ld (debug_mark+2),a  
4667 18 03			jr .pastdmark  
4669 ..			.dmark: db "CN?"  
466c f1			.pastdmark: pop af  
466d			endm  
# End of macro DMARK
466d						CALLMONITOR 
466d cd e8 15			call break_point_state  
4670				endm  
# End of macro CALLMONITOR
4670					endif 
4670 cd 45 12				call strlenz 
4673					if DEBUG_FORTH_WORDS 
4673						DMARK "CNl" 
4673 f5				push af  
4674 3a 88 46			ld a, (.dmark)  
4677 32 71 ee			ld (debug_mark),a  
467a 3a 89 46			ld a, (.dmark+1)  
467d 32 72 ee			ld (debug_mark+1),a  
4680 3a 8a 46			ld a, (.dmark+2)  
4683 32 73 ee			ld (debug_mark+2),a  
4686 18 03			jr .pastdmark  
4688 ..			.dmark: db "CNl"  
468b f1			.pastdmark: pop af  
468c			endm  
# End of macro DMARK
468c						CALLMONITOR 
468c cd e8 15			call break_point_state  
468f				endm  
# End of macro CALLMONITOR
468f					endif 
468f			 
468f cd 5e 1c				call forth_push_numhl 
4692			 
4692			 
4692			 
4692				       NEXTW 
4692 c3 0b 20			jp macro_next 
4695				endm 
# End of macro NEXTW
4695			.ASC: 
4695				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4695 4d				db WORD_SYS_CORE+57             
4696 03 47			dw .CHR            
4698 04				db 3 + 1 
4699 .. 00			db "ASC",0              
469d				endm 
# End of macro CWHEAD
469d			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
469d					if DEBUG_FORTH_WORDS_KEY 
469d						DMARK "ASC" 
469d f5				push af  
469e 3a b2 46			ld a, (.dmark)  
46a1 32 71 ee			ld (debug_mark),a  
46a4 3a b3 46			ld a, (.dmark+1)  
46a7 32 72 ee			ld (debug_mark+1),a  
46aa 3a b4 46			ld a, (.dmark+2)  
46ad 32 73 ee			ld (debug_mark+2),a  
46b0 18 03			jr .pastdmark  
46b2 ..			.dmark: db "ASC"  
46b5 f1			.pastdmark: pop af  
46b6			endm  
# End of macro DMARK
46b6						CALLMONITOR 
46b6 cd e8 15			call break_point_state  
46b9				endm  
# End of macro CALLMONITOR
46b9					endif 
46b9					FORTH_DSP_VALUE 
46b9 cd 3e 1e			call macro_forth_dsp_value 
46bc				endm 
# End of macro FORTH_DSP_VALUE
46bc					;v5 FORTH_DSP_VALUE 
46bc			;		inc hl      ; now at start of numeric as string 
46bc			 
46bc e5					push hl 
46bd			 
46bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46bd cd 0d 1f			call macro_forth_dsp_pop 
46c0				endm 
# End of macro FORTH_DSP_POP
46c0			 
46c0 e1					pop hl 
46c1			 
46c1					if DEBUG_FORTH_WORDS 
46c1						DMARK "AS1" 
46c1 f5				push af  
46c2 3a d6 46			ld a, (.dmark)  
46c5 32 71 ee			ld (debug_mark),a  
46c8 3a d7 46			ld a, (.dmark+1)  
46cb 32 72 ee			ld (debug_mark+1),a  
46ce 3a d8 46			ld a, (.dmark+2)  
46d1 32 73 ee			ld (debug_mark+2),a  
46d4 18 03			jr .pastdmark  
46d6 ..			.dmark: db "AS1"  
46d9 f1			.pastdmark: pop af  
46da			endm  
# End of macro DMARK
46da						CALLMONITOR 
46da cd e8 15			call break_point_state  
46dd				endm  
# End of macro CALLMONITOR
46dd					endif 
46dd					; push the content of a onto the stack as a value 
46dd			 
46dd 7e					ld a,(hl)   ; get char 
46de 26 00				ld h,0 
46e0 6f					ld l,a 
46e1					if DEBUG_FORTH_WORDS 
46e1						DMARK "AS2" 
46e1 f5				push af  
46e2 3a f6 46			ld a, (.dmark)  
46e5 32 71 ee			ld (debug_mark),a  
46e8 3a f7 46			ld a, (.dmark+1)  
46eb 32 72 ee			ld (debug_mark+1),a  
46ee 3a f8 46			ld a, (.dmark+2)  
46f1 32 73 ee			ld (debug_mark+2),a  
46f4 18 03			jr .pastdmark  
46f6 ..			.dmark: db "AS2"  
46f9 f1			.pastdmark: pop af  
46fa			endm  
# End of macro DMARK
46fa						CALLMONITOR 
46fa cd e8 15			call break_point_state  
46fd				endm  
# End of macro CALLMONITOR
46fd					endif 
46fd cd 5e 1c				call forth_push_numhl 
4700			 
4700				       NEXTW 
4700 c3 0b 20			jp macro_next 
4703				endm 
# End of macro NEXTW
4703			 
4703			.CHR: 
4703				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4703 4d				db WORD_SYS_CORE+57             
4704 3f 47			dw .ENDSTR            
4706 04				db 3 + 1 
4707 .. 00			db "CHR",0              
470b				endm 
# End of macro CWHEAD
470b			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
470b					if DEBUG_FORTH_WORDS_KEY 
470b						DMARK "CHR" 
470b f5				push af  
470c 3a 20 47			ld a, (.dmark)  
470f 32 71 ee			ld (debug_mark),a  
4712 3a 21 47			ld a, (.dmark+1)  
4715 32 72 ee			ld (debug_mark+1),a  
4718 3a 22 47			ld a, (.dmark+2)  
471b 32 73 ee			ld (debug_mark+2),a  
471e 18 03			jr .pastdmark  
4720 ..			.dmark: db "CHR"  
4723 f1			.pastdmark: pop af  
4724			endm  
# End of macro DMARK
4724						CALLMONITOR 
4724 cd e8 15			call break_point_state  
4727				endm  
# End of macro CALLMONITOR
4727					endif 
4727					FORTH_DSP_VALUEHL 
4727 cd 55 1e			call macro_dsp_valuehl 
472a				endm 
# End of macro FORTH_DSP_VALUEHL
472a			 
472a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
472a cd 0d 1f			call macro_forth_dsp_pop 
472d				endm 
# End of macro FORTH_DSP_POP
472d			 
472d					; save asci byte as a zero term string and push string 
472d			 
472d 7d					ld a,l 
472e 32 c7 e2				ld (scratch), a 
4731			 
4731 3e 00				ld a, 0 
4733 32 c8 e2				ld (scratch+1), a 
4736			 
4736 21 c7 e2				ld hl, scratch 
4739 cd cc 1c				call forth_push_str 
473c			 
473c			 
473c				       NEXTW 
473c c3 0b 20			jp macro_next 
473f				endm 
# End of macro NEXTW
473f			 
473f			 
473f			 
473f			 
473f			.ENDSTR: 
473f			; eof 
473f			 
# End of file forth_words_str.asm
473f			include "forth_words_key.asm" 
473f			 
473f			; | ## Keyboard Words 
473f			 
473f			.KEY: 
473f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
473f 3e				db WORD_SYS_CORE+42             
4740 6f 47			dw .WAITK            
4742 04				db 3 + 1 
4743 .. 00			db "KEY",0              
4747				endm 
# End of macro CWHEAD
4747			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4747			 
4747					if DEBUG_FORTH_WORDS_KEY 
4747						DMARK "KEY" 
4747 f5				push af  
4748 3a 5c 47			ld a, (.dmark)  
474b 32 71 ee			ld (debug_mark),a  
474e 3a 5d 47			ld a, (.dmark+1)  
4751 32 72 ee			ld (debug_mark+1),a  
4754 3a 5e 47			ld a, (.dmark+2)  
4757 32 73 ee			ld (debug_mark+2),a  
475a 18 03			jr .pastdmark  
475c ..			.dmark: db "KEY"  
475f f1			.pastdmark: pop af  
4760			endm  
# End of macro DMARK
4760						CALLMONITOR 
4760 cd e8 15			call break_point_state  
4763				endm  
# End of macro CALLMONITOR
4763					endif 
4763			; TODO currently waits 
4763 cd 9f 64				call cin 
4766					;call cin_wait 
4766 6f					ld l, a 
4767 26 00				ld h, 0 
4769 cd 5e 1c				call forth_push_numhl 
476c					NEXTW 
476c c3 0b 20			jp macro_next 
476f				endm 
# End of macro NEXTW
476f			.WAITK: 
476f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
476f 3f				db WORD_SYS_CORE+43             
4770 a1 47			dw .ACCEPT            
4772 06				db 5 + 1 
4773 .. 00			db "WAITK",0              
4779				endm 
# End of macro CWHEAD
4779			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4779					if DEBUG_FORTH_WORDS_KEY 
4779						DMARK "WAI" 
4779 f5				push af  
477a 3a 8e 47			ld a, (.dmark)  
477d 32 71 ee			ld (debug_mark),a  
4780 3a 8f 47			ld a, (.dmark+1)  
4783 32 72 ee			ld (debug_mark+1),a  
4786 3a 90 47			ld a, (.dmark+2)  
4789 32 73 ee			ld (debug_mark+2),a  
478c 18 03			jr .pastdmark  
478e ..			.dmark: db "WAI"  
4791 f1			.pastdmark: pop af  
4792			endm  
# End of macro DMARK
4792						CALLMONITOR 
4792 cd e8 15			call break_point_state  
4795				endm  
# End of macro CALLMONITOR
4795					endif 
4795 cd 97 64				call cin_wait 
4798 6f					ld l, a 
4799 26 00				ld h, 0 
479b cd 5e 1c				call forth_push_numhl 
479e					NEXTW 
479e c3 0b 20			jp macro_next 
47a1				endm 
# End of macro NEXTW
47a1			.ACCEPT: 
47a1				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47a1 40				db WORD_SYS_CORE+44             
47a2 ff 47			dw .EDIT            
47a4 07				db 6 + 1 
47a5 .. 00			db "ACCEPT",0              
47ac				endm 
# End of macro CWHEAD
47ac			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47ac					; TODO crashes on push 
47ac					if DEBUG_FORTH_WORDS_KEY 
47ac						DMARK "ACC" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 71 ee			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 72 ee			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 73 ee			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "ACC"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd e8 15			call break_point_state  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8 21 c5 e4				ld hl, os_input 
47cb 3e 00				ld a, 0 
47cd 77					ld (hl),a 
47ce 3a 64 ea				ld a,(f_cursor_ptr) 
47d1 16 64				ld d, 100 
47d3 0e 00				ld c, 0 
47d5 1e 28				ld e, 40 
47d7 cd 14 0e				call input_str 
47da					; TODO perhaps do a type check and wrap in quotes if not a number 
47da 21 c5 e4				ld hl, os_input 
47dd					if DEBUG_FORTH_WORDS 
47dd						DMARK "AC1" 
47dd f5				push af  
47de 3a f2 47			ld a, (.dmark)  
47e1 32 71 ee			ld (debug_mark),a  
47e4 3a f3 47			ld a, (.dmark+1)  
47e7 32 72 ee			ld (debug_mark+1),a  
47ea 3a f4 47			ld a, (.dmark+2)  
47ed 32 73 ee			ld (debug_mark+2),a  
47f0 18 03			jr .pastdmark  
47f2 ..			.dmark: db "AC1"  
47f5 f1			.pastdmark: pop af  
47f6			endm  
# End of macro DMARK
47f6						CALLMONITOR 
47f6 cd e8 15			call break_point_state  
47f9				endm  
# End of macro CALLMONITOR
47f9					endif 
47f9 cd cc 1c				call forth_push_str 
47fc					NEXTW 
47fc c3 0b 20			jp macro_next 
47ff				endm 
# End of macro NEXTW
47ff			 
47ff			.EDIT: 
47ff				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
47ff 40				db WORD_SYS_CORE+44             
4800 a1 48			dw .DEDIT            
4802 05				db 4 + 1 
4803 .. 00			db "EDIT",0              
4808				endm 
# End of macro CWHEAD
4808			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4808			 
4808					; TODO does not copy from stack 
4808					if DEBUG_FORTH_WORDS_KEY 
4808						DMARK "EDT" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 71 ee			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 72 ee			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 73 ee			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "EDT"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821						CALLMONITOR 
4821 cd e8 15			call break_point_state  
4824				endm  
# End of macro CALLMONITOR
4824					endif 
4824			 
4824					;FORTH_DSP 
4824					FORTH_DSP_VALUEHL 
4824 cd 55 1e			call macro_dsp_valuehl 
4827				endm 
# End of macro FORTH_DSP_VALUEHL
4827			;		inc hl    ; TODO do type check 
4827			 
4827			;		call get_word_hl 
4827 e5					push hl 
4828					if DEBUG_FORTH_WORDS 
4828						DMARK "EDp" 
4828 f5				push af  
4829 3a 3d 48			ld a, (.dmark)  
482c 32 71 ee			ld (debug_mark),a  
482f 3a 3e 48			ld a, (.dmark+1)  
4832 32 72 ee			ld (debug_mark+1),a  
4835 3a 3f 48			ld a, (.dmark+2)  
4838 32 73 ee			ld (debug_mark+2),a  
483b 18 03			jr .pastdmark  
483d ..			.dmark: db "EDp"  
4840 f1			.pastdmark: pop af  
4841			endm  
# End of macro DMARK
4841						CALLMONITOR 
4841 cd e8 15			call break_point_state  
4844				endm  
# End of macro CALLMONITOR
4844					endif 
4844				;	ld a, 0 
4844 cd 45 12				call strlenz 
4847 23					inc hl 
4848			 
4848 06 00				ld b, 0 
484a 4d					ld c, l 
484b			 
484b e1					pop hl 
484c 11 c5 e4				ld de, os_input 
484f					if DEBUG_FORTH_WORDS_KEY 
484f						DMARK "EDc" 
484f f5				push af  
4850 3a 64 48			ld a, (.dmark)  
4853 32 71 ee			ld (debug_mark),a  
4856 3a 65 48			ld a, (.dmark+1)  
4859 32 72 ee			ld (debug_mark+1),a  
485c 3a 66 48			ld a, (.dmark+2)  
485f 32 73 ee			ld (debug_mark+2),a  
4862 18 03			jr .pastdmark  
4864 ..			.dmark: db "EDc"  
4867 f1			.pastdmark: pop af  
4868			endm  
# End of macro DMARK
4868						CALLMONITOR 
4868 cd e8 15			call break_point_state  
486b				endm  
# End of macro CALLMONITOR
486b					endif 
486b ed b0				ldir 
486d			 
486d			 
486d 21 c5 e4				ld hl, os_input 
4870					;ld a, 0 
4870					;ld (hl),a 
4870 3a 64 ea				ld a,(f_cursor_ptr) 
4873 16 64				ld d, 100 
4875 0e 00				ld c, 0 
4877 1e 28				ld e, 40 
4879 cd 14 0e				call input_str 
487c					; TODO perhaps do a type check and wrap in quotes if not a number 
487c 21 c5 e4				ld hl, os_input 
487f					if DEBUG_FORTH_WORDS 
487f						DMARK "ED1" 
487f f5				push af  
4880 3a 94 48			ld a, (.dmark)  
4883 32 71 ee			ld (debug_mark),a  
4886 3a 95 48			ld a, (.dmark+1)  
4889 32 72 ee			ld (debug_mark+1),a  
488c 3a 96 48			ld a, (.dmark+2)  
488f 32 73 ee			ld (debug_mark+2),a  
4892 18 03			jr .pastdmark  
4894 ..			.dmark: db "ED1"  
4897 f1			.pastdmark: pop af  
4898			endm  
# End of macro DMARK
4898						CALLMONITOR 
4898 cd e8 15			call break_point_state  
489b				endm  
# End of macro CALLMONITOR
489b					endif 
489b cd cc 1c				call forth_push_str 
489e					NEXTW 
489e c3 0b 20			jp macro_next 
48a1				endm 
# End of macro NEXTW
48a1			 
48a1			.DEDIT: 
48a1				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48a1 40				db WORD_SYS_CORE+44             
48a2 03 49			dw .ENDKEY            
48a4 06				db 5 + 1 
48a5 .. 00			db "DEDIT",0              
48ab				endm 
# End of macro CWHEAD
48ab			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48ab			 
48ab					; TODO does not copy from stack 
48ab					if DEBUG_FORTH_WORDS_KEY 
48ab						DMARK "DED" 
48ab f5				push af  
48ac 3a c0 48			ld a, (.dmark)  
48af 32 71 ee			ld (debug_mark),a  
48b2 3a c1 48			ld a, (.dmark+1)  
48b5 32 72 ee			ld (debug_mark+1),a  
48b8 3a c2 48			ld a, (.dmark+2)  
48bb 32 73 ee			ld (debug_mark+2),a  
48be 18 03			jr .pastdmark  
48c0 ..			.dmark: db "DED"  
48c3 f1			.pastdmark: pop af  
48c4			endm  
# End of macro DMARK
48c4						CALLMONITOR 
48c4 cd e8 15			call break_point_state  
48c7				endm  
# End of macro CALLMONITOR
48c7					endif 
48c7			 
48c7					;FORTH_DSP 
48c7					FORTH_DSP_VALUEHL 
48c7 cd 55 1e			call macro_dsp_valuehl 
48ca				endm 
# End of macro FORTH_DSP_VALUEHL
48ca			;		inc hl    ; TODO do type check 
48ca			 
48ca			;		call get_word_hl 
48ca e5					push hl 
48cb e5					push hl 
48cc					FORTH_DSP_POP 
48cc cd 0d 1f			call macro_forth_dsp_pop 
48cf				endm 
# End of macro FORTH_DSP_POP
48cf e1					pop hl 
48d0					if DEBUG_FORTH_WORDS 
48d0						DMARK "EDp" 
48d0 f5				push af  
48d1 3a e5 48			ld a, (.dmark)  
48d4 32 71 ee			ld (debug_mark),a  
48d7 3a e6 48			ld a, (.dmark+1)  
48da 32 72 ee			ld (debug_mark+1),a  
48dd 3a e7 48			ld a, (.dmark+2)  
48e0 32 73 ee			ld (debug_mark+2),a  
48e3 18 03			jr .pastdmark  
48e5 ..			.dmark: db "EDp"  
48e8 f1			.pastdmark: pop af  
48e9			endm  
# End of macro DMARK
48e9						CALLMONITOR 
48e9 cd e8 15			call break_point_state  
48ec				endm  
# End of macro CALLMONITOR
48ec					endif 
48ec				;	ld a, 0 
48ec cd 45 12				call strlenz 
48ef 23					inc hl 
48f0			 
48f0 06 00				ld b, 0 
48f2 4d					ld c, l 
48f3			 
48f3 e1					pop hl 
48f4			 
48f4					;ld a, 0 
48f4					;ld (hl),a 
48f4 3a 64 ea				ld a,(f_cursor_ptr) 
48f7 16 64				ld d, 100 
48f9 0e 00				ld c, 0 
48fb 1e 28				ld e, 40 
48fd cd 14 0e				call input_str 
4900					; TODO perhaps do a type check and wrap in quotes if not a number 
4900					NEXTW 
4900 c3 0b 20			jp macro_next 
4903				endm 
# End of macro NEXTW
4903			 
4903			 
4903			.ENDKEY: 
4903			; eof 
4903			 
# End of file forth_words_key.asm
4903			include "forth_words_const.asm" 
4903			 
4903			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4903			 
4903			 
4903			.SPITIME: 
4903				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4903 77				db WORD_SYS_CORE+99             
4904 18 49			dw .VA            
4906 08				db 7 + 1 
4907 .. 00			db "SPITIME",0              
490f				endm 
# End of macro CWHEAD
490f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
490f			; 
490f			; | If using BANK devices then leave as is. 
490f			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
490f			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
490f			 
490f 21 6a ea				ld hl, spi_clktime  
4912 cd 5e 1c				call forth_push_numhl 
4915			 
4915					NEXTW 
4915 c3 0b 20			jp macro_next 
4918				endm 
# End of macro NEXTW
4918			 
4918			 
4918			.VA: 
4918				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4918 77				db WORD_SYS_CORE+99             
4919 28 49			dw .SYMBOL            
491b 03				db 2 + 1 
491c .. 00			db "VA",0              
491f				endm 
# End of macro CWHEAD
491f			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
491f 21 2e ea				ld hl, cli_var_array 
4922 cd 5e 1c				call forth_push_numhl 
4925			 
4925					NEXTW 
4925 c3 0b 20			jp macro_next 
4928				endm 
# End of macro NEXTW
4928			 
4928			.SYMBOL: 
4928				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4928 77				db WORD_SYS_CORE+99             
4929 60 4a			dw .ENDCONST            
492b 07				db 6 + 1 
492c .. 00			db "SYMBOL",0              
4933				endm 
# End of macro CWHEAD
4933			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4933			; | 
4933			; | The value is the number reference and the final address is pushed to stack 
4933			 
4933					if DEBUG_FORTH_WORDS_KEY 
4933						DMARK "SYM" 
4933 f5				push af  
4934 3a 48 49			ld a, (.dmark)  
4937 32 71 ee			ld (debug_mark),a  
493a 3a 49 49			ld a, (.dmark+1)  
493d 32 72 ee			ld (debug_mark+1),a  
4940 3a 4a 49			ld a, (.dmark+2)  
4943 32 73 ee			ld (debug_mark+2),a  
4946 18 03			jr .pastdmark  
4948 ..			.dmark: db "SYM"  
494b f1			.pastdmark: pop af  
494c			endm  
# End of macro DMARK
494c						CALLMONITOR 
494c cd e8 15			call break_point_state  
494f				endm  
# End of macro CALLMONITOR
494f					endif 
494f			 
494f					FORTH_DSP_VALUEHL 
494f cd 55 1e			call macro_dsp_valuehl 
4952				endm 
# End of macro FORTH_DSP_VALUEHL
4952			 
4952 7d					ld a, l     
4953			 
4953			 
4953					if DEBUG_FORTH_WORDS 
4953						DMARK "SY1" 
4953 f5				push af  
4954 3a 68 49			ld a, (.dmark)  
4957 32 71 ee			ld (debug_mark),a  
495a 3a 69 49			ld a, (.dmark+1)  
495d 32 72 ee			ld (debug_mark+1),a  
4960 3a 6a 49			ld a, (.dmark+2)  
4963 32 73 ee			ld (debug_mark+2),a  
4966 18 03			jr .pastdmark  
4968 ..			.dmark: db "SY1"  
496b f1			.pastdmark: pop af  
496c			endm  
# End of macro DMARK
496c						CALLMONITOR 
496c cd e8 15			call break_point_state  
496f				endm  
# End of macro CALLMONITOR
496f					endif 
496f					 
496f f5					push af	 
4970					FORTH_DSP_POP 
4970 cd 0d 1f			call macro_forth_dsp_pop 
4973				endm 
# End of macro FORTH_DSP_POP
4973 f1					pop af 
4974			 
4974 cb 27				sla a  
4976				 
4976					 
4976					if DEBUG_FORTH_WORDS 
4976						DMARK "SY" 
4976 f5				push af  
4977 3a 8b 49			ld a, (.dmark)  
497a 32 71 ee			ld (debug_mark),a  
497d 3a 8c 49			ld a, (.dmark+1)  
4980 32 72 ee			ld (debug_mark+1),a  
4983 3a 8d 49			ld a, (.dmark+2)  
4986 32 73 ee			ld (debug_mark+2),a  
4989 18 02			jr .pastdmark  
498b ..			.dmark: db "SY"  
498d f1			.pastdmark: pop af  
498e			endm  
# End of macro DMARK
498e						CALLMONITOR 
498e cd e8 15			call break_point_state  
4991				endm  
# End of macro CALLMONITOR
4991					endif 
4991			 
4991 21 a0 49				ld hl, sym_table 
4994 cd e7 0d				call addatohl 
4997 cd 8d 1f				call loadwordinhl 
499a cd 5e 1c				call forth_push_numhl 
499d			 
499d			 
499d				       NEXTW 
499d c3 0b 20			jp macro_next 
49a0				endm 
# End of macro NEXTW
49a0			 
49a0			sym_table: 
49a0			 
49a0			; 0 
49a0 42 ea		dw cli_autodisplay 
49a2 50 ea		dw cli_buffer 
49a4 f4 e9		dw cli_data_sp 
49a6 2e e8		dw cli_data_stack 
49a8 4a ea		dw cli_execword 
49aa f6 e9		dw cli_loop_sp 
49ac 30 e9		dw cli_loop_stack 
49ae 43 ea		dw cli_mvdot 
49b0 48 ea		dw cli_nextword 
49b2 44 ea		dw cli_origptr 
49b4 4e ea		dw cli_origtoken 
49b6			; 11 
49b6 46 ea		dw cli_ptr 
49b8 f8 e9		dw cli_ret_sp 
49ba b2 e9		dw cli_ret_stack 
49bc 4c ea		dw cli_token 
49be 2e ea		dw cli_var_array 
49c0 cb eb		dw cursor_col 
49c2 c9 eb		dw cursor_ptr 
49c4 ca eb		dw cursor_row 
49c6 c7 eb		dw cursor_shape 
49c8 71 ee		dw debug_mark 
49ca			; 21 
49ca b7 ed		dw display_fb0 
49cc 16 ed		dw display_fb1 
49ce d4 eb		dw display_fb2 
49d0 75 ec		dw display_fb3 
49d2 d2 eb		dw display_fb_active 
49d4 c6 e3		dw execscratch 
49d6 64 ea		dw f_cursor_ptr 
49d8 75 ee		dw hardware_word 
49da 68 ee		dw input_at_cursor 
49dc 6a ee		dw input_at_pos 
49de			; 31 
49de 66 ee		dw input_cur_flash 
49e0 65 ee		dw input_cur_onoff 
49e2 5b ee		dw input_cursor 
49e4 6b ee		dw input_display_size 
49e6 60 ee		dw input_len 
49e8 6f ee		dw input_ptr 
49ea 6c ee		dw input_size 
49ec 6d ee		dw input_start 
49ee 14 0e		dw input_str 
49f0 69 ee		dw input_under_cursor 
49f2			; 41 
49f2 5a ee		dw key_actual_pressed 
49f4 85 ee		dw key_fa 
49f6 81 ee		dw key_face_held 
49f8 84 ee		dw key_fb 
49fa 83 ee		dw key_fc 
49fc 82 ee		dw key_fd 
49fe 8b ee		dw key_held 
4a00 8a ee		dw key_held_prev 
4a02 96 64		dw key_init 
4a04 86 ee		dw key_repeat_ct 
4a06			; 51 
4a06 05 00		dw key_rows 
4a08 58 ee		dw key_shift 
4a0a 59 ee		dw key_symbol 
4a0c 8c ee		dw keyscan_scancol 
4a0e 96 ee		dw keyscan_table 
4a10 f5 ee		dw keyscan_table_row1 
4a12 ea ee		dw keyscan_table_row2 
4a14 df ee		dw keyscan_table_row3 
4a16 d4 ee		dw keyscan_table_row4 
4a18 c9 ee		dw keyscan_table_row5 
4a1a			; 61 
4a1a ee e5		dw os_cli_cmd 
4a1c ea e5		dw os_cur_ptr 
4a1e ec e5		dw os_current_i 
4a20 c5 e4		dw os_input 
4a22 ed e6		dw os_last_cmd 
4a24 c4 e5		dw os_last_new_uword 
4a26 b8 e2		dw os_view_disable 
4a28 b4 e2		dw os_view_hl 
4a2a cc e5		dw os_word_scratch 
4a2c c3 00		dw portbctl 
4a2e			; 71 
4a2e c1 00		dw portbdata 
4a30 69 ea		dw spi_cartdev 
4a32 68 ea		dw spi_cartdev2 
4a34 6a ea		dw spi_clktime 
4a36 66 ea		dw spi_device 
4a38 65 ea		dw spi_device_id 
4a3a 67 ea		dw spi_portbyte 
4a3c ad eb		dw stackstore 
4a3e			if STORAGE_SE 
4a3e			dw storage_actl 
4a3e			dw storage_adata 
4a3e			else 
4a3e 00 00		dw 0 
4a40 00 00		dw 0 
4a42			endif 
4a42			; 81 
4a42 69 09		dw storage_append 
4a44			if STORAGE_SE 
4a44			dw storage_bctl 
4a44			else 
4a44 00 00		dw 0 
4a46			endif 
4a46 99 eb		dw store_bank_active 
4a48 6d ea		dw store_filecache 
4a4a 7b ea		dw store_longread 
4a4c 71 ea		dw store_openaddr 
4a4e 70 ea		dw store_openext 
4a50 6f ea		dw store_openmaxext 
4a52 80 ea		dw store_page 
4a54 7c ea		dw store_readbuf 
4a56			; 91 
4a56 73 ea		dw store_readcont 
4a58 7e ea		dw store_readptr 
4a5a 73 ea		dw store_tmpext 
4a5c 74 ea		dw store_tmpid 
4a5e 6b ea		dw store_tmppageid 
4a60			 
4a60			 
4a60			.ENDCONST: 
4a60			 
4a60			; eof 
4a60			 
4a60			 
# End of file forth_words_const.asm
4a60			 
4a60			if STORAGE_SE 
4a60			   	include "forth_words_storage.asm" 
4a60			endif 
4a60				include "forth_words_device.asm" 
4a60			; Device related words 
4a60			 
4a60			; | ## Device Words 
4a60			 
4a60			;if SOUND_ENABLE 
4a60			;.NOTE: 
4a60			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a60			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a60			;		if DEBUG_FORTH_WORDS_KEY 
4a60			;			DMARK "NTE" 
4a60			;			CALLMONITOR 
4a60			;		endif 
4a60			; 
4a60			;	 
4a60			; 
4a60			;		NEXTW 
4a60			;.AFTERSOUND: 
4a60			;endif 
4a60			 
4a60			 
4a60			USE_GPIO: equ 0 
4a60			 
4a60			if USE_GPIO 
4a60			.GP1: 
4a60				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a60			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a60					NEXTW 
4a60			.GP2: 
4a60				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a60			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a60			 
4a60					NEXTW 
4a60			 
4a60			.GP3: 
4a60				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a60			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a60			 
4a60					NEXTW 
4a60			 
4a60			.GP4: 
4a60				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a60			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a60			 
4a60					NEXTW 
4a60			.SIN: 
4a60			 
4a60			 
4a60			endif 
4a60			 
4a60			 
4a60				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a60 33				db WORD_SYS_CORE+31             
4a61 95 4a			dw .SOUT            
4a63 03				db 2 + 1 
4a64 .. 00			db "IN",0              
4a67				endm 
# End of macro CWHEAD
4a67			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a67					if DEBUG_FORTH_WORDS_KEY 
4a67						DMARK "IN." 
4a67 f5				push af  
4a68 3a 7c 4a			ld a, (.dmark)  
4a6b 32 71 ee			ld (debug_mark),a  
4a6e 3a 7d 4a			ld a, (.dmark+1)  
4a71 32 72 ee			ld (debug_mark+1),a  
4a74 3a 7e 4a			ld a, (.dmark+2)  
4a77 32 73 ee			ld (debug_mark+2),a  
4a7a 18 03			jr .pastdmark  
4a7c ..			.dmark: db "IN."  
4a7f f1			.pastdmark: pop af  
4a80			endm  
# End of macro DMARK
4a80						CALLMONITOR 
4a80 cd e8 15			call break_point_state  
4a83				endm  
# End of macro CALLMONITOR
4a83					endif 
4a83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a83 cd 55 1e			call macro_dsp_valuehl 
4a86				endm 
# End of macro FORTH_DSP_VALUEHL
4a86			 
4a86 e5					push hl 
4a87			 
4a87					; destroy value TOS 
4a87			 
4a87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a87 cd 0d 1f			call macro_forth_dsp_pop 
4a8a				endm 
# End of macro FORTH_DSP_POP
4a8a			 
4a8a					; one value on hl get other one back 
4a8a			 
4a8a c1					pop bc 
4a8b			 
4a8b					; do the sub 
4a8b			;		ex de, hl 
4a8b			 
4a8b ed 68				in l,(c) 
4a8d			 
4a8d					; save it 
4a8d			 
4a8d 26 00				ld h,0 
4a8f			 
4a8f					; TODO push value back onto stack for another op etc 
4a8f			 
4a8f cd 5e 1c				call forth_push_numhl 
4a92					NEXTW 
4a92 c3 0b 20			jp macro_next 
4a95				endm 
# End of macro NEXTW
4a95			.SOUT: 
4a95				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a95 34				db WORD_SYS_CORE+32             
4a96 e8 4a			dw .SPIO            
4a98 04				db 3 + 1 
4a99 .. 00			db "OUT",0              
4a9d				endm 
# End of macro CWHEAD
4a9d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a9d					if DEBUG_FORTH_WORDS_KEY 
4a9d						DMARK "OUT" 
4a9d f5				push af  
4a9e 3a b2 4a			ld a, (.dmark)  
4aa1 32 71 ee			ld (debug_mark),a  
4aa4 3a b3 4a			ld a, (.dmark+1)  
4aa7 32 72 ee			ld (debug_mark+1),a  
4aaa 3a b4 4a			ld a, (.dmark+2)  
4aad 32 73 ee			ld (debug_mark+2),a  
4ab0 18 03			jr .pastdmark  
4ab2 ..			.dmark: db "OUT"  
4ab5 f1			.pastdmark: pop af  
4ab6			endm  
# End of macro DMARK
4ab6						CALLMONITOR 
4ab6 cd e8 15			call break_point_state  
4ab9				endm  
# End of macro CALLMONITOR
4ab9					endif 
4ab9			 
4ab9					; get port 
4ab9			 
4ab9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ab9 cd 55 1e			call macro_dsp_valuehl 
4abc				endm 
# End of macro FORTH_DSP_VALUEHL
4abc			 
4abc e5					push hl 
4abd			 
4abd					; destroy value TOS 
4abd			 
4abd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4abd cd 0d 1f			call macro_forth_dsp_pop 
4ac0				endm 
# End of macro FORTH_DSP_POP
4ac0			 
4ac0					; get byte to send 
4ac0			 
4ac0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ac0 cd 55 1e			call macro_dsp_valuehl 
4ac3				endm 
# End of macro FORTH_DSP_VALUEHL
4ac3			 
4ac3			;		push hl 
4ac3			 
4ac3					; destroy value TOS 
4ac3			 
4ac3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ac3 cd 0d 1f			call macro_forth_dsp_pop 
4ac6				endm 
# End of macro FORTH_DSP_POP
4ac6			 
4ac6					; one value on hl get other one back 
4ac6			 
4ac6			;		pop hl 
4ac6			 
4ac6 c1					pop bc 
4ac7			 
4ac7					if DEBUG_FORTH_WORDS 
4ac7						DMARK "OUT" 
4ac7 f5				push af  
4ac8 3a dc 4a			ld a, (.dmark)  
4acb 32 71 ee			ld (debug_mark),a  
4ace 3a dd 4a			ld a, (.dmark+1)  
4ad1 32 72 ee			ld (debug_mark+1),a  
4ad4 3a de 4a			ld a, (.dmark+2)  
4ad7 32 73 ee			ld (debug_mark+2),a  
4ada 18 03			jr .pastdmark  
4adc ..			.dmark: db "OUT"  
4adf f1			.pastdmark: pop af  
4ae0			endm  
# End of macro DMARK
4ae0						CALLMONITOR 
4ae0 cd e8 15			call break_point_state  
4ae3				endm  
# End of macro CALLMONITOR
4ae3					endif 
4ae3			 
4ae3 ed 69				out (c), l 
4ae5			 
4ae5					NEXTW 
4ae5 c3 0b 20			jp macro_next 
4ae8				endm 
# End of macro NEXTW
4ae8			 
4ae8			 
4ae8			.SPIO: 
4ae8			 
4ae8			if STORAGE_SE 
4ae8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4ae8			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ae8			 
4ae8					call spi_ce_low 
4ae8			    NEXTW 
4ae8			 
4ae8			.SPICEH: 
4ae8				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ae8			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ae8			 
4ae8					call spi_ce_high 
4ae8			    NEXTW 
4ae8			 
4ae8			 
4ae8			.SPIOb: 
4ae8			 
4ae8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ae8			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ae8			 
4ae8					if DEBUG_FORTH_WORDS_KEY 
4ae8						DMARK "SPo" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8					; get port 
4ae8			 
4ae8			 
4ae8					; get byte to send 
4ae8			 
4ae8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae8			 
4ae8			;		push hl    ; u1  
4ae8			 
4ae8					; destroy value TOS 
4ae8			 
4ae8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae8			 
4ae8					; one value on hl get other one back 
4ae8			 
4ae8			;		pop hl   ; u2 - addr 
4ae8			 
4ae8					; TODO Send SPI byte 
4ae8			 
4ae8			;		push hl 
4ae8			;		call spi_ce_low 
4ae8			;		pop hl 
4ae8					ld a, l 
4ae8					call spi_send_byte 
4ae8			;		call spi_ce_high 
4ae8			 
4ae8					NEXTW 
4ae8			 
4ae8			.SPII: 
4ae8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ae8			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ae8					if DEBUG_FORTH_WORDS_KEY 
4ae8						DMARK "SPi" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8			 
4ae8					; TODO Get SPI byte 
4ae8			 
4ae8					call spi_read_byte 
4ae8			 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "Si2" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8					ld h, 0 
4ae8					ld l, a 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "Si3" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8					call forth_push_numhl 
4ae8			 
4ae8					NEXTW 
4ae8			 
4ae8			 
4ae8			 
4ae8			.SESEL: 
4ae8				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ae8			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ae8					if DEBUG_FORTH_WORDS_KEY 
4ae8						DMARK "BNK" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8			 
4ae8					ld a, 255 
4ae8					ld (spi_cartdev), a 
4ae8			 
4ae8					; get bank 
4ae8			 
4ae8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae8			 
4ae8			;		push hl 
4ae8			 
4ae8					; destroy value TOS 
4ae8			 
4ae8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae8			 
4ae8					; one value on hl get other one back 
4ae8			 
4ae8			;		pop hl 
4ae8			 
4ae8			 
4ae8					ld c, SPI_CE_HIGH 
4ae8					ld b, '0'    ; human readable bank number 
4ae8			 
4ae8					ld a, l 
4ae8			 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "BNK" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8			 
4ae8					; active low 
4ae8			 
4ae8					cp 0 
4ae8					jr z, .bset 
4ae8					cp 1 
4ae8					jr nz, .b2 
4ae8					res 0, c 
4ae8					ld b, '1'    ; human readable bank number 
4ae8			.b2:		cp 2 
4ae8					jr nz, .b3 
4ae8					res 1, c 
4ae8					ld b, '2'    ; human readable bank number 
4ae8			.b3:		cp 3 
4ae8					jr nz, .b4 
4ae8					res 2, c 
4ae8					ld b, '3'    ; human readable bank number 
4ae8			.b4:		cp 4 
4ae8					jr nz, .b5 
4ae8					res 3, c 
4ae8					ld b, '4'    ; human readable bank number 
4ae8			.b5:		cp 5 
4ae8					jr nz, .bset 
4ae8					res 4, c 
4ae8					ld b, '5'    ; human readable bank number 
4ae8			 
4ae8			.bset: 
4ae8					ld a, c 
4ae8					ld (spi_device),a 
4ae8					ld a, b 
4ae8					ld (spi_device_id),a 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "BN2" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8			 
4ae8					; set default SPI clk pulse time as disabled for BANK use 
4ae8			 
4ae8					ld a, 0 
4ae8					ld (spi_clktime), a 
4ae8			 
4ae8					NEXTW 
4ae8			 
4ae8			.CARTDEV: 
4ae8				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4ae8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4ae8					if DEBUG_FORTH_WORDS_KEY 
4ae8						DMARK "CDV" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8			 
4ae8					; disable se storage bank selection 
4ae8			 
4ae8					ld a, SPI_CE_HIGH		; ce high 
4ae8					ld (spi_device), a 
4ae8			 
4ae8					; get bank 
4ae8			 
4ae8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae8			 
4ae8			;		push hl 
4ae8			 
4ae8					; destroy value TOS 
4ae8			 
4ae8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae8			 
4ae8					; one value on hl get other one back 
4ae8			 
4ae8			;		pop hl 
4ae8			 
4ae8					; active low 
4ae8			 
4ae8					ld c, 255 
4ae8			 
4ae8					ld a, l 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "CDV" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8					cp 0 
4ae8					jr z, .cset 
4ae8					cp 1 
4ae8					jr nz, .c2 
4ae8					res 0, c 
4ae8			.c2:		cp 2 
4ae8					jr nz, .c3 
4ae8					res 1, c 
4ae8			.c3:		cp 3 
4ae8					jr nz, .c4 
4ae8					res 2, c 
4ae8			.c4:		cp 4 
4ae8					jr nz, .c5 
4ae8					res 3, c 
4ae8			.c5:		cp 5 
4ae8					jr nz, .c6 
4ae8					res 4, c 
4ae8			.c6:		cp 6 
4ae8					jr nz, .c7 
4ae8					res 5, c 
4ae8			.c7:		cp 7 
4ae8					jr nz, .c8 
4ae8					res 6, c 
4ae8			.c8:		cp 8 
4ae8					jr nz, .cset 
4ae8					res 7, c 
4ae8			.cset:		ld a, c 
4ae8					ld (spi_cartdev),a 
4ae8			 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "CD2" 
4ae8						CALLMONITOR 
4ae8					endif 
4ae8			 
4ae8					; set default SPI clk pulse time as 10ms for CARTDEV use 
4ae8			 
4ae8					ld a, $0a 
4ae8					ld (spi_clktime), a 
4ae8					NEXTW 
4ae8			endif 
4ae8			 
4ae8			.ENDDEVICE: 
4ae8			; eof 
4ae8			 
# End of file forth_words_device.asm
4ae8			 
4ae8			; var handler 
4ae8			 
4ae8			 
4ae8			.VARS: 
4ae8				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4ae8 77				db WORD_SYS_CORE+99             
4ae9 99 4b			dw .V0            
4aeb 04				db 3 + 1 
4aec .. 00			db "VAR",0              
4af0				endm 
# End of macro CWHEAD
4af0			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4af0			;| 
4af0			;| The variable name should consist of a single letter. e.g. "a" 
4af0			;! If a full string is passed then only the first char is looked at 
4af0			;| Any other char could exceed bounds checks!  
4af0			 
4af0					if DEBUG_FORTH_WORDS_KEY 
4af0						DMARK "VAR" 
4af0 f5				push af  
4af1 3a 05 4b			ld a, (.dmark)  
4af4 32 71 ee			ld (debug_mark),a  
4af7 3a 06 4b			ld a, (.dmark+1)  
4afa 32 72 ee			ld (debug_mark+1),a  
4afd 3a 07 4b			ld a, (.dmark+2)  
4b00 32 73 ee			ld (debug_mark+2),a  
4b03 18 03			jr .pastdmark  
4b05 ..			.dmark: db "VAR"  
4b08 f1			.pastdmark: pop af  
4b09			endm  
# End of macro DMARK
4b09						CALLMONITOR 
4b09 cd e8 15			call break_point_state  
4b0c				endm  
# End of macro CALLMONITOR
4b0c					endif 
4b0c			 
4b0c					FORTH_DSP_VALUEHL 
4b0c cd 55 1e			call macro_dsp_valuehl 
4b0f				endm 
# End of macro FORTH_DSP_VALUEHL
4b0f			 
4b0f 7e					ld a, (hl)    ; get first char on of the string 
4b10			 
4b10			 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "VR1" 
4b10 f5				push af  
4b11 3a 25 4b			ld a, (.dmark)  
4b14 32 71 ee			ld (debug_mark),a  
4b17 3a 26 4b			ld a, (.dmark+1)  
4b1a 32 72 ee			ld (debug_mark+1),a  
4b1d 3a 27 4b			ld a, (.dmark+2)  
4b20 32 73 ee			ld (debug_mark+2),a  
4b23 18 03			jr .pastdmark  
4b25 ..			.dmark: db "VR1"  
4b28 f1			.pastdmark: pop af  
4b29			endm  
# End of macro DMARK
4b29						CALLMONITOR 
4b29 cd e8 15			call break_point_state  
4b2c				endm  
# End of macro CALLMONITOR
4b2c					endif 
4b2c					 
4b2c f5					push af	 
4b2d					FORTH_DSP_POP 
4b2d cd 0d 1f			call macro_forth_dsp_pop 
4b30				endm 
# End of macro FORTH_DSP_POP
4b30 f1					pop af 
4b31			 
4b31					; convert to upper 
4b31			 
4b31 cd 54 11				call to_upper 
4b34					if DEBUG_FORTH_WORDS 
4b34						DMARK "Vaa" 
4b34 f5				push af  
4b35 3a 49 4b			ld a, (.dmark)  
4b38 32 71 ee			ld (debug_mark),a  
4b3b 3a 4a 4b			ld a, (.dmark+1)  
4b3e 32 72 ee			ld (debug_mark+1),a  
4b41 3a 4b 4b			ld a, (.dmark+2)  
4b44 32 73 ee			ld (debug_mark+2),a  
4b47 18 03			jr .pastdmark  
4b49 ..			.dmark: db "Vaa"  
4b4c f1			.pastdmark: pop af  
4b4d			endm  
# End of macro DMARK
4b4d						CALLMONITOR 
4b4d cd e8 15			call break_point_state  
4b50				endm  
# End of macro CALLMONITOR
4b50					endif 
4b50 06 41				ld b, 'A' 
4b52 90					sub b			; set offset 
4b53					if DEBUG_FORTH_WORDS 
4b53						DMARK "Vbb" 
4b53 f5				push af  
4b54 3a 68 4b			ld a, (.dmark)  
4b57 32 71 ee			ld (debug_mark),a  
4b5a 3a 69 4b			ld a, (.dmark+1)  
4b5d 32 72 ee			ld (debug_mark+1),a  
4b60 3a 6a 4b			ld a, (.dmark+2)  
4b63 32 73 ee			ld (debug_mark+2),a  
4b66 18 03			jr .pastdmark  
4b68 ..			.dmark: db "Vbb"  
4b6b f1			.pastdmark: pop af  
4b6c			endm  
# End of macro DMARK
4b6c						CALLMONITOR 
4b6c cd e8 15			call break_point_state  
4b6f				endm  
# End of macro CALLMONITOR
4b6f					endif 
4b6f cb 27				sla a  
4b71				 
4b71					 
4b71					if DEBUG_FORTH_WORDS 
4b71						DMARK "VR2" 
4b71 f5				push af  
4b72 3a 86 4b			ld a, (.dmark)  
4b75 32 71 ee			ld (debug_mark),a  
4b78 3a 87 4b			ld a, (.dmark+1)  
4b7b 32 72 ee			ld (debug_mark+1),a  
4b7e 3a 88 4b			ld a, (.dmark+2)  
4b81 32 73 ee			ld (debug_mark+2),a  
4b84 18 03			jr .pastdmark  
4b86 ..			.dmark: db "VR2"  
4b89 f1			.pastdmark: pop af  
4b8a			endm  
# End of macro DMARK
4b8a						CALLMONITOR 
4b8a cd e8 15			call break_point_state  
4b8d				endm  
# End of macro CALLMONITOR
4b8d					endif 
4b8d			 
4b8d 21 fa e9				ld hl, cli_var_array2 
4b90 cd e7 0d				call addatohl 
4b93 cd 5e 1c				call forth_push_numhl 
4b96			 
4b96			 
4b96				       NEXTW 
4b96 c3 0b 20			jp macro_next 
4b99				endm 
# End of macro NEXTW
4b99			.V0: 
4b99				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b99 78				db WORD_SYS_CORE+100             
4b9a b1 4b			dw .V0Q            
4b9c 04				db 3 + 1 
4b9d .. 00			db "V0!",0              
4ba1				endm 
# End of macro CWHEAD
4ba1			;| V0! ( u1 -- )  Store value to v0  | DONE 
4ba1			 
4ba1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ba1 cd 55 1e			call macro_dsp_valuehl 
4ba4				endm 
# End of macro FORTH_DSP_VALUEHL
4ba4			 
4ba4 11 2e ea				ld de, cli_var_array 
4ba7			 
4ba7 eb					ex de, hl 
4ba8 73					ld (hl), e 
4ba9 23					inc hl 
4baa 72					ld (hl), d 
4bab			 
4bab					; destroy value TOS 
4bab			 
4bab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bab cd 0d 1f			call macro_forth_dsp_pop 
4bae				endm 
# End of macro FORTH_DSP_POP
4bae			 
4bae				       NEXTW 
4bae c3 0b 20			jp macro_next 
4bb1				endm 
# End of macro NEXTW
4bb1			.V0Q: 
4bb1				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bb1 79				db WORD_SYS_CORE+101             
4bb2 c2 4b			dw .V1S            
4bb4 04				db 3 + 1 
4bb5 .. 00			db "V0@",0              
4bb9				endm 
# End of macro CWHEAD
4bb9			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4bb9 2a 2e ea				ld hl, (cli_var_array) 
4bbc cd 5e 1c				call forth_push_numhl 
4bbf			 
4bbf				       NEXTW 
4bbf c3 0b 20			jp macro_next 
4bc2				endm 
# End of macro NEXTW
4bc2			.V1S: 
4bc2				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bc2 7a				db WORD_SYS_CORE+102             
4bc3 da 4b			dw .V1Q            
4bc5 04				db 3 + 1 
4bc6 .. 00			db "V1!",0              
4bca				endm 
# End of macro CWHEAD
4bca			;| V1! ( u1 -- )  Store value to v1 | DONE 
4bca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bca cd 55 1e			call macro_dsp_valuehl 
4bcd				endm 
# End of macro FORTH_DSP_VALUEHL
4bcd			 
4bcd 11 30 ea				ld de, cli_var_array+2 
4bd0				 
4bd0 eb					ex de, hl 
4bd1 73					ld (hl), e 
4bd2 23					inc hl 
4bd3 72					ld (hl), d 
4bd4			 
4bd4					; destroy value TOS 
4bd4			 
4bd4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd4 cd 0d 1f			call macro_forth_dsp_pop 
4bd7				endm 
# End of macro FORTH_DSP_POP
4bd7				       NEXTW 
4bd7 c3 0b 20			jp macro_next 
4bda				endm 
# End of macro NEXTW
4bda			.V1Q: 
4bda				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bda 7b				db WORD_SYS_CORE+103             
4bdb eb 4b			dw .V2S            
4bdd 04				db 3 + 1 
4bde .. 00			db "V1@",0              
4be2				endm 
# End of macro CWHEAD
4be2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4be2 2a 30 ea				ld hl, (cli_var_array+2) 
4be5 cd 5e 1c				call forth_push_numhl 
4be8				       NEXTW 
4be8 c3 0b 20			jp macro_next 
4beb				endm 
# End of macro NEXTW
4beb			.V2S: 
4beb				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4beb 7c				db WORD_SYS_CORE+104             
4bec 03 4c			dw .V2Q            
4bee 04				db 3 + 1 
4bef .. 00			db "V2!",0              
4bf3				endm 
# End of macro CWHEAD
4bf3			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf3 cd 55 1e			call macro_dsp_valuehl 
4bf6				endm 
# End of macro FORTH_DSP_VALUEHL
4bf6			 
4bf6 11 32 ea				ld de, cli_var_array+4 
4bf9				 
4bf9 eb					ex de, hl 
4bfa 73					ld (hl), e 
4bfb 23					inc hl 
4bfc 72					ld (hl), d 
4bfd			 
4bfd					; destroy value TOS 
4bfd			 
4bfd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bfd cd 0d 1f			call macro_forth_dsp_pop 
4c00				endm 
# End of macro FORTH_DSP_POP
4c00				       NEXTW 
4c00 c3 0b 20			jp macro_next 
4c03				endm 
# End of macro NEXTW
4c03			.V2Q: 
4c03				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c03 7d				db WORD_SYS_CORE+105             
4c04 14 4c			dw .V3S            
4c06 04				db 3 + 1 
4c07 .. 00			db "V2@",0              
4c0b				endm 
# End of macro CWHEAD
4c0b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c0b 2a 32 ea				ld hl, (cli_var_array+4) 
4c0e cd 5e 1c				call forth_push_numhl 
4c11				       NEXTW 
4c11 c3 0b 20			jp macro_next 
4c14				endm 
# End of macro NEXTW
4c14			.V3S: 
4c14				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c14 7c				db WORD_SYS_CORE+104             
4c15 2c 4c			dw .V3Q            
4c17 04				db 3 + 1 
4c18 .. 00			db "V3!",0              
4c1c				endm 
# End of macro CWHEAD
4c1c			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c1c cd 55 1e			call macro_dsp_valuehl 
4c1f				endm 
# End of macro FORTH_DSP_VALUEHL
4c1f			 
4c1f 11 34 ea				ld de, cli_var_array+6 
4c22				 
4c22 eb					ex de, hl 
4c23 73					ld (hl), e 
4c24 23					inc hl 
4c25 72					ld (hl), d 
4c26			 
4c26					; destroy value TOS 
4c26			 
4c26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c26 cd 0d 1f			call macro_forth_dsp_pop 
4c29				endm 
# End of macro FORTH_DSP_POP
4c29				       NEXTW 
4c29 c3 0b 20			jp macro_next 
4c2c				endm 
# End of macro NEXTW
4c2c			.V3Q: 
4c2c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c2c 7d				db WORD_SYS_CORE+105             
4c2d 3d 4c			dw .END            
4c2f 04				db 3 + 1 
4c30 .. 00			db "V3@",0              
4c34				endm 
# End of macro CWHEAD
4c34			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c34 2a 34 ea				ld hl, (cli_var_array+6) 
4c37 cd 5e 1c				call forth_push_numhl 
4c3a				       NEXTW 
4c3a c3 0b 20			jp macro_next 
4c3d				endm 
# End of macro NEXTW
4c3d			 
4c3d			 
4c3d			 
4c3d			 
4c3d			 
4c3d			; end of dict marker 
4c3d			 
4c3d 00			.END:    db WORD_SYS_END 
4c3e 00 00			dw 0 
4c40 00				db 0 
4c41			 
4c41			; use to jp here for user dict words to save on macro expansion  
4c41			 
4c41			user_dict_next: 
4c41				NEXTW 
4c41 c3 0b 20			jp macro_next 
4c44				endm 
# End of macro NEXTW
4c44			 
4c44			 
4c44			user_exec: 
4c44				;    ld hl, <word code> 
4c44				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c44				;    call forthexec 
4c44				;    jp user_dict_next   (NEXT) 
4c44			        ;    <word code bytes> 
4c44 eb				ex de, hl 
4c45 2a c8 e5			ld hl,(os_tok_ptr) 
4c48				 
4c48				FORTH_RSP_NEXT 
4c48 cd 05 1c			call macro_forth_rsp_next 
4c4b				endm 
# End of macro FORTH_RSP_NEXT
4c4b			 
4c4b			if DEBUG_FORTH_UWORD 
4c4b						DMARK "UEX" 
4c4b f5				push af  
4c4c 3a 60 4c			ld a, (.dmark)  
4c4f 32 71 ee			ld (debug_mark),a  
4c52 3a 61 4c			ld a, (.dmark+1)  
4c55 32 72 ee			ld (debug_mark+1),a  
4c58 3a 62 4c			ld a, (.dmark+2)  
4c5b 32 73 ee			ld (debug_mark+2),a  
4c5e 18 03			jr .pastdmark  
4c60 ..			.dmark: db "UEX"  
4c63 f1			.pastdmark: pop af  
4c64			endm  
# End of macro DMARK
4c64				CALLMONITOR 
4c64 cd e8 15			call break_point_state  
4c67				endm  
# End of macro CALLMONITOR
4c67			endif 
4c67			 
4c67			 
4c67			 
4c67 eb				ex de, hl 
4c68 22 c8 e5			ld (os_tok_ptr), hl 
4c6b				 
4c6b				; Don't use next - Skips the first word in uword. 
4c6b			 
4c6b c3 9c 20			jp exec1 
4c6e			;	NEXT 
4c6e			 
4c6e			 
4c6e			; eof 
# End of file forth_wordsv4.asm
4c6e			endif 
4c6e			;;;;;;;;;;;;;; Debug code 
4c6e			 
4c6e			 
4c6e			;if DEBUG_FORTH_PARSE 
4c6e .. 00		.nowordfound: db "No match",0 
4c77 .. 00		.compword:	db "Comparing word ",0 
4c87 .. 00		.nextwordat:	db "Next word at",0 
4c94 .. 00		.charmatch:	db "Char match",0 
4c9f			;endif 
4c9f			if DEBUG_FORTH_JP 
4c9f			.foundword:	db "Word match. Exec..",0 
4c9f			endif 
4c9f			;if DEBUG_FORTH_PUSH 
4c9f .. 00		.enddict:	db "Dict end. Push.",0 
4caf .. 00		.push_str:	db "Pushing string",0 
4cbe .. 00		.push_num:	db "Pushing number",0 
4ccd .. 00		.data_sp:	db "SP:",0 
4cd1 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ce3 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cf5 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d07			;endif 
4d07			;if DEBUG_FORTH_MALLOC 
4d07 .. 00		.push_malloc:	db "Malloc address",0 
4d16			;endif 
4d16			 
4d16			 
4d16			 
4d16			; display malloc address and current data stack pointer  
4d16			 
4d16			malloc_error: 
4d16 d5				push de 
4d17 f5				push af 
4d18 e5				push hl 
4d19 cd ba 0b			call clear_display 
4d1c 11 3e 4d			ld de, .mallocerr 
4d1f 3e 00			ld a,0 
4d21			;	ld de,os_word_scratch 
4d21 cd cd 0b			call str_at_display 
4d24 3e 11			ld a, display_row_1+17 
4d26 11 71 ee			ld de, debug_mark 
4d29 cd cd 0b			call str_at_display 
4d2c cd dd 0b			call update_display 
4d2f				;call break_point_state 
4d2f cd 97 64			call cin_wait 
4d32			 
4d32 3e 20			ld a, ' ' 
4d34 32 b8 e2			ld (os_view_disable), a 
4d37 e1				pop hl 
4d38 f1				pop af 
4d39 d1				pop de	 
4d3a				CALLMONITOR 
4d3a cd e8 15			call break_point_state  
4d3d				endm  
# End of macro CALLMONITOR
4d3d c9				ret 
4d3e			 
4d3e .. 00		.mallocerr: 	db "Malloc Error",0 
4d4b			;if DEBUG_FORTH_PUSH 
4d4b			display_data_sp: 
4d4b f5				push af 
4d4c			 
4d4c				; see if disabled 
4d4c			 
4d4c 3a b8 e2			ld a, (os_view_disable) 
4d4f fe 2a			cp '*' 
4d51 28 67			jr z, .skipdsp 
4d53			 
4d53 e5				push hl 
4d54 e5				push hl 
4d55 e5			push hl 
4d56 cd ba 0b			call clear_display 
4d59 e1			pop hl 
4d5a 7c				ld a,h 
4d5b 21 cc e5			ld hl, os_word_scratch 
4d5e cd e8 10			call hexout 
4d61 e1				pop hl 
4d62 7d				ld a,l 
4d63 21 ce e5			ld hl, os_word_scratch+2 
4d66 cd e8 10			call hexout 
4d69 21 d0 e5			ld hl, os_word_scratch+4 
4d6c 3e 00			ld a,0 
4d6e 77				ld (hl),a 
4d6f 11 cc e5			ld de,os_word_scratch 
4d72 3e 28				ld a, display_row_2 
4d74 cd cd 0b				call str_at_display 
4d77 11 d1 4c			ld de, .wordinhl 
4d7a 3e 00			ld a, display_row_1 
4d7c			 
4d7c cd cd 0b				call str_at_display 
4d7f 11 71 ee			ld de, debug_mark 
4d82 3e 11			ld a, display_row_1+17 
4d84			 
4d84 cd cd 0b				call str_at_display 
4d87			 
4d87				; display current data stack pointer 
4d87 11 cd 4c			ld de,.data_sp 
4d8a 3e 30				ld a, display_row_2 + 8 
4d8c cd cd 0b				call str_at_display 
4d8f			 
4d8f 2a f4 e9			ld hl,(cli_data_sp) 
4d92 e5				push hl 
4d93 7c				ld a,h 
4d94 21 cc e5			ld hl, os_word_scratch 
4d97 cd e8 10			call hexout 
4d9a e1				pop hl 
4d9b 7d				ld a,l 
4d9c 21 ce e5			ld hl, os_word_scratch+2 
4d9f cd e8 10			call hexout 
4da2 21 d0 e5			ld hl, os_word_scratch+4 
4da5 3e 00			ld a,0 
4da7 77				ld (hl),a 
4da8 11 cc e5			ld de,os_word_scratch 
4dab 3e 33				ld a, display_row_2 + 11 
4dad cd cd 0b				call str_at_display 
4db0			 
4db0			 
4db0 cd dd 0b			call update_display 
4db3 cd f2 0a			call delay1s 
4db6 cd f2 0a			call delay1s 
4db9 e1				pop hl 
4dba			.skipdsp: 
4dba f1				pop af 
4dbb c9				ret 
4dbc			 
4dbc			display_data_malloc: 
4dbc			 
4dbc f5				push af 
4dbd e5				push hl 
4dbe e5				push hl 
4dbf e5			push hl 
4dc0 cd ba 0b			call clear_display 
4dc3 e1			pop hl 
4dc4 7c				ld a,h 
4dc5 21 cc e5			ld hl, os_word_scratch 
4dc8 cd e8 10			call hexout 
4dcb e1				pop hl 
4dcc 7d				ld a,l 
4dcd 21 ce e5			ld hl, os_word_scratch+2 
4dd0 cd e8 10			call hexout 
4dd3 21 d0 e5			ld hl, os_word_scratch+4 
4dd6 3e 00			ld a,0 
4dd8 77				ld (hl),a 
4dd9 11 cc e5			ld de,os_word_scratch 
4ddc 3e 28				ld a, display_row_2 
4dde cd cd 0b				call str_at_display 
4de1 11 07 4d			ld de, .push_malloc 
4de4 3e 00			ld a, display_row_1 
4de6			 
4de6 cd cd 0b				call str_at_display 
4de9			 
4de9				; display current data stack pointer 
4de9 11 cd 4c			ld de,.data_sp 
4dec 3e 30				ld a, display_row_2 + 8 
4dee cd cd 0b				call str_at_display 
4df1			 
4df1 2a f4 e9			ld hl,(cli_data_sp) 
4df4 e5				push hl 
4df5 7c				ld a,h 
4df6 21 cc e5			ld hl, os_word_scratch 
4df9 cd e8 10			call hexout 
4dfc e1				pop hl 
4dfd 7d				ld a,l 
4dfe 21 ce e5			ld hl, os_word_scratch+2 
4e01 cd e8 10			call hexout 
4e04 21 d0 e5			ld hl, os_word_scratch+4 
4e07 3e 00			ld a,0 
4e09 77				ld (hl),a 
4e0a 11 cc e5			ld de,os_word_scratch 
4e0d 3e 33				ld a, display_row_2 + 11 
4e0f cd cd 0b				call str_at_display 
4e12			 
4e12 cd dd 0b			call update_display 
4e15 cd f2 0a			call delay1s 
4e18 cd f2 0a			call delay1s 
4e1b e1				pop hl 
4e1c f1				pop af 
4e1d c9				ret 
4e1e			;endif 
4e1e			 
4e1e			include "forth_autostart.asm" 
4e1e			; list of commands to perform at system start up 
4e1e			 
4e1e			startcmds: 
4e1e			;	dw test11 
4e1e			;	dw test12 
4e1e			;	dw test13 
4e1e			;	dw test14 
4e1e			;	dw test15 
4e1e			;	dw test16 
4e1e			;	dw test17 
4e1e			;	dw ifthtest1 
4e1e			;	dw ifthtest2 
4e1e			;	dw ifthtest3 
4e1e			;	dw mmtest1 
4e1e			;	dw mmtest2 
4e1e			;	dw mmtest3 
4e1e			;	dw mmtest4 
4e1e			;	dw mmtest5 
4e1e			;	dw mmtest6 
4e1e			;	dw iftest1 
4e1e			;	dw iftest2 
4e1e			;	dw iftest3 
4e1e			;	dw looptest1 
4e1e			;	dw looptest2 
4e1e			;	dw test1 
4e1e			;	dw test2 
4e1e			;	dw test3 
4e1e			;	dw test4 
4e1e			;	dw game2r 
4e1e			;	dw game2b1 
4e1e			;	dw game2b2 
4e1e			 
4e1e				; start up words that are actually useful 
4e1e			 
4e1e 26 4f		    dw spi1 
4e20 7f 4f		    dw spi2 
4e22 0d 50		    dw spi3 
4e24 b5 4f		    dw spi4 
4e26 e0 4f		    dw spi5 
4e28 73 50		    dw spi6 
4e2a c8 50		    dw spi7 
4e2c			 
4e2c 20 51		    dw spi8 
4e2e 3f 51		    dw spi9 
4e30 97 51		    dw spi10 
4e32			 
4e32			; file editor 
4e32 98 4e			dw edit1 
4e34 b9 4e			dw edit2 
4e36 ee 4e			dw edit3 
4e38			 
4e38 0a 52			dw longread 
4e3a 51 52			dw clrstack 
4e3c 84 52			dw type 
4e3e 6f 54			dw stest 
4e40 a8 52			dw strncpy 
4e42 05 54			dw list 
4e44 09 53			dw start1 
4e46 19 53			dw start2 
4e48			;	dw start3 
4e48 2a 53			dw start3b 
4e4a a5 53			dw start3c 
4e4c			 
4e4c				; (unit) testing words 
4e4c			 
4e4c e6 54			dw mtesta 
4e4e 9b 55			dw mtestb 
4e50 3e 56			dw mtestc 
4e52 f3 56			dw mtestd 
4e54 97 57			dw mteste 
4e56			 
4e56				; demo/game words 
4e56			 
4e56 a3 5e		        dw game3w 
4e58 d1 5e		        dw game3p 
4e5a ef 5e		        dw game3sc 
4e5c 20 5f		        dw game3vsi 
4e5e 4c 5f		        dw game3vs 
4e60				 
4e60 96 5c			dw game2b 
4e62 04 5d			dw game2bf 
4e64 4e 5d			dw game2mba 
4e66 e4 5d			dw game2mbas 
4e68 26 5e			dw game2mb 
4e6a			 
4e6a 57 59			dw game1 
4e6c 68 59			dw game1a 
4e6e ca 59			dw game1b 
4e70 ff 59			dw game1c 
4e72 35 5a			dw game1d 
4e74 66 5a			dw game1s 
4e76 7a 5a			dw game1t 
4e78 8f 5a			dw game1f 
4e7a c3 5a			dw game1z 
4e7c 07 5b			dw game1zz 
4e7e			 
4e7e 4d 58			dw test5 
4e80 85 58			dw test6 
4e82 bd 58			dw test7 
4e84 d1 58			dw test8 
4e86 fd 58			dw test9 
4e88 13 59			dw test10 
4e8a				 
4e8a de 5b		        dw ssv5 
4e8c c2 5b		        dw ssv4 
4e8e a6 5b		        dw ssv3 
4e90 70 5b		        dw ssv2 
4e92 f7 5b		        dw ssv1 
4e94 3f 5c		        dw ssv1cpm 
4e96			;	dw keyup 
4e96			;	dw keydown 
4e96			;	dw keyleft 
4e96			;	dw keyright 
4e96			;	dw 	keyf1 
4e96			;	dw keyf2 
4e96			;	dw keyf3 
4e96			;	dw keyf4 
4e96			;	dw keyf5 
4e96			;	dw keyf6 
4e96			;	dw keyf7 
4e96			;	dw keyf8 
4e96			;	dw keyf9 
4e96			;	dw keyf10 
4e96			;	dw keyf11 
4e96			;	dw keyf12 
4e96			;	dw keytab 
4e96			;	dw keycr 
4e96			;	dw keyhome 
4e96			;	dw keyend 
4e96			;	dw keybs 
4e96 00 00			db 0, 0	 
4e98			 
4e98			 
4e98			; File Editor 
4e98			 
4e98			; ( id - ) use 'e' to edit the displayed line 
4e98 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4eb9 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4eee			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4eee .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f26			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f26			 
4f26			; SPI Net support words 
4f26			 
4f26			; v0! = node to send to 
4f26			; ( str count - ) 
4f26 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f7f			 
4f7f			; spiputchr ( char node - ) 
4f7f .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4fb5			 
4fb5			; spigetchr ( - n ) 
4fb5 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4fe0			 
4fe0			; getnode ( - n ) 
4fe0 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
500d			 
500d			; ( str node - )  
500d .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5073			; store string ( str i - ) 
5073			 
5073			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5073 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50c8			 
50c8			; get string ( addr i -  )    TO FIX 
50c8			 
50c8 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5120			 
5120			 
5120			; NETCHAT (TODO) 
5120			; Program to allow two nodes to chat with eachother 
5120			; 
5120			; v0 - target node 
5120			;  
5120			; accept input at 0,0 
5120			; if input is string send spitype to target node 
5120			; starting at row 2,0 , while spigetchr is not zero ->  
5120			; 
5120			; 
5120			; TODO add paging of get request 
5120			 
5120			; ( node - ) 
5120 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
513f .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5197 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
520a			 
520a			 
520a			; Long read of currently open file 
520a .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5251			 
5251			; clear stack  
5251			 
5251 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5284			 
5284			; type ( addr count - ) 
5284 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
52a8			 
52a8			; some direct memory words 
52a8			; strncpy ( len t f -- t ) 
52a8			 
52a8 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5309			 
5309 .. 00		start1:     	db ": bpon $00 bp ;",0 
5319 .. 00		start2:     	db ": bpoff $01 bp ;",0 
532a .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
53a5 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5405			 
5405			 
5405			; a handy word to list items on the stack 
5405			 
5405 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
546f			 
546f			 
546f			; test stack  
546f			; rnd8 stest 
546f			 
546f .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54e6			 
54e6			; random malloc and free cycles 
54e6			 
54e6 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
559b			 
559b			; fixed malloc and free cycles 
559b			 
559b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
563e			 
563e			; fixed double string push and drop cycle  
563e			 
563e .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56f3			 
56f3			; consistent fixed string push and drop cycle  
56f3			 
56f3 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5797			 
5797 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
584d			 
584d			;test1:		db ": aa 1 2 3 ;", 0 
584d			;test2:     	db "111 aa 888 999",0 
584d			;test3:     	db ": bb 77 ;",0 
584d			;test4:     	db "$02 $01 do i . loop bb",0 
584d			 
584d .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5885 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58bd .. 00		test7:     	db ": box hline vline ;",0 
58d1 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58fd .. 00		test9:     	db ": sw $01 adsp world ;",0 
5913 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5938 .. 00		test11:     	db "hello create .",0 
5947 .. 00		test12:     	db "hello2 create .",0 
5957			 
5957			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5957			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5957			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5957			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5957			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5957			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5957			 
5957			;iftest1:     	db "$0001 IF cls .",0 
5957			;iftest2:     	db "$0000 IF cls .",0 
5957			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5957			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5957			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5957			 
5957			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5957			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5957			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5957			 
5957			 
5957			 
5957			; a small guess the number game 
5957			 
5957 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5968 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
59ca			 
59ca .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
59ff .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5a35 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5a66 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5a7a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5a8f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ac3 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b07			 
5b07			; Using 'ga' save a high score across multiple runs using external storage 
5b07			 
5b07 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5b70			 
5b70			 
5b70			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5b70			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b70			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b70			 
5b70			; simple screen saver to test code memory reuse to destruction 
5b70			 
5b70 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5ba6 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5bc2 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5bde .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5bf7 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c3f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5c96			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c96			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5c96			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5c96			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5c96			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5c96			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5c96			 
5c96			 
5c96			 
5c96			; minesweeper/battleship finding game 
5c96			; draws a game board of random ship/mine positions 
5c96			; user enters coords to see if it hits on 
5c96			; game ends when all are hit 
5c96			; when hit or miss says how many may be in the area 
5c96			 
5c96			; setup the game board and then hide it 
5c96 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d04 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5d4e			; prompt for where to target 
5d4e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5de4 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e09			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e09 .. 00		game2mbht:      db ": mbckht nop ;",0 
5e18 .. 00		game2mbms:      db ": mbcms nop ;",0 
5e26			; TODO how many might be near by 
5e26 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ea3			 
5ea3			; Game 3 
5ea3			 
5ea3			; Vert scroller ski game - avoid the trees! 
5ea3			 
5ea3			; v0 score (ie turns) 
5ea3			; v1 player pos 
5ea3			; v2 left wall 
5ea3			; v3 right wall 
5ea3			 
5ea3			; Draw side walls randomly 
5ea3			 
5ea3 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5ed1			 
5ed1			; Draw player 
5ed1 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5eef			 
5eef			; TODO Get Key 
5eef			 
5eef			; TODO Move left right 
5eef			 
5eef			; scroll and move walls a bit 
5eef			 
5eef .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f20			 
5f20			; main game loop 
5f20			 
5f20 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5f4c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5f8b			 
5f8b			; key board defs 
5f8b			 
5f8b .. 00		keyup:       db ": keyup $05 ;",0 
5f99 .. 00		keydown:       db ": keydown $0a ;",0 
5fa9 .. 00		keyleft:       db ": keyleft $0b ;",0 
5fb9 .. 00		keyright:       db ": keyright $0c ;",0 
5fca .. 00		keyf1:       db ": keyf1 $10 ;",0 
5fd8 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5fe6 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5ff4 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6002 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6010 .. 00		keyf6:       db ": keyf6 $15 ;",0 
601e .. 00		keyf7:       db ": keyf7 $16 ;",0 
602c .. 00		keyf8:       db ": keyf8 $17 ;",0 
603a .. 00		keyf9:       db ": keyf9 $18 ;",0 
6048 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6057 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6066 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6075			 
6075 .. 00		keytab:       db ": keytab $09 ;",0 
6084 .. 00		keycr:       db ": keycr $0d ;",0 
6092 .. 00		keyhome:       db ": keyhome $0e ;",0 
60a2 .. 00		keyend:       db ": keyend $0f ;",0 
60b1 .. 00		keybs:       db ": keybs $08 ;",0 
60bf			 
60bf			   
60bf			 
60bf			 
60bf			 
60bf			; eof 
# End of file forth_autostart.asm
60bf			 
60bf			 
60bf			 
60bf			; stack over and underflow checks 
60bf			 
60bf			; init the words to detect the under/overflow 
60bf			 
60bf			chk_stk_init: 
60bf				; a vague random number to check so we dont get any "lucky" hits 
60bf 3e 2d			ld a, 45 
60c1 6f				ld l, a 
60c2 00				nop 
60c3 3e 17			ld a, 23 
60c5 67				ld h, a 
60c6			 
60c6 22 ae e2			ld (chk_word), hl     ; the word we need to check against 
60c9			 
60c9			;	ld (chk_stund), hl	; stack points.... 
60c9 22 00 ef			ld (chk_stovr), hl 
60cc 22 f2 e9			ld (chk_ret_und), hl 
60cf 22 b0 e9			ld (chk_ret_ovr), hl 
60d2 22 2e e9			ld (chk_loop_ovr), hl 
60d5 22 2c e8			ld (chk_data_ovr), hl 
60d8 c9				ret 
60d9				 
60d9			check_stacks: 
60d9				; check all stack words 
60d9			 
60d9 e5				push hl 
60da d5				push de 
60db			 
60db			;	ld de,(chk_word) 
60db			;	ld hl, (chk_stund)	; stack points.... 
60db			;	if DEBUG_STK_FAULT 
60db			;		DMARK "FAa" 
60db			;		CALLMONITOR 
60db			;	endif 
60db			;	call cmp16 
60db			;	jp z, .chk_faulta 
60db			; 
60db			;	ld de, sfaultsu 
60db			;	jp .chk_fault 
60db			 
60db 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
60de ed 5b ae e2		ld de,(chk_word) 
60e2				if DEBUG_STK_FAULT 
60e2					DMARK "FAb" 
60e2					CALLMONITOR 
60e2				endif 
60e2 cd 05 0e			call cmp16 
60e5 28 06			jr z, .chk_fault1 
60e7 11 88 61			ld de, sfaultso 
60ea c3 3c 61			jp .chk_fault 
60ed			.chk_fault1:  
60ed 2a f2 e9			ld hl, (chk_ret_und) 
60f0 ed 5b ae e2		ld de,(chk_word) 
60f4				if DEBUG_STK_FAULT 
60f4					DMARK "FAU" 
60f4					CALLMONITOR 
60f4				endif 
60f4 cd 05 0e			call cmp16 
60f7 ca 00 61			jp z, .chk_fault2 
60fa 11 98 61			ld de, sfaultru 
60fd c3 3c 61			jp .chk_fault 
6100			.chk_fault2:  
6100 2a b0 e9			ld hl, (chk_ret_ovr) 
6103 ed 5b ae e2		ld de,(chk_word) 
6107				if DEBUG_STK_FAULT 
6107					DMARK "FA1" 
6107					CALLMONITOR 
6107				endif 
6107 cd 05 0e			call cmp16 
610a ca 13 61			jp z, .chk_fault3 
610d 11 a6 61			ld de, sfaultro 
6110 c3 3c 61			jp .chk_fault 
6113			.chk_fault3:  
6113 2a 2e e9			ld hl, (chk_loop_ovr) 
6116 ed 5b ae e2		ld de,(chk_word) 
611a				if DEBUG_STK_FAULT 
611a					DMARK "FA2" 
611a					CALLMONITOR 
611a				endif 
611a cd 05 0e			call cmp16 
611d ca 26 61			jp z, .chk_fault4 
6120 11 c0 61			ld de, sfaultlo 
6123 c3 3c 61			jp .chk_fault 
6126			.chk_fault4:  
6126 2a 2c e8			ld hl, (chk_data_ovr) 
6129 ed 5b ae e2		ld de,(chk_word) 
612d				if DEBUG_STK_FAULT 
612d					DMARK "FA3" 
612d					CALLMONITOR 
612d				endif 
612d cd 05 0e			call cmp16 
6130 ca 39 61			jp z, .chk_fault5 
6133 11 da 61			ld de, sfaultdo 
6136 c3 3c 61			jp .chk_fault 
6139			 
6139			 
6139			.chk_fault5:  
6139 d1				pop de 
613a e1				pop hl 
613b			 
613b c9				ret 
613c			 
613c cd ba 0b		.chk_fault: 	call clear_display 
613f 3e 28				ld a, display_row_2 
6141 cd cd 0b				call str_at_display 
6144 11 6a 61				   ld de, .stackfault 
6147 3e 00				ld a, display_row_1 
6149 cd cd 0b				call str_at_display 
614c 11 71 ee				    ld de, debug_mark 
614f 3e 11				ld a, display_row_1+17 
6151 cd cd 0b				call str_at_display 
6154 cd dd 0b				call update_display 
6157			 
6157				; prompt before entering montior for investigating issue 
6157			 
6157 3e 78			ld a, display_row_4 
6159 11 78 19			ld de, endprog 
615c			 
615c cd dd 0b			call update_display		 
615f			 
615f cd d6 1b			call next_page_prompt 
6162			 
6162 d1				pop de 
6163 e1				pop hl 
6164 cd cc 19				call monitor 
6167 c3 c6 18				jp warmstart 
616a					;jp 0 
616a					;halt 
616a			 
616a			 
616a			 
616a .. 00		.stackfault: 	db "Stack fault:",0 
6177			 
6177 .. 00		sfaultsu: 	db	"Stack under flow",0 
6188 .. 00		sfaultso: 	db	"Stack over flow",0 
6198 .. 00		sfaultru:	db "RTS underflow",0 
61a6 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
61c0 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
61da .. 00		sfaultdo:	db "DTS overflow", 0 
61e7			 
61e7			 
61e7			fault_dsp_under: 
61e7 11 f9 61			ld de, .dsp_under 
61ea c3 a9 62			jp .show_fault 
61ed			 
61ed			fault_rsp_under: 
61ed 11 07 62			ld de, .rsp_under 
61f0 c3 a9 62			jp .show_fault 
61f3			fault_loop_under: 
61f3 11 15 62			ld de, .loop_under 
61f6 c3 a9 62			jp .show_fault 
61f9			 
61f9 .. 00		.dsp_under: db "DSP Underflow",0 
6207 .. 00		.rsp_under: db "RSP Underflow",0 
6215 .. 00		.loop_under: db "LOOP Underflow",0 
6224			 
6224			 
6224 d5			type_faultn: 	push de 
6225 e5					push hl 
6226 cd ba 0b				call clear_display 
6229 11 50 62				   ld de, .typefaultn 
622c 3e 00				ld a, display_row_1 
622e cd cd 0b				call str_at_display 
6231 11 71 ee				    ld de, debug_mark 
6234 3e 11				ld a, display_row_1+17 
6236 cd cd 0b				call str_at_display 
6239 cd dd 0b				call update_display 
623c			 
623c				; prompt before entering montior for investigating issue 
623c			 
623c 3e 78			ld a, display_row_4 
623e 11 78 19			ld de, endprog 
6241			 
6241 cd dd 0b			call update_display		 
6244			 
6244 cd d6 1b			call next_page_prompt 
6247			 
6247 e5					push hl 
6248 d5					push de 
6249 cd cc 19				call monitor 
624c c3 c6 18				jp warmstart 
624f 76					halt 
6250			 
6250			 
6250 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6267			 
6267 d5			type_faults: 	push de 
6268 e5					push hl 
6269 cd ba 0b				call clear_display 
626c 11 92 62				   ld de, .typefaults 
626f 3e 00				ld a, display_row_1 
6271 cd cd 0b				call str_at_display 
6274 11 71 ee				    ld de, debug_mark 
6277 3e 11				ld a, display_row_1+17 
6279 cd cd 0b				call str_at_display 
627c cd dd 0b				call update_display 
627f			 
627f				; prompt before entering montior for investigating issue 
627f			 
627f 3e 78			ld a, display_row_4 
6281 11 78 19			ld de, endprog 
6284			 
6284 cd dd 0b			call update_display		 
6287			 
6287 cd d6 1b			call next_page_prompt 
628a			 
628a e1					pop hl 
628b d1					pop de 
628c cd cc 19				call monitor 
628f c3 c6 18				jp warmstart 
6292			 
6292			 
6292 .. 00		.typefaults: db "STR Type Expected TOS!",0 
62a9			 
62a9			.show_fault: 	 
62a9 d5					push de 
62aa cd ba 0b				call clear_display 
62ad d1					pop de 
62ae 3e 00				ld a, display_row_1 
62b0 cd cd 0b				call str_at_display 
62b3 11 71 ee				    ld de, debug_mark 
62b6 3e 11				ld a, display_row_1+17 
62b8 cd cd 0b				call str_at_display 
62bb cd dd 0b				call update_display 
62be			 
62be				; prompt before entering montior for investigating issue 
62be			 
62be 3e 78			ld a, display_row_4 
62c0 11 78 19			ld de, endprog 
62c3			 
62c3 cd dd 0b			call update_display		 
62c6			 
62c6 cd d6 1b			call next_page_prompt 
62c9			 
62c9 e1					pop hl 
62ca d1					pop de 
62cb cd cc 19				call monitor 
62ce			; do a dump to cli and not warmstart so we preserve all of the uwords.  
62ce			; TODO Make optional fault restart to cli or warm boot? 
62ce					;jp warmstart 
62ce c3 1e 19				jp cli 
62d1 76					halt 
62d2			 
62d2			; handle the auto run of code from files in storage 
62d2			 
62d2			 
62d2			include "forth_startup.asm" 
62d2			; Which startup method to use? 
62d2			; 
62d2			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
62d2			; followed by loading of a list of scripts in eeprom 
62d2			 
62d2			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
62d2			; from eeprom 
62d2			 
62d2			; Select with define in main stubs 
62d2			 
62d2			if STARTUP_V1 
62d2				include "forth_startupv1.asm" 
62d2			; Startup script loading version 1 
62d2			 
62d2			; If SE storage is available first stage is to use the selected file 
62d2			; then go through the eeprom list 
62d2			 
62d2 .. 00		sprompt1: db "Startup load...",0 
62e2 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
62f8			 
62f8			 
62f8			 
62f8			 
62f8			forth_startup: 
62f8 21 1e 4e			ld hl, startcmds 
62fb 3e 00			ld a, 0 
62fd 32 ed e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6300			 
6300 e5			.start1:	push hl 
6301 cd ba 0b			call clear_display 
6304 11 d2 62			ld de, sprompt1 
6307 3e 00		        ld a, display_row_1 
6309 cd cd 0b			call str_at_display 
630c 11 e2 62			ld de, sprompt2 
630f 3e 28		        ld a, display_row_2 
6311 cd cd 0b			call str_at_display 
6314 e1				pop hl 
6315 e5				push hl 
6316 5e				ld e,(hl) 
6317 23				inc hl 
6318 56				ld d,(hl) 
6319 3e 50		        ld a, display_row_3 
631b cd cd 0b			call str_at_display 
631e cd dd 0b			call update_display 
6321			 
6321			 
6321 3a ed e6			ld a, (os_last_cmd) 
6324 fe 00			cp 0 
6326 28 05			jr z, .startprompt 
6328 cd e6 0a			call delay250ms 
632b 18 24			jr .startdo 
632d				 
632d				 
632d			 
632d			.startprompt: 
632d			 
632d 3e 9f			ld a,display_row_4 + display_cols - 1 
632f 11 d4 1b		        ld de, endprg 
6332 cd cd 0b			call str_at_display 
6335 cd dd 0b			call update_display 
6338 cd f2 0a			call delay1s 
633b cd 97 64			call cin_wait 
633e						 
633e fe 2a			cp '*' 
6340 28 5e			jr z, .startupend1 
6342 fe 23			cp '#' 
6344 20 07			jr nz, .startno 
6346 3e 01			ld a, 1 
6348 32 ed e6			ld (os_last_cmd),a 
634b 18 04			jr .startdo 
634d fe 31		.startno:	cp '1' 
634f 28 3a			jr z,.startnxt  
6351			 
6351				; exec startup line 
6351			.startdo:	 
6351 e1				pop hl 
6352 e5				push hl 
6353				 
6353 5e				ld e,(hl) 
6354 23				inc hl 
6355 56				ld d,(hl) 
6356 eb				ex de,hl 
6357			 
6357 e5				push hl 
6358			 
6358 3e 00			ld a, 0 
635a				;ld a, FORTH_END_BUFFER 
635a cd 50 12			call strlent 
635d 23				inc hl   ; include zero term to copy 
635e 06 00			ld b,0 
6360 4d				ld c,l 
6361 e1				pop hl 
6362 11 c7 e2			ld de, scratch 
6365 ed b0			ldir 
6367			 
6367			 
6367 21 c7 e2			ld hl, scratch 
636a cd 59 20			call forthparse 
636d cd 99 20			call forthexec 
6370 cd ab 1f			call forthexec_cleanup 
6373			 
6373 3e 78			ld a, display_row_4 
6375 11 78 19			ld de, endprog 
6378			 
6378 cd dd 0b			call update_display		 
637b			 
637b 3a ed e6			ld a, (os_last_cmd) 
637e fe 00			cp 0 
6380 20 09			jr nz, .startnxt 
6382 cd d6 1b			call next_page_prompt 
6385 cd ba 0b		        call clear_display 
6388 cd dd 0b			call update_display		 
638b			 
638b				; move onto next startup line? 
638b			.startnxt: 
638b			 
638b cd e6 0a			call delay250ms 
638e e1				pop hl 
638f			 
638f 23				inc hl 
6390 23				inc hl 
6391			 
6391 e5				push hl 
6392 5e				ld e, (hl) 
6393 23				inc hl 
6394 56				ld d, (hl) 
6395 e1				pop hl 
6396				; TODO replace 0 test 
6396			 
6396 eb				ex de, hl 
6397 cd 10 0e			call ishlzero 
639a			;	ld a,e 
639a			;	add d 
639a			;	cp 0    ; any left to do? 
639a eb				ex de, hl 
639b c2 00 63			jp nz, .start1 
639e 18 01			jr .startupend 
63a0			 
63a0 e1			.startupend1: pop hl 
63a1			.startupend: 
63a1			 
63a1 cd ba 0b			call clear_display 
63a4 cd dd 0b			call update_display 
63a7 c9				ret 
63a8			if STORAGE_SE 
63a8			 
63a8			sprompt3: db "Loading from start-up file?:",0 
63a8			sprompt4: db "(Y=Any key/N=No)",0 
63a8			 
63a8			 
63a8			forth_autoload: 
63a8			 
63a8				; load block 0 of store 1 
63a8				 
63a8				ld a, $fe      ; bit 0 clear 
63a8				ld (spi_device), a 
63a8			 
63a8				call storage_get_block_0 
63a8			 
63a8				ld a, (store_page+STORE_0_AUTOFILE) 
63a8			 
63a8				cp 0 
63a8				ret z     ; auto start not enabled 
63a8			 
63a8				call clear_display 
63a8			 
63a8				; set bank 
63a8			 
63a8					ld a, (store_page+STORE_0_BANKRUN) 
63a8					ld (spi_device), a 
63a8			 
63a8				; get file id to load from and get the file name to display 
63a8			 
63a8					ld a, (store_page+STORE_0_FILERUN) 
63a8			 
63a8					ld l, 0 
63a8					ld h, a 
63a8					ld de, store_page 
63a8			 
63a8					if DEBUG_FORTH_WORDS 
63a8						DMARK "ASp" 
63a8						CALLMONITOR 
63a8					endif 
63a8					call storage_read 
63a8			 
63a8					if DEBUG_FORTH_WORDS 
63a8						DMARK "ASr" 
63a8						CALLMONITOR 
63a8					endif 
63a8			 
63a8					call ishlzero 
63a8					ret z             ; file not found 
63a8			 
63a8					ld a, display_row_2 + 10 
63a8					ld de, store_page+3 
63a8					call str_at_display 
63a8				 
63a8			; 
63a8			 
63a8				ld a, display_row_1+5 
63a8				ld de, sprompt3 
63a8				call str_at_display 
63a8				ld a, display_row_3+15 
63a8				ld de, sprompt4 
63a8				call str_at_display 
63a8			 
63a8				call update_display 
63a8			 
63a8				call cin_wait 
63a8				cp 'n' 
63a8				ret z 
63a8				cp 'N' 
63a8				ret z 
63a8			 
63a8				call delay1s 
63a8			 
63a8				ld a, (store_page+2) 
63a8				ld (store_openmaxext), a    ; save count of ext 
63a8				ld a, 1  
63a8				ld (store_openext), a    ; save count of ext 
63a8			 
63a8			.autof:  
63a8				ld l , a 
63a8				 
63a8				ld a, (store_page) 
63a8				ld h, a	 
63a8				ld de, store_page 
63a8					if DEBUG_FORTH_WORDS 
63a8						DMARK "ASl" 
63a8						CALLMONITOR 
63a8					endif 
63a8					call storage_read 
63a8				call ishlzero 
63a8				ret z 
63a8			;	jr z, .autoend 
63a8			 
63a8					if DEBUG_FORTH_WORDS 
63a8						DMARK "ASc" 
63a8						CALLMONITOR 
63a8					endif 
63a8				ld de, store_page+2 
63a8				ld a, display_row_4 
63a8				call str_at_display 
63a8			 
63a8				call update_display 
63a8				call delay250ms 
63a8			 
63a8			 
63a8			 
63a8				ld hl, store_page+2 
63a8				call forthparse 
63a8				call forthexec 
63a8				call forthexec_cleanup 
63a8			 
63a8				 
63a8				ld a, (store_openext) 
63a8				inc a 
63a8				ld (store_openext), a    ; save count of ext 
63a8			 
63a8				jr .autof 
63a8			;.autofdone: 
63a8			; 
63a8			;		if DEBUG_FORTH_WORDS 
63a8			;			DMARK "ASx" 
63a8			;			CALLMONITOR 
63a8			;		endif 
63a8			;;	call clear_display 
63a8			;	ret 
63a8			 
63a8			 
63a8			 
63a8			endif 
# End of file forth_startupv1.asm
63a8			endif 
63a8			if STARTUP_V2 
63a8				include "forth_startupv2.asm" 
63a8			endif 
63a8			 
# End of file forth_startup.asm
63a8			 
63a8			; eof 
# End of file forth_kernel.asm
63a8			;include "nascombasic.asm" 
63a8			 
63a8			 
63a8			; find out where the code ends if loaded into RAM (for SC114) 
63a8			;endofcode:  
63a8			;	nop 
63a8			 
63a8			 
63a8			; eof 
63a8			 
# End of file main.asm
63a8			;include "firmware_lcd_4x40.asm" 
63a8			;;include "firmware_lcd_4x20.asm" 
63a8			include "firmware_cpm_display.asm" 
63a8			 
63a8			; Serial display interface for SC114 
63a8			 
63a8			 
63a8			display_row_1: equ 0 
63a8			display_row_2: equ display_row_1+display_cols 
63a8			display_row_3: equ display_row_2 + display_cols 
63a8			display_row_4: equ display_row_3 + display_cols 
63a8			 
63a8			kLCDWidth:  EQU display_cols             ;Width in characters 
63a8			kLCD_Line1: EQU 0x00  
63a8			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
63a8			; E1 
63a8			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
63a8			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
63a8			 
63a8			lcd_init: 
63a8				; no init as handled by the SCM bios 
63a8 c9				ret 
63a9			 
63a9			 
63a9			; low level functions for direct screen writes 
63a9			 
63a9			; output char at pos? 
63a9			fLCD_Str: 
63a9			        ;out (SC114_SIO_1_OUT),a 
63a9 c5				push bc 
63aa d5				push de 
63ab 5f				ld e, a 
63ac			; TODO Replace with CP/M BIOS call 
63ac 0e 02			ld c, $02 
63ae cd 05 00			call 5 
63b1 d1				pop de 
63b2 c1				pop bc 
63b3 c9				ret 
63b4			 
63b4			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
63b4			fLCD_Pos: 
63b4				; use ASCII escape to position 
63b4			        ;out (SC114_SIO_1_OUT),a 
63b4 c5				push bc 
63b5 d5				push de 
63b6 5f				ld e, a 
63b7 0e 02			ld c, $02 
63b9			; TODO Replace with CP/M BIOS call 
63b9 cd 05 00			call 5 
63bc d1				pop de 
63bd c1				pop bc 
63be			 
63be c9				ret 
63bf			 
63bf			; output char at pos 
63bf			fLCD_Data: 
63bf			      ;  out (SC114_SIO_1_OUT),a 
63bf c5				push bc 
63c0 d5				push de 
63c1 0e 02			ld c, $02 
63c3 5f				ld e, a 
63c4			; TODO Replace with CP/M BIOS call 
63c4 cd 05 00			call 5 
63c7 d1				pop de 
63c8 c1				pop bc 
63c9			 
63c9 c9				ret 
63ca			 
63ca			; ascii cls  
63ca			 
63ca 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
63ce			 
63ce 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
63e5			;.clscpm: db 3, $3c,"$" 
63e5			 
63e5			; write the frame buffer given in hl to hardware  
63e5			write_display: 
63e5			 
63e5			API: equ 0 
63e5			 
63e5			if API 
63e5				push bc 
63e5				ld b, 4 
63e5			 
63e5			        ld (display_write_tmp), hl 	  
63e5			 
63e5				; clear and home cursor 
63e5			 
63e5				ld c, 9 
63e5				ld de, .cls 
63e5			; TODO Replace with CP/M BIOS call 
63e5				call 5 
63e5			 
63e5			 
63e5			.writeln: 
63e5			 
63e5				ld de, (display_write_tmp) 
63e5				ld c, 6 
63e5			; TODO Replace with CP/M BIOS call 
63e5				rst $30 
63e5				ld c, 7 
63e5				rst $30 
63e5			 
63e5				ld hl, (display_write_tmp) 
63e5				ld de, display_cols 
63e5				add hl,de 
63e5				ld (display_write_tmp),hl 
63e5			 
63e5				djnz  .writeln 
63e5			 
63e5				pop bc 
63e5			 
63e5			 
63e5				ret 
63e5			endif 
63e5 e5				push hl 
63e6 c5				push bc 
63e7 d5				push de 
63e8			 
63e8			;	ld c, 2 
63e8			;	;ld de, .cls 
63e8			;	ld a, 27 
63e8			;	rst $30 
63e8			;	ld c, 2 
63e8			;	;ld de, .cls 
63e8			;	ld a, '[' 
63e8			;	rst $30 
63e8			; 
63e8			;	ld c, 2 
63e8			;	;ld de, .cls 
63e8			;	ld a, 'H' 
63e8			;	rst $30 
63e8			; 
63e8			 
63e8			 
63e8			; lots of CR/LF 
63e8			;	ld c, 9 
63e8			;	ld de, .clscpm 
63e8			;	call 5 
63e8			 
63e8			; xterm cls 
63e8 0e 02			ld c, 2 
63ea 1e 1b			ld e, 27 
63ec cd 05 00			call 5 
63ef			; cls causes too much flicker 
63ef			;	ld c, 2 
63ef			;	ld e, 'c' 
63ef			;	call 5 
63ef			 
63ef			; use xterm home instead 
63ef 0e 02			ld c, 2 
63f1 1e 5b			ld e, '[' 
63f3 cd 05 00			call 5 
63f6 0e 02			ld c, 2 
63f8 1e 48			ld e, 'H' 
63fa cd 05 00			call 5 
63fd			LLL: equ 0 
63fd			 
63fd			if LLL 
63fd			 
63fd				ld c, 2 
63fd				;ld de, .cls 
63fd				ld e, 27 
63fd			; TODO Replace with CP/M BIOS call 
63fd				call 5 
63fd			 
63fd			 
63fd				ld c, 2 
63fd				;ld de, .cls 
63fd				ld e, '[' 
63fd			; TODO Replace with CP/M BIOS call 
63fd				call 5 
63fd				ld c, 2 
63fd				;ld de, .cls 
63fd				ld e, '2' 
63fd			; TODO Replace with CP/M BIOS call 
63fd				call 5 
63fd				ld c, 2 
63fd				;ld de, .cls 
63fd				ld e, 'J' 
63fd			; TODO Replace with CP/M BIOS call 
63fd				call 5 
63fd			 
63fd			endif 
63fd			 
63fd d1				pop de 
63fe c1				pop bc 
63ff e1				pop hl 
6400			 
6400			 
6400 22 cf eb		        ld (display_write_tmp), hl 	  
6403 3e 00			ld a, kLCD_Line1 
6405			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6405 06 28			ld b, display_cols 
6407 ed 5b cf eb		ld de, (display_write_tmp) 
640b cd 8e 64			call write_len_string 
640e				 
640e			 
640e e5			push hl 
640f d5			push de 
6410 c5			push bc 
6411 0e 02			ld c, 2 
6413 1e 0a			ld e, 10 
6415 cd 05 00			call 5 
6418 0e 02			ld c, 2 
641a 1e 0d			ld e, 13 
641c cd 05 00			call 5 
641f			; TODO Replace with CP/M BIOS call 
641f				;rst $30 
641f c1			pop bc 
6420 d1			pop de 
6421 e1			pop hl 
6422			 
6422				 
6422 2a cf eb			ld hl, (display_write_tmp) 
6425 11 28 00			ld de, display_cols 
6428 19				add hl,de 
6429 22 cf eb			ld (display_write_tmp),hl 
642c			 
642c				 
642c 3e 28			ld a, kLCD_Line2 
642e			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
642e 06 28			ld b, display_cols 
6430 ed 5b cf eb		ld de, (display_write_tmp) 
6434 cd 8e 64			call write_len_string 
6437				 
6437 2a cf eb			ld hl, (display_write_tmp) 
643a 11 28 00			ld de, display_cols 
643d 19				add hl,de 
643e 22 cf eb			ld (display_write_tmp),hl 
6441			 
6441 e5			push hl 
6442 d5			push de 
6443 c5			push bc 
6444 0e 07			ld c, 7 
6446			; TODO Replace with CP/M BIOS call 
6446				;rst $30 
6446 0e 02			ld c, 2 
6448 1e 0a			ld e, 10 
644a cd 05 00			call 5 
644d 0e 02			ld c, 2 
644f 1e 0d			ld e, 13 
6451 cd 05 00			call 5 
6454 c1			pop bc 
6455 d1			pop de 
6456 e1			pop hl 
6457			 
6457				 
6457 3e 50			ld a, kLCD_Line3 
6459			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6459 06 28			ld b, display_cols 
645b ed 5b cf eb		ld de, (display_write_tmp) 
645f cd 8e 64			call write_len_string 
6462				 
6462 2a cf eb			ld hl, (display_write_tmp) 
6465 11 28 00			ld de, display_cols 
6468 19				add hl,de 
6469 22 cf eb			ld (display_write_tmp),hl 
646c			 
646c e5			push hl 
646d d5			push de 
646e c5			push bc 
646f 0e 07			ld c, 7 
6471			; TODO Replace with CP/M BIOS call 
6471				;rst $30 
6471 0e 02			ld c, 2 
6473 1e 0a			ld e, 10 
6475 cd 05 00			call 5 
6478 0e 02			ld c, 2 
647a 1e 0d			ld e, 13 
647c cd 05 00			call 5 
647f c1			pop bc 
6480 d1			pop de 
6481 e1			pop hl 
6482			 
6482				 
6482 3e 78			ld a, kLCD_Line4 
6484			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6484 06 28			ld b, display_cols 
6486 ed 5b cf eb		ld de, (display_write_tmp) 
648a cd 8e 64			call write_len_string 
648d c9					ret 
648e			 
648e			 
648e				; write out a fixed length string given in b from de 
648e			 
648e 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
648f cd bf 63		            CALL fLCD_Data      ;Write character to display 
6492 13				inc de 
6493 10 f9			djnz write_len_string 
6495 c9				ret 
6496			 
6496			 
6496			; eof 
# End of file firmware_cpm_display.asm
6496			;include "firmware_key_5x10.asm" 
6496			;;include "firmware_key_4x10.asm" 
6496			include "firmware_key_cpm.asm" 
6496			; Serial keyboard interface for SC114 
6496			 
6496			 
6496			key_init: 
6496				; no init as handled by the SCM bios 
6496 c9				ret 
6497			 
6497			 
6497			cin_wait: 
6497			;	ld a, 0 
6497			;	ret 
6497			 
6497				;in a,(SC114_SIO_1_IN) 
6497			        ; Use SCM API to get from whatever console device we are using 
6497			 
6497			; TODO Replace with CP/M BIOS call 
6497 c5				push bc 
6498 0e 01			ld c, $01 
649a cd 05 00			call 5 
649d c1				pop bc 
649e c9				ret 
649f			 
649f			cin: 
649f			 
649f			 
649f c5				push bc 
64a0			 
64a0				; any key waiting to process? 
64a0			; TODO Replace with CP/M BIOS call 
64a0 0e 06			ld c, $06 
64a2 cd 05 00			call 5 
64a5 28 0d			jr z, .cin_skip 
64a7			 
64a7				; yep, get it 
64a7			 
64a7 0e 01			ld c, $01 
64a9			; TODO Replace with CP/M BIOS call 
64a9 cd 05 00			call 5 
64ac			 
64ac fe 7f			cp $7f     ; back space 
64ae 20 02			jr nz, .skipbs 
64b0 3e 08			ld a, KEY_BS 
64b2			.skipbs: 
64b2			 
64b2 c1				pop bc 
64b3 c9				ret 
64b4			.cin_skip: 
64b4 3e 00			ld a, 0 
64b6 c1				pop bc 
64b7 c9				ret 
64b8			 
64b8			 
64b8			 
64b8			 
# End of file firmware_key_cpm.asm
64b8			endofcode:  
64b8			baseram:  
64b8 00				nop 
64b9			 
64b9			heap_start: equ baseram+15  ; Starting address of heap 
64b9			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
64b9			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
64b9			;VDU:  EQU     endofcode           ; BASIC Work space 
64b9			; eof 
64b9			 
# End of file os_mega_cpm.asm
64b9
