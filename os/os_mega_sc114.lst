# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 72 99			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-09 10:11' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			;stacksize: equ 256  
801b			; each stack entry is three bytes (type + word)  
801b			stacksize: equ 3*150  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			; cursor blink rate  
801b			CUR_BLINK_RATE: equ $09  
801b			;CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd 44 e6				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd e6 e6			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd a2 93				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 d0 98			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 e5 98			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd 89 93				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd 5c 93			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd 8e a0			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd d7 9c			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd 5b e6			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd e7 e6				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored and edited directly 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO use LCD cursor? 
8d08			 
8d08			EDIT_V1: equ 0 
8d08			EDIT_V2: equ 1 
8d08			 
8d08			 
8d08			 
8d08			if EDIT_V2 
8d08			input_str: 
8d08			else 
8d08			input_str_new: 
8d08			endif 
8d08			 
8d08 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8d0b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d0b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d0e			;		ld a, c 
8d0e			;		call addatohl 
8d0e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d0e 7a					ld a,d 
8d0f 32 66 ee			        ld (input_size), a       ; save length of input area 
8d12 79					ld a, c 
8d13 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d16 7b					ld a,e 
8d17 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d1a			 
8d1a			 
8d1a					; add a trailing space to make screen refresh nicer 
8d1a			 
8d1a					;ld hl, (input_start) 
8d1a					;push hl 
8d1a					;ld a, 0 
8d1a					;call strlent 
8d1a					;ld a, l 
8d1a					;pop hl 
8d1a					;call addatohl 
8d1a					;dec hl 
8d1a					;ld a, ' ' 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld (hl), a 
8d1a					;inc hl 
8d1a					;ld a, 0 
8d1a					;ld (hl), a 
8d1a			 
8d1a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d1a					; init cursor shape if not set by the cin routines 
8d1a 21 c1 eb				ld hl, cursor_shape 
8d1d			if BASE_KEV 
8d1d					ld a, 255 
8d1d			else 
8d1d 3e 23				ld a, '#' 
8d1f			endif 
8d1f 77					ld (hl), a 
8d20 23					inc hl 
8d21 3e 00				ld a, 0 
8d23 77					ld (hl), a 
8d24			 
8d24 3e 09				ld a, CUR_BLINK_RATE 
8d26 32 60 ee				ld (input_cur_flash), a 
8d29 3e 01				ld a, 1 
8d2b 32 5f ee				ld (input_cur_onoff),a 
8d2e			.inmain:	 
8d2e			 
8d2e cd 9a 8e				call input_disp_ref 
8d31			 
8d31					; save current length of string 
8d31			 
8d31 2a 67 ee				ld hl, (input_start) 
8d34 3e 00				ld a, 0 
8d36 cd 5c 93				call strlent 
8d39 7d					ld a,l 
8d3a 32 5a ee				ld (input_len), a 
8d3d			 
8d3d					;call input_disp_oncur 
8d3d			 
8d3d					; display current state of input buffer 
8d3d			 
8d3d					; clean any backspace chars 
8d3d			 
8d3d 3e 5f				ld a, "_" 
8d3f 32 c1 e2				ld (scratch),a 
8d42 3e 00				ld a, 0 
8d44 32 c2 e2				ld (scratch+1),a 
8d47 3a 64 ee				ld a,(input_at_pos) 
8d4a 85					add l 
8d4b 11 c1 e2				ld de, scratch 
8d4e cd c1 8a				call str_at_display 
8d51			 
8d51					; pause 1ms 
8d51			 
8d51 3e 01				ld a, 1 
8d53 cd d6 89				call aDelayInMS 
8d56			 
8d56			; display cursor if visible on this cycle 
8d56			 
8d56					; dec flash counter 
8d56 3a 60 ee				ld a, (input_cur_flash) 
8d59 3d					dec a 
8d5a 32 60 ee				ld (input_cur_flash), a 
8d5d fe 00				cp 0 
8d5f 20 0d				jr nz, .inochgstate 
8d61			 
8d61			 
8d61					; reset on change of state 
8d61 3e 09				ld a, CUR_BLINK_RATE 
8d63 32 60 ee				ld (input_cur_flash), a 
8d66			 
8d66					; change state 
8d66 3a 5f ee				ld a,(input_cur_onoff) 
8d69 ed 44				neg 
8d6b 32 5f ee				ld (input_cur_onoff),a 
8d6e			 
8d6e			 
8d6e			 
8d6e			 
8d6e					; TODO is cursor visible? 
8d6e					; TODO if so then over write the char at curspos pos with the cursor shape 
8d6e			 
8d6e								 
8d6e			 
8d6e			.inochgstate: 
8d6e 3a 5f ee				ld a,(input_cur_onoff) 
8d71 fe ff				cp 255 
8d73 28 0e				jr z, .skipcursor 
8d75 3a 64 ee				ld a, (input_at_pos) 
8d78 47					ld b, a 
8d79 3a 55 ee				ld a, (input_cursor) 
8d7c 80					add b 
8d7d 11 c1 eb				ld de, cursor_shape 
8d80					 
8d80 cd c1 8a				call str_at_display 
8d83			 
8d83			.skipcursor: 
8d83				if DEBUG_INPUTV2 
8d83			 
8d83 3a 64 ee				ld a,(input_at_pos) 
8d86 21 ad eb				ld hl, LFSRSeed 
8d89 cd f4 91				call hexout 
8d8c 3a 55 ee				ld a, (input_cursor) 
8d8f 21 af eb				ld hl, LFSRSeed+2 
8d92 cd f4 91				call hexout 
8d95 3a 66 ee				ld a,(input_size) 
8d98 21 b1 eb				ld hl, LFSRSeed+4 
8d9b cd f4 91				call hexout 
8d9e			 
8d9e 3a 5f ee				ld a,(input_cur_onoff) 
8da1 21 b3 eb				ld hl, LFSRSeed+6 
8da4 cd f4 91				call hexout 
8da7			 
8da7 3a 60 ee				ld a,(input_cur_flash) 
8daa 21 b5 eb				ld hl, LFSRSeed+8 
8dad cd f4 91				call hexout 
8db0			 
8db0 3a 5a ee				ld a,(input_len) 
8db3 21 b7 eb				ld hl, LFSRSeed+10 
8db6 cd f4 91				call hexout 
8db9 21 b9 eb				ld hl, LFSRSeed+12 
8dbc 3e 00				ld a, 0 
8dbe 77					ld (hl),a 
8dbf 3e 78				ld a, display_row_4 
8dc1 11 ad eb				ld de, LFSRSeed 
8dc4 cd c1 8a				call str_at_display 
8dc7				endif 
8dc7 cd d1 8a				call update_display 
8dca			 
8dca					; TODO keyboard processing 
8dca			 
8dca			if BASE_CPM 
8dca					call cin_wait 
8dca			else 
8dca cd ed e6				call cin    ; _wait 
8dcd			endif 
8dcd fe 00				cp 0 
8dcf ca 2e 8d				jp z, .inmain 
8dd2			 
8dd2 fe 0b				cp KEY_LEFT    ; cursor left 
8dd4 ca 8c 8e				jp z, input_left 
8dd7				 
8dd7 fe 0c				cp KEY_RIGHT      ; cursor right 
8dd9 ca 93 8e				jp z, input_right 
8ddc			 
8ddc fe 0d				cp KEY_CR 
8dde c8					ret z 
8ddf			 
8ddf fe 08				cp KEY_BS 
8de1 ca 01 8f				jp z, input_delchar 
8de4			 
8de4 fe 06				cp KEY_NEXTWORD 
8de6 ca 1f 8e				jp z, input_nxtword 
8de9			 
8de9 fe 07				cp KEY_PREVWORD 
8deb ca 46 8e				jp z, input_prvword 
8dee fe 10				cp KEY_F1 
8df0 ca 46 8e				jp z, input_prvword 
8df3			.inskl: 
8df3 fe 0e				cp KEY_HOME    ; jump to start of line 
8df5 20 08				jr nz, .ikh 
8df7 3e 00				ld a, 0 
8df9 32 55 ee				ld (input_cursor), a 
8dfc ca 2e 8d				jp z, .inmain 
8dff			.ikh: 
8dff			 
8dff fe 0f				cp KEY_END     ; jump to end of line 
8e01 20 09				jr nz, .ike 
8e03 3a 5a ee				ld a, (input_len) 
8e06 32 55 ee				ld (input_cursor),a 
8e09 ca 2e 8d				jp z, .inmain 
8e0c			.ike: 
8e0c fe 05			        cp KEY_UP      ; recall last command 
8e0e 20 0c				jr nz, .irec 
8e10			; TODO next word 
8e10			; TODO prev word 
8e10			;  
8e10			; 
8e10 21 c1 e2			ld hl, scratch 
8e13 11 e7 e6			ld de, os_last_cmd 
8e16 cd ea 91			call strcpy 
8e19 ca 2e 8d				jp z, .inmain 
8e1c			.irec: 
8e1c			;		jr .instr1 
8e1c			 
8e1c			 
8e1c					; if no special key then insert as a char 
8e1c			 
8e1c c3 d3 8e				jp input_inschr 
8e1f			 
8e1f				 
8e1f			input_nxtword: 
8e1f				; jump to start next word after the cursor 
8e1f			 
8e1f			.insknwn:	 
8e1f cd c9 8e				call input_curptr	 
8e22 7e					ld a,(hl)	 
8e23 fe 00				cp 0 
8e25 ca 2e 8d				jp z, .inmain    ; end of string 
8e28			 
8e28			; if we are on a word, then move off of it 
8e28			 
8e28 fe 20				cp ' ' 
8e2a 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8e2c 21 55 ee				ld hl, input_cursor 
8e2f 34					inc (hl) 
8e30 18 ed				jr .insknwn 
8e32			 
8e32			.inspace: 
8e32			 
8e32 cd c9 8e				call input_curptr	 
8e35 7e					ld a,(hl)	 
8e36 fe 00				cp 0 
8e38 ca 2e 8d				jp z, .inmain    ; end of string 
8e3b			 
8e3b			; if we are on a word, then move off of it 
8e3b			 
8e3b fe 20				cp ' ' 
8e3d c2 2e 8d				jp nz, .inmain     ; we are on non space so at next word 
8e40 21 55 ee				ld hl, input_cursor 
8e43 34					inc (hl) 
8e44 18 ec				jr .inspace 
8e46			 
8e46			 
8e46			 
8e46			 
8e46			input_prvword: 
8e46				; jump to the start of previous word before the cursor 
8e46			.inskpwn:	 
8e46 3a 55 ee				ld a,(input_cursor) 
8e49 fe 00				cp 0 
8e4b ca 2e 8d				jp z, .inmain    ; start of string 
8e4e			 
8e4e			; if we are on a word, then move off of it 
8e4e			 
8e4e cd c9 8e				call input_curptr	 
8e51 fe 20				cp ' ' 
8e53 28 06				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8e55					;jp z, .inmain    ; start of string 
8e55 21 55 ee				ld hl, input_cursor 
8e58 35					dec (hl) 
8e59 18 eb				jr .inskpwn 
8e5b			 
8e5b			.inspacep: 
8e5b			 
8e5b 3a 55 ee				ld a,(input_cursor) 
8e5e fe 00				cp 0 
8e60 ca 2e 8d				jp z, .inmain    ; start of string 
8e63			 
8e63			; if we are on a word, then move off of it 
8e63			 
8e63 cd c9 8e				call input_curptr	 
8e66 fe 20				cp ' ' 
8e68 c2 71 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e6b 21 55 ee				ld hl, input_cursor 
8e6e 35					dec (hl) 
8e6f 18 ea				jr .inspacep 
8e71			 
8e71			 
8e71			.incharp:	 
8e71					; eat the word to get to the start 
8e71 3a 55 ee				ld a,(input_cursor) 
8e74 fe 00				cp 0 
8e76 ca 2e 8d				jp z, .inmain    ; start of string 
8e79			 
8e79			; if we are on a word, then move off of it 
8e79			 
8e79 cd c9 8e				call input_curptr	 
8e7c fe 20				cp ' ' 
8e7e 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e80 21 55 ee				ld hl, input_cursor 
8e83 35					dec (hl) 
8e84 18 eb				jr .incharp 
8e86			.ipwordst: 
8e86					; at space before the prev word so reposition over it 
8e86 21 55 ee				ld hl, input_cursor 
8e89 34					inc (hl) 
8e8a 18 ba				jr .inskpwn 
8e8c					 
8e8c			 
8e8c			 
8e8c			input_left: 
8e8c				; move cursor left 
8e8c 21 55 ee			ld hl, input_cursor 
8e8f 35				dec (hl) 
8e90			;	cp 0 
8e90			;	jp z, .inmain    ; ignore left as at the start of the string 
8e90 c3 2e 8d			jp .inmain 
8e93			 
8e93			input_right: 
8e93				; move cursor right 
8e93				 
8e93				;ld a, (input_size) 
8e93				;ld b, a 
8e93 21 55 ee			ld hl, input_cursor 
8e96 34				inc (hl) 
8e97				;dec b 
8e97				;cp 0 
8e97				;jp z, .inmain   ; ignore as at end of the string buffer 
8e97				;ld a, b 
8e97				;inc a 
8e97				;ld (input_cursor), a 
8e97 c3 2e 8d			jp .inmain 
8e9a			 
8e9a			 
8e9a			 
8e9a			input_disp_ref: 
8e9a				; display the text from start of buffer (ie full refresh) 
8e9a 3a 64 ee			ld a, (input_at_pos) 
8e9d 2a 67 ee			ld hl,(input_start) 
8ea0 eb				ex de, hl 
8ea1 cd c1 8a			call str_at_display  
8ea4 c9				ret 
8ea5			input_disp_oncur: 
8ea5				; display the text from cursor position to end of buffer 
8ea5				; TODO position start of string at cursor position on screen 
8ea5				; TODO draw from that point on 
8ea5 3a 55 ee			ld a, (input_cursor) 
8ea8 47				ld b, a 
8ea9 3a 64 ee			ld a, (input_at_pos) 
8eac 80				add b 
8ead 48				ld c, b     ; save a 
8eae 78				ld a, b     ; inc string start for cursor 
8eaf 2a 67 ee			ld hl,(input_start) 
8eb2 cd db 8c			call addatohl 
8eb5 eb				ex de, hl 
8eb6 79				ld a, c 
8eb7 cd c1 8a			call str_at_display  
8eba c9				ret 
8ebb			 
8ebb			input_nxtw: 
8ebb				; Find next word 
8ebb c9				ret 
8ebc			 
8ebc			input_prvw: 
8ebc				; Find previous word 
8ebc c9				ret 
8ebd			 
8ebd			input_lenrem:   
8ebd				; Calculate the length of string remaining from current cursor 
8ebd				; position to end of buffer (exc null term) 
8ebd				 
8ebd 3a 55 ee			ld a, (input_cursor) 
8ec0 4f				ld c, a 
8ec1 3a 66 ee			ld a, (input_size) 
8ec4 91				sub c 
8ec5 06 00			ld b, 0 
8ec7 0d				dec c 
8ec8 c9				ret	 
8ec9			 
8ec9			input_curptr: 
8ec9				; calc address of the character under the cursor 
8ec9				 
8ec9 2a 67 ee			ld hl, (input_start) 
8ecc 3a 55 ee			ld a, (input_cursor) 
8ecf cd db 8c			call addatohl 
8ed2 c9				ret 
8ed3			 
8ed3			input_inschr: 
8ed3				; Insert char at cursor position 
8ed3 f5				push af   ; save char 
8ed4				;call input_lenrem    ; get bc length of remaining string 
8ed4			 
8ed4				 
8ed4 cd c9 8e			call input_curptr 
8ed7			;	ld hl, (input_start) 
8ed7			;	ld a, (input_cursor) 
8ed7			;	call addatohl 
8ed7				;push hl   ; save to come back to 
8ed7			 
8ed7				; shift everything up one to end of buffer 
8ed7			 
8ed7				;push hl 
8ed7				;dec de 
8ed7				;inc de 
8ed7			;	ldir 
8ed7				 
8ed7				;pop hl 
8ed7			 
8ed7				; are we adding to the end of line? 
8ed7			 
8ed7 3a 55 ee			ld a, (input_cursor) 
8eda 47				ld b, a 
8edb 3a 5a ee			ld a, (input_len) 
8ede b8				cp b 
8edf 20 09			jr nz, .insmid   ; no, insert in middle of text 
8ee1			 
8ee1				; tack on the end of the line 
8ee1 f1				pop af 
8ee2 77				ld (hl), a   ; save new char 
8ee3 23				inc hl 
8ee4 3e 00			ld a, 0 
8ee6 77				ld (hl), a 
8ee7 c3 93 8e			jp input_right 
8eea				 
8eea			.insmid: 
8eea				; hl has insertion point so move everything up one to allow for insertion 
8eea				;call input_shiftright 
8eea f1				pop af 
8eeb			 
8eeb			.shufinsmid: 
8eeb 47				ld b, a     ; b contains new char, c prev char at this position  
8eec 7e				ld a, (hl) 
8eed			 
8eed fe 00			cp 0    ; at end of string need to then dump new char and add term 
8eef 28 07			jr z, .endinsmid 
8ef1 4f				ld c, a 
8ef2 78				ld a, b 
8ef3 77				ld (hl), a 
8ef4 23				inc hl 
8ef5 79				ld a, c 
8ef6 18 f3			jr .shufinsmid 
8ef8				 
8ef8			 
8ef8			 
8ef8			 
8ef8			.endinsmid: 
8ef8 78				ld a, b 
8ef9 77				ld (hl), a 
8efa 23				inc hl 
8efb 3e 00			ld a, 0 
8efd 77				ld (hl), a 
8efe			 
8efe			 
8efe			;	ld (hl), a   ; save new char 
8efe			 
8efe c3 93 8e			jp input_right 
8f01			 
8f01			;input_shiftright: 
8f01			;	; shift text right at cursor, hl has shift start 
8f01			;	push hl 
8f01			;	push de 
8f01			;	push bc 
8f01			; 
8f01			; 
8f01			;	; move to end of string past zero term 
8f01			;	ld hl,(input_start) 
8f01			;	ld a, (input_len) 
8f01			;	call addatohl 
8f01			;	inc hl 
8f01			;;	inc hl 
8f01			;;	inc hl 
8f01			;	ld a, 0 
8f01			;	ld (hl), a 
8f01			;;	dec hl 
8f01			;	 
8f01			;;	ld (hl), a 
8f01			;;	dec hl 
8f01			; 
8f01			;	push hl 
8f01			;	pop de 
8f01			;	inc de 
8f01			;	 
8f01			; 
8f01			;;	ld hl,(input_start) 
8f01			;;	ld a, (input_cursor) 
8f01			;;	call addatohl 
8f01			; 
8f01			; 
8f01			;	; calc how many bytes from cursor pos to end of string we need to shift 
8f01			;	call input_lenrem    ; get bc length of remaining string 
8f01			;	;ld a, (input_cursor) 
8f01			;	;ld c, a 
8f01			;	ld a, (input_len) 
8f01			;	cp 2 
8f01			;	jr z, .iskipzero	 
8f01			;	;sub c 
8f01			;	;inc a 
8f01			;	;ld c, a 
8f01			;	;ld b, 0 
8f01			;	inc c 
8f01			;	inc c 
8f01			;	; move data 
8f01			;	lddr 
8f01			;.iskipzero: 
8f01			; 
8f01			;	pop bc 
8f01			;	pop de 
8f01			;	pop hl 
8f01			;	ret	 
8f01			 
8f01			input_delchar: 
8f01				; Delete char at cursor position 
8f01 cd bd 8e			call input_lenrem    ; get bc length of remaining string 
8f04 2a 67 ee			ld hl, (input_start) 
8f07 3a 55 ee			ld a, (input_cursor) 
8f0a cd db 8c			call addatohl 
8f0d			 
8f0d e5				push hl 
8f0e d1				pop de 
8f0f 1b				dec de 
8f10			 
8f10			.dl:	 
8f10 ed a0			ldi  
8f12 7e				ld a, (hl) 
8f13 fe 00			cp 0 
8f15 28 02			jr z, .dldone 
8f17 18 f7			jr .dl 
8f19			.dldone: 
8f19 ed a0			ldi 
8f1b			 
8f1b c3 8c 8e			jp input_left 
8f1e			 
8f1e			 
8f1e			 
8f1e			 
8f1e			 
8f1e			if EDIT_V1 
8f1e			input_str: 
8f1e			else 
8f1e			input_str_old: 
8f1e			endif 
8f1e			 
8f1e 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
8f21 81					add c 
8f22 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8f25 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8f28 79					ld a, c 
8f29 cd db 8c				call addatohl 
8f2c 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8f2f 7a					ld a,d 
8f30 32 66 ee			        ld (input_size), a       ; save length of input area 
8f33 79					ld a, c 
8f34 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8f37 7b					ld a,e 
8f38 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8f3b					 
8f3b					 
8f3b			 
8f3b			;		ld a,(input_ptr) 
8f3b			;		ld (input_under_cursor),a 	; save what is under the cursor 
8f3b			 
8f3b			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8f3b					; init cursor shape if not set by the cin routines 
8f3b 21 c1 eb				ld hl, cursor_shape 
8f3e			if BASE_KEV 
8f3e					ld a, 255 
8f3e			else 
8f3e 3e 23				ld a, '#' 
8f40			endif 
8f40 77					ld (hl), a 
8f41 23					inc hl 
8f42 3e 00				ld a, 0 
8f44 77					ld (hl), a 
8f45			 
8f45 3e 09				ld a, CUR_BLINK_RATE 
8f47 32 60 ee				ld (input_cur_flash), a 
8f4a 3e 01				ld a, 1 
8f4c 32 5f ee				ld (input_cur_onoff),a 
8f4f			 
8f4f			;	if DEBUG_INPUT 
8f4f			;		push af 
8f4f			;		ld a, 'I' 
8f4f			;		ld (debug_mark),a 
8f4f			;		pop af 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			.is1:		; main entry loop 
8f4f			 
8f4f			 
8f4f			 
8f4f					; pause 1ms 
8f4f			 
8f4f 3e 01				ld a, 1 
8f51 cd d6 89				call aDelayInMS 
8f54			 
8f54					; dec flash counter 
8f54 3a 60 ee				ld a, (input_cur_flash) 
8f57 3d					dec a 
8f58 32 60 ee				ld (input_cur_flash), a 
8f5b fe 00				cp 0 
8f5d 20 0d				jr nz, .nochgstate 
8f5f			 
8f5f			 
8f5f					; change state 
8f5f 3a 5f ee				ld a,(input_cur_onoff) 
8f62 ed 44				neg 
8f64 32 5f ee				ld (input_cur_onoff),a 
8f67			 
8f67			 
8f67					; reset on change of state 
8f67 3e 09				ld a, CUR_BLINK_RATE 
8f69 32 60 ee				ld (input_cur_flash), a 
8f6c			 
8f6c			.nochgstate: 
8f6c					 
8f6c					 
8f6c			 
8f6c					; display cursor  
8f6c			 
8f6c			;		ld hl, (input_start) 
8f6c			;		ld a, (input_cursor) 
8f6c			;		call addatohl 
8f6c			 
8f6c					; get char under cursor and replace with cursor 
8f6c 2a 69 ee		ld hl, (input_ptr) 
8f6f			;		ld a, (hl) 
8f6f			;		ld (input_under_cursor),a 
8f6f			;		ld a, '_' 
8f6f			;		ld (hl), a 
8f6f			 
8f6f					; display string 
8f6f			 
8f6f ed 5b 67 ee			ld de, (input_start) 
8f73 3a 64 ee				ld a, (input_at_pos) 
8f76 cd c1 8a				call str_at_display 
8f79			;	        call update_display 
8f79			 
8f79					; find place to put the cursor 
8f79			;		add h 
8f79			;		ld l, display_row_1 
8f79			;		sub l 
8f79			; (input_at_pos) 
8f79					;ld c, a 
8f79			;		ld a, (input_cursor) 
8f79			;		ld l, (input_at_pos) 
8f79			;		;ld b, h 
8f79			;		add l 
8f79			;		ld (input_at_cursor),a 
8f79					;ld l,h 
8f79			 
8f79			;		ld h, 0 
8f79			;		ld l,(input_at_pos) 
8f79			;		ld a, (input_cursor) 
8f79			;		call addatohl 
8f79			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8f79			;		call subafromhl 
8f79			;		ld a,l 
8f79			;		ld (input_at_cursor), a 
8f79			 
8f79				if DEBUG_INPUT 
8f79					ld a, (hardware_diag) 
8f79					cp 0 
8f79					jr z, .skip_input_diag 
8f79			 
8f79					ld a,(input_at_pos) 
8f79					ld hl, LFSRSeed 
8f79					call hexout 
8f79					ld a, (input_cursor) 
8f79					ld hl, LFSRSeed+2 
8f79					call hexout 
8f79					ld a,(input_at_cursor) 
8f79					ld hl, LFSRSeed+4 
8f79					call hexout 
8f79			 
8f79					ld a,(input_cur_onoff) 
8f79					ld hl, LFSRSeed+6 
8f79					call hexout 
8f79			 
8f79					ld a,(input_cur_flash) 
8f79					ld hl, LFSRSeed+8 
8f79					call hexout 
8f79			 
8f79					ld a,(input_len) 
8f79					ld hl, LFSRSeed+10 
8f79					call hexout 
8f79					ld hl, LFSRSeed+12 
8f79					ld a, 0 
8f79					ld (hl),a 
8f79					ld a, display_row_4 
8f79					ld de, LFSRSeed 
8f79					call str_at_display 
8f79					.skip_input_diag: 
8f79				endif 
8f79			 
8f79					; decide on if we are showing the cursor this time round 
8f79			 
8f79 3a 5f ee				ld a, (input_cur_onoff) 
8f7c fe ff				cp 255 
8f7e 28 15				jr z, .skipcur 
8f80			 
8f80			 
8f80 3a 62 ee				ld a,(input_at_cursor) 
8f83 11 c1 eb				ld de, cursor_shape 
8f86 cd c1 8a				call str_at_display 
8f89			 
8f89					; save length of current input string 
8f89 2a 67 ee				ld hl, (input_start) 
8f8c 3e 00				ld a, 0 
8f8e cd 5c 93				call strlent 
8f91 7d					ld a,l 
8f92 32 5a ee				ld (input_len),a 
8f95			 
8f95			.skipcur: 
8f95			 
8f95 cd d1 8a			        call update_display 
8f98					 
8f98			 
8f98			 
8f98					; wait 
8f98				 
8f98					; TODO loop without wait to flash the cursor and char under cursor	 
8f98 cd ed e6				call cin    ; _wait 
8f9b			 
8f9b fe 00				cp 0 
8f9d ca 4f 8f				jp z, .is1 
8fa0			 
8fa0					; get ptr to char to input into 
8fa0			 
8fa0 4f					ld c,a 
8fa1 2a 67 ee				ld hl, (input_start) 
8fa4 3a 55 ee				ld a, (input_cursor) 
8fa7 cd db 8c				call addatohl 
8faa 22 69 ee				ld (input_ptr), hl 
8fad 79					ld a,c 
8fae			 
8fae					; replace char under cursor 
8fae			 
8fae			;		ld hl, (input_ptr) 
8fae			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8fae			;		ld (hl), a 
8fae			 
8fae			;	if DEBUG_INPUT 
8fae			;		push af 
8fae			;		ld a, 'i' 
8fae			;		ld (debug_mark),a 
8fae			;		pop af 
8fae			;		CALLMONITOR 
8fae			;	endif 
8fae fe 0e				cp KEY_HOME 
8fb0 20 0e				jr nz, .iske 
8fb2			 
8fb2 3a 64 ee				ld a, (input_at_pos) 
8fb5 32 62 ee				ld (input_at_cursor),a 
8fb8 3e 00				ld a, 0 
8fba 32 55 ee				ld (input_cursor), a 
8fbd c3 4f 8f				jp .is1 
8fc0					 
8fc0 fe 0f		.iske:		cp KEY_END 
8fc2 20 03				jr nz, .isknw 
8fc4 c3 4f 8f				jp .is1 
8fc7			 
8fc7 fe 06		.isknw:		cp KEY_NEXTWORD 
8fc9 20 1b				jr nz, .iskpw 
8fcb			 
8fcb 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8fce 7e					ld a,(hl)	 
8fcf fe 00				cp 0 
8fd1 ca 4f 8f				jp z, .is1    ; end of string 
8fd4 fe 20				cp ' ' 
8fd6 ca 4f 8f				jp z, .is1    ; end of word 
8fd9 23					inc hl 
8fda 22 69 ee				ld (input_ptr), hl 
8fdd 3a 62 ee				ld a, (input_at_cursor) 
8fe0 3c					inc a 
8fe1 32 62 ee				ld (input_at_cursor), a 
8fe4 18 e5				jr .isknwm 
8fe6			 
8fe6 fe 07		.iskpw:		cp KEY_PREVWORD 
8fe8 20 1b				jr nz, .iskl 
8fea			.iskpwm:	 
8fea 2a 69 ee				ld hl, (input_ptr) 
8fed 7e					ld a,(hl)	 
8fee fe 00				cp 0  
8ff0 ca 4f 8f				jp z, .is1    ; end of string 
8ff3 fe 20				cp ' ' 
8ff5 ca 4f 8f				jp z, .is1    ; end of word 
8ff8 2b					dec hl 
8ff9 22 69 ee				ld (input_ptr), hl 
8ffc 3a 62 ee				ld a, (input_at_cursor) 
8fff 3d					dec a 
9000 32 62 ee				ld (input_at_cursor), a 
9003 18 e5				jr .iskpwm 
9005			 
9005			 
9005 fe 0b		.iskl:		cp KEY_LEFT 
9007 20 27				jr nz, .isk1 
9009			 
9009 3a 55 ee				ld a, (input_cursor) 
900c			 
900c fe 00				cp 0 
900e ca 4f 8f				jp z, .is1 		; at start of line to ignore  
9011			 
9011 3d					dec  a 		; TODO check underflow 
9012 32 55 ee				ld (input_cursor), a 
9015			 
9015 2a 69 ee				ld hl, (input_ptr) 
9018 2b					dec hl 
9019 22 69 ee				ld (input_ptr), hl 
901c					 
901c 3a 62 ee				ld a, (input_at_cursor) 
901f 3d					dec a 
9020 32 62 ee				ld (input_at_cursor), a 
9023			 
9023 3e 01				ld a, 1		; show cursor moving 
9025 32 5f ee				ld (input_cur_onoff),a 
9028 3e 09				ld a, CUR_BLINK_RATE 
902a 32 60 ee				ld (input_cur_flash), a 
902d			 
902d c3 4f 8f				jp .is1 
9030			 
9030 fe 0c		.isk1:		cp KEY_RIGHT 
9032 20 2a				jr nz, .isk2 
9034			 
9034 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
9037 5f					ld e,a 
9038 3a 55 ee				ld a, (input_cursor) 
903b bb					cp e 
903c ca 4f 8f				jp z, .is1		; at the end of string so dont go right 
903f			 
903f 3c					inc  a 		; TODO check overflow 
9040 32 55 ee				ld (input_cursor), a 
9043			 
9043 3a 62 ee				ld a, (input_at_cursor) 
9046 3c					inc a 
9047 32 62 ee				ld (input_at_cursor), a 
904a			 
904a 2a 69 ee				ld hl, (input_ptr) 
904d 23					inc hl 
904e 22 69 ee				ld (input_ptr), hl 
9051			 
9051 3e 01				ld a, 1		; show cursor moving 
9053 32 5f ee				ld (input_cur_onoff),a 
9056 3e 09				ld a, CUR_BLINK_RATE 
9058 32 60 ee				ld (input_cur_flash), a 
905b			 
905b c3 4f 8f				jp .is1 
905e			 
905e fe 05		.isk2:		cp KEY_UP 
9060			 
9060 20 26				jr nz, .isk3 
9062			 
9062					; swap last command with the current on 
9062			 
9062					; move cursor to start of string 
9062 2a 67 ee				ld hl, (input_start) 
9065 22 69 ee				ld (input_ptr), hl 
9068			 
9068 3a 64 ee				ld a, (input_at_pos) 
906b 32 62 ee				ld (input_at_cursor), a 
906e			 
906e 3e 00				ld a, 0 
9070 32 55 ee				ld (input_cursor), a 
9073					 
9073					; swap input and last command buffers 
9073			 
9073 21 e8 e5				ld hl, os_cli_cmd 
9076 11 e7 e6				ld de, os_last_cmd 
9079 06 ff				ld b, 255 
907b 7e			.swap1:		ld a, (hl) 
907c 4f					ld c,a 
907d 1a					ld a, (de) 
907e 77					ld (hl), a 
907f 79					ld a,c 
9080 12					ld (de),a 
9081 23					inc hl 
9082 13					inc de 
9083 10 f6				djnz .swap1 
9085			 
9085			 
9085			 
9085			 
9085			 
9085 c3 4f 8f				jp .is1 
9088			 
9088 fe 08		.isk3:		cp KEY_BS 
908a 20 3c				jr nz, .isk4 
908c			 
908c 3a 55 ee				ld a, (input_cursor) 
908f			 
908f fe 00				cp 0 
9091 ca 4f 8f				jp z, .is1 		; at start of line to ignore  
9094			 
9094 3d					dec  a 		; TODO check underflow 
9095 32 55 ee				ld (input_cursor), a 
9098			 
9098					; hl is source 
9098					; de needs to be source - 1 
9098			 
9098			;		ld a, 0 
9098			;		dec hl 
9098			;		ld (hl), a 
9098			 
9098 2a 69 ee				ld hl, (input_ptr) 
909b 2b					dec hl 
909c 22 69 ee				ld (input_ptr), hl 
909f			 
909f					; shift all data 
909f			 
909f e5					push hl 
90a0 23					inc hl 
90a1 d1					pop de 
90a2 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
90a5 4f					ld c,a 
90a6 06 00				ld b,0 
90a8 ed b0				ldir  
90aa			 
90aa			 
90aa			 
90aa			 
90aa 3a 62 ee				ld a, (input_at_cursor) 
90ad 3d					dec a 
90ae 32 62 ee				ld (input_at_cursor), a 
90b1			 
90b1			 
90b1 3e 01				ld a, 1		; show cursor moving 
90b3 32 5f ee				ld (input_cur_onoff),a 
90b6 3e 09				ld a, CUR_BLINK_RATE 
90b8 32 60 ee				ld (input_cur_flash), a 
90bb			 
90bb					; remove char 
90bb 3a 62 ee				ld a, (input_at_cursor) 
90be 3c					inc a 
90bf 11 49 91				ld de,.iblank 
90c2 cd c1 8a				call str_at_display 
90c5			 
90c5 c3 4f 8f				jp .is1 
90c8			 
90c8 fe 0d		.isk4:		cp KEY_CR 
90ca 28 6c				jr z, .endinput 
90cc			 
90cc					; else add the key press to the end 
90cc			 
90cc 4f					ld c, a			; save key pressed 
90cd			 
90cd 7e					ld a,(hl)		; get what is currently under char 
90ce			 
90ce fe 00				cp 0			; we are at the end of the string 
90d0 20 2f				jr nz, .onchar 
90d2					 
90d2					; add a char to the end of the string 
90d2				 
90d2 71					ld (hl),c 
90d3 23					inc hl 
90d4			;		ld a,' ' 
90d4			;		ld (hl),a 
90d4			;		inc hl 
90d4 3e 00				ld a,0 
90d6 77					ld (hl),a 
90d7 2b					dec hl 
90d8			 
90d8 3a 55 ee				ld a, (input_cursor) 
90db 3c					inc a				; TODO check max string length and scroll  
90dc 32 55 ee				ld (input_cursor), a		; inc cursor pos 
90df							 
90df 3a 62 ee				ld a, (input_at_cursor) 
90e2 3c					inc a 
90e3 32 62 ee				ld (input_at_cursor), a 
90e6			 
90e6 2a 69 ee				ld hl, (input_ptr) 
90e9 23					inc hl 
90ea 22 69 ee				ld (input_ptr), hl 
90ed			 
90ed 2a 69 ee				ld hl, (input_ptr) 
90f0 23					inc hl 
90f1 22 69 ee				ld (input_ptr), hl 
90f4			;	if DEBUG_INPUT 
90f4			;		push af 
90f4			;		ld a, '+' 
90f4			;		ld (debug_mark),a 
90f4			;		pop af 
90f4			;		CALLMONITOR 
90f4			;	endif 
90f4 3e 01				ld a, 1		; show cursor moving 
90f6 32 5f ee				ld (input_cur_onoff),a 
90f9 3e 09				ld a, CUR_BLINK_RATE 
90fb 32 60 ee				ld (input_cur_flash), a 
90fe c3 4f 8f				jp .is1 
9101					 
9101			 
9101			 
9101					; if on a char then insert 
9101			.onchar: 
9101			 
9101					; TODO over flow check: make sure insert does not blow out buffer 
9101			 
9101					; need to do some maths to use lddr 
9101			 
9101 e5					push hl   ; save char pos 
9102 c5					push bc 
9103			 
9103 2a 67 ee				ld hl, (input_start) 
9106 3a 5a ee				ld a, (input_len) 
9109 cd db 8c				call addatohl  		; end of string 
910c 23					inc hl 
910d 23					inc hl		; past zero term 
910e e5					push hl 
910f 23					inc hl 
9110 e5					push hl  
9111			 
9111								; start and end of lddr set, now how much to move? 
9111			 
9111							 
9111 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
9114 47					ld b,a 
9115 3a 5a ee				ld a,(input_len) 
9118 5f					ld e,a 
9119 90					sub b 
911a 3c					inc a		;?? 
911b 3c					inc a		;?? 
911c 3c					inc a		;?? 
911d			 
911d 06 00				ld b,0 
911f 4f					ld c,a 
9120			 
9120				if DEBUG_INPUT 
9120					push af 
9120					ld a, 'i' 
9120					ld (debug_mark),a 
9120					pop af 
9120			;		CALLMONITOR 
9120				endif 
9120 d1					pop de 
9121 e1					pop hl 
9122				if DEBUG_INPUT 
9122					push af 
9122					ld a, 'I' 
9122					ld (debug_mark),a 
9122					pop af 
9122			;		CALLMONITOR 
9122				endif 
9122 ed b8				lddr 
9124				 
9124			 
9124			 
9124					; TODO have a key for insert/overwrite mode???? 
9124 c1					pop bc 
9125 e1					pop hl 
9126 71					ld (hl), c		; otherwise overwrite current char 
9127					 
9127			 
9127			 
9127			 
9127 3a 55 ee				ld a, (input_cursor) 
912a 3c					inc  a 		; TODO check overflow 
912b 32 55 ee				ld (input_cursor), a 
912e			 
912e 3a 62 ee				ld a, (input_at_cursor) 
9131 3c					inc a 
9132 32 62 ee				ld (input_at_cursor), a 
9135			 
9135 c3 4f 8f				jp .is1 
9138			 
9138			.endinput:	; TODO look for end of string 
9138			 
9138					; add trailing space for end of token 
9138			 
9138 2a 67 ee				ld hl, (input_start) 
913b 3a 5a ee				ld a,(input_len) 
913e cd db 8c				call addatohl 
9141 3e 20				ld a, ' ' 
9143 77					ld (hl),a 
9144					; TODO eof of parse marker 
9144			 
9144 23					inc hl 
9145 3e 00				ld a, 0 
9147 77					ld (hl),a 
9148			 
9148			 
9148 c9					ret 
9149			 
9149 .. 00		.iblank: db " ",0 
914b			 
914b			 
914b 32 64 ee		input_str_prev:	ld (input_at_pos), a 
914e 22 67 ee				ld (input_start), hl 
9151 3e 01				ld a,1			; add cursor 
9153 77					ld (hl),a 
9154 23					inc hl 
9155 3e 00				ld a,0 
9157 77					ld (hl),a 
9158 22 69 ee				ld (input_ptr), hl 
915b 7a					ld a,d 
915c 32 66 ee				ld (input_size), a 
915f 3e 00				ld a,0 
9161 32 55 ee				ld (input_cursor),a 
9164			.instr1:	 
9164			 
9164					; TODO do block cursor 
9164					; TODO switch cursor depending on the modifer key 
9164			 
9164					; update cursor shape change on key hold 
9164			 
9164 2a 69 ee				ld hl, (input_ptr) 
9167 2b					dec hl 
9168 3a c1 eb				ld a,(cursor_shape) 
916b 77					ld (hl), a 
916c			 
916c					; display entered text 
916c 3a 64 ee				ld a,(input_at_pos) 
916f cd 4b e6		            	CALL fLCD_Pos       ;Position cursor to location in A 
9172 ed 5b 67 ee	            	LD   de, (input_start) 
9176 cd 45 e6		            	CALL fLCD_Str       ;Display string pointed to by DE 
9179			 
9179 cd ed e6				call cin 
917c fe 00				cp 0 
917e 28 e4				jr z, .instr1 
9180			 
9180					; proecess keyboard controls first 
9180			 
9180 2a 69 ee				ld hl,(input_ptr) 
9183			 
9183 fe 0d				cp KEY_CR	 ; pressing enter ends input 
9185 28 5a				jr z, .instrcr 
9187			 
9187 fe 08				cp KEY_BS 	; back space 
9189 20 0f				jr nz, .instr2 
918b					; process back space 
918b			 
918b					; TODO stop back space if at start of string 
918b 2b					dec hl 
918c 2b					dec hl ; to over write cursor 
918d 3a c1 eb				ld a,(cursor_shape) 
9190					;ld a,0 
9190 77					ld (hl),a 
9191 23					inc hl 
9192 3e 20				ld a," " 
9194 77					ld (hl),a 
9195 22 69 ee				ld (input_ptr),hl 
9198					 
9198			 
9198 18 ca				jr .instr1 
919a			 
919a fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
919c 20 06				jr nz, .instr3 
919e 2b					dec hl 
919f 22 69 ee				ld (input_ptr),hl 
91a2 18 c0				jr .instr1 
91a4				 
91a4 fe 0c		.instr3:	cp KEY_RIGHT      ; cursor right 
91a6 20 06				jr nz, .instr4 
91a8 23					inc hl 
91a9 22 69 ee				ld (input_ptr),hl 
91ac 18 b6				jr .instr1 
91ae			 
91ae fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
91b0 20 06				jr nz, .instr5 
91b2 2b					dec hl 
91b3 22 69 ee				ld (input_ptr),hl 
91b6 18 ac				jr .instr1 
91b8			 
91b8 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
91ba 20 06				jr nz, .instr6 
91bc 2b					dec hl 
91bd 22 69 ee				ld (input_ptr),hl 
91c0 18 a2				jr .instr1 
91c2 fe 05		.instr6:        cp KEY_UP      ; recall last command 
91c4 20 0b				jr nz, .instrnew 
91c6			 
91c6 21 c1 e2			ld hl, scratch 
91c9 11 e7 e6			ld de, os_last_cmd 
91cc cd ea 91			call strcpy 
91cf 18 93				jr .instr1 
91d1			 
91d1			 
91d1			.instrnew:	; no special key pressed to see if we have room to store it 
91d1			 
91d1					; TODO do string size test 
91d1			 
91d1 2b					dec hl ; to over write cursor 
91d2 77					ld (hl),a 
91d3 23					inc hl 
91d4 3a c1 eb				ld a,(cursor_shape) 
91d7 77					ld (hl),a 
91d8 23					inc hl 
91d9 3e 00				ld a,0 
91db 77					ld (hl),a 
91dc			 
91dc 22 69 ee				ld (input_ptr),hl 
91df					 
91df 18 83				jr .instr1 
91e1 2b			.instrcr:	dec hl		; remove cursor 
91e2 3e 20				ld a,' '	; TODO add a trailing space for safety 
91e4 77					ld (hl),a 
91e5 23					inc hl 
91e6 3e 00				ld a,0 
91e8 77					ld (hl),a 
91e9			 
91e9			 
91e9					; if at end of line scroll up    
91e9					; TODO detecting only end of line 4 for scroll up  
91e9			 
91e9					;ld   
91e9			 
91e9 c9					ret 
91ea			 
91ea			 
91ea			; strcpy hl = dest, de source 
91ea			 
91ea 1a			strcpy:   LD   A, (DE)        ;Get character from string 
91eb b7			            OR   A              ;Null terminator? 
91ec c8			            RET  Z              ;Yes, so finished 
91ed 1a					ld a,(de) 
91ee 77					ld (hl),a 
91ef 13			            INC  DE             ;Point to next character 
91f0 23					inc hl 
91f1 18 f7		            JR   strcpy       ;Repeat 
91f3 c9					ret 
91f4			 
91f4			 
91f4			; TODO string_at  
91f4			; pass string which starts with lcd offset address and then null term string 
91f4			 
91f4			; TODO string to dec 
91f4			; TODO string to hex 
91f4			; TODO byte to string hex 
91f4			; TODO byte to string dec 
91f4			 
91f4			 
91f4			 
91f4			; from z80uartmonitor 
91f4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
91f4			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
91f4			; pass hl for where to put the text 
91f4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
91f4 c5			hexout:	PUSH BC 
91f5 f5					PUSH AF 
91f6 47					LD B, A 
91f7					; Upper nybble 
91f7 cb 3f				SRL A 
91f9 cb 3f				SRL A 
91fb cb 3f				SRL A 
91fd cb 3f				SRL A 
91ff cd 0f 92				CALL tohex 
9202 77					ld (hl),a 
9203 23					inc hl	 
9204					 
9204					; Lower nybble 
9204 78					LD A, B 
9205 e6 0f				AND 0FH 
9207 cd 0f 92				CALL tohex 
920a 77					ld (hl),a 
920b 23					inc hl	 
920c					 
920c f1					POP AF 
920d c1					POP BC 
920e c9					RET 
920f					 
920f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
920f			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
920f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
920f			tohex: 
920f e5					PUSH HL 
9210 d5					PUSH DE 
9211 16 00				LD D, 0 
9213 5f					LD E, A 
9214 21 1c 92				LD HL, .DATA 
9217 19					ADD HL, DE 
9218 7e					LD A, (HL) 
9219 d1					POP DE 
921a e1					POP HL 
921b c9					RET 
921c			 
921c			.DATA: 
921c 30					DEFB	30h	; 0 
921d 31					DEFB	31h	; 1 
921e 32					DEFB	32h	; 2 
921f 33					DEFB	33h	; 3 
9220 34					DEFB	34h	; 4 
9221 35					DEFB	35h	; 5 
9222 36					DEFB	36h	; 6 
9223 37					DEFB	37h	; 7 
9224 38					DEFB	38h	; 8 
9225 39					DEFB	39h	; 9 
9226 41					DEFB	41h	; A 
9227 42					DEFB	42h	; B 
9228 43					DEFB	43h	; C 
9229 44					DEFB	44h	; D 
922a 45					DEFB	45h	; E 
922b 46					DEFB	46h	; F 
922c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
922c			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
922c			;;    subtract $30, if result > 9 then subtract $7 more 
922c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
922c			atohex: 
922c d6 30				SUB $30 
922e fe 0a				CP 10 
9230 f8					RET M		; If result negative it was 0-9 so we're done 
9231 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
9233 c9					RET		 
9234			 
9234			 
9234			 
9234			 
9234			; Get 2 ASCII characters as hex byte from pointer in hl 
9234			 
9234			BYTERD: 
9234 16 00			LD	D,00h		;Set up 
9236 cd 3e 92			CALL	HEXCON		;Get byte and convert to hex 
9239 87				ADD	A,A		;First nibble so 
923a 87				ADD	A,A		;multiply by 16 
923b 87				ADD	A,A		; 
923c 87				ADD	A,A		; 
923d 57				LD	D,A		;Save hi nibble in D 
923e			HEXCON: 
923e 7e				ld a, (hl)		;Get next chr 
923f 23				inc hl 
9240 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
9242 fe 0a			CP	00Ah		;Is it 0-9 ? 
9244 38 02			JR	C,NALPHA	;If so miss next bit 
9246 d6 07			SUB	007h		;Else convert alpha 
9248			NALPHA: 
9248 b2				OR	D		;Add hi nibble back 
9249 c9				RET			; 
924a			 
924a			 
924a			; 
924a			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
924a			; Since the routines get_byte and therefore get_nibble are called, only valid 
924a			; characters (0-9a-f) are accepted. 
924a			; 
924a			;get_word        push    af 
924a			;                call    get_byte        ; Get the upper byte 
924a			;                ld      h, a 
924a			;                call    get_byte        ; Get the lower byte 
924a			;                ld      l, a 
924a			;                pop     af 
924a			;                ret 
924a			; 
924a			; Get a byte in hexadecimal notation. The result is returned in A. Since 
924a			; the routine get_nibble is used only valid characters are accepted - the  
924a			; input routine only accepts characters 0-9a-f. 
924a			; 
924a c5			get_byte:        push    bc              ; Save contents of B (and C) 
924b 7e					ld a,(hl) 
924c 23					inc hl 
924d cd 72 92		                call    nibble2val      ; Get upper nibble 
9250 cb 07		                rlc     a 
9252 cb 07		                rlc     a 
9254 cb 07		                rlc     a 
9256 cb 07		                rlc     a 
9258 47			                ld      b, a            ; Save upper four bits 
9259 7e					ld a,(hl) 
925a cd 72 92		                call    nibble2val      ; Get lower nibble 
925d b0			                or      b               ; Combine both nibbles 
925e c1			                pop     bc              ; Restore B (and C) 
925f c9			                ret 
9260			; 
9260			; Get a hexadecimal digit from the serial line. This routine blocks until 
9260			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9260			; to the serial line interface. The lower 4 bits of A contain the value of  
9260			; that particular digit. 
9260			; 
9260			;get_nibble      ld a,(hl)           ; Read a character 
9260			;                call    to_upper        ; Convert to upper case 
9260			;                call    is_hex          ; Was it a hex digit? 
9260			;                jr      nc, get_nibble  ; No, get another character 
9260			 ;               call    nibble2val      ; Convert nibble to value 
9260			 ;               call    print_nibble 
9260			 ;               ret 
9260			; 
9260			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9260			; A valid hexadecimal digit is denoted by a set C flag. 
9260			; 
9260			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9260			;                ret     nc              ; Yes 
9260			;                cp      '0'             ; Less than '0'? 
9260			;                jr      nc, is_hex_1    ; No, continue 
9260			;                ccf                     ; Complement carry (i.e. clear it) 
9260			;                ret 
9260			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9260			;                ret     c               ; Yes 
9260			;                cp      'A'             ; Less than 'A'? 
9260			;                jr      nc, is_hex_2    ; No, continue 
9260			;                ccf                     ; Yes - clear carry and return 
9260			;                ret 
9260			;is_hex_2        scf                     ; Set carry 
9260			;                ret 
9260			; 
9260			; Convert a single character contained in A to upper case: 
9260			; 
9260 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
9262 d8			                ret     c 
9263 fe 7b		                cp      'z' + 1         ; > 'z'? 
9265 d0			                ret     nc              ; Nothing to do, either 
9266 e6 5f		                and     $5f             ; Convert to upper case 
9268 c9			                ret 
9269			 
9269			 
9269			to_lower: 
9269			 
9269			   ; if char is in [A-Z] make it lower case 
9269			 
9269			   ; enter : a = char 
9269			   ; exit  : a = lower case char 
9269			   ; uses  : af 
9269			 
9269 fe 41		   cp 'A' 
926b d8			   ret c 
926c			    
926c fe 5b		   cp 'Z'+1 
926e d0			   ret nc 
926f			    
926f f6 20		   or $20 
9271 c9			   ret 
9272			 
9272			; 
9272			; Expects a hexadecimal digit (upper case!) in A and returns the 
9272			; corresponding value in A. 
9272			; 
9272 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
9274 38 02		                jr      c, nibble2val_1 ; Yes 
9276 d6 07		                sub     7               ; Adjust for A-F 
9278 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
927a e6 0f		                and     $f              ; Only return lower 4 bits 
927c c9			                ret 
927d			; 
927d			; Print_nibble prints a single hex nibble which is contained in the lower  
927d			; four bits of A: 
927d			; 
927d			;print_nibble    push    af              ; We won't destroy the contents of A 
927d			;                and     $f              ; Just in case... 
927d			;                add     a, '0'             ; If we have a digit we are done here. 
927d			;                cp      '9' + 1         ; Is the result > 9? 
927d			;                jr      c, print_nibble_1 
927d			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
927d			;print_nibble_1  call    putc            ; Print the nibble and 
927d			;                pop     af              ; restore the original value of A 
927d			;                ret 
927d			;; 
927d			;; Send a CR/LF pair: 
927d			; 
927d			;crlf            push    af 
927d			;                ld      a, cr 
927d			;                call    putc 
927d			;                ld      a, lf 
927d			;                call    putc 
927d			;                pop     af 
927d			;                ret 
927d			; 
927d			; Print_word prints the four hex digits of a word to the serial line. The  
927d			; word is expected to be in HL. 
927d			; 
927d			;print_word      push    hl 
927d			;                push    af 
927d			;                ld      a, h 
927d			;                call    print_byte 
927d			;                ld      a, l 
927d			;                call    print_byte 
927d			;                pop     af 
927d			;                pop     hl 
927d			;                ret 
927d			; 
927d			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
927d			; The byte to be printed is expected to be in A. 
927d			; 
927d			;print_byte      push    af              ; Save the contents of the registers 
927d			;                push    bc 
927d			;                ld      b, a 
927d			;                rrca 
927d			;                rrca 
927d			;                rrca 
927d			;                rrca 
927d			;                call    print_nibble    ; Print high nibble 
927d			;                ld      a, b 
927d			;                call    print_nibble    ; Print low nibble 
927d			;                pop     bc              ; Restore original register contents 
927d			;                pop     af 
927d			;                ret 
927d			 
927d			 
927d			 
927d			 
927d			 
927d			fourehexhl:  
927d 7e				ld a,(hl) 
927e cd 2c 92			call atohex 
9281 cb 3f				SRL A 
9283 cb 3f				SRL A 
9285 cb 3f				SRL A 
9287 cb 3f				SRL A 
9289 47				ld b, a 
928a 23				inc hl 
928b 7e				ld a,(hl) 
928c 23				inc hl 
928d cd 2c 92			call atohex 
9290 80				add b 
9291 57				ld d,a 
9292 7e				ld a,(hl) 
9293 cd 2c 92			call atohex 
9296 cb 3f				SRL A 
9298 cb 3f				SRL A 
929a cb 3f				SRL A 
929c cb 3f				SRL A 
929e 47				ld b, a 
929f 23				inc hl 
92a0 7e				ld a,(hl) 
92a1 23				inc hl 
92a2 cd 2c 92			call atohex 
92a5 80				add b 
92a6 5f				ld e, a 
92a7 d5				push de 
92a8 e1				pop hl 
92a9 c9				ret 
92aa			 
92aa			; pass hl. returns z set if the byte at hl is a digit 
92aa			;isdigithl:  
92aa			;	push bc 
92aa			;	ld a,(hl) 
92aa			;	cp ':' 
92aa			;	jr nc, .isdf 		; > 
92aa			;	cp '0' 
92aa			;	jr c, .isdf		; < 
92aa			; 
92aa			;	; TODO find a better way to set z 
92aa			; 
92aa			;	ld b,a 
92aa			;	cp b 
92aa			;	pop bc 
92aa			;	ret 
92aa			; 
92aa			;.isdf:	; not digit so clear z 
92aa			; 
92aa			;	; TODO find a better way to unset z 
92aa			; 
92aa			;	ld b,a 
92aa			;	inc b 
92aa			;	cp b 
92aa			; 
92aa			;	pop bc 
92aa			;	ret 
92aa				 
92aa				 
92aa			 
92aa			 
92aa			; pass hl as the four byte address to load 
92aa			 
92aa			get_word_hl:  
92aa e5				push hl 
92ab cd 4a 92			call get_byte 
92ae				 
92ae 47				ld b, a 
92af			 
92af e1				pop hl 
92b0 23				inc hl 
92b1 23				inc hl 
92b2			 
92b2			; TODO not able to handle a-f  
92b2 7e				ld a,(hl) 
92b3			;	;cp ':' 
92b3			;	cp 'g' 
92b3			;	jr nc, .single_byte_hl 		; > 
92b3			;	cp 'G' 
92b3			;	jr nc, .single_byte_hl 		; > 
92b3			;	cp '0' 
92b3			;	jr c, .single_byte_hl		; < 
92b3			 
92b3				;call isdigithl 
92b3 fe 00			cp 0 
92b5 28 06			jr z, .single_byte_hl 
92b7			 
92b7			.getwhln:   ; hex word so get next byte 
92b7			 
92b7 cd 4a 92			call get_byte 
92ba 6f				ld l, a 
92bb 60				ld h,b 
92bc c9				ret 
92bd 68			.single_byte_hl:   ld l,b 
92be 26 00				ld h,0 
92c0 c9					ret 
92c1			 
92c1			 
92c1			 
92c1			 
92c1 21 4e 9a			ld hl,asc+1 
92c4			;	ld a, (hl) 
92c4			;	call nibble2val 
92c4 cd 4a 92			call get_byte 
92c7			 
92c7			;	call fourehexhl 
92c7 32 f5 e2			ld (scratch+52),a 
92ca				 
92ca 21 f3 e2			ld hl,scratch+50 
92cd 22 e4 e5			ld (os_cur_ptr),hl 
92d0			 
92d0 c9				ret 
92d1			 
92d1			 
92d1			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
92d1			 
92d1			; Decimal Unsigned Version 
92d1			 
92d1			;Number in a to decimal ASCII 
92d1			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
92d1			;Example: display a=56 as "056" 
92d1			;input: a = number 
92d1			;Output: a=0,value of a in the screen 
92d1			;destroys af,bc (don't know about hl and de) 
92d1			DispAToASCII: 
92d1 0e 9c			ld	c,-100 
92d3 cd dd 92			call	.Na1 
92d6 0e f6			ld	c,-10 
92d8 cd dd 92			call	.Na1 
92db 0e ff			ld	c,-1 
92dd 06 2f		.Na1:	ld	b,'0'-1 
92df 04			.Na2:	inc	b 
92e0 81				add	a,c 
92e1 38 fc			jr	c,.Na2 
92e3 91				sub	c		;works as add 100/10/1 
92e4 f5				push af		;safer than ld c,a 
92e5 78				ld	a,b		;char is in b 
92e6			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
92e6 f1				pop af		;safer than ld a,c 
92e7 c9				ret 
92e8			 
92e8			; Decimal Signed Version 
92e8			 
92e8			; DispA 
92e8			; -------------------------------------------------------------- 
92e8			; Converts a signed integer value to a zero-terminated ASCII 
92e8			; string representative of that value (using radix 10). 
92e8			; -------------------------------------------------------------- 
92e8			; INPUTS: 
92e8			;     HL     Value to convert (two's complement integer). 
92e8			;     DE     Base address of string destination. (pointer). 
92e8			; -------------------------------------------------------------- 
92e8			; OUTPUTS: 
92e8			;     None 
92e8			; -------------------------------------------------------------- 
92e8			; REGISTERS/MEMORY DESTROYED 
92e8			; AF HL 
92e8			; -------------------------------------------------------------- 
92e8			 
92e8			;DispHLToASCII: 
92e8			;   push    de 
92e8			;   push    bc 
92e8			; 
92e8			;; Detect sign of HL. 
92e8			;    bit    7, h 
92e8			;    jr     z, ._DoConvert 
92e8			; 
92e8			;; HL is negative. Output '-' to string and negate HL. 
92e8			;    ld     a, '-' 
92e8			;    ld     (de), a 
92e8			;    inc    de 
92e8			; 
92e8			;; Negate HL (using two's complement) 
92e8			;    xor    a 
92e8			;    sub    l 
92e8			;    ld     l, a 
92e8			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
92e8			;    sbc    a, h 
92e8			;    ld     h, a 
92e8			; 
92e8			;; Convert HL to digit characters 
92e8			;._DoConvert: 
92e8			;    ld     b, 0     ; B will count character length of number 
92e8			;-   ld     a, 10 
92e8			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
92e8			;    push   af 
92e8			;    inc    b 
92e8			;    ld     a, h 
92e8			;    or     l 
92e8			;    jr     nz, - 
92e8			; 
92e8			;; Retrieve digits from stack 
92e8			;-   pop    af 
92e8			;    or     $30 
92e8			;    ld     (de), a 
92e8			;    inc    de 
92e8			;    djnz   - 
92e8			; 
92e8			;; Terminate string with NULL 
92e8			;    xor    a 
92e8			;    ld     (de), a 
92e8			; 
92e8			;    pop    bc 
92e8			;    pop    de 
92e8			;    ret 
92e8			 
92e8			;Comments 
92e8			; 
92e8			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
92e8			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
92e8			;    Note that the output string will not be fixed-width. 
92e8			; 
92e8			;Example Usage 
92e8			; 
92e8			;    ld    hl, -1004 
92e8			;    ld    de, OP1 
92e8			;    call  DispA 
92e8			;    ld    hl, OP1 
92e8			;    syscall  PutS 
92e8			 
92e8			 
92e8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
92e8			 
92e8			 
92e8			;Converts an ASCII string to an unsigned 16-bit integer 
92e8			;Quits when it reaches a non-decimal digit 
92e8			 
92e8			string_to_uint16: 
92e8			atoui_16: 
92e8			;Input: 
92e8			;     DE points to the string 
92e8			;Outputs: 
92e8			;     HL is the result 
92e8			;     A is the 8-bit value of the number 
92e8			;     DE points to the byte after the number 
92e8			;Destroys: 
92e8			;     BC 
92e8			;       if the string is non-empty, BC is HL/10 
92e8			;Size:  24 bytes 
92e8			;Speed: 42+d(104+{0,9}) 
92e8			;       d is the number of digits in the number 
92e8			;       max is 640 cycles for a 5 digit number 
92e8			;Assuming no leading zeros: 
92e8			;1 digit:  146cc 
92e8			;2 digit:  250cc 
92e8			;3 digit:  354cc or 363cc (avg: 354.126cc) 
92e8			;4 digit:  458cc or 467cc (avg: 458.27cc) 
92e8			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
92e8			;avg: 544.81158447265625cc (544+13297/16384) 
92e8			;=============================================================== 
92e8 21 00 00		  ld hl,0 
92eb			.u16a: 
92eb 1a			  ld a,(de) 
92ec d6 30		  sub 30h 
92ee fe 0a		  cp 10 
92f0 d0			  ret nc 
92f1 13			  inc de 
92f2 44			  ld b,h 
92f3 4d			  ld c,l 
92f4 29			  add hl,hl 
92f5 29			  add hl,hl 
92f6 09			  add hl,bc 
92f7 29			  add hl,hl 
92f8 85			  add a,l 
92f9 6f			  ld l,a 
92fa 30 ef		  jr nc,.u16a 
92fc 24			  inc h 
92fd c3 eb 92		  jp .u16a 
9300			 
9300			 
9300			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9300			 
9300			;written by Zeda 
9300			;Converts a 16-bit unsigned integer to an ASCII string. 
9300			 
9300			uitoa_16: 
9300			;Input: 
9300			;   DE is the number to convert 
9300			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
9300			;Output: 
9300			;   HL points to the null-terminated ASCII string 
9300			;      NOTE: This isn't necessarily the same as the input HL. 
9300 d5			  push de 
9301 c5			  push bc 
9302 f5			  push af 
9303 eb			  ex de,hl 
9304			 
9304 01 f0 d8		  ld bc,-10000 
9307 3e 2f		  ld a,'0'-1 
9309 3c			  inc a 
930a 09			  add hl,bc  
930b 38 fc		   jr c,$-2 
930d 12			  ld (de),a 
930e 13			  inc de 
930f			 
930f 01 e8 03		  ld bc,1000 
9312 3e 3a		  ld a,'9'+1 
9314 3d			  dec a  
9315 09			  add hl,bc  
9316 30 fc		   jr nc,$-2 
9318 12			  ld (de),a 
9319 13			  inc de 
931a			 
931a 01 9c ff		  ld bc,-100 
931d 3e 2f		  ld a,'0'-1 
931f 3c			  inc a  
9320 09			  add hl,bc  
9321 38 fc		   jr c,$-2 
9323 12			  ld (de),a 
9324 13			  inc de 
9325			 
9325 7d			  ld a,l 
9326 26 3a		  ld h,'9'+1 
9328 25			  dec h  
9329 c6 0a		  add a,10  
932b 30 fb		   jr nc,$-3 
932d c6 30		  add a,'0' 
932f eb			  ex de,hl 
9330 72			  ld (hl),d 
9331 23			  inc hl 
9332 77			  ld (hl),a 
9333 23			  inc hl 
9334 36 00		  ld (hl),0 
9336			 
9336			;Now strip the leading zeros 
9336 0e fa		  ld c,-6 
9338 09			  add hl,bc 
9339 3e 30		  ld a,'0' 
933b 23			  inc hl  
933c be			  cp (hl)  
933d 28 fc		  jr z,$-2 
933f			 
933f			;Make sure that the string is non-empty! 
933f 7e			  ld a,(hl) 
9340 b7			  or a 
9341 20 01		  jr nz,.atoub 
9343 2b			  dec hl 
9344			.atoub: 
9344			 
9344 f1			  pop af 
9345 c1			  pop bc 
9346 d1			  pop de 
9347 c9			  ret 
9348			 
9348			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9348			 
9348			toUpper: 
9348			;A is the char. 
9348			;If A is a lowercase letter, this sets it to the matching uppercase 
9348			;18cc or 30cc or 41cc 
9348			;avg: 26.75cc 
9348 fe 61		  cp 'a' 
934a d8			  ret c 
934b fe 7b		  cp 'z'+1 
934d d0			  ret nc 
934e d6 20		  sub 'a'-'A' 
9350 c9			  ret 
9351			 
9351			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9351			 
9351			; String Length 
9351			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9351			 
9351			; Get the length of the null-terminated string starting at $8000 hl 
9351			;    LD     HL, $8000 
9351			 
9351			strlenz: 
9351			 
9351 af			    XOR    A               ; Zero is the value we are looking for. 
9352 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9353 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9354			                           ; 65, 536 bytes (the entire addressable memory space). 
9354 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9356			 
9356			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9356 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9357 6f			    LD     L, A             ; number of bytes 
9358 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
935a 2b			    DEC    HL              ; Compensate for null. 
935b c9				ret 
935c			 
935c			; Get the length of the A terminated string starting at $8000 hl 
935c			;    LD     HL, $8000 
935c			 
935c			strlent: 
935c			 
935c			                  ; A is the value we are looking for. 
935c 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
935e 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9360			                           ; 65, 536 bytes (the entire addressable memory space). 
9360 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9362			 
9362			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9362 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9364 2e 00		    LD     L, 0             ; number of bytes 
9366 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9368 2b			    DEC    HL              ; Compensate for null. 
9369 c9				ret 
936a			 
936a			 
936a			;Comparing Strings 
936a			 
936a			;IN    HL     Address of string1. 
936a			;      DE     Address of string2. 
936a			 
936a			; doc given but wrong??? 
936a			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
936a			;      carry  Set if string1 > string2, reset if string1 <= string2. 
936a			; tested 
936a			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
936a			 
936a			strcmp_old: 
936a e5			    PUSH   HL 
936b d5			    PUSH   DE 
936c			 
936c 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
936d be			    CP     (HL)            ; (want to minimize work). 
936e 38 01		    JR     C, Str1IsBigger 
9370 7e			    LD     A, (HL) 
9371			 
9371			Str1IsBigger: 
9371 4f			    LD     C, A             ; Put length in BC 
9372 06 00		    LD     B, 0 
9374 13			    INC    DE              ; Increment pointers to meat of string. 
9375 23			    INC    HL 
9376			 
9376			CmpLoop: 
9376 1a			    LD     A, (DE)          ; Compare bytes. 
9377 ed a1		    CPI 
9379 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
937b 13			    INC    DE              ; Update pointer. 
937c ea 76 93		    JP     PE, CmpLoop 
937f			 
937f d1			    POP    DE 
9380 e1			    POP    HL 
9381 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
9382 be			    CP     (HL) 
9383 c9			    RET 
9384			 
9384			NoMatch: 
9384 2b			    DEC    HL 
9385 be			    CP     (HL)            ; Compare again to affect carry. 
9386 d1			    POP    DE 
9387 e1			    POP    HL 
9388 c9			    RET 
9389			 
9389			;; test strmp 
9389			; 
9389			;ld de, .str1 
9389			;ld hl, .str2 
9389			;call strcmp 
9389			;jr z, .z1 
9389			;;this 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "NZ1" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			;.z1: 
9389			; 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "ZZ1" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			; 
9389			;ld de, .str1 
9389			;ld hl, .str1 
9389			;call strcmp 
9389			;jr z, .z2 
9389			;;this 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "NZ2" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			;.z2: 
9389			; 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "ZZ2" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			; 
9389			;ld de, .str1 
9389			;ld hl, .str2 
9389			;call strcmp 
9389			;jr c, .c1 
9389			; 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "Nc1" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			;.c1: 
9389			;;this 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "cc1" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			; 
9389			;ld de, .str1 
9389			;ld hl, .str1 
9389			;call strcmp 
9389			;jr c, .c2 
9389			;;this 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "Nc2" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			;.c2: 
9389			; 
9389			;	if DEBUG_FORTH_WORDS 
9389			;		DMARK "cc2" 
9389			;		CALLMONITOR 
9389			;	endif 
9389			;	NEXTW 
9389			;.str1:   db "string1",0 
9389			;.str2:   db "string2",0 
9389			 
9389			; only care about direct match or not 
9389			; hl and de strings 
9389			; zero set if the same 
9389			 
9389			strcmp: 
9389 1a				ld a, (de) 
938a be				cp (hl) 
938b 28 02			jr z, .ssame 
938d b7				or a 
938e c9				ret 
938f			 
938f			.ssame:  
938f fe 00			cp 0 
9391 c8				ret z 
9392			 
9392 23				inc hl 
9393 13				inc de 
9394 18 f3			jr strcmp 
9396				 
9396				 
9396			 
9396			;Copyright (c) 2014, Luke Maurits 
9396			;All rights reserved. 
9396			; 
9396			;Redistribution and use in source and binary forms, with or without 
9396			;modification, are permitted provided that the following conditions are met: 
9396			; 
9396			;* Redistributions of source code must retain the above copyright notice, this 
9396			;  list of conditions and the following disclaimer. 
9396			; 
9396			;* Redistributions in binary form must reproduce the above copyright notice, 
9396			;  this list of conditions and the following disclaimer in the documentation 
9396			;  and/or other materials provided with the distribution. 
9396			; 
9396			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9396			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9396			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9396			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9396			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9396			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9396			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9396			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9396			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9396			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9396			 
9396			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9396			 
9396			StrictStrCmp: 
9396				; Load next chars of each string 
9396 1a				ld a, (de) 
9397 47				ld b, a 
9398 7e				ld a, (hl) 
9399				; Compare 
9399 b8				cp b 
939a				; Return non-zero if chars don't match 
939a c0				ret nz 
939b				; Check for end of both strings 
939b fe 00			cp "\0" 
939d				; Return if strings have ended 
939d c8				ret z 
939e				; Otherwise, advance to next chars 
939e 23				inc hl 
939f 13				inc de 
93a0 18 f4			jr StrictStrCmp 
93a2			 
93a2			;end 
93a2			; eof 
93a2			 
93a2			 
93a2			 
93a2			 
93a2			 
93a2			 
# End of file firmware_strings.asm
93a2			include "firmware_memory.asm"   ; malloc and free  
93a2			 
93a2			if DEBUG_FORTH_MALLOC_HIGH 
93a2			.mallocsize: db "Wants malloc >256",0 
93a2			.mallocasize: db "MALLOC gives >256",0 
93a2			.malloczero: db "MALLOC gives zero",0 
93a2			 
93a2			malloc_guard_zerolen: 
93a2				push hl 
93a2				push de 
93a2				push af 
93a2			 
93a2				ld de, 0 
93a2			        call cmp16 
93a2				jr nz, .lowalloz 
93a2			 
93a2				push hl 
93a2				push de 
93a2					ld hl, display_fb0 
93a2					ld (display_fb_active), hl 
93a2				call clear_display 
93a2				ld a, 0 
93a2				ld de, .malloczero 
93a2				call str_at_display 
93a2				call update_display 
93a2				call delay1s 
93a2				call delay1s 
93a2				call bp_on 
93a2			;	ld a, 0 
93a2			;	ld (os_view_disable), a 
93a2			 
93a2				pop de 
93a2				pop hl 
93a2			 
93a2				 
93a2			 
93a2				CALLMONITOR 
93a2			.lowalloz: 
93a2			 
93a2			 
93a2				pop af 
93a2				pop de 
93a2				pop hl 
93a2			ret 
93a2			 
93a2			malloc_guard_entry: 
93a2				push hl 
93a2				push de 
93a2				push af 
93a2			 
93a2			 	or a      ;clear carry flag 
93a2				push hl 
93a2				ld de, 255 
93a2				sbc hl, de 
93a2				jr c, .lowalloc 
93a2			 
93a2				push de 
93a2					ld hl, display_fb0 
93a2					ld (display_fb_active), hl 
93a2				call clear_display 
93a2				ld a, 0 
93a2				ld de, .mallocsize 
93a2				call str_at_display 
93a2				call update_display 
93a2				call delay1s 
93a2				call delay1s 
93a2			;	ld a, 0 
93a2			;	ld (os_view_disable), a 
93a2				call bp_on 
93a2			 
93a2				pop de 
93a2				pop hl 
93a2			 
93a2				 
93a2			 
93a2				CALLMONITOR 
93a2				jr .lowdone 
93a2			.lowalloc: 
93a2			 
93a2			 
93a2				pop hl 
93a2			.lowdone:	pop af 
93a2				pop de 
93a2				pop hl 
93a2			ret 
93a2			 
93a2			malloc_guard_exit: 
93a2				push hl 
93a2				push de 
93a2				push af 
93a2			 
93a2			 	or a      ;clear carry flag 
93a2				push hl 
93a2				ld de, 255 
93a2				sbc hl, de 
93a2				jr c, .lowallocx 
93a2			 
93a2				push de 
93a2					ld hl, display_fb0 
93a2					ld (display_fb_active), hl 
93a2				call clear_display 
93a2				ld a, 0 
93a2				ld de, .mallocasize 
93a2				call str_at_display 
93a2				call update_display 
93a2				call delay1s 
93a2				call delay1s 
93a2			;	ld a, 0 
93a2			;	ld (os_view_disable), a 
93a2				call bp_on 
93a2				pop de 
93a2				pop hl 
93a2			 
93a2				CALLMONITOR 
93a2				jr .lowdonex 
93a2			.lowallocx: 
93a2			 
93a2				pop hl 
93a2			.lowdonex:	pop af 
93a2				pop de 
93a2				pop hl 
93a2			ret 
93a2			endif 
93a2			 
93a2			if MALLOC_2 
93a2			; Z80 Malloc and Free Functions 
93a2			 
93a2			; Malloc Function: 
93a2			; Input: 
93a2			;   HL: Size of block to allocate 
93a2			; Output: 
93a2			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
93a2			 
93a2			malloc: 
93a2				 
93a2			if DEBUG_FORTH_MALLOC_HIGH 
93a2			call malloc_guard_entry 
93a2			endif 
93a2			 
93a2			 
93a2			 
93a2			 
93a2					if DEBUG_FORTH_MALLOC 
93a2						DMARK "mal" 
93a2						CALLMONITOR 
93a2					endif 
93a2			    push af            ; Save AF register 
93a2			    ld a, l            ; Load low byte of size into A 
93a2			    or h               ; Check if size is zero 
93a2			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
93a2			 
93a2			    ; Allocate memory 
93a2			    ld hl, (heap_start) ; Load start of heap into HL 
93a2					if DEBUG_FORTH_MALLOC 
93a2						DMARK "ma1" 
93a2						CALLMONITOR 
93a2					endif 
93a2			    call malloc_internal ; Call internal malloc function 
93a2			    pop af             ; Restore AF register 
93a2			if DEBUG_FORTH_MALLOC_HIGH 
93a2			call malloc_guard_exit 
93a2			call malloc_guard_zerolen 
93a2			endif 
93a2			    ret                ; Return 
93a2			 
93a2			; Free Function: 
93a2			; Input: 
93a2			;   HL: Pointer to memory block to free 
93a2			; Output: 
93a2			;   None 
93a2			 
93a2			free: 
93a2			    push af            ; Save AF register 
93a2			    ld a, l            ; Load low byte of pointer into A 
93a2			    or h               ; Check if pointer is NULL 
93a2			    jp z, free_exit    ; If pointer is NULL, exit 
93a2			 
93a2			    ; Free memory 
93a2			    ld hl, (heap_start) ; Load start of heap into HL 
93a2			    call free_internal  ; Call internal free function 
93a2			    pop af             ; Restore AF register 
93a2			    ret                ; Return 
93a2			 
93a2			; Internal Malloc Function: 
93a2			; Input: 
93a2			;   HL: Size of block to allocate 
93a2			; Output: 
93a2			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
93a2			 
93a2			malloc_internal: 
93a2			    ld bc, 2           ; Number of bytes to allocate for management overhead 
93a2			    add hl, bc         ; Add management overhead to requested size 
93a2			    ex de, hl          ; Save total size in DE, and keep it in HL 
93a2					if DEBUG_FORTH_MALLOC 
93a2						DMARK "ma2" 
93a2						CALLMONITOR 
93a2					endif 
93a2			 
93a2			    ; Search for free memory block 
93a2			    ld de, (heap_end)  ; Load end of heap into DE 
93a2			    ld bc, 0           ; Initialize counter 
93a2			 
93a2					if DEBUG_FORTH_MALLOC 
93a2						DMARK "ma2" 
93a2						CALLMONITOR 
93a2					endif 
93a2			malloc_search_loop: 
93a2			    ; Check if current block is free 
93a2			    ld a, (hl)         ; Load current block's status (free or used) 
93a2			    cp 0               ; Compare with zero (free) 
93a2			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
93a2			 
93a2			    ; Check if current block is large enough 
93a2			    ld a, (hl+1)       ; Load high byte of block size 
93a2			    cp l               ; Compare with low byte of requested size 
93a2			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
93a2			 
93a2			    ld a, (hl+2)       ; Load low byte of block size 
93a2			    cp h               ; Compare with high byte of requested size 
93a2			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
93a2			 
93a2			    ; Mark block as used 
93a2			    ld (hl), 0xFF      ; Set status byte to indicate used block 
93a2			 
93a2			    ; Calculate remaining space in block 
93a2			    ld bc, 0           ; Clear BC 
93a2			    add hl, bc         ; Increment HL to point to start of data block 
93a2			    add hl, de         ; HL = HL + DE (total size) 
93a2			    ld bc, 1           ; Number of bytes to allocate for management overhead 
93a2			    add hl, bc         ; Add management overhead to start of data block 
93a2			 
93a2			    ; Save pointer to allocated block in HL 
93a2			if DEBUG_FORTH_MALLOC_HIGH 
93a2						DMARK "ma5" 
93a2			call malloc_guard_exit 
93a2			call malloc_guard_zerolen 
93a2			endif 
93a2			    ret 
93a2			 
93a2			malloc_skip_block_check: 
93a2			    ; Move to the next block 
93a2			    ld bc, 3           ; Size of management overhead 
93a2			    add hl, bc         ; Move to the next block 
93a2			    inc de             ; Increment counter 
93a2			 
93a2			    ; Check if we have reached the end of heap 
93a2			    ld a, e            ; Load low byte of heap end address 
93a2			    cp (hl)            ; Compare with low byte of current address 
93a2			    jr nz, malloc_search_loop  ; If not equal, continue searching 
93a2			    ld a, d            ; Load high byte of heap end address 
93a2			    cp 0               ; Check if it's zero (end of memory) 
93a2			    jr nz, malloc_search_loop  ; If not zero, continue searching 
93a2			 
93a2			    ; If we reached here, allocation failed 
93a2			    xor a              ; Set result to NULL 
93a2			if DEBUG_FORTH_MALLOC_HIGH 
93a2						DMARK "ma6" 
93a2			call malloc_guard_exit 
93a2			call malloc_guard_zerolen 
93a2			endif 
93a2			    ret 
93a2			malloc_exit: 
93a2			if DEBUG_FORTH_MALLOC_HIGH 
93a2						DMARK "ma7" 
93a2			call malloc_guard_exit 
93a2			call malloc_guard_zerolen 
93a2			endif 
93a2			    ret 
93a2			 
93a2			; Internal Free Function: 
93a2			; Input: 
93a2			;   HL: Pointer to memory block to free 
93a2			; Output: 
93a2			;   None 
93a2			 
93a2			free_internal: 
93a2			    ld de, (heap_start) ; Load start of heap into DE 
93a2			    ld bc, 0            ; Initialize counter 
93a2			 
93a2			free_search_loop: 
93a2			    ; Check if current block contains the pointer 
93a2			    ld a, l             ; Load low byte of pointer 
93a2			    cp (hl+1)           ; Compare with high byte of current block's address 
93a2			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
93a2			    ld a, h             ; Load high byte of pointer 
93a2			    cp (hl+2)           ; Compare with low byte of current block's address 
93a2			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
93a2			 
93a2			    ; Mark block as free 
93a2			    ld (hl), 0          ; Set status byte to indicate free block 
93a2			    ret                 ; Return 
93a2			 
93a2			free_skip_block_check: 
93a2			    ; Move to the next block 
93a2			    ld bc, 3            ; Size of management overhead 
93a2			    add hl, bc          ; Move to the next block 
93a2			    inc de              ; Increment counter 
93a2			 
93a2			    ; Check if we have reached the end of heap 
93a2			    ld a, e             ; Load low byte of heap end address 
93a2			    cp (hl)             ; Compare with low byte of current address 
93a2			    jr nz, free_search_loop  ; If not equal, continue searching 
93a2			    ld a, d             ; Load high byte of heap end address 
93a2			    cp 0                ; Check if it's zero (end of memory) 
93a2			    jr nz, free_search_loop  ; If not zero, continue searching 
93a2			 
93a2			    ; If we reached here, pointer is not found in heap 
93a2			    ret 
93a2			 
93a2			free_exit: 
93a2			    ret                 ; Return 
93a2			 
93a2			; Define heap start and end addresses 
93a2			;heap_start:    .dw 0xC000   ; Start of heap 
93a2			;heap_end:      .dw 0xE000   ; End of heap 
93a2			 
93a2			endif 
93a2			 
93a2			 
93a2			if MALLOC_1 
93a2			 
93a2			 
93a2			 
93a2			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
93a2			 
93a2			;moved to firmware.asm 
93a2			;heap_start        .equ  0x9000      ; Starting address of heap 
93a2			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
93a2			 
93a2			;      .org 0 
93a2			;      jp    main 
93a2			 
93a2			 
93a2			;      .org  0x100 
93a2			;main: 
93a2			;      ld    HL, 0x8100 
93a2			;      ld    SP, HL 
93a2			; 
93a2			;      call  heap_init 
93a2			; 
93a2			;      ; Make some allocations 
93a2			;      ld    HL, 12 
93a2			;      call  malloc            ; Allocates 0x9004 
93a2			; 
93a2			;      ld    HL, 12 
93a2			;      call  malloc            ; Allocates 0x9014 
93a2			; 
93a2			;      ld    HL, 12 
93a2			;      call  malloc            ; Allocates 0x9024 
93a2			; 
93a2			;      ; Free some allocations 
93a2			;      ld    HL, 0x9014 
93a2			;      call  free 
93a2			; 
93a2			;      ld    HL, 0x9004 
93a2			;      call  free 
93a2			; 
93a2			;      ld    HL, 0x9024 
93a2			;      call  free 
93a2			; 
93a2			; 
93a2			;      halt 
93a2			 
93a2			 
93a2			;------------------------------------------------------------------------------ 
93a2			;     heap_init                                                               : 
93a2			;                                                                             : 
93a2			; Description                                                                 : 
93a2			;     Initialise the heap and make it ready for malloc and free operations.   : 
93a2			;                                                                             : 
93a2			;     The heap is maintained as a linked list, starting with an initial       : 
93a2			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
93a2			;     the first free block in the heap. Each block then points to the next    : 
93a2			;     free block within the heap, and the free list ends at the first block   : 
93a2			;     with a null pointer to the next free block.                             : 
93a2			;                                                                             : 
93a2			; Parameters                                                                  : 
93a2			;     Inputs are compile-time only. Two defines which specify the starting    : 
93a2			;     address of the heap and its size are required, along with a memory      : 
93a2			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
93a2			;     principally stores a pointer to the first free block in the heap.       : 
93a2			;                                                                             : 
93a2			; Returns                                                                     : 
93a2			;     Nothing                                                                 : 
93a2			;------------------------------------------------------------------------------ 
93a2			heap_init: 
93a2 e5			      push  HL 
93a3			 
93a3			      ; Initialise free list struct 
93a3 21 0b e7		      ld    HL, heap_start 
93a6 22 06 e7		      ld    (free_list), HL 
93a9 21 00 00		      ld    HL, 0 
93ac 22 08 e7		      ld    (free_list+2), HL 
93af			 
93af			      ; Insert first free block at bottom of heap, consumes entire heap 
93af 21 98 e2		      ld    HL, heap_start+heap_size-4 
93b2 22 0b e7		      ld    (heap_start), HL        ; Next block (end of free list) 
93b5 21 8d fb		      ld    HL, heap_size-4 
93b8 22 0d e7		      ld    (heap_start+2), HL      ; Block size 
93bb			 
93bb			      ; Insert end of free list block at top of heap - two null words will 
93bb			      ; terminate the free list 
93bb 21 00 00		      ld    HL, 0 
93be 22 9a e2		      ld    (heap_start+heap_size-2), HL 
93c1 22 98 e2		      ld    (heap_start+heap_size-4), HL 
93c4			 
93c4 e1			      pop   HL 
93c5			 
93c5 c9			      ret 
93c6			 
93c6			 
93c6			;------------------------------------------------------------------------------ 
93c6			;     malloc                                                                  : 
93c6			;                                                                             : 
93c6			; Description                                                                 : 
93c6			;     Allocates the wanted space from the heap and returns the address of the : 
93c6			;     first useable byte of the allocation.                                   : 
93c6			;                                                                             : 
93c6			;     Allocations can happen in one of two ways:                              : 
93c6			;                                                                             : 
93c6			;     1. A free block may be found which is the exact size wanted. In this    : 
93c6			;        case the block is removed from the free list and retuedn to the      : 
93c6			;        caller.                                                              : 
93c6			;     2. A free block may be found which is larger than the size wanted. In   : 
93c6			;        this case, the larger block is split into two. The first portion of  : 
93c6			;        this block will become the requested space by the malloc call and    : 
93c6			;        is returned to the caller. The second portion becomes a new free     : 
93c6			;        block, and the free list is adjusted to maintain continuity via this : 
93c6			;        newly created block.                                                 : 
93c6			;                                                                             : 
93c6			;     malloc does not set any initial value in the allocated space, the       : 
93c6			;     caller is required to do this as required.                              : 
93c6			;                                                                             : 
93c6			;     This implementation of malloc uses the stack exclusively, and is        : 
93c6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
93c6			;     advisable to disable interrupts before calling malloc, and recommended  : 
93c6			;     to avoid the use of malloc inside ISRs in general.                      : 
93c6			;                                                                             : 
93c6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
93c6			;                                                                             : 
93c6			; Parameters                                                                  : 
93c6			;     HL  Number of bytes wanted                                              : 
93c6			;                                                                             : 
93c6			; Returns                                                                     : 
93c6			;     HL  Address of the first useable byte of the allocation                 : 
93c6			;                                                                             : 
93c6			; Flags                                                                       : 
93c6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
93c6			;                                                                             : 
93c6			; Stack frame                                                                 : 
93c6			;       |             |                                                       : 
93c6			;       +-------------+                                                       : 
93c6			;       |     BC      |                                                       : 
93c6			;       +-------------+                                                       : 
93c6			;       |     DE      |                                                       : 
93c6			;       +-------------+                                                       : 
93c6			;       |     IX      |                                                       : 
93c6			;       +-------------+                                                       : 
93c6			;       |  prev_free  |                                                       : 
93c6			;   +4  +-------------+                                                       : 
93c6			;       |  this_free  |                                                       : 
93c6			;   +2  +-------------+                                                       : 
93c6			;       |  next_free  |                                                       : 
93c6			;   +0  +-------------+                                                       : 
93c6			;       |             |                                                       : 
93c6			;                                                                             : 
93c6			;------------------------------------------------------------------------------ 
93c6			 
93c6			 
93c6			;malloc: 
93c6			; 
93c6			;	SAVESP ON 1 
93c6			; 
93c6			;	call malloc_code 
93c6			; 
93c6			;	CHECKSP ON 1 
93c6			;	ret 
93c6			 
93c6			 
93c6			malloc: 
93c6 c5			      push  BC 
93c7 d5			      push  DE 
93c8 dd e5		      push  IX 
93ca			if DEBUG_FORTH_MALLOC_HIGH 
93ca			call malloc_guard_entry 
93ca			endif 
93ca			 
93ca					if DEBUG_FORTH_MALLOC 
93ca						DMARK "mal" 
93ca						CALLMONITOR 
93ca					endif 
93ca 7c			      ld    A, H                    ; Exit if no space requested 
93cb b5			      or    L 
93cc ca 8b 94		      jp    Z, malloc_early_exit 
93cf			 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			; 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			;inc hl 
93cf			 
93cf			 
93cf			 
93cf			 
93cf					if DEBUG_FORTH_MALLOC 
93cf						DMARK "maA" 
93cf						CALLMONITOR 
93cf					endif 
93cf			      ; Set up stack frame 
93cf eb			      ex    DE, HL 
93d0 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
93d3 39			      add   HL, SP 
93d4 f9			      ld    SP, HL 
93d5 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
93d9 dd 39		      add   IX, SP 
93db			 
93db			      ; Setup initial state 
93db 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
93de 19			      add   HL, DE 
93df			 
93df 44			      ld    B, H                    ; Move want to BC 
93e0 4d			      ld    C, L 
93e1			 
93e1 21 06 e7		      ld    HL, free_list           ; Store prev_free ptr to stack 
93e4 dd 75 04		      ld    (IX+4), L 
93e7 dd 74 05		      ld    (IX+5), H 
93ea			 
93ea 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
93eb 23			      inc   HL 
93ec 56			      ld    D, (HL) 
93ed dd 73 02		      ld    (IX+2), E 
93f0 dd 72 03		      ld    (IX+3), D 
93f3 eb			      ex    DE, HL                  ; this_free ptr into HL 
93f4			 
93f4					if DEBUG_FORTH_MALLOC 
93f4						DMARK "maB" 
93f4						CALLMONITOR 
93f4					endif 
93f4			      ; Loop through free block list to find some space 
93f4			malloc_find_space: 
93f4 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
93f5 23			      inc   HL 
93f6 56			      ld    D, (HL) 
93f7			 
93f7 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
93f8 b3			      or    E 
93f9 ca 85 94		      jp    Z, malloc_no_space 
93fc			 
93fc dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
93ff dd 72 01		      ld    (IX+1), D 
9402			 
9402			      ; Does this block have enough space to make the allocation? 
9402 23			      inc   HL                      ; Load free block size into DE 
9403 5e			      ld    E, (HL) 
9404 23			      inc   HL 
9405 56			      ld    D, (HL) 
9406			 
9406 eb			      ex    DE, HL                  ; Check size of block against want 
9407 b7			      or    A                       ; Ensure carry flag clear 
9408 ed 42		      sbc   HL, BC 
940a e5			      push  HL                      ; Store the result for later (new block size) 
940b			 
940b ca 5a 94		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
940e 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9410			 
9410			      ; this_free block is not big enough, setup ptrs to test next free block 
9410 e1			      pop   HL                      ; Discard previous result 
9411			 
9411 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9414 dd 66 03		      ld    H, (IX+3) 
9417 dd 75 04		      ld    (IX+4), L 
941a dd 74 05		      ld    (IX+5), H 
941d			 
941d dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9420 dd 66 01		      ld    H, (IX+1) 
9423 dd 75 02		      ld    (IX+2), L 
9426 dd 74 03		      ld    (IX+3), H 
9429			 
9429					if DEBUG_FORTH_MALLOC 
9429						DMARK "MA>" 
9429						CALLMONITOR 
9429					endif 
9429 18 c9		      jr    malloc_find_space 
942b			 
942b			      ; split a bigger block into two - requested size and remaining size 
942b			malloc_alloc_split: 
942b					if DEBUG_FORTH_MALLOC 
942b						DMARK "MAs" 
942b						CALLMONITOR 
942b					endif 
942b eb			      ex    DE, HL                  ; Calculate address of new free block 
942c 2b			      dec   HL 
942d 2b			      dec   HL 
942e 2b			      dec   HL 
942f 09			      add   HL, BC 
9430			 
9430			      ; Create a new block and point it at next_free 
9430 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9433 dd 56 01		      ld    D, (IX+1) 
9436			 
9436 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9437 23			      inc   HL 
9438 72			      ld    (HL), D 
9439			 
9439 d1			      pop   DE                      ; Store size of new block into new block 
943a 23			      inc   HL 
943b 73			      ld    (HL), E 
943c 23			      inc   HL 
943d 72			      ld    (HL), D 
943e			 
943e			      ; Update this_free ptr to point to new block 
943e 2b			      dec   HL 
943f 2b			      dec   HL 
9440 2b			      dec   HL 
9441			 
9441 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9444 dd 56 03		      ld    D, (IX+3) 
9447			 
9447 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
944a dd 74 03		      ld    (IX+3), H 
944d			 
944d			      ; Modify this_free block to be allocation 
944d eb			      ex    DE, HL 
944e af			      xor   A                       ; Null the next block ptr of allocated block 
944f 77			      ld    (HL), A 
9450 23			      inc   HL 
9451 77			      ld    (HL), A 
9452			 
9452 23			      inc   HL                      ; Store want size into allocated block 
9453 71			      ld    (HL), C 
9454 23			      inc   HL 
9455 70			      ld    (HL), B 
9456 23			      inc   HL 
9457 e5			      push  HL                      ; Address of allocation to return 
9458			 
9458 18 19		      jr    malloc_update_links 
945a			 
945a			malloc_alloc_fit: 
945a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
945b			 
945b					if DEBUG_FORTH_MALLOC 
945b						DMARK "MAf" 
945b						CALLMONITOR 
945b					endif 
945b			      ; Modify this_free block to be allocation 
945b eb			      ex    DE, HL 
945c 2b			      dec   HL 
945d 2b			      dec   HL 
945e 2b			      dec   HL 
945f			 
945f af			      xor   A                       ; Null the next block ptr of allocated block 
9460 77			      ld    (HL), A 
9461 23			      inc   HL 
9462 77			      ld    (HL), A 
9463			 
9463 23			      inc   HL                      ; Store address of allocation to return 
9464 23			      inc   HL 
9465 23			      inc   HL 
9466 e5			      push  HL 
9467			 
9467			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9467 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
946a dd 66 01		      ld    H, (IX+1) 
946d			 
946d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9470 dd 74 03		      ld    (IX+3), H 
9473			 
9473			 
9473			malloc_update_links: 
9473			      ; Update prev_free ptr to point to this_free 
9473 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9476 dd 66 05		      ld    H, (IX+5) 
9479			 
9479 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
947c dd 56 03		      ld    D, (IX+3) 
947f			 
947f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9480 23			      inc   HL 
9481 72			      ld    (HL), D 
9482			 
9482					if DEBUG_FORTH_MALLOC 
9482						DMARK "Mul" 
9482						CALLMONITOR 
9482					endif 
9482			      ; Clear the Z flag to indicate successful allocation 
9482 7a			      ld    A, D 
9483 b3			      or    E 
9484			 
9484 d1			      pop   DE                      ; Address of allocation 
9485					if DEBUG_FORTH_MALLOC 
9485						DMARK "MAu" 
9485						CALLMONITOR 
9485					endif 
9485			 
9485			malloc_no_space: 
9485 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9488 39			      add   HL, SP 
9489 f9			      ld    SP, HL 
948a			 
948a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
948b					if DEBUG_FORTH_MALLOC 
948b						DMARK "MAN" 
948b						CALLMONITOR 
948b					endif 
948b			 
948b			malloc_early_exit: 
948b					if DEBUG_FORTH_MALLOC 
948b						DMARK "MAx" 
948b						CALLMONITOR 
948b					endif 
948b dd e1		      pop   IX 
948d d1			      pop   DE 
948e c1			      pop   BC 
948f			 
948f			if DEBUG_FORTH_MALLOC_HIGH 
948f			call malloc_guard_exit 
948f			call malloc_guard_zerolen 
948f			endif 
948f c9			      ret 
9490			 
9490			 
9490			;------------------------------------------------------------------------------ 
9490			;     free                                                                    : 
9490			;                                                                             : 
9490			; Description                                                                 : 
9490			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9490			;     returned by malloc, otherwise the behaviour is undefined.               : 
9490			;                                                                             : 
9490			;     Where possible, directly adjacent free blocks will be merged together   : 
9490			;     into larger blocks to help ensure that the heap does not become         : 
9490			;     excessively fragmented.                                                 : 
9490			;                                                                             : 
9490			;     free does not clear or set any other value into the freed space, and    : 
9490			;     therefore its contents may be visible through subsequent malloc's. The  : 
9490			;     caller should clear the freed space as required.                        : 
9490			;                                                                             : 
9490			;     This implementation of free uses the stack exclusively, and is          : 
9490			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9490			;     advisable to disable interrupts before calling free, and recommended    : 
9490			;     to avoid the use of free inside ISRs in general.                        : 
9490			;                                                                             : 
9490			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9490			;                                                                             : 
9490			; Parameters                                                                  : 
9490			;     HL  Pointer to address of first byte of allocation to be freed          : 
9490			;                                                                             : 
9490			; Returns                                                                     : 
9490			;     Nothing                                                                 : 
9490			;                                                                             : 
9490			; Stack frame                                                                 : 
9490			;       |             |                                                       : 
9490			;       +-------------+                                                       : 
9490			;       |     BC      |                                                       : 
9490			;       +-------------+                                                       : 
9490			;       |     DE      |                                                       : 
9490			;       +-------------+                                                       : 
9490			;       |     IX      |                                                       : 
9490			;       +-------------+                                                       : 
9490			;       |  prev_free  |                                                       : 
9490			;   +2  +-------------+                                                       : 
9490			;       |  next_free  |                                                       : 
9490			;   +0  +-------------+                                                       : 
9490			;       |             |                                                       : 
9490			;                                                                             : 
9490			;------------------------------------------------------------------------------ 
9490			free: 
9490 c5			      push  BC 
9491 d5			      push  DE 
9492 dd e5		      push  IX 
9494			 
9494 7c			      ld    A, H                    ; Exit if ptr is null 
9495 b5			      or    L 
9496 ca 5a 95		      jp    Z, free_early_exit 
9499			 
9499			      ; Set up stack frame 
9499 eb			      ex    DE, HL 
949a 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
949d 39			      add   HL, SP 
949e f9			      ld    SP, HL 
949f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
94a3 dd 39		      add   IX, SP 
94a5			 
94a5			      ; The address in HL points to the start of the useable allocated space, 
94a5			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
94a5			      ; address of the block itself. 
94a5 eb			      ex    DE, HL 
94a6 11 fc ff		      ld    DE, -4 
94a9 19			      add   HL, DE 
94aa			 
94aa			      ; An allocated block must have a null next block pointer in it 
94aa 7e			      ld    A, (HL) 
94ab 23			      inc   HL 
94ac b6			      or    (HL) 
94ad c2 55 95		      jp    NZ, free_done 
94b0			 
94b0 2b			      dec   HL 
94b1			 
94b1 44			      ld    B, H                    ; Copy HL to BC 
94b2 4d			      ld    C, L 
94b3			 
94b3			      ; Loop through the free list to find the first block with an address 
94b3			      ; higher than the block being freed 
94b3 21 06 e7		      ld    HL, free_list 
94b6			 
94b6			free_find_higher_block: 
94b6 5e			      ld    E, (HL)                 ; Load next ptr from free block 
94b7 23			      inc   HL 
94b8 56			      ld    D, (HL) 
94b9 2b			      dec   HL 
94ba			 
94ba dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
94bd dd 72 01		      ld    (IX+1), D 
94c0 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
94c3 dd 74 03		      ld    (IX+3), H 
94c6			 
94c6 78			      ld    A, B                    ; Check if DE is greater than BC 
94c7 ba			      cp    D                       ; Compare MSB first 
94c8 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
94ca 30 04		      jr    NC, free_find_higher_block_skip 
94cc 79			      ld    A, C 
94cd bb			      cp    E                       ; Then compare LSB 
94ce 38 08		      jr    C, free_found_higher_block 
94d0			 
94d0			free_find_higher_block_skip: 
94d0 7a			      ld    A, D                    ; Reached the end of the free list? 
94d1 b3			      or    E 
94d2 ca 55 95		      jp    Z, free_done 
94d5			 
94d5 eb			      ex    DE, HL 
94d6			 
94d6 18 de		      jr    free_find_higher_block 
94d8			 
94d8			free_found_higher_block: 
94d8			      ; Insert freed block between prev and next free blocks 
94d8 71			      ld    (HL), C                 ; Point prev free block to freed block 
94d9 23			      inc   HL 
94da 70			      ld    (HL), B 
94db			 
94db 60			      ld    H, B                    ; Point freed block at next free block 
94dc 69			      ld    L, C 
94dd 73			      ld    (HL), E 
94de 23			      inc   HL 
94df 72			      ld    (HL), D 
94e0			 
94e0			      ; Check if the freed block is adjacent to the next free block 
94e0 23			      inc   HL                      ; Load size of freed block into HL 
94e1 5e			      ld    E, (HL) 
94e2 23			      inc   HL 
94e3 56			      ld    D, (HL) 
94e4 eb			      ex    DE, HL 
94e5			 
94e5 09			      add   HL, BC                  ; Add addr of freed block and its size 
94e6			 
94e6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
94e9 dd 56 01		      ld    D, (IX+1) 
94ec			 
94ec b7			      or    A                       ; Clear the carry flag 
94ed ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
94ef 20 22		      jr    NZ, free_check_adjacent_to_prev 
94f1			 
94f1			      ; Freed block is adjacent to next, merge into one bigger block 
94f1 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
94f2 5e			      ld    E, (HL) 
94f3 23			      inc   HL 
94f4 56			      ld    D, (HL) 
94f5 e5			      push  HL                      ; Save ptr to next block for later 
94f6			 
94f6 60			      ld    H, B                    ; Store ptr from next block into freed block 
94f7 69			      ld    L, C 
94f8 73			      ld    (HL), E 
94f9 23			      inc   HL 
94fa 72			      ld    (HL), D 
94fb			 
94fb e1			      pop   HL                      ; Restore ptr to next block 
94fc 23			      inc   HL                      ; Load size of next block into DE 
94fd 5e			      ld    E, (HL) 
94fe 23			      inc   HL 
94ff 56			      ld    D, (HL) 
9500 d5			      push  DE                      ; Save next block size for later 
9501			 
9501 60			      ld    H, B                    ; Load size of freed block into HL 
9502 69			      ld    L, C 
9503 23			      inc   HL 
9504 23			      inc   HL 
9505 5e			      ld    E, (HL) 
9506 23			      inc   HL 
9507 56			      ld    D, (HL) 
9508 eb			      ex    DE, HL 
9509			 
9509 d1			      pop   DE                      ; Restore size of next block 
950a 19			      add   HL, DE                  ; Add sizes of both blocks 
950b eb			      ex    DE, HL 
950c			 
950c 60			      ld    H, B                    ; Store new bigger size into freed block 
950d 69			      ld    L, C 
950e 23			      inc   HL 
950f 23			      inc   HL 
9510 73			      ld    (HL), E 
9511 23			      inc   HL 
9512 72			      ld    (HL), D 
9513			 
9513			free_check_adjacent_to_prev: 
9513			      ; Check if the freed block is adjacent to the prev free block 
9513 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9516 dd 66 03		      ld    H, (IX+3) 
9519			 
9519 23			      inc   HL                      ; Size of prev free block into DE 
951a 23			      inc   HL 
951b 5e			      ld    E, (HL) 
951c 23			      inc   HL 
951d 56			      ld    D, (HL) 
951e 2b			      dec   HL 
951f 2b			      dec   HL 
9520 2b			      dec   HL 
9521			 
9521 19			      add   HL, DE                  ; Add prev block addr and size 
9522			 
9522 b7			      or    A                       ; Clear the carry flag 
9523 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9525 20 2e		      jr    NZ, free_done 
9527			 
9527			      ; Freed block is adjacent to prev, merge into one bigger block 
9527 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9528 69			      ld    L, C 
9529 5e			      ld    E, (HL) 
952a 23			      inc   HL 
952b 56			      ld    D, (HL) 
952c e5			      push  HL                      ; Save freed block ptr for later 
952d			 
952d dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9530 dd 66 03		      ld    H, (IX+3) 
9533 73			      ld    (HL), E 
9534 23			      inc   HL 
9535 72			      ld    (HL), D 
9536			 
9536 e1			      pop   HL                      ; Restore freed block ptr 
9537 23			      inc   HL                      ; Load size of freed block into DE 
9538 5e			      ld    E, (HL) 
9539 23			      inc   HL 
953a 56			      ld    D, (HL) 
953b d5			      push  DE                      ; Save freed block size for later 
953c			 
953c dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
953f dd 66 03		      ld    H, (IX+3) 
9542 23			      inc   HL 
9543 23			      inc   HL 
9544 5e			      ld    E, (HL) 
9545 23			      inc   HL 
9546 56			      ld    D, (HL) 
9547			 
9547 e1			      pop   HL                      ; Add sizes of both blocks 
9548 19			      add   HL, DE 
9549 eb			      ex    DE, HL 
954a			 
954a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
954d dd 66 03		      ld    H, (IX+3) 
9550 23			      inc   HL 
9551 23			      inc   HL 
9552 73			      ld    (HL), E 
9553 23			      inc   HL 
9554 72			      ld    (HL), D 
9555			 
9555			free_done: 
9555 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9558 39			      add   HL, SP 
9559 f9			      ld    SP, HL 
955a			 
955a			free_early_exit: 
955a dd e1		      pop   IX 
955c d1			      pop   DE 
955d c1			      pop   BC 
955e			 
955e c9			      ret 
955f			 
955f			; moved to firmware.asm 
955f			; 
955f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
955f			;                  .dw   0 
955f			 
955f			 
955f			endif 
955f			 
955f			 
955f			if MALLOC_3 
955f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
955f			;heap_start        .equ  0x9000      ; Starting address of heap 
955f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
955f			; 
955f			 ;     .org 0 
955f			  ;    jp    main 
955f			; 
955f			; 
955f			 ;     .org  0x100 
955f			;main: 
955f			 ;     ld    HL, 0x8100 
955f			  ;    ld    SP, HL 
955f			; 
955f			;      call  heap_init 
955f			 
955f			      ; Make some allocations 
955f			;      ld    HL, 12 
955f			;      call  malloc            ; Allocates 0x9004 
955f			; 
955f			 ;     ld    HL, 12 
955f			;      call  malloc            ; Allocates 0x9014 
955f			 
955f			;      ld    HL, 12 
955f			;      call  malloc            ; Allocates 0x9024 
955f			 
955f			      ; Free some allocations 
955f			;      ld    HL, 0x9014 
955f			;      call  free 
955f			 
955f			;      ld    HL, 0x9004 
955f			;      call  free 
955f			; 
955f			;      ld    HL, 0x9024 
955f			;      call  free 
955f			 
955f			 
955f			 ;     halt 
955f			 
955f			 
955f			;------------------------------------------------------------------------------ 
955f			;     heap_init                                                               : 
955f			;                                                                             : 
955f			; Description                                                                 : 
955f			;     Initialise the heap and make it ready for malloc and free operations.   : 
955f			;                                                                             : 
955f			;     The heap is maintained as a linked list, starting with an initial       : 
955f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
955f			;     the first free block in the heap. Each block then points to the next    : 
955f			;     free block within the heap, and the free list ends at the first block   : 
955f			;     with a null pointer to the next free block.                             : 
955f			;                                                                             : 
955f			; Parameters                                                                  : 
955f			;     Inputs are compile-time only. Two defines which specify the starting    : 
955f			;     address of the heap and its size are required, along with a memory      : 
955f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
955f			;     principally stores a pointer to the first free block in the heap.       : 
955f			;                                                                             : 
955f			; Returns                                                                     : 
955f			;     Nothing                                                                 : 
955f			;------------------------------------------------------------------------------ 
955f			heap_init: 
955f			      push  HL 
955f			 
955f			      ; Initialise free list struct 
955f			      ld    HL, heap_start 
955f			      ld    (free_list), HL 
955f			      ld    HL, 0 
955f			      ld    (free_list+2), HL 
955f			 
955f			      ; Insert first free block at bottom of heap, consumes entire heap 
955f			      ld    HL, heap_start+heap_size-4 
955f			      ld    (heap_start), HL        ; Next block (end of free list) 
955f			      ld    HL, heap_size-4 
955f			      ld    (heap_start+2), HL      ; Block size 
955f			 
955f			      ; Insert end of free list block at top of heap - two null words will 
955f			      ; terminate the free list 
955f			      ld    HL, 0 
955f			      ld    (heap_start+heap_size-2), HL 
955f			      ld    (heap_start+heap_size-4), HL 
955f			 
955f			      pop   HL 
955f			 
955f			      ret 
955f			 
955f			 
955f			;------------------------------------------------------------------------------ 
955f			;     malloc                                                                  : 
955f			;                                                                             : 
955f			; Description                                                                 : 
955f			;     Allocates the wanted space from the heap and returns the address of the : 
955f			;     first useable byte of the allocation.                                   : 
955f			;                                                                             : 
955f			;     Allocations can happen in one of two ways:                              : 
955f			;                                                                             : 
955f			;     1. A free block may be found which is the exact size wanted. In this    : 
955f			;        case the block is removed from the free list and retuedn to the      : 
955f			;        caller.                                                              : 
955f			;     2. A free block may be found which is larger than the size wanted. In   : 
955f			;        this case, the larger block is split into two. The first portion of  : 
955f			;        this block will become the requested space by the malloc call and    : 
955f			;        is returned to the caller. The second portion becomes a new free     : 
955f			;        block, and the free list is adjusted to maintain continuity via this : 
955f			;        newly created block.                                                 : 
955f			;                                                                             : 
955f			;     malloc does not set any initial value in the allocated space, the       : 
955f			;     caller is required to do this as required.                              : 
955f			;                                                                             : 
955f			;     This implementation of malloc uses the stack exclusively, and is        : 
955f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
955f			;     advisable to disable interrupts before calling malloc, and recommended  : 
955f			;     to avoid the use of malloc inside ISRs in general.                      : 
955f			;                                                                             : 
955f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
955f			;                                                                             : 
955f			; Parameters                                                                  : 
955f			;     HL  Number of bytes wanted                                              : 
955f			;                                                                             : 
955f			; Returns                                                                     : 
955f			;     HL  Address of the first useable byte of the allocation                 : 
955f			;                                                                             : 
955f			; Flags                                                                       : 
955f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
955f			;                                                                             : 
955f			; Stack frame                                                                 : 
955f			;       |             |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |     BC      |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |     DE      |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |     IX      |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |  prev_free  |                                                       : 
955f			;   +4  +-------------+                                                       : 
955f			;       |  this_free  |                                                       : 
955f			;   +2  +-------------+                                                       : 
955f			;       |  next_free  |                                                       : 
955f			;   +0  +-------------+                                                       : 
955f			;       |             |                                                       : 
955f			;                                                                             : 
955f			;------------------------------------------------------------------------------ 
955f			malloc: 
955f			      push  BC 
955f			      push  DE 
955f			      push  IX 
955f			 
955f			      ld    A, H                    ; Exit if no space requested 
955f			      or    L 
955f			      jp    Z, malloc_early_exit 
955f			 
955f			      ; Set up stack frame 
955f			      ex    DE, HL 
955f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
955f			      add   HL, SP 
955f			      ld    SP, HL 
955f			      ld    IX, 0                   ; Use IX as a frame pointer 
955f			      add   IX, SP 
955f			 
955f			      ; Setup initial state 
955f			      ld    HL, 4                   ; want must also include space used by block struct 
955f			      add   HL, DE 
955f			 
955f			      ld    B, H                    ; Move want to BC 
955f			      ld    C, L 
955f			 
955f			      ld    HL, free_list           ; Store prev_free ptr to stack 
955f			      ld    (IX+4), L 
955f			      ld    (IX+5), H 
955f			 
955f			      ld    E, (HL)                 ; Store this_free ptr to stack 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      ld    (IX+2), E 
955f			      ld    (IX+3), D 
955f			      ex    DE, HL                  ; this_free ptr into HL 
955f			 
955f			      ; Loop through free block list to find some space 
955f			malloc_find_space: 
955f			      ld    E, (HL)                 ; Load next_free ptr into DE 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			 
955f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
955f			      or    E 
955f			      jp    Z, malloc_no_space 
955f			 
955f			      ld    (IX+0), E               ; Store next_free ptr to stack 
955f			      ld    (IX+1), D 
955f			 
955f			      ; Does this block have enough space to make the allocation? 
955f			      inc   HL                      ; Load free block size into DE 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			 
955f			      ex    DE, HL                  ; Check size of block against want 
955f			      or    A                       ; Ensure carry flag clear 
955f			      sbc   HL, BC 
955f			      push  HL                      ; Store the result for later (new block size) 
955f			 
955f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
955f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
955f			 
955f			      ; this_free block is not big enough, setup ptrs to test next free block 
955f			      pop   HL                      ; Discard previous result 
955f			 
955f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
955f			      ld    H, (IX+3) 
955f			      ld    (IX+4), L 
955f			      ld    (IX+5), H 
955f			 
955f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
955f			      ld    H, (IX+1) 
955f			      ld    (IX+2), L 
955f			      ld    (IX+3), H 
955f			 
955f			      jr    malloc_find_space 
955f			 
955f			      ; split a bigger block into two - requested size and remaining size 
955f			malloc_alloc_split: 
955f			      ex    DE, HL                  ; Calculate address of new free block 
955f			      dec   HL 
955f			      dec   HL 
955f			      dec   HL 
955f			      add   HL, BC 
955f			 
955f			      ; Create a new block and point it at next_free 
955f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
955f			      ld    D, (IX+1) 
955f			 
955f			      ld    (HL), E                 ; Store next_free ptr into new block 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			      pop   DE                      ; Store size of new block into new block 
955f			      inc   HL 
955f			      ld    (HL), E 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			      ; Update this_free ptr to point to new block 
955f			      dec   HL 
955f			      dec   HL 
955f			      dec   HL 
955f			 
955f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
955f			      ld    D, (IX+3) 
955f			 
955f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
955f			      ld    (IX+3), H 
955f			 
955f			      ; Modify this_free block to be allocation 
955f			      ex    DE, HL 
955f			      xor   A                       ; Null the next block ptr of allocated block 
955f			      ld    (HL), A 
955f			      inc   HL 
955f			      ld    (HL), A 
955f			 
955f			      inc   HL                      ; Store want size into allocated block 
955f			      ld    (HL), C 
955f			      inc   HL 
955f			      ld    (HL), B 
955f			      inc   HL 
955f			      push  HL                      ; Address of allocation to return 
955f			 
955f			      jr    malloc_update_links 
955f			 
955f			malloc_alloc_fit: 
955f			      pop   HL                      ; Dont need new block size, want is exact fit 
955f			 
955f			      ; Modify this_free block to be allocation 
955f			      ex    DE, HL 
955f			      dec   HL 
955f			      dec   HL 
955f			      dec   HL 
955f			 
955f			      xor   A                       ; Null the next block ptr of allocated block 
955f			      ld    (HL), A 
955f			      inc   HL 
955f			      ld    (HL), A 
955f			 
955f			      inc   HL                      ; Store address of allocation to return 
955f			      inc   HL 
955f			      inc   HL 
955f			      push  HL 
955f			 
955f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
955f			      ld    L, (IX+0)               ; next_free to HL 
955f			      ld    H, (IX+1) 
955f			 
955f			      ld    (IX+2), L               ; HL to this_free 
955f			      ld    (IX+3), H 
955f			 
955f			 
955f			malloc_update_links: 
955f			      ; Update prev_free ptr to point to this_free 
955f			      ld    L, (IX+4)               ; prev_free ptr to HL 
955f			      ld    H, (IX+5) 
955f			 
955f			      ld    E, (IX+2)               ; this_free ptr to DE 
955f			      ld    D, (IX+3) 
955f			 
955f			      ld    (HL), E                 ; this_free ptr into prev_free 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			      ; Clear the Z flag to indicate successful allocation 
955f			      ld    A, D 
955f			      or    E 
955f			 
955f			      pop   DE                      ; Address of allocation 
955f			 
955f			malloc_no_space: 
955f			      ld    HL, 6                   ; Clean up stack frame 
955f			      add   HL, SP 
955f			      ld    SP, HL 
955f			 
955f			      ex    DE, HL                  ; Alloc addr into HL for return 
955f			 
955f			malloc_early_exit: 
955f			      pop   IX 
955f			      pop   DE 
955f			      pop   BC 
955f			 
955f			      ret 
955f			 
955f			 
955f			;------------------------------------------------------------------------------ 
955f			;     free                                                                    : 
955f			;                                                                             : 
955f			; Description                                                                 : 
955f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
955f			;     returned by malloc, otherwise the behaviour is undefined.               : 
955f			;                                                                             : 
955f			;     Where possible, directly adjacent free blocks will be merged together   : 
955f			;     into larger blocks to help ensure that the heap does not become         : 
955f			;     excessively fragmented.                                                 : 
955f			;                                                                             : 
955f			;     free does not clear or set any other value into the freed space, and    : 
955f			;     therefore its contents may be visible through subsequent malloc's. The  : 
955f			;     caller should clear the freed space as required.                        : 
955f			;                                                                             : 
955f			;     This implementation of free uses the stack exclusively, and is          : 
955f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
955f			;     advisable to disable interrupts before calling free, and recommended    : 
955f			;     to avoid the use of free inside ISRs in general.                        : 
955f			;                                                                             : 
955f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
955f			;                                                                             : 
955f			; Parameters                                                                  : 
955f			;     HL  Pointer to address of first byte of allocation to be freed          : 
955f			;                                                                             : 
955f			; Returns                                                                     : 
955f			;     Nothing                                                                 : 
955f			;                                                                             : 
955f			; Stack frame                                                                 : 
955f			;       |             |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |     BC      |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |     DE      |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |     IX      |                                                       : 
955f			;       +-------------+                                                       : 
955f			;       |  prev_free  |                                                       : 
955f			;   +2  +-------------+                                                       : 
955f			;       |  next_free  |                                                       : 
955f			;   +0  +-------------+                                                       : 
955f			;       |             |                                                       : 
955f			;                                                                             : 
955f			;------------------------------------------------------------------------------ 
955f			free: 
955f			      push  BC 
955f			      push  DE 
955f			      push  IX 
955f			 
955f			      ld    A, H                    ; Exit if ptr is null 
955f			      or    L 
955f			      jp    Z, free_early_exit 
955f			 
955f			      ; Set up stack frame 
955f			      ex    DE, HL 
955f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
955f			      add   HL, SP 
955f			      ld    SP, HL 
955f			      ld    IX, 0                   ; Use IX as a frame pointer 
955f			      add   IX, SP 
955f			 
955f			      ; The address in HL points to the start of the useable allocated space, 
955f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
955f			      ; address of the block itself. 
955f			      ex    DE, HL 
955f			      ld    DE, -4 
955f			      add   HL, DE 
955f			 
955f			      ; An allocated block must have a null next block pointer in it 
955f			      ld    A, (HL) 
955f			      inc   HL 
955f			      or    (HL) 
955f			      jp    NZ, free_done 
955f			 
955f			      dec   HL 
955f			 
955f			      ld    B, H                    ; Copy HL to BC 
955f			      ld    C, L 
955f			 
955f			      ; Loop through the free list to find the first block with an address 
955f			      ; higher than the block being freed 
955f			      ld    HL, free_list 
955f			 
955f			free_find_higher_block: 
955f			      ld    E, (HL)                 ; Load next ptr from free block 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      dec   HL 
955f			 
955f			      ld    (IX+0), E               ; Save ptr to next free block 
955f			      ld    (IX+1), D 
955f			      ld    (IX+2), L               ; Save ptr to prev free block 
955f			      ld    (IX+3), H 
955f			 
955f			      ld    A, B                    ; Check if DE is greater than BC 
955f			      cp    D                       ; Compare MSB first 
955f			      jr    Z, $+4                  ; MSB the same, compare LSB 
955f			      jr    NC, free_find_higher_block_skip 
955f			      ld    A, C 
955f			      cp    E                       ; Then compare LSB 
955f			      jr    C, free_found_higher_block 
955f			 
955f			free_find_higher_block_skip: 
955f			      ld    A, D                    ; Reached the end of the free list? 
955f			      or    E 
955f			      jp    Z, free_done 
955f			 
955f			      ex    DE, HL 
955f			 
955f			      jr    free_find_higher_block 
955f			 
955f			free_found_higher_block: 
955f			      ; Insert freed block between prev and next free blocks 
955f			      ld    (HL), C                 ; Point prev free block to freed block 
955f			      inc   HL 
955f			      ld    (HL), B 
955f			 
955f			      ld    H, B                    ; Point freed block at next free block 
955f			      ld    L, C 
955f			      ld    (HL), E 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			      ; Check if the freed block is adjacent to the next free block 
955f			      inc   HL                      ; Load size of freed block into HL 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      ex    DE, HL 
955f			 
955f			      add   HL, BC                  ; Add addr of freed block and its size 
955f			 
955f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
955f			      ld    D, (IX+1) 
955f			 
955f			      or    A                       ; Clear the carry flag 
955f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
955f			      jr    NZ, free_check_adjacent_to_prev 
955f			 
955f			      ; Freed block is adjacent to next, merge into one bigger block 
955f			      ex    DE, HL                  ; Load next ptr from next block into DE 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      push  HL                      ; Save ptr to next block for later 
955f			 
955f			      ld    H, B                    ; Store ptr from next block into freed block 
955f			      ld    L, C 
955f			      ld    (HL), E 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			      pop   HL                      ; Restore ptr to next block 
955f			      inc   HL                      ; Load size of next block into DE 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      push  DE                      ; Save next block size for later 
955f			 
955f			      ld    H, B                    ; Load size of freed block into HL 
955f			      ld    L, C 
955f			      inc   HL 
955f			      inc   HL 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      ex    DE, HL 
955f			 
955f			      pop   DE                      ; Restore size of next block 
955f			      add   HL, DE                  ; Add sizes of both blocks 
955f			      ex    DE, HL 
955f			 
955f			      ld    H, B                    ; Store new bigger size into freed block 
955f			      ld    L, C 
955f			      inc   HL 
955f			      inc   HL 
955f			      ld    (HL), E 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			free_check_adjacent_to_prev: 
955f			      ; Check if the freed block is adjacent to the prev free block 
955f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
955f			      ld    H, (IX+3) 
955f			 
955f			      inc   HL                      ; Size of prev free block into DE 
955f			      inc   HL 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      dec   HL 
955f			      dec   HL 
955f			      dec   HL 
955f			 
955f			      add   HL, DE                  ; Add prev block addr and size 
955f			 
955f			      or    A                       ; Clear the carry flag 
955f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
955f			      jr    NZ, free_done 
955f			 
955f			      ; Freed block is adjacent to prev, merge into one bigger block 
955f			      ld    H, B                    ; Load next ptr from freed block into DE 
955f			      ld    L, C 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      push  HL                      ; Save freed block ptr for later 
955f			 
955f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
955f			      ld    H, (IX+3) 
955f			      ld    (HL), E 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			      pop   HL                      ; Restore freed block ptr 
955f			      inc   HL                      ; Load size of freed block into DE 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			      push  DE                      ; Save freed block size for later 
955f			 
955f			      ld    L, (IX+2)               ; Load size of prev block into DE 
955f			      ld    H, (IX+3) 
955f			      inc   HL 
955f			      inc   HL 
955f			      ld    E, (HL) 
955f			      inc   HL 
955f			      ld    D, (HL) 
955f			 
955f			      pop   HL                      ; Add sizes of both blocks 
955f			      add   HL, DE 
955f			      ex    DE, HL 
955f			 
955f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
955f			      ld    H, (IX+3) 
955f			      inc   HL 
955f			      inc   HL 
955f			      ld    (HL), E 
955f			      inc   HL 
955f			      ld    (HL), D 
955f			 
955f			free_done: 
955f			      ld    HL, 4                   ; Clean up stack frame 
955f			      add   HL, SP 
955f			      ld    SP, HL 
955f			 
955f			free_early_exit: 
955f			      pop   IX 
955f			      pop   DE 
955f			      pop   BC 
955f			 
955f			      ret 
955f			 
955f			 
955f			;      .org 0x8000 
955f			; 
955f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
955f			 ;                 .dw   0 
955f			 
955f			endif 
955f			 
955f			 
955f			if MALLOC_4 
955f			 
955f			; My memory allocation code. Very very simple.... 
955f			; allocate space under 250 chars 
955f			 
955f			heap_init: 
955f				; init start of heap as zero 
955f				;  
955f			 
955f				ld hl, heap_start 
955f				ld a, 0 
955f				ld (hl), a      ; empty block 
955f				inc hl 
955f				ld a, 0 
955f				ld (hl), a      ; length of block 
955f				; write end of list 
955f				inc hl 
955f				ld a,(hl) 
955f				inc hl 
955f				ld a,(hl) 
955f				 
955f			 
955f				; init some malloc vars 
955f			 
955f				ld hl, 0 
955f				ld (free_list), hl       ; store last malloc location 
955f			 
955f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
955f				ld a, 0 
955f				ld (hl), a 
955f			 
955f			 
955f				ld hl, heap_start 
955f				;  
955f				  
955f				ret 
955f			 
955f			 
955f			;    free block marker 
955f			;    requested size  
955f			;    pointer to next block 
955f			;    .... 
955f			;    next block marker 
955f			 
955f			 
955f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
955f			; 
955f			 
955f			 
955f			malloc:  
955f				push de 
955f				push bc 
955f				push af 
955f			 
955f				; hl space required 
955f				 
955f				ld c, l    ; hold space   (TODO only a max of 255) 
955f			 
955f			;	inc c     ; TODO BUG need to fix memory leak on push str 
955f			;	inc c 
955f			;	inc c 
955f			;	inc c 
955f			;	inc c 
955f			;	inc c 
955f			;	inc c 
955f			 
955f			 
955f			 
955f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
955f			 
955f				ld a, (free_list+3) 
955f				cp 0 
955f				jr z, .contheap 
955f			 
955f				ld hl, (free_list)     ; get last alloc 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "mrs" 
955f						CALLMONITOR 
955f					endif 
955f				jr .startalloc 
955f			 
955f			.contheap: 
955f				ld hl, heap_start 
955f			 
955f			.startalloc: 
955f			 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "mym" 
955f						CALLMONITOR 
955f					endif 
955f			.findblock: 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "mmf" 
955f						CALLMONITOR 
955f					endif 
955f			 
955f				ld a,(hl)  
955f				; if byte is zero then clear to use 
955f			 
955f				cp 0 
955f				jr z, .foundemptyblock 
955f			 
955f				; if byte is not clear 
955f				;     then byte is offset to next block 
955f			 
955f				inc hl 
955f				ld a, (hl) ; get size 
955f			.nextblock:	inc hl 
955f					ld e, (hl) 
955f					inc hl 
955f					ld d, (hl) 
955f					ex de, hl 
955f			;	inc hl  ; move past the store space 
955f			;	inc hl  ; move past zero index  
955f			 
955f				; TODO detect no more space 
955f			 
955f				push hl 
955f				ld de, heap_end 
955f				call cmp16 
955f				pop hl 
955f				jr nc, .nospace 
955f			 
955f				jr .findblock 
955f			 
955f			.nospace: ld hl, 0 
955f				jp .exit 
955f			 
955f			 
955f			.foundemptyblock:	 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "mme" 
955f						CALLMONITOR 
955f					endif 
955f			 
955f			; TODO has block enough space if reusing??? 
955f			 
955f				;  
955f			 
955f			; see if this block has been previously used 
955f				inc hl 
955f				ld a, (hl) 
955f				dec hl 
955f				cp 0 
955f				jr z, .newblock 
955f			 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "meR" 
955f						CALLMONITOR 
955f					endif 
955f			 
955f			; no reusing previously allocated block 
955f			 
955f			; is it smaller than previously used? 
955f				 
955f				inc hl    ; move to size 
955f				ld a, c 
955f				sub (hl)        ; we want c < (hl) 
955f				dec hl    ; move back to marker 
955f			        jr z, .findblock 
955f			 
955f				; update with the new size which should be lower 
955f			 
955f			        ;inc  hl   ; negate next move. move back to size  
955f			 
955f			.newblock: 
955f				; need to be at marker here 
955f			 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "meN" 
955f						CALLMONITOR 
955f					endif 
955f			 
955f			 
955f				ld a, c 
955f			 
955f				ld (free_list+3), a	 ; flag resume from last malloc  
955f				ld (free_list), hl    ; save out last location 
955f			 
955f			 
955f				;inc a     ; space for length byte 
955f				ld (hl), a     ; save block in use marker 
955f			 
955f				inc hl   ; move to space marker 
955f				ld (hl), a    ; save new space 
955f			 
955f				inc hl   ; move to start of allocated area 
955f				 
955f			;	push hl     ; save where we are - 1  
955f			 
955f			;	inc hl  ; move past zero index  
955f				; skip space to set down new marker 
955f			 
955f				; provide some extra space for now 
955f			 
955f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
955f				inc a 
955f				inc a 
955f			 
955f				push hl   ; save where we are in the node block 
955f			 
955f				call addatohl 
955f			 
955f				; write linked list point 
955f			 
955f				pop de     ; get our node position 
955f				ex de, hl 
955f			 
955f				ld (hl), e 
955f				inc hl 
955f				ld (hl), d 
955f			 
955f				inc hl 
955f			 
955f				; now at start of allocated data so save pointer 
955f			 
955f				push hl 
955f			 
955f				; jump to position of next node and setup empty header in DE 
955f			 
955f				ex de, hl 
955f			 
955f			;	inc hl ; move past end of block 
955f			 
955f				ld a, 0 
955f				ld (hl), a   ; empty marker 
955f				inc hl 
955f				ld (hl), a   ; size 
955f				inc hl  
955f				ld (hl), a   ; ptr 
955f				inc hl 
955f				ld (hl), a   ; ptr 
955f			 
955f			 
955f				pop hl 
955f			 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "mmr" 
955f						CALLMONITOR 
955f					endif 
955f			 
955f			.exit: 
955f				pop af 
955f				pop bc 
955f				pop de  
955f				ret 
955f			 
955f			 
955f			 
955f			 
955f			free:  
955f				push hl 
955f				push af 
955f				; get address in hl 
955f			 
955f					if DEBUG_FORTH_MALLOC_INT 
955f						DMARK "fre" 
955f						CALLMONITOR 
955f					endif 
955f				; data is at hl - move to block count 
955f				dec hl 
955f				dec hl    ; get past pointer 
955f				dec hl 
955f			 
955f				ld a, (hl)    ; need this for a validation check 
955f			 
955f				dec hl    ; move to block marker 
955f			 
955f				; now check that the block count and block marker are the same  
955f			        ; this checks that we are on a malloc node and not random memory 
955f			        ; OK a faint chance this could be a problem but rare - famous last words! 
955f			 
955f				ld c, a 
955f				ld a, (hl)    
955f			 
955f				cp c 
955f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
955f			 
955f				; yes good chance we are on a malloc node 
955f			 
955f				ld a, 0      
955f				ld (hl), a   ; mark as free 
955f			 
955f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
955f			 
955f			.freeignore:  
955f			 
955f				pop af 
955f				pop hl 
955f			 
955f				ret 
955f			 
955f			 
955f			 
955f			endif 
955f			 
955f			; eof 
# End of file firmware_memory.asm
955f			  
955f			; device C  
955f			; Now handled by SPI  
955f			;if SOUND_ENABLE  
955f			;	include "firmware_sound.asm"  
955f			;endif  
955f			  
955f			include "firmware_diags.asm"  
955f			; Hardware diags menu 
955f			 
955f			 
955f			config: 
955f			 
955f 3e 00			ld a, 0 
9561 21 85 95			ld hl, .configmn 
9564 cd df 8a			call menu 
9567			 
9567 fe 00			cp 0 
9569 c8				ret z 
956a			 
956a			;	cp 1 
956a			;	call z, .savetostore 
956a			 
956a fe 01			cp 1 
956c			if STARTUP_V1 
956c cc 9b 95			call z, .selautoload 
956f			endif 
956f			 
956f			if STARTUP_V2 
956f				call z, .enautoload 
956f			endif 
956f fe 02			cp 2 
9571 cc 91 95			call z, .disautoload 
9574			;	cp 3 
9574			;	call z, .selbank 
9574 fe 03			cp 3 
9576 cc b9 95			call z, .debug_tog 
9579 fe 04			cp 4 
957b cc 07 97			call z, .bpsgo 
957e fe 05			cp 5 
9580 cc e2 95			call z, hardware_diags 
9583			if STARTUP_V2 
9583				cp 6 
9583				call z, create_startup 
9583			endif 
9583 18 da			jr config 
9585			 
9585			.configmn: 
9585			;	dw prom_c3 
9585 f5 98			dw prom_c2 
9587 0a 99			dw prom_c2a 
9589			;	dw prom_c2b 
9589			;	dw prom_c4 
9589 29 99			dw prom_m4 
958b 44 99			dw prom_m4b 
958d 4c 99			dw prom_c1 
958f			if STARTUP_V2 
958f				dw prom_c9 
958f			endif 
958f 00 00			dw 0 
9591				 
9591			 
9591			if STARTUP_V2 
9591			.enautoload: 
9591				if STORAGE_SE 
9591				ld a, $fe      ; bit 0 clear 
9591				ld (spi_device), a 
9591			 
9591				call storage_get_block_0 
9591			 
9591				ld a, 1 
9591				ld (store_page+STORE_0_AUTOFILE), a 
9591			 
9591					ld hl, 0 
9591					ld de, store_page 
9591				call storage_write_block	 ; save update 
9591				else 
9591			 
9591				ld hl, prom_notav 
9591				ld de, prom_empty 
9591				call info_panel 
9591				endif 
9591			 
9591			 
9591				ret 
9591			endif 
9591			 
9591			.disautoload: 
9591				if STORAGE_SE 
9591				ld a, $fe      ; bit 0 clear 
9591				ld (spi_device), a 
9591			 
9591				call storage_get_block_0 
9591			 
9591				ld a, 0 
9591				ld (store_page+STORE_0_AUTOFILE), a 
9591			 
9591					ld hl, 0 
9591					ld de, store_page 
9591				call storage_write_block	 ; save update 
9591				else 
9591			 
9591 21 5b 99			ld hl, prom_notav 
9594 11 71 99			ld de, prom_empty 
9597 cd 3f 8a			call info_panel 
959a				endif 
959a			 
959a			 
959a c9				ret 
959b			 
959b			if STARTUP_V1 
959b			 
959b			; Select auto start 
959b			 
959b			.selautoload: 
959b			 
959b				 
959b				if STORAGE_SE 
959b			 
959b					call config_dir 
959b				        ld hl, scratch 
959b					ld a, 0 
959b					call menu 
959b			 
959b					cp 0 
959b					ret z 
959b			 
959b					dec a 
959b			 
959b			 
959b					; locate menu option 
959b			 
959b					ld hl, scratch 
959b					call table_lookup 
959b			 
959b					if DEBUG_FORTH_WORDS 
959b						DMARK "ALl" 
959b						CALLMONITOR 
959b					endif 
959b					; with the pointer to the menu it, the byte following the zero term is the file id 
959b			 
959b					ld a, 0 
959b					ld bc, 50   ; max of bytes to look at 
959b					cpir  
959b			 
959b					if DEBUG_FORTH_WORDS 
959b						DMARK "ALb" 
959b						CALLMONITOR 
959b					endif 
959b					;inc hl 
959b			 
959b					ld a, (hl)   ; file id 
959b					 
959b				        ; save bank and file ids 
959b			 
959b					push af 
959b			 
959b			; TODO need to save to block 0 on bank 1	 
959b			 
959b					call storage_get_block_0 
959b			 
959b					if DEBUG_FORTH_WORDS 
959b						DMARK "AL0" 
959b						CALLMONITOR 
959b					endif 
959b					pop af 
959b			 
959b					ld (store_page+STORE_0_FILERUN),a 
959b					 
959b					; save bank id 
959b			 
959b					ld a,(spi_device) 
959b					ld (store_page+STORE_0_BANKRUN),a 
959b			 
959b					; enable auto run of store file 
959b			 
959b					ld a, 1 
959b					ld (store_page+STORE_0_AUTOFILE),a 
959b			 
959b					; save buffer 
959b			 
959b					ld hl, 0 
959b					ld de, store_page 
959b					if DEBUG_FORTH_WORDS 
959b						DMARK "ALw" 
959b						CALLMONITOR 
959b					endif 
959b				call storage_write_block	 ; save update 
959b			  
959b			 
959b			 
959b			 
959b					ld hl, scratch 
959b					call config_fdir 
959b			 
959b				else 
959b			 
959b 21 5b 99			ld hl, prom_notav 
959e 11 71 99			ld de, prom_empty 
95a1 cd 3f 8a			call info_panel 
95a4			 
95a4				endif 
95a4 c9				ret 
95a5			endif 
95a5			 
95a5			 
95a5			; Select storage bank 
95a5			 
95a5			.selbank: 
95a5			 
95a5			;	if STORAGE_SE 
95a5			;	else 
95a5			 
95a5 21 5b 99			ld hl, prom_notav 
95a8 11 71 99			ld de, prom_empty 
95ab cd 3f 8a			call info_panel 
95ae			;	endif 
95ae				 
95ae c9				ret 
95af			 
95af			if STORAGE_SE 
95af			 
95af			.config_ldir:   
95af				; Load storage bank labels into menu array 
95af			 
95af				 
95af			 
95af			 
95af				ret 
95af			 
95af			 
95af			endif 
95af			 
95af			 
95af			; Save user words to storage 
95af			 
95af			.savetostore: 
95af			 
95af			;	if STORAGE_SE 
95af			; 
95af			;		call config_dir 
95af			;	        ld hl, scratch 
95af			;		ld a, 0 
95af			;		call menu 
95af			;		 
95af			;		ld hl, scratch 
95af			;		call config_fdir 
95af			; 
95af			;	else 
95af			 
95af 21 5b 99			ld hl, prom_notav 
95b2 11 71 99			ld de, prom_empty 
95b5 cd 3f 8a			call info_panel 
95b8			 
95b8			;	endif 
95b8			 
95b8 c9				ret 
95b9			 
95b9			if STARTUP_V2 
95b9			 
95b9			create_startup: 
95b9			 
95b9				ld a, 0 
95b9				ld hl, .crstart 
95b9				call menu 
95b9			 
95b9				cp 0 
95b9				ret z 
95b9			 
95b9				cp 1 
95b9				call z, .genlsword 
95b9				cp 2 
95b9				call z, .genedword 
95b9			 
95b9				cp 3 
95b9				call z, .gendemword 
95b9			 
95b9				cp 4 
95b9				call z, .genutlword 
95b9				cp 5 
95b9				call z, .genspiword 
95b9				cp 6 
95b9				call z, .genkeyword 
95b9				cp 7 
95b9				call z, .gensoundword 
95b9				jr create_startup 
95b9			 
95b9			.gensoundword: 
95b9				ld hl, crs_sound 
95b9				ld de, .soundworddef 
95b9				call .genfile 
95b9				ret 
95b9			.genlsword: 
95b9				ld hl, crs_s1 
95b9				ld de, .lsworddef 
95b9				call .genfile 
95b9				ret 
95b9			 
95b9			.genedword: 
95b9				ld de, .edworddef 
95b9				ld hl, crs_s2 
95b9				call .genfile 
95b9				ret 
95b9			 
95b9			.gendemword: 
95b9				ld de, .demoworddef 
95b9				ld hl, crs_s3 
95b9				call .genfile 
95b9				ret 
95b9			 
95b9			.genutlword: 
95b9				ld hl, crs_s4 
95b9				ld de, .utilwordef 
95b9				call .genfile 
95b9				ret 
95b9			.genspiword: 
95b9				ld hl, crs_s5 
95b9				ld de, .spiworddef 
95b9				call .genfile 
95b9				ret 
95b9			.genkeyword: 
95b9				ld hl, crs_s6 
95b9				ld de, .keyworddef 
95b9				call .genfile 
95b9				ret 
95b9			 
95b9			; hl - points to file name 
95b9			; de - points to strings to add to file 
95b9			 
95b9			.genfile: 
95b9				push hl 
95b9				push de 
95b9			 
95b9				call clear_display 
95b9				ld a, display_row_1 
95b9				ld de, .genfiletxt 
95b9				call str_at_display 
95b9				call update_display 
95b9			 
95b9				pop de 
95b9				pop hl 
95b9			 
95b9			 
95b9				push de 
95b9				call storage_create 
95b9				; id in hl 
95b9				pop de   ; table of strings to add 
95b9			 
95b9			.genloop: 
95b9			 
95b9				push hl ; save id for next time around 
95b9				push de ; save de for next time around 
95b9			 
95b9				ex de, hl 
95b9				call loadwordinhl 
95b9				ex de, hl 
95b9			 
95b9				; need hl to be the id 
95b9				; need de to be the string ptr 
95b9				 
95b9				call storage_append 
95b9			 
95b9				pop de 
95b9				pop hl 
95b9			 
95b9				inc de 
95b9				inc de 
95b9			 
95b9				ld a,(de) 
95b9				cp 0 
95b9				jr nz, .genloop 
95b9				inc de 
95b9				ld a, (de) 
95b9				dec de 
95b9				cp 0 
95b9				jr nz, .genloop	 
95b9			 
95b9				ret 
95b9			 
95b9			.genfiletxt:  db "Creating file...",0 
95b9			 
95b9			.soundworddef: 
95b9				dw sound1 
95b9				dw sound2 
95b9				dw sound3 
95b9				dw sound4 
95b9				dw sound5 
95b9				dw sound6 
95b9				dw sound7 
95b9				dw sound8 
95b9				dw sound9 
95b9				dw 0 
95b9			 
95b9			.utilwordef: 
95b9				dw strncpy 
95b9				dw type 
95b9				dw clrstack 
95b9				dw longread 
95b9				dw start1 
95b9				dw start2 
95b9			; duplicated 
95b9			;	dw start3b 
95b9			;	dw start3c 
95b9				dw list 
95b9				dw 0 
95b9			 
95b9			.lsworddef: 
95b9				dw start3b 
95b9				dw 0 
95b9			 
95b9			.edworddef: 
95b9				dw edit1 
95b9				dw edit2 
95b9				dw edit3 
95b9				dw 0 
95b9			 
95b9			.demoworddef: 
95b9				dw test5 
95b9				dw test6 
95b9				dw test7 
95b9				dw test8 
95b9				dw test9 
95b9				dw test10 
95b9				dw game1 
95b9				dw game1a 
95b9				dw game1b 
95b9				dw game1c 
95b9				dw game1d 
95b9				dw game1s 
95b9				dw game1t 
95b9				dw game1f 
95b9				dw game1z 
95b9				dw game1zz 
95b9				dw ssv2 
95b9				dw ssv3 
95b9				dw ssv4 
95b9				dw ssv5 
95b9				dw ssv1 
95b9				dw ssv1cpm	 
95b9				dw game2b 
95b9				dw game2bf 
95b9				dw game2mba 
95b9				dw game2mbas	 
95b9				dw game2mbht 
95b9				dw game2mbms 
95b9				dw game2mb 
95b9				dw game3w 
95b9				dw game3p 
95b9				dw game3sc 
95b9				dw game3vsi 
95b9				dw game3vs 
95b9				dw 0 
95b9			 
95b9			 
95b9			.spiworddef: 
95b9			 
95b9			    dw spi1 
95b9			    dw spi2 
95b9			    dw spi2b 
95b9			    dw spi3 
95b9			    dw spi4 
95b9			    dw spi5 
95b9			;    dw spi6 
95b9			;    dw spi7 
95b9			 
95b9			;    dw spi8 
95b9			;    dw spi9 
95b9			;    dw spi10 
95b9			    dw 0 
95b9			 
95b9			.keyworddef: 
95b9			 
95b9				dw keyup 
95b9				dw keydown 
95b9				dw keyleft 
95b9				dw keyright 
95b9				dw 	keyf1 
95b9				dw keyf2 
95b9				dw keyf3 
95b9				dw keyf4 
95b9				dw keyf5 
95b9				dw keyf6 
95b9				dw keyf7 
95b9				dw keyf8 
95b9				dw keyf9 
95b9				dw keyf10 
95b9				dw keyf11 
95b9				dw keyf12 
95b9				dw keytab 
95b9				dw keycr 
95b9				dw keyhome 
95b9				dw keyend 
95b9				dw keybs 
95b9				dw 0 
95b9			 
95b9			.crstart: 
95b9				dw crs_s1 
95b9				dw crs_s2 
95b9				dw crs_s3 
95b9				dw crs_s4 
95b9				dw crs_s5 
95b9				dw crs_s6 
95b9				dw crs_sound 
95b9				dw 0 
95b9			 
95b9			endif 
95b9			 
95b9			 
95b9			if STORAGE_SE 
95b9			 
95b9			config_fdir: 
95b9				; using the scratch dir go through and release the memory allocated for each string 
95b9				 
95b9				ld hl, scratch 
95b9			.cfdir:	ld e,(hl) 
95b9				inc hl 
95b9				ld d,(hl) 
95b9				inc hl 
95b9			 
95b9				ex de, hl 
95b9				call ishlzero 
95b9				ret z     ; return on null pointer 
95b9				call free 
95b9				ex de, hl 
95b9				jr .cfdir 
95b9			 
95b9			 
95b9				ret 
95b9			 
95b9			 
95b9			config_dir: 
95b9			 
95b9				; for the config menus that need to build a directory of storage call this routine 
95b9				; it will construct a menu in scratch to pass to menu 
95b9			 
95b9				; open storage device 
95b9			 
95b9				; execute DIR to build a list of files and their ids into scratch in menu format 
95b9				; once the menu has finished then will need to call config_fdir to release the strings 
95b9				 
95b9				; c = number items 
95b9			 
95b9				 
95b9				call storage_get_block_0 
95b9			 
95b9				ld hl, store_page     ; get current id count 
95b9				ld b, (hl) 
95b9				ld c, 0    ; count of files   
95b9			 
95b9			 
95b9				ld hl, scratch 
95b9				ld (store_tmp2), hl    ; location to poke strings 
95b9			 
95b9				; check for empty drive 
95b9			 
95b9				ld a, 0 
95b9				cp b 
95b9				jp z, .dirdone 
95b9			 
95b9				 
95b9					if DEBUG_FORTH_WORDS 
95b9						DMARK "Cdc" 
95b9						CALLMONITOR 
95b9					endif 
95b9			 
95b9			 
95b9			.diritem:	 
95b9				push bc 
95b9				; for each of the current ids do a search for them and if found push to stack 
95b9			 
95b9					ld hl, STORE_BLOCK_PHY 
95b9					ld d, 0		 ; look for extent 0 of block id as this contains file name 
95b9					ld e,b 
95b9			 
95b9					call storage_findnextid 
95b9			 
95b9			 
95b9					; if found hl will be non zero 
95b9			 
95b9					call ishlzero 
95b9					jr z, .dirnotfound 
95b9			 
95b9					; increase count 
95b9			 
95b9					pop bc	 
95b9					inc c 
95b9					push bc 
95b9					 
95b9			 
95b9					; get file header and push the file name 
95b9			 
95b9					ld de, store_page 
95b9					call storage_read_block 
95b9			 
95b9					; push file id to stack 
95b9				 
95b9					ld a, (store_page) 
95b9					ld h, 0 
95b9					ld l, a 
95b9			 
95b9					;call forth_push_numhl 
95b9					; TODO store id 
95b9			 
95b9					push hl 
95b9			 
95b9					; push extent count to stack  
95b9				 
95b9					ld hl, store_page+3 
95b9			 
95b9					; get file name length 
95b9			 
95b9					call strlenz   
95b9			 
95b9					inc hl   ; cover zero term 
95b9					inc hl  ; stick the id at the end of the area 
95b9			 
95b9					push hl 
95b9					pop bc    ; move length to bc 
95b9			 
95b9					call malloc 
95b9			 
95b9					; TODO save malloc area to scratch 
95b9			 
95b9					ex de, hl 
95b9					ld hl, (store_tmp2) 
95b9					ld (hl), e 
95b9					inc hl 
95b9					ld (hl), d 
95b9					inc hl 
95b9					ld (store_tmp2), hl 
95b9			 
95b9					 
95b9			 
95b9					;pop hl   ; get source 
95b9			;		ex de, hl    ; swap aronund	 
95b9			 
95b9					ld hl, store_page+3 
95b9					if DEBUG_FORTH_WORDS 
95b9						DMARK "CFd" 
95b9						CALLMONITOR 
95b9					endif 
95b9					ldir 
95b9			 
95b9					; de is past string, move back one and store id 
95b9					 
95b9					dec de 
95b9			 
95b9					; store file id 
95b9			 
95b9					pop hl 
95b9					ex de,hl 
95b9					ld (hl), e 
95b9			 
95b9					if DEBUG_FORTH_WORDS 
95b9						DMARK "Cdi" 
95b9						CALLMONITOR 
95b9					endif 
95b9					 
95b9			.dirnotfound: 
95b9					pop bc     
95b9					djnz .diritem 
95b9				 
95b9			.dirdone:	 
95b9			 
95b9					ld a, 0 
95b9					ld hl, (store_tmp2) 
95b9					ld (hl), a 
95b9					inc hl 
95b9					ld (hl), a 
95b9					inc hl 
95b9					; push a count of the dir items found 
95b9			 
95b9			;		ld h, 0 
95b9			;		ld l, c 
95b9			 
95b9				ret 
95b9			 
95b9			endif 
95b9			 
95b9			 
95b9			; Settings 
95b9			; Run  
95b9			 
95b9			 
95b9			 
95b9			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
95b9			;;hd_menu2:   db "        2: Editor",0   
95b9			;hd_menu2:   db "        2: Editor       6: Menu",0   
95b9			;hd_menu3:   db "        3: Storage",0 
95b9			;hd_menu4:   db "0=quit  4: Debug",0 
95b9			;hd_don:     db "ON",0 
95b9			;hd_doff:     db "OFF",0 
95b9			; 
95b9			; 
95b9			; 
95b9			;hardware_diags_old:       
95b9			; 
95b9			;.diagmenu: 
95b9			;	call clear_display 
95b9			;	ld a, display_row_1 
95b9			;	ld de, hd_menu1 
95b9			;	call str_at_display 
95b9			; 
95b9			;	ld a, display_row_2 
95b9			;	ld de, hd_menu2 
95b9			;	call str_at_display 
95b9			; 
95b9			;	ld a, display_row_3 
95b9			;	ld de, hd_menu3 
95b9			;	call str_at_display 
95b9			; 
95b9			;	ld a,  display_row_4 
95b9			;	ld de, hd_menu4 
95b9			;	call str_at_display 
95b9			; 
95b9			;	; display debug state 
95b9			; 
95b9			;	ld de, hd_don 
95b9			;	ld a, (os_view_disable) 
95b9			;	cp 0 
95b9			;	jr z, .distog 
95b9			;	ld de, hd_doff 
95b9			;.distog: ld a, display_row_4+17 
95b9			;	call str_at_display 
95b9			; 
95b9			;	call update_display 
95b9			; 
95b9			;	call cin_wait 
95b9			; 
95b9			; 
95b9			; 
95b9			;	cp '4' 
95b9			;	jr nz, .diagn1 
95b9			; 
95b9			;	; debug toggle 
95b9			; 
95b9			;	ld a, (os_view_disable) 
95b9			;	ld b, '*' 
95b9			;	cp 0 
95b9			;	jr z, .debtog 
95b9			;	ld b, 0 
95b9			;.debtog:	 
95b9			;	ld a,b 
95b9			;	ld (os_view_disable),a 
95b9			; 
95b9			;.diagn1: cp '0' 
95b9			;	 ret z 
95b9			; 
95b9			;;	cp '1' 
95b9			;;       jp z, matrix	 
95b9			;;   TODO keyboard matrix test 
95b9			; 
95b9			;	cp '2' 
95b9			;	jp z, .diagedit 
95b9			; 
95b9			;;	cp '6' 
95b9			;;	jp z, .menutest 
95b9			;;if ENABLE_BASIC 
95b9			;;	cp '6' 
95b9			;;	jp z, basic 
95b9			;;endif 
95b9			 ; 
95b9			;	jp .diagmenu 
95b9			; 
95b9			; 
95b9			;	ret 
95b9			 
95b9			 
95b9			.debug_tog: 
95b9 21 03 96			ld hl, .menudebug 
95bc				 
95bc			;	ld a, (os_view_disable) 
95bc			;	cp '*' 
95bc 3a 6f ee			ld a,(debug_vector) 
95bf fe c9			cp $C9   ; RET 
95c1 20 04			jr nz,.tdon  
95c3 3e 01			ld a, 1 
95c5 18 02			jr .tog1 
95c7 3e 00		.tdon: ld a, 0 
95c9			 
95c9			.tog1: 
95c9 cd df 8a			call menu 
95cc fe 00			cp 0 
95ce c8				ret z 
95cf fe 01			cp 1    ; disable debug 
95d1 28 04			jr z, .dtog0 
95d3 3e 2a			ld a, '*' 
95d5 18 05			jr .dtogset 
95d7			.dtog0:  
95d7				;ld a, 0 
95d7 cd f5 96			call bp_on 
95da 18 dd			jr .debug_tog 
95dc			.dtogset:  
95dc				; ld (os_view_disable), a 
95dc cd 01 97			call bp_off 
95df c3 b9 95			jp .debug_tog 
95e2			 
95e2			 
95e2			hardware_diags:       
95e2			 
95e2			.diagm: 
95e2 21 f5 95			ld hl, .menuitems 
95e5 3e 00			ld a, 0 
95e7 cd df 8a			call menu 
95ea			 
95ea fe 00		         cp 0 
95ec c8				 ret z 
95ed			 
95ed fe 02			cp 2 
95ef ca 4e 96			jp z, .diagedit 
95f2			 
95f2			;	cp '6' 
95f2			;	jp z, .menutest 
95f2			;if ENABLE_BASIC 
95f2			;	cp '6' 
95f2			;	jp z, basic 
95f2			;endif 
95f2			  
95f2 c3 e2 95			jp .diagm 
95f5			 
95f5				 
95f5 09 96		.menuitems:   	dw .m1 
95f7 14 96				dw .m2 
95f9 1b 96				dw .m3 
95fb 23 96				dw .m5 
95fd 29 96				dw .m5a 
95ff 32 96				dw .m5b 
9601 00 00				dw 0 
9603			 
9603			.menudebug: 
9603 3b 96				dw .m6 
9605 44 96				dw .m7 
9607 00 00				dw 0 
9609			 
9609 .. 00		.m1:   db "Key Matrix",0 
9614 .. 00		.m2:   db "Editor",0 
961b .. 00		.m3:   db "Storage",0 
9623 .. 00		.m5:   db "Sound",0 
9629 .. 00		.m5a:  db "RAM Test",0 
9632 .. 00		.m5b:  db "LCD Test",0 
963b			 
963b .. 00		.m6:   db "Debug ON",0 
9644 .. 00		.m7:   db "Debug OFF",0 
964e			 
964e			; debug editor 
964e			 
964e			.diagedit: 
964e			 
964e 21 c1 e2			ld hl, scratch 
9651			;	ld bc, 250 
9651			;	ldir 
9651				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9651 3e 00			ld a, 0 
9653 77				ld (hl), a 
9654 23				inc hl 
9655 77				ld (hl), a 
9656 23				inc hl 
9657 77				ld (hl), a 
9658			 
9658 cd ae 8a		        call clear_display 
965b cd d1 8a			call update_display 
965e				;ld a, 1 
965e				;ld (hardware_diag), a 
965e			.diloop: 
965e 3e 00			ld a, display_row_1 
9660 0e 00			ld c, 0 
9662 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9664 1e 28			ld e, 40 
9666			 
9666 21 c1 e2			ld hl, scratch	 
9669 cd 08 8d			call input_str 
966c			 
966c 3e 28			ld a, display_row_2 
966e 11 c1 e2			ld de, scratch 
9671 cd c1 8a			call str_at_display 
9674 cd d1 8a			call update_display 
9677			 
9677 c3 5e 96			jp .diloop 
967a			 
967a			 
967a			; pass word in hl 
967a			; a has display location 
967a			display_word_at: 
967a f5				push af 
967b e5				push hl 
967c 7c				ld a,h 
967d 21 c6 e5			ld hl, os_word_scratch 
9680 cd f4 91			call hexout 
9683 e1				pop hl 
9684 7d				ld a,l 
9685 21 c8 e5			ld hl, os_word_scratch+2 
9688 cd f4 91			call hexout 
968b 21 ca e5			ld hl, os_word_scratch+4 
968e 3e 00			ld a,0 
9690 77				ld (hl),a 
9691 11 c6 e5			ld de,os_word_scratch 
9694 f1				pop af 
9695 cd c1 8a				call str_at_display 
9698 c9				ret 
9699			 
9699			display_ptr_state: 
9699			 
9699				; to restore afterwards 
9699			 
9699 d5				push de 
969a c5				push bc 
969b e5				push hl 
969c f5				push af 
969d			 
969d				; for use in here 
969d			 
969d			;	push bc 
969d			;	push de 
969d			;	push hl 
969d			;	push af 
969d			 
969d cd ae 8a			call clear_display 
96a0			 
96a0 11 78 98			ld de, .ptrstate 
96a3 3e 00			ld a, display_row_1 
96a5 cd c1 8a			call str_at_display 
96a8			 
96a8				; display debug step 
96a8			 
96a8			 
96a8 11 6b ee			ld de, debug_mark 
96ab 3e 26			ld a, display_row_1+display_cols-2 
96ad cd c1 8a			call str_at_display 
96b0			 
96b0				; display a 
96b0 11 82 98			ld de, .ptrcliptr 
96b3 3e 28			ld a, display_row_2 
96b5 cd c1 8a			call str_at_display 
96b8			 
96b8 f1				pop af 
96b9 2a 40 ea			ld hl,(cli_ptr) 
96bc 3e 30			ld a, display_row_2+8 
96be cd 7a 96			call display_word_at 
96c1			 
96c1			 
96c1				; display hl 
96c1			 
96c1			 
96c1 11 8a 98			ld de, .ptrclioptr 
96c4 3e 32			ld a, display_row_2+10 
96c6 cd c1 8a			call str_at_display 
96c9			; 
96c9			;	pop hl 
96c9 3e 35			ld a, display_row_2+13 
96cb 2a 3e ea			ld hl,(cli_origptr) 
96ce cd 7a 96			call display_word_at 
96d1			; 
96d1			;	 
96d1			;	; display de 
96d1			 
96d1			;	ld de, .regstatede 
96d1			;	ld a, display_row_3 
96d1			;	call str_at_display 
96d1			 
96d1			;	pop de 
96d1			;	ld h,d 
96d1			;	ld l, e 
96d1			;	ld a, display_row_3+3 
96d1			;	call display_word_at 
96d1			 
96d1			 
96d1				; display bc 
96d1			 
96d1			;	ld de, .regstatebc 
96d1			;	ld a, display_row_3+10 
96d1			;	call str_at_display 
96d1			 
96d1			;	pop bc 
96d1			;	ld h,b 
96d1			;	ld l, c 
96d1			;	ld a, display_row_3+13 
96d1			;	call display_word_at 
96d1			 
96d1			 
96d1				; display dsp 
96d1			 
96d1			;	ld de, .regstatedsp 
96d1			;	ld a, display_row_4 
96d1			;	call str_at_display 
96d1			 
96d1				 
96d1			;	ld hl,(cli_data_sp) 
96d1			;	ld a, display_row_4+4 
96d1			;	call display_word_at 
96d1			 
96d1				; display rsp 
96d1			 
96d1 11 b9 98			ld de, .regstatersp 
96d4 3e 82			ld a, display_row_4+10 
96d6 cd c1 8a			call str_at_display 
96d9			 
96d9				 
96d9 2a f2 e9			ld hl,(cli_ret_sp) 
96dc 3e 86			ld a, display_row_4+14 
96de cd 7a 96			call display_word_at 
96e1			 
96e1 cd d1 8a			call update_display 
96e4			 
96e4 cd f1 89			call delay1s 
96e7 cd f1 89			call delay1s 
96ea cd f1 89			call delay1s 
96ed			 
96ed			 
96ed cd d7 9c			call next_page_prompt 
96f0			 
96f0				; restore  
96f0			 
96f0 f1				pop af 
96f1 e1				pop hl 
96f2 c1				pop bc 
96f3 d1				pop de 
96f4 c9				ret 
96f5			 
96f5			; Update the break point vector so that the user can hook a new routine 
96f5			 
96f5			bp_on: 
96f5 3e c3			ld a, $c3    ; JP 
96f7 32 6f ee			ld (debug_vector), a 
96fa 21 07 97			ld hl, break_point_state 
96fd 22 70 ee			ld (debug_vector+1), hl 
9700 c9				ret 
9701			 
9701			bp_off: 
9701 3e c9			ld a, $c9    ; RET 
9703 32 6f ee			ld (debug_vector), a 
9706 c9				ret 
9707			 
9707			 
9707			break_point_state: 
9707			;	push af 
9707			; 
9707			;	; see if disabled 
9707			; 
9707			;	ld a, (os_view_disable) 
9707			;	cp '*' 
9707			;	jr nz, .bpsgo 
9707			;	pop af 
9707			;	ret 
9707			 
9707			.bpsgo: 
9707			;	pop af 
9707 f5				push af 
9708 22 a3 e2			ld (os_view_hl), hl 
970b ed 53 a1 e2		ld (os_view_de), de 
970f ed 43 9f e2		ld (os_view_bc), bc 
9713 e5				push hl 
9714 6f				ld l, a 
9715 26 00			ld h, 0 
9717 22 a5 e2			ld (os_view_af),hl 
971a			 
971a 21 b1 ed				ld hl, display_fb0 
971d 22 cc eb				ld (display_fb_active), hl 
9720 e1				pop hl	 
9721			 
9721 3e 31			ld a, '1' 
9723 fe 2a		.bps1:  cp '*' 
9725 cc 01 97			call z, bp_off 
9728			;	jr nz, .bps1b 
9728			;	ld (os_view_disable),a 
9728 fe 31		.bps1b:  cp '1' 
972a 20 14			jr nz, .bps2 
972c			 
972c				; display reg 
972c			 
972c				 
972c			 
972c 3a a5 e2			ld a, (os_view_af) 
972f 2a a3 e2			ld hl, (os_view_hl) 
9732 ed 5b a1 e2		ld de, (os_view_de) 
9736 ed 4b 9f e2		ld bc, (os_view_bc) 
973a cd d4 97			call display_reg_state 
973d c3 c0 97			jp .bpschk 
9740			 
9740 fe 32		.bps2:  cp '2' 
9742 20 08			jr nz, .bps3 
9744				 
9744				; display hl 
9744 2a a3 e2			ld hl, (os_view_hl) 
9747 cd be 98			call display_dump_at_hl 
974a			 
974a 18 74			jr .bpschk 
974c			 
974c fe 33		.bps3:  cp '3' 
974e 20 08			jr nz, .bps4 
9750			 
9750			        ; display de 
9750 2a a1 e2			ld hl, (os_view_de) 
9753 cd be 98			call display_dump_at_hl 
9756			 
9756 18 68			jr .bpschk 
9758 fe 34		.bps4:  cp '4' 
975a 20 08			jr nz, .bps5 
975c			 
975c			        ; display bc 
975c 2a 9f e2			ld hl, (os_view_bc) 
975f cd be 98			call display_dump_at_hl 
9762			 
9762 18 5c			jr .bpschk 
9764 fe 35		.bps5:  cp '5' 
9766 20 08		        jr nz, .bps7 
9768			 
9768				; display cur ptr 
9768 2a 40 ea			ld hl, (cli_ptr) 
976b cd be 98			call display_dump_at_hl 
976e			 
976e 18 50			jr .bpschk 
9770 fe 36		.bps7:  cp '6' 
9772 20 08			jr nz, .bps8b 
9774				 
9774				; display cur orig ptr 
9774 2a 3e ea			ld hl, (cli_origptr) 
9777 cd be 98			call display_dump_at_hl 
977a 18 44			jr .bpschk 
977c fe 37		.bps8b:  cp '7' 
977e 20 08			jr nz, .bps9 
9780				 
9780				; display dsp 
9780 2a ee e9			ld hl, (cli_data_sp) 
9783 cd be 98			call display_dump_at_hl 
9786			 
9786 18 38			jr .bpschk 
9788 fe 39		.bps9:  cp '9' 
978a 20 05			jr nz, .bps8c 
978c				 
978c				; display SP 
978c			;	ld hl, sp 
978c cd be 98			call display_dump_at_hl 
978f			 
978f 18 2f			jr .bpschk 
9791 fe 38		.bps8c:  cp '8' 
9793 20 08			jr nz, .bps8d 
9795				 
9795				; display rsp 
9795 2a f2 e9			ld hl, (cli_ret_sp) 
9798 cd be 98			call display_dump_at_hl 
979b			 
979b 18 23			jr .bpschk 
979d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
979f 20 05			jr nz, .bps8 
97a1 cd a5 9a			call monitor 
97a4			 
97a4 18 1a			jr .bpschk 
97a6 fe 30		.bps8:  cp '0' 
97a8 20 16			jr nz, .bpschk 
97aa			 
97aa 21 10 ed				ld hl, display_fb1 
97ad 22 cc eb				ld (display_fb_active), hl 
97b0 cd d1 8a				call update_display 
97b3			 
97b3				;ld a, (os_view_af) 
97b3 2a a3 e2			ld hl, (os_view_hl) 
97b6 ed 5b a1 e2		ld de, (os_view_de) 
97ba ed 4b 9f e2		ld bc, (os_view_bc) 
97be f1				pop af 
97bf c9				ret 
97c0			 
97c0			.bpschk:   
97c0 cd f1 89			call delay1s 
97c3 3e 9f		ld a,display_row_4 + display_cols - 1 
97c5 11 d5 9c		        ld de, endprg 
97c8 cd c1 8a			call str_at_display 
97cb cd d1 8a			call update_display 
97ce cd e7 e6			call cin_wait 
97d1			 
97d1 c3 23 97			jp .bps1 
97d4			 
97d4			 
97d4			display_reg_state: 
97d4			 
97d4				; to restore afterwards 
97d4			 
97d4 d5				push de 
97d5 c5				push bc 
97d6 e5				push hl 
97d7 f5				push af 
97d8			 
97d8				; for use in here 
97d8			 
97d8 c5				push bc 
97d9 d5				push de 
97da e5				push hl 
97db f5				push af 
97dc			 
97dc cd ae 8a			call clear_display 
97df			 
97df 11 94 98			ld de, .regstate 
97e2 3e 00			ld a, display_row_1 
97e4 cd c1 8a			call str_at_display 
97e7			 
97e7				; display debug step 
97e7			 
97e7			 
97e7 11 6b ee			ld de, debug_mark 
97ea 3e 25			ld a, display_row_1+display_cols-3 
97ec cd c1 8a			call str_at_display 
97ef			 
97ef				; display a 
97ef 11 b0 98			ld de, .regstatea 
97f2 3e 28			ld a, display_row_2 
97f4 cd c1 8a			call str_at_display 
97f7			 
97f7 e1				pop hl 
97f8			;	ld h,0 
97f8			;	ld l, a 
97f8 3e 2b			ld a, display_row_2+3 
97fa cd 7a 96			call display_word_at 
97fd			 
97fd			 
97fd				; display hl 
97fd			 
97fd			 
97fd 11 a4 98			ld de, .regstatehl 
9800 3e 32			ld a, display_row_2+10 
9802 cd c1 8a			call str_at_display 
9805			 
9805 e1				pop hl 
9806 3e 35			ld a, display_row_2+13 
9808 cd 7a 96			call display_word_at 
980b			 
980b				 
980b				; display de 
980b			 
980b 11 a8 98			ld de, .regstatede 
980e 3e 50			ld a, display_row_3 
9810 cd c1 8a			call str_at_display 
9813			 
9813 e1				pop hl 
9814			;	ld h,d 
9814			;	ld l, e 
9814 3e 53			ld a, display_row_3+3 
9816 cd 7a 96			call display_word_at 
9819			 
9819			 
9819				; display bc 
9819			 
9819 11 ac 98			ld de, .regstatebc 
981c 3e 5a			ld a, display_row_3+10 
981e cd c1 8a			call str_at_display 
9821			 
9821 e1				pop hl 
9822			;	ld h,b 
9822			;	ld l, c 
9822 3e 5d			ld a, display_row_3+13 
9824 cd 7a 96			call display_word_at 
9827			 
9827			 
9827				; display dsp 
9827			 
9827 11 b4 98			ld de, .regstatedsp 
982a 3e 78			ld a, display_row_4 
982c cd c1 8a			call str_at_display 
982f			 
982f				 
982f 2a ee e9			ld hl,(cli_data_sp) 
9832 3e 7c			ld a, display_row_4+4 
9834 cd 7a 96			call display_word_at 
9837			 
9837				; display rsp 
9837			 
9837 11 b9 98			ld de, .regstatersp 
983a 3e 82			ld a, display_row_4+10 
983c cd c1 8a			call str_at_display 
983f			 
983f				 
983f 2a f2 e9			ld hl,(cli_ret_sp) 
9842 3e 86			ld a, display_row_4+14 
9844 cd 7a 96			call display_word_at 
9847			 
9847 cd d1 8a			call update_display 
984a			 
984a			;	call delay1s 
984a			;	call delay1s 
984a			;	call delay1s 
984a			 
984a			 
984a			;	call next_page_prompt 
984a			 
984a				; restore  
984a			 
984a f1				pop af 
984b e1				pop hl 
984c c1				pop bc 
984d d1				pop de 
984e c9				ret 
984f			 
984f .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9863 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9878 .. 00		.ptrstate:	db "Ptr State",0 
9882 .. 00		.ptrcliptr:     db "cli_ptr",0 
988a .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9894 .. 00		.regstate:	db "Reg State (1/0)",0 
98a4 .. 00		.regstatehl:	db "HL:",0 
98a8 .. 00		.regstatede:	db "DE:",0 
98ac .. 00		.regstatebc:	db "BC:",0 
98b0 .. 00		.regstatea:	db "A :",0 
98b4 .. 00		.regstatedsp:	db "DSP:",0 
98b9 .. 00		.regstatersp:	db "RSP:",0 
98be			 
98be			display_dump_at_hl: 
98be e5				push hl 
98bf d5				push de 
98c0 c5				push bc 
98c1 f5				push af 
98c2			 
98c2 22 e4 e5			ld (os_cur_ptr),hl	 
98c5 cd ae 8a			call clear_display 
98c8 cd df 9b			call dumpcont 
98cb			;	call delay1s 
98cb			;	call next_page_prompt 
98cb			 
98cb			 
98cb f1				pop af 
98cc c1				pop bc 
98cd d1				pop de 
98ce e1				pop hl 
98cf c9				ret 
98d0			 
98d0			;if ENABLE_BASIC 
98d0			;	include "nascombasic.asm" 
98d0			;	basic: 
98d0			;	include "forth/FORTH.ASM" 
98d0			;endif 
98d0			 
98d0			; eof 
98d0			 
98d0			 
# End of file firmware_diags.asm
98d0			  
98d0			include "firmware_prompts.asm"  
98d0			; Prompts  
98d0			 
98d0			; boot messages 
98d0			 
98d0 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
98e5 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
98f5			 
98f5			 
98f5			; config menus 
98f5			 
98f5			;prom_c3: db "Add Dictionary To File",0 
98f5			 
98f5			if STARTUP_V1 
98f5 .. 00		prom_c2: db "Select Autoload File",0 
990a .. 00		prom_c2a: db "Disable Autoload File", 0 
9920			endif 
9920			 
9920			if STARTUP_V2 
9920			prom_c2: db "Enable Autoload Files",0 
9920			prom_c2a: db "Disable Autoload Files", 0 
9920			 
9920			crs_s1: db "*ls-word", 0 
9920			crs_s2: db "*ed-word", 0 
9920			crs_s3: db "*Demo-Programs", 0 
9920			crs_s4: db "*Utils", 0 
9920			crs_s5: db "*SPI-Util", 0 
9920			crs_s6: db "*Key-constants", 0 
9920			crs_sound: db "*Sound-Util", 0 
9920			 
9920			 
9920			 
9920			endif 
9920			;prom_c2b: db "Select Storage Bank",0 
9920 .. 00		prom_c4: db "Settings",0 
9929 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9944 .. 00		prom_m4b:   db "Monitor",0 
994c .. 00		prom_c1: db "Hardware Diags",0 
995b			 
995b			 
995b			if STARTUP_V2 
995b			prom_c9: db "Create Startup Files",0 
995b			endif 
995b			 
995b .. 00		prom_notav:    db "Feature not available",0 
9971 .. 00		prom_empty:    db "",0 
9972			 
9972			; eof 
9972			 
# End of file firmware_prompts.asm
9972			  
9972			  
9972			; eof  
9972			  
# End of file firmware.asm
9972			 
9972			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9972			;if BASE_KEV  
9972			;baseram: equ 08000h 
9972			;endif 
9972			 
9972			;if BASE_SC114 
9972			;baseram:     equ    endofcode 
9972			;endif 
9972			 
9972			 
9972			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
9972			 
9972			; start system 
9972			 
9972			coldstart: 
9972				; set sp 
9972				; di/ei 
9972			 
9972 f3				di 
9973 31 00 f0			ld sp, tos 
9976 cd 31 e6			call init_nmi 
9979			;	ei 
9979			 
9979				; init spinner 
9979 3e 00			ld a,0 
997b 32 c6 eb			ld (display_active), a 
997e			 
997e				; disable breakpoint by default 
997e			 
997e				;ld a,'*' 
997e			;	ld a,' ' 
997e			;	ld (os_view_disable),a 
997e			 
997e				; set break point vector as new break point on or off 
997e cd 01 97			call bp_off 
9981			 
9981				; init hardware 
9981			 
9981				; init keyboard and screen hardware 
9981			 
9981 cd 1b 80			call hardware_init 
9984			 
9984			 
9984 cd f1 89			call delay1s 
9987 3e 58			ld a, display_row_3+8 
9989 11 03 80			ld de, buildtime 
998c cd c1 8a			call str_at_display 
998f cd d1 8a			call update_display 
9992			 
9992 cd f1 89			call delay1s 
9995 cd f1 89			call delay1s 
9998 cd f1 89			call delay1s 
999b			 
999b				; detect if any keys are held down to enable breakpoints at start up 
999b			 
999b cd ed e6			call cin  
999e fe 00			cp 0 
99a0 28 03			jr z, .nokeys 
99a2			 
99a2				;call hardware_diags 
99a2 cd 5f 95			call config 
99a5			 
99a5			;	ld de, .bpen 
99a5			;	ld a, display_row_4 
99a5			;	call str_at_display 
99a5			;	call update_display 
99a5			; 
99a5			;	ld a,0 
99a5			;	ld (os_view_disable),a 
99a5			; 
99a5			;.bpwait: 
99a5			;	call cin 
99a5			;	cp 0 
99a5			;	jr z, .bpwait 
99a5			;	jr .nokeys 
99a5			; 
99a5			; 
99a5			;.bpen:  db "Break points enabled!",0 
99a5			 
99a5			 
99a5			 
99a5			 
99a5			 
99a5			 
99a5			.nokeys: 
99a5			 
99a5			 
99a5				 
99a5			 
99a5			;jp  testkey 
99a5			 
99a5			;call storage_get_block_0 
99a5			; 
99a5			;ld hl, 0 
99a5			;ld de, store_page 
99a5			;call storage_read_block 
99a5			 
99a5				 
99a5			;ld hl, 10 
99a5			;ld de, store_page 
99a5			;call storage_read_block 
99a5			 
99a5			 
99a5			 
99a5			 
99a5			 
99a5			;stop:	nop 
99a5			;	jp stop 
99a5			 
99a5			 
99a5			 
99a5			main: 
99a5 cd ae 8a			call clear_display 
99a8 cd d1 8a			call update_display 
99ab			 
99ab			 
99ab			 
99ab			;	call testlcd 
99ab			 
99ab			 
99ab			 
99ab cd dc a0			call forth_init 
99ae			 
99ae			 
99ae			warmstart: 
99ae cd b2 a0			call forth_warmstart 
99b1			 
99b1				; run startup word load 
99b1			        ; TODO prevent this running at warmstart after crash  
99b1			 
99b1				if STARTUP_ENABLE 
99b1			 
99b1					if STARTUP_V1 
99b1			 
99b1						if STORAGE_SE 
99b1							call forth_autoload 
99b1						endif 
99b1 cd 81 e5					call forth_startup 
99b4					endif 
99b4			 
99b4					if STARTUP_V2 
99b4			 
99b4						if STORAGE_SE 
99b4							call forth_autoload 
99b4						else 
99b4							call forth_startup 
99b4						endif 
99b4			 
99b4			 
99b4					endif 
99b4			 
99b4				endif 
99b4			 
99b4				; show free memory after boot 
99b4 11 40 9a			ld de, freeram 
99b7 3e 00			ld a, display_row_1 
99b9 cd c1 8a			call str_at_display 
99bc			 
99bc				; get current heap start after loading any uwords 
99bc			 
99bc				;ld de, (os_last_new_uword) 
99bc				;ex de, hl 
99bc			 
99bc			; Or use heap_size word???? 
99bc				;ld hl, heap_end 
99bc				;ld hl, heap_size 
99bc				;ld de, topusermem 
99bc				;ld de, heap_start 
99bc ed 5b 06 e7			ld de, (free_list )      
99c0 21 9c e2				ld hl, heap_end 
99c3 ed 52			sbc hl, de 
99c5				;push hl 
99c5				;ld a,h	         	 
99c5				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99c5				;call hexout 
99c5			   	;pop hl 
99c5			; 
99c5			;	ld a,l 
99c5			;	ld hl, os_word_scratch+2 
99c5			;	call hexout 
99c5			;	ld hl, os_word_scratch+4 
99c5			;	ld a, 0 
99c5			;	ld (hl),a 
99c5 eb				ex de, hl 
99c6 21 c6 e5			ld hl, os_word_scratch 
99c9 cd 00 93			call uitoa_16 
99cc			 
99cc			 
99cc 11 c6 e5			ld de, os_word_scratch 
99cf 3e 0d			ld a, display_row_1 + 13 
99d1 cd c1 8a			call str_at_display 
99d4 cd d1 8a			call update_display 
99d7			 
99d7			 
99d7				;call demo 
99d7			 
99d7			 
99d7				; init scratch input area for cli commands 
99d7			 
99d7 21 e8 e5			ld hl, os_cli_cmd 
99da 3e 00			ld a,0 
99dc 77				ld (hl),a 
99dd 23				inc hl 
99de 77				ld (hl),a 
99df			 
99df 3e 00			ld a,0 
99e1 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
99e4			 
99e4 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
99e7 32 e5 e5			ld (os_cur_ptr+1),a	 
99ea			 
99ea 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
99ed 32 c7 e5			ld (os_word_scratch+1),a	 
99f0				 
99f0			 
99f0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
99f0 21 e8 e5			ld hl, os_cli_cmd 
99f3			 
99f3 3e 00			ld a, 0		 ; init cli input 
99f5 77				ld (hl), a 
99f6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
99f8			cli: 
99f8				; show cli prompt 
99f8				;push af 
99f8				;ld a, 0 
99f8				;ld de, prompt 
99f8				;call str_at_display 
99f8			 
99f8				;call update_display 
99f8				;pop af 
99f8				;inc a 
99f8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
99f8 0e 00			ld c, 0 
99fa 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
99fc 1e 28			ld e, 40 
99fe			 
99fe 21 e8 e5			ld hl, os_cli_cmd 
9a01			 
9a01				STACKFRAME OFF $fefe $9f9f 
9a01				if DEBUG_STACK_IMB 
9a01					if OFF 
9a01						exx 
9a01						ld de, $fefe 
9a01						ld a, d 
9a01						ld hl, curframe 
9a01						call hexout 
9a01						ld a, e 
9a01						ld hl, curframe+2 
9a01						call hexout 
9a01						ld hl, $fefe 
9a01						push hl 
9a01						ld hl, $9f9f 
9a01						push hl 
9a01						exx 
9a01					endif 
9a01				endif 
9a01			endm 
# End of macro STACKFRAME
9a01			 
9a01 cd 08 8d			call input_str 
9a04			 
9a04				STACKFRAMECHK OFF $fefe $9f9f 
9a04				if DEBUG_STACK_IMB 
9a04					if OFF 
9a04						exx 
9a04						ld hl, $9f9f 
9a04						pop de   ; $9f9f 
9a04						call cmp16 
9a04						jr nz, .spnosame 
9a04						ld hl, $fefe 
9a04						pop de   ; $fefe 
9a04						call cmp16 
9a04						jr z, .spfrsame 
9a04						.spnosame: call showsperror 
9a04						.spfrsame: nop 
9a04						exx 
9a04					endif 
9a04				endif 
9a04			endm 
# End of macro STACKFRAMECHK
9a04			 
9a04				; copy input to last command 
9a04			 
9a04 21 e8 e5			ld hl, os_cli_cmd 
9a07 11 e7 e6			ld de, os_last_cmd 
9a0a 01 ff 00			ld bc, 255 
9a0d ed b0			ldir 
9a0f			 
9a0f				; wipe current buffer 
9a0f			 
9a0f			;	ld a, 0 
9a0f			;	ld hl, os_cli_cmd 
9a0f			;	ld de, os_cli_cmd+1 
9a0f			;	ld bc, 254 
9a0f			;	ldir 
9a0f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9a0f			;	call strcpy 
9a0f			;	ld a, 0 
9a0f			;	ld (hl), a 
9a0f			;	inc hl 
9a0f			;	ld (hl), a 
9a0f			;	inc hl 
9a0f			;	ld (hl), a 
9a0f			 
9a0f				; switch frame buffer to program  
9a0f			 
9a0f 21 10 ed				ld hl, display_fb1 
9a12 22 cc eb				ld (display_fb_active), hl 
9a15			 
9a15			;	nop 
9a15				STACKFRAME ON $fbfe $8f9f 
9a15				if DEBUG_STACK_IMB 
9a15					if ON 
9a15						exx 
9a15						ld de, $fbfe 
9a15						ld a, d 
9a15						ld hl, curframe 
9a15						call hexout 
9a15						ld a, e 
9a15						ld hl, curframe+2 
9a15						call hexout 
9a15						ld hl, $fbfe 
9a15						push hl 
9a15						ld hl, $8f9f 
9a15						push hl 
9a15						exx 
9a15					endif 
9a15				endif 
9a15			endm 
# End of macro STACKFRAME
9a15				; first time into the parser so pass over the current scratch pad 
9a15 21 e8 e5			ld hl,os_cli_cmd 
9a18				; tokenise the entered statement(s) in HL 
9a18 cd 5a a1			call forthparse 
9a1b			        ; exec forth statements in top of return stack 
9a1b cd 9a a1			call forthexec 
9a1e				;call forthexec_cleanup 
9a1e			;	call parsenext 
9a1e			 
9a1e				STACKFRAMECHK ON $fbfe $8f9f 
9a1e				if DEBUG_STACK_IMB 
9a1e					if ON 
9a1e						exx 
9a1e						ld hl, $8f9f 
9a1e						pop de   ; $8f9f 
9a1e						call cmp16 
9a1e						jr nz, .spnosame 
9a1e						ld hl, $fbfe 
9a1e						pop de   ; $fbfe 
9a1e						call cmp16 
9a1e						jr z, .spfrsame 
9a1e						.spnosame: call showsperror 
9a1e						.spfrsame: nop 
9a1e						exx 
9a1e					endif 
9a1e				endif 
9a1e			endm 
# End of macro STACKFRAMECHK
9a1e				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9a1e			 
9a1e 3e 78			ld a, display_row_4 
9a20 11 51 9a			ld de, endprog 
9a23			 
9a23 cd d1 8a			call update_display		 
9a26			 
9a26 cd d7 9c			call next_page_prompt 
9a29			 
9a29				; switch frame buffer to cli 
9a29			 
9a29 21 b1 ed				ld hl, display_fb0 
9a2c 22 cc eb				ld (display_fb_active), hl 
9a2f			 
9a2f			 
9a2f cd ae 8a		        call clear_display 
9a32 cd d1 8a			call update_display		 
9a35			 
9a35 21 e8 e5			ld hl, os_cli_cmd 
9a38			 
9a38 3e 00			ld a, 0		 ; init cli input 
9a3a 77				ld (hl), a 
9a3b			 
9a3b				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9a3b			 
9a3b				; now on last line 
9a3b			 
9a3b				; TODO scroll screen up 
9a3b			 
9a3b				; TODO instead just clear screen and place at top of screen 
9a3b			 
9a3b			;	ld a, 0 
9a3b			;	ld (f_cursor_ptr),a 
9a3b			 
9a3b				;call clear_display 
9a3b				;call update_display 
9a3b			 
9a3b				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9a3b 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9a3d c3 f8 99			jp cli 
9a40			 
9a40 .. 00		freeram: db "Free bytes: ",0 
9a4d ..			asc: db "1A2F" 
9a51 .. 00		endprog: db "End prog...",0 
9a5d			 
9a5d			testenter2:   
9a5d 21 f3 e2			ld hl,scratch+50 
9a60 22 e4 e5			ld (os_cur_ptr),hl 
9a63 c3 f8 99			jp cli 
9a66			 
9a66			testenter:  
9a66			 
9a66 21 4d 9a			ld hl,asc 
9a69			;	ld a,(hl) 
9a69			;	call nibble2val 
9a69 cd 4a 92			call get_byte 
9a6c			 
9a6c			 
9a6c			;	ld a,(hl) 
9a6c			;	call atohex 
9a6c			 
9a6c			;	call fourehexhl 
9a6c 32 f3 e2			ld (scratch+50),a 
9a6f			 
9a6f			 
9a6f			 
9a6f 21 4f 9a			ld hl,asc+2 
9a72			;	ld a, (hl) 
9a72			;	call nibble2val 
9a72 cd 4a 92			call get_byte 
9a75			 
9a75			;	call fourehexhl 
9a75 32 f5 e2			ld (scratch+52),a 
9a78				 
9a78 21 f3 e2			ld hl,scratch+50 
9a7b 22 e4 e5			ld (os_cur_ptr),hl 
9a7e c3 f8 99			jp cli 
9a81			 
9a81			enter:	 
9a81 3a c5 e2			ld a,(scratch+4) 
9a84 fe 00			cp 0 
9a86 28 0c			jr z, .entercont 
9a88				; no, not a null term line so has an address to work out.... 
9a88			 
9a88 21 c3 e2			ld hl,scratch+2 
9a8b cd aa 92			call get_word_hl 
9a8e			 
9a8e 22 e4 e5			ld (os_cur_ptr),hl	 
9a91 c3 f8 99			jp cli 
9a94			 
9a94			 
9a94			.entercont:  
9a94			 
9a94 21 c3 e2			ld hl, scratch+2 
9a97 cd 4a 92			call get_byte 
9a9a			 
9a9a 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a9d 77					ld (hl),a 
9a9e 23					inc hl 
9a9f 22 e4 e5				ld (os_cur_ptr),hl 
9aa2				 
9aa2			; get byte  
9aa2			 
9aa2			 
9aa2 c3 f8 99			jp cli 
9aa5			 
9aa5			 
9aa5			; basic monitor support 
9aa5			 
9aa5			monitor: 
9aa5				;  
9aa5 cd ae 8a			call clear_display 
9aa8 3e 00			ld a, 0 
9aaa 11 f9 9a			ld de, .monprompt 
9aad cd c1 8a			call str_at_display 
9ab0 cd d1 8a			call update_display 
9ab3			 
9ab3				; get a monitor command 
9ab3			 
9ab3 0e 00			ld c, 0     ; entry at top left 
9ab5 16 64			ld d, 100   ; max buffer size 
9ab7 1e 0f			ld e, 15    ; input scroll area 
9ab9 3e 00			ld a, 0     ; init string 
9abb 21 bf e4			ld hl, os_input 
9abe 77				ld (hl), a 
9abf 23				inc hl 
9ac0 77				ld (hl), a 
9ac1 21 bf e4			ld hl, os_input 
9ac4 3e 01			ld a, 1     ; init string 
9ac6 cd 08 8d			call input_str 
9ac9			 
9ac9 cd ae 8a		        call clear_display 
9acc cd d1 8a			call update_display		 
9acf			 
9acf 3a bf e4			ld a, (os_input) 
9ad2 cd 48 93			call toUpper 
9ad5 fe 48		        cp 'H' 
9ad7 ca 5e 9b		        jp z, .monhelp 
9ada fe 44			cp 'D'		; dump 
9adc ca 91 9b			jp z, .mondump	 
9adf fe 43			cp 'C'		; dump 
9ae1 ca ab 9b			jp z, .moncdump	 
9ae4 fe 4d			cp 'M'		; dump 
9ae6 ca fb 9a			jp z, .moneditstart 
9ae9 fe 55			cp 'U'		; dump 
9aeb ca 07 9b			jp z, .monedit	 
9aee fe 47			cp 'G'		; dump 
9af0 ca 87 9b			jp z, .monjump 
9af3 fe 51			cp 'Q'		; dump 
9af5 c8				ret z	 
9af6			 
9af6			 
9af6				; TODO "S" to access symbol by name and not need the address 
9af6				; TODO "F" to find a string in memory 
9af6			 
9af6 c3 a5 9a			jp monitor 
9af9			 
9af9 .. 00		.monprompt: db ">", 0 
9afb			 
9afb			.moneditstart: 
9afb				; get starting address 
9afb			 
9afb 21 c1 e4			ld hl,os_input+2 
9afe cd aa 92			call get_word_hl 
9b01			 
9b01 22 e4 e5			ld (os_cur_ptr),hl	 
9b04			 
9b04 c3 a5 9a			jp monitor 
9b07			 
9b07			.monedit: 
9b07				; get byte to load 
9b07			 
9b07 21 c1 e4			ld hl,os_input+2 
9b0a cd 4a 92			call get_byte 
9b0d			 
9b0d				; get address to update 
9b0d 2a e4 e5			ld hl, (os_cur_ptr) 
9b10			 
9b10				; update byte 
9b10			 
9b10 77				ld (hl), a 
9b11			 
9b11				; move to next address and save it 
9b11			 
9b11 23				inc hl 
9b12 22 e4 e5			ld (os_cur_ptr),hl	 
9b15			 
9b15 c3 a5 9a			jp monitor 
9b18			 
9b18			 
9b18 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9b2c .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9b48 .. 00		.monhelptext3:  db "G-Call address",0 
9b57 .. 00		.monhelptext4:  db "Q-Quit",0 
9b5e			        
9b5e			.monhelp: 
9b5e 3e 00			ld a, display_row_1 
9b60 11 18 9b		        ld de, .monhelptext1 
9b63			 
9b63 cd c1 8a			call str_at_display 
9b66 3e 28			ld a, display_row_2 
9b68 11 2c 9b		        ld de, .monhelptext2 
9b6b					 
9b6b cd c1 8a			call str_at_display 
9b6e 3e 50			ld a, display_row_3 
9b70 11 48 9b		        ld de, .monhelptext3 
9b73					 
9b73 cd c1 8a			call str_at_display 
9b76 3e 78			ld a, display_row_4 
9b78 11 57 9b		        ld de, .monhelptext4 
9b7b cd c1 8a			call str_at_display 
9b7e			 
9b7e cd d1 8a			call update_display		 
9b81			 
9b81 cd d7 9c			call next_page_prompt 
9b84 c3 a5 9a			jp monitor 
9b87			 
9b87			.monjump:    
9b87 21 c1 e4			ld hl,os_input+2 
9b8a cd aa 92			call get_word_hl 
9b8d			 
9b8d e9				jp (hl) 
9b8e c3 a5 9a			jp monitor 
9b91			 
9b91			.mondump:    
9b91 21 c1 e4			ld hl,os_input+2 
9b94 cd aa 92			call get_word_hl 
9b97			 
9b97 22 e4 e5			ld (os_cur_ptr),hl	 
9b9a cd df 9b			call dumpcont 
9b9d 3e 78			ld a, display_row_4 
9b9f 11 51 9a			ld de, endprog 
9ba2			 
9ba2 cd d1 8a			call update_display		 
9ba5			 
9ba5 cd d7 9c			call next_page_prompt 
9ba8 c3 a5 9a			jp monitor 
9bab			.moncdump: 
9bab cd df 9b			call dumpcont 
9bae 3e 78			ld a, display_row_4 
9bb0 11 51 9a			ld de, endprog 
9bb3			 
9bb3 cd d1 8a			call update_display		 
9bb6			 
9bb6 cd d7 9c			call next_page_prompt 
9bb9 c3 a5 9a			jp monitor 
9bbc			 
9bbc			 
9bbc			; TODO symbol access  
9bbc			 
9bbc			.symbols:     ;; A list of symbols that can be called up  
9bbc b1 ed			dw display_fb0 
9bbe .. 00			db "fb0",0  
9bc2 7a ea		     	dw store_page 
9bc4 .. 00			db "store_page",0 
9bcf			 
9bcf			 
9bcf			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9bcf			 
9bcf 3a c2 e2			ld a,(scratch+1) 
9bd2 fe 00			cp 0 
9bd4 28 09			jr z, dumpcont 
9bd6			 
9bd6				; no, not a null term line so has an address to work out.... 
9bd6			 
9bd6 21 c3 e2			ld hl,scratch+2 
9bd9 cd aa 92			call get_word_hl 
9bdc			 
9bdc 22 e4 e5			ld (os_cur_ptr),hl	 
9bdf			 
9bdf			 
9bdf			 
9bdf			dumpcont: 
9bdf			 
9bdf				; dump bytes at ptr 
9bdf			 
9bdf			 
9bdf 3e 00			ld a, display_row_1 
9be1 2a cc eb			ld hl, (display_fb_active) 
9be4 cd db 8c			call addatohl 
9be7 cd 0f 9c			call .dumpbyterow 
9bea			 
9bea 3e 28			ld a, display_row_2 
9bec 2a cc eb			ld hl, (display_fb_active) 
9bef cd db 8c			call addatohl 
9bf2 cd 0f 9c			call .dumpbyterow 
9bf5			 
9bf5			 
9bf5 3e 50			ld a, display_row_3 
9bf7 2a cc eb			ld hl, (display_fb_active) 
9bfa cd db 8c			call addatohl 
9bfd cd 0f 9c			call .dumpbyterow 
9c00			 
9c00 3e 78			ld a, display_row_4 
9c02 2a cc eb			ld hl, (display_fb_active) 
9c05 cd db 8c			call addatohl 
9c08 cd 0f 9c			call .dumpbyterow 
9c0b			 
9c0b cd d1 8a			call update_display 
9c0e			;		jp cli 
9c0e c9				ret 
9c0f			 
9c0f			.dumpbyterow: 
9c0f			 
9c0f				;push af 
9c0f			 
9c0f e5				push hl 
9c10			 
9c10				; calc where to poke the ascii 
9c10			if display_cols == 20 
9c10				ld a, 16 
9c10			else 
9c10 3e 1f			ld a, 31 
9c12			endif 
9c12			 
9c12 cd db 8c			call addatohl 
9c15 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
9c18			 
9c18			 
9c18			; display decoding address 
9c18 2a e4 e5		   	ld hl,(os_cur_ptr) 
9c1b			 
9c1b 7c				ld a,h 
9c1c e1				pop hl 
9c1d e5				push hl 
9c1e			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9c1e cd f4 91			call hexout 
9c21 2a e4 e5		   	ld hl,(os_cur_ptr) 
9c24			 
9c24 7d				ld a,l 
9c25 e1				pop hl 
9c26 23				inc hl 
9c27 23				inc hl 
9c28 e5				push hl 
9c29			;	ld hl, os_word_scratch+2 
9c29 cd f4 91			call hexout 
9c2c e1				pop hl 
9c2d 23				inc hl 
9c2e 23				inc hl 
9c2f				;ld hl, os_word_scratch+4 
9c2f 3e 3a			ld a, ':' 
9c31 77				ld (hl),a 
9c32 23				inc hl 
9c33				;ld a, 0 
9c33				;ld (hl),a 
9c33				;ld de, os_word_scratch 
9c33				;pop af 
9c33				;push af 
9c33			;		ld a, display_row_2 
9c33			;		call str_at_display 
9c33			;		call update_display 
9c33			 
9c33			 
9c33			;pop af 
9c33			;	add 5 
9c33			 
9c33			if display_cols == 20 
9c33				ld b, 4 
9c33			else 
9c33 06 08			ld b, 8 
9c35			endif	 
9c35			 
9c35			.dumpbyte: 
9c35 c5				push bc 
9c36 e5				push hl 
9c37			 
9c37			 
9c37 2a e4 e5		   	ld hl,(os_cur_ptr) 
9c3a 7e					ld a,(hl) 
9c3b			 
9c3b					; poke the ascii to display 
9c3b 2a c6 e5				ld hl,(os_word_scratch) 
9c3e 77					ld (hl),a 
9c3f 23					inc hl 
9c40 22 c6 e5				ld (os_word_scratch),hl 
9c43			 
9c43					 
9c43			 
9c43			 
9c43 e1					pop hl 
9c44 e5					push hl 
9c45			 
9c45 cd f4 91				call hexout 
9c48			 
9c48					 
9c48 2a e4 e5		   	ld hl,(os_cur_ptr) 
9c4b 23				inc hl 
9c4c 22 e4 e5		   	ld (os_cur_ptr),hl 
9c4f			 
9c4f e1					pop hl 
9c50 23					inc hl 
9c51 23					inc hl 
9c52 23					inc hl 
9c53			 
9c53			 
9c53			 
9c53					;ld a,0 
9c53					;ld (os_word_scratch+2),a 
9c53					;pop af 
9c53					;push af 
9c53			 
9c53					;ld de, os_word_scratch 
9c53					;call str_at_display 
9c53			;		call update_display 
9c53			;		pop af 
9c53 c1					pop bc 
9c54 c6 03				add 3 
9c56 10 dd			djnz .dumpbyte 
9c58			 
9c58				 
9c58			 
9c58 c9				ret 
9c59			 
9c59			jump:	 
9c59			 
9c59 21 c3 e2			ld hl,scratch+2 
9c5c cd aa 92			call get_word_hl 
9c5f				;ld hl,(scratch+2) 
9c5f				;call fourehexhl 
9c5f			 
9c5f 22 e4 e5			ld (os_cur_ptr),hl	 
9c62			 
9c62 e9				jp (hl) 
9c63			 
9c63			 
9c63			 
9c63			; TODO implement a basic monitor mode to start with 
9c63			 
9c63			 
9c63			 
9c63			 
9c63			 
9c63			 
9c63			 
9c63			 
9c63			 
9c63			; testing and demo code during development 
9c63			 
9c63			 
9c63 .. 00		str1: db "Enter some text...",0 
9c76 .. 00		clear: db "                    ",0 
9c8b			 
9c8b			demo: 
9c8b			 
9c8b			 
9c8b			 
9c8b			;	call update_display 
9c8b			 
9c8b				; init scratch input area for testing 
9c8b 21 c1 e2			ld hl, scratch	 
9c8e 3e 00			ld a,0 
9c90 77				ld (hl),a 
9c91			 
9c91			 
9c91 3e 28		            LD   A, display_row_2 
9c93			;            CALL fLCD_Pos       ;Position cursor to location in A 
9c93 11 63 9c		            LD   DE, str1 
9c96 cd c1 8a			call str_at_display 
9c99			 
9c99			;            CALL fLCD_Str       ;Display string pointed to by DE 
9c99			cloop:	 
9c99 3e 50		            LD   A, display_row_3 
9c9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
9c9b 11 76 9c		            LD   DE, clear 
9c9e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9c9e cd c1 8a				call str_at_display 
9ca1 3e 78			ld a, display_row_4 
9ca3 11 d3 9c			ld de, prompt 
9ca6			 
9ca6 cd c1 8a				call str_at_display 
9ca9 cd d1 8a			call update_display 
9cac			 
9cac 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9cae 16 0a			ld d, 10 
9cb0 21 c1 e2			ld hl, scratch	 
9cb3 cd 08 8d			call input_str 
9cb6			 
9cb6			;	call clear_display 
9cb6			;'	call update_display 
9cb6			 
9cb6 3e 00		            LD   A, display_row_1 
9cb8			;            CALL fLCD_Pos       ;Position cursor to location in A 
9cb8 11 76 9c		            LD   DE, clear 
9cbb cd c1 8a				call str_at_display 
9cbe			;            CALL fLCD_Str       ;Display string pointed to by DE 
9cbe 3e 00		            LD   A, display_row_1 
9cc0			;            CALL fLCD_Pos       ;Position cursor to location in A 
9cc0 11 c1 e2		            LD   DE, scratch 
9cc3			;            CALL fLCD_Str       ;Display string pointed to by DE 
9cc3 cd c1 8a				call str_at_display 
9cc6 cd d1 8a			call update_display 
9cc9			 
9cc9 3e 00				ld a,0 
9ccb 21 c1 e2			ld hl, scratch 
9cce 77				ld (hl),a 
9ccf			 
9ccf 00				nop 
9cd0 c3 99 9c			jp cloop 
9cd3			 
9cd3			 
9cd3			 
9cd3			; OS Prompt 
9cd3			 
9cd3 .. 00		prompt: db ">",0 
9cd5 .. 00		endprg: db "?",0 
9cd7			 
9cd7			 
9cd7			; handy next page prompt 
9cd7			next_page_prompt: 
9cd7 e5				push hl 
9cd8 d5				push de 
9cd9 f5				push af 
9cda c5				push bc 
9cdb			 
9cdb 3e 9f			ld a,display_row_4 + display_cols - 1 
9cdd 11 d5 9c		        ld de, endprg 
9ce0 cd c1 8a			call str_at_display 
9ce3 cd d1 8a			call update_display 
9ce6 cd e7 e6			call cin_wait 
9ce9 c1				pop bc 
9cea f1				pop af 
9ceb d1				pop de 
9cec e1				pop hl 
9ced			 
9ced			 
9ced c9				ret 
9cee			 
9cee			 
9cee			; forth parser 
9cee			 
9cee			; My forth kernel 
9cee			include "forth_kernel.asm" 
9cee			; 
9cee			; kernel to the forth OS 
9cee			 
9cee			DS_TYPE_STR: equ 1     ; string type 
9cee			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9cee			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9cee			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9cee			 
9cee			FORTH_PARSEV1: equ 0 
9cee			FORTH_PARSEV2: equ 0 
9cee			FORTH_PARSEV3: equ 0 
9cee			FORTH_PARSEV4: equ 0 
9cee			FORTH_PARSEV5: equ 1 
9cee			 
9cee			;if FORTH_PARSEV5 
9cee			;	FORTH_END_BUFFER: equ 0 
9cee			;else 
9cee			FORTH_END_BUFFER: equ 127 
9cee			;endif 
9cee			 
9cee			FORTH_TRUE: equ 1 
9cee			FORTH_FALSE: equ 0 
9cee			 
9cee			if FORTH_PARSEV4 
9cee			include "forth_stackops.asm" 
9cee			endif 
9cee			 
9cee			if FORTH_PARSEV5 
9cee			include "forth_stackopsv5.asm" 
9cee			 
9cee			; Stack operations for v5 parser on wards 
9cee			; * DATA stack 
9cee			; * LOOP stack 
9cee			; * RETURN stack 
9cee			 
9cee			 
9cee			 
9cee			FORTH_CHK_DSP_UNDER: macro 
9cee				push hl 
9cee				push de 
9cee				ld hl,(cli_data_sp) 
9cee				ld de, cli_data_stack 
9cee				call cmp16 
9cee				jp c, fault_dsp_under 
9cee				pop de 
9cee				pop hl 
9cee				endm 
9cee			 
9cee			 
9cee			FORTH_CHK_RSP_UNDER: macro 
9cee				push hl 
9cee				push de 
9cee				ld hl,(cli_ret_sp) 
9cee				ld de, cli_ret_stack 
9cee				call cmp16 
9cee				jp c, fault_rsp_under 
9cee				pop de 
9cee				pop hl 
9cee				endm 
9cee			 
9cee			FORTH_CHK_LOOP_UNDER: macro 
9cee				push hl 
9cee				push de 
9cee				ld hl,(cli_loop_sp) 
9cee				ld de, cli_loop_stack 
9cee				call cmp16 
9cee				jp c, fault_loop_under 
9cee				pop de 
9cee				pop hl 
9cee				endm 
9cee			 
9cee			FORTH_ERR_TOS_NOTSTR: macro 
9cee				; TOSO might need more for checks when used 
9cee				push af 
9cee				ld a,(hl) 
9cee				cp DS_TYPE_STR 
9cee				jp nz, type_faultn   
9cee				pop af 
9cee				endm 
9cee			 
9cee			FORTH_ERR_TOS_NOTNUM: macro 
9cee				push af 
9cee				ld a,(hl) 
9cee				cp DS_TYPE_INUM 
9cee				jp nz, type_faultn   
9cee				pop af 
9cee				endm 
9cee			 
9cee			 
9cee			; increase data stack pointer and save hl to it 
9cee				 
9cee			FORTH_DSP_NEXT: macro 
9cee				call macro_forth_dsp_next 
9cee				endm 
9cee			 
9cee			 
9cee			macro_forth_dsp_next: 
9cee				if DEBUG_FORTH_STACK_GUARD 
9cee cd 62 e3				call check_stacks 
9cf1				endif 
9cf1 e5				push hl 
9cf2 d5				push de 
9cf3 eb				ex de,hl 
9cf4 2a ee e9			ld hl,(cli_data_sp) 
9cf7 23				inc hl 
9cf8 23				inc hl 
9cf9			 
9cf9			; PARSEV5 
9cf9 23				inc hl 
9cfa 22 ee e9			ld (cli_data_sp),hl 
9cfd 73				ld (hl), e 
9cfe 23				inc hl 
9cff 72				ld (hl), d 
9d00 d1				pop de 
9d01 e1				pop hl 
9d02				if DEBUG_FORTH_STACK_GUARD 
9d02 cd 62 e3				call check_stacks 
9d05				endif 
9d05 c9				ret 
9d06			 
9d06			 
9d06			; increase ret stack pointer and save hl to it 
9d06				 
9d06			FORTH_RSP_NEXT: macro 
9d06				call macro_forth_rsp_next 
9d06				endm 
9d06			 
9d06			macro_forth_rsp_next: 
9d06				if DEBUG_FORTH_STACK_GUARD 
9d06 cd 62 e3				call check_stacks 
9d09				endif 
9d09 e5				push hl 
9d0a d5				push de 
9d0b eb				ex de,hl 
9d0c 2a f2 e9			ld hl,(cli_ret_sp) 
9d0f 23				inc hl 
9d10 23				inc hl 
9d11 22 f2 e9			ld (cli_ret_sp),hl 
9d14 73				ld (hl), e 
9d15 23				inc hl 
9d16 72				ld (hl), d 
9d17 d1				pop de 
9d18 e1				pop hl 
9d19				if DEBUG_FORTH_STACK_GUARD 
9d19 cd 62 e3				call check_stacks 
9d1c				endif 
9d1c c9				ret 
9d1d			 
9d1d			; get current ret stack pointer and save to hl  
9d1d				 
9d1d			FORTH_RSP_TOS: macro 
9d1d				call macro_forth_rsp_tos 
9d1d				endm 
9d1d			 
9d1d			macro_forth_rsp_tos: 
9d1d				;push de 
9d1d 2a f2 e9			ld hl,(cli_ret_sp) 
9d20 cd 58 9d			call loadhlptrtohl 
9d23				;ld e, (hl) 
9d23				;inc hl 
9d23				;ld d, (hl) 
9d23				;ex de, hl 
9d23					if DEBUG_FORTH_WORDS 
9d23			;			DMARK "RST" 
9d23						CALLMONITOR 
9d23 cd 6f ee			call debug_vector  
9d26				endm  
# End of macro CALLMONITOR
9d26					endif 
9d26				;pop de 
9d26 c9				ret 
9d27			 
9d27			; pop ret stack pointer 
9d27				 
9d27			FORTH_RSP_POP: macro 
9d27				call macro_forth_rsp_pop 
9d27				endm 
9d27			 
9d27			 
9d27			macro_forth_rsp_pop: 
9d27				if DEBUG_FORTH_STACK_GUARD 
9d27			;		DMARK "RPP" 
9d27 cd 62 e3				call check_stacks 
9d2a					FORTH_CHK_RSP_UNDER 
9d2a e5				push hl 
9d2b d5				push de 
9d2c 2a f2 e9			ld hl,(cli_ret_sp) 
9d2f 11 ac e9			ld de, cli_ret_stack 
9d32 cd f9 8c			call cmp16 
9d35 da 76 e4			jp c, fault_rsp_under 
9d38 d1				pop de 
9d39 e1				pop hl 
9d3a				endm 
# End of macro FORTH_CHK_RSP_UNDER
9d3a				endif 
9d3a e5				push hl 
9d3b 2a f2 e9			ld hl,(cli_ret_sp) 
9d3e			 
9d3e			 
9d3e				if FORTH_ENABLE_FREE 
9d3e			 
9d3e					; get pointer 
9d3e			 
9d3e					push de 
9d3e					push hl 
9d3e			 
9d3e					ld e, (hl) 
9d3e					inc hl 
9d3e					ld d, (hl) 
9d3e			 
9d3e					ex de, hl 
9d3e					call free 
9d3e			 
9d3e					pop hl 
9d3e					pop de 
9d3e			 
9d3e			 
9d3e				endif 
9d3e			 
9d3e			 
9d3e 2b				dec hl 
9d3f 2b				dec hl 
9d40 22 f2 e9			ld (cli_ret_sp), hl 
9d43				; do stack underflow checks 
9d43 e1				pop hl 
9d44				if DEBUG_FORTH_STACK_GUARD 
9d44 cd 62 e3				call check_stacks 
9d47					FORTH_CHK_RSP_UNDER 
9d47 e5				push hl 
9d48 d5				push de 
9d49 2a f2 e9			ld hl,(cli_ret_sp) 
9d4c 11 ac e9			ld de, cli_ret_stack 
9d4f cd f9 8c			call cmp16 
9d52 da 76 e4			jp c, fault_rsp_under 
9d55 d1				pop de 
9d56 e1				pop hl 
9d57				endm 
# End of macro FORTH_CHK_RSP_UNDER
9d57				endif 
9d57 c9				ret 
9d58			 
9d58			 
9d58			 
9d58			; routine to load word pointed to by hl into hl 
9d58			 
9d58			loadhlptrtohl: 
9d58			 
9d58 d5				push de 
9d59 5e				ld e, (hl) 
9d5a 23				inc hl 
9d5b 56				ld d, (hl) 
9d5c eb				ex de, hl 
9d5d d1				pop de 
9d5e			 
9d5e c9				ret 
9d5f			 
9d5f			 
9d5f			 
9d5f			 
9d5f			 
9d5f			; push a number held in HL onto the data stack 
9d5f			; entry point for pushing a value when already in hl used in function above 
9d5f			 
9d5f			forth_push_numhl: 
9d5f			 
9d5f e5				push hl    ; save value to push 
9d60			 
9d60			if DEBUG_FORTH_PUSH 
9d60				; see if disabled 
9d60			 
9d60			 
9d60 f5				push af 
9d61 3a 6f ee			ld a,(debug_vector) 
9d64 fe c9			cp $c9   ; ret 
9d66			;	ld a, (os_view_disable) 
9d66			;	cp '*' 
9d66 28 34			jr z, .pskip2 
9d68 e5				push hl 
9d69 e5			push hl 
9d6a cd ae 8a			call clear_display 
9d6d e1			pop hl 
9d6e 7c				ld a,h 
9d6f 21 c6 e5			ld hl, os_word_scratch 
9d72 cd f4 91			call hexout 
9d75 e1				pop hl 
9d76 7d				ld a,l 
9d77 21 c8 e5			ld hl, os_word_scratch+2 
9d7a cd f4 91			call hexout 
9d7d			 
9d7d 21 ca e5			ld hl, os_word_scratch+4 
9d80 3e 00			ld a,0 
9d82 77				ld (hl),a 
9d83 11 c6 e5			ld de,os_word_scratch 
9d86 3e 28				ld a, display_row_2 
9d88 cd c1 8a				call str_at_display 
9d8b 11 74 ce			ld de, .push_num 
9d8e 3e 00			ld a, display_row_1 
9d90			 
9d90 cd c1 8a				call str_at_display 
9d93			 
9d93			 
9d93 cd d1 8a			call update_display 
9d96 cd f1 89			call delay1s 
9d99 cd f1 89			call delay1s 
9d9c			.pskip2:  
9d9c			 
9d9c f1				pop af 
9d9d			endif	 
9d9d			 
9d9d			 
9d9d				FORTH_DSP_NEXT 
9d9d cd ee 9c			call macro_forth_dsp_next 
9da0				endm 
# End of macro FORTH_DSP_NEXT
9da0			 
9da0 2a ee e9			ld hl, (cli_data_sp) 
9da3			 
9da3				; save item type 
9da3 3e 02			ld a,  DS_TYPE_INUM 
9da5 77				ld (hl), a 
9da6 23				inc hl 
9da7			 
9da7				; get word off stack 
9da7 d1				pop de 
9da8 7b				ld a,e 
9da9 77				ld (hl), a 
9daa 23				inc hl 
9dab 7a				ld a,d 
9dac 77				ld (hl), a 
9dad			 
9dad			if DEBUG_FORTH_PUSH 
9dad 2b				dec hl 
9dae 2b				dec hl 
9daf 2b				dec hl 
9db0						DMARK "PH5" 
9db0 f5				push af  
9db1 3a c5 9d			ld a, (.dmark)  
9db4 32 6b ee			ld (debug_mark),a  
9db7 3a c6 9d			ld a, (.dmark+1)  
9dba 32 6c ee			ld (debug_mark+1),a  
9dbd 3a c7 9d			ld a, (.dmark+2)  
9dc0 32 6d ee			ld (debug_mark+2),a  
9dc3 18 03			jr .pastdmark  
9dc5 ..			.dmark: db "PH5"  
9dc8 f1			.pastdmark: pop af  
9dc9			endm  
# End of macro DMARK
9dc9				CALLMONITOR 
9dc9 cd 6f ee			call debug_vector  
9dcc				endm  
# End of macro CALLMONITOR
9dcc			endif	 
9dcc			 
9dcc c9				ret 
9dcd			 
9dcd			 
9dcd			; Push a string to stack pointed to by hl 
9dcd			 
9dcd			forth_push_str: 
9dcd			 
9dcd			if DEBUG_FORTH_PUSH 
9dcd						DMARK "PSQ" 
9dcd f5				push af  
9dce 3a e2 9d			ld a, (.dmark)  
9dd1 32 6b ee			ld (debug_mark),a  
9dd4 3a e3 9d			ld a, (.dmark+1)  
9dd7 32 6c ee			ld (debug_mark+1),a  
9dda 3a e4 9d			ld a, (.dmark+2)  
9ddd 32 6d ee			ld (debug_mark+2),a  
9de0 18 03			jr .pastdmark  
9de2 ..			.dmark: db "PSQ"  
9de5 f1			.pastdmark: pop af  
9de6			endm  
# End of macro DMARK
9de6				CALLMONITOR 
9de6 cd 6f ee			call debug_vector  
9de9				endm  
# End of macro CALLMONITOR
9de9			endif	 
9de9			    
9de9 e5				push hl 
9dea e5				push hl 
9deb			 
9deb			;	ld a, 0   ; find end of string 
9deb cd 51 93			call strlenz 
9dee			if DEBUG_FORTH_PUSH 
9dee						DMARK "PQ2" 
9dee f5				push af  
9def 3a 03 9e			ld a, (.dmark)  
9df2 32 6b ee			ld (debug_mark),a  
9df5 3a 04 9e			ld a, (.dmark+1)  
9df8 32 6c ee			ld (debug_mark+1),a  
9dfb 3a 05 9e			ld a, (.dmark+2)  
9dfe 32 6d ee			ld (debug_mark+2),a  
9e01 18 03			jr .pastdmark  
9e03 ..			.dmark: db "PQ2"  
9e06 f1			.pastdmark: pop af  
9e07			endm  
# End of macro DMARK
9e07				CALLMONITOR 
9e07 cd 6f ee			call debug_vector  
9e0a				endm  
# End of macro CALLMONITOR
9e0a			endif	 
9e0a eb				ex de, hl 
9e0b e1				pop hl   ; get ptr to start of string 
9e0c			if DEBUG_FORTH_PUSH 
9e0c						DMARK "PQ3" 
9e0c f5				push af  
9e0d 3a 21 9e			ld a, (.dmark)  
9e10 32 6b ee			ld (debug_mark),a  
9e13 3a 22 9e			ld a, (.dmark+1)  
9e16 32 6c ee			ld (debug_mark+1),a  
9e19 3a 23 9e			ld a, (.dmark+2)  
9e1c 32 6d ee			ld (debug_mark+2),a  
9e1f 18 03			jr .pastdmark  
9e21 ..			.dmark: db "PQ3"  
9e24 f1			.pastdmark: pop af  
9e25			endm  
# End of macro DMARK
9e25				CALLMONITOR 
9e25 cd 6f ee			call debug_vector  
9e28				endm  
# End of macro CALLMONITOR
9e28			endif	 
9e28 19				add hl,de 
9e29			if DEBUG_FORTH_PUSH 
9e29						DMARK "PQE" 
9e29 f5				push af  
9e2a 3a 3e 9e			ld a, (.dmark)  
9e2d 32 6b ee			ld (debug_mark),a  
9e30 3a 3f 9e			ld a, (.dmark+1)  
9e33 32 6c ee			ld (debug_mark+1),a  
9e36 3a 40 9e			ld a, (.dmark+2)  
9e39 32 6d ee			ld (debug_mark+2),a  
9e3c 18 03			jr .pastdmark  
9e3e ..			.dmark: db "PQE"  
9e41 f1			.pastdmark: pop af  
9e42			endm  
# End of macro DMARK
9e42				CALLMONITOR 
9e42 cd 6f ee			call debug_vector  
9e45				endm  
# End of macro CALLMONITOR
9e45			endif	 
9e45			 
9e45 2b				dec hl    ; see if there is an optional trailing double quote 
9e46 7e				ld a,(hl) 
9e47 fe 22			cp '"' 
9e49 20 03			jr nz, .strnoq 
9e4b 3e 00			ld a, 0      ; get rid of double quote 
9e4d 77				ld (hl), a 
9e4e 23			.strnoq: inc hl 
9e4f			 
9e4f 3e 00			ld a, 0 
9e51 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9e52			 
9e52 13				inc de ; add one for the type string 
9e53 13				inc de ; add one for null term??? 
9e54			 
9e54				; tos is get string pointer again 
9e54				; de contains space to allocate 
9e54				 
9e54 d5				push de 
9e55			 
9e55 eb				ex de, hl 
9e56			 
9e56				;push af 
9e56			 
9e56			if DEBUG_FORTH_PUSH 
9e56						DMARK "PHm" 
9e56 f5				push af  
9e57 3a 6b 9e			ld a, (.dmark)  
9e5a 32 6b ee			ld (debug_mark),a  
9e5d 3a 6c 9e			ld a, (.dmark+1)  
9e60 32 6c ee			ld (debug_mark+1),a  
9e63 3a 6d 9e			ld a, (.dmark+2)  
9e66 32 6d ee			ld (debug_mark+2),a  
9e69 18 03			jr .pastdmark  
9e6b ..			.dmark: db "PHm"  
9e6e f1			.pastdmark: pop af  
9e6f			endm  
# End of macro DMARK
9e6f				CALLMONITOR 
9e6f cd 6f ee			call debug_vector  
9e72				endm  
# End of macro CALLMONITOR
9e72			endif	 
9e72 cd c6 93			call malloc	; on ret hl now contains allocated memory 
9e75				if DEBUG_FORTH_MALLOC_GUARD 
9e75 cc cc ce				call z,malloc_error 
9e78				endif 
9e78			 
9e78				 
9e78 c1				pop bc    ; get length 
9e79 d1				pop de   ;  get string start    
9e7a			 
9e7a				; hl has destination from malloc 
9e7a			 
9e7a eb				ex de, hl    ; prep for ldir 
9e7b			 
9e7b d5				push de   ; save malloc area for DSP later 
9e7c				;push hl   ; save malloc area for DSP later 
9e7c			 
9e7c			if DEBUG_FORTH_PUSH 
9e7c						DMARK "PHc" 
9e7c f5				push af  
9e7d 3a 91 9e			ld a, (.dmark)  
9e80 32 6b ee			ld (debug_mark),a  
9e83 3a 92 9e			ld a, (.dmark+1)  
9e86 32 6c ee			ld (debug_mark+1),a  
9e89 3a 93 9e			ld a, (.dmark+2)  
9e8c 32 6d ee			ld (debug_mark+2),a  
9e8f 18 03			jr .pastdmark  
9e91 ..			.dmark: db "PHc"  
9e94 f1			.pastdmark: pop af  
9e95			endm  
# End of macro DMARK
9e95				CALLMONITOR 
9e95 cd 6f ee			call debug_vector  
9e98				endm  
# End of macro CALLMONITOR
9e98			endif	 
9e98			 
9e98			 
9e98 ed b0			ldir 
9e9a			 
9e9a			 
9e9a				; push malloc to data stack     macro?????  
9e9a			 
9e9a				FORTH_DSP_NEXT 
9e9a cd ee 9c			call macro_forth_dsp_next 
9e9d				endm 
# End of macro FORTH_DSP_NEXT
9e9d			 
9e9d				; save value and type 
9e9d			 
9e9d 2a ee e9			ld hl, (cli_data_sp) 
9ea0			 
9ea0				; save item type 
9ea0 3e 01			ld a,  DS_TYPE_STR 
9ea2 77				ld (hl), a 
9ea3 23				inc hl 
9ea4			 
9ea4				; get malloc word off stack 
9ea4 d1				pop de 
9ea5 73				ld (hl), e 
9ea6 23				inc hl 
9ea7 72				ld (hl), d 
9ea8			 
9ea8			 
9ea8			 
9ea8			if DEBUG_FORTH_PUSH 
9ea8 2a ee e9			ld hl, (cli_data_sp) 
9eab						DMARK "PHS" 
9eab f5				push af  
9eac 3a c0 9e			ld a, (.dmark)  
9eaf 32 6b ee			ld (debug_mark),a  
9eb2 3a c1 9e			ld a, (.dmark+1)  
9eb5 32 6c ee			ld (debug_mark+1),a  
9eb8 3a c2 9e			ld a, (.dmark+2)  
9ebb 32 6d ee			ld (debug_mark+2),a  
9ebe 18 03			jr .pastdmark  
9ec0 ..			.dmark: db "PHS"  
9ec3 f1			.pastdmark: pop af  
9ec4			endm  
# End of macro DMARK
9ec4				CALLMONITOR 
9ec4 cd 6f ee			call debug_vector  
9ec7				endm  
# End of macro CALLMONITOR
9ec7			;	ex de,hl 
9ec7			endif	 
9ec7				; in case of spaces, skip the ptr past the copied string 
9ec7				;pop af 
9ec7				;ld (cli_origptr),hl 
9ec7			 
9ec7 c9				ret 
9ec8			 
9ec8			 
9ec8			 
9ec8			; TODO ascii push input onto stack given hl to start of input 
9ec8			 
9ec8			; identify type 
9ec8			; if starts with a " then a string 
9ec8			; otherwise it is a number 
9ec8			;  
9ec8			; if a string 
9ec8			;     scan for ending " to get length of string to malloc for + 1 
9ec8			;     malloc 
9ec8			;     put pointer to string on stack first byte flags as string 
9ec8			; 
9ec8			; else a number 
9ec8			;    look for number format identifier 
9ec8			;    $xx hex 
9ec8			;    %xxxxx bin 
9ec8			;    xxxxx decimal 
9ec8			;    convert number to 16bit word.  
9ec8			;    malloc word + 1 with flag to identiy as num 
9ec8			;    put pointer to number on stack 
9ec8			;   
9ec8			;  
9ec8			  
9ec8			forth_apush: 
9ec8				; kernel push 
9ec8			 
9ec8			if DEBUG_FORTH_PUSH 
9ec8						DMARK "PSH" 
9ec8 f5				push af  
9ec9 3a dd 9e			ld a, (.dmark)  
9ecc 32 6b ee			ld (debug_mark),a  
9ecf 3a de 9e			ld a, (.dmark+1)  
9ed2 32 6c ee			ld (debug_mark+1),a  
9ed5 3a df 9e			ld a, (.dmark+2)  
9ed8 32 6d ee			ld (debug_mark+2),a  
9edb 18 03			jr .pastdmark  
9edd ..			.dmark: db "PSH"  
9ee0 f1			.pastdmark: pop af  
9ee1			endm  
# End of macro DMARK
9ee1				CALLMONITOR 
9ee1 cd 6f ee			call debug_vector  
9ee4				endm  
# End of macro CALLMONITOR
9ee4			endif	 
9ee4				; identify input type 
9ee4			 
9ee4 7e				ld a,(hl) 
9ee5 fe 22			cp '"' 
9ee7 28 0a			jr z, .fapstr 
9ee9 fe 24			cp '$' 
9eeb ca 13 9f			jp z, .faphex 
9eee fe 25			cp '%' 
9ef0 ca fb 9e			jp z, .fapbin 
9ef3			;	cp 'b' 
9ef3			;	jp z, .fabin 
9ef3				; else decimal 
9ef3			 
9ef3				; TODO do decimal conversion 
9ef3				; decimal is stored as a 16bit word 
9ef3			 
9ef3				; by default everything is a string if type is not detected 
9ef3			.fapstr: ; 
9ef3 fe 22			cp '"' 
9ef5 20 01			jr nz, .strnoqu 
9ef7 23				inc hl 
9ef8			.strnoqu: 
9ef8 c3 cd 9d			jp forth_push_str 
9efb			 
9efb			 
9efb			 
9efb			.fapbin:    ; push a binary string.  
9efb 11 00 00			ld de, 0   ; hold a 16bit value 
9efe			 
9efe 23			.fapbinshift:	inc hl  
9eff 7e				ld a,(hl) 
9f00 fe 00			cp 0     ; done scanning  
9f02 28 0b			jr z, .fapbdone  	; got it in HL so push  
9f04			 
9f04				; left shift de 
9f04 eb				ex de, hl	 
9f05 29				add hl, hl 
9f06			 
9f06				; is 1 
9f06 fe 31			cp '1' 
9f08 20 02			jr nz, .binzero 
9f0a cb 4d			bit 1, l 
9f0c			.binzero: 
9f0c eb				ex de, hl	 ; save current de 
9f0d 18 ef			jr .fapbinshift 
9f0f			 
9f0f			.fapbdone: 
9f0f eb				ex de, hl 
9f10 c3 5f 9d			jp forth_push_numhl 
9f13			 
9f13			 
9f13			.faphex:   ; hex is always stored as a 16bit word 
9f13				; skip number prefix 
9f13 23				inc hl 
9f14				; turn ascii into number 
9f14 cd aa 92			call get_word_hl	; ret 16bit word in hl 
9f17			 
9f17 c3 5f 9d			jp forth_push_numhl 
9f1a			 
9f1a 00				 nop 
9f1b			 
9f1b			.fabin:   ; TODO bin conversion 
9f1b			 
9f1b			 
9f1b c9				ret 
9f1c			 
9f1c			 
9f1c			; get either a string ptr or a 16bit word from the data stack 
9f1c			 
9f1c			FORTH_DSP: macro 
9f1c				call macro_forth_dsp 
9f1c				endm 
9f1c			 
9f1c			macro_forth_dsp: 
9f1c				; data stack pointer points to current word on tos 
9f1c			 
9f1c 2a ee e9			ld hl,(cli_data_sp) 
9f1f			 
9f1f				if DEBUG_FORTH_PUSH 
9f1f						DMARK "DSP" 
9f1f f5				push af  
9f20 3a 34 9f			ld a, (.dmark)  
9f23 32 6b ee			ld (debug_mark),a  
9f26 3a 35 9f			ld a, (.dmark+1)  
9f29 32 6c ee			ld (debug_mark+1),a  
9f2c 3a 36 9f			ld a, (.dmark+2)  
9f2f 32 6d ee			ld (debug_mark+2),a  
9f32 18 03			jr .pastdmark  
9f34 ..			.dmark: db "DSP"  
9f37 f1			.pastdmark: pop af  
9f38			endm  
# End of macro DMARK
9f38			 
9f38 cd ff ce				call display_data_sp 
9f3b				;call break_point_state 
9f3b				;rst 030h 
9f3b				CALLMONITOR 
9f3b cd 6f ee			call debug_vector  
9f3e				endm  
# End of macro CALLMONITOR
9f3e				endif 
9f3e			 
9f3e c9				ret 
9f3f			 
9f3f			; return hl to start of value on stack 
9f3f			 
9f3f			FORTH_DSP_VALUE: macro 
9f3f				call macro_forth_dsp_value 
9f3f				endm 
9f3f			 
9f3f			macro_forth_dsp_value: 
9f3f			 
9f3f				FORTH_DSP 
9f3f cd 1c 9f			call macro_forth_dsp 
9f42				endm 
# End of macro FORTH_DSP
9f42			 
9f42 d5				push de 
9f43			 
9f43 23				inc hl ; skip type 
9f44			 
9f44 5e				ld e, (hl) 
9f45 23				inc hl 
9f46 56				ld d, (hl) 
9f47 eb				ex de,hl  
9f48			 
9f48 d1				pop de 
9f49			 
9f49 c9				ret 
9f4a			 
9f4a			; return hl to start of value to second item on stack 
9f4a			 
9f4a			FORTH_DSP_VALUEM1: macro 
9f4a				call macro_forth_dsp_value_m1 
9f4a				endm 
9f4a			 
9f4a			macro_forth_dsp_value_m1: 
9f4a			 
9f4a				FORTH_DSP 
9f4a cd 1c 9f			call macro_forth_dsp 
9f4d				endm 
# End of macro FORTH_DSP
9f4d			 
9f4d 2b				dec hl 
9f4e 2b				dec hl 
9f4f			;	dec hl 
9f4f			 
9f4f d5				push de 
9f50			 
9f50 5e				ld e, (hl) 
9f51 23				inc hl 
9f52 56				ld d, (hl) 
9f53 eb				ex de,hl  
9f54			 
9f54 d1				pop de 
9f55			 
9f55 c9				ret 
9f56			 
9f56				 
9f56			 
9f56			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9f56			 
9f56			FORTH_DSP_POP: macro 
9f56				call macro_forth_dsp_pop 
9f56				endm 
9f56			 
9f56			 
9f56			; get the tos data type 
9f56			 
9f56			FORTH_DSP_TYPE:   macro 
9f56			 
9f56				;FORTH_DSP_VALUE 
9f56				FORTH_DSP 
9f56				 
9f56				; hl points to value 
9f56				; check type 
9f56			 
9f56				ld a,(hl) 
9f56			 
9f56				endm 
9f56			 
9f56			; load the tos value into hl 
9f56			 
9f56			 
9f56			FORTH_DSP_VALUEHL:  macro 
9f56				call macro_dsp_valuehl 
9f56				endm 
9f56			 
9f56			 
9f56			 
9f56			macro_dsp_valuehl: 
9f56				FORTH_DSP_VALUE 
9f56 cd 3f 9f			call macro_forth_dsp_value 
9f59				endm 
# End of macro FORTH_DSP_VALUE
9f59			 
9f59				;FORTH_ERR_TOS_NOTNUM 
9f59			 
9f59				;inc hl   ; skip type id 
9f59			 
9f59			;	push de 
9f59			; 
9f59			;	ld e, (hl) 
9f59			;	inc hl 
9f59			;	ld d, (hl) 
9f59			;	ex de,hl  
9f59			 
9f59			;	pop de 
9f59			 
9f59				if DEBUG_FORTH_PUSH 
9f59						DMARK "DVL" 
9f59 f5				push af  
9f5a 3a 6e 9f			ld a, (.dmark)  
9f5d 32 6b ee			ld (debug_mark),a  
9f60 3a 6f 9f			ld a, (.dmark+1)  
9f63 32 6c ee			ld (debug_mark+1),a  
9f66 3a 70 9f			ld a, (.dmark+2)  
9f69 32 6d ee			ld (debug_mark+2),a  
9f6c 18 03			jr .pastdmark  
9f6e ..			.dmark: db "DVL"  
9f71 f1			.pastdmark: pop af  
9f72			endm  
# End of macro DMARK
9f72				CALLMONITOR 
9f72 cd 6f ee			call debug_vector  
9f75				endm  
# End of macro CALLMONITOR
9f75				endif 
9f75 c9				ret 
9f76			 
9f76			forth_apushstrhl:      
9f76				; push of string requires use of cli_origptr 
9f76				; bodge use 
9f76			 
9f76				; get current cli_origptr, save, update with temp pointer  
9f76 ed 5b 3e ea		ld de, (cli_origptr) 
9f7a 22 3e ea			ld (cli_origptr), hl 
9f7d d5				push de 
9f7e cd c8 9e			call forth_apush 
9f81 d1				pop de 
9f82 ed 53 3e ea		ld (cli_origptr), de 
9f86 c9			        ret	 
9f87			 
9f87			 
9f87			; increase loop stack pointer and save hl to it 
9f87				 
9f87			FORTH_LOOP_NEXT: macro 
9f87				call macro_forth_loop_next 
9f87				;nop 
9f87				endm 
9f87			 
9f87			macro_forth_loop_next: 
9f87				if DEBUG_FORTH_STACK_GUARD 
9f87 cd 62 e3				call check_stacks 
9f8a				endif 
9f8a e5				push hl 
9f8b d5				push de 
9f8c eb				ex de,hl 
9f8d 2a f0 e9			ld hl,(cli_loop_sp) 
9f90 23				inc hl 
9f91 23				inc hl 
9f92					if DEBUG_FORTH_WORDS 
9f92						DMARK "LNX" 
9f92 f5				push af  
9f93 3a a7 9f			ld a, (.dmark)  
9f96 32 6b ee			ld (debug_mark),a  
9f99 3a a8 9f			ld a, (.dmark+1)  
9f9c 32 6c ee			ld (debug_mark+1),a  
9f9f 3a a9 9f			ld a, (.dmark+2)  
9fa2 32 6d ee			ld (debug_mark+2),a  
9fa5 18 03			jr .pastdmark  
9fa7 ..			.dmark: db "LNX"  
9faa f1			.pastdmark: pop af  
9fab			endm  
# End of macro DMARK
9fab						CALLMONITOR 
9fab cd 6f ee			call debug_vector  
9fae				endm  
# End of macro CALLMONITOR
9fae					endif 
9fae 22 f0 e9			ld (cli_loop_sp),hl 
9fb1 73				ld (hl), e 
9fb2 23				inc hl 
9fb3 72				ld (hl), d 
9fb4 d1				pop de    ; been reversed so save a swap on restore 
9fb5 e1				pop hl 
9fb6				if DEBUG_FORTH_STACK_GUARD 
9fb6 cd 62 e3				call check_stacks 
9fb9				endif 
9fb9 c9				ret 
9fba			 
9fba			; get current ret stack pointer and save to hl  
9fba				 
9fba			FORTH_LOOP_TOS: macro 
9fba				call macro_forth_loop_tos 
9fba				endm 
9fba			 
9fba			macro_forth_loop_tos: 
9fba d5				push de 
9fbb 2a f0 e9			ld hl,(cli_loop_sp) 
9fbe 5e				ld e, (hl) 
9fbf 23				inc hl 
9fc0 56				ld d, (hl) 
9fc1 eb				ex de, hl 
9fc2 d1				pop de 
9fc3 c9				ret 
9fc4			 
9fc4			; pop loop stack pointer 
9fc4				 
9fc4			FORTH_LOOP_POP: macro 
9fc4				call macro_forth_loop_pop 
9fc4				endm 
9fc4			 
9fc4			 
9fc4			macro_forth_loop_pop: 
9fc4				if DEBUG_FORTH_STACK_GUARD 
9fc4					DMARK "LPP" 
9fc4 f5				push af  
9fc5 3a d9 9f			ld a, (.dmark)  
9fc8 32 6b ee			ld (debug_mark),a  
9fcb 3a da 9f			ld a, (.dmark+1)  
9fce 32 6c ee			ld (debug_mark+1),a  
9fd1 3a db 9f			ld a, (.dmark+2)  
9fd4 32 6d ee			ld (debug_mark+2),a  
9fd7 18 03			jr .pastdmark  
9fd9 ..			.dmark: db "LPP"  
9fdc f1			.pastdmark: pop af  
9fdd			endm  
# End of macro DMARK
9fdd cd 62 e3				call check_stacks 
9fe0					FORTH_CHK_LOOP_UNDER 
9fe0 e5				push hl 
9fe1 d5				push de 
9fe2 2a f0 e9			ld hl,(cli_loop_sp) 
9fe5 11 2a e9			ld de, cli_loop_stack 
9fe8 cd f9 8c			call cmp16 
9feb da 7c e4			jp c, fault_loop_under 
9fee d1				pop de 
9fef e1				pop hl 
9ff0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9ff0				endif 
9ff0 e5				push hl 
9ff1 2a f0 e9			ld hl,(cli_loop_sp) 
9ff4 2b				dec hl 
9ff5 2b				dec hl 
9ff6 22 f0 e9			ld (cli_loop_sp), hl 
9ff9				; TODO do stack underflow checks 
9ff9 e1				pop hl 
9ffa				if DEBUG_FORTH_STACK_GUARD 
9ffa cd 62 e3				call check_stacks 
9ffd					FORTH_CHK_LOOP_UNDER 
9ffd e5				push hl 
9ffe d5				push de 
9fff 2a f0 e9			ld hl,(cli_loop_sp) 
a002 11 2a e9			ld de, cli_loop_stack 
a005 cd f9 8c			call cmp16 
a008 da 7c e4			jp c, fault_loop_under 
a00b d1				pop de 
a00c e1				pop hl 
a00d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
a00d				endif 
a00d c9				ret 
a00e			 
a00e			macro_forth_dsp_pop: 
a00e			 
a00e e5				push hl 
a00f			 
a00f				; release malloc data 
a00f			 
a00f				if DEBUG_FORTH_STACK_GUARD 
a00f cd 62 e3				call check_stacks 
a012					FORTH_CHK_DSP_UNDER 
a012 e5				push hl 
a013 d5				push de 
a014 2a ee e9			ld hl,(cli_data_sp) 
a017 11 28 e8			ld de, cli_data_stack 
a01a cd f9 8c			call cmp16 
a01d da 70 e4			jp c, fault_dsp_under 
a020 d1				pop de 
a021 e1				pop hl 
a022				endm 
# End of macro FORTH_CHK_DSP_UNDER
a022				endif 
a022				;ld hl,(cli_data_sp) 
a022			if DEBUG_FORTH_DOT 
a022				DMARK "DPP" 
a022 f5				push af  
a023 3a 37 a0			ld a, (.dmark)  
a026 32 6b ee			ld (debug_mark),a  
a029 3a 38 a0			ld a, (.dmark+1)  
a02c 32 6c ee			ld (debug_mark+1),a  
a02f 3a 39 a0			ld a, (.dmark+2)  
a032 32 6d ee			ld (debug_mark+2),a  
a035 18 03			jr .pastdmark  
a037 ..			.dmark: db "DPP"  
a03a f1			.pastdmark: pop af  
a03b			endm  
# End of macro DMARK
a03b				CALLMONITOR 
a03b cd 6f ee			call debug_vector  
a03e				endm  
# End of macro CALLMONITOR
a03e			endif	 
a03e			 
a03e			 
a03e			if FORTH_ENABLE_DSPPOPFREE 
a03e			 
a03e				FORTH_DSP 
a03e cd 1c 9f			call macro_forth_dsp 
a041				endm 
# End of macro FORTH_DSP
a041			 
a041 7e				ld a, (hl) 
a042 fe 01			cp DS_TYPE_STR 
a044 20 23			jr nz, .skippopfree 
a046			 
a046				FORTH_DSP_VALUEHL 
a046 cd 56 9f			call macro_dsp_valuehl 
a049				endm 
# End of macro FORTH_DSP_VALUEHL
a049 00				nop 
a04a			if DEBUG_FORTH_DOT 
a04a				DMARK "DPf" 
a04a f5				push af  
a04b 3a 5f a0			ld a, (.dmark)  
a04e 32 6b ee			ld (debug_mark),a  
a051 3a 60 a0			ld a, (.dmark+1)  
a054 32 6c ee			ld (debug_mark+1),a  
a057 3a 61 a0			ld a, (.dmark+2)  
a05a 32 6d ee			ld (debug_mark+2),a  
a05d 18 03			jr .pastdmark  
a05f ..			.dmark: db "DPf"  
a062 f1			.pastdmark: pop af  
a063			endm  
# End of macro DMARK
a063				CALLMONITOR 
a063 cd 6f ee			call debug_vector  
a066				endm  
# End of macro CALLMONITOR
a066			endif	 
a066 cd 90 94			call free 
a069			.skippopfree: 
a069				 
a069			 
a069			endif 
a069			 
a069			if DEBUG_FORTH_DOT_KEY 
a069				DMARK "DP2" 
a069				CALLMONITOR 
a069			endif	 
a069			 
a069				; move pointer down 
a069			 
a069 2a ee e9			ld hl,(cli_data_sp) 
a06c 2b				dec hl 
a06d 2b				dec hl 
a06e			; PARSEV5 
a06e 2b				dec hl 
a06f 22 ee e9			ld (cli_data_sp), hl 
a072			 
a072				if DEBUG_FORTH_STACK_GUARD 
a072 cd 62 e3				call check_stacks 
a075					FORTH_CHK_DSP_UNDER 
a075 e5				push hl 
a076 d5				push de 
a077 2a ee e9			ld hl,(cli_data_sp) 
a07a 11 28 e8			ld de, cli_data_stack 
a07d cd f9 8c			call cmp16 
a080 da 70 e4			jp c, fault_dsp_under 
a083 d1				pop de 
a084 e1				pop hl 
a085				endm 
# End of macro FORTH_CHK_DSP_UNDER
a085				endif 
a085			 
a085 e1				pop hl 
a086			 
a086 c9				ret 
a087			 
a087			getwordathl: 
a087				; hl points to an address 
a087				; load hl with the word at that address 
a087			 
a087 d5				push de 
a088			 
a088 5e				ld e, (hl) 
a089 23				inc hl 
a08a 56				ld d, (hl) 
a08b eb				ex de, hl 
a08c			 
a08c d1				pop de 
a08d c9				ret 
a08e			 
a08e			 
a08e			 
a08e			 
a08e			 
a08e			; eof 
a08e			 
# End of file forth_stackopsv5.asm
a08e			endif 
a08e			 
a08e			loadwordinhl:	 
a08e			 
a08e d5				push de 
a08f			 
a08f 5e				ld e, (hl) 
a090 23				inc hl 
a091 56				ld d, (hl) 
a092 eb				ex de,hl  
a093			 
a093 d1				pop de 
a094			 
a094 c9				ret 
a095			 
a095			user_word_eol:  
a095				; hl contains the pointer to where to create a linked list item from the end 
a095				; of the user dict to continue on at the system word dict 
a095				 
a095				; poke the stub of the word list linked list to repoint to rom words 
a095			 
a095				; stub format 
a095				; db   word id 
a095				; dw    link to next word 
a095			        ; db char length of token 
a095				; db string + 0 term 
a095				; db exec code....  
a095			 
a095 3e 00			ld a, WORD_SYS_ROOT     ; root word 
a097 77				ld (hl), a		; word id 
a098 23				inc hl 
a099			 
a099 11 64 a2			ld de, sysdict 
a09c 73				ld (hl), e		; next word link ie system dict 
a09d 23				inc hl 
a09e 72				ld (hl), d		; next word link ie system dict 
a09f 23				inc hl	 
a0a0			 
a0a0			;	ld (hl), sysdict		; next word link ie system dict 
a0a0			;	inc hl 
a0a0			;	inc hl 
a0a0			 
a0a0			;	inc hl 
a0a0			;	inc hl 
a0a0			 
a0a0 3e 02			ld a, 2			; word length is 0 
a0a2 77				ld (hl), a	 
a0a3 23				inc hl 
a0a4			 
a0a4 3e 7e			ld a, '~'			; word length is 0 
a0a6 77				ld (hl), a	 
a0a7 23				inc hl 
a0a8 3e 00			ld a, 0			; save empty word 
a0aa 77				ld (hl), a 
a0ab			 
a0ab c9				ret 
a0ac			 
a0ac				 
a0ac			 
a0ac			forthexec_cleanup: 
a0ac				FORTH_RSP_POP 
a0ac cd 27 9d			call macro_forth_rsp_pop 
a0af				endm 
# End of macro FORTH_RSP_POP
a0af c9				ret 
a0b0			 
a0b0			forth_call_hl: 
a0b0				; taking hl 
a0b0 e5				push hl 
a0b1 c9				ret 
a0b2			 
a0b2			; this is called to reset Forth system but keep existing uwords etc 
a0b2			 
a0b2			forth_warmstart: 
a0b2				; setup stack over/under flow checks 
a0b2				if DEBUG_FORTH_STACK_GUARD 
a0b2 cd 48 e3				call chk_stk_init 
a0b5				endif 
a0b5			 
a0b5				; init stack pointers  - * these stacks go upwards *  
a0b5 21 ac e9			ld hl, cli_ret_stack 
a0b8 22 f2 e9			ld (cli_ret_sp), hl	 
a0bb				; set bottom of stack 
a0bb 3e 00			ld a,0 
a0bd 77				ld (hl),a 
a0be 23				inc hl 
a0bf 77				ld (hl),a 
a0c0			 
a0c0 21 28 e8			ld hl, cli_data_stack 
a0c3 22 ee e9			ld (cli_data_sp), hl	 
a0c6				; set bottom of stack 
a0c6 3e 00			ld a,0 
a0c8 77				ld (hl),a 
a0c9 23				inc hl 
a0ca 77				ld (hl),a 
a0cb			 
a0cb 21 2a e9			ld hl, cli_loop_stack 
a0ce 22 f0 e9			ld (cli_loop_sp), hl	 
a0d1				; set bottom of stack 
a0d1 3e 00			ld a,0 
a0d3 77				ld (hl),a 
a0d4 23				inc hl 
a0d5 77				ld (hl),a 
a0d6			 
a0d6				; init extent of current open file 
a0d6			 
a0d6 3e 00			ld a, 0 
a0d8 32 6a ea			ld (store_openext), a 
a0db			 
a0db c9				ret 
a0dc			 
a0dc			 
a0dc			 
a0dc			; Cold Start - this is called to setup the whole Forth system 
a0dc			 
a0dc			forth_init: 
a0dc			 
a0dc				; setup stack over/under flow checks 
a0dc			 
a0dc			;	if DEBUG_FORTH_STACK_GUARD 
a0dc			;		call chk_stk_init 
a0dc			;	endif 
a0dc			 
a0dc				; enable auto display updates (slow.....) 
a0dc			 
a0dc 3e 01			ld a, 1 
a0de 32 3c ea			ld (cli_autodisplay), a 
a0e1			 
a0e1				; if storage is in use disable long reads for now 
a0e1 3e 00			ld a, 0 
a0e3 32 75 ea			ld (store_longread), a 
a0e6			 
a0e6			 
a0e6				; show start up screen 
a0e6			 
a0e6 cd ae 8a			call clear_display 
a0e9			 
a0e9 3e 00			ld a,0 
a0eb 32 5e ea			ld (f_cursor_ptr), a 
a0ee			 
a0ee				; set start of word list in start of ram - for use when creating user words 
a0ee			 
a0ee 21 fc e6			ld hl, baseram 
a0f1 22 be e5			ld (os_last_new_uword), hl 
a0f4 cd 95 a0			call user_word_eol 
a0f7				 
a0f7			;		call display_data_sp 
a0f7			;		call next_page_prompt 
a0f7			 
a0f7			 
a0f7			 
a0f7			 
a0f7 c9				ret 
a0f8			 
a0f8 .. 00		.bootforth: db " Forth Kernel Init ",0 
a10c			 
a10c			; TODO push to stack 
a10c			 
a10c			;  
a10c			 
a10c			if FORTH_PARSEV2 
a10c			 
a10c			 
a10c				include "forth_parserv2.asm" 
a10c			 
a10c			endif 
a10c			 
a10c			 
a10c			; parse cli version 1 
a10c			 
a10c			if FORTH_PARSEV1 
a10c			 
a10c			 
a10c			 
a10c			      include "forth_parserv1.asm" 
a10c			endif 
a10c				 
a10c			if FORTH_PARSEV3 
a10c			 
a10c			 
a10c			 
a10c			      include "forth_parserv3.asm" 
a10c				include "forth_wordsv3.asm" 
a10c			endif 
a10c			 
a10c			if FORTH_PARSEV4 
a10c			 
a10c			 
a10c			 
a10c			      include "forth_parserv4.asm" 
a10c				include "forth_wordsv4.asm" 
a10c			endif 
a10c			 
a10c			if FORTH_PARSEV5 
a10c			 
a10c			 
a10c			 
a10c			      include "forth_parserv5.asm" 
a10c			 
a10c			 
a10c			; A better parser without using malloc and string copies all over the place.  
a10c			; Exec in situ should be faster 
a10c			 
a10c			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
a10c			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
a10c			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
a10c			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
a10c			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
a10c			WORD_SYS_END: equ 0   ; Opcode for all user words 
a10c			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
a10c			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
a10c			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
a10c			 
a10c			; Core word preamble macro 
a10c			 
a10c			CWHEAD:   macro nxtword opcode lit len opflags 
a10c				db WORD_SYS_CORE+opcode             
a10c				; internal op code number 
a10c				dw nxtword            
a10c				; link to next dict word block 
a10c				db len + 1 
a10c				; literal length of dict word inc zero term 
a10c				db lit,0              
a10c				; literal dict word 
a10c			        ; TODO db opflags        
a10c				endm 
a10c			 
a10c			 
a10c			NEXTW: macro  
a10c				jp macro_next 
a10c				endm 
a10c			 
a10c			macro_next: 
a10c			if DEBUG_FORTH_PARSE_KEY 
a10c				DMARK "NXT" 
a10c				CALLMONITOR 
a10c			endif	 
a10c			;	inc hl  ; skip token null term  
a10c ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a110 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a114 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a117			if DEBUG_FORTH_PARSE_KEY 
a117				DMARK "}AA" 
a117				CALLMONITOR 
a117			endif	 
a117 c3 1a a2			jp execnext 
a11a				;jp exec1 
a11a			       
a11a			 
a11a			 
a11a			; Another go at the parser to compile  
a11a			 
a11a			 
a11a			; TODO rework parser to change all of the string words to byte tokens 
a11a			; TODO do a search for  
a11a			 
a11a			; TODO first run normal parser to zero term sections 
a11a			; TODO for each word do a token look up to get the op code 
a11a			; TODO need some means to flag to the exec that this is a byte code form    
a11a			 
a11a			 
a11a			forthcompile: 
a11a			 
a11a			; 
a11a			; line parse: 
a11a			;       parse raw input buffer 
a11a			;       tokenise the words 
a11a			;       malloc new copy (for looping etc) 
a11a			;       copy to malloc + current pc in line to start of string and add line term 
a11a			;       save on new rsp 
a11a			; 
a11a			 
a11a			; hl to point to the line to tokenise 
a11a			 
a11a			;	push hl 
a11a 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
a11d			 
a11d			;	ld a,0		; string term on input 
a11d			;	call strlent 
a11d			 
a11d			;	ld (os_tok_len), hl	 ; save string length 
a11d			 
a11d			;if DEBUG_FORTH_TOK 
a11d			;	ex de,hl		 
a11d			;endif 
a11d			 
a11d			;	pop hl 		; get back string pointer 
a11d			 
a11d			if DEBUG_FORTH_TOK 
a11d						DMARK "TOc" 
a11d				CALLMONITOR 
a11d			endif 
a11d 7e			.cptoken2:    ld a,(hl) 
a11e 23				inc hl 
a11f fe 7f			cp FORTH_END_BUFFER 
a121 28 29			jr z, .cptokendone2 
a123 fe 00			cp 0 
a125 28 25			jr z, .cptokendone2 
a127 fe 22			cp '"' 
a129 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
a12b fe 20			cp ' ' 
a12d 20 ee			jr nz,  .cptoken2 
a12f			 
a12f			; TODO consume comments held between ( and ) 
a12f			 
a12f				; we have a space so change to zero term for dict match later 
a12f 2b				dec hl 
a130 3e 00			ld a,0 
a132 77				ld (hl), a 
a133 23				inc hl 
a134 18 e7			jr .cptoken2 
a136				 
a136			 
a136			.cptokenstr2: 
a136				; skip all white space until either eol (because forgot to term) or end double quote 
a136			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
a136				;inc hl ; skip current double quote 
a136 7e				ld a,(hl) 
a137 23				inc hl 
a138 fe 22			cp '"' 
a13a 28 e1			jr z, .cptoken2 
a13c fe 7f			cp FORTH_END_BUFFER 
a13e 28 0c			jr z, .cptokendone2 
a140 fe 00			cp 0 
a142 28 08			jr z, .cptokendone2 
a144 fe 20			cp ' ' 
a146 28 02			jr z, .cptmp2 
a148 18 ec			jr .cptokenstr2 
a14a			 
a14a			.cptmp2:	; we have a space so change to zero term for dict match later 
a14a				;dec hl 
a14a				;ld a,"-"	; TODO remove this when working 
a14a				;ld (hl), a 
a14a				;inc hl 
a14a 18 ea			jr .cptokenstr2 
a14c			 
a14c			.cptokendone2: 
a14c				;inc hl 
a14c 3e 7f			ld a, FORTH_END_BUFFER 
a14e 77				ld (hl),a 
a14f 23				inc hl 
a150 3e 21			ld a, '!' 
a152 77				ld (hl),a 
a153			 
a153 2a c2 e5			ld hl,(os_tok_ptr) 
a156			         
a156			if DEBUG_FORTH_TOK 
a156						DMARK "Tc1" 
a156				CALLMONITOR 
a156			endif 
a156			 
a156				; push exec string to top of return stack 
a156				FORTH_RSP_NEXT 
a156 cd 06 9d			call macro_forth_rsp_next 
a159				endm 
# End of macro FORTH_RSP_NEXT
a159 c9				ret 
a15a			 
a15a			; Another go at the parser need to simplify the process 
a15a			 
a15a			forthparse: 
a15a			 
a15a			; 
a15a			; line parse: 
a15a			;       parse raw input buffer 
a15a			;       tokenise the words 
a15a			;       malloc new copy (for looping etc) 
a15a			;       copy to malloc + current pc in line to start of string and add line term 
a15a			;       save on new rsp 
a15a			; 
a15a			 
a15a			; hl to point to the line to tokenise 
a15a			 
a15a			;	push hl 
a15a 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
a15d			 
a15d			;	ld a,0		; string term on input 
a15d			;	call strlent 
a15d			 
a15d			;	ld (os_tok_len), hl	 ; save string length 
a15d			 
a15d			;if DEBUG_FORTH_TOK 
a15d			;	ex de,hl		 
a15d			;endif 
a15d			 
a15d			;	pop hl 		; get back string pointer 
a15d			 
a15d			if DEBUG_FORTH_TOK 
a15d						DMARK "TOK" 
a15d				CALLMONITOR 
a15d			endif 
a15d 7e			.ptoken2:    ld a,(hl) 
a15e 23				inc hl 
a15f fe 7f			cp FORTH_END_BUFFER 
a161 28 29			jr z, .ptokendone2 
a163 fe 00			cp 0 
a165 28 25			jr z, .ptokendone2 
a167 fe 22			cp '"' 
a169 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
a16b fe 20			cp ' ' 
a16d 20 ee			jr nz,  .ptoken2 
a16f			 
a16f			; TODO consume comments held between ( and ) 
a16f			 
a16f				; we have a space so change to zero term for dict match later 
a16f 2b				dec hl 
a170 3e 00			ld a,0 
a172 77				ld (hl), a 
a173 23				inc hl 
a174 18 e7			jr .ptoken2 
a176				 
a176			 
a176			.ptokenstr2: 
a176				; skip all white space until either eol (because forgot to term) or end double quote 
a176			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
a176				;inc hl ; skip current double quote 
a176 7e				ld a,(hl) 
a177 23				inc hl 
a178 fe 22			cp '"' 
a17a 28 e1			jr z, .ptoken2 
a17c fe 7f			cp FORTH_END_BUFFER 
a17e 28 0c			jr z, .ptokendone2 
a180 fe 00			cp 0 
a182 28 08			jr z, .ptokendone2 
a184 fe 20			cp ' ' 
a186 28 02			jr z, .ptmp2 
a188 18 ec			jr .ptokenstr2 
a18a			 
a18a			.ptmp2:	; we have a space so change to zero term for dict match later 
a18a				;dec hl 
a18a				;ld a,"-"	; TODO remove this when working 
a18a				;ld (hl), a 
a18a				;inc hl 
a18a 18 ea			jr .ptokenstr2 
a18c			 
a18c			.ptokendone2: 
a18c				;inc hl 
a18c 3e 7f			ld a, FORTH_END_BUFFER 
a18e 77				ld (hl),a 
a18f 23				inc hl 
a190 3e 21			ld a, '!' 
a192 77				ld (hl),a 
a193			 
a193 2a c2 e5			ld hl,(os_tok_ptr) 
a196			         
a196			if DEBUG_FORTH_TOK 
a196						DMARK "TK1" 
a196				CALLMONITOR 
a196			endif 
a196			 
a196				; push exec string to top of return stack 
a196				FORTH_RSP_NEXT 
a196 cd 06 9d			call macro_forth_rsp_next 
a199				endm 
# End of macro FORTH_RSP_NEXT
a199 c9				ret 
a19a			 
a19a			; 
a19a			;	; malloc size + buffer pointer + if is loop flag 
a19a			;	ld hl,(os_tok_len) 		 ; get string length 
a19a			; 
a19a			;	ld a,l 
a19a			; 
a19a			;	cp 0			; we dont want to use a null string 
a19a			;	ret z 
a19a			; 
a19a			;;	add 3    ; prefix malloc with buffer for current word ptr 
a19a			; 
a19a			;	add 5     ; TODO when certain not over writing memory remove 
a19a			; 
a19a			;		 
a19a			; 
a19a			;if DEBUG_FORTH_TOK 
a19a			;			DMARK "TKE" 
a19a			;	CALLMONITOR 
a19a			;endif 
a19a			; 
a19a			;	ld l,a 
a19a			;	ld h,0 
a19a			;;	push hl   ; save required space for the copy later 
a19a			;	call malloc 
a19a			;if DEBUG_FORTH_TOK 
a19a			;			DMARK "TKM" 
a19a			;	CALLMONITOR 
a19a			;endif 
a19a			;	if DEBUG_FORTH_MALLOC_GUARD 
a19a			;		push af 
a19a			;		call ishlzero 
a19a			;;		ld a, l 
a19a			;;		add h 
a19a			;;		cp 0 
a19a			;		pop af 
a19a			;		 
a19a			;		call z,malloc_error 
a19a			;	endif 
a19a			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
a19a			; 
a19a			; 
a19a			;if DEBUG_FORTH_TOK 
a19a			;			DMARK "TKR" 
a19a			;	CALLMONITOR 
a19a			;endif 
a19a			; 
a19a			;	FORTH_RSP_NEXT 
a19a			; 
a19a			;	;inc hl	 ; go past current buffer pointer 
a19a			;	;inc hl 
a19a			;	;inc hl   ; and past if loop flag 
a19a			;		; TODO Need to set flag  
a19a			; 
a19a			;	 
a19a			;	 
a19a			;	ex de,hl	; malloc is dest 
a19a			;	ld hl, (os_tok_len) 
a19a			;;	pop bc 
a19a			;	ld c, l                
a19a			;	ld b,0 
a19a			;	ld hl, (os_tok_ptr) 
a19a			; 
a19a			;if DEBUG_FORTH_TOK 
a19a			;			DMARK "TKT" 
a19a			;	CALLMONITOR 
a19a			;endif 
a19a			; 
a19a			;	; do str cpy 
a19a			; 
a19a			;	ldir      ; copy byte in hl to de 
a19a			; 
a19a			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
a19a			; 
a19a			;if DEBUG_FORTH_TOK 
a19a			; 
a19a			;			DMARK "TKY" 
a19a			;	CALLMONITOR 
a19a			;endif 
a19a			;	;ld a,0 
a19a			;	;ld a,FORTH_END_BUFFER 
a19a			;	ex de, hl 
a19a			;	;dec hl			 ; go back over the space delim at the end of word 
a19a			;	;ld (hl),a 
a19a			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
a19a			;	ld a,FORTH_END_BUFFER 
a19a			;	ld (hl),a 
a19a			;	inc hl 
a19a			;	ld a,FORTH_END_BUFFER 
a19a			;	ld (hl),a 
a19a			; 
a19a			;	; init the malloc area data 
a19a			;	; set pc for in current area 
a19a			;	;ld hl, (os_tok_malloc) 
a19a			;	;inc hl 
a19a			;	;inc hl 
a19a			;	;inc hl 
a19a			;	;ex de,hl 
a19a			;	;ld hl, (os_tok_malloc) 
a19a			;	;ld (hl),e 
a19a			;	;inc hl 
a19a			;	;ld (hl),d 
a19a			; 
a19a			; 
a19a			;	ld hl,(os_tok_malloc) 
a19a			;if DEBUG_FORTH_PARSE_KEY 
a19a			;			DMARK "TKU" 
a19a			;	CALLMONITOR 
a19a			;endif 
a19a			; 
a19a			;	ret 
a19a			 
a19a			forthexec: 
a19a			 
a19a			; line exec: 
a19a			; forth parser 
a19a			 
a19a			; 
a19a			;       get current exec line on rsp 
a19a			 
a19a				FORTH_RSP_TOS 
a19a cd 1d 9d			call macro_forth_rsp_tos 
a19d				endm 
# End of macro FORTH_RSP_TOS
a19d			 
a19d			;       restore current pc - hl points to malloc of data 
a19d			 
a19d				;ld e, (hl) 
a19d				;inc hl 
a19d				;ld d, (hl) 
a19d				;ex de,hl 
a19d			 
a19d			 
a19d			exec1: 
a19d 22 c2 e5			ld (os_tok_ptr), hl 
a1a0			 
a1a0				; copy our PC to working vars  
a1a0 22 40 ea			ld (cli_ptr), hl 
a1a3 22 3e ea			ld (cli_origptr), hl 
a1a6			 
a1a6 7e				ld a,(hl) 
a1a7 fe 7f			cp FORTH_END_BUFFER 
a1a9 c8				ret z 
a1aa			 
a1aa				; skip any nulls 
a1aa			 
a1aa fe 00			cp 0 
a1ac 20 03			jr nz, .execword 
a1ae 23				inc hl 
a1af 18 ec			jr exec1 
a1b1			 
a1b1			 
a1b1			.execword: 
a1b1			 
a1b1			 
a1b1			 
a1b1			if DEBUG_FORTH_PARSE_KEY 
a1b1						DMARK "KYQ" 
a1b1				CALLMONITOR 
a1b1			endif 
a1b1			;       while at start of word: 
a1b1			; get start of dict (in user area first) 
a1b1			 
a1b1 21 fc e6		ld hl, baseram 
a1b4			;ld hl, sysdict 
a1b4 22 42 ea		ld (cli_nextword),hl 
a1b7			;           match word at pc 
a1b7			;           exec word 
a1b7			;           or push to dsp 
a1b7			;           forward to next token 
a1b7			;           if line term pop rsp and exit 
a1b7			;        
a1b7			 
a1b7			if DEBUG_FORTH_PARSE_KEY 
a1b7						DMARK "KYq" 
a1b7				CALLMONITOR 
a1b7			endif 
a1b7			 
a1b7			; 
a1b7			; word comp 
a1b7			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
a1b7			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
a1b7			;    move to start of word  
a1b7			;    compare word to cli_token 
a1b7			 
a1b7			.execpnword:	; HL at start of a word in the dictionary to check 
a1b7			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
a1b7			;	ld (cli_ptr), hl 
a1b7			 
a1b7 2a 42 ea			ld hl,(cli_nextword) 
a1ba			 
a1ba cd 5d a2			call forth_tok_next 
a1bd			; tok next start here 
a1bd			;	; TODO skip compiled symbol for now 
a1bd			;	inc hl 
a1bd			; 
a1bd			;	; save pointer to next word 
a1bd			; 
a1bd			;	; hl now points to the address of the next word pointer  
a1bd			;	ld e, (hl) 
a1bd			;	inc hl 
a1bd			;	ld d, (hl) 
a1bd			;	inc l 
a1bd			; 
a1bd			;	ex de,hl 
a1bd			;if DEBUG_FORTH_PARSE_NEXTWORD 
a1bd			;	push bc 
a1bd			;	ld bc, (cli_nextword) 
a1bd			;			DMARK "NXW" 
a1bd			;	CALLMONITOR 
a1bd			;	pop bc 
a1bd			;endif 
a1bd			; tok next end here 
a1bd 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
a1c0 eb				ex de, hl 
a1c1			 
a1c1			 
a1c1				; save the pointer of the current token - 1 to check against 
a1c1				 
a1c1 22 46 ea			ld (cli_token), hl   
a1c4				; TODO maybe remove below save if no debug 
a1c4				; save token string ptr for any debug later 
a1c4 23				inc hl  
a1c5 22 48 ea			ld (cli_origtoken), hl 
a1c8 2b				dec hl 
a1c9				; save pointer to the start of the next dictionay word 
a1c9 7e				ld a,(hl)   ; get string length 
a1ca 47				ld b,a 
a1cb			.execpnwordinc:  
a1cb 23				inc hl 
a1cc 10 fd			djnz .execpnwordinc 
a1ce 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
a1d1			 
a1d1				; now check the word token against the string being parsed 
a1d1			 
a1d1 2a 46 ea			ld hl,(cli_token) 
a1d4 23				inc hl     ; skip string length (use zero term instead to end) 
a1d5 22 46 ea			ld (cli_token), hl 
a1d8			 
a1d8			if DEBUG_FORTH_PARSE_KEY 
a1d8						DMARK "KY2" 
a1d8			endif 
a1d8			if DEBUG_FORTH_PARSE_EXEC 
a1d8				; see if disabled 
a1d8			 
a1d8			;	ld a, (os_view_disable) 
a1d8			;	cp '*' 
a1d8				ld a, (debug_vector) 
a1d8				cp $c9   ; RET  
a1d8				jr z, .skip 
a1d8			 
a1d8				push hl 
a1d8				push hl 
a1d8				call clear_display 
a1d8				ld de, .compword 
a1d8				ld a, display_row_1 
a1d8				call str_at_display 
a1d8				pop de 
a1d8				ld a, display_row_2 
a1d8				call str_at_display 
a1d8				ld hl,(cli_ptr) 
a1d8				ld a,(hl) 
a1d8			        ld hl, os_word_scratch 
a1d8				ld (hl),a 
a1d8				ld a,0 
a1d8				inc hl 
a1d8				ld (hl),a 	 
a1d8				ld de, os_word_scratch 
a1d8				ld a, display_row_2+10 
a1d8				call str_at_display 
a1d8				call update_display 
a1d8				ld a, 100 
a1d8				call aDelayInMS 
a1d8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a1d8				call delay250ms 
a1d8				endif 
a1d8				pop hl 
a1d8			.skip:  
a1d8			endif	 
a1d8			.execpnchar:    ; compare char between token and string to parse 
a1d8			 
a1d8			if DEBUG_FORTH_PARSE_KEY 
a1d8						DMARK "Ky3" 
a1d8			endif 
a1d8			if DEBUG_FORTH_PARSE_EXEC 
a1d8				; see if disabled 
a1d8			 
a1d8			;	ld a, (os_view_disable) 
a1d8			;	cp '*' 
a1d8				ld a, (debug_vector) 
a1d8				cp $C9  ; RET 
a1d8				jr z, .skip2 
a1d8			 
a1d8			;	call clear_display 
a1d8			ld hl,(cli_token) 
a1d8			ld a,(hl) 
a1d8			ld (os_word_scratch),a 
a1d8				ld hl,(cli_ptr) 
a1d8			ld a,(hl) 
a1d8				ld (os_word_scratch+1),a 
a1d8				ld a,0 
a1d8				ld (os_word_scratch+2),a 
a1d8				ld de,os_word_scratch 
a1d8				ld a,display_row_4 
a1d8				call str_at_display 
a1d8				call update_display 
a1d8			.skip2:  
a1d8			endif 
a1d8 2a 46 ea			ld hl,(cli_token) 
a1db 7e				ld a, (hl)	 ; char in word token 
a1dc 23				inc hl 		; move to next char 
a1dd 22 46 ea			ld (cli_token), hl ; and save it 
a1e0 47				ld b,a 
a1e1			 
a1e1 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
a1e4 7e				ld a,(hl) 
a1e5 23				inc hl 
a1e6 22 40 ea			ld (cli_ptr), hl		; move to next char 
a1e9 cd 48 93			call toUpper 		; make sure the input string matches case 
a1ec			 
a1ec			if DEBUG_FORTH_PARSE 
a1ec			endif 
a1ec			 
a1ec				; input stream end of token is a space so get rid of it 
a1ec			 
a1ec			;	cp ' ' 
a1ec			;	jr nz, .pnskipspace 
a1ec			; 
a1ec			;	ld a, 0		; make same term as word token term 
a1ec			; 
a1ec			;.pnskipspace: 
a1ec			 
a1ec			if DEBUG_FORTH_PARSE_KEY 
a1ec						DMARK "KY7" 
a1ec			endif 
a1ec b8				cp b 
a1ed c2 03 a2			jp nz, .execpnskipword	 ; no match so move to next word 
a1f0				 
a1f0			;    if same 
a1f0			;       scan for string terms 0 for token and 32 for input 
a1f0			 
a1f0				 
a1f0			if DEBUG_FORTH_PARSE_KEY 
a1f0						DMARK "KY8" 
a1f0			endif 
a1f0			 
a1f0 80				add b			 
a1f1 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
a1f3							; TODO need to make sure last word in zero term string is accounted for 
a1f3 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
a1f5			 
a1f5			 
a1f5				; at end of both strings so both are exact match 
a1f5			 
a1f5			;       skip ptr for next word 
a1f5			 
a1f5 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
a1f8 23				inc hl			 ; at next char 
a1f9 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
a1fc 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
a1ff				 
a1ff				 
a1ff			if DEBUG_FORTH_PARSE_KEY 
a1ff						DMARK "KY3" 
a1ff			endif 
a1ff			 
a1ff			 
a1ff			 
a1ff			;       exec code block 
a1ff			if DEBUG_FORTH_JP 
a1ff				call clear_display 
a1ff				call update_display 
a1ff				call delay1s 
a1ff				ld hl, (cli_execword)     ; save for next check if no match on this word 
a1ff				ld a,h 
a1ff				ld hl, os_word_scratch 
a1ff				call hexout 
a1ff				ld hl, (cli_execword)     ; save for next check if no match on this word 
a1ff				ld a,l 
a1ff				ld hl, os_word_scratch+2 
a1ff				call hexout 
a1ff				ld hl, os_word_scratch+4 
a1ff				ld a,0 
a1ff				ld (hl),a 
a1ff				ld de,os_word_scratch 
a1ff				call str_at_display 
a1ff					ld a, display_row_2 
a1ff					call str_at_display 
a1ff				ld de, (cli_origtoken) 
a1ff				ld a, display_row_1+10 
a1ff					call str_at_display 
a1ff			 
a1ff				ld a,display_row_1 
a1ff				ld de, .foundword 
a1ff				ld a, display_row_3 
a1ff				call str_at_display 
a1ff				call update_display 
a1ff				call delay1s 
a1ff				call delay1s 
a1ff				call delay1s 
a1ff			endif 
a1ff			 
a1ff			if DEBUG_FORTH_PARSE_KEY 
a1ff						DMARK "KYj" 
a1ff			endif 
a1ff				; TODO save the word pointer in this exec 
a1ff			 
a1ff 2a 44 ea			ld hl,(cli_execword) 
a202 e9				jp (hl) 
a203			 
a203			 
a203			;    if not same 
a203			;	scan for zero term 
a203			;	get ptr for next word 
a203			;	goto word comp 
a203			 
a203			.execpnskipword:	; get pointer to next word 
a203 2a 42 ea			ld hl,(cli_nextword) 
a206			 
a206 7e				ld a,(hl) 
a207 fe 00			cp WORD_SYS_END 
a209			;	cp 0 
a209 28 09			jr z, .execendofdict			 ; at end of words 
a20b			 
a20b			if DEBUG_FORTH_PARSE_KEY 
a20b						DMARK "KY4" 
a20b			endif 
a20b			if DEBUG_FORTH_PARSE_EXEC 
a20b			 
a20b				; see if disabled 
a20b			 
a20b			;	ld a, (os_view_disable) 
a20b			;	cp '*' 
a20b				ld a,(debug_vector) 
a20b				cp $c9   ; RET 
a20b				jr z, .noskip 
a20b			 
a20b			 
a20b				ld de, .nowordfound 
a20b				ld a, display_row_3 
a20b				call str_at_display 
a20b				call update_display 
a20b				ld a, 100 
a20b				call aDelayInMS 
a20b				 
a20b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a20b					call delay250ms 
a20b				endif 
a20b			.noskip:  
a20b			 
a20b			endif	 
a20b			 
a20b 2a 3e ea			ld hl,(cli_origptr) 
a20e 22 40 ea			ld (cli_ptr),hl 
a211			 
a211			if DEBUG_FORTH_PARSE_KEY 
a211						DMARK "KY5" 
a211			endif 
a211 c3 b7 a1			jp .execpnword			; else go to next word 
a214			 
a214			.execendofdict:  
a214			 
a214			if DEBUG_FORTH_PARSE_KEY 
a214						DMARK "KYe" 
a214			endif 
a214			if DEBUG_FORTH_PARSE_EXEC 
a214				; see if disabled 
a214			 
a214			;	ld a, (os_view_disable) 
a214			;	cp '*' 
a214				ld a,(debug_vector) 
a214				cp $c9   ; ret 
a214				jr z, .ispskip 
a214			 
a214				call clear_display 
a214				call update_display 
a214				call delay1s 
a214				ld de, (cli_origptr) 
a214				ld a, display_row_1 
a214				call str_at_display 
a214				 
a214				ld de, .enddict 
a214				ld a, display_row_3 
a214				call str_at_display 
a214				call update_display 
a214				ld a, 100 
a214				call aDelayInMS 
a214				if DEBUG_FORTH_PARSE_EXEC_SLOW 
a214				call delay1s 
a214				call delay1s 
a214				call delay1s 
a214				endif 
a214			.ispskip:  
a214				 
a214			endif	 
a214			 
a214			 
a214			 
a214				; if the word is not a keyword then must be a literal so push it to stack 
a214			 
a214			; push token to stack to end of word 
a214			 
a214				STACKFRAME ON $1efe $2f9f 
a214				if DEBUG_STACK_IMB 
a214					if ON 
a214						exx 
a214						ld de, $1efe 
a214						ld a, d 
a214						ld hl, curframe 
a214						call hexout 
a214						ld a, e 
a214						ld hl, curframe+2 
a214						call hexout 
a214						ld hl, $1efe 
a214						push hl 
a214						ld hl, $2f9f 
a214						push hl 
a214						exx 
a214					endif 
a214				endif 
a214			endm 
# End of macro STACKFRAME
a214			 
a214 2a c2 e5		ld hl,(os_tok_ptr) 
a217 cd c8 9e		call forth_apush 
a21a			 
a21a				STACKFRAMECHK ON $1efe $2f9f 
a21a				if DEBUG_STACK_IMB 
a21a					if ON 
a21a						exx 
a21a						ld hl, $2f9f 
a21a						pop de   ; $2f9f 
a21a						call cmp16 
a21a						jr nz, .spnosame 
a21a						ld hl, $1efe 
a21a						pop de   ; $1efe 
a21a						call cmp16 
a21a						jr z, .spfrsame 
a21a						.spnosame: call showsperror 
a21a						.spfrsame: nop 
a21a						exx 
a21a					endif 
a21a				endif 
a21a			endm 
# End of macro STACKFRAMECHK
a21a			 
a21a			execnext: 
a21a			 
a21a			if DEBUG_FORTH_PARSE_KEY 
a21a						DMARK "KY>" 
a21a			endif 
a21a			; move past token to next word 
a21a			 
a21a 2a c2 e5		ld hl, (os_tok_ptr) 
a21d 3e 00		ld a, 0 
a21f 01 ff 00		ld bc, 255     ; input buffer size 
a222 ed b1		cpir 
a224			 
a224			if DEBUG_FORTH_PARSE_KEY 
a224						DMARK "KY!" 
a224				CALLMONITOR 
a224			endif	 
a224			; TODO this might place hl on the null, so will need to forward on??? 
a224			;inc hl   ; see if this gets onto the next item 
a224			 
a224			 
a224			; TODO pass a pointer to the buffer to push 
a224			; TODO call function to push 
a224			 
a224			; look for end of input 
a224			 
a224			;inc hl 
a224			;ld a,(hl) 
a224			;cp FORTH_END_BUFFER 
a224			;ret z 
a224			 
a224			 
a224 c3 9d a1		jp exec1 
a227			 
a227			 
a227			 
a227			 
a227			 
a227			 
a227			 
a227			 
a227			 
a227			findnexttok: 
a227			 
a227				; hl is pointer to move 
a227				; de is the token to locate 
a227			 
a227					if DEBUG_FORTH 
a227						DMARK "NTK" 
a227						CALLMONITOR 
a227					endif 
a227 d5				push de 
a228			 
a228			.fnt1:	 
a228				; find first char of token to locate 
a228			 
a228 1a				ld a, (de) 
a229 4f				ld c,a 
a22a 7e				ld a,(hl) 
a22b cd 48 93			call toUpper 
a22e					if DEBUG_FORTH 
a22e						DMARK "NT1" 
a22e						CALLMONITOR 
a22e					endif 
a22e b9				cp c 
a22f			 
a22f 28 03			jr z, .fnt2cmpmorefirst	 
a231			 
a231				; first char not found move to next char 
a231			 
a231 23				inc hl 
a232 18 f4			jr .fnt1 
a234			 
a234			.fnt2cmpmorefirst:	 
a234				; first char of token found.  
a234			 
a234 e5				push hl     ; save start of token just in case it is the right one 
a235 d9				exx 
a236 e1				pop hl        ; save it to hl' 
a237 d9				exx 
a238			 
a238			 
a238			.fnt2cmpmore:	 
a238				; compare the rest 
a238				 
a238 23				inc hl 
a239 13				inc de 
a23a				 
a23a 1a				ld a, (de) 
a23b 4f				ld c,a 
a23c 7e				ld a,(hl) 
a23d cd 48 93			call toUpper 
a240			 
a240					if DEBUG_FORTH 
a240						DMARK "NT2" 
a240						CALLMONITOR 
a240					endif 
a240				; c has the token to find char 
a240				; a has the mem to scan char 
a240			 
a240 b9				cp c 
a241 28 04			jr z,.fntmatch1 
a243			 
a243				; they are not the same 
a243			 
a243					if DEBUG_FORTH 
a243						DMARK "NT3" 
a243						CALLMONITOR 
a243					endif 
a243 d1				pop de	; reset de token to look for 
a244 d5				push de 
a245 18 e1			jr .fnt1 
a247				 
a247			.fntmatch1: 
a247			 
a247				; is the same char a null which means we might have a full hit? 
a247					if DEBUG_FORTH 
a247						DMARK "NT4" 
a247						CALLMONITOR 
a247					endif 
a247			 
a247 fe 00			cp 0 
a249 28 0b			jr z, .fntmatchyes 
a24b			 
a24b				; are we at the end of the token to find? 
a24b			 
a24b					if DEBUG_FORTH 
a24b						DMARK "NT5" 
a24b						CALLMONITOR 
a24b					endif 
a24b 3e 00			ld a, 0 
a24d b9				cp c 
a24e			 
a24e c2 38 a2			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a251			 
a251					if DEBUG_FORTH 
a251						DMARK "NT6" 
a251						CALLMONITOR 
a251					endif 
a251				; token to find is exhusted but no match to stream 
a251			 
a251				; restore tok pointer and continue on 
a251 d1				pop de 
a252 d5				push de 
a253 c3 28 a2			jp .fnt1 
a256			 
a256			 
a256			.fntmatchyes: 
a256			 
a256				; hl now contains the end of the found token 
a256			 
a256				; get rid of saved token pointer to find 
a256			 
a256 d1				pop de 
a257			 
a257					if DEBUG_FORTH 
a257						DMARK "NT9" 
a257						CALLMONITOR 
a257					endif 
a257			 
a257				; hl will be on the null term so forward on 
a257			 
a257				; get back the saved start of the token 
a257			 
a257 d9				exx 
a258 e5				push hl     ; save start of token just in case it is the right one 
a259 d9				exx 
a25a e1				pop hl        ; save it to hl 
a25b			 
a25b c9				ret 
a25c			 
a25c			 
a25c			; LIST needs to find a specific token   
a25c			; FORGET needs to find a spefici token 
a25c			 
a25c			; SAVE needs to find all tokens by flag 
a25c			; WORDS just needs to scan through all  by flag 
a25c			; UWORDS needs to scan through all by flag 
a25c			 
a25c			 
a25c			; given hl as pointer to start of dict look up string 
a25c			; return hl as pointer to start of word block 
a25c			; or 0 if not found 
a25c			 
a25c			forth_find_tok: 
a25c c9				ret 
a25d			 
a25d			; given hl as pointer to dict structure 
a25d			; move to the next dict block structure 
a25d			 
a25d			forth_tok_next: 
a25d				; hl now points to the address of the next word pointer  
a25d				; TODO skip compiled symbol for now 
a25d			;	push de 
a25d 23				inc hl 
a25e 5e				ld e, (hl) 
a25f 23				inc hl 
a260 56				ld d, (hl) 
a261 23				inc hl 
a262			 
a262 eb				ex de,hl 
a263			if DEBUG_FORTH_PARSE_NEXTWORD 
a263				push bc 
a263				ld bc, (cli_nextword) 
a263						DMARK "NXW" 
a263				CALLMONITOR 
a263				pop bc 
a263			endif 
a263			;	pop de	 
a263 c9				ret 
a264			 
a264			 
a264			 
a264			; eof 
# End of file forth_parserv5.asm
a264				include "forth_wordsv4.asm" 
a264			 
a264			; the core word dictionary v4 
a264			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a264			 
a264			; this is a linked list for each of the system words used 
a264			; user defined words will follow the same format but will be in ram 
a264			 
a264			 
a264			; 
a264			; 
a264			; define linked list: 
a264			; 
a264			; 1. compiled byte op code 
a264			; 2. len of text word 
a264			; 3. text word 
a264			; 4. ptr to next dictionary word 
a264			; 5. asm, calls etc for the word 
a264			; 
a264			;  if 1 == 0 then last word in dict  
a264			;   
a264			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a264			;  
a264			;  
a264			; create basic standard set of words 
a264			; 
a264			;  
a264			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a264			; 2DUP 2DROP 2SWAP  
a264			; @ C@ - get byte  
a264			; ! C! - store byte 
a264			; 0< true if less than zero 
a264			; 0= true if zero 
a264			; < >  
a264			; = true if same 
a264			; variables 
a264			 
a264			 
a264			; Hardware specific words I may need 
a264			; 
a264			; IN OUT  
a264			; calls to key util functions 
a264			; calls to hardward abstraction stuff 
a264			; easy control of frame buffers and lcd i/o 
a264			; keyboard  
a264			 
a264			 
a264			;DICT: macro 
a264			; op_code, len, word, next 
a264			;    word: 
a264			;    db op_code 
a264			;    ds word zero term 
a264			;    dw next 
a264			;    endm 
a264			 
a264			 
a264			 
a264			 
a264			; op code 1 is a flag for user define words which are to be handled differently 
a264			 
a264			 
a264			; 
a264			; 
a264			;    TODO on entry to a word this should be the expected environment 
a264			;    hl - tos value if number then held, if string this is the ptr 
a264			;    de -  
a264			 
a264			 
a264			; opcode ranges 
a264			; 0 - end of word dict 
a264			; 255 - user define words 
a264			 
a264			sysdict: 
a264			include "forth_opcodes.asm" 
a264			; op codes for forth keywords 
a264			; free to use code 0  
a264				OPCODE_HEAP: equ  1 
a264				OPCODE_EXEC: equ 2 
a264				OPCODE_DUP: equ 3 
a264				OPCODE_SWAP: equ 4 
a264				OPCODE_COLN: equ 5 
a264				OPCODE_SCOLN: equ 6 
a264				OPCODE_DROP: equ 7 
a264				OPCODE_DUP2: equ 8 
a264				OPCODE_DROP2: equ 9 
a264				OPCODE_SWAP2: equ 10 
a264				OPCODE_AT: equ 11 
a264				OPCODE_CAT: equ 12 
a264				OPCODE_BANG: equ 13 
a264				OPCODE_CBANG: equ 14 
a264				OPCODE_SCALL: equ 15 
a264				OPCODE_DEPTH: equ 16 
a264				OPCODE_OVER: equ 17 
a264				OPCODE_PAUSE: equ 18 
a264				OPCODE_PAUSES: equ 19 
a264				OPCODE_ROT: equ 20 
a264			;free to reuse	OPCODE_WORDS: equ 21 
a264			        OPCODE_NOT: equ 21 
a264				OPCODE_UWORDS: equ 22 
a264				OPCODE_BP: equ 23 
a264				OPCODE_MONITOR: equ 24  
a264				OPCODE_MALLOC: equ 25 
a264				OPCODE_FREE: equ 26 
a264				OPCODE_LIST: equ 27 
a264				OPCODE_FORGET: equ 28 
a264				OPCODE_NOP: equ 29 
a264				OPCODE_COMO: equ 30 
a264				OPCODE_COMC: equ 31 
a264			;free to reuse	OPCODE_ENDCORE: equ 32 
a264				OPCODE_AFTERSOUND: equ 33 
a264				OPCODE_GP2: equ 34 
a264				OPCODE_GP3: equ 35 
a264				OPCODE_GP4: equ 36 
a264				OPCODE_SIN: equ 37 
a264				OPCODE_SOUT: equ 38 
a264				OPCODE_SPIO: equ 39 
a264				OPCODE_SPICEH: equ 40 
a264				OPCODE_SPIOb: equ 41 
a264				OPCODE_SPII: equ 42 
a264				OPCODE_SESEL: equ 43 
a264				OPCODE_CARTDEV: equ 44 
a264			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a264				OPCODE_FB: equ 46 
a264				OPCODE_EMIT: equ 47 
a264				OPCODE_DOTH: equ 48 
a264				OPCODE_DOTF: equ 49 
a264				OPCODE_DOT: equ 50 
a264				OPCODE_CLS: equ 51 
a264				OPCODE_DRAW: equ 52 
a264				OPCODE_DUMP: equ 53 
a264				OPCODE_CDUMP: equ 54 
a264				OPCODE_DAT: equ 55 
a264				OPCODE_HOME: equ 56 
a264				OPCODE_SPACE: equ 57 
a264				OPCODE_SPACES: equ 58 
a264				OPCODE_SCROLL: equ 59 
a264				OPCODE_ATQ: equ 60 
a264				OPCODE_AUTODSP: equ 61 
a264				OPCODE_MENU: equ 62 
a264			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a264				OPCODE_THEN: equ 64 
a264				OPCODE_ELSE: equ 65 
a264				OPCODE_DO: equ 66 
a264				OPCODE_LOOP: equ 67 
a264				OPCODE_I: equ 68 
a264				OPCODE_DLOOP: equ 69  
a264				OPCODE_REPEAT: equ 70  
a264				OPCODE_UNTIL: equ 71 
a264				OPCODE_ENDFLOW: equ 72 
a264				OPCODE_WAITK: equ 73 
a264				OPCODE_ACCEPT: equ 74 
a264				OPCODE_EDIT: equ 75 
a264			;free to reuse	OPCODE_ENDKEY: equ 76 
a264				OPCODE_LZERO: equ 77 
a264				OPCODE_TZERO: equ 78 
a264				OPCODE_LESS: equ 79 
a264				OPCODE_GT: equ 80 
a264				OPCODE_EQUAL: equ 81  
a264			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a264				OPCODE_NEG: equ 83 
a264				OPCODE_DIV: equ 84 
a264				OPCODE_MUL: equ 85 
a264				OPCODE_MIN: equ 86 
a264				OPCODE_MAX: equ 87 
a264				OPCODE_RND16: equ 88 
a264				OPCODE_RND8: equ 89 
a264				OPCODE_RND: equ 90 
a264			;free to reuse	OPCODE_ENDMATHS: equ 91  
a264				OPCODE_BYNAME: equ 92 
a264				OPCODE_DIR: equ 93 
a264				OPCODE_SAVE: equ 94 
a264				OPCODE_LOAD: equ 95 
a264				OPCODE_BSAVE: equ 96 
a264				OPCODE_BLOAD: equ 97 
a264				OPCODE_SEO: equ 98  
a264				OPCODE_SEI: equ 99 
a264				OPCODE_SFREE: equ 100 
a264				OPCODE_SIZE: equ 101 
a264				OPCODE_CREATE: equ 102 
a264				OPCODE_APPEND: equ 103 
a264				OPCODE_SDEL: equ 104 
a264				OPCODE_OPEN: equ 105 
a264				OPCODE_READ: equ 106 
a264				OPCODE_EOF: equ 106 
a264				OPCODE_FORMAT: equ 107 
a264				OPCODE_LABEL: equ 108 
a264				OPCODE_LABELS: equ 109 
a264			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a264				OPCODE_UPPER: equ 111 
a264				OPCODE_LOWER: equ 112 
a264				OPCODE_SUBSTR: equ 113 
a264				OPCODE_LEFT: equ 114 
a264				OPCODE_RIGHT: equ 115 
a264				OPCODE_STR2NUM: equ 116 
a264				OPCODE_NUM2STR: equ 117 
a264				OPCODE_CONCAT: equ 118 
a264				OPCODE_FIND: equ 119 
a264				OPCODE_LEN: equ 120 
a264				OPCODE_CHAR: equ 121 
a264			; free to reuse	OPCODE_STRLEN: equ 122 
a264			; free to reuse	OPCODE_ENDSTR: equ 123 
a264				OPCODE_V0S: equ 124 
a264				OPCODE_V0Q: equ 125 
a264				OPCODE_V1S: equ 126 
a264				OPCODE_V1Q: equ 127 
a264				OPCODE_V2S: equ 128 
a264				OPCODE_V2Q: equ 129 
a264				OPCODE_V3S: equ 130 
a264				OPCODE_V3Q: equ 131 
a264			;free to reuse	OPCODE_END: equ 132 
a264				OPCODE_ZDUP: equ 133 
a264			 
a264			; eof 
# End of file forth_opcodes.asm
a264			 
a264			include "forth_words_core.asm" 
a264			 
a264			; | ## Core Words 
a264			 
a264			;if MALLOC_4 
a264			 
a264			.HEAP: 
a264			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a264 15				db WORD_SYS_CORE+OPCODE_HEAP             
a265 a3 a2			dw .EXEC            
a267 05				db 4 + 1 
a268 .. 00			db "HEAP",0              
a26d				endm 
# End of macro CWHEAD
a26d			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a26d			; | | u1 - Current number of bytes in the heap 
a26d			; | | u2 - Remaining bytes left on the heap 
a26d			; | |  
a26d			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a26d			 
a26d			 
a26d				if DEBUG_FORTH_WORDS_KEY 
a26d					DMARK "HEP" 
a26d f5				push af  
a26e 3a 82 a2			ld a, (.dmark)  
a271 32 6b ee			ld (debug_mark),a  
a274 3a 83 a2			ld a, (.dmark+1)  
a277 32 6c ee			ld (debug_mark+1),a  
a27a 3a 84 a2			ld a, (.dmark+2)  
a27d 32 6d ee			ld (debug_mark+2),a  
a280 18 03			jr .pastdmark  
a282 ..			.dmark: db "HEP"  
a285 f1			.pastdmark: pop af  
a286			endm  
# End of macro DMARK
a286					CALLMONITOR 
a286 cd 6f ee			call debug_vector  
a289				endm  
# End of macro CALLMONITOR
a289				endif 
a289 2a 06 e7			ld hl, (free_list )      
a28c 11 0b e7			ld de, heap_start 
a28f			 
a28f ed 52			sbc hl, de  
a291			 
a291 cd 5f 9d			call forth_push_numhl 
a294			 
a294			 
a294 ed 5b 06 e7		ld de, (free_list )      
a298 21 9c e2			ld hl, heap_end 
a29b			 
a29b ed 52			sbc hl, de 
a29d			 
a29d cd 5f 9d			call forth_push_numhl 
a2a0				 
a2a0			 
a2a0				 
a2a0			 
a2a0			 
a2a0			 
a2a0				NEXTW 
a2a0 c3 0c a1			jp macro_next 
a2a3				endm 
# End of macro NEXTW
a2a3			;endif 
a2a3			 
a2a3			.EXEC: 
a2a3			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a2a3			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a2a3			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a2a3			;; > > 
a2a3			;; > >   
a2a3			;	STACKFRAME OFF $5efe $5f9f 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS_KEY 
a2a3			;			DMARK "EXE" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			; 
a2a3			;	FORTH_DSP_VALUEHL 
a2a3			; 
a2a3			;	FORTH_DSP_POP 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX1" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;;	ld e,(hl) 
a2a3			;;	inc hl 
a2a3			;;	ld d,(hl) 
a2a3			;;	ex de,hl 
a2a3			; 
a2a3			;;		if DEBUG_FORTH_WORDS 
a2a3			;;			DMARK "EX2" 
a2a3			;;			CALLMONITOR 
a2a3			;;		endif 
a2a3			;	push hl 
a2a3			; 
a2a3			;	;ld a, 0 
a2a3			;	;ld a, FORTH_END_BUFFER 
a2a3			;	call strlenz 
a2a3			;	inc hl   ; include zero term to copy 
a2a3			;	inc hl   ; include term 
a2a3			;	inc hl   ; include term 
a2a3			;	ld b,0 
a2a3			;	ld c,l 
a2a3			;	pop hl 
a2a3			;	ld de, execscratch 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX3" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	ldir 
a2a3			; 
a2a3			; 
a2a3			;	ld hl, execscratch 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EXe" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			; 
a2a3			;	call forthparse 
a2a3			;	call forthexec 
a2a3			;;	call forthexec_cleanup 
a2a3			;;	call forthparse 
a2a3			;;	call forthexec 
a2a3			; 
a2a3			;	STACKFRAMECHK OFF $5efe $5f9f 
a2a3			; 
a2a3			;	; an immediate word so no need to process any more words 
a2a3			;	ret 
a2a3			;	NEXTW 
a2a3			 
a2a3			; dead code - old version  
a2a3			;	FORTH_RSP_NEXT 
a2a3			 
a2a3			;  
a2a3			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a2a3			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a2a3			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a2a3			;	push hl 
a2a3			;	push de 
a2a3			;	push bc 
a2a3			; 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS_KEY 
a2a3			;			DMARK "EXR" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			; 
a2a3			; 
a2a3			; 
a2a3			;	;v5 FORTH_DSP_VALUE 
a2a3			;	FORTH_DSP_VALUEHL 
a2a3			; 
a2a3			;	; TODO do string type checks 
a2a3			; 
a2a3			;;v5	inc hl   ; skip type 
a2a3			; 
a2a3			;	push hl  ; source code  
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX1" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	ld a, 0 
a2a3			;	call strlent 
a2a3			; 
a2a3			;	inc hl 
a2a3			;	inc hl 
a2a3			;	inc hl 
a2a3			;	inc hl 
a2a3			; 
a2a3			;	push hl    ; size 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX2" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	call malloc 
a2a3			; 
a2a3			;	ex de, hl    ; de now contains malloc area 
a2a3			;	pop bc   	; get byte count 
a2a3			;	pop hl      ; get string to copy 
a2a3			; 
a2a3			;	push de     ; save malloc for free later 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX3" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	ldir       ; duplicate string 
a2a3			; 
a2a3			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a2a3			;	 
a2a3			;	; TODO fix the parse would be better than this...  
a2a3			;	ex de, hl 
a2a3			;	dec hl 
a2a3			;	ld a, 0 
a2a3			;	ld (hl), a 
a2a3			;	dec hl 
a2a3			;	ld a, ' ' 
a2a3			;	ld (hl), a 
a2a3			;	dec hl 
a2a3			;	ld (hl), a 
a2a3			; 
a2a3			;	dec hl 
a2a3			;	ld (hl), a 
a2a3			; 
a2a3			; 
a2a3			;	FORTH_DSP_POP  
a2a3			; 
a2a3			;	pop hl     
a2a3			;	push hl    ; save malloc area 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX4" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			; 
a2a3			;	call forthparse 
a2a3			;	call forthexec 
a2a3			;	 
a2a3			;	pop hl 
a2a3			;	if DEBUG_FORTH_WORDS 
a2a3			;		DMARK "EX5" 
a2a3			;		CALLMONITOR 
a2a3			;	endif 
a2a3			; 
a2a3			;	if FORTH_ENABLE_FREE 
a2a3			;	call free 
a2a3			;	endif 
a2a3			; 
a2a3			;	if DEBUG_FORTH_WORDS 
a2a3			;		DMARK "EX6" 
a2a3			;		CALLMONITOR 
a2a3			;	endif 
a2a3			; 
a2a3			;	pop bc 
a2a3			;	pop de 
a2a3			;	pop hl 
a2a3			;;	FORTH_RSP_POP	  
a2a3			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a2a3			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a2a3			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a2a3			; 
a2a3			;	if DEBUG_FORTH_WORDS 
a2a3			;		DMARK "EX7" 
a2a3			;		CALLMONITOR 
a2a3			;	endif 
a2a3			;	NEXTW 
a2a3			 
a2a3			;.STKEXEC: 
a2a3			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a2a3			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a2a3			; 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS_KEY 
a2a3			;			DMARK "STX" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			; 
a2a3			;	FORTH_DSP_VALUEHL 
a2a3			; 
a2a3			;	ld (store_tmp1), hl    ; count 
a2a3			; 
a2a3			;	FORTH_DSP_POP 
a2a3			;.stkexec1: 
a2a3			;	ld hl, (store_tmp1)   ; count 
a2a3			;	ld a, 0 
a2a3			;	cp l 
a2a3			;	ret z 
a2a3			; 
a2a3			;	dec hl 
a2a3			;	ld (store_tmp1), hl    ; count 
a2a3			;	 
a2a3			;	FORTH_DSP_VALUEHL 
a2a3			;	push hl 
a2a3			;	 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EXp" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	FORTH_DSP_POP 
a2a3			; 
a2a3			;	call strlenz 
a2a3			;	inc hl   ; include zero term to copy 
a2a3			;	inc hl   ; include zero term to copy 
a2a3			;	inc hl   ; include zero term to copy 
a2a3			;	ld b,0 
a2a3			;	ld c,l 
a2a3			;	pop hl 
a2a3			;	ld de, execscratch 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EX3" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	ldir 
a2a3			; 
a2a3			; 
a2a3			;	ld hl, execscratch 
a2a3			; 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EXP" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			; 
a2a3			;	call forthparse 
a2a3			;	ld hl, execscratch 
a2a3			;		if DEBUG_FORTH_WORDS 
a2a3			;			DMARK "EXx" 
a2a3			;			CALLMONITOR 
a2a3			;		endif 
a2a3			;	call forthexec 
a2a3			; 
a2a3			;	jp .stkexec1 
a2a3			; 
a2a3			;	ret 
a2a3			 
a2a3			 
a2a3			.DUP: 
a2a3			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a2a3 17				db WORD_SYS_CORE+OPCODE_DUP             
a2a4 19 a3			dw .ZDUP            
a2a6 04				db 3 + 1 
a2a7 .. 00			db "DUP",0              
a2ab				endm 
# End of macro CWHEAD
a2ab			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a2ab			 
a2ab				if DEBUG_FORTH_WORDS_KEY 
a2ab					DMARK "DUP" 
a2ab f5				push af  
a2ac 3a c0 a2			ld a, (.dmark)  
a2af 32 6b ee			ld (debug_mark),a  
a2b2 3a c1 a2			ld a, (.dmark+1)  
a2b5 32 6c ee			ld (debug_mark+1),a  
a2b8 3a c2 a2			ld a, (.dmark+2)  
a2bb 32 6d ee			ld (debug_mark+2),a  
a2be 18 03			jr .pastdmark  
a2c0 ..			.dmark: db "DUP"  
a2c3 f1			.pastdmark: pop af  
a2c4			endm  
# End of macro DMARK
a2c4					CALLMONITOR 
a2c4 cd 6f ee			call debug_vector  
a2c7				endm  
# End of macro CALLMONITOR
a2c7				endif 
a2c7			 
a2c7				FORTH_DSP 
a2c7 cd 1c 9f			call macro_forth_dsp 
a2ca				endm 
# End of macro FORTH_DSP
a2ca			 
a2ca 7e				ld a, (HL) 
a2cb fe 01			cp DS_TYPE_STR 
a2cd 20 25			jr nz, .dupinum 
a2cf			 
a2cf				; push another string 
a2cf			 
a2cf				FORTH_DSP_VALUEHL     		 
a2cf cd 56 9f			call macro_dsp_valuehl 
a2d2				endm 
# End of macro FORTH_DSP_VALUEHL
a2d2			 
a2d2			if DEBUG_FORTH_WORDS 
a2d2				DMARK "DUs" 
a2d2 f5				push af  
a2d3 3a e7 a2			ld a, (.dmark)  
a2d6 32 6b ee			ld (debug_mark),a  
a2d9 3a e8 a2			ld a, (.dmark+1)  
a2dc 32 6c ee			ld (debug_mark+1),a  
a2df 3a e9 a2			ld a, (.dmark+2)  
a2e2 32 6d ee			ld (debug_mark+2),a  
a2e5 18 03			jr .pastdmark  
a2e7 ..			.dmark: db "DUs"  
a2ea f1			.pastdmark: pop af  
a2eb			endm  
# End of macro DMARK
a2eb				CALLMONITOR 
a2eb cd 6f ee			call debug_vector  
a2ee				endm  
# End of macro CALLMONITOR
a2ee			endif 
a2ee cd cd 9d			call forth_push_str 
a2f1			 
a2f1				NEXTW 
a2f1 c3 0c a1			jp macro_next 
a2f4				endm 
# End of macro NEXTW
a2f4			 
a2f4			 
a2f4			.dupinum: 
a2f4				 
a2f4			 
a2f4			 
a2f4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2f4 cd 56 9f			call macro_dsp_valuehl 
a2f7				endm 
# End of macro FORTH_DSP_VALUEHL
a2f7			 
a2f7			; TODO add floating point number detection 
a2f7			 
a2f7			if DEBUG_FORTH_WORDS 
a2f7				DMARK "DUi" 
a2f7 f5				push af  
a2f8 3a 0c a3			ld a, (.dmark)  
a2fb 32 6b ee			ld (debug_mark),a  
a2fe 3a 0d a3			ld a, (.dmark+1)  
a301 32 6c ee			ld (debug_mark+1),a  
a304 3a 0e a3			ld a, (.dmark+2)  
a307 32 6d ee			ld (debug_mark+2),a  
a30a 18 03			jr .pastdmark  
a30c ..			.dmark: db "DUi"  
a30f f1			.pastdmark: pop af  
a310			endm  
# End of macro DMARK
a310				CALLMONITOR 
a310 cd 6f ee			call debug_vector  
a313				endm  
# End of macro CALLMONITOR
a313			endif 
a313			 
a313 cd 5f 9d			call forth_push_numhl 
a316				NEXTW 
a316 c3 0c a1			jp macro_next 
a319				endm 
# End of macro NEXTW
a319			.ZDUP: 
a319			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a319 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a31a 51 a3			dw .SWAP            
a31c 05				db 4 + 1 
a31d .. 00			db "?DUP",0              
a322				endm 
# End of macro CWHEAD
a322			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a322			 
a322				if DEBUG_FORTH_WORDS_KEY 
a322					DMARK "qDU" 
a322 f5				push af  
a323 3a 37 a3			ld a, (.dmark)  
a326 32 6b ee			ld (debug_mark),a  
a329 3a 38 a3			ld a, (.dmark+1)  
a32c 32 6c ee			ld (debug_mark+1),a  
a32f 3a 39 a3			ld a, (.dmark+2)  
a332 32 6d ee			ld (debug_mark+2),a  
a335 18 03			jr .pastdmark  
a337 ..			.dmark: db "qDU"  
a33a f1			.pastdmark: pop af  
a33b			endm  
# End of macro DMARK
a33b					CALLMONITOR 
a33b cd 6f ee			call debug_vector  
a33e				endm  
# End of macro CALLMONITOR
a33e				endif 
a33e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a33e cd 56 9f			call macro_dsp_valuehl 
a341				endm 
# End of macro FORTH_DSP_VALUEHL
a341			 
a341 e5				push hl 
a342			 
a342				; is it a zero? 
a342			 
a342 3e 00			ld a, 0 
a344 84				add h 
a345 85				add l 
a346			 
a346 e1				pop hl 
a347			 
a347 fe 00			cp 0 
a349 28 03			jr z, .dup2orig 
a34b			 
a34b			 
a34b cd 5f 9d			call forth_push_numhl 
a34e			 
a34e			 
a34e			; TODO add floating point number detection 
a34e			 
a34e			.dup2orig: 
a34e			 
a34e				NEXTW 
a34e c3 0c a1			jp macro_next 
a351				endm 
# End of macro NEXTW
a351			.SWAP: 
a351			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a351 18				db WORD_SYS_CORE+OPCODE_SWAP             
a352 90 a3			dw .COLN            
a354 05				db 4 + 1 
a355 .. 00			db "SWAP",0              
a35a				endm 
# End of macro CWHEAD
a35a			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a35a				if DEBUG_FORTH_WORDS_KEY 
a35a					DMARK "SWP" 
a35a f5				push af  
a35b 3a 6f a3			ld a, (.dmark)  
a35e 32 6b ee			ld (debug_mark),a  
a361 3a 70 a3			ld a, (.dmark+1)  
a364 32 6c ee			ld (debug_mark+1),a  
a367 3a 71 a3			ld a, (.dmark+2)  
a36a 32 6d ee			ld (debug_mark+2),a  
a36d 18 03			jr .pastdmark  
a36f ..			.dmark: db "SWP"  
a372 f1			.pastdmark: pop af  
a373			endm  
# End of macro DMARK
a373					CALLMONITOR 
a373 cd 6f ee			call debug_vector  
a376				endm  
# End of macro CALLMONITOR
a376				endif 
a376			 
a376			; TODO Use os stack swap memory 
a376				FORTH_DSP_VALUEHL 
a376 cd 56 9f			call macro_dsp_valuehl 
a379				endm 
# End of macro FORTH_DSP_VALUEHL
a379 e5				push hl     ; w2 
a37a			 
a37a				FORTH_DSP_POP 
a37a cd 0e a0			call macro_forth_dsp_pop 
a37d				endm 
# End of macro FORTH_DSP_POP
a37d			 
a37d				FORTH_DSP_VALUEHL 
a37d cd 56 9f			call macro_dsp_valuehl 
a380				endm 
# End of macro FORTH_DSP_VALUEHL
a380			 
a380				FORTH_DSP_POP 
a380 cd 0e a0			call macro_forth_dsp_pop 
a383				endm 
# End of macro FORTH_DSP_POP
a383			 
a383 d1				pop de     ; w2	, hl = w1 
a384			 
a384 eb				ex de, hl 
a385 d5				push de 
a386			 
a386 cd 5f 9d			call forth_push_numhl 
a389			 
a389 e1				pop hl 
a38a			 
a38a cd 5f 9d			call forth_push_numhl 
a38d				 
a38d			 
a38d				NEXTW 
a38d c3 0c a1			jp macro_next 
a390				endm 
# End of macro NEXTW
a390			.COLN: 
a390			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a390 19				db WORD_SYS_CORE+OPCODE_COLN             
a391 1c a5			dw .SCOLN            
a393 02				db 1 + 1 
a394 .. 00			db ":",0              
a396				endm 
# End of macro CWHEAD
a396			; | : ( -- )         Create new word | DONE 
a396			 
a396				if DEBUG_FORTH_WORDS_KEY 
a396					DMARK "CLN" 
a396 f5				push af  
a397 3a ab a3			ld a, (.dmark)  
a39a 32 6b ee			ld (debug_mark),a  
a39d 3a ac a3			ld a, (.dmark+1)  
a3a0 32 6c ee			ld (debug_mark+1),a  
a3a3 3a ad a3			ld a, (.dmark+2)  
a3a6 32 6d ee			ld (debug_mark+2),a  
a3a9 18 03			jr .pastdmark  
a3ab ..			.dmark: db "CLN"  
a3ae f1			.pastdmark: pop af  
a3af			endm  
# End of macro DMARK
a3af					CALLMONITOR 
a3af cd 6f ee			call debug_vector  
a3b2				endm  
# End of macro CALLMONITOR
a3b2				endif 
a3b2			STACKFRAME OFF $8efe $989f 
a3b2				if DEBUG_STACK_IMB 
a3b2					if OFF 
a3b2						exx 
a3b2						ld de, $8efe 
a3b2						ld a, d 
a3b2						ld hl, curframe 
a3b2						call hexout 
a3b2						ld a, e 
a3b2						ld hl, curframe+2 
a3b2						call hexout 
a3b2						ld hl, $8efe 
a3b2						push hl 
a3b2						ld hl, $989f 
a3b2						push hl 
a3b2						exx 
a3b2					endif 
a3b2				endif 
a3b2			endm 
# End of macro STACKFRAME
a3b2			; get parser buffer length  of new word 
a3b2			 
a3b2			 
a3b2			 
a3b2				; move tok past this to start of name defintition 
a3b2				; TODO get word to define 
a3b2				; TODO Move past word token 
a3b2				; TODO get length of string up to the ';' 
a3b2			 
a3b2 2a c2 e5		ld hl, (os_tok_ptr) 
a3b5 23			inc hl 
a3b6 23			inc hl 
a3b7			 
a3b7 3e 3b		ld a, ';' 
a3b9 cd 5c 93		call strlent 
a3bc			 
a3bc 7d			ld a,l 
a3bd 32 b1 e2		ld (os_new_parse_len), a 
a3c0			 
a3c0			 
a3c0			if DEBUG_FORTH_UWORD 
a3c0 ed 5b c2 e5	ld de, (os_tok_ptr) 
a3c4					DMARK ":01" 
a3c4 f5				push af  
a3c5 3a d9 a3			ld a, (.dmark)  
a3c8 32 6b ee			ld (debug_mark),a  
a3cb 3a da a3			ld a, (.dmark+1)  
a3ce 32 6c ee			ld (debug_mark+1),a  
a3d1 3a db a3			ld a, (.dmark+2)  
a3d4 32 6d ee			ld (debug_mark+2),a  
a3d7 18 03			jr .pastdmark  
a3d9 ..			.dmark: db ":01"  
a3dc f1			.pastdmark: pop af  
a3dd			endm  
# End of macro DMARK
a3dd			CALLMONITOR 
a3dd cd 6f ee			call debug_vector  
a3e0				endm  
# End of macro CALLMONITOR
a3e0			endif 
a3e0			 
a3e0			; 
a3e0			;  new word memory layout: 
a3e0			;  
a3e0			;    : adg 6666 ;  
a3e0			; 
a3e0			;    db   1     ; user defined word  
a3e0 23			inc hl    
a3e1			;    dw   sysdict 
a3e1 23			inc hl 
a3e2 23			inc hl 
a3e3			;    db <word len>+1 (for null) 
a3e3 23			inc hl 
a3e4			;    db .... <word> 
a3e4			; 
a3e4			 
a3e4 23			inc hl    ; some extras for the word preamble before the above 
a3e5 23			inc hl 
a3e6 23			inc hl 
a3e7 23			inc hl 
a3e8 23			inc hl 
a3e9 23			inc hl 
a3ea 23			inc hl  
a3eb 23			inc hl 
a3ec 23			inc hl 
a3ed 23			inc hl 
a3ee 23			inc hl 
a3ef 23			inc hl 
a3f0 23			inc hl 
a3f1 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a3f2			;       exec word buffer 
a3f2			;	<ptr word>   
a3f2 23			inc hl 
a3f3 23			inc hl 
a3f4			;       <word list><null term> 7F final term 
a3f4			 
a3f4			 
a3f4			if DEBUG_FORTH_UWORD 
a3f4					DMARK ":02" 
a3f4 f5				push af  
a3f5 3a 09 a4			ld a, (.dmark)  
a3f8 32 6b ee			ld (debug_mark),a  
a3fb 3a 0a a4			ld a, (.dmark+1)  
a3fe 32 6c ee			ld (debug_mark+1),a  
a401 3a 0b a4			ld a, (.dmark+2)  
a404 32 6d ee			ld (debug_mark+2),a  
a407 18 03			jr .pastdmark  
a409 ..			.dmark: db ":02"  
a40c f1			.pastdmark: pop af  
a40d			endm  
# End of macro DMARK
a40d			CALLMONITOR 
a40d cd 6f ee			call debug_vector  
a410				endm  
# End of macro CALLMONITOR
a410			endif 
a410			 
a410			 
a410				; malloc the size 
a410			 
a410 cd c6 93			call malloc 
a413 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a416			 
a416			;    db   1     ; user defined word  
a416 3e 01			ld a, WORD_SYS_UWORD  
a418 77				ld (hl), a 
a419			 
a419 23			inc hl    
a41a			;    dw   sysdict 
a41a 11 64 a2		ld de, sysdict       ; continue on with the scan to the system dict 
a41d 73			ld (hl), e 
a41e 23			inc hl 
a41f 72			ld (hl), d 
a420 23			inc hl 
a421			 
a421			 
a421			;    Setup dict word 
a421			 
a421 23			inc hl 
a422 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a425			 
a425			; 1. get length of dict word 
a425			 
a425			 
a425 2a c2 e5		ld hl, (os_tok_ptr) 
a428 23			inc hl 
a429 23			inc hl    ; position to start of dict word 
a42a 3e 00		ld a, 0 
a42c cd 5c 93		call strlent 
a42f			 
a42f			 
a42f 23			inc hl    ; to include null??? 
a430			 
a430			; write length of dict word 
a430			 
a430 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a434 1b			dec de 
a435 eb			ex de, hl 
a436 73			ld (hl), e 
a437 eb			ex de, hl 
a438			 
a438			 
a438			 
a438			; copy  
a438 4d			ld c, l 
a439 06 00		ld b, 0 
a43b ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a43f 2a c2 e5		ld hl, (os_tok_ptr) 
a442 23			inc hl 
a443 23			inc hl    ; position to start of dict word 
a444			 
a444			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a444			 
a444			; TODO need to convert word to upper case 
a444			 
a444			ucasetok:	 
a444 7e			ld a,(hl) 
a445 cd 48 93		call toUpper 
a448 77			ld (hl),a 
a449 ed a0		ldi 
a44b f2 44 a4		jp p, ucasetok 
a44e			 
a44e			 
a44e			 
a44e			; de now points to start of where the word body code should be placed 
a44e ed 53 ad e2	ld (os_new_work_ptr), de 
a452			; hl now points to the words to throw at forthexec which needs to be copied 
a452 22 ab e2		ld (os_new_src_ptr), hl 
a455			 
a455			; TODO add 'call to forthexec' 
a455			 
a455			if DEBUG_FORTH_UWORD 
a455 c5			push bc 
a456 ed 4b b3 e2	ld bc, (os_new_malloc) 
a45a					DMARK ":0x" 
a45a f5				push af  
a45b 3a 6f a4			ld a, (.dmark)  
a45e 32 6b ee			ld (debug_mark),a  
a461 3a 70 a4			ld a, (.dmark+1)  
a464 32 6c ee			ld (debug_mark+1),a  
a467 3a 71 a4			ld a, (.dmark+2)  
a46a 32 6d ee			ld (debug_mark+2),a  
a46d 18 03			jr .pastdmark  
a46f ..			.dmark: db ":0x"  
a472 f1			.pastdmark: pop af  
a473			endm  
# End of macro DMARK
a473			CALLMONITOR 
a473 cd 6f ee			call debug_vector  
a476				endm  
# End of macro CALLMONITOR
a476 c1			pop bc 
a477			endif 
a477			 
a477			 
a477			; create word preamble which should be: 
a477			 
a477			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a477			 
a477			;    ld hl, <word code> 
a477			;    jp user_exec 
a477			;    <word code bytes> 
a477			 
a477			 
a477			;	inc de     ; TODO ??? or are we already past the word's null 
a477 eb			ex de, hl 
a478			 
a478 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a47a			 
a47a 23			inc hl 
a47b 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a47e 23			inc hl 
a47f			 
a47f 23			inc hl 
a480 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a482			 
a482 01 fa cd		ld bc, user_exec 
a485 23			inc hl 
a486 71			ld (hl), c     ; poke address of user_exec 
a487 23			inc hl 
a488 70			ld (hl), b     
a489			; 
a489			;	inc hl 
a489			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a489			; 
a489			; 
a489			;	ld bc, macro_forth_rsp_next 
a489			;	inc hl 
a489			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a489			;	inc hl 
a489			;	ld (hl), b     
a489			; 
a489			;	inc hl 
a489			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a489			; 
a489			; 
a489			;	inc hl 
a489			;	ld bc, forthexec 
a489			;	ld (hl), c     ; poke address of forthexec 
a489			;	inc hl 
a489			;	ld (hl), b      
a489			; 
a489			;	inc hl 
a489			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a489			; 
a489			;	ld bc, user_dict_next 
a489			;	inc hl 
a489			;	ld (hl), c     ; poke address of forthexec 
a489			;	inc hl 
a489			;	ld (hl), b      
a489			 
a489			; hl is now where we need to copy the word byte data to save this 
a489			 
a489 23			inc hl 
a48a 22 a9 e2		ld (os_new_exec), hl 
a48d			 
a48d			; copy definition 
a48d			 
a48d eb			ex de, hl 
a48e			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a48e			;	inc de    ; skip the PC for this parse 
a48e 3a b1 e2		ld a, (os_new_parse_len) 
a491 4f			ld c, a 
a492 06 00		ld b, 0 
a494 ed b0		ldir		 ; copy defintion 
a496			 
a496			 
a496			; poke the address of where the new word bytes live for forthexec 
a496			 
a496 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a499			 
a499 ed 5b a9 e2	ld de, (os_new_exec)      
a49d			 
a49d 73			ld (hl), e 
a49e 23			inc hl 
a49f 72			ld (hl), d 
a4a0			 
a4a0				; TODO copy last user dict word next link to this word 
a4a0				; TODO update last user dict word to point to this word 
a4a0			; 
a4a0			; hl f923 de 812a ; bc 811a 
a4a0			 
a4a0			if DEBUG_FORTH_UWORD 
a4a0 c5			push bc 
a4a1 ed 4b b3 e2	ld bc, (os_new_malloc) 
a4a5					DMARK ":0A" 
a4a5 f5				push af  
a4a6 3a ba a4			ld a, (.dmark)  
a4a9 32 6b ee			ld (debug_mark),a  
a4ac 3a bb a4			ld a, (.dmark+1)  
a4af 32 6c ee			ld (debug_mark+1),a  
a4b2 3a bc a4			ld a, (.dmark+2)  
a4b5 32 6d ee			ld (debug_mark+2),a  
a4b8 18 03			jr .pastdmark  
a4ba ..			.dmark: db ":0A"  
a4bd f1			.pastdmark: pop af  
a4be			endm  
# End of macro DMARK
a4be			CALLMONITOR 
a4be cd 6f ee			call debug_vector  
a4c1				endm  
# End of macro CALLMONITOR
a4c1 c1			pop bc 
a4c2			endif 
a4c2			if DEBUG_FORTH_UWORD 
a4c2 c5			push bc 
a4c3 ed 4b b3 e2	ld bc, (os_new_malloc) 
a4c7 03			inc bc 
a4c8 03			inc bc 
a4c9 03			inc bc 
a4ca 03			inc bc 
a4cb 03			inc bc 
a4cc 03			inc bc 
a4cd 03			inc bc 
a4ce 03			inc bc 
a4cf			 
a4cf					DMARK ":0B" 
a4cf f5				push af  
a4d0 3a e4 a4			ld a, (.dmark)  
a4d3 32 6b ee			ld (debug_mark),a  
a4d6 3a e5 a4			ld a, (.dmark+1)  
a4d9 32 6c ee			ld (debug_mark+1),a  
a4dc 3a e6 a4			ld a, (.dmark+2)  
a4df 32 6d ee			ld (debug_mark+2),a  
a4e2 18 03			jr .pastdmark  
a4e4 ..			.dmark: db ":0B"  
a4e7 f1			.pastdmark: pop af  
a4e8			endm  
# End of macro DMARK
a4e8			CALLMONITOR 
a4e8 cd 6f ee			call debug_vector  
a4eb				endm  
# End of macro CALLMONITOR
a4eb c1			pop bc 
a4ec			endif 
a4ec			 
a4ec			; update word dict linked list for new word 
a4ec			 
a4ec			 
a4ec 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a4ef 23			inc hl     ; move to next work linked list ptr 
a4f0			 
a4f0 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a4f4 73			ld (hl), e 
a4f5 23			inc hl 
a4f6 72			ld (hl), d 
a4f7			 
a4f7			if DEBUG_FORTH_UWORD 
a4f7 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a4fb			endif 
a4fb			 
a4fb ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a4ff			 
a4ff			 
a4ff			if DEBUG_FORTH_UWORD 
a4ff					DMARK ":0+" 
a4ff f5				push af  
a500 3a 14 a5			ld a, (.dmark)  
a503 32 6b ee			ld (debug_mark),a  
a506 3a 15 a5			ld a, (.dmark+1)  
a509 32 6c ee			ld (debug_mark+1),a  
a50c 3a 16 a5			ld a, (.dmark+2)  
a50f 32 6d ee			ld (debug_mark+2),a  
a512 18 03			jr .pastdmark  
a514 ..			.dmark: db ":0+"  
a517 f1			.pastdmark: pop af  
a518			endm  
# End of macro DMARK
a518			CALLMONITOR 
a518 cd 6f ee			call debug_vector  
a51b				endm  
# End of macro CALLMONITOR
a51b			endif 
a51b			 
a51b			STACKFRAMECHK OFF $8efe $989f 
a51b				if DEBUG_STACK_IMB 
a51b					if OFF 
a51b						exx 
a51b						ld hl, $989f 
a51b						pop de   ; $989f 
a51b						call cmp16 
a51b						jr nz, .spnosame 
a51b						ld hl, $8efe 
a51b						pop de   ; $8efe 
a51b						call cmp16 
a51b						jr z, .spfrsame 
a51b						.spnosame: call showsperror 
a51b						.spfrsame: nop 
a51b						exx 
a51b					endif 
a51b				endif 
a51b			endm 
# End of macro STACKFRAMECHK
a51b			 
a51b c9			ret    ; dont process any remaining parser tokens as they form new word 
a51c			 
a51c			 
a51c			 
a51c			 
a51c			;		NEXT 
a51c			.SCOLN: 
a51c			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a51c 06			db OPCODE_SCOLN 
a51d 68 a5		dw .DROP 
a51f 02			db 2 
a520 .. 00		db ";",0           
a522			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a522				if DEBUG_FORTH_WORDS_KEY 
a522					DMARK "SCN" 
a522 f5				push af  
a523 3a 37 a5			ld a, (.dmark)  
a526 32 6b ee			ld (debug_mark),a  
a529 3a 38 a5			ld a, (.dmark+1)  
a52c 32 6c ee			ld (debug_mark+1),a  
a52f 3a 39 a5			ld a, (.dmark+2)  
a532 32 6d ee			ld (debug_mark+2),a  
a535 18 03			jr .pastdmark  
a537 ..			.dmark: db "SCN"  
a53a f1			.pastdmark: pop af  
a53b			endm  
# End of macro DMARK
a53b					CALLMONITOR 
a53b cd 6f ee			call debug_vector  
a53e				endm  
# End of macro CALLMONITOR
a53e				endif 
a53e				FORTH_RSP_TOS 
a53e cd 1d 9d			call macro_forth_rsp_tos 
a541				endm 
# End of macro FORTH_RSP_TOS
a541 e5				push hl 
a542				FORTH_RSP_POP 
a542 cd 27 9d			call macro_forth_rsp_pop 
a545				endm 
# End of macro FORTH_RSP_POP
a545 e1				pop hl 
a546			;		ex de,hl 
a546 22 c2 e5			ld (os_tok_ptr),hl 
a549			 
a549			if DEBUG_FORTH_UWORD 
a549					DMARK "SCL" 
a549 f5				push af  
a54a 3a 5e a5			ld a, (.dmark)  
a54d 32 6b ee			ld (debug_mark),a  
a550 3a 5f a5			ld a, (.dmark+1)  
a553 32 6c ee			ld (debug_mark+1),a  
a556 3a 60 a5			ld a, (.dmark+2)  
a559 32 6d ee			ld (debug_mark+2),a  
a55c 18 03			jr .pastdmark  
a55e ..			.dmark: db "SCL"  
a561 f1			.pastdmark: pop af  
a562			endm  
# End of macro DMARK
a562			CALLMONITOR 
a562 cd 6f ee			call debug_vector  
a565				endm  
# End of macro CALLMONITOR
a565			endif 
a565				NEXTW 
a565 c3 0c a1			jp macro_next 
a568				endm 
# End of macro NEXTW
a568			 
a568			.DROP: 
a568			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a568 1b				db WORD_SYS_CORE+OPCODE_DROP             
a569 93 a5			dw .DUP2            
a56b 05				db 4 + 1 
a56c .. 00			db "DROP",0              
a571				endm 
# End of macro CWHEAD
a571			; | DROP ( w -- )   drop the TOS item   | DONE 
a571				if DEBUG_FORTH_WORDS_KEY 
a571					DMARK "DRP" 
a571 f5				push af  
a572 3a 86 a5			ld a, (.dmark)  
a575 32 6b ee			ld (debug_mark),a  
a578 3a 87 a5			ld a, (.dmark+1)  
a57b 32 6c ee			ld (debug_mark+1),a  
a57e 3a 88 a5			ld a, (.dmark+2)  
a581 32 6d ee			ld (debug_mark+2),a  
a584 18 03			jr .pastdmark  
a586 ..			.dmark: db "DRP"  
a589 f1			.pastdmark: pop af  
a58a			endm  
# End of macro DMARK
a58a					CALLMONITOR 
a58a cd 6f ee			call debug_vector  
a58d				endm  
# End of macro CALLMONITOR
a58d				endif 
a58d				FORTH_DSP_POP 
a58d cd 0e a0			call macro_forth_dsp_pop 
a590				endm 
# End of macro FORTH_DSP_POP
a590				NEXTW 
a590 c3 0c a1			jp macro_next 
a593				endm 
# End of macro NEXTW
a593			.DUP2: 
a593			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a593 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a594 d8 a5			dw .DROP2            
a596 05				db 4 + 1 
a597 .. 00			db "2DUP",0              
a59c				endm 
# End of macro CWHEAD
a59c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a59c				if DEBUG_FORTH_WORDS_KEY 
a59c					DMARK "2DU" 
a59c f5				push af  
a59d 3a b1 a5			ld a, (.dmark)  
a5a0 32 6b ee			ld (debug_mark),a  
a5a3 3a b2 a5			ld a, (.dmark+1)  
a5a6 32 6c ee			ld (debug_mark+1),a  
a5a9 3a b3 a5			ld a, (.dmark+2)  
a5ac 32 6d ee			ld (debug_mark+2),a  
a5af 18 03			jr .pastdmark  
a5b1 ..			.dmark: db "2DU"  
a5b4 f1			.pastdmark: pop af  
a5b5			endm  
# End of macro DMARK
a5b5					CALLMONITOR 
a5b5 cd 6f ee			call debug_vector  
a5b8				endm  
# End of macro CALLMONITOR
a5b8				endif 
a5b8				FORTH_DSP_VALUEHL 
a5b8 cd 56 9f			call macro_dsp_valuehl 
a5bb				endm 
# End of macro FORTH_DSP_VALUEHL
a5bb e5				push hl      ; 2 
a5bc			 
a5bc				FORTH_DSP_POP 
a5bc cd 0e a0			call macro_forth_dsp_pop 
a5bf				endm 
# End of macro FORTH_DSP_POP
a5bf				 
a5bf				FORTH_DSP_VALUEHL 
a5bf cd 56 9f			call macro_dsp_valuehl 
a5c2				endm 
# End of macro FORTH_DSP_VALUEHL
a5c2			;		push hl      ; 1 
a5c2			 
a5c2				FORTH_DSP_POP 
a5c2 cd 0e a0			call macro_forth_dsp_pop 
a5c5				endm 
# End of macro FORTH_DSP_POP
a5c5			 
a5c5			;		pop hl       ; 1 
a5c5 d1				pop de       ; 2 
a5c6			 
a5c6 cd 5f 9d			call forth_push_numhl 
a5c9 eb				ex de, hl 
a5ca cd 5f 9d			call forth_push_numhl 
a5cd			 
a5cd				 
a5cd eb				ex de, hl 
a5ce			 
a5ce cd 5f 9d			call forth_push_numhl 
a5d1 eb				ex de, hl 
a5d2 cd 5f 9d			call forth_push_numhl 
a5d5			 
a5d5			 
a5d5				NEXTW 
a5d5 c3 0c a1			jp macro_next 
a5d8				endm 
# End of macro NEXTW
a5d8			.DROP2: 
a5d8			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a5d8 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a5d9 07 a6			dw .SWAP2            
a5db 06				db 5 + 1 
a5dc .. 00			db "2DROP",0              
a5e2				endm 
# End of macro CWHEAD
a5e2			; | 2DROP ( w w -- )    Double drop | DONE 
a5e2				if DEBUG_FORTH_WORDS_KEY 
a5e2					DMARK "2DR" 
a5e2 f5				push af  
a5e3 3a f7 a5			ld a, (.dmark)  
a5e6 32 6b ee			ld (debug_mark),a  
a5e9 3a f8 a5			ld a, (.dmark+1)  
a5ec 32 6c ee			ld (debug_mark+1),a  
a5ef 3a f9 a5			ld a, (.dmark+2)  
a5f2 32 6d ee			ld (debug_mark+2),a  
a5f5 18 03			jr .pastdmark  
a5f7 ..			.dmark: db "2DR"  
a5fa f1			.pastdmark: pop af  
a5fb			endm  
# End of macro DMARK
a5fb					CALLMONITOR 
a5fb cd 6f ee			call debug_vector  
a5fe				endm  
# End of macro CALLMONITOR
a5fe				endif 
a5fe				FORTH_DSP_POP 
a5fe cd 0e a0			call macro_forth_dsp_pop 
a601				endm 
# End of macro FORTH_DSP_POP
a601				FORTH_DSP_POP 
a601 cd 0e a0			call macro_forth_dsp_pop 
a604				endm 
# End of macro FORTH_DSP_POP
a604				NEXTW 
a604 c3 0c a1			jp macro_next 
a607				endm 
# End of macro NEXTW
a607			.SWAP2: 
a607			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a607 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a608 30 a6			dw .AT            
a60a 06				db 5 + 1 
a60b .. 00			db "2SWAP",0              
a611				endm 
# End of macro CWHEAD
a611			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a611				if DEBUG_FORTH_WORDS_KEY 
a611					DMARK "2SW" 
a611 f5				push af  
a612 3a 26 a6			ld a, (.dmark)  
a615 32 6b ee			ld (debug_mark),a  
a618 3a 27 a6			ld a, (.dmark+1)  
a61b 32 6c ee			ld (debug_mark+1),a  
a61e 3a 28 a6			ld a, (.dmark+2)  
a621 32 6d ee			ld (debug_mark+2),a  
a624 18 03			jr .pastdmark  
a626 ..			.dmark: db "2SW"  
a629 f1			.pastdmark: pop af  
a62a			endm  
# End of macro DMARK
a62a					CALLMONITOR 
a62a cd 6f ee			call debug_vector  
a62d				endm  
# End of macro CALLMONITOR
a62d				endif 
a62d			; TODO Use os stack swap memory 
a62d				NEXTW 
a62d c3 0c a1			jp macro_next 
a630				endm 
# End of macro NEXTW
a630			.AT: 
a630			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a630 1f				db WORD_SYS_CORE+OPCODE_AT             
a631 62 a6			dw .CAT            
a633 02				db 1 + 1 
a634 .. 00			db "@",0              
a636				endm 
# End of macro CWHEAD
a636			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a636			 
a636				if DEBUG_FORTH_WORDS_KEY 
a636					DMARK "AT." 
a636 f5				push af  
a637 3a 4b a6			ld a, (.dmark)  
a63a 32 6b ee			ld (debug_mark),a  
a63d 3a 4c a6			ld a, (.dmark+1)  
a640 32 6c ee			ld (debug_mark+1),a  
a643 3a 4d a6			ld a, (.dmark+2)  
a646 32 6d ee			ld (debug_mark+2),a  
a649 18 03			jr .pastdmark  
a64b ..			.dmark: db "AT."  
a64e f1			.pastdmark: pop af  
a64f			endm  
# End of macro DMARK
a64f					CALLMONITOR 
a64f cd 6f ee			call debug_vector  
a652				endm  
# End of macro CALLMONITOR
a652				endif 
a652			.getbyteat:	 
a652				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a652 cd 56 9f			call macro_dsp_valuehl 
a655				endm 
# End of macro FORTH_DSP_VALUEHL
a655				 
a655			;		push hl 
a655			 
a655				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a655 cd 0e a0			call macro_forth_dsp_pop 
a658				endm 
# End of macro FORTH_DSP_POP
a658			 
a658			;		pop hl 
a658			 
a658 7e				ld a, (hl) 
a659			 
a659 6f				ld l, a 
a65a 26 00			ld h, 0 
a65c cd 5f 9d			call forth_push_numhl 
a65f			 
a65f				NEXTW 
a65f c3 0c a1			jp macro_next 
a662				endm 
# End of macro NEXTW
a662			.CAT: 
a662			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a662 20				db WORD_SYS_CORE+OPCODE_CAT             
a663 8b a6			dw .BANG            
a665 03				db 2 + 1 
a666 .. 00			db "C@",0              
a669				endm 
# End of macro CWHEAD
a669			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a669				if DEBUG_FORTH_WORDS_KEY 
a669					DMARK "CAA" 
a669 f5				push af  
a66a 3a 7e a6			ld a, (.dmark)  
a66d 32 6b ee			ld (debug_mark),a  
a670 3a 7f a6			ld a, (.dmark+1)  
a673 32 6c ee			ld (debug_mark+1),a  
a676 3a 80 a6			ld a, (.dmark+2)  
a679 32 6d ee			ld (debug_mark+2),a  
a67c 18 03			jr .pastdmark  
a67e ..			.dmark: db "CAA"  
a681 f1			.pastdmark: pop af  
a682			endm  
# End of macro DMARK
a682					CALLMONITOR 
a682 cd 6f ee			call debug_vector  
a685				endm  
# End of macro CALLMONITOR
a685				endif 
a685 c3 52 a6			jp .getbyteat 
a688				NEXTW 
a688 c3 0c a1			jp macro_next 
a68b				endm 
# End of macro NEXTW
a68b			.BANG: 
a68b			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a68b 21				db WORD_SYS_CORE+OPCODE_BANG             
a68c c1 a6			dw .CBANG            
a68e 02				db 1 + 1 
a68f .. 00			db "!",0              
a691				endm 
# End of macro CWHEAD
a691			; | ! ( x w -- ) Store x at address w      | DONE 
a691				if DEBUG_FORTH_WORDS_KEY 
a691					DMARK "BNG" 
a691 f5				push af  
a692 3a a6 a6			ld a, (.dmark)  
a695 32 6b ee			ld (debug_mark),a  
a698 3a a7 a6			ld a, (.dmark+1)  
a69b 32 6c ee			ld (debug_mark+1),a  
a69e 3a a8 a6			ld a, (.dmark+2)  
a6a1 32 6d ee			ld (debug_mark+2),a  
a6a4 18 03			jr .pastdmark  
a6a6 ..			.dmark: db "BNG"  
a6a9 f1			.pastdmark: pop af  
a6aa			endm  
# End of macro DMARK
a6aa					CALLMONITOR 
a6aa cd 6f ee			call debug_vector  
a6ad				endm  
# End of macro CALLMONITOR
a6ad				endif 
a6ad			 
a6ad			.storebyteat:		 
a6ad				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6ad cd 56 9f			call macro_dsp_valuehl 
a6b0				endm 
# End of macro FORTH_DSP_VALUEHL
a6b0				 
a6b0 e5				push hl 
a6b1			 
a6b1				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6b1 cd 0e a0			call macro_forth_dsp_pop 
a6b4				endm 
# End of macro FORTH_DSP_POP
a6b4			 
a6b4				; get byte to poke 
a6b4			 
a6b4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6b4 cd 56 9f			call macro_dsp_valuehl 
a6b7				endm 
# End of macro FORTH_DSP_VALUEHL
a6b7 e5				push hl 
a6b8			 
a6b8			 
a6b8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6b8 cd 0e a0			call macro_forth_dsp_pop 
a6bb				endm 
# End of macro FORTH_DSP_POP
a6bb			 
a6bb			 
a6bb d1				pop de 
a6bc e1				pop hl 
a6bd			 
a6bd 73				ld (hl),e 
a6be			 
a6be			 
a6be				NEXTW 
a6be c3 0c a1			jp macro_next 
a6c1				endm 
# End of macro NEXTW
a6c1			.CBANG: 
a6c1			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a6c1 22				db WORD_SYS_CORE+OPCODE_CBANG             
a6c2 ea a6			dw .SCALL            
a6c4 03				db 2 + 1 
a6c5 .. 00			db "C!",0              
a6c8				endm 
# End of macro CWHEAD
a6c8			; | C!  ( x w -- ) Store x at address w  | DONE 
a6c8				if DEBUG_FORTH_WORDS_KEY 
a6c8					DMARK "CBA" 
a6c8 f5				push af  
a6c9 3a dd a6			ld a, (.dmark)  
a6cc 32 6b ee			ld (debug_mark),a  
a6cf 3a de a6			ld a, (.dmark+1)  
a6d2 32 6c ee			ld (debug_mark+1),a  
a6d5 3a df a6			ld a, (.dmark+2)  
a6d8 32 6d ee			ld (debug_mark+2),a  
a6db 18 03			jr .pastdmark  
a6dd ..			.dmark: db "CBA"  
a6e0 f1			.pastdmark: pop af  
a6e1			endm  
# End of macro DMARK
a6e1					CALLMONITOR 
a6e1 cd 6f ee			call debug_vector  
a6e4				endm  
# End of macro CALLMONITOR
a6e4				endif 
a6e4 c3 ad a6			jp .storebyteat 
a6e7				NEXTW 
a6e7 c3 0c a1			jp macro_next 
a6ea				endm 
# End of macro NEXTW
a6ea			.SCALL: 
a6ea			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a6ea 23				db WORD_SYS_CORE+OPCODE_SCALL             
a6eb 1e a7			dw .DEPTH            
a6ed 05				db 4 + 1 
a6ee .. 00			db "CALL",0              
a6f3				endm 
# End of macro CWHEAD
a6f3			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a6f3				if DEBUG_FORTH_WORDS_KEY 
a6f3					DMARK "CLL" 
a6f3 f5				push af  
a6f4 3a 08 a7			ld a, (.dmark)  
a6f7 32 6b ee			ld (debug_mark),a  
a6fa 3a 09 a7			ld a, (.dmark+1)  
a6fd 32 6c ee			ld (debug_mark+1),a  
a700 3a 0a a7			ld a, (.dmark+2)  
a703 32 6d ee			ld (debug_mark+2),a  
a706 18 03			jr .pastdmark  
a708 ..			.dmark: db "CLL"  
a70b f1			.pastdmark: pop af  
a70c			endm  
# End of macro DMARK
a70c					CALLMONITOR 
a70c cd 6f ee			call debug_vector  
a70f				endm  
# End of macro CALLMONITOR
a70f				endif 
a70f			 
a70f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a70f cd 56 9f			call macro_dsp_valuehl 
a712				endm 
# End of macro FORTH_DSP_VALUEHL
a712			 
a712			;		push hl 
a712			 
a712				; destroy value TOS 
a712			 
a712				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a712 cd 0e a0			call macro_forth_dsp_pop 
a715				endm 
# End of macro FORTH_DSP_POP
a715			 
a715					 
a715			;		pop hl 
a715			 
a715				; how to do a call with hl???? save SP? 
a715 cd b0 a0			call forth_call_hl 
a718			 
a718			 
a718				; TODO push value back onto stack for another op etc 
a718			 
a718 cd 5f 9d			call forth_push_numhl 
a71b				NEXTW 
a71b c3 0c a1			jp macro_next 
a71e				endm 
# End of macro NEXTW
a71e			.DEPTH: 
a71e			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a71e 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a71f 5b a7			dw .OVER            
a721 06				db 5 + 1 
a722 .. 00			db "DEPTH",0              
a728				endm 
# End of macro CWHEAD
a728			; | DEPTH ( -- u ) Push count of stack | DONE 
a728				; take current TOS and remove from base value div by two to get count 
a728				if DEBUG_FORTH_WORDS_KEY 
a728					DMARK "DEP" 
a728 f5				push af  
a729 3a 3d a7			ld a, (.dmark)  
a72c 32 6b ee			ld (debug_mark),a  
a72f 3a 3e a7			ld a, (.dmark+1)  
a732 32 6c ee			ld (debug_mark+1),a  
a735 3a 3f a7			ld a, (.dmark+2)  
a738 32 6d ee			ld (debug_mark+2),a  
a73b 18 03			jr .pastdmark  
a73d ..			.dmark: db "DEP"  
a740 f1			.pastdmark: pop af  
a741			endm  
# End of macro DMARK
a741					CALLMONITOR 
a741 cd 6f ee			call debug_vector  
a744				endm  
# End of macro CALLMONITOR
a744				endif 
a744			 
a744			 
a744 2a ee e9		ld hl, (cli_data_sp) 
a747 11 28 e8		ld de, cli_data_stack 
a74a ed 52		sbc hl,de 
a74c			 
a74c			; div by size of stack item 
a74c			 
a74c 5d			ld e,l 
a74d 0e 03		ld c, 3 
a74f cd 6b 8c		call Div8 
a752			 
a752 6f			ld l,a 
a753 26 00		ld h,0 
a755			 
a755			;srl h 
a755			;rr l 
a755			 
a755 cd 5f 9d			call forth_push_numhl 
a758				NEXTW 
a758 c3 0c a1			jp macro_next 
a75b				endm 
# End of macro NEXTW
a75b			.OVER: 
a75b			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a75b 42				db WORD_SYS_CORE+46             
a75c a2 a7			dw .PAUSE            
a75e 05				db 4 + 1 
a75f .. 00			db "OVER",0              
a764				endm 
# End of macro CWHEAD
a764			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a764				if DEBUG_FORTH_WORDS_KEY 
a764					DMARK "OVR" 
a764 f5				push af  
a765 3a 79 a7			ld a, (.dmark)  
a768 32 6b ee			ld (debug_mark),a  
a76b 3a 7a a7			ld a, (.dmark+1)  
a76e 32 6c ee			ld (debug_mark+1),a  
a771 3a 7b a7			ld a, (.dmark+2)  
a774 32 6d ee			ld (debug_mark+2),a  
a777 18 03			jr .pastdmark  
a779 ..			.dmark: db "OVR"  
a77c f1			.pastdmark: pop af  
a77d			endm  
# End of macro DMARK
a77d					CALLMONITOR 
a77d cd 6f ee			call debug_vector  
a780				endm  
# End of macro CALLMONITOR
a780				endif 
a780			 
a780			; TODO Use os stack swap memory 
a780				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a780 cd 56 9f			call macro_dsp_valuehl 
a783				endm 
# End of macro FORTH_DSP_VALUEHL
a783 e5				push hl    ; n2 
a784				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a784 cd 0e a0			call macro_forth_dsp_pop 
a787				endm 
# End of macro FORTH_DSP_POP
a787			 
a787				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a787 cd 56 9f			call macro_dsp_valuehl 
a78a				endm 
# End of macro FORTH_DSP_VALUEHL
a78a e5				push hl    ; n1 
a78b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a78b cd 0e a0			call macro_forth_dsp_pop 
a78e				endm 
# End of macro FORTH_DSP_POP
a78e			 
a78e d1				pop de     ; n1 
a78f e1				pop hl     ; n2 
a790			 
a790 d5				push de 
a791 e5				push hl 
a792 d5				push de 
a793			 
a793				; push back  
a793			 
a793 e1				pop hl 
a794 cd 5f 9d			call forth_push_numhl 
a797 e1				pop hl 
a798 cd 5f 9d			call forth_push_numhl 
a79b e1				pop hl 
a79c cd 5f 9d			call forth_push_numhl 
a79f				NEXTW 
a79f c3 0c a1			jp macro_next 
a7a2				endm 
# End of macro NEXTW
a7a2			 
a7a2			.PAUSE: 
a7a2			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a7a2 43				db WORD_SYS_CORE+47             
a7a3 d7 a7			dw .PAUSES            
a7a5 08				db 7 + 1 
a7a6 .. 00			db "PAUSEMS",0              
a7ae				endm 
# End of macro CWHEAD
a7ae			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a7ae				if DEBUG_FORTH_WORDS_KEY 
a7ae					DMARK "PMS" 
a7ae f5				push af  
a7af 3a c3 a7			ld a, (.dmark)  
a7b2 32 6b ee			ld (debug_mark),a  
a7b5 3a c4 a7			ld a, (.dmark+1)  
a7b8 32 6c ee			ld (debug_mark+1),a  
a7bb 3a c5 a7			ld a, (.dmark+2)  
a7be 32 6d ee			ld (debug_mark+2),a  
a7c1 18 03			jr .pastdmark  
a7c3 ..			.dmark: db "PMS"  
a7c6 f1			.pastdmark: pop af  
a7c7			endm  
# End of macro DMARK
a7c7					CALLMONITOR 
a7c7 cd 6f ee			call debug_vector  
a7ca				endm  
# End of macro CALLMONITOR
a7ca				endif 
a7ca				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7ca cd 56 9f			call macro_dsp_valuehl 
a7cd				endm 
# End of macro FORTH_DSP_VALUEHL
a7cd			;		push hl    ; n2 
a7cd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7cd cd 0e a0			call macro_forth_dsp_pop 
a7d0				endm 
# End of macro FORTH_DSP_POP
a7d0			;		pop hl 
a7d0			 
a7d0 7d				ld a, l 
a7d1 cd d6 89			call aDelayInMS 
a7d4			       NEXTW 
a7d4 c3 0c a1			jp macro_next 
a7d7				endm 
# End of macro NEXTW
a7d7			.PAUSES:  
a7d7			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a7d7 44				db WORD_SYS_CORE+48             
a7d8 46 a8			dw .ROT            
a7da 06				db 5 + 1 
a7db .. 00			db "PAUSE",0              
a7e1				endm 
# End of macro CWHEAD
a7e1			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a7e1				if DEBUG_FORTH_WORDS_KEY 
a7e1					DMARK "PAU" 
a7e1 f5				push af  
a7e2 3a f6 a7			ld a, (.dmark)  
a7e5 32 6b ee			ld (debug_mark),a  
a7e8 3a f7 a7			ld a, (.dmark+1)  
a7eb 32 6c ee			ld (debug_mark+1),a  
a7ee 3a f8 a7			ld a, (.dmark+2)  
a7f1 32 6d ee			ld (debug_mark+2),a  
a7f4 18 03			jr .pastdmark  
a7f6 ..			.dmark: db "PAU"  
a7f9 f1			.pastdmark: pop af  
a7fa			endm  
# End of macro DMARK
a7fa					CALLMONITOR 
a7fa cd 6f ee			call debug_vector  
a7fd				endm  
# End of macro CALLMONITOR
a7fd				endif 
a7fd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7fd cd 56 9f			call macro_dsp_valuehl 
a800				endm 
# End of macro FORTH_DSP_VALUEHL
a800			;		push hl    ; n2 
a800				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a800 cd 0e a0			call macro_forth_dsp_pop 
a803				endm 
# End of macro FORTH_DSP_POP
a803			;		pop hl 
a803 45				ld b, l 
a804				if DEBUG_FORTH_WORDS 
a804					DMARK "PAU" 
a804 f5				push af  
a805 3a 19 a8			ld a, (.dmark)  
a808 32 6b ee			ld (debug_mark),a  
a80b 3a 1a a8			ld a, (.dmark+1)  
a80e 32 6c ee			ld (debug_mark+1),a  
a811 3a 1b a8			ld a, (.dmark+2)  
a814 32 6d ee			ld (debug_mark+2),a  
a817 18 03			jr .pastdmark  
a819 ..			.dmark: db "PAU"  
a81c f1			.pastdmark: pop af  
a81d			endm  
# End of macro DMARK
a81d					CALLMONITOR 
a81d cd 6f ee			call debug_vector  
a820				endm  
# End of macro CALLMONITOR
a820				endif 
a820 c5			.pauses1:	push bc 
a821 cd f1 89			call delay1s 
a824 c1				pop bc 
a825				if DEBUG_FORTH_WORDS 
a825					DMARK "PA1" 
a825 f5				push af  
a826 3a 3a a8			ld a, (.dmark)  
a829 32 6b ee			ld (debug_mark),a  
a82c 3a 3b a8			ld a, (.dmark+1)  
a82f 32 6c ee			ld (debug_mark+1),a  
a832 3a 3c a8			ld a, (.dmark+2)  
a835 32 6d ee			ld (debug_mark+2),a  
a838 18 03			jr .pastdmark  
a83a ..			.dmark: db "PA1"  
a83d f1			.pastdmark: pop af  
a83e			endm  
# End of macro DMARK
a83e					CALLMONITOR 
a83e cd 6f ee			call debug_vector  
a841				endm  
# End of macro CALLMONITOR
a841				endif 
a841 10 dd			djnz .pauses1 
a843			 
a843			       NEXTW 
a843 c3 0c a1			jp macro_next 
a846				endm 
# End of macro NEXTW
a846			.ROT: 
a846			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a846 45				db WORD_SYS_CORE+49             
a847 94 a8			dw .UWORDS            
a849 04				db 3 + 1 
a84a .. 00			db "ROT",0              
a84e				endm 
# End of macro CWHEAD
a84e			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a84e				if DEBUG_FORTH_WORDS_KEY 
a84e					DMARK "ROT" 
a84e f5				push af  
a84f 3a 63 a8			ld a, (.dmark)  
a852 32 6b ee			ld (debug_mark),a  
a855 3a 64 a8			ld a, (.dmark+1)  
a858 32 6c ee			ld (debug_mark+1),a  
a85b 3a 65 a8			ld a, (.dmark+2)  
a85e 32 6d ee			ld (debug_mark+2),a  
a861 18 03			jr .pastdmark  
a863 ..			.dmark: db "ROT"  
a866 f1			.pastdmark: pop af  
a867			endm  
# End of macro DMARK
a867					CALLMONITOR 
a867 cd 6f ee			call debug_vector  
a86a				endm  
# End of macro CALLMONITOR
a86a				endif 
a86a			 
a86a			; TODO Use os stack swap memory 
a86a				FORTH_DSP_VALUEHL 
a86a cd 56 9f			call macro_dsp_valuehl 
a86d				endm 
# End of macro FORTH_DSP_VALUEHL
a86d e5				push hl    ; u3  
a86e			 
a86e				FORTH_DSP_POP 
a86e cd 0e a0			call macro_forth_dsp_pop 
a871				endm 
# End of macro FORTH_DSP_POP
a871			 
a871				FORTH_DSP_VALUEHL 
a871 cd 56 9f			call macro_dsp_valuehl 
a874				endm 
# End of macro FORTH_DSP_VALUEHL
a874 e5				push hl     ; u2 
a875			 
a875				FORTH_DSP_POP 
a875 cd 0e a0			call macro_forth_dsp_pop 
a878				endm 
# End of macro FORTH_DSP_POP
a878			 
a878				FORTH_DSP_VALUEHL 
a878 cd 56 9f			call macro_dsp_valuehl 
a87b				endm 
# End of macro FORTH_DSP_VALUEHL
a87b e5				push hl     ; u1 
a87c			 
a87c				FORTH_DSP_POP 
a87c cd 0e a0			call macro_forth_dsp_pop 
a87f				endm 
# End of macro FORTH_DSP_POP
a87f			 
a87f c1				pop bc      ; u1 
a880 e1				pop hl      ; u2 
a881 d1				pop de      ; u3 
a882			 
a882			 
a882 c5				push bc 
a883 d5				push de 
a884 e5				push hl 
a885			 
a885			 
a885 e1				pop hl 
a886 cd 5f 9d			call forth_push_numhl 
a889			 
a889 e1				pop hl 
a88a cd 5f 9d			call forth_push_numhl 
a88d			 
a88d e1				pop hl 
a88e cd 5f 9d			call forth_push_numhl 
a891				 
a891			 
a891			 
a891			 
a891			 
a891			 
a891			       NEXTW 
a891 c3 0c a1			jp macro_next 
a894				endm 
# End of macro NEXTW
a894			 
a894			.UWORDS: 
a894			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a894 50				db WORD_SYS_CORE+60             
a895 56 a9			dw .BP            
a897 07				db 6 + 1 
a898 .. 00			db "UWORDS",0              
a89f				endm 
# End of macro CWHEAD
a89f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a89f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a89f			; | | Following the count are the individual words. 
a89f			; | | 
a89f			; | | e.g. UWORDS 
a89f			; | | BOX DIRLIST 2 
a89f			; | |  
a89f			; | | Can be used to save the words to storage via: 
a89f			; | | UWORDS $01 DO $01 APPEND LOOP 
a89f			if DEBUG_FORTH_WORDS_KEY 
a89f				DMARK "UWR" 
a89f f5				push af  
a8a0 3a b4 a8			ld a, (.dmark)  
a8a3 32 6b ee			ld (debug_mark),a  
a8a6 3a b5 a8			ld a, (.dmark+1)  
a8a9 32 6c ee			ld (debug_mark+1),a  
a8ac 3a b6 a8			ld a, (.dmark+2)  
a8af 32 6d ee			ld (debug_mark+2),a  
a8b2 18 03			jr .pastdmark  
a8b4 ..			.dmark: db "UWR"  
a8b7 f1			.pastdmark: pop af  
a8b8			endm  
# End of macro DMARK
a8b8				CALLMONITOR 
a8b8 cd 6f ee			call debug_vector  
a8bb				endm  
# End of macro CALLMONITOR
a8bb			endif 
a8bb 21 fc e6			ld hl, baseram 
a8be				;ld hl, baseusermem 
a8be 01 00 00			ld bc, 0    ; start a counter 
a8c1			 
a8c1			; skip dict stub 
a8c1			 
a8c1 cd 5d a2			call forth_tok_next 
a8c4			 
a8c4			 
a8c4			; while we have words to look for 
a8c4			 
a8c4 7e			.douscan:	ld a, (hl)      
a8c5			if DEBUG_FORTH_WORDS 
a8c5				DMARK "UWs" 
a8c5 f5				push af  
a8c6 3a da a8			ld a, (.dmark)  
a8c9 32 6b ee			ld (debug_mark),a  
a8cc 3a db a8			ld a, (.dmark+1)  
a8cf 32 6c ee			ld (debug_mark+1),a  
a8d2 3a dc a8			ld a, (.dmark+2)  
a8d5 32 6d ee			ld (debug_mark+2),a  
a8d8 18 03			jr .pastdmark  
a8da ..			.dmark: db "UWs"  
a8dd f1			.pastdmark: pop af  
a8de			endm  
# End of macro DMARK
a8de				CALLMONITOR 
a8de cd 6f ee			call debug_vector  
a8e1				endm  
# End of macro CALLMONITOR
a8e1			endif 
a8e1 fe 00			cp WORD_SYS_END 
a8e3 28 4d			jr z, .udone 
a8e5 fe 01			cp WORD_SYS_UWORD 
a8e7 20 44			jr nz, .nuword 
a8e9			 
a8e9			if DEBUG_FORTH_WORDS 
a8e9				DMARK "UWu" 
a8e9 f5				push af  
a8ea 3a fe a8			ld a, (.dmark)  
a8ed 32 6b ee			ld (debug_mark),a  
a8f0 3a ff a8			ld a, (.dmark+1)  
a8f3 32 6c ee			ld (debug_mark+1),a  
a8f6 3a 00 a9			ld a, (.dmark+2)  
a8f9 32 6d ee			ld (debug_mark+2),a  
a8fc 18 03			jr .pastdmark  
a8fe ..			.dmark: db "UWu"  
a901 f1			.pastdmark: pop af  
a902			endm  
# End of macro DMARK
a902				CALLMONITOR 
a902 cd 6f ee			call debug_vector  
a905				endm  
# End of macro CALLMONITOR
a905			endif 
a905				; we have a uword so push its name to the stack 
a905			 
a905 e5				push hl  ; save so we can move to next dict block 
a906			 
a906				; skip opcode 
a906 23				inc hl  
a907				; skip next ptr 
a907 23				inc hl  
a908 23				inc hl 
a909				; skip len 
a909 23				inc hl 
a90a			if DEBUG_FORTH_WORDS 
a90a				DMARK "UWt" 
a90a f5				push af  
a90b 3a 1f a9			ld a, (.dmark)  
a90e 32 6b ee			ld (debug_mark),a  
a911 3a 20 a9			ld a, (.dmark+1)  
a914 32 6c ee			ld (debug_mark+1),a  
a917 3a 21 a9			ld a, (.dmark+2)  
a91a 32 6d ee			ld (debug_mark+2),a  
a91d 18 03			jr .pastdmark  
a91f ..			.dmark: db "UWt"  
a922 f1			.pastdmark: pop af  
a923			endm  
# End of macro DMARK
a923				CALLMONITOR 
a923 cd 6f ee			call debug_vector  
a926				endm  
# End of macro CALLMONITOR
a926			endif 
a926 03				inc bc 
a927			 
a927 c5				push bc 
a928 cd cd 9d			call forth_push_str 
a92b c1				pop bc 
a92c			 
a92c e1				pop hl 	 
a92d			 
a92d cd 5d a2		.nuword:	call forth_tok_next 
a930 18 92			jr .douscan  
a932			 
a932			.udone:		 ; push count of uwords found 
a932 c5				push bc 
a933 e1				pop hl 
a934			 
a934			if DEBUG_FORTH_WORDS 
a934				DMARK "UWc" 
a934 f5				push af  
a935 3a 49 a9			ld a, (.dmark)  
a938 32 6b ee			ld (debug_mark),a  
a93b 3a 4a a9			ld a, (.dmark+1)  
a93e 32 6c ee			ld (debug_mark+1),a  
a941 3a 4b a9			ld a, (.dmark+2)  
a944 32 6d ee			ld (debug_mark+2),a  
a947 18 03			jr .pastdmark  
a949 ..			.dmark: db "UWc"  
a94c f1			.pastdmark: pop af  
a94d			endm  
# End of macro DMARK
a94d				CALLMONITOR 
a94d cd 6f ee			call debug_vector  
a950				endm  
# End of macro CALLMONITOR
a950			endif 
a950 cd 5f 9d			call forth_push_numhl 
a953			 
a953			 
a953			       NEXTW 
a953 c3 0c a1			jp macro_next 
a956				endm 
# End of macro NEXTW
a956			 
a956			.BP: 
a956			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a956 54				db WORD_SYS_CORE+64             
a957 90 a9			dw .MONITOR            
a959 03				db 2 + 1 
a95a .. 00			db "BP",0              
a95d				endm 
# End of macro CWHEAD
a95d			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a95d			; | | $00 Will enable the break points within specific code paths 
a95d			; | | $01 Will disable break points 
a95d			; | |  
a95d			; | | By default break points are off. Either the above can be used to enable them 
a95d			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a95d			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a95d			; | | can disable break points. Exiting will then continue boot process. 
a95d				; get byte count 
a95d				if DEBUG_FORTH_WORDS_KEY 
a95d					DMARK "BP." 
a95d f5				push af  
a95e 3a 72 a9			ld a, (.dmark)  
a961 32 6b ee			ld (debug_mark),a  
a964 3a 73 a9			ld a, (.dmark+1)  
a967 32 6c ee			ld (debug_mark+1),a  
a96a 3a 74 a9			ld a, (.dmark+2)  
a96d 32 6d ee			ld (debug_mark+2),a  
a970 18 03			jr .pastdmark  
a972 ..			.dmark: db "BP."  
a975 f1			.pastdmark: pop af  
a976			endm  
# End of macro DMARK
a976					CALLMONITOR 
a976 cd 6f ee			call debug_vector  
a979				endm  
# End of macro CALLMONITOR
a979				endif 
a979			 
a979				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a979 cd 56 9f			call macro_dsp_valuehl 
a97c				endm 
# End of macro FORTH_DSP_VALUEHL
a97c			 
a97c			;		push hl 
a97c			 
a97c				; destroy value TOS 
a97c			 
a97c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a97c cd 0e a0			call macro_forth_dsp_pop 
a97f				endm 
# End of macro FORTH_DSP_POP
a97f			 
a97f			;		pop hl 
a97f			 
a97f 3e 00			ld a,0 
a981 bd				cp l 
a982 28 06			jr z, .bpset 
a984			;		ld a, '*' 
a984 cd 01 97			call bp_off 
a987				NEXTW 
a987 c3 0c a1			jp macro_next 
a98a				endm 
# End of macro NEXTW
a98a			 
a98a			.bpset:	 
a98a				;	ld (os_view_disable), a 
a98a cd f5 96			call bp_on 
a98d			 
a98d			 
a98d				NEXTW 
a98d c3 0c a1			jp macro_next 
a990				endm 
# End of macro NEXTW
a990			 
a990			 
a990			.MONITOR: 
a990			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a990 55				db WORD_SYS_CORE+65             
a991 c1 a9			dw .MALLOC            
a993 08				db 7 + 1 
a994 .. 00			db "MONITOR",0              
a99c				endm 
# End of macro CWHEAD
a99c			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a99c			; | | At start the current various registers will be displayed with contents. 
a99c			; | | Top right corner will show the most recent debug marker seen. 
a99c			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a99c			; | | and the return stack pointer (RSP). 
a99c			; | | Pressing: 
a99c			; | |    1 - Initial screen 
a99c			; | |    2 - Display a data dump of HL 
a99c			; | |    3 - Display a data dump of DE 
a99c			; | |    4 - Display a data dump of BC 
a99c			; | |    5 - Display a data dump of HL 
a99c			; | |    6 - Display a data dump of DSP 
a99c			; | |    7 - Display a data dump of RSP 
a99c			; | |    8 - Display a data dump of what is at DSP 
a99c			; | |    9 - Display a data dump of what is at RSP 
a99c			; | |    0 - Exit monitor and continue running. This will also enable break points 
a99c			; | |    * - Disable break points 
a99c			; | |    # - Enter traditional monitor mode 
a99c			; | | 
a99c			; | | Monitor Mode 
a99c			; | | ------------ 
a99c			; | | A prompt of '>' will be shown for various commands: 
a99c			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a99c			; | |    C - Continue display a data dump from the last set address 
a99c			; | |    M xxxx - Set start of memory edit at address xx 
a99c			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a99c			; | |    G xxxx - Exec code at specific address 
a99c			; | |    Q - Return to previous 
a99c				if DEBUG_FORTH_WORDS_KEY 
a99c					DMARK "MON" 
a99c f5				push af  
a99d 3a b1 a9			ld a, (.dmark)  
a9a0 32 6b ee			ld (debug_mark),a  
a9a3 3a b2 a9			ld a, (.dmark+1)  
a9a6 32 6c ee			ld (debug_mark+1),a  
a9a9 3a b3 a9			ld a, (.dmark+2)  
a9ac 32 6d ee			ld (debug_mark+2),a  
a9af 18 03			jr .pastdmark  
a9b1 ..			.dmark: db "MON"  
a9b4 f1			.pastdmark: pop af  
a9b5			endm  
# End of macro DMARK
a9b5					CALLMONITOR 
a9b5 cd 6f ee			call debug_vector  
a9b8				endm  
# End of macro CALLMONITOR
a9b8				endif 
a9b8			;		ld a, 0 
a9b8			;		ld (os_view_disable), a 
a9b8 cd f5 96			call bp_on 
a9bb			 
a9bb				CALLMONITOR 
a9bb cd 6f ee			call debug_vector  
a9be				endm  
# End of macro CALLMONITOR
a9be			 
a9be			;	call monitor 
a9be			 
a9be				NEXTW 
a9be c3 0c a1			jp macro_next 
a9c1				endm 
# End of macro NEXTW
a9c1			 
a9c1			 
a9c1			.MALLOC: 
a9c1			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a9c1 56				db WORD_SYS_CORE+66             
a9c2 ea a9			dw .MALLOC2            
a9c4 06				db 5 + 1 
a9c5 .. 00			db "ALLOT",0              
a9cb				endm 
# End of macro CWHEAD
a9cb			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a9cb				if DEBUG_FORTH_WORDS_KEY 
a9cb					DMARK "ALL" 
a9cb f5				push af  
a9cc 3a e0 a9			ld a, (.dmark)  
a9cf 32 6b ee			ld (debug_mark),a  
a9d2 3a e1 a9			ld a, (.dmark+1)  
a9d5 32 6c ee			ld (debug_mark+1),a  
a9d8 3a e2 a9			ld a, (.dmark+2)  
a9db 32 6d ee			ld (debug_mark+2),a  
a9de 18 03			jr .pastdmark  
a9e0 ..			.dmark: db "ALL"  
a9e3 f1			.pastdmark: pop af  
a9e4			endm  
# End of macro DMARK
a9e4					CALLMONITOR 
a9e4 cd 6f ee			call debug_vector  
a9e7				endm  
# End of macro CALLMONITOR
a9e7				endif 
a9e7 c3 11 aa			jp .mallocc 
a9ea			.MALLOC2: 
a9ea			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a9ea 56				db WORD_SYS_CORE+66             
a9eb 28 aa			dw .FREE            
a9ed 07				db 6 + 1 
a9ee .. 00			db "MALLOC",0              
a9f5				endm 
# End of macro CWHEAD
a9f5			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a9f5				; get byte count 
a9f5				if DEBUG_FORTH_WORDS_KEY 
a9f5					DMARK "MAL" 
a9f5 f5				push af  
a9f6 3a 0a aa			ld a, (.dmark)  
a9f9 32 6b ee			ld (debug_mark),a  
a9fc 3a 0b aa			ld a, (.dmark+1)  
a9ff 32 6c ee			ld (debug_mark+1),a  
aa02 3a 0c aa			ld a, (.dmark+2)  
aa05 32 6d ee			ld (debug_mark+2),a  
aa08 18 03			jr .pastdmark  
aa0a ..			.dmark: db "MAL"  
aa0d f1			.pastdmark: pop af  
aa0e			endm  
# End of macro DMARK
aa0e					CALLMONITOR 
aa0e cd 6f ee			call debug_vector  
aa11				endm  
# End of macro CALLMONITOR
aa11				endif 
aa11			.mallocc: 
aa11				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
aa11 cd 56 9f			call macro_dsp_valuehl 
aa14				endm 
# End of macro FORTH_DSP_VALUEHL
aa14			 
aa14			;		push hl 
aa14			 
aa14				; destroy value TOS 
aa14			 
aa14				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
aa14 cd 0e a0			call macro_forth_dsp_pop 
aa17				endm 
# End of macro FORTH_DSP_POP
aa17			 
aa17			;		pop hl 
aa17 cd c6 93			call malloc 
aa1a			if DEBUG_FORTH_MALLOC_GUARD 
aa1a f5				push af 
aa1b cd 04 8d			call ishlzero 
aa1e			;		ld a, l 
aa1e			;		add h 
aa1e			;		cp 0 
aa1e f1				pop af 
aa1f				 
aa1f cc cc ce			call z,malloc_error 
aa22			endif 
aa22			 
aa22 cd 5f 9d			call forth_push_numhl 
aa25				NEXTW 
aa25 c3 0c a1			jp macro_next 
aa28				endm 
# End of macro NEXTW
aa28			 
aa28			.FREE: 
aa28			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
aa28 57				db WORD_SYS_CORE+67             
aa29 59 aa			dw .LIST            
aa2b 05				db 4 + 1 
aa2c .. 00			db "FREE",0              
aa31				endm 
# End of macro CWHEAD
aa31			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
aa31				if DEBUG_FORTH_WORDS_KEY 
aa31					DMARK "FRE" 
aa31 f5				push af  
aa32 3a 46 aa			ld a, (.dmark)  
aa35 32 6b ee			ld (debug_mark),a  
aa38 3a 47 aa			ld a, (.dmark+1)  
aa3b 32 6c ee			ld (debug_mark+1),a  
aa3e 3a 48 aa			ld a, (.dmark+2)  
aa41 32 6d ee			ld (debug_mark+2),a  
aa44 18 03			jr .pastdmark  
aa46 ..			.dmark: db "FRE"  
aa49 f1			.pastdmark: pop af  
aa4a			endm  
# End of macro DMARK
aa4a					CALLMONITOR 
aa4a cd 6f ee			call debug_vector  
aa4d				endm  
# End of macro CALLMONITOR
aa4d				endif 
aa4d				; get address 
aa4d			 
aa4d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
aa4d cd 56 9f			call macro_dsp_valuehl 
aa50				endm 
# End of macro FORTH_DSP_VALUEHL
aa50			 
aa50			;		push hl 
aa50			 
aa50				; destroy value TOS 
aa50			 
aa50				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
aa50 cd 0e a0			call macro_forth_dsp_pop 
aa53				endm 
# End of macro FORTH_DSP_POP
aa53			 
aa53			;		pop hl 
aa53			if FORTH_ENABLE_MALLOCFREE 
aa53 cd 90 94			call free 
aa56			endif 
aa56				NEXTW 
aa56 c3 0c a1			jp macro_next 
aa59				endm 
# End of macro NEXTW
aa59			.LIST: 
aa59			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
aa59 5c				db WORD_SYS_CORE+72             
aa5a 49 ac			dw .FORGET            
aa5c 05				db 4 + 1 
aa5d .. 00			db "LIST",0              
aa62				endm 
# End of macro CWHEAD
aa62			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
aa62			; | | The quoted word must be in upper case. 
aa62			if DEBUG_FORTH_WORDS_KEY 
aa62				DMARK "LST" 
aa62 f5				push af  
aa63 3a 77 aa			ld a, (.dmark)  
aa66 32 6b ee			ld (debug_mark),a  
aa69 3a 78 aa			ld a, (.dmark+1)  
aa6c 32 6c ee			ld (debug_mark+1),a  
aa6f 3a 79 aa			ld a, (.dmark+2)  
aa72 32 6d ee			ld (debug_mark+2),a  
aa75 18 03			jr .pastdmark  
aa77 ..			.dmark: db "LST"  
aa7a f1			.pastdmark: pop af  
aa7b			endm  
# End of macro DMARK
aa7b				CALLMONITOR 
aa7b cd 6f ee			call debug_vector  
aa7e				endm  
# End of macro CALLMONITOR
aa7e			endif 
aa7e			 
aa7e				FORTH_DSP_VALUEHL 
aa7e cd 56 9f			call macro_dsp_valuehl 
aa81				endm 
# End of macro FORTH_DSP_VALUEHL
aa81			 
aa81 e5				push hl 
aa82				FORTH_DSP_POP 
aa82 cd 0e a0			call macro_forth_dsp_pop 
aa85				endm 
# End of macro FORTH_DSP_POP
aa85 c1				pop bc 
aa86			 
aa86			; Start format of scratch string 
aa86			 
aa86 21 c1 e2			ld hl, scratch 
aa89			 
aa89 3e 3a			ld a, ':' 
aa8b 77				ld (hl),a 
aa8c 23				inc hl 
aa8d 3e 20			ld a, ' ' 
aa8f 77				ld (hl), a 
aa90			 
aa90				; Get ptr to the word we need to look up 
aa90			 
aa90			;		FORTH_DSP_VALUEHL 
aa90				;v5 FORTH_DSP_VALUE 
aa90			; TODO type check 
aa90			;		inc hl    ; Skip type check  
aa90			;		push hl 
aa90			;		ex de, hl    ; put into DE 
aa90			 
aa90			 
aa90 21 fc e6			ld hl, baseram 
aa93				;ld hl, baseusermem 
aa93			 
aa93 e5			push hl   ; sacreifical push 
aa94			 
aa94			.ldouscanm: 
aa94 e1			pop hl 
aa95			.ldouscan: 
aa95			if DEBUG_FORTH_WORDS 
aa95				DMARK "LSs" 
aa95 f5				push af  
aa96 3a aa aa			ld a, (.dmark)  
aa99 32 6b ee			ld (debug_mark),a  
aa9c 3a ab aa			ld a, (.dmark+1)  
aa9f 32 6c ee			ld (debug_mark+1),a  
aaa2 3a ac aa			ld a, (.dmark+2)  
aaa5 32 6d ee			ld (debug_mark+2),a  
aaa8 18 03			jr .pastdmark  
aaaa ..			.dmark: db "LSs"  
aaad f1			.pastdmark: pop af  
aaae			endm  
# End of macro DMARK
aaae				CALLMONITOR 
aaae cd 6f ee			call debug_vector  
aab1				endm  
# End of macro CALLMONITOR
aab1			endif 
aab1			; skip dict stub 
aab1 cd 5d a2			call forth_tok_next 
aab4			 
aab4			 
aab4			; while we have words to look for 
aab4			 
aab4 7e			ld a, (hl)      
aab5			if DEBUG_FORTH_WORDS 
aab5				DMARK "LSk" 
aab5 f5				push af  
aab6 3a ca aa			ld a, (.dmark)  
aab9 32 6b ee			ld (debug_mark),a  
aabc 3a cb aa			ld a, (.dmark+1)  
aabf 32 6c ee			ld (debug_mark+1),a  
aac2 3a cc aa			ld a, (.dmark+2)  
aac5 32 6d ee			ld (debug_mark+2),a  
aac8 18 03			jr .pastdmark  
aaca ..			.dmark: db "LSk"  
aacd f1			.pastdmark: pop af  
aace			endm  
# End of macro DMARK
aace				CALLMONITOR 
aace cd 6f ee			call debug_vector  
aad1				endm  
# End of macro CALLMONITOR
aad1			endif 
aad1				;cp WORD_SYS_END 
aad1				;jp z, .lunotfound 
aad1			 
aad1					; if we hit non uwords then gone too far 
aad1 fe 01				cp WORD_SYS_UWORD 
aad3 c2 05 ac				jp nz, .lunotfound 
aad6			 
aad6				if DEBUG_FORTH_WORDS 
aad6					DMARK "LSu" 
aad6 f5				push af  
aad7 3a eb aa			ld a, (.dmark)  
aada 32 6b ee			ld (debug_mark),a  
aadd 3a ec aa			ld a, (.dmark+1)  
aae0 32 6c ee			ld (debug_mark+1),a  
aae3 3a ed aa			ld a, (.dmark+2)  
aae6 32 6d ee			ld (debug_mark+2),a  
aae9 18 03			jr .pastdmark  
aaeb ..			.dmark: db "LSu"  
aaee f1			.pastdmark: pop af  
aaef			endm  
# End of macro DMARK
aaef					CALLMONITOR 
aaef cd 6f ee			call debug_vector  
aaf2				endm  
# End of macro CALLMONITOR
aaf2				endif 
aaf2			 
aaf2					; found a uword but is it the one we want... 
aaf2			 
aaf2 c5					push bc     ; uword to find is on bc 
aaf3 d1					pop de 
aaf4			 
aaf4 e5					push hl  ; to save the ptr 
aaf5			 
aaf5					; skip opcode 
aaf5 23					inc hl  
aaf6					; skip next ptr 
aaf6 23					inc hl  
aaf7 23					inc hl 
aaf8					; skip len 
aaf8 23					inc hl 
aaf9			 
aaf9				if DEBUG_FORTH_WORDS 
aaf9					DMARK "LSc" 
aaf9 f5				push af  
aafa 3a 0e ab			ld a, (.dmark)  
aafd 32 6b ee			ld (debug_mark),a  
ab00 3a 0f ab			ld a, (.dmark+1)  
ab03 32 6c ee			ld (debug_mark+1),a  
ab06 3a 10 ab			ld a, (.dmark+2)  
ab09 32 6d ee			ld (debug_mark+2),a  
ab0c 18 03			jr .pastdmark  
ab0e ..			.dmark: db "LSc"  
ab11 f1			.pastdmark: pop af  
ab12			endm  
# End of macro DMARK
ab12					CALLMONITOR 
ab12 cd 6f ee			call debug_vector  
ab15				endm  
# End of macro CALLMONITOR
ab15				endif 
ab15			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
ab15			; ie. If WOO is defined first and then WO. Couldnt list WO. 
ab15			; Nope that has gone the other way. It needs to be exact not on first zero 
ab15			;		call strcmp 
ab15 c5					push bc 
ab16 cd 96 93				call StrictStrCmp 
ab19 c1					pop bc 
ab1a c2 94 aa				jp nz, .ldouscanm 
ab1d				 
ab1d			 
ab1d			 
ab1d					; we have a uword so push its name to the stack 
ab1d			 
ab1d			;	   	push hl  ; save so we can move to next dict block 
ab1d e1			pop hl 
ab1e			 
ab1e				if DEBUG_FORTH_WORDS 
ab1e					DMARK "LSm" 
ab1e f5				push af  
ab1f 3a 33 ab			ld a, (.dmark)  
ab22 32 6b ee			ld (debug_mark),a  
ab25 3a 34 ab			ld a, (.dmark+1)  
ab28 32 6c ee			ld (debug_mark+1),a  
ab2b 3a 35 ab			ld a, (.dmark+2)  
ab2e 32 6d ee			ld (debug_mark+2),a  
ab31 18 03			jr .pastdmark  
ab33 ..			.dmark: db "LSm"  
ab36 f1			.pastdmark: pop af  
ab37			endm  
# End of macro DMARK
ab37					CALLMONITOR 
ab37 cd 6f ee			call debug_vector  
ab3a				endm  
# End of macro CALLMONITOR
ab3a				endif 
ab3a			 
ab3a					; skip opcode 
ab3a 23					inc hl  
ab3b					; skip next ptr 
ab3b 23					inc hl  
ab3c 23					inc hl 
ab3d					; skip len 
ab3d 7e					ld a, (hl)   ; save length to add 
ab3e				if DEBUG_FORTH_WORDS 
ab3e					DMARK "LS2" 
ab3e f5				push af  
ab3f 3a 53 ab			ld a, (.dmark)  
ab42 32 6b ee			ld (debug_mark),a  
ab45 3a 54 ab			ld a, (.dmark+1)  
ab48 32 6c ee			ld (debug_mark+1),a  
ab4b 3a 55 ab			ld a, (.dmark+2)  
ab4e 32 6d ee			ld (debug_mark+2),a  
ab51 18 03			jr .pastdmark  
ab53 ..			.dmark: db "LS2"  
ab56 f1			.pastdmark: pop af  
ab57			endm  
# End of macro DMARK
ab57					CALLMONITOR 
ab57 cd 6f ee			call debug_vector  
ab5a				endm  
# End of macro CALLMONITOR
ab5a				endif 
ab5a			 
ab5a					; save this location 
ab5a				 
ab5a e5					push hl 
ab5b			 
ab5b 23					inc hl 
ab5c 11 c3 e2				ld de, scratch+2 
ab5f 4f					ld c, a 
ab60 06 00				ld b, 0 
ab62			 
ab62				if DEBUG_FORTH_WORDS 
ab62					DMARK "LSn" 
ab62 f5				push af  
ab63 3a 77 ab			ld a, (.dmark)  
ab66 32 6b ee			ld (debug_mark),a  
ab69 3a 78 ab			ld a, (.dmark+1)  
ab6c 32 6c ee			ld (debug_mark+1),a  
ab6f 3a 79 ab			ld a, (.dmark+2)  
ab72 32 6d ee			ld (debug_mark+2),a  
ab75 18 03			jr .pastdmark  
ab77 ..			.dmark: db "LSn"  
ab7a f1			.pastdmark: pop af  
ab7b			endm  
# End of macro DMARK
ab7b					CALLMONITOR 
ab7b cd 6f ee			call debug_vector  
ab7e				endm  
# End of macro CALLMONITOR
ab7e				endif 
ab7e			 
ab7e					; copy uword name to scratch 
ab7e			 
ab7e ed b0				ldir 
ab80			 
ab80 1b					dec de 
ab81 3e 20				ld a, ' '    ; change null to space 
ab83 12					ld (de), a 
ab84			 
ab84 13					inc de 
ab85			 
ab85 d5					push de 
ab86 c1					pop bc     ; move scratch pointer to end of word name and save it 
ab87			 
ab87 e1					pop hl 
ab88 7e					ld a, (hl) 
ab89					;inc hl 
ab89					; skip word string 
ab89 cd db 8c				call addatohl 
ab8c			 
ab8c 23					inc hl 
ab8d			 
ab8d				if DEBUG_FORTH_WORDS 
ab8d					DMARK "LS3" 
ab8d f5				push af  
ab8e 3a a2 ab			ld a, (.dmark)  
ab91 32 6b ee			ld (debug_mark),a  
ab94 3a a3 ab			ld a, (.dmark+1)  
ab97 32 6c ee			ld (debug_mark+1),a  
ab9a 3a a4 ab			ld a, (.dmark+2)  
ab9d 32 6d ee			ld (debug_mark+2),a  
aba0 18 03			jr .pastdmark  
aba2 ..			.dmark: db "LS3"  
aba5 f1			.pastdmark: pop af  
aba6			endm  
# End of macro DMARK
aba6					CALLMONITOR 
aba6 cd 6f ee			call debug_vector  
aba9				endm  
# End of macro CALLMONITOR
aba9				endif 
aba9					; should now be at the start of the machine code to setup the eval of the uword 
aba9					; now locate the ptr to the string defintion 
aba9			 
aba9					; skip ld hl, 
aba9					; then load the ptr 
aba9			; TODO use get from hl ptr 
aba9 23					inc hl 
abaa 5e					ld e, (hl) 
abab 23					inc hl 
abac 56					ld d, (hl) 
abad eb					ex de, hl 
abae			 
abae			 
abae				if DEBUG_FORTH_WORDS 
abae					DMARK "LSt" 
abae f5				push af  
abaf 3a c3 ab			ld a, (.dmark)  
abb2 32 6b ee			ld (debug_mark),a  
abb5 3a c4 ab			ld a, (.dmark+1)  
abb8 32 6c ee			ld (debug_mark+1),a  
abbb 3a c5 ab			ld a, (.dmark+2)  
abbe 32 6d ee			ld (debug_mark+2),a  
abc1 18 03			jr .pastdmark  
abc3 ..			.dmark: db "LSt"  
abc6 f1			.pastdmark: pop af  
abc7			endm  
# End of macro DMARK
abc7					CALLMONITOR 
abc7 cd 6f ee			call debug_vector  
abca				endm  
# End of macro CALLMONITOR
abca				endif 
abca			 
abca			; cant push right now due to tokenised strings  
abca			 
abca			; get the destination of where to copy this definition to. 
abca			 
abca c5					push bc 
abcb d1					pop de 
abcc			 
abcc 7e			.listl:         ld a,(hl) 
abcd fe 00				cp 0 
abcf 28 09				jr z, .lreplsp     ; replace zero with space 
abd1					;cp FORTH_END_BUFFER 
abd1 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
abd3 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
abd5				 
abd5					; just copy this char as is then 
abd5			 
abd5 12					ld (de), a 
abd6			 
abd6 23			.listnxt:	inc hl 
abd7 13					inc de 
abd8 18 f2				jr .listl 
abda			 
abda 3e 20		.lreplsp:	ld a,' ' 
abdc 12					ld (de), a 
abdd 18 f7				jr .listnxt 
abdf			 
abdf			; close up uword def 
abdf			 
abdf			.listdone: 
abdf 12					ld (de), a 
abe0 13					inc de 
abe1 3e 00				ld a, 0 
abe3 12					ld (de), a 
abe4			 
abe4			; now have def so clean up and push to stack 
abe4			 
abe4 21 c1 e2				ld hl, scratch 
abe7				if DEBUG_FORTH_WORDS 
abe7					DMARK "Ltp" 
abe7 f5				push af  
abe8 3a fc ab			ld a, (.dmark)  
abeb 32 6b ee			ld (debug_mark),a  
abee 3a fd ab			ld a, (.dmark+1)  
abf1 32 6c ee			ld (debug_mark+1),a  
abf4 3a fe ab			ld a, (.dmark+2)  
abf7 32 6d ee			ld (debug_mark+2),a  
abfa 18 03			jr .pastdmark  
abfc ..			.dmark: db "Ltp"  
abff f1			.pastdmark: pop af  
ac00			endm  
# End of macro DMARK
ac00					CALLMONITOR 
ac00 cd 6f ee			call debug_vector  
ac03				endm  
# End of macro CALLMONITOR
ac03				endif 
ac03			 
ac03 18 1f			jr .listpush 
ac05			 
ac05			;.lnuword:	pop hl 
ac05			;		call forth_tok_next 
ac05			;		jp .ldouscan  
ac05			 
ac05			.lunotfound:		  
ac05			 
ac05				if DEBUG_FORTH_WORDS 
ac05					DMARK "LSn" 
ac05 f5				push af  
ac06 3a 1a ac			ld a, (.dmark)  
ac09 32 6b ee			ld (debug_mark),a  
ac0c 3a 1b ac			ld a, (.dmark+1)  
ac0f 32 6c ee			ld (debug_mark+1),a  
ac12 3a 1c ac			ld a, (.dmark+2)  
ac15 32 6d ee			ld (debug_mark+2),a  
ac18 18 03			jr .pastdmark  
ac1a ..			.dmark: db "LSn"  
ac1d f1			.pastdmark: pop af  
ac1e			endm  
# End of macro DMARK
ac1e					CALLMONITOR 
ac1e cd 6f ee			call debug_vector  
ac21				endm  
# End of macro CALLMONITOR
ac21				endif 
ac21			 
ac21					 
ac21			;		FORTH_DSP_POP 
ac21			;		ld hl, .luno 
ac21			 
ac21					NEXTW			 
ac21 c3 0c a1			jp macro_next 
ac24				endm 
# End of macro NEXTW
ac24			 
ac24			.listpush: 
ac24				if DEBUG_FORTH_WORDS 
ac24					DMARK "LS>" 
ac24 f5				push af  
ac25 3a 39 ac			ld a, (.dmark)  
ac28 32 6b ee			ld (debug_mark),a  
ac2b 3a 3a ac			ld a, (.dmark+1)  
ac2e 32 6c ee			ld (debug_mark+1),a  
ac31 3a 3b ac			ld a, (.dmark+2)  
ac34 32 6d ee			ld (debug_mark+2),a  
ac37 18 03			jr .pastdmark  
ac39 ..			.dmark: db "LS>"  
ac3c f1			.pastdmark: pop af  
ac3d			endm  
# End of macro DMARK
ac3d					CALLMONITOR 
ac3d cd 6f ee			call debug_vector  
ac40				endm  
# End of macro CALLMONITOR
ac40				endif 
ac40 cd cd 9d				call forth_push_str 
ac43			 
ac43			 
ac43			 
ac43					NEXTW 
ac43 c3 0c a1			jp macro_next 
ac46				endm 
# End of macro NEXTW
ac46			 
ac46			;.luno:    db "Word not found",0 
ac46			 
ac46			 
ac46			 
ac46			 
ac46			 
ac46			;		push hl   ; save pointer to start of uword def string 
ac46			; 
ac46			;; look for FORTH_EOL_LINE 
ac46			;		ld a, FORTH_END_BUFFER 
ac46			;		call strlent 
ac46			; 
ac46			;		inc hl		 ; space for coln def 
ac46			;		inc hl 
ac46			;		inc hl          ; space for terms 
ac46			;		inc hl 
ac46			; 
ac46			;		ld a, 20   ; TODO get actual length 
ac46			;		call addatohl    ; include a random amount of room for the uword name 
ac46			; 
ac46			;		 
ac46			;	if DEBUG_FORTH_WORDS 
ac46			;		DMARK "Lt1" 
ac46			;		CALLMONITOR 
ac46			;	endif 
ac46			;		 
ac46			; 
ac46			;; malloc space for the string because we cant change it 
ac46			; 
ac46			;		call malloc 
ac46			;	if DEBUG_FORTH_MALLOC_GUARD 
ac46			;		push af 
ac46			;		call ishlzero 
ac46			;		pop af 
ac46			;		 
ac46			;		call z,malloc_error 
ac46			;	endif 
ac46			; 
ac46			;	if DEBUG_FORTH_WORDS 
ac46			;		DMARK "Lt2" 
ac46			;		CALLMONITOR 
ac46			;	endif 
ac46			;		pop de 
ac46			;		push hl    ; push the malloc to release later 
ac46			;		push hl   ;  push back a copy for the later stack push 
ac46			;		 
ac46			;; copy the string swapping out the zero terms for spaces 
ac46			; 
ac46			;		; de has our source 
ac46			;		; hl has our dest 
ac46			; 
ac46			;; add the coln def 
ac46			; 
ac46			;		ld a, ':' 
ac46			;		ld (hl), a 
ac46			;		inc hl 
ac46			;		ld a, ' ' 
ac46			;		ld (hl), a 
ac46			;		inc hl 
ac46			; 
ac46			;; add the uname word 
ac46			;		push de   ; save our string for now 
ac46			;		ex de, hl 
ac46			; 
ac46			;		FORTH_DSP_VALUE 
ac46			;		;v5 FORTH_DSP_VALUE 
ac46			; 
ac46			;		inc hl   ; skip type but we know by now this is OK 
ac46			; 
ac46			;.luword:	ld a,(hl) 
ac46			;		cp 0 
ac46			;		jr z, .luword2 
ac46			;		ld (de), a 
ac46			;		inc de 
ac46			;		inc hl 
ac46			;		jr .luword 
ac46			; 
ac46			;.luword2:	ld a, ' ' 
ac46			;		ld (de), a 
ac46			;;		inc hl 
ac46			;;		inc de 
ac46			;;		ld (de), a 
ac46			;;		inc hl 
ac46			;		inc de 
ac46			; 
ac46			;		ex de, hl 
ac46			;		pop de 
ac46			;		 
ac46			;		 
ac46			; 
ac46			;; detoken that string and copy it 
ac46			; 
ac46			;	if DEBUG_FORTH_WORDS 
ac46			;		DMARK "Lt2" 
ac46			;		CALLMONITOR 
ac46			;	endif 
ac46			;.ldetok:	ld a, (de) 
ac46			;		cp FORTH_END_BUFFER 
ac46			;		jr z, .ldetokend 
ac46			;		; swap out any zero term for space 
ac46			;		cp 0 
ac46			;		jr nz, .ldetoknext 
ac46			;		ld a, ' ' 
ac46			; 
ac46			;	if DEBUG_FORTH_WORDS 
ac46			;		DMARK "LtS" 
ac46			;		CALLMONITOR 
ac46			;	endif 
ac46			;.ldetoknext:	ld (hl), a 
ac46			;		inc de 
ac46			;		inc hl 
ac46			;		jr .ldetok 
ac46			; 
ac46			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ac46			;		ld (hl), a  
ac46			; 
ac46			;; free that temp malloc 
ac46			; 
ac46			;		pop hl    
ac46			; 
ac46			;	if DEBUG_FORTH_WORDS 
ac46			;		DMARK "Lt4" 
ac46			;		CALLMONITOR 
ac46			;	endif 
ac46			;		call forth_apushstrhl 
ac46			; 
ac46			;		; get rid of temp malloc area 
ac46			; 
ac46			;		pop hl 
ac46			;		call free 
ac46			; 
ac46			;		jr .ludone 
ac46			; 
ac46			;.lnuword:	pop hl 
ac46			;		call forth_tok_next 
ac46			;		jp .ldouscan  
ac46			; 
ac46			;.ludone:		 pop hl 
ac46			; 
ac46					NEXTW 
ac46 c3 0c a1			jp macro_next 
ac49				endm 
# End of macro NEXTW
ac49			 
ac49			.FORGET: 
ac49				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ac49 5d				db WORD_SYS_CORE+73             
ac4a c2 ac			dw .NOP            
ac4c 07				db 6 + 1 
ac4d .. 00			db "FORGET",0              
ac54				endm 
# End of macro CWHEAD
ac54			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ac54			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ac54			; | |  
ac54			; | | e.g. "MORE" forget 
ac54					if DEBUG_FORTH_WORDS_KEY 
ac54						DMARK "FRG" 
ac54 f5				push af  
ac55 3a 69 ac			ld a, (.dmark)  
ac58 32 6b ee			ld (debug_mark),a  
ac5b 3a 6a ac			ld a, (.dmark+1)  
ac5e 32 6c ee			ld (debug_mark+1),a  
ac61 3a 6b ac			ld a, (.dmark+2)  
ac64 32 6d ee			ld (debug_mark+2),a  
ac67 18 03			jr .pastdmark  
ac69 ..			.dmark: db "FRG"  
ac6c f1			.pastdmark: pop af  
ac6d			endm  
# End of macro DMARK
ac6d						CALLMONITOR 
ac6d cd 6f ee			call debug_vector  
ac70				endm  
# End of macro CALLMONITOR
ac70					endif 
ac70			 
ac70				; find uword 
ac70			        ; update start of word with "_" 
ac70				; replace uword with deleted flag 
ac70			 
ac70			 
ac70			;	if DEBUG_FORTH_WORDS 
ac70			;		DMARK "FOG" 
ac70			;		CALLMONITOR 
ac70			;	endif 
ac70			 
ac70			 
ac70					; Get ptr to the word we need to look up 
ac70			 
ac70					FORTH_DSP_VALUEHL 
ac70 cd 56 9f			call macro_dsp_valuehl 
ac73				endm 
# End of macro FORTH_DSP_VALUEHL
ac73					;v5 FORTH_DSP_VALUE 
ac73				; TODO type check 
ac73			;		inc hl    ; Skip type check  
ac73 e5					push hl 
ac74 c1					pop bc 
ac75			;		ex de, hl    ; put into DE 
ac75			 
ac75			 
ac75 21 fc e6				ld hl, baseram 
ac78					;ld hl, baseusermem 
ac78			 
ac78				; skip dict stub 
ac78			;	call forth_tok_next 
ac78 e5			push hl   ; sacreifical push 
ac79			 
ac79			.fldouscanm: 
ac79 e1				pop hl 
ac7a			.fldouscan: 
ac7a			;	if DEBUG_FORTH_WORDS 
ac7a			;		DMARK "LSs" 
ac7a			;		CALLMONITOR 
ac7a			;	endif 
ac7a				; skip dict stub 
ac7a cd 5d a2				call forth_tok_next 
ac7d			 
ac7d			 
ac7d			; while we have words to look for 
ac7d			 
ac7d 7e				ld a, (hl)      
ac7e			;	if DEBUG_FORTH_WORDS 
ac7e			;		DMARK "LSk" 
ac7e			;		CALLMONITOR 
ac7e			;	endif 
ac7e fe 00				cp WORD_SYS_END 
ac80 ca bc ac				jp z, .flunotfound 
ac83 fe 01				cp WORD_SYS_UWORD 
ac85 c2 7a ac				jp nz, .fldouscan 
ac88			 
ac88			;	if DEBUG_FORTH_WORDS 
ac88			;		DMARK "LSu" 
ac88			;		CALLMONITOR 
ac88			;	endif 
ac88			 
ac88					; found a uword but is it the one we want... 
ac88			 
ac88 c5					push bc     ; uword to find is on bc 
ac89 d1					pop de 
ac8a			 
ac8a e5					push hl  ; to save the ptr 
ac8b			 
ac8b					; skip opcode 
ac8b 23					inc hl  
ac8c					; skip next ptr 
ac8c 23					inc hl  
ac8d 23					inc hl 
ac8e					; skip len 
ac8e 23					inc hl 
ac8f			 
ac8f			;	if DEBUG_FORTH_WORDS 
ac8f			;		DMARK "LSc" 
ac8f			;		CALLMONITOR 
ac8f			;	endif 
ac8f cd 89 93				call strcmp 
ac92 c2 79 ac				jp nz, .fldouscanm 
ac95			; 
ac95			; 
ac95			;; while we have words to look for 
ac95			; 
ac95			;.fdouscan:	ld a, (hl)      
ac95			;	if DEBUG_FORTH_WORDS 
ac95			;		DMARK "LSs" 
ac95			;		CALLMONITOR 
ac95			;	endif 
ac95			;		cp WORD_SYS_END 
ac95			;		jp z, .fudone 
ac95			;		cp WORD_SYS_UWORD 
ac95			;		jp nz, .fnuword 
ac95			; 
ac95			;	if DEBUG_FORTH_WORDS 
ac95			;		DMARK "FGu" 
ac95			;		CALLMONITOR 
ac95			;	endif 
ac95			; 
ac95			;		; found a uword but is it the one we want... 
ac95			; 
ac95			; 
ac95			;	        pop de   ; get back the dsp name 
ac95			;		push de 
ac95			; 
ac95			;		push hl  ; to save the ptr 
ac95			; 
ac95			;		; skip opcode 
ac95			;		inc hl  
ac95			;		; skip next ptr 
ac95			;		inc hl  
ac95			;		inc hl 
ac95			;		; skip len 
ac95			;		inc hl 
ac95			; 
ac95			;	if DEBUG_FORTH_WORDS 
ac95			;		DMARK "FGc" 
ac95			;		CALLMONITOR 
ac95			;	endif 
ac95			;		call strcmp 
ac95			;		jp nz, .fnuword 
ac95			 
ac95			 
ac95 e1			pop hl 
ac96			 
ac96				 
ac96				if DEBUG_FORTH_WORDS 
ac96					DMARK "FGm" 
ac96 f5				push af  
ac97 3a ab ac			ld a, (.dmark)  
ac9a 32 6b ee			ld (debug_mark),a  
ac9d 3a ac ac			ld a, (.dmark+1)  
aca0 32 6c ee			ld (debug_mark+1),a  
aca3 3a ad ac			ld a, (.dmark+2)  
aca6 32 6d ee			ld (debug_mark+2),a  
aca9 18 03			jr .pastdmark  
acab ..			.dmark: db "FGm"  
acae f1			.pastdmark: pop af  
acaf			endm  
# End of macro DMARK
acaf					CALLMONITOR 
acaf cd 6f ee			call debug_vector  
acb2				endm  
# End of macro CALLMONITOR
acb2				endif 
acb2			 
acb2			 
acb2			 
acb2					; we have a uword so push its name to the stack 
acb2			 
acb2			;	   	push hl  ; save so we can move to next dict block 
acb2			;pop hl 
acb2			 
acb2					; update opcode to deleted 
acb2 3e 03				ld a, WORD_SYS_DELETED 
acb4 77					ld (hl), a 
acb5			 
acb5 23					inc hl  
acb6					; skip next ptr 
acb6 23					inc hl  
acb7 23					inc hl 
acb8					; skip len 
acb8 23					inc hl 
acb9			 
acb9					; TODO change parser to skip deleted words but for now mark it out 
acb9 3e 5f				ld a, "_" 
acbb 77					ld  (hl),a 
acbc			 
acbc			;		jr .fudone 
acbc			; 
acbc			;.fnuword:	pop hl 
acbc			;		call forth_tok_next 
acbc			;		jp .fdouscan  
acbc			 
acbc			.flunotfound:		  
acbc			 
acbc			 
acbc					 
acbc					FORTH_DSP_POP 
acbc cd 0e a0			call macro_forth_dsp_pop 
acbf				endm 
# End of macro FORTH_DSP_POP
acbf			;		ld hl, .luno 
acbf			;.fudone:		 pop hl 
acbf					NEXTW 
acbf c3 0c a1			jp macro_next 
acc2				endm 
# End of macro NEXTW
acc2			.NOP: 
acc2				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
acc2 61				db WORD_SYS_CORE+77             
acc3 e9 ac			dw .COMO            
acc5 04				db 3 + 1 
acc6 .. 00			db "NOP",0              
acca				endm 
# End of macro CWHEAD
acca			; | NOP (  --  ) Do nothing | DONE 
acca					if DEBUG_FORTH_WORDS_KEY 
acca						DMARK "NOP" 
acca f5				push af  
accb 3a df ac			ld a, (.dmark)  
acce 32 6b ee			ld (debug_mark),a  
acd1 3a e0 ac			ld a, (.dmark+1)  
acd4 32 6c ee			ld (debug_mark+1),a  
acd7 3a e1 ac			ld a, (.dmark+2)  
acda 32 6d ee			ld (debug_mark+2),a  
acdd 18 03			jr .pastdmark  
acdf ..			.dmark: db "NOP"  
ace2 f1			.pastdmark: pop af  
ace3			endm  
# End of macro DMARK
ace3						CALLMONITOR 
ace3 cd 6f ee			call debug_vector  
ace6				endm  
# End of macro CALLMONITOR
ace6					endif 
ace6				       NEXTW 
ace6 c3 0c a1			jp macro_next 
ace9				endm 
# End of macro NEXTW
ace9			.COMO: 
ace9				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
ace9 6e				db WORD_SYS_CORE+90             
acea 3b ad			dw .COMC            
acec 02				db 1 + 1 
aced .. 00			db "(",0              
acef				endm 
# End of macro CWHEAD
acef			; | ( ( -- )  Start of comment | DONE 
acef			 
acef			 
acef 2a c2 e5				ld hl, ( os_tok_ptr) 
acf2 11 36 ad			ld de, .closepar 
acf5					 
acf5					if DEBUG_FORTH_WORDS 
acf5						DMARK ").." 
acf5 f5				push af  
acf6 3a 0a ad			ld a, (.dmark)  
acf9 32 6b ee			ld (debug_mark),a  
acfc 3a 0b ad			ld a, (.dmark+1)  
acff 32 6c ee			ld (debug_mark+1),a  
ad02 3a 0c ad			ld a, (.dmark+2)  
ad05 32 6d ee			ld (debug_mark+2),a  
ad08 18 03			jr .pastdmark  
ad0a ..			.dmark: db ").."  
ad0d f1			.pastdmark: pop af  
ad0e			endm  
# End of macro DMARK
ad0e						CALLMONITOR 
ad0e cd 6f ee			call debug_vector  
ad11				endm  
# End of macro CALLMONITOR
ad11					endif 
ad11 cd 27 a2			call findnexttok  
ad14			 
ad14					if DEBUG_FORTH_WORDS 
ad14						DMARK "IF5" 
ad14 f5				push af  
ad15 3a 29 ad			ld a, (.dmark)  
ad18 32 6b ee			ld (debug_mark),a  
ad1b 3a 2a ad			ld a, (.dmark+1)  
ad1e 32 6c ee			ld (debug_mark+1),a  
ad21 3a 2b ad			ld a, (.dmark+2)  
ad24 32 6d ee			ld (debug_mark+2),a  
ad27 18 03			jr .pastdmark  
ad29 ..			.dmark: db "IF5"  
ad2c f1			.pastdmark: pop af  
ad2d			endm  
# End of macro DMARK
ad2d						CALLMONITOR 
ad2d cd 6f ee			call debug_vector  
ad30				endm  
# End of macro CALLMONITOR
ad30					endif 
ad30				; replace below with ) exec using tok_ptr 
ad30 22 c2 e5			ld (os_tok_ptr), hl 
ad33 c3 9d a1			jp exec1 
ad36			 
ad36 .. 00			.closepar:   db ")",0 
ad38			 
ad38				       NEXTW 
ad38 c3 0c a1			jp macro_next 
ad3b				endm 
# End of macro NEXTW
ad3b			.COMC: 
ad3b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ad3b 6f				db WORD_SYS_CORE+91             
ad3c 44 ad			dw .SCRATCH            
ad3e 02				db 1 + 1 
ad3f .. 00			db ")",0              
ad41				endm 
# End of macro CWHEAD
ad41			; | ) ( -- )  End of comment |  DONE  
ad41				       NEXTW 
ad41 c3 0c a1			jp macro_next 
ad44				endm 
# End of macro NEXTW
ad44			 
ad44			.SCRATCH: 
ad44				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ad44 6f				db WORD_SYS_CORE+91             
ad45 7f ad			dw .INC            
ad47 08				db 7 + 1 
ad48 .. 00			db "SCRATCH",0              
ad50				endm 
# End of macro CWHEAD
ad50			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ad50			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ad50			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ad50			; | |  
ad50			; | | e.g.    : score $00 scratch ; 
ad50			; | |  
ad50			; | | $00 score ! 
ad50			; | | $01 score +! 
ad50			; | |  
ad50			; | | e.g.   : varword $0a scratch ;  
ad50			; | | 
ad50			; | | $8000 varword ! 
ad50					if DEBUG_FORTH_WORDS_KEY 
ad50						DMARK "SCR" 
ad50 f5				push af  
ad51 3a 65 ad			ld a, (.dmark)  
ad54 32 6b ee			ld (debug_mark),a  
ad57 3a 66 ad			ld a, (.dmark+1)  
ad5a 32 6c ee			ld (debug_mark+1),a  
ad5d 3a 67 ad			ld a, (.dmark+2)  
ad60 32 6d ee			ld (debug_mark+2),a  
ad63 18 03			jr .pastdmark  
ad65 ..			.dmark: db "SCR"  
ad68 f1			.pastdmark: pop af  
ad69			endm  
# End of macro DMARK
ad69						CALLMONITOR 
ad69 cd 6f ee			call debug_vector  
ad6c				endm  
# End of macro CALLMONITOR
ad6c					endif 
ad6c			 
ad6c					FORTH_DSP_VALUEHL 
ad6c cd 56 9f			call macro_dsp_valuehl 
ad6f				endm 
# End of macro FORTH_DSP_VALUEHL
ad6f				 
ad6f					FORTH_DSP_POP 
ad6f cd 0e a0			call macro_forth_dsp_pop 
ad72				endm 
# End of macro FORTH_DSP_POP
ad72			 
ad72 7d					ld a, l 
ad73 21 e6 e7				ld hl, os_var_array 
ad76 cd db 8c				call addatohl 
ad79			 
ad79 cd 5f 9d				call forth_push_numhl 
ad7c			 
ad7c				       NEXTW 
ad7c c3 0c a1			jp macro_next 
ad7f				endm 
# End of macro NEXTW
ad7f			 
ad7f			.INC: 
ad7f				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ad7f 6f				db WORD_SYS_CORE+91             
ad80 d5 ad			dw .DEC            
ad82 03				db 2 + 1 
ad83 .. 00			db "+!",0              
ad86				endm 
# End of macro CWHEAD
ad86			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ad86					if DEBUG_FORTH_WORDS_KEY 
ad86						DMARK "+s_" 
ad86 f5				push af  
ad87 3a 9b ad			ld a, (.dmark)  
ad8a 32 6b ee			ld (debug_mark),a  
ad8d 3a 9c ad			ld a, (.dmark+1)  
ad90 32 6c ee			ld (debug_mark+1),a  
ad93 3a 9d ad			ld a, (.dmark+2)  
ad96 32 6d ee			ld (debug_mark+2),a  
ad99 18 03			jr .pastdmark  
ad9b ..			.dmark: db "+s_"  
ad9e f1			.pastdmark: pop af  
ad9f			endm  
# End of macro DMARK
ad9f						CALLMONITOR 
ad9f cd 6f ee			call debug_vector  
ada2				endm  
# End of macro CALLMONITOR
ada2					endif 
ada2			 
ada2					FORTH_DSP_VALUEHL 
ada2 cd 56 9f			call macro_dsp_valuehl 
ada5				endm 
# End of macro FORTH_DSP_VALUEHL
ada5			 
ada5 e5					push hl   ; save address 
ada6			 
ada6					FORTH_DSP_POP 
ada6 cd 0e a0			call macro_forth_dsp_pop 
ada9				endm 
# End of macro FORTH_DSP_POP
ada9			 
ada9					FORTH_DSP_VALUEHL 
ada9 cd 56 9f			call macro_dsp_valuehl 
adac				endm 
# End of macro FORTH_DSP_VALUEHL
adac			 
adac e5					push hl 
adad					FORTH_DSP_POP 
adad cd 0e a0			call macro_forth_dsp_pop 
adb0				endm 
# End of macro FORTH_DSP_POP
adb0 e1					pop hl 
adb1			 
adb1					; hl contains value to add to byte at a 
adb1				 
adb1 eb					ex de, hl 
adb2			 
adb2 e1					pop hl 
adb3			 
adb3					if DEBUG_FORTH_WORDS 
adb3						DMARK "INC" 
adb3 f5				push af  
adb4 3a c8 ad			ld a, (.dmark)  
adb7 32 6b ee			ld (debug_mark),a  
adba 3a c9 ad			ld a, (.dmark+1)  
adbd 32 6c ee			ld (debug_mark+1),a  
adc0 3a ca ad			ld a, (.dmark+2)  
adc3 32 6d ee			ld (debug_mark+2),a  
adc6 18 03			jr .pastdmark  
adc8 ..			.dmark: db "INC"  
adcb f1			.pastdmark: pop af  
adcc			endm  
# End of macro DMARK
adcc						CALLMONITOR 
adcc cd 6f ee			call debug_vector  
adcf				endm  
# End of macro CALLMONITOR
adcf					endif 
adcf			 
adcf 7e					ld a,(hl) 
add0 83					add e 
add1 77					ld (hl),a 
add2			 
add2			 
add2			 
add2				       NEXTW 
add2 c3 0c a1			jp macro_next 
add5				endm 
# End of macro NEXTW
add5			 
add5			.DEC: 
add5				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
add5 6f				db WORD_SYS_CORE+91             
add6 29 ae			dw .INC2            
add8 03				db 2 + 1 
add9 .. 00			db "-!",0              
addc				endm 
# End of macro CWHEAD
addc			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
addc					if DEBUG_FORTH_WORDS_KEY 
addc						DMARK "-s_" 
addc f5				push af  
addd 3a f1 ad			ld a, (.dmark)  
ade0 32 6b ee			ld (debug_mark),a  
ade3 3a f2 ad			ld a, (.dmark+1)  
ade6 32 6c ee			ld (debug_mark+1),a  
ade9 3a f3 ad			ld a, (.dmark+2)  
adec 32 6d ee			ld (debug_mark+2),a  
adef 18 03			jr .pastdmark  
adf1 ..			.dmark: db "-s_"  
adf4 f1			.pastdmark: pop af  
adf5			endm  
# End of macro DMARK
adf5						CALLMONITOR 
adf5 cd 6f ee			call debug_vector  
adf8				endm  
# End of macro CALLMONITOR
adf8					endif 
adf8			 
adf8					FORTH_DSP_VALUEHL 
adf8 cd 56 9f			call macro_dsp_valuehl 
adfb				endm 
# End of macro FORTH_DSP_VALUEHL
adfb			 
adfb e5					push hl   ; save address 
adfc			 
adfc					FORTH_DSP_POP 
adfc cd 0e a0			call macro_forth_dsp_pop 
adff				endm 
# End of macro FORTH_DSP_POP
adff			 
adff					FORTH_DSP_VALUEHL 
adff cd 56 9f			call macro_dsp_valuehl 
ae02				endm 
# End of macro FORTH_DSP_VALUEHL
ae02			 
ae02					; hl contains value to add to byte at a 
ae02				 
ae02 eb					ex de, hl 
ae03			 
ae03 e1					pop hl 
ae04			 
ae04					if DEBUG_FORTH_WORDS 
ae04						DMARK "DEC" 
ae04 f5				push af  
ae05 3a 19 ae			ld a, (.dmark)  
ae08 32 6b ee			ld (debug_mark),a  
ae0b 3a 1a ae			ld a, (.dmark+1)  
ae0e 32 6c ee			ld (debug_mark+1),a  
ae11 3a 1b ae			ld a, (.dmark+2)  
ae14 32 6d ee			ld (debug_mark+2),a  
ae17 18 03			jr .pastdmark  
ae19 ..			.dmark: db "DEC"  
ae1c f1			.pastdmark: pop af  
ae1d			endm  
# End of macro DMARK
ae1d						CALLMONITOR 
ae1d cd 6f ee			call debug_vector  
ae20				endm  
# End of macro CALLMONITOR
ae20					endif 
ae20			 
ae20 7e					ld a,(hl) 
ae21 93					sub e 
ae22 77					ld (hl),a 
ae23			 
ae23			 
ae23					FORTH_DSP_POP 
ae23 cd 0e a0			call macro_forth_dsp_pop 
ae26				endm 
# End of macro FORTH_DSP_POP
ae26			 
ae26				       NEXTW 
ae26 c3 0c a1			jp macro_next 
ae29				endm 
# End of macro NEXTW
ae29			 
ae29			.INC2: 
ae29				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ae29 6f				db WORD_SYS_CORE+91             
ae2a d6 ae			dw .DEC2            
ae2c 04				db 3 + 1 
ae2d .. 00			db "+2!",0              
ae31				endm 
# End of macro CWHEAD
ae31			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ae31			 
ae31					if DEBUG_FORTH_WORDS_KEY 
ae31						DMARK "+2s" 
ae31 f5				push af  
ae32 3a 46 ae			ld a, (.dmark)  
ae35 32 6b ee			ld (debug_mark),a  
ae38 3a 47 ae			ld a, (.dmark+1)  
ae3b 32 6c ee			ld (debug_mark+1),a  
ae3e 3a 48 ae			ld a, (.dmark+2)  
ae41 32 6d ee			ld (debug_mark+2),a  
ae44 18 03			jr .pastdmark  
ae46 ..			.dmark: db "+2s"  
ae49 f1			.pastdmark: pop af  
ae4a			endm  
# End of macro DMARK
ae4a						CALLMONITOR 
ae4a cd 6f ee			call debug_vector  
ae4d				endm  
# End of macro CALLMONITOR
ae4d					endif 
ae4d			 
ae4d					; Address 
ae4d			 
ae4d					FORTH_DSP_VALUEHL 
ae4d cd 56 9f			call macro_dsp_valuehl 
ae50				endm 
# End of macro FORTH_DSP_VALUEHL
ae50			 
ae50 e5					push hl    ; save address 
ae51			 
ae51					; load content into de 
ae51			 
ae51 5e					ld e,(hl) 
ae52 23					inc hl 
ae53 56					ld d, (hl) 
ae54			 
ae54					if DEBUG_FORTH_WORDS 
ae54						DMARK "+2a" 
ae54 f5				push af  
ae55 3a 69 ae			ld a, (.dmark)  
ae58 32 6b ee			ld (debug_mark),a  
ae5b 3a 6a ae			ld a, (.dmark+1)  
ae5e 32 6c ee			ld (debug_mark+1),a  
ae61 3a 6b ae			ld a, (.dmark+2)  
ae64 32 6d ee			ld (debug_mark+2),a  
ae67 18 03			jr .pastdmark  
ae69 ..			.dmark: db "+2a"  
ae6c f1			.pastdmark: pop af  
ae6d			endm  
# End of macro DMARK
ae6d						CALLMONITOR 
ae6d cd 6f ee			call debug_vector  
ae70				endm  
# End of macro CALLMONITOR
ae70					endif 
ae70			 
ae70					FORTH_DSP_POP 
ae70 cd 0e a0			call macro_forth_dsp_pop 
ae73				endm 
# End of macro FORTH_DSP_POP
ae73			 
ae73					; Get value to add 
ae73			 
ae73					FORTH_DSP_VALUE 
ae73 cd 3f 9f			call macro_forth_dsp_value 
ae76				endm 
# End of macro FORTH_DSP_VALUE
ae76			 
ae76					if DEBUG_FORTH_WORDS 
ae76						DMARK "+2v" 
ae76 f5				push af  
ae77 3a 8b ae			ld a, (.dmark)  
ae7a 32 6b ee			ld (debug_mark),a  
ae7d 3a 8c ae			ld a, (.dmark+1)  
ae80 32 6c ee			ld (debug_mark+1),a  
ae83 3a 8d ae			ld a, (.dmark+2)  
ae86 32 6d ee			ld (debug_mark+2),a  
ae89 18 03			jr .pastdmark  
ae8b ..			.dmark: db "+2v"  
ae8e f1			.pastdmark: pop af  
ae8f			endm  
# End of macro DMARK
ae8f						CALLMONITOR 
ae8f cd 6f ee			call debug_vector  
ae92				endm  
# End of macro CALLMONITOR
ae92					endif 
ae92			 
ae92 19					add hl, de 
ae93			 
ae93					if DEBUG_FORTH_WORDS 
ae93						DMARK "+2+" 
ae93 f5				push af  
ae94 3a a8 ae			ld a, (.dmark)  
ae97 32 6b ee			ld (debug_mark),a  
ae9a 3a a9 ae			ld a, (.dmark+1)  
ae9d 32 6c ee			ld (debug_mark+1),a  
aea0 3a aa ae			ld a, (.dmark+2)  
aea3 32 6d ee			ld (debug_mark+2),a  
aea6 18 03			jr .pastdmark  
aea8 ..			.dmark: db "+2+"  
aeab f1			.pastdmark: pop af  
aeac			endm  
# End of macro DMARK
aeac						CALLMONITOR 
aeac cd 6f ee			call debug_vector  
aeaf				endm  
# End of macro CALLMONITOR
aeaf					endif 
aeaf			 
aeaf					; move result to de 
aeaf			 
aeaf eb					ex de, hl 
aeb0			 
aeb0					; Address 
aeb0			 
aeb0 e1					pop hl 
aeb1			 
aeb1					; save it back 
aeb1			 
aeb1 73					ld (hl), e 
aeb2 23					inc hl 
aeb3 72					ld (hl), d 
aeb4			 
aeb4					if DEBUG_FORTH_WORDS 
aeb4						DMARK "+2e" 
aeb4 f5				push af  
aeb5 3a c9 ae			ld a, (.dmark)  
aeb8 32 6b ee			ld (debug_mark),a  
aebb 3a ca ae			ld a, (.dmark+1)  
aebe 32 6c ee			ld (debug_mark+1),a  
aec1 3a cb ae			ld a, (.dmark+2)  
aec4 32 6d ee			ld (debug_mark+2),a  
aec7 18 03			jr .pastdmark  
aec9 ..			.dmark: db "+2e"  
aecc f1			.pastdmark: pop af  
aecd			endm  
# End of macro DMARK
aecd						CALLMONITOR 
aecd cd 6f ee			call debug_vector  
aed0				endm  
# End of macro CALLMONITOR
aed0					endif 
aed0			 
aed0			 
aed0			 
aed0					FORTH_DSP_POP 
aed0 cd 0e a0			call macro_forth_dsp_pop 
aed3				endm 
# End of macro FORTH_DSP_POP
aed3			 
aed3			 
aed3				       NEXTW 
aed3 c3 0c a1			jp macro_next 
aed6				endm 
# End of macro NEXTW
aed6			 
aed6			.DEC2: 
aed6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aed6 6f				db WORD_SYS_CORE+91             
aed7 85 af			dw .GET2            
aed9 04				db 3 + 1 
aeda .. 00			db "-2!",0              
aede				endm 
# End of macro CWHEAD
aede			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aede			 
aede			 
aede					if DEBUG_FORTH_WORDS_KEY 
aede						DMARK "-2s" 
aede f5				push af  
aedf 3a f3 ae			ld a, (.dmark)  
aee2 32 6b ee			ld (debug_mark),a  
aee5 3a f4 ae			ld a, (.dmark+1)  
aee8 32 6c ee			ld (debug_mark+1),a  
aeeb 3a f5 ae			ld a, (.dmark+2)  
aeee 32 6d ee			ld (debug_mark+2),a  
aef1 18 03			jr .pastdmark  
aef3 ..			.dmark: db "-2s"  
aef6 f1			.pastdmark: pop af  
aef7			endm  
# End of macro DMARK
aef7						CALLMONITOR 
aef7 cd 6f ee			call debug_vector  
aefa				endm  
# End of macro CALLMONITOR
aefa					endif 
aefa			 
aefa					; Address 
aefa			 
aefa					FORTH_DSP_VALUEHL 
aefa cd 56 9f			call macro_dsp_valuehl 
aefd				endm 
# End of macro FORTH_DSP_VALUEHL
aefd			 
aefd e5					push hl    ; save address 
aefe			 
aefe					; load content into de 
aefe			 
aefe 5e					ld e,(hl) 
aeff 23					inc hl 
af00 56					ld d, (hl) 
af01			 
af01					if DEBUG_FORTH_WORDS 
af01						DMARK "-2a" 
af01 f5				push af  
af02 3a 16 af			ld a, (.dmark)  
af05 32 6b ee			ld (debug_mark),a  
af08 3a 17 af			ld a, (.dmark+1)  
af0b 32 6c ee			ld (debug_mark+1),a  
af0e 3a 18 af			ld a, (.dmark+2)  
af11 32 6d ee			ld (debug_mark+2),a  
af14 18 03			jr .pastdmark  
af16 ..			.dmark: db "-2a"  
af19 f1			.pastdmark: pop af  
af1a			endm  
# End of macro DMARK
af1a						CALLMONITOR 
af1a cd 6f ee			call debug_vector  
af1d				endm  
# End of macro CALLMONITOR
af1d					endif 
af1d			 
af1d					FORTH_DSP_POP 
af1d cd 0e a0			call macro_forth_dsp_pop 
af20				endm 
# End of macro FORTH_DSP_POP
af20			 
af20					; Get value to remove 
af20			 
af20					FORTH_DSP_VALUE 
af20 cd 3f 9f			call macro_forth_dsp_value 
af23				endm 
# End of macro FORTH_DSP_VALUE
af23			 
af23					if DEBUG_FORTH_WORDS 
af23						DMARK "-2v" 
af23 f5				push af  
af24 3a 38 af			ld a, (.dmark)  
af27 32 6b ee			ld (debug_mark),a  
af2a 3a 39 af			ld a, (.dmark+1)  
af2d 32 6c ee			ld (debug_mark+1),a  
af30 3a 3a af			ld a, (.dmark+2)  
af33 32 6d ee			ld (debug_mark+2),a  
af36 18 03			jr .pastdmark  
af38 ..			.dmark: db "-2v"  
af3b f1			.pastdmark: pop af  
af3c			endm  
# End of macro DMARK
af3c						CALLMONITOR 
af3c cd 6f ee			call debug_vector  
af3f				endm  
# End of macro CALLMONITOR
af3f					endif 
af3f			 
af3f eb					ex de, hl 
af40 ed 52				sbc hl, de 
af42			 
af42					if DEBUG_FORTH_WORDS 
af42						DMARK "-2d" 
af42 f5				push af  
af43 3a 57 af			ld a, (.dmark)  
af46 32 6b ee			ld (debug_mark),a  
af49 3a 58 af			ld a, (.dmark+1)  
af4c 32 6c ee			ld (debug_mark+1),a  
af4f 3a 59 af			ld a, (.dmark+2)  
af52 32 6d ee			ld (debug_mark+2),a  
af55 18 03			jr .pastdmark  
af57 ..			.dmark: db "-2d"  
af5a f1			.pastdmark: pop af  
af5b			endm  
# End of macro DMARK
af5b						CALLMONITOR 
af5b cd 6f ee			call debug_vector  
af5e				endm  
# End of macro CALLMONITOR
af5e					endif 
af5e			 
af5e					; move result to de 
af5e			 
af5e eb					ex de, hl 
af5f			 
af5f					; Address 
af5f			 
af5f e1					pop hl 
af60			 
af60					; save it back 
af60			 
af60 73					ld (hl), e 
af61 23					inc hl 
af62 72					ld (hl), d 
af63			 
af63					if DEBUG_FORTH_WORDS 
af63						DMARK "-2e" 
af63 f5				push af  
af64 3a 78 af			ld a, (.dmark)  
af67 32 6b ee			ld (debug_mark),a  
af6a 3a 79 af			ld a, (.dmark+1)  
af6d 32 6c ee			ld (debug_mark+1),a  
af70 3a 7a af			ld a, (.dmark+2)  
af73 32 6d ee			ld (debug_mark+2),a  
af76 18 03			jr .pastdmark  
af78 ..			.dmark: db "-2e"  
af7b f1			.pastdmark: pop af  
af7c			endm  
# End of macro DMARK
af7c						CALLMONITOR 
af7c cd 6f ee			call debug_vector  
af7f				endm  
# End of macro CALLMONITOR
af7f					endif 
af7f			 
af7f			 
af7f					FORTH_DSP_POP 
af7f cd 0e a0			call macro_forth_dsp_pop 
af82				endm 
# End of macro FORTH_DSP_POP
af82			 
af82			 
af82			 
af82				       NEXTW 
af82 c3 0c a1			jp macro_next 
af85				endm 
# End of macro NEXTW
af85			.GET2: 
af85				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
af85 6f				db WORD_SYS_CORE+91             
af86 ba af			dw .BANG2            
af88 03				db 2 + 1 
af89 .. 00			db "2@",0              
af8c				endm 
# End of macro CWHEAD
af8c			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
af8c					if DEBUG_FORTH_WORDS_KEY 
af8c						DMARK "2A_" 
af8c f5				push af  
af8d 3a a1 af			ld a, (.dmark)  
af90 32 6b ee			ld (debug_mark),a  
af93 3a a2 af			ld a, (.dmark+1)  
af96 32 6c ee			ld (debug_mark+1),a  
af99 3a a3 af			ld a, (.dmark+2)  
af9c 32 6d ee			ld (debug_mark+2),a  
af9f 18 03			jr .pastdmark  
afa1 ..			.dmark: db "2A_"  
afa4 f1			.pastdmark: pop af  
afa5			endm  
# End of macro DMARK
afa5						CALLMONITOR 
afa5 cd 6f ee			call debug_vector  
afa8				endm  
# End of macro CALLMONITOR
afa8					endif 
afa8			 
afa8					FORTH_DSP_VALUEHL 
afa8 cd 56 9f			call macro_dsp_valuehl 
afab				endm 
# End of macro FORTH_DSP_VALUEHL
afab			 
afab e5					push hl   ; save address 
afac			 
afac					FORTH_DSP_POP 
afac cd 0e a0			call macro_forth_dsp_pop 
afaf				endm 
# End of macro FORTH_DSP_POP
afaf			 
afaf e1					pop hl 
afb0			 
afb0 5e					ld e, (hl) 
afb1 23					inc hl 
afb2 56					ld d, (hl) 
afb3			 
afb3 eb					ex de, hl 
afb4			 
afb4 cd 5f 9d				call forth_push_numhl 
afb7			 
afb7				       NEXTW 
afb7 c3 0c a1			jp macro_next 
afba				endm 
# End of macro NEXTW
afba			.BANG2: 
afba				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
afba 6f				db WORD_SYS_CORE+91             
afbb f2 af			dw .CONFIG            
afbd 03				db 2 + 1 
afbe .. 00			db "2!",0              
afc1				endm 
# End of macro CWHEAD
afc1			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
afc1					if DEBUG_FORTH_WORDS_KEY 
afc1						DMARK "2S_" 
afc1 f5				push af  
afc2 3a d6 af			ld a, (.dmark)  
afc5 32 6b ee			ld (debug_mark),a  
afc8 3a d7 af			ld a, (.dmark+1)  
afcb 32 6c ee			ld (debug_mark+1),a  
afce 3a d8 af			ld a, (.dmark+2)  
afd1 32 6d ee			ld (debug_mark+2),a  
afd4 18 03			jr .pastdmark  
afd6 ..			.dmark: db "2S_"  
afd9 f1			.pastdmark: pop af  
afda			endm  
# End of macro DMARK
afda						CALLMONITOR 
afda cd 6f ee			call debug_vector  
afdd				endm  
# End of macro CALLMONITOR
afdd					endif 
afdd			 
afdd					FORTH_DSP_VALUEHL 
afdd cd 56 9f			call macro_dsp_valuehl 
afe0				endm 
# End of macro FORTH_DSP_VALUEHL
afe0			 
afe0 e5					push hl   ; save address 
afe1			 
afe1			 
afe1					FORTH_DSP_POP 
afe1 cd 0e a0			call macro_forth_dsp_pop 
afe4				endm 
# End of macro FORTH_DSP_POP
afe4			 
afe4					 
afe4					FORTH_DSP_VALUEHL 
afe4 cd 56 9f			call macro_dsp_valuehl 
afe7				endm 
# End of macro FORTH_DSP_VALUEHL
afe7			 
afe7					FORTH_DSP_POP 
afe7 cd 0e a0			call macro_forth_dsp_pop 
afea				endm 
# End of macro FORTH_DSP_POP
afea			 
afea eb					ex de, hl    ; value now in de 
afeb			 
afeb e1					pop hl 
afec			 
afec 73					ld (hl), e 
afed			 
afed 23					inc hl 
afee			 
afee 72					ld (hl), d 
afef			 
afef			 
afef				       NEXTW 
afef c3 0c a1			jp macro_next 
aff2				endm 
# End of macro NEXTW
aff2			.CONFIG: 
aff2				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
aff2 6f				db WORD_SYS_CORE+91             
aff3 03 b0			dw .ADTOS            
aff5 07				db 6 + 1 
aff6 .. 00			db "CONFIG",0              
affd				endm 
# End of macro CWHEAD
affd			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
affd			 
affd cd 5f 95				call config 
b000					NEXTW 
b000 c3 0c a1			jp macro_next 
b003				endm 
# End of macro NEXTW
b003			 
b003			.ADTOS: 
b003				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
b003 6f				db WORD_SYS_CORE+91             
b004 19 b0			dw .SBTOS            
b006 03				db 2 + 1 
b007 .. 00			db "1+",0              
b00a				endm 
# End of macro CWHEAD
b00a			; | 1+ ( u -- u )  Increment value on TOS | DONE 
b00a			 
b00a					FORTH_DSP_VALUEHL 
b00a cd 56 9f			call macro_dsp_valuehl 
b00d				endm 
# End of macro FORTH_DSP_VALUEHL
b00d e5					push hl 
b00e			 
b00e					FORTH_DSP_POP 
b00e cd 0e a0			call macro_forth_dsp_pop 
b011				endm 
# End of macro FORTH_DSP_POP
b011 e1					pop hl 
b012			 
b012 23					inc hl 
b013 cd 5f 9d				call forth_push_numhl 
b016					 
b016					NEXTW 
b016 c3 0c a1			jp macro_next 
b019				endm 
# End of macro NEXTW
b019			.SBTOS: 
b019				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
b019 6f				db WORD_SYS_CORE+91             
b01a 2f b0			dw .ADSTORE            
b01c 03				db 2 + 1 
b01d .. 00			db "1-",0              
b020				endm 
# End of macro CWHEAD
b020			; | 1- ( u -- u )  Decrement value on TOS | DONE 
b020			 
b020					FORTH_DSP_VALUEHL 
b020 cd 56 9f			call macro_dsp_valuehl 
b023				endm 
# End of macro FORTH_DSP_VALUEHL
b023 e5					push hl 
b024			 
b024					FORTH_DSP_POP 
b024 cd 0e a0			call macro_forth_dsp_pop 
b027				endm 
# End of macro FORTH_DSP_POP
b027 e1					pop hl 
b028			 
b028 2b					dec hl 
b029 cd 5f 9d				call forth_push_numhl 
b02c					 
b02c					NEXTW 
b02c c3 0c a1			jp macro_next 
b02f				endm 
# End of macro NEXTW
b02f			.ADSTORE: 
b02f				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
b02f 6f				db WORD_SYS_CORE+91             
b030 45 b0			dw .ADWSTORE            
b032 04				db 3 + 1 
b033 .. 00			db "1+!",0              
b037				endm 
# End of macro CWHEAD
b037			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
b037			 
b037					FORTH_DSP_VALUEHL 
b037 cd 56 9f			call macro_dsp_valuehl 
b03a				endm 
# End of macro FORTH_DSP_VALUEHL
b03a e5					push hl 
b03b			 
b03b					FORTH_DSP_POP 
b03b cd 0e a0			call macro_forth_dsp_pop 
b03e				endm 
# End of macro FORTH_DSP_POP
b03e e1					pop hl 
b03f			 
b03f 7e					ld a, (hl) 
b040 3c					inc a 
b041 77					ld (hl), a 
b042					 
b042					NEXTW 
b042 c3 0c a1			jp macro_next 
b045				endm 
# End of macro NEXTW
b045			.ADWSTORE: 
b045				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
b045 6f				db WORD_SYS_CORE+91             
b046 63 b0			dw .SBSTORE            
b048 05				db 4 + 1 
b049 .. 00			db "1+2!",0              
b04e				endm 
# End of macro CWHEAD
b04e			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
b04e			 
b04e					FORTH_DSP_VALUEHL 
b04e cd 56 9f			call macro_dsp_valuehl 
b051				endm 
# End of macro FORTH_DSP_VALUEHL
b051 e5					push hl 
b052			 
b052					FORTH_DSP_POP 
b052 cd 0e a0			call macro_forth_dsp_pop 
b055				endm 
# End of macro FORTH_DSP_POP
b055 e1					pop hl 
b056			 
b056 e5					push hl 
b057			 
b057 cd 8e a0				call loadwordinhl 
b05a 23					inc hl 
b05b			 
b05b d1					pop de 
b05c eb					ex de, hl 
b05d 73					ld (hl), e 
b05e 23					inc hl 
b05f 72					ld (hl), d 
b060					 
b060					NEXTW 
b060 c3 0c a1			jp macro_next 
b063				endm 
# End of macro NEXTW
b063			.SBSTORE: 
b063				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
b063 6f				db WORD_SYS_CORE+91             
b064 79 b0			dw .SBWSTORE            
b066 04				db 3 + 1 
b067 .. 00			db "1-!",0              
b06b				endm 
# End of macro CWHEAD
b06b			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
b06b			 
b06b					FORTH_DSP_VALUEHL 
b06b cd 56 9f			call macro_dsp_valuehl 
b06e				endm 
# End of macro FORTH_DSP_VALUEHL
b06e e5					push hl 
b06f			 
b06f					FORTH_DSP_POP 
b06f cd 0e a0			call macro_forth_dsp_pop 
b072				endm 
# End of macro FORTH_DSP_POP
b072 e1					pop hl 
b073			 
b073 7e					ld a, (hl) 
b074 3d					dec a 
b075 77					ld (hl), a 
b076					 
b076					NEXTW 
b076 c3 0c a1			jp macro_next 
b079				endm 
# End of macro NEXTW
b079			.SBWSTORE: 
b079				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
b079 6f				db WORD_SYS_CORE+91             
b07a 97 b0			dw .ENDCORE            
b07c 05				db 4 + 1 
b07d .. 00			db "1-2!",0              
b082				endm 
# End of macro CWHEAD
b082			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
b082			 
b082					FORTH_DSP_VALUEHL 
b082 cd 56 9f			call macro_dsp_valuehl 
b085				endm 
# End of macro FORTH_DSP_VALUEHL
b085 e5					push hl 
b086			 
b086					FORTH_DSP_POP 
b086 cd 0e a0			call macro_forth_dsp_pop 
b089				endm 
# End of macro FORTH_DSP_POP
b089 e1					pop hl 
b08a			 
b08a e5					push hl 
b08b			 
b08b cd 8e a0				call loadwordinhl 
b08e 2b					dec hl 
b08f			 
b08f d1					pop de 
b090 eb					ex de, hl 
b091 73					ld (hl), e 
b092 23					inc hl 
b093 72					ld (hl), d 
b094					 
b094					NEXTW 
b094 c3 0c a1			jp macro_next 
b097				endm 
# End of macro NEXTW
b097			.ENDCORE: 
b097			 
b097			; eof 
b097			 
b097			 
# End of file forth_words_core.asm
b097			include "forth_words_flow.asm" 
b097			 
b097			; | ## Program Flow Words 
b097			 
b097			.IF: 
b097				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
b097 1e				db WORD_SYS_CORE+10             
b098 8c b1			dw .THEN            
b09a 03				db 2 + 1 
b09b .. 00			db "IF",0              
b09e				endm 
# End of macro CWHEAD
b09e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
b09e			; 
b09e					if DEBUG_FORTH_WORDS_KEY 
b09e						DMARK "IF." 
b09e f5				push af  
b09f 3a b3 b0			ld a, (.dmark)  
b0a2 32 6b ee			ld (debug_mark),a  
b0a5 3a b4 b0			ld a, (.dmark+1)  
b0a8 32 6c ee			ld (debug_mark+1),a  
b0ab 3a b5 b0			ld a, (.dmark+2)  
b0ae 32 6d ee			ld (debug_mark+2),a  
b0b1 18 03			jr .pastdmark  
b0b3 ..			.dmark: db "IF."  
b0b6 f1			.pastdmark: pop af  
b0b7			endm  
# End of macro DMARK
b0b7						CALLMONITOR 
b0b7 cd 6f ee			call debug_vector  
b0ba				endm  
# End of macro CALLMONITOR
b0ba					endif 
b0ba			; eval TOS 
b0ba			 
b0ba				FORTH_DSP_VALUEHL 
b0ba cd 56 9f			call macro_dsp_valuehl 
b0bd				endm 
# End of macro FORTH_DSP_VALUEHL
b0bd			 
b0bd			;	push hl 
b0bd				FORTH_DSP_POP 
b0bd cd 0e a0			call macro_forth_dsp_pop 
b0c0				endm 
# End of macro FORTH_DSP_POP
b0c0			;	pop hl 
b0c0			 
b0c0					if DEBUG_FORTH_WORDS 
b0c0						DMARK "IF1" 
b0c0 f5				push af  
b0c1 3a d5 b0			ld a, (.dmark)  
b0c4 32 6b ee			ld (debug_mark),a  
b0c7 3a d6 b0			ld a, (.dmark+1)  
b0ca 32 6c ee			ld (debug_mark+1),a  
b0cd 3a d7 b0			ld a, (.dmark+2)  
b0d0 32 6d ee			ld (debug_mark+2),a  
b0d3 18 03			jr .pastdmark  
b0d5 ..			.dmark: db "IF1"  
b0d8 f1			.pastdmark: pop af  
b0d9			endm  
# End of macro DMARK
b0d9						CALLMONITOR 
b0d9 cd 6f ee			call debug_vector  
b0dc				endm  
# End of macro CALLMONITOR
b0dc					endif 
b0dc b7				or a        ; clear carry flag 
b0dd 11 00 00			ld de, 0 
b0e0 eb				ex de,hl 
b0e1 ed 52			sbc hl, de 
b0e3 c2 6d b1			jp nz, .iftrue 
b0e6			 
b0e6					if DEBUG_FORTH_WORDS 
b0e6						DMARK "IF2" 
b0e6 f5				push af  
b0e7 3a fb b0			ld a, (.dmark)  
b0ea 32 6b ee			ld (debug_mark),a  
b0ed 3a fc b0			ld a, (.dmark+1)  
b0f0 32 6c ee			ld (debug_mark+1),a  
b0f3 3a fd b0			ld a, (.dmark+2)  
b0f6 32 6d ee			ld (debug_mark+2),a  
b0f9 18 03			jr .pastdmark  
b0fb ..			.dmark: db "IF2"  
b0fe f1			.pastdmark: pop af  
b0ff			endm  
# End of macro DMARK
b0ff						CALLMONITOR 
b0ff cd 6f ee			call debug_vector  
b102				endm  
# End of macro CALLMONITOR
b102					endif 
b102			 
b102			; if not true then skip to THEN 
b102			 
b102				; TODO get tok_ptr 
b102				; TODO consume toks until we get to THEN 
b102			 
b102 2a c2 e5			ld hl, (os_tok_ptr) 
b105					if DEBUG_FORTH_WORDS 
b105						DMARK "IF3" 
b105 f5				push af  
b106 3a 1a b1			ld a, (.dmark)  
b109 32 6b ee			ld (debug_mark),a  
b10c 3a 1b b1			ld a, (.dmark+1)  
b10f 32 6c ee			ld (debug_mark+1),a  
b112 3a 1c b1			ld a, (.dmark+2)  
b115 32 6d ee			ld (debug_mark+2),a  
b118 18 03			jr .pastdmark  
b11a ..			.dmark: db "IF3"  
b11d f1			.pastdmark: pop af  
b11e			endm  
# End of macro DMARK
b11e						CALLMONITOR 
b11e cd 6f ee			call debug_vector  
b121				endm  
# End of macro CALLMONITOR
b121						 
b121					endif 
b121 11 68 b1			ld de, .ifthen 
b124					if DEBUG_FORTH_WORDS 
b124						DMARK "IF4" 
b124 f5				push af  
b125 3a 39 b1			ld a, (.dmark)  
b128 32 6b ee			ld (debug_mark),a  
b12b 3a 3a b1			ld a, (.dmark+1)  
b12e 32 6c ee			ld (debug_mark+1),a  
b131 3a 3b b1			ld a, (.dmark+2)  
b134 32 6d ee			ld (debug_mark+2),a  
b137 18 03			jr .pastdmark  
b139 ..			.dmark: db "IF4"  
b13c f1			.pastdmark: pop af  
b13d			endm  
# End of macro DMARK
b13d						CALLMONITOR 
b13d cd 6f ee			call debug_vector  
b140				endm  
# End of macro CALLMONITOR
b140					endif 
b140 cd 27 a2			call findnexttok  
b143			 
b143					if DEBUG_FORTH_WORDS 
b143						DMARK "IF5" 
b143 f5				push af  
b144 3a 58 b1			ld a, (.dmark)  
b147 32 6b ee			ld (debug_mark),a  
b14a 3a 59 b1			ld a, (.dmark+1)  
b14d 32 6c ee			ld (debug_mark+1),a  
b150 3a 5a b1			ld a, (.dmark+2)  
b153 32 6d ee			ld (debug_mark+2),a  
b156 18 03			jr .pastdmark  
b158 ..			.dmark: db "IF5"  
b15b f1			.pastdmark: pop af  
b15c			endm  
# End of macro DMARK
b15c						CALLMONITOR 
b15c cd 6f ee			call debug_vector  
b15f				endm  
# End of macro CALLMONITOR
b15f					endif 
b15f				; TODO replace below with ; exec using tok_ptr 
b15f 22 c2 e5			ld (os_tok_ptr), hl 
b162 c3 9d a1			jp exec1 
b165				NEXTW 
b165 c3 0c a1			jp macro_next 
b168				endm 
# End of macro NEXTW
b168			 
b168 .. 00		.ifthen:  db "THEN",0 
b16d			 
b16d			.iftrue:		 
b16d				; Exec next words normally 
b16d			 
b16d				; if true then exec following IF as normal 
b16d					if DEBUG_FORTH_WORDS 
b16d						DMARK "IFT" 
b16d f5				push af  
b16e 3a 82 b1			ld a, (.dmark)  
b171 32 6b ee			ld (debug_mark),a  
b174 3a 83 b1			ld a, (.dmark+1)  
b177 32 6c ee			ld (debug_mark+1),a  
b17a 3a 84 b1			ld a, (.dmark+2)  
b17d 32 6d ee			ld (debug_mark+2),a  
b180 18 03			jr .pastdmark  
b182 ..			.dmark: db "IFT"  
b185 f1			.pastdmark: pop af  
b186			endm  
# End of macro DMARK
b186						CALLMONITOR 
b186 cd 6f ee			call debug_vector  
b189				endm  
# End of macro CALLMONITOR
b189					endif 
b189			 
b189					NEXTW 
b189 c3 0c a1			jp macro_next 
b18c				endm 
# End of macro NEXTW
b18c			.THEN: 
b18c				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b18c 1f				db WORD_SYS_CORE+11             
b18d b4 b1			dw .ELSE            
b18f 05				db 4 + 1 
b190 .. 00			db "THEN",0              
b195				endm 
# End of macro CWHEAD
b195			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b195					if DEBUG_FORTH_WORDS_KEY 
b195						DMARK "THN" 
b195 f5				push af  
b196 3a aa b1			ld a, (.dmark)  
b199 32 6b ee			ld (debug_mark),a  
b19c 3a ab b1			ld a, (.dmark+1)  
b19f 32 6c ee			ld (debug_mark+1),a  
b1a2 3a ac b1			ld a, (.dmark+2)  
b1a5 32 6d ee			ld (debug_mark+2),a  
b1a8 18 03			jr .pastdmark  
b1aa ..			.dmark: db "THN"  
b1ad f1			.pastdmark: pop af  
b1ae			endm  
# End of macro DMARK
b1ae						CALLMONITOR 
b1ae cd 6f ee			call debug_vector  
b1b1				endm  
# End of macro CALLMONITOR
b1b1					endif 
b1b1					NEXTW 
b1b1 c3 0c a1			jp macro_next 
b1b4				endm 
# End of macro NEXTW
b1b4			.ELSE: 
b1b4				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b1b4 20				db WORD_SYS_CORE+12             
b1b5 dc b1			dw .DO            
b1b7 03				db 2 + 1 
b1b8 .. 00			db "ELSE",0              
b1bd				endm 
# End of macro CWHEAD
b1bd			; | ELSE ( -- ) Not supported - does nothing | TODO 
b1bd			 
b1bd					if DEBUG_FORTH_WORDS_KEY 
b1bd						DMARK "ELS" 
b1bd f5				push af  
b1be 3a d2 b1			ld a, (.dmark)  
b1c1 32 6b ee			ld (debug_mark),a  
b1c4 3a d3 b1			ld a, (.dmark+1)  
b1c7 32 6c ee			ld (debug_mark+1),a  
b1ca 3a d4 b1			ld a, (.dmark+2)  
b1cd 32 6d ee			ld (debug_mark+2),a  
b1d0 18 03			jr .pastdmark  
b1d2 ..			.dmark: db "ELS"  
b1d5 f1			.pastdmark: pop af  
b1d6			endm  
# End of macro DMARK
b1d6						CALLMONITOR 
b1d6 cd 6f ee			call debug_vector  
b1d9				endm  
# End of macro CALLMONITOR
b1d9					endif 
b1d9			 
b1d9			 
b1d9					NEXTW 
b1d9 c3 0c a1			jp macro_next 
b1dc				endm 
# End of macro NEXTW
b1dc			.DO: 
b1dc				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b1dc 21				db WORD_SYS_CORE+13             
b1dd 03 b3			dw .LOOP            
b1df 03				db 2 + 1 
b1e0 .. 00			db "DO",0              
b1e3				endm 
# End of macro CWHEAD
b1e3			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b1e3			 
b1e3					if DEBUG_FORTH_WORDS_KEY 
b1e3						DMARK "DO." 
b1e3 f5				push af  
b1e4 3a f8 b1			ld a, (.dmark)  
b1e7 32 6b ee			ld (debug_mark),a  
b1ea 3a f9 b1			ld a, (.dmark+1)  
b1ed 32 6c ee			ld (debug_mark+1),a  
b1f0 3a fa b1			ld a, (.dmark+2)  
b1f3 32 6d ee			ld (debug_mark+2),a  
b1f6 18 03			jr .pastdmark  
b1f8 ..			.dmark: db "DO."  
b1fb f1			.pastdmark: pop af  
b1fc			endm  
# End of macro DMARK
b1fc						CALLMONITOR 
b1fc cd 6f ee			call debug_vector  
b1ff				endm  
# End of macro CALLMONITOR
b1ff					endif 
b1ff			;  push pc to rsp stack past the DO 
b1ff			 
b1ff 2a c2 e5				ld hl, (os_tok_ptr) 
b202 23					inc hl   ; D 
b203 23					inc hl  ; O 
b204 23					inc hl   ; null 
b205					if DEBUG_FORTH_WORDS 
b205						DMARK "DO2" 
b205 f5				push af  
b206 3a 1a b2			ld a, (.dmark)  
b209 32 6b ee			ld (debug_mark),a  
b20c 3a 1b b2			ld a, (.dmark+1)  
b20f 32 6c ee			ld (debug_mark+1),a  
b212 3a 1c b2			ld a, (.dmark+2)  
b215 32 6d ee			ld (debug_mark+2),a  
b218 18 03			jr .pastdmark  
b21a ..			.dmark: db "DO2"  
b21d f1			.pastdmark: pop af  
b21e			endm  
# End of macro DMARK
b21e						CALLMONITOR 
b21e cd 6f ee			call debug_vector  
b221				endm  
# End of macro CALLMONITOR
b221					endif 
b221					FORTH_RSP_NEXT 
b221 cd 06 9d			call macro_forth_rsp_next 
b224				endm 
# End of macro FORTH_RSP_NEXT
b224					if DEBUG_FORTH_WORDS 
b224						DMARK "DO3" 
b224 f5				push af  
b225 3a 39 b2			ld a, (.dmark)  
b228 32 6b ee			ld (debug_mark),a  
b22b 3a 3a b2			ld a, (.dmark+1)  
b22e 32 6c ee			ld (debug_mark+1),a  
b231 3a 3b b2			ld a, (.dmark+2)  
b234 32 6d ee			ld (debug_mark+2),a  
b237 18 03			jr .pastdmark  
b239 ..			.dmark: db "DO3"  
b23c f1			.pastdmark: pop af  
b23d			endm  
# End of macro DMARK
b23d						CALLMONITOR 
b23d cd 6f ee			call debug_vector  
b240				endm  
# End of macro CALLMONITOR
b240					endif 
b240			 
b240					;if DEBUG_FORTH_WORDS 
b240				;		push hl 
b240			;		endif  
b240			 
b240			; get counters from data stack 
b240			 
b240			 
b240					FORTH_DSP_VALUEHL 
b240 cd 56 9f			call macro_dsp_valuehl 
b243				endm 
# End of macro FORTH_DSP_VALUEHL
b243 e5					push hl		 ; hl now has starting counter which needs to be tos 
b244			 
b244					if DEBUG_FORTH_WORDS 
b244						DMARK "DO4" 
b244 f5				push af  
b245 3a 59 b2			ld a, (.dmark)  
b248 32 6b ee			ld (debug_mark),a  
b24b 3a 5a b2			ld a, (.dmark+1)  
b24e 32 6c ee			ld (debug_mark+1),a  
b251 3a 5b b2			ld a, (.dmark+2)  
b254 32 6d ee			ld (debug_mark+2),a  
b257 18 03			jr .pastdmark  
b259 ..			.dmark: db "DO4"  
b25c f1			.pastdmark: pop af  
b25d			endm  
# End of macro DMARK
b25d						CALLMONITOR 
b25d cd 6f ee			call debug_vector  
b260				endm  
# End of macro CALLMONITOR
b260					endif 
b260					FORTH_DSP_POP 
b260 cd 0e a0			call macro_forth_dsp_pop 
b263				endm 
# End of macro FORTH_DSP_POP
b263			 
b263					if DEBUG_FORTH_WORDS 
b263						DMARK "DO5" 
b263 f5				push af  
b264 3a 78 b2			ld a, (.dmark)  
b267 32 6b ee			ld (debug_mark),a  
b26a 3a 79 b2			ld a, (.dmark+1)  
b26d 32 6c ee			ld (debug_mark+1),a  
b270 3a 7a b2			ld a, (.dmark+2)  
b273 32 6d ee			ld (debug_mark+2),a  
b276 18 03			jr .pastdmark  
b278 ..			.dmark: db "DO5"  
b27b f1			.pastdmark: pop af  
b27c			endm  
# End of macro DMARK
b27c						CALLMONITOR 
b27c cd 6f ee			call debug_vector  
b27f				endm  
# End of macro CALLMONITOR
b27f					endif 
b27f			 
b27f					FORTH_DSP_VALUEHL 
b27f cd 56 9f			call macro_dsp_valuehl 
b282				endm 
# End of macro FORTH_DSP_VALUEHL
b282			;		push hl		 ; hl now has starting limit counter 
b282			 
b282					if DEBUG_FORTH_WORDS 
b282						DMARK "DO6" 
b282 f5				push af  
b283 3a 97 b2			ld a, (.dmark)  
b286 32 6b ee			ld (debug_mark),a  
b289 3a 98 b2			ld a, (.dmark+1)  
b28c 32 6c ee			ld (debug_mark+1),a  
b28f 3a 99 b2			ld a, (.dmark+2)  
b292 32 6d ee			ld (debug_mark+2),a  
b295 18 03			jr .pastdmark  
b297 ..			.dmark: db "DO6"  
b29a f1			.pastdmark: pop af  
b29b			endm  
# End of macro DMARK
b29b						CALLMONITOR 
b29b cd 6f ee			call debug_vector  
b29e				endm  
# End of macro CALLMONITOR
b29e					endif 
b29e					FORTH_DSP_POP 
b29e cd 0e a0			call macro_forth_dsp_pop 
b2a1				endm 
# End of macro FORTH_DSP_POP
b2a1			 
b2a1			; put counters on the loop stack 
b2a1			 
b2a1			;		pop hl			 ; limit counter 
b2a1 d1					pop de			; start counter 
b2a2			 
b2a2					; push limit counter 
b2a2			 
b2a2					if DEBUG_FORTH_WORDS 
b2a2						DMARK "DO7" 
b2a2 f5				push af  
b2a3 3a b7 b2			ld a, (.dmark)  
b2a6 32 6b ee			ld (debug_mark),a  
b2a9 3a b8 b2			ld a, (.dmark+1)  
b2ac 32 6c ee			ld (debug_mark+1),a  
b2af 3a b9 b2			ld a, (.dmark+2)  
b2b2 32 6d ee			ld (debug_mark+2),a  
b2b5 18 03			jr .pastdmark  
b2b7 ..			.dmark: db "DO7"  
b2ba f1			.pastdmark: pop af  
b2bb			endm  
# End of macro DMARK
b2bb						CALLMONITOR 
b2bb cd 6f ee			call debug_vector  
b2be				endm  
# End of macro CALLMONITOR
b2be					endif 
b2be					FORTH_LOOP_NEXT 
b2be cd 87 9f			call macro_forth_loop_next 
b2c1				endm 
# End of macro FORTH_LOOP_NEXT
b2c1			 
b2c1					; push start counter 
b2c1			 
b2c1 eb					ex de, hl 
b2c2					if DEBUG_FORTH_WORDS 
b2c2						DMARK "DO7" 
b2c2 f5				push af  
b2c3 3a d7 b2			ld a, (.dmark)  
b2c6 32 6b ee			ld (debug_mark),a  
b2c9 3a d8 b2			ld a, (.dmark+1)  
b2cc 32 6c ee			ld (debug_mark+1),a  
b2cf 3a d9 b2			ld a, (.dmark+2)  
b2d2 32 6d ee			ld (debug_mark+2),a  
b2d5 18 03			jr .pastdmark  
b2d7 ..			.dmark: db "DO7"  
b2da f1			.pastdmark: pop af  
b2db			endm  
# End of macro DMARK
b2db						CALLMONITOR 
b2db cd 6f ee			call debug_vector  
b2de				endm  
# End of macro CALLMONITOR
b2de					endif 
b2de					FORTH_LOOP_NEXT 
b2de cd 87 9f			call macro_forth_loop_next 
b2e1				endm 
# End of macro FORTH_LOOP_NEXT
b2e1			 
b2e1			 
b2e1					; init first round of I counter 
b2e1			 
b2e1 22 e6 e5				ld (os_current_i), hl 
b2e4			 
b2e4					if DEBUG_FORTH_WORDS 
b2e4						DMARK "DO8" 
b2e4 f5				push af  
b2e5 3a f9 b2			ld a, (.dmark)  
b2e8 32 6b ee			ld (debug_mark),a  
b2eb 3a fa b2			ld a, (.dmark+1)  
b2ee 32 6c ee			ld (debug_mark+1),a  
b2f1 3a fb b2			ld a, (.dmark+2)  
b2f4 32 6d ee			ld (debug_mark+2),a  
b2f7 18 03			jr .pastdmark  
b2f9 ..			.dmark: db "DO8"  
b2fc f1			.pastdmark: pop af  
b2fd			endm  
# End of macro DMARK
b2fd						CALLMONITOR 
b2fd cd 6f ee			call debug_vector  
b300				endm  
# End of macro CALLMONITOR
b300					endif 
b300			 
b300					NEXTW 
b300 c3 0c a1			jp macro_next 
b303				endm 
# End of macro NEXTW
b303			.LOOP: 
b303				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b303 22				db WORD_SYS_CORE+14             
b304 1b b4			dw .I            
b306 05				db 4 + 1 
b307 .. 00			db "LOOP",0              
b30c				endm 
# End of macro CWHEAD
b30c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b30c			 
b30c				; pop tos as current loop count to hl 
b30c			 
b30c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b30c			 
b30c				FORTH_LOOP_TOS 
b30c cd ba 9f			call macro_forth_loop_tos 
b30f				endm 
# End of macro FORTH_LOOP_TOS
b30f e5				push hl 
b310			 
b310					if DEBUG_FORTH_WORDS_KEY 
b310						DMARK "LOP" 
b310 f5				push af  
b311 3a 25 b3			ld a, (.dmark)  
b314 32 6b ee			ld (debug_mark),a  
b317 3a 26 b3			ld a, (.dmark+1)  
b31a 32 6c ee			ld (debug_mark+1),a  
b31d 3a 27 b3			ld a, (.dmark+2)  
b320 32 6d ee			ld (debug_mark+2),a  
b323 18 03			jr .pastdmark  
b325 ..			.dmark: db "LOP"  
b328 f1			.pastdmark: pop af  
b329			endm  
# End of macro DMARK
b329						CALLMONITOR 
b329 cd 6f ee			call debug_vector  
b32c				endm  
# End of macro CALLMONITOR
b32c					endif 
b32c				; next item on the stack is the limit. get it 
b32c			 
b32c			 
b32c				FORTH_LOOP_POP 
b32c cd c4 9f			call macro_forth_loop_pop 
b32f				endm 
# End of macro FORTH_LOOP_POP
b32f			 
b32f				FORTH_LOOP_TOS 
b32f cd ba 9f			call macro_forth_loop_tos 
b332				endm 
# End of macro FORTH_LOOP_TOS
b332			 
b332 d1				pop de		 ; de = i, hl = limit 
b333			 
b333					if DEBUG_FORTH_WORDS 
b333						DMARK "LP1" 
b333 f5				push af  
b334 3a 48 b3			ld a, (.dmark)  
b337 32 6b ee			ld (debug_mark),a  
b33a 3a 49 b3			ld a, (.dmark+1)  
b33d 32 6c ee			ld (debug_mark+1),a  
b340 3a 4a b3			ld a, (.dmark+2)  
b343 32 6d ee			ld (debug_mark+2),a  
b346 18 03			jr .pastdmark  
b348 ..			.dmark: db "LP1"  
b34b f1			.pastdmark: pop af  
b34c			endm  
# End of macro DMARK
b34c						CALLMONITOR 
b34c cd 6f ee			call debug_vector  
b34f				endm  
# End of macro CALLMONITOR
b34f					endif 
b34f			 
b34f				; go back to previous word 
b34f			 
b34f d5				push de    ; save I for inc later 
b350			 
b350			 
b350				; get limit 
b350				;  is I at limit? 
b350			 
b350			 
b350					if DEBUG_FORTH_WORDS 
b350						DMARK "LP1" 
b350 f5				push af  
b351 3a 65 b3			ld a, (.dmark)  
b354 32 6b ee			ld (debug_mark),a  
b357 3a 66 b3			ld a, (.dmark+1)  
b35a 32 6c ee			ld (debug_mark+1),a  
b35d 3a 67 b3			ld a, (.dmark+2)  
b360 32 6d ee			ld (debug_mark+2),a  
b363 18 03			jr .pastdmark  
b365 ..			.dmark: db "LP1"  
b368 f1			.pastdmark: pop af  
b369			endm  
# End of macro DMARK
b369						CALLMONITOR 
b369 cd 6f ee			call debug_vector  
b36c				endm  
# End of macro CALLMONITOR
b36c					endif 
b36c			 
b36c ed 52			sbc hl, de 
b36e			 
b36e			 
b36e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b36e			 
b36e 20 26				jr nz, .loopnotdone 
b370			 
b370 e1				pop hl   ; get rid of saved I 
b371				FORTH_LOOP_POP     ; get rid of limit 
b371 cd c4 9f			call macro_forth_loop_pop 
b374				endm 
# End of macro FORTH_LOOP_POP
b374			 
b374				FORTH_RSP_POP     ; get rid of DO ptr 
b374 cd 27 9d			call macro_forth_rsp_pop 
b377				endm 
# End of macro FORTH_RSP_POP
b377			 
b377			if DEBUG_FORTH_WORDS 
b377						DMARK "LP>" 
b377 f5				push af  
b378 3a 8c b3			ld a, (.dmark)  
b37b 32 6b ee			ld (debug_mark),a  
b37e 3a 8d b3			ld a, (.dmark+1)  
b381 32 6c ee			ld (debug_mark+1),a  
b384 3a 8e b3			ld a, (.dmark+2)  
b387 32 6d ee			ld (debug_mark+2),a  
b38a 18 03			jr .pastdmark  
b38c ..			.dmark: db "LP>"  
b38f f1			.pastdmark: pop af  
b390			endm  
# End of macro DMARK
b390				CALLMONITOR 
b390 cd 6f ee			call debug_vector  
b393				endm  
# End of macro CALLMONITOR
b393			endif 
b393			 
b393					NEXTW 
b393 c3 0c a1			jp macro_next 
b396				endm 
# End of macro NEXTW
b396				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b396			 
b396			.loopnotdone: 
b396			 
b396 e1				pop hl    ; get I 
b397 23				inc hl 
b398			 
b398			   	; save new I 
b398			 
b398			 
b398					; set I counter 
b398			 
b398 22 e6 e5				ld (os_current_i), hl 
b39b			 
b39b					if DEBUG_FORTH_WORDS 
b39b						DMARK "LPN" 
b39b f5				push af  
b39c 3a b0 b3			ld a, (.dmark)  
b39f 32 6b ee			ld (debug_mark),a  
b3a2 3a b1 b3			ld a, (.dmark+1)  
b3a5 32 6c ee			ld (debug_mark+1),a  
b3a8 3a b2 b3			ld a, (.dmark+2)  
b3ab 32 6d ee			ld (debug_mark+2),a  
b3ae 18 03			jr .pastdmark  
b3b0 ..			.dmark: db "LPN"  
b3b3 f1			.pastdmark: pop af  
b3b4			endm  
# End of macro DMARK
b3b4					CALLMONITOR 
b3b4 cd 6f ee			call debug_vector  
b3b7				endm  
# End of macro CALLMONITOR
b3b7					endif 
b3b7					 
b3b7				FORTH_LOOP_NEXT 
b3b7 cd 87 9f			call macro_forth_loop_next 
b3ba				endm 
# End of macro FORTH_LOOP_NEXT
b3ba			 
b3ba			 
b3ba					if DEBUG_FORTH_WORDS 
b3ba eb						ex de,hl 
b3bb					endif 
b3bb			 
b3bb			;	; get DO ptr 
b3bb			; 
b3bb					if DEBUG_FORTH_WORDS 
b3bb						DMARK "LP7" 
b3bb f5				push af  
b3bc 3a d0 b3			ld a, (.dmark)  
b3bf 32 6b ee			ld (debug_mark),a  
b3c2 3a d1 b3			ld a, (.dmark+1)  
b3c5 32 6c ee			ld (debug_mark+1),a  
b3c8 3a d2 b3			ld a, (.dmark+2)  
b3cb 32 6d ee			ld (debug_mark+2),a  
b3ce 18 03			jr .pastdmark  
b3d0 ..			.dmark: db "LP7"  
b3d3 f1			.pastdmark: pop af  
b3d4			endm  
# End of macro DMARK
b3d4					CALLMONITOR 
b3d4 cd 6f ee			call debug_vector  
b3d7				endm  
# End of macro CALLMONITOR
b3d7					endif 
b3d7				FORTH_RSP_TOS 
b3d7 cd 1d 9d			call macro_forth_rsp_tos 
b3da				endm 
# End of macro FORTH_RSP_TOS
b3da			 
b3da					if DEBUG_FORTH_WORDS 
b3da						DMARK "LP8" 
b3da f5				push af  
b3db 3a ef b3			ld a, (.dmark)  
b3de 32 6b ee			ld (debug_mark),a  
b3e1 3a f0 b3			ld a, (.dmark+1)  
b3e4 32 6c ee			ld (debug_mark+1),a  
b3e7 3a f1 b3			ld a, (.dmark+2)  
b3ea 32 6d ee			ld (debug_mark+2),a  
b3ed 18 03			jr .pastdmark  
b3ef ..			.dmark: db "LP8"  
b3f2 f1			.pastdmark: pop af  
b3f3			endm  
# End of macro DMARK
b3f3					CALLMONITOR 
b3f3 cd 6f ee			call debug_vector  
b3f6				endm  
# End of macro CALLMONITOR
b3f6					endif 
b3f6				;push hl 
b3f6			 
b3f6				; not going to DO any more 
b3f6				; get rid of the RSP pointer as DO will add it back in 
b3f6				;FORTH_RSP_POP 
b3f6				;pop hl 
b3f6			 
b3f6				;ld hl,(cli_ret_sp) 
b3f6				;ld e, (hl) 
b3f6				;inc hl 
b3f6				;ld d, (hl) 
b3f6				;ex de,hl 
b3f6 22 c2 e5			ld (os_tok_ptr), hl 
b3f9					if DEBUG_FORTH_WORDS 
b3f9						DMARK "LP<" 
b3f9 f5				push af  
b3fa 3a 0e b4			ld a, (.dmark)  
b3fd 32 6b ee			ld (debug_mark),a  
b400 3a 0f b4			ld a, (.dmark+1)  
b403 32 6c ee			ld (debug_mark+1),a  
b406 3a 10 b4			ld a, (.dmark+2)  
b409 32 6d ee			ld (debug_mark+2),a  
b40c 18 03			jr .pastdmark  
b40e ..			.dmark: db "LP<"  
b411 f1			.pastdmark: pop af  
b412			endm  
# End of macro DMARK
b412					CALLMONITOR 
b412 cd 6f ee			call debug_vector  
b415				endm  
# End of macro CALLMONITOR
b415				endif 
b415 c3 9d a1			jp exec1 
b418			 
b418					 
b418			 
b418			 
b418					NEXTW 
b418 c3 0c a1			jp macro_next 
b41b				endm 
# End of macro NEXTW
b41b			.I:  
b41b			 
b41b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b41b 5e				db WORD_SYS_CORE+74             
b41c 46 b4			dw .DLOOP            
b41e 02				db 1 + 1 
b41f .. 00			db "I",0              
b421				endm 
# End of macro CWHEAD
b421			; | I ( -- ) Current loop counter | DONE 
b421					if DEBUG_FORTH_WORDS_KEY 
b421						DMARK "I.." 
b421 f5				push af  
b422 3a 36 b4			ld a, (.dmark)  
b425 32 6b ee			ld (debug_mark),a  
b428 3a 37 b4			ld a, (.dmark+1)  
b42b 32 6c ee			ld (debug_mark+1),a  
b42e 3a 38 b4			ld a, (.dmark+2)  
b431 32 6d ee			ld (debug_mark+2),a  
b434 18 03			jr .pastdmark  
b436 ..			.dmark: db "I.."  
b439 f1			.pastdmark: pop af  
b43a			endm  
# End of macro DMARK
b43a						CALLMONITOR 
b43a cd 6f ee			call debug_vector  
b43d				endm  
# End of macro CALLMONITOR
b43d					endif 
b43d			 
b43d 2a e6 e5				ld hl,(os_current_i) 
b440 cd 5f 9d				call forth_push_numhl 
b443			 
b443					NEXTW 
b443 c3 0c a1			jp macro_next 
b446				endm 
# End of macro NEXTW
b446			.DLOOP: 
b446				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b446 5f				db WORD_SYS_CORE+75             
b447 27 b5			dw .REPEAT            
b449 06				db 5 + 1 
b44a .. 00			db "-LOOP",0              
b450				endm 
# End of macro CWHEAD
b450			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b450				; pop tos as current loop count to hl 
b450					if DEBUG_FORTH_WORDS_KEY 
b450						DMARK "-LP" 
b450 f5				push af  
b451 3a 65 b4			ld a, (.dmark)  
b454 32 6b ee			ld (debug_mark),a  
b457 3a 66 b4			ld a, (.dmark+1)  
b45a 32 6c ee			ld (debug_mark+1),a  
b45d 3a 67 b4			ld a, (.dmark+2)  
b460 32 6d ee			ld (debug_mark+2),a  
b463 18 03			jr .pastdmark  
b465 ..			.dmark: db "-LP"  
b468 f1			.pastdmark: pop af  
b469			endm  
# End of macro DMARK
b469						CALLMONITOR 
b469 cd 6f ee			call debug_vector  
b46c				endm  
# End of macro CALLMONITOR
b46c					endif 
b46c			 
b46c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b46c			 
b46c				FORTH_LOOP_TOS 
b46c cd ba 9f			call macro_forth_loop_tos 
b46f				endm 
# End of macro FORTH_LOOP_TOS
b46f e5				push hl 
b470			 
b470					if DEBUG_FORTH_WORDS 
b470						DMARK "-LP" 
b470 f5				push af  
b471 3a 85 b4			ld a, (.dmark)  
b474 32 6b ee			ld (debug_mark),a  
b477 3a 86 b4			ld a, (.dmark+1)  
b47a 32 6c ee			ld (debug_mark+1),a  
b47d 3a 87 b4			ld a, (.dmark+2)  
b480 32 6d ee			ld (debug_mark+2),a  
b483 18 03			jr .pastdmark  
b485 ..			.dmark: db "-LP"  
b488 f1			.pastdmark: pop af  
b489			endm  
# End of macro DMARK
b489						CALLMONITOR 
b489 cd 6f ee			call debug_vector  
b48c				endm  
# End of macro CALLMONITOR
b48c					endif 
b48c				; next item on the stack is the limit. get it 
b48c			 
b48c			 
b48c				FORTH_LOOP_POP 
b48c cd c4 9f			call macro_forth_loop_pop 
b48f				endm 
# End of macro FORTH_LOOP_POP
b48f			 
b48f				FORTH_LOOP_TOS 
b48f cd ba 9f			call macro_forth_loop_tos 
b492				endm 
# End of macro FORTH_LOOP_TOS
b492			 
b492 d1				pop de		 ; de = i, hl = limit 
b493			 
b493					if DEBUG_FORTH_WORDS 
b493						DMARK "-L1" 
b493 f5				push af  
b494 3a a8 b4			ld a, (.dmark)  
b497 32 6b ee			ld (debug_mark),a  
b49a 3a a9 b4			ld a, (.dmark+1)  
b49d 32 6c ee			ld (debug_mark+1),a  
b4a0 3a aa b4			ld a, (.dmark+2)  
b4a3 32 6d ee			ld (debug_mark+2),a  
b4a6 18 03			jr .pastdmark  
b4a8 ..			.dmark: db "-L1"  
b4ab f1			.pastdmark: pop af  
b4ac			endm  
# End of macro DMARK
b4ac						CALLMONITOR 
b4ac cd 6f ee			call debug_vector  
b4af				endm  
# End of macro CALLMONITOR
b4af					endif 
b4af			 
b4af				; go back to previous word 
b4af			 
b4af d5				push de    ; save I for inc later 
b4b0			 
b4b0			 
b4b0				; get limit 
b4b0				;  is I at limit? 
b4b0			 
b4b0			 
b4b0					if DEBUG_FORTH_WORDS 
b4b0						DMARK "-L1" 
b4b0 f5				push af  
b4b1 3a c5 b4			ld a, (.dmark)  
b4b4 32 6b ee			ld (debug_mark),a  
b4b7 3a c6 b4			ld a, (.dmark+1)  
b4ba 32 6c ee			ld (debug_mark+1),a  
b4bd 3a c7 b4			ld a, (.dmark+2)  
b4c0 32 6d ee			ld (debug_mark+2),a  
b4c3 18 03			jr .pastdmark  
b4c5 ..			.dmark: db "-L1"  
b4c8 f1			.pastdmark: pop af  
b4c9			endm  
# End of macro DMARK
b4c9						CALLMONITOR 
b4c9 cd 6f ee			call debug_vector  
b4cc				endm  
# End of macro CALLMONITOR
b4cc					endif 
b4cc			 
b4cc ed 52			sbc hl, de 
b4ce			 
b4ce			 
b4ce				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b4ce			 
b4ce 20 26				jr nz, .mloopnotdone 
b4d0			 
b4d0 e1				pop hl   ; get rid of saved I 
b4d1				FORTH_LOOP_POP     ; get rid of limit 
b4d1 cd c4 9f			call macro_forth_loop_pop 
b4d4				endm 
# End of macro FORTH_LOOP_POP
b4d4			 
b4d4				FORTH_RSP_POP     ; get rid of DO ptr 
b4d4 cd 27 9d			call macro_forth_rsp_pop 
b4d7				endm 
# End of macro FORTH_RSP_POP
b4d7			 
b4d7			if DEBUG_FORTH_WORDS 
b4d7						DMARK "-L>" 
b4d7 f5				push af  
b4d8 3a ec b4			ld a, (.dmark)  
b4db 32 6b ee			ld (debug_mark),a  
b4de 3a ed b4			ld a, (.dmark+1)  
b4e1 32 6c ee			ld (debug_mark+1),a  
b4e4 3a ee b4			ld a, (.dmark+2)  
b4e7 32 6d ee			ld (debug_mark+2),a  
b4ea 18 03			jr .pastdmark  
b4ec ..			.dmark: db "-L>"  
b4ef f1			.pastdmark: pop af  
b4f0			endm  
# End of macro DMARK
b4f0				CALLMONITOR 
b4f0 cd 6f ee			call debug_vector  
b4f3				endm  
# End of macro CALLMONITOR
b4f3			endif 
b4f3			 
b4f3					NEXTW 
b4f3 c3 0c a1			jp macro_next 
b4f6				endm 
# End of macro NEXTW
b4f6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b4f6			 
b4f6			.mloopnotdone: 
b4f6			 
b4f6 e1				pop hl    ; get I 
b4f7 2b				dec hl 
b4f8			 
b4f8			   	; save new I 
b4f8			 
b4f8			 
b4f8					; set I counter 
b4f8			 
b4f8 22 e6 e5				ld (os_current_i), hl 
b4fb			 
b4fb					 
b4fb				FORTH_LOOP_NEXT 
b4fb cd 87 9f			call macro_forth_loop_next 
b4fe				endm 
# End of macro FORTH_LOOP_NEXT
b4fe			 
b4fe			 
b4fe					if DEBUG_FORTH_WORDS 
b4fe eb						ex de,hl 
b4ff					endif 
b4ff			 
b4ff			;	; get DO ptr 
b4ff			; 
b4ff				FORTH_RSP_TOS 
b4ff cd 1d 9d			call macro_forth_rsp_tos 
b502				endm 
# End of macro FORTH_RSP_TOS
b502			 
b502				;push hl 
b502			 
b502				; not going to DO any more 
b502				; get rid of the RSP pointer as DO will add it back in 
b502				;FORTH_RSP_POP 
b502				;pop hl 
b502			 
b502			 
b502 22 c2 e5			ld (os_tok_ptr), hl 
b505					if DEBUG_FORTH_WORDS 
b505						DMARK "-L<" 
b505 f5				push af  
b506 3a 1a b5			ld a, (.dmark)  
b509 32 6b ee			ld (debug_mark),a  
b50c 3a 1b b5			ld a, (.dmark+1)  
b50f 32 6c ee			ld (debug_mark+1),a  
b512 3a 1c b5			ld a, (.dmark+2)  
b515 32 6d ee			ld (debug_mark+2),a  
b518 18 03			jr .pastdmark  
b51a ..			.dmark: db "-L<"  
b51d f1			.pastdmark: pop af  
b51e			endm  
# End of macro DMARK
b51e					CALLMONITOR 
b51e cd 6f ee			call debug_vector  
b521				endm  
# End of macro CALLMONITOR
b521				endif 
b521 c3 9d a1			jp exec1 
b524			 
b524					 
b524			 
b524			 
b524			 
b524				NEXTW 
b524 c3 0c a1			jp macro_next 
b527				endm 
# End of macro NEXTW
b527			 
b527			 
b527			 
b527			 
b527			.REPEAT: 
b527				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b527 71				db WORD_SYS_CORE+93             
b528 7a b5			dw .UNTIL            
b52a 06				db 5 + 1 
b52b .. 00			db "REPEAT",0              
b532				endm 
# End of macro CWHEAD
b532			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b532			;  push pc to rsp stack past the REPEAT 
b532					if DEBUG_FORTH_WORDS_KEY 
b532						DMARK "REP" 
b532 f5				push af  
b533 3a 47 b5			ld a, (.dmark)  
b536 32 6b ee			ld (debug_mark),a  
b539 3a 48 b5			ld a, (.dmark+1)  
b53c 32 6c ee			ld (debug_mark+1),a  
b53f 3a 49 b5			ld a, (.dmark+2)  
b542 32 6d ee			ld (debug_mark+2),a  
b545 18 03			jr .pastdmark  
b547 ..			.dmark: db "REP"  
b54a f1			.pastdmark: pop af  
b54b			endm  
# End of macro DMARK
b54b						CALLMONITOR 
b54b cd 6f ee			call debug_vector  
b54e				endm  
# End of macro CALLMONITOR
b54e					endif 
b54e			 
b54e 2a c2 e5				ld hl, (os_tok_ptr) 
b551 23					inc hl   ; R 
b552 23					inc hl  ; E 
b553 23					inc hl   ; P 
b554 23					inc hl   ; E 
b555 23					inc hl   ; A 
b556 23					inc hl   ; T 
b557 23					inc hl   ; zero 
b558					FORTH_RSP_NEXT 
b558 cd 06 9d			call macro_forth_rsp_next 
b55b				endm 
# End of macro FORTH_RSP_NEXT
b55b			 
b55b			 
b55b					if DEBUG_FORTH_WORDS 
b55b						DMARK "REP" 
b55b f5				push af  
b55c 3a 70 b5			ld a, (.dmark)  
b55f 32 6b ee			ld (debug_mark),a  
b562 3a 71 b5			ld a, (.dmark+1)  
b565 32 6c ee			ld (debug_mark+1),a  
b568 3a 72 b5			ld a, (.dmark+2)  
b56b 32 6d ee			ld (debug_mark+2),a  
b56e 18 03			jr .pastdmark  
b570 ..			.dmark: db "REP"  
b573 f1			.pastdmark: pop af  
b574			endm  
# End of macro DMARK
b574						;pop bc    ; TODO BUG ?????? what is this for???? 
b574						CALLMONITOR 
b574 cd 6f ee			call debug_vector  
b577				endm  
# End of macro CALLMONITOR
b577					endif 
b577			 
b577					NEXTW 
b577 c3 0c a1			jp macro_next 
b57a				endm 
# End of macro NEXTW
b57a			;	       NEXTW 
b57a			 
b57a			.UNTIL: 
b57a				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b57a 72				db WORD_SYS_CORE+94             
b57b 11 b6			dw .ENDFLOW            
b57d 06				db 5 + 1 
b57e .. 00			db "UNTIL",0              
b584				endm 
# End of macro CWHEAD
b584			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b584			 
b584				; pop tos as check 
b584			 
b584				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b584			 
b584				FORTH_DSP_VALUEHL 
b584 cd 56 9f			call macro_dsp_valuehl 
b587				endm 
# End of macro FORTH_DSP_VALUEHL
b587			 
b587					if DEBUG_FORTH_WORDS_KEY 
b587						DMARK "UNT" 
b587 f5				push af  
b588 3a 9c b5			ld a, (.dmark)  
b58b 32 6b ee			ld (debug_mark),a  
b58e 3a 9d b5			ld a, (.dmark+1)  
b591 32 6c ee			ld (debug_mark+1),a  
b594 3a 9e b5			ld a, (.dmark+2)  
b597 32 6d ee			ld (debug_mark+2),a  
b59a 18 03			jr .pastdmark  
b59c ..			.dmark: db "UNT"  
b59f f1			.pastdmark: pop af  
b5a0			endm  
# End of macro DMARK
b5a0						CALLMONITOR 
b5a0 cd 6f ee			call debug_vector  
b5a3				endm  
# End of macro CALLMONITOR
b5a3					endif 
b5a3			 
b5a3			;	push hl 
b5a3				FORTH_DSP_POP 
b5a3 cd 0e a0			call macro_forth_dsp_pop 
b5a6				endm 
# End of macro FORTH_DSP_POP
b5a6			 
b5a6			;	pop hl 
b5a6			 
b5a6				; test if true 
b5a6			 
b5a6 cd 04 8d			call ishlzero 
b5a9			;	ld a,l 
b5a9			;	add h 
b5a9			; 
b5a9			;	cp 0 
b5a9			 
b5a9 20 3e			jr nz, .untilnotdone 
b5ab			 
b5ab					if DEBUG_FORTH_WORDS 
b5ab						DMARK "UNf" 
b5ab f5				push af  
b5ac 3a c0 b5			ld a, (.dmark)  
b5af 32 6b ee			ld (debug_mark),a  
b5b2 3a c1 b5			ld a, (.dmark+1)  
b5b5 32 6c ee			ld (debug_mark+1),a  
b5b8 3a c2 b5			ld a, (.dmark+2)  
b5bb 32 6d ee			ld (debug_mark+2),a  
b5be 18 03			jr .pastdmark  
b5c0 ..			.dmark: db "UNf"  
b5c3 f1			.pastdmark: pop af  
b5c4			endm  
# End of macro DMARK
b5c4						CALLMONITOR 
b5c4 cd 6f ee			call debug_vector  
b5c7				endm  
# End of macro CALLMONITOR
b5c7					endif 
b5c7			 
b5c7			 
b5c7			 
b5c7				FORTH_RSP_POP     ; get rid of DO ptr 
b5c7 cd 27 9d			call macro_forth_rsp_pop 
b5ca				endm 
# End of macro FORTH_RSP_POP
b5ca			 
b5ca			if DEBUG_FORTH_WORDS 
b5ca						DMARK "UN>" 
b5ca f5				push af  
b5cb 3a df b5			ld a, (.dmark)  
b5ce 32 6b ee			ld (debug_mark),a  
b5d1 3a e0 b5			ld a, (.dmark+1)  
b5d4 32 6c ee			ld (debug_mark+1),a  
b5d7 3a e1 b5			ld a, (.dmark+2)  
b5da 32 6d ee			ld (debug_mark+2),a  
b5dd 18 03			jr .pastdmark  
b5df ..			.dmark: db "UN>"  
b5e2 f1			.pastdmark: pop af  
b5e3			endm  
# End of macro DMARK
b5e3				CALLMONITOR 
b5e3 cd 6f ee			call debug_vector  
b5e6				endm  
# End of macro CALLMONITOR
b5e6			endif 
b5e6			 
b5e6					NEXTW 
b5e6 c3 0c a1			jp macro_next 
b5e9				endm 
# End of macro NEXTW
b5e9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b5e9			 
b5e9			.untilnotdone: 
b5e9			 
b5e9			 
b5e9			;	; get DO ptr 
b5e9			; 
b5e9				FORTH_RSP_TOS 
b5e9 cd 1d 9d			call macro_forth_rsp_tos 
b5ec				endm 
# End of macro FORTH_RSP_TOS
b5ec			 
b5ec				;push hl 
b5ec			 
b5ec				; not going to DO any more 
b5ec				; get rid of the RSP pointer as DO will add it back in 
b5ec				;FORTH_RSP_POP 
b5ec				;pop hl 
b5ec			 
b5ec			 
b5ec 22 c2 e5			ld (os_tok_ptr), hl 
b5ef					if DEBUG_FORTH_WORDS 
b5ef						DMARK "UN<" 
b5ef f5				push af  
b5f0 3a 04 b6			ld a, (.dmark)  
b5f3 32 6b ee			ld (debug_mark),a  
b5f6 3a 05 b6			ld a, (.dmark+1)  
b5f9 32 6c ee			ld (debug_mark+1),a  
b5fc 3a 06 b6			ld a, (.dmark+2)  
b5ff 32 6d ee			ld (debug_mark+2),a  
b602 18 03			jr .pastdmark  
b604 ..			.dmark: db "UN<"  
b607 f1			.pastdmark: pop af  
b608			endm  
# End of macro DMARK
b608					CALLMONITOR 
b608 cd 6f ee			call debug_vector  
b60b				endm  
# End of macro CALLMONITOR
b60b				endif 
b60b c3 9d a1			jp exec1 
b60e			 
b60e					 
b60e			 
b60e			 
b60e					NEXTW 
b60e c3 0c a1			jp macro_next 
b611				endm 
# End of macro NEXTW
b611			 
b611			 
b611			.ENDFLOW: 
b611			 
b611			; eof 
b611			 
# End of file forth_words_flow.asm
b611			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b611			include "forth_words_logic.asm" 
b611			 
b611			; | ## Logic Words 
b611			 
b611			.NOT: 
b611				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b611 2d				db WORD_SYS_CORE+25             
b612 59 b6			dw .IS            
b614 04				db 3 + 1 
b615 .. 00			db "NOT",0              
b619				endm 
# End of macro CWHEAD
b619			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b619					if DEBUG_FORTH_WORDS_KEY 
b619						DMARK "NOT" 
b619 f5				push af  
b61a 3a 2e b6			ld a, (.dmark)  
b61d 32 6b ee			ld (debug_mark),a  
b620 3a 2f b6			ld a, (.dmark+1)  
b623 32 6c ee			ld (debug_mark+1),a  
b626 3a 30 b6			ld a, (.dmark+2)  
b629 32 6d ee			ld (debug_mark+2),a  
b62c 18 03			jr .pastdmark  
b62e ..			.dmark: db "NOT"  
b631 f1			.pastdmark: pop af  
b632			endm  
# End of macro DMARK
b632						CALLMONITOR 
b632 cd 6f ee			call debug_vector  
b635				endm  
# End of macro CALLMONITOR
b635					endif 
b635					FORTH_DSP 
b635 cd 1c 9f			call macro_forth_dsp 
b638				endm 
# End of macro FORTH_DSP
b638 7e					ld a,(hl)	; get type of value on TOS 
b639 fe 02				cp DS_TYPE_INUM  
b63b 28 03				jr z, .noti 
b63d					NEXTW 
b63d c3 0c a1			jp macro_next 
b640				endm 
# End of macro NEXTW
b640			.noti:          FORTH_DSP_VALUEHL 
b640 cd 56 9f			call macro_dsp_valuehl 
b643				endm 
# End of macro FORTH_DSP_VALUEHL
b643			;		push hl 
b643					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b643 cd 0e a0			call macro_forth_dsp_pop 
b646				endm 
# End of macro FORTH_DSP_POP
b646			;		pop hl 
b646 3e 00				ld a,0 
b648 bd					cp l 
b649 28 04				jr z, .not2t 
b64b 2e 00				ld l, 0 
b64d 18 02				jr .notip 
b64f			 
b64f 2e ff		.not2t:		ld l, 255 
b651			 
b651 26 00		.notip:		ld h, 0	 
b653			 
b653 cd 5f 9d				call forth_push_numhl 
b656					NEXTW 
b656 c3 0c a1			jp macro_next 
b659				endm 
# End of macro NEXTW
b659			 
b659			.IS: 
b659				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b659 2d				db WORD_SYS_CORE+25             
b65a 7f b6			dw .LZERO            
b65c 03				db 2 + 1 
b65d .. 00			db "IS",0              
b660				endm 
# End of macro CWHEAD
b660			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b660					if DEBUG_FORTH_WORDS_KEY 
b660						DMARK "IS." 
b660 f5				push af  
b661 3a 75 b6			ld a, (.dmark)  
b664 32 6b ee			ld (debug_mark),a  
b667 3a 76 b6			ld a, (.dmark+1)  
b66a 32 6c ee			ld (debug_mark+1),a  
b66d 3a 77 b6			ld a, (.dmark+2)  
b670 32 6d ee			ld (debug_mark+2),a  
b673 18 03			jr .pastdmark  
b675 ..			.dmark: db "IS."  
b678 f1			.pastdmark: pop af  
b679			endm  
# End of macro DMARK
b679						CALLMONITOR 
b679 cd 6f ee			call debug_vector  
b67c				endm  
# End of macro CALLMONITOR
b67c					endif 
b67c					NEXTW 
b67c c3 0c a1			jp macro_next 
b67f				endm 
# End of macro NEXTW
b67f			.LZERO: 
b67f				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b67f 2d				db WORD_SYS_CORE+25             
b680 89 b6			dw .TZERO            
b682 03				db 2 + 1 
b683 .. 00			db "0<",0              
b686				endm 
# End of macro CWHEAD
b686			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b686					NEXTW 
b686 c3 0c a1			jp macro_next 
b689				endm 
# End of macro NEXTW
b689			.TZERO: 
b689				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b689 2e				db WORD_SYS_CORE+26             
b68a d0 b6			dw .LESS            
b68c 03				db 2 + 1 
b68d .. 00			db "0=",0              
b690				endm 
# End of macro CWHEAD
b690			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b690				; TODO add floating point number detection 
b690					;v5 FORTH_DSP_VALUE 
b690					if DEBUG_FORTH_WORDS_KEY 
b690						DMARK "0=." 
b690 f5				push af  
b691 3a a5 b6			ld a, (.dmark)  
b694 32 6b ee			ld (debug_mark),a  
b697 3a a6 b6			ld a, (.dmark+1)  
b69a 32 6c ee			ld (debug_mark+1),a  
b69d 3a a7 b6			ld a, (.dmark+2)  
b6a0 32 6d ee			ld (debug_mark+2),a  
b6a3 18 03			jr .pastdmark  
b6a5 ..			.dmark: db "0=."  
b6a8 f1			.pastdmark: pop af  
b6a9			endm  
# End of macro DMARK
b6a9						CALLMONITOR 
b6a9 cd 6f ee			call debug_vector  
b6ac				endm  
# End of macro CALLMONITOR
b6ac					endif 
b6ac					FORTH_DSP 
b6ac cd 1c 9f			call macro_forth_dsp 
b6af				endm 
# End of macro FORTH_DSP
b6af 7e					ld a,(hl)	; get type of value on TOS 
b6b0 fe 02				cp DS_TYPE_INUM  
b6b2 28 00				jr z, .tz_inum 
b6b4			 
b6b4				if FORTH_ENABLE_FLOATMATH 
b6b4					jr .tz_done 
b6b4			 
b6b4				endif 
b6b4					 
b6b4			 
b6b4			.tz_inum: 
b6b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b4 cd 56 9f			call macro_dsp_valuehl 
b6b7				endm 
# End of macro FORTH_DSP_VALUEHL
b6b7			 
b6b7			;		push hl 
b6b7			 
b6b7					; destroy value TOS 
b6b7			 
b6b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b7 cd 0e a0			call macro_forth_dsp_pop 
b6ba				endm 
# End of macro FORTH_DSP_POP
b6ba			 
b6ba			;		pop hl 
b6ba			 
b6ba 3e 00				ld a,0 
b6bc			 
b6bc bd					cp l 
b6bd 20 08				jr nz, .tz_notzero 
b6bf			 
b6bf bc					cp h 
b6c0			 
b6c0 20 05				jr nz, .tz_notzero 
b6c2			 
b6c2			 
b6c2 21 01 00				ld hl, FORTH_TRUE 
b6c5 18 03				jr .tz_done 
b6c7			 
b6c7 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b6ca			 
b6ca					; push value back onto stack for another op etc 
b6ca			 
b6ca			.tz_done: 
b6ca cd 5f 9d				call forth_push_numhl 
b6cd			 
b6cd					NEXTW 
b6cd c3 0c a1			jp macro_next 
b6d0				endm 
# End of macro NEXTW
b6d0			.LESS: 
b6d0				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b6d0 2f				db WORD_SYS_CORE+27             
b6d1 39 b7			dw .GT            
b6d3 02				db 1 + 1 
b6d4 .. 00			db "<",0              
b6d6				endm 
# End of macro CWHEAD
b6d6			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b6d6				; TODO add floating point number detection 
b6d6					if DEBUG_FORTH_WORDS_KEY 
b6d6						DMARK "LES" 
b6d6 f5				push af  
b6d7 3a eb b6			ld a, (.dmark)  
b6da 32 6b ee			ld (debug_mark),a  
b6dd 3a ec b6			ld a, (.dmark+1)  
b6e0 32 6c ee			ld (debug_mark+1),a  
b6e3 3a ed b6			ld a, (.dmark+2)  
b6e6 32 6d ee			ld (debug_mark+2),a  
b6e9 18 03			jr .pastdmark  
b6eb ..			.dmark: db "LES"  
b6ee f1			.pastdmark: pop af  
b6ef			endm  
# End of macro DMARK
b6ef						CALLMONITOR 
b6ef cd 6f ee			call debug_vector  
b6f2				endm  
# End of macro CALLMONITOR
b6f2					endif 
b6f2					FORTH_DSP 
b6f2 cd 1c 9f			call macro_forth_dsp 
b6f5				endm 
# End of macro FORTH_DSP
b6f5					;v5 FORTH_DSP_VALUE 
b6f5 7e					ld a,(hl)	; get type of value on TOS 
b6f6 fe 02				cp DS_TYPE_INUM  
b6f8 28 00				jr z, .less_inum 
b6fa			 
b6fa				if FORTH_ENABLE_FLOATMATH 
b6fa					jr .less_done 
b6fa			 
b6fa				endif 
b6fa					 
b6fa			 
b6fa			.less_inum: 
b6fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6fa cd 56 9f			call macro_dsp_valuehl 
b6fd				endm 
# End of macro FORTH_DSP_VALUEHL
b6fd			 
b6fd e5					push hl  ; u2 
b6fe			 
b6fe					; destroy value TOS 
b6fe			 
b6fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fe cd 0e a0			call macro_forth_dsp_pop 
b701				endm 
# End of macro FORTH_DSP_POP
b701			 
b701			 
b701					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b701 cd 56 9f			call macro_dsp_valuehl 
b704				endm 
# End of macro FORTH_DSP_VALUEHL
b704			 
b704 e5					push hl    ; u1 
b705			 
b705					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b705 cd 0e a0			call macro_forth_dsp_pop 
b708				endm 
# End of macro FORTH_DSP_POP
b708			 
b708			 
b708 b7			 or a      ;clear carry flag 
b709 01 00 00		 ld bc, FORTH_FALSE 
b70c e1			  pop hl    ; u1 
b70d d1			  pop de    ; u2 
b70e ed 52		  sbc hl,de 
b710 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b712			 
b712 01 01 00		 ld bc, FORTH_TRUE 
b715			.lscont:  
b715 c5					push bc 
b716 e1					pop hl 
b717			 
b717					if DEBUG_FORTH_WORDS 
b717						DMARK "LT1" 
b717 f5				push af  
b718 3a 2c b7			ld a, (.dmark)  
b71b 32 6b ee			ld (debug_mark),a  
b71e 3a 2d b7			ld a, (.dmark+1)  
b721 32 6c ee			ld (debug_mark+1),a  
b724 3a 2e b7			ld a, (.dmark+2)  
b727 32 6d ee			ld (debug_mark+2),a  
b72a 18 03			jr .pastdmark  
b72c ..			.dmark: db "LT1"  
b72f f1			.pastdmark: pop af  
b730			endm  
# End of macro DMARK
b730						CALLMONITOR 
b730 cd 6f ee			call debug_vector  
b733				endm  
# End of macro CALLMONITOR
b733					endif 
b733 cd 5f 9d				call forth_push_numhl 
b736			 
b736					NEXTW 
b736 c3 0c a1			jp macro_next 
b739				endm 
# End of macro NEXTW
b739			.GT: 
b739				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b739 30				db WORD_SYS_CORE+28             
b73a a2 b7			dw .EQUAL            
b73c 02				db 1 + 1 
b73d .. 00			db ">",0              
b73f				endm 
# End of macro CWHEAD
b73f			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b73f				; TODO add floating point number detection 
b73f					if DEBUG_FORTH_WORDS_KEY 
b73f						DMARK "GRT" 
b73f f5				push af  
b740 3a 54 b7			ld a, (.dmark)  
b743 32 6b ee			ld (debug_mark),a  
b746 3a 55 b7			ld a, (.dmark+1)  
b749 32 6c ee			ld (debug_mark+1),a  
b74c 3a 56 b7			ld a, (.dmark+2)  
b74f 32 6d ee			ld (debug_mark+2),a  
b752 18 03			jr .pastdmark  
b754 ..			.dmark: db "GRT"  
b757 f1			.pastdmark: pop af  
b758			endm  
# End of macro DMARK
b758						CALLMONITOR 
b758 cd 6f ee			call debug_vector  
b75b				endm  
# End of macro CALLMONITOR
b75b					endif 
b75b					FORTH_DSP 
b75b cd 1c 9f			call macro_forth_dsp 
b75e				endm 
# End of macro FORTH_DSP
b75e					;FORTH_DSP_VALUE 
b75e 7e					ld a,(hl)	; get type of value on TOS 
b75f fe 02				cp DS_TYPE_INUM  
b761 28 00				jr z, .gt_inum 
b763			 
b763				if FORTH_ENABLE_FLOATMATH 
b763					jr .gt_done 
b763			 
b763				endif 
b763					 
b763			 
b763			.gt_inum: 
b763					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b763 cd 56 9f			call macro_dsp_valuehl 
b766				endm 
# End of macro FORTH_DSP_VALUEHL
b766			 
b766 e5					push hl  ; u2 
b767			 
b767					; destroy value TOS 
b767			 
b767					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b767 cd 0e a0			call macro_forth_dsp_pop 
b76a				endm 
# End of macro FORTH_DSP_POP
b76a			 
b76a			 
b76a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b76a cd 56 9f			call macro_dsp_valuehl 
b76d				endm 
# End of macro FORTH_DSP_VALUEHL
b76d			 
b76d e5					push hl    ; u1 
b76e			 
b76e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b76e cd 0e a0			call macro_forth_dsp_pop 
b771				endm 
# End of macro FORTH_DSP_POP
b771			 
b771			 
b771 b7			 or a      ;clear carry flag 
b772 01 00 00		 ld bc, FORTH_FALSE 
b775 e1			  pop hl    ; u1 
b776 d1			  pop de    ; u2 
b777 ed 52		  sbc hl,de 
b779 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b77b			 
b77b 01 01 00		 ld bc, FORTH_TRUE 
b77e			.gtcont:  
b77e c5					push bc 
b77f e1					pop hl 
b780			 
b780					if DEBUG_FORTH_WORDS 
b780						DMARK "GT1" 
b780 f5				push af  
b781 3a 95 b7			ld a, (.dmark)  
b784 32 6b ee			ld (debug_mark),a  
b787 3a 96 b7			ld a, (.dmark+1)  
b78a 32 6c ee			ld (debug_mark+1),a  
b78d 3a 97 b7			ld a, (.dmark+2)  
b790 32 6d ee			ld (debug_mark+2),a  
b793 18 03			jr .pastdmark  
b795 ..			.dmark: db "GT1"  
b798 f1			.pastdmark: pop af  
b799			endm  
# End of macro DMARK
b799						CALLMONITOR 
b799 cd 6f ee			call debug_vector  
b79c				endm  
# End of macro CALLMONITOR
b79c					endif 
b79c cd 5f 9d				call forth_push_numhl 
b79f			 
b79f					NEXTW 
b79f c3 0c a1			jp macro_next 
b7a2				endm 
# End of macro NEXTW
b7a2			.EQUAL: 
b7a2				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b7a2 31				db WORD_SYS_CORE+29             
b7a3 0d b8			dw .ENDLOGIC            
b7a5 02				db 1 + 1 
b7a6 .. 00			db "=",0              
b7a8				endm 
# End of macro CWHEAD
b7a8			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b7a8				; TODO add floating point number detection 
b7a8					if DEBUG_FORTH_WORDS_KEY 
b7a8						DMARK "EQ." 
b7a8 f5				push af  
b7a9 3a bd b7			ld a, (.dmark)  
b7ac 32 6b ee			ld (debug_mark),a  
b7af 3a be b7			ld a, (.dmark+1)  
b7b2 32 6c ee			ld (debug_mark+1),a  
b7b5 3a bf b7			ld a, (.dmark+2)  
b7b8 32 6d ee			ld (debug_mark+2),a  
b7bb 18 03			jr .pastdmark  
b7bd ..			.dmark: db "EQ."  
b7c0 f1			.pastdmark: pop af  
b7c1			endm  
# End of macro DMARK
b7c1						CALLMONITOR 
b7c1 cd 6f ee			call debug_vector  
b7c4				endm  
# End of macro CALLMONITOR
b7c4					endif 
b7c4					FORTH_DSP 
b7c4 cd 1c 9f			call macro_forth_dsp 
b7c7				endm 
# End of macro FORTH_DSP
b7c7					;v5 FORTH_DSP_VALUE 
b7c7 7e					ld a,(hl)	; get type of value on TOS 
b7c8 fe 02				cp DS_TYPE_INUM  
b7ca 28 00				jr z, .eq_inum 
b7cc			 
b7cc				if FORTH_ENABLE_FLOATMATH 
b7cc					jr .eq_done 
b7cc			 
b7cc				endif 
b7cc					 
b7cc			 
b7cc			.eq_inum: 
b7cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7cc cd 56 9f			call macro_dsp_valuehl 
b7cf				endm 
# End of macro FORTH_DSP_VALUEHL
b7cf			 
b7cf e5					push hl 
b7d0			 
b7d0					; destroy value TOS 
b7d0			 
b7d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7d0 cd 0e a0			call macro_forth_dsp_pop 
b7d3				endm 
# End of macro FORTH_DSP_POP
b7d3			 
b7d3			 
b7d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7d3 cd 56 9f			call macro_dsp_valuehl 
b7d6				endm 
# End of macro FORTH_DSP_VALUEHL
b7d6			 
b7d6					; one value on hl get other one back 
b7d6			 
b7d6 e5					push hl 
b7d7			 
b7d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7d7 cd 0e a0			call macro_forth_dsp_pop 
b7da				endm 
# End of macro FORTH_DSP_POP
b7da			 
b7da 0e 00				ld c, FORTH_FALSE 
b7dc			 
b7dc e1					pop hl 
b7dd d1					pop de 
b7de			 
b7de 7b					ld a, e 
b7df bd					cp l 
b7e0			 
b7e0 20 06				jr nz, .eq_done 
b7e2			 
b7e2 7a					ld a, d 
b7e3 bc					cp h 
b7e4			 
b7e4 20 02				jr nz, .eq_done 
b7e6			 
b7e6 0e 01				ld c, FORTH_TRUE 
b7e8					 
b7e8			 
b7e8			 
b7e8			.eq_done: 
b7e8			 
b7e8					; TODO push value back onto stack for another op etc 
b7e8			 
b7e8 26 00				ld h, 0 
b7ea 69					ld l, c 
b7eb					if DEBUG_FORTH_WORDS 
b7eb						DMARK "EQ1" 
b7eb f5				push af  
b7ec 3a 00 b8			ld a, (.dmark)  
b7ef 32 6b ee			ld (debug_mark),a  
b7f2 3a 01 b8			ld a, (.dmark+1)  
b7f5 32 6c ee			ld (debug_mark+1),a  
b7f8 3a 02 b8			ld a, (.dmark+2)  
b7fb 32 6d ee			ld (debug_mark+2),a  
b7fe 18 03			jr .pastdmark  
b800 ..			.dmark: db "EQ1"  
b803 f1			.pastdmark: pop af  
b804			endm  
# End of macro DMARK
b804						CALLMONITOR 
b804 cd 6f ee			call debug_vector  
b807				endm  
# End of macro CALLMONITOR
b807					endif 
b807 cd 5f 9d				call forth_push_numhl 
b80a			 
b80a					NEXTW 
b80a c3 0c a1			jp macro_next 
b80d				endm 
# End of macro NEXTW
b80d			 
b80d			 
b80d			.ENDLOGIC: 
b80d			; eof 
b80d			 
b80d			 
# End of file forth_words_logic.asm
b80d			include "forth_words_maths.asm" 
b80d			 
b80d			; | ## Maths Words 
b80d			 
b80d			.PLUS:	 
b80d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b80d 15				db WORD_SYS_CORE+1             
b80e 6b b8			dw .NEG            
b810 02				db 1 + 1 
b811 .. 00			db "+",0              
b813				endm 
# End of macro CWHEAD
b813			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b813					if DEBUG_FORTH_WORDS_KEY 
b813						DMARK "PLU" 
b813 f5				push af  
b814 3a 28 b8			ld a, (.dmark)  
b817 32 6b ee			ld (debug_mark),a  
b81a 3a 29 b8			ld a, (.dmark+1)  
b81d 32 6c ee			ld (debug_mark+1),a  
b820 3a 2a b8			ld a, (.dmark+2)  
b823 32 6d ee			ld (debug_mark+2),a  
b826 18 03			jr .pastdmark  
b828 ..			.dmark: db "PLU"  
b82b f1			.pastdmark: pop af  
b82c			endm  
# End of macro DMARK
b82c						CALLMONITOR 
b82c cd 6f ee			call debug_vector  
b82f				endm  
# End of macro CALLMONITOR
b82f					endif 
b82f					; add top two values and push back result 
b82f			 
b82f					;for v5 FORTH_DSP_VALUE 
b82f					FORTH_DSP 
b82f cd 1c 9f			call macro_forth_dsp 
b832				endm 
# End of macro FORTH_DSP
b832 7e					ld a,(hl)	; get type of value on TOS 
b833 fe 02				cp DS_TYPE_INUM  
b835 28 03				jr z, .dot_inum 
b837			 
b837					NEXTW 
b837 c3 0c a1			jp macro_next 
b83a				endm 
# End of macro NEXTW
b83a			 
b83a			; float maths 
b83a			 
b83a				if FORTH_ENABLE_FLOATMATH 
b83a						inc hl      ; now at start of numeric as string 
b83a			 
b83a					if DEBUG_FORTH_MATHS 
b83a						DMARK "ADD" 
b83a				CALLMONITOR 
b83a					endif 
b83a			 
b83a					;ld ix, hl 
b83a					call CON 
b83a			 
b83a			 
b83a					push hl 
b83a					 
b83a					 
b83a			 
b83a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b83a			 
b83a					; get next number 
b83a			 
b83a						FORTH_DSP_VALUE 
b83a			 
b83a						inc hl      ; now at start of numeric as string 
b83a			 
b83a					;ld ix, hl 
b83a					call CON 
b83a			 
b83a					push hl 
b83a			 
b83a			 
b83a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b83a			 
b83a						; TODO do add 
b83a			 
b83a						call IADD 
b83a			 
b83a						; TODO get result back as ascii 
b83a			 
b83a						; TODO push result  
b83a			 
b83a			 
b83a			 
b83a						jr .dot_done 
b83a				endif 
b83a			 
b83a			.dot_inum: 
b83a			 
b83a			 
b83a					if DEBUG_FORTH_DOT 
b83a						DMARK "+IT" 
b83a f5				push af  
b83b 3a 4f b8			ld a, (.dmark)  
b83e 32 6b ee			ld (debug_mark),a  
b841 3a 50 b8			ld a, (.dmark+1)  
b844 32 6c ee			ld (debug_mark+1),a  
b847 3a 51 b8			ld a, (.dmark+2)  
b84a 32 6d ee			ld (debug_mark+2),a  
b84d 18 03			jr .pastdmark  
b84f ..			.dmark: db "+IT"  
b852 f1			.pastdmark: pop af  
b853			endm  
# End of macro DMARK
b853				CALLMONITOR 
b853 cd 6f ee			call debug_vector  
b856				endm  
# End of macro CALLMONITOR
b856					endif 
b856			 
b856					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b856 cd 56 9f			call macro_dsp_valuehl 
b859				endm 
# End of macro FORTH_DSP_VALUEHL
b859			 
b859				; TODO add floating point number detection 
b859			 
b859 e5					push hl 
b85a			 
b85a					; destroy value TOS 
b85a			 
b85a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b85a cd 0e a0			call macro_forth_dsp_pop 
b85d				endm 
# End of macro FORTH_DSP_POP
b85d			 
b85d			 
b85d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b85d cd 56 9f			call macro_dsp_valuehl 
b860				endm 
# End of macro FORTH_DSP_VALUEHL
b860			 
b860					; one value on hl get other one back 
b860			 
b860 d1					pop de 
b861			 
b861					; do the add 
b861			 
b861 19					add hl,de 
b862			 
b862					; save it 
b862			 
b862			;		push hl	 
b862			 
b862					; 
b862			 
b862					; destroy value TOS 
b862			 
b862					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b862 cd 0e a0			call macro_forth_dsp_pop 
b865				endm 
# End of macro FORTH_DSP_POP
b865			 
b865					; TODO push value back onto stack for another op etc 
b865			 
b865			;		pop hl 
b865			 
b865			.dot_done: 
b865 cd 5f 9d				call forth_push_numhl 
b868			 
b868					NEXTW 
b868 c3 0c a1			jp macro_next 
b86b				endm 
# End of macro NEXTW
b86b			.NEG: 
b86b			 
b86b				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b86b 17				db WORD_SYS_CORE+3             
b86c ae b8			dw .DIV            
b86e 02				db 1 + 1 
b86f .. 00			db "-",0              
b871				endm 
# End of macro CWHEAD
b871			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b871					if DEBUG_FORTH_WORDS_KEY 
b871						DMARK "SUB" 
b871 f5				push af  
b872 3a 86 b8			ld a, (.dmark)  
b875 32 6b ee			ld (debug_mark),a  
b878 3a 87 b8			ld a, (.dmark+1)  
b87b 32 6c ee			ld (debug_mark+1),a  
b87e 3a 88 b8			ld a, (.dmark+2)  
b881 32 6d ee			ld (debug_mark+2),a  
b884 18 03			jr .pastdmark  
b886 ..			.dmark: db "SUB"  
b889 f1			.pastdmark: pop af  
b88a			endm  
# End of macro DMARK
b88a						CALLMONITOR 
b88a cd 6f ee			call debug_vector  
b88d				endm  
# End of macro CALLMONITOR
b88d					endif 
b88d			 
b88d			 
b88d				; TODO add floating point number detection 
b88d					; v5 FORTH_DSP_VALUE 
b88d					FORTH_DSP 
b88d cd 1c 9f			call macro_forth_dsp 
b890				endm 
# End of macro FORTH_DSP
b890 7e					ld a,(hl)	; get type of value on TOS 
b891 fe 02				cp DS_TYPE_INUM  
b893 28 03				jr z, .neg_inum 
b895			 
b895					NEXTW 
b895 c3 0c a1			jp macro_next 
b898				endm 
# End of macro NEXTW
b898			 
b898			; float maths 
b898			 
b898				if FORTH_ENABLE_FLOATMATH 
b898					jr .neg_done 
b898			 
b898				endif 
b898					 
b898			 
b898			.neg_inum: 
b898					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b898 cd 56 9f			call macro_dsp_valuehl 
b89b				endm 
# End of macro FORTH_DSP_VALUEHL
b89b			 
b89b e5					push hl 
b89c			 
b89c					; destroy value TOS 
b89c			 
b89c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b89c cd 0e a0			call macro_forth_dsp_pop 
b89f				endm 
# End of macro FORTH_DSP_POP
b89f			 
b89f			 
b89f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b89f cd 56 9f			call macro_dsp_valuehl 
b8a2				endm 
# End of macro FORTH_DSP_VALUEHL
b8a2			 
b8a2					; one value on hl get other one back 
b8a2			 
b8a2 d1					pop de 
b8a3			 
b8a3					; do the sub 
b8a3			;		ex de, hl 
b8a3			 
b8a3 ed 52				sbc hl,de 
b8a5			 
b8a5					; save it 
b8a5			 
b8a5			;		push hl	 
b8a5			 
b8a5					; 
b8a5			 
b8a5					; destroy value TOS 
b8a5			 
b8a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8a5 cd 0e a0			call macro_forth_dsp_pop 
b8a8				endm 
# End of macro FORTH_DSP_POP
b8a8			 
b8a8					; TODO push value back onto stack for another op etc 
b8a8			 
b8a8			;		pop hl 
b8a8			 
b8a8 cd 5f 9d				call forth_push_numhl 
b8ab			.neg_done: 
b8ab			 
b8ab					NEXTW 
b8ab c3 0c a1			jp macro_next 
b8ae				endm 
# End of macro NEXTW
b8ae			.DIV: 
b8ae				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b8ae 18				db WORD_SYS_CORE+4             
b8af fb b8			dw .MUL            
b8b1 02				db 1 + 1 
b8b2 .. 00			db "/",0              
b8b4				endm 
# End of macro CWHEAD
b8b4			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b8b4					if DEBUG_FORTH_WORDS_KEY 
b8b4						DMARK "DIV" 
b8b4 f5				push af  
b8b5 3a c9 b8			ld a, (.dmark)  
b8b8 32 6b ee			ld (debug_mark),a  
b8bb 3a ca b8			ld a, (.dmark+1)  
b8be 32 6c ee			ld (debug_mark+1),a  
b8c1 3a cb b8			ld a, (.dmark+2)  
b8c4 32 6d ee			ld (debug_mark+2),a  
b8c7 18 03			jr .pastdmark  
b8c9 ..			.dmark: db "DIV"  
b8cc f1			.pastdmark: pop af  
b8cd			endm  
# End of macro DMARK
b8cd						CALLMONITOR 
b8cd cd 6f ee			call debug_vector  
b8d0				endm  
# End of macro CALLMONITOR
b8d0					endif 
b8d0				; TODO add floating point number detection 
b8d0					; v5 FORTH_DSP_VALUE 
b8d0					FORTH_DSP 
b8d0 cd 1c 9f			call macro_forth_dsp 
b8d3				endm 
# End of macro FORTH_DSP
b8d3 7e					ld a,(hl)	; get type of value on TOS 
b8d4 fe 02				cp DS_TYPE_INUM  
b8d6 28 03				jr z, .div_inum 
b8d8			 
b8d8				if FORTH_ENABLE_FLOATMATH 
b8d8					jr .div_done 
b8d8			 
b8d8				endif 
b8d8					NEXTW 
b8d8 c3 0c a1			jp macro_next 
b8db				endm 
# End of macro NEXTW
b8db			.div_inum: 
b8db			 
b8db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8db cd 56 9f			call macro_dsp_valuehl 
b8de				endm 
# End of macro FORTH_DSP_VALUEHL
b8de			 
b8de e5					push hl    ; to go to bc 
b8df			 
b8df					; destroy value TOS 
b8df			 
b8df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8df cd 0e a0			call macro_forth_dsp_pop 
b8e2				endm 
# End of macro FORTH_DSP_POP
b8e2			 
b8e2			 
b8e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8e2 cd 56 9f			call macro_dsp_valuehl 
b8e5				endm 
# End of macro FORTH_DSP_VALUEHL
b8e5			 
b8e5					; hl to go to de 
b8e5			 
b8e5 e5					push hl 
b8e6			 
b8e6 c1					pop bc 
b8e7 d1					pop de		 
b8e8			 
b8e8			 
b8e8					if DEBUG_FORTH_MATHS 
b8e8						DMARK "DIV" 
b8e8				CALLMONITOR 
b8e8					endif 
b8e8					; one value on hl but move to a get other one back 
b8e8			 
b8e8			        
b8e8 cd 38 8c			call Div16 
b8eb			 
b8eb			;	push af	 
b8eb e5				push hl 
b8ec c5				push bc 
b8ed			 
b8ed					if DEBUG_FORTH_MATHS 
b8ed						DMARK "DI1" 
b8ed				CALLMONITOR 
b8ed					endif 
b8ed			 
b8ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8ed cd 0e a0			call macro_forth_dsp_pop 
b8f0				endm 
# End of macro FORTH_DSP_POP
b8f0			 
b8f0			 
b8f0			 
b8f0 e1					pop hl    ; result 
b8f1			 
b8f1 cd 5f 9d				call forth_push_numhl 
b8f4			 
b8f4 e1					pop hl    ; reminder 
b8f5			;		ld h,0 
b8f5			;		ld l,d 
b8f5			 
b8f5 cd 5f 9d				call forth_push_numhl 
b8f8			.div_done: 
b8f8					NEXTW 
b8f8 c3 0c a1			jp macro_next 
b8fb				endm 
# End of macro NEXTW
b8fb			.MUL: 
b8fb				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b8fb 19				db WORD_SYS_CORE+5             
b8fc 40 b9			dw .MIN            
b8fe 02				db 1 + 1 
b8ff .. 00			db "*",0              
b901				endm 
# End of macro CWHEAD
b901			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b901				; TODO add floating point number detection 
b901					if DEBUG_FORTH_WORDS_KEY 
b901						DMARK "MUL" 
b901 f5				push af  
b902 3a 16 b9			ld a, (.dmark)  
b905 32 6b ee			ld (debug_mark),a  
b908 3a 17 b9			ld a, (.dmark+1)  
b90b 32 6c ee			ld (debug_mark+1),a  
b90e 3a 18 b9			ld a, (.dmark+2)  
b911 32 6d ee			ld (debug_mark+2),a  
b914 18 03			jr .pastdmark  
b916 ..			.dmark: db "MUL"  
b919 f1			.pastdmark: pop af  
b91a			endm  
# End of macro DMARK
b91a						CALLMONITOR 
b91a cd 6f ee			call debug_vector  
b91d				endm  
# End of macro CALLMONITOR
b91d					endif 
b91d					FORTH_DSP 
b91d cd 1c 9f			call macro_forth_dsp 
b920				endm 
# End of macro FORTH_DSP
b920					; v5 FORTH_DSP_VALUE 
b920 7e					ld a,(hl)	; get type of value on TOS 
b921 fe 02				cp DS_TYPE_INUM  
b923 28 03				jr z, .mul_inum 
b925			 
b925				if FORTH_ENABLE_FLOATMATH 
b925					jr .mul_done 
b925			 
b925				endif 
b925			 
b925					NEXTW 
b925 c3 0c a1			jp macro_next 
b928				endm 
# End of macro NEXTW
b928			.mul_inum:	 
b928			 
b928					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b928 cd 56 9f			call macro_dsp_valuehl 
b92b				endm 
# End of macro FORTH_DSP_VALUEHL
b92b			 
b92b e5					push hl 
b92c			 
b92c					; destroy value TOS 
b92c			 
b92c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b92c cd 0e a0			call macro_forth_dsp_pop 
b92f				endm 
# End of macro FORTH_DSP_POP
b92f			 
b92f			 
b92f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b92f cd 56 9f			call macro_dsp_valuehl 
b932				endm 
# End of macro FORTH_DSP_VALUEHL
b932			 
b932					; one value on hl but move to a get other one back 
b932			 
b932 7d					ld a, l 
b933			 
b933 d1					pop de 
b934			 
b934					; do the mull 
b934			;		ex de, hl 
b934			 
b934 cd 5e 8c				call Mult16 
b937					; save it 
b937			 
b937			;		push hl	 
b937			 
b937					; 
b937			 
b937					; destroy value TOS 
b937			 
b937					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b937 cd 0e a0			call macro_forth_dsp_pop 
b93a				endm 
# End of macro FORTH_DSP_POP
b93a			 
b93a					; TODO push value back onto stack for another op etc 
b93a			 
b93a			;		pop hl 
b93a			 
b93a cd 5f 9d				call forth_push_numhl 
b93d			 
b93d			.mul_done: 
b93d					NEXTW 
b93d c3 0c a1			jp macro_next 
b940				endm 
# End of macro NEXTW
b940			 
b940			 
b940			 
b940			 
b940			.MIN: 
b940				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b940 49				db WORD_SYS_CORE+53             
b941 c1 b9			dw .MAX            
b943 04				db 3 + 1 
b944 .. 00			db "MIN",0              
b948				endm 
# End of macro CWHEAD
b948			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b948					if DEBUG_FORTH_WORDS_KEY 
b948						DMARK "MIN" 
b948 f5				push af  
b949 3a 5d b9			ld a, (.dmark)  
b94c 32 6b ee			ld (debug_mark),a  
b94f 3a 5e b9			ld a, (.dmark+1)  
b952 32 6c ee			ld (debug_mark+1),a  
b955 3a 5f b9			ld a, (.dmark+2)  
b958 32 6d ee			ld (debug_mark+2),a  
b95b 18 03			jr .pastdmark  
b95d ..			.dmark: db "MIN"  
b960 f1			.pastdmark: pop af  
b961			endm  
# End of macro DMARK
b961						CALLMONITOR 
b961 cd 6f ee			call debug_vector  
b964				endm  
# End of macro CALLMONITOR
b964					endif 
b964					; get u2 
b964			 
b964					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b964 cd 56 9f			call macro_dsp_valuehl 
b967				endm 
# End of macro FORTH_DSP_VALUEHL
b967			 
b967 e5					push hl   ; u2 
b968			 
b968					; destroy value TOS 
b968			 
b968					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b968 cd 0e a0			call macro_forth_dsp_pop 
b96b				endm 
# End of macro FORTH_DSP_POP
b96b			 
b96b					; get u1 
b96b			 
b96b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b96b cd 56 9f			call macro_dsp_valuehl 
b96e				endm 
# End of macro FORTH_DSP_VALUEHL
b96e			 
b96e e5					push hl  ; u1 
b96f			 
b96f					; destroy value TOS 
b96f			 
b96f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b96f cd 0e a0			call macro_forth_dsp_pop 
b972				endm 
# End of macro FORTH_DSP_POP
b972			 
b972 b7			 or a      ;clear carry flag 
b973 e1			  pop hl    ; u1 
b974 d1			  pop de    ; u2 
b975 e5				push hl   ; saved in case hl is lowest 
b976 ed 52		  sbc hl,de 
b978 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b97a			 
b97a e1				pop hl 
b97b					if DEBUG_FORTH_WORDS 
b97b						DMARK "MIN" 
b97b f5				push af  
b97c 3a 90 b9			ld a, (.dmark)  
b97f 32 6b ee			ld (debug_mark),a  
b982 3a 91 b9			ld a, (.dmark+1)  
b985 32 6c ee			ld (debug_mark+1),a  
b988 3a 92 b9			ld a, (.dmark+2)  
b98b 32 6d ee			ld (debug_mark+2),a  
b98e 18 03			jr .pastdmark  
b990 ..			.dmark: db "MIN"  
b993 f1			.pastdmark: pop af  
b994			endm  
# End of macro DMARK
b994						CALLMONITOR 
b994 cd 6f ee			call debug_vector  
b997				endm  
# End of macro CALLMONITOR
b997					endif 
b997 cd 5f 9d				call forth_push_numhl 
b99a			 
b99a				       NEXTW 
b99a c3 0c a1			jp macro_next 
b99d				endm 
# End of macro NEXTW
b99d			 
b99d			.mincont:  
b99d c1				pop bc   ; tidy up 
b99e eb				ex de , hl  
b99f					if DEBUG_FORTH_WORDS 
b99f						DMARK "MI1" 
b99f f5				push af  
b9a0 3a b4 b9			ld a, (.dmark)  
b9a3 32 6b ee			ld (debug_mark),a  
b9a6 3a b5 b9			ld a, (.dmark+1)  
b9a9 32 6c ee			ld (debug_mark+1),a  
b9ac 3a b6 b9			ld a, (.dmark+2)  
b9af 32 6d ee			ld (debug_mark+2),a  
b9b2 18 03			jr .pastdmark  
b9b4 ..			.dmark: db "MI1"  
b9b7 f1			.pastdmark: pop af  
b9b8			endm  
# End of macro DMARK
b9b8						CALLMONITOR 
b9b8 cd 6f ee			call debug_vector  
b9bb				endm  
# End of macro CALLMONITOR
b9bb					endif 
b9bb cd 5f 9d				call forth_push_numhl 
b9be			 
b9be				       NEXTW 
b9be c3 0c a1			jp macro_next 
b9c1				endm 
# End of macro NEXTW
b9c1			.MAX: 
b9c1				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b9c1 4a				db WORD_SYS_CORE+54             
b9c2 42 ba			dw .RND16            
b9c4 04				db 3 + 1 
b9c5 .. 00			db "MAX",0              
b9c9				endm 
# End of macro CWHEAD
b9c9			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b9c9					if DEBUG_FORTH_WORDS_KEY 
b9c9						DMARK "MAX" 
b9c9 f5				push af  
b9ca 3a de b9			ld a, (.dmark)  
b9cd 32 6b ee			ld (debug_mark),a  
b9d0 3a df b9			ld a, (.dmark+1)  
b9d3 32 6c ee			ld (debug_mark+1),a  
b9d6 3a e0 b9			ld a, (.dmark+2)  
b9d9 32 6d ee			ld (debug_mark+2),a  
b9dc 18 03			jr .pastdmark  
b9de ..			.dmark: db "MAX"  
b9e1 f1			.pastdmark: pop af  
b9e2			endm  
# End of macro DMARK
b9e2						CALLMONITOR 
b9e2 cd 6f ee			call debug_vector  
b9e5				endm  
# End of macro CALLMONITOR
b9e5					endif 
b9e5					; get u2 
b9e5			 
b9e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9e5 cd 56 9f			call macro_dsp_valuehl 
b9e8				endm 
# End of macro FORTH_DSP_VALUEHL
b9e8			 
b9e8 e5					push hl   ; u2 
b9e9			 
b9e9					; destroy value TOS 
b9e9			 
b9e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9e9 cd 0e a0			call macro_forth_dsp_pop 
b9ec				endm 
# End of macro FORTH_DSP_POP
b9ec			 
b9ec					; get u1 
b9ec			 
b9ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9ec cd 56 9f			call macro_dsp_valuehl 
b9ef				endm 
# End of macro FORTH_DSP_VALUEHL
b9ef			 
b9ef e5					push hl  ; u1 
b9f0			 
b9f0					; destroy value TOS 
b9f0			 
b9f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9f0 cd 0e a0			call macro_forth_dsp_pop 
b9f3				endm 
# End of macro FORTH_DSP_POP
b9f3			 
b9f3 b7			 or a      ;clear carry flag 
b9f4 e1			  pop hl    ; u1 
b9f5 d1			  pop de    ; u2 
b9f6 e5				push hl   ; saved in case hl is lowest 
b9f7 ed 52		  sbc hl,de 
b9f9 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b9fb			 
b9fb e1				pop hl 
b9fc					if DEBUG_FORTH_WORDS 
b9fc						DMARK "MAX" 
b9fc f5				push af  
b9fd 3a 11 ba			ld a, (.dmark)  
ba00 32 6b ee			ld (debug_mark),a  
ba03 3a 12 ba			ld a, (.dmark+1)  
ba06 32 6c ee			ld (debug_mark+1),a  
ba09 3a 13 ba			ld a, (.dmark+2)  
ba0c 32 6d ee			ld (debug_mark+2),a  
ba0f 18 03			jr .pastdmark  
ba11 ..			.dmark: db "MAX"  
ba14 f1			.pastdmark: pop af  
ba15			endm  
# End of macro DMARK
ba15						CALLMONITOR 
ba15 cd 6f ee			call debug_vector  
ba18				endm  
# End of macro CALLMONITOR
ba18					endif 
ba18 cd 5f 9d				call forth_push_numhl 
ba1b			 
ba1b				       NEXTW 
ba1b c3 0c a1			jp macro_next 
ba1e				endm 
# End of macro NEXTW
ba1e			 
ba1e			.maxcont:  
ba1e c1				pop bc   ; tidy up 
ba1f eb				ex de , hl  
ba20					if DEBUG_FORTH_WORDS 
ba20						DMARK "MA1" 
ba20 f5				push af  
ba21 3a 35 ba			ld a, (.dmark)  
ba24 32 6b ee			ld (debug_mark),a  
ba27 3a 36 ba			ld a, (.dmark+1)  
ba2a 32 6c ee			ld (debug_mark+1),a  
ba2d 3a 37 ba			ld a, (.dmark+2)  
ba30 32 6d ee			ld (debug_mark+2),a  
ba33 18 03			jr .pastdmark  
ba35 ..			.dmark: db "MA1"  
ba38 f1			.pastdmark: pop af  
ba39			endm  
# End of macro DMARK
ba39						CALLMONITOR 
ba39 cd 6f ee			call debug_vector  
ba3c				endm  
# End of macro CALLMONITOR
ba3c					endif 
ba3c cd 5f 9d				call forth_push_numhl 
ba3f				       NEXTW 
ba3f c3 0c a1			jp macro_next 
ba42				endm 
# End of macro NEXTW
ba42			 
ba42			.RND16: 
ba42				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
ba42 4e				db WORD_SYS_CORE+58             
ba43 71 ba			dw .RND8            
ba45 06				db 5 + 1 
ba46 .. 00			db "RND16",0              
ba4c				endm 
# End of macro CWHEAD
ba4c			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
ba4c					if DEBUG_FORTH_WORDS_KEY 
ba4c						DMARK "R16" 
ba4c f5				push af  
ba4d 3a 61 ba			ld a, (.dmark)  
ba50 32 6b ee			ld (debug_mark),a  
ba53 3a 62 ba			ld a, (.dmark+1)  
ba56 32 6c ee			ld (debug_mark+1),a  
ba59 3a 63 ba			ld a, (.dmark+2)  
ba5c 32 6d ee			ld (debug_mark+2),a  
ba5f 18 03			jr .pastdmark  
ba61 ..			.dmark: db "R16"  
ba64 f1			.pastdmark: pop af  
ba65			endm  
# End of macro DMARK
ba65						CALLMONITOR 
ba65 cd 6f ee			call debug_vector  
ba68				endm  
# End of macro CALLMONITOR
ba68					endif 
ba68 cd 02 8c				call prng16  
ba6b cd 5f 9d				call forth_push_numhl 
ba6e				       NEXTW 
ba6e c3 0c a1			jp macro_next 
ba71				endm 
# End of macro NEXTW
ba71			.RND8: 
ba71				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
ba71 60				db WORD_SYS_CORE+76             
ba72 a6 ba			dw .RND            
ba74 05				db 4 + 1 
ba75 .. 00			db "RND8",0              
ba7a				endm 
# End of macro CWHEAD
ba7a			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
ba7a					if DEBUG_FORTH_WORDS_KEY 
ba7a						DMARK "RN8" 
ba7a f5				push af  
ba7b 3a 8f ba			ld a, (.dmark)  
ba7e 32 6b ee			ld (debug_mark),a  
ba81 3a 90 ba			ld a, (.dmark+1)  
ba84 32 6c ee			ld (debug_mark+1),a  
ba87 3a 91 ba			ld a, (.dmark+2)  
ba8a 32 6d ee			ld (debug_mark+2),a  
ba8d 18 03			jr .pastdmark  
ba8f ..			.dmark: db "RN8"  
ba92 f1			.pastdmark: pop af  
ba93			endm  
# End of macro DMARK
ba93						CALLMONITOR 
ba93 cd 6f ee			call debug_vector  
ba96				endm  
# End of macro CALLMONITOR
ba96					endif 
ba96 2a a9 eb				ld hl,(xrandc) 
ba99 23					inc hl 
ba9a cd 1c 8c				call xrnd 
ba9d 6f					ld l,a	 
ba9e 26 00				ld h,0 
baa0 cd 5f 9d				call forth_push_numhl 
baa3				       NEXTW 
baa3 c3 0c a1			jp macro_next 
baa6				endm 
# End of macro NEXTW
baa6			.RND: 
baa6				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
baa6 60				db WORD_SYS_CORE+76             
baa7 ac bb			dw .ENDMATHS            
baa9 04				db 3 + 1 
baaa .. 00			db "RND",0              
baae				endm 
# End of macro CWHEAD
baae			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
baae			 
baae					if DEBUG_FORTH_WORDS_KEY 
baae						DMARK "RND" 
baae f5				push af  
baaf 3a c3 ba			ld a, (.dmark)  
bab2 32 6b ee			ld (debug_mark),a  
bab5 3a c4 ba			ld a, (.dmark+1)  
bab8 32 6c ee			ld (debug_mark+1),a  
babb 3a c5 ba			ld a, (.dmark+2)  
babe 32 6d ee			ld (debug_mark+2),a  
bac1 18 03			jr .pastdmark  
bac3 ..			.dmark: db "RND"  
bac6 f1			.pastdmark: pop af  
bac7			endm  
# End of macro DMARK
bac7						CALLMONITOR 
bac7 cd 6f ee			call debug_vector  
baca				endm  
# End of macro CALLMONITOR
baca					endif 
baca					 
baca					FORTH_DSP_VALUEHL    ; upper range 
baca cd 56 9f			call macro_dsp_valuehl 
bacd				endm 
# End of macro FORTH_DSP_VALUEHL
bacd			 
bacd 22 ad eb				ld (LFSRSeed), hl	 
bad0			 
bad0					if DEBUG_FORTH_WORDS 
bad0						DMARK "RN1" 
bad0 f5				push af  
bad1 3a e5 ba			ld a, (.dmark)  
bad4 32 6b ee			ld (debug_mark),a  
bad7 3a e6 ba			ld a, (.dmark+1)  
bada 32 6c ee			ld (debug_mark+1),a  
badd 3a e7 ba			ld a, (.dmark+2)  
bae0 32 6d ee			ld (debug_mark+2),a  
bae3 18 03			jr .pastdmark  
bae5 ..			.dmark: db "RN1"  
bae8 f1			.pastdmark: pop af  
bae9			endm  
# End of macro DMARK
bae9						CALLMONITOR 
bae9 cd 6f ee			call debug_vector  
baec				endm  
# End of macro CALLMONITOR
baec					endif 
baec					FORTH_DSP_POP 
baec cd 0e a0			call macro_forth_dsp_pop 
baef				endm 
# End of macro FORTH_DSP_POP
baef			 
baef					FORTH_DSP_VALUEHL    ; low range 
baef cd 56 9f			call macro_dsp_valuehl 
baf2				endm 
# End of macro FORTH_DSP_VALUEHL
baf2			 
baf2					if DEBUG_FORTH_WORDS 
baf2						DMARK "RN2" 
baf2 f5				push af  
baf3 3a 07 bb			ld a, (.dmark)  
baf6 32 6b ee			ld (debug_mark),a  
baf9 3a 08 bb			ld a, (.dmark+1)  
bafc 32 6c ee			ld (debug_mark+1),a  
baff 3a 09 bb			ld a, (.dmark+2)  
bb02 32 6d ee			ld (debug_mark+2),a  
bb05 18 03			jr .pastdmark  
bb07 ..			.dmark: db "RN2"  
bb0a f1			.pastdmark: pop af  
bb0b			endm  
# End of macro DMARK
bb0b						CALLMONITOR 
bb0b cd 6f ee			call debug_vector  
bb0e				endm  
# End of macro CALLMONITOR
bb0e					endif 
bb0e 22 af eb				ld (LFSRSeed+2), hl 
bb11			 
bb11					FORTH_DSP_POP 
bb11 cd 0e a0			call macro_forth_dsp_pop 
bb14				endm 
# End of macro FORTH_DSP_POP
bb14			 
bb14 e5					push hl 
bb15			 
bb15 e1			.inrange:	pop hl 
bb16 cd 02 8c				call prng16  
bb19					if DEBUG_FORTH_WORDS 
bb19						DMARK "RN3" 
bb19 f5				push af  
bb1a 3a 2e bb			ld a, (.dmark)  
bb1d 32 6b ee			ld (debug_mark),a  
bb20 3a 2f bb			ld a, (.dmark+1)  
bb23 32 6c ee			ld (debug_mark+1),a  
bb26 3a 30 bb			ld a, (.dmark+2)  
bb29 32 6d ee			ld (debug_mark+2),a  
bb2c 18 03			jr .pastdmark  
bb2e ..			.dmark: db "RN3"  
bb31 f1			.pastdmark: pop af  
bb32			endm  
# End of macro DMARK
bb32						CALLMONITOR 
bb32 cd 6f ee			call debug_vector  
bb35				endm  
# End of macro CALLMONITOR
bb35					endif 
bb35					 
bb35					; if the range is 8bit knock out the high byte 
bb35			 
bb35 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
bb39			 
bb39 3e 00				ld a, 0 
bb3b ba					cp d  
bb3c 20 1e				jr nz, .hirange 
bb3e 26 00				ld h, 0   ; knock it down to 8bit 
bb40			 
bb40					if DEBUG_FORTH_WORDS 
bb40						DMARK "RNk" 
bb40 f5				push af  
bb41 3a 55 bb			ld a, (.dmark)  
bb44 32 6b ee			ld (debug_mark),a  
bb47 3a 56 bb			ld a, (.dmark+1)  
bb4a 32 6c ee			ld (debug_mark+1),a  
bb4d 3a 57 bb			ld a, (.dmark+2)  
bb50 32 6d ee			ld (debug_mark+2),a  
bb53 18 03			jr .pastdmark  
bb55 ..			.dmark: db "RNk"  
bb58 f1			.pastdmark: pop af  
bb59			endm  
# End of macro DMARK
bb59						CALLMONITOR 
bb59 cd 6f ee			call debug_vector  
bb5c				endm  
# End of macro CALLMONITOR
bb5c					endif 
bb5c			.hirange:   
bb5c e5					push hl  
bb5d b7					or a  
bb5e ed 52		                sbc hl, de 
bb60			 
bb60					;call cmp16 
bb60			 
bb60 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
bb62 e1					pop hl 
bb63 e5					push hl 
bb64			 
bb64					if DEBUG_FORTH_WORDS 
bb64						DMARK "RN4" 
bb64 f5				push af  
bb65 3a 79 bb			ld a, (.dmark)  
bb68 32 6b ee			ld (debug_mark),a  
bb6b 3a 7a bb			ld a, (.dmark+1)  
bb6e 32 6c ee			ld (debug_mark+1),a  
bb71 3a 7b bb			ld a, (.dmark+2)  
bb74 32 6d ee			ld (debug_mark+2),a  
bb77 18 03			jr .pastdmark  
bb79 ..			.dmark: db "RN4"  
bb7c f1			.pastdmark: pop af  
bb7d			endm  
# End of macro DMARK
bb7d						CALLMONITOR 
bb7d cd 6f ee			call debug_vector  
bb80				endm  
# End of macro CALLMONITOR
bb80					endif 
bb80 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
bb84					;call cmp16 
bb84				 
bb84 b7					or a  
bb85 ed 52		                sbc hl, de 
bb87 38 8c				jr c, .inrange 
bb89			 
bb89 e1					pop hl 
bb8a					 
bb8a					if DEBUG_FORTH_WORDS 
bb8a						DMARK "RNd" 
bb8a f5				push af  
bb8b 3a 9f bb			ld a, (.dmark)  
bb8e 32 6b ee			ld (debug_mark),a  
bb91 3a a0 bb			ld a, (.dmark+1)  
bb94 32 6c ee			ld (debug_mark+1),a  
bb97 3a a1 bb			ld a, (.dmark+2)  
bb9a 32 6d ee			ld (debug_mark+2),a  
bb9d 18 03			jr .pastdmark  
bb9f ..			.dmark: db "RNd"  
bba2 f1			.pastdmark: pop af  
bba3			endm  
# End of macro DMARK
bba3						CALLMONITOR 
bba3 cd 6f ee			call debug_vector  
bba6				endm  
# End of macro CALLMONITOR
bba6					endif 
bba6			 
bba6			 
bba6 cd 5f 9d				call forth_push_numhl 
bba9				       NEXTW 
bba9 c3 0c a1			jp macro_next 
bbac				endm 
# End of macro NEXTW
bbac			 
bbac			.ENDMATHS: 
bbac			 
bbac			; eof 
bbac			 
# End of file forth_words_maths.asm
bbac			include "forth_words_display.asm" 
bbac			 
bbac			; | ## Display Words 
bbac			 
bbac			.ACT: 
bbac			 
bbac				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
bbac 62				db WORD_SYS_CORE+78             
bbad f8 bb			dw .INFO            
bbaf 07				db 6 + 1 
bbb0 .. 00			db "ACTIVE",0              
bbb7				endm 
# End of macro CWHEAD
bbb7			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bbb7			;  
bbb7			; | | To display a pulsing activity indicator in a processing loop do this... 
bbb7			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bbb7			 
bbb7					if DEBUG_FORTH_WORDS_KEY 
bbb7						DMARK "ACT" 
bbb7 f5				push af  
bbb8 3a cc bb			ld a, (.dmark)  
bbbb 32 6b ee			ld (debug_mark),a  
bbbe 3a cd bb			ld a, (.dmark+1)  
bbc1 32 6c ee			ld (debug_mark+1),a  
bbc4 3a ce bb			ld a, (.dmark+2)  
bbc7 32 6d ee			ld (debug_mark+2),a  
bbca 18 03			jr .pastdmark  
bbcc ..			.dmark: db "ACT"  
bbcf f1			.pastdmark: pop af  
bbd0			endm  
# End of macro DMARK
bbd0						CALLMONITOR 
bbd0 cd 6f ee			call debug_vector  
bbd3				endm  
# End of macro CALLMONITOR
bbd3					endif 
bbd3 cd 05 8a				call active 
bbd6					if DEBUG_FORTH_WORDS 
bbd6						DMARK "ACp" 
bbd6 f5				push af  
bbd7 3a eb bb			ld a, (.dmark)  
bbda 32 6b ee			ld (debug_mark),a  
bbdd 3a ec bb			ld a, (.dmark+1)  
bbe0 32 6c ee			ld (debug_mark+1),a  
bbe3 3a ed bb			ld a, (.dmark+2)  
bbe6 32 6d ee			ld (debug_mark+2),a  
bbe9 18 03			jr .pastdmark  
bbeb ..			.dmark: db "ACp"  
bbee f1			.pastdmark: pop af  
bbef			endm  
# End of macro DMARK
bbef						CALLMONITOR 
bbef cd 6f ee			call debug_vector  
bbf2				endm  
# End of macro CALLMONITOR
bbf2					endif 
bbf2 cd cd 9d				call forth_push_str 
bbf5			 
bbf5					NEXTW 
bbf5 c3 0c a1			jp macro_next 
bbf8				endm 
# End of macro NEXTW
bbf8			.INFO: 
bbf8			 
bbf8				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bbf8 62				db WORD_SYS_CORE+78             
bbf9 15 bc			dw .ATP            
bbfb 05				db 4 + 1 
bbfc .. 00			db "INFO",0              
bc01				endm 
# End of macro CWHEAD
bc01			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bc01					FORTH_DSP_VALUEHL 
bc01 cd 56 9f			call macro_dsp_valuehl 
bc04				endm 
# End of macro FORTH_DSP_VALUEHL
bc04			 
bc04					FORTH_DSP_POP 
bc04 cd 0e a0			call macro_forth_dsp_pop 
bc07				endm 
# End of macro FORTH_DSP_POP
bc07			 
bc07 e5					push hl 
bc08			 
bc08					FORTH_DSP_VALUEHL 
bc08 cd 56 9f			call macro_dsp_valuehl 
bc0b				endm 
# End of macro FORTH_DSP_VALUEHL
bc0b			 
bc0b					FORTH_DSP_POP 
bc0b cd 0e a0			call macro_forth_dsp_pop 
bc0e				endm 
# End of macro FORTH_DSP_POP
bc0e			 
bc0e d1					pop de 
bc0f			 
bc0f cd 3f 8a				call info_panel 
bc12			 
bc12			 
bc12					NEXTW 
bc12 c3 0c a1			jp macro_next 
bc15				endm 
# End of macro NEXTW
bc15			.ATP: 
bc15				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bc15 62				db WORD_SYS_CORE+78             
bc16 8c bc			dw .FB            
bc18 04				db 3 + 1 
bc19 .. 00			db "AT?",0              
bc1d				endm 
# End of macro CWHEAD
bc1d			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bc1d					if DEBUG_FORTH_WORDS_KEY 
bc1d						DMARK "AT?" 
bc1d f5				push af  
bc1e 3a 32 bc			ld a, (.dmark)  
bc21 32 6b ee			ld (debug_mark),a  
bc24 3a 33 bc			ld a, (.dmark+1)  
bc27 32 6c ee			ld (debug_mark+1),a  
bc2a 3a 34 bc			ld a, (.dmark+2)  
bc2d 32 6d ee			ld (debug_mark+2),a  
bc30 18 03			jr .pastdmark  
bc32 ..			.dmark: db "AT?"  
bc35 f1			.pastdmark: pop af  
bc36			endm  
# End of macro DMARK
bc36						CALLMONITOR 
bc36 cd 6f ee			call debug_vector  
bc39				endm  
# End of macro CALLMONITOR
bc39					endif 
bc39 3a 5e ea				ld a, (f_cursor_ptr) 
bc3c			 
bc3c			if DEBUG_FORTH_WORDS 
bc3c				DMARK "AT?" 
bc3c f5				push af  
bc3d 3a 51 bc			ld a, (.dmark)  
bc40 32 6b ee			ld (debug_mark),a  
bc43 3a 52 bc			ld a, (.dmark+1)  
bc46 32 6c ee			ld (debug_mark+1),a  
bc49 3a 53 bc			ld a, (.dmark+2)  
bc4c 32 6d ee			ld (debug_mark+2),a  
bc4f 18 03			jr .pastdmark  
bc51 ..			.dmark: db "AT?"  
bc54 f1			.pastdmark: pop af  
bc55			endm  
# End of macro DMARK
bc55				CALLMONITOR 
bc55 cd 6f ee			call debug_vector  
bc58				endm  
# End of macro CALLMONITOR
bc58			endif	 
bc58					; count the number of rows 
bc58			 
bc58 06 00				ld b, 0 
bc5a 4f			.atpr:		ld c, a    ; save in case we go below zero 
bc5b d6 28				sub display_cols 
bc5d f2 63 bc				jp p, .atprunder 
bc60 04					inc b 
bc61 18 f7				jr .atpr 
bc63			.atprunder:	 
bc63			if DEBUG_FORTH_WORDS 
bc63				DMARK "A?2" 
bc63 f5				push af  
bc64 3a 78 bc			ld a, (.dmark)  
bc67 32 6b ee			ld (debug_mark),a  
bc6a 3a 79 bc			ld a, (.dmark+1)  
bc6d 32 6c ee			ld (debug_mark+1),a  
bc70 3a 7a bc			ld a, (.dmark+2)  
bc73 32 6d ee			ld (debug_mark+2),a  
bc76 18 03			jr .pastdmark  
bc78 ..			.dmark: db "A?2"  
bc7b f1			.pastdmark: pop af  
bc7c			endm  
# End of macro DMARK
bc7c				CALLMONITOR 
bc7c cd 6f ee			call debug_vector  
bc7f				endm  
# End of macro CALLMONITOR
bc7f			endif	 
bc7f 26 00				ld h, 0 
bc81 69					ld l, c 
bc82 cd 5f 9d				call forth_push_numhl 
bc85 68					ld l, b  
bc86 cd 5f 9d				call forth_push_numhl 
bc89			 
bc89			 
bc89				NEXTW 
bc89 c3 0c a1			jp macro_next 
bc8c				endm 
# End of macro NEXTW
bc8c			 
bc8c			.FB: 
bc8c				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bc8c 1b				db WORD_SYS_CORE+7             
bc8d da bc			dw .EMIT            
bc8f 03				db 2 + 1 
bc90 .. 00			db "FB",0              
bc93				endm 
# End of macro CWHEAD
bc93			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bc93			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bc93			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bc93			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bc93					if DEBUG_FORTH_WORDS_KEY 
bc93						DMARK "FB." 
bc93 f5				push af  
bc94 3a a8 bc			ld a, (.dmark)  
bc97 32 6b ee			ld (debug_mark),a  
bc9a 3a a9 bc			ld a, (.dmark+1)  
bc9d 32 6c ee			ld (debug_mark+1),a  
bca0 3a aa bc			ld a, (.dmark+2)  
bca3 32 6d ee			ld (debug_mark+2),a  
bca6 18 03			jr .pastdmark  
bca8 ..			.dmark: db "FB."  
bcab f1			.pastdmark: pop af  
bcac			endm  
# End of macro DMARK
bcac						CALLMONITOR 
bcac cd 6f ee			call debug_vector  
bcaf				endm  
# End of macro CALLMONITOR
bcaf					endif 
bcaf			 
bcaf					FORTH_DSP_VALUEHL 
bcaf cd 56 9f			call macro_dsp_valuehl 
bcb2				endm 
# End of macro FORTH_DSP_VALUEHL
bcb2			 
bcb2 7d					ld a, l 
bcb3 fe 01				cp 1 
bcb5 20 05				jr nz, .fbn1 
bcb7 21 10 ed				ld hl, display_fb1 
bcba 18 15				jr .fbset 
bcbc fe 02		.fbn1:		cp 2 
bcbe 20 05				jr nz, .fbn2 
bcc0 21 ce eb				ld hl, display_fb2 
bcc3 18 0c				jr .fbset 
bcc5 fe 03		.fbn2:		cp 3 
bcc7 20 05				jr nz, .fbn3 
bcc9 21 6f ec				ld hl, display_fb3 
bccc 18 03				jr .fbset 
bcce			.fbn3:		 ; if invalid number select first 
bcce 21 10 ed				ld hl, display_fb1 
bcd1 22 cc eb		.fbset:		ld (display_fb_active), hl 
bcd4			 
bcd4					FORTH_DSP_POP 
bcd4 cd 0e a0			call macro_forth_dsp_pop 
bcd7				endm 
# End of macro FORTH_DSP_POP
bcd7			 
bcd7					NEXTW 
bcd7 c3 0c a1			jp macro_next 
bcda				endm 
# End of macro NEXTW
bcda			 
bcda			 
bcda			.EMIT: 
bcda				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bcda 1b				db WORD_SYS_CORE+7             
bcdb 2b bd			dw .DOTH            
bcdd 05				db 4 + 1 
bcde .. 00			db "EMIT",0              
bce3				endm 
# End of macro CWHEAD
bce3			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bce3					; get value off TOS and display it 
bce3			 
bce3					if DEBUG_FORTH_WORDS_KEY 
bce3						DMARK "EMT" 
bce3 f5				push af  
bce4 3a f8 bc			ld a, (.dmark)  
bce7 32 6b ee			ld (debug_mark),a  
bcea 3a f9 bc			ld a, (.dmark+1)  
bced 32 6c ee			ld (debug_mark+1),a  
bcf0 3a fa bc			ld a, (.dmark+2)  
bcf3 32 6d ee			ld (debug_mark+2),a  
bcf6 18 03			jr .pastdmark  
bcf8 ..			.dmark: db "EMT"  
bcfb f1			.pastdmark: pop af  
bcfc			endm  
# End of macro DMARK
bcfc						CALLMONITOR 
bcfc cd 6f ee			call debug_vector  
bcff				endm  
# End of macro CALLMONITOR
bcff					endif 
bcff			 
bcff					FORTH_DSP_VALUEHL 
bcff cd 56 9f			call macro_dsp_valuehl 
bd02				endm 
# End of macro FORTH_DSP_VALUEHL
bd02			 
bd02 7d					ld a,l 
bd03			 
bd03					; TODO write to display 
bd03			 
bd03 32 bf e4				ld (os_input), a 
bd06 3e 00				ld a, 0 
bd08 32 c0 e4				ld (os_input+1), a 
bd0b					 
bd0b 3a 5e ea				ld a, (f_cursor_ptr) 
bd0e 11 bf e4				ld de, os_input 
bd11 cd c1 8a				call str_at_display 
bd14			 
bd14			 
bd14 3a 3c ea				ld a,(cli_autodisplay) 
bd17 fe 00				cp 0 
bd19 28 03				jr z, .enoupdate 
bd1b cd d1 8a						call update_display 
bd1e					.enoupdate: 
bd1e			 
bd1e 3a 5e ea				ld a, (f_cursor_ptr) 
bd21 3c					inc a 
bd22 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bd25			 
bd25			 
bd25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd25 cd 0e a0			call macro_forth_dsp_pop 
bd28				endm 
# End of macro FORTH_DSP_POP
bd28			  
bd28			 
bd28					NEXTW 
bd28 c3 0c a1			jp macro_next 
bd2b				endm 
# End of macro NEXTW
bd2b			.DOTH: 
bd2b				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bd2b 1c				db WORD_SYS_CORE+8             
bd2c 5b bd			dw .DOTF            
bd2e 03				db 2 + 1 
bd2f .. 00			db ".-",0              
bd32				endm 
# End of macro CWHEAD
bd32			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bd32					; get value off TOS and display it 
bd32					if DEBUG_FORTH_WORDS_KEY 
bd32						DMARK "DTD" 
bd32 f5				push af  
bd33 3a 47 bd			ld a, (.dmark)  
bd36 32 6b ee			ld (debug_mark),a  
bd39 3a 48 bd			ld a, (.dmark+1)  
bd3c 32 6c ee			ld (debug_mark+1),a  
bd3f 3a 49 bd			ld a, (.dmark+2)  
bd42 32 6d ee			ld (debug_mark+2),a  
bd45 18 03			jr .pastdmark  
bd47 ..			.dmark: db "DTD"  
bd4a f1			.pastdmark: pop af  
bd4b			endm  
# End of macro DMARK
bd4b						CALLMONITOR 
bd4b cd 6f ee			call debug_vector  
bd4e				endm  
# End of macro CALLMONITOR
bd4e					endif 
bd4e 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bd50 3e 00			ld a, 0 
bd52 32 3d ea			ld (cli_mvdot), a 
bd55 c3 b2 bd			jp .dotgo 
bd58				NEXTW 
bd58 c3 0c a1			jp macro_next 
bd5b				endm 
# End of macro NEXTW
bd5b			.DOTF: 
bd5b				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bd5b 1c				db WORD_SYS_CORE+8             
bd5c 89 bd			dw .DOT            
bd5e 03				db 2 + 1 
bd5f .. 00			db ".>",0              
bd62				endm 
# End of macro CWHEAD
bd62			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bd62					; get value off TOS and display it 
bd62			        ; TODO BUG adds extra spaces 
bd62			        ; TODO BUG handle numerics? 
bd62					if DEBUG_FORTH_WORDS_KEY 
bd62						DMARK "DTC" 
bd62 f5				push af  
bd63 3a 77 bd			ld a, (.dmark)  
bd66 32 6b ee			ld (debug_mark),a  
bd69 3a 78 bd			ld a, (.dmark+1)  
bd6c 32 6c ee			ld (debug_mark+1),a  
bd6f 3a 79 bd			ld a, (.dmark+2)  
bd72 32 6d ee			ld (debug_mark+2),a  
bd75 18 03			jr .pastdmark  
bd77 ..			.dmark: db "DTC"  
bd7a f1			.pastdmark: pop af  
bd7b			endm  
# End of macro DMARK
bd7b						CALLMONITOR 
bd7b cd 6f ee			call debug_vector  
bd7e				endm  
# End of macro CALLMONITOR
bd7e					endif 
bd7e 3e 01			ld a, 1 
bd80 32 3d ea			ld (cli_mvdot), a 
bd83 c3 b2 bd			jp .dotgo 
bd86				NEXTW 
bd86 c3 0c a1			jp macro_next 
bd89				endm 
# End of macro NEXTW
bd89			 
bd89			.DOT: 
bd89				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bd89 1c				db WORD_SYS_CORE+8             
bd8a 65 bf			dw .CLS            
bd8c 02				db 1 + 1 
bd8d .. 00			db ".",0              
bd8f				endm 
# End of macro CWHEAD
bd8f			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
bd8f					; get value off TOS and display it 
bd8f			 
bd8f					if DEBUG_FORTH_WORDS_KEY 
bd8f						DMARK "DOT" 
bd8f f5				push af  
bd90 3a a4 bd			ld a, (.dmark)  
bd93 32 6b ee			ld (debug_mark),a  
bd96 3a a5 bd			ld a, (.dmark+1)  
bd99 32 6c ee			ld (debug_mark+1),a  
bd9c 3a a6 bd			ld a, (.dmark+2)  
bd9f 32 6d ee			ld (debug_mark+2),a  
bda2 18 03			jr .pastdmark  
bda4 ..			.dmark: db "DOT"  
bda7 f1			.pastdmark: pop af  
bda8			endm  
# End of macro DMARK
bda8						CALLMONITOR 
bda8 cd 6f ee			call debug_vector  
bdab				endm  
# End of macro CALLMONITOR
bdab					endif 
bdab 3e 00			ld a, 0 
bdad 32 3d ea			ld (cli_mvdot), a 
bdb0 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bdb2				 
bdb2			 
bdb2			.dotgo: 
bdb2			 
bdb2			; move up type to on stack for parserv5 
bdb2					FORTH_DSP 
bdb2 cd 1c 9f			call macro_forth_dsp 
bdb5				endm 
# End of macro FORTH_DSP
bdb5				;FORTH_DSP_VALUE  
bdb5			 
bdb5			if DEBUG_FORTH_DOT 
bdb5				DMARK "DOT" 
bdb5 f5				push af  
bdb6 3a ca bd			ld a, (.dmark)  
bdb9 32 6b ee			ld (debug_mark),a  
bdbc 3a cb bd			ld a, (.dmark+1)  
bdbf 32 6c ee			ld (debug_mark+1),a  
bdc2 3a cc bd			ld a, (.dmark+2)  
bdc5 32 6d ee			ld (debug_mark+2),a  
bdc8 18 03			jr .pastdmark  
bdca ..			.dmark: db "DOT"  
bdcd f1			.pastdmark: pop af  
bdce			endm  
# End of macro DMARK
bdce				CALLMONITOR 
bdce cd 6f ee			call debug_vector  
bdd1				endm  
# End of macro CALLMONITOR
bdd1			endif	 
bdd1			;		.print: 
bdd1			 
bdd1 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bdd2 23				inc hl   ; position to the actual value 
bdd3 fe 01			cp DS_TYPE_STR 
bdd5 20 06			jr nz, .dotnum1  
bdd7			 
bdd7			; display string 
bdd7				FORTH_DSP_VALUE  
bdd7 cd 3f 9f			call macro_forth_dsp_value 
bdda				endm 
# End of macro FORTH_DSP_VALUE
bdda eb				ex de,hl 
bddb 18 49			jr .dotwrite 
bddd			 
bddd			.dotnum1: 
bddd fe 02			cp DS_TYPE_INUM 
bddf 20 44			jr nz, .dotflot 
bde1			 
bde1			 
bde1			; display number 
bde1			 
bde1			;	push hl 
bde1			;	call clear_display 
bde1			;	pop hl 
bde1			 
bde1 5e				ld e, (hl) 
bde2 23				inc hl 
bde3 56				ld d, (hl) 
bde4 21 c1 e2			ld hl, scratch 
bde7			if DEBUG_FORTH_DOT 
bde7				DMARK "DT1" 
bde7 f5				push af  
bde8 3a fc bd			ld a, (.dmark)  
bdeb 32 6b ee			ld (debug_mark),a  
bdee 3a fd bd			ld a, (.dmark+1)  
bdf1 32 6c ee			ld (debug_mark+1),a  
bdf4 3a fe bd			ld a, (.dmark+2)  
bdf7 32 6d ee			ld (debug_mark+2),a  
bdfa 18 03			jr .pastdmark  
bdfc ..			.dmark: db "DT1"  
bdff f1			.pastdmark: pop af  
be00			endm  
# End of macro DMARK
be00				CALLMONITOR 
be00 cd 6f ee			call debug_vector  
be03				endm  
# End of macro CALLMONITOR
be03			endif	 
be03			 
be03 cd 00 93			call uitoa_16 
be06 eb				ex de,hl 
be07			 
be07			if DEBUG_FORTH_DOT 
be07				DMARK "DT2" 
be07 f5				push af  
be08 3a 1c be			ld a, (.dmark)  
be0b 32 6b ee			ld (debug_mark),a  
be0e 3a 1d be			ld a, (.dmark+1)  
be11 32 6c ee			ld (debug_mark+1),a  
be14 3a 1e be			ld a, (.dmark+2)  
be17 32 6d ee			ld (debug_mark+2),a  
be1a 18 03			jr .pastdmark  
be1c ..			.dmark: db "DT2"  
be1f f1			.pastdmark: pop af  
be20			endm  
# End of macro DMARK
be20				CALLMONITOR 
be20 cd 6f ee			call debug_vector  
be23				endm  
# End of macro CALLMONITOR
be23			endif	 
be23			 
be23			;	ld de, os_word_scratch 
be23 18 01			jr .dotwrite 
be25			 
be25 00			.dotflot:   nop 
be26			; TODO print floating point number 
be26			 
be26			.dotwrite:		 
be26			 
be26					; if c is set then set all '-' to spaces 
be26					; need to also take into account .>  
be26			 
be26 3e 01				ld a, 1 
be28 b9					cp c 
be29 20 67				jr nz, .nodashswap 
be2b			 
be2b					; DE has the string to write, working with HL 
be2b			 
be2b 06 ff				ld b, 255 
be2d d5					push de 
be2e e1					pop hl 
be2f			 
be2f			if DEBUG_FORTH_DOT 
be2f				DMARK "DT-" 
be2f f5				push af  
be30 3a 44 be			ld a, (.dmark)  
be33 32 6b ee			ld (debug_mark),a  
be36 3a 45 be			ld a, (.dmark+1)  
be39 32 6c ee			ld (debug_mark+1),a  
be3c 3a 46 be			ld a, (.dmark+2)  
be3f 32 6d ee			ld (debug_mark+2),a  
be42 18 03			jr .pastdmark  
be44 ..			.dmark: db "DT-"  
be47 f1			.pastdmark: pop af  
be48			endm  
# End of macro DMARK
be48				CALLMONITOR 
be48 cd 6f ee			call debug_vector  
be4b				endm  
# End of macro CALLMONITOR
be4b			endif	 
be4b 7e			.dashscan:	ld a, (hl) 
be4c fe 00				cp 0 
be4e 28 42				jr z, .nodashswap 
be50 fe 2d				cp '-' 
be52 20 03				jr nz, .dashskip 
be54 3e 20				ld a, ' ' 
be56 77					ld (hl), a 
be57 23			.dashskip:	inc hl 
be58			if DEBUG_FORTH_DOT 
be58				DMARK "D-2" 
be58 f5				push af  
be59 3a 6d be			ld a, (.dmark)  
be5c 32 6b ee			ld (debug_mark),a  
be5f 3a 6e be			ld a, (.dmark+1)  
be62 32 6c ee			ld (debug_mark+1),a  
be65 3a 6f be			ld a, (.dmark+2)  
be68 32 6d ee			ld (debug_mark+2),a  
be6b 18 03			jr .pastdmark  
be6d ..			.dmark: db "D-2"  
be70 f1			.pastdmark: pop af  
be71			endm  
# End of macro DMARK
be71				CALLMONITOR 
be71 cd 6f ee			call debug_vector  
be74				endm  
# End of macro CALLMONITOR
be74			endif	 
be74 10 d5				djnz .dashscan 
be76			 
be76			if DEBUG_FORTH_DOT 
be76				DMARK "D-1" 
be76 f5				push af  
be77 3a 8b be			ld a, (.dmark)  
be7a 32 6b ee			ld (debug_mark),a  
be7d 3a 8c be			ld a, (.dmark+1)  
be80 32 6c ee			ld (debug_mark+1),a  
be83 3a 8d be			ld a, (.dmark+2)  
be86 32 6d ee			ld (debug_mark+2),a  
be89 18 03			jr .pastdmark  
be8b ..			.dmark: db "D-1"  
be8e f1			.pastdmark: pop af  
be8f			endm  
# End of macro DMARK
be8f				CALLMONITOR 
be8f cd 6f ee			call debug_vector  
be92				endm  
# End of macro CALLMONITOR
be92			endif	 
be92			 
be92			.nodashswap: 
be92			 
be92			if DEBUG_FORTH_DOT 
be92				DMARK "D-o" 
be92 f5				push af  
be93 3a a7 be			ld a, (.dmark)  
be96 32 6b ee			ld (debug_mark),a  
be99 3a a8 be			ld a, (.dmark+1)  
be9c 32 6c ee			ld (debug_mark+1),a  
be9f 3a a9 be			ld a, (.dmark+2)  
bea2 32 6d ee			ld (debug_mark+2),a  
bea5 18 03			jr .pastdmark  
bea7 ..			.dmark: db "D-o"  
beaa f1			.pastdmark: pop af  
beab			endm  
# End of macro DMARK
beab				CALLMONITOR 
beab cd 6f ee			call debug_vector  
beae				endm  
# End of macro CALLMONITOR
beae			endif	 
beae			 
beae d5					push de   ; save string start in case we need to advance print 
beaf			 
beaf 3a 5e ea				ld a, (f_cursor_ptr) 
beb2 cd c1 8a				call str_at_display 
beb5 3a 3c ea				ld a,(cli_autodisplay) 
beb8 fe 00				cp 0 
beba 28 03				jr z, .noupdate 
bebc cd d1 8a						call update_display 
bebf					.noupdate: 
bebf			 
bebf			 
bebf					; see if we need to advance the print position 
bebf			 
bebf e1					pop hl   ; get back string 
bec0			;		ex de,hl 
bec0			 
bec0 3a 3d ea				ld a, (cli_mvdot) 
bec3			if DEBUG_FORTH_DOT 
bec3			;		ld e,a 
bec3				DMARK "D>1" 
bec3 f5				push af  
bec4 3a d8 be			ld a, (.dmark)  
bec7 32 6b ee			ld (debug_mark),a  
beca 3a d9 be			ld a, (.dmark+1)  
becd 32 6c ee			ld (debug_mark+1),a  
bed0 3a da be			ld a, (.dmark+2)  
bed3 32 6d ee			ld (debug_mark+2),a  
bed6 18 03			jr .pastdmark  
bed8 ..			.dmark: db "D>1"  
bedb f1			.pastdmark: pop af  
bedc			endm  
# End of macro DMARK
bedc				CALLMONITOR 
bedc cd 6f ee			call debug_vector  
bedf				endm  
# End of macro CALLMONITOR
bedf			endif	 
bedf fe 00				cp 0 
bee1 28 44				jr z, .noadv 
bee3					; yes, lets advance the print position 
bee3 3e 00				ld a, 0 
bee5 cd 5c 93				call strlent 
bee8			if DEBUG_FORTH_DOT 
bee8				DMARK "D-?" 
bee8 f5				push af  
bee9 3a fd be			ld a, (.dmark)  
beec 32 6b ee			ld (debug_mark),a  
beef 3a fe be			ld a, (.dmark+1)  
bef2 32 6c ee			ld (debug_mark+1),a  
bef5 3a ff be			ld a, (.dmark+2)  
bef8 32 6d ee			ld (debug_mark+2),a  
befb 18 03			jr .pastdmark  
befd ..			.dmark: db "D-?"  
bf00 f1			.pastdmark: pop af  
bf01			endm  
# End of macro DMARK
bf01				CALLMONITOR 
bf01 cd 6f ee			call debug_vector  
bf04				endm  
# End of macro CALLMONITOR
bf04			endif	 
bf04 3a 5e ea				ld a, (f_cursor_ptr) 
bf07 85					add a,l 
bf08					;call addatohl 
bf08					;ld a, l 
bf08 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bf0b			 
bf0b			if DEBUG_FORTH_DOT 
bf0b				DMARK "D->" 
bf0b f5				push af  
bf0c 3a 20 bf			ld a, (.dmark)  
bf0f 32 6b ee			ld (debug_mark),a  
bf12 3a 21 bf			ld a, (.dmark+1)  
bf15 32 6c ee			ld (debug_mark+1),a  
bf18 3a 22 bf			ld a, (.dmark+2)  
bf1b 32 6d ee			ld (debug_mark+2),a  
bf1e 18 03			jr .pastdmark  
bf20 ..			.dmark: db "D->"  
bf23 f1			.pastdmark: pop af  
bf24			endm  
# End of macro DMARK
bf24				CALLMONITOR 
bf24 cd 6f ee			call debug_vector  
bf27				endm  
# End of macro CALLMONITOR
bf27			endif	 
bf27			 
bf27			.noadv:	 
bf27			 
bf27					if DEBUG_FORTH_DOT_WAIT 
bf27							call next_page_prompt 
bf27					endif	 
bf27			; TODO this pop off the stack causes a crash. i dont know why 
bf27			 
bf27			 
bf27			if DEBUG_FORTH_DOT 
bf27				DMARK "DTh" 
bf27 f5				push af  
bf28 3a 3c bf			ld a, (.dmark)  
bf2b 32 6b ee			ld (debug_mark),a  
bf2e 3a 3d bf			ld a, (.dmark+1)  
bf31 32 6c ee			ld (debug_mark+1),a  
bf34 3a 3e bf			ld a, (.dmark+2)  
bf37 32 6d ee			ld (debug_mark+2),a  
bf3a 18 03			jr .pastdmark  
bf3c ..			.dmark: db "DTh"  
bf3f f1			.pastdmark: pop af  
bf40			endm  
# End of macro DMARK
bf40				CALLMONITOR 
bf40 cd 6f ee			call debug_vector  
bf43				endm  
# End of macro CALLMONITOR
bf43			endif	 
bf43			 
bf43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf43 cd 0e a0			call macro_forth_dsp_pop 
bf46				endm 
# End of macro FORTH_DSP_POP
bf46			 
bf46			if DEBUG_FORTH_DOT 
bf46				DMARK "DTi" 
bf46 f5				push af  
bf47 3a 5b bf			ld a, (.dmark)  
bf4a 32 6b ee			ld (debug_mark),a  
bf4d 3a 5c bf			ld a, (.dmark+1)  
bf50 32 6c ee			ld (debug_mark+1),a  
bf53 3a 5d bf			ld a, (.dmark+2)  
bf56 32 6d ee			ld (debug_mark+2),a  
bf59 18 03			jr .pastdmark  
bf5b ..			.dmark: db "DTi"  
bf5e f1			.pastdmark: pop af  
bf5f			endm  
# End of macro DMARK
bf5f				CALLMONITOR 
bf5f cd 6f ee			call debug_vector  
bf62				endm  
# End of macro CALLMONITOR
bf62			endif	 
bf62			 
bf62			 
bf62					NEXTW 
bf62 c3 0c a1			jp macro_next 
bf65				endm 
# End of macro NEXTW
bf65			 
bf65			.CLS: 
bf65				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bf65 35				db WORD_SYS_CORE+33             
bf66 92 bf			dw .DRAW            
bf68 04				db 3 + 1 
bf69 .. 00			db "CLS",0              
bf6d				endm 
# End of macro CWHEAD
bf6d			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bf6d					if DEBUG_FORTH_WORDS_KEY 
bf6d						DMARK "CLS" 
bf6d f5				push af  
bf6e 3a 82 bf			ld a, (.dmark)  
bf71 32 6b ee			ld (debug_mark),a  
bf74 3a 83 bf			ld a, (.dmark+1)  
bf77 32 6c ee			ld (debug_mark+1),a  
bf7a 3a 84 bf			ld a, (.dmark+2)  
bf7d 32 6d ee			ld (debug_mark+2),a  
bf80 18 03			jr .pastdmark  
bf82 ..			.dmark: db "CLS"  
bf85 f1			.pastdmark: pop af  
bf86			endm  
# End of macro DMARK
bf86						CALLMONITOR 
bf86 cd 6f ee			call debug_vector  
bf89				endm  
# End of macro CALLMONITOR
bf89					endif 
bf89 cd ae 8a				call clear_display 
bf8c c3 a0 c0				jp .home		; and home cursor 
bf8f					NEXTW 
bf8f c3 0c a1			jp macro_next 
bf92				endm 
# End of macro NEXTW
bf92			 
bf92			.DRAW: 
bf92				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bf92 36				db WORD_SYS_CORE+34             
bf93 bd bf			dw .DUMP            
bf95 05				db 4 + 1 
bf96 .. 00			db "DRAW",0              
bf9b				endm 
# End of macro CWHEAD
bf9b			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bf9b					if DEBUG_FORTH_WORDS_KEY 
bf9b						DMARK "DRW" 
bf9b f5				push af  
bf9c 3a b0 bf			ld a, (.dmark)  
bf9f 32 6b ee			ld (debug_mark),a  
bfa2 3a b1 bf			ld a, (.dmark+1)  
bfa5 32 6c ee			ld (debug_mark+1),a  
bfa8 3a b2 bf			ld a, (.dmark+2)  
bfab 32 6d ee			ld (debug_mark+2),a  
bfae 18 03			jr .pastdmark  
bfb0 ..			.dmark: db "DRW"  
bfb3 f1			.pastdmark: pop af  
bfb4			endm  
# End of macro DMARK
bfb4						CALLMONITOR 
bfb4 cd 6f ee			call debug_vector  
bfb7				endm  
# End of macro CALLMONITOR
bfb7					endif 
bfb7 cd d1 8a				call update_display 
bfba					NEXTW 
bfba c3 0c a1			jp macro_next 
bfbd				endm 
# End of macro NEXTW
bfbd			 
bfbd			.DUMP: 
bfbd				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bfbd 37				db WORD_SYS_CORE+35             
bfbe f5 bf			dw .CDUMP            
bfc0 05				db 4 + 1 
bfc1 .. 00			db "DUMP",0              
bfc6				endm 
# End of macro CWHEAD
bfc6			; | DUMP ( x -- ) With address x display dump   | DONE 
bfc6			; TODO pop address to use off of the stack 
bfc6					if DEBUG_FORTH_WORDS_KEY 
bfc6						DMARK "DUM" 
bfc6 f5				push af  
bfc7 3a db bf			ld a, (.dmark)  
bfca 32 6b ee			ld (debug_mark),a  
bfcd 3a dc bf			ld a, (.dmark+1)  
bfd0 32 6c ee			ld (debug_mark+1),a  
bfd3 3a dd bf			ld a, (.dmark+2)  
bfd6 32 6d ee			ld (debug_mark+2),a  
bfd9 18 03			jr .pastdmark  
bfdb ..			.dmark: db "DUM"  
bfde f1			.pastdmark: pop af  
bfdf			endm  
# End of macro DMARK
bfdf						CALLMONITOR 
bfdf cd 6f ee			call debug_vector  
bfe2				endm  
# End of macro CALLMONITOR
bfe2					endif 
bfe2 cd ae 8a				call clear_display 
bfe5			 
bfe5					; get address 
bfe5			 
bfe5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfe5 cd 56 9f			call macro_dsp_valuehl 
bfe8				endm 
# End of macro FORTH_DSP_VALUEHL
bfe8				 
bfe8					; save it for cdump 
bfe8			 
bfe8 22 e4 e5				ld (os_cur_ptr),hl 
bfeb			 
bfeb					; destroy value TOS 
bfeb			 
bfeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfeb cd 0e a0			call macro_forth_dsp_pop 
bfee				endm 
# End of macro FORTH_DSP_POP
bfee			 
bfee cd df 9b				call dumpcont	; skip old style of param parsing	 
bff1 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bff2					NEXTW 
bff2 c3 0c a1			jp macro_next 
bff5				endm 
# End of macro NEXTW
bff5			.CDUMP: 
bff5				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bff5 38				db WORD_SYS_CORE+36             
bff6 25 c0			dw .DAT            
bff8 06				db 5 + 1 
bff9 .. 00			db "CDUMP",0              
bfff				endm 
# End of macro CWHEAD
bfff			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bfff					if DEBUG_FORTH_WORDS_KEY 
bfff						DMARK "CDP" 
bfff f5				push af  
c000 3a 14 c0			ld a, (.dmark)  
c003 32 6b ee			ld (debug_mark),a  
c006 3a 15 c0			ld a, (.dmark+1)  
c009 32 6c ee			ld (debug_mark+1),a  
c00c 3a 16 c0			ld a, (.dmark+2)  
c00f 32 6d ee			ld (debug_mark+2),a  
c012 18 03			jr .pastdmark  
c014 ..			.dmark: db "CDP"  
c017 f1			.pastdmark: pop af  
c018			endm  
# End of macro DMARK
c018						CALLMONITOR 
c018 cd 6f ee			call debug_vector  
c01b				endm  
# End of macro CALLMONITOR
c01b					endif 
c01b cd ae 8a				call clear_display 
c01e cd df 9b				call dumpcont	 
c021 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
c022					NEXTW 
c022 c3 0c a1			jp macro_next 
c025				endm 
# End of macro NEXTW
c025			 
c025			 
c025			 
c025			 
c025			.DAT: 
c025				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
c025 3d				db WORD_SYS_CORE+41             
c026 7b c0			dw .HOME            
c028 03				db 2 + 1 
c029 .. 00			db "AT",0              
c02c				endm 
# End of macro CWHEAD
c02c			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
c02c					if DEBUG_FORTH_WORDS_KEY 
c02c						DMARK "AT." 
c02c f5				push af  
c02d 3a 41 c0			ld a, (.dmark)  
c030 32 6b ee			ld (debug_mark),a  
c033 3a 42 c0			ld a, (.dmark+1)  
c036 32 6c ee			ld (debug_mark+1),a  
c039 3a 43 c0			ld a, (.dmark+2)  
c03c 32 6d ee			ld (debug_mark+2),a  
c03f 18 03			jr .pastdmark  
c041 ..			.dmark: db "AT."  
c044 f1			.pastdmark: pop af  
c045			endm  
# End of macro DMARK
c045						CALLMONITOR 
c045 cd 6f ee			call debug_vector  
c048				endm  
# End of macro CALLMONITOR
c048					endif 
c048					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c048 cd 56 9f			call macro_dsp_valuehl 
c04b				endm 
# End of macro FORTH_DSP_VALUEHL
c04b			 
c04b			 
c04b					; TODO save cursor row 
c04b 7d					ld a,l 
c04c fe 02				cp 2 
c04e 20 04				jr nz, .crow3 
c050 3e 28				ld a, display_row_2 
c052 18 12				jr .ccol1 
c054 fe 03		.crow3:		cp 3 
c056 20 04				jr nz, .crow4 
c058 3e 50				ld a, display_row_3 
c05a 18 0a				jr .ccol1 
c05c fe 04		.crow4:		cp 4 
c05e 20 04				jr nz, .crow1 
c060 3e 78				ld a, display_row_4 
c062 18 02				jr .ccol1 
c064 3e 00		.crow1:		ld a,display_row_1 
c066 f5			.ccol1:		push af			; got row offset 
c067 6f					ld l,a 
c068 26 00				ld h,0 
c06a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c06a cd 0e a0			call macro_forth_dsp_pop 
c06d				endm 
# End of macro FORTH_DSP_POP
c06d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c06d cd 56 9f			call macro_dsp_valuehl 
c070				endm 
# End of macro FORTH_DSP_VALUEHL
c070					; TODO save cursor col 
c070 f1					pop af 
c071 85					add l		; add col offset 
c072 32 5e ea				ld (f_cursor_ptr), a 
c075					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c075 cd 0e a0			call macro_forth_dsp_pop 
c078				endm 
# End of macro FORTH_DSP_POP
c078			 
c078					; calculate  
c078			 
c078					NEXTW 
c078 c3 0c a1			jp macro_next 
c07b				endm 
# End of macro NEXTW
c07b			 
c07b			 
c07b			.HOME: 
c07b				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
c07b 41				db WORD_SYS_CORE+45             
c07c a8 c0			dw .CR            
c07e 05				db 4 + 1 
c07f .. 00			db "HOME",0              
c084				endm 
# End of macro CWHEAD
c084			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
c084					if DEBUG_FORTH_WORDS_KEY 
c084						DMARK "HOM" 
c084 f5				push af  
c085 3a 99 c0			ld a, (.dmark)  
c088 32 6b ee			ld (debug_mark),a  
c08b 3a 9a c0			ld a, (.dmark+1)  
c08e 32 6c ee			ld (debug_mark+1),a  
c091 3a 9b c0			ld a, (.dmark+2)  
c094 32 6d ee			ld (debug_mark+2),a  
c097 18 03			jr .pastdmark  
c099 ..			.dmark: db "HOM"  
c09c f1			.pastdmark: pop af  
c09d			endm  
# End of macro DMARK
c09d						CALLMONITOR 
c09d cd 6f ee			call debug_vector  
c0a0				endm  
# End of macro CALLMONITOR
c0a0					endif 
c0a0 3e 00		.home:		ld a, 0		; and home cursor 
c0a2 32 5e ea				ld (f_cursor_ptr), a 
c0a5					NEXTW 
c0a5 c3 0c a1			jp macro_next 
c0a8				endm 
# End of macro NEXTW
c0a8			 
c0a8			 
c0a8			.CR: 
c0a8				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
c0a8 46				db WORD_SYS_CORE+50             
c0a9 e3 c0			dw .SPACE            
c0ab 03				db 2 + 1 
c0ac .. 00			db "CR",0              
c0af				endm 
# End of macro CWHEAD
c0af			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
c0af					if DEBUG_FORTH_WORDS_KEY 
c0af						DMARK "CR." 
c0af f5				push af  
c0b0 3a c4 c0			ld a, (.dmark)  
c0b3 32 6b ee			ld (debug_mark),a  
c0b6 3a c5 c0			ld a, (.dmark+1)  
c0b9 32 6c ee			ld (debug_mark+1),a  
c0bc 3a c6 c0			ld a, (.dmark+2)  
c0bf 32 6d ee			ld (debug_mark+2),a  
c0c2 18 03			jr .pastdmark  
c0c4 ..			.dmark: db "CR."  
c0c7 f1			.pastdmark: pop af  
c0c8			endm  
# End of macro DMARK
c0c8						CALLMONITOR 
c0c8 cd 6f ee			call debug_vector  
c0cb				endm  
# End of macro CALLMONITOR
c0cb					endif 
c0cb 3e 0d				ld a, 13 
c0cd 32 c1 e2				ld (scratch),a 
c0d0 3e 0a				ld a, 10 
c0d2 32 c2 e2				ld (scratch+1),a 
c0d5 3e 00				ld a, 0 
c0d7 32 c3 e2				ld (scratch+2),a 
c0da 21 c1 e2				ld hl, scratch 
c0dd cd cd 9d				call forth_push_str 
c0e0					 
c0e0				       NEXTW 
c0e0 c3 0c a1			jp macro_next 
c0e3				endm 
# End of macro NEXTW
c0e3			.SPACE: 
c0e3				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c0e3 46				db WORD_SYS_CORE+50             
c0e4 19 c1			dw .SPACES            
c0e6 03				db 2 + 1 
c0e7 .. 00			db "BL",0              
c0ea				endm 
# End of macro CWHEAD
c0ea			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c0ea					if DEBUG_FORTH_WORDS_KEY 
c0ea						DMARK "BL." 
c0ea f5				push af  
c0eb 3a ff c0			ld a, (.dmark)  
c0ee 32 6b ee			ld (debug_mark),a  
c0f1 3a 00 c1			ld a, (.dmark+1)  
c0f4 32 6c ee			ld (debug_mark+1),a  
c0f7 3a 01 c1			ld a, (.dmark+2)  
c0fa 32 6d ee			ld (debug_mark+2),a  
c0fd 18 03			jr .pastdmark  
c0ff ..			.dmark: db "BL."  
c102 f1			.pastdmark: pop af  
c103			endm  
# End of macro DMARK
c103						CALLMONITOR 
c103 cd 6f ee			call debug_vector  
c106				endm  
# End of macro CALLMONITOR
c106					endif 
c106 3e 20				ld a, " " 
c108 32 c1 e2				ld (scratch),a 
c10b 3e 00				ld a, 0 
c10d 32 c2 e2				ld (scratch+1),a 
c110 21 c1 e2				ld hl, scratch 
c113 cd cd 9d				call forth_push_str 
c116					 
c116				       NEXTW 
c116 c3 0c a1			jp macro_next 
c119				endm 
# End of macro NEXTW
c119			 
c119			;.blstr: db " ", 0 
c119			 
c119			.SPACES: 
c119				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c119 47				db WORD_SYS_CORE+51             
c11a b4 c1			dw .SCROLL            
c11c 07				db 6 + 1 
c11d .. 00			db "SPACES",0              
c124				endm 
# End of macro CWHEAD
c124			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c124					if DEBUG_FORTH_WORDS_KEY 
c124						DMARK "SPS" 
c124 f5				push af  
c125 3a 39 c1			ld a, (.dmark)  
c128 32 6b ee			ld (debug_mark),a  
c12b 3a 3a c1			ld a, (.dmark+1)  
c12e 32 6c ee			ld (debug_mark+1),a  
c131 3a 3b c1			ld a, (.dmark+2)  
c134 32 6d ee			ld (debug_mark+2),a  
c137 18 03			jr .pastdmark  
c139 ..			.dmark: db "SPS"  
c13c f1			.pastdmark: pop af  
c13d			endm  
# End of macro DMARK
c13d						CALLMONITOR 
c13d cd 6f ee			call debug_vector  
c140				endm  
# End of macro CALLMONITOR
c140					endif 
c140			 
c140			 
c140					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c140 cd 56 9f			call macro_dsp_valuehl 
c143				endm 
# End of macro FORTH_DSP_VALUEHL
c143			 
c143 e5					push hl    ; u 
c144					if DEBUG_FORTH_WORDS 
c144						DMARK "SPA" 
c144 f5				push af  
c145 3a 59 c1			ld a, (.dmark)  
c148 32 6b ee			ld (debug_mark),a  
c14b 3a 5a c1			ld a, (.dmark+1)  
c14e 32 6c ee			ld (debug_mark+1),a  
c151 3a 5b c1			ld a, (.dmark+2)  
c154 32 6d ee			ld (debug_mark+2),a  
c157 18 03			jr .pastdmark  
c159 ..			.dmark: db "SPA"  
c15c f1			.pastdmark: pop af  
c15d			endm  
# End of macro DMARK
c15d						CALLMONITOR 
c15d cd 6f ee			call debug_vector  
c160				endm  
# End of macro CALLMONITOR
c160					endif 
c160			 
c160					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c160 cd 0e a0			call macro_forth_dsp_pop 
c163				endm 
# End of macro FORTH_DSP_POP
c163 e1					pop hl 
c164 0e 00				ld c, 0 
c166 45					ld b, l 
c167 21 c1 e2				ld hl, scratch  
c16a			 
c16a					if DEBUG_FORTH_WORDS 
c16a						DMARK "SP2" 
c16a f5				push af  
c16b 3a 7f c1			ld a, (.dmark)  
c16e 32 6b ee			ld (debug_mark),a  
c171 3a 80 c1			ld a, (.dmark+1)  
c174 32 6c ee			ld (debug_mark+1),a  
c177 3a 81 c1			ld a, (.dmark+2)  
c17a 32 6d ee			ld (debug_mark+2),a  
c17d 18 03			jr .pastdmark  
c17f ..			.dmark: db "SP2"  
c182 f1			.pastdmark: pop af  
c183			endm  
# End of macro DMARK
c183						CALLMONITOR 
c183 cd 6f ee			call debug_vector  
c186				endm  
# End of macro CALLMONITOR
c186					endif 
c186 3e 20				ld a, ' ' 
c188			.spaces1:	 
c188 77					ld (hl),a 
c189 23					inc hl 
c18a					 
c18a 10 fc				djnz .spaces1 
c18c 3e 00				ld a,0 
c18e 77					ld (hl),a 
c18f 21 c1 e2				ld hl, scratch 
c192					if DEBUG_FORTH_WORDS 
c192						DMARK "SP3" 
c192 f5				push af  
c193 3a a7 c1			ld a, (.dmark)  
c196 32 6b ee			ld (debug_mark),a  
c199 3a a8 c1			ld a, (.dmark+1)  
c19c 32 6c ee			ld (debug_mark+1),a  
c19f 3a a9 c1			ld a, (.dmark+2)  
c1a2 32 6d ee			ld (debug_mark+2),a  
c1a5 18 03			jr .pastdmark  
c1a7 ..			.dmark: db "SP3"  
c1aa f1			.pastdmark: pop af  
c1ab			endm  
# End of macro DMARK
c1ab						CALLMONITOR 
c1ab cd 6f ee			call debug_vector  
c1ae				endm  
# End of macro CALLMONITOR
c1ae					endif 
c1ae cd cd 9d				call forth_push_str 
c1b1			 
c1b1				       NEXTW 
c1b1 c3 0c a1			jp macro_next 
c1b4				endm 
# End of macro NEXTW
c1b4			 
c1b4			 
c1b4			 
c1b4			.SCROLL: 
c1b4				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c1b4 53				db WORD_SYS_CORE+63             
c1b5 e1 c1			dw .SCROLLD            
c1b7 07				db 6 + 1 
c1b8 .. 00			db "SCROLL",0              
c1bf				endm 
# End of macro CWHEAD
c1bf			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c1bf					if DEBUG_FORTH_WORDS_KEY 
c1bf						DMARK "SCR" 
c1bf f5				push af  
c1c0 3a d4 c1			ld a, (.dmark)  
c1c3 32 6b ee			ld (debug_mark),a  
c1c6 3a d5 c1			ld a, (.dmark+1)  
c1c9 32 6c ee			ld (debug_mark+1),a  
c1cc 3a d6 c1			ld a, (.dmark+2)  
c1cf 32 6d ee			ld (debug_mark+2),a  
c1d2 18 03			jr .pastdmark  
c1d4 ..			.dmark: db "SCR"  
c1d7 f1			.pastdmark: pop af  
c1d8			endm  
# End of macro DMARK
c1d8						CALLMONITOR 
c1d8 cd 6f ee			call debug_vector  
c1db				endm  
# End of macro CALLMONITOR
c1db					endif 
c1db			 
c1db cd 70 8a			call scroll_up 
c1de			;	call update_display 
c1de			 
c1de					NEXTW 
c1de c3 0c a1			jp macro_next 
c1e1				endm 
# End of macro NEXTW
c1e1			 
c1e1			 
c1e1			 
c1e1			;		; get dir 
c1e1			; 
c1e1			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1e1			; 
c1e1			;		push hl 
c1e1			; 
c1e1			;		; destroy value TOS 
c1e1			; 
c1e1			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1e1			; 
c1e1			;		; get count 
c1e1			; 
c1e1			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1e1			; 
c1e1			;		push hl 
c1e1			; 
c1e1			;		; destroy value TOS 
c1e1			; 
c1e1			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1e1			; 
c1e1			;		; one value on hl get other one back 
c1e1			; 
c1e1			;		pop bc    ; count 
c1e1			; 
c1e1			;		pop de   ; dir 
c1e1			; 
c1e1			; 
c1e1			;		ld b, c 
c1e1			; 
c1e1			;.scrolldir:     push bc 
c1e1			;		push de 
c1e1			; 
c1e1			;		ld a, 0 
c1e1			;		cp e 
c1e1			;		jr z, .scrollup  
c1e1			;		call scroll_down 
c1e1			;		jr .scrollnext 
c1e1			;.scrollup:	call scroll_up 
c1e1			; 
c1e1			;		 
c1e1			;.scrollnext: 
c1e1			;		pop de 
c1e1			;		pop bc 
c1e1			;		djnz .scrolldir 
c1e1			; 
c1e1			; 
c1e1			; 
c1e1			; 
c1e1			; 
c1e1			;		NEXTW 
c1e1			 
c1e1			.SCROLLD: 
c1e1				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c1e1 53				db WORD_SYS_CORE+63             
c1e2 0f c2			dw .ATQ            
c1e4 08				db 7 + 1 
c1e5 .. 00			db "SCROLLD",0              
c1ed				endm 
# End of macro CWHEAD
c1ed			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c1ed					if DEBUG_FORTH_WORDS_KEY 
c1ed						DMARK "SCD" 
c1ed f5				push af  
c1ee 3a 02 c2			ld a, (.dmark)  
c1f1 32 6b ee			ld (debug_mark),a  
c1f4 3a 03 c2			ld a, (.dmark+1)  
c1f7 32 6c ee			ld (debug_mark+1),a  
c1fa 3a 04 c2			ld a, (.dmark+2)  
c1fd 32 6d ee			ld (debug_mark+2),a  
c200 18 03			jr .pastdmark  
c202 ..			.dmark: db "SCD"  
c205 f1			.pastdmark: pop af  
c206			endm  
# End of macro DMARK
c206						CALLMONITOR 
c206 cd 6f ee			call debug_vector  
c209				endm  
# End of macro CALLMONITOR
c209					endif 
c209			 
c209 cd 94 8a			call scroll_down 
c20c			;	call update_display 
c20c			 
c20c					NEXTW 
c20c c3 0c a1			jp macro_next 
c20f				endm 
# End of macro NEXTW
c20f			 
c20f			 
c20f			.ATQ: 
c20f				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c20f 62				db WORD_SYS_CORE+78             
c210 6d c2			dw .AUTODSP            
c212 04				db 3 + 1 
c213 .. 00			db "AT@",0              
c217				endm 
# End of macro CWHEAD
c217			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c217					if DEBUG_FORTH_WORDS_KEY 
c217						DMARK "ATA" 
c217 f5				push af  
c218 3a 2c c2			ld a, (.dmark)  
c21b 32 6b ee			ld (debug_mark),a  
c21e 3a 2d c2			ld a, (.dmark+1)  
c221 32 6c ee			ld (debug_mark+1),a  
c224 3a 2e c2			ld a, (.dmark+2)  
c227 32 6d ee			ld (debug_mark+2),a  
c22a 18 03			jr .pastdmark  
c22c ..			.dmark: db "ATA"  
c22f f1			.pastdmark: pop af  
c230			endm  
# End of macro DMARK
c230						CALLMONITOR 
c230 cd 6f ee			call debug_vector  
c233				endm  
# End of macro CALLMONITOR
c233					endif 
c233			 
c233			 
c233					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c233 cd 56 9f			call macro_dsp_valuehl 
c236				endm 
# End of macro FORTH_DSP_VALUEHL
c236			 
c236					; TODO save cursor row 
c236 7d					ld a,l 
c237 fe 02				cp 2 
c239 20 04				jr nz, .crow3aq 
c23b 3e 28				ld a, display_row_2 
c23d 18 12				jr .ccol1aq 
c23f fe 03		.crow3aq:		cp 3 
c241 20 04				jr nz, .crow4aq 
c243 3e 50				ld a, display_row_3 
c245 18 0a				jr .ccol1aq 
c247 fe 04		.crow4aq:		cp 4 
c249 20 04				jr nz, .crow1aq 
c24b 3e 78				ld a, display_row_4 
c24d 18 02				jr .ccol1aq 
c24f 3e 00		.crow1aq:		ld a,display_row_1 
c251 f5			.ccol1aq:		push af			; got row offset 
c252 6f					ld l,a 
c253 26 00				ld h,0 
c255					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c255 cd 0e a0			call macro_forth_dsp_pop 
c258				endm 
# End of macro FORTH_DSP_POP
c258					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c258 cd 56 9f			call macro_dsp_valuehl 
c25b				endm 
# End of macro FORTH_DSP_VALUEHL
c25b					; TODO save cursor col 
c25b f1					pop af 
c25c 85					add l		; add col offset 
c25d			 
c25d					; add current frame buffer address 
c25d 2a cc eb				ld hl, (display_fb_active) 
c260 cd db 8c				call addatohl 
c263			 
c263			 
c263			 
c263			 
c263					; get char frame buffer location offset in hl 
c263			 
c263 7e					ld a,(hl) 
c264 26 00				ld h, 0 
c266 6f					ld l, a 
c267			 
c267 cd 5f 9d				call forth_push_numhl 
c26a			 
c26a			 
c26a					NEXTW 
c26a c3 0c a1			jp macro_next 
c26d				endm 
# End of macro NEXTW
c26d			 
c26d			.AUTODSP: 
c26d				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c26d 63				db WORD_SYS_CORE+79             
c26e 83 c2			dw .MENU            
c270 05				db 4 + 1 
c271 .. 00			db "ADSP",0              
c276				endm 
# End of macro CWHEAD
c276			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c276			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c276			 
c276					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c276 cd 56 9f			call macro_dsp_valuehl 
c279				endm 
# End of macro FORTH_DSP_VALUEHL
c279			 
c279			;		push hl 
c279			 
c279					; destroy value TOS 
c279			 
c279					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c279 cd 0e a0			call macro_forth_dsp_pop 
c27c				endm 
# End of macro FORTH_DSP_POP
c27c			 
c27c			;		pop hl 
c27c			 
c27c 7d					ld a,l 
c27d 32 3c ea				ld (cli_autodisplay), a 
c280				       NEXTW 
c280 c3 0c a1			jp macro_next 
c283				endm 
# End of macro NEXTW
c283			 
c283			.MENU: 
c283				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c283 70				db WORD_SYS_CORE+92             
c284 2c c3			dw .ENDDISPLAY            
c286 05				db 4 + 1 
c287 .. 00			db "MENU",0              
c28c				endm 
# End of macro CWHEAD
c28c			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c28c			 
c28c			;		; get number of items on the stack 
c28c			; 
c28c				 
c28c					FORTH_DSP_VALUEHL 
c28c cd 56 9f			call macro_dsp_valuehl 
c28f				endm 
# End of macro FORTH_DSP_VALUEHL
c28f				 
c28f					if DEBUG_FORTH_WORDS_KEY 
c28f						DMARK "MNU" 
c28f f5				push af  
c290 3a a4 c2			ld a, (.dmark)  
c293 32 6b ee			ld (debug_mark),a  
c296 3a a5 c2			ld a, (.dmark+1)  
c299 32 6c ee			ld (debug_mark+1),a  
c29c 3a a6 c2			ld a, (.dmark+2)  
c29f 32 6d ee			ld (debug_mark+2),a  
c2a2 18 03			jr .pastdmark  
c2a4 ..			.dmark: db "MNU"  
c2a7 f1			.pastdmark: pop af  
c2a8			endm  
# End of macro DMARK
c2a8						CALLMONITOR 
c2a8 cd 6f ee			call debug_vector  
c2ab				endm  
# End of macro CALLMONITOR
c2ab					endif 
c2ab			 
c2ab 45					ld b, l	 
c2ac 05					dec b 
c2ad			 
c2ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ad cd 0e a0			call macro_forth_dsp_pop 
c2b0				endm 
# End of macro FORTH_DSP_POP
c2b0			 
c2b0			 
c2b0					; go directly through the stack to pluck out the string pointers and build an array 
c2b0			 
c2b0			;		FORTH_DSP 
c2b0			 
c2b0					; hl contains top most stack item 
c2b0				 
c2b0 11 c1 e2				ld de, scratch 
c2b3			 
c2b3			.mbuild: 
c2b3			 
c2b3					FORTH_DSP_VALUEHL 
c2b3 cd 56 9f			call macro_dsp_valuehl 
c2b6				endm 
# End of macro FORTH_DSP_VALUEHL
c2b6			 
c2b6					if DEBUG_FORTH_WORDS 
c2b6						DMARK "MN3" 
c2b6 f5				push af  
c2b7 3a cb c2			ld a, (.dmark)  
c2ba 32 6b ee			ld (debug_mark),a  
c2bd 3a cc c2			ld a, (.dmark+1)  
c2c0 32 6c ee			ld (debug_mark+1),a  
c2c3 3a cd c2			ld a, (.dmark+2)  
c2c6 32 6d ee			ld (debug_mark+2),a  
c2c9 18 03			jr .pastdmark  
c2cb ..			.dmark: db "MN3"  
c2ce f1			.pastdmark: pop af  
c2cf			endm  
# End of macro DMARK
c2cf						CALLMONITOR 
c2cf cd 6f ee			call debug_vector  
c2d2				endm  
# End of macro CALLMONITOR
c2d2					endif 
c2d2 eb					ex de, hl 
c2d3 73					ld (hl), e 
c2d4 23					inc hl 
c2d5 72					ld (hl), d 
c2d6 23					inc hl 
c2d7 eb					ex de, hl 
c2d8			 
c2d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2d8 cd 0e a0			call macro_forth_dsp_pop 
c2db				endm 
# End of macro FORTH_DSP_POP
c2db			 
c2db 10 d6				djnz .mbuild 
c2dd			 
c2dd					; done add term 
c2dd			 
c2dd eb					ex de, hl 
c2de 36 00				ld (hl), 0 
c2e0 23					inc hl 
c2e1 36 00				ld (hl), 0 
c2e3			 
c2e3				 
c2e3					 
c2e3 21 c1 e2				ld hl, scratch 
c2e6			 
c2e6					if DEBUG_FORTH_WORDS 
c2e6						DMARK "MNx" 
c2e6 f5				push af  
c2e7 3a fb c2			ld a, (.dmark)  
c2ea 32 6b ee			ld (debug_mark),a  
c2ed 3a fc c2			ld a, (.dmark+1)  
c2f0 32 6c ee			ld (debug_mark+1),a  
c2f3 3a fd c2			ld a, (.dmark+2)  
c2f6 32 6d ee			ld (debug_mark+2),a  
c2f9 18 03			jr .pastdmark  
c2fb ..			.dmark: db "MNx"  
c2fe f1			.pastdmark: pop af  
c2ff			endm  
# End of macro DMARK
c2ff						CALLMONITOR 
c2ff cd 6f ee			call debug_vector  
c302				endm  
# End of macro CALLMONITOR
c302					endif 
c302			 
c302			 
c302			 
c302 3e 00				ld a, 0 
c304 cd df 8a				call menu 
c307			 
c307			 
c307 6f					ld l, a 
c308 26 00				ld h, 0 
c30a			 
c30a					if DEBUG_FORTH_WORDS 
c30a						DMARK "MNr" 
c30a f5				push af  
c30b 3a 1f c3			ld a, (.dmark)  
c30e 32 6b ee			ld (debug_mark),a  
c311 3a 20 c3			ld a, (.dmark+1)  
c314 32 6c ee			ld (debug_mark+1),a  
c317 3a 21 c3			ld a, (.dmark+2)  
c31a 32 6d ee			ld (debug_mark+2),a  
c31d 18 03			jr .pastdmark  
c31f ..			.dmark: db "MNr"  
c322 f1			.pastdmark: pop af  
c323			endm  
# End of macro DMARK
c323						CALLMONITOR 
c323 cd 6f ee			call debug_vector  
c326				endm  
# End of macro CALLMONITOR
c326					endif 
c326			 
c326 cd 5f 9d				call forth_push_numhl 
c329			 
c329			 
c329			 
c329			 
c329				       NEXTW 
c329 c3 0c a1			jp macro_next 
c32c				endm 
# End of macro NEXTW
c32c			 
c32c			 
c32c			.ENDDISPLAY: 
c32c			 
c32c			; eof 
# End of file forth_words_display.asm
c32c			include "forth_words_str.asm" 
c32c			 
c32c			; | ## String Words 
c32c			 
c32c			.PTR:   
c32c			 
c32c				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c32c 48				db WORD_SYS_CORE+52             
c32d 59 c3			dw .STYPE            
c32f 04				db 3 + 1 
c330 .. 00			db "PTR",0              
c334				endm 
# End of macro CWHEAD
c334			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c334			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c334			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c334			 
c334					if DEBUG_FORTH_WORDS_KEY 
c334						DMARK "PTR" 
c334 f5				push af  
c335 3a 49 c3			ld a, (.dmark)  
c338 32 6b ee			ld (debug_mark),a  
c33b 3a 4a c3			ld a, (.dmark+1)  
c33e 32 6c ee			ld (debug_mark+1),a  
c341 3a 4b c3			ld a, (.dmark+2)  
c344 32 6d ee			ld (debug_mark+2),a  
c347 18 03			jr .pastdmark  
c349 ..			.dmark: db "PTR"  
c34c f1			.pastdmark: pop af  
c34d			endm  
# End of macro DMARK
c34d						CALLMONITOR 
c34d cd 6f ee			call debug_vector  
c350				endm  
# End of macro CALLMONITOR
c350					endif 
c350					FORTH_DSP_VALUEHL 
c350 cd 56 9f			call macro_dsp_valuehl 
c353				endm 
# End of macro FORTH_DSP_VALUEHL
c353 cd 5f 9d				call forth_push_numhl 
c356			 
c356			 
c356					NEXTW 
c356 c3 0c a1			jp macro_next 
c359				endm 
# End of macro NEXTW
c359			.STYPE: 
c359				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c359 48				db WORD_SYS_CORE+52             
c35a a8 c3			dw .UPPER            
c35c 06				db 5 + 1 
c35d .. 00			db "STYPE",0              
c363				endm 
# End of macro CWHEAD
c363			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c363					if DEBUG_FORTH_WORDS_KEY 
c363						DMARK "STY" 
c363 f5				push af  
c364 3a 78 c3			ld a, (.dmark)  
c367 32 6b ee			ld (debug_mark),a  
c36a 3a 79 c3			ld a, (.dmark+1)  
c36d 32 6c ee			ld (debug_mark+1),a  
c370 3a 7a c3			ld a, (.dmark+2)  
c373 32 6d ee			ld (debug_mark+2),a  
c376 18 03			jr .pastdmark  
c378 ..			.dmark: db "STY"  
c37b f1			.pastdmark: pop af  
c37c			endm  
# End of macro DMARK
c37c						CALLMONITOR 
c37c cd 6f ee			call debug_vector  
c37f				endm  
# End of macro CALLMONITOR
c37f					endif 
c37f					FORTH_DSP 
c37f cd 1c 9f			call macro_forth_dsp 
c382				endm 
# End of macro FORTH_DSP
c382					;v5 FORTH_DSP_VALUE 
c382			 
c382 7e					ld a, (hl) 
c383			 
c383 f5					push af 
c384			 
c384			; Dont destroy TOS		FORTH_DSP_POP 
c384			 
c384 f1					pop af 
c385			 
c385 fe 01				cp DS_TYPE_STR 
c387 28 09				jr z, .typestr 
c389			 
c389 fe 02				cp DS_TYPE_INUM 
c38b 28 0a				jr z, .typeinum 
c38d			 
c38d 21 a6 c3				ld hl, .tna 
c390 18 0a				jr .tpush 
c392			 
c392 21 a2 c3		.typestr:	ld hl, .tstr 
c395 18 05				jr .tpush 
c397 21 a4 c3		.typeinum:	ld hl, .tinum 
c39a 18 00				jr .tpush 
c39c			 
c39c			.tpush: 
c39c			 
c39c cd cd 9d				call forth_push_str 
c39f			 
c39f					NEXTW 
c39f c3 0c a1			jp macro_next 
c3a2				endm 
# End of macro NEXTW
c3a2 .. 00		.tstr:	db "s",0 
c3a4 .. 00		.tinum:  db "i",0 
c3a6 .. 00		.tna:   db "?", 0 
c3a8			 
c3a8			 
c3a8			.UPPER: 
c3a8				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c3a8 48				db WORD_SYS_CORE+52             
c3a9 e3 c3			dw .LOWER            
c3ab 06				db 5 + 1 
c3ac .. 00			db "UPPER",0              
c3b2				endm 
# End of macro CWHEAD
c3b2			; | UPPER ( s -- s ) Upper case string s  | DONE 
c3b2					if DEBUG_FORTH_WORDS_KEY 
c3b2						DMARK "UPR" 
c3b2 f5				push af  
c3b3 3a c7 c3			ld a, (.dmark)  
c3b6 32 6b ee			ld (debug_mark),a  
c3b9 3a c8 c3			ld a, (.dmark+1)  
c3bc 32 6c ee			ld (debug_mark+1),a  
c3bf 3a c9 c3			ld a, (.dmark+2)  
c3c2 32 6d ee			ld (debug_mark+2),a  
c3c5 18 03			jr .pastdmark  
c3c7 ..			.dmark: db "UPR"  
c3ca f1			.pastdmark: pop af  
c3cb			endm  
# End of macro DMARK
c3cb						CALLMONITOR 
c3cb cd 6f ee			call debug_vector  
c3ce				endm  
# End of macro CALLMONITOR
c3ce					endif 
c3ce			 
c3ce					FORTH_DSP 
c3ce cd 1c 9f			call macro_forth_dsp 
c3d1				endm 
# End of macro FORTH_DSP
c3d1					 
c3d1			; TODO check is string type 
c3d1			 
c3d1					FORTH_DSP_VALUEHL 
c3d1 cd 56 9f			call macro_dsp_valuehl 
c3d4				endm 
# End of macro FORTH_DSP_VALUEHL
c3d4			; get pointer to string in hl 
c3d4			 
c3d4 7e			.toup:		ld a, (hl) 
c3d5 fe 00				cp 0 
c3d7 28 07				jr z, .toupdone 
c3d9			 
c3d9 cd 60 92				call to_upper 
c3dc			 
c3dc 77					ld (hl), a 
c3dd 23					inc hl 
c3de 18 f4				jr .toup 
c3e0			 
c3e0					 
c3e0			 
c3e0			 
c3e0			; for each char convert to upper 
c3e0					 
c3e0			.toupdone: 
c3e0			 
c3e0			 
c3e0					NEXTW 
c3e0 c3 0c a1			jp macro_next 
c3e3				endm 
# End of macro NEXTW
c3e3			.LOWER: 
c3e3				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c3e3 48				db WORD_SYS_CORE+52             
c3e4 1e c4			dw .TCASE            
c3e6 06				db 5 + 1 
c3e7 .. 00			db "LOWER",0              
c3ed				endm 
# End of macro CWHEAD
c3ed			; | LOWER ( s -- s ) Lower case string s  | DONE 
c3ed					if DEBUG_FORTH_WORDS_KEY 
c3ed						DMARK "LWR" 
c3ed f5				push af  
c3ee 3a 02 c4			ld a, (.dmark)  
c3f1 32 6b ee			ld (debug_mark),a  
c3f4 3a 03 c4			ld a, (.dmark+1)  
c3f7 32 6c ee			ld (debug_mark+1),a  
c3fa 3a 04 c4			ld a, (.dmark+2)  
c3fd 32 6d ee			ld (debug_mark+2),a  
c400 18 03			jr .pastdmark  
c402 ..			.dmark: db "LWR"  
c405 f1			.pastdmark: pop af  
c406			endm  
# End of macro DMARK
c406						CALLMONITOR 
c406 cd 6f ee			call debug_vector  
c409				endm  
# End of macro CALLMONITOR
c409					endif 
c409			 
c409					FORTH_DSP 
c409 cd 1c 9f			call macro_forth_dsp 
c40c				endm 
# End of macro FORTH_DSP
c40c					 
c40c			; TODO check is string type 
c40c			 
c40c					FORTH_DSP_VALUEHL 
c40c cd 56 9f			call macro_dsp_valuehl 
c40f				endm 
# End of macro FORTH_DSP_VALUEHL
c40f			; get pointer to string in hl 
c40f			 
c40f 7e			.tolow:		ld a, (hl) 
c410 fe 00				cp 0 
c412 28 07				jr z, .tolowdone 
c414			 
c414 cd 69 92				call to_lower 
c417			 
c417 77					ld (hl), a 
c418 23					inc hl 
c419 18 f4				jr .tolow 
c41b			 
c41b					 
c41b			 
c41b			 
c41b			; for each char convert to low 
c41b					 
c41b			.tolowdone: 
c41b					NEXTW 
c41b c3 0c a1			jp macro_next 
c41e				endm 
# End of macro NEXTW
c41e			.TCASE: 
c41e				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c41e 48				db WORD_SYS_CORE+52             
c41f 54 c5			dw .SUBSTR            
c421 06				db 5 + 1 
c422 .. 00			db "TCASE",0              
c428				endm 
# End of macro CWHEAD
c428			; | TCASE ( s -- s ) Title case string s  | DONE 
c428					if DEBUG_FORTH_WORDS_KEY 
c428						DMARK "TCS" 
c428 f5				push af  
c429 3a 3d c4			ld a, (.dmark)  
c42c 32 6b ee			ld (debug_mark),a  
c42f 3a 3e c4			ld a, (.dmark+1)  
c432 32 6c ee			ld (debug_mark+1),a  
c435 3a 3f c4			ld a, (.dmark+2)  
c438 32 6d ee			ld (debug_mark+2),a  
c43b 18 03			jr .pastdmark  
c43d ..			.dmark: db "TCS"  
c440 f1			.pastdmark: pop af  
c441			endm  
# End of macro DMARK
c441						CALLMONITOR 
c441 cd 6f ee			call debug_vector  
c444				endm  
# End of macro CALLMONITOR
c444					endif 
c444			 
c444					FORTH_DSP 
c444 cd 1c 9f			call macro_forth_dsp 
c447				endm 
# End of macro FORTH_DSP
c447					 
c447			; TODO check is string type 
c447			 
c447					FORTH_DSP_VALUEHL 
c447 cd 56 9f			call macro_dsp_valuehl 
c44a				endm 
# End of macro FORTH_DSP_VALUEHL
c44a			; get pointer to string in hl 
c44a			 
c44a					if DEBUG_FORTH_WORDS 
c44a						DMARK "TC1" 
c44a f5				push af  
c44b 3a 5f c4			ld a, (.dmark)  
c44e 32 6b ee			ld (debug_mark),a  
c451 3a 60 c4			ld a, (.dmark+1)  
c454 32 6c ee			ld (debug_mark+1),a  
c457 3a 61 c4			ld a, (.dmark+2)  
c45a 32 6d ee			ld (debug_mark+2),a  
c45d 18 03			jr .pastdmark  
c45f ..			.dmark: db "TC1"  
c462 f1			.pastdmark: pop af  
c463			endm  
# End of macro DMARK
c463						CALLMONITOR 
c463 cd 6f ee			call debug_vector  
c466				endm  
# End of macro CALLMONITOR
c466					endif 
c466			 
c466					; first time in turn to upper case first char 
c466			 
c466 7e					ld a, (hl) 
c467 c3 f1 c4				jp .totsiptou 
c46a			 
c46a			 
c46a 7e			.tot:		ld a, (hl) 
c46b fe 00				cp 0 
c46d ca 35 c5				jp z, .totdone 
c470			 
c470					if DEBUG_FORTH_WORDS 
c470						DMARK "TC2" 
c470 f5				push af  
c471 3a 85 c4			ld a, (.dmark)  
c474 32 6b ee			ld (debug_mark),a  
c477 3a 86 c4			ld a, (.dmark+1)  
c47a 32 6c ee			ld (debug_mark+1),a  
c47d 3a 87 c4			ld a, (.dmark+2)  
c480 32 6d ee			ld (debug_mark+2),a  
c483 18 03			jr .pastdmark  
c485 ..			.dmark: db "TC2"  
c488 f1			.pastdmark: pop af  
c489			endm  
# End of macro DMARK
c489						CALLMONITOR 
c489 cd 6f ee			call debug_vector  
c48c				endm  
# End of macro CALLMONITOR
c48c					endif 
c48c					; check to see if current char is a space 
c48c			 
c48c fe 20				cp ' ' 
c48e 28 21				jr z, .totsp 
c490 cd 69 92				call to_lower 
c493					if DEBUG_FORTH_WORDS 
c493						DMARK "TC3" 
c493 f5				push af  
c494 3a a8 c4			ld a, (.dmark)  
c497 32 6b ee			ld (debug_mark),a  
c49a 3a a9 c4			ld a, (.dmark+1)  
c49d 32 6c ee			ld (debug_mark+1),a  
c4a0 3a aa c4			ld a, (.dmark+2)  
c4a3 32 6d ee			ld (debug_mark+2),a  
c4a6 18 03			jr .pastdmark  
c4a8 ..			.dmark: db "TC3"  
c4ab f1			.pastdmark: pop af  
c4ac			endm  
# End of macro DMARK
c4ac						CALLMONITOR 
c4ac cd 6f ee			call debug_vector  
c4af				endm  
# End of macro CALLMONITOR
c4af					endif 
c4af 18 63				jr .totnxt 
c4b1			 
c4b1			.totsp:         ; on a space, find next char which should be upper 
c4b1			 
c4b1					if DEBUG_FORTH_WORDS 
c4b1						DMARK "TC4" 
c4b1 f5				push af  
c4b2 3a c6 c4			ld a, (.dmark)  
c4b5 32 6b ee			ld (debug_mark),a  
c4b8 3a c7 c4			ld a, (.dmark+1)  
c4bb 32 6c ee			ld (debug_mark+1),a  
c4be 3a c8 c4			ld a, (.dmark+2)  
c4c1 32 6d ee			ld (debug_mark+2),a  
c4c4 18 03			jr .pastdmark  
c4c6 ..			.dmark: db "TC4"  
c4c9 f1			.pastdmark: pop af  
c4ca			endm  
# End of macro DMARK
c4ca						CALLMONITOR 
c4ca cd 6f ee			call debug_vector  
c4cd				endm  
# End of macro CALLMONITOR
c4cd					endif 
c4cd					;; 
c4cd			 
c4cd fe 20				cp ' ' 
c4cf 20 20				jr nz, .totsiptou 
c4d1 23					inc hl 
c4d2 7e					ld a, (hl) 
c4d3					if DEBUG_FORTH_WORDS 
c4d3						DMARK "TC5" 
c4d3 f5				push af  
c4d4 3a e8 c4			ld a, (.dmark)  
c4d7 32 6b ee			ld (debug_mark),a  
c4da 3a e9 c4			ld a, (.dmark+1)  
c4dd 32 6c ee			ld (debug_mark+1),a  
c4e0 3a ea c4			ld a, (.dmark+2)  
c4e3 32 6d ee			ld (debug_mark+2),a  
c4e6 18 03			jr .pastdmark  
c4e8 ..			.dmark: db "TC5"  
c4eb f1			.pastdmark: pop af  
c4ec			endm  
# End of macro DMARK
c4ec						CALLMONITOR 
c4ec cd 6f ee			call debug_vector  
c4ef				endm  
# End of macro CALLMONITOR
c4ef					endif 
c4ef 18 c0				jr .totsp 
c4f1 fe 00		.totsiptou:    cp 0 
c4f3 28 40				jr z, .totdone 
c4f5					; not space and not zero term so upper case it 
c4f5 cd 60 92				call to_upper 
c4f8			 
c4f8					if DEBUG_FORTH_WORDS 
c4f8						DMARK "TC6" 
c4f8 f5				push af  
c4f9 3a 0d c5			ld a, (.dmark)  
c4fc 32 6b ee			ld (debug_mark),a  
c4ff 3a 0e c5			ld a, (.dmark+1)  
c502 32 6c ee			ld (debug_mark+1),a  
c505 3a 0f c5			ld a, (.dmark+2)  
c508 32 6d ee			ld (debug_mark+2),a  
c50b 18 03			jr .pastdmark  
c50d ..			.dmark: db "TC6"  
c510 f1			.pastdmark: pop af  
c511			endm  
# End of macro DMARK
c511						CALLMONITOR 
c511 cd 6f ee			call debug_vector  
c514				endm  
# End of macro CALLMONITOR
c514					endif 
c514			 
c514			 
c514			.totnxt: 
c514			 
c514 77					ld (hl), a 
c515 23					inc hl 
c516					if DEBUG_FORTH_WORDS 
c516						DMARK "TC7" 
c516 f5				push af  
c517 3a 2b c5			ld a, (.dmark)  
c51a 32 6b ee			ld (debug_mark),a  
c51d 3a 2c c5			ld a, (.dmark+1)  
c520 32 6c ee			ld (debug_mark+1),a  
c523 3a 2d c5			ld a, (.dmark+2)  
c526 32 6d ee			ld (debug_mark+2),a  
c529 18 03			jr .pastdmark  
c52b ..			.dmark: db "TC7"  
c52e f1			.pastdmark: pop af  
c52f			endm  
# End of macro DMARK
c52f						CALLMONITOR 
c52f cd 6f ee			call debug_vector  
c532				endm  
# End of macro CALLMONITOR
c532					endif 
c532 c3 6a c4				jp .tot 
c535			 
c535					 
c535			 
c535			 
c535			; for each char convert to low 
c535					 
c535			.totdone: 
c535					if DEBUG_FORTH_WORDS 
c535						DMARK "TCd" 
c535 f5				push af  
c536 3a 4a c5			ld a, (.dmark)  
c539 32 6b ee			ld (debug_mark),a  
c53c 3a 4b c5			ld a, (.dmark+1)  
c53f 32 6c ee			ld (debug_mark+1),a  
c542 3a 4c c5			ld a, (.dmark+2)  
c545 32 6d ee			ld (debug_mark+2),a  
c548 18 03			jr .pastdmark  
c54a ..			.dmark: db "TCd"  
c54d f1			.pastdmark: pop af  
c54e			endm  
# End of macro DMARK
c54e						CALLMONITOR 
c54e cd 6f ee			call debug_vector  
c551				endm  
# End of macro CALLMONITOR
c551					endif 
c551					NEXTW 
c551 c3 0c a1			jp macro_next 
c554				endm 
# End of macro NEXTW
c554			 
c554			.SUBSTR: 
c554				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c554 48				db WORD_SYS_CORE+52             
c555 b2 c5			dw .LEFT            
c557 07				db 6 + 1 
c558 .. 00			db "SUBSTR",0              
c55f				endm 
# End of macro CWHEAD
c55f			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c55f			 
c55f					if DEBUG_FORTH_WORDS_KEY 
c55f						DMARK "SST" 
c55f f5				push af  
c560 3a 74 c5			ld a, (.dmark)  
c563 32 6b ee			ld (debug_mark),a  
c566 3a 75 c5			ld a, (.dmark+1)  
c569 32 6c ee			ld (debug_mark+1),a  
c56c 3a 76 c5			ld a, (.dmark+2)  
c56f 32 6d ee			ld (debug_mark+2),a  
c572 18 03			jr .pastdmark  
c574 ..			.dmark: db "SST"  
c577 f1			.pastdmark: pop af  
c578			endm  
# End of macro DMARK
c578						CALLMONITOR 
c578 cd 6f ee			call debug_vector  
c57b				endm  
# End of macro CALLMONITOR
c57b					endif 
c57b			; TODO check string type 
c57b					FORTH_DSP_VALUEHL 
c57b cd 56 9f			call macro_dsp_valuehl 
c57e				endm 
# End of macro FORTH_DSP_VALUEHL
c57e			 
c57e e5					push hl      ; string length 
c57f			 
c57f					FORTH_DSP_POP 
c57f cd 0e a0			call macro_forth_dsp_pop 
c582				endm 
# End of macro FORTH_DSP_POP
c582			 
c582					FORTH_DSP_VALUEHL 
c582 cd 56 9f			call macro_dsp_valuehl 
c585				endm 
# End of macro FORTH_DSP_VALUEHL
c585			 
c585 e5					push hl     ; start char 
c586			 
c586					FORTH_DSP_POP 
c586 cd 0e a0			call macro_forth_dsp_pop 
c589				endm 
# End of macro FORTH_DSP_POP
c589			 
c589			 
c589					FORTH_DSP_VALUE 
c589 cd 3f 9f			call macro_forth_dsp_value 
c58c				endm 
# End of macro FORTH_DSP_VALUE
c58c			 
c58c d1					pop de    ; get start post offset 
c58d			 
c58d 19					add hl, de    ; starting offset 
c58e			 
c58e c1					pop bc 
c58f c5					push bc      ; grab size of string 
c590			 
c590 e5					push hl    ; save string start  
c591			 
c591 26 00				ld h, 0 
c593 69					ld l, c 
c594 23					inc hl 
c595 23					inc hl 
c596			 
c596 cd c6 93				call malloc 
c599				if DEBUG_FORTH_MALLOC_GUARD 
c599 cc cc ce				call z,malloc_error 
c59c				endif 
c59c			 
c59c eb					ex de, hl      ; save malloc area for string copy 
c59d e1					pop hl    ; get back source 
c59e c1					pop bc    ; get length of string back 
c59f			 
c59f d5					push de    ; save malloc area for after we push 
c5a0 ed b0				ldir     ; copy substr 
c5a2			 
c5a2			 
c5a2 eb					ex de, hl 
c5a3 3e 00				ld a, 0 
c5a5 77					ld (hl), a   ; term substr 
c5a6			 
c5a6					 
c5a6 e1					pop hl    ; get malloc so we can push it 
c5a7 e5					push hl   ; save so we can free it afterwards 
c5a8			 
c5a8 cd cd 9d				call forth_push_str 
c5ab			 
c5ab e1					pop hl 
c5ac cd 90 94				call free 
c5af			 
c5af					 
c5af					 
c5af			 
c5af			 
c5af					NEXTW 
c5af c3 0c a1			jp macro_next 
c5b2				endm 
# End of macro NEXTW
c5b2			 
c5b2			.LEFT: 
c5b2				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c5b2 48				db WORD_SYS_CORE+52             
c5b3 da c5			dw .RIGHT            
c5b5 05				db 4 + 1 
c5b6 .. 00			db "LEFT",0              
c5bb				endm 
# End of macro CWHEAD
c5bb			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c5bb					if DEBUG_FORTH_WORDS_KEY 
c5bb						DMARK "LEF" 
c5bb f5				push af  
c5bc 3a d0 c5			ld a, (.dmark)  
c5bf 32 6b ee			ld (debug_mark),a  
c5c2 3a d1 c5			ld a, (.dmark+1)  
c5c5 32 6c ee			ld (debug_mark+1),a  
c5c8 3a d2 c5			ld a, (.dmark+2)  
c5cb 32 6d ee			ld (debug_mark+2),a  
c5ce 18 03			jr .pastdmark  
c5d0 ..			.dmark: db "LEF"  
c5d3 f1			.pastdmark: pop af  
c5d4			endm  
# End of macro DMARK
c5d4						CALLMONITOR 
c5d4 cd 6f ee			call debug_vector  
c5d7				endm  
# End of macro CALLMONITOR
c5d7					endif 
c5d7			 
c5d7					NEXTW 
c5d7 c3 0c a1			jp macro_next 
c5da				endm 
# End of macro NEXTW
c5da			.RIGHT: 
c5da				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c5da 48				db WORD_SYS_CORE+52             
c5db 03 c6			dw .STR2NUM            
c5dd 06				db 5 + 1 
c5de .. 00			db "RIGHT",0              
c5e4				endm 
# End of macro CWHEAD
c5e4			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c5e4					if DEBUG_FORTH_WORDS_KEY 
c5e4						DMARK "RIG" 
c5e4 f5				push af  
c5e5 3a f9 c5			ld a, (.dmark)  
c5e8 32 6b ee			ld (debug_mark),a  
c5eb 3a fa c5			ld a, (.dmark+1)  
c5ee 32 6c ee			ld (debug_mark+1),a  
c5f1 3a fb c5			ld a, (.dmark+2)  
c5f4 32 6d ee			ld (debug_mark+2),a  
c5f7 18 03			jr .pastdmark  
c5f9 ..			.dmark: db "RIG"  
c5fc f1			.pastdmark: pop af  
c5fd			endm  
# End of macro DMARK
c5fd						CALLMONITOR 
c5fd cd 6f ee			call debug_vector  
c600				endm  
# End of macro CALLMONITOR
c600					endif 
c600			 
c600					NEXTW 
c600 c3 0c a1			jp macro_next 
c603				endm 
# End of macro NEXTW
c603			 
c603			 
c603			.STR2NUM: 
c603				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c603 48				db WORD_SYS_CORE+52             
c604 8f c6			dw .NUM2STR            
c606 08				db 7 + 1 
c607 .. 00			db "STR2NUM",0              
c60f				endm 
# End of macro CWHEAD
c60f			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c60f			 
c60f			 
c60f			; TODO STR type check to do 
c60f					if DEBUG_FORTH_WORDS_KEY 
c60f						DMARK "S2N" 
c60f f5				push af  
c610 3a 24 c6			ld a, (.dmark)  
c613 32 6b ee			ld (debug_mark),a  
c616 3a 25 c6			ld a, (.dmark+1)  
c619 32 6c ee			ld (debug_mark+1),a  
c61c 3a 26 c6			ld a, (.dmark+2)  
c61f 32 6d ee			ld (debug_mark+2),a  
c622 18 03			jr .pastdmark  
c624 ..			.dmark: db "S2N"  
c627 f1			.pastdmark: pop af  
c628			endm  
# End of macro DMARK
c628						CALLMONITOR 
c628 cd 6f ee			call debug_vector  
c62b				endm  
# End of macro CALLMONITOR
c62b					endif 
c62b			 
c62b					;FORTH_DSP 
c62b					FORTH_DSP_VALUE 
c62b cd 3f 9f			call macro_forth_dsp_value 
c62e				endm 
# End of macro FORTH_DSP_VALUE
c62e					;inc hl 
c62e			 
c62e eb					ex de, hl 
c62f					if DEBUG_FORTH_WORDS 
c62f						DMARK "S2a" 
c62f f5				push af  
c630 3a 44 c6			ld a, (.dmark)  
c633 32 6b ee			ld (debug_mark),a  
c636 3a 45 c6			ld a, (.dmark+1)  
c639 32 6c ee			ld (debug_mark+1),a  
c63c 3a 46 c6			ld a, (.dmark+2)  
c63f 32 6d ee			ld (debug_mark+2),a  
c642 18 03			jr .pastdmark  
c644 ..			.dmark: db "S2a"  
c647 f1			.pastdmark: pop af  
c648			endm  
# End of macro DMARK
c648						CALLMONITOR 
c648 cd 6f ee			call debug_vector  
c64b				endm  
# End of macro CALLMONITOR
c64b					endif 
c64b cd e8 92				call string_to_uint16 
c64e			 
c64e					if DEBUG_FORTH_WORDS 
c64e						DMARK "S2b" 
c64e f5				push af  
c64f 3a 63 c6			ld a, (.dmark)  
c652 32 6b ee			ld (debug_mark),a  
c655 3a 64 c6			ld a, (.dmark+1)  
c658 32 6c ee			ld (debug_mark+1),a  
c65b 3a 65 c6			ld a, (.dmark+2)  
c65e 32 6d ee			ld (debug_mark+2),a  
c661 18 03			jr .pastdmark  
c663 ..			.dmark: db "S2b"  
c666 f1			.pastdmark: pop af  
c667			endm  
# End of macro DMARK
c667						CALLMONITOR 
c667 cd 6f ee			call debug_vector  
c66a				endm  
# End of macro CALLMONITOR
c66a					endif 
c66a			;		push hl 
c66a					FORTH_DSP_POP 
c66a cd 0e a0			call macro_forth_dsp_pop 
c66d				endm 
# End of macro FORTH_DSP_POP
c66d			;		pop hl 
c66d					 
c66d					if DEBUG_FORTH_WORDS 
c66d						DMARK "S2b" 
c66d f5				push af  
c66e 3a 82 c6			ld a, (.dmark)  
c671 32 6b ee			ld (debug_mark),a  
c674 3a 83 c6			ld a, (.dmark+1)  
c677 32 6c ee			ld (debug_mark+1),a  
c67a 3a 84 c6			ld a, (.dmark+2)  
c67d 32 6d ee			ld (debug_mark+2),a  
c680 18 03			jr .pastdmark  
c682 ..			.dmark: db "S2b"  
c685 f1			.pastdmark: pop af  
c686			endm  
# End of macro DMARK
c686						CALLMONITOR 
c686 cd 6f ee			call debug_vector  
c689				endm  
# End of macro CALLMONITOR
c689					endif 
c689 cd 5f 9d				call forth_push_numhl	 
c68c			 
c68c				 
c68c				       NEXTW 
c68c c3 0c a1			jp macro_next 
c68f				endm 
# End of macro NEXTW
c68f			.NUM2STR: 
c68f				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c68f 48				db WORD_SYS_CORE+52             
c690 9e c6			dw .CONCAT            
c692 08				db 7 + 1 
c693 .. 00			db "NUM2STR",0              
c69b				endm 
# End of macro CWHEAD
c69b			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
c69b			 
c69b			;		; malloc a string to target 
c69b			;		ld hl, 10     ; TODO max string size should be fine 
c69b			;		call malloc 
c69b			;		push hl    ; save malloc location 
c69b			; 
c69b			; 
c69b			;; TODO check int type 
c69b			;		FORTH_DSP_VALUEHL 
c69b			;		ld a, l 
c69b			;		call DispAToASCII   
c69b			;;TODO need to chage above call to dump into string 
c69b			; 
c69b			; 
c69b			 
c69b				       NEXTW 
c69b c3 0c a1			jp macro_next 
c69e				endm 
# End of macro NEXTW
c69e			 
c69e			.CONCAT: 
c69e				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c69e 48				db WORD_SYS_CORE+52             
c69f 51 c7			dw .FIND            
c6a1 07				db 6 + 1 
c6a2 .. 00			db "CONCAT",0              
c6a9				endm 
# End of macro CWHEAD
c6a9			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c6a9			 
c6a9			; TODO check string type 
c6a9			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c6a9			 
c6a9					if DEBUG_FORTH_WORDS_KEY 
c6a9						DMARK "CON" 
c6a9 f5				push af  
c6aa 3a be c6			ld a, (.dmark)  
c6ad 32 6b ee			ld (debug_mark),a  
c6b0 3a bf c6			ld a, (.dmark+1)  
c6b3 32 6c ee			ld (debug_mark+1),a  
c6b6 3a c0 c6			ld a, (.dmark+2)  
c6b9 32 6d ee			ld (debug_mark+2),a  
c6bc 18 03			jr .pastdmark  
c6be ..			.dmark: db "CON"  
c6c1 f1			.pastdmark: pop af  
c6c2			endm  
# End of macro DMARK
c6c2						CALLMONITOR 
c6c2 cd 6f ee			call debug_vector  
c6c5				endm  
# End of macro CALLMONITOR
c6c5					endif 
c6c5			 
c6c5			 
c6c5					FORTH_DSP_VALUE 
c6c5 cd 3f 9f			call macro_forth_dsp_value 
c6c8				endm 
# End of macro FORTH_DSP_VALUE
c6c8 e5					push hl   ; s2 
c6c9			 
c6c9					FORTH_DSP_POP 
c6c9 cd 0e a0			call macro_forth_dsp_pop 
c6cc				endm 
# End of macro FORTH_DSP_POP
c6cc			 
c6cc					FORTH_DSP_VALUE 
c6cc cd 3f 9f			call macro_forth_dsp_value 
c6cf				endm 
# End of macro FORTH_DSP_VALUE
c6cf			 
c6cf e5					push hl   ; s1 
c6d0			 
c6d0					FORTH_DSP_POP 
c6d0 cd 0e a0			call macro_forth_dsp_pop 
c6d3				endm 
# End of macro FORTH_DSP_POP
c6d3					 
c6d3			 
c6d3					; copy s1 
c6d3			 
c6d3				 
c6d3					; save ptr 
c6d3 e1					pop hl  
c6d4 e5					push hl 
c6d5 3e 00				ld a, 0 
c6d7 cd 5c 93				call strlent 
c6da					;inc hl    ; zer0 
c6da 06 00				ld b, 0 
c6dc 4d					ld c, l 
c6dd e1					pop hl		 
c6de 11 c1 e2				ld de, scratch	 
c6e1					if DEBUG_FORTH_WORDS 
c6e1						DMARK "CO1" 
c6e1 f5				push af  
c6e2 3a f6 c6			ld a, (.dmark)  
c6e5 32 6b ee			ld (debug_mark),a  
c6e8 3a f7 c6			ld a, (.dmark+1)  
c6eb 32 6c ee			ld (debug_mark+1),a  
c6ee 3a f8 c6			ld a, (.dmark+2)  
c6f1 32 6d ee			ld (debug_mark+2),a  
c6f4 18 03			jr .pastdmark  
c6f6 ..			.dmark: db "CO1"  
c6f9 f1			.pastdmark: pop af  
c6fa			endm  
# End of macro DMARK
c6fa						CALLMONITOR 
c6fa cd 6f ee			call debug_vector  
c6fd				endm  
# End of macro CALLMONITOR
c6fd					endif 
c6fd ed b0				ldir 
c6ff			 
c6ff e1					pop hl 
c700 e5					push hl 
c701 d5					push de 
c702			 
c702			 
c702 3e 00				ld a, 0 
c704 cd 5c 93				call strlent 
c707 23					inc hl    ; zer0 
c708 23					inc hl 
c709 06 00				ld b, 0 
c70b 4d					ld c, l 
c70c d1					pop de 
c70d e1					pop hl		 
c70e					if DEBUG_FORTH_WORDS 
c70e						DMARK "CO2" 
c70e f5				push af  
c70f 3a 23 c7			ld a, (.dmark)  
c712 32 6b ee			ld (debug_mark),a  
c715 3a 24 c7			ld a, (.dmark+1)  
c718 32 6c ee			ld (debug_mark+1),a  
c71b 3a 25 c7			ld a, (.dmark+2)  
c71e 32 6d ee			ld (debug_mark+2),a  
c721 18 03			jr .pastdmark  
c723 ..			.dmark: db "CO2"  
c726 f1			.pastdmark: pop af  
c727			endm  
# End of macro DMARK
c727						CALLMONITOR 
c727 cd 6f ee			call debug_vector  
c72a				endm  
# End of macro CALLMONITOR
c72a					endif 
c72a ed b0				ldir 
c72c			 
c72c			 
c72c			 
c72c 21 c1 e2				ld hl, scratch 
c72f					if DEBUG_FORTH_WORDS 
c72f						DMARK "CO5" 
c72f f5				push af  
c730 3a 44 c7			ld a, (.dmark)  
c733 32 6b ee			ld (debug_mark),a  
c736 3a 45 c7			ld a, (.dmark+1)  
c739 32 6c ee			ld (debug_mark+1),a  
c73c 3a 46 c7			ld a, (.dmark+2)  
c73f 32 6d ee			ld (debug_mark+2),a  
c742 18 03			jr .pastdmark  
c744 ..			.dmark: db "CO5"  
c747 f1			.pastdmark: pop af  
c748			endm  
# End of macro DMARK
c748						CALLMONITOR 
c748 cd 6f ee			call debug_vector  
c74b				endm  
# End of macro CALLMONITOR
c74b					endif 
c74b			 
c74b cd cd 9d				call forth_push_str 
c74e			 
c74e			 
c74e			 
c74e			 
c74e				       NEXTW 
c74e c3 0c a1			jp macro_next 
c751				endm 
# End of macro NEXTW
c751			 
c751			 
c751			.FIND: 
c751				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c751 4b				db WORD_SYS_CORE+55             
c752 0f c8			dw .LEN            
c754 05				db 4 + 1 
c755 .. 00			db "FIND",0              
c75a				endm 
# End of macro CWHEAD
c75a			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c75a			 
c75a					if DEBUG_FORTH_WORDS_KEY 
c75a						DMARK "FND" 
c75a f5				push af  
c75b 3a 6f c7			ld a, (.dmark)  
c75e 32 6b ee			ld (debug_mark),a  
c761 3a 70 c7			ld a, (.dmark+1)  
c764 32 6c ee			ld (debug_mark+1),a  
c767 3a 71 c7			ld a, (.dmark+2)  
c76a 32 6d ee			ld (debug_mark+2),a  
c76d 18 03			jr .pastdmark  
c76f ..			.dmark: db "FND"  
c772 f1			.pastdmark: pop af  
c773			endm  
# End of macro DMARK
c773						CALLMONITOR 
c773 cd 6f ee			call debug_vector  
c776				endm  
# End of macro CALLMONITOR
c776					endif 
c776			 
c776			; TODO check string type 
c776					FORTH_DSP_VALUE 
c776 cd 3f 9f			call macro_forth_dsp_value 
c779				endm 
# End of macro FORTH_DSP_VALUE
c779			 
c779 e5					push hl    
c77a 7e					ld a,(hl)    ; char to find   
c77b			; TODO change char to substr 
c77b			 
c77b f5					push af 
c77c					 
c77c			 
c77c			 
c77c					if DEBUG_FORTH_WORDS 
c77c						DMARK "FN1" 
c77c f5				push af  
c77d 3a 91 c7			ld a, (.dmark)  
c780 32 6b ee			ld (debug_mark),a  
c783 3a 92 c7			ld a, (.dmark+1)  
c786 32 6c ee			ld (debug_mark+1),a  
c789 3a 93 c7			ld a, (.dmark+2)  
c78c 32 6d ee			ld (debug_mark+2),a  
c78f 18 03			jr .pastdmark  
c791 ..			.dmark: db "FN1"  
c794 f1			.pastdmark: pop af  
c795			endm  
# End of macro DMARK
c795						CALLMONITOR 
c795 cd 6f ee			call debug_vector  
c798				endm  
# End of macro CALLMONITOR
c798					endif 
c798			 
c798					FORTH_DSP_POP 
c798 cd 0e a0			call macro_forth_dsp_pop 
c79b				endm 
# End of macro FORTH_DSP_POP
c79b			 
c79b					; string to search 
c79b			 
c79b					FORTH_DSP_VALUE 
c79b cd 3f 9f			call macro_forth_dsp_value 
c79e				endm 
# End of macro FORTH_DSP_VALUE
c79e			 
c79e d1					pop de  ; d is char to find  
c79f			 
c79f					if DEBUG_FORTH_WORDS 
c79f						DMARK "FN2" 
c79f f5				push af  
c7a0 3a b4 c7			ld a, (.dmark)  
c7a3 32 6b ee			ld (debug_mark),a  
c7a6 3a b5 c7			ld a, (.dmark+1)  
c7a9 32 6c ee			ld (debug_mark+1),a  
c7ac 3a b6 c7			ld a, (.dmark+2)  
c7af 32 6d ee			ld (debug_mark+2),a  
c7b2 18 03			jr .pastdmark  
c7b4 ..			.dmark: db "FN2"  
c7b7 f1			.pastdmark: pop af  
c7b8			endm  
# End of macro DMARK
c7b8						CALLMONITOR 
c7b8 cd 6f ee			call debug_vector  
c7bb				endm  
# End of macro CALLMONITOR
c7bb					endif 
c7bb					 
c7bb 01 00 00				ld bc, 0 
c7be 7e			.findchar:      ld a,(hl) 
c7bf fe 00				cp 0   		 
c7c1 28 27				jr z, .finddone     
c7c3 ba					cp d 
c7c4 28 20				jr z, .foundchar 
c7c6 03					inc bc 
c7c7 23					inc hl 
c7c8					if DEBUG_FORTH_WORDS 
c7c8						DMARK "FN3" 
c7c8 f5				push af  
c7c9 3a dd c7			ld a, (.dmark)  
c7cc 32 6b ee			ld (debug_mark),a  
c7cf 3a de c7			ld a, (.dmark+1)  
c7d2 32 6c ee			ld (debug_mark+1),a  
c7d5 3a df c7			ld a, (.dmark+2)  
c7d8 32 6d ee			ld (debug_mark+2),a  
c7db 18 03			jr .pastdmark  
c7dd ..			.dmark: db "FN3"  
c7e0 f1			.pastdmark: pop af  
c7e1			endm  
# End of macro DMARK
c7e1						CALLMONITOR 
c7e1 cd 6f ee			call debug_vector  
c7e4				endm  
# End of macro CALLMONITOR
c7e4					endif 
c7e4 18 d8				jr .findchar 
c7e6			 
c7e6			 
c7e6 c5			.foundchar:	push bc 
c7e7 e1					pop hl 
c7e8 18 03				jr .findexit 
c7ea			 
c7ea			 
c7ea							 
c7ea			 
c7ea			.finddone:     ; got to end of string with no find 
c7ea 21 00 00				ld hl, 0 
c7ed			.findexit: 
c7ed			 
c7ed					if DEBUG_FORTH_WORDS 
c7ed						DMARK "FNd" 
c7ed f5				push af  
c7ee 3a 02 c8			ld a, (.dmark)  
c7f1 32 6b ee			ld (debug_mark),a  
c7f4 3a 03 c8			ld a, (.dmark+1)  
c7f7 32 6c ee			ld (debug_mark+1),a  
c7fa 3a 04 c8			ld a, (.dmark+2)  
c7fd 32 6d ee			ld (debug_mark+2),a  
c800 18 03			jr .pastdmark  
c802 ..			.dmark: db "FNd"  
c805 f1			.pastdmark: pop af  
c806			endm  
# End of macro DMARK
c806						CALLMONITOR 
c806 cd 6f ee			call debug_vector  
c809				endm  
# End of macro CALLMONITOR
c809					endif 
c809 cd 5f 9d			call forth_push_numhl 
c80c			 
c80c				       NEXTW 
c80c c3 0c a1			jp macro_next 
c80f				endm 
# End of macro NEXTW
c80f			 
c80f			.LEN: 
c80f				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c80f 4c				db WORD_SYS_CORE+56             
c810 79 c8			dw .ASC            
c812 06				db 5 + 1 
c813 .. 00			db "COUNT",0              
c819				endm 
# End of macro CWHEAD
c819			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c819			 
c819					if DEBUG_FORTH_WORDS_KEY 
c819						DMARK "CNT" 
c819 f5				push af  
c81a 3a 2e c8			ld a, (.dmark)  
c81d 32 6b ee			ld (debug_mark),a  
c820 3a 2f c8			ld a, (.dmark+1)  
c823 32 6c ee			ld (debug_mark+1),a  
c826 3a 30 c8			ld a, (.dmark+2)  
c829 32 6d ee			ld (debug_mark+2),a  
c82c 18 03			jr .pastdmark  
c82e ..			.dmark: db "CNT"  
c831 f1			.pastdmark: pop af  
c832			endm  
# End of macro DMARK
c832						CALLMONITOR 
c832 cd 6f ee			call debug_vector  
c835				endm  
# End of macro CALLMONITOR
c835					endif 
c835			; TODO check string type 
c835					FORTH_DSP_VALUE 
c835 cd 3f 9f			call macro_forth_dsp_value 
c838				endm 
# End of macro FORTH_DSP_VALUE
c838			 
c838			 
c838					if DEBUG_FORTH_WORDS 
c838						DMARK "CN?" 
c838 f5				push af  
c839 3a 4d c8			ld a, (.dmark)  
c83c 32 6b ee			ld (debug_mark),a  
c83f 3a 4e c8			ld a, (.dmark+1)  
c842 32 6c ee			ld (debug_mark+1),a  
c845 3a 4f c8			ld a, (.dmark+2)  
c848 32 6d ee			ld (debug_mark+2),a  
c84b 18 03			jr .pastdmark  
c84d ..			.dmark: db "CN?"  
c850 f1			.pastdmark: pop af  
c851			endm  
# End of macro DMARK
c851						CALLMONITOR 
c851 cd 6f ee			call debug_vector  
c854				endm  
# End of macro CALLMONITOR
c854					endif 
c854 cd 51 93				call strlenz 
c857					if DEBUG_FORTH_WORDS 
c857						DMARK "CNl" 
c857 f5				push af  
c858 3a 6c c8			ld a, (.dmark)  
c85b 32 6b ee			ld (debug_mark),a  
c85e 3a 6d c8			ld a, (.dmark+1)  
c861 32 6c ee			ld (debug_mark+1),a  
c864 3a 6e c8			ld a, (.dmark+2)  
c867 32 6d ee			ld (debug_mark+2),a  
c86a 18 03			jr .pastdmark  
c86c ..			.dmark: db "CNl"  
c86f f1			.pastdmark: pop af  
c870			endm  
# End of macro DMARK
c870						CALLMONITOR 
c870 cd 6f ee			call debug_vector  
c873				endm  
# End of macro CALLMONITOR
c873					endif 
c873			 
c873 cd 5f 9d				call forth_push_numhl 
c876			 
c876			 
c876			 
c876				       NEXTW 
c876 c3 0c a1			jp macro_next 
c879				endm 
# End of macro NEXTW
c879			.ASC: 
c879				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c879 4d				db WORD_SYS_CORE+57             
c87a e7 c8			dw .CHR            
c87c 04				db 3 + 1 
c87d .. 00			db "ASC",0              
c881				endm 
# End of macro CWHEAD
c881			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
c881					if DEBUG_FORTH_WORDS_KEY 
c881						DMARK "ASC" 
c881 f5				push af  
c882 3a 96 c8			ld a, (.dmark)  
c885 32 6b ee			ld (debug_mark),a  
c888 3a 97 c8			ld a, (.dmark+1)  
c88b 32 6c ee			ld (debug_mark+1),a  
c88e 3a 98 c8			ld a, (.dmark+2)  
c891 32 6d ee			ld (debug_mark+2),a  
c894 18 03			jr .pastdmark  
c896 ..			.dmark: db "ASC"  
c899 f1			.pastdmark: pop af  
c89a			endm  
# End of macro DMARK
c89a						CALLMONITOR 
c89a cd 6f ee			call debug_vector  
c89d				endm  
# End of macro CALLMONITOR
c89d					endif 
c89d					FORTH_DSP_VALUE 
c89d cd 3f 9f			call macro_forth_dsp_value 
c8a0				endm 
# End of macro FORTH_DSP_VALUE
c8a0					;v5 FORTH_DSP_VALUE 
c8a0			;		inc hl      ; now at start of numeric as string 
c8a0			 
c8a0 e5					push hl 
c8a1			 
c8a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c8a1 cd 0e a0			call macro_forth_dsp_pop 
c8a4				endm 
# End of macro FORTH_DSP_POP
c8a4			 
c8a4 e1					pop hl 
c8a5			 
c8a5					if DEBUG_FORTH_WORDS 
c8a5						DMARK "AS1" 
c8a5 f5				push af  
c8a6 3a ba c8			ld a, (.dmark)  
c8a9 32 6b ee			ld (debug_mark),a  
c8ac 3a bb c8			ld a, (.dmark+1)  
c8af 32 6c ee			ld (debug_mark+1),a  
c8b2 3a bc c8			ld a, (.dmark+2)  
c8b5 32 6d ee			ld (debug_mark+2),a  
c8b8 18 03			jr .pastdmark  
c8ba ..			.dmark: db "AS1"  
c8bd f1			.pastdmark: pop af  
c8be			endm  
# End of macro DMARK
c8be						CALLMONITOR 
c8be cd 6f ee			call debug_vector  
c8c1				endm  
# End of macro CALLMONITOR
c8c1					endif 
c8c1					; push the content of a onto the stack as a value 
c8c1			 
c8c1 7e					ld a,(hl)   ; get char 
c8c2 26 00				ld h,0 
c8c4 6f					ld l,a 
c8c5					if DEBUG_FORTH_WORDS 
c8c5						DMARK "AS2" 
c8c5 f5				push af  
c8c6 3a da c8			ld a, (.dmark)  
c8c9 32 6b ee			ld (debug_mark),a  
c8cc 3a db c8			ld a, (.dmark+1)  
c8cf 32 6c ee			ld (debug_mark+1),a  
c8d2 3a dc c8			ld a, (.dmark+2)  
c8d5 32 6d ee			ld (debug_mark+2),a  
c8d8 18 03			jr .pastdmark  
c8da ..			.dmark: db "AS2"  
c8dd f1			.pastdmark: pop af  
c8de			endm  
# End of macro DMARK
c8de						CALLMONITOR 
c8de cd 6f ee			call debug_vector  
c8e1				endm  
# End of macro CALLMONITOR
c8e1					endif 
c8e1 cd 5f 9d				call forth_push_numhl 
c8e4			 
c8e4				       NEXTW 
c8e4 c3 0c a1			jp macro_next 
c8e7				endm 
# End of macro NEXTW
c8e7			 
c8e7			.CHR: 
c8e7				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c8e7 4d				db WORD_SYS_CORE+57             
c8e8 23 c9			dw .ENDSTR            
c8ea 04				db 3 + 1 
c8eb .. 00			db "CHR",0              
c8ef				endm 
# End of macro CWHEAD
c8ef			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c8ef					if DEBUG_FORTH_WORDS_KEY 
c8ef						DMARK "CHR" 
c8ef f5				push af  
c8f0 3a 04 c9			ld a, (.dmark)  
c8f3 32 6b ee			ld (debug_mark),a  
c8f6 3a 05 c9			ld a, (.dmark+1)  
c8f9 32 6c ee			ld (debug_mark+1),a  
c8fc 3a 06 c9			ld a, (.dmark+2)  
c8ff 32 6d ee			ld (debug_mark+2),a  
c902 18 03			jr .pastdmark  
c904 ..			.dmark: db "CHR"  
c907 f1			.pastdmark: pop af  
c908			endm  
# End of macro DMARK
c908						CALLMONITOR 
c908 cd 6f ee			call debug_vector  
c90b				endm  
# End of macro CALLMONITOR
c90b					endif 
c90b					FORTH_DSP_VALUEHL 
c90b cd 56 9f			call macro_dsp_valuehl 
c90e				endm 
# End of macro FORTH_DSP_VALUEHL
c90e			 
c90e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c90e cd 0e a0			call macro_forth_dsp_pop 
c911				endm 
# End of macro FORTH_DSP_POP
c911			 
c911					; save asci byte as a zero term string and push string 
c911			 
c911 7d					ld a,l 
c912 32 c1 e2				ld (scratch), a 
c915			 
c915 3e 00				ld a, 0 
c917 32 c2 e2				ld (scratch+1), a 
c91a			 
c91a 21 c1 e2				ld hl, scratch 
c91d cd cd 9d				call forth_push_str 
c920			 
c920			 
c920				       NEXTW 
c920 c3 0c a1			jp macro_next 
c923				endm 
# End of macro NEXTW
c923			 
c923			 
c923			 
c923			 
c923			.ENDSTR: 
c923			; eof 
c923			 
# End of file forth_words_str.asm
c923			include "forth_words_key.asm" 
c923			 
c923			; | ## Keyboard Words 
c923			 
c923			.KEY: 
c923				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c923 3e				db WORD_SYS_CORE+42             
c924 53 c9			dw .WAITK            
c926 04				db 3 + 1 
c927 .. 00			db "KEY",0              
c92b				endm 
# End of macro CWHEAD
c92b			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c92b			 
c92b					if DEBUG_FORTH_WORDS_KEY 
c92b						DMARK "KEY" 
c92b f5				push af  
c92c 3a 40 c9			ld a, (.dmark)  
c92f 32 6b ee			ld (debug_mark),a  
c932 3a 41 c9			ld a, (.dmark+1)  
c935 32 6c ee			ld (debug_mark+1),a  
c938 3a 42 c9			ld a, (.dmark+2)  
c93b 32 6d ee			ld (debug_mark+2),a  
c93e 18 03			jr .pastdmark  
c940 ..			.dmark: db "KEY"  
c943 f1			.pastdmark: pop af  
c944			endm  
# End of macro DMARK
c944						CALLMONITOR 
c944 cd 6f ee			call debug_vector  
c947				endm  
# End of macro CALLMONITOR
c947					endif 
c947			; TODO currently waits 
c947 cd ed e6				call cin 
c94a					;call cin_wait 
c94a 6f					ld l, a 
c94b 26 00				ld h, 0 
c94d cd 5f 9d				call forth_push_numhl 
c950					NEXTW 
c950 c3 0c a1			jp macro_next 
c953				endm 
# End of macro NEXTW
c953			.WAITK: 
c953				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c953 3f				db WORD_SYS_CORE+43             
c954 85 c9			dw .ACCEPT            
c956 06				db 5 + 1 
c957 .. 00			db "WAITK",0              
c95d				endm 
# End of macro CWHEAD
c95d			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c95d					if DEBUG_FORTH_WORDS_KEY 
c95d						DMARK "WAI" 
c95d f5				push af  
c95e 3a 72 c9			ld a, (.dmark)  
c961 32 6b ee			ld (debug_mark),a  
c964 3a 73 c9			ld a, (.dmark+1)  
c967 32 6c ee			ld (debug_mark+1),a  
c96a 3a 74 c9			ld a, (.dmark+2)  
c96d 32 6d ee			ld (debug_mark+2),a  
c970 18 03			jr .pastdmark  
c972 ..			.dmark: db "WAI"  
c975 f1			.pastdmark: pop af  
c976			endm  
# End of macro DMARK
c976						CALLMONITOR 
c976 cd 6f ee			call debug_vector  
c979				endm  
# End of macro CALLMONITOR
c979					endif 
c979 cd e7 e6				call cin_wait 
c97c 6f					ld l, a 
c97d 26 00				ld h, 0 
c97f cd 5f 9d				call forth_push_numhl 
c982					NEXTW 
c982 c3 0c a1			jp macro_next 
c985				endm 
# End of macro NEXTW
c985			.ACCEPT: 
c985				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c985 40				db WORD_SYS_CORE+44             
c986 e3 c9			dw .EDIT            
c988 07				db 6 + 1 
c989 .. 00			db "ACCEPT",0              
c990				endm 
# End of macro CWHEAD
c990			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c990					; TODO crashes on push 
c990					if DEBUG_FORTH_WORDS_KEY 
c990						DMARK "ACC" 
c990 f5				push af  
c991 3a a5 c9			ld a, (.dmark)  
c994 32 6b ee			ld (debug_mark),a  
c997 3a a6 c9			ld a, (.dmark+1)  
c99a 32 6c ee			ld (debug_mark+1),a  
c99d 3a a7 c9			ld a, (.dmark+2)  
c9a0 32 6d ee			ld (debug_mark+2),a  
c9a3 18 03			jr .pastdmark  
c9a5 ..			.dmark: db "ACC"  
c9a8 f1			.pastdmark: pop af  
c9a9			endm  
# End of macro DMARK
c9a9						CALLMONITOR 
c9a9 cd 6f ee			call debug_vector  
c9ac				endm  
# End of macro CALLMONITOR
c9ac					endif 
c9ac 21 bf e4				ld hl, os_input 
c9af 3e 00				ld a, 0 
c9b1 77					ld (hl),a 
c9b2 3a 5e ea				ld a,(f_cursor_ptr) 
c9b5 16 64				ld d, 100 
c9b7 0e 00				ld c, 0 
c9b9 1e 28				ld e, 40 
c9bb cd 08 8d				call input_str 
c9be					; TODO perhaps do a type check and wrap in quotes if not a number 
c9be 21 bf e4				ld hl, os_input 
c9c1					if DEBUG_FORTH_WORDS 
c9c1						DMARK "AC1" 
c9c1 f5				push af  
c9c2 3a d6 c9			ld a, (.dmark)  
c9c5 32 6b ee			ld (debug_mark),a  
c9c8 3a d7 c9			ld a, (.dmark+1)  
c9cb 32 6c ee			ld (debug_mark+1),a  
c9ce 3a d8 c9			ld a, (.dmark+2)  
c9d1 32 6d ee			ld (debug_mark+2),a  
c9d4 18 03			jr .pastdmark  
c9d6 ..			.dmark: db "AC1"  
c9d9 f1			.pastdmark: pop af  
c9da			endm  
# End of macro DMARK
c9da						CALLMONITOR 
c9da cd 6f ee			call debug_vector  
c9dd				endm  
# End of macro CALLMONITOR
c9dd					endif 
c9dd cd cd 9d				call forth_push_str 
c9e0					NEXTW 
c9e0 c3 0c a1			jp macro_next 
c9e3				endm 
# End of macro NEXTW
c9e3			 
c9e3			.EDIT: 
c9e3				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c9e3 40				db WORD_SYS_CORE+44             
c9e4 85 ca			dw .DEDIT            
c9e6 05				db 4 + 1 
c9e7 .. 00			db "EDIT",0              
c9ec				endm 
# End of macro CWHEAD
c9ec			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c9ec			 
c9ec					; TODO does not copy from stack 
c9ec					if DEBUG_FORTH_WORDS_KEY 
c9ec						DMARK "EDT" 
c9ec f5				push af  
c9ed 3a 01 ca			ld a, (.dmark)  
c9f0 32 6b ee			ld (debug_mark),a  
c9f3 3a 02 ca			ld a, (.dmark+1)  
c9f6 32 6c ee			ld (debug_mark+1),a  
c9f9 3a 03 ca			ld a, (.dmark+2)  
c9fc 32 6d ee			ld (debug_mark+2),a  
c9ff 18 03			jr .pastdmark  
ca01 ..			.dmark: db "EDT"  
ca04 f1			.pastdmark: pop af  
ca05			endm  
# End of macro DMARK
ca05						CALLMONITOR 
ca05 cd 6f ee			call debug_vector  
ca08				endm  
# End of macro CALLMONITOR
ca08					endif 
ca08			 
ca08					;FORTH_DSP 
ca08					FORTH_DSP_VALUEHL 
ca08 cd 56 9f			call macro_dsp_valuehl 
ca0b				endm 
# End of macro FORTH_DSP_VALUEHL
ca0b			;		inc hl    ; TODO do type check 
ca0b			 
ca0b			;		call get_word_hl 
ca0b e5					push hl 
ca0c					if DEBUG_FORTH_WORDS 
ca0c						DMARK "EDp" 
ca0c f5				push af  
ca0d 3a 21 ca			ld a, (.dmark)  
ca10 32 6b ee			ld (debug_mark),a  
ca13 3a 22 ca			ld a, (.dmark+1)  
ca16 32 6c ee			ld (debug_mark+1),a  
ca19 3a 23 ca			ld a, (.dmark+2)  
ca1c 32 6d ee			ld (debug_mark+2),a  
ca1f 18 03			jr .pastdmark  
ca21 ..			.dmark: db "EDp"  
ca24 f1			.pastdmark: pop af  
ca25			endm  
# End of macro DMARK
ca25						CALLMONITOR 
ca25 cd 6f ee			call debug_vector  
ca28				endm  
# End of macro CALLMONITOR
ca28					endif 
ca28				;	ld a, 0 
ca28 cd 51 93				call strlenz 
ca2b 23					inc hl 
ca2c			 
ca2c 06 00				ld b, 0 
ca2e 4d					ld c, l 
ca2f			 
ca2f e1					pop hl 
ca30 11 bf e4				ld de, os_input 
ca33					if DEBUG_FORTH_WORDS_KEY 
ca33						DMARK "EDc" 
ca33 f5				push af  
ca34 3a 48 ca			ld a, (.dmark)  
ca37 32 6b ee			ld (debug_mark),a  
ca3a 3a 49 ca			ld a, (.dmark+1)  
ca3d 32 6c ee			ld (debug_mark+1),a  
ca40 3a 4a ca			ld a, (.dmark+2)  
ca43 32 6d ee			ld (debug_mark+2),a  
ca46 18 03			jr .pastdmark  
ca48 ..			.dmark: db "EDc"  
ca4b f1			.pastdmark: pop af  
ca4c			endm  
# End of macro DMARK
ca4c						CALLMONITOR 
ca4c cd 6f ee			call debug_vector  
ca4f				endm  
# End of macro CALLMONITOR
ca4f					endif 
ca4f ed b0				ldir 
ca51			 
ca51			 
ca51 21 bf e4				ld hl, os_input 
ca54					;ld a, 0 
ca54					;ld (hl),a 
ca54 3a 5e ea				ld a,(f_cursor_ptr) 
ca57 16 64				ld d, 100 
ca59 0e 00				ld c, 0 
ca5b 1e 28				ld e, 40 
ca5d cd 08 8d				call input_str 
ca60					; TODO perhaps do a type check and wrap in quotes if not a number 
ca60 21 bf e4				ld hl, os_input 
ca63					if DEBUG_FORTH_WORDS 
ca63						DMARK "ED1" 
ca63 f5				push af  
ca64 3a 78 ca			ld a, (.dmark)  
ca67 32 6b ee			ld (debug_mark),a  
ca6a 3a 79 ca			ld a, (.dmark+1)  
ca6d 32 6c ee			ld (debug_mark+1),a  
ca70 3a 7a ca			ld a, (.dmark+2)  
ca73 32 6d ee			ld (debug_mark+2),a  
ca76 18 03			jr .pastdmark  
ca78 ..			.dmark: db "ED1"  
ca7b f1			.pastdmark: pop af  
ca7c			endm  
# End of macro DMARK
ca7c						CALLMONITOR 
ca7c cd 6f ee			call debug_vector  
ca7f				endm  
# End of macro CALLMONITOR
ca7f					endif 
ca7f cd cd 9d				call forth_push_str 
ca82					NEXTW 
ca82 c3 0c a1			jp macro_next 
ca85				endm 
# End of macro NEXTW
ca85			 
ca85			.DEDIT: 
ca85				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
ca85 40				db WORD_SYS_CORE+44             
ca86 e7 ca			dw .ENDKEY            
ca88 06				db 5 + 1 
ca89 .. 00			db "DEDIT",0              
ca8f				endm 
# End of macro CWHEAD
ca8f			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
ca8f			 
ca8f					; TODO does not copy from stack 
ca8f					if DEBUG_FORTH_WORDS_KEY 
ca8f						DMARK "DED" 
ca8f f5				push af  
ca90 3a a4 ca			ld a, (.dmark)  
ca93 32 6b ee			ld (debug_mark),a  
ca96 3a a5 ca			ld a, (.dmark+1)  
ca99 32 6c ee			ld (debug_mark+1),a  
ca9c 3a a6 ca			ld a, (.dmark+2)  
ca9f 32 6d ee			ld (debug_mark+2),a  
caa2 18 03			jr .pastdmark  
caa4 ..			.dmark: db "DED"  
caa7 f1			.pastdmark: pop af  
caa8			endm  
# End of macro DMARK
caa8						CALLMONITOR 
caa8 cd 6f ee			call debug_vector  
caab				endm  
# End of macro CALLMONITOR
caab					endif 
caab			 
caab					;FORTH_DSP 
caab					FORTH_DSP_VALUEHL 
caab cd 56 9f			call macro_dsp_valuehl 
caae				endm 
# End of macro FORTH_DSP_VALUEHL
caae			;		inc hl    ; TODO do type check 
caae			 
caae			;		call get_word_hl 
caae e5					push hl 
caaf e5					push hl 
cab0					FORTH_DSP_POP 
cab0 cd 0e a0			call macro_forth_dsp_pop 
cab3				endm 
# End of macro FORTH_DSP_POP
cab3 e1					pop hl 
cab4					if DEBUG_FORTH_WORDS 
cab4						DMARK "EDp" 
cab4 f5				push af  
cab5 3a c9 ca			ld a, (.dmark)  
cab8 32 6b ee			ld (debug_mark),a  
cabb 3a ca ca			ld a, (.dmark+1)  
cabe 32 6c ee			ld (debug_mark+1),a  
cac1 3a cb ca			ld a, (.dmark+2)  
cac4 32 6d ee			ld (debug_mark+2),a  
cac7 18 03			jr .pastdmark  
cac9 ..			.dmark: db "EDp"  
cacc f1			.pastdmark: pop af  
cacd			endm  
# End of macro DMARK
cacd						CALLMONITOR 
cacd cd 6f ee			call debug_vector  
cad0				endm  
# End of macro CALLMONITOR
cad0					endif 
cad0				;	ld a, 0 
cad0 cd 51 93				call strlenz 
cad3 23					inc hl 
cad4			 
cad4 06 00				ld b, 0 
cad6 4d					ld c, l 
cad7			 
cad7 e1					pop hl 
cad8			 
cad8					;ld a, 0 
cad8					;ld (hl),a 
cad8 3a 5e ea				ld a,(f_cursor_ptr) 
cadb 16 64				ld d, 100 
cadd 0e 00				ld c, 0 
cadf 1e 28				ld e, 40 
cae1 cd 08 8d				call input_str 
cae4					; TODO perhaps do a type check and wrap in quotes if not a number 
cae4					NEXTW 
cae4 c3 0c a1			jp macro_next 
cae7				endm 
# End of macro NEXTW
cae7			 
cae7			 
cae7			.ENDKEY: 
cae7			; eof 
cae7			 
# End of file forth_words_key.asm
cae7			include "forth_words_const.asm" 
cae7			 
cae7			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
cae7			 
cae7			 
cae7			.SPITIME: 
cae7				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
cae7 77				db WORD_SYS_CORE+99             
cae8 fc ca			dw .VA            
caea 08				db 7 + 1 
caeb .. 00			db "SPITIME",0              
caf3				endm 
# End of macro CWHEAD
caf3			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
caf3			; 
caf3			; | | If using BANK devices then leave as is. 
caf3			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
caf3			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
caf3			 
caf3 21 64 ea				ld hl, spi_clktime  
caf6 cd 5f 9d				call forth_push_numhl 
caf9			 
caf9					NEXTW 
caf9 c3 0c a1			jp macro_next 
cafc				endm 
# End of macro NEXTW
cafc			 
cafc			 
cafc			.VA: 
cafc				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
cafc 77				db WORD_SYS_CORE+99             
cafd 0c cb			dw .SYMBOL            
caff 03				db 2 + 1 
cb00 .. 00			db "VA",0              
cb03				endm 
# End of macro CWHEAD
cb03			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
cb03 21 28 ea				ld hl, cli_var_array 
cb06 cd 5f 9d				call forth_push_numhl 
cb09			 
cb09					NEXTW 
cb09 c3 0c a1			jp macro_next 
cb0c				endm 
# End of macro NEXTW
cb0c			 
cb0c			.SYMBOL: 
cb0c				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
cb0c 77				db WORD_SYS_CORE+99             
cb0d 16 cc			dw .ENDCONST            
cb0f 07				db 6 + 1 
cb10 .. 00			db "SYMBOL",0              
cb17				endm 
# End of macro CWHEAD
cb17			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
cb17			; | 
cb17			; | | The value is the number reference and the final address is pushed to stack 
cb17			 
cb17			; | | ``` 
cb17			; | | dw sym_table 
cb17			; | | dw nmi_vector 
cb17			; | | dw cli_autodisplay 
cb17			; | | dw cli_data_sp 
cb17			; | | dw cli_data_stack 
cb17			; | | dw cli_loop_sp 
cb17			; | | dw cli_loop_stack 
cb17			; | | dw cli_var_array 
cb17			; | | dw cursor_col 
cb17			; | | dw cursor_ptr 
cb17			; | | ; 10 
cb17			; | | dw cursor_row 
cb17			; | | dw debug_mark 
cb17			; | | dw display_fb0 
cb17			; | | dw display_fb1 
cb17			; | | dw display_fb2 
cb17			; | | dw display_fb3 
cb17			; | | dw display_fb_active 
cb17			; | | dw execscratch 
cb17			; | | dw f_cursor_ptr 
cb17			; | | dw hardware_word 
cb17			; | | ;20 
cb17			; | | dw input_at_cursor 
cb17			; | | dw input_at_pos 
cb17			; | | dw input_cur_flash 
cb17			; | | dw input_cur_onoff 
cb17			; | | dw input_cursor 
cb17			; | | dw input_display_size 
cb17			; | | dw input_len 
cb17			; | | dw input_ptr 
cb17			; | | dw input_size 
cb17			; | | dw input_start 
cb17			; | | ; 30 
cb17			; | | dw input_str 
cb17			; | | dw input_under_cursor 
cb17			; | | dw os_cli_cmd 
cb17			; | | dw os_cur_ptr 
cb17			; | | dw os_current_i 
cb17			; | | dw os_input 
cb17			; | | dw os_last_cmd 
cb17			; | | dw os_last_new_uword 
cb17			; | | dw debug_vector 
cb17			; | | dw os_view_hl 
cb17			; | | ;40 
cb17			; | | dw os_word_scratch 
cb17			; | | dw portbctl 
cb17			; | | dw portbdata 
cb17			; | | dw spi_cartdev 
cb17			; | | dw spi_cartdev2 
cb17			; | | dw spi_clktime 
cb17			; | | dw spi_device 
cb17			; | | dw spi_device_id 
cb17			; | | dw spi_portbyte 
cb17			; | | dw stackstore 
cb17			; | | ; 50 
cb17			; | | if STORAGE_SE 
cb17			; | | dw storage_actl 
cb17			; | | dw storage_adata 
cb17			; | | else 
cb17			; | | dw 0 
cb17			; | | dw 0 
cb17			; | | endif 
cb17			; | | dw storage_append 
cb17			; | | if STORAGE_SE 
cb17			; | | dw storage_bctl 
cb17			; | | else 
cb17			; | | dw 0 
cb17			; | | endif 
cb17			; | | dw store_bank_active 
cb17			; | | dw store_filecache 
cb17			; | | dw store_longread 
cb17			; | | dw store_openaddr 
cb17			; | | dw store_openext 
cb17			; | | dw store_openmaxext 
cb17			; | | ; 60 
cb17			; | | dw store_page 
cb17			; | | dw store_readbuf 
cb17			; | | dw store_readcont 
cb17			; | | dw store_readptr 
cb17			; | | dw store_tmpext 
cb17			; | | dw store_tmpid 
cb17			; | | dw store_tmppageid 
cb17			; | | dw malloc 
cb17			; | | dw free 
cb17			; | | dw cin 
cb17			; | | ; 70 
cb17			; | | dw cin_wait 
cb17			; | | dw forth_push_numhl 
cb17			; | | dw forth_push_str 
cb17			; | | ``` 
cb17			 
cb17					if DEBUG_FORTH_WORDS_KEY 
cb17						DMARK "SYM" 
cb17 f5				push af  
cb18 3a 2c cb			ld a, (.dmark)  
cb1b 32 6b ee			ld (debug_mark),a  
cb1e 3a 2d cb			ld a, (.dmark+1)  
cb21 32 6c ee			ld (debug_mark+1),a  
cb24 3a 2e cb			ld a, (.dmark+2)  
cb27 32 6d ee			ld (debug_mark+2),a  
cb2a 18 03			jr .pastdmark  
cb2c ..			.dmark: db "SYM"  
cb2f f1			.pastdmark: pop af  
cb30			endm  
# End of macro DMARK
cb30						CALLMONITOR 
cb30 cd 6f ee			call debug_vector  
cb33				endm  
# End of macro CALLMONITOR
cb33					endif 
cb33			 
cb33					FORTH_DSP_VALUEHL 
cb33 cd 56 9f			call macro_dsp_valuehl 
cb36				endm 
# End of macro FORTH_DSP_VALUEHL
cb36			 
cb36 7d					ld a, l     
cb37			 
cb37			 
cb37					if DEBUG_FORTH_WORDS 
cb37						DMARK "SY1" 
cb37 f5				push af  
cb38 3a 4c cb			ld a, (.dmark)  
cb3b 32 6b ee			ld (debug_mark),a  
cb3e 3a 4d cb			ld a, (.dmark+1)  
cb41 32 6c ee			ld (debug_mark+1),a  
cb44 3a 4e cb			ld a, (.dmark+2)  
cb47 32 6d ee			ld (debug_mark+2),a  
cb4a 18 03			jr .pastdmark  
cb4c ..			.dmark: db "SY1"  
cb4f f1			.pastdmark: pop af  
cb50			endm  
# End of macro DMARK
cb50						CALLMONITOR 
cb50 cd 6f ee			call debug_vector  
cb53				endm  
# End of macro CALLMONITOR
cb53					endif 
cb53					 
cb53 f5					push af	 
cb54					FORTH_DSP_POP 
cb54 cd 0e a0			call macro_forth_dsp_pop 
cb57				endm 
# End of macro FORTH_DSP_POP
cb57 f1					pop af 
cb58			 
cb58 cb 27				sla a  
cb5a				 
cb5a					 
cb5a					if DEBUG_FORTH_WORDS 
cb5a						DMARK "SY" 
cb5a f5				push af  
cb5b 3a 6f cb			ld a, (.dmark)  
cb5e 32 6b ee			ld (debug_mark),a  
cb61 3a 70 cb			ld a, (.dmark+1)  
cb64 32 6c ee			ld (debug_mark+1),a  
cb67 3a 71 cb			ld a, (.dmark+2)  
cb6a 32 6d ee			ld (debug_mark+2),a  
cb6d 18 02			jr .pastdmark  
cb6f ..			.dmark: db "SY"  
cb71 f1			.pastdmark: pop af  
cb72			endm  
# End of macro DMARK
cb72						CALLMONITOR 
cb72 cd 6f ee			call debug_vector  
cb75				endm  
# End of macro CALLMONITOR
cb75					endif 
cb75			 
cb75 21 84 cb				ld hl, sym_table 
cb78 cd db 8c				call addatohl 
cb7b cd 8e a0				call loadwordinhl 
cb7e cd 5f 9d				call forth_push_numhl 
cb81			 
cb81			 
cb81				       NEXTW 
cb81 c3 0c a1			jp macro_next 
cb84				endm 
# End of macro NEXTW
cb84			 
cb84			sym_table: 
cb84			 
cb84			; 0 
cb84 84 cb		dw sym_table 
cb86 72 ee		dw nmi_vector 
cb88 3c ea		dw cli_autodisplay 
cb8a ee e9		dw cli_data_sp 
cb8c 28 e8		dw cli_data_stack 
cb8e f0 e9		dw cli_loop_sp 
cb90 2a e9		dw cli_loop_stack 
cb92 28 ea		dw cli_var_array 
cb94 c5 eb		dw cursor_col 
cb96 c3 eb		dw cursor_ptr 
cb98			; 10 
cb98 c4 eb		dw cursor_row 
cb9a 6b ee		dw debug_mark 
cb9c b1 ed		dw display_fb0 
cb9e 10 ed		dw display_fb1 
cba0 ce eb		dw display_fb2 
cba2 6f ec		dw display_fb3 
cba4 cc eb		dw display_fb_active 
cba6 c0 e3		dw execscratch 
cba8 5e ea		dw f_cursor_ptr 
cbaa 75 ee		dw hardware_word 
cbac			;20 
cbac 62 ee		dw input_at_cursor 
cbae 64 ee		dw input_at_pos 
cbb0 60 ee		dw input_cur_flash 
cbb2 5f ee		dw input_cur_onoff 
cbb4 55 ee		dw input_cursor 
cbb6 65 ee		dw input_display_size 
cbb8 5a ee		dw input_len 
cbba 69 ee		dw input_ptr 
cbbc 66 ee		dw input_size 
cbbe 67 ee		dw input_start 
cbc0			; 30 
cbc0 08 8d		dw input_str 
cbc2 63 ee		dw input_under_cursor 
cbc4 e8 e5		dw os_cli_cmd 
cbc6 e4 e5		dw os_cur_ptr 
cbc8 e6 e5		dw os_current_i 
cbca bf e4		dw os_input 
cbcc e7 e6		dw os_last_cmd 
cbce be e5		dw os_last_new_uword 
cbd0 6f ee		dw debug_vector 
cbd2 a3 e2		dw os_view_hl 
cbd4			;40 
cbd4 c6 e5		dw os_word_scratch 
cbd6 c3 00		dw portbctl 
cbd8 c1 00		dw portbdata 
cbda 63 ea		dw spi_cartdev 
cbdc 62 ea		dw spi_cartdev2 
cbde 64 ea		dw spi_clktime 
cbe0 60 ea		dw spi_device 
cbe2 5f ea		dw spi_device_id 
cbe4 61 ea		dw spi_portbyte 
cbe6 a7 eb		dw stackstore 
cbe8			; 50 
cbe8			if STORAGE_SE 
cbe8			dw storage_actl 
cbe8			dw storage_adata 
cbe8			else 
cbe8 00 00		dw 0 
cbea 00 00		dw 0 
cbec			endif 
cbec 68 88		dw storage_append 
cbee			if STORAGE_SE 
cbee			dw storage_bctl 
cbee			else 
cbee 00 00		dw 0 
cbf0			endif 
cbf0 93 eb		dw store_bank_active 
cbf2 67 ea		dw store_filecache 
cbf4 75 ea		dw store_longread 
cbf6 6b ea		dw store_openaddr 
cbf8 6a ea		dw store_openext 
cbfa 69 ea		dw store_openmaxext 
cbfc			; 60 
cbfc 7a ea		dw store_page 
cbfe 76 ea		dw store_readbuf 
cc00 6d ea		dw store_readcont 
cc02 78 ea		dw store_readptr 
cc04 6d ea		dw store_tmpext 
cc06 6e ea		dw store_tmpid 
cc08 65 ea		dw store_tmppageid 
cc0a c6 93		dw malloc 
cc0c 90 94		dw free 
cc0e ed e6		dw cin 
cc10			; 70 
cc10 e7 e6		dw cin_wait 
cc12 5f 9d		dw forth_push_numhl 
cc14 cd 9d		dw forth_push_str 
cc16			 
cc16			 
cc16			.ENDCONST: 
cc16			 
cc16			; eof 
cc16			 
cc16			 
# End of file forth_words_const.asm
cc16			 
cc16			if STORAGE_SE 
cc16			   	include "forth_words_storage.asm" 
cc16			endif 
cc16				include "forth_words_device.asm" 
cc16			; Device related words 
cc16			 
cc16			; | ## Device Words 
cc16			 
cc16			;if SOUND_ENABLE 
cc16			;.NOTE: 
cc16			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
cc16			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
cc16			;		if DEBUG_FORTH_WORDS_KEY 
cc16			;			DMARK "NTE" 
cc16			;			CALLMONITOR 
cc16			;		endif 
cc16			; 
cc16			;	 
cc16			; 
cc16			;		NEXTW 
cc16			;.AFTERSOUND: 
cc16			;endif 
cc16			 
cc16			 
cc16			USE_GPIO: equ 0 
cc16			 
cc16			if USE_GPIO 
cc16			.GP1: 
cc16				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
cc16			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
cc16					NEXTW 
cc16			.GP2: 
cc16				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
cc16			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
cc16			 
cc16					NEXTW 
cc16			 
cc16			.GP3: 
cc16				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
cc16			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
cc16			 
cc16					NEXTW 
cc16			 
cc16			.GP4: 
cc16				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
cc16			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
cc16			 
cc16					NEXTW 
cc16			.SIN: 
cc16			 
cc16			 
cc16			endif 
cc16			 
cc16			 
cc16				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
cc16 33				db WORD_SYS_CORE+31             
cc17 4b cc			dw .SOUT            
cc19 03				db 2 + 1 
cc1a .. 00			db "IN",0              
cc1d				endm 
# End of macro CWHEAD
cc1d			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
cc1d					if DEBUG_FORTH_WORDS_KEY 
cc1d						DMARK "IN." 
cc1d f5				push af  
cc1e 3a 32 cc			ld a, (.dmark)  
cc21 32 6b ee			ld (debug_mark),a  
cc24 3a 33 cc			ld a, (.dmark+1)  
cc27 32 6c ee			ld (debug_mark+1),a  
cc2a 3a 34 cc			ld a, (.dmark+2)  
cc2d 32 6d ee			ld (debug_mark+2),a  
cc30 18 03			jr .pastdmark  
cc32 ..			.dmark: db "IN."  
cc35 f1			.pastdmark: pop af  
cc36			endm  
# End of macro DMARK
cc36						CALLMONITOR 
cc36 cd 6f ee			call debug_vector  
cc39				endm  
# End of macro CALLMONITOR
cc39					endif 
cc39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc39 cd 56 9f			call macro_dsp_valuehl 
cc3c				endm 
# End of macro FORTH_DSP_VALUEHL
cc3c			 
cc3c e5					push hl 
cc3d			 
cc3d					; destroy value TOS 
cc3d			 
cc3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc3d cd 0e a0			call macro_forth_dsp_pop 
cc40				endm 
# End of macro FORTH_DSP_POP
cc40			 
cc40					; one value on hl get other one back 
cc40			 
cc40 c1					pop bc 
cc41			 
cc41					; do the sub 
cc41			;		ex de, hl 
cc41			 
cc41 ed 68				in l,(c) 
cc43			 
cc43					; save it 
cc43			 
cc43 26 00				ld h,0 
cc45			 
cc45					; TODO push value back onto stack for another op etc 
cc45			 
cc45 cd 5f 9d				call forth_push_numhl 
cc48					NEXTW 
cc48 c3 0c a1			jp macro_next 
cc4b				endm 
# End of macro NEXTW
cc4b			.SOUT: 
cc4b				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
cc4b 34				db WORD_SYS_CORE+32             
cc4c 9e cc			dw .SPIO            
cc4e 04				db 3 + 1 
cc4f .. 00			db "OUT",0              
cc53				endm 
# End of macro CWHEAD
cc53			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
cc53					if DEBUG_FORTH_WORDS_KEY 
cc53						DMARK "OUT" 
cc53 f5				push af  
cc54 3a 68 cc			ld a, (.dmark)  
cc57 32 6b ee			ld (debug_mark),a  
cc5a 3a 69 cc			ld a, (.dmark+1)  
cc5d 32 6c ee			ld (debug_mark+1),a  
cc60 3a 6a cc			ld a, (.dmark+2)  
cc63 32 6d ee			ld (debug_mark+2),a  
cc66 18 03			jr .pastdmark  
cc68 ..			.dmark: db "OUT"  
cc6b f1			.pastdmark: pop af  
cc6c			endm  
# End of macro DMARK
cc6c						CALLMONITOR 
cc6c cd 6f ee			call debug_vector  
cc6f				endm  
# End of macro CALLMONITOR
cc6f					endif 
cc6f			 
cc6f					; get port 
cc6f			 
cc6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc6f cd 56 9f			call macro_dsp_valuehl 
cc72				endm 
# End of macro FORTH_DSP_VALUEHL
cc72			 
cc72 e5					push hl 
cc73			 
cc73					; destroy value TOS 
cc73			 
cc73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc73 cd 0e a0			call macro_forth_dsp_pop 
cc76				endm 
# End of macro FORTH_DSP_POP
cc76			 
cc76					; get byte to send 
cc76			 
cc76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc76 cd 56 9f			call macro_dsp_valuehl 
cc79				endm 
# End of macro FORTH_DSP_VALUEHL
cc79			 
cc79			;		push hl 
cc79			 
cc79					; destroy value TOS 
cc79			 
cc79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc79 cd 0e a0			call macro_forth_dsp_pop 
cc7c				endm 
# End of macro FORTH_DSP_POP
cc7c			 
cc7c					; one value on hl get other one back 
cc7c			 
cc7c			;		pop hl 
cc7c			 
cc7c c1					pop bc 
cc7d			 
cc7d					if DEBUG_FORTH_WORDS 
cc7d						DMARK "OUT" 
cc7d f5				push af  
cc7e 3a 92 cc			ld a, (.dmark)  
cc81 32 6b ee			ld (debug_mark),a  
cc84 3a 93 cc			ld a, (.dmark+1)  
cc87 32 6c ee			ld (debug_mark+1),a  
cc8a 3a 94 cc			ld a, (.dmark+2)  
cc8d 32 6d ee			ld (debug_mark+2),a  
cc90 18 03			jr .pastdmark  
cc92 ..			.dmark: db "OUT"  
cc95 f1			.pastdmark: pop af  
cc96			endm  
# End of macro DMARK
cc96						CALLMONITOR 
cc96 cd 6f ee			call debug_vector  
cc99				endm  
# End of macro CALLMONITOR
cc99					endif 
cc99			 
cc99 ed 69				out (c), l 
cc9b			 
cc9b					NEXTW 
cc9b c3 0c a1			jp macro_next 
cc9e				endm 
# End of macro NEXTW
cc9e			 
cc9e			 
cc9e			.SPIO: 
cc9e			 
cc9e			if STORAGE_SE 
cc9e				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
cc9e			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
cc9e			 
cc9e					call spi_ce_low 
cc9e			    NEXTW 
cc9e			 
cc9e			.SPICEH: 
cc9e				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
cc9e			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
cc9e			 
cc9e					call spi_ce_high 
cc9e			    NEXTW 
cc9e			 
cc9e			 
cc9e			.SPIOb: 
cc9e			 
cc9e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
cc9e			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
cc9e			 
cc9e					if DEBUG_FORTH_WORDS_KEY 
cc9e						DMARK "SPo" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e					; get port 
cc9e			 
cc9e			 
cc9e					; get byte to send 
cc9e			 
cc9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc9e			 
cc9e			;		push hl    ; u1  
cc9e			 
cc9e					; destroy value TOS 
cc9e			 
cc9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc9e			 
cc9e					; one value on hl get other one back 
cc9e			 
cc9e			;		pop hl   ; u2 - addr 
cc9e			 
cc9e					; TODO Send SPI byte 
cc9e			 
cc9e			;		push hl 
cc9e			;		call spi_ce_low 
cc9e			;		pop hl 
cc9e					ld a, l 
cc9e					call spi_send_byte 
cc9e			;		call spi_ce_high 
cc9e			 
cc9e					NEXTW 
cc9e			 
cc9e			.SPII: 
cc9e				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
cc9e			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
cc9e					if DEBUG_FORTH_WORDS_KEY 
cc9e						DMARK "SPi" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e			 
cc9e					; TODO Get SPI byte 
cc9e			 
cc9e					call spi_read_byte 
cc9e			 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "Si2" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e					ld h, 0 
cc9e					ld l, a 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "Si3" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e					call forth_push_numhl 
cc9e			 
cc9e					NEXTW 
cc9e			 
cc9e			 
cc9e			 
cc9e			.SESEL: 
cc9e				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
cc9e			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
cc9e					if DEBUG_FORTH_WORDS_KEY 
cc9e						DMARK "BNK" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e			 
cc9e					ld a, 255 
cc9e					ld (spi_cartdev), a 
cc9e			 
cc9e					; get bank 
cc9e			 
cc9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc9e			 
cc9e			;		push hl 
cc9e			 
cc9e					; destroy value TOS 
cc9e			 
cc9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc9e			 
cc9e					; one value on hl get other one back 
cc9e			 
cc9e			;		pop hl 
cc9e			 
cc9e			 
cc9e					ld c, SPI_CE_HIGH 
cc9e					ld b, '0'    ; human readable bank number 
cc9e			 
cc9e					ld a, l 
cc9e			 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "BNK" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e			 
cc9e					; active low 
cc9e			 
cc9e					cp 0 
cc9e					jr z, .bset 
cc9e					cp 1 
cc9e					jr nz, .b2 
cc9e					res 0, c 
cc9e					ld b, '1'    ; human readable bank number 
cc9e			.b2:		cp 2 
cc9e					jr nz, .b3 
cc9e					res 1, c 
cc9e					ld b, '2'    ; human readable bank number 
cc9e			.b3:		cp 3 
cc9e					jr nz, .b4 
cc9e					res 2, c 
cc9e					ld b, '3'    ; human readable bank number 
cc9e			.b4:		cp 4 
cc9e					jr nz, .b5 
cc9e					res 3, c 
cc9e					ld b, '4'    ; human readable bank number 
cc9e			.b5:		cp 5 
cc9e					jr nz, .bset 
cc9e					res 4, c 
cc9e					ld b, '5'    ; human readable bank number 
cc9e			 
cc9e			.bset: 
cc9e					ld a, c 
cc9e					ld (spi_device),a 
cc9e					ld a, b 
cc9e					ld (spi_device_id),a 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "BN2" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e			 
cc9e					; set default SPI clk pulse time as disabled for BANK use 
cc9e			 
cc9e					ld a, 0 
cc9e					ld (spi_clktime), a 
cc9e			 
cc9e					NEXTW 
cc9e			 
cc9e			.CARTDEV: 
cc9e				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
cc9e			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
cc9e					if DEBUG_FORTH_WORDS_KEY 
cc9e						DMARK "CDV" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e			 
cc9e					; disable se storage bank selection 
cc9e			 
cc9e					ld a, SPI_CE_HIGH		; ce high 
cc9e					ld (spi_device), a 
cc9e			 
cc9e					; get bank 
cc9e			 
cc9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cc9e			 
cc9e			;		push hl 
cc9e			 
cc9e					; destroy value TOS 
cc9e			 
cc9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc9e			 
cc9e					; one value on hl get other one back 
cc9e			 
cc9e			;		pop hl 
cc9e			 
cc9e					; active low 
cc9e			 
cc9e					ld c, 255 
cc9e			 
cc9e					ld a, l 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "CDV" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e					cp 0 
cc9e					jr z, .cset 
cc9e					cp 1 
cc9e					jr nz, .c2 
cc9e					res 0, c 
cc9e			.c2:		cp 2 
cc9e					jr nz, .c3 
cc9e					res 1, c 
cc9e			.c3:		cp 3 
cc9e					jr nz, .c4 
cc9e					res 2, c 
cc9e			.c4:		cp 4 
cc9e					jr nz, .c5 
cc9e					res 3, c 
cc9e			.c5:		cp 5 
cc9e					jr nz, .c6 
cc9e					res 4, c 
cc9e			.c6:		cp 6 
cc9e					jr nz, .c7 
cc9e					res 5, c 
cc9e			.c7:		cp 7 
cc9e					jr nz, .c8 
cc9e					res 6, c 
cc9e			.c8:		cp 8 
cc9e					jr nz, .cset 
cc9e					res 7, c 
cc9e			.cset:		ld a, c 
cc9e					ld (spi_cartdev),a 
cc9e			 
cc9e					if DEBUG_FORTH_WORDS 
cc9e						DMARK "CD2" 
cc9e						CALLMONITOR 
cc9e					endif 
cc9e			 
cc9e					; set default SPI clk pulse time as 10ms for CARTDEV use 
cc9e			 
cc9e					ld a, $0a 
cc9e					ld (spi_clktime), a 
cc9e					NEXTW 
cc9e			endif 
cc9e			 
cc9e			.ENDDEVICE: 
cc9e			; eof 
cc9e			 
# End of file forth_words_device.asm
cc9e			 
cc9e			; var handler 
cc9e			 
cc9e			 
cc9e			.VARS: 
cc9e				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
cc9e 77				db WORD_SYS_CORE+99             
cc9f 4f cd			dw .V0            
cca1 04				db 3 + 1 
cca2 .. 00			db "VAR",0              
cca6				endm 
# End of macro CWHEAD
cca6			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
cca6			;| 
cca6			;| The variable name should consist of a single letter. e.g. "a" 
cca6			;! If a full string is passed then only the first char is looked at 
cca6			;| Any other char could exceed bounds checks!  
cca6			 
cca6					if DEBUG_FORTH_WORDS_KEY 
cca6						DMARK "VAR" 
cca6 f5				push af  
cca7 3a bb cc			ld a, (.dmark)  
ccaa 32 6b ee			ld (debug_mark),a  
ccad 3a bc cc			ld a, (.dmark+1)  
ccb0 32 6c ee			ld (debug_mark+1),a  
ccb3 3a bd cc			ld a, (.dmark+2)  
ccb6 32 6d ee			ld (debug_mark+2),a  
ccb9 18 03			jr .pastdmark  
ccbb ..			.dmark: db "VAR"  
ccbe f1			.pastdmark: pop af  
ccbf			endm  
# End of macro DMARK
ccbf						CALLMONITOR 
ccbf cd 6f ee			call debug_vector  
ccc2				endm  
# End of macro CALLMONITOR
ccc2					endif 
ccc2			 
ccc2					FORTH_DSP_VALUEHL 
ccc2 cd 56 9f			call macro_dsp_valuehl 
ccc5				endm 
# End of macro FORTH_DSP_VALUEHL
ccc5			 
ccc5 7e					ld a, (hl)    ; get first char on of the string 
ccc6			 
ccc6			 
ccc6					if DEBUG_FORTH_WORDS 
ccc6						DMARK "VR1" 
ccc6 f5				push af  
ccc7 3a db cc			ld a, (.dmark)  
ccca 32 6b ee			ld (debug_mark),a  
cccd 3a dc cc			ld a, (.dmark+1)  
ccd0 32 6c ee			ld (debug_mark+1),a  
ccd3 3a dd cc			ld a, (.dmark+2)  
ccd6 32 6d ee			ld (debug_mark+2),a  
ccd9 18 03			jr .pastdmark  
ccdb ..			.dmark: db "VR1"  
ccde f1			.pastdmark: pop af  
ccdf			endm  
# End of macro DMARK
ccdf						CALLMONITOR 
ccdf cd 6f ee			call debug_vector  
cce2				endm  
# End of macro CALLMONITOR
cce2					endif 
cce2					 
cce2 f5					push af	 
cce3					FORTH_DSP_POP 
cce3 cd 0e a0			call macro_forth_dsp_pop 
cce6				endm 
# End of macro FORTH_DSP_POP
cce6 f1					pop af 
cce7			 
cce7					; convert to upper 
cce7			 
cce7 cd 60 92				call to_upper 
ccea					if DEBUG_FORTH_WORDS 
ccea						DMARK "Vaa" 
ccea f5				push af  
cceb 3a ff cc			ld a, (.dmark)  
ccee 32 6b ee			ld (debug_mark),a  
ccf1 3a 00 cd			ld a, (.dmark+1)  
ccf4 32 6c ee			ld (debug_mark+1),a  
ccf7 3a 01 cd			ld a, (.dmark+2)  
ccfa 32 6d ee			ld (debug_mark+2),a  
ccfd 18 03			jr .pastdmark  
ccff ..			.dmark: db "Vaa"  
cd02 f1			.pastdmark: pop af  
cd03			endm  
# End of macro DMARK
cd03						CALLMONITOR 
cd03 cd 6f ee			call debug_vector  
cd06				endm  
# End of macro CALLMONITOR
cd06					endif 
cd06 06 41				ld b, 'A' 
cd08 90					sub b			; set offset 
cd09					if DEBUG_FORTH_WORDS 
cd09						DMARK "Vbb" 
cd09 f5				push af  
cd0a 3a 1e cd			ld a, (.dmark)  
cd0d 32 6b ee			ld (debug_mark),a  
cd10 3a 1f cd			ld a, (.dmark+1)  
cd13 32 6c ee			ld (debug_mark+1),a  
cd16 3a 20 cd			ld a, (.dmark+2)  
cd19 32 6d ee			ld (debug_mark+2),a  
cd1c 18 03			jr .pastdmark  
cd1e ..			.dmark: db "Vbb"  
cd21 f1			.pastdmark: pop af  
cd22			endm  
# End of macro DMARK
cd22						CALLMONITOR 
cd22 cd 6f ee			call debug_vector  
cd25				endm  
# End of macro CALLMONITOR
cd25					endif 
cd25 cb 27				sla a  
cd27				 
cd27					 
cd27					if DEBUG_FORTH_WORDS 
cd27						DMARK "VR2" 
cd27 f5				push af  
cd28 3a 3c cd			ld a, (.dmark)  
cd2b 32 6b ee			ld (debug_mark),a  
cd2e 3a 3d cd			ld a, (.dmark+1)  
cd31 32 6c ee			ld (debug_mark+1),a  
cd34 3a 3e cd			ld a, (.dmark+2)  
cd37 32 6d ee			ld (debug_mark+2),a  
cd3a 18 03			jr .pastdmark  
cd3c ..			.dmark: db "VR2"  
cd3f f1			.pastdmark: pop af  
cd40			endm  
# End of macro DMARK
cd40						CALLMONITOR 
cd40 cd 6f ee			call debug_vector  
cd43				endm  
# End of macro CALLMONITOR
cd43					endif 
cd43			 
cd43 21 f4 e9				ld hl, cli_var_array2 
cd46 cd db 8c				call addatohl 
cd49 cd 5f 9d				call forth_push_numhl 
cd4c			 
cd4c			 
cd4c				       NEXTW 
cd4c c3 0c a1			jp macro_next 
cd4f				endm 
# End of macro NEXTW
cd4f			.V0: 
cd4f				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
cd4f 78				db WORD_SYS_CORE+100             
cd50 67 cd			dw .V0Q            
cd52 04				db 3 + 1 
cd53 .. 00			db "V0!",0              
cd57				endm 
# End of macro CWHEAD
cd57			;| V0! ( u1 -- )  Store value to v0  | DONE 
cd57			 
cd57					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cd57 cd 56 9f			call macro_dsp_valuehl 
cd5a				endm 
# End of macro FORTH_DSP_VALUEHL
cd5a			 
cd5a 11 28 ea				ld de, cli_var_array 
cd5d			 
cd5d eb					ex de, hl 
cd5e 73					ld (hl), e 
cd5f 23					inc hl 
cd60 72					ld (hl), d 
cd61			 
cd61					; destroy value TOS 
cd61			 
cd61					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cd61 cd 0e a0			call macro_forth_dsp_pop 
cd64				endm 
# End of macro FORTH_DSP_POP
cd64			 
cd64				       NEXTW 
cd64 c3 0c a1			jp macro_next 
cd67				endm 
# End of macro NEXTW
cd67			.V0Q: 
cd67				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cd67 79				db WORD_SYS_CORE+101             
cd68 78 cd			dw .V1S            
cd6a 04				db 3 + 1 
cd6b .. 00			db "V0@",0              
cd6f				endm 
# End of macro CWHEAD
cd6f			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cd6f 2a 28 ea				ld hl, (cli_var_array) 
cd72 cd 5f 9d				call forth_push_numhl 
cd75			 
cd75				       NEXTW 
cd75 c3 0c a1			jp macro_next 
cd78				endm 
# End of macro NEXTW
cd78			.V1S: 
cd78				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cd78 7a				db WORD_SYS_CORE+102             
cd79 90 cd			dw .V1Q            
cd7b 04				db 3 + 1 
cd7c .. 00			db "V1!",0              
cd80				endm 
# End of macro CWHEAD
cd80			;| V1! ( u1 -- )  Store value to v1 | DONE 
cd80					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cd80 cd 56 9f			call macro_dsp_valuehl 
cd83				endm 
# End of macro FORTH_DSP_VALUEHL
cd83			 
cd83 11 2a ea				ld de, cli_var_array+2 
cd86				 
cd86 eb					ex de, hl 
cd87 73					ld (hl), e 
cd88 23					inc hl 
cd89 72					ld (hl), d 
cd8a			 
cd8a					; destroy value TOS 
cd8a			 
cd8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cd8a cd 0e a0			call macro_forth_dsp_pop 
cd8d				endm 
# End of macro FORTH_DSP_POP
cd8d				       NEXTW 
cd8d c3 0c a1			jp macro_next 
cd90				endm 
# End of macro NEXTW
cd90			.V1Q: 
cd90				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cd90 7b				db WORD_SYS_CORE+103             
cd91 a1 cd			dw .V2S            
cd93 04				db 3 + 1 
cd94 .. 00			db "V1@",0              
cd98				endm 
# End of macro CWHEAD
cd98			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cd98 2a 2a ea				ld hl, (cli_var_array+2) 
cd9b cd 5f 9d				call forth_push_numhl 
cd9e				       NEXTW 
cd9e c3 0c a1			jp macro_next 
cda1				endm 
# End of macro NEXTW
cda1			.V2S: 
cda1				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cda1 7c				db WORD_SYS_CORE+104             
cda2 b9 cd			dw .V2Q            
cda4 04				db 3 + 1 
cda5 .. 00			db "V2!",0              
cda9				endm 
# End of macro CWHEAD
cda9			;| V2! ( u1 -- )  Store value to v2 | DONE 
cda9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cda9 cd 56 9f			call macro_dsp_valuehl 
cdac				endm 
# End of macro FORTH_DSP_VALUEHL
cdac			 
cdac 11 2c ea				ld de, cli_var_array+4 
cdaf				 
cdaf eb					ex de, hl 
cdb0 73					ld (hl), e 
cdb1 23					inc hl 
cdb2 72					ld (hl), d 
cdb3			 
cdb3					; destroy value TOS 
cdb3			 
cdb3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cdb3 cd 0e a0			call macro_forth_dsp_pop 
cdb6				endm 
# End of macro FORTH_DSP_POP
cdb6				       NEXTW 
cdb6 c3 0c a1			jp macro_next 
cdb9				endm 
# End of macro NEXTW
cdb9			.V2Q: 
cdb9				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cdb9 7d				db WORD_SYS_CORE+105             
cdba ca cd			dw .V3S            
cdbc 04				db 3 + 1 
cdbd .. 00			db "V2@",0              
cdc1				endm 
# End of macro CWHEAD
cdc1			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cdc1 2a 2c ea				ld hl, (cli_var_array+4) 
cdc4 cd 5f 9d				call forth_push_numhl 
cdc7				       NEXTW 
cdc7 c3 0c a1			jp macro_next 
cdca				endm 
# End of macro NEXTW
cdca			.V3S: 
cdca				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cdca 7c				db WORD_SYS_CORE+104             
cdcb e2 cd			dw .V3Q            
cdcd 04				db 3 + 1 
cdce .. 00			db "V3!",0              
cdd2				endm 
# End of macro CWHEAD
cdd2			;| V3! ( u1 -- )  Store value to v3 | DONE 
cdd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cdd2 cd 56 9f			call macro_dsp_valuehl 
cdd5				endm 
# End of macro FORTH_DSP_VALUEHL
cdd5			 
cdd5 11 2e ea				ld de, cli_var_array+6 
cdd8				 
cdd8 eb					ex de, hl 
cdd9 73					ld (hl), e 
cdda 23					inc hl 
cddb 72					ld (hl), d 
cddc			 
cddc					; destroy value TOS 
cddc			 
cddc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cddc cd 0e a0			call macro_forth_dsp_pop 
cddf				endm 
# End of macro FORTH_DSP_POP
cddf				       NEXTW 
cddf c3 0c a1			jp macro_next 
cde2				endm 
# End of macro NEXTW
cde2			.V3Q: 
cde2				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cde2 7d				db WORD_SYS_CORE+105             
cde3 f3 cd			dw .END            
cde5 04				db 3 + 1 
cde6 .. 00			db "V3@",0              
cdea				endm 
# End of macro CWHEAD
cdea			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cdea 2a 2e ea				ld hl, (cli_var_array+6) 
cded cd 5f 9d				call forth_push_numhl 
cdf0				       NEXTW 
cdf0 c3 0c a1			jp macro_next 
cdf3				endm 
# End of macro NEXTW
cdf3			 
cdf3			 
cdf3			 
cdf3			 
cdf3			 
cdf3			; end of dict marker 
cdf3			 
cdf3 00			.END:    db WORD_SYS_END 
cdf4 00 00			dw 0 
cdf6 00				db 0 
cdf7			 
cdf7			; use to jp here for user dict words to save on macro expansion  
cdf7			 
cdf7			user_dict_next: 
cdf7				NEXTW 
cdf7 c3 0c a1			jp macro_next 
cdfa				endm 
# End of macro NEXTW
cdfa			 
cdfa			 
cdfa			user_exec: 
cdfa				;    ld hl, <word code> 
cdfa				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cdfa				;    call forthexec 
cdfa				;    jp user_dict_next   (NEXT) 
cdfa			        ;    <word code bytes> 
cdfa eb				ex de, hl 
cdfb 2a c2 e5			ld hl,(os_tok_ptr) 
cdfe				 
cdfe				FORTH_RSP_NEXT 
cdfe cd 06 9d			call macro_forth_rsp_next 
ce01				endm 
# End of macro FORTH_RSP_NEXT
ce01			 
ce01			if DEBUG_FORTH_UWORD 
ce01						DMARK "UEX" 
ce01 f5				push af  
ce02 3a 16 ce			ld a, (.dmark)  
ce05 32 6b ee			ld (debug_mark),a  
ce08 3a 17 ce			ld a, (.dmark+1)  
ce0b 32 6c ee			ld (debug_mark+1),a  
ce0e 3a 18 ce			ld a, (.dmark+2)  
ce11 32 6d ee			ld (debug_mark+2),a  
ce14 18 03			jr .pastdmark  
ce16 ..			.dmark: db "UEX"  
ce19 f1			.pastdmark: pop af  
ce1a			endm  
# End of macro DMARK
ce1a				CALLMONITOR 
ce1a cd 6f ee			call debug_vector  
ce1d				endm  
# End of macro CALLMONITOR
ce1d			endif 
ce1d			 
ce1d			 
ce1d			 
ce1d eb				ex de, hl 
ce1e 22 c2 e5			ld (os_tok_ptr), hl 
ce21				 
ce21				; Don't use next - Skips the first word in uword. 
ce21			 
ce21 c3 9d a1			jp exec1 
ce24			;	NEXT 
ce24			 
ce24			 
ce24			; eof 
# End of file forth_wordsv4.asm
ce24			endif 
ce24			;;;;;;;;;;;;;; Debug code 
ce24			 
ce24			 
ce24			;if DEBUG_FORTH_PARSE 
ce24 .. 00		.nowordfound: db "No match",0 
ce2d .. 00		.compword:	db "Comparing word ",0 
ce3d .. 00		.nextwordat:	db "Next word at",0 
ce4a .. 00		.charmatch:	db "Char match",0 
ce55			;endif 
ce55			if DEBUG_FORTH_JP 
ce55			.foundword:	db "Word match. Exec..",0 
ce55			endif 
ce55			;if DEBUG_FORTH_PUSH 
ce55 .. 00		.enddict:	db "Dict end. Push.",0 
ce65 .. 00		.push_str:	db "Pushing string",0 
ce74 .. 00		.push_num:	db "Pushing number",0 
ce83 .. 00		.data_sp:	db "SP:",0 
ce87 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
ce99 .. 00		.wordinde:	db "Word in DE (3/0):",0 
ceab .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cebd			;endif 
cebd			;if DEBUG_FORTH_MALLOC 
cebd .. 00		.push_malloc:	db "Malloc address",0 
cecc			;endif 
cecc			 
cecc			 
cecc			 
cecc			; display malloc address and current data stack pointer  
cecc			 
cecc			malloc_error: 
cecc d5				push de 
cecd f5				push af 
cece e5				push hl 
cecf cd ae 8a			call clear_display 
ced2 11 f2 ce			ld de, .mallocerr 
ced5 3e 00			ld a,0 
ced7			;	ld de,os_word_scratch 
ced7 cd c1 8a			call str_at_display 
ceda 3e 11			ld a, display_row_1+17 
cedc 11 6b ee			ld de, debug_mark 
cedf cd c1 8a			call str_at_display 
cee2 cd d1 8a			call update_display 
cee5				;call break_point_state 
cee5 cd e7 e6			call cin_wait 
cee8			 
cee8			;	ld a, ' ' 
cee8			;	ld (os_view_disable), a 
cee8 cd f5 96			call bp_on 
ceeb e1				pop hl 
ceec f1				pop af 
ceed d1				pop de	 
ceee				CALLMONITOR 
ceee cd 6f ee			call debug_vector  
cef1				endm  
# End of macro CALLMONITOR
cef1 c9				ret 
cef2			 
cef2 .. 00		.mallocerr: 	db "Malloc Error",0 
ceff			;if DEBUG_FORTH_PUSH 
ceff			display_data_sp: 
ceff f5				push af 
cf00			 
cf00				; see if disabled 
cf00			 
cf00			 
cf00 3a 6f ee			ld a, (debug_vector) 
cf03 fe c9			cp $C9  ; RET 
cf05				;ld a, (os_view_disable) 
cf05				;cp '*' 
cf05 28 67			jr z, .skipdsp 
cf07			 
cf07 e5				push hl 
cf08 e5				push hl 
cf09 e5			push hl 
cf0a cd ae 8a			call clear_display 
cf0d e1			pop hl 
cf0e 7c				ld a,h 
cf0f 21 c6 e5			ld hl, os_word_scratch 
cf12 cd f4 91			call hexout 
cf15 e1				pop hl 
cf16 7d				ld a,l 
cf17 21 c8 e5			ld hl, os_word_scratch+2 
cf1a cd f4 91			call hexout 
cf1d 21 ca e5			ld hl, os_word_scratch+4 
cf20 3e 00			ld a,0 
cf22 77				ld (hl),a 
cf23 11 c6 e5			ld de,os_word_scratch 
cf26 3e 28				ld a, display_row_2 
cf28 cd c1 8a				call str_at_display 
cf2b 11 87 ce			ld de, .wordinhl 
cf2e 3e 00			ld a, display_row_1 
cf30			 
cf30 cd c1 8a				call str_at_display 
cf33 11 6b ee			ld de, debug_mark 
cf36 3e 11			ld a, display_row_1+17 
cf38			 
cf38 cd c1 8a				call str_at_display 
cf3b			 
cf3b				; display current data stack pointer 
cf3b 11 83 ce			ld de,.data_sp 
cf3e 3e 30				ld a, display_row_2 + 8 
cf40 cd c1 8a				call str_at_display 
cf43			 
cf43 2a ee e9			ld hl,(cli_data_sp) 
cf46 e5				push hl 
cf47 7c				ld a,h 
cf48 21 c6 e5			ld hl, os_word_scratch 
cf4b cd f4 91			call hexout 
cf4e e1				pop hl 
cf4f 7d				ld a,l 
cf50 21 c8 e5			ld hl, os_word_scratch+2 
cf53 cd f4 91			call hexout 
cf56 21 ca e5			ld hl, os_word_scratch+4 
cf59 3e 00			ld a,0 
cf5b 77				ld (hl),a 
cf5c 11 c6 e5			ld de,os_word_scratch 
cf5f 3e 33				ld a, display_row_2 + 11 
cf61 cd c1 8a				call str_at_display 
cf64			 
cf64			 
cf64 cd d1 8a			call update_display 
cf67 cd f1 89			call delay1s 
cf6a cd f1 89			call delay1s 
cf6d e1				pop hl 
cf6e			.skipdsp: 
cf6e f1				pop af 
cf6f c9				ret 
cf70			 
cf70			display_data_malloc: 
cf70			 
cf70 f5				push af 
cf71 e5				push hl 
cf72 e5				push hl 
cf73 e5			push hl 
cf74 cd ae 8a			call clear_display 
cf77 e1			pop hl 
cf78 7c				ld a,h 
cf79 21 c6 e5			ld hl, os_word_scratch 
cf7c cd f4 91			call hexout 
cf7f e1				pop hl 
cf80 7d				ld a,l 
cf81 21 c8 e5			ld hl, os_word_scratch+2 
cf84 cd f4 91			call hexout 
cf87 21 ca e5			ld hl, os_word_scratch+4 
cf8a 3e 00			ld a,0 
cf8c 77				ld (hl),a 
cf8d 11 c6 e5			ld de,os_word_scratch 
cf90 3e 28				ld a, display_row_2 
cf92 cd c1 8a				call str_at_display 
cf95 11 bd ce			ld de, .push_malloc 
cf98 3e 00			ld a, display_row_1 
cf9a			 
cf9a cd c1 8a				call str_at_display 
cf9d			 
cf9d				; display current data stack pointer 
cf9d 11 83 ce			ld de,.data_sp 
cfa0 3e 30				ld a, display_row_2 + 8 
cfa2 cd c1 8a				call str_at_display 
cfa5			 
cfa5 2a ee e9			ld hl,(cli_data_sp) 
cfa8 e5				push hl 
cfa9 7c				ld a,h 
cfaa 21 c6 e5			ld hl, os_word_scratch 
cfad cd f4 91			call hexout 
cfb0 e1				pop hl 
cfb1 7d				ld a,l 
cfb2 21 c8 e5			ld hl, os_word_scratch+2 
cfb5 cd f4 91			call hexout 
cfb8 21 ca e5			ld hl, os_word_scratch+4 
cfbb 3e 00			ld a,0 
cfbd 77				ld (hl),a 
cfbe 11 c6 e5			ld de,os_word_scratch 
cfc1 3e 33				ld a, display_row_2 + 11 
cfc3 cd c1 8a				call str_at_display 
cfc6			 
cfc6 cd d1 8a			call update_display 
cfc9 cd f1 89			call delay1s 
cfcc cd f1 89			call delay1s 
cfcf e1				pop hl 
cfd0 f1				pop af 
cfd1 c9				ret 
cfd2			;endif 
cfd2			 
cfd2			include "forth_autostart.asm" 
cfd2			; list of commands to perform at system start up 
cfd2			 
cfd2			startcmds: 
cfd2			;	dw test11 
cfd2			;	dw test12 
cfd2			;	dw test13 
cfd2			;	dw test14 
cfd2			;	dw test15 
cfd2			;	dw test16 
cfd2			;	dw test17 
cfd2			;	dw ifthtest1 
cfd2			;	dw ifthtest2 
cfd2			;	dw ifthtest3 
cfd2			;	dw mmtest1 
cfd2			;	dw mmtest2 
cfd2			;	dw mmtest3 
cfd2			;	dw mmtest4 
cfd2			;	dw mmtest5 
cfd2			;	dw mmtest6 
cfd2			;	dw iftest1 
cfd2			;	dw iftest2 
cfd2			;	dw iftest3 
cfd2			;	dw looptest1 
cfd2			;	dw looptest2 
cfd2			;	dw test1 
cfd2			;	dw test2 
cfd2			;	dw test3 
cfd2			;	dw test4 
cfd2			;	dw game2r 
cfd2			;	dw game2b1 
cfd2			;	dw game2b2 
cfd2			 
cfd2				; start up words that are actually useful 
cfd2			 
cfd2			;    dw spi1 
cfd2			;    dw spi2 
cfd2			;    dw spi3 
cfd2			;    dw spi4 
cfd2			;    dw spi5 
cfd2			;    dw spi6 
cfd2			;    dw spi7 
cfd2			; 
cfd2			;    dw spi8 
cfd2			;    dw spi9 
cfd2			;    dw spi10 
cfd2			 
cfd2			; file editor 
cfd2			;	dw edit1 
cfd2			;	dw edit2 
cfd2			;	dw edit3 
cfd2			 
cfd2			;	dw longread 
cfd2 fc d3			dw clrstack 
cfd4 30 d4			dw type 
cfd6			;	dw stest 
cfd6 55 d4			dw strncpy 
cfd8			;	dw list 
cfd8 b6 d4			dw start1 
cfda c6 d4			dw start2 
cfdc			;	dw start3 
cfdc			;	dw start3b 
cfdc			;	dw start3c 
cfdc			 
cfdc				; (unit) testing words 
cfdc			 
cfdc			;	dw mtesta 
cfdc			;	dw mtestb 
cfdc			;	dw mtestc 
cfdc			;	dw mtestd 
cfdc			;	dw mteste 
cfdc			 
cfdc				; demo/game words 
cfdc			 
cfdc			;        dw game3w 
cfdc			;        dw game3p 
cfdc			;        dw game3sc 
cfdc			;        dw game3vsi 
cfdc			;        dw game3vs 
cfdc				 
cfdc 1f df			dw game2b 
cfde 8d df			dw game2bf 
cfe0 d7 df			dw game2mba 
cfe2 6d e0			dw game2mbas 
cfe4 af e0			dw game2mb 
cfe6			 
cfe6 e0 db			dw game1 
cfe8 f1 db			dw game1a 
cfea 53 dc			dw game1b 
cfec 88 dc			dw game1c 
cfee be dc			dw game1d 
cff0 ef dc			dw game1s 
cff2 03 dd			dw game1t 
cff4 18 dd			dw game1f 
cff6 4c dd			dw game1z 
cff8 90 dd			dw game1zz 
cffa			 
cffa fa d9			dw test5 
cffc 32 da			dw test6 
cffe 6a da			dw test7 
d000 7e da			dw test8 
d002 aa da			dw test9 
d004 c0 da			dw test10 
d006				 
d006 67 de		        dw ssv5 
d008 4b de		        dw ssv4 
d00a 2f de		        dw ssv3 
d00c f9 dd		        dw ssv2 
d00e 80 de		        dw ssv1 
d010 c8 de		        dw ssv1cpm 
d012			;	dw keyup 
d012			;	dw keydown 
d012			;	dw keyleft 
d012			;	dw keyright 
d012			;	dw 	keyf1 
d012			;	dw keyf2 
d012			;	dw keyf3 
d012			;	dw keyf4 
d012			;	dw keyf5 
d012			;	dw keyf6 
d012			;	dw keyf7 
d012			;	dw keyf8 
d012			;	dw keyf9 
d012			;	dw keyf10 
d012			;	dw keyf11 
d012			;	dw keyf12 
d012			;	dw keytab 
d012			;	dw keycr 
d012			;	dw keyhome 
d012			;	dw keyend 
d012			;	dw keybs 
d012 00 00			db 0, 0	 
d014			 
d014			 
d014			; File Editor 
d014			 
d014			; ( id - ) use 'e' to edit the displayed line 
d014 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
d035 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d06a			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d06a .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d0a2			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d0a2			 
d0a2			; SPI Net support words 
d0a2			 
d0a2			; v0! = node to send to 
d0a2			; ( str count - ) 
d0a2 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d0fb			 
d0fb			; spiputc ( char node - ) 
d0fb .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d12f			; spiputc ( u node - ) 
d12f .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d15d			 
d15d			; spigetc ( - n ) 
d15d .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d186			 
d186			; getnode ( - n ) 
d186 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d1b3			 
d1b3			; ( str node - )  
d1b3 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d219			; store string ( str i - ) 
d219			 
d219			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d219 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d26e			 
d26e			; get string ( addr i -  )    TO FIX 
d26e			 
d26e .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d2c6			 
d2c6			 
d2c6			; NETCHAT (TODO) 
d2c6			; Program to allow two nodes to chat with eachother 
d2c6			; 
d2c6			; v0 - target node 
d2c6			;  
d2c6			; accept input at 0,0 
d2c6			; if input is string send spitype to target node 
d2c6			; starting at row 2,0 , while spigetchr is not zero ->  
d2c6			; 
d2c6			; 
d2c6			; TODO add paging of get request 
d2c6			 
d2c6			; ( node - ) 
d2c6 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d2e5 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d33d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d3b5			 
d3b5			 
d3b5			; Long read of currently open file 
d3b5 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d3fc			 
d3fc			; clear stack  
d3fc			 
d3fc .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d430			 
d430			; type ( addr count - ) 
d430 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d455			 
d455			; some direct memory words 
d455			; strncpy ( len t f -- t ) 
d455			 
d455 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d4b6			 
d4b6 .. 00		start1:     	db ": bpon $00 bp ;",0 
d4c6 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d4d7 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d552 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d5b2			 
d5b2			 
d5b2			; a handy word to list items on the stack 
d5b2			 
d5b2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d61c			 
d61c			 
d61c			; test stack  
d61c			; rnd8 stest 
d61c			 
d61c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d693			 
d693			; random malloc and free cycles 
d693			 
d693 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d748			 
d748			; fixed malloc and free cycles 
d748			 
d748 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d7eb			 
d7eb			; fixed double string push and drop cycle  
d7eb			 
d7eb .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d8a0			 
d8a0			; consistent fixed string push and drop cycle  
d8a0			 
d8a0 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d944			 
d944 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d9fa			 
d9fa			;test1:		db ": aa 1 2 3 ;", 0 
d9fa			;test2:     	db "111 aa 888 999",0 
d9fa			;test3:     	db ": bb 77 ;",0 
d9fa			;test4:     	db "$02 $01 do i . loop bb",0 
d9fa			 
d9fa .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
da32 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
da6a .. 00		test7:     	db ": box hline vline ;",0 
da7e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
daaa .. 00		test9:     	db ": sw $01 adsp world ;",0 
dac0 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
dae5 .. 00		test11:     	db "hello create .",0 
daf4 .. 00		test12:     	db "hello2 create .",0 
db04			 
db04			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
db04			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
db04			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
db04			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
db04			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
db04			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
db04			 
db04			;iftest1:     	db "$0001 IF cls .",0 
db04			;iftest2:     	db "$0000 IF cls .",0 
db04			;iftest3:     	db "$0002 $0003 - IF cls .",0 
db04			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
db04			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
db04			 
db04			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
db04			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
db04			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
db04			 
db04			 
db04 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
db28 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
db58 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
db7d .. 00		sound4: db ": cha $00 ; ",0 
db8a .. 00		sound5: db ": chb $20 ; ",0 
db97 .. 00		sound6: db ": chc $40 ; ",0 
dba4 .. 00		sound7: db ": chd $60 ; ",0 
dbb1 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
dbc9 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
dbe0			 
dbe0			 
dbe0			 
dbe0			 
dbe0			; a small guess the number game 
dbe0			 
dbe0 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
dbf1 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
dc53			 
dc53 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
dc88 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
dcbe .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
dcef .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
dd03 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
dd18 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dd4c .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dd90			 
dd90			; Using 'ga' save a high score across multiple runs using external storage 
dd90			 
dd90 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ddf9			 
ddf9			 
ddf9			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ddf9			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ddf9			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ddf9			 
ddf9			; simple screen saver to test code memory reuse to destruction 
ddf9			 
ddf9 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
de2f .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
de4b .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
de67 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
de80 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dec8 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
df1f			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
df1f			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
df1f			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
df1f			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
df1f			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
df1f			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
df1f			 
df1f			 
df1f			 
df1f			; minesweeper/battleship finding game 
df1f			; draws a game board of random ship/mine positions 
df1f			; user enters coords to see if it hits on 
df1f			; game ends when all are hit 
df1f			; when hit or miss says how many may be in the area 
df1f			 
df1f			; setup the game board and then hide it 
df1f .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
df8d .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dfd7			; prompt for where to target 
dfd7 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
e06d .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
e092			; TODO see if the entered coords hits or misses pushes char hit of miss 
e092 .. 00		game2mbht:      db ": mbckht nop ;",0 
e0a1 .. 00		game2mbms:      db ": mbcms nop ;",0 
e0af			; TODO how many might be near by 
e0af .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
e12c			 
e12c			; Game 3 
e12c			 
e12c			; Vert scroller ski game - avoid the trees! 
e12c			 
e12c			; v0 score (ie turns) 
e12c			; v1 player pos 
e12c			; v2 left wall 
e12c			; v3 right wall 
e12c			 
e12c			; Draw side walls randomly 
e12c			 
e12c .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
e15a			 
e15a			; Draw player 
e15a .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
e178			 
e178			; TODO Get Key 
e178			 
e178			; TODO Move left right 
e178			 
e178			; scroll and move walls a bit 
e178			 
e178 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
e1a9			 
e1a9			; main game loop 
e1a9			 
e1a9 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
e1d5 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
e214			 
e214			; key board defs 
e214			 
e214 .. 00		keyup:       db ": keyup $05 ;",0 
e222 .. 00		keydown:       db ": keydown $0a ;",0 
e232 .. 00		keyleft:       db ": keyleft $0b ;",0 
e242 .. 00		keyright:       db ": keyright $0c ;",0 
e253 .. 00		keyf1:       db ": keyf1 $10 ;",0 
e261 .. 00		keyf2:       db ": keyf2 $11 ;",0 
e26f .. 00		keyf3:       db ": keyf3 $12 ;",0 
e27d .. 00		keyf4:       db ": keyf4 $13 ;",0 
e28b .. 00		keyf5:       db ": keyf5 $14 ;",0 
e299 .. 00		keyf6:       db ": keyf6 $15 ;",0 
e2a7 .. 00		keyf7:       db ": keyf7 $16 ;",0 
e2b5 .. 00		keyf8:       db ": keyf8 $17 ;",0 
e2c3 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e2d1 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e2e0 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e2ef .. 00		keyf12:       db ": keyf12 $1b ;",0 
e2fe			 
e2fe .. 00		keytab:       db ": keytab $09 ;",0 
e30d .. 00		keycr:       db ": keycr $0d ;",0 
e31b .. 00		keyhome:       db ": keyhome $0e ;",0 
e32b .. 00		keyend:       db ": keyend $0f ;",0 
e33a .. 00		keybs:       db ": keybs $08 ;",0 
e348			 
e348			   
e348			 
e348			 
e348			 
e348			; eof 
# End of file forth_autostart.asm
e348			 
e348			 
e348			 
e348			; stack over and underflow checks 
e348			 
e348			; init the words to detect the under/overflow 
e348			 
e348			chk_stk_init: 
e348				; a vague random number to check so we dont get any "lucky" hits 
e348 3e 2d			ld a, 45 
e34a 6f				ld l, a 
e34b 00				nop 
e34c 3e 17			ld a, 23 
e34e 67				ld h, a 
e34f			 
e34f 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e352			 
e352			;	ld (chk_stund), hl	; stack points.... 
e352 22 00 ef			ld (chk_stovr), hl 
e355 22 ec e9			ld (chk_ret_und), hl 
e358 22 aa e9			ld (chk_ret_ovr), hl 
e35b 22 28 e9			ld (chk_loop_ovr), hl 
e35e 22 26 e8			ld (chk_data_ovr), hl 
e361 c9				ret 
e362				 
e362			check_stacks: 
e362				; check all stack words 
e362			 
e362 e5				push hl 
e363 d5				push de 
e364			 
e364			;	ld de,(chk_word) 
e364			;	ld hl, (chk_stund)	; stack points.... 
e364			;	if DEBUG_STK_FAULT 
e364			;		DMARK "FAa" 
e364			;		CALLMONITOR 
e364			;	endif 
e364			;	call cmp16 
e364			;	jp z, .chk_faulta 
e364			; 
e364			;	ld de, sfaultsu 
e364			;	jp .chk_fault 
e364			 
e364 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e367 ed 5b 9d e2		ld de,(chk_word) 
e36b				if DEBUG_STK_FAULT 
e36b					DMARK "FAb" 
e36b					CALLMONITOR 
e36b				endif 
e36b cd f9 8c			call cmp16 
e36e 28 06			jr z, .chk_fault1 
e370 11 11 e4			ld de, sfaultso 
e373 c3 c5 e3			jp .chk_fault 
e376			.chk_fault1:  
e376 2a ec e9			ld hl, (chk_ret_und) 
e379 ed 5b 9d e2		ld de,(chk_word) 
e37d				if DEBUG_STK_FAULT 
e37d					DMARK "FAU" 
e37d					CALLMONITOR 
e37d				endif 
e37d cd f9 8c			call cmp16 
e380 ca 89 e3			jp z, .chk_fault2 
e383 11 21 e4			ld de, sfaultru 
e386 c3 c5 e3			jp .chk_fault 
e389			.chk_fault2:  
e389 2a aa e9			ld hl, (chk_ret_ovr) 
e38c ed 5b 9d e2		ld de,(chk_word) 
e390				if DEBUG_STK_FAULT 
e390					DMARK "FA1" 
e390					CALLMONITOR 
e390				endif 
e390 cd f9 8c			call cmp16 
e393 ca 9c e3			jp z, .chk_fault3 
e396 11 2f e4			ld de, sfaultro 
e399 c3 c5 e3			jp .chk_fault 
e39c			.chk_fault3:  
e39c 2a 28 e9			ld hl, (chk_loop_ovr) 
e39f ed 5b 9d e2		ld de,(chk_word) 
e3a3				if DEBUG_STK_FAULT 
e3a3					DMARK "FA2" 
e3a3					CALLMONITOR 
e3a3				endif 
e3a3 cd f9 8c			call cmp16 
e3a6 ca af e3			jp z, .chk_fault4 
e3a9 11 49 e4			ld de, sfaultlo 
e3ac c3 c5 e3			jp .chk_fault 
e3af			.chk_fault4:  
e3af 2a 26 e8			ld hl, (chk_data_ovr) 
e3b2 ed 5b 9d e2		ld de,(chk_word) 
e3b6				if DEBUG_STK_FAULT 
e3b6					DMARK "FA3" 
e3b6					CALLMONITOR 
e3b6				endif 
e3b6 cd f9 8c			call cmp16 
e3b9 ca c2 e3			jp z, .chk_fault5 
e3bc 11 63 e4			ld de, sfaultdo 
e3bf c3 c5 e3			jp .chk_fault 
e3c2			 
e3c2			 
e3c2			.chk_fault5:  
e3c2 d1				pop de 
e3c3 e1				pop hl 
e3c4			 
e3c4 c9				ret 
e3c5			 
e3c5 cd ae 8a		.chk_fault: 	call clear_display 
e3c8 3e 28				ld a, display_row_2 
e3ca cd c1 8a				call str_at_display 
e3cd 11 f3 e3				   ld de, .stackfault 
e3d0 3e 00				ld a, display_row_1 
e3d2 cd c1 8a				call str_at_display 
e3d5 11 6b ee				    ld de, debug_mark 
e3d8 3e 11				ld a, display_row_1+17 
e3da cd c1 8a				call str_at_display 
e3dd cd d1 8a				call update_display 
e3e0			 
e3e0				; prompt before entering montior for investigating issue 
e3e0			 
e3e0 3e 78			ld a, display_row_4 
e3e2 11 51 9a			ld de, endprog 
e3e5			 
e3e5 cd d1 8a			call update_display		 
e3e8			 
e3e8 cd d7 9c			call next_page_prompt 
e3eb			 
e3eb d1				pop de 
e3ec e1				pop hl 
e3ed cd a5 9a				call monitor 
e3f0 c3 ae 99				jp warmstart 
e3f3					;jp 0 
e3f3					;halt 
e3f3			 
e3f3			 
e3f3			 
e3f3 .. 00		.stackfault: 	db "Stack fault:",0 
e400			 
e400 .. 00		sfaultsu: 	db	"Stack under flow",0 
e411 .. 00		sfaultso: 	db	"Stack over flow",0 
e421 .. 00		sfaultru:	db "RTS underflow",0 
e42f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e449 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e463 .. 00		sfaultdo:	db "DTS overflow", 0 
e470			 
e470			 
e470			fault_dsp_under: 
e470 11 82 e4			ld de, .dsp_under 
e473 c3 32 e5			jp .show_fault 
e476			 
e476			fault_rsp_under: 
e476 11 90 e4			ld de, .rsp_under 
e479 c3 32 e5			jp .show_fault 
e47c			fault_loop_under: 
e47c 11 9e e4			ld de, .loop_under 
e47f c3 32 e5			jp .show_fault 
e482			 
e482 .. 00		.dsp_under: db "DSP Underflow",0 
e490 .. 00		.rsp_under: db "RSP Underflow",0 
e49e .. 00		.loop_under: db "LOOP Underflow",0 
e4ad			 
e4ad			 
e4ad d5			type_faultn: 	push de 
e4ae e5					push hl 
e4af cd ae 8a				call clear_display 
e4b2 11 d9 e4				   ld de, .typefaultn 
e4b5 3e 00				ld a, display_row_1 
e4b7 cd c1 8a				call str_at_display 
e4ba 11 6b ee				    ld de, debug_mark 
e4bd 3e 11				ld a, display_row_1+17 
e4bf cd c1 8a				call str_at_display 
e4c2 cd d1 8a				call update_display 
e4c5			 
e4c5				; prompt before entering montior for investigating issue 
e4c5			 
e4c5 3e 78			ld a, display_row_4 
e4c7 11 51 9a			ld de, endprog 
e4ca			 
e4ca cd d1 8a			call update_display		 
e4cd			 
e4cd cd d7 9c			call next_page_prompt 
e4d0			 
e4d0 e5					push hl 
e4d1 d5					push de 
e4d2 cd a5 9a				call monitor 
e4d5 c3 ae 99				jp warmstart 
e4d8 76					halt 
e4d9			 
e4d9			 
e4d9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e4f0			 
e4f0 d5			type_faults: 	push de 
e4f1 e5					push hl 
e4f2 cd ae 8a				call clear_display 
e4f5 11 1b e5				   ld de, .typefaults 
e4f8 3e 00				ld a, display_row_1 
e4fa cd c1 8a				call str_at_display 
e4fd 11 6b ee				    ld de, debug_mark 
e500 3e 11				ld a, display_row_1+17 
e502 cd c1 8a				call str_at_display 
e505 cd d1 8a				call update_display 
e508			 
e508				; prompt before entering montior for investigating issue 
e508			 
e508 3e 78			ld a, display_row_4 
e50a 11 51 9a			ld de, endprog 
e50d			 
e50d cd d1 8a			call update_display		 
e510			 
e510 cd d7 9c			call next_page_prompt 
e513			 
e513 e1					pop hl 
e514 d1					pop de 
e515 cd a5 9a				call monitor 
e518 c3 ae 99				jp warmstart 
e51b			 
e51b			 
e51b .. 00		.typefaults: db "STR Type Expected TOS!",0 
e532			 
e532			.show_fault: 	 
e532 d5					push de 
e533 cd ae 8a				call clear_display 
e536 d1					pop de 
e537 3e 00				ld a, display_row_1 
e539 cd c1 8a				call str_at_display 
e53c 11 6b ee				    ld de, debug_mark 
e53f 3e 11				ld a, display_row_1+17 
e541 cd c1 8a				call str_at_display 
e544 cd d1 8a				call update_display 
e547			 
e547				; prompt before entering montior for investigating issue 
e547			 
e547 3e 78			ld a, display_row_4 
e549 11 51 9a			ld de, endprog 
e54c			 
e54c cd d1 8a			call update_display		 
e54f			 
e54f cd d7 9c			call next_page_prompt 
e552			 
e552 e1					pop hl 
e553 d1					pop de 
e554 cd a5 9a				call monitor 
e557			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e557			; TODO Make optional fault restart to cli or warm boot? 
e557					;jp warmstart 
e557 c3 f8 99				jp cli 
e55a 76					halt 
e55b			 
e55b			; handle the auto run of code from files in storage 
e55b			 
e55b			 
e55b			include "forth_startup.asm" 
e55b			; Which startup method to use? 
e55b			; 
e55b			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e55b			; followed by loading of a list of scripts in eeprom 
e55b			 
e55b			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e55b			; from eeprom 
e55b			 
e55b			; Select with define in main stubs 
e55b			 
e55b			if STARTUP_V1 
e55b				include "forth_startupv1.asm" 
e55b			; Startup script loading version 1 
e55b			 
e55b			; If SE storage is available first stage is to use the selected file 
e55b			; then go through the eeprom list 
e55b			 
e55b .. 00		sprompt1: db "Startup load...",0 
e56b .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e581			 
e581			 
e581			 
e581			 
e581			forth_startup: 
e581 21 d2 cf			ld hl, startcmds 
e584 3e 00			ld a, 0 
e586 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e589			 
e589 e5			.start1:	push hl 
e58a cd ae 8a			call clear_display 
e58d 11 5b e5			ld de, sprompt1 
e590 3e 00		        ld a, display_row_1 
e592 cd c1 8a			call str_at_display 
e595 11 6b e5			ld de, sprompt2 
e598 3e 28		        ld a, display_row_2 
e59a cd c1 8a			call str_at_display 
e59d e1				pop hl 
e59e e5				push hl 
e59f 5e				ld e,(hl) 
e5a0 23				inc hl 
e5a1 56				ld d,(hl) 
e5a2 3e 50		        ld a, display_row_3 
e5a4 cd c1 8a			call str_at_display 
e5a7 cd d1 8a			call update_display 
e5aa			 
e5aa			 
e5aa 3a e7 e6			ld a, (os_last_cmd) 
e5ad fe 00			cp 0 
e5af 28 05			jr z, .startprompt 
e5b1 cd e5 89			call delay250ms 
e5b4 18 24			jr .startdo 
e5b6				 
e5b6				 
e5b6			 
e5b6			.startprompt: 
e5b6			 
e5b6 3e 9f			ld a,display_row_4 + display_cols - 1 
e5b8 11 d5 9c		        ld de, endprg 
e5bb cd c1 8a			call str_at_display 
e5be cd d1 8a			call update_display 
e5c1 cd f1 89			call delay1s 
e5c4 cd e7 e6			call cin_wait 
e5c7						 
e5c7 fe 2a			cp '*' 
e5c9 28 5e			jr z, .startupend1 
e5cb fe 23			cp '#' 
e5cd 20 07			jr nz, .startno 
e5cf 3e 01			ld a, 1 
e5d1 32 e7 e6			ld (os_last_cmd),a 
e5d4 18 04			jr .startdo 
e5d6 fe 31		.startno:	cp '1' 
e5d8 28 3a			jr z,.startnxt  
e5da			 
e5da				; exec startup line 
e5da			.startdo:	 
e5da e1				pop hl 
e5db e5				push hl 
e5dc				 
e5dc 5e				ld e,(hl) 
e5dd 23				inc hl 
e5de 56				ld d,(hl) 
e5df eb				ex de,hl 
e5e0			 
e5e0 e5				push hl 
e5e1			 
e5e1 3e 00			ld a, 0 
e5e3				;ld a, FORTH_END_BUFFER 
e5e3 cd 5c 93			call strlent 
e5e6 23				inc hl   ; include zero term to copy 
e5e7 06 00			ld b,0 
e5e9 4d				ld c,l 
e5ea e1				pop hl 
e5eb 11 c1 e2			ld de, scratch 
e5ee ed b0			ldir 
e5f0			 
e5f0			 
e5f0 21 c1 e2			ld hl, scratch 
e5f3 cd 5a a1			call forthparse 
e5f6 cd 9a a1			call forthexec 
e5f9 cd ac a0			call forthexec_cleanup 
e5fc			 
e5fc 3e 78			ld a, display_row_4 
e5fe 11 51 9a			ld de, endprog 
e601			 
e601 cd d1 8a			call update_display		 
e604			 
e604 3a e7 e6			ld a, (os_last_cmd) 
e607 fe 00			cp 0 
e609 20 09			jr nz, .startnxt 
e60b cd d7 9c			call next_page_prompt 
e60e cd ae 8a		        call clear_display 
e611 cd d1 8a			call update_display		 
e614			 
e614				; move onto next startup line? 
e614			.startnxt: 
e614			 
e614 cd e5 89			call delay250ms 
e617 e1				pop hl 
e618			 
e618 23				inc hl 
e619 23				inc hl 
e61a			 
e61a e5				push hl 
e61b 5e				ld e, (hl) 
e61c 23				inc hl 
e61d 56				ld d, (hl) 
e61e e1				pop hl 
e61f				; TODO replace 0 test 
e61f			 
e61f eb				ex de, hl 
e620 cd 04 8d			call ishlzero 
e623			;	ld a,e 
e623			;	add d 
e623			;	cp 0    ; any left to do? 
e623 eb				ex de, hl 
e624 c2 89 e5			jp nz, .start1 
e627 18 01			jr .startupend 
e629			 
e629 e1			.startupend1: pop hl 
e62a			.startupend: 
e62a			 
e62a cd ae 8a			call clear_display 
e62d cd d1 8a			call update_display 
e630 c9				ret 
e631			if STORAGE_SE 
e631			 
e631			sprompt3: db "Loading from start-up file?:",0 
e631			sprompt4: db "(Y=Any key/N=No)",0 
e631			 
e631			 
e631			forth_autoload: 
e631			 
e631				; load block 0 of store 1 
e631				 
e631				ld a, $fe      ; bit 0 clear 
e631				ld (spi_device), a 
e631			 
e631				call storage_get_block_0 
e631			 
e631				ld a, (store_page+STORE_0_AUTOFILE) 
e631			 
e631				cp 0 
e631				ret z     ; auto start not enabled 
e631			 
e631				call clear_display 
e631			 
e631				; set bank 
e631			 
e631					ld a, (store_page+STORE_0_BANKRUN) 
e631					ld (spi_device), a 
e631			 
e631				; get file id to load from and get the file name to display 
e631			 
e631					ld a, (store_page+STORE_0_FILERUN) 
e631			 
e631					ld l, 0 
e631					ld h, a 
e631					ld de, store_page 
e631			 
e631					if DEBUG_FORTH_WORDS 
e631						DMARK "ASp" 
e631						CALLMONITOR 
e631					endif 
e631					call storage_read 
e631			 
e631					if DEBUG_FORTH_WORDS 
e631						DMARK "ASr" 
e631						CALLMONITOR 
e631					endif 
e631			 
e631					call ishlzero 
e631					ret z             ; file not found 
e631			 
e631					ld a, display_row_2 + 10 
e631					ld de, store_page+3 
e631					call str_at_display 
e631				 
e631			; 
e631			 
e631				ld a, display_row_1+5 
e631				ld de, sprompt3 
e631				call str_at_display 
e631				ld a, display_row_3+15 
e631				ld de, sprompt4 
e631				call str_at_display 
e631			 
e631				call update_display 
e631			 
e631				call cin_wait 
e631				cp 'n' 
e631				ret z 
e631				cp 'N' 
e631				ret z 
e631			 
e631				call delay1s 
e631			 
e631				ld a, (store_page+2) 
e631				ld (store_openmaxext), a    ; save count of ext 
e631				ld a, 1  
e631				ld (store_openext), a    ; save count of ext 
e631			 
e631			.autof:  
e631				ld l , a 
e631				 
e631				ld a, (store_page) 
e631				ld h, a	 
e631				ld de, store_page 
e631					if DEBUG_FORTH_WORDS 
e631						DMARK "ASl" 
e631						CALLMONITOR 
e631					endif 
e631					call storage_read 
e631				call ishlzero 
e631				ret z 
e631			;	jr z, .autoend 
e631			 
e631					if DEBUG_FORTH_WORDS 
e631						DMARK "ASc" 
e631						CALLMONITOR 
e631					endif 
e631				ld de, store_page+2 
e631				ld a, display_row_4 
e631				call str_at_display 
e631			 
e631				call update_display 
e631				call delay250ms 
e631			 
e631			 
e631			 
e631				ld hl, store_page+2 
e631				call forthparse 
e631				call forthexec 
e631				call forthexec_cleanup 
e631			 
e631				 
e631				ld a, (store_openext) 
e631				inc a 
e631				ld (store_openext), a    ; save count of ext 
e631			 
e631				jr .autof 
e631			;.autofdone: 
e631			; 
e631			;		if DEBUG_FORTH_WORDS 
e631			;			DMARK "ASx" 
e631			;			CALLMONITOR 
e631			;		endif 
e631			;;	call clear_display 
e631			;	ret 
e631			 
e631			 
e631			 
e631			endif 
# End of file forth_startupv1.asm
e631			endif 
e631			if STARTUP_V2 
e631				include "forth_startupv2.asm" 
e631			endif 
e631			 
# End of file forth_startup.asm
e631			 
e631			; eof 
# End of file forth_kernel.asm
e631			;include "nascombasic.asm" 
e631			 
e631			 
e631			; find out where the code ends if loaded into RAM (for SC114) 
e631			;endofcode:  
e631			;	nop 
e631			 
e631			 
e631			; jump to nmi vector 
e631			 
e631			init_nmi: 
e631 3e c9			ld a, $c9   ; RET 
e633 32 72 ee			ld (nmi_vector), a 
e636 c9				ret 
e637			nmi: 
e637 e5				push hl 
e638 d5				push de 
e639 c5				push bc 
e63a f5				push af 
e63b cd 72 ee			call nmi_vector 
e63e f5				push af 
e63f c5				push bc 
e640 d5				push de 
e641 e5				push hl 
e642 ed 4d			reti 
e644			 
e644			 
e644			; eof 
e644			 
# End of file main.asm
e644			;include "firmware_lcd_4x40.asm" 
e644			;;include "firmware_lcd_4x20.asm" 
e644			include "firmware_serial_display.asm" 
e644			 
e644			; Serial display interface for SC114 
e644			 
e644			 
e644			display_row_1: equ 0 
e644			display_row_2: equ display_row_1+display_cols 
e644			display_row_3: equ display_row_2 + display_cols 
e644			display_row_4: equ display_row_3 + display_cols 
e644			 
e644			kLCDWidth:  EQU display_cols             ;Width in characters 
e644			kLCD_Line1: EQU 0x00  
e644			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e644			; E1 
e644			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e644			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e644			 
e644			lcd_init: 
e644				; no init as handled by the SCM bios 
e644 c9				ret 
e645			 
e645			 
e645			; low level functions for direct screen writes 
e645			 
e645			; output char at pos? 
e645			fLCD_Str: 
e645			        ;out (SC114_SIO_1_OUT),a 
e645 c5				push bc 
e646 0e 02			ld c, $02 
e648 f7				rst $30 
e649 c1				pop bc 
e64a c9				ret 
e64b			 
e64b			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e64b			fLCD_Pos: 
e64b				; use ASCII escape to position 
e64b			        ;out (SC114_SIO_1_OUT),a 
e64b c5				push bc 
e64c 0e 02			ld c, $02 
e64e f7				rst $30 
e64f c1				pop bc 
e650			 
e650 c9				ret 
e651			 
e651			; output char at pos 
e651			fLCD_Data: 
e651			      ;  out (SC114_SIO_1_OUT),a 
e651 c5				push bc 
e652 0e 02			ld c, $02 
e654 f7				rst $30 
e655 c1				pop bc 
e656			 
e656 c9				ret 
e657			 
e657			; ascii cls  
e657			 
e657 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e65b			 
e65b			; write the frame buffer given in hl to hardware  
e65b			write_display: 
e65b			 
e65b			API: equ 0 
e65b			 
e65b			if API 
e65b				push bc 
e65b				ld b, 4 
e65b			 
e65b			        ld (display_write_tmp), hl 	  
e65b			 
e65b				; clear and home cursor 
e65b			 
e65b				ld c, 6 
e65b				ld de, .cls 
e65b				rst $30 
e65b			 
e65b			 
e65b			.writeln: 
e65b			 
e65b				ld de, (display_write_tmp) 
e65b				ld c, 6 
e65b				rst $30 
e65b				ld c, 7 
e65b				rst $30 
e65b			 
e65b				ld hl, (display_write_tmp) 
e65b				ld de, display_cols 
e65b				add hl,de 
e65b				ld (display_write_tmp),hl 
e65b			 
e65b				djnz  .writeln 
e65b			 
e65b				pop bc 
e65b			 
e65b			 
e65b				ret 
e65b			endif 
e65b e5				push hl 
e65c c5				push bc 
e65d d5				push de 
e65e			 
e65e			;	ld c, 2 
e65e			;	;ld de, .cls 
e65e			;	ld a, 27 
e65e			;	rst $30 
e65e			;	ld c, 2 
e65e			;	;ld de, .cls 
e65e			;	ld a, '[' 
e65e			;	rst $30 
e65e			; 
e65e			;	ld c, 2 
e65e			;	;ld de, .cls 
e65e			;	ld a, 'H' 
e65e			;	rst $30 
e65e			; 
e65e			 
e65e 0e 02			ld c, 2 
e660				;ld de, .cls 
e660 3e 1b			ld a, 27 
e662 f7				rst $30 
e663			 
e663			 
e663 0e 02			ld c, 2 
e665				;ld de, .cls 
e665 3e 5b			ld a, '[' 
e667 f7				rst $30 
e668 0e 02			ld c, 2 
e66a				;ld de, .cls 
e66a 3e 32			ld a, '2' 
e66c f7				rst $30 
e66d 0e 02			ld c, 2 
e66f				;ld de, .cls 
e66f 3e 4a			ld a, 'J' 
e671 f7				rst $30 
e672 d1				pop de 
e673 c1				pop bc 
e674 e1				pop hl 
e675			 
e675			 
e675 22 c9 eb		        ld (display_write_tmp), hl 	  
e678 3e 00			ld a, kLCD_Line1 
e67a			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e67a 06 28			ld b, display_cols 
e67c ed 5b c9 eb		ld de, (display_write_tmp) 
e680 cd de e6			call write_len_string 
e683				 
e683			 
e683 e5			push hl 
e684 d5			push de 
e685 c5			push bc 
e686 0e 07			ld c, 7 
e688 f7				rst $30 
e689 c1			pop bc 
e68a d1			pop de 
e68b e1			pop hl 
e68c			 
e68c				 
e68c 2a c9 eb			ld hl, (display_write_tmp) 
e68f 11 28 00			ld de, display_cols 
e692 19				add hl,de 
e693 22 c9 eb			ld (display_write_tmp),hl 
e696			 
e696				 
e696 3e 28			ld a, kLCD_Line2 
e698			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e698 06 28			ld b, display_cols 
e69a ed 5b c9 eb		ld de, (display_write_tmp) 
e69e cd de e6			call write_len_string 
e6a1				 
e6a1 2a c9 eb			ld hl, (display_write_tmp) 
e6a4 11 28 00			ld de, display_cols 
e6a7 19				add hl,de 
e6a8 22 c9 eb			ld (display_write_tmp),hl 
e6ab			 
e6ab e5			push hl 
e6ac d5			push de 
e6ad c5			push bc 
e6ae 0e 07			ld c, 7 
e6b0 f7				rst $30 
e6b1 c1			pop bc 
e6b2 d1			pop de 
e6b3 e1			pop hl 
e6b4			 
e6b4				 
e6b4 3e 50			ld a, kLCD_Line3 
e6b6			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e6b6 06 28			ld b, display_cols 
e6b8 ed 5b c9 eb		ld de, (display_write_tmp) 
e6bc cd de e6			call write_len_string 
e6bf				 
e6bf 2a c9 eb			ld hl, (display_write_tmp) 
e6c2 11 28 00			ld de, display_cols 
e6c5 19				add hl,de 
e6c6 22 c9 eb			ld (display_write_tmp),hl 
e6c9			 
e6c9 e5			push hl 
e6ca d5			push de 
e6cb c5			push bc 
e6cc 0e 07			ld c, 7 
e6ce f7				rst $30 
e6cf c1			pop bc 
e6d0 d1			pop de 
e6d1 e1			pop hl 
e6d2			 
e6d2				 
e6d2 3e 78			ld a, kLCD_Line4 
e6d4			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e6d4 06 28			ld b, display_cols 
e6d6 ed 5b c9 eb		ld de, (display_write_tmp) 
e6da cd de e6			call write_len_string 
e6dd c9					ret 
e6de			 
e6de			 
e6de				; write out a fixed length string given in b from de 
e6de			 
e6de 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e6df cd 51 e6		            CALL fLCD_Data      ;Write character to display 
e6e2 13				inc de 
e6e3 10 f9			djnz write_len_string 
e6e5 c9				ret 
e6e6			 
e6e6			 
e6e6			; eof 
# End of file firmware_serial_display.asm
e6e6			;include "firmware_key_5x10.asm" 
e6e6			;;include "firmware_key_4x10.asm" 
e6e6			include "firmware_key_serial.asm" 
e6e6			; Serial keyboard interface for SC114 
e6e6			 
e6e6			key_init: 
e6e6				; no init as handled by the SCM bios 
e6e6 c9				ret 
e6e7			 
e6e7			 
e6e7			cin_wait: 
e6e7			;	ld a, 0 
e6e7			;	ret 
e6e7			 
e6e7				;in a,(SC114_SIO_1_IN) 
e6e7			        ; Use SCM API to get from whatever console device we are using 
e6e7 c5				push bc 
e6e8 0e 01			ld c, $01 
e6ea f7				rst $30 
e6eb c1				pop bc 
e6ec c9				ret 
e6ed			 
e6ed			cin: 
e6ed			 
e6ed			 
e6ed c5				push bc 
e6ee			 
e6ee				; any key waiting to process? 
e6ee 0e 03			ld c, $03 
e6f0 f7				rst $30 
e6f1 28 05			jr z, .cin_skip 
e6f3			 
e6f3				; yep, get it 
e6f3			 
e6f3 0e 01			ld c, $01 
e6f5 f7				rst $30 
e6f6 c1				pop bc 
e6f7 c9				ret 
e6f8			.cin_skip: 
e6f8 3e 00			ld a, 0 
e6fa c1				pop bc 
e6fb c9				ret 
e6fc			 
e6fc			 
e6fc			 
e6fc			 
# End of file firmware_key_serial.asm
e6fc			endofcode:  
e6fc			baseram:  
e6fc 00				nop 
e6fd			 
e6fd			heap_start: equ baseram+15  ; Starting address of heap 
e6fd			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e6fd			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e6fd			;VDU:  EQU     endofcode           ; BASIC Work space 
e6fd			; eof 
e6fd			 
# End of file os_mega_sc114.asm
e6fd
