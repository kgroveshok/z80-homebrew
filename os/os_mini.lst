# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 f6 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd d2 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd d2 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd d2 0a				call clear_display  
0023			  
0023			  
0023 cd fa 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 43 66			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd a9 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd f5 0a			call update_display  
0032 cd 52 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd d7 0a			call fill_display  
003a cd f5 0a			call update_display  
003d cd 52 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd d7 0a			call fill_display  
0045 cd f5 0a			call update_display  
0048 cd 52 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd d7 0a			call fill_display  
0050 cd f5 0a			call update_display  
0053 cd 52 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd e5 0a			call str_at_display  
005e cd f5 0a			call update_display  
0061			  
0061			  
0061 cd 52 0a			call delay1s  
0064 cd 52 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd e5 0a			call str_at_display  
006f cd f5 0a			call update_display  
0072 cd 52 0a			call delay1s  
0075 cd 52 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 37 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 37 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd bd 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 20 17			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 20 17			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2a 06			call storage_findnextid 
035d			 
035d cd 2f 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 20 17			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 20 17			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 20 17			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 20 17			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 20 17			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 15 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 20 17			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 20 17			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 37 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 37 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 06 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 37 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 37 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 06 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 20 17			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 20 17			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 20 17			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 20 17			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 e8 f9			ld de, store_page 
0572 cd 09 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 bd fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 be fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 bf fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd 20 17			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a e8 f9			ld a, (store_page)	; get file id 
0594 32 e1 f9			ld (store_tmpid), a 
0597			 
0597 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059a 32 e0 f9			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 e8 f9			ld (store_page), a 
05a3 32 e9 f9			ld (store_page+1),a 
05a6 11 e8 f9			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 bd fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 be fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 bf fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd 20 17			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 6e 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a e0 f9			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a e1 f9			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 bd fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 be fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 bf fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd 20 17			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 e8 f9			ld de, store_page 
05f8 cd 09 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 e8 f9			ld (store_page), a 
0600 32 e9 f9			ld (store_page+1),a 
0603 11 e8 f9			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 bd fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 be fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 bf fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd 20 17			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 6e 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 bd fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 be fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 bf fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd 20 17			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 89 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 89 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd 24 0d				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd 06 0d				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 89 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 89 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd 24 0d				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd 06 0d				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 bd fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 be fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 bf fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd 20 17			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 bd fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 be fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 bf fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd 20 17			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 89 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd 06 0d				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 89 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd 06 0d				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 bd fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 be fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 bf fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd 20 17			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd ba 03			call storage_get_block_0 
071a			 
071a 3a e8 f9			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 e8 f9			ld (store_page),a 
0721				 
0721 32 e1 f9			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 e8 f9			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd 20 17			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 6e 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 e8 f9				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 bd fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 be fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 bf fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd 20 17			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 bd fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 be fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 bf fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd 20 17			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 d2 f9			ld (store_tmppageid), hl 
0793				 
0793 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 e8 f9			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 e9 f9			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 bd fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 be fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 bf fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd 20 17			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 6f 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 bd fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 be fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 bf fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd 20 17			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 bd fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 be fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 bf fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 20 17			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a d2 f9			ld hl,(store_tmppageid) 
0809 11 e8 f9			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 bd fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 be fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 bf fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd 20 17			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 6e 03			call storage_write_block 
082b			 
082b 3a e1 f9			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 bd fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 be fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 bf fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd 20 17			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			storage_read: 
084e d5				push de 
084f			 
084f			; TODO BUG the above push is it popped before the RET Z? 
084f			 
084f			; TODO how to handle multiple part blocks 
084f			 
084f				; locate file extent to read 
084f			 
084f 5c				ld e, h 
0850 55				ld d, l 
0851 21 40 00			ld hl, STORE_BLOCK_PHY 
0854				if DEBUG_STORESE 
0854					DMARK "SRE" 
0854 f5				push af  
0855 3a 69 08			ld a, (.dmark)  
0858 32 bd fb			ld (debug_mark),a  
085b 3a 6a 08			ld a, (.dmark+1)  
085e 32 be fb			ld (debug_mark+1),a  
0861 3a 6b 08			ld a, (.dmark+2)  
0864 32 bf fb			ld (debug_mark+2),a  
0867 18 03			jr .pastdmark  
0869 ..			.dmark: db "SRE"  
086c f1			.pastdmark: pop af  
086d			endm  
# End of macro DMARK
086d					CALLMONITOR 
086d cd 20 17			call break_point_state  
0870				endm  
# End of macro CALLMONITOR
0870				endif 
0870 cd 2a 06			call storage_findnextid 
0873			 
0873				if DEBUG_STORESE 
0873					DMARK "SRf" 
0873 f5				push af  
0874 3a 88 08			ld a, (.dmark)  
0877 32 bd fb			ld (debug_mark),a  
087a 3a 89 08			ld a, (.dmark+1)  
087d 32 be fb			ld (debug_mark+1),a  
0880 3a 8a 08			ld a, (.dmark+2)  
0883 32 bf fb			ld (debug_mark+2),a  
0886 18 03			jr .pastdmark  
0888 ..			.dmark: db "SRf"  
088b f1			.pastdmark: pop af  
088c			endm  
# End of macro DMARK
088c					CALLMONITOR 
088c cd 20 17			call break_point_state  
088f				endm  
# End of macro CALLMONITOR
088f				endif 
088f cd 2f 0d			call ishlzero 
0892			;	ld a, l 
0892			;	add h 
0892			;	cp 0 
0892 c8				ret z			; block not found so EOF 
0893			 
0893				; hl contains page number to load 
0893 d1				pop de   ; get storage 
0894 d5				push de 
0895				if DEBUG_STORESE 
0895					DMARK "SRg" 
0895 f5				push af  
0896 3a aa 08			ld a, (.dmark)  
0899 32 bd fb			ld (debug_mark),a  
089c 3a ab 08			ld a, (.dmark+1)  
089f 32 be fb			ld (debug_mark+1),a  
08a2 3a ac 08			ld a, (.dmark+2)  
08a5 32 bf fb			ld (debug_mark+2),a  
08a8 18 03			jr .pastdmark  
08aa ..			.dmark: db "SRg"  
08ad f1			.pastdmark: pop af  
08ae			endm  
# End of macro DMARK
08ae					CALLMONITOR 
08ae cd 20 17			call break_point_state  
08b1				endm  
# End of macro CALLMONITOR
08b1				endif 
08b1 cd 09 03			call storage_read_block 
08b4			 
08b4			 
08b4			; TODO if block has no zeros then need to read next block  
08b4			 
08b4			 
08b4					 
08b4 e1				pop hl 		 ; return start of data to show as not EOF 
08b5 23				inc hl   ; past file id 
08b6 23				inc hl   ; past ext 
08b7				if DEBUG_STORESE 
08b7					DMARK "SRe" 
08b7 f5				push af  
08b8 3a cc 08			ld a, (.dmark)  
08bb 32 bd fb			ld (debug_mark),a  
08be 3a cd 08			ld a, (.dmark+1)  
08c1 32 be fb			ld (debug_mark+1),a  
08c4 3a ce 08			ld a, (.dmark+2)  
08c7 32 bf fb			ld (debug_mark+2),a  
08ca 18 03			jr .pastdmark  
08cc ..			.dmark: db "SRe"  
08cf f1			.pastdmark: pop af  
08d0			endm  
# End of macro DMARK
08d0					CALLMONITOR 
08d0 cd 20 17			call break_point_state  
08d3				endm  
# End of macro CALLMONITOR
08d3				endif 
08d3 c9					ret 
08d4			 
08d4			 
08d4			 
08d4			; 
08d4			; Append File 
08d4			; 
08d4			; hl - file id to locate 
08d4			; de - pointer to (multi block) string to write 
08d4			 
08d4			 
08d4			storage_append: 
08d4				; hl -  file id to append to 
08d4				; de - string to append 
08d4			 
08d4 d5				push de 
08d5				 
08d5				if DEBUG_STORESE 
08d5					DMARK "AP1" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 bd fb			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 be fb			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 bf fb			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "AP1"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 20 17			call break_point_state  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1			 
08f1 7d				ld a, l 
08f2 32 e1 f9			ld (store_tmpid), a 
08f5			 
08f5				; get file header  
08f5			 
08f5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f7 3a e1 f9			ld a, (store_tmpid) 
08fa 5f				ld e, a 
08fb			 
08fb 21 40 00				ld hl, STORE_BLOCK_PHY 
08fe cd 2a 06				call storage_findnextid 
0901			 
0901 22 d2 f9			ld (store_tmppageid), hl 
0904			 
0904				; TODO handle file id not found 
0904			 
0904				if DEBUG_STORESE 
0904					DMARK "AP2" 
0904 f5				push af  
0905 3a 19 09			ld a, (.dmark)  
0908 32 bd fb			ld (debug_mark),a  
090b 3a 1a 09			ld a, (.dmark+1)  
090e 32 be fb			ld (debug_mark+1),a  
0911 3a 1b 09			ld a, (.dmark+2)  
0914 32 bf fb			ld (debug_mark+2),a  
0917 18 03			jr .pastdmark  
0919 ..			.dmark: db "AP2"  
091c f1			.pastdmark: pop af  
091d			endm  
# End of macro DMARK
091d					CALLMONITOR 
091d cd 20 17			call break_point_state  
0920				endm  
# End of macro CALLMONITOR
0920				endif 
0920			 
0920				; update file extent count 
0920			 
0920 11 e8 f9			ld de, store_page 
0923			 
0923 cd 09 03			call storage_read_block 
0926			 
0926				if DEBUG_STORESE 
0926					DMARK "AP3" 
0926 f5				push af  
0927 3a 3b 09			ld a, (.dmark)  
092a 32 bd fb			ld (debug_mark),a  
092d 3a 3c 09			ld a, (.dmark+1)  
0930 32 be fb			ld (debug_mark+1),a  
0933 3a 3d 09			ld a, (.dmark+2)  
0936 32 bf fb			ld (debug_mark+2),a  
0939 18 03			jr .pastdmark  
093b ..			.dmark: db "AP3"  
093e f1			.pastdmark: pop af  
093f			endm  
# End of macro DMARK
093f					CALLMONITOR 
093f cd 20 17			call break_point_state  
0942				endm  
# End of macro CALLMONITOR
0942				endif 
0942			;	ld (store_tmppageid), hl 
0942			 
0942 3a ea f9			ld a, (store_page+2) 
0945 3c				inc a 
0946 32 ea f9			ld (store_page+2), a 
0949 32 e0 f9			ld (store_tmpext), a 
094c				 
094c				if DEBUG_STORESE 
094c					DMARK "AP3" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 bd fb			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 be fb			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 bf fb			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP3"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 20 17			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 2a d2 f9			ld hl, (store_tmppageid) 
096b 11 e8 f9			ld de, store_page 
096e cd 6e 03			call storage_write_block 
0971			 
0971				; find free block 
0971			 
0971 11 00 00			ld de, 0			 ; file extent to locate 
0974			 
0974 21 40 00				ld hl, STORE_BLOCK_PHY 
0977 cd 2a 06				call storage_findnextid 
097a			 
097a					; TODO handle no space left 
097a					 
097a 22 d2 f9				ld (store_tmppageid), hl 
097d			 
097d				if DEBUG_STORESE 
097d					DMARK "AP4" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 bd fb			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 be fb			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 bf fb			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "AP4"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd 20 17			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999					; init the buffer with zeros so we can id if the buffer is full or not 
0999			 
0999 e5					push hl 
099a c5					push bc 
099b			 
099b 21 e8 f9				ld hl, store_page 
099e 06 40				ld b, STORE_BLOCK_PHY 
09a0 3e 00				ld a, 0 
09a2 77			.zeroblock:	ld (hl), a 
09a3 23					inc hl 
09a4 10 fc				djnz .zeroblock 
09a6			 
09a6 c1					pop bc 
09a7 e1					pop hl 
09a8			 
09a8					; construct block 
09a8			 
09a8 3a e1 f9				ld a, (store_tmpid) 
09ab 32 e8 f9				ld (store_page), a   ; file id 
09ae 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09b1 32 e9 f9				ld (store_page+1), a 
09b4			 
09b4 e1					pop hl    ; get string to write 
09b5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b7 11 ea f9				ld de, store_page+2 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP5" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 bd fb			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 be fb			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 bf fb			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP5"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd 20 17			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			 
09d6			 
09d6			 
09d6					; fill buffer with data until end of string or full block 
09d6			 
09d6 7e			.appd:		ld a, (hl) 
09d7 12					ld (de), a 
09d8 fe 00				cp 0 
09da 28 04				jr z, .appdone 
09dc 23					inc hl 
09dd 13					inc de 
09de 10 f6				djnz .appd 
09e0			 
09e0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e1 f5					push af   		; save last byte dumped 
09e2			 
09e2			 
09e2 2a d2 f9			ld hl, (store_tmppageid) 
09e5 11 e8 f9			ld de, store_page 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP6" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 bd fb			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 be fb			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 bf fb			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP6"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 20 17			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 cd 6e 03				call storage_write_block 
0a07			 
0a07			 
0a07				; was that a full block of data written? 
0a07				; any more to write out? 
0a07			 
0a07				; if yes then set vars and jump to start of function again 
0a07			 
0a07 f1					pop af 
0a08 d1					pop de 
0a09			 
0a09 fe 00				cp 0		 ; no, string was fully written 
0a0b c8					ret z 
0a0c			 
0a0c					; setup vars for next cycle 
0a0c			 
0a0c 3a e1 f9				ld a, (store_tmpid) 
0a0f 6f					ld l, a 
0a10 26 00				ld h, 0 
0a12			 
0a12 c3 d4 08			 	jp storage_append	 ; yes, need to write out some more 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			if DEBUG_STORECF 
0a15			storageput:	 
0a15					ret 
0a15			storageread: 
0a15					ld hl, store_page 
0a15					ld b, 200 
0a15					ld a,0 
0a15			.src:		ld (hl),a 
0a15					inc hl 
0a15					djnz .src 
0a15					 
0a15			 
0a15					ld de, 0 
0a15					ld bc, 1 
0a15					ld hl, store_page 
0a15					call cfRead 
0a15			 
0a15				call cfGetError 
0a15				ld hl,scratch 
0a15				call hexout 
0a15				ld hl, scratch+2 
0a15				ld a, 0 
0a15				ld (hl),a 
0a15				ld de, scratch 
0a15				ld a,display_row_1 
0a15				call str_at_display 
0a15				call update_display 
0a15			 
0a15					ld hl, store_page 
0a15					ld (os_cur_ptr),hl 
0a15			 
0a15					ret 
0a15			endif 
0a15			 
0a15			 
0a15			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a15			 
0a15			storage_clear_page: 
0a15 e5				push hl 
0a16 d5				push de 
0a17 c5				push bc 
0a18 21 e8 f9			ld hl, store_page 
0a1b 3e 00			ld a, 0 
0a1d 77				ld (hl), a 
0a1e			 
0a1e 11 e9 f9			ld de, store_page+1 
0a21 01 40 00			ld bc, STORE_BLOCK_PHY 
0a24			 
0a24 ed b0			ldir 
0a26				 
0a26 c1				pop bc 
0a27 d1				pop de 
0a28 e1				pop hl 
0a29 c9				ret 
0a2a			 
0a2a			; eof 
# End of file firmware_storage.asm
0a2a			  
0a2a			; support routines for above hardware abstraction layer  
0a2a			  
0a2a			include "firmware_general.asm"        ; general support functions  
0a2a			 
0a2a			; word look up 
0a2a			 
0a2a			; in 
0a2a			; a is the index 
0a2a			; hl is pointer start of array 
0a2a			; 
0a2a			; returns 
0a2a			; hl to the word 
0a2a			; 
0a2a			 
0a2a			table_lookup:  
0a2a d5					push de 
0a2b eb					ex de, hl 
0a2c			 
0a2c 6f					ld l, a 
0a2d 26 00				ld h, 0 
0a2f 29					add hl, hl 
0a30 19					add hl, de 
0a31 7e					ld a, (hl) 
0a32 23					inc hl 
0a33 66					ld h,(hl) 
0a34 6f					ld l, a 
0a35			 
0a35 d1					pop de 
0a36 c9					ret 
0a37			 
0a37			; Delay loops 
0a37			 
0a37			 
0a37			 
0a37			aDelayInMS: 
0a37 c5				push bc 
0a38 47				ld b,a 
0a39			msdelay: 
0a39 c5				push bc 
0a3a				 
0a3a			 
0a3a 01 41 00			ld bc,041h 
0a3d cd 55 0a			call delayloop 
0a40 c1				pop bc 
0a41 05				dec b 
0a42 20 f5			jr nz,msdelay 
0a44			 
0a44			;if CPU_CLOCK_8MHZ 
0a44			;msdelay8: 
0a44			;	push bc 
0a44			;	 
0a44			; 
0a44			;	ld bc,041h 
0a44			;	call delayloop 
0a44			;	pop bc 
0a44			;	dec b 
0a44			;	jr nz,msdelay8 
0a44			;endif 
0a44			 
0a44			 
0a44 c1				pop bc 
0a45 c9				ret 
0a46			 
0a46			 
0a46			delay250ms: 
0a46				;push de 
0a46 01 00 40			ld bc, 04000h 
0a49 c3 55 0a			jp delayloop 
0a4c			delay500ms: 
0a4c				;push de 
0a4c 01 00 80			ld bc, 08000h 
0a4f c3 55 0a			jp delayloop 
0a52			delay1s: 
0a52				;push bc 
0a52			   ; Clobbers A, d and e 
0a52 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a55			delayloop: 
0a55 c5			    push bc 
0a56			 
0a56			if BASE_CPM 
0a56				ld bc, CPM_DELAY_TUNE 
0a56			.cpmloop: 
0a56				push bc 
0a56			 
0a56			endif 
0a56			 
0a56			 
0a56			 
0a56			delayloopi: 
0a56			;	push bc 
0a56			;.dl: 
0a56 cb 47		    bit     0,a    	; 8 
0a58 cb 47		    bit     0,a    	; 8 
0a5a cb 47		    bit     0,a    	; 8 
0a5c e6 ff		    and     255  	; 7 
0a5e 0b			    dec     bc      	; 6 
0a5f 79			    ld      a,c     	; 4 
0a60 b0			    or      b     	; 4 
0a61 c2 56 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a64			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a64				;pop de 
0a64			;pop bc 
0a64			 
0a64			if BASE_CPM 
0a64				pop bc 
0a64				 
0a64			    dec     bc      	; 6 
0a64			    ld      a,c     	; 4 
0a64			    or      b     	; 4 
0a64			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a64				 
0a64			 
0a64			endif 
0a64			;if CPU_CLOCK_8MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64			 
0a64			;if CPU_CLOCK_10MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64 c1			    pop bc 
0a65			 
0a65 c9				ret 
0a66			 
0a66			 
0a66			 
0a66			; eof 
# End of file firmware_general.asm
0a66			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a66			; display routines that use the physical hardware abstraction layer 
0a66			 
0a66			 
0a66			; information window 
0a66			 
0a66			; pass hl with 1st string to display 
0a66			; pass de with 2nd string to display 
0a66			 
0a66			info_panel: 
0a66 e5				push hl 
0a67			 
0a67 2a 5e fa			ld hl, (display_fb_active) 
0a6a e5				push hl    ; future de destination 
0a6b 21 53 fb				ld hl, display_fb0 
0a6e 22 5e fa				ld (display_fb_active), hl 
0a71			 
0a71 cd d2 0a			call clear_display 
0a74			 
0a74			 
0a74 3e 2d			ld a, display_row_3 + 5 
0a76 cd e5 0a			call str_at_display 
0a79			 
0a79 e1				pop hl 
0a7a d1				pop de 
0a7b			 
0a7b e5				push hl 
0a7c			 
0a7c			 
0a7c 3e 19			ld a, display_row_2 + 5 
0a7e cd e5 0a			call str_at_display 
0a81			 
0a81			 
0a81 cd f5 0a			call update_display 
0a84 cd 28 1c			call next_page_prompt 
0a87 cd d2 0a			call clear_display 
0a8a			 
0a8a				 
0a8a 21 02 fb				ld hl, display_fb1 
0a8d 22 5e fa				ld (display_fb_active), hl 
0a90 cd f5 0a			call update_display 
0a93			 
0a93			 
0a93 c9				ret 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			; TODO windowing? 
0a94			 
0a94			; TODO scroll line up 
0a94			 
0a94			scroll_up: 
0a94			 
0a94 e5				push hl 
0a95 d5				push de 
0a96 c5				push bc 
0a97			 
0a97				; get frame buffer  
0a97			 
0a97 2a 5e fa			ld hl, (display_fb_active) 
0a9a e5				push hl    ; future de destination 
0a9b			 
0a9b 11 14 00			ld  de, display_cols 
0a9e 19				add hl, de 
0a9f			 
0a9f d1				pop de 
0aa0			 
0aa0				;ex de, hl 
0aa0 01 4f 00			ld bc, display_fb_len -1  
0aa3			;if DEBUG_FORTH_WORDS 
0aa3			;	DMARK "SCL" 
0aa3			;	CALLMONITOR 
0aa3			;endif	 
0aa3 ed b0			ldir 
0aa5			 
0aa5				; wipe bottom row 
0aa5			 
0aa5			 
0aa5 2a 5e fa			ld hl, (display_fb_active) 
0aa8 11 50 00			ld de, display_cols*display_rows 
0aab 19				add hl, de 
0aac 06 14			ld b, display_cols 
0aae 3e 20			ld a, ' ' 
0ab0			.scwipe: 
0ab0 77				ld (hl), a 
0ab1 2b				dec hl 
0ab2 10 fc			djnz .scwipe 
0ab4			 
0ab4				;pop hl 
0ab4			 
0ab4 c1				pop bc 
0ab5 d1				pop de 
0ab6 e1				pop hl 
0ab7			 
0ab7 c9				ret 
0ab8			 
0ab8			 
0ab8			;scroll_upo: 
0ab8			;	ld de, display_row_1 
0ab8			 ;	ld hl, display_row_2 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_2 
0ab8			 ;	ld hl, display_row_3 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_3 
0ab8			 ;	ld hl, display_row_4 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			 
0ab8			; TODO clear row 4 
0ab8			 
0ab8			;	ret 
0ab8			 
0ab8				 
0ab8			scroll_down: 
0ab8			 
0ab8 e5				push hl 
0ab9 d5				push de 
0aba c5				push bc 
0abb			 
0abb				; get frame buffer  
0abb			 
0abb 2a 5e fa			ld hl, (display_fb_active) 
0abe			 
0abe 11 4f 00			ld de, display_fb_len - 1 
0ac1 19				add hl, de 
0ac2			 
0ac2 e5			push hl    ; future de destination 
0ac3			 
0ac3 11 14 00			ld  de, display_cols 
0ac6 ed 52			sbc hl, de 
0ac8			 
0ac8			 
0ac8 d1				pop de 
0ac9			 
0ac9			;	ex de, hl 
0ac9 01 4f 00			ld bc, display_fb_len -1  
0acc			 
0acc			 
0acc				 
0acc			 
0acc ed b0			ldir 
0ace			 
0ace				; wipe bottom row 
0ace			 
0ace			 
0ace			;	ld hl, (display_fb_active) 
0ace			;;	ld de, display_cols*display_rows 
0ace			;;	add hl, de 
0ace			;	ld b, display_cols 
0ace			;	ld a, ' ' 
0ace			;.scwiped: 
0ace			;	ld (hl), a 
0ace			;	dec hl 
0ace			;	djnz .scwiped 
0ace			 
0ace				;pop hl 
0ace			 
0ace c1				pop bc 
0acf d1				pop de 
0ad0 e1				pop hl 
0ad1			 
0ad1 c9				ret 
0ad2			;scroll_down: 
0ad2			;	ld de, display_row_4 
0ad2			;	ld hl, display_row_3 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_3 
0ad2			; 	ld hl, display_row_2 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_2 
0ad2			;	ld hl, display_row_1 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;;; TODO clear row 1 
0ad2			;	ret 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			; clear active frame buffer 
0ad2			 
0ad2			clear_display: 
0ad2 3e 20			ld a, ' ' 
0ad4 c3 d7 0a			jp fill_display 
0ad7			 
0ad7			; fill active frame buffer with a char in A 
0ad7			 
0ad7			fill_display: 
0ad7 06 50			ld b,display_fb_len 
0ad9 2a 5e fa			ld hl, (display_fb_active) 
0adc 77			.fd1:	ld (hl),a 
0add 23				inc hl 
0ade 10 fc			djnz .fd1 
0ae0 23				inc hl 
0ae1 3e 00			ld a,0 
0ae3 77				ld (hl),a 
0ae4			 
0ae4			 
0ae4 c9				ret 
0ae5			; Write string (DE) at pos (A) to active frame buffer 
0ae5			 
0ae5 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0ae8 06 00					ld b,0 
0aea 4f					ld c,a 
0aeb 09					add hl,bc 
0aec 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aed b7			            OR   A              ;Null terminator? 
0aee c8			            RET  Z              ;Yes, so finished 
0aef 77					ld (hl),a 
0af0 23				inc hl 
0af1 13			            INC  DE             ;Point to next character 
0af2 18 f8		            JR   .sad1     ;Repeat 
0af4 c9					ret 
0af5			 
0af5			; using current frame buffer write to physical display 
0af5			 
0af5			update_display: 
0af5 e5				push hl 
0af6 2a 5e fa			ld hl, (display_fb_active) 
0af9 cd 19 65			call write_display 
0afc e1				pop hl 
0afd c9				ret 
0afe			 
0afe			; TODO scrolling 
0afe			 
0afe			 
0afe			; move cursor right one char 
0afe			cursor_right: 
0afe			 
0afe				; TODO shift right 
0afe				; TODO if beyond max col 
0afe				; TODO       cursor_next_line 
0afe			 
0afe c9				ret 
0aff			 
0aff			 
0aff			cursor_next_line: 
0aff				; TODO first char 
0aff				; TODO line down 
0aff				; TODO if past last row 
0aff				; TODO    scroll up 
0aff			 
0aff c9				ret 
0b00			 
0b00			cursor_left: 
0b00				; TODO shift left 
0b00				; TODO if beyond left  
0b00				; TODO     cursor prev line 
0b00				 
0b00 c9				ret 
0b01			 
0b01			cursor_prev_line: 
0b01				; TODO last char 
0b01				; TODO line up 
0b01				; TODO if past first row 
0b01				; TODO   scroll down 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cout: 
0b02				; A - char 
0b02 c9				ret 
0b03			 
0b03			 
0b03			; Display a menu and allow item selection (optional toggle items) 
0b03			; 
0b03			; format: 
0b03			; hl pointer to word array with zero term for items 
0b03			; e.g.    db item1 
0b03			;         db .... 
0b03			;         db 0 
0b03			; 
0b03			; a = starting menu item  
0b03			; 
0b03			; de = pointer item toggle array   (todo) 
0b03			; 
0b03			; returns item selected in a 1-... 
0b03			; returns 0 if back button pressed 
0b03			; 
0b03			; NOTE: Uses system frame buffer to display 
0b03			; 
0b03			; LEFT, Q = go back 
0b03			; RIGHT, SPACE, CR = select 
0b03			; UP, A - Up 
0b03			; DOWN, Z - Down 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			menu: 
0b03			 
0b03					; keep array pointer 
0b03			 
0b03 22 e6 f9				ld (store_tmp1), hl 
0b06 32 e4 f9				ld (store_tmp2), a 
0b09			 
0b09					; check for key bounce 
0b09			 
0b09			if BASE_KEV 
0b09			 
0b09 cd ce 66		.mbounce:	call cin 
0b0c fe 00				cp 0 
0b0e 20 f9				jr nz, .mbounce 
0b10			endif 
0b10					; for ease use ex 
0b10			 
0b10					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b10 21 53 fb				ld hl, display_fb0 
0b13 22 5e fa				ld (display_fb_active), hl 
0b16			 
0b16 cd d2 0a		.mloop:		call clear_display 
0b19 cd f5 0a				call update_display 
0b1c			 
0b1c					; draw selection id '>' at 1 
0b1c			 
0b1c					; init start of list display 
0b1c			 
0b1c 3e 05				ld a, 5 
0b1e 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b21 3a e4 f9				ld a,( store_tmp2) 
0b24 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b27			 
0b27					 
0b27			.mitem:	 
0b27			 
0b27			 
0b27 3a e5 f9				ld a,(store_tmp2+1) 
0b2a 6f					ld l, a 
0b2b 26 00				ld h, 0 
0b2d 29					add hl, hl 
0b2e ed 5b e6 f9			ld de, (store_tmp1) 
0b32 19					add hl, de 
0b33 7e					ld a, (hl) 
0b34 23					inc hl 
0b35 66					ld h,(hl) 
0b36 6f					ld l, a 
0b37			 
0b37 cd 2f 0d				call ishlzero 
0b3a 28 1a				jr z, .mdone 
0b3c			 
0b3c eb					ex de, hl 
0b3d 3a e2 f9				ld a, (store_tmp3) 
0b40 cd e5 0a				call str_at_display 
0b43					 
0b43			 
0b43					; next item 
0b43 3a e5 f9				ld a, (store_tmp2+1) 
0b46 3c					inc a 
0b47 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b4a			 
0b4a			 		; next row 
0b4a			 
0b4a 3a e2 f9				ld a, (store_tmp3) 
0b4d c6 14				add display_cols 
0b4f 32 e2 f9				ld (store_tmp3), a 
0b52			 
0b52					; at end of screen? 
0b52			 
0b52 fe 10				cp display_rows*4 
0b54 20 d1				jr nz, .mitem 
0b56			 
0b56			 
0b56			.mdone: 
0b56 cd 2f 0d				call ishlzero 
0b59 28 08				jr z, .nodn 
0b5b			 
0b5b 3e 3c				ld a, display_row_4 
0b5d 11 dc 0b				ld de, .mdown 
0b60 cd e5 0a				call str_at_display 
0b63			 
0b63					; draw options to fill the screens with active item on line 1 
0b63					; if current option is 2 or more then display ^ in top 
0b63			 
0b63 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b66 fe 00				cp 0 
0b68 28 08				jr z, .noup 
0b6a			 
0b6a 3e 00				ld a, 0 
0b6c 11 da 0b				ld de, .mup 
0b6f cd e5 0a				call str_at_display 
0b72			 
0b72 3e 02		.noup:		ld a, 2 
0b74 11 d8 0b				ld de, .msel 
0b77 cd e5 0a				call str_at_display 
0b7a			 
0b7a					; if current option + 1 is not null then display V in bottom 
0b7a					; get key 
0b7a cd f5 0a				call update_display 
0b7d			 
0b7d			 
0b7d					; handle key 
0b7d			 
0b7d cd bd 66				call cin_wait 
0b80			 
0b80 fe 05				cp KEY_UP 
0b82 28 2b				jr z, .mgoup 
0b84 fe 61				cp 'a' 
0b86 28 27				jr z, .mgoup 
0b88 fe 0a				cp KEY_DOWN 
0b8a 28 32				jr z, .mgod 
0b8c fe 7a				cp 'z' 
0b8e 28 2e				jr z, .mgod 
0b90 fe 20				cp ' ' 
0b92 28 34				jr z, .goend 
0b94 fe 0c				cp KEY_RIGHT 
0b96 28 30				jr z, .goend 
0b98 fe 0d				cp KEY_CR 
0b9a 28 2c				jr z, .goend 
0b9c fe 71				cp 'q' 
0b9e 28 0b				jr z, .goback 
0ba0			 
0ba0 fe 0b				cp KEY_LEFT 
0ba2 28 07				jr z, .goback 
0ba4 fe 08				cp KEY_BS 
0ba6 28 03				jr z, .goback 
0ba8 c3 16 0b				jp .mloop 
0bab			 
0bab			.goback: 
0bab 3e 00			ld a, 0 
0bad 18 1d			jr .goend2 
0baf			 
0baf				; move up one 
0baf			.mgoup: 
0baf 3a e4 f9				ld a, (store_tmp2) 
0bb2 fe 00				cp 0 
0bb4 ca 16 0b				jp z, .mloop 
0bb7 3d					dec a 
0bb8 32 e4 f9				ld (store_tmp2), a 
0bbb c3 16 0b				jp .mloop 
0bbe			 
0bbe				; move down one 
0bbe			.mgod: 
0bbe 3a e4 f9				ld a, (store_tmp2) 
0bc1 3c					inc a 
0bc2 32 e4 f9				ld (store_tmp2), a 
0bc5 c3 16 0b				jp .mloop 
0bc8			 
0bc8			 
0bc8			.goend: 
0bc8					; get selected item number 
0bc8			 
0bc8 3a e4 f9				ld a, (store_tmp2) 
0bcb 3c					inc a 
0bcc			 
0bcc			.goend2: 
0bcc f5					push af 
0bcd			 
0bcd					; restore active fb 
0bcd					; TODO BUG assumes fb1 
0bcd			 
0bcd 21 02 fb				ld hl, display_fb1 
0bd0 22 5e fa				ld (display_fb_active), hl 
0bd3			 
0bd3					; restore main regs 
0bd3			 
0bd3			 
0bd3 cd f5 0a				call update_display 
0bd6			 
0bd6 f1					pop af 
0bd7			 
0bd7 c9				ret 
0bd8			 
0bd8 .. 00		.msel:   db ">",0 
0bda .. 00		.mup:   db "^",0 
0bdc .. 00		.mdown:   db "v",0 
0bde			 
0bde			 
0bde			; eof 
0bde			 
# End of file firmware_display.asm
0bde			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bde			; random number generators 
0bde			 
0bde			 
0bde			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bde			 
0bde			 
0bde			;-----> Generate a random number 
0bde			; output a=answer 0<=a<=255 
0bde			; all registers are preserved except: af 
0bde			random: 
0bde e5			        push    hl 
0bdf d5			        push    de 
0be0 2a 40 fa		        ld      hl,(randData) 
0be3 ed 5f		        ld      a,r 
0be5 57			        ld      d,a 
0be6 5e			        ld      e,(hl) 
0be7 19			        add     hl,de 
0be8 85			        add     a,l 
0be9 ac			        xor     h 
0bea 22 40 fa		        ld      (randData),hl 
0bed d1			        pop     de 
0bee e1			        pop     hl 
0bef c9			        ret 
0bf0			 
0bf0			 
0bf0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf0			 
0bf0			 
0bf0			 
0bf0			;------LFSR------ 
0bf0			;James Montelongo 
0bf0			;optimized by Spencer Putt 
0bf0			;out: 
0bf0			; a = 8 bit random number 
0bf0			RandLFSR: 
0bf0 21 46 fa		        ld hl,LFSRSeed+4 
0bf3 5e			        ld e,(hl) 
0bf4 23			        inc hl 
0bf5 56			        ld d,(hl) 
0bf6 23			        inc hl 
0bf7 4e			        ld c,(hl) 
0bf8 23			        inc hl 
0bf9 7e			        ld a,(hl) 
0bfa 47			        ld b,a 
0bfb cb 13		        rl e  
0bfd cb 12			rl d 
0bff cb 11		        rl c  
0c01 17				rla 
0c02 cb 13		        rl e  
0c04 cb 12			rl d 
0c06 cb 11		        rl c  
0c08 17				rla 
0c09 cb 13		        rl e  
0c0b cb 12			rl d 
0c0d cb 11		        rl c  
0c0f 17				rla 
0c10 67			        ld h,a 
0c11 cb 13		        rl e  
0c13 cb 12			rl d 
0c15 cb 11		        rl c  
0c17 17				rla 
0c18 a8			        xor b 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d ac			        xor h 
0c1e a9			        xor c 
0c1f aa			        xor d 
0c20 21 48 fa		        ld hl,LFSRSeed+6 
0c23 11 49 fa		        ld de,LFSRSeed+7 
0c26 01 07 00		        ld bc,7 
0c29 ed b8		        lddr 
0c2b 12			        ld (de),a 
0c2c c9			        ret 
0c2d			 
0c2d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c2d			 
0c2d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c2d			 
0c2d			 
0c2d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c2d			 
0c2d			prng16: 
0c2d			;Inputs: 
0c2d			;   (seed1) contains a 16-bit seed value 
0c2d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c2d			;Outputs: 
0c2d			;   HL is the result 
0c2d			;   BC is the result of the LCG, so not that great of quality 
0c2d			;   DE is preserved 
0c2d			;Destroys: 
0c2d			;   AF 
0c2d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c2d			;160cc 
0c2d			;26 bytes 
0c2d 2a 3a fa		    ld hl,(seed1) 
0c30 44			    ld b,h 
0c31 4d			    ld c,l 
0c32 29			    add hl,hl 
0c33 29			    add hl,hl 
0c34 2c			    inc l 
0c35 09			    add hl,bc 
0c36 22 3a fa		    ld (seed1),hl 
0c39 2a 38 fa		    ld hl,(seed2) 
0c3c 29			    add hl,hl 
0c3d 9f			    sbc a,a 
0c3e e6 2d		    and %00101101 
0c40 ad			    xor l 
0c41 6f			    ld l,a 
0c42 22 38 fa		    ld (seed2),hl 
0c45 09			    add hl,bc 
0c46 c9			    ret 
0c47			 
0c47			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c47			 
0c47			rand32: 
0c47			;Inputs: 
0c47			;   (seed1_0) holds the lower 16 bits of the first seed 
0c47			;   (seed1_1) holds the upper 16 bits of the first seed 
0c47			;   (seed2_0) holds the lower 16 bits of the second seed 
0c47			;   (seed2_1) holds the upper 16 bits of the second seed 
0c47			;   **NOTE: seed2 must be non-zero 
0c47			;Outputs: 
0c47			;   HL is the result 
0c47			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c47			;Destroys: 
0c47			;   AF 
0c47			;Tested and passes all CAcert tests 
0c47			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c47			;it has a period of 18,446,744,069,414,584,320 
0c47			;roughly 18.4 quintillion. 
0c47			;LFSR taps: 0,2,6,7  = 11000101 
0c47			;291cc 
0c47			;seed1_0=$+1 
0c47			;    ld hl,12345 
0c47			;seed1_1=$+1 
0c47			;    ld de,6789 
0c47			;    ld b,h 
0c47			;    ld c,l 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    inc l 
0c47			;    add hl,bc 
0c47			;    ld (seed1_0),hl 
0c47			;    ld hl,(seed1_1) 
0c47			;    adc hl,de 
0c47			;    ld (seed1_1),hl 
0c47			;    ex de,hl 
0c47			;seed2_0=$+1 
0c47			;    ld hl,9876 
0c47			;seed2_1=$+1 
0c47			;    ld bc,54321 
0c47			;    add hl,hl \ rl c \ rl b 
0c47			;    ld (seed2_1),bc 
0c47			;    sbc a,a 
0c47			;    and %11000101 
0c47			;    xor l 
0c47			;    ld l,a 
0c47			;    ld (seed2_0),hl 
0c47			;    ex de,hl 
0c47			;    add hl,bc 
0c47			;    ret 
0c47			; 
0c47			 
0c47			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c47			; 20 bytes, 86 cycles (excluding ret) 
0c47			 
0c47			; returns   hl = pseudorandom number 
0c47			; corrupts   a 
0c47			 
0c47			; generates 16-bit pseudorandom numbers with a period of 65535 
0c47			; using the xorshift method: 
0c47			 
0c47			; hl ^= hl << 7 
0c47			; hl ^= hl >> 9 
0c47			; hl ^= hl << 8 
0c47			 
0c47			; some alternative shift triplets which also perform well are: 
0c47			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c47			 
0c47			;  org 32768 
0c47			 
0c47			xrnd: 
0c47 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c4a 3e 00		  ld a,0 
0c4c bd			  cp l 
0c4d 20 02		  jr nz, .xrnd1 
0c4f 2e 01		  ld l, 1 
0c51			.xrnd1: 
0c51			 
0c51 7c			  ld a,h 
0c52 1f			  rra 
0c53 7d			  ld a,l 
0c54 1f			  rra 
0c55 ac			  xor h 
0c56 67			  ld h,a 
0c57 7d			  ld a,l 
0c58 1f			  rra 
0c59 7c			  ld a,h 
0c5a 1f			  rra 
0c5b ad			  xor l 
0c5c 6f			  ld l,a 
0c5d ac			  xor h 
0c5e 67			  ld h,a 
0c5f			 
0c5f 22 3e fa		  ld (xrandc),hl 
0c62			 
0c62 c9			  ret 
0c63			;  
0c63			 
0c63			 
0c63			;;;; int maths 
0c63			 
0c63			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c63			; Divide 16-bit values (with 16-bit result) 
0c63			; In: Divide BC by divider DE 
0c63			; Out: BC = result, HL = rest 
0c63			; 
0c63			Div16: 
0c63 21 00 00		    ld hl,0 
0c66 78			    ld a,b 
0c67 06 08		    ld b,8 
0c69			Div16_Loop1: 
0c69 17			    rla 
0c6a ed 6a		    adc hl,hl 
0c6c ed 52		    sbc hl,de 
0c6e 30 01		    jr nc,Div16_NoAdd1 
0c70 19			    add hl,de 
0c71			Div16_NoAdd1: 
0c71 10 f6		    djnz Div16_Loop1 
0c73 17			    rla 
0c74 2f			    cpl 
0c75 47			    ld b,a 
0c76 79			    ld a,c 
0c77 48			    ld c,b 
0c78 06 08		    ld b,8 
0c7a			Div16_Loop2: 
0c7a 17			    rla 
0c7b ed 6a		    adc hl,hl 
0c7d ed 52		    sbc hl,de 
0c7f 30 01		    jr nc,Div16_NoAdd2 
0c81 19			    add hl,de 
0c82			Div16_NoAdd2: 
0c82 10 f6		    djnz Div16_Loop2 
0c84 17			    rla 
0c85 2f			    cpl 
0c86 41			    ld b,c 
0c87 4f			    ld c,a 
0c88 c9			ret 
0c89			 
0c89			 
0c89			;http://z80-heaven.wikidot.com/math 
0c89			; 
0c89			;Inputs: 
0c89			;     DE and A are factors 
0c89			;Outputs: 
0c89			;     A is not changed 
0c89			;     B is 0 
0c89			;     C is not changed 
0c89			;     DE is not changed 
0c89			;     HL is the product 
0c89			;Time: 
0c89			;     342+6x 
0c89			; 
0c89			Mult16: 
0c89			 
0c89 06 08		     ld b,8          ;7           7 
0c8b 21 00 00		     ld hl,0         ;10         10 
0c8e 29			       add hl,hl     ;11*8       88 
0c8f 07			       rlca          ;4*8        32 
0c90 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c92 19			         add hl,de   ;--         -- 
0c93 10 f9		       djnz $-5      ;13*7+8     99 
0c95 c9			ret 
0c96			 
0c96			; 
0c96			; Square root of 16-bit value 
0c96			; In:  HL = value 
0c96			; Out:  D = result (rounded down) 
0c96			; 
0c96			;Sqr16: 
0c96			;    ld de,#0040 
0c96			;    ld a,l 
0c96			;    ld l,h 
0c96			;    ld h,d 
0c96			;    or a 
0c96			;    ld b,8 
0c96			;Sqr16_Loop: 
0c96			;    sbc hl,de 
0c96			;    jr nc,Sqr16_Skip 
0c96			;    add hl,de 
0c96			;Sqr16_Skip: 
0c96			;    ccf 
0c96			;    rl d 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    djnz Sqr16_Loop 
0c96			;    ret 
0c96			; 
0c96			; 
0c96			; Divide 8-bit values 
0c96			; In: Divide E by divider C 
0c96			; Out: A = result, B = rest 
0c96			; 
0c96			Div8: 
0c96 af			    xor a 
0c97 06 08		    ld b,8 
0c99			Div8_Loop: 
0c99 cb 13		    rl e 
0c9b 17			    rla 
0c9c 91			    sub c 
0c9d 30 01		    jr nc,Div8_NoAdd 
0c9f 81			    add a,c 
0ca0			Div8_NoAdd: 
0ca0 10 f7		    djnz Div8_Loop 
0ca2 47			    ld b,a 
0ca3 7b			    ld a,e 
0ca4 17			    rla 
0ca5 2f			    cpl 
0ca6 c9			    ret 
0ca7			 
0ca7			; 
0ca7			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca7			; In: Multiply A with DE 
0ca7			; Out: HL = result 
0ca7			; 
0ca7			Mult12U: 
0ca7 2e 00		    ld l,0 
0ca9 87			    add a,a 
0caa 30 01		    jr nc,Mult12U_NoAdd0 
0cac 19			    add hl,de 
0cad			Mult12U_NoAdd0: 
0cad 29			    add hl,hl 
0cae 87			    add a,a 
0caf 30 01		    jr nc,Mult12U_NoAdd1 
0cb1 19			    add hl,de 
0cb2			Mult12U_NoAdd1: 
0cb2 29			    add hl,hl 
0cb3 87			    add a,a 
0cb4 30 01		    jr nc,Mult12U_NoAdd2 
0cb6 19			    add hl,de 
0cb7			Mult12U_NoAdd2: 
0cb7 29			    add hl,hl 
0cb8 87			    add a,a 
0cb9 30 01		    jr nc,Mult12U_NoAdd3 
0cbb 19			    add hl,de 
0cbc			Mult12U_NoAdd3: 
0cbc 29			    add hl,hl 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd4 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd4: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd5 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd5: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 30 01		    jr nc,Mult12U_NoAdd6 
0cca 19			    add hl,de 
0ccb			Mult12U_NoAdd6: 
0ccb 29			    add hl,hl 
0ccc 87			    add a,a 
0ccd d0			    ret nc 
0cce 19			    add hl,de 
0ccf c9			    ret 
0cd0			 
0cd0			; 
0cd0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd0			; In: Multiply A with DE 
0cd0			;      Put lowest value in A for most efficient calculation 
0cd0			; Out: HL = result 
0cd0			; 
0cd0			Mult12R: 
0cd0 21 00 00		    ld hl,0 
0cd3			Mult12R_Loop: 
0cd3 cb 3f		    srl a 
0cd5 30 01		    jr nc,Mult12R_NoAdd 
0cd7 19			    add hl,de 
0cd8			Mult12R_NoAdd: 
0cd8 cb 23		    sla e 
0cda cb 12		    rl d 
0cdc b7			    or a 
0cdd c2 d3 0c		    jp nz,Mult12R_Loop 
0ce0 c9			    ret 
0ce1			 
0ce1			; 
0ce1			; Multiply 16-bit values (with 32-bit result) 
0ce1			; In: Multiply BC with DE 
0ce1			; Out: BCHL = result 
0ce1			; 
0ce1			Mult32: 
0ce1 79			    ld a,c 
0ce2 48			    ld c,b 
0ce3 21 00 00		    ld hl,0 
0ce6 06 10		    ld b,16 
0ce8			Mult32_Loop: 
0ce8 29			    add hl,hl 
0ce9 17			    rla 
0cea cb 11		    rl c 
0cec 30 07		    jr nc,Mult32_NoAdd 
0cee 19			    add hl,de 
0cef ce 00		    adc a,0 
0cf1 d2 f5 0c		    jp nc,Mult32_NoAdd 
0cf4 0c			    inc c 
0cf5			Mult32_NoAdd: 
0cf5 10 f1		    djnz Mult32_Loop 
0cf7 41			    ld b,c 
0cf8 4f			    ld c,a 
0cf9 c9			    ret 
0cfa			 
0cfa			 
0cfa			 
0cfa			; 
0cfa			; Multiply 8-bit values 
0cfa			; In:  Multiply H with E 
0cfa			; Out: HL = result 
0cfa			; 
0cfa			Mult8: 
0cfa 16 00		    ld d,0 
0cfc 6a			    ld l,d 
0cfd 06 08		    ld b,8 
0cff			Mult8_Loop: 
0cff 29			    add hl,hl 
0d00 30 01		    jr nc,Mult8_NoAdd 
0d02 19			    add hl,de 
0d03			Mult8_NoAdd: 
0d03 10 fa		    djnz Mult8_Loop 
0d05 c9			    ret 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			;;http://z80-heaven.wikidot.com/math 
0d06			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d06			; 
0d06			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d06			;     ld a,16        ;7 
0d06			;     ld hl,0        ;10 
0d06			;     jp $+5         ;10 
0d06			;.DivLoop: 
0d06			;       add hl,bc    ;-- 
0d06			;       dec a        ;64 
0d06			;       jr z,.DivLoopEnd        ;86 
0d06			; 
0d06			;       sla e        ;128 
0d06			;       rl d         ;128 
0d06			;       adc hl,hl    ;240 
0d06			;       sbc hl,bc    ;240 
0d06			;       jr nc,.DivLoop ;23|21 
0d06			;       inc e        ;-- 
0d06			;       jp .DivLoop+1 
0d06			; 
0d06			;.DivLoopEnd: 
0d06			 
0d06			;HL_Div_C: 
0d06			;Inputs: 
0d06			;     HL is the numerator 
0d06			;     C is the denominator 
0d06			;Outputs: 
0d06			;     A is the remainder 
0d06			;     B is 0 
0d06			;     C is not changed 
0d06			;     DE is not changed 
0d06			;     HL is the quotient 
0d06			; 
0d06			;       ld b,16 
0d06			;       xor a 
0d06			;         add hl,hl 
0d06			;         rla 
0d06			;         cp c 
0d06			;         jr c,$+4 
0d06			;           inc l 
0d06			;           sub c 
0d06			;         djnz $-7 
0d06			 
0d06			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d06			 
0d06			addatohl: 
0d06 85			    add   a, l    ; A = A+L 
0d07 6f			    ld    l, a    ; L = A+L 
0d08 8c			    adc   a, h    ; A = A+L+H+carry 
0d09 95			    sub   l       ; A = H+carry 
0d0a 67			    ld    h, a    ; H = H+carry 
0d0b c9			ret 
0d0c			 
0d0c			addatode: 
0d0c 83			    add   a, e    ; A = A+L 
0d0d 5f			    ld    e, a    ; L = A+L 
0d0e 8a			    adc   a, d    ; A = A+L+H+carry 
0d0f 93			    sub   e       ; A = H+carry 
0d10 57			    ld    d, a    ; H = H+carry 
0d11 c9			ret 
0d12			 
0d12			 
0d12			addatobc: 
0d12 81			    add   a, c    ; A = A+L 
0d13 4f			    ld    c, a    ; L = A+L 
0d14 88			    adc   a, b    ; A = A+L+H+carry 
0d15 91			    sub   c       ; A = H+carry 
0d16 47			    ld    b, a    ; H = H+carry 
0d17 c9			ret 
0d18			 
0d18			subafromhl: 
0d18			   ; If A=0 do nothing 
0d18			    ; Otherwise flip A's sign. Since 
0d18			    ; the upper byte becomes -1, also 
0d18			    ; substract 1 from H. 
0d18 ed 44		    neg 
0d1a ca 23 0d		    jp    z, Skip 
0d1d 25			    dec   h 
0d1e			     
0d1e			    ; Now add the low byte as usual 
0d1e			    ; Two's complement takes care of 
0d1e			    ; ensuring the result is correct 
0d1e 85			    add   a, l 
0d1f 6f			    ld    l, a 
0d20 8c			    adc   a, h 
0d21 95			    sub   l 
0d22 67			    ld    h, a 
0d23			Skip: 
0d23 c9				ret 
0d24			 
0d24			 
0d24			; compare hl and de 
0d24			; returns:  
0d24			; if hl = de, z=1, s=0, c0=0 
0d24			; if hl > de, z=0, s=0, c=0 
0d24			; if hl < de, z=0, s=1, c=1 
0d24			cmp16:	 
0d24 b7				or a 
0d25 ed 52			sbc hl,de 
0d27 e0				ret po 
0d28 7c				ld a,h 
0d29 1f				rra 
0d2a ee 40			xor 01000000B 
0d2c 37				scf 
0d2d 8f				adc a,a 
0d2e c9				ret 
0d2f			 
0d2f			 
0d2f			; test if hl contains zero   - A is destroyed 
0d2f			 
0d2f			ishlzero:    
0d2f b7				or a     ; reset flags 
0d30 7c				ld a, h 
0d31 b5				or l        	 
0d32			 
0d32 c9				ret 
0d33			 
0d33			 
0d33			 
0d33			 
0d33			if FORTH_ENABLE_FLOATMATH 
0d33			;include "float/bbcmath.z80" 
0d33			include "float/lpfpcalc.asm" 
0d33			endif 
0d33			 
0d33			 
0d33			; eof 
0d33			 
# End of file firmware_maths.asm
0d33			include "firmware_strings.asm"   ; string handling  
0d33			 
0d33			 
0d33			; TODO string len 
0d33			; input text string, end on cr with zero term 
0d33			; a offset into frame buffer to start prompt 
0d33			; d is max length 
0d33			; e is display size TODO 
0d33			; c is current cursor position 
0d33			; hl is ptr to where string will be stored 
0d33			 
0d33			 
0d33			; TODO check limit of buffer for new inserts 
0d33			; TODO check insert does not push beyond buffer 
0d33			; TODO scroll in a limited display area 
0d33			; TODO scroll whole screen on page wrap 
0d33			 
0d33			 
0d33			; TODO handle KEY_PREVWORD 
0d33			; TODO handle KEY_NEXTWORD 
0d33			; TODO handle KEY_HOME 
0d33			; TODO handle KEY_END 
0d33			; TODO use LCD cursor? 
0d33			 
0d33 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d36 81					add c 
0d37 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3a 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d3d 79					ld a, c 
0d3e cd 06 0d				call addatohl 
0d41 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d44 7a					ld a,d 
0d45 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d48 79					ld a, c 
0d49 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d4c 7b					ld a,e 
0d4d 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d50					 
0d50					 
0d50			 
0d50			;		ld a,(input_ptr) 
0d50			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d50			 
0d50			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d50					; init cursor shape if not set by the cin routines 
0d50 21 56 fa				ld hl, cursor_shape 
0d53 3e ff				ld a, 255 
0d55 77					ld (hl), a 
0d56 23					inc hl 
0d57 3e 00				ld a, 0 
0d59 77					ld (hl), a 
0d5a			 
0d5a 3e 0f				ld a, CUR_BLINK_RATE 
0d5c 32 b2 fb				ld (input_cur_flash), a 
0d5f 3e 01				ld a, 1 
0d61 32 b1 fb				ld (input_cur_onoff),a 
0d64			 
0d64			;	if DEBUG_INPUT 
0d64			;		push af 
0d64			;		ld a, 'I' 
0d64			;		ld (debug_mark),a 
0d64			;		pop af 
0d64			;		CALLMONITOR 
0d64			;	endif 
0d64			.is1:		; main entry loop 
0d64			 
0d64			 
0d64			 
0d64					; pause 1ms 
0d64			 
0d64 3e 01				ld a, 1 
0d66 cd 37 0a				call aDelayInMS 
0d69			 
0d69					; dec flash counter 
0d69 3a b2 fb				ld a, (input_cur_flash) 
0d6c 3d					dec a 
0d6d 32 b2 fb				ld (input_cur_flash), a 
0d70 fe 00				cp 0 
0d72 20 0d				jr nz, .nochgstate 
0d74			 
0d74			 
0d74					; change state 
0d74 3a b1 fb				ld a,(input_cur_onoff) 
0d77 ed 44				neg 
0d79 32 b1 fb				ld (input_cur_onoff),a 
0d7c			 
0d7c			 
0d7c					; reset on change of state 
0d7c 3e 0f				ld a, CUR_BLINK_RATE 
0d7e 32 b2 fb				ld (input_cur_flash), a 
0d81			 
0d81			.nochgstate: 
0d81					 
0d81					 
0d81			 
0d81					; display cursor  
0d81			 
0d81			;		ld hl, (input_start) 
0d81			;		ld a, (input_cursor) 
0d81			;		call addatohl 
0d81			 
0d81					; get char under cursor and replace with cursor 
0d81 2a bb fb		ld hl, (input_ptr) 
0d84			;		ld a, (hl) 
0d84			;		ld (input_under_cursor),a 
0d84			;		ld a, '_' 
0d84			;		ld (hl), a 
0d84			 
0d84					; display string 
0d84			 
0d84 ed 5b b9 fb			ld de, (input_start) 
0d88 3a b6 fb				ld a, (input_at_pos) 
0d8b cd e5 0a				call str_at_display 
0d8e			;	        call update_display 
0d8e			 
0d8e					; find place to put the cursor 
0d8e			;		add h 
0d8e			;		ld l, display_row_1 
0d8e			;		sub l 
0d8e			; (input_at_pos) 
0d8e					;ld c, a 
0d8e			;		ld a, (input_cursor) 
0d8e			;		ld l, (input_at_pos) 
0d8e			;		;ld b, h 
0d8e			;		add l 
0d8e			;		ld (input_at_cursor),a 
0d8e					;ld l,h 
0d8e			 
0d8e			;		ld h, 0 
0d8e			;		ld l,(input_at_pos) 
0d8e			;		ld a, (input_cursor) 
0d8e			;		call addatohl 
0d8e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d8e			;		call subafromhl 
0d8e			;		ld a,l 
0d8e			;		ld (input_at_cursor), a 
0d8e			 
0d8e				if DEBUG_INPUT 
0d8e					ld a, (hardware_diag) 
0d8e					cp 0 
0d8e					jr z, .skip_input_diag 
0d8e			 
0d8e					ld a,(input_at_pos) 
0d8e					ld hl, LFSRSeed 
0d8e					call hexout 
0d8e					ld a, (input_cursor) 
0d8e					ld hl, LFSRSeed+2 
0d8e					call hexout 
0d8e					ld a,(input_at_cursor) 
0d8e					ld hl, LFSRSeed+4 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_onoff) 
0d8e					ld hl, LFSRSeed+6 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_flash) 
0d8e					ld hl, LFSRSeed+8 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_len) 
0d8e					ld hl, LFSRSeed+10 
0d8e					call hexout 
0d8e					ld hl, LFSRSeed+12 
0d8e					ld a, 0 
0d8e					ld (hl),a 
0d8e					ld a, display_row_4 
0d8e					ld de, LFSRSeed 
0d8e					call str_at_display 
0d8e					.skip_input_diag: 
0d8e				endif 
0d8e			 
0d8e					; decide on if we are showing the cursor this time round 
0d8e			 
0d8e 3a b1 fb				ld a, (input_cur_onoff) 
0d91 fe ff				cp 255 
0d93 28 13				jr z, .skipcur 
0d95			 
0d95			 
0d95 3a b4 fb				ld a,(input_at_cursor) 
0d98 11 56 fa				ld de, cursor_shape 
0d9b cd e5 0a				call str_at_display 
0d9e			 
0d9e					; save length of current input string 
0d9e 2a b9 fb				ld hl, (input_start) 
0da1 cd 64 11				call strlenz 
0da4 7d					ld a,l 
0da5 32 ac fb				ld (input_len),a 
0da8			 
0da8			.skipcur: 
0da8			 
0da8 cd f5 0a			        call update_display 
0dab					 
0dab			 
0dab			 
0dab					; wait 
0dab				 
0dab					; TODO loop without wait to flash the cursor and char under cursor	 
0dab cd ce 66				call cin    ; _wait 
0dae			 
0dae fe 00				cp 0 
0db0 ca 64 0d				jp z, .is1 
0db3			 
0db3					; get ptr to char to input into 
0db3			 
0db3 4f					ld c,a 
0db4 2a b9 fb				ld hl, (input_start) 
0db7 3a a7 fb				ld a, (input_cursor) 
0dba cd 06 0d				call addatohl 
0dbd 22 bb fb				ld (input_ptr), hl 
0dc0 79					ld a,c 
0dc1			 
0dc1					; replace char under cursor 
0dc1			 
0dc1			;		ld hl, (input_ptr) 
0dc1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc1			;		ld (hl), a 
0dc1			 
0dc1			;	if DEBUG_INPUT 
0dc1			;		push af 
0dc1			;		ld a, 'i' 
0dc1			;		ld (debug_mark),a 
0dc1			;		pop af 
0dc1			;		CALLMONITOR 
0dc1			;	endif 
0dc1 fe 0e				cp KEY_HOME 
0dc3 20 0e				jr nz, .iske 
0dc5			 
0dc5 3a b6 fb				ld a, (input_at_pos) 
0dc8 32 b4 fb				ld (input_at_cursor),a 
0dcb 3e 00				ld a, 0 
0dcd 32 a7 fb				ld (input_cursor), a 
0dd0 c3 64 0d				jp .is1 
0dd3					 
0dd3 fe 0f		.iske:		cp KEY_END 
0dd5 20 03				jr nz, .isknw 
0dd7 c3 64 0d				jp .is1 
0dda			 
0dda fe 06		.isknw:		cp KEY_NEXTWORD 
0ddc 20 1b				jr nz, .iskpw 
0dde			 
0dde 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0de1 7e					ld a,(hl)	 
0de2 fe 00				cp 0 
0de4 ca 64 0d				jp z, .is1    ; end of string 
0de7 fe 20				cp ' ' 
0de9 ca 64 0d				jp z, .is1    ; end of word 
0dec 23					inc hl 
0ded 22 bb fb				ld (input_ptr), hl 
0df0 3a b4 fb				ld a, (input_at_cursor) 
0df3 3c					inc a 
0df4 32 b4 fb				ld (input_at_cursor), a 
0df7 18 e5				jr .isknwm 
0df9			 
0df9 fe 07		.iskpw:		cp KEY_PREVWORD 
0dfb 20 1b				jr nz, .iskl 
0dfd			.iskpwm:	 
0dfd 2a bb fb				ld hl, (input_ptr) 
0e00 7e					ld a,(hl)	 
0e01 fe 00				cp 0  
0e03 ca 64 0d				jp z, .is1    ; end of string 
0e06 fe 20				cp ' ' 
0e08 ca 64 0d				jp z, .is1    ; end of word 
0e0b 2b					dec hl 
0e0c 22 bb fb				ld (input_ptr), hl 
0e0f 3a b4 fb				ld a, (input_at_cursor) 
0e12 3d					dec a 
0e13 32 b4 fb				ld (input_at_cursor), a 
0e16 18 e5				jr .iskpwm 
0e18			 
0e18			 
0e18 fe 0b		.iskl:		cp KEY_LEFT 
0e1a 20 27				jr nz, .isk1 
0e1c			 
0e1c 3a a7 fb				ld a, (input_cursor) 
0e1f			 
0e1f fe 00				cp 0 
0e21 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0e24			 
0e24 3d					dec  a 		; TODO check underflow 
0e25 32 a7 fb				ld (input_cursor), a 
0e28			 
0e28 2a bb fb				ld hl, (input_ptr) 
0e2b 2b					dec hl 
0e2c 22 bb fb				ld (input_ptr), hl 
0e2f					 
0e2f 3a b4 fb				ld a, (input_at_cursor) 
0e32 3d					dec a 
0e33 32 b4 fb				ld (input_at_cursor), a 
0e36			 
0e36 3e 01				ld a, 1		; show cursor moving 
0e38 32 b1 fb				ld (input_cur_onoff),a 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 b2 fb				ld (input_cur_flash), a 
0e40			 
0e40 c3 64 0d				jp .is1 
0e43			 
0e43 fe 0c		.isk1:		cp KEY_RIGHT 
0e45 20 2a				jr nz, .isk2 
0e47			 
0e47 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4a 5f					ld e,a 
0e4b 3a a7 fb				ld a, (input_cursor) 
0e4e bb					cp e 
0e4f ca 64 0d				jp z, .is1		; at the end of string so dont go right 
0e52			 
0e52 3c					inc  a 		; TODO check overflow 
0e53 32 a7 fb				ld (input_cursor), a 
0e56			 
0e56 3a b4 fb				ld a, (input_at_cursor) 
0e59 3c					inc a 
0e5a 32 b4 fb				ld (input_at_cursor), a 
0e5d			 
0e5d 2a bb fb				ld hl, (input_ptr) 
0e60 23					inc hl 
0e61 22 bb fb				ld (input_ptr), hl 
0e64			 
0e64 3e 01				ld a, 1		; show cursor moving 
0e66 32 b1 fb				ld (input_cur_onoff),a 
0e69 3e 0f				ld a, CUR_BLINK_RATE 
0e6b 32 b2 fb				ld (input_cur_flash), a 
0e6e			 
0e6e c3 64 0d				jp .is1 
0e71			 
0e71 fe 05		.isk2:		cp KEY_UP 
0e73			 
0e73 20 26				jr nz, .isk3 
0e75			 
0e75					; swap last command with the current on 
0e75			 
0e75					; move cursor to start of string 
0e75 2a b9 fb				ld hl, (input_start) 
0e78 22 bb fb				ld (input_ptr), hl 
0e7b			 
0e7b 3a b6 fb				ld a, (input_at_pos) 
0e7e 32 b4 fb				ld (input_at_cursor), a 
0e81			 
0e81 3e 00				ld a, 0 
0e83 32 a7 fb				ld (input_cursor), a 
0e86					 
0e86					; swap input and last command buffers 
0e86			 
0e86 21 ca f2				ld hl, os_cli_cmd 
0e89 11 c9 f3				ld de, os_last_cmd 
0e8c 06 ff				ld b, 255 
0e8e 7e			.swap1:		ld a, (hl) 
0e8f 4f					ld c,a 
0e90 1a					ld a, (de) 
0e91 77					ld (hl), a 
0e92 79					ld a,c 
0e93 12					ld (de),a 
0e94 23					inc hl 
0e95 13					inc de 
0e96 10 f6				djnz .swap1 
0e98			 
0e98			 
0e98			 
0e98			 
0e98			 
0e98 c3 64 0d				jp .is1 
0e9b			 
0e9b fe 08		.isk3:		cp KEY_BS 
0e9d 20 3c				jr nz, .isk4 
0e9f			 
0e9f 3a a7 fb				ld a, (input_cursor) 
0ea2			 
0ea2 fe 00				cp 0 
0ea4 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0ea7			 
0ea7 3d					dec  a 		; TODO check underflow 
0ea8 32 a7 fb				ld (input_cursor), a 
0eab			 
0eab					; hl is source 
0eab					; de needs to be source - 1 
0eab			 
0eab			;		ld a, 0 
0eab			;		dec hl 
0eab			;		ld (hl), a 
0eab			 
0eab 2a bb fb				ld hl, (input_ptr) 
0eae 2b					dec hl 
0eaf 22 bb fb				ld (input_ptr), hl 
0eb2			 
0eb2					; shift all data 
0eb2			 
0eb2 e5					push hl 
0eb3 23					inc hl 
0eb4 d1					pop de 
0eb5 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb8 4f					ld c,a 
0eb9 06 00				ld b,0 
0ebb ed b0				ldir  
0ebd			 
0ebd			 
0ebd			 
0ebd			 
0ebd 3a b4 fb				ld a, (input_at_cursor) 
0ec0 3d					dec a 
0ec1 32 b4 fb				ld (input_at_cursor), a 
0ec4			 
0ec4			 
0ec4 3e 01				ld a, 1		; show cursor moving 
0ec6 32 b1 fb				ld (input_cur_onoff),a 
0ec9 3e 0f				ld a, CUR_BLINK_RATE 
0ecb 32 b2 fb				ld (input_cur_flash), a 
0ece			 
0ece					; remove char 
0ece 3a b4 fb				ld a, (input_at_cursor) 
0ed1 3c					inc a 
0ed2 11 5c 0f				ld de,.iblank 
0ed5 cd e5 0a				call str_at_display 
0ed8			 
0ed8 c3 64 0d				jp .is1 
0edb			 
0edb fe 0d		.isk4:		cp KEY_CR 
0edd 28 6c				jr z, .endinput 
0edf			 
0edf					; else add the key press to the end 
0edf			 
0edf 4f					ld c, a			; save key pressed 
0ee0			 
0ee0 7e					ld a,(hl)		; get what is currently under char 
0ee1			 
0ee1 fe 00				cp 0			; we are at the end of the string 
0ee3 20 2f				jr nz, .onchar 
0ee5					 
0ee5					; add a char to the end of the string 
0ee5				 
0ee5 71					ld (hl),c 
0ee6 23					inc hl 
0ee7			;		ld a,' ' 
0ee7			;		ld (hl),a 
0ee7			;		inc hl 
0ee7 3e 00				ld a,0 
0ee9 77					ld (hl),a 
0eea 2b					dec hl 
0eeb			 
0eeb 3a a7 fb				ld a, (input_cursor) 
0eee 3c					inc a				; TODO check max string length and scroll  
0eef 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ef2							 
0ef2 3a b4 fb				ld a, (input_at_cursor) 
0ef5 3c					inc a 
0ef6 32 b4 fb				ld (input_at_cursor), a 
0ef9			 
0ef9 2a bb fb				ld hl, (input_ptr) 
0efc 23					inc hl 
0efd 22 bb fb				ld (input_ptr), hl 
0f00			 
0f00 2a bb fb				ld hl, (input_ptr) 
0f03 23					inc hl 
0f04 22 bb fb				ld (input_ptr), hl 
0f07			;	if DEBUG_INPUT 
0f07			;		push af 
0f07			;		ld a, '+' 
0f07			;		ld (debug_mark),a 
0f07			;		pop af 
0f07			;		CALLMONITOR 
0f07			;	endif 
0f07 3e 01				ld a, 1		; show cursor moving 
0f09 32 b1 fb				ld (input_cur_onoff),a 
0f0c 3e 0f				ld a, CUR_BLINK_RATE 
0f0e 32 b2 fb				ld (input_cur_flash), a 
0f11 c3 64 0d				jp .is1 
0f14					 
0f14			 
0f14			 
0f14					; if on a char then insert 
0f14			.onchar: 
0f14			 
0f14					; TODO over flow check: make sure insert does not blow out buffer 
0f14			 
0f14					; need to do some maths to use lddr 
0f14			 
0f14 e5					push hl   ; save char pos 
0f15 c5					push bc 
0f16			 
0f16 2a b9 fb				ld hl, (input_start) 
0f19 3a ac fb				ld a, (input_len) 
0f1c cd 06 0d				call addatohl  		; end of string 
0f1f 23					inc hl 
0f20 23					inc hl		; past zero term 
0f21 e5					push hl 
0f22 23					inc hl 
0f23 e5					push hl  
0f24			 
0f24								; start and end of lddr set, now how much to move? 
0f24			 
0f24							 
0f24 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f27 47					ld b,a 
0f28 3a ac fb				ld a,(input_len) 
0f2b 5f					ld e,a 
0f2c 90					sub b 
0f2d 3c					inc a		;?? 
0f2e 3c					inc a		;?? 
0f2f 3c					inc a		;?? 
0f30			 
0f30 06 00				ld b,0 
0f32 4f					ld c,a 
0f33			 
0f33				if DEBUG_INPUT 
0f33					push af 
0f33					ld a, 'i' 
0f33					ld (debug_mark),a 
0f33					pop af 
0f33			;		CALLMONITOR 
0f33				endif 
0f33 d1					pop de 
0f34 e1					pop hl 
0f35				if DEBUG_INPUT 
0f35					push af 
0f35					ld a, 'I' 
0f35					ld (debug_mark),a 
0f35					pop af 
0f35			;		CALLMONITOR 
0f35				endif 
0f35 ed b8				lddr 
0f37				 
0f37			 
0f37			 
0f37					; TODO have a key for insert/overwrite mode???? 
0f37 c1					pop bc 
0f38 e1					pop hl 
0f39 71					ld (hl), c		; otherwise overwrite current char 
0f3a					 
0f3a			 
0f3a			 
0f3a			 
0f3a 3a a7 fb				ld a, (input_cursor) 
0f3d 3c					inc  a 		; TODO check overflow 
0f3e 32 a7 fb				ld (input_cursor), a 
0f41			 
0f41 3a b4 fb				ld a, (input_at_cursor) 
0f44 3c					inc a 
0f45 32 b4 fb				ld (input_at_cursor), a 
0f48			 
0f48 c3 64 0d				jp .is1 
0f4b			 
0f4b			.endinput:	; TODO look for end of string 
0f4b			 
0f4b					; add trailing space for end of token 
0f4b			 
0f4b 2a b9 fb				ld hl, (input_start) 
0f4e 3a ac fb				ld a,(input_len) 
0f51 cd 06 0d				call addatohl 
0f54 3e 20				ld a, ' ' 
0f56 77					ld (hl),a 
0f57					; TODO eof of parse marker 
0f57			 
0f57 23					inc hl 
0f58 3e 00				ld a, 0 
0f5a 77					ld (hl),a 
0f5b			 
0f5b			 
0f5b c9					ret 
0f5c			 
0f5c .. 00		.iblank: db " ",0 
0f5e			 
0f5e			 
0f5e 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f61 22 b9 fb				ld (input_start), hl 
0f64 3e 01				ld a,1			; add cursor 
0f66 77					ld (hl),a 
0f67 23					inc hl 
0f68 3e 00				ld a,0 
0f6a 77					ld (hl),a 
0f6b 22 bb fb				ld (input_ptr), hl 
0f6e 7a					ld a,d 
0f6f 32 b8 fb				ld (input_size), a 
0f72 3e 00				ld a,0 
0f74 32 a7 fb				ld (input_cursor),a 
0f77			.instr1:	 
0f77			 
0f77					; TODO do block cursor 
0f77					; TODO switch cursor depending on the modifer key 
0f77			 
0f77					; update cursor shape change on key hold 
0f77			 
0f77 2a bb fb				ld hl, (input_ptr) 
0f7a 2b					dec hl 
0f7b 3a 56 fa				ld a,(cursor_shape) 
0f7e 77					ld (hl), a 
0f7f			 
0f7f					; display entered text 
0f7f 3a b6 fb				ld a,(input_at_pos) 
0f82 cd ec 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f85 ed 5b b9 fb	            	LD   de, (input_start) 
0f89 cd f4 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8c			 
0f8c cd ce 66				call cin 
0f8f fe 00				cp 0 
0f91 28 e4				jr z, .instr1 
0f93			 
0f93					; proecess keyboard controls first 
0f93			 
0f93 2a bb fb				ld hl,(input_ptr) 
0f96			 
0f96 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f98 28 5a				jr z, .instrcr 
0f9a			 
0f9a fe 08				cp KEY_BS 	; back space 
0f9c 20 0f				jr nz, .instr2 
0f9e					; process back space 
0f9e			 
0f9e					; TODO stop back space if at start of string 
0f9e 2b					dec hl 
0f9f 2b					dec hl ; to over write cursor 
0fa0 3a 56 fa				ld a,(cursor_shape) 
0fa3					;ld a,0 
0fa3 77					ld (hl),a 
0fa4 23					inc hl 
0fa5 3e 20				ld a," " 
0fa7 77					ld (hl),a 
0fa8 22 bb fb				ld (input_ptr),hl 
0fab					 
0fab			 
0fab 18 ca				jr .instr1 
0fad			 
0fad fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0faf 20 06				jr nz, .instr3 
0fb1 2b					dec hl 
0fb2 22 bb fb				ld (input_ptr),hl 
0fb5 18 c0				jr .instr1 
0fb7				 
0fb7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb9 20 06				jr nz, .instr4 
0fbb 23					inc hl 
0fbc 22 bb fb				ld (input_ptr),hl 
0fbf 18 b6				jr .instr1 
0fc1			 
0fc1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc3 20 06				jr nz, .instr5 
0fc5 2b					dec hl 
0fc6 22 bb fb				ld (input_ptr),hl 
0fc9 18 ac				jr .instr1 
0fcb			 
0fcb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fcd 20 06				jr nz, .instr6 
0fcf 2b					dec hl 
0fd0 22 bb fb				ld (input_ptr),hl 
0fd3 18 a2				jr .instr1 
0fd5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd7 20 0b				jr nz, .instrnew 
0fd9			 
0fd9 21 a3 ef			ld hl, scratch 
0fdc 11 c9 f3			ld de, os_last_cmd 
0fdf cd fd 0f			call strcpy 
0fe2 18 93				jr .instr1 
0fe4			 
0fe4			 
0fe4			.instrnew:	; no special key pressed to see if we have room to store it 
0fe4			 
0fe4					; TODO do string size test 
0fe4			 
0fe4 2b					dec hl ; to over write cursor 
0fe5 77					ld (hl),a 
0fe6 23					inc hl 
0fe7 3a 56 fa				ld a,(cursor_shape) 
0fea 77					ld (hl),a 
0feb 23					inc hl 
0fec 3e 00				ld a,0 
0fee 77					ld (hl),a 
0fef			 
0fef 22 bb fb				ld (input_ptr),hl 
0ff2					 
0ff2 18 83				jr .instr1 
0ff4 2b			.instrcr:	dec hl		; remove cursor 
0ff5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff7 77					ld (hl),a 
0ff8 23					inc hl 
0ff9 3e 00				ld a,0 
0ffb 77					ld (hl),a 
0ffc			 
0ffc			 
0ffc					; if at end of line scroll up    
0ffc					; TODO detecting only end of line 4 for scroll up  
0ffc			 
0ffc					;ld   
0ffc			 
0ffc c9					ret 
0ffd			 
0ffd			 
0ffd			; strcpy hl = dest, de source 
0ffd			 
0ffd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ffe b7			            OR   A              ;Null terminator? 
0fff c8			            RET  Z              ;Yes, so finished 
1000 1a					ld a,(de) 
1001 77					ld (hl),a 
1002 13			            INC  DE             ;Point to next character 
1003 23					inc hl 
1004 18 f7		            JR   strcpy       ;Repeat 
1006 c9					ret 
1007			 
1007			 
1007			; TODO string_at  
1007			; pass string which starts with lcd offset address and then null term string 
1007			 
1007			; TODO string to dec 
1007			; TODO string to hex 
1007			; TODO byte to string hex 
1007			; TODO byte to string dec 
1007			 
1007			 
1007			 
1007			; from z80uartmonitor 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1007			; pass hl for where to put the text 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007 c5			hexout:	PUSH BC 
1008 f5					PUSH AF 
1009 47					LD B, A 
100a					; Upper nybble 
100a cb 3f				SRL A 
100c cb 3f				SRL A 
100e cb 3f				SRL A 
1010 cb 3f				SRL A 
1012 cd 22 10				CALL tohex 
1015 77					ld (hl),a 
1016 23					inc hl	 
1017					 
1017					; Lower nybble 
1017 78					LD A, B 
1018 e6 0f				AND 0FH 
101a cd 22 10				CALL tohex 
101d 77					ld (hl),a 
101e 23					inc hl	 
101f					 
101f f1					POP AF 
1020 c1					POP BC 
1021 c9					RET 
1022					 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			tohex: 
1022 e5					PUSH HL 
1023 d5					PUSH DE 
1024 16 00				LD D, 0 
1026 5f					LD E, A 
1027 21 2f 10				LD HL, .DATA 
102a 19					ADD HL, DE 
102b 7e					LD A, (HL) 
102c d1					POP DE 
102d e1					POP HL 
102e c9					RET 
102f			 
102f			.DATA: 
102f 30					DEFB	30h	; 0 
1030 31					DEFB	31h	; 1 
1031 32					DEFB	32h	; 2 
1032 33					DEFB	33h	; 3 
1033 34					DEFB	34h	; 4 
1034 35					DEFB	35h	; 5 
1035 36					DEFB	36h	; 6 
1036 37					DEFB	37h	; 7 
1037 38					DEFB	38h	; 8 
1038 39					DEFB	39h	; 9 
1039 41					DEFB	41h	; A 
103a 42					DEFB	42h	; B 
103b 43					DEFB	43h	; C 
103c 44					DEFB	44h	; D 
103d 45					DEFB	45h	; E 
103e 46					DEFB	46h	; F 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103f			;;    subtract $30, if result > 9 then subtract $7 more 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			atohex: 
103f d6 30				SUB $30 
1041 fe 0a				CP 10 
1043 f8					RET M		; If result negative it was 0-9 so we're done 
1044 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1046 c9					RET		 
1047			 
1047			 
1047			 
1047			 
1047			; Get 2 ASCII characters as hex byte from pointer in hl 
1047			 
1047			BYTERD: 
1047 16 00			LD	D,00h		;Set up 
1049 cd 51 10			CALL	HEXCON		;Get byte and convert to hex 
104c 87				ADD	A,A		;First nibble so 
104d 87				ADD	A,A		;multiply by 16 
104e 87				ADD	A,A		; 
104f 87				ADD	A,A		; 
1050 57				LD	D,A		;Save hi nibble in D 
1051			HEXCON: 
1051 7e				ld a, (hl)		;Get next chr 
1052 23				inc hl 
1053 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1055 fe 0a			CP	00Ah		;Is it 0-9 ? 
1057 38 02			JR	C,NALPHA	;If so miss next bit 
1059 d6 07			SUB	007h		;Else convert alpha 
105b			NALPHA: 
105b b2				OR	D		;Add hi nibble back 
105c c9				RET			; 
105d			 
105d			 
105d			; 
105d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
105d			; Since the routines get_byte and therefore get_nibble are called, only valid 
105d			; characters (0-9a-f) are accepted. 
105d			; 
105d			;get_word        push    af 
105d			;                call    get_byte        ; Get the upper byte 
105d			;                ld      h, a 
105d			;                call    get_byte        ; Get the lower byte 
105d			;                ld      l, a 
105d			;                pop     af 
105d			;                ret 
105d			; 
105d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
105d			; the routine get_nibble is used only valid characters are accepted - the  
105d			; input routine only accepts characters 0-9a-f. 
105d			; 
105d c5			get_byte:        push    bc              ; Save contents of B (and C) 
105e 7e					ld a,(hl) 
105f 23					inc hl 
1060 cd 85 10		                call    nibble2val      ; Get upper nibble 
1063 cb 07		                rlc     a 
1065 cb 07		                rlc     a 
1067 cb 07		                rlc     a 
1069 cb 07		                rlc     a 
106b 47			                ld      b, a            ; Save upper four bits 
106c 7e					ld a,(hl) 
106d cd 85 10		                call    nibble2val      ; Get lower nibble 
1070 b0			                or      b               ; Combine both nibbles 
1071 c1			                pop     bc              ; Restore B (and C) 
1072 c9			                ret 
1073			; 
1073			; Get a hexadecimal digit from the serial line. This routine blocks until 
1073			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1073			; to the serial line interface. The lower 4 bits of A contain the value of  
1073			; that particular digit. 
1073			; 
1073			;get_nibble      ld a,(hl)           ; Read a character 
1073			;                call    to_upper        ; Convert to upper case 
1073			;                call    is_hex          ; Was it a hex digit? 
1073			;                jr      nc, get_nibble  ; No, get another character 
1073			 ;               call    nibble2val      ; Convert nibble to value 
1073			 ;               call    print_nibble 
1073			 ;               ret 
1073			; 
1073			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1073			; A valid hexadecimal digit is denoted by a set C flag. 
1073			; 
1073			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1073			;                ret     nc              ; Yes 
1073			;                cp      '0'             ; Less than '0'? 
1073			;                jr      nc, is_hex_1    ; No, continue 
1073			;                ccf                     ; Complement carry (i.e. clear it) 
1073			;                ret 
1073			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1073			;                ret     c               ; Yes 
1073			;                cp      'A'             ; Less than 'A'? 
1073			;                jr      nc, is_hex_2    ; No, continue 
1073			;                ccf                     ; Yes - clear carry and return 
1073			;                ret 
1073			;is_hex_2        scf                     ; Set carry 
1073			;                ret 
1073			; 
1073			; Convert a single character contained in A to upper case: 
1073			; 
1073 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1075 d8			                ret     c 
1076 fe 7b		                cp      'z' + 1         ; > 'z'? 
1078 d0			                ret     nc              ; Nothing to do, either 
1079 e6 5f		                and     $5f             ; Convert to upper case 
107b c9			                ret 
107c			 
107c			 
107c			to_lower: 
107c			 
107c			   ; if char is in [A-Z] make it lower case 
107c			 
107c			   ; enter : a = char 
107c			   ; exit  : a = lower case char 
107c			   ; uses  : af 
107c			 
107c fe 41		   cp 'A' 
107e d8			   ret c 
107f			    
107f fe 5b		   cp 'Z'+1 
1081 d0			   ret nc 
1082			    
1082 f6 20		   or $20 
1084 c9			   ret 
1085			 
1085			; 
1085			; Expects a hexadecimal digit (upper case!) in A and returns the 
1085			; corresponding value in A. 
1085			; 
1085 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1087 38 02		                jr      c, nibble2val_1 ; Yes 
1089 d6 07		                sub     7               ; Adjust for A-F 
108b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
108d e6 0f		                and     $f              ; Only return lower 4 bits 
108f c9			                ret 
1090			; 
1090			; Print_nibble prints a single hex nibble which is contained in the lower  
1090			; four bits of A: 
1090			; 
1090			;print_nibble    push    af              ; We won't destroy the contents of A 
1090			;                and     $f              ; Just in case... 
1090			;                add     a, '0'             ; If we have a digit we are done here. 
1090			;                cp      '9' + 1         ; Is the result > 9? 
1090			;                jr      c, print_nibble_1 
1090			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1090			;print_nibble_1  call    putc            ; Print the nibble and 
1090			;                pop     af              ; restore the original value of A 
1090			;                ret 
1090			;; 
1090			;; Send a CR/LF pair: 
1090			; 
1090			;crlf            push    af 
1090			;                ld      a, cr 
1090			;                call    putc 
1090			;                ld      a, lf 
1090			;                call    putc 
1090			;                pop     af 
1090			;                ret 
1090			; 
1090			; Print_word prints the four hex digits of a word to the serial line. The  
1090			; word is expected to be in HL. 
1090			; 
1090			;print_word      push    hl 
1090			;                push    af 
1090			;                ld      a, h 
1090			;                call    print_byte 
1090			;                ld      a, l 
1090			;                call    print_byte 
1090			;                pop     af 
1090			;                pop     hl 
1090			;                ret 
1090			; 
1090			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1090			; The byte to be printed is expected to be in A. 
1090			; 
1090			;print_byte      push    af              ; Save the contents of the registers 
1090			;                push    bc 
1090			;                ld      b, a 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                call    print_nibble    ; Print high nibble 
1090			;                ld      a, b 
1090			;                call    print_nibble    ; Print low nibble 
1090			;                pop     bc              ; Restore original register contents 
1090			;                pop     af 
1090			;                ret 
1090			 
1090			 
1090			 
1090			 
1090			 
1090			fourehexhl:  
1090 7e				ld a,(hl) 
1091 cd 3f 10			call atohex 
1094 cb 3f				SRL A 
1096 cb 3f				SRL A 
1098 cb 3f				SRL A 
109a cb 3f				SRL A 
109c 47				ld b, a 
109d 23				inc hl 
109e 7e				ld a,(hl) 
109f 23				inc hl 
10a0 cd 3f 10			call atohex 
10a3 80				add b 
10a4 57				ld d,a 
10a5 7e				ld a,(hl) 
10a6 cd 3f 10			call atohex 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 47				ld b, a 
10b2 23				inc hl 
10b3 7e				ld a,(hl) 
10b4 23				inc hl 
10b5 cd 3f 10			call atohex 
10b8 80				add b 
10b9 5f				ld e, a 
10ba d5				push de 
10bb e1				pop hl 
10bc c9				ret 
10bd			 
10bd			; pass hl. returns z set if the byte at hl is a digit 
10bd			;isdigithl:  
10bd			;	push bc 
10bd			;	ld a,(hl) 
10bd			;	cp ':' 
10bd			;	jr nc, .isdf 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .isdf		; < 
10bd			; 
10bd			;	; TODO find a better way to set z 
10bd			; 
10bd			;	ld b,a 
10bd			;	cp b 
10bd			;	pop bc 
10bd			;	ret 
10bd			; 
10bd			;.isdf:	; not digit so clear z 
10bd			; 
10bd			;	; TODO find a better way to unset z 
10bd			; 
10bd			;	ld b,a 
10bd			;	inc b 
10bd			;	cp b 
10bd			; 
10bd			;	pop bc 
10bd			;	ret 
10bd				 
10bd				 
10bd			 
10bd			 
10bd			; pass hl as the four byte address to load 
10bd			 
10bd			get_word_hl:  
10bd e5				push hl 
10be cd 5d 10			call get_byte 
10c1				 
10c1 47				ld b, a 
10c2			 
10c2 e1				pop hl 
10c3 23				inc hl 
10c4 23				inc hl 
10c5			 
10c5			; TODO not able to handle a-f  
10c5 7e				ld a,(hl) 
10c6			;	;cp ':' 
10c6			;	cp 'g' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp 'G' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp '0' 
10c6			;	jr c, .single_byte_hl		; < 
10c6			 
10c6				;call isdigithl 
10c6 fe 00			cp 0 
10c8 28 06			jr z, .single_byte_hl 
10ca			 
10ca			.getwhln:   ; hex word so get next byte 
10ca			 
10ca cd 5d 10			call get_byte 
10cd 6f				ld l, a 
10ce 60				ld h,b 
10cf c9				ret 
10d0 68			.single_byte_hl:   ld l,b 
10d1 26 00				ld h,0 
10d3 c9					ret 
10d4			 
10d4			 
10d4			 
10d4			 
10d4 21 c7 19			ld hl,asc+1 
10d7			;	ld a, (hl) 
10d7			;	call nibble2val 
10d7 cd 5d 10			call get_byte 
10da			 
10da			;	call fourehexhl 
10da 32 d7 ef			ld (scratch+52),a 
10dd				 
10dd 21 d5 ef			ld hl,scratch+50 
10e0 22 c6 f2			ld (os_cur_ptr),hl 
10e3			 
10e3 c9				ret 
10e4			 
10e4			 
10e4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e4			 
10e4			; Decimal Unsigned Version 
10e4			 
10e4			;Number in a to decimal ASCII 
10e4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e4			;Example: display a=56 as "056" 
10e4			;input: a = number 
10e4			;Output: a=0,value of a in the screen 
10e4			;destroys af,bc (don't know about hl and de) 
10e4			DispAToASCII: 
10e4 0e 9c			ld	c,-100 
10e6 cd f0 10			call	.Na1 
10e9 0e f6			ld	c,-10 
10eb cd f0 10			call	.Na1 
10ee 0e ff			ld	c,-1 
10f0 06 2f		.Na1:	ld	b,'0'-1 
10f2 04			.Na2:	inc	b 
10f3 81				add	a,c 
10f4 38 fc			jr	c,.Na2 
10f6 91				sub	c		;works as add 100/10/1 
10f7 f5				push af		;safer than ld c,a 
10f8 78				ld	a,b		;char is in b 
10f9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f9 f1				pop af		;safer than ld a,c 
10fa c9				ret 
10fb			 
10fb			; Decimal Signed Version 
10fb			 
10fb			; DispA 
10fb			; -------------------------------------------------------------- 
10fb			; Converts a signed integer value to a zero-terminated ASCII 
10fb			; string representative of that value (using radix 10). 
10fb			; -------------------------------------------------------------- 
10fb			; INPUTS: 
10fb			;     HL     Value to convert (two's complement integer). 
10fb			;     DE     Base address of string destination. (pointer). 
10fb			; -------------------------------------------------------------- 
10fb			; OUTPUTS: 
10fb			;     None 
10fb			; -------------------------------------------------------------- 
10fb			; REGISTERS/MEMORY DESTROYED 
10fb			; AF HL 
10fb			; -------------------------------------------------------------- 
10fb			 
10fb			;DispHLToASCII: 
10fb			;   push    de 
10fb			;   push    bc 
10fb			; 
10fb			;; Detect sign of HL. 
10fb			;    bit    7, h 
10fb			;    jr     z, ._DoConvert 
10fb			; 
10fb			;; HL is negative. Output '-' to string and negate HL. 
10fb			;    ld     a, '-' 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			; 
10fb			;; Negate HL (using two's complement) 
10fb			;    xor    a 
10fb			;    sub    l 
10fb			;    ld     l, a 
10fb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fb			;    sbc    a, h 
10fb			;    ld     h, a 
10fb			; 
10fb			;; Convert HL to digit characters 
10fb			;._DoConvert: 
10fb			;    ld     b, 0     ; B will count character length of number 
10fb			;-   ld     a, 10 
10fb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fb			;    push   af 
10fb			;    inc    b 
10fb			;    ld     a, h 
10fb			;    or     l 
10fb			;    jr     nz, - 
10fb			; 
10fb			;; Retrieve digits from stack 
10fb			;-   pop    af 
10fb			;    or     $30 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			;    djnz   - 
10fb			; 
10fb			;; Terminate string with NULL 
10fb			;    xor    a 
10fb			;    ld     (de), a 
10fb			; 
10fb			;    pop    bc 
10fb			;    pop    de 
10fb			;    ret 
10fb			 
10fb			;Comments 
10fb			; 
10fb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fb			;    Note that the output string will not be fixed-width. 
10fb			; 
10fb			;Example Usage 
10fb			; 
10fb			;    ld    hl, -1004 
10fb			;    ld    de, OP1 
10fb			;    call  DispA 
10fb			;    ld    hl, OP1 
10fb			;    syscall  PutS 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			 
10fb			;Converts an ASCII string to an unsigned 16-bit integer 
10fb			;Quits when it reaches a non-decimal digit 
10fb			 
10fb			string_to_uint16: 
10fb			atoui_16: 
10fb			;Input: 
10fb			;     DE points to the string 
10fb			;Outputs: 
10fb			;     HL is the result 
10fb			;     A is the 8-bit value of the number 
10fb			;     DE points to the byte after the number 
10fb			;Destroys: 
10fb			;     BC 
10fb			;       if the string is non-empty, BC is HL/10 
10fb			;Size:  24 bytes 
10fb			;Speed: 42+d(104+{0,9}) 
10fb			;       d is the number of digits in the number 
10fb			;       max is 640 cycles for a 5 digit number 
10fb			;Assuming no leading zeros: 
10fb			;1 digit:  146cc 
10fb			;2 digit:  250cc 
10fb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fb			;avg: 544.81158447265625cc (544+13297/16384) 
10fb			;=============================================================== 
10fb 21 00 00		  ld hl,0 
10fe			.u16a: 
10fe 1a			  ld a,(de) 
10ff d6 30		  sub 30h 
1101 fe 0a		  cp 10 
1103 d0			  ret nc 
1104 13			  inc de 
1105 44			  ld b,h 
1106 4d			  ld c,l 
1107 29			  add hl,hl 
1108 29			  add hl,hl 
1109 09			  add hl,bc 
110a 29			  add hl,hl 
110b 85			  add a,l 
110c 6f			  ld l,a 
110d 30 ef		  jr nc,.u16a 
110f 24			  inc h 
1110 c3 fe 10		  jp .u16a 
1113			 
1113			 
1113			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1113			 
1113			;written by Zeda 
1113			;Converts a 16-bit unsigned integer to an ASCII string. 
1113			 
1113			uitoa_16: 
1113			;Input: 
1113			;   DE is the number to convert 
1113			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1113			;Output: 
1113			;   HL points to the null-terminated ASCII string 
1113			;      NOTE: This isn't necessarily the same as the input HL. 
1113 d5			  push de 
1114 c5			  push bc 
1115 f5			  push af 
1116 eb			  ex de,hl 
1117			 
1117 01 f0 d8		  ld bc,-10000 
111a 3e 2f		  ld a,'0'-1 
111c 3c			  inc a 
111d 09			  add hl,bc  
111e 38 fc		   jr c,$-2 
1120 12			  ld (de),a 
1121 13			  inc de 
1122			 
1122 01 e8 03		  ld bc,1000 
1125 3e 3a		  ld a,'9'+1 
1127 3d			  dec a  
1128 09			  add hl,bc  
1129 30 fc		   jr nc,$-2 
112b 12			  ld (de),a 
112c 13			  inc de 
112d			 
112d 01 9c ff		  ld bc,-100 
1130 3e 2f		  ld a,'0'-1 
1132 3c			  inc a  
1133 09			  add hl,bc  
1134 38 fc		   jr c,$-2 
1136 12			  ld (de),a 
1137 13			  inc de 
1138			 
1138 7d			  ld a,l 
1139 26 3a		  ld h,'9'+1 
113b 25			  dec h  
113c c6 0a		  add a,10  
113e 30 fb		   jr nc,$-3 
1140 c6 30		  add a,'0' 
1142 eb			  ex de,hl 
1143 72			  ld (hl),d 
1144 23			  inc hl 
1145 77			  ld (hl),a 
1146 23			  inc hl 
1147 36 00		  ld (hl),0 
1149			 
1149			;Now strip the leading zeros 
1149 0e fa		  ld c,-6 
114b 09			  add hl,bc 
114c 3e 30		  ld a,'0' 
114e 23			  inc hl  
114f be			  cp (hl)  
1150 28 fc		  jr z,$-2 
1152			 
1152			;Make sure that the string is non-empty! 
1152 7e			  ld a,(hl) 
1153 b7			  or a 
1154 20 01		  jr nz,.atoub 
1156 2b			  dec hl 
1157			.atoub: 
1157			 
1157 f1			  pop af 
1158 c1			  pop bc 
1159 d1			  pop de 
115a c9			  ret 
115b			 
115b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115b			 
115b			toUpper: 
115b			;A is the char. 
115b			;If A is a lowercase letter, this sets it to the matching uppercase 
115b			;18cc or 30cc or 41cc 
115b			;avg: 26.75cc 
115b fe 61		  cp 'a' 
115d d8			  ret c 
115e fe 7b		  cp 'z'+1 
1160 d0			  ret nc 
1161 d6 20		  sub 'a'-'A' 
1163 c9			  ret 
1164			 
1164			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1164			 
1164			; String Length 
1164			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1164			 
1164			; Get the length of the null-terminated string starting at $8000 hl 
1164			;    LD     HL, $8000 
1164			 
1164			strlenz: 
1164			 
1164 af			    XOR    A               ; Zero is the value we are looking for. 
1165 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1166 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116a 6f			    LD     L, A             ; number of bytes 
116b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116d 2b			    DEC    HL              ; Compensate for null. 
116e c9				ret 
116f			 
116f			; Get the length of the A terminated string starting at $8000 hl 
116f			;    LD     HL, $8000 
116f			 
116f			strlent: 
116f			 
116f			                  ; A is the value we are looking for. 
116f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1171 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1173			                           ; 65, 536 bytes (the entire addressable memory space). 
1173 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1175			 
1175			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1175 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1177 2e 00		    LD     L, 0             ; number of bytes 
1179 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117b 2b			    DEC    HL              ; Compensate for null. 
117c c9				ret 
117d			 
117d			 
117d			;Comparing Strings 
117d			 
117d			;IN    HL     Address of string1. 
117d			;      DE     Address of string2. 
117d			 
117d			; doc given but wrong??? 
117d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
117d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
117d			; tested 
117d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
117d			 
117d			strcmp_old: 
117d e5			    PUSH   HL 
117e d5			    PUSH   DE 
117f			 
117f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1180 be			    CP     (HL)            ; (want to minimize work). 
1181 38 01		    JR     C, Str1IsBigger 
1183 7e			    LD     A, (HL) 
1184			 
1184			Str1IsBigger: 
1184 4f			    LD     C, A             ; Put length in BC 
1185 06 00		    LD     B, 0 
1187 13			    INC    DE              ; Increment pointers to meat of string. 
1188 23			    INC    HL 
1189			 
1189			CmpLoop: 
1189 1a			    LD     A, (DE)          ; Compare bytes. 
118a ed a1		    CPI 
118c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
118e 13			    INC    DE              ; Update pointer. 
118f ea 89 11		    JP     PE, CmpLoop 
1192			 
1192 d1			    POP    DE 
1193 e1			    POP    HL 
1194 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1195 be			    CP     (HL) 
1196 c9			    RET 
1197			 
1197			NoMatch: 
1197 2b			    DEC    HL 
1198 be			    CP     (HL)            ; Compare again to affect carry. 
1199 d1			    POP    DE 
119a e1			    POP    HL 
119b c9			    RET 
119c			 
119c			;; test strmp 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr z, .z1 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z1: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr z, .z2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr c, .c1 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c1: 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr c, .c2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;	NEXTW 
119c			;.str1:   db "string1",0 
119c			;.str2:   db "string2",0 
119c			 
119c			; only care about direct match or not 
119c			; hl and de strings 
119c			; zero set if the same 
119c			 
119c			strcmp: 
119c 1a				ld a, (de) 
119d be				cp (hl) 
119e 28 02			jr z, .ssame 
11a0 b7				or a 
11a1 c9				ret 
11a2			 
11a2			.ssame:  
11a2 fe 00			cp 0 
11a4 c8				ret z 
11a5			 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f3			jr strcmp 
11a9				 
11a9				 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 0e 80		      ld    HL, heap_start 
11ad 22 0a 80		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 0c 80		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 0a 80		      ld    HL, heap_start+heap_size-4 
11b9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 fc ff		      ld    HL, heap_size-4 
11bf 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11c8 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 0a 80		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			if SOUND_ENABLE  
1366				include "firmware_sound.asm"  
1366			endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 96 13			ld hl, .configmn 
136b cd 03 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371 fe 01			cp 1 
1373 cc 07 15			call z, .savetostore 
1376			 
1376 fe 02			cp 2 
1378 cc 55 14			call z, .selautoload 
137b fe 03			cp 3 
137d cc 3e 14			call z, .disautoload 
1380 fe 04			cp 4 
1382 cc 05 15			call z, .selbank 
1385 fe 06			cp 6 
1387 cc e2 15			call z, .debug_tog 
138a fe 07			cp 7 
138c cc 2a 17			call z, .bpsgo 
138f fe 08			cp 8 
1391 cc 08 16			call z, hardware_diags 
1394			 
1394 18 d0			jr config 
1396			 
1396			.configmn: 
1396 a8 13			dw .c3 
1398 c4 13			dw .c2 
139a d9 13			dw .c2a 
139c ef 13			dw .c2b 
139e 03 14			dw .c4 
13a0 0c 14			dw .m4 
13a2 27 14			dw .m4b 
13a4 2f 14			dw .c1 
13a6 00 00			dw 0 
13a8				 
13a8			 
13a8 .. 00		.c3: db "Add User Dictionary To File",0 
13c4 .. 00		.c2: db "Select Autoload File",0 
13d9 .. 00		.c2a: db "Disable Autoload File", 0 
13ef .. 00		.c2b: db "Select Storage Bank",0 
1403 .. 00		.c4: db "Settings",0 
140c .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1427 .. 00		.m4b:   db "Monitor",0 
142f .. 00		.c1: db "Hardware Diags",0 
143e			 
143e			 
143e			.disautoload: 
143e				if STORAGE_SE 
143e 3e fe			ld a, $fe      ; bit 0 clear 
1440 32 ce f9			ld (spi_device), a 
1443			 
1443 cd ba 03			call storage_get_block_0 
1446			 
1446 3e 00			ld a, 0 
1448 32 09 fa			ld (store_page+STORE_0_AUTOFILE), a 
144b			 
144b 21 00 00				ld hl, 0 
144e 11 e8 f9				ld de, store_page 
1451 cd 6e 03			call storage_write_block	 ; save update 
1454				endif 
1454			 
1454			 
1454 c9				ret 
1455			 
1455			 
1455			 
1455			; Select auto start 
1455			 
1455			.selautoload: 
1455			 
1455				 
1455				if STORAGE_SE 
1455			 
1455 cd 2c 15				call config_dir 
1458 21 a3 ef			        ld hl, scratch 
145b 3e 00				ld a, 0 
145d cd 03 0b				call menu 
1460			 
1460 fe 00				cp 0 
1462 c8					ret z 
1463			 
1463 3d					dec a 
1464			 
1464			 
1464					; locate menu option 
1464			 
1464 21 a3 ef				ld hl, scratch 
1467 cd 2a 0a				call table_lookup 
146a			 
146a					if DEBUG_FORTH_WORDS 
146a						DMARK "ALl" 
146a f5				push af  
146b 3a 7f 14			ld a, (.dmark)  
146e 32 bd fb			ld (debug_mark),a  
1471 3a 80 14			ld a, (.dmark+1)  
1474 32 be fb			ld (debug_mark+1),a  
1477 3a 81 14			ld a, (.dmark+2)  
147a 32 bf fb			ld (debug_mark+2),a  
147d 18 03			jr .pastdmark  
147f ..			.dmark: db "ALl"  
1482 f1			.pastdmark: pop af  
1483			endm  
# End of macro DMARK
1483						CALLMONITOR 
1483 cd 20 17			call break_point_state  
1486				endm  
# End of macro CALLMONITOR
1486					endif 
1486					; with the pointer to the menu it, the byte following the zero term is the file id 
1486			 
1486 3e 00				ld a, 0 
1488 01 32 00				ld bc, 50   ; max of bytes to look at 
148b ed b1				cpir  
148d			 
148d					if DEBUG_FORTH_WORDS 
148d						DMARK "ALb" 
148d f5				push af  
148e 3a a2 14			ld a, (.dmark)  
1491 32 bd fb			ld (debug_mark),a  
1494 3a a3 14			ld a, (.dmark+1)  
1497 32 be fb			ld (debug_mark+1),a  
149a 3a a4 14			ld a, (.dmark+2)  
149d 32 bf fb			ld (debug_mark+2),a  
14a0 18 03			jr .pastdmark  
14a2 ..			.dmark: db "ALb"  
14a5 f1			.pastdmark: pop af  
14a6			endm  
# End of macro DMARK
14a6						CALLMONITOR 
14a6 cd 20 17			call break_point_state  
14a9				endm  
# End of macro CALLMONITOR
14a9					endif 
14a9					;inc hl 
14a9			 
14a9 7e					ld a, (hl)   ; file id 
14aa					 
14aa				        ; save bank and file ids 
14aa			 
14aa f5					push af 
14ab			 
14ab			; TODO need to save to block 0 on bank 1	 
14ab			 
14ab cd ba 03				call storage_get_block_0 
14ae			 
14ae					if DEBUG_FORTH_WORDS 
14ae						DMARK "AL0" 
14ae f5				push af  
14af 3a c3 14			ld a, (.dmark)  
14b2 32 bd fb			ld (debug_mark),a  
14b5 3a c4 14			ld a, (.dmark+1)  
14b8 32 be fb			ld (debug_mark+1),a  
14bb 3a c5 14			ld a, (.dmark+2)  
14be 32 bf fb			ld (debug_mark+2),a  
14c1 18 03			jr .pastdmark  
14c3 ..			.dmark: db "AL0"  
14c6 f1			.pastdmark: pop af  
14c7			endm  
# End of macro DMARK
14c7						CALLMONITOR 
14c7 cd 20 17			call break_point_state  
14ca				endm  
# End of macro CALLMONITOR
14ca					endif 
14ca f1					pop af 
14cb			 
14cb 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
14ce					 
14ce					; save bank id 
14ce			 
14ce 3a ce f9				ld a,(spi_device) 
14d1 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
14d4			 
14d4					; enable auto run of store file 
14d4			 
14d4 3e 01				ld a, 1 
14d6 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
14d9			 
14d9					; save buffer 
14d9			 
14d9 21 00 00				ld hl, 0 
14dc 11 e8 f9				ld de, store_page 
14df					if DEBUG_FORTH_WORDS 
14df						DMARK "ALw" 
14df f5				push af  
14e0 3a f4 14			ld a, (.dmark)  
14e3 32 bd fb			ld (debug_mark),a  
14e6 3a f5 14			ld a, (.dmark+1)  
14e9 32 be fb			ld (debug_mark+1),a  
14ec 3a f6 14			ld a, (.dmark+2)  
14ef 32 bf fb			ld (debug_mark+2),a  
14f2 18 03			jr .pastdmark  
14f4 ..			.dmark: db "ALw"  
14f7 f1			.pastdmark: pop af  
14f8			endm  
# End of macro DMARK
14f8						CALLMONITOR 
14f8 cd 20 17			call break_point_state  
14fb				endm  
# End of macro CALLMONITOR
14fb					endif 
14fb cd 6e 03			call storage_write_block	 ; save update 
14fe			  
14fe			 
14fe			 
14fe			 
14fe 21 a3 ef				ld hl, scratch 
1501 cd 19 15				call config_fdir 
1504			 
1504			 
1504				endif 
1504 c9				ret 
1505			 
1505			 
1505			 
1505			; Select storage bank 
1505			 
1505			.selbank: 
1505			 
1505				if STORAGE_SE 
1505				endif 
1505				 
1505 c9				ret 
1506			 
1506			if STORAGE_SE 
1506			 
1506			.config_ldir:   
1506				; Load storage bank labels into menu array 
1506			 
1506				 
1506			 
1506			 
1506 c9				ret 
1507			 
1507			 
1507			endif 
1507			 
1507			 
1507			; Save user words to storage 
1507			 
1507			.savetostore: 
1507			 
1507				if STORAGE_SE 
1507			 
1507 cd 2c 15				call config_dir 
150a 21 a3 ef			        ld hl, scratch 
150d 3e 00				ld a, 0 
150f cd 03 0b				call menu 
1512					 
1512 21 a3 ef				ld hl, scratch 
1515 cd 19 15				call config_fdir 
1518			 
1518			 
1518				endif 
1518			 
1518 c9				ret 
1519			 
1519			 
1519			 
1519			if STORAGE_SE 
1519			 
1519			config_fdir: 
1519				; using the scratch dir go through and release the memory allocated for each string 
1519				 
1519 21 a3 ef			ld hl, scratch 
151c 5e			.cfdir:	ld e,(hl) 
151d 23				inc hl 
151e 56				ld d,(hl) 
151f 23				inc hl 
1520			 
1520 eb				ex de, hl 
1521 cd 2f 0d			call ishlzero 
1524 c8				ret z     ; return on null pointer 
1525 cd 97 12			call free 
1528 eb				ex de, hl 
1529 18 f1			jr .cfdir 
152b			 
152b			 
152b c9				ret 
152c			 
152c			 
152c			config_dir: 
152c			 
152c				; for the config menus that need to build a directory of storage call this routine 
152c				; it will construct a menu in scratch to pass to menu 
152c			 
152c				; open storage device 
152c			 
152c				; execute DIR to build a list of files and their ids into scratch in menu format 
152c				; once the menu has finished then will need to call config_fdir to release the strings 
152c				 
152c				; c = number items 
152c			 
152c				 
152c cd ba 03			call storage_get_block_0 
152f			 
152f 21 e8 f9			ld hl, store_page     ; get current id count 
1532 46				ld b, (hl) 
1533 0e 00			ld c, 0    ; count of files   
1535			 
1535			 
1535 21 a3 ef			ld hl, scratch 
1538 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
153b			 
153b				; check for empty drive 
153b			 
153b 3e 00			ld a, 0 
153d b8				cp b 
153e ca d8 15			jp z, .dirdone 
1541			 
1541				 
1541					if DEBUG_FORTH_WORDS 
1541						DMARK "Cdc" 
1541 f5				push af  
1542 3a 56 15			ld a, (.dmark)  
1545 32 bd fb			ld (debug_mark),a  
1548 3a 57 15			ld a, (.dmark+1)  
154b 32 be fb			ld (debug_mark+1),a  
154e 3a 58 15			ld a, (.dmark+2)  
1551 32 bf fb			ld (debug_mark+2),a  
1554 18 03			jr .pastdmark  
1556 ..			.dmark: db "Cdc"  
1559 f1			.pastdmark: pop af  
155a			endm  
# End of macro DMARK
155a						CALLMONITOR 
155a cd 20 17			call break_point_state  
155d				endm  
# End of macro CALLMONITOR
155d					endif 
155d			 
155d			 
155d			.diritem:	 
155d c5				push bc 
155e				; for each of the current ids do a search for them and if found push to stack 
155e			 
155e 21 40 00				ld hl, STORE_BLOCK_PHY 
1561 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1563 58					ld e,b 
1564			 
1564 cd 2a 06				call storage_findnextid 
1567			 
1567			 
1567					; if found hl will be non zero 
1567			 
1567 cd 2f 0d				call ishlzero 
156a 28 69				jr z, .dirnotfound 
156c			 
156c					; increase count 
156c			 
156c c1					pop bc	 
156d 0c					inc c 
156e c5					push bc 
156f					 
156f			 
156f					; get file header and push the file name 
156f			 
156f 11 e8 f9				ld de, store_page 
1572 cd 09 03				call storage_read_block 
1575			 
1575					; push file id to stack 
1575				 
1575 3a e8 f9				ld a, (store_page) 
1578 26 00				ld h, 0 
157a 6f					ld l, a 
157b			 
157b					;call forth_push_numhl 
157b					; TODO store id 
157b			 
157b e5					push hl 
157c			 
157c					; push extent count to stack  
157c				 
157c 21 eb f9				ld hl, store_page+3 
157f			 
157f					; get file name length 
157f			 
157f cd 64 11				call strlenz   
1582			 
1582 23					inc hl   ; cover zero term 
1583 23					inc hl  ; stick the id at the end of the area 
1584			 
1584 e5					push hl 
1585 c1					pop bc    ; move length to bc 
1586			 
1586 cd cd 11				call malloc 
1589			 
1589					; TODO save malloc area to scratch 
1589			 
1589 eb					ex de, hl 
158a 2a e4 f9				ld hl, (store_tmp2) 
158d 73					ld (hl), e 
158e 23					inc hl 
158f 72					ld (hl), d 
1590 23					inc hl 
1591 22 e4 f9				ld (store_tmp2), hl 
1594			 
1594					 
1594			 
1594					;pop hl   ; get source 
1594			;		ex de, hl    ; swap aronund	 
1594			 
1594 21 eb f9				ld hl, store_page+3 
1597					if DEBUG_FORTH_WORDS 
1597						DMARK "CFd" 
1597 f5				push af  
1598 3a ac 15			ld a, (.dmark)  
159b 32 bd fb			ld (debug_mark),a  
159e 3a ad 15			ld a, (.dmark+1)  
15a1 32 be fb			ld (debug_mark+1),a  
15a4 3a ae 15			ld a, (.dmark+2)  
15a7 32 bf fb			ld (debug_mark+2),a  
15aa 18 03			jr .pastdmark  
15ac ..			.dmark: db "CFd"  
15af f1			.pastdmark: pop af  
15b0			endm  
# End of macro DMARK
15b0						CALLMONITOR 
15b0 cd 20 17			call break_point_state  
15b3				endm  
# End of macro CALLMONITOR
15b3					endif 
15b3 ed b0				ldir 
15b5			 
15b5					; de is past string, move back one and store id 
15b5					 
15b5 1b					dec de 
15b6			 
15b6					; store file id 
15b6			 
15b6 e1					pop hl 
15b7 eb					ex de,hl 
15b8 73					ld (hl), e 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "Cdi" 
15b9 f5				push af  
15ba 3a ce 15			ld a, (.dmark)  
15bd 32 bd fb			ld (debug_mark),a  
15c0 3a cf 15			ld a, (.dmark+1)  
15c3 32 be fb			ld (debug_mark+1),a  
15c6 3a d0 15			ld a, (.dmark+2)  
15c9 32 bf fb			ld (debug_mark+2),a  
15cc 18 03			jr .pastdmark  
15ce ..			.dmark: db "Cdi"  
15d1 f1			.pastdmark: pop af  
15d2			endm  
# End of macro DMARK
15d2						CALLMONITOR 
15d2 cd 20 17			call break_point_state  
15d5				endm  
# End of macro CALLMONITOR
15d5					endif 
15d5					 
15d5			.dirnotfound: 
15d5 c1					pop bc     
15d6 10 85				djnz .diritem 
15d8				 
15d8			.dirdone:	 
15d8			 
15d8 3e 00				ld a, 0 
15da 2a e4 f9				ld hl, (store_tmp2) 
15dd 77					ld (hl), a 
15de 23					inc hl 
15df 77					ld (hl), a 
15e0 23					inc hl 
15e1					; push a count of the dir items found 
15e1			 
15e1			;		ld h, 0 
15e1			;		ld l, c 
15e1			 
15e1 c9				ret 
15e2			 
15e2			endif 
15e2			 
15e2			 
15e2			; Settings 
15e2			; Run  
15e2			 
15e2			 
15e2			 
15e2			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
15e2			;;hd_menu2:   db "        2: Editor",0   
15e2			;hd_menu2:   db "        2: Editor       6: Menu",0   
15e2			;hd_menu3:   db "        3: Storage",0 
15e2			;hd_menu4:   db "0=quit  4: Debug",0 
15e2			;hd_don:     db "ON",0 
15e2			;hd_doff:     db "OFF",0 
15e2			; 
15e2			; 
15e2			; 
15e2			;hardware_diags_old:       
15e2			; 
15e2			;.diagmenu: 
15e2			;	call clear_display 
15e2			;	ld a, display_row_1 
15e2			;	ld de, hd_menu1 
15e2			;	call str_at_display 
15e2			; 
15e2			;	ld a, display_row_2 
15e2			;	ld de, hd_menu2 
15e2			;	call str_at_display 
15e2			; 
15e2			;	ld a, display_row_3 
15e2			;	ld de, hd_menu3 
15e2			;	call str_at_display 
15e2			; 
15e2			;	ld a,  display_row_4 
15e2			;	ld de, hd_menu4 
15e2			;	call str_at_display 
15e2			; 
15e2			;	; display debug state 
15e2			; 
15e2			;	ld de, hd_don 
15e2			;	ld a, (os_view_disable) 
15e2			;	cp 0 
15e2			;	jr z, .distog 
15e2			;	ld de, hd_doff 
15e2			;.distog: ld a, display_row_4+17 
15e2			;	call str_at_display 
15e2			; 
15e2			;	call update_display 
15e2			; 
15e2			;	call cin_wait 
15e2			; 
15e2			; 
15e2			; 
15e2			;	cp '4' 
15e2			;	jr nz, .diagn1 
15e2			; 
15e2			;	; debug toggle 
15e2			; 
15e2			;	ld a, (os_view_disable) 
15e2			;	ld b, '*' 
15e2			;	cp 0 
15e2			;	jr z, .debtog 
15e2			;	ld b, 0 
15e2			;.debtog:	 
15e2			;	ld a,b 
15e2			;	ld (os_view_disable),a 
15e2			; 
15e2			;.diagn1: cp '0' 
15e2			;	 ret z 
15e2			; 
15e2			;;	cp '1' 
15e2			;;       jp z, matrix	 
15e2			;;   TODO keyboard matrix test 
15e2			; 
15e2			;	cp '2' 
15e2			;	jp z, .diagedit 
15e2			; 
15e2			;;	cp '6' 
15e2			;;	jp z, .menutest 
15e2			;;if ENABLE_BASIC 
15e2			;;	cp '6' 
15e2			;;	jp z, basic 
15e2			;;endif 
15e2			 ; 
15e2			;	jp .diagmenu 
15e2			; 
15e2			; 
15e2			;	ret 
15e2			 
15e2			 
15e2			.debug_tog: 
15e2 21 29 16			ld hl, .menudebug 
15e5				 
15e5 3a 94 ef			ld a, (os_view_disable) 
15e8 fe 2a			cp '*' 
15ea 20 04			jr nz,.tdon  
15ec 3e 01			ld a, 1 
15ee 18 02			jr .tog1 
15f0 3e 00		.tdon: ld a, 0 
15f2			 
15f2			.tog1: 
15f2 cd 03 0b			call menu 
15f5 fe 00			cp 0 
15f7 c8				ret z 
15f8 fe 01			cp 1    ; disable debug 
15fa 28 04			jr z, .dtog0 
15fc 3e 2a			ld a, '*' 
15fe 18 02			jr .dtogset 
1600 3e 00		.dtog0: ld a, 0 
1602 32 94 ef		.dtogset:  ld (os_view_disable), a 
1605 c3 e2 15			jp .debug_tog 
1608			 
1608			 
1608			hardware_diags:       
1608			 
1608			.diagm: 
1608 21 1b 16			ld hl, .menuitems 
160b 3e 00			ld a, 0 
160d cd 03 0b			call menu 
1610			 
1610 fe 00		         cp 0 
1612 c8				 ret z 
1613			 
1613 fe 02			cp 2 
1615 ca 74 16			jp z, .diagedit 
1618			 
1618			;	cp '6' 
1618			;	jp z, .menutest 
1618			;if ENABLE_BASIC 
1618			;	cp '6' 
1618			;	jp z, basic 
1618			;endif 
1618			  
1618 c3 08 16			jp .diagm 
161b			 
161b				 
161b 2f 16		.menuitems:   	dw .m1 
161d 3a 16				dw .m2 
161f 41 16				dw .m3 
1621 49 16				dw .m5 
1623 4f 16				dw .m5a 
1625 58 16				dw .m5b 
1627 00 00				dw 0 
1629			 
1629			.menudebug: 
1629 61 16				dw .m6 
162b 6a 16				dw .m7 
162d 00 00				dw 0 
162f			 
162f .. 00		.m1:   db "Key Matrix",0 
163a .. 00		.m2:   db "Editor",0 
1641 .. 00		.m3:   db "Storage",0 
1649 .. 00		.m5:   db "Sound",0 
164f .. 00		.m5a:  db "RAM Test",0 
1658 .. 00		.m5b:  db "LCD Test",0 
1661			 
1661 .. 00		.m6:   db "Debug ON",0 
166a .. 00		.m7:   db "Debug OFF",0 
1674			 
1674			; debug editor 
1674			 
1674			.diagedit: 
1674			 
1674 21 a3 ef			ld hl, scratch 
1677			;	ld bc, 250 
1677			;	ldir 
1677				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1677 3e 00			ld a, 0 
1679 77				ld (hl), a 
167a 23				inc hl 
167b 77				ld (hl), a 
167c 23				inc hl 
167d 77				ld (hl), a 
167e			 
167e cd d2 0a		        call clear_display 
1681 cd f5 0a			call update_display 
1684 3e 01			ld a, 1 
1686 32 c3 fb			ld (hardware_diag), a 
1689			.diloop: 
1689 3e 00			ld a, display_row_1 
168b 0e 00			ld c, 0 
168d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
168f 1e 28			ld e, 40 
1691			 
1691 21 a3 ef			ld hl, scratch	 
1694 cd 33 0d			call input_str 
1697			 
1697 3e 14			ld a, display_row_2 
1699 11 a3 ef			ld de, scratch 
169c cd e5 0a			call str_at_display 
169f cd f5 0a			call update_display 
16a2			 
16a2 c3 89 16			jp .diloop 
16a5			 
16a5			 
16a5			; pass word in hl 
16a5			; a has display location 
16a5			display_word_at: 
16a5 f5				push af 
16a6 e5				push hl 
16a7 7c				ld a,h 
16a8 21 a8 f2			ld hl, os_word_scratch 
16ab cd 07 10			call hexout 
16ae e1				pop hl 
16af 7d				ld a,l 
16b0 21 aa f2			ld hl, os_word_scratch+2 
16b3 cd 07 10			call hexout 
16b6 21 ac f2			ld hl, os_word_scratch+4 
16b9 3e 00			ld a,0 
16bb 77				ld (hl),a 
16bc 11 a8 f2			ld de,os_word_scratch 
16bf f1				pop af 
16c0 cd e5 0a				call str_at_display 
16c3 c9				ret 
16c4			 
16c4			display_ptr_state: 
16c4			 
16c4				; to restore afterwards 
16c4			 
16c4 d5				push de 
16c5 c5				push bc 
16c6 e5				push hl 
16c7 f5				push af 
16c8			 
16c8				; for use in here 
16c8			 
16c8			;	push bc 
16c8			;	push de 
16c8			;	push hl 
16c8			;	push af 
16c8			 
16c8 cd d2 0a			call clear_display 
16cb			 
16cb 11 9e 18			ld de, .ptrstate 
16ce 3e 00			ld a, display_row_1 
16d0 cd e5 0a			call str_at_display 
16d3			 
16d3				; display debug step 
16d3			 
16d3			 
16d3 11 bd fb			ld de, debug_mark 
16d6 3e 12			ld a, display_row_1+display_cols-2 
16d8 cd e5 0a			call str_at_display 
16db			 
16db				; display a 
16db 11 a8 18			ld de, .ptrcliptr 
16de 3e 14			ld a, display_row_2 
16e0 cd e5 0a			call str_at_display 
16e3			 
16e3 f1				pop af 
16e4 2a ae f9			ld hl,(cli_ptr) 
16e7 3e 1c			ld a, display_row_2+8 
16e9 cd a5 16			call display_word_at 
16ec			 
16ec			 
16ec				; display hl 
16ec			 
16ec			 
16ec 11 b0 18			ld de, .ptrclioptr 
16ef 3e 1e			ld a, display_row_2+10 
16f1 cd e5 0a			call str_at_display 
16f4			; 
16f4			;	pop hl 
16f4 3e 21			ld a, display_row_2+13 
16f6 2a ac f9			ld hl,(cli_origptr) 
16f9 cd a5 16			call display_word_at 
16fc			; 
16fc			;	 
16fc			;	; display de 
16fc			 
16fc			;	ld de, .regstatede 
16fc			;	ld a, display_row_3 
16fc			;	call str_at_display 
16fc			 
16fc			;	pop de 
16fc			;	ld h,d 
16fc			;	ld l, e 
16fc			;	ld a, display_row_3+3 
16fc			;	call display_word_at 
16fc			 
16fc			 
16fc				; display bc 
16fc			 
16fc			;	ld de, .regstatebc 
16fc			;	ld a, display_row_3+10 
16fc			;	call str_at_display 
16fc			 
16fc			;	pop bc 
16fc			;	ld h,b 
16fc			;	ld l, c 
16fc			;	ld a, display_row_3+13 
16fc			;	call display_word_at 
16fc			 
16fc			 
16fc				; display dsp 
16fc			 
16fc			;	ld de, .regstatedsp 
16fc			;	ld a, display_row_4 
16fc			;	call str_at_display 
16fc			 
16fc				 
16fc			;	ld hl,(cli_data_sp) 
16fc			;	ld a, display_row_4+4 
16fc			;	call display_word_at 
16fc			 
16fc				; display rsp 
16fc			 
16fc 11 df 18			ld de, .regstatersp 
16ff 3e 46			ld a, display_row_4+10 
1701 cd e5 0a			call str_at_display 
1704			 
1704				 
1704 2a 94 f9			ld hl,(cli_ret_sp) 
1707 3e 4a			ld a, display_row_4+14 
1709 cd a5 16			call display_word_at 
170c			 
170c cd f5 0a			call update_display 
170f			 
170f cd 52 0a			call delay1s 
1712 cd 52 0a			call delay1s 
1715 cd 52 0a			call delay1s 
1718			 
1718			 
1718 cd 28 1c			call next_page_prompt 
171b			 
171b				; restore  
171b			 
171b f1				pop af 
171c e1				pop hl 
171d c1				pop bc 
171e d1				pop de 
171f c9				ret 
1720			 
1720			break_point_state: 
1720 f5				push af 
1721			 
1721				; see if disabled 
1721			 
1721 3a 94 ef			ld a, (os_view_disable) 
1724 fe 2a			cp '*' 
1726 20 02			jr nz, .bpsgo 
1728 f1				pop af 
1729 c9				ret 
172a			 
172a			.bpsgo: 
172a f1				pop af 
172b f5				push af 
172c 22 90 ef			ld (os_view_hl), hl 
172f ed 53 8e ef		ld (os_view_de), de 
1733 ed 43 8c ef		ld (os_view_bc), bc 
1737 e5				push hl 
1738 6f				ld l, a 
1739 26 00			ld h, 0 
173b 22 92 ef			ld (os_view_af),hl 
173e			 
173e 21 53 fb				ld hl, display_fb0 
1741 22 5e fa				ld (display_fb_active), hl 
1744 e1				pop hl	 
1745			 
1745 3e 31			ld a, '1' 
1747 fe 2a		.bps1:  cp '*' 
1749 20 03			jr nz, .bps1b 
174b 32 94 ef			ld (os_view_disable),a 
174e fe 31		.bps1b:  cp '1' 
1750 20 14			jr nz, .bps2 
1752			 
1752				; display reg 
1752			 
1752				 
1752			 
1752 3a 92 ef			ld a, (os_view_af) 
1755 2a 90 ef			ld hl, (os_view_hl) 
1758 ed 5b 8e ef		ld de, (os_view_de) 
175c ed 4b 8c ef		ld bc, (os_view_bc) 
1760 cd fa 17			call display_reg_state 
1763 c3 e6 17			jp .bpschk 
1766			 
1766 fe 32		.bps2:  cp '2' 
1768 20 08			jr nz, .bps3 
176a				 
176a				; display hl 
176a 2a 90 ef			ld hl, (os_view_hl) 
176d cd e4 18			call display_dump_at_hl 
1770			 
1770 18 74			jr .bpschk 
1772			 
1772 fe 33		.bps3:  cp '3' 
1774 20 08			jr nz, .bps4 
1776			 
1776			        ; display de 
1776 2a 8e ef			ld hl, (os_view_de) 
1779 cd e4 18			call display_dump_at_hl 
177c			 
177c 18 68			jr .bpschk 
177e fe 34		.bps4:  cp '4' 
1780 20 08			jr nz, .bps5 
1782			 
1782			        ; display bc 
1782 2a 8c ef			ld hl, (os_view_bc) 
1785 cd e4 18			call display_dump_at_hl 
1788			 
1788 18 5c			jr .bpschk 
178a fe 35		.bps5:  cp '5' 
178c 20 08		        jr nz, .bps7 
178e			 
178e				; display cur ptr 
178e 2a ae f9			ld hl, (cli_ptr) 
1791 cd e4 18			call display_dump_at_hl 
1794			 
1794 18 50			jr .bpschk 
1796 fe 36		.bps7:  cp '6' 
1798 20 08			jr nz, .bps8b 
179a				 
179a				; display cur orig ptr 
179a 2a ac f9			ld hl, (cli_origptr) 
179d cd e4 18			call display_dump_at_hl 
17a0 18 44			jr .bpschk 
17a2 fe 37		.bps8b:  cp '7' 
17a4 20 08			jr nz, .bps9 
17a6				 
17a6				; display dsp 
17a6 2a 90 f9			ld hl, (cli_data_sp) 
17a9 cd e4 18			call display_dump_at_hl 
17ac			 
17ac 18 38			jr .bpschk 
17ae fe 39		.bps9:  cp '9' 
17b0 20 05			jr nz, .bps8c 
17b2				 
17b2				; display SP 
17b2			;	ld hl, sp 
17b2 cd e4 18			call display_dump_at_hl 
17b5			 
17b5 18 2f			jr .bpschk 
17b7 fe 38		.bps8c:  cp '8' 
17b9 20 08			jr nz, .bps8d 
17bb				 
17bb				; display rsp 
17bb 2a 94 f9			ld hl, (cli_ret_sp) 
17be cd e4 18			call display_dump_at_hl 
17c1			 
17c1 18 23			jr .bpschk 
17c3 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17c5 20 05			jr nz, .bps8 
17c7 cd 1e 1a			call monitor 
17ca			 
17ca 18 1a			jr .bpschk 
17cc fe 30		.bps8:  cp '0' 
17ce 20 16			jr nz, .bpschk 
17d0			 
17d0 21 02 fb				ld hl, display_fb1 
17d3 22 5e fa				ld (display_fb_active), hl 
17d6 cd f5 0a				call update_display 
17d9			 
17d9				;ld a, (os_view_af) 
17d9 2a 90 ef			ld hl, (os_view_hl) 
17dc ed 5b 8e ef		ld de, (os_view_de) 
17e0 ed 4b 8c ef		ld bc, (os_view_bc) 
17e4 f1				pop af 
17e5 c9				ret 
17e6			 
17e6			.bpschk:   
17e6 cd 52 0a			call delay1s 
17e9 3e 4f		ld a,display_row_4 + display_cols - 1 
17eb 11 26 1c		        ld de, endprg 
17ee cd e5 0a			call str_at_display 
17f1 cd f5 0a			call update_display 
17f4 cd bd 66			call cin_wait 
17f7			 
17f7 c3 47 17			jp .bps1 
17fa			 
17fa			 
17fa			display_reg_state: 
17fa			 
17fa				; to restore afterwards 
17fa			 
17fa d5				push de 
17fb c5				push bc 
17fc e5				push hl 
17fd f5				push af 
17fe			 
17fe				; for use in here 
17fe			 
17fe c5				push bc 
17ff d5				push de 
1800 e5				push hl 
1801 f5				push af 
1802			 
1802 cd d2 0a			call clear_display 
1805			 
1805 11 ba 18			ld de, .regstate 
1808 3e 00			ld a, display_row_1 
180a cd e5 0a			call str_at_display 
180d			 
180d				; display debug step 
180d			 
180d			 
180d 11 bd fb			ld de, debug_mark 
1810 3e 11			ld a, display_row_1+display_cols-3 
1812 cd e5 0a			call str_at_display 
1815			 
1815				; display a 
1815 11 d6 18			ld de, .regstatea 
1818 3e 14			ld a, display_row_2 
181a cd e5 0a			call str_at_display 
181d			 
181d e1				pop hl 
181e			;	ld h,0 
181e			;	ld l, a 
181e 3e 17			ld a, display_row_2+3 
1820 cd a5 16			call display_word_at 
1823			 
1823			 
1823				; display hl 
1823			 
1823			 
1823 11 ca 18			ld de, .regstatehl 
1826 3e 1e			ld a, display_row_2+10 
1828 cd e5 0a			call str_at_display 
182b			 
182b e1				pop hl 
182c 3e 21			ld a, display_row_2+13 
182e cd a5 16			call display_word_at 
1831			 
1831				 
1831				; display de 
1831			 
1831 11 ce 18			ld de, .regstatede 
1834 3e 28			ld a, display_row_3 
1836 cd e5 0a			call str_at_display 
1839			 
1839 e1				pop hl 
183a			;	ld h,d 
183a			;	ld l, e 
183a 3e 2b			ld a, display_row_3+3 
183c cd a5 16			call display_word_at 
183f			 
183f			 
183f				; display bc 
183f			 
183f 11 d2 18			ld de, .regstatebc 
1842 3e 32			ld a, display_row_3+10 
1844 cd e5 0a			call str_at_display 
1847			 
1847 e1				pop hl 
1848			;	ld h,b 
1848			;	ld l, c 
1848 3e 35			ld a, display_row_3+13 
184a cd a5 16			call display_word_at 
184d			 
184d			 
184d				; display dsp 
184d			 
184d 11 da 18			ld de, .regstatedsp 
1850 3e 3c			ld a, display_row_4 
1852 cd e5 0a			call str_at_display 
1855			 
1855				 
1855 2a 90 f9			ld hl,(cli_data_sp) 
1858 3e 40			ld a, display_row_4+4 
185a cd a5 16			call display_word_at 
185d			 
185d				; display rsp 
185d			 
185d 11 df 18			ld de, .regstatersp 
1860 3e 46			ld a, display_row_4+10 
1862 cd e5 0a			call str_at_display 
1865			 
1865				 
1865 2a 94 f9			ld hl,(cli_ret_sp) 
1868 3e 4a			ld a, display_row_4+14 
186a cd a5 16			call display_word_at 
186d			 
186d cd f5 0a			call update_display 
1870			 
1870			;	call delay1s 
1870			;	call delay1s 
1870			;	call delay1s 
1870			 
1870			 
1870			;	call next_page_prompt 
1870			 
1870				; restore  
1870			 
1870 f1				pop af 
1871 e1				pop hl 
1872 c1				pop bc 
1873 d1				pop de 
1874 c9				ret 
1875			 
1875 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1889 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
189e .. 00		.ptrstate:	db "Ptr State",0 
18a8 .. 00		.ptrcliptr:     db "cli_ptr",0 
18b0 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18ba .. 00		.regstate:	db "Reg State (1/0)",0 
18ca .. 00		.regstatehl:	db "HL:",0 
18ce .. 00		.regstatede:	db "DE:",0 
18d2 .. 00		.regstatebc:	db "BC:",0 
18d6 .. 00		.regstatea:	db "A :",0 
18da .. 00		.regstatedsp:	db "DSP:",0 
18df .. 00		.regstatersp:	db "RSP:",0 
18e4			 
18e4			display_dump_at_hl: 
18e4 e5				push hl 
18e5 d5				push de 
18e6 c5				push bc 
18e7 f5				push af 
18e8			 
18e8 22 c6 f2			ld (os_cur_ptr),hl	 
18eb cd d2 0a			call clear_display 
18ee cd 30 1b			call dumpcont 
18f1			;	call delay1s 
18f1			;	call next_page_prompt 
18f1			 
18f1			 
18f1 f1				pop af 
18f2 c1				pop bc 
18f3 d1				pop de 
18f4 e1				pop hl 
18f5 c9				ret 
18f6			 
18f6			;if ENABLE_BASIC 
18f6			;	include "nascombasic.asm" 
18f6			;	basic: 
18f6			;	include "forth/FORTH.ASM" 
18f6			;endif 
18f6			 
18f6			; eof 
18f6			 
18f6			 
# End of file firmware_diags.asm
18f6			  
18f6			  
18f6			  
18f6			  
18f6			; eof  
18f6			  
# End of file firmware.asm
18f6			 
18f6			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
18f6			;if BASE_KEV  
18f6			;baseram: equ 08000h 
18f6			;endif 
18f6			 
18f6			;if BASE_SC114 
18f6			;baseram:     equ    endofcode 
18f6			;endif 
18f6			 
18f6			 
18f6			; start system 
18f6			 
18f6			coldstart: 
18f6				; set sp 
18f6				; di/ei 
18f6			 
18f6 f3				di 
18f7 31 fd ff			ld sp, tos 
18fa			;	ei 
18fa			 
18fa			 
18fa				; disable breakpoint by default 
18fa			 
18fa 3e 2a			ld a,'*' 
18fc 32 94 ef			ld (os_view_disable),a 
18ff			 
18ff				; init hardware 
18ff			 
18ff				; init keyboard and screen hardware 
18ff			 
18ff cd 03 00			call hardware_init 
1902			 
1902			 
1902				; detect if any keys are held down to enable breakpoints at start up 
1902			 
1902 cd ce 66			call cin  
1905 fe 00			cp 0 
1907 28 03			jr z, .nokeys 
1909			 
1909				;call hardware_diags 
1909 cd 66 13			call config 
190c			 
190c			;	ld de, .bpen 
190c			;	ld a, display_row_4 
190c			;	call str_at_display 
190c			;	call update_display 
190c			; 
190c			;	ld a,0 
190c			;	ld (os_view_disable),a 
190c			; 
190c			;.bpwait: 
190c			;	call cin 
190c			;	cp 0 
190c			;	jr z, .bpwait 
190c			;	jr .nokeys 
190c			; 
190c			; 
190c			;.bpen:  db "Break points enabled!",0 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			.nokeys: 
190c			 
190c			 
190c				 
190c			 
190c			;jp  testkey 
190c			 
190c			;call storage_get_block_0 
190c			; 
190c			;ld hl, 0 
190c			;ld de, store_page 
190c			;call storage_read_block 
190c			 
190c				 
190c			;ld hl, 10 
190c			;ld de, store_page 
190c			;call storage_read_block 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			;stop:	nop 
190c			;	jp stop 
190c			 
190c			 
190c			 
190c			main: 
190c cd d2 0a			call clear_display 
190f cd f5 0a			call update_display 
1912			 
1912			 
1912			 
1912			;	call testlcd 
1912			 
1912			 
1912			 
1912 cd ee 1f			call forth_init 
1915			 
1915			 
1915			warmstart: 
1915 cd c4 1f			call forth_warmstart 
1918			 
1918				; run startup word load 
1918			        ; TODO prevent this running at warmstart after crash  
1918			 
1918				if STARTUP_ENABLE 
1918					if STORAGE_SE 
1918 cd ff 63					call forth_autoload 
191b					endif 
191b cd 0e 61				call forth_startup 
191e			 
191e			 
191e				endif 
191e			 
191e				; show free memory after boot 
191e 11 b8 19			ld de, freeram 
1921 3e 00			ld a, display_row_1 
1923 cd e5 0a			call str_at_display 
1926			 
1926			; Or use heap_size word???? 
1926 21 89 ef			ld hl, heap_end 
1929 11 0e 80			ld de, heap_start 
192c ed 52			sbc hl, de 
192e e5				push hl 
192f 7c				ld a,h	         	 
1930 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1933 cd 07 10			call hexout 
1936 e1			   	pop hl 
1937			 
1937 7d				ld a,l 
1938 21 aa f2			ld hl, os_word_scratch+2 
193b cd 07 10			call hexout 
193e 21 ac f2			ld hl, os_word_scratch+4 
1941 3e 00			ld a, 0 
1943 77				ld (hl),a 
1944 11 a8 f2			ld de, os_word_scratch 
1947 3e 0d			ld a, display_row_1 + 13 
1949 cd e5 0a			call str_at_display 
194c cd f5 0a			call update_display 
194f			 
194f			 
194f				;call demo 
194f			 
194f			 
194f				; init scratch input area for cli commands 
194f			 
194f 21 ca f2			ld hl, os_cli_cmd 
1952 3e 00			ld a,0 
1954 77				ld (hl),a 
1955 23				inc hl 
1956 77				ld (hl),a 
1957			 
1957 3e 00			ld a,0 
1959 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
195c			 
195c 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
195f 32 c7 f2			ld (os_cur_ptr+1),a	 
1962			 
1962 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1965 32 a9 f2			ld (os_word_scratch+1),a	 
1968				 
1968			 
1968				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1968 21 ca f2			ld hl, os_cli_cmd 
196b			 
196b 3e 00			ld a, 0		 ; init cli input 
196d 77				ld (hl), a 
196e 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1970			cli: 
1970				; show cli prompt 
1970				;push af 
1970				;ld a, 0 
1970				;ld de, prompt 
1970				;call str_at_display 
1970			 
1970				;call update_display 
1970				;pop af 
1970				;inc a 
1970				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1970 0e 00			ld c, 0 
1972 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1974 1e 28			ld e, 40 
1976			 
1976 21 ca f2			ld hl, os_cli_cmd 
1979			 
1979				STACKFRAME OFF $fefe $9f9f 
1979				if DEBUG_STACK_IMB 
1979					if OFF 
1979						exx 
1979						ld de, $fefe 
1979						ld a, d 
1979						ld hl, curframe 
1979						call hexout 
1979						ld a, e 
1979						ld hl, curframe+2 
1979						call hexout 
1979						ld hl, $fefe 
1979						push hl 
1979						ld hl, $9f9f 
1979						push hl 
1979						exx 
1979					endif 
1979				endif 
1979			endm 
# End of macro STACKFRAME
1979			 
1979 cd 33 0d			call input_str 
197c			 
197c				STACKFRAMECHK OFF $fefe $9f9f 
197c				if DEBUG_STACK_IMB 
197c					if OFF 
197c						exx 
197c						ld hl, $9f9f 
197c						pop de   ; $9f9f 
197c						call cmp16 
197c						jr nz, .spnosame 
197c						ld hl, $fefe 
197c						pop de   ; $fefe 
197c						call cmp16 
197c						jr z, .spfrsame 
197c						.spnosame: call showsperror 
197c						.spfrsame: nop 
197c						exx 
197c					endif 
197c				endif 
197c			endm 
# End of macro STACKFRAMECHK
197c			 
197c				; copy input to last command 
197c			 
197c 21 ca f2			ld hl, os_cli_cmd 
197f 11 c9 f3			ld de, os_last_cmd 
1982 01 ff 00			ld bc, 255 
1985 ed b0			ldir 
1987			 
1987				; wipe current buffer 
1987			 
1987			;	ld a, 0 
1987			;	ld hl, os_cli_cmd 
1987			;	ld de, os_cli_cmd+1 
1987			;	ld bc, 254 
1987			;	ldir 
1987				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1987			;	call strcpy 
1987			;	ld a, 0 
1987			;	ld (hl), a 
1987			;	inc hl 
1987			;	ld (hl), a 
1987			;	inc hl 
1987			;	ld (hl), a 
1987			 
1987				; switch frame buffer to program  
1987			 
1987 21 02 fb				ld hl, display_fb1 
198a 22 5e fa				ld (display_fb_active), hl 
198d			 
198d			;	nop 
198d				STACKFRAME ON $fbfe $8f9f 
198d				if DEBUG_STACK_IMB 
198d					if ON 
198d						exx 
198d						ld de, $fbfe 
198d						ld a, d 
198d						ld hl, curframe 
198d						call hexout 
198d						ld a, e 
198d						ld hl, curframe+2 
198d						call hexout 
198d						ld hl, $fbfe 
198d						push hl 
198d						ld hl, $8f9f 
198d						push hl 
198d						exx 
198d					endif 
198d				endif 
198d			endm 
# End of macro STACKFRAME
198d				; first time into the parser so pass over the current scratch pad 
198d 21 ca f2			ld hl,os_cli_cmd 
1990				; tokenise the entered statement(s) in HL 
1990 cd 67 20			call forthparse 
1993			        ; exec forth statements in top of return stack 
1993 cd a7 20			call forthexec 
1996				;call forthexec_cleanup 
1996			;	call parsenext 
1996			 
1996				STACKFRAMECHK ON $fbfe $8f9f 
1996				if DEBUG_STACK_IMB 
1996					if ON 
1996						exx 
1996						ld hl, $8f9f 
1996						pop de   ; $8f9f 
1996						call cmp16 
1996						jr nz, .spnosame 
1996						ld hl, $fbfe 
1996						pop de   ; $fbfe 
1996						call cmp16 
1996						jr z, .spfrsame 
1996						.spnosame: call showsperror 
1996						.spfrsame: nop 
1996						exx 
1996					endif 
1996				endif 
1996			endm 
# End of macro STACKFRAMECHK
1996				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1996			 
1996 3e 3c			ld a, display_row_4 
1998 11 ca 19			ld de, endprog 
199b			 
199b cd f5 0a			call update_display		 
199e			 
199e cd 28 1c			call next_page_prompt 
19a1			 
19a1				; switch frame buffer to cli 
19a1			 
19a1 21 53 fb				ld hl, display_fb0 
19a4 22 5e fa				ld (display_fb_active), hl 
19a7			 
19a7			 
19a7 cd d2 0a		        call clear_display 
19aa cd f5 0a			call update_display		 
19ad			 
19ad 21 ca f2			ld hl, os_cli_cmd 
19b0			 
19b0 3e 00			ld a, 0		 ; init cli input 
19b2 77				ld (hl), a 
19b3			 
19b3				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19b3			 
19b3				; now on last line 
19b3			 
19b3				; TODO scroll screen up 
19b3			 
19b3				; TODO instead just clear screen and place at top of screen 
19b3			 
19b3			;	ld a, 0 
19b3			;	ld (f_cursor_ptr),a 
19b3			 
19b3				;call clear_display 
19b3				;call update_display 
19b3			 
19b3				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19b3 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19b5 c3 70 19			jp cli 
19b8			 
19b8 .. 00		freeram: db "Free bytes: $",0 
19c6 ..			asc: db "1A2F" 
19ca .. 00		endprog: db "End prog...",0 
19d6			 
19d6			testenter2:   
19d6 21 d5 ef			ld hl,scratch+50 
19d9 22 c6 f2			ld (os_cur_ptr),hl 
19dc c3 70 19			jp cli 
19df			 
19df			testenter:  
19df			 
19df 21 c6 19			ld hl,asc 
19e2			;	ld a,(hl) 
19e2			;	call nibble2val 
19e2 cd 5d 10			call get_byte 
19e5			 
19e5			 
19e5			;	ld a,(hl) 
19e5			;	call atohex 
19e5			 
19e5			;	call fourehexhl 
19e5 32 d5 ef			ld (scratch+50),a 
19e8			 
19e8			 
19e8			 
19e8 21 c8 19			ld hl,asc+2 
19eb			;	ld a, (hl) 
19eb			;	call nibble2val 
19eb cd 5d 10			call get_byte 
19ee			 
19ee			;	call fourehexhl 
19ee 32 d7 ef			ld (scratch+52),a 
19f1				 
19f1 21 d5 ef			ld hl,scratch+50 
19f4 22 c6 f2			ld (os_cur_ptr),hl 
19f7 c3 70 19			jp cli 
19fa			 
19fa			enter:	 
19fa 3a a7 ef			ld a,(scratch+4) 
19fd fe 00			cp 0 
19ff 28 0c			jr z, .entercont 
1a01				; no, not a null term line so has an address to work out.... 
1a01			 
1a01 21 a5 ef			ld hl,scratch+2 
1a04 cd bd 10			call get_word_hl 
1a07			 
1a07 22 c6 f2			ld (os_cur_ptr),hl	 
1a0a c3 70 19			jp cli 
1a0d			 
1a0d			 
1a0d			.entercont:  
1a0d			 
1a0d 21 a5 ef			ld hl, scratch+2 
1a10 cd 5d 10			call get_byte 
1a13			 
1a13 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a16 77					ld (hl),a 
1a17 23					inc hl 
1a18 22 c6 f2				ld (os_cur_ptr),hl 
1a1b				 
1a1b			; get byte  
1a1b			 
1a1b			 
1a1b c3 70 19			jp cli 
1a1e			 
1a1e			 
1a1e			; basic monitor support 
1a1e			 
1a1e			monitor: 
1a1e				;  
1a1e cd d2 0a			call clear_display 
1a21 3e 00			ld a, 0 
1a23 11 6b 1a			ld de, .monprompt 
1a26 cd e5 0a			call str_at_display 
1a29 cd f5 0a			call update_display 
1a2c			 
1a2c				; get a monitor command 
1a2c			 
1a2c 0e 00			ld c, 0     ; entry at top left 
1a2e 16 64			ld d, 100   ; max buffer size 
1a30 1e 0f			ld e, 15    ; input scroll area 
1a32 3e 00			ld a, 0     ; init string 
1a34 21 a1 f1			ld hl, os_input 
1a37 77				ld (hl), a 
1a38 23				inc hl 
1a39 77				ld (hl), a 
1a3a 21 a1 f1			ld hl, os_input 
1a3d 3e 01			ld a, 1     ; init string 
1a3f cd 33 0d			call input_str 
1a42			 
1a42 cd d2 0a		        call clear_display 
1a45 cd f5 0a			call update_display		 
1a48			 
1a48 3a a1 f1			ld a, (os_input) 
1a4b cd 5b 11			call toUpper 
1a4e fe 48		        cp 'H' 
1a50 28 6f		        jr z, .monhelp 
1a52 fe 44			cp 'D'		; dump 
1a54 ca e2 1a			jp z, .mondump	 
1a57 fe 43			cp 'C'		; dump 
1a59 ca fc 1a			jp z, .moncdump	 
1a5c fe 4d			cp 'M'		; dump 
1a5e ca 6d 1a			jp z, .moneditstart 
1a61 fe 55			cp 'U'		; dump 
1a63 28 14			jr z, .monedit	 
1a65 fe 51			cp 'Q'		; dump 
1a67 c8				ret z	 
1a68			 
1a68			 
1a68				; TODO "S" to access symbol by name and not need the address 
1a68				; TODO "F" to find a string in memory 
1a68			 
1a68 c3 1e 1a			jp monitor 
1a6b			 
1a6b .. 00		.monprompt: db ">", 0 
1a6d			 
1a6d			.moneditstart: 
1a6d				; get starting address 
1a6d			 
1a6d 21 a3 f1			ld hl,os_input+2 
1a70 cd bd 10			call get_word_hl 
1a73			 
1a73 22 c6 f2			ld (os_cur_ptr),hl	 
1a76			 
1a76 c3 1e 1a			jp monitor 
1a79			 
1a79			.monedit: 
1a79				; get byte to load 
1a79			 
1a79 21 a3 f1			ld hl,os_input+2 
1a7c cd 5d 10			call get_byte 
1a7f			 
1a7f				; get address to update 
1a7f 2a c6 f2			ld hl, (os_cur_ptr) 
1a82			 
1a82				; update byte 
1a82			 
1a82 77				ld (hl), a 
1a83			 
1a83				; move to next address and save it 
1a83			 
1a83 23				inc hl 
1a84 22 c6 f2			ld (os_cur_ptr),hl	 
1a87			 
1a87 c3 1e 1a			jp monitor 
1a8a			 
1a8a			 
1a8a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a9e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1aba .. 00		.monhelptext3:  db "Q-Quit",0 
1ac1			        
1ac1			.monhelp: 
1ac1 3e 00			ld a, display_row_1 
1ac3 11 8a 1a		        ld de, .monhelptext1 
1ac6			 
1ac6 cd e5 0a			call str_at_display 
1ac9 3e 14			ld a, display_row_2 
1acb 11 9e 1a		        ld de, .monhelptext2 
1ace					 
1ace cd e5 0a			call str_at_display 
1ad1 3e 28			ld a, display_row_3 
1ad3 11 ba 1a		        ld de, .monhelptext3 
1ad6					 
1ad6 cd e5 0a			call str_at_display 
1ad9 cd f5 0a			call update_display		 
1adc			 
1adc cd 28 1c			call next_page_prompt 
1adf c3 1e 1a			jp monitor 
1ae2			 
1ae2			.mondump:    
1ae2 21 a3 f1			ld hl,os_input+2 
1ae5 cd bd 10			call get_word_hl 
1ae8			 
1ae8 22 c6 f2			ld (os_cur_ptr),hl	 
1aeb cd 30 1b			call dumpcont 
1aee 3e 3c			ld a, display_row_4 
1af0 11 ca 19			ld de, endprog 
1af3			 
1af3 cd f5 0a			call update_display		 
1af6			 
1af6 cd 28 1c			call next_page_prompt 
1af9 c3 1e 1a			jp monitor 
1afc			.moncdump: 
1afc cd 30 1b			call dumpcont 
1aff 3e 3c			ld a, display_row_4 
1b01 11 ca 19			ld de, endprog 
1b04			 
1b04 cd f5 0a			call update_display		 
1b07			 
1b07 cd 28 1c			call next_page_prompt 
1b0a c3 1e 1a			jp monitor 
1b0d			 
1b0d			 
1b0d			; TODO symbol access  
1b0d			 
1b0d			.symbols:     ;; A list of symbols that can be called up  
1b0d 53 fb			dw display_fb0 
1b0f .. 00			db "fb0",0  
1b13 e8 f9		     	dw store_page 
1b15 .. 00			db "store_page",0 
1b20			 
1b20			 
1b20			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b20			 
1b20 3a a4 ef			ld a,(scratch+1) 
1b23 fe 00			cp 0 
1b25 28 09			jr z, dumpcont 
1b27			 
1b27				; no, not a null term line so has an address to work out.... 
1b27			 
1b27 21 a5 ef			ld hl,scratch+2 
1b2a cd bd 10			call get_word_hl 
1b2d			 
1b2d 22 c6 f2			ld (os_cur_ptr),hl	 
1b30			 
1b30			 
1b30			 
1b30			dumpcont: 
1b30			 
1b30				; dump bytes at ptr 
1b30			 
1b30			 
1b30 3e 00			ld a, display_row_1 
1b32 2a 5e fa			ld hl, (display_fb_active) 
1b35 cd 06 0d			call addatohl 
1b38 cd 60 1b			call .dumpbyterow 
1b3b			 
1b3b 3e 14			ld a, display_row_2 
1b3d 2a 5e fa			ld hl, (display_fb_active) 
1b40 cd 06 0d			call addatohl 
1b43 cd 60 1b			call .dumpbyterow 
1b46			 
1b46			 
1b46 3e 28			ld a, display_row_3 
1b48 2a 5e fa			ld hl, (display_fb_active) 
1b4b cd 06 0d			call addatohl 
1b4e cd 60 1b			call .dumpbyterow 
1b51			 
1b51 3e 3c			ld a, display_row_4 
1b53 2a 5e fa			ld hl, (display_fb_active) 
1b56 cd 06 0d			call addatohl 
1b59 cd 60 1b			call .dumpbyterow 
1b5c			 
1b5c cd f5 0a			call update_display 
1b5f			;		jp cli 
1b5f c9				ret 
1b60			 
1b60			.dumpbyterow: 
1b60			 
1b60				;push af 
1b60			 
1b60 e5				push hl 
1b61			 
1b61				; calc where to poke the ascii 
1b61			if display_cols == 20 
1b61 3e 10			ld a, 16 
1b63			else 
1b63				ld a, 31 
1b63			endif 
1b63			 
1b63 cd 06 0d			call addatohl 
1b66 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1b69			 
1b69			 
1b69			; display decoding address 
1b69 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b6c			 
1b6c 7c				ld a,h 
1b6d e1				pop hl 
1b6e e5				push hl 
1b6f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b6f cd 07 10			call hexout 
1b72 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b75			 
1b75 7d				ld a,l 
1b76 e1				pop hl 
1b77 23				inc hl 
1b78 23				inc hl 
1b79 e5				push hl 
1b7a			;	ld hl, os_word_scratch+2 
1b7a cd 07 10			call hexout 
1b7d e1				pop hl 
1b7e 23				inc hl 
1b7f 23				inc hl 
1b80				;ld hl, os_word_scratch+4 
1b80 3e 3a			ld a, ':' 
1b82 77				ld (hl),a 
1b83 23				inc hl 
1b84				;ld a, 0 
1b84				;ld (hl),a 
1b84				;ld de, os_word_scratch 
1b84				;pop af 
1b84				;push af 
1b84			;		ld a, display_row_2 
1b84			;		call str_at_display 
1b84			;		call update_display 
1b84			 
1b84			 
1b84			;pop af 
1b84			;	add 5 
1b84			 
1b84			if display_cols == 20 
1b84 06 04			ld b, 4 
1b86			else 
1b86				ld b, 8 
1b86			endif	 
1b86			 
1b86			.dumpbyte: 
1b86 c5				push bc 
1b87 e5				push hl 
1b88			 
1b88			 
1b88 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b8b 7e					ld a,(hl) 
1b8c			 
1b8c					; poke the ascii to display 
1b8c 2a a8 f2				ld hl,(os_word_scratch) 
1b8f 77					ld (hl),a 
1b90 23					inc hl 
1b91 22 a8 f2				ld (os_word_scratch),hl 
1b94			 
1b94					 
1b94			 
1b94			 
1b94 e1					pop hl 
1b95 e5					push hl 
1b96			 
1b96 cd 07 10				call hexout 
1b99			 
1b99					 
1b99 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b9c 23				inc hl 
1b9d 22 c6 f2		   	ld (os_cur_ptr),hl 
1ba0			 
1ba0 e1					pop hl 
1ba1 23					inc hl 
1ba2 23					inc hl 
1ba3 23					inc hl 
1ba4			 
1ba4			 
1ba4			 
1ba4					;ld a,0 
1ba4					;ld (os_word_scratch+2),a 
1ba4					;pop af 
1ba4					;push af 
1ba4			 
1ba4					;ld de, os_word_scratch 
1ba4					;call str_at_display 
1ba4			;		call update_display 
1ba4			;		pop af 
1ba4 c1					pop bc 
1ba5 c6 03				add 3 
1ba7 10 dd			djnz .dumpbyte 
1ba9			 
1ba9				 
1ba9			 
1ba9 c9				ret 
1baa			 
1baa			jump:	 
1baa			 
1baa 21 a5 ef			ld hl,scratch+2 
1bad cd bd 10			call get_word_hl 
1bb0				;ld hl,(scratch+2) 
1bb0				;call fourehexhl 
1bb0			 
1bb0 22 c6 f2			ld (os_cur_ptr),hl	 
1bb3			 
1bb3 e9				jp (hl) 
1bb4			 
1bb4			 
1bb4			 
1bb4			; TODO implement a basic monitor mode to start with 
1bb4			 
1bb4			 
1bb4			 
1bb4			 
1bb4			 
1bb4			 
1bb4			 
1bb4			 
1bb4			 
1bb4			; testing and demo code during development 
1bb4			 
1bb4			 
1bb4 .. 00		str1: db "Enter some text...",0 
1bc7 .. 00		clear: db "                    ",0 
1bdc			 
1bdc			demo: 
1bdc			 
1bdc			 
1bdc			 
1bdc			;	call update_display 
1bdc			 
1bdc				; init scratch input area for testing 
1bdc 21 a3 ef			ld hl, scratch	 
1bdf 3e 00			ld a,0 
1be1 77				ld (hl),a 
1be2			 
1be2			 
1be2 3e 14		            LD   A, display_row_2 
1be4			;            CALL fLCD_Pos       ;Position cursor to location in A 
1be4 11 b4 1b		            LD   DE, str1 
1be7 cd e5 0a			call str_at_display 
1bea			 
1bea			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bea			cloop:	 
1bea 3e 28		            LD   A, display_row_3 
1bec			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bec 11 c7 1b		            LD   DE, clear 
1bef			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1bef cd e5 0a				call str_at_display 
1bf2 3e 3c			ld a, display_row_4 
1bf4 11 24 1c			ld de, prompt 
1bf7			 
1bf7 cd e5 0a				call str_at_display 
1bfa cd f5 0a			call update_display 
1bfd			 
1bfd 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bff 16 0a			ld d, 10 
1c01 21 a3 ef			ld hl, scratch	 
1c04 cd 33 0d			call input_str 
1c07			 
1c07			;	call clear_display 
1c07			;'	call update_display 
1c07			 
1c07 3e 00		            LD   A, display_row_1 
1c09			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c09 11 c7 1b		            LD   DE, clear 
1c0c cd e5 0a				call str_at_display 
1c0f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c0f 3e 00		            LD   A, display_row_1 
1c11			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c11 11 a3 ef		            LD   DE, scratch 
1c14			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c14 cd e5 0a				call str_at_display 
1c17 cd f5 0a			call update_display 
1c1a			 
1c1a 3e 00				ld a,0 
1c1c 21 a3 ef			ld hl, scratch 
1c1f 77				ld (hl),a 
1c20			 
1c20 00				nop 
1c21 c3 ea 1b			jp cloop 
1c24			 
1c24			 
1c24			 
1c24			; OS Prompt 
1c24			 
1c24 .. 00		prompt: db ">",0 
1c26 .. 00		endprg: db "?",0 
1c28			 
1c28			 
1c28			; handy next page prompt 
1c28			next_page_prompt: 
1c28 e5				push hl 
1c29 d5				push de 
1c2a f5				push af 
1c2b c5				push bc 
1c2c			 
1c2c 3e 4f			ld a,display_row_4 + display_cols - 1 
1c2e 11 26 1c		        ld de, endprg 
1c31 cd e5 0a			call str_at_display 
1c34 cd f5 0a			call update_display 
1c37 cd bd 66			call cin_wait 
1c3a c1				pop bc 
1c3b f1				pop af 
1c3c d1				pop de 
1c3d e1				pop hl 
1c3e			 
1c3e			 
1c3e c9				ret 
1c3f			 
1c3f			 
1c3f			; forth parser 
1c3f			 
1c3f			; My forth kernel 
1c3f			include "forth_kernel.asm" 
1c3f			; 
1c3f			; kernel to the forth OS 
1c3f			 
1c3f			DS_TYPE_STR: equ 1     ; string type 
1c3f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c3f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c3f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c3f			 
1c3f			FORTH_PARSEV1: equ 0 
1c3f			FORTH_PARSEV2: equ 0 
1c3f			FORTH_PARSEV3: equ 0 
1c3f			FORTH_PARSEV4: equ 0 
1c3f			FORTH_PARSEV5: equ 1 
1c3f			 
1c3f			;if FORTH_PARSEV5 
1c3f			;	FORTH_END_BUFFER: equ 0 
1c3f			;else 
1c3f			FORTH_END_BUFFER: equ 127 
1c3f			;endif 
1c3f			 
1c3f			FORTH_TRUE: equ 1 
1c3f			FORTH_FALSE: equ 0 
1c3f			 
1c3f			if FORTH_PARSEV4 
1c3f			include "forth_stackops.asm" 
1c3f			endif 
1c3f			 
1c3f			if FORTH_PARSEV5 
1c3f			include "forth_stackopsv5.asm" 
1c3f			 
1c3f			; Stack operations for v5 parser on wards 
1c3f			; * DATA stack 
1c3f			; * LOOP stack 
1c3f			; * RETURN stack 
1c3f			 
1c3f			 
1c3f			 
1c3f			FORTH_CHK_DSP_UNDER: macro 
1c3f				push hl 
1c3f				push de 
1c3f				ld hl,(cli_data_sp) 
1c3f				ld de, cli_data_stack 
1c3f				call cmp16 
1c3f				jp c, fault_dsp_under 
1c3f				pop de 
1c3f				pop hl 
1c3f				endm 
1c3f			 
1c3f			 
1c3f			FORTH_CHK_RSP_UNDER: macro 
1c3f				push hl 
1c3f				push de 
1c3f				ld hl,(cli_ret_sp) 
1c3f				ld de, cli_ret_stack 
1c3f				call cmp16 
1c3f				jp c, fault_rsp_under 
1c3f				pop de 
1c3f				pop hl 
1c3f				endm 
1c3f			 
1c3f			FORTH_CHK_LOOP_UNDER: macro 
1c3f				push hl 
1c3f				push de 
1c3f				ld hl,(cli_loop_sp) 
1c3f				ld de, cli_loop_stack 
1c3f				call cmp16 
1c3f				jp c, fault_loop_under 
1c3f				pop de 
1c3f				pop hl 
1c3f				endm 
1c3f			 
1c3f			FORTH_ERR_TOS_NOTSTR: macro 
1c3f				; TOSO might need more for checks when used 
1c3f				push af 
1c3f				ld a,(hl) 
1c3f				cp DS_TYPE_STR 
1c3f				jp nz, type_faultn   
1c3f				pop af 
1c3f				endm 
1c3f			 
1c3f			FORTH_ERR_TOS_NOTNUM: macro 
1c3f				push af 
1c3f				ld a,(hl) 
1c3f				cp DS_TYPE_INUM 
1c3f				jp nz, type_faultn   
1c3f				pop af 
1c3f				endm 
1c3f			 
1c3f			 
1c3f			; increase data stack pointer and save hl to it 
1c3f				 
1c3f			FORTH_DSP_NEXT: macro 
1c3f				call macro_forth_dsp_next 
1c3f				endm 
1c3f			 
1c3f			 
1c3f			macro_forth_dsp_next: 
1c3f				if DEBUG_FORTH_STACK_GUARD 
1c3f cd d8 61				call check_stacks 
1c42				endif 
1c42 e5				push hl 
1c43 d5				push de 
1c44 eb				ex de,hl 
1c45 2a 90 f9			ld hl,(cli_data_sp) 
1c48 23				inc hl 
1c49 23				inc hl 
1c4a			 
1c4a			; PARSEV5 
1c4a 23				inc hl 
1c4b 22 90 f9			ld (cli_data_sp),hl 
1c4e 73				ld (hl), e 
1c4f 23				inc hl 
1c50 72				ld (hl), d 
1c51 d1				pop de 
1c52 e1				pop hl 
1c53				if DEBUG_FORTH_STACK_GUARD 
1c53 cd d8 61				call check_stacks 
1c56				endif 
1c56 c9				ret 
1c57			 
1c57			 
1c57			; increase ret stack pointer and save hl to it 
1c57				 
1c57			FORTH_RSP_NEXT: macro 
1c57				call macro_forth_rsp_next 
1c57				endm 
1c57			 
1c57			macro_forth_rsp_next: 
1c57				if DEBUG_FORTH_STACK_GUARD 
1c57 cd d8 61				call check_stacks 
1c5a				endif 
1c5a e5				push hl 
1c5b d5				push de 
1c5c eb				ex de,hl 
1c5d 2a 94 f9			ld hl,(cli_ret_sp) 
1c60 23				inc hl 
1c61 23				inc hl 
1c62 22 94 f9			ld (cli_ret_sp),hl 
1c65 73				ld (hl), e 
1c66 23				inc hl 
1c67 72				ld (hl), d 
1c68 d1				pop de 
1c69 e1				pop hl 
1c6a				if DEBUG_FORTH_STACK_GUARD 
1c6a cd d8 61				call check_stacks 
1c6d				endif 
1c6d c9				ret 
1c6e			 
1c6e			; get current ret stack pointer and save to hl  
1c6e				 
1c6e			FORTH_RSP_TOS: macro 
1c6e				call macro_forth_rsp_tos 
1c6e				endm 
1c6e			 
1c6e			macro_forth_rsp_tos: 
1c6e				;push de 
1c6e 2a 94 f9			ld hl,(cli_ret_sp) 
1c71 cd a9 1c			call loadhlptrtohl 
1c74				;ld e, (hl) 
1c74				;inc hl 
1c74				;ld d, (hl) 
1c74				;ex de, hl 
1c74					if DEBUG_FORTH_WORDS 
1c74			;			DMARK "RST" 
1c74						CALLMONITOR 
1c74 cd 20 17			call break_point_state  
1c77				endm  
# End of macro CALLMONITOR
1c77					endif 
1c77				;pop de 
1c77 c9				ret 
1c78			 
1c78			; pop ret stack pointer 
1c78				 
1c78			FORTH_RSP_POP: macro 
1c78				call macro_forth_rsp_pop 
1c78				endm 
1c78			 
1c78			 
1c78			macro_forth_rsp_pop: 
1c78				if DEBUG_FORTH_STACK_GUARD 
1c78			;		DMARK "RPP" 
1c78 cd d8 61				call check_stacks 
1c7b					FORTH_CHK_RSP_UNDER 
1c7b e5				push hl 
1c7c d5				push de 
1c7d 2a 94 f9			ld hl,(cli_ret_sp) 
1c80 11 0e f9			ld de, cli_ret_stack 
1c83 cd 24 0d			call cmp16 
1c86 da ec 62			jp c, fault_rsp_under 
1c89 d1				pop de 
1c8a e1				pop hl 
1c8b				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c8b				endif 
1c8b e5				push hl 
1c8c 2a 94 f9			ld hl,(cli_ret_sp) 
1c8f			 
1c8f			 
1c8f				if FORTH_ENABLE_FREE 
1c8f			 
1c8f					; get pointer 
1c8f			 
1c8f					push de 
1c8f					push hl 
1c8f			 
1c8f					ld e, (hl) 
1c8f					inc hl 
1c8f					ld d, (hl) 
1c8f			 
1c8f					ex de, hl 
1c8f					call free 
1c8f			 
1c8f					pop hl 
1c8f					pop de 
1c8f			 
1c8f			 
1c8f				endif 
1c8f			 
1c8f			 
1c8f 2b				dec hl 
1c90 2b				dec hl 
1c91 22 94 f9			ld (cli_ret_sp), hl 
1c94				; do stack underflow checks 
1c94 e1				pop hl 
1c95				if DEBUG_FORTH_STACK_GUARD 
1c95 cd d8 61				call check_stacks 
1c98					FORTH_CHK_RSP_UNDER 
1c98 e5				push hl 
1c99 d5				push de 
1c9a 2a 94 f9			ld hl,(cli_ret_sp) 
1c9d 11 0e f9			ld de, cli_ret_stack 
1ca0 cd 24 0d			call cmp16 
1ca3 da ec 62			jp c, fault_rsp_under 
1ca6 d1				pop de 
1ca7 e1				pop hl 
1ca8				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ca8				endif 
1ca8 c9				ret 
1ca9			 
1ca9			 
1ca9			 
1ca9			; routine to load word pointed to by hl into hl 
1ca9			 
1ca9			loadhlptrtohl: 
1ca9			 
1ca9 d5				push de 
1caa 5e				ld e, (hl) 
1cab 23				inc hl 
1cac 56				ld d, (hl) 
1cad eb				ex de, hl 
1cae d1				pop de 
1caf			 
1caf c9				ret 
1cb0			 
1cb0			 
1cb0			 
1cb0			 
1cb0			 
1cb0			; push a number held in HL onto the data stack 
1cb0			; entry point for pushing a value when already in hl used in function above 
1cb0			 
1cb0			forth_push_numhl: 
1cb0			 
1cb0 e5				push hl    ; save value to push 
1cb1			 
1cb1			if DEBUG_FORTH_PUSH 
1cb1				; see if disabled 
1cb1			 
1cb1			 
1cb1 f5				push af 
1cb2 3a 94 ef			ld a, (os_view_disable) 
1cb5 fe 2a			cp '*' 
1cb7 28 34			jr z, .pskip2 
1cb9 e5				push hl 
1cba e5			push hl 
1cbb cd d2 0a			call clear_display 
1cbe e1			pop hl 
1cbf 7c				ld a,h 
1cc0 21 a8 f2			ld hl, os_word_scratch 
1cc3 cd 07 10			call hexout 
1cc6 e1				pop hl 
1cc7 7d				ld a,l 
1cc8 21 aa f2			ld hl, os_word_scratch+2 
1ccb cd 07 10			call hexout 
1cce			 
1cce 21 ac f2			ld hl, os_word_scratch+4 
1cd1 3e 00			ld a,0 
1cd3 77				ld (hl),a 
1cd4 11 a8 f2			ld de,os_word_scratch 
1cd7 3e 14				ld a, display_row_2 
1cd9 cd e5 0a				call str_at_display 
1cdc 11 e6 50			ld de, .push_num 
1cdf 3e 00			ld a, display_row_1 
1ce1			 
1ce1 cd e5 0a				call str_at_display 
1ce4			 
1ce4			 
1ce4 cd f5 0a			call update_display 
1ce7 cd 52 0a			call delay1s 
1cea cd 52 0a			call delay1s 
1ced			.pskip2:  
1ced			 
1ced f1				pop af 
1cee			endif	 
1cee			 
1cee			 
1cee				FORTH_DSP_NEXT 
1cee cd 3f 1c			call macro_forth_dsp_next 
1cf1				endm 
# End of macro FORTH_DSP_NEXT
1cf1			 
1cf1 2a 90 f9			ld hl, (cli_data_sp) 
1cf4			 
1cf4				; save item type 
1cf4 3e 02			ld a,  DS_TYPE_INUM 
1cf6 77				ld (hl), a 
1cf7 23				inc hl 
1cf8			 
1cf8				; get word off stack 
1cf8 d1				pop de 
1cf9 7b				ld a,e 
1cfa 77				ld (hl), a 
1cfb 23				inc hl 
1cfc 7a				ld a,d 
1cfd 77				ld (hl), a 
1cfe			 
1cfe			if DEBUG_FORTH_PUSH 
1cfe 2b				dec hl 
1cff 2b				dec hl 
1d00 2b				dec hl 
1d01						DMARK "PH5" 
1d01 f5				push af  
1d02 3a 16 1d			ld a, (.dmark)  
1d05 32 bd fb			ld (debug_mark),a  
1d08 3a 17 1d			ld a, (.dmark+1)  
1d0b 32 be fb			ld (debug_mark+1),a  
1d0e 3a 18 1d			ld a, (.dmark+2)  
1d11 32 bf fb			ld (debug_mark+2),a  
1d14 18 03			jr .pastdmark  
1d16 ..			.dmark: db "PH5"  
1d19 f1			.pastdmark: pop af  
1d1a			endm  
# End of macro DMARK
1d1a				CALLMONITOR 
1d1a cd 20 17			call break_point_state  
1d1d				endm  
# End of macro CALLMONITOR
1d1d			endif	 
1d1d			 
1d1d c9				ret 
1d1e			 
1d1e			 
1d1e			; Push a string to stack pointed to by hl 
1d1e			 
1d1e			forth_push_str: 
1d1e			 
1d1e			if DEBUG_FORTH_PUSH 
1d1e						DMARK "PSQ" 
1d1e f5				push af  
1d1f 3a 33 1d			ld a, (.dmark)  
1d22 32 bd fb			ld (debug_mark),a  
1d25 3a 34 1d			ld a, (.dmark+1)  
1d28 32 be fb			ld (debug_mark+1),a  
1d2b 3a 35 1d			ld a, (.dmark+2)  
1d2e 32 bf fb			ld (debug_mark+2),a  
1d31 18 03			jr .pastdmark  
1d33 ..			.dmark: db "PSQ"  
1d36 f1			.pastdmark: pop af  
1d37			endm  
# End of macro DMARK
1d37				CALLMONITOR 
1d37 cd 20 17			call break_point_state  
1d3a				endm  
# End of macro CALLMONITOR
1d3a			endif	 
1d3a			    
1d3a e5				push hl 
1d3b e5				push hl 
1d3c			 
1d3c			;	ld a, 0   ; find end of string 
1d3c cd 64 11			call strlenz 
1d3f			if DEBUG_FORTH_PUSH 
1d3f						DMARK "PQ2" 
1d3f f5				push af  
1d40 3a 54 1d			ld a, (.dmark)  
1d43 32 bd fb			ld (debug_mark),a  
1d46 3a 55 1d			ld a, (.dmark+1)  
1d49 32 be fb			ld (debug_mark+1),a  
1d4c 3a 56 1d			ld a, (.dmark+2)  
1d4f 32 bf fb			ld (debug_mark+2),a  
1d52 18 03			jr .pastdmark  
1d54 ..			.dmark: db "PQ2"  
1d57 f1			.pastdmark: pop af  
1d58			endm  
# End of macro DMARK
1d58				CALLMONITOR 
1d58 cd 20 17			call break_point_state  
1d5b				endm  
# End of macro CALLMONITOR
1d5b			endif	 
1d5b eb				ex de, hl 
1d5c e1				pop hl   ; get ptr to start of string 
1d5d			if DEBUG_FORTH_PUSH 
1d5d						DMARK "PQ3" 
1d5d f5				push af  
1d5e 3a 72 1d			ld a, (.dmark)  
1d61 32 bd fb			ld (debug_mark),a  
1d64 3a 73 1d			ld a, (.dmark+1)  
1d67 32 be fb			ld (debug_mark+1),a  
1d6a 3a 74 1d			ld a, (.dmark+2)  
1d6d 32 bf fb			ld (debug_mark+2),a  
1d70 18 03			jr .pastdmark  
1d72 ..			.dmark: db "PQ3"  
1d75 f1			.pastdmark: pop af  
1d76			endm  
# End of macro DMARK
1d76				CALLMONITOR 
1d76 cd 20 17			call break_point_state  
1d79				endm  
# End of macro CALLMONITOR
1d79			endif	 
1d79 19				add hl,de 
1d7a			if DEBUG_FORTH_PUSH 
1d7a						DMARK "PQE" 
1d7a f5				push af  
1d7b 3a 8f 1d			ld a, (.dmark)  
1d7e 32 bd fb			ld (debug_mark),a  
1d81 3a 90 1d			ld a, (.dmark+1)  
1d84 32 be fb			ld (debug_mark+1),a  
1d87 3a 91 1d			ld a, (.dmark+2)  
1d8a 32 bf fb			ld (debug_mark+2),a  
1d8d 18 03			jr .pastdmark  
1d8f ..			.dmark: db "PQE"  
1d92 f1			.pastdmark: pop af  
1d93			endm  
# End of macro DMARK
1d93				CALLMONITOR 
1d93 cd 20 17			call break_point_state  
1d96				endm  
# End of macro CALLMONITOR
1d96			endif	 
1d96			 
1d96 2b				dec hl    ; see if there is an optional trailing double quote 
1d97 7e				ld a,(hl) 
1d98 fe 22			cp '"' 
1d9a 20 03			jr nz, .strnoq 
1d9c 3e 00			ld a, 0      ; get rid of double quote 
1d9e 77				ld (hl), a 
1d9f 23			.strnoq: inc hl 
1da0			 
1da0 3e 00			ld a, 0 
1da2 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1da3			 
1da3 13				inc de ; add one for the type string 
1da4 13				inc de ; add one for null term??? 
1da5			 
1da5				; tos is get string pointer again 
1da5				; de contains space to allocate 
1da5				 
1da5 d5				push de 
1da6			 
1da6 eb				ex de, hl 
1da7			 
1da7				;push af 
1da7			 
1da7			if DEBUG_FORTH_PUSH 
1da7						DMARK "PHm" 
1da7 f5				push af  
1da8 3a bc 1d			ld a, (.dmark)  
1dab 32 bd fb			ld (debug_mark),a  
1dae 3a bd 1d			ld a, (.dmark+1)  
1db1 32 be fb			ld (debug_mark+1),a  
1db4 3a be 1d			ld a, (.dmark+2)  
1db7 32 bf fb			ld (debug_mark+2),a  
1dba 18 03			jr .pastdmark  
1dbc ..			.dmark: db "PHm"  
1dbf f1			.pastdmark: pop af  
1dc0			endm  
# End of macro DMARK
1dc0				CALLMONITOR 
1dc0 cd 20 17			call break_point_state  
1dc3				endm  
# End of macro CALLMONITOR
1dc3			endif	 
1dc3 cd cd 11			call malloc	; on ret hl now contains allocated memory 
1dc6				if DEBUG_FORTH_MALLOC_GUARD 
1dc6 cc 3e 51				call z,malloc_error 
1dc9				endif 
1dc9			 
1dc9				 
1dc9 c1				pop bc    ; get length 
1dca d1				pop de   ;  get string start    
1dcb			 
1dcb				; hl has destination from malloc 
1dcb			 
1dcb eb				ex de, hl    ; prep for ldir 
1dcc			 
1dcc d5				push de   ; save malloc area for DSP later 
1dcd				;push hl   ; save malloc area for DSP later 
1dcd			 
1dcd			if DEBUG_FORTH_PUSH 
1dcd						DMARK "PHc" 
1dcd f5				push af  
1dce 3a e2 1d			ld a, (.dmark)  
1dd1 32 bd fb			ld (debug_mark),a  
1dd4 3a e3 1d			ld a, (.dmark+1)  
1dd7 32 be fb			ld (debug_mark+1),a  
1dda 3a e4 1d			ld a, (.dmark+2)  
1ddd 32 bf fb			ld (debug_mark+2),a  
1de0 18 03			jr .pastdmark  
1de2 ..			.dmark: db "PHc"  
1de5 f1			.pastdmark: pop af  
1de6			endm  
# End of macro DMARK
1de6				CALLMONITOR 
1de6 cd 20 17			call break_point_state  
1de9				endm  
# End of macro CALLMONITOR
1de9			endif	 
1de9			 
1de9			 
1de9 ed b0			ldir 
1deb			 
1deb			 
1deb				; push malloc to data stack     macro?????  
1deb			 
1deb				FORTH_DSP_NEXT 
1deb cd 3f 1c			call macro_forth_dsp_next 
1dee				endm 
# End of macro FORTH_DSP_NEXT
1dee			 
1dee				; save value and type 
1dee			 
1dee 2a 90 f9			ld hl, (cli_data_sp) 
1df1			 
1df1				; save item type 
1df1 3e 01			ld a,  DS_TYPE_STR 
1df3 77				ld (hl), a 
1df4 23				inc hl 
1df5			 
1df5				; get malloc word off stack 
1df5 d1				pop de 
1df6 73				ld (hl), e 
1df7 23				inc hl 
1df8 72				ld (hl), d 
1df9			 
1df9			 
1df9			 
1df9			if DEBUG_FORTH_PUSH 
1df9 2a 90 f9			ld hl, (cli_data_sp) 
1dfc						DMARK "PHS" 
1dfc f5				push af  
1dfd 3a 11 1e			ld a, (.dmark)  
1e00 32 bd fb			ld (debug_mark),a  
1e03 3a 12 1e			ld a, (.dmark+1)  
1e06 32 be fb			ld (debug_mark+1),a  
1e09 3a 13 1e			ld a, (.dmark+2)  
1e0c 32 bf fb			ld (debug_mark+2),a  
1e0f 18 03			jr .pastdmark  
1e11 ..			.dmark: db "PHS"  
1e14 f1			.pastdmark: pop af  
1e15			endm  
# End of macro DMARK
1e15				CALLMONITOR 
1e15 cd 20 17			call break_point_state  
1e18				endm  
# End of macro CALLMONITOR
1e18			;	ex de,hl 
1e18			endif	 
1e18				; in case of spaces, skip the ptr past the copied string 
1e18				;pop af 
1e18				;ld (cli_origptr),hl 
1e18			 
1e18 c9				ret 
1e19			 
1e19			 
1e19			 
1e19			; TODO ascii push input onto stack given hl to start of input 
1e19			 
1e19			; identify type 
1e19			; if starts with a " then a string 
1e19			; otherwise it is a number 
1e19			;  
1e19			; if a string 
1e19			;     scan for ending " to get length of string to malloc for + 1 
1e19			;     malloc 
1e19			;     put pointer to string on stack first byte flags as string 
1e19			; 
1e19			; else a number 
1e19			;    look for number format identifier 
1e19			;    $xx hex 
1e19			;    %xxxxx bin 
1e19			;    xxxxx decimal 
1e19			;    convert number to 16bit word.  
1e19			;    malloc word + 1 with flag to identiy as num 
1e19			;    put pointer to number on stack 
1e19			;   
1e19			;  
1e19			  
1e19			forth_apush: 
1e19				; kernel push 
1e19			 
1e19			if DEBUG_FORTH_PUSH 
1e19						DMARK "PSH" 
1e19 f5				push af  
1e1a 3a 2e 1e			ld a, (.dmark)  
1e1d 32 bd fb			ld (debug_mark),a  
1e20 3a 2f 1e			ld a, (.dmark+1)  
1e23 32 be fb			ld (debug_mark+1),a  
1e26 3a 30 1e			ld a, (.dmark+2)  
1e29 32 bf fb			ld (debug_mark+2),a  
1e2c 18 03			jr .pastdmark  
1e2e ..			.dmark: db "PSH"  
1e31 f1			.pastdmark: pop af  
1e32			endm  
# End of macro DMARK
1e32				CALLMONITOR 
1e32 cd 20 17			call break_point_state  
1e35				endm  
# End of macro CALLMONITOR
1e35			endif	 
1e35				; identify input type 
1e35			 
1e35 7e				ld a,(hl) 
1e36 fe 22			cp '"' 
1e38 28 0a			jr z, .fapstr 
1e3a fe 24			cp '$' 
1e3c ca 64 1e			jp z, .faphex 
1e3f fe 25			cp '%' 
1e41 ca 4c 1e			jp z, .fapbin 
1e44			;	cp 'b' 
1e44			;	jp z, .fabin 
1e44				; else decimal 
1e44			 
1e44				; TODO do decimal conversion 
1e44				; decimal is stored as a 16bit word 
1e44			 
1e44				; by default everything is a string if type is not detected 
1e44			.fapstr: ; 
1e44 fe 22			cp '"' 
1e46 20 01			jr nz, .strnoqu 
1e48 23				inc hl 
1e49			.strnoqu: 
1e49 c3 1e 1d			jp forth_push_str 
1e4c			 
1e4c			 
1e4c			 
1e4c			.fapbin:    ; push a binary string.  
1e4c 11 00 00			ld de, 0   ; hold a 16bit value 
1e4f			 
1e4f 23			.fapbinshift:	inc hl  
1e50 7e				ld a,(hl) 
1e51 fe 00			cp 0     ; done scanning  
1e53 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e55			 
1e55				; left shift de 
1e55 eb				ex de, hl	 
1e56 29				add hl, hl 
1e57			 
1e57				; is 1 
1e57 fe 31			cp '1' 
1e59 20 02			jr nz, .binzero 
1e5b cb 4d			bit 1, l 
1e5d			.binzero: 
1e5d eb				ex de, hl	 ; save current de 
1e5e 18 ef			jr .fapbinshift 
1e60			 
1e60			.fapbdone: 
1e60 eb				ex de, hl 
1e61 c3 b0 1c			jp forth_push_numhl 
1e64			 
1e64			 
1e64			.faphex:   ; hex is always stored as a 16bit word 
1e64				; skip number prefix 
1e64 23				inc hl 
1e65				; turn ascii into number 
1e65 cd bd 10			call get_word_hl	; ret 16bit word in hl 
1e68			 
1e68 c3 b0 1c			jp forth_push_numhl 
1e6b			 
1e6b 00				 nop 
1e6c			 
1e6c			.fabin:   ; TODO bin conversion 
1e6c			 
1e6c			 
1e6c c9				ret 
1e6d			 
1e6d			 
1e6d			; get either a string ptr or a 16bit word from the data stack 
1e6d			 
1e6d			FORTH_DSP: macro 
1e6d				call macro_forth_dsp 
1e6d				endm 
1e6d			 
1e6d			macro_forth_dsp: 
1e6d				; data stack pointer points to current word on tos 
1e6d			 
1e6d 2a 90 f9			ld hl,(cli_data_sp) 
1e70			 
1e70				if DEBUG_FORTH_PUSH 
1e70						DMARK "DSP" 
1e70 f5				push af  
1e71 3a 85 1e			ld a, (.dmark)  
1e74 32 bd fb			ld (debug_mark),a  
1e77 3a 86 1e			ld a, (.dmark+1)  
1e7a 32 be fb			ld (debug_mark+1),a  
1e7d 3a 87 1e			ld a, (.dmark+2)  
1e80 32 bf fb			ld (debug_mark+2),a  
1e83 18 03			jr .pastdmark  
1e85 ..			.dmark: db "DSP"  
1e88 f1			.pastdmark: pop af  
1e89			endm  
# End of macro DMARK
1e89			 
1e89 cd 73 51				call display_data_sp 
1e8c				;call break_point_state 
1e8c				;rst 030h 
1e8c				CALLMONITOR 
1e8c cd 20 17			call break_point_state  
1e8f				endm  
# End of macro CALLMONITOR
1e8f				endif 
1e8f			 
1e8f c9				ret 
1e90			 
1e90			; return hl to start of value on stack 
1e90			 
1e90			FORTH_DSP_VALUE: macro 
1e90				call macro_forth_dsp_value 
1e90				endm 
1e90			 
1e90			macro_forth_dsp_value: 
1e90			 
1e90				FORTH_DSP 
1e90 cd 6d 1e			call macro_forth_dsp 
1e93				endm 
# End of macro FORTH_DSP
1e93			 
1e93 d5				push de 
1e94			 
1e94 23				inc hl ; skip type 
1e95			 
1e95 5e				ld e, (hl) 
1e96 23				inc hl 
1e97 56				ld d, (hl) 
1e98 eb				ex de,hl  
1e99			 
1e99 d1				pop de 
1e9a			 
1e9a c9				ret 
1e9b			 
1e9b			; return hl to start of value to second item on stack 
1e9b			 
1e9b			FORTH_DSP_VALUEM1: macro 
1e9b				call macro_forth_dsp_value_m1 
1e9b				endm 
1e9b			 
1e9b			macro_forth_dsp_value_m1: 
1e9b			 
1e9b				FORTH_DSP 
1e9b cd 6d 1e			call macro_forth_dsp 
1e9e				endm 
# End of macro FORTH_DSP
1e9e			 
1e9e 2b				dec hl 
1e9f 2b				dec hl 
1ea0			;	dec hl 
1ea0			 
1ea0 d5				push de 
1ea1			 
1ea1 5e				ld e, (hl) 
1ea2 23				inc hl 
1ea3 56				ld d, (hl) 
1ea4 eb				ex de,hl  
1ea5			 
1ea5 d1				pop de 
1ea6			 
1ea6 c9				ret 
1ea7			 
1ea7				 
1ea7			 
1ea7			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ea7			 
1ea7			FORTH_DSP_POP: macro 
1ea7				call macro_forth_dsp_pop 
1ea7				endm 
1ea7			 
1ea7			 
1ea7			; get the tos data type 
1ea7			 
1ea7			FORTH_DSP_TYPE:   macro 
1ea7			 
1ea7				;FORTH_DSP_VALUE 
1ea7				FORTH_DSP 
1ea7				 
1ea7				; hl points to value 
1ea7				; check type 
1ea7			 
1ea7				ld a,(hl) 
1ea7			 
1ea7				endm 
1ea7			 
1ea7			; load the tos value into hl 
1ea7			 
1ea7			 
1ea7			FORTH_DSP_VALUEHL:  macro 
1ea7				call macro_dsp_valuehl 
1ea7				endm 
1ea7			 
1ea7			 
1ea7			 
1ea7			macro_dsp_valuehl: 
1ea7				FORTH_DSP_VALUE 
1ea7 cd 90 1e			call macro_forth_dsp_value 
1eaa				endm 
# End of macro FORTH_DSP_VALUE
1eaa			 
1eaa				;FORTH_ERR_TOS_NOTNUM 
1eaa			 
1eaa				;inc hl   ; skip type id 
1eaa			 
1eaa			;	push de 
1eaa			; 
1eaa			;	ld e, (hl) 
1eaa			;	inc hl 
1eaa			;	ld d, (hl) 
1eaa			;	ex de,hl  
1eaa			 
1eaa			;	pop de 
1eaa			 
1eaa				if DEBUG_FORTH_PUSH 
1eaa						DMARK "DVL" 
1eaa f5				push af  
1eab 3a bf 1e			ld a, (.dmark)  
1eae 32 bd fb			ld (debug_mark),a  
1eb1 3a c0 1e			ld a, (.dmark+1)  
1eb4 32 be fb			ld (debug_mark+1),a  
1eb7 3a c1 1e			ld a, (.dmark+2)  
1eba 32 bf fb			ld (debug_mark+2),a  
1ebd 18 03			jr .pastdmark  
1ebf ..			.dmark: db "DVL"  
1ec2 f1			.pastdmark: pop af  
1ec3			endm  
# End of macro DMARK
1ec3				CALLMONITOR 
1ec3 cd 20 17			call break_point_state  
1ec6				endm  
# End of macro CALLMONITOR
1ec6				endif 
1ec6 c9				ret 
1ec7			 
1ec7			forth_apushstrhl:      
1ec7				; push of string requires use of cli_origptr 
1ec7				; bodge use 
1ec7			 
1ec7				; get current cli_origptr, save, update with temp pointer  
1ec7 ed 5b ac f9		ld de, (cli_origptr) 
1ecb 22 ac f9			ld (cli_origptr), hl 
1ece d5				push de 
1ecf cd 19 1e			call forth_apush 
1ed2 d1				pop de 
1ed3 ed 53 ac f9		ld (cli_origptr), de 
1ed7 c9			        ret	 
1ed8			 
1ed8			 
1ed8			; increase loop stack pointer and save hl to it 
1ed8				 
1ed8			FORTH_LOOP_NEXT: macro 
1ed8				call macro_forth_loop_next 
1ed8				;nop 
1ed8				endm 
1ed8			 
1ed8			macro_forth_loop_next: 
1ed8				if DEBUG_FORTH_STACK_GUARD 
1ed8 cd d8 61				call check_stacks 
1edb				endif 
1edb e5				push hl 
1edc d5				push de 
1edd eb				ex de,hl 
1ede 2a 92 f9			ld hl,(cli_loop_sp) 
1ee1 23				inc hl 
1ee2 23				inc hl 
1ee3					if DEBUG_FORTH_WORDS 
1ee3						DMARK "LNX" 
1ee3 f5				push af  
1ee4 3a f8 1e			ld a, (.dmark)  
1ee7 32 bd fb			ld (debug_mark),a  
1eea 3a f9 1e			ld a, (.dmark+1)  
1eed 32 be fb			ld (debug_mark+1),a  
1ef0 3a fa 1e			ld a, (.dmark+2)  
1ef3 32 bf fb			ld (debug_mark+2),a  
1ef6 18 03			jr .pastdmark  
1ef8 ..			.dmark: db "LNX"  
1efb f1			.pastdmark: pop af  
1efc			endm  
# End of macro DMARK
1efc						CALLMONITOR 
1efc cd 20 17			call break_point_state  
1eff				endm  
# End of macro CALLMONITOR
1eff					endif 
1eff 22 92 f9			ld (cli_loop_sp),hl 
1f02 73				ld (hl), e 
1f03 23				inc hl 
1f04 72				ld (hl), d 
1f05 d1				pop de    ; been reversed so save a swap on restore 
1f06 e1				pop hl 
1f07				if DEBUG_FORTH_STACK_GUARD 
1f07 cd d8 61				call check_stacks 
1f0a				endif 
1f0a c9				ret 
1f0b			 
1f0b			; get current ret stack pointer and save to hl  
1f0b				 
1f0b			FORTH_LOOP_TOS: macro 
1f0b				call macro_forth_loop_tos 
1f0b				endm 
1f0b			 
1f0b			macro_forth_loop_tos: 
1f0b d5				push de 
1f0c 2a 92 f9			ld hl,(cli_loop_sp) 
1f0f 5e				ld e, (hl) 
1f10 23				inc hl 
1f11 56				ld d, (hl) 
1f12 eb				ex de, hl 
1f13 d1				pop de 
1f14 c9				ret 
1f15			 
1f15			; pop loop stack pointer 
1f15				 
1f15			FORTH_LOOP_POP: macro 
1f15				call macro_forth_loop_pop 
1f15				endm 
1f15			 
1f15			 
1f15			macro_forth_loop_pop: 
1f15				if DEBUG_FORTH_STACK_GUARD 
1f15					DMARK "LPP" 
1f15 f5				push af  
1f16 3a 2a 1f			ld a, (.dmark)  
1f19 32 bd fb			ld (debug_mark),a  
1f1c 3a 2b 1f			ld a, (.dmark+1)  
1f1f 32 be fb			ld (debug_mark+1),a  
1f22 3a 2c 1f			ld a, (.dmark+2)  
1f25 32 bf fb			ld (debug_mark+2),a  
1f28 18 03			jr .pastdmark  
1f2a ..			.dmark: db "LPP"  
1f2d f1			.pastdmark: pop af  
1f2e			endm  
# End of macro DMARK
1f2e cd d8 61				call check_stacks 
1f31					FORTH_CHK_LOOP_UNDER 
1f31 e5				push hl 
1f32 d5				push de 
1f33 2a 92 f9			ld hl,(cli_loop_sp) 
1f36 11 0c f7			ld de, cli_loop_stack 
1f39 cd 24 0d			call cmp16 
1f3c da f2 62			jp c, fault_loop_under 
1f3f d1				pop de 
1f40 e1				pop hl 
1f41				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f41				endif 
1f41 e5				push hl 
1f42 2a 92 f9			ld hl,(cli_loop_sp) 
1f45 2b				dec hl 
1f46 2b				dec hl 
1f47 22 92 f9			ld (cli_loop_sp), hl 
1f4a				; TODO do stack underflow checks 
1f4a e1				pop hl 
1f4b				if DEBUG_FORTH_STACK_GUARD 
1f4b cd d8 61				call check_stacks 
1f4e					FORTH_CHK_LOOP_UNDER 
1f4e e5				push hl 
1f4f d5				push de 
1f50 2a 92 f9			ld hl,(cli_loop_sp) 
1f53 11 0c f7			ld de, cli_loop_stack 
1f56 cd 24 0d			call cmp16 
1f59 da f2 62			jp c, fault_loop_under 
1f5c d1				pop de 
1f5d e1				pop hl 
1f5e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f5e				endif 
1f5e c9				ret 
1f5f			 
1f5f			macro_forth_dsp_pop: 
1f5f			 
1f5f e5				push hl 
1f60			 
1f60				; release malloc data 
1f60			 
1f60				if DEBUG_FORTH_STACK_GUARD 
1f60 cd d8 61				call check_stacks 
1f63					FORTH_CHK_DSP_UNDER 
1f63 e5				push hl 
1f64 d5				push de 
1f65 2a 90 f9			ld hl,(cli_data_sp) 
1f68 11 0a f5			ld de, cli_data_stack 
1f6b cd 24 0d			call cmp16 
1f6e da e6 62			jp c, fault_dsp_under 
1f71 d1				pop de 
1f72 e1				pop hl 
1f73				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f73				endif 
1f73				;ld hl,(cli_data_sp) 
1f73			if DEBUG_FORTH_DOT 
1f73				DMARK "DPP" 
1f73				CALLMONITOR 
1f73			endif	 
1f73			 
1f73			 
1f73			if FORTH_ENABLE_DSPPOPFREE 
1f73			 
1f73				FORTH_DSP 
1f73 cd 6d 1e			call macro_forth_dsp 
1f76				endm 
# End of macro FORTH_DSP
1f76			 
1f76 7e				ld a, (hl) 
1f77 fe 01			cp DS_TYPE_STR 
1f79 20 07			jr nz, .skippopfree 
1f7b			 
1f7b				FORTH_DSP_VALUEHL 
1f7b cd a7 1e			call macro_dsp_valuehl 
1f7e				endm 
# End of macro FORTH_DSP_VALUEHL
1f7e 00				nop 
1f7f			if DEBUG_FORTH_DOT 
1f7f				DMARK "DPf" 
1f7f				CALLMONITOR 
1f7f			endif	 
1f7f cd 97 12			call free 
1f82			.skippopfree: 
1f82				 
1f82			 
1f82			endif 
1f82			 
1f82			if DEBUG_FORTH_DOT_KEY 
1f82				DMARK "DP2" 
1f82				CALLMONITOR 
1f82			endif	 
1f82			 
1f82				; move pointer down 
1f82			 
1f82 2a 90 f9			ld hl,(cli_data_sp) 
1f85 2b				dec hl 
1f86 2b				dec hl 
1f87			; PARSEV5 
1f87 2b				dec hl 
1f88 22 90 f9			ld (cli_data_sp), hl 
1f8b			 
1f8b				if DEBUG_FORTH_STACK_GUARD 
1f8b cd d8 61				call check_stacks 
1f8e					FORTH_CHK_DSP_UNDER 
1f8e e5				push hl 
1f8f d5				push de 
1f90 2a 90 f9			ld hl,(cli_data_sp) 
1f93 11 0a f5			ld de, cli_data_stack 
1f96 cd 24 0d			call cmp16 
1f99 da e6 62			jp c, fault_dsp_under 
1f9c d1				pop de 
1f9d e1				pop hl 
1f9e				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f9e				endif 
1f9e			 
1f9e e1				pop hl 
1f9f			 
1f9f c9				ret 
1fa0			 
1fa0			getwordathl: 
1fa0				; hl points to an address 
1fa0				; load hl with the word at that address 
1fa0			 
1fa0 d5				push de 
1fa1			 
1fa1 5e				ld e, (hl) 
1fa2 23				inc hl 
1fa3 56				ld d, (hl) 
1fa4 eb				ex de, hl 
1fa5			 
1fa5 d1				pop de 
1fa6 c9				ret 
1fa7			 
1fa7			 
1fa7			 
1fa7			 
1fa7			 
1fa7			; eof 
1fa7			 
# End of file forth_stackopsv5.asm
1fa7			endif 
1fa7			 
1fa7			user_word_eol:  
1fa7				; hl contains the pointer to where to create a linked list item from the end 
1fa7				; of the user dict to continue on at the system word dict 
1fa7				 
1fa7				; poke the stub of the word list linked list to repoint to rom words 
1fa7			 
1fa7				; stub format 
1fa7				; db   word id 
1fa7				; dw    link to next word 
1fa7			        ; db char length of token 
1fa7				; db string + 0 term 
1fa7				; db exec code....  
1fa7			 
1fa7 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fa9 77				ld (hl), a		; word id 
1faa 23				inc hl 
1fab			 
1fab 11 71 21			ld de, sysdict 
1fae 73				ld (hl), e		; next word link ie system dict 
1faf 23				inc hl 
1fb0 72				ld (hl), d		; next word link ie system dict 
1fb1 23				inc hl	 
1fb2			 
1fb2			;	ld (hl), sysdict		; next word link ie system dict 
1fb2			;	inc hl 
1fb2			;	inc hl 
1fb2			 
1fb2			;	inc hl 
1fb2			;	inc hl 
1fb2			 
1fb2 3e 02			ld a, 2			; word length is 0 
1fb4 77				ld (hl), a	 
1fb5 23				inc hl 
1fb6			 
1fb6 3e 7e			ld a, '~'			; word length is 0 
1fb8 77				ld (hl), a	 
1fb9 23				inc hl 
1fba 3e 00			ld a, 0			; save empty word 
1fbc 77				ld (hl), a 
1fbd			 
1fbd c9				ret 
1fbe			 
1fbe				 
1fbe			 
1fbe			forthexec_cleanup: 
1fbe				FORTH_RSP_POP 
1fbe cd 78 1c			call macro_forth_rsp_pop 
1fc1				endm 
# End of macro FORTH_RSP_POP
1fc1 c9				ret 
1fc2			 
1fc2			forth_call_hl: 
1fc2				; taking hl 
1fc2 e5				push hl 
1fc3 c9				ret 
1fc4			 
1fc4			; this is called to reset Forth system but keep existing uwords etc 
1fc4			 
1fc4			forth_warmstart: 
1fc4				; setup stack over/under flow checks 
1fc4				if DEBUG_FORTH_STACK_GUARD 
1fc4 cd be 61				call chk_stk_init 
1fc7				endif 
1fc7			 
1fc7				; init stack pointers  - * these stacks go upwards *  
1fc7 21 0e f9			ld hl, cli_ret_stack 
1fca 22 94 f9			ld (cli_ret_sp), hl	 
1fcd				; set bottom of stack 
1fcd 3e 00			ld a,0 
1fcf 77				ld (hl),a 
1fd0 23				inc hl 
1fd1 77				ld (hl),a 
1fd2			 
1fd2 21 0a f5			ld hl, cli_data_stack 
1fd5 22 90 f9			ld (cli_data_sp), hl	 
1fd8				; set bottom of stack 
1fd8 3e 00			ld a,0 
1fda 77				ld (hl),a 
1fdb 23				inc hl 
1fdc 77				ld (hl),a 
1fdd			 
1fdd 21 0c f7			ld hl, cli_loop_stack 
1fe0 22 92 f9			ld (cli_loop_sp), hl	 
1fe3				; set bottom of stack 
1fe3 3e 00			ld a,0 
1fe5 77				ld (hl),a 
1fe6 23				inc hl 
1fe7 77				ld (hl),a 
1fe8			 
1fe8				; init extent of current open file 
1fe8			 
1fe8 3e 00			ld a, 0 
1fea 32 df f9			ld (store_openext), a 
1fed			 
1fed c9				ret 
1fee			 
1fee			 
1fee			; Cold Start - this is called to setup the whole Forth system 
1fee			 
1fee			forth_init: 
1fee			 
1fee				; setup stack over/under flow checks 
1fee			 
1fee			;	if DEBUG_FORTH_STACK_GUARD 
1fee			;		call chk_stk_init 
1fee			;	endif 
1fee			 
1fee				; enable auto display updates (slow.....) 
1fee			 
1fee 3e 01			ld a, 1 
1ff0 32 aa f9			ld (cli_autodisplay), a 
1ff3			 
1ff3			 
1ff3			 
1ff3				; show start up screen 
1ff3			 
1ff3 cd d2 0a			call clear_display 
1ff6			 
1ff6 3e 00			ld a,0 
1ff8 32 cc f9			ld (f_cursor_ptr), a 
1ffb			 
1ffb				; set start of word list in start of ram - for use when creating user words 
1ffb			 
1ffb 21 00 80			ld hl, baseram 
1ffe 22 a0 f2			ld (os_last_new_uword), hl 
2001 cd a7 1f			call user_word_eol 
2004				 
2004			;		call display_data_sp 
2004			;		call next_page_prompt 
2004			 
2004			 
2004			 
2004			 
2004 c9				ret 
2005			 
2005 .. 00		.bootforth: db " Forth Kernel Init ",0 
2019			 
2019			; TODO push to stack 
2019			 
2019			;  
2019			 
2019			if FORTH_PARSEV2 
2019			 
2019			 
2019				include "forth_parserv2.asm" 
2019			 
2019			endif 
2019			 
2019			 
2019			; parse cli version 1 
2019			 
2019			if FORTH_PARSEV1 
2019			 
2019			 
2019			 
2019			      include "forth_parserv1.asm" 
2019			endif 
2019				 
2019			if FORTH_PARSEV3 
2019			 
2019			 
2019			 
2019			      include "forth_parserv3.asm" 
2019				include "forth_wordsv3.asm" 
2019			endif 
2019			 
2019			if FORTH_PARSEV4 
2019			 
2019			 
2019			 
2019			      include "forth_parserv4.asm" 
2019				include "forth_wordsv4.asm" 
2019			endif 
2019			 
2019			if FORTH_PARSEV5 
2019			 
2019			 
2019			 
2019			      include "forth_parserv5.asm" 
2019			 
2019			 
2019			; A better parser without using malloc and string copies all over the place.  
2019			; Exec in situ should be faster 
2019			 
2019			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2019			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2019			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2019			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2019			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2019			WORD_SYS_END: equ 0   ; Opcode for all user words 
2019			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2019			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2019			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2019			 
2019			; Core word preamble macro 
2019			 
2019			CWHEAD:   macro nxtword opcode lit len opflags 
2019				db WORD_SYS_CORE+opcode             
2019				; internal op code number 
2019				dw nxtword            
2019				; link to next dict word block 
2019				db len + 1 
2019				; literal length of dict word inc zero term 
2019				db lit,0              
2019				; literal dict word 
2019			        ; TODO db opflags        
2019				endm 
2019			 
2019			 
2019			NEXTW: macro  
2019				jp macro_next 
2019				endm 
2019			 
2019			macro_next: 
2019			if DEBUG_FORTH_PARSE_KEY 
2019				DMARK "NXT" 
2019				CALLMONITOR 
2019			endif	 
2019			;	inc hl  ; skip token null term  
2019 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
201d ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2021 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2024			if DEBUG_FORTH_PARSE_KEY 
2024				DMARK "}AA" 
2024				CALLMONITOR 
2024			endif	 
2024 c3 27 21			jp execnext 
2027				;jp exec1 
2027			       
2027			 
2027			 
2027			; Another go at the parser to compile  
2027			 
2027			 
2027			; TODO rework parser to change all of the string words to byte tokens 
2027			; TODO do a search for  
2027			 
2027			; TODO first run normal parser to zero term sections 
2027			; TODO for each word do a token look up to get the op code 
2027			; TODO need some means to flag to the exec that this is a byte code form    
2027			 
2027			 
2027			forthcompile: 
2027			 
2027			; 
2027			; line parse: 
2027			;       parse raw input buffer 
2027			;       tokenise the words 
2027			;       malloc new copy (for looping etc) 
2027			;       copy to malloc + current pc in line to start of string and add line term 
2027			;       save on new rsp 
2027			; 
2027			 
2027			; hl to point to the line to tokenise 
2027			 
2027			;	push hl 
2027 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
202a			 
202a			;	ld a,0		; string term on input 
202a			;	call strlent 
202a			 
202a			;	ld (os_tok_len), hl	 ; save string length 
202a			 
202a			;if DEBUG_FORTH_TOK 
202a			;	ex de,hl		 
202a			;endif 
202a			 
202a			;	pop hl 		; get back string pointer 
202a			 
202a			if DEBUG_FORTH_TOK 
202a						DMARK "TOc" 
202a				CALLMONITOR 
202a			endif 
202a 7e			.cptoken2:    ld a,(hl) 
202b 23				inc hl 
202c fe 7f			cp FORTH_END_BUFFER 
202e 28 29			jr z, .cptokendone2 
2030 fe 00			cp 0 
2032 28 25			jr z, .cptokendone2 
2034 fe 22			cp '"' 
2036 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2038 fe 20			cp ' ' 
203a 20 ee			jr nz,  .cptoken2 
203c			 
203c			; TODO consume comments held between ( and ) 
203c			 
203c				; we have a space so change to zero term for dict match later 
203c 2b				dec hl 
203d 3e 00			ld a,0 
203f 77				ld (hl), a 
2040 23				inc hl 
2041 18 e7			jr .cptoken2 
2043				 
2043			 
2043			.cptokenstr2: 
2043				; skip all white space until either eol (because forgot to term) or end double quote 
2043			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2043				;inc hl ; skip current double quote 
2043 7e				ld a,(hl) 
2044 23				inc hl 
2045 fe 22			cp '"' 
2047 28 e1			jr z, .cptoken2 
2049 fe 7f			cp FORTH_END_BUFFER 
204b 28 0c			jr z, .cptokendone2 
204d fe 00			cp 0 
204f 28 08			jr z, .cptokendone2 
2051 fe 20			cp ' ' 
2053 28 02			jr z, .cptmp2 
2055 18 ec			jr .cptokenstr2 
2057			 
2057			.cptmp2:	; we have a space so change to zero term for dict match later 
2057				;dec hl 
2057				;ld a,"-"	; TODO remove this when working 
2057				;ld (hl), a 
2057				;inc hl 
2057 18 ea			jr .cptokenstr2 
2059			 
2059			.cptokendone2: 
2059				;inc hl 
2059 3e 7f			ld a, FORTH_END_BUFFER 
205b 77				ld (hl),a 
205c 23				inc hl 
205d 3e 21			ld a, '!' 
205f 77				ld (hl),a 
2060			 
2060 2a a4 f2			ld hl,(os_tok_ptr) 
2063			         
2063			if DEBUG_FORTH_TOK 
2063						DMARK "Tc1" 
2063				CALLMONITOR 
2063			endif 
2063			 
2063				; push exec string to top of return stack 
2063				FORTH_RSP_NEXT 
2063 cd 57 1c			call macro_forth_rsp_next 
2066				endm 
# End of macro FORTH_RSP_NEXT
2066 c9				ret 
2067			 
2067			; Another go at the parser need to simplify the process 
2067			 
2067			forthparse: 
2067			 
2067			; 
2067			; line parse: 
2067			;       parse raw input buffer 
2067			;       tokenise the words 
2067			;       malloc new copy (for looping etc) 
2067			;       copy to malloc + current pc in line to start of string and add line term 
2067			;       save on new rsp 
2067			; 
2067			 
2067			; hl to point to the line to tokenise 
2067			 
2067			;	push hl 
2067 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
206a			 
206a			;	ld a,0		; string term on input 
206a			;	call strlent 
206a			 
206a			;	ld (os_tok_len), hl	 ; save string length 
206a			 
206a			;if DEBUG_FORTH_TOK 
206a			;	ex de,hl		 
206a			;endif 
206a			 
206a			;	pop hl 		; get back string pointer 
206a			 
206a			if DEBUG_FORTH_TOK 
206a						DMARK "TOK" 
206a				CALLMONITOR 
206a			endif 
206a 7e			.ptoken2:    ld a,(hl) 
206b 23				inc hl 
206c fe 7f			cp FORTH_END_BUFFER 
206e 28 29			jr z, .ptokendone2 
2070 fe 00			cp 0 
2072 28 25			jr z, .ptokendone2 
2074 fe 22			cp '"' 
2076 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2078 fe 20			cp ' ' 
207a 20 ee			jr nz,  .ptoken2 
207c			 
207c			; TODO consume comments held between ( and ) 
207c			 
207c				; we have a space so change to zero term for dict match later 
207c 2b				dec hl 
207d 3e 00			ld a,0 
207f 77				ld (hl), a 
2080 23				inc hl 
2081 18 e7			jr .ptoken2 
2083				 
2083			 
2083			.ptokenstr2: 
2083				; skip all white space until either eol (because forgot to term) or end double quote 
2083			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2083				;inc hl ; skip current double quote 
2083 7e				ld a,(hl) 
2084 23				inc hl 
2085 fe 22			cp '"' 
2087 28 e1			jr z, .ptoken2 
2089 fe 7f			cp FORTH_END_BUFFER 
208b 28 0c			jr z, .ptokendone2 
208d fe 00			cp 0 
208f 28 08			jr z, .ptokendone2 
2091 fe 20			cp ' ' 
2093 28 02			jr z, .ptmp2 
2095 18 ec			jr .ptokenstr2 
2097			 
2097			.ptmp2:	; we have a space so change to zero term for dict match later 
2097				;dec hl 
2097				;ld a,"-"	; TODO remove this when working 
2097				;ld (hl), a 
2097				;inc hl 
2097 18 ea			jr .ptokenstr2 
2099			 
2099			.ptokendone2: 
2099				;inc hl 
2099 3e 7f			ld a, FORTH_END_BUFFER 
209b 77				ld (hl),a 
209c 23				inc hl 
209d 3e 21			ld a, '!' 
209f 77				ld (hl),a 
20a0			 
20a0 2a a4 f2			ld hl,(os_tok_ptr) 
20a3			         
20a3			if DEBUG_FORTH_TOK 
20a3						DMARK "TK1" 
20a3				CALLMONITOR 
20a3			endif 
20a3			 
20a3				; push exec string to top of return stack 
20a3				FORTH_RSP_NEXT 
20a3 cd 57 1c			call macro_forth_rsp_next 
20a6				endm 
# End of macro FORTH_RSP_NEXT
20a6 c9				ret 
20a7			 
20a7			; 
20a7			;	; malloc size + buffer pointer + if is loop flag 
20a7			;	ld hl,(os_tok_len) 		 ; get string length 
20a7			; 
20a7			;	ld a,l 
20a7			; 
20a7			;	cp 0			; we dont want to use a null string 
20a7			;	ret z 
20a7			; 
20a7			;;	add 3    ; prefix malloc with buffer for current word ptr 
20a7			; 
20a7			;	add 5     ; TODO when certain not over writing memory remove 
20a7			; 
20a7			;		 
20a7			; 
20a7			;if DEBUG_FORTH_TOK 
20a7			;			DMARK "TKE" 
20a7			;	CALLMONITOR 
20a7			;endif 
20a7			; 
20a7			;	ld l,a 
20a7			;	ld h,0 
20a7			;;	push hl   ; save required space for the copy later 
20a7			;	call malloc 
20a7			;if DEBUG_FORTH_TOK 
20a7			;			DMARK "TKM" 
20a7			;	CALLMONITOR 
20a7			;endif 
20a7			;	if DEBUG_FORTH_MALLOC_GUARD 
20a7			;		push af 
20a7			;		call ishlzero 
20a7			;;		ld a, l 
20a7			;;		add h 
20a7			;;		cp 0 
20a7			;		pop af 
20a7			;		 
20a7			;		call z,malloc_error 
20a7			;	endif 
20a7			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20a7			; 
20a7			; 
20a7			;if DEBUG_FORTH_TOK 
20a7			;			DMARK "TKR" 
20a7			;	CALLMONITOR 
20a7			;endif 
20a7			; 
20a7			;	FORTH_RSP_NEXT 
20a7			; 
20a7			;	;inc hl	 ; go past current buffer pointer 
20a7			;	;inc hl 
20a7			;	;inc hl   ; and past if loop flag 
20a7			;		; TODO Need to set flag  
20a7			; 
20a7			;	 
20a7			;	 
20a7			;	ex de,hl	; malloc is dest 
20a7			;	ld hl, (os_tok_len) 
20a7			;;	pop bc 
20a7			;	ld c, l                
20a7			;	ld b,0 
20a7			;	ld hl, (os_tok_ptr) 
20a7			; 
20a7			;if DEBUG_FORTH_TOK 
20a7			;			DMARK "TKT" 
20a7			;	CALLMONITOR 
20a7			;endif 
20a7			; 
20a7			;	; do str cpy 
20a7			; 
20a7			;	ldir      ; copy byte in hl to de 
20a7			; 
20a7			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20a7			; 
20a7			;if DEBUG_FORTH_TOK 
20a7			; 
20a7			;			DMARK "TKY" 
20a7			;	CALLMONITOR 
20a7			;endif 
20a7			;	;ld a,0 
20a7			;	;ld a,FORTH_END_BUFFER 
20a7			;	ex de, hl 
20a7			;	;dec hl			 ; go back over the space delim at the end of word 
20a7			;	;ld (hl),a 
20a7			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20a7			;	ld a,FORTH_END_BUFFER 
20a7			;	ld (hl),a 
20a7			;	inc hl 
20a7			;	ld a,FORTH_END_BUFFER 
20a7			;	ld (hl),a 
20a7			; 
20a7			;	; init the malloc area data 
20a7			;	; set pc for in current area 
20a7			;	;ld hl, (os_tok_malloc) 
20a7			;	;inc hl 
20a7			;	;inc hl 
20a7			;	;inc hl 
20a7			;	;ex de,hl 
20a7			;	;ld hl, (os_tok_malloc) 
20a7			;	;ld (hl),e 
20a7			;	;inc hl 
20a7			;	;ld (hl),d 
20a7			; 
20a7			; 
20a7			;	ld hl,(os_tok_malloc) 
20a7			;if DEBUG_FORTH_PARSE_KEY 
20a7			;			DMARK "TKU" 
20a7			;	CALLMONITOR 
20a7			;endif 
20a7			; 
20a7			;	ret 
20a7			 
20a7			forthexec: 
20a7			 
20a7			; line exec: 
20a7			; forth parser 
20a7			 
20a7			; 
20a7			;       get current exec line on rsp 
20a7			 
20a7				FORTH_RSP_TOS 
20a7 cd 6e 1c			call macro_forth_rsp_tos 
20aa				endm 
# End of macro FORTH_RSP_TOS
20aa			 
20aa			;       restore current pc - hl points to malloc of data 
20aa			 
20aa				;ld e, (hl) 
20aa				;inc hl 
20aa				;ld d, (hl) 
20aa				;ex de,hl 
20aa			 
20aa			 
20aa			exec1: 
20aa 22 a4 f2			ld (os_tok_ptr), hl 
20ad			 
20ad				; copy our PC to working vars  
20ad 22 ae f9			ld (cli_ptr), hl 
20b0 22 ac f9			ld (cli_origptr), hl 
20b3			 
20b3 7e				ld a,(hl) 
20b4 fe 7f			cp FORTH_END_BUFFER 
20b6 c8				ret z 
20b7			 
20b7				; skip any nulls 
20b7			 
20b7 fe 00			cp 0 
20b9 20 03			jr nz, .execword 
20bb 23				inc hl 
20bc 18 ec			jr exec1 
20be			 
20be			 
20be			.execword: 
20be			 
20be			 
20be			 
20be			if DEBUG_FORTH_PARSE_KEY 
20be						DMARK "KYQ" 
20be				CALLMONITOR 
20be			endif 
20be			;       while at start of word: 
20be			; get start of dict (in user area first) 
20be			 
20be 21 00 80		ld hl, baseram 
20c1			;ld hl, sysdict 
20c1 22 b0 f9		ld (cli_nextword),hl 
20c4			;           match word at pc 
20c4			;           exec word 
20c4			;           or push to dsp 
20c4			;           forward to next token 
20c4			;           if line term pop rsp and exit 
20c4			;        
20c4			 
20c4			if DEBUG_FORTH_PARSE_KEY 
20c4						DMARK "KYq" 
20c4				CALLMONITOR 
20c4			endif 
20c4			 
20c4			; 
20c4			; word comp 
20c4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20c4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20c4			;    move to start of word  
20c4			;    compare word to cli_token 
20c4			 
20c4			.execpnword:	; HL at start of a word in the dictionary to check 
20c4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20c4			;	ld (cli_ptr), hl 
20c4			 
20c4 2a b0 f9			ld hl,(cli_nextword) 
20c7			 
20c7 cd 6a 21			call forth_tok_next 
20ca			; tok next start here 
20ca			;	; TODO skip compiled symbol for now 
20ca			;	inc hl 
20ca			; 
20ca			;	; save pointer to next word 
20ca			; 
20ca			;	; hl now points to the address of the next word pointer  
20ca			;	ld e, (hl) 
20ca			;	inc hl 
20ca			;	ld d, (hl) 
20ca			;	inc l 
20ca			; 
20ca			;	ex de,hl 
20ca			;if DEBUG_FORTH_PARSE_NEXTWORD 
20ca			;	push bc 
20ca			;	ld bc, (cli_nextword) 
20ca			;			DMARK "NXW" 
20ca			;	CALLMONITOR 
20ca			;	pop bc 
20ca			;endif 
20ca			; tok next end here 
20ca 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
20cd eb				ex de, hl 
20ce			 
20ce			 
20ce				; save the pointer of the current token - 1 to check against 
20ce				 
20ce 22 b4 f9			ld (cli_token), hl   
20d1				; TODO maybe remove below save if no debug 
20d1				; save token string ptr for any debug later 
20d1 23				inc hl  
20d2 22 b6 f9			ld (cli_origtoken), hl 
20d5 2b				dec hl 
20d6				; save pointer to the start of the next dictionay word 
20d6 7e				ld a,(hl)   ; get string length 
20d7 47				ld b,a 
20d8			.execpnwordinc:  
20d8 23				inc hl 
20d9 10 fd			djnz .execpnwordinc 
20db 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
20de			 
20de				; now check the word token against the string being parsed 
20de			 
20de 2a b4 f9			ld hl,(cli_token) 
20e1 23				inc hl     ; skip string length (use zero term instead to end) 
20e2 22 b4 f9			ld (cli_token), hl 
20e5			 
20e5			if DEBUG_FORTH_PARSE_KEY 
20e5						DMARK "KY2" 
20e5			endif 
20e5			if DEBUG_FORTH_PARSE_EXEC 
20e5				; see if disabled 
20e5			 
20e5				ld a, (os_view_disable) 
20e5				cp '*' 
20e5				jr z, .skip 
20e5			 
20e5				push hl 
20e5				push hl 
20e5				call clear_display 
20e5				ld de, .compword 
20e5				ld a, display_row_1 
20e5				call str_at_display 
20e5				pop de 
20e5				ld a, display_row_2 
20e5				call str_at_display 
20e5				ld hl,(cli_ptr) 
20e5				ld a,(hl) 
20e5			        ld hl, os_word_scratch 
20e5				ld (hl),a 
20e5				ld a,0 
20e5				inc hl 
20e5				ld (hl),a 	 
20e5				ld de, os_word_scratch 
20e5				ld a, display_row_2+10 
20e5				call str_at_display 
20e5				call update_display 
20e5				ld a, 100 
20e5				call aDelayInMS 
20e5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20e5				call delay250ms 
20e5				endif 
20e5				pop hl 
20e5			.skip:  
20e5			endif	 
20e5			.execpnchar:    ; compare char between token and string to parse 
20e5			 
20e5			if DEBUG_FORTH_PARSE_KEY 
20e5						DMARK "Ky3" 
20e5			endif 
20e5			if DEBUG_FORTH_PARSE_EXEC 
20e5				; see if disabled 
20e5			 
20e5				ld a, (os_view_disable) 
20e5				cp '*' 
20e5				jr z, .skip2 
20e5			 
20e5			;	call clear_display 
20e5			ld hl,(cli_token) 
20e5			ld a,(hl) 
20e5			ld (os_word_scratch),a 
20e5				ld hl,(cli_ptr) 
20e5			ld a,(hl) 
20e5				ld (os_word_scratch+1),a 
20e5				ld a,0 
20e5				ld (os_word_scratch+2),a 
20e5				ld de,os_word_scratch 
20e5				ld a,display_row_4 
20e5				call str_at_display 
20e5				call update_display 
20e5			.skip2:  
20e5			endif 
20e5 2a b4 f9			ld hl,(cli_token) 
20e8 7e				ld a, (hl)	 ; char in word token 
20e9 23				inc hl 		; move to next char 
20ea 22 b4 f9			ld (cli_token), hl ; and save it 
20ed 47				ld b,a 
20ee			 
20ee 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
20f1 7e				ld a,(hl) 
20f2 23				inc hl 
20f3 22 ae f9			ld (cli_ptr), hl		; move to next char 
20f6 cd 5b 11			call toUpper 		; make sure the input string matches case 
20f9			 
20f9			if DEBUG_FORTH_PARSE 
20f9			endif 
20f9			 
20f9				; input stream end of token is a space so get rid of it 
20f9			 
20f9			;	cp ' ' 
20f9			;	jr nz, .pnskipspace 
20f9			; 
20f9			;	ld a, 0		; make same term as word token term 
20f9			; 
20f9			;.pnskipspace: 
20f9			 
20f9			if DEBUG_FORTH_PARSE_KEY 
20f9						DMARK "KY7" 
20f9			endif 
20f9 b8				cp b 
20fa c2 10 21			jp nz, .execpnskipword	 ; no match so move to next word 
20fd				 
20fd			;    if same 
20fd			;       scan for string terms 0 for token and 32 for input 
20fd			 
20fd				 
20fd			if DEBUG_FORTH_PARSE_KEY 
20fd						DMARK "KY8" 
20fd			endif 
20fd			 
20fd 80				add b			 
20fe fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2100							; TODO need to make sure last word in zero term string is accounted for 
2100 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2102			 
2102			 
2102				; at end of both strings so both are exact match 
2102			 
2102			;       skip ptr for next word 
2102			 
2102 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
2105 23				inc hl			 ; at next char 
2106 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
2109 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
210c				 
210c				 
210c			if DEBUG_FORTH_PARSE_KEY 
210c						DMARK "KY3" 
210c			endif 
210c			 
210c			 
210c			 
210c			;       exec code block 
210c			if DEBUG_FORTH_JP 
210c				call clear_display 
210c				call update_display 
210c				call delay1s 
210c				ld hl, (cli_execword)     ; save for next check if no match on this word 
210c				ld a,h 
210c				ld hl, os_word_scratch 
210c				call hexout 
210c				ld hl, (cli_execword)     ; save for next check if no match on this word 
210c				ld a,l 
210c				ld hl, os_word_scratch+2 
210c				call hexout 
210c				ld hl, os_word_scratch+4 
210c				ld a,0 
210c				ld (hl),a 
210c				ld de,os_word_scratch 
210c				call str_at_display 
210c					ld a, display_row_2 
210c					call str_at_display 
210c				ld de, (cli_origtoken) 
210c				ld a, display_row_1+10 
210c					call str_at_display 
210c			 
210c				ld a,display_row_1 
210c				ld de, .foundword 
210c				ld a, display_row_3 
210c				call str_at_display 
210c				call update_display 
210c				call delay1s 
210c				call delay1s 
210c				call delay1s 
210c			endif 
210c			 
210c			if DEBUG_FORTH_PARSE_KEY 
210c						DMARK "KYj" 
210c			endif 
210c				; TODO save the word pointer in this exec 
210c			 
210c 2a b2 f9			ld hl,(cli_execword) 
210f e9				jp (hl) 
2110			 
2110			 
2110			;    if not same 
2110			;	scan for zero term 
2110			;	get ptr for next word 
2110			;	goto word comp 
2110			 
2110			.execpnskipword:	; get pointer to next word 
2110 2a b0 f9			ld hl,(cli_nextword) 
2113			 
2113 7e				ld a,(hl) 
2114 fe 00			cp WORD_SYS_END 
2116			;	cp 0 
2116 28 09			jr z, .execendofdict			 ; at end of words 
2118			 
2118			if DEBUG_FORTH_PARSE_KEY 
2118						DMARK "KY4" 
2118			endif 
2118			if DEBUG_FORTH_PARSE_EXEC 
2118			 
2118				; see if disabled 
2118			 
2118				ld a, (os_view_disable) 
2118				cp '*' 
2118				jr z, .noskip 
2118			 
2118			 
2118				ld de, .nowordfound 
2118				ld a, display_row_3 
2118				call str_at_display 
2118				call update_display 
2118				ld a, 100 
2118				call aDelayInMS 
2118				 
2118				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2118					call delay250ms 
2118				endif 
2118			.noskip:  
2118			 
2118			endif	 
2118			 
2118 2a ac f9			ld hl,(cli_origptr) 
211b 22 ae f9			ld (cli_ptr),hl 
211e			 
211e			if DEBUG_FORTH_PARSE_KEY 
211e						DMARK "KY5" 
211e			endif 
211e c3 c4 20			jp .execpnword			; else go to next word 
2121			 
2121			.execendofdict:  
2121			 
2121			if DEBUG_FORTH_PARSE_KEY 
2121						DMARK "KYe" 
2121			endif 
2121			if DEBUG_FORTH_PARSE_EXEC 
2121				; see if disabled 
2121			 
2121				ld a, (os_view_disable) 
2121				cp '*' 
2121				jr z, .ispskip 
2121			 
2121				call clear_display 
2121				call update_display 
2121				call delay1s 
2121				ld de, (cli_origptr) 
2121				ld a, display_row_1 
2121				call str_at_display 
2121				 
2121				ld de, .enddict 
2121				ld a, display_row_3 
2121				call str_at_display 
2121				call update_display 
2121				ld a, 100 
2121				call aDelayInMS 
2121				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2121				call delay1s 
2121				call delay1s 
2121				call delay1s 
2121				endif 
2121			.ispskip:  
2121				 
2121			endif	 
2121			 
2121			 
2121			 
2121				; if the word is not a keyword then must be a literal so push it to stack 
2121			 
2121			; push token to stack to end of word 
2121			 
2121				STACKFRAME ON $1efe $2f9f 
2121				if DEBUG_STACK_IMB 
2121					if ON 
2121						exx 
2121						ld de, $1efe 
2121						ld a, d 
2121						ld hl, curframe 
2121						call hexout 
2121						ld a, e 
2121						ld hl, curframe+2 
2121						call hexout 
2121						ld hl, $1efe 
2121						push hl 
2121						ld hl, $2f9f 
2121						push hl 
2121						exx 
2121					endif 
2121				endif 
2121			endm 
# End of macro STACKFRAME
2121			 
2121 2a a4 f2		ld hl,(os_tok_ptr) 
2124 cd 19 1e		call forth_apush 
2127			 
2127				STACKFRAMECHK ON $1efe $2f9f 
2127				if DEBUG_STACK_IMB 
2127					if ON 
2127						exx 
2127						ld hl, $2f9f 
2127						pop de   ; $2f9f 
2127						call cmp16 
2127						jr nz, .spnosame 
2127						ld hl, $1efe 
2127						pop de   ; $1efe 
2127						call cmp16 
2127						jr z, .spfrsame 
2127						.spnosame: call showsperror 
2127						.spfrsame: nop 
2127						exx 
2127					endif 
2127				endif 
2127			endm 
# End of macro STACKFRAMECHK
2127			 
2127			execnext: 
2127			 
2127			if DEBUG_FORTH_PARSE_KEY 
2127						DMARK "KY>" 
2127			endif 
2127			; move past token to next word 
2127			 
2127 2a a4 f2		ld hl, (os_tok_ptr) 
212a 3e 00		ld a, 0 
212c 01 ff 00		ld bc, 255     ; input buffer size 
212f ed b1		cpir 
2131			 
2131			if DEBUG_FORTH_PARSE_KEY 
2131						DMARK "KY!" 
2131				CALLMONITOR 
2131			endif	 
2131			; TODO this might place hl on the null, so will need to forward on??? 
2131			;inc hl   ; see if this gets onto the next item 
2131			 
2131			 
2131			; TODO pass a pointer to the buffer to push 
2131			; TODO call function to push 
2131			 
2131			; look for end of input 
2131			 
2131			;inc hl 
2131			;ld a,(hl) 
2131			;cp FORTH_END_BUFFER 
2131			;ret z 
2131			 
2131			 
2131 c3 aa 20		jp exec1 
2134			 
2134			 
2134			 
2134			 
2134			 
2134			 
2134			 
2134			 
2134			 
2134			findnexttok: 
2134			 
2134				; hl is pointer to move 
2134				; de is the token to locate 
2134			 
2134					if DEBUG_FORTH 
2134						DMARK "NTK" 
2134						CALLMONITOR 
2134					endif 
2134 d5				push de 
2135			 
2135			.fnt1:	 
2135				; find first char of token to locate 
2135			 
2135 1a				ld a, (de) 
2136 4f				ld c,a 
2137 7e				ld a,(hl) 
2138 cd 5b 11			call toUpper 
213b					if DEBUG_FORTH 
213b						DMARK "NT1" 
213b						CALLMONITOR 
213b					endif 
213b b9				cp c 
213c			 
213c 28 03			jr z, .fnt2cmpmorefirst	 
213e			 
213e				; first char not found move to next char 
213e			 
213e 23				inc hl 
213f 18 f4			jr .fnt1 
2141			 
2141			.fnt2cmpmorefirst:	 
2141				; first char of token found.  
2141			 
2141 e5				push hl     ; save start of token just in case it is the right one 
2142 d9				exx 
2143 e1				pop hl        ; save it to hl' 
2144 d9				exx 
2145			 
2145			 
2145			.fnt2cmpmore:	 
2145				; compare the rest 
2145				 
2145 23				inc hl 
2146 13				inc de 
2147				 
2147 1a				ld a, (de) 
2148 4f				ld c,a 
2149 7e				ld a,(hl) 
214a cd 5b 11			call toUpper 
214d			 
214d					if DEBUG_FORTH 
214d						DMARK "NT2" 
214d						CALLMONITOR 
214d					endif 
214d				; c has the token to find char 
214d				; a has the mem to scan char 
214d			 
214d b9				cp c 
214e 28 04			jr z,.fntmatch1 
2150			 
2150				; they are not the same 
2150			 
2150					if DEBUG_FORTH 
2150						DMARK "NT3" 
2150						CALLMONITOR 
2150					endif 
2150 d1				pop de	; reset de token to look for 
2151 d5				push de 
2152 18 e1			jr .fnt1 
2154				 
2154			.fntmatch1: 
2154			 
2154				; is the same char a null which means we might have a full hit? 
2154					if DEBUG_FORTH 
2154						DMARK "NT4" 
2154						CALLMONITOR 
2154					endif 
2154			 
2154 fe 00			cp 0 
2156 28 0b			jr z, .fntmatchyes 
2158			 
2158				; are we at the end of the token to find? 
2158			 
2158					if DEBUG_FORTH 
2158						DMARK "NT5" 
2158						CALLMONITOR 
2158					endif 
2158 3e 00			ld a, 0 
215a b9				cp c 
215b			 
215b c2 45 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
215e			 
215e					if DEBUG_FORTH 
215e						DMARK "NT6" 
215e						CALLMONITOR 
215e					endif 
215e				; token to find is exhusted but no match to stream 
215e			 
215e				; restore tok pointer and continue on 
215e d1				pop de 
215f d5				push de 
2160 c3 35 21			jp .fnt1 
2163			 
2163			 
2163			.fntmatchyes: 
2163			 
2163				; hl now contains the end of the found token 
2163			 
2163				; get rid of saved token pointer to find 
2163			 
2163 d1				pop de 
2164			 
2164					if DEBUG_FORTH 
2164						DMARK "NT9" 
2164						CALLMONITOR 
2164					endif 
2164			 
2164				; hl will be on the null term so forward on 
2164			 
2164				; get back the saved start of the token 
2164			 
2164 d9				exx 
2165 e5				push hl     ; save start of token just in case it is the right one 
2166 d9				exx 
2167 e1				pop hl        ; save it to hl 
2168			 
2168 c9				ret 
2169			 
2169			 
2169			; LIST needs to find a specific token   
2169			; FORGET needs to find a spefici token 
2169			 
2169			; SAVE needs to find all tokens by flag 
2169			; WORDS just needs to scan through all  by flag 
2169			; UWORDS needs to scan through all by flag 
2169			 
2169			 
2169			; given hl as pointer to start of dict look up string 
2169			; return hl as pointer to start of word block 
2169			; or 0 if not found 
2169			 
2169			forth_find_tok: 
2169 c9				ret 
216a			 
216a			; given hl as pointer to dict structure 
216a			; move to the next dict block structure 
216a			 
216a			forth_tok_next: 
216a				; hl now points to the address of the next word pointer  
216a				; TODO skip compiled symbol for now 
216a			;	push de 
216a 23				inc hl 
216b 5e				ld e, (hl) 
216c 23				inc hl 
216d 56				ld d, (hl) 
216e 23				inc hl 
216f			 
216f eb				ex de,hl 
2170			if DEBUG_FORTH_PARSE_NEXTWORD 
2170				push bc 
2170				ld bc, (cli_nextword) 
2170						DMARK "NXW" 
2170				CALLMONITOR 
2170				pop bc 
2170			endif 
2170			;	pop de	 
2170 c9				ret 
2171			 
2171			 
2171			 
2171			; eof 
# End of file forth_parserv5.asm
2171				include "forth_wordsv4.asm" 
2171			 
2171			; the core word dictionary v4 
2171			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2171			 
2171			; this is a linked list for each of the system words used 
2171			; user defined words will follow the same format but will be in ram 
2171			 
2171			 
2171			; 
2171			; 
2171			; define linked list: 
2171			; 
2171			; 1. compiled byte op code 
2171			; 2. len of text word 
2171			; 3. text word 
2171			; 4. ptr to next dictionary word 
2171			; 5. asm, calls etc for the word 
2171			; 
2171			;  if 1 == 0 then last word in dict  
2171			;   
2171			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2171			;  
2171			;  
2171			; create basic standard set of words 
2171			; 
2171			;  
2171			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2171			; 2DUP 2DROP 2SWAP  
2171			; @ C@ - get byte  
2171			; ! C! - store byte 
2171			; 0< true if less than zero 
2171			; 0= true if zero 
2171			; < >  
2171			; = true if same 
2171			; variables 
2171			 
2171			 
2171			; Hardware specific words I may need 
2171			; 
2171			; IN OUT  
2171			; calls to key util functions 
2171			; calls to hardward abstraction stuff 
2171			; easy control of frame buffers and lcd i/o 
2171			; keyboard  
2171			 
2171			 
2171			;DICT: macro 
2171			; op_code, len, word, next 
2171			;    word: 
2171			;    db op_code 
2171			;    ds word zero term 
2171			;    dw next 
2171			;    endm 
2171			 
2171			 
2171			 
2171			 
2171			; op code 1 is a flag for user define words which are to be handled differently 
2171			 
2171			 
2171			; 
2171			; 
2171			;    TODO on entry to a word this should be the expected environment 
2171			;    hl - tos value if number then held, if string this is the ptr 
2171			;    de -  
2171			 
2171			 
2171			; opcode ranges 
2171			; 0 - end of word dict 
2171			; 255 - user define words 
2171			 
2171			sysdict: 
2171			include "forth_opcodes.asm" 
2171			; op codes for forth keywords 
2171			; free to use code 0  
2171				OPCODE_HEAP: equ  1 
2171				OPCODE_EXEC: equ 2 
2171				OPCODE_DUP: equ 3 
2171				OPCODE_SWAP: equ 4 
2171				OPCODE_COLN: equ 5 
2171				OPCODE_SCOLN: equ 6 
2171				OPCODE_DROP: equ 7 
2171				OPCODE_DUP2: equ 8 
2171				OPCODE_DROP2: equ 9 
2171				OPCODE_SWAP2: equ 10 
2171				OPCODE_AT: equ 11 
2171				OPCODE_CAT: equ 12 
2171				OPCODE_BANG: equ 13 
2171				OPCODE_CBANG: equ 14 
2171				OPCODE_SCALL: equ 15 
2171				OPCODE_DEPTH: equ 16 
2171				OPCODE_OVER: equ 17 
2171				OPCODE_PAUSE: equ 18 
2171				OPCODE_PAUSES: equ 19 
2171				OPCODE_ROT: equ 20 
2171			;free to reuse	OPCODE_WORDS: equ 21 
2171			        OPCODE_NOT: equ 21 
2171				OPCODE_UWORDS: equ 22 
2171				OPCODE_BP: equ 23 
2171				OPCODE_MONITOR: equ 24  
2171				OPCODE_MALLOC: equ 25 
2171				OPCODE_FREE: equ 26 
2171				OPCODE_LIST: equ 27 
2171				OPCODE_FORGET: equ 28 
2171				OPCODE_NOP: equ 29 
2171				OPCODE_COMO: equ 30 
2171				OPCODE_COMC: equ 31 
2171			;free to reuse	OPCODE_ENDCORE: equ 32 
2171				OPCODE_AFTERSOUND: equ 33 
2171				OPCODE_GP2: equ 34 
2171				OPCODE_GP3: equ 35 
2171				OPCODE_GP4: equ 36 
2171				OPCODE_SIN: equ 37 
2171				OPCODE_SOUT: equ 38 
2171				OPCODE_SPIO: equ 39 
2171				OPCODE_SPICEH: equ 40 
2171				OPCODE_SPIOb: equ 41 
2171				OPCODE_SPII: equ 42 
2171				OPCODE_SESEL: equ 43 
2171				OPCODE_CARTDEV: equ 44 
2171			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2171				OPCODE_FB: equ 46 
2171				OPCODE_EMIT: equ 47 
2171				OPCODE_DOTH: equ 48 
2171				OPCODE_DOTF: equ 49 
2171				OPCODE_DOT: equ 50 
2171				OPCODE_CLS: equ 51 
2171				OPCODE_DRAW: equ 52 
2171				OPCODE_DUMP: equ 53 
2171				OPCODE_CDUMP: equ 54 
2171				OPCODE_DAT: equ 55 
2171				OPCODE_HOME: equ 56 
2171				OPCODE_SPACE: equ 57 
2171				OPCODE_SPACES: equ 58 
2171				OPCODE_SCROLL: equ 59 
2171				OPCODE_ATQ: equ 60 
2171				OPCODE_AUTODSP: equ 61 
2171				OPCODE_MENU: equ 62 
2171			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2171				OPCODE_THEN: equ 64 
2171				OPCODE_ELSE: equ 65 
2171				OPCODE_DO: equ 66 
2171				OPCODE_LOOP: equ 67 
2171				OPCODE_I: equ 68 
2171				OPCODE_DLOOP: equ 69  
2171				OPCODE_REPEAT: equ 70  
2171				OPCODE_UNTIL: equ 71 
2171				OPCODE_ENDFLOW: equ 72 
2171				OPCODE_WAITK: equ 73 
2171				OPCODE_ACCEPT: equ 74 
2171				OPCODE_EDIT: equ 75 
2171			;free to reuse	OPCODE_ENDKEY: equ 76 
2171				OPCODE_LZERO: equ 77 
2171				OPCODE_TZERO: equ 78 
2171				OPCODE_LESS: equ 79 
2171				OPCODE_GT: equ 80 
2171				OPCODE_EQUAL: equ 81  
2171			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2171				OPCODE_NEG: equ 83 
2171				OPCODE_DIV: equ 84 
2171				OPCODE_MUL: equ 85 
2171				OPCODE_MIN: equ 86 
2171				OPCODE_MAX: equ 87 
2171				OPCODE_RND16: equ 88 
2171				OPCODE_RND8: equ 89 
2171				OPCODE_RND: equ 90 
2171			;free to reuse	OPCODE_ENDMATHS: equ 91  
2171				OPCODE_BYNAME: equ 92 
2171				OPCODE_DIR: equ 93 
2171				OPCODE_SAVE: equ 94 
2171				OPCODE_LOAD: equ 95 
2171				OPCODE_BSAVE: equ 96 
2171				OPCODE_BLOAD: equ 97 
2171				OPCODE_SEO: equ 98  
2171				OPCODE_SEI: equ 99 
2171				OPCODE_SFREE: equ 100 
2171				OPCODE_SIZE: equ 101 
2171				OPCODE_CREATE: equ 102 
2171				OPCODE_APPEND: equ 103 
2171				OPCODE_SDEL: equ 104 
2171				OPCODE_OPEN: equ 105 
2171				OPCODE_READ: equ 106 
2171				OPCODE_EOF: equ 106 
2171				OPCODE_FORMAT: equ 107 
2171				OPCODE_LABEL: equ 108 
2171				OPCODE_LABELS: equ 109 
2171			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2171				OPCODE_UPPER: equ 111 
2171				OPCODE_LOWER: equ 112 
2171				OPCODE_SUBSTR: equ 113 
2171				OPCODE_LEFT: equ 114 
2171				OPCODE_RIGHT: equ 115 
2171				OPCODE_STR2NUM: equ 116 
2171				OPCODE_NUM2STR: equ 117 
2171				OPCODE_CONCAT: equ 118 
2171				OPCODE_FIND: equ 119 
2171				OPCODE_LEN: equ 120 
2171				OPCODE_CHAR: equ 121 
2171			; free to reuse	OPCODE_STRLEN: equ 122 
2171			; free to reuse	OPCODE_ENDSTR: equ 123 
2171				OPCODE_V0S: equ 124 
2171				OPCODE_V0Q: equ 125 
2171				OPCODE_V1S: equ 126 
2171				OPCODE_V1Q: equ 127 
2171				OPCODE_V2S: equ 128 
2171				OPCODE_V2Q: equ 129 
2171				OPCODE_V3S: equ 130 
2171				OPCODE_V3Q: equ 131 
2171			;free to reuse	OPCODE_END: equ 132 
2171				OPCODE_ZDUP: equ 133 
2171			 
2171			; eof 
# End of file forth_opcodes.asm
2171			 
2171			include "forth_words_core.asm" 
2171			 
2171			; | ## Core Words 
2171			 
2171			;if MALLOC_4 
2171			 
2171			.HEAP: 
2171				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2171 15				db WORD_SYS_CORE+OPCODE_HEAP             
2172 b0 21			dw .EXEC            
2174 05				db 4 + 1 
2175 .. 00			db "HEAP",0              
217a				endm 
# End of macro CWHEAD
217a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
217a			; | | u1 - Current number of bytes in the heap 
217a			; | | u2 - Remaining bytes left on the heap 
217a			; | |  
217a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
217a			 
217a			 
217a					if DEBUG_FORTH_WORDS_KEY 
217a						DMARK "HEP" 
217a f5				push af  
217b 3a 8f 21			ld a, (.dmark)  
217e 32 bd fb			ld (debug_mark),a  
2181 3a 90 21			ld a, (.dmark+1)  
2184 32 be fb			ld (debug_mark+1),a  
2187 3a 91 21			ld a, (.dmark+2)  
218a 32 bf fb			ld (debug_mark+2),a  
218d 18 03			jr .pastdmark  
218f ..			.dmark: db "HEP"  
2192 f1			.pastdmark: pop af  
2193			endm  
# End of macro DMARK
2193						CALLMONITOR 
2193 cd 20 17			call break_point_state  
2196				endm  
# End of macro CALLMONITOR
2196					endif 
2196 2a 0a 80				ld hl, (free_list )      
2199 11 0e 80				ld de, heap_start 
219c			 
219c ed 52				sbc hl, de  
219e			 
219e cd b0 1c				call forth_push_numhl 
21a1			 
21a1			 
21a1 ed 5b 0a 80			ld de, (free_list )      
21a5 21 89 ef				ld hl, heap_end 
21a8			 
21a8 ed 52				sbc hl, de 
21aa			 
21aa cd b0 1c				call forth_push_numhl 
21ad					 
21ad			 
21ad					 
21ad			 
21ad			 
21ad			 
21ad					NEXTW 
21ad c3 19 20			jp macro_next 
21b0				endm 
# End of macro NEXTW
21b0			;endif 
21b0			 
21b0			.EXEC: 
21b0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21b0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21b0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21b0			;; > > 
21b0			;; > >   
21b0			;	STACKFRAME OFF $5efe $5f9f 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS_KEY 
21b0			;			DMARK "EXE" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			; 
21b0			;	FORTH_DSP_VALUEHL 
21b0			; 
21b0			;	FORTH_DSP_POP 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX1" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;;	ld e,(hl) 
21b0			;;	inc hl 
21b0			;;	ld d,(hl) 
21b0			;;	ex de,hl 
21b0			; 
21b0			;;		if DEBUG_FORTH_WORDS 
21b0			;;			DMARK "EX2" 
21b0			;;			CALLMONITOR 
21b0			;;		endif 
21b0			;	push hl 
21b0			; 
21b0			;	;ld a, 0 
21b0			;	;ld a, FORTH_END_BUFFER 
21b0			;	call strlenz 
21b0			;	inc hl   ; include zero term to copy 
21b0			;	inc hl   ; include term 
21b0			;	inc hl   ; include term 
21b0			;	ld b,0 
21b0			;	ld c,l 
21b0			;	pop hl 
21b0			;	ld de, execscratch 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX3" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	ldir 
21b0			; 
21b0			; 
21b0			;	ld hl, execscratch 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EXe" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			; 
21b0			;	call forthparse 
21b0			;	call forthexec 
21b0			;;	call forthexec_cleanup 
21b0			;;	call forthparse 
21b0			;;	call forthexec 
21b0			; 
21b0			;	STACKFRAMECHK OFF $5efe $5f9f 
21b0			; 
21b0			;	; an immediate word so no need to process any more words 
21b0			;	ret 
21b0			;	NEXTW 
21b0			 
21b0			; dead code - old version  
21b0			;	FORTH_RSP_NEXT 
21b0			 
21b0			;  
21b0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21b0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21b0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21b0			;	push hl 
21b0			;	push de 
21b0			;	push bc 
21b0			; 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS_KEY 
21b0			;			DMARK "EXR" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			; 
21b0			; 
21b0			; 
21b0			;	;v5 FORTH_DSP_VALUE 
21b0			;	FORTH_DSP_VALUEHL 
21b0			; 
21b0			;	; TODO do string type checks 
21b0			; 
21b0			;;v5	inc hl   ; skip type 
21b0			; 
21b0			;	push hl  ; source code  
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX1" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	ld a, 0 
21b0			;	call strlent 
21b0			; 
21b0			;	inc hl 
21b0			;	inc hl 
21b0			;	inc hl 
21b0			;	inc hl 
21b0			; 
21b0			;	push hl    ; size 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX2" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	call malloc 
21b0			; 
21b0			;	ex de, hl    ; de now contains malloc area 
21b0			;	pop bc   	; get byte count 
21b0			;	pop hl      ; get string to copy 
21b0			; 
21b0			;	push de     ; save malloc for free later 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX3" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	ldir       ; duplicate string 
21b0			; 
21b0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21b0			;	 
21b0			;	; TODO fix the parse would be better than this...  
21b0			;	ex de, hl 
21b0			;	dec hl 
21b0			;	ld a, 0 
21b0			;	ld (hl), a 
21b0			;	dec hl 
21b0			;	ld a, ' ' 
21b0			;	ld (hl), a 
21b0			;	dec hl 
21b0			;	ld (hl), a 
21b0			; 
21b0			;	dec hl 
21b0			;	ld (hl), a 
21b0			; 
21b0			; 
21b0			;	FORTH_DSP_POP  
21b0			; 
21b0			;	pop hl     
21b0			;	push hl    ; save malloc area 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX4" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			; 
21b0			;	call forthparse 
21b0			;	call forthexec 
21b0			;	 
21b0			;	pop hl 
21b0			;	if DEBUG_FORTH_WORDS 
21b0			;		DMARK "EX5" 
21b0			;		CALLMONITOR 
21b0			;	endif 
21b0			; 
21b0			;	if FORTH_ENABLE_FREE 
21b0			;	call free 
21b0			;	endif 
21b0			; 
21b0			;	if DEBUG_FORTH_WORDS 
21b0			;		DMARK "EX6" 
21b0			;		CALLMONITOR 
21b0			;	endif 
21b0			; 
21b0			;	pop bc 
21b0			;	pop de 
21b0			;	pop hl 
21b0			;;	FORTH_RSP_POP	  
21b0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21b0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21b0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21b0			; 
21b0			;	if DEBUG_FORTH_WORDS 
21b0			;		DMARK "EX7" 
21b0			;		CALLMONITOR 
21b0			;	endif 
21b0			;	NEXTW 
21b0			 
21b0			;.STKEXEC: 
21b0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21b0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21b0			; 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS_KEY 
21b0			;			DMARK "STX" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			; 
21b0			;	FORTH_DSP_VALUEHL 
21b0			; 
21b0			;	ld (store_tmp1), hl    ; count 
21b0			; 
21b0			;	FORTH_DSP_POP 
21b0			;.stkexec1: 
21b0			;	ld hl, (store_tmp1)   ; count 
21b0			;	ld a, 0 
21b0			;	cp l 
21b0			;	ret z 
21b0			; 
21b0			;	dec hl 
21b0			;	ld (store_tmp1), hl    ; count 
21b0			;	 
21b0			;	FORTH_DSP_VALUEHL 
21b0			;	push hl 
21b0			;	 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EXp" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	FORTH_DSP_POP 
21b0			; 
21b0			;	call strlenz 
21b0			;	inc hl   ; include zero term to copy 
21b0			;	inc hl   ; include zero term to copy 
21b0			;	inc hl   ; include zero term to copy 
21b0			;	ld b,0 
21b0			;	ld c,l 
21b0			;	pop hl 
21b0			;	ld de, execscratch 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EX3" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	ldir 
21b0			; 
21b0			; 
21b0			;	ld hl, execscratch 
21b0			; 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EXP" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			; 
21b0			;	call forthparse 
21b0			;	ld hl, execscratch 
21b0			;		if DEBUG_FORTH_WORDS 
21b0			;			DMARK "EXx" 
21b0			;			CALLMONITOR 
21b0			;		endif 
21b0			;	call forthexec 
21b0			; 
21b0			;	jp .stkexec1 
21b0			; 
21b0			;	ret 
21b0			 
21b0			 
21b0			.DUP: 
21b0				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21b0 17				db WORD_SYS_CORE+OPCODE_DUP             
21b1 26 22			dw .ZDUP            
21b3 04				db 3 + 1 
21b4 .. 00			db "DUP",0              
21b8				endm 
# End of macro CWHEAD
21b8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21b8			 
21b8					if DEBUG_FORTH_WORDS_KEY 
21b8						DMARK "DUP" 
21b8 f5				push af  
21b9 3a cd 21			ld a, (.dmark)  
21bc 32 bd fb			ld (debug_mark),a  
21bf 3a ce 21			ld a, (.dmark+1)  
21c2 32 be fb			ld (debug_mark+1),a  
21c5 3a cf 21			ld a, (.dmark+2)  
21c8 32 bf fb			ld (debug_mark+2),a  
21cb 18 03			jr .pastdmark  
21cd ..			.dmark: db "DUP"  
21d0 f1			.pastdmark: pop af  
21d1			endm  
# End of macro DMARK
21d1						CALLMONITOR 
21d1 cd 20 17			call break_point_state  
21d4				endm  
# End of macro CALLMONITOR
21d4					endif 
21d4			 
21d4					FORTH_DSP 
21d4 cd 6d 1e			call macro_forth_dsp 
21d7				endm 
# End of macro FORTH_DSP
21d7			 
21d7 7e					ld a, (HL) 
21d8 fe 01				cp DS_TYPE_STR 
21da 20 25				jr nz, .dupinum 
21dc			 
21dc					; push another string 
21dc			 
21dc					FORTH_DSP_VALUEHL     		 
21dc cd a7 1e			call macro_dsp_valuehl 
21df				endm 
# End of macro FORTH_DSP_VALUEHL
21df			 
21df				if DEBUG_FORTH_WORDS 
21df					DMARK "DUs" 
21df f5				push af  
21e0 3a f4 21			ld a, (.dmark)  
21e3 32 bd fb			ld (debug_mark),a  
21e6 3a f5 21			ld a, (.dmark+1)  
21e9 32 be fb			ld (debug_mark+1),a  
21ec 3a f6 21			ld a, (.dmark+2)  
21ef 32 bf fb			ld (debug_mark+2),a  
21f2 18 03			jr .pastdmark  
21f4 ..			.dmark: db "DUs"  
21f7 f1			.pastdmark: pop af  
21f8			endm  
# End of macro DMARK
21f8					CALLMONITOR 
21f8 cd 20 17			call break_point_state  
21fb				endm  
# End of macro CALLMONITOR
21fb				endif 
21fb cd 1e 1d				call forth_push_str 
21fe			 
21fe					NEXTW 
21fe c3 19 20			jp macro_next 
2201				endm 
# End of macro NEXTW
2201			 
2201			 
2201			.dupinum: 
2201					 
2201			 
2201			 
2201					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2201 cd a7 1e			call macro_dsp_valuehl 
2204				endm 
# End of macro FORTH_DSP_VALUEHL
2204			 
2204				; TODO add floating point number detection 
2204			 
2204				if DEBUG_FORTH_WORDS 
2204					DMARK "DUi" 
2204 f5				push af  
2205 3a 19 22			ld a, (.dmark)  
2208 32 bd fb			ld (debug_mark),a  
220b 3a 1a 22			ld a, (.dmark+1)  
220e 32 be fb			ld (debug_mark+1),a  
2211 3a 1b 22			ld a, (.dmark+2)  
2214 32 bf fb			ld (debug_mark+2),a  
2217 18 03			jr .pastdmark  
2219 ..			.dmark: db "DUi"  
221c f1			.pastdmark: pop af  
221d			endm  
# End of macro DMARK
221d					CALLMONITOR 
221d cd 20 17			call break_point_state  
2220				endm  
# End of macro CALLMONITOR
2220				endif 
2220			 
2220 cd b0 1c				call forth_push_numhl 
2223					NEXTW 
2223 c3 19 20			jp macro_next 
2226				endm 
# End of macro NEXTW
2226			.ZDUP: 
2226				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2226 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2227 5e 22			dw .SWAP            
2229 05				db 4 + 1 
222a .. 00			db "?DUP",0              
222f				endm 
# End of macro CWHEAD
222f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
222f			 
222f					if DEBUG_FORTH_WORDS_KEY 
222f						DMARK "qDU" 
222f f5				push af  
2230 3a 44 22			ld a, (.dmark)  
2233 32 bd fb			ld (debug_mark),a  
2236 3a 45 22			ld a, (.dmark+1)  
2239 32 be fb			ld (debug_mark+1),a  
223c 3a 46 22			ld a, (.dmark+2)  
223f 32 bf fb			ld (debug_mark+2),a  
2242 18 03			jr .pastdmark  
2244 ..			.dmark: db "qDU"  
2247 f1			.pastdmark: pop af  
2248			endm  
# End of macro DMARK
2248						CALLMONITOR 
2248 cd 20 17			call break_point_state  
224b				endm  
# End of macro CALLMONITOR
224b					endif 
224b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
224b cd a7 1e			call macro_dsp_valuehl 
224e				endm 
# End of macro FORTH_DSP_VALUEHL
224e			 
224e e5					push hl 
224f			 
224f					; is it a zero? 
224f			 
224f 3e 00				ld a, 0 
2251 84					add h 
2252 85					add l 
2253			 
2253 e1					pop hl 
2254			 
2254 fe 00				cp 0 
2256 28 03				jr z, .dup2orig 
2258			 
2258			 
2258 cd b0 1c				call forth_push_numhl 
225b			 
225b			 
225b				; TODO add floating point number detection 
225b			 
225b			.dup2orig: 
225b			 
225b					NEXTW 
225b c3 19 20			jp macro_next 
225e				endm 
# End of macro NEXTW
225e			.SWAP: 
225e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
225e 18				db WORD_SYS_CORE+OPCODE_SWAP             
225f 9d 22			dw .COLN            
2261 05				db 4 + 1 
2262 .. 00			db "SWAP",0              
2267				endm 
# End of macro CWHEAD
2267			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2267					if DEBUG_FORTH_WORDS_KEY 
2267						DMARK "SWP" 
2267 f5				push af  
2268 3a 7c 22			ld a, (.dmark)  
226b 32 bd fb			ld (debug_mark),a  
226e 3a 7d 22			ld a, (.dmark+1)  
2271 32 be fb			ld (debug_mark+1),a  
2274 3a 7e 22			ld a, (.dmark+2)  
2277 32 bf fb			ld (debug_mark+2),a  
227a 18 03			jr .pastdmark  
227c ..			.dmark: db "SWP"  
227f f1			.pastdmark: pop af  
2280			endm  
# End of macro DMARK
2280						CALLMONITOR 
2280 cd 20 17			call break_point_state  
2283				endm  
# End of macro CALLMONITOR
2283					endif 
2283			 
2283					FORTH_DSP_VALUEHL 
2283 cd a7 1e			call macro_dsp_valuehl 
2286				endm 
# End of macro FORTH_DSP_VALUEHL
2286 e5					push hl     ; w2 
2287			 
2287					FORTH_DSP_POP 
2287 cd 5f 1f			call macro_forth_dsp_pop 
228a				endm 
# End of macro FORTH_DSP_POP
228a			 
228a					FORTH_DSP_VALUEHL 
228a cd a7 1e			call macro_dsp_valuehl 
228d				endm 
# End of macro FORTH_DSP_VALUEHL
228d			 
228d					FORTH_DSP_POP 
228d cd 5f 1f			call macro_forth_dsp_pop 
2290				endm 
# End of macro FORTH_DSP_POP
2290			 
2290 d1					pop de     ; w2	, hl = w1 
2291			 
2291 eb					ex de, hl 
2292 d5					push de 
2293			 
2293 cd b0 1c				call forth_push_numhl 
2296			 
2296 e1					pop hl 
2297			 
2297 cd b0 1c				call forth_push_numhl 
229a					 
229a			 
229a					NEXTW 
229a c3 19 20			jp macro_next 
229d				endm 
# End of macro NEXTW
229d			.COLN: 
229d				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
229d 19				db WORD_SYS_CORE+OPCODE_COLN             
229e 29 24			dw .SCOLN            
22a0 02				db 1 + 1 
22a1 .. 00			db ":",0              
22a3				endm 
# End of macro CWHEAD
22a3			; | : ( -- )         Create new word | DONE 
22a3			 
22a3					if DEBUG_FORTH_WORDS_KEY 
22a3						DMARK "CLN" 
22a3 f5				push af  
22a4 3a b8 22			ld a, (.dmark)  
22a7 32 bd fb			ld (debug_mark),a  
22aa 3a b9 22			ld a, (.dmark+1)  
22ad 32 be fb			ld (debug_mark+1),a  
22b0 3a ba 22			ld a, (.dmark+2)  
22b3 32 bf fb			ld (debug_mark+2),a  
22b6 18 03			jr .pastdmark  
22b8 ..			.dmark: db "CLN"  
22bb f1			.pastdmark: pop af  
22bc			endm  
# End of macro DMARK
22bc						CALLMONITOR 
22bc cd 20 17			call break_point_state  
22bf				endm  
# End of macro CALLMONITOR
22bf					endif 
22bf				STACKFRAME OFF $8efe $989f 
22bf				if DEBUG_STACK_IMB 
22bf					if OFF 
22bf						exx 
22bf						ld de, $8efe 
22bf						ld a, d 
22bf						ld hl, curframe 
22bf						call hexout 
22bf						ld a, e 
22bf						ld hl, curframe+2 
22bf						call hexout 
22bf						ld hl, $8efe 
22bf						push hl 
22bf						ld hl, $989f 
22bf						push hl 
22bf						exx 
22bf					endif 
22bf				endif 
22bf			endm 
# End of macro STACKFRAME
22bf				; get parser buffer length  of new word 
22bf			 
22bf				 
22bf			 
22bf					; move tok past this to start of name defintition 
22bf					; TODO get word to define 
22bf					; TODO Move past word token 
22bf					; TODO get length of string up to the ';' 
22bf			 
22bf 2a a4 f2			ld hl, (os_tok_ptr) 
22c2 23				inc hl 
22c3 23				inc hl 
22c4			 
22c4 3e 3b			ld a, ';' 
22c6 cd 6f 11			call strlent 
22c9			 
22c9 7d				ld a,l 
22ca 32 9f ef			ld (os_new_parse_len), a 
22cd			 
22cd			 
22cd			if DEBUG_FORTH_UWORD 
22cd ed 5b a4 f2		ld de, (os_tok_ptr) 
22d1						DMARK ":01" 
22d1 f5				push af  
22d2 3a e6 22			ld a, (.dmark)  
22d5 32 bd fb			ld (debug_mark),a  
22d8 3a e7 22			ld a, (.dmark+1)  
22db 32 be fb			ld (debug_mark+1),a  
22de 3a e8 22			ld a, (.dmark+2)  
22e1 32 bf fb			ld (debug_mark+2),a  
22e4 18 03			jr .pastdmark  
22e6 ..			.dmark: db ":01"  
22e9 f1			.pastdmark: pop af  
22ea			endm  
# End of macro DMARK
22ea				CALLMONITOR 
22ea cd 20 17			call break_point_state  
22ed				endm  
# End of macro CALLMONITOR
22ed			endif 
22ed			 
22ed			; 
22ed			;  new word memory layout: 
22ed			;  
22ed			;    : adg 6666 ;  
22ed			; 
22ed			;    db   1     ; user defined word  
22ed 23				inc hl    
22ee			;    dw   sysdict 
22ee 23				inc hl 
22ef 23				inc hl 
22f0			;    db <word len>+1 (for null) 
22f0 23				inc hl 
22f1			;    db .... <word> 
22f1			; 
22f1			 
22f1 23				inc hl    ; some extras for the word preamble before the above 
22f2 23				inc hl 
22f3 23				inc hl 
22f4 23				inc hl 
22f5 23				inc hl 
22f6 23				inc hl 
22f7 23				inc hl  
22f8 23				inc hl 
22f9 23				inc hl 
22fa 23				inc hl 
22fb 23				inc hl 
22fc 23				inc hl 
22fd 23				inc hl 
22fe 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22ff			;       exec word buffer 
22ff			;	<ptr word>   
22ff 23				inc hl 
2300 23				inc hl 
2301			;       <word list><null term> 7F final term 
2301			 
2301			 
2301			if DEBUG_FORTH_UWORD 
2301						DMARK ":02" 
2301 f5				push af  
2302 3a 16 23			ld a, (.dmark)  
2305 32 bd fb			ld (debug_mark),a  
2308 3a 17 23			ld a, (.dmark+1)  
230b 32 be fb			ld (debug_mark+1),a  
230e 3a 18 23			ld a, (.dmark+2)  
2311 32 bf fb			ld (debug_mark+2),a  
2314 18 03			jr .pastdmark  
2316 ..			.dmark: db ":02"  
2319 f1			.pastdmark: pop af  
231a			endm  
# End of macro DMARK
231a				CALLMONITOR 
231a cd 20 17			call break_point_state  
231d				endm  
# End of macro CALLMONITOR
231d			endif 
231d			 
231d				 
231d					; malloc the size 
231d			 
231d cd cd 11				call malloc 
2320 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
2323			 
2323			;    db   1     ; user defined word  
2323 3e 01				ld a, WORD_SYS_UWORD  
2325 77					ld (hl), a 
2326				 
2326 23				inc hl    
2327			;    dw   sysdict 
2327 11 71 21			ld de, sysdict       ; continue on with the scan to the system dict 
232a 73				ld (hl), e 
232b 23				inc hl 
232c 72				ld (hl), d 
232d 23				inc hl 
232e			 
232e			 
232e			;    Setup dict word 
232e			 
232e 23				inc hl 
232f 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
2332			 
2332				; 1. get length of dict word 
2332			 
2332			 
2332 2a a4 f2			ld hl, (os_tok_ptr) 
2335 23				inc hl 
2336 23				inc hl    ; position to start of dict word 
2337 3e 00			ld a, 0 
2339 cd 6f 11			call strlent 
233c			 
233c			 
233c 23				inc hl    ; to include null??? 
233d			 
233d				; write length of dict word 
233d			 
233d ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2341 1b				dec de 
2342 eb				ex de, hl 
2343 73				ld (hl), e 
2344 eb				ex de, hl 
2345			 
2345				 
2345			 
2345				; copy  
2345 4d				ld c, l 
2346 06 00			ld b, 0 
2348 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
234c 2a a4 f2			ld hl, (os_tok_ptr) 
234f 23				inc hl 
2350 23				inc hl    ; position to start of dict word 
2351				 
2351			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2351				 
2351				; TODO need to convert word to upper case 
2351			 
2351			ucasetok:	 
2351 7e				ld a,(hl) 
2352 cd 5b 11			call toUpper 
2355 77				ld (hl),a 
2356 ed a0			ldi 
2358 f2 51 23		 	jp p, ucasetok 
235b			 
235b			 
235b			 
235b				; de now points to start of where the word body code should be placed 
235b ed 53 9b ef		ld (os_new_work_ptr), de 
235f				; hl now points to the words to throw at forthexec which needs to be copied 
235f 22 99 ef			ld (os_new_src_ptr), hl 
2362			 
2362				; TODO add 'call to forthexec' 
2362			 
2362			if DEBUG_FORTH_UWORD 
2362 c5				push bc 
2363 ed 4b a1 ef		ld bc, (os_new_malloc) 
2367						DMARK ":0x" 
2367 f5				push af  
2368 3a 7c 23			ld a, (.dmark)  
236b 32 bd fb			ld (debug_mark),a  
236e 3a 7d 23			ld a, (.dmark+1)  
2371 32 be fb			ld (debug_mark+1),a  
2374 3a 7e 23			ld a, (.dmark+2)  
2377 32 bf fb			ld (debug_mark+2),a  
237a 18 03			jr .pastdmark  
237c ..			.dmark: db ":0x"  
237f f1			.pastdmark: pop af  
2380			endm  
# End of macro DMARK
2380				CALLMONITOR 
2380 cd 20 17			call break_point_state  
2383				endm  
# End of macro CALLMONITOR
2383 c1				pop bc 
2384			endif 
2384			 
2384			 
2384				; create word preamble which should be: 
2384			 
2384			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2384			 
2384				;    ld hl, <word code> 
2384				;    jp user_exec 
2384			        ;    <word code bytes> 
2384			 
2384			 
2384			;	inc de     ; TODO ??? or are we already past the word's null 
2384 eb				ex de, hl 
2385			 
2385 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2387			 
2387 23				inc hl 
2388 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
238b 23				inc hl 
238c			 
238c 23				inc hl 
238d 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
238f			 
238f 01 6c 50			ld bc, user_exec 
2392 23				inc hl 
2393 71				ld (hl), c     ; poke address of user_exec 
2394 23				inc hl 
2395 70				ld (hl), b     
2396			 ; 
2396			;	inc hl 
2396			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2396			; 
2396			; 
2396			;	ld bc, macro_forth_rsp_next 
2396			;	inc hl 
2396			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2396			;	inc hl 
2396			;	ld (hl), b     
2396			 ; 
2396			;	inc hl 
2396			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2396			; 
2396			; 
2396			;	inc hl 
2396			;	ld bc, forthexec 
2396			;	ld (hl), c     ; poke address of forthexec 
2396			;	inc hl 
2396			;	ld (hl), b      
2396			; 
2396			;	inc hl 
2396			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2396			; 
2396			;	ld bc, user_dict_next 
2396			;	inc hl 
2396			;	ld (hl), c     ; poke address of forthexec 
2396			;	inc hl 
2396			;	ld (hl), b      
2396			 
2396				; hl is now where we need to copy the word byte data to save this 
2396			 
2396 23				inc hl 
2397 22 97 ef			ld (os_new_exec), hl 
239a				 
239a				; copy definition 
239a			 
239a eb				ex de, hl 
239b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
239b			;	inc de    ; skip the PC for this parse 
239b 3a 9f ef			ld a, (os_new_parse_len) 
239e 4f				ld c, a 
239f 06 00			ld b, 0 
23a1 ed b0			ldir		 ; copy defintion 
23a3			 
23a3			 
23a3				; poke the address of where the new word bytes live for forthexec 
23a3			 
23a3 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23a6			 
23a6 ed 5b 97 ef		ld de, (os_new_exec)      
23aa				 
23aa 73				ld (hl), e 
23ab 23				inc hl 
23ac 72				ld (hl), d 
23ad			 
23ad					; TODO copy last user dict word next link to this word 
23ad					; TODO update last user dict word to point to this word 
23ad			; 
23ad			; hl f923 de 812a ; bc 811a 
23ad			 
23ad			if DEBUG_FORTH_UWORD 
23ad c5				push bc 
23ae ed 4b a1 ef		ld bc, (os_new_malloc) 
23b2						DMARK ":0A" 
23b2 f5				push af  
23b3 3a c7 23			ld a, (.dmark)  
23b6 32 bd fb			ld (debug_mark),a  
23b9 3a c8 23			ld a, (.dmark+1)  
23bc 32 be fb			ld (debug_mark+1),a  
23bf 3a c9 23			ld a, (.dmark+2)  
23c2 32 bf fb			ld (debug_mark+2),a  
23c5 18 03			jr .pastdmark  
23c7 ..			.dmark: db ":0A"  
23ca f1			.pastdmark: pop af  
23cb			endm  
# End of macro DMARK
23cb				CALLMONITOR 
23cb cd 20 17			call break_point_state  
23ce				endm  
# End of macro CALLMONITOR
23ce c1				pop bc 
23cf			endif 
23cf			if DEBUG_FORTH_UWORD 
23cf c5				push bc 
23d0 ed 4b a1 ef		ld bc, (os_new_malloc) 
23d4 03				inc bc 
23d5 03				inc bc 
23d6 03				inc bc 
23d7 03				inc bc 
23d8 03				inc bc 
23d9 03				inc bc 
23da 03				inc bc 
23db 03				inc bc 
23dc			 
23dc						DMARK ":0B" 
23dc f5				push af  
23dd 3a f1 23			ld a, (.dmark)  
23e0 32 bd fb			ld (debug_mark),a  
23e3 3a f2 23			ld a, (.dmark+1)  
23e6 32 be fb			ld (debug_mark+1),a  
23e9 3a f3 23			ld a, (.dmark+2)  
23ec 32 bf fb			ld (debug_mark+2),a  
23ef 18 03			jr .pastdmark  
23f1 ..			.dmark: db ":0B"  
23f4 f1			.pastdmark: pop af  
23f5			endm  
# End of macro DMARK
23f5				CALLMONITOR 
23f5 cd 20 17			call break_point_state  
23f8				endm  
# End of macro CALLMONITOR
23f8 c1				pop bc 
23f9			endif 
23f9			 
23f9			; update word dict linked list for new word 
23f9			 
23f9			 
23f9 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23fc 23			inc hl     ; move to next work linked list ptr 
23fd			 
23fd ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
2401 73			ld (hl), e 
2402 23			inc hl 
2403 72			ld (hl), d 
2404			 
2404			if DEBUG_FORTH_UWORD 
2404 ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2408			endif 
2408			 
2408 ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
240c			 
240c			 
240c			if DEBUG_FORTH_UWORD 
240c						DMARK ":0+" 
240c f5				push af  
240d 3a 21 24			ld a, (.dmark)  
2410 32 bd fb			ld (debug_mark),a  
2413 3a 22 24			ld a, (.dmark+1)  
2416 32 be fb			ld (debug_mark+1),a  
2419 3a 23 24			ld a, (.dmark+2)  
241c 32 bf fb			ld (debug_mark+2),a  
241f 18 03			jr .pastdmark  
2421 ..			.dmark: db ":0+"  
2424 f1			.pastdmark: pop af  
2425			endm  
# End of macro DMARK
2425				CALLMONITOR 
2425 cd 20 17			call break_point_state  
2428				endm  
# End of macro CALLMONITOR
2428			endif 
2428			 
2428				STACKFRAMECHK OFF $8efe $989f 
2428				if DEBUG_STACK_IMB 
2428					if OFF 
2428						exx 
2428						ld hl, $989f 
2428						pop de   ; $989f 
2428						call cmp16 
2428						jr nz, .spnosame 
2428						ld hl, $8efe 
2428						pop de   ; $8efe 
2428						call cmp16 
2428						jr z, .spfrsame 
2428						.spnosame: call showsperror 
2428						.spfrsame: nop 
2428						exx 
2428					endif 
2428				endif 
2428			endm 
# End of macro STACKFRAMECHK
2428			 
2428 c9			ret    ; dont process any remaining parser tokens as they form new word 
2429			 
2429			 
2429			 
2429			 
2429			;		NEXT 
2429			.SCOLN: 
2429			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2429 06				db OPCODE_SCOLN 
242a 75 24			dw .DROP 
242c 02				db 2 
242d .. 00			db ";",0           
242f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
242f					if DEBUG_FORTH_WORDS_KEY 
242f						DMARK "SCN" 
242f f5				push af  
2430 3a 44 24			ld a, (.dmark)  
2433 32 bd fb			ld (debug_mark),a  
2436 3a 45 24			ld a, (.dmark+1)  
2439 32 be fb			ld (debug_mark+1),a  
243c 3a 46 24			ld a, (.dmark+2)  
243f 32 bf fb			ld (debug_mark+2),a  
2442 18 03			jr .pastdmark  
2444 ..			.dmark: db "SCN"  
2447 f1			.pastdmark: pop af  
2448			endm  
# End of macro DMARK
2448						CALLMONITOR 
2448 cd 20 17			call break_point_state  
244b				endm  
# End of macro CALLMONITOR
244b					endif 
244b					FORTH_RSP_TOS 
244b cd 6e 1c			call macro_forth_rsp_tos 
244e				endm 
# End of macro FORTH_RSP_TOS
244e e5					push hl 
244f					FORTH_RSP_POP 
244f cd 78 1c			call macro_forth_rsp_pop 
2452				endm 
# End of macro FORTH_RSP_POP
2452 e1					pop hl 
2453			;		ex de,hl 
2453 22 a4 f2				ld (os_tok_ptr),hl 
2456			 
2456			if DEBUG_FORTH_UWORD 
2456						DMARK "SCL" 
2456 f5				push af  
2457 3a 6b 24			ld a, (.dmark)  
245a 32 bd fb			ld (debug_mark),a  
245d 3a 6c 24			ld a, (.dmark+1)  
2460 32 be fb			ld (debug_mark+1),a  
2463 3a 6d 24			ld a, (.dmark+2)  
2466 32 bf fb			ld (debug_mark+2),a  
2469 18 03			jr .pastdmark  
246b ..			.dmark: db "SCL"  
246e f1			.pastdmark: pop af  
246f			endm  
# End of macro DMARK
246f				CALLMONITOR 
246f cd 20 17			call break_point_state  
2472				endm  
# End of macro CALLMONITOR
2472			endif 
2472					NEXTW 
2472 c3 19 20			jp macro_next 
2475				endm 
# End of macro NEXTW
2475			 
2475			.DROP: 
2475				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2475 1b				db WORD_SYS_CORE+OPCODE_DROP             
2476 a0 24			dw .DUP2            
2478 05				db 4 + 1 
2479 .. 00			db "DROP",0              
247e				endm 
# End of macro CWHEAD
247e			; | DROP ( w -- )   drop the TOS item   | DONE 
247e					if DEBUG_FORTH_WORDS_KEY 
247e						DMARK "DRP" 
247e f5				push af  
247f 3a 93 24			ld a, (.dmark)  
2482 32 bd fb			ld (debug_mark),a  
2485 3a 94 24			ld a, (.dmark+1)  
2488 32 be fb			ld (debug_mark+1),a  
248b 3a 95 24			ld a, (.dmark+2)  
248e 32 bf fb			ld (debug_mark+2),a  
2491 18 03			jr .pastdmark  
2493 ..			.dmark: db "DRP"  
2496 f1			.pastdmark: pop af  
2497			endm  
# End of macro DMARK
2497						CALLMONITOR 
2497 cd 20 17			call break_point_state  
249a				endm  
# End of macro CALLMONITOR
249a					endif 
249a					FORTH_DSP_POP 
249a cd 5f 1f			call macro_forth_dsp_pop 
249d				endm 
# End of macro FORTH_DSP_POP
249d					NEXTW 
249d c3 19 20			jp macro_next 
24a0				endm 
# End of macro NEXTW
24a0			.DUP2: 
24a0				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24a0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24a1 e5 24			dw .DROP2            
24a3 05				db 4 + 1 
24a4 .. 00			db "2DUP",0              
24a9				endm 
# End of macro CWHEAD
24a9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24a9					if DEBUG_FORTH_WORDS_KEY 
24a9						DMARK "2DU" 
24a9 f5				push af  
24aa 3a be 24			ld a, (.dmark)  
24ad 32 bd fb			ld (debug_mark),a  
24b0 3a bf 24			ld a, (.dmark+1)  
24b3 32 be fb			ld (debug_mark+1),a  
24b6 3a c0 24			ld a, (.dmark+2)  
24b9 32 bf fb			ld (debug_mark+2),a  
24bc 18 03			jr .pastdmark  
24be ..			.dmark: db "2DU"  
24c1 f1			.pastdmark: pop af  
24c2			endm  
# End of macro DMARK
24c2						CALLMONITOR 
24c2 cd 20 17			call break_point_state  
24c5				endm  
# End of macro CALLMONITOR
24c5					endif 
24c5					FORTH_DSP_VALUEHL 
24c5 cd a7 1e			call macro_dsp_valuehl 
24c8				endm 
# End of macro FORTH_DSP_VALUEHL
24c8 e5					push hl      ; 2 
24c9			 
24c9					FORTH_DSP_POP 
24c9 cd 5f 1f			call macro_forth_dsp_pop 
24cc				endm 
# End of macro FORTH_DSP_POP
24cc					 
24cc					FORTH_DSP_VALUEHL 
24cc cd a7 1e			call macro_dsp_valuehl 
24cf				endm 
# End of macro FORTH_DSP_VALUEHL
24cf			;		push hl      ; 1 
24cf			 
24cf					FORTH_DSP_POP 
24cf cd 5f 1f			call macro_forth_dsp_pop 
24d2				endm 
# End of macro FORTH_DSP_POP
24d2			 
24d2			;		pop hl       ; 1 
24d2 d1					pop de       ; 2 
24d3			 
24d3 cd b0 1c				call forth_push_numhl 
24d6 eb					ex de, hl 
24d7 cd b0 1c				call forth_push_numhl 
24da			 
24da					 
24da eb					ex de, hl 
24db			 
24db cd b0 1c				call forth_push_numhl 
24de eb					ex de, hl 
24df cd b0 1c				call forth_push_numhl 
24e2			 
24e2			 
24e2					NEXTW 
24e2 c3 19 20			jp macro_next 
24e5				endm 
# End of macro NEXTW
24e5			.DROP2: 
24e5				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24e5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24e6 14 25			dw .SWAP2            
24e8 06				db 5 + 1 
24e9 .. 00			db "2DROP",0              
24ef				endm 
# End of macro CWHEAD
24ef			; | 2DROP ( w w -- )    Double drop | DONE 
24ef					if DEBUG_FORTH_WORDS_KEY 
24ef						DMARK "2DR" 
24ef f5				push af  
24f0 3a 04 25			ld a, (.dmark)  
24f3 32 bd fb			ld (debug_mark),a  
24f6 3a 05 25			ld a, (.dmark+1)  
24f9 32 be fb			ld (debug_mark+1),a  
24fc 3a 06 25			ld a, (.dmark+2)  
24ff 32 bf fb			ld (debug_mark+2),a  
2502 18 03			jr .pastdmark  
2504 ..			.dmark: db "2DR"  
2507 f1			.pastdmark: pop af  
2508			endm  
# End of macro DMARK
2508						CALLMONITOR 
2508 cd 20 17			call break_point_state  
250b				endm  
# End of macro CALLMONITOR
250b					endif 
250b					FORTH_DSP_POP 
250b cd 5f 1f			call macro_forth_dsp_pop 
250e				endm 
# End of macro FORTH_DSP_POP
250e					FORTH_DSP_POP 
250e cd 5f 1f			call macro_forth_dsp_pop 
2511				endm 
# End of macro FORTH_DSP_POP
2511					NEXTW 
2511 c3 19 20			jp macro_next 
2514				endm 
# End of macro NEXTW
2514			.SWAP2: 
2514				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2514 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2515 3d 25			dw .AT            
2517 06				db 5 + 1 
2518 .. 00			db "2SWAP",0              
251e				endm 
# End of macro CWHEAD
251e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
251e					if DEBUG_FORTH_WORDS_KEY 
251e						DMARK "2SW" 
251e f5				push af  
251f 3a 33 25			ld a, (.dmark)  
2522 32 bd fb			ld (debug_mark),a  
2525 3a 34 25			ld a, (.dmark+1)  
2528 32 be fb			ld (debug_mark+1),a  
252b 3a 35 25			ld a, (.dmark+2)  
252e 32 bf fb			ld (debug_mark+2),a  
2531 18 03			jr .pastdmark  
2533 ..			.dmark: db "2SW"  
2536 f1			.pastdmark: pop af  
2537			endm  
# End of macro DMARK
2537						CALLMONITOR 
2537 cd 20 17			call break_point_state  
253a				endm  
# End of macro CALLMONITOR
253a					endif 
253a					NEXTW 
253a c3 19 20			jp macro_next 
253d				endm 
# End of macro NEXTW
253d			.AT: 
253d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
253d 1f				db WORD_SYS_CORE+OPCODE_AT             
253e 6f 25			dw .CAT            
2540 02				db 1 + 1 
2541 .. 00			db "@",0              
2543				endm 
# End of macro CWHEAD
2543			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2543			 
2543					if DEBUG_FORTH_WORDS_KEY 
2543						DMARK "AT." 
2543 f5				push af  
2544 3a 58 25			ld a, (.dmark)  
2547 32 bd fb			ld (debug_mark),a  
254a 3a 59 25			ld a, (.dmark+1)  
254d 32 be fb			ld (debug_mark+1),a  
2550 3a 5a 25			ld a, (.dmark+2)  
2553 32 bf fb			ld (debug_mark+2),a  
2556 18 03			jr .pastdmark  
2558 ..			.dmark: db "AT."  
255b f1			.pastdmark: pop af  
255c			endm  
# End of macro DMARK
255c						CALLMONITOR 
255c cd 20 17			call break_point_state  
255f				endm  
# End of macro CALLMONITOR
255f					endif 
255f			.getbyteat:	 
255f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
255f cd a7 1e			call macro_dsp_valuehl 
2562				endm 
# End of macro FORTH_DSP_VALUEHL
2562					 
2562			;		push hl 
2562				 
2562					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2562 cd 5f 1f			call macro_forth_dsp_pop 
2565				endm 
# End of macro FORTH_DSP_POP
2565			 
2565			;		pop hl 
2565			 
2565 7e					ld a, (hl) 
2566			 
2566 6f					ld l, a 
2567 26 00				ld h, 0 
2569 cd b0 1c				call forth_push_numhl 
256c			 
256c					NEXTW 
256c c3 19 20			jp macro_next 
256f				endm 
# End of macro NEXTW
256f			.CAT: 
256f				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
256f 20				db WORD_SYS_CORE+OPCODE_CAT             
2570 98 25			dw .BANG            
2572 03				db 2 + 1 
2573 .. 00			db "C@",0              
2576				endm 
# End of macro CWHEAD
2576			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2576					if DEBUG_FORTH_WORDS_KEY 
2576						DMARK "CAA" 
2576 f5				push af  
2577 3a 8b 25			ld a, (.dmark)  
257a 32 bd fb			ld (debug_mark),a  
257d 3a 8c 25			ld a, (.dmark+1)  
2580 32 be fb			ld (debug_mark+1),a  
2583 3a 8d 25			ld a, (.dmark+2)  
2586 32 bf fb			ld (debug_mark+2),a  
2589 18 03			jr .pastdmark  
258b ..			.dmark: db "CAA"  
258e f1			.pastdmark: pop af  
258f			endm  
# End of macro DMARK
258f						CALLMONITOR 
258f cd 20 17			call break_point_state  
2592				endm  
# End of macro CALLMONITOR
2592					endif 
2592 c3 5f 25				jp .getbyteat 
2595					NEXTW 
2595 c3 19 20			jp macro_next 
2598				endm 
# End of macro NEXTW
2598			.BANG: 
2598				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2598 21				db WORD_SYS_CORE+OPCODE_BANG             
2599 ce 25			dw .CBANG            
259b 02				db 1 + 1 
259c .. 00			db "!",0              
259e				endm 
# End of macro CWHEAD
259e			; | ! ( x w -- ) Store x at address w      | DONE 
259e					if DEBUG_FORTH_WORDS_KEY 
259e						DMARK "BNG" 
259e f5				push af  
259f 3a b3 25			ld a, (.dmark)  
25a2 32 bd fb			ld (debug_mark),a  
25a5 3a b4 25			ld a, (.dmark+1)  
25a8 32 be fb			ld (debug_mark+1),a  
25ab 3a b5 25			ld a, (.dmark+2)  
25ae 32 bf fb			ld (debug_mark+2),a  
25b1 18 03			jr .pastdmark  
25b3 ..			.dmark: db "BNG"  
25b6 f1			.pastdmark: pop af  
25b7			endm  
# End of macro DMARK
25b7						CALLMONITOR 
25b7 cd 20 17			call break_point_state  
25ba				endm  
# End of macro CALLMONITOR
25ba					endif 
25ba			 
25ba			.storebyteat:		 
25ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ba cd a7 1e			call macro_dsp_valuehl 
25bd				endm 
# End of macro FORTH_DSP_VALUEHL
25bd					 
25bd e5					push hl 
25be				 
25be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25be cd 5f 1f			call macro_forth_dsp_pop 
25c1				endm 
# End of macro FORTH_DSP_POP
25c1			 
25c1					; get byte to poke 
25c1			 
25c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c1 cd a7 1e			call macro_dsp_valuehl 
25c4				endm 
# End of macro FORTH_DSP_VALUEHL
25c4 e5					push hl 
25c5			 
25c5			 
25c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25c5 cd 5f 1f			call macro_forth_dsp_pop 
25c8				endm 
# End of macro FORTH_DSP_POP
25c8			 
25c8			 
25c8 d1					pop de 
25c9 e1					pop hl 
25ca			 
25ca 73					ld (hl),e 
25cb			 
25cb			 
25cb					NEXTW 
25cb c3 19 20			jp macro_next 
25ce				endm 
# End of macro NEXTW
25ce			.CBANG: 
25ce				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25ce 22				db WORD_SYS_CORE+OPCODE_CBANG             
25cf f7 25			dw .SCALL            
25d1 03				db 2 + 1 
25d2 .. 00			db "C!",0              
25d5				endm 
# End of macro CWHEAD
25d5			; | C!  ( x w -- ) Store x at address w  | DONE 
25d5					if DEBUG_FORTH_WORDS_KEY 
25d5						DMARK "CBA" 
25d5 f5				push af  
25d6 3a ea 25			ld a, (.dmark)  
25d9 32 bd fb			ld (debug_mark),a  
25dc 3a eb 25			ld a, (.dmark+1)  
25df 32 be fb			ld (debug_mark+1),a  
25e2 3a ec 25			ld a, (.dmark+2)  
25e5 32 bf fb			ld (debug_mark+2),a  
25e8 18 03			jr .pastdmark  
25ea ..			.dmark: db "CBA"  
25ed f1			.pastdmark: pop af  
25ee			endm  
# End of macro DMARK
25ee						CALLMONITOR 
25ee cd 20 17			call break_point_state  
25f1				endm  
# End of macro CALLMONITOR
25f1					endif 
25f1 c3 ba 25				jp .storebyteat 
25f4					NEXTW 
25f4 c3 19 20			jp macro_next 
25f7				endm 
# End of macro NEXTW
25f7			.SCALL: 
25f7				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25f7 23				db WORD_SYS_CORE+OPCODE_SCALL             
25f8 2b 26			dw .DEPTH            
25fa 05				db 4 + 1 
25fb .. 00			db "CALL",0              
2600				endm 
# End of macro CWHEAD
2600			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2600					if DEBUG_FORTH_WORDS_KEY 
2600						DMARK "CLL" 
2600 f5				push af  
2601 3a 15 26			ld a, (.dmark)  
2604 32 bd fb			ld (debug_mark),a  
2607 3a 16 26			ld a, (.dmark+1)  
260a 32 be fb			ld (debug_mark+1),a  
260d 3a 17 26			ld a, (.dmark+2)  
2610 32 bf fb			ld (debug_mark+2),a  
2613 18 03			jr .pastdmark  
2615 ..			.dmark: db "CLL"  
2618 f1			.pastdmark: pop af  
2619			endm  
# End of macro DMARK
2619						CALLMONITOR 
2619 cd 20 17			call break_point_state  
261c				endm  
# End of macro CALLMONITOR
261c					endif 
261c			 
261c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261c cd a7 1e			call macro_dsp_valuehl 
261f				endm 
# End of macro FORTH_DSP_VALUEHL
261f			 
261f			;		push hl 
261f			 
261f					; destroy value TOS 
261f			 
261f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261f cd 5f 1f			call macro_forth_dsp_pop 
2622				endm 
# End of macro FORTH_DSP_POP
2622			 
2622						 
2622			;		pop hl 
2622			 
2622					; how to do a call with hl???? save SP? 
2622 cd c2 1f				call forth_call_hl 
2625			 
2625			 
2625					; TODO push value back onto stack for another op etc 
2625			 
2625 cd b0 1c				call forth_push_numhl 
2628					NEXTW 
2628 c3 19 20			jp macro_next 
262b				endm 
# End of macro NEXTW
262b			.DEPTH: 
262b				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
262b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
262c 68 26			dw .OVER            
262e 06				db 5 + 1 
262f .. 00			db "DEPTH",0              
2635				endm 
# End of macro CWHEAD
2635			; | DEPTH ( -- u ) Push count of stack | DONE 
2635					; take current TOS and remove from base value div by two to get count 
2635					if DEBUG_FORTH_WORDS_KEY 
2635						DMARK "DEP" 
2635 f5				push af  
2636 3a 4a 26			ld a, (.dmark)  
2639 32 bd fb			ld (debug_mark),a  
263c 3a 4b 26			ld a, (.dmark+1)  
263f 32 be fb			ld (debug_mark+1),a  
2642 3a 4c 26			ld a, (.dmark+2)  
2645 32 bf fb			ld (debug_mark+2),a  
2648 18 03			jr .pastdmark  
264a ..			.dmark: db "DEP"  
264d f1			.pastdmark: pop af  
264e			endm  
# End of macro DMARK
264e						CALLMONITOR 
264e cd 20 17			call break_point_state  
2651				endm  
# End of macro CALLMONITOR
2651					endif 
2651			 
2651			 
2651 2a 90 f9			ld hl, (cli_data_sp) 
2654 11 0a f5			ld de, cli_data_stack 
2657 ed 52			sbc hl,de 
2659				 
2659				; div by size of stack item 
2659			 
2659 5d				ld e,l 
265a 0e 03			ld c, 3 
265c cd 96 0c			call Div8 
265f			 
265f 6f				ld l,a 
2660 26 00			ld h,0 
2662			 
2662				;srl h 
2662				;rr l 
2662			 
2662 cd b0 1c				call forth_push_numhl 
2665					NEXTW 
2665 c3 19 20			jp macro_next 
2668				endm 
# End of macro NEXTW
2668			.OVER: 
2668				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2668 42				db WORD_SYS_CORE+46             
2669 af 26			dw .PAUSE            
266b 05				db 4 + 1 
266c .. 00			db "OVER",0              
2671				endm 
# End of macro CWHEAD
2671			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2671					if DEBUG_FORTH_WORDS_KEY 
2671						DMARK "OVR" 
2671 f5				push af  
2672 3a 86 26			ld a, (.dmark)  
2675 32 bd fb			ld (debug_mark),a  
2678 3a 87 26			ld a, (.dmark+1)  
267b 32 be fb			ld (debug_mark+1),a  
267e 3a 88 26			ld a, (.dmark+2)  
2681 32 bf fb			ld (debug_mark+2),a  
2684 18 03			jr .pastdmark  
2686 ..			.dmark: db "OVR"  
2689 f1			.pastdmark: pop af  
268a			endm  
# End of macro DMARK
268a						CALLMONITOR 
268a cd 20 17			call break_point_state  
268d				endm  
# End of macro CALLMONITOR
268d					endif 
268d			 
268d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
268d cd a7 1e			call macro_dsp_valuehl 
2690				endm 
# End of macro FORTH_DSP_VALUEHL
2690 e5					push hl    ; n2 
2691					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2691 cd 5f 1f			call macro_forth_dsp_pop 
2694				endm 
# End of macro FORTH_DSP_POP
2694			 
2694					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2694 cd a7 1e			call macro_dsp_valuehl 
2697				endm 
# End of macro FORTH_DSP_VALUEHL
2697 e5					push hl    ; n1 
2698					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2698 cd 5f 1f			call macro_forth_dsp_pop 
269b				endm 
# End of macro FORTH_DSP_POP
269b			 
269b d1					pop de     ; n1 
269c e1					pop hl     ; n2 
269d			 
269d d5					push de 
269e e5					push hl 
269f d5					push de 
26a0			 
26a0					; push back  
26a0			 
26a0 e1					pop hl 
26a1 cd b0 1c				call forth_push_numhl 
26a4 e1					pop hl 
26a5 cd b0 1c				call forth_push_numhl 
26a8 e1					pop hl 
26a9 cd b0 1c				call forth_push_numhl 
26ac					NEXTW 
26ac c3 19 20			jp macro_next 
26af				endm 
# End of macro NEXTW
26af			 
26af			.PAUSE: 
26af				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26af 43				db WORD_SYS_CORE+47             
26b0 e4 26			dw .PAUSES            
26b2 08				db 7 + 1 
26b3 .. 00			db "PAUSEMS",0              
26bb				endm 
# End of macro CWHEAD
26bb			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26bb					if DEBUG_FORTH_WORDS_KEY 
26bb						DMARK "PMS" 
26bb f5				push af  
26bc 3a d0 26			ld a, (.dmark)  
26bf 32 bd fb			ld (debug_mark),a  
26c2 3a d1 26			ld a, (.dmark+1)  
26c5 32 be fb			ld (debug_mark+1),a  
26c8 3a d2 26			ld a, (.dmark+2)  
26cb 32 bf fb			ld (debug_mark+2),a  
26ce 18 03			jr .pastdmark  
26d0 ..			.dmark: db "PMS"  
26d3 f1			.pastdmark: pop af  
26d4			endm  
# End of macro DMARK
26d4						CALLMONITOR 
26d4 cd 20 17			call break_point_state  
26d7				endm  
# End of macro CALLMONITOR
26d7					endif 
26d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d7 cd a7 1e			call macro_dsp_valuehl 
26da				endm 
# End of macro FORTH_DSP_VALUEHL
26da			;		push hl    ; n2 
26da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26da cd 5f 1f			call macro_forth_dsp_pop 
26dd				endm 
# End of macro FORTH_DSP_POP
26dd			;		pop hl 
26dd			 
26dd 7d					ld a, l 
26de cd 37 0a				call aDelayInMS 
26e1				       NEXTW 
26e1 c3 19 20			jp macro_next 
26e4				endm 
# End of macro NEXTW
26e4			.PAUSES:  
26e4				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26e4 44				db WORD_SYS_CORE+48             
26e5 53 27			dw .ROT            
26e7 06				db 5 + 1 
26e8 .. 00			db "PAUSE",0              
26ee				endm 
# End of macro CWHEAD
26ee			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26ee					if DEBUG_FORTH_WORDS_KEY 
26ee						DMARK "PAU" 
26ee f5				push af  
26ef 3a 03 27			ld a, (.dmark)  
26f2 32 bd fb			ld (debug_mark),a  
26f5 3a 04 27			ld a, (.dmark+1)  
26f8 32 be fb			ld (debug_mark+1),a  
26fb 3a 05 27			ld a, (.dmark+2)  
26fe 32 bf fb			ld (debug_mark+2),a  
2701 18 03			jr .pastdmark  
2703 ..			.dmark: db "PAU"  
2706 f1			.pastdmark: pop af  
2707			endm  
# End of macro DMARK
2707						CALLMONITOR 
2707 cd 20 17			call break_point_state  
270a				endm  
# End of macro CALLMONITOR
270a					endif 
270a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
270a cd a7 1e			call macro_dsp_valuehl 
270d				endm 
# End of macro FORTH_DSP_VALUEHL
270d			;		push hl    ; n2 
270d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
270d cd 5f 1f			call macro_forth_dsp_pop 
2710				endm 
# End of macro FORTH_DSP_POP
2710			;		pop hl 
2710 45					ld b, l 
2711					if DEBUG_FORTH_WORDS 
2711						DMARK "PAU" 
2711 f5				push af  
2712 3a 26 27			ld a, (.dmark)  
2715 32 bd fb			ld (debug_mark),a  
2718 3a 27 27			ld a, (.dmark+1)  
271b 32 be fb			ld (debug_mark+1),a  
271e 3a 28 27			ld a, (.dmark+2)  
2721 32 bf fb			ld (debug_mark+2),a  
2724 18 03			jr .pastdmark  
2726 ..			.dmark: db "PAU"  
2729 f1			.pastdmark: pop af  
272a			endm  
# End of macro DMARK
272a						CALLMONITOR 
272a cd 20 17			call break_point_state  
272d				endm  
# End of macro CALLMONITOR
272d					endif 
272d c5			.pauses1:	push bc 
272e cd 52 0a				call delay1s 
2731 c1					pop bc 
2732					if DEBUG_FORTH_WORDS 
2732						DMARK "PA1" 
2732 f5				push af  
2733 3a 47 27			ld a, (.dmark)  
2736 32 bd fb			ld (debug_mark),a  
2739 3a 48 27			ld a, (.dmark+1)  
273c 32 be fb			ld (debug_mark+1),a  
273f 3a 49 27			ld a, (.dmark+2)  
2742 32 bf fb			ld (debug_mark+2),a  
2745 18 03			jr .pastdmark  
2747 ..			.dmark: db "PA1"  
274a f1			.pastdmark: pop af  
274b			endm  
# End of macro DMARK
274b						CALLMONITOR 
274b cd 20 17			call break_point_state  
274e				endm  
# End of macro CALLMONITOR
274e					endif 
274e 10 dd				djnz .pauses1 
2750			 
2750				       NEXTW 
2750 c3 19 20			jp macro_next 
2753				endm 
# End of macro NEXTW
2753			.ROT: 
2753				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2753 45				db WORD_SYS_CORE+49             
2754 a1 27			dw .UWORDS            
2756 04				db 3 + 1 
2757 .. 00			db "ROT",0              
275b				endm 
# End of macro CWHEAD
275b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
275b					if DEBUG_FORTH_WORDS_KEY 
275b						DMARK "ROT" 
275b f5				push af  
275c 3a 70 27			ld a, (.dmark)  
275f 32 bd fb			ld (debug_mark),a  
2762 3a 71 27			ld a, (.dmark+1)  
2765 32 be fb			ld (debug_mark+1),a  
2768 3a 72 27			ld a, (.dmark+2)  
276b 32 bf fb			ld (debug_mark+2),a  
276e 18 03			jr .pastdmark  
2770 ..			.dmark: db "ROT"  
2773 f1			.pastdmark: pop af  
2774			endm  
# End of macro DMARK
2774						CALLMONITOR 
2774 cd 20 17			call break_point_state  
2777				endm  
# End of macro CALLMONITOR
2777					endif 
2777			 
2777					FORTH_DSP_VALUEHL 
2777 cd a7 1e			call macro_dsp_valuehl 
277a				endm 
# End of macro FORTH_DSP_VALUEHL
277a e5					push hl    ; u3  
277b			 
277b					FORTH_DSP_POP 
277b cd 5f 1f			call macro_forth_dsp_pop 
277e				endm 
# End of macro FORTH_DSP_POP
277e			   
277e					FORTH_DSP_VALUEHL 
277e cd a7 1e			call macro_dsp_valuehl 
2781				endm 
# End of macro FORTH_DSP_VALUEHL
2781 e5					push hl     ; u2 
2782			 
2782					FORTH_DSP_POP 
2782 cd 5f 1f			call macro_forth_dsp_pop 
2785				endm 
# End of macro FORTH_DSP_POP
2785			 
2785					FORTH_DSP_VALUEHL 
2785 cd a7 1e			call macro_dsp_valuehl 
2788				endm 
# End of macro FORTH_DSP_VALUEHL
2788 e5					push hl     ; u1 
2789			 
2789					FORTH_DSP_POP 
2789 cd 5f 1f			call macro_forth_dsp_pop 
278c				endm 
# End of macro FORTH_DSP_POP
278c			 
278c c1					pop bc      ; u1 
278d e1					pop hl      ; u2 
278e d1					pop de      ; u3 
278f			 
278f			 
278f c5					push bc 
2790 d5					push de 
2791 e5					push hl 
2792			 
2792			 
2792 e1					pop hl 
2793 cd b0 1c				call forth_push_numhl 
2796			 
2796 e1					pop hl 
2797 cd b0 1c				call forth_push_numhl 
279a			 
279a e1					pop hl 
279b cd b0 1c				call forth_push_numhl 
279e					 
279e			 
279e			 
279e			 
279e			 
279e			 
279e				       NEXTW 
279e c3 19 20			jp macro_next 
27a1				endm 
# End of macro NEXTW
27a1			 
27a1			.UWORDS: 
27a1				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27a1 50				db WORD_SYS_CORE+60             
27a2 63 28			dw .BP            
27a4 07				db 6 + 1 
27a5 .. 00			db "UWORDS",0              
27ac				endm 
# End of macro CWHEAD
27ac			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27ac			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27ac			; | | Following the count are the individual words. 
27ac			; | | 
27ac			; | | e.g. UWORDS 
27ac			; | | BOX DIRLIST 2 
27ac			; | |  
27ac			; | | Can be used to save the words to storage via: 
27ac			; | | UWORDS $01 DO $01 APPEND LOOP 
27ac				if DEBUG_FORTH_WORDS_KEY 
27ac					DMARK "UWR" 
27ac f5				push af  
27ad 3a c1 27			ld a, (.dmark)  
27b0 32 bd fb			ld (debug_mark),a  
27b3 3a c2 27			ld a, (.dmark+1)  
27b6 32 be fb			ld (debug_mark+1),a  
27b9 3a c3 27			ld a, (.dmark+2)  
27bc 32 bf fb			ld (debug_mark+2),a  
27bf 18 03			jr .pastdmark  
27c1 ..			.dmark: db "UWR"  
27c4 f1			.pastdmark: pop af  
27c5			endm  
# End of macro DMARK
27c5					CALLMONITOR 
27c5 cd 20 17			call break_point_state  
27c8				endm  
# End of macro CALLMONITOR
27c8				endif 
27c8 21 00 80				ld hl, baseram 
27cb					;ld hl, baseusermem 
27cb 01 00 00				ld bc, 0    ; start a counter 
27ce			 
27ce				; skip dict stub 
27ce			 
27ce cd 6a 21				call forth_tok_next 
27d1			 
27d1			 
27d1			; while we have words to look for 
27d1			 
27d1 7e			.douscan:	ld a, (hl)      
27d2				if DEBUG_FORTH_WORDS 
27d2					DMARK "UWs" 
27d2 f5				push af  
27d3 3a e7 27			ld a, (.dmark)  
27d6 32 bd fb			ld (debug_mark),a  
27d9 3a e8 27			ld a, (.dmark+1)  
27dc 32 be fb			ld (debug_mark+1),a  
27df 3a e9 27			ld a, (.dmark+2)  
27e2 32 bf fb			ld (debug_mark+2),a  
27e5 18 03			jr .pastdmark  
27e7 ..			.dmark: db "UWs"  
27ea f1			.pastdmark: pop af  
27eb			endm  
# End of macro DMARK
27eb					CALLMONITOR 
27eb cd 20 17			call break_point_state  
27ee				endm  
# End of macro CALLMONITOR
27ee				endif 
27ee fe 00				cp WORD_SYS_END 
27f0 28 4d				jr z, .udone 
27f2 fe 01				cp WORD_SYS_UWORD 
27f4 20 44				jr nz, .nuword 
27f6			 
27f6				if DEBUG_FORTH_WORDS 
27f6					DMARK "UWu" 
27f6 f5				push af  
27f7 3a 0b 28			ld a, (.dmark)  
27fa 32 bd fb			ld (debug_mark),a  
27fd 3a 0c 28			ld a, (.dmark+1)  
2800 32 be fb			ld (debug_mark+1),a  
2803 3a 0d 28			ld a, (.dmark+2)  
2806 32 bf fb			ld (debug_mark+2),a  
2809 18 03			jr .pastdmark  
280b ..			.dmark: db "UWu"  
280e f1			.pastdmark: pop af  
280f			endm  
# End of macro DMARK
280f					CALLMONITOR 
280f cd 20 17			call break_point_state  
2812				endm  
# End of macro CALLMONITOR
2812				endif 
2812					; we have a uword so push its name to the stack 
2812			 
2812 e5				   	push hl  ; save so we can move to next dict block 
2813			 
2813					; skip opcode 
2813 23					inc hl  
2814					; skip next ptr 
2814 23					inc hl  
2815 23					inc hl 
2816					; skip len 
2816 23					inc hl 
2817				if DEBUG_FORTH_WORDS 
2817					DMARK "UWt" 
2817 f5				push af  
2818 3a 2c 28			ld a, (.dmark)  
281b 32 bd fb			ld (debug_mark),a  
281e 3a 2d 28			ld a, (.dmark+1)  
2821 32 be fb			ld (debug_mark+1),a  
2824 3a 2e 28			ld a, (.dmark+2)  
2827 32 bf fb			ld (debug_mark+2),a  
282a 18 03			jr .pastdmark  
282c ..			.dmark: db "UWt"  
282f f1			.pastdmark: pop af  
2830			endm  
# End of macro DMARK
2830					CALLMONITOR 
2830 cd 20 17			call break_point_state  
2833				endm  
# End of macro CALLMONITOR
2833				endif 
2833 03					inc bc 
2834			 
2834 c5					push bc 
2835 cd 1e 1d				call forth_push_str 
2838 c1					pop bc 
2839			 
2839 e1					pop hl 	 
283a			 
283a cd 6a 21		.nuword:	call forth_tok_next 
283d 18 92				jr .douscan  
283f			 
283f			.udone:		 ; push count of uwords found 
283f c5					push bc 
2840 e1					pop hl 
2841			 
2841				if DEBUG_FORTH_WORDS 
2841					DMARK "UWc" 
2841 f5				push af  
2842 3a 56 28			ld a, (.dmark)  
2845 32 bd fb			ld (debug_mark),a  
2848 3a 57 28			ld a, (.dmark+1)  
284b 32 be fb			ld (debug_mark+1),a  
284e 3a 58 28			ld a, (.dmark+2)  
2851 32 bf fb			ld (debug_mark+2),a  
2854 18 03			jr .pastdmark  
2856 ..			.dmark: db "UWc"  
2859 f1			.pastdmark: pop af  
285a			endm  
# End of macro DMARK
285a					CALLMONITOR 
285a cd 20 17			call break_point_state  
285d				endm  
# End of macro CALLMONITOR
285d				endif 
285d cd b0 1c				call forth_push_numhl 
2860			 
2860			 
2860				       NEXTW 
2860 c3 19 20			jp macro_next 
2863				endm 
# End of macro NEXTW
2863			 
2863			.BP: 
2863				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2863 54				db WORD_SYS_CORE+64             
2864 99 28			dw .MONITOR            
2866 03				db 2 + 1 
2867 .. 00			db "BP",0              
286a				endm 
# End of macro CWHEAD
286a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
286a			; | | $00 Will enable the break points within specific code paths 
286a			; | | $01 Will disable break points 
286a			; | |  
286a			; | | By default break points are off. Either the above can be used to enable them 
286a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
286a			; | | and on release of the pressed key a message will be disaplayed to notify 
286a			; | | that break points are enabled. Pressing any key will then continue boot process. 
286a					; get byte count 
286a					if DEBUG_FORTH_WORDS_KEY 
286a						DMARK "BP." 
286a f5				push af  
286b 3a 7f 28			ld a, (.dmark)  
286e 32 bd fb			ld (debug_mark),a  
2871 3a 80 28			ld a, (.dmark+1)  
2874 32 be fb			ld (debug_mark+1),a  
2877 3a 81 28			ld a, (.dmark+2)  
287a 32 bf fb			ld (debug_mark+2),a  
287d 18 03			jr .pastdmark  
287f ..			.dmark: db "BP."  
2882 f1			.pastdmark: pop af  
2883			endm  
# End of macro DMARK
2883						CALLMONITOR 
2883 cd 20 17			call break_point_state  
2886				endm  
# End of macro CALLMONITOR
2886					endif 
2886			 
2886					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2886 cd a7 1e			call macro_dsp_valuehl 
2889				endm 
# End of macro FORTH_DSP_VALUEHL
2889			 
2889			;		push hl 
2889			 
2889					; destroy value TOS 
2889			 
2889					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2889 cd 5f 1f			call macro_forth_dsp_pop 
288c				endm 
# End of macro FORTH_DSP_POP
288c			 
288c			;		pop hl 
288c			 
288c 3e 00				ld a,0 
288e bd					cp l 
288f 28 02				jr z, .bpset 
2891 3e 2a				ld a, '*' 
2893			 
2893 32 94 ef		.bpset:		ld (os_view_disable), a 
2896			 
2896			 
2896					NEXTW 
2896 c3 19 20			jp macro_next 
2899				endm 
# End of macro NEXTW
2899			 
2899			 
2899			.MONITOR: 
2899				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2899 55				db WORD_SYS_CORE+65             
289a cc 28			dw .MALLOC            
289c 08				db 7 + 1 
289d .. 00			db "MONITOR",0              
28a5				endm 
# End of macro CWHEAD
28a5			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28a5			; | | At start the current various registers will be displayed with contents. 
28a5			; | | Top right corner will show the most recent debug marker seen. 
28a5			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28a5			; | | and the return stack pointer (RSP). 
28a5			; | | Pressing: 
28a5			; | |    1 - Initial screen 
28a5			; | |    2 - Display a data dump of HL 
28a5			; | |    3 - Display a data dump of DE 
28a5			; | |    4 - Display a data dump of BC 
28a5			; | |    5 - Display a data dump of HL 
28a5			; | |    6 - Display a data dump of DSP 
28a5			; | |    7 - Display a data dump of RSP 
28a5			; | |    8 - Display a data dump of what is at DSP 
28a5			; | |    9 - Display a data dump of what is at RSP 
28a5			; | |    0 - Exit monitor and continue running. This will also enable break points 
28a5			; | |    * - Disable break points 
28a5			; | |    # - Enter traditional monitor mode 
28a5			; | | 
28a5			; | | Monitor Mode 
28a5			; | | ------------ 
28a5			; | | A prompt of '>' will be shown for various commands: 
28a5			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28a5			; | |    C - Continue display a data dump from the last set address 
28a5			; | |    M xxxx - Set start of memory edit at address xx 
28a5			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28a5			; | |    Q - Return to previous 
28a5					if DEBUG_FORTH_WORDS_KEY 
28a5						DMARK "MON" 
28a5 f5				push af  
28a6 3a ba 28			ld a, (.dmark)  
28a9 32 bd fb			ld (debug_mark),a  
28ac 3a bb 28			ld a, (.dmark+1)  
28af 32 be fb			ld (debug_mark+1),a  
28b2 3a bc 28			ld a, (.dmark+2)  
28b5 32 bf fb			ld (debug_mark+2),a  
28b8 18 03			jr .pastdmark  
28ba ..			.dmark: db "MON"  
28bd f1			.pastdmark: pop af  
28be			endm  
# End of macro DMARK
28be						CALLMONITOR 
28be cd 20 17			call break_point_state  
28c1				endm  
# End of macro CALLMONITOR
28c1					endif 
28c1 3e 00				ld a, 0 
28c3 32 94 ef				ld (os_view_disable), a 
28c6			 
28c6					CALLMONITOR 
28c6 cd 20 17			call break_point_state  
28c9				endm  
# End of macro CALLMONITOR
28c9			 
28c9			;	call monitor 
28c9			 
28c9					NEXTW 
28c9 c3 19 20			jp macro_next 
28cc				endm 
# End of macro NEXTW
28cc			 
28cc			 
28cc			.MALLOC: 
28cc				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28cc 56				db WORD_SYS_CORE+66             
28cd f5 28			dw .MALLOC2            
28cf 06				db 5 + 1 
28d0 .. 00			db "ALLOT",0              
28d6				endm 
# End of macro CWHEAD
28d6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28d6					if DEBUG_FORTH_WORDS_KEY 
28d6						DMARK "ALL" 
28d6 f5				push af  
28d7 3a eb 28			ld a, (.dmark)  
28da 32 bd fb			ld (debug_mark),a  
28dd 3a ec 28			ld a, (.dmark+1)  
28e0 32 be fb			ld (debug_mark+1),a  
28e3 3a ed 28			ld a, (.dmark+2)  
28e6 32 bf fb			ld (debug_mark+2),a  
28e9 18 03			jr .pastdmark  
28eb ..			.dmark: db "ALL"  
28ee f1			.pastdmark: pop af  
28ef			endm  
# End of macro DMARK
28ef						CALLMONITOR 
28ef cd 20 17			call break_point_state  
28f2				endm  
# End of macro CALLMONITOR
28f2					endif 
28f2 c3 1c 29				jp .mallocc 
28f5			.MALLOC2: 
28f5				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28f5 56				db WORD_SYS_CORE+66             
28f6 33 29			dw .FREE            
28f8 07				db 6 + 1 
28f9 .. 00			db "MALLOC",0              
2900				endm 
# End of macro CWHEAD
2900			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2900					; get byte count 
2900					if DEBUG_FORTH_WORDS_KEY 
2900						DMARK "MAL" 
2900 f5				push af  
2901 3a 15 29			ld a, (.dmark)  
2904 32 bd fb			ld (debug_mark),a  
2907 3a 16 29			ld a, (.dmark+1)  
290a 32 be fb			ld (debug_mark+1),a  
290d 3a 17 29			ld a, (.dmark+2)  
2910 32 bf fb			ld (debug_mark+2),a  
2913 18 03			jr .pastdmark  
2915 ..			.dmark: db "MAL"  
2918 f1			.pastdmark: pop af  
2919			endm  
# End of macro DMARK
2919						CALLMONITOR 
2919 cd 20 17			call break_point_state  
291c				endm  
# End of macro CALLMONITOR
291c					endif 
291c			.mallocc: 
291c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
291c cd a7 1e			call macro_dsp_valuehl 
291f				endm 
# End of macro FORTH_DSP_VALUEHL
291f			 
291f			;		push hl 
291f			 
291f					; destroy value TOS 
291f			 
291f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291f cd 5f 1f			call macro_forth_dsp_pop 
2922				endm 
# End of macro FORTH_DSP_POP
2922			 
2922			;		pop hl 
2922 cd cd 11				call malloc 
2925				if DEBUG_FORTH_MALLOC_GUARD 
2925 f5					push af 
2926 cd 2f 0d				call ishlzero 
2929			;		ld a, l 
2929			;		add h 
2929			;		cp 0 
2929 f1					pop af 
292a					 
292a cc 3e 51				call z,malloc_error 
292d				endif 
292d			 
292d cd b0 1c				call forth_push_numhl 
2930					NEXTW 
2930 c3 19 20			jp macro_next 
2933				endm 
# End of macro NEXTW
2933			 
2933			.FREE: 
2933				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2933 57				db WORD_SYS_CORE+67             
2934 64 29			dw .LIST            
2936 05				db 4 + 1 
2937 .. 00			db "FREE",0              
293c				endm 
# End of macro CWHEAD
293c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
293c					if DEBUG_FORTH_WORDS_KEY 
293c						DMARK "FRE" 
293c f5				push af  
293d 3a 51 29			ld a, (.dmark)  
2940 32 bd fb			ld (debug_mark),a  
2943 3a 52 29			ld a, (.dmark+1)  
2946 32 be fb			ld (debug_mark+1),a  
2949 3a 53 29			ld a, (.dmark+2)  
294c 32 bf fb			ld (debug_mark+2),a  
294f 18 03			jr .pastdmark  
2951 ..			.dmark: db "FRE"  
2954 f1			.pastdmark: pop af  
2955			endm  
# End of macro DMARK
2955						CALLMONITOR 
2955 cd 20 17			call break_point_state  
2958				endm  
# End of macro CALLMONITOR
2958					endif 
2958					; get address 
2958			 
2958					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2958 cd a7 1e			call macro_dsp_valuehl 
295b				endm 
# End of macro FORTH_DSP_VALUEHL
295b			 
295b			;		push hl 
295b			 
295b					; destroy value TOS 
295b			 
295b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
295b cd 5f 1f			call macro_forth_dsp_pop 
295e				endm 
# End of macro FORTH_DSP_POP
295e			 
295e			;		pop hl 
295e			if FORTH_ENABLE_MALLOCFREE 
295e cd 97 12				call free 
2961			endif 
2961					NEXTW 
2961 c3 19 20			jp macro_next 
2964				endm 
# End of macro NEXTW
2964			.LIST: 
2964				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2964 5c				db WORD_SYS_CORE+72             
2965 27 2b			dw .FORGET            
2967 05				db 4 + 1 
2968 .. 00			db "LIST",0              
296d				endm 
# End of macro CWHEAD
296d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
296d			; | | The quoted word must be in upper case. 
296d				if DEBUG_FORTH_WORDS_KEY 
296d					DMARK "LST" 
296d f5				push af  
296e 3a 82 29			ld a, (.dmark)  
2971 32 bd fb			ld (debug_mark),a  
2974 3a 83 29			ld a, (.dmark+1)  
2977 32 be fb			ld (debug_mark+1),a  
297a 3a 84 29			ld a, (.dmark+2)  
297d 32 bf fb			ld (debug_mark+2),a  
2980 18 03			jr .pastdmark  
2982 ..			.dmark: db "LST"  
2985 f1			.pastdmark: pop af  
2986			endm  
# End of macro DMARK
2986					CALLMONITOR 
2986 cd 20 17			call break_point_state  
2989				endm  
# End of macro CALLMONITOR
2989				endif 
2989			 
2989					FORTH_DSP_VALUEHL 
2989 cd a7 1e			call macro_dsp_valuehl 
298c				endm 
# End of macro FORTH_DSP_VALUEHL
298c			 
298c e5					push hl 
298d c1					pop bc 
298e			 
298e			; Start format of scratch string 
298e			 
298e 21 a3 ef				ld hl, scratch 
2991			 
2991 3e 3a				ld a, ':' 
2993 77					ld (hl),a 
2994 23					inc hl 
2995 3e 20				ld a, ' ' 
2997 77					ld (hl), a 
2998			 
2998					; Get ptr to the word we need to look up 
2998			 
2998			;		FORTH_DSP_VALUEHL 
2998					;v5 FORTH_DSP_VALUE 
2998				; TODO type check 
2998			;		inc hl    ; Skip type check  
2998			;		push hl 
2998			;		ex de, hl    ; put into DE 
2998			 
2998			 
2998 21 00 80				ld hl, baseram 
299b					;ld hl, baseusermem 
299b			 
299b e5			push hl   ; sacreifical push 
299c			 
299c			.ldouscanm: 
299c e1				pop hl 
299d			.ldouscan: 
299d				if DEBUG_FORTH_WORDS 
299d					DMARK "LSs" 
299d f5				push af  
299e 3a b2 29			ld a, (.dmark)  
29a1 32 bd fb			ld (debug_mark),a  
29a4 3a b3 29			ld a, (.dmark+1)  
29a7 32 be fb			ld (debug_mark+1),a  
29aa 3a b4 29			ld a, (.dmark+2)  
29ad 32 bf fb			ld (debug_mark+2),a  
29b0 18 03			jr .pastdmark  
29b2 ..			.dmark: db "LSs"  
29b5 f1			.pastdmark: pop af  
29b6			endm  
# End of macro DMARK
29b6					CALLMONITOR 
29b6 cd 20 17			call break_point_state  
29b9				endm  
# End of macro CALLMONITOR
29b9				endif 
29b9				; skip dict stub 
29b9 cd 6a 21				call forth_tok_next 
29bc			 
29bc			 
29bc			; while we have words to look for 
29bc			 
29bc 7e				ld a, (hl)      
29bd				if DEBUG_FORTH_WORDS 
29bd					DMARK "LSk" 
29bd f5				push af  
29be 3a d2 29			ld a, (.dmark)  
29c1 32 bd fb			ld (debug_mark),a  
29c4 3a d3 29			ld a, (.dmark+1)  
29c7 32 be fb			ld (debug_mark+1),a  
29ca 3a d4 29			ld a, (.dmark+2)  
29cd 32 bf fb			ld (debug_mark+2),a  
29d0 18 03			jr .pastdmark  
29d2 ..			.dmark: db "LSk"  
29d5 f1			.pastdmark: pop af  
29d6			endm  
# End of macro DMARK
29d6					CALLMONITOR 
29d6 cd 20 17			call break_point_state  
29d9				endm  
# End of macro CALLMONITOR
29d9				endif 
29d9 fe 00				cp WORD_SYS_END 
29db ca 0e 2b				jp z, .lunotfound 
29de fe 01				cp WORD_SYS_UWORD 
29e0 c2 9d 29				jp nz, .ldouscan 
29e3			 
29e3				if DEBUG_FORTH_WORDS 
29e3					DMARK "LSu" 
29e3 f5				push af  
29e4 3a f8 29			ld a, (.dmark)  
29e7 32 bd fb			ld (debug_mark),a  
29ea 3a f9 29			ld a, (.dmark+1)  
29ed 32 be fb			ld (debug_mark+1),a  
29f0 3a fa 29			ld a, (.dmark+2)  
29f3 32 bf fb			ld (debug_mark+2),a  
29f6 18 03			jr .pastdmark  
29f8 ..			.dmark: db "LSu"  
29fb f1			.pastdmark: pop af  
29fc			endm  
# End of macro DMARK
29fc					CALLMONITOR 
29fc cd 20 17			call break_point_state  
29ff				endm  
# End of macro CALLMONITOR
29ff				endif 
29ff			 
29ff					; found a uword but is it the one we want... 
29ff			 
29ff c5					push bc     ; uword to find is on bc 
2a00 d1					pop de 
2a01			 
2a01 e5					push hl  ; to save the ptr 
2a02			 
2a02					; skip opcode 
2a02 23					inc hl  
2a03					; skip next ptr 
2a03 23					inc hl  
2a04 23					inc hl 
2a05					; skip len 
2a05 23					inc hl 
2a06			 
2a06				if DEBUG_FORTH_WORDS 
2a06					DMARK "LSc" 
2a06 f5				push af  
2a07 3a 1b 2a			ld a, (.dmark)  
2a0a 32 bd fb			ld (debug_mark),a  
2a0d 3a 1c 2a			ld a, (.dmark+1)  
2a10 32 be fb			ld (debug_mark+1),a  
2a13 3a 1d 2a			ld a, (.dmark+2)  
2a16 32 bf fb			ld (debug_mark+2),a  
2a19 18 03			jr .pastdmark  
2a1b ..			.dmark: db "LSc"  
2a1e f1			.pastdmark: pop af  
2a1f			endm  
# End of macro DMARK
2a1f					CALLMONITOR 
2a1f cd 20 17			call break_point_state  
2a22				endm  
# End of macro CALLMONITOR
2a22				endif 
2a22 cd 9c 11				call strcmp 
2a25 c2 9c 29				jp nz, .ldouscanm 
2a28				 
2a28			 
2a28			 
2a28					; we have a uword so push its name to the stack 
2a28			 
2a28			;	   	push hl  ; save so we can move to next dict block 
2a28 e1			pop hl 
2a29			 
2a29				if DEBUG_FORTH_WORDS 
2a29					DMARK "LSm" 
2a29 f5				push af  
2a2a 3a 3e 2a			ld a, (.dmark)  
2a2d 32 bd fb			ld (debug_mark),a  
2a30 3a 3f 2a			ld a, (.dmark+1)  
2a33 32 be fb			ld (debug_mark+1),a  
2a36 3a 40 2a			ld a, (.dmark+2)  
2a39 32 bf fb			ld (debug_mark+2),a  
2a3c 18 03			jr .pastdmark  
2a3e ..			.dmark: db "LSm"  
2a41 f1			.pastdmark: pop af  
2a42			endm  
# End of macro DMARK
2a42					CALLMONITOR 
2a42 cd 20 17			call break_point_state  
2a45				endm  
# End of macro CALLMONITOR
2a45				endif 
2a45			 
2a45					; skip opcode 
2a45 23					inc hl  
2a46					; skip next ptr 
2a46 23					inc hl  
2a47 23					inc hl 
2a48					; skip len 
2a48 7e					ld a, (hl)   ; save length to add 
2a49				if DEBUG_FORTH_WORDS 
2a49					DMARK "LS2" 
2a49 f5				push af  
2a4a 3a 5e 2a			ld a, (.dmark)  
2a4d 32 bd fb			ld (debug_mark),a  
2a50 3a 5f 2a			ld a, (.dmark+1)  
2a53 32 be fb			ld (debug_mark+1),a  
2a56 3a 60 2a			ld a, (.dmark+2)  
2a59 32 bf fb			ld (debug_mark+2),a  
2a5c 18 03			jr .pastdmark  
2a5e ..			.dmark: db "LS2"  
2a61 f1			.pastdmark: pop af  
2a62			endm  
# End of macro DMARK
2a62					CALLMONITOR 
2a62 cd 20 17			call break_point_state  
2a65				endm  
# End of macro CALLMONITOR
2a65				endif 
2a65			 
2a65					; save this location 
2a65				 
2a65 e5					push hl 
2a66			 
2a66 23					inc hl 
2a67 11 a5 ef				ld de, scratch+2 
2a6a 4f					ld c, a 
2a6b 06 00				ld b, 0 
2a6d			 
2a6d				if DEBUG_FORTH_WORDS 
2a6d					DMARK "LSn" 
2a6d f5				push af  
2a6e 3a 82 2a			ld a, (.dmark)  
2a71 32 bd fb			ld (debug_mark),a  
2a74 3a 83 2a			ld a, (.dmark+1)  
2a77 32 be fb			ld (debug_mark+1),a  
2a7a 3a 84 2a			ld a, (.dmark+2)  
2a7d 32 bf fb			ld (debug_mark+2),a  
2a80 18 03			jr .pastdmark  
2a82 ..			.dmark: db "LSn"  
2a85 f1			.pastdmark: pop af  
2a86			endm  
# End of macro DMARK
2a86					CALLMONITOR 
2a86 cd 20 17			call break_point_state  
2a89				endm  
# End of macro CALLMONITOR
2a89				endif 
2a89			 
2a89					; copy uword name to scratch 
2a89			 
2a89 ed b0				ldir 
2a8b			 
2a8b 1b					dec de 
2a8c 3e 20				ld a, ' '    ; change null to space 
2a8e 12					ld (de), a 
2a8f			 
2a8f 13					inc de 
2a90			 
2a90 d5					push de 
2a91 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a92			 
2a92 e1					pop hl 
2a93 7e					ld a, (hl) 
2a94					;inc hl 
2a94					; skip word string 
2a94 cd 06 0d				call addatohl 
2a97			 
2a97 23					inc hl 
2a98			 
2a98				if DEBUG_FORTH_WORDS 
2a98					DMARK "LS3" 
2a98 f5				push af  
2a99 3a ad 2a			ld a, (.dmark)  
2a9c 32 bd fb			ld (debug_mark),a  
2a9f 3a ae 2a			ld a, (.dmark+1)  
2aa2 32 be fb			ld (debug_mark+1),a  
2aa5 3a af 2a			ld a, (.dmark+2)  
2aa8 32 bf fb			ld (debug_mark+2),a  
2aab 18 03			jr .pastdmark  
2aad ..			.dmark: db "LS3"  
2ab0 f1			.pastdmark: pop af  
2ab1			endm  
# End of macro DMARK
2ab1					CALLMONITOR 
2ab1 cd 20 17			call break_point_state  
2ab4				endm  
# End of macro CALLMONITOR
2ab4				endif 
2ab4					; should now be at the start of the machine code to setup the eval of the uword 
2ab4					; now locate the ptr to the string defintion 
2ab4			 
2ab4					; skip ld hl, 
2ab4					; then load the ptr 
2ab4			 
2ab4 23					inc hl 
2ab5 5e					ld e, (hl) 
2ab6 23					inc hl 
2ab7 56					ld d, (hl) 
2ab8 eb					ex de, hl 
2ab9			 
2ab9			 
2ab9				if DEBUG_FORTH_WORDS 
2ab9					DMARK "LSt" 
2ab9 f5				push af  
2aba 3a ce 2a			ld a, (.dmark)  
2abd 32 bd fb			ld (debug_mark),a  
2ac0 3a cf 2a			ld a, (.dmark+1)  
2ac3 32 be fb			ld (debug_mark+1),a  
2ac6 3a d0 2a			ld a, (.dmark+2)  
2ac9 32 bf fb			ld (debug_mark+2),a  
2acc 18 03			jr .pastdmark  
2ace ..			.dmark: db "LSt"  
2ad1 f1			.pastdmark: pop af  
2ad2			endm  
# End of macro DMARK
2ad2					CALLMONITOR 
2ad2 cd 20 17			call break_point_state  
2ad5				endm  
# End of macro CALLMONITOR
2ad5				endif 
2ad5			 
2ad5			; cant push right now due to tokenised strings  
2ad5			 
2ad5			; get the destination of where to copy this definition to. 
2ad5			 
2ad5 c5					push bc 
2ad6 d1					pop de 
2ad7			 
2ad7 7e			.listl:         ld a,(hl) 
2ad8 fe 00				cp 0 
2ada 28 09				jr z, .lreplsp     ; replace zero with space 
2adc fe 7f				cp FORTH_END_BUFFER 
2ade 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ae0				 
2ae0					; just copy this char as is then 
2ae0			 
2ae0 12					ld (de), a 
2ae1			 
2ae1 23			.listnxt:	inc hl 
2ae2 13					inc de 
2ae3 18 f2				jr .listl 
2ae5			 
2ae5 3e 20		.lreplsp:	ld a,' ' 
2ae7 12					ld (de), a 
2ae8 18 f7				jr .listnxt 
2aea			 
2aea			; close up uword def 
2aea			 
2aea			.listdone: 
2aea 3e 00				ld a, 0 
2aec 12					ld (de), a 
2aed			 
2aed			; now have def so clean up and push to stack 
2aed			 
2aed 21 a3 ef				ld hl, scratch 
2af0				if DEBUG_FORTH_WORDS 
2af0					DMARK "Ltp" 
2af0 f5				push af  
2af1 3a 05 2b			ld a, (.dmark)  
2af4 32 bd fb			ld (debug_mark),a  
2af7 3a 06 2b			ld a, (.dmark+1)  
2afa 32 be fb			ld (debug_mark+1),a  
2afd 3a 07 2b			ld a, (.dmark+2)  
2b00 32 bf fb			ld (debug_mark+2),a  
2b03 18 03			jr .pastdmark  
2b05 ..			.dmark: db "Ltp"  
2b08 f1			.pastdmark: pop af  
2b09			endm  
# End of macro DMARK
2b09					CALLMONITOR 
2b09 cd 20 17			call break_point_state  
2b0c				endm  
# End of macro CALLMONITOR
2b0c				endif 
2b0c			 
2b0c 18 06			jr .listpush 
2b0e			 
2b0e			;.lnuword:	pop hl 
2b0e			;		call forth_tok_next 
2b0e			;		jp .ldouscan  
2b0e			 
2b0e			.lunotfound:		  
2b0e			 
2b0e			 
2b0e					 
2b0e					FORTH_DSP_POP 
2b0e cd 5f 1f			call macro_forth_dsp_pop 
2b11				endm 
# End of macro FORTH_DSP_POP
2b11 21 1a 2b				ld hl, .luno 
2b14						 
2b14			 
2b14			.listpush: 
2b14 cd 1e 1d				call forth_push_str 
2b17			 
2b17			 
2b17			 
2b17					NEXTW 
2b17 c3 19 20			jp macro_next 
2b1a				endm 
# End of macro NEXTW
2b1a			 
2b1a .. 00		.luno:    db "Not found",0 
2b24			 
2b24			 
2b24			 
2b24			 
2b24			 
2b24			;		push hl   ; save pointer to start of uword def string 
2b24			; 
2b24			;; look for FORTH_EOL_LINE 
2b24			;		ld a, FORTH_END_BUFFER 
2b24			;		call strlent 
2b24			; 
2b24			;		inc hl		 ; space for coln def 
2b24			;		inc hl 
2b24			;		inc hl          ; space for terms 
2b24			;		inc hl 
2b24			; 
2b24			;		ld a, 20   ; TODO get actual length 
2b24			;		call addatohl    ; include a random amount of room for the uword name 
2b24			; 
2b24			;		 
2b24			;	if DEBUG_FORTH_WORDS 
2b24			;		DMARK "Lt1" 
2b24			;		CALLMONITOR 
2b24			;	endif 
2b24			;		 
2b24			; 
2b24			;; malloc space for the string because we cant change it 
2b24			; 
2b24			;		call malloc 
2b24			;	if DEBUG_FORTH_MALLOC_GUARD 
2b24			;		push af 
2b24			;		call ishlzero 
2b24			;		pop af 
2b24			;		 
2b24			;		call z,malloc_error 
2b24			;	endif 
2b24			; 
2b24			;	if DEBUG_FORTH_WORDS 
2b24			;		DMARK "Lt2" 
2b24			;		CALLMONITOR 
2b24			;	endif 
2b24			;		pop de 
2b24			;		push hl    ; push the malloc to release later 
2b24			;		push hl   ;  push back a copy for the later stack push 
2b24			;		 
2b24			;; copy the string swapping out the zero terms for spaces 
2b24			; 
2b24			;		; de has our source 
2b24			;		; hl has our dest 
2b24			; 
2b24			;; add the coln def 
2b24			; 
2b24			;		ld a, ':' 
2b24			;		ld (hl), a 
2b24			;		inc hl 
2b24			;		ld a, ' ' 
2b24			;		ld (hl), a 
2b24			;		inc hl 
2b24			; 
2b24			;; add the uname word 
2b24			;		push de   ; save our string for now 
2b24			;		ex de, hl 
2b24			; 
2b24			;		FORTH_DSP_VALUE 
2b24			;		;v5 FORTH_DSP_VALUE 
2b24			; 
2b24			;		inc hl   ; skip type but we know by now this is OK 
2b24			; 
2b24			;.luword:	ld a,(hl) 
2b24			;		cp 0 
2b24			;		jr z, .luword2 
2b24			;		ld (de), a 
2b24			;		inc de 
2b24			;		inc hl 
2b24			;		jr .luword 
2b24			; 
2b24			;.luword2:	ld a, ' ' 
2b24			;		ld (de), a 
2b24			;;		inc hl 
2b24			;;		inc de 
2b24			;;		ld (de), a 
2b24			;;		inc hl 
2b24			;		inc de 
2b24			; 
2b24			;		ex de, hl 
2b24			;		pop de 
2b24			;		 
2b24			;		 
2b24			; 
2b24			;; detoken that string and copy it 
2b24			; 
2b24			;	if DEBUG_FORTH_WORDS 
2b24			;		DMARK "Lt2" 
2b24			;		CALLMONITOR 
2b24			;	endif 
2b24			;.ldetok:	ld a, (de) 
2b24			;		cp FORTH_END_BUFFER 
2b24			;		jr z, .ldetokend 
2b24			;		; swap out any zero term for space 
2b24			;		cp 0 
2b24			;		jr nz, .ldetoknext 
2b24			;		ld a, ' ' 
2b24			; 
2b24			;	if DEBUG_FORTH_WORDS 
2b24			;		DMARK "LtS" 
2b24			;		CALLMONITOR 
2b24			;	endif 
2b24			;.ldetoknext:	ld (hl), a 
2b24			;		inc de 
2b24			;		inc hl 
2b24			;		jr .ldetok 
2b24			; 
2b24			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b24			;		ld (hl), a  
2b24			; 
2b24			;; free that temp malloc 
2b24			; 
2b24			;		pop hl    
2b24			; 
2b24			;	if DEBUG_FORTH_WORDS 
2b24			;		DMARK "Lt4" 
2b24			;		CALLMONITOR 
2b24			;	endif 
2b24			;		call forth_apushstrhl 
2b24			; 
2b24			;		; get rid of temp malloc area 
2b24			; 
2b24			;		pop hl 
2b24			;		call free 
2b24			; 
2b24			;		jr .ludone 
2b24			; 
2b24			;.lnuword:	pop hl 
2b24			;		call forth_tok_next 
2b24			;		jp .ldouscan  
2b24			; 
2b24			;.ludone:		 pop hl 
2b24			; 
2b24					NEXTW 
2b24 c3 19 20			jp macro_next 
2b27				endm 
# End of macro NEXTW
2b27			 
2b27			.FORGET: 
2b27				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b27 5d				db WORD_SYS_CORE+73             
2b28 a0 2b			dw .NOP            
2b2a 07				db 6 + 1 
2b2b .. 00			db "FORGET",0              
2b32				endm 
# End of macro CWHEAD
2b32			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b32			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b32			; | |  
2b32			; | | e.g. "MORE" forget 
2b32					if DEBUG_FORTH_WORDS_KEY 
2b32						DMARK "FRG" 
2b32 f5				push af  
2b33 3a 47 2b			ld a, (.dmark)  
2b36 32 bd fb			ld (debug_mark),a  
2b39 3a 48 2b			ld a, (.dmark+1)  
2b3c 32 be fb			ld (debug_mark+1),a  
2b3f 3a 49 2b			ld a, (.dmark+2)  
2b42 32 bf fb			ld (debug_mark+2),a  
2b45 18 03			jr .pastdmark  
2b47 ..			.dmark: db "FRG"  
2b4a f1			.pastdmark: pop af  
2b4b			endm  
# End of macro DMARK
2b4b						CALLMONITOR 
2b4b cd 20 17			call break_point_state  
2b4e				endm  
# End of macro CALLMONITOR
2b4e					endif 
2b4e			 
2b4e				; find uword 
2b4e			        ; update start of word with "_" 
2b4e				; replace uword with deleted flag 
2b4e			 
2b4e			 
2b4e			;	if DEBUG_FORTH_WORDS 
2b4e			;		DMARK "FOG" 
2b4e			;		CALLMONITOR 
2b4e			;	endif 
2b4e			 
2b4e			 
2b4e					; Get ptr to the word we need to look up 
2b4e			 
2b4e					FORTH_DSP_VALUEHL 
2b4e cd a7 1e			call macro_dsp_valuehl 
2b51				endm 
# End of macro FORTH_DSP_VALUEHL
2b51					;v5 FORTH_DSP_VALUE 
2b51				; TODO type check 
2b51			;		inc hl    ; Skip type check  
2b51 e5					push hl 
2b52 c1					pop bc 
2b53			;		ex de, hl    ; put into DE 
2b53			 
2b53			 
2b53 21 00 80				ld hl, baseram 
2b56					;ld hl, baseusermem 
2b56			 
2b56				; skip dict stub 
2b56			;	call forth_tok_next 
2b56 e5			push hl   ; sacreifical push 
2b57			 
2b57			.fldouscanm: 
2b57 e1				pop hl 
2b58			.fldouscan: 
2b58			;	if DEBUG_FORTH_WORDS 
2b58			;		DMARK "LSs" 
2b58			;		CALLMONITOR 
2b58			;	endif 
2b58				; skip dict stub 
2b58 cd 6a 21				call forth_tok_next 
2b5b			 
2b5b			 
2b5b			; while we have words to look for 
2b5b			 
2b5b 7e				ld a, (hl)      
2b5c			;	if DEBUG_FORTH_WORDS 
2b5c			;		DMARK "LSk" 
2b5c			;		CALLMONITOR 
2b5c			;	endif 
2b5c fe 00				cp WORD_SYS_END 
2b5e ca 9a 2b				jp z, .flunotfound 
2b61 fe 01				cp WORD_SYS_UWORD 
2b63 c2 58 2b				jp nz, .fldouscan 
2b66			 
2b66			;	if DEBUG_FORTH_WORDS 
2b66			;		DMARK "LSu" 
2b66			;		CALLMONITOR 
2b66			;	endif 
2b66			 
2b66					; found a uword but is it the one we want... 
2b66			 
2b66 c5					push bc     ; uword to find is on bc 
2b67 d1					pop de 
2b68			 
2b68 e5					push hl  ; to save the ptr 
2b69			 
2b69					; skip opcode 
2b69 23					inc hl  
2b6a					; skip next ptr 
2b6a 23					inc hl  
2b6b 23					inc hl 
2b6c					; skip len 
2b6c 23					inc hl 
2b6d			 
2b6d			;	if DEBUG_FORTH_WORDS 
2b6d			;		DMARK "LSc" 
2b6d			;		CALLMONITOR 
2b6d			;	endif 
2b6d cd 9c 11				call strcmp 
2b70 c2 57 2b				jp nz, .fldouscanm 
2b73			; 
2b73			; 
2b73			;; while we have words to look for 
2b73			; 
2b73			;.fdouscan:	ld a, (hl)      
2b73			;	if DEBUG_FORTH_WORDS 
2b73			;		DMARK "LSs" 
2b73			;		CALLMONITOR 
2b73			;	endif 
2b73			;		cp WORD_SYS_END 
2b73			;		jp z, .fudone 
2b73			;		cp WORD_SYS_UWORD 
2b73			;		jp nz, .fnuword 
2b73			; 
2b73			;	if DEBUG_FORTH_WORDS 
2b73			;		DMARK "FGu" 
2b73			;		CALLMONITOR 
2b73			;	endif 
2b73			; 
2b73			;		; found a uword but is it the one we want... 
2b73			; 
2b73			; 
2b73			;	        pop de   ; get back the dsp name 
2b73			;		push de 
2b73			; 
2b73			;		push hl  ; to save the ptr 
2b73			; 
2b73			;		; skip opcode 
2b73			;		inc hl  
2b73			;		; skip next ptr 
2b73			;		inc hl  
2b73			;		inc hl 
2b73			;		; skip len 
2b73			;		inc hl 
2b73			; 
2b73			;	if DEBUG_FORTH_WORDS 
2b73			;		DMARK "FGc" 
2b73			;		CALLMONITOR 
2b73			;	endif 
2b73			;		call strcmp 
2b73			;		jp nz, .fnuword 
2b73			 
2b73			 
2b73 e1			pop hl 
2b74			 
2b74				 
2b74				if DEBUG_FORTH_WORDS 
2b74					DMARK "FGm" 
2b74 f5				push af  
2b75 3a 89 2b			ld a, (.dmark)  
2b78 32 bd fb			ld (debug_mark),a  
2b7b 3a 8a 2b			ld a, (.dmark+1)  
2b7e 32 be fb			ld (debug_mark+1),a  
2b81 3a 8b 2b			ld a, (.dmark+2)  
2b84 32 bf fb			ld (debug_mark+2),a  
2b87 18 03			jr .pastdmark  
2b89 ..			.dmark: db "FGm"  
2b8c f1			.pastdmark: pop af  
2b8d			endm  
# End of macro DMARK
2b8d					CALLMONITOR 
2b8d cd 20 17			call break_point_state  
2b90				endm  
# End of macro CALLMONITOR
2b90				endif 
2b90			 
2b90			 
2b90			 
2b90					; we have a uword so push its name to the stack 
2b90			 
2b90			;	   	push hl  ; save so we can move to next dict block 
2b90			;pop hl 
2b90			 
2b90					; update opcode to deleted 
2b90 3e 03				ld a, WORD_SYS_DELETED 
2b92 77					ld (hl), a 
2b93			 
2b93 23					inc hl  
2b94					; skip next ptr 
2b94 23					inc hl  
2b95 23					inc hl 
2b96					; skip len 
2b96 23					inc hl 
2b97			 
2b97					; TODO change parser to skip deleted words but for now mark it out 
2b97 3e 5f				ld a, "_" 
2b99 77					ld  (hl),a 
2b9a			 
2b9a			;		jr .fudone 
2b9a			; 
2b9a			;.fnuword:	pop hl 
2b9a			;		call forth_tok_next 
2b9a			;		jp .fdouscan  
2b9a			 
2b9a			.flunotfound:		  
2b9a			 
2b9a			 
2b9a					 
2b9a					FORTH_DSP_POP 
2b9a cd 5f 1f			call macro_forth_dsp_pop 
2b9d				endm 
# End of macro FORTH_DSP_POP
2b9d			;		ld hl, .luno 
2b9d			;.fudone:		 pop hl 
2b9d					NEXTW 
2b9d c3 19 20			jp macro_next 
2ba0				endm 
# End of macro NEXTW
2ba0			.NOP: 
2ba0				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ba0 61				db WORD_SYS_CORE+77             
2ba1 c7 2b			dw .COMO            
2ba3 04				db 3 + 1 
2ba4 .. 00			db "NOP",0              
2ba8				endm 
# End of macro CWHEAD
2ba8			; | NOP (  --  ) Do nothing | DONE 
2ba8					if DEBUG_FORTH_WORDS_KEY 
2ba8						DMARK "NOP" 
2ba8 f5				push af  
2ba9 3a bd 2b			ld a, (.dmark)  
2bac 32 bd fb			ld (debug_mark),a  
2baf 3a be 2b			ld a, (.dmark+1)  
2bb2 32 be fb			ld (debug_mark+1),a  
2bb5 3a bf 2b			ld a, (.dmark+2)  
2bb8 32 bf fb			ld (debug_mark+2),a  
2bbb 18 03			jr .pastdmark  
2bbd ..			.dmark: db "NOP"  
2bc0 f1			.pastdmark: pop af  
2bc1			endm  
# End of macro DMARK
2bc1						CALLMONITOR 
2bc1 cd 20 17			call break_point_state  
2bc4				endm  
# End of macro CALLMONITOR
2bc4					endif 
2bc4				       NEXTW 
2bc4 c3 19 20			jp macro_next 
2bc7				endm 
# End of macro NEXTW
2bc7			.COMO: 
2bc7				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bc7 6e				db WORD_SYS_CORE+90             
2bc8 19 2c			dw .COMC            
2bca 02				db 1 + 1 
2bcb .. 00			db "(",0              
2bcd				endm 
# End of macro CWHEAD
2bcd			; | ( ( -- )  Start of comment | DONE 
2bcd			 
2bcd			 
2bcd 2a a4 f2				ld hl, ( os_tok_ptr) 
2bd0 11 14 2c			ld de, .closepar 
2bd3					 
2bd3					if DEBUG_FORTH_WORDS 
2bd3						DMARK ").." 
2bd3 f5				push af  
2bd4 3a e8 2b			ld a, (.dmark)  
2bd7 32 bd fb			ld (debug_mark),a  
2bda 3a e9 2b			ld a, (.dmark+1)  
2bdd 32 be fb			ld (debug_mark+1),a  
2be0 3a ea 2b			ld a, (.dmark+2)  
2be3 32 bf fb			ld (debug_mark+2),a  
2be6 18 03			jr .pastdmark  
2be8 ..			.dmark: db ").."  
2beb f1			.pastdmark: pop af  
2bec			endm  
# End of macro DMARK
2bec						CALLMONITOR 
2bec cd 20 17			call break_point_state  
2bef				endm  
# End of macro CALLMONITOR
2bef					endif 
2bef cd 34 21			call findnexttok  
2bf2			 
2bf2					if DEBUG_FORTH_WORDS 
2bf2						DMARK "IF5" 
2bf2 f5				push af  
2bf3 3a 07 2c			ld a, (.dmark)  
2bf6 32 bd fb			ld (debug_mark),a  
2bf9 3a 08 2c			ld a, (.dmark+1)  
2bfc 32 be fb			ld (debug_mark+1),a  
2bff 3a 09 2c			ld a, (.dmark+2)  
2c02 32 bf fb			ld (debug_mark+2),a  
2c05 18 03			jr .pastdmark  
2c07 ..			.dmark: db "IF5"  
2c0a f1			.pastdmark: pop af  
2c0b			endm  
# End of macro DMARK
2c0b						CALLMONITOR 
2c0b cd 20 17			call break_point_state  
2c0e				endm  
# End of macro CALLMONITOR
2c0e					endif 
2c0e				; replace below with ) exec using tok_ptr 
2c0e 22 a4 f2			ld (os_tok_ptr), hl 
2c11 c3 aa 20			jp exec1 
2c14			 
2c14 .. 00			.closepar:   db ")",0 
2c16			 
2c16				       NEXTW 
2c16 c3 19 20			jp macro_next 
2c19				endm 
# End of macro NEXTW
2c19			.COMC: 
2c19				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c19 6f				db WORD_SYS_CORE+91             
2c1a 22 2c			dw .SCRATCH            
2c1c 02				db 1 + 1 
2c1d .. 00			db ")",0              
2c1f				endm 
# End of macro CWHEAD
2c1f			; | ) ( -- )  End of comment |  DONE  
2c1f				       NEXTW 
2c1f c3 19 20			jp macro_next 
2c22				endm 
# End of macro NEXTW
2c22			 
2c22			.SCRATCH: 
2c22				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c22 6f				db WORD_SYS_CORE+91             
2c23 5d 2c			dw .INC            
2c25 08				db 7 + 1 
2c26 .. 00			db "SCRATCH",0              
2c2e				endm 
# End of macro CWHEAD
2c2e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c2e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c2e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c2e			; | |  
2c2e			; | | e.g.    : score $00 scratch ; 
2c2e			; | |  
2c2e			; | | $00 score ! 
2c2e			; | | $01 score +! 
2c2e			; | |  
2c2e			; | | e.g.   : varword $0a scratch ;  
2c2e			; | | 
2c2e			; | | $8000 varword ! 
2c2e					if DEBUG_FORTH_WORDS_KEY 
2c2e						DMARK "SCR" 
2c2e f5				push af  
2c2f 3a 43 2c			ld a, (.dmark)  
2c32 32 bd fb			ld (debug_mark),a  
2c35 3a 44 2c			ld a, (.dmark+1)  
2c38 32 be fb			ld (debug_mark+1),a  
2c3b 3a 45 2c			ld a, (.dmark+2)  
2c3e 32 bf fb			ld (debug_mark+2),a  
2c41 18 03			jr .pastdmark  
2c43 ..			.dmark: db "SCR"  
2c46 f1			.pastdmark: pop af  
2c47			endm  
# End of macro DMARK
2c47						CALLMONITOR 
2c47 cd 20 17			call break_point_state  
2c4a				endm  
# End of macro CALLMONITOR
2c4a					endif 
2c4a			 
2c4a					FORTH_DSP_VALUEHL 
2c4a cd a7 1e			call macro_dsp_valuehl 
2c4d				endm 
# End of macro FORTH_DSP_VALUEHL
2c4d				 
2c4d					FORTH_DSP_POP 
2c4d cd 5f 1f			call macro_forth_dsp_pop 
2c50				endm 
# End of macro FORTH_DSP_POP
2c50			 
2c50 7d					ld a, l 
2c51 21 c8 f4				ld hl, os_var_array 
2c54 cd 06 0d				call addatohl 
2c57			 
2c57 cd b0 1c				call forth_push_numhl 
2c5a			 
2c5a				       NEXTW 
2c5a c3 19 20			jp macro_next 
2c5d				endm 
# End of macro NEXTW
2c5d			 
2c5d			.INC: 
2c5d				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c5d 6f				db WORD_SYS_CORE+91             
2c5e b1 2c			dw .DEC            
2c60 03				db 2 + 1 
2c61 .. 00			db "+!",0              
2c64				endm 
# End of macro CWHEAD
2c64			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c64					if DEBUG_FORTH_WORDS_KEY 
2c64						DMARK "+s_" 
2c64 f5				push af  
2c65 3a 79 2c			ld a, (.dmark)  
2c68 32 bd fb			ld (debug_mark),a  
2c6b 3a 7a 2c			ld a, (.dmark+1)  
2c6e 32 be fb			ld (debug_mark+1),a  
2c71 3a 7b 2c			ld a, (.dmark+2)  
2c74 32 bf fb			ld (debug_mark+2),a  
2c77 18 03			jr .pastdmark  
2c79 ..			.dmark: db "+s_"  
2c7c f1			.pastdmark: pop af  
2c7d			endm  
# End of macro DMARK
2c7d						CALLMONITOR 
2c7d cd 20 17			call break_point_state  
2c80				endm  
# End of macro CALLMONITOR
2c80					endif 
2c80			 
2c80					FORTH_DSP_VALUEHL 
2c80 cd a7 1e			call macro_dsp_valuehl 
2c83				endm 
# End of macro FORTH_DSP_VALUEHL
2c83			 
2c83 e5					push hl   ; save address 
2c84			 
2c84					FORTH_DSP_POP 
2c84 cd 5f 1f			call macro_forth_dsp_pop 
2c87				endm 
# End of macro FORTH_DSP_POP
2c87			 
2c87					FORTH_DSP_VALUEHL 
2c87 cd a7 1e			call macro_dsp_valuehl 
2c8a				endm 
# End of macro FORTH_DSP_VALUEHL
2c8a			 
2c8a					FORTH_DSP_POP 
2c8a cd 5f 1f			call macro_forth_dsp_pop 
2c8d				endm 
# End of macro FORTH_DSP_POP
2c8d			 
2c8d					; hl contains value to add to byte at a 
2c8d				 
2c8d eb					ex de, hl 
2c8e			 
2c8e e1					pop hl 
2c8f			 
2c8f					if DEBUG_FORTH_WORDS 
2c8f						DMARK "INC" 
2c8f f5				push af  
2c90 3a a4 2c			ld a, (.dmark)  
2c93 32 bd fb			ld (debug_mark),a  
2c96 3a a5 2c			ld a, (.dmark+1)  
2c99 32 be fb			ld (debug_mark+1),a  
2c9c 3a a6 2c			ld a, (.dmark+2)  
2c9f 32 bf fb			ld (debug_mark+2),a  
2ca2 18 03			jr .pastdmark  
2ca4 ..			.dmark: db "INC"  
2ca7 f1			.pastdmark: pop af  
2ca8			endm  
# End of macro DMARK
2ca8						CALLMONITOR 
2ca8 cd 20 17			call break_point_state  
2cab				endm  
# End of macro CALLMONITOR
2cab					endif 
2cab			 
2cab 7e					ld a,(hl) 
2cac 83					add e 
2cad 77					ld (hl),a 
2cae			 
2cae			 
2cae			 
2cae				       NEXTW 
2cae c3 19 20			jp macro_next 
2cb1				endm 
# End of macro NEXTW
2cb1			 
2cb1			.DEC: 
2cb1				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cb1 6f				db WORD_SYS_CORE+91             
2cb2 02 2d			dw .INC2            
2cb4 03				db 2 + 1 
2cb5 .. 00			db "-!",0              
2cb8				endm 
# End of macro CWHEAD
2cb8			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cb8					if DEBUG_FORTH_WORDS_KEY 
2cb8						DMARK "-s_" 
2cb8 f5				push af  
2cb9 3a cd 2c			ld a, (.dmark)  
2cbc 32 bd fb			ld (debug_mark),a  
2cbf 3a ce 2c			ld a, (.dmark+1)  
2cc2 32 be fb			ld (debug_mark+1),a  
2cc5 3a cf 2c			ld a, (.dmark+2)  
2cc8 32 bf fb			ld (debug_mark+2),a  
2ccb 18 03			jr .pastdmark  
2ccd ..			.dmark: db "-s_"  
2cd0 f1			.pastdmark: pop af  
2cd1			endm  
# End of macro DMARK
2cd1						CALLMONITOR 
2cd1 cd 20 17			call break_point_state  
2cd4				endm  
# End of macro CALLMONITOR
2cd4					endif 
2cd4			 
2cd4					FORTH_DSP_VALUEHL 
2cd4 cd a7 1e			call macro_dsp_valuehl 
2cd7				endm 
# End of macro FORTH_DSP_VALUEHL
2cd7			 
2cd7 e5					push hl   ; save address 
2cd8			 
2cd8					FORTH_DSP_POP 
2cd8 cd 5f 1f			call macro_forth_dsp_pop 
2cdb				endm 
# End of macro FORTH_DSP_POP
2cdb			 
2cdb					FORTH_DSP_VALUEHL 
2cdb cd a7 1e			call macro_dsp_valuehl 
2cde				endm 
# End of macro FORTH_DSP_VALUEHL
2cde			 
2cde					; hl contains value to add to byte at a 
2cde				 
2cde eb					ex de, hl 
2cdf			 
2cdf e1					pop hl 
2ce0			 
2ce0					if DEBUG_FORTH_WORDS 
2ce0						DMARK "DEC" 
2ce0 f5				push af  
2ce1 3a f5 2c			ld a, (.dmark)  
2ce4 32 bd fb			ld (debug_mark),a  
2ce7 3a f6 2c			ld a, (.dmark+1)  
2cea 32 be fb			ld (debug_mark+1),a  
2ced 3a f7 2c			ld a, (.dmark+2)  
2cf0 32 bf fb			ld (debug_mark+2),a  
2cf3 18 03			jr .pastdmark  
2cf5 ..			.dmark: db "DEC"  
2cf8 f1			.pastdmark: pop af  
2cf9			endm  
# End of macro DMARK
2cf9						CALLMONITOR 
2cf9 cd 20 17			call break_point_state  
2cfc				endm  
# End of macro CALLMONITOR
2cfc					endif 
2cfc			 
2cfc 7e					ld a,(hl) 
2cfd 93					sub e 
2cfe 77					ld (hl),a 
2cff			 
2cff			 
2cff			 
2cff				       NEXTW 
2cff c3 19 20			jp macro_next 
2d02				endm 
# End of macro NEXTW
2d02			 
2d02			.INC2: 
2d02				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d02 6f				db WORD_SYS_CORE+91             
2d03 ac 2d			dw .DEC2            
2d05 04				db 3 + 1 
2d06 .. 00			db "+2!",0              
2d0a				endm 
# End of macro CWHEAD
2d0a			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d0a			 
2d0a					if DEBUG_FORTH_WORDS_KEY 
2d0a						DMARK "+2s" 
2d0a f5				push af  
2d0b 3a 1f 2d			ld a, (.dmark)  
2d0e 32 bd fb			ld (debug_mark),a  
2d11 3a 20 2d			ld a, (.dmark+1)  
2d14 32 be fb			ld (debug_mark+1),a  
2d17 3a 21 2d			ld a, (.dmark+2)  
2d1a 32 bf fb			ld (debug_mark+2),a  
2d1d 18 03			jr .pastdmark  
2d1f ..			.dmark: db "+2s"  
2d22 f1			.pastdmark: pop af  
2d23			endm  
# End of macro DMARK
2d23						CALLMONITOR 
2d23 cd 20 17			call break_point_state  
2d26				endm  
# End of macro CALLMONITOR
2d26					endif 
2d26			 
2d26					; Address 
2d26			 
2d26					FORTH_DSP_VALUEHL 
2d26 cd a7 1e			call macro_dsp_valuehl 
2d29				endm 
# End of macro FORTH_DSP_VALUEHL
2d29			 
2d29 e5					push hl    ; save address 
2d2a			 
2d2a					; load content into de 
2d2a			 
2d2a 5e					ld e,(hl) 
2d2b 23					inc hl 
2d2c 56					ld d, (hl) 
2d2d			 
2d2d					if DEBUG_FORTH_WORDS 
2d2d						DMARK "+2a" 
2d2d f5				push af  
2d2e 3a 42 2d			ld a, (.dmark)  
2d31 32 bd fb			ld (debug_mark),a  
2d34 3a 43 2d			ld a, (.dmark+1)  
2d37 32 be fb			ld (debug_mark+1),a  
2d3a 3a 44 2d			ld a, (.dmark+2)  
2d3d 32 bf fb			ld (debug_mark+2),a  
2d40 18 03			jr .pastdmark  
2d42 ..			.dmark: db "+2a"  
2d45 f1			.pastdmark: pop af  
2d46			endm  
# End of macro DMARK
2d46						CALLMONITOR 
2d46 cd 20 17			call break_point_state  
2d49				endm  
# End of macro CALLMONITOR
2d49					endif 
2d49			 
2d49					FORTH_DSP_POP 
2d49 cd 5f 1f			call macro_forth_dsp_pop 
2d4c				endm 
# End of macro FORTH_DSP_POP
2d4c			 
2d4c					; Get value to add 
2d4c			 
2d4c					FORTH_DSP_VALUE 
2d4c cd 90 1e			call macro_forth_dsp_value 
2d4f				endm 
# End of macro FORTH_DSP_VALUE
2d4f			 
2d4f					if DEBUG_FORTH_WORDS 
2d4f						DMARK "+2v" 
2d4f f5				push af  
2d50 3a 64 2d			ld a, (.dmark)  
2d53 32 bd fb			ld (debug_mark),a  
2d56 3a 65 2d			ld a, (.dmark+1)  
2d59 32 be fb			ld (debug_mark+1),a  
2d5c 3a 66 2d			ld a, (.dmark+2)  
2d5f 32 bf fb			ld (debug_mark+2),a  
2d62 18 03			jr .pastdmark  
2d64 ..			.dmark: db "+2v"  
2d67 f1			.pastdmark: pop af  
2d68			endm  
# End of macro DMARK
2d68						CALLMONITOR 
2d68 cd 20 17			call break_point_state  
2d6b				endm  
# End of macro CALLMONITOR
2d6b					endif 
2d6b			 
2d6b 19					add hl, de 
2d6c			 
2d6c					if DEBUG_FORTH_WORDS 
2d6c						DMARK "+2+" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 bd fb			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 be fb			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 bf fb			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "+2+"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 20 17			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88					; move result to de 
2d88			 
2d88 eb					ex de, hl 
2d89			 
2d89					; Address 
2d89			 
2d89 e1					pop hl 
2d8a			 
2d8a					; save it back 
2d8a			 
2d8a 73					ld (hl), e 
2d8b 23					inc hl 
2d8c 72					ld (hl), d 
2d8d			 
2d8d					if DEBUG_FORTH_WORDS 
2d8d						DMARK "+2e" 
2d8d f5				push af  
2d8e 3a a2 2d			ld a, (.dmark)  
2d91 32 bd fb			ld (debug_mark),a  
2d94 3a a3 2d			ld a, (.dmark+1)  
2d97 32 be fb			ld (debug_mark+1),a  
2d9a 3a a4 2d			ld a, (.dmark+2)  
2d9d 32 bf fb			ld (debug_mark+2),a  
2da0 18 03			jr .pastdmark  
2da2 ..			.dmark: db "+2e"  
2da5 f1			.pastdmark: pop af  
2da6			endm  
# End of macro DMARK
2da6						CALLMONITOR 
2da6 cd 20 17			call break_point_state  
2da9				endm  
# End of macro CALLMONITOR
2da9					endif 
2da9			 
2da9			 
2da9			 
2da9			 
2da9			 
2da9				       NEXTW 
2da9 c3 19 20			jp macro_next 
2dac				endm 
# End of macro NEXTW
2dac			 
2dac			.DEC2: 
2dac				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dac 6f				db WORD_SYS_CORE+91             
2dad 58 2e			dw .GET2            
2daf 04				db 3 + 1 
2db0 .. 00			db "-2!",0              
2db4				endm 
# End of macro CWHEAD
2db4			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2db4			 
2db4			 
2db4					if DEBUG_FORTH_WORDS_KEY 
2db4						DMARK "-2s" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 bd fb			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 be fb			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 bf fb			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "-2s"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd						CALLMONITOR 
2dcd cd 20 17			call break_point_state  
2dd0				endm  
# End of macro CALLMONITOR
2dd0					endif 
2dd0			 
2dd0					; Address 
2dd0			 
2dd0					FORTH_DSP_VALUEHL 
2dd0 cd a7 1e			call macro_dsp_valuehl 
2dd3				endm 
# End of macro FORTH_DSP_VALUEHL
2dd3			 
2dd3 e5					push hl    ; save address 
2dd4			 
2dd4					; load content into de 
2dd4			 
2dd4 5e					ld e,(hl) 
2dd5 23					inc hl 
2dd6 56					ld d, (hl) 
2dd7			 
2dd7					if DEBUG_FORTH_WORDS 
2dd7						DMARK "-2a" 
2dd7 f5				push af  
2dd8 3a ec 2d			ld a, (.dmark)  
2ddb 32 bd fb			ld (debug_mark),a  
2dde 3a ed 2d			ld a, (.dmark+1)  
2de1 32 be fb			ld (debug_mark+1),a  
2de4 3a ee 2d			ld a, (.dmark+2)  
2de7 32 bf fb			ld (debug_mark+2),a  
2dea 18 03			jr .pastdmark  
2dec ..			.dmark: db "-2a"  
2def f1			.pastdmark: pop af  
2df0			endm  
# End of macro DMARK
2df0						CALLMONITOR 
2df0 cd 20 17			call break_point_state  
2df3				endm  
# End of macro CALLMONITOR
2df3					endif 
2df3			 
2df3					FORTH_DSP_POP 
2df3 cd 5f 1f			call macro_forth_dsp_pop 
2df6				endm 
# End of macro FORTH_DSP_POP
2df6			 
2df6					; Get value to remove 
2df6			 
2df6					FORTH_DSP_VALUE 
2df6 cd 90 1e			call macro_forth_dsp_value 
2df9				endm 
# End of macro FORTH_DSP_VALUE
2df9			 
2df9					if DEBUG_FORTH_WORDS 
2df9						DMARK "-2v" 
2df9 f5				push af  
2dfa 3a 0e 2e			ld a, (.dmark)  
2dfd 32 bd fb			ld (debug_mark),a  
2e00 3a 0f 2e			ld a, (.dmark+1)  
2e03 32 be fb			ld (debug_mark+1),a  
2e06 3a 10 2e			ld a, (.dmark+2)  
2e09 32 bf fb			ld (debug_mark+2),a  
2e0c 18 03			jr .pastdmark  
2e0e ..			.dmark: db "-2v"  
2e11 f1			.pastdmark: pop af  
2e12			endm  
# End of macro DMARK
2e12						CALLMONITOR 
2e12 cd 20 17			call break_point_state  
2e15				endm  
# End of macro CALLMONITOR
2e15					endif 
2e15			 
2e15 eb					ex de, hl 
2e16 ed 52				sbc hl, de 
2e18			 
2e18					if DEBUG_FORTH_WORDS 
2e18						DMARK "-2d" 
2e18 f5				push af  
2e19 3a 2d 2e			ld a, (.dmark)  
2e1c 32 bd fb			ld (debug_mark),a  
2e1f 3a 2e 2e			ld a, (.dmark+1)  
2e22 32 be fb			ld (debug_mark+1),a  
2e25 3a 2f 2e			ld a, (.dmark+2)  
2e28 32 bf fb			ld (debug_mark+2),a  
2e2b 18 03			jr .pastdmark  
2e2d ..			.dmark: db "-2d"  
2e30 f1			.pastdmark: pop af  
2e31			endm  
# End of macro DMARK
2e31						CALLMONITOR 
2e31 cd 20 17			call break_point_state  
2e34				endm  
# End of macro CALLMONITOR
2e34					endif 
2e34			 
2e34					; move result to de 
2e34			 
2e34 eb					ex de, hl 
2e35			 
2e35					; Address 
2e35			 
2e35 e1					pop hl 
2e36			 
2e36					; save it back 
2e36			 
2e36 73					ld (hl), e 
2e37 23					inc hl 
2e38 72					ld (hl), d 
2e39			 
2e39					if DEBUG_FORTH_WORDS 
2e39						DMARK "-2e" 
2e39 f5				push af  
2e3a 3a 4e 2e			ld a, (.dmark)  
2e3d 32 bd fb			ld (debug_mark),a  
2e40 3a 4f 2e			ld a, (.dmark+1)  
2e43 32 be fb			ld (debug_mark+1),a  
2e46 3a 50 2e			ld a, (.dmark+2)  
2e49 32 bf fb			ld (debug_mark+2),a  
2e4c 18 03			jr .pastdmark  
2e4e ..			.dmark: db "-2e"  
2e51 f1			.pastdmark: pop af  
2e52			endm  
# End of macro DMARK
2e52						CALLMONITOR 
2e52 cd 20 17			call break_point_state  
2e55				endm  
# End of macro CALLMONITOR
2e55					endif 
2e55			 
2e55			 
2e55			 
2e55			 
2e55			 
2e55				       NEXTW 
2e55 c3 19 20			jp macro_next 
2e58				endm 
# End of macro NEXTW
2e58			.GET2: 
2e58				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e58 6f				db WORD_SYS_CORE+91             
2e59 88 2e			dw .BANG2            
2e5b 03				db 2 + 1 
2e5c .. 00			db "2@",0              
2e5f				endm 
# End of macro CWHEAD
2e5f			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e5f					if DEBUG_FORTH_WORDS_KEY 
2e5f						DMARK "2A_" 
2e5f f5				push af  
2e60 3a 74 2e			ld a, (.dmark)  
2e63 32 bd fb			ld (debug_mark),a  
2e66 3a 75 2e			ld a, (.dmark+1)  
2e69 32 be fb			ld (debug_mark+1),a  
2e6c 3a 76 2e			ld a, (.dmark+2)  
2e6f 32 bf fb			ld (debug_mark+2),a  
2e72 18 03			jr .pastdmark  
2e74 ..			.dmark: db "2A_"  
2e77 f1			.pastdmark: pop af  
2e78			endm  
# End of macro DMARK
2e78						CALLMONITOR 
2e78 cd 20 17			call break_point_state  
2e7b				endm  
# End of macro CALLMONITOR
2e7b					endif 
2e7b			 
2e7b					FORTH_DSP_VALUEHL 
2e7b cd a7 1e			call macro_dsp_valuehl 
2e7e				endm 
# End of macro FORTH_DSP_VALUEHL
2e7e			 
2e7e 5e					ld e, (hl) 
2e7f 23					inc hl 
2e80 56					ld d, (hl) 
2e81			 
2e81 eb					ex de, hl 
2e82			 
2e82 cd b0 1c				call forth_push_numhl 
2e85			 
2e85				       NEXTW 
2e85 c3 19 20			jp macro_next 
2e88				endm 
# End of macro NEXTW
2e88			.BANG2: 
2e88				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e88 6f				db WORD_SYS_CORE+91             
2e89 c0 2e			dw .CONFIG            
2e8b 03				db 2 + 1 
2e8c .. 00			db "2!",0              
2e8f				endm 
# End of macro CWHEAD
2e8f			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e8f					if DEBUG_FORTH_WORDS_KEY 
2e8f						DMARK "2S_" 
2e8f f5				push af  
2e90 3a a4 2e			ld a, (.dmark)  
2e93 32 bd fb			ld (debug_mark),a  
2e96 3a a5 2e			ld a, (.dmark+1)  
2e99 32 be fb			ld (debug_mark+1),a  
2e9c 3a a6 2e			ld a, (.dmark+2)  
2e9f 32 bf fb			ld (debug_mark+2),a  
2ea2 18 03			jr .pastdmark  
2ea4 ..			.dmark: db "2S_"  
2ea7 f1			.pastdmark: pop af  
2ea8			endm  
# End of macro DMARK
2ea8						CALLMONITOR 
2ea8 cd 20 17			call break_point_state  
2eab				endm  
# End of macro CALLMONITOR
2eab					endif 
2eab			 
2eab					FORTH_DSP_VALUEHL 
2eab cd a7 1e			call macro_dsp_valuehl 
2eae				endm 
# End of macro FORTH_DSP_VALUEHL
2eae			 
2eae e5					push hl   ; save address 
2eaf			 
2eaf			 
2eaf					FORTH_DSP_POP 
2eaf cd 5f 1f			call macro_forth_dsp_pop 
2eb2				endm 
# End of macro FORTH_DSP_POP
2eb2			 
2eb2					 
2eb2					FORTH_DSP_VALUEHL 
2eb2 cd a7 1e			call macro_dsp_valuehl 
2eb5				endm 
# End of macro FORTH_DSP_VALUEHL
2eb5			 
2eb5					FORTH_DSP_POP 
2eb5 cd 5f 1f			call macro_forth_dsp_pop 
2eb8				endm 
# End of macro FORTH_DSP_POP
2eb8			 
2eb8 eb					ex de, hl    ; value now in de 
2eb9			 
2eb9 e1					pop hl 
2eba			 
2eba 73					ld (hl), e 
2ebb			 
2ebb 23					inc hl 
2ebc			 
2ebc 72					ld (hl), d 
2ebd			 
2ebd			 
2ebd				       NEXTW 
2ebd c3 19 20			jp macro_next 
2ec0				endm 
# End of macro NEXTW
2ec0			.CONFIG: 
2ec0				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ec0 6f				db WORD_SYS_CORE+91             
2ec1 d1 2e			dw .ENDCORE            
2ec3 07				db 6 + 1 
2ec4 .. 00			db "CONFIG",0              
2ecb				endm 
# End of macro CWHEAD
2ecb			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2ecb			 
2ecb cd 66 13				call config 
2ece					NEXTW 
2ece c3 19 20			jp macro_next 
2ed1				endm 
# End of macro NEXTW
2ed1			.ENDCORE: 
2ed1			 
2ed1			; eof 
2ed1			 
2ed1			 
# End of file forth_words_core.asm
2ed1			include "forth_words_flow.asm" 
2ed1			 
2ed1			; | ## Program Flow Words 
2ed1			 
2ed1			.IF: 
2ed1				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ed1 1e				db WORD_SYS_CORE+10             
2ed2 c6 2f			dw .THEN            
2ed4 03				db 2 + 1 
2ed5 .. 00			db "IF",0              
2ed8				endm 
# End of macro CWHEAD
2ed8			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ed8			; 
2ed8					if DEBUG_FORTH_WORDS_KEY 
2ed8						DMARK "IF." 
2ed8 f5				push af  
2ed9 3a ed 2e			ld a, (.dmark)  
2edc 32 bd fb			ld (debug_mark),a  
2edf 3a ee 2e			ld a, (.dmark+1)  
2ee2 32 be fb			ld (debug_mark+1),a  
2ee5 3a ef 2e			ld a, (.dmark+2)  
2ee8 32 bf fb			ld (debug_mark+2),a  
2eeb 18 03			jr .pastdmark  
2eed ..			.dmark: db "IF."  
2ef0 f1			.pastdmark: pop af  
2ef1			endm  
# End of macro DMARK
2ef1						CALLMONITOR 
2ef1 cd 20 17			call break_point_state  
2ef4				endm  
# End of macro CALLMONITOR
2ef4					endif 
2ef4			; eval TOS 
2ef4			 
2ef4				FORTH_DSP_VALUEHL 
2ef4 cd a7 1e			call macro_dsp_valuehl 
2ef7				endm 
# End of macro FORTH_DSP_VALUEHL
2ef7			 
2ef7			;	push hl 
2ef7				FORTH_DSP_POP 
2ef7 cd 5f 1f			call macro_forth_dsp_pop 
2efa				endm 
# End of macro FORTH_DSP_POP
2efa			;	pop hl 
2efa			 
2efa					if DEBUG_FORTH_WORDS 
2efa						DMARK "IF1" 
2efa f5				push af  
2efb 3a 0f 2f			ld a, (.dmark)  
2efe 32 bd fb			ld (debug_mark),a  
2f01 3a 10 2f			ld a, (.dmark+1)  
2f04 32 be fb			ld (debug_mark+1),a  
2f07 3a 11 2f			ld a, (.dmark+2)  
2f0a 32 bf fb			ld (debug_mark+2),a  
2f0d 18 03			jr .pastdmark  
2f0f ..			.dmark: db "IF1"  
2f12 f1			.pastdmark: pop af  
2f13			endm  
# End of macro DMARK
2f13						CALLMONITOR 
2f13 cd 20 17			call break_point_state  
2f16				endm  
# End of macro CALLMONITOR
2f16					endif 
2f16 b7				or a        ; clear carry flag 
2f17 11 00 00			ld de, 0 
2f1a eb				ex de,hl 
2f1b ed 52			sbc hl, de 
2f1d c2 a7 2f			jp nz, .iftrue 
2f20			 
2f20					if DEBUG_FORTH_WORDS 
2f20						DMARK "IF2" 
2f20 f5				push af  
2f21 3a 35 2f			ld a, (.dmark)  
2f24 32 bd fb			ld (debug_mark),a  
2f27 3a 36 2f			ld a, (.dmark+1)  
2f2a 32 be fb			ld (debug_mark+1),a  
2f2d 3a 37 2f			ld a, (.dmark+2)  
2f30 32 bf fb			ld (debug_mark+2),a  
2f33 18 03			jr .pastdmark  
2f35 ..			.dmark: db "IF2"  
2f38 f1			.pastdmark: pop af  
2f39			endm  
# End of macro DMARK
2f39						CALLMONITOR 
2f39 cd 20 17			call break_point_state  
2f3c				endm  
# End of macro CALLMONITOR
2f3c					endif 
2f3c			 
2f3c			; if not true then skip to THEN 
2f3c			 
2f3c				; TODO get tok_ptr 
2f3c				; TODO consume toks until we get to THEN 
2f3c			 
2f3c 2a a4 f2			ld hl, (os_tok_ptr) 
2f3f					if DEBUG_FORTH_WORDS 
2f3f						DMARK "IF3" 
2f3f f5				push af  
2f40 3a 54 2f			ld a, (.dmark)  
2f43 32 bd fb			ld (debug_mark),a  
2f46 3a 55 2f			ld a, (.dmark+1)  
2f49 32 be fb			ld (debug_mark+1),a  
2f4c 3a 56 2f			ld a, (.dmark+2)  
2f4f 32 bf fb			ld (debug_mark+2),a  
2f52 18 03			jr .pastdmark  
2f54 ..			.dmark: db "IF3"  
2f57 f1			.pastdmark: pop af  
2f58			endm  
# End of macro DMARK
2f58						CALLMONITOR 
2f58 cd 20 17			call break_point_state  
2f5b				endm  
# End of macro CALLMONITOR
2f5b						 
2f5b					endif 
2f5b 11 a2 2f			ld de, .ifthen 
2f5e					if DEBUG_FORTH_WORDS 
2f5e						DMARK "IF4" 
2f5e f5				push af  
2f5f 3a 73 2f			ld a, (.dmark)  
2f62 32 bd fb			ld (debug_mark),a  
2f65 3a 74 2f			ld a, (.dmark+1)  
2f68 32 be fb			ld (debug_mark+1),a  
2f6b 3a 75 2f			ld a, (.dmark+2)  
2f6e 32 bf fb			ld (debug_mark+2),a  
2f71 18 03			jr .pastdmark  
2f73 ..			.dmark: db "IF4"  
2f76 f1			.pastdmark: pop af  
2f77			endm  
# End of macro DMARK
2f77						CALLMONITOR 
2f77 cd 20 17			call break_point_state  
2f7a				endm  
# End of macro CALLMONITOR
2f7a					endif 
2f7a cd 34 21			call findnexttok  
2f7d			 
2f7d					if DEBUG_FORTH_WORDS 
2f7d						DMARK "IF5" 
2f7d f5				push af  
2f7e 3a 92 2f			ld a, (.dmark)  
2f81 32 bd fb			ld (debug_mark),a  
2f84 3a 93 2f			ld a, (.dmark+1)  
2f87 32 be fb			ld (debug_mark+1),a  
2f8a 3a 94 2f			ld a, (.dmark+2)  
2f8d 32 bf fb			ld (debug_mark+2),a  
2f90 18 03			jr .pastdmark  
2f92 ..			.dmark: db "IF5"  
2f95 f1			.pastdmark: pop af  
2f96			endm  
# End of macro DMARK
2f96						CALLMONITOR 
2f96 cd 20 17			call break_point_state  
2f99				endm  
# End of macro CALLMONITOR
2f99					endif 
2f99				; TODO replace below with ; exec using tok_ptr 
2f99 22 a4 f2			ld (os_tok_ptr), hl 
2f9c c3 aa 20			jp exec1 
2f9f				NEXTW 
2f9f c3 19 20			jp macro_next 
2fa2				endm 
# End of macro NEXTW
2fa2			 
2fa2 .. 00		.ifthen:  db "THEN",0 
2fa7			 
2fa7			.iftrue:		 
2fa7				; Exec next words normally 
2fa7			 
2fa7				; if true then exec following IF as normal 
2fa7					if DEBUG_FORTH_WORDS 
2fa7						DMARK "IFT" 
2fa7 f5				push af  
2fa8 3a bc 2f			ld a, (.dmark)  
2fab 32 bd fb			ld (debug_mark),a  
2fae 3a bd 2f			ld a, (.dmark+1)  
2fb1 32 be fb			ld (debug_mark+1),a  
2fb4 3a be 2f			ld a, (.dmark+2)  
2fb7 32 bf fb			ld (debug_mark+2),a  
2fba 18 03			jr .pastdmark  
2fbc ..			.dmark: db "IFT"  
2fbf f1			.pastdmark: pop af  
2fc0			endm  
# End of macro DMARK
2fc0						CALLMONITOR 
2fc0 cd 20 17			call break_point_state  
2fc3				endm  
# End of macro CALLMONITOR
2fc3					endif 
2fc3			 
2fc3					NEXTW 
2fc3 c3 19 20			jp macro_next 
2fc6				endm 
# End of macro NEXTW
2fc6			.THEN: 
2fc6				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fc6 1f				db WORD_SYS_CORE+11             
2fc7 ee 2f			dw .ELSE            
2fc9 05				db 4 + 1 
2fca .. 00			db "THEN",0              
2fcf				endm 
# End of macro CWHEAD
2fcf			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fcf					if DEBUG_FORTH_WORDS_KEY 
2fcf						DMARK "THN" 
2fcf f5				push af  
2fd0 3a e4 2f			ld a, (.dmark)  
2fd3 32 bd fb			ld (debug_mark),a  
2fd6 3a e5 2f			ld a, (.dmark+1)  
2fd9 32 be fb			ld (debug_mark+1),a  
2fdc 3a e6 2f			ld a, (.dmark+2)  
2fdf 32 bf fb			ld (debug_mark+2),a  
2fe2 18 03			jr .pastdmark  
2fe4 ..			.dmark: db "THN"  
2fe7 f1			.pastdmark: pop af  
2fe8			endm  
# End of macro DMARK
2fe8						CALLMONITOR 
2fe8 cd 20 17			call break_point_state  
2feb				endm  
# End of macro CALLMONITOR
2feb					endif 
2feb					NEXTW 
2feb c3 19 20			jp macro_next 
2fee				endm 
# End of macro NEXTW
2fee			.ELSE: 
2fee				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fee 20				db WORD_SYS_CORE+12             
2fef 16 30			dw .DO            
2ff1 03				db 2 + 1 
2ff2 .. 00			db "ELSE",0              
2ff7				endm 
# End of macro CWHEAD
2ff7			; | ELSE ( -- ) Not supported - does nothing | TODO 
2ff7			 
2ff7					if DEBUG_FORTH_WORDS_KEY 
2ff7						DMARK "ELS" 
2ff7 f5				push af  
2ff8 3a 0c 30			ld a, (.dmark)  
2ffb 32 bd fb			ld (debug_mark),a  
2ffe 3a 0d 30			ld a, (.dmark+1)  
3001 32 be fb			ld (debug_mark+1),a  
3004 3a 0e 30			ld a, (.dmark+2)  
3007 32 bf fb			ld (debug_mark+2),a  
300a 18 03			jr .pastdmark  
300c ..			.dmark: db "ELS"  
300f f1			.pastdmark: pop af  
3010			endm  
# End of macro DMARK
3010						CALLMONITOR 
3010 cd 20 17			call break_point_state  
3013				endm  
# End of macro CALLMONITOR
3013					endif 
3013			 
3013			 
3013					NEXTW 
3013 c3 19 20			jp macro_next 
3016				endm 
# End of macro NEXTW
3016			.DO: 
3016				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3016 21				db WORD_SYS_CORE+13             
3017 3d 31			dw .LOOP            
3019 03				db 2 + 1 
301a .. 00			db "DO",0              
301d				endm 
# End of macro CWHEAD
301d			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
301d			 
301d					if DEBUG_FORTH_WORDS_KEY 
301d						DMARK "DO." 
301d f5				push af  
301e 3a 32 30			ld a, (.dmark)  
3021 32 bd fb			ld (debug_mark),a  
3024 3a 33 30			ld a, (.dmark+1)  
3027 32 be fb			ld (debug_mark+1),a  
302a 3a 34 30			ld a, (.dmark+2)  
302d 32 bf fb			ld (debug_mark+2),a  
3030 18 03			jr .pastdmark  
3032 ..			.dmark: db "DO."  
3035 f1			.pastdmark: pop af  
3036			endm  
# End of macro DMARK
3036						CALLMONITOR 
3036 cd 20 17			call break_point_state  
3039				endm  
# End of macro CALLMONITOR
3039					endif 
3039			;  push pc to rsp stack past the DO 
3039			 
3039 2a a4 f2				ld hl, (os_tok_ptr) 
303c 23					inc hl   ; D 
303d 23					inc hl  ; O 
303e 23					inc hl   ; null 
303f					if DEBUG_FORTH_WORDS 
303f						DMARK "DO2" 
303f f5				push af  
3040 3a 54 30			ld a, (.dmark)  
3043 32 bd fb			ld (debug_mark),a  
3046 3a 55 30			ld a, (.dmark+1)  
3049 32 be fb			ld (debug_mark+1),a  
304c 3a 56 30			ld a, (.dmark+2)  
304f 32 bf fb			ld (debug_mark+2),a  
3052 18 03			jr .pastdmark  
3054 ..			.dmark: db "DO2"  
3057 f1			.pastdmark: pop af  
3058			endm  
# End of macro DMARK
3058						CALLMONITOR 
3058 cd 20 17			call break_point_state  
305b				endm  
# End of macro CALLMONITOR
305b					endif 
305b					FORTH_RSP_NEXT 
305b cd 57 1c			call macro_forth_rsp_next 
305e				endm 
# End of macro FORTH_RSP_NEXT
305e					if DEBUG_FORTH_WORDS 
305e						DMARK "DO3" 
305e f5				push af  
305f 3a 73 30			ld a, (.dmark)  
3062 32 bd fb			ld (debug_mark),a  
3065 3a 74 30			ld a, (.dmark+1)  
3068 32 be fb			ld (debug_mark+1),a  
306b 3a 75 30			ld a, (.dmark+2)  
306e 32 bf fb			ld (debug_mark+2),a  
3071 18 03			jr .pastdmark  
3073 ..			.dmark: db "DO3"  
3076 f1			.pastdmark: pop af  
3077			endm  
# End of macro DMARK
3077						CALLMONITOR 
3077 cd 20 17			call break_point_state  
307a				endm  
# End of macro CALLMONITOR
307a					endif 
307a			 
307a					;if DEBUG_FORTH_WORDS 
307a				;		push hl 
307a			;		endif  
307a			 
307a			; get counters from data stack 
307a			 
307a			 
307a					FORTH_DSP_VALUEHL 
307a cd a7 1e			call macro_dsp_valuehl 
307d				endm 
# End of macro FORTH_DSP_VALUEHL
307d e5					push hl		 ; hl now has starting counter which needs to be tos 
307e			 
307e					if DEBUG_FORTH_WORDS 
307e						DMARK "DO4" 
307e f5				push af  
307f 3a 93 30			ld a, (.dmark)  
3082 32 bd fb			ld (debug_mark),a  
3085 3a 94 30			ld a, (.dmark+1)  
3088 32 be fb			ld (debug_mark+1),a  
308b 3a 95 30			ld a, (.dmark+2)  
308e 32 bf fb			ld (debug_mark+2),a  
3091 18 03			jr .pastdmark  
3093 ..			.dmark: db "DO4"  
3096 f1			.pastdmark: pop af  
3097			endm  
# End of macro DMARK
3097						CALLMONITOR 
3097 cd 20 17			call break_point_state  
309a				endm  
# End of macro CALLMONITOR
309a					endif 
309a					FORTH_DSP_POP 
309a cd 5f 1f			call macro_forth_dsp_pop 
309d				endm 
# End of macro FORTH_DSP_POP
309d			 
309d					if DEBUG_FORTH_WORDS 
309d						DMARK "DO5" 
309d f5				push af  
309e 3a b2 30			ld a, (.dmark)  
30a1 32 bd fb			ld (debug_mark),a  
30a4 3a b3 30			ld a, (.dmark+1)  
30a7 32 be fb			ld (debug_mark+1),a  
30aa 3a b4 30			ld a, (.dmark+2)  
30ad 32 bf fb			ld (debug_mark+2),a  
30b0 18 03			jr .pastdmark  
30b2 ..			.dmark: db "DO5"  
30b5 f1			.pastdmark: pop af  
30b6			endm  
# End of macro DMARK
30b6						CALLMONITOR 
30b6 cd 20 17			call break_point_state  
30b9				endm  
# End of macro CALLMONITOR
30b9					endif 
30b9			 
30b9					FORTH_DSP_VALUEHL 
30b9 cd a7 1e			call macro_dsp_valuehl 
30bc				endm 
# End of macro FORTH_DSP_VALUEHL
30bc			;		push hl		 ; hl now has starting limit counter 
30bc			 
30bc					if DEBUG_FORTH_WORDS 
30bc						DMARK "DO6" 
30bc f5				push af  
30bd 3a d1 30			ld a, (.dmark)  
30c0 32 bd fb			ld (debug_mark),a  
30c3 3a d2 30			ld a, (.dmark+1)  
30c6 32 be fb			ld (debug_mark+1),a  
30c9 3a d3 30			ld a, (.dmark+2)  
30cc 32 bf fb			ld (debug_mark+2),a  
30cf 18 03			jr .pastdmark  
30d1 ..			.dmark: db "DO6"  
30d4 f1			.pastdmark: pop af  
30d5			endm  
# End of macro DMARK
30d5						CALLMONITOR 
30d5 cd 20 17			call break_point_state  
30d8				endm  
# End of macro CALLMONITOR
30d8					endif 
30d8					FORTH_DSP_POP 
30d8 cd 5f 1f			call macro_forth_dsp_pop 
30db				endm 
# End of macro FORTH_DSP_POP
30db			 
30db			; put counters on the loop stack 
30db			 
30db			;		pop hl			 ; limit counter 
30db d1					pop de			; start counter 
30dc			 
30dc					; push limit counter 
30dc			 
30dc					if DEBUG_FORTH_WORDS 
30dc						DMARK "DO7" 
30dc f5				push af  
30dd 3a f1 30			ld a, (.dmark)  
30e0 32 bd fb			ld (debug_mark),a  
30e3 3a f2 30			ld a, (.dmark+1)  
30e6 32 be fb			ld (debug_mark+1),a  
30e9 3a f3 30			ld a, (.dmark+2)  
30ec 32 bf fb			ld (debug_mark+2),a  
30ef 18 03			jr .pastdmark  
30f1 ..			.dmark: db "DO7"  
30f4 f1			.pastdmark: pop af  
30f5			endm  
# End of macro DMARK
30f5						CALLMONITOR 
30f5 cd 20 17			call break_point_state  
30f8				endm  
# End of macro CALLMONITOR
30f8					endif 
30f8					FORTH_LOOP_NEXT 
30f8 cd d8 1e			call macro_forth_loop_next 
30fb				endm 
# End of macro FORTH_LOOP_NEXT
30fb			 
30fb					; push start counter 
30fb			 
30fb eb					ex de, hl 
30fc					if DEBUG_FORTH_WORDS 
30fc						DMARK "DO7" 
30fc f5				push af  
30fd 3a 11 31			ld a, (.dmark)  
3100 32 bd fb			ld (debug_mark),a  
3103 3a 12 31			ld a, (.dmark+1)  
3106 32 be fb			ld (debug_mark+1),a  
3109 3a 13 31			ld a, (.dmark+2)  
310c 32 bf fb			ld (debug_mark+2),a  
310f 18 03			jr .pastdmark  
3111 ..			.dmark: db "DO7"  
3114 f1			.pastdmark: pop af  
3115			endm  
# End of macro DMARK
3115						CALLMONITOR 
3115 cd 20 17			call break_point_state  
3118				endm  
# End of macro CALLMONITOR
3118					endif 
3118					FORTH_LOOP_NEXT 
3118 cd d8 1e			call macro_forth_loop_next 
311b				endm 
# End of macro FORTH_LOOP_NEXT
311b			 
311b			 
311b					; init first round of I counter 
311b			 
311b 22 c8 f2				ld (os_current_i), hl 
311e			 
311e					if DEBUG_FORTH_WORDS 
311e						DMARK "DO8" 
311e f5				push af  
311f 3a 33 31			ld a, (.dmark)  
3122 32 bd fb			ld (debug_mark),a  
3125 3a 34 31			ld a, (.dmark+1)  
3128 32 be fb			ld (debug_mark+1),a  
312b 3a 35 31			ld a, (.dmark+2)  
312e 32 bf fb			ld (debug_mark+2),a  
3131 18 03			jr .pastdmark  
3133 ..			.dmark: db "DO8"  
3136 f1			.pastdmark: pop af  
3137			endm  
# End of macro DMARK
3137						CALLMONITOR 
3137 cd 20 17			call break_point_state  
313a				endm  
# End of macro CALLMONITOR
313a					endif 
313a			 
313a					NEXTW 
313a c3 19 20			jp macro_next 
313d				endm 
# End of macro NEXTW
313d			.LOOP: 
313d				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
313d 22				db WORD_SYS_CORE+14             
313e 55 32			dw .I            
3140 05				db 4 + 1 
3141 .. 00			db "LOOP",0              
3146				endm 
# End of macro CWHEAD
3146			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3146			 
3146				; pop tos as current loop count to hl 
3146			 
3146				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3146			 
3146				FORTH_LOOP_TOS 
3146 cd 0b 1f			call macro_forth_loop_tos 
3149				endm 
# End of macro FORTH_LOOP_TOS
3149 e5				push hl 
314a			 
314a					if DEBUG_FORTH_WORDS_KEY 
314a						DMARK "LOP" 
314a f5				push af  
314b 3a 5f 31			ld a, (.dmark)  
314e 32 bd fb			ld (debug_mark),a  
3151 3a 60 31			ld a, (.dmark+1)  
3154 32 be fb			ld (debug_mark+1),a  
3157 3a 61 31			ld a, (.dmark+2)  
315a 32 bf fb			ld (debug_mark+2),a  
315d 18 03			jr .pastdmark  
315f ..			.dmark: db "LOP"  
3162 f1			.pastdmark: pop af  
3163			endm  
# End of macro DMARK
3163						CALLMONITOR 
3163 cd 20 17			call break_point_state  
3166				endm  
# End of macro CALLMONITOR
3166					endif 
3166				; next item on the stack is the limit. get it 
3166			 
3166			 
3166				FORTH_LOOP_POP 
3166 cd 15 1f			call macro_forth_loop_pop 
3169				endm 
# End of macro FORTH_LOOP_POP
3169			 
3169				FORTH_LOOP_TOS 
3169 cd 0b 1f			call macro_forth_loop_tos 
316c				endm 
# End of macro FORTH_LOOP_TOS
316c			 
316c d1				pop de		 ; de = i, hl = limit 
316d			 
316d					if DEBUG_FORTH_WORDS 
316d						DMARK "LP1" 
316d f5				push af  
316e 3a 82 31			ld a, (.dmark)  
3171 32 bd fb			ld (debug_mark),a  
3174 3a 83 31			ld a, (.dmark+1)  
3177 32 be fb			ld (debug_mark+1),a  
317a 3a 84 31			ld a, (.dmark+2)  
317d 32 bf fb			ld (debug_mark+2),a  
3180 18 03			jr .pastdmark  
3182 ..			.dmark: db "LP1"  
3185 f1			.pastdmark: pop af  
3186			endm  
# End of macro DMARK
3186						CALLMONITOR 
3186 cd 20 17			call break_point_state  
3189				endm  
# End of macro CALLMONITOR
3189					endif 
3189			 
3189				; go back to previous word 
3189			 
3189 d5				push de    ; save I for inc later 
318a			 
318a			 
318a				; get limit 
318a				;  is I at limit? 
318a			 
318a			 
318a					if DEBUG_FORTH_WORDS 
318a						DMARK "LP1" 
318a f5				push af  
318b 3a 9f 31			ld a, (.dmark)  
318e 32 bd fb			ld (debug_mark),a  
3191 3a a0 31			ld a, (.dmark+1)  
3194 32 be fb			ld (debug_mark+1),a  
3197 3a a1 31			ld a, (.dmark+2)  
319a 32 bf fb			ld (debug_mark+2),a  
319d 18 03			jr .pastdmark  
319f ..			.dmark: db "LP1"  
31a2 f1			.pastdmark: pop af  
31a3			endm  
# End of macro DMARK
31a3						CALLMONITOR 
31a3 cd 20 17			call break_point_state  
31a6				endm  
# End of macro CALLMONITOR
31a6					endif 
31a6			 
31a6 ed 52			sbc hl, de 
31a8			 
31a8			 
31a8				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31a8			 
31a8 20 26				jr nz, .loopnotdone 
31aa			 
31aa e1				pop hl   ; get rid of saved I 
31ab				FORTH_LOOP_POP     ; get rid of limit 
31ab cd 15 1f			call macro_forth_loop_pop 
31ae				endm 
# End of macro FORTH_LOOP_POP
31ae			 
31ae				FORTH_RSP_POP     ; get rid of DO ptr 
31ae cd 78 1c			call macro_forth_rsp_pop 
31b1				endm 
# End of macro FORTH_RSP_POP
31b1			 
31b1			if DEBUG_FORTH_WORDS 
31b1						DMARK "LP>" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 bd fb			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 be fb			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 bf fb			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "LP>"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca				CALLMONITOR 
31ca cd 20 17			call break_point_state  
31cd				endm  
# End of macro CALLMONITOR
31cd			endif 
31cd			 
31cd					NEXTW 
31cd c3 19 20			jp macro_next 
31d0				endm 
# End of macro NEXTW
31d0				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31d0			 
31d0			.loopnotdone: 
31d0			 
31d0 e1				pop hl    ; get I 
31d1 23				inc hl 
31d2			 
31d2			   	; save new I 
31d2			 
31d2			 
31d2					; set I counter 
31d2			 
31d2 22 c8 f2				ld (os_current_i), hl 
31d5			 
31d5					if DEBUG_FORTH_WORDS 
31d5						DMARK "LPN" 
31d5 f5				push af  
31d6 3a ea 31			ld a, (.dmark)  
31d9 32 bd fb			ld (debug_mark),a  
31dc 3a eb 31			ld a, (.dmark+1)  
31df 32 be fb			ld (debug_mark+1),a  
31e2 3a ec 31			ld a, (.dmark+2)  
31e5 32 bf fb			ld (debug_mark+2),a  
31e8 18 03			jr .pastdmark  
31ea ..			.dmark: db "LPN"  
31ed f1			.pastdmark: pop af  
31ee			endm  
# End of macro DMARK
31ee					CALLMONITOR 
31ee cd 20 17			call break_point_state  
31f1				endm  
# End of macro CALLMONITOR
31f1					endif 
31f1					 
31f1				FORTH_LOOP_NEXT 
31f1 cd d8 1e			call macro_forth_loop_next 
31f4				endm 
# End of macro FORTH_LOOP_NEXT
31f4			 
31f4			 
31f4					if DEBUG_FORTH_WORDS 
31f4 eb						ex de,hl 
31f5					endif 
31f5			 
31f5			;	; get DO ptr 
31f5			; 
31f5					if DEBUG_FORTH_WORDS 
31f5						DMARK "LP7" 
31f5 f5				push af  
31f6 3a 0a 32			ld a, (.dmark)  
31f9 32 bd fb			ld (debug_mark),a  
31fc 3a 0b 32			ld a, (.dmark+1)  
31ff 32 be fb			ld (debug_mark+1),a  
3202 3a 0c 32			ld a, (.dmark+2)  
3205 32 bf fb			ld (debug_mark+2),a  
3208 18 03			jr .pastdmark  
320a ..			.dmark: db "LP7"  
320d f1			.pastdmark: pop af  
320e			endm  
# End of macro DMARK
320e					CALLMONITOR 
320e cd 20 17			call break_point_state  
3211				endm  
# End of macro CALLMONITOR
3211					endif 
3211				FORTH_RSP_TOS 
3211 cd 6e 1c			call macro_forth_rsp_tos 
3214				endm 
# End of macro FORTH_RSP_TOS
3214			 
3214					if DEBUG_FORTH_WORDS 
3214						DMARK "LP8" 
3214 f5				push af  
3215 3a 29 32			ld a, (.dmark)  
3218 32 bd fb			ld (debug_mark),a  
321b 3a 2a 32			ld a, (.dmark+1)  
321e 32 be fb			ld (debug_mark+1),a  
3221 3a 2b 32			ld a, (.dmark+2)  
3224 32 bf fb			ld (debug_mark+2),a  
3227 18 03			jr .pastdmark  
3229 ..			.dmark: db "LP8"  
322c f1			.pastdmark: pop af  
322d			endm  
# End of macro DMARK
322d					CALLMONITOR 
322d cd 20 17			call break_point_state  
3230				endm  
# End of macro CALLMONITOR
3230					endif 
3230				;push hl 
3230			 
3230				; not going to DO any more 
3230				; get rid of the RSP pointer as DO will add it back in 
3230				;FORTH_RSP_POP 
3230				;pop hl 
3230			 
3230				;ld hl,(cli_ret_sp) 
3230				;ld e, (hl) 
3230				;inc hl 
3230				;ld d, (hl) 
3230				;ex de,hl 
3230 22 a4 f2			ld (os_tok_ptr), hl 
3233					if DEBUG_FORTH_WORDS 
3233						DMARK "LP<" 
3233 f5				push af  
3234 3a 48 32			ld a, (.dmark)  
3237 32 bd fb			ld (debug_mark),a  
323a 3a 49 32			ld a, (.dmark+1)  
323d 32 be fb			ld (debug_mark+1),a  
3240 3a 4a 32			ld a, (.dmark+2)  
3243 32 bf fb			ld (debug_mark+2),a  
3246 18 03			jr .pastdmark  
3248 ..			.dmark: db "LP<"  
324b f1			.pastdmark: pop af  
324c			endm  
# End of macro DMARK
324c					CALLMONITOR 
324c cd 20 17			call break_point_state  
324f				endm  
# End of macro CALLMONITOR
324f				endif 
324f c3 aa 20			jp exec1 
3252			 
3252					 
3252			 
3252			 
3252					NEXTW 
3252 c3 19 20			jp macro_next 
3255				endm 
# End of macro NEXTW
3255			.I:  
3255			 
3255				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3255 5e				db WORD_SYS_CORE+74             
3256 80 32			dw .DLOOP            
3258 02				db 1 + 1 
3259 .. 00			db "I",0              
325b				endm 
# End of macro CWHEAD
325b			; | I ( -- ) Current loop counter | DONE 
325b					if DEBUG_FORTH_WORDS_KEY 
325b						DMARK "I.." 
325b f5				push af  
325c 3a 70 32			ld a, (.dmark)  
325f 32 bd fb			ld (debug_mark),a  
3262 3a 71 32			ld a, (.dmark+1)  
3265 32 be fb			ld (debug_mark+1),a  
3268 3a 72 32			ld a, (.dmark+2)  
326b 32 bf fb			ld (debug_mark+2),a  
326e 18 03			jr .pastdmark  
3270 ..			.dmark: db "I.."  
3273 f1			.pastdmark: pop af  
3274			endm  
# End of macro DMARK
3274						CALLMONITOR 
3274 cd 20 17			call break_point_state  
3277				endm  
# End of macro CALLMONITOR
3277					endif 
3277			 
3277 2a c8 f2				ld hl,(os_current_i) 
327a cd b0 1c				call forth_push_numhl 
327d			 
327d					NEXTW 
327d c3 19 20			jp macro_next 
3280				endm 
# End of macro NEXTW
3280			.DLOOP: 
3280				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3280 5f				db WORD_SYS_CORE+75             
3281 61 33			dw .REPEAT            
3283 06				db 5 + 1 
3284 .. 00			db "-LOOP",0              
328a				endm 
# End of macro CWHEAD
328a			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
328a				; pop tos as current loop count to hl 
328a					if DEBUG_FORTH_WORDS_KEY 
328a						DMARK "-LP" 
328a f5				push af  
328b 3a 9f 32			ld a, (.dmark)  
328e 32 bd fb			ld (debug_mark),a  
3291 3a a0 32			ld a, (.dmark+1)  
3294 32 be fb			ld (debug_mark+1),a  
3297 3a a1 32			ld a, (.dmark+2)  
329a 32 bf fb			ld (debug_mark+2),a  
329d 18 03			jr .pastdmark  
329f ..			.dmark: db "-LP"  
32a2 f1			.pastdmark: pop af  
32a3			endm  
# End of macro DMARK
32a3						CALLMONITOR 
32a3 cd 20 17			call break_point_state  
32a6				endm  
# End of macro CALLMONITOR
32a6					endif 
32a6			 
32a6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32a6			 
32a6				FORTH_LOOP_TOS 
32a6 cd 0b 1f			call macro_forth_loop_tos 
32a9				endm 
# End of macro FORTH_LOOP_TOS
32a9 e5				push hl 
32aa			 
32aa					if DEBUG_FORTH_WORDS 
32aa						DMARK "-LP" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 bd fb			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 be fb			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 bf fb			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "-LP"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3						CALLMONITOR 
32c3 cd 20 17			call break_point_state  
32c6				endm  
# End of macro CALLMONITOR
32c6					endif 
32c6				; next item on the stack is the limit. get it 
32c6			 
32c6			 
32c6				FORTH_LOOP_POP 
32c6 cd 15 1f			call macro_forth_loop_pop 
32c9				endm 
# End of macro FORTH_LOOP_POP
32c9			 
32c9				FORTH_LOOP_TOS 
32c9 cd 0b 1f			call macro_forth_loop_tos 
32cc				endm 
# End of macro FORTH_LOOP_TOS
32cc			 
32cc d1				pop de		 ; de = i, hl = limit 
32cd			 
32cd					if DEBUG_FORTH_WORDS 
32cd						DMARK "-L1" 
32cd f5				push af  
32ce 3a e2 32			ld a, (.dmark)  
32d1 32 bd fb			ld (debug_mark),a  
32d4 3a e3 32			ld a, (.dmark+1)  
32d7 32 be fb			ld (debug_mark+1),a  
32da 3a e4 32			ld a, (.dmark+2)  
32dd 32 bf fb			ld (debug_mark+2),a  
32e0 18 03			jr .pastdmark  
32e2 ..			.dmark: db "-L1"  
32e5 f1			.pastdmark: pop af  
32e6			endm  
# End of macro DMARK
32e6						CALLMONITOR 
32e6 cd 20 17			call break_point_state  
32e9				endm  
# End of macro CALLMONITOR
32e9					endif 
32e9			 
32e9				; go back to previous word 
32e9			 
32e9 d5				push de    ; save I for inc later 
32ea			 
32ea			 
32ea				; get limit 
32ea				;  is I at limit? 
32ea			 
32ea			 
32ea					if DEBUG_FORTH_WORDS 
32ea						DMARK "-L1" 
32ea f5				push af  
32eb 3a ff 32			ld a, (.dmark)  
32ee 32 bd fb			ld (debug_mark),a  
32f1 3a 00 33			ld a, (.dmark+1)  
32f4 32 be fb			ld (debug_mark+1),a  
32f7 3a 01 33			ld a, (.dmark+2)  
32fa 32 bf fb			ld (debug_mark+2),a  
32fd 18 03			jr .pastdmark  
32ff ..			.dmark: db "-L1"  
3302 f1			.pastdmark: pop af  
3303			endm  
# End of macro DMARK
3303						CALLMONITOR 
3303 cd 20 17			call break_point_state  
3306				endm  
# End of macro CALLMONITOR
3306					endif 
3306			 
3306 ed 52			sbc hl, de 
3308			 
3308			 
3308				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3308			 
3308 20 26				jr nz, .mloopnotdone 
330a			 
330a e1				pop hl   ; get rid of saved I 
330b				FORTH_LOOP_POP     ; get rid of limit 
330b cd 15 1f			call macro_forth_loop_pop 
330e				endm 
# End of macro FORTH_LOOP_POP
330e			 
330e				FORTH_RSP_POP     ; get rid of DO ptr 
330e cd 78 1c			call macro_forth_rsp_pop 
3311				endm 
# End of macro FORTH_RSP_POP
3311			 
3311			if DEBUG_FORTH_WORDS 
3311						DMARK "-L>" 
3311 f5				push af  
3312 3a 26 33			ld a, (.dmark)  
3315 32 bd fb			ld (debug_mark),a  
3318 3a 27 33			ld a, (.dmark+1)  
331b 32 be fb			ld (debug_mark+1),a  
331e 3a 28 33			ld a, (.dmark+2)  
3321 32 bf fb			ld (debug_mark+2),a  
3324 18 03			jr .pastdmark  
3326 ..			.dmark: db "-L>"  
3329 f1			.pastdmark: pop af  
332a			endm  
# End of macro DMARK
332a				CALLMONITOR 
332a cd 20 17			call break_point_state  
332d				endm  
# End of macro CALLMONITOR
332d			endif 
332d			 
332d					NEXTW 
332d c3 19 20			jp macro_next 
3330				endm 
# End of macro NEXTW
3330				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3330			 
3330			.mloopnotdone: 
3330			 
3330 e1				pop hl    ; get I 
3331 2b				dec hl 
3332			 
3332			   	; save new I 
3332			 
3332			 
3332					; set I counter 
3332			 
3332 22 c8 f2				ld (os_current_i), hl 
3335			 
3335					 
3335				FORTH_LOOP_NEXT 
3335 cd d8 1e			call macro_forth_loop_next 
3338				endm 
# End of macro FORTH_LOOP_NEXT
3338			 
3338			 
3338					if DEBUG_FORTH_WORDS 
3338 eb						ex de,hl 
3339					endif 
3339			 
3339			;	; get DO ptr 
3339			; 
3339				FORTH_RSP_TOS 
3339 cd 6e 1c			call macro_forth_rsp_tos 
333c				endm 
# End of macro FORTH_RSP_TOS
333c			 
333c				;push hl 
333c			 
333c				; not going to DO any more 
333c				; get rid of the RSP pointer as DO will add it back in 
333c				;FORTH_RSP_POP 
333c				;pop hl 
333c			 
333c			 
333c 22 a4 f2			ld (os_tok_ptr), hl 
333f					if DEBUG_FORTH_WORDS 
333f						DMARK "-L<" 
333f f5				push af  
3340 3a 54 33			ld a, (.dmark)  
3343 32 bd fb			ld (debug_mark),a  
3346 3a 55 33			ld a, (.dmark+1)  
3349 32 be fb			ld (debug_mark+1),a  
334c 3a 56 33			ld a, (.dmark+2)  
334f 32 bf fb			ld (debug_mark+2),a  
3352 18 03			jr .pastdmark  
3354 ..			.dmark: db "-L<"  
3357 f1			.pastdmark: pop af  
3358			endm  
# End of macro DMARK
3358					CALLMONITOR 
3358 cd 20 17			call break_point_state  
335b				endm  
# End of macro CALLMONITOR
335b				endif 
335b c3 aa 20			jp exec1 
335e			 
335e					 
335e			 
335e			 
335e			 
335e				NEXTW 
335e c3 19 20			jp macro_next 
3361				endm 
# End of macro NEXTW
3361			 
3361			 
3361			 
3361			 
3361			.REPEAT: 
3361				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3361 71				db WORD_SYS_CORE+93             
3362 b4 33			dw .UNTIL            
3364 06				db 5 + 1 
3365 .. 00			db "REPEAT",0              
336c				endm 
# End of macro CWHEAD
336c			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
336c			;  push pc to rsp stack past the REPEAT 
336c					if DEBUG_FORTH_WORDS_KEY 
336c						DMARK "REP" 
336c f5				push af  
336d 3a 81 33			ld a, (.dmark)  
3370 32 bd fb			ld (debug_mark),a  
3373 3a 82 33			ld a, (.dmark+1)  
3376 32 be fb			ld (debug_mark+1),a  
3379 3a 83 33			ld a, (.dmark+2)  
337c 32 bf fb			ld (debug_mark+2),a  
337f 18 03			jr .pastdmark  
3381 ..			.dmark: db "REP"  
3384 f1			.pastdmark: pop af  
3385			endm  
# End of macro DMARK
3385						CALLMONITOR 
3385 cd 20 17			call break_point_state  
3388				endm  
# End of macro CALLMONITOR
3388					endif 
3388			 
3388 2a a4 f2				ld hl, (os_tok_ptr) 
338b 23					inc hl   ; R 
338c 23					inc hl  ; E 
338d 23					inc hl   ; P 
338e 23					inc hl   ; E 
338f 23					inc hl   ; A 
3390 23					inc hl   ; T 
3391 23					inc hl   ; zero 
3392					FORTH_RSP_NEXT 
3392 cd 57 1c			call macro_forth_rsp_next 
3395				endm 
# End of macro FORTH_RSP_NEXT
3395			 
3395			 
3395					if DEBUG_FORTH_WORDS 
3395						DMARK "REP" 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 bd fb			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 be fb			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 bf fb			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "REP"  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae						;pop bc    ; TODO BUG ?????? what is this for???? 
33ae						CALLMONITOR 
33ae cd 20 17			call break_point_state  
33b1				endm  
# End of macro CALLMONITOR
33b1					endif 
33b1			 
33b1					NEXTW 
33b1 c3 19 20			jp macro_next 
33b4				endm 
# End of macro NEXTW
33b4			;	       NEXTW 
33b4			 
33b4			.UNTIL: 
33b4				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33b4 72				db WORD_SYS_CORE+94             
33b5 4b 34			dw .ENDFLOW            
33b7 06				db 5 + 1 
33b8 .. 00			db "UNTIL",0              
33be				endm 
# End of macro CWHEAD
33be			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33be			 
33be				; pop tos as check 
33be			 
33be				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33be			 
33be				FORTH_DSP_VALUEHL 
33be cd a7 1e			call macro_dsp_valuehl 
33c1				endm 
# End of macro FORTH_DSP_VALUEHL
33c1			 
33c1					if DEBUG_FORTH_WORDS_KEY 
33c1						DMARK "UNT" 
33c1 f5				push af  
33c2 3a d6 33			ld a, (.dmark)  
33c5 32 bd fb			ld (debug_mark),a  
33c8 3a d7 33			ld a, (.dmark+1)  
33cb 32 be fb			ld (debug_mark+1),a  
33ce 3a d8 33			ld a, (.dmark+2)  
33d1 32 bf fb			ld (debug_mark+2),a  
33d4 18 03			jr .pastdmark  
33d6 ..			.dmark: db "UNT"  
33d9 f1			.pastdmark: pop af  
33da			endm  
# End of macro DMARK
33da						CALLMONITOR 
33da cd 20 17			call break_point_state  
33dd				endm  
# End of macro CALLMONITOR
33dd					endif 
33dd			 
33dd			;	push hl 
33dd				FORTH_DSP_POP 
33dd cd 5f 1f			call macro_forth_dsp_pop 
33e0				endm 
# End of macro FORTH_DSP_POP
33e0			 
33e0			;	pop hl 
33e0			 
33e0				; test if true 
33e0			 
33e0 cd 2f 0d			call ishlzero 
33e3			;	ld a,l 
33e3			;	add h 
33e3			; 
33e3			;	cp 0 
33e3			 
33e3 20 3e			jr nz, .untilnotdone 
33e5			 
33e5					if DEBUG_FORTH_WORDS 
33e5						DMARK "UNf" 
33e5 f5				push af  
33e6 3a fa 33			ld a, (.dmark)  
33e9 32 bd fb			ld (debug_mark),a  
33ec 3a fb 33			ld a, (.dmark+1)  
33ef 32 be fb			ld (debug_mark+1),a  
33f2 3a fc 33			ld a, (.dmark+2)  
33f5 32 bf fb			ld (debug_mark+2),a  
33f8 18 03			jr .pastdmark  
33fa ..			.dmark: db "UNf"  
33fd f1			.pastdmark: pop af  
33fe			endm  
# End of macro DMARK
33fe						CALLMONITOR 
33fe cd 20 17			call break_point_state  
3401				endm  
# End of macro CALLMONITOR
3401					endif 
3401			 
3401			 
3401			 
3401				FORTH_RSP_POP     ; get rid of DO ptr 
3401 cd 78 1c			call macro_forth_rsp_pop 
3404				endm 
# End of macro FORTH_RSP_POP
3404			 
3404			if DEBUG_FORTH_WORDS 
3404						DMARK "UN>" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 bd fb			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 be fb			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 bf fb			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "UN>"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d				CALLMONITOR 
341d cd 20 17			call break_point_state  
3420				endm  
# End of macro CALLMONITOR
3420			endif 
3420			 
3420					NEXTW 
3420 c3 19 20			jp macro_next 
3423				endm 
# End of macro NEXTW
3423				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3423			 
3423			.untilnotdone: 
3423			 
3423			 
3423			;	; get DO ptr 
3423			; 
3423				FORTH_RSP_TOS 
3423 cd 6e 1c			call macro_forth_rsp_tos 
3426				endm 
# End of macro FORTH_RSP_TOS
3426			 
3426				;push hl 
3426			 
3426				; not going to DO any more 
3426				; get rid of the RSP pointer as DO will add it back in 
3426				;FORTH_RSP_POP 
3426				;pop hl 
3426			 
3426			 
3426 22 a4 f2			ld (os_tok_ptr), hl 
3429					if DEBUG_FORTH_WORDS 
3429						DMARK "UN<" 
3429 f5				push af  
342a 3a 3e 34			ld a, (.dmark)  
342d 32 bd fb			ld (debug_mark),a  
3430 3a 3f 34			ld a, (.dmark+1)  
3433 32 be fb			ld (debug_mark+1),a  
3436 3a 40 34			ld a, (.dmark+2)  
3439 32 bf fb			ld (debug_mark+2),a  
343c 18 03			jr .pastdmark  
343e ..			.dmark: db "UN<"  
3441 f1			.pastdmark: pop af  
3442			endm  
# End of macro DMARK
3442					CALLMONITOR 
3442 cd 20 17			call break_point_state  
3445				endm  
# End of macro CALLMONITOR
3445				endif 
3445 c3 aa 20			jp exec1 
3448			 
3448					 
3448			 
3448			 
3448					NEXTW 
3448 c3 19 20			jp macro_next 
344b				endm 
# End of macro NEXTW
344b			 
344b			 
344b			.ENDFLOW: 
344b			 
344b			; eof 
344b			 
# End of file forth_words_flow.asm
344b			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
344b			include "forth_words_logic.asm" 
344b			 
344b			; | ## Logic Words 
344b			 
344b			.NOT: 
344b				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
344b 2d				db WORD_SYS_CORE+25             
344c 93 34			dw .IS            
344e 04				db 3 + 1 
344f .. 00			db "NOT",0              
3453				endm 
# End of macro CWHEAD
3453			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3453					if DEBUG_FORTH_WORDS_KEY 
3453						DMARK "NOT" 
3453 f5				push af  
3454 3a 68 34			ld a, (.dmark)  
3457 32 bd fb			ld (debug_mark),a  
345a 3a 69 34			ld a, (.dmark+1)  
345d 32 be fb			ld (debug_mark+1),a  
3460 3a 6a 34			ld a, (.dmark+2)  
3463 32 bf fb			ld (debug_mark+2),a  
3466 18 03			jr .pastdmark  
3468 ..			.dmark: db "NOT"  
346b f1			.pastdmark: pop af  
346c			endm  
# End of macro DMARK
346c						CALLMONITOR 
346c cd 20 17			call break_point_state  
346f				endm  
# End of macro CALLMONITOR
346f					endif 
346f					FORTH_DSP 
346f cd 6d 1e			call macro_forth_dsp 
3472				endm 
# End of macro FORTH_DSP
3472 7e					ld a,(hl)	; get type of value on TOS 
3473 fe 02				cp DS_TYPE_INUM  
3475 28 03				jr z, .noti 
3477					NEXTW 
3477 c3 19 20			jp macro_next 
347a				endm 
# End of macro NEXTW
347a			.noti:          FORTH_DSP_VALUEHL 
347a cd a7 1e			call macro_dsp_valuehl 
347d				endm 
# End of macro FORTH_DSP_VALUEHL
347d			;		push hl 
347d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
347d cd 5f 1f			call macro_forth_dsp_pop 
3480				endm 
# End of macro FORTH_DSP_POP
3480			;		pop hl 
3480 3e 00				ld a,0 
3482 bd					cp l 
3483 28 04				jr z, .not2t 
3485 2e 00				ld l, 0 
3487 18 02				jr .notip 
3489			 
3489 2e ff		.not2t:		ld l, 255 
348b			 
348b 26 00		.notip:		ld h, 0	 
348d			 
348d cd b0 1c				call forth_push_numhl 
3490					NEXTW 
3490 c3 19 20			jp macro_next 
3493				endm 
# End of macro NEXTW
3493			 
3493			.IS: 
3493				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3493 2d				db WORD_SYS_CORE+25             
3494 b9 34			dw .LZERO            
3496 03				db 2 + 1 
3497 .. 00			db "IS",0              
349a				endm 
# End of macro CWHEAD
349a			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
349a					if DEBUG_FORTH_WORDS_KEY 
349a						DMARK "IS." 
349a f5				push af  
349b 3a af 34			ld a, (.dmark)  
349e 32 bd fb			ld (debug_mark),a  
34a1 3a b0 34			ld a, (.dmark+1)  
34a4 32 be fb			ld (debug_mark+1),a  
34a7 3a b1 34			ld a, (.dmark+2)  
34aa 32 bf fb			ld (debug_mark+2),a  
34ad 18 03			jr .pastdmark  
34af ..			.dmark: db "IS."  
34b2 f1			.pastdmark: pop af  
34b3			endm  
# End of macro DMARK
34b3						CALLMONITOR 
34b3 cd 20 17			call break_point_state  
34b6				endm  
# End of macro CALLMONITOR
34b6					endif 
34b6					NEXTW 
34b6 c3 19 20			jp macro_next 
34b9				endm 
# End of macro NEXTW
34b9			.LZERO: 
34b9				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34b9 2d				db WORD_SYS_CORE+25             
34ba c3 34			dw .TZERO            
34bc 03				db 2 + 1 
34bd .. 00			db "0<",0              
34c0				endm 
# End of macro CWHEAD
34c0			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34c0					NEXTW 
34c0 c3 19 20			jp macro_next 
34c3				endm 
# End of macro NEXTW
34c3			.TZERO: 
34c3				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34c3 2e				db WORD_SYS_CORE+26             
34c4 0a 35			dw .LESS            
34c6 03				db 2 + 1 
34c7 .. 00			db "0=",0              
34ca				endm 
# End of macro CWHEAD
34ca			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34ca				; TODO add floating point number detection 
34ca					;v5 FORTH_DSP_VALUE 
34ca					if DEBUG_FORTH_WORDS_KEY 
34ca						DMARK "0=." 
34ca f5				push af  
34cb 3a df 34			ld a, (.dmark)  
34ce 32 bd fb			ld (debug_mark),a  
34d1 3a e0 34			ld a, (.dmark+1)  
34d4 32 be fb			ld (debug_mark+1),a  
34d7 3a e1 34			ld a, (.dmark+2)  
34da 32 bf fb			ld (debug_mark+2),a  
34dd 18 03			jr .pastdmark  
34df ..			.dmark: db "0=."  
34e2 f1			.pastdmark: pop af  
34e3			endm  
# End of macro DMARK
34e3						CALLMONITOR 
34e3 cd 20 17			call break_point_state  
34e6				endm  
# End of macro CALLMONITOR
34e6					endif 
34e6					FORTH_DSP 
34e6 cd 6d 1e			call macro_forth_dsp 
34e9				endm 
# End of macro FORTH_DSP
34e9 7e					ld a,(hl)	; get type of value on TOS 
34ea fe 02				cp DS_TYPE_INUM  
34ec 28 00				jr z, .tz_inum 
34ee			 
34ee				if FORTH_ENABLE_FLOATMATH 
34ee					jr .tz_done 
34ee			 
34ee				endif 
34ee					 
34ee			 
34ee			.tz_inum: 
34ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34ee cd a7 1e			call macro_dsp_valuehl 
34f1				endm 
# End of macro FORTH_DSP_VALUEHL
34f1			 
34f1			;		push hl 
34f1			 
34f1					; destroy value TOS 
34f1			 
34f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34f1 cd 5f 1f			call macro_forth_dsp_pop 
34f4				endm 
# End of macro FORTH_DSP_POP
34f4			 
34f4			;		pop hl 
34f4			 
34f4 3e 00				ld a,0 
34f6			 
34f6 bd					cp l 
34f7 20 08				jr nz, .tz_notzero 
34f9			 
34f9 bc					cp h 
34fa			 
34fa 20 05				jr nz, .tz_notzero 
34fc			 
34fc			 
34fc 21 01 00				ld hl, FORTH_TRUE 
34ff 18 03				jr .tz_done 
3501			 
3501 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3504			 
3504					; push value back onto stack for another op etc 
3504			 
3504			.tz_done: 
3504 cd b0 1c				call forth_push_numhl 
3507			 
3507					NEXTW 
3507 c3 19 20			jp macro_next 
350a				endm 
# End of macro NEXTW
350a			.LESS: 
350a				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
350a 2f				db WORD_SYS_CORE+27             
350b 73 35			dw .GT            
350d 02				db 1 + 1 
350e .. 00			db "<",0              
3510				endm 
# End of macro CWHEAD
3510			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3510				; TODO add floating point number detection 
3510					if DEBUG_FORTH_WORDS_KEY 
3510						DMARK "LES" 
3510 f5				push af  
3511 3a 25 35			ld a, (.dmark)  
3514 32 bd fb			ld (debug_mark),a  
3517 3a 26 35			ld a, (.dmark+1)  
351a 32 be fb			ld (debug_mark+1),a  
351d 3a 27 35			ld a, (.dmark+2)  
3520 32 bf fb			ld (debug_mark+2),a  
3523 18 03			jr .pastdmark  
3525 ..			.dmark: db "LES"  
3528 f1			.pastdmark: pop af  
3529			endm  
# End of macro DMARK
3529						CALLMONITOR 
3529 cd 20 17			call break_point_state  
352c				endm  
# End of macro CALLMONITOR
352c					endif 
352c					FORTH_DSP 
352c cd 6d 1e			call macro_forth_dsp 
352f				endm 
# End of macro FORTH_DSP
352f					;v5 FORTH_DSP_VALUE 
352f 7e					ld a,(hl)	; get type of value on TOS 
3530 fe 02				cp DS_TYPE_INUM  
3532 28 00				jr z, .less_inum 
3534			 
3534				if FORTH_ENABLE_FLOATMATH 
3534					jr .less_done 
3534			 
3534				endif 
3534					 
3534			 
3534			.less_inum: 
3534					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3534 cd a7 1e			call macro_dsp_valuehl 
3537				endm 
# End of macro FORTH_DSP_VALUEHL
3537			 
3537 e5					push hl  ; u2 
3538			 
3538					; destroy value TOS 
3538			 
3538					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3538 cd 5f 1f			call macro_forth_dsp_pop 
353b				endm 
# End of macro FORTH_DSP_POP
353b			 
353b			 
353b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
353b cd a7 1e			call macro_dsp_valuehl 
353e				endm 
# End of macro FORTH_DSP_VALUEHL
353e			 
353e e5					push hl    ; u1 
353f			 
353f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
353f cd 5f 1f			call macro_forth_dsp_pop 
3542				endm 
# End of macro FORTH_DSP_POP
3542			 
3542			 
3542 b7			 or a      ;clear carry flag 
3543 01 00 00		 ld bc, FORTH_FALSE 
3546 e1			  pop hl    ; u1 
3547 d1			  pop de    ; u2 
3548 ed 52		  sbc hl,de 
354a 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
354c			 
354c 01 01 00		 ld bc, FORTH_TRUE 
354f			.lscont:  
354f c5					push bc 
3550 e1					pop hl 
3551			 
3551					if DEBUG_FORTH_WORDS 
3551						DMARK "LT1" 
3551 f5				push af  
3552 3a 66 35			ld a, (.dmark)  
3555 32 bd fb			ld (debug_mark),a  
3558 3a 67 35			ld a, (.dmark+1)  
355b 32 be fb			ld (debug_mark+1),a  
355e 3a 68 35			ld a, (.dmark+2)  
3561 32 bf fb			ld (debug_mark+2),a  
3564 18 03			jr .pastdmark  
3566 ..			.dmark: db "LT1"  
3569 f1			.pastdmark: pop af  
356a			endm  
# End of macro DMARK
356a						CALLMONITOR 
356a cd 20 17			call break_point_state  
356d				endm  
# End of macro CALLMONITOR
356d					endif 
356d cd b0 1c				call forth_push_numhl 
3570			 
3570					NEXTW 
3570 c3 19 20			jp macro_next 
3573				endm 
# End of macro NEXTW
3573			.GT: 
3573				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3573 30				db WORD_SYS_CORE+28             
3574 dc 35			dw .EQUAL            
3576 02				db 1 + 1 
3577 .. 00			db ">",0              
3579				endm 
# End of macro CWHEAD
3579			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3579				; TODO add floating point number detection 
3579					if DEBUG_FORTH_WORDS_KEY 
3579						DMARK "GRT" 
3579 f5				push af  
357a 3a 8e 35			ld a, (.dmark)  
357d 32 bd fb			ld (debug_mark),a  
3580 3a 8f 35			ld a, (.dmark+1)  
3583 32 be fb			ld (debug_mark+1),a  
3586 3a 90 35			ld a, (.dmark+2)  
3589 32 bf fb			ld (debug_mark+2),a  
358c 18 03			jr .pastdmark  
358e ..			.dmark: db "GRT"  
3591 f1			.pastdmark: pop af  
3592			endm  
# End of macro DMARK
3592						CALLMONITOR 
3592 cd 20 17			call break_point_state  
3595				endm  
# End of macro CALLMONITOR
3595					endif 
3595					FORTH_DSP 
3595 cd 6d 1e			call macro_forth_dsp 
3598				endm 
# End of macro FORTH_DSP
3598					;FORTH_DSP_VALUE 
3598 7e					ld a,(hl)	; get type of value on TOS 
3599 fe 02				cp DS_TYPE_INUM  
359b 28 00				jr z, .gt_inum 
359d			 
359d				if FORTH_ENABLE_FLOATMATH 
359d					jr .gt_done 
359d			 
359d				endif 
359d					 
359d			 
359d			.gt_inum: 
359d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359d cd a7 1e			call macro_dsp_valuehl 
35a0				endm 
# End of macro FORTH_DSP_VALUEHL
35a0			 
35a0 e5					push hl  ; u2 
35a1			 
35a1					; destroy value TOS 
35a1			 
35a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a1 cd 5f 1f			call macro_forth_dsp_pop 
35a4				endm 
# End of macro FORTH_DSP_POP
35a4			 
35a4			 
35a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a4 cd a7 1e			call macro_dsp_valuehl 
35a7				endm 
# End of macro FORTH_DSP_VALUEHL
35a7			 
35a7 e5					push hl    ; u1 
35a8			 
35a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a8 cd 5f 1f			call macro_forth_dsp_pop 
35ab				endm 
# End of macro FORTH_DSP_POP
35ab			 
35ab			 
35ab b7			 or a      ;clear carry flag 
35ac 01 00 00		 ld bc, FORTH_FALSE 
35af e1			  pop hl    ; u1 
35b0 d1			  pop de    ; u2 
35b1 ed 52		  sbc hl,de 
35b3 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35b5			 
35b5 01 01 00		 ld bc, FORTH_TRUE 
35b8			.gtcont:  
35b8 c5					push bc 
35b9 e1					pop hl 
35ba			 
35ba					if DEBUG_FORTH_WORDS 
35ba						DMARK "GT1" 
35ba f5				push af  
35bb 3a cf 35			ld a, (.dmark)  
35be 32 bd fb			ld (debug_mark),a  
35c1 3a d0 35			ld a, (.dmark+1)  
35c4 32 be fb			ld (debug_mark+1),a  
35c7 3a d1 35			ld a, (.dmark+2)  
35ca 32 bf fb			ld (debug_mark+2),a  
35cd 18 03			jr .pastdmark  
35cf ..			.dmark: db "GT1"  
35d2 f1			.pastdmark: pop af  
35d3			endm  
# End of macro DMARK
35d3						CALLMONITOR 
35d3 cd 20 17			call break_point_state  
35d6				endm  
# End of macro CALLMONITOR
35d6					endif 
35d6 cd b0 1c				call forth_push_numhl 
35d9			 
35d9					NEXTW 
35d9 c3 19 20			jp macro_next 
35dc				endm 
# End of macro NEXTW
35dc			.EQUAL: 
35dc				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35dc 31				db WORD_SYS_CORE+29             
35dd 47 36			dw .ENDLOGIC            
35df 02				db 1 + 1 
35e0 .. 00			db "=",0              
35e2				endm 
# End of macro CWHEAD
35e2			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35e2				; TODO add floating point number detection 
35e2					if DEBUG_FORTH_WORDS_KEY 
35e2						DMARK "EQ." 
35e2 f5				push af  
35e3 3a f7 35			ld a, (.dmark)  
35e6 32 bd fb			ld (debug_mark),a  
35e9 3a f8 35			ld a, (.dmark+1)  
35ec 32 be fb			ld (debug_mark+1),a  
35ef 3a f9 35			ld a, (.dmark+2)  
35f2 32 bf fb			ld (debug_mark+2),a  
35f5 18 03			jr .pastdmark  
35f7 ..			.dmark: db "EQ."  
35fa f1			.pastdmark: pop af  
35fb			endm  
# End of macro DMARK
35fb						CALLMONITOR 
35fb cd 20 17			call break_point_state  
35fe				endm  
# End of macro CALLMONITOR
35fe					endif 
35fe					FORTH_DSP 
35fe cd 6d 1e			call macro_forth_dsp 
3601				endm 
# End of macro FORTH_DSP
3601					;v5 FORTH_DSP_VALUE 
3601 7e					ld a,(hl)	; get type of value on TOS 
3602 fe 02				cp DS_TYPE_INUM  
3604 28 00				jr z, .eq_inum 
3606			 
3606				if FORTH_ENABLE_FLOATMATH 
3606					jr .eq_done 
3606			 
3606				endif 
3606					 
3606			 
3606			.eq_inum: 
3606					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3606 cd a7 1e			call macro_dsp_valuehl 
3609				endm 
# End of macro FORTH_DSP_VALUEHL
3609			 
3609 e5					push hl 
360a			 
360a					; destroy value TOS 
360a			 
360a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360a cd 5f 1f			call macro_forth_dsp_pop 
360d				endm 
# End of macro FORTH_DSP_POP
360d			 
360d			 
360d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
360d cd a7 1e			call macro_dsp_valuehl 
3610				endm 
# End of macro FORTH_DSP_VALUEHL
3610			 
3610					; one value on hl get other one back 
3610			 
3610 e5					push hl 
3611			 
3611					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3611 cd 5f 1f			call macro_forth_dsp_pop 
3614				endm 
# End of macro FORTH_DSP_POP
3614			 
3614 0e 00				ld c, FORTH_FALSE 
3616			 
3616 e1					pop hl 
3617 d1					pop de 
3618			 
3618 7b					ld a, e 
3619 bd					cp l 
361a			 
361a 20 06				jr nz, .eq_done 
361c			 
361c 7a					ld a, d 
361d bc					cp h 
361e			 
361e 20 02				jr nz, .eq_done 
3620			 
3620 0e 01				ld c, FORTH_TRUE 
3622					 
3622			 
3622			 
3622			.eq_done: 
3622			 
3622					; TODO push value back onto stack for another op etc 
3622			 
3622 26 00				ld h, 0 
3624 69					ld l, c 
3625					if DEBUG_FORTH_WORDS 
3625						DMARK "EQ1" 
3625 f5				push af  
3626 3a 3a 36			ld a, (.dmark)  
3629 32 bd fb			ld (debug_mark),a  
362c 3a 3b 36			ld a, (.dmark+1)  
362f 32 be fb			ld (debug_mark+1),a  
3632 3a 3c 36			ld a, (.dmark+2)  
3635 32 bf fb			ld (debug_mark+2),a  
3638 18 03			jr .pastdmark  
363a ..			.dmark: db "EQ1"  
363d f1			.pastdmark: pop af  
363e			endm  
# End of macro DMARK
363e						CALLMONITOR 
363e cd 20 17			call break_point_state  
3641				endm  
# End of macro CALLMONITOR
3641					endif 
3641 cd b0 1c				call forth_push_numhl 
3644			 
3644					NEXTW 
3644 c3 19 20			jp macro_next 
3647				endm 
# End of macro NEXTW
3647			 
3647			 
3647			.ENDLOGIC: 
3647			; eof 
3647			 
3647			 
# End of file forth_words_logic.asm
3647			include "forth_words_maths.asm" 
3647			 
3647			; | ## Maths Words 
3647			 
3647			.PLUS:	 
3647				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3647 15				db WORD_SYS_CORE+1             
3648 89 36			dw .NEG            
364a 02				db 1 + 1 
364b .. 00			db "+",0              
364d				endm 
# End of macro CWHEAD
364d			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
364d					if DEBUG_FORTH_WORDS_KEY 
364d						DMARK "PLU" 
364d f5				push af  
364e 3a 62 36			ld a, (.dmark)  
3651 32 bd fb			ld (debug_mark),a  
3654 3a 63 36			ld a, (.dmark+1)  
3657 32 be fb			ld (debug_mark+1),a  
365a 3a 64 36			ld a, (.dmark+2)  
365d 32 bf fb			ld (debug_mark+2),a  
3660 18 03			jr .pastdmark  
3662 ..			.dmark: db "PLU"  
3665 f1			.pastdmark: pop af  
3666			endm  
# End of macro DMARK
3666						CALLMONITOR 
3666 cd 20 17			call break_point_state  
3669				endm  
# End of macro CALLMONITOR
3669					endif 
3669					; add top two values and push back result 
3669			 
3669					;for v5 FORTH_DSP_VALUE 
3669					FORTH_DSP 
3669 cd 6d 1e			call macro_forth_dsp 
366c				endm 
# End of macro FORTH_DSP
366c 7e					ld a,(hl)	; get type of value on TOS 
366d fe 02				cp DS_TYPE_INUM  
366f 28 03				jr z, .dot_inum 
3671			 
3671					NEXTW 
3671 c3 19 20			jp macro_next 
3674				endm 
# End of macro NEXTW
3674			 
3674			; float maths 
3674			 
3674				if FORTH_ENABLE_FLOATMATH 
3674						inc hl      ; now at start of numeric as string 
3674			 
3674					if DEBUG_FORTH_MATHS 
3674						DMARK "ADD" 
3674				CALLMONITOR 
3674					endif 
3674			 
3674					;ld ix, hl 
3674					call CON 
3674			 
3674			 
3674					push hl 
3674					 
3674					 
3674			 
3674						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3674			 
3674					; get next number 
3674			 
3674						FORTH_DSP_VALUE 
3674			 
3674						inc hl      ; now at start of numeric as string 
3674			 
3674					;ld ix, hl 
3674					call CON 
3674			 
3674					push hl 
3674			 
3674			 
3674						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3674			 
3674						; TODO do add 
3674			 
3674						call IADD 
3674			 
3674						; TODO get result back as ascii 
3674			 
3674						; TODO push result  
3674			 
3674			 
3674			 
3674						jr .dot_done 
3674				endif 
3674			 
3674			.dot_inum: 
3674			 
3674			 
3674					if DEBUG_FORTH_DOT 
3674						DMARK "+IT" 
3674				CALLMONITOR 
3674					endif 
3674			 
3674					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3674 cd a7 1e			call macro_dsp_valuehl 
3677				endm 
# End of macro FORTH_DSP_VALUEHL
3677			 
3677				; TODO add floating point number detection 
3677			 
3677 e5					push hl 
3678			 
3678					; destroy value TOS 
3678			 
3678					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3678 cd 5f 1f			call macro_forth_dsp_pop 
367b				endm 
# End of macro FORTH_DSP_POP
367b			 
367b			 
367b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
367b cd a7 1e			call macro_dsp_valuehl 
367e				endm 
# End of macro FORTH_DSP_VALUEHL
367e			 
367e					; one value on hl get other one back 
367e			 
367e d1					pop de 
367f			 
367f					; do the add 
367f			 
367f 19					add hl,de 
3680			 
3680					; save it 
3680			 
3680			;		push hl	 
3680			 
3680					; 
3680			 
3680					; destroy value TOS 
3680			 
3680					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3680 cd 5f 1f			call macro_forth_dsp_pop 
3683				endm 
# End of macro FORTH_DSP_POP
3683			 
3683					; TODO push value back onto stack for another op etc 
3683			 
3683			;		pop hl 
3683			 
3683			.dot_done: 
3683 cd b0 1c				call forth_push_numhl 
3686			 
3686					NEXTW 
3686 c3 19 20			jp macro_next 
3689				endm 
# End of macro NEXTW
3689			.NEG: 
3689			 
3689				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3689 17				db WORD_SYS_CORE+3             
368a cc 36			dw .DIV            
368c 02				db 1 + 1 
368d .. 00			db "-",0              
368f				endm 
# End of macro CWHEAD
368f			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
368f					if DEBUG_FORTH_WORDS_KEY 
368f						DMARK "SUB" 
368f f5				push af  
3690 3a a4 36			ld a, (.dmark)  
3693 32 bd fb			ld (debug_mark),a  
3696 3a a5 36			ld a, (.dmark+1)  
3699 32 be fb			ld (debug_mark+1),a  
369c 3a a6 36			ld a, (.dmark+2)  
369f 32 bf fb			ld (debug_mark+2),a  
36a2 18 03			jr .pastdmark  
36a4 ..			.dmark: db "SUB"  
36a7 f1			.pastdmark: pop af  
36a8			endm  
# End of macro DMARK
36a8						CALLMONITOR 
36a8 cd 20 17			call break_point_state  
36ab				endm  
# End of macro CALLMONITOR
36ab					endif 
36ab			 
36ab			 
36ab				; TODO add floating point number detection 
36ab					; v5 FORTH_DSP_VALUE 
36ab					FORTH_DSP 
36ab cd 6d 1e			call macro_forth_dsp 
36ae				endm 
# End of macro FORTH_DSP
36ae 7e					ld a,(hl)	; get type of value on TOS 
36af fe 02				cp DS_TYPE_INUM  
36b1 28 03				jr z, .neg_inum 
36b3			 
36b3					NEXTW 
36b3 c3 19 20			jp macro_next 
36b6				endm 
# End of macro NEXTW
36b6			 
36b6			; float maths 
36b6			 
36b6				if FORTH_ENABLE_FLOATMATH 
36b6					jr .neg_done 
36b6			 
36b6				endif 
36b6					 
36b6			 
36b6			.neg_inum: 
36b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b6 cd a7 1e			call macro_dsp_valuehl 
36b9				endm 
# End of macro FORTH_DSP_VALUEHL
36b9			 
36b9 e5					push hl 
36ba			 
36ba					; destroy value TOS 
36ba			 
36ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ba cd 5f 1f			call macro_forth_dsp_pop 
36bd				endm 
# End of macro FORTH_DSP_POP
36bd			 
36bd			 
36bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bd cd a7 1e			call macro_dsp_valuehl 
36c0				endm 
# End of macro FORTH_DSP_VALUEHL
36c0			 
36c0					; one value on hl get other one back 
36c0			 
36c0 d1					pop de 
36c1			 
36c1					; do the sub 
36c1			;		ex de, hl 
36c1			 
36c1 ed 52				sbc hl,de 
36c3			 
36c3					; save it 
36c3			 
36c3			;		push hl	 
36c3			 
36c3					; 
36c3			 
36c3					; destroy value TOS 
36c3			 
36c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c3 cd 5f 1f			call macro_forth_dsp_pop 
36c6				endm 
# End of macro FORTH_DSP_POP
36c6			 
36c6					; TODO push value back onto stack for another op etc 
36c6			 
36c6			;		pop hl 
36c6			 
36c6 cd b0 1c				call forth_push_numhl 
36c9			.neg_done: 
36c9			 
36c9					NEXTW 
36c9 c3 19 20			jp macro_next 
36cc				endm 
# End of macro NEXTW
36cc			.DIV: 
36cc				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36cc 18				db WORD_SYS_CORE+4             
36cd 19 37			dw .MUL            
36cf 02				db 1 + 1 
36d0 .. 00			db "/",0              
36d2				endm 
# End of macro CWHEAD
36d2			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36d2					if DEBUG_FORTH_WORDS_KEY 
36d2						DMARK "DIV" 
36d2 f5				push af  
36d3 3a e7 36			ld a, (.dmark)  
36d6 32 bd fb			ld (debug_mark),a  
36d9 3a e8 36			ld a, (.dmark+1)  
36dc 32 be fb			ld (debug_mark+1),a  
36df 3a e9 36			ld a, (.dmark+2)  
36e2 32 bf fb			ld (debug_mark+2),a  
36e5 18 03			jr .pastdmark  
36e7 ..			.dmark: db "DIV"  
36ea f1			.pastdmark: pop af  
36eb			endm  
# End of macro DMARK
36eb						CALLMONITOR 
36eb cd 20 17			call break_point_state  
36ee				endm  
# End of macro CALLMONITOR
36ee					endif 
36ee				; TODO add floating point number detection 
36ee					; v5 FORTH_DSP_VALUE 
36ee					FORTH_DSP 
36ee cd 6d 1e			call macro_forth_dsp 
36f1				endm 
# End of macro FORTH_DSP
36f1 7e					ld a,(hl)	; get type of value on TOS 
36f2 fe 02				cp DS_TYPE_INUM  
36f4 28 03				jr z, .div_inum 
36f6			 
36f6				if FORTH_ENABLE_FLOATMATH 
36f6					jr .div_done 
36f6			 
36f6				endif 
36f6					NEXTW 
36f6 c3 19 20			jp macro_next 
36f9				endm 
# End of macro NEXTW
36f9			.div_inum: 
36f9			 
36f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f9 cd a7 1e			call macro_dsp_valuehl 
36fc				endm 
# End of macro FORTH_DSP_VALUEHL
36fc			 
36fc e5					push hl    ; to go to bc 
36fd			 
36fd					; destroy value TOS 
36fd			 
36fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fd cd 5f 1f			call macro_forth_dsp_pop 
3700				endm 
# End of macro FORTH_DSP_POP
3700			 
3700			 
3700					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3700 cd a7 1e			call macro_dsp_valuehl 
3703				endm 
# End of macro FORTH_DSP_VALUEHL
3703			 
3703					; hl to go to de 
3703			 
3703 e5					push hl 
3704			 
3704 c1					pop bc 
3705 d1					pop de		 
3706			 
3706			 
3706					if DEBUG_FORTH_MATHS 
3706						DMARK "DIV" 
3706				CALLMONITOR 
3706					endif 
3706					; one value on hl but move to a get other one back 
3706			 
3706			        
3706 cd 63 0c			call Div16 
3709			 
3709			;	push af	 
3709 e5				push hl 
370a c5				push bc 
370b			 
370b					if DEBUG_FORTH_MATHS 
370b						DMARK "DI1" 
370b				CALLMONITOR 
370b					endif 
370b			 
370b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370b cd 5f 1f			call macro_forth_dsp_pop 
370e				endm 
# End of macro FORTH_DSP_POP
370e			 
370e			 
370e			 
370e e1					pop hl    ; result 
370f			 
370f cd b0 1c				call forth_push_numhl 
3712			 
3712 e1					pop hl    ; reminder 
3713			;		ld h,0 
3713			;		ld l,d 
3713			 
3713 cd b0 1c				call forth_push_numhl 
3716			.div_done: 
3716					NEXTW 
3716 c3 19 20			jp macro_next 
3719				endm 
# End of macro NEXTW
3719			.MUL: 
3719				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3719 19				db WORD_SYS_CORE+5             
371a 5e 37			dw .MIN            
371c 02				db 1 + 1 
371d .. 00			db "*",0              
371f				endm 
# End of macro CWHEAD
371f			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
371f				; TODO add floating point number detection 
371f					if DEBUG_FORTH_WORDS_KEY 
371f						DMARK "MUL" 
371f f5				push af  
3720 3a 34 37			ld a, (.dmark)  
3723 32 bd fb			ld (debug_mark),a  
3726 3a 35 37			ld a, (.dmark+1)  
3729 32 be fb			ld (debug_mark+1),a  
372c 3a 36 37			ld a, (.dmark+2)  
372f 32 bf fb			ld (debug_mark+2),a  
3732 18 03			jr .pastdmark  
3734 ..			.dmark: db "MUL"  
3737 f1			.pastdmark: pop af  
3738			endm  
# End of macro DMARK
3738						CALLMONITOR 
3738 cd 20 17			call break_point_state  
373b				endm  
# End of macro CALLMONITOR
373b					endif 
373b					FORTH_DSP 
373b cd 6d 1e			call macro_forth_dsp 
373e				endm 
# End of macro FORTH_DSP
373e					; v5 FORTH_DSP_VALUE 
373e 7e					ld a,(hl)	; get type of value on TOS 
373f fe 02				cp DS_TYPE_INUM  
3741 28 03				jr z, .mul_inum 
3743			 
3743				if FORTH_ENABLE_FLOATMATH 
3743					jr .mul_done 
3743			 
3743				endif 
3743			 
3743					NEXTW 
3743 c3 19 20			jp macro_next 
3746				endm 
# End of macro NEXTW
3746			.mul_inum:	 
3746			 
3746					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3746 cd a7 1e			call macro_dsp_valuehl 
3749				endm 
# End of macro FORTH_DSP_VALUEHL
3749			 
3749 e5					push hl 
374a			 
374a					; destroy value TOS 
374a			 
374a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374a cd 5f 1f			call macro_forth_dsp_pop 
374d				endm 
# End of macro FORTH_DSP_POP
374d			 
374d			 
374d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
374d cd a7 1e			call macro_dsp_valuehl 
3750				endm 
# End of macro FORTH_DSP_VALUEHL
3750			 
3750					; one value on hl but move to a get other one back 
3750			 
3750 7d					ld a, l 
3751			 
3751 d1					pop de 
3752			 
3752					; do the mull 
3752			;		ex de, hl 
3752			 
3752 cd 89 0c				call Mult16 
3755					; save it 
3755			 
3755			;		push hl	 
3755			 
3755					; 
3755			 
3755					; destroy value TOS 
3755			 
3755					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3755 cd 5f 1f			call macro_forth_dsp_pop 
3758				endm 
# End of macro FORTH_DSP_POP
3758			 
3758					; TODO push value back onto stack for another op etc 
3758			 
3758			;		pop hl 
3758			 
3758 cd b0 1c				call forth_push_numhl 
375b			 
375b			.mul_done: 
375b					NEXTW 
375b c3 19 20			jp macro_next 
375e				endm 
# End of macro NEXTW
375e			 
375e			 
375e			 
375e			 
375e			.MIN: 
375e				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
375e 49				db WORD_SYS_CORE+53             
375f df 37			dw .MAX            
3761 04				db 3 + 1 
3762 .. 00			db "MIN",0              
3766				endm 
# End of macro CWHEAD
3766			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3766					if DEBUG_FORTH_WORDS_KEY 
3766						DMARK "MIN" 
3766 f5				push af  
3767 3a 7b 37			ld a, (.dmark)  
376a 32 bd fb			ld (debug_mark),a  
376d 3a 7c 37			ld a, (.dmark+1)  
3770 32 be fb			ld (debug_mark+1),a  
3773 3a 7d 37			ld a, (.dmark+2)  
3776 32 bf fb			ld (debug_mark+2),a  
3779 18 03			jr .pastdmark  
377b ..			.dmark: db "MIN"  
377e f1			.pastdmark: pop af  
377f			endm  
# End of macro DMARK
377f						CALLMONITOR 
377f cd 20 17			call break_point_state  
3782				endm  
# End of macro CALLMONITOR
3782					endif 
3782					; get u2 
3782			 
3782					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3782 cd a7 1e			call macro_dsp_valuehl 
3785				endm 
# End of macro FORTH_DSP_VALUEHL
3785			 
3785 e5					push hl   ; u2 
3786			 
3786					; destroy value TOS 
3786			 
3786					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3786 cd 5f 1f			call macro_forth_dsp_pop 
3789				endm 
# End of macro FORTH_DSP_POP
3789			 
3789					; get u1 
3789			 
3789					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3789 cd a7 1e			call macro_dsp_valuehl 
378c				endm 
# End of macro FORTH_DSP_VALUEHL
378c			 
378c e5					push hl  ; u1 
378d			 
378d					; destroy value TOS 
378d			 
378d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378d cd 5f 1f			call macro_forth_dsp_pop 
3790				endm 
# End of macro FORTH_DSP_POP
3790			 
3790 b7			 or a      ;clear carry flag 
3791 e1			  pop hl    ; u1 
3792 d1			  pop de    ; u2 
3793 e5				push hl   ; saved in case hl is lowest 
3794 ed 52		  sbc hl,de 
3796 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3798			 
3798 e1				pop hl 
3799					if DEBUG_FORTH_WORDS 
3799						DMARK "MIN" 
3799 f5				push af  
379a 3a ae 37			ld a, (.dmark)  
379d 32 bd fb			ld (debug_mark),a  
37a0 3a af 37			ld a, (.dmark+1)  
37a3 32 be fb			ld (debug_mark+1),a  
37a6 3a b0 37			ld a, (.dmark+2)  
37a9 32 bf fb			ld (debug_mark+2),a  
37ac 18 03			jr .pastdmark  
37ae ..			.dmark: db "MIN"  
37b1 f1			.pastdmark: pop af  
37b2			endm  
# End of macro DMARK
37b2						CALLMONITOR 
37b2 cd 20 17			call break_point_state  
37b5				endm  
# End of macro CALLMONITOR
37b5					endif 
37b5 cd b0 1c				call forth_push_numhl 
37b8			 
37b8				       NEXTW 
37b8 c3 19 20			jp macro_next 
37bb				endm 
# End of macro NEXTW
37bb			 
37bb			.mincont:  
37bb c1				pop bc   ; tidy up 
37bc eb				ex de , hl  
37bd					if DEBUG_FORTH_WORDS 
37bd						DMARK "MI1" 
37bd f5				push af  
37be 3a d2 37			ld a, (.dmark)  
37c1 32 bd fb			ld (debug_mark),a  
37c4 3a d3 37			ld a, (.dmark+1)  
37c7 32 be fb			ld (debug_mark+1),a  
37ca 3a d4 37			ld a, (.dmark+2)  
37cd 32 bf fb			ld (debug_mark+2),a  
37d0 18 03			jr .pastdmark  
37d2 ..			.dmark: db "MI1"  
37d5 f1			.pastdmark: pop af  
37d6			endm  
# End of macro DMARK
37d6						CALLMONITOR 
37d6 cd 20 17			call break_point_state  
37d9				endm  
# End of macro CALLMONITOR
37d9					endif 
37d9 cd b0 1c				call forth_push_numhl 
37dc			 
37dc				       NEXTW 
37dc c3 19 20			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			.MAX: 
37df				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37df 4a				db WORD_SYS_CORE+54             
37e0 60 38			dw .RND16            
37e2 04				db 3 + 1 
37e3 .. 00			db "MAX",0              
37e7				endm 
# End of macro CWHEAD
37e7			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37e7					if DEBUG_FORTH_WORDS_KEY 
37e7						DMARK "MAX" 
37e7 f5				push af  
37e8 3a fc 37			ld a, (.dmark)  
37eb 32 bd fb			ld (debug_mark),a  
37ee 3a fd 37			ld a, (.dmark+1)  
37f1 32 be fb			ld (debug_mark+1),a  
37f4 3a fe 37			ld a, (.dmark+2)  
37f7 32 bf fb			ld (debug_mark+2),a  
37fa 18 03			jr .pastdmark  
37fc ..			.dmark: db "MAX"  
37ff f1			.pastdmark: pop af  
3800			endm  
# End of macro DMARK
3800						CALLMONITOR 
3800 cd 20 17			call break_point_state  
3803				endm  
# End of macro CALLMONITOR
3803					endif 
3803					; get u2 
3803			 
3803					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3803 cd a7 1e			call macro_dsp_valuehl 
3806				endm 
# End of macro FORTH_DSP_VALUEHL
3806			 
3806 e5					push hl   ; u2 
3807			 
3807					; destroy value TOS 
3807			 
3807					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3807 cd 5f 1f			call macro_forth_dsp_pop 
380a				endm 
# End of macro FORTH_DSP_POP
380a			 
380a					; get u1 
380a			 
380a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380a cd a7 1e			call macro_dsp_valuehl 
380d				endm 
# End of macro FORTH_DSP_VALUEHL
380d			 
380d e5					push hl  ; u1 
380e			 
380e					; destroy value TOS 
380e			 
380e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380e cd 5f 1f			call macro_forth_dsp_pop 
3811				endm 
# End of macro FORTH_DSP_POP
3811			 
3811 b7			 or a      ;clear carry flag 
3812 e1			  pop hl    ; u1 
3813 d1			  pop de    ; u2 
3814 e5				push hl   ; saved in case hl is lowest 
3815 ed 52		  sbc hl,de 
3817 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3819			 
3819 e1				pop hl 
381a					if DEBUG_FORTH_WORDS 
381a						DMARK "MAX" 
381a f5				push af  
381b 3a 2f 38			ld a, (.dmark)  
381e 32 bd fb			ld (debug_mark),a  
3821 3a 30 38			ld a, (.dmark+1)  
3824 32 be fb			ld (debug_mark+1),a  
3827 3a 31 38			ld a, (.dmark+2)  
382a 32 bf fb			ld (debug_mark+2),a  
382d 18 03			jr .pastdmark  
382f ..			.dmark: db "MAX"  
3832 f1			.pastdmark: pop af  
3833			endm  
# End of macro DMARK
3833						CALLMONITOR 
3833 cd 20 17			call break_point_state  
3836				endm  
# End of macro CALLMONITOR
3836					endif 
3836 cd b0 1c				call forth_push_numhl 
3839			 
3839				       NEXTW 
3839 c3 19 20			jp macro_next 
383c				endm 
# End of macro NEXTW
383c			 
383c			.maxcont:  
383c c1				pop bc   ; tidy up 
383d eb				ex de , hl  
383e					if DEBUG_FORTH_WORDS 
383e						DMARK "MA1" 
383e f5				push af  
383f 3a 53 38			ld a, (.dmark)  
3842 32 bd fb			ld (debug_mark),a  
3845 3a 54 38			ld a, (.dmark+1)  
3848 32 be fb			ld (debug_mark+1),a  
384b 3a 55 38			ld a, (.dmark+2)  
384e 32 bf fb			ld (debug_mark+2),a  
3851 18 03			jr .pastdmark  
3853 ..			.dmark: db "MA1"  
3856 f1			.pastdmark: pop af  
3857			endm  
# End of macro DMARK
3857						CALLMONITOR 
3857 cd 20 17			call break_point_state  
385a				endm  
# End of macro CALLMONITOR
385a					endif 
385a cd b0 1c				call forth_push_numhl 
385d				       NEXTW 
385d c3 19 20			jp macro_next 
3860				endm 
# End of macro NEXTW
3860			 
3860			.RND16: 
3860				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3860 4e				db WORD_SYS_CORE+58             
3861 8f 38			dw .RND8            
3863 06				db 5 + 1 
3864 .. 00			db "RND16",0              
386a				endm 
# End of macro CWHEAD
386a			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
386a					if DEBUG_FORTH_WORDS_KEY 
386a						DMARK "R16" 
386a f5				push af  
386b 3a 7f 38			ld a, (.dmark)  
386e 32 bd fb			ld (debug_mark),a  
3871 3a 80 38			ld a, (.dmark+1)  
3874 32 be fb			ld (debug_mark+1),a  
3877 3a 81 38			ld a, (.dmark+2)  
387a 32 bf fb			ld (debug_mark+2),a  
387d 18 03			jr .pastdmark  
387f ..			.dmark: db "R16"  
3882 f1			.pastdmark: pop af  
3883			endm  
# End of macro DMARK
3883						CALLMONITOR 
3883 cd 20 17			call break_point_state  
3886				endm  
# End of macro CALLMONITOR
3886					endif 
3886 cd 2d 0c				call prng16  
3889 cd b0 1c				call forth_push_numhl 
388c				       NEXTW 
388c c3 19 20			jp macro_next 
388f				endm 
# End of macro NEXTW
388f			.RND8: 
388f				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
388f 60				db WORD_SYS_CORE+76             
3890 c4 38			dw .RND            
3892 05				db 4 + 1 
3893 .. 00			db "RND8",0              
3898				endm 
# End of macro CWHEAD
3898			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3898					if DEBUG_FORTH_WORDS_KEY 
3898						DMARK "RN8" 
3898 f5				push af  
3899 3a ad 38			ld a, (.dmark)  
389c 32 bd fb			ld (debug_mark),a  
389f 3a ae 38			ld a, (.dmark+1)  
38a2 32 be fb			ld (debug_mark+1),a  
38a5 3a af 38			ld a, (.dmark+2)  
38a8 32 bf fb			ld (debug_mark+2),a  
38ab 18 03			jr .pastdmark  
38ad ..			.dmark: db "RN8"  
38b0 f1			.pastdmark: pop af  
38b1			endm  
# End of macro DMARK
38b1						CALLMONITOR 
38b1 cd 20 17			call break_point_state  
38b4				endm  
# End of macro CALLMONITOR
38b4					endif 
38b4 2a 3e fa				ld hl,(xrandc) 
38b7 23					inc hl 
38b8 cd 47 0c				call xrnd 
38bb 6f					ld l,a	 
38bc 26 00				ld h,0 
38be cd b0 1c				call forth_push_numhl 
38c1				       NEXTW 
38c1 c3 19 20			jp macro_next 
38c4				endm 
# End of macro NEXTW
38c4			.RND: 
38c4				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38c4 60				db WORD_SYS_CORE+76             
38c5 ca 39			dw .ENDMATHS            
38c7 04				db 3 + 1 
38c8 .. 00			db "RND",0              
38cc				endm 
# End of macro CWHEAD
38cc			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38cc			 
38cc					if DEBUG_FORTH_WORDS_KEY 
38cc						DMARK "RND" 
38cc f5				push af  
38cd 3a e1 38			ld a, (.dmark)  
38d0 32 bd fb			ld (debug_mark),a  
38d3 3a e2 38			ld a, (.dmark+1)  
38d6 32 be fb			ld (debug_mark+1),a  
38d9 3a e3 38			ld a, (.dmark+2)  
38dc 32 bf fb			ld (debug_mark+2),a  
38df 18 03			jr .pastdmark  
38e1 ..			.dmark: db "RND"  
38e4 f1			.pastdmark: pop af  
38e5			endm  
# End of macro DMARK
38e5						CALLMONITOR 
38e5 cd 20 17			call break_point_state  
38e8				endm  
# End of macro CALLMONITOR
38e8					endif 
38e8					 
38e8					FORTH_DSP_VALUEHL    ; upper range 
38e8 cd a7 1e			call macro_dsp_valuehl 
38eb				endm 
# End of macro FORTH_DSP_VALUEHL
38eb			 
38eb 22 42 fa				ld (LFSRSeed), hl	 
38ee			 
38ee					if DEBUG_FORTH_WORDS 
38ee						DMARK "RN1" 
38ee f5				push af  
38ef 3a 03 39			ld a, (.dmark)  
38f2 32 bd fb			ld (debug_mark),a  
38f5 3a 04 39			ld a, (.dmark+1)  
38f8 32 be fb			ld (debug_mark+1),a  
38fb 3a 05 39			ld a, (.dmark+2)  
38fe 32 bf fb			ld (debug_mark+2),a  
3901 18 03			jr .pastdmark  
3903 ..			.dmark: db "RN1"  
3906 f1			.pastdmark: pop af  
3907			endm  
# End of macro DMARK
3907						CALLMONITOR 
3907 cd 20 17			call break_point_state  
390a				endm  
# End of macro CALLMONITOR
390a					endif 
390a					FORTH_DSP_POP 
390a cd 5f 1f			call macro_forth_dsp_pop 
390d				endm 
# End of macro FORTH_DSP_POP
390d			 
390d					FORTH_DSP_VALUEHL    ; low range 
390d cd a7 1e			call macro_dsp_valuehl 
3910				endm 
# End of macro FORTH_DSP_VALUEHL
3910			 
3910					if DEBUG_FORTH_WORDS 
3910						DMARK "RN2" 
3910 f5				push af  
3911 3a 25 39			ld a, (.dmark)  
3914 32 bd fb			ld (debug_mark),a  
3917 3a 26 39			ld a, (.dmark+1)  
391a 32 be fb			ld (debug_mark+1),a  
391d 3a 27 39			ld a, (.dmark+2)  
3920 32 bf fb			ld (debug_mark+2),a  
3923 18 03			jr .pastdmark  
3925 ..			.dmark: db "RN2"  
3928 f1			.pastdmark: pop af  
3929			endm  
# End of macro DMARK
3929						CALLMONITOR 
3929 cd 20 17			call break_point_state  
392c				endm  
# End of macro CALLMONITOR
392c					endif 
392c 22 44 fa				ld (LFSRSeed+2), hl 
392f			 
392f					FORTH_DSP_POP 
392f cd 5f 1f			call macro_forth_dsp_pop 
3932				endm 
# End of macro FORTH_DSP_POP
3932			 
3932 e5					push hl 
3933			 
3933 e1			.inrange:	pop hl 
3934 cd 2d 0c				call prng16  
3937					if DEBUG_FORTH_WORDS 
3937						DMARK "RN3" 
3937 f5				push af  
3938 3a 4c 39			ld a, (.dmark)  
393b 32 bd fb			ld (debug_mark),a  
393e 3a 4d 39			ld a, (.dmark+1)  
3941 32 be fb			ld (debug_mark+1),a  
3944 3a 4e 39			ld a, (.dmark+2)  
3947 32 bf fb			ld (debug_mark+2),a  
394a 18 03			jr .pastdmark  
394c ..			.dmark: db "RN3"  
394f f1			.pastdmark: pop af  
3950			endm  
# End of macro DMARK
3950						CALLMONITOR 
3950 cd 20 17			call break_point_state  
3953				endm  
# End of macro CALLMONITOR
3953					endif 
3953					 
3953					; if the range is 8bit knock out the high byte 
3953			 
3953 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
3957			 
3957 3e 00				ld a, 0 
3959 ba					cp d  
395a 20 1e				jr nz, .hirange 
395c 26 00				ld h, 0   ; knock it down to 8bit 
395e			 
395e					if DEBUG_FORTH_WORDS 
395e						DMARK "RNk" 
395e f5				push af  
395f 3a 73 39			ld a, (.dmark)  
3962 32 bd fb			ld (debug_mark),a  
3965 3a 74 39			ld a, (.dmark+1)  
3968 32 be fb			ld (debug_mark+1),a  
396b 3a 75 39			ld a, (.dmark+2)  
396e 32 bf fb			ld (debug_mark+2),a  
3971 18 03			jr .pastdmark  
3973 ..			.dmark: db "RNk"  
3976 f1			.pastdmark: pop af  
3977			endm  
# End of macro DMARK
3977						CALLMONITOR 
3977 cd 20 17			call break_point_state  
397a				endm  
# End of macro CALLMONITOR
397a					endif 
397a			.hirange:   
397a e5					push hl  
397b b7					or a  
397c ed 52		                sbc hl, de 
397e			 
397e					;call cmp16 
397e			 
397e 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3980 e1					pop hl 
3981 e5					push hl 
3982			 
3982					if DEBUG_FORTH_WORDS 
3982						DMARK "RN4" 
3982 f5				push af  
3983 3a 97 39			ld a, (.dmark)  
3986 32 bd fb			ld (debug_mark),a  
3989 3a 98 39			ld a, (.dmark+1)  
398c 32 be fb			ld (debug_mark+1),a  
398f 3a 99 39			ld a, (.dmark+2)  
3992 32 bf fb			ld (debug_mark+2),a  
3995 18 03			jr .pastdmark  
3997 ..			.dmark: db "RN4"  
399a f1			.pastdmark: pop af  
399b			endm  
# End of macro DMARK
399b						CALLMONITOR 
399b cd 20 17			call break_point_state  
399e				endm  
# End of macro CALLMONITOR
399e					endif 
399e ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
39a2					;call cmp16 
39a2				 
39a2 b7					or a  
39a3 ed 52		                sbc hl, de 
39a5 38 8c				jr c, .inrange 
39a7			 
39a7 e1					pop hl 
39a8					 
39a8					if DEBUG_FORTH_WORDS 
39a8						DMARK "RNd" 
39a8 f5				push af  
39a9 3a bd 39			ld a, (.dmark)  
39ac 32 bd fb			ld (debug_mark),a  
39af 3a be 39			ld a, (.dmark+1)  
39b2 32 be fb			ld (debug_mark+1),a  
39b5 3a bf 39			ld a, (.dmark+2)  
39b8 32 bf fb			ld (debug_mark+2),a  
39bb 18 03			jr .pastdmark  
39bd ..			.dmark: db "RNd"  
39c0 f1			.pastdmark: pop af  
39c1			endm  
# End of macro DMARK
39c1						CALLMONITOR 
39c1 cd 20 17			call break_point_state  
39c4				endm  
# End of macro CALLMONITOR
39c4					endif 
39c4			 
39c4			 
39c4 cd b0 1c				call forth_push_numhl 
39c7				       NEXTW 
39c7 c3 19 20			jp macro_next 
39ca				endm 
# End of macro NEXTW
39ca			 
39ca			.ENDMATHS: 
39ca			 
39ca			; eof 
39ca			 
# End of file forth_words_maths.asm
39ca			include "forth_words_display.asm" 
39ca			 
39ca			; | ## Display Words 
39ca			 
39ca			.ATP: 
39ca				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39ca 62				db WORD_SYS_CORE+78             
39cb 41 3a			dw .FB            
39cd 04				db 3 + 1 
39ce .. 00			db "AT?",0              
39d2				endm 
# End of macro CWHEAD
39d2			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
39d2					if DEBUG_FORTH_WORDS_KEY 
39d2						DMARK "AT?" 
39d2 f5				push af  
39d3 3a e7 39			ld a, (.dmark)  
39d6 32 bd fb			ld (debug_mark),a  
39d9 3a e8 39			ld a, (.dmark+1)  
39dc 32 be fb			ld (debug_mark+1),a  
39df 3a e9 39			ld a, (.dmark+2)  
39e2 32 bf fb			ld (debug_mark+2),a  
39e5 18 03			jr .pastdmark  
39e7 ..			.dmark: db "AT?"  
39ea f1			.pastdmark: pop af  
39eb			endm  
# End of macro DMARK
39eb						CALLMONITOR 
39eb cd 20 17			call break_point_state  
39ee				endm  
# End of macro CALLMONITOR
39ee					endif 
39ee 3a cc f9				ld a, (f_cursor_ptr) 
39f1			 
39f1			if DEBUG_FORTH_WORDS 
39f1				DMARK "AT?" 
39f1 f5				push af  
39f2 3a 06 3a			ld a, (.dmark)  
39f5 32 bd fb			ld (debug_mark),a  
39f8 3a 07 3a			ld a, (.dmark+1)  
39fb 32 be fb			ld (debug_mark+1),a  
39fe 3a 08 3a			ld a, (.dmark+2)  
3a01 32 bf fb			ld (debug_mark+2),a  
3a04 18 03			jr .pastdmark  
3a06 ..			.dmark: db "AT?"  
3a09 f1			.pastdmark: pop af  
3a0a			endm  
# End of macro DMARK
3a0a				CALLMONITOR 
3a0a cd 20 17			call break_point_state  
3a0d				endm  
# End of macro CALLMONITOR
3a0d			endif	 
3a0d					; count the number of rows 
3a0d			 
3a0d 06 00				ld b, 0 
3a0f 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a10 d6 14				sub display_cols 
3a12 f2 18 3a				jp p, .atprunder 
3a15 04					inc b 
3a16 18 f7				jr .atpr 
3a18			.atprunder:	 
3a18			if DEBUG_FORTH_WORDS 
3a18				DMARK "A?2" 
3a18 f5				push af  
3a19 3a 2d 3a			ld a, (.dmark)  
3a1c 32 bd fb			ld (debug_mark),a  
3a1f 3a 2e 3a			ld a, (.dmark+1)  
3a22 32 be fb			ld (debug_mark+1),a  
3a25 3a 2f 3a			ld a, (.dmark+2)  
3a28 32 bf fb			ld (debug_mark+2),a  
3a2b 18 03			jr .pastdmark  
3a2d ..			.dmark: db "A?2"  
3a30 f1			.pastdmark: pop af  
3a31			endm  
# End of macro DMARK
3a31				CALLMONITOR 
3a31 cd 20 17			call break_point_state  
3a34				endm  
# End of macro CALLMONITOR
3a34			endif	 
3a34 26 00				ld h, 0 
3a36 69					ld l, c 
3a37 cd b0 1c				call forth_push_numhl 
3a3a 68					ld l, b  
3a3b cd b0 1c				call forth_push_numhl 
3a3e			 
3a3e			 
3a3e				NEXTW 
3a3e c3 19 20			jp macro_next 
3a41				endm 
# End of macro NEXTW
3a41			 
3a41			.FB: 
3a41				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a41 1b				db WORD_SYS_CORE+7             
3a42 8f 3a			dw .EMIT            
3a44 03				db 2 + 1 
3a45 .. 00			db "FB",0              
3a48				endm 
# End of macro CWHEAD
3a48			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a48			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a48			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a48			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a48					if DEBUG_FORTH_WORDS_KEY 
3a48						DMARK "FB." 
3a48 f5				push af  
3a49 3a 5d 3a			ld a, (.dmark)  
3a4c 32 bd fb			ld (debug_mark),a  
3a4f 3a 5e 3a			ld a, (.dmark+1)  
3a52 32 be fb			ld (debug_mark+1),a  
3a55 3a 5f 3a			ld a, (.dmark+2)  
3a58 32 bf fb			ld (debug_mark+2),a  
3a5b 18 03			jr .pastdmark  
3a5d ..			.dmark: db "FB."  
3a60 f1			.pastdmark: pop af  
3a61			endm  
# End of macro DMARK
3a61						CALLMONITOR 
3a61 cd 20 17			call break_point_state  
3a64				endm  
# End of macro CALLMONITOR
3a64					endif 
3a64			 
3a64					FORTH_DSP_VALUEHL 
3a64 cd a7 1e			call macro_dsp_valuehl 
3a67				endm 
# End of macro FORTH_DSP_VALUEHL
3a67			 
3a67 7d					ld a, l 
3a68 fe 01				cp 1 
3a6a 20 05				jr nz, .fbn1 
3a6c 21 02 fb				ld hl, display_fb1 
3a6f 18 15				jr .fbset 
3a71 fe 02		.fbn1:		cp 2 
3a73 20 05				jr nz, .fbn2 
3a75 21 60 fa				ld hl, display_fb2 
3a78 18 0c				jr .fbset 
3a7a fe 03		.fbn2:		cp 3 
3a7c 20 05				jr nz, .fbn3 
3a7e 21 b1 fa				ld hl, display_fb3 
3a81 18 03				jr .fbset 
3a83			.fbn3:		 ; if invalid number select first 
3a83 21 02 fb				ld hl, display_fb1 
3a86 22 5e fa		.fbset:		ld (display_fb_active), hl 
3a89			 
3a89					FORTH_DSP_POP 
3a89 cd 5f 1f			call macro_forth_dsp_pop 
3a8c				endm 
# End of macro FORTH_DSP_POP
3a8c			 
3a8c					NEXTW 
3a8c c3 19 20			jp macro_next 
3a8f				endm 
# End of macro NEXTW
3a8f			 
3a8f			 
3a8f			.EMIT: 
3a8f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3a8f 1b				db WORD_SYS_CORE+7             
3a90 e0 3a			dw .DOTH            
3a92 05				db 4 + 1 
3a93 .. 00			db "EMIT",0              
3a98				endm 
# End of macro CWHEAD
3a98			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3a98					; get value off TOS and display it 
3a98			 
3a98					if DEBUG_FORTH_WORDS_KEY 
3a98						DMARK "EMT" 
3a98 f5				push af  
3a99 3a ad 3a			ld a, (.dmark)  
3a9c 32 bd fb			ld (debug_mark),a  
3a9f 3a ae 3a			ld a, (.dmark+1)  
3aa2 32 be fb			ld (debug_mark+1),a  
3aa5 3a af 3a			ld a, (.dmark+2)  
3aa8 32 bf fb			ld (debug_mark+2),a  
3aab 18 03			jr .pastdmark  
3aad ..			.dmark: db "EMT"  
3ab0 f1			.pastdmark: pop af  
3ab1			endm  
# End of macro DMARK
3ab1						CALLMONITOR 
3ab1 cd 20 17			call break_point_state  
3ab4				endm  
# End of macro CALLMONITOR
3ab4					endif 
3ab4			 
3ab4					FORTH_DSP_VALUEHL 
3ab4 cd a7 1e			call macro_dsp_valuehl 
3ab7				endm 
# End of macro FORTH_DSP_VALUEHL
3ab7			 
3ab7 7d					ld a,l 
3ab8			 
3ab8					; TODO write to display 
3ab8			 
3ab8 32 a1 f1				ld (os_input), a 
3abb 3e 00				ld a, 0 
3abd 32 a2 f1				ld (os_input+1), a 
3ac0					 
3ac0 3a cc f9				ld a, (f_cursor_ptr) 
3ac3 11 a1 f1				ld de, os_input 
3ac6 cd e5 0a				call str_at_display 
3ac9			 
3ac9			 
3ac9 3a aa f9				ld a,(cli_autodisplay) 
3acc fe 00				cp 0 
3ace 28 03				jr z, .enoupdate 
3ad0 cd f5 0a						call update_display 
3ad3					.enoupdate: 
3ad3			 
3ad3 3a cc f9				ld a, (f_cursor_ptr) 
3ad6 3c					inc a 
3ad7 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3ada			 
3ada			 
3ada					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ada cd 5f 1f			call macro_forth_dsp_pop 
3add				endm 
# End of macro FORTH_DSP_POP
3add			  
3add			 
3add					NEXTW 
3add c3 19 20			jp macro_next 
3ae0				endm 
# End of macro NEXTW
3ae0			.DOTH: 
3ae0				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3ae0 1c				db WORD_SYS_CORE+8             
3ae1 10 3b			dw .DOTF            
3ae3 03				db 2 + 1 
3ae4 .. 00			db ".-",0              
3ae7				endm 
# End of macro CWHEAD
3ae7			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3ae7					; get value off TOS and display it 
3ae7					if DEBUG_FORTH_WORDS_KEY 
3ae7						DMARK "DTD" 
3ae7 f5				push af  
3ae8 3a fc 3a			ld a, (.dmark)  
3aeb 32 bd fb			ld (debug_mark),a  
3aee 3a fd 3a			ld a, (.dmark+1)  
3af1 32 be fb			ld (debug_mark+1),a  
3af4 3a fe 3a			ld a, (.dmark+2)  
3af7 32 bf fb			ld (debug_mark+2),a  
3afa 18 03			jr .pastdmark  
3afc ..			.dmark: db "DTD"  
3aff f1			.pastdmark: pop af  
3b00			endm  
# End of macro DMARK
3b00						CALLMONITOR 
3b00 cd 20 17			call break_point_state  
3b03				endm  
# End of macro CALLMONITOR
3b03					endif 
3b03 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b05 3e 00			ld a, 0 
3b07 32 ab f9			ld (cli_mvdot), a 
3b0a c3 67 3b			jp .dotgo 
3b0d				NEXTW 
3b0d c3 19 20			jp macro_next 
3b10				endm 
# End of macro NEXTW
3b10			.DOTF: 
3b10				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b10 1c				db WORD_SYS_CORE+8             
3b11 3e 3b			dw .DOT            
3b13 03				db 2 + 1 
3b14 .. 00			db ".>",0              
3b17				endm 
# End of macro CWHEAD
3b17			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b17					; get value off TOS and display it 
3b17			        ; TODO BUG adds extra spaces 
3b17			        ; TODO BUG handle numerics? 
3b17					if DEBUG_FORTH_WORDS_KEY 
3b17						DMARK "DTC" 
3b17 f5				push af  
3b18 3a 2c 3b			ld a, (.dmark)  
3b1b 32 bd fb			ld (debug_mark),a  
3b1e 3a 2d 3b			ld a, (.dmark+1)  
3b21 32 be fb			ld (debug_mark+1),a  
3b24 3a 2e 3b			ld a, (.dmark+2)  
3b27 32 bf fb			ld (debug_mark+2),a  
3b2a 18 03			jr .pastdmark  
3b2c ..			.dmark: db "DTC"  
3b2f f1			.pastdmark: pop af  
3b30			endm  
# End of macro DMARK
3b30						CALLMONITOR 
3b30 cd 20 17			call break_point_state  
3b33				endm  
# End of macro CALLMONITOR
3b33					endif 
3b33 3e 01			ld a, 1 
3b35 32 ab f9			ld (cli_mvdot), a 
3b38 c3 67 3b			jp .dotgo 
3b3b				NEXTW 
3b3b c3 19 20			jp macro_next 
3b3e				endm 
# End of macro NEXTW
3b3e			 
3b3e			.DOT: 
3b3e				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b3e 1c				db WORD_SYS_CORE+8             
3b3f ca 3b			dw .CLS            
3b41 02				db 1 + 1 
3b42 .. 00			db ".",0              
3b44				endm 
# End of macro CWHEAD
3b44			        ; | . ( u -- ) Display TOS | DONE 
3b44					; get value off TOS and display it 
3b44			 
3b44					if DEBUG_FORTH_WORDS_KEY 
3b44						DMARK "DOT" 
3b44 f5				push af  
3b45 3a 59 3b			ld a, (.dmark)  
3b48 32 bd fb			ld (debug_mark),a  
3b4b 3a 5a 3b			ld a, (.dmark+1)  
3b4e 32 be fb			ld (debug_mark+1),a  
3b51 3a 5b 3b			ld a, (.dmark+2)  
3b54 32 bf fb			ld (debug_mark+2),a  
3b57 18 03			jr .pastdmark  
3b59 ..			.dmark: db "DOT"  
3b5c f1			.pastdmark: pop af  
3b5d			endm  
# End of macro DMARK
3b5d						CALLMONITOR 
3b5d cd 20 17			call break_point_state  
3b60				endm  
# End of macro CALLMONITOR
3b60					endif 
3b60 3e 00			ld a, 0 
3b62 32 ab f9			ld (cli_mvdot), a 
3b65 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b67				 
3b67			 
3b67			.dotgo: 
3b67			 
3b67			; move up type to on stack for parserv5 
3b67					FORTH_DSP 
3b67 cd 6d 1e			call macro_forth_dsp 
3b6a				endm 
# End of macro FORTH_DSP
3b6a				;FORTH_DSP_VALUE  
3b6a			 
3b6a			if DEBUG_FORTH_DOT 
3b6a				DMARK "DOT" 
3b6a				CALLMONITOR 
3b6a			endif	 
3b6a			;		.print: 
3b6a			 
3b6a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b6b 23				inc hl   ; position to the actual value 
3b6c fe 01			cp DS_TYPE_STR 
3b6e 20 06			jr nz, .dotnum1  
3b70			 
3b70			; display string 
3b70				FORTH_DSP_VALUE  
3b70 cd 90 1e			call macro_forth_dsp_value 
3b73				endm 
# End of macro FORTH_DSP_VALUE
3b73 eb				ex de,hl 
3b74 18 11			jr .dotwrite 
3b76			 
3b76			.dotnum1: 
3b76 fe 02			cp DS_TYPE_INUM 
3b78 20 0c			jr nz, .dotflot 
3b7a			 
3b7a			 
3b7a			; display number 
3b7a			 
3b7a			;	push hl 
3b7a			;	call clear_display 
3b7a			;	pop hl 
3b7a			 
3b7a 5e				ld e, (hl) 
3b7b 23				inc hl 
3b7c 56				ld d, (hl) 
3b7d 21 a3 ef			ld hl, scratch 
3b80			if DEBUG_FORTH_DOT 
3b80				DMARK "DT1" 
3b80				CALLMONITOR 
3b80			endif	 
3b80			 
3b80 cd 13 11			call uitoa_16 
3b83 eb				ex de,hl 
3b84			 
3b84			if DEBUG_FORTH_DOT 
3b84				DMARK "DT2" 
3b84				CALLMONITOR 
3b84			endif	 
3b84			 
3b84			;	ld de, os_word_scratch 
3b84 18 01			jr .dotwrite 
3b86			 
3b86 00			.dotflot:   nop 
3b87			; TODO print floating point number 
3b87			 
3b87			.dotwrite:		 
3b87			 
3b87					; if c is set then set all '-' to spaces 
3b87					; need to also take into account .>  
3b87			 
3b87 3e 01				ld a, 1 
3b89 b9					cp c 
3b8a 20 13				jr nz, .nodashswap 
3b8c			 
3b8c					; DE has the string to write, working with HL 
3b8c			 
3b8c 06 ff				ld b, 255 
3b8e d5					push de 
3b8f e1					pop hl 
3b90			 
3b90			if DEBUG_FORTH_DOT 
3b90				DMARK "DT-" 
3b90				CALLMONITOR 
3b90			endif	 
3b90 7e			.dashscan:	ld a, (hl) 
3b91 fe 00				cp 0 
3b93 28 0a				jr z, .nodashswap 
3b95 fe 2d				cp '-' 
3b97 20 03				jr nz, .dashskip 
3b99 3e 20				ld a, ' ' 
3b9b 77					ld (hl), a 
3b9c 23			.dashskip:	inc hl 
3b9d			if DEBUG_FORTH_DOT 
3b9d				DMARK "D-2" 
3b9d				CALLMONITOR 
3b9d			endif	 
3b9d 10 f1				djnz .dashscan 
3b9f			 
3b9f			if DEBUG_FORTH_DOT 
3b9f				DMARK "D-1" 
3b9f				CALLMONITOR 
3b9f			endif	 
3b9f			 
3b9f			.nodashswap: 
3b9f			 
3b9f e5					push hl   ; save string start in case we need to advance print 
3ba0			 
3ba0 3a cc f9				ld a, (f_cursor_ptr) 
3ba3 cd e5 0a				call str_at_display 
3ba6 3a aa f9				ld a,(cli_autodisplay) 
3ba9 fe 00				cp 0 
3bab 28 03				jr z, .noupdate 
3bad cd f5 0a						call update_display 
3bb0					.noupdate: 
3bb0			 
3bb0			 
3bb0					; see if we need to advance the print position 
3bb0			 
3bb0 e1					pop hl   ; get back string 
3bb1			 
3bb1 3a ab f9				ld a, (cli_mvdot) 
3bb4			if DEBUG_FORTH_DOT 
3bb4					ld e,a 
3bb4				DMARK "D>1" 
3bb4				CALLMONITOR 
3bb4			endif	 
3bb4 fe 00				cp 0 
3bb6 28 0c				jr z, .noadv 
3bb8					; yes, lets advance the print position 
3bb8 3e 00				ld a, 0 
3bba cd 6f 11				call strlent 
3bbd 3a cc f9				ld a, (f_cursor_ptr) 
3bc0 85					add a,l 
3bc1					;call addatohl 
3bc1					;ld a, l 
3bc1 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3bc4			 
3bc4			if DEBUG_FORTH_DOT 
3bc4				DMARK "D->" 
3bc4				CALLMONITOR 
3bc4			endif	 
3bc4			 
3bc4			.noadv:	 
3bc4			 
3bc4					if DEBUG_FORTH_DOT_WAIT 
3bc4							call next_page_prompt 
3bc4					endif	 
3bc4			; TODO this pop off the stack causes a crash. i dont know why 
3bc4			 
3bc4			 
3bc4			if DEBUG_FORTH_DOT 
3bc4				DMARK "DTh" 
3bc4				CALLMONITOR 
3bc4			endif	 
3bc4			 
3bc4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc4 cd 5f 1f			call macro_forth_dsp_pop 
3bc7				endm 
# End of macro FORTH_DSP_POP
3bc7			 
3bc7			if DEBUG_FORTH_DOT 
3bc7				DMARK "DTi" 
3bc7				CALLMONITOR 
3bc7			endif	 
3bc7			 
3bc7			 
3bc7					NEXTW 
3bc7 c3 19 20			jp macro_next 
3bca				endm 
# End of macro NEXTW
3bca			 
3bca			.CLS: 
3bca				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3bca 35				db WORD_SYS_CORE+33             
3bcb f7 3b			dw .DRAW            
3bcd 04				db 3 + 1 
3bce .. 00			db "CLS",0              
3bd2				endm 
# End of macro CWHEAD
3bd2			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3bd2					if DEBUG_FORTH_WORDS_KEY 
3bd2						DMARK "CLS" 
3bd2 f5				push af  
3bd3 3a e7 3b			ld a, (.dmark)  
3bd6 32 bd fb			ld (debug_mark),a  
3bd9 3a e8 3b			ld a, (.dmark+1)  
3bdc 32 be fb			ld (debug_mark+1),a  
3bdf 3a e9 3b			ld a, (.dmark+2)  
3be2 32 bf fb			ld (debug_mark+2),a  
3be5 18 03			jr .pastdmark  
3be7 ..			.dmark: db "CLS"  
3bea f1			.pastdmark: pop af  
3beb			endm  
# End of macro DMARK
3beb						CALLMONITOR 
3beb cd 20 17			call break_point_state  
3bee				endm  
# End of macro CALLMONITOR
3bee					endif 
3bee cd d2 0a				call clear_display 
3bf1 c3 05 3d				jp .home		; and home cursor 
3bf4					NEXTW 
3bf4 c3 19 20			jp macro_next 
3bf7				endm 
# End of macro NEXTW
3bf7			 
3bf7			.DRAW: 
3bf7				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3bf7 36				db WORD_SYS_CORE+34             
3bf8 22 3c			dw .DUMP            
3bfa 05				db 4 + 1 
3bfb .. 00			db "DRAW",0              
3c00				endm 
# End of macro CWHEAD
3c00			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c00					if DEBUG_FORTH_WORDS_KEY 
3c00						DMARK "DRW" 
3c00 f5				push af  
3c01 3a 15 3c			ld a, (.dmark)  
3c04 32 bd fb			ld (debug_mark),a  
3c07 3a 16 3c			ld a, (.dmark+1)  
3c0a 32 be fb			ld (debug_mark+1),a  
3c0d 3a 17 3c			ld a, (.dmark+2)  
3c10 32 bf fb			ld (debug_mark+2),a  
3c13 18 03			jr .pastdmark  
3c15 ..			.dmark: db "DRW"  
3c18 f1			.pastdmark: pop af  
3c19			endm  
# End of macro DMARK
3c19						CALLMONITOR 
3c19 cd 20 17			call break_point_state  
3c1c				endm  
# End of macro CALLMONITOR
3c1c					endif 
3c1c cd f5 0a				call update_display 
3c1f					NEXTW 
3c1f c3 19 20			jp macro_next 
3c22				endm 
# End of macro NEXTW
3c22			 
3c22			.DUMP: 
3c22				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c22 37				db WORD_SYS_CORE+35             
3c23 5a 3c			dw .CDUMP            
3c25 05				db 4 + 1 
3c26 .. 00			db "DUMP",0              
3c2b				endm 
# End of macro CWHEAD
3c2b			; | DUMP ( x -- ) With address x display dump   | DONE 
3c2b			; TODO pop address to use off of the stack 
3c2b					if DEBUG_FORTH_WORDS_KEY 
3c2b						DMARK "DUM" 
3c2b f5				push af  
3c2c 3a 40 3c			ld a, (.dmark)  
3c2f 32 bd fb			ld (debug_mark),a  
3c32 3a 41 3c			ld a, (.dmark+1)  
3c35 32 be fb			ld (debug_mark+1),a  
3c38 3a 42 3c			ld a, (.dmark+2)  
3c3b 32 bf fb			ld (debug_mark+2),a  
3c3e 18 03			jr .pastdmark  
3c40 ..			.dmark: db "DUM"  
3c43 f1			.pastdmark: pop af  
3c44			endm  
# End of macro DMARK
3c44						CALLMONITOR 
3c44 cd 20 17			call break_point_state  
3c47				endm  
# End of macro CALLMONITOR
3c47					endif 
3c47 cd d2 0a				call clear_display 
3c4a			 
3c4a					; get address 
3c4a			 
3c4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4a cd a7 1e			call macro_dsp_valuehl 
3c4d				endm 
# End of macro FORTH_DSP_VALUEHL
3c4d				 
3c4d					; save it for cdump 
3c4d			 
3c4d 22 c6 f2				ld (os_cur_ptr),hl 
3c50			 
3c50					; destroy value TOS 
3c50			 
3c50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c50 cd 5f 1f			call macro_forth_dsp_pop 
3c53				endm 
# End of macro FORTH_DSP_POP
3c53			 
3c53 cd 30 1b				call dumpcont	; skip old style of param parsing	 
3c56 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c57					NEXTW 
3c57 c3 19 20			jp macro_next 
3c5a				endm 
# End of macro NEXTW
3c5a			.CDUMP: 
3c5a				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c5a 38				db WORD_SYS_CORE+36             
3c5b 8a 3c			dw .DAT            
3c5d 06				db 5 + 1 
3c5e .. 00			db "CDUMP",0              
3c64				endm 
# End of macro CWHEAD
3c64			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c64					if DEBUG_FORTH_WORDS_KEY 
3c64						DMARK "CDP" 
3c64 f5				push af  
3c65 3a 79 3c			ld a, (.dmark)  
3c68 32 bd fb			ld (debug_mark),a  
3c6b 3a 7a 3c			ld a, (.dmark+1)  
3c6e 32 be fb			ld (debug_mark+1),a  
3c71 3a 7b 3c			ld a, (.dmark+2)  
3c74 32 bf fb			ld (debug_mark+2),a  
3c77 18 03			jr .pastdmark  
3c79 ..			.dmark: db "CDP"  
3c7c f1			.pastdmark: pop af  
3c7d			endm  
# End of macro DMARK
3c7d						CALLMONITOR 
3c7d cd 20 17			call break_point_state  
3c80				endm  
# End of macro CALLMONITOR
3c80					endif 
3c80 cd d2 0a				call clear_display 
3c83 cd 30 1b				call dumpcont	 
3c86 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3c87					NEXTW 
3c87 c3 19 20			jp macro_next 
3c8a				endm 
# End of macro NEXTW
3c8a			 
3c8a			 
3c8a			 
3c8a			 
3c8a			.DAT: 
3c8a				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3c8a 3d				db WORD_SYS_CORE+41             
3c8b e0 3c			dw .HOME            
3c8d 03				db 2 + 1 
3c8e .. 00			db "AT",0              
3c91				endm 
# End of macro CWHEAD
3c91			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3c91					if DEBUG_FORTH_WORDS_KEY 
3c91						DMARK "AT." 
3c91 f5				push af  
3c92 3a a6 3c			ld a, (.dmark)  
3c95 32 bd fb			ld (debug_mark),a  
3c98 3a a7 3c			ld a, (.dmark+1)  
3c9b 32 be fb			ld (debug_mark+1),a  
3c9e 3a a8 3c			ld a, (.dmark+2)  
3ca1 32 bf fb			ld (debug_mark+2),a  
3ca4 18 03			jr .pastdmark  
3ca6 ..			.dmark: db "AT."  
3ca9 f1			.pastdmark: pop af  
3caa			endm  
# End of macro DMARK
3caa						CALLMONITOR 
3caa cd 20 17			call break_point_state  
3cad				endm  
# End of macro CALLMONITOR
3cad					endif 
3cad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cad cd a7 1e			call macro_dsp_valuehl 
3cb0				endm 
# End of macro FORTH_DSP_VALUEHL
3cb0			 
3cb0			 
3cb0					; TODO save cursor row 
3cb0 7d					ld a,l 
3cb1 fe 02				cp 2 
3cb3 20 04				jr nz, .crow3 
3cb5 3e 14				ld a, display_row_2 
3cb7 18 12				jr .ccol1 
3cb9 fe 03		.crow3:		cp 3 
3cbb 20 04				jr nz, .crow4 
3cbd 3e 28				ld a, display_row_3 
3cbf 18 0a				jr .ccol1 
3cc1 fe 04		.crow4:		cp 4 
3cc3 20 04				jr nz, .crow1 
3cc5 3e 3c				ld a, display_row_4 
3cc7 18 02				jr .ccol1 
3cc9 3e 00		.crow1:		ld a,display_row_1 
3ccb f5			.ccol1:		push af			; got row offset 
3ccc 6f					ld l,a 
3ccd 26 00				ld h,0 
3ccf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ccf cd 5f 1f			call macro_forth_dsp_pop 
3cd2				endm 
# End of macro FORTH_DSP_POP
3cd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd2 cd a7 1e			call macro_dsp_valuehl 
3cd5				endm 
# End of macro FORTH_DSP_VALUEHL
3cd5					; TODO save cursor col 
3cd5 f1					pop af 
3cd6 85					add l		; add col offset 
3cd7 32 cc f9				ld (f_cursor_ptr), a 
3cda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cda cd 5f 1f			call macro_forth_dsp_pop 
3cdd				endm 
# End of macro FORTH_DSP_POP
3cdd			 
3cdd					; calculate  
3cdd			 
3cdd					NEXTW 
3cdd c3 19 20			jp macro_next 
3ce0				endm 
# End of macro NEXTW
3ce0			 
3ce0			 
3ce0			.HOME: 
3ce0				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3ce0 41				db WORD_SYS_CORE+45             
3ce1 0d 3d			dw .SPACE            
3ce3 05				db 4 + 1 
3ce4 .. 00			db "HOME",0              
3ce9				endm 
# End of macro CWHEAD
3ce9			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ce9					if DEBUG_FORTH_WORDS_KEY 
3ce9						DMARK "HOM" 
3ce9 f5				push af  
3cea 3a fe 3c			ld a, (.dmark)  
3ced 32 bd fb			ld (debug_mark),a  
3cf0 3a ff 3c			ld a, (.dmark+1)  
3cf3 32 be fb			ld (debug_mark+1),a  
3cf6 3a 00 3d			ld a, (.dmark+2)  
3cf9 32 bf fb			ld (debug_mark+2),a  
3cfc 18 03			jr .pastdmark  
3cfe ..			.dmark: db "HOM"  
3d01 f1			.pastdmark: pop af  
3d02			endm  
# End of macro DMARK
3d02						CALLMONITOR 
3d02 cd 20 17			call break_point_state  
3d05				endm  
# End of macro CALLMONITOR
3d05					endif 
3d05 3e 00		.home:		ld a, 0		; and home cursor 
3d07 32 cc f9				ld (f_cursor_ptr), a 
3d0a					NEXTW 
3d0a c3 19 20			jp macro_next 
3d0d				endm 
# End of macro NEXTW
3d0d			 
3d0d			 
3d0d			.SPACE: 
3d0d				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d0d 46				db WORD_SYS_CORE+50             
3d0e 3b 3d			dw .SPACES            
3d10 03				db 2 + 1 
3d11 .. 00			db "BL",0              
3d14				endm 
# End of macro CWHEAD
3d14			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d14					if DEBUG_FORTH_WORDS_KEY 
3d14						DMARK "BL." 
3d14 f5				push af  
3d15 3a 29 3d			ld a, (.dmark)  
3d18 32 bd fb			ld (debug_mark),a  
3d1b 3a 2a 3d			ld a, (.dmark+1)  
3d1e 32 be fb			ld (debug_mark+1),a  
3d21 3a 2b 3d			ld a, (.dmark+2)  
3d24 32 bf fb			ld (debug_mark+2),a  
3d27 18 03			jr .pastdmark  
3d29 ..			.dmark: db "BL."  
3d2c f1			.pastdmark: pop af  
3d2d			endm  
# End of macro DMARK
3d2d						CALLMONITOR 
3d2d cd 20 17			call break_point_state  
3d30				endm  
# End of macro CALLMONITOR
3d30					endif 
3d30 21 39 3d				ld hl, .blstr 
3d33 cd 1e 1d				call forth_push_str 
3d36					 
3d36				       NEXTW 
3d36 c3 19 20			jp macro_next 
3d39				endm 
# End of macro NEXTW
3d39			 
3d39 .. 00		.blstr: db " ", 0 
3d3b			 
3d3b			.SPACES: 
3d3b				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d3b 47				db WORD_SYS_CORE+51             
3d3c d6 3d			dw .SCROLL            
3d3e 07				db 6 + 1 
3d3f .. 00			db "SPACES",0              
3d46				endm 
# End of macro CWHEAD
3d46			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d46					if DEBUG_FORTH_WORDS_KEY 
3d46						DMARK "SPS" 
3d46 f5				push af  
3d47 3a 5b 3d			ld a, (.dmark)  
3d4a 32 bd fb			ld (debug_mark),a  
3d4d 3a 5c 3d			ld a, (.dmark+1)  
3d50 32 be fb			ld (debug_mark+1),a  
3d53 3a 5d 3d			ld a, (.dmark+2)  
3d56 32 bf fb			ld (debug_mark+2),a  
3d59 18 03			jr .pastdmark  
3d5b ..			.dmark: db "SPS"  
3d5e f1			.pastdmark: pop af  
3d5f			endm  
# End of macro DMARK
3d5f						CALLMONITOR 
3d5f cd 20 17			call break_point_state  
3d62				endm  
# End of macro CALLMONITOR
3d62					endif 
3d62			 
3d62			 
3d62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d62 cd a7 1e			call macro_dsp_valuehl 
3d65				endm 
# End of macro FORTH_DSP_VALUEHL
3d65			 
3d65			;		push hl    ; u 
3d65					if DEBUG_FORTH_WORDS 
3d65						DMARK "SPA" 
3d65 f5				push af  
3d66 3a 7a 3d			ld a, (.dmark)  
3d69 32 bd fb			ld (debug_mark),a  
3d6c 3a 7b 3d			ld a, (.dmark+1)  
3d6f 32 be fb			ld (debug_mark+1),a  
3d72 3a 7c 3d			ld a, (.dmark+2)  
3d75 32 bf fb			ld (debug_mark+2),a  
3d78 18 03			jr .pastdmark  
3d7a ..			.dmark: db "SPA"  
3d7d f1			.pastdmark: pop af  
3d7e			endm  
# End of macro DMARK
3d7e						CALLMONITOR 
3d7e cd 20 17			call break_point_state  
3d81				endm  
# End of macro CALLMONITOR
3d81					endif 
3d81			 
3d81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d81 cd 5f 1f			call macro_forth_dsp_pop 
3d84				endm 
# End of macro FORTH_DSP_POP
3d84			;		pop hl 
3d84 4d					ld c, l 
3d85 06 00				ld b, 0 
3d87 21 a3 ef				ld hl, scratch  
3d8a			 
3d8a					if DEBUG_FORTH_WORDS 
3d8a						DMARK "SP2" 
3d8a f5				push af  
3d8b 3a 9f 3d			ld a, (.dmark)  
3d8e 32 bd fb			ld (debug_mark),a  
3d91 3a a0 3d			ld a, (.dmark+1)  
3d94 32 be fb			ld (debug_mark+1),a  
3d97 3a a1 3d			ld a, (.dmark+2)  
3d9a 32 bf fb			ld (debug_mark+2),a  
3d9d 18 03			jr .pastdmark  
3d9f ..			.dmark: db "SP2"  
3da2 f1			.pastdmark: pop af  
3da3			endm  
# End of macro DMARK
3da3						CALLMONITOR 
3da3 cd 20 17			call break_point_state  
3da6				endm  
# End of macro CALLMONITOR
3da6					endif 
3da6 3e 20				ld a, ' ' 
3da8 c5			.spaces1:	push bc 
3da9 77					ld (hl),a 
3daa 23					inc hl 
3dab c1					pop bc 
3dac 10 fa				djnz .spaces1 
3dae 3e 00				ld a,0 
3db0 77					ld (hl),a 
3db1 21 a3 ef				ld hl, scratch 
3db4					if DEBUG_FORTH_WORDS 
3db4						DMARK "SP3" 
3db4 f5				push af  
3db5 3a c9 3d			ld a, (.dmark)  
3db8 32 bd fb			ld (debug_mark),a  
3dbb 3a ca 3d			ld a, (.dmark+1)  
3dbe 32 be fb			ld (debug_mark+1),a  
3dc1 3a cb 3d			ld a, (.dmark+2)  
3dc4 32 bf fb			ld (debug_mark+2),a  
3dc7 18 03			jr .pastdmark  
3dc9 ..			.dmark: db "SP3"  
3dcc f1			.pastdmark: pop af  
3dcd			endm  
# End of macro DMARK
3dcd						CALLMONITOR 
3dcd cd 20 17			call break_point_state  
3dd0				endm  
# End of macro CALLMONITOR
3dd0					endif 
3dd0 cd 19 1e				call forth_apush 
3dd3			 
3dd3				       NEXTW 
3dd3 c3 19 20			jp macro_next 
3dd6				endm 
# End of macro NEXTW
3dd6			 
3dd6			 
3dd6			 
3dd6			.SCROLL: 
3dd6				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3dd6 53				db WORD_SYS_CORE+63             
3dd7 03 3e			dw .SCROLLD            
3dd9 07				db 6 + 1 
3dda .. 00			db "SCROLL",0              
3de1				endm 
# End of macro CWHEAD
3de1			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3de1					if DEBUG_FORTH_WORDS_KEY 
3de1						DMARK "SCR" 
3de1 f5				push af  
3de2 3a f6 3d			ld a, (.dmark)  
3de5 32 bd fb			ld (debug_mark),a  
3de8 3a f7 3d			ld a, (.dmark+1)  
3deb 32 be fb			ld (debug_mark+1),a  
3dee 3a f8 3d			ld a, (.dmark+2)  
3df1 32 bf fb			ld (debug_mark+2),a  
3df4 18 03			jr .pastdmark  
3df6 ..			.dmark: db "SCR"  
3df9 f1			.pastdmark: pop af  
3dfa			endm  
# End of macro DMARK
3dfa						CALLMONITOR 
3dfa cd 20 17			call break_point_state  
3dfd				endm  
# End of macro CALLMONITOR
3dfd					endif 
3dfd			 
3dfd cd 94 0a			call scroll_up 
3e00			;	call update_display 
3e00			 
3e00					NEXTW 
3e00 c3 19 20			jp macro_next 
3e03				endm 
# End of macro NEXTW
3e03			 
3e03			 
3e03			 
3e03			;		; get dir 
3e03			; 
3e03			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e03			; 
3e03			;		push hl 
3e03			; 
3e03			;		; destroy value TOS 
3e03			; 
3e03			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e03			; 
3e03			;		; get count 
3e03			; 
3e03			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e03			; 
3e03			;		push hl 
3e03			; 
3e03			;		; destroy value TOS 
3e03			; 
3e03			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e03			; 
3e03			;		; one value on hl get other one back 
3e03			; 
3e03			;		pop bc    ; count 
3e03			; 
3e03			;		pop de   ; dir 
3e03			; 
3e03			; 
3e03			;		ld b, c 
3e03			; 
3e03			;.scrolldir:     push bc 
3e03			;		push de 
3e03			; 
3e03			;		ld a, 0 
3e03			;		cp e 
3e03			;		jr z, .scrollup  
3e03			;		call scroll_down 
3e03			;		jr .scrollnext 
3e03			;.scrollup:	call scroll_up 
3e03			; 
3e03			;		 
3e03			;.scrollnext: 
3e03			;		pop de 
3e03			;		pop bc 
3e03			;		djnz .scrolldir 
3e03			; 
3e03			; 
3e03			; 
3e03			; 
3e03			; 
3e03			;		NEXTW 
3e03			 
3e03			.SCROLLD: 
3e03				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e03 53				db WORD_SYS_CORE+63             
3e04 31 3e			dw .ATQ            
3e06 08				db 7 + 1 
3e07 .. 00			db "SCROLLD",0              
3e0f				endm 
# End of macro CWHEAD
3e0f			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e0f					if DEBUG_FORTH_WORDS_KEY 
3e0f						DMARK "SCD" 
3e0f f5				push af  
3e10 3a 24 3e			ld a, (.dmark)  
3e13 32 bd fb			ld (debug_mark),a  
3e16 3a 25 3e			ld a, (.dmark+1)  
3e19 32 be fb			ld (debug_mark+1),a  
3e1c 3a 26 3e			ld a, (.dmark+2)  
3e1f 32 bf fb			ld (debug_mark+2),a  
3e22 18 03			jr .pastdmark  
3e24 ..			.dmark: db "SCD"  
3e27 f1			.pastdmark: pop af  
3e28			endm  
# End of macro DMARK
3e28						CALLMONITOR 
3e28 cd 20 17			call break_point_state  
3e2b				endm  
# End of macro CALLMONITOR
3e2b					endif 
3e2b			 
3e2b cd b8 0a			call scroll_down 
3e2e			;	call update_display 
3e2e			 
3e2e					NEXTW 
3e2e c3 19 20			jp macro_next 
3e31				endm 
# End of macro NEXTW
3e31			 
3e31			 
3e31			.ATQ: 
3e31				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e31 62				db WORD_SYS_CORE+78             
3e32 8f 3e			dw .AUTODSP            
3e34 04				db 3 + 1 
3e35 .. 00			db "AT@",0              
3e39				endm 
# End of macro CWHEAD
3e39			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e39					if DEBUG_FORTH_WORDS_KEY 
3e39						DMARK "ATA" 
3e39 f5				push af  
3e3a 3a 4e 3e			ld a, (.dmark)  
3e3d 32 bd fb			ld (debug_mark),a  
3e40 3a 4f 3e			ld a, (.dmark+1)  
3e43 32 be fb			ld (debug_mark+1),a  
3e46 3a 50 3e			ld a, (.dmark+2)  
3e49 32 bf fb			ld (debug_mark+2),a  
3e4c 18 03			jr .pastdmark  
3e4e ..			.dmark: db "ATA"  
3e51 f1			.pastdmark: pop af  
3e52			endm  
# End of macro DMARK
3e52						CALLMONITOR 
3e52 cd 20 17			call break_point_state  
3e55				endm  
# End of macro CALLMONITOR
3e55					endif 
3e55			 
3e55			 
3e55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e55 cd a7 1e			call macro_dsp_valuehl 
3e58				endm 
# End of macro FORTH_DSP_VALUEHL
3e58			 
3e58					; TODO save cursor row 
3e58 7d					ld a,l 
3e59 fe 02				cp 2 
3e5b 20 04				jr nz, .crow3aq 
3e5d 3e 14				ld a, display_row_2 
3e5f 18 12				jr .ccol1aq 
3e61 fe 03		.crow3aq:		cp 3 
3e63 20 04				jr nz, .crow4aq 
3e65 3e 28				ld a, display_row_3 
3e67 18 0a				jr .ccol1aq 
3e69 fe 04		.crow4aq:		cp 4 
3e6b 20 04				jr nz, .crow1aq 
3e6d 3e 3c				ld a, display_row_4 
3e6f 18 02				jr .ccol1aq 
3e71 3e 00		.crow1aq:		ld a,display_row_1 
3e73 f5			.ccol1aq:		push af			; got row offset 
3e74 6f					ld l,a 
3e75 26 00				ld h,0 
3e77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e77 cd 5f 1f			call macro_forth_dsp_pop 
3e7a				endm 
# End of macro FORTH_DSP_POP
3e7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e7a cd a7 1e			call macro_dsp_valuehl 
3e7d				endm 
# End of macro FORTH_DSP_VALUEHL
3e7d					; TODO save cursor col 
3e7d f1					pop af 
3e7e 85					add l		; add col offset 
3e7f			 
3e7f					; add current frame buffer address 
3e7f 2a 5e fa				ld hl, (display_fb_active) 
3e82 cd 06 0d				call addatohl 
3e85			 
3e85			 
3e85			 
3e85			 
3e85					; get char frame buffer location offset in hl 
3e85			 
3e85 7e					ld a,(hl) 
3e86 26 00				ld h, 0 
3e88 6f					ld l, a 
3e89			 
3e89 cd b0 1c				call forth_push_numhl 
3e8c			 
3e8c			 
3e8c					NEXTW 
3e8c c3 19 20			jp macro_next 
3e8f				endm 
# End of macro NEXTW
3e8f			 
3e8f			.AUTODSP: 
3e8f				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3e8f 63				db WORD_SYS_CORE+79             
3e90 a5 3e			dw .MENU            
3e92 05				db 4 + 1 
3e93 .. 00			db "ADSP",0              
3e98				endm 
# End of macro CWHEAD
3e98			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3e98			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3e98			 
3e98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e98 cd a7 1e			call macro_dsp_valuehl 
3e9b				endm 
# End of macro FORTH_DSP_VALUEHL
3e9b			 
3e9b			;		push hl 
3e9b			 
3e9b					; destroy value TOS 
3e9b			 
3e9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9b cd 5f 1f			call macro_forth_dsp_pop 
3e9e				endm 
# End of macro FORTH_DSP_POP
3e9e			 
3e9e			;		pop hl 
3e9e			 
3e9e 7d					ld a,l 
3e9f 32 aa f9				ld (cli_autodisplay), a 
3ea2				       NEXTW 
3ea2 c3 19 20			jp macro_next 
3ea5				endm 
# End of macro NEXTW
3ea5			 
3ea5			.MENU: 
3ea5				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3ea5 70				db WORD_SYS_CORE+92             
3ea6 4e 3f			dw .ENDDISPLAY            
3ea8 05				db 4 + 1 
3ea9 .. 00			db "MENU",0              
3eae				endm 
# End of macro CWHEAD
3eae			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3eae			 
3eae			;		; get number of items on the stack 
3eae			; 
3eae				 
3eae					FORTH_DSP_VALUEHL 
3eae cd a7 1e			call macro_dsp_valuehl 
3eb1				endm 
# End of macro FORTH_DSP_VALUEHL
3eb1				 
3eb1					if DEBUG_FORTH_WORDS_KEY 
3eb1						DMARK "MNU" 
3eb1 f5				push af  
3eb2 3a c6 3e			ld a, (.dmark)  
3eb5 32 bd fb			ld (debug_mark),a  
3eb8 3a c7 3e			ld a, (.dmark+1)  
3ebb 32 be fb			ld (debug_mark+1),a  
3ebe 3a c8 3e			ld a, (.dmark+2)  
3ec1 32 bf fb			ld (debug_mark+2),a  
3ec4 18 03			jr .pastdmark  
3ec6 ..			.dmark: db "MNU"  
3ec9 f1			.pastdmark: pop af  
3eca			endm  
# End of macro DMARK
3eca						CALLMONITOR 
3eca cd 20 17			call break_point_state  
3ecd				endm  
# End of macro CALLMONITOR
3ecd					endif 
3ecd			 
3ecd 45					ld b, l	 
3ece 05					dec b 
3ecf			 
3ecf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ecf cd 5f 1f			call macro_forth_dsp_pop 
3ed2				endm 
# End of macro FORTH_DSP_POP
3ed2			 
3ed2			 
3ed2					; go directly through the stack to pluck out the string pointers and build an array 
3ed2			 
3ed2			;		FORTH_DSP 
3ed2			 
3ed2					; hl contains top most stack item 
3ed2				 
3ed2 11 a3 ef				ld de, scratch 
3ed5			 
3ed5			.mbuild: 
3ed5			 
3ed5					FORTH_DSP_VALUEHL 
3ed5 cd a7 1e			call macro_dsp_valuehl 
3ed8				endm 
# End of macro FORTH_DSP_VALUEHL
3ed8			 
3ed8					if DEBUG_FORTH_WORDS 
3ed8						DMARK "MN3" 
3ed8 f5				push af  
3ed9 3a ed 3e			ld a, (.dmark)  
3edc 32 bd fb			ld (debug_mark),a  
3edf 3a ee 3e			ld a, (.dmark+1)  
3ee2 32 be fb			ld (debug_mark+1),a  
3ee5 3a ef 3e			ld a, (.dmark+2)  
3ee8 32 bf fb			ld (debug_mark+2),a  
3eeb 18 03			jr .pastdmark  
3eed ..			.dmark: db "MN3"  
3ef0 f1			.pastdmark: pop af  
3ef1			endm  
# End of macro DMARK
3ef1						CALLMONITOR 
3ef1 cd 20 17			call break_point_state  
3ef4				endm  
# End of macro CALLMONITOR
3ef4					endif 
3ef4 eb					ex de, hl 
3ef5 73					ld (hl), e 
3ef6 23					inc hl 
3ef7 72					ld (hl), d 
3ef8 23					inc hl 
3ef9 eb					ex de, hl 
3efa			 
3efa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3efa cd 5f 1f			call macro_forth_dsp_pop 
3efd				endm 
# End of macro FORTH_DSP_POP
3efd			 
3efd 10 d6				djnz .mbuild 
3eff			 
3eff					; done add term 
3eff			 
3eff eb					ex de, hl 
3f00 36 00				ld (hl), 0 
3f02 23					inc hl 
3f03 36 00				ld (hl), 0 
3f05			 
3f05				 
3f05					 
3f05 21 a3 ef				ld hl, scratch 
3f08			 
3f08					if DEBUG_FORTH_WORDS 
3f08						DMARK "MNx" 
3f08 f5				push af  
3f09 3a 1d 3f			ld a, (.dmark)  
3f0c 32 bd fb			ld (debug_mark),a  
3f0f 3a 1e 3f			ld a, (.dmark+1)  
3f12 32 be fb			ld (debug_mark+1),a  
3f15 3a 1f 3f			ld a, (.dmark+2)  
3f18 32 bf fb			ld (debug_mark+2),a  
3f1b 18 03			jr .pastdmark  
3f1d ..			.dmark: db "MNx"  
3f20 f1			.pastdmark: pop af  
3f21			endm  
# End of macro DMARK
3f21						CALLMONITOR 
3f21 cd 20 17			call break_point_state  
3f24				endm  
# End of macro CALLMONITOR
3f24					endif 
3f24			 
3f24			 
3f24			 
3f24 3e 00				ld a, 0 
3f26 cd 03 0b				call menu 
3f29			 
3f29			 
3f29 6f					ld l, a 
3f2a 26 00				ld h, 0 
3f2c			 
3f2c					if DEBUG_FORTH_WORDS 
3f2c						DMARK "MNr" 
3f2c f5				push af  
3f2d 3a 41 3f			ld a, (.dmark)  
3f30 32 bd fb			ld (debug_mark),a  
3f33 3a 42 3f			ld a, (.dmark+1)  
3f36 32 be fb			ld (debug_mark+1),a  
3f39 3a 43 3f			ld a, (.dmark+2)  
3f3c 32 bf fb			ld (debug_mark+2),a  
3f3f 18 03			jr .pastdmark  
3f41 ..			.dmark: db "MNr"  
3f44 f1			.pastdmark: pop af  
3f45			endm  
# End of macro DMARK
3f45						CALLMONITOR 
3f45 cd 20 17			call break_point_state  
3f48				endm  
# End of macro CALLMONITOR
3f48					endif 
3f48			 
3f48 cd b0 1c				call forth_push_numhl 
3f4b			 
3f4b			 
3f4b			 
3f4b			 
3f4b				       NEXTW 
3f4b c3 19 20			jp macro_next 
3f4e				endm 
# End of macro NEXTW
3f4e			 
3f4e			 
3f4e			.ENDDISPLAY: 
3f4e			 
3f4e			; eof 
# End of file forth_words_display.asm
3f4e			include "forth_words_str.asm" 
3f4e			 
3f4e			; | ## String Words 
3f4e			 
3f4e			.PTR:   
3f4e			 
3f4e				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f4e 48				db WORD_SYS_CORE+52             
3f4f 7b 3f			dw .STYPE            
3f51 04				db 3 + 1 
3f52 .. 00			db "PTR",0              
3f56				endm 
# End of macro CWHEAD
3f56			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f56			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f56			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f56			 
3f56					if DEBUG_FORTH_WORDS_KEY 
3f56						DMARK "PTR" 
3f56 f5				push af  
3f57 3a 6b 3f			ld a, (.dmark)  
3f5a 32 bd fb			ld (debug_mark),a  
3f5d 3a 6c 3f			ld a, (.dmark+1)  
3f60 32 be fb			ld (debug_mark+1),a  
3f63 3a 6d 3f			ld a, (.dmark+2)  
3f66 32 bf fb			ld (debug_mark+2),a  
3f69 18 03			jr .pastdmark  
3f6b ..			.dmark: db "PTR"  
3f6e f1			.pastdmark: pop af  
3f6f			endm  
# End of macro DMARK
3f6f						CALLMONITOR 
3f6f cd 20 17			call break_point_state  
3f72				endm  
# End of macro CALLMONITOR
3f72					endif 
3f72					FORTH_DSP_VALUEHL 
3f72 cd a7 1e			call macro_dsp_valuehl 
3f75				endm 
# End of macro FORTH_DSP_VALUEHL
3f75 cd b0 1c				call forth_push_numhl 
3f78			 
3f78			 
3f78					NEXTW 
3f78 c3 19 20			jp macro_next 
3f7b				endm 
# End of macro NEXTW
3f7b			.STYPE: 
3f7b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3f7b 48				db WORD_SYS_CORE+52             
3f7c ca 3f			dw .UPPER            
3f7e 06				db 5 + 1 
3f7f .. 00			db "STYPE",0              
3f85				endm 
# End of macro CWHEAD
3f85			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3f85					if DEBUG_FORTH_WORDS_KEY 
3f85						DMARK "STY" 
3f85 f5				push af  
3f86 3a 9a 3f			ld a, (.dmark)  
3f89 32 bd fb			ld (debug_mark),a  
3f8c 3a 9b 3f			ld a, (.dmark+1)  
3f8f 32 be fb			ld (debug_mark+1),a  
3f92 3a 9c 3f			ld a, (.dmark+2)  
3f95 32 bf fb			ld (debug_mark+2),a  
3f98 18 03			jr .pastdmark  
3f9a ..			.dmark: db "STY"  
3f9d f1			.pastdmark: pop af  
3f9e			endm  
# End of macro DMARK
3f9e						CALLMONITOR 
3f9e cd 20 17			call break_point_state  
3fa1				endm  
# End of macro CALLMONITOR
3fa1					endif 
3fa1					FORTH_DSP 
3fa1 cd 6d 1e			call macro_forth_dsp 
3fa4				endm 
# End of macro FORTH_DSP
3fa4					;v5 FORTH_DSP_VALUE 
3fa4			 
3fa4 7e					ld a, (hl) 
3fa5			 
3fa5 f5					push af 
3fa6			 
3fa6			; Dont destroy TOS		FORTH_DSP_POP 
3fa6			 
3fa6 f1					pop af 
3fa7			 
3fa7 fe 01				cp DS_TYPE_STR 
3fa9 28 09				jr z, .typestr 
3fab			 
3fab fe 02				cp DS_TYPE_INUM 
3fad 28 0a				jr z, .typeinum 
3faf			 
3faf 21 c8 3f				ld hl, .tna 
3fb2 18 0a				jr .tpush 
3fb4			 
3fb4 21 c4 3f		.typestr:	ld hl, .tstr 
3fb7 18 05				jr .tpush 
3fb9 21 c6 3f		.typeinum:	ld hl, .tinum 
3fbc 18 00				jr .tpush 
3fbe			 
3fbe			.tpush: 
3fbe			 
3fbe cd 1e 1d				call forth_push_str 
3fc1			 
3fc1					NEXTW 
3fc1 c3 19 20			jp macro_next 
3fc4				endm 
# End of macro NEXTW
3fc4 .. 00		.tstr:	db "s",0 
3fc6 .. 00		.tinum:  db "i",0 
3fc8 .. 00		.tna:   db "?", 0 
3fca			 
3fca			 
3fca			.UPPER: 
3fca				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3fca 48				db WORD_SYS_CORE+52             
3fcb 05 40			dw .LOWER            
3fcd 06				db 5 + 1 
3fce .. 00			db "UPPER",0              
3fd4				endm 
# End of macro CWHEAD
3fd4			; | UPPER ( s -- s ) Upper case string s  | DONE 
3fd4					if DEBUG_FORTH_WORDS_KEY 
3fd4						DMARK "UPR" 
3fd4 f5				push af  
3fd5 3a e9 3f			ld a, (.dmark)  
3fd8 32 bd fb			ld (debug_mark),a  
3fdb 3a ea 3f			ld a, (.dmark+1)  
3fde 32 be fb			ld (debug_mark+1),a  
3fe1 3a eb 3f			ld a, (.dmark+2)  
3fe4 32 bf fb			ld (debug_mark+2),a  
3fe7 18 03			jr .pastdmark  
3fe9 ..			.dmark: db "UPR"  
3fec f1			.pastdmark: pop af  
3fed			endm  
# End of macro DMARK
3fed						CALLMONITOR 
3fed cd 20 17			call break_point_state  
3ff0				endm  
# End of macro CALLMONITOR
3ff0					endif 
3ff0			 
3ff0					FORTH_DSP 
3ff0 cd 6d 1e			call macro_forth_dsp 
3ff3				endm 
# End of macro FORTH_DSP
3ff3					 
3ff3			; TODO check is string type 
3ff3			 
3ff3					FORTH_DSP_VALUEHL 
3ff3 cd a7 1e			call macro_dsp_valuehl 
3ff6				endm 
# End of macro FORTH_DSP_VALUEHL
3ff6			; get pointer to string in hl 
3ff6			 
3ff6 7e			.toup:		ld a, (hl) 
3ff7 fe 00				cp 0 
3ff9 28 07				jr z, .toupdone 
3ffb			 
3ffb cd 73 10				call to_upper 
3ffe			 
3ffe 77					ld (hl), a 
3fff 23					inc hl 
4000 18 f4				jr .toup 
4002			 
4002					 
4002			 
4002			 
4002			; for each char convert to upper 
4002					 
4002			.toupdone: 
4002			 
4002			 
4002					NEXTW 
4002 c3 19 20			jp macro_next 
4005				endm 
# End of macro NEXTW
4005			.LOWER: 
4005				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4005 48				db WORD_SYS_CORE+52             
4006 40 40			dw .TCASE            
4008 06				db 5 + 1 
4009 .. 00			db "LOWER",0              
400f				endm 
# End of macro CWHEAD
400f			; | LOWER ( s -- s ) Lower case string s  | DONE 
400f					if DEBUG_FORTH_WORDS_KEY 
400f						DMARK "LWR" 
400f f5				push af  
4010 3a 24 40			ld a, (.dmark)  
4013 32 bd fb			ld (debug_mark),a  
4016 3a 25 40			ld a, (.dmark+1)  
4019 32 be fb			ld (debug_mark+1),a  
401c 3a 26 40			ld a, (.dmark+2)  
401f 32 bf fb			ld (debug_mark+2),a  
4022 18 03			jr .pastdmark  
4024 ..			.dmark: db "LWR"  
4027 f1			.pastdmark: pop af  
4028			endm  
# End of macro DMARK
4028						CALLMONITOR 
4028 cd 20 17			call break_point_state  
402b				endm  
# End of macro CALLMONITOR
402b					endif 
402b			 
402b					FORTH_DSP 
402b cd 6d 1e			call macro_forth_dsp 
402e				endm 
# End of macro FORTH_DSP
402e					 
402e			; TODO check is string type 
402e			 
402e					FORTH_DSP_VALUEHL 
402e cd a7 1e			call macro_dsp_valuehl 
4031				endm 
# End of macro FORTH_DSP_VALUEHL
4031			; get pointer to string in hl 
4031			 
4031 7e			.tolow:		ld a, (hl) 
4032 fe 00				cp 0 
4034 28 07				jr z, .tolowdone 
4036			 
4036 cd 7c 10				call to_lower 
4039			 
4039 77					ld (hl), a 
403a 23					inc hl 
403b 18 f4				jr .tolow 
403d			 
403d					 
403d			 
403d			 
403d			; for each char convert to low 
403d					 
403d			.tolowdone: 
403d					NEXTW 
403d c3 19 20			jp macro_next 
4040				endm 
# End of macro NEXTW
4040			.TCASE: 
4040				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4040 48				db WORD_SYS_CORE+52             
4041 76 41			dw .SUBSTR            
4043 06				db 5 + 1 
4044 .. 00			db "TCASE",0              
404a				endm 
# End of macro CWHEAD
404a			; | TCASE ( s -- s ) Title case string s  | DONE 
404a					if DEBUG_FORTH_WORDS_KEY 
404a						DMARK "TCS" 
404a f5				push af  
404b 3a 5f 40			ld a, (.dmark)  
404e 32 bd fb			ld (debug_mark),a  
4051 3a 60 40			ld a, (.dmark+1)  
4054 32 be fb			ld (debug_mark+1),a  
4057 3a 61 40			ld a, (.dmark+2)  
405a 32 bf fb			ld (debug_mark+2),a  
405d 18 03			jr .pastdmark  
405f ..			.dmark: db "TCS"  
4062 f1			.pastdmark: pop af  
4063			endm  
# End of macro DMARK
4063						CALLMONITOR 
4063 cd 20 17			call break_point_state  
4066				endm  
# End of macro CALLMONITOR
4066					endif 
4066			 
4066					FORTH_DSP 
4066 cd 6d 1e			call macro_forth_dsp 
4069				endm 
# End of macro FORTH_DSP
4069					 
4069			; TODO check is string type 
4069			 
4069					FORTH_DSP_VALUEHL 
4069 cd a7 1e			call macro_dsp_valuehl 
406c				endm 
# End of macro FORTH_DSP_VALUEHL
406c			; get pointer to string in hl 
406c			 
406c					if DEBUG_FORTH_WORDS 
406c						DMARK "TC1" 
406c f5				push af  
406d 3a 81 40			ld a, (.dmark)  
4070 32 bd fb			ld (debug_mark),a  
4073 3a 82 40			ld a, (.dmark+1)  
4076 32 be fb			ld (debug_mark+1),a  
4079 3a 83 40			ld a, (.dmark+2)  
407c 32 bf fb			ld (debug_mark+2),a  
407f 18 03			jr .pastdmark  
4081 ..			.dmark: db "TC1"  
4084 f1			.pastdmark: pop af  
4085			endm  
# End of macro DMARK
4085						CALLMONITOR 
4085 cd 20 17			call break_point_state  
4088				endm  
# End of macro CALLMONITOR
4088					endif 
4088			 
4088					; first time in turn to upper case first char 
4088			 
4088 7e					ld a, (hl) 
4089 c3 13 41				jp .totsiptou 
408c			 
408c			 
408c 7e			.tot:		ld a, (hl) 
408d fe 00				cp 0 
408f ca 57 41				jp z, .totdone 
4092			 
4092					if DEBUG_FORTH_WORDS 
4092						DMARK "TC2" 
4092 f5				push af  
4093 3a a7 40			ld a, (.dmark)  
4096 32 bd fb			ld (debug_mark),a  
4099 3a a8 40			ld a, (.dmark+1)  
409c 32 be fb			ld (debug_mark+1),a  
409f 3a a9 40			ld a, (.dmark+2)  
40a2 32 bf fb			ld (debug_mark+2),a  
40a5 18 03			jr .pastdmark  
40a7 ..			.dmark: db "TC2"  
40aa f1			.pastdmark: pop af  
40ab			endm  
# End of macro DMARK
40ab						CALLMONITOR 
40ab cd 20 17			call break_point_state  
40ae				endm  
# End of macro CALLMONITOR
40ae					endif 
40ae					; check to see if current char is a space 
40ae			 
40ae fe 20				cp ' ' 
40b0 28 21				jr z, .totsp 
40b2 cd 7c 10				call to_lower 
40b5					if DEBUG_FORTH_WORDS 
40b5						DMARK "TC3" 
40b5 f5				push af  
40b6 3a ca 40			ld a, (.dmark)  
40b9 32 bd fb			ld (debug_mark),a  
40bc 3a cb 40			ld a, (.dmark+1)  
40bf 32 be fb			ld (debug_mark+1),a  
40c2 3a cc 40			ld a, (.dmark+2)  
40c5 32 bf fb			ld (debug_mark+2),a  
40c8 18 03			jr .pastdmark  
40ca ..			.dmark: db "TC3"  
40cd f1			.pastdmark: pop af  
40ce			endm  
# End of macro DMARK
40ce						CALLMONITOR 
40ce cd 20 17			call break_point_state  
40d1				endm  
# End of macro CALLMONITOR
40d1					endif 
40d1 18 63				jr .totnxt 
40d3			 
40d3			.totsp:         ; on a space, find next char which should be upper 
40d3			 
40d3					if DEBUG_FORTH_WORDS 
40d3						DMARK "TC4" 
40d3 f5				push af  
40d4 3a e8 40			ld a, (.dmark)  
40d7 32 bd fb			ld (debug_mark),a  
40da 3a e9 40			ld a, (.dmark+1)  
40dd 32 be fb			ld (debug_mark+1),a  
40e0 3a ea 40			ld a, (.dmark+2)  
40e3 32 bf fb			ld (debug_mark+2),a  
40e6 18 03			jr .pastdmark  
40e8 ..			.dmark: db "TC4"  
40eb f1			.pastdmark: pop af  
40ec			endm  
# End of macro DMARK
40ec						CALLMONITOR 
40ec cd 20 17			call break_point_state  
40ef				endm  
# End of macro CALLMONITOR
40ef					endif 
40ef					;; 
40ef			 
40ef fe 20				cp ' ' 
40f1 20 20				jr nz, .totsiptou 
40f3 23					inc hl 
40f4 7e					ld a, (hl) 
40f5					if DEBUG_FORTH_WORDS 
40f5						DMARK "TC5" 
40f5 f5				push af  
40f6 3a 0a 41			ld a, (.dmark)  
40f9 32 bd fb			ld (debug_mark),a  
40fc 3a 0b 41			ld a, (.dmark+1)  
40ff 32 be fb			ld (debug_mark+1),a  
4102 3a 0c 41			ld a, (.dmark+2)  
4105 32 bf fb			ld (debug_mark+2),a  
4108 18 03			jr .pastdmark  
410a ..			.dmark: db "TC5"  
410d f1			.pastdmark: pop af  
410e			endm  
# End of macro DMARK
410e						CALLMONITOR 
410e cd 20 17			call break_point_state  
4111				endm  
# End of macro CALLMONITOR
4111					endif 
4111 18 c0				jr .totsp 
4113 fe 00		.totsiptou:    cp 0 
4115 28 40				jr z, .totdone 
4117					; not space and not zero term so upper case it 
4117 cd 73 10				call to_upper 
411a			 
411a					if DEBUG_FORTH_WORDS 
411a						DMARK "TC6" 
411a f5				push af  
411b 3a 2f 41			ld a, (.dmark)  
411e 32 bd fb			ld (debug_mark),a  
4121 3a 30 41			ld a, (.dmark+1)  
4124 32 be fb			ld (debug_mark+1),a  
4127 3a 31 41			ld a, (.dmark+2)  
412a 32 bf fb			ld (debug_mark+2),a  
412d 18 03			jr .pastdmark  
412f ..			.dmark: db "TC6"  
4132 f1			.pastdmark: pop af  
4133			endm  
# End of macro DMARK
4133						CALLMONITOR 
4133 cd 20 17			call break_point_state  
4136				endm  
# End of macro CALLMONITOR
4136					endif 
4136			 
4136			 
4136			.totnxt: 
4136			 
4136 77					ld (hl), a 
4137 23					inc hl 
4138					if DEBUG_FORTH_WORDS 
4138						DMARK "TC7" 
4138 f5				push af  
4139 3a 4d 41			ld a, (.dmark)  
413c 32 bd fb			ld (debug_mark),a  
413f 3a 4e 41			ld a, (.dmark+1)  
4142 32 be fb			ld (debug_mark+1),a  
4145 3a 4f 41			ld a, (.dmark+2)  
4148 32 bf fb			ld (debug_mark+2),a  
414b 18 03			jr .pastdmark  
414d ..			.dmark: db "TC7"  
4150 f1			.pastdmark: pop af  
4151			endm  
# End of macro DMARK
4151						CALLMONITOR 
4151 cd 20 17			call break_point_state  
4154				endm  
# End of macro CALLMONITOR
4154					endif 
4154 c3 8c 40				jp .tot 
4157			 
4157					 
4157			 
4157			 
4157			; for each char convert to low 
4157					 
4157			.totdone: 
4157					if DEBUG_FORTH_WORDS 
4157						DMARK "TCd" 
4157 f5				push af  
4158 3a 6c 41			ld a, (.dmark)  
415b 32 bd fb			ld (debug_mark),a  
415e 3a 6d 41			ld a, (.dmark+1)  
4161 32 be fb			ld (debug_mark+1),a  
4164 3a 6e 41			ld a, (.dmark+2)  
4167 32 bf fb			ld (debug_mark+2),a  
416a 18 03			jr .pastdmark  
416c ..			.dmark: db "TCd"  
416f f1			.pastdmark: pop af  
4170			endm  
# End of macro DMARK
4170						CALLMONITOR 
4170 cd 20 17			call break_point_state  
4173				endm  
# End of macro CALLMONITOR
4173					endif 
4173					NEXTW 
4173 c3 19 20			jp macro_next 
4176				endm 
# End of macro NEXTW
4176			 
4176			.SUBSTR: 
4176				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4176 48				db WORD_SYS_CORE+52             
4177 d4 41			dw .LEFT            
4179 07				db 6 + 1 
417a .. 00			db "SUBSTR",0              
4181				endm 
# End of macro CWHEAD
4181			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4181			 
4181					if DEBUG_FORTH_WORDS_KEY 
4181						DMARK "SST" 
4181 f5				push af  
4182 3a 96 41			ld a, (.dmark)  
4185 32 bd fb			ld (debug_mark),a  
4188 3a 97 41			ld a, (.dmark+1)  
418b 32 be fb			ld (debug_mark+1),a  
418e 3a 98 41			ld a, (.dmark+2)  
4191 32 bf fb			ld (debug_mark+2),a  
4194 18 03			jr .pastdmark  
4196 ..			.dmark: db "SST"  
4199 f1			.pastdmark: pop af  
419a			endm  
# End of macro DMARK
419a						CALLMONITOR 
419a cd 20 17			call break_point_state  
419d				endm  
# End of macro CALLMONITOR
419d					endif 
419d			; TODO check string type 
419d					FORTH_DSP_VALUEHL 
419d cd a7 1e			call macro_dsp_valuehl 
41a0				endm 
# End of macro FORTH_DSP_VALUEHL
41a0			 
41a0 e5					push hl      ; string length 
41a1			 
41a1					FORTH_DSP_POP 
41a1 cd 5f 1f			call macro_forth_dsp_pop 
41a4				endm 
# End of macro FORTH_DSP_POP
41a4			 
41a4					FORTH_DSP_VALUEHL 
41a4 cd a7 1e			call macro_dsp_valuehl 
41a7				endm 
# End of macro FORTH_DSP_VALUEHL
41a7			 
41a7 e5					push hl     ; start char 
41a8			 
41a8					FORTH_DSP_POP 
41a8 cd 5f 1f			call macro_forth_dsp_pop 
41ab				endm 
# End of macro FORTH_DSP_POP
41ab			 
41ab			 
41ab					FORTH_DSP_VALUE 
41ab cd 90 1e			call macro_forth_dsp_value 
41ae				endm 
# End of macro FORTH_DSP_VALUE
41ae			 
41ae d1					pop de    ; get start post offset 
41af			 
41af 19					add hl, de    ; starting offset 
41b0			 
41b0 c1					pop bc 
41b1 c5					push bc      ; grab size of string 
41b2			 
41b2 e5					push hl    ; save string start  
41b3			 
41b3 26 00				ld h, 0 
41b5 69					ld l, c 
41b6 23					inc hl 
41b7 23					inc hl 
41b8			 
41b8 cd cd 11				call malloc 
41bb				if DEBUG_FORTH_MALLOC_GUARD 
41bb cc 3e 51				call z,malloc_error 
41be				endif 
41be			 
41be eb					ex de, hl      ; save malloc area for string copy 
41bf e1					pop hl    ; get back source 
41c0 c1					pop bc    ; get length of string back 
41c1			 
41c1 d5					push de    ; save malloc area for after we push 
41c2 ed b0				ldir     ; copy substr 
41c4			 
41c4			 
41c4 eb					ex de, hl 
41c5 3e 00				ld a, 0 
41c7 77					ld (hl), a   ; term substr 
41c8			 
41c8					 
41c8 e1					pop hl    ; get malloc so we can push it 
41c9 e5					push hl   ; save so we can free it afterwards 
41ca			 
41ca cd 1e 1d				call forth_push_str 
41cd			 
41cd e1					pop hl 
41ce cd 97 12				call free 
41d1			 
41d1					 
41d1					 
41d1			 
41d1			 
41d1					NEXTW 
41d1 c3 19 20			jp macro_next 
41d4				endm 
# End of macro NEXTW
41d4			 
41d4			.LEFT: 
41d4				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
41d4 48				db WORD_SYS_CORE+52             
41d5 fc 41			dw .RIGHT            
41d7 05				db 4 + 1 
41d8 .. 00			db "LEFT",0              
41dd				endm 
# End of macro CWHEAD
41dd			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
41dd					if DEBUG_FORTH_WORDS_KEY 
41dd						DMARK "LEF" 
41dd f5				push af  
41de 3a f2 41			ld a, (.dmark)  
41e1 32 bd fb			ld (debug_mark),a  
41e4 3a f3 41			ld a, (.dmark+1)  
41e7 32 be fb			ld (debug_mark+1),a  
41ea 3a f4 41			ld a, (.dmark+2)  
41ed 32 bf fb			ld (debug_mark+2),a  
41f0 18 03			jr .pastdmark  
41f2 ..			.dmark: db "LEF"  
41f5 f1			.pastdmark: pop af  
41f6			endm  
# End of macro DMARK
41f6						CALLMONITOR 
41f6 cd 20 17			call break_point_state  
41f9				endm  
# End of macro CALLMONITOR
41f9					endif 
41f9			 
41f9					NEXTW 
41f9 c3 19 20			jp macro_next 
41fc				endm 
# End of macro NEXTW
41fc			.RIGHT: 
41fc				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
41fc 48				db WORD_SYS_CORE+52             
41fd 25 42			dw .STR2NUM            
41ff 06				db 5 + 1 
4200 .. 00			db "RIGHT",0              
4206				endm 
# End of macro CWHEAD
4206			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4206					if DEBUG_FORTH_WORDS_KEY 
4206						DMARK "RIG" 
4206 f5				push af  
4207 3a 1b 42			ld a, (.dmark)  
420a 32 bd fb			ld (debug_mark),a  
420d 3a 1c 42			ld a, (.dmark+1)  
4210 32 be fb			ld (debug_mark+1),a  
4213 3a 1d 42			ld a, (.dmark+2)  
4216 32 bf fb			ld (debug_mark+2),a  
4219 18 03			jr .pastdmark  
421b ..			.dmark: db "RIG"  
421e f1			.pastdmark: pop af  
421f			endm  
# End of macro DMARK
421f						CALLMONITOR 
421f cd 20 17			call break_point_state  
4222				endm  
# End of macro CALLMONITOR
4222					endif 
4222			 
4222					NEXTW 
4222 c3 19 20			jp macro_next 
4225				endm 
# End of macro NEXTW
4225			 
4225			 
4225			.STR2NUM: 
4225				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4225 48				db WORD_SYS_CORE+52             
4226 b1 42			dw .NUM2STR            
4228 08				db 7 + 1 
4229 .. 00			db "STR2NUM",0              
4231				endm 
# End of macro CWHEAD
4231			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4231			 
4231			 
4231			; TODO STR type check to do 
4231					if DEBUG_FORTH_WORDS_KEY 
4231						DMARK "S2N" 
4231 f5				push af  
4232 3a 46 42			ld a, (.dmark)  
4235 32 bd fb			ld (debug_mark),a  
4238 3a 47 42			ld a, (.dmark+1)  
423b 32 be fb			ld (debug_mark+1),a  
423e 3a 48 42			ld a, (.dmark+2)  
4241 32 bf fb			ld (debug_mark+2),a  
4244 18 03			jr .pastdmark  
4246 ..			.dmark: db "S2N"  
4249 f1			.pastdmark: pop af  
424a			endm  
# End of macro DMARK
424a						CALLMONITOR 
424a cd 20 17			call break_point_state  
424d				endm  
# End of macro CALLMONITOR
424d					endif 
424d			 
424d					;FORTH_DSP 
424d					FORTH_DSP_VALUE 
424d cd 90 1e			call macro_forth_dsp_value 
4250				endm 
# End of macro FORTH_DSP_VALUE
4250					;inc hl 
4250			 
4250 eb					ex de, hl 
4251					if DEBUG_FORTH_WORDS 
4251						DMARK "S2a" 
4251 f5				push af  
4252 3a 66 42			ld a, (.dmark)  
4255 32 bd fb			ld (debug_mark),a  
4258 3a 67 42			ld a, (.dmark+1)  
425b 32 be fb			ld (debug_mark+1),a  
425e 3a 68 42			ld a, (.dmark+2)  
4261 32 bf fb			ld (debug_mark+2),a  
4264 18 03			jr .pastdmark  
4266 ..			.dmark: db "S2a"  
4269 f1			.pastdmark: pop af  
426a			endm  
# End of macro DMARK
426a						CALLMONITOR 
426a cd 20 17			call break_point_state  
426d				endm  
# End of macro CALLMONITOR
426d					endif 
426d cd fb 10				call string_to_uint16 
4270			 
4270					if DEBUG_FORTH_WORDS 
4270						DMARK "S2b" 
4270 f5				push af  
4271 3a 85 42			ld a, (.dmark)  
4274 32 bd fb			ld (debug_mark),a  
4277 3a 86 42			ld a, (.dmark+1)  
427a 32 be fb			ld (debug_mark+1),a  
427d 3a 87 42			ld a, (.dmark+2)  
4280 32 bf fb			ld (debug_mark+2),a  
4283 18 03			jr .pastdmark  
4285 ..			.dmark: db "S2b"  
4288 f1			.pastdmark: pop af  
4289			endm  
# End of macro DMARK
4289						CALLMONITOR 
4289 cd 20 17			call break_point_state  
428c				endm  
# End of macro CALLMONITOR
428c					endif 
428c			;		push hl 
428c					FORTH_DSP_POP 
428c cd 5f 1f			call macro_forth_dsp_pop 
428f				endm 
# End of macro FORTH_DSP_POP
428f			;		pop hl 
428f					 
428f					if DEBUG_FORTH_WORDS 
428f						DMARK "S2b" 
428f f5				push af  
4290 3a a4 42			ld a, (.dmark)  
4293 32 bd fb			ld (debug_mark),a  
4296 3a a5 42			ld a, (.dmark+1)  
4299 32 be fb			ld (debug_mark+1),a  
429c 3a a6 42			ld a, (.dmark+2)  
429f 32 bf fb			ld (debug_mark+2),a  
42a2 18 03			jr .pastdmark  
42a4 ..			.dmark: db "S2b"  
42a7 f1			.pastdmark: pop af  
42a8			endm  
# End of macro DMARK
42a8						CALLMONITOR 
42a8 cd 20 17			call break_point_state  
42ab				endm  
# End of macro CALLMONITOR
42ab					endif 
42ab cd b0 1c				call forth_push_numhl	 
42ae			 
42ae				 
42ae				       NEXTW 
42ae c3 19 20			jp macro_next 
42b1				endm 
# End of macro NEXTW
42b1			.NUM2STR: 
42b1				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
42b1 48				db WORD_SYS_CORE+52             
42b2 c0 42			dw .CONCAT            
42b4 08				db 7 + 1 
42b5 .. 00			db "NUM2STR",0              
42bd				endm 
# End of macro CWHEAD
42bd			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
42bd			 
42bd			;		; malloc a string to target 
42bd			;		ld hl, 10     ; TODO max string size should be fine 
42bd			;		call malloc 
42bd			;		push hl    ; save malloc location 
42bd			; 
42bd			; 
42bd			;; TODO check int type 
42bd			;		FORTH_DSP_VALUEHL 
42bd			;		ld a, l 
42bd			;		call DispAToASCII   
42bd			;;TODO need to chage above call to dump into string 
42bd			; 
42bd			; 
42bd			 
42bd				       NEXTW 
42bd c3 19 20			jp macro_next 
42c0				endm 
# End of macro NEXTW
42c0			 
42c0			.CONCAT: 
42c0				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
42c0 48				db WORD_SYS_CORE+52             
42c1 73 43			dw .FIND            
42c3 07				db 6 + 1 
42c4 .. 00			db "CONCAT",0              
42cb				endm 
# End of macro CWHEAD
42cb			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
42cb			 
42cb			; TODO check string type 
42cb			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
42cb			 
42cb					if DEBUG_FORTH_WORDS_KEY 
42cb						DMARK "CON" 
42cb f5				push af  
42cc 3a e0 42			ld a, (.dmark)  
42cf 32 bd fb			ld (debug_mark),a  
42d2 3a e1 42			ld a, (.dmark+1)  
42d5 32 be fb			ld (debug_mark+1),a  
42d8 3a e2 42			ld a, (.dmark+2)  
42db 32 bf fb			ld (debug_mark+2),a  
42de 18 03			jr .pastdmark  
42e0 ..			.dmark: db "CON"  
42e3 f1			.pastdmark: pop af  
42e4			endm  
# End of macro DMARK
42e4						CALLMONITOR 
42e4 cd 20 17			call break_point_state  
42e7				endm  
# End of macro CALLMONITOR
42e7					endif 
42e7			 
42e7			 
42e7					FORTH_DSP_VALUE 
42e7 cd 90 1e			call macro_forth_dsp_value 
42ea				endm 
# End of macro FORTH_DSP_VALUE
42ea e5					push hl   ; s2 
42eb			 
42eb					FORTH_DSP_POP 
42eb cd 5f 1f			call macro_forth_dsp_pop 
42ee				endm 
# End of macro FORTH_DSP_POP
42ee			 
42ee					FORTH_DSP_VALUE 
42ee cd 90 1e			call macro_forth_dsp_value 
42f1				endm 
# End of macro FORTH_DSP_VALUE
42f1			 
42f1 e5					push hl   ; s1 
42f2			 
42f2					FORTH_DSP_POP 
42f2 cd 5f 1f			call macro_forth_dsp_pop 
42f5				endm 
# End of macro FORTH_DSP_POP
42f5					 
42f5			 
42f5					; copy s1 
42f5			 
42f5				 
42f5					; save ptr 
42f5 e1					pop hl  
42f6 e5					push hl 
42f7 3e 00				ld a, 0 
42f9 cd 6f 11				call strlent 
42fc					;inc hl    ; zer0 
42fc 06 00				ld b, 0 
42fe 4d					ld c, l 
42ff e1					pop hl		 
4300 11 a3 ef				ld de, scratch	 
4303					if DEBUG_FORTH_WORDS 
4303						DMARK "CO1" 
4303 f5				push af  
4304 3a 18 43			ld a, (.dmark)  
4307 32 bd fb			ld (debug_mark),a  
430a 3a 19 43			ld a, (.dmark+1)  
430d 32 be fb			ld (debug_mark+1),a  
4310 3a 1a 43			ld a, (.dmark+2)  
4313 32 bf fb			ld (debug_mark+2),a  
4316 18 03			jr .pastdmark  
4318 ..			.dmark: db "CO1"  
431b f1			.pastdmark: pop af  
431c			endm  
# End of macro DMARK
431c						CALLMONITOR 
431c cd 20 17			call break_point_state  
431f				endm  
# End of macro CALLMONITOR
431f					endif 
431f ed b0				ldir 
4321			 
4321 e1					pop hl 
4322 e5					push hl 
4323 d5					push de 
4324			 
4324			 
4324 3e 00				ld a, 0 
4326 cd 6f 11				call strlent 
4329 23					inc hl    ; zer0 
432a 23					inc hl 
432b 06 00				ld b, 0 
432d 4d					ld c, l 
432e d1					pop de 
432f e1					pop hl		 
4330					if DEBUG_FORTH_WORDS 
4330						DMARK "CO2" 
4330 f5				push af  
4331 3a 45 43			ld a, (.dmark)  
4334 32 bd fb			ld (debug_mark),a  
4337 3a 46 43			ld a, (.dmark+1)  
433a 32 be fb			ld (debug_mark+1),a  
433d 3a 47 43			ld a, (.dmark+2)  
4340 32 bf fb			ld (debug_mark+2),a  
4343 18 03			jr .pastdmark  
4345 ..			.dmark: db "CO2"  
4348 f1			.pastdmark: pop af  
4349			endm  
# End of macro DMARK
4349						CALLMONITOR 
4349 cd 20 17			call break_point_state  
434c				endm  
# End of macro CALLMONITOR
434c					endif 
434c ed b0				ldir 
434e			 
434e			 
434e			 
434e 21 a3 ef				ld hl, scratch 
4351					if DEBUG_FORTH_WORDS 
4351						DMARK "CO5" 
4351 f5				push af  
4352 3a 66 43			ld a, (.dmark)  
4355 32 bd fb			ld (debug_mark),a  
4358 3a 67 43			ld a, (.dmark+1)  
435b 32 be fb			ld (debug_mark+1),a  
435e 3a 68 43			ld a, (.dmark+2)  
4361 32 bf fb			ld (debug_mark+2),a  
4364 18 03			jr .pastdmark  
4366 ..			.dmark: db "CO5"  
4369 f1			.pastdmark: pop af  
436a			endm  
# End of macro DMARK
436a						CALLMONITOR 
436a cd 20 17			call break_point_state  
436d				endm  
# End of macro CALLMONITOR
436d					endif 
436d			 
436d cd 1e 1d				call forth_push_str 
4370			 
4370			 
4370			 
4370			 
4370				       NEXTW 
4370 c3 19 20			jp macro_next 
4373				endm 
# End of macro NEXTW
4373			 
4373			 
4373			.FIND: 
4373				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4373 4b				db WORD_SYS_CORE+55             
4374 31 44			dw .LEN            
4376 05				db 4 + 1 
4377 .. 00			db "FIND",0              
437c				endm 
# End of macro CWHEAD
437c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
437c			 
437c					if DEBUG_FORTH_WORDS_KEY 
437c						DMARK "FND" 
437c f5				push af  
437d 3a 91 43			ld a, (.dmark)  
4380 32 bd fb			ld (debug_mark),a  
4383 3a 92 43			ld a, (.dmark+1)  
4386 32 be fb			ld (debug_mark+1),a  
4389 3a 93 43			ld a, (.dmark+2)  
438c 32 bf fb			ld (debug_mark+2),a  
438f 18 03			jr .pastdmark  
4391 ..			.dmark: db "FND"  
4394 f1			.pastdmark: pop af  
4395			endm  
# End of macro DMARK
4395						CALLMONITOR 
4395 cd 20 17			call break_point_state  
4398				endm  
# End of macro CALLMONITOR
4398					endif 
4398			 
4398			; TODO check string type 
4398					FORTH_DSP_VALUE 
4398 cd 90 1e			call macro_forth_dsp_value 
439b				endm 
# End of macro FORTH_DSP_VALUE
439b			 
439b e5					push hl    
439c 7e					ld a,(hl)    ; char to find   
439d			; TODO change char to substr 
439d			 
439d f5					push af 
439e					 
439e			 
439e			 
439e					if DEBUG_FORTH_WORDS 
439e						DMARK "FN1" 
439e f5				push af  
439f 3a b3 43			ld a, (.dmark)  
43a2 32 bd fb			ld (debug_mark),a  
43a5 3a b4 43			ld a, (.dmark+1)  
43a8 32 be fb			ld (debug_mark+1),a  
43ab 3a b5 43			ld a, (.dmark+2)  
43ae 32 bf fb			ld (debug_mark+2),a  
43b1 18 03			jr .pastdmark  
43b3 ..			.dmark: db "FN1"  
43b6 f1			.pastdmark: pop af  
43b7			endm  
# End of macro DMARK
43b7						CALLMONITOR 
43b7 cd 20 17			call break_point_state  
43ba				endm  
# End of macro CALLMONITOR
43ba					endif 
43ba			 
43ba					FORTH_DSP_POP 
43ba cd 5f 1f			call macro_forth_dsp_pop 
43bd				endm 
# End of macro FORTH_DSP_POP
43bd			 
43bd					; string to search 
43bd			 
43bd					FORTH_DSP_VALUE 
43bd cd 90 1e			call macro_forth_dsp_value 
43c0				endm 
# End of macro FORTH_DSP_VALUE
43c0			 
43c0 d1					pop de  ; d is char to find  
43c1			 
43c1					if DEBUG_FORTH_WORDS 
43c1						DMARK "FN2" 
43c1 f5				push af  
43c2 3a d6 43			ld a, (.dmark)  
43c5 32 bd fb			ld (debug_mark),a  
43c8 3a d7 43			ld a, (.dmark+1)  
43cb 32 be fb			ld (debug_mark+1),a  
43ce 3a d8 43			ld a, (.dmark+2)  
43d1 32 bf fb			ld (debug_mark+2),a  
43d4 18 03			jr .pastdmark  
43d6 ..			.dmark: db "FN2"  
43d9 f1			.pastdmark: pop af  
43da			endm  
# End of macro DMARK
43da						CALLMONITOR 
43da cd 20 17			call break_point_state  
43dd				endm  
# End of macro CALLMONITOR
43dd					endif 
43dd					 
43dd 01 00 00				ld bc, 0 
43e0 7e			.findchar:      ld a,(hl) 
43e1 fe 00				cp 0   		 
43e3 28 27				jr z, .finddone     
43e5 ba					cp d 
43e6 28 20				jr z, .foundchar 
43e8 03					inc bc 
43e9 23					inc hl 
43ea					if DEBUG_FORTH_WORDS 
43ea						DMARK "FN3" 
43ea f5				push af  
43eb 3a ff 43			ld a, (.dmark)  
43ee 32 bd fb			ld (debug_mark),a  
43f1 3a 00 44			ld a, (.dmark+1)  
43f4 32 be fb			ld (debug_mark+1),a  
43f7 3a 01 44			ld a, (.dmark+2)  
43fa 32 bf fb			ld (debug_mark+2),a  
43fd 18 03			jr .pastdmark  
43ff ..			.dmark: db "FN3"  
4402 f1			.pastdmark: pop af  
4403			endm  
# End of macro DMARK
4403						CALLMONITOR 
4403 cd 20 17			call break_point_state  
4406				endm  
# End of macro CALLMONITOR
4406					endif 
4406 18 d8				jr .findchar 
4408			 
4408			 
4408 c5			.foundchar:	push bc 
4409 e1					pop hl 
440a 18 03				jr .findexit 
440c			 
440c			 
440c							 
440c			 
440c			.finddone:     ; got to end of string with no find 
440c 21 00 00				ld hl, 0 
440f			.findexit: 
440f			 
440f					if DEBUG_FORTH_WORDS 
440f						DMARK "FNd" 
440f f5				push af  
4410 3a 24 44			ld a, (.dmark)  
4413 32 bd fb			ld (debug_mark),a  
4416 3a 25 44			ld a, (.dmark+1)  
4419 32 be fb			ld (debug_mark+1),a  
441c 3a 26 44			ld a, (.dmark+2)  
441f 32 bf fb			ld (debug_mark+2),a  
4422 18 03			jr .pastdmark  
4424 ..			.dmark: db "FNd"  
4427 f1			.pastdmark: pop af  
4428			endm  
# End of macro DMARK
4428						CALLMONITOR 
4428 cd 20 17			call break_point_state  
442b				endm  
# End of macro CALLMONITOR
442b					endif 
442b cd b0 1c			call forth_push_numhl 
442e			 
442e				       NEXTW 
442e c3 19 20			jp macro_next 
4431				endm 
# End of macro NEXTW
4431			 
4431			.LEN: 
4431				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4431 4c				db WORD_SYS_CORE+56             
4432 66 44			dw .CHAR            
4434 06				db 5 + 1 
4435 .. 00			db "COUNT",0              
443b				endm 
# End of macro CWHEAD
443b			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
443b			 
443b					if DEBUG_FORTH_WORDS_KEY 
443b						DMARK "CNT" 
443b f5				push af  
443c 3a 50 44			ld a, (.dmark)  
443f 32 bd fb			ld (debug_mark),a  
4442 3a 51 44			ld a, (.dmark+1)  
4445 32 be fb			ld (debug_mark+1),a  
4448 3a 52 44			ld a, (.dmark+2)  
444b 32 bf fb			ld (debug_mark+2),a  
444e 18 03			jr .pastdmark  
4450 ..			.dmark: db "CNT"  
4453 f1			.pastdmark: pop af  
4454			endm  
# End of macro DMARK
4454						CALLMONITOR 
4454 cd 20 17			call break_point_state  
4457				endm  
# End of macro CALLMONITOR
4457					endif 
4457			; TODO check string type 
4457					FORTH_DSP 
4457 cd 6d 1e			call macro_forth_dsp 
445a				endm 
# End of macro FORTH_DSP
445a					;v5FORTH_DSP_VALUE 
445a			 
445a 23					inc hl 
445b			 
445b 3e 00				ld a, 0 
445d cd 6f 11				call strlent 
4460			 
4460 cd b0 1c				call forth_push_numhl 
4463			 
4463			 
4463			 
4463				       NEXTW 
4463 c3 19 20			jp macro_next 
4466				endm 
# End of macro NEXTW
4466			.CHAR: 
4466				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4466 4d				db WORD_SYS_CORE+57             
4467 9c 44			dw .ENDSTR            
4469 05				db 4 + 1 
446a .. 00			db "CHAR",0              
446f				endm 
# End of macro CWHEAD
446f			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
446f					if DEBUG_FORTH_WORDS_KEY 
446f						DMARK "CHR" 
446f f5				push af  
4470 3a 84 44			ld a, (.dmark)  
4473 32 bd fb			ld (debug_mark),a  
4476 3a 85 44			ld a, (.dmark+1)  
4479 32 be fb			ld (debug_mark+1),a  
447c 3a 86 44			ld a, (.dmark+2)  
447f 32 bf fb			ld (debug_mark+2),a  
4482 18 03			jr .pastdmark  
4484 ..			.dmark: db "CHR"  
4487 f1			.pastdmark: pop af  
4488			endm  
# End of macro DMARK
4488						CALLMONITOR 
4488 cd 20 17			call break_point_state  
448b				endm  
# End of macro CALLMONITOR
448b					endif 
448b					FORTH_DSP 
448b cd 6d 1e			call macro_forth_dsp 
448e				endm 
# End of macro FORTH_DSP
448e					;v5 FORTH_DSP_VALUE 
448e 23					inc hl      ; now at start of numeric as string 
448f			 
448f			;		push hl 
448f			 
448f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
448f cd 5f 1f			call macro_forth_dsp_pop 
4492				endm 
# End of macro FORTH_DSP_POP
4492			 
4492			;		pop hl 
4492			 
4492					; push the content of a onto the stack as a value 
4492			 
4492 7e					ld a,(hl)   ; get char 
4493 26 00				ld h,0 
4495 6f					ld l,a 
4496 cd b0 1c				call forth_push_numhl 
4499			 
4499				       NEXTW 
4499 c3 19 20			jp macro_next 
449c				endm 
# End of macro NEXTW
449c			 
449c			 
449c			 
449c			 
449c			.ENDSTR: 
449c			; eof 
449c			 
# End of file forth_words_str.asm
449c			include "forth_words_key.asm" 
449c			 
449c			; | ## Keyboard Words 
449c			 
449c			.KEY: 
449c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
449c 3e				db WORD_SYS_CORE+42             
449d cc 44			dw .WAITK            
449f 04				db 3 + 1 
44a0 .. 00			db "KEY",0              
44a4				endm 
# End of macro CWHEAD
44a4			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44a4			 
44a4					if DEBUG_FORTH_WORDS_KEY 
44a4						DMARK "KEY" 
44a4 f5				push af  
44a5 3a b9 44			ld a, (.dmark)  
44a8 32 bd fb			ld (debug_mark),a  
44ab 3a ba 44			ld a, (.dmark+1)  
44ae 32 be fb			ld (debug_mark+1),a  
44b1 3a bb 44			ld a, (.dmark+2)  
44b4 32 bf fb			ld (debug_mark+2),a  
44b7 18 03			jr .pastdmark  
44b9 ..			.dmark: db "KEY"  
44bc f1			.pastdmark: pop af  
44bd			endm  
# End of macro DMARK
44bd						CALLMONITOR 
44bd cd 20 17			call break_point_state  
44c0				endm  
# End of macro CALLMONITOR
44c0					endif 
44c0			; TODO currently waits 
44c0 cd ce 66				call cin 
44c3					;call cin_wait 
44c3 6f					ld l, a 
44c4 26 00				ld h, 0 
44c6 cd b0 1c				call forth_push_numhl 
44c9					NEXTW 
44c9 c3 19 20			jp macro_next 
44cc				endm 
# End of macro NEXTW
44cc			.WAITK: 
44cc				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
44cc 3f				db WORD_SYS_CORE+43             
44cd fe 44			dw .ACCEPT            
44cf 06				db 5 + 1 
44d0 .. 00			db "WAITK",0              
44d6				endm 
# End of macro CWHEAD
44d6			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
44d6					if DEBUG_FORTH_WORDS_KEY 
44d6						DMARK "WAI" 
44d6 f5				push af  
44d7 3a eb 44			ld a, (.dmark)  
44da 32 bd fb			ld (debug_mark),a  
44dd 3a ec 44			ld a, (.dmark+1)  
44e0 32 be fb			ld (debug_mark+1),a  
44e3 3a ed 44			ld a, (.dmark+2)  
44e6 32 bf fb			ld (debug_mark+2),a  
44e9 18 03			jr .pastdmark  
44eb ..			.dmark: db "WAI"  
44ee f1			.pastdmark: pop af  
44ef			endm  
# End of macro DMARK
44ef						CALLMONITOR 
44ef cd 20 17			call break_point_state  
44f2				endm  
# End of macro CALLMONITOR
44f2					endif 
44f2 cd bd 66				call cin_wait 
44f5 6f					ld l, a 
44f6 26 00				ld h, 0 
44f8 cd b0 1c				call forth_push_numhl 
44fb					NEXTW 
44fb c3 19 20			jp macro_next 
44fe				endm 
# End of macro NEXTW
44fe			.ACCEPT: 
44fe				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
44fe 40				db WORD_SYS_CORE+44             
44ff 5c 45			dw .EDIT            
4501 07				db 6 + 1 
4502 .. 00			db "ACCEPT",0              
4509				endm 
# End of macro CWHEAD
4509			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4509					; TODO crashes on push 
4509					if DEBUG_FORTH_WORDS_KEY 
4509						DMARK "ACC" 
4509 f5				push af  
450a 3a 1e 45			ld a, (.dmark)  
450d 32 bd fb			ld (debug_mark),a  
4510 3a 1f 45			ld a, (.dmark+1)  
4513 32 be fb			ld (debug_mark+1),a  
4516 3a 20 45			ld a, (.dmark+2)  
4519 32 bf fb			ld (debug_mark+2),a  
451c 18 03			jr .pastdmark  
451e ..			.dmark: db "ACC"  
4521 f1			.pastdmark: pop af  
4522			endm  
# End of macro DMARK
4522						CALLMONITOR 
4522 cd 20 17			call break_point_state  
4525				endm  
# End of macro CALLMONITOR
4525					endif 
4525 21 a1 f1				ld hl, os_input 
4528 3e 00				ld a, 0 
452a 77					ld (hl),a 
452b 3a cc f9				ld a,(f_cursor_ptr) 
452e 16 64				ld d, 100 
4530 0e 00				ld c, 0 
4532 1e 28				ld e, 40 
4534 cd 33 0d				call input_str 
4537					; TODO perhaps do a type check and wrap in quotes if not a number 
4537 21 a1 f1				ld hl, os_input 
453a					if DEBUG_FORTH_WORDS 
453a						DMARK "AC1" 
453a f5				push af  
453b 3a 4f 45			ld a, (.dmark)  
453e 32 bd fb			ld (debug_mark),a  
4541 3a 50 45			ld a, (.dmark+1)  
4544 32 be fb			ld (debug_mark+1),a  
4547 3a 51 45			ld a, (.dmark+2)  
454a 32 bf fb			ld (debug_mark+2),a  
454d 18 03			jr .pastdmark  
454f ..			.dmark: db "AC1"  
4552 f1			.pastdmark: pop af  
4553			endm  
# End of macro DMARK
4553						CALLMONITOR 
4553 cd 20 17			call break_point_state  
4556				endm  
# End of macro CALLMONITOR
4556					endif 
4556 cd 1e 1d				call forth_push_str 
4559					NEXTW 
4559 c3 19 20			jp macro_next 
455c				endm 
# End of macro NEXTW
455c			 
455c			.EDIT: 
455c				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
455c 40				db WORD_SYS_CORE+44             
455d e5 45			dw .ENDKEY            
455f 05				db 4 + 1 
4560 .. 00			db "EDIT",0              
4565				endm 
# End of macro CWHEAD
4565			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4565			 
4565					; TODO does not copy from stack 
4565					if DEBUG_FORTH_WORDS_KEY 
4565						DMARK "EDT" 
4565 f5				push af  
4566 3a 7a 45			ld a, (.dmark)  
4569 32 bd fb			ld (debug_mark),a  
456c 3a 7b 45			ld a, (.dmark+1)  
456f 32 be fb			ld (debug_mark+1),a  
4572 3a 7c 45			ld a, (.dmark+2)  
4575 32 bf fb			ld (debug_mark+2),a  
4578 18 03			jr .pastdmark  
457a ..			.dmark: db "EDT"  
457d f1			.pastdmark: pop af  
457e			endm  
# End of macro DMARK
457e						CALLMONITOR 
457e cd 20 17			call break_point_state  
4581				endm  
# End of macro CALLMONITOR
4581					endif 
4581			 
4581					FORTH_DSP 
4581 cd 6d 1e			call macro_forth_dsp 
4584				endm 
# End of macro FORTH_DSP
4584					;v5 FORTH_DSP_VALUE 
4584 23					inc hl    ; TODO do type check 
4585			 
4585 e5					push hl 
4586 3e 00				ld a, 0 
4588 cd 6f 11				call strlent 
458b 23					inc hl 
458c			 
458c 06 00				ld b, 0 
458e 4d					ld c, l 
458f			 
458f e1					pop hl 
4590 11 a1 f1				ld de, os_input 
4593					if DEBUG_FORTH_WORDS_KEY 
4593						DMARK "EDc" 
4593 f5				push af  
4594 3a a8 45			ld a, (.dmark)  
4597 32 bd fb			ld (debug_mark),a  
459a 3a a9 45			ld a, (.dmark+1)  
459d 32 be fb			ld (debug_mark+1),a  
45a0 3a aa 45			ld a, (.dmark+2)  
45a3 32 bf fb			ld (debug_mark+2),a  
45a6 18 03			jr .pastdmark  
45a8 ..			.dmark: db "EDc"  
45ab f1			.pastdmark: pop af  
45ac			endm  
# End of macro DMARK
45ac						CALLMONITOR 
45ac cd 20 17			call break_point_state  
45af				endm  
# End of macro CALLMONITOR
45af					endif 
45af ed b0				ldir 
45b1			 
45b1			 
45b1 21 a1 f1				ld hl, os_input 
45b4					;ld a, 0 
45b4					;ld (hl),a 
45b4 3a cc f9				ld a,(f_cursor_ptr) 
45b7 16 64				ld d, 100 
45b9 0e 00				ld c, 0 
45bb 1e 28				ld e, 40 
45bd cd 33 0d				call input_str 
45c0					; TODO perhaps do a type check and wrap in quotes if not a number 
45c0 21 a1 f1				ld hl, os_input 
45c3					if DEBUG_FORTH_WORDS 
45c3						DMARK "ED1" 
45c3 f5				push af  
45c4 3a d8 45			ld a, (.dmark)  
45c7 32 bd fb			ld (debug_mark),a  
45ca 3a d9 45			ld a, (.dmark+1)  
45cd 32 be fb			ld (debug_mark+1),a  
45d0 3a da 45			ld a, (.dmark+2)  
45d3 32 bf fb			ld (debug_mark+2),a  
45d6 18 03			jr .pastdmark  
45d8 ..			.dmark: db "ED1"  
45db f1			.pastdmark: pop af  
45dc			endm  
# End of macro DMARK
45dc						CALLMONITOR 
45dc cd 20 17			call break_point_state  
45df				endm  
# End of macro CALLMONITOR
45df					endif 
45df cd 1e 1d				call forth_push_str 
45e2					NEXTW 
45e2 c3 19 20			jp macro_next 
45e5				endm 
# End of macro NEXTW
45e5			 
45e5			 
45e5			 
45e5			.ENDKEY: 
45e5			; eof 
45e5			 
# End of file forth_words_key.asm
45e5			 
45e5			if STORAGE_SE 
45e5			   	include "forth_words_storage.asm" 
45e5			 
45e5			; | ## Fixed Storage Words 
45e5			 
45e5			 
45e5			.BREAD: 
45e5			  
45e5				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
45e5 3a				db WORD_SYS_CORE+38             
45e6 5e 46			dw .BWRITE            
45e8 06				db 5 + 1 
45e9 .. 00			db "BREAD",0              
45ef				endm 
# End of macro CWHEAD
45ef			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
45ef				 
45ef					if DEBUG_FORTH_WORDS_KEY 
45ef						DMARK "BRD" 
45ef f5				push af  
45f0 3a 04 46			ld a, (.dmark)  
45f3 32 bd fb			ld (debug_mark),a  
45f6 3a 05 46			ld a, (.dmark+1)  
45f9 32 be fb			ld (debug_mark+1),a  
45fc 3a 06 46			ld a, (.dmark+2)  
45ff 32 bf fb			ld (debug_mark+2),a  
4602 18 03			jr .pastdmark  
4604 ..			.dmark: db "BRD"  
4607 f1			.pastdmark: pop af  
4608			endm  
# End of macro DMARK
4608						CALLMONITOR 
4608 cd 20 17			call break_point_state  
460b				endm  
# End of macro CALLMONITOR
460b					endif 
460b			 
460b				FORTH_DSP_VALUEHL 
460b cd a7 1e			call macro_dsp_valuehl 
460e				endm 
# End of macro FORTH_DSP_VALUEHL
460e			 
460e				FORTH_DSP_POP 
460e cd 5f 1f			call macro_forth_dsp_pop 
4611				endm 
# End of macro FORTH_DSP_POP
4611			 
4611				; calc block address 
4611			 
4611 eb				ex de, hl 
4612 3e 40			ld a, STORE_BLOCK_PHY 
4614 cd 89 0c			call Mult16 
4617			 
4617			 
4617 11 e8 f9			ld de, store_page 
461a			 
461a					if DEBUG_FORTH_WORDS 
461a						DMARK "BR1" 
461a f5				push af  
461b 3a 2f 46			ld a, (.dmark)  
461e 32 bd fb			ld (debug_mark),a  
4621 3a 30 46			ld a, (.dmark+1)  
4624 32 be fb			ld (debug_mark+1),a  
4627 3a 31 46			ld a, (.dmark+2)  
462a 32 bf fb			ld (debug_mark+2),a  
462d 18 03			jr .pastdmark  
462f ..			.dmark: db "BR1"  
4632 f1			.pastdmark: pop af  
4633			endm  
# End of macro DMARK
4633						CALLMONITOR 
4633 cd 20 17			call break_point_state  
4636				endm  
# End of macro CALLMONITOR
4636					endif 
4636			 
4636 cd 09 03			call storage_read_block 
4639			 
4639 21 ea f9		        ld hl, store_page+2 
463c					if DEBUG_FORTH_WORDS 
463c						DMARK "BR2" 
463c f5				push af  
463d 3a 51 46			ld a, (.dmark)  
4640 32 bd fb			ld (debug_mark),a  
4643 3a 52 46			ld a, (.dmark+1)  
4646 32 be fb			ld (debug_mark+1),a  
4649 3a 53 46			ld a, (.dmark+2)  
464c 32 bf fb			ld (debug_mark+2),a  
464f 18 03			jr .pastdmark  
4651 ..			.dmark: db "BR2"  
4654 f1			.pastdmark: pop af  
4655			endm  
# End of macro DMARK
4655						CALLMONITOR 
4655 cd 20 17			call break_point_state  
4658				endm  
# End of macro CALLMONITOR
4658					endif 
4658 cd 1e 1d			call forth_push_str 
465b			 
465b			 
465b					NEXTW 
465b c3 19 20			jp macro_next 
465e				endm 
# End of macro NEXTW
465e			.BWRITE: 
465e				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
465e 3a				db WORD_SYS_CORE+38             
465f f3 46			dw .BUPD            
4661 07				db 6 + 1 
4662 .. 00			db "BWRITE",0              
4669				endm 
# End of macro CWHEAD
4669			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4669			 
4669					if DEBUG_FORTH_WORDS_KEY 
4669						DMARK "BWR" 
4669 f5				push af  
466a 3a 7e 46			ld a, (.dmark)  
466d 32 bd fb			ld (debug_mark),a  
4670 3a 7f 46			ld a, (.dmark+1)  
4673 32 be fb			ld (debug_mark+1),a  
4676 3a 80 46			ld a, (.dmark+2)  
4679 32 bf fb			ld (debug_mark+2),a  
467c 18 03			jr .pastdmark  
467e ..			.dmark: db "BWR"  
4681 f1			.pastdmark: pop af  
4682			endm  
# End of macro DMARK
4682						CALLMONITOR 
4682 cd 20 17			call break_point_state  
4685				endm  
# End of macro CALLMONITOR
4685					endif 
4685			 
4685				FORTH_DSP_VALUEHL 
4685 cd a7 1e			call macro_dsp_valuehl 
4688				endm 
# End of macro FORTH_DSP_VALUEHL
4688			 
4688				; calc block address 
4688			 
4688 eb				ex de, hl 
4689 3e 40			ld a, STORE_BLOCK_PHY 
468b cd 89 0c			call Mult16 
468e			 
468e e5				push hl         ; address 
468f			 
468f				FORTH_DSP_POP 
468f cd 5f 1f			call macro_forth_dsp_pop 
4692				endm 
# End of macro FORTH_DSP_POP
4692			 
4692				FORTH_DSP_VALUEHL 
4692 cd a7 1e			call macro_dsp_valuehl 
4695				endm 
# End of macro FORTH_DSP_VALUEHL
4695			 
4695				FORTH_DSP_POP 
4695 cd 5f 1f			call macro_forth_dsp_pop 
4698				endm 
# End of macro FORTH_DSP_POP
4698			 
4698 cd 15 0a			call storage_clear_page 
469b			 
469b				; copy string to store page 
469b			 
469b e5				push hl     ; save string address 
469c			 
469c 3e 00			ld a, 0 
469e cd 6f 11			call strlent 
46a1			 
46a1 23				inc hl 
46a2			 
46a2 4d				ld c, l 
46a3 06 00			ld b, 0 
46a5			 
46a5 e1				pop hl 
46a6 11 ea f9			ld de, store_page + 2 
46a9					if DEBUG_FORTH_WORDS 
46a9						DMARK "BW1" 
46a9 f5				push af  
46aa 3a be 46			ld a, (.dmark)  
46ad 32 bd fb			ld (debug_mark),a  
46b0 3a bf 46			ld a, (.dmark+1)  
46b3 32 be fb			ld (debug_mark+1),a  
46b6 3a c0 46			ld a, (.dmark+2)  
46b9 32 bf fb			ld (debug_mark+2),a  
46bc 18 03			jr .pastdmark  
46be ..			.dmark: db "BW1"  
46c1 f1			.pastdmark: pop af  
46c2			endm  
# End of macro DMARK
46c2						CALLMONITOR 
46c2 cd 20 17			call break_point_state  
46c5				endm  
# End of macro CALLMONITOR
46c5					endif 
46c5 ed b0			ldir 
46c7			 
46c7			 
46c7				; poke the start of the block with flags to prevent high level file ops hitting the block 
46c7			 
46c7 21 ff ff			ld hl, $ffff 
46ca			 
46ca 22 e8 f9			ld (store_page), hl	 
46cd				 
46cd e1				pop hl    ; get address 
46ce 11 e8 f9			ld de, store_page 
46d1			 
46d1					if DEBUG_FORTH_WORDS 
46d1						DMARK "BW2" 
46d1 f5				push af  
46d2 3a e6 46			ld a, (.dmark)  
46d5 32 bd fb			ld (debug_mark),a  
46d8 3a e7 46			ld a, (.dmark+1)  
46db 32 be fb			ld (debug_mark+1),a  
46de 3a e8 46			ld a, (.dmark+2)  
46e1 32 bf fb			ld (debug_mark+2),a  
46e4 18 03			jr .pastdmark  
46e6 ..			.dmark: db "BW2"  
46e9 f1			.pastdmark: pop af  
46ea			endm  
# End of macro DMARK
46ea						CALLMONITOR 
46ea cd 20 17			call break_point_state  
46ed				endm  
# End of macro CALLMONITOR
46ed					endif 
46ed			 
46ed cd 6e 03			call storage_write_block 
46f0			 
46f0					NEXTW 
46f0 c3 19 20			jp macro_next 
46f3				endm 
# End of macro NEXTW
46f3			 
46f3			.BUPD: 
46f3				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
46f3 3a				db WORD_SYS_CORE+38             
46f4 49 47			dw .BYID            
46f6 05				db 4 + 1 
46f7 .. 00			db "BUPD",0              
46fc				endm 
# End of macro CWHEAD
46fc			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
46fc			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
46fc			; | | or completely different file system structure. 
46fc			 
46fc					if DEBUG_FORTH_WORDS_KEY 
46fc						DMARK "BUD" 
46fc f5				push af  
46fd 3a 11 47			ld a, (.dmark)  
4700 32 bd fb			ld (debug_mark),a  
4703 3a 12 47			ld a, (.dmark+1)  
4706 32 be fb			ld (debug_mark+1),a  
4709 3a 13 47			ld a, (.dmark+2)  
470c 32 bf fb			ld (debug_mark+2),a  
470f 18 03			jr .pastdmark  
4711 ..			.dmark: db "BUD"  
4714 f1			.pastdmark: pop af  
4715			endm  
# End of macro DMARK
4715						CALLMONITOR 
4715 cd 20 17			call break_point_state  
4718				endm  
# End of macro CALLMONITOR
4718					endif 
4718			 
4718				FORTH_DSP_VALUEHL 
4718 cd a7 1e			call macro_dsp_valuehl 
471b				endm 
# End of macro FORTH_DSP_VALUEHL
471b			 
471b				; calc block address 
471b			 
471b eb				ex de, hl 
471c 3e 40			ld a, STORE_BLOCK_PHY 
471e cd 89 0c			call Mult16 
4721			 
4721				FORTH_DSP_POP 
4721 cd 5f 1f			call macro_forth_dsp_pop 
4724				endm 
# End of macro FORTH_DSP_POP
4724			 
4724			 
4724 11 e8 f9			ld de, store_page 
4727			 
4727					if DEBUG_FORTH_WORDS 
4727						DMARK "BUe" 
4727 f5				push af  
4728 3a 3c 47			ld a, (.dmark)  
472b 32 bd fb			ld (debug_mark),a  
472e 3a 3d 47			ld a, (.dmark+1)  
4731 32 be fb			ld (debug_mark+1),a  
4734 3a 3e 47			ld a, (.dmark+2)  
4737 32 bf fb			ld (debug_mark+2),a  
473a 18 03			jr .pastdmark  
473c ..			.dmark: db "BUe"  
473f f1			.pastdmark: pop af  
4740			endm  
# End of macro DMARK
4740						CALLMONITOR 
4740 cd 20 17			call break_point_state  
4743				endm  
# End of macro CALLMONITOR
4743					endif 
4743			 
4743 cd 6e 03			call storage_write_block 
4746			 
4746					NEXTW 
4746 c3 19 20			jp macro_next 
4749				endm 
# End of macro NEXTW
4749			 
4749			.BYID: 
4749			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4749			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4749			; 
4749			;		 
4749			;		if DEBUG_FORTH_WORDS_KEY 
4749			;			DMARK "BYID" 
4749			;			CALLMONITOR 
4749			;		endif 
4749			; 
4749			;		; get direct address 
4749			; 
4749			;		FORTH_DSP_VALUEHL 
4749			; 
4749			;		FORTH_DSP_POP 
4749			; 
4749			;	; calc block address 
4749			; 
4749			;	ex de, hl 
4749			;	ld a, STORE_BLOCK_PHY 
4749			;	call Mult16 
4749			;	;	do BREAD with number as param 
4749			;	; push the file name	 
4749			;	ld de, store_page 
4749			;	call storage_read_block 
4749			 ;       ld hl, store_page+2 
4749			; 
4749			; 
4749			;		NEXTW 
4749			;.BYNAME: 
4749			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4749			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4749			;		NEXTW 
4749			; 
4749			.DIR: 
4749				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4749 3a				db WORD_SYS_CORE+38             
474a 4d 48			dw .SAVE            
474c 04				db 3 + 1 
474d .. 00			db "DIR",0              
4751				endm 
# End of macro CWHEAD
4751			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4751			 
4751					if DEBUG_FORTH_WORDS_KEY 
4751						DMARK "DIR" 
4751 f5				push af  
4752 3a 66 47			ld a, (.dmark)  
4755 32 bd fb			ld (debug_mark),a  
4758 3a 67 47			ld a, (.dmark+1)  
475b 32 be fb			ld (debug_mark+1),a  
475e 3a 68 47			ld a, (.dmark+2)  
4761 32 bf fb			ld (debug_mark+2),a  
4764 18 03			jr .pastdmark  
4766 ..			.dmark: db "DIR"  
4769 f1			.pastdmark: pop af  
476a			endm  
# End of macro DMARK
476a						CALLMONITOR 
476a cd 20 17			call break_point_state  
476d				endm  
# End of macro CALLMONITOR
476d					endif 
476d cd ba 03			call storage_get_block_0 
4770			 
4770 21 e8 f9			ld hl, store_page     ; get current id count 
4773 46				ld b, (hl) 
4774 0e 00			ld c, 0    ; count of files   
4776					if DEBUG_FORTH_WORDS 
4776						DMARK "DI1" 
4776 f5				push af  
4777 3a 8b 47			ld a, (.dmark)  
477a 32 bd fb			ld (debug_mark),a  
477d 3a 8c 47			ld a, (.dmark+1)  
4780 32 be fb			ld (debug_mark+1),a  
4783 3a 8d 47			ld a, (.dmark+2)  
4786 32 bf fb			ld (debug_mark+2),a  
4789 18 03			jr .pastdmark  
478b ..			.dmark: db "DI1"  
478e f1			.pastdmark: pop af  
478f			endm  
# End of macro DMARK
478f						CALLMONITOR 
478f cd 20 17			call break_point_state  
4792				endm  
# End of macro CALLMONITOR
4792					endif 
4792			 
4792				; check for empty drive 
4792			 
4792 3e 00			ld a, 0 
4794 b8				cp b 
4795 ca 03 48			jp z, .dirdone 
4798			 
4798				; for each of the current ids do a search for them and if found push to stack 
4798			 
4798 c5			.diritem:	push bc 
4799 21 40 00				ld hl, STORE_BLOCK_PHY 
479c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
479e 58					ld e,b 
479f			 
479f			;		if DEBUG_FORTH_WORDS 
479f			;			DMARK "DI2" 
479f			;			CALLMONITOR 
479f			;		endif 
479f			 
479f cd 2a 06				call storage_findnextid 
47a2			 
47a2			;		if DEBUG_FORTH_WORDS 
47a2			;			DMARK "DI3" 
47a2			;			CALLMONITOR 
47a2			;		endif 
47a2			 
47a2					; if found hl will be non zero 
47a2			 
47a2 cd 2f 0d				call ishlzero 
47a5			;		ld a, l 
47a5			;		add h 
47a5			; 
47a5			;		cp 0 
47a5 28 59				jr z, .dirnotfound 
47a7			 
47a7					; increase count 
47a7			 
47a7 c1					pop bc	 
47a8 0c					inc c 
47a9 c5					push bc 
47aa					 
47aa			 
47aa					; get file header and push the file name 
47aa			 
47aa 11 e8 f9				ld de, store_page 
47ad cd 09 03				call storage_read_block 
47b0			 
47b0					; push file id to stack 
47b0				 
47b0 3a e8 f9				ld a, (store_page) 
47b3 26 00				ld h, 0 
47b5 6f					ld l, a 
47b6 cd b0 1c				call forth_push_numhl 
47b9			 
47b9					; push extent count to stack  
47b9				 
47b9 3a ea f9				ld a, (store_page+2) 
47bc 26 00				ld h, 0 
47be 6f					ld l, a 
47bf cd b0 1c				call forth_push_numhl 
47c2			 
47c2					; push file name 
47c2			 
47c2 21 eb f9				ld hl, store_page+3 
47c5					if DEBUG_FORTH_WORDS 
47c5						DMARK "DI5" 
47c5 f5				push af  
47c6 3a da 47			ld a, (.dmark)  
47c9 32 bd fb			ld (debug_mark),a  
47cc 3a db 47			ld a, (.dmark+1)  
47cf 32 be fb			ld (debug_mark+1),a  
47d2 3a dc 47			ld a, (.dmark+2)  
47d5 32 bf fb			ld (debug_mark+2),a  
47d8 18 03			jr .pastdmark  
47da ..			.dmark: db "DI5"  
47dd f1			.pastdmark: pop af  
47de			endm  
# End of macro DMARK
47de						CALLMONITOR 
47de cd 20 17			call break_point_state  
47e1				endm  
# End of macro CALLMONITOR
47e1					endif 
47e1 cd 1e 1d				call forth_push_str 
47e4					if DEBUG_FORTH_WORDS 
47e4						DMARK "DI6" 
47e4 f5				push af  
47e5 3a f9 47			ld a, (.dmark)  
47e8 32 bd fb			ld (debug_mark),a  
47eb 3a fa 47			ld a, (.dmark+1)  
47ee 32 be fb			ld (debug_mark+1),a  
47f1 3a fb 47			ld a, (.dmark+2)  
47f4 32 bf fb			ld (debug_mark+2),a  
47f7 18 03			jr .pastdmark  
47f9 ..			.dmark: db "DI6"  
47fc f1			.pastdmark: pop af  
47fd			endm  
# End of macro DMARK
47fd						CALLMONITOR 
47fd cd 20 17			call break_point_state  
4800				endm  
# End of macro CALLMONITOR
4800					endif 
4800			.dirnotfound: 
4800 c1					pop bc     
4801 10 95				djnz .diritem 
4803				 
4803			.dirdone:	 
4803					if DEBUG_FORTH_WORDS 
4803						DMARK "DI7" 
4803 f5				push af  
4804 3a 18 48			ld a, (.dmark)  
4807 32 bd fb			ld (debug_mark),a  
480a 3a 19 48			ld a, (.dmark+1)  
480d 32 be fb			ld (debug_mark+1),a  
4810 3a 1a 48			ld a, (.dmark+2)  
4813 32 bf fb			ld (debug_mark+2),a  
4816 18 03			jr .pastdmark  
4818 ..			.dmark: db "DI7"  
481b f1			.pastdmark: pop af  
481c			endm  
# End of macro DMARK
481c						CALLMONITOR 
481c cd 20 17			call break_point_state  
481f				endm  
# End of macro CALLMONITOR
481f					endif 
481f			 
481f					; push a count of the dir items found 
481f			 
481f 26 00				ld h, 0 
4821 69					ld l, c 
4822 cd b0 1c				call forth_push_numhl 
4825			 
4825					; push the bank label 
4825			 
4825 cd ba 03				call storage_get_block_0 
4828			 
4828				 
4828 21 eb f9		 		ld hl, store_page+3 
482b			 
482b					if DEBUG_FORTH_WORDS 
482b						DMARK "DI8" 
482b f5				push af  
482c 3a 40 48			ld a, (.dmark)  
482f 32 bd fb			ld (debug_mark),a  
4832 3a 41 48			ld a, (.dmark+1)  
4835 32 be fb			ld (debug_mark+1),a  
4838 3a 42 48			ld a, (.dmark+2)  
483b 32 bf fb			ld (debug_mark+2),a  
483e 18 03			jr .pastdmark  
4840 ..			.dmark: db "DI8"  
4843 f1			.pastdmark: pop af  
4844			endm  
# End of macro DMARK
4844						CALLMONITOR 
4844 cd 20 17			call break_point_state  
4847				endm  
# End of macro CALLMONITOR
4847					endif 
4847 cd 1e 1d				call forth_push_str 
484a			 
484a			 
484a				 
484a					NEXTW 
484a c3 19 20			jp macro_next 
484d				endm 
# End of macro NEXTW
484d			.SAVE: 
484d			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
484d			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
484d			;		NEXTW 
484d			;.LOAD: 
484d			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
484d			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
484d			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
484d			;; > > The LOAD command can not be used in any user words or compound lines. 
484d			; 
484d			;		; store_openext use it. If zero it is EOF 
484d			; 
484d			;		; read block from current stream id 
484d			;		; if the block does not contain zero term keep reading blocks until zero found 
484d			;		; push the block to stack 
484d			;		; save the block id to stream 
484d			; 
484d			; 
484d			;		FORTH_DSP_VALUEHL 
484d			; 
484d			;;		push hl 
484d			; 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LOA" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;		FORTH_DSP_POP 
484d			; 
484d			;;		pop hl 
484d			; 
484d			;		ld h, l 
484d			;		ld l, 0 
484d			; 
484d			;		push hl     ; stack holds current file id and extent to work with 
484d			; 
484d			; 
484d			;		ld de, store_page      ; get block zero of file 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LO0" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;		call storage_read 
484d			; 
484d			;		ld a, (store_page+2)    ; max extents for this file 
484d			;		ld  (store_openmaxext),a   ; get our limit 
484d			; 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LOE" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			; 
484d			;; TODO dont know why max extents are not present 
484d			;;		cp 0 
484d			;;		jp z, .loadeof     ; dont read past eof 
484d			; 
484d			;;		ld a, 1   ; start from the head of the file 
484d			; 
484d			;.loadline:	pop hl 
484d			;		inc hl 
484d			;		ld  a, (store_openmaxext)   ; get our limit 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LOx" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;		inc a 
484d			;		cp l 
484d			;		jp z, .loadeof 
484d			;		push hl    ; save current extent 
484d			; 
484d			;		ld de, store_page 
484d			; 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LO1" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;		call storage_read 
484d			; 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LO2" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;	call ishlzero 
484d			;	ld a, l 
484d			;	add h 
484d			;	cp 0 
484d			;	jr z, .loadeof 
484d			; 
484d			;	; not eof so hl should point to data to exec 
484d			; 
484d			;	; will need to add the FORTH_END_BUFFER flag 
484d			 ; 
484d			;	ld hl, store_page+2 
484d			;	ld bc, 255 
484d			;	ld a, 0 
484d			;	cpir 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LOt" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;	dec hl 
484d			;	ld a, ' ' 
484d			;	ld (hl), a 
484d			;	inc hl 
484d			;	ld (hl), a 
484d			;	inc hl 
484d			;	ld (hl), a 
484d			;	inc hl 
484d			;	ld a, FORTH_END_BUFFER 
484d			;	ld (hl), a 
484d			; 
484d			;	; TODO handle more than a single block read 
484d			; 
484d			; 
484d			;	ld hl, store_page+2 
484d			; 
484d			;	ld (os_tok_ptr), hl 
484d			; 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LO3" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			; 
484d			;	call forthparse 
484d			;	call forthexec 
484d			;	call forthexec_cleanup 
484d			; 
484d			;	; go to next extent 
484d			; 
484d			;	; get next block  or mark as eof 
484d			;	jp .loadline 
484d			; 
484d			; 
484d			; 
484d			;	       NEXTW 
484d			;.loadeof:	ld a, 0 
484d			;		ld (store_openext), a 
484d			; 
484d			;	if DEBUG_STORESE 
484d			;		DMARK "LOF" 
484d			;		CALLMONITOR 
484d			;	endif 
484d			;		ret 
484d			;		;NEXTW 
484d			;.BSAVE:   
484d			; 
484d			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
484d			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
484d			;		NEXTW 
484d			;.BLOAD: 
484d			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
484d			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
484d			;		NEXTW 
484d			;;;; counter gap 
484d			 
484d			 
484d			.SEO: 
484d				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
484d 64				db WORD_SYS_CORE+80             
484e 6c 48			dw .SEI            
4850 04				db 3 + 1 
4851 .. 00			db "SEO",0              
4855				endm 
# End of macro CWHEAD
4855			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4855			 
4855					; get port 
4855			 
4855					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4855 cd a7 1e			call macro_dsp_valuehl 
4858				endm 
# End of macro FORTH_DSP_VALUEHL
4858			 
4858 e5					push hl    ; u2 - byte 
4859			 
4859					; destroy value TOS 
4859			 
4859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4859 cd 5f 1f			call macro_forth_dsp_pop 
485c				endm 
# End of macro FORTH_DSP_POP
485c			 
485c					; get byte to send 
485c			 
485c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
485c cd a7 1e			call macro_dsp_valuehl 
485f				endm 
# End of macro FORTH_DSP_VALUEHL
485f			 
485f e5					push hl    ; u1 - addr 
4860			 
4860					; destroy value TOS 
4860			 
4860					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4860 cd 5f 1f			call macro_forth_dsp_pop 
4863				endm 
# End of macro FORTH_DSP_POP
4863			 
4863					; one value on hl get other one back 
4863			 
4863 d1					pop de   ; u1 - byte 
4864			 
4864 e1					pop hl   ; u2 - addr 
4865			 
4865					; TODO Send SPI byte 
4865			 
4865			 
4865 7b					ld a, e 
4866 cd e7 01				call se_writebyte 
4869			 
4869					 
4869			 
4869					NEXTW 
4869 c3 19 20			jp macro_next 
486c				endm 
# End of macro NEXTW
486c			 
486c			.SEI: 
486c				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
486c 65				db WORD_SYS_CORE+81             
486d 86 48			dw .SFREE            
486f 04				db 3 + 1 
4870 .. 00			db "SEI",0              
4874				endm 
# End of macro CWHEAD
4874			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4874			 
4874					; get port 
4874			 
4874					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4874 cd a7 1e			call macro_dsp_valuehl 
4877				endm 
# End of macro FORTH_DSP_VALUEHL
4877			 
4877			;		push hl 
4877			 
4877					; destroy value TOS 
4877			 
4877					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4877 cd 5f 1f			call macro_forth_dsp_pop 
487a				endm 
# End of macro FORTH_DSP_POP
487a			 
487a					; one value on hl get other one back 
487a			 
487a			;		pop hl 
487a			 
487a			 
487a					; TODO Get SPI byte 
487a			 
487a cd 89 02				call se_readbyte 
487d			 
487d 26 00				ld h, 0 
487f 6f					ld l, a 
4880 cd b0 1c				call forth_push_numhl 
4883			 
4883					NEXTW 
4883 c3 19 20			jp macro_next 
4886				endm 
# End of macro NEXTW
4886			 
4886			.SFREE: 
4886				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4886 67				db WORD_SYS_CORE+83             
4887 b5 48			dw .SIZE            
4889 06				db 5 + 1 
488a .. 00			db "FFREE",0              
4890				endm 
# End of macro CWHEAD
4890			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4890					if DEBUG_FORTH_WORDS_KEY 
4890						DMARK "FFR" 
4890 f5				push af  
4891 3a a5 48			ld a, (.dmark)  
4894 32 bd fb			ld (debug_mark),a  
4897 3a a6 48			ld a, (.dmark+1)  
489a 32 be fb			ld (debug_mark+1),a  
489d 3a a7 48			ld a, (.dmark+2)  
48a0 32 bf fb			ld (debug_mark+2),a  
48a3 18 03			jr .pastdmark  
48a5 ..			.dmark: db "FFR"  
48a8 f1			.pastdmark: pop af  
48a9			endm  
# End of macro DMARK
48a9						CALLMONITOR 
48a9 cd 20 17			call break_point_state  
48ac				endm  
# End of macro CALLMONITOR
48ac					endif 
48ac			 
48ac cd c4 06				call storage_freeblocks 
48af			 
48af cd b0 1c				call forth_push_numhl 
48b2			 
48b2				       NEXTW 
48b2 c3 19 20			jp macro_next 
48b5				endm 
# End of macro NEXTW
48b5			.SIZE: 
48b5				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
48b5 67				db WORD_SYS_CORE+83             
48b6 e9 48			dw .CREATE            
48b8 05				db 4 + 1 
48b9 .. 00			db "SIZE",0              
48be				endm 
# End of macro CWHEAD
48be			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
48be					if DEBUG_FORTH_WORDS_KEY 
48be						DMARK "SIZ" 
48be f5				push af  
48bf 3a d3 48			ld a, (.dmark)  
48c2 32 bd fb			ld (debug_mark),a  
48c5 3a d4 48			ld a, (.dmark+1)  
48c8 32 be fb			ld (debug_mark+1),a  
48cb 3a d5 48			ld a, (.dmark+2)  
48ce 32 bf fb			ld (debug_mark+2),a  
48d1 18 03			jr .pastdmark  
48d3 ..			.dmark: db "SIZ"  
48d6 f1			.pastdmark: pop af  
48d7			endm  
# End of macro DMARK
48d7						CALLMONITOR 
48d7 cd 20 17			call break_point_state  
48da				endm  
# End of macro CALLMONITOR
48da					endif 
48da			 
48da					FORTH_DSP_VALUEHL 
48da cd a7 1e			call macro_dsp_valuehl 
48dd				endm 
# End of macro FORTH_DSP_VALUEHL
48dd			;		push hl 
48dd					FORTH_DSP_POP 
48dd cd 5f 1f			call macro_forth_dsp_pop 
48e0				endm 
# End of macro FORTH_DSP_POP
48e0			;		pop hl 
48e0 cd 38 03				call storage_file_size 
48e3			 
48e3 cd b0 1c				call forth_push_numhl 
48e6			  
48e6			 
48e6				       NEXTW 
48e6 c3 19 20			jp macro_next 
48e9				endm 
# End of macro NEXTW
48e9			 
48e9			.CREATE: 
48e9				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
48e9 68				db WORD_SYS_CORE+84             
48ea 57 49			dw .APPEND            
48ec 07				db 6 + 1 
48ed .. 00			db "CREATE",0              
48f4				endm 
# End of macro CWHEAD
48f4			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
48f4			; | | e.g.  
48f4			; | | TestProgram CREATE 
48f4			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
48f4			; | |  
48f4			; | | Max file IDs are 255. 
48f4			; | |  
48f4					 
48f4					if DEBUG_FORTH_WORDS_KEY 
48f4						DMARK "CRT" 
48f4 f5				push af  
48f5 3a 09 49			ld a, (.dmark)  
48f8 32 bd fb			ld (debug_mark),a  
48fb 3a 0a 49			ld a, (.dmark+1)  
48fe 32 be fb			ld (debug_mark+1),a  
4901 3a 0b 49			ld a, (.dmark+2)  
4904 32 bf fb			ld (debug_mark+2),a  
4907 18 03			jr .pastdmark  
4909 ..			.dmark: db "CRT"  
490c f1			.pastdmark: pop af  
490d			endm  
# End of macro DMARK
490d						CALLMONITOR 
490d cd 20 17			call break_point_state  
4910				endm  
# End of macro CALLMONITOR
4910					endif 
4910			;		call storage_get_block_0 
4910			 
4910					; TODO pop hl 
4910			 
4910					;v5 FORTH_DSP_VALUE 
4910					FORTH_DSP_VALUE 
4910 cd 90 1e			call macro_forth_dsp_value 
4913				endm 
# End of macro FORTH_DSP_VALUE
4913			 
4913				if DEBUG_STORESE 
4913					DMARK "CR1" 
4913 f5				push af  
4914 3a 28 49			ld a, (.dmark)  
4917 32 bd fb			ld (debug_mark),a  
491a 3a 29 49			ld a, (.dmark+1)  
491d 32 be fb			ld (debug_mark+1),a  
4920 3a 2a 49			ld a, (.dmark+2)  
4923 32 bf fb			ld (debug_mark+2),a  
4926 18 03			jr .pastdmark  
4928 ..			.dmark: db "CR1"  
492b f1			.pastdmark: pop af  
492c			endm  
# End of macro DMARK
492c					CALLMONITOR 
492c cd 20 17			call break_point_state  
492f				endm  
# End of macro CALLMONITOR
492f				endif 
492f			;		push hl 
492f			;		FORTH_DSP_POP 
492f			;		pop hl 
492f			 
492f			;		inc hl   ; move past the type marker 
492f			 
492f cd fa 06				call storage_create 
4932			 
4932				if DEBUG_STORESE 
4932					DMARK "CT1" 
4932 f5				push af  
4933 3a 47 49			ld a, (.dmark)  
4936 32 bd fb			ld (debug_mark),a  
4939 3a 48 49			ld a, (.dmark+1)  
493c 32 be fb			ld (debug_mark+1),a  
493f 3a 49 49			ld a, (.dmark+2)  
4942 32 bf fb			ld (debug_mark+2),a  
4945 18 03			jr .pastdmark  
4947 ..			.dmark: db "CT1"  
494a f1			.pastdmark: pop af  
494b			endm  
# End of macro DMARK
494b					CALLMONITOR 
494b cd 20 17			call break_point_state  
494e				endm  
# End of macro CALLMONITOR
494e				endif 
494e			;		push hl 
494e					FORTH_DSP_POP 
494e cd 5f 1f			call macro_forth_dsp_pop 
4951				endm 
# End of macro FORTH_DSP_POP
4951			;		pop hl 
4951					; push file id to stack 
4951 cd b0 1c				call forth_push_numhl 
4954			 
4954			 
4954			 
4954				       NEXTW 
4954 c3 19 20			jp macro_next 
4957				endm 
# End of macro NEXTW
4957			 
4957			.APPEND: 
4957				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4957 69				db WORD_SYS_CORE+85             
4958 e8 49			dw .SDEL            
495a 07				db 6 + 1 
495b .. 00			db "APPEND",0              
4962				endm 
# End of macro CWHEAD
4962			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4962			; | | e.g. 
4962			; | | Test CREATE      -> $01 
4962			; | | "A string to add to file" $01 APPEND 
4962			; | |  
4962			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4962					if DEBUG_FORTH_WORDS_KEY 
4962						DMARK "APP" 
4962 f5				push af  
4963 3a 77 49			ld a, (.dmark)  
4966 32 bd fb			ld (debug_mark),a  
4969 3a 78 49			ld a, (.dmark+1)  
496c 32 be fb			ld (debug_mark+1),a  
496f 3a 79 49			ld a, (.dmark+2)  
4972 32 bf fb			ld (debug_mark+2),a  
4975 18 03			jr .pastdmark  
4977 ..			.dmark: db "APP"  
497a f1			.pastdmark: pop af  
497b			endm  
# End of macro DMARK
497b						CALLMONITOR 
497b cd 20 17			call break_point_state  
497e				endm  
# End of macro CALLMONITOR
497e					endif 
497e			 
497e					FORTH_DSP_VALUEHL 
497e cd a7 1e			call macro_dsp_valuehl 
4981				endm 
# End of macro FORTH_DSP_VALUEHL
4981 e5					push hl 	; save file id 
4982			 
4982				if DEBUG_STORESE 
4982					DMARK "AP1" 
4982 f5				push af  
4983 3a 97 49			ld a, (.dmark)  
4986 32 bd fb			ld (debug_mark),a  
4989 3a 98 49			ld a, (.dmark+1)  
498c 32 be fb			ld (debug_mark+1),a  
498f 3a 99 49			ld a, (.dmark+2)  
4992 32 bf fb			ld (debug_mark+2),a  
4995 18 03			jr .pastdmark  
4997 ..			.dmark: db "AP1"  
499a f1			.pastdmark: pop af  
499b			endm  
# End of macro DMARK
499b					CALLMONITOR 
499b cd 20 17			call break_point_state  
499e				endm  
# End of macro CALLMONITOR
499e				endif 
499e					FORTH_DSP_POP 
499e cd 5f 1f			call macro_forth_dsp_pop 
49a1				endm 
# End of macro FORTH_DSP_POP
49a1			 
49a1					FORTH_DSP_VALUEHL 
49a1 cd a7 1e			call macro_dsp_valuehl 
49a4				endm 
# End of macro FORTH_DSP_VALUEHL
49a4					;v5 FORTH_DSP_VALUE 
49a4 e5					push hl 	; save ptr to string to save 
49a5			 
49a5				if DEBUG_STORESE 
49a5					DMARK "AP1" 
49a5 f5				push af  
49a6 3a ba 49			ld a, (.dmark)  
49a9 32 bd fb			ld (debug_mark),a  
49ac 3a bb 49			ld a, (.dmark+1)  
49af 32 be fb			ld (debug_mark+1),a  
49b2 3a bc 49			ld a, (.dmark+2)  
49b5 32 bf fb			ld (debug_mark+2),a  
49b8 18 03			jr .pastdmark  
49ba ..			.dmark: db "AP1"  
49bd f1			.pastdmark: pop af  
49be			endm  
# End of macro DMARK
49be					CALLMONITOR 
49be cd 20 17			call break_point_state  
49c1				endm  
# End of macro CALLMONITOR
49c1				endif 
49c1					FORTH_DSP_POP 
49c1 cd 5f 1f			call macro_forth_dsp_pop 
49c4				endm 
# End of macro FORTH_DSP_POP
49c4			 
49c4 d1					pop de 
49c5 e1					pop hl 
49c6				if DEBUG_STORESE 
49c6					DMARK "AP2" 
49c6 f5				push af  
49c7 3a db 49			ld a, (.dmark)  
49ca 32 bd fb			ld (debug_mark),a  
49cd 3a dc 49			ld a, (.dmark+1)  
49d0 32 be fb			ld (debug_mark+1),a  
49d3 3a dd 49			ld a, (.dmark+2)  
49d6 32 bf fb			ld (debug_mark+2),a  
49d9 18 03			jr .pastdmark  
49db ..			.dmark: db "AP2"  
49de f1			.pastdmark: pop af  
49df			endm  
# End of macro DMARK
49df					CALLMONITOR 
49df cd 20 17			call break_point_state  
49e2				endm  
# End of macro CALLMONITOR
49e2				endif 
49e2					;inc de ; skip var type indicator 
49e2			 
49e2					; TODO how to append numerics???? 
49e2			 
49e2 cd d4 08				call storage_append		 
49e5			 
49e5				       NEXTW 
49e5 c3 19 20			jp macro_next 
49e8				endm 
# End of macro NEXTW
49e8			.SDEL: 
49e8				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
49e8 6a				db WORD_SYS_CORE+86             
49e9 34 4a			dw .OPEN            
49eb 05				db 4 + 1 
49ec .. 00			db "ERA",0              
49f0				endm 
# End of macro CWHEAD
49f0			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
49f0					FORTH_DSP_VALUEHL 
49f0 cd a7 1e			call macro_dsp_valuehl 
49f3				endm 
# End of macro FORTH_DSP_VALUEHL
49f3			;		push hl 	; save file id 
49f3			 
49f3					if DEBUG_FORTH_WORDS_KEY 
49f3						DMARK "ERA" 
49f3 f5				push af  
49f4 3a 08 4a			ld a, (.dmark)  
49f7 32 bd fb			ld (debug_mark),a  
49fa 3a 09 4a			ld a, (.dmark+1)  
49fd 32 be fb			ld (debug_mark+1),a  
4a00 3a 0a 4a			ld a, (.dmark+2)  
4a03 32 bf fb			ld (debug_mark+2),a  
4a06 18 03			jr .pastdmark  
4a08 ..			.dmark: db "ERA"  
4a0b f1			.pastdmark: pop af  
4a0c			endm  
# End of macro DMARK
4a0c						CALLMONITOR 
4a0c cd 20 17			call break_point_state  
4a0f				endm  
# End of macro CALLMONITOR
4a0f					endif 
4a0f				if DEBUG_STORESE 
4a0f					DMARK "ER1" 
4a0f f5				push af  
4a10 3a 24 4a			ld a, (.dmark)  
4a13 32 bd fb			ld (debug_mark),a  
4a16 3a 25 4a			ld a, (.dmark+1)  
4a19 32 be fb			ld (debug_mark+1),a  
4a1c 3a 26 4a			ld a, (.dmark+2)  
4a1f 32 bf fb			ld (debug_mark+2),a  
4a22 18 03			jr .pastdmark  
4a24 ..			.dmark: db "ER1"  
4a27 f1			.pastdmark: pop af  
4a28			endm  
# End of macro DMARK
4a28					CALLMONITOR 
4a28 cd 20 17			call break_point_state  
4a2b				endm  
# End of macro CALLMONITOR
4a2b				endif 
4a2b					FORTH_DSP_POP 
4a2b cd 5f 1f			call macro_forth_dsp_pop 
4a2e				endm 
# End of macro FORTH_DSP_POP
4a2e			 
4a2e			;		pop hl 
4a2e			 
4a2e cd 49 05				call storage_erase 
4a31				       NEXTW 
4a31 c3 19 20			jp macro_next 
4a34				endm 
# End of macro NEXTW
4a34			 
4a34			.OPEN: 
4a34				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a34 6b				db WORD_SYS_CORE+87             
4a35 bb 4a			dw .READ            
4a37 05				db 4 + 1 
4a38 .. 00			db "OPEN",0              
4a3d				endm 
# End of macro CWHEAD
4a3d			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a3d			; | | e.g. 
4a3d			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a3d			 
4a3d					if DEBUG_FORTH_WORDS_KEY 
4a3d						DMARK "OPN" 
4a3d f5				push af  
4a3e 3a 52 4a			ld a, (.dmark)  
4a41 32 bd fb			ld (debug_mark),a  
4a44 3a 53 4a			ld a, (.dmark+1)  
4a47 32 be fb			ld (debug_mark+1),a  
4a4a 3a 54 4a			ld a, (.dmark+2)  
4a4d 32 bf fb			ld (debug_mark+2),a  
4a50 18 03			jr .pastdmark  
4a52 ..			.dmark: db "OPN"  
4a55 f1			.pastdmark: pop af  
4a56			endm  
# End of macro DMARK
4a56						CALLMONITOR 
4a56 cd 20 17			call break_point_state  
4a59				endm  
# End of macro CALLMONITOR
4a59					endif 
4a59					; TODO handle multiple file opens 
4a59			 
4a59 3e 01			       	ld a, 1 
4a5b 32 df f9				ld (store_openext), a 
4a5e			 
4a5e					; get max extents for this file 
4a5e				 
4a5e								 
4a5e					FORTH_DSP_VALUEHL 
4a5e cd a7 1e			call macro_dsp_valuehl 
4a61				endm 
# End of macro FORTH_DSP_VALUEHL
4a61			 
4a61 65					ld h, l 
4a62 2e 00				ld l, 0 
4a64			 
4a64				if DEBUG_STORESE 
4a64					DMARK "OPN" 
4a64 f5				push af  
4a65 3a 79 4a			ld a, (.dmark)  
4a68 32 bd fb			ld (debug_mark),a  
4a6b 3a 7a 4a			ld a, (.dmark+1)  
4a6e 32 be fb			ld (debug_mark+1),a  
4a71 3a 7b 4a			ld a, (.dmark+2)  
4a74 32 bf fb			ld (debug_mark+2),a  
4a77 18 03			jr .pastdmark  
4a79 ..			.dmark: db "OPN"  
4a7c f1			.pastdmark: pop af  
4a7d			endm  
# End of macro DMARK
4a7d					CALLMONITOR 
4a7d cd 20 17			call break_point_state  
4a80				endm  
# End of macro CALLMONITOR
4a80				endif 
4a80			;		push hl 
4a80					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4a80 cd 5f 1f			call macro_forth_dsp_pop 
4a83				endm 
# End of macro FORTH_DSP_POP
4a83			;		pop hl 
4a83						 
4a83 11 e8 f9				ld de, store_page      ; get block zero of file 
4a86 cd 4e 08				call storage_read 
4a89			 
4a89			 
4a89 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4a8c 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4a8f					 
4a8f				if DEBUG_STORESE 
4a8f					DMARK "OPx" 
4a8f f5				push af  
4a90 3a a4 4a			ld a, (.dmark)  
4a93 32 bd fb			ld (debug_mark),a  
4a96 3a a5 4a			ld a, (.dmark+1)  
4a99 32 be fb			ld (debug_mark+1),a  
4a9c 3a a6 4a			ld a, (.dmark+2)  
4a9f 32 bf fb			ld (debug_mark+2),a  
4aa2 18 03			jr .pastdmark  
4aa4 ..			.dmark: db "OPx"  
4aa7 f1			.pastdmark: pop af  
4aa8			endm  
# End of macro DMARK
4aa8					CALLMONITOR 
4aa8 cd 20 17			call break_point_state  
4aab				endm  
# End of macro CALLMONITOR
4aab				endif 
4aab fe 00				cp 0 
4aad 20 03				jr nz, .skipopeneof 
4aaf					; have opened an empty file 
4aaf					 
4aaf 32 df f9				ld (store_openext), a 
4ab2			 
4ab2			.skipopeneof: 
4ab2			 
4ab2 6f					ld l, a 
4ab3 26 00				ld h, 0 
4ab5 cd b0 1c				call forth_push_numhl 
4ab8			 
4ab8			 
4ab8				       NEXTW 
4ab8 c3 19 20			jp macro_next 
4abb				endm 
# End of macro NEXTW
4abb			.READ: 
4abb				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4abb 6c				db WORD_SYS_CORE+88             
4abc 02 4c			dw .EOF            
4abe 05				db 4 + 1 
4abf .. 00			db "READ",0              
4ac4				endm 
# End of macro CWHEAD
4ac4			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4ac4			; | | e.g. 
4ac4			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ac4			 
4ac4					if DEBUG_FORTH_WORDS_KEY 
4ac4						DMARK "REA" 
4ac4 f5				push af  
4ac5 3a d9 4a			ld a, (.dmark)  
4ac8 32 bd fb			ld (debug_mark),a  
4acb 3a da 4a			ld a, (.dmark+1)  
4ace 32 be fb			ld (debug_mark+1),a  
4ad1 3a db 4a			ld a, (.dmark+2)  
4ad4 32 bf fb			ld (debug_mark+2),a  
4ad7 18 03			jr .pastdmark  
4ad9 ..			.dmark: db "REA"  
4adc f1			.pastdmark: pop af  
4add			endm  
# End of macro DMARK
4add						CALLMONITOR 
4add cd 20 17			call break_point_state  
4ae0				endm  
# End of macro CALLMONITOR
4ae0					endif 
4ae0					; store_openext use it. If zero it is EOF 
4ae0			 
4ae0					; read block from current stream id 
4ae0					; if the block does not contain zero term keep reading blocks until zero found 
4ae0					; push the block to stack 
4ae0					; save the block id to stream 
4ae0			 
4ae0			 
4ae0					FORTH_DSP_VALUEHL 
4ae0 cd a7 1e			call macro_dsp_valuehl 
4ae3				endm 
# End of macro FORTH_DSP_VALUEHL
4ae3			 
4ae3			;		push hl 
4ae3			 
4ae3				if DEBUG_STORESE 
4ae3					DMARK "REA" 
4ae3 f5				push af  
4ae4 3a f8 4a			ld a, (.dmark)  
4ae7 32 bd fb			ld (debug_mark),a  
4aea 3a f9 4a			ld a, (.dmark+1)  
4aed 32 be fb			ld (debug_mark+1),a  
4af0 3a fa 4a			ld a, (.dmark+2)  
4af3 32 bf fb			ld (debug_mark+2),a  
4af6 18 03			jr .pastdmark  
4af8 ..			.dmark: db "REA"  
4afb f1			.pastdmark: pop af  
4afc			endm  
# End of macro DMARK
4afc					CALLMONITOR 
4afc cd 20 17			call break_point_state  
4aff				endm  
# End of macro CALLMONITOR
4aff				endif 
4aff					FORTH_DSP_POP 
4aff cd 5f 1f			call macro_forth_dsp_pop 
4b02				endm 
# End of macro FORTH_DSP_POP
4b02			 
4b02			;		pop hl 
4b02				 
4b02 65					ld h,l 
4b03			 
4b03 3a df f9				ld a, (store_openext) 
4b06 6f					ld l, a 
4b07					 
4b07 fe 00				cp 0 
4b09 ca d4 4b				jp z, .ateof     ; dont read past eof 
4b0c			 
4b0c			 
4b0c 11 e8 f9				ld de, store_page 
4b0f				if DEBUG_STORESE 
4b0f					DMARK "RE1" 
4b0f f5				push af  
4b10 3a 24 4b			ld a, (.dmark)  
4b13 32 bd fb			ld (debug_mark),a  
4b16 3a 25 4b			ld a, (.dmark+1)  
4b19 32 be fb			ld (debug_mark+1),a  
4b1c 3a 26 4b			ld a, (.dmark+2)  
4b1f 32 bf fb			ld (debug_mark+2),a  
4b22 18 03			jr .pastdmark  
4b24 ..			.dmark: db "RE1"  
4b27 f1			.pastdmark: pop af  
4b28			endm  
# End of macro DMARK
4b28					CALLMONITOR 
4b28 cd 20 17			call break_point_state  
4b2b				endm  
# End of macro CALLMONITOR
4b2b				endif 
4b2b cd 4e 08				call storage_read 
4b2e			 
4b2e				if DEBUG_STORESE 
4b2e					DMARK "RE2" 
4b2e f5				push af  
4b2f 3a 43 4b			ld a, (.dmark)  
4b32 32 bd fb			ld (debug_mark),a  
4b35 3a 44 4b			ld a, (.dmark+1)  
4b38 32 be fb			ld (debug_mark+1),a  
4b3b 3a 45 4b			ld a, (.dmark+2)  
4b3e 32 bf fb			ld (debug_mark+2),a  
4b41 18 03			jr .pastdmark  
4b43 ..			.dmark: db "RE2"  
4b46 f1			.pastdmark: pop af  
4b47			endm  
# End of macro DMARK
4b47					CALLMONITOR 
4b47 cd 20 17			call break_point_state  
4b4a				endm  
# End of macro CALLMONITOR
4b4a				endif 
4b4a cd 2f 0d			call ishlzero 
4b4d			;	ld a, l 
4b4d			;	add h 
4b4d			;	cp 0 
4b4d ca da 4b			jp z, .readeof 
4b50			 
4b50				; not eof so hl should point to data to push to stack 
4b50			 
4b50				if DEBUG_STORESE 
4b50					DMARK "RE3" 
4b50 f5				push af  
4b51 3a 65 4b			ld a, (.dmark)  
4b54 32 bd fb			ld (debug_mark),a  
4b57 3a 66 4b			ld a, (.dmark+1)  
4b5a 32 be fb			ld (debug_mark+1),a  
4b5d 3a 67 4b			ld a, (.dmark+2)  
4b60 32 bf fb			ld (debug_mark+2),a  
4b63 18 03			jr .pastdmark  
4b65 ..			.dmark: db "RE3"  
4b68 f1			.pastdmark: pop af  
4b69			endm  
# End of macro DMARK
4b69					CALLMONITOR 
4b69 cd 20 17			call break_point_state  
4b6c				endm  
# End of macro CALLMONITOR
4b6c				endif 
4b6c cd 1e 1d			call forth_push_str 
4b6f			 
4b6f				if DEBUG_STORESE 
4b6f					DMARK "RE4" 
4b6f f5				push af  
4b70 3a 84 4b			ld a, (.dmark)  
4b73 32 bd fb			ld (debug_mark),a  
4b76 3a 85 4b			ld a, (.dmark+1)  
4b79 32 be fb			ld (debug_mark+1),a  
4b7c 3a 86 4b			ld a, (.dmark+2)  
4b7f 32 bf fb			ld (debug_mark+2),a  
4b82 18 03			jr .pastdmark  
4b84 ..			.dmark: db "RE4"  
4b87 f1			.pastdmark: pop af  
4b88			endm  
# End of macro DMARK
4b88					CALLMONITOR 
4b88 cd 20 17			call break_point_state  
4b8b				endm  
# End of macro CALLMONITOR
4b8b				endif 
4b8b				; get next block  or mark as eof 
4b8b			 
4b8b 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4b8e 4f				ld c, a	 
4b8f 3a df f9			ld a, (store_openext) 
4b92			 
4b92				if DEBUG_STORESE 
4b92					DMARK "RE5" 
4b92 f5				push af  
4b93 3a a7 4b			ld a, (.dmark)  
4b96 32 bd fb			ld (debug_mark),a  
4b99 3a a8 4b			ld a, (.dmark+1)  
4b9c 32 be fb			ld (debug_mark+1),a  
4b9f 3a a9 4b			ld a, (.dmark+2)  
4ba2 32 bf fb			ld (debug_mark+2),a  
4ba5 18 03			jr .pastdmark  
4ba7 ..			.dmark: db "RE5"  
4baa f1			.pastdmark: pop af  
4bab			endm  
# End of macro DMARK
4bab					CALLMONITOR 
4bab cd 20 17			call break_point_state  
4bae				endm  
# End of macro CALLMONITOR
4bae				endif 
4bae b9				cp c 
4baf 28 29			jr z, .readeof     ; at last extent 
4bb1			 
4bb1 3c					inc a 
4bb2 32 df f9				ld (store_openext), a 
4bb5			 
4bb5				if DEBUG_STORESE 
4bb5					DMARK "RE6" 
4bb5 f5				push af  
4bb6 3a ca 4b			ld a, (.dmark)  
4bb9 32 bd fb			ld (debug_mark),a  
4bbc 3a cb 4b			ld a, (.dmark+1)  
4bbf 32 be fb			ld (debug_mark+1),a  
4bc2 3a cc 4b			ld a, (.dmark+2)  
4bc5 32 bf fb			ld (debug_mark+2),a  
4bc8 18 03			jr .pastdmark  
4bca ..			.dmark: db "RE6"  
4bcd f1			.pastdmark: pop af  
4bce			endm  
# End of macro DMARK
4bce					CALLMONITOR 
4bce cd 20 17			call break_point_state  
4bd1				endm  
# End of macro CALLMONITOR
4bd1				endif 
4bd1			 
4bd1			 
4bd1				       NEXTW 
4bd1 c3 19 20			jp macro_next 
4bd4				endm 
# End of macro NEXTW
4bd4			.ateof: 
4bd4 21 fe 4b				ld hl, .showeof 
4bd7 cd 1e 1d				call forth_push_str 
4bda 3e 00		.readeof:	ld a, 0 
4bdc 32 df f9				ld (store_openext), a 
4bdf			 
4bdf					 
4bdf				if DEBUG_STORESE 
4bdf					DMARK "REF" 
4bdf f5				push af  
4be0 3a f4 4b			ld a, (.dmark)  
4be3 32 bd fb			ld (debug_mark),a  
4be6 3a f5 4b			ld a, (.dmark+1)  
4be9 32 be fb			ld (debug_mark+1),a  
4bec 3a f6 4b			ld a, (.dmark+2)  
4bef 32 bf fb			ld (debug_mark+2),a  
4bf2 18 03			jr .pastdmark  
4bf4 ..			.dmark: db "REF"  
4bf7 f1			.pastdmark: pop af  
4bf8			endm  
# End of macro DMARK
4bf8					CALLMONITOR 
4bf8 cd 20 17			call break_point_state  
4bfb				endm  
# End of macro CALLMONITOR
4bfb				endif 
4bfb				       NEXTW 
4bfb c3 19 20			jp macro_next 
4bfe				endm 
# End of macro NEXTW
4bfe			 
4bfe .. 00		.showeof:   db "eof", 0 
4c02			 
4c02			 
4c02			.EOF: 
4c02				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c02 6d				db WORD_SYS_CORE+89             
4c03 43 4c			dw .FORMAT            
4c05 04				db 3 + 1 
4c06 .. 00			db "EOF",0              
4c0a				endm 
# End of macro CWHEAD
4c0a			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c0a			; | | e.g. 
4c0a			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c0a					; TODO if current block id for stream is zero then push true else false 
4c0a			 
4c0a					if DEBUG_FORTH_WORDS_KEY 
4c0a						DMARK "EOF" 
4c0a f5				push af  
4c0b 3a 1f 4c			ld a, (.dmark)  
4c0e 32 bd fb			ld (debug_mark),a  
4c11 3a 20 4c			ld a, (.dmark+1)  
4c14 32 be fb			ld (debug_mark+1),a  
4c17 3a 21 4c			ld a, (.dmark+2)  
4c1a 32 bf fb			ld (debug_mark+2),a  
4c1d 18 03			jr .pastdmark  
4c1f ..			.dmark: db "EOF"  
4c22 f1			.pastdmark: pop af  
4c23			endm  
# End of macro DMARK
4c23						CALLMONITOR 
4c23 cd 20 17			call break_point_state  
4c26				endm  
# End of macro CALLMONITOR
4c26					endif 
4c26			 
4c26					; TODO handlue multiple file streams 
4c26			 
4c26					FORTH_DSP_POP     ; for now just get rid of stream id 
4c26 cd 5f 1f			call macro_forth_dsp_pop 
4c29				endm 
# End of macro FORTH_DSP_POP
4c29			 
4c29 2e 01				ld l, 1 
4c2b 3a de f9				ld a, (store_openmaxext) 
4c2e fe 00				cp 0 
4c30 28 09				jr  z, .eofdone   ; empty file 
4c32 3a df f9				ld a, (store_openext) 
4c35 fe 00				cp 0 
4c37 28 02				jr  z, .eofdone 
4c39 2e 00				ld l, 0 
4c3b 26 00		.eofdone:	ld h, 0 
4c3d cd b0 1c				call forth_push_numhl 
4c40			 
4c40			 
4c40				       NEXTW 
4c40 c3 19 20			jp macro_next 
4c43				endm 
# End of macro NEXTW
4c43			 
4c43			.FORMAT: 
4c43				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4c43 6d				db WORD_SYS_CORE+89             
4c44 94 4c			dw .LABEL            
4c46 07				db 6 + 1 
4c47 .. 00			db "FORMAT",0              
4c4e				endm 
# End of macro CWHEAD
4c4e			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4c4e					; TODO if current block id for stream is zero then push true else false 
4c4e				 
4c4e				if DEBUG_STORESE 
4c4e					DMARK "FOR" 
4c4e f5				push af  
4c4f 3a 63 4c			ld a, (.dmark)  
4c52 32 bd fb			ld (debug_mark),a  
4c55 3a 64 4c			ld a, (.dmark+1)  
4c58 32 be fb			ld (debug_mark+1),a  
4c5b 3a 65 4c			ld a, (.dmark+2)  
4c5e 32 bf fb			ld (debug_mark+2),a  
4c61 18 03			jr .pastdmark  
4c63 ..			.dmark: db "FOR"  
4c66 f1			.pastdmark: pop af  
4c67			endm  
# End of macro DMARK
4c67					CALLMONITOR 
4c67 cd 20 17			call break_point_state  
4c6a				endm  
# End of macro CALLMONITOR
4c6a				endif 
4c6a					; Wipes the bank check flags to cause a reformat on next block 0 read 
4c6a			 
4c6a 21 01 00				ld hl, 1 
4c6d 3e 00				ld a, 0 
4c6f cd e7 01				call se_writebyte 
4c72			 
4c72				if DEBUG_STORESE 
4c72					DMARK "FO0" 
4c72 f5				push af  
4c73 3a 87 4c			ld a, (.dmark)  
4c76 32 bd fb			ld (debug_mark),a  
4c79 3a 88 4c			ld a, (.dmark+1)  
4c7c 32 be fb			ld (debug_mark+1),a  
4c7f 3a 89 4c			ld a, (.dmark+2)  
4c82 32 bf fb			ld (debug_mark+2),a  
4c85 18 03			jr .pastdmark  
4c87 ..			.dmark: db "FO0"  
4c8a f1			.pastdmark: pop af  
4c8b			endm  
# End of macro DMARK
4c8b					CALLMONITOR 
4c8b cd 20 17			call break_point_state  
4c8e				endm  
# End of macro CALLMONITOR
4c8e				endif 
4c8e					; force bank init 
4c8e			 
4c8e cd ba 03				call storage_get_block_0 
4c91					 
4c91				       NEXTW 
4c91 c3 19 20			jp macro_next 
4c94				endm 
# End of macro NEXTW
4c94			.LABEL: 
4c94				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4c94 6d				db WORD_SYS_CORE+89             
4c95 e2 4c			dw .STOREPAGE            
4c97 06				db 5 + 1 
4c98 .. 00			db "LABEL",0              
4c9e				endm 
# End of macro CWHEAD
4c9e			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4c9e					; TODO test to see if bank is selected 
4c9e				 
4c9e					if DEBUG_FORTH_WORDS_KEY 
4c9e						DMARK "LBL" 
4c9e f5				push af  
4c9f 3a b3 4c			ld a, (.dmark)  
4ca2 32 bd fb			ld (debug_mark),a  
4ca5 3a b4 4c			ld a, (.dmark+1)  
4ca8 32 be fb			ld (debug_mark+1),a  
4cab 3a b5 4c			ld a, (.dmark+2)  
4cae 32 bf fb			ld (debug_mark+2),a  
4cb1 18 03			jr .pastdmark  
4cb3 ..			.dmark: db "LBL"  
4cb6 f1			.pastdmark: pop af  
4cb7			endm  
# End of macro DMARK
4cb7						CALLMONITOR 
4cb7 cd 20 17			call break_point_state  
4cba				endm  
# End of macro CALLMONITOR
4cba					endif 
4cba			;	if DEBUG_STORESE 
4cba			;		DMARK "LBL" 
4cba			;		CALLMONITOR 
4cba			;	endif 
4cba					FORTH_DSP_VALUEHL 
4cba cd a7 1e			call macro_dsp_valuehl 
4cbd				endm 
# End of macro FORTH_DSP_VALUEHL
4cbd					;v5FORTH_DSP_VALUE 
4cbd					 
4cbd			;		push hl 
4cbd					FORTH_DSP_POP 
4cbd cd 5f 1f			call macro_forth_dsp_pop 
4cc0				endm 
# End of macro FORTH_DSP_POP
4cc0			;		pop hl 
4cc0			 
4cc0			;v5		inc hl   ; move past the type marker 
4cc0			 
4cc0				if DEBUG_STORESE 
4cc0					DMARK "LBl" 
4cc0 f5				push af  
4cc1 3a d5 4c			ld a, (.dmark)  
4cc4 32 bd fb			ld (debug_mark),a  
4cc7 3a d6 4c			ld a, (.dmark+1)  
4cca 32 be fb			ld (debug_mark+1),a  
4ccd 3a d7 4c			ld a, (.dmark+2)  
4cd0 32 bf fb			ld (debug_mark+2),a  
4cd3 18 03			jr .pastdmark  
4cd5 ..			.dmark: db "LBl"  
4cd8 f1			.pastdmark: pop af  
4cd9			endm  
# End of macro DMARK
4cd9					CALLMONITOR 
4cd9 cd 20 17			call break_point_state  
4cdc				endm  
# End of macro CALLMONITOR
4cdc				endif 
4cdc cd de 04				call storage_label 
4cdf			 
4cdf				       NEXTW 
4cdf c3 19 20			jp macro_next 
4ce2				endm 
# End of macro NEXTW
4ce2			.STOREPAGE: 
4ce2				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4ce2 6d				db WORD_SYS_CORE+89             
4ce3 15 4d			dw .LABELS            
4ce5 0a				db 9 + 1 
4ce6 .. 00			db "STOREPAGE",0              
4cf0				endm 
# End of macro CWHEAD
4cf0			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4cf0					; TODO test to see if bank is selected 
4cf0				 
4cf0					if DEBUG_FORTH_WORDS_KEY 
4cf0						DMARK "STP" 
4cf0 f5				push af  
4cf1 3a 05 4d			ld a, (.dmark)  
4cf4 32 bd fb			ld (debug_mark),a  
4cf7 3a 06 4d			ld a, (.dmark+1)  
4cfa 32 be fb			ld (debug_mark+1),a  
4cfd 3a 07 4d			ld a, (.dmark+2)  
4d00 32 bf fb			ld (debug_mark+2),a  
4d03 18 03			jr .pastdmark  
4d05 ..			.dmark: db "STP"  
4d08 f1			.pastdmark: pop af  
4d09			endm  
# End of macro DMARK
4d09						CALLMONITOR 
4d09 cd 20 17			call break_point_state  
4d0c				endm  
# End of macro CALLMONITOR
4d0c					endif 
4d0c			;	if DEBUG_STORESE 
4d0c			;		DMARK "STP" 
4d0c			;		CALLMONITOR 
4d0c			;	endif 
4d0c			 
4d0c 21 e8 f9			ld hl, store_page 
4d0f cd b0 1c			call forth_push_numhl 
4d12			 
4d12			 
4d12				       NEXTW 
4d12 c3 19 20			jp macro_next 
4d15				endm 
# End of macro NEXTW
4d15			.LABELS: 
4d15				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d15 6d				db WORD_SYS_CORE+89             
4d16 9f 4d			dw .ENDSTORAGE            
4d18 07				db 6 + 1 
4d19 .. 00			db "LABELS",0              
4d20				endm 
# End of macro CWHEAD
4d20			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d20					;  
4d20			 
4d20					; save the current device selected to restore afterwards 
4d20				 
4d20 3a ce f9				ld a, (spi_device) 
4d23 f5					push af 
4d24			 
4d24			 
4d24					; run through each of the banks 
4d24			 
4d24 21 01 00				ld hl, 1 
4d27 cd b0 1c				call forth_push_numhl 
4d2a 3e ff				ld a, SPI_CE_HIGH 
4d2c cb 87				res SPI_CE0, a 
4d2e 32 ce f9				ld (spi_device), a 
4d31 cd ba 03				call storage_get_block_0 
4d34 21 eb f9				ld hl, store_page+3 
4d37 cd 1e 1d				call forth_push_str 
4d3a			 
4d3a					 
4d3a 21 02 00				ld hl, 2 
4d3d cd b0 1c				call forth_push_numhl 
4d40 3e ff				ld a, SPI_CE_HIGH 
4d42 cb 8f				res SPI_CE1, a 
4d44 32 ce f9				ld (spi_device), a 
4d47 cd ba 03				call storage_get_block_0 
4d4a 21 eb f9				ld hl, store_page+3 
4d4d cd 1e 1d				call forth_push_str 
4d50			 
4d50					 
4d50 21 03 00				ld hl, 3 
4d53 cd b0 1c				call forth_push_numhl 
4d56 3e ff				ld a, SPI_CE_HIGH 
4d58 cb 97				res SPI_CE2, a 
4d5a 32 ce f9				ld (spi_device), a 
4d5d cd ba 03				call storage_get_block_0 
4d60 21 eb f9				ld hl, store_page+3 
4d63 cd 1e 1d				call forth_push_str 
4d66			 
4d66			 
4d66 21 04 00				ld hl, 4 
4d69 cd b0 1c				call forth_push_numhl 
4d6c 3e ff				ld a, SPI_CE_HIGH 
4d6e cb 9f				res SPI_CE3, a 
4d70 32 ce f9				ld (spi_device), a 
4d73 cd ba 03				call storage_get_block_0 
4d76 21 eb f9				ld hl, store_page+3 
4d79 cd 1e 1d				call forth_push_str 
4d7c			 
4d7c					 
4d7c			 
4d7c 21 05 00				ld hl, 5 
4d7f cd b0 1c				call forth_push_numhl 
4d82 3e ff				ld a, SPI_CE_HIGH 
4d84 cb a7				res SPI_CE4, a 
4d86 32 ce f9				ld (spi_device), a 
4d89 cd ba 03				call storage_get_block_0 
4d8c 21 eb f9				ld hl, store_page+3 
4d8f cd 1e 1d				call forth_push_str 
4d92			 
4d92					 
4d92					; push fixed count of storage devices (on board) for now 
4d92			 
4d92 21 05 00				ld hl, 5 
4d95 cd b0 1c				call forth_push_numhl 
4d98			 
4d98					; restore selected device  
4d98				 
4d98 f1					pop af 
4d99 32 ce f9				ld (spi_device), a 
4d9c			 
4d9c				       NEXTW 
4d9c c3 19 20			jp macro_next 
4d9f				endm 
# End of macro NEXTW
4d9f			 
4d9f			.ENDSTORAGE: 
4d9f			; eof 
# End of file forth_words_storage.asm
4d9f			endif 
4d9f				include "forth_words_device.asm" 
4d9f			; Device related words 
4d9f			 
4d9f			; | ## Device Words 
4d9f			 
4d9f			if SOUND_ENABLE 
4d9f			.NOTE: 
4d9f				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4d9f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4d9f					if DEBUG_FORTH_WORDS_KEY 
4d9f						DMARK "NTE" 
4d9f						CALLMONITOR 
4d9f					endif 
4d9f			 
4d9f				 
4d9f			 
4d9f					NEXTW 
4d9f			.AFTERSOUND: 
4d9f			endif 
4d9f			 
4d9f			 
4d9f			USE_GPIO: equ 0 
4d9f			 
4d9f			if USE_GPIO 
4d9f			.GP1: 
4d9f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4d9f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4d9f					NEXTW 
4d9f			.GP2: 
4d9f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4d9f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4d9f			 
4d9f					NEXTW 
4d9f			 
4d9f			.GP3: 
4d9f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4d9f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4d9f			 
4d9f					NEXTW 
4d9f			 
4d9f			.GP4: 
4d9f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4d9f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4d9f			 
4d9f					NEXTW 
4d9f			.SIN: 
4d9f			 
4d9f			 
4d9f			endif 
4d9f			 
4d9f			 
4d9f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4d9f 33				db WORD_SYS_CORE+31             
4da0 d4 4d			dw .SOUT            
4da2 03				db 2 + 1 
4da3 .. 00			db "IN",0              
4da6				endm 
# End of macro CWHEAD
4da6			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4da6					if DEBUG_FORTH_WORDS_KEY 
4da6						DMARK "IN." 
4da6 f5				push af  
4da7 3a bb 4d			ld a, (.dmark)  
4daa 32 bd fb			ld (debug_mark),a  
4dad 3a bc 4d			ld a, (.dmark+1)  
4db0 32 be fb			ld (debug_mark+1),a  
4db3 3a bd 4d			ld a, (.dmark+2)  
4db6 32 bf fb			ld (debug_mark+2),a  
4db9 18 03			jr .pastdmark  
4dbb ..			.dmark: db "IN."  
4dbe f1			.pastdmark: pop af  
4dbf			endm  
# End of macro DMARK
4dbf						CALLMONITOR 
4dbf cd 20 17			call break_point_state  
4dc2				endm  
# End of macro CALLMONITOR
4dc2					endif 
4dc2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dc2 cd a7 1e			call macro_dsp_valuehl 
4dc5				endm 
# End of macro FORTH_DSP_VALUEHL
4dc5			 
4dc5 e5					push hl 
4dc6			 
4dc6					; destroy value TOS 
4dc6			 
4dc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dc6 cd 5f 1f			call macro_forth_dsp_pop 
4dc9				endm 
# End of macro FORTH_DSP_POP
4dc9			 
4dc9					; one value on hl get other one back 
4dc9			 
4dc9 c1					pop bc 
4dca			 
4dca					; do the sub 
4dca			;		ex de, hl 
4dca			 
4dca ed 68				in l,(c) 
4dcc			 
4dcc					; save it 
4dcc			 
4dcc 26 00				ld h,0 
4dce			 
4dce					; TODO push value back onto stack for another op etc 
4dce			 
4dce cd b0 1c				call forth_push_numhl 
4dd1					NEXTW 
4dd1 c3 19 20			jp macro_next 
4dd4				endm 
# End of macro NEXTW
4dd4			.SOUT: 
4dd4				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4dd4 34				db WORD_SYS_CORE+32             
4dd5 27 4e			dw .SPIO            
4dd7 04				db 3 + 1 
4dd8 .. 00			db "OUT",0              
4ddc				endm 
# End of macro CWHEAD
4ddc			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ddc					if DEBUG_FORTH_WORDS_KEY 
4ddc						DMARK "OUT" 
4ddc f5				push af  
4ddd 3a f1 4d			ld a, (.dmark)  
4de0 32 bd fb			ld (debug_mark),a  
4de3 3a f2 4d			ld a, (.dmark+1)  
4de6 32 be fb			ld (debug_mark+1),a  
4de9 3a f3 4d			ld a, (.dmark+2)  
4dec 32 bf fb			ld (debug_mark+2),a  
4def 18 03			jr .pastdmark  
4df1 ..			.dmark: db "OUT"  
4df4 f1			.pastdmark: pop af  
4df5			endm  
# End of macro DMARK
4df5						CALLMONITOR 
4df5 cd 20 17			call break_point_state  
4df8				endm  
# End of macro CALLMONITOR
4df8					endif 
4df8			 
4df8					; get port 
4df8			 
4df8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4df8 cd a7 1e			call macro_dsp_valuehl 
4dfb				endm 
# End of macro FORTH_DSP_VALUEHL
4dfb			 
4dfb e5					push hl 
4dfc			 
4dfc					; destroy value TOS 
4dfc			 
4dfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dfc cd 5f 1f			call macro_forth_dsp_pop 
4dff				endm 
# End of macro FORTH_DSP_POP
4dff			 
4dff					; get byte to send 
4dff			 
4dff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dff cd a7 1e			call macro_dsp_valuehl 
4e02				endm 
# End of macro FORTH_DSP_VALUEHL
4e02			 
4e02			;		push hl 
4e02			 
4e02					; destroy value TOS 
4e02			 
4e02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e02 cd 5f 1f			call macro_forth_dsp_pop 
4e05				endm 
# End of macro FORTH_DSP_POP
4e05			 
4e05					; one value on hl get other one back 
4e05			 
4e05			;		pop hl 
4e05			 
4e05 c1					pop bc 
4e06			 
4e06					if DEBUG_FORTH_WORDS 
4e06						DMARK "OUT" 
4e06 f5				push af  
4e07 3a 1b 4e			ld a, (.dmark)  
4e0a 32 bd fb			ld (debug_mark),a  
4e0d 3a 1c 4e			ld a, (.dmark+1)  
4e10 32 be fb			ld (debug_mark+1),a  
4e13 3a 1d 4e			ld a, (.dmark+2)  
4e16 32 bf fb			ld (debug_mark+2),a  
4e19 18 03			jr .pastdmark  
4e1b ..			.dmark: db "OUT"  
4e1e f1			.pastdmark: pop af  
4e1f			endm  
# End of macro DMARK
4e1f						CALLMONITOR 
4e1f cd 20 17			call break_point_state  
4e22				endm  
# End of macro CALLMONITOR
4e22					endif 
4e22			 
4e22 ed 69				out (c), l 
4e24			 
4e24					NEXTW 
4e24 c3 19 20			jp macro_next 
4e27				endm 
# End of macro NEXTW
4e27			 
4e27			 
4e27			.SPIO: 
4e27			 
4e27			if STORAGE_SE 
4e27				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4e27 51				db WORD_SYS_CORE+61             
4e28 38 4e			dw .SPICEH            
4e2a 07				db 6 + 1 
4e2b .. 00			db "SPICEL",0              
4e32				endm 
# End of macro CWHEAD
4e32			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4e32			 
4e32 cd 95 01				call spi_ce_low 
4e35			    NEXTW 
4e35 c3 19 20			jp macro_next 
4e38				endm 
# End of macro NEXTW
4e38			 
4e38			.SPICEH: 
4e38				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4e38 51				db WORD_SYS_CORE+61             
4e39 49 4e			dw .SPIOb            
4e3b 07				db 6 + 1 
4e3c .. 00			db "SPICEH",0              
4e43				endm 
# End of macro CWHEAD
4e43			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4e43			 
4e43 cd 84 01				call spi_ce_high 
4e46			    NEXTW 
4e46 c3 19 20			jp macro_next 
4e49				endm 
# End of macro NEXTW
4e49			 
4e49			 
4e49			.SPIOb: 
4e49			 
4e49				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4e49 51				db WORD_SYS_CORE+61             
4e4a 5f 4e			dw .SPII            
4e4c 05				db 4 + 1 
4e4d .. 00			db "SPIO",0              
4e52				endm 
# End of macro CWHEAD
4e52			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4e52			 
4e52					; get port 
4e52			 
4e52			 
4e52					; get byte to send 
4e52			 
4e52					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e52 cd a7 1e			call macro_dsp_valuehl 
4e55				endm 
# End of macro FORTH_DSP_VALUEHL
4e55			 
4e55			;		push hl    ; u1  
4e55			 
4e55					; destroy value TOS 
4e55			 
4e55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e55 cd 5f 1f			call macro_forth_dsp_pop 
4e58				endm 
# End of macro FORTH_DSP_POP
4e58			 
4e58					; one value on hl get other one back 
4e58			 
4e58			;		pop hl   ; u2 - addr 
4e58			 
4e58					; TODO Send SPI byte 
4e58			 
4e58 7d					ld a, l 
4e59 cd b9 00				call spi_send_byte 
4e5c			 
4e5c					NEXTW 
4e5c c3 19 20			jp macro_next 
4e5f				endm 
# End of macro NEXTW
4e5f			 
4e5f			.SPII: 
4e5f				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4e5f 52				db WORD_SYS_CORE+62             
4e60 74 4e			dw .SESEL            
4e62 06				db 5 + 1 
4e63 .. 00			db "SPII",0              
4e68				endm 
# End of macro CWHEAD
4e68			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4e68			 
4e68					; TODO Get SPI byte 
4e68			 
4e68 cd da 00				call spi_read_byte 
4e6b			 
4e6b 26 00				ld h, 0 
4e6d 6f					ld l, a 
4e6e cd b0 1c				call forth_push_numhl 
4e71			 
4e71					NEXTW 
4e71 c3 19 20			jp macro_next 
4e74				endm 
# End of macro NEXTW
4e74			 
4e74			 
4e74			 
4e74			.SESEL: 
4e74				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4e74 66				db WORD_SYS_CORE+82             
4e75 18 4f			dw .CARTDEV            
4e77 05				db 4 + 1 
4e78 .. 00			db "BANK",0              
4e7d				endm 
# End of macro CWHEAD
4e7d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4e7d					if DEBUG_FORTH_WORDS_KEY 
4e7d						DMARK "BNK" 
4e7d f5				push af  
4e7e 3a 92 4e			ld a, (.dmark)  
4e81 32 bd fb			ld (debug_mark),a  
4e84 3a 93 4e			ld a, (.dmark+1)  
4e87 32 be fb			ld (debug_mark+1),a  
4e8a 3a 94 4e			ld a, (.dmark+2)  
4e8d 32 bf fb			ld (debug_mark+2),a  
4e90 18 03			jr .pastdmark  
4e92 ..			.dmark: db "BNK"  
4e95 f1			.pastdmark: pop af  
4e96			endm  
# End of macro DMARK
4e96						CALLMONITOR 
4e96 cd 20 17			call break_point_state  
4e99				endm  
# End of macro CALLMONITOR
4e99					endif 
4e99			 
4e99 3e ff				ld a, 255 
4e9b 32 d1 f9				ld (spi_cartdev), a 
4e9e			 
4e9e					; get bank 
4e9e			 
4e9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e9e cd a7 1e			call macro_dsp_valuehl 
4ea1				endm 
# End of macro FORTH_DSP_VALUEHL
4ea1			 
4ea1			;		push hl 
4ea1			 
4ea1					; destroy value TOS 
4ea1			 
4ea1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ea1 cd 5f 1f			call macro_forth_dsp_pop 
4ea4				endm 
# End of macro FORTH_DSP_POP
4ea4			 
4ea4					; one value on hl get other one back 
4ea4			 
4ea4			;		pop hl 
4ea4			 
4ea4			 
4ea4 0e ff				ld c, SPI_CE_HIGH 
4ea6 06 30				ld b, '0'    ; human readable bank number 
4ea8			 
4ea8 7d					ld a, l 
4ea9			 
4ea9					if DEBUG_FORTH_WORDS 
4ea9						DMARK "BNK" 
4ea9 f5				push af  
4eaa 3a be 4e			ld a, (.dmark)  
4ead 32 bd fb			ld (debug_mark),a  
4eb0 3a bf 4e			ld a, (.dmark+1)  
4eb3 32 be fb			ld (debug_mark+1),a  
4eb6 3a c0 4e			ld a, (.dmark+2)  
4eb9 32 bf fb			ld (debug_mark+2),a  
4ebc 18 03			jr .pastdmark  
4ebe ..			.dmark: db "BNK"  
4ec1 f1			.pastdmark: pop af  
4ec2			endm  
# End of macro DMARK
4ec2						CALLMONITOR 
4ec2 cd 20 17			call break_point_state  
4ec5				endm  
# End of macro CALLMONITOR
4ec5					endif 
4ec5			 
4ec5					; active low 
4ec5			 
4ec5 fe 00				cp 0 
4ec7 28 28				jr z, .bset 
4ec9 fe 01				cp 1 
4ecb 20 04				jr nz, .b2 
4ecd cb 81				res 0, c 
4ecf 06 31				ld b, '1'    ; human readable bank number 
4ed1 fe 02		.b2:		cp 2 
4ed3 20 04				jr nz, .b3 
4ed5 cb 89				res 1, c 
4ed7 06 32				ld b, '2'    ; human readable bank number 
4ed9 fe 03		.b3:		cp 3 
4edb 20 04				jr nz, .b4 
4edd cb 91				res 2, c 
4edf 06 33				ld b, '3'    ; human readable bank number 
4ee1 fe 04		.b4:		cp 4 
4ee3 20 04				jr nz, .b5 
4ee5 cb 99				res 3, c 
4ee7 06 34				ld b, '4'    ; human readable bank number 
4ee9 fe 05		.b5:		cp 5 
4eeb 20 04				jr nz, .bset 
4eed cb a1				res 4, c 
4eef 06 35				ld b, '5'    ; human readable bank number 
4ef1			 
4ef1			.bset: 
4ef1 79					ld a, c 
4ef2 32 ce f9				ld (spi_device),a 
4ef5 78					ld a, b 
4ef6 32 cd f9				ld (spi_device_id),a 
4ef9					if DEBUG_FORTH_WORDS 
4ef9						DMARK "BN2" 
4ef9 f5				push af  
4efa 3a 0e 4f			ld a, (.dmark)  
4efd 32 bd fb			ld (debug_mark),a  
4f00 3a 0f 4f			ld a, (.dmark+1)  
4f03 32 be fb			ld (debug_mark+1),a  
4f06 3a 10 4f			ld a, (.dmark+2)  
4f09 32 bf fb			ld (debug_mark+2),a  
4f0c 18 03			jr .pastdmark  
4f0e ..			.dmark: db "BN2"  
4f11 f1			.pastdmark: pop af  
4f12			endm  
# End of macro DMARK
4f12						CALLMONITOR 
4f12 cd 20 17			call break_point_state  
4f15				endm  
# End of macro CALLMONITOR
4f15					endif 
4f15			 
4f15					NEXTW 
4f15 c3 19 20			jp macro_next 
4f18				endm 
# End of macro NEXTW
4f18			 
4f18			.CARTDEV: 
4f18				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4f18 66				db WORD_SYS_CORE+82             
4f19 c1 4f			dw .ENDDEVICE            
4f1b 08				db 7 + 1 
4f1c .. 00			db "CARTDEV",0              
4f24				endm 
# End of macro CWHEAD
4f24			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4f24					if DEBUG_FORTH_WORDS_KEY 
4f24						DMARK "CDV" 
4f24 f5				push af  
4f25 3a 39 4f			ld a, (.dmark)  
4f28 32 bd fb			ld (debug_mark),a  
4f2b 3a 3a 4f			ld a, (.dmark+1)  
4f2e 32 be fb			ld (debug_mark+1),a  
4f31 3a 3b 4f			ld a, (.dmark+2)  
4f34 32 bf fb			ld (debug_mark+2),a  
4f37 18 03			jr .pastdmark  
4f39 ..			.dmark: db "CDV"  
4f3c f1			.pastdmark: pop af  
4f3d			endm  
# End of macro DMARK
4f3d						CALLMONITOR 
4f3d cd 20 17			call break_point_state  
4f40				endm  
# End of macro CALLMONITOR
4f40					endif 
4f40			 
4f40					; disable se storage bank selection 
4f40			 
4f40 3e ff				ld a, SPI_CE_HIGH		; ce high 
4f42 32 ce f9				ld (spi_device), a 
4f45			 
4f45					; get bank 
4f45			 
4f45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f45 cd a7 1e			call macro_dsp_valuehl 
4f48				endm 
# End of macro FORTH_DSP_VALUEHL
4f48			 
4f48			;		push hl 
4f48			 
4f48					; destroy value TOS 
4f48			 
4f48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f48 cd 5f 1f			call macro_forth_dsp_pop 
4f4b				endm 
# End of macro FORTH_DSP_POP
4f4b			 
4f4b					; one value on hl get other one back 
4f4b			 
4f4b			;		pop hl 
4f4b			 
4f4b					; active low 
4f4b			 
4f4b 0e ff				ld c, 255 
4f4d			 
4f4d 7d					ld a, l 
4f4e					if DEBUG_FORTH_WORDS 
4f4e						DMARK "CDV" 
4f4e f5				push af  
4f4f 3a 63 4f			ld a, (.dmark)  
4f52 32 bd fb			ld (debug_mark),a  
4f55 3a 64 4f			ld a, (.dmark+1)  
4f58 32 be fb			ld (debug_mark+1),a  
4f5b 3a 65 4f			ld a, (.dmark+2)  
4f5e 32 bf fb			ld (debug_mark+2),a  
4f61 18 03			jr .pastdmark  
4f63 ..			.dmark: db "CDV"  
4f66 f1			.pastdmark: pop af  
4f67			endm  
# End of macro DMARK
4f67						CALLMONITOR 
4f67 cd 20 17			call break_point_state  
4f6a				endm  
# End of macro CALLMONITOR
4f6a					endif 
4f6a fe 00				cp 0 
4f6c 28 30				jr z, .cset 
4f6e fe 01				cp 1 
4f70 20 02				jr nz, .c2 
4f72 cb 81				res 0, c 
4f74 fe 02		.c2:		cp 2 
4f76 20 02				jr nz, .c3 
4f78 cb 89				res 1, c 
4f7a fe 03		.c3:		cp 3 
4f7c 20 02				jr nz, .c4 
4f7e cb 91				res 2, c 
4f80 fe 04		.c4:		cp 4 
4f82 20 02				jr nz, .c5 
4f84 cb 99				res 3, c 
4f86 fe 05		.c5:		cp 5 
4f88 20 02				jr nz, .c6 
4f8a cb a1				res 4, c 
4f8c fe 06		.c6:		cp 6 
4f8e 20 02				jr nz, .c7 
4f90 cb a9				res 5, c 
4f92 fe 07		.c7:		cp 7 
4f94 20 02				jr nz, .c8 
4f96 cb b1				res 6, c 
4f98 fe 08		.c8:		cp 8 
4f9a 20 02				jr nz, .cset 
4f9c cb b9				res 7, c 
4f9e 79			.cset:		ld a, c 
4f9f 32 d1 f9				ld (spi_cartdev),a 
4fa2			 
4fa2					if DEBUG_FORTH_WORDS 
4fa2						DMARK "CD2" 
4fa2 f5				push af  
4fa3 3a b7 4f			ld a, (.dmark)  
4fa6 32 bd fb			ld (debug_mark),a  
4fa9 3a b8 4f			ld a, (.dmark+1)  
4fac 32 be fb			ld (debug_mark+1),a  
4faf 3a b9 4f			ld a, (.dmark+2)  
4fb2 32 bf fb			ld (debug_mark+2),a  
4fb5 18 03			jr .pastdmark  
4fb7 ..			.dmark: db "CD2"  
4fba f1			.pastdmark: pop af  
4fbb			endm  
# End of macro DMARK
4fbb						CALLMONITOR 
4fbb cd 20 17			call break_point_state  
4fbe				endm  
# End of macro CALLMONITOR
4fbe					endif 
4fbe					NEXTW 
4fbe c3 19 20			jp macro_next 
4fc1				endm 
# End of macro NEXTW
4fc1			endif 
4fc1			 
4fc1			.ENDDEVICE: 
4fc1			; eof 
4fc1			 
# End of file forth_words_device.asm
4fc1			 
4fc1			; var handler 
4fc1			 
4fc1			 
4fc1			.VARS: 
4fc1				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4fc1 78				db WORD_SYS_CORE+100             
4fc2 d9 4f			dw .V0Q            
4fc4 04				db 3 + 1 
4fc5 .. 00			db "V0!",0              
4fc9				endm 
# End of macro CWHEAD
4fc9			;| V0! ( u1 -- )  Store value to v0  | DONE 
4fc9			 
4fc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fc9 cd a7 1e			call macro_dsp_valuehl 
4fcc				endm 
# End of macro FORTH_DSP_VALUEHL
4fcc			 
4fcc 11 96 f9				ld de, cli_var_array 
4fcf			 
4fcf eb					ex de, hl 
4fd0 73					ld (hl), e 
4fd1 23					inc hl 
4fd2 72					ld (hl), d 
4fd3			 
4fd3					; destroy value TOS 
4fd3			 
4fd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fd3 cd 5f 1f			call macro_forth_dsp_pop 
4fd6				endm 
# End of macro FORTH_DSP_POP
4fd6			 
4fd6				       NEXTW 
4fd6 c3 19 20			jp macro_next 
4fd9				endm 
# End of macro NEXTW
4fd9			.V0Q: 
4fd9				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4fd9 79				db WORD_SYS_CORE+101             
4fda ea 4f			dw .V1S            
4fdc 04				db 3 + 1 
4fdd .. 00			db "V0@",0              
4fe1				endm 
# End of macro CWHEAD
4fe1			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4fe1 2a 96 f9				ld hl, (cli_var_array) 
4fe4 cd b0 1c				call forth_push_numhl 
4fe7			 
4fe7				       NEXTW 
4fe7 c3 19 20			jp macro_next 
4fea				endm 
# End of macro NEXTW
4fea			.V1S: 
4fea				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4fea 7a				db WORD_SYS_CORE+102             
4feb 02 50			dw .V1Q            
4fed 04				db 3 + 1 
4fee .. 00			db "V1!",0              
4ff2				endm 
# End of macro CWHEAD
4ff2			;| V1! ( u1 -- )  Store value to v1 | DONE 
4ff2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ff2 cd a7 1e			call macro_dsp_valuehl 
4ff5				endm 
# End of macro FORTH_DSP_VALUEHL
4ff5			 
4ff5 11 98 f9				ld de, cli_var_array+2 
4ff8				 
4ff8 eb					ex de, hl 
4ff9 73					ld (hl), e 
4ffa 23					inc hl 
4ffb 72					ld (hl), d 
4ffc			 
4ffc					; destroy value TOS 
4ffc			 
4ffc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ffc cd 5f 1f			call macro_forth_dsp_pop 
4fff				endm 
# End of macro FORTH_DSP_POP
4fff				       NEXTW 
4fff c3 19 20			jp macro_next 
5002				endm 
# End of macro NEXTW
5002			.V1Q: 
5002				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5002 7b				db WORD_SYS_CORE+103             
5003 13 50			dw .V2S            
5005 04				db 3 + 1 
5006 .. 00			db "V1@",0              
500a				endm 
# End of macro CWHEAD
500a			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
500a 2a 98 f9				ld hl, (cli_var_array+2) 
500d cd b0 1c				call forth_push_numhl 
5010				       NEXTW 
5010 c3 19 20			jp macro_next 
5013				endm 
# End of macro NEXTW
5013			.V2S: 
5013				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5013 7c				db WORD_SYS_CORE+104             
5014 2b 50			dw .V2Q            
5016 04				db 3 + 1 
5017 .. 00			db "V2!",0              
501b				endm 
# End of macro CWHEAD
501b			;| V2! ( u1 -- )  Store value to v2 | DONE 
501b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
501b cd a7 1e			call macro_dsp_valuehl 
501e				endm 
# End of macro FORTH_DSP_VALUEHL
501e			 
501e 11 9a f9				ld de, cli_var_array+4 
5021				 
5021 eb					ex de, hl 
5022 73					ld (hl), e 
5023 23					inc hl 
5024 72					ld (hl), d 
5025			 
5025					; destroy value TOS 
5025			 
5025					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5025 cd 5f 1f			call macro_forth_dsp_pop 
5028				endm 
# End of macro FORTH_DSP_POP
5028				       NEXTW 
5028 c3 19 20			jp macro_next 
502b				endm 
# End of macro NEXTW
502b			.V2Q: 
502b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
502b 7d				db WORD_SYS_CORE+105             
502c 3c 50			dw .V3S            
502e 04				db 3 + 1 
502f .. 00			db "V2@",0              
5033				endm 
# End of macro CWHEAD
5033			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5033 2a 9a f9				ld hl, (cli_var_array+4) 
5036 cd b0 1c				call forth_push_numhl 
5039				       NEXTW 
5039 c3 19 20			jp macro_next 
503c				endm 
# End of macro NEXTW
503c			.V3S: 
503c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
503c 7c				db WORD_SYS_CORE+104             
503d 54 50			dw .V3Q            
503f 04				db 3 + 1 
5040 .. 00			db "V3!",0              
5044				endm 
# End of macro CWHEAD
5044			;| V3! ( u1 -- )  Store value to v3 | DONE 
5044					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5044 cd a7 1e			call macro_dsp_valuehl 
5047				endm 
# End of macro FORTH_DSP_VALUEHL
5047			 
5047 11 9c f9				ld de, cli_var_array+6 
504a				 
504a eb					ex de, hl 
504b 73					ld (hl), e 
504c 23					inc hl 
504d 72					ld (hl), d 
504e			 
504e					; destroy value TOS 
504e			 
504e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
504e cd 5f 1f			call macro_forth_dsp_pop 
5051				endm 
# End of macro FORTH_DSP_POP
5051				       NEXTW 
5051 c3 19 20			jp macro_next 
5054				endm 
# End of macro NEXTW
5054			.V3Q: 
5054				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5054 7d				db WORD_SYS_CORE+105             
5055 65 50			dw .END            
5057 04				db 3 + 1 
5058 .. 00			db "V3@",0              
505c				endm 
# End of macro CWHEAD
505c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
505c 2a 9c f9				ld hl, (cli_var_array+6) 
505f cd b0 1c				call forth_push_numhl 
5062				       NEXTW 
5062 c3 19 20			jp macro_next 
5065				endm 
# End of macro NEXTW
5065			 
5065			 
5065			 
5065			 
5065			 
5065			; end of dict marker 
5065			 
5065 00			.END:    db WORD_SYS_END 
5066 00 00			dw 0 
5068 00				db 0 
5069			 
5069			; use to jp here for user dict words to save on macro expansion  
5069			 
5069			user_dict_next: 
5069				NEXTW 
5069 c3 19 20			jp macro_next 
506c				endm 
# End of macro NEXTW
506c			 
506c			 
506c			user_exec: 
506c				;    ld hl, <word code> 
506c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
506c				;    call forthexec 
506c				;    jp user_dict_next   (NEXT) 
506c			        ;    <word code bytes> 
506c eb				ex de, hl 
506d 2a a4 f2			ld hl,(os_tok_ptr) 
5070				 
5070				FORTH_RSP_NEXT 
5070 cd 57 1c			call macro_forth_rsp_next 
5073				endm 
# End of macro FORTH_RSP_NEXT
5073			 
5073			if DEBUG_FORTH_UWORD 
5073						DMARK "UEX" 
5073 f5				push af  
5074 3a 88 50			ld a, (.dmark)  
5077 32 bd fb			ld (debug_mark),a  
507a 3a 89 50			ld a, (.dmark+1)  
507d 32 be fb			ld (debug_mark+1),a  
5080 3a 8a 50			ld a, (.dmark+2)  
5083 32 bf fb			ld (debug_mark+2),a  
5086 18 03			jr .pastdmark  
5088 ..			.dmark: db "UEX"  
508b f1			.pastdmark: pop af  
508c			endm  
# End of macro DMARK
508c				CALLMONITOR 
508c cd 20 17			call break_point_state  
508f				endm  
# End of macro CALLMONITOR
508f			endif 
508f			 
508f			 
508f			 
508f eb				ex de, hl 
5090 22 a4 f2			ld (os_tok_ptr), hl 
5093				 
5093				; Don't use next - Skips the first word in uword. 
5093			 
5093 c3 aa 20			jp exec1 
5096			;	NEXT 
5096			 
5096			 
5096			; eof 
# End of file forth_wordsv4.asm
5096			endif 
5096			;;;;;;;;;;;;;; Debug code 
5096			 
5096			 
5096			;if DEBUG_FORTH_PARSE 
5096 .. 00		.nowordfound: db "No match",0 
509f .. 00		.compword:	db "Comparing word ",0 
50af .. 00		.nextwordat:	db "Next word at",0 
50bc .. 00		.charmatch:	db "Char match",0 
50c7			;endif 
50c7			if DEBUG_FORTH_JP 
50c7			.foundword:	db "Word match. Exec..",0 
50c7			endif 
50c7			;if DEBUG_FORTH_PUSH 
50c7 .. 00		.enddict:	db "Dict end. Push.",0 
50d7 .. 00		.push_str:	db "Pushing string",0 
50e6 .. 00		.push_num:	db "Pushing number",0 
50f5 .. 00		.data_sp:	db "SP:",0 
50f9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
510b .. 00		.wordinde:	db "Word in DE (3/0):",0 
511d .. 00		.wordinbc:	db "Word in BC (4/0):",0 
512f			;endif 
512f			;if DEBUG_FORTH_MALLOC 
512f .. 00		.push_malloc:	db "Malloc address",0 
513e			;endif 
513e			 
513e			 
513e			 
513e			; display malloc address and current data stack pointer  
513e			 
513e			malloc_error: 
513e d5				push de 
513f f5				push af 
5140 e5				push hl 
5141 cd d2 0a			call clear_display 
5144 11 66 51			ld de, .mallocerr 
5147 3e 00			ld a,0 
5149			;	ld de,os_word_scratch 
5149 cd e5 0a			call str_at_display 
514c 3e 11			ld a, display_row_1+17 
514e 11 bd fb			ld de, debug_mark 
5151 cd e5 0a			call str_at_display 
5154 cd f5 0a			call update_display 
5157				;call break_point_state 
5157 cd bd 66			call cin_wait 
515a			 
515a 3e 20			ld a, ' ' 
515c 32 94 ef			ld (os_view_disable), a 
515f e1				pop hl 
5160 f1				pop af 
5161 d1				pop de	 
5162				CALLMONITOR 
5162 cd 20 17			call break_point_state  
5165				endm  
# End of macro CALLMONITOR
5165 c9				ret 
5166			 
5166 .. 00		.mallocerr: 	db "Malloc Error",0 
5173			;if DEBUG_FORTH_PUSH 
5173			display_data_sp: 
5173 f5				push af 
5174			 
5174				; see if disabled 
5174			 
5174 3a 94 ef			ld a, (os_view_disable) 
5177 fe 2a			cp '*' 
5179 28 67			jr z, .skipdsp 
517b			 
517b e5				push hl 
517c e5				push hl 
517d e5			push hl 
517e cd d2 0a			call clear_display 
5181 e1			pop hl 
5182 7c				ld a,h 
5183 21 a8 f2			ld hl, os_word_scratch 
5186 cd 07 10			call hexout 
5189 e1				pop hl 
518a 7d				ld a,l 
518b 21 aa f2			ld hl, os_word_scratch+2 
518e cd 07 10			call hexout 
5191 21 ac f2			ld hl, os_word_scratch+4 
5194 3e 00			ld a,0 
5196 77				ld (hl),a 
5197 11 a8 f2			ld de,os_word_scratch 
519a 3e 14				ld a, display_row_2 
519c cd e5 0a				call str_at_display 
519f 11 f9 50			ld de, .wordinhl 
51a2 3e 00			ld a, display_row_1 
51a4			 
51a4 cd e5 0a				call str_at_display 
51a7 11 bd fb			ld de, debug_mark 
51aa 3e 11			ld a, display_row_1+17 
51ac			 
51ac cd e5 0a				call str_at_display 
51af			 
51af				; display current data stack pointer 
51af 11 f5 50			ld de,.data_sp 
51b2 3e 1c				ld a, display_row_2 + 8 
51b4 cd e5 0a				call str_at_display 
51b7			 
51b7 2a 90 f9			ld hl,(cli_data_sp) 
51ba e5				push hl 
51bb 7c				ld a,h 
51bc 21 a8 f2			ld hl, os_word_scratch 
51bf cd 07 10			call hexout 
51c2 e1				pop hl 
51c3 7d				ld a,l 
51c4 21 aa f2			ld hl, os_word_scratch+2 
51c7 cd 07 10			call hexout 
51ca 21 ac f2			ld hl, os_word_scratch+4 
51cd 3e 00			ld a,0 
51cf 77				ld (hl),a 
51d0 11 a8 f2			ld de,os_word_scratch 
51d3 3e 1f				ld a, display_row_2 + 11 
51d5 cd e5 0a				call str_at_display 
51d8			 
51d8			 
51d8 cd f5 0a			call update_display 
51db cd 52 0a			call delay1s 
51de cd 52 0a			call delay1s 
51e1 e1				pop hl 
51e2			.skipdsp: 
51e2 f1				pop af 
51e3 c9				ret 
51e4			 
51e4			display_data_malloc: 
51e4			 
51e4 f5				push af 
51e5 e5				push hl 
51e6 e5				push hl 
51e7 e5			push hl 
51e8 cd d2 0a			call clear_display 
51eb e1			pop hl 
51ec 7c				ld a,h 
51ed 21 a8 f2			ld hl, os_word_scratch 
51f0 cd 07 10			call hexout 
51f3 e1				pop hl 
51f4 7d				ld a,l 
51f5 21 aa f2			ld hl, os_word_scratch+2 
51f8 cd 07 10			call hexout 
51fb 21 ac f2			ld hl, os_word_scratch+4 
51fe 3e 00			ld a,0 
5200 77				ld (hl),a 
5201 11 a8 f2			ld de,os_word_scratch 
5204 3e 14				ld a, display_row_2 
5206 cd e5 0a				call str_at_display 
5209 11 2f 51			ld de, .push_malloc 
520c 3e 00			ld a, display_row_1 
520e			 
520e cd e5 0a				call str_at_display 
5211			 
5211				; display current data stack pointer 
5211 11 f5 50			ld de,.data_sp 
5214 3e 1c				ld a, display_row_2 + 8 
5216 cd e5 0a				call str_at_display 
5219			 
5219 2a 90 f9			ld hl,(cli_data_sp) 
521c e5				push hl 
521d 7c				ld a,h 
521e 21 a8 f2			ld hl, os_word_scratch 
5221 cd 07 10			call hexout 
5224 e1				pop hl 
5225 7d				ld a,l 
5226 21 aa f2			ld hl, os_word_scratch+2 
5229 cd 07 10			call hexout 
522c 21 ac f2			ld hl, os_word_scratch+4 
522f 3e 00			ld a,0 
5231 77				ld (hl),a 
5232 11 a8 f2			ld de,os_word_scratch 
5235 3e 1f				ld a, display_row_2 + 11 
5237 cd e5 0a				call str_at_display 
523a			 
523a cd f5 0a			call update_display 
523d cd 52 0a			call delay1s 
5240 cd 52 0a			call delay1s 
5243 e1				pop hl 
5244 f1				pop af 
5245 c9				ret 
5246			;endif 
5246			 
5246			include "forth_autostart.asm" 
5246			; list of commands to perform at system start up 
5246			 
5246			startcmds: 
5246			;	dw test11 
5246			;	dw test12 
5246			;	dw test13 
5246			;	dw test14 
5246			;	dw test15 
5246			;	dw test16 
5246			;	dw test17 
5246			;	dw ifthtest1 
5246			;	dw ifthtest2 
5246			;	dw ifthtest3 
5246			;	dw mmtest1 
5246			;	dw mmtest2 
5246			;	dw mmtest3 
5246			;	dw mmtest4 
5246			;	dw mmtest5 
5246			;	dw mmtest6 
5246			;	dw iftest1 
5246			;	dw iftest2 
5246			;	dw iftest3 
5246			;	dw looptest1 
5246			;	dw looptest2 
5246			;	dw test1 
5246			;	dw test2 
5246			;	dw test3 
5246			;	dw test4 
5246			;	dw game2r 
5246			;	dw game2b1 
5246			;	dw game2b2 
5246			 
5246				; start up words that are actually useful 
5246			 
5246 a4 52			dw clrstack 
5248 d7 52			dw type 
524a 98 54			dw stest 
524c fb 52			dw strncpy 
524e 39 54			dw list 
5250 5c 53			dw start1 
5252 6e 53			dw start2 
5254			;	dw start3 
5254 81 53			dw start3b 
5256 d9 53			dw start3c 
5258			 
5258				; (unit) testing words 
5258			 
5258 0f 55			dw mtesta 
525a c4 55			dw mtestb 
525c 67 56			dw mtestc 
525e 1c 57			dw mtestd 
5260 c0 57			dw mteste 
5262			 
5262				; demo/game words 
5262			 
5262 cc 5e		        dw game3w 
5264 fa 5e		        dw game3p 
5266 18 5f		        dw game3sc 
5268 49 5f		        dw game3vsi 
526a 75 5f		        dw game3vs 
526c				 
526c bf 5c			dw game2b 
526e 2d 5d			dw game2bf 
5270 77 5d			dw game2mba 
5272 0d 5e			dw game2mbas 
5274 4f 5e			dw game2mb 
5276			 
5276 80 59			dw game1 
5278 91 59			dw game1a 
527a f3 59			dw game1b 
527c 28 5a			dw game1c 
527e 5e 5a			dw game1d 
5280 8f 5a			dw game1s 
5282 a3 5a			dw game1t 
5284 b8 5a			dw game1f 
5286 ec 5a			dw game1z 
5288 30 5b			dw game1zz 
528a			 
528a 76 58			dw test5 
528c ae 58			dw test6 
528e e6 58			dw test7 
5290 fa 58			dw test8 
5292 26 59			dw test9 
5294 3c 59			dw test10 
5296				 
5296 07 5c		        dw ssv5 
5298 eb 5b		        dw ssv4 
529a cf 5b		        dw ssv3 
529c 99 5b		        dw ssv2 
529e 20 5c		        dw ssv1 
52a0 68 5c		        dw ssv1cpm 
52a2			;	dw keyup 
52a2			;	dw keydown 
52a2			;	dw keyleft 
52a2			;	dw keyright 
52a2			;	dw 	keyf1 
52a2			;	dw keyf2 
52a2			;	dw keyf3 
52a2			;	dw keyf4 
52a2			;	dw keyf5 
52a2			;	dw keyf6 
52a2			;	dw keyf7 
52a2			;	dw keyf8 
52a2			;	dw keyf9 
52a2			;	dw keyf10 
52a2			;	dw keyf11 
52a2			;	dw keyf12 
52a2			;	dw keytab 
52a2			;	dw keycr 
52a2			;	dw keyhome 
52a2			;	dw keyend 
52a2			;	dw keybs 
52a2 00 00			db 0, 0	 
52a4			 
52a4			 
52a4			; clear stack  
52a4			 
52a4 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
52d7			 
52d7			; type ( addr count - ) 
52d7 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
52fb			 
52fb			; some direct memory words 
52fb			; strncpy ( len t f -- t ) 
52fb			 
52fb .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
535c			 
535c .. 00		start1:     	db ": bpon $0000 bp ;",0 
536e .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5381			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5381 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
53d9 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5439			 
5439			 
5439			; a handy word to list items on the stack 
5439			 
5439 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5498			 
5498			 
5498			; test stack  
5498			; rnd8 stest 
5498			 
5498 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
550f			 
550f			; random malloc and free cycles 
550f			 
550f .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55c4			 
55c4			; fixed malloc and free cycles 
55c4			 
55c4 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5667			 
5667			; fixed double string push and drop cycle  
5667			 
5667 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
571c			 
571c			; consistent fixed string push and drop cycle  
571c			 
571c .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57c0			 
57c0 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5876			 
5876			;test1:		db ": aa 1 2 3 ;", 0 
5876			;test2:     	db "111 aa 888 999",0 
5876			;test3:     	db ": bb 77 ;",0 
5876			;test4:     	db "$02 $01 do i . loop bb",0 
5876			 
5876 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
58ae .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58e6 .. 00		test7:     	db ": box hline vline ;",0 
58fa .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5926 .. 00		test9:     	db ": sw $01 adsp world ;",0 
593c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5961 .. 00		test11:     	db "hello create .",0 
5970 .. 00		test12:     	db "hello2 create .",0 
5980			 
5980			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5980			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5980			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5980			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5980			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5980			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5980			 
5980			;iftest1:     	db "$0001 IF cls .",0 
5980			;iftest2:     	db "$0000 IF cls .",0 
5980			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5980			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5980			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5980			 
5980			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5980			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5980			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5980			 
5980			 
5980			 
5980			; a small guess the number game 
5980			 
5980 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5991 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
59f3			 
59f3 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a28 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5a5e .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5a8f .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5aa3 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5ab8 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5aec .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b30			 
5b30			; Using 'ga' save a high score across multiple runs using external storage 
5b30			 
5b30 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5b99			 
5b99			 
5b99			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5b99			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b99			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b99			 
5b99			; simple screen saver to test code memory reuse to destruction 
5b99			 
5b99 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5bcf .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5beb .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c07 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c20 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c68 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5cbf			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cbf			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5cbf			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5cbf			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5cbf			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5cbf			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5cbf			 
5cbf			 
5cbf			 
5cbf			; minesweeper/battleship finding game 
5cbf			; draws a game board of random ship/mine positions 
5cbf			; user enters coords to see if it hits on 
5cbf			; game ends when all are hit 
5cbf			; when hit or miss says how many may be in the area 
5cbf			 
5cbf			; setup the game board and then hide it 
5cbf .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d2d .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5d77			; prompt for where to target 
5d77 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e0d .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e32			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e32 .. 00		game2mbht:      db ": mbckht nop ;",0 
5e41 .. 00		game2mbms:      db ": mbcms nop ;",0 
5e4f			; TODO how many might be near by 
5e4f .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ecc			 
5ecc			; Game 3 
5ecc			 
5ecc			; Vert scroller ski game - avoid the trees! 
5ecc			 
5ecc			; v0 score (ie turns) 
5ecc			; v1 player pos 
5ecc			; v2 left wall 
5ecc			; v3 right wall 
5ecc			 
5ecc			; Draw side walls randomly 
5ecc			 
5ecc .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5efa			 
5efa			; Draw player 
5efa .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f18			 
5f18			; TODO Get Key 
5f18			 
5f18			; TODO Move left right 
5f18			 
5f18			; scroll and move walls a bit 
5f18			 
5f18 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f49			 
5f49			; main game loop 
5f49			 
5f49 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5f75 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5fb4			 
5fb4			; key board defs 
5fb4			 
5fb4 .. 00		keyup:       db ": keyup $05 ;",0 
5fc2 .. 00		keydown:       db ": keydown $0a ;",0 
5fd2 .. 00		keyleft:       db ": keyleft $0b ;",0 
5fe2 .. 00		keyright:       db ": keyright $0c ;",0 
5ff3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6001 .. 00		keyf2:       db ": keyf2 $11 ;",0 
600f .. 00		keyf3:       db ": keyf3 $12 ;",0 
601d .. 00		keyf4:       db ": keyf4 $13 ;",0 
602b .. 00		keyf5:       db ": keyf5 $14 ;",0 
6039 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6047 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6055 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6063 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6071 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6080 .. 00		keyf11:       db ": keyf11 $1a ;",0 
608f .. 00		keyf12:       db ": keyf12 $1b ;",0 
609e			 
609e .. 00		keytab:       db ": keytab $09 ;",0 
60ad .. 00		keycr:       db ": keycr $0d ;",0 
60bb .. 00		keyhome:       db ": keyhome $0e ;",0 
60cb .. 00		keyend:       db ": keyend $0f ;",0 
60da .. 00		keybs:       db ": keybs $08 ;",0 
60e8			 
60e8			   
60e8			 
60e8			 
60e8			 
60e8			; eof 
# End of file forth_autostart.asm
60e8			 
60e8 .. 00		sprompt1: db "Startup load...",0 
60f8 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
610e			 
610e			 
610e			 
610e			 
610e			forth_startup: 
610e 21 46 52			ld hl, startcmds 
6111 3e 00			ld a, 0 
6113 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6116			 
6116 e5			.start1:	push hl 
6117 cd d2 0a			call clear_display 
611a 11 e8 60			ld de, sprompt1 
611d 3e 00		        ld a, display_row_1 
611f cd e5 0a			call str_at_display 
6122 11 f8 60			ld de, sprompt2 
6125 3e 14		        ld a, display_row_2 
6127 cd e5 0a			call str_at_display 
612a e1				pop hl 
612b e5				push hl 
612c 5e				ld e,(hl) 
612d 23				inc hl 
612e 56				ld d,(hl) 
612f 3e 28		        ld a, display_row_3 
6131 cd e5 0a			call str_at_display 
6134 cd f5 0a			call update_display 
6137			 
6137			 
6137 3a c9 f3			ld a, (os_last_cmd) 
613a fe 00			cp 0 
613c 28 05			jr z, .startprompt 
613e cd 46 0a			call delay250ms 
6141 18 24			jr .startdo 
6143				 
6143				 
6143			 
6143			.startprompt: 
6143			 
6143 3e 4f			ld a,display_row_4 + display_cols - 1 
6145 11 26 1c		        ld de, endprg 
6148 cd e5 0a			call str_at_display 
614b cd f5 0a			call update_display 
614e cd 52 0a			call delay1s 
6151 cd bd 66			call cin_wait 
6154						 
6154 fe 2a			cp '*' 
6156 28 5e			jr z, .startupend1 
6158 fe 23			cp '#' 
615a 20 07			jr nz, .startno 
615c 3e 01			ld a, 1 
615e 32 c9 f3			ld (os_last_cmd),a 
6161 18 04			jr .startdo 
6163 fe 31		.startno:	cp '1' 
6165 28 3a			jr z,.startnxt  
6167			 
6167				; exec startup line 
6167			.startdo:	 
6167 e1				pop hl 
6168 e5				push hl 
6169				 
6169 5e				ld e,(hl) 
616a 23				inc hl 
616b 56				ld d,(hl) 
616c eb				ex de,hl 
616d			 
616d e5				push hl 
616e			 
616e 3e 00			ld a, 0 
6170				;ld a, FORTH_END_BUFFER 
6170 cd 6f 11			call strlent 
6173 23				inc hl   ; include zero term to copy 
6174 06 00			ld b,0 
6176 4d				ld c,l 
6177 e1				pop hl 
6178 11 a3 ef			ld de, scratch 
617b ed b0			ldir 
617d			 
617d			 
617d 21 a3 ef			ld hl, scratch 
6180 cd 67 20			call forthparse 
6183 cd a7 20			call forthexec 
6186 cd be 1f			call forthexec_cleanup 
6189			 
6189 3e 3c			ld a, display_row_4 
618b 11 ca 19			ld de, endprog 
618e			 
618e cd f5 0a			call update_display		 
6191			 
6191 3a c9 f3			ld a, (os_last_cmd) 
6194 fe 00			cp 0 
6196 20 09			jr nz, .startnxt 
6198 cd 28 1c			call next_page_prompt 
619b cd d2 0a		        call clear_display 
619e cd f5 0a			call update_display		 
61a1			 
61a1				; move onto next startup line? 
61a1			.startnxt: 
61a1			 
61a1 cd 46 0a			call delay250ms 
61a4 e1				pop hl 
61a5			 
61a5 23				inc hl 
61a6 23				inc hl 
61a7			 
61a7 e5				push hl 
61a8 5e				ld e, (hl) 
61a9 23				inc hl 
61aa 56				ld d, (hl) 
61ab e1				pop hl 
61ac				; TODO replace 0 test 
61ac			 
61ac eb				ex de, hl 
61ad cd 2f 0d			call ishlzero 
61b0			;	ld a,e 
61b0			;	add d 
61b0			;	cp 0    ; any left to do? 
61b0 eb				ex de, hl 
61b1 c2 16 61			jp nz, .start1 
61b4 18 01			jr .startupend 
61b6			 
61b6 e1			.startupend1: pop hl 
61b7			.startupend: 
61b7			 
61b7 cd d2 0a			call clear_display 
61ba cd f5 0a			call update_display 
61bd c9				ret 
61be			 
61be			 
61be			; stack over and underflow checks 
61be			 
61be			; init the words to detect the under/overflow 
61be			 
61be			chk_stk_init: 
61be				; a vague random number to check so we dont get any "lucky" hits 
61be 3e 2d			ld a, 45 
61c0 6f				ld l, a 
61c1 00				nop 
61c2 3e 17			ld a, 23 
61c4 67				ld h, a 
61c5			 
61c5 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
61c8			 
61c8			;	ld (chk_stund), hl	; stack points.... 
61c8 22 fd fb			ld (chk_stovr), hl 
61cb 22 8e f9			ld (chk_ret_und), hl 
61ce 22 0c f9			ld (chk_ret_ovr), hl 
61d1 22 0a f7			ld (chk_loop_ovr), hl 
61d4 22 08 f5			ld (chk_data_ovr), hl 
61d7 c9				ret 
61d8				 
61d8			check_stacks: 
61d8				; check all stack words 
61d8			 
61d8 e5				push hl 
61d9 d5				push de 
61da			 
61da			;	ld de,(chk_word) 
61da			;	ld hl, (chk_stund)	; stack points.... 
61da			;	if DEBUG_STK_FAULT 
61da			;		DMARK "FAa" 
61da			;		CALLMONITOR 
61da			;	endif 
61da			;	call cmp16 
61da			;	jp z, .chk_faulta 
61da			; 
61da			;	ld de, sfaultsu 
61da			;	jp .chk_fault 
61da			 
61da 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
61dd ed 5b 8a ef		ld de,(chk_word) 
61e1				if DEBUG_STK_FAULT 
61e1					DMARK "FAb" 
61e1					CALLMONITOR 
61e1				endif 
61e1 cd 24 0d			call cmp16 
61e4 28 06			jr z, .chk_fault1 
61e6 11 87 62			ld de, sfaultso 
61e9 c3 3b 62			jp .chk_fault 
61ec			.chk_fault1:  
61ec 2a 8e f9			ld hl, (chk_ret_und) 
61ef ed 5b 8a ef		ld de,(chk_word) 
61f3				if DEBUG_STK_FAULT 
61f3					DMARK "FAU" 
61f3					CALLMONITOR 
61f3				endif 
61f3 cd 24 0d			call cmp16 
61f6 ca ff 61			jp z, .chk_fault2 
61f9 11 97 62			ld de, sfaultru 
61fc c3 3b 62			jp .chk_fault 
61ff			.chk_fault2:  
61ff 2a 0c f9			ld hl, (chk_ret_ovr) 
6202 ed 5b 8a ef		ld de,(chk_word) 
6206				if DEBUG_STK_FAULT 
6206					DMARK "FA1" 
6206					CALLMONITOR 
6206				endif 
6206 cd 24 0d			call cmp16 
6209 ca 12 62			jp z, .chk_fault3 
620c 11 a5 62			ld de, sfaultro 
620f c3 3b 62			jp .chk_fault 
6212			.chk_fault3:  
6212 2a 0a f7			ld hl, (chk_loop_ovr) 
6215 ed 5b 8a ef		ld de,(chk_word) 
6219				if DEBUG_STK_FAULT 
6219					DMARK "FA2" 
6219					CALLMONITOR 
6219				endif 
6219 cd 24 0d			call cmp16 
621c ca 25 62			jp z, .chk_fault4 
621f 11 bf 62			ld de, sfaultlo 
6222 c3 3b 62			jp .chk_fault 
6225			.chk_fault4:  
6225 2a 08 f5			ld hl, (chk_data_ovr) 
6228 ed 5b 8a ef		ld de,(chk_word) 
622c				if DEBUG_STK_FAULT 
622c					DMARK "FA3" 
622c					CALLMONITOR 
622c				endif 
622c cd 24 0d			call cmp16 
622f ca 38 62			jp z, .chk_fault5 
6232 11 d9 62			ld de, sfaultdo 
6235 c3 3b 62			jp .chk_fault 
6238			 
6238			 
6238			.chk_fault5:  
6238 d1				pop de 
6239 e1				pop hl 
623a			 
623a c9				ret 
623b			 
623b cd d2 0a		.chk_fault: 	call clear_display 
623e 3e 14				ld a, display_row_2 
6240 cd e5 0a				call str_at_display 
6243 11 69 62				   ld de, .stackfault 
6246 3e 00				ld a, display_row_1 
6248 cd e5 0a				call str_at_display 
624b 11 bd fb				    ld de, debug_mark 
624e 3e 11				ld a, display_row_1+17 
6250 cd e5 0a				call str_at_display 
6253 cd f5 0a				call update_display 
6256			 
6256				; prompt before entering montior for investigating issue 
6256			 
6256 3e 3c			ld a, display_row_4 
6258 11 ca 19			ld de, endprog 
625b			 
625b cd f5 0a			call update_display		 
625e			 
625e cd 28 1c			call next_page_prompt 
6261			 
6261 d1				pop de 
6262 e1				pop hl 
6263 cd 1e 1a				call monitor 
6266 c3 15 19				jp warmstart 
6269					;jp 0 
6269					;halt 
6269			 
6269			 
6269			 
6269 .. 00		.stackfault: 	db "Stack fault:",0 
6276			 
6276 .. 00		sfaultsu: 	db	"Stack under flow",0 
6287 .. 00		sfaultso: 	db	"Stack over flow",0 
6297 .. 00		sfaultru:	db "RTS underflow",0 
62a5 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
62bf .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62d9 .. 00		sfaultdo:	db "DTS overflow", 0 
62e6			 
62e6			 
62e6			fault_dsp_under: 
62e6 11 f8 62			ld de, .dsp_under 
62e9 c3 a8 63			jp .show_fault 
62ec			 
62ec			fault_rsp_under: 
62ec 11 06 63			ld de, .rsp_under 
62ef c3 a8 63			jp .show_fault 
62f2			fault_loop_under: 
62f2 11 14 63			ld de, .loop_under 
62f5 c3 a8 63			jp .show_fault 
62f8			 
62f8 .. 00		.dsp_under: db "DSP Underflow",0 
6306 .. 00		.rsp_under: db "RSP Underflow",0 
6314 .. 00		.loop_under: db "LOOP Underflow",0 
6323			 
6323			 
6323 d5			type_faultn: 	push de 
6324 e5					push hl 
6325 cd d2 0a				call clear_display 
6328 11 4f 63				   ld de, .typefaultn 
632b 3e 00				ld a, display_row_1 
632d cd e5 0a				call str_at_display 
6330 11 bd fb				    ld de, debug_mark 
6333 3e 11				ld a, display_row_1+17 
6335 cd e5 0a				call str_at_display 
6338 cd f5 0a				call update_display 
633b			 
633b				; prompt before entering montior for investigating issue 
633b			 
633b 3e 3c			ld a, display_row_4 
633d 11 ca 19			ld de, endprog 
6340			 
6340 cd f5 0a			call update_display		 
6343			 
6343 cd 28 1c			call next_page_prompt 
6346			 
6346 e5					push hl 
6347 d5					push de 
6348 cd 1e 1a				call monitor 
634b c3 15 19				jp warmstart 
634e 76					halt 
634f			 
634f			 
634f .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6366			 
6366 d5			type_faults: 	push de 
6367 e5					push hl 
6368 cd d2 0a				call clear_display 
636b 11 91 63				   ld de, .typefaults 
636e 3e 00				ld a, display_row_1 
6370 cd e5 0a				call str_at_display 
6373 11 bd fb				    ld de, debug_mark 
6376 3e 11				ld a, display_row_1+17 
6378 cd e5 0a				call str_at_display 
637b cd f5 0a				call update_display 
637e			 
637e				; prompt before entering montior for investigating issue 
637e			 
637e 3e 3c			ld a, display_row_4 
6380 11 ca 19			ld de, endprog 
6383			 
6383 cd f5 0a			call update_display		 
6386			 
6386 cd 28 1c			call next_page_prompt 
6389			 
6389 e1					pop hl 
638a d1					pop de 
638b cd 1e 1a				call monitor 
638e c3 15 19				jp warmstart 
6391			 
6391			 
6391 .. 00		.typefaults: db "STR Type Expected TOS!",0 
63a8			 
63a8			.show_fault: 	 
63a8 d5					push de 
63a9 cd d2 0a				call clear_display 
63ac d1					pop de 
63ad 3e 00				ld a, display_row_1 
63af cd e5 0a				call str_at_display 
63b2 11 bd fb				    ld de, debug_mark 
63b5 3e 11				ld a, display_row_1+17 
63b7 cd e5 0a				call str_at_display 
63ba cd f5 0a				call update_display 
63bd			 
63bd				; prompt before entering montior for investigating issue 
63bd			 
63bd 3e 3c			ld a, display_row_4 
63bf 11 ca 19			ld de, endprog 
63c2			 
63c2 cd f5 0a			call update_display		 
63c5			 
63c5 cd 28 1c			call next_page_prompt 
63c8			 
63c8 e1					pop hl 
63c9 d1					pop de 
63ca cd 1e 1a				call monitor 
63cd			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63cd			; TODO Make optional fault restart to cli or warm boot? 
63cd					;jp warmstart 
63cd c3 70 19				jp cli 
63d0 76					halt 
63d1			 
63d1			; handle the auto run of code from files in storage 
63d1			 
63d1			 
63d1			if STORAGE_SE 
63d1			 
63d1 .. 00		sprompt3: db "Loading from start-up file?:",0 
63ee .. 00		sprompt4: db "(Y=Any key/N=No)",0 
63ff			 
63ff			 
63ff			forth_autoload: 
63ff			 
63ff				; load block 0 of store 1 
63ff				 
63ff 3e fe			ld a, $fe      ; bit 0 clear 
6401 32 ce f9			ld (spi_device), a 
6404			 
6404 cd ba 03			call storage_get_block_0 
6407			 
6407 3a 09 fa			ld a, (store_page+STORE_0_AUTOFILE) 
640a			 
640a fe 00			cp 0 
640c c8				ret z     ; auto start not enabled 
640d			 
640d cd d2 0a			call clear_display 
6410			 
6410				; set bank 
6410			 
6410 3a 0b fa				ld a, (store_page+STORE_0_BANKRUN) 
6413 32 ce f9				ld (spi_device), a 
6416			 
6416				; get file id to load from and get the file name to display 
6416			 
6416 3a 0c fa				ld a, (store_page+STORE_0_FILERUN) 
6419			 
6419 2e 00				ld l, 0 
641b 67					ld h, a 
641c 11 e8 f9				ld de, store_page 
641f			 
641f					if DEBUG_FORTH_WORDS 
641f						DMARK "ASp" 
641f f5				push af  
6420 3a 34 64			ld a, (.dmark)  
6423 32 bd fb			ld (debug_mark),a  
6426 3a 35 64			ld a, (.dmark+1)  
6429 32 be fb			ld (debug_mark+1),a  
642c 3a 36 64			ld a, (.dmark+2)  
642f 32 bf fb			ld (debug_mark+2),a  
6432 18 03			jr .pastdmark  
6434 ..			.dmark: db "ASp"  
6437 f1			.pastdmark: pop af  
6438			endm  
# End of macro DMARK
6438						CALLMONITOR 
6438 cd 20 17			call break_point_state  
643b				endm  
# End of macro CALLMONITOR
643b					endif 
643b cd 4e 08				call storage_read 
643e			 
643e					if DEBUG_FORTH_WORDS 
643e						DMARK "ASr" 
643e f5				push af  
643f 3a 53 64			ld a, (.dmark)  
6442 32 bd fb			ld (debug_mark),a  
6445 3a 54 64			ld a, (.dmark+1)  
6448 32 be fb			ld (debug_mark+1),a  
644b 3a 55 64			ld a, (.dmark+2)  
644e 32 bf fb			ld (debug_mark+2),a  
6451 18 03			jr .pastdmark  
6453 ..			.dmark: db "ASr"  
6456 f1			.pastdmark: pop af  
6457			endm  
# End of macro DMARK
6457						CALLMONITOR 
6457 cd 20 17			call break_point_state  
645a				endm  
# End of macro CALLMONITOR
645a					endif 
645a			 
645a cd 2f 0d				call ishlzero 
645d c8					ret z             ; file not found 
645e			 
645e 3e 1e				ld a, display_row_2 + 10 
6460 11 eb f9				ld de, store_page+3 
6463 cd e5 0a				call str_at_display 
6466				 
6466			; 
6466			 
6466 3e 05			ld a, display_row_1+5 
6468 11 d1 63			ld de, sprompt3 
646b cd e5 0a			call str_at_display 
646e 3e 37			ld a, display_row_3+15 
6470 11 ee 63			ld de, sprompt4 
6473 cd e5 0a			call str_at_display 
6476			 
6476 cd f5 0a			call update_display 
6479			 
6479 cd bd 66			call cin_wait 
647c fe 6e			cp 'n' 
647e c8				ret z 
647f fe 4e			cp 'N' 
6481 c8				ret z 
6482			 
6482 cd 52 0a			call delay1s 
6485			 
6485 3a ea f9			ld a, (store_page+2) 
6488 32 de f9			ld (store_openmaxext), a    ; save count of ext 
648b 3e 01			ld a, 1  
648d 32 df f9			ld (store_openext), a    ; save count of ext 
6490			 
6490			.autof:  
6490 6f				ld l , a 
6491				 
6491 3a e8 f9			ld a, (store_page) 
6494 67				ld h, a	 
6495 11 e8 f9			ld de, store_page 
6498					if DEBUG_FORTH_WORDS 
6498						DMARK "ASl" 
6498 f5				push af  
6499 3a ad 64			ld a, (.dmark)  
649c 32 bd fb			ld (debug_mark),a  
649f 3a ae 64			ld a, (.dmark+1)  
64a2 32 be fb			ld (debug_mark+1),a  
64a5 3a af 64			ld a, (.dmark+2)  
64a8 32 bf fb			ld (debug_mark+2),a  
64ab 18 03			jr .pastdmark  
64ad ..			.dmark: db "ASl"  
64b0 f1			.pastdmark: pop af  
64b1			endm  
# End of macro DMARK
64b1						CALLMONITOR 
64b1 cd 20 17			call break_point_state  
64b4				endm  
# End of macro CALLMONITOR
64b4					endif 
64b4 cd 4e 08				call storage_read 
64b7 cd 2f 0d			call ishlzero 
64ba c8				ret z 
64bb			 
64bb					if DEBUG_FORTH_WORDS 
64bb						DMARK "ASc" 
64bb f5				push af  
64bc 3a d0 64			ld a, (.dmark)  
64bf 32 bd fb			ld (debug_mark),a  
64c2 3a d1 64			ld a, (.dmark+1)  
64c5 32 be fb			ld (debug_mark+1),a  
64c8 3a d2 64			ld a, (.dmark+2)  
64cb 32 bf fb			ld (debug_mark+2),a  
64ce 18 03			jr .pastdmark  
64d0 ..			.dmark: db "ASc"  
64d3 f1			.pastdmark: pop af  
64d4			endm  
# End of macro DMARK
64d4						CALLMONITOR 
64d4 cd 20 17			call break_point_state  
64d7				endm  
# End of macro CALLMONITOR
64d7					endif 
64d7 11 ea f9			ld de, store_page+2 
64da 3e 3c			ld a, display_row_4 
64dc cd e5 0a			call str_at_display 
64df			 
64df cd f5 0a			call update_display 
64e2 cd 46 0a			call delay250ms 
64e5			 
64e5			 
64e5			 
64e5 21 ea f9			ld hl, store_page+2 
64e8 cd 67 20			call forthparse 
64eb cd a7 20			call forthexec 
64ee cd be 1f			call forthexec_cleanup 
64f1			 
64f1				 
64f1 3a df f9			ld a, (store_openext) 
64f4 3c				inc a 
64f5 32 df f9			ld (store_openext), a    ; save count of ext 
64f8			 
64f8 18 96			jr .autof 
64fa			 
64fa			;.autofdone: 
64fa			; 
64fa			;		if DEBUG_FORTH_WORDS 
64fa			;			DMARK "ASx" 
64fa			;			CALLMONITOR 
64fa			;		endif 
64fa			;;	call clear_display 
64fa			;	ret 
64fa			 
64fa			 
64fa			 
64fa			endif 
64fa			 
64fa			 
64fa			; eof 
# End of file forth_kernel.asm
64fa			;include "nascombasic.asm" 
64fa			 
64fa			 
64fa			; find out where the code ends if loaded into RAM (for SC114) 
64fa			;endofcode:  
64fa			;	nop 
64fa			 
64fa			 
64fa			; eof 
64fa			 
# End of file main.asm
64fa			include "firmware_lcd_4x20.asm" 
64fa			; **********************************************************************  
64fa			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
64fa			; **********************************************************************  
64fa			;  
64fa			; **  Written as a Small Computer Monitor App  
64fa			; **  www.scc.me.uk  
64fa			;  
64fa			; History  
64fa			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
64fa			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
64fa			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
64fa			;  
64fa			; **********************************************************************  
64fa			;  
64fa			; This program is an example of one of the methods of interfacing an   
64fa			; alphanumeric LCD module.   
64fa			;  
64fa			; In this example the display is connected to either a Z80 PIO or a   
64fa			; simple 8-bit output port.   
64fa			;  
64fa			; This interfacing method uses 4-bit data mode and uses time delays  
64fa			; rather than polling the display's ready status. As a result the   
64fa			; interface only requires 6 simple output lines:  
64fa			;   Output bit 0 = not used  
64fa			;   Output bit 1 = not used  
64fa			;   Output bit 2 = RS         High = data, Low = instruction  
64fa			;   Output bit 3 = E          Active high  
64fa			;   Output bit 4 = DB4  
64fa			;   Output bit 5 = DB5  
64fa			;   Output bit 6 = DB6  
64fa			;   Output bit 7 = DB7  
64fa			; Display's R/W is connected to 0v so it is always in write mode  
64fa			;  
64fa			; This set up should work with any system supporting the RC2014 bus  
64fa			  
64fa			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
64fa			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
64fa			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
64fa			;  
64fa			; **********************************************************************  
64fa			  
64fa			; **********************************************************************  
64fa			; **  Constants  
64fa			; **********************************************************************  
64fa			; LCD constants required by LCD support module  
64fa			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
64fa			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
64fa			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
64fa			kLCDWidth:  EQU display_cols             ;Width in characters  
64fa			  
64fa			; **********************************************************************  
64fa			; **  Code library usage  
64fa			; **********************************************************************  
64fa			  
64fa			; send character to current cursor position  
64fa			; wraps and/or scrolls screen automatically  
64fa			  
64fa			  
64fa			lcd_init:  
64fa			  
64fa			; SCMonAPI functions used  
64fa			  
64fa			; Alphanumeric LCD functions used  
64fa			; no need to specify specific functions for this module  
64fa			  
64fa 3e cf		            LD   A, 11001111b  
64fc d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
64fe 3e 00		            LD   A, 00000000b  
6500 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6502			  
6502			; Initialise alphanumeric LCD module  
6502 cd 7b 65		            CALL fLCD_Init      ;Initialise LCD module  
6505			  
6505 c9				ret  
6506			  
6506			;  
6506			;;  
6506			; lcd functions  
6506			;  
6506			;  
6506			  
6506			; what is at cursor position   
6506			  
6506			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6506			;		call curptr  
6506			;		ret  
6506			  
6506			  
6506			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6506			  
6506			curptr:  
6506 c5				push bc  
6507 21 53 fb			ld hl, display_fb0  
650a			cpr:	  
650a				; loop for cursor whole row  
650a 0e 14			ld c, display_cols  
650c 23			cpr1:	inc hl  
650d 0d				dec c  
650e 20 fc			jr nz, cpr1  
6510 05				dec b  
6511 20 f7			jr nz, cpr  
6513			  
6513				; add col	  
6513			  
6513 23			cpr2:	inc hl  
6514 1d				dec e  
6515 20 fc			jr nz, cpr2  
6517			  
6517 c1				pop bc  
6518 c9				ret  
6519				  
6519			  
6519			  
6519			  
6519			  
6519			; write the frame buffer given in hl to hardware   
6519 22 5b fa		write_display: ld (display_write_tmp), hl 	   
651c 3e 00			ld a, kLCD_Line1  
651e cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6521 06 14			ld b, display_cols  
6523 ed 5b 5b fa		ld de, (display_write_tmp)  
6527 cd 73 65			call write_len_string  
652a				  
652a				  
652a 2a 5b fa			ld hl, (display_write_tmp)  
652d 11 14 00			ld de, display_cols  
6530 19				add hl,de  
6531 22 5b fa			ld (display_write_tmp),hl  
6534			  
6534				  
6534 3e 40			ld a, kLCD_Line2  
6536 cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6539 06 14			ld b, display_cols  
653b ed 5b 5b fa		ld de, (display_write_tmp)  
653f cd 73 65			call write_len_string  
6542				  
6542 2a 5b fa			ld hl, (display_write_tmp)  
6545 11 14 00			ld de, display_cols  
6548 19				add hl,de  
6549 22 5b fa			ld (display_write_tmp),hl  
654c			  
654c				  
654c 3e 14			ld a, kLCD_Line3  
654e cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6551 06 14			ld b, display_cols  
6553 ed 5b 5b fa		ld de, (display_write_tmp)  
6557 cd 73 65			call write_len_string  
655a				  
655a 2a 5b fa			ld hl, (display_write_tmp)  
655d 11 14 00			ld de, display_cols  
6560 19				add hl,de  
6561 22 5b fa			ld (display_write_tmp),hl  
6564			  
6564				  
6564 3e 54			ld a, kLCD_Line4  
6566 cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6569 06 14			ld b, display_cols  
656b ed 5b 5b fa		ld de, (display_write_tmp)  
656f cd 73 65			call write_len_string  
6572 c9					ret  
6573				  
6573				; write out a fixed length string given in b from de  
6573			  
6573 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6574 cd c5 65		            CALL fLCD_Data      ;Write character to display  
6577 13				inc de  
6578 10 f9			djnz write_len_string  
657a c9				ret  
657b			  
657b			; Some other things to do  
657b			;            LD   A, kLCD_Clear ;Display clear  
657b			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
657b			;            LD   A, kLCD_Under ;Display on with underscore cursor  
657b			;            LD   A, kLCD_On     ;Display on with no cursor  
657b			;            ;LD   A, kLCD_Off   ;Display off  
657b			;            CALL fLCD_Inst      ;Send instruction to display  
657b			;  
657b			;  
657b			;            halt  
657b			;  
657b			;  
657b			;MsgHello:   DB  "Hello World!",0  
657b			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
657b			  
657b			; Custom characters 5 pixels wide by 8 pixels high  
657b			; Up to 8 custom characters can be defined  
657b			;BitMaps:      
657b			;; Character 0x00 = Battery icon  
657b			;            DB  01110b  
657b			;            DB  11011b  
657b			;            DB  10001b  
657b			;            DB  10001b  
657b			;            DB  11111b  
657b			;            DB  11111b  
657b			;            DB  11111b  
657b			;            DB  11111b  
657b			;; Character 0x01 = Bluetooth icon  
657b			;            DB  01100b  
657b			;            DB  01010b  
657b			;            DB  11100b  
657b			;            DB  01000b  
657b			;            DB  11100b  
657b			;            DB  01010b  
657b			;            DB  01100b  
657b			;            DB  00000b  
657b			;  
657b			  
657b			  
657b			; **********************************************************************  
657b			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
657b			; **********************************************************************  
657b			;  
657b			; **  Written as a Small Computer Monitor App   
657b			; **  Version 0.1 SCC 2018-05-16  
657b			; **  www.scc.me.uk  
657b			;  
657b			; **********************************************************************  
657b			;  
657b			; This module provides support for alphanumeric LCD modules using with  
657b			; *  HD44780 (or compatible) controller  
657b			; *  5 x 7 pixel fonts  
657b			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
657b			; *  Interface via six digital outputs to the display (see below)  
657b			;  
657b			; LCD module pinout:  
657b			;   1  Vss   0v supply  
657b			;   2  Vdd   5v supply  
657b			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
657b			;   4  RS    High = data, Low = instruction  
657b			;   5  R/W   High = Read, Low = Write  
657b			;   6  E     Enable signal (active high)  
657b			;   7  DB0   Data bit 0  
657b			;   8  DB1   Data bit 1  
657b			;   9  DB2   Data bit 2  
657b			;  10  DB3   Data bit 3  
657b			;  11  DB4   Data bit 4  
657b			;  12  DB5   Data bit 5  
657b			;  13  DB6   Data bit 6  
657b			;  14  DB7   Data bit 7  
657b			;  15  A     Backlight anode (+)  
657b			;  16  K     Backlight cathode (-)  
657b			;  
657b			; This interfacing method uses 4-bit data mode and uses time delays  
657b			; rather than polling the display's ready status. As a result the   
657b			; interface only requires 6 simple output lines:  
657b			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
657b			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
657b			;   LCD DB4 = Microcomputer output port bit 4  
657b			;   LCD DB5 = Microcomputer output port bit 5  
657b			;   LCD DB6 = Microcomputer output port bit 6  
657b			;   LCD DB7 = Microcomputer output port bit 7  
657b			; Display's R/W is connected to 0v so it is always in write mode  
657b			; All 6 connections must be on the same port address <kLCDPrt>  
657b			; This method also allows a decent length of cable from micro to LCD  
657b			;  
657b			; **********************************************************************  
657b			;  
657b			; To include the code for any given function provided by this module,   
657b			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
657b			; the parent source file.  
657b			; For example:  #REQUIRES   uHexPrefix  
657b			;  
657b			; Also #INCLUDE this file at some point after the #REQUIRES statements  
657b			; in the parent source file.  
657b			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
657b			;  
657b			; These are the function names provided by this module:  
657b			; fLCD_Init                     ;Initialise LCD  
657b			; fLCD_Inst                     ;Send instruction to LCD  
657b			; fLCD_Data                     ;Send data byte to LCD  
657b			; fLCD_Pos                      ;Position cursor  
657b			; fLCD_Str                      ;Display string  
657b			; fLCD_Def                      ;Define custom character  
657b			;  
657b			; **********************************************************************  
657b			;  
657b			; Requires SCMonAPI.asm to also be included in the project  
657b			;  
657b			  
657b			  
657b			; **********************************************************************  
657b			; **  Constants  
657b			; **********************************************************************  
657b			  
657b			; Constants that must be defined externally  
657b			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
657b			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
657b			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
657b			;kLCDWidth: EQU 20             ;Width in characters  
657b			  
657b			; general line offsets in any frame buffer  
657b			  
657b			  
657b			display_row_1: equ 0  
657b			display_row_2: equ display_row_1+display_cols  
657b			display_row_3: equ display_row_2 + display_cols  
657b			display_row_4: equ display_row_3 + display_cols  
657b			;display_row_4_eol:   
657b			  
657b			  
657b			; Cursor position values for the start of each line  
657b			kLCD_Line1: EQU 0x00   
657b			kLCD_Line2: EQU 0x40    
657b			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
657b			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
657b			  
657b			; Instructions to send as A register to fLCD_Inst  
657b			kLCD_Clear: EQU 00000001b     ;LCD clear  
657b			kLCD_Off:   EQU 00001000b     ;LCD off  
657b			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
657b			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
657b			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
657b			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
657b			  
657b			; Constants used by this code module  
657b			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
657b			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
657b			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
657b			  
657b			  
657b			  
657b			; **********************************************************************  
657b			; **  LCD support functions  
657b			; **********************************************************************  
657b			  
657b			; Initialise alphanumeric LCD module  
657b			; LCD control register codes:  
657b			;   DL   0 = 4-bit mode        1 = 8-bit mode  
657b			;   N    0 = 1-line mode       1 = 2-line mode  
657b			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
657b			;   D    0 = Display off       1 = Display on  
657b			;   C    0 = Cursor off        1 = Cursor on  
657b			;   B    0 = Blinking off      1 = Blinking on  
657b			;   ID   0 = Decrement mode    1 = Increment mode  
657b			;   SH   0 = Entire shift off  1 = Entire shift on  
657b 3e 28		fLCD_Init:  LD   A, 40  
657d cd 32 66		            CALL LCDDelay       ;Delay 40ms after power up  
6580			; For reliable reset set 8-bit mode - 3 times  
6580 cd 1c 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6583 cd 1c 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6586 cd 1c 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6589			; Set 4-bit mode  
6589 cd 18 66		            CALL WrFn4bit       ;Function = 4-bit mode  
658c cd 30 66		            CALL LCDDelay1      ;Delay 37 us or more  
658f			; Function set  
658f 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6591 cd a4 65		            CALL fLCD_Inst      ;2 line, display on  
6594			; Display On/Off control  
6594 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6596 cd a4 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6599			; Display Clear  
6599 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
659b cd a4 65		            CALL fLCD_Inst      ;Clear display  
659e			; Entry mode  
659e 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
65a0 cd a4 65		            CALL fLCD_Inst      ;Increment mode, shift off  
65a3			; Display module now initialised  
65a3 c9			            RET  
65a4			; ok to here  
65a4			  
65a4			; Write instruction to LCD  
65a4			;   On entry: A = Instruction byte to be written  
65a4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65a4 f5			fLCD_Inst:  PUSH AF  
65a5 f5			            PUSH AF  
65a6 cd b8 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
65a9 f1			            POP  AF  
65aa 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65ab 17			            RLA  
65ac 17			            RLA  
65ad 17			            RLA  
65ae cd b8 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
65b1 3e 02		            LD   A, 2  
65b3 cd 32 66		            CALL LCDDelay       ;Delay 2 ms to complete   
65b6 f1			            POP  AF  
65b7 c9			            RET  
65b8 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
65ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65bc cb df		            SET  kLCDBitE, A  
65be d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65c0 cb 9f		            RES  kLCDBitE, A  
65c2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65c4 c9			            RET  
65c5			  
65c5			  
65c5			; Write data to LCD  
65c5			;   On entry: A = Data byte to be written  
65c5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65c5 f5			fLCD_Data:  PUSH AF  
65c6 f5			            PUSH AF  
65c7 cd d9 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
65ca f1			            POP  AF  
65cb 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65cc 17			            RLA  
65cd 17			            RLA  
65ce 17			            RLA  
65cf cd d9 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
65d2 3e 96		            LD   A, 150  
65d4 3d			Wait:      DEC  A              ;Wait a while to allow data   
65d5 20 fd		            JR   NZ, Wait      ;  write to complete  
65d7 f1			            POP  AF  
65d8 c9			            RET  
65d9 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
65db cb d7		            SET  kLCDBitRS, A  
65dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65df cb df		            SET  kLCDBitE, A  
65e1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
65e3 cb 9f		            RES  kLCDBitE, A  
65e5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65e7 cb 97		            RES  kLCDBitRS, A  
65e9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65eb c9			            RET  
65ec			  
65ec			  
65ec			; Position cursor to specified location  
65ec			;   On entry: A = Cursor position  
65ec			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65ec f5			fLCD_Pos:   PUSH AF  
65ed f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
65ef cd a4 65		            CALL fLCD_Inst      ;Write instruction to LCD  
65f2 f1			            POP  AF  
65f3 c9			            RET  
65f4			  
65f4			  
65f4			; Output text string to LCD  
65f4			;   On entry: DE = Pointer to null terminated text string  
65f4			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
65f4 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
65f5 b7			            OR   A              ;Null terminator?  
65f6 c8			            RET  Z              ;Yes, so finished  
65f7 cd c5 65		            CALL fLCD_Data      ;Write character to display  
65fa 13			            INC  DE             ;Point to next character  
65fb 18 f7		            JR   fLCD_Str       ;Repeat  
65fd c9					ret  
65fe			  
65fe			; Define custom character  
65fe			;   On entry: A = Character number (0 to 7)  
65fe			;             DE = Pointer to character bitmap data  
65fe			;   On exit:  A = Next character number  
65fe			;             DE = Next location following bitmap  
65fe			;             BC HL IX IY I AF' BC' DE' HL' preserved  
65fe			; Character is   
65fe c5			fLCD_Def:   PUSH BC  
65ff f5			            PUSH AF  
6600 07			            RLCA                ;Calculate location  
6601 07			            RLCA                ;  for bitmap data  
6602 07			            RLCA                ;  = 8 x CharacterNumber  
6603 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6605 cd a4 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6608 06 00		            LD   B, 0  
660a 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
660b cd c5 65		            CALL fLCD_Data      ;Write byte to display  
660e 13			            INC  DE             ;Point to next byte  
660f 04			            INC  B              ;Count bytes  
6610 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6612 28 f6		            JR   Z, Loop       ;No, so repeat  
6614 f1			            POP  AF  
6615 3c			            INC  A              ;Increment character number  
6616 c1			            POP  BC  
6617 c9			            RET  
6618			  
6618			  
6618			; **********************************************************************  
6618			; **  Private functions  
6618			; **********************************************************************  
6618			  
6618			; Write function to LCD  
6618			;   On entry: A = Function byte to be written  
6618			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6618 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
661a 18 02		            JR   WrFunc  
661c 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
661e f5			WrFunc:     PUSH AF  
661f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6621 cb df		            SET  kLCDBitE, A  
6623 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6625 cb 9f		            RES  kLCDBitE, A  
6627 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6629 3e 05		            LD   A, 5  
662b cd 32 66		            CALL LCDDelay       ;Delay 5 ms to complete  
662e f1			            POP  AF  
662f c9			            RET  
6630			  
6630			  
6630			; Delay in milliseconds  
6630			;   On entry: A = Number of milliseconds delay  
6630			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6630 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6632 d5			LCDDelay:   PUSH DE  
6633 5f			            LD   E, A           ;Delay by 'A' ms  
6634 16 00		            LD   D, 0  
6636 cd 37 0a		            CALL aDelayInMS  
6639 d1			            POP  DE  
663a c9			            RET  
663b			  
663b			  
663b			  
663b			  
663b			; eof  
663b			  
# End of file firmware_lcd_4x20.asm
663b			include "firmware_key_4x4.asm" 
663b			  
663b			  
663b			; bit mask for each scan column and row for teing the matrix  
663b			  
663b			; out   
663b 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
663f			; in  
663f 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6643			  
6643			; row/col to character map  
6643			  
6643			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6643			;    
6643			  
6643			; physical key matrix map to face of key  
6643			  
6643			  
6643			;      	1	2	3	A  
6643			;   	abc”	def&	ghi$	s1  
6643			;			  
6643			;	4	5	6	B  
6643			; 	jkl,	mno.	pqr:	s2  
6643			;			  
6643			; 	7	8	9	C  
6643			;	stu;	vwx@	yz?!	s3  
6643			;			  
6643			; 	*	0	#	D  
6643			; 	shift lck '	Space < >	Enter ( )	s4  
6643			;       tab bs 		  
6643			  
6643			  
6643			  
6643			  
6643			key_init:  
6643			  
6643			; SCMonAPI functions used  
6643			  
6643			; Alphanumeric LCD functions used  
6643			; no need to specify specific functions for this module  
6643			  
6643			  
6643 3e cf		            LD   A, 11001111b  
6645 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6647			;            LD   A, 00000000b  
6647 3e 0f		            LD   A, 00001111b  
6649 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
664b			  
664b			  
664b				; TODO Configure cursor shapes  
664b			  
664b				; Load cursor shapes   
664b 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
664d 11 5d 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6650 06 02		            LD   B, 2           ;Number of characters to define  
6652 cd fe 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6655 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6657			  
6657 3e 01				ld a, 1  
6659 32 56 fa			ld (cursor_shape),a  
665c c9				ret  
665d			  
665d			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
665d			; Up to 8 custom characters can be defined  
665d			.cursor_shapes:      
665d			;; Character 0x00 = Normal  
665d 1f			            DB  11111b  
665e 1f			            DB  11111b  
665f 1f			            DB  11111b  
6660 1f			            DB  11111b  
6661 1f			            DB  11111b  
6662 1f			            DB  11111b  
6663 1f			            DB  11111b  
6664 1f			            DB  11111b  
6665			;; Character 0x01 = Modifier  
6665 1f			            DB  11111b  
6666 1b			            DB  11011b  
6667 1b			            DB  11011b  
6668 1b			            DB  11011b  
6669 1b			            DB  11011b  
666a 1f			            DB  11111b  
666b 1b			            DB  11011b  
666c 1f			            DB  11111b  
666d			  
666d			  
666d			  
666d			  
666d			; Display custom character 0  
666d			;            LD   A, kLCD_Line1+14  
666d			;            CALL fLCD_Pos       ;Position cursor to location in A  
666d			;            LD   A, 0  
666d			;            CALL fLCD_Data      ;Write character in A at cursor  
666d			  
666d			; Display custom character 1  
666d			;            LD   A, kLCD_Line2+14  
666d			;            CALL fLCD_Pos      ;Position cursor to location in A  
666d			;            LD   A, 1  
666d			;            CALL fLCD_Data     ;Write character in A at cursor  
666d			  
666d			; keyboard scanning   
666d			  
666d			  
666d			; key_rows: equ 4  
666d			; key_cols: equ 4  
666d			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
666d			  
666d			; key_scanr: equ key_row_bitmask  
666d			; key_scanc: equ key_col_bitmask  
666d			  
666d			; key_char_map: equ key_map  
666d			  
666d			  
666d			  
666d			; character in from keyboard  
666d			  
666d ..			.matrix_to_char: db "D#0*C987B654A321"  
667d			  
667d			  
667d			; map the physical key to a char dependant on state  
667d			  
667d			.key_map_fa:   
667d			  
667d ..					db 'D'  
667e 0d					db KEY_CR    ; cr  
667f ..					db ' '  
6680 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6681 ..					db 'C'  
6682 ..					db 'y'  
6683 ..					db 'v'  
6684 ..					db 's'  
6685 ..					db 'B'  
6686 ..					db 'p'  
6687 ..					db 'm'  
6688 ..					db 'j'  
6689 ..					db 'A'  
668a ..					db 'g'  
668b ..					db 'd'  
668c ..					db 'a'  
668d			  
668d			.key_map_fb:  
668d			  
668d ..					db 'A'  
668e ..					db '+'   
668f ..					db '<'  
6690 ..					db  "'"    
6691			  
6691 ..					db 'A'  
6692 ..					db 'z'  
6693 ..					db 'w'  
6694 ..					db 't'  
6695 ..					db 'A'  
6696 ..					db 'q'  
6697 ..					db 'n'  
6698 ..					db 'k'  
6699 ..					db 'A'  
669a ..					db 'h'  
669b ..					db 'e'  
669c ..			 		db 'b'  
669d			  
669d			.key_map_fc:   
669d			  
669d			  
669d ..					db 'A'  
669e ..					db '-'   
669f ..					db '>'  
66a0 ..					db  '='   	  
66a1 ..					db 'A'  
66a2 ..					db '?'  
66a3 ..					db 'x'  
66a4 ..					db 'u'  
66a5 ..					db 'A'  
66a6 ..					db 'r'  
66a7 ..					db 'o'  
66a8 ..					db 'l'  
66a9 ..					db 'A'  
66aa ..					db 'i'  
66ab ..					db 'f'  
66ac ..					db 'c'  
66ad			  
66ad				  
66ad			.key_map_fd:  
66ad			  
66ad ..					db 'A'  
66ae ..					db '/'   
66af ..					db '%'   
66b0 08					db KEY_BS  ; back space  
66b1 ..					db 'A'  
66b2 ..					db '!'  
66b3 ..					db '@'  
66b4 ..					db ';'  
66b5 ..					db 'A'  
66b6 ..					db ':'  
66b7 ..					db '.'  
66b8 ..					db ','  
66b9 ..					db 'A'  
66ba ..					db '$'  
66bb ..					db '&'  
66bc ..				 	db '"'  
66bd			  
66bd					  
66bd				  
66bd			  
66bd			; add cin and cin_wait  
66bd			  
66bd cd ce 66		cin_wait: 	call cin  
66c0 fe 00			cp 0  
66c2 28 f9			jr z, cin_wait   ; block until key press  
66c4			  
66c4 f5				push af   ; save key pressed  
66c5			  
66c5 cd ce 66		.cin_wait1:	call cin  
66c8 fe 00			cp 0  
66ca 20 f9			jr nz, .cin_wait1  	; wait for key release  
66cc			  
66cc f1				pop af   ; get key  
66cd c9				ret  
66ce			  
66ce			  
66ce cd df 66		cin: 	call .mtoc  
66d1			  
66d1				; no key held  
66d1 fe 00			cp 0  
66d3 c8				ret z  
66d4			  
66d4				; stop key bounce  
66d4			  
66d4			;	ld (key_held),a		 ; save it  
66d4 47				ld b, a  
66d5			  
66d5 c5			.cina1:	push bc  
66d6 cd df 66			call .mtoc  
66d9 c1				pop bc  
66da b8				cp b  
66db 28 f8			jr z, .cina1  
66dd 78				ld a,b		  
66de c9				ret  
66df			  
66df			; detect keyboard modifier key press and apply new overlay to the face key held  
66df			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
66df			  
66df			;.cin_map_modifier:   
66df			;	ld a, (hl)  
66df			;	and 255  
66df			;	ret NZ		; modifier key not flagged  
66df			;  
66df			;	; get key face  
66df			;  
66df			;	ld b,(key_face_held)  
66df			;  
66df			;	ld b, key_cols * key_rows  
66df			;  
66df			;	push de  
66df			;	pop hl  
66df			;  
66df			;.mmod1: ld a,(hl)   ; get map test  
66df			;	cp b  
66df			;	jr z, .mmod2  
66df			;  
66df			;  
66df			;  
66df			;.mmod2: inc hl    ;   
66df			;  
66df			;	  
66df			;  
66df			;	  
66df			;  
66df			;	ld hl,key_actual_pressed  
66df			;	ld (hl),a,  
66df			;	ret  
66df			  
66df				  
66df			  
66df			; map matrix key held to char on face of key  
66df			  
66df			.mtoc:  
66df			  
66df			  
66df				; TODO optimise the code....  
66df			  
66df			; scan keyboard row 1  
66df 3e 80			ld a, 128  
66e1 21 d3 fb			ld hl, keyscan_table  
66e4 cd c6 67			call .rowscan  
66e7			  
66e7				   
66e7			  
66e7 3e 40			ld a, 64  
66e9 21 d7 fb			ld hl, keyscan_table+key_cols  
66ec cd c6 67			call .rowscan  
66ef			  
66ef			  
66ef			  
66ef			  
66ef 3e 20			ld a, 32  
66f1 21 db fb			ld hl, keyscan_table+(key_cols*2)  
66f4 cd c6 67			call .rowscan  
66f7			  
66f7			  
66f7			  
66f7 3e 10			ld a, 16  
66f9 21 df fb			ld hl, keyscan_table+(key_cols*3)  
66fc cd c6 67			call .rowscan  
66ff			  
66ff			  
66ff				; flag if key D is held down and remove from reporting  
66ff 01 ad 66			ld bc, .key_map_fd    
6702 21 d3 fb			ld hl, keyscan_table  
6705 11 c5 fb			ld de, key_fd  
6708 cd 58 67			call .key_shift_hold  
670b fe ff			cp 255  
670d 28 33			jr z, .cinmap  
670f				; flag if key C is held down and remove from reporting  
670f 01 9d 66			ld bc, .key_map_fc    
6712 21 d7 fb			ld hl, keyscan_table+key_cols  
6715 11 c6 fb			ld de, key_fc  
6718 cd 58 67			call .key_shift_hold  
671b fe ff			cp 255  
671d 28 23			jr z, .cinmap  
671f				; flag if key B is held down and remove from reporting  
671f 01 8d 66			ld bc, .key_map_fb    
6722 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6725 11 c7 fb			ld de, key_fb  
6728 cd 58 67			call .key_shift_hold  
672b fe ff			cp 255  
672d 28 13			jr z, .cinmap  
672f				; flag if key A is held down and remove from reporting  
672f 01 7d 66			ld bc, .key_map_fa    
6732 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6735 11 c8 fb			ld de, key_fa  
6738 cd 58 67			call .key_shift_hold  
673b fe ff			cp 255  
673d 28 03			jr z, .cinmap  
673f			  
673f 11 6d 66			ld de, .matrix_to_char  
6742			  
6742			  
6742			.cinmap:   
6742				if DEBUG_KEY  
6742			            LD   A, kLCD_Line4  
6742			            CALL fLCD_Pos       ;Position cursor to location in A  
6742					push de  
6742			            LD   DE, keyscan_table  
6742			            CALL fLCD_Str       ;Display string pointed to by DE  
6742					pop de  
6742				endif  
6742			  
6742				; scan key matrix table for any held key  
6742			  
6742				; de holds either the default matrix or one selected above  
6742			  
6742 21 d3 fb			ld hl, keyscan_table  
6745 06 10			ld b,key_cols*key_rows  
6747			  
6747 7e			.cin1:	ld a,(hl)  
6748 fe 23			cp '#'  
674a 28 08			jr z, .cinhit  
674c 23				inc hl  
674d 13				inc de  
674e 05				dec b  
674f 20 f6			jr nz, .cin1  
6751				; no key found held  
6751 3e 00			ld a,0  
6753 c9				ret  
6754 d5			.cinhit: push de  
6755 e1				pop hl  
6756 7e				ld a,(hl)  
6757 c9				ret  
6758			  
6758			; flag a control key is held   
6758			; hl is key pin, de is flag indicator  
6758			  
6758			.key_shift_hold:  
6758 c5				push bc  
6759 3e 01			ld a, 1  
675b 32 56 fa			ld (cursor_shape),a  
675e 06 00			ld b, 0  
6760 7e				ld a, (hl)  
6761 fe 2e			cp '.'  
6763 28 0a			jr z, .key_shift1  
6765 06 ff			ld b, 255  
6767 3e 2b			ld a, '+'    ; hide key from later scans  
6769 77				ld (hl),a  
676a 3e 02			ld a, 2  
676c 32 56 fa			ld (cursor_shape),a  
676f			.key_shift1:  
676f				; write flag indicator  
676f 78				ld a,b  
6770 12				ld (de),a  
6771			  
6771 d1				pop de    ; de now holds the key map ptr  
6772 c9				ret  
6773			  
6773				  
6773				  
6773			  
6773			  
6773			  
6773			  
6773			  
6773			  
6773			  
6773			  
6773			  
6773			  
6773 c9				ret  
6774			  
6774			;	push hl  
6774			;	push de  
6774			;	push bc  
6774			;	call keyscan  
6774			;	; map key matrix to ascii value of key face  
6774			;  
6774			;	ld hl, key_face_map  
6774			;	ld de, keyscan_table  
6774			;  
6774			;	; get how many keys to look at  
6774			;	ld b, keyscan_table_len  
6774			;	  
6774			;  
6774			;	; at this stage fall out on first key hit  
6774			;	; TODO handle multiple key press  
6774			;  
6774			;map1:	ld a,(hl)  
6774			;	cp '#'  
6774			;	jr z, keyhit  
6774			;	inc hl  
6774			;	inc de  
6774			;	dec b  
6774			;	jr nz, map1  
6774			;nohit:	ld a, 0  
6774			;	jr keydone  
6774			;keyhit: push de  
6774			;	pop hl  
6774			;	ld a,(hl)  
6774			;keydone:  
6774			;	push bc  
6774			;	push de  
6774			; 	push hl  
6774			;	ret   
6774			;  
6774			  
6774			  
6774			  
6774			  
6774			; scan physical key matrix  
6774			  
6774			  
6774			;keyscan:  
6774			;  
6774			;; for each key_row use keyscanr bit mask for out  
6774			;; then read in for keyscanc bitmask  
6774			;; save result of row scan to keyscantable  
6774			;  
6774			;; scan keyboard row 1  
6774			;  
6774			;	ld b, key_rows  
6774			;	ld hl, key_scanr  
6774			;	ld de, keyscan_table  
6774			;  
6774			;rowloop:  
6774			;  
6774			;	ld a,(hl)		; out bit mask to energise keyboard row  
6774			;	call rowscan  
6774			;	inc hl  
6774			;	dec b  
6774			;	jr nz, rowloop  
6774			;  
6774			;	ret  
6774			;  
6774			;  
6774			;; pass a out bitmask, b row number  
6774			;arowscan:   
6774			;	push bc  
6774			;  
6774			;	ld d, b  
6774			;  
6774			;	; calculate buffer location for this row  
6774			;  
6774			;	ld hl, keyscan_table	  
6774			;kbufr:  ld e, key_cols  
6774			;kbufc:	inc hl  
6774			;	dec e  
6774			;	jr nz, kbufc  
6774			;	dec d  
6774			;	jr nz, kbufr  
6774			;  
6774			;	; energise row and read columns  
6774			;  
6774			;	out (portbdata),a  
6774			;	in a,(portbdata)  
6774			;	ld c,a  
6774			;  
6774			;  
6774			;	; save buffer loc  
6774			;  
6774			;	ld (keybufptr), hl  
6774			;  
6774			;	ld hl, key_scanc  
6774			;	ld d, key_cols  
6774			;  
6774			;	; for each column check each bit mask  
6774			;  
6774			;colloop:  
6774			;	  
6774			;  
6774			;	; reset flags for the row   
6774			;  
6774			;	ld b,'.'  
6774			;	and (hl)  
6774			;	jr z, maskskip  
6774			;	ld b,'#'  
6774			;maskskip:  
6774			;	; save  key state  
6774			;	push hl  
6774			;	ld hl, (keybufptr)  
6774			;	ld (hl), b  
6774			;	inc hl  
6774			;	ld (keybufptr), hl  
6774			;  
6774			;	; move to next bit mask  
6774			;	pop hl  
6774			;	inc hl  
6774			;  
6774			;	dec d  
6774			;	jr nz, colloop  
6774			;  
6774			;	ret  
6774			;  
6774			;  
6774			;;  
6774			; lcd functions  
6774			;  
6774			;  
6774			  
6774			;if DEBUG_KEY_MATRIX  
6774			  
6774			; test function to display hardware view of matrix state  
6774			  
6774			matrix:  
6774			  
6774			  
6774			  
6774			; scan keyboard row 1  
6774 3e 80			ld a, 128  
6776 21 f8 fb			ld hl, keyscan_table_row1  
6779 cd c6 67			call .rowscan  
677c			  
677c 3e 40			ld a, 64  
677e 21 f3 fb			ld hl, keyscan_table_row2  
6781 cd c6 67			call .rowscan  
6784			  
6784 3e 20			ld a, 32  
6786 21 ee fb			ld hl, keyscan_table_row3  
6789 cd c6 67			call .rowscan  
678c			  
678c 3e 10			ld a, 16  
678e 21 e9 fb			ld hl, keyscan_table_row4  
6791 cd c6 67			call .rowscan  
6794			  
6794			; Display text on first line  
6794 3e 00		            LD   A, kLCD_Line1  
6796 cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6799 11 f8 fb		            LD   DE, keyscan_table_row1  
679c			            ;LD   DE, MsgHello  
679c cd f4 65		            CALL fLCD_Str       ;Display string pointed to by DE  
679f			  
679f			; Display text on second line  
679f 3e 40		            LD   A, kLCD_Line2  
67a1 cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67a4 11 f3 fb		            LD   DE, keyscan_table_row2  
67a7 cd f4 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67aa 3e 14		            LD   A, kLCD_Line3  
67ac cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67af 11 ee fb		            LD   DE, keyscan_table_row3  
67b2 cd f4 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67b5 3e 54		            LD   A, kLCD_Line4  
67b7 cd ec 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67ba 11 e9 fb		            LD   DE, keyscan_table_row4  
67bd cd f4 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67c0			  
67c0 cd 46 0a			call delay250ms  
67c3 c3 74 67			jp matrix  
67c6			  
67c6			; pass de as row display flags  
67c6			.rowscan:   
67c6 d3 c1			out (portbdata),a  
67c8 db c1			in a,(portbdata)  
67ca 4f				ld c,a  
67cb				; reset flags for the row   
67cb 06 2e			ld b,'.'  
67cd e6 01			and 1  
67cf 28 02			jr z, .p1on  
67d1 06 23			ld b,'#'  
67d3			.p1on:  
67d3 70				ld (hl), b  
67d4 23				inc hl  
67d5			  
67d5 06 2e			ld b,'.'  
67d7 79				ld a,c  
67d8 e6 02			and 2  
67da			;	bit 0,a  
67da 28 02			jr z, .p2on  
67dc 06 23			ld b,'#'  
67de			.p2on:  
67de 70				ld (hl), b  
67df 23				inc hl  
67e0			;  
67e0 06 2e			ld b,'.'  
67e2 79				ld a,c  
67e3 e6 04			and 4  
67e5			;;	bit 0,a  
67e5 28 02			jr z, .p3on  
67e7 06 23			ld b,'#'  
67e9			.p3on:  
67e9 70				ld (hl), b  
67ea 23				inc hl  
67eb			;;  
67eb 06 2e			ld b,'.'  
67ed			;;	bit 0,a  
67ed 79				ld a,c  
67ee e6 08			and 8  
67f0 28 02			jr z, .p4on  
67f2 06 23			ld b,'#'  
67f4			.p4on:  
67f4 70				ld (hl), b  
67f5 23				inc hl  
67f6			  
67f6			; zero term  
67f6 06 00			ld b,0  
67f8 70				ld (hl), b  
67f9			  
67f9 c9			.rscandone: ret  
67fa			  
67fa			  
67fa			  
67fa			;endif  
67fa			  
67fa			  
67fa			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
67fa
