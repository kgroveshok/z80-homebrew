# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 23 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-09 11:33' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 2b 6f			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			; cursor blink rate  
0068			CUR_BLINK_RATE: equ $09  
0068			;CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 38 6f				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd cf 71			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd 86 13				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 13 1b			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 28 1b			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd 8e 12			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd 6d 13				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 40 13			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 60 23			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd 9b 1f			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 64 6f			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd af 72		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd 9e 72				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored and edited directly 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc			EDIT_V1: equ 0 
0ffc			EDIT_V2: equ 1 
0ffc			 
0ffc			 
0ffc			 
0ffc			if EDIT_V2 
0ffc			input_str: 
0ffc			 
0ffc 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
0fff			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fff 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1002			;		ld a, c 
1002			;		call addatohl 
1002			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1002 7a					ld a,d 
1003 32 a1 fd			        ld (input_size), a       ; save length of input area 
1006 79					ld a, c 
1007 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
100a 7b					ld a,e 
100b 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
100e			 
100e			 
100e					; add a trailing space to make screen refresh nicer 
100e			 
100e					;ld hl, (input_start) 
100e					;push hl 
100e					;ld a, 0 
100e					;call strlent 
100e					;ld a, l 
100e					;pop hl 
100e					;call addatohl 
100e					;dec hl 
100e					;ld a, ' ' 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld a, 0 
100e					;ld (hl), a 
100e			 
100e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
100e					; init cursor shape if not set by the cin routines 
100e 21 fc fa				ld hl, cursor_shape 
1011			if BASE_KEV 
1011 3e ff				ld a, 255 
1013			else 
1013					ld a, '#' 
1013			endif 
1013 77					ld (hl), a 
1014 23					inc hl 
1015 3e 00				ld a, 0 
1017 77					ld (hl), a 
1018			 
1018 3e 09				ld a, CUR_BLINK_RATE 
101a 32 9b fd				ld (input_cur_flash), a 
101d 3e 01				ld a, 1 
101f 32 9a fd				ld (input_cur_onoff),a 
1022			.inmain:	 
1022			 
1022 cd 4a 11				call input_disp_ref 
1025			 
1025					; save current length of string 
1025			 
1025 2a a2 fd				ld hl, (input_start) 
1028 3e 00				ld a, 0 
102a cd 40 13				call strlent 
102d 7d					ld a,l 
102e 32 95 fd				ld (input_len), a 
1031			 
1031					;call input_disp_oncur 
1031			 
1031					; display current state of input buffer 
1031			 
1031					; clean any backspace chars 
1031			 
1031 3e 20				ld a, " " 
1033 32 fc f0				ld (scratch),a 
1036 3e 00				ld a, 0 
1038 32 fd f0				ld (scratch+1),a 
103b 3a 9f fd				ld a,(input_at_pos) 
103e 85					add l 
103f 11 fc f0				ld de, scratch 
1042 cd ae 0d				call str_at_display 
1045			 
1045					; pause 1ms 
1045			 
1045 3e 01				ld a, 1 
1047 cd c3 0c				call aDelayInMS 
104a			 
104a			; display cursor if visible on this cycle 
104a			 
104a					; dec flash counter 
104a 3a 9b fd				ld a, (input_cur_flash) 
104d 3d					dec a 
104e 32 9b fd				ld (input_cur_flash), a 
1051 fe 00				cp 0 
1053 20 0d				jr nz, .inochgstate 
1055			 
1055			 
1055					; reset on change of state 
1055 3e 09				ld a, CUR_BLINK_RATE 
1057 32 9b fd				ld (input_cur_flash), a 
105a			 
105a					; change state 
105a 3a 9a fd				ld a,(input_cur_onoff) 
105d ed 44				neg 
105f 32 9a fd				ld (input_cur_onoff),a 
1062			 
1062			 
1062			 
1062			 
1062					; TODO is cursor visible? 
1062					; TODO if so then over write the char at curspos pos with the cursor shape 
1062			 
1062								 
1062			 
1062			.inochgstate: 
1062 3a 9a fd				ld a,(input_cur_onoff) 
1065 fe ff				cp 255 
1067 28 0e				jr z, .skipcursor 
1069 3a 9f fd				ld a, (input_at_pos) 
106c 47					ld b, a 
106d 3a 90 fd				ld a, (input_cursor) 
1070 80					add b 
1071 11 fc fa				ld de, cursor_shape 
1074					 
1074 cd ae 0d				call str_at_display 
1077			 
1077			.skipcursor: 
1077				if DEBUG_INPUTV2 
1077			 
1077					ld a,(input_at_pos) 
1077					ld hl, LFSRSeed 
1077					call hexout 
1077					ld a, (input_cursor) 
1077					ld hl, LFSRSeed+2 
1077					call hexout 
1077					ld a,(input_size) 
1077					ld hl, LFSRSeed+4 
1077					call hexout 
1077			 
1077					ld a,(input_cur_onoff) 
1077					ld hl, LFSRSeed+6 
1077					call hexout 
1077			 
1077					ld a,(input_cur_flash) 
1077					ld hl, LFSRSeed+8 
1077					call hexout 
1077			 
1077					ld a,(input_len) 
1077					ld hl, LFSRSeed+10 
1077					call hexout 
1077					ld hl, LFSRSeed+12 
1077					ld a, 0 
1077					ld (hl),a 
1077					ld a, display_row_4 
1077					ld de, LFSRSeed 
1077					call str_at_display 
1077				endif 
1077 cd be 0d				call update_display 
107a			 
107a					; TODO keyboard processing 
107a			 
107a			if BASE_CPM 
107a					call cin_wait 
107a			else 
107a cd af 72				call cin    ; _wait 
107d			endif 
107d fe 00				cp 0 
107f ca 22 10				jp z, .inmain 
1082			 
1082 fe 0b				cp KEY_LEFT    ; cursor left 
1084 ca 3c 11				jp z, input_left 
1087				 
1087 fe 0c				cp KEY_RIGHT      ; cursor right 
1089 ca 43 11				jp z, input_right 
108c			 
108c fe 0d				cp KEY_CR 
108e c8					ret z 
108f			 
108f fe 08				cp KEY_BS 
1091 ca b1 11				jp z, input_delchar 
1094			 
1094 fe 06				cp KEY_NEXTWORD 
1096 ca bd 10				jp z, input_nxtword 
1099			 
1099 fe 07				cp KEY_PREVWORD 
109b ca e4 10				jp z, input_prvword 
109e			 
109e fe 0e				cp KEY_HOME    ; jump to start of line 
10a0 20 08				jr nz, .ikh 
10a2 3e 00				ld a, 0 
10a4 32 90 fd				ld (input_cursor), a 
10a7 ca 22 10				jp z, .inmain 
10aa			.ikh: 
10aa			 
10aa fe 0f				cp KEY_END     ; jump to end of line 
10ac 20 09				jr nz, .ike 
10ae 3a 95 fd				ld a, (input_len) 
10b1 32 90 fd				ld (input_cursor),a 
10b4 ca 22 10				jp z, .inmain 
10b7			.ike: 
10b7 fe 05			        cp KEY_UP      ; recall last command 
10b9 c8					ret z 
10ba			;jr nz, .irec 
10ba			; TODO next word 
10ba			; TODO prev word 
10ba			;  
10ba			; 
10ba			;	ld hl, scratch 
10ba			;	ld de, os_last_cmd 
10ba			;	call strcpy 
10ba			;		jp  .inmain 
10ba			.irec: 
10ba			;		jr .instr1 
10ba			 
10ba			 
10ba			 
10ba					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10ba			 
10ba			; TODO return if any special keys are given 
10ba			;		ld l, a 
10ba			;		ld a, 28 ; KEY_F12   ; 27 
10ba			;		sub l 
10ba			;		ret m 
10ba			;		ld a, l 
10ba					; if no special key then insert as a char 
10ba			 
10ba c3 83 11				jp input_inschr 
10bd			 
10bd				 
10bd			input_nxtword: 
10bd				; jump to start next word after the cursor 
10bd			 
10bd			.insknwn:	 
10bd cd 79 11				call input_curptr	 
10c0 7e					ld a,(hl)	 
10c1 fe 00				cp 0 
10c3 ca 22 10				jp z, .inmain    ; end of string 
10c6			 
10c6			; if we are on a word, then move off of it 
10c6			 
10c6 fe 20				cp ' ' 
10c8 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10ca 21 90 fd				ld hl, input_cursor 
10cd 34					inc (hl) 
10ce 18 ed				jr .insknwn 
10d0			 
10d0			.inspace: 
10d0			 
10d0 cd 79 11				call input_curptr	 
10d3 7e					ld a,(hl)	 
10d4 fe 00				cp 0 
10d6 ca 22 10				jp z, .inmain    ; end of string 
10d9			 
10d9			; if we are on a word, then move off of it 
10d9			 
10d9 fe 20				cp ' ' 
10db c2 22 10				jp nz, .inmain     ; we are on non space so at next word 
10de 21 90 fd				ld hl, input_cursor 
10e1 34					inc (hl) 
10e2 18 ec				jr .inspace 
10e4			 
10e4			 
10e4			 
10e4			 
10e4			input_prvword: 
10e4				; jump to the start of previous word before the cursor 
10e4			 
10e4			; where are we to start with currently? 
10e4			 
10e4 cd 79 11				call input_curptr	 
10e7 7e					ld a, (hl) 
10e8 fe 20				cp ' ' 
10ea 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10ec			 
10ec			 
10ec			 
10ec			.inskpwn:	 
10ec 3a 90 fd				ld a,(input_cursor) 
10ef fe 00				cp 0 
10f1 ca 22 10				jp z, .inmain    ; start of string 
10f4			 
10f4			;if we are on a word, then move off of it 
10f4			 
10f4 cd 79 11				call input_curptr	 
10f7 7e					ld a, (hl) 
10f8 fe 20				cp ' ' 
10fa 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
10fc					;jp z, .inmain    ; start of string 
10fc 21 90 fd				ld hl, input_cursor 
10ff 35					dec (hl) 
1100 18 ea				jr .inskpwn 
1102			.iwstart: 
1102 21 90 fd				ld hl, input_cursor 
1105 34					inc (hl) 
1106 c3 22 10				jp .inmain 
1109					 
1109			 
1109			.inspacep: 
1109			 
1109					;jp .inmain    ; start of string 
1109			 
1109			 
1109			 
1109 3a 90 fd				ld a,(input_cursor) 
110c fe 00				cp 0 
110e ca 22 10				jp z, .inmain    ; start of string 
1111			 
1111			; if we are on a word, then move off of it 
1111			 
1111 cd 79 11				call input_curptr	 
1114 7e					ld a, (hl) 
1115 fe 20				cp ' ' 
1117 c2 20 11				jp nz, .incharp     ; we are on non space so at end of prev word 
111a 21 90 fd				ld hl, input_cursor 
111d 35					dec (hl) 
111e 18 e9				jr .inspacep 
1120			 
1120			 
1120			.incharp:	 
1120					; eat the word to get to the start 
1120 3a 90 fd				ld a,(input_cursor) 
1123 fe 00				cp 0 
1125 ca 22 10				jp z, .inmain    ; start of string 
1128			 
1128			; if we are on a word, then move off of it 
1128			 
1128 cd 79 11				call input_curptr	 
112b 7e					ld a, (hl) 
112c fe 20				cp ' ' 
112e 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1130 21 90 fd				ld hl, input_cursor 
1133 35					dec (hl) 
1134 18 ea				jr .incharp 
1136			.ipwordst: 
1136					; at space before the prev word so reposition over it 
1136 21 90 fd				ld hl, input_cursor 
1139 34					inc (hl) 
113a 18 b0				jr .inskpwn 
113c					 
113c			 
113c			 
113c			input_left: 
113c				; move cursor left 
113c 21 90 fd			ld hl, input_cursor 
113f 35				dec (hl) 
1140			;	cp 0 
1140			;	jp z, .inmain    ; ignore left as at the start of the string 
1140 c3 22 10			jp .inmain 
1143			 
1143			input_right: 
1143				; move cursor right 
1143				 
1143				;ld a, (input_size) 
1143				;ld b, a 
1143 21 90 fd			ld hl, input_cursor 
1146 34				inc (hl) 
1147				;dec b 
1147				;cp 0 
1147				;jp z, .inmain   ; ignore as at end of the string buffer 
1147				;ld a, b 
1147				;inc a 
1147				;ld (input_cursor), a 
1147 c3 22 10			jp .inmain 
114a			 
114a			 
114a			 
114a			input_disp_ref: 
114a				; display the text from start of buffer (ie full refresh) 
114a 3a 9f fd			ld a, (input_at_pos) 
114d 2a a2 fd			ld hl,(input_start) 
1150 eb				ex de, hl 
1151 cd ae 0d			call str_at_display  
1154 c9				ret 
1155			input_disp_oncur: 
1155				; display the text from cursor position to end of buffer 
1155				; TODO position start of string at cursor position on screen 
1155				; TODO draw from that point on 
1155 3a 90 fd			ld a, (input_cursor) 
1158 47				ld b, a 
1159 3a 9f fd			ld a, (input_at_pos) 
115c 80				add b 
115d 48				ld c, b     ; save a 
115e 78				ld a, b     ; inc string start for cursor 
115f 2a a2 fd			ld hl,(input_start) 
1162 cd cf 0f			call addatohl 
1165 eb				ex de, hl 
1166 79				ld a, c 
1167 cd ae 0d			call str_at_display  
116a c9				ret 
116b			 
116b			input_nxtw: 
116b				; Find next word 
116b c9				ret 
116c			 
116c			input_prvw: 
116c				; Find previous word 
116c c9				ret 
116d			 
116d			input_lenrem:   
116d				; Calculate the length of string remaining from current cursor 
116d				; position to end of buffer (exc null term) 
116d				 
116d 3a 90 fd			ld a, (input_cursor) 
1170 4f				ld c, a 
1171 3a a1 fd			ld a, (input_size) 
1174 91				sub c 
1175 06 00			ld b, 0 
1177 0d				dec c 
1178 c9				ret	 
1179			 
1179			input_curptr: 
1179				; calc address of the character under the cursor 
1179				 
1179 2a a2 fd			ld hl, (input_start) 
117c 3a 90 fd			ld a, (input_cursor) 
117f cd cf 0f			call addatohl 
1182 c9				ret 
1183			 
1183			input_inschr: 
1183				; Insert char at cursor position 
1183 f5				push af   ; save char 
1184				;call input_lenrem    ; get bc length of remaining string 
1184			 
1184				 
1184 cd 79 11			call input_curptr 
1187			;	ld hl, (input_start) 
1187			;	ld a, (input_cursor) 
1187			;	call addatohl 
1187				;push hl   ; save to come back to 
1187			 
1187				; shift everything up one to end of buffer 
1187			 
1187				;push hl 
1187				;dec de 
1187				;inc de 
1187			;	ldir 
1187				 
1187				;pop hl 
1187			 
1187				; are we adding to the end of line? 
1187			 
1187 3a 90 fd			ld a, (input_cursor) 
118a 47				ld b, a 
118b 3a 95 fd			ld a, (input_len) 
118e b8				cp b 
118f 20 09			jr nz, .insmid   ; no, insert in middle of text 
1191			 
1191				; tack on the end of the line 
1191 f1				pop af 
1192 77				ld (hl), a   ; save new char 
1193 23				inc hl 
1194 3e 00			ld a, 0 
1196 77				ld (hl), a 
1197 c3 43 11			jp input_right 
119a				 
119a			.insmid: 
119a				; hl has insertion point so move everything up one to allow for insertion 
119a				;call input_shiftright 
119a f1				pop af 
119b			 
119b			.shufinsmid: 
119b 47				ld b, a     ; b contains new char, c prev char at this position  
119c 7e				ld a, (hl) 
119d			 
119d fe 00			cp 0    ; at end of string need to then dump new char and add term 
119f 28 07			jr z, .endinsmid 
11a1 4f				ld c, a 
11a2 78				ld a, b 
11a3 77				ld (hl), a 
11a4 23				inc hl 
11a5 79				ld a, c 
11a6 18 f3			jr .shufinsmid 
11a8				 
11a8			 
11a8			 
11a8			 
11a8			.endinsmid: 
11a8 78				ld a, b 
11a9 77				ld (hl), a 
11aa 23				inc hl 
11ab 3e 00			ld a, 0 
11ad 77				ld (hl), a 
11ae			 
11ae			 
11ae			;	ld (hl), a   ; save new char 
11ae			 
11ae c3 43 11			jp input_right 
11b1			 
11b1			;input_shiftright: 
11b1			;	; shift text right at cursor, hl has shift start 
11b1			;	push hl 
11b1			;	push de 
11b1			;	push bc 
11b1			; 
11b1			; 
11b1			;	; move to end of string past zero term 
11b1			;	ld hl,(input_start) 
11b1			;	ld a, (input_len) 
11b1			;	call addatohl 
11b1			;	inc hl 
11b1			;;	inc hl 
11b1			;;	inc hl 
11b1			;	ld a, 0 
11b1			;	ld (hl), a 
11b1			;;	dec hl 
11b1			;	 
11b1			;;	ld (hl), a 
11b1			;;	dec hl 
11b1			; 
11b1			;	push hl 
11b1			;	pop de 
11b1			;	inc de 
11b1			;	 
11b1			; 
11b1			;;	ld hl,(input_start) 
11b1			;;	ld a, (input_cursor) 
11b1			;;	call addatohl 
11b1			; 
11b1			; 
11b1			;	; calc how many bytes from cursor pos to end of string we need to shift 
11b1			;	call input_lenrem    ; get bc length of remaining string 
11b1			;	;ld a, (input_cursor) 
11b1			;	;ld c, a 
11b1			;	ld a, (input_len) 
11b1			;	cp 2 
11b1			;	jr z, .iskipzero	 
11b1			;	;sub c 
11b1			;	;inc a 
11b1			;	;ld c, a 
11b1			;	;ld b, 0 
11b1			;	inc c 
11b1			;	inc c 
11b1			;	; move data 
11b1			;	lddr 
11b1			;.iskipzero: 
11b1			; 
11b1			;	pop bc 
11b1			;	pop de 
11b1			;	pop hl 
11b1			;	ret	 
11b1			 
11b1			input_delchar: 
11b1				; Delete char at cursor position 
11b1 cd 6d 11			call input_lenrem    ; get bc length of remaining string 
11b4 2a a2 fd			ld hl, (input_start) 
11b7 3a 90 fd			ld a, (input_cursor) 
11ba cd cf 0f			call addatohl 
11bd			 
11bd e5				push hl 
11be d1				pop de 
11bf 1b				dec de 
11c0			 
11c0			.dl:	 
11c0 ed a0			ldi  
11c2 7e				ld a, (hl) 
11c3 fe 00			cp 0 
11c5 28 02			jr z, .dldone 
11c7 18 f7			jr .dl 
11c9			.dldone: 
11c9 ed a0			ldi 
11cb			 
11cb c3 3c 11			jp input_left 
11ce			 
11ce			 
11ce			endif 
11ce			 
11ce			 
11ce			 
11ce			if EDIT_V1 
11ce			input_str: 
11ce			 
11ce				    	ld (input_at_pos),a      ; save display position to start 
11ce					add c 
11ce					ld (input_at_cursor),a	; save draw pos of cursor 
11ce					ld (input_start), hl     ; save ptr to buffer 
11ce					ld a, c 
11ce					call addatohl 
11ce					ld (input_ptr), hl     ; save ptr to point under the cursor 
11ce					ld a,d 
11ce				        ld (input_size), a       ; save length of input area 
11ce					ld a, c 
11ce					ld (input_cursor),a      ; init cursor start position  
11ce					ld a,e 
11ce				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11ce					 
11ce					 
11ce			 
11ce			;		ld a,(input_ptr) 
11ce			;		ld (input_under_cursor),a 	; save what is under the cursor 
11ce			 
11ce			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11ce					; init cursor shape if not set by the cin routines 
11ce					ld hl, cursor_shape 
11ce			if BASE_KEV 
11ce					ld a, 255 
11ce			else 
11ce					ld a, '#' 
11ce			endif 
11ce					ld (hl), a 
11ce					inc hl 
11ce					ld a, 0 
11ce					ld (hl), a 
11ce			 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce					ld a, 1 
11ce					ld (input_cur_onoff),a 
11ce			 
11ce			;	if DEBUG_INPUT 
11ce			;		push af 
11ce			;		ld a, 'I' 
11ce			;		ld (debug_mark),a 
11ce			;		pop af 
11ce			;		CALLMONITOR 
11ce			;	endif 
11ce			.is1:		; main entry loop 
11ce			 
11ce			 
11ce			 
11ce					; pause 1ms 
11ce			 
11ce					ld a, 1 
11ce					call aDelayInMS 
11ce			 
11ce					; dec flash counter 
11ce					ld a, (input_cur_flash) 
11ce					dec a 
11ce					ld (input_cur_flash), a 
11ce					cp 0 
11ce					jr nz, .nochgstate 
11ce			 
11ce			 
11ce					; change state 
11ce					ld a,(input_cur_onoff) 
11ce					neg 
11ce					ld (input_cur_onoff),a 
11ce			 
11ce			 
11ce					; reset on change of state 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce			.nochgstate: 
11ce					 
11ce					 
11ce			 
11ce					; display cursor  
11ce			 
11ce			;		ld hl, (input_start) 
11ce			;		ld a, (input_cursor) 
11ce			;		call addatohl 
11ce			 
11ce					; get char under cursor and replace with cursor 
11ce			ld hl, (input_ptr) 
11ce			;		ld a, (hl) 
11ce			;		ld (input_under_cursor),a 
11ce			;		ld a, '_' 
11ce			;		ld (hl), a 
11ce			 
11ce					; display string 
11ce			 
11ce					ld de, (input_start) 
11ce					ld a, (input_at_pos) 
11ce					call str_at_display 
11ce			;	        call update_display 
11ce			 
11ce					; find place to put the cursor 
11ce			;		add h 
11ce			;		ld l, display_row_1 
11ce			;		sub l 
11ce			; (input_at_pos) 
11ce					;ld c, a 
11ce			;		ld a, (input_cursor) 
11ce			;		ld l, (input_at_pos) 
11ce			;		;ld b, h 
11ce			;		add l 
11ce			;		ld (input_at_cursor),a 
11ce					;ld l,h 
11ce			 
11ce			;		ld h, 0 
11ce			;		ld l,(input_at_pos) 
11ce			;		ld a, (input_cursor) 
11ce			;		call addatohl 
11ce			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11ce			;		call subafromhl 
11ce			;		ld a,l 
11ce			;		ld (input_at_cursor), a 
11ce			 
11ce				if DEBUG_INPUT 
11ce					ld a, (hardware_diag) 
11ce					cp 0 
11ce					jr z, .skip_input_diag 
11ce			 
11ce					ld a,(input_at_pos) 
11ce					ld hl, LFSRSeed 
11ce					call hexout 
11ce					ld a, (input_cursor) 
11ce					ld hl, LFSRSeed+2 
11ce					call hexout 
11ce					ld a,(input_at_cursor) 
11ce					ld hl, LFSRSeed+4 
11ce					call hexout 
11ce			 
11ce					ld a,(input_cur_onoff) 
11ce					ld hl, LFSRSeed+6 
11ce					call hexout 
11ce			 
11ce					ld a,(input_cur_flash) 
11ce					ld hl, LFSRSeed+8 
11ce					call hexout 
11ce			 
11ce					ld a,(input_len) 
11ce					ld hl, LFSRSeed+10 
11ce					call hexout 
11ce					ld hl, LFSRSeed+12 
11ce					ld a, 0 
11ce					ld (hl),a 
11ce					ld a, display_row_4 
11ce					ld de, LFSRSeed 
11ce					call str_at_display 
11ce					.skip_input_diag: 
11ce				endif 
11ce			 
11ce					; decide on if we are showing the cursor this time round 
11ce			 
11ce					ld a, (input_cur_onoff) 
11ce					cp 255 
11ce					jr z, .skipcur 
11ce			 
11ce			 
11ce					ld a,(input_at_cursor) 
11ce					ld de, cursor_shape 
11ce					call str_at_display 
11ce			 
11ce					; save length of current input string 
11ce					ld hl, (input_start) 
11ce					ld a, 0 
11ce					call strlent 
11ce					ld a,l 
11ce					ld (input_len),a 
11ce			 
11ce			.skipcur: 
11ce			 
11ce				        call update_display 
11ce					 
11ce			 
11ce			 
11ce					; wait 
11ce				 
11ce					; TODO loop without wait to flash the cursor and char under cursor	 
11ce					call cin    ; _wait 
11ce			 
11ce					cp 0 
11ce					jp z, .is1 
11ce			 
11ce					; get ptr to char to input into 
11ce			 
11ce					ld c,a 
11ce					ld hl, (input_start) 
11ce					ld a, (input_cursor) 
11ce					call addatohl 
11ce					ld (input_ptr), hl 
11ce					ld a,c 
11ce			 
11ce					; replace char under cursor 
11ce			 
11ce			;		ld hl, (input_ptr) 
11ce			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11ce			;		ld (hl), a 
11ce			 
11ce			;	if DEBUG_INPUT 
11ce			;		push af 
11ce			;		ld a, 'i' 
11ce			;		ld (debug_mark),a 
11ce			;		pop af 
11ce			;		CALLMONITOR 
11ce			;	endif 
11ce					cp KEY_HOME 
11ce					jr nz, .iske 
11ce			 
11ce					ld a, (input_at_pos) 
11ce					ld (input_at_cursor),a 
11ce					ld a, 0 
11ce					ld (input_cursor), a 
11ce					jp .is1 
11ce					 
11ce			.iske:		cp KEY_END 
11ce					jr nz, .isknw 
11ce					jp .is1 
11ce			 
11ce			.isknw:		cp KEY_NEXTWORD 
11ce					jr nz, .iskpw 
11ce			 
11ce			.isknwm:	ld hl, (input_ptr) 
11ce					ld a,(hl)	 
11ce					cp 0 
11ce					jp z, .is1    ; end of string 
11ce					cp ' ' 
11ce					jp z, .is1    ; end of word 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce					jr .isknwm 
11ce			 
11ce			.iskpw:		cp KEY_PREVWORD 
11ce					jr nz, .iskl 
11ce			.iskpwm:	 
11ce					ld hl, (input_ptr) 
11ce					ld a,(hl)	 
11ce					cp 0  
11ce					jp z, .is1    ; end of string 
11ce					cp ' ' 
11ce					jp z, .is1    ; end of word 
11ce					dec hl 
11ce					ld (input_ptr), hl 
11ce					ld a, (input_at_cursor) 
11ce					dec a 
11ce					ld (input_at_cursor), a 
11ce					jr .iskpwm 
11ce			 
11ce			 
11ce			.iskl:		cp KEY_LEFT 
11ce					jr nz, .isk1 
11ce			 
11ce					ld a, (input_cursor) 
11ce			 
11ce					cp 0 
11ce					jp z, .is1 		; at start of line to ignore  
11ce			 
11ce					dec  a 		; TODO check underflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					dec hl 
11ce					ld (input_ptr), hl 
11ce					 
11ce					ld a, (input_at_cursor) 
11ce					dec a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk1:		cp KEY_RIGHT 
11ce					jr nz, .isk2 
11ce			 
11ce					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11ce					ld e,a 
11ce					ld a, (input_cursor) 
11ce					cp e 
11ce					jp z, .is1		; at the end of string so dont go right 
11ce			 
11ce					inc  a 		; TODO check overflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce			 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk2:		cp KEY_UP 
11ce			 
11ce					jr nz, .isk3 
11ce			 
11ce					; swap last command with the current on 
11ce			 
11ce					; move cursor to start of string 
11ce					ld hl, (input_start) 
11ce					ld (input_ptr), hl 
11ce			 
11ce					ld a, (input_at_pos) 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld a, 0 
11ce					ld (input_cursor), a 
11ce					 
11ce					; swap input and last command buffers 
11ce			 
11ce					ld hl, os_cli_cmd 
11ce					ld de, os_last_cmd 
11ce					ld b, 255 
11ce			.swap1:		ld a, (hl) 
11ce					ld c,a 
11ce					ld a, (de) 
11ce					ld (hl), a 
11ce					ld a,c 
11ce					ld (de),a 
11ce					inc hl 
11ce					inc de 
11ce					djnz .swap1 
11ce			 
11ce			 
11ce			 
11ce			 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk3:		cp KEY_BS 
11ce					jr nz, .isk4 
11ce			 
11ce					ld a, (input_cursor) 
11ce			 
11ce					cp 0 
11ce					jp z, .is1 		; at start of line to ignore  
11ce			 
11ce					dec  a 		; TODO check underflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					; hl is source 
11ce					; de needs to be source - 1 
11ce			 
11ce			;		ld a, 0 
11ce			;		dec hl 
11ce			;		ld (hl), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					dec hl 
11ce					ld (input_ptr), hl 
11ce			 
11ce					; shift all data 
11ce			 
11ce					push hl 
11ce					inc hl 
11ce					pop de 
11ce					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11ce					ld c,a 
11ce					ld b,0 
11ce					ldir  
11ce			 
11ce			 
11ce			 
11ce			 
11ce					ld a, (input_at_cursor) 
11ce					dec a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce			 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce			 
11ce					; remove char 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld de,.iblank 
11ce					call str_at_display 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.isk4:		cp KEY_CR 
11ce					jr z, .endinput 
11ce			 
11ce					; else add the key press to the end 
11ce			 
11ce					ld c, a			; save key pressed 
11ce			 
11ce					ld a,(hl)		; get what is currently under char 
11ce			 
11ce					cp 0			; we are at the end of the string 
11ce					jr nz, .onchar 
11ce					 
11ce					; add a char to the end of the string 
11ce				 
11ce					ld (hl),c 
11ce					inc hl 
11ce			;		ld a,' ' 
11ce			;		ld (hl),a 
11ce			;		inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce					dec hl 
11ce			 
11ce					ld a, (input_cursor) 
11ce					inc a				; TODO check max string length and scroll  
11ce					ld (input_cursor), a		; inc cursor pos 
11ce							 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					inc hl 
11ce					ld (input_ptr), hl 
11ce			;	if DEBUG_INPUT 
11ce			;		push af 
11ce			;		ld a, '+' 
11ce			;		ld (debug_mark),a 
11ce			;		pop af 
11ce			;		CALLMONITOR 
11ce			;	endif 
11ce					ld a, 1		; show cursor moving 
11ce					ld (input_cur_onoff),a 
11ce					ld a, CUR_BLINK_RATE 
11ce					ld (input_cur_flash), a 
11ce					jp .is1 
11ce					 
11ce			 
11ce			 
11ce					; if on a char then insert 
11ce			.onchar: 
11ce			 
11ce					; TODO over flow check: make sure insert does not blow out buffer 
11ce			 
11ce					; need to do some maths to use lddr 
11ce			 
11ce					push hl   ; save char pos 
11ce					push bc 
11ce			 
11ce					ld hl, (input_start) 
11ce					ld a, (input_len) 
11ce					call addatohl  		; end of string 
11ce					inc hl 
11ce					inc hl		; past zero term 
11ce					push hl 
11ce					inc hl 
11ce					push hl  
11ce			 
11ce								; start and end of lddr set, now how much to move? 
11ce			 
11ce							 
11ce					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11ce					ld b,a 
11ce					ld a,(input_len) 
11ce					ld e,a 
11ce					sub b 
11ce					inc a		;?? 
11ce					inc a		;?? 
11ce					inc a		;?? 
11ce			 
11ce					ld b,0 
11ce					ld c,a 
11ce			 
11ce				if DEBUG_INPUT 
11ce					push af 
11ce					ld a, 'i' 
11ce					ld (debug_mark),a 
11ce					pop af 
11ce			;		CALLMONITOR 
11ce				endif 
11ce					pop de 
11ce					pop hl 
11ce				if DEBUG_INPUT 
11ce					push af 
11ce					ld a, 'I' 
11ce					ld (debug_mark),a 
11ce					pop af 
11ce			;		CALLMONITOR 
11ce				endif 
11ce					lddr 
11ce				 
11ce			 
11ce			 
11ce					; TODO have a key for insert/overwrite mode???? 
11ce					pop bc 
11ce					pop hl 
11ce					ld (hl), c		; otherwise overwrite current char 
11ce					 
11ce			 
11ce			 
11ce			 
11ce					ld a, (input_cursor) 
11ce					inc  a 		; TODO check overflow 
11ce					ld (input_cursor), a 
11ce			 
11ce					ld a, (input_at_cursor) 
11ce					inc a 
11ce					ld (input_at_cursor), a 
11ce			 
11ce					jp .is1 
11ce			 
11ce			.endinput:	; TODO look for end of string 
11ce			 
11ce					; add trailing space for end of token 
11ce			 
11ce					ld hl, (input_start) 
11ce					ld a,(input_len) 
11ce					call addatohl 
11ce					ld a, ' ' 
11ce					ld (hl),a 
11ce					; TODO eof of parse marker 
11ce			 
11ce					inc hl 
11ce					ld a, 0 
11ce					ld (hl),a 
11ce			 
11ce			 
11ce					ret 
11ce			 
11ce			.iblank: db " ",0 
11ce			 
11ce			 
11ce			input_str_prev:	ld (input_at_pos), a 
11ce					ld (input_start), hl 
11ce					ld a,1			; add cursor 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce					ld (input_ptr), hl 
11ce					ld a,d 
11ce					ld (input_size), a 
11ce					ld a,0 
11ce					ld (input_cursor),a 
11ce			.instr1:	 
11ce			 
11ce					; TODO do block cursor 
11ce					; TODO switch cursor depending on the modifer key 
11ce			 
11ce					; update cursor shape change on key hold 
11ce			 
11ce					ld hl, (input_ptr) 
11ce					dec hl 
11ce					ld a,(cursor_shape) 
11ce					ld (hl), a 
11ce			 
11ce					; display entered text 
11ce					ld a,(input_at_pos) 
11ce			            	CALL fLCD_Pos       ;Position cursor to location in A 
11ce			            	LD   de, (input_start) 
11ce			            	CALL fLCD_Str       ;Display string pointed to by DE 
11ce			 
11ce					call cin 
11ce					cp 0 
11ce					jr z, .instr1 
11ce			 
11ce					; proecess keyboard controls first 
11ce			 
11ce					ld hl,(input_ptr) 
11ce			 
11ce					cp KEY_CR	 ; pressing enter ends input 
11ce					jr z, .instrcr 
11ce			 
11ce					cp KEY_BS 	; back space 
11ce					jr nz, .instr2 
11ce					; process back space 
11ce			 
11ce					; TODO stop back space if at start of string 
11ce					dec hl 
11ce					dec hl ; to over write cursor 
11ce					ld a,(cursor_shape) 
11ce					;ld a,0 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a," " 
11ce					ld (hl),a 
11ce					ld (input_ptr),hl 
11ce					 
11ce			 
11ce					jr .instr1 
11ce			 
11ce			.instr2:	cp KEY_LEFT    ; cursor left 
11ce					jr nz, .instr3 
11ce					dec hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce				 
11ce			.instr3:	cp KEY_RIGHT      ; cursor right 
11ce					jr nz, .instr4 
11ce					inc hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce			 
11ce			.instr4:	cp KEY_HOME    ; jump to start of line 
11ce					jr nz, .instr5 
11ce					dec hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce			 
11ce			.instr5:	cp KEY_END     ; jump to end of line 
11ce					jr nz, .instr6 
11ce					dec hl 
11ce					ld (input_ptr),hl 
11ce					jr .instr1 
11ce			.instr6:        cp KEY_UP      ; recall last command 
11ce					jr nz, .instrnew 
11ce			 
11ce				ld hl, scratch 
11ce				ld de, os_last_cmd 
11ce				call strcpy 
11ce					jr .instr1 
11ce			 
11ce			 
11ce			.instrnew:	; no special key pressed to see if we have room to store it 
11ce			 
11ce					; TODO do string size test 
11ce			 
11ce					dec hl ; to over write cursor 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,(cursor_shape) 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce			 
11ce					ld (input_ptr),hl 
11ce					 
11ce					jr .instr1 
11ce			.instrcr:	dec hl		; remove cursor 
11ce					ld a,' '	; TODO add a trailing space for safety 
11ce					ld (hl),a 
11ce					inc hl 
11ce					ld a,0 
11ce					ld (hl),a 
11ce			 
11ce			 
11ce					; if at end of line scroll up    
11ce					; TODO detecting only end of line 4 for scroll up  
11ce			 
11ce					;ld   
11ce			 
11ce					ret 
11ce			 
11ce			 
11ce			endif 
11ce			; strcpy hl = dest, de source 
11ce			 
11ce 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11cf b7			            OR   A              ;Null terminator? 
11d0 c8			            RET  Z              ;Yes, so finished 
11d1 1a					ld a,(de) 
11d2 77					ld (hl),a 
11d3 13			            INC  DE             ;Point to next character 
11d4 23					inc hl 
11d5 18 f7		            JR   strcpy       ;Repeat 
11d7 c9					ret 
11d8			 
11d8			 
11d8			; TODO string_at  
11d8			; pass string which starts with lcd offset address and then null term string 
11d8			 
11d8			; TODO string to dec 
11d8			; TODO string to hex 
11d8			; TODO byte to string hex 
11d8			; TODO byte to string dec 
11d8			 
11d8			 
11d8			 
11d8			; from z80uartmonitor 
11d8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11d8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11d8			; pass hl for where to put the text 
11d8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11d8 c5			hexout:	PUSH BC 
11d9 f5					PUSH AF 
11da 47					LD B, A 
11db					; Upper nybble 
11db cb 3f				SRL A 
11dd cb 3f				SRL A 
11df cb 3f				SRL A 
11e1 cb 3f				SRL A 
11e3 cd f3 11				CALL tohex 
11e6 77					ld (hl),a 
11e7 23					inc hl	 
11e8					 
11e8					; Lower nybble 
11e8 78					LD A, B 
11e9 e6 0f				AND 0FH 
11eb cd f3 11				CALL tohex 
11ee 77					ld (hl),a 
11ef 23					inc hl	 
11f0					 
11f0 f1					POP AF 
11f1 c1					POP BC 
11f2 c9					RET 
11f3					 
11f3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11f3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11f3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11f3			tohex: 
11f3 e5					PUSH HL 
11f4 d5					PUSH DE 
11f5 16 00				LD D, 0 
11f7 5f					LD E, A 
11f8 21 00 12				LD HL, .DATA 
11fb 19					ADD HL, DE 
11fc 7e					LD A, (HL) 
11fd d1					POP DE 
11fe e1					POP HL 
11ff c9					RET 
1200			 
1200			.DATA: 
1200 30					DEFB	30h	; 0 
1201 31					DEFB	31h	; 1 
1202 32					DEFB	32h	; 2 
1203 33					DEFB	33h	; 3 
1204 34					DEFB	34h	; 4 
1205 35					DEFB	35h	; 5 
1206 36					DEFB	36h	; 6 
1207 37					DEFB	37h	; 7 
1208 38					DEFB	38h	; 8 
1209 39					DEFB	39h	; 9 
120a 41					DEFB	41h	; A 
120b 42					DEFB	42h	; B 
120c 43					DEFB	43h	; C 
120d 44					DEFB	44h	; D 
120e 45					DEFB	45h	; E 
120f 46					DEFB	46h	; F 
1210			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1210			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1210			;;    subtract $30, if result > 9 then subtract $7 more 
1210			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1210			atohex: 
1210 d6 30				SUB $30 
1212 fe 0a				CP 10 
1214 f8					RET M		; If result negative it was 0-9 so we're done 
1215 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1217 c9					RET		 
1218			 
1218			 
1218			 
1218			 
1218			; Get 2 ASCII characters as hex byte from pointer in hl 
1218			 
1218			BYTERD: 
1218 16 00			LD	D,00h		;Set up 
121a cd 22 12			CALL	HEXCON		;Get byte and convert to hex 
121d 87				ADD	A,A		;First nibble so 
121e 87				ADD	A,A		;multiply by 16 
121f 87				ADD	A,A		; 
1220 87				ADD	A,A		; 
1221 57				LD	D,A		;Save hi nibble in D 
1222			HEXCON: 
1222 7e				ld a, (hl)		;Get next chr 
1223 23				inc hl 
1224 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1226 fe 0a			CP	00Ah		;Is it 0-9 ? 
1228 38 02			JR	C,NALPHA	;If so miss next bit 
122a d6 07			SUB	007h		;Else convert alpha 
122c			NALPHA: 
122c b2				OR	D		;Add hi nibble back 
122d c9				RET			; 
122e			 
122e			 
122e			; 
122e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
122e			; Since the routines get_byte and therefore get_nibble are called, only valid 
122e			; characters (0-9a-f) are accepted. 
122e			; 
122e			;get_word        push    af 
122e			;                call    get_byte        ; Get the upper byte 
122e			;                ld      h, a 
122e			;                call    get_byte        ; Get the lower byte 
122e			;                ld      l, a 
122e			;                pop     af 
122e			;                ret 
122e			; 
122e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
122e			; the routine get_nibble is used only valid characters are accepted - the  
122e			; input routine only accepts characters 0-9a-f. 
122e			; 
122e c5			get_byte:        push    bc              ; Save contents of B (and C) 
122f 7e					ld a,(hl) 
1230 23					inc hl 
1231 cd 56 12		                call    nibble2val      ; Get upper nibble 
1234 cb 07		                rlc     a 
1236 cb 07		                rlc     a 
1238 cb 07		                rlc     a 
123a cb 07		                rlc     a 
123c 47			                ld      b, a            ; Save upper four bits 
123d 7e					ld a,(hl) 
123e cd 56 12		                call    nibble2val      ; Get lower nibble 
1241 b0			                or      b               ; Combine both nibbles 
1242 c1			                pop     bc              ; Restore B (and C) 
1243 c9			                ret 
1244			; 
1244			; Get a hexadecimal digit from the serial line. This routine blocks until 
1244			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1244			; to the serial line interface. The lower 4 bits of A contain the value of  
1244			; that particular digit. 
1244			; 
1244			;get_nibble      ld a,(hl)           ; Read a character 
1244			;                call    to_upper        ; Convert to upper case 
1244			;                call    is_hex          ; Was it a hex digit? 
1244			;                jr      nc, get_nibble  ; No, get another character 
1244			 ;               call    nibble2val      ; Convert nibble to value 
1244			 ;               call    print_nibble 
1244			 ;               ret 
1244			; 
1244			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1244			; A valid hexadecimal digit is denoted by a set C flag. 
1244			; 
1244			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1244			;                ret     nc              ; Yes 
1244			;                cp      '0'             ; Less than '0'? 
1244			;                jr      nc, is_hex_1    ; No, continue 
1244			;                ccf                     ; Complement carry (i.e. clear it) 
1244			;                ret 
1244			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1244			;                ret     c               ; Yes 
1244			;                cp      'A'             ; Less than 'A'? 
1244			;                jr      nc, is_hex_2    ; No, continue 
1244			;                ccf                     ; Yes - clear carry and return 
1244			;                ret 
1244			;is_hex_2        scf                     ; Set carry 
1244			;                ret 
1244			; 
1244			; Convert a single character contained in A to upper case: 
1244			; 
1244 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1246 d8			                ret     c 
1247 fe 7b		                cp      'z' + 1         ; > 'z'? 
1249 d0			                ret     nc              ; Nothing to do, either 
124a e6 5f		                and     $5f             ; Convert to upper case 
124c c9			                ret 
124d			 
124d			 
124d			to_lower: 
124d			 
124d			   ; if char is in [A-Z] make it lower case 
124d			 
124d			   ; enter : a = char 
124d			   ; exit  : a = lower case char 
124d			   ; uses  : af 
124d			 
124d fe 41		   cp 'A' 
124f d8			   ret c 
1250			    
1250 fe 5b		   cp 'Z'+1 
1252 d0			   ret nc 
1253			    
1253 f6 20		   or $20 
1255 c9			   ret 
1256			 
1256			; 
1256			; Expects a hexadecimal digit (upper case!) in A and returns the 
1256			; corresponding value in A. 
1256			; 
1256 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1258 38 02		                jr      c, nibble2val_1 ; Yes 
125a d6 07		                sub     7               ; Adjust for A-F 
125c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
125e e6 0f		                and     $f              ; Only return lower 4 bits 
1260 c9			                ret 
1261			; 
1261			; Print_nibble prints a single hex nibble which is contained in the lower  
1261			; four bits of A: 
1261			; 
1261			;print_nibble    push    af              ; We won't destroy the contents of A 
1261			;                and     $f              ; Just in case... 
1261			;                add     a, '0'             ; If we have a digit we are done here. 
1261			;                cp      '9' + 1         ; Is the result > 9? 
1261			;                jr      c, print_nibble_1 
1261			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1261			;print_nibble_1  call    putc            ; Print the nibble and 
1261			;                pop     af              ; restore the original value of A 
1261			;                ret 
1261			;; 
1261			;; Send a CR/LF pair: 
1261			; 
1261			;crlf            push    af 
1261			;                ld      a, cr 
1261			;                call    putc 
1261			;                ld      a, lf 
1261			;                call    putc 
1261			;                pop     af 
1261			;                ret 
1261			; 
1261			; Print_word prints the four hex digits of a word to the serial line. The  
1261			; word is expected to be in HL. 
1261			; 
1261			;print_word      push    hl 
1261			;                push    af 
1261			;                ld      a, h 
1261			;                call    print_byte 
1261			;                ld      a, l 
1261			;                call    print_byte 
1261			;                pop     af 
1261			;                pop     hl 
1261			;                ret 
1261			; 
1261			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1261			; The byte to be printed is expected to be in A. 
1261			; 
1261			;print_byte      push    af              ; Save the contents of the registers 
1261			;                push    bc 
1261			;                ld      b, a 
1261			;                rrca 
1261			;                rrca 
1261			;                rrca 
1261			;                rrca 
1261			;                call    print_nibble    ; Print high nibble 
1261			;                ld      a, b 
1261			;                call    print_nibble    ; Print low nibble 
1261			;                pop     bc              ; Restore original register contents 
1261			;                pop     af 
1261			;                ret 
1261			 
1261			 
1261			 
1261			 
1261			 
1261			fourehexhl:  
1261 7e				ld a,(hl) 
1262 cd 10 12			call atohex 
1265 cb 3f				SRL A 
1267 cb 3f				SRL A 
1269 cb 3f				SRL A 
126b cb 3f				SRL A 
126d 47				ld b, a 
126e 23				inc hl 
126f 7e				ld a,(hl) 
1270 23				inc hl 
1271 cd 10 12			call atohex 
1274 80				add b 
1275 57				ld d,a 
1276 7e				ld a,(hl) 
1277 cd 10 12			call atohex 
127a cb 3f				SRL A 
127c cb 3f				SRL A 
127e cb 3f				SRL A 
1280 cb 3f				SRL A 
1282 47				ld b, a 
1283 23				inc hl 
1284 7e				ld a,(hl) 
1285 23				inc hl 
1286 cd 10 12			call atohex 
1289 80				add b 
128a 5f				ld e, a 
128b d5				push de 
128c e1				pop hl 
128d c9				ret 
128e			 
128e			; pass hl. returns z set if the byte at hl is a digit 
128e			;isdigithl:  
128e			;	push bc 
128e			;	ld a,(hl) 
128e			;	cp ':' 
128e			;	jr nc, .isdf 		; > 
128e			;	cp '0' 
128e			;	jr c, .isdf		; < 
128e			; 
128e			;	; TODO find a better way to set z 
128e			; 
128e			;	ld b,a 
128e			;	cp b 
128e			;	pop bc 
128e			;	ret 
128e			; 
128e			;.isdf:	; not digit so clear z 
128e			; 
128e			;	; TODO find a better way to unset z 
128e			; 
128e			;	ld b,a 
128e			;	inc b 
128e			;	cp b 
128e			; 
128e			;	pop bc 
128e			;	ret 
128e				 
128e				 
128e			 
128e			 
128e			; pass hl as the four byte address to load 
128e			 
128e			get_word_hl:  
128e e5				push hl 
128f cd 2e 12			call get_byte 
1292				 
1292 47				ld b, a 
1293			 
1293 e1				pop hl 
1294 23				inc hl 
1295 23				inc hl 
1296			 
1296			; TODO not able to handle a-f  
1296 7e				ld a,(hl) 
1297			;	;cp ':' 
1297			;	cp 'g' 
1297			;	jr nc, .single_byte_hl 		; > 
1297			;	cp 'G' 
1297			;	jr nc, .single_byte_hl 		; > 
1297			;	cp '0' 
1297			;	jr c, .single_byte_hl		; < 
1297			 
1297				;call isdigithl 
1297 fe 00			cp 0 
1299 28 06			jr z, .single_byte_hl 
129b			 
129b			.getwhln:   ; hex word so get next byte 
129b			 
129b cd 2e 12			call get_byte 
129e 6f				ld l, a 
129f 60				ld h,b 
12a0 c9				ret 
12a1 68			.single_byte_hl:   ld l,b 
12a2 26 00				ld h,0 
12a4 c9					ret 
12a5			 
12a5			 
12a5			 
12a5			 
12a5 21 12 1d			ld hl,asc+1 
12a8			;	ld a, (hl) 
12a8			;	call nibble2val 
12a8 cd 2e 12			call get_byte 
12ab			 
12ab			;	call fourehexhl 
12ab 32 30 f1			ld (scratch+52),a 
12ae				 
12ae 21 2e f1			ld hl,scratch+50 
12b1 22 1f f4			ld (os_cur_ptr),hl 
12b4			 
12b4 c9				ret 
12b5			 
12b5			 
12b5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12b5			 
12b5			; Decimal Unsigned Version 
12b5			 
12b5			;Number in a to decimal ASCII 
12b5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12b5			;Example: display a=56 as "056" 
12b5			;input: a = number 
12b5			;Output: a=0,value of a in the screen 
12b5			;destroys af,bc (don't know about hl and de) 
12b5			DispAToASCII: 
12b5 0e 9c			ld	c,-100 
12b7 cd c1 12			call	.Na1 
12ba 0e f6			ld	c,-10 
12bc cd c1 12			call	.Na1 
12bf 0e ff			ld	c,-1 
12c1 06 2f		.Na1:	ld	b,'0'-1 
12c3 04			.Na2:	inc	b 
12c4 81				add	a,c 
12c5 38 fc			jr	c,.Na2 
12c7 91				sub	c		;works as add 100/10/1 
12c8 f5				push af		;safer than ld c,a 
12c9 78				ld	a,b		;char is in b 
12ca			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12ca f1				pop af		;safer than ld a,c 
12cb c9				ret 
12cc			 
12cc			; Decimal Signed Version 
12cc			 
12cc			; DispA 
12cc			; -------------------------------------------------------------- 
12cc			; Converts a signed integer value to a zero-terminated ASCII 
12cc			; string representative of that value (using radix 10). 
12cc			; -------------------------------------------------------------- 
12cc			; INPUTS: 
12cc			;     HL     Value to convert (two's complement integer). 
12cc			;     DE     Base address of string destination. (pointer). 
12cc			; -------------------------------------------------------------- 
12cc			; OUTPUTS: 
12cc			;     None 
12cc			; -------------------------------------------------------------- 
12cc			; REGISTERS/MEMORY DESTROYED 
12cc			; AF HL 
12cc			; -------------------------------------------------------------- 
12cc			 
12cc			;DispHLToASCII: 
12cc			;   push    de 
12cc			;   push    bc 
12cc			; 
12cc			;; Detect sign of HL. 
12cc			;    bit    7, h 
12cc			;    jr     z, ._DoConvert 
12cc			; 
12cc			;; HL is negative. Output '-' to string and negate HL. 
12cc			;    ld     a, '-' 
12cc			;    ld     (de), a 
12cc			;    inc    de 
12cc			; 
12cc			;; Negate HL (using two's complement) 
12cc			;    xor    a 
12cc			;    sub    l 
12cc			;    ld     l, a 
12cc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12cc			;    sbc    a, h 
12cc			;    ld     h, a 
12cc			; 
12cc			;; Convert HL to digit characters 
12cc			;._DoConvert: 
12cc			;    ld     b, 0     ; B will count character length of number 
12cc			;-   ld     a, 10 
12cc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12cc			;    push   af 
12cc			;    inc    b 
12cc			;    ld     a, h 
12cc			;    or     l 
12cc			;    jr     nz, - 
12cc			; 
12cc			;; Retrieve digits from stack 
12cc			;-   pop    af 
12cc			;    or     $30 
12cc			;    ld     (de), a 
12cc			;    inc    de 
12cc			;    djnz   - 
12cc			; 
12cc			;; Terminate string with NULL 
12cc			;    xor    a 
12cc			;    ld     (de), a 
12cc			; 
12cc			;    pop    bc 
12cc			;    pop    de 
12cc			;    ret 
12cc			 
12cc			;Comments 
12cc			; 
12cc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12cc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12cc			;    Note that the output string will not be fixed-width. 
12cc			; 
12cc			;Example Usage 
12cc			; 
12cc			;    ld    hl, -1004 
12cc			;    ld    de, OP1 
12cc			;    call  DispA 
12cc			;    ld    hl, OP1 
12cc			;    syscall  PutS 
12cc			 
12cc			 
12cc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12cc			 
12cc			 
12cc			;Converts an ASCII string to an unsigned 16-bit integer 
12cc			;Quits when it reaches a non-decimal digit 
12cc			 
12cc			string_to_uint16: 
12cc			atoui_16: 
12cc			;Input: 
12cc			;     DE points to the string 
12cc			;Outputs: 
12cc			;     HL is the result 
12cc			;     A is the 8-bit value of the number 
12cc			;     DE points to the byte after the number 
12cc			;Destroys: 
12cc			;     BC 
12cc			;       if the string is non-empty, BC is HL/10 
12cc			;Size:  24 bytes 
12cc			;Speed: 42+d(104+{0,9}) 
12cc			;       d is the number of digits in the number 
12cc			;       max is 640 cycles for a 5 digit number 
12cc			;Assuming no leading zeros: 
12cc			;1 digit:  146cc 
12cc			;2 digit:  250cc 
12cc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12cc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12cc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12cc			;avg: 544.81158447265625cc (544+13297/16384) 
12cc			;=============================================================== 
12cc 21 00 00		  ld hl,0 
12cf			.u16a: 
12cf 1a			  ld a,(de) 
12d0 d6 30		  sub 30h 
12d2 fe 0a		  cp 10 
12d4 d0			  ret nc 
12d5 13			  inc de 
12d6 44			  ld b,h 
12d7 4d			  ld c,l 
12d8 29			  add hl,hl 
12d9 29			  add hl,hl 
12da 09			  add hl,bc 
12db 29			  add hl,hl 
12dc 85			  add a,l 
12dd 6f			  ld l,a 
12de 30 ef		  jr nc,.u16a 
12e0 24			  inc h 
12e1 c3 cf 12		  jp .u16a 
12e4			 
12e4			 
12e4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12e4			 
12e4			;written by Zeda 
12e4			;Converts a 16-bit unsigned integer to an ASCII string. 
12e4			 
12e4			uitoa_16: 
12e4			;Input: 
12e4			;   DE is the number to convert 
12e4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12e4			;Output: 
12e4			;   HL points to the null-terminated ASCII string 
12e4			;      NOTE: This isn't necessarily the same as the input HL. 
12e4 d5			  push de 
12e5 c5			  push bc 
12e6 f5			  push af 
12e7 eb			  ex de,hl 
12e8			 
12e8 01 f0 d8		  ld bc,-10000 
12eb 3e 2f		  ld a,'0'-1 
12ed 3c			  inc a 
12ee 09			  add hl,bc  
12ef 38 fc		   jr c,$-2 
12f1 12			  ld (de),a 
12f2 13			  inc de 
12f3			 
12f3 01 e8 03		  ld bc,1000 
12f6 3e 3a		  ld a,'9'+1 
12f8 3d			  dec a  
12f9 09			  add hl,bc  
12fa 30 fc		   jr nc,$-2 
12fc 12			  ld (de),a 
12fd 13			  inc de 
12fe			 
12fe 01 9c ff		  ld bc,-100 
1301 3e 2f		  ld a,'0'-1 
1303 3c			  inc a  
1304 09			  add hl,bc  
1305 38 fc		   jr c,$-2 
1307 12			  ld (de),a 
1308 13			  inc de 
1309			 
1309 7d			  ld a,l 
130a 26 3a		  ld h,'9'+1 
130c 25			  dec h  
130d c6 0a		  add a,10  
130f 30 fb		   jr nc,$-3 
1311 c6 30		  add a,'0' 
1313 eb			  ex de,hl 
1314 72			  ld (hl),d 
1315 23			  inc hl 
1316 77			  ld (hl),a 
1317 23			  inc hl 
1318 36 00		  ld (hl),0 
131a			 
131a			;Now strip the leading zeros 
131a 0e fa		  ld c,-6 
131c 09			  add hl,bc 
131d 3e 30		  ld a,'0' 
131f 23			  inc hl  
1320 be			  cp (hl)  
1321 28 fc		  jr z,$-2 
1323			 
1323			;Make sure that the string is non-empty! 
1323 7e			  ld a,(hl) 
1324 b7			  or a 
1325 20 01		  jr nz,.atoub 
1327 2b			  dec hl 
1328			.atoub: 
1328			 
1328 f1			  pop af 
1329 c1			  pop bc 
132a d1			  pop de 
132b c9			  ret 
132c			 
132c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
132c			 
132c			toUpper: 
132c			;A is the char. 
132c			;If A is a lowercase letter, this sets it to the matching uppercase 
132c			;18cc or 30cc or 41cc 
132c			;avg: 26.75cc 
132c fe 61		  cp 'a' 
132e d8			  ret c 
132f fe 7b		  cp 'z'+1 
1331 d0			  ret nc 
1332 d6 20		  sub 'a'-'A' 
1334 c9			  ret 
1335			 
1335			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1335			 
1335			; String Length 
1335			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1335			 
1335			; Get the length of the null-terminated string starting at $8000 hl 
1335			;    LD     HL, $8000 
1335			 
1335			strlenz: 
1335			 
1335 af			    XOR    A               ; Zero is the value we are looking for. 
1336 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1337 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1338			                           ; 65, 536 bytes (the entire addressable memory space). 
1338 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
133a			 
133a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
133a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
133b 6f			    LD     L, A             ; number of bytes 
133c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
133e 2b			    DEC    HL              ; Compensate for null. 
133f c9				ret 
1340			 
1340			; Get the length of the A terminated string starting at $8000 hl 
1340			;    LD     HL, $8000 
1340			 
1340			strlent: 
1340			 
1340			                  ; A is the value we are looking for. 
1340 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1342 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1344			                           ; 65, 536 bytes (the entire addressable memory space). 
1344 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1346			 
1346			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1346 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1348 2e 00		    LD     L, 0             ; number of bytes 
134a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134c 2b			    DEC    HL              ; Compensate for null. 
134d c9				ret 
134e			 
134e			 
134e			;Comparing Strings 
134e			 
134e			;IN    HL     Address of string1. 
134e			;      DE     Address of string2. 
134e			 
134e			; doc given but wrong??? 
134e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
134e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
134e			; tested 
134e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
134e			 
134e			strcmp_old: 
134e e5			    PUSH   HL 
134f d5			    PUSH   DE 
1350			 
1350 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1351 be			    CP     (HL)            ; (want to minimize work). 
1352 38 01		    JR     C, Str1IsBigger 
1354 7e			    LD     A, (HL) 
1355			 
1355			Str1IsBigger: 
1355 4f			    LD     C, A             ; Put length in BC 
1356 06 00		    LD     B, 0 
1358 13			    INC    DE              ; Increment pointers to meat of string. 
1359 23			    INC    HL 
135a			 
135a			CmpLoop: 
135a 1a			    LD     A, (DE)          ; Compare bytes. 
135b ed a1		    CPI 
135d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
135f 13			    INC    DE              ; Update pointer. 
1360 ea 5a 13		    JP     PE, CmpLoop 
1363			 
1363 d1			    POP    DE 
1364 e1			    POP    HL 
1365 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1366 be			    CP     (HL) 
1367 c9			    RET 
1368			 
1368			NoMatch: 
1368 2b			    DEC    HL 
1369 be			    CP     (HL)            ; Compare again to affect carry. 
136a d1			    POP    DE 
136b e1			    POP    HL 
136c c9			    RET 
136d			 
136d			;; test strmp 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str2 
136d			;call strcmp 
136d			;jr z, .z1 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "NZ1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.z1: 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "ZZ1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str1 
136d			;call strcmp 
136d			;jr z, .z2 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "NZ2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.z2: 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "ZZ2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str2 
136d			;call strcmp 
136d			;jr c, .c1 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "Nc1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.c1: 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "cc1" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			; 
136d			;ld de, .str1 
136d			;ld hl, .str1 
136d			;call strcmp 
136d			;jr c, .c2 
136d			;;this 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "Nc2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;.c2: 
136d			; 
136d			;	if DEBUG_FORTH_WORDS 
136d			;		DMARK "cc2" 
136d			;		CALLMONITOR 
136d			;	endif 
136d			;	NEXTW 
136d			;.str1:   db "string1",0 
136d			;.str2:   db "string2",0 
136d			 
136d			; only care about direct match or not 
136d			; hl and de strings 
136d			; zero set if the same 
136d			 
136d			strcmp: 
136d 1a				ld a, (de) 
136e be				cp (hl) 
136f 28 02			jr z, .ssame 
1371 b7				or a 
1372 c9				ret 
1373			 
1373			.ssame:  
1373 fe 00			cp 0 
1375 c8				ret z 
1376			 
1376 23				inc hl 
1377 13				inc de 
1378 18 f3			jr strcmp 
137a				 
137a				 
137a			 
137a			;Copyright (c) 2014, Luke Maurits 
137a			;All rights reserved. 
137a			; 
137a			;Redistribution and use in source and binary forms, with or without 
137a			;modification, are permitted provided that the following conditions are met: 
137a			; 
137a			;* Redistributions of source code must retain the above copyright notice, this 
137a			;  list of conditions and the following disclaimer. 
137a			; 
137a			;* Redistributions in binary form must reproduce the above copyright notice, 
137a			;  this list of conditions and the following disclaimer in the documentation 
137a			;  and/or other materials provided with the distribution. 
137a			; 
137a			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
137a			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
137a			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
137a			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
137a			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
137a			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
137a			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
137a			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
137a			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
137a			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
137a			 
137a			; https://github.com/lmaurits/lm512/blob/master/string.z80 
137a			 
137a			StrictStrCmp: 
137a				; Load next chars of each string 
137a 1a				ld a, (de) 
137b 47				ld b, a 
137c 7e				ld a, (hl) 
137d				; Compare 
137d b8				cp b 
137e				; Return non-zero if chars don't match 
137e c0				ret nz 
137f				; Check for end of both strings 
137f fe 00			cp "\0" 
1381				; Return if strings have ended 
1381 c8				ret z 
1382				; Otherwise, advance to next chars 
1382 23				inc hl 
1383 13				inc de 
1384 18 f4			jr StrictStrCmp 
1386			 
1386			;end 
1386			; eof 
1386			 
1386			 
1386			 
1386			 
1386			 
1386			 
# End of file firmware_strings.asm
1386			include "firmware_memory.asm"   ; malloc and free  
1386			 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			.mallocsize: db "Wants malloc >256",0 
1386			.mallocasize: db "MALLOC gives >256",0 
1386			.malloczero: db "MALLOC gives zero",0 
1386			 
1386			malloc_guard_zerolen: 
1386				push hl 
1386				push de 
1386				push af 
1386			 
1386				ld de, 0 
1386			        call cmp16 
1386				jr nz, .lowalloz 
1386			 
1386				push hl 
1386				push de 
1386					ld hl, display_fb0 
1386					ld (display_fb_active), hl 
1386				call clear_display 
1386				ld a, 0 
1386				ld de, .malloczero 
1386				call str_at_display 
1386				call update_display 
1386				call delay1s 
1386				call delay1s 
1386				call bp_on 
1386			;	ld a, 0 
1386			;	ld (os_view_disable), a 
1386			 
1386				pop de 
1386				pop hl 
1386			 
1386				 
1386			 
1386				CALLMONITOR 
1386			.lowalloz: 
1386			 
1386			 
1386				pop af 
1386				pop de 
1386				pop hl 
1386			ret 
1386			 
1386			malloc_guard_entry: 
1386				push hl 
1386				push de 
1386				push af 
1386			 
1386			 	or a      ;clear carry flag 
1386				push hl 
1386				ld de, 255 
1386				sbc hl, de 
1386				jr c, .lowalloc 
1386			 
1386				push de 
1386					ld hl, display_fb0 
1386					ld (display_fb_active), hl 
1386				call clear_display 
1386				ld a, 0 
1386				ld de, .mallocsize 
1386				call str_at_display 
1386				call update_display 
1386				call delay1s 
1386				call delay1s 
1386			;	ld a, 0 
1386			;	ld (os_view_disable), a 
1386				call bp_on 
1386			 
1386				pop de 
1386				pop hl 
1386			 
1386				 
1386			 
1386				CALLMONITOR 
1386				jr .lowdone 
1386			.lowalloc: 
1386			 
1386			 
1386				pop hl 
1386			.lowdone:	pop af 
1386				pop de 
1386				pop hl 
1386			ret 
1386			 
1386			malloc_guard_exit: 
1386				push hl 
1386				push de 
1386				push af 
1386			 
1386			 	or a      ;clear carry flag 
1386				push hl 
1386				ld de, 255 
1386				sbc hl, de 
1386				jr c, .lowallocx 
1386			 
1386				push de 
1386					ld hl, display_fb0 
1386					ld (display_fb_active), hl 
1386				call clear_display 
1386				ld a, 0 
1386				ld de, .mallocasize 
1386				call str_at_display 
1386				call update_display 
1386				call delay1s 
1386				call delay1s 
1386			;	ld a, 0 
1386			;	ld (os_view_disable), a 
1386				call bp_on 
1386				pop de 
1386				pop hl 
1386			 
1386				CALLMONITOR 
1386				jr .lowdonex 
1386			.lowallocx: 
1386			 
1386				pop hl 
1386			.lowdonex:	pop af 
1386				pop de 
1386				pop hl 
1386			ret 
1386			endif 
1386			 
1386			if MALLOC_2 
1386			; Z80 Malloc and Free Functions 
1386			 
1386			; Malloc Function: 
1386			; Input: 
1386			;   HL: Size of block to allocate 
1386			; Output: 
1386			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1386			 
1386			malloc: 
1386				 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			call malloc_guard_entry 
1386			endif 
1386			 
1386			 
1386			 
1386			 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "mal" 
1386						CALLMONITOR 
1386					endif 
1386			    push af            ; Save AF register 
1386			    ld a, l            ; Load low byte of size into A 
1386			    or h               ; Check if size is zero 
1386			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1386			 
1386			    ; Allocate memory 
1386			    ld hl, (heap_start) ; Load start of heap into HL 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "ma1" 
1386						CALLMONITOR 
1386					endif 
1386			    call malloc_internal ; Call internal malloc function 
1386			    pop af             ; Restore AF register 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret                ; Return 
1386			 
1386			; Free Function: 
1386			; Input: 
1386			;   HL: Pointer to memory block to free 
1386			; Output: 
1386			;   None 
1386			 
1386			free: 
1386			    push af            ; Save AF register 
1386			    ld a, l            ; Load low byte of pointer into A 
1386			    or h               ; Check if pointer is NULL 
1386			    jp z, free_exit    ; If pointer is NULL, exit 
1386			 
1386			    ; Free memory 
1386			    ld hl, (heap_start) ; Load start of heap into HL 
1386			    call free_internal  ; Call internal free function 
1386			    pop af             ; Restore AF register 
1386			    ret                ; Return 
1386			 
1386			; Internal Malloc Function: 
1386			; Input: 
1386			;   HL: Size of block to allocate 
1386			; Output: 
1386			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1386			 
1386			malloc_internal: 
1386			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1386			    add hl, bc         ; Add management overhead to requested size 
1386			    ex de, hl          ; Save total size in DE, and keep it in HL 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "ma2" 
1386						CALLMONITOR 
1386					endif 
1386			 
1386			    ; Search for free memory block 
1386			    ld de, (heap_end)  ; Load end of heap into DE 
1386			    ld bc, 0           ; Initialize counter 
1386			 
1386					if DEBUG_FORTH_MALLOC 
1386						DMARK "ma2" 
1386						CALLMONITOR 
1386					endif 
1386			malloc_search_loop: 
1386			    ; Check if current block is free 
1386			    ld a, (hl)         ; Load current block's status (free or used) 
1386			    cp 0               ; Compare with zero (free) 
1386			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1386			 
1386			    ; Check if current block is large enough 
1386			    ld a, (hl+1)       ; Load high byte of block size 
1386			    cp l               ; Compare with low byte of requested size 
1386			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1386			 
1386			    ld a, (hl+2)       ; Load low byte of block size 
1386			    cp h               ; Compare with high byte of requested size 
1386			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1386			 
1386			    ; Mark block as used 
1386			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1386			 
1386			    ; Calculate remaining space in block 
1386			    ld bc, 0           ; Clear BC 
1386			    add hl, bc         ; Increment HL to point to start of data block 
1386			    add hl, de         ; HL = HL + DE (total size) 
1386			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1386			    add hl, bc         ; Add management overhead to start of data block 
1386			 
1386			    ; Save pointer to allocated block in HL 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386						DMARK "ma5" 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret 
1386			 
1386			malloc_skip_block_check: 
1386			    ; Move to the next block 
1386			    ld bc, 3           ; Size of management overhead 
1386			    add hl, bc         ; Move to the next block 
1386			    inc de             ; Increment counter 
1386			 
1386			    ; Check if we have reached the end of heap 
1386			    ld a, e            ; Load low byte of heap end address 
1386			    cp (hl)            ; Compare with low byte of current address 
1386			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1386			    ld a, d            ; Load high byte of heap end address 
1386			    cp 0               ; Check if it's zero (end of memory) 
1386			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1386			 
1386			    ; If we reached here, allocation failed 
1386			    xor a              ; Set result to NULL 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386						DMARK "ma6" 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret 
1386			malloc_exit: 
1386			if DEBUG_FORTH_MALLOC_HIGH 
1386						DMARK "ma7" 
1386			call malloc_guard_exit 
1386			call malloc_guard_zerolen 
1386			endif 
1386			    ret 
1386			 
1386			; Internal Free Function: 
1386			; Input: 
1386			;   HL: Pointer to memory block to free 
1386			; Output: 
1386			;   None 
1386			 
1386			free_internal: 
1386			    ld de, (heap_start) ; Load start of heap into DE 
1386			    ld bc, 0            ; Initialize counter 
1386			 
1386			free_search_loop: 
1386			    ; Check if current block contains the pointer 
1386			    ld a, l             ; Load low byte of pointer 
1386			    cp (hl+1)           ; Compare with high byte of current block's address 
1386			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1386			    ld a, h             ; Load high byte of pointer 
1386			    cp (hl+2)           ; Compare with low byte of current block's address 
1386			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1386			 
1386			    ; Mark block as free 
1386			    ld (hl), 0          ; Set status byte to indicate free block 
1386			    ret                 ; Return 
1386			 
1386			free_skip_block_check: 
1386			    ; Move to the next block 
1386			    ld bc, 3            ; Size of management overhead 
1386			    add hl, bc          ; Move to the next block 
1386			    inc de              ; Increment counter 
1386			 
1386			    ; Check if we have reached the end of heap 
1386			    ld a, e             ; Load low byte of heap end address 
1386			    cp (hl)             ; Compare with low byte of current address 
1386			    jr nz, free_search_loop  ; If not equal, continue searching 
1386			    ld a, d             ; Load high byte of heap end address 
1386			    cp 0                ; Check if it's zero (end of memory) 
1386			    jr nz, free_search_loop  ; If not zero, continue searching 
1386			 
1386			    ; If we reached here, pointer is not found in heap 
1386			    ret 
1386			 
1386			free_exit: 
1386			    ret                 ; Return 
1386			 
1386			; Define heap start and end addresses 
1386			;heap_start:    .dw 0xC000   ; Start of heap 
1386			;heap_end:      .dw 0xE000   ; End of heap 
1386			 
1386			endif 
1386			 
1386			 
1386			if MALLOC_1 
1386			 
1386			 
1386			 
1386			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1386			 
1386			;moved to firmware.asm 
1386			;heap_start        .equ  0x9000      ; Starting address of heap 
1386			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1386			 
1386			;      .org 0 
1386			;      jp    main 
1386			 
1386			 
1386			;      .org  0x100 
1386			;main: 
1386			;      ld    HL, 0x8100 
1386			;      ld    SP, HL 
1386			; 
1386			;      call  heap_init 
1386			; 
1386			;      ; Make some allocations 
1386			;      ld    HL, 12 
1386			;      call  malloc            ; Allocates 0x9004 
1386			; 
1386			;      ld    HL, 12 
1386			;      call  malloc            ; Allocates 0x9014 
1386			; 
1386			;      ld    HL, 12 
1386			;      call  malloc            ; Allocates 0x9024 
1386			; 
1386			;      ; Free some allocations 
1386			;      ld    HL, 0x9014 
1386			;      call  free 
1386			; 
1386			;      ld    HL, 0x9004 
1386			;      call  free 
1386			; 
1386			;      ld    HL, 0x9024 
1386			;      call  free 
1386			; 
1386			; 
1386			;      halt 
1386			 
1386			 
1386			;------------------------------------------------------------------------------ 
1386			;     heap_init                                                               : 
1386			;                                                                             : 
1386			; Description                                                                 : 
1386			;     Initialise the heap and make it ready for malloc and free operations.   : 
1386			;                                                                             : 
1386			;     The heap is maintained as a linked list, starting with an initial       : 
1386			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1386			;     the first free block in the heap. Each block then points to the next    : 
1386			;     free block within the heap, and the free list ends at the first block   : 
1386			;     with a null pointer to the next free block.                             : 
1386			;                                                                             : 
1386			; Parameters                                                                  : 
1386			;     Inputs are compile-time only. Two defines which specify the starting    : 
1386			;     address of the heap and its size are required, along with a memory      : 
1386			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1386			;     principally stores a pointer to the first free block in the heap.       : 
1386			;                                                                             : 
1386			; Returns                                                                     : 
1386			;     Nothing                                                                 : 
1386			;------------------------------------------------------------------------------ 
1386			heap_init: 
1386 e5			      push  HL 
1387			 
1387			      ; Initialise free list struct 
1387 21 0e 80		      ld    HL, heap_start 
138a 22 0a 80		      ld    (free_list), HL 
138d 21 00 00		      ld    HL, 0 
1390 22 0c 80		      ld    (free_list+2), HL 
1393			 
1393			      ; Insert first free block at bottom of heap, consumes entire heap 
1393 21 d3 f0		      ld    HL, heap_start+heap_size-4 
1396 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1399 21 c5 70		      ld    HL, heap_size-4 
139c 22 10 80		      ld    (heap_start+2), HL      ; Block size 
139f			 
139f			      ; Insert end of free list block at top of heap - two null words will 
139f			      ; terminate the free list 
139f 21 00 00		      ld    HL, 0 
13a2 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
13a5 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
13a8			 
13a8 e1			      pop   HL 
13a9			 
13a9 c9			      ret 
13aa			 
13aa			 
13aa			;------------------------------------------------------------------------------ 
13aa			;     malloc                                                                  : 
13aa			;                                                                             : 
13aa			; Description                                                                 : 
13aa			;     Allocates the wanted space from the heap and returns the address of the : 
13aa			;     first useable byte of the allocation.                                   : 
13aa			;                                                                             : 
13aa			;     Allocations can happen in one of two ways:                              : 
13aa			;                                                                             : 
13aa			;     1. A free block may be found which is the exact size wanted. In this    : 
13aa			;        case the block is removed from the free list and retuedn to the      : 
13aa			;        caller.                                                              : 
13aa			;     2. A free block may be found which is larger than the size wanted. In   : 
13aa			;        this case, the larger block is split into two. The first portion of  : 
13aa			;        this block will become the requested space by the malloc call and    : 
13aa			;        is returned to the caller. The second portion becomes a new free     : 
13aa			;        block, and the free list is adjusted to maintain continuity via this : 
13aa			;        newly created block.                                                 : 
13aa			;                                                                             : 
13aa			;     malloc does not set any initial value in the allocated space, the       : 
13aa			;     caller is required to do this as required.                              : 
13aa			;                                                                             : 
13aa			;     This implementation of malloc uses the stack exclusively, and is        : 
13aa			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13aa			;     advisable to disable interrupts before calling malloc, and recommended  : 
13aa			;     to avoid the use of malloc inside ISRs in general.                      : 
13aa			;                                                                             : 
13aa			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13aa			;                                                                             : 
13aa			; Parameters                                                                  : 
13aa			;     HL  Number of bytes wanted                                              : 
13aa			;                                                                             : 
13aa			; Returns                                                                     : 
13aa			;     HL  Address of the first useable byte of the allocation                 : 
13aa			;                                                                             : 
13aa			; Flags                                                                       : 
13aa			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13aa			;                                                                             : 
13aa			; Stack frame                                                                 : 
13aa			;       |             |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |     BC      |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |     DE      |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |     IX      |                                                       : 
13aa			;       +-------------+                                                       : 
13aa			;       |  prev_free  |                                                       : 
13aa			;   +4  +-------------+                                                       : 
13aa			;       |  this_free  |                                                       : 
13aa			;   +2  +-------------+                                                       : 
13aa			;       |  next_free  |                                                       : 
13aa			;   +0  +-------------+                                                       : 
13aa			;       |             |                                                       : 
13aa			;                                                                             : 
13aa			;------------------------------------------------------------------------------ 
13aa			 
13aa			 
13aa			;malloc: 
13aa			; 
13aa			;	SAVESP ON 1 
13aa			; 
13aa			;	call malloc_code 
13aa			; 
13aa			;	CHECKSP ON 1 
13aa			;	ret 
13aa			 
13aa			 
13aa			malloc: 
13aa c5			      push  BC 
13ab d5			      push  DE 
13ac dd e5		      push  IX 
13ae			if DEBUG_FORTH_MALLOC_HIGH 
13ae			call malloc_guard_entry 
13ae			endif 
13ae			 
13ae					if DEBUG_FORTH_MALLOC 
13ae						DMARK "mal" 
13ae						CALLMONITOR 
13ae					endif 
13ae 7c			      ld    A, H                    ; Exit if no space requested 
13af b5			      or    L 
13b0 ca 6f 14		      jp    Z, malloc_early_exit 
13b3			 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			; 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			;inc hl 
13b3			 
13b3			 
13b3			 
13b3			 
13b3					if DEBUG_FORTH_MALLOC 
13b3						DMARK "maA" 
13b3						CALLMONITOR 
13b3					endif 
13b3			      ; Set up stack frame 
13b3 eb			      ex    DE, HL 
13b4 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13b7 39			      add   HL, SP 
13b8 f9			      ld    SP, HL 
13b9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13bd dd 39		      add   IX, SP 
13bf			 
13bf			      ; Setup initial state 
13bf 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13c2 19			      add   HL, DE 
13c3			 
13c3 44			      ld    B, H                    ; Move want to BC 
13c4 4d			      ld    C, L 
13c5			 
13c5 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13c8 dd 75 04		      ld    (IX+4), L 
13cb dd 74 05		      ld    (IX+5), H 
13ce			 
13ce 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13cf 23			      inc   HL 
13d0 56			      ld    D, (HL) 
13d1 dd 73 02		      ld    (IX+2), E 
13d4 dd 72 03		      ld    (IX+3), D 
13d7 eb			      ex    DE, HL                  ; this_free ptr into HL 
13d8			 
13d8					if DEBUG_FORTH_MALLOC 
13d8						DMARK "maB" 
13d8						CALLMONITOR 
13d8					endif 
13d8			      ; Loop through free block list to find some space 
13d8			malloc_find_space: 
13d8 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13d9 23			      inc   HL 
13da 56			      ld    D, (HL) 
13db			 
13db 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13dc b3			      or    E 
13dd ca 69 14		      jp    Z, malloc_no_space 
13e0			 
13e0 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13e3 dd 72 01		      ld    (IX+1), D 
13e6			 
13e6			      ; Does this block have enough space to make the allocation? 
13e6 23			      inc   HL                      ; Load free block size into DE 
13e7 5e			      ld    E, (HL) 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea eb			      ex    DE, HL                  ; Check size of block against want 
13eb b7			      or    A                       ; Ensure carry flag clear 
13ec ed 42		      sbc   HL, BC 
13ee e5			      push  HL                      ; Store the result for later (new block size) 
13ef			 
13ef ca 3e 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13f2 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13f4			 
13f4			      ; this_free block is not big enough, setup ptrs to test next free block 
13f4 e1			      pop   HL                      ; Discard previous result 
13f5			 
13f5 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13f8 dd 66 03		      ld    H, (IX+3) 
13fb dd 75 04		      ld    (IX+4), L 
13fe dd 74 05		      ld    (IX+5), H 
1401			 
1401 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1404 dd 66 01		      ld    H, (IX+1) 
1407 dd 75 02		      ld    (IX+2), L 
140a dd 74 03		      ld    (IX+3), H 
140d			 
140d					if DEBUG_FORTH_MALLOC 
140d						DMARK "MA>" 
140d						CALLMONITOR 
140d					endif 
140d 18 c9		      jr    malloc_find_space 
140f			 
140f			      ; split a bigger block into two - requested size and remaining size 
140f			malloc_alloc_split: 
140f					if DEBUG_FORTH_MALLOC 
140f						DMARK "MAs" 
140f						CALLMONITOR 
140f					endif 
140f eb			      ex    DE, HL                  ; Calculate address of new free block 
1410 2b			      dec   HL 
1411 2b			      dec   HL 
1412 2b			      dec   HL 
1413 09			      add   HL, BC 
1414			 
1414			      ; Create a new block and point it at next_free 
1414 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1417 dd 56 01		      ld    D, (IX+1) 
141a			 
141a 73			      ld    (HL), E                 ; Store next_free ptr into new block 
141b 23			      inc   HL 
141c 72			      ld    (HL), D 
141d			 
141d d1			      pop   DE                      ; Store size of new block into new block 
141e 23			      inc   HL 
141f 73			      ld    (HL), E 
1420 23			      inc   HL 
1421 72			      ld    (HL), D 
1422			 
1422			      ; Update this_free ptr to point to new block 
1422 2b			      dec   HL 
1423 2b			      dec   HL 
1424 2b			      dec   HL 
1425			 
1425 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1428 dd 56 03		      ld    D, (IX+3) 
142b			 
142b dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
142e dd 74 03		      ld    (IX+3), H 
1431			 
1431			      ; Modify this_free block to be allocation 
1431 eb			      ex    DE, HL 
1432 af			      xor   A                       ; Null the next block ptr of allocated block 
1433 77			      ld    (HL), A 
1434 23			      inc   HL 
1435 77			      ld    (HL), A 
1436			 
1436 23			      inc   HL                      ; Store want size into allocated block 
1437 71			      ld    (HL), C 
1438 23			      inc   HL 
1439 70			      ld    (HL), B 
143a 23			      inc   HL 
143b e5			      push  HL                      ; Address of allocation to return 
143c			 
143c 18 19		      jr    malloc_update_links 
143e			 
143e			malloc_alloc_fit: 
143e e1			      pop   HL                      ; Dont need new block size, want is exact fit 
143f			 
143f					if DEBUG_FORTH_MALLOC 
143f						DMARK "MAf" 
143f						CALLMONITOR 
143f					endif 
143f			      ; Modify this_free block to be allocation 
143f eb			      ex    DE, HL 
1440 2b			      dec   HL 
1441 2b			      dec   HL 
1442 2b			      dec   HL 
1443			 
1443 af			      xor   A                       ; Null the next block ptr of allocated block 
1444 77			      ld    (HL), A 
1445 23			      inc   HL 
1446 77			      ld    (HL), A 
1447			 
1447 23			      inc   HL                      ; Store address of allocation to return 
1448 23			      inc   HL 
1449 23			      inc   HL 
144a e5			      push  HL 
144b			 
144b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
144b dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
144e dd 66 01		      ld    H, (IX+1) 
1451			 
1451 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1454 dd 74 03		      ld    (IX+3), H 
1457			 
1457			 
1457			malloc_update_links: 
1457			      ; Update prev_free ptr to point to this_free 
1457 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
145a dd 66 05		      ld    H, (IX+5) 
145d			 
145d dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1460 dd 56 03		      ld    D, (IX+3) 
1463			 
1463 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1464 23			      inc   HL 
1465 72			      ld    (HL), D 
1466			 
1466					if DEBUG_FORTH_MALLOC 
1466						DMARK "Mul" 
1466						CALLMONITOR 
1466					endif 
1466			      ; Clear the Z flag to indicate successful allocation 
1466 7a			      ld    A, D 
1467 b3			      or    E 
1468			 
1468 d1			      pop   DE                      ; Address of allocation 
1469					if DEBUG_FORTH_MALLOC 
1469						DMARK "MAu" 
1469						CALLMONITOR 
1469					endif 
1469			 
1469			malloc_no_space: 
1469 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
146c 39			      add   HL, SP 
146d f9			      ld    SP, HL 
146e			 
146e eb			      ex    DE, HL                  ; Alloc addr into HL for return 
146f					if DEBUG_FORTH_MALLOC 
146f						DMARK "MAN" 
146f						CALLMONITOR 
146f					endif 
146f			 
146f			malloc_early_exit: 
146f					if DEBUG_FORTH_MALLOC 
146f						DMARK "MAx" 
146f						CALLMONITOR 
146f					endif 
146f dd e1		      pop   IX 
1471 d1			      pop   DE 
1472 c1			      pop   BC 
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473 c9			      ret 
1474			 
1474			 
1474			;------------------------------------------------------------------------------ 
1474			;     free                                                                    : 
1474			;                                                                             : 
1474			; Description                                                                 : 
1474			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1474			;     returned by malloc, otherwise the behaviour is undefined.               : 
1474			;                                                                             : 
1474			;     Where possible, directly adjacent free blocks will be merged together   : 
1474			;     into larger blocks to help ensure that the heap does not become         : 
1474			;     excessively fragmented.                                                 : 
1474			;                                                                             : 
1474			;     free does not clear or set any other value into the freed space, and    : 
1474			;     therefore its contents may be visible through subsequent malloc's. The  : 
1474			;     caller should clear the freed space as required.                        : 
1474			;                                                                             : 
1474			;     This implementation of free uses the stack exclusively, and is          : 
1474			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1474			;     advisable to disable interrupts before calling free, and recommended    : 
1474			;     to avoid the use of free inside ISRs in general.                        : 
1474			;                                                                             : 
1474			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1474			;                                                                             : 
1474			; Parameters                                                                  : 
1474			;     HL  Pointer to address of first byte of allocation to be freed          : 
1474			;                                                                             : 
1474			; Returns                                                                     : 
1474			;     Nothing                                                                 : 
1474			;                                                                             : 
1474			; Stack frame                                                                 : 
1474			;       |             |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |     BC      |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |     DE      |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |     IX      |                                                       : 
1474			;       +-------------+                                                       : 
1474			;       |  prev_free  |                                                       : 
1474			;   +2  +-------------+                                                       : 
1474			;       |  next_free  |                                                       : 
1474			;   +0  +-------------+                                                       : 
1474			;       |             |                                                       : 
1474			;                                                                             : 
1474			;------------------------------------------------------------------------------ 
1474			free: 
1474 c5			      push  BC 
1475 d5			      push  DE 
1476 dd e5		      push  IX 
1478			 
1478 7c			      ld    A, H                    ; Exit if ptr is null 
1479 b5			      or    L 
147a ca 3e 15		      jp    Z, free_early_exit 
147d			 
147d			      ; Set up stack frame 
147d eb			      ex    DE, HL 
147e 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1481 39			      add   HL, SP 
1482 f9			      ld    SP, HL 
1483 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1487 dd 39		      add   IX, SP 
1489			 
1489			      ; The address in HL points to the start of the useable allocated space, 
1489			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1489			      ; address of the block itself. 
1489 eb			      ex    DE, HL 
148a 11 fc ff		      ld    DE, -4 
148d 19			      add   HL, DE 
148e			 
148e			      ; An allocated block must have a null next block pointer in it 
148e 7e			      ld    A, (HL) 
148f 23			      inc   HL 
1490 b6			      or    (HL) 
1491 c2 39 15		      jp    NZ, free_done 
1494			 
1494 2b			      dec   HL 
1495			 
1495 44			      ld    B, H                    ; Copy HL to BC 
1496 4d			      ld    C, L 
1497			 
1497			      ; Loop through the free list to find the first block with an address 
1497			      ; higher than the block being freed 
1497 21 0a 80		      ld    HL, free_list 
149a			 
149a			free_find_higher_block: 
149a 5e			      ld    E, (HL)                 ; Load next ptr from free block 
149b 23			      inc   HL 
149c 56			      ld    D, (HL) 
149d 2b			      dec   HL 
149e			 
149e dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14a1 dd 72 01		      ld    (IX+1), D 
14a4 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14a7 dd 74 03		      ld    (IX+3), H 
14aa			 
14aa 78			      ld    A, B                    ; Check if DE is greater than BC 
14ab ba			      cp    D                       ; Compare MSB first 
14ac 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14ae 30 04		      jr    NC, free_find_higher_block_skip 
14b0 79			      ld    A, C 
14b1 bb			      cp    E                       ; Then compare LSB 
14b2 38 08		      jr    C, free_found_higher_block 
14b4			 
14b4			free_find_higher_block_skip: 
14b4 7a			      ld    A, D                    ; Reached the end of the free list? 
14b5 b3			      or    E 
14b6 ca 39 15		      jp    Z, free_done 
14b9			 
14b9 eb			      ex    DE, HL 
14ba			 
14ba 18 de		      jr    free_find_higher_block 
14bc			 
14bc			free_found_higher_block: 
14bc			      ; Insert freed block between prev and next free blocks 
14bc 71			      ld    (HL), C                 ; Point prev free block to freed block 
14bd 23			      inc   HL 
14be 70			      ld    (HL), B 
14bf			 
14bf 60			      ld    H, B                    ; Point freed block at next free block 
14c0 69			      ld    L, C 
14c1 73			      ld    (HL), E 
14c2 23			      inc   HL 
14c3 72			      ld    (HL), D 
14c4			 
14c4			      ; Check if the freed block is adjacent to the next free block 
14c4 23			      inc   HL                      ; Load size of freed block into HL 
14c5 5e			      ld    E, (HL) 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 09			      add   HL, BC                  ; Add addr of freed block and its size 
14ca			 
14ca dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14cd dd 56 01		      ld    D, (IX+1) 
14d0			 
14d0 b7			      or    A                       ; Clear the carry flag 
14d1 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14d3 20 22		      jr    NZ, free_check_adjacent_to_prev 
14d5			 
14d5			      ; Freed block is adjacent to next, merge into one bigger block 
14d5 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14d6 5e			      ld    E, (HL) 
14d7 23			      inc   HL 
14d8 56			      ld    D, (HL) 
14d9 e5			      push  HL                      ; Save ptr to next block for later 
14da			 
14da 60			      ld    H, B                    ; Store ptr from next block into freed block 
14db 69			      ld    L, C 
14dc 73			      ld    (HL), E 
14dd 23			      inc   HL 
14de 72			      ld    (HL), D 
14df			 
14df e1			      pop   HL                      ; Restore ptr to next block 
14e0 23			      inc   HL                      ; Load size of next block into DE 
14e1 5e			      ld    E, (HL) 
14e2 23			      inc   HL 
14e3 56			      ld    D, (HL) 
14e4 d5			      push  DE                      ; Save next block size for later 
14e5			 
14e5 60			      ld    H, B                    ; Load size of freed block into HL 
14e6 69			      ld    L, C 
14e7 23			      inc   HL 
14e8 23			      inc   HL 
14e9 5e			      ld    E, (HL) 
14ea 23			      inc   HL 
14eb 56			      ld    D, (HL) 
14ec eb			      ex    DE, HL 
14ed			 
14ed d1			      pop   DE                      ; Restore size of next block 
14ee 19			      add   HL, DE                  ; Add sizes of both blocks 
14ef eb			      ex    DE, HL 
14f0			 
14f0 60			      ld    H, B                    ; Store new bigger size into freed block 
14f1 69			      ld    L, C 
14f2 23			      inc   HL 
14f3 23			      inc   HL 
14f4 73			      ld    (HL), E 
14f5 23			      inc   HL 
14f6 72			      ld    (HL), D 
14f7			 
14f7			free_check_adjacent_to_prev: 
14f7			      ; Check if the freed block is adjacent to the prev free block 
14f7 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14fa dd 66 03		      ld    H, (IX+3) 
14fd			 
14fd 23			      inc   HL                      ; Size of prev free block into DE 
14fe 23			      inc   HL 
14ff 5e			      ld    E, (HL) 
1500 23			      inc   HL 
1501 56			      ld    D, (HL) 
1502 2b			      dec   HL 
1503 2b			      dec   HL 
1504 2b			      dec   HL 
1505			 
1505 19			      add   HL, DE                  ; Add prev block addr and size 
1506			 
1506 b7			      or    A                       ; Clear the carry flag 
1507 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1509 20 2e		      jr    NZ, free_done 
150b			 
150b			      ; Freed block is adjacent to prev, merge into one bigger block 
150b 60			      ld    H, B                    ; Load next ptr from freed block into DE 
150c 69			      ld    L, C 
150d 5e			      ld    E, (HL) 
150e 23			      inc   HL 
150f 56			      ld    D, (HL) 
1510 e5			      push  HL                      ; Save freed block ptr for later 
1511			 
1511 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1514 dd 66 03		      ld    H, (IX+3) 
1517 73			      ld    (HL), E 
1518 23			      inc   HL 
1519 72			      ld    (HL), D 
151a			 
151a e1			      pop   HL                      ; Restore freed block ptr 
151b 23			      inc   HL                      ; Load size of freed block into DE 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f d5			      push  DE                      ; Save freed block size for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1523 dd 66 03		      ld    H, (IX+3) 
1526 23			      inc   HL 
1527 23			      inc   HL 
1528 5e			      ld    E, (HL) 
1529 23			      inc   HL 
152a 56			      ld    D, (HL) 
152b			 
152b e1			      pop   HL                      ; Add sizes of both blocks 
152c 19			      add   HL, DE 
152d eb			      ex    DE, HL 
152e			 
152e dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1531 dd 66 03		      ld    H, (IX+3) 
1534 23			      inc   HL 
1535 23			      inc   HL 
1536 73			      ld    (HL), E 
1537 23			      inc   HL 
1538 72			      ld    (HL), D 
1539			 
1539			free_done: 
1539 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
153c 39			      add   HL, SP 
153d f9			      ld    SP, HL 
153e			 
153e			free_early_exit: 
153e dd e1		      pop   IX 
1540 d1			      pop   DE 
1541 c1			      pop   BC 
1542			 
1542 c9			      ret 
1543			 
1543			; moved to firmware.asm 
1543			; 
1543			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1543			;                  .dw   0 
1543			 
1543			 
1543			endif 
1543			 
1543			 
1543			if MALLOC_3 
1543			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1543			;heap_start        .equ  0x9000      ; Starting address of heap 
1543			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1543			; 
1543			 ;     .org 0 
1543			  ;    jp    main 
1543			; 
1543			; 
1543			 ;     .org  0x100 
1543			;main: 
1543			 ;     ld    HL, 0x8100 
1543			  ;    ld    SP, HL 
1543			; 
1543			;      call  heap_init 
1543			 
1543			      ; Make some allocations 
1543			;      ld    HL, 12 
1543			;      call  malloc            ; Allocates 0x9004 
1543			; 
1543			 ;     ld    HL, 12 
1543			;      call  malloc            ; Allocates 0x9014 
1543			 
1543			;      ld    HL, 12 
1543			;      call  malloc            ; Allocates 0x9024 
1543			 
1543			      ; Free some allocations 
1543			;      ld    HL, 0x9014 
1543			;      call  free 
1543			 
1543			;      ld    HL, 0x9004 
1543			;      call  free 
1543			; 
1543			;      ld    HL, 0x9024 
1543			;      call  free 
1543			 
1543			 
1543			 ;     halt 
1543			 
1543			 
1543			;------------------------------------------------------------------------------ 
1543			;     heap_init                                                               : 
1543			;                                                                             : 
1543			; Description                                                                 : 
1543			;     Initialise the heap and make it ready for malloc and free operations.   : 
1543			;                                                                             : 
1543			;     The heap is maintained as a linked list, starting with an initial       : 
1543			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1543			;     the first free block in the heap. Each block then points to the next    : 
1543			;     free block within the heap, and the free list ends at the first block   : 
1543			;     with a null pointer to the next free block.                             : 
1543			;                                                                             : 
1543			; Parameters                                                                  : 
1543			;     Inputs are compile-time only. Two defines which specify the starting    : 
1543			;     address of the heap and its size are required, along with a memory      : 
1543			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1543			;     principally stores a pointer to the first free block in the heap.       : 
1543			;                                                                             : 
1543			; Returns                                                                     : 
1543			;     Nothing                                                                 : 
1543			;------------------------------------------------------------------------------ 
1543			heap_init: 
1543			      push  HL 
1543			 
1543			      ; Initialise free list struct 
1543			      ld    HL, heap_start 
1543			      ld    (free_list), HL 
1543			      ld    HL, 0 
1543			      ld    (free_list+2), HL 
1543			 
1543			      ; Insert first free block at bottom of heap, consumes entire heap 
1543			      ld    HL, heap_start+heap_size-4 
1543			      ld    (heap_start), HL        ; Next block (end of free list) 
1543			      ld    HL, heap_size-4 
1543			      ld    (heap_start+2), HL      ; Block size 
1543			 
1543			      ; Insert end of free list block at top of heap - two null words will 
1543			      ; terminate the free list 
1543			      ld    HL, 0 
1543			      ld    (heap_start+heap_size-2), HL 
1543			      ld    (heap_start+heap_size-4), HL 
1543			 
1543			      pop   HL 
1543			 
1543			      ret 
1543			 
1543			 
1543			;------------------------------------------------------------------------------ 
1543			;     malloc                                                                  : 
1543			;                                                                             : 
1543			; Description                                                                 : 
1543			;     Allocates the wanted space from the heap and returns the address of the : 
1543			;     first useable byte of the allocation.                                   : 
1543			;                                                                             : 
1543			;     Allocations can happen in one of two ways:                              : 
1543			;                                                                             : 
1543			;     1. A free block may be found which is the exact size wanted. In this    : 
1543			;        case the block is removed from the free list and retuedn to the      : 
1543			;        caller.                                                              : 
1543			;     2. A free block may be found which is larger than the size wanted. In   : 
1543			;        this case, the larger block is split into two. The first portion of  : 
1543			;        this block will become the requested space by the malloc call and    : 
1543			;        is returned to the caller. The second portion becomes a new free     : 
1543			;        block, and the free list is adjusted to maintain continuity via this : 
1543			;        newly created block.                                                 : 
1543			;                                                                             : 
1543			;     malloc does not set any initial value in the allocated space, the       : 
1543			;     caller is required to do this as required.                              : 
1543			;                                                                             : 
1543			;     This implementation of malloc uses the stack exclusively, and is        : 
1543			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1543			;     advisable to disable interrupts before calling malloc, and recommended  : 
1543			;     to avoid the use of malloc inside ISRs in general.                      : 
1543			;                                                                             : 
1543			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1543			;                                                                             : 
1543			; Parameters                                                                  : 
1543			;     HL  Number of bytes wanted                                              : 
1543			;                                                                             : 
1543			; Returns                                                                     : 
1543			;     HL  Address of the first useable byte of the allocation                 : 
1543			;                                                                             : 
1543			; Flags                                                                       : 
1543			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1543			;                                                                             : 
1543			; Stack frame                                                                 : 
1543			;       |             |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     BC      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     DE      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     IX      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |  prev_free  |                                                       : 
1543			;   +4  +-------------+                                                       : 
1543			;       |  this_free  |                                                       : 
1543			;   +2  +-------------+                                                       : 
1543			;       |  next_free  |                                                       : 
1543			;   +0  +-------------+                                                       : 
1543			;       |             |                                                       : 
1543			;                                                                             : 
1543			;------------------------------------------------------------------------------ 
1543			malloc: 
1543			      push  BC 
1543			      push  DE 
1543			      push  IX 
1543			 
1543			      ld    A, H                    ; Exit if no space requested 
1543			      or    L 
1543			      jp    Z, malloc_early_exit 
1543			 
1543			      ; Set up stack frame 
1543			      ex    DE, HL 
1543			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			      ld    IX, 0                   ; Use IX as a frame pointer 
1543			      add   IX, SP 
1543			 
1543			      ; Setup initial state 
1543			      ld    HL, 4                   ; want must also include space used by block struct 
1543			      add   HL, DE 
1543			 
1543			      ld    B, H                    ; Move want to BC 
1543			      ld    C, L 
1543			 
1543			      ld    HL, free_list           ; Store prev_free ptr to stack 
1543			      ld    (IX+4), L 
1543			      ld    (IX+5), H 
1543			 
1543			      ld    E, (HL)                 ; Store this_free ptr to stack 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      ld    (IX+2), E 
1543			      ld    (IX+3), D 
1543			      ex    DE, HL                  ; this_free ptr into HL 
1543			 
1543			      ; Loop through free block list to find some space 
1543			malloc_find_space: 
1543			      ld    E, (HL)                 ; Load next_free ptr into DE 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			 
1543			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1543			      or    E 
1543			      jp    Z, malloc_no_space 
1543			 
1543			      ld    (IX+0), E               ; Store next_free ptr to stack 
1543			      ld    (IX+1), D 
1543			 
1543			      ; Does this block have enough space to make the allocation? 
1543			      inc   HL                      ; Load free block size into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			 
1543			      ex    DE, HL                  ; Check size of block against want 
1543			      or    A                       ; Ensure carry flag clear 
1543			      sbc   HL, BC 
1543			      push  HL                      ; Store the result for later (new block size) 
1543			 
1543			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1543			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1543			 
1543			      ; this_free block is not big enough, setup ptrs to test next free block 
1543			      pop   HL                      ; Discard previous result 
1543			 
1543			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1543			      ld    H, (IX+3) 
1543			      ld    (IX+4), L 
1543			      ld    (IX+5), H 
1543			 
1543			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1543			      ld    H, (IX+1) 
1543			      ld    (IX+2), L 
1543			      ld    (IX+3), H 
1543			 
1543			      jr    malloc_find_space 
1543			 
1543			      ; split a bigger block into two - requested size and remaining size 
1543			malloc_alloc_split: 
1543			      ex    DE, HL                  ; Calculate address of new free block 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			      add   HL, BC 
1543			 
1543			      ; Create a new block and point it at next_free 
1543			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1543			      ld    D, (IX+1) 
1543			 
1543			      ld    (HL), E                 ; Store next_free ptr into new block 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      pop   DE                      ; Store size of new block into new block 
1543			      inc   HL 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      ; Update this_free ptr to point to new block 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			 
1543			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1543			      ld    D, (IX+3) 
1543			 
1543			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1543			      ld    (IX+3), H 
1543			 
1543			      ; Modify this_free block to be allocation 
1543			      ex    DE, HL 
1543			      xor   A                       ; Null the next block ptr of allocated block 
1543			      ld    (HL), A 
1543			      inc   HL 
1543			      ld    (HL), A 
1543			 
1543			      inc   HL                      ; Store want size into allocated block 
1543			      ld    (HL), C 
1543			      inc   HL 
1543			      ld    (HL), B 
1543			      inc   HL 
1543			      push  HL                      ; Address of allocation to return 
1543			 
1543			      jr    malloc_update_links 
1543			 
1543			malloc_alloc_fit: 
1543			      pop   HL                      ; Dont need new block size, want is exact fit 
1543			 
1543			      ; Modify this_free block to be allocation 
1543			      ex    DE, HL 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			 
1543			      xor   A                       ; Null the next block ptr of allocated block 
1543			      ld    (HL), A 
1543			      inc   HL 
1543			      ld    (HL), A 
1543			 
1543			      inc   HL                      ; Store address of allocation to return 
1543			      inc   HL 
1543			      inc   HL 
1543			      push  HL 
1543			 
1543			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1543			      ld    L, (IX+0)               ; next_free to HL 
1543			      ld    H, (IX+1) 
1543			 
1543			      ld    (IX+2), L               ; HL to this_free 
1543			      ld    (IX+3), H 
1543			 
1543			 
1543			malloc_update_links: 
1543			      ; Update prev_free ptr to point to this_free 
1543			      ld    L, (IX+4)               ; prev_free ptr to HL 
1543			      ld    H, (IX+5) 
1543			 
1543			      ld    E, (IX+2)               ; this_free ptr to DE 
1543			      ld    D, (IX+3) 
1543			 
1543			      ld    (HL), E                 ; this_free ptr into prev_free 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      ; Clear the Z flag to indicate successful allocation 
1543			      ld    A, D 
1543			      or    E 
1543			 
1543			      pop   DE                      ; Address of allocation 
1543			 
1543			malloc_no_space: 
1543			      ld    HL, 6                   ; Clean up stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			 
1543			      ex    DE, HL                  ; Alloc addr into HL for return 
1543			 
1543			malloc_early_exit: 
1543			      pop   IX 
1543			      pop   DE 
1543			      pop   BC 
1543			 
1543			      ret 
1543			 
1543			 
1543			;------------------------------------------------------------------------------ 
1543			;     free                                                                    : 
1543			;                                                                             : 
1543			; Description                                                                 : 
1543			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1543			;     returned by malloc, otherwise the behaviour is undefined.               : 
1543			;                                                                             : 
1543			;     Where possible, directly adjacent free blocks will be merged together   : 
1543			;     into larger blocks to help ensure that the heap does not become         : 
1543			;     excessively fragmented.                                                 : 
1543			;                                                                             : 
1543			;     free does not clear or set any other value into the freed space, and    : 
1543			;     therefore its contents may be visible through subsequent malloc's. The  : 
1543			;     caller should clear the freed space as required.                        : 
1543			;                                                                             : 
1543			;     This implementation of free uses the stack exclusively, and is          : 
1543			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1543			;     advisable to disable interrupts before calling free, and recommended    : 
1543			;     to avoid the use of free inside ISRs in general.                        : 
1543			;                                                                             : 
1543			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1543			;                                                                             : 
1543			; Parameters                                                                  : 
1543			;     HL  Pointer to address of first byte of allocation to be freed          : 
1543			;                                                                             : 
1543			; Returns                                                                     : 
1543			;     Nothing                                                                 : 
1543			;                                                                             : 
1543			; Stack frame                                                                 : 
1543			;       |             |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     BC      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     DE      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |     IX      |                                                       : 
1543			;       +-------------+                                                       : 
1543			;       |  prev_free  |                                                       : 
1543			;   +2  +-------------+                                                       : 
1543			;       |  next_free  |                                                       : 
1543			;   +0  +-------------+                                                       : 
1543			;       |             |                                                       : 
1543			;                                                                             : 
1543			;------------------------------------------------------------------------------ 
1543			free: 
1543			      push  BC 
1543			      push  DE 
1543			      push  IX 
1543			 
1543			      ld    A, H                    ; Exit if ptr is null 
1543			      or    L 
1543			      jp    Z, free_early_exit 
1543			 
1543			      ; Set up stack frame 
1543			      ex    DE, HL 
1543			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			      ld    IX, 0                   ; Use IX as a frame pointer 
1543			      add   IX, SP 
1543			 
1543			      ; The address in HL points to the start of the useable allocated space, 
1543			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1543			      ; address of the block itself. 
1543			      ex    DE, HL 
1543			      ld    DE, -4 
1543			      add   HL, DE 
1543			 
1543			      ; An allocated block must have a null next block pointer in it 
1543			      ld    A, (HL) 
1543			      inc   HL 
1543			      or    (HL) 
1543			      jp    NZ, free_done 
1543			 
1543			      dec   HL 
1543			 
1543			      ld    B, H                    ; Copy HL to BC 
1543			      ld    C, L 
1543			 
1543			      ; Loop through the free list to find the first block with an address 
1543			      ; higher than the block being freed 
1543			      ld    HL, free_list 
1543			 
1543			free_find_higher_block: 
1543			      ld    E, (HL)                 ; Load next ptr from free block 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      dec   HL 
1543			 
1543			      ld    (IX+0), E               ; Save ptr to next free block 
1543			      ld    (IX+1), D 
1543			      ld    (IX+2), L               ; Save ptr to prev free block 
1543			      ld    (IX+3), H 
1543			 
1543			      ld    A, B                    ; Check if DE is greater than BC 
1543			      cp    D                       ; Compare MSB first 
1543			      jr    Z, $+4                  ; MSB the same, compare LSB 
1543			      jr    NC, free_find_higher_block_skip 
1543			      ld    A, C 
1543			      cp    E                       ; Then compare LSB 
1543			      jr    C, free_found_higher_block 
1543			 
1543			free_find_higher_block_skip: 
1543			      ld    A, D                    ; Reached the end of the free list? 
1543			      or    E 
1543			      jp    Z, free_done 
1543			 
1543			      ex    DE, HL 
1543			 
1543			      jr    free_find_higher_block 
1543			 
1543			free_found_higher_block: 
1543			      ; Insert freed block between prev and next free blocks 
1543			      ld    (HL), C                 ; Point prev free block to freed block 
1543			      inc   HL 
1543			      ld    (HL), B 
1543			 
1543			      ld    H, B                    ; Point freed block at next free block 
1543			      ld    L, C 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      ; Check if the freed block is adjacent to the next free block 
1543			      inc   HL                      ; Load size of freed block into HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      ex    DE, HL 
1543			 
1543			      add   HL, BC                  ; Add addr of freed block and its size 
1543			 
1543			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1543			      ld    D, (IX+1) 
1543			 
1543			      or    A                       ; Clear the carry flag 
1543			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1543			      jr    NZ, free_check_adjacent_to_prev 
1543			 
1543			      ; Freed block is adjacent to next, merge into one bigger block 
1543			      ex    DE, HL                  ; Load next ptr from next block into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  HL                      ; Save ptr to next block for later 
1543			 
1543			      ld    H, B                    ; Store ptr from next block into freed block 
1543			      ld    L, C 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      pop   HL                      ; Restore ptr to next block 
1543			      inc   HL                      ; Load size of next block into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  DE                      ; Save next block size for later 
1543			 
1543			      ld    H, B                    ; Load size of freed block into HL 
1543			      ld    L, C 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      ex    DE, HL 
1543			 
1543			      pop   DE                      ; Restore size of next block 
1543			      add   HL, DE                  ; Add sizes of both blocks 
1543			      ex    DE, HL 
1543			 
1543			      ld    H, B                    ; Store new bigger size into freed block 
1543			      ld    L, C 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			free_check_adjacent_to_prev: 
1543			      ; Check if the freed block is adjacent to the prev free block 
1543			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1543			      ld    H, (IX+3) 
1543			 
1543			      inc   HL                      ; Size of prev free block into DE 
1543			      inc   HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      dec   HL 
1543			      dec   HL 
1543			      dec   HL 
1543			 
1543			      add   HL, DE                  ; Add prev block addr and size 
1543			 
1543			      or    A                       ; Clear the carry flag 
1543			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1543			      jr    NZ, free_done 
1543			 
1543			      ; Freed block is adjacent to prev, merge into one bigger block 
1543			      ld    H, B                    ; Load next ptr from freed block into DE 
1543			      ld    L, C 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  HL                      ; Save freed block ptr for later 
1543			 
1543			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1543			      ld    H, (IX+3) 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			      pop   HL                      ; Restore freed block ptr 
1543			      inc   HL                      ; Load size of freed block into DE 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			      push  DE                      ; Save freed block size for later 
1543			 
1543			      ld    L, (IX+2)               ; Load size of prev block into DE 
1543			      ld    H, (IX+3) 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    E, (HL) 
1543			      inc   HL 
1543			      ld    D, (HL) 
1543			 
1543			      pop   HL                      ; Add sizes of both blocks 
1543			      add   HL, DE 
1543			      ex    DE, HL 
1543			 
1543			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1543			      ld    H, (IX+3) 
1543			      inc   HL 
1543			      inc   HL 
1543			      ld    (HL), E 
1543			      inc   HL 
1543			      ld    (HL), D 
1543			 
1543			free_done: 
1543			      ld    HL, 4                   ; Clean up stack frame 
1543			      add   HL, SP 
1543			      ld    SP, HL 
1543			 
1543			free_early_exit: 
1543			      pop   IX 
1543			      pop   DE 
1543			      pop   BC 
1543			 
1543			      ret 
1543			 
1543			 
1543			;      .org 0x8000 
1543			; 
1543			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1543			 ;                 .dw   0 
1543			 
1543			endif 
1543			 
1543			 
1543			if MALLOC_4 
1543			 
1543			; My memory allocation code. Very very simple.... 
1543			; allocate space under 250 chars 
1543			 
1543			heap_init: 
1543				; init start of heap as zero 
1543				;  
1543			 
1543				ld hl, heap_start 
1543				ld a, 0 
1543				ld (hl), a      ; empty block 
1543				inc hl 
1543				ld a, 0 
1543				ld (hl), a      ; length of block 
1543				; write end of list 
1543				inc hl 
1543				ld a,(hl) 
1543				inc hl 
1543				ld a,(hl) 
1543				 
1543			 
1543				; init some malloc vars 
1543			 
1543				ld hl, 0 
1543				ld (free_list), hl       ; store last malloc location 
1543			 
1543				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1543				ld a, 0 
1543				ld (hl), a 
1543			 
1543			 
1543				ld hl, heap_start 
1543				;  
1543				  
1543				ret 
1543			 
1543			 
1543			;    free block marker 
1543			;    requested size  
1543			;    pointer to next block 
1543			;    .... 
1543			;    next block marker 
1543			 
1543			 
1543			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1543			; 
1543			 
1543			 
1543			malloc:  
1543				push de 
1543				push bc 
1543				push af 
1543			 
1543				; hl space required 
1543				 
1543				ld c, l    ; hold space   (TODO only a max of 255) 
1543			 
1543			;	inc c     ; TODO BUG need to fix memory leak on push str 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			;	inc c 
1543			 
1543			 
1543			 
1543				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1543			 
1543				ld a, (free_list+3) 
1543				cp 0 
1543				jr z, .contheap 
1543			 
1543				ld hl, (free_list)     ; get last alloc 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mrs" 
1543						CALLMONITOR 
1543					endif 
1543				jr .startalloc 
1543			 
1543			.contheap: 
1543				ld hl, heap_start 
1543			 
1543			.startalloc: 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mym" 
1543						CALLMONITOR 
1543					endif 
1543			.findblock: 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mmf" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543				ld a,(hl)  
1543				; if byte is zero then clear to use 
1543			 
1543				cp 0 
1543				jr z, .foundemptyblock 
1543			 
1543				; if byte is not clear 
1543				;     then byte is offset to next block 
1543			 
1543				inc hl 
1543				ld a, (hl) ; get size 
1543			.nextblock:	inc hl 
1543					ld e, (hl) 
1543					inc hl 
1543					ld d, (hl) 
1543					ex de, hl 
1543			;	inc hl  ; move past the store space 
1543			;	inc hl  ; move past zero index  
1543			 
1543				; TODO detect no more space 
1543			 
1543				push hl 
1543				ld de, heap_end 
1543				call cmp16 
1543				pop hl 
1543				jr nc, .nospace 
1543			 
1543				jr .findblock 
1543			 
1543			.nospace: ld hl, 0 
1543				jp .exit 
1543			 
1543			 
1543			.foundemptyblock:	 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mme" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			; TODO has block enough space if reusing??? 
1543			 
1543				;  
1543			 
1543			; see if this block has been previously used 
1543				inc hl 
1543				ld a, (hl) 
1543				dec hl 
1543				cp 0 
1543				jr z, .newblock 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "meR" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			; no reusing previously allocated block 
1543			 
1543			; is it smaller than previously used? 
1543				 
1543				inc hl    ; move to size 
1543				ld a, c 
1543				sub (hl)        ; we want c < (hl) 
1543				dec hl    ; move back to marker 
1543			        jr z, .findblock 
1543			 
1543				; update with the new size which should be lower 
1543			 
1543			        ;inc  hl   ; negate next move. move back to size  
1543			 
1543			.newblock: 
1543				; need to be at marker here 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "meN" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			 
1543				ld a, c 
1543			 
1543				ld (free_list+3), a	 ; flag resume from last malloc  
1543				ld (free_list), hl    ; save out last location 
1543			 
1543			 
1543				;inc a     ; space for length byte 
1543				ld (hl), a     ; save block in use marker 
1543			 
1543				inc hl   ; move to space marker 
1543				ld (hl), a    ; save new space 
1543			 
1543				inc hl   ; move to start of allocated area 
1543				 
1543			;	push hl     ; save where we are - 1  
1543			 
1543			;	inc hl  ; move past zero index  
1543				; skip space to set down new marker 
1543			 
1543				; provide some extra space for now 
1543			 
1543				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1543				inc a 
1543				inc a 
1543			 
1543				push hl   ; save where we are in the node block 
1543			 
1543				call addatohl 
1543			 
1543				; write linked list point 
1543			 
1543				pop de     ; get our node position 
1543				ex de, hl 
1543			 
1543				ld (hl), e 
1543				inc hl 
1543				ld (hl), d 
1543			 
1543				inc hl 
1543			 
1543				; now at start of allocated data so save pointer 
1543			 
1543				push hl 
1543			 
1543				; jump to position of next node and setup empty header in DE 
1543			 
1543				ex de, hl 
1543			 
1543			;	inc hl ; move past end of block 
1543			 
1543				ld a, 0 
1543				ld (hl), a   ; empty marker 
1543				inc hl 
1543				ld (hl), a   ; size 
1543				inc hl  
1543				ld (hl), a   ; ptr 
1543				inc hl 
1543				ld (hl), a   ; ptr 
1543			 
1543			 
1543				pop hl 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "mmr" 
1543						CALLMONITOR 
1543					endif 
1543			 
1543			.exit: 
1543				pop af 
1543				pop bc 
1543				pop de  
1543				ret 
1543			 
1543			 
1543			 
1543			 
1543			free:  
1543				push hl 
1543				push af 
1543				; get address in hl 
1543			 
1543					if DEBUG_FORTH_MALLOC_INT 
1543						DMARK "fre" 
1543						CALLMONITOR 
1543					endif 
1543				; data is at hl - move to block count 
1543				dec hl 
1543				dec hl    ; get past pointer 
1543				dec hl 
1543			 
1543				ld a, (hl)    ; need this for a validation check 
1543			 
1543				dec hl    ; move to block marker 
1543			 
1543				; now check that the block count and block marker are the same  
1543			        ; this checks that we are on a malloc node and not random memory 
1543			        ; OK a faint chance this could be a problem but rare - famous last words! 
1543			 
1543				ld c, a 
1543				ld a, (hl)    
1543			 
1543				cp c 
1543				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1543			 
1543				; yes good chance we are on a malloc node 
1543			 
1543				ld a, 0      
1543				ld (hl), a   ; mark as free 
1543			 
1543				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1543			 
1543			.freeignore:  
1543			 
1543				pop af 
1543				pop hl 
1543			 
1543				ret 
1543			 
1543			 
1543			 
1543			endif 
1543			 
1543			; eof 
# End of file firmware_memory.asm
1543			  
1543			; device C  
1543			; Now handled by SPI  
1543			;if SOUND_ENABLE  
1543			;	include "firmware_sound.asm"  
1543			;endif  
1543			  
1543			include "firmware_diags.asm"  
1543			; Hardware diags menu 
1543			 
1543			 
1543			config: 
1543			 
1543 3e 00			ld a, 0 
1545 21 6e 15			ld hl, .configmn 
1548 cd cc 0d			call menu 
154b			 
154b fe 00			cp 0 
154d c8				ret z 
154e			 
154e			;	cp 1 
154e			;	call z, .savetostore 
154e			 
154e fe 01			cp 1 
1550			if STARTUP_V1 
1550				call z, .selautoload 
1550			endif 
1550			 
1550			if STARTUP_V2 
1550 cc 7c 15			call z, .enautoload 
1553			endif 
1553 fe 02			cp 2 
1555 cc 93 15			call z, .disautoload 
1558			;	cp 3 
1558			;	call z, .selbank 
1558 fe 03			cp 3 
155a cc fc 17			call z, .debug_tog 
155d fe 04			cp 4 
155f cc 4a 19			call z, .bpsgo 
1562 fe 05			cp 5 
1564 cc 25 18			call z, hardware_diags 
1567			if STARTUP_V2 
1567 fe 06			cp 6 
1569 cc bf 15			call z, create_startup 
156c			endif 
156c 18 d5			jr config 
156e			 
156e			.configmn: 
156e			;	dw prom_c3 
156e 38 1b			dw prom_c2 
1570 4e 1b			dw prom_c2a 
1572			;	dw prom_c2b 
1572			;	dw prom_c4 
1572 c5 1b			dw prom_m4 
1574 e0 1b			dw prom_m4b 
1576 e8 1b			dw prom_c1 
1578			if STARTUP_V2 
1578 f7 1b			dw prom_c9 
157a			endif 
157a 00 00			dw 0 
157c				 
157c			 
157c			if STARTUP_V2 
157c			.enautoload: 
157c				if STORAGE_SE 
157c 3e fe			ld a, $fe      ; bit 0 clear 
157e 32 9b f9			ld (spi_device), a 
1581			 
1581 cd 16 05			call storage_get_block_0 
1584			 
1584 3e 01			ld a, 1 
1586 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1589			 
1589 21 00 00				ld hl, 0 
158c 11 b5 f9				ld de, store_page 
158f cd ca 04			call storage_write_block	 ; save update 
1592				else 
1592			 
1592				ld hl, prom_notav 
1592				ld de, prom_empty 
1592				call info_panel 
1592				endif 
1592			 
1592			 
1592 c9				ret 
1593			endif 
1593			 
1593			.disautoload: 
1593				if STORAGE_SE 
1593 3e fe			ld a, $fe      ; bit 0 clear 
1595 32 9b f9			ld (spi_device), a 
1598			 
1598 cd 16 05			call storage_get_block_0 
159b			 
159b 3e 00			ld a, 0 
159d 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
15a0			 
15a0 21 00 00				ld hl, 0 
15a3 11 b5 f9				ld de, store_page 
15a6 cd ca 04			call storage_write_block	 ; save update 
15a9				else 
15a9			 
15a9				ld hl, prom_notav 
15a9				ld de, prom_empty 
15a9				call info_panel 
15a9				endif 
15a9			 
15a9			 
15a9 c9				ret 
15aa			 
15aa			if STARTUP_V1 
15aa			 
15aa			; Select auto start 
15aa			 
15aa			.selautoload: 
15aa			 
15aa				 
15aa				if STORAGE_SE 
15aa			 
15aa					call config_dir 
15aa				        ld hl, scratch 
15aa					ld a, 0 
15aa					call menu 
15aa			 
15aa					cp 0 
15aa					ret z 
15aa			 
15aa					dec a 
15aa			 
15aa			 
15aa					; locate menu option 
15aa			 
15aa					ld hl, scratch 
15aa					call table_lookup 
15aa			 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "ALl" 
15aa						CALLMONITOR 
15aa					endif 
15aa					; with the pointer to the menu it, the byte following the zero term is the file id 
15aa			 
15aa					ld a, 0 
15aa					ld bc, 50   ; max of bytes to look at 
15aa					cpir  
15aa			 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "ALb" 
15aa						CALLMONITOR 
15aa					endif 
15aa					;inc hl 
15aa			 
15aa					ld a, (hl)   ; file id 
15aa					 
15aa				        ; save bank and file ids 
15aa			 
15aa					push af 
15aa			 
15aa			; TODO need to save to block 0 on bank 1	 
15aa			 
15aa					call storage_get_block_0 
15aa			 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "AL0" 
15aa						CALLMONITOR 
15aa					endif 
15aa					pop af 
15aa			 
15aa					ld (store_page+STORE_0_FILERUN),a 
15aa					 
15aa					; save bank id 
15aa			 
15aa					ld a,(spi_device) 
15aa					ld (store_page+STORE_0_BANKRUN),a 
15aa			 
15aa					; enable auto run of store file 
15aa			 
15aa					ld a, 1 
15aa					ld (store_page+STORE_0_AUTOFILE),a 
15aa			 
15aa					; save buffer 
15aa			 
15aa					ld hl, 0 
15aa					ld de, store_page 
15aa					if DEBUG_FORTH_WORDS 
15aa						DMARK "ALw" 
15aa						CALLMONITOR 
15aa					endif 
15aa				call storage_write_block	 ; save update 
15aa			  
15aa			 
15aa			 
15aa			 
15aa					ld hl, scratch 
15aa					call config_fdir 
15aa			 
15aa				else 
15aa			 
15aa				ld hl, prom_notav 
15aa				ld de, prom_empty 
15aa				call info_panel 
15aa			 
15aa				endif 
15aa				ret 
15aa			endif 
15aa			 
15aa			 
15aa			; Select storage bank 
15aa			 
15aa			.selbank: 
15aa			 
15aa			;	if STORAGE_SE 
15aa			;	else 
15aa			 
15aa 21 0c 1c			ld hl, prom_notav 
15ad 11 22 1c			ld de, prom_empty 
15b0 cd 2c 0d			call info_panel 
15b3			;	endif 
15b3				 
15b3 c9				ret 
15b4			 
15b4			if STORAGE_SE 
15b4			 
15b4			.config_ldir:   
15b4				; Load storage bank labels into menu array 
15b4			 
15b4				 
15b4			 
15b4			 
15b4 c9				ret 
15b5			 
15b5			 
15b5			endif 
15b5			 
15b5			 
15b5			; Save user words to storage 
15b5			 
15b5			.savetostore: 
15b5			 
15b5			;	if STORAGE_SE 
15b5			; 
15b5			;		call config_dir 
15b5			;	        ld hl, scratch 
15b5			;		ld a, 0 
15b5			;		call menu 
15b5			;		 
15b5			;		ld hl, scratch 
15b5			;		call config_fdir 
15b5			; 
15b5			;	else 
15b5			 
15b5 21 0c 1c			ld hl, prom_notav 
15b8 11 22 1c			ld de, prom_empty 
15bb cd 2c 0d			call info_panel 
15be			 
15be			;	endif 
15be			 
15be c9				ret 
15bf			 
15bf			if STARTUP_V2 
15bf			 
15bf			create_startup: 
15bf			 
15bf 3e 00			ld a, 0 
15c1 21 21 17			ld hl, .crstart 
15c4 cd cc 0d			call menu 
15c7			 
15c7 fe 00			cp 0 
15c9 c8				ret z 
15ca			 
15ca fe 01			cp 1 
15cc cc 08 16			call z, .genlsword 
15cf fe 02			cp 2 
15d1 cc 12 16			call z, .genedword 
15d4			 
15d4 fe 03			cp 3 
15d6 cc 1c 16			call z, .gendemword 
15d9			 
15d9 fe 04			cp 4 
15db cc 26 16			call z, .genutlword 
15de fe 05			cp 5 
15e0 cc 30 16			call z, .genspiword 
15e3 fe 06			cp 6 
15e5 cc 3a 16			call z, .genkeyword 
15e8 fe 07			cp 7 
15ea cc fe 15			call z, .gensoundword 
15ed fe 07			cp 7 
15ef cc f4 15			call z, .genhwword 
15f2 18 cb			jr create_startup 
15f4			 
15f4			.genhwword: 
15f4 21 af 1b			ld hl, crs_hw 
15f7 11 87 16			ld de, .hwworddef 
15fa cd 44 16			call .genfile 
15fd c9				ret 
15fe			.gensoundword: 
15fe 21 a3 1b			ld hl, crs_sound 
1601 11 95 16			ld de, .soundworddef 
1604 cd 44 16			call .genfile 
1607 c9				ret 
1608			.genlsword: 
1608 21 65 1b			ld hl, crs_s1 
160b 11 b9 16			ld de, .lsworddef 
160e cd 44 16			call .genfile 
1611 c9				ret 
1612			 
1612			.genedword: 
1612 11 bd 16			ld de, .edworddef 
1615 21 6e 1b			ld hl, crs_s2 
1618 cd 44 16			call .genfile 
161b c9				ret 
161c			 
161c			.gendemword: 
161c 11 c5 16			ld de, .demoworddef 
161f 21 77 1b			ld hl, crs_s3 
1622 cd 44 16			call .genfile 
1625 c9				ret 
1626			 
1626			.genutlword: 
1626 21 83 1b			ld hl, crs_s4 
1629 11 a9 16			ld de, .utilwordef 
162c cd 44 16			call .genfile 
162f c9				ret 
1630			.genspiword: 
1630 21 8a 1b			ld hl, crs_s5 
1633 11 e7 16			ld de, .spiworddef 
1636 cd 44 16			call .genfile 
1639 c9				ret 
163a			.genkeyword: 
163a 21 94 1b			ld hl, crs_s6 
163d 11 f5 16			ld de, .keyworddef 
1640 cd 44 16			call .genfile 
1643 c9				ret 
1644			 
1644			; hl - points to file name 
1644			; de - points to strings to add to file 
1644			 
1644			.genfile: 
1644 e5				push hl 
1645 d5				push de 
1646			 
1646 cd 9b 0d			call clear_display 
1649 3e 00			ld a, display_row_1 
164b 11 76 16			ld de, .genfiletxt 
164e cd ae 0d			call str_at_display 
1651 cd be 0d			call update_display 
1654			 
1654 d1				pop de 
1655 e1				pop hl 
1656			 
1656			 
1656 d5				push de 
1657 cd 68 08			call storage_create 
165a				; id in hl 
165a d1				pop de   ; table of strings to add 
165b			 
165b			.genloop: 
165b			 
165b e5				push hl ; save id for next time around 
165c d5				push de ; save de for next time around 
165d			 
165d eb				ex de, hl 
165e cd 60 23			call loadwordinhl 
1661 eb				ex de, hl 
1662			 
1662				; need hl to be the id 
1662				; need de to be the string ptr 
1662				 
1662 cd 55 0b			call storage_append 
1665			 
1665 d1				pop de 
1666 e1				pop hl 
1667			 
1667 13				inc de 
1668 13				inc de 
1669			 
1669 1a				ld a,(de) 
166a fe 00			cp 0 
166c 20 ed			jr nz, .genloop 
166e 13				inc de 
166f 1a				ld a, (de) 
1670 1b				dec de 
1671 fe 00			cp 0 
1673 20 e6			jr nz, .genloop	 
1675			 
1675 c9				ret 
1676			 
1676 .. 00		.genfiletxt:  db "Creating file...",0 
1687			 
1687			.hwworddef: 
1687 f7 64			dw test5 
1689 2f 65			dw test6 
168b 67 65			dw test7 
168d 7b 65			dw test8 
168f a7 65			dw test9 
1691 bd 65			dw test10 
1693 00 00			dw 0 
1695			 
1695			.soundworddef: 
1695 e2 65			dw sound1 
1697 06 66			dw sound2 
1699 36 66			dw sound3 
169b 5b 66			dw sound4 
169d 68 66			dw sound5 
169f 75 66			dw sound6 
16a1 82 66			dw sound7 
16a3 8f 66			dw sound8 
16a5 a7 66			dw sound9 
16a7 00 00			dw 0 
16a9			 
16a9			.utilwordef: 
16a9 30 63			dw strncpy 
16ab 0b 63			dw type 
16ad d7 62			dw clrstack 
16af 90 62			dw longread 
16b1 91 63			dw start1 
16b3 a1 63			dw start2 
16b5			; duplicated 
16b5			;	dw start3b 
16b5			;	dw start3c 
16b5 8d 64			dw list 
16b7 00 00			dw 0 
16b9			 
16b9			.lsworddef: 
16b9 b2 63			dw start3b 
16bb 00 00			dw 0 
16bd			 
16bd			.edworddef: 
16bd ef 5e			dw edit1 
16bf 10 5f			dw edit2 
16c1 45 5f			dw edit3 
16c3 00 00			dw 0 
16c5			 
16c5			.demoworddef: 
16c5 be 66			dw game1 
16c7 cf 66			dw game1a 
16c9 31 67			dw game1b 
16cb 66 67			dw game1c 
16cd 9c 67			dw game1d 
16cf cd 67			dw game1s 
16d1 e1 67			dw game1t 
16d3 f6 67			dw game1f 
16d5 2a 68			dw game1z 
16d7 6e 68			dw game1zz 
16d9 d7 68			dw ssv2 
16db 0d 69			dw ssv3 
16dd 29 69			dw ssv4 
16df 45 69			dw ssv5 
16e1 5e 69			dw ssv1 
16e3 a6 69			dw ssv1cpm	 
16e5			;	dw game2b 
16e5			;	dw game2bf 
16e5			;	dw game2mba 
16e5			;	dw game2mbas	 
16e5			;	dw game2mbht 
16e5			;	dw game2mbms 
16e5			;	dw game2mb 
16e5			;	dw game3w 
16e5			;	dw game3p 
16e5			;	dw game3sc 
16e5			;	dw game3vsi 
16e5			;	dw game3vs 
16e5 00 00			dw 0 
16e7			 
16e7			 
16e7			.spiworddef: 
16e7			 
16e7 7d 5f		    dw spi1 
16e9 d6 5f		    dw spi2 
16eb 0a 60		    dw spi2b 
16ed 8e 60		    dw spi3 
16ef 38 60		    dw spi4 
16f1 61 60		    dw spi5 
16f3			;    dw spi6 
16f3			;    dw spi7 
16f3			 
16f3			;    dw spi8 
16f3			;    dw spi9 
16f3			;    dw spi10 
16f3 00 00		    dw 0 
16f5			 
16f5			.keyworddef: 
16f5			 
16f5 fd 69			dw keyup 
16f7 0b 6a			dw keydown 
16f9 1b 6a			dw keyleft 
16fb 2b 6a			dw keyright 
16fd 3c 6a			dw 	keyf1 
16ff 4a 6a			dw keyf2 
1701 58 6a			dw keyf3 
1703 66 6a			dw keyf4 
1705 74 6a			dw keyf5 
1707 82 6a			dw keyf6 
1709 90 6a			dw keyf7 
170b 9e 6a			dw keyf8 
170d ac 6a			dw keyf9 
170f ba 6a			dw keyf10 
1711 c9 6a			dw keyf11 
1713 d8 6a			dw keyf12 
1715 e7 6a			dw keytab 
1717 f6 6a			dw keycr 
1719 04 6b			dw keyhome 
171b 14 6b			dw keyend 
171d 23 6b			dw keybs 
171f 00 00			dw 0 
1721			 
1721			.crstart: 
1721 65 1b			dw crs_s1 
1723 6e 1b			dw crs_s2 
1725 77 1b			dw crs_s3 
1727 83 1b			dw crs_s4 
1729 8a 1b			dw crs_s5 
172b 94 1b			dw crs_s6 
172d a3 1b			dw crs_sound 
172f af 1b			dw crs_hw 
1731 00 00			dw 0 
1733			 
1733			endif 
1733			 
1733			 
1733			if STORAGE_SE 
1733			 
1733			config_fdir: 
1733				; using the scratch dir go through and release the memory allocated for each string 
1733				 
1733 21 fc f0			ld hl, scratch 
1736 5e			.cfdir:	ld e,(hl) 
1737 23				inc hl 
1738 56				ld d,(hl) 
1739 23				inc hl 
173a			 
173a eb				ex de, hl 
173b cd f8 0f			call ishlzero 
173e c8				ret z     ; return on null pointer 
173f cd 74 14			call free 
1742 eb				ex de, hl 
1743 18 f1			jr .cfdir 
1745			 
1745			 
1745 c9				ret 
1746			 
1746			 
1746			config_dir: 
1746			 
1746				; for the config menus that need to build a directory of storage call this routine 
1746				; it will construct a menu in scratch to pass to menu 
1746			 
1746				; open storage device 
1746			 
1746				; execute DIR to build a list of files and their ids into scratch in menu format 
1746				; once the menu has finished then will need to call config_fdir to release the strings 
1746				 
1746				; c = number items 
1746			 
1746				 
1746 cd 16 05			call storage_get_block_0 
1749			 
1749 21 b5 f9			ld hl, store_page     ; get current id count 
174c 46				ld b, (hl) 
174d 0e 00			ld c, 0    ; count of files   
174f			 
174f			 
174f 21 fc f0			ld hl, scratch 
1752 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
1755			 
1755				; check for empty drive 
1755			 
1755 3e 00			ld a, 0 
1757 b8				cp b 
1758 ca f2 17			jp z, .dirdone 
175b			 
175b				 
175b					if DEBUG_FORTH_WORDS 
175b						DMARK "Cdc" 
175b f5				push af  
175c 3a 70 17			ld a, (.dmark)  
175f 32 a6 fd			ld (debug_mark),a  
1762 3a 71 17			ld a, (.dmark+1)  
1765 32 a7 fd			ld (debug_mark+1),a  
1768 3a 72 17			ld a, (.dmark+2)  
176b 32 a8 fd			ld (debug_mark+2),a  
176e 18 03			jr .pastdmark  
1770 ..			.dmark: db "Cdc"  
1773 f1			.pastdmark: pop af  
1774			endm  
# End of macro DMARK
1774						CALLMONITOR 
1774 cd aa fd			call debug_vector  
1777				endm  
# End of macro CALLMONITOR
1777					endif 
1777			 
1777			 
1777			.diritem:	 
1777 c5				push bc 
1778				; for each of the current ids do a search for them and if found push to stack 
1778			 
1778 21 40 00				ld hl, STORE_BLOCK_PHY 
177b 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
177d 58					ld e,b 
177e			 
177e cd 98 07				call storage_findnextid 
1781			 
1781			 
1781					; if found hl will be non zero 
1781			 
1781 cd f8 0f				call ishlzero 
1784 28 69				jr z, .dirnotfound 
1786			 
1786					; increase count 
1786			 
1786 c1					pop bc	 
1787 0c					inc c 
1788 c5					push bc 
1789					 
1789			 
1789					; get file header and push the file name 
1789			 
1789 11 b5 f9				ld de, store_page 
178c cd 65 04				call storage_read_block 
178f			 
178f					; push file id to stack 
178f				 
178f 3a b5 f9				ld a, (store_page) 
1792 26 00				ld h, 0 
1794 6f					ld l, a 
1795			 
1795					;call forth_push_numhl 
1795					; TODO store id 
1795			 
1795 e5					push hl 
1796			 
1796					; push extent count to stack  
1796				 
1796 21 b8 f9				ld hl, store_page+3 
1799			 
1799					; get file name length 
1799			 
1799 cd 35 13				call strlenz   
179c			 
179c 23					inc hl   ; cover zero term 
179d 23					inc hl  ; stick the id at the end of the area 
179e			 
179e e5					push hl 
179f c1					pop bc    ; move length to bc 
17a0			 
17a0 cd aa 13				call malloc 
17a3			 
17a3					; TODO save malloc area to scratch 
17a3			 
17a3 eb					ex de, hl 
17a4 2a ac f9				ld hl, (store_tmp2) 
17a7 73					ld (hl), e 
17a8 23					inc hl 
17a9 72					ld (hl), d 
17aa 23					inc hl 
17ab 22 ac f9				ld (store_tmp2), hl 
17ae			 
17ae					 
17ae			 
17ae					;pop hl   ; get source 
17ae			;		ex de, hl    ; swap aronund	 
17ae			 
17ae 21 b8 f9				ld hl, store_page+3 
17b1					if DEBUG_FORTH_WORDS 
17b1						DMARK "CFd" 
17b1 f5				push af  
17b2 3a c6 17			ld a, (.dmark)  
17b5 32 a6 fd			ld (debug_mark),a  
17b8 3a c7 17			ld a, (.dmark+1)  
17bb 32 a7 fd			ld (debug_mark+1),a  
17be 3a c8 17			ld a, (.dmark+2)  
17c1 32 a8 fd			ld (debug_mark+2),a  
17c4 18 03			jr .pastdmark  
17c6 ..			.dmark: db "CFd"  
17c9 f1			.pastdmark: pop af  
17ca			endm  
# End of macro DMARK
17ca						CALLMONITOR 
17ca cd aa fd			call debug_vector  
17cd				endm  
# End of macro CALLMONITOR
17cd					endif 
17cd ed b0				ldir 
17cf			 
17cf					; de is past string, move back one and store id 
17cf					 
17cf 1b					dec de 
17d0			 
17d0					; store file id 
17d0			 
17d0 e1					pop hl 
17d1 eb					ex de,hl 
17d2 73					ld (hl), e 
17d3			 
17d3					if DEBUG_FORTH_WORDS 
17d3						DMARK "Cdi" 
17d3 f5				push af  
17d4 3a e8 17			ld a, (.dmark)  
17d7 32 a6 fd			ld (debug_mark),a  
17da 3a e9 17			ld a, (.dmark+1)  
17dd 32 a7 fd			ld (debug_mark+1),a  
17e0 3a ea 17			ld a, (.dmark+2)  
17e3 32 a8 fd			ld (debug_mark+2),a  
17e6 18 03			jr .pastdmark  
17e8 ..			.dmark: db "Cdi"  
17eb f1			.pastdmark: pop af  
17ec			endm  
# End of macro DMARK
17ec						CALLMONITOR 
17ec cd aa fd			call debug_vector  
17ef				endm  
# End of macro CALLMONITOR
17ef					endif 
17ef					 
17ef			.dirnotfound: 
17ef c1					pop bc     
17f0 10 85				djnz .diritem 
17f2				 
17f2			.dirdone:	 
17f2			 
17f2 3e 00				ld a, 0 
17f4 2a ac f9				ld hl, (store_tmp2) 
17f7 77					ld (hl), a 
17f8 23					inc hl 
17f9 77					ld (hl), a 
17fa 23					inc hl 
17fb					; push a count of the dir items found 
17fb			 
17fb			;		ld h, 0 
17fb			;		ld l, c 
17fb			 
17fb c9				ret 
17fc			 
17fc			endif 
17fc			 
17fc			 
17fc			; Settings 
17fc			; Run  
17fc			 
17fc			 
17fc			 
17fc			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17fc			;;hd_menu2:   db "        2: Editor",0   
17fc			;hd_menu2:   db "        2: Editor       6: Menu",0   
17fc			;hd_menu3:   db "        3: Storage",0 
17fc			;hd_menu4:   db "0=quit  4: Debug",0 
17fc			;hd_don:     db "ON",0 
17fc			;hd_doff:     db "OFF",0 
17fc			; 
17fc			; 
17fc			; 
17fc			;hardware_diags_old:       
17fc			; 
17fc			;.diagmenu: 
17fc			;	call clear_display 
17fc			;	ld a, display_row_1 
17fc			;	ld de, hd_menu1 
17fc			;	call str_at_display 
17fc			; 
17fc			;	ld a, display_row_2 
17fc			;	ld de, hd_menu2 
17fc			;	call str_at_display 
17fc			; 
17fc			;	ld a, display_row_3 
17fc			;	ld de, hd_menu3 
17fc			;	call str_at_display 
17fc			; 
17fc			;	ld a,  display_row_4 
17fc			;	ld de, hd_menu4 
17fc			;	call str_at_display 
17fc			; 
17fc			;	; display debug state 
17fc			; 
17fc			;	ld de, hd_don 
17fc			;	ld a, (os_view_disable) 
17fc			;	cp 0 
17fc			;	jr z, .distog 
17fc			;	ld de, hd_doff 
17fc			;.distog: ld a, display_row_4+17 
17fc			;	call str_at_display 
17fc			; 
17fc			;	call update_display 
17fc			; 
17fc			;	call cin_wait 
17fc			; 
17fc			; 
17fc			; 
17fc			;	cp '4' 
17fc			;	jr nz, .diagn1 
17fc			; 
17fc			;	; debug toggle 
17fc			; 
17fc			;	ld a, (os_view_disable) 
17fc			;	ld b, '*' 
17fc			;	cp 0 
17fc			;	jr z, .debtog 
17fc			;	ld b, 0 
17fc			;.debtog:	 
17fc			;	ld a,b 
17fc			;	ld (os_view_disable),a 
17fc			; 
17fc			;.diagn1: cp '0' 
17fc			;	 ret z 
17fc			; 
17fc			;;	cp '1' 
17fc			;;       jp z, matrix	 
17fc			;;   TODO keyboard matrix test 
17fc			; 
17fc			;	cp '2' 
17fc			;	jp z, .diagedit 
17fc			; 
17fc			;;	cp '6' 
17fc			;;	jp z, .menutest 
17fc			;;if ENABLE_BASIC 
17fc			;;	cp '6' 
17fc			;;	jp z, basic 
17fc			;;endif 
17fc			 ; 
17fc			;	jp .diagmenu 
17fc			; 
17fc			; 
17fc			;	ret 
17fc			 
17fc			 
17fc			.debug_tog: 
17fc 21 46 18			ld hl, .menudebug 
17ff				 
17ff			;	ld a, (os_view_disable) 
17ff			;	cp '*' 
17ff 3a aa fd			ld a,(debug_vector) 
1802 fe c9			cp $C9   ; RET 
1804 20 04			jr nz,.tdon  
1806 3e 01			ld a, 1 
1808 18 02			jr .tog1 
180a 3e 00		.tdon: ld a, 0 
180c			 
180c			.tog1: 
180c cd cc 0d			call menu 
180f fe 00			cp 0 
1811 c8				ret z 
1812 fe 01			cp 1    ; disable debug 
1814 28 04			jr z, .dtog0 
1816 3e 2a			ld a, '*' 
1818 18 05			jr .dtogset 
181a			.dtog0:  
181a				;ld a, 0 
181a cd 38 19			call bp_on 
181d 18 dd			jr .debug_tog 
181f			.dtogset:  
181f				; ld (os_view_disable), a 
181f cd 44 19			call bp_off 
1822 c3 fc 17			jp .debug_tog 
1825			 
1825			 
1825			hardware_diags:       
1825			 
1825			.diagm: 
1825 21 38 18			ld hl, .menuitems 
1828 3e 00			ld a, 0 
182a cd cc 0d			call menu 
182d			 
182d fe 00		         cp 0 
182f c8				 ret z 
1830			 
1830 fe 02			cp 2 
1832 ca 91 18			jp z, .diagedit 
1835			 
1835			;	cp '6' 
1835			;	jp z, .menutest 
1835			;if ENABLE_BASIC 
1835			;	cp '6' 
1835			;	jp z, basic 
1835			;endif 
1835			  
1835 c3 25 18			jp .diagm 
1838			 
1838				 
1838 4c 18		.menuitems:   	dw .m1 
183a 57 18				dw .m2 
183c 5e 18				dw .m3 
183e 66 18				dw .m5 
1840 6c 18				dw .m5a 
1842 75 18				dw .m5b 
1844 00 00				dw 0 
1846			 
1846			.menudebug: 
1846 7e 18				dw .m6 
1848 87 18				dw .m7 
184a 00 00				dw 0 
184c			 
184c .. 00		.m1:   db "Key Matrix",0 
1857 .. 00		.m2:   db "Editor",0 
185e .. 00		.m3:   db "Storage",0 
1866 .. 00		.m5:   db "Sound",0 
186c .. 00		.m5a:  db "RAM Test",0 
1875 .. 00		.m5b:  db "LCD Test",0 
187e			 
187e .. 00		.m6:   db "Debug ON",0 
1887 .. 00		.m7:   db "Debug OFF",0 
1891			 
1891			; debug editor 
1891			 
1891			.diagedit: 
1891			 
1891 21 fc f0			ld hl, scratch 
1894			;	ld bc, 250 
1894			;	ldir 
1894				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1894 3e 00			ld a, 0 
1896 77				ld (hl), a 
1897 23				inc hl 
1898 77				ld (hl), a 
1899 23				inc hl 
189a 77				ld (hl), a 
189b			 
189b cd 9b 0d		        call clear_display 
189e cd be 0d			call update_display 
18a1				;ld a, 1 
18a1				;ld (hardware_diag), a 
18a1			.diloop: 
18a1 3e 00			ld a, display_row_1 
18a3 0e 00			ld c, 0 
18a5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18a7 1e 28			ld e, 40 
18a9			 
18a9 21 fc f0			ld hl, scratch	 
18ac cd fc 0f			call input_str 
18af			 
18af 3e 28			ld a, display_row_2 
18b1 11 fc f0			ld de, scratch 
18b4 cd ae 0d			call str_at_display 
18b7 cd be 0d			call update_display 
18ba			 
18ba c3 a1 18			jp .diloop 
18bd			 
18bd			 
18bd			; pass word in hl 
18bd			; a has display location 
18bd			display_word_at: 
18bd f5				push af 
18be e5				push hl 
18bf 7c				ld a,h 
18c0 21 01 f4			ld hl, os_word_scratch 
18c3 cd d8 11			call hexout 
18c6 e1				pop hl 
18c7 7d				ld a,l 
18c8 21 03 f4			ld hl, os_word_scratch+2 
18cb cd d8 11			call hexout 
18ce 21 05 f4			ld hl, os_word_scratch+4 
18d1 3e 00			ld a,0 
18d3 77				ld (hl),a 
18d4 11 01 f4			ld de,os_word_scratch 
18d7 f1				pop af 
18d8 cd ae 0d				call str_at_display 
18db c9				ret 
18dc			 
18dc			display_ptr_state: 
18dc			 
18dc				; to restore afterwards 
18dc			 
18dc d5				push de 
18dd c5				push bc 
18de e5				push hl 
18df f5				push af 
18e0			 
18e0				; for use in here 
18e0			 
18e0			;	push bc 
18e0			;	push de 
18e0			;	push hl 
18e0			;	push af 
18e0			 
18e0 cd 9b 0d			call clear_display 
18e3			 
18e3 11 bb 1a			ld de, .ptrstate 
18e6 3e 00			ld a, display_row_1 
18e8 cd ae 0d			call str_at_display 
18eb			 
18eb				; display debug step 
18eb			 
18eb			 
18eb 11 a6 fd			ld de, debug_mark 
18ee 3e 26			ld a, display_row_1+display_cols-2 
18f0 cd ae 0d			call str_at_display 
18f3			 
18f3				; display a 
18f3 11 c5 1a			ld de, .ptrcliptr 
18f6 3e 28			ld a, display_row_2 
18f8 cd ae 0d			call str_at_display 
18fb			 
18fb f1				pop af 
18fc 2a 7b f9			ld hl,(cli_ptr) 
18ff 3e 30			ld a, display_row_2+8 
1901 cd bd 18			call display_word_at 
1904			 
1904			 
1904				; display hl 
1904			 
1904			 
1904 11 cd 1a			ld de, .ptrclioptr 
1907 3e 32			ld a, display_row_2+10 
1909 cd ae 0d			call str_at_display 
190c			; 
190c			;	pop hl 
190c 3e 35			ld a, display_row_2+13 
190e 2a 79 f9			ld hl,(cli_origptr) 
1911 cd bd 18			call display_word_at 
1914			; 
1914			;	 
1914			;	; display de 
1914			 
1914			;	ld de, .regstatede 
1914			;	ld a, display_row_3 
1914			;	call str_at_display 
1914			 
1914			;	pop de 
1914			;	ld h,d 
1914			;	ld l, e 
1914			;	ld a, display_row_3+3 
1914			;	call display_word_at 
1914			 
1914			 
1914				; display bc 
1914			 
1914			;	ld de, .regstatebc 
1914			;	ld a, display_row_3+10 
1914			;	call str_at_display 
1914			 
1914			;	pop bc 
1914			;	ld h,b 
1914			;	ld l, c 
1914			;	ld a, display_row_3+13 
1914			;	call display_word_at 
1914			 
1914			 
1914				; display dsp 
1914			 
1914			;	ld de, .regstatedsp 
1914			;	ld a, display_row_4 
1914			;	call str_at_display 
1914			 
1914				 
1914			;	ld hl,(cli_data_sp) 
1914			;	ld a, display_row_4+4 
1914			;	call display_word_at 
1914			 
1914				; display rsp 
1914			 
1914 11 fc 1a			ld de, .regstatersp 
1917 3e 82			ld a, display_row_4+10 
1919 cd ae 0d			call str_at_display 
191c			 
191c				 
191c 2a 2d f9			ld hl,(cli_ret_sp) 
191f 3e 86			ld a, display_row_4+14 
1921 cd bd 18			call display_word_at 
1924			 
1924 cd be 0d			call update_display 
1927			 
1927 cd de 0c			call delay1s 
192a cd de 0c			call delay1s 
192d cd de 0c			call delay1s 
1930			 
1930			 
1930 cd 9b 1f			call next_page_prompt 
1933			 
1933				; restore  
1933			 
1933 f1				pop af 
1934 e1				pop hl 
1935 c1				pop bc 
1936 d1				pop de 
1937 c9				ret 
1938			 
1938			; Update the break point vector so that the user can hook a new routine 
1938			 
1938			bp_on: 
1938 3e c3			ld a, $c3    ; JP 
193a 32 aa fd			ld (debug_vector), a 
193d 21 4a 19			ld hl, break_point_state 
1940 22 ab fd			ld (debug_vector+1), hl 
1943 c9				ret 
1944			 
1944			bp_off: 
1944 3e c9			ld a, $c9    ; RET 
1946 32 aa fd			ld (debug_vector), a 
1949 c9				ret 
194a			 
194a			 
194a			break_point_state: 
194a			;	push af 
194a			; 
194a			;	; see if disabled 
194a			; 
194a			;	ld a, (os_view_disable) 
194a			;	cp '*' 
194a			;	jr nz, .bpsgo 
194a			;	pop af 
194a			;	ret 
194a			 
194a			.bpsgo: 
194a			;	pop af 
194a f5				push af 
194b 22 de f0			ld (os_view_hl), hl 
194e ed 53 dc f0		ld (os_view_de), de 
1952 ed 43 da f0		ld (os_view_bc), bc 
1956 e5				push hl 
1957 6f				ld l, a 
1958 26 00			ld h, 0 
195a 22 e0 f0			ld (os_view_af),hl 
195d			 
195d 21 ec fc				ld hl, display_fb0 
1960 22 07 fb				ld (display_fb_active), hl 
1963 e1				pop hl	 
1964			 
1964 3e 31			ld a, '1' 
1966 fe 2a		.bps1:  cp '*' 
1968 cc 44 19			call z, bp_off 
196b			;	jr nz, .bps1b 
196b			;	ld (os_view_disable),a 
196b fe 31		.bps1b:  cp '1' 
196d 20 14			jr nz, .bps2 
196f			 
196f				; display reg 
196f			 
196f				 
196f			 
196f 3a e0 f0			ld a, (os_view_af) 
1972 2a de f0			ld hl, (os_view_hl) 
1975 ed 5b dc f0		ld de, (os_view_de) 
1979 ed 4b da f0		ld bc, (os_view_bc) 
197d cd 17 1a			call display_reg_state 
1980 c3 03 1a			jp .bpschk 
1983			 
1983 fe 32		.bps2:  cp '2' 
1985 20 08			jr nz, .bps3 
1987				 
1987				; display hl 
1987 2a de f0			ld hl, (os_view_hl) 
198a cd 01 1b			call display_dump_at_hl 
198d			 
198d 18 74			jr .bpschk 
198f			 
198f fe 33		.bps3:  cp '3' 
1991 20 08			jr nz, .bps4 
1993			 
1993			        ; display de 
1993 2a dc f0			ld hl, (os_view_de) 
1996 cd 01 1b			call display_dump_at_hl 
1999			 
1999 18 68			jr .bpschk 
199b fe 34		.bps4:  cp '4' 
199d 20 08			jr nz, .bps5 
199f			 
199f			        ; display bc 
199f 2a da f0			ld hl, (os_view_bc) 
19a2 cd 01 1b			call display_dump_at_hl 
19a5			 
19a5 18 5c			jr .bpschk 
19a7 fe 35		.bps5:  cp '5' 
19a9 20 08		        jr nz, .bps7 
19ab			 
19ab				; display cur ptr 
19ab 2a 7b f9			ld hl, (cli_ptr) 
19ae cd 01 1b			call display_dump_at_hl 
19b1			 
19b1 18 50			jr .bpschk 
19b3 fe 36		.bps7:  cp '6' 
19b5 20 08			jr nz, .bps8b 
19b7				 
19b7				; display cur orig ptr 
19b7 2a 79 f9			ld hl, (cli_origptr) 
19ba cd 01 1b			call display_dump_at_hl 
19bd 18 44			jr .bpschk 
19bf fe 37		.bps8b:  cp '7' 
19c1 20 08			jr nz, .bps9 
19c3				 
19c3				; display dsp 
19c3 2a 29 f9			ld hl, (cli_data_sp) 
19c6 cd 01 1b			call display_dump_at_hl 
19c9			 
19c9 18 38			jr .bpschk 
19cb fe 39		.bps9:  cp '9' 
19cd 20 05			jr nz, .bps8c 
19cf				 
19cf				; display SP 
19cf			;	ld hl, sp 
19cf cd 01 1b			call display_dump_at_hl 
19d2			 
19d2 18 2f			jr .bpschk 
19d4 fe 38		.bps8c:  cp '8' 
19d6 20 08			jr nz, .bps8d 
19d8				 
19d8				; display rsp 
19d8 2a 2d f9			ld hl, (cli_ret_sp) 
19db cd 01 1b			call display_dump_at_hl 
19de			 
19de 18 23			jr .bpschk 
19e0 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19e2 20 05			jr nz, .bps8 
19e4 cd 69 1d			call monitor 
19e7			 
19e7 18 1a			jr .bpschk 
19e9 fe 30		.bps8:  cp '0' 
19eb 20 16			jr nz, .bpschk 
19ed			 
19ed 21 4b fc				ld hl, display_fb1 
19f0 22 07 fb				ld (display_fb_active), hl 
19f3 cd be 0d				call update_display 
19f6			 
19f6				;ld a, (os_view_af) 
19f6 2a de f0			ld hl, (os_view_hl) 
19f9 ed 5b dc f0		ld de, (os_view_de) 
19fd ed 4b da f0		ld bc, (os_view_bc) 
1a01 f1				pop af 
1a02 c9				ret 
1a03			 
1a03			.bpschk:   
1a03 cd de 0c			call delay1s 
1a06 3e 9f		ld a,display_row_4 + display_cols - 1 
1a08 11 99 1f		        ld de, endprg 
1a0b cd ae 0d			call str_at_display 
1a0e cd be 0d			call update_display 
1a11 cd 9e 72			call cin_wait 
1a14			 
1a14 c3 66 19			jp .bps1 
1a17			 
1a17			 
1a17			display_reg_state: 
1a17			 
1a17				; to restore afterwards 
1a17			 
1a17 d5				push de 
1a18 c5				push bc 
1a19 e5				push hl 
1a1a f5				push af 
1a1b			 
1a1b				; for use in here 
1a1b			 
1a1b c5				push bc 
1a1c d5				push de 
1a1d e5				push hl 
1a1e f5				push af 
1a1f			 
1a1f cd 9b 0d			call clear_display 
1a22			 
1a22 11 d7 1a			ld de, .regstate 
1a25 3e 00			ld a, display_row_1 
1a27 cd ae 0d			call str_at_display 
1a2a			 
1a2a				; display debug step 
1a2a			 
1a2a			 
1a2a 11 a6 fd			ld de, debug_mark 
1a2d 3e 25			ld a, display_row_1+display_cols-3 
1a2f cd ae 0d			call str_at_display 
1a32			 
1a32				; display a 
1a32 11 f3 1a			ld de, .regstatea 
1a35 3e 28			ld a, display_row_2 
1a37 cd ae 0d			call str_at_display 
1a3a			 
1a3a e1				pop hl 
1a3b			;	ld h,0 
1a3b			;	ld l, a 
1a3b 3e 2b			ld a, display_row_2+3 
1a3d cd bd 18			call display_word_at 
1a40			 
1a40			 
1a40				; display hl 
1a40			 
1a40			 
1a40 11 e7 1a			ld de, .regstatehl 
1a43 3e 32			ld a, display_row_2+10 
1a45 cd ae 0d			call str_at_display 
1a48			 
1a48 e1				pop hl 
1a49 3e 35			ld a, display_row_2+13 
1a4b cd bd 18			call display_word_at 
1a4e			 
1a4e				 
1a4e				; display de 
1a4e			 
1a4e 11 eb 1a			ld de, .regstatede 
1a51 3e 50			ld a, display_row_3 
1a53 cd ae 0d			call str_at_display 
1a56			 
1a56 e1				pop hl 
1a57			;	ld h,d 
1a57			;	ld l, e 
1a57 3e 53			ld a, display_row_3+3 
1a59 cd bd 18			call display_word_at 
1a5c			 
1a5c			 
1a5c				; display bc 
1a5c			 
1a5c 11 ef 1a			ld de, .regstatebc 
1a5f 3e 5a			ld a, display_row_3+10 
1a61 cd ae 0d			call str_at_display 
1a64			 
1a64 e1				pop hl 
1a65			;	ld h,b 
1a65			;	ld l, c 
1a65 3e 5d			ld a, display_row_3+13 
1a67 cd bd 18			call display_word_at 
1a6a			 
1a6a			 
1a6a				; display dsp 
1a6a			 
1a6a 11 f7 1a			ld de, .regstatedsp 
1a6d 3e 78			ld a, display_row_4 
1a6f cd ae 0d			call str_at_display 
1a72			 
1a72				 
1a72 2a 29 f9			ld hl,(cli_data_sp) 
1a75 3e 7c			ld a, display_row_4+4 
1a77 cd bd 18			call display_word_at 
1a7a			 
1a7a				; display rsp 
1a7a			 
1a7a 11 fc 1a			ld de, .regstatersp 
1a7d 3e 82			ld a, display_row_4+10 
1a7f cd ae 0d			call str_at_display 
1a82			 
1a82				 
1a82 2a 2d f9			ld hl,(cli_ret_sp) 
1a85 3e 86			ld a, display_row_4+14 
1a87 cd bd 18			call display_word_at 
1a8a			 
1a8a cd be 0d			call update_display 
1a8d			 
1a8d			;	call delay1s 
1a8d			;	call delay1s 
1a8d			;	call delay1s 
1a8d			 
1a8d			 
1a8d			;	call next_page_prompt 
1a8d			 
1a8d				; restore  
1a8d			 
1a8d f1				pop af 
1a8e e1				pop hl 
1a8f c1				pop bc 
1a90 d1				pop de 
1a91 c9				ret 
1a92			 
1a92 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1aa6 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1abb .. 00		.ptrstate:	db "Ptr State",0 
1ac5 .. 00		.ptrcliptr:     db "cli_ptr",0 
1acd .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ad7 .. 00		.regstate:	db "Reg State (1/0)",0 
1ae7 .. 00		.regstatehl:	db "HL:",0 
1aeb .. 00		.regstatede:	db "DE:",0 
1aef .. 00		.regstatebc:	db "BC:",0 
1af3 .. 00		.regstatea:	db "A :",0 
1af7 .. 00		.regstatedsp:	db "DSP:",0 
1afc .. 00		.regstatersp:	db "RSP:",0 
1b01			 
1b01			display_dump_at_hl: 
1b01 e5				push hl 
1b02 d5				push de 
1b03 c5				push bc 
1b04 f5				push af 
1b05			 
1b05 22 1f f4			ld (os_cur_ptr),hl	 
1b08 cd 9b 0d			call clear_display 
1b0b cd a3 1e			call dumpcont 
1b0e			;	call delay1s 
1b0e			;	call next_page_prompt 
1b0e			 
1b0e			 
1b0e f1				pop af 
1b0f c1				pop bc 
1b10 d1				pop de 
1b11 e1				pop hl 
1b12 c9				ret 
1b13			 
1b13			;if ENABLE_BASIC 
1b13			;	include "nascombasic.asm" 
1b13			;	basic: 
1b13			;	include "forth/FORTH.ASM" 
1b13			;endif 
1b13			 
1b13			; eof 
1b13			 
1b13			 
# End of file firmware_diags.asm
1b13			  
1b13			include "firmware_prompts.asm"  
1b13			; Prompts  
1b13			 
1b13			; boot messages 
1b13			 
1b13 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b28 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b38			 
1b38			 
1b38			; config menus 
1b38			 
1b38			;prom_c3: db "Add Dictionary To File",0 
1b38			 
1b38			if STARTUP_V1 
1b38			prom_c2: db "Select Autoload File",0 
1b38			prom_c2a: db "Disable Autoload File", 0 
1b38			endif 
1b38			 
1b38			if STARTUP_V2 
1b38 .. 00		prom_c2: db "Enable Autoload Files",0 
1b4e .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b65			 
1b65 .. 00		crs_s1: db "*ls-word", 0 
1b6e .. 00		crs_s2: db "*ed-word", 0 
1b77 .. 00		crs_s3: db "*Demo-Games", 0 
1b83 .. 00		crs_s4: db "*Utils", 0 
1b8a .. 00		crs_s5: db "*SPI-Util", 0 
1b94 .. 00		crs_s6: db "*Key-Constants", 0 
1ba3 .. 00		crs_sound: db "*Sound-Util", 0 
1baf .. 00		crs_hw: db "*Hello-World",0 
1bbc			 
1bbc			 
1bbc			 
1bbc			endif 
1bbc			;prom_c2b: db "Select Storage Bank",0 
1bbc .. 00		prom_c4: db "Settings",0 
1bc5 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1be0 .. 00		prom_m4b:   db "Monitor",0 
1be8 .. 00		prom_c1: db "Hardware Diags",0 
1bf7			 
1bf7			 
1bf7			if STARTUP_V2 
1bf7 .. 00		prom_c9: db "Create Startup Files",0 
1c0c			endif 
1c0c			 
1c0c .. 00		prom_notav:    db "Feature not available",0 
1c22 .. 00		prom_empty:    db "",0 
1c23			 
1c23			; eof 
1c23			 
# End of file firmware_prompts.asm
1c23			  
1c23			  
1c23			; eof  
1c23			  
# End of file firmware.asm
1c23			 
1c23			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c23			;if BASE_KEV  
1c23			;baseram: equ 08000h 
1c23			;endif 
1c23			 
1c23			;if BASE_SC114 
1c23			;baseram:     equ    endofcode 
1c23			;endif 
1c23			 
1c23			 
1c23			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c23			 
1c23			; start system 
1c23			 
1c23			coldstart: 
1c23				; set sp 
1c23				; di/ei 
1c23			 
1c23 f3				di 
1c24 31 fd ff			ld sp, tos 
1c27 cd 25 6f			call init_nmi 
1c2a			;	ei 
1c2a			 
1c2a				; init spinner 
1c2a 3e 00			ld a,0 
1c2c 32 01 fb			ld (display_active), a 
1c2f			 
1c2f				; disable breakpoint by default 
1c2f			 
1c2f				;ld a,'*' 
1c2f			;	ld a,' ' 
1c2f			;	ld (os_view_disable),a 
1c2f			 
1c2f				; set break point vector as new break point on or off 
1c2f cd 44 19			call bp_off 
1c32			 
1c32				; init hardware 
1c32			 
1c32				; init keyboard and screen hardware 
1c32			 
1c32 cd 68 00			call hardware_init 
1c35			 
1c35			 
1c35 cd de 0c			call delay1s 
1c38 3e 58			ld a, display_row_3+8 
1c3a 11 03 00			ld de, buildtime 
1c3d cd ae 0d			call str_at_display 
1c40 cd be 0d			call update_display 
1c43			 
1c43 cd de 0c			call delay1s 
1c46 cd de 0c			call delay1s 
1c49 cd de 0c			call delay1s 
1c4c			 
1c4c				; detect if any keys are held down to enable breakpoints at start up 
1c4c			 
1c4c cd af 72			call cin  
1c4f fe 00			cp 0 
1c51 28 03			jr z, .nokeys 
1c53			 
1c53				;call hardware_diags 
1c53 cd 43 15			call config 
1c56			 
1c56			;	ld de, .bpen 
1c56			;	ld a, display_row_4 
1c56			;	call str_at_display 
1c56			;	call update_display 
1c56			; 
1c56			;	ld a,0 
1c56			;	ld (os_view_disable),a 
1c56			; 
1c56			;.bpwait: 
1c56			;	call cin 
1c56			;	cp 0 
1c56			;	jr z, .bpwait 
1c56			;	jr .nokeys 
1c56			; 
1c56			; 
1c56			;.bpen:  db "Break points enabled!",0 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			.nokeys: 
1c56			 
1c56			 
1c56				 
1c56			 
1c56			;jp  testkey 
1c56			 
1c56			;call storage_get_block_0 
1c56			; 
1c56			;ld hl, 0 
1c56			;ld de, store_page 
1c56			;call storage_read_block 
1c56			 
1c56				 
1c56			;ld hl, 10 
1c56			;ld de, store_page 
1c56			;call storage_read_block 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			;stop:	nop 
1c56			;	jp stop 
1c56			 
1c56			 
1c56			 
1c56			main: 
1c56 cd 9b 0d			call clear_display 
1c59 cd be 0d			call update_display 
1c5c			 
1c5c			 
1c5c			 
1c5c			;	call testlcd 
1c5c			 
1c5c			 
1c5c			 
1c5c cd ae 23			call forth_init 
1c5f			 
1c5f			 
1c5f			warmstart: 
1c5f cd 84 23			call forth_warmstart 
1c62			 
1c62				; run startup word load 
1c62			        ; TODO prevent this running at warmstart after crash  
1c62			 
1c62				if STARTUP_ENABLE 
1c62			 
1c62					if STARTUP_V1 
1c62			 
1c62						if STORAGE_SE 
1c62							call forth_autoload 
1c62						endif 
1c62						call forth_startup 
1c62					endif 
1c62			 
1c62					if STARTUP_V2 
1c62			 
1c62						if STORAGE_SE 
1c62 cd 53 6d						call forth_autoload 
1c65						else 
1c65							call forth_startup 
1c65						endif 
1c65			 
1c65			 
1c65					endif 
1c65			 
1c65				endif 
1c65			 
1c65				; show free memory after boot 
1c65 11 04 1d			ld de, freeram 
1c68 3e 00			ld a, display_row_1 
1c6a cd ae 0d			call str_at_display 
1c6d			 
1c6d				; get current heap start after loading any uwords 
1c6d			 
1c6d				;ld de, (os_last_new_uword) 
1c6d				;ex de, hl 
1c6d			 
1c6d			; Or use heap_size word???? 
1c6d				;ld hl, heap_end 
1c6d				;ld hl, heap_size 
1c6d				;ld de, topusermem 
1c6d				;ld de, heap_start 
1c6d ed 5b 0a 80			ld de, (free_list )      
1c71 21 d7 f0				ld hl, heap_end 
1c74 ed 52			sbc hl, de 
1c76				;push hl 
1c76				;ld a,h	         	 
1c76				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c76				;call hexout 
1c76			   	;pop hl 
1c76			; 
1c76			;	ld a,l 
1c76			;	ld hl, os_word_scratch+2 
1c76			;	call hexout 
1c76			;	ld hl, os_word_scratch+4 
1c76			;	ld a, 0 
1c76			;	ld (hl),a 
1c76 eb				ex de, hl 
1c77 21 01 f4			ld hl, os_word_scratch 
1c7a cd e4 12			call uitoa_16 
1c7d			 
1c7d			 
1c7d 11 01 f4			ld de, os_word_scratch 
1c80 3e 0d			ld a, display_row_1 + 13 
1c82 cd ae 0d			call str_at_display 
1c85 cd be 0d			call update_display 
1c88			 
1c88			 
1c88				;call demo 
1c88			 
1c88			 
1c88				; init scratch input area for cli commands 
1c88			 
1c88 21 23 f4			ld hl, os_cli_cmd 
1c8b 3e 00			ld a,0 
1c8d 77				ld (hl),a 
1c8e 23				inc hl 
1c8f 77				ld (hl),a 
1c90			 
1c90 3e 00			ld a,0 
1c92 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c95			 
1c95 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c98 32 20 f4			ld (os_cur_ptr+1),a	 
1c9b			 
1c9b 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c9e 32 02 f4			ld (os_word_scratch+1),a	 
1ca1				 
1ca1			 
1ca1				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ca1 21 23 f4			ld hl, os_cli_cmd 
1ca4			 
1ca4 3e 00			ld a, 0		 ; init cli input 
1ca6 77				ld (hl), a 
1ca7 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ca9			cli: 
1ca9				; show cli prompt 
1ca9				;push af 
1ca9				;ld a, 0 
1ca9				;ld de, prompt 
1ca9				;call str_at_display 
1ca9			 
1ca9				;call update_display 
1ca9				;pop af 
1ca9				;inc a 
1ca9				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ca9			 
1ca9			.lastrecall: 
1ca9			 
1ca9 0e 00			ld c, 0 
1cab 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cad 1e 28			ld e, 40 
1caf			 
1caf 21 23 f4			ld hl, os_cli_cmd 
1cb2			 
1cb2				STACKFRAME OFF $fefe $9f9f 
1cb2				if DEBUG_STACK_IMB 
1cb2					if OFF 
1cb2						exx 
1cb2						ld de, $fefe 
1cb2						ld a, d 
1cb2						ld hl, curframe 
1cb2						call hexout 
1cb2						ld a, e 
1cb2						ld hl, curframe+2 
1cb2						call hexout 
1cb2						ld hl, $fefe 
1cb2						push hl 
1cb2						ld hl, $9f9f 
1cb2						push hl 
1cb2						exx 
1cb2					endif 
1cb2				endif 
1cb2			endm 
# End of macro STACKFRAME
1cb2			 
1cb2 cd fc 0f			call input_str 
1cb5			 
1cb5				STACKFRAMECHK OFF $fefe $9f9f 
1cb5				if DEBUG_STACK_IMB 
1cb5					if OFF 
1cb5						exx 
1cb5						ld hl, $9f9f 
1cb5						pop de   ; $9f9f 
1cb5						call cmp16 
1cb5						jr nz, .spnosame 
1cb5						ld hl, $fefe 
1cb5						pop de   ; $fefe 
1cb5						call cmp16 
1cb5						jr z, .spfrsame 
1cb5						.spnosame: call showsperror 
1cb5						.spfrsame: nop 
1cb5						exx 
1cb5					endif 
1cb5				endif 
1cb5			endm 
# End of macro STACKFRAMECHK
1cb5			 
1cb5			 
1cb5				; check to see if last line recall has been requested 
1cb5			 
1cb5			if EDIT_V2 
1cb5 fe 05			cp KEY_UP 
1cb7 20 0f			jr nz, .noexecline 
1cb9			 
1cb9 11 23 f4			ld de, os_cli_cmd 
1cbc 21 22 f5			ld hl, os_last_cmd 
1cbf 01 ff 00			ld bc, 255 
1cc2 ed b0			ldir 
1cc4 3e 00			ld a, 0 
1cc6 18 e1			jr .lastrecall 
1cc8			endif 
1cc8			 
1cc8			.noexecline: 
1cc8				; no so exec the line		 
1cc8			 
1cc8				; copy input to last command 
1cc8			 
1cc8 21 23 f4			ld hl, os_cli_cmd 
1ccb 11 22 f5			ld de, os_last_cmd 
1cce 01 ff 00			ld bc, 255 
1cd1 ed b0			ldir 
1cd3			 
1cd3				; wipe current buffer 
1cd3			 
1cd3			;	ld a, 0 
1cd3			;	ld hl, os_cli_cmd 
1cd3			;	ld de, os_cli_cmd+1 
1cd3			;	ld bc, 254 
1cd3			;	ldir 
1cd3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1cd3			;	call strcpy 
1cd3			;	ld a, 0 
1cd3			;	ld (hl), a 
1cd3			;	inc hl 
1cd3			;	ld (hl), a 
1cd3			;	inc hl 
1cd3			;	ld (hl), a 
1cd3			 
1cd3				; switch frame buffer to program  
1cd3			 
1cd3 21 4b fc				ld hl, display_fb1 
1cd6 22 07 fb				ld (display_fb_active), hl 
1cd9			 
1cd9			;	nop 
1cd9				STACKFRAME ON $fbfe $8f9f 
1cd9				if DEBUG_STACK_IMB 
1cd9					if ON 
1cd9						exx 
1cd9						ld de, $fbfe 
1cd9						ld a, d 
1cd9						ld hl, curframe 
1cd9						call hexout 
1cd9						ld a, e 
1cd9						ld hl, curframe+2 
1cd9						call hexout 
1cd9						ld hl, $fbfe 
1cd9						push hl 
1cd9						ld hl, $8f9f 
1cd9						push hl 
1cd9						exx 
1cd9					endif 
1cd9				endif 
1cd9			endm 
# End of macro STACKFRAME
1cd9				; first time into the parser so pass over the current scratch pad 
1cd9 21 23 f4			ld hl,os_cli_cmd 
1cdc				; tokenise the entered statement(s) in HL 
1cdc cd 2c 24			call forthparse 
1cdf			        ; exec forth statements in top of return stack 
1cdf cd 6c 24			call forthexec 
1ce2				;call forthexec_cleanup 
1ce2			;	call parsenext 
1ce2			 
1ce2				STACKFRAMECHK ON $fbfe $8f9f 
1ce2				if DEBUG_STACK_IMB 
1ce2					if ON 
1ce2						exx 
1ce2						ld hl, $8f9f 
1ce2						pop de   ; $8f9f 
1ce2						call cmp16 
1ce2						jr nz, .spnosame 
1ce2						ld hl, $fbfe 
1ce2						pop de   ; $fbfe 
1ce2						call cmp16 
1ce2						jr z, .spfrsame 
1ce2						.spnosame: call showsperror 
1ce2						.spfrsame: nop 
1ce2						exx 
1ce2					endif 
1ce2				endif 
1ce2			endm 
# End of macro STACKFRAMECHK
1ce2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1ce2			 
1ce2 3e 78			ld a, display_row_4 
1ce4 11 15 1d			ld de, endprog 
1ce7			 
1ce7 cd be 0d			call update_display		 
1cea			 
1cea cd 9b 1f			call next_page_prompt 
1ced			 
1ced				; switch frame buffer to cli 
1ced			 
1ced 21 ec fc				ld hl, display_fb0 
1cf0 22 07 fb				ld (display_fb_active), hl 
1cf3			 
1cf3			 
1cf3 cd 9b 0d		        call clear_display 
1cf6 cd be 0d			call update_display		 
1cf9			 
1cf9 21 23 f4			ld hl, os_cli_cmd 
1cfc			 
1cfc 3e 00			ld a, 0		 ; init cli input 
1cfe 77				ld (hl), a 
1cff			 
1cff				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1cff			 
1cff				; now on last line 
1cff			 
1cff				; TODO scroll screen up 
1cff			 
1cff				; TODO instead just clear screen and place at top of screen 
1cff			 
1cff			;	ld a, 0 
1cff			;	ld (f_cursor_ptr),a 
1cff			 
1cff				;call clear_display 
1cff				;call update_display 
1cff			 
1cff				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cff 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d01 c3 a9 1c			jp cli 
1d04			 
1d04 .. 00		freeram: db "Free bytes: ",0 
1d11 ..			asc: db "1A2F" 
1d15 .. 00		endprog: db "End prog...",0 
1d21			 
1d21			testenter2:   
1d21 21 2e f1			ld hl,scratch+50 
1d24 22 1f f4			ld (os_cur_ptr),hl 
1d27 c3 a9 1c			jp cli 
1d2a			 
1d2a			testenter:  
1d2a			 
1d2a 21 11 1d			ld hl,asc 
1d2d			;	ld a,(hl) 
1d2d			;	call nibble2val 
1d2d cd 2e 12			call get_byte 
1d30			 
1d30			 
1d30			;	ld a,(hl) 
1d30			;	call atohex 
1d30			 
1d30			;	call fourehexhl 
1d30 32 2e f1			ld (scratch+50),a 
1d33			 
1d33			 
1d33			 
1d33 21 13 1d			ld hl,asc+2 
1d36			;	ld a, (hl) 
1d36			;	call nibble2val 
1d36 cd 2e 12			call get_byte 
1d39			 
1d39			;	call fourehexhl 
1d39 32 30 f1			ld (scratch+52),a 
1d3c				 
1d3c 21 2e f1			ld hl,scratch+50 
1d3f 22 1f f4			ld (os_cur_ptr),hl 
1d42 c3 a9 1c			jp cli 
1d45			 
1d45			enter:	 
1d45 3a 00 f1			ld a,(scratch+4) 
1d48 fe 00			cp 0 
1d4a 28 0c			jr z, .entercont 
1d4c				; no, not a null term line so has an address to work out.... 
1d4c			 
1d4c 21 fe f0			ld hl,scratch+2 
1d4f cd 8e 12			call get_word_hl 
1d52			 
1d52 22 1f f4			ld (os_cur_ptr),hl	 
1d55 c3 a9 1c			jp cli 
1d58			 
1d58			 
1d58			.entercont:  
1d58			 
1d58 21 fe f0			ld hl, scratch+2 
1d5b cd 2e 12			call get_byte 
1d5e			 
1d5e 2a 1f f4		   	ld hl,(os_cur_ptr) 
1d61 77					ld (hl),a 
1d62 23					inc hl 
1d63 22 1f f4				ld (os_cur_ptr),hl 
1d66				 
1d66			; get byte  
1d66			 
1d66			 
1d66 c3 a9 1c			jp cli 
1d69			 
1d69			 
1d69			; basic monitor support 
1d69			 
1d69			monitor: 
1d69				;  
1d69 cd 9b 0d			call clear_display 
1d6c 3e 00			ld a, 0 
1d6e 11 bd 1d			ld de, .monprompt 
1d71 cd ae 0d			call str_at_display 
1d74 cd be 0d			call update_display 
1d77			 
1d77				; get a monitor command 
1d77			 
1d77 0e 00			ld c, 0     ; entry at top left 
1d79 16 64			ld d, 100   ; max buffer size 
1d7b 1e 0f			ld e, 15    ; input scroll area 
1d7d 3e 00			ld a, 0     ; init string 
1d7f 21 fa f2			ld hl, os_input 
1d82 77				ld (hl), a 
1d83 23				inc hl 
1d84 77				ld (hl), a 
1d85 21 fa f2			ld hl, os_input 
1d88 3e 01			ld a, 1     ; init string 
1d8a cd fc 0f			call input_str 
1d8d			 
1d8d cd 9b 0d		        call clear_display 
1d90 cd be 0d			call update_display		 
1d93			 
1d93 3a fa f2			ld a, (os_input) 
1d96 cd 2c 13			call toUpper 
1d99 fe 48		        cp 'H' 
1d9b ca 22 1e		        jp z, .monhelp 
1d9e fe 44			cp 'D'		; dump 
1da0 ca 55 1e			jp z, .mondump	 
1da3 fe 43			cp 'C'		; dump 
1da5 ca 6f 1e			jp z, .moncdump	 
1da8 fe 4d			cp 'M'		; dump 
1daa ca bf 1d			jp z, .moneditstart 
1dad fe 55			cp 'U'		; dump 
1daf ca cb 1d			jp z, .monedit	 
1db2 fe 47			cp 'G'		; dump 
1db4 ca 4b 1e			jp z, .monjump 
1db7 fe 51			cp 'Q'		; dump 
1db9 c8				ret z	 
1dba			 
1dba			 
1dba				; TODO "S" to access symbol by name and not need the address 
1dba				; TODO "F" to find a string in memory 
1dba			 
1dba c3 69 1d			jp monitor 
1dbd			 
1dbd .. 00		.monprompt: db ">", 0 
1dbf			 
1dbf			.moneditstart: 
1dbf				; get starting address 
1dbf			 
1dbf 21 fc f2			ld hl,os_input+2 
1dc2 cd 8e 12			call get_word_hl 
1dc5			 
1dc5 22 1f f4			ld (os_cur_ptr),hl	 
1dc8			 
1dc8 c3 69 1d			jp monitor 
1dcb			 
1dcb			.monedit: 
1dcb				; get byte to load 
1dcb			 
1dcb 21 fc f2			ld hl,os_input+2 
1dce cd 2e 12			call get_byte 
1dd1			 
1dd1				; get address to update 
1dd1 2a 1f f4			ld hl, (os_cur_ptr) 
1dd4			 
1dd4				; update byte 
1dd4			 
1dd4 77				ld (hl), a 
1dd5			 
1dd5				; move to next address and save it 
1dd5			 
1dd5 23				inc hl 
1dd6 22 1f f4			ld (os_cur_ptr),hl	 
1dd9			 
1dd9 c3 69 1d			jp monitor 
1ddc			 
1ddc			 
1ddc .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1df0 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e0c .. 00		.monhelptext3:  db "G-Call address",0 
1e1b .. 00		.monhelptext4:  db "Q-Quit",0 
1e22			        
1e22			.monhelp: 
1e22 3e 00			ld a, display_row_1 
1e24 11 dc 1d		        ld de, .monhelptext1 
1e27			 
1e27 cd ae 0d			call str_at_display 
1e2a 3e 28			ld a, display_row_2 
1e2c 11 f0 1d		        ld de, .monhelptext2 
1e2f					 
1e2f cd ae 0d			call str_at_display 
1e32 3e 50			ld a, display_row_3 
1e34 11 0c 1e		        ld de, .monhelptext3 
1e37					 
1e37 cd ae 0d			call str_at_display 
1e3a 3e 78			ld a, display_row_4 
1e3c 11 1b 1e		        ld de, .monhelptext4 
1e3f cd ae 0d			call str_at_display 
1e42			 
1e42 cd be 0d			call update_display		 
1e45			 
1e45 cd 9b 1f			call next_page_prompt 
1e48 c3 69 1d			jp monitor 
1e4b			 
1e4b			.monjump:    
1e4b 21 fc f2			ld hl,os_input+2 
1e4e cd 8e 12			call get_word_hl 
1e51			 
1e51 e9				jp (hl) 
1e52 c3 69 1d			jp monitor 
1e55			 
1e55			.mondump:    
1e55 21 fc f2			ld hl,os_input+2 
1e58 cd 8e 12			call get_word_hl 
1e5b			 
1e5b 22 1f f4			ld (os_cur_ptr),hl	 
1e5e cd a3 1e			call dumpcont 
1e61 3e 78			ld a, display_row_4 
1e63 11 15 1d			ld de, endprog 
1e66			 
1e66 cd be 0d			call update_display		 
1e69			 
1e69 cd 9b 1f			call next_page_prompt 
1e6c c3 69 1d			jp monitor 
1e6f			.moncdump: 
1e6f cd a3 1e			call dumpcont 
1e72 3e 78			ld a, display_row_4 
1e74 11 15 1d			ld de, endprog 
1e77			 
1e77 cd be 0d			call update_display		 
1e7a			 
1e7a cd 9b 1f			call next_page_prompt 
1e7d c3 69 1d			jp monitor 
1e80			 
1e80			 
1e80			; TODO symbol access  
1e80			 
1e80			.symbols:     ;; A list of symbols that can be called up  
1e80 ec fc			dw display_fb0 
1e82 .. 00			db "fb0",0  
1e86 b5 f9		     	dw store_page 
1e88 .. 00			db "store_page",0 
1e93			 
1e93			 
1e93			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e93			 
1e93 3a fd f0			ld a,(scratch+1) 
1e96 fe 00			cp 0 
1e98 28 09			jr z, dumpcont 
1e9a			 
1e9a				; no, not a null term line so has an address to work out.... 
1e9a			 
1e9a 21 fe f0			ld hl,scratch+2 
1e9d cd 8e 12			call get_word_hl 
1ea0			 
1ea0 22 1f f4			ld (os_cur_ptr),hl	 
1ea3			 
1ea3			 
1ea3			 
1ea3			dumpcont: 
1ea3			 
1ea3				; dump bytes at ptr 
1ea3			 
1ea3			 
1ea3 3e 00			ld a, display_row_1 
1ea5 2a 07 fb			ld hl, (display_fb_active) 
1ea8 cd cf 0f			call addatohl 
1eab cd d3 1e			call .dumpbyterow 
1eae			 
1eae 3e 28			ld a, display_row_2 
1eb0 2a 07 fb			ld hl, (display_fb_active) 
1eb3 cd cf 0f			call addatohl 
1eb6 cd d3 1e			call .dumpbyterow 
1eb9			 
1eb9			 
1eb9 3e 50			ld a, display_row_3 
1ebb 2a 07 fb			ld hl, (display_fb_active) 
1ebe cd cf 0f			call addatohl 
1ec1 cd d3 1e			call .dumpbyterow 
1ec4			 
1ec4 3e 78			ld a, display_row_4 
1ec6 2a 07 fb			ld hl, (display_fb_active) 
1ec9 cd cf 0f			call addatohl 
1ecc cd d3 1e			call .dumpbyterow 
1ecf			 
1ecf cd be 0d			call update_display 
1ed2			;		jp cli 
1ed2 c9				ret 
1ed3			 
1ed3			.dumpbyterow: 
1ed3			 
1ed3				;push af 
1ed3			 
1ed3 e5				push hl 
1ed4			 
1ed4				; calc where to poke the ascii 
1ed4			if display_cols == 20 
1ed4				ld a, 16 
1ed4			else 
1ed4 3e 1f			ld a, 31 
1ed6			endif 
1ed6			 
1ed6 cd cf 0f			call addatohl 
1ed9 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
1edc			 
1edc			 
1edc			; display decoding address 
1edc 2a 1f f4		   	ld hl,(os_cur_ptr) 
1edf			 
1edf 7c				ld a,h 
1ee0 e1				pop hl 
1ee1 e5				push hl 
1ee2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ee2 cd d8 11			call hexout 
1ee5 2a 1f f4		   	ld hl,(os_cur_ptr) 
1ee8			 
1ee8 7d				ld a,l 
1ee9 e1				pop hl 
1eea 23				inc hl 
1eeb 23				inc hl 
1eec e5				push hl 
1eed			;	ld hl, os_word_scratch+2 
1eed cd d8 11			call hexout 
1ef0 e1				pop hl 
1ef1 23				inc hl 
1ef2 23				inc hl 
1ef3				;ld hl, os_word_scratch+4 
1ef3 3e 3a			ld a, ':' 
1ef5 77				ld (hl),a 
1ef6 23				inc hl 
1ef7				;ld a, 0 
1ef7				;ld (hl),a 
1ef7				;ld de, os_word_scratch 
1ef7				;pop af 
1ef7				;push af 
1ef7			;		ld a, display_row_2 
1ef7			;		call str_at_display 
1ef7			;		call update_display 
1ef7			 
1ef7			 
1ef7			;pop af 
1ef7			;	add 5 
1ef7			 
1ef7			if display_cols == 20 
1ef7				ld b, 4 
1ef7			else 
1ef7 06 08			ld b, 8 
1ef9			endif	 
1ef9			 
1ef9			.dumpbyte: 
1ef9 c5				push bc 
1efa e5				push hl 
1efb			 
1efb			 
1efb 2a 1f f4		   	ld hl,(os_cur_ptr) 
1efe 7e					ld a,(hl) 
1eff			 
1eff					; poke the ascii to display 
1eff 2a 01 f4				ld hl,(os_word_scratch) 
1f02 77					ld (hl),a 
1f03 23					inc hl 
1f04 22 01 f4				ld (os_word_scratch),hl 
1f07			 
1f07					 
1f07			 
1f07			 
1f07 e1					pop hl 
1f08 e5					push hl 
1f09			 
1f09 cd d8 11				call hexout 
1f0c			 
1f0c					 
1f0c 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f0f 23				inc hl 
1f10 22 1f f4		   	ld (os_cur_ptr),hl 
1f13			 
1f13 e1					pop hl 
1f14 23					inc hl 
1f15 23					inc hl 
1f16 23					inc hl 
1f17			 
1f17			 
1f17			 
1f17					;ld a,0 
1f17					;ld (os_word_scratch+2),a 
1f17					;pop af 
1f17					;push af 
1f17			 
1f17					;ld de, os_word_scratch 
1f17					;call str_at_display 
1f17			;		call update_display 
1f17			;		pop af 
1f17 c1					pop bc 
1f18 c6 03				add 3 
1f1a 10 dd			djnz .dumpbyte 
1f1c			 
1f1c				 
1f1c			 
1f1c c9				ret 
1f1d			 
1f1d			jump:	 
1f1d			 
1f1d 21 fe f0			ld hl,scratch+2 
1f20 cd 8e 12			call get_word_hl 
1f23				;ld hl,(scratch+2) 
1f23				;call fourehexhl 
1f23			 
1f23 22 1f f4			ld (os_cur_ptr),hl	 
1f26			 
1f26 e9				jp (hl) 
1f27			 
1f27			 
1f27			 
1f27			; TODO implement a basic monitor mode to start with 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			 
1f27			; testing and demo code during development 
1f27			 
1f27			 
1f27 .. 00		str1: db "Enter some text...",0 
1f3a .. 00		clear: db "                    ",0 
1f4f			 
1f4f			demo: 
1f4f			 
1f4f			 
1f4f			 
1f4f			;	call update_display 
1f4f			 
1f4f				; init scratch input area for testing 
1f4f 21 fc f0			ld hl, scratch	 
1f52 3e 00			ld a,0 
1f54 77				ld (hl),a 
1f55			 
1f55			 
1f55 3e 28		            LD   A, display_row_2 
1f57			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f57 11 27 1f		            LD   DE, str1 
1f5a cd ae 0d			call str_at_display 
1f5d			 
1f5d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f5d			cloop:	 
1f5d 3e 50		            LD   A, display_row_3 
1f5f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f5f 11 3a 1f		            LD   DE, clear 
1f62			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f62 cd ae 0d				call str_at_display 
1f65 3e 78			ld a, display_row_4 
1f67 11 97 1f			ld de, prompt 
1f6a			 
1f6a cd ae 0d				call str_at_display 
1f6d cd be 0d			call update_display 
1f70			 
1f70 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f72 16 0a			ld d, 10 
1f74 21 fc f0			ld hl, scratch	 
1f77 cd fc 0f			call input_str 
1f7a			 
1f7a			;	call clear_display 
1f7a			;'	call update_display 
1f7a			 
1f7a 3e 00		            LD   A, display_row_1 
1f7c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7c 11 3a 1f		            LD   DE, clear 
1f7f cd ae 0d				call str_at_display 
1f82			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f82 3e 00		            LD   A, display_row_1 
1f84			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f84 11 fc f0		            LD   DE, scratch 
1f87			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f87 cd ae 0d				call str_at_display 
1f8a cd be 0d			call update_display 
1f8d			 
1f8d 3e 00				ld a,0 
1f8f 21 fc f0			ld hl, scratch 
1f92 77				ld (hl),a 
1f93			 
1f93 00				nop 
1f94 c3 5d 1f			jp cloop 
1f97			 
1f97			 
1f97			 
1f97			; OS Prompt 
1f97			 
1f97 .. 00		prompt: db ">",0 
1f99 .. 00		endprg: db "?",0 
1f9b			 
1f9b			 
1f9b			; handy next page prompt 
1f9b			next_page_prompt: 
1f9b e5				push hl 
1f9c d5				push de 
1f9d f5				push af 
1f9e c5				push bc 
1f9f			 
1f9f 3e 9f			ld a,display_row_4 + display_cols - 1 
1fa1 11 99 1f		        ld de, endprg 
1fa4 cd ae 0d			call str_at_display 
1fa7 cd be 0d			call update_display 
1faa cd 9e 72			call cin_wait 
1fad c1				pop bc 
1fae f1				pop af 
1faf d1				pop de 
1fb0 e1				pop hl 
1fb1			 
1fb1			 
1fb1 c9				ret 
1fb2			 
1fb2			 
1fb2			; forth parser 
1fb2			 
1fb2			; My forth kernel 
1fb2			include "forth_kernel.asm" 
1fb2			; 
1fb2			; kernel to the forth OS 
1fb2			 
1fb2			DS_TYPE_STR: equ 1     ; string type 
1fb2			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fb2			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fb2			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fb2			 
1fb2			FORTH_PARSEV1: equ 0 
1fb2			FORTH_PARSEV2: equ 0 
1fb2			FORTH_PARSEV3: equ 0 
1fb2			FORTH_PARSEV4: equ 0 
1fb2			FORTH_PARSEV5: equ 1 
1fb2			 
1fb2			;if FORTH_PARSEV5 
1fb2			;	FORTH_END_BUFFER: equ 0 
1fb2			;else 
1fb2			FORTH_END_BUFFER: equ 127 
1fb2			;endif 
1fb2			 
1fb2			FORTH_TRUE: equ 1 
1fb2			FORTH_FALSE: equ 0 
1fb2			 
1fb2			if FORTH_PARSEV4 
1fb2			include "forth_stackops.asm" 
1fb2			endif 
1fb2			 
1fb2			if FORTH_PARSEV5 
1fb2			include "forth_stackopsv5.asm" 
1fb2			 
1fb2			; Stack operations for v5 parser on wards 
1fb2			; * DATA stack 
1fb2			; * LOOP stack 
1fb2			; * RETURN stack 
1fb2			 
1fb2			 
1fb2			 
1fb2			FORTH_CHK_DSP_UNDER: macro 
1fb2				push hl 
1fb2				push de 
1fb2				ld hl,(cli_data_sp) 
1fb2				ld de, cli_data_stack 
1fb2				call cmp16 
1fb2				jp c, fault_dsp_under 
1fb2				pop de 
1fb2				pop hl 
1fb2				endm 
1fb2			 
1fb2			 
1fb2			FORTH_CHK_RSP_UNDER: macro 
1fb2				push hl 
1fb2				push de 
1fb2				ld hl,(cli_ret_sp) 
1fb2				ld de, cli_ret_stack 
1fb2				call cmp16 
1fb2				jp c, fault_rsp_under 
1fb2				pop de 
1fb2				pop hl 
1fb2				endm 
1fb2			 
1fb2			FORTH_CHK_LOOP_UNDER: macro 
1fb2				push hl 
1fb2				push de 
1fb2				ld hl,(cli_loop_sp) 
1fb2				ld de, cli_loop_stack 
1fb2				call cmp16 
1fb2				jp c, fault_loop_under 
1fb2				pop de 
1fb2				pop hl 
1fb2				endm 
1fb2			 
1fb2			FORTH_ERR_TOS_NOTSTR: macro 
1fb2				; TOSO might need more for checks when used 
1fb2				push af 
1fb2				ld a,(hl) 
1fb2				cp DS_TYPE_STR 
1fb2				jp nz, type_faultn   
1fb2				pop af 
1fb2				endm 
1fb2			 
1fb2			FORTH_ERR_TOS_NOTNUM: macro 
1fb2				push af 
1fb2				ld a,(hl) 
1fb2				cp DS_TYPE_INUM 
1fb2				jp nz, type_faultn   
1fb2				pop af 
1fb2				endm 
1fb2			 
1fb2			 
1fb2			; increase data stack pointer and save hl to it 
1fb2				 
1fb2			FORTH_DSP_NEXT: macro 
1fb2				call macro_forth_dsp_next 
1fb2				endm 
1fb2			 
1fb2			 
1fb2			macro_forth_dsp_next: 
1fb2				if DEBUG_FORTH_STACK_GUARD 
1fb2 cd 4b 6b				call check_stacks 
1fb5				endif 
1fb5 e5				push hl 
1fb6 d5				push de 
1fb7 eb				ex de,hl 
1fb8 2a 29 f9			ld hl,(cli_data_sp) 
1fbb 23				inc hl 
1fbc 23				inc hl 
1fbd			 
1fbd			; PARSEV5 
1fbd 23				inc hl 
1fbe 22 29 f9			ld (cli_data_sp),hl 
1fc1 73				ld (hl), e 
1fc2 23				inc hl 
1fc3 72				ld (hl), d 
1fc4 d1				pop de 
1fc5 e1				pop hl 
1fc6				if DEBUG_FORTH_STACK_GUARD 
1fc6 cd 4b 6b				call check_stacks 
1fc9				endif 
1fc9 c9				ret 
1fca			 
1fca			 
1fca			; increase ret stack pointer and save hl to it 
1fca				 
1fca			FORTH_RSP_NEXT: macro 
1fca				call macro_forth_rsp_next 
1fca				endm 
1fca			 
1fca			macro_forth_rsp_next: 
1fca				if DEBUG_FORTH_STACK_GUARD 
1fca cd 4b 6b				call check_stacks 
1fcd				endif 
1fcd e5				push hl 
1fce d5				push de 
1fcf eb				ex de,hl 
1fd0 2a 2d f9			ld hl,(cli_ret_sp) 
1fd3 23				inc hl 
1fd4 23				inc hl 
1fd5 22 2d f9			ld (cli_ret_sp),hl 
1fd8 73				ld (hl), e 
1fd9 23				inc hl 
1fda 72				ld (hl), d 
1fdb d1				pop de 
1fdc e1				pop hl 
1fdd				if DEBUG_FORTH_STACK_GUARD 
1fdd cd 4b 6b				call check_stacks 
1fe0				endif 
1fe0 c9				ret 
1fe1			 
1fe1			; get current ret stack pointer and save to hl  
1fe1				 
1fe1			FORTH_RSP_TOS: macro 
1fe1				call macro_forth_rsp_tos 
1fe1				endm 
1fe1			 
1fe1			macro_forth_rsp_tos: 
1fe1				;push de 
1fe1 2a 2d f9			ld hl,(cli_ret_sp) 
1fe4 cd 1c 20			call loadhlptrtohl 
1fe7				;ld e, (hl) 
1fe7				;inc hl 
1fe7				;ld d, (hl) 
1fe7				;ex de, hl 
1fe7					if DEBUG_FORTH_WORDS 
1fe7			;			DMARK "RST" 
1fe7						CALLMONITOR 
1fe7 cd aa fd			call debug_vector  
1fea				endm  
# End of macro CALLMONITOR
1fea					endif 
1fea				;pop de 
1fea c9				ret 
1feb			 
1feb			; pop ret stack pointer 
1feb				 
1feb			FORTH_RSP_POP: macro 
1feb				call macro_forth_rsp_pop 
1feb				endm 
1feb			 
1feb			 
1feb			macro_forth_rsp_pop: 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb			;		DMARK "RPP" 
1feb cd 4b 6b				call check_stacks 
1fee					FORTH_CHK_RSP_UNDER 
1fee e5				push hl 
1fef d5				push de 
1ff0 2a 2d f9			ld hl,(cli_ret_sp) 
1ff3 11 e7 f8			ld de, cli_ret_stack 
1ff6 cd ed 0f			call cmp16 
1ff9 da 5f 6c			jp c, fault_rsp_under 
1ffc d1				pop de 
1ffd e1				pop hl 
1ffe				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ffe				endif 
1ffe e5				push hl 
1fff 2a 2d f9			ld hl,(cli_ret_sp) 
2002			 
2002			 
2002				if FORTH_ENABLE_FREE 
2002			 
2002					; get pointer 
2002			 
2002					push de 
2002					push hl 
2002			 
2002					ld e, (hl) 
2002					inc hl 
2002					ld d, (hl) 
2002			 
2002					ex de, hl 
2002					call free 
2002			 
2002					pop hl 
2002					pop de 
2002			 
2002			 
2002				endif 
2002			 
2002			 
2002 2b				dec hl 
2003 2b				dec hl 
2004 22 2d f9			ld (cli_ret_sp), hl 
2007				; do stack underflow checks 
2007 e1				pop hl 
2008				if DEBUG_FORTH_STACK_GUARD 
2008 cd 4b 6b				call check_stacks 
200b					FORTH_CHK_RSP_UNDER 
200b e5				push hl 
200c d5				push de 
200d 2a 2d f9			ld hl,(cli_ret_sp) 
2010 11 e7 f8			ld de, cli_ret_stack 
2013 cd ed 0f			call cmp16 
2016 da 5f 6c			jp c, fault_rsp_under 
2019 d1				pop de 
201a e1				pop hl 
201b				endm 
# End of macro FORTH_CHK_RSP_UNDER
201b				endif 
201b c9				ret 
201c			 
201c			 
201c			 
201c			; routine to load word pointed to by hl into hl 
201c			 
201c			loadhlptrtohl: 
201c			 
201c d5				push de 
201d 5e				ld e, (hl) 
201e 23				inc hl 
201f 56				ld d, (hl) 
2020 eb				ex de, hl 
2021 d1				pop de 
2022			 
2022 c9				ret 
2023			 
2023			 
2023			 
2023			 
2023			 
2023			; push a number held in HL onto the data stack 
2023			; entry point for pushing a value when already in hl used in function above 
2023			 
2023			forth_push_numhl: 
2023			 
2023 e5				push hl    ; save value to push 
2024			 
2024			if DEBUG_FORTH_PUSH 
2024				; see if disabled 
2024			 
2024			 
2024 f5				push af 
2025 3a aa fd			ld a,(debug_vector) 
2028 fe c9			cp $c9   ; ret 
202a			;	ld a, (os_view_disable) 
202a			;	cp '*' 
202a 28 34			jr z, .pskip2 
202c e5				push hl 
202d e5			push hl 
202e cd 9b 0d			call clear_display 
2031 e1			pop hl 
2032 7c				ld a,h 
2033 21 01 f4			ld hl, os_word_scratch 
2036 cd d8 11			call hexout 
2039 e1				pop hl 
203a 7d				ld a,l 
203b 21 03 f4			ld hl, os_word_scratch+2 
203e cd d8 11			call hexout 
2041			 
2041 21 05 f4			ld hl, os_word_scratch+4 
2044 3e 00			ld a,0 
2046 77				ld (hl),a 
2047 11 01 f4			ld de,os_word_scratch 
204a 3e 28				ld a, display_row_2 
204c cd ae 0d				call str_at_display 
204f 11 59 5d			ld de, .push_num 
2052 3e 00			ld a, display_row_1 
2054			 
2054 cd ae 0d				call str_at_display 
2057			 
2057			 
2057 cd be 0d			call update_display 
205a cd de 0c			call delay1s 
205d cd de 0c			call delay1s 
2060			.pskip2:  
2060			 
2060 f1				pop af 
2061			endif	 
2061			 
2061			 
2061				FORTH_DSP_NEXT 
2061 cd b2 1f			call macro_forth_dsp_next 
2064				endm 
# End of macro FORTH_DSP_NEXT
2064			 
2064 2a 29 f9			ld hl, (cli_data_sp) 
2067			 
2067				; save item type 
2067 3e 02			ld a,  DS_TYPE_INUM 
2069 77				ld (hl), a 
206a 23				inc hl 
206b			 
206b				; get word off stack 
206b d1				pop de 
206c 7b				ld a,e 
206d 77				ld (hl), a 
206e 23				inc hl 
206f 7a				ld a,d 
2070 77				ld (hl), a 
2071			 
2071			if DEBUG_FORTH_PUSH 
2071 2b				dec hl 
2072 2b				dec hl 
2073 2b				dec hl 
2074						DMARK "PH5" 
2074 f5				push af  
2075 3a 89 20			ld a, (.dmark)  
2078 32 a6 fd			ld (debug_mark),a  
207b 3a 8a 20			ld a, (.dmark+1)  
207e 32 a7 fd			ld (debug_mark+1),a  
2081 3a 8b 20			ld a, (.dmark+2)  
2084 32 a8 fd			ld (debug_mark+2),a  
2087 18 03			jr .pastdmark  
2089 ..			.dmark: db "PH5"  
208c f1			.pastdmark: pop af  
208d			endm  
# End of macro DMARK
208d				CALLMONITOR 
208d cd aa fd			call debug_vector  
2090				endm  
# End of macro CALLMONITOR
2090			endif	 
2090			 
2090 c9				ret 
2091			 
2091			 
2091			; Push a string to stack pointed to by hl 
2091			 
2091			forth_push_str: 
2091			 
2091			if DEBUG_FORTH_PUSH 
2091						DMARK "PSQ" 
2091 f5				push af  
2092 3a a6 20			ld a, (.dmark)  
2095 32 a6 fd			ld (debug_mark),a  
2098 3a a7 20			ld a, (.dmark+1)  
209b 32 a7 fd			ld (debug_mark+1),a  
209e 3a a8 20			ld a, (.dmark+2)  
20a1 32 a8 fd			ld (debug_mark+2),a  
20a4 18 03			jr .pastdmark  
20a6 ..			.dmark: db "PSQ"  
20a9 f1			.pastdmark: pop af  
20aa			endm  
# End of macro DMARK
20aa				CALLMONITOR 
20aa cd aa fd			call debug_vector  
20ad				endm  
# End of macro CALLMONITOR
20ad			endif	 
20ad			 
20ad			 
20ad			    
20ad e5				push hl 
20ae e5				push hl 
20af			 
20af			;	ld a, 0   ; find end of string 
20af cd 35 13			call strlenz 
20b2			if DEBUG_FORTH_PUSH 
20b2						DMARK "PQ2" 
20b2 f5				push af  
20b3 3a c7 20			ld a, (.dmark)  
20b6 32 a6 fd			ld (debug_mark),a  
20b9 3a c8 20			ld a, (.dmark+1)  
20bc 32 a7 fd			ld (debug_mark+1),a  
20bf 3a c9 20			ld a, (.dmark+2)  
20c2 32 a8 fd			ld (debug_mark+2),a  
20c5 18 03			jr .pastdmark  
20c7 ..			.dmark: db "PQ2"  
20ca f1			.pastdmark: pop af  
20cb			endm  
# End of macro DMARK
20cb				CALLMONITOR 
20cb cd aa fd			call debug_vector  
20ce				endm  
# End of macro CALLMONITOR
20ce			endif	 
20ce eb				ex de, hl 
20cf e1				pop hl   ; get ptr to start of string 
20d0			if DEBUG_FORTH_PUSH 
20d0						DMARK "PQ3" 
20d0 f5				push af  
20d1 3a e5 20			ld a, (.dmark)  
20d4 32 a6 fd			ld (debug_mark),a  
20d7 3a e6 20			ld a, (.dmark+1)  
20da 32 a7 fd			ld (debug_mark+1),a  
20dd 3a e7 20			ld a, (.dmark+2)  
20e0 32 a8 fd			ld (debug_mark+2),a  
20e3 18 03			jr .pastdmark  
20e5 ..			.dmark: db "PQ3"  
20e8 f1			.pastdmark: pop af  
20e9			endm  
# End of macro DMARK
20e9				CALLMONITOR 
20e9 cd aa fd			call debug_vector  
20ec				endm  
# End of macro CALLMONITOR
20ec			endif	 
20ec 19				add hl,de 
20ed			if DEBUG_FORTH_PUSH 
20ed						DMARK "PQE" 
20ed f5				push af  
20ee 3a 02 21			ld a, (.dmark)  
20f1 32 a6 fd			ld (debug_mark),a  
20f4 3a 03 21			ld a, (.dmark+1)  
20f7 32 a7 fd			ld (debug_mark+1),a  
20fa 3a 04 21			ld a, (.dmark+2)  
20fd 32 a8 fd			ld (debug_mark+2),a  
2100 18 03			jr .pastdmark  
2102 ..			.dmark: db "PQE"  
2105 f1			.pastdmark: pop af  
2106			endm  
# End of macro DMARK
2106				CALLMONITOR 
2106 cd aa fd			call debug_vector  
2109				endm  
# End of macro CALLMONITOR
2109			endif	 
2109			 
2109 2b				dec hl    ; see if there is an optional trailing double quote 
210a 7e				ld a,(hl) 
210b fe 22			cp '"' 
210d 20 03			jr nz, .strnoq 
210f 3e 00			ld a, 0      ; get rid of double quote 
2111 77				ld (hl), a 
2112 23			.strnoq: inc hl 
2113			 
2113 3e 00			ld a, 0 
2115 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2116			 
2116 13				inc de ; add one for the type string 
2117 13				inc de ; add one for null term??? 
2118			 
2118				; tos is get string pointer again 
2118				; de contains space to allocate 
2118				 
2118 d5				push de 
2119			 
2119 eb				ex de, hl 
211a			 
211a				;push af 
211a			 
211a			if DEBUG_FORTH_PUSH 
211a						DMARK "PHm" 
211a f5				push af  
211b 3a 2f 21			ld a, (.dmark)  
211e 32 a6 fd			ld (debug_mark),a  
2121 3a 30 21			ld a, (.dmark+1)  
2124 32 a7 fd			ld (debug_mark+1),a  
2127 3a 31 21			ld a, (.dmark+2)  
212a 32 a8 fd			ld (debug_mark+2),a  
212d 18 03			jr .pastdmark  
212f ..			.dmark: db "PHm"  
2132 f1			.pastdmark: pop af  
2133			endm  
# End of macro DMARK
2133				CALLMONITOR 
2133 cd aa fd			call debug_vector  
2136				endm  
# End of macro CALLMONITOR
2136			endif	 
2136 cd aa 13			call malloc	; on ret hl now contains allocated memory 
2139				if DEBUG_FORTH_MALLOC_GUARD 
2139 cc b1 5d				call z,malloc_error 
213c				endif 
213c			 
213c				 
213c c1				pop bc    ; get length 
213d d1				pop de   ;  get string start    
213e			 
213e				; hl has destination from malloc 
213e			 
213e eb				ex de, hl    ; prep for ldir 
213f			 
213f d5				push de   ; save malloc area for DSP later 
2140				;push hl   ; save malloc area for DSP later 
2140			 
2140			if DEBUG_FORTH_PUSH 
2140						DMARK "PHc" 
2140 f5				push af  
2141 3a 55 21			ld a, (.dmark)  
2144 32 a6 fd			ld (debug_mark),a  
2147 3a 56 21			ld a, (.dmark+1)  
214a 32 a7 fd			ld (debug_mark+1),a  
214d 3a 57 21			ld a, (.dmark+2)  
2150 32 a8 fd			ld (debug_mark+2),a  
2153 18 03			jr .pastdmark  
2155 ..			.dmark: db "PHc"  
2158 f1			.pastdmark: pop af  
2159			endm  
# End of macro DMARK
2159				CALLMONITOR 
2159 cd aa fd			call debug_vector  
215c				endm  
# End of macro CALLMONITOR
215c			endif	 
215c			 
215c			 
215c ed b0			ldir 
215e			 
215e			 
215e				; push malloc to data stack     macro?????  
215e			 
215e				FORTH_DSP_NEXT 
215e cd b2 1f			call macro_forth_dsp_next 
2161				endm 
# End of macro FORTH_DSP_NEXT
2161			 
2161				; save value and type 
2161			 
2161 2a 29 f9			ld hl, (cli_data_sp) 
2164			 
2164				; save item type 
2164 3e 01			ld a,  DS_TYPE_STR 
2166 77				ld (hl), a 
2167 23				inc hl 
2168			 
2168				; get malloc word off stack 
2168 d1				pop de 
2169 73				ld (hl), e 
216a 23				inc hl 
216b 72				ld (hl), d 
216c			 
216c			 
216c			 
216c			if DEBUG_FORTH_PUSH 
216c 2a 29 f9			ld hl, (cli_data_sp) 
216f						DMARK "PHS" 
216f f5				push af  
2170 3a 84 21			ld a, (.dmark)  
2173 32 a6 fd			ld (debug_mark),a  
2176 3a 85 21			ld a, (.dmark+1)  
2179 32 a7 fd			ld (debug_mark+1),a  
217c 3a 86 21			ld a, (.dmark+2)  
217f 32 a8 fd			ld (debug_mark+2),a  
2182 18 03			jr .pastdmark  
2184 ..			.dmark: db "PHS"  
2187 f1			.pastdmark: pop af  
2188			endm  
# End of macro DMARK
2188				CALLMONITOR 
2188 cd aa fd			call debug_vector  
218b				endm  
# End of macro CALLMONITOR
218b			;	ex de,hl 
218b			endif	 
218b				; in case of spaces, skip the ptr past the copied string 
218b				;pop af 
218b				;ld (cli_origptr),hl 
218b			 
218b c9				ret 
218c			 
218c			 
218c			 
218c			; TODO ascii push input onto stack given hl to start of input 
218c			 
218c			; identify type 
218c			; if starts with a " then a string 
218c			; otherwise it is a number 
218c			;  
218c			; if a string 
218c			;     scan for ending " to get length of string to malloc for + 1 
218c			;     malloc 
218c			;     put pointer to string on stack first byte flags as string 
218c			; 
218c			; else a number 
218c			;    look for number format identifier 
218c			;    $xx hex 
218c			;    %xxxxx bin 
218c			;    xxxxx decimal 
218c			;    convert number to 16bit word.  
218c			;    malloc word + 1 with flag to identiy as num 
218c			;    put pointer to number on stack 
218c			;   
218c			;  
218c			  
218c			forth_apush: 
218c				; kernel push 
218c			 
218c			if DEBUG_FORTH_PUSH 
218c						DMARK "PSH" 
218c f5				push af  
218d 3a a1 21			ld a, (.dmark)  
2190 32 a6 fd			ld (debug_mark),a  
2193 3a a2 21			ld a, (.dmark+1)  
2196 32 a7 fd			ld (debug_mark+1),a  
2199 3a a3 21			ld a, (.dmark+2)  
219c 32 a8 fd			ld (debug_mark+2),a  
219f 18 03			jr .pastdmark  
21a1 ..			.dmark: db "PSH"  
21a4 f1			.pastdmark: pop af  
21a5			endm  
# End of macro DMARK
21a5				CALLMONITOR 
21a5 cd aa fd			call debug_vector  
21a8				endm  
# End of macro CALLMONITOR
21a8			endif	 
21a8				; identify input type 
21a8			 
21a8 7e				ld a,(hl) 
21a9			 
21a9 fe 23			cp '#' 
21ab ca e5 21			jp z, .fapdec 
21ae			 
21ae			 
21ae fe 22			cp '"' 
21b0 28 0a			jr z, .fapstr 
21b2 fe 24			cp '$' 
21b4 ca dc 21			jp z, .faphex 
21b7 fe 25			cp '%' 
21b9 ca c4 21			jp z, .fapbin 
21bc			;	cp 'b' 
21bc			;	jp z, .fabin 
21bc				; else decimal 
21bc			 
21bc				; TODO do decimal conversion 
21bc				; decimal is stored as a 16bit word 
21bc			 
21bc				; by default everything is a string if type is not detected 
21bc			.fapstr: ; 
21bc fe 22			cp '"' 
21be 20 01			jr nz, .strnoqu 
21c0 23				inc hl 
21c1			.strnoqu: 
21c1 c3 91 20			jp forth_push_str 
21c4			 
21c4			 
21c4			 
21c4			.fapbin:    ; push a binary string.  
21c4 11 00 00			ld de, 0   ; hold a 16bit value 
21c7			 
21c7 23			.fapbinshift:	inc hl  
21c8 7e				ld a,(hl) 
21c9 fe 00			cp 0     ; done scanning  
21cb 28 0b			jr z, .fapbdone  	; got it in HL so push  
21cd			 
21cd				; left shift de 
21cd eb				ex de, hl	 
21ce 29				add hl, hl 
21cf			 
21cf				; is 1 
21cf fe 31			cp '1' 
21d1 20 02			jr nz, .binzero 
21d3 cb 4d			bit 1, l 
21d5			.binzero: 
21d5 eb				ex de, hl	 ; save current de 
21d6 18 ef			jr .fapbinshift 
21d8			 
21d8			.fapbdone: 
21d8 eb				ex de, hl 
21d9 c3 23 20			jp forth_push_numhl 
21dc			 
21dc			 
21dc			.faphex:   ; hex is always stored as a 16bit word 
21dc				; skip number prefix 
21dc 23				inc hl 
21dd				; turn ascii into number 
21dd cd 8e 12			call get_word_hl	; ret 16bit word in hl 
21e0			 
21e0 c3 23 20			jp forth_push_numhl 
21e3			 
21e3 00				 nop 
21e4			 
21e4			.fabin:   ; TODO bin conversion 
21e4			 
21e4			 
21e4 c9				ret 
21e5			.fapdec:	 
21e5				; string to dec conversion 
21e5 23				inc hl 
21e6 eb				ex de, hl 
21e7 cd cc 12			call string_to_uint16 
21ea c3 23 20			jp forth_push_numhl 
21ed c9				ret 
21ee				 
21ee			;atoui_16: 
21ee			 
21ee			; get either a string ptr or a 16bit word from the data stack 
21ee			 
21ee			FORTH_DSP: macro 
21ee				call macro_forth_dsp 
21ee				endm 
21ee			 
21ee			macro_forth_dsp: 
21ee				; data stack pointer points to current word on tos 
21ee			 
21ee 2a 29 f9			ld hl,(cli_data_sp) 
21f1			 
21f1				if DEBUG_FORTH_PUSH 
21f1						DMARK "DSP" 
21f1 f5				push af  
21f2 3a 06 22			ld a, (.dmark)  
21f5 32 a6 fd			ld (debug_mark),a  
21f8 3a 07 22			ld a, (.dmark+1)  
21fb 32 a7 fd			ld (debug_mark+1),a  
21fe 3a 08 22			ld a, (.dmark+2)  
2201 32 a8 fd			ld (debug_mark+2),a  
2204 18 03			jr .pastdmark  
2206 ..			.dmark: db "DSP"  
2209 f1			.pastdmark: pop af  
220a			endm  
# End of macro DMARK
220a			 
220a cd e4 5d				call display_data_sp 
220d				;call break_point_state 
220d				;rst 030h 
220d				CALLMONITOR 
220d cd aa fd			call debug_vector  
2210				endm  
# End of macro CALLMONITOR
2210				endif 
2210			 
2210 c9				ret 
2211			 
2211			; return hl to start of value on stack 
2211			 
2211			FORTH_DSP_VALUE: macro 
2211				call macro_forth_dsp_value 
2211				endm 
2211			 
2211			macro_forth_dsp_value: 
2211			 
2211				FORTH_DSP 
2211 cd ee 21			call macro_forth_dsp 
2214				endm 
# End of macro FORTH_DSP
2214			 
2214 d5				push de 
2215			 
2215 23				inc hl ; skip type 
2216			 
2216 5e				ld e, (hl) 
2217 23				inc hl 
2218 56				ld d, (hl) 
2219 eb				ex de,hl  
221a			 
221a d1				pop de 
221b			 
221b c9				ret 
221c			 
221c			; return hl to start of value to second item on stack 
221c			 
221c			FORTH_DSP_VALUEM1: macro 
221c				call macro_forth_dsp_value_m1 
221c				endm 
221c			 
221c			macro_forth_dsp_value_m1: 
221c			 
221c				FORTH_DSP 
221c cd ee 21			call macro_forth_dsp 
221f				endm 
# End of macro FORTH_DSP
221f			 
221f 2b				dec hl 
2220 2b				dec hl 
2221			;	dec hl 
2221			 
2221 d5				push de 
2222			 
2222 5e				ld e, (hl) 
2223 23				inc hl 
2224 56				ld d, (hl) 
2225 eb				ex de,hl  
2226			 
2226 d1				pop de 
2227			 
2227 c9				ret 
2228			 
2228				 
2228			 
2228			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2228			 
2228			FORTH_DSP_POP: macro 
2228				call macro_forth_dsp_pop 
2228				endm 
2228			 
2228			 
2228			; get the tos data type 
2228			 
2228			FORTH_DSP_TYPE:   macro 
2228			 
2228				;FORTH_DSP_VALUE 
2228				FORTH_DSP 
2228				 
2228				; hl points to value 
2228				; check type 
2228			 
2228				ld a,(hl) 
2228			 
2228				endm 
2228			 
2228			; load the tos value into hl 
2228			 
2228			 
2228			FORTH_DSP_VALUEHL:  macro 
2228				call macro_dsp_valuehl 
2228				endm 
2228			 
2228			 
2228			 
2228			macro_dsp_valuehl: 
2228				FORTH_DSP_VALUE 
2228 cd 11 22			call macro_forth_dsp_value 
222b				endm 
# End of macro FORTH_DSP_VALUE
222b			 
222b				;FORTH_ERR_TOS_NOTNUM 
222b			 
222b				;inc hl   ; skip type id 
222b			 
222b			;	push de 
222b			; 
222b			;	ld e, (hl) 
222b			;	inc hl 
222b			;	ld d, (hl) 
222b			;	ex de,hl  
222b			 
222b			;	pop de 
222b			 
222b				if DEBUG_FORTH_PUSH 
222b						DMARK "DVL" 
222b f5				push af  
222c 3a 40 22			ld a, (.dmark)  
222f 32 a6 fd			ld (debug_mark),a  
2232 3a 41 22			ld a, (.dmark+1)  
2235 32 a7 fd			ld (debug_mark+1),a  
2238 3a 42 22			ld a, (.dmark+2)  
223b 32 a8 fd			ld (debug_mark+2),a  
223e 18 03			jr .pastdmark  
2240 ..			.dmark: db "DVL"  
2243 f1			.pastdmark: pop af  
2244			endm  
# End of macro DMARK
2244				CALLMONITOR 
2244 cd aa fd			call debug_vector  
2247				endm  
# End of macro CALLMONITOR
2247				endif 
2247 c9				ret 
2248			 
2248			forth_apushstrhl:      
2248				; push of string requires use of cli_origptr 
2248				; bodge use 
2248			 
2248				; get current cli_origptr, save, update with temp pointer  
2248 ed 5b 79 f9		ld de, (cli_origptr) 
224c 22 79 f9			ld (cli_origptr), hl 
224f d5				push de 
2250 cd 8c 21			call forth_apush 
2253 d1				pop de 
2254 ed 53 79 f9		ld (cli_origptr), de 
2258 c9			        ret	 
2259			 
2259			 
2259			; increase loop stack pointer and save hl to it 
2259				 
2259			FORTH_LOOP_NEXT: macro 
2259				call macro_forth_loop_next 
2259				;nop 
2259				endm 
2259			 
2259			macro_forth_loop_next: 
2259				if DEBUG_FORTH_STACK_GUARD 
2259 cd 4b 6b				call check_stacks 
225c				endif 
225c e5				push hl 
225d d5				push de 
225e eb				ex de,hl 
225f 2a 2b f9			ld hl,(cli_loop_sp) 
2262 23				inc hl 
2263 23				inc hl 
2264					if DEBUG_FORTH_WORDS 
2264						DMARK "LNX" 
2264 f5				push af  
2265 3a 79 22			ld a, (.dmark)  
2268 32 a6 fd			ld (debug_mark),a  
226b 3a 7a 22			ld a, (.dmark+1)  
226e 32 a7 fd			ld (debug_mark+1),a  
2271 3a 7b 22			ld a, (.dmark+2)  
2274 32 a8 fd			ld (debug_mark+2),a  
2277 18 03			jr .pastdmark  
2279 ..			.dmark: db "LNX"  
227c f1			.pastdmark: pop af  
227d			endm  
# End of macro DMARK
227d						CALLMONITOR 
227d cd aa fd			call debug_vector  
2280				endm  
# End of macro CALLMONITOR
2280					endif 
2280 22 2b f9			ld (cli_loop_sp),hl 
2283 73				ld (hl), e 
2284 23				inc hl 
2285 72				ld (hl), d 
2286 d1				pop de    ; been reversed so save a swap on restore 
2287 e1				pop hl 
2288				if DEBUG_FORTH_STACK_GUARD 
2288 cd 4b 6b				call check_stacks 
228b				endif 
228b c9				ret 
228c			 
228c			; get current ret stack pointer and save to hl  
228c				 
228c			FORTH_LOOP_TOS: macro 
228c				call macro_forth_loop_tos 
228c				endm 
228c			 
228c			macro_forth_loop_tos: 
228c d5				push de 
228d 2a 2b f9			ld hl,(cli_loop_sp) 
2290 5e				ld e, (hl) 
2291 23				inc hl 
2292 56				ld d, (hl) 
2293 eb				ex de, hl 
2294 d1				pop de 
2295 c9				ret 
2296			 
2296			; pop loop stack pointer 
2296				 
2296			FORTH_LOOP_POP: macro 
2296				call macro_forth_loop_pop 
2296				endm 
2296			 
2296			 
2296			macro_forth_loop_pop: 
2296				if DEBUG_FORTH_STACK_GUARD 
2296					DMARK "LPP" 
2296 f5				push af  
2297 3a ab 22			ld a, (.dmark)  
229a 32 a6 fd			ld (debug_mark),a  
229d 3a ac 22			ld a, (.dmark+1)  
22a0 32 a7 fd			ld (debug_mark+1),a  
22a3 3a ad 22			ld a, (.dmark+2)  
22a6 32 a8 fd			ld (debug_mark+2),a  
22a9 18 03			jr .pastdmark  
22ab ..			.dmark: db "LPP"  
22ae f1			.pastdmark: pop af  
22af			endm  
# End of macro DMARK
22af cd 4b 6b				call check_stacks 
22b2					FORTH_CHK_LOOP_UNDER 
22b2 e5				push hl 
22b3 d5				push de 
22b4 2a 2b f9			ld hl,(cli_loop_sp) 
22b7 11 65 f8			ld de, cli_loop_stack 
22ba cd ed 0f			call cmp16 
22bd da 65 6c			jp c, fault_loop_under 
22c0 d1				pop de 
22c1 e1				pop hl 
22c2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22c2				endif 
22c2 e5				push hl 
22c3 2a 2b f9			ld hl,(cli_loop_sp) 
22c6 2b				dec hl 
22c7 2b				dec hl 
22c8 22 2b f9			ld (cli_loop_sp), hl 
22cb				; TODO do stack underflow checks 
22cb e1				pop hl 
22cc				if DEBUG_FORTH_STACK_GUARD 
22cc cd 4b 6b				call check_stacks 
22cf					FORTH_CHK_LOOP_UNDER 
22cf e5				push hl 
22d0 d5				push de 
22d1 2a 2b f9			ld hl,(cli_loop_sp) 
22d4 11 65 f8			ld de, cli_loop_stack 
22d7 cd ed 0f			call cmp16 
22da da 65 6c			jp c, fault_loop_under 
22dd d1				pop de 
22de e1				pop hl 
22df				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22df				endif 
22df c9				ret 
22e0			 
22e0			macro_forth_dsp_pop: 
22e0			 
22e0 e5				push hl 
22e1			 
22e1				; release malloc data 
22e1			 
22e1				if DEBUG_FORTH_STACK_GUARD 
22e1 cd 4b 6b				call check_stacks 
22e4					FORTH_CHK_DSP_UNDER 
22e4 e5				push hl 
22e5 d5				push de 
22e6 2a 29 f9			ld hl,(cli_data_sp) 
22e9 11 63 f6			ld de, cli_data_stack 
22ec cd ed 0f			call cmp16 
22ef da 59 6c			jp c, fault_dsp_under 
22f2 d1				pop de 
22f3 e1				pop hl 
22f4				endm 
# End of macro FORTH_CHK_DSP_UNDER
22f4				endif 
22f4				;ld hl,(cli_data_sp) 
22f4			if DEBUG_FORTH_DOT 
22f4				DMARK "DPP" 
22f4 f5				push af  
22f5 3a 09 23			ld a, (.dmark)  
22f8 32 a6 fd			ld (debug_mark),a  
22fb 3a 0a 23			ld a, (.dmark+1)  
22fe 32 a7 fd			ld (debug_mark+1),a  
2301 3a 0b 23			ld a, (.dmark+2)  
2304 32 a8 fd			ld (debug_mark+2),a  
2307 18 03			jr .pastdmark  
2309 ..			.dmark: db "DPP"  
230c f1			.pastdmark: pop af  
230d			endm  
# End of macro DMARK
230d				CALLMONITOR 
230d cd aa fd			call debug_vector  
2310				endm  
# End of macro CALLMONITOR
2310			endif	 
2310			 
2310			 
2310			if FORTH_ENABLE_DSPPOPFREE 
2310			 
2310				FORTH_DSP 
2310 cd ee 21			call macro_forth_dsp 
2313				endm 
# End of macro FORTH_DSP
2313			 
2313 7e				ld a, (hl) 
2314 fe 01			cp DS_TYPE_STR 
2316 20 23			jr nz, .skippopfree 
2318			 
2318				FORTH_DSP_VALUEHL 
2318 cd 28 22			call macro_dsp_valuehl 
231b				endm 
# End of macro FORTH_DSP_VALUEHL
231b 00				nop 
231c			if DEBUG_FORTH_DOT 
231c				DMARK "DPf" 
231c f5				push af  
231d 3a 31 23			ld a, (.dmark)  
2320 32 a6 fd			ld (debug_mark),a  
2323 3a 32 23			ld a, (.dmark+1)  
2326 32 a7 fd			ld (debug_mark+1),a  
2329 3a 33 23			ld a, (.dmark+2)  
232c 32 a8 fd			ld (debug_mark+2),a  
232f 18 03			jr .pastdmark  
2331 ..			.dmark: db "DPf"  
2334 f1			.pastdmark: pop af  
2335			endm  
# End of macro DMARK
2335				CALLMONITOR 
2335 cd aa fd			call debug_vector  
2338				endm  
# End of macro CALLMONITOR
2338			endif	 
2338 cd 74 14			call free 
233b			.skippopfree: 
233b				 
233b			 
233b			endif 
233b			 
233b			if DEBUG_FORTH_DOT_KEY 
233b				DMARK "DP2" 
233b				CALLMONITOR 
233b			endif	 
233b			 
233b				; move pointer down 
233b			 
233b 2a 29 f9			ld hl,(cli_data_sp) 
233e 2b				dec hl 
233f 2b				dec hl 
2340			; PARSEV5 
2340 2b				dec hl 
2341 22 29 f9			ld (cli_data_sp), hl 
2344			 
2344				if DEBUG_FORTH_STACK_GUARD 
2344 cd 4b 6b				call check_stacks 
2347					FORTH_CHK_DSP_UNDER 
2347 e5				push hl 
2348 d5				push de 
2349 2a 29 f9			ld hl,(cli_data_sp) 
234c 11 63 f6			ld de, cli_data_stack 
234f cd ed 0f			call cmp16 
2352 da 59 6c			jp c, fault_dsp_under 
2355 d1				pop de 
2356 e1				pop hl 
2357				endm 
# End of macro FORTH_CHK_DSP_UNDER
2357				endif 
2357			 
2357 e1				pop hl 
2358			 
2358 c9				ret 
2359			 
2359			getwordathl: 
2359				; hl points to an address 
2359				; load hl with the word at that address 
2359			 
2359 d5				push de 
235a			 
235a 5e				ld e, (hl) 
235b 23				inc hl 
235c 56				ld d, (hl) 
235d eb				ex de, hl 
235e			 
235e d1				pop de 
235f c9				ret 
2360			 
2360			 
2360			 
2360			 
2360			 
2360			; eof 
2360			 
# End of file forth_stackopsv5.asm
2360			endif 
2360			 
2360			loadwordinhl:	 
2360			 
2360 d5				push de 
2361			 
2361 5e				ld e, (hl) 
2362 23				inc hl 
2363 56				ld d, (hl) 
2364 eb				ex de,hl  
2365			 
2365 d1				pop de 
2366			 
2366 c9				ret 
2367			 
2367			user_word_eol:  
2367				; hl contains the pointer to where to create a linked list item from the end 
2367				; of the user dict to continue on at the system word dict 
2367				 
2367				; poke the stub of the word list linked list to repoint to rom words 
2367			 
2367				; stub format 
2367				; db   word id 
2367				; dw    link to next word 
2367			        ; db char length of token 
2367				; db string + 0 term 
2367				; db exec code....  
2367			 
2367 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2369 77				ld (hl), a		; word id 
236a 23				inc hl 
236b			 
236b 11 36 25			ld de, sysdict 
236e 73				ld (hl), e		; next word link ie system dict 
236f 23				inc hl 
2370 72				ld (hl), d		; next word link ie system dict 
2371 23				inc hl	 
2372			 
2372			;	ld (hl), sysdict		; next word link ie system dict 
2372			;	inc hl 
2372			;	inc hl 
2372			 
2372			;	inc hl 
2372			;	inc hl 
2372			 
2372 3e 02			ld a, 2			; word length is 0 
2374 77				ld (hl), a	 
2375 23				inc hl 
2376			 
2376 3e 7e			ld a, '~'			; word length is 0 
2378 77				ld (hl), a	 
2379 23				inc hl 
237a 3e 00			ld a, 0			; save empty word 
237c 77				ld (hl), a 
237d			 
237d c9				ret 
237e			 
237e				 
237e			 
237e			forthexec_cleanup: 
237e				FORTH_RSP_POP 
237e cd eb 1f			call macro_forth_rsp_pop 
2381				endm 
# End of macro FORTH_RSP_POP
2381 c9				ret 
2382			 
2382			forth_call_hl: 
2382				; taking hl 
2382 e5				push hl 
2383 c9				ret 
2384			 
2384			; this is called to reset Forth system but keep existing uwords etc 
2384			 
2384			forth_warmstart: 
2384				; setup stack over/under flow checks 
2384				if DEBUG_FORTH_STACK_GUARD 
2384 cd 31 6b				call chk_stk_init 
2387				endif 
2387			 
2387				; init stack pointers  - * these stacks go upwards *  
2387 21 e7 f8			ld hl, cli_ret_stack 
238a 22 2d f9			ld (cli_ret_sp), hl	 
238d				; set bottom of stack 
238d 3e 00			ld a,0 
238f 77				ld (hl),a 
2390 23				inc hl 
2391 77				ld (hl),a 
2392			 
2392 21 63 f6			ld hl, cli_data_stack 
2395 22 29 f9			ld (cli_data_sp), hl	 
2398				; set bottom of stack 
2398 3e 00			ld a,0 
239a 77				ld (hl),a 
239b 23				inc hl 
239c 77				ld (hl),a 
239d			 
239d 21 65 f8			ld hl, cli_loop_stack 
23a0 22 2b f9			ld (cli_loop_sp), hl	 
23a3				; set bottom of stack 
23a3 3e 00			ld a,0 
23a5 77				ld (hl),a 
23a6 23				inc hl 
23a7 77				ld (hl),a 
23a8			 
23a8				; init extent of current open file 
23a8			 
23a8 3e 00			ld a, 0 
23aa 32 a5 f9			ld (store_openext), a 
23ad			 
23ad c9				ret 
23ae			 
23ae			 
23ae			 
23ae			; Cold Start - this is called to setup the whole Forth system 
23ae			 
23ae			forth_init: 
23ae			 
23ae				; setup stack over/under flow checks 
23ae			 
23ae			;	if DEBUG_FORTH_STACK_GUARD 
23ae			;		call chk_stk_init 
23ae			;	endif 
23ae			 
23ae				; enable auto display updates (slow.....) 
23ae			 
23ae 3e 01			ld a, 1 
23b0 32 77 f9			ld (cli_autodisplay), a 
23b3			 
23b3				; if storage is in use disable long reads for now 
23b3 3e 00			ld a, 0 
23b5 32 b0 f9			ld (store_longread), a 
23b8			 
23b8			 
23b8				; show start up screen 
23b8			 
23b8 cd 9b 0d			call clear_display 
23bb			 
23bb 3e 00			ld a,0 
23bd 32 99 f9			ld (f_cursor_ptr), a 
23c0			 
23c0				; set start of word list in start of ram - for use when creating user words 
23c0			 
23c0 21 00 80			ld hl, baseram 
23c3 22 f9 f3			ld (os_last_new_uword), hl 
23c6 cd 67 23			call user_word_eol 
23c9				 
23c9			;		call display_data_sp 
23c9			;		call next_page_prompt 
23c9			 
23c9			 
23c9			 
23c9			 
23c9 c9				ret 
23ca			 
23ca .. 00		.bootforth: db " Forth Kernel Init ",0 
23de			 
23de			; TODO push to stack 
23de			 
23de			;  
23de			 
23de			if FORTH_PARSEV2 
23de			 
23de			 
23de				include "forth_parserv2.asm" 
23de			 
23de			endif 
23de			 
23de			 
23de			; parse cli version 1 
23de			 
23de			if FORTH_PARSEV1 
23de			 
23de			 
23de			 
23de			      include "forth_parserv1.asm" 
23de			endif 
23de				 
23de			if FORTH_PARSEV3 
23de			 
23de			 
23de			 
23de			      include "forth_parserv3.asm" 
23de				include "forth_wordsv3.asm" 
23de			endif 
23de			 
23de			if FORTH_PARSEV4 
23de			 
23de			 
23de			 
23de			      include "forth_parserv4.asm" 
23de				include "forth_wordsv4.asm" 
23de			endif 
23de			 
23de			if FORTH_PARSEV5 
23de			 
23de			 
23de			 
23de			      include "forth_parserv5.asm" 
23de			 
23de			 
23de			; A better parser without using malloc and string copies all over the place.  
23de			; Exec in situ should be faster 
23de			 
23de			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23de			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23de			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23de			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23de			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23de			WORD_SYS_END: equ 0   ; Opcode for all user words 
23de			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23de			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23de			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23de			 
23de			; Core word preamble macro 
23de			 
23de			CWHEAD:   macro nxtword opcode lit len opflags 
23de				db WORD_SYS_CORE+opcode             
23de				; internal op code number 
23de				dw nxtword            
23de				; link to next dict word block 
23de				db len + 1 
23de				; literal length of dict word inc zero term 
23de				db lit,0              
23de				; literal dict word 
23de			        ; TODO db opflags        
23de				endm 
23de			 
23de			 
23de			NEXTW: macro  
23de				jp macro_next 
23de				endm 
23de			 
23de			macro_next: 
23de			if DEBUG_FORTH_PARSE_KEY 
23de				DMARK "NXT" 
23de				CALLMONITOR 
23de			endif	 
23de			;	inc hl  ; skip token null term  
23de ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23e2 ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23e6 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23e9			if DEBUG_FORTH_PARSE_KEY 
23e9				DMARK "}AA" 
23e9				CALLMONITOR 
23e9			endif	 
23e9 c3 ec 24			jp execnext 
23ec				;jp exec1 
23ec			       
23ec			 
23ec			 
23ec			; Another go at the parser to compile  
23ec			 
23ec			 
23ec			; TODO rework parser to change all of the string words to byte tokens 
23ec			; TODO do a search for  
23ec			 
23ec			; TODO first run normal parser to zero term sections 
23ec			; TODO for each word do a token look up to get the op code 
23ec			; TODO need some means to flag to the exec that this is a byte code form    
23ec			 
23ec			 
23ec			forthcompile: 
23ec			 
23ec			; 
23ec			; line parse: 
23ec			;       parse raw input buffer 
23ec			;       tokenise the words 
23ec			;       malloc new copy (for looping etc) 
23ec			;       copy to malloc + current pc in line to start of string and add line term 
23ec			;       save on new rsp 
23ec			; 
23ec			 
23ec			; hl to point to the line to tokenise 
23ec			 
23ec			;	push hl 
23ec 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
23ef			 
23ef			;	ld a,0		; string term on input 
23ef			;	call strlent 
23ef			 
23ef			;	ld (os_tok_len), hl	 ; save string length 
23ef			 
23ef			;if DEBUG_FORTH_TOK 
23ef			;	ex de,hl		 
23ef			;endif 
23ef			 
23ef			;	pop hl 		; get back string pointer 
23ef			 
23ef			if DEBUG_FORTH_TOK 
23ef						DMARK "TOc" 
23ef				CALLMONITOR 
23ef			endif 
23ef 7e			.cptoken2:    ld a,(hl) 
23f0 23				inc hl 
23f1 fe 7f			cp FORTH_END_BUFFER 
23f3 28 29			jr z, .cptokendone2 
23f5 fe 00			cp 0 
23f7 28 25			jr z, .cptokendone2 
23f9 fe 22			cp '"' 
23fb 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
23fd fe 20			cp ' ' 
23ff 20 ee			jr nz,  .cptoken2 
2401			 
2401			; TODO consume comments held between ( and ) 
2401			 
2401				; we have a space so change to zero term for dict match later 
2401 2b				dec hl 
2402 3e 00			ld a,0 
2404 77				ld (hl), a 
2405 23				inc hl 
2406 18 e7			jr .cptoken2 
2408				 
2408			 
2408			.cptokenstr2: 
2408				; skip all white space until either eol (because forgot to term) or end double quote 
2408			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2408				;inc hl ; skip current double quote 
2408 7e				ld a,(hl) 
2409 23				inc hl 
240a fe 22			cp '"' 
240c 28 e1			jr z, .cptoken2 
240e fe 7f			cp FORTH_END_BUFFER 
2410 28 0c			jr z, .cptokendone2 
2412 fe 00			cp 0 
2414 28 08			jr z, .cptokendone2 
2416 fe 20			cp ' ' 
2418 28 02			jr z, .cptmp2 
241a 18 ec			jr .cptokenstr2 
241c			 
241c			.cptmp2:	; we have a space so change to zero term for dict match later 
241c				;dec hl 
241c				;ld a,"-"	; TODO remove this when working 
241c				;ld (hl), a 
241c				;inc hl 
241c 18 ea			jr .cptokenstr2 
241e			 
241e			.cptokendone2: 
241e				;inc hl 
241e 3e 7f			ld a, FORTH_END_BUFFER 
2420 77				ld (hl),a 
2421 23				inc hl 
2422 3e 21			ld a, '!' 
2424 77				ld (hl),a 
2425			 
2425 2a fd f3			ld hl,(os_tok_ptr) 
2428			         
2428			if DEBUG_FORTH_TOK 
2428						DMARK "Tc1" 
2428				CALLMONITOR 
2428			endif 
2428			 
2428				; push exec string to top of return stack 
2428				FORTH_RSP_NEXT 
2428 cd ca 1f			call macro_forth_rsp_next 
242b				endm 
# End of macro FORTH_RSP_NEXT
242b c9				ret 
242c			 
242c			; Another go at the parser need to simplify the process 
242c			 
242c			forthparse: 
242c			 
242c			; 
242c			; line parse: 
242c			;       parse raw input buffer 
242c			;       tokenise the words 
242c			;       malloc new copy (for looping etc) 
242c			;       copy to malloc + current pc in line to start of string and add line term 
242c			;       save on new rsp 
242c			; 
242c			 
242c			; hl to point to the line to tokenise 
242c			 
242c			;	push hl 
242c 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
242f			 
242f			;	ld a,0		; string term on input 
242f			;	call strlent 
242f			 
242f			;	ld (os_tok_len), hl	 ; save string length 
242f			 
242f			;if DEBUG_FORTH_TOK 
242f			;	ex de,hl		 
242f			;endif 
242f			 
242f			;	pop hl 		; get back string pointer 
242f			 
242f			if DEBUG_FORTH_TOK 
242f						DMARK "TOK" 
242f				CALLMONITOR 
242f			endif 
242f 7e			.ptoken2:    ld a,(hl) 
2430 23				inc hl 
2431 fe 7f			cp FORTH_END_BUFFER 
2433 28 29			jr z, .ptokendone2 
2435 fe 00			cp 0 
2437 28 25			jr z, .ptokendone2 
2439 fe 22			cp '"' 
243b 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
243d fe 20			cp ' ' 
243f 20 ee			jr nz,  .ptoken2 
2441			 
2441			; TODO consume comments held between ( and ) 
2441			 
2441				; we have a space so change to zero term for dict match later 
2441 2b				dec hl 
2442 3e 00			ld a,0 
2444 77				ld (hl), a 
2445 23				inc hl 
2446 18 e7			jr .ptoken2 
2448				 
2448			 
2448			.ptokenstr2: 
2448				; skip all white space until either eol (because forgot to term) or end double quote 
2448			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2448				;inc hl ; skip current double quote 
2448 7e				ld a,(hl) 
2449 23				inc hl 
244a fe 22			cp '"' 
244c 28 e1			jr z, .ptoken2 
244e fe 7f			cp FORTH_END_BUFFER 
2450 28 0c			jr z, .ptokendone2 
2452 fe 00			cp 0 
2454 28 08			jr z, .ptokendone2 
2456 fe 20			cp ' ' 
2458 28 02			jr z, .ptmp2 
245a 18 ec			jr .ptokenstr2 
245c			 
245c			.ptmp2:	; we have a space so change to zero term for dict match later 
245c				;dec hl 
245c				;ld a,"-"	; TODO remove this when working 
245c				;ld (hl), a 
245c				;inc hl 
245c 18 ea			jr .ptokenstr2 
245e			 
245e			.ptokendone2: 
245e				;inc hl 
245e 3e 7f			ld a, FORTH_END_BUFFER 
2460 77				ld (hl),a 
2461 23				inc hl 
2462 3e 21			ld a, '!' 
2464 77				ld (hl),a 
2465			 
2465 2a fd f3			ld hl,(os_tok_ptr) 
2468			         
2468			if DEBUG_FORTH_TOK 
2468						DMARK "TK1" 
2468				CALLMONITOR 
2468			endif 
2468			 
2468				; push exec string to top of return stack 
2468				FORTH_RSP_NEXT 
2468 cd ca 1f			call macro_forth_rsp_next 
246b				endm 
# End of macro FORTH_RSP_NEXT
246b c9				ret 
246c			 
246c			; 
246c			;	; malloc size + buffer pointer + if is loop flag 
246c			;	ld hl,(os_tok_len) 		 ; get string length 
246c			; 
246c			;	ld a,l 
246c			; 
246c			;	cp 0			; we dont want to use a null string 
246c			;	ret z 
246c			; 
246c			;;	add 3    ; prefix malloc with buffer for current word ptr 
246c			; 
246c			;	add 5     ; TODO when certain not over writing memory remove 
246c			; 
246c			;		 
246c			; 
246c			;if DEBUG_FORTH_TOK 
246c			;			DMARK "TKE" 
246c			;	CALLMONITOR 
246c			;endif 
246c			; 
246c			;	ld l,a 
246c			;	ld h,0 
246c			;;	push hl   ; save required space for the copy later 
246c			;	call malloc 
246c			;if DEBUG_FORTH_TOK 
246c			;			DMARK "TKM" 
246c			;	CALLMONITOR 
246c			;endif 
246c			;	if DEBUG_FORTH_MALLOC_GUARD 
246c			;		push af 
246c			;		call ishlzero 
246c			;;		ld a, l 
246c			;;		add h 
246c			;;		cp 0 
246c			;		pop af 
246c			;		 
246c			;		call z,malloc_error 
246c			;	endif 
246c			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
246c			; 
246c			; 
246c			;if DEBUG_FORTH_TOK 
246c			;			DMARK "TKR" 
246c			;	CALLMONITOR 
246c			;endif 
246c			; 
246c			;	FORTH_RSP_NEXT 
246c			; 
246c			;	;inc hl	 ; go past current buffer pointer 
246c			;	;inc hl 
246c			;	;inc hl   ; and past if loop flag 
246c			;		; TODO Need to set flag  
246c			; 
246c			;	 
246c			;	 
246c			;	ex de,hl	; malloc is dest 
246c			;	ld hl, (os_tok_len) 
246c			;;	pop bc 
246c			;	ld c, l                
246c			;	ld b,0 
246c			;	ld hl, (os_tok_ptr) 
246c			; 
246c			;if DEBUG_FORTH_TOK 
246c			;			DMARK "TKT" 
246c			;	CALLMONITOR 
246c			;endif 
246c			; 
246c			;	; do str cpy 
246c			; 
246c			;	ldir      ; copy byte in hl to de 
246c			; 
246c			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
246c			; 
246c			;if DEBUG_FORTH_TOK 
246c			; 
246c			;			DMARK "TKY" 
246c			;	CALLMONITOR 
246c			;endif 
246c			;	;ld a,0 
246c			;	;ld a,FORTH_END_BUFFER 
246c			;	ex de, hl 
246c			;	;dec hl			 ; go back over the space delim at the end of word 
246c			;	;ld (hl),a 
246c			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
246c			;	ld a,FORTH_END_BUFFER 
246c			;	ld (hl),a 
246c			;	inc hl 
246c			;	ld a,FORTH_END_BUFFER 
246c			;	ld (hl),a 
246c			; 
246c			;	; init the malloc area data 
246c			;	; set pc for in current area 
246c			;	;ld hl, (os_tok_malloc) 
246c			;	;inc hl 
246c			;	;inc hl 
246c			;	;inc hl 
246c			;	;ex de,hl 
246c			;	;ld hl, (os_tok_malloc) 
246c			;	;ld (hl),e 
246c			;	;inc hl 
246c			;	;ld (hl),d 
246c			; 
246c			; 
246c			;	ld hl,(os_tok_malloc) 
246c			;if DEBUG_FORTH_PARSE_KEY 
246c			;			DMARK "TKU" 
246c			;	CALLMONITOR 
246c			;endif 
246c			; 
246c			;	ret 
246c			 
246c			forthexec: 
246c			 
246c			; line exec: 
246c			; forth parser 
246c			 
246c			; 
246c			;       get current exec line on rsp 
246c			 
246c				FORTH_RSP_TOS 
246c cd e1 1f			call macro_forth_rsp_tos 
246f				endm 
# End of macro FORTH_RSP_TOS
246f			 
246f			;       restore current pc - hl points to malloc of data 
246f			 
246f				;ld e, (hl) 
246f				;inc hl 
246f				;ld d, (hl) 
246f				;ex de,hl 
246f			 
246f			 
246f			exec1: 
246f 22 fd f3			ld (os_tok_ptr), hl 
2472			 
2472				; copy our PC to working vars  
2472 22 7b f9			ld (cli_ptr), hl 
2475 22 79 f9			ld (cli_origptr), hl 
2478			 
2478 7e				ld a,(hl) 
2479 fe 7f			cp FORTH_END_BUFFER 
247b c8				ret z 
247c			 
247c				; skip any nulls 
247c			 
247c fe 00			cp 0 
247e 20 03			jr nz, .execword 
2480 23				inc hl 
2481 18 ec			jr exec1 
2483			 
2483			 
2483			.execword: 
2483			 
2483			 
2483			 
2483			if DEBUG_FORTH_PARSE_KEY 
2483						DMARK "KYQ" 
2483				CALLMONITOR 
2483			endif 
2483			;       while at start of word: 
2483			; get start of dict (in user area first) 
2483			 
2483 21 00 80		ld hl, baseram 
2486			;ld hl, sysdict 
2486 22 7d f9		ld (cli_nextword),hl 
2489			;           match word at pc 
2489			;           exec word 
2489			;           or push to dsp 
2489			;           forward to next token 
2489			;           if line term pop rsp and exit 
2489			;        
2489			 
2489			if DEBUG_FORTH_PARSE_KEY 
2489						DMARK "KYq" 
2489				CALLMONITOR 
2489			endif 
2489			 
2489			; 
2489			; word comp 
2489			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2489			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2489			;    move to start of word  
2489			;    compare word to cli_token 
2489			 
2489			.execpnword:	; HL at start of a word in the dictionary to check 
2489			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2489			;	ld (cli_ptr), hl 
2489			 
2489 2a 7d f9			ld hl,(cli_nextword) 
248c			 
248c cd 2f 25			call forth_tok_next 
248f			; tok next start here 
248f			;	; TODO skip compiled symbol for now 
248f			;	inc hl 
248f			; 
248f			;	; save pointer to next word 
248f			; 
248f			;	; hl now points to the address of the next word pointer  
248f			;	ld e, (hl) 
248f			;	inc hl 
248f			;	ld d, (hl) 
248f			;	inc l 
248f			; 
248f			;	ex de,hl 
248f			;if DEBUG_FORTH_PARSE_NEXTWORD 
248f			;	push bc 
248f			;	ld bc, (cli_nextword) 
248f			;			DMARK "NXW" 
248f			;	CALLMONITOR 
248f			;	pop bc 
248f			;endif 
248f			; tok next end here 
248f 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2492 eb				ex de, hl 
2493			 
2493			 
2493				; save the pointer of the current token - 1 to check against 
2493				 
2493 22 81 f9			ld (cli_token), hl   
2496				; TODO maybe remove below save if no debug 
2496				; save token string ptr for any debug later 
2496 23				inc hl  
2497 22 83 f9			ld (cli_origtoken), hl 
249a 2b				dec hl 
249b				; save pointer to the start of the next dictionay word 
249b 7e				ld a,(hl)   ; get string length 
249c 47				ld b,a 
249d			.execpnwordinc:  
249d 23				inc hl 
249e 10 fd			djnz .execpnwordinc 
24a0 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
24a3			 
24a3				; now check the word token against the string being parsed 
24a3			 
24a3 2a 81 f9			ld hl,(cli_token) 
24a6 23				inc hl     ; skip string length (use zero term instead to end) 
24a7 22 81 f9			ld (cli_token), hl 
24aa			 
24aa			if DEBUG_FORTH_PARSE_KEY 
24aa						DMARK "KY2" 
24aa			endif 
24aa			if DEBUG_FORTH_PARSE_EXEC 
24aa				; see if disabled 
24aa			 
24aa			;	ld a, (os_view_disable) 
24aa			;	cp '*' 
24aa				ld a, (debug_vector) 
24aa				cp $c9   ; RET  
24aa				jr z, .skip 
24aa			 
24aa				push hl 
24aa				push hl 
24aa				call clear_display 
24aa				ld de, .compword 
24aa				ld a, display_row_1 
24aa				call str_at_display 
24aa				pop de 
24aa				ld a, display_row_2 
24aa				call str_at_display 
24aa				ld hl,(cli_ptr) 
24aa				ld a,(hl) 
24aa			        ld hl, os_word_scratch 
24aa				ld (hl),a 
24aa				ld a,0 
24aa				inc hl 
24aa				ld (hl),a 	 
24aa				ld de, os_word_scratch 
24aa				ld a, display_row_2+10 
24aa				call str_at_display 
24aa				call update_display 
24aa				ld a, 100 
24aa				call aDelayInMS 
24aa				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24aa				call delay250ms 
24aa				endif 
24aa				pop hl 
24aa			.skip:  
24aa			endif	 
24aa			.execpnchar:    ; compare char between token and string to parse 
24aa			 
24aa			if DEBUG_FORTH_PARSE_KEY 
24aa						DMARK "Ky3" 
24aa			endif 
24aa			if DEBUG_FORTH_PARSE_EXEC 
24aa				; see if disabled 
24aa			 
24aa			;	ld a, (os_view_disable) 
24aa			;	cp '*' 
24aa				ld a, (debug_vector) 
24aa				cp $C9  ; RET 
24aa				jr z, .skip2 
24aa			 
24aa			;	call clear_display 
24aa			ld hl,(cli_token) 
24aa			ld a,(hl) 
24aa			ld (os_word_scratch),a 
24aa				ld hl,(cli_ptr) 
24aa			ld a,(hl) 
24aa				ld (os_word_scratch+1),a 
24aa				ld a,0 
24aa				ld (os_word_scratch+2),a 
24aa				ld de,os_word_scratch 
24aa				ld a,display_row_4 
24aa				call str_at_display 
24aa				call update_display 
24aa			.skip2:  
24aa			endif 
24aa 2a 81 f9			ld hl,(cli_token) 
24ad 7e				ld a, (hl)	 ; char in word token 
24ae 23				inc hl 		; move to next char 
24af 22 81 f9			ld (cli_token), hl ; and save it 
24b2 47				ld b,a 
24b3			 
24b3 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
24b6 7e				ld a,(hl) 
24b7 23				inc hl 
24b8 22 7b f9			ld (cli_ptr), hl		; move to next char 
24bb cd 2c 13			call toUpper 		; make sure the input string matches case 
24be			 
24be			if DEBUG_FORTH_PARSE 
24be			endif 
24be			 
24be				; input stream end of token is a space so get rid of it 
24be			 
24be			;	cp ' ' 
24be			;	jr nz, .pnskipspace 
24be			; 
24be			;	ld a, 0		; make same term as word token term 
24be			; 
24be			;.pnskipspace: 
24be			 
24be			if DEBUG_FORTH_PARSE_KEY 
24be						DMARK "KY7" 
24be			endif 
24be b8				cp b 
24bf c2 d5 24			jp nz, .execpnskipword	 ; no match so move to next word 
24c2				 
24c2			;    if same 
24c2			;       scan for string terms 0 for token and 32 for input 
24c2			 
24c2				 
24c2			if DEBUG_FORTH_PARSE_KEY 
24c2						DMARK "KY8" 
24c2			endif 
24c2			 
24c2 80				add b			 
24c3 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24c5							; TODO need to make sure last word in zero term string is accounted for 
24c5 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
24c7			 
24c7			 
24c7				; at end of both strings so both are exact match 
24c7			 
24c7			;       skip ptr for next word 
24c7			 
24c7 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
24ca 23				inc hl			 ; at next char 
24cb 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
24ce 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24d1				 
24d1				 
24d1			if DEBUG_FORTH_PARSE_KEY 
24d1						DMARK "KY3" 
24d1			endif 
24d1			 
24d1			 
24d1			 
24d1			;       exec code block 
24d1			if DEBUG_FORTH_JP 
24d1				call clear_display 
24d1				call update_display 
24d1				call delay1s 
24d1				ld hl, (cli_execword)     ; save for next check if no match on this word 
24d1				ld a,h 
24d1				ld hl, os_word_scratch 
24d1				call hexout 
24d1				ld hl, (cli_execword)     ; save for next check if no match on this word 
24d1				ld a,l 
24d1				ld hl, os_word_scratch+2 
24d1				call hexout 
24d1				ld hl, os_word_scratch+4 
24d1				ld a,0 
24d1				ld (hl),a 
24d1				ld de,os_word_scratch 
24d1				call str_at_display 
24d1					ld a, display_row_2 
24d1					call str_at_display 
24d1				ld de, (cli_origtoken) 
24d1				ld a, display_row_1+10 
24d1					call str_at_display 
24d1			 
24d1				ld a,display_row_1 
24d1				ld de, .foundword 
24d1				ld a, display_row_3 
24d1				call str_at_display 
24d1				call update_display 
24d1				call delay1s 
24d1				call delay1s 
24d1				call delay1s 
24d1			endif 
24d1			 
24d1			if DEBUG_FORTH_PARSE_KEY 
24d1						DMARK "KYj" 
24d1			endif 
24d1				; TODO save the word pointer in this exec 
24d1			 
24d1 2a 7f f9			ld hl,(cli_execword) 
24d4 e9				jp (hl) 
24d5			 
24d5			 
24d5			;    if not same 
24d5			;	scan for zero term 
24d5			;	get ptr for next word 
24d5			;	goto word comp 
24d5			 
24d5			.execpnskipword:	; get pointer to next word 
24d5 2a 7d f9			ld hl,(cli_nextword) 
24d8			 
24d8 7e				ld a,(hl) 
24d9 fe 00			cp WORD_SYS_END 
24db			;	cp 0 
24db 28 09			jr z, .execendofdict			 ; at end of words 
24dd			 
24dd			if DEBUG_FORTH_PARSE_KEY 
24dd						DMARK "KY4" 
24dd			endif 
24dd			if DEBUG_FORTH_PARSE_EXEC 
24dd			 
24dd				; see if disabled 
24dd			 
24dd			;	ld a, (os_view_disable) 
24dd			;	cp '*' 
24dd				ld a,(debug_vector) 
24dd				cp $c9   ; RET 
24dd				jr z, .noskip 
24dd			 
24dd			 
24dd				ld de, .nowordfound 
24dd				ld a, display_row_3 
24dd				call str_at_display 
24dd				call update_display 
24dd				ld a, 100 
24dd				call aDelayInMS 
24dd				 
24dd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24dd					call delay250ms 
24dd				endif 
24dd			.noskip:  
24dd			 
24dd			endif	 
24dd			 
24dd 2a 79 f9			ld hl,(cli_origptr) 
24e0 22 7b f9			ld (cli_ptr),hl 
24e3			 
24e3			if DEBUG_FORTH_PARSE_KEY 
24e3						DMARK "KY5" 
24e3			endif 
24e3 c3 89 24			jp .execpnword			; else go to next word 
24e6			 
24e6			.execendofdict:  
24e6			 
24e6			if DEBUG_FORTH_PARSE_KEY 
24e6						DMARK "KYe" 
24e6			endif 
24e6			if DEBUG_FORTH_PARSE_EXEC 
24e6				; see if disabled 
24e6			 
24e6			;	ld a, (os_view_disable) 
24e6			;	cp '*' 
24e6				ld a,(debug_vector) 
24e6				cp $c9   ; ret 
24e6				jr z, .ispskip 
24e6			 
24e6				call clear_display 
24e6				call update_display 
24e6				call delay1s 
24e6				ld de, (cli_origptr) 
24e6				ld a, display_row_1 
24e6				call str_at_display 
24e6				 
24e6				ld de, .enddict 
24e6				ld a, display_row_3 
24e6				call str_at_display 
24e6				call update_display 
24e6				ld a, 100 
24e6				call aDelayInMS 
24e6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24e6				call delay1s 
24e6				call delay1s 
24e6				call delay1s 
24e6				endif 
24e6			.ispskip:  
24e6				 
24e6			endif	 
24e6			 
24e6			 
24e6			 
24e6				; if the word is not a keyword then must be a literal so push it to stack 
24e6			 
24e6			; push token to stack to end of word 
24e6			 
24e6				STACKFRAME ON $1efe $2f9f 
24e6				if DEBUG_STACK_IMB 
24e6					if ON 
24e6						exx 
24e6						ld de, $1efe 
24e6						ld a, d 
24e6						ld hl, curframe 
24e6						call hexout 
24e6						ld a, e 
24e6						ld hl, curframe+2 
24e6						call hexout 
24e6						ld hl, $1efe 
24e6						push hl 
24e6						ld hl, $2f9f 
24e6						push hl 
24e6						exx 
24e6					endif 
24e6				endif 
24e6			endm 
# End of macro STACKFRAME
24e6			 
24e6 2a fd f3		ld hl,(os_tok_ptr) 
24e9 cd 8c 21		call forth_apush 
24ec			 
24ec				STACKFRAMECHK ON $1efe $2f9f 
24ec				if DEBUG_STACK_IMB 
24ec					if ON 
24ec						exx 
24ec						ld hl, $2f9f 
24ec						pop de   ; $2f9f 
24ec						call cmp16 
24ec						jr nz, .spnosame 
24ec						ld hl, $1efe 
24ec						pop de   ; $1efe 
24ec						call cmp16 
24ec						jr z, .spfrsame 
24ec						.spnosame: call showsperror 
24ec						.spfrsame: nop 
24ec						exx 
24ec					endif 
24ec				endif 
24ec			endm 
# End of macro STACKFRAMECHK
24ec			 
24ec			execnext: 
24ec			 
24ec			if DEBUG_FORTH_PARSE_KEY 
24ec						DMARK "KY>" 
24ec			endif 
24ec			; move past token to next word 
24ec			 
24ec 2a fd f3		ld hl, (os_tok_ptr) 
24ef 3e 00		ld a, 0 
24f1 01 ff 00		ld bc, 255     ; input buffer size 
24f4 ed b1		cpir 
24f6			 
24f6			if DEBUG_FORTH_PARSE_KEY 
24f6						DMARK "KY!" 
24f6				CALLMONITOR 
24f6			endif	 
24f6			; TODO this might place hl on the null, so will need to forward on??? 
24f6			;inc hl   ; see if this gets onto the next item 
24f6			 
24f6			 
24f6			; TODO pass a pointer to the buffer to push 
24f6			; TODO call function to push 
24f6			 
24f6			; look for end of input 
24f6			 
24f6			;inc hl 
24f6			;ld a,(hl) 
24f6			;cp FORTH_END_BUFFER 
24f6			;ret z 
24f6			 
24f6			 
24f6 c3 6f 24		jp exec1 
24f9			 
24f9			 
24f9			 
24f9			 
24f9			 
24f9			 
24f9			 
24f9			 
24f9			 
24f9			findnexttok: 
24f9			 
24f9				; hl is pointer to move 
24f9				; de is the token to locate 
24f9			 
24f9					if DEBUG_FORTH 
24f9						DMARK "NTK" 
24f9						CALLMONITOR 
24f9					endif 
24f9 d5				push de 
24fa			 
24fa			.fnt1:	 
24fa				; find first char of token to locate 
24fa			 
24fa 1a				ld a, (de) 
24fb 4f				ld c,a 
24fc 7e				ld a,(hl) 
24fd cd 2c 13			call toUpper 
2500					if DEBUG_FORTH 
2500						DMARK "NT1" 
2500						CALLMONITOR 
2500					endif 
2500 b9				cp c 
2501			 
2501 28 03			jr z, .fnt2cmpmorefirst	 
2503			 
2503				; first char not found move to next char 
2503			 
2503 23				inc hl 
2504 18 f4			jr .fnt1 
2506			 
2506			.fnt2cmpmorefirst:	 
2506				; first char of token found.  
2506			 
2506 e5				push hl     ; save start of token just in case it is the right one 
2507 d9				exx 
2508 e1				pop hl        ; save it to hl' 
2509 d9				exx 
250a			 
250a			 
250a			.fnt2cmpmore:	 
250a				; compare the rest 
250a				 
250a 23				inc hl 
250b 13				inc de 
250c				 
250c 1a				ld a, (de) 
250d 4f				ld c,a 
250e 7e				ld a,(hl) 
250f cd 2c 13			call toUpper 
2512			 
2512					if DEBUG_FORTH 
2512						DMARK "NT2" 
2512						CALLMONITOR 
2512					endif 
2512				; c has the token to find char 
2512				; a has the mem to scan char 
2512			 
2512 b9				cp c 
2513 28 04			jr z,.fntmatch1 
2515			 
2515				; they are not the same 
2515			 
2515					if DEBUG_FORTH 
2515						DMARK "NT3" 
2515						CALLMONITOR 
2515					endif 
2515 d1				pop de	; reset de token to look for 
2516 d5				push de 
2517 18 e1			jr .fnt1 
2519				 
2519			.fntmatch1: 
2519			 
2519				; is the same char a null which means we might have a full hit? 
2519					if DEBUG_FORTH 
2519						DMARK "NT4" 
2519						CALLMONITOR 
2519					endif 
2519			 
2519 fe 00			cp 0 
251b 28 0b			jr z, .fntmatchyes 
251d			 
251d				; are we at the end of the token to find? 
251d			 
251d					if DEBUG_FORTH 
251d						DMARK "NT5" 
251d						CALLMONITOR 
251d					endif 
251d 3e 00			ld a, 0 
251f b9				cp c 
2520			 
2520 c2 0a 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2523			 
2523					if DEBUG_FORTH 
2523						DMARK "NT6" 
2523						CALLMONITOR 
2523					endif 
2523				; token to find is exhusted but no match to stream 
2523			 
2523				; restore tok pointer and continue on 
2523 d1				pop de 
2524 d5				push de 
2525 c3 fa 24			jp .fnt1 
2528			 
2528			 
2528			.fntmatchyes: 
2528			 
2528				; hl now contains the end of the found token 
2528			 
2528				; get rid of saved token pointer to find 
2528			 
2528 d1				pop de 
2529			 
2529					if DEBUG_FORTH 
2529						DMARK "NT9" 
2529						CALLMONITOR 
2529					endif 
2529			 
2529				; hl will be on the null term so forward on 
2529			 
2529				; get back the saved start of the token 
2529			 
2529 d9				exx 
252a e5				push hl     ; save start of token just in case it is the right one 
252b d9				exx 
252c e1				pop hl        ; save it to hl 
252d			 
252d c9				ret 
252e			 
252e			 
252e			; LIST needs to find a specific token   
252e			; FORGET needs to find a spefici token 
252e			 
252e			; SAVE needs to find all tokens by flag 
252e			; WORDS just needs to scan through all  by flag 
252e			; UWORDS needs to scan through all by flag 
252e			 
252e			 
252e			; given hl as pointer to start of dict look up string 
252e			; return hl as pointer to start of word block 
252e			; or 0 if not found 
252e			 
252e			forth_find_tok: 
252e c9				ret 
252f			 
252f			; given hl as pointer to dict structure 
252f			; move to the next dict block structure 
252f			 
252f			forth_tok_next: 
252f				; hl now points to the address of the next word pointer  
252f				; TODO skip compiled symbol for now 
252f			;	push de 
252f 23				inc hl 
2530 5e				ld e, (hl) 
2531 23				inc hl 
2532 56				ld d, (hl) 
2533 23				inc hl 
2534			 
2534 eb				ex de,hl 
2535			if DEBUG_FORTH_PARSE_NEXTWORD 
2535				push bc 
2535				ld bc, (cli_nextword) 
2535						DMARK "NXW" 
2535				CALLMONITOR 
2535				pop bc 
2535			endif 
2535			;	pop de	 
2535 c9				ret 
2536			 
2536			 
2536			 
2536			; eof 
# End of file forth_parserv5.asm
2536				include "forth_wordsv4.asm" 
2536			 
2536			; the core word dictionary v4 
2536			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2536			 
2536			; this is a linked list for each of the system words used 
2536			; user defined words will follow the same format but will be in ram 
2536			 
2536			 
2536			; 
2536			; 
2536			; define linked list: 
2536			; 
2536			; 1. compiled byte op code 
2536			; 2. len of text word 
2536			; 3. text word 
2536			; 4. ptr to next dictionary word 
2536			; 5. asm, calls etc for the word 
2536			; 
2536			;  if 1 == 0 then last word in dict  
2536			;   
2536			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2536			;  
2536			;  
2536			; create basic standard set of words 
2536			; 
2536			;  
2536			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2536			; 2DUP 2DROP 2SWAP  
2536			; @ C@ - get byte  
2536			; ! C! - store byte 
2536			; 0< true if less than zero 
2536			; 0= true if zero 
2536			; < >  
2536			; = true if same 
2536			; variables 
2536			 
2536			 
2536			; Hardware specific words I may need 
2536			; 
2536			; IN OUT  
2536			; calls to key util functions 
2536			; calls to hardward abstraction stuff 
2536			; easy control of frame buffers and lcd i/o 
2536			; keyboard  
2536			 
2536			 
2536			;DICT: macro 
2536			; op_code, len, word, next 
2536			;    word: 
2536			;    db op_code 
2536			;    ds word zero term 
2536			;    dw next 
2536			;    endm 
2536			 
2536			 
2536			 
2536			 
2536			; op code 1 is a flag for user define words which are to be handled differently 
2536			 
2536			 
2536			; 
2536			; 
2536			;    TODO on entry to a word this should be the expected environment 
2536			;    hl - tos value if number then held, if string this is the ptr 
2536			;    de -  
2536			 
2536			 
2536			; opcode ranges 
2536			; 0 - end of word dict 
2536			; 255 - user define words 
2536			 
2536			sysdict: 
2536			include "forth_opcodes.asm" 
2536			; op codes for forth keywords 
2536			; free to use code 0  
2536				OPCODE_HEAP: equ  1 
2536				OPCODE_EXEC: equ 2 
2536				OPCODE_DUP: equ 3 
2536				OPCODE_SWAP: equ 4 
2536				OPCODE_COLN: equ 5 
2536				OPCODE_SCOLN: equ 6 
2536				OPCODE_DROP: equ 7 
2536				OPCODE_DUP2: equ 8 
2536				OPCODE_DROP2: equ 9 
2536				OPCODE_SWAP2: equ 10 
2536				OPCODE_AT: equ 11 
2536				OPCODE_CAT: equ 12 
2536				OPCODE_BANG: equ 13 
2536				OPCODE_CBANG: equ 14 
2536				OPCODE_SCALL: equ 15 
2536				OPCODE_DEPTH: equ 16 
2536				OPCODE_OVER: equ 17 
2536				OPCODE_PAUSE: equ 18 
2536				OPCODE_PAUSES: equ 19 
2536				OPCODE_ROT: equ 20 
2536			;free to reuse	OPCODE_WORDS: equ 21 
2536			        OPCODE_NOT: equ 21 
2536				OPCODE_UWORDS: equ 22 
2536				OPCODE_BP: equ 23 
2536				OPCODE_MONITOR: equ 24  
2536				OPCODE_MALLOC: equ 25 
2536				OPCODE_FREE: equ 26 
2536				OPCODE_LIST: equ 27 
2536				OPCODE_FORGET: equ 28 
2536				OPCODE_NOP: equ 29 
2536				OPCODE_COMO: equ 30 
2536				OPCODE_COMC: equ 31 
2536			;free to reuse	OPCODE_ENDCORE: equ 32 
2536				OPCODE_AFTERSOUND: equ 33 
2536				OPCODE_GP2: equ 34 
2536				OPCODE_GP3: equ 35 
2536				OPCODE_GP4: equ 36 
2536				OPCODE_SIN: equ 37 
2536				OPCODE_SOUT: equ 38 
2536				OPCODE_SPIO: equ 39 
2536				OPCODE_SPICEH: equ 40 
2536				OPCODE_SPIOb: equ 41 
2536				OPCODE_SPII: equ 42 
2536				OPCODE_SESEL: equ 43 
2536				OPCODE_CARTDEV: equ 44 
2536			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2536				OPCODE_FB: equ 46 
2536				OPCODE_EMIT: equ 47 
2536				OPCODE_DOTH: equ 48 
2536				OPCODE_DOTF: equ 49 
2536				OPCODE_DOT: equ 50 
2536				OPCODE_CLS: equ 51 
2536				OPCODE_DRAW: equ 52 
2536				OPCODE_DUMP: equ 53 
2536				OPCODE_CDUMP: equ 54 
2536				OPCODE_DAT: equ 55 
2536				OPCODE_HOME: equ 56 
2536				OPCODE_SPACE: equ 57 
2536				OPCODE_SPACES: equ 58 
2536				OPCODE_SCROLL: equ 59 
2536				OPCODE_ATQ: equ 60 
2536				OPCODE_AUTODSP: equ 61 
2536				OPCODE_MENU: equ 62 
2536			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2536				OPCODE_THEN: equ 64 
2536				OPCODE_ELSE: equ 65 
2536				OPCODE_DO: equ 66 
2536				OPCODE_LOOP: equ 67 
2536				OPCODE_I: equ 68 
2536				OPCODE_DLOOP: equ 69  
2536				OPCODE_REPEAT: equ 70  
2536				OPCODE_UNTIL: equ 71 
2536				OPCODE_ENDFLOW: equ 72 
2536				OPCODE_WAITK: equ 73 
2536				OPCODE_ACCEPT: equ 74 
2536				OPCODE_EDIT: equ 75 
2536			;free to reuse	OPCODE_ENDKEY: equ 76 
2536				OPCODE_LZERO: equ 77 
2536				OPCODE_TZERO: equ 78 
2536				OPCODE_LESS: equ 79 
2536				OPCODE_GT: equ 80 
2536				OPCODE_EQUAL: equ 81  
2536			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2536				OPCODE_NEG: equ 83 
2536				OPCODE_DIV: equ 84 
2536				OPCODE_MUL: equ 85 
2536				OPCODE_MIN: equ 86 
2536				OPCODE_MAX: equ 87 
2536				OPCODE_RND16: equ 88 
2536				OPCODE_RND8: equ 89 
2536				OPCODE_RND: equ 90 
2536			;free to reuse	OPCODE_ENDMATHS: equ 91  
2536				OPCODE_BYNAME: equ 92 
2536				OPCODE_DIR: equ 93 
2536				OPCODE_SAVE: equ 94 
2536				OPCODE_LOAD: equ 95 
2536				OPCODE_BSAVE: equ 96 
2536				OPCODE_BLOAD: equ 97 
2536				OPCODE_SEO: equ 98  
2536				OPCODE_SEI: equ 99 
2536				OPCODE_SFREE: equ 100 
2536				OPCODE_SIZE: equ 101 
2536				OPCODE_CREATE: equ 102 
2536				OPCODE_APPEND: equ 103 
2536				OPCODE_SDEL: equ 104 
2536				OPCODE_OPEN: equ 105 
2536				OPCODE_READ: equ 106 
2536				OPCODE_EOF: equ 106 
2536				OPCODE_FORMAT: equ 107 
2536				OPCODE_LABEL: equ 108 
2536				OPCODE_LABELS: equ 109 
2536			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2536				OPCODE_UPPER: equ 111 
2536				OPCODE_LOWER: equ 112 
2536				OPCODE_SUBSTR: equ 113 
2536				OPCODE_LEFT: equ 114 
2536				OPCODE_RIGHT: equ 115 
2536				OPCODE_STR2NUM: equ 116 
2536				OPCODE_NUM2STR: equ 117 
2536				OPCODE_CONCAT: equ 118 
2536				OPCODE_FIND: equ 119 
2536				OPCODE_LEN: equ 120 
2536				OPCODE_CHAR: equ 121 
2536			; free to reuse	OPCODE_STRLEN: equ 122 
2536			; free to reuse	OPCODE_ENDSTR: equ 123 
2536				OPCODE_V0S: equ 124 
2536				OPCODE_V0Q: equ 125 
2536				OPCODE_V1S: equ 126 
2536				OPCODE_V1Q: equ 127 
2536				OPCODE_V2S: equ 128 
2536				OPCODE_V2Q: equ 129 
2536				OPCODE_V3S: equ 130 
2536				OPCODE_V3Q: equ 131 
2536			;free to reuse	OPCODE_END: equ 132 
2536				OPCODE_ZDUP: equ 133 
2536			 
2536			; eof 
# End of file forth_opcodes.asm
2536			 
2536			include "forth_words_core.asm" 
2536			 
2536			; | ## Core Words 
2536			 
2536			;if MALLOC_4 
2536			 
2536			.HEAP: 
2536			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2536 15				db WORD_SYS_CORE+OPCODE_HEAP             
2537 75 25			dw .EXEC            
2539 05				db 4 + 1 
253a .. 00			db "HEAP",0              
253f				endm 
# End of macro CWHEAD
253f			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
253f			; | | u1 - Current number of bytes in the heap 
253f			; | | u2 - Remaining bytes left on the heap 
253f			; | |  
253f			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
253f			 
253f			 
253f				if DEBUG_FORTH_WORDS_KEY 
253f					DMARK "HEP" 
253f f5				push af  
2540 3a 54 25			ld a, (.dmark)  
2543 32 a6 fd			ld (debug_mark),a  
2546 3a 55 25			ld a, (.dmark+1)  
2549 32 a7 fd			ld (debug_mark+1),a  
254c 3a 56 25			ld a, (.dmark+2)  
254f 32 a8 fd			ld (debug_mark+2),a  
2552 18 03			jr .pastdmark  
2554 ..			.dmark: db "HEP"  
2557 f1			.pastdmark: pop af  
2558			endm  
# End of macro DMARK
2558					CALLMONITOR 
2558 cd aa fd			call debug_vector  
255b				endm  
# End of macro CALLMONITOR
255b				endif 
255b 2a 0a 80			ld hl, (free_list )      
255e 11 0e 80			ld de, heap_start 
2561			 
2561 ed 52			sbc hl, de  
2563			 
2563 cd 23 20			call forth_push_numhl 
2566			 
2566			 
2566 ed 5b 0a 80		ld de, (free_list )      
256a 21 d7 f0			ld hl, heap_end 
256d			 
256d ed 52			sbc hl, de 
256f			 
256f cd 23 20			call forth_push_numhl 
2572				 
2572			 
2572				 
2572			 
2572			 
2572			 
2572				NEXTW 
2572 c3 de 23			jp macro_next 
2575				endm 
# End of macro NEXTW
2575			;endif 
2575			 
2575			.EXEC: 
2575			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2575			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2575			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2575			;; > > 
2575			;; > >   
2575			;	STACKFRAME OFF $5efe $5f9f 
2575			; 
2575			;		if DEBUG_FORTH_WORDS_KEY 
2575			;			DMARK "EXE" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			; 
2575			;	FORTH_DSP_VALUEHL 
2575			; 
2575			;	FORTH_DSP_POP 
2575			; 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX1" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;;	ld e,(hl) 
2575			;;	inc hl 
2575			;;	ld d,(hl) 
2575			;;	ex de,hl 
2575			; 
2575			;;		if DEBUG_FORTH_WORDS 
2575			;;			DMARK "EX2" 
2575			;;			CALLMONITOR 
2575			;;		endif 
2575			;	push hl 
2575			; 
2575			;	;ld a, 0 
2575			;	;ld a, FORTH_END_BUFFER 
2575			;	call strlenz 
2575			;	inc hl   ; include zero term to copy 
2575			;	inc hl   ; include term 
2575			;	inc hl   ; include term 
2575			;	ld b,0 
2575			;	ld c,l 
2575			;	pop hl 
2575			;	ld de, execscratch 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX3" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	ldir 
2575			; 
2575			; 
2575			;	ld hl, execscratch 
2575			; 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EXe" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			; 
2575			;	call forthparse 
2575			;	call forthexec 
2575			;;	call forthexec_cleanup 
2575			;;	call forthparse 
2575			;;	call forthexec 
2575			; 
2575			;	STACKFRAMECHK OFF $5efe $5f9f 
2575			; 
2575			;	; an immediate word so no need to process any more words 
2575			;	ret 
2575			;	NEXTW 
2575			 
2575			; dead code - old version  
2575			;	FORTH_RSP_NEXT 
2575			 
2575			;  
2575			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2575			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2575			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2575			;	push hl 
2575			;	push de 
2575			;	push bc 
2575			; 
2575			; 
2575			;		if DEBUG_FORTH_WORDS_KEY 
2575			;			DMARK "EXR" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			; 
2575			; 
2575			; 
2575			;	;v5 FORTH_DSP_VALUE 
2575			;	FORTH_DSP_VALUEHL 
2575			; 
2575			;	; TODO do string type checks 
2575			; 
2575			;;v5	inc hl   ; skip type 
2575			; 
2575			;	push hl  ; source code  
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX1" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	ld a, 0 
2575			;	call strlent 
2575			; 
2575			;	inc hl 
2575			;	inc hl 
2575			;	inc hl 
2575			;	inc hl 
2575			; 
2575			;	push hl    ; size 
2575			; 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX2" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	call malloc 
2575			; 
2575			;	ex de, hl    ; de now contains malloc area 
2575			;	pop bc   	; get byte count 
2575			;	pop hl      ; get string to copy 
2575			; 
2575			;	push de     ; save malloc for free later 
2575			; 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX3" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	ldir       ; duplicate string 
2575			; 
2575			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2575			;	 
2575			;	; TODO fix the parse would be better than this...  
2575			;	ex de, hl 
2575			;	dec hl 
2575			;	ld a, 0 
2575			;	ld (hl), a 
2575			;	dec hl 
2575			;	ld a, ' ' 
2575			;	ld (hl), a 
2575			;	dec hl 
2575			;	ld (hl), a 
2575			; 
2575			;	dec hl 
2575			;	ld (hl), a 
2575			; 
2575			; 
2575			;	FORTH_DSP_POP  
2575			; 
2575			;	pop hl     
2575			;	push hl    ; save malloc area 
2575			; 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX4" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			; 
2575			;	call forthparse 
2575			;	call forthexec 
2575			;	 
2575			;	pop hl 
2575			;	if DEBUG_FORTH_WORDS 
2575			;		DMARK "EX5" 
2575			;		CALLMONITOR 
2575			;	endif 
2575			; 
2575			;	if FORTH_ENABLE_FREE 
2575			;	call free 
2575			;	endif 
2575			; 
2575			;	if DEBUG_FORTH_WORDS 
2575			;		DMARK "EX6" 
2575			;		CALLMONITOR 
2575			;	endif 
2575			; 
2575			;	pop bc 
2575			;	pop de 
2575			;	pop hl 
2575			;;	FORTH_RSP_POP	  
2575			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2575			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2575			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2575			; 
2575			;	if DEBUG_FORTH_WORDS 
2575			;		DMARK "EX7" 
2575			;		CALLMONITOR 
2575			;	endif 
2575			;	NEXTW 
2575			 
2575			;.STKEXEC: 
2575			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2575			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2575			; 
2575			; 
2575			;		if DEBUG_FORTH_WORDS_KEY 
2575			;			DMARK "STX" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			; 
2575			;	FORTH_DSP_VALUEHL 
2575			; 
2575			;	ld (store_tmp1), hl    ; count 
2575			; 
2575			;	FORTH_DSP_POP 
2575			;.stkexec1: 
2575			;	ld hl, (store_tmp1)   ; count 
2575			;	ld a, 0 
2575			;	cp l 
2575			;	ret z 
2575			; 
2575			;	dec hl 
2575			;	ld (store_tmp1), hl    ; count 
2575			;	 
2575			;	FORTH_DSP_VALUEHL 
2575			;	push hl 
2575			;	 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EXp" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	FORTH_DSP_POP 
2575			; 
2575			;	call strlenz 
2575			;	inc hl   ; include zero term to copy 
2575			;	inc hl   ; include zero term to copy 
2575			;	inc hl   ; include zero term to copy 
2575			;	ld b,0 
2575			;	ld c,l 
2575			;	pop hl 
2575			;	ld de, execscratch 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EX3" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	ldir 
2575			; 
2575			; 
2575			;	ld hl, execscratch 
2575			; 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EXP" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			; 
2575			;	call forthparse 
2575			;	ld hl, execscratch 
2575			;		if DEBUG_FORTH_WORDS 
2575			;			DMARK "EXx" 
2575			;			CALLMONITOR 
2575			;		endif 
2575			;	call forthexec 
2575			; 
2575			;	jp .stkexec1 
2575			; 
2575			;	ret 
2575			 
2575			 
2575			.DUP: 
2575			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2575 17				db WORD_SYS_CORE+OPCODE_DUP             
2576 eb 25			dw .ZDUP            
2578 04				db 3 + 1 
2579 .. 00			db "DUP",0              
257d				endm 
# End of macro CWHEAD
257d			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
257d			 
257d				if DEBUG_FORTH_WORDS_KEY 
257d					DMARK "DUP" 
257d f5				push af  
257e 3a 92 25			ld a, (.dmark)  
2581 32 a6 fd			ld (debug_mark),a  
2584 3a 93 25			ld a, (.dmark+1)  
2587 32 a7 fd			ld (debug_mark+1),a  
258a 3a 94 25			ld a, (.dmark+2)  
258d 32 a8 fd			ld (debug_mark+2),a  
2590 18 03			jr .pastdmark  
2592 ..			.dmark: db "DUP"  
2595 f1			.pastdmark: pop af  
2596			endm  
# End of macro DMARK
2596					CALLMONITOR 
2596 cd aa fd			call debug_vector  
2599				endm  
# End of macro CALLMONITOR
2599				endif 
2599			 
2599				FORTH_DSP 
2599 cd ee 21			call macro_forth_dsp 
259c				endm 
# End of macro FORTH_DSP
259c			 
259c 7e				ld a, (HL) 
259d fe 01			cp DS_TYPE_STR 
259f 20 25			jr nz, .dupinum 
25a1			 
25a1				; push another string 
25a1			 
25a1				FORTH_DSP_VALUEHL     		 
25a1 cd 28 22			call macro_dsp_valuehl 
25a4				endm 
# End of macro FORTH_DSP_VALUEHL
25a4			 
25a4			if DEBUG_FORTH_WORDS 
25a4				DMARK "DUs" 
25a4 f5				push af  
25a5 3a b9 25			ld a, (.dmark)  
25a8 32 a6 fd			ld (debug_mark),a  
25ab 3a ba 25			ld a, (.dmark+1)  
25ae 32 a7 fd			ld (debug_mark+1),a  
25b1 3a bb 25			ld a, (.dmark+2)  
25b4 32 a8 fd			ld (debug_mark+2),a  
25b7 18 03			jr .pastdmark  
25b9 ..			.dmark: db "DUs"  
25bc f1			.pastdmark: pop af  
25bd			endm  
# End of macro DMARK
25bd				CALLMONITOR 
25bd cd aa fd			call debug_vector  
25c0				endm  
# End of macro CALLMONITOR
25c0			endif 
25c0 cd 91 20			call forth_push_str 
25c3			 
25c3				NEXTW 
25c3 c3 de 23			jp macro_next 
25c6				endm 
# End of macro NEXTW
25c6			 
25c6			 
25c6			.dupinum: 
25c6				 
25c6			 
25c6			 
25c6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c6 cd 28 22			call macro_dsp_valuehl 
25c9				endm 
# End of macro FORTH_DSP_VALUEHL
25c9			 
25c9			; TODO add floating point number detection 
25c9			 
25c9			if DEBUG_FORTH_WORDS 
25c9				DMARK "DUi" 
25c9 f5				push af  
25ca 3a de 25			ld a, (.dmark)  
25cd 32 a6 fd			ld (debug_mark),a  
25d0 3a df 25			ld a, (.dmark+1)  
25d3 32 a7 fd			ld (debug_mark+1),a  
25d6 3a e0 25			ld a, (.dmark+2)  
25d9 32 a8 fd			ld (debug_mark+2),a  
25dc 18 03			jr .pastdmark  
25de ..			.dmark: db "DUi"  
25e1 f1			.pastdmark: pop af  
25e2			endm  
# End of macro DMARK
25e2				CALLMONITOR 
25e2 cd aa fd			call debug_vector  
25e5				endm  
# End of macro CALLMONITOR
25e5			endif 
25e5			 
25e5 cd 23 20			call forth_push_numhl 
25e8				NEXTW 
25e8 c3 de 23			jp macro_next 
25eb				endm 
# End of macro NEXTW
25eb			.ZDUP: 
25eb			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25eb 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25ec 23 26			dw .SWAP            
25ee 05				db 4 + 1 
25ef .. 00			db "?DUP",0              
25f4				endm 
# End of macro CWHEAD
25f4			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
25f4			 
25f4				if DEBUG_FORTH_WORDS_KEY 
25f4					DMARK "qDU" 
25f4 f5				push af  
25f5 3a 09 26			ld a, (.dmark)  
25f8 32 a6 fd			ld (debug_mark),a  
25fb 3a 0a 26			ld a, (.dmark+1)  
25fe 32 a7 fd			ld (debug_mark+1),a  
2601 3a 0b 26			ld a, (.dmark+2)  
2604 32 a8 fd			ld (debug_mark+2),a  
2607 18 03			jr .pastdmark  
2609 ..			.dmark: db "qDU"  
260c f1			.pastdmark: pop af  
260d			endm  
# End of macro DMARK
260d					CALLMONITOR 
260d cd aa fd			call debug_vector  
2610				endm  
# End of macro CALLMONITOR
2610				endif 
2610				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2610 cd 28 22			call macro_dsp_valuehl 
2613				endm 
# End of macro FORTH_DSP_VALUEHL
2613			 
2613 e5				push hl 
2614			 
2614				; is it a zero? 
2614			 
2614 3e 00			ld a, 0 
2616 84				add h 
2617 85				add l 
2618			 
2618 e1				pop hl 
2619			 
2619 fe 00			cp 0 
261b 28 03			jr z, .dup2orig 
261d			 
261d			 
261d cd 23 20			call forth_push_numhl 
2620			 
2620			 
2620			; TODO add floating point number detection 
2620			 
2620			.dup2orig: 
2620			 
2620				NEXTW 
2620 c3 de 23			jp macro_next 
2623				endm 
# End of macro NEXTW
2623			.SWAP: 
2623			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2623 18				db WORD_SYS_CORE+OPCODE_SWAP             
2624 62 26			dw .COLN            
2626 05				db 4 + 1 
2627 .. 00			db "SWAP",0              
262c				endm 
# End of macro CWHEAD
262c			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
262c				if DEBUG_FORTH_WORDS_KEY 
262c					DMARK "SWP" 
262c f5				push af  
262d 3a 41 26			ld a, (.dmark)  
2630 32 a6 fd			ld (debug_mark),a  
2633 3a 42 26			ld a, (.dmark+1)  
2636 32 a7 fd			ld (debug_mark+1),a  
2639 3a 43 26			ld a, (.dmark+2)  
263c 32 a8 fd			ld (debug_mark+2),a  
263f 18 03			jr .pastdmark  
2641 ..			.dmark: db "SWP"  
2644 f1			.pastdmark: pop af  
2645			endm  
# End of macro DMARK
2645					CALLMONITOR 
2645 cd aa fd			call debug_vector  
2648				endm  
# End of macro CALLMONITOR
2648				endif 
2648			 
2648			; TODO Use os stack swap memory 
2648				FORTH_DSP_VALUEHL 
2648 cd 28 22			call macro_dsp_valuehl 
264b				endm 
# End of macro FORTH_DSP_VALUEHL
264b e5				push hl     ; w2 
264c			 
264c				FORTH_DSP_POP 
264c cd e0 22			call macro_forth_dsp_pop 
264f				endm 
# End of macro FORTH_DSP_POP
264f			 
264f				FORTH_DSP_VALUEHL 
264f cd 28 22			call macro_dsp_valuehl 
2652				endm 
# End of macro FORTH_DSP_VALUEHL
2652			 
2652				FORTH_DSP_POP 
2652 cd e0 22			call macro_forth_dsp_pop 
2655				endm 
# End of macro FORTH_DSP_POP
2655			 
2655 d1				pop de     ; w2	, hl = w1 
2656			 
2656 eb				ex de, hl 
2657 d5				push de 
2658			 
2658 cd 23 20			call forth_push_numhl 
265b			 
265b e1				pop hl 
265c			 
265c cd 23 20			call forth_push_numhl 
265f				 
265f			 
265f				NEXTW 
265f c3 de 23			jp macro_next 
2662				endm 
# End of macro NEXTW
2662			.COLN: 
2662			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2662 19				db WORD_SYS_CORE+OPCODE_COLN             
2663 ee 27			dw .SCOLN            
2665 02				db 1 + 1 
2666 .. 00			db ":",0              
2668				endm 
# End of macro CWHEAD
2668			; | : ( -- )         Create new word | DONE 
2668			 
2668				if DEBUG_FORTH_WORDS_KEY 
2668					DMARK "CLN" 
2668 f5				push af  
2669 3a 7d 26			ld a, (.dmark)  
266c 32 a6 fd			ld (debug_mark),a  
266f 3a 7e 26			ld a, (.dmark+1)  
2672 32 a7 fd			ld (debug_mark+1),a  
2675 3a 7f 26			ld a, (.dmark+2)  
2678 32 a8 fd			ld (debug_mark+2),a  
267b 18 03			jr .pastdmark  
267d ..			.dmark: db "CLN"  
2680 f1			.pastdmark: pop af  
2681			endm  
# End of macro DMARK
2681					CALLMONITOR 
2681 cd aa fd			call debug_vector  
2684				endm  
# End of macro CALLMONITOR
2684				endif 
2684			STACKFRAME OFF $8efe $989f 
2684				if DEBUG_STACK_IMB 
2684					if OFF 
2684						exx 
2684						ld de, $8efe 
2684						ld a, d 
2684						ld hl, curframe 
2684						call hexout 
2684						ld a, e 
2684						ld hl, curframe+2 
2684						call hexout 
2684						ld hl, $8efe 
2684						push hl 
2684						ld hl, $989f 
2684						push hl 
2684						exx 
2684					endif 
2684				endif 
2684			endm 
# End of macro STACKFRAME
2684			; get parser buffer length  of new word 
2684			 
2684			 
2684			 
2684				; move tok past this to start of name defintition 
2684				; TODO get word to define 
2684				; TODO Move past word token 
2684				; TODO get length of string up to the ';' 
2684			 
2684 2a fd f3		ld hl, (os_tok_ptr) 
2687 23			inc hl 
2688 23			inc hl 
2689			 
2689 3e 3b		ld a, ';' 
268b cd 40 13		call strlent 
268e			 
268e 7d			ld a,l 
268f 32 ec f0		ld (os_new_parse_len), a 
2692			 
2692			 
2692			if DEBUG_FORTH_UWORD 
2692 ed 5b fd f3	ld de, (os_tok_ptr) 
2696					DMARK ":01" 
2696 f5				push af  
2697 3a ab 26			ld a, (.dmark)  
269a 32 a6 fd			ld (debug_mark),a  
269d 3a ac 26			ld a, (.dmark+1)  
26a0 32 a7 fd			ld (debug_mark+1),a  
26a3 3a ad 26			ld a, (.dmark+2)  
26a6 32 a8 fd			ld (debug_mark+2),a  
26a9 18 03			jr .pastdmark  
26ab ..			.dmark: db ":01"  
26ae f1			.pastdmark: pop af  
26af			endm  
# End of macro DMARK
26af			CALLMONITOR 
26af cd aa fd			call debug_vector  
26b2				endm  
# End of macro CALLMONITOR
26b2			endif 
26b2			 
26b2			; 
26b2			;  new word memory layout: 
26b2			;  
26b2			;    : adg 6666 ;  
26b2			; 
26b2			;    db   1     ; user defined word  
26b2 23			inc hl    
26b3			;    dw   sysdict 
26b3 23			inc hl 
26b4 23			inc hl 
26b5			;    db <word len>+1 (for null) 
26b5 23			inc hl 
26b6			;    db .... <word> 
26b6			; 
26b6			 
26b6 23			inc hl    ; some extras for the word preamble before the above 
26b7 23			inc hl 
26b8 23			inc hl 
26b9 23			inc hl 
26ba 23			inc hl 
26bb 23			inc hl 
26bc 23			inc hl  
26bd 23			inc hl 
26be 23			inc hl 
26bf 23			inc hl 
26c0 23			inc hl 
26c1 23			inc hl 
26c2 23			inc hl 
26c3 23			inc hl     ; TODO how many do we really need?     maybe only 6 
26c4			;       exec word buffer 
26c4			;	<ptr word>   
26c4 23			inc hl 
26c5 23			inc hl 
26c6			;       <word list><null term> 7F final term 
26c6			 
26c6			 
26c6			if DEBUG_FORTH_UWORD 
26c6					DMARK ":02" 
26c6 f5				push af  
26c7 3a db 26			ld a, (.dmark)  
26ca 32 a6 fd			ld (debug_mark),a  
26cd 3a dc 26			ld a, (.dmark+1)  
26d0 32 a7 fd			ld (debug_mark+1),a  
26d3 3a dd 26			ld a, (.dmark+2)  
26d6 32 a8 fd			ld (debug_mark+2),a  
26d9 18 03			jr .pastdmark  
26db ..			.dmark: db ":02"  
26de f1			.pastdmark: pop af  
26df			endm  
# End of macro DMARK
26df			CALLMONITOR 
26df cd aa fd			call debug_vector  
26e2				endm  
# End of macro CALLMONITOR
26e2			endif 
26e2			 
26e2			 
26e2				; malloc the size 
26e2			 
26e2 cd aa 13			call malloc 
26e5 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
26e8			 
26e8			;    db   1     ; user defined word  
26e8 3e 01			ld a, WORD_SYS_UWORD  
26ea 77				ld (hl), a 
26eb			 
26eb 23			inc hl    
26ec			;    dw   sysdict 
26ec 11 36 25		ld de, sysdict       ; continue on with the scan to the system dict 
26ef 73			ld (hl), e 
26f0 23			inc hl 
26f1 72			ld (hl), d 
26f2 23			inc hl 
26f3			 
26f3			 
26f3			;    Setup dict word 
26f3			 
26f3 23			inc hl 
26f4 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
26f7			 
26f7			; 1. get length of dict word 
26f7			 
26f7			 
26f7 2a fd f3		ld hl, (os_tok_ptr) 
26fa 23			inc hl 
26fb 23			inc hl    ; position to start of dict word 
26fc 3e 00		ld a, 0 
26fe cd 40 13		call strlent 
2701			 
2701			 
2701 23			inc hl    ; to include null??? 
2702			 
2702			; write length of dict word 
2702			 
2702 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2706 1b			dec de 
2707 eb			ex de, hl 
2708 73			ld (hl), e 
2709 eb			ex de, hl 
270a			 
270a			 
270a			 
270a			; copy  
270a 4d			ld c, l 
270b 06 00		ld b, 0 
270d ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2711 2a fd f3		ld hl, (os_tok_ptr) 
2714 23			inc hl 
2715 23			inc hl    ; position to start of dict word 
2716			 
2716			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2716			 
2716			; TODO need to convert word to upper case 
2716			 
2716			ucasetok:	 
2716 7e			ld a,(hl) 
2717 cd 2c 13		call toUpper 
271a 77			ld (hl),a 
271b ed a0		ldi 
271d f2 16 27		jp p, ucasetok 
2720			 
2720			 
2720			 
2720			; de now points to start of where the word body code should be placed 
2720 ed 53 e8 f0	ld (os_new_work_ptr), de 
2724			; hl now points to the words to throw at forthexec which needs to be copied 
2724 22 e6 f0		ld (os_new_src_ptr), hl 
2727			 
2727			; TODO add 'call to forthexec' 
2727			 
2727			if DEBUG_FORTH_UWORD 
2727 c5			push bc 
2728 ed 4b ee f0	ld bc, (os_new_malloc) 
272c					DMARK ":0x" 
272c f5				push af  
272d 3a 41 27			ld a, (.dmark)  
2730 32 a6 fd			ld (debug_mark),a  
2733 3a 42 27			ld a, (.dmark+1)  
2736 32 a7 fd			ld (debug_mark+1),a  
2739 3a 43 27			ld a, (.dmark+2)  
273c 32 a8 fd			ld (debug_mark+2),a  
273f 18 03			jr .pastdmark  
2741 ..			.dmark: db ":0x"  
2744 f1			.pastdmark: pop af  
2745			endm  
# End of macro DMARK
2745			CALLMONITOR 
2745 cd aa fd			call debug_vector  
2748				endm  
# End of macro CALLMONITOR
2748 c1			pop bc 
2749			endif 
2749			 
2749			 
2749			; create word preamble which should be: 
2749			 
2749			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2749			 
2749			;    ld hl, <word code> 
2749			;    jp user_exec 
2749			;    <word code bytes> 
2749			 
2749			 
2749			;	inc de     ; TODO ??? or are we already past the word's null 
2749 eb			ex de, hl 
274a			 
274a 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
274c			 
274c 23			inc hl 
274d 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2750 23			inc hl 
2751			 
2751 23			inc hl 
2752 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2754			 
2754 01 df 5c		ld bc, user_exec 
2757 23			inc hl 
2758 71			ld (hl), c     ; poke address of user_exec 
2759 23			inc hl 
275a 70			ld (hl), b     
275b			; 
275b			;	inc hl 
275b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
275b			; 
275b			; 
275b			;	ld bc, macro_forth_rsp_next 
275b			;	inc hl 
275b			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
275b			;	inc hl 
275b			;	ld (hl), b     
275b			; 
275b			;	inc hl 
275b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
275b			; 
275b			; 
275b			;	inc hl 
275b			;	ld bc, forthexec 
275b			;	ld (hl), c     ; poke address of forthexec 
275b			;	inc hl 
275b			;	ld (hl), b      
275b			; 
275b			;	inc hl 
275b			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
275b			; 
275b			;	ld bc, user_dict_next 
275b			;	inc hl 
275b			;	ld (hl), c     ; poke address of forthexec 
275b			;	inc hl 
275b			;	ld (hl), b      
275b			 
275b			; hl is now where we need to copy the word byte data to save this 
275b			 
275b 23			inc hl 
275c 22 e4 f0		ld (os_new_exec), hl 
275f			 
275f			; copy definition 
275f			 
275f eb			ex de, hl 
2760			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2760			;	inc de    ; skip the PC for this parse 
2760 3a ec f0		ld a, (os_new_parse_len) 
2763 4f			ld c, a 
2764 06 00		ld b, 0 
2766 ed b0		ldir		 ; copy defintion 
2768			 
2768			 
2768			; poke the address of where the new word bytes live for forthexec 
2768			 
2768 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
276b			 
276b ed 5b e4 f0	ld de, (os_new_exec)      
276f			 
276f 73			ld (hl), e 
2770 23			inc hl 
2771 72			ld (hl), d 
2772			 
2772				; TODO copy last user dict word next link to this word 
2772				; TODO update last user dict word to point to this word 
2772			; 
2772			; hl f923 de 812a ; bc 811a 
2772			 
2772			if DEBUG_FORTH_UWORD 
2772 c5			push bc 
2773 ed 4b ee f0	ld bc, (os_new_malloc) 
2777					DMARK ":0A" 
2777 f5				push af  
2778 3a 8c 27			ld a, (.dmark)  
277b 32 a6 fd			ld (debug_mark),a  
277e 3a 8d 27			ld a, (.dmark+1)  
2781 32 a7 fd			ld (debug_mark+1),a  
2784 3a 8e 27			ld a, (.dmark+2)  
2787 32 a8 fd			ld (debug_mark+2),a  
278a 18 03			jr .pastdmark  
278c ..			.dmark: db ":0A"  
278f f1			.pastdmark: pop af  
2790			endm  
# End of macro DMARK
2790			CALLMONITOR 
2790 cd aa fd			call debug_vector  
2793				endm  
# End of macro CALLMONITOR
2793 c1			pop bc 
2794			endif 
2794			if DEBUG_FORTH_UWORD 
2794 c5			push bc 
2795 ed 4b ee f0	ld bc, (os_new_malloc) 
2799 03			inc bc 
279a 03			inc bc 
279b 03			inc bc 
279c 03			inc bc 
279d 03			inc bc 
279e 03			inc bc 
279f 03			inc bc 
27a0 03			inc bc 
27a1			 
27a1					DMARK ":0B" 
27a1 f5				push af  
27a2 3a b6 27			ld a, (.dmark)  
27a5 32 a6 fd			ld (debug_mark),a  
27a8 3a b7 27			ld a, (.dmark+1)  
27ab 32 a7 fd			ld (debug_mark+1),a  
27ae 3a b8 27			ld a, (.dmark+2)  
27b1 32 a8 fd			ld (debug_mark+2),a  
27b4 18 03			jr .pastdmark  
27b6 ..			.dmark: db ":0B"  
27b9 f1			.pastdmark: pop af  
27ba			endm  
# End of macro DMARK
27ba			CALLMONITOR 
27ba cd aa fd			call debug_vector  
27bd				endm  
# End of macro CALLMONITOR
27bd c1			pop bc 
27be			endif 
27be			 
27be			; update word dict linked list for new word 
27be			 
27be			 
27be 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27c1 23			inc hl     ; move to next work linked list ptr 
27c2			 
27c2 ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
27c6 73			ld (hl), e 
27c7 23			inc hl 
27c8 72			ld (hl), d 
27c9			 
27c9			if DEBUG_FORTH_UWORD 
27c9 ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
27cd			endif 
27cd			 
27cd ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
27d1			 
27d1			 
27d1			if DEBUG_FORTH_UWORD 
27d1					DMARK ":0+" 
27d1 f5				push af  
27d2 3a e6 27			ld a, (.dmark)  
27d5 32 a6 fd			ld (debug_mark),a  
27d8 3a e7 27			ld a, (.dmark+1)  
27db 32 a7 fd			ld (debug_mark+1),a  
27de 3a e8 27			ld a, (.dmark+2)  
27e1 32 a8 fd			ld (debug_mark+2),a  
27e4 18 03			jr .pastdmark  
27e6 ..			.dmark: db ":0+"  
27e9 f1			.pastdmark: pop af  
27ea			endm  
# End of macro DMARK
27ea			CALLMONITOR 
27ea cd aa fd			call debug_vector  
27ed				endm  
# End of macro CALLMONITOR
27ed			endif 
27ed			 
27ed			STACKFRAMECHK OFF $8efe $989f 
27ed				if DEBUG_STACK_IMB 
27ed					if OFF 
27ed						exx 
27ed						ld hl, $989f 
27ed						pop de   ; $989f 
27ed						call cmp16 
27ed						jr nz, .spnosame 
27ed						ld hl, $8efe 
27ed						pop de   ; $8efe 
27ed						call cmp16 
27ed						jr z, .spfrsame 
27ed						.spnosame: call showsperror 
27ed						.spfrsame: nop 
27ed						exx 
27ed					endif 
27ed				endif 
27ed			endm 
# End of macro STACKFRAMECHK
27ed			 
27ed c9			ret    ; dont process any remaining parser tokens as they form new word 
27ee			 
27ee			 
27ee			 
27ee			 
27ee			;		NEXT 
27ee			.SCOLN: 
27ee			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
27ee 06			db OPCODE_SCOLN 
27ef 3a 28		dw .DROP 
27f1 02			db 2 
27f2 .. 00		db ";",0           
27f4			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
27f4				if DEBUG_FORTH_WORDS_KEY 
27f4					DMARK "SCN" 
27f4 f5				push af  
27f5 3a 09 28			ld a, (.dmark)  
27f8 32 a6 fd			ld (debug_mark),a  
27fb 3a 0a 28			ld a, (.dmark+1)  
27fe 32 a7 fd			ld (debug_mark+1),a  
2801 3a 0b 28			ld a, (.dmark+2)  
2804 32 a8 fd			ld (debug_mark+2),a  
2807 18 03			jr .pastdmark  
2809 ..			.dmark: db "SCN"  
280c f1			.pastdmark: pop af  
280d			endm  
# End of macro DMARK
280d					CALLMONITOR 
280d cd aa fd			call debug_vector  
2810				endm  
# End of macro CALLMONITOR
2810				endif 
2810				FORTH_RSP_TOS 
2810 cd e1 1f			call macro_forth_rsp_tos 
2813				endm 
# End of macro FORTH_RSP_TOS
2813 e5				push hl 
2814				FORTH_RSP_POP 
2814 cd eb 1f			call macro_forth_rsp_pop 
2817				endm 
# End of macro FORTH_RSP_POP
2817 e1				pop hl 
2818			;		ex de,hl 
2818 22 fd f3			ld (os_tok_ptr),hl 
281b			 
281b			if DEBUG_FORTH_UWORD 
281b					DMARK "SCL" 
281b f5				push af  
281c 3a 30 28			ld a, (.dmark)  
281f 32 a6 fd			ld (debug_mark),a  
2822 3a 31 28			ld a, (.dmark+1)  
2825 32 a7 fd			ld (debug_mark+1),a  
2828 3a 32 28			ld a, (.dmark+2)  
282b 32 a8 fd			ld (debug_mark+2),a  
282e 18 03			jr .pastdmark  
2830 ..			.dmark: db "SCL"  
2833 f1			.pastdmark: pop af  
2834			endm  
# End of macro DMARK
2834			CALLMONITOR 
2834 cd aa fd			call debug_vector  
2837				endm  
# End of macro CALLMONITOR
2837			endif 
2837				NEXTW 
2837 c3 de 23			jp macro_next 
283a				endm 
# End of macro NEXTW
283a			 
283a			.DROP: 
283a			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
283a 1b				db WORD_SYS_CORE+OPCODE_DROP             
283b 65 28			dw .DUP2            
283d 05				db 4 + 1 
283e .. 00			db "DROP",0              
2843				endm 
# End of macro CWHEAD
2843			; | DROP ( w -- )   drop the TOS item   | DONE 
2843				if DEBUG_FORTH_WORDS_KEY 
2843					DMARK "DRP" 
2843 f5				push af  
2844 3a 58 28			ld a, (.dmark)  
2847 32 a6 fd			ld (debug_mark),a  
284a 3a 59 28			ld a, (.dmark+1)  
284d 32 a7 fd			ld (debug_mark+1),a  
2850 3a 5a 28			ld a, (.dmark+2)  
2853 32 a8 fd			ld (debug_mark+2),a  
2856 18 03			jr .pastdmark  
2858 ..			.dmark: db "DRP"  
285b f1			.pastdmark: pop af  
285c			endm  
# End of macro DMARK
285c					CALLMONITOR 
285c cd aa fd			call debug_vector  
285f				endm  
# End of macro CALLMONITOR
285f				endif 
285f				FORTH_DSP_POP 
285f cd e0 22			call macro_forth_dsp_pop 
2862				endm 
# End of macro FORTH_DSP_POP
2862				NEXTW 
2862 c3 de 23			jp macro_next 
2865				endm 
# End of macro NEXTW
2865			.DUP2: 
2865			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2865 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2866 aa 28			dw .DROP2            
2868 05				db 4 + 1 
2869 .. 00			db "2DUP",0              
286e				endm 
# End of macro CWHEAD
286e			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
286e				if DEBUG_FORTH_WORDS_KEY 
286e					DMARK "2DU" 
286e f5				push af  
286f 3a 83 28			ld a, (.dmark)  
2872 32 a6 fd			ld (debug_mark),a  
2875 3a 84 28			ld a, (.dmark+1)  
2878 32 a7 fd			ld (debug_mark+1),a  
287b 3a 85 28			ld a, (.dmark+2)  
287e 32 a8 fd			ld (debug_mark+2),a  
2881 18 03			jr .pastdmark  
2883 ..			.dmark: db "2DU"  
2886 f1			.pastdmark: pop af  
2887			endm  
# End of macro DMARK
2887					CALLMONITOR 
2887 cd aa fd			call debug_vector  
288a				endm  
# End of macro CALLMONITOR
288a				endif 
288a				FORTH_DSP_VALUEHL 
288a cd 28 22			call macro_dsp_valuehl 
288d				endm 
# End of macro FORTH_DSP_VALUEHL
288d e5				push hl      ; 2 
288e			 
288e				FORTH_DSP_POP 
288e cd e0 22			call macro_forth_dsp_pop 
2891				endm 
# End of macro FORTH_DSP_POP
2891				 
2891				FORTH_DSP_VALUEHL 
2891 cd 28 22			call macro_dsp_valuehl 
2894				endm 
# End of macro FORTH_DSP_VALUEHL
2894			;		push hl      ; 1 
2894			 
2894				FORTH_DSP_POP 
2894 cd e0 22			call macro_forth_dsp_pop 
2897				endm 
# End of macro FORTH_DSP_POP
2897			 
2897			;		pop hl       ; 1 
2897 d1				pop de       ; 2 
2898			 
2898 cd 23 20			call forth_push_numhl 
289b eb				ex de, hl 
289c cd 23 20			call forth_push_numhl 
289f			 
289f				 
289f eb				ex de, hl 
28a0			 
28a0 cd 23 20			call forth_push_numhl 
28a3 eb				ex de, hl 
28a4 cd 23 20			call forth_push_numhl 
28a7			 
28a7			 
28a7				NEXTW 
28a7 c3 de 23			jp macro_next 
28aa				endm 
# End of macro NEXTW
28aa			.DROP2: 
28aa			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
28aa 1d				db WORD_SYS_CORE+OPCODE_DROP2             
28ab d9 28			dw .SWAP2            
28ad 06				db 5 + 1 
28ae .. 00			db "2DROP",0              
28b4				endm 
# End of macro CWHEAD
28b4			; | 2DROP ( w w -- )    Double drop | DONE 
28b4				if DEBUG_FORTH_WORDS_KEY 
28b4					DMARK "2DR" 
28b4 f5				push af  
28b5 3a c9 28			ld a, (.dmark)  
28b8 32 a6 fd			ld (debug_mark),a  
28bb 3a ca 28			ld a, (.dmark+1)  
28be 32 a7 fd			ld (debug_mark+1),a  
28c1 3a cb 28			ld a, (.dmark+2)  
28c4 32 a8 fd			ld (debug_mark+2),a  
28c7 18 03			jr .pastdmark  
28c9 ..			.dmark: db "2DR"  
28cc f1			.pastdmark: pop af  
28cd			endm  
# End of macro DMARK
28cd					CALLMONITOR 
28cd cd aa fd			call debug_vector  
28d0				endm  
# End of macro CALLMONITOR
28d0				endif 
28d0				FORTH_DSP_POP 
28d0 cd e0 22			call macro_forth_dsp_pop 
28d3				endm 
# End of macro FORTH_DSP_POP
28d3				FORTH_DSP_POP 
28d3 cd e0 22			call macro_forth_dsp_pop 
28d6				endm 
# End of macro FORTH_DSP_POP
28d6				NEXTW 
28d6 c3 de 23			jp macro_next 
28d9				endm 
# End of macro NEXTW
28d9			.SWAP2: 
28d9			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
28d9 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
28da 02 29			dw .AT            
28dc 06				db 5 + 1 
28dd .. 00			db "2SWAP",0              
28e3				endm 
# End of macro CWHEAD
28e3			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
28e3				if DEBUG_FORTH_WORDS_KEY 
28e3					DMARK "2SW" 
28e3 f5				push af  
28e4 3a f8 28			ld a, (.dmark)  
28e7 32 a6 fd			ld (debug_mark),a  
28ea 3a f9 28			ld a, (.dmark+1)  
28ed 32 a7 fd			ld (debug_mark+1),a  
28f0 3a fa 28			ld a, (.dmark+2)  
28f3 32 a8 fd			ld (debug_mark+2),a  
28f6 18 03			jr .pastdmark  
28f8 ..			.dmark: db "2SW"  
28fb f1			.pastdmark: pop af  
28fc			endm  
# End of macro DMARK
28fc					CALLMONITOR 
28fc cd aa fd			call debug_vector  
28ff				endm  
# End of macro CALLMONITOR
28ff				endif 
28ff			; TODO Use os stack swap memory 
28ff				NEXTW 
28ff c3 de 23			jp macro_next 
2902				endm 
# End of macro NEXTW
2902			.AT: 
2902			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2902 1f				db WORD_SYS_CORE+OPCODE_AT             
2903 34 29			dw .CAT            
2905 02				db 1 + 1 
2906 .. 00			db "@",0              
2908				endm 
# End of macro CWHEAD
2908			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2908			 
2908				if DEBUG_FORTH_WORDS_KEY 
2908					DMARK "AT." 
2908 f5				push af  
2909 3a 1d 29			ld a, (.dmark)  
290c 32 a6 fd			ld (debug_mark),a  
290f 3a 1e 29			ld a, (.dmark+1)  
2912 32 a7 fd			ld (debug_mark+1),a  
2915 3a 1f 29			ld a, (.dmark+2)  
2918 32 a8 fd			ld (debug_mark+2),a  
291b 18 03			jr .pastdmark  
291d ..			.dmark: db "AT."  
2920 f1			.pastdmark: pop af  
2921			endm  
# End of macro DMARK
2921					CALLMONITOR 
2921 cd aa fd			call debug_vector  
2924				endm  
# End of macro CALLMONITOR
2924				endif 
2924			.getbyteat:	 
2924				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2924 cd 28 22			call macro_dsp_valuehl 
2927				endm 
# End of macro FORTH_DSP_VALUEHL
2927				 
2927			;		push hl 
2927			 
2927				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2927 cd e0 22			call macro_forth_dsp_pop 
292a				endm 
# End of macro FORTH_DSP_POP
292a			 
292a			;		pop hl 
292a			 
292a 7e				ld a, (hl) 
292b			 
292b 6f				ld l, a 
292c 26 00			ld h, 0 
292e cd 23 20			call forth_push_numhl 
2931			 
2931				NEXTW 
2931 c3 de 23			jp macro_next 
2934				endm 
# End of macro NEXTW
2934			.CAT: 
2934			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2934 20				db WORD_SYS_CORE+OPCODE_CAT             
2935 5d 29			dw .BANG            
2937 03				db 2 + 1 
2938 .. 00			db "C@",0              
293b				endm 
# End of macro CWHEAD
293b			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
293b				if DEBUG_FORTH_WORDS_KEY 
293b					DMARK "CAA" 
293b f5				push af  
293c 3a 50 29			ld a, (.dmark)  
293f 32 a6 fd			ld (debug_mark),a  
2942 3a 51 29			ld a, (.dmark+1)  
2945 32 a7 fd			ld (debug_mark+1),a  
2948 3a 52 29			ld a, (.dmark+2)  
294b 32 a8 fd			ld (debug_mark+2),a  
294e 18 03			jr .pastdmark  
2950 ..			.dmark: db "CAA"  
2953 f1			.pastdmark: pop af  
2954			endm  
# End of macro DMARK
2954					CALLMONITOR 
2954 cd aa fd			call debug_vector  
2957				endm  
# End of macro CALLMONITOR
2957				endif 
2957 c3 24 29			jp .getbyteat 
295a				NEXTW 
295a c3 de 23			jp macro_next 
295d				endm 
# End of macro NEXTW
295d			.BANG: 
295d			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
295d 21				db WORD_SYS_CORE+OPCODE_BANG             
295e 93 29			dw .CBANG            
2960 02				db 1 + 1 
2961 .. 00			db "!",0              
2963				endm 
# End of macro CWHEAD
2963			; | ! ( x w -- ) Store x at address w      | DONE 
2963				if DEBUG_FORTH_WORDS_KEY 
2963					DMARK "BNG" 
2963 f5				push af  
2964 3a 78 29			ld a, (.dmark)  
2967 32 a6 fd			ld (debug_mark),a  
296a 3a 79 29			ld a, (.dmark+1)  
296d 32 a7 fd			ld (debug_mark+1),a  
2970 3a 7a 29			ld a, (.dmark+2)  
2973 32 a8 fd			ld (debug_mark+2),a  
2976 18 03			jr .pastdmark  
2978 ..			.dmark: db "BNG"  
297b f1			.pastdmark: pop af  
297c			endm  
# End of macro DMARK
297c					CALLMONITOR 
297c cd aa fd			call debug_vector  
297f				endm  
# End of macro CALLMONITOR
297f				endif 
297f			 
297f			.storebyteat:		 
297f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297f cd 28 22			call macro_dsp_valuehl 
2982				endm 
# End of macro FORTH_DSP_VALUEHL
2982				 
2982 e5				push hl 
2983			 
2983				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2983 cd e0 22			call macro_forth_dsp_pop 
2986				endm 
# End of macro FORTH_DSP_POP
2986			 
2986				; get byte to poke 
2986			 
2986				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2986 cd 28 22			call macro_dsp_valuehl 
2989				endm 
# End of macro FORTH_DSP_VALUEHL
2989 e5				push hl 
298a			 
298a			 
298a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298a cd e0 22			call macro_forth_dsp_pop 
298d				endm 
# End of macro FORTH_DSP_POP
298d			 
298d			 
298d d1				pop de 
298e e1				pop hl 
298f			 
298f 73				ld (hl),e 
2990			 
2990			 
2990				NEXTW 
2990 c3 de 23			jp macro_next 
2993				endm 
# End of macro NEXTW
2993			.CBANG: 
2993			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2993 22				db WORD_SYS_CORE+OPCODE_CBANG             
2994 bc 29			dw .SCALL            
2996 03				db 2 + 1 
2997 .. 00			db "C!",0              
299a				endm 
# End of macro CWHEAD
299a			; | C!  ( x w -- ) Store x at address w  | DONE 
299a				if DEBUG_FORTH_WORDS_KEY 
299a					DMARK "CBA" 
299a f5				push af  
299b 3a af 29			ld a, (.dmark)  
299e 32 a6 fd			ld (debug_mark),a  
29a1 3a b0 29			ld a, (.dmark+1)  
29a4 32 a7 fd			ld (debug_mark+1),a  
29a7 3a b1 29			ld a, (.dmark+2)  
29aa 32 a8 fd			ld (debug_mark+2),a  
29ad 18 03			jr .pastdmark  
29af ..			.dmark: db "CBA"  
29b2 f1			.pastdmark: pop af  
29b3			endm  
# End of macro DMARK
29b3					CALLMONITOR 
29b3 cd aa fd			call debug_vector  
29b6				endm  
# End of macro CALLMONITOR
29b6				endif 
29b6 c3 7f 29			jp .storebyteat 
29b9				NEXTW 
29b9 c3 de 23			jp macro_next 
29bc				endm 
# End of macro NEXTW
29bc			.SCALL: 
29bc			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
29bc 23				db WORD_SYS_CORE+OPCODE_SCALL             
29bd f0 29			dw .DEPTH            
29bf 05				db 4 + 1 
29c0 .. 00			db "CALL",0              
29c5				endm 
# End of macro CWHEAD
29c5			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
29c5				if DEBUG_FORTH_WORDS_KEY 
29c5					DMARK "CLL" 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 a6 fd			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 a7 fd			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 a8 fd			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "CLL"  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de					CALLMONITOR 
29de cd aa fd			call debug_vector  
29e1				endm  
# End of macro CALLMONITOR
29e1				endif 
29e1			 
29e1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29e1 cd 28 22			call macro_dsp_valuehl 
29e4				endm 
# End of macro FORTH_DSP_VALUEHL
29e4			 
29e4			;		push hl 
29e4			 
29e4				; destroy value TOS 
29e4			 
29e4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29e4 cd e0 22			call macro_forth_dsp_pop 
29e7				endm 
# End of macro FORTH_DSP_POP
29e7			 
29e7					 
29e7			;		pop hl 
29e7			 
29e7				; how to do a call with hl???? save SP? 
29e7 cd 82 23			call forth_call_hl 
29ea			 
29ea			 
29ea				; TODO push value back onto stack for another op etc 
29ea			 
29ea cd 23 20			call forth_push_numhl 
29ed				NEXTW 
29ed c3 de 23			jp macro_next 
29f0				endm 
# End of macro NEXTW
29f0			.DEPTH: 
29f0			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
29f0 24				db WORD_SYS_CORE+OPCODE_DEPTH             
29f1 2d 2a			dw .OVER            
29f3 06				db 5 + 1 
29f4 .. 00			db "DEPTH",0              
29fa				endm 
# End of macro CWHEAD
29fa			; | DEPTH ( -- u ) Push count of stack | DONE 
29fa				; take current TOS and remove from base value div by two to get count 
29fa				if DEBUG_FORTH_WORDS_KEY 
29fa					DMARK "DEP" 
29fa f5				push af  
29fb 3a 0f 2a			ld a, (.dmark)  
29fe 32 a6 fd			ld (debug_mark),a  
2a01 3a 10 2a			ld a, (.dmark+1)  
2a04 32 a7 fd			ld (debug_mark+1),a  
2a07 3a 11 2a			ld a, (.dmark+2)  
2a0a 32 a8 fd			ld (debug_mark+2),a  
2a0d 18 03			jr .pastdmark  
2a0f ..			.dmark: db "DEP"  
2a12 f1			.pastdmark: pop af  
2a13			endm  
# End of macro DMARK
2a13					CALLMONITOR 
2a13 cd aa fd			call debug_vector  
2a16				endm  
# End of macro CALLMONITOR
2a16				endif 
2a16			 
2a16			 
2a16 2a 29 f9		ld hl, (cli_data_sp) 
2a19 11 63 f6		ld de, cli_data_stack 
2a1c ed 52		sbc hl,de 
2a1e			 
2a1e			; div by size of stack item 
2a1e			 
2a1e 5d			ld e,l 
2a1f 0e 03		ld c, 3 
2a21 cd 5f 0f		call Div8 
2a24			 
2a24 6f			ld l,a 
2a25 26 00		ld h,0 
2a27			 
2a27			;srl h 
2a27			;rr l 
2a27			 
2a27 cd 23 20			call forth_push_numhl 
2a2a				NEXTW 
2a2a c3 de 23			jp macro_next 
2a2d				endm 
# End of macro NEXTW
2a2d			.OVER: 
2a2d			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a2d 42				db WORD_SYS_CORE+46             
2a2e 74 2a			dw .PAUSE            
2a30 05				db 4 + 1 
2a31 .. 00			db "OVER",0              
2a36				endm 
# End of macro CWHEAD
2a36			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a36				if DEBUG_FORTH_WORDS_KEY 
2a36					DMARK "OVR" 
2a36 f5				push af  
2a37 3a 4b 2a			ld a, (.dmark)  
2a3a 32 a6 fd			ld (debug_mark),a  
2a3d 3a 4c 2a			ld a, (.dmark+1)  
2a40 32 a7 fd			ld (debug_mark+1),a  
2a43 3a 4d 2a			ld a, (.dmark+2)  
2a46 32 a8 fd			ld (debug_mark+2),a  
2a49 18 03			jr .pastdmark  
2a4b ..			.dmark: db "OVR"  
2a4e f1			.pastdmark: pop af  
2a4f			endm  
# End of macro DMARK
2a4f					CALLMONITOR 
2a4f cd aa fd			call debug_vector  
2a52				endm  
# End of macro CALLMONITOR
2a52				endif 
2a52			 
2a52			; TODO Use os stack swap memory 
2a52				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a52 cd 28 22			call macro_dsp_valuehl 
2a55				endm 
# End of macro FORTH_DSP_VALUEHL
2a55 e5				push hl    ; n2 
2a56				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a56 cd e0 22			call macro_forth_dsp_pop 
2a59				endm 
# End of macro FORTH_DSP_POP
2a59			 
2a59				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a59 cd 28 22			call macro_dsp_valuehl 
2a5c				endm 
# End of macro FORTH_DSP_VALUEHL
2a5c e5				push hl    ; n1 
2a5d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a5d cd e0 22			call macro_forth_dsp_pop 
2a60				endm 
# End of macro FORTH_DSP_POP
2a60			 
2a60 d1				pop de     ; n1 
2a61 e1				pop hl     ; n2 
2a62			 
2a62 d5				push de 
2a63 e5				push hl 
2a64 d5				push de 
2a65			 
2a65				; push back  
2a65			 
2a65 e1				pop hl 
2a66 cd 23 20			call forth_push_numhl 
2a69 e1				pop hl 
2a6a cd 23 20			call forth_push_numhl 
2a6d e1				pop hl 
2a6e cd 23 20			call forth_push_numhl 
2a71				NEXTW 
2a71 c3 de 23			jp macro_next 
2a74				endm 
# End of macro NEXTW
2a74			 
2a74			.PAUSE: 
2a74			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2a74 43				db WORD_SYS_CORE+47             
2a75 a9 2a			dw .PAUSES            
2a77 08				db 7 + 1 
2a78 .. 00			db "PAUSEMS",0              
2a80				endm 
# End of macro CWHEAD
2a80			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2a80				if DEBUG_FORTH_WORDS_KEY 
2a80					DMARK "PMS" 
2a80 f5				push af  
2a81 3a 95 2a			ld a, (.dmark)  
2a84 32 a6 fd			ld (debug_mark),a  
2a87 3a 96 2a			ld a, (.dmark+1)  
2a8a 32 a7 fd			ld (debug_mark+1),a  
2a8d 3a 97 2a			ld a, (.dmark+2)  
2a90 32 a8 fd			ld (debug_mark+2),a  
2a93 18 03			jr .pastdmark  
2a95 ..			.dmark: db "PMS"  
2a98 f1			.pastdmark: pop af  
2a99			endm  
# End of macro DMARK
2a99					CALLMONITOR 
2a99 cd aa fd			call debug_vector  
2a9c				endm  
# End of macro CALLMONITOR
2a9c				endif 
2a9c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a9c cd 28 22			call macro_dsp_valuehl 
2a9f				endm 
# End of macro FORTH_DSP_VALUEHL
2a9f			;		push hl    ; n2 
2a9f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a9f cd e0 22			call macro_forth_dsp_pop 
2aa2				endm 
# End of macro FORTH_DSP_POP
2aa2			;		pop hl 
2aa2			 
2aa2 7d				ld a, l 
2aa3 cd c3 0c			call aDelayInMS 
2aa6			       NEXTW 
2aa6 c3 de 23			jp macro_next 
2aa9				endm 
# End of macro NEXTW
2aa9			.PAUSES:  
2aa9			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2aa9 44				db WORD_SYS_CORE+48             
2aaa 18 2b			dw .ROT            
2aac 06				db 5 + 1 
2aad .. 00			db "PAUSE",0              
2ab3				endm 
# End of macro CWHEAD
2ab3			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2ab3				if DEBUG_FORTH_WORDS_KEY 
2ab3					DMARK "PAU" 
2ab3 f5				push af  
2ab4 3a c8 2a			ld a, (.dmark)  
2ab7 32 a6 fd			ld (debug_mark),a  
2aba 3a c9 2a			ld a, (.dmark+1)  
2abd 32 a7 fd			ld (debug_mark+1),a  
2ac0 3a ca 2a			ld a, (.dmark+2)  
2ac3 32 a8 fd			ld (debug_mark+2),a  
2ac6 18 03			jr .pastdmark  
2ac8 ..			.dmark: db "PAU"  
2acb f1			.pastdmark: pop af  
2acc			endm  
# End of macro DMARK
2acc					CALLMONITOR 
2acc cd aa fd			call debug_vector  
2acf				endm  
# End of macro CALLMONITOR
2acf				endif 
2acf				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2acf cd 28 22			call macro_dsp_valuehl 
2ad2				endm 
# End of macro FORTH_DSP_VALUEHL
2ad2			;		push hl    ; n2 
2ad2				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ad2 cd e0 22			call macro_forth_dsp_pop 
2ad5				endm 
# End of macro FORTH_DSP_POP
2ad5			;		pop hl 
2ad5 45				ld b, l 
2ad6				if DEBUG_FORTH_WORDS 
2ad6					DMARK "PAU" 
2ad6 f5				push af  
2ad7 3a eb 2a			ld a, (.dmark)  
2ada 32 a6 fd			ld (debug_mark),a  
2add 3a ec 2a			ld a, (.dmark+1)  
2ae0 32 a7 fd			ld (debug_mark+1),a  
2ae3 3a ed 2a			ld a, (.dmark+2)  
2ae6 32 a8 fd			ld (debug_mark+2),a  
2ae9 18 03			jr .pastdmark  
2aeb ..			.dmark: db "PAU"  
2aee f1			.pastdmark: pop af  
2aef			endm  
# End of macro DMARK
2aef					CALLMONITOR 
2aef cd aa fd			call debug_vector  
2af2				endm  
# End of macro CALLMONITOR
2af2				endif 
2af2 c5			.pauses1:	push bc 
2af3 cd de 0c			call delay1s 
2af6 c1				pop bc 
2af7				if DEBUG_FORTH_WORDS 
2af7					DMARK "PA1" 
2af7 f5				push af  
2af8 3a 0c 2b			ld a, (.dmark)  
2afb 32 a6 fd			ld (debug_mark),a  
2afe 3a 0d 2b			ld a, (.dmark+1)  
2b01 32 a7 fd			ld (debug_mark+1),a  
2b04 3a 0e 2b			ld a, (.dmark+2)  
2b07 32 a8 fd			ld (debug_mark+2),a  
2b0a 18 03			jr .pastdmark  
2b0c ..			.dmark: db "PA1"  
2b0f f1			.pastdmark: pop af  
2b10			endm  
# End of macro DMARK
2b10					CALLMONITOR 
2b10 cd aa fd			call debug_vector  
2b13				endm  
# End of macro CALLMONITOR
2b13				endif 
2b13 10 dd			djnz .pauses1 
2b15			 
2b15			       NEXTW 
2b15 c3 de 23			jp macro_next 
2b18				endm 
# End of macro NEXTW
2b18			.ROT: 
2b18			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b18 45				db WORD_SYS_CORE+49             
2b19 66 2b			dw .UWORDS            
2b1b 04				db 3 + 1 
2b1c .. 00			db "ROT",0              
2b20				endm 
# End of macro CWHEAD
2b20			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b20				if DEBUG_FORTH_WORDS_KEY 
2b20					DMARK "ROT" 
2b20 f5				push af  
2b21 3a 35 2b			ld a, (.dmark)  
2b24 32 a6 fd			ld (debug_mark),a  
2b27 3a 36 2b			ld a, (.dmark+1)  
2b2a 32 a7 fd			ld (debug_mark+1),a  
2b2d 3a 37 2b			ld a, (.dmark+2)  
2b30 32 a8 fd			ld (debug_mark+2),a  
2b33 18 03			jr .pastdmark  
2b35 ..			.dmark: db "ROT"  
2b38 f1			.pastdmark: pop af  
2b39			endm  
# End of macro DMARK
2b39					CALLMONITOR 
2b39 cd aa fd			call debug_vector  
2b3c				endm  
# End of macro CALLMONITOR
2b3c				endif 
2b3c			 
2b3c			; TODO Use os stack swap memory 
2b3c				FORTH_DSP_VALUEHL 
2b3c cd 28 22			call macro_dsp_valuehl 
2b3f				endm 
# End of macro FORTH_DSP_VALUEHL
2b3f e5				push hl    ; u3  
2b40			 
2b40				FORTH_DSP_POP 
2b40 cd e0 22			call macro_forth_dsp_pop 
2b43				endm 
# End of macro FORTH_DSP_POP
2b43			 
2b43				FORTH_DSP_VALUEHL 
2b43 cd 28 22			call macro_dsp_valuehl 
2b46				endm 
# End of macro FORTH_DSP_VALUEHL
2b46 e5				push hl     ; u2 
2b47			 
2b47				FORTH_DSP_POP 
2b47 cd e0 22			call macro_forth_dsp_pop 
2b4a				endm 
# End of macro FORTH_DSP_POP
2b4a			 
2b4a				FORTH_DSP_VALUEHL 
2b4a cd 28 22			call macro_dsp_valuehl 
2b4d				endm 
# End of macro FORTH_DSP_VALUEHL
2b4d e5				push hl     ; u1 
2b4e			 
2b4e				FORTH_DSP_POP 
2b4e cd e0 22			call macro_forth_dsp_pop 
2b51				endm 
# End of macro FORTH_DSP_POP
2b51			 
2b51 c1				pop bc      ; u1 
2b52 e1				pop hl      ; u2 
2b53 d1				pop de      ; u3 
2b54			 
2b54			 
2b54 c5				push bc 
2b55 d5				push de 
2b56 e5				push hl 
2b57			 
2b57			 
2b57 e1				pop hl 
2b58 cd 23 20			call forth_push_numhl 
2b5b			 
2b5b e1				pop hl 
2b5c cd 23 20			call forth_push_numhl 
2b5f			 
2b5f e1				pop hl 
2b60 cd 23 20			call forth_push_numhl 
2b63				 
2b63			 
2b63			 
2b63			 
2b63			 
2b63			 
2b63			       NEXTW 
2b63 c3 de 23			jp macro_next 
2b66				endm 
# End of macro NEXTW
2b66			 
2b66			.UWORDS: 
2b66			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2b66 50				db WORD_SYS_CORE+60             
2b67 28 2c			dw .BP            
2b69 07				db 6 + 1 
2b6a .. 00			db "UWORDS",0              
2b71				endm 
# End of macro CWHEAD
2b71			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2b71			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2b71			; | | Following the count are the individual words. 
2b71			; | | 
2b71			; | | e.g. UWORDS 
2b71			; | | BOX DIRLIST 2 
2b71			; | |  
2b71			; | | Can be used to save the words to storage via: 
2b71			; | | UWORDS $01 DO $01 APPEND LOOP 
2b71			if DEBUG_FORTH_WORDS_KEY 
2b71				DMARK "UWR" 
2b71 f5				push af  
2b72 3a 86 2b			ld a, (.dmark)  
2b75 32 a6 fd			ld (debug_mark),a  
2b78 3a 87 2b			ld a, (.dmark+1)  
2b7b 32 a7 fd			ld (debug_mark+1),a  
2b7e 3a 88 2b			ld a, (.dmark+2)  
2b81 32 a8 fd			ld (debug_mark+2),a  
2b84 18 03			jr .pastdmark  
2b86 ..			.dmark: db "UWR"  
2b89 f1			.pastdmark: pop af  
2b8a			endm  
# End of macro DMARK
2b8a				CALLMONITOR 
2b8a cd aa fd			call debug_vector  
2b8d				endm  
# End of macro CALLMONITOR
2b8d			endif 
2b8d 21 00 80			ld hl, baseram 
2b90				;ld hl, baseusermem 
2b90 01 00 00			ld bc, 0    ; start a counter 
2b93			 
2b93			; skip dict stub 
2b93			 
2b93 cd 2f 25			call forth_tok_next 
2b96			 
2b96			 
2b96			; while we have words to look for 
2b96			 
2b96 7e			.douscan:	ld a, (hl)      
2b97			if DEBUG_FORTH_WORDS 
2b97				DMARK "UWs" 
2b97 f5				push af  
2b98 3a ac 2b			ld a, (.dmark)  
2b9b 32 a6 fd			ld (debug_mark),a  
2b9e 3a ad 2b			ld a, (.dmark+1)  
2ba1 32 a7 fd			ld (debug_mark+1),a  
2ba4 3a ae 2b			ld a, (.dmark+2)  
2ba7 32 a8 fd			ld (debug_mark+2),a  
2baa 18 03			jr .pastdmark  
2bac ..			.dmark: db "UWs"  
2baf f1			.pastdmark: pop af  
2bb0			endm  
# End of macro DMARK
2bb0				CALLMONITOR 
2bb0 cd aa fd			call debug_vector  
2bb3				endm  
# End of macro CALLMONITOR
2bb3			endif 
2bb3 fe 00			cp WORD_SYS_END 
2bb5 28 4d			jr z, .udone 
2bb7 fe 01			cp WORD_SYS_UWORD 
2bb9 20 44			jr nz, .nuword 
2bbb			 
2bbb			if DEBUG_FORTH_WORDS 
2bbb				DMARK "UWu" 
2bbb f5				push af  
2bbc 3a d0 2b			ld a, (.dmark)  
2bbf 32 a6 fd			ld (debug_mark),a  
2bc2 3a d1 2b			ld a, (.dmark+1)  
2bc5 32 a7 fd			ld (debug_mark+1),a  
2bc8 3a d2 2b			ld a, (.dmark+2)  
2bcb 32 a8 fd			ld (debug_mark+2),a  
2bce 18 03			jr .pastdmark  
2bd0 ..			.dmark: db "UWu"  
2bd3 f1			.pastdmark: pop af  
2bd4			endm  
# End of macro DMARK
2bd4				CALLMONITOR 
2bd4 cd aa fd			call debug_vector  
2bd7				endm  
# End of macro CALLMONITOR
2bd7			endif 
2bd7				; we have a uword so push its name to the stack 
2bd7			 
2bd7 e5				push hl  ; save so we can move to next dict block 
2bd8			 
2bd8				; skip opcode 
2bd8 23				inc hl  
2bd9				; skip next ptr 
2bd9 23				inc hl  
2bda 23				inc hl 
2bdb				; skip len 
2bdb 23				inc hl 
2bdc			if DEBUG_FORTH_WORDS 
2bdc				DMARK "UWt" 
2bdc f5				push af  
2bdd 3a f1 2b			ld a, (.dmark)  
2be0 32 a6 fd			ld (debug_mark),a  
2be3 3a f2 2b			ld a, (.dmark+1)  
2be6 32 a7 fd			ld (debug_mark+1),a  
2be9 3a f3 2b			ld a, (.dmark+2)  
2bec 32 a8 fd			ld (debug_mark+2),a  
2bef 18 03			jr .pastdmark  
2bf1 ..			.dmark: db "UWt"  
2bf4 f1			.pastdmark: pop af  
2bf5			endm  
# End of macro DMARK
2bf5				CALLMONITOR 
2bf5 cd aa fd			call debug_vector  
2bf8				endm  
# End of macro CALLMONITOR
2bf8			endif 
2bf8 03				inc bc 
2bf9			 
2bf9 c5				push bc 
2bfa cd 91 20			call forth_push_str 
2bfd c1				pop bc 
2bfe			 
2bfe e1				pop hl 	 
2bff			 
2bff cd 2f 25		.nuword:	call forth_tok_next 
2c02 18 92			jr .douscan  
2c04			 
2c04			.udone:		 ; push count of uwords found 
2c04 c5				push bc 
2c05 e1				pop hl 
2c06			 
2c06			if DEBUG_FORTH_WORDS 
2c06				DMARK "UWc" 
2c06 f5				push af  
2c07 3a 1b 2c			ld a, (.dmark)  
2c0a 32 a6 fd			ld (debug_mark),a  
2c0d 3a 1c 2c			ld a, (.dmark+1)  
2c10 32 a7 fd			ld (debug_mark+1),a  
2c13 3a 1d 2c			ld a, (.dmark+2)  
2c16 32 a8 fd			ld (debug_mark+2),a  
2c19 18 03			jr .pastdmark  
2c1b ..			.dmark: db "UWc"  
2c1e f1			.pastdmark: pop af  
2c1f			endm  
# End of macro DMARK
2c1f				CALLMONITOR 
2c1f cd aa fd			call debug_vector  
2c22				endm  
# End of macro CALLMONITOR
2c22			endif 
2c22 cd 23 20			call forth_push_numhl 
2c25			 
2c25			 
2c25			       NEXTW 
2c25 c3 de 23			jp macro_next 
2c28				endm 
# End of macro NEXTW
2c28			 
2c28			.BP: 
2c28			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c28 54				db WORD_SYS_CORE+64             
2c29 62 2c			dw .MONITOR            
2c2b 03				db 2 + 1 
2c2c .. 00			db "BP",0              
2c2f				endm 
# End of macro CWHEAD
2c2f			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c2f			; | | $00 Will enable the break points within specific code paths 
2c2f			; | | $01 Will disable break points 
2c2f			; | |  
2c2f			; | | By default break points are off. Either the above can be used to enable them 
2c2f			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c2f			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2c2f			; | | can disable break points. Exiting will then continue boot process. 
2c2f				; get byte count 
2c2f				if DEBUG_FORTH_WORDS_KEY 
2c2f					DMARK "BP." 
2c2f f5				push af  
2c30 3a 44 2c			ld a, (.dmark)  
2c33 32 a6 fd			ld (debug_mark),a  
2c36 3a 45 2c			ld a, (.dmark+1)  
2c39 32 a7 fd			ld (debug_mark+1),a  
2c3c 3a 46 2c			ld a, (.dmark+2)  
2c3f 32 a8 fd			ld (debug_mark+2),a  
2c42 18 03			jr .pastdmark  
2c44 ..			.dmark: db "BP."  
2c47 f1			.pastdmark: pop af  
2c48			endm  
# End of macro DMARK
2c48					CALLMONITOR 
2c48 cd aa fd			call debug_vector  
2c4b				endm  
# End of macro CALLMONITOR
2c4b				endif 
2c4b			 
2c4b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c4b cd 28 22			call macro_dsp_valuehl 
2c4e				endm 
# End of macro FORTH_DSP_VALUEHL
2c4e			 
2c4e			;		push hl 
2c4e			 
2c4e				; destroy value TOS 
2c4e			 
2c4e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c4e cd e0 22			call macro_forth_dsp_pop 
2c51				endm 
# End of macro FORTH_DSP_POP
2c51			 
2c51			;		pop hl 
2c51			 
2c51 3e 00			ld a,0 
2c53 bd				cp l 
2c54 28 06			jr z, .bpset 
2c56			;		ld a, '*' 
2c56 cd 44 19			call bp_off 
2c59				NEXTW 
2c59 c3 de 23			jp macro_next 
2c5c				endm 
# End of macro NEXTW
2c5c			 
2c5c			.bpset:	 
2c5c				;	ld (os_view_disable), a 
2c5c cd 38 19			call bp_on 
2c5f			 
2c5f			 
2c5f				NEXTW 
2c5f c3 de 23			jp macro_next 
2c62				endm 
# End of macro NEXTW
2c62			 
2c62			 
2c62			.MONITOR: 
2c62			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2c62 55				db WORD_SYS_CORE+65             
2c63 93 2c			dw .MALLOC            
2c65 08				db 7 + 1 
2c66 .. 00			db "MONITOR",0              
2c6e				endm 
# End of macro CWHEAD
2c6e			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2c6e			; | | At start the current various registers will be displayed with contents. 
2c6e			; | | Top right corner will show the most recent debug marker seen. 
2c6e			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2c6e			; | | and the return stack pointer (RSP). 
2c6e			; | | Pressing: 
2c6e			; | |    1 - Initial screen 
2c6e			; | |    2 - Display a data dump of HL 
2c6e			; | |    3 - Display a data dump of DE 
2c6e			; | |    4 - Display a data dump of BC 
2c6e			; | |    5 - Display a data dump of HL 
2c6e			; | |    6 - Display a data dump of DSP 
2c6e			; | |    7 - Display a data dump of RSP 
2c6e			; | |    8 - Display a data dump of what is at DSP 
2c6e			; | |    9 - Display a data dump of what is at RSP 
2c6e			; | |    0 - Exit monitor and continue running. This will also enable break points 
2c6e			; | |    * - Disable break points 
2c6e			; | |    # - Enter traditional monitor mode 
2c6e			; | | 
2c6e			; | | Monitor Mode 
2c6e			; | | ------------ 
2c6e			; | | A prompt of '>' will be shown for various commands: 
2c6e			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2c6e			; | |    C - Continue display a data dump from the last set address 
2c6e			; | |    M xxxx - Set start of memory edit at address xx 
2c6e			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2c6e			; | |    G xxxx - Exec code at specific address 
2c6e			; | |    Q - Return to previous 
2c6e				if DEBUG_FORTH_WORDS_KEY 
2c6e					DMARK "MON" 
2c6e f5				push af  
2c6f 3a 83 2c			ld a, (.dmark)  
2c72 32 a6 fd			ld (debug_mark),a  
2c75 3a 84 2c			ld a, (.dmark+1)  
2c78 32 a7 fd			ld (debug_mark+1),a  
2c7b 3a 85 2c			ld a, (.dmark+2)  
2c7e 32 a8 fd			ld (debug_mark+2),a  
2c81 18 03			jr .pastdmark  
2c83 ..			.dmark: db "MON"  
2c86 f1			.pastdmark: pop af  
2c87			endm  
# End of macro DMARK
2c87					CALLMONITOR 
2c87 cd aa fd			call debug_vector  
2c8a				endm  
# End of macro CALLMONITOR
2c8a				endif 
2c8a			;		ld a, 0 
2c8a			;		ld (os_view_disable), a 
2c8a cd 38 19			call bp_on 
2c8d			 
2c8d				CALLMONITOR 
2c8d cd aa fd			call debug_vector  
2c90				endm  
# End of macro CALLMONITOR
2c90			 
2c90			;	call monitor 
2c90			 
2c90				NEXTW 
2c90 c3 de 23			jp macro_next 
2c93				endm 
# End of macro NEXTW
2c93			 
2c93			 
2c93			.MALLOC: 
2c93			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2c93 56				db WORD_SYS_CORE+66             
2c94 bc 2c			dw .MALLOC2            
2c96 06				db 5 + 1 
2c97 .. 00			db "ALLOT",0              
2c9d				endm 
# End of macro CWHEAD
2c9d			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2c9d				if DEBUG_FORTH_WORDS_KEY 
2c9d					DMARK "ALL" 
2c9d f5				push af  
2c9e 3a b2 2c			ld a, (.dmark)  
2ca1 32 a6 fd			ld (debug_mark),a  
2ca4 3a b3 2c			ld a, (.dmark+1)  
2ca7 32 a7 fd			ld (debug_mark+1),a  
2caa 3a b4 2c			ld a, (.dmark+2)  
2cad 32 a8 fd			ld (debug_mark+2),a  
2cb0 18 03			jr .pastdmark  
2cb2 ..			.dmark: db "ALL"  
2cb5 f1			.pastdmark: pop af  
2cb6			endm  
# End of macro DMARK
2cb6					CALLMONITOR 
2cb6 cd aa fd			call debug_vector  
2cb9				endm  
# End of macro CALLMONITOR
2cb9				endif 
2cb9 c3 e3 2c			jp .mallocc 
2cbc			.MALLOC2: 
2cbc			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2cbc 56				db WORD_SYS_CORE+66             
2cbd fa 2c			dw .FREE            
2cbf 07				db 6 + 1 
2cc0 .. 00			db "MALLOC",0              
2cc7				endm 
# End of macro CWHEAD
2cc7			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cc7				; get byte count 
2cc7				if DEBUG_FORTH_WORDS_KEY 
2cc7					DMARK "MAL" 
2cc7 f5				push af  
2cc8 3a dc 2c			ld a, (.dmark)  
2ccb 32 a6 fd			ld (debug_mark),a  
2cce 3a dd 2c			ld a, (.dmark+1)  
2cd1 32 a7 fd			ld (debug_mark+1),a  
2cd4 3a de 2c			ld a, (.dmark+2)  
2cd7 32 a8 fd			ld (debug_mark+2),a  
2cda 18 03			jr .pastdmark  
2cdc ..			.dmark: db "MAL"  
2cdf f1			.pastdmark: pop af  
2ce0			endm  
# End of macro DMARK
2ce0					CALLMONITOR 
2ce0 cd aa fd			call debug_vector  
2ce3				endm  
# End of macro CALLMONITOR
2ce3				endif 
2ce3			.mallocc: 
2ce3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ce3 cd 28 22			call macro_dsp_valuehl 
2ce6				endm 
# End of macro FORTH_DSP_VALUEHL
2ce6			 
2ce6			;		push hl 
2ce6			 
2ce6				; destroy value TOS 
2ce6			 
2ce6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ce6 cd e0 22			call macro_forth_dsp_pop 
2ce9				endm 
# End of macro FORTH_DSP_POP
2ce9			 
2ce9			;		pop hl 
2ce9 cd aa 13			call malloc 
2cec			if DEBUG_FORTH_MALLOC_GUARD 
2cec f5				push af 
2ced cd f8 0f			call ishlzero 
2cf0			;		ld a, l 
2cf0			;		add h 
2cf0			;		cp 0 
2cf0 f1				pop af 
2cf1				 
2cf1 cc b1 5d			call z,malloc_error 
2cf4			endif 
2cf4			 
2cf4 cd 23 20			call forth_push_numhl 
2cf7				NEXTW 
2cf7 c3 de 23			jp macro_next 
2cfa				endm 
# End of macro NEXTW
2cfa			 
2cfa			.FREE: 
2cfa			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2cfa 57				db WORD_SYS_CORE+67             
2cfb 2b 2d			dw .LIST            
2cfd 05				db 4 + 1 
2cfe .. 00			db "FREE",0              
2d03				endm 
# End of macro CWHEAD
2d03			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d03				if DEBUG_FORTH_WORDS_KEY 
2d03					DMARK "FRE" 
2d03 f5				push af  
2d04 3a 18 2d			ld a, (.dmark)  
2d07 32 a6 fd			ld (debug_mark),a  
2d0a 3a 19 2d			ld a, (.dmark+1)  
2d0d 32 a7 fd			ld (debug_mark+1),a  
2d10 3a 1a 2d			ld a, (.dmark+2)  
2d13 32 a8 fd			ld (debug_mark+2),a  
2d16 18 03			jr .pastdmark  
2d18 ..			.dmark: db "FRE"  
2d1b f1			.pastdmark: pop af  
2d1c			endm  
# End of macro DMARK
2d1c					CALLMONITOR 
2d1c cd aa fd			call debug_vector  
2d1f				endm  
# End of macro CALLMONITOR
2d1f				endif 
2d1f				; get address 
2d1f			 
2d1f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d1f cd 28 22			call macro_dsp_valuehl 
2d22				endm 
# End of macro FORTH_DSP_VALUEHL
2d22			 
2d22			;		push hl 
2d22			 
2d22				; destroy value TOS 
2d22			 
2d22				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d22 cd e0 22			call macro_forth_dsp_pop 
2d25				endm 
# End of macro FORTH_DSP_POP
2d25			 
2d25			;		pop hl 
2d25			if FORTH_ENABLE_MALLOCFREE 
2d25 cd 74 14			call free 
2d28			endif 
2d28				NEXTW 
2d28 c3 de 23			jp macro_next 
2d2b				endm 
# End of macro NEXTW
2d2b			.LIST: 
2d2b			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d2b 5c				db WORD_SYS_CORE+72             
2d2c 1b 2f			dw .FORGET            
2d2e 05				db 4 + 1 
2d2f .. 00			db "LIST",0              
2d34				endm 
# End of macro CWHEAD
2d34			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d34			; | | The quoted word must be in upper case. 
2d34			if DEBUG_FORTH_WORDS_KEY 
2d34				DMARK "LST" 
2d34 f5				push af  
2d35 3a 49 2d			ld a, (.dmark)  
2d38 32 a6 fd			ld (debug_mark),a  
2d3b 3a 4a 2d			ld a, (.dmark+1)  
2d3e 32 a7 fd			ld (debug_mark+1),a  
2d41 3a 4b 2d			ld a, (.dmark+2)  
2d44 32 a8 fd			ld (debug_mark+2),a  
2d47 18 03			jr .pastdmark  
2d49 ..			.dmark: db "LST"  
2d4c f1			.pastdmark: pop af  
2d4d			endm  
# End of macro DMARK
2d4d				CALLMONITOR 
2d4d cd aa fd			call debug_vector  
2d50				endm  
# End of macro CALLMONITOR
2d50			endif 
2d50			 
2d50				FORTH_DSP_VALUEHL 
2d50 cd 28 22			call macro_dsp_valuehl 
2d53				endm 
# End of macro FORTH_DSP_VALUEHL
2d53			 
2d53 e5				push hl 
2d54				FORTH_DSP_POP 
2d54 cd e0 22			call macro_forth_dsp_pop 
2d57				endm 
# End of macro FORTH_DSP_POP
2d57 c1				pop bc 
2d58			 
2d58			; Start format of scratch string 
2d58			 
2d58 21 fc f0			ld hl, scratch 
2d5b			 
2d5b 3e 3a			ld a, ':' 
2d5d 77				ld (hl),a 
2d5e 23				inc hl 
2d5f 3e 20			ld a, ' ' 
2d61 77				ld (hl), a 
2d62			 
2d62				; Get ptr to the word we need to look up 
2d62			 
2d62			;		FORTH_DSP_VALUEHL 
2d62				;v5 FORTH_DSP_VALUE 
2d62			; TODO type check 
2d62			;		inc hl    ; Skip type check  
2d62			;		push hl 
2d62			;		ex de, hl    ; put into DE 
2d62			 
2d62			 
2d62 21 00 80			ld hl, baseram 
2d65				;ld hl, baseusermem 
2d65			 
2d65 e5			push hl   ; sacreifical push 
2d66			 
2d66			.ldouscanm: 
2d66 e1			pop hl 
2d67			.ldouscan: 
2d67			if DEBUG_FORTH_WORDS 
2d67				DMARK "LSs" 
2d67 f5				push af  
2d68 3a 7c 2d			ld a, (.dmark)  
2d6b 32 a6 fd			ld (debug_mark),a  
2d6e 3a 7d 2d			ld a, (.dmark+1)  
2d71 32 a7 fd			ld (debug_mark+1),a  
2d74 3a 7e 2d			ld a, (.dmark+2)  
2d77 32 a8 fd			ld (debug_mark+2),a  
2d7a 18 03			jr .pastdmark  
2d7c ..			.dmark: db "LSs"  
2d7f f1			.pastdmark: pop af  
2d80			endm  
# End of macro DMARK
2d80				CALLMONITOR 
2d80 cd aa fd			call debug_vector  
2d83				endm  
# End of macro CALLMONITOR
2d83			endif 
2d83			; skip dict stub 
2d83 cd 2f 25			call forth_tok_next 
2d86			 
2d86			 
2d86			; while we have words to look for 
2d86			 
2d86 7e			ld a, (hl)      
2d87			if DEBUG_FORTH_WORDS 
2d87				DMARK "LSk" 
2d87 f5				push af  
2d88 3a 9c 2d			ld a, (.dmark)  
2d8b 32 a6 fd			ld (debug_mark),a  
2d8e 3a 9d 2d			ld a, (.dmark+1)  
2d91 32 a7 fd			ld (debug_mark+1),a  
2d94 3a 9e 2d			ld a, (.dmark+2)  
2d97 32 a8 fd			ld (debug_mark+2),a  
2d9a 18 03			jr .pastdmark  
2d9c ..			.dmark: db "LSk"  
2d9f f1			.pastdmark: pop af  
2da0			endm  
# End of macro DMARK
2da0				CALLMONITOR 
2da0 cd aa fd			call debug_vector  
2da3				endm  
# End of macro CALLMONITOR
2da3			endif 
2da3				;cp WORD_SYS_END 
2da3				;jp z, .lunotfound 
2da3			 
2da3					; if we hit non uwords then gone too far 
2da3 fe 01				cp WORD_SYS_UWORD 
2da5 c2 d7 2e				jp nz, .lunotfound 
2da8			 
2da8				if DEBUG_FORTH_WORDS 
2da8					DMARK "LSu" 
2da8 f5				push af  
2da9 3a bd 2d			ld a, (.dmark)  
2dac 32 a6 fd			ld (debug_mark),a  
2daf 3a be 2d			ld a, (.dmark+1)  
2db2 32 a7 fd			ld (debug_mark+1),a  
2db5 3a bf 2d			ld a, (.dmark+2)  
2db8 32 a8 fd			ld (debug_mark+2),a  
2dbb 18 03			jr .pastdmark  
2dbd ..			.dmark: db "LSu"  
2dc0 f1			.pastdmark: pop af  
2dc1			endm  
# End of macro DMARK
2dc1					CALLMONITOR 
2dc1 cd aa fd			call debug_vector  
2dc4				endm  
# End of macro CALLMONITOR
2dc4				endif 
2dc4			 
2dc4					; found a uword but is it the one we want... 
2dc4			 
2dc4 c5					push bc     ; uword to find is on bc 
2dc5 d1					pop de 
2dc6			 
2dc6 e5					push hl  ; to save the ptr 
2dc7			 
2dc7					; skip opcode 
2dc7 23					inc hl  
2dc8					; skip next ptr 
2dc8 23					inc hl  
2dc9 23					inc hl 
2dca					; skip len 
2dca 23					inc hl 
2dcb			 
2dcb				if DEBUG_FORTH_WORDS 
2dcb					DMARK "LSc" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 a6 fd			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 a7 fd			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 a8 fd			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "LSc"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4					CALLMONITOR 
2de4 cd aa fd			call debug_vector  
2de7				endm  
# End of macro CALLMONITOR
2de7				endif 
2de7			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2de7			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2de7			; Nope that has gone the other way. It needs to be exact not on first zero 
2de7			;		call strcmp 
2de7 c5					push bc 
2de8 cd 7a 13				call StrictStrCmp 
2deb c1					pop bc 
2dec c2 66 2d				jp nz, .ldouscanm 
2def				 
2def			 
2def			 
2def					; we have a uword so push its name to the stack 
2def			 
2def			;	   	push hl  ; save so we can move to next dict block 
2def e1			pop hl 
2df0			 
2df0				if DEBUG_FORTH_WORDS 
2df0					DMARK "LSm" 
2df0 f5				push af  
2df1 3a 05 2e			ld a, (.dmark)  
2df4 32 a6 fd			ld (debug_mark),a  
2df7 3a 06 2e			ld a, (.dmark+1)  
2dfa 32 a7 fd			ld (debug_mark+1),a  
2dfd 3a 07 2e			ld a, (.dmark+2)  
2e00 32 a8 fd			ld (debug_mark+2),a  
2e03 18 03			jr .pastdmark  
2e05 ..			.dmark: db "LSm"  
2e08 f1			.pastdmark: pop af  
2e09			endm  
# End of macro DMARK
2e09					CALLMONITOR 
2e09 cd aa fd			call debug_vector  
2e0c				endm  
# End of macro CALLMONITOR
2e0c				endif 
2e0c			 
2e0c					; skip opcode 
2e0c 23					inc hl  
2e0d					; skip next ptr 
2e0d 23					inc hl  
2e0e 23					inc hl 
2e0f					; skip len 
2e0f 7e					ld a, (hl)   ; save length to add 
2e10				if DEBUG_FORTH_WORDS 
2e10					DMARK "LS2" 
2e10 f5				push af  
2e11 3a 25 2e			ld a, (.dmark)  
2e14 32 a6 fd			ld (debug_mark),a  
2e17 3a 26 2e			ld a, (.dmark+1)  
2e1a 32 a7 fd			ld (debug_mark+1),a  
2e1d 3a 27 2e			ld a, (.dmark+2)  
2e20 32 a8 fd			ld (debug_mark+2),a  
2e23 18 03			jr .pastdmark  
2e25 ..			.dmark: db "LS2"  
2e28 f1			.pastdmark: pop af  
2e29			endm  
# End of macro DMARK
2e29					CALLMONITOR 
2e29 cd aa fd			call debug_vector  
2e2c				endm  
# End of macro CALLMONITOR
2e2c				endif 
2e2c			 
2e2c					; save this location 
2e2c				 
2e2c e5					push hl 
2e2d			 
2e2d 23					inc hl 
2e2e 11 fe f0				ld de, scratch+2 
2e31 4f					ld c, a 
2e32 06 00				ld b, 0 
2e34			 
2e34				if DEBUG_FORTH_WORDS 
2e34					DMARK "LSn" 
2e34 f5				push af  
2e35 3a 49 2e			ld a, (.dmark)  
2e38 32 a6 fd			ld (debug_mark),a  
2e3b 3a 4a 2e			ld a, (.dmark+1)  
2e3e 32 a7 fd			ld (debug_mark+1),a  
2e41 3a 4b 2e			ld a, (.dmark+2)  
2e44 32 a8 fd			ld (debug_mark+2),a  
2e47 18 03			jr .pastdmark  
2e49 ..			.dmark: db "LSn"  
2e4c f1			.pastdmark: pop af  
2e4d			endm  
# End of macro DMARK
2e4d					CALLMONITOR 
2e4d cd aa fd			call debug_vector  
2e50				endm  
# End of macro CALLMONITOR
2e50				endif 
2e50			 
2e50					; copy uword name to scratch 
2e50			 
2e50 ed b0				ldir 
2e52			 
2e52 1b					dec de 
2e53 3e 20				ld a, ' '    ; change null to space 
2e55 12					ld (de), a 
2e56			 
2e56 13					inc de 
2e57			 
2e57 d5					push de 
2e58 c1					pop bc     ; move scratch pointer to end of word name and save it 
2e59			 
2e59 e1					pop hl 
2e5a 7e					ld a, (hl) 
2e5b					;inc hl 
2e5b					; skip word string 
2e5b cd cf 0f				call addatohl 
2e5e			 
2e5e 23					inc hl 
2e5f			 
2e5f				if DEBUG_FORTH_WORDS 
2e5f					DMARK "LS3" 
2e5f f5				push af  
2e60 3a 74 2e			ld a, (.dmark)  
2e63 32 a6 fd			ld (debug_mark),a  
2e66 3a 75 2e			ld a, (.dmark+1)  
2e69 32 a7 fd			ld (debug_mark+1),a  
2e6c 3a 76 2e			ld a, (.dmark+2)  
2e6f 32 a8 fd			ld (debug_mark+2),a  
2e72 18 03			jr .pastdmark  
2e74 ..			.dmark: db "LS3"  
2e77 f1			.pastdmark: pop af  
2e78			endm  
# End of macro DMARK
2e78					CALLMONITOR 
2e78 cd aa fd			call debug_vector  
2e7b				endm  
# End of macro CALLMONITOR
2e7b				endif 
2e7b					; should now be at the start of the machine code to setup the eval of the uword 
2e7b					; now locate the ptr to the string defintion 
2e7b			 
2e7b					; skip ld hl, 
2e7b					; then load the ptr 
2e7b			; TODO use get from hl ptr 
2e7b 23					inc hl 
2e7c 5e					ld e, (hl) 
2e7d 23					inc hl 
2e7e 56					ld d, (hl) 
2e7f eb					ex de, hl 
2e80			 
2e80			 
2e80				if DEBUG_FORTH_WORDS 
2e80					DMARK "LSt" 
2e80 f5				push af  
2e81 3a 95 2e			ld a, (.dmark)  
2e84 32 a6 fd			ld (debug_mark),a  
2e87 3a 96 2e			ld a, (.dmark+1)  
2e8a 32 a7 fd			ld (debug_mark+1),a  
2e8d 3a 97 2e			ld a, (.dmark+2)  
2e90 32 a8 fd			ld (debug_mark+2),a  
2e93 18 03			jr .pastdmark  
2e95 ..			.dmark: db "LSt"  
2e98 f1			.pastdmark: pop af  
2e99			endm  
# End of macro DMARK
2e99					CALLMONITOR 
2e99 cd aa fd			call debug_vector  
2e9c				endm  
# End of macro CALLMONITOR
2e9c				endif 
2e9c			 
2e9c			; cant push right now due to tokenised strings  
2e9c			 
2e9c			; get the destination of where to copy this definition to. 
2e9c			 
2e9c c5					push bc 
2e9d d1					pop de 
2e9e			 
2e9e 7e			.listl:         ld a,(hl) 
2e9f fe 00				cp 0 
2ea1 28 09				jr z, .lreplsp     ; replace zero with space 
2ea3					;cp FORTH_END_BUFFER 
2ea3 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ea5 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ea7				 
2ea7					; just copy this char as is then 
2ea7			 
2ea7 12					ld (de), a 
2ea8			 
2ea8 23			.listnxt:	inc hl 
2ea9 13					inc de 
2eaa 18 f2				jr .listl 
2eac			 
2eac 3e 20		.lreplsp:	ld a,' ' 
2eae 12					ld (de), a 
2eaf 18 f7				jr .listnxt 
2eb1			 
2eb1			; close up uword def 
2eb1			 
2eb1			.listdone: 
2eb1 12					ld (de), a 
2eb2 13					inc de 
2eb3 3e 00				ld a, 0 
2eb5 12					ld (de), a 
2eb6			 
2eb6			; now have def so clean up and push to stack 
2eb6			 
2eb6 21 fc f0				ld hl, scratch 
2eb9				if DEBUG_FORTH_WORDS 
2eb9					DMARK "Ltp" 
2eb9 f5				push af  
2eba 3a ce 2e			ld a, (.dmark)  
2ebd 32 a6 fd			ld (debug_mark),a  
2ec0 3a cf 2e			ld a, (.dmark+1)  
2ec3 32 a7 fd			ld (debug_mark+1),a  
2ec6 3a d0 2e			ld a, (.dmark+2)  
2ec9 32 a8 fd			ld (debug_mark+2),a  
2ecc 18 03			jr .pastdmark  
2ece ..			.dmark: db "Ltp"  
2ed1 f1			.pastdmark: pop af  
2ed2			endm  
# End of macro DMARK
2ed2					CALLMONITOR 
2ed2 cd aa fd			call debug_vector  
2ed5				endm  
# End of macro CALLMONITOR
2ed5				endif 
2ed5			 
2ed5 18 1f			jr .listpush 
2ed7			 
2ed7			;.lnuword:	pop hl 
2ed7			;		call forth_tok_next 
2ed7			;		jp .ldouscan  
2ed7			 
2ed7			.lunotfound:		  
2ed7			 
2ed7				if DEBUG_FORTH_WORDS 
2ed7					DMARK "LSn" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 a6 fd			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 a7 fd			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 a8 fd			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "LSn"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0					CALLMONITOR 
2ef0 cd aa fd			call debug_vector  
2ef3				endm  
# End of macro CALLMONITOR
2ef3				endif 
2ef3			 
2ef3					 
2ef3			;		FORTH_DSP_POP 
2ef3			;		ld hl, .luno 
2ef3			 
2ef3					NEXTW			 
2ef3 c3 de 23			jp macro_next 
2ef6				endm 
# End of macro NEXTW
2ef6			 
2ef6			.listpush: 
2ef6				if DEBUG_FORTH_WORDS 
2ef6					DMARK "LS>" 
2ef6 f5				push af  
2ef7 3a 0b 2f			ld a, (.dmark)  
2efa 32 a6 fd			ld (debug_mark),a  
2efd 3a 0c 2f			ld a, (.dmark+1)  
2f00 32 a7 fd			ld (debug_mark+1),a  
2f03 3a 0d 2f			ld a, (.dmark+2)  
2f06 32 a8 fd			ld (debug_mark+2),a  
2f09 18 03			jr .pastdmark  
2f0b ..			.dmark: db "LS>"  
2f0e f1			.pastdmark: pop af  
2f0f			endm  
# End of macro DMARK
2f0f					CALLMONITOR 
2f0f cd aa fd			call debug_vector  
2f12				endm  
# End of macro CALLMONITOR
2f12				endif 
2f12 cd 91 20				call forth_push_str 
2f15			 
2f15			 
2f15			 
2f15					NEXTW 
2f15 c3 de 23			jp macro_next 
2f18				endm 
# End of macro NEXTW
2f18			 
2f18			;.luno:    db "Word not found",0 
2f18			 
2f18			 
2f18			 
2f18			 
2f18			 
2f18			;		push hl   ; save pointer to start of uword def string 
2f18			; 
2f18			;; look for FORTH_EOL_LINE 
2f18			;		ld a, FORTH_END_BUFFER 
2f18			;		call strlent 
2f18			; 
2f18			;		inc hl		 ; space for coln def 
2f18			;		inc hl 
2f18			;		inc hl          ; space for terms 
2f18			;		inc hl 
2f18			; 
2f18			;		ld a, 20   ; TODO get actual length 
2f18			;		call addatohl    ; include a random amount of room for the uword name 
2f18			; 
2f18			;		 
2f18			;	if DEBUG_FORTH_WORDS 
2f18			;		DMARK "Lt1" 
2f18			;		CALLMONITOR 
2f18			;	endif 
2f18			;		 
2f18			; 
2f18			;; malloc space for the string because we cant change it 
2f18			; 
2f18			;		call malloc 
2f18			;	if DEBUG_FORTH_MALLOC_GUARD 
2f18			;		push af 
2f18			;		call ishlzero 
2f18			;		pop af 
2f18			;		 
2f18			;		call z,malloc_error 
2f18			;	endif 
2f18			; 
2f18			;	if DEBUG_FORTH_WORDS 
2f18			;		DMARK "Lt2" 
2f18			;		CALLMONITOR 
2f18			;	endif 
2f18			;		pop de 
2f18			;		push hl    ; push the malloc to release later 
2f18			;		push hl   ;  push back a copy for the later stack push 
2f18			;		 
2f18			;; copy the string swapping out the zero terms for spaces 
2f18			; 
2f18			;		; de has our source 
2f18			;		; hl has our dest 
2f18			; 
2f18			;; add the coln def 
2f18			; 
2f18			;		ld a, ':' 
2f18			;		ld (hl), a 
2f18			;		inc hl 
2f18			;		ld a, ' ' 
2f18			;		ld (hl), a 
2f18			;		inc hl 
2f18			; 
2f18			;; add the uname word 
2f18			;		push de   ; save our string for now 
2f18			;		ex de, hl 
2f18			; 
2f18			;		FORTH_DSP_VALUE 
2f18			;		;v5 FORTH_DSP_VALUE 
2f18			; 
2f18			;		inc hl   ; skip type but we know by now this is OK 
2f18			; 
2f18			;.luword:	ld a,(hl) 
2f18			;		cp 0 
2f18			;		jr z, .luword2 
2f18			;		ld (de), a 
2f18			;		inc de 
2f18			;		inc hl 
2f18			;		jr .luword 
2f18			; 
2f18			;.luword2:	ld a, ' ' 
2f18			;		ld (de), a 
2f18			;;		inc hl 
2f18			;;		inc de 
2f18			;;		ld (de), a 
2f18			;;		inc hl 
2f18			;		inc de 
2f18			; 
2f18			;		ex de, hl 
2f18			;		pop de 
2f18			;		 
2f18			;		 
2f18			; 
2f18			;; detoken that string and copy it 
2f18			; 
2f18			;	if DEBUG_FORTH_WORDS 
2f18			;		DMARK "Lt2" 
2f18			;		CALLMONITOR 
2f18			;	endif 
2f18			;.ldetok:	ld a, (de) 
2f18			;		cp FORTH_END_BUFFER 
2f18			;		jr z, .ldetokend 
2f18			;		; swap out any zero term for space 
2f18			;		cp 0 
2f18			;		jr nz, .ldetoknext 
2f18			;		ld a, ' ' 
2f18			; 
2f18			;	if DEBUG_FORTH_WORDS 
2f18			;		DMARK "LtS" 
2f18			;		CALLMONITOR 
2f18			;	endif 
2f18			;.ldetoknext:	ld (hl), a 
2f18			;		inc de 
2f18			;		inc hl 
2f18			;		jr .ldetok 
2f18			; 
2f18			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f18			;		ld (hl), a  
2f18			; 
2f18			;; free that temp malloc 
2f18			; 
2f18			;		pop hl    
2f18			; 
2f18			;	if DEBUG_FORTH_WORDS 
2f18			;		DMARK "Lt4" 
2f18			;		CALLMONITOR 
2f18			;	endif 
2f18			;		call forth_apushstrhl 
2f18			; 
2f18			;		; get rid of temp malloc area 
2f18			; 
2f18			;		pop hl 
2f18			;		call free 
2f18			; 
2f18			;		jr .ludone 
2f18			; 
2f18			;.lnuword:	pop hl 
2f18			;		call forth_tok_next 
2f18			;		jp .ldouscan  
2f18			; 
2f18			;.ludone:		 pop hl 
2f18			; 
2f18					NEXTW 
2f18 c3 de 23			jp macro_next 
2f1b				endm 
# End of macro NEXTW
2f1b			 
2f1b			.FORGET: 
2f1b				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f1b 5d				db WORD_SYS_CORE+73             
2f1c 94 2f			dw .NOP            
2f1e 07				db 6 + 1 
2f1f .. 00			db "FORGET",0              
2f26				endm 
# End of macro CWHEAD
2f26			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f26			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2f26			; | |  
2f26			; | | e.g. "MORE" forget 
2f26					if DEBUG_FORTH_WORDS_KEY 
2f26						DMARK "FRG" 
2f26 f5				push af  
2f27 3a 3b 2f			ld a, (.dmark)  
2f2a 32 a6 fd			ld (debug_mark),a  
2f2d 3a 3c 2f			ld a, (.dmark+1)  
2f30 32 a7 fd			ld (debug_mark+1),a  
2f33 3a 3d 2f			ld a, (.dmark+2)  
2f36 32 a8 fd			ld (debug_mark+2),a  
2f39 18 03			jr .pastdmark  
2f3b ..			.dmark: db "FRG"  
2f3e f1			.pastdmark: pop af  
2f3f			endm  
# End of macro DMARK
2f3f						CALLMONITOR 
2f3f cd aa fd			call debug_vector  
2f42				endm  
# End of macro CALLMONITOR
2f42					endif 
2f42			 
2f42				; find uword 
2f42			        ; update start of word with "_" 
2f42				; replace uword with deleted flag 
2f42			 
2f42			 
2f42			;	if DEBUG_FORTH_WORDS 
2f42			;		DMARK "FOG" 
2f42			;		CALLMONITOR 
2f42			;	endif 
2f42			 
2f42			 
2f42					; Get ptr to the word we need to look up 
2f42			 
2f42					FORTH_DSP_VALUEHL 
2f42 cd 28 22			call macro_dsp_valuehl 
2f45				endm 
# End of macro FORTH_DSP_VALUEHL
2f45					;v5 FORTH_DSP_VALUE 
2f45				; TODO type check 
2f45			;		inc hl    ; Skip type check  
2f45 e5					push hl 
2f46 c1					pop bc 
2f47			;		ex de, hl    ; put into DE 
2f47			 
2f47			 
2f47 21 00 80				ld hl, baseram 
2f4a					;ld hl, baseusermem 
2f4a			 
2f4a				; skip dict stub 
2f4a			;	call forth_tok_next 
2f4a e5			push hl   ; sacreifical push 
2f4b			 
2f4b			.fldouscanm: 
2f4b e1				pop hl 
2f4c			.fldouscan: 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "LSs" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c				; skip dict stub 
2f4c cd 2f 25				call forth_tok_next 
2f4f			 
2f4f			 
2f4f			; while we have words to look for 
2f4f			 
2f4f 7e				ld a, (hl)      
2f50			;	if DEBUG_FORTH_WORDS 
2f50			;		DMARK "LSk" 
2f50			;		CALLMONITOR 
2f50			;	endif 
2f50 fe 00				cp WORD_SYS_END 
2f52 ca 8e 2f				jp z, .flunotfound 
2f55 fe 01				cp WORD_SYS_UWORD 
2f57 c2 4c 2f				jp nz, .fldouscan 
2f5a			 
2f5a			;	if DEBUG_FORTH_WORDS 
2f5a			;		DMARK "LSu" 
2f5a			;		CALLMONITOR 
2f5a			;	endif 
2f5a			 
2f5a					; found a uword but is it the one we want... 
2f5a			 
2f5a c5					push bc     ; uword to find is on bc 
2f5b d1					pop de 
2f5c			 
2f5c e5					push hl  ; to save the ptr 
2f5d			 
2f5d					; skip opcode 
2f5d 23					inc hl  
2f5e					; skip next ptr 
2f5e 23					inc hl  
2f5f 23					inc hl 
2f60					; skip len 
2f60 23					inc hl 
2f61			 
2f61			;	if DEBUG_FORTH_WORDS 
2f61			;		DMARK "LSc" 
2f61			;		CALLMONITOR 
2f61			;	endif 
2f61 cd 6d 13				call strcmp 
2f64 c2 4b 2f				jp nz, .fldouscanm 
2f67			; 
2f67			; 
2f67			;; while we have words to look for 
2f67			; 
2f67			;.fdouscan:	ld a, (hl)      
2f67			;	if DEBUG_FORTH_WORDS 
2f67			;		DMARK "LSs" 
2f67			;		CALLMONITOR 
2f67			;	endif 
2f67			;		cp WORD_SYS_END 
2f67			;		jp z, .fudone 
2f67			;		cp WORD_SYS_UWORD 
2f67			;		jp nz, .fnuword 
2f67			; 
2f67			;	if DEBUG_FORTH_WORDS 
2f67			;		DMARK "FGu" 
2f67			;		CALLMONITOR 
2f67			;	endif 
2f67			; 
2f67			;		; found a uword but is it the one we want... 
2f67			; 
2f67			; 
2f67			;	        pop de   ; get back the dsp name 
2f67			;		push de 
2f67			; 
2f67			;		push hl  ; to save the ptr 
2f67			; 
2f67			;		; skip opcode 
2f67			;		inc hl  
2f67			;		; skip next ptr 
2f67			;		inc hl  
2f67			;		inc hl 
2f67			;		; skip len 
2f67			;		inc hl 
2f67			; 
2f67			;	if DEBUG_FORTH_WORDS 
2f67			;		DMARK "FGc" 
2f67			;		CALLMONITOR 
2f67			;	endif 
2f67			;		call strcmp 
2f67			;		jp nz, .fnuword 
2f67			 
2f67			 
2f67 e1			pop hl 
2f68			 
2f68				 
2f68				if DEBUG_FORTH_WORDS 
2f68					DMARK "FGm" 
2f68 f5				push af  
2f69 3a 7d 2f			ld a, (.dmark)  
2f6c 32 a6 fd			ld (debug_mark),a  
2f6f 3a 7e 2f			ld a, (.dmark+1)  
2f72 32 a7 fd			ld (debug_mark+1),a  
2f75 3a 7f 2f			ld a, (.dmark+2)  
2f78 32 a8 fd			ld (debug_mark+2),a  
2f7b 18 03			jr .pastdmark  
2f7d ..			.dmark: db "FGm"  
2f80 f1			.pastdmark: pop af  
2f81			endm  
# End of macro DMARK
2f81					CALLMONITOR 
2f81 cd aa fd			call debug_vector  
2f84				endm  
# End of macro CALLMONITOR
2f84				endif 
2f84			 
2f84			 
2f84			 
2f84					; we have a uword so push its name to the stack 
2f84			 
2f84			;	   	push hl  ; save so we can move to next dict block 
2f84			;pop hl 
2f84			 
2f84					; update opcode to deleted 
2f84 3e 03				ld a, WORD_SYS_DELETED 
2f86 77					ld (hl), a 
2f87			 
2f87 23					inc hl  
2f88					; skip next ptr 
2f88 23					inc hl  
2f89 23					inc hl 
2f8a					; skip len 
2f8a 23					inc hl 
2f8b			 
2f8b					; TODO change parser to skip deleted words but for now mark it out 
2f8b 3e 5f				ld a, "_" 
2f8d 77					ld  (hl),a 
2f8e			 
2f8e			;		jr .fudone 
2f8e			; 
2f8e			;.fnuword:	pop hl 
2f8e			;		call forth_tok_next 
2f8e			;		jp .fdouscan  
2f8e			 
2f8e			.flunotfound:		  
2f8e			 
2f8e			 
2f8e					 
2f8e					FORTH_DSP_POP 
2f8e cd e0 22			call macro_forth_dsp_pop 
2f91				endm 
# End of macro FORTH_DSP_POP
2f91			;		ld hl, .luno 
2f91			;.fudone:		 pop hl 
2f91					NEXTW 
2f91 c3 de 23			jp macro_next 
2f94				endm 
# End of macro NEXTW
2f94			.NOP: 
2f94				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2f94 61				db WORD_SYS_CORE+77             
2f95 bb 2f			dw .COMO            
2f97 04				db 3 + 1 
2f98 .. 00			db "NOP",0              
2f9c				endm 
# End of macro CWHEAD
2f9c			; | NOP (  --  ) Do nothing | DONE 
2f9c					if DEBUG_FORTH_WORDS_KEY 
2f9c						DMARK "NOP" 
2f9c f5				push af  
2f9d 3a b1 2f			ld a, (.dmark)  
2fa0 32 a6 fd			ld (debug_mark),a  
2fa3 3a b2 2f			ld a, (.dmark+1)  
2fa6 32 a7 fd			ld (debug_mark+1),a  
2fa9 3a b3 2f			ld a, (.dmark+2)  
2fac 32 a8 fd			ld (debug_mark+2),a  
2faf 18 03			jr .pastdmark  
2fb1 ..			.dmark: db "NOP"  
2fb4 f1			.pastdmark: pop af  
2fb5			endm  
# End of macro DMARK
2fb5						CALLMONITOR 
2fb5 cd aa fd			call debug_vector  
2fb8				endm  
# End of macro CALLMONITOR
2fb8					endif 
2fb8				       NEXTW 
2fb8 c3 de 23			jp macro_next 
2fbb				endm 
# End of macro NEXTW
2fbb			.COMO: 
2fbb				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2fbb 6e				db WORD_SYS_CORE+90             
2fbc 0d 30			dw .COMC            
2fbe 02				db 1 + 1 
2fbf .. 00			db "(",0              
2fc1				endm 
# End of macro CWHEAD
2fc1			; | ( ( -- )  Start of comment | DONE 
2fc1			 
2fc1			 
2fc1 2a fd f3				ld hl, ( os_tok_ptr) 
2fc4 11 08 30			ld de, .closepar 
2fc7					 
2fc7					if DEBUG_FORTH_WORDS 
2fc7						DMARK ").." 
2fc7 f5				push af  
2fc8 3a dc 2f			ld a, (.dmark)  
2fcb 32 a6 fd			ld (debug_mark),a  
2fce 3a dd 2f			ld a, (.dmark+1)  
2fd1 32 a7 fd			ld (debug_mark+1),a  
2fd4 3a de 2f			ld a, (.dmark+2)  
2fd7 32 a8 fd			ld (debug_mark+2),a  
2fda 18 03			jr .pastdmark  
2fdc ..			.dmark: db ").."  
2fdf f1			.pastdmark: pop af  
2fe0			endm  
# End of macro DMARK
2fe0						CALLMONITOR 
2fe0 cd aa fd			call debug_vector  
2fe3				endm  
# End of macro CALLMONITOR
2fe3					endif 
2fe3 cd f9 24			call findnexttok  
2fe6			 
2fe6					if DEBUG_FORTH_WORDS 
2fe6						DMARK "IF5" 
2fe6 f5				push af  
2fe7 3a fb 2f			ld a, (.dmark)  
2fea 32 a6 fd			ld (debug_mark),a  
2fed 3a fc 2f			ld a, (.dmark+1)  
2ff0 32 a7 fd			ld (debug_mark+1),a  
2ff3 3a fd 2f			ld a, (.dmark+2)  
2ff6 32 a8 fd			ld (debug_mark+2),a  
2ff9 18 03			jr .pastdmark  
2ffb ..			.dmark: db "IF5"  
2ffe f1			.pastdmark: pop af  
2fff			endm  
# End of macro DMARK
2fff						CALLMONITOR 
2fff cd aa fd			call debug_vector  
3002				endm  
# End of macro CALLMONITOR
3002					endif 
3002				; replace below with ) exec using tok_ptr 
3002 22 fd f3			ld (os_tok_ptr), hl 
3005 c3 6f 24			jp exec1 
3008			 
3008 .. 00			.closepar:   db ")",0 
300a			 
300a				       NEXTW 
300a c3 de 23			jp macro_next 
300d				endm 
# End of macro NEXTW
300d			.COMC: 
300d				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
300d 6f				db WORD_SYS_CORE+91             
300e 16 30			dw .SCRATCH            
3010 02				db 1 + 1 
3011 .. 00			db ")",0              
3013				endm 
# End of macro CWHEAD
3013			; | ) ( -- )  End of comment |  DONE  
3013				       NEXTW 
3013 c3 de 23			jp macro_next 
3016				endm 
# End of macro NEXTW
3016			 
3016			.SCRATCH: 
3016				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3016 6f				db WORD_SYS_CORE+91             
3017 51 30			dw .INC            
3019 08				db 7 + 1 
301a .. 00			db "SCRATCH",0              
3022				endm 
# End of macro CWHEAD
3022			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3022			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3022			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3022			; | |  
3022			; | | e.g.    : score $00 scratch ; 
3022			; | |  
3022			; | | $00 score ! 
3022			; | | $01 score +! 
3022			; | |  
3022			; | | e.g.   : varword $0a scratch ;  
3022			; | | 
3022			; | | $8000 varword ! 
3022					if DEBUG_FORTH_WORDS_KEY 
3022						DMARK "SCR" 
3022 f5				push af  
3023 3a 37 30			ld a, (.dmark)  
3026 32 a6 fd			ld (debug_mark),a  
3029 3a 38 30			ld a, (.dmark+1)  
302c 32 a7 fd			ld (debug_mark+1),a  
302f 3a 39 30			ld a, (.dmark+2)  
3032 32 a8 fd			ld (debug_mark+2),a  
3035 18 03			jr .pastdmark  
3037 ..			.dmark: db "SCR"  
303a f1			.pastdmark: pop af  
303b			endm  
# End of macro DMARK
303b						CALLMONITOR 
303b cd aa fd			call debug_vector  
303e				endm  
# End of macro CALLMONITOR
303e					endif 
303e			 
303e					FORTH_DSP_VALUEHL 
303e cd 28 22			call macro_dsp_valuehl 
3041				endm 
# End of macro FORTH_DSP_VALUEHL
3041				 
3041					FORTH_DSP_POP 
3041 cd e0 22			call macro_forth_dsp_pop 
3044				endm 
# End of macro FORTH_DSP_POP
3044			 
3044 7d					ld a, l 
3045 21 21 f6				ld hl, os_var_array 
3048 cd cf 0f				call addatohl 
304b			 
304b cd 23 20				call forth_push_numhl 
304e			 
304e				       NEXTW 
304e c3 de 23			jp macro_next 
3051				endm 
# End of macro NEXTW
3051			 
3051			.INC: 
3051				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3051 6f				db WORD_SYS_CORE+91             
3052 a7 30			dw .DEC            
3054 03				db 2 + 1 
3055 .. 00			db "+!",0              
3058				endm 
# End of macro CWHEAD
3058			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3058					if DEBUG_FORTH_WORDS_KEY 
3058						DMARK "+s_" 
3058 f5				push af  
3059 3a 6d 30			ld a, (.dmark)  
305c 32 a6 fd			ld (debug_mark),a  
305f 3a 6e 30			ld a, (.dmark+1)  
3062 32 a7 fd			ld (debug_mark+1),a  
3065 3a 6f 30			ld a, (.dmark+2)  
3068 32 a8 fd			ld (debug_mark+2),a  
306b 18 03			jr .pastdmark  
306d ..			.dmark: db "+s_"  
3070 f1			.pastdmark: pop af  
3071			endm  
# End of macro DMARK
3071						CALLMONITOR 
3071 cd aa fd			call debug_vector  
3074				endm  
# End of macro CALLMONITOR
3074					endif 
3074			 
3074					FORTH_DSP_VALUEHL 
3074 cd 28 22			call macro_dsp_valuehl 
3077				endm 
# End of macro FORTH_DSP_VALUEHL
3077			 
3077 e5					push hl   ; save address 
3078			 
3078					FORTH_DSP_POP 
3078 cd e0 22			call macro_forth_dsp_pop 
307b				endm 
# End of macro FORTH_DSP_POP
307b			 
307b					FORTH_DSP_VALUEHL 
307b cd 28 22			call macro_dsp_valuehl 
307e				endm 
# End of macro FORTH_DSP_VALUEHL
307e			 
307e e5					push hl 
307f					FORTH_DSP_POP 
307f cd e0 22			call macro_forth_dsp_pop 
3082				endm 
# End of macro FORTH_DSP_POP
3082 e1					pop hl 
3083			 
3083					; hl contains value to add to byte at a 
3083				 
3083 eb					ex de, hl 
3084			 
3084 e1					pop hl 
3085			 
3085					if DEBUG_FORTH_WORDS 
3085						DMARK "INC" 
3085 f5				push af  
3086 3a 9a 30			ld a, (.dmark)  
3089 32 a6 fd			ld (debug_mark),a  
308c 3a 9b 30			ld a, (.dmark+1)  
308f 32 a7 fd			ld (debug_mark+1),a  
3092 3a 9c 30			ld a, (.dmark+2)  
3095 32 a8 fd			ld (debug_mark+2),a  
3098 18 03			jr .pastdmark  
309a ..			.dmark: db "INC"  
309d f1			.pastdmark: pop af  
309e			endm  
# End of macro DMARK
309e						CALLMONITOR 
309e cd aa fd			call debug_vector  
30a1				endm  
# End of macro CALLMONITOR
30a1					endif 
30a1			 
30a1 7e					ld a,(hl) 
30a2 83					add e 
30a3 77					ld (hl),a 
30a4			 
30a4			 
30a4			 
30a4				       NEXTW 
30a4 c3 de 23			jp macro_next 
30a7				endm 
# End of macro NEXTW
30a7			 
30a7			.DEC: 
30a7				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
30a7 6f				db WORD_SYS_CORE+91             
30a8 fb 30			dw .INC2            
30aa 03				db 2 + 1 
30ab .. 00			db "-!",0              
30ae				endm 
# End of macro CWHEAD
30ae			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
30ae					if DEBUG_FORTH_WORDS_KEY 
30ae						DMARK "-s_" 
30ae f5				push af  
30af 3a c3 30			ld a, (.dmark)  
30b2 32 a6 fd			ld (debug_mark),a  
30b5 3a c4 30			ld a, (.dmark+1)  
30b8 32 a7 fd			ld (debug_mark+1),a  
30bb 3a c5 30			ld a, (.dmark+2)  
30be 32 a8 fd			ld (debug_mark+2),a  
30c1 18 03			jr .pastdmark  
30c3 ..			.dmark: db "-s_"  
30c6 f1			.pastdmark: pop af  
30c7			endm  
# End of macro DMARK
30c7						CALLMONITOR 
30c7 cd aa fd			call debug_vector  
30ca				endm  
# End of macro CALLMONITOR
30ca					endif 
30ca			 
30ca					FORTH_DSP_VALUEHL 
30ca cd 28 22			call macro_dsp_valuehl 
30cd				endm 
# End of macro FORTH_DSP_VALUEHL
30cd			 
30cd e5					push hl   ; save address 
30ce			 
30ce					FORTH_DSP_POP 
30ce cd e0 22			call macro_forth_dsp_pop 
30d1				endm 
# End of macro FORTH_DSP_POP
30d1			 
30d1					FORTH_DSP_VALUEHL 
30d1 cd 28 22			call macro_dsp_valuehl 
30d4				endm 
# End of macro FORTH_DSP_VALUEHL
30d4			 
30d4					; hl contains value to add to byte at a 
30d4				 
30d4 eb					ex de, hl 
30d5			 
30d5 e1					pop hl 
30d6			 
30d6					if DEBUG_FORTH_WORDS 
30d6						DMARK "DEC" 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 a6 fd			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 a7 fd			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 a8 fd			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "DEC"  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef						CALLMONITOR 
30ef cd aa fd			call debug_vector  
30f2				endm  
# End of macro CALLMONITOR
30f2					endif 
30f2			 
30f2 7e					ld a,(hl) 
30f3 93					sub e 
30f4 77					ld (hl),a 
30f5			 
30f5			 
30f5					FORTH_DSP_POP 
30f5 cd e0 22			call macro_forth_dsp_pop 
30f8				endm 
# End of macro FORTH_DSP_POP
30f8			 
30f8				       NEXTW 
30f8 c3 de 23			jp macro_next 
30fb				endm 
# End of macro NEXTW
30fb			 
30fb			.INC2: 
30fb				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
30fb 6f				db WORD_SYS_CORE+91             
30fc a8 31			dw .DEC2            
30fe 04				db 3 + 1 
30ff .. 00			db "+2!",0              
3103				endm 
# End of macro CWHEAD
3103			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3103			 
3103					if DEBUG_FORTH_WORDS_KEY 
3103						DMARK "+2s" 
3103 f5				push af  
3104 3a 18 31			ld a, (.dmark)  
3107 32 a6 fd			ld (debug_mark),a  
310a 3a 19 31			ld a, (.dmark+1)  
310d 32 a7 fd			ld (debug_mark+1),a  
3110 3a 1a 31			ld a, (.dmark+2)  
3113 32 a8 fd			ld (debug_mark+2),a  
3116 18 03			jr .pastdmark  
3118 ..			.dmark: db "+2s"  
311b f1			.pastdmark: pop af  
311c			endm  
# End of macro DMARK
311c						CALLMONITOR 
311c cd aa fd			call debug_vector  
311f				endm  
# End of macro CALLMONITOR
311f					endif 
311f			 
311f					; Address 
311f			 
311f					FORTH_DSP_VALUEHL 
311f cd 28 22			call macro_dsp_valuehl 
3122				endm 
# End of macro FORTH_DSP_VALUEHL
3122			 
3122 e5					push hl    ; save address 
3123			 
3123					; load content into de 
3123			 
3123 5e					ld e,(hl) 
3124 23					inc hl 
3125 56					ld d, (hl) 
3126			 
3126					if DEBUG_FORTH_WORDS 
3126						DMARK "+2a" 
3126 f5				push af  
3127 3a 3b 31			ld a, (.dmark)  
312a 32 a6 fd			ld (debug_mark),a  
312d 3a 3c 31			ld a, (.dmark+1)  
3130 32 a7 fd			ld (debug_mark+1),a  
3133 3a 3d 31			ld a, (.dmark+2)  
3136 32 a8 fd			ld (debug_mark+2),a  
3139 18 03			jr .pastdmark  
313b ..			.dmark: db "+2a"  
313e f1			.pastdmark: pop af  
313f			endm  
# End of macro DMARK
313f						CALLMONITOR 
313f cd aa fd			call debug_vector  
3142				endm  
# End of macro CALLMONITOR
3142					endif 
3142			 
3142					FORTH_DSP_POP 
3142 cd e0 22			call macro_forth_dsp_pop 
3145				endm 
# End of macro FORTH_DSP_POP
3145			 
3145					; Get value to add 
3145			 
3145					FORTH_DSP_VALUE 
3145 cd 11 22			call macro_forth_dsp_value 
3148				endm 
# End of macro FORTH_DSP_VALUE
3148			 
3148					if DEBUG_FORTH_WORDS 
3148						DMARK "+2v" 
3148 f5				push af  
3149 3a 5d 31			ld a, (.dmark)  
314c 32 a6 fd			ld (debug_mark),a  
314f 3a 5e 31			ld a, (.dmark+1)  
3152 32 a7 fd			ld (debug_mark+1),a  
3155 3a 5f 31			ld a, (.dmark+2)  
3158 32 a8 fd			ld (debug_mark+2),a  
315b 18 03			jr .pastdmark  
315d ..			.dmark: db "+2v"  
3160 f1			.pastdmark: pop af  
3161			endm  
# End of macro DMARK
3161						CALLMONITOR 
3161 cd aa fd			call debug_vector  
3164				endm  
# End of macro CALLMONITOR
3164					endif 
3164			 
3164 19					add hl, de 
3165			 
3165					if DEBUG_FORTH_WORDS 
3165						DMARK "+2+" 
3165 f5				push af  
3166 3a 7a 31			ld a, (.dmark)  
3169 32 a6 fd			ld (debug_mark),a  
316c 3a 7b 31			ld a, (.dmark+1)  
316f 32 a7 fd			ld (debug_mark+1),a  
3172 3a 7c 31			ld a, (.dmark+2)  
3175 32 a8 fd			ld (debug_mark+2),a  
3178 18 03			jr .pastdmark  
317a ..			.dmark: db "+2+"  
317d f1			.pastdmark: pop af  
317e			endm  
# End of macro DMARK
317e						CALLMONITOR 
317e cd aa fd			call debug_vector  
3181				endm  
# End of macro CALLMONITOR
3181					endif 
3181			 
3181					; move result to de 
3181			 
3181 eb					ex de, hl 
3182			 
3182					; Address 
3182			 
3182 e1					pop hl 
3183			 
3183					; save it back 
3183			 
3183 73					ld (hl), e 
3184 23					inc hl 
3185 72					ld (hl), d 
3186			 
3186					if DEBUG_FORTH_WORDS 
3186						DMARK "+2e" 
3186 f5				push af  
3187 3a 9b 31			ld a, (.dmark)  
318a 32 a6 fd			ld (debug_mark),a  
318d 3a 9c 31			ld a, (.dmark+1)  
3190 32 a7 fd			ld (debug_mark+1),a  
3193 3a 9d 31			ld a, (.dmark+2)  
3196 32 a8 fd			ld (debug_mark+2),a  
3199 18 03			jr .pastdmark  
319b ..			.dmark: db "+2e"  
319e f1			.pastdmark: pop af  
319f			endm  
# End of macro DMARK
319f						CALLMONITOR 
319f cd aa fd			call debug_vector  
31a2				endm  
# End of macro CALLMONITOR
31a2					endif 
31a2			 
31a2			 
31a2			 
31a2					FORTH_DSP_POP 
31a2 cd e0 22			call macro_forth_dsp_pop 
31a5				endm 
# End of macro FORTH_DSP_POP
31a5			 
31a5			 
31a5				       NEXTW 
31a5 c3 de 23			jp macro_next 
31a8				endm 
# End of macro NEXTW
31a8			 
31a8			.DEC2: 
31a8				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
31a8 6f				db WORD_SYS_CORE+91             
31a9 57 32			dw .GET2            
31ab 04				db 3 + 1 
31ac .. 00			db "-2!",0              
31b0				endm 
# End of macro CWHEAD
31b0			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
31b0			 
31b0			 
31b0					if DEBUG_FORTH_WORDS_KEY 
31b0						DMARK "-2s" 
31b0 f5				push af  
31b1 3a c5 31			ld a, (.dmark)  
31b4 32 a6 fd			ld (debug_mark),a  
31b7 3a c6 31			ld a, (.dmark+1)  
31ba 32 a7 fd			ld (debug_mark+1),a  
31bd 3a c7 31			ld a, (.dmark+2)  
31c0 32 a8 fd			ld (debug_mark+2),a  
31c3 18 03			jr .pastdmark  
31c5 ..			.dmark: db "-2s"  
31c8 f1			.pastdmark: pop af  
31c9			endm  
# End of macro DMARK
31c9						CALLMONITOR 
31c9 cd aa fd			call debug_vector  
31cc				endm  
# End of macro CALLMONITOR
31cc					endif 
31cc			 
31cc					; Address 
31cc			 
31cc					FORTH_DSP_VALUEHL 
31cc cd 28 22			call macro_dsp_valuehl 
31cf				endm 
# End of macro FORTH_DSP_VALUEHL
31cf			 
31cf e5					push hl    ; save address 
31d0			 
31d0					; load content into de 
31d0			 
31d0 5e					ld e,(hl) 
31d1 23					inc hl 
31d2 56					ld d, (hl) 
31d3			 
31d3					if DEBUG_FORTH_WORDS 
31d3						DMARK "-2a" 
31d3 f5				push af  
31d4 3a e8 31			ld a, (.dmark)  
31d7 32 a6 fd			ld (debug_mark),a  
31da 3a e9 31			ld a, (.dmark+1)  
31dd 32 a7 fd			ld (debug_mark+1),a  
31e0 3a ea 31			ld a, (.dmark+2)  
31e3 32 a8 fd			ld (debug_mark+2),a  
31e6 18 03			jr .pastdmark  
31e8 ..			.dmark: db "-2a"  
31eb f1			.pastdmark: pop af  
31ec			endm  
# End of macro DMARK
31ec						CALLMONITOR 
31ec cd aa fd			call debug_vector  
31ef				endm  
# End of macro CALLMONITOR
31ef					endif 
31ef			 
31ef					FORTH_DSP_POP 
31ef cd e0 22			call macro_forth_dsp_pop 
31f2				endm 
# End of macro FORTH_DSP_POP
31f2			 
31f2					; Get value to remove 
31f2			 
31f2					FORTH_DSP_VALUE 
31f2 cd 11 22			call macro_forth_dsp_value 
31f5				endm 
# End of macro FORTH_DSP_VALUE
31f5			 
31f5					if DEBUG_FORTH_WORDS 
31f5						DMARK "-2v" 
31f5 f5				push af  
31f6 3a 0a 32			ld a, (.dmark)  
31f9 32 a6 fd			ld (debug_mark),a  
31fc 3a 0b 32			ld a, (.dmark+1)  
31ff 32 a7 fd			ld (debug_mark+1),a  
3202 3a 0c 32			ld a, (.dmark+2)  
3205 32 a8 fd			ld (debug_mark+2),a  
3208 18 03			jr .pastdmark  
320a ..			.dmark: db "-2v"  
320d f1			.pastdmark: pop af  
320e			endm  
# End of macro DMARK
320e						CALLMONITOR 
320e cd aa fd			call debug_vector  
3211				endm  
# End of macro CALLMONITOR
3211					endif 
3211			 
3211 eb					ex de, hl 
3212 ed 52				sbc hl, de 
3214			 
3214					if DEBUG_FORTH_WORDS 
3214						DMARK "-2d" 
3214 f5				push af  
3215 3a 29 32			ld a, (.dmark)  
3218 32 a6 fd			ld (debug_mark),a  
321b 3a 2a 32			ld a, (.dmark+1)  
321e 32 a7 fd			ld (debug_mark+1),a  
3221 3a 2b 32			ld a, (.dmark+2)  
3224 32 a8 fd			ld (debug_mark+2),a  
3227 18 03			jr .pastdmark  
3229 ..			.dmark: db "-2d"  
322c f1			.pastdmark: pop af  
322d			endm  
# End of macro DMARK
322d						CALLMONITOR 
322d cd aa fd			call debug_vector  
3230				endm  
# End of macro CALLMONITOR
3230					endif 
3230			 
3230					; move result to de 
3230			 
3230 eb					ex de, hl 
3231			 
3231					; Address 
3231			 
3231 e1					pop hl 
3232			 
3232					; save it back 
3232			 
3232 73					ld (hl), e 
3233 23					inc hl 
3234 72					ld (hl), d 
3235			 
3235					if DEBUG_FORTH_WORDS 
3235						DMARK "-2e" 
3235 f5				push af  
3236 3a 4a 32			ld a, (.dmark)  
3239 32 a6 fd			ld (debug_mark),a  
323c 3a 4b 32			ld a, (.dmark+1)  
323f 32 a7 fd			ld (debug_mark+1),a  
3242 3a 4c 32			ld a, (.dmark+2)  
3245 32 a8 fd			ld (debug_mark+2),a  
3248 18 03			jr .pastdmark  
324a ..			.dmark: db "-2e"  
324d f1			.pastdmark: pop af  
324e			endm  
# End of macro DMARK
324e						CALLMONITOR 
324e cd aa fd			call debug_vector  
3251				endm  
# End of macro CALLMONITOR
3251					endif 
3251			 
3251			 
3251					FORTH_DSP_POP 
3251 cd e0 22			call macro_forth_dsp_pop 
3254				endm 
# End of macro FORTH_DSP_POP
3254			 
3254			 
3254			 
3254				       NEXTW 
3254 c3 de 23			jp macro_next 
3257				endm 
# End of macro NEXTW
3257			.GET2: 
3257				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3257 6f				db WORD_SYS_CORE+91             
3258 8c 32			dw .BANG2            
325a 03				db 2 + 1 
325b .. 00			db "2@",0              
325e				endm 
# End of macro CWHEAD
325e			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
325e					if DEBUG_FORTH_WORDS_KEY 
325e						DMARK "2A_" 
325e f5				push af  
325f 3a 73 32			ld a, (.dmark)  
3262 32 a6 fd			ld (debug_mark),a  
3265 3a 74 32			ld a, (.dmark+1)  
3268 32 a7 fd			ld (debug_mark+1),a  
326b 3a 75 32			ld a, (.dmark+2)  
326e 32 a8 fd			ld (debug_mark+2),a  
3271 18 03			jr .pastdmark  
3273 ..			.dmark: db "2A_"  
3276 f1			.pastdmark: pop af  
3277			endm  
# End of macro DMARK
3277						CALLMONITOR 
3277 cd aa fd			call debug_vector  
327a				endm  
# End of macro CALLMONITOR
327a					endif 
327a			 
327a					FORTH_DSP_VALUEHL 
327a cd 28 22			call macro_dsp_valuehl 
327d				endm 
# End of macro FORTH_DSP_VALUEHL
327d			 
327d e5					push hl   ; save address 
327e			 
327e					FORTH_DSP_POP 
327e cd e0 22			call macro_forth_dsp_pop 
3281				endm 
# End of macro FORTH_DSP_POP
3281			 
3281 e1					pop hl 
3282			 
3282 5e					ld e, (hl) 
3283 23					inc hl 
3284 56					ld d, (hl) 
3285			 
3285 eb					ex de, hl 
3286			 
3286 cd 23 20				call forth_push_numhl 
3289			 
3289				       NEXTW 
3289 c3 de 23			jp macro_next 
328c				endm 
# End of macro NEXTW
328c			.BANG2: 
328c				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
328c 6f				db WORD_SYS_CORE+91             
328d c4 32			dw .CONFIG            
328f 03				db 2 + 1 
3290 .. 00			db "2!",0              
3293				endm 
# End of macro CWHEAD
3293			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3293					if DEBUG_FORTH_WORDS_KEY 
3293						DMARK "2S_" 
3293 f5				push af  
3294 3a a8 32			ld a, (.dmark)  
3297 32 a6 fd			ld (debug_mark),a  
329a 3a a9 32			ld a, (.dmark+1)  
329d 32 a7 fd			ld (debug_mark+1),a  
32a0 3a aa 32			ld a, (.dmark+2)  
32a3 32 a8 fd			ld (debug_mark+2),a  
32a6 18 03			jr .pastdmark  
32a8 ..			.dmark: db "2S_"  
32ab f1			.pastdmark: pop af  
32ac			endm  
# End of macro DMARK
32ac						CALLMONITOR 
32ac cd aa fd			call debug_vector  
32af				endm  
# End of macro CALLMONITOR
32af					endif 
32af			 
32af					FORTH_DSP_VALUEHL 
32af cd 28 22			call macro_dsp_valuehl 
32b2				endm 
# End of macro FORTH_DSP_VALUEHL
32b2			 
32b2 e5					push hl   ; save address 
32b3			 
32b3			 
32b3					FORTH_DSP_POP 
32b3 cd e0 22			call macro_forth_dsp_pop 
32b6				endm 
# End of macro FORTH_DSP_POP
32b6			 
32b6					 
32b6					FORTH_DSP_VALUEHL 
32b6 cd 28 22			call macro_dsp_valuehl 
32b9				endm 
# End of macro FORTH_DSP_VALUEHL
32b9			 
32b9					FORTH_DSP_POP 
32b9 cd e0 22			call macro_forth_dsp_pop 
32bc				endm 
# End of macro FORTH_DSP_POP
32bc			 
32bc eb					ex de, hl    ; value now in de 
32bd			 
32bd e1					pop hl 
32be			 
32be 73					ld (hl), e 
32bf			 
32bf 23					inc hl 
32c0			 
32c0 72					ld (hl), d 
32c1			 
32c1			 
32c1				       NEXTW 
32c1 c3 de 23			jp macro_next 
32c4				endm 
# End of macro NEXTW
32c4			.CONFIG: 
32c4				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
32c4 6f				db WORD_SYS_CORE+91             
32c5 d5 32			dw .ADTOS            
32c7 07				db 6 + 1 
32c8 .. 00			db "CONFIG",0              
32cf				endm 
# End of macro CWHEAD
32cf			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
32cf			 
32cf cd 43 15				call config 
32d2					NEXTW 
32d2 c3 de 23			jp macro_next 
32d5				endm 
# End of macro NEXTW
32d5			 
32d5			.ADTOS: 
32d5				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
32d5 6f				db WORD_SYS_CORE+91             
32d6 eb 32			dw .SBTOS            
32d8 03				db 2 + 1 
32d9 .. 00			db "1+",0              
32dc				endm 
# End of macro CWHEAD
32dc			; | 1+ ( u -- u )  Increment value on TOS | DONE 
32dc			 
32dc					FORTH_DSP_VALUEHL 
32dc cd 28 22			call macro_dsp_valuehl 
32df				endm 
# End of macro FORTH_DSP_VALUEHL
32df e5					push hl 
32e0			 
32e0					FORTH_DSP_POP 
32e0 cd e0 22			call macro_forth_dsp_pop 
32e3				endm 
# End of macro FORTH_DSP_POP
32e3 e1					pop hl 
32e4			 
32e4 23					inc hl 
32e5 cd 23 20				call forth_push_numhl 
32e8					 
32e8					NEXTW 
32e8 c3 de 23			jp macro_next 
32eb				endm 
# End of macro NEXTW
32eb			.SBTOS: 
32eb				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
32eb 6f				db WORD_SYS_CORE+91             
32ec 01 33			dw .ADSTORE            
32ee 03				db 2 + 1 
32ef .. 00			db "1-",0              
32f2				endm 
# End of macro CWHEAD
32f2			; | 1- ( u -- u )  Decrement value on TOS | DONE 
32f2			 
32f2					FORTH_DSP_VALUEHL 
32f2 cd 28 22			call macro_dsp_valuehl 
32f5				endm 
# End of macro FORTH_DSP_VALUEHL
32f5 e5					push hl 
32f6			 
32f6					FORTH_DSP_POP 
32f6 cd e0 22			call macro_forth_dsp_pop 
32f9				endm 
# End of macro FORTH_DSP_POP
32f9 e1					pop hl 
32fa			 
32fa 2b					dec hl 
32fb cd 23 20				call forth_push_numhl 
32fe					 
32fe					NEXTW 
32fe c3 de 23			jp macro_next 
3301				endm 
# End of macro NEXTW
3301			.ADSTORE: 
3301				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3301 6f				db WORD_SYS_CORE+91             
3302 17 33			dw .ADWSTORE            
3304 04				db 3 + 1 
3305 .. 00			db "1+!",0              
3309				endm 
# End of macro CWHEAD
3309			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3309			 
3309					FORTH_DSP_VALUEHL 
3309 cd 28 22			call macro_dsp_valuehl 
330c				endm 
# End of macro FORTH_DSP_VALUEHL
330c e5					push hl 
330d			 
330d					FORTH_DSP_POP 
330d cd e0 22			call macro_forth_dsp_pop 
3310				endm 
# End of macro FORTH_DSP_POP
3310 e1					pop hl 
3311			 
3311 7e					ld a, (hl) 
3312 3c					inc a 
3313 77					ld (hl), a 
3314					 
3314					NEXTW 
3314 c3 de 23			jp macro_next 
3317				endm 
# End of macro NEXTW
3317			.ADWSTORE: 
3317				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3317 6f				db WORD_SYS_CORE+91             
3318 35 33			dw .SBSTORE            
331a 05				db 4 + 1 
331b .. 00			db "1+2!",0              
3320				endm 
# End of macro CWHEAD
3320			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3320			 
3320					FORTH_DSP_VALUEHL 
3320 cd 28 22			call macro_dsp_valuehl 
3323				endm 
# End of macro FORTH_DSP_VALUEHL
3323 e5					push hl 
3324			 
3324					FORTH_DSP_POP 
3324 cd e0 22			call macro_forth_dsp_pop 
3327				endm 
# End of macro FORTH_DSP_POP
3327 e1					pop hl 
3328			 
3328 e5					push hl 
3329			 
3329 cd 60 23				call loadwordinhl 
332c 23					inc hl 
332d			 
332d d1					pop de 
332e eb					ex de, hl 
332f 73					ld (hl), e 
3330 23					inc hl 
3331 72					ld (hl), d 
3332					 
3332					NEXTW 
3332 c3 de 23			jp macro_next 
3335				endm 
# End of macro NEXTW
3335			.SBSTORE: 
3335				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3335 6f				db WORD_SYS_CORE+91             
3336 4b 33			dw .SBWSTORE            
3338 04				db 3 + 1 
3339 .. 00			db "1-!",0              
333d				endm 
# End of macro CWHEAD
333d			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
333d			 
333d					FORTH_DSP_VALUEHL 
333d cd 28 22			call macro_dsp_valuehl 
3340				endm 
# End of macro FORTH_DSP_VALUEHL
3340 e5					push hl 
3341			 
3341					FORTH_DSP_POP 
3341 cd e0 22			call macro_forth_dsp_pop 
3344				endm 
# End of macro FORTH_DSP_POP
3344 e1					pop hl 
3345			 
3345 7e					ld a, (hl) 
3346 3d					dec a 
3347 77					ld (hl), a 
3348					 
3348					NEXTW 
3348 c3 de 23			jp macro_next 
334b				endm 
# End of macro NEXTW
334b			.SBWSTORE: 
334b				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
334b 6f				db WORD_SYS_CORE+91             
334c 69 33			dw .ENDCORE            
334e 05				db 4 + 1 
334f .. 00			db "1-2!",0              
3354				endm 
# End of macro CWHEAD
3354			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3354			 
3354					FORTH_DSP_VALUEHL 
3354 cd 28 22			call macro_dsp_valuehl 
3357				endm 
# End of macro FORTH_DSP_VALUEHL
3357 e5					push hl 
3358			 
3358					FORTH_DSP_POP 
3358 cd e0 22			call macro_forth_dsp_pop 
335b				endm 
# End of macro FORTH_DSP_POP
335b e1					pop hl 
335c			 
335c e5					push hl 
335d			 
335d cd 60 23				call loadwordinhl 
3360 2b					dec hl 
3361			 
3361 d1					pop de 
3362 eb					ex de, hl 
3363 73					ld (hl), e 
3364 23					inc hl 
3365 72					ld (hl), d 
3366					 
3366					NEXTW 
3366 c3 de 23			jp macro_next 
3369				endm 
# End of macro NEXTW
3369			.ENDCORE: 
3369			 
3369			; eof 
3369			 
3369			 
# End of file forth_words_core.asm
3369			include "forth_words_flow.asm" 
3369			 
3369			; | ## Program Flow Words 
3369			 
3369			.IF: 
3369				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3369 1e				db WORD_SYS_CORE+10             
336a 5e 34			dw .THEN            
336c 03				db 2 + 1 
336d .. 00			db "IF",0              
3370				endm 
# End of macro CWHEAD
3370			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3370			; 
3370					if DEBUG_FORTH_WORDS_KEY 
3370						DMARK "IF." 
3370 f5				push af  
3371 3a 85 33			ld a, (.dmark)  
3374 32 a6 fd			ld (debug_mark),a  
3377 3a 86 33			ld a, (.dmark+1)  
337a 32 a7 fd			ld (debug_mark+1),a  
337d 3a 87 33			ld a, (.dmark+2)  
3380 32 a8 fd			ld (debug_mark+2),a  
3383 18 03			jr .pastdmark  
3385 ..			.dmark: db "IF."  
3388 f1			.pastdmark: pop af  
3389			endm  
# End of macro DMARK
3389						CALLMONITOR 
3389 cd aa fd			call debug_vector  
338c				endm  
# End of macro CALLMONITOR
338c					endif 
338c			; eval TOS 
338c			 
338c				FORTH_DSP_VALUEHL 
338c cd 28 22			call macro_dsp_valuehl 
338f				endm 
# End of macro FORTH_DSP_VALUEHL
338f			 
338f			;	push hl 
338f				FORTH_DSP_POP 
338f cd e0 22			call macro_forth_dsp_pop 
3392				endm 
# End of macro FORTH_DSP_POP
3392			;	pop hl 
3392			 
3392					if DEBUG_FORTH_WORDS 
3392						DMARK "IF1" 
3392 f5				push af  
3393 3a a7 33			ld a, (.dmark)  
3396 32 a6 fd			ld (debug_mark),a  
3399 3a a8 33			ld a, (.dmark+1)  
339c 32 a7 fd			ld (debug_mark+1),a  
339f 3a a9 33			ld a, (.dmark+2)  
33a2 32 a8 fd			ld (debug_mark+2),a  
33a5 18 03			jr .pastdmark  
33a7 ..			.dmark: db "IF1"  
33aa f1			.pastdmark: pop af  
33ab			endm  
# End of macro DMARK
33ab						CALLMONITOR 
33ab cd aa fd			call debug_vector  
33ae				endm  
# End of macro CALLMONITOR
33ae					endif 
33ae b7				or a        ; clear carry flag 
33af 11 00 00			ld de, 0 
33b2 eb				ex de,hl 
33b3 ed 52			sbc hl, de 
33b5 c2 3f 34			jp nz, .iftrue 
33b8			 
33b8					if DEBUG_FORTH_WORDS 
33b8						DMARK "IF2" 
33b8 f5				push af  
33b9 3a cd 33			ld a, (.dmark)  
33bc 32 a6 fd			ld (debug_mark),a  
33bf 3a ce 33			ld a, (.dmark+1)  
33c2 32 a7 fd			ld (debug_mark+1),a  
33c5 3a cf 33			ld a, (.dmark+2)  
33c8 32 a8 fd			ld (debug_mark+2),a  
33cb 18 03			jr .pastdmark  
33cd ..			.dmark: db "IF2"  
33d0 f1			.pastdmark: pop af  
33d1			endm  
# End of macro DMARK
33d1						CALLMONITOR 
33d1 cd aa fd			call debug_vector  
33d4				endm  
# End of macro CALLMONITOR
33d4					endif 
33d4			 
33d4			; if not true then skip to THEN 
33d4			 
33d4				; TODO get tok_ptr 
33d4				; TODO consume toks until we get to THEN 
33d4			 
33d4 2a fd f3			ld hl, (os_tok_ptr) 
33d7					if DEBUG_FORTH_WORDS 
33d7						DMARK "IF3" 
33d7 f5				push af  
33d8 3a ec 33			ld a, (.dmark)  
33db 32 a6 fd			ld (debug_mark),a  
33de 3a ed 33			ld a, (.dmark+1)  
33e1 32 a7 fd			ld (debug_mark+1),a  
33e4 3a ee 33			ld a, (.dmark+2)  
33e7 32 a8 fd			ld (debug_mark+2),a  
33ea 18 03			jr .pastdmark  
33ec ..			.dmark: db "IF3"  
33ef f1			.pastdmark: pop af  
33f0			endm  
# End of macro DMARK
33f0						CALLMONITOR 
33f0 cd aa fd			call debug_vector  
33f3				endm  
# End of macro CALLMONITOR
33f3						 
33f3					endif 
33f3 11 3a 34			ld de, .ifthen 
33f6					if DEBUG_FORTH_WORDS 
33f6						DMARK "IF4" 
33f6 f5				push af  
33f7 3a 0b 34			ld a, (.dmark)  
33fa 32 a6 fd			ld (debug_mark),a  
33fd 3a 0c 34			ld a, (.dmark+1)  
3400 32 a7 fd			ld (debug_mark+1),a  
3403 3a 0d 34			ld a, (.dmark+2)  
3406 32 a8 fd			ld (debug_mark+2),a  
3409 18 03			jr .pastdmark  
340b ..			.dmark: db "IF4"  
340e f1			.pastdmark: pop af  
340f			endm  
# End of macro DMARK
340f						CALLMONITOR 
340f cd aa fd			call debug_vector  
3412				endm  
# End of macro CALLMONITOR
3412					endif 
3412 cd f9 24			call findnexttok  
3415			 
3415					if DEBUG_FORTH_WORDS 
3415						DMARK "IF5" 
3415 f5				push af  
3416 3a 2a 34			ld a, (.dmark)  
3419 32 a6 fd			ld (debug_mark),a  
341c 3a 2b 34			ld a, (.dmark+1)  
341f 32 a7 fd			ld (debug_mark+1),a  
3422 3a 2c 34			ld a, (.dmark+2)  
3425 32 a8 fd			ld (debug_mark+2),a  
3428 18 03			jr .pastdmark  
342a ..			.dmark: db "IF5"  
342d f1			.pastdmark: pop af  
342e			endm  
# End of macro DMARK
342e						CALLMONITOR 
342e cd aa fd			call debug_vector  
3431				endm  
# End of macro CALLMONITOR
3431					endif 
3431				; TODO replace below with ; exec using tok_ptr 
3431 22 fd f3			ld (os_tok_ptr), hl 
3434 c3 6f 24			jp exec1 
3437				NEXTW 
3437 c3 de 23			jp macro_next 
343a				endm 
# End of macro NEXTW
343a			 
343a .. 00		.ifthen:  db "THEN",0 
343f			 
343f			.iftrue:		 
343f				; Exec next words normally 
343f			 
343f				; if true then exec following IF as normal 
343f					if DEBUG_FORTH_WORDS 
343f						DMARK "IFT" 
343f f5				push af  
3440 3a 54 34			ld a, (.dmark)  
3443 32 a6 fd			ld (debug_mark),a  
3446 3a 55 34			ld a, (.dmark+1)  
3449 32 a7 fd			ld (debug_mark+1),a  
344c 3a 56 34			ld a, (.dmark+2)  
344f 32 a8 fd			ld (debug_mark+2),a  
3452 18 03			jr .pastdmark  
3454 ..			.dmark: db "IFT"  
3457 f1			.pastdmark: pop af  
3458			endm  
# End of macro DMARK
3458						CALLMONITOR 
3458 cd aa fd			call debug_vector  
345b				endm  
# End of macro CALLMONITOR
345b					endif 
345b			 
345b					NEXTW 
345b c3 de 23			jp macro_next 
345e				endm 
# End of macro NEXTW
345e			.THEN: 
345e				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
345e 1f				db WORD_SYS_CORE+11             
345f 86 34			dw .ELSE            
3461 05				db 4 + 1 
3462 .. 00			db "THEN",0              
3467				endm 
# End of macro CWHEAD
3467			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3467					if DEBUG_FORTH_WORDS_KEY 
3467						DMARK "THN" 
3467 f5				push af  
3468 3a 7c 34			ld a, (.dmark)  
346b 32 a6 fd			ld (debug_mark),a  
346e 3a 7d 34			ld a, (.dmark+1)  
3471 32 a7 fd			ld (debug_mark+1),a  
3474 3a 7e 34			ld a, (.dmark+2)  
3477 32 a8 fd			ld (debug_mark+2),a  
347a 18 03			jr .pastdmark  
347c ..			.dmark: db "THN"  
347f f1			.pastdmark: pop af  
3480			endm  
# End of macro DMARK
3480						CALLMONITOR 
3480 cd aa fd			call debug_vector  
3483				endm  
# End of macro CALLMONITOR
3483					endif 
3483					NEXTW 
3483 c3 de 23			jp macro_next 
3486				endm 
# End of macro NEXTW
3486			.ELSE: 
3486				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3486 20				db WORD_SYS_CORE+12             
3487 ae 34			dw .DO            
3489 03				db 2 + 1 
348a .. 00			db "ELSE",0              
348f				endm 
# End of macro CWHEAD
348f			; | ELSE ( -- ) Not supported - does nothing | TODO 
348f			 
348f					if DEBUG_FORTH_WORDS_KEY 
348f						DMARK "ELS" 
348f f5				push af  
3490 3a a4 34			ld a, (.dmark)  
3493 32 a6 fd			ld (debug_mark),a  
3496 3a a5 34			ld a, (.dmark+1)  
3499 32 a7 fd			ld (debug_mark+1),a  
349c 3a a6 34			ld a, (.dmark+2)  
349f 32 a8 fd			ld (debug_mark+2),a  
34a2 18 03			jr .pastdmark  
34a4 ..			.dmark: db "ELS"  
34a7 f1			.pastdmark: pop af  
34a8			endm  
# End of macro DMARK
34a8						CALLMONITOR 
34a8 cd aa fd			call debug_vector  
34ab				endm  
# End of macro CALLMONITOR
34ab					endif 
34ab			 
34ab			 
34ab					NEXTW 
34ab c3 de 23			jp macro_next 
34ae				endm 
# End of macro NEXTW
34ae			.DO: 
34ae				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34ae 21				db WORD_SYS_CORE+13             
34af d5 35			dw .LOOP            
34b1 03				db 2 + 1 
34b2 .. 00			db "DO",0              
34b5				endm 
# End of macro CWHEAD
34b5			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34b5			 
34b5					if DEBUG_FORTH_WORDS_KEY 
34b5						DMARK "DO." 
34b5 f5				push af  
34b6 3a ca 34			ld a, (.dmark)  
34b9 32 a6 fd			ld (debug_mark),a  
34bc 3a cb 34			ld a, (.dmark+1)  
34bf 32 a7 fd			ld (debug_mark+1),a  
34c2 3a cc 34			ld a, (.dmark+2)  
34c5 32 a8 fd			ld (debug_mark+2),a  
34c8 18 03			jr .pastdmark  
34ca ..			.dmark: db "DO."  
34cd f1			.pastdmark: pop af  
34ce			endm  
# End of macro DMARK
34ce						CALLMONITOR 
34ce cd aa fd			call debug_vector  
34d1				endm  
# End of macro CALLMONITOR
34d1					endif 
34d1			;  push pc to rsp stack past the DO 
34d1			 
34d1 2a fd f3				ld hl, (os_tok_ptr) 
34d4 23					inc hl   ; D 
34d5 23					inc hl  ; O 
34d6 23					inc hl   ; null 
34d7					if DEBUG_FORTH_WORDS 
34d7						DMARK "DO2" 
34d7 f5				push af  
34d8 3a ec 34			ld a, (.dmark)  
34db 32 a6 fd			ld (debug_mark),a  
34de 3a ed 34			ld a, (.dmark+1)  
34e1 32 a7 fd			ld (debug_mark+1),a  
34e4 3a ee 34			ld a, (.dmark+2)  
34e7 32 a8 fd			ld (debug_mark+2),a  
34ea 18 03			jr .pastdmark  
34ec ..			.dmark: db "DO2"  
34ef f1			.pastdmark: pop af  
34f0			endm  
# End of macro DMARK
34f0						CALLMONITOR 
34f0 cd aa fd			call debug_vector  
34f3				endm  
# End of macro CALLMONITOR
34f3					endif 
34f3					FORTH_RSP_NEXT 
34f3 cd ca 1f			call macro_forth_rsp_next 
34f6				endm 
# End of macro FORTH_RSP_NEXT
34f6					if DEBUG_FORTH_WORDS 
34f6						DMARK "DO3" 
34f6 f5				push af  
34f7 3a 0b 35			ld a, (.dmark)  
34fa 32 a6 fd			ld (debug_mark),a  
34fd 3a 0c 35			ld a, (.dmark+1)  
3500 32 a7 fd			ld (debug_mark+1),a  
3503 3a 0d 35			ld a, (.dmark+2)  
3506 32 a8 fd			ld (debug_mark+2),a  
3509 18 03			jr .pastdmark  
350b ..			.dmark: db "DO3"  
350e f1			.pastdmark: pop af  
350f			endm  
# End of macro DMARK
350f						CALLMONITOR 
350f cd aa fd			call debug_vector  
3512				endm  
# End of macro CALLMONITOR
3512					endif 
3512			 
3512					;if DEBUG_FORTH_WORDS 
3512				;		push hl 
3512			;		endif  
3512			 
3512			; get counters from data stack 
3512			 
3512			 
3512					FORTH_DSP_VALUEHL 
3512 cd 28 22			call macro_dsp_valuehl 
3515				endm 
# End of macro FORTH_DSP_VALUEHL
3515 e5					push hl		 ; hl now has starting counter which needs to be tos 
3516			 
3516					if DEBUG_FORTH_WORDS 
3516						DMARK "DO4" 
3516 f5				push af  
3517 3a 2b 35			ld a, (.dmark)  
351a 32 a6 fd			ld (debug_mark),a  
351d 3a 2c 35			ld a, (.dmark+1)  
3520 32 a7 fd			ld (debug_mark+1),a  
3523 3a 2d 35			ld a, (.dmark+2)  
3526 32 a8 fd			ld (debug_mark+2),a  
3529 18 03			jr .pastdmark  
352b ..			.dmark: db "DO4"  
352e f1			.pastdmark: pop af  
352f			endm  
# End of macro DMARK
352f						CALLMONITOR 
352f cd aa fd			call debug_vector  
3532				endm  
# End of macro CALLMONITOR
3532					endif 
3532					FORTH_DSP_POP 
3532 cd e0 22			call macro_forth_dsp_pop 
3535				endm 
# End of macro FORTH_DSP_POP
3535			 
3535					if DEBUG_FORTH_WORDS 
3535						DMARK "DO5" 
3535 f5				push af  
3536 3a 4a 35			ld a, (.dmark)  
3539 32 a6 fd			ld (debug_mark),a  
353c 3a 4b 35			ld a, (.dmark+1)  
353f 32 a7 fd			ld (debug_mark+1),a  
3542 3a 4c 35			ld a, (.dmark+2)  
3545 32 a8 fd			ld (debug_mark+2),a  
3548 18 03			jr .pastdmark  
354a ..			.dmark: db "DO5"  
354d f1			.pastdmark: pop af  
354e			endm  
# End of macro DMARK
354e						CALLMONITOR 
354e cd aa fd			call debug_vector  
3551				endm  
# End of macro CALLMONITOR
3551					endif 
3551			 
3551					FORTH_DSP_VALUEHL 
3551 cd 28 22			call macro_dsp_valuehl 
3554				endm 
# End of macro FORTH_DSP_VALUEHL
3554			;		push hl		 ; hl now has starting limit counter 
3554			 
3554					if DEBUG_FORTH_WORDS 
3554						DMARK "DO6" 
3554 f5				push af  
3555 3a 69 35			ld a, (.dmark)  
3558 32 a6 fd			ld (debug_mark),a  
355b 3a 6a 35			ld a, (.dmark+1)  
355e 32 a7 fd			ld (debug_mark+1),a  
3561 3a 6b 35			ld a, (.dmark+2)  
3564 32 a8 fd			ld (debug_mark+2),a  
3567 18 03			jr .pastdmark  
3569 ..			.dmark: db "DO6"  
356c f1			.pastdmark: pop af  
356d			endm  
# End of macro DMARK
356d						CALLMONITOR 
356d cd aa fd			call debug_vector  
3570				endm  
# End of macro CALLMONITOR
3570					endif 
3570					FORTH_DSP_POP 
3570 cd e0 22			call macro_forth_dsp_pop 
3573				endm 
# End of macro FORTH_DSP_POP
3573			 
3573			; put counters on the loop stack 
3573			 
3573			;		pop hl			 ; limit counter 
3573 d1					pop de			; start counter 
3574			 
3574					; push limit counter 
3574			 
3574					if DEBUG_FORTH_WORDS 
3574						DMARK "DO7" 
3574 f5				push af  
3575 3a 89 35			ld a, (.dmark)  
3578 32 a6 fd			ld (debug_mark),a  
357b 3a 8a 35			ld a, (.dmark+1)  
357e 32 a7 fd			ld (debug_mark+1),a  
3581 3a 8b 35			ld a, (.dmark+2)  
3584 32 a8 fd			ld (debug_mark+2),a  
3587 18 03			jr .pastdmark  
3589 ..			.dmark: db "DO7"  
358c f1			.pastdmark: pop af  
358d			endm  
# End of macro DMARK
358d						CALLMONITOR 
358d cd aa fd			call debug_vector  
3590				endm  
# End of macro CALLMONITOR
3590					endif 
3590					FORTH_LOOP_NEXT 
3590 cd 59 22			call macro_forth_loop_next 
3593				endm 
# End of macro FORTH_LOOP_NEXT
3593			 
3593					; push start counter 
3593			 
3593 eb					ex de, hl 
3594					if DEBUG_FORTH_WORDS 
3594						DMARK "DO7" 
3594 f5				push af  
3595 3a a9 35			ld a, (.dmark)  
3598 32 a6 fd			ld (debug_mark),a  
359b 3a aa 35			ld a, (.dmark+1)  
359e 32 a7 fd			ld (debug_mark+1),a  
35a1 3a ab 35			ld a, (.dmark+2)  
35a4 32 a8 fd			ld (debug_mark+2),a  
35a7 18 03			jr .pastdmark  
35a9 ..			.dmark: db "DO7"  
35ac f1			.pastdmark: pop af  
35ad			endm  
# End of macro DMARK
35ad						CALLMONITOR 
35ad cd aa fd			call debug_vector  
35b0				endm  
# End of macro CALLMONITOR
35b0					endif 
35b0					FORTH_LOOP_NEXT 
35b0 cd 59 22			call macro_forth_loop_next 
35b3				endm 
# End of macro FORTH_LOOP_NEXT
35b3			 
35b3			 
35b3					; init first round of I counter 
35b3			 
35b3 22 21 f4				ld (os_current_i), hl 
35b6			 
35b6					if DEBUG_FORTH_WORDS 
35b6						DMARK "DO8" 
35b6 f5				push af  
35b7 3a cb 35			ld a, (.dmark)  
35ba 32 a6 fd			ld (debug_mark),a  
35bd 3a cc 35			ld a, (.dmark+1)  
35c0 32 a7 fd			ld (debug_mark+1),a  
35c3 3a cd 35			ld a, (.dmark+2)  
35c6 32 a8 fd			ld (debug_mark+2),a  
35c9 18 03			jr .pastdmark  
35cb ..			.dmark: db "DO8"  
35ce f1			.pastdmark: pop af  
35cf			endm  
# End of macro DMARK
35cf						CALLMONITOR 
35cf cd aa fd			call debug_vector  
35d2				endm  
# End of macro CALLMONITOR
35d2					endif 
35d2			 
35d2					NEXTW 
35d2 c3 de 23			jp macro_next 
35d5				endm 
# End of macro NEXTW
35d5			.LOOP: 
35d5				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35d5 22				db WORD_SYS_CORE+14             
35d6 ed 36			dw .I            
35d8 05				db 4 + 1 
35d9 .. 00			db "LOOP",0              
35de				endm 
# End of macro CWHEAD
35de			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35de			 
35de				; pop tos as current loop count to hl 
35de			 
35de				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35de			 
35de				FORTH_LOOP_TOS 
35de cd 8c 22			call macro_forth_loop_tos 
35e1				endm 
# End of macro FORTH_LOOP_TOS
35e1 e5				push hl 
35e2			 
35e2					if DEBUG_FORTH_WORDS_KEY 
35e2						DMARK "LOP" 
35e2 f5				push af  
35e3 3a f7 35			ld a, (.dmark)  
35e6 32 a6 fd			ld (debug_mark),a  
35e9 3a f8 35			ld a, (.dmark+1)  
35ec 32 a7 fd			ld (debug_mark+1),a  
35ef 3a f9 35			ld a, (.dmark+2)  
35f2 32 a8 fd			ld (debug_mark+2),a  
35f5 18 03			jr .pastdmark  
35f7 ..			.dmark: db "LOP"  
35fa f1			.pastdmark: pop af  
35fb			endm  
# End of macro DMARK
35fb						CALLMONITOR 
35fb cd aa fd			call debug_vector  
35fe				endm  
# End of macro CALLMONITOR
35fe					endif 
35fe				; next item on the stack is the limit. get it 
35fe			 
35fe			 
35fe				FORTH_LOOP_POP 
35fe cd 96 22			call macro_forth_loop_pop 
3601				endm 
# End of macro FORTH_LOOP_POP
3601			 
3601				FORTH_LOOP_TOS 
3601 cd 8c 22			call macro_forth_loop_tos 
3604				endm 
# End of macro FORTH_LOOP_TOS
3604			 
3604 d1				pop de		 ; de = i, hl = limit 
3605			 
3605					if DEBUG_FORTH_WORDS 
3605						DMARK "LP1" 
3605 f5				push af  
3606 3a 1a 36			ld a, (.dmark)  
3609 32 a6 fd			ld (debug_mark),a  
360c 3a 1b 36			ld a, (.dmark+1)  
360f 32 a7 fd			ld (debug_mark+1),a  
3612 3a 1c 36			ld a, (.dmark+2)  
3615 32 a8 fd			ld (debug_mark+2),a  
3618 18 03			jr .pastdmark  
361a ..			.dmark: db "LP1"  
361d f1			.pastdmark: pop af  
361e			endm  
# End of macro DMARK
361e						CALLMONITOR 
361e cd aa fd			call debug_vector  
3621				endm  
# End of macro CALLMONITOR
3621					endif 
3621			 
3621				; go back to previous word 
3621			 
3621 d5				push de    ; save I for inc later 
3622			 
3622			 
3622				; get limit 
3622				;  is I at limit? 
3622			 
3622			 
3622					if DEBUG_FORTH_WORDS 
3622						DMARK "LP1" 
3622 f5				push af  
3623 3a 37 36			ld a, (.dmark)  
3626 32 a6 fd			ld (debug_mark),a  
3629 3a 38 36			ld a, (.dmark+1)  
362c 32 a7 fd			ld (debug_mark+1),a  
362f 3a 39 36			ld a, (.dmark+2)  
3632 32 a8 fd			ld (debug_mark+2),a  
3635 18 03			jr .pastdmark  
3637 ..			.dmark: db "LP1"  
363a f1			.pastdmark: pop af  
363b			endm  
# End of macro DMARK
363b						CALLMONITOR 
363b cd aa fd			call debug_vector  
363e				endm  
# End of macro CALLMONITOR
363e					endif 
363e			 
363e ed 52			sbc hl, de 
3640			 
3640			 
3640				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3640			 
3640 20 26				jr nz, .loopnotdone 
3642			 
3642 e1				pop hl   ; get rid of saved I 
3643				FORTH_LOOP_POP     ; get rid of limit 
3643 cd 96 22			call macro_forth_loop_pop 
3646				endm 
# End of macro FORTH_LOOP_POP
3646			 
3646				FORTH_RSP_POP     ; get rid of DO ptr 
3646 cd eb 1f			call macro_forth_rsp_pop 
3649				endm 
# End of macro FORTH_RSP_POP
3649			 
3649			if DEBUG_FORTH_WORDS 
3649						DMARK "LP>" 
3649 f5				push af  
364a 3a 5e 36			ld a, (.dmark)  
364d 32 a6 fd			ld (debug_mark),a  
3650 3a 5f 36			ld a, (.dmark+1)  
3653 32 a7 fd			ld (debug_mark+1),a  
3656 3a 60 36			ld a, (.dmark+2)  
3659 32 a8 fd			ld (debug_mark+2),a  
365c 18 03			jr .pastdmark  
365e ..			.dmark: db "LP>"  
3661 f1			.pastdmark: pop af  
3662			endm  
# End of macro DMARK
3662				CALLMONITOR 
3662 cd aa fd			call debug_vector  
3665				endm  
# End of macro CALLMONITOR
3665			endif 
3665			 
3665					NEXTW 
3665 c3 de 23			jp macro_next 
3668				endm 
# End of macro NEXTW
3668				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3668			 
3668			.loopnotdone: 
3668			 
3668 e1				pop hl    ; get I 
3669 23				inc hl 
366a			 
366a			   	; save new I 
366a			 
366a			 
366a					; set I counter 
366a			 
366a 22 21 f4				ld (os_current_i), hl 
366d			 
366d					if DEBUG_FORTH_WORDS 
366d						DMARK "LPN" 
366d f5				push af  
366e 3a 82 36			ld a, (.dmark)  
3671 32 a6 fd			ld (debug_mark),a  
3674 3a 83 36			ld a, (.dmark+1)  
3677 32 a7 fd			ld (debug_mark+1),a  
367a 3a 84 36			ld a, (.dmark+2)  
367d 32 a8 fd			ld (debug_mark+2),a  
3680 18 03			jr .pastdmark  
3682 ..			.dmark: db "LPN"  
3685 f1			.pastdmark: pop af  
3686			endm  
# End of macro DMARK
3686					CALLMONITOR 
3686 cd aa fd			call debug_vector  
3689				endm  
# End of macro CALLMONITOR
3689					endif 
3689					 
3689				FORTH_LOOP_NEXT 
3689 cd 59 22			call macro_forth_loop_next 
368c				endm 
# End of macro FORTH_LOOP_NEXT
368c			 
368c			 
368c					if DEBUG_FORTH_WORDS 
368c eb						ex de,hl 
368d					endif 
368d			 
368d			;	; get DO ptr 
368d			; 
368d					if DEBUG_FORTH_WORDS 
368d						DMARK "LP7" 
368d f5				push af  
368e 3a a2 36			ld a, (.dmark)  
3691 32 a6 fd			ld (debug_mark),a  
3694 3a a3 36			ld a, (.dmark+1)  
3697 32 a7 fd			ld (debug_mark+1),a  
369a 3a a4 36			ld a, (.dmark+2)  
369d 32 a8 fd			ld (debug_mark+2),a  
36a0 18 03			jr .pastdmark  
36a2 ..			.dmark: db "LP7"  
36a5 f1			.pastdmark: pop af  
36a6			endm  
# End of macro DMARK
36a6					CALLMONITOR 
36a6 cd aa fd			call debug_vector  
36a9				endm  
# End of macro CALLMONITOR
36a9					endif 
36a9				FORTH_RSP_TOS 
36a9 cd e1 1f			call macro_forth_rsp_tos 
36ac				endm 
# End of macro FORTH_RSP_TOS
36ac			 
36ac					if DEBUG_FORTH_WORDS 
36ac						DMARK "LP8" 
36ac f5				push af  
36ad 3a c1 36			ld a, (.dmark)  
36b0 32 a6 fd			ld (debug_mark),a  
36b3 3a c2 36			ld a, (.dmark+1)  
36b6 32 a7 fd			ld (debug_mark+1),a  
36b9 3a c3 36			ld a, (.dmark+2)  
36bc 32 a8 fd			ld (debug_mark+2),a  
36bf 18 03			jr .pastdmark  
36c1 ..			.dmark: db "LP8"  
36c4 f1			.pastdmark: pop af  
36c5			endm  
# End of macro DMARK
36c5					CALLMONITOR 
36c5 cd aa fd			call debug_vector  
36c8				endm  
# End of macro CALLMONITOR
36c8					endif 
36c8				;push hl 
36c8			 
36c8				; not going to DO any more 
36c8				; get rid of the RSP pointer as DO will add it back in 
36c8				;FORTH_RSP_POP 
36c8				;pop hl 
36c8			 
36c8				;ld hl,(cli_ret_sp) 
36c8				;ld e, (hl) 
36c8				;inc hl 
36c8				;ld d, (hl) 
36c8				;ex de,hl 
36c8 22 fd f3			ld (os_tok_ptr), hl 
36cb					if DEBUG_FORTH_WORDS 
36cb						DMARK "LP<" 
36cb f5				push af  
36cc 3a e0 36			ld a, (.dmark)  
36cf 32 a6 fd			ld (debug_mark),a  
36d2 3a e1 36			ld a, (.dmark+1)  
36d5 32 a7 fd			ld (debug_mark+1),a  
36d8 3a e2 36			ld a, (.dmark+2)  
36db 32 a8 fd			ld (debug_mark+2),a  
36de 18 03			jr .pastdmark  
36e0 ..			.dmark: db "LP<"  
36e3 f1			.pastdmark: pop af  
36e4			endm  
# End of macro DMARK
36e4					CALLMONITOR 
36e4 cd aa fd			call debug_vector  
36e7				endm  
# End of macro CALLMONITOR
36e7				endif 
36e7 c3 6f 24			jp exec1 
36ea			 
36ea					 
36ea			 
36ea			 
36ea					NEXTW 
36ea c3 de 23			jp macro_next 
36ed				endm 
# End of macro NEXTW
36ed			.I:  
36ed			 
36ed				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
36ed 5e				db WORD_SYS_CORE+74             
36ee 18 37			dw .DLOOP            
36f0 02				db 1 + 1 
36f1 .. 00			db "I",0              
36f3				endm 
# End of macro CWHEAD
36f3			; | I ( -- ) Current loop counter | DONE 
36f3					if DEBUG_FORTH_WORDS_KEY 
36f3						DMARK "I.." 
36f3 f5				push af  
36f4 3a 08 37			ld a, (.dmark)  
36f7 32 a6 fd			ld (debug_mark),a  
36fa 3a 09 37			ld a, (.dmark+1)  
36fd 32 a7 fd			ld (debug_mark+1),a  
3700 3a 0a 37			ld a, (.dmark+2)  
3703 32 a8 fd			ld (debug_mark+2),a  
3706 18 03			jr .pastdmark  
3708 ..			.dmark: db "I.."  
370b f1			.pastdmark: pop af  
370c			endm  
# End of macro DMARK
370c						CALLMONITOR 
370c cd aa fd			call debug_vector  
370f				endm  
# End of macro CALLMONITOR
370f					endif 
370f			 
370f 2a 21 f4				ld hl,(os_current_i) 
3712 cd 23 20				call forth_push_numhl 
3715			 
3715					NEXTW 
3715 c3 de 23			jp macro_next 
3718				endm 
# End of macro NEXTW
3718			.DLOOP: 
3718				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3718 5f				db WORD_SYS_CORE+75             
3719 f9 37			dw .REPEAT            
371b 06				db 5 + 1 
371c .. 00			db "-LOOP",0              
3722				endm 
# End of macro CWHEAD
3722			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3722				; pop tos as current loop count to hl 
3722					if DEBUG_FORTH_WORDS_KEY 
3722						DMARK "-LP" 
3722 f5				push af  
3723 3a 37 37			ld a, (.dmark)  
3726 32 a6 fd			ld (debug_mark),a  
3729 3a 38 37			ld a, (.dmark+1)  
372c 32 a7 fd			ld (debug_mark+1),a  
372f 3a 39 37			ld a, (.dmark+2)  
3732 32 a8 fd			ld (debug_mark+2),a  
3735 18 03			jr .pastdmark  
3737 ..			.dmark: db "-LP"  
373a f1			.pastdmark: pop af  
373b			endm  
# End of macro DMARK
373b						CALLMONITOR 
373b cd aa fd			call debug_vector  
373e				endm  
# End of macro CALLMONITOR
373e					endif 
373e			 
373e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
373e			 
373e				FORTH_LOOP_TOS 
373e cd 8c 22			call macro_forth_loop_tos 
3741				endm 
# End of macro FORTH_LOOP_TOS
3741 e5				push hl 
3742			 
3742					if DEBUG_FORTH_WORDS 
3742						DMARK "-LP" 
3742 f5				push af  
3743 3a 57 37			ld a, (.dmark)  
3746 32 a6 fd			ld (debug_mark),a  
3749 3a 58 37			ld a, (.dmark+1)  
374c 32 a7 fd			ld (debug_mark+1),a  
374f 3a 59 37			ld a, (.dmark+2)  
3752 32 a8 fd			ld (debug_mark+2),a  
3755 18 03			jr .pastdmark  
3757 ..			.dmark: db "-LP"  
375a f1			.pastdmark: pop af  
375b			endm  
# End of macro DMARK
375b						CALLMONITOR 
375b cd aa fd			call debug_vector  
375e				endm  
# End of macro CALLMONITOR
375e					endif 
375e				; next item on the stack is the limit. get it 
375e			 
375e			 
375e				FORTH_LOOP_POP 
375e cd 96 22			call macro_forth_loop_pop 
3761				endm 
# End of macro FORTH_LOOP_POP
3761			 
3761				FORTH_LOOP_TOS 
3761 cd 8c 22			call macro_forth_loop_tos 
3764				endm 
# End of macro FORTH_LOOP_TOS
3764			 
3764 d1				pop de		 ; de = i, hl = limit 
3765			 
3765					if DEBUG_FORTH_WORDS 
3765						DMARK "-L1" 
3765 f5				push af  
3766 3a 7a 37			ld a, (.dmark)  
3769 32 a6 fd			ld (debug_mark),a  
376c 3a 7b 37			ld a, (.dmark+1)  
376f 32 a7 fd			ld (debug_mark+1),a  
3772 3a 7c 37			ld a, (.dmark+2)  
3775 32 a8 fd			ld (debug_mark+2),a  
3778 18 03			jr .pastdmark  
377a ..			.dmark: db "-L1"  
377d f1			.pastdmark: pop af  
377e			endm  
# End of macro DMARK
377e						CALLMONITOR 
377e cd aa fd			call debug_vector  
3781				endm  
# End of macro CALLMONITOR
3781					endif 
3781			 
3781				; go back to previous word 
3781			 
3781 d5				push de    ; save I for inc later 
3782			 
3782			 
3782				; get limit 
3782				;  is I at limit? 
3782			 
3782			 
3782					if DEBUG_FORTH_WORDS 
3782						DMARK "-L1" 
3782 f5				push af  
3783 3a 97 37			ld a, (.dmark)  
3786 32 a6 fd			ld (debug_mark),a  
3789 3a 98 37			ld a, (.dmark+1)  
378c 32 a7 fd			ld (debug_mark+1),a  
378f 3a 99 37			ld a, (.dmark+2)  
3792 32 a8 fd			ld (debug_mark+2),a  
3795 18 03			jr .pastdmark  
3797 ..			.dmark: db "-L1"  
379a f1			.pastdmark: pop af  
379b			endm  
# End of macro DMARK
379b						CALLMONITOR 
379b cd aa fd			call debug_vector  
379e				endm  
# End of macro CALLMONITOR
379e					endif 
379e			 
379e ed 52			sbc hl, de 
37a0			 
37a0			 
37a0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
37a0			 
37a0 20 26				jr nz, .mloopnotdone 
37a2			 
37a2 e1				pop hl   ; get rid of saved I 
37a3				FORTH_LOOP_POP     ; get rid of limit 
37a3 cd 96 22			call macro_forth_loop_pop 
37a6				endm 
# End of macro FORTH_LOOP_POP
37a6			 
37a6				FORTH_RSP_POP     ; get rid of DO ptr 
37a6 cd eb 1f			call macro_forth_rsp_pop 
37a9				endm 
# End of macro FORTH_RSP_POP
37a9			 
37a9			if DEBUG_FORTH_WORDS 
37a9						DMARK "-L>" 
37a9 f5				push af  
37aa 3a be 37			ld a, (.dmark)  
37ad 32 a6 fd			ld (debug_mark),a  
37b0 3a bf 37			ld a, (.dmark+1)  
37b3 32 a7 fd			ld (debug_mark+1),a  
37b6 3a c0 37			ld a, (.dmark+2)  
37b9 32 a8 fd			ld (debug_mark+2),a  
37bc 18 03			jr .pastdmark  
37be ..			.dmark: db "-L>"  
37c1 f1			.pastdmark: pop af  
37c2			endm  
# End of macro DMARK
37c2				CALLMONITOR 
37c2 cd aa fd			call debug_vector  
37c5				endm  
# End of macro CALLMONITOR
37c5			endif 
37c5			 
37c5					NEXTW 
37c5 c3 de 23			jp macro_next 
37c8				endm 
# End of macro NEXTW
37c8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37c8			 
37c8			.mloopnotdone: 
37c8			 
37c8 e1				pop hl    ; get I 
37c9 2b				dec hl 
37ca			 
37ca			   	; save new I 
37ca			 
37ca			 
37ca					; set I counter 
37ca			 
37ca 22 21 f4				ld (os_current_i), hl 
37cd			 
37cd					 
37cd				FORTH_LOOP_NEXT 
37cd cd 59 22			call macro_forth_loop_next 
37d0				endm 
# End of macro FORTH_LOOP_NEXT
37d0			 
37d0			 
37d0					if DEBUG_FORTH_WORDS 
37d0 eb						ex de,hl 
37d1					endif 
37d1			 
37d1			;	; get DO ptr 
37d1			; 
37d1				FORTH_RSP_TOS 
37d1 cd e1 1f			call macro_forth_rsp_tos 
37d4				endm 
# End of macro FORTH_RSP_TOS
37d4			 
37d4				;push hl 
37d4			 
37d4				; not going to DO any more 
37d4				; get rid of the RSP pointer as DO will add it back in 
37d4				;FORTH_RSP_POP 
37d4				;pop hl 
37d4			 
37d4			 
37d4 22 fd f3			ld (os_tok_ptr), hl 
37d7					if DEBUG_FORTH_WORDS 
37d7						DMARK "-L<" 
37d7 f5				push af  
37d8 3a ec 37			ld a, (.dmark)  
37db 32 a6 fd			ld (debug_mark),a  
37de 3a ed 37			ld a, (.dmark+1)  
37e1 32 a7 fd			ld (debug_mark+1),a  
37e4 3a ee 37			ld a, (.dmark+2)  
37e7 32 a8 fd			ld (debug_mark+2),a  
37ea 18 03			jr .pastdmark  
37ec ..			.dmark: db "-L<"  
37ef f1			.pastdmark: pop af  
37f0			endm  
# End of macro DMARK
37f0					CALLMONITOR 
37f0 cd aa fd			call debug_vector  
37f3				endm  
# End of macro CALLMONITOR
37f3				endif 
37f3 c3 6f 24			jp exec1 
37f6			 
37f6					 
37f6			 
37f6			 
37f6			 
37f6				NEXTW 
37f6 c3 de 23			jp macro_next 
37f9				endm 
# End of macro NEXTW
37f9			 
37f9			 
37f9			 
37f9			 
37f9			.REPEAT: 
37f9				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
37f9 71				db WORD_SYS_CORE+93             
37fa 4c 38			dw .UNTIL            
37fc 06				db 5 + 1 
37fd .. 00			db "REPEAT",0              
3804				endm 
# End of macro CWHEAD
3804			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3804			;  push pc to rsp stack past the REPEAT 
3804					if DEBUG_FORTH_WORDS_KEY 
3804						DMARK "REP" 
3804 f5				push af  
3805 3a 19 38			ld a, (.dmark)  
3808 32 a6 fd			ld (debug_mark),a  
380b 3a 1a 38			ld a, (.dmark+1)  
380e 32 a7 fd			ld (debug_mark+1),a  
3811 3a 1b 38			ld a, (.dmark+2)  
3814 32 a8 fd			ld (debug_mark+2),a  
3817 18 03			jr .pastdmark  
3819 ..			.dmark: db "REP"  
381c f1			.pastdmark: pop af  
381d			endm  
# End of macro DMARK
381d						CALLMONITOR 
381d cd aa fd			call debug_vector  
3820				endm  
# End of macro CALLMONITOR
3820					endif 
3820			 
3820 2a fd f3				ld hl, (os_tok_ptr) 
3823 23					inc hl   ; R 
3824 23					inc hl  ; E 
3825 23					inc hl   ; P 
3826 23					inc hl   ; E 
3827 23					inc hl   ; A 
3828 23					inc hl   ; T 
3829 23					inc hl   ; zero 
382a					FORTH_RSP_NEXT 
382a cd ca 1f			call macro_forth_rsp_next 
382d				endm 
# End of macro FORTH_RSP_NEXT
382d			 
382d			 
382d					if DEBUG_FORTH_WORDS 
382d						DMARK "REP" 
382d f5				push af  
382e 3a 42 38			ld a, (.dmark)  
3831 32 a6 fd			ld (debug_mark),a  
3834 3a 43 38			ld a, (.dmark+1)  
3837 32 a7 fd			ld (debug_mark+1),a  
383a 3a 44 38			ld a, (.dmark+2)  
383d 32 a8 fd			ld (debug_mark+2),a  
3840 18 03			jr .pastdmark  
3842 ..			.dmark: db "REP"  
3845 f1			.pastdmark: pop af  
3846			endm  
# End of macro DMARK
3846						;pop bc    ; TODO BUG ?????? what is this for???? 
3846						CALLMONITOR 
3846 cd aa fd			call debug_vector  
3849				endm  
# End of macro CALLMONITOR
3849					endif 
3849			 
3849					NEXTW 
3849 c3 de 23			jp macro_next 
384c				endm 
# End of macro NEXTW
384c			;	       NEXTW 
384c			 
384c			.UNTIL: 
384c				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
384c 72				db WORD_SYS_CORE+94             
384d e3 38			dw .ENDFLOW            
384f 06				db 5 + 1 
3850 .. 00			db "UNTIL",0              
3856				endm 
# End of macro CWHEAD
3856			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3856			 
3856				; pop tos as check 
3856			 
3856				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3856			 
3856				FORTH_DSP_VALUEHL 
3856 cd 28 22			call macro_dsp_valuehl 
3859				endm 
# End of macro FORTH_DSP_VALUEHL
3859			 
3859					if DEBUG_FORTH_WORDS_KEY 
3859						DMARK "UNT" 
3859 f5				push af  
385a 3a 6e 38			ld a, (.dmark)  
385d 32 a6 fd			ld (debug_mark),a  
3860 3a 6f 38			ld a, (.dmark+1)  
3863 32 a7 fd			ld (debug_mark+1),a  
3866 3a 70 38			ld a, (.dmark+2)  
3869 32 a8 fd			ld (debug_mark+2),a  
386c 18 03			jr .pastdmark  
386e ..			.dmark: db "UNT"  
3871 f1			.pastdmark: pop af  
3872			endm  
# End of macro DMARK
3872						CALLMONITOR 
3872 cd aa fd			call debug_vector  
3875				endm  
# End of macro CALLMONITOR
3875					endif 
3875			 
3875			;	push hl 
3875				FORTH_DSP_POP 
3875 cd e0 22			call macro_forth_dsp_pop 
3878				endm 
# End of macro FORTH_DSP_POP
3878			 
3878			;	pop hl 
3878			 
3878				; test if true 
3878			 
3878 cd f8 0f			call ishlzero 
387b			;	ld a,l 
387b			;	add h 
387b			; 
387b			;	cp 0 
387b			 
387b 20 3e			jr nz, .untilnotdone 
387d			 
387d					if DEBUG_FORTH_WORDS 
387d						DMARK "UNf" 
387d f5				push af  
387e 3a 92 38			ld a, (.dmark)  
3881 32 a6 fd			ld (debug_mark),a  
3884 3a 93 38			ld a, (.dmark+1)  
3887 32 a7 fd			ld (debug_mark+1),a  
388a 3a 94 38			ld a, (.dmark+2)  
388d 32 a8 fd			ld (debug_mark+2),a  
3890 18 03			jr .pastdmark  
3892 ..			.dmark: db "UNf"  
3895 f1			.pastdmark: pop af  
3896			endm  
# End of macro DMARK
3896						CALLMONITOR 
3896 cd aa fd			call debug_vector  
3899				endm  
# End of macro CALLMONITOR
3899					endif 
3899			 
3899			 
3899			 
3899				FORTH_RSP_POP     ; get rid of DO ptr 
3899 cd eb 1f			call macro_forth_rsp_pop 
389c				endm 
# End of macro FORTH_RSP_POP
389c			 
389c			if DEBUG_FORTH_WORDS 
389c						DMARK "UN>" 
389c f5				push af  
389d 3a b1 38			ld a, (.dmark)  
38a0 32 a6 fd			ld (debug_mark),a  
38a3 3a b2 38			ld a, (.dmark+1)  
38a6 32 a7 fd			ld (debug_mark+1),a  
38a9 3a b3 38			ld a, (.dmark+2)  
38ac 32 a8 fd			ld (debug_mark+2),a  
38af 18 03			jr .pastdmark  
38b1 ..			.dmark: db "UN>"  
38b4 f1			.pastdmark: pop af  
38b5			endm  
# End of macro DMARK
38b5				CALLMONITOR 
38b5 cd aa fd			call debug_vector  
38b8				endm  
# End of macro CALLMONITOR
38b8			endif 
38b8			 
38b8					NEXTW 
38b8 c3 de 23			jp macro_next 
38bb				endm 
# End of macro NEXTW
38bb				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38bb			 
38bb			.untilnotdone: 
38bb			 
38bb			 
38bb			;	; get DO ptr 
38bb			; 
38bb				FORTH_RSP_TOS 
38bb cd e1 1f			call macro_forth_rsp_tos 
38be				endm 
# End of macro FORTH_RSP_TOS
38be			 
38be				;push hl 
38be			 
38be				; not going to DO any more 
38be				; get rid of the RSP pointer as DO will add it back in 
38be				;FORTH_RSP_POP 
38be				;pop hl 
38be			 
38be			 
38be 22 fd f3			ld (os_tok_ptr), hl 
38c1					if DEBUG_FORTH_WORDS 
38c1						DMARK "UN<" 
38c1 f5				push af  
38c2 3a d6 38			ld a, (.dmark)  
38c5 32 a6 fd			ld (debug_mark),a  
38c8 3a d7 38			ld a, (.dmark+1)  
38cb 32 a7 fd			ld (debug_mark+1),a  
38ce 3a d8 38			ld a, (.dmark+2)  
38d1 32 a8 fd			ld (debug_mark+2),a  
38d4 18 03			jr .pastdmark  
38d6 ..			.dmark: db "UN<"  
38d9 f1			.pastdmark: pop af  
38da			endm  
# End of macro DMARK
38da					CALLMONITOR 
38da cd aa fd			call debug_vector  
38dd				endm  
# End of macro CALLMONITOR
38dd				endif 
38dd c3 6f 24			jp exec1 
38e0			 
38e0					 
38e0			 
38e0			 
38e0					NEXTW 
38e0 c3 de 23			jp macro_next 
38e3				endm 
# End of macro NEXTW
38e3			 
38e3			 
38e3			.ENDFLOW: 
38e3			 
38e3			; eof 
38e3			 
# End of file forth_words_flow.asm
38e3			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38e3			include "forth_words_logic.asm" 
38e3			 
38e3			; | ## Logic Words 
38e3			 
38e3			.NOT: 
38e3				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38e3 2d				db WORD_SYS_CORE+25             
38e4 2b 39			dw .IS            
38e6 04				db 3 + 1 
38e7 .. 00			db "NOT",0              
38eb				endm 
# End of macro CWHEAD
38eb			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
38eb					if DEBUG_FORTH_WORDS_KEY 
38eb						DMARK "NOT" 
38eb f5				push af  
38ec 3a 00 39			ld a, (.dmark)  
38ef 32 a6 fd			ld (debug_mark),a  
38f2 3a 01 39			ld a, (.dmark+1)  
38f5 32 a7 fd			ld (debug_mark+1),a  
38f8 3a 02 39			ld a, (.dmark+2)  
38fb 32 a8 fd			ld (debug_mark+2),a  
38fe 18 03			jr .pastdmark  
3900 ..			.dmark: db "NOT"  
3903 f1			.pastdmark: pop af  
3904			endm  
# End of macro DMARK
3904						CALLMONITOR 
3904 cd aa fd			call debug_vector  
3907				endm  
# End of macro CALLMONITOR
3907					endif 
3907					FORTH_DSP 
3907 cd ee 21			call macro_forth_dsp 
390a				endm 
# End of macro FORTH_DSP
390a 7e					ld a,(hl)	; get type of value on TOS 
390b fe 02				cp DS_TYPE_INUM  
390d 28 03				jr z, .noti 
390f					NEXTW 
390f c3 de 23			jp macro_next 
3912				endm 
# End of macro NEXTW
3912			.noti:          FORTH_DSP_VALUEHL 
3912 cd 28 22			call macro_dsp_valuehl 
3915				endm 
# End of macro FORTH_DSP_VALUEHL
3915			;		push hl 
3915					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3915 cd e0 22			call macro_forth_dsp_pop 
3918				endm 
# End of macro FORTH_DSP_POP
3918			;		pop hl 
3918 3e 00				ld a,0 
391a bd					cp l 
391b 28 04				jr z, .not2t 
391d 2e 00				ld l, 0 
391f 18 02				jr .notip 
3921			 
3921 2e ff		.not2t:		ld l, 255 
3923			 
3923 26 00		.notip:		ld h, 0	 
3925			 
3925 cd 23 20				call forth_push_numhl 
3928					NEXTW 
3928 c3 de 23			jp macro_next 
392b				endm 
# End of macro NEXTW
392b			 
392b			.IS: 
392b				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
392b 2d				db WORD_SYS_CORE+25             
392c 51 39			dw .LZERO            
392e 03				db 2 + 1 
392f .. 00			db "IS",0              
3932				endm 
# End of macro CWHEAD
3932			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3932					if DEBUG_FORTH_WORDS_KEY 
3932						DMARK "IS." 
3932 f5				push af  
3933 3a 47 39			ld a, (.dmark)  
3936 32 a6 fd			ld (debug_mark),a  
3939 3a 48 39			ld a, (.dmark+1)  
393c 32 a7 fd			ld (debug_mark+1),a  
393f 3a 49 39			ld a, (.dmark+2)  
3942 32 a8 fd			ld (debug_mark+2),a  
3945 18 03			jr .pastdmark  
3947 ..			.dmark: db "IS."  
394a f1			.pastdmark: pop af  
394b			endm  
# End of macro DMARK
394b						CALLMONITOR 
394b cd aa fd			call debug_vector  
394e				endm  
# End of macro CALLMONITOR
394e					endif 
394e					NEXTW 
394e c3 de 23			jp macro_next 
3951				endm 
# End of macro NEXTW
3951			.LZERO: 
3951				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3951 2d				db WORD_SYS_CORE+25             
3952 5b 39			dw .TZERO            
3954 03				db 2 + 1 
3955 .. 00			db "0<",0              
3958				endm 
# End of macro CWHEAD
3958			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3958					NEXTW 
3958 c3 de 23			jp macro_next 
395b				endm 
# End of macro NEXTW
395b			.TZERO: 
395b				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
395b 2e				db WORD_SYS_CORE+26             
395c a2 39			dw .LESS            
395e 03				db 2 + 1 
395f .. 00			db "0=",0              
3962				endm 
# End of macro CWHEAD
3962			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3962				; TODO add floating point number detection 
3962					;v5 FORTH_DSP_VALUE 
3962					if DEBUG_FORTH_WORDS_KEY 
3962						DMARK "0=." 
3962 f5				push af  
3963 3a 77 39			ld a, (.dmark)  
3966 32 a6 fd			ld (debug_mark),a  
3969 3a 78 39			ld a, (.dmark+1)  
396c 32 a7 fd			ld (debug_mark+1),a  
396f 3a 79 39			ld a, (.dmark+2)  
3972 32 a8 fd			ld (debug_mark+2),a  
3975 18 03			jr .pastdmark  
3977 ..			.dmark: db "0=."  
397a f1			.pastdmark: pop af  
397b			endm  
# End of macro DMARK
397b						CALLMONITOR 
397b cd aa fd			call debug_vector  
397e				endm  
# End of macro CALLMONITOR
397e					endif 
397e					FORTH_DSP 
397e cd ee 21			call macro_forth_dsp 
3981				endm 
# End of macro FORTH_DSP
3981 7e					ld a,(hl)	; get type of value on TOS 
3982 fe 02				cp DS_TYPE_INUM  
3984 28 00				jr z, .tz_inum 
3986			 
3986				if FORTH_ENABLE_FLOATMATH 
3986					jr .tz_done 
3986			 
3986				endif 
3986					 
3986			 
3986			.tz_inum: 
3986					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3986 cd 28 22			call macro_dsp_valuehl 
3989				endm 
# End of macro FORTH_DSP_VALUEHL
3989			 
3989			;		push hl 
3989			 
3989					; destroy value TOS 
3989			 
3989					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3989 cd e0 22			call macro_forth_dsp_pop 
398c				endm 
# End of macro FORTH_DSP_POP
398c			 
398c			;		pop hl 
398c			 
398c 3e 00				ld a,0 
398e			 
398e bd					cp l 
398f 20 08				jr nz, .tz_notzero 
3991			 
3991 bc					cp h 
3992			 
3992 20 05				jr nz, .tz_notzero 
3994			 
3994			 
3994 21 01 00				ld hl, FORTH_TRUE 
3997 18 03				jr .tz_done 
3999			 
3999 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
399c			 
399c					; push value back onto stack for another op etc 
399c			 
399c			.tz_done: 
399c cd 23 20				call forth_push_numhl 
399f			 
399f					NEXTW 
399f c3 de 23			jp macro_next 
39a2				endm 
# End of macro NEXTW
39a2			.LESS: 
39a2				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
39a2 2f				db WORD_SYS_CORE+27             
39a3 0b 3a			dw .GT            
39a5 02				db 1 + 1 
39a6 .. 00			db "<",0              
39a8				endm 
# End of macro CWHEAD
39a8			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
39a8				; TODO add floating point number detection 
39a8					if DEBUG_FORTH_WORDS_KEY 
39a8						DMARK "LES" 
39a8 f5				push af  
39a9 3a bd 39			ld a, (.dmark)  
39ac 32 a6 fd			ld (debug_mark),a  
39af 3a be 39			ld a, (.dmark+1)  
39b2 32 a7 fd			ld (debug_mark+1),a  
39b5 3a bf 39			ld a, (.dmark+2)  
39b8 32 a8 fd			ld (debug_mark+2),a  
39bb 18 03			jr .pastdmark  
39bd ..			.dmark: db "LES"  
39c0 f1			.pastdmark: pop af  
39c1			endm  
# End of macro DMARK
39c1						CALLMONITOR 
39c1 cd aa fd			call debug_vector  
39c4				endm  
# End of macro CALLMONITOR
39c4					endif 
39c4					FORTH_DSP 
39c4 cd ee 21			call macro_forth_dsp 
39c7				endm 
# End of macro FORTH_DSP
39c7					;v5 FORTH_DSP_VALUE 
39c7 7e					ld a,(hl)	; get type of value on TOS 
39c8 fe 02				cp DS_TYPE_INUM  
39ca 28 00				jr z, .less_inum 
39cc			 
39cc				if FORTH_ENABLE_FLOATMATH 
39cc					jr .less_done 
39cc			 
39cc				endif 
39cc					 
39cc			 
39cc			.less_inum: 
39cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39cc cd 28 22			call macro_dsp_valuehl 
39cf				endm 
# End of macro FORTH_DSP_VALUEHL
39cf			 
39cf e5					push hl  ; u2 
39d0			 
39d0					; destroy value TOS 
39d0			 
39d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d0 cd e0 22			call macro_forth_dsp_pop 
39d3				endm 
# End of macro FORTH_DSP_POP
39d3			 
39d3			 
39d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39d3 cd 28 22			call macro_dsp_valuehl 
39d6				endm 
# End of macro FORTH_DSP_VALUEHL
39d6			 
39d6 e5					push hl    ; u1 
39d7			 
39d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d7 cd e0 22			call macro_forth_dsp_pop 
39da				endm 
# End of macro FORTH_DSP_POP
39da			 
39da			 
39da b7			 or a      ;clear carry flag 
39db 01 00 00		 ld bc, FORTH_FALSE 
39de e1			  pop hl    ; u1 
39df d1			  pop de    ; u2 
39e0 ed 52		  sbc hl,de 
39e2 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39e4			 
39e4 01 01 00		 ld bc, FORTH_TRUE 
39e7			.lscont:  
39e7 c5					push bc 
39e8 e1					pop hl 
39e9			 
39e9					if DEBUG_FORTH_WORDS 
39e9						DMARK "LT1" 
39e9 f5				push af  
39ea 3a fe 39			ld a, (.dmark)  
39ed 32 a6 fd			ld (debug_mark),a  
39f0 3a ff 39			ld a, (.dmark+1)  
39f3 32 a7 fd			ld (debug_mark+1),a  
39f6 3a 00 3a			ld a, (.dmark+2)  
39f9 32 a8 fd			ld (debug_mark+2),a  
39fc 18 03			jr .pastdmark  
39fe ..			.dmark: db "LT1"  
3a01 f1			.pastdmark: pop af  
3a02			endm  
# End of macro DMARK
3a02						CALLMONITOR 
3a02 cd aa fd			call debug_vector  
3a05				endm  
# End of macro CALLMONITOR
3a05					endif 
3a05 cd 23 20				call forth_push_numhl 
3a08			 
3a08					NEXTW 
3a08 c3 de 23			jp macro_next 
3a0b				endm 
# End of macro NEXTW
3a0b			.GT: 
3a0b				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a0b 30				db WORD_SYS_CORE+28             
3a0c 74 3a			dw .EQUAL            
3a0e 02				db 1 + 1 
3a0f .. 00			db ">",0              
3a11				endm 
# End of macro CWHEAD
3a11			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a11				; TODO add floating point number detection 
3a11					if DEBUG_FORTH_WORDS_KEY 
3a11						DMARK "GRT" 
3a11 f5				push af  
3a12 3a 26 3a			ld a, (.dmark)  
3a15 32 a6 fd			ld (debug_mark),a  
3a18 3a 27 3a			ld a, (.dmark+1)  
3a1b 32 a7 fd			ld (debug_mark+1),a  
3a1e 3a 28 3a			ld a, (.dmark+2)  
3a21 32 a8 fd			ld (debug_mark+2),a  
3a24 18 03			jr .pastdmark  
3a26 ..			.dmark: db "GRT"  
3a29 f1			.pastdmark: pop af  
3a2a			endm  
# End of macro DMARK
3a2a						CALLMONITOR 
3a2a cd aa fd			call debug_vector  
3a2d				endm  
# End of macro CALLMONITOR
3a2d					endif 
3a2d					FORTH_DSP 
3a2d cd ee 21			call macro_forth_dsp 
3a30				endm 
# End of macro FORTH_DSP
3a30					;FORTH_DSP_VALUE 
3a30 7e					ld a,(hl)	; get type of value on TOS 
3a31 fe 02				cp DS_TYPE_INUM  
3a33 28 00				jr z, .gt_inum 
3a35			 
3a35				if FORTH_ENABLE_FLOATMATH 
3a35					jr .gt_done 
3a35			 
3a35				endif 
3a35					 
3a35			 
3a35			.gt_inum: 
3a35					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a35 cd 28 22			call macro_dsp_valuehl 
3a38				endm 
# End of macro FORTH_DSP_VALUEHL
3a38			 
3a38 e5					push hl  ; u2 
3a39			 
3a39					; destroy value TOS 
3a39			 
3a39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a39 cd e0 22			call macro_forth_dsp_pop 
3a3c				endm 
# End of macro FORTH_DSP_POP
3a3c			 
3a3c			 
3a3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3c cd 28 22			call macro_dsp_valuehl 
3a3f				endm 
# End of macro FORTH_DSP_VALUEHL
3a3f			 
3a3f e5					push hl    ; u1 
3a40			 
3a40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a40 cd e0 22			call macro_forth_dsp_pop 
3a43				endm 
# End of macro FORTH_DSP_POP
3a43			 
3a43			 
3a43 b7			 or a      ;clear carry flag 
3a44 01 00 00		 ld bc, FORTH_FALSE 
3a47 e1			  pop hl    ; u1 
3a48 d1			  pop de    ; u2 
3a49 ed 52		  sbc hl,de 
3a4b 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a4d			 
3a4d 01 01 00		 ld bc, FORTH_TRUE 
3a50			.gtcont:  
3a50 c5					push bc 
3a51 e1					pop hl 
3a52			 
3a52					if DEBUG_FORTH_WORDS 
3a52						DMARK "GT1" 
3a52 f5				push af  
3a53 3a 67 3a			ld a, (.dmark)  
3a56 32 a6 fd			ld (debug_mark),a  
3a59 3a 68 3a			ld a, (.dmark+1)  
3a5c 32 a7 fd			ld (debug_mark+1),a  
3a5f 3a 69 3a			ld a, (.dmark+2)  
3a62 32 a8 fd			ld (debug_mark+2),a  
3a65 18 03			jr .pastdmark  
3a67 ..			.dmark: db "GT1"  
3a6a f1			.pastdmark: pop af  
3a6b			endm  
# End of macro DMARK
3a6b						CALLMONITOR 
3a6b cd aa fd			call debug_vector  
3a6e				endm  
# End of macro CALLMONITOR
3a6e					endif 
3a6e cd 23 20				call forth_push_numhl 
3a71			 
3a71					NEXTW 
3a71 c3 de 23			jp macro_next 
3a74				endm 
# End of macro NEXTW
3a74			.EQUAL: 
3a74				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a74 31				db WORD_SYS_CORE+29             
3a75 df 3a			dw .ENDLOGIC            
3a77 02				db 1 + 1 
3a78 .. 00			db "=",0              
3a7a				endm 
# End of macro CWHEAD
3a7a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a7a				; TODO add floating point number detection 
3a7a					if DEBUG_FORTH_WORDS_KEY 
3a7a						DMARK "EQ." 
3a7a f5				push af  
3a7b 3a 8f 3a			ld a, (.dmark)  
3a7e 32 a6 fd			ld (debug_mark),a  
3a81 3a 90 3a			ld a, (.dmark+1)  
3a84 32 a7 fd			ld (debug_mark+1),a  
3a87 3a 91 3a			ld a, (.dmark+2)  
3a8a 32 a8 fd			ld (debug_mark+2),a  
3a8d 18 03			jr .pastdmark  
3a8f ..			.dmark: db "EQ."  
3a92 f1			.pastdmark: pop af  
3a93			endm  
# End of macro DMARK
3a93						CALLMONITOR 
3a93 cd aa fd			call debug_vector  
3a96				endm  
# End of macro CALLMONITOR
3a96					endif 
3a96					FORTH_DSP 
3a96 cd ee 21			call macro_forth_dsp 
3a99				endm 
# End of macro FORTH_DSP
3a99					;v5 FORTH_DSP_VALUE 
3a99 7e					ld a,(hl)	; get type of value on TOS 
3a9a fe 02				cp DS_TYPE_INUM  
3a9c 28 00				jr z, .eq_inum 
3a9e			 
3a9e				if FORTH_ENABLE_FLOATMATH 
3a9e					jr .eq_done 
3a9e			 
3a9e				endif 
3a9e					 
3a9e			 
3a9e			.eq_inum: 
3a9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9e cd 28 22			call macro_dsp_valuehl 
3aa1				endm 
# End of macro FORTH_DSP_VALUEHL
3aa1			 
3aa1 e5					push hl 
3aa2			 
3aa2					; destroy value TOS 
3aa2			 
3aa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa2 cd e0 22			call macro_forth_dsp_pop 
3aa5				endm 
# End of macro FORTH_DSP_POP
3aa5			 
3aa5			 
3aa5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa5 cd 28 22			call macro_dsp_valuehl 
3aa8				endm 
# End of macro FORTH_DSP_VALUEHL
3aa8			 
3aa8					; one value on hl get other one back 
3aa8			 
3aa8 e5					push hl 
3aa9			 
3aa9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa9 cd e0 22			call macro_forth_dsp_pop 
3aac				endm 
# End of macro FORTH_DSP_POP
3aac			 
3aac 0e 00				ld c, FORTH_FALSE 
3aae			 
3aae e1					pop hl 
3aaf d1					pop de 
3ab0			 
3ab0 7b					ld a, e 
3ab1 bd					cp l 
3ab2			 
3ab2 20 06				jr nz, .eq_done 
3ab4			 
3ab4 7a					ld a, d 
3ab5 bc					cp h 
3ab6			 
3ab6 20 02				jr nz, .eq_done 
3ab8			 
3ab8 0e 01				ld c, FORTH_TRUE 
3aba					 
3aba			 
3aba			 
3aba			.eq_done: 
3aba			 
3aba					; TODO push value back onto stack for another op etc 
3aba			 
3aba 26 00				ld h, 0 
3abc 69					ld l, c 
3abd					if DEBUG_FORTH_WORDS 
3abd						DMARK "EQ1" 
3abd f5				push af  
3abe 3a d2 3a			ld a, (.dmark)  
3ac1 32 a6 fd			ld (debug_mark),a  
3ac4 3a d3 3a			ld a, (.dmark+1)  
3ac7 32 a7 fd			ld (debug_mark+1),a  
3aca 3a d4 3a			ld a, (.dmark+2)  
3acd 32 a8 fd			ld (debug_mark+2),a  
3ad0 18 03			jr .pastdmark  
3ad2 ..			.dmark: db "EQ1"  
3ad5 f1			.pastdmark: pop af  
3ad6			endm  
# End of macro DMARK
3ad6						CALLMONITOR 
3ad6 cd aa fd			call debug_vector  
3ad9				endm  
# End of macro CALLMONITOR
3ad9					endif 
3ad9 cd 23 20				call forth_push_numhl 
3adc			 
3adc					NEXTW 
3adc c3 de 23			jp macro_next 
3adf				endm 
# End of macro NEXTW
3adf			 
3adf			 
3adf			.ENDLOGIC: 
3adf			; eof 
3adf			 
3adf			 
# End of file forth_words_logic.asm
3adf			include "forth_words_maths.asm" 
3adf			 
3adf			; | ## Maths Words 
3adf			 
3adf			.PLUS:	 
3adf				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3adf 15				db WORD_SYS_CORE+1             
3ae0 3d 3b			dw .NEG            
3ae2 02				db 1 + 1 
3ae3 .. 00			db "+",0              
3ae5				endm 
# End of macro CWHEAD
3ae5			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3ae5					if DEBUG_FORTH_WORDS_KEY 
3ae5						DMARK "PLU" 
3ae5 f5				push af  
3ae6 3a fa 3a			ld a, (.dmark)  
3ae9 32 a6 fd			ld (debug_mark),a  
3aec 3a fb 3a			ld a, (.dmark+1)  
3aef 32 a7 fd			ld (debug_mark+1),a  
3af2 3a fc 3a			ld a, (.dmark+2)  
3af5 32 a8 fd			ld (debug_mark+2),a  
3af8 18 03			jr .pastdmark  
3afa ..			.dmark: db "PLU"  
3afd f1			.pastdmark: pop af  
3afe			endm  
# End of macro DMARK
3afe						CALLMONITOR 
3afe cd aa fd			call debug_vector  
3b01				endm  
# End of macro CALLMONITOR
3b01					endif 
3b01					; add top two values and push back result 
3b01			 
3b01					;for v5 FORTH_DSP_VALUE 
3b01					FORTH_DSP 
3b01 cd ee 21			call macro_forth_dsp 
3b04				endm 
# End of macro FORTH_DSP
3b04 7e					ld a,(hl)	; get type of value on TOS 
3b05 fe 02				cp DS_TYPE_INUM  
3b07 28 03				jr z, .dot_inum 
3b09			 
3b09					NEXTW 
3b09 c3 de 23			jp macro_next 
3b0c				endm 
# End of macro NEXTW
3b0c			 
3b0c			; float maths 
3b0c			 
3b0c				if FORTH_ENABLE_FLOATMATH 
3b0c						inc hl      ; now at start of numeric as string 
3b0c			 
3b0c					if DEBUG_FORTH_MATHS 
3b0c						DMARK "ADD" 
3b0c				CALLMONITOR 
3b0c					endif 
3b0c			 
3b0c					;ld ix, hl 
3b0c					call CON 
3b0c			 
3b0c			 
3b0c					push hl 
3b0c					 
3b0c					 
3b0c			 
3b0c						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b0c			 
3b0c					; get next number 
3b0c			 
3b0c						FORTH_DSP_VALUE 
3b0c			 
3b0c						inc hl      ; now at start of numeric as string 
3b0c			 
3b0c					;ld ix, hl 
3b0c					call CON 
3b0c			 
3b0c					push hl 
3b0c			 
3b0c			 
3b0c						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0c			 
3b0c						; TODO do add 
3b0c			 
3b0c						call IADD 
3b0c			 
3b0c						; TODO get result back as ascii 
3b0c			 
3b0c						; TODO push result  
3b0c			 
3b0c			 
3b0c			 
3b0c						jr .dot_done 
3b0c				endif 
3b0c			 
3b0c			.dot_inum: 
3b0c			 
3b0c			 
3b0c					if DEBUG_FORTH_DOT 
3b0c						DMARK "+IT" 
3b0c f5				push af  
3b0d 3a 21 3b			ld a, (.dmark)  
3b10 32 a6 fd			ld (debug_mark),a  
3b13 3a 22 3b			ld a, (.dmark+1)  
3b16 32 a7 fd			ld (debug_mark+1),a  
3b19 3a 23 3b			ld a, (.dmark+2)  
3b1c 32 a8 fd			ld (debug_mark+2),a  
3b1f 18 03			jr .pastdmark  
3b21 ..			.dmark: db "+IT"  
3b24 f1			.pastdmark: pop af  
3b25			endm  
# End of macro DMARK
3b25				CALLMONITOR 
3b25 cd aa fd			call debug_vector  
3b28				endm  
# End of macro CALLMONITOR
3b28					endif 
3b28			 
3b28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b28 cd 28 22			call macro_dsp_valuehl 
3b2b				endm 
# End of macro FORTH_DSP_VALUEHL
3b2b			 
3b2b				; TODO add floating point number detection 
3b2b			 
3b2b e5					push hl 
3b2c			 
3b2c					; destroy value TOS 
3b2c			 
3b2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2c cd e0 22			call macro_forth_dsp_pop 
3b2f				endm 
# End of macro FORTH_DSP_POP
3b2f			 
3b2f			 
3b2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b2f cd 28 22			call macro_dsp_valuehl 
3b32				endm 
# End of macro FORTH_DSP_VALUEHL
3b32			 
3b32					; one value on hl get other one back 
3b32			 
3b32 d1					pop de 
3b33			 
3b33					; do the add 
3b33			 
3b33 19					add hl,de 
3b34			 
3b34					; save it 
3b34			 
3b34			;		push hl	 
3b34			 
3b34					; 
3b34			 
3b34					; destroy value TOS 
3b34			 
3b34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b34 cd e0 22			call macro_forth_dsp_pop 
3b37				endm 
# End of macro FORTH_DSP_POP
3b37			 
3b37					; TODO push value back onto stack for another op etc 
3b37			 
3b37			;		pop hl 
3b37			 
3b37			.dot_done: 
3b37 cd 23 20				call forth_push_numhl 
3b3a			 
3b3a					NEXTW 
3b3a c3 de 23			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d			.NEG: 
3b3d			 
3b3d				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b3d 17				db WORD_SYS_CORE+3             
3b3e 80 3b			dw .DIV            
3b40 02				db 1 + 1 
3b41 .. 00			db "-",0              
3b43				endm 
# End of macro CWHEAD
3b43			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b43					if DEBUG_FORTH_WORDS_KEY 
3b43						DMARK "SUB" 
3b43 f5				push af  
3b44 3a 58 3b			ld a, (.dmark)  
3b47 32 a6 fd			ld (debug_mark),a  
3b4a 3a 59 3b			ld a, (.dmark+1)  
3b4d 32 a7 fd			ld (debug_mark+1),a  
3b50 3a 5a 3b			ld a, (.dmark+2)  
3b53 32 a8 fd			ld (debug_mark+2),a  
3b56 18 03			jr .pastdmark  
3b58 ..			.dmark: db "SUB"  
3b5b f1			.pastdmark: pop af  
3b5c			endm  
# End of macro DMARK
3b5c						CALLMONITOR 
3b5c cd aa fd			call debug_vector  
3b5f				endm  
# End of macro CALLMONITOR
3b5f					endif 
3b5f			 
3b5f			 
3b5f				; TODO add floating point number detection 
3b5f					; v5 FORTH_DSP_VALUE 
3b5f					FORTH_DSP 
3b5f cd ee 21			call macro_forth_dsp 
3b62				endm 
# End of macro FORTH_DSP
3b62 7e					ld a,(hl)	; get type of value on TOS 
3b63 fe 02				cp DS_TYPE_INUM  
3b65 28 03				jr z, .neg_inum 
3b67			 
3b67					NEXTW 
3b67 c3 de 23			jp macro_next 
3b6a				endm 
# End of macro NEXTW
3b6a			 
3b6a			; float maths 
3b6a			 
3b6a				if FORTH_ENABLE_FLOATMATH 
3b6a					jr .neg_done 
3b6a			 
3b6a				endif 
3b6a					 
3b6a			 
3b6a			.neg_inum: 
3b6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b6a cd 28 22			call macro_dsp_valuehl 
3b6d				endm 
# End of macro FORTH_DSP_VALUEHL
3b6d			 
3b6d e5					push hl 
3b6e			 
3b6e					; destroy value TOS 
3b6e			 
3b6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b6e cd e0 22			call macro_forth_dsp_pop 
3b71				endm 
# End of macro FORTH_DSP_POP
3b71			 
3b71			 
3b71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b71 cd 28 22			call macro_dsp_valuehl 
3b74				endm 
# End of macro FORTH_DSP_VALUEHL
3b74			 
3b74					; one value on hl get other one back 
3b74			 
3b74 d1					pop de 
3b75			 
3b75					; do the sub 
3b75			;		ex de, hl 
3b75			 
3b75 ed 52				sbc hl,de 
3b77			 
3b77					; save it 
3b77			 
3b77			;		push hl	 
3b77			 
3b77					; 
3b77			 
3b77					; destroy value TOS 
3b77			 
3b77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b77 cd e0 22			call macro_forth_dsp_pop 
3b7a				endm 
# End of macro FORTH_DSP_POP
3b7a			 
3b7a					; TODO push value back onto stack for another op etc 
3b7a			 
3b7a			;		pop hl 
3b7a			 
3b7a cd 23 20				call forth_push_numhl 
3b7d			.neg_done: 
3b7d			 
3b7d					NEXTW 
3b7d c3 de 23			jp macro_next 
3b80				endm 
# End of macro NEXTW
3b80			.DIV: 
3b80				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b80 18				db WORD_SYS_CORE+4             
3b81 cd 3b			dw .MUL            
3b83 02				db 1 + 1 
3b84 .. 00			db "/",0              
3b86				endm 
# End of macro CWHEAD
3b86			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b86					if DEBUG_FORTH_WORDS_KEY 
3b86						DMARK "DIV" 
3b86 f5				push af  
3b87 3a 9b 3b			ld a, (.dmark)  
3b8a 32 a6 fd			ld (debug_mark),a  
3b8d 3a 9c 3b			ld a, (.dmark+1)  
3b90 32 a7 fd			ld (debug_mark+1),a  
3b93 3a 9d 3b			ld a, (.dmark+2)  
3b96 32 a8 fd			ld (debug_mark+2),a  
3b99 18 03			jr .pastdmark  
3b9b ..			.dmark: db "DIV"  
3b9e f1			.pastdmark: pop af  
3b9f			endm  
# End of macro DMARK
3b9f						CALLMONITOR 
3b9f cd aa fd			call debug_vector  
3ba2				endm  
# End of macro CALLMONITOR
3ba2					endif 
3ba2				; TODO add floating point number detection 
3ba2					; v5 FORTH_DSP_VALUE 
3ba2					FORTH_DSP 
3ba2 cd ee 21			call macro_forth_dsp 
3ba5				endm 
# End of macro FORTH_DSP
3ba5 7e					ld a,(hl)	; get type of value on TOS 
3ba6 fe 02				cp DS_TYPE_INUM  
3ba8 28 03				jr z, .div_inum 
3baa			 
3baa				if FORTH_ENABLE_FLOATMATH 
3baa					jr .div_done 
3baa			 
3baa				endif 
3baa					NEXTW 
3baa c3 de 23			jp macro_next 
3bad				endm 
# End of macro NEXTW
3bad			.div_inum: 
3bad			 
3bad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bad cd 28 22			call macro_dsp_valuehl 
3bb0				endm 
# End of macro FORTH_DSP_VALUEHL
3bb0			 
3bb0 e5					push hl    ; to go to bc 
3bb1			 
3bb1					; destroy value TOS 
3bb1			 
3bb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb1 cd e0 22			call macro_forth_dsp_pop 
3bb4				endm 
# End of macro FORTH_DSP_POP
3bb4			 
3bb4			 
3bb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb4 cd 28 22			call macro_dsp_valuehl 
3bb7				endm 
# End of macro FORTH_DSP_VALUEHL
3bb7			 
3bb7					; hl to go to de 
3bb7			 
3bb7 e5					push hl 
3bb8			 
3bb8 c1					pop bc 
3bb9 d1					pop de		 
3bba			 
3bba			 
3bba					if DEBUG_FORTH_MATHS 
3bba						DMARK "DIV" 
3bba				CALLMONITOR 
3bba					endif 
3bba					; one value on hl but move to a get other one back 
3bba			 
3bba			        
3bba cd 2c 0f			call Div16 
3bbd			 
3bbd			;	push af	 
3bbd e5				push hl 
3bbe c5				push bc 
3bbf			 
3bbf					if DEBUG_FORTH_MATHS 
3bbf						DMARK "DI1" 
3bbf				CALLMONITOR 
3bbf					endif 
3bbf			 
3bbf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bbf cd e0 22			call macro_forth_dsp_pop 
3bc2				endm 
# End of macro FORTH_DSP_POP
3bc2			 
3bc2			 
3bc2			 
3bc2 e1					pop hl    ; result 
3bc3			 
3bc3 cd 23 20				call forth_push_numhl 
3bc6			 
3bc6 e1					pop hl    ; reminder 
3bc7			;		ld h,0 
3bc7			;		ld l,d 
3bc7			 
3bc7 cd 23 20				call forth_push_numhl 
3bca			.div_done: 
3bca					NEXTW 
3bca c3 de 23			jp macro_next 
3bcd				endm 
# End of macro NEXTW
3bcd			.MUL: 
3bcd				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3bcd 19				db WORD_SYS_CORE+5             
3bce 12 3c			dw .MIN            
3bd0 02				db 1 + 1 
3bd1 .. 00			db "*",0              
3bd3				endm 
# End of macro CWHEAD
3bd3			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bd3				; TODO add floating point number detection 
3bd3					if DEBUG_FORTH_WORDS_KEY 
3bd3						DMARK "MUL" 
3bd3 f5				push af  
3bd4 3a e8 3b			ld a, (.dmark)  
3bd7 32 a6 fd			ld (debug_mark),a  
3bda 3a e9 3b			ld a, (.dmark+1)  
3bdd 32 a7 fd			ld (debug_mark+1),a  
3be0 3a ea 3b			ld a, (.dmark+2)  
3be3 32 a8 fd			ld (debug_mark+2),a  
3be6 18 03			jr .pastdmark  
3be8 ..			.dmark: db "MUL"  
3beb f1			.pastdmark: pop af  
3bec			endm  
# End of macro DMARK
3bec						CALLMONITOR 
3bec cd aa fd			call debug_vector  
3bef				endm  
# End of macro CALLMONITOR
3bef					endif 
3bef					FORTH_DSP 
3bef cd ee 21			call macro_forth_dsp 
3bf2				endm 
# End of macro FORTH_DSP
3bf2					; v5 FORTH_DSP_VALUE 
3bf2 7e					ld a,(hl)	; get type of value on TOS 
3bf3 fe 02				cp DS_TYPE_INUM  
3bf5 28 03				jr z, .mul_inum 
3bf7			 
3bf7				if FORTH_ENABLE_FLOATMATH 
3bf7					jr .mul_done 
3bf7			 
3bf7				endif 
3bf7			 
3bf7					NEXTW 
3bf7 c3 de 23			jp macro_next 
3bfa				endm 
# End of macro NEXTW
3bfa			.mul_inum:	 
3bfa			 
3bfa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bfa cd 28 22			call macro_dsp_valuehl 
3bfd				endm 
# End of macro FORTH_DSP_VALUEHL
3bfd			 
3bfd e5					push hl 
3bfe			 
3bfe					; destroy value TOS 
3bfe			 
3bfe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfe cd e0 22			call macro_forth_dsp_pop 
3c01				endm 
# End of macro FORTH_DSP_POP
3c01			 
3c01			 
3c01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c01 cd 28 22			call macro_dsp_valuehl 
3c04				endm 
# End of macro FORTH_DSP_VALUEHL
3c04			 
3c04					; one value on hl but move to a get other one back 
3c04			 
3c04 7d					ld a, l 
3c05			 
3c05 d1					pop de 
3c06			 
3c06					; do the mull 
3c06			;		ex de, hl 
3c06			 
3c06 cd 52 0f				call Mult16 
3c09					; save it 
3c09			 
3c09			;		push hl	 
3c09			 
3c09					; 
3c09			 
3c09					; destroy value TOS 
3c09			 
3c09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c09 cd e0 22			call macro_forth_dsp_pop 
3c0c				endm 
# End of macro FORTH_DSP_POP
3c0c			 
3c0c					; TODO push value back onto stack for another op etc 
3c0c			 
3c0c			;		pop hl 
3c0c			 
3c0c cd 23 20				call forth_push_numhl 
3c0f			 
3c0f			.mul_done: 
3c0f					NEXTW 
3c0f c3 de 23			jp macro_next 
3c12				endm 
# End of macro NEXTW
3c12			 
3c12			 
3c12			 
3c12			 
3c12			.MIN: 
3c12				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c12 49				db WORD_SYS_CORE+53             
3c13 93 3c			dw .MAX            
3c15 04				db 3 + 1 
3c16 .. 00			db "MIN",0              
3c1a				endm 
# End of macro CWHEAD
3c1a			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c1a					if DEBUG_FORTH_WORDS_KEY 
3c1a						DMARK "MIN" 
3c1a f5				push af  
3c1b 3a 2f 3c			ld a, (.dmark)  
3c1e 32 a6 fd			ld (debug_mark),a  
3c21 3a 30 3c			ld a, (.dmark+1)  
3c24 32 a7 fd			ld (debug_mark+1),a  
3c27 3a 31 3c			ld a, (.dmark+2)  
3c2a 32 a8 fd			ld (debug_mark+2),a  
3c2d 18 03			jr .pastdmark  
3c2f ..			.dmark: db "MIN"  
3c32 f1			.pastdmark: pop af  
3c33			endm  
# End of macro DMARK
3c33						CALLMONITOR 
3c33 cd aa fd			call debug_vector  
3c36				endm  
# End of macro CALLMONITOR
3c36					endif 
3c36					; get u2 
3c36			 
3c36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c36 cd 28 22			call macro_dsp_valuehl 
3c39				endm 
# End of macro FORTH_DSP_VALUEHL
3c39			 
3c39 e5					push hl   ; u2 
3c3a			 
3c3a					; destroy value TOS 
3c3a			 
3c3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3a cd e0 22			call macro_forth_dsp_pop 
3c3d				endm 
# End of macro FORTH_DSP_POP
3c3d			 
3c3d					; get u1 
3c3d			 
3c3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3d cd 28 22			call macro_dsp_valuehl 
3c40				endm 
# End of macro FORTH_DSP_VALUEHL
3c40			 
3c40 e5					push hl  ; u1 
3c41			 
3c41					; destroy value TOS 
3c41			 
3c41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c41 cd e0 22			call macro_forth_dsp_pop 
3c44				endm 
# End of macro FORTH_DSP_POP
3c44			 
3c44 b7			 or a      ;clear carry flag 
3c45 e1			  pop hl    ; u1 
3c46 d1			  pop de    ; u2 
3c47 e5				push hl   ; saved in case hl is lowest 
3c48 ed 52		  sbc hl,de 
3c4a 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c4c			 
3c4c e1				pop hl 
3c4d					if DEBUG_FORTH_WORDS 
3c4d						DMARK "MIN" 
3c4d f5				push af  
3c4e 3a 62 3c			ld a, (.dmark)  
3c51 32 a6 fd			ld (debug_mark),a  
3c54 3a 63 3c			ld a, (.dmark+1)  
3c57 32 a7 fd			ld (debug_mark+1),a  
3c5a 3a 64 3c			ld a, (.dmark+2)  
3c5d 32 a8 fd			ld (debug_mark+2),a  
3c60 18 03			jr .pastdmark  
3c62 ..			.dmark: db "MIN"  
3c65 f1			.pastdmark: pop af  
3c66			endm  
# End of macro DMARK
3c66						CALLMONITOR 
3c66 cd aa fd			call debug_vector  
3c69				endm  
# End of macro CALLMONITOR
3c69					endif 
3c69 cd 23 20				call forth_push_numhl 
3c6c			 
3c6c				       NEXTW 
3c6c c3 de 23			jp macro_next 
3c6f				endm 
# End of macro NEXTW
3c6f			 
3c6f			.mincont:  
3c6f c1				pop bc   ; tidy up 
3c70 eb				ex de , hl  
3c71					if DEBUG_FORTH_WORDS 
3c71						DMARK "MI1" 
3c71 f5				push af  
3c72 3a 86 3c			ld a, (.dmark)  
3c75 32 a6 fd			ld (debug_mark),a  
3c78 3a 87 3c			ld a, (.dmark+1)  
3c7b 32 a7 fd			ld (debug_mark+1),a  
3c7e 3a 88 3c			ld a, (.dmark+2)  
3c81 32 a8 fd			ld (debug_mark+2),a  
3c84 18 03			jr .pastdmark  
3c86 ..			.dmark: db "MI1"  
3c89 f1			.pastdmark: pop af  
3c8a			endm  
# End of macro DMARK
3c8a						CALLMONITOR 
3c8a cd aa fd			call debug_vector  
3c8d				endm  
# End of macro CALLMONITOR
3c8d					endif 
3c8d cd 23 20				call forth_push_numhl 
3c90			 
3c90				       NEXTW 
3c90 c3 de 23			jp macro_next 
3c93				endm 
# End of macro NEXTW
3c93			.MAX: 
3c93				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c93 4a				db WORD_SYS_CORE+54             
3c94 14 3d			dw .RND16            
3c96 04				db 3 + 1 
3c97 .. 00			db "MAX",0              
3c9b				endm 
# End of macro CWHEAD
3c9b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c9b					if DEBUG_FORTH_WORDS_KEY 
3c9b						DMARK "MAX" 
3c9b f5				push af  
3c9c 3a b0 3c			ld a, (.dmark)  
3c9f 32 a6 fd			ld (debug_mark),a  
3ca2 3a b1 3c			ld a, (.dmark+1)  
3ca5 32 a7 fd			ld (debug_mark+1),a  
3ca8 3a b2 3c			ld a, (.dmark+2)  
3cab 32 a8 fd			ld (debug_mark+2),a  
3cae 18 03			jr .pastdmark  
3cb0 ..			.dmark: db "MAX"  
3cb3 f1			.pastdmark: pop af  
3cb4			endm  
# End of macro DMARK
3cb4						CALLMONITOR 
3cb4 cd aa fd			call debug_vector  
3cb7				endm  
# End of macro CALLMONITOR
3cb7					endif 
3cb7					; get u2 
3cb7			 
3cb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb7 cd 28 22			call macro_dsp_valuehl 
3cba				endm 
# End of macro FORTH_DSP_VALUEHL
3cba			 
3cba e5					push hl   ; u2 
3cbb			 
3cbb					; destroy value TOS 
3cbb			 
3cbb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cbb cd e0 22			call macro_forth_dsp_pop 
3cbe				endm 
# End of macro FORTH_DSP_POP
3cbe			 
3cbe					; get u1 
3cbe			 
3cbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cbe cd 28 22			call macro_dsp_valuehl 
3cc1				endm 
# End of macro FORTH_DSP_VALUEHL
3cc1			 
3cc1 e5					push hl  ; u1 
3cc2			 
3cc2					; destroy value TOS 
3cc2			 
3cc2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc2 cd e0 22			call macro_forth_dsp_pop 
3cc5				endm 
# End of macro FORTH_DSP_POP
3cc5			 
3cc5 b7			 or a      ;clear carry flag 
3cc6 e1			  pop hl    ; u1 
3cc7 d1			  pop de    ; u2 
3cc8 e5				push hl   ; saved in case hl is lowest 
3cc9 ed 52		  sbc hl,de 
3ccb 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3ccd			 
3ccd e1				pop hl 
3cce					if DEBUG_FORTH_WORDS 
3cce						DMARK "MAX" 
3cce f5				push af  
3ccf 3a e3 3c			ld a, (.dmark)  
3cd2 32 a6 fd			ld (debug_mark),a  
3cd5 3a e4 3c			ld a, (.dmark+1)  
3cd8 32 a7 fd			ld (debug_mark+1),a  
3cdb 3a e5 3c			ld a, (.dmark+2)  
3cde 32 a8 fd			ld (debug_mark+2),a  
3ce1 18 03			jr .pastdmark  
3ce3 ..			.dmark: db "MAX"  
3ce6 f1			.pastdmark: pop af  
3ce7			endm  
# End of macro DMARK
3ce7						CALLMONITOR 
3ce7 cd aa fd			call debug_vector  
3cea				endm  
# End of macro CALLMONITOR
3cea					endif 
3cea cd 23 20				call forth_push_numhl 
3ced			 
3ced				       NEXTW 
3ced c3 de 23			jp macro_next 
3cf0				endm 
# End of macro NEXTW
3cf0			 
3cf0			.maxcont:  
3cf0 c1				pop bc   ; tidy up 
3cf1 eb				ex de , hl  
3cf2					if DEBUG_FORTH_WORDS 
3cf2						DMARK "MA1" 
3cf2 f5				push af  
3cf3 3a 07 3d			ld a, (.dmark)  
3cf6 32 a6 fd			ld (debug_mark),a  
3cf9 3a 08 3d			ld a, (.dmark+1)  
3cfc 32 a7 fd			ld (debug_mark+1),a  
3cff 3a 09 3d			ld a, (.dmark+2)  
3d02 32 a8 fd			ld (debug_mark+2),a  
3d05 18 03			jr .pastdmark  
3d07 ..			.dmark: db "MA1"  
3d0a f1			.pastdmark: pop af  
3d0b			endm  
# End of macro DMARK
3d0b						CALLMONITOR 
3d0b cd aa fd			call debug_vector  
3d0e				endm  
# End of macro CALLMONITOR
3d0e					endif 
3d0e cd 23 20				call forth_push_numhl 
3d11				       NEXTW 
3d11 c3 de 23			jp macro_next 
3d14				endm 
# End of macro NEXTW
3d14			 
3d14			.RND16: 
3d14				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d14 4e				db WORD_SYS_CORE+58             
3d15 43 3d			dw .RND8            
3d17 06				db 5 + 1 
3d18 .. 00			db "RND16",0              
3d1e				endm 
# End of macro CWHEAD
3d1e			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d1e					if DEBUG_FORTH_WORDS_KEY 
3d1e						DMARK "R16" 
3d1e f5				push af  
3d1f 3a 33 3d			ld a, (.dmark)  
3d22 32 a6 fd			ld (debug_mark),a  
3d25 3a 34 3d			ld a, (.dmark+1)  
3d28 32 a7 fd			ld (debug_mark+1),a  
3d2b 3a 35 3d			ld a, (.dmark+2)  
3d2e 32 a8 fd			ld (debug_mark+2),a  
3d31 18 03			jr .pastdmark  
3d33 ..			.dmark: db "R16"  
3d36 f1			.pastdmark: pop af  
3d37			endm  
# End of macro DMARK
3d37						CALLMONITOR 
3d37 cd aa fd			call debug_vector  
3d3a				endm  
# End of macro CALLMONITOR
3d3a					endif 
3d3a cd f6 0e				call prng16  
3d3d cd 23 20				call forth_push_numhl 
3d40				       NEXTW 
3d40 c3 de 23			jp macro_next 
3d43				endm 
# End of macro NEXTW
3d43			.RND8: 
3d43				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d43 60				db WORD_SYS_CORE+76             
3d44 78 3d			dw .RND            
3d46 05				db 4 + 1 
3d47 .. 00			db "RND8",0              
3d4c				endm 
# End of macro CWHEAD
3d4c			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d4c					if DEBUG_FORTH_WORDS_KEY 
3d4c						DMARK "RN8" 
3d4c f5				push af  
3d4d 3a 61 3d			ld a, (.dmark)  
3d50 32 a6 fd			ld (debug_mark),a  
3d53 3a 62 3d			ld a, (.dmark+1)  
3d56 32 a7 fd			ld (debug_mark+1),a  
3d59 3a 63 3d			ld a, (.dmark+2)  
3d5c 32 a8 fd			ld (debug_mark+2),a  
3d5f 18 03			jr .pastdmark  
3d61 ..			.dmark: db "RN8"  
3d64 f1			.pastdmark: pop af  
3d65			endm  
# End of macro DMARK
3d65						CALLMONITOR 
3d65 cd aa fd			call debug_vector  
3d68				endm  
# End of macro CALLMONITOR
3d68					endif 
3d68 2a e4 fa				ld hl,(xrandc) 
3d6b 23					inc hl 
3d6c cd 10 0f				call xrnd 
3d6f 6f					ld l,a	 
3d70 26 00				ld h,0 
3d72 cd 23 20				call forth_push_numhl 
3d75				       NEXTW 
3d75 c3 de 23			jp macro_next 
3d78				endm 
# End of macro NEXTW
3d78			.RND: 
3d78				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d78 60				db WORD_SYS_CORE+76             
3d79 7e 3e			dw .ENDMATHS            
3d7b 04				db 3 + 1 
3d7c .. 00			db "RND",0              
3d80				endm 
# End of macro CWHEAD
3d80			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d80			 
3d80					if DEBUG_FORTH_WORDS_KEY 
3d80						DMARK "RND" 
3d80 f5				push af  
3d81 3a 95 3d			ld a, (.dmark)  
3d84 32 a6 fd			ld (debug_mark),a  
3d87 3a 96 3d			ld a, (.dmark+1)  
3d8a 32 a7 fd			ld (debug_mark+1),a  
3d8d 3a 97 3d			ld a, (.dmark+2)  
3d90 32 a8 fd			ld (debug_mark+2),a  
3d93 18 03			jr .pastdmark  
3d95 ..			.dmark: db "RND"  
3d98 f1			.pastdmark: pop af  
3d99			endm  
# End of macro DMARK
3d99						CALLMONITOR 
3d99 cd aa fd			call debug_vector  
3d9c				endm  
# End of macro CALLMONITOR
3d9c					endif 
3d9c					 
3d9c					FORTH_DSP_VALUEHL    ; upper range 
3d9c cd 28 22			call macro_dsp_valuehl 
3d9f				endm 
# End of macro FORTH_DSP_VALUEHL
3d9f			 
3d9f 22 e8 fa				ld (LFSRSeed), hl	 
3da2			 
3da2					if DEBUG_FORTH_WORDS 
3da2						DMARK "RN1" 
3da2 f5				push af  
3da3 3a b7 3d			ld a, (.dmark)  
3da6 32 a6 fd			ld (debug_mark),a  
3da9 3a b8 3d			ld a, (.dmark+1)  
3dac 32 a7 fd			ld (debug_mark+1),a  
3daf 3a b9 3d			ld a, (.dmark+2)  
3db2 32 a8 fd			ld (debug_mark+2),a  
3db5 18 03			jr .pastdmark  
3db7 ..			.dmark: db "RN1"  
3dba f1			.pastdmark: pop af  
3dbb			endm  
# End of macro DMARK
3dbb						CALLMONITOR 
3dbb cd aa fd			call debug_vector  
3dbe				endm  
# End of macro CALLMONITOR
3dbe					endif 
3dbe					FORTH_DSP_POP 
3dbe cd e0 22			call macro_forth_dsp_pop 
3dc1				endm 
# End of macro FORTH_DSP_POP
3dc1			 
3dc1					FORTH_DSP_VALUEHL    ; low range 
3dc1 cd 28 22			call macro_dsp_valuehl 
3dc4				endm 
# End of macro FORTH_DSP_VALUEHL
3dc4			 
3dc4					if DEBUG_FORTH_WORDS 
3dc4						DMARK "RN2" 
3dc4 f5				push af  
3dc5 3a d9 3d			ld a, (.dmark)  
3dc8 32 a6 fd			ld (debug_mark),a  
3dcb 3a da 3d			ld a, (.dmark+1)  
3dce 32 a7 fd			ld (debug_mark+1),a  
3dd1 3a db 3d			ld a, (.dmark+2)  
3dd4 32 a8 fd			ld (debug_mark+2),a  
3dd7 18 03			jr .pastdmark  
3dd9 ..			.dmark: db "RN2"  
3ddc f1			.pastdmark: pop af  
3ddd			endm  
# End of macro DMARK
3ddd						CALLMONITOR 
3ddd cd aa fd			call debug_vector  
3de0				endm  
# End of macro CALLMONITOR
3de0					endif 
3de0 22 ea fa				ld (LFSRSeed+2), hl 
3de3			 
3de3					FORTH_DSP_POP 
3de3 cd e0 22			call macro_forth_dsp_pop 
3de6				endm 
# End of macro FORTH_DSP_POP
3de6			 
3de6 e5					push hl 
3de7			 
3de7 e1			.inrange:	pop hl 
3de8 cd f6 0e				call prng16  
3deb					if DEBUG_FORTH_WORDS 
3deb						DMARK "RN3" 
3deb f5				push af  
3dec 3a 00 3e			ld a, (.dmark)  
3def 32 a6 fd			ld (debug_mark),a  
3df2 3a 01 3e			ld a, (.dmark+1)  
3df5 32 a7 fd			ld (debug_mark+1),a  
3df8 3a 02 3e			ld a, (.dmark+2)  
3dfb 32 a8 fd			ld (debug_mark+2),a  
3dfe 18 03			jr .pastdmark  
3e00 ..			.dmark: db "RN3"  
3e03 f1			.pastdmark: pop af  
3e04			endm  
# End of macro DMARK
3e04						CALLMONITOR 
3e04 cd aa fd			call debug_vector  
3e07				endm  
# End of macro CALLMONITOR
3e07					endif 
3e07					 
3e07					; if the range is 8bit knock out the high byte 
3e07			 
3e07 ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
3e0b			 
3e0b 3e 00				ld a, 0 
3e0d ba					cp d  
3e0e 20 1e				jr nz, .hirange 
3e10 26 00				ld h, 0   ; knock it down to 8bit 
3e12			 
3e12					if DEBUG_FORTH_WORDS 
3e12						DMARK "RNk" 
3e12 f5				push af  
3e13 3a 27 3e			ld a, (.dmark)  
3e16 32 a6 fd			ld (debug_mark),a  
3e19 3a 28 3e			ld a, (.dmark+1)  
3e1c 32 a7 fd			ld (debug_mark+1),a  
3e1f 3a 29 3e			ld a, (.dmark+2)  
3e22 32 a8 fd			ld (debug_mark+2),a  
3e25 18 03			jr .pastdmark  
3e27 ..			.dmark: db "RNk"  
3e2a f1			.pastdmark: pop af  
3e2b			endm  
# End of macro DMARK
3e2b						CALLMONITOR 
3e2b cd aa fd			call debug_vector  
3e2e				endm  
# End of macro CALLMONITOR
3e2e					endif 
3e2e			.hirange:   
3e2e e5					push hl  
3e2f b7					or a  
3e30 ed 52		                sbc hl, de 
3e32			 
3e32					;call cmp16 
3e32			 
3e32 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e34 e1					pop hl 
3e35 e5					push hl 
3e36			 
3e36					if DEBUG_FORTH_WORDS 
3e36						DMARK "RN4" 
3e36 f5				push af  
3e37 3a 4b 3e			ld a, (.dmark)  
3e3a 32 a6 fd			ld (debug_mark),a  
3e3d 3a 4c 3e			ld a, (.dmark+1)  
3e40 32 a7 fd			ld (debug_mark+1),a  
3e43 3a 4d 3e			ld a, (.dmark+2)  
3e46 32 a8 fd			ld (debug_mark+2),a  
3e49 18 03			jr .pastdmark  
3e4b ..			.dmark: db "RN4"  
3e4e f1			.pastdmark: pop af  
3e4f			endm  
# End of macro DMARK
3e4f						CALLMONITOR 
3e4f cd aa fd			call debug_vector  
3e52				endm  
# End of macro CALLMONITOR
3e52					endif 
3e52 ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
3e56					;call cmp16 
3e56				 
3e56 b7					or a  
3e57 ed 52		                sbc hl, de 
3e59 38 8c				jr c, .inrange 
3e5b			 
3e5b e1					pop hl 
3e5c					 
3e5c					if DEBUG_FORTH_WORDS 
3e5c						DMARK "RNd" 
3e5c f5				push af  
3e5d 3a 71 3e			ld a, (.dmark)  
3e60 32 a6 fd			ld (debug_mark),a  
3e63 3a 72 3e			ld a, (.dmark+1)  
3e66 32 a7 fd			ld (debug_mark+1),a  
3e69 3a 73 3e			ld a, (.dmark+2)  
3e6c 32 a8 fd			ld (debug_mark+2),a  
3e6f 18 03			jr .pastdmark  
3e71 ..			.dmark: db "RNd"  
3e74 f1			.pastdmark: pop af  
3e75			endm  
# End of macro DMARK
3e75						CALLMONITOR 
3e75 cd aa fd			call debug_vector  
3e78				endm  
# End of macro CALLMONITOR
3e78					endif 
3e78			 
3e78			 
3e78 cd 23 20				call forth_push_numhl 
3e7b				       NEXTW 
3e7b c3 de 23			jp macro_next 
3e7e				endm 
# End of macro NEXTW
3e7e			 
3e7e			.ENDMATHS: 
3e7e			 
3e7e			; eof 
3e7e			 
# End of file forth_words_maths.asm
3e7e			include "forth_words_display.asm" 
3e7e			 
3e7e			; | ## Display Words 
3e7e			 
3e7e			.ACT: 
3e7e			 
3e7e				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e7e 62				db WORD_SYS_CORE+78             
3e7f ca 3e			dw .INFO            
3e81 07				db 6 + 1 
3e82 .. 00			db "ACTIVE",0              
3e89				endm 
# End of macro CWHEAD
3e89			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3e89			;  
3e89			; | | To display a pulsing activity indicator in a processing loop do this... 
3e89			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3e89			 
3e89					if DEBUG_FORTH_WORDS_KEY 
3e89						DMARK "ACT" 
3e89 f5				push af  
3e8a 3a 9e 3e			ld a, (.dmark)  
3e8d 32 a6 fd			ld (debug_mark),a  
3e90 3a 9f 3e			ld a, (.dmark+1)  
3e93 32 a7 fd			ld (debug_mark+1),a  
3e96 3a a0 3e			ld a, (.dmark+2)  
3e99 32 a8 fd			ld (debug_mark+2),a  
3e9c 18 03			jr .pastdmark  
3e9e ..			.dmark: db "ACT"  
3ea1 f1			.pastdmark: pop af  
3ea2			endm  
# End of macro DMARK
3ea2						CALLMONITOR 
3ea2 cd aa fd			call debug_vector  
3ea5				endm  
# End of macro CALLMONITOR
3ea5					endif 
3ea5 cd f2 0c				call active 
3ea8					if DEBUG_FORTH_WORDS 
3ea8						DMARK "ACp" 
3ea8 f5				push af  
3ea9 3a bd 3e			ld a, (.dmark)  
3eac 32 a6 fd			ld (debug_mark),a  
3eaf 3a be 3e			ld a, (.dmark+1)  
3eb2 32 a7 fd			ld (debug_mark+1),a  
3eb5 3a bf 3e			ld a, (.dmark+2)  
3eb8 32 a8 fd			ld (debug_mark+2),a  
3ebb 18 03			jr .pastdmark  
3ebd ..			.dmark: db "ACp"  
3ec0 f1			.pastdmark: pop af  
3ec1			endm  
# End of macro DMARK
3ec1						CALLMONITOR 
3ec1 cd aa fd			call debug_vector  
3ec4				endm  
# End of macro CALLMONITOR
3ec4					endif 
3ec4 cd 91 20				call forth_push_str 
3ec7			 
3ec7					NEXTW 
3ec7 c3 de 23			jp macro_next 
3eca				endm 
# End of macro NEXTW
3eca			.INFO: 
3eca			 
3eca				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3eca 62				db WORD_SYS_CORE+78             
3ecb e7 3e			dw .ATP            
3ecd 05				db 4 + 1 
3ece .. 00			db "INFO",0              
3ed3				endm 
# End of macro CWHEAD
3ed3			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ed3					FORTH_DSP_VALUEHL 
3ed3 cd 28 22			call macro_dsp_valuehl 
3ed6				endm 
# End of macro FORTH_DSP_VALUEHL
3ed6			 
3ed6					FORTH_DSP_POP 
3ed6 cd e0 22			call macro_forth_dsp_pop 
3ed9				endm 
# End of macro FORTH_DSP_POP
3ed9			 
3ed9 e5					push hl 
3eda			 
3eda					FORTH_DSP_VALUEHL 
3eda cd 28 22			call macro_dsp_valuehl 
3edd				endm 
# End of macro FORTH_DSP_VALUEHL
3edd			 
3edd					FORTH_DSP_POP 
3edd cd e0 22			call macro_forth_dsp_pop 
3ee0				endm 
# End of macro FORTH_DSP_POP
3ee0			 
3ee0 d1					pop de 
3ee1			 
3ee1 cd 2c 0d				call info_panel 
3ee4			 
3ee4			 
3ee4					NEXTW 
3ee4 c3 de 23			jp macro_next 
3ee7				endm 
# End of macro NEXTW
3ee7			.ATP: 
3ee7				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ee7 62				db WORD_SYS_CORE+78             
3ee8 5e 3f			dw .FB            
3eea 04				db 3 + 1 
3eeb .. 00			db "AT?",0              
3eef				endm 
# End of macro CWHEAD
3eef			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3eef					if DEBUG_FORTH_WORDS_KEY 
3eef						DMARK "AT?" 
3eef f5				push af  
3ef0 3a 04 3f			ld a, (.dmark)  
3ef3 32 a6 fd			ld (debug_mark),a  
3ef6 3a 05 3f			ld a, (.dmark+1)  
3ef9 32 a7 fd			ld (debug_mark+1),a  
3efc 3a 06 3f			ld a, (.dmark+2)  
3eff 32 a8 fd			ld (debug_mark+2),a  
3f02 18 03			jr .pastdmark  
3f04 ..			.dmark: db "AT?"  
3f07 f1			.pastdmark: pop af  
3f08			endm  
# End of macro DMARK
3f08						CALLMONITOR 
3f08 cd aa fd			call debug_vector  
3f0b				endm  
# End of macro CALLMONITOR
3f0b					endif 
3f0b 3a 99 f9				ld a, (f_cursor_ptr) 
3f0e			 
3f0e			if DEBUG_FORTH_WORDS 
3f0e				DMARK "AT?" 
3f0e f5				push af  
3f0f 3a 23 3f			ld a, (.dmark)  
3f12 32 a6 fd			ld (debug_mark),a  
3f15 3a 24 3f			ld a, (.dmark+1)  
3f18 32 a7 fd			ld (debug_mark+1),a  
3f1b 3a 25 3f			ld a, (.dmark+2)  
3f1e 32 a8 fd			ld (debug_mark+2),a  
3f21 18 03			jr .pastdmark  
3f23 ..			.dmark: db "AT?"  
3f26 f1			.pastdmark: pop af  
3f27			endm  
# End of macro DMARK
3f27				CALLMONITOR 
3f27 cd aa fd			call debug_vector  
3f2a				endm  
# End of macro CALLMONITOR
3f2a			endif	 
3f2a					; count the number of rows 
3f2a			 
3f2a 06 00				ld b, 0 
3f2c 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f2d d6 28				sub display_cols 
3f2f f2 35 3f				jp p, .atprunder 
3f32 04					inc b 
3f33 18 f7				jr .atpr 
3f35			.atprunder:	 
3f35			if DEBUG_FORTH_WORDS 
3f35				DMARK "A?2" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 a6 fd			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 a7 fd			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 a8 fd			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "A?2"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e				CALLMONITOR 
3f4e cd aa fd			call debug_vector  
3f51				endm  
# End of macro CALLMONITOR
3f51			endif	 
3f51 26 00				ld h, 0 
3f53 69					ld l, c 
3f54 cd 23 20				call forth_push_numhl 
3f57 68					ld l, b  
3f58 cd 23 20				call forth_push_numhl 
3f5b			 
3f5b			 
3f5b				NEXTW 
3f5b c3 de 23			jp macro_next 
3f5e				endm 
# End of macro NEXTW
3f5e			 
3f5e			.FB: 
3f5e				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f5e 1b				db WORD_SYS_CORE+7             
3f5f ac 3f			dw .EMIT            
3f61 03				db 2 + 1 
3f62 .. 00			db "FB",0              
3f65				endm 
# End of macro CWHEAD
3f65			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f65			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f65			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f65			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f65					if DEBUG_FORTH_WORDS_KEY 
3f65						DMARK "FB." 
3f65 f5				push af  
3f66 3a 7a 3f			ld a, (.dmark)  
3f69 32 a6 fd			ld (debug_mark),a  
3f6c 3a 7b 3f			ld a, (.dmark+1)  
3f6f 32 a7 fd			ld (debug_mark+1),a  
3f72 3a 7c 3f			ld a, (.dmark+2)  
3f75 32 a8 fd			ld (debug_mark+2),a  
3f78 18 03			jr .pastdmark  
3f7a ..			.dmark: db "FB."  
3f7d f1			.pastdmark: pop af  
3f7e			endm  
# End of macro DMARK
3f7e						CALLMONITOR 
3f7e cd aa fd			call debug_vector  
3f81				endm  
# End of macro CALLMONITOR
3f81					endif 
3f81			 
3f81					FORTH_DSP_VALUEHL 
3f81 cd 28 22			call macro_dsp_valuehl 
3f84				endm 
# End of macro FORTH_DSP_VALUEHL
3f84			 
3f84 7d					ld a, l 
3f85 fe 01				cp 1 
3f87 20 05				jr nz, .fbn1 
3f89 21 4b fc				ld hl, display_fb1 
3f8c 18 15				jr .fbset 
3f8e fe 02		.fbn1:		cp 2 
3f90 20 05				jr nz, .fbn2 
3f92 21 09 fb				ld hl, display_fb2 
3f95 18 0c				jr .fbset 
3f97 fe 03		.fbn2:		cp 3 
3f99 20 05				jr nz, .fbn3 
3f9b 21 aa fb				ld hl, display_fb3 
3f9e 18 03				jr .fbset 
3fa0			.fbn3:		 ; if invalid number select first 
3fa0 21 4b fc				ld hl, display_fb1 
3fa3 22 07 fb		.fbset:		ld (display_fb_active), hl 
3fa6			 
3fa6					FORTH_DSP_POP 
3fa6 cd e0 22			call macro_forth_dsp_pop 
3fa9				endm 
# End of macro FORTH_DSP_POP
3fa9			 
3fa9					NEXTW 
3fa9 c3 de 23			jp macro_next 
3fac				endm 
# End of macro NEXTW
3fac			 
3fac			 
3fac			.EMIT: 
3fac				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3fac 1b				db WORD_SYS_CORE+7             
3fad fd 3f			dw .DOTH            
3faf 05				db 4 + 1 
3fb0 .. 00			db "EMIT",0              
3fb5				endm 
# End of macro CWHEAD
3fb5			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fb5					; get value off TOS and display it 
3fb5			 
3fb5					if DEBUG_FORTH_WORDS_KEY 
3fb5						DMARK "EMT" 
3fb5 f5				push af  
3fb6 3a ca 3f			ld a, (.dmark)  
3fb9 32 a6 fd			ld (debug_mark),a  
3fbc 3a cb 3f			ld a, (.dmark+1)  
3fbf 32 a7 fd			ld (debug_mark+1),a  
3fc2 3a cc 3f			ld a, (.dmark+2)  
3fc5 32 a8 fd			ld (debug_mark+2),a  
3fc8 18 03			jr .pastdmark  
3fca ..			.dmark: db "EMT"  
3fcd f1			.pastdmark: pop af  
3fce			endm  
# End of macro DMARK
3fce						CALLMONITOR 
3fce cd aa fd			call debug_vector  
3fd1				endm  
# End of macro CALLMONITOR
3fd1					endif 
3fd1			 
3fd1					FORTH_DSP_VALUEHL 
3fd1 cd 28 22			call macro_dsp_valuehl 
3fd4				endm 
# End of macro FORTH_DSP_VALUEHL
3fd4			 
3fd4 7d					ld a,l 
3fd5			 
3fd5					; TODO write to display 
3fd5			 
3fd5 32 fa f2				ld (os_input), a 
3fd8 3e 00				ld a, 0 
3fda 32 fb f2				ld (os_input+1), a 
3fdd					 
3fdd 3a 99 f9				ld a, (f_cursor_ptr) 
3fe0 11 fa f2				ld de, os_input 
3fe3 cd ae 0d				call str_at_display 
3fe6			 
3fe6			 
3fe6 3a 77 f9				ld a,(cli_autodisplay) 
3fe9 fe 00				cp 0 
3feb 28 03				jr z, .enoupdate 
3fed cd be 0d						call update_display 
3ff0					.enoupdate: 
3ff0			 
3ff0 3a 99 f9				ld a, (f_cursor_ptr) 
3ff3 3c					inc a 
3ff4 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
3ff7			 
3ff7			 
3ff7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ff7 cd e0 22			call macro_forth_dsp_pop 
3ffa				endm 
# End of macro FORTH_DSP_POP
3ffa			  
3ffa			 
3ffa					NEXTW 
3ffa c3 de 23			jp macro_next 
3ffd				endm 
# End of macro NEXTW
3ffd			.DOTH: 
3ffd				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3ffd 1c				db WORD_SYS_CORE+8             
3ffe 2d 40			dw .DOTF            
4000 03				db 2 + 1 
4001 .. 00			db ".-",0              
4004				endm 
# End of macro CWHEAD
4004			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4004					; get value off TOS and display it 
4004					if DEBUG_FORTH_WORDS_KEY 
4004						DMARK "DTD" 
4004 f5				push af  
4005 3a 19 40			ld a, (.dmark)  
4008 32 a6 fd			ld (debug_mark),a  
400b 3a 1a 40			ld a, (.dmark+1)  
400e 32 a7 fd			ld (debug_mark+1),a  
4011 3a 1b 40			ld a, (.dmark+2)  
4014 32 a8 fd			ld (debug_mark+2),a  
4017 18 03			jr .pastdmark  
4019 ..			.dmark: db "DTD"  
401c f1			.pastdmark: pop af  
401d			endm  
# End of macro DMARK
401d						CALLMONITOR 
401d cd aa fd			call debug_vector  
4020				endm  
# End of macro CALLMONITOR
4020					endif 
4020 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4022 3e 00			ld a, 0 
4024 32 78 f9			ld (cli_mvdot), a 
4027 c3 84 40			jp .dotgo 
402a				NEXTW 
402a c3 de 23			jp macro_next 
402d				endm 
# End of macro NEXTW
402d			.DOTF: 
402d				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
402d 1c				db WORD_SYS_CORE+8             
402e 5b 40			dw .DOT            
4030 03				db 2 + 1 
4031 .. 00			db ".>",0              
4034				endm 
# End of macro CWHEAD
4034			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4034					; get value off TOS and display it 
4034			        ; TODO BUG adds extra spaces 
4034			        ; TODO BUG handle numerics? 
4034					if DEBUG_FORTH_WORDS_KEY 
4034						DMARK "DTC" 
4034 f5				push af  
4035 3a 49 40			ld a, (.dmark)  
4038 32 a6 fd			ld (debug_mark),a  
403b 3a 4a 40			ld a, (.dmark+1)  
403e 32 a7 fd			ld (debug_mark+1),a  
4041 3a 4b 40			ld a, (.dmark+2)  
4044 32 a8 fd			ld (debug_mark+2),a  
4047 18 03			jr .pastdmark  
4049 ..			.dmark: db "DTC"  
404c f1			.pastdmark: pop af  
404d			endm  
# End of macro DMARK
404d						CALLMONITOR 
404d cd aa fd			call debug_vector  
4050				endm  
# End of macro CALLMONITOR
4050					endif 
4050 3e 01			ld a, 1 
4052 32 78 f9			ld (cli_mvdot), a 
4055 c3 84 40			jp .dotgo 
4058				NEXTW 
4058 c3 de 23			jp macro_next 
405b				endm 
# End of macro NEXTW
405b			 
405b			.DOT: 
405b				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
405b 1c				db WORD_SYS_CORE+8             
405c 37 42			dw .CLS            
405e 02				db 1 + 1 
405f .. 00			db ".",0              
4061				endm 
# End of macro CWHEAD
4061			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4061					; get value off TOS and display it 
4061			 
4061					if DEBUG_FORTH_WORDS_KEY 
4061						DMARK "DOT" 
4061 f5				push af  
4062 3a 76 40			ld a, (.dmark)  
4065 32 a6 fd			ld (debug_mark),a  
4068 3a 77 40			ld a, (.dmark+1)  
406b 32 a7 fd			ld (debug_mark+1),a  
406e 3a 78 40			ld a, (.dmark+2)  
4071 32 a8 fd			ld (debug_mark+2),a  
4074 18 03			jr .pastdmark  
4076 ..			.dmark: db "DOT"  
4079 f1			.pastdmark: pop af  
407a			endm  
# End of macro DMARK
407a						CALLMONITOR 
407a cd aa fd			call debug_vector  
407d				endm  
# End of macro CALLMONITOR
407d					endif 
407d 3e 00			ld a, 0 
407f 32 78 f9			ld (cli_mvdot), a 
4082 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4084				 
4084			 
4084			.dotgo: 
4084			 
4084			; move up type to on stack for parserv5 
4084					FORTH_DSP 
4084 cd ee 21			call macro_forth_dsp 
4087				endm 
# End of macro FORTH_DSP
4087				;FORTH_DSP_VALUE  
4087			 
4087			if DEBUG_FORTH_DOT 
4087				DMARK "DOT" 
4087 f5				push af  
4088 3a 9c 40			ld a, (.dmark)  
408b 32 a6 fd			ld (debug_mark),a  
408e 3a 9d 40			ld a, (.dmark+1)  
4091 32 a7 fd			ld (debug_mark+1),a  
4094 3a 9e 40			ld a, (.dmark+2)  
4097 32 a8 fd			ld (debug_mark+2),a  
409a 18 03			jr .pastdmark  
409c ..			.dmark: db "DOT"  
409f f1			.pastdmark: pop af  
40a0			endm  
# End of macro DMARK
40a0				CALLMONITOR 
40a0 cd aa fd			call debug_vector  
40a3				endm  
# End of macro CALLMONITOR
40a3			endif	 
40a3			;		.print: 
40a3			 
40a3 7e				ld a,(hl)  ; work out what type of value is on the TOS 
40a4 23				inc hl   ; position to the actual value 
40a5 fe 01			cp DS_TYPE_STR 
40a7 20 06			jr nz, .dotnum1  
40a9			 
40a9			; display string 
40a9				FORTH_DSP_VALUE  
40a9 cd 11 22			call macro_forth_dsp_value 
40ac				endm 
# End of macro FORTH_DSP_VALUE
40ac eb				ex de,hl 
40ad 18 49			jr .dotwrite 
40af			 
40af			.dotnum1: 
40af fe 02			cp DS_TYPE_INUM 
40b1 20 44			jr nz, .dotflot 
40b3			 
40b3			 
40b3			; display number 
40b3			 
40b3			;	push hl 
40b3			;	call clear_display 
40b3			;	pop hl 
40b3			 
40b3 5e				ld e, (hl) 
40b4 23				inc hl 
40b5 56				ld d, (hl) 
40b6 21 fc f0			ld hl, scratch 
40b9			if DEBUG_FORTH_DOT 
40b9				DMARK "DT1" 
40b9 f5				push af  
40ba 3a ce 40			ld a, (.dmark)  
40bd 32 a6 fd			ld (debug_mark),a  
40c0 3a cf 40			ld a, (.dmark+1)  
40c3 32 a7 fd			ld (debug_mark+1),a  
40c6 3a d0 40			ld a, (.dmark+2)  
40c9 32 a8 fd			ld (debug_mark+2),a  
40cc 18 03			jr .pastdmark  
40ce ..			.dmark: db "DT1"  
40d1 f1			.pastdmark: pop af  
40d2			endm  
# End of macro DMARK
40d2				CALLMONITOR 
40d2 cd aa fd			call debug_vector  
40d5				endm  
# End of macro CALLMONITOR
40d5			endif	 
40d5			 
40d5 cd e4 12			call uitoa_16 
40d8 eb				ex de,hl 
40d9			 
40d9			if DEBUG_FORTH_DOT 
40d9				DMARK "DT2" 
40d9 f5				push af  
40da 3a ee 40			ld a, (.dmark)  
40dd 32 a6 fd			ld (debug_mark),a  
40e0 3a ef 40			ld a, (.dmark+1)  
40e3 32 a7 fd			ld (debug_mark+1),a  
40e6 3a f0 40			ld a, (.dmark+2)  
40e9 32 a8 fd			ld (debug_mark+2),a  
40ec 18 03			jr .pastdmark  
40ee ..			.dmark: db "DT2"  
40f1 f1			.pastdmark: pop af  
40f2			endm  
# End of macro DMARK
40f2				CALLMONITOR 
40f2 cd aa fd			call debug_vector  
40f5				endm  
# End of macro CALLMONITOR
40f5			endif	 
40f5			 
40f5			;	ld de, os_word_scratch 
40f5 18 01			jr .dotwrite 
40f7			 
40f7 00			.dotflot:   nop 
40f8			; TODO print floating point number 
40f8			 
40f8			.dotwrite:		 
40f8			 
40f8					; if c is set then set all '-' to spaces 
40f8					; need to also take into account .>  
40f8			 
40f8 3e 01				ld a, 1 
40fa b9					cp c 
40fb 20 67				jr nz, .nodashswap 
40fd			 
40fd					; DE has the string to write, working with HL 
40fd			 
40fd 06 ff				ld b, 255 
40ff d5					push de 
4100 e1					pop hl 
4101			 
4101			if DEBUG_FORTH_DOT 
4101				DMARK "DT-" 
4101 f5				push af  
4102 3a 16 41			ld a, (.dmark)  
4105 32 a6 fd			ld (debug_mark),a  
4108 3a 17 41			ld a, (.dmark+1)  
410b 32 a7 fd			ld (debug_mark+1),a  
410e 3a 18 41			ld a, (.dmark+2)  
4111 32 a8 fd			ld (debug_mark+2),a  
4114 18 03			jr .pastdmark  
4116 ..			.dmark: db "DT-"  
4119 f1			.pastdmark: pop af  
411a			endm  
# End of macro DMARK
411a				CALLMONITOR 
411a cd aa fd			call debug_vector  
411d				endm  
# End of macro CALLMONITOR
411d			endif	 
411d 7e			.dashscan:	ld a, (hl) 
411e fe 00				cp 0 
4120 28 42				jr z, .nodashswap 
4122 fe 2d				cp '-' 
4124 20 03				jr nz, .dashskip 
4126 3e 20				ld a, ' ' 
4128 77					ld (hl), a 
4129 23			.dashskip:	inc hl 
412a			if DEBUG_FORTH_DOT 
412a				DMARK "D-2" 
412a f5				push af  
412b 3a 3f 41			ld a, (.dmark)  
412e 32 a6 fd			ld (debug_mark),a  
4131 3a 40 41			ld a, (.dmark+1)  
4134 32 a7 fd			ld (debug_mark+1),a  
4137 3a 41 41			ld a, (.dmark+2)  
413a 32 a8 fd			ld (debug_mark+2),a  
413d 18 03			jr .pastdmark  
413f ..			.dmark: db "D-2"  
4142 f1			.pastdmark: pop af  
4143			endm  
# End of macro DMARK
4143				CALLMONITOR 
4143 cd aa fd			call debug_vector  
4146				endm  
# End of macro CALLMONITOR
4146			endif	 
4146 10 d5				djnz .dashscan 
4148			 
4148			if DEBUG_FORTH_DOT 
4148				DMARK "D-1" 
4148 f5				push af  
4149 3a 5d 41			ld a, (.dmark)  
414c 32 a6 fd			ld (debug_mark),a  
414f 3a 5e 41			ld a, (.dmark+1)  
4152 32 a7 fd			ld (debug_mark+1),a  
4155 3a 5f 41			ld a, (.dmark+2)  
4158 32 a8 fd			ld (debug_mark+2),a  
415b 18 03			jr .pastdmark  
415d ..			.dmark: db "D-1"  
4160 f1			.pastdmark: pop af  
4161			endm  
# End of macro DMARK
4161				CALLMONITOR 
4161 cd aa fd			call debug_vector  
4164				endm  
# End of macro CALLMONITOR
4164			endif	 
4164			 
4164			.nodashswap: 
4164			 
4164			if DEBUG_FORTH_DOT 
4164				DMARK "D-o" 
4164 f5				push af  
4165 3a 79 41			ld a, (.dmark)  
4168 32 a6 fd			ld (debug_mark),a  
416b 3a 7a 41			ld a, (.dmark+1)  
416e 32 a7 fd			ld (debug_mark+1),a  
4171 3a 7b 41			ld a, (.dmark+2)  
4174 32 a8 fd			ld (debug_mark+2),a  
4177 18 03			jr .pastdmark  
4179 ..			.dmark: db "D-o"  
417c f1			.pastdmark: pop af  
417d			endm  
# End of macro DMARK
417d				CALLMONITOR 
417d cd aa fd			call debug_vector  
4180				endm  
# End of macro CALLMONITOR
4180			endif	 
4180			 
4180 d5					push de   ; save string start in case we need to advance print 
4181			 
4181 3a 99 f9				ld a, (f_cursor_ptr) 
4184 cd ae 0d				call str_at_display 
4187 3a 77 f9				ld a,(cli_autodisplay) 
418a fe 00				cp 0 
418c 28 03				jr z, .noupdate 
418e cd be 0d						call update_display 
4191					.noupdate: 
4191			 
4191			 
4191					; see if we need to advance the print position 
4191			 
4191 e1					pop hl   ; get back string 
4192			;		ex de,hl 
4192			 
4192 3a 78 f9				ld a, (cli_mvdot) 
4195			if DEBUG_FORTH_DOT 
4195			;		ld e,a 
4195				DMARK "D>1" 
4195 f5				push af  
4196 3a aa 41			ld a, (.dmark)  
4199 32 a6 fd			ld (debug_mark),a  
419c 3a ab 41			ld a, (.dmark+1)  
419f 32 a7 fd			ld (debug_mark+1),a  
41a2 3a ac 41			ld a, (.dmark+2)  
41a5 32 a8 fd			ld (debug_mark+2),a  
41a8 18 03			jr .pastdmark  
41aa ..			.dmark: db "D>1"  
41ad f1			.pastdmark: pop af  
41ae			endm  
# End of macro DMARK
41ae				CALLMONITOR 
41ae cd aa fd			call debug_vector  
41b1				endm  
# End of macro CALLMONITOR
41b1			endif	 
41b1 fe 00				cp 0 
41b3 28 44				jr z, .noadv 
41b5					; yes, lets advance the print position 
41b5 3e 00				ld a, 0 
41b7 cd 40 13				call strlent 
41ba			if DEBUG_FORTH_DOT 
41ba				DMARK "D-?" 
41ba f5				push af  
41bb 3a cf 41			ld a, (.dmark)  
41be 32 a6 fd			ld (debug_mark),a  
41c1 3a d0 41			ld a, (.dmark+1)  
41c4 32 a7 fd			ld (debug_mark+1),a  
41c7 3a d1 41			ld a, (.dmark+2)  
41ca 32 a8 fd			ld (debug_mark+2),a  
41cd 18 03			jr .pastdmark  
41cf ..			.dmark: db "D-?"  
41d2 f1			.pastdmark: pop af  
41d3			endm  
# End of macro DMARK
41d3				CALLMONITOR 
41d3 cd aa fd			call debug_vector  
41d6				endm  
# End of macro CALLMONITOR
41d6			endif	 
41d6 3a 99 f9				ld a, (f_cursor_ptr) 
41d9 85					add a,l 
41da					;call addatohl 
41da					;ld a, l 
41da 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
41dd			 
41dd			if DEBUG_FORTH_DOT 
41dd				DMARK "D->" 
41dd f5				push af  
41de 3a f2 41			ld a, (.dmark)  
41e1 32 a6 fd			ld (debug_mark),a  
41e4 3a f3 41			ld a, (.dmark+1)  
41e7 32 a7 fd			ld (debug_mark+1),a  
41ea 3a f4 41			ld a, (.dmark+2)  
41ed 32 a8 fd			ld (debug_mark+2),a  
41f0 18 03			jr .pastdmark  
41f2 ..			.dmark: db "D->"  
41f5 f1			.pastdmark: pop af  
41f6			endm  
# End of macro DMARK
41f6				CALLMONITOR 
41f6 cd aa fd			call debug_vector  
41f9				endm  
# End of macro CALLMONITOR
41f9			endif	 
41f9			 
41f9			.noadv:	 
41f9			 
41f9					if DEBUG_FORTH_DOT_WAIT 
41f9							call next_page_prompt 
41f9					endif	 
41f9			; TODO this pop off the stack causes a crash. i dont know why 
41f9			 
41f9			 
41f9			if DEBUG_FORTH_DOT 
41f9				DMARK "DTh" 
41f9 f5				push af  
41fa 3a 0e 42			ld a, (.dmark)  
41fd 32 a6 fd			ld (debug_mark),a  
4200 3a 0f 42			ld a, (.dmark+1)  
4203 32 a7 fd			ld (debug_mark+1),a  
4206 3a 10 42			ld a, (.dmark+2)  
4209 32 a8 fd			ld (debug_mark+2),a  
420c 18 03			jr .pastdmark  
420e ..			.dmark: db "DTh"  
4211 f1			.pastdmark: pop af  
4212			endm  
# End of macro DMARK
4212				CALLMONITOR 
4212 cd aa fd			call debug_vector  
4215				endm  
# End of macro CALLMONITOR
4215			endif	 
4215			 
4215					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4215 cd e0 22			call macro_forth_dsp_pop 
4218				endm 
# End of macro FORTH_DSP_POP
4218			 
4218			if DEBUG_FORTH_DOT 
4218				DMARK "DTi" 
4218 f5				push af  
4219 3a 2d 42			ld a, (.dmark)  
421c 32 a6 fd			ld (debug_mark),a  
421f 3a 2e 42			ld a, (.dmark+1)  
4222 32 a7 fd			ld (debug_mark+1),a  
4225 3a 2f 42			ld a, (.dmark+2)  
4228 32 a8 fd			ld (debug_mark+2),a  
422b 18 03			jr .pastdmark  
422d ..			.dmark: db "DTi"  
4230 f1			.pastdmark: pop af  
4231			endm  
# End of macro DMARK
4231				CALLMONITOR 
4231 cd aa fd			call debug_vector  
4234				endm  
# End of macro CALLMONITOR
4234			endif	 
4234			 
4234			 
4234					NEXTW 
4234 c3 de 23			jp macro_next 
4237				endm 
# End of macro NEXTW
4237			 
4237			.CLS: 
4237				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4237 35				db WORD_SYS_CORE+33             
4238 64 42			dw .DRAW            
423a 04				db 3 + 1 
423b .. 00			db "CLS",0              
423f				endm 
# End of macro CWHEAD
423f			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
423f					if DEBUG_FORTH_WORDS_KEY 
423f						DMARK "CLS" 
423f f5				push af  
4240 3a 54 42			ld a, (.dmark)  
4243 32 a6 fd			ld (debug_mark),a  
4246 3a 55 42			ld a, (.dmark+1)  
4249 32 a7 fd			ld (debug_mark+1),a  
424c 3a 56 42			ld a, (.dmark+2)  
424f 32 a8 fd			ld (debug_mark+2),a  
4252 18 03			jr .pastdmark  
4254 ..			.dmark: db "CLS"  
4257 f1			.pastdmark: pop af  
4258			endm  
# End of macro DMARK
4258						CALLMONITOR 
4258 cd aa fd			call debug_vector  
425b				endm  
# End of macro CALLMONITOR
425b					endif 
425b cd 9b 0d				call clear_display 
425e c3 72 43				jp .home		; and home cursor 
4261					NEXTW 
4261 c3 de 23			jp macro_next 
4264				endm 
# End of macro NEXTW
4264			 
4264			.DRAW: 
4264				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4264 36				db WORD_SYS_CORE+34             
4265 8f 42			dw .DUMP            
4267 05				db 4 + 1 
4268 .. 00			db "DRAW",0              
426d				endm 
# End of macro CWHEAD
426d			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
426d					if DEBUG_FORTH_WORDS_KEY 
426d						DMARK "DRW" 
426d f5				push af  
426e 3a 82 42			ld a, (.dmark)  
4271 32 a6 fd			ld (debug_mark),a  
4274 3a 83 42			ld a, (.dmark+1)  
4277 32 a7 fd			ld (debug_mark+1),a  
427a 3a 84 42			ld a, (.dmark+2)  
427d 32 a8 fd			ld (debug_mark+2),a  
4280 18 03			jr .pastdmark  
4282 ..			.dmark: db "DRW"  
4285 f1			.pastdmark: pop af  
4286			endm  
# End of macro DMARK
4286						CALLMONITOR 
4286 cd aa fd			call debug_vector  
4289				endm  
# End of macro CALLMONITOR
4289					endif 
4289 cd be 0d				call update_display 
428c					NEXTW 
428c c3 de 23			jp macro_next 
428f				endm 
# End of macro NEXTW
428f			 
428f			.DUMP: 
428f				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
428f 37				db WORD_SYS_CORE+35             
4290 c7 42			dw .CDUMP            
4292 05				db 4 + 1 
4293 .. 00			db "DUMP",0              
4298				endm 
# End of macro CWHEAD
4298			; | DUMP ( x -- ) With address x display dump   | DONE 
4298			; TODO pop address to use off of the stack 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "DUM" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 a6 fd			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 a7 fd			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 a8 fd			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "DUM"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd aa fd			call debug_vector  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4 cd 9b 0d				call clear_display 
42b7			 
42b7					; get address 
42b7			 
42b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42b7 cd 28 22			call macro_dsp_valuehl 
42ba				endm 
# End of macro FORTH_DSP_VALUEHL
42ba				 
42ba					; save it for cdump 
42ba			 
42ba 22 1f f4				ld (os_cur_ptr),hl 
42bd			 
42bd					; destroy value TOS 
42bd			 
42bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42bd cd e0 22			call macro_forth_dsp_pop 
42c0				endm 
# End of macro FORTH_DSP_POP
42c0			 
42c0 cd a3 1e				call dumpcont	; skip old style of param parsing	 
42c3 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42c4					NEXTW 
42c4 c3 de 23			jp macro_next 
42c7				endm 
# End of macro NEXTW
42c7			.CDUMP: 
42c7				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42c7 38				db WORD_SYS_CORE+36             
42c8 f7 42			dw .DAT            
42ca 06				db 5 + 1 
42cb .. 00			db "CDUMP",0              
42d1				endm 
# End of macro CWHEAD
42d1			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42d1					if DEBUG_FORTH_WORDS_KEY 
42d1						DMARK "CDP" 
42d1 f5				push af  
42d2 3a e6 42			ld a, (.dmark)  
42d5 32 a6 fd			ld (debug_mark),a  
42d8 3a e7 42			ld a, (.dmark+1)  
42db 32 a7 fd			ld (debug_mark+1),a  
42de 3a e8 42			ld a, (.dmark+2)  
42e1 32 a8 fd			ld (debug_mark+2),a  
42e4 18 03			jr .pastdmark  
42e6 ..			.dmark: db "CDP"  
42e9 f1			.pastdmark: pop af  
42ea			endm  
# End of macro DMARK
42ea						CALLMONITOR 
42ea cd aa fd			call debug_vector  
42ed				endm  
# End of macro CALLMONITOR
42ed					endif 
42ed cd 9b 0d				call clear_display 
42f0 cd a3 1e				call dumpcont	 
42f3 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
42f4					NEXTW 
42f4 c3 de 23			jp macro_next 
42f7				endm 
# End of macro NEXTW
42f7			 
42f7			 
42f7			 
42f7			 
42f7			.DAT: 
42f7				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
42f7 3d				db WORD_SYS_CORE+41             
42f8 4d 43			dw .HOME            
42fa 03				db 2 + 1 
42fb .. 00			db "AT",0              
42fe				endm 
# End of macro CWHEAD
42fe			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
42fe					if DEBUG_FORTH_WORDS_KEY 
42fe						DMARK "AT." 
42fe f5				push af  
42ff 3a 13 43			ld a, (.dmark)  
4302 32 a6 fd			ld (debug_mark),a  
4305 3a 14 43			ld a, (.dmark+1)  
4308 32 a7 fd			ld (debug_mark+1),a  
430b 3a 15 43			ld a, (.dmark+2)  
430e 32 a8 fd			ld (debug_mark+2),a  
4311 18 03			jr .pastdmark  
4313 ..			.dmark: db "AT."  
4316 f1			.pastdmark: pop af  
4317			endm  
# End of macro DMARK
4317						CALLMONITOR 
4317 cd aa fd			call debug_vector  
431a				endm  
# End of macro CALLMONITOR
431a					endif 
431a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
431a cd 28 22			call macro_dsp_valuehl 
431d				endm 
# End of macro FORTH_DSP_VALUEHL
431d			 
431d			 
431d					; TODO save cursor row 
431d 7d					ld a,l 
431e fe 02				cp 2 
4320 20 04				jr nz, .crow3 
4322 3e 28				ld a, display_row_2 
4324 18 12				jr .ccol1 
4326 fe 03		.crow3:		cp 3 
4328 20 04				jr nz, .crow4 
432a 3e 50				ld a, display_row_3 
432c 18 0a				jr .ccol1 
432e fe 04		.crow4:		cp 4 
4330 20 04				jr nz, .crow1 
4332 3e 78				ld a, display_row_4 
4334 18 02				jr .ccol1 
4336 3e 00		.crow1:		ld a,display_row_1 
4338 f5			.ccol1:		push af			; got row offset 
4339 6f					ld l,a 
433a 26 00				ld h,0 
433c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
433c cd e0 22			call macro_forth_dsp_pop 
433f				endm 
# End of macro FORTH_DSP_POP
433f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
433f cd 28 22			call macro_dsp_valuehl 
4342				endm 
# End of macro FORTH_DSP_VALUEHL
4342					; TODO save cursor col 
4342 f1					pop af 
4343 85					add l		; add col offset 
4344 32 99 f9				ld (f_cursor_ptr), a 
4347					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4347 cd e0 22			call macro_forth_dsp_pop 
434a				endm 
# End of macro FORTH_DSP_POP
434a			 
434a					; calculate  
434a			 
434a					NEXTW 
434a c3 de 23			jp macro_next 
434d				endm 
# End of macro NEXTW
434d			 
434d			 
434d			.HOME: 
434d				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
434d 41				db WORD_SYS_CORE+45             
434e 7a 43			dw .CR            
4350 05				db 4 + 1 
4351 .. 00			db "HOME",0              
4356				endm 
# End of macro CWHEAD
4356			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4356					if DEBUG_FORTH_WORDS_KEY 
4356						DMARK "HOM" 
4356 f5				push af  
4357 3a 6b 43			ld a, (.dmark)  
435a 32 a6 fd			ld (debug_mark),a  
435d 3a 6c 43			ld a, (.dmark+1)  
4360 32 a7 fd			ld (debug_mark+1),a  
4363 3a 6d 43			ld a, (.dmark+2)  
4366 32 a8 fd			ld (debug_mark+2),a  
4369 18 03			jr .pastdmark  
436b ..			.dmark: db "HOM"  
436e f1			.pastdmark: pop af  
436f			endm  
# End of macro DMARK
436f						CALLMONITOR 
436f cd aa fd			call debug_vector  
4372				endm  
# End of macro CALLMONITOR
4372					endif 
4372 3e 00		.home:		ld a, 0		; and home cursor 
4374 32 99 f9				ld (f_cursor_ptr), a 
4377					NEXTW 
4377 c3 de 23			jp macro_next 
437a				endm 
# End of macro NEXTW
437a			 
437a			 
437a			.CR: 
437a				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
437a 46				db WORD_SYS_CORE+50             
437b b5 43			dw .SPACE            
437d 03				db 2 + 1 
437e .. 00			db "CR",0              
4381				endm 
# End of macro CWHEAD
4381			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4381					if DEBUG_FORTH_WORDS_KEY 
4381						DMARK "CR." 
4381 f5				push af  
4382 3a 96 43			ld a, (.dmark)  
4385 32 a6 fd			ld (debug_mark),a  
4388 3a 97 43			ld a, (.dmark+1)  
438b 32 a7 fd			ld (debug_mark+1),a  
438e 3a 98 43			ld a, (.dmark+2)  
4391 32 a8 fd			ld (debug_mark+2),a  
4394 18 03			jr .pastdmark  
4396 ..			.dmark: db "CR."  
4399 f1			.pastdmark: pop af  
439a			endm  
# End of macro DMARK
439a						CALLMONITOR 
439a cd aa fd			call debug_vector  
439d				endm  
# End of macro CALLMONITOR
439d					endif 
439d 3e 0d				ld a, 13 
439f 32 fc f0				ld (scratch),a 
43a2 3e 0a				ld a, 10 
43a4 32 fd f0				ld (scratch+1),a 
43a7 3e 00				ld a, 0 
43a9 32 fe f0				ld (scratch+2),a 
43ac 21 fc f0				ld hl, scratch 
43af cd 91 20				call forth_push_str 
43b2					 
43b2				       NEXTW 
43b2 c3 de 23			jp macro_next 
43b5				endm 
# End of macro NEXTW
43b5			.SPACE: 
43b5				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
43b5 46				db WORD_SYS_CORE+50             
43b6 eb 43			dw .SPACES            
43b8 03				db 2 + 1 
43b9 .. 00			db "BL",0              
43bc				endm 
# End of macro CWHEAD
43bc			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
43bc					if DEBUG_FORTH_WORDS_KEY 
43bc						DMARK "BL." 
43bc f5				push af  
43bd 3a d1 43			ld a, (.dmark)  
43c0 32 a6 fd			ld (debug_mark),a  
43c3 3a d2 43			ld a, (.dmark+1)  
43c6 32 a7 fd			ld (debug_mark+1),a  
43c9 3a d3 43			ld a, (.dmark+2)  
43cc 32 a8 fd			ld (debug_mark+2),a  
43cf 18 03			jr .pastdmark  
43d1 ..			.dmark: db "BL."  
43d4 f1			.pastdmark: pop af  
43d5			endm  
# End of macro DMARK
43d5						CALLMONITOR 
43d5 cd aa fd			call debug_vector  
43d8				endm  
# End of macro CALLMONITOR
43d8					endif 
43d8 3e 20				ld a, " " 
43da 32 fc f0				ld (scratch),a 
43dd 3e 00				ld a, 0 
43df 32 fd f0				ld (scratch+1),a 
43e2 21 fc f0				ld hl, scratch 
43e5 cd 91 20				call forth_push_str 
43e8					 
43e8				       NEXTW 
43e8 c3 de 23			jp macro_next 
43eb				endm 
# End of macro NEXTW
43eb			 
43eb			;.blstr: db " ", 0 
43eb			 
43eb			.SPACES: 
43eb				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
43eb 47				db WORD_SYS_CORE+51             
43ec 86 44			dw .SCROLL            
43ee 07				db 6 + 1 
43ef .. 00			db "SPACES",0              
43f6				endm 
# End of macro CWHEAD
43f6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43f6					if DEBUG_FORTH_WORDS_KEY 
43f6						DMARK "SPS" 
43f6 f5				push af  
43f7 3a 0b 44			ld a, (.dmark)  
43fa 32 a6 fd			ld (debug_mark),a  
43fd 3a 0c 44			ld a, (.dmark+1)  
4400 32 a7 fd			ld (debug_mark+1),a  
4403 3a 0d 44			ld a, (.dmark+2)  
4406 32 a8 fd			ld (debug_mark+2),a  
4409 18 03			jr .pastdmark  
440b ..			.dmark: db "SPS"  
440e f1			.pastdmark: pop af  
440f			endm  
# End of macro DMARK
440f						CALLMONITOR 
440f cd aa fd			call debug_vector  
4412				endm  
# End of macro CALLMONITOR
4412					endif 
4412			 
4412			 
4412					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4412 cd 28 22			call macro_dsp_valuehl 
4415				endm 
# End of macro FORTH_DSP_VALUEHL
4415			 
4415 e5					push hl    ; u 
4416					if DEBUG_FORTH_WORDS 
4416						DMARK "SPA" 
4416 f5				push af  
4417 3a 2b 44			ld a, (.dmark)  
441a 32 a6 fd			ld (debug_mark),a  
441d 3a 2c 44			ld a, (.dmark+1)  
4420 32 a7 fd			ld (debug_mark+1),a  
4423 3a 2d 44			ld a, (.dmark+2)  
4426 32 a8 fd			ld (debug_mark+2),a  
4429 18 03			jr .pastdmark  
442b ..			.dmark: db "SPA"  
442e f1			.pastdmark: pop af  
442f			endm  
# End of macro DMARK
442f						CALLMONITOR 
442f cd aa fd			call debug_vector  
4432				endm  
# End of macro CALLMONITOR
4432					endif 
4432			 
4432					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4432 cd e0 22			call macro_forth_dsp_pop 
4435				endm 
# End of macro FORTH_DSP_POP
4435 e1					pop hl 
4436 0e 00				ld c, 0 
4438 45					ld b, l 
4439 21 fc f0				ld hl, scratch  
443c			 
443c					if DEBUG_FORTH_WORDS 
443c						DMARK "SP2" 
443c f5				push af  
443d 3a 51 44			ld a, (.dmark)  
4440 32 a6 fd			ld (debug_mark),a  
4443 3a 52 44			ld a, (.dmark+1)  
4446 32 a7 fd			ld (debug_mark+1),a  
4449 3a 53 44			ld a, (.dmark+2)  
444c 32 a8 fd			ld (debug_mark+2),a  
444f 18 03			jr .pastdmark  
4451 ..			.dmark: db "SP2"  
4454 f1			.pastdmark: pop af  
4455			endm  
# End of macro DMARK
4455						CALLMONITOR 
4455 cd aa fd			call debug_vector  
4458				endm  
# End of macro CALLMONITOR
4458					endif 
4458 3e 20				ld a, ' ' 
445a			.spaces1:	 
445a 77					ld (hl),a 
445b 23					inc hl 
445c					 
445c 10 fc				djnz .spaces1 
445e 3e 00				ld a,0 
4460 77					ld (hl),a 
4461 21 fc f0				ld hl, scratch 
4464					if DEBUG_FORTH_WORDS 
4464						DMARK "SP3" 
4464 f5				push af  
4465 3a 79 44			ld a, (.dmark)  
4468 32 a6 fd			ld (debug_mark),a  
446b 3a 7a 44			ld a, (.dmark+1)  
446e 32 a7 fd			ld (debug_mark+1),a  
4471 3a 7b 44			ld a, (.dmark+2)  
4474 32 a8 fd			ld (debug_mark+2),a  
4477 18 03			jr .pastdmark  
4479 ..			.dmark: db "SP3"  
447c f1			.pastdmark: pop af  
447d			endm  
# End of macro DMARK
447d						CALLMONITOR 
447d cd aa fd			call debug_vector  
4480				endm  
# End of macro CALLMONITOR
4480					endif 
4480 cd 91 20				call forth_push_str 
4483			 
4483				       NEXTW 
4483 c3 de 23			jp macro_next 
4486				endm 
# End of macro NEXTW
4486			 
4486			 
4486			 
4486			.SCROLL: 
4486				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4486 53				db WORD_SYS_CORE+63             
4487 b3 44			dw .SCROLLD            
4489 07				db 6 + 1 
448a .. 00			db "SCROLL",0              
4491				endm 
# End of macro CWHEAD
4491			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4491					if DEBUG_FORTH_WORDS_KEY 
4491						DMARK "SCR" 
4491 f5				push af  
4492 3a a6 44			ld a, (.dmark)  
4495 32 a6 fd			ld (debug_mark),a  
4498 3a a7 44			ld a, (.dmark+1)  
449b 32 a7 fd			ld (debug_mark+1),a  
449e 3a a8 44			ld a, (.dmark+2)  
44a1 32 a8 fd			ld (debug_mark+2),a  
44a4 18 03			jr .pastdmark  
44a6 ..			.dmark: db "SCR"  
44a9 f1			.pastdmark: pop af  
44aa			endm  
# End of macro DMARK
44aa						CALLMONITOR 
44aa cd aa fd			call debug_vector  
44ad				endm  
# End of macro CALLMONITOR
44ad					endif 
44ad			 
44ad cd 5d 0d			call scroll_up 
44b0			;	call update_display 
44b0			 
44b0					NEXTW 
44b0 c3 de 23			jp macro_next 
44b3				endm 
# End of macro NEXTW
44b3			 
44b3			 
44b3			 
44b3			;		; get dir 
44b3			; 
44b3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b3			; 
44b3			;		push hl 
44b3			; 
44b3			;		; destroy value TOS 
44b3			; 
44b3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b3			; 
44b3			;		; get count 
44b3			; 
44b3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b3			; 
44b3			;		push hl 
44b3			; 
44b3			;		; destroy value TOS 
44b3			; 
44b3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b3			; 
44b3			;		; one value on hl get other one back 
44b3			; 
44b3			;		pop bc    ; count 
44b3			; 
44b3			;		pop de   ; dir 
44b3			; 
44b3			; 
44b3			;		ld b, c 
44b3			; 
44b3			;.scrolldir:     push bc 
44b3			;		push de 
44b3			; 
44b3			;		ld a, 0 
44b3			;		cp e 
44b3			;		jr z, .scrollup  
44b3			;		call scroll_down 
44b3			;		jr .scrollnext 
44b3			;.scrollup:	call scroll_up 
44b3			; 
44b3			;		 
44b3			;.scrollnext: 
44b3			;		pop de 
44b3			;		pop bc 
44b3			;		djnz .scrolldir 
44b3			; 
44b3			; 
44b3			; 
44b3			; 
44b3			; 
44b3			;		NEXTW 
44b3			 
44b3			.SCROLLD: 
44b3				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
44b3 53				db WORD_SYS_CORE+63             
44b4 e1 44			dw .ATQ            
44b6 08				db 7 + 1 
44b7 .. 00			db "SCROLLD",0              
44bf				endm 
# End of macro CWHEAD
44bf			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
44bf					if DEBUG_FORTH_WORDS_KEY 
44bf						DMARK "SCD" 
44bf f5				push af  
44c0 3a d4 44			ld a, (.dmark)  
44c3 32 a6 fd			ld (debug_mark),a  
44c6 3a d5 44			ld a, (.dmark+1)  
44c9 32 a7 fd			ld (debug_mark+1),a  
44cc 3a d6 44			ld a, (.dmark+2)  
44cf 32 a8 fd			ld (debug_mark+2),a  
44d2 18 03			jr .pastdmark  
44d4 ..			.dmark: db "SCD"  
44d7 f1			.pastdmark: pop af  
44d8			endm  
# End of macro DMARK
44d8						CALLMONITOR 
44d8 cd aa fd			call debug_vector  
44db				endm  
# End of macro CALLMONITOR
44db					endif 
44db			 
44db cd 81 0d			call scroll_down 
44de			;	call update_display 
44de			 
44de					NEXTW 
44de c3 de 23			jp macro_next 
44e1				endm 
# End of macro NEXTW
44e1			 
44e1			 
44e1			.ATQ: 
44e1				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
44e1 62				db WORD_SYS_CORE+78             
44e2 3f 45			dw .AUTODSP            
44e4 04				db 3 + 1 
44e5 .. 00			db "AT@",0              
44e9				endm 
# End of macro CWHEAD
44e9			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
44e9					if DEBUG_FORTH_WORDS_KEY 
44e9						DMARK "ATA" 
44e9 f5				push af  
44ea 3a fe 44			ld a, (.dmark)  
44ed 32 a6 fd			ld (debug_mark),a  
44f0 3a ff 44			ld a, (.dmark+1)  
44f3 32 a7 fd			ld (debug_mark+1),a  
44f6 3a 00 45			ld a, (.dmark+2)  
44f9 32 a8 fd			ld (debug_mark+2),a  
44fc 18 03			jr .pastdmark  
44fe ..			.dmark: db "ATA"  
4501 f1			.pastdmark: pop af  
4502			endm  
# End of macro DMARK
4502						CALLMONITOR 
4502 cd aa fd			call debug_vector  
4505				endm  
# End of macro CALLMONITOR
4505					endif 
4505			 
4505			 
4505					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4505 cd 28 22			call macro_dsp_valuehl 
4508				endm 
# End of macro FORTH_DSP_VALUEHL
4508			 
4508					; TODO save cursor row 
4508 7d					ld a,l 
4509 fe 02				cp 2 
450b 20 04				jr nz, .crow3aq 
450d 3e 28				ld a, display_row_2 
450f 18 12				jr .ccol1aq 
4511 fe 03		.crow3aq:		cp 3 
4513 20 04				jr nz, .crow4aq 
4515 3e 50				ld a, display_row_3 
4517 18 0a				jr .ccol1aq 
4519 fe 04		.crow4aq:		cp 4 
451b 20 04				jr nz, .crow1aq 
451d 3e 78				ld a, display_row_4 
451f 18 02				jr .ccol1aq 
4521 3e 00		.crow1aq:		ld a,display_row_1 
4523 f5			.ccol1aq:		push af			; got row offset 
4524 6f					ld l,a 
4525 26 00				ld h,0 
4527					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4527 cd e0 22			call macro_forth_dsp_pop 
452a				endm 
# End of macro FORTH_DSP_POP
452a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
452a cd 28 22			call macro_dsp_valuehl 
452d				endm 
# End of macro FORTH_DSP_VALUEHL
452d					; TODO save cursor col 
452d f1					pop af 
452e 85					add l		; add col offset 
452f			 
452f					; add current frame buffer address 
452f 2a 07 fb				ld hl, (display_fb_active) 
4532 cd cf 0f				call addatohl 
4535			 
4535			 
4535			 
4535			 
4535					; get char frame buffer location offset in hl 
4535			 
4535 7e					ld a,(hl) 
4536 26 00				ld h, 0 
4538 6f					ld l, a 
4539			 
4539 cd 23 20				call forth_push_numhl 
453c			 
453c			 
453c					NEXTW 
453c c3 de 23			jp macro_next 
453f				endm 
# End of macro NEXTW
453f			 
453f			.AUTODSP: 
453f				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
453f 63				db WORD_SYS_CORE+79             
4540 55 45			dw .MENU            
4542 05				db 4 + 1 
4543 .. 00			db "ADSP",0              
4548				endm 
# End of macro CWHEAD
4548			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4548			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4548			 
4548					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4548 cd 28 22			call macro_dsp_valuehl 
454b				endm 
# End of macro FORTH_DSP_VALUEHL
454b			 
454b			;		push hl 
454b			 
454b					; destroy value TOS 
454b			 
454b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
454b cd e0 22			call macro_forth_dsp_pop 
454e				endm 
# End of macro FORTH_DSP_POP
454e			 
454e			;		pop hl 
454e			 
454e 7d					ld a,l 
454f 32 77 f9				ld (cli_autodisplay), a 
4552				       NEXTW 
4552 c3 de 23			jp macro_next 
4555				endm 
# End of macro NEXTW
4555			 
4555			.MENU: 
4555				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4555 70				db WORD_SYS_CORE+92             
4556 fe 45			dw .ENDDISPLAY            
4558 05				db 4 + 1 
4559 .. 00			db "MENU",0              
455e				endm 
# End of macro CWHEAD
455e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
455e			 
455e			;		; get number of items on the stack 
455e			; 
455e				 
455e					FORTH_DSP_VALUEHL 
455e cd 28 22			call macro_dsp_valuehl 
4561				endm 
# End of macro FORTH_DSP_VALUEHL
4561				 
4561					if DEBUG_FORTH_WORDS_KEY 
4561						DMARK "MNU" 
4561 f5				push af  
4562 3a 76 45			ld a, (.dmark)  
4565 32 a6 fd			ld (debug_mark),a  
4568 3a 77 45			ld a, (.dmark+1)  
456b 32 a7 fd			ld (debug_mark+1),a  
456e 3a 78 45			ld a, (.dmark+2)  
4571 32 a8 fd			ld (debug_mark+2),a  
4574 18 03			jr .pastdmark  
4576 ..			.dmark: db "MNU"  
4579 f1			.pastdmark: pop af  
457a			endm  
# End of macro DMARK
457a						CALLMONITOR 
457a cd aa fd			call debug_vector  
457d				endm  
# End of macro CALLMONITOR
457d					endif 
457d			 
457d 45					ld b, l	 
457e 05					dec b 
457f			 
457f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
457f cd e0 22			call macro_forth_dsp_pop 
4582				endm 
# End of macro FORTH_DSP_POP
4582			 
4582			 
4582					; go directly through the stack to pluck out the string pointers and build an array 
4582			 
4582			;		FORTH_DSP 
4582			 
4582					; hl contains top most stack item 
4582				 
4582 11 fc f0				ld de, scratch 
4585			 
4585			.mbuild: 
4585			 
4585					FORTH_DSP_VALUEHL 
4585 cd 28 22			call macro_dsp_valuehl 
4588				endm 
# End of macro FORTH_DSP_VALUEHL
4588			 
4588					if DEBUG_FORTH_WORDS 
4588						DMARK "MN3" 
4588 f5				push af  
4589 3a 9d 45			ld a, (.dmark)  
458c 32 a6 fd			ld (debug_mark),a  
458f 3a 9e 45			ld a, (.dmark+1)  
4592 32 a7 fd			ld (debug_mark+1),a  
4595 3a 9f 45			ld a, (.dmark+2)  
4598 32 a8 fd			ld (debug_mark+2),a  
459b 18 03			jr .pastdmark  
459d ..			.dmark: db "MN3"  
45a0 f1			.pastdmark: pop af  
45a1			endm  
# End of macro DMARK
45a1						CALLMONITOR 
45a1 cd aa fd			call debug_vector  
45a4				endm  
# End of macro CALLMONITOR
45a4					endif 
45a4 eb					ex de, hl 
45a5 73					ld (hl), e 
45a6 23					inc hl 
45a7 72					ld (hl), d 
45a8 23					inc hl 
45a9 eb					ex de, hl 
45aa			 
45aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45aa cd e0 22			call macro_forth_dsp_pop 
45ad				endm 
# End of macro FORTH_DSP_POP
45ad			 
45ad 10 d6				djnz .mbuild 
45af			 
45af					; done add term 
45af			 
45af eb					ex de, hl 
45b0 36 00				ld (hl), 0 
45b2 23					inc hl 
45b3 36 00				ld (hl), 0 
45b5			 
45b5				 
45b5					 
45b5 21 fc f0				ld hl, scratch 
45b8			 
45b8					if DEBUG_FORTH_WORDS 
45b8						DMARK "MNx" 
45b8 f5				push af  
45b9 3a cd 45			ld a, (.dmark)  
45bc 32 a6 fd			ld (debug_mark),a  
45bf 3a ce 45			ld a, (.dmark+1)  
45c2 32 a7 fd			ld (debug_mark+1),a  
45c5 3a cf 45			ld a, (.dmark+2)  
45c8 32 a8 fd			ld (debug_mark+2),a  
45cb 18 03			jr .pastdmark  
45cd ..			.dmark: db "MNx"  
45d0 f1			.pastdmark: pop af  
45d1			endm  
# End of macro DMARK
45d1						CALLMONITOR 
45d1 cd aa fd			call debug_vector  
45d4				endm  
# End of macro CALLMONITOR
45d4					endif 
45d4			 
45d4			 
45d4			 
45d4 3e 00				ld a, 0 
45d6 cd cc 0d				call menu 
45d9			 
45d9			 
45d9 6f					ld l, a 
45da 26 00				ld h, 0 
45dc			 
45dc					if DEBUG_FORTH_WORDS 
45dc						DMARK "MNr" 
45dc f5				push af  
45dd 3a f1 45			ld a, (.dmark)  
45e0 32 a6 fd			ld (debug_mark),a  
45e3 3a f2 45			ld a, (.dmark+1)  
45e6 32 a7 fd			ld (debug_mark+1),a  
45e9 3a f3 45			ld a, (.dmark+2)  
45ec 32 a8 fd			ld (debug_mark+2),a  
45ef 18 03			jr .pastdmark  
45f1 ..			.dmark: db "MNr"  
45f4 f1			.pastdmark: pop af  
45f5			endm  
# End of macro DMARK
45f5						CALLMONITOR 
45f5 cd aa fd			call debug_vector  
45f8				endm  
# End of macro CALLMONITOR
45f8					endif 
45f8			 
45f8 cd 23 20				call forth_push_numhl 
45fb			 
45fb			 
45fb			 
45fb			 
45fb				       NEXTW 
45fb c3 de 23			jp macro_next 
45fe				endm 
# End of macro NEXTW
45fe			 
45fe			 
45fe			.ENDDISPLAY: 
45fe			 
45fe			; eof 
# End of file forth_words_display.asm
45fe			include "forth_words_str.asm" 
45fe			 
45fe			; | ## String Words 
45fe			 
45fe			.PTR:   
45fe			 
45fe				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45fe 48				db WORD_SYS_CORE+52             
45ff 2b 46			dw .STYPE            
4601 04				db 3 + 1 
4602 .. 00			db "PTR",0              
4606				endm 
# End of macro CWHEAD
4606			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4606			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4606			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4606			 
4606					if DEBUG_FORTH_WORDS_KEY 
4606						DMARK "PTR" 
4606 f5				push af  
4607 3a 1b 46			ld a, (.dmark)  
460a 32 a6 fd			ld (debug_mark),a  
460d 3a 1c 46			ld a, (.dmark+1)  
4610 32 a7 fd			ld (debug_mark+1),a  
4613 3a 1d 46			ld a, (.dmark+2)  
4616 32 a8 fd			ld (debug_mark+2),a  
4619 18 03			jr .pastdmark  
461b ..			.dmark: db "PTR"  
461e f1			.pastdmark: pop af  
461f			endm  
# End of macro DMARK
461f						CALLMONITOR 
461f cd aa fd			call debug_vector  
4622				endm  
# End of macro CALLMONITOR
4622					endif 
4622					FORTH_DSP_VALUEHL 
4622 cd 28 22			call macro_dsp_valuehl 
4625				endm 
# End of macro FORTH_DSP_VALUEHL
4625 cd 23 20				call forth_push_numhl 
4628			 
4628			 
4628					NEXTW 
4628 c3 de 23			jp macro_next 
462b				endm 
# End of macro NEXTW
462b			.STYPE: 
462b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
462b 48				db WORD_SYS_CORE+52             
462c 7a 46			dw .UPPER            
462e 06				db 5 + 1 
462f .. 00			db "STYPE",0              
4635				endm 
# End of macro CWHEAD
4635			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4635					if DEBUG_FORTH_WORDS_KEY 
4635						DMARK "STY" 
4635 f5				push af  
4636 3a 4a 46			ld a, (.dmark)  
4639 32 a6 fd			ld (debug_mark),a  
463c 3a 4b 46			ld a, (.dmark+1)  
463f 32 a7 fd			ld (debug_mark+1),a  
4642 3a 4c 46			ld a, (.dmark+2)  
4645 32 a8 fd			ld (debug_mark+2),a  
4648 18 03			jr .pastdmark  
464a ..			.dmark: db "STY"  
464d f1			.pastdmark: pop af  
464e			endm  
# End of macro DMARK
464e						CALLMONITOR 
464e cd aa fd			call debug_vector  
4651				endm  
# End of macro CALLMONITOR
4651					endif 
4651					FORTH_DSP 
4651 cd ee 21			call macro_forth_dsp 
4654				endm 
# End of macro FORTH_DSP
4654					;v5 FORTH_DSP_VALUE 
4654			 
4654 7e					ld a, (hl) 
4655			 
4655 f5					push af 
4656			 
4656			; Dont destroy TOS		FORTH_DSP_POP 
4656			 
4656 f1					pop af 
4657			 
4657 fe 01				cp DS_TYPE_STR 
4659 28 09				jr z, .typestr 
465b			 
465b fe 02				cp DS_TYPE_INUM 
465d 28 0a				jr z, .typeinum 
465f			 
465f 21 78 46				ld hl, .tna 
4662 18 0a				jr .tpush 
4664			 
4664 21 74 46		.typestr:	ld hl, .tstr 
4667 18 05				jr .tpush 
4669 21 76 46		.typeinum:	ld hl, .tinum 
466c 18 00				jr .tpush 
466e			 
466e			.tpush: 
466e			 
466e cd 91 20				call forth_push_str 
4671			 
4671					NEXTW 
4671 c3 de 23			jp macro_next 
4674				endm 
# End of macro NEXTW
4674 .. 00		.tstr:	db "s",0 
4676 .. 00		.tinum:  db "i",0 
4678 .. 00		.tna:   db "?", 0 
467a			 
467a			 
467a			.UPPER: 
467a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
467a 48				db WORD_SYS_CORE+52             
467b b5 46			dw .LOWER            
467d 06				db 5 + 1 
467e .. 00			db "UPPER",0              
4684				endm 
# End of macro CWHEAD
4684			; | UPPER ( s -- s ) Upper case string s  | DONE 
4684					if DEBUG_FORTH_WORDS_KEY 
4684						DMARK "UPR" 
4684 f5				push af  
4685 3a 99 46			ld a, (.dmark)  
4688 32 a6 fd			ld (debug_mark),a  
468b 3a 9a 46			ld a, (.dmark+1)  
468e 32 a7 fd			ld (debug_mark+1),a  
4691 3a 9b 46			ld a, (.dmark+2)  
4694 32 a8 fd			ld (debug_mark+2),a  
4697 18 03			jr .pastdmark  
4699 ..			.dmark: db "UPR"  
469c f1			.pastdmark: pop af  
469d			endm  
# End of macro DMARK
469d						CALLMONITOR 
469d cd aa fd			call debug_vector  
46a0				endm  
# End of macro CALLMONITOR
46a0					endif 
46a0			 
46a0					FORTH_DSP 
46a0 cd ee 21			call macro_forth_dsp 
46a3				endm 
# End of macro FORTH_DSP
46a3					 
46a3			; TODO check is string type 
46a3			 
46a3					FORTH_DSP_VALUEHL 
46a3 cd 28 22			call macro_dsp_valuehl 
46a6				endm 
# End of macro FORTH_DSP_VALUEHL
46a6			; get pointer to string in hl 
46a6			 
46a6 7e			.toup:		ld a, (hl) 
46a7 fe 00				cp 0 
46a9 28 07				jr z, .toupdone 
46ab			 
46ab cd 44 12				call to_upper 
46ae			 
46ae 77					ld (hl), a 
46af 23					inc hl 
46b0 18 f4				jr .toup 
46b2			 
46b2					 
46b2			 
46b2			 
46b2			; for each char convert to upper 
46b2					 
46b2			.toupdone: 
46b2			 
46b2			 
46b2					NEXTW 
46b2 c3 de 23			jp macro_next 
46b5				endm 
# End of macro NEXTW
46b5			.LOWER: 
46b5				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
46b5 48				db WORD_SYS_CORE+52             
46b6 f0 46			dw .TCASE            
46b8 06				db 5 + 1 
46b9 .. 00			db "LOWER",0              
46bf				endm 
# End of macro CWHEAD
46bf			; | LOWER ( s -- s ) Lower case string s  | DONE 
46bf					if DEBUG_FORTH_WORDS_KEY 
46bf						DMARK "LWR" 
46bf f5				push af  
46c0 3a d4 46			ld a, (.dmark)  
46c3 32 a6 fd			ld (debug_mark),a  
46c6 3a d5 46			ld a, (.dmark+1)  
46c9 32 a7 fd			ld (debug_mark+1),a  
46cc 3a d6 46			ld a, (.dmark+2)  
46cf 32 a8 fd			ld (debug_mark+2),a  
46d2 18 03			jr .pastdmark  
46d4 ..			.dmark: db "LWR"  
46d7 f1			.pastdmark: pop af  
46d8			endm  
# End of macro DMARK
46d8						CALLMONITOR 
46d8 cd aa fd			call debug_vector  
46db				endm  
# End of macro CALLMONITOR
46db					endif 
46db			 
46db					FORTH_DSP 
46db cd ee 21			call macro_forth_dsp 
46de				endm 
# End of macro FORTH_DSP
46de					 
46de			; TODO check is string type 
46de			 
46de					FORTH_DSP_VALUEHL 
46de cd 28 22			call macro_dsp_valuehl 
46e1				endm 
# End of macro FORTH_DSP_VALUEHL
46e1			; get pointer to string in hl 
46e1			 
46e1 7e			.tolow:		ld a, (hl) 
46e2 fe 00				cp 0 
46e4 28 07				jr z, .tolowdone 
46e6			 
46e6 cd 4d 12				call to_lower 
46e9			 
46e9 77					ld (hl), a 
46ea 23					inc hl 
46eb 18 f4				jr .tolow 
46ed			 
46ed					 
46ed			 
46ed			 
46ed			; for each char convert to low 
46ed					 
46ed			.tolowdone: 
46ed					NEXTW 
46ed c3 de 23			jp macro_next 
46f0				endm 
# End of macro NEXTW
46f0			.TCASE: 
46f0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46f0 48				db WORD_SYS_CORE+52             
46f1 26 48			dw .SUBSTR            
46f3 06				db 5 + 1 
46f4 .. 00			db "TCASE",0              
46fa				endm 
# End of macro CWHEAD
46fa			; | TCASE ( s -- s ) Title case string s  | DONE 
46fa					if DEBUG_FORTH_WORDS_KEY 
46fa						DMARK "TCS" 
46fa f5				push af  
46fb 3a 0f 47			ld a, (.dmark)  
46fe 32 a6 fd			ld (debug_mark),a  
4701 3a 10 47			ld a, (.dmark+1)  
4704 32 a7 fd			ld (debug_mark+1),a  
4707 3a 11 47			ld a, (.dmark+2)  
470a 32 a8 fd			ld (debug_mark+2),a  
470d 18 03			jr .pastdmark  
470f ..			.dmark: db "TCS"  
4712 f1			.pastdmark: pop af  
4713			endm  
# End of macro DMARK
4713						CALLMONITOR 
4713 cd aa fd			call debug_vector  
4716				endm  
# End of macro CALLMONITOR
4716					endif 
4716			 
4716					FORTH_DSP 
4716 cd ee 21			call macro_forth_dsp 
4719				endm 
# End of macro FORTH_DSP
4719					 
4719			; TODO check is string type 
4719			 
4719					FORTH_DSP_VALUEHL 
4719 cd 28 22			call macro_dsp_valuehl 
471c				endm 
# End of macro FORTH_DSP_VALUEHL
471c			; get pointer to string in hl 
471c			 
471c					if DEBUG_FORTH_WORDS 
471c						DMARK "TC1" 
471c f5				push af  
471d 3a 31 47			ld a, (.dmark)  
4720 32 a6 fd			ld (debug_mark),a  
4723 3a 32 47			ld a, (.dmark+1)  
4726 32 a7 fd			ld (debug_mark+1),a  
4729 3a 33 47			ld a, (.dmark+2)  
472c 32 a8 fd			ld (debug_mark+2),a  
472f 18 03			jr .pastdmark  
4731 ..			.dmark: db "TC1"  
4734 f1			.pastdmark: pop af  
4735			endm  
# End of macro DMARK
4735						CALLMONITOR 
4735 cd aa fd			call debug_vector  
4738				endm  
# End of macro CALLMONITOR
4738					endif 
4738			 
4738					; first time in turn to upper case first char 
4738			 
4738 7e					ld a, (hl) 
4739 c3 c3 47				jp .totsiptou 
473c			 
473c			 
473c 7e			.tot:		ld a, (hl) 
473d fe 00				cp 0 
473f ca 07 48				jp z, .totdone 
4742			 
4742					if DEBUG_FORTH_WORDS 
4742						DMARK "TC2" 
4742 f5				push af  
4743 3a 57 47			ld a, (.dmark)  
4746 32 a6 fd			ld (debug_mark),a  
4749 3a 58 47			ld a, (.dmark+1)  
474c 32 a7 fd			ld (debug_mark+1),a  
474f 3a 59 47			ld a, (.dmark+2)  
4752 32 a8 fd			ld (debug_mark+2),a  
4755 18 03			jr .pastdmark  
4757 ..			.dmark: db "TC2"  
475a f1			.pastdmark: pop af  
475b			endm  
# End of macro DMARK
475b						CALLMONITOR 
475b cd aa fd			call debug_vector  
475e				endm  
# End of macro CALLMONITOR
475e					endif 
475e					; check to see if current char is a space 
475e			 
475e fe 20				cp ' ' 
4760 28 21				jr z, .totsp 
4762 cd 4d 12				call to_lower 
4765					if DEBUG_FORTH_WORDS 
4765						DMARK "TC3" 
4765 f5				push af  
4766 3a 7a 47			ld a, (.dmark)  
4769 32 a6 fd			ld (debug_mark),a  
476c 3a 7b 47			ld a, (.dmark+1)  
476f 32 a7 fd			ld (debug_mark+1),a  
4772 3a 7c 47			ld a, (.dmark+2)  
4775 32 a8 fd			ld (debug_mark+2),a  
4778 18 03			jr .pastdmark  
477a ..			.dmark: db "TC3"  
477d f1			.pastdmark: pop af  
477e			endm  
# End of macro DMARK
477e						CALLMONITOR 
477e cd aa fd			call debug_vector  
4781				endm  
# End of macro CALLMONITOR
4781					endif 
4781 18 63				jr .totnxt 
4783			 
4783			.totsp:         ; on a space, find next char which should be upper 
4783			 
4783					if DEBUG_FORTH_WORDS 
4783						DMARK "TC4" 
4783 f5				push af  
4784 3a 98 47			ld a, (.dmark)  
4787 32 a6 fd			ld (debug_mark),a  
478a 3a 99 47			ld a, (.dmark+1)  
478d 32 a7 fd			ld (debug_mark+1),a  
4790 3a 9a 47			ld a, (.dmark+2)  
4793 32 a8 fd			ld (debug_mark+2),a  
4796 18 03			jr .pastdmark  
4798 ..			.dmark: db "TC4"  
479b f1			.pastdmark: pop af  
479c			endm  
# End of macro DMARK
479c						CALLMONITOR 
479c cd aa fd			call debug_vector  
479f				endm  
# End of macro CALLMONITOR
479f					endif 
479f					;; 
479f			 
479f fe 20				cp ' ' 
47a1 20 20				jr nz, .totsiptou 
47a3 23					inc hl 
47a4 7e					ld a, (hl) 
47a5					if DEBUG_FORTH_WORDS 
47a5						DMARK "TC5" 
47a5 f5				push af  
47a6 3a ba 47			ld a, (.dmark)  
47a9 32 a6 fd			ld (debug_mark),a  
47ac 3a bb 47			ld a, (.dmark+1)  
47af 32 a7 fd			ld (debug_mark+1),a  
47b2 3a bc 47			ld a, (.dmark+2)  
47b5 32 a8 fd			ld (debug_mark+2),a  
47b8 18 03			jr .pastdmark  
47ba ..			.dmark: db "TC5"  
47bd f1			.pastdmark: pop af  
47be			endm  
# End of macro DMARK
47be						CALLMONITOR 
47be cd aa fd			call debug_vector  
47c1				endm  
# End of macro CALLMONITOR
47c1					endif 
47c1 18 c0				jr .totsp 
47c3 fe 00		.totsiptou:    cp 0 
47c5 28 40				jr z, .totdone 
47c7					; not space and not zero term so upper case it 
47c7 cd 44 12				call to_upper 
47ca			 
47ca					if DEBUG_FORTH_WORDS 
47ca						DMARK "TC6" 
47ca f5				push af  
47cb 3a df 47			ld a, (.dmark)  
47ce 32 a6 fd			ld (debug_mark),a  
47d1 3a e0 47			ld a, (.dmark+1)  
47d4 32 a7 fd			ld (debug_mark+1),a  
47d7 3a e1 47			ld a, (.dmark+2)  
47da 32 a8 fd			ld (debug_mark+2),a  
47dd 18 03			jr .pastdmark  
47df ..			.dmark: db "TC6"  
47e2 f1			.pastdmark: pop af  
47e3			endm  
# End of macro DMARK
47e3						CALLMONITOR 
47e3 cd aa fd			call debug_vector  
47e6				endm  
# End of macro CALLMONITOR
47e6					endif 
47e6			 
47e6			 
47e6			.totnxt: 
47e6			 
47e6 77					ld (hl), a 
47e7 23					inc hl 
47e8					if DEBUG_FORTH_WORDS 
47e8						DMARK "TC7" 
47e8 f5				push af  
47e9 3a fd 47			ld a, (.dmark)  
47ec 32 a6 fd			ld (debug_mark),a  
47ef 3a fe 47			ld a, (.dmark+1)  
47f2 32 a7 fd			ld (debug_mark+1),a  
47f5 3a ff 47			ld a, (.dmark+2)  
47f8 32 a8 fd			ld (debug_mark+2),a  
47fb 18 03			jr .pastdmark  
47fd ..			.dmark: db "TC7"  
4800 f1			.pastdmark: pop af  
4801			endm  
# End of macro DMARK
4801						CALLMONITOR 
4801 cd aa fd			call debug_vector  
4804				endm  
# End of macro CALLMONITOR
4804					endif 
4804 c3 3c 47				jp .tot 
4807			 
4807					 
4807			 
4807			 
4807			; for each char convert to low 
4807					 
4807			.totdone: 
4807					if DEBUG_FORTH_WORDS 
4807						DMARK "TCd" 
4807 f5				push af  
4808 3a 1c 48			ld a, (.dmark)  
480b 32 a6 fd			ld (debug_mark),a  
480e 3a 1d 48			ld a, (.dmark+1)  
4811 32 a7 fd			ld (debug_mark+1),a  
4814 3a 1e 48			ld a, (.dmark+2)  
4817 32 a8 fd			ld (debug_mark+2),a  
481a 18 03			jr .pastdmark  
481c ..			.dmark: db "TCd"  
481f f1			.pastdmark: pop af  
4820			endm  
# End of macro DMARK
4820						CALLMONITOR 
4820 cd aa fd			call debug_vector  
4823				endm  
# End of macro CALLMONITOR
4823					endif 
4823					NEXTW 
4823 c3 de 23			jp macro_next 
4826				endm 
# End of macro NEXTW
4826			 
4826			.SUBSTR: 
4826				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4826 48				db WORD_SYS_CORE+52             
4827 84 48			dw .LEFT            
4829 07				db 6 + 1 
482a .. 00			db "SUBSTR",0              
4831				endm 
# End of macro CWHEAD
4831			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4831			 
4831					if DEBUG_FORTH_WORDS_KEY 
4831						DMARK "SST" 
4831 f5				push af  
4832 3a 46 48			ld a, (.dmark)  
4835 32 a6 fd			ld (debug_mark),a  
4838 3a 47 48			ld a, (.dmark+1)  
483b 32 a7 fd			ld (debug_mark+1),a  
483e 3a 48 48			ld a, (.dmark+2)  
4841 32 a8 fd			ld (debug_mark+2),a  
4844 18 03			jr .pastdmark  
4846 ..			.dmark: db "SST"  
4849 f1			.pastdmark: pop af  
484a			endm  
# End of macro DMARK
484a						CALLMONITOR 
484a cd aa fd			call debug_vector  
484d				endm  
# End of macro CALLMONITOR
484d					endif 
484d			; TODO check string type 
484d					FORTH_DSP_VALUEHL 
484d cd 28 22			call macro_dsp_valuehl 
4850				endm 
# End of macro FORTH_DSP_VALUEHL
4850			 
4850 e5					push hl      ; string length 
4851			 
4851					FORTH_DSP_POP 
4851 cd e0 22			call macro_forth_dsp_pop 
4854				endm 
# End of macro FORTH_DSP_POP
4854			 
4854					FORTH_DSP_VALUEHL 
4854 cd 28 22			call macro_dsp_valuehl 
4857				endm 
# End of macro FORTH_DSP_VALUEHL
4857			 
4857 e5					push hl     ; start char 
4858			 
4858					FORTH_DSP_POP 
4858 cd e0 22			call macro_forth_dsp_pop 
485b				endm 
# End of macro FORTH_DSP_POP
485b			 
485b			 
485b					FORTH_DSP_VALUE 
485b cd 11 22			call macro_forth_dsp_value 
485e				endm 
# End of macro FORTH_DSP_VALUE
485e			 
485e d1					pop de    ; get start post offset 
485f			 
485f 19					add hl, de    ; starting offset 
4860			 
4860 c1					pop bc 
4861 c5					push bc      ; grab size of string 
4862			 
4862 e5					push hl    ; save string start  
4863			 
4863 26 00				ld h, 0 
4865 69					ld l, c 
4866 23					inc hl 
4867 23					inc hl 
4868			 
4868 cd aa 13				call malloc 
486b				if DEBUG_FORTH_MALLOC_GUARD 
486b cc b1 5d				call z,malloc_error 
486e				endif 
486e			 
486e eb					ex de, hl      ; save malloc area for string copy 
486f e1					pop hl    ; get back source 
4870 c1					pop bc    ; get length of string back 
4871			 
4871 d5					push de    ; save malloc area for after we push 
4872 ed b0				ldir     ; copy substr 
4874			 
4874			 
4874 eb					ex de, hl 
4875 3e 00				ld a, 0 
4877 77					ld (hl), a   ; term substr 
4878			 
4878					 
4878 e1					pop hl    ; get malloc so we can push it 
4879 e5					push hl   ; save so we can free it afterwards 
487a			 
487a cd 91 20				call forth_push_str 
487d			 
487d e1					pop hl 
487e cd 74 14				call free 
4881			 
4881					 
4881					 
4881			 
4881			 
4881					NEXTW 
4881 c3 de 23			jp macro_next 
4884				endm 
# End of macro NEXTW
4884			 
4884			.LEFT: 
4884				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4884 48				db WORD_SYS_CORE+52             
4885 ac 48			dw .RIGHT            
4887 05				db 4 + 1 
4888 .. 00			db "LEFT",0              
488d				endm 
# End of macro CWHEAD
488d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
488d					if DEBUG_FORTH_WORDS_KEY 
488d						DMARK "LEF" 
488d f5				push af  
488e 3a a2 48			ld a, (.dmark)  
4891 32 a6 fd			ld (debug_mark),a  
4894 3a a3 48			ld a, (.dmark+1)  
4897 32 a7 fd			ld (debug_mark+1),a  
489a 3a a4 48			ld a, (.dmark+2)  
489d 32 a8 fd			ld (debug_mark+2),a  
48a0 18 03			jr .pastdmark  
48a2 ..			.dmark: db "LEF"  
48a5 f1			.pastdmark: pop af  
48a6			endm  
# End of macro DMARK
48a6						CALLMONITOR 
48a6 cd aa fd			call debug_vector  
48a9				endm  
# End of macro CALLMONITOR
48a9					endif 
48a9			 
48a9					NEXTW 
48a9 c3 de 23			jp macro_next 
48ac				endm 
# End of macro NEXTW
48ac			.RIGHT: 
48ac				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
48ac 48				db WORD_SYS_CORE+52             
48ad d5 48			dw .STR2NUM            
48af 06				db 5 + 1 
48b0 .. 00			db "RIGHT",0              
48b6				endm 
# End of macro CWHEAD
48b6			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
48b6					if DEBUG_FORTH_WORDS_KEY 
48b6						DMARK "RIG" 
48b6 f5				push af  
48b7 3a cb 48			ld a, (.dmark)  
48ba 32 a6 fd			ld (debug_mark),a  
48bd 3a cc 48			ld a, (.dmark+1)  
48c0 32 a7 fd			ld (debug_mark+1),a  
48c3 3a cd 48			ld a, (.dmark+2)  
48c6 32 a8 fd			ld (debug_mark+2),a  
48c9 18 03			jr .pastdmark  
48cb ..			.dmark: db "RIG"  
48ce f1			.pastdmark: pop af  
48cf			endm  
# End of macro DMARK
48cf						CALLMONITOR 
48cf cd aa fd			call debug_vector  
48d2				endm  
# End of macro CALLMONITOR
48d2					endif 
48d2			 
48d2					NEXTW 
48d2 c3 de 23			jp macro_next 
48d5				endm 
# End of macro NEXTW
48d5			 
48d5			 
48d5			.STR2NUM: 
48d5				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48d5 48				db WORD_SYS_CORE+52             
48d6 61 49			dw .NUM2STR            
48d8 08				db 7 + 1 
48d9 .. 00			db "STR2NUM",0              
48e1				endm 
# End of macro CWHEAD
48e1			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
48e1			 
48e1			 
48e1			; TODO STR type check to do 
48e1					if DEBUG_FORTH_WORDS_KEY 
48e1						DMARK "S2N" 
48e1 f5				push af  
48e2 3a f6 48			ld a, (.dmark)  
48e5 32 a6 fd			ld (debug_mark),a  
48e8 3a f7 48			ld a, (.dmark+1)  
48eb 32 a7 fd			ld (debug_mark+1),a  
48ee 3a f8 48			ld a, (.dmark+2)  
48f1 32 a8 fd			ld (debug_mark+2),a  
48f4 18 03			jr .pastdmark  
48f6 ..			.dmark: db "S2N"  
48f9 f1			.pastdmark: pop af  
48fa			endm  
# End of macro DMARK
48fa						CALLMONITOR 
48fa cd aa fd			call debug_vector  
48fd				endm  
# End of macro CALLMONITOR
48fd					endif 
48fd			 
48fd					;FORTH_DSP 
48fd					FORTH_DSP_VALUE 
48fd cd 11 22			call macro_forth_dsp_value 
4900				endm 
# End of macro FORTH_DSP_VALUE
4900					;inc hl 
4900			 
4900 eb					ex de, hl 
4901					if DEBUG_FORTH_WORDS 
4901						DMARK "S2a" 
4901 f5				push af  
4902 3a 16 49			ld a, (.dmark)  
4905 32 a6 fd			ld (debug_mark),a  
4908 3a 17 49			ld a, (.dmark+1)  
490b 32 a7 fd			ld (debug_mark+1),a  
490e 3a 18 49			ld a, (.dmark+2)  
4911 32 a8 fd			ld (debug_mark+2),a  
4914 18 03			jr .pastdmark  
4916 ..			.dmark: db "S2a"  
4919 f1			.pastdmark: pop af  
491a			endm  
# End of macro DMARK
491a						CALLMONITOR 
491a cd aa fd			call debug_vector  
491d				endm  
# End of macro CALLMONITOR
491d					endif 
491d cd cc 12				call string_to_uint16 
4920			 
4920					if DEBUG_FORTH_WORDS 
4920						DMARK "S2b" 
4920 f5				push af  
4921 3a 35 49			ld a, (.dmark)  
4924 32 a6 fd			ld (debug_mark),a  
4927 3a 36 49			ld a, (.dmark+1)  
492a 32 a7 fd			ld (debug_mark+1),a  
492d 3a 37 49			ld a, (.dmark+2)  
4930 32 a8 fd			ld (debug_mark+2),a  
4933 18 03			jr .pastdmark  
4935 ..			.dmark: db "S2b"  
4938 f1			.pastdmark: pop af  
4939			endm  
# End of macro DMARK
4939						CALLMONITOR 
4939 cd aa fd			call debug_vector  
493c				endm  
# End of macro CALLMONITOR
493c					endif 
493c			;		push hl 
493c					FORTH_DSP_POP 
493c cd e0 22			call macro_forth_dsp_pop 
493f				endm 
# End of macro FORTH_DSP_POP
493f			;		pop hl 
493f					 
493f					if DEBUG_FORTH_WORDS 
493f						DMARK "S2b" 
493f f5				push af  
4940 3a 54 49			ld a, (.dmark)  
4943 32 a6 fd			ld (debug_mark),a  
4946 3a 55 49			ld a, (.dmark+1)  
4949 32 a7 fd			ld (debug_mark+1),a  
494c 3a 56 49			ld a, (.dmark+2)  
494f 32 a8 fd			ld (debug_mark+2),a  
4952 18 03			jr .pastdmark  
4954 ..			.dmark: db "S2b"  
4957 f1			.pastdmark: pop af  
4958			endm  
# End of macro DMARK
4958						CALLMONITOR 
4958 cd aa fd			call debug_vector  
495b				endm  
# End of macro CALLMONITOR
495b					endif 
495b cd 23 20				call forth_push_numhl	 
495e			 
495e				 
495e				       NEXTW 
495e c3 de 23			jp macro_next 
4961				endm 
# End of macro NEXTW
4961			.NUM2STR: 
4961				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4961 48				db WORD_SYS_CORE+52             
4962 70 49			dw .CONCAT            
4964 08				db 7 + 1 
4965 .. 00			db "NUM2STR",0              
496d				endm 
# End of macro CWHEAD
496d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
496d			 
496d			;		; malloc a string to target 
496d			;		ld hl, 10     ; TODO max string size should be fine 
496d			;		call malloc 
496d			;		push hl    ; save malloc location 
496d			; 
496d			; 
496d			;; TODO check int type 
496d			;		FORTH_DSP_VALUEHL 
496d			;		ld a, l 
496d			;		call DispAToASCII   
496d			;;TODO need to chage above call to dump into string 
496d			; 
496d			; 
496d			 
496d				       NEXTW 
496d c3 de 23			jp macro_next 
4970				endm 
# End of macro NEXTW
4970			 
4970			.CONCAT: 
4970				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4970 48				db WORD_SYS_CORE+52             
4971 23 4a			dw .FIND            
4973 07				db 6 + 1 
4974 .. 00			db "CONCAT",0              
497b				endm 
# End of macro CWHEAD
497b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
497b			 
497b			; TODO check string type 
497b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
497b			 
497b					if DEBUG_FORTH_WORDS_KEY 
497b						DMARK "CON" 
497b f5				push af  
497c 3a 90 49			ld a, (.dmark)  
497f 32 a6 fd			ld (debug_mark),a  
4982 3a 91 49			ld a, (.dmark+1)  
4985 32 a7 fd			ld (debug_mark+1),a  
4988 3a 92 49			ld a, (.dmark+2)  
498b 32 a8 fd			ld (debug_mark+2),a  
498e 18 03			jr .pastdmark  
4990 ..			.dmark: db "CON"  
4993 f1			.pastdmark: pop af  
4994			endm  
# End of macro DMARK
4994						CALLMONITOR 
4994 cd aa fd			call debug_vector  
4997				endm  
# End of macro CALLMONITOR
4997					endif 
4997			 
4997			 
4997					FORTH_DSP_VALUE 
4997 cd 11 22			call macro_forth_dsp_value 
499a				endm 
# End of macro FORTH_DSP_VALUE
499a e5					push hl   ; s2 
499b			 
499b					FORTH_DSP_POP 
499b cd e0 22			call macro_forth_dsp_pop 
499e				endm 
# End of macro FORTH_DSP_POP
499e			 
499e					FORTH_DSP_VALUE 
499e cd 11 22			call macro_forth_dsp_value 
49a1				endm 
# End of macro FORTH_DSP_VALUE
49a1			 
49a1 e5					push hl   ; s1 
49a2			 
49a2					FORTH_DSP_POP 
49a2 cd e0 22			call macro_forth_dsp_pop 
49a5				endm 
# End of macro FORTH_DSP_POP
49a5					 
49a5			 
49a5					; copy s1 
49a5			 
49a5				 
49a5					; save ptr 
49a5 e1					pop hl  
49a6 e5					push hl 
49a7 3e 00				ld a, 0 
49a9 cd 40 13				call strlent 
49ac					;inc hl    ; zer0 
49ac 06 00				ld b, 0 
49ae 4d					ld c, l 
49af e1					pop hl		 
49b0 11 fc f0				ld de, scratch	 
49b3					if DEBUG_FORTH_WORDS 
49b3						DMARK "CO1" 
49b3 f5				push af  
49b4 3a c8 49			ld a, (.dmark)  
49b7 32 a6 fd			ld (debug_mark),a  
49ba 3a c9 49			ld a, (.dmark+1)  
49bd 32 a7 fd			ld (debug_mark+1),a  
49c0 3a ca 49			ld a, (.dmark+2)  
49c3 32 a8 fd			ld (debug_mark+2),a  
49c6 18 03			jr .pastdmark  
49c8 ..			.dmark: db "CO1"  
49cb f1			.pastdmark: pop af  
49cc			endm  
# End of macro DMARK
49cc						CALLMONITOR 
49cc cd aa fd			call debug_vector  
49cf				endm  
# End of macro CALLMONITOR
49cf					endif 
49cf ed b0				ldir 
49d1			 
49d1 e1					pop hl 
49d2 e5					push hl 
49d3 d5					push de 
49d4			 
49d4			 
49d4 3e 00				ld a, 0 
49d6 cd 40 13				call strlent 
49d9 23					inc hl    ; zer0 
49da 23					inc hl 
49db 06 00				ld b, 0 
49dd 4d					ld c, l 
49de d1					pop de 
49df e1					pop hl		 
49e0					if DEBUG_FORTH_WORDS 
49e0						DMARK "CO2" 
49e0 f5				push af  
49e1 3a f5 49			ld a, (.dmark)  
49e4 32 a6 fd			ld (debug_mark),a  
49e7 3a f6 49			ld a, (.dmark+1)  
49ea 32 a7 fd			ld (debug_mark+1),a  
49ed 3a f7 49			ld a, (.dmark+2)  
49f0 32 a8 fd			ld (debug_mark+2),a  
49f3 18 03			jr .pastdmark  
49f5 ..			.dmark: db "CO2"  
49f8 f1			.pastdmark: pop af  
49f9			endm  
# End of macro DMARK
49f9						CALLMONITOR 
49f9 cd aa fd			call debug_vector  
49fc				endm  
# End of macro CALLMONITOR
49fc					endif 
49fc ed b0				ldir 
49fe			 
49fe			 
49fe			 
49fe 21 fc f0				ld hl, scratch 
4a01					if DEBUG_FORTH_WORDS 
4a01						DMARK "CO5" 
4a01 f5				push af  
4a02 3a 16 4a			ld a, (.dmark)  
4a05 32 a6 fd			ld (debug_mark),a  
4a08 3a 17 4a			ld a, (.dmark+1)  
4a0b 32 a7 fd			ld (debug_mark+1),a  
4a0e 3a 18 4a			ld a, (.dmark+2)  
4a11 32 a8 fd			ld (debug_mark+2),a  
4a14 18 03			jr .pastdmark  
4a16 ..			.dmark: db "CO5"  
4a19 f1			.pastdmark: pop af  
4a1a			endm  
# End of macro DMARK
4a1a						CALLMONITOR 
4a1a cd aa fd			call debug_vector  
4a1d				endm  
# End of macro CALLMONITOR
4a1d					endif 
4a1d			 
4a1d cd 91 20				call forth_push_str 
4a20			 
4a20			 
4a20			 
4a20			 
4a20				       NEXTW 
4a20 c3 de 23			jp macro_next 
4a23				endm 
# End of macro NEXTW
4a23			 
4a23			 
4a23			.FIND: 
4a23				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a23 4b				db WORD_SYS_CORE+55             
4a24 e1 4a			dw .LEN            
4a26 05				db 4 + 1 
4a27 .. 00			db "FIND",0              
4a2c				endm 
# End of macro CWHEAD
4a2c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a2c			 
4a2c					if DEBUG_FORTH_WORDS_KEY 
4a2c						DMARK "FND" 
4a2c f5				push af  
4a2d 3a 41 4a			ld a, (.dmark)  
4a30 32 a6 fd			ld (debug_mark),a  
4a33 3a 42 4a			ld a, (.dmark+1)  
4a36 32 a7 fd			ld (debug_mark+1),a  
4a39 3a 43 4a			ld a, (.dmark+2)  
4a3c 32 a8 fd			ld (debug_mark+2),a  
4a3f 18 03			jr .pastdmark  
4a41 ..			.dmark: db "FND"  
4a44 f1			.pastdmark: pop af  
4a45			endm  
# End of macro DMARK
4a45						CALLMONITOR 
4a45 cd aa fd			call debug_vector  
4a48				endm  
# End of macro CALLMONITOR
4a48					endif 
4a48			 
4a48			; TODO check string type 
4a48					FORTH_DSP_VALUE 
4a48 cd 11 22			call macro_forth_dsp_value 
4a4b				endm 
# End of macro FORTH_DSP_VALUE
4a4b			 
4a4b e5					push hl    
4a4c 7e					ld a,(hl)    ; char to find   
4a4d			; TODO change char to substr 
4a4d			 
4a4d f5					push af 
4a4e					 
4a4e			 
4a4e			 
4a4e					if DEBUG_FORTH_WORDS 
4a4e						DMARK "FN1" 
4a4e f5				push af  
4a4f 3a 63 4a			ld a, (.dmark)  
4a52 32 a6 fd			ld (debug_mark),a  
4a55 3a 64 4a			ld a, (.dmark+1)  
4a58 32 a7 fd			ld (debug_mark+1),a  
4a5b 3a 65 4a			ld a, (.dmark+2)  
4a5e 32 a8 fd			ld (debug_mark+2),a  
4a61 18 03			jr .pastdmark  
4a63 ..			.dmark: db "FN1"  
4a66 f1			.pastdmark: pop af  
4a67			endm  
# End of macro DMARK
4a67						CALLMONITOR 
4a67 cd aa fd			call debug_vector  
4a6a				endm  
# End of macro CALLMONITOR
4a6a					endif 
4a6a			 
4a6a					FORTH_DSP_POP 
4a6a cd e0 22			call macro_forth_dsp_pop 
4a6d				endm 
# End of macro FORTH_DSP_POP
4a6d			 
4a6d					; string to search 
4a6d			 
4a6d					FORTH_DSP_VALUE 
4a6d cd 11 22			call macro_forth_dsp_value 
4a70				endm 
# End of macro FORTH_DSP_VALUE
4a70			 
4a70 d1					pop de  ; d is char to find  
4a71			 
4a71					if DEBUG_FORTH_WORDS 
4a71						DMARK "FN2" 
4a71 f5				push af  
4a72 3a 86 4a			ld a, (.dmark)  
4a75 32 a6 fd			ld (debug_mark),a  
4a78 3a 87 4a			ld a, (.dmark+1)  
4a7b 32 a7 fd			ld (debug_mark+1),a  
4a7e 3a 88 4a			ld a, (.dmark+2)  
4a81 32 a8 fd			ld (debug_mark+2),a  
4a84 18 03			jr .pastdmark  
4a86 ..			.dmark: db "FN2"  
4a89 f1			.pastdmark: pop af  
4a8a			endm  
# End of macro DMARK
4a8a						CALLMONITOR 
4a8a cd aa fd			call debug_vector  
4a8d				endm  
# End of macro CALLMONITOR
4a8d					endif 
4a8d					 
4a8d 01 00 00				ld bc, 0 
4a90 7e			.findchar:      ld a,(hl) 
4a91 fe 00				cp 0   		 
4a93 28 27				jr z, .finddone     
4a95 ba					cp d 
4a96 28 20				jr z, .foundchar 
4a98 03					inc bc 
4a99 23					inc hl 
4a9a					if DEBUG_FORTH_WORDS 
4a9a						DMARK "FN3" 
4a9a f5				push af  
4a9b 3a af 4a			ld a, (.dmark)  
4a9e 32 a6 fd			ld (debug_mark),a  
4aa1 3a b0 4a			ld a, (.dmark+1)  
4aa4 32 a7 fd			ld (debug_mark+1),a  
4aa7 3a b1 4a			ld a, (.dmark+2)  
4aaa 32 a8 fd			ld (debug_mark+2),a  
4aad 18 03			jr .pastdmark  
4aaf ..			.dmark: db "FN3"  
4ab2 f1			.pastdmark: pop af  
4ab3			endm  
# End of macro DMARK
4ab3						CALLMONITOR 
4ab3 cd aa fd			call debug_vector  
4ab6				endm  
# End of macro CALLMONITOR
4ab6					endif 
4ab6 18 d8				jr .findchar 
4ab8			 
4ab8			 
4ab8 c5			.foundchar:	push bc 
4ab9 e1					pop hl 
4aba 18 03				jr .findexit 
4abc			 
4abc			 
4abc							 
4abc			 
4abc			.finddone:     ; got to end of string with no find 
4abc 21 00 00				ld hl, 0 
4abf			.findexit: 
4abf			 
4abf					if DEBUG_FORTH_WORDS 
4abf						DMARK "FNd" 
4abf f5				push af  
4ac0 3a d4 4a			ld a, (.dmark)  
4ac3 32 a6 fd			ld (debug_mark),a  
4ac6 3a d5 4a			ld a, (.dmark+1)  
4ac9 32 a7 fd			ld (debug_mark+1),a  
4acc 3a d6 4a			ld a, (.dmark+2)  
4acf 32 a8 fd			ld (debug_mark+2),a  
4ad2 18 03			jr .pastdmark  
4ad4 ..			.dmark: db "FNd"  
4ad7 f1			.pastdmark: pop af  
4ad8			endm  
# End of macro DMARK
4ad8						CALLMONITOR 
4ad8 cd aa fd			call debug_vector  
4adb				endm  
# End of macro CALLMONITOR
4adb					endif 
4adb cd 23 20			call forth_push_numhl 
4ade			 
4ade				       NEXTW 
4ade c3 de 23			jp macro_next 
4ae1				endm 
# End of macro NEXTW
4ae1			 
4ae1			.LEN: 
4ae1				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ae1 4c				db WORD_SYS_CORE+56             
4ae2 4b 4b			dw .ASC            
4ae4 06				db 5 + 1 
4ae5 .. 00			db "COUNT",0              
4aeb				endm 
# End of macro CWHEAD
4aeb			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4aeb			 
4aeb					if DEBUG_FORTH_WORDS_KEY 
4aeb						DMARK "CNT" 
4aeb f5				push af  
4aec 3a 00 4b			ld a, (.dmark)  
4aef 32 a6 fd			ld (debug_mark),a  
4af2 3a 01 4b			ld a, (.dmark+1)  
4af5 32 a7 fd			ld (debug_mark+1),a  
4af8 3a 02 4b			ld a, (.dmark+2)  
4afb 32 a8 fd			ld (debug_mark+2),a  
4afe 18 03			jr .pastdmark  
4b00 ..			.dmark: db "CNT"  
4b03 f1			.pastdmark: pop af  
4b04			endm  
# End of macro DMARK
4b04						CALLMONITOR 
4b04 cd aa fd			call debug_vector  
4b07				endm  
# End of macro CALLMONITOR
4b07					endif 
4b07			; TODO check string type 
4b07					FORTH_DSP_VALUE 
4b07 cd 11 22			call macro_forth_dsp_value 
4b0a				endm 
# End of macro FORTH_DSP_VALUE
4b0a			 
4b0a			 
4b0a					if DEBUG_FORTH_WORDS 
4b0a						DMARK "CN?" 
4b0a f5				push af  
4b0b 3a 1f 4b			ld a, (.dmark)  
4b0e 32 a6 fd			ld (debug_mark),a  
4b11 3a 20 4b			ld a, (.dmark+1)  
4b14 32 a7 fd			ld (debug_mark+1),a  
4b17 3a 21 4b			ld a, (.dmark+2)  
4b1a 32 a8 fd			ld (debug_mark+2),a  
4b1d 18 03			jr .pastdmark  
4b1f ..			.dmark: db "CN?"  
4b22 f1			.pastdmark: pop af  
4b23			endm  
# End of macro DMARK
4b23						CALLMONITOR 
4b23 cd aa fd			call debug_vector  
4b26				endm  
# End of macro CALLMONITOR
4b26					endif 
4b26 cd 35 13				call strlenz 
4b29					if DEBUG_FORTH_WORDS 
4b29						DMARK "CNl" 
4b29 f5				push af  
4b2a 3a 3e 4b			ld a, (.dmark)  
4b2d 32 a6 fd			ld (debug_mark),a  
4b30 3a 3f 4b			ld a, (.dmark+1)  
4b33 32 a7 fd			ld (debug_mark+1),a  
4b36 3a 40 4b			ld a, (.dmark+2)  
4b39 32 a8 fd			ld (debug_mark+2),a  
4b3c 18 03			jr .pastdmark  
4b3e ..			.dmark: db "CNl"  
4b41 f1			.pastdmark: pop af  
4b42			endm  
# End of macro DMARK
4b42						CALLMONITOR 
4b42 cd aa fd			call debug_vector  
4b45				endm  
# End of macro CALLMONITOR
4b45					endif 
4b45			 
4b45 cd 23 20				call forth_push_numhl 
4b48			 
4b48			 
4b48			 
4b48				       NEXTW 
4b48 c3 de 23			jp macro_next 
4b4b				endm 
# End of macro NEXTW
4b4b			.ASC: 
4b4b				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b4b 4d				db WORD_SYS_CORE+57             
4b4c b9 4b			dw .CHR            
4b4e 04				db 3 + 1 
4b4f .. 00			db "ASC",0              
4b53				endm 
# End of macro CWHEAD
4b53			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4b53					if DEBUG_FORTH_WORDS_KEY 
4b53						DMARK "ASC" 
4b53 f5				push af  
4b54 3a 68 4b			ld a, (.dmark)  
4b57 32 a6 fd			ld (debug_mark),a  
4b5a 3a 69 4b			ld a, (.dmark+1)  
4b5d 32 a7 fd			ld (debug_mark+1),a  
4b60 3a 6a 4b			ld a, (.dmark+2)  
4b63 32 a8 fd			ld (debug_mark+2),a  
4b66 18 03			jr .pastdmark  
4b68 ..			.dmark: db "ASC"  
4b6b f1			.pastdmark: pop af  
4b6c			endm  
# End of macro DMARK
4b6c						CALLMONITOR 
4b6c cd aa fd			call debug_vector  
4b6f				endm  
# End of macro CALLMONITOR
4b6f					endif 
4b6f					FORTH_DSP_VALUE 
4b6f cd 11 22			call macro_forth_dsp_value 
4b72				endm 
# End of macro FORTH_DSP_VALUE
4b72					;v5 FORTH_DSP_VALUE 
4b72			;		inc hl      ; now at start of numeric as string 
4b72			 
4b72 e5					push hl 
4b73			 
4b73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b73 cd e0 22			call macro_forth_dsp_pop 
4b76				endm 
# End of macro FORTH_DSP_POP
4b76			 
4b76 e1					pop hl 
4b77			 
4b77					if DEBUG_FORTH_WORDS 
4b77						DMARK "AS1" 
4b77 f5				push af  
4b78 3a 8c 4b			ld a, (.dmark)  
4b7b 32 a6 fd			ld (debug_mark),a  
4b7e 3a 8d 4b			ld a, (.dmark+1)  
4b81 32 a7 fd			ld (debug_mark+1),a  
4b84 3a 8e 4b			ld a, (.dmark+2)  
4b87 32 a8 fd			ld (debug_mark+2),a  
4b8a 18 03			jr .pastdmark  
4b8c ..			.dmark: db "AS1"  
4b8f f1			.pastdmark: pop af  
4b90			endm  
# End of macro DMARK
4b90						CALLMONITOR 
4b90 cd aa fd			call debug_vector  
4b93				endm  
# End of macro CALLMONITOR
4b93					endif 
4b93					; push the content of a onto the stack as a value 
4b93			 
4b93 7e					ld a,(hl)   ; get char 
4b94 26 00				ld h,0 
4b96 6f					ld l,a 
4b97					if DEBUG_FORTH_WORDS 
4b97						DMARK "AS2" 
4b97 f5				push af  
4b98 3a ac 4b			ld a, (.dmark)  
4b9b 32 a6 fd			ld (debug_mark),a  
4b9e 3a ad 4b			ld a, (.dmark+1)  
4ba1 32 a7 fd			ld (debug_mark+1),a  
4ba4 3a ae 4b			ld a, (.dmark+2)  
4ba7 32 a8 fd			ld (debug_mark+2),a  
4baa 18 03			jr .pastdmark  
4bac ..			.dmark: db "AS2"  
4baf f1			.pastdmark: pop af  
4bb0			endm  
# End of macro DMARK
4bb0						CALLMONITOR 
4bb0 cd aa fd			call debug_vector  
4bb3				endm  
# End of macro CALLMONITOR
4bb3					endif 
4bb3 cd 23 20				call forth_push_numhl 
4bb6			 
4bb6				       NEXTW 
4bb6 c3 de 23			jp macro_next 
4bb9				endm 
# End of macro NEXTW
4bb9			 
4bb9			.CHR: 
4bb9				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4bb9 4d				db WORD_SYS_CORE+57             
4bba f5 4b			dw .ENDSTR            
4bbc 04				db 3 + 1 
4bbd .. 00			db "CHR",0              
4bc1				endm 
# End of macro CWHEAD
4bc1			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4bc1					if DEBUG_FORTH_WORDS_KEY 
4bc1						DMARK "CHR" 
4bc1 f5				push af  
4bc2 3a d6 4b			ld a, (.dmark)  
4bc5 32 a6 fd			ld (debug_mark),a  
4bc8 3a d7 4b			ld a, (.dmark+1)  
4bcb 32 a7 fd			ld (debug_mark+1),a  
4bce 3a d8 4b			ld a, (.dmark+2)  
4bd1 32 a8 fd			ld (debug_mark+2),a  
4bd4 18 03			jr .pastdmark  
4bd6 ..			.dmark: db "CHR"  
4bd9 f1			.pastdmark: pop af  
4bda			endm  
# End of macro DMARK
4bda						CALLMONITOR 
4bda cd aa fd			call debug_vector  
4bdd				endm  
# End of macro CALLMONITOR
4bdd					endif 
4bdd					FORTH_DSP_VALUEHL 
4bdd cd 28 22			call macro_dsp_valuehl 
4be0				endm 
# End of macro FORTH_DSP_VALUEHL
4be0			 
4be0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4be0 cd e0 22			call macro_forth_dsp_pop 
4be3				endm 
# End of macro FORTH_DSP_POP
4be3			 
4be3					; save asci byte as a zero term string and push string 
4be3			 
4be3 7d					ld a,l 
4be4 32 fc f0				ld (scratch), a 
4be7			 
4be7 3e 00				ld a, 0 
4be9 32 fd f0				ld (scratch+1), a 
4bec			 
4bec 21 fc f0				ld hl, scratch 
4bef cd 91 20				call forth_push_str 
4bf2			 
4bf2			 
4bf2				       NEXTW 
4bf2 c3 de 23			jp macro_next 
4bf5				endm 
# End of macro NEXTW
4bf5			 
4bf5			 
4bf5			 
4bf5			 
4bf5			.ENDSTR: 
4bf5			; eof 
4bf5			 
# End of file forth_words_str.asm
4bf5			include "forth_words_key.asm" 
4bf5			 
4bf5			; | ## Keyboard Words 
4bf5			 
4bf5			.KEY: 
4bf5				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4bf5 3e				db WORD_SYS_CORE+42             
4bf6 25 4c			dw .WAITK            
4bf8 04				db 3 + 1 
4bf9 .. 00			db "KEY",0              
4bfd				endm 
# End of macro CWHEAD
4bfd			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4bfd			 
4bfd					if DEBUG_FORTH_WORDS_KEY 
4bfd						DMARK "KEY" 
4bfd f5				push af  
4bfe 3a 12 4c			ld a, (.dmark)  
4c01 32 a6 fd			ld (debug_mark),a  
4c04 3a 13 4c			ld a, (.dmark+1)  
4c07 32 a7 fd			ld (debug_mark+1),a  
4c0a 3a 14 4c			ld a, (.dmark+2)  
4c0d 32 a8 fd			ld (debug_mark+2),a  
4c10 18 03			jr .pastdmark  
4c12 ..			.dmark: db "KEY"  
4c15 f1			.pastdmark: pop af  
4c16			endm  
# End of macro DMARK
4c16						CALLMONITOR 
4c16 cd aa fd			call debug_vector  
4c19				endm  
# End of macro CALLMONITOR
4c19					endif 
4c19			; TODO currently waits 
4c19 cd af 72				call cin 
4c1c					;call cin_wait 
4c1c 6f					ld l, a 
4c1d 26 00				ld h, 0 
4c1f cd 23 20				call forth_push_numhl 
4c22					NEXTW 
4c22 c3 de 23			jp macro_next 
4c25				endm 
# End of macro NEXTW
4c25			.WAITK: 
4c25				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c25 3f				db WORD_SYS_CORE+43             
4c26 57 4c			dw .ACCEPT            
4c28 06				db 5 + 1 
4c29 .. 00			db "WAITK",0              
4c2f				endm 
# End of macro CWHEAD
4c2f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c2f					if DEBUG_FORTH_WORDS_KEY 
4c2f						DMARK "WAI" 
4c2f f5				push af  
4c30 3a 44 4c			ld a, (.dmark)  
4c33 32 a6 fd			ld (debug_mark),a  
4c36 3a 45 4c			ld a, (.dmark+1)  
4c39 32 a7 fd			ld (debug_mark+1),a  
4c3c 3a 46 4c			ld a, (.dmark+2)  
4c3f 32 a8 fd			ld (debug_mark+2),a  
4c42 18 03			jr .pastdmark  
4c44 ..			.dmark: db "WAI"  
4c47 f1			.pastdmark: pop af  
4c48			endm  
# End of macro DMARK
4c48						CALLMONITOR 
4c48 cd aa fd			call debug_vector  
4c4b				endm  
# End of macro CALLMONITOR
4c4b					endif 
4c4b cd 9e 72				call cin_wait 
4c4e 6f					ld l, a 
4c4f 26 00				ld h, 0 
4c51 cd 23 20				call forth_push_numhl 
4c54					NEXTW 
4c54 c3 de 23			jp macro_next 
4c57				endm 
# End of macro NEXTW
4c57			.ACCEPT: 
4c57				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c57 40				db WORD_SYS_CORE+44             
4c58 b5 4c			dw .EDIT            
4c5a 07				db 6 + 1 
4c5b .. 00			db "ACCEPT",0              
4c62				endm 
# End of macro CWHEAD
4c62			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c62					; TODO crashes on push 
4c62					if DEBUG_FORTH_WORDS_KEY 
4c62						DMARK "ACC" 
4c62 f5				push af  
4c63 3a 77 4c			ld a, (.dmark)  
4c66 32 a6 fd			ld (debug_mark),a  
4c69 3a 78 4c			ld a, (.dmark+1)  
4c6c 32 a7 fd			ld (debug_mark+1),a  
4c6f 3a 79 4c			ld a, (.dmark+2)  
4c72 32 a8 fd			ld (debug_mark+2),a  
4c75 18 03			jr .pastdmark  
4c77 ..			.dmark: db "ACC"  
4c7a f1			.pastdmark: pop af  
4c7b			endm  
# End of macro DMARK
4c7b						CALLMONITOR 
4c7b cd aa fd			call debug_vector  
4c7e				endm  
# End of macro CALLMONITOR
4c7e					endif 
4c7e 21 fa f2				ld hl, os_input 
4c81 3e 00				ld a, 0 
4c83 77					ld (hl),a 
4c84 3a 99 f9				ld a,(f_cursor_ptr) 
4c87 16 64				ld d, 100 
4c89 0e 00				ld c, 0 
4c8b 1e 28				ld e, 40 
4c8d cd fc 0f				call input_str 
4c90					; TODO perhaps do a type check and wrap in quotes if not a number 
4c90 21 fa f2				ld hl, os_input 
4c93					if DEBUG_FORTH_WORDS 
4c93						DMARK "AC1" 
4c93 f5				push af  
4c94 3a a8 4c			ld a, (.dmark)  
4c97 32 a6 fd			ld (debug_mark),a  
4c9a 3a a9 4c			ld a, (.dmark+1)  
4c9d 32 a7 fd			ld (debug_mark+1),a  
4ca0 3a aa 4c			ld a, (.dmark+2)  
4ca3 32 a8 fd			ld (debug_mark+2),a  
4ca6 18 03			jr .pastdmark  
4ca8 ..			.dmark: db "AC1"  
4cab f1			.pastdmark: pop af  
4cac			endm  
# End of macro DMARK
4cac						CALLMONITOR 
4cac cd aa fd			call debug_vector  
4caf				endm  
# End of macro CALLMONITOR
4caf					endif 
4caf cd 91 20				call forth_push_str 
4cb2					NEXTW 
4cb2 c3 de 23			jp macro_next 
4cb5				endm 
# End of macro NEXTW
4cb5			 
4cb5			.EDIT: 
4cb5				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4cb5 40				db WORD_SYS_CORE+44             
4cb6 57 4d			dw .DEDIT            
4cb8 05				db 4 + 1 
4cb9 .. 00			db "EDIT",0              
4cbe				endm 
# End of macro CWHEAD
4cbe			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4cbe			 
4cbe					; TODO does not copy from stack 
4cbe					if DEBUG_FORTH_WORDS_KEY 
4cbe						DMARK "EDT" 
4cbe f5				push af  
4cbf 3a d3 4c			ld a, (.dmark)  
4cc2 32 a6 fd			ld (debug_mark),a  
4cc5 3a d4 4c			ld a, (.dmark+1)  
4cc8 32 a7 fd			ld (debug_mark+1),a  
4ccb 3a d5 4c			ld a, (.dmark+2)  
4cce 32 a8 fd			ld (debug_mark+2),a  
4cd1 18 03			jr .pastdmark  
4cd3 ..			.dmark: db "EDT"  
4cd6 f1			.pastdmark: pop af  
4cd7			endm  
# End of macro DMARK
4cd7						CALLMONITOR 
4cd7 cd aa fd			call debug_vector  
4cda				endm  
# End of macro CALLMONITOR
4cda					endif 
4cda			 
4cda					;FORTH_DSP 
4cda					FORTH_DSP_VALUEHL 
4cda cd 28 22			call macro_dsp_valuehl 
4cdd				endm 
# End of macro FORTH_DSP_VALUEHL
4cdd			;		inc hl    ; TODO do type check 
4cdd			 
4cdd			;		call get_word_hl 
4cdd e5					push hl 
4cde					if DEBUG_FORTH_WORDS 
4cde						DMARK "EDp" 
4cde f5				push af  
4cdf 3a f3 4c			ld a, (.dmark)  
4ce2 32 a6 fd			ld (debug_mark),a  
4ce5 3a f4 4c			ld a, (.dmark+1)  
4ce8 32 a7 fd			ld (debug_mark+1),a  
4ceb 3a f5 4c			ld a, (.dmark+2)  
4cee 32 a8 fd			ld (debug_mark+2),a  
4cf1 18 03			jr .pastdmark  
4cf3 ..			.dmark: db "EDp"  
4cf6 f1			.pastdmark: pop af  
4cf7			endm  
# End of macro DMARK
4cf7						CALLMONITOR 
4cf7 cd aa fd			call debug_vector  
4cfa				endm  
# End of macro CALLMONITOR
4cfa					endif 
4cfa				;	ld a, 0 
4cfa cd 35 13				call strlenz 
4cfd 23					inc hl 
4cfe			 
4cfe 06 00				ld b, 0 
4d00 4d					ld c, l 
4d01			 
4d01 e1					pop hl 
4d02 11 fa f2				ld de, os_input 
4d05					if DEBUG_FORTH_WORDS_KEY 
4d05						DMARK "EDc" 
4d05 f5				push af  
4d06 3a 1a 4d			ld a, (.dmark)  
4d09 32 a6 fd			ld (debug_mark),a  
4d0c 3a 1b 4d			ld a, (.dmark+1)  
4d0f 32 a7 fd			ld (debug_mark+1),a  
4d12 3a 1c 4d			ld a, (.dmark+2)  
4d15 32 a8 fd			ld (debug_mark+2),a  
4d18 18 03			jr .pastdmark  
4d1a ..			.dmark: db "EDc"  
4d1d f1			.pastdmark: pop af  
4d1e			endm  
# End of macro DMARK
4d1e						CALLMONITOR 
4d1e cd aa fd			call debug_vector  
4d21				endm  
# End of macro CALLMONITOR
4d21					endif 
4d21 ed b0				ldir 
4d23			 
4d23			 
4d23 21 fa f2				ld hl, os_input 
4d26					;ld a, 0 
4d26					;ld (hl),a 
4d26 3a 99 f9				ld a,(f_cursor_ptr) 
4d29 16 64				ld d, 100 
4d2b 0e 00				ld c, 0 
4d2d 1e 28				ld e, 40 
4d2f cd fc 0f				call input_str 
4d32					; TODO perhaps do a type check and wrap in quotes if not a number 
4d32 21 fa f2				ld hl, os_input 
4d35					if DEBUG_FORTH_WORDS 
4d35						DMARK "ED1" 
4d35 f5				push af  
4d36 3a 4a 4d			ld a, (.dmark)  
4d39 32 a6 fd			ld (debug_mark),a  
4d3c 3a 4b 4d			ld a, (.dmark+1)  
4d3f 32 a7 fd			ld (debug_mark+1),a  
4d42 3a 4c 4d			ld a, (.dmark+2)  
4d45 32 a8 fd			ld (debug_mark+2),a  
4d48 18 03			jr .pastdmark  
4d4a ..			.dmark: db "ED1"  
4d4d f1			.pastdmark: pop af  
4d4e			endm  
# End of macro DMARK
4d4e						CALLMONITOR 
4d4e cd aa fd			call debug_vector  
4d51				endm  
# End of macro CALLMONITOR
4d51					endif 
4d51 cd 91 20				call forth_push_str 
4d54					NEXTW 
4d54 c3 de 23			jp macro_next 
4d57				endm 
# End of macro NEXTW
4d57			 
4d57			.DEDIT: 
4d57				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d57 40				db WORD_SYS_CORE+44             
4d58 b9 4d			dw .ENDKEY            
4d5a 06				db 5 + 1 
4d5b .. 00			db "DEDIT",0              
4d61				endm 
# End of macro CWHEAD
4d61			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d61			 
4d61					; TODO does not copy from stack 
4d61					if DEBUG_FORTH_WORDS_KEY 
4d61						DMARK "DED" 
4d61 f5				push af  
4d62 3a 76 4d			ld a, (.dmark)  
4d65 32 a6 fd			ld (debug_mark),a  
4d68 3a 77 4d			ld a, (.dmark+1)  
4d6b 32 a7 fd			ld (debug_mark+1),a  
4d6e 3a 78 4d			ld a, (.dmark+2)  
4d71 32 a8 fd			ld (debug_mark+2),a  
4d74 18 03			jr .pastdmark  
4d76 ..			.dmark: db "DED"  
4d79 f1			.pastdmark: pop af  
4d7a			endm  
# End of macro DMARK
4d7a						CALLMONITOR 
4d7a cd aa fd			call debug_vector  
4d7d				endm  
# End of macro CALLMONITOR
4d7d					endif 
4d7d			 
4d7d					;FORTH_DSP 
4d7d					FORTH_DSP_VALUEHL 
4d7d cd 28 22			call macro_dsp_valuehl 
4d80				endm 
# End of macro FORTH_DSP_VALUEHL
4d80			;		inc hl    ; TODO do type check 
4d80			 
4d80			;		call get_word_hl 
4d80 e5					push hl 
4d81 e5					push hl 
4d82					FORTH_DSP_POP 
4d82 cd e0 22			call macro_forth_dsp_pop 
4d85				endm 
# End of macro FORTH_DSP_POP
4d85 e1					pop hl 
4d86					if DEBUG_FORTH_WORDS 
4d86						DMARK "EDp" 
4d86 f5				push af  
4d87 3a 9b 4d			ld a, (.dmark)  
4d8a 32 a6 fd			ld (debug_mark),a  
4d8d 3a 9c 4d			ld a, (.dmark+1)  
4d90 32 a7 fd			ld (debug_mark+1),a  
4d93 3a 9d 4d			ld a, (.dmark+2)  
4d96 32 a8 fd			ld (debug_mark+2),a  
4d99 18 03			jr .pastdmark  
4d9b ..			.dmark: db "EDp"  
4d9e f1			.pastdmark: pop af  
4d9f			endm  
# End of macro DMARK
4d9f						CALLMONITOR 
4d9f cd aa fd			call debug_vector  
4da2				endm  
# End of macro CALLMONITOR
4da2					endif 
4da2				;	ld a, 0 
4da2 cd 35 13				call strlenz 
4da5 23					inc hl 
4da6			 
4da6 06 00				ld b, 0 
4da8 4d					ld c, l 
4da9			 
4da9 e1					pop hl 
4daa			 
4daa					;ld a, 0 
4daa					;ld (hl),a 
4daa 3a 99 f9				ld a,(f_cursor_ptr) 
4dad 16 64				ld d, 100 
4daf 0e 00				ld c, 0 
4db1 1e 28				ld e, 40 
4db3 cd fc 0f				call input_str 
4db6					; TODO perhaps do a type check and wrap in quotes if not a number 
4db6					NEXTW 
4db6 c3 de 23			jp macro_next 
4db9				endm 
# End of macro NEXTW
4db9			 
4db9			 
4db9			.ENDKEY: 
4db9			; eof 
4db9			 
# End of file forth_words_key.asm
4db9			include "forth_words_const.asm" 
4db9			 
4db9			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4db9			 
4db9			 
4db9			.SPITIME: 
4db9				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4db9 77				db WORD_SYS_CORE+99             
4dba ce 4d			dw .VA            
4dbc 08				db 7 + 1 
4dbd .. 00			db "SPITIME",0              
4dc5				endm 
# End of macro CWHEAD
4dc5			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4dc5			; 
4dc5			; | | If using BANK devices then leave as is. 
4dc5			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4dc5			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4dc5			 
4dc5 21 9f f9				ld hl, spi_clktime  
4dc8 cd 23 20				call forth_push_numhl 
4dcb			 
4dcb					NEXTW 
4dcb c3 de 23			jp macro_next 
4dce				endm 
# End of macro NEXTW
4dce			 
4dce			 
4dce			.VA: 
4dce				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4dce 77				db WORD_SYS_CORE+99             
4dcf de 4d			dw .SYMBOL            
4dd1 03				db 2 + 1 
4dd2 .. 00			db "VA",0              
4dd5				endm 
# End of macro CWHEAD
4dd5			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4dd5 21 63 f9				ld hl, cli_var_array 
4dd8 cd 23 20				call forth_push_numhl 
4ddb			 
4ddb					NEXTW 
4ddb c3 de 23			jp macro_next 
4dde				endm 
# End of macro NEXTW
4dde			 
4dde			.SYMBOL: 
4dde				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4dde 77				db WORD_SYS_CORE+99             
4ddf e8 4e			dw .ENDCONST            
4de1 07				db 6 + 1 
4de2 .. 00			db "SYMBOL",0              
4de9				endm 
# End of macro CWHEAD
4de9			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4de9			; | 
4de9			; | | The value is the number reference and the final address is pushed to stack 
4de9			 
4de9			; | | ``` 
4de9			; | | dw sym_table 
4de9			; | | dw nmi_vector 
4de9			; | | dw cli_autodisplay 
4de9			; | | dw cli_data_sp 
4de9			; | | dw cli_data_stack 
4de9			; | | dw cli_loop_sp 
4de9			; | | dw cli_loop_stack 
4de9			; | | dw cli_var_array 
4de9			; | | dw cursor_col 
4de9			; | | dw cursor_ptr 
4de9			; | | ; 10 
4de9			; | | dw cursor_row 
4de9			; | | dw debug_mark 
4de9			; | | dw display_fb0 
4de9			; | | dw display_fb1 
4de9			; | | dw display_fb2 
4de9			; | | dw display_fb3 
4de9			; | | dw display_fb_active 
4de9			; | | dw execscratch 
4de9			; | | dw f_cursor_ptr 
4de9			; | | dw hardware_word 
4de9			; | | ;20 
4de9			; | | dw input_at_cursor 
4de9			; | | dw input_at_pos 
4de9			; | | dw input_cur_flash 
4de9			; | | dw input_cur_onoff 
4de9			; | | dw input_cursor 
4de9			; | | dw input_display_size 
4de9			; | | dw input_len 
4de9			; | | dw input_ptr 
4de9			; | | dw input_size 
4de9			; | | dw input_start 
4de9			; | | ; 30 
4de9			; | | dw input_str 
4de9			; | | dw input_under_cursor 
4de9			; | | dw os_cli_cmd 
4de9			; | | dw os_cur_ptr 
4de9			; | | dw os_current_i 
4de9			; | | dw os_input 
4de9			; | | dw os_last_cmd 
4de9			; | | dw os_last_new_uword 
4de9			; | | dw debug_vector 
4de9			; | | dw os_view_hl 
4de9			; | | ;40 
4de9			; | | dw os_word_scratch 
4de9			; | | dw portbctl 
4de9			; | | dw portbdata 
4de9			; | | dw spi_cartdev 
4de9			; | | dw spi_cartdev2 
4de9			; | | dw spi_clktime 
4de9			; | | dw spi_device 
4de9			; | | dw spi_device_id 
4de9			; | | dw spi_portbyte 
4de9			; | | dw stackstore 
4de9			; | | ; 50 
4de9			; | | if STORAGE_SE 
4de9			; | | dw storage_actl 
4de9			; | | dw storage_adata 
4de9			; | | else 
4de9			; | | dw 0 
4de9			; | | dw 0 
4de9			; | | endif 
4de9			; | | dw storage_append 
4de9			; | | if STORAGE_SE 
4de9			; | | dw storage_bctl 
4de9			; | | else 
4de9			; | | dw 0 
4de9			; | | endif 
4de9			; | | dw store_bank_active 
4de9			; | | dw store_filecache 
4de9			; | | dw store_longread 
4de9			; | | dw store_openaddr 
4de9			; | | dw store_openext 
4de9			; | | dw store_openmaxext 
4de9			; | | ; 60 
4de9			; | | dw store_page 
4de9			; | | dw store_readbuf 
4de9			; | | dw store_readcont 
4de9			; | | dw store_readptr 
4de9			; | | dw store_tmpext 
4de9			; | | dw store_tmpid 
4de9			; | | dw store_tmppageid 
4de9			; | | dw malloc 
4de9			; | | dw free 
4de9			; | | dw cin 
4de9			; | | ; 70 
4de9			; | | dw cin_wait 
4de9			; | | dw forth_push_numhl 
4de9			; | | dw forth_push_str 
4de9			; | | ``` 
4de9			 
4de9					if DEBUG_FORTH_WORDS_KEY 
4de9						DMARK "SYM" 
4de9 f5				push af  
4dea 3a fe 4d			ld a, (.dmark)  
4ded 32 a6 fd			ld (debug_mark),a  
4df0 3a ff 4d			ld a, (.dmark+1)  
4df3 32 a7 fd			ld (debug_mark+1),a  
4df6 3a 00 4e			ld a, (.dmark+2)  
4df9 32 a8 fd			ld (debug_mark+2),a  
4dfc 18 03			jr .pastdmark  
4dfe ..			.dmark: db "SYM"  
4e01 f1			.pastdmark: pop af  
4e02			endm  
# End of macro DMARK
4e02						CALLMONITOR 
4e02 cd aa fd			call debug_vector  
4e05				endm  
# End of macro CALLMONITOR
4e05					endif 
4e05			 
4e05					FORTH_DSP_VALUEHL 
4e05 cd 28 22			call macro_dsp_valuehl 
4e08				endm 
# End of macro FORTH_DSP_VALUEHL
4e08			 
4e08 7d					ld a, l     
4e09			 
4e09			 
4e09					if DEBUG_FORTH_WORDS 
4e09						DMARK "SY1" 
4e09 f5				push af  
4e0a 3a 1e 4e			ld a, (.dmark)  
4e0d 32 a6 fd			ld (debug_mark),a  
4e10 3a 1f 4e			ld a, (.dmark+1)  
4e13 32 a7 fd			ld (debug_mark+1),a  
4e16 3a 20 4e			ld a, (.dmark+2)  
4e19 32 a8 fd			ld (debug_mark+2),a  
4e1c 18 03			jr .pastdmark  
4e1e ..			.dmark: db "SY1"  
4e21 f1			.pastdmark: pop af  
4e22			endm  
# End of macro DMARK
4e22						CALLMONITOR 
4e22 cd aa fd			call debug_vector  
4e25				endm  
# End of macro CALLMONITOR
4e25					endif 
4e25					 
4e25 f5					push af	 
4e26					FORTH_DSP_POP 
4e26 cd e0 22			call macro_forth_dsp_pop 
4e29				endm 
# End of macro FORTH_DSP_POP
4e29 f1					pop af 
4e2a			 
4e2a cb 27				sla a  
4e2c				 
4e2c					 
4e2c					if DEBUG_FORTH_WORDS 
4e2c						DMARK "SY" 
4e2c f5				push af  
4e2d 3a 41 4e			ld a, (.dmark)  
4e30 32 a6 fd			ld (debug_mark),a  
4e33 3a 42 4e			ld a, (.dmark+1)  
4e36 32 a7 fd			ld (debug_mark+1),a  
4e39 3a 43 4e			ld a, (.dmark+2)  
4e3c 32 a8 fd			ld (debug_mark+2),a  
4e3f 18 02			jr .pastdmark  
4e41 ..			.dmark: db "SY"  
4e43 f1			.pastdmark: pop af  
4e44			endm  
# End of macro DMARK
4e44						CALLMONITOR 
4e44 cd aa fd			call debug_vector  
4e47				endm  
# End of macro CALLMONITOR
4e47					endif 
4e47			 
4e47 21 56 4e				ld hl, sym_table 
4e4a cd cf 0f				call addatohl 
4e4d cd 60 23				call loadwordinhl 
4e50 cd 23 20				call forth_push_numhl 
4e53			 
4e53			 
4e53				       NEXTW 
4e53 c3 de 23			jp macro_next 
4e56				endm 
# End of macro NEXTW
4e56			 
4e56			sym_table: 
4e56			 
4e56			; 0 
4e56 56 4e		dw sym_table 
4e58 ad fd		dw nmi_vector 
4e5a 77 f9		dw cli_autodisplay 
4e5c 29 f9		dw cli_data_sp 
4e5e 63 f6		dw cli_data_stack 
4e60 2b f9		dw cli_loop_sp 
4e62 65 f8		dw cli_loop_stack 
4e64 63 f9		dw cli_var_array 
4e66 00 fb		dw cursor_col 
4e68 fe fa		dw cursor_ptr 
4e6a			; 10 
4e6a ff fa		dw cursor_row 
4e6c a6 fd		dw debug_mark 
4e6e ec fc		dw display_fb0 
4e70 4b fc		dw display_fb1 
4e72 09 fb		dw display_fb2 
4e74 aa fb		dw display_fb3 
4e76 07 fb		dw display_fb_active 
4e78 fb f1		dw execscratch 
4e7a 99 f9		dw f_cursor_ptr 
4e7c b0 fd		dw hardware_word 
4e7e			;20 
4e7e 9d fd		dw input_at_cursor 
4e80 9f fd		dw input_at_pos 
4e82 9b fd		dw input_cur_flash 
4e84 9a fd		dw input_cur_onoff 
4e86 90 fd		dw input_cursor 
4e88 a0 fd		dw input_display_size 
4e8a 95 fd		dw input_len 
4e8c a4 fd		dw input_ptr 
4e8e a1 fd		dw input_size 
4e90 a2 fd		dw input_start 
4e92			; 30 
4e92 fc 0f		dw input_str 
4e94 9e fd		dw input_under_cursor 
4e96 23 f4		dw os_cli_cmd 
4e98 1f f4		dw os_cur_ptr 
4e9a 21 f4		dw os_current_i 
4e9c fa f2		dw os_input 
4e9e 22 f5		dw os_last_cmd 
4ea0 f9 f3		dw os_last_new_uword 
4ea2 aa fd		dw debug_vector 
4ea4 de f0		dw os_view_hl 
4ea6			;40 
4ea6 01 f4		dw os_word_scratch 
4ea8 c3 00		dw portbctl 
4eaa c1 00		dw portbdata 
4eac 9e f9		dw spi_cartdev 
4eae 9d f9		dw spi_cartdev2 
4eb0 9f f9		dw spi_clktime 
4eb2 9b f9		dw spi_device 
4eb4 9a f9		dw spi_device_id 
4eb6 9c f9		dw spi_portbyte 
4eb8 e2 fa		dw stackstore 
4eba			; 50 
4eba			if STORAGE_SE 
4eba 82 00		dw storage_actl 
4ebc 80 00		dw storage_adata 
4ebe			else 
4ebe			dw 0 
4ebe			dw 0 
4ebe			endif 
4ebe 55 0b		dw storage_append 
4ec0			if STORAGE_SE 
4ec0 83 00		dw storage_bctl 
4ec2			else 
4ec2			dw 0 
4ec2			endif 
4ec2 ce fa		dw store_bank_active 
4ec4 a2 f9		dw store_filecache 
4ec6 b0 f9		dw store_longread 
4ec8 a6 f9		dw store_openaddr 
4eca a5 f9		dw store_openext 
4ecc a4 f9		dw store_openmaxext 
4ece			; 60 
4ece b5 f9		dw store_page 
4ed0 b1 f9		dw store_readbuf 
4ed2 a8 f9		dw store_readcont 
4ed4 b3 f9		dw store_readptr 
4ed6 a8 f9		dw store_tmpext 
4ed8 a9 f9		dw store_tmpid 
4eda a0 f9		dw store_tmppageid 
4edc aa 13		dw malloc 
4ede 74 14		dw free 
4ee0 af 72		dw cin 
4ee2			; 70 
4ee2 9e 72		dw cin_wait 
4ee4 23 20		dw forth_push_numhl 
4ee6 91 20		dw forth_push_str 
4ee8			 
4ee8			 
4ee8			.ENDCONST: 
4ee8			 
4ee8			; eof 
4ee8			 
4ee8			 
# End of file forth_words_const.asm
4ee8			 
4ee8			if STORAGE_SE 
4ee8			   	include "forth_words_storage.asm" 
4ee8			 
4ee8			; | ## Fixed Storage Words 
4ee8			 
4ee8			.RENAME: 
4ee8			  
4ee8				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4ee8 3a				db WORD_SYS_CORE+38             
4ee9 de 4f			dw .RECORD            
4eeb 07				db 6 + 1 
4eec .. 00			db "RENAME",0              
4ef3				endm 
# End of macro CWHEAD
4ef3			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4ef3			; | | > [!NOTE] 
4ef3			; | | > Compatible with PicoSPINet  
4ef3					if DEBUG_FORTH_WORDS_KEY 
4ef3						DMARK "REN" 
4ef3 f5				push af  
4ef4 3a 08 4f			ld a, (.dmark)  
4ef7 32 a6 fd			ld (debug_mark),a  
4efa 3a 09 4f			ld a, (.dmark+1)  
4efd 32 a7 fd			ld (debug_mark+1),a  
4f00 3a 0a 4f			ld a, (.dmark+2)  
4f03 32 a8 fd			ld (debug_mark+2),a  
4f06 18 03			jr .pastdmark  
4f08 ..			.dmark: db "REN"  
4f0b f1			.pastdmark: pop af  
4f0c			endm  
# End of macro DMARK
4f0c						CALLMONITOR 
4f0c cd aa fd			call debug_vector  
4f0f				endm  
# End of macro CALLMONITOR
4f0f					endif 
4f0f			 
4f0f			 
4f0f					; preserve some internal vars used by other file handing routines 
4f0f			 
4f0f 2a a6 f9				ld hl, (store_openaddr) 
4f12 e5					push hl 
4f13 3a a8 f9				ld a, (store_readcont) 
4f16 f5					push af 
4f17			 
4f17					FORTH_DSP_VALUEHL 
4f17 cd 28 22			call macro_dsp_valuehl 
4f1a				endm 
# End of macro FORTH_DSP_VALUEHL
4f1a			 
4f1a					; move ext and id around for the file header 
4f1a			 
4f1a 65					ld h, l 
4f1b 2e 00				ld l, 0 
4f1d			 
4f1d e5					push hl    ; id 
4f1e			 
4f1e					FORTH_DSP_POP 
4f1e cd e0 22			call macro_forth_dsp_pop 
4f21				endm 
# End of macro FORTH_DSP_POP
4f21			 
4f21					; Locate the file header 
4f21			 
4f21 e1					pop hl 
4f22 e5					push hl 
4f23 11 b5 f9				ld de, store_page      ; get block zero of file 
4f26					if DEBUG_FORTH_WORDS 
4f26						DMARK "REr" 
4f26 f5				push af  
4f27 3a 3b 4f			ld a, (.dmark)  
4f2a 32 a6 fd			ld (debug_mark),a  
4f2d 3a 3c 4f			ld a, (.dmark+1)  
4f30 32 a7 fd			ld (debug_mark+1),a  
4f33 3a 3d 4f			ld a, (.dmark+2)  
4f36 32 a8 fd			ld (debug_mark+2),a  
4f39 18 03			jr .pastdmark  
4f3b ..			.dmark: db "REr"  
4f3e f1			.pastdmark: pop af  
4f3f			endm  
# End of macro DMARK
4f3f						CALLMONITOR 
4f3f cd aa fd			call debug_vector  
4f42				endm  
# End of macro CALLMONITOR
4f42					endif 
4f42 cd be 09				call storage_read 
4f45			 
4f45 cd f8 0f			call ishlzero 
4f48 20 05			jr nz, .rnfound 
4f4a			 
4f4a				; file does not exist so indicate with 255 extents in use 
4f4a			 
4f4a 3e ff			ld a, 255 
4f4c e1				pop hl ; clear dup hl 
4f4d 18 7b			jr .skiprneof 
4f4f			 
4f4f			 
4f4f			.rnfound: 
4f4f					; file found so rename 
4f4f			 
4f4f					FORTH_DSP_VALUEHL 
4f4f cd 28 22			call macro_dsp_valuehl 
4f52				endm 
# End of macro FORTH_DSP_VALUEHL
4f52			 
4f52 e5				push hl 
4f53 3e 00			ld a, 0 
4f55 cd 40 13			call strlent 
4f58 23				inc hl   ; cover zero term 
4f59 06 00			ld b,0 
4f5b 4d				ld c,l 
4f5c e1				pop hl 
4f5d 11 b8 f9				ld de, store_page + 3 
4f60 ed b0				ldir 
4f62			 
4f62 11 b5 f9				ld de, store_page 
4f65					if DEBUG_FORTH_WORDS 
4f65						DMARK "RER" 
4f65 f5				push af  
4f66 3a 7a 4f			ld a, (.dmark)  
4f69 32 a6 fd			ld (debug_mark),a  
4f6c 3a 7b 4f			ld a, (.dmark+1)  
4f6f 32 a7 fd			ld (debug_mark+1),a  
4f72 3a 7c 4f			ld a, (.dmark+2)  
4f75 32 a8 fd			ld (debug_mark+2),a  
4f78 18 03			jr .pastdmark  
4f7a ..			.dmark: db "RER"  
4f7d f1			.pastdmark: pop af  
4f7e			endm  
# End of macro DMARK
4f7e						CALLMONITOR 
4f7e cd aa fd			call debug_vector  
4f81				endm  
# End of macro CALLMONITOR
4f81					endif 
4f81			 
4f81 e1					pop hl    ; get orig file id and mangle it for find id 
4f82 55					ld d, l 
4f83 5c					ld e, h 
4f84			 
4f84 21 00 00				ld hl, 0 
4f87					if DEBUG_FORTH_WORDS 
4f87						DMARK "REf" 
4f87 f5				push af  
4f88 3a 9c 4f			ld a, (.dmark)  
4f8b 32 a6 fd			ld (debug_mark),a  
4f8e 3a 9d 4f			ld a, (.dmark+1)  
4f91 32 a7 fd			ld (debug_mark+1),a  
4f94 3a 9e 4f			ld a, (.dmark+2)  
4f97 32 a8 fd			ld (debug_mark+2),a  
4f9a 18 03			jr .pastdmark  
4f9c ..			.dmark: db "REf"  
4f9f f1			.pastdmark: pop af  
4fa0			endm  
# End of macro DMARK
4fa0						CALLMONITOR 
4fa0 cd aa fd			call debug_vector  
4fa3				endm  
# End of macro CALLMONITOR
4fa3					endif 
4fa3 cd 98 07				call storage_findnextid 
4fa6 11 b5 f9				ld de, store_page 
4fa9					if DEBUG_FORTH_WORDS 
4fa9						DMARK "REw" 
4fa9 f5				push af  
4faa 3a be 4f			ld a, (.dmark)  
4fad 32 a6 fd			ld (debug_mark),a  
4fb0 3a bf 4f			ld a, (.dmark+1)  
4fb3 32 a7 fd			ld (debug_mark+1),a  
4fb6 3a c0 4f			ld a, (.dmark+2)  
4fb9 32 a8 fd			ld (debug_mark+2),a  
4fbc 18 03			jr .pastdmark  
4fbe ..			.dmark: db "REw"  
4fc1 f1			.pastdmark: pop af  
4fc2			endm  
# End of macro DMARK
4fc2						CALLMONITOR 
4fc2 cd aa fd			call debug_vector  
4fc5				endm  
# End of macro CALLMONITOR
4fc5					endif 
4fc5 cd ca 04				call storage_write_block 
4fc8			 
4fc8 3e 00				ld a, 0 
4fca			.skiprneof: 
4fca					; drop file name 
4fca					FORTH_DSP_POP 
4fca cd e0 22			call macro_forth_dsp_pop 
4fcd				endm 
# End of macro FORTH_DSP_POP
4fcd			 
4fcd 6f					ld l, a 
4fce 26 00				ld h, 0 
4fd0 cd 23 20				call forth_push_numhl 
4fd3			 
4fd3			 
4fd3 f1					pop af 
4fd4 32 a8 f9				ld (store_readcont),a 
4fd7 e1					pop hl 
4fd8 22 a6 f9				ld (store_openaddr), hl 
4fdb						 
4fdb				NEXTW 
4fdb c3 de 23			jp macro_next 
4fde				endm 
# End of macro NEXTW
4fde			.RECORD: 
4fde			  
4fde				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4fde 3a				db WORD_SYS_CORE+38             
4fdf 82 50			dw .BREAD            
4fe1 07				db 6 + 1 
4fe2 .. 00			db "RECORD",0              
4fe9				endm 
# End of macro CWHEAD
4fe9			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4fe9			; | | > [!NOTE] 
4fe9			; | | > Compatible with PicoSPINet  
4fe9			 
4fe9					if DEBUG_FORTH_WORDS_KEY 
4fe9						DMARK "REC" 
4fe9 f5				push af  
4fea 3a fe 4f			ld a, (.dmark)  
4fed 32 a6 fd			ld (debug_mark),a  
4ff0 3a ff 4f			ld a, (.dmark+1)  
4ff3 32 a7 fd			ld (debug_mark+1),a  
4ff6 3a 00 50			ld a, (.dmark+2)  
4ff9 32 a8 fd			ld (debug_mark+2),a  
4ffc 18 03			jr .pastdmark  
4ffe ..			.dmark: db "REC"  
5001 f1			.pastdmark: pop af  
5002			endm  
# End of macro DMARK
5002						CALLMONITOR 
5002 cd aa fd			call debug_vector  
5005				endm  
# End of macro CALLMONITOR
5005					endif 
5005			 
5005					FORTH_DSP_VALUEHL 
5005 cd 28 22			call macro_dsp_valuehl 
5008				endm 
# End of macro FORTH_DSP_VALUEHL
5008			 
5008 e5					push hl    ; id 
5009			 
5009					FORTH_DSP_POP 
5009 cd e0 22			call macro_forth_dsp_pop 
500c				endm 
# End of macro FORTH_DSP_POP
500c			 
500c					FORTH_DSP_VALUEHL 
500c cd 28 22			call macro_dsp_valuehl 
500f				endm 
# End of macro FORTH_DSP_VALUEHL
500f			 
500f					FORTH_DSP_POP 
500f cd e0 22			call macro_forth_dsp_pop 
5012				endm 
# End of macro FORTH_DSP_POP
5012			 
5012 d1					pop de     ; get file id 
5013			 
5013					; e = file id 
5013					; l = file extent 
5013			 
5013			 
5013					; construct request to access file extent 
5013			 
5013			;		ld a, e 
5013 63					ld h, e 
5014					 
5014					 
5014					 
5014			 
5014					; e has id 
5014			 
5014 11 b5 f9			ld de, store_page 
5017					if DEBUG_FORTH_WORDS 
5017						DMARK "REr" 
5017 f5				push af  
5018 3a 2c 50			ld a, (.dmark)  
501b 32 a6 fd			ld (debug_mark),a  
501e 3a 2d 50			ld a, (.dmark+1)  
5021 32 a7 fd			ld (debug_mark+1),a  
5024 3a 2e 50			ld a, (.dmark+2)  
5027 32 a8 fd			ld (debug_mark+2),a  
502a 18 03			jr .pastdmark  
502c ..			.dmark: db "REr"  
502f f1			.pastdmark: pop af  
5030			endm  
# End of macro DMARK
5030						CALLMONITOR 
5030 cd aa fd			call debug_vector  
5033				endm  
# End of macro CALLMONITOR
5033					endif 
5033 cd be 09				call storage_read 
5036 cd f8 0f			call ishlzero 
5039 28 22			jr z, .recnotfound 
503b			 
503b			 
503b					if DEBUG_FORTH_WORDS 
503b						DMARK "REe" 
503b f5				push af  
503c 3a 50 50			ld a, (.dmark)  
503f 32 a6 fd			ld (debug_mark),a  
5042 3a 51 50			ld a, (.dmark+1)  
5045 32 a7 fd			ld (debug_mark+1),a  
5048 3a 52 50			ld a, (.dmark+2)  
504b 32 a8 fd			ld (debug_mark+2),a  
504e 18 03			jr .pastdmark  
5050 ..			.dmark: db "REe"  
5053 f1			.pastdmark: pop af  
5054			endm  
# End of macro DMARK
5054						CALLMONITOR 
5054 cd aa fd			call debug_vector  
5057				endm  
# End of macro CALLMONITOR
5057					endif 
5057 cd 91 20			call forth_push_str 
505a			 
505a					NEXTW 
505a c3 de 23			jp macro_next 
505d				endm 
# End of macro NEXTW
505d			 
505d			.recnotfound: 
505d					if DEBUG_FORTH_WORDS 
505d						DMARK "REf" 
505d f5				push af  
505e 3a 72 50			ld a, (.dmark)  
5061 32 a6 fd			ld (debug_mark),a  
5064 3a 73 50			ld a, (.dmark+1)  
5067 32 a7 fd			ld (debug_mark+1),a  
506a 3a 74 50			ld a, (.dmark+2)  
506d 32 a8 fd			ld (debug_mark+2),a  
5070 18 03			jr .pastdmark  
5072 ..			.dmark: db "REf"  
5075 f1			.pastdmark: pop af  
5076			endm  
# End of macro DMARK
5076						CALLMONITOR 
5076 cd aa fd			call debug_vector  
5079				endm  
# End of macro CALLMONITOR
5079					endif 
5079 21 ff 00			ld hl, 255 
507c cd 23 20			call forth_push_numhl 
507f				NEXTW 
507f c3 de 23			jp macro_next 
5082				endm 
# End of macro NEXTW
5082			 
5082			 
5082			.BREAD: 
5082			  
5082				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5082 3a				db WORD_SYS_CORE+38             
5083 05 51			dw .BWRITE            
5085 06				db 5 + 1 
5086 .. 00			db "BREAD",0              
508c				endm 
# End of macro CWHEAD
508c			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
508c			; | | > [!NOTE] 
508c			; | | > Compatible with PicoSPINet  
508c				 
508c					if DEBUG_FORTH_WORDS_KEY 
508c						DMARK "BRD" 
508c f5				push af  
508d 3a a1 50			ld a, (.dmark)  
5090 32 a6 fd			ld (debug_mark),a  
5093 3a a2 50			ld a, (.dmark+1)  
5096 32 a7 fd			ld (debug_mark+1),a  
5099 3a a3 50			ld a, (.dmark+2)  
509c 32 a8 fd			ld (debug_mark+2),a  
509f 18 03			jr .pastdmark  
50a1 ..			.dmark: db "BRD"  
50a4 f1			.pastdmark: pop af  
50a5			endm  
# End of macro DMARK
50a5						CALLMONITOR 
50a5 cd aa fd			call debug_vector  
50a8				endm  
# End of macro CALLMONITOR
50a8					endif 
50a8			 
50a8				FORTH_DSP_VALUEHL 
50a8 cd 28 22			call macro_dsp_valuehl 
50ab				endm 
# End of macro FORTH_DSP_VALUEHL
50ab			 
50ab				FORTH_DSP_POP 
50ab cd e0 22			call macro_forth_dsp_pop 
50ae				endm 
# End of macro FORTH_DSP_POP
50ae			 
50ae				; calc block address 
50ae			 
50ae eb				ex de, hl 
50af 3e 40			ld a, STORE_BLOCK_PHY 
50b1 cd 52 0f			call Mult16 
50b4			 
50b4			 
50b4 11 b5 f9			ld de, store_page 
50b7			 
50b7					if DEBUG_FORTH_WORDS 
50b7						DMARK "BR1" 
50b7 f5				push af  
50b8 3a cc 50			ld a, (.dmark)  
50bb 32 a6 fd			ld (debug_mark),a  
50be 3a cd 50			ld a, (.dmark+1)  
50c1 32 a7 fd			ld (debug_mark+1),a  
50c4 3a ce 50			ld a, (.dmark+2)  
50c7 32 a8 fd			ld (debug_mark+2),a  
50ca 18 03			jr .pastdmark  
50cc ..			.dmark: db "BR1"  
50cf f1			.pastdmark: pop af  
50d0			endm  
# End of macro DMARK
50d0						CALLMONITOR 
50d0 cd aa fd			call debug_vector  
50d3				endm  
# End of macro CALLMONITOR
50d3					endif 
50d3			 
50d3 cd 65 04			call storage_read_block 
50d6			 
50d6 cd f8 0f			call ishlzero 
50d9 20 05			jr nz, .brfound 
50db			 
50db cd 23 20			call forth_push_numhl 
50de 18 22			jr .brdone 
50e0			 
50e0			 
50e0			.brfound: 
50e0 21 b7 f9		        ld hl, store_page+2 
50e3			 
50e3					if DEBUG_FORTH_WORDS 
50e3						DMARK "BR2" 
50e3 f5				push af  
50e4 3a f8 50			ld a, (.dmark)  
50e7 32 a6 fd			ld (debug_mark),a  
50ea 3a f9 50			ld a, (.dmark+1)  
50ed 32 a7 fd			ld (debug_mark+1),a  
50f0 3a fa 50			ld a, (.dmark+2)  
50f3 32 a8 fd			ld (debug_mark+2),a  
50f6 18 03			jr .pastdmark  
50f8 ..			.dmark: db "BR2"  
50fb f1			.pastdmark: pop af  
50fc			endm  
# End of macro DMARK
50fc						CALLMONITOR 
50fc cd aa fd			call debug_vector  
50ff				endm  
# End of macro CALLMONITOR
50ff					endif 
50ff			 
50ff cd 91 20			call forth_push_str 
5102			 
5102			 
5102			.brdone: 
5102			 
5102					NEXTW 
5102 c3 de 23			jp macro_next 
5105				endm 
# End of macro NEXTW
5105			.BWRITE: 
5105				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5105 3a				db WORD_SYS_CORE+38             
5106 9a 51			dw .BUPD            
5108 07				db 6 + 1 
5109 .. 00			db "BWRITE",0              
5110				endm 
# End of macro CWHEAD
5110			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5110			; | | > [!NOTE] 
5110			; | | > Compatible with PicoSPINet  
5110			 
5110					if DEBUG_FORTH_WORDS_KEY 
5110						DMARK "BWR" 
5110 f5				push af  
5111 3a 25 51			ld a, (.dmark)  
5114 32 a6 fd			ld (debug_mark),a  
5117 3a 26 51			ld a, (.dmark+1)  
511a 32 a7 fd			ld (debug_mark+1),a  
511d 3a 27 51			ld a, (.dmark+2)  
5120 32 a8 fd			ld (debug_mark+2),a  
5123 18 03			jr .pastdmark  
5125 ..			.dmark: db "BWR"  
5128 f1			.pastdmark: pop af  
5129			endm  
# End of macro DMARK
5129						CALLMONITOR 
5129 cd aa fd			call debug_vector  
512c				endm  
# End of macro CALLMONITOR
512c					endif 
512c			 
512c				FORTH_DSP_VALUEHL 
512c cd 28 22			call macro_dsp_valuehl 
512f				endm 
# End of macro FORTH_DSP_VALUEHL
512f			 
512f				; calc block address 
512f			 
512f eb				ex de, hl 
5130 3e 40			ld a, STORE_BLOCK_PHY 
5132 cd 52 0f			call Mult16 
5135			 
5135 e5				push hl         ; address 
5136			 
5136				FORTH_DSP_POP 
5136 cd e0 22			call macro_forth_dsp_pop 
5139				endm 
# End of macro FORTH_DSP_POP
5139			 
5139				FORTH_DSP_VALUEHL 
5139 cd 28 22			call macro_dsp_valuehl 
513c				endm 
# End of macro FORTH_DSP_VALUEHL
513c			 
513c				FORTH_DSP_POP 
513c cd e0 22			call macro_forth_dsp_pop 
513f				endm 
# End of macro FORTH_DSP_POP
513f			 
513f cd a1 0c			call storage_clear_page 
5142			 
5142				; copy string to store page 
5142			 
5142 e5				push hl     ; save string address 
5143			 
5143 3e 00			ld a, 0 
5145 cd 40 13			call strlent 
5148			 
5148 23				inc hl 
5149			 
5149 4d				ld c, l 
514a 06 00			ld b, 0 
514c			 
514c e1				pop hl 
514d 11 b7 f9			ld de, store_page + 2 
5150					if DEBUG_FORTH_WORDS 
5150						DMARK "BW1" 
5150 f5				push af  
5151 3a 65 51			ld a, (.dmark)  
5154 32 a6 fd			ld (debug_mark),a  
5157 3a 66 51			ld a, (.dmark+1)  
515a 32 a7 fd			ld (debug_mark+1),a  
515d 3a 67 51			ld a, (.dmark+2)  
5160 32 a8 fd			ld (debug_mark+2),a  
5163 18 03			jr .pastdmark  
5165 ..			.dmark: db "BW1"  
5168 f1			.pastdmark: pop af  
5169			endm  
# End of macro DMARK
5169						CALLMONITOR 
5169 cd aa fd			call debug_vector  
516c				endm  
# End of macro CALLMONITOR
516c					endif 
516c ed b0			ldir 
516e			 
516e			 
516e				; poke the start of the block with flags to prevent high level file ops hitting the block 
516e			 
516e 21 ff ff			ld hl, $ffff 
5171			 
5171 22 b5 f9			ld (store_page), hl	 
5174				 
5174 e1				pop hl    ; get address 
5175 11 b5 f9			ld de, store_page 
5178			 
5178					if DEBUG_FORTH_WORDS 
5178						DMARK "BW2" 
5178 f5				push af  
5179 3a 8d 51			ld a, (.dmark)  
517c 32 a6 fd			ld (debug_mark),a  
517f 3a 8e 51			ld a, (.dmark+1)  
5182 32 a7 fd			ld (debug_mark+1),a  
5185 3a 8f 51			ld a, (.dmark+2)  
5188 32 a8 fd			ld (debug_mark+2),a  
518b 18 03			jr .pastdmark  
518d ..			.dmark: db "BW2"  
5190 f1			.pastdmark: pop af  
5191			endm  
# End of macro DMARK
5191						CALLMONITOR 
5191 cd aa fd			call debug_vector  
5194				endm  
# End of macro CALLMONITOR
5194					endif 
5194			 
5194 cd ca 04			call storage_write_block 
5197			 
5197					NEXTW 
5197 c3 de 23			jp macro_next 
519a				endm 
# End of macro NEXTW
519a			 
519a			.BUPD: 
519a				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
519a 3a				db WORD_SYS_CORE+38             
519b f0 51			dw .BYID            
519d 05				db 4 + 1 
519e .. 00			db "BUPD",0              
51a3				endm 
# End of macro CWHEAD
51a3			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51a3			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51a3			; | | or completely different file system structure. 
51a3			; | | > [!NOTE] 
51a3			; | | > Compatible with PicoSPINet  
51a3			 
51a3					if DEBUG_FORTH_WORDS_KEY 
51a3						DMARK "BUD" 
51a3 f5				push af  
51a4 3a b8 51			ld a, (.dmark)  
51a7 32 a6 fd			ld (debug_mark),a  
51aa 3a b9 51			ld a, (.dmark+1)  
51ad 32 a7 fd			ld (debug_mark+1),a  
51b0 3a ba 51			ld a, (.dmark+2)  
51b3 32 a8 fd			ld (debug_mark+2),a  
51b6 18 03			jr .pastdmark  
51b8 ..			.dmark: db "BUD"  
51bb f1			.pastdmark: pop af  
51bc			endm  
# End of macro DMARK
51bc						CALLMONITOR 
51bc cd aa fd			call debug_vector  
51bf				endm  
# End of macro CALLMONITOR
51bf					endif 
51bf			 
51bf				FORTH_DSP_VALUEHL 
51bf cd 28 22			call macro_dsp_valuehl 
51c2				endm 
# End of macro FORTH_DSP_VALUEHL
51c2			 
51c2				; calc block address 
51c2			 
51c2 eb				ex de, hl 
51c3 3e 40			ld a, STORE_BLOCK_PHY 
51c5 cd 52 0f			call Mult16 
51c8			 
51c8				FORTH_DSP_POP 
51c8 cd e0 22			call macro_forth_dsp_pop 
51cb				endm 
# End of macro FORTH_DSP_POP
51cb			 
51cb			 
51cb 11 b5 f9			ld de, store_page 
51ce			 
51ce					if DEBUG_FORTH_WORDS 
51ce						DMARK "BUe" 
51ce f5				push af  
51cf 3a e3 51			ld a, (.dmark)  
51d2 32 a6 fd			ld (debug_mark),a  
51d5 3a e4 51			ld a, (.dmark+1)  
51d8 32 a7 fd			ld (debug_mark+1),a  
51db 3a e5 51			ld a, (.dmark+2)  
51de 32 a8 fd			ld (debug_mark+2),a  
51e1 18 03			jr .pastdmark  
51e3 ..			.dmark: db "BUe"  
51e6 f1			.pastdmark: pop af  
51e7			endm  
# End of macro DMARK
51e7						CALLMONITOR 
51e7 cd aa fd			call debug_vector  
51ea				endm  
# End of macro CALLMONITOR
51ea					endif 
51ea			 
51ea cd ca 04			call storage_write_block 
51ed			 
51ed					NEXTW 
51ed c3 de 23			jp macro_next 
51f0				endm 
# End of macro NEXTW
51f0			 
51f0			.BYID: 
51f0			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51f0			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51f0			; 
51f0			;		 
51f0			;		if DEBUG_FORTH_WORDS_KEY 
51f0			;			DMARK "BYID" 
51f0			;			CALLMONITOR 
51f0			;		endif 
51f0			; 
51f0			;		; get direct address 
51f0			; 
51f0			;		FORTH_DSP_VALUEHL 
51f0			; 
51f0			;		FORTH_DSP_POP 
51f0			; 
51f0			;	; calc block address 
51f0			; 
51f0			;	ex de, hl 
51f0			;	ld a, STORE_BLOCK_PHY 
51f0			;	call Mult16 
51f0			;	;	do BREAD with number as param 
51f0			;	; push the file name	 
51f0			;	ld de, store_page 
51f0			;	call storage_read_block 
51f0			 ;       ld hl, store_page+2 
51f0			; 
51f0			; 
51f0			;		NEXTW 
51f0			;.BYNAME: 
51f0				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51f0 3a				db WORD_SYS_CORE+38             
51f1 09 52			dw .DIR            
51f3 06				db 5 + 1 
51f4 .. 00			db "GETID",0              
51fa				endm 
# End of macro CWHEAD
51fa			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
51fa			; | | > [!NOTE] 
51fa			; | | > Compatible with PicoSPINet  
51fa			 
51fa					; get pointer to file name to seek 
51fa			 
51fa					FORTH_DSP_VALUEHL 
51fa cd 28 22			call macro_dsp_valuehl 
51fd				endm 
# End of macro FORTH_DSP_VALUEHL
51fd			 
51fd			 
51fd cd 8c 03				call storage_getid  
5200			 
5200					FORTH_DSP_POP 
5200 cd e0 22			call macro_forth_dsp_pop 
5203				endm 
# End of macro FORTH_DSP_POP
5203			 
5203 cd 23 20				call forth_push_numhl 
5206			 
5206					NEXTW 
5206 c3 de 23			jp macro_next 
5209				endm 
# End of macro NEXTW
5209			; 
5209			.DIR: 
5209				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5209 3a				db WORD_SYS_CORE+38             
520a 0d 53			dw .SAVE            
520c 04				db 3 + 1 
520d .. 00			db "DIR",0              
5211				endm 
# End of macro CWHEAD
5211			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5211			; | | > [!NOTE] 
5211			; | | > Compatible with PicoSPINet  
5211			 
5211					if DEBUG_FORTH_WORDS_KEY 
5211						DMARK "DIR" 
5211 f5				push af  
5212 3a 26 52			ld a, (.dmark)  
5215 32 a6 fd			ld (debug_mark),a  
5218 3a 27 52			ld a, (.dmark+1)  
521b 32 a7 fd			ld (debug_mark+1),a  
521e 3a 28 52			ld a, (.dmark+2)  
5221 32 a8 fd			ld (debug_mark+2),a  
5224 18 03			jr .pastdmark  
5226 ..			.dmark: db "DIR"  
5229 f1			.pastdmark: pop af  
522a			endm  
# End of macro DMARK
522a						CALLMONITOR 
522a cd aa fd			call debug_vector  
522d				endm  
# End of macro CALLMONITOR
522d					endif 
522d cd 16 05			call storage_get_block_0 
5230			 
5230 21 b5 f9			ld hl, store_page     ; get current id count 
5233 46				ld b, (hl) 
5234 0e 00			ld c, 0    ; count of files   
5236					if DEBUG_FORTH_WORDS 
5236						DMARK "DI1" 
5236 f5				push af  
5237 3a 4b 52			ld a, (.dmark)  
523a 32 a6 fd			ld (debug_mark),a  
523d 3a 4c 52			ld a, (.dmark+1)  
5240 32 a7 fd			ld (debug_mark+1),a  
5243 3a 4d 52			ld a, (.dmark+2)  
5246 32 a8 fd			ld (debug_mark+2),a  
5249 18 03			jr .pastdmark  
524b ..			.dmark: db "DI1"  
524e f1			.pastdmark: pop af  
524f			endm  
# End of macro DMARK
524f						CALLMONITOR 
524f cd aa fd			call debug_vector  
5252				endm  
# End of macro CALLMONITOR
5252					endif 
5252			 
5252				; check for empty drive 
5252			 
5252 3e 00			ld a, 0 
5254 b8				cp b 
5255 ca c3 52			jp z, .dirdone 
5258			 
5258				; for each of the current ids do a search for them and if found push to stack 
5258			 
5258 c5			.diritem:	push bc 
5259 21 40 00				ld hl, STORE_BLOCK_PHY 
525c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
525e 58					ld e,b 
525f			 
525f			;		if DEBUG_FORTH_WORDS 
525f			;			DMARK "DI2" 
525f			;			CALLMONITOR 
525f			;		endif 
525f			 
525f cd 98 07				call storage_findnextid 
5262			 
5262			;		if DEBUG_FORTH_WORDS 
5262			;			DMARK "DI3" 
5262			;			CALLMONITOR 
5262			;		endif 
5262			 
5262					; if found hl will be non zero 
5262			 
5262 cd f8 0f				call ishlzero 
5265			;		ld a, l 
5265			;		add h 
5265			; 
5265			;		cp 0 
5265 28 59				jr z, .dirnotfound 
5267			 
5267					; increase count 
5267			 
5267 c1					pop bc	 
5268 0c					inc c 
5269 c5					push bc 
526a					 
526a			 
526a					; get file header and push the file name 
526a			 
526a 11 b5 f9				ld de, store_page 
526d cd 65 04				call storage_read_block 
5270			 
5270					; push file id to stack 
5270				 
5270 3a b5 f9				ld a, (store_page) 
5273 26 00				ld h, 0 
5275 6f					ld l, a 
5276 cd 23 20				call forth_push_numhl 
5279			 
5279					; push extent count to stack  
5279				 
5279 3a b7 f9				ld a, (store_page+2) 
527c 26 00				ld h, 0 
527e 6f					ld l, a 
527f cd 23 20				call forth_push_numhl 
5282			 
5282					; push file name 
5282			 
5282 21 b8 f9				ld hl, store_page+3 
5285					if DEBUG_FORTH_WORDS 
5285						DMARK "DI5" 
5285 f5				push af  
5286 3a 9a 52			ld a, (.dmark)  
5289 32 a6 fd			ld (debug_mark),a  
528c 3a 9b 52			ld a, (.dmark+1)  
528f 32 a7 fd			ld (debug_mark+1),a  
5292 3a 9c 52			ld a, (.dmark+2)  
5295 32 a8 fd			ld (debug_mark+2),a  
5298 18 03			jr .pastdmark  
529a ..			.dmark: db "DI5"  
529d f1			.pastdmark: pop af  
529e			endm  
# End of macro DMARK
529e						CALLMONITOR 
529e cd aa fd			call debug_vector  
52a1				endm  
# End of macro CALLMONITOR
52a1					endif 
52a1 cd 91 20				call forth_push_str 
52a4					if DEBUG_FORTH_WORDS 
52a4						DMARK "DI6" 
52a4 f5				push af  
52a5 3a b9 52			ld a, (.dmark)  
52a8 32 a6 fd			ld (debug_mark),a  
52ab 3a ba 52			ld a, (.dmark+1)  
52ae 32 a7 fd			ld (debug_mark+1),a  
52b1 3a bb 52			ld a, (.dmark+2)  
52b4 32 a8 fd			ld (debug_mark+2),a  
52b7 18 03			jr .pastdmark  
52b9 ..			.dmark: db "DI6"  
52bc f1			.pastdmark: pop af  
52bd			endm  
# End of macro DMARK
52bd						CALLMONITOR 
52bd cd aa fd			call debug_vector  
52c0				endm  
# End of macro CALLMONITOR
52c0					endif 
52c0			.dirnotfound: 
52c0 c1					pop bc     
52c1 10 95				djnz .diritem 
52c3				 
52c3			.dirdone:	 
52c3					if DEBUG_FORTH_WORDS 
52c3						DMARK "DI7" 
52c3 f5				push af  
52c4 3a d8 52			ld a, (.dmark)  
52c7 32 a6 fd			ld (debug_mark),a  
52ca 3a d9 52			ld a, (.dmark+1)  
52cd 32 a7 fd			ld (debug_mark+1),a  
52d0 3a da 52			ld a, (.dmark+2)  
52d3 32 a8 fd			ld (debug_mark+2),a  
52d6 18 03			jr .pastdmark  
52d8 ..			.dmark: db "DI7"  
52db f1			.pastdmark: pop af  
52dc			endm  
# End of macro DMARK
52dc						CALLMONITOR 
52dc cd aa fd			call debug_vector  
52df				endm  
# End of macro CALLMONITOR
52df					endif 
52df			 
52df					; push a count of the dir items found 
52df			 
52df 26 00				ld h, 0 
52e1 69					ld l, c 
52e2 cd 23 20				call forth_push_numhl 
52e5			 
52e5					; push the bank label 
52e5			 
52e5 cd 16 05				call storage_get_block_0 
52e8			 
52e8				 
52e8 21 b8 f9		 		ld hl, store_page+3 
52eb			 
52eb					if DEBUG_FORTH_WORDS 
52eb						DMARK "DI8" 
52eb f5				push af  
52ec 3a 00 53			ld a, (.dmark)  
52ef 32 a6 fd			ld (debug_mark),a  
52f2 3a 01 53			ld a, (.dmark+1)  
52f5 32 a7 fd			ld (debug_mark+1),a  
52f8 3a 02 53			ld a, (.dmark+2)  
52fb 32 a8 fd			ld (debug_mark+2),a  
52fe 18 03			jr .pastdmark  
5300 ..			.dmark: db "DI8"  
5303 f1			.pastdmark: pop af  
5304			endm  
# End of macro DMARK
5304						CALLMONITOR 
5304 cd aa fd			call debug_vector  
5307				endm  
# End of macro CALLMONITOR
5307					endif 
5307 cd 91 20				call forth_push_str 
530a			 
530a			 
530a				 
530a					NEXTW 
530a c3 de 23			jp macro_next 
530d				endm 
# End of macro NEXTW
530d			.SAVE: 
530d			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
530d			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
530d			;		NEXTW 
530d			;.LOAD: 
530d			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
530d			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
530d			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
530d			;; > > The LOAD command can not be used in any user words or compound lines. 
530d			; 
530d			;		; store_openext use it. If zero it is EOF 
530d			; 
530d			;		; read block from current stream id 
530d			;		; if the block does not contain zero term keep reading blocks until zero found 
530d			;		; push the block to stack 
530d			;		; save the block id to stream 
530d			; 
530d			; 
530d			;		FORTH_DSP_VALUEHL 
530d			; 
530d			;;		push hl 
530d			; 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LOA" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;		FORTH_DSP_POP 
530d			; 
530d			;;		pop hl 
530d			; 
530d			;		ld h, l 
530d			;		ld l, 0 
530d			; 
530d			;		push hl     ; stack holds current file id and extent to work with 
530d			; 
530d			; 
530d			;		ld de, store_page      ; get block zero of file 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LO0" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;		call storage_read 
530d			; 
530d			;		ld a, (store_page+2)    ; max extents for this file 
530d			;		ld  (store_openmaxext),a   ; get our limit 
530d			; 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LOE" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			; 
530d			;; TODO dont know why max extents are not present 
530d			;;		cp 0 
530d			;;		jp z, .loadeof     ; dont read past eof 
530d			; 
530d			;;		ld a, 1   ; start from the head of the file 
530d			; 
530d			;.loadline:	pop hl 
530d			;		inc hl 
530d			;		ld  a, (store_openmaxext)   ; get our limit 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LOx" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;		inc a 
530d			;		cp l 
530d			;		jp z, .loadeof 
530d			;		push hl    ; save current extent 
530d			; 
530d			;		ld de, store_page 
530d			; 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LO1" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;		call storage_read 
530d			; 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LO2" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;	call ishlzero 
530d			;	ld a, l 
530d			;	add h 
530d			;	cp 0 
530d			;	jr z, .loadeof 
530d			; 
530d			;	; not eof so hl should point to data to exec 
530d			; 
530d			;	; will need to add the FORTH_END_BUFFER flag 
530d			 ; 
530d			;	ld hl, store_page+2 
530d			;	ld bc, 255 
530d			;	ld a, 0 
530d			;	cpir 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LOt" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;	dec hl 
530d			;	ld a, ' ' 
530d			;	ld (hl), a 
530d			;	inc hl 
530d			;	ld (hl), a 
530d			;	inc hl 
530d			;	ld (hl), a 
530d			;	inc hl 
530d			;	ld a, FORTH_END_BUFFER 
530d			;	ld (hl), a 
530d			; 
530d			;	; TODO handle more than a single block read 
530d			; 
530d			; 
530d			;	ld hl, store_page+2 
530d			; 
530d			;	ld (os_tok_ptr), hl 
530d			; 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LO3" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			; 
530d			;	call forthparse 
530d			;	call forthexec 
530d			;	call forthexec_cleanup 
530d			; 
530d			;	; go to next extent 
530d			; 
530d			;	; get next block  or mark as eof 
530d			;	jp .loadline 
530d			; 
530d			; 
530d			; 
530d			;	       NEXTW 
530d			;.loadeof:	ld a, 0 
530d			;		ld (store_openext), a 
530d			; 
530d			;	if DEBUG_STORESE 
530d			;		DMARK "LOF" 
530d			;		CALLMONITOR 
530d			;	endif 
530d			;		ret 
530d			;		;NEXTW 
530d			;.BSAVE:   
530d			; 
530d			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
530d			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
530d			;		NEXTW 
530d			;.BLOAD: 
530d			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
530d			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
530d			;		NEXTW 
530d			;;;; counter gap 
530d			 
530d			 
530d			.SEO: 
530d				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
530d 64				db WORD_SYS_CORE+80             
530e 2c 53			dw .SEI            
5310 04				db 3 + 1 
5311 .. 00			db "SEO",0              
5315				endm 
# End of macro CWHEAD
5315			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5315			 
5315					; get port 
5315			 
5315					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5315 cd 28 22			call macro_dsp_valuehl 
5318				endm 
# End of macro FORTH_DSP_VALUEHL
5318			 
5318 e5					push hl    ; u2 - byte 
5319			 
5319					; destroy value TOS 
5319			 
5319					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5319 cd e0 22			call macro_forth_dsp_pop 
531c				endm 
# End of macro FORTH_DSP_POP
531c			 
531c					; get byte to send 
531c			 
531c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
531c cd 28 22			call macro_dsp_valuehl 
531f				endm 
# End of macro FORTH_DSP_VALUEHL
531f			 
531f e5					push hl    ; u1 - addr 
5320			 
5320					; destroy value TOS 
5320			 
5320					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5320 cd e0 22			call macro_forth_dsp_pop 
5323				endm 
# End of macro FORTH_DSP_POP
5323			 
5323					; one value on hl get other one back 
5323			 
5323 d1					pop de   ; u1 - byte 
5324			 
5324 e1					pop hl   ; u2 - addr 
5325			 
5325					; TODO Send SPI byte 
5325			 
5325			 
5325 7b					ld a, e 
5326 cd 6a 02				call se_writebyte 
5329			 
5329					 
5329			 
5329					NEXTW 
5329 c3 de 23			jp macro_next 
532c				endm 
# End of macro NEXTW
532c			 
532c			.SEI: 
532c				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
532c 65				db WORD_SYS_CORE+81             
532d 46 53			dw .SFREE            
532f 04				db 3 + 1 
5330 .. 00			db "SEI",0              
5334				endm 
# End of macro CWHEAD
5334			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5334			 
5334					; get port 
5334			 
5334					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5334 cd 28 22			call macro_dsp_valuehl 
5337				endm 
# End of macro FORTH_DSP_VALUEHL
5337			 
5337			;		push hl 
5337			 
5337					; destroy value TOS 
5337			 
5337					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5337 cd e0 22			call macro_forth_dsp_pop 
533a				endm 
# End of macro FORTH_DSP_POP
533a			 
533a					; one value on hl get other one back 
533a			 
533a			;		pop hl 
533a			 
533a			 
533a					; TODO Get SPI byte 
533a			 
533a cd 0c 03				call se_readbyte 
533d			 
533d 26 00				ld h, 0 
533f 6f					ld l, a 
5340 cd 23 20				call forth_push_numhl 
5343			 
5343					NEXTW 
5343 c3 de 23			jp macro_next 
5346				endm 
# End of macro NEXTW
5346			 
5346			.SFREE: 
5346				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5346 67				db WORD_SYS_CORE+83             
5347 75 53			dw .SIZE            
5349 06				db 5 + 1 
534a .. 00			db "FFREE",0              
5350				endm 
# End of macro CWHEAD
5350			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5350			; | | > [!NOTE] 
5350			; | | > Compatible with PicoSPINet  
5350					if DEBUG_FORTH_WORDS_KEY 
5350						DMARK "FFR" 
5350 f5				push af  
5351 3a 65 53			ld a, (.dmark)  
5354 32 a6 fd			ld (debug_mark),a  
5357 3a 66 53			ld a, (.dmark+1)  
535a 32 a7 fd			ld (debug_mark+1),a  
535d 3a 67 53			ld a, (.dmark+2)  
5360 32 a8 fd			ld (debug_mark+2),a  
5363 18 03			jr .pastdmark  
5365 ..			.dmark: db "FFR"  
5368 f1			.pastdmark: pop af  
5369			endm  
# End of macro DMARK
5369						CALLMONITOR 
5369 cd aa fd			call debug_vector  
536c				endm  
# End of macro CALLMONITOR
536c					endif 
536c			 
536c cd 32 08				call storage_freeblocks 
536f			 
536f cd 23 20				call forth_push_numhl 
5372			 
5372				       NEXTW 
5372 c3 de 23			jp macro_next 
5375				endm 
# End of macro NEXTW
5375			.SIZE: 
5375				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5375 67				db WORD_SYS_CORE+83             
5376 a9 53			dw .CREATE            
5378 05				db 4 + 1 
5379 .. 00			db "SIZE",0              
537e				endm 
# End of macro CWHEAD
537e			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
537e			; | | > [!NOTE] 
537e			; | | > Compatible with PicoSPINet  
537e					if DEBUG_FORTH_WORDS_KEY 
537e						DMARK "SIZ" 
537e f5				push af  
537f 3a 93 53			ld a, (.dmark)  
5382 32 a6 fd			ld (debug_mark),a  
5385 3a 94 53			ld a, (.dmark+1)  
5388 32 a7 fd			ld (debug_mark+1),a  
538b 3a 95 53			ld a, (.dmark+2)  
538e 32 a8 fd			ld (debug_mark+2),a  
5391 18 03			jr .pastdmark  
5393 ..			.dmark: db "SIZ"  
5396 f1			.pastdmark: pop af  
5397			endm  
# End of macro DMARK
5397						CALLMONITOR 
5397 cd aa fd			call debug_vector  
539a				endm  
# End of macro CALLMONITOR
539a					endif 
539a			 
539a					FORTH_DSP_VALUEHL 
539a cd 28 22			call macro_dsp_valuehl 
539d				endm 
# End of macro FORTH_DSP_VALUEHL
539d			;		push hl 
539d					FORTH_DSP_POP 
539d cd e0 22			call macro_forth_dsp_pop 
53a0				endm 
# End of macro FORTH_DSP_POP
53a0			;		pop hl 
53a0 cd 94 04				call storage_file_size 
53a3			 
53a3 cd 23 20				call forth_push_numhl 
53a6			  
53a6			 
53a6				       NEXTW 
53a6 c3 de 23			jp macro_next 
53a9				endm 
# End of macro NEXTW
53a9			 
53a9			.CREATE: 
53a9				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53a9 68				db WORD_SYS_CORE+84             
53aa 17 54			dw .APPEND            
53ac 07				db 6 + 1 
53ad .. 00			db "CREATE",0              
53b4				endm 
# End of macro CWHEAD
53b4			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
53b4			; | | e.g.  
53b4			; | | TestProgram CREATE 
53b4			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
53b4			; | |  
53b4			; | | Max file IDs are 255. 
53b4			; | |  
53b4			; | | > [!NOTE] 
53b4			; | | > Compatible with PicoSPINet  
53b4					 
53b4					if DEBUG_FORTH_WORDS_KEY 
53b4						DMARK "CRT" 
53b4 f5				push af  
53b5 3a c9 53			ld a, (.dmark)  
53b8 32 a6 fd			ld (debug_mark),a  
53bb 3a ca 53			ld a, (.dmark+1)  
53be 32 a7 fd			ld (debug_mark+1),a  
53c1 3a cb 53			ld a, (.dmark+2)  
53c4 32 a8 fd			ld (debug_mark+2),a  
53c7 18 03			jr .pastdmark  
53c9 ..			.dmark: db "CRT"  
53cc f1			.pastdmark: pop af  
53cd			endm  
# End of macro DMARK
53cd						CALLMONITOR 
53cd cd aa fd			call debug_vector  
53d0				endm  
# End of macro CALLMONITOR
53d0					endif 
53d0			;		call storage_get_block_0 
53d0			 
53d0					; TODO pop hl 
53d0			 
53d0					;v5 FORTH_DSP_VALUE 
53d0					FORTH_DSP_VALUE 
53d0 cd 11 22			call macro_forth_dsp_value 
53d3				endm 
# End of macro FORTH_DSP_VALUE
53d3			 
53d3				if DEBUG_STORESE 
53d3					DMARK "CR1" 
53d3 f5				push af  
53d4 3a e8 53			ld a, (.dmark)  
53d7 32 a6 fd			ld (debug_mark),a  
53da 3a e9 53			ld a, (.dmark+1)  
53dd 32 a7 fd			ld (debug_mark+1),a  
53e0 3a ea 53			ld a, (.dmark+2)  
53e3 32 a8 fd			ld (debug_mark+2),a  
53e6 18 03			jr .pastdmark  
53e8 ..			.dmark: db "CR1"  
53eb f1			.pastdmark: pop af  
53ec			endm  
# End of macro DMARK
53ec					CALLMONITOR 
53ec cd aa fd			call debug_vector  
53ef				endm  
# End of macro CALLMONITOR
53ef				endif 
53ef			;		push hl 
53ef			;		FORTH_DSP_POP 
53ef			;		pop hl 
53ef			 
53ef			;		inc hl   ; move past the type marker 
53ef			 
53ef cd 68 08				call storage_create 
53f2			 
53f2				if DEBUG_STORESE 
53f2					DMARK "CT1" 
53f2 f5				push af  
53f3 3a 07 54			ld a, (.dmark)  
53f6 32 a6 fd			ld (debug_mark),a  
53f9 3a 08 54			ld a, (.dmark+1)  
53fc 32 a7 fd			ld (debug_mark+1),a  
53ff 3a 09 54			ld a, (.dmark+2)  
5402 32 a8 fd			ld (debug_mark+2),a  
5405 18 03			jr .pastdmark  
5407 ..			.dmark: db "CT1"  
540a f1			.pastdmark: pop af  
540b			endm  
# End of macro DMARK
540b					CALLMONITOR 
540b cd aa fd			call debug_vector  
540e				endm  
# End of macro CALLMONITOR
540e				endif 
540e			;		push hl 
540e					FORTH_DSP_POP 
540e cd e0 22			call macro_forth_dsp_pop 
5411				endm 
# End of macro FORTH_DSP_POP
5411			;		pop hl 
5411					; push file id to stack 
5411 cd 23 20				call forth_push_numhl 
5414			 
5414			 
5414			 
5414				       NEXTW 
5414 c3 de 23			jp macro_next 
5417				endm 
# End of macro NEXTW
5417			 
5417			.APPEND: 
5417				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5417 69				db WORD_SYS_CORE+85             
5418 a8 54			dw .SDEL            
541a 07				db 6 + 1 
541b .. 00			db "APPEND",0              
5422				endm 
# End of macro CWHEAD
5422			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5422			; | | e.g. 
5422			; | | Test CREATE      -> $01 
5422			; | | "A string to add to file" $01 APPEND 
5422			; | |  
5422			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5422			; | | > [!NOTE] 
5422			; | | > Compatible with PicoSPINet  
5422					if DEBUG_FORTH_WORDS_KEY 
5422						DMARK "APP" 
5422 f5				push af  
5423 3a 37 54			ld a, (.dmark)  
5426 32 a6 fd			ld (debug_mark),a  
5429 3a 38 54			ld a, (.dmark+1)  
542c 32 a7 fd			ld (debug_mark+1),a  
542f 3a 39 54			ld a, (.dmark+2)  
5432 32 a8 fd			ld (debug_mark+2),a  
5435 18 03			jr .pastdmark  
5437 ..			.dmark: db "APP"  
543a f1			.pastdmark: pop af  
543b			endm  
# End of macro DMARK
543b						CALLMONITOR 
543b cd aa fd			call debug_vector  
543e				endm  
# End of macro CALLMONITOR
543e					endif 
543e			 
543e					FORTH_DSP_VALUEHL 
543e cd 28 22			call macro_dsp_valuehl 
5441				endm 
# End of macro FORTH_DSP_VALUEHL
5441 e5					push hl 	; save file id 
5442			 
5442				if DEBUG_STORESE 
5442					DMARK "AP1" 
5442 f5				push af  
5443 3a 57 54			ld a, (.dmark)  
5446 32 a6 fd			ld (debug_mark),a  
5449 3a 58 54			ld a, (.dmark+1)  
544c 32 a7 fd			ld (debug_mark+1),a  
544f 3a 59 54			ld a, (.dmark+2)  
5452 32 a8 fd			ld (debug_mark+2),a  
5455 18 03			jr .pastdmark  
5457 ..			.dmark: db "AP1"  
545a f1			.pastdmark: pop af  
545b			endm  
# End of macro DMARK
545b					CALLMONITOR 
545b cd aa fd			call debug_vector  
545e				endm  
# End of macro CALLMONITOR
545e				endif 
545e					FORTH_DSP_POP 
545e cd e0 22			call macro_forth_dsp_pop 
5461				endm 
# End of macro FORTH_DSP_POP
5461			 
5461					FORTH_DSP_VALUEHL 
5461 cd 28 22			call macro_dsp_valuehl 
5464				endm 
# End of macro FORTH_DSP_VALUEHL
5464					;v5 FORTH_DSP_VALUE 
5464 e5					push hl 	; save ptr to string to save 
5465			 
5465				if DEBUG_STORESE 
5465					DMARK "AP1" 
5465 f5				push af  
5466 3a 7a 54			ld a, (.dmark)  
5469 32 a6 fd			ld (debug_mark),a  
546c 3a 7b 54			ld a, (.dmark+1)  
546f 32 a7 fd			ld (debug_mark+1),a  
5472 3a 7c 54			ld a, (.dmark+2)  
5475 32 a8 fd			ld (debug_mark+2),a  
5478 18 03			jr .pastdmark  
547a ..			.dmark: db "AP1"  
547d f1			.pastdmark: pop af  
547e			endm  
# End of macro DMARK
547e					CALLMONITOR 
547e cd aa fd			call debug_vector  
5481				endm  
# End of macro CALLMONITOR
5481				endif 
5481					FORTH_DSP_POP 
5481 cd e0 22			call macro_forth_dsp_pop 
5484				endm 
# End of macro FORTH_DSP_POP
5484			 
5484 d1					pop de 
5485 e1					pop hl 
5486				if DEBUG_STORESE 
5486					DMARK "AP2" 
5486 f5				push af  
5487 3a 9b 54			ld a, (.dmark)  
548a 32 a6 fd			ld (debug_mark),a  
548d 3a 9c 54			ld a, (.dmark+1)  
5490 32 a7 fd			ld (debug_mark+1),a  
5493 3a 9d 54			ld a, (.dmark+2)  
5496 32 a8 fd			ld (debug_mark+2),a  
5499 18 03			jr .pastdmark  
549b ..			.dmark: db "AP2"  
549e f1			.pastdmark: pop af  
549f			endm  
# End of macro DMARK
549f					CALLMONITOR 
549f cd aa fd			call debug_vector  
54a2				endm  
# End of macro CALLMONITOR
54a2				endif 
54a2					;inc de ; skip var type indicator 
54a2			 
54a2					; TODO how to append numerics???? 
54a2			 
54a2 cd 55 0b				call storage_append		 
54a5			 
54a5				       NEXTW 
54a5 c3 de 23			jp macro_next 
54a8				endm 
# End of macro NEXTW
54a8			.SDEL: 
54a8				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54a8 6a				db WORD_SYS_CORE+86             
54a9 f4 54			dw .OPEN            
54ab 05				db 4 + 1 
54ac .. 00			db "ERA",0              
54b0				endm 
# End of macro CWHEAD
54b0			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
54b0			; | | > [!NOTE] 
54b0			; | | > Compatible with PicoSPINet  
54b0					FORTH_DSP_VALUEHL 
54b0 cd 28 22			call macro_dsp_valuehl 
54b3				endm 
# End of macro FORTH_DSP_VALUEHL
54b3			;		push hl 	; save file id 
54b3			 
54b3					if DEBUG_FORTH_WORDS_KEY 
54b3						DMARK "ERA" 
54b3 f5				push af  
54b4 3a c8 54			ld a, (.dmark)  
54b7 32 a6 fd			ld (debug_mark),a  
54ba 3a c9 54			ld a, (.dmark+1)  
54bd 32 a7 fd			ld (debug_mark+1),a  
54c0 3a ca 54			ld a, (.dmark+2)  
54c3 32 a8 fd			ld (debug_mark+2),a  
54c6 18 03			jr .pastdmark  
54c8 ..			.dmark: db "ERA"  
54cb f1			.pastdmark: pop af  
54cc			endm  
# End of macro DMARK
54cc						CALLMONITOR 
54cc cd aa fd			call debug_vector  
54cf				endm  
# End of macro CALLMONITOR
54cf					endif 
54cf				if DEBUG_STORESE 
54cf					DMARK "ER1" 
54cf f5				push af  
54d0 3a e4 54			ld a, (.dmark)  
54d3 32 a6 fd			ld (debug_mark),a  
54d6 3a e5 54			ld a, (.dmark+1)  
54d9 32 a7 fd			ld (debug_mark+1),a  
54dc 3a e6 54			ld a, (.dmark+2)  
54df 32 a8 fd			ld (debug_mark+2),a  
54e2 18 03			jr .pastdmark  
54e4 ..			.dmark: db "ER1"  
54e7 f1			.pastdmark: pop af  
54e8			endm  
# End of macro DMARK
54e8					CALLMONITOR 
54e8 cd aa fd			call debug_vector  
54eb				endm  
# End of macro CALLMONITOR
54eb				endif 
54eb					FORTH_DSP_POP 
54eb cd e0 22			call macro_forth_dsp_pop 
54ee				endm 
# End of macro FORTH_DSP_POP
54ee			 
54ee			;		pop hl 
54ee			 
54ee cd a7 06				call storage_erase 
54f1				       NEXTW 
54f1 c3 de 23			jp macro_next 
54f4				endm 
# End of macro NEXTW
54f4			 
54f4			.OPEN: 
54f4				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
54f4 6b				db WORD_SYS_CORE+87             
54f5 88 55			dw .READ            
54f7 05				db 4 + 1 
54f8 .. 00			db "OPEN",0              
54fd				endm 
# End of macro CWHEAD
54fd			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
54fd			; | | e.g. 
54fd			; | | $01 OPEN $01 DO $01 READ . LOOP 
54fd			; | | 
54fd			; | | Will return with 255 blocks if the file does not exist 
54fd			; | | > [!NOTE] 
54fd			; | | > Compatible with PicoSPINet  
54fd			 
54fd					if DEBUG_FORTH_WORDS_KEY 
54fd						DMARK "OPN" 
54fd f5				push af  
54fe 3a 12 55			ld a, (.dmark)  
5501 32 a6 fd			ld (debug_mark),a  
5504 3a 13 55			ld a, (.dmark+1)  
5507 32 a7 fd			ld (debug_mark+1),a  
550a 3a 14 55			ld a, (.dmark+2)  
550d 32 a8 fd			ld (debug_mark+2),a  
5510 18 03			jr .pastdmark  
5512 ..			.dmark: db "OPN"  
5515 f1			.pastdmark: pop af  
5516			endm  
# End of macro DMARK
5516						CALLMONITOR 
5516 cd aa fd			call debug_vector  
5519				endm  
# End of macro CALLMONITOR
5519					endif 
5519					; TODO handle multiple file opens 
5519			 
5519 3e 01			       	ld a, 1 
551b 32 a5 f9				ld (store_openext), a 
551e			 
551e					; get max extents for this file 
551e				 
551e								 
551e					FORTH_DSP_VALUEHL 
551e cd 28 22			call macro_dsp_valuehl 
5521				endm 
# End of macro FORTH_DSP_VALUEHL
5521			 
5521 65					ld h, l 
5522 2e 00				ld l, 0 
5524			 
5524					; store file id 
5524			 
5524 7c					ld a, h 
5525 32 a2 f9				ld (store_filecache), a 
5528			 
5528				if DEBUG_STORESE 
5528					DMARK "OPN" 
5528 f5				push af  
5529 3a 3d 55			ld a, (.dmark)  
552c 32 a6 fd			ld (debug_mark),a  
552f 3a 3e 55			ld a, (.dmark+1)  
5532 32 a7 fd			ld (debug_mark+1),a  
5535 3a 3f 55			ld a, (.dmark+2)  
5538 32 a8 fd			ld (debug_mark+2),a  
553b 18 03			jr .pastdmark  
553d ..			.dmark: db "OPN"  
5540 f1			.pastdmark: pop af  
5541			endm  
# End of macro DMARK
5541					CALLMONITOR 
5541 cd aa fd			call debug_vector  
5544				endm  
# End of macro CALLMONITOR
5544				endif 
5544			;		push hl 
5544					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5544 cd e0 22			call macro_forth_dsp_pop 
5547				endm 
# End of macro FORTH_DSP_POP
5547			;		pop hl 
5547						 
5547 11 b5 f9				ld de, store_page      ; get block zero of file 
554a cd be 09				call storage_read 
554d cd f8 0f			call ishlzero 
5550 20 04			jr nz, .opfound 
5552			 
5552				; file does not exist so indicate with 255 extents in use 
5552			 
5552 3e ff			ld a, 255 
5554 18 29			jr .skipopeneof 
5556			 
5556			 
5556			.opfound: 
5556			 
5556			 
5556 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
5559 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
555c					 
555c				if DEBUG_STORESE 
555c					DMARK "OPx" 
555c f5				push af  
555d 3a 71 55			ld a, (.dmark)  
5560 32 a6 fd			ld (debug_mark),a  
5563 3a 72 55			ld a, (.dmark+1)  
5566 32 a7 fd			ld (debug_mark+1),a  
5569 3a 73 55			ld a, (.dmark+2)  
556c 32 a8 fd			ld (debug_mark+2),a  
556f 18 03			jr .pastdmark  
5571 ..			.dmark: db "OPx"  
5574 f1			.pastdmark: pop af  
5575			endm  
# End of macro DMARK
5575					CALLMONITOR 
5575 cd aa fd			call debug_vector  
5578				endm  
# End of macro CALLMONITOR
5578				endif 
5578 fe 00				cp 0 
557a 20 03				jr nz, .skipopeneof 
557c					; have opened an empty file 
557c					 
557c 32 a5 f9				ld (store_openext), a 
557f			 
557f			.skipopeneof: 
557f			 
557f 6f					ld l, a 
5580 26 00				ld h, 0 
5582 cd 23 20				call forth_push_numhl 
5585			 
5585			 
5585				       NEXTW 
5585 c3 de 23			jp macro_next 
5588				endm 
# End of macro NEXTW
5588			.READ: 
5588				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5588 6c				db WORD_SYS_CORE+88             
5589 b2 56			dw .EOF            
558b 05				db 4 + 1 
558c .. 00			db "READ",0              
5591				endm 
# End of macro CWHEAD
5591			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5591			; | | e.g. 
5591			; | | $01 OPEN $01 DO READ . LOOP 
5591			; | | 
5591			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5591			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5591			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5591			; | | two bytes contain the file id and extent. 
5591			; | |  
5591			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5591			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5591			; | | > [!NOTE] 
5591			; | | > Compatible with PicoSPINet  
5591			 
5591					if DEBUG_FORTH_WORDS_KEY 
5591						DMARK "REA" 
5591 f5				push af  
5592 3a a6 55			ld a, (.dmark)  
5595 32 a6 fd			ld (debug_mark),a  
5598 3a a7 55			ld a, (.dmark+1)  
559b 32 a7 fd			ld (debug_mark+1),a  
559e 3a a8 55			ld a, (.dmark+2)  
55a1 32 a8 fd			ld (debug_mark+2),a  
55a4 18 03			jr .pastdmark  
55a6 ..			.dmark: db "REA"  
55a9 f1			.pastdmark: pop af  
55aa			endm  
# End of macro DMARK
55aa						CALLMONITOR 
55aa cd aa fd			call debug_vector  
55ad				endm  
# End of macro CALLMONITOR
55ad					endif 
55ad					; store_openext use it. If zero it is EOF 
55ad			 
55ad					; read block from current stream id 
55ad					; if the block does not contain zero term keep reading blocks until zero found 
55ad					; push the block to stack 
55ad					; save the block id to stream 
55ad			 
55ad			 
55ad cd df 56				call .testeof 
55b0 3e 01				ld a, 1 
55b2 bd					cp l 
55b3 ca 8e 56				jp z, .ateof 
55b6			 
55b6			 
55b6			;		FORTH_DSP_VALUEHL 
55b6			 
55b6			;		push hl 
55b6			 
55b6			;	if DEBUG_STORESE 
55b6			;		DMARK "REA" 
55b6			;		CALLMONITOR 
55b6			;	endif 
55b6			;		FORTH_DSP_POP 
55b6			 
55b6			;		pop hl 
55b6				 
55b6 3a a2 f9				ld a, (store_filecache) 
55b9 67					ld h,a 
55ba			 
55ba 3a a5 f9				ld a, (store_openext) 
55bd 6f					ld l, a 
55be					 
55be fe 00				cp 0 
55c0 ca 8e 56				jp z, .ateof     ; dont read past eof 
55c3			 
55c3 cd a1 0c				call storage_clear_page 
55c6			 
55c6 11 b5 f9				ld de, store_page 
55c9				if DEBUG_STORESE 
55c9					DMARK "RE1" 
55c9 f5				push af  
55ca 3a de 55			ld a, (.dmark)  
55cd 32 a6 fd			ld (debug_mark),a  
55d0 3a df 55			ld a, (.dmark+1)  
55d3 32 a7 fd			ld (debug_mark+1),a  
55d6 3a e0 55			ld a, (.dmark+2)  
55d9 32 a8 fd			ld (debug_mark+2),a  
55dc 18 03			jr .pastdmark  
55de ..			.dmark: db "RE1"  
55e1 f1			.pastdmark: pop af  
55e2			endm  
# End of macro DMARK
55e2					CALLMONITOR 
55e2 cd aa fd			call debug_vector  
55e5				endm  
# End of macro CALLMONITOR
55e5				endif 
55e5 cd be 09				call storage_read 
55e8			 
55e8				if DEBUG_STORESE 
55e8					DMARK "RE2" 
55e8 f5				push af  
55e9 3a fd 55			ld a, (.dmark)  
55ec 32 a6 fd			ld (debug_mark),a  
55ef 3a fe 55			ld a, (.dmark+1)  
55f2 32 a7 fd			ld (debug_mark+1),a  
55f5 3a ff 55			ld a, (.dmark+2)  
55f8 32 a8 fd			ld (debug_mark+2),a  
55fb 18 03			jr .pastdmark  
55fd ..			.dmark: db "RE2"  
5600 f1			.pastdmark: pop af  
5601			endm  
# End of macro DMARK
5601					CALLMONITOR 
5601 cd aa fd			call debug_vector  
5604				endm  
# End of macro CALLMONITOR
5604				endif 
5604 cd f8 0f			call ishlzero 
5607			;	ld a, l 
5607			;	add h 
5607			;	cp 0 
5607 ca 8e 56			jp z, .readeof 
560a			 
560a				; not eof so hl should point to data to push to stack 
560a			 
560a				if DEBUG_STORESE 
560a					DMARK "RE3" 
560a f5				push af  
560b 3a 1f 56			ld a, (.dmark)  
560e 32 a6 fd			ld (debug_mark),a  
5611 3a 20 56			ld a, (.dmark+1)  
5614 32 a7 fd			ld (debug_mark+1),a  
5617 3a 21 56			ld a, (.dmark+2)  
561a 32 a8 fd			ld (debug_mark+2),a  
561d 18 03			jr .pastdmark  
561f ..			.dmark: db "RE3"  
5622 f1			.pastdmark: pop af  
5623			endm  
# End of macro DMARK
5623					CALLMONITOR 
5623 cd aa fd			call debug_vector  
5626				endm  
# End of macro CALLMONITOR
5626				endif 
5626 cd 91 20			call forth_push_str 
5629			 
5629				if DEBUG_STORESE 
5629					DMARK "RE4" 
5629 f5				push af  
562a 3a 3e 56			ld a, (.dmark)  
562d 32 a6 fd			ld (debug_mark),a  
5630 3a 3f 56			ld a, (.dmark+1)  
5633 32 a7 fd			ld (debug_mark+1),a  
5636 3a 40 56			ld a, (.dmark+2)  
5639 32 a8 fd			ld (debug_mark+2),a  
563c 18 03			jr .pastdmark  
563e ..			.dmark: db "RE4"  
5641 f1			.pastdmark: pop af  
5642			endm  
# End of macro DMARK
5642					CALLMONITOR 
5642 cd aa fd			call debug_vector  
5645				endm  
# End of macro CALLMONITOR
5645				endif 
5645				; get next block  or mark as eof 
5645			 
5645 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
5648 4f				ld c, a	 
5649 3a a5 f9			ld a, (store_openext) 
564c			 
564c				if DEBUG_STORESE 
564c					DMARK "RE5" 
564c f5				push af  
564d 3a 61 56			ld a, (.dmark)  
5650 32 a6 fd			ld (debug_mark),a  
5653 3a 62 56			ld a, (.dmark+1)  
5656 32 a7 fd			ld (debug_mark+1),a  
5659 3a 63 56			ld a, (.dmark+2)  
565c 32 a8 fd			ld (debug_mark+2),a  
565f 18 03			jr .pastdmark  
5661 ..			.dmark: db "RE5"  
5664 f1			.pastdmark: pop af  
5665			endm  
# End of macro DMARK
5665					CALLMONITOR 
5665 cd aa fd			call debug_vector  
5668				endm  
# End of macro CALLMONITOR
5668				endif 
5668 b9				cp c 
5669 28 23			jr z, .readeof     ; at last extent 
566b			 
566b 3c					inc a 
566c 32 a5 f9				ld (store_openext), a 
566f			 
566f				if DEBUG_STORESE 
566f					DMARK "RE6" 
566f f5				push af  
5670 3a 84 56			ld a, (.dmark)  
5673 32 a6 fd			ld (debug_mark),a  
5676 3a 85 56			ld a, (.dmark+1)  
5679 32 a7 fd			ld (debug_mark+1),a  
567c 3a 86 56			ld a, (.dmark+2)  
567f 32 a8 fd			ld (debug_mark+2),a  
5682 18 03			jr .pastdmark  
5684 ..			.dmark: db "RE6"  
5687 f1			.pastdmark: pop af  
5688			endm  
# End of macro DMARK
5688					CALLMONITOR 
5688 cd aa fd			call debug_vector  
568b				endm  
# End of macro CALLMONITOR
568b				endif 
568b			 
568b			 
568b				       NEXTW 
568b c3 de 23			jp macro_next 
568e				endm 
# End of macro NEXTW
568e			.ateof: 
568e				;	ld hl, .showeof 
568e				;	call forth_push_str 
568e 3e 00		.readeof:	ld a, 0 
5690 32 a5 f9				ld (store_openext), a 
5693			 
5693					 
5693				if DEBUG_STORESE 
5693					DMARK "REF" 
5693 f5				push af  
5694 3a a8 56			ld a, (.dmark)  
5697 32 a6 fd			ld (debug_mark),a  
569a 3a a9 56			ld a, (.dmark+1)  
569d 32 a7 fd			ld (debug_mark+1),a  
56a0 3a aa 56			ld a, (.dmark+2)  
56a3 32 a8 fd			ld (debug_mark+2),a  
56a6 18 03			jr .pastdmark  
56a8 ..			.dmark: db "REF"  
56ab f1			.pastdmark: pop af  
56ac			endm  
# End of macro DMARK
56ac					CALLMONITOR 
56ac cd aa fd			call debug_vector  
56af				endm  
# End of macro CALLMONITOR
56af				endif 
56af				       NEXTW 
56af c3 de 23			jp macro_next 
56b2				endm 
# End of macro NEXTW
56b2			 
56b2			;.showeof:   db "eof", 0 
56b2			 
56b2			 
56b2			.EOF: 
56b2				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
56b2 6d				db WORD_SYS_CORE+89             
56b3 f4 56			dw .FORMAT            
56b5 04				db 3 + 1 
56b6 .. 00			db "EOF",0              
56ba				endm 
# End of macro CWHEAD
56ba			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56ba			; | | e.g. 
56ba			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56ba			; | | > [!NOTE] 
56ba			; | | > Compatible with PicoSPINet  
56ba					; TODO if current block id for stream is zero then push true else false 
56ba			 
56ba					if DEBUG_FORTH_WORDS_KEY 
56ba						DMARK "EOF" 
56ba f5				push af  
56bb 3a cf 56			ld a, (.dmark)  
56be 32 a6 fd			ld (debug_mark),a  
56c1 3a d0 56			ld a, (.dmark+1)  
56c4 32 a7 fd			ld (debug_mark+1),a  
56c7 3a d1 56			ld a, (.dmark+2)  
56ca 32 a8 fd			ld (debug_mark+2),a  
56cd 18 03			jr .pastdmark  
56cf ..			.dmark: db "EOF"  
56d2 f1			.pastdmark: pop af  
56d3			endm  
# End of macro DMARK
56d3						CALLMONITOR 
56d3 cd aa fd			call debug_vector  
56d6				endm  
# End of macro CALLMONITOR
56d6					endif 
56d6			 
56d6					; TODO handlue multiple file streams 
56d6			 
56d6			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56d6 cd df 56				call .testeof 
56d9 cd 23 20				call forth_push_numhl 
56dc			 
56dc			 
56dc				       NEXTW 
56dc c3 de 23			jp macro_next 
56df				endm 
# End of macro NEXTW
56df			 
56df			.testeof: 
56df 2e 01				ld l, 1 
56e1 3a a4 f9				ld a, (store_openmaxext) 
56e4 fe 00				cp 0 
56e6 28 09				jr  z, .eofdone   ; empty file 
56e8 3a a5 f9				ld a, (store_openext) 
56eb fe 00				cp 0 
56ed 28 02				jr  z, .eofdone 
56ef 2e 00				ld l, 0 
56f1 26 00		.eofdone:	ld h, 0 
56f3 c9					ret 
56f4			 
56f4			 
56f4			 
56f4			 
56f4			.FORMAT: 
56f4				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
56f4 6d				db WORD_SYS_CORE+89             
56f5 45 57			dw .LABEL            
56f7 07				db 6 + 1 
56f8 .. 00			db "FORMAT",0              
56ff				endm 
# End of macro CWHEAD
56ff			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
56ff			; | | > [!NOTE] 
56ff			; | | > Compatible with PicoSPINet  
56ff					; TODO if current block id for stream is zero then push true else false 
56ff				 
56ff				if DEBUG_STORESE 
56ff					DMARK "FOR" 
56ff f5				push af  
5700 3a 14 57			ld a, (.dmark)  
5703 32 a6 fd			ld (debug_mark),a  
5706 3a 15 57			ld a, (.dmark+1)  
5709 32 a7 fd			ld (debug_mark+1),a  
570c 3a 16 57			ld a, (.dmark+2)  
570f 32 a8 fd			ld (debug_mark+2),a  
5712 18 03			jr .pastdmark  
5714 ..			.dmark: db "FOR"  
5717 f1			.pastdmark: pop af  
5718			endm  
# End of macro DMARK
5718					CALLMONITOR 
5718 cd aa fd			call debug_vector  
571b				endm  
# End of macro CALLMONITOR
571b				endif 
571b					; Wipes the bank check flags to cause a reformat on next block 0 read 
571b			 
571b 21 01 00				ld hl, 1 
571e 3e 00				ld a, 0 
5720 cd 6a 02				call se_writebyte 
5723			 
5723				if DEBUG_STORESE 
5723					DMARK "FO0" 
5723 f5				push af  
5724 3a 38 57			ld a, (.dmark)  
5727 32 a6 fd			ld (debug_mark),a  
572a 3a 39 57			ld a, (.dmark+1)  
572d 32 a7 fd			ld (debug_mark+1),a  
5730 3a 3a 57			ld a, (.dmark+2)  
5733 32 a8 fd			ld (debug_mark+2),a  
5736 18 03			jr .pastdmark  
5738 ..			.dmark: db "FO0"  
573b f1			.pastdmark: pop af  
573c			endm  
# End of macro DMARK
573c					CALLMONITOR 
573c cd aa fd			call debug_vector  
573f				endm  
# End of macro CALLMONITOR
573f				endif 
573f					; force bank init 
573f			 
573f cd 16 05				call storage_get_block_0 
5742					 
5742				       NEXTW 
5742 c3 de 23			jp macro_next 
5745				endm 
# End of macro NEXTW
5745			.LABEL: 
5745				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5745 6d				db WORD_SYS_CORE+89             
5746 93 57			dw .STOREPAGE            
5748 06				db 5 + 1 
5749 .. 00			db "LABEL",0              
574f				endm 
# End of macro CWHEAD
574f			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
574f			; | | > [!NOTE] 
574f			; | | > Compatible with PicoSPINet  
574f					; TODO test to see if bank is selected 
574f				 
574f					if DEBUG_FORTH_WORDS_KEY 
574f						DMARK "LBL" 
574f f5				push af  
5750 3a 64 57			ld a, (.dmark)  
5753 32 a6 fd			ld (debug_mark),a  
5756 3a 65 57			ld a, (.dmark+1)  
5759 32 a7 fd			ld (debug_mark+1),a  
575c 3a 66 57			ld a, (.dmark+2)  
575f 32 a8 fd			ld (debug_mark+2),a  
5762 18 03			jr .pastdmark  
5764 ..			.dmark: db "LBL"  
5767 f1			.pastdmark: pop af  
5768			endm  
# End of macro DMARK
5768						CALLMONITOR 
5768 cd aa fd			call debug_vector  
576b				endm  
# End of macro CALLMONITOR
576b					endif 
576b			;	if DEBUG_STORESE 
576b			;		DMARK "LBL" 
576b			;		CALLMONITOR 
576b			;	endif 
576b					FORTH_DSP_VALUEHL 
576b cd 28 22			call macro_dsp_valuehl 
576e				endm 
# End of macro FORTH_DSP_VALUEHL
576e					;v5FORTH_DSP_VALUE 
576e					 
576e			;		push hl 
576e					FORTH_DSP_POP 
576e cd e0 22			call macro_forth_dsp_pop 
5771				endm 
# End of macro FORTH_DSP_POP
5771			;		pop hl 
5771			 
5771			;v5		inc hl   ; move past the type marker 
5771			 
5771				if DEBUG_STORESE 
5771					DMARK "LBl" 
5771 f5				push af  
5772 3a 86 57			ld a, (.dmark)  
5775 32 a6 fd			ld (debug_mark),a  
5778 3a 87 57			ld a, (.dmark+1)  
577b 32 a7 fd			ld (debug_mark+1),a  
577e 3a 88 57			ld a, (.dmark+2)  
5781 32 a8 fd			ld (debug_mark+2),a  
5784 18 03			jr .pastdmark  
5786 ..			.dmark: db "LBl"  
5789 f1			.pastdmark: pop af  
578a			endm  
# End of macro DMARK
578a					CALLMONITOR 
578a cd aa fd			call debug_vector  
578d				endm  
# End of macro CALLMONITOR
578d				endif 
578d cd 3a 06				call storage_label 
5790			 
5790				       NEXTW 
5790 c3 de 23			jp macro_next 
5793				endm 
# End of macro NEXTW
5793			.STOREPAGE: 
5793				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5793 6d				db WORD_SYS_CORE+89             
5794 c6 57			dw .LABELS            
5796 0a				db 9 + 1 
5797 .. 00			db "STOREPAGE",0              
57a1				endm 
# End of macro CWHEAD
57a1			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57a1			; | | > [!NOTE] 
57a1			; | | > Compatible with PicoSPINet  
57a1					; TODO test to see if bank is selected 
57a1				 
57a1					if DEBUG_FORTH_WORDS_KEY 
57a1						DMARK "STP" 
57a1 f5				push af  
57a2 3a b6 57			ld a, (.dmark)  
57a5 32 a6 fd			ld (debug_mark),a  
57a8 3a b7 57			ld a, (.dmark+1)  
57ab 32 a7 fd			ld (debug_mark+1),a  
57ae 3a b8 57			ld a, (.dmark+2)  
57b1 32 a8 fd			ld (debug_mark+2),a  
57b4 18 03			jr .pastdmark  
57b6 ..			.dmark: db "STP"  
57b9 f1			.pastdmark: pop af  
57ba			endm  
# End of macro DMARK
57ba						CALLMONITOR 
57ba cd aa fd			call debug_vector  
57bd				endm  
# End of macro CALLMONITOR
57bd					endif 
57bd			;	if DEBUG_STORESE 
57bd			;		DMARK "STP" 
57bd			;		CALLMONITOR 
57bd			;	endif 
57bd			 
57bd 21 b5 f9			ld hl, store_page 
57c0 cd 23 20			call forth_push_numhl 
57c3			 
57c3			 
57c3				       NEXTW 
57c3 c3 de 23			jp macro_next 
57c6				endm 
# End of macro NEXTW
57c6			.LABELS: 
57c6				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57c6 6d				db WORD_SYS_CORE+89             
57c7 50 58			dw .SCONST1            
57c9 07				db 6 + 1 
57ca .. 00			db "LABELS",0              
57d1				endm 
# End of macro CWHEAD
57d1			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
57d1			; | | > [!CAUTION] 
57d1			; | | > *NOT* Compatible with PicoSPINet  
57d1					;  
57d1			 
57d1					; save the current device selected to restore afterwards 
57d1				 
57d1 3a 9b f9				ld a, (spi_device) 
57d4 f5					push af 
57d5			 
57d5			 
57d5					; run through each of the banks 
57d5			 
57d5 21 01 00				ld hl, 1 
57d8 cd 23 20				call forth_push_numhl 
57db 3e ff				ld a, SPI_CE_HIGH 
57dd cb 87				res SPI_CE0, a 
57df 32 9b f9				ld (spi_device), a 
57e2 cd 16 05				call storage_get_block_0 
57e5 21 b8 f9				ld hl, store_page+3 
57e8 cd 91 20				call forth_push_str 
57eb			 
57eb					 
57eb 21 02 00				ld hl, 2 
57ee cd 23 20				call forth_push_numhl 
57f1 3e ff				ld a, SPI_CE_HIGH 
57f3 cb 8f				res SPI_CE1, a 
57f5 32 9b f9				ld (spi_device), a 
57f8 cd 16 05				call storage_get_block_0 
57fb 21 b8 f9				ld hl, store_page+3 
57fe cd 91 20				call forth_push_str 
5801			 
5801					 
5801 21 03 00				ld hl, 3 
5804 cd 23 20				call forth_push_numhl 
5807 3e ff				ld a, SPI_CE_HIGH 
5809 cb 97				res SPI_CE2, a 
580b 32 9b f9				ld (spi_device), a 
580e cd 16 05				call storage_get_block_0 
5811 21 b8 f9				ld hl, store_page+3 
5814 cd 91 20				call forth_push_str 
5817			 
5817			 
5817 21 04 00				ld hl, 4 
581a cd 23 20				call forth_push_numhl 
581d 3e ff				ld a, SPI_CE_HIGH 
581f cb 9f				res SPI_CE3, a 
5821 32 9b f9				ld (spi_device), a 
5824 cd 16 05				call storage_get_block_0 
5827 21 b8 f9				ld hl, store_page+3 
582a cd 91 20				call forth_push_str 
582d			 
582d					 
582d			 
582d 21 05 00				ld hl, 5 
5830 cd 23 20				call forth_push_numhl 
5833 3e ff				ld a, SPI_CE_HIGH 
5835 cb a7				res SPI_CE4, a 
5837 32 9b f9				ld (spi_device), a 
583a cd 16 05				call storage_get_block_0 
583d 21 b8 f9				ld hl, store_page+3 
5840 cd 91 20				call forth_push_str 
5843			 
5843					 
5843					; push fixed count of storage devices (on board) for now 
5843			 
5843 21 05 00				ld hl, 5 
5846 cd 23 20				call forth_push_numhl 
5849			 
5849					; restore selected device  
5849				 
5849 f1					pop af 
584a 32 9b f9				ld (spi_device), a 
584d			 
584d				       NEXTW 
584d c3 de 23			jp macro_next 
5850				endm 
# End of macro NEXTW
5850			 
5850			.SCONST1: 
5850				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5850 6d				db WORD_SYS_CORE+89             
5851 67 58			dw .SCONST2            
5853 07				db 6 + 1 
5854 .. 00			db "FILEID",0              
585b				endm 
# End of macro CWHEAD
585b			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
585b			; | | > [!NOTE] 
585b			; | | > Compatible with PicoSPINet  
585b 3a a2 f9				ld a, (store_filecache) 
585e 26 00				ld h, 0 
5860 6f					ld l, a 
5861 cd 23 20				call forth_push_numhl 
5864					NEXTW 
5864 c3 de 23			jp macro_next 
5867				endm 
# End of macro NEXTW
5867			.SCONST2: 
5867				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5867 6d				db WORD_SYS_CORE+89             
5868 7f 58			dw .SCONST3            
586a 08				db 7 + 1 
586b .. 00			db "FILEEXT",0              
5873				endm 
# End of macro CWHEAD
5873			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5873			; | | > [!NOTE] 
5873			; | | > Compatible with PicoSPINet  
5873 3a a5 f9				ld a, (store_openext) 
5876 26 00				ld h, 0 
5878 6f					ld l, a 
5879 cd 23 20				call forth_push_numhl 
587c					NEXTW 
587c c3 de 23			jp macro_next 
587f				endm 
# End of macro NEXTW
587f			.SCONST3: 
587f				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
587f 6d				db WORD_SYS_CORE+89             
5880 97 58			dw .SCONST4            
5882 08				db 7 + 1 
5883 .. 00			db "FILEMAX",0              
588b				endm 
# End of macro CWHEAD
588b			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
588b			; | | > [!NOTE] 
588b			; | | > Compatible with PicoSPINet  
588b 3a a4 f9				ld a, (store_openmaxext) 
588e 26 00				ld h, 0 
5890 6f					ld l, a 
5891 cd 23 20				call forth_push_numhl 
5894					NEXTW 
5894 c3 de 23			jp macro_next 
5897				endm 
# End of macro NEXTW
5897			.SCONST4: 
5897				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5897 6d				db WORD_SYS_CORE+89             
5898 ad 58			dw .SCONST5            
589a 09				db 8 + 1 
589b .. 00			db "FILEADDR",0              
58a4				endm 
# End of macro CWHEAD
58a4			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
58a4			; | | > [!NOTE] 
58a4			; | | > Compatible with PicoSPINet  
58a4 2a a6 f9				ld hl, (store_openaddr) 
58a7 cd 23 20				call forth_push_numhl 
58aa					NEXTW 
58aa c3 de 23			jp macro_next 
58ad				endm 
# End of macro NEXTW
58ad			.SCONST5: 
58ad				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
58ad 6d				db WORD_SYS_CORE+89             
58ae ce 58			dw .SCONST6            
58b0 09				db 8 + 1 
58b1 .. 00			db "FILEPAGE",0              
58ba				endm 
# End of macro CWHEAD
58ba			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58ba			; | | > [!NOTE] 
58ba			; | | > Compatible with PicoSPINet  
58ba 2a a6 f9				ld hl, (store_openaddr) 
58bd e5					push hl 
58be c1					pop bc 
58bf 16 00				ld d, 0 
58c1 1e 40				ld e, STORE_BLOCK_PHY 
58c3 cd 2c 0f				call Div16 
58c6 c5					push bc 
58c7 e1					pop hl 
58c8 cd 23 20				call forth_push_numhl 
58cb					NEXTW 
58cb c3 de 23			jp macro_next 
58ce				endm 
# End of macro NEXTW
58ce			.SCONST6: 
58ce				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58ce 6d				db WORD_SYS_CORE+89             
58cf e7 58			dw .ENDSTORAGE            
58d1 09				db 8 + 1 
58d2 .. 00			db "READCONT",0              
58db				endm 
# End of macro CWHEAD
58db			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58db			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58db			; | | a further read should, if applicable, be CONCAT to the previous read. 
58db			; | | > [!NOTE] 
58db			; | | > Compatible with PicoSPINet  
58db 3a a8 f9				ld a, (store_readcont) 
58de 26 00				ld h, 0 
58e0 6f					ld l, a 
58e1 cd 23 20				call forth_push_numhl 
58e4					NEXTW 
58e4 c3 de 23			jp macro_next 
58e7				endm 
# End of macro NEXTW
58e7			.ENDSTORAGE: 
58e7			; eof 
# End of file forth_words_storage.asm
58e7			endif 
58e7				include "forth_words_device.asm" 
58e7			; Device related words 
58e7			 
58e7			; | ## Device Words 
58e7			 
58e7			;if SOUND_ENABLE 
58e7			;.NOTE: 
58e7			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58e7			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
58e7			;		if DEBUG_FORTH_WORDS_KEY 
58e7			;			DMARK "NTE" 
58e7			;			CALLMONITOR 
58e7			;		endif 
58e7			; 
58e7			;	 
58e7			; 
58e7			;		NEXTW 
58e7			;.AFTERSOUND: 
58e7			;endif 
58e7			 
58e7			 
58e7			USE_GPIO: equ 0 
58e7			 
58e7			if USE_GPIO 
58e7			.GP1: 
58e7				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58e7			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
58e7					NEXTW 
58e7			.GP2: 
58e7				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58e7			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
58e7			 
58e7					NEXTW 
58e7			 
58e7			.GP3: 
58e7				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58e7			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
58e7			 
58e7					NEXTW 
58e7			 
58e7			.GP4: 
58e7				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58e7			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
58e7			 
58e7					NEXTW 
58e7			.SIN: 
58e7			 
58e7			 
58e7			endif 
58e7			 
58e7			 
58e7				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58e7 33				db WORD_SYS_CORE+31             
58e8 1c 59			dw .SOUT            
58ea 03				db 2 + 1 
58eb .. 00			db "IN",0              
58ee				endm 
# End of macro CWHEAD
58ee			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58ee					if DEBUG_FORTH_WORDS_KEY 
58ee						DMARK "IN." 
58ee f5				push af  
58ef 3a 03 59			ld a, (.dmark)  
58f2 32 a6 fd			ld (debug_mark),a  
58f5 3a 04 59			ld a, (.dmark+1)  
58f8 32 a7 fd			ld (debug_mark+1),a  
58fb 3a 05 59			ld a, (.dmark+2)  
58fe 32 a8 fd			ld (debug_mark+2),a  
5901 18 03			jr .pastdmark  
5903 ..			.dmark: db "IN."  
5906 f1			.pastdmark: pop af  
5907			endm  
# End of macro DMARK
5907						CALLMONITOR 
5907 cd aa fd			call debug_vector  
590a				endm  
# End of macro CALLMONITOR
590a					endif 
590a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
590a cd 28 22			call macro_dsp_valuehl 
590d				endm 
# End of macro FORTH_DSP_VALUEHL
590d			 
590d e5					push hl 
590e			 
590e					; destroy value TOS 
590e			 
590e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
590e cd e0 22			call macro_forth_dsp_pop 
5911				endm 
# End of macro FORTH_DSP_POP
5911			 
5911					; one value on hl get other one back 
5911			 
5911 c1					pop bc 
5912			 
5912					; do the sub 
5912			;		ex de, hl 
5912			 
5912 ed 68				in l,(c) 
5914			 
5914					; save it 
5914			 
5914 26 00				ld h,0 
5916			 
5916					; TODO push value back onto stack for another op etc 
5916			 
5916 cd 23 20				call forth_push_numhl 
5919					NEXTW 
5919 c3 de 23			jp macro_next 
591c				endm 
# End of macro NEXTW
591c			.SOUT: 
591c				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
591c 34				db WORD_SYS_CORE+32             
591d 6f 59			dw .SPIO            
591f 04				db 3 + 1 
5920 .. 00			db "OUT",0              
5924				endm 
# End of macro CWHEAD
5924			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5924					if DEBUG_FORTH_WORDS_KEY 
5924						DMARK "OUT" 
5924 f5				push af  
5925 3a 39 59			ld a, (.dmark)  
5928 32 a6 fd			ld (debug_mark),a  
592b 3a 3a 59			ld a, (.dmark+1)  
592e 32 a7 fd			ld (debug_mark+1),a  
5931 3a 3b 59			ld a, (.dmark+2)  
5934 32 a8 fd			ld (debug_mark+2),a  
5937 18 03			jr .pastdmark  
5939 ..			.dmark: db "OUT"  
593c f1			.pastdmark: pop af  
593d			endm  
# End of macro DMARK
593d						CALLMONITOR 
593d cd aa fd			call debug_vector  
5940				endm  
# End of macro CALLMONITOR
5940					endif 
5940			 
5940					; get port 
5940			 
5940					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5940 cd 28 22			call macro_dsp_valuehl 
5943				endm 
# End of macro FORTH_DSP_VALUEHL
5943			 
5943 e5					push hl 
5944			 
5944					; destroy value TOS 
5944			 
5944					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5944 cd e0 22			call macro_forth_dsp_pop 
5947				endm 
# End of macro FORTH_DSP_POP
5947			 
5947					; get byte to send 
5947			 
5947					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5947 cd 28 22			call macro_dsp_valuehl 
594a				endm 
# End of macro FORTH_DSP_VALUEHL
594a			 
594a			;		push hl 
594a			 
594a					; destroy value TOS 
594a			 
594a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
594a cd e0 22			call macro_forth_dsp_pop 
594d				endm 
# End of macro FORTH_DSP_POP
594d			 
594d					; one value on hl get other one back 
594d			 
594d			;		pop hl 
594d			 
594d c1					pop bc 
594e			 
594e					if DEBUG_FORTH_WORDS 
594e						DMARK "OUT" 
594e f5				push af  
594f 3a 63 59			ld a, (.dmark)  
5952 32 a6 fd			ld (debug_mark),a  
5955 3a 64 59			ld a, (.dmark+1)  
5958 32 a7 fd			ld (debug_mark+1),a  
595b 3a 65 59			ld a, (.dmark+2)  
595e 32 a8 fd			ld (debug_mark+2),a  
5961 18 03			jr .pastdmark  
5963 ..			.dmark: db "OUT"  
5966 f1			.pastdmark: pop af  
5967			endm  
# End of macro DMARK
5967						CALLMONITOR 
5967 cd aa fd			call debug_vector  
596a				endm  
# End of macro CALLMONITOR
596a					endif 
596a			 
596a ed 69				out (c), l 
596c			 
596c					NEXTW 
596c c3 de 23			jp macro_next 
596f				endm 
# End of macro NEXTW
596f			 
596f			 
596f			.SPIO: 
596f			 
596f			if STORAGE_SE 
596f				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
596f 51				db WORD_SYS_CORE+61             
5970 80 59			dw .SPICEH            
5972 07				db 6 + 1 
5973 .. 00			db "SPICEL",0              
597a				endm 
# End of macro CWHEAD
597a			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
597a			 
597a cd 13 02				call spi_ce_low 
597d			    NEXTW 
597d c3 de 23			jp macro_next 
5980				endm 
# End of macro NEXTW
5980			 
5980			.SPICEH: 
5980				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5980 51				db WORD_SYS_CORE+61             
5981 91 59			dw .SPIOb            
5983 07				db 6 + 1 
5984 .. 00			db "SPICEH",0              
598b				endm 
# End of macro CWHEAD
598b			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
598b			 
598b cd 02 02				call spi_ce_high 
598e			    NEXTW 
598e c3 de 23			jp macro_next 
5991				endm 
# End of macro NEXTW
5991			 
5991			 
5991			.SPIOb: 
5991			 
5991				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5991 51				db WORD_SYS_CORE+61             
5992 c3 59			dw .SPII            
5994 05				db 4 + 1 
5995 .. 00			db "SPIO",0              
599a				endm 
# End of macro CWHEAD
599a			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
599a			 
599a					if DEBUG_FORTH_WORDS_KEY 
599a						DMARK "SPo" 
599a f5				push af  
599b 3a af 59			ld a, (.dmark)  
599e 32 a6 fd			ld (debug_mark),a  
59a1 3a b0 59			ld a, (.dmark+1)  
59a4 32 a7 fd			ld (debug_mark+1),a  
59a7 3a b1 59			ld a, (.dmark+2)  
59aa 32 a8 fd			ld (debug_mark+2),a  
59ad 18 03			jr .pastdmark  
59af ..			.dmark: db "SPo"  
59b2 f1			.pastdmark: pop af  
59b3			endm  
# End of macro DMARK
59b3						CALLMONITOR 
59b3 cd aa fd			call debug_vector  
59b6				endm  
# End of macro CALLMONITOR
59b6					endif 
59b6					; get port 
59b6			 
59b6			 
59b6					; get byte to send 
59b6			 
59b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59b6 cd 28 22			call macro_dsp_valuehl 
59b9				endm 
# End of macro FORTH_DSP_VALUEHL
59b9			 
59b9			;		push hl    ; u1  
59b9			 
59b9					; destroy value TOS 
59b9			 
59b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59b9 cd e0 22			call macro_forth_dsp_pop 
59bc				endm 
# End of macro FORTH_DSP_POP
59bc			 
59bc					; one value on hl get other one back 
59bc			 
59bc			;		pop hl   ; u2 - addr 
59bc			 
59bc					; TODO Send SPI byte 
59bc			 
59bc			;		push hl 
59bc			;		call spi_ce_low 
59bc			;		pop hl 
59bc 7d					ld a, l 
59bd cd 01 01				call spi_send_byte 
59c0			;		call spi_ce_high 
59c0			 
59c0					NEXTW 
59c0 c3 de 23			jp macro_next 
59c3				endm 
# End of macro NEXTW
59c3			 
59c3			.SPII: 
59c3				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59c3 52				db WORD_SYS_CORE+62             
59c4 2c 5a			dw .SESEL            
59c6 06				db 5 + 1 
59c7 .. 00			db "SPII",0              
59cc				endm 
# End of macro CWHEAD
59cc			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59cc					if DEBUG_FORTH_WORDS_KEY 
59cc						DMARK "SPi" 
59cc f5				push af  
59cd 3a e1 59			ld a, (.dmark)  
59d0 32 a6 fd			ld (debug_mark),a  
59d3 3a e2 59			ld a, (.dmark+1)  
59d6 32 a7 fd			ld (debug_mark+1),a  
59d9 3a e3 59			ld a, (.dmark+2)  
59dc 32 a8 fd			ld (debug_mark+2),a  
59df 18 03			jr .pastdmark  
59e1 ..			.dmark: db "SPi"  
59e4 f1			.pastdmark: pop af  
59e5			endm  
# End of macro DMARK
59e5						CALLMONITOR 
59e5 cd aa fd			call debug_vector  
59e8				endm  
# End of macro CALLMONITOR
59e8					endif 
59e8			 
59e8					; TODO Get SPI byte 
59e8			 
59e8 cd 28 01				call spi_read_byte 
59eb			 
59eb					if DEBUG_FORTH_WORDS 
59eb						DMARK "Si2" 
59eb f5				push af  
59ec 3a 00 5a			ld a, (.dmark)  
59ef 32 a6 fd			ld (debug_mark),a  
59f2 3a 01 5a			ld a, (.dmark+1)  
59f5 32 a7 fd			ld (debug_mark+1),a  
59f8 3a 02 5a			ld a, (.dmark+2)  
59fb 32 a8 fd			ld (debug_mark+2),a  
59fe 18 03			jr .pastdmark  
5a00 ..			.dmark: db "Si2"  
5a03 f1			.pastdmark: pop af  
5a04			endm  
# End of macro DMARK
5a04						CALLMONITOR 
5a04 cd aa fd			call debug_vector  
5a07				endm  
# End of macro CALLMONITOR
5a07					endif 
5a07 26 00				ld h, 0 
5a09 6f					ld l, a 
5a0a					if DEBUG_FORTH_WORDS 
5a0a						DMARK "Si3" 
5a0a f5				push af  
5a0b 3a 1f 5a			ld a, (.dmark)  
5a0e 32 a6 fd			ld (debug_mark),a  
5a11 3a 20 5a			ld a, (.dmark+1)  
5a14 32 a7 fd			ld (debug_mark+1),a  
5a17 3a 21 5a			ld a, (.dmark+2)  
5a1a 32 a8 fd			ld (debug_mark+2),a  
5a1d 18 03			jr .pastdmark  
5a1f ..			.dmark: db "Si3"  
5a22 f1			.pastdmark: pop af  
5a23			endm  
# End of macro DMARK
5a23						CALLMONITOR 
5a23 cd aa fd			call debug_vector  
5a26				endm  
# End of macro CALLMONITOR
5a26					endif 
5a26 cd 23 20				call forth_push_numhl 
5a29			 
5a29					NEXTW 
5a29 c3 de 23			jp macro_next 
5a2c				endm 
# End of macro NEXTW
5a2c			 
5a2c			 
5a2c			 
5a2c			.SESEL: 
5a2c				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a2c 66				db WORD_SYS_CORE+82             
5a2d d5 5a			dw .CARTDEV            
5a2f 05				db 4 + 1 
5a30 .. 00			db "BANK",0              
5a35				endm 
# End of macro CWHEAD
5a35			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a35					if DEBUG_FORTH_WORDS_KEY 
5a35						DMARK "BNK" 
5a35 f5				push af  
5a36 3a 4a 5a			ld a, (.dmark)  
5a39 32 a6 fd			ld (debug_mark),a  
5a3c 3a 4b 5a			ld a, (.dmark+1)  
5a3f 32 a7 fd			ld (debug_mark+1),a  
5a42 3a 4c 5a			ld a, (.dmark+2)  
5a45 32 a8 fd			ld (debug_mark+2),a  
5a48 18 03			jr .pastdmark  
5a4a ..			.dmark: db "BNK"  
5a4d f1			.pastdmark: pop af  
5a4e			endm  
# End of macro DMARK
5a4e						CALLMONITOR 
5a4e cd aa fd			call debug_vector  
5a51				endm  
# End of macro CALLMONITOR
5a51					endif 
5a51			 
5a51 3e ff				ld a, 255 
5a53 32 9e f9				ld (spi_cartdev), a 
5a56			 
5a56					; get bank 
5a56			 
5a56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a56 cd 28 22			call macro_dsp_valuehl 
5a59				endm 
# End of macro FORTH_DSP_VALUEHL
5a59			 
5a59			;		push hl 
5a59			 
5a59					; destroy value TOS 
5a59			 
5a59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a59 cd e0 22			call macro_forth_dsp_pop 
5a5c				endm 
# End of macro FORTH_DSP_POP
5a5c			 
5a5c					; one value on hl get other one back 
5a5c			 
5a5c			;		pop hl 
5a5c			 
5a5c			 
5a5c 0e ff				ld c, SPI_CE_HIGH 
5a5e 06 30				ld b, '0'    ; human readable bank number 
5a60			 
5a60 7d					ld a, l 
5a61			 
5a61					if DEBUG_FORTH_WORDS 
5a61						DMARK "BNK" 
5a61 f5				push af  
5a62 3a 76 5a			ld a, (.dmark)  
5a65 32 a6 fd			ld (debug_mark),a  
5a68 3a 77 5a			ld a, (.dmark+1)  
5a6b 32 a7 fd			ld (debug_mark+1),a  
5a6e 3a 78 5a			ld a, (.dmark+2)  
5a71 32 a8 fd			ld (debug_mark+2),a  
5a74 18 03			jr .pastdmark  
5a76 ..			.dmark: db "BNK"  
5a79 f1			.pastdmark: pop af  
5a7a			endm  
# End of macro DMARK
5a7a						CALLMONITOR 
5a7a cd aa fd			call debug_vector  
5a7d				endm  
# End of macro CALLMONITOR
5a7d					endif 
5a7d			 
5a7d					; active low 
5a7d			 
5a7d fe 00				cp 0 
5a7f 28 28				jr z, .bset 
5a81 fe 01				cp 1 
5a83 20 04				jr nz, .b2 
5a85 cb 81				res 0, c 
5a87 06 31				ld b, '1'    ; human readable bank number 
5a89 fe 02		.b2:		cp 2 
5a8b 20 04				jr nz, .b3 
5a8d cb 89				res 1, c 
5a8f 06 32				ld b, '2'    ; human readable bank number 
5a91 fe 03		.b3:		cp 3 
5a93 20 04				jr nz, .b4 
5a95 cb 91				res 2, c 
5a97 06 33				ld b, '3'    ; human readable bank number 
5a99 fe 04		.b4:		cp 4 
5a9b 20 04				jr nz, .b5 
5a9d cb 99				res 3, c 
5a9f 06 34				ld b, '4'    ; human readable bank number 
5aa1 fe 05		.b5:		cp 5 
5aa3 20 04				jr nz, .bset 
5aa5 cb a1				res 4, c 
5aa7 06 35				ld b, '5'    ; human readable bank number 
5aa9			 
5aa9			.bset: 
5aa9 79					ld a, c 
5aaa 32 9b f9				ld (spi_device),a 
5aad 78					ld a, b 
5aae 32 9a f9				ld (spi_device_id),a 
5ab1					if DEBUG_FORTH_WORDS 
5ab1						DMARK "BN2" 
5ab1 f5				push af  
5ab2 3a c6 5a			ld a, (.dmark)  
5ab5 32 a6 fd			ld (debug_mark),a  
5ab8 3a c7 5a			ld a, (.dmark+1)  
5abb 32 a7 fd			ld (debug_mark+1),a  
5abe 3a c8 5a			ld a, (.dmark+2)  
5ac1 32 a8 fd			ld (debug_mark+2),a  
5ac4 18 03			jr .pastdmark  
5ac6 ..			.dmark: db "BN2"  
5ac9 f1			.pastdmark: pop af  
5aca			endm  
# End of macro DMARK
5aca						CALLMONITOR 
5aca cd aa fd			call debug_vector  
5acd				endm  
# End of macro CALLMONITOR
5acd					endif 
5acd			 
5acd					; set default SPI clk pulse time as disabled for BANK use 
5acd			 
5acd 3e 00				ld a, 0 
5acf 32 9f f9				ld (spi_clktime), a 
5ad2			 
5ad2					NEXTW 
5ad2 c3 de 23			jp macro_next 
5ad5				endm 
# End of macro NEXTW
5ad5			 
5ad5			.CARTDEV: 
5ad5				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ad5 66				db WORD_SYS_CORE+82             
5ad6 83 5b			dw .ENDDEVICE            
5ad8 08				db 7 + 1 
5ad9 .. 00			db "CARTDEV",0              
5ae1				endm 
# End of macro CWHEAD
5ae1			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5ae1					if DEBUG_FORTH_WORDS_KEY 
5ae1						DMARK "CDV" 
5ae1 f5				push af  
5ae2 3a f6 5a			ld a, (.dmark)  
5ae5 32 a6 fd			ld (debug_mark),a  
5ae8 3a f7 5a			ld a, (.dmark+1)  
5aeb 32 a7 fd			ld (debug_mark+1),a  
5aee 3a f8 5a			ld a, (.dmark+2)  
5af1 32 a8 fd			ld (debug_mark+2),a  
5af4 18 03			jr .pastdmark  
5af6 ..			.dmark: db "CDV"  
5af9 f1			.pastdmark: pop af  
5afa			endm  
# End of macro DMARK
5afa						CALLMONITOR 
5afa cd aa fd			call debug_vector  
5afd				endm  
# End of macro CALLMONITOR
5afd					endif 
5afd			 
5afd					; disable se storage bank selection 
5afd			 
5afd 3e ff				ld a, SPI_CE_HIGH		; ce high 
5aff 32 9b f9				ld (spi_device), a 
5b02			 
5b02					; get bank 
5b02			 
5b02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b02 cd 28 22			call macro_dsp_valuehl 
5b05				endm 
# End of macro FORTH_DSP_VALUEHL
5b05			 
5b05			;		push hl 
5b05			 
5b05					; destroy value TOS 
5b05			 
5b05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b05 cd e0 22			call macro_forth_dsp_pop 
5b08				endm 
# End of macro FORTH_DSP_POP
5b08			 
5b08					; one value on hl get other one back 
5b08			 
5b08			;		pop hl 
5b08			 
5b08					; active low 
5b08			 
5b08 0e ff				ld c, 255 
5b0a			 
5b0a 7d					ld a, l 
5b0b					if DEBUG_FORTH_WORDS 
5b0b						DMARK "CDV" 
5b0b f5				push af  
5b0c 3a 20 5b			ld a, (.dmark)  
5b0f 32 a6 fd			ld (debug_mark),a  
5b12 3a 21 5b			ld a, (.dmark+1)  
5b15 32 a7 fd			ld (debug_mark+1),a  
5b18 3a 22 5b			ld a, (.dmark+2)  
5b1b 32 a8 fd			ld (debug_mark+2),a  
5b1e 18 03			jr .pastdmark  
5b20 ..			.dmark: db "CDV"  
5b23 f1			.pastdmark: pop af  
5b24			endm  
# End of macro DMARK
5b24						CALLMONITOR 
5b24 cd aa fd			call debug_vector  
5b27				endm  
# End of macro CALLMONITOR
5b27					endif 
5b27 fe 00				cp 0 
5b29 28 30				jr z, .cset 
5b2b fe 01				cp 1 
5b2d 20 02				jr nz, .c2 
5b2f cb 81				res 0, c 
5b31 fe 02		.c2:		cp 2 
5b33 20 02				jr nz, .c3 
5b35 cb 89				res 1, c 
5b37 fe 03		.c3:		cp 3 
5b39 20 02				jr nz, .c4 
5b3b cb 91				res 2, c 
5b3d fe 04		.c4:		cp 4 
5b3f 20 02				jr nz, .c5 
5b41 cb 99				res 3, c 
5b43 fe 05		.c5:		cp 5 
5b45 20 02				jr nz, .c6 
5b47 cb a1				res 4, c 
5b49 fe 06		.c6:		cp 6 
5b4b 20 02				jr nz, .c7 
5b4d cb a9				res 5, c 
5b4f fe 07		.c7:		cp 7 
5b51 20 02				jr nz, .c8 
5b53 cb b1				res 6, c 
5b55 fe 08		.c8:		cp 8 
5b57 20 02				jr nz, .cset 
5b59 cb b9				res 7, c 
5b5b 79			.cset:		ld a, c 
5b5c 32 9e f9				ld (spi_cartdev),a 
5b5f			 
5b5f					if DEBUG_FORTH_WORDS 
5b5f						DMARK "CD2" 
5b5f f5				push af  
5b60 3a 74 5b			ld a, (.dmark)  
5b63 32 a6 fd			ld (debug_mark),a  
5b66 3a 75 5b			ld a, (.dmark+1)  
5b69 32 a7 fd			ld (debug_mark+1),a  
5b6c 3a 76 5b			ld a, (.dmark+2)  
5b6f 32 a8 fd			ld (debug_mark+2),a  
5b72 18 03			jr .pastdmark  
5b74 ..			.dmark: db "CD2"  
5b77 f1			.pastdmark: pop af  
5b78			endm  
# End of macro DMARK
5b78						CALLMONITOR 
5b78 cd aa fd			call debug_vector  
5b7b				endm  
# End of macro CALLMONITOR
5b7b					endif 
5b7b			 
5b7b					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b7b			 
5b7b 3e 0a				ld a, $0a 
5b7d 32 9f f9				ld (spi_clktime), a 
5b80					NEXTW 
5b80 c3 de 23			jp macro_next 
5b83				endm 
# End of macro NEXTW
5b83			endif 
5b83			 
5b83			.ENDDEVICE: 
5b83			; eof 
5b83			 
# End of file forth_words_device.asm
5b83			 
5b83			; var handler 
5b83			 
5b83			 
5b83			.VARS: 
5b83				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b83 77				db WORD_SYS_CORE+99             
5b84 34 5c			dw .V0            
5b86 04				db 3 + 1 
5b87 .. 00			db "VAR",0              
5b8b				endm 
# End of macro CWHEAD
5b8b			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b8b			;| 
5b8b			;| The variable name should consist of a single letter. e.g. "a" 
5b8b			;! If a full string is passed then only the first char is looked at 
5b8b			;| Any other char could exceed bounds checks!  
5b8b			 
5b8b					if DEBUG_FORTH_WORDS_KEY 
5b8b						DMARK "VAR" 
5b8b f5				push af  
5b8c 3a a0 5b			ld a, (.dmark)  
5b8f 32 a6 fd			ld (debug_mark),a  
5b92 3a a1 5b			ld a, (.dmark+1)  
5b95 32 a7 fd			ld (debug_mark+1),a  
5b98 3a a2 5b			ld a, (.dmark+2)  
5b9b 32 a8 fd			ld (debug_mark+2),a  
5b9e 18 03			jr .pastdmark  
5ba0 ..			.dmark: db "VAR"  
5ba3 f1			.pastdmark: pop af  
5ba4			endm  
# End of macro DMARK
5ba4						CALLMONITOR 
5ba4 cd aa fd			call debug_vector  
5ba7				endm  
# End of macro CALLMONITOR
5ba7					endif 
5ba7			 
5ba7					FORTH_DSP_VALUEHL 
5ba7 cd 28 22			call macro_dsp_valuehl 
5baa				endm 
# End of macro FORTH_DSP_VALUEHL
5baa			 
5baa 7e					ld a, (hl)    ; get first char on of the string 
5bab			 
5bab			 
5bab					if DEBUG_FORTH_WORDS 
5bab						DMARK "VR1" 
5bab f5				push af  
5bac 3a c0 5b			ld a, (.dmark)  
5baf 32 a6 fd			ld (debug_mark),a  
5bb2 3a c1 5b			ld a, (.dmark+1)  
5bb5 32 a7 fd			ld (debug_mark+1),a  
5bb8 3a c2 5b			ld a, (.dmark+2)  
5bbb 32 a8 fd			ld (debug_mark+2),a  
5bbe 18 03			jr .pastdmark  
5bc0 ..			.dmark: db "VR1"  
5bc3 f1			.pastdmark: pop af  
5bc4			endm  
# End of macro DMARK
5bc4						CALLMONITOR 
5bc4 cd aa fd			call debug_vector  
5bc7				endm  
# End of macro CALLMONITOR
5bc7					endif 
5bc7					 
5bc7 f5					push af	 
5bc8					FORTH_DSP_POP 
5bc8 cd e0 22			call macro_forth_dsp_pop 
5bcb				endm 
# End of macro FORTH_DSP_POP
5bcb f1					pop af 
5bcc			 
5bcc					; convert to upper 
5bcc			 
5bcc cd 44 12				call to_upper 
5bcf					if DEBUG_FORTH_WORDS 
5bcf						DMARK "Vaa" 
5bcf f5				push af  
5bd0 3a e4 5b			ld a, (.dmark)  
5bd3 32 a6 fd			ld (debug_mark),a  
5bd6 3a e5 5b			ld a, (.dmark+1)  
5bd9 32 a7 fd			ld (debug_mark+1),a  
5bdc 3a e6 5b			ld a, (.dmark+2)  
5bdf 32 a8 fd			ld (debug_mark+2),a  
5be2 18 03			jr .pastdmark  
5be4 ..			.dmark: db "Vaa"  
5be7 f1			.pastdmark: pop af  
5be8			endm  
# End of macro DMARK
5be8						CALLMONITOR 
5be8 cd aa fd			call debug_vector  
5beb				endm  
# End of macro CALLMONITOR
5beb					endif 
5beb 06 41				ld b, 'A' 
5bed 90					sub b			; set offset 
5bee					if DEBUG_FORTH_WORDS 
5bee						DMARK "Vbb" 
5bee f5				push af  
5bef 3a 03 5c			ld a, (.dmark)  
5bf2 32 a6 fd			ld (debug_mark),a  
5bf5 3a 04 5c			ld a, (.dmark+1)  
5bf8 32 a7 fd			ld (debug_mark+1),a  
5bfb 3a 05 5c			ld a, (.dmark+2)  
5bfe 32 a8 fd			ld (debug_mark+2),a  
5c01 18 03			jr .pastdmark  
5c03 ..			.dmark: db "Vbb"  
5c06 f1			.pastdmark: pop af  
5c07			endm  
# End of macro DMARK
5c07						CALLMONITOR 
5c07 cd aa fd			call debug_vector  
5c0a				endm  
# End of macro CALLMONITOR
5c0a					endif 
5c0a cb 27				sla a  
5c0c				 
5c0c					 
5c0c					if DEBUG_FORTH_WORDS 
5c0c						DMARK "VR2" 
5c0c f5				push af  
5c0d 3a 21 5c			ld a, (.dmark)  
5c10 32 a6 fd			ld (debug_mark),a  
5c13 3a 22 5c			ld a, (.dmark+1)  
5c16 32 a7 fd			ld (debug_mark+1),a  
5c19 3a 23 5c			ld a, (.dmark+2)  
5c1c 32 a8 fd			ld (debug_mark+2),a  
5c1f 18 03			jr .pastdmark  
5c21 ..			.dmark: db "VR2"  
5c24 f1			.pastdmark: pop af  
5c25			endm  
# End of macro DMARK
5c25						CALLMONITOR 
5c25 cd aa fd			call debug_vector  
5c28				endm  
# End of macro CALLMONITOR
5c28					endif 
5c28			 
5c28 21 2f f9				ld hl, cli_var_array2 
5c2b cd cf 0f				call addatohl 
5c2e cd 23 20				call forth_push_numhl 
5c31			 
5c31			 
5c31				       NEXTW 
5c31 c3 de 23			jp macro_next 
5c34				endm 
# End of macro NEXTW
5c34			.V0: 
5c34				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c34 78				db WORD_SYS_CORE+100             
5c35 4c 5c			dw .V0Q            
5c37 04				db 3 + 1 
5c38 .. 00			db "V0!",0              
5c3c				endm 
# End of macro CWHEAD
5c3c			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c3c			 
5c3c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c3c cd 28 22			call macro_dsp_valuehl 
5c3f				endm 
# End of macro FORTH_DSP_VALUEHL
5c3f			 
5c3f 11 63 f9				ld de, cli_var_array 
5c42			 
5c42 eb					ex de, hl 
5c43 73					ld (hl), e 
5c44 23					inc hl 
5c45 72					ld (hl), d 
5c46			 
5c46					; destroy value TOS 
5c46			 
5c46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c46 cd e0 22			call macro_forth_dsp_pop 
5c49				endm 
# End of macro FORTH_DSP_POP
5c49			 
5c49				       NEXTW 
5c49 c3 de 23			jp macro_next 
5c4c				endm 
# End of macro NEXTW
5c4c			.V0Q: 
5c4c				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c4c 79				db WORD_SYS_CORE+101             
5c4d 5d 5c			dw .V1S            
5c4f 04				db 3 + 1 
5c50 .. 00			db "V0@",0              
5c54				endm 
# End of macro CWHEAD
5c54			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c54 2a 63 f9				ld hl, (cli_var_array) 
5c57 cd 23 20				call forth_push_numhl 
5c5a			 
5c5a				       NEXTW 
5c5a c3 de 23			jp macro_next 
5c5d				endm 
# End of macro NEXTW
5c5d			.V1S: 
5c5d				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c5d 7a				db WORD_SYS_CORE+102             
5c5e 75 5c			dw .V1Q            
5c60 04				db 3 + 1 
5c61 .. 00			db "V1!",0              
5c65				endm 
# End of macro CWHEAD
5c65			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c65 cd 28 22			call macro_dsp_valuehl 
5c68				endm 
# End of macro FORTH_DSP_VALUEHL
5c68			 
5c68 11 65 f9				ld de, cli_var_array+2 
5c6b				 
5c6b eb					ex de, hl 
5c6c 73					ld (hl), e 
5c6d 23					inc hl 
5c6e 72					ld (hl), d 
5c6f			 
5c6f					; destroy value TOS 
5c6f			 
5c6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c6f cd e0 22			call macro_forth_dsp_pop 
5c72				endm 
# End of macro FORTH_DSP_POP
5c72				       NEXTW 
5c72 c3 de 23			jp macro_next 
5c75				endm 
# End of macro NEXTW
5c75			.V1Q: 
5c75				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c75 7b				db WORD_SYS_CORE+103             
5c76 86 5c			dw .V2S            
5c78 04				db 3 + 1 
5c79 .. 00			db "V1@",0              
5c7d				endm 
# End of macro CWHEAD
5c7d			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c7d 2a 65 f9				ld hl, (cli_var_array+2) 
5c80 cd 23 20				call forth_push_numhl 
5c83				       NEXTW 
5c83 c3 de 23			jp macro_next 
5c86				endm 
# End of macro NEXTW
5c86			.V2S: 
5c86				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c86 7c				db WORD_SYS_CORE+104             
5c87 9e 5c			dw .V2Q            
5c89 04				db 3 + 1 
5c8a .. 00			db "V2!",0              
5c8e				endm 
# End of macro CWHEAD
5c8e			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c8e cd 28 22			call macro_dsp_valuehl 
5c91				endm 
# End of macro FORTH_DSP_VALUEHL
5c91			 
5c91 11 67 f9				ld de, cli_var_array+4 
5c94				 
5c94 eb					ex de, hl 
5c95 73					ld (hl), e 
5c96 23					inc hl 
5c97 72					ld (hl), d 
5c98			 
5c98					; destroy value TOS 
5c98			 
5c98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c98 cd e0 22			call macro_forth_dsp_pop 
5c9b				endm 
# End of macro FORTH_DSP_POP
5c9b				       NEXTW 
5c9b c3 de 23			jp macro_next 
5c9e				endm 
# End of macro NEXTW
5c9e			.V2Q: 
5c9e				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5c9e 7d				db WORD_SYS_CORE+105             
5c9f af 5c			dw .V3S            
5ca1 04				db 3 + 1 
5ca2 .. 00			db "V2@",0              
5ca6				endm 
# End of macro CWHEAD
5ca6			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5ca6 2a 67 f9				ld hl, (cli_var_array+4) 
5ca9 cd 23 20				call forth_push_numhl 
5cac				       NEXTW 
5cac c3 de 23			jp macro_next 
5caf				endm 
# End of macro NEXTW
5caf			.V3S: 
5caf				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5caf 7c				db WORD_SYS_CORE+104             
5cb0 c7 5c			dw .V3Q            
5cb2 04				db 3 + 1 
5cb3 .. 00			db "V3!",0              
5cb7				endm 
# End of macro CWHEAD
5cb7			;| V3! ( u1 -- )  Store value to v3 | DONE 
5cb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cb7 cd 28 22			call macro_dsp_valuehl 
5cba				endm 
# End of macro FORTH_DSP_VALUEHL
5cba			 
5cba 11 69 f9				ld de, cli_var_array+6 
5cbd				 
5cbd eb					ex de, hl 
5cbe 73					ld (hl), e 
5cbf 23					inc hl 
5cc0 72					ld (hl), d 
5cc1			 
5cc1					; destroy value TOS 
5cc1			 
5cc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cc1 cd e0 22			call macro_forth_dsp_pop 
5cc4				endm 
# End of macro FORTH_DSP_POP
5cc4				       NEXTW 
5cc4 c3 de 23			jp macro_next 
5cc7				endm 
# End of macro NEXTW
5cc7			.V3Q: 
5cc7				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cc7 7d				db WORD_SYS_CORE+105             
5cc8 d8 5c			dw .END            
5cca 04				db 3 + 1 
5ccb .. 00			db "V3@",0              
5ccf				endm 
# End of macro CWHEAD
5ccf			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5ccf 2a 69 f9				ld hl, (cli_var_array+6) 
5cd2 cd 23 20				call forth_push_numhl 
5cd5				       NEXTW 
5cd5 c3 de 23			jp macro_next 
5cd8				endm 
# End of macro NEXTW
5cd8			 
5cd8			 
5cd8			 
5cd8			 
5cd8			 
5cd8			; end of dict marker 
5cd8			 
5cd8 00			.END:    db WORD_SYS_END 
5cd9 00 00			dw 0 
5cdb 00				db 0 
5cdc			 
5cdc			; use to jp here for user dict words to save on macro expansion  
5cdc			 
5cdc			user_dict_next: 
5cdc				NEXTW 
5cdc c3 de 23			jp macro_next 
5cdf				endm 
# End of macro NEXTW
5cdf			 
5cdf			 
5cdf			user_exec: 
5cdf				;    ld hl, <word code> 
5cdf				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cdf				;    call forthexec 
5cdf				;    jp user_dict_next   (NEXT) 
5cdf			        ;    <word code bytes> 
5cdf eb				ex de, hl 
5ce0 2a fd f3			ld hl,(os_tok_ptr) 
5ce3				 
5ce3				FORTH_RSP_NEXT 
5ce3 cd ca 1f			call macro_forth_rsp_next 
5ce6				endm 
# End of macro FORTH_RSP_NEXT
5ce6			 
5ce6			if DEBUG_FORTH_UWORD 
5ce6						DMARK "UEX" 
5ce6 f5				push af  
5ce7 3a fb 5c			ld a, (.dmark)  
5cea 32 a6 fd			ld (debug_mark),a  
5ced 3a fc 5c			ld a, (.dmark+1)  
5cf0 32 a7 fd			ld (debug_mark+1),a  
5cf3 3a fd 5c			ld a, (.dmark+2)  
5cf6 32 a8 fd			ld (debug_mark+2),a  
5cf9 18 03			jr .pastdmark  
5cfb ..			.dmark: db "UEX"  
5cfe f1			.pastdmark: pop af  
5cff			endm  
# End of macro DMARK
5cff				CALLMONITOR 
5cff cd aa fd			call debug_vector  
5d02				endm  
# End of macro CALLMONITOR
5d02			endif 
5d02			 
5d02			 
5d02			 
5d02 eb				ex de, hl 
5d03 22 fd f3			ld (os_tok_ptr), hl 
5d06				 
5d06				; Don't use next - Skips the first word in uword. 
5d06			 
5d06 c3 6f 24			jp exec1 
5d09			;	NEXT 
5d09			 
5d09			 
5d09			; eof 
# End of file forth_wordsv4.asm
5d09			endif 
5d09			;;;;;;;;;;;;;; Debug code 
5d09			 
5d09			 
5d09			;if DEBUG_FORTH_PARSE 
5d09 .. 00		.nowordfound: db "No match",0 
5d12 .. 00		.compword:	db "Comparing word ",0 
5d22 .. 00		.nextwordat:	db "Next word at",0 
5d2f .. 00		.charmatch:	db "Char match",0 
5d3a			;endif 
5d3a			if DEBUG_FORTH_JP 
5d3a			.foundword:	db "Word match. Exec..",0 
5d3a			endif 
5d3a			;if DEBUG_FORTH_PUSH 
5d3a .. 00		.enddict:	db "Dict end. Push.",0 
5d4a .. 00		.push_str:	db "Pushing string",0 
5d59 .. 00		.push_num:	db "Pushing number",0 
5d68 .. 00		.data_sp:	db "SP:",0 
5d6c .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d7e .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d90 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5da2			;endif 
5da2			;if DEBUG_FORTH_MALLOC 
5da2 .. 00		.push_malloc:	db "Malloc address",0 
5db1			;endif 
5db1			 
5db1			 
5db1			 
5db1			; display malloc address and current data stack pointer  
5db1			 
5db1			malloc_error: 
5db1 d5				push de 
5db2 f5				push af 
5db3 e5				push hl 
5db4 cd 9b 0d			call clear_display 
5db7 11 d7 5d			ld de, .mallocerr 
5dba 3e 00			ld a,0 
5dbc			;	ld de,os_word_scratch 
5dbc cd ae 0d			call str_at_display 
5dbf 3e 11			ld a, display_row_1+17 
5dc1 11 a6 fd			ld de, debug_mark 
5dc4 cd ae 0d			call str_at_display 
5dc7 cd be 0d			call update_display 
5dca				;call break_point_state 
5dca cd 9e 72			call cin_wait 
5dcd			 
5dcd			;	ld a, ' ' 
5dcd			;	ld (os_view_disable), a 
5dcd cd 38 19			call bp_on 
5dd0 e1				pop hl 
5dd1 f1				pop af 
5dd2 d1				pop de	 
5dd3				CALLMONITOR 
5dd3 cd aa fd			call debug_vector  
5dd6				endm  
# End of macro CALLMONITOR
5dd6 c9				ret 
5dd7			 
5dd7 .. 00		.mallocerr: 	db "Malloc Error",0 
5de4			;if DEBUG_FORTH_PUSH 
5de4			display_data_sp: 
5de4 f5				push af 
5de5			 
5de5				; see if disabled 
5de5			 
5de5			 
5de5 3a aa fd			ld a, (debug_vector) 
5de8 fe c9			cp $C9  ; RET 
5dea				;ld a, (os_view_disable) 
5dea				;cp '*' 
5dea 28 67			jr z, .skipdsp 
5dec			 
5dec e5				push hl 
5ded e5				push hl 
5dee e5			push hl 
5def cd 9b 0d			call clear_display 
5df2 e1			pop hl 
5df3 7c				ld a,h 
5df4 21 01 f4			ld hl, os_word_scratch 
5df7 cd d8 11			call hexout 
5dfa e1				pop hl 
5dfb 7d				ld a,l 
5dfc 21 03 f4			ld hl, os_word_scratch+2 
5dff cd d8 11			call hexout 
5e02 21 05 f4			ld hl, os_word_scratch+4 
5e05 3e 00			ld a,0 
5e07 77				ld (hl),a 
5e08 11 01 f4			ld de,os_word_scratch 
5e0b 3e 28				ld a, display_row_2 
5e0d cd ae 0d				call str_at_display 
5e10 11 6c 5d			ld de, .wordinhl 
5e13 3e 00			ld a, display_row_1 
5e15			 
5e15 cd ae 0d				call str_at_display 
5e18 11 a6 fd			ld de, debug_mark 
5e1b 3e 11			ld a, display_row_1+17 
5e1d			 
5e1d cd ae 0d				call str_at_display 
5e20			 
5e20				; display current data stack pointer 
5e20 11 68 5d			ld de,.data_sp 
5e23 3e 30				ld a, display_row_2 + 8 
5e25 cd ae 0d				call str_at_display 
5e28			 
5e28 2a 29 f9			ld hl,(cli_data_sp) 
5e2b e5				push hl 
5e2c 7c				ld a,h 
5e2d 21 01 f4			ld hl, os_word_scratch 
5e30 cd d8 11			call hexout 
5e33 e1				pop hl 
5e34 7d				ld a,l 
5e35 21 03 f4			ld hl, os_word_scratch+2 
5e38 cd d8 11			call hexout 
5e3b 21 05 f4			ld hl, os_word_scratch+4 
5e3e 3e 00			ld a,0 
5e40 77				ld (hl),a 
5e41 11 01 f4			ld de,os_word_scratch 
5e44 3e 33				ld a, display_row_2 + 11 
5e46 cd ae 0d				call str_at_display 
5e49			 
5e49			 
5e49 cd be 0d			call update_display 
5e4c cd de 0c			call delay1s 
5e4f cd de 0c			call delay1s 
5e52 e1				pop hl 
5e53			.skipdsp: 
5e53 f1				pop af 
5e54 c9				ret 
5e55			 
5e55			display_data_malloc: 
5e55			 
5e55 f5				push af 
5e56 e5				push hl 
5e57 e5				push hl 
5e58 e5			push hl 
5e59 cd 9b 0d			call clear_display 
5e5c e1			pop hl 
5e5d 7c				ld a,h 
5e5e 21 01 f4			ld hl, os_word_scratch 
5e61 cd d8 11			call hexout 
5e64 e1				pop hl 
5e65 7d				ld a,l 
5e66 21 03 f4			ld hl, os_word_scratch+2 
5e69 cd d8 11			call hexout 
5e6c 21 05 f4			ld hl, os_word_scratch+4 
5e6f 3e 00			ld a,0 
5e71 77				ld (hl),a 
5e72 11 01 f4			ld de,os_word_scratch 
5e75 3e 28				ld a, display_row_2 
5e77 cd ae 0d				call str_at_display 
5e7a 11 a2 5d			ld de, .push_malloc 
5e7d 3e 00			ld a, display_row_1 
5e7f			 
5e7f cd ae 0d				call str_at_display 
5e82			 
5e82				; display current data stack pointer 
5e82 11 68 5d			ld de,.data_sp 
5e85 3e 30				ld a, display_row_2 + 8 
5e87 cd ae 0d				call str_at_display 
5e8a			 
5e8a 2a 29 f9			ld hl,(cli_data_sp) 
5e8d e5				push hl 
5e8e 7c				ld a,h 
5e8f 21 01 f4			ld hl, os_word_scratch 
5e92 cd d8 11			call hexout 
5e95 e1				pop hl 
5e96 7d				ld a,l 
5e97 21 03 f4			ld hl, os_word_scratch+2 
5e9a cd d8 11			call hexout 
5e9d 21 05 f4			ld hl, os_word_scratch+4 
5ea0 3e 00			ld a,0 
5ea2 77				ld (hl),a 
5ea3 11 01 f4			ld de,os_word_scratch 
5ea6 3e 33				ld a, display_row_2 + 11 
5ea8 cd ae 0d				call str_at_display 
5eab			 
5eab cd be 0d			call update_display 
5eae cd de 0c			call delay1s 
5eb1 cd de 0c			call delay1s 
5eb4 e1				pop hl 
5eb5 f1				pop af 
5eb6 c9				ret 
5eb7			;endif 
5eb7			 
5eb7			include "forth_autostart.asm" 
5eb7			; list of commands to perform at system start up 
5eb7			 
5eb7			startcmds: 
5eb7			;	dw test11 
5eb7			;	dw test12 
5eb7			;	dw test13 
5eb7			;	dw test14 
5eb7			;	dw test15 
5eb7			;	dw test16 
5eb7			;	dw test17 
5eb7			;	dw ifthtest1 
5eb7			;	dw ifthtest2 
5eb7			;	dw ifthtest3 
5eb7			;	dw mmtest1 
5eb7			;	dw mmtest2 
5eb7			;	dw mmtest3 
5eb7			;	dw mmtest4 
5eb7			;	dw mmtest5 
5eb7			;	dw mmtest6 
5eb7			;	dw iftest1 
5eb7			;	dw iftest2 
5eb7			;	dw iftest3 
5eb7			;	dw looptest1 
5eb7			;	dw looptest2 
5eb7			;	dw test1 
5eb7			;	dw test2 
5eb7			;	dw test3 
5eb7			;	dw test4 
5eb7			;	dw game2r 
5eb7			;	dw game2b1 
5eb7			;	dw game2b2 
5eb7			 
5eb7				; start up words that are actually useful 
5eb7			 
5eb7			;    dw spi1 
5eb7			;    dw spi2 
5eb7			;    dw spi3 
5eb7			;    dw spi4 
5eb7			;    dw spi5 
5eb7			;    dw spi6 
5eb7			;    dw spi7 
5eb7			; 
5eb7			;    dw spi8 
5eb7			;    dw spi9 
5eb7			;    dw spi10 
5eb7			 
5eb7			; file editor 
5eb7			;	dw edit1 
5eb7			;	dw edit2 
5eb7			;	dw edit3 
5eb7			 
5eb7			;	dw longread 
5eb7 d7 62			dw clrstack 
5eb9 0b 63			dw type 
5ebb			;	dw stest 
5ebb 30 63			dw strncpy 
5ebd			;	dw list 
5ebd 91 63			dw start1 
5ebf a1 63			dw start2 
5ec1			;	dw start3 
5ec1			;	dw start3b 
5ec1			;	dw start3c 
5ec1			 
5ec1				; (unit) testing words 
5ec1			 
5ec1			;	dw mtesta 
5ec1			;	dw mtestb 
5ec1			;	dw mtestc 
5ec1			;	dw mtestd 
5ec1			;	dw mteste 
5ec1			 
5ec1				; demo/game words 
5ec1			 
5ec1			;        dw game3w 
5ec1			;        dw game3p 
5ec1			;        dw game3sc 
5ec1			;        dw game3vsi 
5ec1			;        dw game3vs 
5ec1				 
5ec1			;	dw game2b 
5ec1			;	dw game2bf 
5ec1			;	dw game2mba 
5ec1			;	dw game2mbas 
5ec1			;	dw game2mb 
5ec1			 
5ec1 be 66			dw game1 
5ec3 cf 66			dw game1a 
5ec5 31 67			dw game1b 
5ec7 66 67			dw game1c 
5ec9 9c 67			dw game1d 
5ecb cd 67			dw game1s 
5ecd e1 67			dw game1t 
5ecf f6 67			dw game1f 
5ed1 2a 68			dw game1z 
5ed3 6e 68			dw game1zz 
5ed5			 
5ed5 f7 64			dw test5 
5ed7 2f 65			dw test6 
5ed9 67 65			dw test7 
5edb 7b 65			dw test8 
5edd a7 65			dw test9 
5edf bd 65			dw test10 
5ee1				 
5ee1 45 69		        dw ssv5 
5ee3 29 69		        dw ssv4 
5ee5 0d 69		        dw ssv3 
5ee7 d7 68		        dw ssv2 
5ee9 5e 69		        dw ssv1 
5eeb a6 69		        dw ssv1cpm 
5eed			;	dw keyup 
5eed			;	dw keydown 
5eed			;	dw keyleft 
5eed			;	dw keyright 
5eed			;	dw 	keyf1 
5eed			;	dw keyf2 
5eed			;	dw keyf3 
5eed			;	dw keyf4 
5eed			;	dw keyf5 
5eed			;	dw keyf6 
5eed			;	dw keyf7 
5eed			;	dw keyf8 
5eed			;	dw keyf9 
5eed			;	dw keyf10 
5eed			;	dw keyf11 
5eed			;	dw keyf12 
5eed			;	dw keytab 
5eed			;	dw keycr 
5eed			;	dw keyhome 
5eed			;	dw keyend 
5eed			;	dw keybs 
5eed 00 00			db 0, 0	 
5eef			 
5eef			 
5eef			; File Editor 
5eef			 
5eef			; ( id - ) use 'e' to edit the displayed line 
5eef .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f10 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f45			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f45 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f7d			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f7d			 
5f7d			; SPI Net support words 
5f7d			 
5f7d			; v0! = node to send to 
5f7d			; ( str count - ) 
5f7d .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5fd6			 
5fd6			; spiputc ( char node - ) 
5fd6 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
600a			; spiputc ( u node - ) 
600a .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6038			 
6038			; spigetc ( - n ) 
6038 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6061			 
6061			; getnode ( - n ) 
6061 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
608e			 
608e			; ( str node - )  
608e .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
60f4			; store string ( str i - ) 
60f4			 
60f4			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
60f4 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6149			 
6149			; get string ( addr i -  )    TO FIX 
6149			 
6149 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61a1			 
61a1			 
61a1			; NETCHAT (TODO) 
61a1			; Program to allow two nodes to chat with eachother 
61a1			; 
61a1			; v0 - target node 
61a1			;  
61a1			; accept input at 0,0 
61a1			; if input is string send spitype to target node 
61a1			; starting at row 2,0 , while spigetchr is not zero ->  
61a1			; 
61a1			; 
61a1			; TODO add paging of get request 
61a1			 
61a1			; ( node - ) 
61a1 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61c0 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6218 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6290			 
6290			 
6290			; Long read of currently open file 
6290 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62d7			 
62d7			; clear stack  
62d7			 
62d7 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
630b			 
630b			; type ( addr count - ) 
630b .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6330			 
6330			; some direct memory words 
6330			; strncpy ( len t f -- t ) 
6330			 
6330 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6391			 
6391 .. 00		start1:     	db ": bpon $00 bp ;",0 
63a1 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63b2 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
642d .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
648d			 
648d			 
648d			; a handy word to list items on the stack 
648d			 
648d .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
64f7			 
64f7			 
64f7			; test stack  
64f7			; rnd8 stest 
64f7			 
64f7			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
64f7			 
64f7			; random malloc and free cycles 
64f7			 
64f7			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
64f7			 
64f7			; fixed malloc and free cycles 
64f7			 
64f7			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
64f7			 
64f7			; fixed double string push and drop cycle  
64f7			 
64f7			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
64f7			 
64f7			; consistent fixed string push and drop cycle  
64f7			 
64f7			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
64f7			 
64f7			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
64f7			 
64f7			;test1:		db ": aa 1 2 3 ;", 0 
64f7			;test2:     	db "111 aa 888 999",0 
64f7			;test3:     	db ": bb 77 ;",0 
64f7			;test4:     	db "$02 $01 do i . loop bb",0 
64f7			 
64f7 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
652f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6567 .. 00		test7:     	db ": box hline vline ;",0 
657b .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
65a7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
65bd .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
65e2			;test11:     	db "hello create .",0 
65e2			;test12:     	db "hello2 create .",0 
65e2			 
65e2			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
65e2			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
65e2			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
65e2			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
65e2			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
65e2			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
65e2			 
65e2			;iftest1:     	db "$0001 IF cls .",0 
65e2			;iftest2:     	db "$0000 IF cls .",0 
65e2			;iftest3:     	db "$0002 $0003 - IF cls .",0 
65e2			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
65e2			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
65e2			 
65e2			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65e2			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65e2			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65e2			 
65e2			 
65e2 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6606 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6636 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
665b .. 00		sound4: db ": cha $00 ; ",0 
6668 .. 00		sound5: db ": chb $20 ; ",0 
6675 .. 00		sound6: db ": chc $40 ; ",0 
6682 .. 00		sound7: db ": chd $60 ; ",0 
668f .. 00		sound8: db ": cnote $80 + + note ; ", 0 
66a7 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
66be			 
66be			 
66be			 
66be			 
66be			; a small guess the number game 
66be			 
66be .. 00		game1:          db ": gsn rnd8 v1! ;",0 
66cf .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6731			 
6731 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6766 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
679c .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
67cd .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
67e1 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
67f6 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
682a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
686e			 
686e			; Using 'ga' save a high score across multiple runs using external storage 
686e			 
686e .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
68d7			 
68d7			 
68d7			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
68d7			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
68d7			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
68d7			 
68d7			; simple screen saver to test code memory reuse to destruction 
68d7			 
68d7 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
690d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6929 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6945 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
695e .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
69a6 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
69fd			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
69fd			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
69fd			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
69fd			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
69fd			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
69fd			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
69fd			 
69fd			 
69fd			 
69fd			; minesweeper/battleship finding game 
69fd			; draws a game board of random ship/mine positions 
69fd			; user enters coords to see if it hits on 
69fd			; game ends when all are hit 
69fd			; when hit or miss says how many may be in the area 
69fd			 
69fd			; setup the game board and then hide it 
69fd			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
69fd			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
69fd			;; prompt for where to target 
69fd			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
69fd			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
69fd			;; TODO see if the entered coords hits or misses pushes char hit of miss 
69fd			;game2mbht:      db ": mbckht nop ;",0 
69fd			;game2mbms:      db ": mbcms nop ;",0 
69fd			; TODO how many might be near by 
69fd			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
69fd			 
69fd			; Game 3 
69fd			 
69fd			; Vert scroller ski game - avoid the trees! 
69fd			 
69fd			; v0 score (ie turns) 
69fd			; v1 player pos 
69fd			; v2 left wall 
69fd			; v3 right wall 
69fd			 
69fd			; Draw side walls randomly 
69fd			 
69fd			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
69fd			 
69fd			; Draw player 
69fd			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
69fd			 
69fd			; TODO Get Key 
69fd			 
69fd			; TODO Move left right 
69fd			 
69fd			; scroll and move walls a bit 
69fd			 
69fd			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
69fd			 
69fd			; main game loop 
69fd			 
69fd			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
69fd			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
69fd			 
69fd			; key board defs 
69fd			 
69fd .. 00		keyup:       db ": keyup $05 ;",0 
6a0b .. 00		keydown:       db ": keydown $0a ;",0 
6a1b .. 00		keyleft:       db ": keyleft $0b ;",0 
6a2b .. 00		keyright:       db ": keyright $0c ;",0 
6a3c .. 00		keyf1:       db ": keyf1 $10 ;",0 
6a4a .. 00		keyf2:       db ": keyf2 $11 ;",0 
6a58 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6a66 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6a74 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6a82 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6a90 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6a9e .. 00		keyf8:       db ": keyf8 $17 ;",0 
6aac .. 00		keyf9:       db ": keyf9 $18 ;",0 
6aba .. 00		keyf10:       db ": keyf10 $19 ;",0 
6ac9 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6ad8 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6ae7			 
6ae7 .. 00		keytab:       db ": keytab $09 ;",0 
6af6 .. 00		keycr:       db ": keycr $0d ;",0 
6b04 .. 00		keyhome:       db ": keyhome $0e ;",0 
6b14 .. 00		keyend:       db ": keyend $0f ;",0 
6b23 .. 00		keybs:       db ": keybs $08 ;",0 
6b31			 
6b31			   
6b31			 
6b31			 
6b31			 
6b31			; eof 
# End of file forth_autostart.asm
6b31			 
6b31			 
6b31			 
6b31			; stack over and underflow checks 
6b31			 
6b31			; init the words to detect the under/overflow 
6b31			 
6b31			chk_stk_init: 
6b31				; a vague random number to check so we dont get any "lucky" hits 
6b31 3e 2d			ld a, 45 
6b33 6f				ld l, a 
6b34 00				nop 
6b35 3e 17			ld a, 23 
6b37 67				ld h, a 
6b38			 
6b38 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
6b3b			 
6b3b			;	ld (chk_stund), hl	; stack points.... 
6b3b 22 3b fe			ld (chk_stovr), hl 
6b3e 22 27 f9			ld (chk_ret_und), hl 
6b41 22 e5 f8			ld (chk_ret_ovr), hl 
6b44 22 63 f8			ld (chk_loop_ovr), hl 
6b47 22 61 f6			ld (chk_data_ovr), hl 
6b4a c9				ret 
6b4b				 
6b4b			check_stacks: 
6b4b				; check all stack words 
6b4b			 
6b4b e5				push hl 
6b4c d5				push de 
6b4d			 
6b4d			;	ld de,(chk_word) 
6b4d			;	ld hl, (chk_stund)	; stack points.... 
6b4d			;	if DEBUG_STK_FAULT 
6b4d			;		DMARK "FAa" 
6b4d			;		CALLMONITOR 
6b4d			;	endif 
6b4d			;	call cmp16 
6b4d			;	jp z, .chk_faulta 
6b4d			; 
6b4d			;	ld de, sfaultsu 
6b4d			;	jp .chk_fault 
6b4d			 
6b4d 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6b50 ed 5b d8 f0		ld de,(chk_word) 
6b54				if DEBUG_STK_FAULT 
6b54					DMARK "FAb" 
6b54					CALLMONITOR 
6b54				endif 
6b54 cd ed 0f			call cmp16 
6b57 28 06			jr z, .chk_fault1 
6b59 11 fa 6b			ld de, sfaultso 
6b5c c3 ae 6b			jp .chk_fault 
6b5f			.chk_fault1:  
6b5f 2a 27 f9			ld hl, (chk_ret_und) 
6b62 ed 5b d8 f0		ld de,(chk_word) 
6b66				if DEBUG_STK_FAULT 
6b66					DMARK "FAU" 
6b66					CALLMONITOR 
6b66				endif 
6b66 cd ed 0f			call cmp16 
6b69 ca 72 6b			jp z, .chk_fault2 
6b6c 11 0a 6c			ld de, sfaultru 
6b6f c3 ae 6b			jp .chk_fault 
6b72			.chk_fault2:  
6b72 2a e5 f8			ld hl, (chk_ret_ovr) 
6b75 ed 5b d8 f0		ld de,(chk_word) 
6b79				if DEBUG_STK_FAULT 
6b79					DMARK "FA1" 
6b79					CALLMONITOR 
6b79				endif 
6b79 cd ed 0f			call cmp16 
6b7c ca 85 6b			jp z, .chk_fault3 
6b7f 11 18 6c			ld de, sfaultro 
6b82 c3 ae 6b			jp .chk_fault 
6b85			.chk_fault3:  
6b85 2a 63 f8			ld hl, (chk_loop_ovr) 
6b88 ed 5b d8 f0		ld de,(chk_word) 
6b8c				if DEBUG_STK_FAULT 
6b8c					DMARK "FA2" 
6b8c					CALLMONITOR 
6b8c				endif 
6b8c cd ed 0f			call cmp16 
6b8f ca 98 6b			jp z, .chk_fault4 
6b92 11 32 6c			ld de, sfaultlo 
6b95 c3 ae 6b			jp .chk_fault 
6b98			.chk_fault4:  
6b98 2a 61 f6			ld hl, (chk_data_ovr) 
6b9b ed 5b d8 f0		ld de,(chk_word) 
6b9f				if DEBUG_STK_FAULT 
6b9f					DMARK "FA3" 
6b9f					CALLMONITOR 
6b9f				endif 
6b9f cd ed 0f			call cmp16 
6ba2 ca ab 6b			jp z, .chk_fault5 
6ba5 11 4c 6c			ld de, sfaultdo 
6ba8 c3 ae 6b			jp .chk_fault 
6bab			 
6bab			 
6bab			.chk_fault5:  
6bab d1				pop de 
6bac e1				pop hl 
6bad			 
6bad c9				ret 
6bae			 
6bae cd 9b 0d		.chk_fault: 	call clear_display 
6bb1 3e 28				ld a, display_row_2 
6bb3 cd ae 0d				call str_at_display 
6bb6 11 dc 6b				   ld de, .stackfault 
6bb9 3e 00				ld a, display_row_1 
6bbb cd ae 0d				call str_at_display 
6bbe 11 a6 fd				    ld de, debug_mark 
6bc1 3e 11				ld a, display_row_1+17 
6bc3 cd ae 0d				call str_at_display 
6bc6 cd be 0d				call update_display 
6bc9			 
6bc9				; prompt before entering montior for investigating issue 
6bc9			 
6bc9 3e 78			ld a, display_row_4 
6bcb 11 15 1d			ld de, endprog 
6bce			 
6bce cd be 0d			call update_display		 
6bd1			 
6bd1 cd 9b 1f			call next_page_prompt 
6bd4			 
6bd4 d1				pop de 
6bd5 e1				pop hl 
6bd6 cd 69 1d				call monitor 
6bd9 c3 5f 1c				jp warmstart 
6bdc					;jp 0 
6bdc					;halt 
6bdc			 
6bdc			 
6bdc			 
6bdc .. 00		.stackfault: 	db "Stack fault:",0 
6be9			 
6be9 .. 00		sfaultsu: 	db	"Stack under flow",0 
6bfa .. 00		sfaultso: 	db	"Stack over flow",0 
6c0a .. 00		sfaultru:	db "RTS underflow",0 
6c18 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6c32 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6c4c .. 00		sfaultdo:	db "DTS overflow", 0 
6c59			 
6c59			 
6c59			fault_dsp_under: 
6c59 11 6b 6c			ld de, .dsp_under 
6c5c c3 1b 6d			jp .show_fault 
6c5f			 
6c5f			fault_rsp_under: 
6c5f 11 79 6c			ld de, .rsp_under 
6c62 c3 1b 6d			jp .show_fault 
6c65			fault_loop_under: 
6c65 11 87 6c			ld de, .loop_under 
6c68 c3 1b 6d			jp .show_fault 
6c6b			 
6c6b .. 00		.dsp_under: db "DSP Underflow",0 
6c79 .. 00		.rsp_under: db "RSP Underflow",0 
6c87 .. 00		.loop_under: db "LOOP Underflow",0 
6c96			 
6c96			 
6c96 d5			type_faultn: 	push de 
6c97 e5					push hl 
6c98 cd 9b 0d				call clear_display 
6c9b 11 c2 6c				   ld de, .typefaultn 
6c9e 3e 00				ld a, display_row_1 
6ca0 cd ae 0d				call str_at_display 
6ca3 11 a6 fd				    ld de, debug_mark 
6ca6 3e 11				ld a, display_row_1+17 
6ca8 cd ae 0d				call str_at_display 
6cab cd be 0d				call update_display 
6cae			 
6cae				; prompt before entering montior for investigating issue 
6cae			 
6cae 3e 78			ld a, display_row_4 
6cb0 11 15 1d			ld de, endprog 
6cb3			 
6cb3 cd be 0d			call update_display		 
6cb6			 
6cb6 cd 9b 1f			call next_page_prompt 
6cb9			 
6cb9 e5					push hl 
6cba d5					push de 
6cbb cd 69 1d				call monitor 
6cbe c3 5f 1c				jp warmstart 
6cc1 76					halt 
6cc2			 
6cc2			 
6cc2 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6cd9			 
6cd9 d5			type_faults: 	push de 
6cda e5					push hl 
6cdb cd 9b 0d				call clear_display 
6cde 11 04 6d				   ld de, .typefaults 
6ce1 3e 00				ld a, display_row_1 
6ce3 cd ae 0d				call str_at_display 
6ce6 11 a6 fd				    ld de, debug_mark 
6ce9 3e 11				ld a, display_row_1+17 
6ceb cd ae 0d				call str_at_display 
6cee cd be 0d				call update_display 
6cf1			 
6cf1				; prompt before entering montior for investigating issue 
6cf1			 
6cf1 3e 78			ld a, display_row_4 
6cf3 11 15 1d			ld de, endprog 
6cf6			 
6cf6 cd be 0d			call update_display		 
6cf9			 
6cf9 cd 9b 1f			call next_page_prompt 
6cfc			 
6cfc e1					pop hl 
6cfd d1					pop de 
6cfe cd 69 1d				call monitor 
6d01 c3 5f 1c				jp warmstart 
6d04			 
6d04			 
6d04 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6d1b			 
6d1b			.show_fault: 	 
6d1b d5					push de 
6d1c cd 9b 0d				call clear_display 
6d1f d1					pop de 
6d20 3e 00				ld a, display_row_1 
6d22 cd ae 0d				call str_at_display 
6d25 11 a6 fd				    ld de, debug_mark 
6d28 3e 11				ld a, display_row_1+17 
6d2a cd ae 0d				call str_at_display 
6d2d cd be 0d				call update_display 
6d30			 
6d30				; prompt before entering montior for investigating issue 
6d30			 
6d30 3e 78			ld a, display_row_4 
6d32 11 15 1d			ld de, endprog 
6d35			 
6d35 cd be 0d			call update_display		 
6d38			 
6d38 cd 9b 1f			call next_page_prompt 
6d3b			 
6d3b e1					pop hl 
6d3c d1					pop de 
6d3d cd 69 1d				call monitor 
6d40			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6d40			; TODO Make optional fault restart to cli or warm boot? 
6d40					;jp warmstart 
6d40 c3 a9 1c				jp cli 
6d43 76					halt 
6d44			 
6d44			; handle the auto run of code from files in storage 
6d44			 
6d44			 
6d44			include "forth_startup.asm" 
6d44			; Which startup method to use? 
6d44			; 
6d44			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6d44			; followed by loading of a list of scripts in eeprom 
6d44			 
6d44			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6d44			; from eeprom 
6d44			 
6d44			; Select with define in main stubs 
6d44			 
6d44			if STARTUP_V1 
6d44				include "forth_startupv1.asm" 
6d44			endif 
6d44			if STARTUP_V2 
6d44				include "forth_startupv2.asm" 
6d44			; Version 2 of the startup  
6d44			;  
6d44			; Auto load any files in bank 1 that start with a '*' 
6d44			; If no se storage then revert to using eprom 
6d44			 
6d44			 
6d44			if STORAGE_SE = 0 
6d44			 
6d44			sprompt1: db "Startup load...",0 
6d44			sprompt2: db "Run? 1=No *=End #=All",0 
6d44			 
6d44			 
6d44			 
6d44			 
6d44			forth_startup: 
6d44				ld hl, startcmds 
6d44				ld a, 0 
6d44				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6d44			 
6d44			.start1:	push hl 
6d44				call clear_display 
6d44				ld de, sprompt1 
6d44			        ld a, display_row_1 
6d44				call str_at_display 
6d44				ld de, sprompt2 
6d44			        ld a, display_row_2 
6d44				call str_at_display 
6d44				pop hl 
6d44				push hl 
6d44				ld e,(hl) 
6d44				inc hl 
6d44				ld d,(hl) 
6d44			        ld a, display_row_3 
6d44				call str_at_display 
6d44				call update_display 
6d44			 
6d44			 
6d44				ld a, (os_last_cmd) 
6d44				cp 0 
6d44				jr z, .startprompt 
6d44				call delay250ms 
6d44				jr .startdo 
6d44				 
6d44				 
6d44			 
6d44			.startprompt: 
6d44			 
6d44				ld a,display_row_4 + display_cols - 1 
6d44			        ld de, endprg 
6d44				call str_at_display 
6d44				call update_display 
6d44				call delay1s 
6d44				call cin_wait 
6d44						 
6d44				cp '*' 
6d44				jr z, .startupend1 
6d44				cp '#' 
6d44				jr nz, .startno 
6d44				ld a, 1 
6d44				ld (os_last_cmd),a 
6d44				jr .startdo 
6d44			.startno:	cp '1' 
6d44				jr z,.startnxt  
6d44			 
6d44				; exec startup line 
6d44			.startdo:	 
6d44				pop hl 
6d44				push hl 
6d44				 
6d44				ld e,(hl) 
6d44				inc hl 
6d44				ld d,(hl) 
6d44				ex de,hl 
6d44			 
6d44				push hl 
6d44			 
6d44				ld a, 0 
6d44				;ld a, FORTH_END_BUFFER 
6d44				call strlent 
6d44				inc hl   ; include zero term to copy 
6d44				ld b,0 
6d44				ld c,l 
6d44				pop hl 
6d44				ld de, scratch 
6d44				ldir 
6d44			 
6d44			 
6d44				ld hl, scratch 
6d44				call forthparse 
6d44				call forthexec 
6d44				call forthexec_cleanup 
6d44			 
6d44				ld a, display_row_4 
6d44				ld de, endprog 
6d44			 
6d44				call update_display		 
6d44			 
6d44				ld a, (os_last_cmd) 
6d44				cp 0 
6d44				jr nz, .startnxt 
6d44				call next_page_prompt 
6d44			        call clear_display 
6d44				call update_display		 
6d44			 
6d44				; move onto next startup line? 
6d44			.startnxt: 
6d44			 
6d44				call delay250ms 
6d44				pop hl 
6d44			 
6d44				inc hl 
6d44				inc hl 
6d44			 
6d44				push hl 
6d44				ld e, (hl) 
6d44				inc hl 
6d44				ld d, (hl) 
6d44				pop hl 
6d44				; TODO replace 0 test 
6d44			 
6d44				ex de, hl 
6d44				call ishlzero 
6d44			;	ld a,e 
6d44			;	add d 
6d44			;	cp 0    ; any left to do? 
6d44				ex de, hl 
6d44				jp nz, .start1 
6d44				jr .startupend 
6d44			 
6d44			.startupend1: pop hl 
6d44			.startupend: 
6d44			 
6d44				call clear_display 
6d44				call update_display 
6d44				ret 
6d44			endif 
6d44			 
6d44			 
6d44			if STORAGE_SE 
6d44			 
6d44			;sprompt3: db "Loading from start-up file:",0 
6d44 .. 00		sprompt3: db "  Searching...",0 
6d53			;sprompt4: db "(Any key to stop)",0 
6d53			 
6d53			 
6d53			forth_autoload: 
6d53			 
6d53				; load block 0 of store 1 
6d53				 
6d53 3e fe			ld a, $fe      ; bit 0 clear 
6d55 32 9b f9			ld (spi_device), a 
6d58			 
6d58 cd 16 05			call storage_get_block_0 
6d5b			 
6d5b 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
6d5e			 
6d5e fe 00			cp 0 
6d60 c8				ret z     ; auto start not enabled 
6d61			 
6d61 cd 9b 0d			call clear_display 
6d64			 
6d64				; set bank 
6d64			 
6d64 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
6d67 32 9b f9				ld (spi_device), a 
6d6a			 
6d6a			 
6d6a				; generate a directory of bank 1 and search for flagged files 
6d6a			 
6d6a					if DEBUG_FORTH_WORDS_KEY 
6d6a						DMARK "DIR" 
6d6a f5				push af  
6d6b 3a 7f 6d			ld a, (.dmark)  
6d6e 32 a6 fd			ld (debug_mark),a  
6d71 3a 80 6d			ld a, (.dmark+1)  
6d74 32 a7 fd			ld (debug_mark+1),a  
6d77 3a 81 6d			ld a, (.dmark+2)  
6d7a 32 a8 fd			ld (debug_mark+2),a  
6d7d 18 03			jr .pastdmark  
6d7f ..			.dmark: db "DIR"  
6d82 f1			.pastdmark: pop af  
6d83			endm  
# End of macro DMARK
6d83						CALLMONITOR 
6d83 cd aa fd			call debug_vector  
6d86				endm  
# End of macro CALLMONITOR
6d86					endif 
6d86			 
6d86 cd 16 05			call storage_get_block_0 
6d89			 
6d89 21 b5 f9			ld hl, store_page     ; get current id count 
6d8c 46				ld b, (hl) 
6d8d 0e 00			ld c, 0    ; count of files   
6d8f					if DEBUG_FORTH_WORDS 
6d8f						DMARK "DI1" 
6d8f f5				push af  
6d90 3a a4 6d			ld a, (.dmark)  
6d93 32 a6 fd			ld (debug_mark),a  
6d96 3a a5 6d			ld a, (.dmark+1)  
6d99 32 a7 fd			ld (debug_mark+1),a  
6d9c 3a a6 6d			ld a, (.dmark+2)  
6d9f 32 a8 fd			ld (debug_mark+2),a  
6da2 18 03			jr .pastdmark  
6da4 ..			.dmark: db "DI1"  
6da7 f1			.pastdmark: pop af  
6da8			endm  
# End of macro DMARK
6da8						CALLMONITOR 
6da8 cd aa fd			call debug_vector  
6dab				endm  
# End of macro CALLMONITOR
6dab					endif 
6dab			 
6dab				; check for empty drive 
6dab			 
6dab 3e 00			ld a, 0 
6dad b8				cp b 
6dae ca fb 6d			jp z, .dirdone 
6db1			 
6db1				; for each of the current ids do a search for them and if found push to stack 
6db1			 
6db1 c5			.diritem:	push bc 
6db2 21 40 00				ld hl, STORE_BLOCK_PHY 
6db5 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
6db7 58					ld e,b 
6db8			 
6db8 d5					push de 
6db9 e5					push hl 
6dba cd 9b 0d			call clear_display 
6dbd 3e 32			ld a, display_row_2 + 10 
6dbf 11 44 6d			ld de, sprompt3 
6dc2 cd ae 0d			call str_at_display 
6dc5 cd f2 0c			call active 
6dc8 eb				ex de, hl 
6dc9 3e 2f			ld a, display_row_2 + 7 
6dcb cd ae 0d			call str_at_display 
6dce cd be 0d			call update_display 
6dd1 e1				pop hl 
6dd2 d1				pop de 
6dd3			 
6dd3			;		if DEBUG_FORTH_WORDS 
6dd3			;			DMARK "DI2" 
6dd3			;			CALLMONITOR 
6dd3			;		endif 
6dd3			 
6dd3 cd 98 07				call storage_findnextid 
6dd6			 
6dd6			;		if DEBUG_FORTH_WORDS 
6dd6			;			DMARK "DI3" 
6dd6			;			CALLMONITOR 
6dd6			;		endif 
6dd6			 
6dd6					; if found hl will be non zero 
6dd6			 
6dd6 cd f8 0f				call ishlzero 
6dd9			;		ld a, l 
6dd9			;		add h 
6dd9			; 
6dd9			;		cp 0 
6dd9 28 1d				jr z, .dirnotfound 
6ddb			 
6ddb					; increase count 
6ddb			 
6ddb c1					pop bc	 
6ddc 0c					inc c 
6ddd c5					push bc 
6dde					 
6dde			 
6dde					; get file header and push the file name 
6dde			 
6dde 11 b5 f9				ld de, store_page 
6de1 cd 65 04				call storage_read_block 
6de4			 
6de4					; push file id to stack 
6de4				 
6de4			 
6de4					; is this a file we want to run? 
6de4			 
6de4 21 b8 f9				ld hl, store_page+3 
6de7 7e					ld a,(hl) 
6de8 fe 2a				cp '*' 
6dea 20 0c				jr nz,  .dirnotfound 
6dec					 
6dec			 
6dec			 
6dec 3a b5 f9				ld a, (store_page) 
6def d5					push de 
6df0 e5					push hl 
6df1 c5					push bc 
6df2 cd 1e 6e				call .autorunf 
6df5 c1					pop bc 
6df6 e1					pop hl 
6df7 d1					pop de 
6df8			 
6df8			 
6df8			 
6df8				; save this extent 
6df8			 
6df8					; push file name 
6df8			;display file name to run 
6df8			 
6df8			;		ld hl, store_page+3 
6df8			;		if DEBUG_FORTH_WORDS 
6df8			;			DMARK "DI5" 
6df8			;			CALLMONITOR 
6df8			;		endif 
6df8			; 
6df8			;		 
6df8			; 
6df8			;		call forth_push_str 
6df8			;		if DEBUG_FORTH_WORDS 
6df8			;			DMARK "DI6" 
6df8			;			CALLMONITOR 
6df8			;		endif 
6df8			.dirnotfound: 
6df8 c1					pop bc     
6df9 10 b6				djnz .diritem 
6dfb				 
6dfb			.dirdone:	 
6dfb					if DEBUG_FORTH_WORDS 
6dfb						DMARK "DI7" 
6dfb f5				push af  
6dfc 3a 10 6e			ld a, (.dmark)  
6dff 32 a6 fd			ld (debug_mark),a  
6e02 3a 11 6e			ld a, (.dmark+1)  
6e05 32 a7 fd			ld (debug_mark+1),a  
6e08 3a 12 6e			ld a, (.dmark+2)  
6e0b 32 a8 fd			ld (debug_mark+2),a  
6e0e 18 03			jr .pastdmark  
6e10 ..			.dmark: db "DI7"  
6e13 f1			.pastdmark: pop af  
6e14			endm  
# End of macro DMARK
6e14						CALLMONITOR 
6e14 cd aa fd			call debug_vector  
6e17				endm  
# End of macro CALLMONITOR
6e17					endif 
6e17			 
6e17 cd 9b 0d				call clear_display 
6e1a cd be 0d				call update_display 
6e1d			 
6e1d c9					ret 
6e1e			 
6e1e			 
6e1e			 
6e1e			 
6e1e			 
6e1e			.autorunf: 
6e1e			 
6e1e			 
6e1e				; get file id to load from and get the file name to display 
6e1e			 
6e1e			;		ld a, (store_page+STORE_0_FILERUN) 
6e1e			 
6e1e 2e 00				ld l, 0 
6e20 67					ld h, a 
6e21 11 b5 f9				ld de, store_page 
6e24			 
6e24					if DEBUG_FORTH_WORDS 
6e24						DMARK "ASp" 
6e24 f5				push af  
6e25 3a 39 6e			ld a, (.dmark)  
6e28 32 a6 fd			ld (debug_mark),a  
6e2b 3a 3a 6e			ld a, (.dmark+1)  
6e2e 32 a7 fd			ld (debug_mark+1),a  
6e31 3a 3b 6e			ld a, (.dmark+2)  
6e34 32 a8 fd			ld (debug_mark+2),a  
6e37 18 03			jr .pastdmark  
6e39 ..			.dmark: db "ASp"  
6e3c f1			.pastdmark: pop af  
6e3d			endm  
# End of macro DMARK
6e3d						CALLMONITOR 
6e3d cd aa fd			call debug_vector  
6e40				endm  
# End of macro CALLMONITOR
6e40					endif 
6e40 cd be 09				call storage_read 
6e43			 
6e43					if DEBUG_FORTH_WORDS 
6e43						DMARK "ASr" 
6e43 f5				push af  
6e44 3a 58 6e			ld a, (.dmark)  
6e47 32 a6 fd			ld (debug_mark),a  
6e4a 3a 59 6e			ld a, (.dmark+1)  
6e4d 32 a7 fd			ld (debug_mark+1),a  
6e50 3a 5a 6e			ld a, (.dmark+2)  
6e53 32 a8 fd			ld (debug_mark+2),a  
6e56 18 03			jr .pastdmark  
6e58 ..			.dmark: db "ASr"  
6e5b f1			.pastdmark: pop af  
6e5c			endm  
# End of macro DMARK
6e5c						CALLMONITOR 
6e5c cd aa fd			call debug_vector  
6e5f				endm  
# End of macro CALLMONITOR
6e5f					endif 
6e5f			 
6e5f cd f8 0f				call ishlzero 
6e62 c8					ret z             ; file not found 
6e63			 
6e63					; display file name we are loading 
6e63			 
6e63 cd 9b 0d				call clear_display 
6e66			 
6e66 3e 32				ld a, display_row_2 + 10 
6e68 11 b8 f9				ld de, store_page+3 
6e6b cd ae 0d				call str_at_display 
6e6e				 
6e6e			; 
6e6e			 
6e6e			;	ld a, display_row_1+5 
6e6e			;	ld de, sprompt3 
6e6e			;	call str_at_display 
6e6e			;	ld a, display_row_2+7 
6e6e			;	call active 
6e6e			;	ex de, hl 
6e6e			;;	ld de, sprompt4 
6e6e			;	call str_at_display 
6e6e			; 
6e6e cd be 0d			call update_display 
6e71			 
6e71			;	call cin_wait 
6e71			;	cp 'n' 
6e71			;	ret z 
6e71			;	cp 'N' 
6e71			;	ret z 
6e71			 
6e71			;	call delay1s 
6e71			 
6e71 3a b7 f9			ld a, (store_page+2) 
6e74 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
6e77 3e 01			ld a, 1  
6e79 32 a5 f9			ld (store_openext), a    ; save count of ext 
6e7c			 
6e7c			.autof: 
6e7c				; begin to read a line from file 
6e7c			 
6e7c 21 23 f4			ld hl, os_cli_cmd 
6e7f 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
6e82			  
6e82			.readext: 
6e82 3a a5 f9			ld a, (store_openext) 
6e85 6f				ld l , a 
6e86				 
6e86 3a b5 f9			ld a, (store_page) 
6e89 67				ld h, a	 
6e8a 11 b5 f9			ld de, store_page 
6e8d					if DEBUG_FORTH_WORDS 
6e8d						DMARK "ASl" 
6e8d f5				push af  
6e8e 3a a2 6e			ld a, (.dmark)  
6e91 32 a6 fd			ld (debug_mark),a  
6e94 3a a3 6e			ld a, (.dmark+1)  
6e97 32 a7 fd			ld (debug_mark+1),a  
6e9a 3a a4 6e			ld a, (.dmark+2)  
6e9d 32 a8 fd			ld (debug_mark+2),a  
6ea0 18 03			jr .pastdmark  
6ea2 ..			.dmark: db "ASl"  
6ea5 f1			.pastdmark: pop af  
6ea6			endm  
# End of macro DMARK
6ea6						CALLMONITOR 
6ea6 cd aa fd			call debug_vector  
6ea9				endm  
# End of macro CALLMONITOR
6ea9					endif 
6ea9 cd be 09				call storage_read 
6eac cd f8 0f			call ishlzero 
6eaf c8				ret z 
6eb0			 
6eb0			; TODO copy to exec buffer 
6eb0			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6eb0			 
6eb0				; copy the record buffer to the cli buffer 
6eb0			 
6eb0 ed 5b 21 f6		ld de, (os_var_array) 
6eb4 21 b7 f9			ld hl, store_page+2 
6eb7			;	ex de, hl 
6eb7 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
6eba ed b0			ldir 
6ebc ed 53 21 f6		ld (os_var_array), de 
6ec0				 
6ec0 3a a5 f9			ld a, (store_openext) 
6ec3 3c				inc a 
6ec4 32 a5 f9			ld (store_openext), a    ; save count of ext 
6ec7			 
6ec7			 
6ec7			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6ec7				 
6ec7 3a a8 f9			ld a, (store_readcont) 
6eca fe 00			cp 0 
6ecc 20 b4			jr nz, .readext 
6ece			 
6ece			;	jr z, .autoend 
6ece			 
6ece					if DEBUG_FORTH_WORDS 
6ece						DMARK "ASc" 
6ece f5				push af  
6ecf 3a e3 6e			ld a, (.dmark)  
6ed2 32 a6 fd			ld (debug_mark),a  
6ed5 3a e4 6e			ld a, (.dmark+1)  
6ed8 32 a7 fd			ld (debug_mark+1),a  
6edb 3a e5 6e			ld a, (.dmark+2)  
6ede 32 a8 fd			ld (debug_mark+2),a  
6ee1 18 03			jr .pastdmark  
6ee3 ..			.dmark: db "ASc"  
6ee6 f1			.pastdmark: pop af  
6ee7			endm  
# End of macro DMARK
6ee7						CALLMONITOR 
6ee7 cd aa fd			call debug_vector  
6eea				endm  
# End of macro CALLMONITOR
6eea					endif 
6eea e5				push hl	 
6eeb d5				push de 
6eec cd f2 0c			call active 
6eef eb				ex de, hl 
6ef0 3e 2f			ld a, display_row_2 + 7 
6ef2 cd ae 0d			call str_at_display 
6ef5			 
6ef5 cd be 0d			call update_display 
6ef8 d1				pop de  
6ef9 e1				pop hl 
6efa			;	call delay250ms 
6efa			 
6efa			 
6efa			 
6efa			 
6efa			.autoexec: 
6efa			 
6efa			 
6efa 21 23 f4			ld hl, os_cli_cmd 
6efd					if DEBUG_FORTH_WORDS 
6efd						DMARK "ASx" 
6efd f5				push af  
6efe 3a 12 6f			ld a, (.dmark)  
6f01 32 a6 fd			ld (debug_mark),a  
6f04 3a 13 6f			ld a, (.dmark+1)  
6f07 32 a7 fd			ld (debug_mark+1),a  
6f0a 3a 14 6f			ld a, (.dmark+2)  
6f0d 32 a8 fd			ld (debug_mark+2),a  
6f10 18 03			jr .pastdmark  
6f12 ..			.dmark: db "ASx"  
6f15 f1			.pastdmark: pop af  
6f16			endm  
# End of macro DMARK
6f16						CALLMONITOR 
6f16 cd aa fd			call debug_vector  
6f19				endm  
# End of macro CALLMONITOR
6f19					endif 
6f19 cd 2c 24			call forthparse 
6f1c cd 6c 24			call forthexec 
6f1f cd 7e 23			call forthexec_cleanup 
6f22			 
6f22			 
6f22			 
6f22 c3 7c 6e			jp .autof 
6f25			;.autofdone: 
6f25			; 
6f25			;		if DEBUG_FORTH_WORDS 
6f25			;			DMARK "ASx" 
6f25			;			CALLMONITOR 
6f25			;		endif 
6f25			;;	call clear_display 
6f25			;	ret 
6f25			 
6f25			 
6f25			 
6f25			endif 
# End of file forth_startupv2.asm
6f25			endif 
6f25			 
# End of file forth_startup.asm
6f25			 
6f25			; eof 
# End of file forth_kernel.asm
6f25			;include "nascombasic.asm" 
6f25			 
6f25			 
6f25			; find out where the code ends if loaded into RAM (for SC114) 
6f25			;endofcode:  
6f25			;	nop 
6f25			 
6f25			 
6f25			; jump to nmi vector 
6f25			 
6f25			init_nmi: 
6f25 3e c9			ld a, $c9   ; RET 
6f27 32 ad fd			ld (nmi_vector), a 
6f2a c9				ret 
6f2b			nmi: 
6f2b e5				push hl 
6f2c d5				push de 
6f2d c5				push bc 
6f2e f5				push af 
6f2f cd ad fd			call nmi_vector 
6f32 f5				push af 
6f33 c5				push bc 
6f34 d5				push de 
6f35 e5				push hl 
6f36 ed 4d			reti 
6f38			 
6f38			 
6f38			; eof 
6f38			 
# End of file main.asm
6f38			include "firmware_lcd_4x40.asm" 
6f38			; **********************************************************************  
6f38			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6f38			; **********************************************************************  
6f38			;  
6f38			; **  Written as a Small Computer Monitor App  
6f38			; **  www.scc.me.uk  
6f38			;  
6f38			; History  
6f38			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6f38			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6f38			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6f38			;  
6f38			; **********************************************************************  
6f38			;  
6f38			; This program is an example of one of the methods of interfacing an   
6f38			; alphanumeric LCD module.   
6f38			;  
6f38			; In this example the display is connected to either a Z80 PIO or a   
6f38			; simple 8-bit output port.   
6f38			;  
6f38			; This interfacing method uses 4-bit data mode and uses time delays  
6f38			; rather than polling the display's ready status. As a result the   
6f38			; interface only requires 6 simple output lines:  
6f38			;   Output bit 0 = not used  
6f38			;   Output bit 1 = not used  
6f38			;   Output bit 2 = RS         High = data, Low = instruction  
6f38			;   Output bit 3 = E          Active high  
6f38			;   Output bit 4 = DB4  
6f38			;   Output bit 5 = DB5  
6f38			;   Output bit 6 = DB6  
6f38			;   Output bit 7 = DB7  
6f38			; Display's R/W is connected to 0v so it is always in write mode  
6f38			;  
6f38			; This set up should work with any system supporting the RC2014 bus  
6f38			  
6f38			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6f38			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6f38			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6f38			;  
6f38			; **********************************************************************  
6f38			  
6f38			; Additonal for 4x40. E1 and E2 instead of just E   
6f38			; TODO swipe vidout signal on port a to activate E2  
6f38			  
6f38			; **********************************************************************  
6f38			; **  Constants  
6f38			; **********************************************************************  
6f38			; LCD constants required by LCD support module  
6f38			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6f38			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6f38			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6f38			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6f38			; TODO Decide which E is being set  
6f38			kLCDWidth:  EQU display_cols             ;Width in characters  
6f38			  
6f38			; **********************************************************************  
6f38			; **  Code library usage  
6f38			; **********************************************************************  
6f38			  
6f38			; send character to current cursor position  
6f38			; wraps and/or scrolls screen automatically  
6f38			  
6f38			  
6f38			  
6f38			lcd_init:  
6f38			  
6f38			; SCMonAPI functions used  
6f38			  
6f38			; Alphanumeric LCD functions used  
6f38			; no need to specify specific functions for this module  
6f38			  
6f38 3e cf		            LD   A, 11001111b  
6f3a d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6f3c 3e 00		            LD   A, 00000000b  
6f3e d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6f40			  
6f40			; Initialise alphanumeric LCD module  
6f40 3e 00				ld a, 0  
6f42 32 06 fb				ld (display_lcde1e2), a  
6f45 cd c6 6f		            CALL fLCD_Init      ;Initialise LCD module  
6f48 3e 01				ld a, 1  
6f4a 32 06 fb				ld (display_lcde1e2), a  
6f4d cd c6 6f		            CALL fLCD_Init      ;Initialise LCD module  
6f50			  
6f50 c9				ret  
6f51			  
6f51			;  
6f51			;;  
6f51			; lcd functions  
6f51			;  
6f51			;  
6f51			  
6f51			; what is at cursor position   
6f51			  
6f51			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6f51			;		call curptr  
6f51			;		ret  
6f51			  
6f51			  
6f51			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6f51			  
6f51			curptr:  
6f51 c5				push bc  
6f52 21 ec fc			ld hl, display_fb0  
6f55			cpr:	  
6f55				; loop for cursor whole row  
6f55 0e 28			ld c, display_cols  
6f57 23			cpr1:	inc hl  
6f58 0d				dec c  
6f59 20 fc			jr nz, cpr1  
6f5b 05				dec b  
6f5c 20 f7			jr nz, cpr  
6f5e			  
6f5e				; add col	  
6f5e			  
6f5e 23			cpr2:	inc hl  
6f5f 1d				dec e  
6f60 20 fc			jr nz, cpr2  
6f62			  
6f62 c1				pop bc  
6f63 c9				ret  
6f64				  
6f64			  
6f64			  
6f64			  
6f64			  
6f64			; write the frame buffer given in hl to hardware   
6f64 22 04 fb		write_display: ld (display_write_tmp), hl 	   
6f67 3e 00			ld a, kLCD_Line1  
6f69 cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f6c 06 28			ld b, display_cols  
6f6e ed 5b 04 fb		ld de, (display_write_tmp)  
6f72 cd be 6f			call write_len_string  
6f75				  
6f75				  
6f75 2a 04 fb			ld hl, (display_write_tmp)  
6f78 11 28 00			ld de, display_cols  
6f7b 19				add hl,de  
6f7c 22 04 fb			ld (display_write_tmp),hl  
6f7f			  
6f7f				  
6f7f 3e 28			ld a, kLCD_Line2  
6f81 cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f84 06 28			ld b, display_cols  
6f86 ed 5b 04 fb		ld de, (display_write_tmp)  
6f8a cd be 6f			call write_len_string  
6f8d				  
6f8d 2a 04 fb			ld hl, (display_write_tmp)  
6f90 11 28 00			ld de, display_cols  
6f93 19				add hl,de  
6f94 22 04 fb			ld (display_write_tmp),hl  
6f97			  
6f97				  
6f97 3e 50			ld a, kLCD_Line3  
6f99 cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f9c 06 28			ld b, display_cols  
6f9e ed 5b 04 fb		ld de, (display_write_tmp)  
6fa2 cd be 6f			call write_len_string  
6fa5				  
6fa5 2a 04 fb			ld hl, (display_write_tmp)  
6fa8 11 28 00			ld de, display_cols  
6fab 19				add hl,de  
6fac 22 04 fb			ld (display_write_tmp),hl  
6faf			  
6faf				  
6faf 3e 78			ld a, kLCD_Line4  
6fb1 cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6fb4 06 28			ld b, display_cols  
6fb6 ed 5b 04 fb		ld de, (display_write_tmp)  
6fba cd be 6f			call write_len_string  
6fbd c9					ret  
6fbe				  
6fbe				; write out a fixed length string given in b from de  
6fbe			  
6fbe 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6fbf cd 2b 70		            CALL fLCD_Data      ;Write character to display  
6fc2 13				inc de  
6fc3 10 f9			djnz write_len_string  
6fc5 c9				ret  
6fc6			  
6fc6			; Some other things to do  
6fc6			;            LD   A, kLCD_Clear ;Display clear  
6fc6			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6fc6			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6fc6			;            LD   A, kLCD_On     ;Display on with no cursor  
6fc6			;            ;LD   A, kLCD_Off   ;Display off  
6fc6			;            CALL fLCD_Inst      ;Send instruction to display  
6fc6			;  
6fc6			;  
6fc6			;            halt  
6fc6			;  
6fc6			;  
6fc6			;MsgHello:   DB  "Hello World!",0  
6fc6			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6fc6			  
6fc6			; Custom characters 5 pixels wide by 8 pixels high  
6fc6			; Up to 8 custom characters can be defined  
6fc6			;BitMaps:      
6fc6			;; Character 0x00 = Battery icon  
6fc6			;            DB  01110b  
6fc6			;            DB  11011b  
6fc6			;            DB  10001b  
6fc6			;            DB  10001b  
6fc6			;            DB  11111b  
6fc6			;            DB  11111b  
6fc6			;            DB  11111b  
6fc6			;            DB  11111b  
6fc6			;; Character 0x01 = Bluetooth icon  
6fc6			;            DB  01100b  
6fc6			;            DB  01010b  
6fc6			;            DB  11100b  
6fc6			;            DB  01000b  
6fc6			;            DB  11100b  
6fc6			;            DB  01010b  
6fc6			;            DB  01100b  
6fc6			;            DB  00000b  
6fc6			;  
6fc6			  
6fc6			  
6fc6			; **********************************************************************  
6fc6			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6fc6			; **********************************************************************  
6fc6			;  
6fc6			; **  Written as a Small Computer Monitor App   
6fc6			; **  Version 0.1 SCC 2018-05-16  
6fc6			; **  www.scc.me.uk  
6fc6			;  
6fc6			; **********************************************************************  
6fc6			;  
6fc6			; This module provides support for alphanumeric LCD modules using with  
6fc6			; *  HD44780 (or compatible) controller  
6fc6			; *  5 x 7 pixel fonts  
6fc6			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6fc6			; *  Interface via six digital outputs to the display (see below)  
6fc6			;  
6fc6			; LCD module pinout:  
6fc6			;   1  Vss   0v supply  
6fc6			;   2  Vdd   5v supply  
6fc6			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6fc6			;   4  RS    High = data, Low = instruction  
6fc6			;   5  R/W   High = Read, Low = Write  
6fc6			;   6  E     Enable signal (active high)  
6fc6			;   7  DB0   Data bit 0  
6fc6			;   8  DB1   Data bit 1  
6fc6			;   9  DB2   Data bit 2  
6fc6			;  10  DB3   Data bit 3  
6fc6			;  11  DB4   Data bit 4  
6fc6			;  12  DB5   Data bit 5  
6fc6			;  13  DB6   Data bit 6  
6fc6			;  14  DB7   Data bit 7  
6fc6			;  15  A     Backlight anode (+)  
6fc6			;  16  K     Backlight cathode (-)  
6fc6			;  
6fc6			; This interfacing method uses 4-bit data mode and uses time delays  
6fc6			; rather than polling the display's ready status. As a result the   
6fc6			; interface only requires 6 simple output lines:  
6fc6			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6fc6			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6fc6			;   LCD DB4 = Microcomputer output port bit 4  
6fc6			;   LCD DB5 = Microcomputer output port bit 5  
6fc6			;   LCD DB6 = Microcomputer output port bit 6  
6fc6			;   LCD DB7 = Microcomputer output port bit 7  
6fc6			; Display's R/W is connected to 0v so it is always in write mode  
6fc6			; All 6 connections must be on the same port address <kLCDPrt>  
6fc6			; This method also allows a decent length of cable from micro to LCD  
6fc6			;  
6fc6			; **********************************************************************  
6fc6			;  
6fc6			; To include the code for any given function provided by this module,   
6fc6			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6fc6			; the parent source file.  
6fc6			; For example:  #REQUIRES   uHexPrefix  
6fc6			;  
6fc6			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6fc6			; in the parent source file.  
6fc6			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6fc6			;  
6fc6			; These are the function names provided by this module:  
6fc6			; fLCD_Init                     ;Initialise LCD  
6fc6			; fLCD_Inst                     ;Send instruction to LCD  
6fc6			; fLCD_Data                     ;Send data byte to LCD  
6fc6			; fLCD_Pos                      ;Position cursor  
6fc6			; fLCD_Str                      ;Display string  
6fc6			; fLCD_Def                      ;Define custom character  
6fc6			;  
6fc6			; **********************************************************************  
6fc6			;  
6fc6			; Requires SCMonAPI.asm to also be included in the project  
6fc6			;  
6fc6			  
6fc6			  
6fc6			; **********************************************************************  
6fc6			; **  Constants  
6fc6			; **********************************************************************  
6fc6			  
6fc6			; Constants that must be defined externally  
6fc6			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6fc6			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6fc6			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6fc6			;kLCDWidth: EQU 20             ;Width in characters  
6fc6			  
6fc6			; general line offsets in any frame buffer  
6fc6			  
6fc6			  
6fc6			display_row_1: equ 0  
6fc6			display_row_2: equ display_row_1+display_cols  
6fc6			display_row_3: equ display_row_2 + display_cols  
6fc6			display_row_4: equ display_row_3 + display_cols  
6fc6			;display_row_4_eol:   
6fc6			  
6fc6			  
6fc6			; Cursor position values for the start of each line  
6fc6			  
6fc6			; E  
6fc6			kLCD_Line1: EQU 0x00   
6fc6			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6fc6			; E1  
6fc6			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6fc6			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6fc6			  
6fc6			; Instructions to send as A register to fLCD_Inst  
6fc6			kLCD_Clear: EQU 00000001b     ;LCD clear  
6fc6			kLCD_Off:   EQU 00001000b     ;LCD off  
6fc6			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6fc6			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6fc6			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6fc6			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6fc6			  
6fc6			; Constants used by this code module  
6fc6			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6fc6			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6fc6			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6fc6			  
6fc6			  
6fc6			  
6fc6			; **********************************************************************  
6fc6			; **  LCD support functions  
6fc6			; **********************************************************************  
6fc6			  
6fc6			; Initialise alphanumeric LCD module  
6fc6			; LCD control register codes:  
6fc6			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6fc6			;   N    0 = 1-line mode       1 = 2-line mode  
6fc6			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6fc6			;   D    0 = Display off       1 = Display on  
6fc6			;   C    0 = Cursor off        1 = Cursor on  
6fc6			;   B    0 = Blinking off      1 = Blinking on  
6fc6			;   ID   0 = Decrement mode    1 = Increment mode  
6fc6			;   SH   0 = Entire shift off  1 = Entire shift on  
6fc6 3e 28		fLCD_Init:  LD   A, 40  
6fc8 cd ed 70		            CALL LCDDelay       ;Delay 40ms after power up  
6fcb			; For reliable reset set 8-bit mode - 3 times  
6fcb cd bd 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fce cd bd 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fd1 cd bd 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fd4			; Set 4-bit mode  
6fd4 cd b9 70		            CALL WrFn4bit       ;Function = 4-bit mode  
6fd7 cd eb 70		            CALL LCDDelay1      ;Delay 37 us or more  
6fda			; Function set  
6fda 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6fdc cd ef 6f		            CALL fLCD_Inst      ;2 line, display on  
6fdf			; Display On/Off control  
6fdf 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6fe1 cd ef 6f		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6fe4			; Display Clear  
6fe4 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6fe6 cd ef 6f		            CALL fLCD_Inst      ;Clear display  
6fe9			; Entry mode  
6fe9 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6feb cd ef 6f		            CALL fLCD_Inst      ;Increment mode, shift off  
6fee			; Display module now initialised  
6fee c9			            RET  
6fef			; ok to here  
6fef			  
6fef			; Write instruction to LCD  
6fef			;   On entry: A = Instruction byte to be written  
6fef			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6fef f5			fLCD_Inst:  PUSH AF  
6ff0 f5			            PUSH AF  
6ff1 cd 03 70		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6ff4 f1			            POP  AF  
6ff5 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6ff6 17			            RLA  
6ff7 17			            RLA  
6ff8 17			            RLA  
6ff9 cd 03 70		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6ffc 3e 02		            LD   A, 2  
6ffe cd ed 70		            CALL LCDDelay       ;Delay 2 ms to complete   
7001 f1			            POP  AF  
7002 c9			            RET  
7003			Wr4bits:   
7003 f5					push af  
7004 3a 06 fb				ld a, (display_lcde1e2)  
7007 fe 00				cp 0     ; e  
7009 20 10				jr nz, .wea2	  
700b f1					pop af  
700c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
700e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7010 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7012 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7014 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7016 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7018 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
701a c9			            RET  
701b f1			.wea2:		pop af  
701c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
701e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7020 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7022 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7024 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7026 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7028 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
702a c9			            RET  
702b			  
702b			  
702b			; Write data to LCD  
702b			;   On entry: A = Data byte to be written  
702b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
702b f5			fLCD_Data:  PUSH AF  
702c f5			            PUSH AF  
702d cd 3f 70		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7030 f1			            POP  AF  
7031 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7032 17			            RLA  
7033 17			            RLA  
7034 17			            RLA  
7035 cd 3f 70		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7038 3e 96		            LD   A, 150  
703a 3d			Wait:      DEC  A              ;Wait a while to allow data   
703b 20 fd		            JR   NZ, Wait      ;  write to complete  
703d f1			            POP  AF  
703e c9			            RET  
703f			Wr4bitsa:     
703f f5					push af  
7040 3a 06 fb				ld a, (display_lcde1e2)  
7043 fe 00				cp 0     ; e1  
7045 20 16				jr nz, .we2	  
7047 f1					pop af  
7048 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
704a cb d7		            SET  kLCDBitRS, A  
704c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
704e cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7050 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7052 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7054 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7056 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7058 cb 97		            RES  kLCDBitRS, A  
705a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
705c c9			            RET  
705d f1			.we2:		pop af  
705e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7060 cb d7		            SET  kLCDBitRS, A  
7062 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7064 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7066 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7068 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
706a cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
706c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
706e cb 97		            RES  kLCDBitRS, A  
7070 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7072 c9			            RET  
7073			  
7073			  
7073			; Position cursor to specified location  
7073			;   On entry: A = Cursor position  
7073			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7073 f5			fLCD_Pos:   PUSH AF  
7074					; at this point set the E1 or E2 flag depending on position  
7074			  
7074 c5					push bc  
7075			;		push af  
7075 06 00				ld b, 0  
7077 4f					ld c, a  
7078 3e 4f				ld a, kLCD_Line3-1  
707a b7			 		or a      ;clear carry flag  
707b 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
707c 38 04				jr c, .pe1  
707e			  
707e					; E selection  
707e cb 80				res 0, b         ; bit 0 unset e  
7080			;		pop af    ; before line 3 so recover orig pos  
7080			;		ld c, a    ; save for poking back  
7080 18 06				jr .peset	          
7082			.pe1:          	; E2 selection  
7082 cb c0				set 0, b         ; bit 0 set e1  
7084 79					ld a, c  
7085 de 4f				sbc a, kLCD_Line3-1  
7087 4f					ld c, a	         ; save caculated offset  
7088			;		pop af     ; bin this original value now we have calculated form  
7088			  
7088			.peset:		; set bit  
7088 78					ld a, b  
7089 32 06 fb				ld (display_lcde1e2), a 	  
708c 79					ld a, c  
708d c1					pop bc  
708e			  
708e f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7090 cd ef 6f		            CALL fLCD_Inst      ;Write instruction to LCD  
7093 f1			            POP  AF  
7094 c9			            RET  
7095			  
7095			  
7095			; Output text string to LCD  
7095			;   On entry: DE = Pointer to null terminated text string  
7095			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7095 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7096 b7			            OR   A              ;Null terminator?  
7097 c8			            RET  Z              ;Yes, so finished  
7098 cd 2b 70		            CALL fLCD_Data      ;Write character to display  
709b 13			            INC  DE             ;Point to next character  
709c 18 f7		            JR   fLCD_Str       ;Repeat  
709e c9					ret  
709f			  
709f			; Define custom character  
709f			;   On entry: A = Character number (0 to 7)  
709f			;             DE = Pointer to character bitmap data  
709f			;   On exit:  A = Next character number  
709f			;             DE = Next location following bitmap  
709f			;             BC HL IX IY I AF' BC' DE' HL' preserved  
709f			; Character is   
709f c5			fLCD_Def:   PUSH BC  
70a0 f5			            PUSH AF  
70a1 07			            RLCA                ;Calculate location  
70a2 07			            RLCA                ;  for bitmap data  
70a3 07			            RLCA                ;  = 8 x CharacterNumber  
70a4 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
70a6 cd ef 6f		            CALL fLCD_Inst      ;Write instruction to LCD  
70a9 06 00		            LD   B, 0  
70ab 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
70ac cd 2b 70		            CALL fLCD_Data      ;Write byte to display  
70af 13			            INC  DE             ;Point to next byte  
70b0 04			            INC  B              ;Count bytes  
70b1 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
70b3 28 f6		            JR   Z, Loop       ;No, so repeat  
70b5 f1			            POP  AF  
70b6 3c			            INC  A              ;Increment character number  
70b7 c1			            POP  BC  
70b8 c9			            RET  
70b9			  
70b9			  
70b9			; **********************************************************************  
70b9			; **  Private functions  
70b9			; **********************************************************************  
70b9			  
70b9			; Write function to LCD  
70b9			;   On entry: A = Function byte to be written  
70b9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70b9 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
70bb 18 02		            JR   WrFunc  
70bd 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
70bf f5			WrFunc:     PUSH AF  
70c0 f5					push af  
70c1 3a 06 fb				ld a, (display_lcde1e2)  
70c4 fe 00				cp 0     ; e1  
70c6 20 0f				jr nz, .wfea2	  
70c8 f1					pop af  
70c9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70cb cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
70cd cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
70cf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70d1 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
70d3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70d5 18 0d			jr .wfskip  
70d7 f1			.wfea2:		pop af  
70d8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70da cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
70dc cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
70de d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70e0 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
70e2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70e4 3e 05		.wfskip:            LD  A, 5  
70e6 cd ed 70		            CALL LCDDelay       ;Delay 5 ms to complete  
70e9 f1			            POP  AF  
70ea c9			            RET  
70eb			  
70eb			  
70eb			; Delay in milliseconds  
70eb			;   On entry: A = Number of milliseconds delay  
70eb			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70eb 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
70ed d5			LCDDelay:   PUSH DE  
70ee 5f			            LD   E, A           ;Delay by 'A' ms  
70ef 16 00		            LD   D, 0  
70f1 cd c3 0c		            CALL aDelayInMS  
70f4 d1			            POP  DE  
70f5 c9			            RET  
70f6			  
70f6			  
70f6			testlcd:  
70f6 3e 00			ld a, kLCD_Line1  
70f8 cd 73 70			call fLCD_Pos  
70fb 06 28			ld b, 40  
70fd 11 2b 71			ld de, .ttext1  
7100 cd be 6f			call write_len_string  
7103			  
7103 3e 28			ld a, kLCD_Line2  
7105 cd 73 70			call fLCD_Pos  
7108 06 28			ld b, 40  
710a 11 54 71			ld de, .ttext2  
710d cd be 6f			call write_len_string  
7110 3e 50			ld a, kLCD_Line3  
7112 cd 73 70			call fLCD_Pos  
7115 06 28			ld b, 40  
7117 11 7d 71			ld de, .ttext3  
711a cd be 6f			call write_len_string  
711d 3e 78			ld a, kLCD_Line4  
711f cd 73 70			call fLCD_Pos  
7122 06 28			ld b, 40  
7124 11 a6 71			ld de, .ttext4  
7127 cd be 6f			call write_len_string  
712a			  
712a 76				halt  
712b			  
712b			  
712b .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7154 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
717d .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
71a6 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
71cf			   
71cf			  
71cf			  
71cf			; eof  
71cf			  
# End of file firmware_lcd_4x40.asm
71cf			;include "firmware_lcd_4x20.asm" 
71cf			include "firmware_key_5x10.asm" 
71cf			; 5 x 10 decade counter scanner  
71cf			  
71cf			  
71cf			; TODO do cursor shape change for shift keys  
71cf			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
71cf			  
71cf			  
71cf			; bit mask for each scan column and row for teing the matrix  
71cf			  
71cf			  
71cf			key_init:  
71cf			  
71cf			; SCMonAPI functions used  
71cf			  
71cf			; Alphanumeric LCD functions used  
71cf			; no need to specify specific functions for this module  
71cf			  
71cf			  
71cf 3e cf		            LD   A, 11001111b  
71d1 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
71d3			;            LD   A, 00000000b  
71d3 3e 1f		            LD   A, 00011111b  
71d5 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
71d7			  
71d7			  
71d7				; TODO Configure cursor shapes  
71d7			  
71d7				; Load cursor shapes   
71d7 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
71d9 11 e9 71		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
71dc 06 02		            LD   B, 2           ;Number of characters to define  
71de cd 9f 70		.DefLoop:   CALL fLCD_Def       ;Define custom character  
71e1 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
71e3			  
71e3 3e 01				ld a, 1  
71e5 32 fc fa			ld (cursor_shape),a  
71e8 c9				ret  
71e9			  
71e9			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
71e9			; Up to 8 custom characters can be defined  
71e9			.cursor_shapes:      
71e9			;; Character 0x00 = Normal  
71e9 1f			            DB  11111b  
71ea 1f			            DB  11111b  
71eb 1f			            DB  11111b  
71ec 1f			            DB  11111b  
71ed 1f			            DB  11111b  
71ee 1f			            DB  11111b  
71ef 1f			            DB  11111b  
71f0 1f			            DB  11111b  
71f1			;; Character 0x01 = Modifier  
71f1 1f			            DB  11111b  
71f2 1b			            DB  11011b  
71f3 1b			            DB  11011b  
71f4 1b			            DB  11011b  
71f5 1b			            DB  11011b  
71f6 1f			            DB  11111b  
71f7 1b			            DB  11011b  
71f8 1f			            DB  11111b  
71f9			  
71f9			  
71f9			  
71f9			  
71f9			; Display custom character 0  
71f9			;            LD   A, kLCD_Line1+14  
71f9			;            CALL fLCD_Pos       ;Position cursor to location in A  
71f9			;            LD   A, 0  
71f9			;            CALL fLCD_Data      ;Write character in A at cursor  
71f9			  
71f9			; Display custom character 1  
71f9			;            LD   A, kLCD_Line2+14  
71f9			;            CALL fLCD_Pos      ;Position cursor to location in A  
71f9			;            LD   A, 1  
71f9			;            CALL fLCD_Data     ;Write character in A at cursor  
71f9			  
71f9			; keyboard scanning   
71f9			  
71f9			; character in from keyboard  
71f9			  
71f9			; mapping for the pcb layout  
71f9			  
71f9			.matrix_to_char:  
71f9 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7204 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
720f 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
721a 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7225 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7230			.matrix_to_shift:  
7230			  
7230 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
723b .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7246 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7251 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
725c .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7267			  
7267			.matrix_to_symbolshift:  
7267			  
7267 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7272 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
727d 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7288			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7288 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7293 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
729e			  
729e			  
729e			  
729e			; mapping for a simple straight through breadboard layout  
729e			  
729e			;.matrix_to_char:  
729e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
729e			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
729e			;		db "asdfghjkl",KEY_CR,0  
729e			;		db "qwertyuiop",0  
729e			;		 db "1234567890",0  
729e			;.matrix_to_shift:  
729e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
729e			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
729e			;		db "ASDFGHJKL",KEY_CR,0  
729e			;		db "QWERTYUIOP",0  
729e			;		 db "!",'"',"#$%^&*()",0  
729e			;.matrix_to_symbolshift:  
729e			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
729e			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
729e			;		db "_?*fghjk=",KEY_CR,0  
729e			;		db "-/+*[]{}@#",0  
729e			;		 db "1234567890",0  
729e			  
729e			;.matrix_to_char: db "D#0*C987B654A321"  
729e			  
729e			  
729e				  
729e			  
729e			; add cin and cin_wait  
729e			  
729e cd af 72		cin_wait: 	call cin  
72a1						if DEBUG_KEYCINWAIT  
72a1							push af  
72a1							  
72a1							ld hl,key_repeat_ct  
72a1							ld (hl),a  
72a1							inc hl  
72a1							call hexout  
72a1							ld hl,key_repeat_ct+3  
72a1							ld a,0  
72a1							ld (hl),a  
72a1			  
72a1							    LD   A, kLCD_Line1+11  
72a1							    CALL fLCD_Pos       ;Position cursor to location in A  
72a1							    LD   DE, key_repeat_ct  
72a1							    ;LD   DE, MsgHello  
72a1							    CALL fLCD_Str       ;Display string pointed to by DE  
72a1			  
72a1			  
72a1			  
72a1							pop af  
72a1						endif  
72a1 fe 00			cp 0  
72a3 28 f9			jr z, cin_wait   ; block until key press  
72a5			  
72a5							if DEBUG_KEYCINWAIT  
72a5								push af  
72a5			  
72a5								ld a, 'A'	  
72a5								ld hl,key_repeat_ct  
72a5								ld (hl),a  
72a5								inc hl  
72a5								ld a,0  
72a5								ld (hl),a  
72a5			  
72a5								    LD   A, kLCD_Line2+11  
72a5								    CALL fLCD_Pos       ;Position cursor to location in A  
72a5								    LD   DE, key_repeat_ct  
72a5								    ;LD   DE, MsgHello  
72a5								    CALL fLCD_Str       ;Display string pointed to by DE  
72a5			  
72a5							call delay500ms  
72a5			  
72a5								pop af  
72a5							endif  
72a5 f5				push af   ; save key pressed  
72a6			  
72a6			.cin_wait1:	  
72a6							if DEBUG_KEYCINWAIT  
72a6								push af  
72a6			  
72a6								ld a, 'b'	  
72a6								ld hl,key_repeat_ct  
72a6								ld (hl),a  
72a6								inc hl  
72a6								ld a,0  
72a6								ld (hl),a  
72a6			  
72a6								    LD   A, kLCD_Line2+11  
72a6								    CALL fLCD_Pos       ;Position cursor to location in A  
72a6								    LD   DE, key_repeat_ct  
72a6								    ;LD   DE, MsgHello  
72a6								    CALL fLCD_Str       ;Display string pointed to by DE  
72a6			  
72a6			  
72a6							call delay500ms  
72a6			  
72a6								pop af  
72a6							endif  
72a6			  
72a6 cd af 72		call cin  
72a9 fe 00			cp 0  
72ab 20 f9			jr nz, .cin_wait1  	; wait for key release  
72ad			if DEBUG_KEYCINWAIT  
72ad				push af  
72ad			  
72ad				ld a, '3'	  
72ad				ld hl,key_repeat_ct  
72ad				ld (hl),a  
72ad				inc hl  
72ad				ld a,0  
72ad				ld (hl),a  
72ad			  
72ad			            LD   A, kLCD_Line2+11  
72ad			            CALL fLCD_Pos       ;Position cursor to location in A  
72ad			            LD   DE, key_repeat_ct  
72ad			            ;LD   DE, MsgHello  
72ad			            CALL fLCD_Str       ;Display string pointed to by DE  
72ad			  
72ad			  
72ad			call delay500ms  
72ad			  
72ad				pop af  
72ad			endif  
72ad			  
72ad f1				pop af   ; get key  
72ae c9				ret  
72af			  
72af			  
72af cd c3 72		cin: 	call .mtoc  
72b2			  
72b2			if DEBUG_KEYCIN  
72b2				push af  
72b2				  
72b2				ld hl,key_repeat_ct  
72b2				ld (hl),a  
72b2				inc hl  
72b2				call hexout  
72b2				ld hl,key_repeat_ct+3  
72b2				ld a,0  
72b2				ld (hl),a  
72b2			  
72b2			            LD   A, kLCD_Line3+15  
72b2			            CALL fLCD_Pos       ;Position cursor to location in A  
72b2			            LD   DE, key_repeat_ct  
72b2			            ;LD   DE, MsgHello  
72b2			            CALL fLCD_Str       ;Display string pointed to by DE  
72b2			  
72b2			  
72b2			call delay500ms  
72b2			  
72b2				pop af  
72b2			endif  
72b2			  
72b2			  
72b2				; no key held  
72b2 fe 00			cp 0  
72b4 c8				ret z  
72b5			  
72b5			if DEBUG_KEYCIN  
72b5				push af  
72b5			  
72b5				ld a, '1'	  
72b5				ld hl,key_repeat_ct  
72b5				ld (hl),a  
72b5				inc hl  
72b5				ld a,0  
72b5				ld (hl),a  
72b5			  
72b5			            LD   A, kLCD_Line4+15  
72b5			            CALL fLCD_Pos       ;Position cursor to location in A  
72b5			            LD   DE, key_repeat_ct  
72b5			            ;LD   DE, MsgHello  
72b5			            CALL fLCD_Str       ;Display string pointed to by DE  
72b5			  
72b5			  
72b5			call delay500ms  
72b5			  
72b5				pop af  
72b5			endif  
72b5			  
72b5				; stop key bounce  
72b5			  
72b5 32 c6 fd			ld (key_held),a		 ; save it  
72b8 47				ld b, a  
72b9			  
72b9 c5			.cina1:	push bc  
72ba			if DEBUG_KEYCIN  
72ba				push af  
72ba			  
72ba				ld hl,key_repeat_ct  
72ba				inc hl  
72ba				call hexout  
72ba				ld hl,key_repeat_ct+3  
72ba				ld a,0  
72ba				ld (hl),a  
72ba				ld hl,key_repeat_ct  
72ba				ld a, '2'	  
72ba				ld (hl),a  
72ba			  
72ba			            LD   A, kLCD_Line4+15  
72ba			            CALL fLCD_Pos       ;Position cursor to location in A  
72ba			            LD   DE, key_repeat_ct  
72ba			            ;LD   DE, MsgHello  
72ba			            CALL fLCD_Str       ;Display string pointed to by DE  
72ba			  
72ba				pop af  
72ba			endif  
72ba cd c3 72			call .mtoc  
72bd c1				pop bc  
72be b8				cp b  
72bf 28 f8			jr z, .cina1  
72c1 78				ld a,b		  
72c2			if DEBUG_KEYCIN  
72c2				push af  
72c2			  
72c2				ld hl,key_repeat_ct  
72c2				inc hl  
72c2				call hexout  
72c2				ld hl,key_repeat_ct+3  
72c2				ld a,0  
72c2				ld (hl),a  
72c2				ld hl,key_repeat_ct  
72c2				ld a, '3'	  
72c2				ld (hl),a  
72c2			  
72c2			            LD   A, kLCD_Line4+15  
72c2			            CALL fLCD_Pos       ;Position cursor to location in A  
72c2			            LD   DE, key_repeat_ct  
72c2			            ;LD   DE, MsgHello  
72c2			            CALL fLCD_Str       ;Display string pointed to by DE  
72c2			  
72c2				pop af  
72c2			endif  
72c2 c9				ret  
72c3			  
72c3			; detect keyboard modifier key press and apply new overlay to the face key held  
72c3			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
72c3			  
72c3			;.cin_map_modifier:   
72c3			;	ld a, (hl)  
72c3			;	and 255  
72c3			;	ret NZ		; modifier key not flagged  
72c3			;  
72c3			;	; get key face  
72c3			;  
72c3			;	ld b,(key_face_held)  
72c3			;  
72c3			;	ld b, key_cols * key_rows  
72c3			;  
72c3			;	push de  
72c3			;	pop hl  
72c3			;  
72c3			;.mmod1: ld a,(hl)   ; get map test  
72c3			;	cp b  
72c3			;	jr z, .mmod2  
72c3			;  
72c3			;  
72c3			;  
72c3			;.mmod2: inc hl    ;   
72c3			;  
72c3			;	  
72c3			;  
72c3			;	  
72c3			;  
72c3			;	ld hl,key_actual_pressed  
72c3			;	ld (hl),a,  
72c3			;	ret  
72c3			  
72c3			; map matrix key held to char on face of key  
72c3			  
72c3			.mtoc:  
72c3			  
72c3			; test decade counter strobes  
72c3			  
72c3			;.decadetest1:  
72c3			  
72c3			; reset counter  
72c3			;ld a, 128  
72c3			;out (portbdata),a  
72c3			  
72c3			  
72c3			;ld b, 5  
72c3			;.dec1:  
72c3			;ld a, 0  
72c3			;out (portbdata),a  
72c3			;call delay1s  
72c3			  
72c3			;ld a, 32  
72c3			;out (portbdata),a  
72c3			;call delay1s  
72c3			;call delay1s  
72c3			;call delay1s  
72c3			;  
72c3			;ld a, 64+32  
72c3			;out (portbdata),a  
72c3			;call delay1s  
72c3			;;djnz .dec1  
72c3			;  
72c3			;jp .decadetest1  
72c3			  
72c3			  
72c3			  
72c3			  
72c3			  
72c3			  
72c3			  
72c3			  
72c3			  
72c3			  
72c3				; scan keyboard matrix and generate raw scan map  
72c3 cd 56 73			call matrix  
72c6			  
72c6				; reuse c bit 0 left modifer button - ie shift  
72c6			        ; reuse c bit 1 for right modifer button - ie symbol shift  
72c6				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
72c6			  
72c6 0e 00			ld c, 0  
72c8			  
72c8				; TODO set flags for modifer key presses   
72c8				; TODO do a search for modifer key...  
72c8			  
72c8				;ld hl,keyscan_table_row4  
72c8 21 25 fe			ld hl,keyscan_table_row2  
72cb			  
72cb 7e				ld a, (hl)  
72cc fe 23			cp '#'  
72ce 20 07			jr nz, .nextmodcheck  
72d0 cb c1			set 0, c  
72d2 21 30 72			ld hl, .matrix_to_shift  
72d5 18 21			jr .dokeymap  
72d7				; TODO for now igonre  
72d7			.nextmodcheck:  
72d7 21 1a fe			ld hl,keyscan_table_row3  
72da			  
72da 7e				ld a, (hl)  
72db fe 23			cp '#'  
72dd 20 07			jr nz, .nextmodcheck2  
72df cb c9			set 1, c   
72e1 21 67 72			ld hl, .matrix_to_symbolshift  
72e4 18 12			jr .dokeymap  
72e6			.nextmodcheck2:  
72e6 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
72e9			  
72e9 7e				ld a, (hl)  
72ea fe 23			cp '#'  
72ec 20 07			jr nz, .donemodcheck  
72ee cb c9			set 1, c   
72f0 21 30 72			ld hl, .matrix_to_shift  
72f3 18 03			jr .dokeymap  
72f5			  
72f5				; no modifer found so just map to normal keys  
72f5				; get mtoc map matrix to respective keys  
72f5			;	ld hl, .matrix_to_char  
72f5			;	ld hl, .matrix_to_char  
72f5			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
72f5			;	ld a, KEY_SHIFT  
72f5			;	call findchar  
72f5			;  
72f5			;	; got offset to key modifer in b  
72f5			;  
72f5			;	ld hl,keyscan_table_row5  
72f5			;  
72f5			;	ld a,b  
72f5			;	call addatohl  
72f5			;	ld a,(hl)  
72f5			;  
72f5			;	cp '#'  
72f5			;	jr nz, .nextmodcheck  
72f5			;	set 0, c  
72f5			;	ld hl, .matrix_to_char  
72f5			;	jr .dokeymap  
72f5			;	; TODO for now igonre  
72f5			;.nextmodcheck:  
72f5			;	ld hl, .matrix_to_symbolshift  
72f5			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
72f5			;	ld a, KEY_SYMBOLSHIFT  
72f5			;	call findchar  
72f5			;  
72f5			;  
72f5			;	; got offset to key modifer in b  
72f5			;  
72f5			;	ld hl,keyscan_table_row5  
72f5			;  
72f5			;	ld a,b  
72f5			;	call addatohl  
72f5			;	ld a,(hl)  
72f5			;  
72f5			;	cp '#'  
72f5			;	jr nz, .donemodcheck  
72f5			;	set 1, c   
72f5			;	ld hl, .matrix_to_symbolshift  
72f5			;	jr .dokeymap  
72f5			  
72f5			  
72f5			  
72f5			.donemodcheck:  
72f5				; no modifer found so just map to normal keys  
72f5				; get mtoc map matrix to respective keys  
72f5 21 f9 71			ld hl, .matrix_to_char  
72f8			  
72f8			.dokeymap:  
72f8				;ld (key_fa), c   
72f8 cd 11 73			call .mapkeys  
72fb			  
72fb			  
72fb			if DEBUG_KEY  
72fb			  
72fb			; Display text on first line  
72fb			            LD   A, kLCD_Line1  
72fb			            CALL fLCD_Pos       ;Position cursor to location in A  
72fb			            LD   DE, keyscan_table_row1  
72fb			            ;LD   DE, MsgHello  
72fb			            CALL fLCD_Str       ;Display string pointed to by DE  
72fb			  
72fb			; Display text on second line  
72fb			            LD   A, kLCD_Line2  
72fb			            CALL fLCD_Pos       ;Position cursor to location in A  
72fb			            LD   DE, keyscan_table_row2  
72fb			            CALL fLCD_Str       ;Display string pointed to by DE  
72fb			            LD   A, kLCD_Line3  
72fb			            CALL fLCD_Pos       ;Position cursor to location in A  
72fb			            LD   DE, keyscan_table_row3  
72fb			            CALL fLCD_Str       ;Display string pointed to by DE  
72fb			            LD   A, kLCD_Line4  
72fb			            CALL fLCD_Pos       ;Position cursor to location in A  
72fb			            LD   DE, keyscan_table_row4  
72fb			            CALL fLCD_Str       ;Display string pointed to by DE  
72fb			            LD   A, kLCD_Line1+10  
72fb			            CALL fLCD_Pos       ;Position cursor to location in A  
72fb			            LD   DE, keyscan_table_row5  
72fb			            CALL fLCD_Str       ;Display string pointed to by DE  
72fb			  
72fb				;call delay250ms  
72fb			endif  
72fb			;	jp testkey  
72fb			  
72fb			; get first char reported  
72fb			  
72fb 21 04 fe			ld hl,keyscan_table_row5  
72fe			  
72fe				;ld b, 46   ; 30 keys to remap + 8 nulls   
72fe 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7300			.findkey:  
7300 7e				ld a,(hl)  
7301 fe 00			cp 0  
7303 28 04			jr z, .nextkey  
7305 fe 7e			cp KEY_MATRIX_NO_PRESS  
7307 20 06			jr nz, .foundkey  
7309			.nextkey:  
7309 23				inc hl  
730a 10 f4			djnz .findkey  
730c 3e 00			ld a,0  
730e c9				ret  
730f			.foundkey:  
730f 7e				ld a,(hl)  
7310 c9				ret  
7311				  
7311			  
7311			; convert the raw key map given hl for destination key  
7311			.mapkeys:  
7311 11 04 fe			ld de,keyscan_table_row5  
7314			  
7314 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7316			.remap:  
7316 1a				ld a,(de)  
7317 fe 23			cp '#'  
7319 20 02			jr nz, .remapnext  
731b				;CALLMONITOR  
731b 7e				ld a,(hl)  
731c 12				ld (de),a  
731d			  
731d			  
731d			  
731d			.remapnext:  
731d 23				inc hl  
731e 13				inc de  
731f 10 f5			djnz .remap  
7321				  
7321 c9				ret  
7322			  
7322			  
7322			  
7322			.mtocold2:  
7322			  
7322			;	; flag if key D is held down and remove from reporting  
7322			;	ld bc, .key_map_fd    
7322			;	ld hl, keyscan_table  
7322			;	ld de, key_fd  
7322			;	call .key_shift_hold  
7322			;	cp 255  
7322			;	jr z, .cinmap  
7322			;	; flag if key C is held down and remove from reporting  
7322			;	ld bc, .key_map_fc    
7322			;	ld hl, keyscan_table+key_cols  
7322			;	ld de, key_fc  
7322			;	call .key_shift_hold  
7322			;	cp 255  
7322			;	jr z, .cinmap  
7322			;	; flag if key B is held down and remove from reporting  
7322			;	ld bc, .key_map_fb    
7322			;	ld hl, keyscan_table+(key_cols*2)  
7322			;	ld de, key_fb  
7322			;	call .key_shift_hold  
7322			;	cp 255  
7322			;	jr z, .cinmap  
7322			;	; flag if key A is held down and remove from reporting  
7322			;	ld bc, .key_map_fa    
7322			;	ld hl, keyscan_table+(key_cols*3)  
7322			;	ld de, key_fa  
7322			;	call .key_shift_hold  
7322			;	cp 255  
7322			;	jr z, .cinmap  
7322			  
7322 11 f9 71			ld de, .matrix_to_char  
7325			  
7325			  
7325			.cinmap1:   
7325				if DEBUG_KEY  
7325			            LD   A, kLCD_Line4  
7325			            CALL fLCD_Pos       ;Position cursor to location in A  
7325					push de  
7325			            LD   DE, keyscan_table  
7325			            CALL fLCD_Str       ;Display string pointed to by DE  
7325					pop de  
7325				endif  
7325			  
7325				; scan key matrix table for any held key  
7325			  
7325				; de holds either the default matrix or one selected above  
7325			  
7325 21 d1 fd			ld hl, keyscan_table  
7328 06 32			ld b,key_cols*key_rows  
732a			  
732a 7e			.cin11:	ld a,(hl)  
732b fe 23			cp '#'  
732d 28 08			jr z, .cinhit1  
732f 23				inc hl  
7330 13				inc de  
7331 05				dec b  
7332 20 f6			jr nz, .cin11  
7334				; no key found held  
7334 3e 00			ld a,0  
7336 c9				ret  
7337 d5			.cinhit1: push de  
7338 e1				pop hl  
7339 7e				ld a,(hl)  
733a c9				ret  
733b			  
733b			; flag a control key is held   
733b			; hl is key pin, de is flag indicator  
733b			  
733b			.key_shift_hold1:  
733b c5				push bc  
733c 3e 01			ld a, 1  
733e 32 fc fa			ld (cursor_shape),a  
7341 06 00			ld b, 0  
7343 7e				ld a, (hl)  
7344 fe 2e			cp '.'  
7346 28 0a			jr z, .key_shift11  
7348 06 ff			ld b, 255  
734a 3e 2b			ld a, '+'    ; hide key from later scans  
734c 77				ld (hl),a  
734d 3e 02			ld a, 2  
734f 32 fc fa			ld (cursor_shape),a  
7352			.key_shift11:  
7352				; write flag indicator  
7352 78				ld a,b  
7353 12				ld (de),a  
7354			  
7354 d1				pop de    ; de now holds the key map ptr  
7355 c9				ret  
7356			  
7356				  
7356			  
7356			; scans keyboard matrix and flags key press in memory array	  
7356				  
7356			matrix:  
7356				;call matrix  
7356				; TODO optimise the code....  
7356			  
7356			  
7356			;ld hl, keyscan_table_row1  
7356			;ld de, keyscan_table_row1+1  
7356			;ld bc,46  
7356			;ld a,KEY_MATRIX_NO_PRESS  
7356			;ldir  
7356			  
7356			  
7356			  
7356			; reset counter  
7356 3e 80		ld a, 128  
7358 d3 c1		out (portbdata),a  
735a			  
735a 06 0a		ld b, 10  
735c 0e 00		ld c, 0       ; current clock toggle  
735e			  
735e			.colscan:  
735e			  
735e			; set current column  
735e			; disable clock enable and set clock low  
735e			  
735e			;ld a, 0  
735e			;out (portbdata),a  
735e			  
735e			; For each column scan for switches  
735e			  
735e c5			push bc  
735f 21 c7 fd		ld hl, keyscan_scancol  
7362 cd 6b 74		call .rowscan  
7365 c1			pop bc  
7366			  
7366			  
7366			; get back current column  
7366			  
7366			; translate the row scan  
7366			  
7366			;   
7366			; row 1  
7366			  
7366 78			ld a,b  
7367			  
7367 21 3a fe		LD   hl, keyscan_table_row1+10  
736a			  
736a cd e1 0f		call subafromhl  
736d			;call addatohl  
736d			  
736d 11 c7 fd		ld de, keyscan_scancol  
7370			  
7370 1a			ld a,(de)  
7371 77			ld (hl),a  
7372			  
7372			  
7372			  
7372			  
7372			; row 2  
7372			  
7372 78			ld a,b  
7373			  
7373 21 2f fe		LD   hl, keyscan_table_row2+10  
7376			  
7376			;call addatohl  
7376 cd e1 0f		call subafromhl  
7379			  
7379			  
7379 11 c8 fd		ld de, keyscan_scancol+1  
737c			  
737c 1a			ld a,(de)  
737d 77			ld (hl),a  
737e			  
737e			  
737e			; row 3  
737e			  
737e 78			ld a,b  
737f			  
737f 21 24 fe		LD   hl, keyscan_table_row3+10  
7382			  
7382			;call addatohl  
7382 cd e1 0f		call subafromhl  
7385			  
7385 11 c9 fd		ld de, keyscan_scancol+2  
7388			  
7388 1a			ld a,(de)  
7389 77			ld (hl),a  
738a			  
738a			  
738a			  
738a			; row 4  
738a			  
738a 78			ld a,b  
738b			  
738b 21 19 fe		LD   hl, keyscan_table_row4+10  
738e			  
738e			;call addatohl  
738e cd e1 0f		call subafromhl  
7391			  
7391 11 ca fd		ld de, keyscan_scancol+3  
7394			  
7394 1a			ld a,(de)  
7395 77			ld (hl),a  
7396			  
7396			; row 5  
7396			  
7396 78			ld a,b  
7397			  
7397 21 0e fe		LD   hl, keyscan_table_row5+10  
739a			  
739a			;call addatohl  
739a cd e1 0f		call subafromhl  
739d			  
739d 11 cb fd		ld de, keyscan_scancol+4  
73a0			  
73a0 1a			ld a,(de)  
73a1 77			ld (hl),a  
73a2			  
73a2			; handshake next column  
73a2			  
73a2			  
73a2 3e 40		ld a, 64  
73a4 d3 c1		out (portbdata),a  
73a6			  
73a6 3e 00		ld a, 0  
73a8 d3 c1		out (portbdata),a  
73aa			  
73aa			; toggle clk and move to next column  
73aa			;ld a, 64  
73aa			;cp c  
73aa			;  
73aa			;jr z, .coltoglow  
73aa			;ld c, a  
73aa			;jr .coltog  
73aa			;.coltoglow:  
73aa			;ld c, 0  
73aa			;.coltog:  
73aa			;ld a, c  
73aa			;out (portbdata),a  
73aa			  
73aa 10 b2		djnz .colscan  
73ac			  
73ac 3e 0a		ld a,10  
73ae 21 30 fe		LD   hl, keyscan_table_row1  
73b1 cd cf 0f		call addatohl  
73b4 3e 00		ld a, 0  
73b6 77			ld (hl), a  
73b7			  
73b7			  
73b7 3e 0a		ld a,10  
73b9 21 25 fe		LD   hl, keyscan_table_row2  
73bc cd cf 0f		call addatohl  
73bf 3e 00		ld a, 0  
73c1 77			ld (hl), a  
73c2			  
73c2 3e 0a		ld a,10  
73c4 21 1a fe		LD   hl, keyscan_table_row3  
73c7 cd cf 0f		call addatohl  
73ca 3e 00		ld a, 0  
73cc 77			ld (hl), a  
73cd			  
73cd 3e 0a		ld a,10  
73cf 21 0f fe		LD   hl, keyscan_table_row4  
73d2 cd cf 0f		call addatohl  
73d5 3e 00		ld a, 0  
73d7 77			ld (hl), a  
73d8			  
73d8 3e 0a		ld a,10  
73da 21 04 fe		LD   hl, keyscan_table_row5  
73dd cd cf 0f		call addatohl  
73e0 3e 00		ld a, 0  
73e2 77			ld (hl), a  
73e3			  
73e3			if DEBUG_KEY_MATRIX  
73e3			  
73e3			; Display text on first line  
73e3			            LD   A, kLCD_Line1  
73e3			            CALL fLCD_Pos       ;Position cursor to location in A  
73e3			            LD   DE, keyscan_table_row1  
73e3			            ;LD   DE, MsgHello  
73e3			            CALL fLCD_Str       ;Display string pointed to by DE  
73e3			  
73e3			; Display text on second line  
73e3			            LD   A, kLCD_Line2  
73e3			            CALL fLCD_Pos       ;Position cursor to location in A  
73e3			            LD   DE, keyscan_table_row2  
73e3			            CALL fLCD_Str       ;Display string pointed to by DE  
73e3			            LD   A, kLCD_Line3  
73e3			            CALL fLCD_Pos       ;Position cursor to location in A  
73e3			            LD   DE, keyscan_table_row3  
73e3			            CALL fLCD_Str       ;Display string pointed to by DE  
73e3			            LD   A, kLCD_Line4  
73e3			            CALL fLCD_Pos       ;Position cursor to location in A  
73e3			            LD   DE, keyscan_table_row4  
73e3			            CALL fLCD_Str       ;Display string pointed to by DE  
73e3			            LD   A, kLCD_Line4+10  
73e3			            CALL fLCD_Pos       ;Position cursor to location in A  
73e3			            LD   DE, keyscan_table_row5  
73e3			            CALL fLCD_Str       ;Display string pointed to by DE  
73e3			  
73e3			;call delay250ms  
73e3				jp matrix  
73e3			endif  
73e3 c9			ret  
73e4			  
73e4			; using decade counter....  
73e4			  
73e4			  
73e4			; TODO reset decade counter to start of scan  
73e4			  
73e4			; reset 15  
73e4			; clock 14  
73e4			; ce 13  
73e4			  
73e4			; 1 - q5  
73e4			; 2 - q1  
73e4			; 3 - q0  
73e4			; 4 - q2  
73e4			; 5 - q6  
73e4			; 6 - q7  
73e4			; 7 - q3  
73e4			; 8 - vss  
73e4			; 9 - q8  
73e4			; 10 - q4  
73e4			; 11 - q9  
73e4			; 12 - cout  
73e4			; 16 - vdd  
73e4			  
73e4			; clock      ce       reset     output  
73e4			; 0          x        0         n  
73e4			; x          1        0         n  
73e4			; x          x        1         q0  
73e4			; rising     0        0         n+1  
73e4			; falling    x        0         n  
73e4			; x          rising   0         n  
73e4			; 1          falling  0         x+1  
73e4			;  
73e4			; x = dont care, if n < 5 carry = 1 otherwise 0  
73e4			  
73e4			;   
73e4			; reset   
73e4			; 13=0, 14=0, 15=1 .. 15=0  
73e4			;  
73e4			; handshake line  
73e4			; 14=1.... read line 14=0  
73e4			  
73e4			  
73e4			  
73e4			  
73e4			  
73e4			; TODO hand shake clock for next column scan  
73e4			; TODO detect each row  
73e4			  
73e4			  
73e4			  
73e4			  
73e4			; reset 128  
73e4			; clock 64  
73e4			; ce 32  
73e4			  
73e4			  
73e4			.cyclestart:  
73e4			  
73e4			; reset counter  
73e4 3e 80		ld a, 128  
73e6 d3 c1		out (portbdata),a  
73e8			  
73e8			; loop leds  
73e8 06 0a		ld b,10  
73ea			  
73ea			.cycle1:  
73ea c5			push bc  
73eb 3e 00		ld a, 0  
73ed d3 c1		out (portbdata),a  
73ef cd d2 0c		call delay250ms  
73f2			  
73f2 3e 40		ld a, 64  
73f4 d3 c1		out (portbdata),a  
73f6 cd d2 0c		call delay250ms  
73f9			  
73f9 3e 00		ld a, 0  
73fb d3 c1		out (portbdata),a  
73fd cd d2 0c		call delay250ms  
7400			  
7400 c1			pop bc  
7401 10 e7		djnz .cycle1  
7403			  
7403			  
7403 18 df		jr .cyclestart  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			; map matrix key held to char on face of key  
7405			  
7405			;.mtocold:  
7405			;  
7405			;  
7405			;; reset counter  
7405			;ld a, 128  
7405			;out (portbdata),a  
7405			;  
7405			;  
7405			;; scan keyboard row 1  
7405			;ld a, 0  
7405			;out (portbdata),a  
7405			;;ld a, 64  
7405			;;out (portbdata),a  
7405			;  
7405			;  
7405			;	ld a, 128  
7405			;	ld hl, keyscan_table  
7405			;	call .rowscan  
7405			;  
7405			;;ld a, 0  
7405			;;out (portbdata),a  
7405			;ld a, 64  
7405			;out (portbdata),a  
7405			;  
7405			;	ld a, 64  
7405			;	ld hl, keyscan_table+key_cols  
7405			;	call .rowscan  
7405			;  
7405			;ld a, 0  
7405			;out (portbdata),a  
7405			;;ld a, 64  
7405			;;out (portbdata),a  
7405			;	ld a, 32  
7405			;	ld hl, keyscan_table+(key_cols*2)  
7405			;	call .rowscan  
7405			;  
7405			;  
7405			;;ld a, 0  
7405			;;out (portbdata),a  
7405			;ld a, 64  
7405			;out (portbdata),a  
7405			;  
7405			;	ld a, 16  
7405			;	ld hl, keyscan_table+(key_cols*3)  
7405			;	call .rowscan  
7405			;  
7405			;  
7405			;	; flag if key D is held down and remove from reporting  
7405			;	ld bc, .key_map_fd    
7405			;	ld hl, keyscan_table  
7405			;	ld de, key_fd  
7405			;	call .key_shift_hold  
7405			;	cp 255  
7405			;	jr z, .cinmap  
7405			;	; flag if key C is held down and remove from reporting  
7405			;	ld bc, .key_map_fc    
7405			;	ld hl, keyscan_table+key_cols  
7405			;	ld de, key_fc  
7405			;	call .key_shift_hold  
7405			;	cp 255  
7405			;	jr z, .cinmap  
7405			;	; flag if key B is held down and remove from reporting  
7405			;	ld bc, .key_map_fb    
7405			;	ld hl, keyscan_table+(key_cols*2)  
7405			;	ld de, key_fb  
7405			;	call .key_shift_hold  
7405			;	cp 255  
7405			;	jr z, .cinmap  
7405			;	; flag if key A is held down and remove from reporting  
7405			;	ld bc, .key_map_fa    
7405			;	ld hl, keyscan_table+(key_cols*3)  
7405			;	ld de, key_fa  
7405			;	call .key_shift_hold  
7405			;	cp 255  
7405			;	jr z, .cinmap  
7405			;  
7405			;	ld de, .matrix_to_char  
7405			;  
7405			;  
7405			;.cinmap:   
7405			;	if DEBUG_KEY  
7405			;            LD   A, kLCD_Line4  
7405			;            CALL fLCD_Pos       ;Position cursor to location in A  
7405			;		push de  
7405			;            LD   DE, keyscan_table  
7405			;            CALL fLCD_Str       ;Display string pointed to by DE  
7405			;		pop de  
7405			;	endif  
7405			  
7405				; scan key matrix table for any held key  
7405			  
7405				; de holds either the default matrix or one selected above  
7405			  
7405			;	ld hl, keyscan_table  
7405			;	ld b,key_cols*key_rows  
7405			;  
7405			;.cin1:	ld a,(hl)  
7405			;	cp '#'  
7405			;	jr z, .cinhit  
7405			;	inc hl  
7405			;	inc de  
7405			;	dec b  
7405			;	jr nz, .cin1  
7405			;	; no key found held  
7405			;	ld a,0  
7405			;	ret  
7405			;.cinhit: push de  
7405			;	pop hl  
7405			;	ld a,(hl)  
7405			;	ret  
7405			  
7405			; flag a control key is held   
7405			; hl is key pin, de is flag indicator  
7405			  
7405			;.key_shift_hold:  
7405			;	push bc  
7405			;	ld a, 1  
7405			;	ld (cursor_shape),a  
7405			;	ld b, 0  
7405			;	ld a, (hl)  
7405			;	cp '.'  
7405			;	jr z, .key_shift1  
7405			;	ld b, 255  
7405			;	ld a, '+'    ; hide key from later scans  
7405			;	ld (hl),a  
7405			;	ld a, 2  
7405			;	ld (cursor_shape),a  
7405			;.key_shift1:  
7405			;	; write flag indicator  
7405			;	ld a,b  
7405			;	ld (de),a  
7405			;  
7405			;	pop de    ; de now holds the key map ptr  
7405			;	ret  
7405			  
7405				  
7405				  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			;	push hl  
7405			;	push de  
7405			;	push bc  
7405			;	call keyscan  
7405			;	; map key matrix to ascii value of key face  
7405			;  
7405			;	ld hl, key_face_map  
7405			;	ld de, keyscan_table  
7405			;  
7405			;	; get how many keys to look at  
7405			;	ld b, keyscan_table_len  
7405			;	  
7405			;  
7405			;	; at this stage fall out on first key hit  
7405			;	; TODO handle multiple key press  
7405			;  
7405			;map1:	ld a,(hl)  
7405			;	cp '#'  
7405			;	jr z, keyhit  
7405			;	inc hl  
7405			;	inc de  
7405			;	dec b  
7405			;	jr nz, map1  
7405			;nohit:	ld a, 0  
7405			;	jr keydone  
7405			;keyhit: push de  
7405			;	pop hl  
7405			;	ld a,(hl)  
7405			;keydone:  
7405			;	push bc  
7405			;	push de  
7405			; 	push hl  
7405			;	ret   
7405			;  
7405			  
7405			  
7405			  
7405			  
7405			; scan physical key matrix  
7405			  
7405			  
7405			;keyscan:  
7405			;  
7405			;; for each key_row use keyscanr bit mask for out  
7405			;; then read in for keyscanc bitmask  
7405			;; save result of row scan to keyscantable  
7405			;  
7405			;; scan keyboard row 1  
7405			;  
7405			;	ld b, key_rows  
7405			;	ld hl, key_scanr  
7405			;	ld de, keyscan_table  
7405			;  
7405			;rowloop:  
7405			;  
7405			;	ld a,(hl)		; out bit mask to energise keyboard row  
7405			;	call rowscan  
7405			;	inc hl  
7405			;	dec b  
7405			;	jr nz, rowloop  
7405			;  
7405			;	ret  
7405			;  
7405			;  
7405			;; pass a out bitmask, b row number  
7405			;arowscan:   
7405			;	push bc  
7405			;  
7405			;	ld d, b  
7405			;  
7405			;	; calculate buffer location for this row  
7405			;  
7405			;	ld hl, keyscan_table	  
7405			;kbufr:  ld e, key_cols  
7405			;kbufc:	inc hl  
7405			;	dec e  
7405			;	jr nz, kbufc  
7405			;	dec d  
7405			;	jr nz, kbufr  
7405			;  
7405			;	; energise row and read columns  
7405			;  
7405			;	out (portbdata),a  
7405			;	in a,(portbdata)  
7405			;	ld c,a  
7405			;  
7405			;  
7405			;	; save buffer loc  
7405			;  
7405			;	ld (keybufptr), hl  
7405			;  
7405			;	ld hl, key_scanc  
7405			;	ld d, key_cols  
7405			;  
7405			;	; for each column check each bit mask  
7405			;  
7405			;colloop:  
7405			;	  
7405			;  
7405			;	; reset flags for the row   
7405			;  
7405			;	ld b,'.'  
7405			;	and (hl)  
7405			;	jr z, maskskip  
7405			;	ld b,'#'  
7405			;maskskip:  
7405			;	; save  key state  
7405			;	push hl  
7405			;	ld hl, (keybufptr)  
7405			;	ld (hl), b  
7405			;	inc hl  
7405			;	ld (keybufptr), hl  
7405			;  
7405			;	; move to next bit mask  
7405			;	pop hl  
7405			;	inc hl  
7405			;  
7405			;	dec d  
7405			;	jr nz, colloop  
7405			;  
7405			;	ret  
7405			;  
7405			;  
7405			;;  
7405			; lcd functions  
7405			;  
7405			;  
7405			  
7405			;if DEBUG_KEY_MATRIX  
7405			  
7405			; test function to display hardware view of matrix state  
7405			  
7405			matrixold:  
7405			  
7405			  
7405			  
7405			; reset counter  
7405 3e 80		ld a, 128  
7407 d3 c1		out (portbdata),a  
7409			; scan keyboard row 1  
7409 3e 00		ld a, 0  
740b d3 c1		out (portbdata),a  
740d			;ld a, 64  
740d			;out (portbdata),a  
740d 3e 80			ld a, 128  
740f 21 30 fe			ld hl, keyscan_table_row1  
7412 cd 6b 74			call .rowscan  
7415			  
7415			;ld a, 0  
7415			;out (portbdata),a  
7415 3e 40		ld a, 64  
7417 d3 c1		out (portbdata),a  
7419 3e 40			ld a, 64  
741b 21 25 fe			ld hl, keyscan_table_row2  
741e cd 6b 74			call .rowscan  
7421			  
7421 3e 00		ld a, 0  
7423 d3 c1		out (portbdata),a  
7425			;ld a, 64  
7425			;out (portbdata),a  
7425 3e 20			ld a, 32  
7427 21 1a fe			ld hl, keyscan_table_row3  
742a cd 6b 74			call .rowscan  
742d			  
742d			;ld a, 0  
742d			;out (portbdata),a  
742d 3e 40		ld a, 64  
742f d3 c1		out (portbdata),a  
7431 3e 10			ld a, 16  
7433 21 0f fe			ld hl, keyscan_table_row4  
7436 cd 6b 74			call .rowscan  
7439			  
7439			; Display text on first line  
7439 3e 00		            LD   A, kLCD_Line1  
743b cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
743e 11 30 fe		            LD   DE, keyscan_table_row1  
7441			            ;LD   DE, MsgHello  
7441 cd 95 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7444			  
7444			; Display text on second line  
7444 3e 28		            LD   A, kLCD_Line2  
7446 cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7449 11 25 fe		            LD   DE, keyscan_table_row2  
744c cd 95 70		            CALL fLCD_Str       ;Display string pointed to by DE  
744f 3e 50		            LD   A, kLCD_Line3  
7451 cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7454 11 1a fe		            LD   DE, keyscan_table_row3  
7457 cd 95 70		            CALL fLCD_Str       ;Display string pointed to by DE  
745a 3e 78		            LD   A, kLCD_Line4  
745c cd 73 70		            CALL fLCD_Pos       ;Position cursor to location in A  
745f 11 0f fe		            LD   DE, keyscan_table_row4  
7462 cd 95 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7465			  
7465 cd d2 0c			call delay250ms  
7468 c3 56 73			jp matrix  
746b			  
746b			; pass de as row display flags  
746b			.rowscan:   
746b			;	out (portbdata),a  
746b db c1			in a,(portbdata)  
746d 4f				ld c,a  
746e				; reset flags for the row   
746e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7470 e6 01			and 1  
7472 28 02			jr z, .p1on  
7474 06 23			ld b,'#'  
7476			.p1on:  
7476 70				ld (hl), b  
7477 23				inc hl  
7478			  
7478 06 7e			ld b,KEY_MATRIX_NO_PRESS  
747a 79				ld a,c  
747b e6 02			and 2  
747d			;	bit 0,a  
747d 28 02			jr z, .p2on  
747f 06 23			ld b,'#'  
7481			.p2on:  
7481 70				ld (hl), b  
7482 23				inc hl  
7483			;  
7483 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7485 79				ld a,c  
7486 e6 04			and 4  
7488			;;	bit 0,a  
7488 28 02			jr z, .p3on  
748a 06 23			ld b,'#'  
748c			.p3on:  
748c 70				ld (hl), b  
748d 23				inc hl  
748e			;;  
748e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7490			;;	bit 0,a  
7490 79				ld a,c  
7491 e6 08			and 8  
7493 28 02			jr z, .p4on  
7495 06 23			ld b,'#'  
7497			.p4on:  
7497 70				ld (hl), b  
7498 23				inc hl  
7499			  
7499 06 7e			ld b,KEY_MATRIX_NO_PRESS  
749b			;;	bit 0,a  
749b 79				ld a,c  
749c e6 10			and 16  
749e 28 02			jr z, .p5on  
74a0 06 23			ld b,'#'  
74a2			.p5on:  
74a2 70				ld (hl), b  
74a3 23				inc hl  
74a4			; zero term  
74a4 06 00			ld b,0  
74a6 70				ld (hl), b  
74a7			  
74a7 c9			.rscandone: ret  
74a8			  
74a8			;addatohl:  
74a8			;  
74a8			 ;add   a, l    ; A = A+L  
74a8			  ;  ld    l, a    ; L = A+L  
74a8			   ; adc   a, h    ; A = A+L+H+carry  
74a8			   ; sub   l       ; A = H+carry  
74a8			   ; ld    h, a    ; H = H+carry  
74a8			  
74a8			;ret  
74a8			; eof  
# End of file firmware_key_5x10.asm
74a8			;include "firmware_key_4x10.asm" 
74a8			 
74a8			heap_size:    equ heap_end - heap_start 
74a8			;eof 
# End of file os_mega.asm
74a8
