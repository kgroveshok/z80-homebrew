# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 f2 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd d5 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd d5 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd d5 0a				call clear_display  
0023			  
0023			  
0023 cd f6 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 3f 66			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd ac 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd f8 0a			call update_display  
0032 cd 55 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd da 0a			call fill_display  
003a cd f8 0a			call update_display  
003d cd 55 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd da 0a			call fill_display  
0045 cd f8 0a			call update_display  
0048 cd 55 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd da 0a			call fill_display  
0050 cd f8 0a			call update_display  
0053 cd 55 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd e8 0a			call str_at_display  
005e cd f8 0a			call update_display  
0061			  
0061			  
0061 cd 55 0a			call delay1s  
0064 cd 55 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd e8 0a			call str_at_display  
006f cd f8 0a			call update_display  
0072 cd 55 0a			call delay1s  
0075 cd 55 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 3a 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 3a 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd c0 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 1c 17			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 1c 17			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2a 06			call storage_findnextid 
035d			 
035d cd 32 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 1c 17			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 1c 17			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 1c 17			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 1c 17			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 1c 17			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 18 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 1c 17			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 1c 17			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 3a 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 3a 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 09 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 3a 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 3a 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 09 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 1c 17			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 1c 17			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 1c 17			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 1c 17			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 e8 f9			ld de, store_page 
0572 cd 09 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 bd fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 be fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 bf fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd 1c 17			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a e8 f9			ld a, (store_page)	; get file id 
0594 32 e1 f9			ld (store_tmpid), a 
0597			 
0597 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059a 32 e0 f9			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 e8 f9			ld (store_page), a 
05a3 32 e9 f9			ld (store_page+1),a 
05a6 11 e8 f9			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 bd fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 be fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 bf fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd 1c 17			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 6e 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a e0 f9			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a e1 f9			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 bd fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 be fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 bf fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd 1c 17			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 e8 f9			ld de, store_page 
05f8 cd 09 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 e8 f9			ld (store_page), a 
0600 32 e9 f9			ld (store_page+1),a 
0603 11 e8 f9			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 bd fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 be fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 bf fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd 1c 17			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 6e 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 bd fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 be fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 bf fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd 1c 17			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 89 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 89 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd 27 0d				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd 09 0d				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 89 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 89 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd 27 0d				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd 09 0d				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 bd fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 be fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 bf fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd 1c 17			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 bd fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 be fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 bf fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd 1c 17			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 89 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd 09 0d				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 89 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd 09 0d				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 bd fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 be fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 bf fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd 1c 17			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd ba 03			call storage_get_block_0 
071a			 
071a 3a e8 f9			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 e8 f9			ld (store_page),a 
0721				 
0721 32 e1 f9			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 e8 f9			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd 1c 17			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 6e 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 e8 f9				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 bd fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 be fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 bf fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd 1c 17			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 bd fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 be fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 bf fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd 1c 17			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 d2 f9			ld (store_tmppageid), hl 
0793				 
0793 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 e8 f9			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 e9 f9			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 bd fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 be fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 bf fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd 1c 17			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 72 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 bd fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 be fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 bf fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd 1c 17			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 bd fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 be fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 bf fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 1c 17			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a d2 f9			ld hl,(store_tmppageid) 
0809 11 e8 f9			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 bd fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 be fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 bf fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd 1c 17			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 6e 03			call storage_write_block 
082b			 
082b 3a e1 f9			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 bd fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 be fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 bf fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd 1c 17			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			 
084e			.sr_fail: 
084e d1				pop de 
084f c9				ret 
0850			 
0850			storage_read: 
0850 d5				push de 
0851			 
0851			; TODO BUG the above push is it popped before the RET Z? 
0851			 
0851			; TODO how to handle multiple part blocks 
0851			 
0851				; locate file extent to read 
0851			 
0851 5c				ld e, h 
0852 55				ld d, l 
0853 21 40 00			ld hl, STORE_BLOCK_PHY 
0856				if DEBUG_STORESE 
0856					DMARK "SRE" 
0856 f5				push af  
0857 3a 6b 08			ld a, (.dmark)  
085a 32 bd fb			ld (debug_mark),a  
085d 3a 6c 08			ld a, (.dmark+1)  
0860 32 be fb			ld (debug_mark+1),a  
0863 3a 6d 08			ld a, (.dmark+2)  
0866 32 bf fb			ld (debug_mark+2),a  
0869 18 03			jr .pastdmark  
086b ..			.dmark: db "SRE"  
086e f1			.pastdmark: pop af  
086f			endm  
# End of macro DMARK
086f					CALLMONITOR 
086f cd 1c 17			call break_point_state  
0872				endm  
# End of macro CALLMONITOR
0872				endif 
0872 cd 2a 06			call storage_findnextid 
0875			 
0875				if DEBUG_STORESE 
0875					DMARK "SRf" 
0875 f5				push af  
0876 3a 8a 08			ld a, (.dmark)  
0879 32 bd fb			ld (debug_mark),a  
087c 3a 8b 08			ld a, (.dmark+1)  
087f 32 be fb			ld (debug_mark+1),a  
0882 3a 8c 08			ld a, (.dmark+2)  
0885 32 bf fb			ld (debug_mark+2),a  
0888 18 03			jr .pastdmark  
088a ..			.dmark: db "SRf"  
088d f1			.pastdmark: pop af  
088e			endm  
# End of macro DMARK
088e					CALLMONITOR 
088e cd 1c 17			call break_point_state  
0891				endm  
# End of macro CALLMONITOR
0891				endif 
0891 cd 32 0d			call ishlzero 
0894			;	ld a, l 
0894			;	add h 
0894			;	cp 0 
0894 28 b8			jr z,.sr_fail			; block not found so EOF 
0896			 
0896				; hl contains page number to load 
0896 d1				pop de   ; get storage 
0897 d5				push de 
0898				if DEBUG_STORESE 
0898					DMARK "SRg" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 bd fb			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 be fb			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 bf fb			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SRg"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd 1c 17			call break_point_state  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd 09 03			call storage_read_block 
08b7			 
08b7			 
08b7			; TODO if block has no zeros then need to read next block  
08b7			 
08b7			 
08b7					 
08b7 e1				pop hl 		 ; return start of data to show as not EOF 
08b8 23				inc hl   ; past file id 
08b9 23				inc hl   ; past ext 
08ba				if DEBUG_STORESE 
08ba					DMARK "SRe" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 bd fb			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 be fb			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 bf fb			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SRe"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd 1c 17			call break_point_state  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6 c9					ret 
08d7			 
08d7			 
08d7			 
08d7			; 
08d7			; Append File 
08d7			; 
08d7			; hl - file id to locate 
08d7			; de - pointer to (multi block) string to write 
08d7			 
08d7			 
08d7			storage_append: 
08d7				; hl -  file id to append to 
08d7				; de - string to append 
08d7			 
08d7 d5				push de 
08d8				 
08d8				if DEBUG_STORESE 
08d8					DMARK "AP1" 
08d8 f5				push af  
08d9 3a ed 08			ld a, (.dmark)  
08dc 32 bd fb			ld (debug_mark),a  
08df 3a ee 08			ld a, (.dmark+1)  
08e2 32 be fb			ld (debug_mark+1),a  
08e5 3a ef 08			ld a, (.dmark+2)  
08e8 32 bf fb			ld (debug_mark+2),a  
08eb 18 03			jr .pastdmark  
08ed ..			.dmark: db "AP1"  
08f0 f1			.pastdmark: pop af  
08f1			endm  
# End of macro DMARK
08f1					CALLMONITOR 
08f1 cd 1c 17			call break_point_state  
08f4				endm  
# End of macro CALLMONITOR
08f4				endif 
08f4			 
08f4 7d				ld a, l 
08f5 32 e1 f9			ld (store_tmpid), a 
08f8			 
08f8				; get file header  
08f8			 
08f8 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fa 3a e1 f9			ld a, (store_tmpid) 
08fd 5f				ld e, a 
08fe			 
08fe 21 40 00				ld hl, STORE_BLOCK_PHY 
0901 cd 2a 06				call storage_findnextid 
0904			 
0904 22 d2 f9			ld (store_tmppageid), hl 
0907			 
0907				; TODO handle file id not found 
0907			 
0907				if DEBUG_STORESE 
0907					DMARK "AP2" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 bd fb			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 be fb			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 bf fb			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "AP2"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 1c 17			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923			 
0923				; update file extent count 
0923			 
0923 11 e8 f9			ld de, store_page 
0926			 
0926 cd 09 03			call storage_read_block 
0929			 
0929				if DEBUG_STORESE 
0929					DMARK "AP3" 
0929 f5				push af  
092a 3a 3e 09			ld a, (.dmark)  
092d 32 bd fb			ld (debug_mark),a  
0930 3a 3f 09			ld a, (.dmark+1)  
0933 32 be fb			ld (debug_mark+1),a  
0936 3a 40 09			ld a, (.dmark+2)  
0939 32 bf fb			ld (debug_mark+2),a  
093c 18 03			jr .pastdmark  
093e ..			.dmark: db "AP3"  
0941 f1			.pastdmark: pop af  
0942			endm  
# End of macro DMARK
0942					CALLMONITOR 
0942 cd 1c 17			call break_point_state  
0945				endm  
# End of macro CALLMONITOR
0945				endif 
0945			;	ld (store_tmppageid), hl 
0945			 
0945 3a ea f9			ld a, (store_page+2) 
0948 3c				inc a 
0949 32 ea f9			ld (store_page+2), a 
094c 32 e0 f9			ld (store_tmpext), a 
094f				 
094f				if DEBUG_STORESE 
094f					DMARK "AP3" 
094f f5				push af  
0950 3a 64 09			ld a, (.dmark)  
0953 32 bd fb			ld (debug_mark),a  
0956 3a 65 09			ld a, (.dmark+1)  
0959 32 be fb			ld (debug_mark+1),a  
095c 3a 66 09			ld a, (.dmark+2)  
095f 32 bf fb			ld (debug_mark+2),a  
0962 18 03			jr .pastdmark  
0964 ..			.dmark: db "AP3"  
0967 f1			.pastdmark: pop af  
0968			endm  
# End of macro DMARK
0968					CALLMONITOR 
0968 cd 1c 17			call break_point_state  
096b				endm  
# End of macro CALLMONITOR
096b				endif 
096b 2a d2 f9			ld hl, (store_tmppageid) 
096e 11 e8 f9			ld de, store_page 
0971 cd 6e 03			call storage_write_block 
0974			 
0974				; find free block 
0974			 
0974 11 00 00			ld de, 0			 ; file extent to locate 
0977			 
0977 21 40 00				ld hl, STORE_BLOCK_PHY 
097a cd 2a 06				call storage_findnextid 
097d			 
097d					; TODO handle no space left 
097d					 
097d 22 d2 f9				ld (store_tmppageid), hl 
0980			 
0980				if DEBUG_STORESE 
0980					DMARK "AP4" 
0980 f5				push af  
0981 3a 95 09			ld a, (.dmark)  
0984 32 bd fb			ld (debug_mark),a  
0987 3a 96 09			ld a, (.dmark+1)  
098a 32 be fb			ld (debug_mark+1),a  
098d 3a 97 09			ld a, (.dmark+2)  
0990 32 bf fb			ld (debug_mark+2),a  
0993 18 03			jr .pastdmark  
0995 ..			.dmark: db "AP4"  
0998 f1			.pastdmark: pop af  
0999			endm  
# End of macro DMARK
0999					CALLMONITOR 
0999 cd 1c 17			call break_point_state  
099c				endm  
# End of macro CALLMONITOR
099c				endif 
099c					; init the buffer with zeros so we can id if the buffer is full or not 
099c			 
099c e5					push hl 
099d c5					push bc 
099e			 
099e 21 e8 f9				ld hl, store_page 
09a1 06 40				ld b, STORE_BLOCK_PHY 
09a3 3e 00				ld a, 0 
09a5 77			.zeroblock:	ld (hl), a 
09a6 23					inc hl 
09a7 10 fc				djnz .zeroblock 
09a9			 
09a9 c1					pop bc 
09aa e1					pop hl 
09ab			 
09ab					; construct block 
09ab			 
09ab 3a e1 f9				ld a, (store_tmpid) 
09ae 32 e8 f9				ld (store_page), a   ; file id 
09b1 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09b4 32 e9 f9				ld (store_page+1), a 
09b7			 
09b7 e1					pop hl    ; get string to write 
09b8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09ba 11 ea f9				ld de, store_page+2 
09bd			 
09bd				if DEBUG_STORESE 
09bd					DMARK "AP5" 
09bd f5				push af  
09be 3a d2 09			ld a, (.dmark)  
09c1 32 bd fb			ld (debug_mark),a  
09c4 3a d3 09			ld a, (.dmark+1)  
09c7 32 be fb			ld (debug_mark+1),a  
09ca 3a d4 09			ld a, (.dmark+2)  
09cd 32 bf fb			ld (debug_mark+2),a  
09d0 18 03			jr .pastdmark  
09d2 ..			.dmark: db "AP5"  
09d5 f1			.pastdmark: pop af  
09d6			endm  
# End of macro DMARK
09d6					CALLMONITOR 
09d6 cd 1c 17			call break_point_state  
09d9				endm  
# End of macro CALLMONITOR
09d9				endif 
09d9			 
09d9			 
09d9			 
09d9					; fill buffer with data until end of string or full block 
09d9			 
09d9 7e			.appd:		ld a, (hl) 
09da 12					ld (de), a 
09db fe 00				cp 0 
09dd 28 04				jr z, .appdone 
09df 23					inc hl 
09e0 13					inc de 
09e1 10 f6				djnz .appd 
09e3			 
09e3 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e4 f5					push af   		; save last byte dumped 
09e5			 
09e5			 
09e5 2a d2 f9			ld hl, (store_tmppageid) 
09e8 11 e8 f9			ld de, store_page 
09eb				if DEBUG_STORESE 
09eb					DMARK "AP6" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 bd fb			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 be fb			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 bf fb			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "AP6"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 1c 17			call break_point_state  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd 6e 03				call storage_write_block 
0a0a			 
0a0a			 
0a0a				; was that a full block of data written? 
0a0a				; any more to write out? 
0a0a			 
0a0a				; if yes then set vars and jump to start of function again 
0a0a			 
0a0a f1					pop af 
0a0b d1					pop de 
0a0c			 
0a0c fe 00				cp 0		 ; no, string was fully written 
0a0e c8					ret z 
0a0f			 
0a0f					; setup vars for next cycle 
0a0f			 
0a0f 3a e1 f9				ld a, (store_tmpid) 
0a12 6f					ld l, a 
0a13 26 00				ld h, 0 
0a15			 
0a15 c3 d7 08			 	jp storage_append	 ; yes, need to write out some more 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			 
0a18			if DEBUG_STORECF 
0a18			storageput:	 
0a18					ret 
0a18			storageread: 
0a18					ld hl, store_page 
0a18					ld b, 200 
0a18					ld a,0 
0a18			.src:		ld (hl),a 
0a18					inc hl 
0a18					djnz .src 
0a18					 
0a18			 
0a18					ld de, 0 
0a18					ld bc, 1 
0a18					ld hl, store_page 
0a18					call cfRead 
0a18			 
0a18				call cfGetError 
0a18				ld hl,scratch 
0a18				call hexout 
0a18				ld hl, scratch+2 
0a18				ld a, 0 
0a18				ld (hl),a 
0a18				ld de, scratch 
0a18				ld a,display_row_1 
0a18				call str_at_display 
0a18				call update_display 
0a18			 
0a18					ld hl, store_page 
0a18					ld (os_cur_ptr),hl 
0a18			 
0a18					ret 
0a18			endif 
0a18			 
0a18			 
0a18			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a18			 
0a18			storage_clear_page: 
0a18 e5				push hl 
0a19 d5				push de 
0a1a c5				push bc 
0a1b 21 e8 f9			ld hl, store_page 
0a1e 3e 00			ld a, 0 
0a20 77				ld (hl), a 
0a21			 
0a21 11 e9 f9			ld de, store_page+1 
0a24 01 40 00			ld bc, STORE_BLOCK_PHY 
0a27			 
0a27 ed b0			ldir 
0a29				 
0a29 c1				pop bc 
0a2a d1				pop de 
0a2b e1				pop hl 
0a2c c9				ret 
0a2d			 
0a2d			; eof 
# End of file firmware_storage.asm
0a2d			  
0a2d			; support routines for above hardware abstraction layer  
0a2d			  
0a2d			include "firmware_general.asm"        ; general support functions  
0a2d			 
0a2d			; word look up 
0a2d			 
0a2d			; in 
0a2d			; a is the index 
0a2d			; hl is pointer start of array 
0a2d			; 
0a2d			; returns 
0a2d			; hl to the word 
0a2d			; 
0a2d			 
0a2d			table_lookup:  
0a2d d5					push de 
0a2e eb					ex de, hl 
0a2f			 
0a2f 6f					ld l, a 
0a30 26 00				ld h, 0 
0a32 29					add hl, hl 
0a33 19					add hl, de 
0a34 7e					ld a, (hl) 
0a35 23					inc hl 
0a36 66					ld h,(hl) 
0a37 6f					ld l, a 
0a38			 
0a38 d1					pop de 
0a39 c9					ret 
0a3a			 
0a3a			; Delay loops 
0a3a			 
0a3a			 
0a3a			 
0a3a			aDelayInMS: 
0a3a c5				push bc 
0a3b 47				ld b,a 
0a3c			msdelay: 
0a3c c5				push bc 
0a3d				 
0a3d			 
0a3d 01 41 00			ld bc,041h 
0a40 cd 58 0a			call delayloop 
0a43 c1				pop bc 
0a44 05				dec b 
0a45 20 f5			jr nz,msdelay 
0a47			 
0a47			;if CPU_CLOCK_8MHZ 
0a47			;msdelay8: 
0a47			;	push bc 
0a47			;	 
0a47			; 
0a47			;	ld bc,041h 
0a47			;	call delayloop 
0a47			;	pop bc 
0a47			;	dec b 
0a47			;	jr nz,msdelay8 
0a47			;endif 
0a47			 
0a47			 
0a47 c1				pop bc 
0a48 c9				ret 
0a49			 
0a49			 
0a49			delay250ms: 
0a49				;push de 
0a49 01 00 40			ld bc, 04000h 
0a4c c3 58 0a			jp delayloop 
0a4f			delay500ms: 
0a4f				;push de 
0a4f 01 00 80			ld bc, 08000h 
0a52 c3 58 0a			jp delayloop 
0a55			delay1s: 
0a55				;push bc 
0a55			   ; Clobbers A, d and e 
0a55 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a58			delayloop: 
0a58 c5			    push bc 
0a59			 
0a59			if BASE_CPM 
0a59				ld bc, CPM_DELAY_TUNE 
0a59			.cpmloop: 
0a59				push bc 
0a59			 
0a59			endif 
0a59			 
0a59			 
0a59			 
0a59			delayloopi: 
0a59			;	push bc 
0a59			;.dl: 
0a59 cb 47		    bit     0,a    	; 8 
0a5b cb 47		    bit     0,a    	; 8 
0a5d cb 47		    bit     0,a    	; 8 
0a5f e6 ff		    and     255  	; 7 
0a61 0b			    dec     bc      	; 6 
0a62 79			    ld      a,c     	; 4 
0a63 b0			    or      b     	; 4 
0a64 c2 59 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a67			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a67				;pop de 
0a67			;pop bc 
0a67			 
0a67			if BASE_CPM 
0a67				pop bc 
0a67				 
0a67			    dec     bc      	; 6 
0a67			    ld      a,c     	; 4 
0a67			    or      b     	; 4 
0a67			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a67				 
0a67			 
0a67			endif 
0a67			;if CPU_CLOCK_8MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67			 
0a67			;if CPU_CLOCK_10MHZ 
0a67			;    pop bc 
0a67			;    push bc 
0a67			;.dl8: 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    bit     0,a    	; 8 
0a67			;    and     255  	; 7 
0a67			;    dec     bc      	; 6 
0a67			;    ld      a,c     	; 4 
0a67			;    or      b     	; 4 
0a67			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a67			;endif 
0a67 c1			    pop bc 
0a68			 
0a68 c9				ret 
0a69			 
0a69			 
0a69			 
0a69			; eof 
# End of file firmware_general.asm
0a69			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a69			; display routines that use the physical hardware abstraction layer 
0a69			 
0a69			 
0a69			; information window 
0a69			 
0a69			; pass hl with 1st string to display 
0a69			; pass de with 2nd string to display 
0a69			 
0a69			info_panel: 
0a69 e5				push hl 
0a6a			 
0a6a 2a 5e fa			ld hl, (display_fb_active) 
0a6d e5				push hl    ; future de destination 
0a6e 21 53 fb				ld hl, display_fb0 
0a71 22 5e fa				ld (display_fb_active), hl 
0a74			 
0a74 cd d5 0a			call clear_display 
0a77			 
0a77			 
0a77 3e 2d			ld a, display_row_3 + 5 
0a79 cd e8 0a			call str_at_display 
0a7c			 
0a7c e1				pop hl 
0a7d d1				pop de 
0a7e			 
0a7e e5				push hl 
0a7f			 
0a7f			 
0a7f 3e 19			ld a, display_row_2 + 5 
0a81 cd e8 0a			call str_at_display 
0a84			 
0a84			 
0a84 cd f8 0a			call update_display 
0a87 cd 24 1c			call next_page_prompt 
0a8a cd d5 0a			call clear_display 
0a8d			 
0a8d				 
0a8d 21 02 fb				ld hl, display_fb1 
0a90 22 5e fa				ld (display_fb_active), hl 
0a93 cd f8 0a			call update_display 
0a96			 
0a96			 
0a96 c9				ret 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			; TODO windowing? 
0a97			 
0a97			; TODO scroll line up 
0a97			 
0a97			scroll_up: 
0a97			 
0a97 e5				push hl 
0a98 d5				push de 
0a99 c5				push bc 
0a9a			 
0a9a				; get frame buffer  
0a9a			 
0a9a 2a 5e fa			ld hl, (display_fb_active) 
0a9d e5				push hl    ; future de destination 
0a9e			 
0a9e 11 14 00			ld  de, display_cols 
0aa1 19				add hl, de 
0aa2			 
0aa2 d1				pop de 
0aa3			 
0aa3				;ex de, hl 
0aa3 01 4f 00			ld bc, display_fb_len -1  
0aa6			;if DEBUG_FORTH_WORDS 
0aa6			;	DMARK "SCL" 
0aa6			;	CALLMONITOR 
0aa6			;endif	 
0aa6 ed b0			ldir 
0aa8			 
0aa8				; wipe bottom row 
0aa8			 
0aa8			 
0aa8 2a 5e fa			ld hl, (display_fb_active) 
0aab 11 50 00			ld de, display_cols*display_rows 
0aae 19				add hl, de 
0aaf 06 14			ld b, display_cols 
0ab1 3e 20			ld a, ' ' 
0ab3			.scwipe: 
0ab3 77				ld (hl), a 
0ab4 2b				dec hl 
0ab5 10 fc			djnz .scwipe 
0ab7			 
0ab7				;pop hl 
0ab7			 
0ab7 c1				pop bc 
0ab8 d1				pop de 
0ab9 e1				pop hl 
0aba			 
0aba c9				ret 
0abb			 
0abb			 
0abb			;scroll_upo: 
0abb			;	ld de, display_row_1 
0abb			 ;	ld hl, display_row_2 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_2 
0abb			 ;	ld hl, display_row_3 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			;	ld de, display_row_3 
0abb			 ;	ld hl, display_row_4 
0abb			;	ld bc, display_cols 
0abb			;	ldir 
0abb			 
0abb			; TODO clear row 4 
0abb			 
0abb			;	ret 
0abb			 
0abb				 
0abb			scroll_down: 
0abb			 
0abb e5				push hl 
0abc d5				push de 
0abd c5				push bc 
0abe			 
0abe				; get frame buffer  
0abe			 
0abe 2a 5e fa			ld hl, (display_fb_active) 
0ac1			 
0ac1 11 4f 00			ld de, display_fb_len - 1 
0ac4 19				add hl, de 
0ac5			 
0ac5 e5			push hl    ; future de destination 
0ac6			 
0ac6 11 14 00			ld  de, display_cols 
0ac9 ed 52			sbc hl, de 
0acb			 
0acb			 
0acb d1				pop de 
0acc			 
0acc			;	ex de, hl 
0acc 01 4f 00			ld bc, display_fb_len -1  
0acf			 
0acf			 
0acf				 
0acf			 
0acf ed b0			ldir 
0ad1			 
0ad1				; wipe bottom row 
0ad1			 
0ad1			 
0ad1			;	ld hl, (display_fb_active) 
0ad1			;;	ld de, display_cols*display_rows 
0ad1			;;	add hl, de 
0ad1			;	ld b, display_cols 
0ad1			;	ld a, ' ' 
0ad1			;.scwiped: 
0ad1			;	ld (hl), a 
0ad1			;	dec hl 
0ad1			;	djnz .scwiped 
0ad1			 
0ad1				;pop hl 
0ad1			 
0ad1 c1				pop bc 
0ad2 d1				pop de 
0ad3 e1				pop hl 
0ad4			 
0ad4 c9				ret 
0ad5			;scroll_down: 
0ad5			;	ld de, display_row_4 
0ad5			;	ld hl, display_row_3 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_3 
0ad5			; 	ld hl, display_row_2 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;	ld de, display_row_2 
0ad5			;	ld hl, display_row_1 
0ad5			;	ld bc, display_cols 
0ad5			;	ldir 
0ad5			;;; TODO clear row 1 
0ad5			;	ret 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			 
0ad5			; clear active frame buffer 
0ad5			 
0ad5			clear_display: 
0ad5 3e 20			ld a, ' ' 
0ad7 c3 da 0a			jp fill_display 
0ada			 
0ada			; fill active frame buffer with a char in A 
0ada			 
0ada			fill_display: 
0ada 06 50			ld b,display_fb_len 
0adc 2a 5e fa			ld hl, (display_fb_active) 
0adf 77			.fd1:	ld (hl),a 
0ae0 23				inc hl 
0ae1 10 fc			djnz .fd1 
0ae3 23				inc hl 
0ae4 3e 00			ld a,0 
0ae6 77				ld (hl),a 
0ae7			 
0ae7			 
0ae7 c9				ret 
0ae8			; Write string (DE) at pos (A) to active frame buffer 
0ae8			 
0ae8 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0aeb 06 00					ld b,0 
0aed 4f					ld c,a 
0aee 09					add hl,bc 
0aef 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0af0 b7			            OR   A              ;Null terminator? 
0af1 c8			            RET  Z              ;Yes, so finished 
0af2 77					ld (hl),a 
0af3 23				inc hl 
0af4 13			            INC  DE             ;Point to next character 
0af5 18 f8		            JR   .sad1     ;Repeat 
0af7 c9					ret 
0af8			 
0af8			; using current frame buffer write to physical display 
0af8			 
0af8			update_display: 
0af8 e5				push hl 
0af9 2a 5e fa			ld hl, (display_fb_active) 
0afc cd 15 65			call write_display 
0aff e1				pop hl 
0b00 c9				ret 
0b01			 
0b01			; TODO scrolling 
0b01			 
0b01			 
0b01			; move cursor right one char 
0b01			cursor_right: 
0b01			 
0b01				; TODO shift right 
0b01				; TODO if beyond max col 
0b01				; TODO       cursor_next_line 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cursor_next_line: 
0b02				; TODO first char 
0b02				; TODO line down 
0b02				; TODO if past last row 
0b02				; TODO    scroll up 
0b02			 
0b02 c9				ret 
0b03			 
0b03			cursor_left: 
0b03				; TODO shift left 
0b03				; TODO if beyond left  
0b03				; TODO     cursor prev line 
0b03				 
0b03 c9				ret 
0b04			 
0b04			cursor_prev_line: 
0b04				; TODO last char 
0b04				; TODO line up 
0b04				; TODO if past first row 
0b04				; TODO   scroll down 
0b04			 
0b04 c9				ret 
0b05			 
0b05			 
0b05			cout: 
0b05				; A - char 
0b05 c9				ret 
0b06			 
0b06			 
0b06			; Display a menu and allow item selection (optional toggle items) 
0b06			; 
0b06			; format: 
0b06			; hl pointer to word array with zero term for items 
0b06			; e.g.    db item1 
0b06			;         db .... 
0b06			;         db 0 
0b06			; 
0b06			; a = starting menu item  
0b06			; 
0b06			; de = pointer item toggle array   (todo) 
0b06			; 
0b06			; returns item selected in a 1-... 
0b06			; returns 0 if back button pressed 
0b06			; 
0b06			; NOTE: Uses system frame buffer to display 
0b06			; 
0b06			; LEFT, Q = go back 
0b06			; RIGHT, SPACE, CR = select 
0b06			; UP, A - Up 
0b06			; DOWN, Z - Down 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			 
0b06			menu: 
0b06			 
0b06					; keep array pointer 
0b06			 
0b06 22 e6 f9				ld (store_tmp1), hl 
0b09 32 e4 f9				ld (store_tmp2), a 
0b0c			 
0b0c					; check for key bounce 
0b0c			 
0b0c			if BASE_KEV 
0b0c			 
0b0c cd ca 66		.mbounce:	call cin 
0b0f fe 00				cp 0 
0b11 20 f9				jr nz, .mbounce 
0b13			endif 
0b13					; for ease use ex 
0b13			 
0b13					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b13 21 53 fb				ld hl, display_fb0 
0b16 22 5e fa				ld (display_fb_active), hl 
0b19			 
0b19 cd d5 0a		.mloop:		call clear_display 
0b1c cd f8 0a				call update_display 
0b1f			 
0b1f					; draw selection id '>' at 1 
0b1f			 
0b1f					; init start of list display 
0b1f			 
0b1f 3e 05				ld a, 5 
0b21 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b24 3a e4 f9				ld a,( store_tmp2) 
0b27 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b2a			 
0b2a					 
0b2a			.mitem:	 
0b2a			 
0b2a			 
0b2a 3a e5 f9				ld a,(store_tmp2+1) 
0b2d 6f					ld l, a 
0b2e 26 00				ld h, 0 
0b30 29					add hl, hl 
0b31 ed 5b e6 f9			ld de, (store_tmp1) 
0b35 19					add hl, de 
0b36 7e					ld a, (hl) 
0b37 23					inc hl 
0b38 66					ld h,(hl) 
0b39 6f					ld l, a 
0b3a			 
0b3a cd 32 0d				call ishlzero 
0b3d 28 1a				jr z, .mdone 
0b3f			 
0b3f eb					ex de, hl 
0b40 3a e2 f9				ld a, (store_tmp3) 
0b43 cd e8 0a				call str_at_display 
0b46					 
0b46			 
0b46					; next item 
0b46 3a e5 f9				ld a, (store_tmp2+1) 
0b49 3c					inc a 
0b4a 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b4d			 
0b4d			 		; next row 
0b4d			 
0b4d 3a e2 f9				ld a, (store_tmp3) 
0b50 c6 14				add display_cols 
0b52 32 e2 f9				ld (store_tmp3), a 
0b55			 
0b55					; at end of screen? 
0b55			 
0b55 fe 10				cp display_rows*4 
0b57 20 d1				jr nz, .mitem 
0b59			 
0b59			 
0b59			.mdone: 
0b59 cd 32 0d				call ishlzero 
0b5c 28 08				jr z, .nodn 
0b5e			 
0b5e 3e 3c				ld a, display_row_4 
0b60 11 df 0b				ld de, .mdown 
0b63 cd e8 0a				call str_at_display 
0b66			 
0b66					; draw options to fill the screens with active item on line 1 
0b66					; if current option is 2 or more then display ^ in top 
0b66			 
0b66 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b69 fe 00				cp 0 
0b6b 28 08				jr z, .noup 
0b6d			 
0b6d 3e 00				ld a, 0 
0b6f 11 dd 0b				ld de, .mup 
0b72 cd e8 0a				call str_at_display 
0b75			 
0b75 3e 02		.noup:		ld a, 2 
0b77 11 db 0b				ld de, .msel 
0b7a cd e8 0a				call str_at_display 
0b7d			 
0b7d					; if current option + 1 is not null then display V in bottom 
0b7d					; get key 
0b7d cd f8 0a				call update_display 
0b80			 
0b80			 
0b80					; handle key 
0b80			 
0b80 cd b9 66				call cin_wait 
0b83			 
0b83 fe 05				cp KEY_UP 
0b85 28 2b				jr z, .mgoup 
0b87 fe 61				cp 'a' 
0b89 28 27				jr z, .mgoup 
0b8b fe 0a				cp KEY_DOWN 
0b8d 28 32				jr z, .mgod 
0b8f fe 7a				cp 'z' 
0b91 28 2e				jr z, .mgod 
0b93 fe 20				cp ' ' 
0b95 28 34				jr z, .goend 
0b97 fe 0c				cp KEY_RIGHT 
0b99 28 30				jr z, .goend 
0b9b fe 0d				cp KEY_CR 
0b9d 28 2c				jr z, .goend 
0b9f fe 71				cp 'q' 
0ba1 28 0b				jr z, .goback 
0ba3			 
0ba3 fe 0b				cp KEY_LEFT 
0ba5 28 07				jr z, .goback 
0ba7 fe 08				cp KEY_BS 
0ba9 28 03				jr z, .goback 
0bab c3 19 0b				jp .mloop 
0bae			 
0bae			.goback: 
0bae 3e 00			ld a, 0 
0bb0 18 1d			jr .goend2 
0bb2			 
0bb2				; move up one 
0bb2			.mgoup: 
0bb2 3a e4 f9				ld a, (store_tmp2) 
0bb5 fe 00				cp 0 
0bb7 ca 19 0b				jp z, .mloop 
0bba 3d					dec a 
0bbb 32 e4 f9				ld (store_tmp2), a 
0bbe c3 19 0b				jp .mloop 
0bc1			 
0bc1				; move down one 
0bc1			.mgod: 
0bc1 3a e4 f9				ld a, (store_tmp2) 
0bc4 3c					inc a 
0bc5 32 e4 f9				ld (store_tmp2), a 
0bc8 c3 19 0b				jp .mloop 
0bcb			 
0bcb			 
0bcb			.goend: 
0bcb					; get selected item number 
0bcb			 
0bcb 3a e4 f9				ld a, (store_tmp2) 
0bce 3c					inc a 
0bcf			 
0bcf			.goend2: 
0bcf f5					push af 
0bd0			 
0bd0					; restore active fb 
0bd0					; TODO BUG assumes fb1 
0bd0			 
0bd0 21 02 fb				ld hl, display_fb1 
0bd3 22 5e fa				ld (display_fb_active), hl 
0bd6			 
0bd6					; restore main regs 
0bd6			 
0bd6			 
0bd6 cd f8 0a				call update_display 
0bd9			 
0bd9 f1					pop af 
0bda			 
0bda c9				ret 
0bdb			 
0bdb .. 00		.msel:   db ">",0 
0bdd .. 00		.mup:   db "^",0 
0bdf .. 00		.mdown:   db "v",0 
0be1			 
0be1			 
0be1			; eof 
0be1			 
# End of file firmware_display.asm
0be1			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0be1			; random number generators 
0be1			 
0be1			 
0be1			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0be1			 
0be1			 
0be1			;-----> Generate a random number 
0be1			; output a=answer 0<=a<=255 
0be1			; all registers are preserved except: af 
0be1			random: 
0be1 e5			        push    hl 
0be2 d5			        push    de 
0be3 2a 40 fa		        ld      hl,(randData) 
0be6 ed 5f		        ld      a,r 
0be8 57			        ld      d,a 
0be9 5e			        ld      e,(hl) 
0bea 19			        add     hl,de 
0beb 85			        add     a,l 
0bec ac			        xor     h 
0bed 22 40 fa		        ld      (randData),hl 
0bf0 d1			        pop     de 
0bf1 e1			        pop     hl 
0bf2 c9			        ret 
0bf3			 
0bf3			 
0bf3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf3			 
0bf3			 
0bf3			 
0bf3			;------LFSR------ 
0bf3			;James Montelongo 
0bf3			;optimized by Spencer Putt 
0bf3			;out: 
0bf3			; a = 8 bit random number 
0bf3			RandLFSR: 
0bf3 21 46 fa		        ld hl,LFSRSeed+4 
0bf6 5e			        ld e,(hl) 
0bf7 23			        inc hl 
0bf8 56			        ld d,(hl) 
0bf9 23			        inc hl 
0bfa 4e			        ld c,(hl) 
0bfb 23			        inc hl 
0bfc 7e			        ld a,(hl) 
0bfd 47			        ld b,a 
0bfe cb 13		        rl e  
0c00 cb 12			rl d 
0c02 cb 11		        rl c  
0c04 17				rla 
0c05 cb 13		        rl e  
0c07 cb 12			rl d 
0c09 cb 11		        rl c  
0c0b 17				rla 
0c0c cb 13		        rl e  
0c0e cb 12			rl d 
0c10 cb 11		        rl c  
0c12 17				rla 
0c13 67			        ld h,a 
0c14 cb 13		        rl e  
0c16 cb 12			rl d 
0c18 cb 11		        rl c  
0c1a 17				rla 
0c1b a8			        xor b 
0c1c cb 13		        rl e  
0c1e cb 12			rl d 
0c20 ac			        xor h 
0c21 a9			        xor c 
0c22 aa			        xor d 
0c23 21 48 fa		        ld hl,LFSRSeed+6 
0c26 11 49 fa		        ld de,LFSRSeed+7 
0c29 01 07 00		        ld bc,7 
0c2c ed b8		        lddr 
0c2e 12			        ld (de),a 
0c2f c9			        ret 
0c30			 
0c30			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c30			 
0c30			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c30			 
0c30			 
0c30			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c30			 
0c30			prng16: 
0c30			;Inputs: 
0c30			;   (seed1) contains a 16-bit seed value 
0c30			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c30			;Outputs: 
0c30			;   HL is the result 
0c30			;   BC is the result of the LCG, so not that great of quality 
0c30			;   DE is preserved 
0c30			;Destroys: 
0c30			;   AF 
0c30			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c30			;160cc 
0c30			;26 bytes 
0c30 2a 3a fa		    ld hl,(seed1) 
0c33 44			    ld b,h 
0c34 4d			    ld c,l 
0c35 29			    add hl,hl 
0c36 29			    add hl,hl 
0c37 2c			    inc l 
0c38 09			    add hl,bc 
0c39 22 3a fa		    ld (seed1),hl 
0c3c 2a 38 fa		    ld hl,(seed2) 
0c3f 29			    add hl,hl 
0c40 9f			    sbc a,a 
0c41 e6 2d		    and %00101101 
0c43 ad			    xor l 
0c44 6f			    ld l,a 
0c45 22 38 fa		    ld (seed2),hl 
0c48 09			    add hl,bc 
0c49 c9			    ret 
0c4a			 
0c4a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c4a			 
0c4a			rand32: 
0c4a			;Inputs: 
0c4a			;   (seed1_0) holds the lower 16 bits of the first seed 
0c4a			;   (seed1_1) holds the upper 16 bits of the first seed 
0c4a			;   (seed2_0) holds the lower 16 bits of the second seed 
0c4a			;   (seed2_1) holds the upper 16 bits of the second seed 
0c4a			;   **NOTE: seed2 must be non-zero 
0c4a			;Outputs: 
0c4a			;   HL is the result 
0c4a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c4a			;Destroys: 
0c4a			;   AF 
0c4a			;Tested and passes all CAcert tests 
0c4a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c4a			;it has a period of 18,446,744,069,414,584,320 
0c4a			;roughly 18.4 quintillion. 
0c4a			;LFSR taps: 0,2,6,7  = 11000101 
0c4a			;291cc 
0c4a			;seed1_0=$+1 
0c4a			;    ld hl,12345 
0c4a			;seed1_1=$+1 
0c4a			;    ld de,6789 
0c4a			;    ld b,h 
0c4a			;    ld c,l 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    add hl,hl \ rl e \ rl d 
0c4a			;    inc l 
0c4a			;    add hl,bc 
0c4a			;    ld (seed1_0),hl 
0c4a			;    ld hl,(seed1_1) 
0c4a			;    adc hl,de 
0c4a			;    ld (seed1_1),hl 
0c4a			;    ex de,hl 
0c4a			;seed2_0=$+1 
0c4a			;    ld hl,9876 
0c4a			;seed2_1=$+1 
0c4a			;    ld bc,54321 
0c4a			;    add hl,hl \ rl c \ rl b 
0c4a			;    ld (seed2_1),bc 
0c4a			;    sbc a,a 
0c4a			;    and %11000101 
0c4a			;    xor l 
0c4a			;    ld l,a 
0c4a			;    ld (seed2_0),hl 
0c4a			;    ex de,hl 
0c4a			;    add hl,bc 
0c4a			;    ret 
0c4a			; 
0c4a			 
0c4a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c4a			; 20 bytes, 86 cycles (excluding ret) 
0c4a			 
0c4a			; returns   hl = pseudorandom number 
0c4a			; corrupts   a 
0c4a			 
0c4a			; generates 16-bit pseudorandom numbers with a period of 65535 
0c4a			; using the xorshift method: 
0c4a			 
0c4a			; hl ^= hl << 7 
0c4a			; hl ^= hl >> 9 
0c4a			; hl ^= hl << 8 
0c4a			 
0c4a			; some alternative shift triplets which also perform well are: 
0c4a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c4a			 
0c4a			;  org 32768 
0c4a			 
0c4a			xrnd: 
0c4a 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c4d 3e 00		  ld a,0 
0c4f bd			  cp l 
0c50 20 02		  jr nz, .xrnd1 
0c52 2e 01		  ld l, 1 
0c54			.xrnd1: 
0c54			 
0c54 7c			  ld a,h 
0c55 1f			  rra 
0c56 7d			  ld a,l 
0c57 1f			  rra 
0c58 ac			  xor h 
0c59 67			  ld h,a 
0c5a 7d			  ld a,l 
0c5b 1f			  rra 
0c5c 7c			  ld a,h 
0c5d 1f			  rra 
0c5e ad			  xor l 
0c5f 6f			  ld l,a 
0c60 ac			  xor h 
0c61 67			  ld h,a 
0c62			 
0c62 22 3e fa		  ld (xrandc),hl 
0c65			 
0c65 c9			  ret 
0c66			;  
0c66			 
0c66			 
0c66			;;;; int maths 
0c66			 
0c66			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c66			; Divide 16-bit values (with 16-bit result) 
0c66			; In: Divide BC by divider DE 
0c66			; Out: BC = result, HL = rest 
0c66			; 
0c66			Div16: 
0c66 21 00 00		    ld hl,0 
0c69 78			    ld a,b 
0c6a 06 08		    ld b,8 
0c6c			Div16_Loop1: 
0c6c 17			    rla 
0c6d ed 6a		    adc hl,hl 
0c6f ed 52		    sbc hl,de 
0c71 30 01		    jr nc,Div16_NoAdd1 
0c73 19			    add hl,de 
0c74			Div16_NoAdd1: 
0c74 10 f6		    djnz Div16_Loop1 
0c76 17			    rla 
0c77 2f			    cpl 
0c78 47			    ld b,a 
0c79 79			    ld a,c 
0c7a 48			    ld c,b 
0c7b 06 08		    ld b,8 
0c7d			Div16_Loop2: 
0c7d 17			    rla 
0c7e ed 6a		    adc hl,hl 
0c80 ed 52		    sbc hl,de 
0c82 30 01		    jr nc,Div16_NoAdd2 
0c84 19			    add hl,de 
0c85			Div16_NoAdd2: 
0c85 10 f6		    djnz Div16_Loop2 
0c87 17			    rla 
0c88 2f			    cpl 
0c89 41			    ld b,c 
0c8a 4f			    ld c,a 
0c8b c9			ret 
0c8c			 
0c8c			 
0c8c			;http://z80-heaven.wikidot.com/math 
0c8c			; 
0c8c			;Inputs: 
0c8c			;     DE and A are factors 
0c8c			;Outputs: 
0c8c			;     A is not changed 
0c8c			;     B is 0 
0c8c			;     C is not changed 
0c8c			;     DE is not changed 
0c8c			;     HL is the product 
0c8c			;Time: 
0c8c			;     342+6x 
0c8c			; 
0c8c			Mult16: 
0c8c			 
0c8c 06 08		     ld b,8          ;7           7 
0c8e 21 00 00		     ld hl,0         ;10         10 
0c91 29			       add hl,hl     ;11*8       88 
0c92 07			       rlca          ;4*8        32 
0c93 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c95 19			         add hl,de   ;--         -- 
0c96 10 f9		       djnz $-5      ;13*7+8     99 
0c98 c9			ret 
0c99			 
0c99			; 
0c99			; Square root of 16-bit value 
0c99			; In:  HL = value 
0c99			; Out:  D = result (rounded down) 
0c99			; 
0c99			;Sqr16: 
0c99			;    ld de,#0040 
0c99			;    ld a,l 
0c99			;    ld l,h 
0c99			;    ld h,d 
0c99			;    or a 
0c99			;    ld b,8 
0c99			;Sqr16_Loop: 
0c99			;    sbc hl,de 
0c99			;    jr nc,Sqr16_Skip 
0c99			;    add hl,de 
0c99			;Sqr16_Skip: 
0c99			;    ccf 
0c99			;    rl d 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    add a,a 
0c99			;    adc hl,hl 
0c99			;    djnz Sqr16_Loop 
0c99			;    ret 
0c99			; 
0c99			; 
0c99			; Divide 8-bit values 
0c99			; In: Divide E by divider C 
0c99			; Out: A = result, B = rest 
0c99			; 
0c99			Div8: 
0c99 af			    xor a 
0c9a 06 08		    ld b,8 
0c9c			Div8_Loop: 
0c9c cb 13		    rl e 
0c9e 17			    rla 
0c9f 91			    sub c 
0ca0 30 01		    jr nc,Div8_NoAdd 
0ca2 81			    add a,c 
0ca3			Div8_NoAdd: 
0ca3 10 f7		    djnz Div8_Loop 
0ca5 47			    ld b,a 
0ca6 7b			    ld a,e 
0ca7 17			    rla 
0ca8 2f			    cpl 
0ca9 c9			    ret 
0caa			 
0caa			; 
0caa			; Multiply 8-bit value with a 16-bit value (unrolled) 
0caa			; In: Multiply A with DE 
0caa			; Out: HL = result 
0caa			; 
0caa			Mult12U: 
0caa 2e 00		    ld l,0 
0cac 87			    add a,a 
0cad 30 01		    jr nc,Mult12U_NoAdd0 
0caf 19			    add hl,de 
0cb0			Mult12U_NoAdd0: 
0cb0 29			    add hl,hl 
0cb1 87			    add a,a 
0cb2 30 01		    jr nc,Mult12U_NoAdd1 
0cb4 19			    add hl,de 
0cb5			Mult12U_NoAdd1: 
0cb5 29			    add hl,hl 
0cb6 87			    add a,a 
0cb7 30 01		    jr nc,Mult12U_NoAdd2 
0cb9 19			    add hl,de 
0cba			Mult12U_NoAdd2: 
0cba 29			    add hl,hl 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd3 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd3: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd4 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd4: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd5 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd5: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb 30 01		    jr nc,Mult12U_NoAdd6 
0ccd 19			    add hl,de 
0cce			Mult12U_NoAdd6: 
0cce 29			    add hl,hl 
0ccf 87			    add a,a 
0cd0 d0			    ret nc 
0cd1 19			    add hl,de 
0cd2 c9			    ret 
0cd3			 
0cd3			; 
0cd3			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd3			; In: Multiply A with DE 
0cd3			;      Put lowest value in A for most efficient calculation 
0cd3			; Out: HL = result 
0cd3			; 
0cd3			Mult12R: 
0cd3 21 00 00		    ld hl,0 
0cd6			Mult12R_Loop: 
0cd6 cb 3f		    srl a 
0cd8 30 01		    jr nc,Mult12R_NoAdd 
0cda 19			    add hl,de 
0cdb			Mult12R_NoAdd: 
0cdb cb 23		    sla e 
0cdd cb 12		    rl d 
0cdf b7			    or a 
0ce0 c2 d6 0c		    jp nz,Mult12R_Loop 
0ce3 c9			    ret 
0ce4			 
0ce4			; 
0ce4			; Multiply 16-bit values (with 32-bit result) 
0ce4			; In: Multiply BC with DE 
0ce4			; Out: BCHL = result 
0ce4			; 
0ce4			Mult32: 
0ce4 79			    ld a,c 
0ce5 48			    ld c,b 
0ce6 21 00 00		    ld hl,0 
0ce9 06 10		    ld b,16 
0ceb			Mult32_Loop: 
0ceb 29			    add hl,hl 
0cec 17			    rla 
0ced cb 11		    rl c 
0cef 30 07		    jr nc,Mult32_NoAdd 
0cf1 19			    add hl,de 
0cf2 ce 00		    adc a,0 
0cf4 d2 f8 0c		    jp nc,Mult32_NoAdd 
0cf7 0c			    inc c 
0cf8			Mult32_NoAdd: 
0cf8 10 f1		    djnz Mult32_Loop 
0cfa 41			    ld b,c 
0cfb 4f			    ld c,a 
0cfc c9			    ret 
0cfd			 
0cfd			 
0cfd			 
0cfd			; 
0cfd			; Multiply 8-bit values 
0cfd			; In:  Multiply H with E 
0cfd			; Out: HL = result 
0cfd			; 
0cfd			Mult8: 
0cfd 16 00		    ld d,0 
0cff 6a			    ld l,d 
0d00 06 08		    ld b,8 
0d02			Mult8_Loop: 
0d02 29			    add hl,hl 
0d03 30 01		    jr nc,Mult8_NoAdd 
0d05 19			    add hl,de 
0d06			Mult8_NoAdd: 
0d06 10 fa		    djnz Mult8_Loop 
0d08 c9			    ret 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			 
0d09			;;http://z80-heaven.wikidot.com/math 
0d09			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d09			; 
0d09			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d09			;     ld a,16        ;7 
0d09			;     ld hl,0        ;10 
0d09			;     jp $+5         ;10 
0d09			;.DivLoop: 
0d09			;       add hl,bc    ;-- 
0d09			;       dec a        ;64 
0d09			;       jr z,.DivLoopEnd        ;86 
0d09			; 
0d09			;       sla e        ;128 
0d09			;       rl d         ;128 
0d09			;       adc hl,hl    ;240 
0d09			;       sbc hl,bc    ;240 
0d09			;       jr nc,.DivLoop ;23|21 
0d09			;       inc e        ;-- 
0d09			;       jp .DivLoop+1 
0d09			; 
0d09			;.DivLoopEnd: 
0d09			 
0d09			;HL_Div_C: 
0d09			;Inputs: 
0d09			;     HL is the numerator 
0d09			;     C is the denominator 
0d09			;Outputs: 
0d09			;     A is the remainder 
0d09			;     B is 0 
0d09			;     C is not changed 
0d09			;     DE is not changed 
0d09			;     HL is the quotient 
0d09			; 
0d09			;       ld b,16 
0d09			;       xor a 
0d09			;         add hl,hl 
0d09			;         rla 
0d09			;         cp c 
0d09			;         jr c,$+4 
0d09			;           inc l 
0d09			;           sub c 
0d09			;         djnz $-7 
0d09			 
0d09			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d09			 
0d09			addatohl: 
0d09 85			    add   a, l    ; A = A+L 
0d0a 6f			    ld    l, a    ; L = A+L 
0d0b 8c			    adc   a, h    ; A = A+L+H+carry 
0d0c 95			    sub   l       ; A = H+carry 
0d0d 67			    ld    h, a    ; H = H+carry 
0d0e c9			ret 
0d0f			 
0d0f			addatode: 
0d0f 83			    add   a, e    ; A = A+L 
0d10 5f			    ld    e, a    ; L = A+L 
0d11 8a			    adc   a, d    ; A = A+L+H+carry 
0d12 93			    sub   e       ; A = H+carry 
0d13 57			    ld    d, a    ; H = H+carry 
0d14 c9			ret 
0d15			 
0d15			 
0d15			addatobc: 
0d15 81			    add   a, c    ; A = A+L 
0d16 4f			    ld    c, a    ; L = A+L 
0d17 88			    adc   a, b    ; A = A+L+H+carry 
0d18 91			    sub   c       ; A = H+carry 
0d19 47			    ld    b, a    ; H = H+carry 
0d1a c9			ret 
0d1b			 
0d1b			subafromhl: 
0d1b			   ; If A=0 do nothing 
0d1b			    ; Otherwise flip A's sign. Since 
0d1b			    ; the upper byte becomes -1, also 
0d1b			    ; substract 1 from H. 
0d1b ed 44		    neg 
0d1d ca 26 0d		    jp    z, Skip 
0d20 25			    dec   h 
0d21			     
0d21			    ; Now add the low byte as usual 
0d21			    ; Two's complement takes care of 
0d21			    ; ensuring the result is correct 
0d21 85			    add   a, l 
0d22 6f			    ld    l, a 
0d23 8c			    adc   a, h 
0d24 95			    sub   l 
0d25 67			    ld    h, a 
0d26			Skip: 
0d26 c9				ret 
0d27			 
0d27			 
0d27			; compare hl and de 
0d27			; returns:  
0d27			; if hl = de, z=1, s=0, c0=0 
0d27			; if hl > de, z=0, s=0, c=0 
0d27			; if hl < de, z=0, s=1, c=1 
0d27			cmp16:	 
0d27 b7				or a 
0d28 ed 52			sbc hl,de 
0d2a e0				ret po 
0d2b 7c				ld a,h 
0d2c 1f				rra 
0d2d ee 40			xor 01000000B 
0d2f 37				scf 
0d30 8f				adc a,a 
0d31 c9				ret 
0d32			 
0d32			 
0d32			; test if hl contains zero   - A is destroyed 
0d32			 
0d32			ishlzero:    
0d32 b7				or a     ; reset flags 
0d33 7c				ld a, h 
0d34 b5				or l        	 
0d35			 
0d35 c9				ret 
0d36			 
0d36			 
0d36			 
0d36			 
0d36			if FORTH_ENABLE_FLOATMATH 
0d36			;include "float/bbcmath.z80" 
0d36			include "float/lpfpcalc.asm" 
0d36			endif 
0d36			 
0d36			 
0d36			; eof 
0d36			 
# End of file firmware_maths.asm
0d36			include "firmware_strings.asm"   ; string handling  
0d36			 
0d36			 
0d36			; TODO string len 
0d36			; input text string, end on cr with zero term 
0d36			; a offset into frame buffer to start prompt 
0d36			; d is max length 
0d36			; e is display size TODO 
0d36			; c is current cursor position 
0d36			; hl is ptr to where string will be stored 
0d36			 
0d36			 
0d36			; TODO check limit of buffer for new inserts 
0d36			; TODO check insert does not push beyond buffer 
0d36			; TODO scroll in a limited display area 
0d36			; TODO scroll whole screen on page wrap 
0d36			 
0d36			 
0d36			; TODO handle KEY_PREVWORD 
0d36			; TODO handle KEY_NEXTWORD 
0d36			; TODO handle KEY_HOME 
0d36			; TODO handle KEY_END 
0d36			; TODO use LCD cursor? 
0d36			 
0d36 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d39 81					add c 
0d3a 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3d 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d40 79					ld a, c 
0d41 cd 09 0d				call addatohl 
0d44 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d47 7a					ld a,d 
0d48 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d4b 79					ld a, c 
0d4c 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d4f 7b					ld a,e 
0d50 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d53					 
0d53					 
0d53			 
0d53			;		ld a,(input_ptr) 
0d53			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d53			 
0d53			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d53					; init cursor shape if not set by the cin routines 
0d53 21 56 fa				ld hl, cursor_shape 
0d56 3e ff				ld a, 255 
0d58 77					ld (hl), a 
0d59 23					inc hl 
0d5a 3e 00				ld a, 0 
0d5c 77					ld (hl), a 
0d5d			 
0d5d 3e 0f				ld a, CUR_BLINK_RATE 
0d5f 32 b2 fb				ld (input_cur_flash), a 
0d62 3e 01				ld a, 1 
0d64 32 b1 fb				ld (input_cur_onoff),a 
0d67			 
0d67			;	if DEBUG_INPUT 
0d67			;		push af 
0d67			;		ld a, 'I' 
0d67			;		ld (debug_mark),a 
0d67			;		pop af 
0d67			;		CALLMONITOR 
0d67			;	endif 
0d67			.is1:		; main entry loop 
0d67			 
0d67			 
0d67			 
0d67					; pause 1ms 
0d67			 
0d67 3e 01				ld a, 1 
0d69 cd 3a 0a				call aDelayInMS 
0d6c			 
0d6c					; dec flash counter 
0d6c 3a b2 fb				ld a, (input_cur_flash) 
0d6f 3d					dec a 
0d70 32 b2 fb				ld (input_cur_flash), a 
0d73 fe 00				cp 0 
0d75 20 0d				jr nz, .nochgstate 
0d77			 
0d77			 
0d77					; change state 
0d77 3a b1 fb				ld a,(input_cur_onoff) 
0d7a ed 44				neg 
0d7c 32 b1 fb				ld (input_cur_onoff),a 
0d7f			 
0d7f			 
0d7f					; reset on change of state 
0d7f 3e 0f				ld a, CUR_BLINK_RATE 
0d81 32 b2 fb				ld (input_cur_flash), a 
0d84			 
0d84			.nochgstate: 
0d84					 
0d84					 
0d84			 
0d84					; display cursor  
0d84			 
0d84			;		ld hl, (input_start) 
0d84			;		ld a, (input_cursor) 
0d84			;		call addatohl 
0d84			 
0d84					; get char under cursor and replace with cursor 
0d84 2a bb fb		ld hl, (input_ptr) 
0d87			;		ld a, (hl) 
0d87			;		ld (input_under_cursor),a 
0d87			;		ld a, '_' 
0d87			;		ld (hl), a 
0d87			 
0d87					; display string 
0d87			 
0d87 ed 5b b9 fb			ld de, (input_start) 
0d8b 3a b6 fb				ld a, (input_at_pos) 
0d8e cd e8 0a				call str_at_display 
0d91			;	        call update_display 
0d91			 
0d91					; find place to put the cursor 
0d91			;		add h 
0d91			;		ld l, display_row_1 
0d91			;		sub l 
0d91			; (input_at_pos) 
0d91					;ld c, a 
0d91			;		ld a, (input_cursor) 
0d91			;		ld l, (input_at_pos) 
0d91			;		;ld b, h 
0d91			;		add l 
0d91			;		ld (input_at_cursor),a 
0d91					;ld l,h 
0d91			 
0d91			;		ld h, 0 
0d91			;		ld l,(input_at_pos) 
0d91			;		ld a, (input_cursor) 
0d91			;		call addatohl 
0d91			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d91			;		call subafromhl 
0d91			;		ld a,l 
0d91			;		ld (input_at_cursor), a 
0d91			 
0d91				if DEBUG_INPUT 
0d91					ld a, (hardware_diag) 
0d91					cp 0 
0d91					jr z, .skip_input_diag 
0d91			 
0d91					ld a,(input_at_pos) 
0d91					ld hl, LFSRSeed 
0d91					call hexout 
0d91					ld a, (input_cursor) 
0d91					ld hl, LFSRSeed+2 
0d91					call hexout 
0d91					ld a,(input_at_cursor) 
0d91					ld hl, LFSRSeed+4 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_onoff) 
0d91					ld hl, LFSRSeed+6 
0d91					call hexout 
0d91			 
0d91					ld a,(input_cur_flash) 
0d91					ld hl, LFSRSeed+8 
0d91					call hexout 
0d91			 
0d91					ld a,(input_len) 
0d91					ld hl, LFSRSeed+10 
0d91					call hexout 
0d91					ld hl, LFSRSeed+12 
0d91					ld a, 0 
0d91					ld (hl),a 
0d91					ld a, display_row_4 
0d91					ld de, LFSRSeed 
0d91					call str_at_display 
0d91					.skip_input_diag: 
0d91				endif 
0d91			 
0d91					; decide on if we are showing the cursor this time round 
0d91			 
0d91 3a b1 fb				ld a, (input_cur_onoff) 
0d94 fe ff				cp 255 
0d96 28 13				jr z, .skipcur 
0d98			 
0d98			 
0d98 3a b4 fb				ld a,(input_at_cursor) 
0d9b 11 56 fa				ld de, cursor_shape 
0d9e cd e8 0a				call str_at_display 
0da1			 
0da1					; save length of current input string 
0da1 2a b9 fb				ld hl, (input_start) 
0da4 cd 67 11				call strlenz 
0da7 7d					ld a,l 
0da8 32 ac fb				ld (input_len),a 
0dab			 
0dab			.skipcur: 
0dab			 
0dab cd f8 0a			        call update_display 
0dae					 
0dae			 
0dae			 
0dae					; wait 
0dae				 
0dae					; TODO loop without wait to flash the cursor and char under cursor	 
0dae cd ca 66				call cin    ; _wait 
0db1			 
0db1 fe 00				cp 0 
0db3 ca 67 0d				jp z, .is1 
0db6			 
0db6					; get ptr to char to input into 
0db6			 
0db6 4f					ld c,a 
0db7 2a b9 fb				ld hl, (input_start) 
0dba 3a a7 fb				ld a, (input_cursor) 
0dbd cd 09 0d				call addatohl 
0dc0 22 bb fb				ld (input_ptr), hl 
0dc3 79					ld a,c 
0dc4			 
0dc4					; replace char under cursor 
0dc4			 
0dc4			;		ld hl, (input_ptr) 
0dc4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc4			;		ld (hl), a 
0dc4			 
0dc4			;	if DEBUG_INPUT 
0dc4			;		push af 
0dc4			;		ld a, 'i' 
0dc4			;		ld (debug_mark),a 
0dc4			;		pop af 
0dc4			;		CALLMONITOR 
0dc4			;	endif 
0dc4 fe 0e				cp KEY_HOME 
0dc6 20 0e				jr nz, .iske 
0dc8			 
0dc8 3a b6 fb				ld a, (input_at_pos) 
0dcb 32 b4 fb				ld (input_at_cursor),a 
0dce 3e 00				ld a, 0 
0dd0 32 a7 fb				ld (input_cursor), a 
0dd3 c3 67 0d				jp .is1 
0dd6					 
0dd6 fe 0f		.iske:		cp KEY_END 
0dd8 20 03				jr nz, .isknw 
0dda c3 67 0d				jp .is1 
0ddd			 
0ddd fe 06		.isknw:		cp KEY_NEXTWORD 
0ddf 20 1b				jr nz, .iskpw 
0de1			 
0de1 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0de4 7e					ld a,(hl)	 
0de5 fe 00				cp 0 
0de7 ca 67 0d				jp z, .is1    ; end of string 
0dea fe 20				cp ' ' 
0dec ca 67 0d				jp z, .is1    ; end of word 
0def 23					inc hl 
0df0 22 bb fb				ld (input_ptr), hl 
0df3 3a b4 fb				ld a, (input_at_cursor) 
0df6 3c					inc a 
0df7 32 b4 fb				ld (input_at_cursor), a 
0dfa 18 e5				jr .isknwm 
0dfc			 
0dfc fe 07		.iskpw:		cp KEY_PREVWORD 
0dfe 20 1b				jr nz, .iskl 
0e00			.iskpwm:	 
0e00 2a bb fb				ld hl, (input_ptr) 
0e03 7e					ld a,(hl)	 
0e04 fe 00				cp 0  
0e06 ca 67 0d				jp z, .is1    ; end of string 
0e09 fe 20				cp ' ' 
0e0b ca 67 0d				jp z, .is1    ; end of word 
0e0e 2b					dec hl 
0e0f 22 bb fb				ld (input_ptr), hl 
0e12 3a b4 fb				ld a, (input_at_cursor) 
0e15 3d					dec a 
0e16 32 b4 fb				ld (input_at_cursor), a 
0e19 18 e5				jr .iskpwm 
0e1b			 
0e1b			 
0e1b fe 0b		.iskl:		cp KEY_LEFT 
0e1d 20 27				jr nz, .isk1 
0e1f			 
0e1f 3a a7 fb				ld a, (input_cursor) 
0e22			 
0e22 fe 00				cp 0 
0e24 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0e27			 
0e27 3d					dec  a 		; TODO check underflow 
0e28 32 a7 fb				ld (input_cursor), a 
0e2b			 
0e2b 2a bb fb				ld hl, (input_ptr) 
0e2e 2b					dec hl 
0e2f 22 bb fb				ld (input_ptr), hl 
0e32					 
0e32 3a b4 fb				ld a, (input_at_cursor) 
0e35 3d					dec a 
0e36 32 b4 fb				ld (input_at_cursor), a 
0e39			 
0e39 3e 01				ld a, 1		; show cursor moving 
0e3b 32 b1 fb				ld (input_cur_onoff),a 
0e3e 3e 0f				ld a, CUR_BLINK_RATE 
0e40 32 b2 fb				ld (input_cur_flash), a 
0e43			 
0e43 c3 67 0d				jp .is1 
0e46			 
0e46 fe 0c		.isk1:		cp KEY_RIGHT 
0e48 20 2a				jr nz, .isk2 
0e4a			 
0e4a 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4d 5f					ld e,a 
0e4e 3a a7 fb				ld a, (input_cursor) 
0e51 bb					cp e 
0e52 ca 67 0d				jp z, .is1		; at the end of string so dont go right 
0e55			 
0e55 3c					inc  a 		; TODO check overflow 
0e56 32 a7 fb				ld (input_cursor), a 
0e59			 
0e59 3a b4 fb				ld a, (input_at_cursor) 
0e5c 3c					inc a 
0e5d 32 b4 fb				ld (input_at_cursor), a 
0e60			 
0e60 2a bb fb				ld hl, (input_ptr) 
0e63 23					inc hl 
0e64 22 bb fb				ld (input_ptr), hl 
0e67			 
0e67 3e 01				ld a, 1		; show cursor moving 
0e69 32 b1 fb				ld (input_cur_onoff),a 
0e6c 3e 0f				ld a, CUR_BLINK_RATE 
0e6e 32 b2 fb				ld (input_cur_flash), a 
0e71			 
0e71 c3 67 0d				jp .is1 
0e74			 
0e74 fe 05		.isk2:		cp KEY_UP 
0e76			 
0e76 20 26				jr nz, .isk3 
0e78			 
0e78					; swap last command with the current on 
0e78			 
0e78					; move cursor to start of string 
0e78 2a b9 fb				ld hl, (input_start) 
0e7b 22 bb fb				ld (input_ptr), hl 
0e7e			 
0e7e 3a b6 fb				ld a, (input_at_pos) 
0e81 32 b4 fb				ld (input_at_cursor), a 
0e84			 
0e84 3e 00				ld a, 0 
0e86 32 a7 fb				ld (input_cursor), a 
0e89					 
0e89					; swap input and last command buffers 
0e89			 
0e89 21 ca f2				ld hl, os_cli_cmd 
0e8c 11 c9 f3				ld de, os_last_cmd 
0e8f 06 ff				ld b, 255 
0e91 7e			.swap1:		ld a, (hl) 
0e92 4f					ld c,a 
0e93 1a					ld a, (de) 
0e94 77					ld (hl), a 
0e95 79					ld a,c 
0e96 12					ld (de),a 
0e97 23					inc hl 
0e98 13					inc de 
0e99 10 f6				djnz .swap1 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b			 
0e9b c3 67 0d				jp .is1 
0e9e			 
0e9e fe 08		.isk3:		cp KEY_BS 
0ea0 20 3c				jr nz, .isk4 
0ea2			 
0ea2 3a a7 fb				ld a, (input_cursor) 
0ea5			 
0ea5 fe 00				cp 0 
0ea7 ca 67 0d				jp z, .is1 		; at start of line to ignore  
0eaa			 
0eaa 3d					dec  a 		; TODO check underflow 
0eab 32 a7 fb				ld (input_cursor), a 
0eae			 
0eae					; hl is source 
0eae					; de needs to be source - 1 
0eae			 
0eae			;		ld a, 0 
0eae			;		dec hl 
0eae			;		ld (hl), a 
0eae			 
0eae 2a bb fb				ld hl, (input_ptr) 
0eb1 2b					dec hl 
0eb2 22 bb fb				ld (input_ptr), hl 
0eb5			 
0eb5					; shift all data 
0eb5			 
0eb5 e5					push hl 
0eb6 23					inc hl 
0eb7 d1					pop de 
0eb8 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ebb 4f					ld c,a 
0ebc 06 00				ld b,0 
0ebe ed b0				ldir  
0ec0			 
0ec0			 
0ec0			 
0ec0			 
0ec0 3a b4 fb				ld a, (input_at_cursor) 
0ec3 3d					dec a 
0ec4 32 b4 fb				ld (input_at_cursor), a 
0ec7			 
0ec7			 
0ec7 3e 01				ld a, 1		; show cursor moving 
0ec9 32 b1 fb				ld (input_cur_onoff),a 
0ecc 3e 0f				ld a, CUR_BLINK_RATE 
0ece 32 b2 fb				ld (input_cur_flash), a 
0ed1			 
0ed1					; remove char 
0ed1 3a b4 fb				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 11 5f 0f				ld de,.iblank 
0ed8 cd e8 0a				call str_at_display 
0edb			 
0edb c3 67 0d				jp .is1 
0ede			 
0ede fe 0d		.isk4:		cp KEY_CR 
0ee0 28 6c				jr z, .endinput 
0ee2			 
0ee2					; else add the key press to the end 
0ee2			 
0ee2 4f					ld c, a			; save key pressed 
0ee3			 
0ee3 7e					ld a,(hl)		; get what is currently under char 
0ee4			 
0ee4 fe 00				cp 0			; we are at the end of the string 
0ee6 20 2f				jr nz, .onchar 
0ee8					 
0ee8					; add a char to the end of the string 
0ee8				 
0ee8 71					ld (hl),c 
0ee9 23					inc hl 
0eea			;		ld a,' ' 
0eea			;		ld (hl),a 
0eea			;		inc hl 
0eea 3e 00				ld a,0 
0eec 77					ld (hl),a 
0eed 2b					dec hl 
0eee			 
0eee 3a a7 fb				ld a, (input_cursor) 
0ef1 3c					inc a				; TODO check max string length and scroll  
0ef2 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ef5							 
0ef5 3a b4 fb				ld a, (input_at_cursor) 
0ef8 3c					inc a 
0ef9 32 b4 fb				ld (input_at_cursor), a 
0efc			 
0efc 2a bb fb				ld hl, (input_ptr) 
0eff 23					inc hl 
0f00 22 bb fb				ld (input_ptr), hl 
0f03			 
0f03 2a bb fb				ld hl, (input_ptr) 
0f06 23					inc hl 
0f07 22 bb fb				ld (input_ptr), hl 
0f0a			;	if DEBUG_INPUT 
0f0a			;		push af 
0f0a			;		ld a, '+' 
0f0a			;		ld (debug_mark),a 
0f0a			;		pop af 
0f0a			;		CALLMONITOR 
0f0a			;	endif 
0f0a 3e 01				ld a, 1		; show cursor moving 
0f0c 32 b1 fb				ld (input_cur_onoff),a 
0f0f 3e 0f				ld a, CUR_BLINK_RATE 
0f11 32 b2 fb				ld (input_cur_flash), a 
0f14 c3 67 0d				jp .is1 
0f17					 
0f17			 
0f17			 
0f17					; if on a char then insert 
0f17			.onchar: 
0f17			 
0f17					; TODO over flow check: make sure insert does not blow out buffer 
0f17			 
0f17					; need to do some maths to use lddr 
0f17			 
0f17 e5					push hl   ; save char pos 
0f18 c5					push bc 
0f19			 
0f19 2a b9 fb				ld hl, (input_start) 
0f1c 3a ac fb				ld a, (input_len) 
0f1f cd 09 0d				call addatohl  		; end of string 
0f22 23					inc hl 
0f23 23					inc hl		; past zero term 
0f24 e5					push hl 
0f25 23					inc hl 
0f26 e5					push hl  
0f27			 
0f27								; start and end of lddr set, now how much to move? 
0f27			 
0f27							 
0f27 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f2a 47					ld b,a 
0f2b 3a ac fb				ld a,(input_len) 
0f2e 5f					ld e,a 
0f2f 90					sub b 
0f30 3c					inc a		;?? 
0f31 3c					inc a		;?? 
0f32 3c					inc a		;?? 
0f33			 
0f33 06 00				ld b,0 
0f35 4f					ld c,a 
0f36			 
0f36				if DEBUG_INPUT 
0f36					push af 
0f36					ld a, 'i' 
0f36					ld (debug_mark),a 
0f36					pop af 
0f36			;		CALLMONITOR 
0f36				endif 
0f36 d1					pop de 
0f37 e1					pop hl 
0f38				if DEBUG_INPUT 
0f38					push af 
0f38					ld a, 'I' 
0f38					ld (debug_mark),a 
0f38					pop af 
0f38			;		CALLMONITOR 
0f38				endif 
0f38 ed b8				lddr 
0f3a				 
0f3a			 
0f3a			 
0f3a					; TODO have a key for insert/overwrite mode???? 
0f3a c1					pop bc 
0f3b e1					pop hl 
0f3c 71					ld (hl), c		; otherwise overwrite current char 
0f3d					 
0f3d			 
0f3d			 
0f3d			 
0f3d 3a a7 fb				ld a, (input_cursor) 
0f40 3c					inc  a 		; TODO check overflow 
0f41 32 a7 fb				ld (input_cursor), a 
0f44			 
0f44 3a b4 fb				ld a, (input_at_cursor) 
0f47 3c					inc a 
0f48 32 b4 fb				ld (input_at_cursor), a 
0f4b			 
0f4b c3 67 0d				jp .is1 
0f4e			 
0f4e			.endinput:	; TODO look for end of string 
0f4e			 
0f4e					; add trailing space for end of token 
0f4e			 
0f4e 2a b9 fb				ld hl, (input_start) 
0f51 3a ac fb				ld a,(input_len) 
0f54 cd 09 0d				call addatohl 
0f57 3e 20				ld a, ' ' 
0f59 77					ld (hl),a 
0f5a					; TODO eof of parse marker 
0f5a			 
0f5a 23					inc hl 
0f5b 3e 00				ld a, 0 
0f5d 77					ld (hl),a 
0f5e			 
0f5e			 
0f5e c9					ret 
0f5f			 
0f5f .. 00		.iblank: db " ",0 
0f61			 
0f61			 
0f61 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f64 22 b9 fb				ld (input_start), hl 
0f67 3e 01				ld a,1			; add cursor 
0f69 77					ld (hl),a 
0f6a 23					inc hl 
0f6b 3e 00				ld a,0 
0f6d 77					ld (hl),a 
0f6e 22 bb fb				ld (input_ptr), hl 
0f71 7a					ld a,d 
0f72 32 b8 fb				ld (input_size), a 
0f75 3e 00				ld a,0 
0f77 32 a7 fb				ld (input_cursor),a 
0f7a			.instr1:	 
0f7a			 
0f7a					; TODO do block cursor 
0f7a					; TODO switch cursor depending on the modifer key 
0f7a			 
0f7a					; update cursor shape change on key hold 
0f7a			 
0f7a 2a bb fb				ld hl, (input_ptr) 
0f7d 2b					dec hl 
0f7e 3a 56 fa				ld a,(cursor_shape) 
0f81 77					ld (hl), a 
0f82			 
0f82					; display entered text 
0f82 3a b6 fb				ld a,(input_at_pos) 
0f85 cd e8 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f88 ed 5b b9 fb	            	LD   de, (input_start) 
0f8c cd f0 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8f			 
0f8f cd ca 66				call cin 
0f92 fe 00				cp 0 
0f94 28 e4				jr z, .instr1 
0f96			 
0f96					; proecess keyboard controls first 
0f96			 
0f96 2a bb fb				ld hl,(input_ptr) 
0f99			 
0f99 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f9b 28 5a				jr z, .instrcr 
0f9d			 
0f9d fe 08				cp KEY_BS 	; back space 
0f9f 20 0f				jr nz, .instr2 
0fa1					; process back space 
0fa1			 
0fa1					; TODO stop back space if at start of string 
0fa1 2b					dec hl 
0fa2 2b					dec hl ; to over write cursor 
0fa3 3a 56 fa				ld a,(cursor_shape) 
0fa6					;ld a,0 
0fa6 77					ld (hl),a 
0fa7 23					inc hl 
0fa8 3e 20				ld a," " 
0faa 77					ld (hl),a 
0fab 22 bb fb				ld (input_ptr),hl 
0fae					 
0fae			 
0fae 18 ca				jr .instr1 
0fb0			 
0fb0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fb2 20 06				jr nz, .instr3 
0fb4 2b					dec hl 
0fb5 22 bb fb				ld (input_ptr),hl 
0fb8 18 c0				jr .instr1 
0fba				 
0fba fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fbc 20 06				jr nz, .instr4 
0fbe 23					inc hl 
0fbf 22 bb fb				ld (input_ptr),hl 
0fc2 18 b6				jr .instr1 
0fc4			 
0fc4 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc6 20 06				jr nz, .instr5 
0fc8 2b					dec hl 
0fc9 22 bb fb				ld (input_ptr),hl 
0fcc 18 ac				jr .instr1 
0fce			 
0fce fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fd0 20 06				jr nz, .instr6 
0fd2 2b					dec hl 
0fd3 22 bb fb				ld (input_ptr),hl 
0fd6 18 a2				jr .instr1 
0fd8 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fda 20 0b				jr nz, .instrnew 
0fdc			 
0fdc 21 a3 ef			ld hl, scratch 
0fdf 11 c9 f3			ld de, os_last_cmd 
0fe2 cd 00 10			call strcpy 
0fe5 18 93				jr .instr1 
0fe7			 
0fe7			 
0fe7			.instrnew:	; no special key pressed to see if we have room to store it 
0fe7			 
0fe7					; TODO do string size test 
0fe7			 
0fe7 2b					dec hl ; to over write cursor 
0fe8 77					ld (hl),a 
0fe9 23					inc hl 
0fea 3a 56 fa				ld a,(cursor_shape) 
0fed 77					ld (hl),a 
0fee 23					inc hl 
0fef 3e 00				ld a,0 
0ff1 77					ld (hl),a 
0ff2			 
0ff2 22 bb fb				ld (input_ptr),hl 
0ff5					 
0ff5 18 83				jr .instr1 
0ff7 2b			.instrcr:	dec hl		; remove cursor 
0ff8 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ffa 77					ld (hl),a 
0ffb 23					inc hl 
0ffc 3e 00				ld a,0 
0ffe 77					ld (hl),a 
0fff			 
0fff			 
0fff					; if at end of line scroll up    
0fff					; TODO detecting only end of line 4 for scroll up  
0fff			 
0fff					;ld   
0fff			 
0fff c9					ret 
1000			 
1000			 
1000			; strcpy hl = dest, de source 
1000			 
1000 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1001 b7			            OR   A              ;Null terminator? 
1002 c8			            RET  Z              ;Yes, so finished 
1003 1a					ld a,(de) 
1004 77					ld (hl),a 
1005 13			            INC  DE             ;Point to next character 
1006 23					inc hl 
1007 18 f7		            JR   strcpy       ;Repeat 
1009 c9					ret 
100a			 
100a			 
100a			; TODO string_at  
100a			; pass string which starts with lcd offset address and then null term string 
100a			 
100a			; TODO string to dec 
100a			; TODO string to hex 
100a			; TODO byte to string hex 
100a			; TODO byte to string dec 
100a			 
100a			 
100a			 
100a			; from z80uartmonitor 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
100a			; pass hl for where to put the text 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a c5			hexout:	PUSH BC 
100b f5					PUSH AF 
100c 47					LD B, A 
100d					; Upper nybble 
100d cb 3f				SRL A 
100f cb 3f				SRL A 
1011 cb 3f				SRL A 
1013 cb 3f				SRL A 
1015 cd 25 10				CALL tohex 
1018 77					ld (hl),a 
1019 23					inc hl	 
101a					 
101a					; Lower nybble 
101a 78					LD A, B 
101b e6 0f				AND 0FH 
101d cd 25 10				CALL tohex 
1020 77					ld (hl),a 
1021 23					inc hl	 
1022					 
1022 f1					POP AF 
1023 c1					POP BC 
1024 c9					RET 
1025					 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1025			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1025			tohex: 
1025 e5					PUSH HL 
1026 d5					PUSH DE 
1027 16 00				LD D, 0 
1029 5f					LD E, A 
102a 21 32 10				LD HL, .DATA 
102d 19					ADD HL, DE 
102e 7e					LD A, (HL) 
102f d1					POP DE 
1030 e1					POP HL 
1031 c9					RET 
1032			 
1032			.DATA: 
1032 30					DEFB	30h	; 0 
1033 31					DEFB	31h	; 1 
1034 32					DEFB	32h	; 2 
1035 33					DEFB	33h	; 3 
1036 34					DEFB	34h	; 4 
1037 35					DEFB	35h	; 5 
1038 36					DEFB	36h	; 6 
1039 37					DEFB	37h	; 7 
103a 38					DEFB	38h	; 8 
103b 39					DEFB	39h	; 9 
103c 41					DEFB	41h	; A 
103d 42					DEFB	42h	; B 
103e 43					DEFB	43h	; C 
103f 44					DEFB	44h	; D 
1040 45					DEFB	45h	; E 
1041 46					DEFB	46h	; F 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1042			;;    subtract $30, if result > 9 then subtract $7 more 
1042			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1042			atohex: 
1042 d6 30				SUB $30 
1044 fe 0a				CP 10 
1046 f8					RET M		; If result negative it was 0-9 so we're done 
1047 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1049 c9					RET		 
104a			 
104a			 
104a			 
104a			 
104a			; Get 2 ASCII characters as hex byte from pointer in hl 
104a			 
104a			BYTERD: 
104a 16 00			LD	D,00h		;Set up 
104c cd 54 10			CALL	HEXCON		;Get byte and convert to hex 
104f 87				ADD	A,A		;First nibble so 
1050 87				ADD	A,A		;multiply by 16 
1051 87				ADD	A,A		; 
1052 87				ADD	A,A		; 
1053 57				LD	D,A		;Save hi nibble in D 
1054			HEXCON: 
1054 7e				ld a, (hl)		;Get next chr 
1055 23				inc hl 
1056 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1058 fe 0a			CP	00Ah		;Is it 0-9 ? 
105a 38 02			JR	C,NALPHA	;If so miss next bit 
105c d6 07			SUB	007h		;Else convert alpha 
105e			NALPHA: 
105e b2				OR	D		;Add hi nibble back 
105f c9				RET			; 
1060			 
1060			 
1060			; 
1060			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1060			; Since the routines get_byte and therefore get_nibble are called, only valid 
1060			; characters (0-9a-f) are accepted. 
1060			; 
1060			;get_word        push    af 
1060			;                call    get_byte        ; Get the upper byte 
1060			;                ld      h, a 
1060			;                call    get_byte        ; Get the lower byte 
1060			;                ld      l, a 
1060			;                pop     af 
1060			;                ret 
1060			; 
1060			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1060			; the routine get_nibble is used only valid characters are accepted - the  
1060			; input routine only accepts characters 0-9a-f. 
1060			; 
1060 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1061 7e					ld a,(hl) 
1062 23					inc hl 
1063 cd 88 10		                call    nibble2val      ; Get upper nibble 
1066 cb 07		                rlc     a 
1068 cb 07		                rlc     a 
106a cb 07		                rlc     a 
106c cb 07		                rlc     a 
106e 47			                ld      b, a            ; Save upper four bits 
106f 7e					ld a,(hl) 
1070 cd 88 10		                call    nibble2val      ; Get lower nibble 
1073 b0			                or      b               ; Combine both nibbles 
1074 c1			                pop     bc              ; Restore B (and C) 
1075 c9			                ret 
1076			; 
1076			; Get a hexadecimal digit from the serial line. This routine blocks until 
1076			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1076			; to the serial line interface. The lower 4 bits of A contain the value of  
1076			; that particular digit. 
1076			; 
1076			;get_nibble      ld a,(hl)           ; Read a character 
1076			;                call    to_upper        ; Convert to upper case 
1076			;                call    is_hex          ; Was it a hex digit? 
1076			;                jr      nc, get_nibble  ; No, get another character 
1076			 ;               call    nibble2val      ; Convert nibble to value 
1076			 ;               call    print_nibble 
1076			 ;               ret 
1076			; 
1076			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1076			; A valid hexadecimal digit is denoted by a set C flag. 
1076			; 
1076			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1076			;                ret     nc              ; Yes 
1076			;                cp      '0'             ; Less than '0'? 
1076			;                jr      nc, is_hex_1    ; No, continue 
1076			;                ccf                     ; Complement carry (i.e. clear it) 
1076			;                ret 
1076			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1076			;                ret     c               ; Yes 
1076			;                cp      'A'             ; Less than 'A'? 
1076			;                jr      nc, is_hex_2    ; No, continue 
1076			;                ccf                     ; Yes - clear carry and return 
1076			;                ret 
1076			;is_hex_2        scf                     ; Set carry 
1076			;                ret 
1076			; 
1076			; Convert a single character contained in A to upper case: 
1076			; 
1076 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1078 d8			                ret     c 
1079 fe 7b		                cp      'z' + 1         ; > 'z'? 
107b d0			                ret     nc              ; Nothing to do, either 
107c e6 5f		                and     $5f             ; Convert to upper case 
107e c9			                ret 
107f			 
107f			 
107f			to_lower: 
107f			 
107f			   ; if char is in [A-Z] make it lower case 
107f			 
107f			   ; enter : a = char 
107f			   ; exit  : a = lower case char 
107f			   ; uses  : af 
107f			 
107f fe 41		   cp 'A' 
1081 d8			   ret c 
1082			    
1082 fe 5b		   cp 'Z'+1 
1084 d0			   ret nc 
1085			    
1085 f6 20		   or $20 
1087 c9			   ret 
1088			 
1088			; 
1088			; Expects a hexadecimal digit (upper case!) in A and returns the 
1088			; corresponding value in A. 
1088			; 
1088 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
108a 38 02		                jr      c, nibble2val_1 ; Yes 
108c d6 07		                sub     7               ; Adjust for A-F 
108e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1090 e6 0f		                and     $f              ; Only return lower 4 bits 
1092 c9			                ret 
1093			; 
1093			; Print_nibble prints a single hex nibble which is contained in the lower  
1093			; four bits of A: 
1093			; 
1093			;print_nibble    push    af              ; We won't destroy the contents of A 
1093			;                and     $f              ; Just in case... 
1093			;                add     a, '0'             ; If we have a digit we are done here. 
1093			;                cp      '9' + 1         ; Is the result > 9? 
1093			;                jr      c, print_nibble_1 
1093			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1093			;print_nibble_1  call    putc            ; Print the nibble and 
1093			;                pop     af              ; restore the original value of A 
1093			;                ret 
1093			;; 
1093			;; Send a CR/LF pair: 
1093			; 
1093			;crlf            push    af 
1093			;                ld      a, cr 
1093			;                call    putc 
1093			;                ld      a, lf 
1093			;                call    putc 
1093			;                pop     af 
1093			;                ret 
1093			; 
1093			; Print_word prints the four hex digits of a word to the serial line. The  
1093			; word is expected to be in HL. 
1093			; 
1093			;print_word      push    hl 
1093			;                push    af 
1093			;                ld      a, h 
1093			;                call    print_byte 
1093			;                ld      a, l 
1093			;                call    print_byte 
1093			;                pop     af 
1093			;                pop     hl 
1093			;                ret 
1093			; 
1093			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1093			; The byte to be printed is expected to be in A. 
1093			; 
1093			;print_byte      push    af              ; Save the contents of the registers 
1093			;                push    bc 
1093			;                ld      b, a 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                rrca 
1093			;                call    print_nibble    ; Print high nibble 
1093			;                ld      a, b 
1093			;                call    print_nibble    ; Print low nibble 
1093			;                pop     bc              ; Restore original register contents 
1093			;                pop     af 
1093			;                ret 
1093			 
1093			 
1093			 
1093			 
1093			 
1093			fourehexhl:  
1093 7e				ld a,(hl) 
1094 cd 42 10			call atohex 
1097 cb 3f				SRL A 
1099 cb 3f				SRL A 
109b cb 3f				SRL A 
109d cb 3f				SRL A 
109f 47				ld b, a 
10a0 23				inc hl 
10a1 7e				ld a,(hl) 
10a2 23				inc hl 
10a3 cd 42 10			call atohex 
10a6 80				add b 
10a7 57				ld d,a 
10a8 7e				ld a,(hl) 
10a9 cd 42 10			call atohex 
10ac cb 3f				SRL A 
10ae cb 3f				SRL A 
10b0 cb 3f				SRL A 
10b2 cb 3f				SRL A 
10b4 47				ld b, a 
10b5 23				inc hl 
10b6 7e				ld a,(hl) 
10b7 23				inc hl 
10b8 cd 42 10			call atohex 
10bb 80				add b 
10bc 5f				ld e, a 
10bd d5				push de 
10be e1				pop hl 
10bf c9				ret 
10c0			 
10c0			; pass hl. returns z set if the byte at hl is a digit 
10c0			;isdigithl:  
10c0			;	push bc 
10c0			;	ld a,(hl) 
10c0			;	cp ':' 
10c0			;	jr nc, .isdf 		; > 
10c0			;	cp '0' 
10c0			;	jr c, .isdf		; < 
10c0			; 
10c0			;	; TODO find a better way to set z 
10c0			; 
10c0			;	ld b,a 
10c0			;	cp b 
10c0			;	pop bc 
10c0			;	ret 
10c0			; 
10c0			;.isdf:	; not digit so clear z 
10c0			; 
10c0			;	; TODO find a better way to unset z 
10c0			; 
10c0			;	ld b,a 
10c0			;	inc b 
10c0			;	cp b 
10c0			; 
10c0			;	pop bc 
10c0			;	ret 
10c0				 
10c0				 
10c0			 
10c0			 
10c0			; pass hl as the four byte address to load 
10c0			 
10c0			get_word_hl:  
10c0 e5				push hl 
10c1 cd 60 10			call get_byte 
10c4				 
10c4 47				ld b, a 
10c5			 
10c5 e1				pop hl 
10c6 23				inc hl 
10c7 23				inc hl 
10c8			 
10c8			; TODO not able to handle a-f  
10c8 7e				ld a,(hl) 
10c9			;	;cp ':' 
10c9			;	cp 'g' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp 'G' 
10c9			;	jr nc, .single_byte_hl 		; > 
10c9			;	cp '0' 
10c9			;	jr c, .single_byte_hl		; < 
10c9			 
10c9				;call isdigithl 
10c9 fe 00			cp 0 
10cb 28 06			jr z, .single_byte_hl 
10cd			 
10cd			.getwhln:   ; hex word so get next byte 
10cd			 
10cd cd 60 10			call get_byte 
10d0 6f				ld l, a 
10d1 60				ld h,b 
10d2 c9				ret 
10d3 68			.single_byte_hl:   ld l,b 
10d4 26 00				ld h,0 
10d6 c9					ret 
10d7			 
10d7			 
10d7			 
10d7			 
10d7 21 c3 19			ld hl,asc+1 
10da			;	ld a, (hl) 
10da			;	call nibble2val 
10da cd 60 10			call get_byte 
10dd			 
10dd			;	call fourehexhl 
10dd 32 d7 ef			ld (scratch+52),a 
10e0				 
10e0 21 d5 ef			ld hl,scratch+50 
10e3 22 c6 f2			ld (os_cur_ptr),hl 
10e6			 
10e6 c9				ret 
10e7			 
10e7			 
10e7			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e7			 
10e7			; Decimal Unsigned Version 
10e7			 
10e7			;Number in a to decimal ASCII 
10e7			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e7			;Example: display a=56 as "056" 
10e7			;input: a = number 
10e7			;Output: a=0,value of a in the screen 
10e7			;destroys af,bc (don't know about hl and de) 
10e7			DispAToASCII: 
10e7 0e 9c			ld	c,-100 
10e9 cd f3 10			call	.Na1 
10ec 0e f6			ld	c,-10 
10ee cd f3 10			call	.Na1 
10f1 0e ff			ld	c,-1 
10f3 06 2f		.Na1:	ld	b,'0'-1 
10f5 04			.Na2:	inc	b 
10f6 81				add	a,c 
10f7 38 fc			jr	c,.Na2 
10f9 91				sub	c		;works as add 100/10/1 
10fa f5				push af		;safer than ld c,a 
10fb 78				ld	a,b		;char is in b 
10fc			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10fc f1				pop af		;safer than ld a,c 
10fd c9				ret 
10fe			 
10fe			; Decimal Signed Version 
10fe			 
10fe			; DispA 
10fe			; -------------------------------------------------------------- 
10fe			; Converts a signed integer value to a zero-terminated ASCII 
10fe			; string representative of that value (using radix 10). 
10fe			; -------------------------------------------------------------- 
10fe			; INPUTS: 
10fe			;     HL     Value to convert (two's complement integer). 
10fe			;     DE     Base address of string destination. (pointer). 
10fe			; -------------------------------------------------------------- 
10fe			; OUTPUTS: 
10fe			;     None 
10fe			; -------------------------------------------------------------- 
10fe			; REGISTERS/MEMORY DESTROYED 
10fe			; AF HL 
10fe			; -------------------------------------------------------------- 
10fe			 
10fe			;DispHLToASCII: 
10fe			;   push    de 
10fe			;   push    bc 
10fe			; 
10fe			;; Detect sign of HL. 
10fe			;    bit    7, h 
10fe			;    jr     z, ._DoConvert 
10fe			; 
10fe			;; HL is negative. Output '-' to string and negate HL. 
10fe			;    ld     a, '-' 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			; 
10fe			;; Negate HL (using two's complement) 
10fe			;    xor    a 
10fe			;    sub    l 
10fe			;    ld     l, a 
10fe			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fe			;    sbc    a, h 
10fe			;    ld     h, a 
10fe			; 
10fe			;; Convert HL to digit characters 
10fe			;._DoConvert: 
10fe			;    ld     b, 0     ; B will count character length of number 
10fe			;-   ld     a, 10 
10fe			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fe			;    push   af 
10fe			;    inc    b 
10fe			;    ld     a, h 
10fe			;    or     l 
10fe			;    jr     nz, - 
10fe			; 
10fe			;; Retrieve digits from stack 
10fe			;-   pop    af 
10fe			;    or     $30 
10fe			;    ld     (de), a 
10fe			;    inc    de 
10fe			;    djnz   - 
10fe			; 
10fe			;; Terminate string with NULL 
10fe			;    xor    a 
10fe			;    ld     (de), a 
10fe			; 
10fe			;    pop    bc 
10fe			;    pop    de 
10fe			;    ret 
10fe			 
10fe			;Comments 
10fe			; 
10fe			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fe			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fe			;    Note that the output string will not be fixed-width. 
10fe			; 
10fe			;Example Usage 
10fe			; 
10fe			;    ld    hl, -1004 
10fe			;    ld    de, OP1 
10fe			;    call  DispA 
10fe			;    ld    hl, OP1 
10fe			;    syscall  PutS 
10fe			 
10fe			 
10fe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fe			 
10fe			 
10fe			;Converts an ASCII string to an unsigned 16-bit integer 
10fe			;Quits when it reaches a non-decimal digit 
10fe			 
10fe			string_to_uint16: 
10fe			atoui_16: 
10fe			;Input: 
10fe			;     DE points to the string 
10fe			;Outputs: 
10fe			;     HL is the result 
10fe			;     A is the 8-bit value of the number 
10fe			;     DE points to the byte after the number 
10fe			;Destroys: 
10fe			;     BC 
10fe			;       if the string is non-empty, BC is HL/10 
10fe			;Size:  24 bytes 
10fe			;Speed: 42+d(104+{0,9}) 
10fe			;       d is the number of digits in the number 
10fe			;       max is 640 cycles for a 5 digit number 
10fe			;Assuming no leading zeros: 
10fe			;1 digit:  146cc 
10fe			;2 digit:  250cc 
10fe			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fe			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fe			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fe			;avg: 544.81158447265625cc (544+13297/16384) 
10fe			;=============================================================== 
10fe 21 00 00		  ld hl,0 
1101			.u16a: 
1101 1a			  ld a,(de) 
1102 d6 30		  sub 30h 
1104 fe 0a		  cp 10 
1106 d0			  ret nc 
1107 13			  inc de 
1108 44			  ld b,h 
1109 4d			  ld c,l 
110a 29			  add hl,hl 
110b 29			  add hl,hl 
110c 09			  add hl,bc 
110d 29			  add hl,hl 
110e 85			  add a,l 
110f 6f			  ld l,a 
1110 30 ef		  jr nc,.u16a 
1112 24			  inc h 
1113 c3 01 11		  jp .u16a 
1116			 
1116			 
1116			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1116			 
1116			;written by Zeda 
1116			;Converts a 16-bit unsigned integer to an ASCII string. 
1116			 
1116			uitoa_16: 
1116			;Input: 
1116			;   DE is the number to convert 
1116			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1116			;Output: 
1116			;   HL points to the null-terminated ASCII string 
1116			;      NOTE: This isn't necessarily the same as the input HL. 
1116 d5			  push de 
1117 c5			  push bc 
1118 f5			  push af 
1119 eb			  ex de,hl 
111a			 
111a 01 f0 d8		  ld bc,-10000 
111d 3e 2f		  ld a,'0'-1 
111f 3c			  inc a 
1120 09			  add hl,bc  
1121 38 fc		   jr c,$-2 
1123 12			  ld (de),a 
1124 13			  inc de 
1125			 
1125 01 e8 03		  ld bc,1000 
1128 3e 3a		  ld a,'9'+1 
112a 3d			  dec a  
112b 09			  add hl,bc  
112c 30 fc		   jr nc,$-2 
112e 12			  ld (de),a 
112f 13			  inc de 
1130			 
1130 01 9c ff		  ld bc,-100 
1133 3e 2f		  ld a,'0'-1 
1135 3c			  inc a  
1136 09			  add hl,bc  
1137 38 fc		   jr c,$-2 
1139 12			  ld (de),a 
113a 13			  inc de 
113b			 
113b 7d			  ld a,l 
113c 26 3a		  ld h,'9'+1 
113e 25			  dec h  
113f c6 0a		  add a,10  
1141 30 fb		   jr nc,$-3 
1143 c6 30		  add a,'0' 
1145 eb			  ex de,hl 
1146 72			  ld (hl),d 
1147 23			  inc hl 
1148 77			  ld (hl),a 
1149 23			  inc hl 
114a 36 00		  ld (hl),0 
114c			 
114c			;Now strip the leading zeros 
114c 0e fa		  ld c,-6 
114e 09			  add hl,bc 
114f 3e 30		  ld a,'0' 
1151 23			  inc hl  
1152 be			  cp (hl)  
1153 28 fc		  jr z,$-2 
1155			 
1155			;Make sure that the string is non-empty! 
1155 7e			  ld a,(hl) 
1156 b7			  or a 
1157 20 01		  jr nz,.atoub 
1159 2b			  dec hl 
115a			.atoub: 
115a			 
115a f1			  pop af 
115b c1			  pop bc 
115c d1			  pop de 
115d c9			  ret 
115e			 
115e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115e			 
115e			toUpper: 
115e			;A is the char. 
115e			;If A is a lowercase letter, this sets it to the matching uppercase 
115e			;18cc or 30cc or 41cc 
115e			;avg: 26.75cc 
115e fe 61		  cp 'a' 
1160 d8			  ret c 
1161 fe 7b		  cp 'z'+1 
1163 d0			  ret nc 
1164 d6 20		  sub 'a'-'A' 
1166 c9			  ret 
1167			 
1167			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1167			 
1167			; String Length 
1167			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1167			 
1167			; Get the length of the null-terminated string starting at $8000 hl 
1167			;    LD     HL, $8000 
1167			 
1167			strlenz: 
1167			 
1167 af			    XOR    A               ; Zero is the value we are looking for. 
1168 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1169 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116d 6f			    LD     L, A             ; number of bytes 
116e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1170 2b			    DEC    HL              ; Compensate for null. 
1171 c9				ret 
1172			 
1172			; Get the length of the A terminated string starting at $8000 hl 
1172			;    LD     HL, $8000 
1172			 
1172			strlent: 
1172			 
1172			                  ; A is the value we are looking for. 
1172 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1174 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1176			                           ; 65, 536 bytes (the entire addressable memory space). 
1176 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1178			 
1178			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1178 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
117a 2e 00		    LD     L, 0             ; number of bytes 
117c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117e 2b			    DEC    HL              ; Compensate for null. 
117f c9				ret 
1180			 
1180			 
1180			;Comparing Strings 
1180			 
1180			;IN    HL     Address of string1. 
1180			;      DE     Address of string2. 
1180			 
1180			; doc given but wrong??? 
1180			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1180			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1180			; tested 
1180			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1180			 
1180			strcmp_old: 
1180 e5			    PUSH   HL 
1181 d5			    PUSH   DE 
1182			 
1182 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1183 be			    CP     (HL)            ; (want to minimize work). 
1184 38 01		    JR     C, Str1IsBigger 
1186 7e			    LD     A, (HL) 
1187			 
1187			Str1IsBigger: 
1187 4f			    LD     C, A             ; Put length in BC 
1188 06 00		    LD     B, 0 
118a 13			    INC    DE              ; Increment pointers to meat of string. 
118b 23			    INC    HL 
118c			 
118c			CmpLoop: 
118c 1a			    LD     A, (DE)          ; Compare bytes. 
118d ed a1		    CPI 
118f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1191 13			    INC    DE              ; Update pointer. 
1192 ea 8c 11		    JP     PE, CmpLoop 
1195			 
1195 d1			    POP    DE 
1196 e1			    POP    HL 
1197 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1198 be			    CP     (HL) 
1199 c9			    RET 
119a			 
119a			NoMatch: 
119a 2b			    DEC    HL 
119b be			    CP     (HL)            ; Compare again to affect carry. 
119c d1			    POP    DE 
119d e1			    POP    HL 
119e c9			    RET 
119f			 
119f			;; test strmp 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr z, .z1 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z1: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr z, .z2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "NZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.z2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "ZZ2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str2 
119f			;call strcmp 
119f			;jr c, .c1 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c1: 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc1" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			; 
119f			;ld de, .str1 
119f			;ld hl, .str1 
119f			;call strcmp 
119f			;jr c, .c2 
119f			;;this 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "Nc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;.c2: 
119f			; 
119f			;	if DEBUG_FORTH_WORDS 
119f			;		DMARK "cc2" 
119f			;		CALLMONITOR 
119f			;	endif 
119f			;	NEXTW 
119f			;.str1:   db "string1",0 
119f			;.str2:   db "string2",0 
119f			 
119f			; only care about direct match or not 
119f			; hl and de strings 
119f			; zero set if the same 
119f			 
119f			strcmp: 
119f 1a				ld a, (de) 
11a0 be				cp (hl) 
11a1 28 02			jr z, .ssame 
11a3 b7				or a 
11a4 c9				ret 
11a5			 
11a5			.ssame:  
11a5 fe 00			cp 0 
11a7 c8				ret z 
11a8			 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f3			jr strcmp 
11ac				 
11ac				 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				ld a, 0 
11ac				ld (os_view_disable), a 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 0e 80		      ld    HL, heap_start 
11b0 22 0a 80		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 0c 80		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 0a 80		      ld    HL, heap_start+heap_size-4 
11bc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 fc ff		      ld    HL, heap_size-4 
11c2 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11cb 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 0a 80		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			if SOUND_ENABLE  
1369				include "firmware_sound.asm"  
1369			endif  
1369			  
1369			include "firmware_diags.asm"  
1369			; Hardware diags menu 
1369			 
1369			 
1369			config: 
1369			 
1369 3e 00			ld a, 0 
136b 21 99 13			ld hl, .configmn 
136e cd 06 0b			call menu 
1371			 
1371 fe 00			cp 0 
1373 c8				ret z 
1374			 
1374 fe 01			cp 1 
1376 cc 03 15			call z, .savetostore 
1379			 
1379 fe 02			cp 2 
137b cc 51 14			call z, .selautoload 
137e fe 03			cp 3 
1380 cc 3a 14			call z, .disautoload 
1383 fe 04			cp 4 
1385 cc 01 15			call z, .selbank 
1388 fe 05			cp 5 
138a cc de 15			call z, .debug_tog 
138d fe 06			cp 6 
138f cc 26 17			call z, .bpsgo 
1392 fe 07			cp 7 
1394 cc 04 16			call z, hardware_diags 
1397			 
1397 18 d0			jr config 
1399			 
1399			.configmn: 
1399 a9 13			dw .c3 
139b c0 13			dw .c2 
139d d5 13			dw .c2a 
139f eb 13			dw .c2b 
13a1			;	dw .c4 
13a1 08 14			dw .m4 
13a3 23 14			dw .m4b 
13a5 2b 14			dw .c1 
13a7 00 00			dw 0 
13a9				 
13a9			 
13a9 .. 00		.c3: db "Add Dictionary To File",0 
13c0 .. 00		.c2: db "Select Autoload File",0 
13d5 .. 00		.c2a: db "Disable Autoload File", 0 
13eb .. 00		.c2b: db "Select Storage Bank",0 
13ff .. 00		.c4: db "Settings",0 
1408 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1423 .. 00		.m4b:   db "Monitor",0 
142b .. 00		.c1: db "Hardware Diags",0 
143a			 
143a			 
143a			.disautoload: 
143a				if STORAGE_SE 
143a 3e fe			ld a, $fe      ; bit 0 clear 
143c 32 ce f9			ld (spi_device), a 
143f			 
143f cd ba 03			call storage_get_block_0 
1442			 
1442 3e 00			ld a, 0 
1444 32 09 fa			ld (store_page+STORE_0_AUTOFILE), a 
1447			 
1447 21 00 00				ld hl, 0 
144a 11 e8 f9				ld de, store_page 
144d cd 6e 03			call storage_write_block	 ; save update 
1450				endif 
1450			 
1450			 
1450 c9				ret 
1451			 
1451			 
1451			 
1451			; Select auto start 
1451			 
1451			.selautoload: 
1451			 
1451				 
1451				if STORAGE_SE 
1451			 
1451 cd 28 15				call config_dir 
1454 21 a3 ef			        ld hl, scratch 
1457 3e 00				ld a, 0 
1459 cd 06 0b				call menu 
145c			 
145c fe 00				cp 0 
145e c8					ret z 
145f			 
145f 3d					dec a 
1460			 
1460			 
1460					; locate menu option 
1460			 
1460 21 a3 ef				ld hl, scratch 
1463 cd 2d 0a				call table_lookup 
1466			 
1466					if DEBUG_FORTH_WORDS 
1466						DMARK "ALl" 
1466 f5				push af  
1467 3a 7b 14			ld a, (.dmark)  
146a 32 bd fb			ld (debug_mark),a  
146d 3a 7c 14			ld a, (.dmark+1)  
1470 32 be fb			ld (debug_mark+1),a  
1473 3a 7d 14			ld a, (.dmark+2)  
1476 32 bf fb			ld (debug_mark+2),a  
1479 18 03			jr .pastdmark  
147b ..			.dmark: db "ALl"  
147e f1			.pastdmark: pop af  
147f			endm  
# End of macro DMARK
147f						CALLMONITOR 
147f cd 1c 17			call break_point_state  
1482				endm  
# End of macro CALLMONITOR
1482					endif 
1482					; with the pointer to the menu it, the byte following the zero term is the file id 
1482			 
1482 3e 00				ld a, 0 
1484 01 32 00				ld bc, 50   ; max of bytes to look at 
1487 ed b1				cpir  
1489			 
1489					if DEBUG_FORTH_WORDS 
1489						DMARK "ALb" 
1489 f5				push af  
148a 3a 9e 14			ld a, (.dmark)  
148d 32 bd fb			ld (debug_mark),a  
1490 3a 9f 14			ld a, (.dmark+1)  
1493 32 be fb			ld (debug_mark+1),a  
1496 3a a0 14			ld a, (.dmark+2)  
1499 32 bf fb			ld (debug_mark+2),a  
149c 18 03			jr .pastdmark  
149e ..			.dmark: db "ALb"  
14a1 f1			.pastdmark: pop af  
14a2			endm  
# End of macro DMARK
14a2						CALLMONITOR 
14a2 cd 1c 17			call break_point_state  
14a5				endm  
# End of macro CALLMONITOR
14a5					endif 
14a5					;inc hl 
14a5			 
14a5 7e					ld a, (hl)   ; file id 
14a6					 
14a6				        ; save bank and file ids 
14a6			 
14a6 f5					push af 
14a7			 
14a7			; TODO need to save to block 0 on bank 1	 
14a7			 
14a7 cd ba 03				call storage_get_block_0 
14aa			 
14aa					if DEBUG_FORTH_WORDS 
14aa						DMARK "AL0" 
14aa f5				push af  
14ab 3a bf 14			ld a, (.dmark)  
14ae 32 bd fb			ld (debug_mark),a  
14b1 3a c0 14			ld a, (.dmark+1)  
14b4 32 be fb			ld (debug_mark+1),a  
14b7 3a c1 14			ld a, (.dmark+2)  
14ba 32 bf fb			ld (debug_mark+2),a  
14bd 18 03			jr .pastdmark  
14bf ..			.dmark: db "AL0"  
14c2 f1			.pastdmark: pop af  
14c3			endm  
# End of macro DMARK
14c3						CALLMONITOR 
14c3 cd 1c 17			call break_point_state  
14c6				endm  
# End of macro CALLMONITOR
14c6					endif 
14c6 f1					pop af 
14c7			 
14c7 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
14ca					 
14ca					; save bank id 
14ca			 
14ca 3a ce f9				ld a,(spi_device) 
14cd 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
14d0			 
14d0					; enable auto run of store file 
14d0			 
14d0 3e 01				ld a, 1 
14d2 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
14d5			 
14d5					; save buffer 
14d5			 
14d5 21 00 00				ld hl, 0 
14d8 11 e8 f9				ld de, store_page 
14db					if DEBUG_FORTH_WORDS 
14db						DMARK "ALw" 
14db f5				push af  
14dc 3a f0 14			ld a, (.dmark)  
14df 32 bd fb			ld (debug_mark),a  
14e2 3a f1 14			ld a, (.dmark+1)  
14e5 32 be fb			ld (debug_mark+1),a  
14e8 3a f2 14			ld a, (.dmark+2)  
14eb 32 bf fb			ld (debug_mark+2),a  
14ee 18 03			jr .pastdmark  
14f0 ..			.dmark: db "ALw"  
14f3 f1			.pastdmark: pop af  
14f4			endm  
# End of macro DMARK
14f4						CALLMONITOR 
14f4 cd 1c 17			call break_point_state  
14f7				endm  
# End of macro CALLMONITOR
14f7					endif 
14f7 cd 6e 03			call storage_write_block	 ; save update 
14fa			  
14fa			 
14fa			 
14fa			 
14fa 21 a3 ef				ld hl, scratch 
14fd cd 15 15				call config_fdir 
1500			 
1500			 
1500				endif 
1500 c9				ret 
1501			 
1501			 
1501			 
1501			; Select storage bank 
1501			 
1501			.selbank: 
1501			 
1501				if STORAGE_SE 
1501				endif 
1501				 
1501 c9				ret 
1502			 
1502			if STORAGE_SE 
1502			 
1502			.config_ldir:   
1502				; Load storage bank labels into menu array 
1502			 
1502				 
1502			 
1502			 
1502 c9				ret 
1503			 
1503			 
1503			endif 
1503			 
1503			 
1503			; Save user words to storage 
1503			 
1503			.savetostore: 
1503			 
1503				if STORAGE_SE 
1503			 
1503 cd 28 15				call config_dir 
1506 21 a3 ef			        ld hl, scratch 
1509 3e 00				ld a, 0 
150b cd 06 0b				call menu 
150e					 
150e 21 a3 ef				ld hl, scratch 
1511 cd 15 15				call config_fdir 
1514			 
1514			 
1514				endif 
1514			 
1514 c9				ret 
1515			 
1515			 
1515			 
1515			if STORAGE_SE 
1515			 
1515			config_fdir: 
1515				; using the scratch dir go through and release the memory allocated for each string 
1515				 
1515 21 a3 ef			ld hl, scratch 
1518 5e			.cfdir:	ld e,(hl) 
1519 23				inc hl 
151a 56				ld d,(hl) 
151b 23				inc hl 
151c			 
151c eb				ex de, hl 
151d cd 32 0d			call ishlzero 
1520 c8				ret z     ; return on null pointer 
1521 cd 9a 12			call free 
1524 eb				ex de, hl 
1525 18 f1			jr .cfdir 
1527			 
1527			 
1527 c9				ret 
1528			 
1528			 
1528			config_dir: 
1528			 
1528				; for the config menus that need to build a directory of storage call this routine 
1528				; it will construct a menu in scratch to pass to menu 
1528			 
1528				; open storage device 
1528			 
1528				; execute DIR to build a list of files and their ids into scratch in menu format 
1528				; once the menu has finished then will need to call config_fdir to release the strings 
1528				 
1528				; c = number items 
1528			 
1528				 
1528 cd ba 03			call storage_get_block_0 
152b			 
152b 21 e8 f9			ld hl, store_page     ; get current id count 
152e 46				ld b, (hl) 
152f 0e 00			ld c, 0    ; count of files   
1531			 
1531			 
1531 21 a3 ef			ld hl, scratch 
1534 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1537			 
1537				; check for empty drive 
1537			 
1537 3e 00			ld a, 0 
1539 b8				cp b 
153a ca d4 15			jp z, .dirdone 
153d			 
153d				 
153d					if DEBUG_FORTH_WORDS 
153d						DMARK "Cdc" 
153d f5				push af  
153e 3a 52 15			ld a, (.dmark)  
1541 32 bd fb			ld (debug_mark),a  
1544 3a 53 15			ld a, (.dmark+1)  
1547 32 be fb			ld (debug_mark+1),a  
154a 3a 54 15			ld a, (.dmark+2)  
154d 32 bf fb			ld (debug_mark+2),a  
1550 18 03			jr .pastdmark  
1552 ..			.dmark: db "Cdc"  
1555 f1			.pastdmark: pop af  
1556			endm  
# End of macro DMARK
1556						CALLMONITOR 
1556 cd 1c 17			call break_point_state  
1559				endm  
# End of macro CALLMONITOR
1559					endif 
1559			 
1559			 
1559			.diritem:	 
1559 c5				push bc 
155a				; for each of the current ids do a search for them and if found push to stack 
155a			 
155a 21 40 00				ld hl, STORE_BLOCK_PHY 
155d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
155f 58					ld e,b 
1560			 
1560 cd 2a 06				call storage_findnextid 
1563			 
1563			 
1563					; if found hl will be non zero 
1563			 
1563 cd 32 0d				call ishlzero 
1566 28 69				jr z, .dirnotfound 
1568			 
1568					; increase count 
1568			 
1568 c1					pop bc	 
1569 0c					inc c 
156a c5					push bc 
156b					 
156b			 
156b					; get file header and push the file name 
156b			 
156b 11 e8 f9				ld de, store_page 
156e cd 09 03				call storage_read_block 
1571			 
1571					; push file id to stack 
1571				 
1571 3a e8 f9				ld a, (store_page) 
1574 26 00				ld h, 0 
1576 6f					ld l, a 
1577			 
1577					;call forth_push_numhl 
1577					; TODO store id 
1577			 
1577 e5					push hl 
1578			 
1578					; push extent count to stack  
1578				 
1578 21 eb f9				ld hl, store_page+3 
157b			 
157b					; get file name length 
157b			 
157b cd 67 11				call strlenz   
157e			 
157e 23					inc hl   ; cover zero term 
157f 23					inc hl  ; stick the id at the end of the area 
1580			 
1580 e5					push hl 
1581 c1					pop bc    ; move length to bc 
1582			 
1582 cd d0 11				call malloc 
1585			 
1585					; TODO save malloc area to scratch 
1585			 
1585 eb					ex de, hl 
1586 2a e4 f9				ld hl, (store_tmp2) 
1589 73					ld (hl), e 
158a 23					inc hl 
158b 72					ld (hl), d 
158c 23					inc hl 
158d 22 e4 f9				ld (store_tmp2), hl 
1590			 
1590					 
1590			 
1590					;pop hl   ; get source 
1590			;		ex de, hl    ; swap aronund	 
1590			 
1590 21 eb f9				ld hl, store_page+3 
1593					if DEBUG_FORTH_WORDS 
1593						DMARK "CFd" 
1593 f5				push af  
1594 3a a8 15			ld a, (.dmark)  
1597 32 bd fb			ld (debug_mark),a  
159a 3a a9 15			ld a, (.dmark+1)  
159d 32 be fb			ld (debug_mark+1),a  
15a0 3a aa 15			ld a, (.dmark+2)  
15a3 32 bf fb			ld (debug_mark+2),a  
15a6 18 03			jr .pastdmark  
15a8 ..			.dmark: db "CFd"  
15ab f1			.pastdmark: pop af  
15ac			endm  
# End of macro DMARK
15ac						CALLMONITOR 
15ac cd 1c 17			call break_point_state  
15af				endm  
# End of macro CALLMONITOR
15af					endif 
15af ed b0				ldir 
15b1			 
15b1					; de is past string, move back one and store id 
15b1					 
15b1 1b					dec de 
15b2			 
15b2					; store file id 
15b2			 
15b2 e1					pop hl 
15b3 eb					ex de,hl 
15b4 73					ld (hl), e 
15b5			 
15b5					if DEBUG_FORTH_WORDS 
15b5						DMARK "Cdi" 
15b5 f5				push af  
15b6 3a ca 15			ld a, (.dmark)  
15b9 32 bd fb			ld (debug_mark),a  
15bc 3a cb 15			ld a, (.dmark+1)  
15bf 32 be fb			ld (debug_mark+1),a  
15c2 3a cc 15			ld a, (.dmark+2)  
15c5 32 bf fb			ld (debug_mark+2),a  
15c8 18 03			jr .pastdmark  
15ca ..			.dmark: db "Cdi"  
15cd f1			.pastdmark: pop af  
15ce			endm  
# End of macro DMARK
15ce						CALLMONITOR 
15ce cd 1c 17			call break_point_state  
15d1				endm  
# End of macro CALLMONITOR
15d1					endif 
15d1					 
15d1			.dirnotfound: 
15d1 c1					pop bc     
15d2 10 85				djnz .diritem 
15d4				 
15d4			.dirdone:	 
15d4			 
15d4 3e 00				ld a, 0 
15d6 2a e4 f9				ld hl, (store_tmp2) 
15d9 77					ld (hl), a 
15da 23					inc hl 
15db 77					ld (hl), a 
15dc 23					inc hl 
15dd					; push a count of the dir items found 
15dd			 
15dd			;		ld h, 0 
15dd			;		ld l, c 
15dd			 
15dd c9				ret 
15de			 
15de			endif 
15de			 
15de			 
15de			; Settings 
15de			; Run  
15de			 
15de			 
15de			 
15de			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
15de			;;hd_menu2:   db "        2: Editor",0   
15de			;hd_menu2:   db "        2: Editor       6: Menu",0   
15de			;hd_menu3:   db "        3: Storage",0 
15de			;hd_menu4:   db "0=quit  4: Debug",0 
15de			;hd_don:     db "ON",0 
15de			;hd_doff:     db "OFF",0 
15de			; 
15de			; 
15de			; 
15de			;hardware_diags_old:       
15de			; 
15de			;.diagmenu: 
15de			;	call clear_display 
15de			;	ld a, display_row_1 
15de			;	ld de, hd_menu1 
15de			;	call str_at_display 
15de			; 
15de			;	ld a, display_row_2 
15de			;	ld de, hd_menu2 
15de			;	call str_at_display 
15de			; 
15de			;	ld a, display_row_3 
15de			;	ld de, hd_menu3 
15de			;	call str_at_display 
15de			; 
15de			;	ld a,  display_row_4 
15de			;	ld de, hd_menu4 
15de			;	call str_at_display 
15de			; 
15de			;	; display debug state 
15de			; 
15de			;	ld de, hd_don 
15de			;	ld a, (os_view_disable) 
15de			;	cp 0 
15de			;	jr z, .distog 
15de			;	ld de, hd_doff 
15de			;.distog: ld a, display_row_4+17 
15de			;	call str_at_display 
15de			; 
15de			;	call update_display 
15de			; 
15de			;	call cin_wait 
15de			; 
15de			; 
15de			; 
15de			;	cp '4' 
15de			;	jr nz, .diagn1 
15de			; 
15de			;	; debug toggle 
15de			; 
15de			;	ld a, (os_view_disable) 
15de			;	ld b, '*' 
15de			;	cp 0 
15de			;	jr z, .debtog 
15de			;	ld b, 0 
15de			;.debtog:	 
15de			;	ld a,b 
15de			;	ld (os_view_disable),a 
15de			; 
15de			;.diagn1: cp '0' 
15de			;	 ret z 
15de			; 
15de			;;	cp '1' 
15de			;;       jp z, matrix	 
15de			;;   TODO keyboard matrix test 
15de			; 
15de			;	cp '2' 
15de			;	jp z, .diagedit 
15de			; 
15de			;;	cp '6' 
15de			;;	jp z, .menutest 
15de			;;if ENABLE_BASIC 
15de			;;	cp '6' 
15de			;;	jp z, basic 
15de			;;endif 
15de			 ; 
15de			;	jp .diagmenu 
15de			; 
15de			; 
15de			;	ret 
15de			 
15de			 
15de			.debug_tog: 
15de 21 25 16			ld hl, .menudebug 
15e1				 
15e1 3a 94 ef			ld a, (os_view_disable) 
15e4 fe 2a			cp '*' 
15e6 20 04			jr nz,.tdon  
15e8 3e 01			ld a, 1 
15ea 18 02			jr .tog1 
15ec 3e 00		.tdon: ld a, 0 
15ee			 
15ee			.tog1: 
15ee cd 06 0b			call menu 
15f1 fe 00			cp 0 
15f3 c8				ret z 
15f4 fe 01			cp 1    ; disable debug 
15f6 28 04			jr z, .dtog0 
15f8 3e 2a			ld a, '*' 
15fa 18 02			jr .dtogset 
15fc 3e 00		.dtog0: ld a, 0 
15fe 32 94 ef		.dtogset:  ld (os_view_disable), a 
1601 c3 de 15			jp .debug_tog 
1604			 
1604			 
1604			hardware_diags:       
1604			 
1604			.diagm: 
1604 21 17 16			ld hl, .menuitems 
1607 3e 00			ld a, 0 
1609 cd 06 0b			call menu 
160c			 
160c fe 00		         cp 0 
160e c8				 ret z 
160f			 
160f fe 02			cp 2 
1611 ca 70 16			jp z, .diagedit 
1614			 
1614			;	cp '6' 
1614			;	jp z, .menutest 
1614			;if ENABLE_BASIC 
1614			;	cp '6' 
1614			;	jp z, basic 
1614			;endif 
1614			  
1614 c3 04 16			jp .diagm 
1617			 
1617				 
1617 2b 16		.menuitems:   	dw .m1 
1619 36 16				dw .m2 
161b 3d 16				dw .m3 
161d 45 16				dw .m5 
161f 4b 16				dw .m5a 
1621 54 16				dw .m5b 
1623 00 00				dw 0 
1625			 
1625			.menudebug: 
1625 5d 16				dw .m6 
1627 66 16				dw .m7 
1629 00 00				dw 0 
162b			 
162b .. 00		.m1:   db "Key Matrix",0 
1636 .. 00		.m2:   db "Editor",0 
163d .. 00		.m3:   db "Storage",0 
1645 .. 00		.m5:   db "Sound",0 
164b .. 00		.m5a:  db "RAM Test",0 
1654 .. 00		.m5b:  db "LCD Test",0 
165d			 
165d .. 00		.m6:   db "Debug ON",0 
1666 .. 00		.m7:   db "Debug OFF",0 
1670			 
1670			; debug editor 
1670			 
1670			.diagedit: 
1670			 
1670 21 a3 ef			ld hl, scratch 
1673			;	ld bc, 250 
1673			;	ldir 
1673				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1673 3e 00			ld a, 0 
1675 77				ld (hl), a 
1676 23				inc hl 
1677 77				ld (hl), a 
1678 23				inc hl 
1679 77				ld (hl), a 
167a			 
167a cd d5 0a		        call clear_display 
167d cd f8 0a			call update_display 
1680 3e 01			ld a, 1 
1682 32 c3 fb			ld (hardware_diag), a 
1685			.diloop: 
1685 3e 00			ld a, display_row_1 
1687 0e 00			ld c, 0 
1689 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
168b 1e 28			ld e, 40 
168d			 
168d 21 a3 ef			ld hl, scratch	 
1690 cd 36 0d			call input_str 
1693			 
1693 3e 14			ld a, display_row_2 
1695 11 a3 ef			ld de, scratch 
1698 cd e8 0a			call str_at_display 
169b cd f8 0a			call update_display 
169e			 
169e c3 85 16			jp .diloop 
16a1			 
16a1			 
16a1			; pass word in hl 
16a1			; a has display location 
16a1			display_word_at: 
16a1 f5				push af 
16a2 e5				push hl 
16a3 7c				ld a,h 
16a4 21 a8 f2			ld hl, os_word_scratch 
16a7 cd 0a 10			call hexout 
16aa e1				pop hl 
16ab 7d				ld a,l 
16ac 21 aa f2			ld hl, os_word_scratch+2 
16af cd 0a 10			call hexout 
16b2 21 ac f2			ld hl, os_word_scratch+4 
16b5 3e 00			ld a,0 
16b7 77				ld (hl),a 
16b8 11 a8 f2			ld de,os_word_scratch 
16bb f1				pop af 
16bc cd e8 0a				call str_at_display 
16bf c9				ret 
16c0			 
16c0			display_ptr_state: 
16c0			 
16c0				; to restore afterwards 
16c0			 
16c0 d5				push de 
16c1 c5				push bc 
16c2 e5				push hl 
16c3 f5				push af 
16c4			 
16c4				; for use in here 
16c4			 
16c4			;	push bc 
16c4			;	push de 
16c4			;	push hl 
16c4			;	push af 
16c4			 
16c4 cd d5 0a			call clear_display 
16c7			 
16c7 11 9a 18			ld de, .ptrstate 
16ca 3e 00			ld a, display_row_1 
16cc cd e8 0a			call str_at_display 
16cf			 
16cf				; display debug step 
16cf			 
16cf			 
16cf 11 bd fb			ld de, debug_mark 
16d2 3e 12			ld a, display_row_1+display_cols-2 
16d4 cd e8 0a			call str_at_display 
16d7			 
16d7				; display a 
16d7 11 a4 18			ld de, .ptrcliptr 
16da 3e 14			ld a, display_row_2 
16dc cd e8 0a			call str_at_display 
16df			 
16df f1				pop af 
16e0 2a ae f9			ld hl,(cli_ptr) 
16e3 3e 1c			ld a, display_row_2+8 
16e5 cd a1 16			call display_word_at 
16e8			 
16e8			 
16e8				; display hl 
16e8			 
16e8			 
16e8 11 ac 18			ld de, .ptrclioptr 
16eb 3e 1e			ld a, display_row_2+10 
16ed cd e8 0a			call str_at_display 
16f0			; 
16f0			;	pop hl 
16f0 3e 21			ld a, display_row_2+13 
16f2 2a ac f9			ld hl,(cli_origptr) 
16f5 cd a1 16			call display_word_at 
16f8			; 
16f8			;	 
16f8			;	; display de 
16f8			 
16f8			;	ld de, .regstatede 
16f8			;	ld a, display_row_3 
16f8			;	call str_at_display 
16f8			 
16f8			;	pop de 
16f8			;	ld h,d 
16f8			;	ld l, e 
16f8			;	ld a, display_row_3+3 
16f8			;	call display_word_at 
16f8			 
16f8			 
16f8				; display bc 
16f8			 
16f8			;	ld de, .regstatebc 
16f8			;	ld a, display_row_3+10 
16f8			;	call str_at_display 
16f8			 
16f8			;	pop bc 
16f8			;	ld h,b 
16f8			;	ld l, c 
16f8			;	ld a, display_row_3+13 
16f8			;	call display_word_at 
16f8			 
16f8			 
16f8				; display dsp 
16f8			 
16f8			;	ld de, .regstatedsp 
16f8			;	ld a, display_row_4 
16f8			;	call str_at_display 
16f8			 
16f8				 
16f8			;	ld hl,(cli_data_sp) 
16f8			;	ld a, display_row_4+4 
16f8			;	call display_word_at 
16f8			 
16f8				; display rsp 
16f8			 
16f8 11 db 18			ld de, .regstatersp 
16fb 3e 46			ld a, display_row_4+10 
16fd cd e8 0a			call str_at_display 
1700			 
1700				 
1700 2a 94 f9			ld hl,(cli_ret_sp) 
1703 3e 4a			ld a, display_row_4+14 
1705 cd a1 16			call display_word_at 
1708			 
1708 cd f8 0a			call update_display 
170b			 
170b cd 55 0a			call delay1s 
170e cd 55 0a			call delay1s 
1711 cd 55 0a			call delay1s 
1714			 
1714			 
1714 cd 24 1c			call next_page_prompt 
1717			 
1717				; restore  
1717			 
1717 f1				pop af 
1718 e1				pop hl 
1719 c1				pop bc 
171a d1				pop de 
171b c9				ret 
171c			 
171c			break_point_state: 
171c f5				push af 
171d			 
171d				; see if disabled 
171d			 
171d 3a 94 ef			ld a, (os_view_disable) 
1720 fe 2a			cp '*' 
1722 20 02			jr nz, .bpsgo 
1724 f1				pop af 
1725 c9				ret 
1726			 
1726			.bpsgo: 
1726 f1				pop af 
1727 f5				push af 
1728 22 90 ef			ld (os_view_hl), hl 
172b ed 53 8e ef		ld (os_view_de), de 
172f ed 43 8c ef		ld (os_view_bc), bc 
1733 e5				push hl 
1734 6f				ld l, a 
1735 26 00			ld h, 0 
1737 22 92 ef			ld (os_view_af),hl 
173a			 
173a 21 53 fb				ld hl, display_fb0 
173d 22 5e fa				ld (display_fb_active), hl 
1740 e1				pop hl	 
1741			 
1741 3e 31			ld a, '1' 
1743 fe 2a		.bps1:  cp '*' 
1745 20 03			jr nz, .bps1b 
1747 32 94 ef			ld (os_view_disable),a 
174a fe 31		.bps1b:  cp '1' 
174c 20 14			jr nz, .bps2 
174e			 
174e				; display reg 
174e			 
174e				 
174e			 
174e 3a 92 ef			ld a, (os_view_af) 
1751 2a 90 ef			ld hl, (os_view_hl) 
1754 ed 5b 8e ef		ld de, (os_view_de) 
1758 ed 4b 8c ef		ld bc, (os_view_bc) 
175c cd f6 17			call display_reg_state 
175f c3 e2 17			jp .bpschk 
1762			 
1762 fe 32		.bps2:  cp '2' 
1764 20 08			jr nz, .bps3 
1766				 
1766				; display hl 
1766 2a 90 ef			ld hl, (os_view_hl) 
1769 cd e0 18			call display_dump_at_hl 
176c			 
176c 18 74			jr .bpschk 
176e			 
176e fe 33		.bps3:  cp '3' 
1770 20 08			jr nz, .bps4 
1772			 
1772			        ; display de 
1772 2a 8e ef			ld hl, (os_view_de) 
1775 cd e0 18			call display_dump_at_hl 
1778			 
1778 18 68			jr .bpschk 
177a fe 34		.bps4:  cp '4' 
177c 20 08			jr nz, .bps5 
177e			 
177e			        ; display bc 
177e 2a 8c ef			ld hl, (os_view_bc) 
1781 cd e0 18			call display_dump_at_hl 
1784			 
1784 18 5c			jr .bpschk 
1786 fe 35		.bps5:  cp '5' 
1788 20 08		        jr nz, .bps7 
178a			 
178a				; display cur ptr 
178a 2a ae f9			ld hl, (cli_ptr) 
178d cd e0 18			call display_dump_at_hl 
1790			 
1790 18 50			jr .bpschk 
1792 fe 36		.bps7:  cp '6' 
1794 20 08			jr nz, .bps8b 
1796				 
1796				; display cur orig ptr 
1796 2a ac f9			ld hl, (cli_origptr) 
1799 cd e0 18			call display_dump_at_hl 
179c 18 44			jr .bpschk 
179e fe 37		.bps8b:  cp '7' 
17a0 20 08			jr nz, .bps9 
17a2				 
17a2				; display dsp 
17a2 2a 90 f9			ld hl, (cli_data_sp) 
17a5 cd e0 18			call display_dump_at_hl 
17a8			 
17a8 18 38			jr .bpschk 
17aa fe 39		.bps9:  cp '9' 
17ac 20 05			jr nz, .bps8c 
17ae				 
17ae				; display SP 
17ae			;	ld hl, sp 
17ae cd e0 18			call display_dump_at_hl 
17b1			 
17b1 18 2f			jr .bpschk 
17b3 fe 38		.bps8c:  cp '8' 
17b5 20 08			jr nz, .bps8d 
17b7				 
17b7				; display rsp 
17b7 2a 94 f9			ld hl, (cli_ret_sp) 
17ba cd e0 18			call display_dump_at_hl 
17bd			 
17bd 18 23			jr .bpschk 
17bf fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17c1 20 05			jr nz, .bps8 
17c3 cd 1a 1a			call monitor 
17c6			 
17c6 18 1a			jr .bpschk 
17c8 fe 30		.bps8:  cp '0' 
17ca 20 16			jr nz, .bpschk 
17cc			 
17cc 21 02 fb				ld hl, display_fb1 
17cf 22 5e fa				ld (display_fb_active), hl 
17d2 cd f8 0a				call update_display 
17d5			 
17d5				;ld a, (os_view_af) 
17d5 2a 90 ef			ld hl, (os_view_hl) 
17d8 ed 5b 8e ef		ld de, (os_view_de) 
17dc ed 4b 8c ef		ld bc, (os_view_bc) 
17e0 f1				pop af 
17e1 c9				ret 
17e2			 
17e2			.bpschk:   
17e2 cd 55 0a			call delay1s 
17e5 3e 4f		ld a,display_row_4 + display_cols - 1 
17e7 11 22 1c		        ld de, endprg 
17ea cd e8 0a			call str_at_display 
17ed cd f8 0a			call update_display 
17f0 cd b9 66			call cin_wait 
17f3			 
17f3 c3 43 17			jp .bps1 
17f6			 
17f6			 
17f6			display_reg_state: 
17f6			 
17f6				; to restore afterwards 
17f6			 
17f6 d5				push de 
17f7 c5				push bc 
17f8 e5				push hl 
17f9 f5				push af 
17fa			 
17fa				; for use in here 
17fa			 
17fa c5				push bc 
17fb d5				push de 
17fc e5				push hl 
17fd f5				push af 
17fe			 
17fe cd d5 0a			call clear_display 
1801			 
1801 11 b6 18			ld de, .regstate 
1804 3e 00			ld a, display_row_1 
1806 cd e8 0a			call str_at_display 
1809			 
1809				; display debug step 
1809			 
1809			 
1809 11 bd fb			ld de, debug_mark 
180c 3e 11			ld a, display_row_1+display_cols-3 
180e cd e8 0a			call str_at_display 
1811			 
1811				; display a 
1811 11 d2 18			ld de, .regstatea 
1814 3e 14			ld a, display_row_2 
1816 cd e8 0a			call str_at_display 
1819			 
1819 e1				pop hl 
181a			;	ld h,0 
181a			;	ld l, a 
181a 3e 17			ld a, display_row_2+3 
181c cd a1 16			call display_word_at 
181f			 
181f			 
181f				; display hl 
181f			 
181f			 
181f 11 c6 18			ld de, .regstatehl 
1822 3e 1e			ld a, display_row_2+10 
1824 cd e8 0a			call str_at_display 
1827			 
1827 e1				pop hl 
1828 3e 21			ld a, display_row_2+13 
182a cd a1 16			call display_word_at 
182d			 
182d				 
182d				; display de 
182d			 
182d 11 ca 18			ld de, .regstatede 
1830 3e 28			ld a, display_row_3 
1832 cd e8 0a			call str_at_display 
1835			 
1835 e1				pop hl 
1836			;	ld h,d 
1836			;	ld l, e 
1836 3e 2b			ld a, display_row_3+3 
1838 cd a1 16			call display_word_at 
183b			 
183b			 
183b				; display bc 
183b			 
183b 11 ce 18			ld de, .regstatebc 
183e 3e 32			ld a, display_row_3+10 
1840 cd e8 0a			call str_at_display 
1843			 
1843 e1				pop hl 
1844			;	ld h,b 
1844			;	ld l, c 
1844 3e 35			ld a, display_row_3+13 
1846 cd a1 16			call display_word_at 
1849			 
1849			 
1849				; display dsp 
1849			 
1849 11 d6 18			ld de, .regstatedsp 
184c 3e 3c			ld a, display_row_4 
184e cd e8 0a			call str_at_display 
1851			 
1851				 
1851 2a 90 f9			ld hl,(cli_data_sp) 
1854 3e 40			ld a, display_row_4+4 
1856 cd a1 16			call display_word_at 
1859			 
1859				; display rsp 
1859			 
1859 11 db 18			ld de, .regstatersp 
185c 3e 46			ld a, display_row_4+10 
185e cd e8 0a			call str_at_display 
1861			 
1861				 
1861 2a 94 f9			ld hl,(cli_ret_sp) 
1864 3e 4a			ld a, display_row_4+14 
1866 cd a1 16			call display_word_at 
1869			 
1869 cd f8 0a			call update_display 
186c			 
186c			;	call delay1s 
186c			;	call delay1s 
186c			;	call delay1s 
186c			 
186c			 
186c			;	call next_page_prompt 
186c			 
186c				; restore  
186c			 
186c f1				pop af 
186d e1				pop hl 
186e c1				pop bc 
186f d1				pop de 
1870 c9				ret 
1871			 
1871 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1885 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
189a .. 00		.ptrstate:	db "Ptr State",0 
18a4 .. 00		.ptrcliptr:     db "cli_ptr",0 
18ac .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18b6 .. 00		.regstate:	db "Reg State (1/0)",0 
18c6 .. 00		.regstatehl:	db "HL:",0 
18ca .. 00		.regstatede:	db "DE:",0 
18ce .. 00		.regstatebc:	db "BC:",0 
18d2 .. 00		.regstatea:	db "A :",0 
18d6 .. 00		.regstatedsp:	db "DSP:",0 
18db .. 00		.regstatersp:	db "RSP:",0 
18e0			 
18e0			display_dump_at_hl: 
18e0 e5				push hl 
18e1 d5				push de 
18e2 c5				push bc 
18e3 f5				push af 
18e4			 
18e4 22 c6 f2			ld (os_cur_ptr),hl	 
18e7 cd d5 0a			call clear_display 
18ea cd 2c 1b			call dumpcont 
18ed			;	call delay1s 
18ed			;	call next_page_prompt 
18ed			 
18ed			 
18ed f1				pop af 
18ee c1				pop bc 
18ef d1				pop de 
18f0 e1				pop hl 
18f1 c9				ret 
18f2			 
18f2			;if ENABLE_BASIC 
18f2			;	include "nascombasic.asm" 
18f2			;	basic: 
18f2			;	include "forth/FORTH.ASM" 
18f2			;endif 
18f2			 
18f2			; eof 
18f2			 
18f2			 
# End of file firmware_diags.asm
18f2			  
18f2			  
18f2			  
18f2			  
18f2			; eof  
18f2			  
# End of file firmware.asm
18f2			 
18f2			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
18f2			;if BASE_KEV  
18f2			;baseram: equ 08000h 
18f2			;endif 
18f2			 
18f2			;if BASE_SC114 
18f2			;baseram:     equ    endofcode 
18f2			;endif 
18f2			 
18f2			 
18f2			; start system 
18f2			 
18f2			coldstart: 
18f2				; set sp 
18f2				; di/ei 
18f2			 
18f2 f3				di 
18f3 31 fd ff			ld sp, tos 
18f6			;	ei 
18f6			 
18f6			 
18f6				; disable breakpoint by default 
18f6			 
18f6 3e 2a			ld a,'*' 
18f8 32 94 ef			ld (os_view_disable),a 
18fb			 
18fb				; init hardware 
18fb			 
18fb				; init keyboard and screen hardware 
18fb			 
18fb cd 03 00			call hardware_init 
18fe			 
18fe			 
18fe				; detect if any keys are held down to enable breakpoints at start up 
18fe			 
18fe cd ca 66			call cin  
1901 fe 00			cp 0 
1903 28 03			jr z, .nokeys 
1905			 
1905				;call hardware_diags 
1905 cd 69 13			call config 
1908			 
1908			;	ld de, .bpen 
1908			;	ld a, display_row_4 
1908			;	call str_at_display 
1908			;	call update_display 
1908			; 
1908			;	ld a,0 
1908			;	ld (os_view_disable),a 
1908			; 
1908			;.bpwait: 
1908			;	call cin 
1908			;	cp 0 
1908			;	jr z, .bpwait 
1908			;	jr .nokeys 
1908			; 
1908			; 
1908			;.bpen:  db "Break points enabled!",0 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			.nokeys: 
1908			 
1908			 
1908				 
1908			 
1908			;jp  testkey 
1908			 
1908			;call storage_get_block_0 
1908			; 
1908			;ld hl, 0 
1908			;ld de, store_page 
1908			;call storage_read_block 
1908			 
1908				 
1908			;ld hl, 10 
1908			;ld de, store_page 
1908			;call storage_read_block 
1908			 
1908			 
1908			 
1908			 
1908			 
1908			;stop:	nop 
1908			;	jp stop 
1908			 
1908			 
1908			 
1908			main: 
1908 cd d5 0a			call clear_display 
190b cd f8 0a			call update_display 
190e			 
190e			 
190e			 
190e			;	call testlcd 
190e			 
190e			 
190e			 
190e cd ea 1f			call forth_init 
1911			 
1911			 
1911			warmstart: 
1911 cd c0 1f			call forth_warmstart 
1914			 
1914				; run startup word load 
1914			        ; TODO prevent this running at warmstart after crash  
1914			 
1914				if STARTUP_ENABLE 
1914					if STORAGE_SE 
1914 cd fb 63					call forth_autoload 
1917					endif 
1917 cd 0a 61				call forth_startup 
191a			 
191a			 
191a				endif 
191a			 
191a				; show free memory after boot 
191a 11 b4 19			ld de, freeram 
191d 3e 00			ld a, display_row_1 
191f cd e8 0a			call str_at_display 
1922			 
1922			; Or use heap_size word???? 
1922 21 89 ef			ld hl, heap_end 
1925 11 0e 80			ld de, heap_start 
1928 ed 52			sbc hl, de 
192a e5				push hl 
192b 7c				ld a,h	         	 
192c 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
192f cd 0a 10			call hexout 
1932 e1			   	pop hl 
1933			 
1933 7d				ld a,l 
1934 21 aa f2			ld hl, os_word_scratch+2 
1937 cd 0a 10			call hexout 
193a 21 ac f2			ld hl, os_word_scratch+4 
193d 3e 00			ld a, 0 
193f 77				ld (hl),a 
1940 11 a8 f2			ld de, os_word_scratch 
1943 3e 0d			ld a, display_row_1 + 13 
1945 cd e8 0a			call str_at_display 
1948 cd f8 0a			call update_display 
194b			 
194b			 
194b				;call demo 
194b			 
194b			 
194b				; init scratch input area for cli commands 
194b			 
194b 21 ca f2			ld hl, os_cli_cmd 
194e 3e 00			ld a,0 
1950 77				ld (hl),a 
1951 23				inc hl 
1952 77				ld (hl),a 
1953			 
1953 3e 00			ld a,0 
1955 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1958			 
1958 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
195b 32 c7 f2			ld (os_cur_ptr+1),a	 
195e			 
195e 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1961 32 a9 f2			ld (os_word_scratch+1),a	 
1964				 
1964			 
1964				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1964 21 ca f2			ld hl, os_cli_cmd 
1967			 
1967 3e 00			ld a, 0		 ; init cli input 
1969 77				ld (hl), a 
196a 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
196c			cli: 
196c				; show cli prompt 
196c				;push af 
196c				;ld a, 0 
196c				;ld de, prompt 
196c				;call str_at_display 
196c			 
196c				;call update_display 
196c				;pop af 
196c				;inc a 
196c				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
196c 0e 00			ld c, 0 
196e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1970 1e 28			ld e, 40 
1972			 
1972 21 ca f2			ld hl, os_cli_cmd 
1975			 
1975				STACKFRAME OFF $fefe $9f9f 
1975				if DEBUG_STACK_IMB 
1975					if OFF 
1975						exx 
1975						ld de, $fefe 
1975						ld a, d 
1975						ld hl, curframe 
1975						call hexout 
1975						ld a, e 
1975						ld hl, curframe+2 
1975						call hexout 
1975						ld hl, $fefe 
1975						push hl 
1975						ld hl, $9f9f 
1975						push hl 
1975						exx 
1975					endif 
1975				endif 
1975			endm 
# End of macro STACKFRAME
1975			 
1975 cd 36 0d			call input_str 
1978			 
1978				STACKFRAMECHK OFF $fefe $9f9f 
1978				if DEBUG_STACK_IMB 
1978					if OFF 
1978						exx 
1978						ld hl, $9f9f 
1978						pop de   ; $9f9f 
1978						call cmp16 
1978						jr nz, .spnosame 
1978						ld hl, $fefe 
1978						pop de   ; $fefe 
1978						call cmp16 
1978						jr z, .spfrsame 
1978						.spnosame: call showsperror 
1978						.spfrsame: nop 
1978						exx 
1978					endif 
1978				endif 
1978			endm 
# End of macro STACKFRAMECHK
1978			 
1978				; copy input to last command 
1978			 
1978 21 ca f2			ld hl, os_cli_cmd 
197b 11 c9 f3			ld de, os_last_cmd 
197e 01 ff 00			ld bc, 255 
1981 ed b0			ldir 
1983			 
1983				; wipe current buffer 
1983			 
1983			;	ld a, 0 
1983			;	ld hl, os_cli_cmd 
1983			;	ld de, os_cli_cmd+1 
1983			;	ld bc, 254 
1983			;	ldir 
1983				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1983			;	call strcpy 
1983			;	ld a, 0 
1983			;	ld (hl), a 
1983			;	inc hl 
1983			;	ld (hl), a 
1983			;	inc hl 
1983			;	ld (hl), a 
1983			 
1983				; switch frame buffer to program  
1983			 
1983 21 02 fb				ld hl, display_fb1 
1986 22 5e fa				ld (display_fb_active), hl 
1989			 
1989			;	nop 
1989				STACKFRAME ON $fbfe $8f9f 
1989				if DEBUG_STACK_IMB 
1989					if ON 
1989						exx 
1989						ld de, $fbfe 
1989						ld a, d 
1989						ld hl, curframe 
1989						call hexout 
1989						ld a, e 
1989						ld hl, curframe+2 
1989						call hexout 
1989						ld hl, $fbfe 
1989						push hl 
1989						ld hl, $8f9f 
1989						push hl 
1989						exx 
1989					endif 
1989				endif 
1989			endm 
# End of macro STACKFRAME
1989				; first time into the parser so pass over the current scratch pad 
1989 21 ca f2			ld hl,os_cli_cmd 
198c				; tokenise the entered statement(s) in HL 
198c cd 63 20			call forthparse 
198f			        ; exec forth statements in top of return stack 
198f cd a3 20			call forthexec 
1992				;call forthexec_cleanup 
1992			;	call parsenext 
1992			 
1992				STACKFRAMECHK ON $fbfe $8f9f 
1992				if DEBUG_STACK_IMB 
1992					if ON 
1992						exx 
1992						ld hl, $8f9f 
1992						pop de   ; $8f9f 
1992						call cmp16 
1992						jr nz, .spnosame 
1992						ld hl, $fbfe 
1992						pop de   ; $fbfe 
1992						call cmp16 
1992						jr z, .spfrsame 
1992						.spnosame: call showsperror 
1992						.spfrsame: nop 
1992						exx 
1992					endif 
1992				endif 
1992			endm 
# End of macro STACKFRAMECHK
1992				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1992			 
1992 3e 3c			ld a, display_row_4 
1994 11 c6 19			ld de, endprog 
1997			 
1997 cd f8 0a			call update_display		 
199a			 
199a cd 24 1c			call next_page_prompt 
199d			 
199d				; switch frame buffer to cli 
199d			 
199d 21 53 fb				ld hl, display_fb0 
19a0 22 5e fa				ld (display_fb_active), hl 
19a3			 
19a3			 
19a3 cd d5 0a		        call clear_display 
19a6 cd f8 0a			call update_display		 
19a9			 
19a9 21 ca f2			ld hl, os_cli_cmd 
19ac			 
19ac 3e 00			ld a, 0		 ; init cli input 
19ae 77				ld (hl), a 
19af			 
19af				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19af			 
19af				; now on last line 
19af			 
19af				; TODO scroll screen up 
19af			 
19af				; TODO instead just clear screen and place at top of screen 
19af			 
19af			;	ld a, 0 
19af			;	ld (f_cursor_ptr),a 
19af			 
19af				;call clear_display 
19af				;call update_display 
19af			 
19af				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19af 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19b1 c3 6c 19			jp cli 
19b4			 
19b4 .. 00		freeram: db "Free bytes: $",0 
19c2 ..			asc: db "1A2F" 
19c6 .. 00		endprog: db "End prog...",0 
19d2			 
19d2			testenter2:   
19d2 21 d5 ef			ld hl,scratch+50 
19d5 22 c6 f2			ld (os_cur_ptr),hl 
19d8 c3 6c 19			jp cli 
19db			 
19db			testenter:  
19db			 
19db 21 c2 19			ld hl,asc 
19de			;	ld a,(hl) 
19de			;	call nibble2val 
19de cd 60 10			call get_byte 
19e1			 
19e1			 
19e1			;	ld a,(hl) 
19e1			;	call atohex 
19e1			 
19e1			;	call fourehexhl 
19e1 32 d5 ef			ld (scratch+50),a 
19e4			 
19e4			 
19e4			 
19e4 21 c4 19			ld hl,asc+2 
19e7			;	ld a, (hl) 
19e7			;	call nibble2val 
19e7 cd 60 10			call get_byte 
19ea			 
19ea			;	call fourehexhl 
19ea 32 d7 ef			ld (scratch+52),a 
19ed				 
19ed 21 d5 ef			ld hl,scratch+50 
19f0 22 c6 f2			ld (os_cur_ptr),hl 
19f3 c3 6c 19			jp cli 
19f6			 
19f6			enter:	 
19f6 3a a7 ef			ld a,(scratch+4) 
19f9 fe 00			cp 0 
19fb 28 0c			jr z, .entercont 
19fd				; no, not a null term line so has an address to work out.... 
19fd			 
19fd 21 a5 ef			ld hl,scratch+2 
1a00 cd c0 10			call get_word_hl 
1a03			 
1a03 22 c6 f2			ld (os_cur_ptr),hl	 
1a06 c3 6c 19			jp cli 
1a09			 
1a09			 
1a09			.entercont:  
1a09			 
1a09 21 a5 ef			ld hl, scratch+2 
1a0c cd 60 10			call get_byte 
1a0f			 
1a0f 2a c6 f2		   	ld hl,(os_cur_ptr) 
1a12 77					ld (hl),a 
1a13 23					inc hl 
1a14 22 c6 f2				ld (os_cur_ptr),hl 
1a17				 
1a17			; get byte  
1a17			 
1a17			 
1a17 c3 6c 19			jp cli 
1a1a			 
1a1a			 
1a1a			; basic monitor support 
1a1a			 
1a1a			monitor: 
1a1a				;  
1a1a cd d5 0a			call clear_display 
1a1d 3e 00			ld a, 0 
1a1f 11 67 1a			ld de, .monprompt 
1a22 cd e8 0a			call str_at_display 
1a25 cd f8 0a			call update_display 
1a28			 
1a28				; get a monitor command 
1a28			 
1a28 0e 00			ld c, 0     ; entry at top left 
1a2a 16 64			ld d, 100   ; max buffer size 
1a2c 1e 0f			ld e, 15    ; input scroll area 
1a2e 3e 00			ld a, 0     ; init string 
1a30 21 a1 f1			ld hl, os_input 
1a33 77				ld (hl), a 
1a34 23				inc hl 
1a35 77				ld (hl), a 
1a36 21 a1 f1			ld hl, os_input 
1a39 3e 01			ld a, 1     ; init string 
1a3b cd 36 0d			call input_str 
1a3e			 
1a3e cd d5 0a		        call clear_display 
1a41 cd f8 0a			call update_display		 
1a44			 
1a44 3a a1 f1			ld a, (os_input) 
1a47 cd 5e 11			call toUpper 
1a4a fe 48		        cp 'H' 
1a4c 28 6f		        jr z, .monhelp 
1a4e fe 44			cp 'D'		; dump 
1a50 ca de 1a			jp z, .mondump	 
1a53 fe 43			cp 'C'		; dump 
1a55 ca f8 1a			jp z, .moncdump	 
1a58 fe 4d			cp 'M'		; dump 
1a5a ca 69 1a			jp z, .moneditstart 
1a5d fe 55			cp 'U'		; dump 
1a5f 28 14			jr z, .monedit	 
1a61 fe 51			cp 'Q'		; dump 
1a63 c8				ret z	 
1a64			 
1a64			 
1a64				; TODO "S" to access symbol by name and not need the address 
1a64				; TODO "F" to find a string in memory 
1a64			 
1a64 c3 1a 1a			jp monitor 
1a67			 
1a67 .. 00		.monprompt: db ">", 0 
1a69			 
1a69			.moneditstart: 
1a69				; get starting address 
1a69			 
1a69 21 a3 f1			ld hl,os_input+2 
1a6c cd c0 10			call get_word_hl 
1a6f			 
1a6f 22 c6 f2			ld (os_cur_ptr),hl	 
1a72			 
1a72 c3 1a 1a			jp monitor 
1a75			 
1a75			.monedit: 
1a75				; get byte to load 
1a75			 
1a75 21 a3 f1			ld hl,os_input+2 
1a78 cd 60 10			call get_byte 
1a7b			 
1a7b				; get address to update 
1a7b 2a c6 f2			ld hl, (os_cur_ptr) 
1a7e			 
1a7e				; update byte 
1a7e			 
1a7e 77				ld (hl), a 
1a7f			 
1a7f				; move to next address and save it 
1a7f			 
1a7f 23				inc hl 
1a80 22 c6 f2			ld (os_cur_ptr),hl	 
1a83			 
1a83 c3 1a 1a			jp monitor 
1a86			 
1a86			 
1a86 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a9a .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ab6 .. 00		.monhelptext3:  db "Q-Quit",0 
1abd			        
1abd			.monhelp: 
1abd 3e 00			ld a, display_row_1 
1abf 11 86 1a		        ld de, .monhelptext1 
1ac2			 
1ac2 cd e8 0a			call str_at_display 
1ac5 3e 14			ld a, display_row_2 
1ac7 11 9a 1a		        ld de, .monhelptext2 
1aca					 
1aca cd e8 0a			call str_at_display 
1acd 3e 28			ld a, display_row_3 
1acf 11 b6 1a		        ld de, .monhelptext3 
1ad2					 
1ad2 cd e8 0a			call str_at_display 
1ad5 cd f8 0a			call update_display		 
1ad8			 
1ad8 cd 24 1c			call next_page_prompt 
1adb c3 1a 1a			jp monitor 
1ade			 
1ade			.mondump:    
1ade 21 a3 f1			ld hl,os_input+2 
1ae1 cd c0 10			call get_word_hl 
1ae4			 
1ae4 22 c6 f2			ld (os_cur_ptr),hl	 
1ae7 cd 2c 1b			call dumpcont 
1aea 3e 3c			ld a, display_row_4 
1aec 11 c6 19			ld de, endprog 
1aef			 
1aef cd f8 0a			call update_display		 
1af2			 
1af2 cd 24 1c			call next_page_prompt 
1af5 c3 1a 1a			jp monitor 
1af8			.moncdump: 
1af8 cd 2c 1b			call dumpcont 
1afb 3e 3c			ld a, display_row_4 
1afd 11 c6 19			ld de, endprog 
1b00			 
1b00 cd f8 0a			call update_display		 
1b03			 
1b03 cd 24 1c			call next_page_prompt 
1b06 c3 1a 1a			jp monitor 
1b09			 
1b09			 
1b09			; TODO symbol access  
1b09			 
1b09			.symbols:     ;; A list of symbols that can be called up  
1b09 53 fb			dw display_fb0 
1b0b .. 00			db "fb0",0  
1b0f e8 f9		     	dw store_page 
1b11 .. 00			db "store_page",0 
1b1c			 
1b1c			 
1b1c			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b1c			 
1b1c 3a a4 ef			ld a,(scratch+1) 
1b1f fe 00			cp 0 
1b21 28 09			jr z, dumpcont 
1b23			 
1b23				; no, not a null term line so has an address to work out.... 
1b23			 
1b23 21 a5 ef			ld hl,scratch+2 
1b26 cd c0 10			call get_word_hl 
1b29			 
1b29 22 c6 f2			ld (os_cur_ptr),hl	 
1b2c			 
1b2c			 
1b2c			 
1b2c			dumpcont: 
1b2c			 
1b2c				; dump bytes at ptr 
1b2c			 
1b2c			 
1b2c 3e 00			ld a, display_row_1 
1b2e 2a 5e fa			ld hl, (display_fb_active) 
1b31 cd 09 0d			call addatohl 
1b34 cd 5c 1b			call .dumpbyterow 
1b37			 
1b37 3e 14			ld a, display_row_2 
1b39 2a 5e fa			ld hl, (display_fb_active) 
1b3c cd 09 0d			call addatohl 
1b3f cd 5c 1b			call .dumpbyterow 
1b42			 
1b42			 
1b42 3e 28			ld a, display_row_3 
1b44 2a 5e fa			ld hl, (display_fb_active) 
1b47 cd 09 0d			call addatohl 
1b4a cd 5c 1b			call .dumpbyterow 
1b4d			 
1b4d 3e 3c			ld a, display_row_4 
1b4f 2a 5e fa			ld hl, (display_fb_active) 
1b52 cd 09 0d			call addatohl 
1b55 cd 5c 1b			call .dumpbyterow 
1b58			 
1b58 cd f8 0a			call update_display 
1b5b			;		jp cli 
1b5b c9				ret 
1b5c			 
1b5c			.dumpbyterow: 
1b5c			 
1b5c				;push af 
1b5c			 
1b5c e5				push hl 
1b5d			 
1b5d				; calc where to poke the ascii 
1b5d			if display_cols == 20 
1b5d 3e 10			ld a, 16 
1b5f			else 
1b5f				ld a, 31 
1b5f			endif 
1b5f			 
1b5f cd 09 0d			call addatohl 
1b62 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1b65			 
1b65			 
1b65			; display decoding address 
1b65 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b68			 
1b68 7c				ld a,h 
1b69 e1				pop hl 
1b6a e5				push hl 
1b6b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b6b cd 0a 10			call hexout 
1b6e 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b71			 
1b71 7d				ld a,l 
1b72 e1				pop hl 
1b73 23				inc hl 
1b74 23				inc hl 
1b75 e5				push hl 
1b76			;	ld hl, os_word_scratch+2 
1b76 cd 0a 10			call hexout 
1b79 e1				pop hl 
1b7a 23				inc hl 
1b7b 23				inc hl 
1b7c				;ld hl, os_word_scratch+4 
1b7c 3e 3a			ld a, ':' 
1b7e 77				ld (hl),a 
1b7f 23				inc hl 
1b80				;ld a, 0 
1b80				;ld (hl),a 
1b80				;ld de, os_word_scratch 
1b80				;pop af 
1b80				;push af 
1b80			;		ld a, display_row_2 
1b80			;		call str_at_display 
1b80			;		call update_display 
1b80			 
1b80			 
1b80			;pop af 
1b80			;	add 5 
1b80			 
1b80			if display_cols == 20 
1b80 06 04			ld b, 4 
1b82			else 
1b82				ld b, 8 
1b82			endif	 
1b82			 
1b82			.dumpbyte: 
1b82 c5				push bc 
1b83 e5				push hl 
1b84			 
1b84			 
1b84 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b87 7e					ld a,(hl) 
1b88			 
1b88					; poke the ascii to display 
1b88 2a a8 f2				ld hl,(os_word_scratch) 
1b8b 77					ld (hl),a 
1b8c 23					inc hl 
1b8d 22 a8 f2				ld (os_word_scratch),hl 
1b90			 
1b90					 
1b90			 
1b90			 
1b90 e1					pop hl 
1b91 e5					push hl 
1b92			 
1b92 cd 0a 10				call hexout 
1b95			 
1b95					 
1b95 2a c6 f2		   	ld hl,(os_cur_ptr) 
1b98 23				inc hl 
1b99 22 c6 f2		   	ld (os_cur_ptr),hl 
1b9c			 
1b9c e1					pop hl 
1b9d 23					inc hl 
1b9e 23					inc hl 
1b9f 23					inc hl 
1ba0			 
1ba0			 
1ba0			 
1ba0					;ld a,0 
1ba0					;ld (os_word_scratch+2),a 
1ba0					;pop af 
1ba0					;push af 
1ba0			 
1ba0					;ld de, os_word_scratch 
1ba0					;call str_at_display 
1ba0			;		call update_display 
1ba0			;		pop af 
1ba0 c1					pop bc 
1ba1 c6 03				add 3 
1ba3 10 dd			djnz .dumpbyte 
1ba5			 
1ba5				 
1ba5			 
1ba5 c9				ret 
1ba6			 
1ba6			jump:	 
1ba6			 
1ba6 21 a5 ef			ld hl,scratch+2 
1ba9 cd c0 10			call get_word_hl 
1bac				;ld hl,(scratch+2) 
1bac				;call fourehexhl 
1bac			 
1bac 22 c6 f2			ld (os_cur_ptr),hl	 
1baf			 
1baf e9				jp (hl) 
1bb0			 
1bb0			 
1bb0			 
1bb0			; TODO implement a basic monitor mode to start with 
1bb0			 
1bb0			 
1bb0			 
1bb0			 
1bb0			 
1bb0			 
1bb0			 
1bb0			 
1bb0			 
1bb0			; testing and demo code during development 
1bb0			 
1bb0			 
1bb0 .. 00		str1: db "Enter some text...",0 
1bc3 .. 00		clear: db "                    ",0 
1bd8			 
1bd8			demo: 
1bd8			 
1bd8			 
1bd8			 
1bd8			;	call update_display 
1bd8			 
1bd8				; init scratch input area for testing 
1bd8 21 a3 ef			ld hl, scratch	 
1bdb 3e 00			ld a,0 
1bdd 77				ld (hl),a 
1bde			 
1bde			 
1bde 3e 14		            LD   A, display_row_2 
1be0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1be0 11 b0 1b		            LD   DE, str1 
1be3 cd e8 0a			call str_at_display 
1be6			 
1be6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1be6			cloop:	 
1be6 3e 28		            LD   A, display_row_3 
1be8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1be8 11 c3 1b		            LD   DE, clear 
1beb			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1beb cd e8 0a				call str_at_display 
1bee 3e 3c			ld a, display_row_4 
1bf0 11 20 1c			ld de, prompt 
1bf3			 
1bf3 cd e8 0a				call str_at_display 
1bf6 cd f8 0a			call update_display 
1bf9			 
1bf9 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bfb 16 0a			ld d, 10 
1bfd 21 a3 ef			ld hl, scratch	 
1c00 cd 36 0d			call input_str 
1c03			 
1c03			;	call clear_display 
1c03			;'	call update_display 
1c03			 
1c03 3e 00		            LD   A, display_row_1 
1c05			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c05 11 c3 1b		            LD   DE, clear 
1c08 cd e8 0a				call str_at_display 
1c0b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c0b 3e 00		            LD   A, display_row_1 
1c0d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c0d 11 a3 ef		            LD   DE, scratch 
1c10			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c10 cd e8 0a				call str_at_display 
1c13 cd f8 0a			call update_display 
1c16			 
1c16 3e 00				ld a,0 
1c18 21 a3 ef			ld hl, scratch 
1c1b 77				ld (hl),a 
1c1c			 
1c1c 00				nop 
1c1d c3 e6 1b			jp cloop 
1c20			 
1c20			 
1c20			 
1c20			; OS Prompt 
1c20			 
1c20 .. 00		prompt: db ">",0 
1c22 .. 00		endprg: db "?",0 
1c24			 
1c24			 
1c24			; handy next page prompt 
1c24			next_page_prompt: 
1c24 e5				push hl 
1c25 d5				push de 
1c26 f5				push af 
1c27 c5				push bc 
1c28			 
1c28 3e 4f			ld a,display_row_4 + display_cols - 1 
1c2a 11 22 1c		        ld de, endprg 
1c2d cd e8 0a			call str_at_display 
1c30 cd f8 0a			call update_display 
1c33 cd b9 66			call cin_wait 
1c36 c1				pop bc 
1c37 f1				pop af 
1c38 d1				pop de 
1c39 e1				pop hl 
1c3a			 
1c3a			 
1c3a c9				ret 
1c3b			 
1c3b			 
1c3b			; forth parser 
1c3b			 
1c3b			; My forth kernel 
1c3b			include "forth_kernel.asm" 
1c3b			; 
1c3b			; kernel to the forth OS 
1c3b			 
1c3b			DS_TYPE_STR: equ 1     ; string type 
1c3b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c3b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c3b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c3b			 
1c3b			FORTH_PARSEV1: equ 0 
1c3b			FORTH_PARSEV2: equ 0 
1c3b			FORTH_PARSEV3: equ 0 
1c3b			FORTH_PARSEV4: equ 0 
1c3b			FORTH_PARSEV5: equ 1 
1c3b			 
1c3b			;if FORTH_PARSEV5 
1c3b			;	FORTH_END_BUFFER: equ 0 
1c3b			;else 
1c3b			FORTH_END_BUFFER: equ 127 
1c3b			;endif 
1c3b			 
1c3b			FORTH_TRUE: equ 1 
1c3b			FORTH_FALSE: equ 0 
1c3b			 
1c3b			if FORTH_PARSEV4 
1c3b			include "forth_stackops.asm" 
1c3b			endif 
1c3b			 
1c3b			if FORTH_PARSEV5 
1c3b			include "forth_stackopsv5.asm" 
1c3b			 
1c3b			; Stack operations for v5 parser on wards 
1c3b			; * DATA stack 
1c3b			; * LOOP stack 
1c3b			; * RETURN stack 
1c3b			 
1c3b			 
1c3b			 
1c3b			FORTH_CHK_DSP_UNDER: macro 
1c3b				push hl 
1c3b				push de 
1c3b				ld hl,(cli_data_sp) 
1c3b				ld de, cli_data_stack 
1c3b				call cmp16 
1c3b				jp c, fault_dsp_under 
1c3b				pop de 
1c3b				pop hl 
1c3b				endm 
1c3b			 
1c3b			 
1c3b			FORTH_CHK_RSP_UNDER: macro 
1c3b				push hl 
1c3b				push de 
1c3b				ld hl,(cli_ret_sp) 
1c3b				ld de, cli_ret_stack 
1c3b				call cmp16 
1c3b				jp c, fault_rsp_under 
1c3b				pop de 
1c3b				pop hl 
1c3b				endm 
1c3b			 
1c3b			FORTH_CHK_LOOP_UNDER: macro 
1c3b				push hl 
1c3b				push de 
1c3b				ld hl,(cli_loop_sp) 
1c3b				ld de, cli_loop_stack 
1c3b				call cmp16 
1c3b				jp c, fault_loop_under 
1c3b				pop de 
1c3b				pop hl 
1c3b				endm 
1c3b			 
1c3b			FORTH_ERR_TOS_NOTSTR: macro 
1c3b				; TOSO might need more for checks when used 
1c3b				push af 
1c3b				ld a,(hl) 
1c3b				cp DS_TYPE_STR 
1c3b				jp nz, type_faultn   
1c3b				pop af 
1c3b				endm 
1c3b			 
1c3b			FORTH_ERR_TOS_NOTNUM: macro 
1c3b				push af 
1c3b				ld a,(hl) 
1c3b				cp DS_TYPE_INUM 
1c3b				jp nz, type_faultn   
1c3b				pop af 
1c3b				endm 
1c3b			 
1c3b			 
1c3b			; increase data stack pointer and save hl to it 
1c3b				 
1c3b			FORTH_DSP_NEXT: macro 
1c3b				call macro_forth_dsp_next 
1c3b				endm 
1c3b			 
1c3b			 
1c3b			macro_forth_dsp_next: 
1c3b				if DEBUG_FORTH_STACK_GUARD 
1c3b cd d4 61				call check_stacks 
1c3e				endif 
1c3e e5				push hl 
1c3f d5				push de 
1c40 eb				ex de,hl 
1c41 2a 90 f9			ld hl,(cli_data_sp) 
1c44 23				inc hl 
1c45 23				inc hl 
1c46			 
1c46			; PARSEV5 
1c46 23				inc hl 
1c47 22 90 f9			ld (cli_data_sp),hl 
1c4a 73				ld (hl), e 
1c4b 23				inc hl 
1c4c 72				ld (hl), d 
1c4d d1				pop de 
1c4e e1				pop hl 
1c4f				if DEBUG_FORTH_STACK_GUARD 
1c4f cd d4 61				call check_stacks 
1c52				endif 
1c52 c9				ret 
1c53			 
1c53			 
1c53			; increase ret stack pointer and save hl to it 
1c53				 
1c53			FORTH_RSP_NEXT: macro 
1c53				call macro_forth_rsp_next 
1c53				endm 
1c53			 
1c53			macro_forth_rsp_next: 
1c53				if DEBUG_FORTH_STACK_GUARD 
1c53 cd d4 61				call check_stacks 
1c56				endif 
1c56 e5				push hl 
1c57 d5				push de 
1c58 eb				ex de,hl 
1c59 2a 94 f9			ld hl,(cli_ret_sp) 
1c5c 23				inc hl 
1c5d 23				inc hl 
1c5e 22 94 f9			ld (cli_ret_sp),hl 
1c61 73				ld (hl), e 
1c62 23				inc hl 
1c63 72				ld (hl), d 
1c64 d1				pop de 
1c65 e1				pop hl 
1c66				if DEBUG_FORTH_STACK_GUARD 
1c66 cd d4 61				call check_stacks 
1c69				endif 
1c69 c9				ret 
1c6a			 
1c6a			; get current ret stack pointer and save to hl  
1c6a				 
1c6a			FORTH_RSP_TOS: macro 
1c6a				call macro_forth_rsp_tos 
1c6a				endm 
1c6a			 
1c6a			macro_forth_rsp_tos: 
1c6a				;push de 
1c6a 2a 94 f9			ld hl,(cli_ret_sp) 
1c6d cd a5 1c			call loadhlptrtohl 
1c70				;ld e, (hl) 
1c70				;inc hl 
1c70				;ld d, (hl) 
1c70				;ex de, hl 
1c70					if DEBUG_FORTH_WORDS 
1c70			;			DMARK "RST" 
1c70						CALLMONITOR 
1c70 cd 1c 17			call break_point_state  
1c73				endm  
# End of macro CALLMONITOR
1c73					endif 
1c73				;pop de 
1c73 c9				ret 
1c74			 
1c74			; pop ret stack pointer 
1c74				 
1c74			FORTH_RSP_POP: macro 
1c74				call macro_forth_rsp_pop 
1c74				endm 
1c74			 
1c74			 
1c74			macro_forth_rsp_pop: 
1c74				if DEBUG_FORTH_STACK_GUARD 
1c74			;		DMARK "RPP" 
1c74 cd d4 61				call check_stacks 
1c77					FORTH_CHK_RSP_UNDER 
1c77 e5				push hl 
1c78 d5				push de 
1c79 2a 94 f9			ld hl,(cli_ret_sp) 
1c7c 11 0e f9			ld de, cli_ret_stack 
1c7f cd 27 0d			call cmp16 
1c82 da e8 62			jp c, fault_rsp_under 
1c85 d1				pop de 
1c86 e1				pop hl 
1c87				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c87				endif 
1c87 e5				push hl 
1c88 2a 94 f9			ld hl,(cli_ret_sp) 
1c8b			 
1c8b			 
1c8b				if FORTH_ENABLE_FREE 
1c8b			 
1c8b					; get pointer 
1c8b			 
1c8b					push de 
1c8b					push hl 
1c8b			 
1c8b					ld e, (hl) 
1c8b					inc hl 
1c8b					ld d, (hl) 
1c8b			 
1c8b					ex de, hl 
1c8b					call free 
1c8b			 
1c8b					pop hl 
1c8b					pop de 
1c8b			 
1c8b			 
1c8b				endif 
1c8b			 
1c8b			 
1c8b 2b				dec hl 
1c8c 2b				dec hl 
1c8d 22 94 f9			ld (cli_ret_sp), hl 
1c90				; do stack underflow checks 
1c90 e1				pop hl 
1c91				if DEBUG_FORTH_STACK_GUARD 
1c91 cd d4 61				call check_stacks 
1c94					FORTH_CHK_RSP_UNDER 
1c94 e5				push hl 
1c95 d5				push de 
1c96 2a 94 f9			ld hl,(cli_ret_sp) 
1c99 11 0e f9			ld de, cli_ret_stack 
1c9c cd 27 0d			call cmp16 
1c9f da e8 62			jp c, fault_rsp_under 
1ca2 d1				pop de 
1ca3 e1				pop hl 
1ca4				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ca4				endif 
1ca4 c9				ret 
1ca5			 
1ca5			 
1ca5			 
1ca5			; routine to load word pointed to by hl into hl 
1ca5			 
1ca5			loadhlptrtohl: 
1ca5			 
1ca5 d5				push de 
1ca6 5e				ld e, (hl) 
1ca7 23				inc hl 
1ca8 56				ld d, (hl) 
1ca9 eb				ex de, hl 
1caa d1				pop de 
1cab			 
1cab c9				ret 
1cac			 
1cac			 
1cac			 
1cac			 
1cac			 
1cac			; push a number held in HL onto the data stack 
1cac			; entry point for pushing a value when already in hl used in function above 
1cac			 
1cac			forth_push_numhl: 
1cac			 
1cac e5				push hl    ; save value to push 
1cad			 
1cad			if DEBUG_FORTH_PUSH 
1cad				; see if disabled 
1cad			 
1cad			 
1cad f5				push af 
1cae 3a 94 ef			ld a, (os_view_disable) 
1cb1 fe 2a			cp '*' 
1cb3 28 34			jr z, .pskip2 
1cb5 e5				push hl 
1cb6 e5			push hl 
1cb7 cd d5 0a			call clear_display 
1cba e1			pop hl 
1cbb 7c				ld a,h 
1cbc 21 a8 f2			ld hl, os_word_scratch 
1cbf cd 0a 10			call hexout 
1cc2 e1				pop hl 
1cc3 7d				ld a,l 
1cc4 21 aa f2			ld hl, os_word_scratch+2 
1cc7 cd 0a 10			call hexout 
1cca			 
1cca 21 ac f2			ld hl, os_word_scratch+4 
1ccd 3e 00			ld a,0 
1ccf 77				ld (hl),a 
1cd0 11 a8 f2			ld de,os_word_scratch 
1cd3 3e 14				ld a, display_row_2 
1cd5 cd e8 0a				call str_at_display 
1cd8 11 e2 50			ld de, .push_num 
1cdb 3e 00			ld a, display_row_1 
1cdd			 
1cdd cd e8 0a				call str_at_display 
1ce0			 
1ce0			 
1ce0 cd f8 0a			call update_display 
1ce3 cd 55 0a			call delay1s 
1ce6 cd 55 0a			call delay1s 
1ce9			.pskip2:  
1ce9			 
1ce9 f1				pop af 
1cea			endif	 
1cea			 
1cea			 
1cea				FORTH_DSP_NEXT 
1cea cd 3b 1c			call macro_forth_dsp_next 
1ced				endm 
# End of macro FORTH_DSP_NEXT
1ced			 
1ced 2a 90 f9			ld hl, (cli_data_sp) 
1cf0			 
1cf0				; save item type 
1cf0 3e 02			ld a,  DS_TYPE_INUM 
1cf2 77				ld (hl), a 
1cf3 23				inc hl 
1cf4			 
1cf4				; get word off stack 
1cf4 d1				pop de 
1cf5 7b				ld a,e 
1cf6 77				ld (hl), a 
1cf7 23				inc hl 
1cf8 7a				ld a,d 
1cf9 77				ld (hl), a 
1cfa			 
1cfa			if DEBUG_FORTH_PUSH 
1cfa 2b				dec hl 
1cfb 2b				dec hl 
1cfc 2b				dec hl 
1cfd						DMARK "PH5" 
1cfd f5				push af  
1cfe 3a 12 1d			ld a, (.dmark)  
1d01 32 bd fb			ld (debug_mark),a  
1d04 3a 13 1d			ld a, (.dmark+1)  
1d07 32 be fb			ld (debug_mark+1),a  
1d0a 3a 14 1d			ld a, (.dmark+2)  
1d0d 32 bf fb			ld (debug_mark+2),a  
1d10 18 03			jr .pastdmark  
1d12 ..			.dmark: db "PH5"  
1d15 f1			.pastdmark: pop af  
1d16			endm  
# End of macro DMARK
1d16				CALLMONITOR 
1d16 cd 1c 17			call break_point_state  
1d19				endm  
# End of macro CALLMONITOR
1d19			endif	 
1d19			 
1d19 c9				ret 
1d1a			 
1d1a			 
1d1a			; Push a string to stack pointed to by hl 
1d1a			 
1d1a			forth_push_str: 
1d1a			 
1d1a			if DEBUG_FORTH_PUSH 
1d1a						DMARK "PSQ" 
1d1a f5				push af  
1d1b 3a 2f 1d			ld a, (.dmark)  
1d1e 32 bd fb			ld (debug_mark),a  
1d21 3a 30 1d			ld a, (.dmark+1)  
1d24 32 be fb			ld (debug_mark+1),a  
1d27 3a 31 1d			ld a, (.dmark+2)  
1d2a 32 bf fb			ld (debug_mark+2),a  
1d2d 18 03			jr .pastdmark  
1d2f ..			.dmark: db "PSQ"  
1d32 f1			.pastdmark: pop af  
1d33			endm  
# End of macro DMARK
1d33				CALLMONITOR 
1d33 cd 1c 17			call break_point_state  
1d36				endm  
# End of macro CALLMONITOR
1d36			endif	 
1d36			    
1d36 e5				push hl 
1d37 e5				push hl 
1d38			 
1d38			;	ld a, 0   ; find end of string 
1d38 cd 67 11			call strlenz 
1d3b			if DEBUG_FORTH_PUSH 
1d3b						DMARK "PQ2" 
1d3b f5				push af  
1d3c 3a 50 1d			ld a, (.dmark)  
1d3f 32 bd fb			ld (debug_mark),a  
1d42 3a 51 1d			ld a, (.dmark+1)  
1d45 32 be fb			ld (debug_mark+1),a  
1d48 3a 52 1d			ld a, (.dmark+2)  
1d4b 32 bf fb			ld (debug_mark+2),a  
1d4e 18 03			jr .pastdmark  
1d50 ..			.dmark: db "PQ2"  
1d53 f1			.pastdmark: pop af  
1d54			endm  
# End of macro DMARK
1d54				CALLMONITOR 
1d54 cd 1c 17			call break_point_state  
1d57				endm  
# End of macro CALLMONITOR
1d57			endif	 
1d57 eb				ex de, hl 
1d58 e1				pop hl   ; get ptr to start of string 
1d59			if DEBUG_FORTH_PUSH 
1d59						DMARK "PQ3" 
1d59 f5				push af  
1d5a 3a 6e 1d			ld a, (.dmark)  
1d5d 32 bd fb			ld (debug_mark),a  
1d60 3a 6f 1d			ld a, (.dmark+1)  
1d63 32 be fb			ld (debug_mark+1),a  
1d66 3a 70 1d			ld a, (.dmark+2)  
1d69 32 bf fb			ld (debug_mark+2),a  
1d6c 18 03			jr .pastdmark  
1d6e ..			.dmark: db "PQ3"  
1d71 f1			.pastdmark: pop af  
1d72			endm  
# End of macro DMARK
1d72				CALLMONITOR 
1d72 cd 1c 17			call break_point_state  
1d75				endm  
# End of macro CALLMONITOR
1d75			endif	 
1d75 19				add hl,de 
1d76			if DEBUG_FORTH_PUSH 
1d76						DMARK "PQE" 
1d76 f5				push af  
1d77 3a 8b 1d			ld a, (.dmark)  
1d7a 32 bd fb			ld (debug_mark),a  
1d7d 3a 8c 1d			ld a, (.dmark+1)  
1d80 32 be fb			ld (debug_mark+1),a  
1d83 3a 8d 1d			ld a, (.dmark+2)  
1d86 32 bf fb			ld (debug_mark+2),a  
1d89 18 03			jr .pastdmark  
1d8b ..			.dmark: db "PQE"  
1d8e f1			.pastdmark: pop af  
1d8f			endm  
# End of macro DMARK
1d8f				CALLMONITOR 
1d8f cd 1c 17			call break_point_state  
1d92				endm  
# End of macro CALLMONITOR
1d92			endif	 
1d92			 
1d92 2b				dec hl    ; see if there is an optional trailing double quote 
1d93 7e				ld a,(hl) 
1d94 fe 22			cp '"' 
1d96 20 03			jr nz, .strnoq 
1d98 3e 00			ld a, 0      ; get rid of double quote 
1d9a 77				ld (hl), a 
1d9b 23			.strnoq: inc hl 
1d9c			 
1d9c 3e 00			ld a, 0 
1d9e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d9f			 
1d9f 13				inc de ; add one for the type string 
1da0 13				inc de ; add one for null term??? 
1da1			 
1da1				; tos is get string pointer again 
1da1				; de contains space to allocate 
1da1				 
1da1 d5				push de 
1da2			 
1da2 eb				ex de, hl 
1da3			 
1da3				;push af 
1da3			 
1da3			if DEBUG_FORTH_PUSH 
1da3						DMARK "PHm" 
1da3 f5				push af  
1da4 3a b8 1d			ld a, (.dmark)  
1da7 32 bd fb			ld (debug_mark),a  
1daa 3a b9 1d			ld a, (.dmark+1)  
1dad 32 be fb			ld (debug_mark+1),a  
1db0 3a ba 1d			ld a, (.dmark+2)  
1db3 32 bf fb			ld (debug_mark+2),a  
1db6 18 03			jr .pastdmark  
1db8 ..			.dmark: db "PHm"  
1dbb f1			.pastdmark: pop af  
1dbc			endm  
# End of macro DMARK
1dbc				CALLMONITOR 
1dbc cd 1c 17			call break_point_state  
1dbf				endm  
# End of macro CALLMONITOR
1dbf			endif	 
1dbf cd d0 11			call malloc	; on ret hl now contains allocated memory 
1dc2				if DEBUG_FORTH_MALLOC_GUARD 
1dc2 cc 3a 51				call z,malloc_error 
1dc5				endif 
1dc5			 
1dc5				 
1dc5 c1				pop bc    ; get length 
1dc6 d1				pop de   ;  get string start    
1dc7			 
1dc7				; hl has destination from malloc 
1dc7			 
1dc7 eb				ex de, hl    ; prep for ldir 
1dc8			 
1dc8 d5				push de   ; save malloc area for DSP later 
1dc9				;push hl   ; save malloc area for DSP later 
1dc9			 
1dc9			if DEBUG_FORTH_PUSH 
1dc9						DMARK "PHc" 
1dc9 f5				push af  
1dca 3a de 1d			ld a, (.dmark)  
1dcd 32 bd fb			ld (debug_mark),a  
1dd0 3a df 1d			ld a, (.dmark+1)  
1dd3 32 be fb			ld (debug_mark+1),a  
1dd6 3a e0 1d			ld a, (.dmark+2)  
1dd9 32 bf fb			ld (debug_mark+2),a  
1ddc 18 03			jr .pastdmark  
1dde ..			.dmark: db "PHc"  
1de1 f1			.pastdmark: pop af  
1de2			endm  
# End of macro DMARK
1de2				CALLMONITOR 
1de2 cd 1c 17			call break_point_state  
1de5				endm  
# End of macro CALLMONITOR
1de5			endif	 
1de5			 
1de5			 
1de5 ed b0			ldir 
1de7			 
1de7			 
1de7				; push malloc to data stack     macro?????  
1de7			 
1de7				FORTH_DSP_NEXT 
1de7 cd 3b 1c			call macro_forth_dsp_next 
1dea				endm 
# End of macro FORTH_DSP_NEXT
1dea			 
1dea				; save value and type 
1dea			 
1dea 2a 90 f9			ld hl, (cli_data_sp) 
1ded			 
1ded				; save item type 
1ded 3e 01			ld a,  DS_TYPE_STR 
1def 77				ld (hl), a 
1df0 23				inc hl 
1df1			 
1df1				; get malloc word off stack 
1df1 d1				pop de 
1df2 73				ld (hl), e 
1df3 23				inc hl 
1df4 72				ld (hl), d 
1df5			 
1df5			 
1df5			 
1df5			if DEBUG_FORTH_PUSH 
1df5 2a 90 f9			ld hl, (cli_data_sp) 
1df8						DMARK "PHS" 
1df8 f5				push af  
1df9 3a 0d 1e			ld a, (.dmark)  
1dfc 32 bd fb			ld (debug_mark),a  
1dff 3a 0e 1e			ld a, (.dmark+1)  
1e02 32 be fb			ld (debug_mark+1),a  
1e05 3a 0f 1e			ld a, (.dmark+2)  
1e08 32 bf fb			ld (debug_mark+2),a  
1e0b 18 03			jr .pastdmark  
1e0d ..			.dmark: db "PHS"  
1e10 f1			.pastdmark: pop af  
1e11			endm  
# End of macro DMARK
1e11				CALLMONITOR 
1e11 cd 1c 17			call break_point_state  
1e14				endm  
# End of macro CALLMONITOR
1e14			;	ex de,hl 
1e14			endif	 
1e14				; in case of spaces, skip the ptr past the copied string 
1e14				;pop af 
1e14				;ld (cli_origptr),hl 
1e14			 
1e14 c9				ret 
1e15			 
1e15			 
1e15			 
1e15			; TODO ascii push input onto stack given hl to start of input 
1e15			 
1e15			; identify type 
1e15			; if starts with a " then a string 
1e15			; otherwise it is a number 
1e15			;  
1e15			; if a string 
1e15			;     scan for ending " to get length of string to malloc for + 1 
1e15			;     malloc 
1e15			;     put pointer to string on stack first byte flags as string 
1e15			; 
1e15			; else a number 
1e15			;    look for number format identifier 
1e15			;    $xx hex 
1e15			;    %xxxxx bin 
1e15			;    xxxxx decimal 
1e15			;    convert number to 16bit word.  
1e15			;    malloc word + 1 with flag to identiy as num 
1e15			;    put pointer to number on stack 
1e15			;   
1e15			;  
1e15			  
1e15			forth_apush: 
1e15				; kernel push 
1e15			 
1e15			if DEBUG_FORTH_PUSH 
1e15						DMARK "PSH" 
1e15 f5				push af  
1e16 3a 2a 1e			ld a, (.dmark)  
1e19 32 bd fb			ld (debug_mark),a  
1e1c 3a 2b 1e			ld a, (.dmark+1)  
1e1f 32 be fb			ld (debug_mark+1),a  
1e22 3a 2c 1e			ld a, (.dmark+2)  
1e25 32 bf fb			ld (debug_mark+2),a  
1e28 18 03			jr .pastdmark  
1e2a ..			.dmark: db "PSH"  
1e2d f1			.pastdmark: pop af  
1e2e			endm  
# End of macro DMARK
1e2e				CALLMONITOR 
1e2e cd 1c 17			call break_point_state  
1e31				endm  
# End of macro CALLMONITOR
1e31			endif	 
1e31				; identify input type 
1e31			 
1e31 7e				ld a,(hl) 
1e32 fe 22			cp '"' 
1e34 28 0a			jr z, .fapstr 
1e36 fe 24			cp '$' 
1e38 ca 60 1e			jp z, .faphex 
1e3b fe 25			cp '%' 
1e3d ca 48 1e			jp z, .fapbin 
1e40			;	cp 'b' 
1e40			;	jp z, .fabin 
1e40				; else decimal 
1e40			 
1e40				; TODO do decimal conversion 
1e40				; decimal is stored as a 16bit word 
1e40			 
1e40				; by default everything is a string if type is not detected 
1e40			.fapstr: ; 
1e40 fe 22			cp '"' 
1e42 20 01			jr nz, .strnoqu 
1e44 23				inc hl 
1e45			.strnoqu: 
1e45 c3 1a 1d			jp forth_push_str 
1e48			 
1e48			 
1e48			 
1e48			.fapbin:    ; push a binary string.  
1e48 11 00 00			ld de, 0   ; hold a 16bit value 
1e4b			 
1e4b 23			.fapbinshift:	inc hl  
1e4c 7e				ld a,(hl) 
1e4d fe 00			cp 0     ; done scanning  
1e4f 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e51			 
1e51				; left shift de 
1e51 eb				ex de, hl	 
1e52 29				add hl, hl 
1e53			 
1e53				; is 1 
1e53 fe 31			cp '1' 
1e55 20 02			jr nz, .binzero 
1e57 cb 4d			bit 1, l 
1e59			.binzero: 
1e59 eb				ex de, hl	 ; save current de 
1e5a 18 ef			jr .fapbinshift 
1e5c			 
1e5c			.fapbdone: 
1e5c eb				ex de, hl 
1e5d c3 ac 1c			jp forth_push_numhl 
1e60			 
1e60			 
1e60			.faphex:   ; hex is always stored as a 16bit word 
1e60				; skip number prefix 
1e60 23				inc hl 
1e61				; turn ascii into number 
1e61 cd c0 10			call get_word_hl	; ret 16bit word in hl 
1e64			 
1e64 c3 ac 1c			jp forth_push_numhl 
1e67			 
1e67 00				 nop 
1e68			 
1e68			.fabin:   ; TODO bin conversion 
1e68			 
1e68			 
1e68 c9				ret 
1e69			 
1e69			 
1e69			; get either a string ptr or a 16bit word from the data stack 
1e69			 
1e69			FORTH_DSP: macro 
1e69				call macro_forth_dsp 
1e69				endm 
1e69			 
1e69			macro_forth_dsp: 
1e69				; data stack pointer points to current word on tos 
1e69			 
1e69 2a 90 f9			ld hl,(cli_data_sp) 
1e6c			 
1e6c				if DEBUG_FORTH_PUSH 
1e6c						DMARK "DSP" 
1e6c f5				push af  
1e6d 3a 81 1e			ld a, (.dmark)  
1e70 32 bd fb			ld (debug_mark),a  
1e73 3a 82 1e			ld a, (.dmark+1)  
1e76 32 be fb			ld (debug_mark+1),a  
1e79 3a 83 1e			ld a, (.dmark+2)  
1e7c 32 bf fb			ld (debug_mark+2),a  
1e7f 18 03			jr .pastdmark  
1e81 ..			.dmark: db "DSP"  
1e84 f1			.pastdmark: pop af  
1e85			endm  
# End of macro DMARK
1e85			 
1e85 cd 6f 51				call display_data_sp 
1e88				;call break_point_state 
1e88				;rst 030h 
1e88				CALLMONITOR 
1e88 cd 1c 17			call break_point_state  
1e8b				endm  
# End of macro CALLMONITOR
1e8b				endif 
1e8b			 
1e8b c9				ret 
1e8c			 
1e8c			; return hl to start of value on stack 
1e8c			 
1e8c			FORTH_DSP_VALUE: macro 
1e8c				call macro_forth_dsp_value 
1e8c				endm 
1e8c			 
1e8c			macro_forth_dsp_value: 
1e8c			 
1e8c				FORTH_DSP 
1e8c cd 69 1e			call macro_forth_dsp 
1e8f				endm 
# End of macro FORTH_DSP
1e8f			 
1e8f d5				push de 
1e90			 
1e90 23				inc hl ; skip type 
1e91			 
1e91 5e				ld e, (hl) 
1e92 23				inc hl 
1e93 56				ld d, (hl) 
1e94 eb				ex de,hl  
1e95			 
1e95 d1				pop de 
1e96			 
1e96 c9				ret 
1e97			 
1e97			; return hl to start of value to second item on stack 
1e97			 
1e97			FORTH_DSP_VALUEM1: macro 
1e97				call macro_forth_dsp_value_m1 
1e97				endm 
1e97			 
1e97			macro_forth_dsp_value_m1: 
1e97			 
1e97				FORTH_DSP 
1e97 cd 69 1e			call macro_forth_dsp 
1e9a				endm 
# End of macro FORTH_DSP
1e9a			 
1e9a 2b				dec hl 
1e9b 2b				dec hl 
1e9c			;	dec hl 
1e9c			 
1e9c d5				push de 
1e9d			 
1e9d 5e				ld e, (hl) 
1e9e 23				inc hl 
1e9f 56				ld d, (hl) 
1ea0 eb				ex de,hl  
1ea1			 
1ea1 d1				pop de 
1ea2			 
1ea2 c9				ret 
1ea3			 
1ea3				 
1ea3			 
1ea3			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ea3			 
1ea3			FORTH_DSP_POP: macro 
1ea3				call macro_forth_dsp_pop 
1ea3				endm 
1ea3			 
1ea3			 
1ea3			; get the tos data type 
1ea3			 
1ea3			FORTH_DSP_TYPE:   macro 
1ea3			 
1ea3				;FORTH_DSP_VALUE 
1ea3				FORTH_DSP 
1ea3				 
1ea3				; hl points to value 
1ea3				; check type 
1ea3			 
1ea3				ld a,(hl) 
1ea3			 
1ea3				endm 
1ea3			 
1ea3			; load the tos value into hl 
1ea3			 
1ea3			 
1ea3			FORTH_DSP_VALUEHL:  macro 
1ea3				call macro_dsp_valuehl 
1ea3				endm 
1ea3			 
1ea3			 
1ea3			 
1ea3			macro_dsp_valuehl: 
1ea3				FORTH_DSP_VALUE 
1ea3 cd 8c 1e			call macro_forth_dsp_value 
1ea6				endm 
# End of macro FORTH_DSP_VALUE
1ea6			 
1ea6				;FORTH_ERR_TOS_NOTNUM 
1ea6			 
1ea6				;inc hl   ; skip type id 
1ea6			 
1ea6			;	push de 
1ea6			; 
1ea6			;	ld e, (hl) 
1ea6			;	inc hl 
1ea6			;	ld d, (hl) 
1ea6			;	ex de,hl  
1ea6			 
1ea6			;	pop de 
1ea6			 
1ea6				if DEBUG_FORTH_PUSH 
1ea6						DMARK "DVL" 
1ea6 f5				push af  
1ea7 3a bb 1e			ld a, (.dmark)  
1eaa 32 bd fb			ld (debug_mark),a  
1ead 3a bc 1e			ld a, (.dmark+1)  
1eb0 32 be fb			ld (debug_mark+1),a  
1eb3 3a bd 1e			ld a, (.dmark+2)  
1eb6 32 bf fb			ld (debug_mark+2),a  
1eb9 18 03			jr .pastdmark  
1ebb ..			.dmark: db "DVL"  
1ebe f1			.pastdmark: pop af  
1ebf			endm  
# End of macro DMARK
1ebf				CALLMONITOR 
1ebf cd 1c 17			call break_point_state  
1ec2				endm  
# End of macro CALLMONITOR
1ec2				endif 
1ec2 c9				ret 
1ec3			 
1ec3			forth_apushstrhl:      
1ec3				; push of string requires use of cli_origptr 
1ec3				; bodge use 
1ec3			 
1ec3				; get current cli_origptr, save, update with temp pointer  
1ec3 ed 5b ac f9		ld de, (cli_origptr) 
1ec7 22 ac f9			ld (cli_origptr), hl 
1eca d5				push de 
1ecb cd 15 1e			call forth_apush 
1ece d1				pop de 
1ecf ed 53 ac f9		ld (cli_origptr), de 
1ed3 c9			        ret	 
1ed4			 
1ed4			 
1ed4			; increase loop stack pointer and save hl to it 
1ed4				 
1ed4			FORTH_LOOP_NEXT: macro 
1ed4				call macro_forth_loop_next 
1ed4				;nop 
1ed4				endm 
1ed4			 
1ed4			macro_forth_loop_next: 
1ed4				if DEBUG_FORTH_STACK_GUARD 
1ed4 cd d4 61				call check_stacks 
1ed7				endif 
1ed7 e5				push hl 
1ed8 d5				push de 
1ed9 eb				ex de,hl 
1eda 2a 92 f9			ld hl,(cli_loop_sp) 
1edd 23				inc hl 
1ede 23				inc hl 
1edf					if DEBUG_FORTH_WORDS 
1edf						DMARK "LNX" 
1edf f5				push af  
1ee0 3a f4 1e			ld a, (.dmark)  
1ee3 32 bd fb			ld (debug_mark),a  
1ee6 3a f5 1e			ld a, (.dmark+1)  
1ee9 32 be fb			ld (debug_mark+1),a  
1eec 3a f6 1e			ld a, (.dmark+2)  
1eef 32 bf fb			ld (debug_mark+2),a  
1ef2 18 03			jr .pastdmark  
1ef4 ..			.dmark: db "LNX"  
1ef7 f1			.pastdmark: pop af  
1ef8			endm  
# End of macro DMARK
1ef8						CALLMONITOR 
1ef8 cd 1c 17			call break_point_state  
1efb				endm  
# End of macro CALLMONITOR
1efb					endif 
1efb 22 92 f9			ld (cli_loop_sp),hl 
1efe 73				ld (hl), e 
1eff 23				inc hl 
1f00 72				ld (hl), d 
1f01 d1				pop de    ; been reversed so save a swap on restore 
1f02 e1				pop hl 
1f03				if DEBUG_FORTH_STACK_GUARD 
1f03 cd d4 61				call check_stacks 
1f06				endif 
1f06 c9				ret 
1f07			 
1f07			; get current ret stack pointer and save to hl  
1f07				 
1f07			FORTH_LOOP_TOS: macro 
1f07				call macro_forth_loop_tos 
1f07				endm 
1f07			 
1f07			macro_forth_loop_tos: 
1f07 d5				push de 
1f08 2a 92 f9			ld hl,(cli_loop_sp) 
1f0b 5e				ld e, (hl) 
1f0c 23				inc hl 
1f0d 56				ld d, (hl) 
1f0e eb				ex de, hl 
1f0f d1				pop de 
1f10 c9				ret 
1f11			 
1f11			; pop loop stack pointer 
1f11				 
1f11			FORTH_LOOP_POP: macro 
1f11				call macro_forth_loop_pop 
1f11				endm 
1f11			 
1f11			 
1f11			macro_forth_loop_pop: 
1f11				if DEBUG_FORTH_STACK_GUARD 
1f11					DMARK "LPP" 
1f11 f5				push af  
1f12 3a 26 1f			ld a, (.dmark)  
1f15 32 bd fb			ld (debug_mark),a  
1f18 3a 27 1f			ld a, (.dmark+1)  
1f1b 32 be fb			ld (debug_mark+1),a  
1f1e 3a 28 1f			ld a, (.dmark+2)  
1f21 32 bf fb			ld (debug_mark+2),a  
1f24 18 03			jr .pastdmark  
1f26 ..			.dmark: db "LPP"  
1f29 f1			.pastdmark: pop af  
1f2a			endm  
# End of macro DMARK
1f2a cd d4 61				call check_stacks 
1f2d					FORTH_CHK_LOOP_UNDER 
1f2d e5				push hl 
1f2e d5				push de 
1f2f 2a 92 f9			ld hl,(cli_loop_sp) 
1f32 11 0c f7			ld de, cli_loop_stack 
1f35 cd 27 0d			call cmp16 
1f38 da ee 62			jp c, fault_loop_under 
1f3b d1				pop de 
1f3c e1				pop hl 
1f3d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f3d				endif 
1f3d e5				push hl 
1f3e 2a 92 f9			ld hl,(cli_loop_sp) 
1f41 2b				dec hl 
1f42 2b				dec hl 
1f43 22 92 f9			ld (cli_loop_sp), hl 
1f46				; TODO do stack underflow checks 
1f46 e1				pop hl 
1f47				if DEBUG_FORTH_STACK_GUARD 
1f47 cd d4 61				call check_stacks 
1f4a					FORTH_CHK_LOOP_UNDER 
1f4a e5				push hl 
1f4b d5				push de 
1f4c 2a 92 f9			ld hl,(cli_loop_sp) 
1f4f 11 0c f7			ld de, cli_loop_stack 
1f52 cd 27 0d			call cmp16 
1f55 da ee 62			jp c, fault_loop_under 
1f58 d1				pop de 
1f59 e1				pop hl 
1f5a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f5a				endif 
1f5a c9				ret 
1f5b			 
1f5b			macro_forth_dsp_pop: 
1f5b			 
1f5b e5				push hl 
1f5c			 
1f5c				; release malloc data 
1f5c			 
1f5c				if DEBUG_FORTH_STACK_GUARD 
1f5c cd d4 61				call check_stacks 
1f5f					FORTH_CHK_DSP_UNDER 
1f5f e5				push hl 
1f60 d5				push de 
1f61 2a 90 f9			ld hl,(cli_data_sp) 
1f64 11 0a f5			ld de, cli_data_stack 
1f67 cd 27 0d			call cmp16 
1f6a da e2 62			jp c, fault_dsp_under 
1f6d d1				pop de 
1f6e e1				pop hl 
1f6f				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6f				endif 
1f6f				;ld hl,(cli_data_sp) 
1f6f			if DEBUG_FORTH_DOT 
1f6f				DMARK "DPP" 
1f6f				CALLMONITOR 
1f6f			endif	 
1f6f			 
1f6f			 
1f6f			if FORTH_ENABLE_DSPPOPFREE 
1f6f			 
1f6f				FORTH_DSP 
1f6f cd 69 1e			call macro_forth_dsp 
1f72				endm 
# End of macro FORTH_DSP
1f72			 
1f72 7e				ld a, (hl) 
1f73 fe 01			cp DS_TYPE_STR 
1f75 20 07			jr nz, .skippopfree 
1f77			 
1f77				FORTH_DSP_VALUEHL 
1f77 cd a3 1e			call macro_dsp_valuehl 
1f7a				endm 
# End of macro FORTH_DSP_VALUEHL
1f7a 00				nop 
1f7b			if DEBUG_FORTH_DOT 
1f7b				DMARK "DPf" 
1f7b				CALLMONITOR 
1f7b			endif	 
1f7b cd 9a 12			call free 
1f7e			.skippopfree: 
1f7e				 
1f7e			 
1f7e			endif 
1f7e			 
1f7e			if DEBUG_FORTH_DOT_KEY 
1f7e				DMARK "DP2" 
1f7e				CALLMONITOR 
1f7e			endif	 
1f7e			 
1f7e				; move pointer down 
1f7e			 
1f7e 2a 90 f9			ld hl,(cli_data_sp) 
1f81 2b				dec hl 
1f82 2b				dec hl 
1f83			; PARSEV5 
1f83 2b				dec hl 
1f84 22 90 f9			ld (cli_data_sp), hl 
1f87			 
1f87				if DEBUG_FORTH_STACK_GUARD 
1f87 cd d4 61				call check_stacks 
1f8a					FORTH_CHK_DSP_UNDER 
1f8a e5				push hl 
1f8b d5				push de 
1f8c 2a 90 f9			ld hl,(cli_data_sp) 
1f8f 11 0a f5			ld de, cli_data_stack 
1f92 cd 27 0d			call cmp16 
1f95 da e2 62			jp c, fault_dsp_under 
1f98 d1				pop de 
1f99 e1				pop hl 
1f9a				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f9a				endif 
1f9a			 
1f9a e1				pop hl 
1f9b			 
1f9b c9				ret 
1f9c			 
1f9c			getwordathl: 
1f9c				; hl points to an address 
1f9c				; load hl with the word at that address 
1f9c			 
1f9c d5				push de 
1f9d			 
1f9d 5e				ld e, (hl) 
1f9e 23				inc hl 
1f9f 56				ld d, (hl) 
1fa0 eb				ex de, hl 
1fa1			 
1fa1 d1				pop de 
1fa2 c9				ret 
1fa3			 
1fa3			 
1fa3			 
1fa3			 
1fa3			 
1fa3			; eof 
1fa3			 
# End of file forth_stackopsv5.asm
1fa3			endif 
1fa3			 
1fa3			user_word_eol:  
1fa3				; hl contains the pointer to where to create a linked list item from the end 
1fa3				; of the user dict to continue on at the system word dict 
1fa3				 
1fa3				; poke the stub of the word list linked list to repoint to rom words 
1fa3			 
1fa3				; stub format 
1fa3				; db   word id 
1fa3				; dw    link to next word 
1fa3			        ; db char length of token 
1fa3				; db string + 0 term 
1fa3				; db exec code....  
1fa3			 
1fa3 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fa5 77				ld (hl), a		; word id 
1fa6 23				inc hl 
1fa7			 
1fa7 11 6d 21			ld de, sysdict 
1faa 73				ld (hl), e		; next word link ie system dict 
1fab 23				inc hl 
1fac 72				ld (hl), d		; next word link ie system dict 
1fad 23				inc hl	 
1fae			 
1fae			;	ld (hl), sysdict		; next word link ie system dict 
1fae			;	inc hl 
1fae			;	inc hl 
1fae			 
1fae			;	inc hl 
1fae			;	inc hl 
1fae			 
1fae 3e 02			ld a, 2			; word length is 0 
1fb0 77				ld (hl), a	 
1fb1 23				inc hl 
1fb2			 
1fb2 3e 7e			ld a, '~'			; word length is 0 
1fb4 77				ld (hl), a	 
1fb5 23				inc hl 
1fb6 3e 00			ld a, 0			; save empty word 
1fb8 77				ld (hl), a 
1fb9			 
1fb9 c9				ret 
1fba			 
1fba				 
1fba			 
1fba			forthexec_cleanup: 
1fba				FORTH_RSP_POP 
1fba cd 74 1c			call macro_forth_rsp_pop 
1fbd				endm 
# End of macro FORTH_RSP_POP
1fbd c9				ret 
1fbe			 
1fbe			forth_call_hl: 
1fbe				; taking hl 
1fbe e5				push hl 
1fbf c9				ret 
1fc0			 
1fc0			; this is called to reset Forth system but keep existing uwords etc 
1fc0			 
1fc0			forth_warmstart: 
1fc0				; setup stack over/under flow checks 
1fc0				if DEBUG_FORTH_STACK_GUARD 
1fc0 cd ba 61				call chk_stk_init 
1fc3				endif 
1fc3			 
1fc3				; init stack pointers  - * these stacks go upwards *  
1fc3 21 0e f9			ld hl, cli_ret_stack 
1fc6 22 94 f9			ld (cli_ret_sp), hl	 
1fc9				; set bottom of stack 
1fc9 3e 00			ld a,0 
1fcb 77				ld (hl),a 
1fcc 23				inc hl 
1fcd 77				ld (hl),a 
1fce			 
1fce 21 0a f5			ld hl, cli_data_stack 
1fd1 22 90 f9			ld (cli_data_sp), hl	 
1fd4				; set bottom of stack 
1fd4 3e 00			ld a,0 
1fd6 77				ld (hl),a 
1fd7 23				inc hl 
1fd8 77				ld (hl),a 
1fd9			 
1fd9 21 0c f7			ld hl, cli_loop_stack 
1fdc 22 92 f9			ld (cli_loop_sp), hl	 
1fdf				; set bottom of stack 
1fdf 3e 00			ld a,0 
1fe1 77				ld (hl),a 
1fe2 23				inc hl 
1fe3 77				ld (hl),a 
1fe4			 
1fe4				; init extent of current open file 
1fe4			 
1fe4 3e 00			ld a, 0 
1fe6 32 df f9			ld (store_openext), a 
1fe9			 
1fe9 c9				ret 
1fea			 
1fea			 
1fea			; Cold Start - this is called to setup the whole Forth system 
1fea			 
1fea			forth_init: 
1fea			 
1fea				; setup stack over/under flow checks 
1fea			 
1fea			;	if DEBUG_FORTH_STACK_GUARD 
1fea			;		call chk_stk_init 
1fea			;	endif 
1fea			 
1fea				; enable auto display updates (slow.....) 
1fea			 
1fea 3e 01			ld a, 1 
1fec 32 aa f9			ld (cli_autodisplay), a 
1fef			 
1fef			 
1fef			 
1fef				; show start up screen 
1fef			 
1fef cd d5 0a			call clear_display 
1ff2			 
1ff2 3e 00			ld a,0 
1ff4 32 cc f9			ld (f_cursor_ptr), a 
1ff7			 
1ff7				; set start of word list in start of ram - for use when creating user words 
1ff7			 
1ff7 21 00 80			ld hl, baseram 
1ffa 22 a0 f2			ld (os_last_new_uword), hl 
1ffd cd a3 1f			call user_word_eol 
2000				 
2000			;		call display_data_sp 
2000			;		call next_page_prompt 
2000			 
2000			 
2000			 
2000			 
2000 c9				ret 
2001			 
2001 .. 00		.bootforth: db " Forth Kernel Init ",0 
2015			 
2015			; TODO push to stack 
2015			 
2015			;  
2015			 
2015			if FORTH_PARSEV2 
2015			 
2015			 
2015				include "forth_parserv2.asm" 
2015			 
2015			endif 
2015			 
2015			 
2015			; parse cli version 1 
2015			 
2015			if FORTH_PARSEV1 
2015			 
2015			 
2015			 
2015			      include "forth_parserv1.asm" 
2015			endif 
2015				 
2015			if FORTH_PARSEV3 
2015			 
2015			 
2015			 
2015			      include "forth_parserv3.asm" 
2015				include "forth_wordsv3.asm" 
2015			endif 
2015			 
2015			if FORTH_PARSEV4 
2015			 
2015			 
2015			 
2015			      include "forth_parserv4.asm" 
2015				include "forth_wordsv4.asm" 
2015			endif 
2015			 
2015			if FORTH_PARSEV5 
2015			 
2015			 
2015			 
2015			      include "forth_parserv5.asm" 
2015			 
2015			 
2015			; A better parser without using malloc and string copies all over the place.  
2015			; Exec in situ should be faster 
2015			 
2015			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2015			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2015			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2015			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2015			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2015			WORD_SYS_END: equ 0   ; Opcode for all user words 
2015			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2015			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2015			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2015			 
2015			; Core word preamble macro 
2015			 
2015			CWHEAD:   macro nxtword opcode lit len opflags 
2015				db WORD_SYS_CORE+opcode             
2015				; internal op code number 
2015				dw nxtword            
2015				; link to next dict word block 
2015				db len + 1 
2015				; literal length of dict word inc zero term 
2015				db lit,0              
2015				; literal dict word 
2015			        ; TODO db opflags        
2015				endm 
2015			 
2015			 
2015			NEXTW: macro  
2015				jp macro_next 
2015				endm 
2015			 
2015			macro_next: 
2015			if DEBUG_FORTH_PARSE_KEY 
2015				DMARK "NXT" 
2015				CALLMONITOR 
2015			endif	 
2015			;	inc hl  ; skip token null term  
2015 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2019 ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
201d 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2020			if DEBUG_FORTH_PARSE_KEY 
2020				DMARK "}AA" 
2020				CALLMONITOR 
2020			endif	 
2020 c3 23 21			jp execnext 
2023				;jp exec1 
2023			       
2023			 
2023			 
2023			; Another go at the parser to compile  
2023			 
2023			 
2023			; TODO rework parser to change all of the string words to byte tokens 
2023			; TODO do a search for  
2023			 
2023			; TODO first run normal parser to zero term sections 
2023			; TODO for each word do a token look up to get the op code 
2023			; TODO need some means to flag to the exec that this is a byte code form    
2023			 
2023			 
2023			forthcompile: 
2023			 
2023			; 
2023			; line parse: 
2023			;       parse raw input buffer 
2023			;       tokenise the words 
2023			;       malloc new copy (for looping etc) 
2023			;       copy to malloc + current pc in line to start of string and add line term 
2023			;       save on new rsp 
2023			; 
2023			 
2023			; hl to point to the line to tokenise 
2023			 
2023			;	push hl 
2023 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2026			 
2026			;	ld a,0		; string term on input 
2026			;	call strlent 
2026			 
2026			;	ld (os_tok_len), hl	 ; save string length 
2026			 
2026			;if DEBUG_FORTH_TOK 
2026			;	ex de,hl		 
2026			;endif 
2026			 
2026			;	pop hl 		; get back string pointer 
2026			 
2026			if DEBUG_FORTH_TOK 
2026						DMARK "TOc" 
2026				CALLMONITOR 
2026			endif 
2026 7e			.cptoken2:    ld a,(hl) 
2027 23				inc hl 
2028 fe 7f			cp FORTH_END_BUFFER 
202a 28 29			jr z, .cptokendone2 
202c fe 00			cp 0 
202e 28 25			jr z, .cptokendone2 
2030 fe 22			cp '"' 
2032 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2034 fe 20			cp ' ' 
2036 20 ee			jr nz,  .cptoken2 
2038			 
2038			; TODO consume comments held between ( and ) 
2038			 
2038				; we have a space so change to zero term for dict match later 
2038 2b				dec hl 
2039 3e 00			ld a,0 
203b 77				ld (hl), a 
203c 23				inc hl 
203d 18 e7			jr .cptoken2 
203f				 
203f			 
203f			.cptokenstr2: 
203f				; skip all white space until either eol (because forgot to term) or end double quote 
203f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
203f				;inc hl ; skip current double quote 
203f 7e				ld a,(hl) 
2040 23				inc hl 
2041 fe 22			cp '"' 
2043 28 e1			jr z, .cptoken2 
2045 fe 7f			cp FORTH_END_BUFFER 
2047 28 0c			jr z, .cptokendone2 
2049 fe 00			cp 0 
204b 28 08			jr z, .cptokendone2 
204d fe 20			cp ' ' 
204f 28 02			jr z, .cptmp2 
2051 18 ec			jr .cptokenstr2 
2053			 
2053			.cptmp2:	; we have a space so change to zero term for dict match later 
2053				;dec hl 
2053				;ld a,"-"	; TODO remove this when working 
2053				;ld (hl), a 
2053				;inc hl 
2053 18 ea			jr .cptokenstr2 
2055			 
2055			.cptokendone2: 
2055				;inc hl 
2055 3e 7f			ld a, FORTH_END_BUFFER 
2057 77				ld (hl),a 
2058 23				inc hl 
2059 3e 21			ld a, '!' 
205b 77				ld (hl),a 
205c			 
205c 2a a4 f2			ld hl,(os_tok_ptr) 
205f			         
205f			if DEBUG_FORTH_TOK 
205f						DMARK "Tc1" 
205f				CALLMONITOR 
205f			endif 
205f			 
205f				; push exec string to top of return stack 
205f				FORTH_RSP_NEXT 
205f cd 53 1c			call macro_forth_rsp_next 
2062				endm 
# End of macro FORTH_RSP_NEXT
2062 c9				ret 
2063			 
2063			; Another go at the parser need to simplify the process 
2063			 
2063			forthparse: 
2063			 
2063			; 
2063			; line parse: 
2063			;       parse raw input buffer 
2063			;       tokenise the words 
2063			;       malloc new copy (for looping etc) 
2063			;       copy to malloc + current pc in line to start of string and add line term 
2063			;       save on new rsp 
2063			; 
2063			 
2063			; hl to point to the line to tokenise 
2063			 
2063			;	push hl 
2063 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
2066			 
2066			;	ld a,0		; string term on input 
2066			;	call strlent 
2066			 
2066			;	ld (os_tok_len), hl	 ; save string length 
2066			 
2066			;if DEBUG_FORTH_TOK 
2066			;	ex de,hl		 
2066			;endif 
2066			 
2066			;	pop hl 		; get back string pointer 
2066			 
2066			if DEBUG_FORTH_TOK 
2066						DMARK "TOK" 
2066				CALLMONITOR 
2066			endif 
2066 7e			.ptoken2:    ld a,(hl) 
2067 23				inc hl 
2068 fe 7f			cp FORTH_END_BUFFER 
206a 28 29			jr z, .ptokendone2 
206c fe 00			cp 0 
206e 28 25			jr z, .ptokendone2 
2070 fe 22			cp '"' 
2072 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2074 fe 20			cp ' ' 
2076 20 ee			jr nz,  .ptoken2 
2078			 
2078			; TODO consume comments held between ( and ) 
2078			 
2078				; we have a space so change to zero term for dict match later 
2078 2b				dec hl 
2079 3e 00			ld a,0 
207b 77				ld (hl), a 
207c 23				inc hl 
207d 18 e7			jr .ptoken2 
207f				 
207f			 
207f			.ptokenstr2: 
207f				; skip all white space until either eol (because forgot to term) or end double quote 
207f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
207f				;inc hl ; skip current double quote 
207f 7e				ld a,(hl) 
2080 23				inc hl 
2081 fe 22			cp '"' 
2083 28 e1			jr z, .ptoken2 
2085 fe 7f			cp FORTH_END_BUFFER 
2087 28 0c			jr z, .ptokendone2 
2089 fe 00			cp 0 
208b 28 08			jr z, .ptokendone2 
208d fe 20			cp ' ' 
208f 28 02			jr z, .ptmp2 
2091 18 ec			jr .ptokenstr2 
2093			 
2093			.ptmp2:	; we have a space so change to zero term for dict match later 
2093				;dec hl 
2093				;ld a,"-"	; TODO remove this when working 
2093				;ld (hl), a 
2093				;inc hl 
2093 18 ea			jr .ptokenstr2 
2095			 
2095			.ptokendone2: 
2095				;inc hl 
2095 3e 7f			ld a, FORTH_END_BUFFER 
2097 77				ld (hl),a 
2098 23				inc hl 
2099 3e 21			ld a, '!' 
209b 77				ld (hl),a 
209c			 
209c 2a a4 f2			ld hl,(os_tok_ptr) 
209f			         
209f			if DEBUG_FORTH_TOK 
209f						DMARK "TK1" 
209f				CALLMONITOR 
209f			endif 
209f			 
209f				; push exec string to top of return stack 
209f				FORTH_RSP_NEXT 
209f cd 53 1c			call macro_forth_rsp_next 
20a2				endm 
# End of macro FORTH_RSP_NEXT
20a2 c9				ret 
20a3			 
20a3			; 
20a3			;	; malloc size + buffer pointer + if is loop flag 
20a3			;	ld hl,(os_tok_len) 		 ; get string length 
20a3			; 
20a3			;	ld a,l 
20a3			; 
20a3			;	cp 0			; we dont want to use a null string 
20a3			;	ret z 
20a3			; 
20a3			;;	add 3    ; prefix malloc with buffer for current word ptr 
20a3			; 
20a3			;	add 5     ; TODO when certain not over writing memory remove 
20a3			; 
20a3			;		 
20a3			; 
20a3			;if DEBUG_FORTH_TOK 
20a3			;			DMARK "TKE" 
20a3			;	CALLMONITOR 
20a3			;endif 
20a3			; 
20a3			;	ld l,a 
20a3			;	ld h,0 
20a3			;;	push hl   ; save required space for the copy later 
20a3			;	call malloc 
20a3			;if DEBUG_FORTH_TOK 
20a3			;			DMARK "TKM" 
20a3			;	CALLMONITOR 
20a3			;endif 
20a3			;	if DEBUG_FORTH_MALLOC_GUARD 
20a3			;		push af 
20a3			;		call ishlzero 
20a3			;;		ld a, l 
20a3			;;		add h 
20a3			;;		cp 0 
20a3			;		pop af 
20a3			;		 
20a3			;		call z,malloc_error 
20a3			;	endif 
20a3			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20a3			; 
20a3			; 
20a3			;if DEBUG_FORTH_TOK 
20a3			;			DMARK "TKR" 
20a3			;	CALLMONITOR 
20a3			;endif 
20a3			; 
20a3			;	FORTH_RSP_NEXT 
20a3			; 
20a3			;	;inc hl	 ; go past current buffer pointer 
20a3			;	;inc hl 
20a3			;	;inc hl   ; and past if loop flag 
20a3			;		; TODO Need to set flag  
20a3			; 
20a3			;	 
20a3			;	 
20a3			;	ex de,hl	; malloc is dest 
20a3			;	ld hl, (os_tok_len) 
20a3			;;	pop bc 
20a3			;	ld c, l                
20a3			;	ld b,0 
20a3			;	ld hl, (os_tok_ptr) 
20a3			; 
20a3			;if DEBUG_FORTH_TOK 
20a3			;			DMARK "TKT" 
20a3			;	CALLMONITOR 
20a3			;endif 
20a3			; 
20a3			;	; do str cpy 
20a3			; 
20a3			;	ldir      ; copy byte in hl to de 
20a3			; 
20a3			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20a3			; 
20a3			;if DEBUG_FORTH_TOK 
20a3			; 
20a3			;			DMARK "TKY" 
20a3			;	CALLMONITOR 
20a3			;endif 
20a3			;	;ld a,0 
20a3			;	;ld a,FORTH_END_BUFFER 
20a3			;	ex de, hl 
20a3			;	;dec hl			 ; go back over the space delim at the end of word 
20a3			;	;ld (hl),a 
20a3			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20a3			;	ld a,FORTH_END_BUFFER 
20a3			;	ld (hl),a 
20a3			;	inc hl 
20a3			;	ld a,FORTH_END_BUFFER 
20a3			;	ld (hl),a 
20a3			; 
20a3			;	; init the malloc area data 
20a3			;	; set pc for in current area 
20a3			;	;ld hl, (os_tok_malloc) 
20a3			;	;inc hl 
20a3			;	;inc hl 
20a3			;	;inc hl 
20a3			;	;ex de,hl 
20a3			;	;ld hl, (os_tok_malloc) 
20a3			;	;ld (hl),e 
20a3			;	;inc hl 
20a3			;	;ld (hl),d 
20a3			; 
20a3			; 
20a3			;	ld hl,(os_tok_malloc) 
20a3			;if DEBUG_FORTH_PARSE_KEY 
20a3			;			DMARK "TKU" 
20a3			;	CALLMONITOR 
20a3			;endif 
20a3			; 
20a3			;	ret 
20a3			 
20a3			forthexec: 
20a3			 
20a3			; line exec: 
20a3			; forth parser 
20a3			 
20a3			; 
20a3			;       get current exec line on rsp 
20a3			 
20a3				FORTH_RSP_TOS 
20a3 cd 6a 1c			call macro_forth_rsp_tos 
20a6				endm 
# End of macro FORTH_RSP_TOS
20a6			 
20a6			;       restore current pc - hl points to malloc of data 
20a6			 
20a6				;ld e, (hl) 
20a6				;inc hl 
20a6				;ld d, (hl) 
20a6				;ex de,hl 
20a6			 
20a6			 
20a6			exec1: 
20a6 22 a4 f2			ld (os_tok_ptr), hl 
20a9			 
20a9				; copy our PC to working vars  
20a9 22 ae f9			ld (cli_ptr), hl 
20ac 22 ac f9			ld (cli_origptr), hl 
20af			 
20af 7e				ld a,(hl) 
20b0 fe 7f			cp FORTH_END_BUFFER 
20b2 c8				ret z 
20b3			 
20b3				; skip any nulls 
20b3			 
20b3 fe 00			cp 0 
20b5 20 03			jr nz, .execword 
20b7 23				inc hl 
20b8 18 ec			jr exec1 
20ba			 
20ba			 
20ba			.execword: 
20ba			 
20ba			 
20ba			 
20ba			if DEBUG_FORTH_PARSE_KEY 
20ba						DMARK "KYQ" 
20ba				CALLMONITOR 
20ba			endif 
20ba			;       while at start of word: 
20ba			; get start of dict (in user area first) 
20ba			 
20ba 21 00 80		ld hl, baseram 
20bd			;ld hl, sysdict 
20bd 22 b0 f9		ld (cli_nextword),hl 
20c0			;           match word at pc 
20c0			;           exec word 
20c0			;           or push to dsp 
20c0			;           forward to next token 
20c0			;           if line term pop rsp and exit 
20c0			;        
20c0			 
20c0			if DEBUG_FORTH_PARSE_KEY 
20c0						DMARK "KYq" 
20c0				CALLMONITOR 
20c0			endif 
20c0			 
20c0			; 
20c0			; word comp 
20c0			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20c0			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20c0			;    move to start of word  
20c0			;    compare word to cli_token 
20c0			 
20c0			.execpnword:	; HL at start of a word in the dictionary to check 
20c0			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20c0			;	ld (cli_ptr), hl 
20c0			 
20c0 2a b0 f9			ld hl,(cli_nextword) 
20c3			 
20c3 cd 66 21			call forth_tok_next 
20c6			; tok next start here 
20c6			;	; TODO skip compiled symbol for now 
20c6			;	inc hl 
20c6			; 
20c6			;	; save pointer to next word 
20c6			; 
20c6			;	; hl now points to the address of the next word pointer  
20c6			;	ld e, (hl) 
20c6			;	inc hl 
20c6			;	ld d, (hl) 
20c6			;	inc l 
20c6			; 
20c6			;	ex de,hl 
20c6			;if DEBUG_FORTH_PARSE_NEXTWORD 
20c6			;	push bc 
20c6			;	ld bc, (cli_nextword) 
20c6			;			DMARK "NXW" 
20c6			;	CALLMONITOR 
20c6			;	pop bc 
20c6			;endif 
20c6			; tok next end here 
20c6 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
20c9 eb				ex de, hl 
20ca			 
20ca			 
20ca				; save the pointer of the current token - 1 to check against 
20ca				 
20ca 22 b4 f9			ld (cli_token), hl   
20cd				; TODO maybe remove below save if no debug 
20cd				; save token string ptr for any debug later 
20cd 23				inc hl  
20ce 22 b6 f9			ld (cli_origtoken), hl 
20d1 2b				dec hl 
20d2				; save pointer to the start of the next dictionay word 
20d2 7e				ld a,(hl)   ; get string length 
20d3 47				ld b,a 
20d4			.execpnwordinc:  
20d4 23				inc hl 
20d5 10 fd			djnz .execpnwordinc 
20d7 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
20da			 
20da				; now check the word token against the string being parsed 
20da			 
20da 2a b4 f9			ld hl,(cli_token) 
20dd 23				inc hl     ; skip string length (use zero term instead to end) 
20de 22 b4 f9			ld (cli_token), hl 
20e1			 
20e1			if DEBUG_FORTH_PARSE_KEY 
20e1						DMARK "KY2" 
20e1			endif 
20e1			if DEBUG_FORTH_PARSE_EXEC 
20e1				; see if disabled 
20e1			 
20e1				ld a, (os_view_disable) 
20e1				cp '*' 
20e1				jr z, .skip 
20e1			 
20e1				push hl 
20e1				push hl 
20e1				call clear_display 
20e1				ld de, .compword 
20e1				ld a, display_row_1 
20e1				call str_at_display 
20e1				pop de 
20e1				ld a, display_row_2 
20e1				call str_at_display 
20e1				ld hl,(cli_ptr) 
20e1				ld a,(hl) 
20e1			        ld hl, os_word_scratch 
20e1				ld (hl),a 
20e1				ld a,0 
20e1				inc hl 
20e1				ld (hl),a 	 
20e1				ld de, os_word_scratch 
20e1				ld a, display_row_2+10 
20e1				call str_at_display 
20e1				call update_display 
20e1				ld a, 100 
20e1				call aDelayInMS 
20e1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20e1				call delay250ms 
20e1				endif 
20e1				pop hl 
20e1			.skip:  
20e1			endif	 
20e1			.execpnchar:    ; compare char between token and string to parse 
20e1			 
20e1			if DEBUG_FORTH_PARSE_KEY 
20e1						DMARK "Ky3" 
20e1			endif 
20e1			if DEBUG_FORTH_PARSE_EXEC 
20e1				; see if disabled 
20e1			 
20e1				ld a, (os_view_disable) 
20e1				cp '*' 
20e1				jr z, .skip2 
20e1			 
20e1			;	call clear_display 
20e1			ld hl,(cli_token) 
20e1			ld a,(hl) 
20e1			ld (os_word_scratch),a 
20e1				ld hl,(cli_ptr) 
20e1			ld a,(hl) 
20e1				ld (os_word_scratch+1),a 
20e1				ld a,0 
20e1				ld (os_word_scratch+2),a 
20e1				ld de,os_word_scratch 
20e1				ld a,display_row_4 
20e1				call str_at_display 
20e1				call update_display 
20e1			.skip2:  
20e1			endif 
20e1 2a b4 f9			ld hl,(cli_token) 
20e4 7e				ld a, (hl)	 ; char in word token 
20e5 23				inc hl 		; move to next char 
20e6 22 b4 f9			ld (cli_token), hl ; and save it 
20e9 47				ld b,a 
20ea			 
20ea 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
20ed 7e				ld a,(hl) 
20ee 23				inc hl 
20ef 22 ae f9			ld (cli_ptr), hl		; move to next char 
20f2 cd 5e 11			call toUpper 		; make sure the input string matches case 
20f5			 
20f5			if DEBUG_FORTH_PARSE 
20f5			endif 
20f5			 
20f5				; input stream end of token is a space so get rid of it 
20f5			 
20f5			;	cp ' ' 
20f5			;	jr nz, .pnskipspace 
20f5			; 
20f5			;	ld a, 0		; make same term as word token term 
20f5			; 
20f5			;.pnskipspace: 
20f5			 
20f5			if DEBUG_FORTH_PARSE_KEY 
20f5						DMARK "KY7" 
20f5			endif 
20f5 b8				cp b 
20f6 c2 0c 21			jp nz, .execpnskipword	 ; no match so move to next word 
20f9				 
20f9			;    if same 
20f9			;       scan for string terms 0 for token and 32 for input 
20f9			 
20f9				 
20f9			if DEBUG_FORTH_PARSE_KEY 
20f9						DMARK "KY8" 
20f9			endif 
20f9			 
20f9 80				add b			 
20fa fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20fc							; TODO need to make sure last word in zero term string is accounted for 
20fc 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20fe			 
20fe			 
20fe				; at end of both strings so both are exact match 
20fe			 
20fe			;       skip ptr for next word 
20fe			 
20fe 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
2101 23				inc hl			 ; at next char 
2102 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
2105 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2108				 
2108				 
2108			if DEBUG_FORTH_PARSE_KEY 
2108						DMARK "KY3" 
2108			endif 
2108			 
2108			 
2108			 
2108			;       exec code block 
2108			if DEBUG_FORTH_JP 
2108				call clear_display 
2108				call update_display 
2108				call delay1s 
2108				ld hl, (cli_execword)     ; save for next check if no match on this word 
2108				ld a,h 
2108				ld hl, os_word_scratch 
2108				call hexout 
2108				ld hl, (cli_execword)     ; save for next check if no match on this word 
2108				ld a,l 
2108				ld hl, os_word_scratch+2 
2108				call hexout 
2108				ld hl, os_word_scratch+4 
2108				ld a,0 
2108				ld (hl),a 
2108				ld de,os_word_scratch 
2108				call str_at_display 
2108					ld a, display_row_2 
2108					call str_at_display 
2108				ld de, (cli_origtoken) 
2108				ld a, display_row_1+10 
2108					call str_at_display 
2108			 
2108				ld a,display_row_1 
2108				ld de, .foundword 
2108				ld a, display_row_3 
2108				call str_at_display 
2108				call update_display 
2108				call delay1s 
2108				call delay1s 
2108				call delay1s 
2108			endif 
2108			 
2108			if DEBUG_FORTH_PARSE_KEY 
2108						DMARK "KYj" 
2108			endif 
2108				; TODO save the word pointer in this exec 
2108			 
2108 2a b2 f9			ld hl,(cli_execword) 
210b e9				jp (hl) 
210c			 
210c			 
210c			;    if not same 
210c			;	scan for zero term 
210c			;	get ptr for next word 
210c			;	goto word comp 
210c			 
210c			.execpnskipword:	; get pointer to next word 
210c 2a b0 f9			ld hl,(cli_nextword) 
210f			 
210f 7e				ld a,(hl) 
2110 fe 00			cp WORD_SYS_END 
2112			;	cp 0 
2112 28 09			jr z, .execendofdict			 ; at end of words 
2114			 
2114			if DEBUG_FORTH_PARSE_KEY 
2114						DMARK "KY4" 
2114			endif 
2114			if DEBUG_FORTH_PARSE_EXEC 
2114			 
2114				; see if disabled 
2114			 
2114				ld a, (os_view_disable) 
2114				cp '*' 
2114				jr z, .noskip 
2114			 
2114			 
2114				ld de, .nowordfound 
2114				ld a, display_row_3 
2114				call str_at_display 
2114				call update_display 
2114				ld a, 100 
2114				call aDelayInMS 
2114				 
2114				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2114					call delay250ms 
2114				endif 
2114			.noskip:  
2114			 
2114			endif	 
2114			 
2114 2a ac f9			ld hl,(cli_origptr) 
2117 22 ae f9			ld (cli_ptr),hl 
211a			 
211a			if DEBUG_FORTH_PARSE_KEY 
211a						DMARK "KY5" 
211a			endif 
211a c3 c0 20			jp .execpnword			; else go to next word 
211d			 
211d			.execendofdict:  
211d			 
211d			if DEBUG_FORTH_PARSE_KEY 
211d						DMARK "KYe" 
211d			endif 
211d			if DEBUG_FORTH_PARSE_EXEC 
211d				; see if disabled 
211d			 
211d				ld a, (os_view_disable) 
211d				cp '*' 
211d				jr z, .ispskip 
211d			 
211d				call clear_display 
211d				call update_display 
211d				call delay1s 
211d				ld de, (cli_origptr) 
211d				ld a, display_row_1 
211d				call str_at_display 
211d				 
211d				ld de, .enddict 
211d				ld a, display_row_3 
211d				call str_at_display 
211d				call update_display 
211d				ld a, 100 
211d				call aDelayInMS 
211d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
211d				call delay1s 
211d				call delay1s 
211d				call delay1s 
211d				endif 
211d			.ispskip:  
211d				 
211d			endif	 
211d			 
211d			 
211d			 
211d				; if the word is not a keyword then must be a literal so push it to stack 
211d			 
211d			; push token to stack to end of word 
211d			 
211d				STACKFRAME ON $1efe $2f9f 
211d				if DEBUG_STACK_IMB 
211d					if ON 
211d						exx 
211d						ld de, $1efe 
211d						ld a, d 
211d						ld hl, curframe 
211d						call hexout 
211d						ld a, e 
211d						ld hl, curframe+2 
211d						call hexout 
211d						ld hl, $1efe 
211d						push hl 
211d						ld hl, $2f9f 
211d						push hl 
211d						exx 
211d					endif 
211d				endif 
211d			endm 
# End of macro STACKFRAME
211d			 
211d 2a a4 f2		ld hl,(os_tok_ptr) 
2120 cd 15 1e		call forth_apush 
2123			 
2123				STACKFRAMECHK ON $1efe $2f9f 
2123				if DEBUG_STACK_IMB 
2123					if ON 
2123						exx 
2123						ld hl, $2f9f 
2123						pop de   ; $2f9f 
2123						call cmp16 
2123						jr nz, .spnosame 
2123						ld hl, $1efe 
2123						pop de   ; $1efe 
2123						call cmp16 
2123						jr z, .spfrsame 
2123						.spnosame: call showsperror 
2123						.spfrsame: nop 
2123						exx 
2123					endif 
2123				endif 
2123			endm 
# End of macro STACKFRAMECHK
2123			 
2123			execnext: 
2123			 
2123			if DEBUG_FORTH_PARSE_KEY 
2123						DMARK "KY>" 
2123			endif 
2123			; move past token to next word 
2123			 
2123 2a a4 f2		ld hl, (os_tok_ptr) 
2126 3e 00		ld a, 0 
2128 01 ff 00		ld bc, 255     ; input buffer size 
212b ed b1		cpir 
212d			 
212d			if DEBUG_FORTH_PARSE_KEY 
212d						DMARK "KY!" 
212d				CALLMONITOR 
212d			endif	 
212d			; TODO this might place hl on the null, so will need to forward on??? 
212d			;inc hl   ; see if this gets onto the next item 
212d			 
212d			 
212d			; TODO pass a pointer to the buffer to push 
212d			; TODO call function to push 
212d			 
212d			; look for end of input 
212d			 
212d			;inc hl 
212d			;ld a,(hl) 
212d			;cp FORTH_END_BUFFER 
212d			;ret z 
212d			 
212d			 
212d c3 a6 20		jp exec1 
2130			 
2130			 
2130			 
2130			 
2130			 
2130			 
2130			 
2130			 
2130			 
2130			findnexttok: 
2130			 
2130				; hl is pointer to move 
2130				; de is the token to locate 
2130			 
2130					if DEBUG_FORTH 
2130						DMARK "NTK" 
2130						CALLMONITOR 
2130					endif 
2130 d5				push de 
2131			 
2131			.fnt1:	 
2131				; find first char of token to locate 
2131			 
2131 1a				ld a, (de) 
2132 4f				ld c,a 
2133 7e				ld a,(hl) 
2134 cd 5e 11			call toUpper 
2137					if DEBUG_FORTH 
2137						DMARK "NT1" 
2137						CALLMONITOR 
2137					endif 
2137 b9				cp c 
2138			 
2138 28 03			jr z, .fnt2cmpmorefirst	 
213a			 
213a				; first char not found move to next char 
213a			 
213a 23				inc hl 
213b 18 f4			jr .fnt1 
213d			 
213d			.fnt2cmpmorefirst:	 
213d				; first char of token found.  
213d			 
213d e5				push hl     ; save start of token just in case it is the right one 
213e d9				exx 
213f e1				pop hl        ; save it to hl' 
2140 d9				exx 
2141			 
2141			 
2141			.fnt2cmpmore:	 
2141				; compare the rest 
2141				 
2141 23				inc hl 
2142 13				inc de 
2143				 
2143 1a				ld a, (de) 
2144 4f				ld c,a 
2145 7e				ld a,(hl) 
2146 cd 5e 11			call toUpper 
2149			 
2149					if DEBUG_FORTH 
2149						DMARK "NT2" 
2149						CALLMONITOR 
2149					endif 
2149				; c has the token to find char 
2149				; a has the mem to scan char 
2149			 
2149 b9				cp c 
214a 28 04			jr z,.fntmatch1 
214c			 
214c				; they are not the same 
214c			 
214c					if DEBUG_FORTH 
214c						DMARK "NT3" 
214c						CALLMONITOR 
214c					endif 
214c d1				pop de	; reset de token to look for 
214d d5				push de 
214e 18 e1			jr .fnt1 
2150				 
2150			.fntmatch1: 
2150			 
2150				; is the same char a null which means we might have a full hit? 
2150					if DEBUG_FORTH 
2150						DMARK "NT4" 
2150						CALLMONITOR 
2150					endif 
2150			 
2150 fe 00			cp 0 
2152 28 0b			jr z, .fntmatchyes 
2154			 
2154				; are we at the end of the token to find? 
2154			 
2154					if DEBUG_FORTH 
2154						DMARK "NT5" 
2154						CALLMONITOR 
2154					endif 
2154 3e 00			ld a, 0 
2156 b9				cp c 
2157			 
2157 c2 41 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
215a			 
215a					if DEBUG_FORTH 
215a						DMARK "NT6" 
215a						CALLMONITOR 
215a					endif 
215a				; token to find is exhusted but no match to stream 
215a			 
215a				; restore tok pointer and continue on 
215a d1				pop de 
215b d5				push de 
215c c3 31 21			jp .fnt1 
215f			 
215f			 
215f			.fntmatchyes: 
215f			 
215f				; hl now contains the end of the found token 
215f			 
215f				; get rid of saved token pointer to find 
215f			 
215f d1				pop de 
2160			 
2160					if DEBUG_FORTH 
2160						DMARK "NT9" 
2160						CALLMONITOR 
2160					endif 
2160			 
2160				; hl will be on the null term so forward on 
2160			 
2160				; get back the saved start of the token 
2160			 
2160 d9				exx 
2161 e5				push hl     ; save start of token just in case it is the right one 
2162 d9				exx 
2163 e1				pop hl        ; save it to hl 
2164			 
2164 c9				ret 
2165			 
2165			 
2165			; LIST needs to find a specific token   
2165			; FORGET needs to find a spefici token 
2165			 
2165			; SAVE needs to find all tokens by flag 
2165			; WORDS just needs to scan through all  by flag 
2165			; UWORDS needs to scan through all by flag 
2165			 
2165			 
2165			; given hl as pointer to start of dict look up string 
2165			; return hl as pointer to start of word block 
2165			; or 0 if not found 
2165			 
2165			forth_find_tok: 
2165 c9				ret 
2166			 
2166			; given hl as pointer to dict structure 
2166			; move to the next dict block structure 
2166			 
2166			forth_tok_next: 
2166				; hl now points to the address of the next word pointer  
2166				; TODO skip compiled symbol for now 
2166			;	push de 
2166 23				inc hl 
2167 5e				ld e, (hl) 
2168 23				inc hl 
2169 56				ld d, (hl) 
216a 23				inc hl 
216b			 
216b eb				ex de,hl 
216c			if DEBUG_FORTH_PARSE_NEXTWORD 
216c				push bc 
216c				ld bc, (cli_nextword) 
216c						DMARK "NXW" 
216c				CALLMONITOR 
216c				pop bc 
216c			endif 
216c			;	pop de	 
216c c9				ret 
216d			 
216d			 
216d			 
216d			; eof 
# End of file forth_parserv5.asm
216d				include "forth_wordsv4.asm" 
216d			 
216d			; the core word dictionary v4 
216d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
216d			 
216d			; this is a linked list for each of the system words used 
216d			; user defined words will follow the same format but will be in ram 
216d			 
216d			 
216d			; 
216d			; 
216d			; define linked list: 
216d			; 
216d			; 1. compiled byte op code 
216d			; 2. len of text word 
216d			; 3. text word 
216d			; 4. ptr to next dictionary word 
216d			; 5. asm, calls etc for the word 
216d			; 
216d			;  if 1 == 0 then last word in dict  
216d			;   
216d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
216d			;  
216d			;  
216d			; create basic standard set of words 
216d			; 
216d			;  
216d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
216d			; 2DUP 2DROP 2SWAP  
216d			; @ C@ - get byte  
216d			; ! C! - store byte 
216d			; 0< true if less than zero 
216d			; 0= true if zero 
216d			; < >  
216d			; = true if same 
216d			; variables 
216d			 
216d			 
216d			; Hardware specific words I may need 
216d			; 
216d			; IN OUT  
216d			; calls to key util functions 
216d			; calls to hardward abstraction stuff 
216d			; easy control of frame buffers and lcd i/o 
216d			; keyboard  
216d			 
216d			 
216d			;DICT: macro 
216d			; op_code, len, word, next 
216d			;    word: 
216d			;    db op_code 
216d			;    ds word zero term 
216d			;    dw next 
216d			;    endm 
216d			 
216d			 
216d			 
216d			 
216d			; op code 1 is a flag for user define words which are to be handled differently 
216d			 
216d			 
216d			; 
216d			; 
216d			;    TODO on entry to a word this should be the expected environment 
216d			;    hl - tos value if number then held, if string this is the ptr 
216d			;    de -  
216d			 
216d			 
216d			; opcode ranges 
216d			; 0 - end of word dict 
216d			; 255 - user define words 
216d			 
216d			sysdict: 
216d			include "forth_opcodes.asm" 
216d			; op codes for forth keywords 
216d			; free to use code 0  
216d				OPCODE_HEAP: equ  1 
216d				OPCODE_EXEC: equ 2 
216d				OPCODE_DUP: equ 3 
216d				OPCODE_SWAP: equ 4 
216d				OPCODE_COLN: equ 5 
216d				OPCODE_SCOLN: equ 6 
216d				OPCODE_DROP: equ 7 
216d				OPCODE_DUP2: equ 8 
216d				OPCODE_DROP2: equ 9 
216d				OPCODE_SWAP2: equ 10 
216d				OPCODE_AT: equ 11 
216d				OPCODE_CAT: equ 12 
216d				OPCODE_BANG: equ 13 
216d				OPCODE_CBANG: equ 14 
216d				OPCODE_SCALL: equ 15 
216d				OPCODE_DEPTH: equ 16 
216d				OPCODE_OVER: equ 17 
216d				OPCODE_PAUSE: equ 18 
216d				OPCODE_PAUSES: equ 19 
216d				OPCODE_ROT: equ 20 
216d			;free to reuse	OPCODE_WORDS: equ 21 
216d			        OPCODE_NOT: equ 21 
216d				OPCODE_UWORDS: equ 22 
216d				OPCODE_BP: equ 23 
216d				OPCODE_MONITOR: equ 24  
216d				OPCODE_MALLOC: equ 25 
216d				OPCODE_FREE: equ 26 
216d				OPCODE_LIST: equ 27 
216d				OPCODE_FORGET: equ 28 
216d				OPCODE_NOP: equ 29 
216d				OPCODE_COMO: equ 30 
216d				OPCODE_COMC: equ 31 
216d			;free to reuse	OPCODE_ENDCORE: equ 32 
216d				OPCODE_AFTERSOUND: equ 33 
216d				OPCODE_GP2: equ 34 
216d				OPCODE_GP3: equ 35 
216d				OPCODE_GP4: equ 36 
216d				OPCODE_SIN: equ 37 
216d				OPCODE_SOUT: equ 38 
216d				OPCODE_SPIO: equ 39 
216d				OPCODE_SPICEH: equ 40 
216d				OPCODE_SPIOb: equ 41 
216d				OPCODE_SPII: equ 42 
216d				OPCODE_SESEL: equ 43 
216d				OPCODE_CARTDEV: equ 44 
216d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
216d				OPCODE_FB: equ 46 
216d				OPCODE_EMIT: equ 47 
216d				OPCODE_DOTH: equ 48 
216d				OPCODE_DOTF: equ 49 
216d				OPCODE_DOT: equ 50 
216d				OPCODE_CLS: equ 51 
216d				OPCODE_DRAW: equ 52 
216d				OPCODE_DUMP: equ 53 
216d				OPCODE_CDUMP: equ 54 
216d				OPCODE_DAT: equ 55 
216d				OPCODE_HOME: equ 56 
216d				OPCODE_SPACE: equ 57 
216d				OPCODE_SPACES: equ 58 
216d				OPCODE_SCROLL: equ 59 
216d				OPCODE_ATQ: equ 60 
216d				OPCODE_AUTODSP: equ 61 
216d				OPCODE_MENU: equ 62 
216d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
216d				OPCODE_THEN: equ 64 
216d				OPCODE_ELSE: equ 65 
216d				OPCODE_DO: equ 66 
216d				OPCODE_LOOP: equ 67 
216d				OPCODE_I: equ 68 
216d				OPCODE_DLOOP: equ 69  
216d				OPCODE_REPEAT: equ 70  
216d				OPCODE_UNTIL: equ 71 
216d				OPCODE_ENDFLOW: equ 72 
216d				OPCODE_WAITK: equ 73 
216d				OPCODE_ACCEPT: equ 74 
216d				OPCODE_EDIT: equ 75 
216d			;free to reuse	OPCODE_ENDKEY: equ 76 
216d				OPCODE_LZERO: equ 77 
216d				OPCODE_TZERO: equ 78 
216d				OPCODE_LESS: equ 79 
216d				OPCODE_GT: equ 80 
216d				OPCODE_EQUAL: equ 81  
216d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
216d				OPCODE_NEG: equ 83 
216d				OPCODE_DIV: equ 84 
216d				OPCODE_MUL: equ 85 
216d				OPCODE_MIN: equ 86 
216d				OPCODE_MAX: equ 87 
216d				OPCODE_RND16: equ 88 
216d				OPCODE_RND8: equ 89 
216d				OPCODE_RND: equ 90 
216d			;free to reuse	OPCODE_ENDMATHS: equ 91  
216d				OPCODE_BYNAME: equ 92 
216d				OPCODE_DIR: equ 93 
216d				OPCODE_SAVE: equ 94 
216d				OPCODE_LOAD: equ 95 
216d				OPCODE_BSAVE: equ 96 
216d				OPCODE_BLOAD: equ 97 
216d				OPCODE_SEO: equ 98  
216d				OPCODE_SEI: equ 99 
216d				OPCODE_SFREE: equ 100 
216d				OPCODE_SIZE: equ 101 
216d				OPCODE_CREATE: equ 102 
216d				OPCODE_APPEND: equ 103 
216d				OPCODE_SDEL: equ 104 
216d				OPCODE_OPEN: equ 105 
216d				OPCODE_READ: equ 106 
216d				OPCODE_EOF: equ 106 
216d				OPCODE_FORMAT: equ 107 
216d				OPCODE_LABEL: equ 108 
216d				OPCODE_LABELS: equ 109 
216d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
216d				OPCODE_UPPER: equ 111 
216d				OPCODE_LOWER: equ 112 
216d				OPCODE_SUBSTR: equ 113 
216d				OPCODE_LEFT: equ 114 
216d				OPCODE_RIGHT: equ 115 
216d				OPCODE_STR2NUM: equ 116 
216d				OPCODE_NUM2STR: equ 117 
216d				OPCODE_CONCAT: equ 118 
216d				OPCODE_FIND: equ 119 
216d				OPCODE_LEN: equ 120 
216d				OPCODE_CHAR: equ 121 
216d			; free to reuse	OPCODE_STRLEN: equ 122 
216d			; free to reuse	OPCODE_ENDSTR: equ 123 
216d				OPCODE_V0S: equ 124 
216d				OPCODE_V0Q: equ 125 
216d				OPCODE_V1S: equ 126 
216d				OPCODE_V1Q: equ 127 
216d				OPCODE_V2S: equ 128 
216d				OPCODE_V2Q: equ 129 
216d				OPCODE_V3S: equ 130 
216d				OPCODE_V3Q: equ 131 
216d			;free to reuse	OPCODE_END: equ 132 
216d				OPCODE_ZDUP: equ 133 
216d			 
216d			; eof 
# End of file forth_opcodes.asm
216d			 
216d			include "forth_words_core.asm" 
216d			 
216d			; | ## Core Words 
216d			 
216d			;if MALLOC_4 
216d			 
216d			.HEAP: 
216d				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
216d 15				db WORD_SYS_CORE+OPCODE_HEAP             
216e ac 21			dw .EXEC            
2170 05				db 4 + 1 
2171 .. 00			db "HEAP",0              
2176				endm 
# End of macro CWHEAD
2176			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2176			; | | u1 - Current number of bytes in the heap 
2176			; | | u2 - Remaining bytes left on the heap 
2176			; | |  
2176			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2176			 
2176			 
2176					if DEBUG_FORTH_WORDS_KEY 
2176						DMARK "HEP" 
2176 f5				push af  
2177 3a 8b 21			ld a, (.dmark)  
217a 32 bd fb			ld (debug_mark),a  
217d 3a 8c 21			ld a, (.dmark+1)  
2180 32 be fb			ld (debug_mark+1),a  
2183 3a 8d 21			ld a, (.dmark+2)  
2186 32 bf fb			ld (debug_mark+2),a  
2189 18 03			jr .pastdmark  
218b ..			.dmark: db "HEP"  
218e f1			.pastdmark: pop af  
218f			endm  
# End of macro DMARK
218f						CALLMONITOR 
218f cd 1c 17			call break_point_state  
2192				endm  
# End of macro CALLMONITOR
2192					endif 
2192 2a 0a 80				ld hl, (free_list )      
2195 11 0e 80				ld de, heap_start 
2198			 
2198 ed 52				sbc hl, de  
219a			 
219a cd ac 1c				call forth_push_numhl 
219d			 
219d			 
219d ed 5b 0a 80			ld de, (free_list )      
21a1 21 89 ef				ld hl, heap_end 
21a4			 
21a4 ed 52				sbc hl, de 
21a6			 
21a6 cd ac 1c				call forth_push_numhl 
21a9					 
21a9			 
21a9					 
21a9			 
21a9			 
21a9			 
21a9					NEXTW 
21a9 c3 15 20			jp macro_next 
21ac				endm 
# End of macro NEXTW
21ac			;endif 
21ac			 
21ac			.EXEC: 
21ac			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21ac			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21ac			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21ac			;; > > 
21ac			;; > >   
21ac			;	STACKFRAME OFF $5efe $5f9f 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS_KEY 
21ac			;			DMARK "EXE" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			; 
21ac			;	FORTH_DSP_VALUEHL 
21ac			; 
21ac			;	FORTH_DSP_POP 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX1" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;;	ld e,(hl) 
21ac			;;	inc hl 
21ac			;;	ld d,(hl) 
21ac			;;	ex de,hl 
21ac			; 
21ac			;;		if DEBUG_FORTH_WORDS 
21ac			;;			DMARK "EX2" 
21ac			;;			CALLMONITOR 
21ac			;;		endif 
21ac			;	push hl 
21ac			; 
21ac			;	;ld a, 0 
21ac			;	;ld a, FORTH_END_BUFFER 
21ac			;	call strlenz 
21ac			;	inc hl   ; include zero term to copy 
21ac			;	inc hl   ; include term 
21ac			;	inc hl   ; include term 
21ac			;	ld b,0 
21ac			;	ld c,l 
21ac			;	pop hl 
21ac			;	ld de, execscratch 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX3" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	ldir 
21ac			; 
21ac			; 
21ac			;	ld hl, execscratch 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EXe" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			; 
21ac			;	call forthparse 
21ac			;	call forthexec 
21ac			;;	call forthexec_cleanup 
21ac			;;	call forthparse 
21ac			;;	call forthexec 
21ac			; 
21ac			;	STACKFRAMECHK OFF $5efe $5f9f 
21ac			; 
21ac			;	; an immediate word so no need to process any more words 
21ac			;	ret 
21ac			;	NEXTW 
21ac			 
21ac			; dead code - old version  
21ac			;	FORTH_RSP_NEXT 
21ac			 
21ac			;  
21ac			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21ac			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21ac			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21ac			;	push hl 
21ac			;	push de 
21ac			;	push bc 
21ac			; 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS_KEY 
21ac			;			DMARK "EXR" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			; 
21ac			; 
21ac			; 
21ac			;	;v5 FORTH_DSP_VALUE 
21ac			;	FORTH_DSP_VALUEHL 
21ac			; 
21ac			;	; TODO do string type checks 
21ac			; 
21ac			;;v5	inc hl   ; skip type 
21ac			; 
21ac			;	push hl  ; source code  
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX1" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	ld a, 0 
21ac			;	call strlent 
21ac			; 
21ac			;	inc hl 
21ac			;	inc hl 
21ac			;	inc hl 
21ac			;	inc hl 
21ac			; 
21ac			;	push hl    ; size 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX2" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	call malloc 
21ac			; 
21ac			;	ex de, hl    ; de now contains malloc area 
21ac			;	pop bc   	; get byte count 
21ac			;	pop hl      ; get string to copy 
21ac			; 
21ac			;	push de     ; save malloc for free later 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX3" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	ldir       ; duplicate string 
21ac			; 
21ac			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21ac			;	 
21ac			;	; TODO fix the parse would be better than this...  
21ac			;	ex de, hl 
21ac			;	dec hl 
21ac			;	ld a, 0 
21ac			;	ld (hl), a 
21ac			;	dec hl 
21ac			;	ld a, ' ' 
21ac			;	ld (hl), a 
21ac			;	dec hl 
21ac			;	ld (hl), a 
21ac			; 
21ac			;	dec hl 
21ac			;	ld (hl), a 
21ac			; 
21ac			; 
21ac			;	FORTH_DSP_POP  
21ac			; 
21ac			;	pop hl     
21ac			;	push hl    ; save malloc area 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX4" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			; 
21ac			;	call forthparse 
21ac			;	call forthexec 
21ac			;	 
21ac			;	pop hl 
21ac			;	if DEBUG_FORTH_WORDS 
21ac			;		DMARK "EX5" 
21ac			;		CALLMONITOR 
21ac			;	endif 
21ac			; 
21ac			;	if FORTH_ENABLE_FREE 
21ac			;	call free 
21ac			;	endif 
21ac			; 
21ac			;	if DEBUG_FORTH_WORDS 
21ac			;		DMARK "EX6" 
21ac			;		CALLMONITOR 
21ac			;	endif 
21ac			; 
21ac			;	pop bc 
21ac			;	pop de 
21ac			;	pop hl 
21ac			;;	FORTH_RSP_POP	  
21ac			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21ac			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21ac			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21ac			; 
21ac			;	if DEBUG_FORTH_WORDS 
21ac			;		DMARK "EX7" 
21ac			;		CALLMONITOR 
21ac			;	endif 
21ac			;	NEXTW 
21ac			 
21ac			;.STKEXEC: 
21ac			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21ac			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21ac			; 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS_KEY 
21ac			;			DMARK "STX" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			; 
21ac			;	FORTH_DSP_VALUEHL 
21ac			; 
21ac			;	ld (store_tmp1), hl    ; count 
21ac			; 
21ac			;	FORTH_DSP_POP 
21ac			;.stkexec1: 
21ac			;	ld hl, (store_tmp1)   ; count 
21ac			;	ld a, 0 
21ac			;	cp l 
21ac			;	ret z 
21ac			; 
21ac			;	dec hl 
21ac			;	ld (store_tmp1), hl    ; count 
21ac			;	 
21ac			;	FORTH_DSP_VALUEHL 
21ac			;	push hl 
21ac			;	 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EXp" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	FORTH_DSP_POP 
21ac			; 
21ac			;	call strlenz 
21ac			;	inc hl   ; include zero term to copy 
21ac			;	inc hl   ; include zero term to copy 
21ac			;	inc hl   ; include zero term to copy 
21ac			;	ld b,0 
21ac			;	ld c,l 
21ac			;	pop hl 
21ac			;	ld de, execscratch 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EX3" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	ldir 
21ac			; 
21ac			; 
21ac			;	ld hl, execscratch 
21ac			; 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EXP" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			; 
21ac			;	call forthparse 
21ac			;	ld hl, execscratch 
21ac			;		if DEBUG_FORTH_WORDS 
21ac			;			DMARK "EXx" 
21ac			;			CALLMONITOR 
21ac			;		endif 
21ac			;	call forthexec 
21ac			; 
21ac			;	jp .stkexec1 
21ac			; 
21ac			;	ret 
21ac			 
21ac			 
21ac			.DUP: 
21ac				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21ac 17				db WORD_SYS_CORE+OPCODE_DUP             
21ad 22 22			dw .ZDUP            
21af 04				db 3 + 1 
21b0 .. 00			db "DUP",0              
21b4				endm 
# End of macro CWHEAD
21b4			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21b4			 
21b4					if DEBUG_FORTH_WORDS_KEY 
21b4						DMARK "DUP" 
21b4 f5				push af  
21b5 3a c9 21			ld a, (.dmark)  
21b8 32 bd fb			ld (debug_mark),a  
21bb 3a ca 21			ld a, (.dmark+1)  
21be 32 be fb			ld (debug_mark+1),a  
21c1 3a cb 21			ld a, (.dmark+2)  
21c4 32 bf fb			ld (debug_mark+2),a  
21c7 18 03			jr .pastdmark  
21c9 ..			.dmark: db "DUP"  
21cc f1			.pastdmark: pop af  
21cd			endm  
# End of macro DMARK
21cd						CALLMONITOR 
21cd cd 1c 17			call break_point_state  
21d0				endm  
# End of macro CALLMONITOR
21d0					endif 
21d0			 
21d0					FORTH_DSP 
21d0 cd 69 1e			call macro_forth_dsp 
21d3				endm 
# End of macro FORTH_DSP
21d3			 
21d3 7e					ld a, (HL) 
21d4 fe 01				cp DS_TYPE_STR 
21d6 20 25				jr nz, .dupinum 
21d8			 
21d8					; push another string 
21d8			 
21d8					FORTH_DSP_VALUEHL     		 
21d8 cd a3 1e			call macro_dsp_valuehl 
21db				endm 
# End of macro FORTH_DSP_VALUEHL
21db			 
21db				if DEBUG_FORTH_WORDS 
21db					DMARK "DUs" 
21db f5				push af  
21dc 3a f0 21			ld a, (.dmark)  
21df 32 bd fb			ld (debug_mark),a  
21e2 3a f1 21			ld a, (.dmark+1)  
21e5 32 be fb			ld (debug_mark+1),a  
21e8 3a f2 21			ld a, (.dmark+2)  
21eb 32 bf fb			ld (debug_mark+2),a  
21ee 18 03			jr .pastdmark  
21f0 ..			.dmark: db "DUs"  
21f3 f1			.pastdmark: pop af  
21f4			endm  
# End of macro DMARK
21f4					CALLMONITOR 
21f4 cd 1c 17			call break_point_state  
21f7				endm  
# End of macro CALLMONITOR
21f7				endif 
21f7 cd 1a 1d				call forth_push_str 
21fa			 
21fa					NEXTW 
21fa c3 15 20			jp macro_next 
21fd				endm 
# End of macro NEXTW
21fd			 
21fd			 
21fd			.dupinum: 
21fd					 
21fd			 
21fd			 
21fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21fd cd a3 1e			call macro_dsp_valuehl 
2200				endm 
# End of macro FORTH_DSP_VALUEHL
2200			 
2200				; TODO add floating point number detection 
2200			 
2200				if DEBUG_FORTH_WORDS 
2200					DMARK "DUi" 
2200 f5				push af  
2201 3a 15 22			ld a, (.dmark)  
2204 32 bd fb			ld (debug_mark),a  
2207 3a 16 22			ld a, (.dmark+1)  
220a 32 be fb			ld (debug_mark+1),a  
220d 3a 17 22			ld a, (.dmark+2)  
2210 32 bf fb			ld (debug_mark+2),a  
2213 18 03			jr .pastdmark  
2215 ..			.dmark: db "DUi"  
2218 f1			.pastdmark: pop af  
2219			endm  
# End of macro DMARK
2219					CALLMONITOR 
2219 cd 1c 17			call break_point_state  
221c				endm  
# End of macro CALLMONITOR
221c				endif 
221c			 
221c cd ac 1c				call forth_push_numhl 
221f					NEXTW 
221f c3 15 20			jp macro_next 
2222				endm 
# End of macro NEXTW
2222			.ZDUP: 
2222				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2222 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2223 5a 22			dw .SWAP            
2225 05				db 4 + 1 
2226 .. 00			db "?DUP",0              
222b				endm 
# End of macro CWHEAD
222b			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
222b			 
222b					if DEBUG_FORTH_WORDS_KEY 
222b						DMARK "qDU" 
222b f5				push af  
222c 3a 40 22			ld a, (.dmark)  
222f 32 bd fb			ld (debug_mark),a  
2232 3a 41 22			ld a, (.dmark+1)  
2235 32 be fb			ld (debug_mark+1),a  
2238 3a 42 22			ld a, (.dmark+2)  
223b 32 bf fb			ld (debug_mark+2),a  
223e 18 03			jr .pastdmark  
2240 ..			.dmark: db "qDU"  
2243 f1			.pastdmark: pop af  
2244			endm  
# End of macro DMARK
2244						CALLMONITOR 
2244 cd 1c 17			call break_point_state  
2247				endm  
# End of macro CALLMONITOR
2247					endif 
2247					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2247 cd a3 1e			call macro_dsp_valuehl 
224a				endm 
# End of macro FORTH_DSP_VALUEHL
224a			 
224a e5					push hl 
224b			 
224b					; is it a zero? 
224b			 
224b 3e 00				ld a, 0 
224d 84					add h 
224e 85					add l 
224f			 
224f e1					pop hl 
2250			 
2250 fe 00				cp 0 
2252 28 03				jr z, .dup2orig 
2254			 
2254			 
2254 cd ac 1c				call forth_push_numhl 
2257			 
2257			 
2257				; TODO add floating point number detection 
2257			 
2257			.dup2orig: 
2257			 
2257					NEXTW 
2257 c3 15 20			jp macro_next 
225a				endm 
# End of macro NEXTW
225a			.SWAP: 
225a				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
225a 18				db WORD_SYS_CORE+OPCODE_SWAP             
225b 99 22			dw .COLN            
225d 05				db 4 + 1 
225e .. 00			db "SWAP",0              
2263				endm 
# End of macro CWHEAD
2263			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2263					if DEBUG_FORTH_WORDS_KEY 
2263						DMARK "SWP" 
2263 f5				push af  
2264 3a 78 22			ld a, (.dmark)  
2267 32 bd fb			ld (debug_mark),a  
226a 3a 79 22			ld a, (.dmark+1)  
226d 32 be fb			ld (debug_mark+1),a  
2270 3a 7a 22			ld a, (.dmark+2)  
2273 32 bf fb			ld (debug_mark+2),a  
2276 18 03			jr .pastdmark  
2278 ..			.dmark: db "SWP"  
227b f1			.pastdmark: pop af  
227c			endm  
# End of macro DMARK
227c						CALLMONITOR 
227c cd 1c 17			call break_point_state  
227f				endm  
# End of macro CALLMONITOR
227f					endif 
227f			 
227f					FORTH_DSP_VALUEHL 
227f cd a3 1e			call macro_dsp_valuehl 
2282				endm 
# End of macro FORTH_DSP_VALUEHL
2282 e5					push hl     ; w2 
2283			 
2283					FORTH_DSP_POP 
2283 cd 5b 1f			call macro_forth_dsp_pop 
2286				endm 
# End of macro FORTH_DSP_POP
2286			 
2286					FORTH_DSP_VALUEHL 
2286 cd a3 1e			call macro_dsp_valuehl 
2289				endm 
# End of macro FORTH_DSP_VALUEHL
2289			 
2289					FORTH_DSP_POP 
2289 cd 5b 1f			call macro_forth_dsp_pop 
228c				endm 
# End of macro FORTH_DSP_POP
228c			 
228c d1					pop de     ; w2	, hl = w1 
228d			 
228d eb					ex de, hl 
228e d5					push de 
228f			 
228f cd ac 1c				call forth_push_numhl 
2292			 
2292 e1					pop hl 
2293			 
2293 cd ac 1c				call forth_push_numhl 
2296					 
2296			 
2296					NEXTW 
2296 c3 15 20			jp macro_next 
2299				endm 
# End of macro NEXTW
2299			.COLN: 
2299				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2299 19				db WORD_SYS_CORE+OPCODE_COLN             
229a 25 24			dw .SCOLN            
229c 02				db 1 + 1 
229d .. 00			db ":",0              
229f				endm 
# End of macro CWHEAD
229f			; | : ( -- )         Create new word | DONE 
229f			 
229f					if DEBUG_FORTH_WORDS_KEY 
229f						DMARK "CLN" 
229f f5				push af  
22a0 3a b4 22			ld a, (.dmark)  
22a3 32 bd fb			ld (debug_mark),a  
22a6 3a b5 22			ld a, (.dmark+1)  
22a9 32 be fb			ld (debug_mark+1),a  
22ac 3a b6 22			ld a, (.dmark+2)  
22af 32 bf fb			ld (debug_mark+2),a  
22b2 18 03			jr .pastdmark  
22b4 ..			.dmark: db "CLN"  
22b7 f1			.pastdmark: pop af  
22b8			endm  
# End of macro DMARK
22b8						CALLMONITOR 
22b8 cd 1c 17			call break_point_state  
22bb				endm  
# End of macro CALLMONITOR
22bb					endif 
22bb				STACKFRAME OFF $8efe $989f 
22bb				if DEBUG_STACK_IMB 
22bb					if OFF 
22bb						exx 
22bb						ld de, $8efe 
22bb						ld a, d 
22bb						ld hl, curframe 
22bb						call hexout 
22bb						ld a, e 
22bb						ld hl, curframe+2 
22bb						call hexout 
22bb						ld hl, $8efe 
22bb						push hl 
22bb						ld hl, $989f 
22bb						push hl 
22bb						exx 
22bb					endif 
22bb				endif 
22bb			endm 
# End of macro STACKFRAME
22bb				; get parser buffer length  of new word 
22bb			 
22bb				 
22bb			 
22bb					; move tok past this to start of name defintition 
22bb					; TODO get word to define 
22bb					; TODO Move past word token 
22bb					; TODO get length of string up to the ';' 
22bb			 
22bb 2a a4 f2			ld hl, (os_tok_ptr) 
22be 23				inc hl 
22bf 23				inc hl 
22c0			 
22c0 3e 3b			ld a, ';' 
22c2 cd 72 11			call strlent 
22c5			 
22c5 7d				ld a,l 
22c6 32 9f ef			ld (os_new_parse_len), a 
22c9			 
22c9			 
22c9			if DEBUG_FORTH_UWORD 
22c9 ed 5b a4 f2		ld de, (os_tok_ptr) 
22cd						DMARK ":01" 
22cd f5				push af  
22ce 3a e2 22			ld a, (.dmark)  
22d1 32 bd fb			ld (debug_mark),a  
22d4 3a e3 22			ld a, (.dmark+1)  
22d7 32 be fb			ld (debug_mark+1),a  
22da 3a e4 22			ld a, (.dmark+2)  
22dd 32 bf fb			ld (debug_mark+2),a  
22e0 18 03			jr .pastdmark  
22e2 ..			.dmark: db ":01"  
22e5 f1			.pastdmark: pop af  
22e6			endm  
# End of macro DMARK
22e6				CALLMONITOR 
22e6 cd 1c 17			call break_point_state  
22e9				endm  
# End of macro CALLMONITOR
22e9			endif 
22e9			 
22e9			; 
22e9			;  new word memory layout: 
22e9			;  
22e9			;    : adg 6666 ;  
22e9			; 
22e9			;    db   1     ; user defined word  
22e9 23				inc hl    
22ea			;    dw   sysdict 
22ea 23				inc hl 
22eb 23				inc hl 
22ec			;    db <word len>+1 (for null) 
22ec 23				inc hl 
22ed			;    db .... <word> 
22ed			; 
22ed			 
22ed 23				inc hl    ; some extras for the word preamble before the above 
22ee 23				inc hl 
22ef 23				inc hl 
22f0 23				inc hl 
22f1 23				inc hl 
22f2 23				inc hl 
22f3 23				inc hl  
22f4 23				inc hl 
22f5 23				inc hl 
22f6 23				inc hl 
22f7 23				inc hl 
22f8 23				inc hl 
22f9 23				inc hl 
22fa 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22fb			;       exec word buffer 
22fb			;	<ptr word>   
22fb 23				inc hl 
22fc 23				inc hl 
22fd			;       <word list><null term> 7F final term 
22fd			 
22fd			 
22fd			if DEBUG_FORTH_UWORD 
22fd						DMARK ":02" 
22fd f5				push af  
22fe 3a 12 23			ld a, (.dmark)  
2301 32 bd fb			ld (debug_mark),a  
2304 3a 13 23			ld a, (.dmark+1)  
2307 32 be fb			ld (debug_mark+1),a  
230a 3a 14 23			ld a, (.dmark+2)  
230d 32 bf fb			ld (debug_mark+2),a  
2310 18 03			jr .pastdmark  
2312 ..			.dmark: db ":02"  
2315 f1			.pastdmark: pop af  
2316			endm  
# End of macro DMARK
2316				CALLMONITOR 
2316 cd 1c 17			call break_point_state  
2319				endm  
# End of macro CALLMONITOR
2319			endif 
2319			 
2319				 
2319					; malloc the size 
2319			 
2319 cd d0 11				call malloc 
231c 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
231f			 
231f			;    db   1     ; user defined word  
231f 3e 01				ld a, WORD_SYS_UWORD  
2321 77					ld (hl), a 
2322				 
2322 23				inc hl    
2323			;    dw   sysdict 
2323 11 6d 21			ld de, sysdict       ; continue on with the scan to the system dict 
2326 73				ld (hl), e 
2327 23				inc hl 
2328 72				ld (hl), d 
2329 23				inc hl 
232a			 
232a			 
232a			;    Setup dict word 
232a			 
232a 23				inc hl 
232b 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
232e			 
232e				; 1. get length of dict word 
232e			 
232e			 
232e 2a a4 f2			ld hl, (os_tok_ptr) 
2331 23				inc hl 
2332 23				inc hl    ; position to start of dict word 
2333 3e 00			ld a, 0 
2335 cd 72 11			call strlent 
2338			 
2338			 
2338 23				inc hl    ; to include null??? 
2339			 
2339				; write length of dict word 
2339			 
2339 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
233d 1b				dec de 
233e eb				ex de, hl 
233f 73				ld (hl), e 
2340 eb				ex de, hl 
2341			 
2341				 
2341			 
2341				; copy  
2341 4d				ld c, l 
2342 06 00			ld b, 0 
2344 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2348 2a a4 f2			ld hl, (os_tok_ptr) 
234b 23				inc hl 
234c 23				inc hl    ; position to start of dict word 
234d				 
234d			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
234d				 
234d				; TODO need to convert word to upper case 
234d			 
234d			ucasetok:	 
234d 7e				ld a,(hl) 
234e cd 5e 11			call toUpper 
2351 77				ld (hl),a 
2352 ed a0			ldi 
2354 f2 4d 23		 	jp p, ucasetok 
2357			 
2357			 
2357			 
2357				; de now points to start of where the word body code should be placed 
2357 ed 53 9b ef		ld (os_new_work_ptr), de 
235b				; hl now points to the words to throw at forthexec which needs to be copied 
235b 22 99 ef			ld (os_new_src_ptr), hl 
235e			 
235e				; TODO add 'call to forthexec' 
235e			 
235e			if DEBUG_FORTH_UWORD 
235e c5				push bc 
235f ed 4b a1 ef		ld bc, (os_new_malloc) 
2363						DMARK ":0x" 
2363 f5				push af  
2364 3a 78 23			ld a, (.dmark)  
2367 32 bd fb			ld (debug_mark),a  
236a 3a 79 23			ld a, (.dmark+1)  
236d 32 be fb			ld (debug_mark+1),a  
2370 3a 7a 23			ld a, (.dmark+2)  
2373 32 bf fb			ld (debug_mark+2),a  
2376 18 03			jr .pastdmark  
2378 ..			.dmark: db ":0x"  
237b f1			.pastdmark: pop af  
237c			endm  
# End of macro DMARK
237c				CALLMONITOR 
237c cd 1c 17			call break_point_state  
237f				endm  
# End of macro CALLMONITOR
237f c1				pop bc 
2380			endif 
2380			 
2380			 
2380				; create word preamble which should be: 
2380			 
2380			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2380			 
2380				;    ld hl, <word code> 
2380				;    jp user_exec 
2380			        ;    <word code bytes> 
2380			 
2380			 
2380			;	inc de     ; TODO ??? or are we already past the word's null 
2380 eb				ex de, hl 
2381			 
2381 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2383			 
2383 23				inc hl 
2384 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2387 23				inc hl 
2388			 
2388 23				inc hl 
2389 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
238b			 
238b 01 68 50			ld bc, user_exec 
238e 23				inc hl 
238f 71				ld (hl), c     ; poke address of user_exec 
2390 23				inc hl 
2391 70				ld (hl), b     
2392			 ; 
2392			;	inc hl 
2392			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2392			; 
2392			; 
2392			;	ld bc, macro_forth_rsp_next 
2392			;	inc hl 
2392			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2392			;	inc hl 
2392			;	ld (hl), b     
2392			 ; 
2392			;	inc hl 
2392			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2392			; 
2392			; 
2392			;	inc hl 
2392			;	ld bc, forthexec 
2392			;	ld (hl), c     ; poke address of forthexec 
2392			;	inc hl 
2392			;	ld (hl), b      
2392			; 
2392			;	inc hl 
2392			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2392			; 
2392			;	ld bc, user_dict_next 
2392			;	inc hl 
2392			;	ld (hl), c     ; poke address of forthexec 
2392			;	inc hl 
2392			;	ld (hl), b      
2392			 
2392				; hl is now where we need to copy the word byte data to save this 
2392			 
2392 23				inc hl 
2393 22 97 ef			ld (os_new_exec), hl 
2396				 
2396				; copy definition 
2396			 
2396 eb				ex de, hl 
2397			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2397			;	inc de    ; skip the PC for this parse 
2397 3a 9f ef			ld a, (os_new_parse_len) 
239a 4f				ld c, a 
239b 06 00			ld b, 0 
239d ed b0			ldir		 ; copy defintion 
239f			 
239f			 
239f				; poke the address of where the new word bytes live for forthexec 
239f			 
239f 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23a2			 
23a2 ed 5b 97 ef		ld de, (os_new_exec)      
23a6				 
23a6 73				ld (hl), e 
23a7 23				inc hl 
23a8 72				ld (hl), d 
23a9			 
23a9					; TODO copy last user dict word next link to this word 
23a9					; TODO update last user dict word to point to this word 
23a9			; 
23a9			; hl f923 de 812a ; bc 811a 
23a9			 
23a9			if DEBUG_FORTH_UWORD 
23a9 c5				push bc 
23aa ed 4b a1 ef		ld bc, (os_new_malloc) 
23ae						DMARK ":0A" 
23ae f5				push af  
23af 3a c3 23			ld a, (.dmark)  
23b2 32 bd fb			ld (debug_mark),a  
23b5 3a c4 23			ld a, (.dmark+1)  
23b8 32 be fb			ld (debug_mark+1),a  
23bb 3a c5 23			ld a, (.dmark+2)  
23be 32 bf fb			ld (debug_mark+2),a  
23c1 18 03			jr .pastdmark  
23c3 ..			.dmark: db ":0A"  
23c6 f1			.pastdmark: pop af  
23c7			endm  
# End of macro DMARK
23c7				CALLMONITOR 
23c7 cd 1c 17			call break_point_state  
23ca				endm  
# End of macro CALLMONITOR
23ca c1				pop bc 
23cb			endif 
23cb			if DEBUG_FORTH_UWORD 
23cb c5				push bc 
23cc ed 4b a1 ef		ld bc, (os_new_malloc) 
23d0 03				inc bc 
23d1 03				inc bc 
23d2 03				inc bc 
23d3 03				inc bc 
23d4 03				inc bc 
23d5 03				inc bc 
23d6 03				inc bc 
23d7 03				inc bc 
23d8			 
23d8						DMARK ":0B" 
23d8 f5				push af  
23d9 3a ed 23			ld a, (.dmark)  
23dc 32 bd fb			ld (debug_mark),a  
23df 3a ee 23			ld a, (.dmark+1)  
23e2 32 be fb			ld (debug_mark+1),a  
23e5 3a ef 23			ld a, (.dmark+2)  
23e8 32 bf fb			ld (debug_mark+2),a  
23eb 18 03			jr .pastdmark  
23ed ..			.dmark: db ":0B"  
23f0 f1			.pastdmark: pop af  
23f1			endm  
# End of macro DMARK
23f1				CALLMONITOR 
23f1 cd 1c 17			call break_point_state  
23f4				endm  
# End of macro CALLMONITOR
23f4 c1				pop bc 
23f5			endif 
23f5			 
23f5			; update word dict linked list for new word 
23f5			 
23f5			 
23f5 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23f8 23			inc hl     ; move to next work linked list ptr 
23f9			 
23f9 ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
23fd 73			ld (hl), e 
23fe 23			inc hl 
23ff 72			ld (hl), d 
2400			 
2400			if DEBUG_FORTH_UWORD 
2400 ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2404			endif 
2404			 
2404 ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
2408			 
2408			 
2408			if DEBUG_FORTH_UWORD 
2408						DMARK ":0+" 
2408 f5				push af  
2409 3a 1d 24			ld a, (.dmark)  
240c 32 bd fb			ld (debug_mark),a  
240f 3a 1e 24			ld a, (.dmark+1)  
2412 32 be fb			ld (debug_mark+1),a  
2415 3a 1f 24			ld a, (.dmark+2)  
2418 32 bf fb			ld (debug_mark+2),a  
241b 18 03			jr .pastdmark  
241d ..			.dmark: db ":0+"  
2420 f1			.pastdmark: pop af  
2421			endm  
# End of macro DMARK
2421				CALLMONITOR 
2421 cd 1c 17			call break_point_state  
2424				endm  
# End of macro CALLMONITOR
2424			endif 
2424			 
2424				STACKFRAMECHK OFF $8efe $989f 
2424				if DEBUG_STACK_IMB 
2424					if OFF 
2424						exx 
2424						ld hl, $989f 
2424						pop de   ; $989f 
2424						call cmp16 
2424						jr nz, .spnosame 
2424						ld hl, $8efe 
2424						pop de   ; $8efe 
2424						call cmp16 
2424						jr z, .spfrsame 
2424						.spnosame: call showsperror 
2424						.spfrsame: nop 
2424						exx 
2424					endif 
2424				endif 
2424			endm 
# End of macro STACKFRAMECHK
2424			 
2424 c9			ret    ; dont process any remaining parser tokens as they form new word 
2425			 
2425			 
2425			 
2425			 
2425			;		NEXT 
2425			.SCOLN: 
2425			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2425 06				db OPCODE_SCOLN 
2426 71 24			dw .DROP 
2428 02				db 2 
2429 .. 00			db ";",0           
242b			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
242b					if DEBUG_FORTH_WORDS_KEY 
242b						DMARK "SCN" 
242b f5				push af  
242c 3a 40 24			ld a, (.dmark)  
242f 32 bd fb			ld (debug_mark),a  
2432 3a 41 24			ld a, (.dmark+1)  
2435 32 be fb			ld (debug_mark+1),a  
2438 3a 42 24			ld a, (.dmark+2)  
243b 32 bf fb			ld (debug_mark+2),a  
243e 18 03			jr .pastdmark  
2440 ..			.dmark: db "SCN"  
2443 f1			.pastdmark: pop af  
2444			endm  
# End of macro DMARK
2444						CALLMONITOR 
2444 cd 1c 17			call break_point_state  
2447				endm  
# End of macro CALLMONITOR
2447					endif 
2447					FORTH_RSP_TOS 
2447 cd 6a 1c			call macro_forth_rsp_tos 
244a				endm 
# End of macro FORTH_RSP_TOS
244a e5					push hl 
244b					FORTH_RSP_POP 
244b cd 74 1c			call macro_forth_rsp_pop 
244e				endm 
# End of macro FORTH_RSP_POP
244e e1					pop hl 
244f			;		ex de,hl 
244f 22 a4 f2				ld (os_tok_ptr),hl 
2452			 
2452			if DEBUG_FORTH_UWORD 
2452						DMARK "SCL" 
2452 f5				push af  
2453 3a 67 24			ld a, (.dmark)  
2456 32 bd fb			ld (debug_mark),a  
2459 3a 68 24			ld a, (.dmark+1)  
245c 32 be fb			ld (debug_mark+1),a  
245f 3a 69 24			ld a, (.dmark+2)  
2462 32 bf fb			ld (debug_mark+2),a  
2465 18 03			jr .pastdmark  
2467 ..			.dmark: db "SCL"  
246a f1			.pastdmark: pop af  
246b			endm  
# End of macro DMARK
246b				CALLMONITOR 
246b cd 1c 17			call break_point_state  
246e				endm  
# End of macro CALLMONITOR
246e			endif 
246e					NEXTW 
246e c3 15 20			jp macro_next 
2471				endm 
# End of macro NEXTW
2471			 
2471			.DROP: 
2471				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2471 1b				db WORD_SYS_CORE+OPCODE_DROP             
2472 9c 24			dw .DUP2            
2474 05				db 4 + 1 
2475 .. 00			db "DROP",0              
247a				endm 
# End of macro CWHEAD
247a			; | DROP ( w -- )   drop the TOS item   | DONE 
247a					if DEBUG_FORTH_WORDS_KEY 
247a						DMARK "DRP" 
247a f5				push af  
247b 3a 8f 24			ld a, (.dmark)  
247e 32 bd fb			ld (debug_mark),a  
2481 3a 90 24			ld a, (.dmark+1)  
2484 32 be fb			ld (debug_mark+1),a  
2487 3a 91 24			ld a, (.dmark+2)  
248a 32 bf fb			ld (debug_mark+2),a  
248d 18 03			jr .pastdmark  
248f ..			.dmark: db "DRP"  
2492 f1			.pastdmark: pop af  
2493			endm  
# End of macro DMARK
2493						CALLMONITOR 
2493 cd 1c 17			call break_point_state  
2496				endm  
# End of macro CALLMONITOR
2496					endif 
2496					FORTH_DSP_POP 
2496 cd 5b 1f			call macro_forth_dsp_pop 
2499				endm 
# End of macro FORTH_DSP_POP
2499					NEXTW 
2499 c3 15 20			jp macro_next 
249c				endm 
# End of macro NEXTW
249c			.DUP2: 
249c				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
249c 1c				db WORD_SYS_CORE+OPCODE_DUP2             
249d e1 24			dw .DROP2            
249f 05				db 4 + 1 
24a0 .. 00			db "2DUP",0              
24a5				endm 
# End of macro CWHEAD
24a5			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24a5					if DEBUG_FORTH_WORDS_KEY 
24a5						DMARK "2DU" 
24a5 f5				push af  
24a6 3a ba 24			ld a, (.dmark)  
24a9 32 bd fb			ld (debug_mark),a  
24ac 3a bb 24			ld a, (.dmark+1)  
24af 32 be fb			ld (debug_mark+1),a  
24b2 3a bc 24			ld a, (.dmark+2)  
24b5 32 bf fb			ld (debug_mark+2),a  
24b8 18 03			jr .pastdmark  
24ba ..			.dmark: db "2DU"  
24bd f1			.pastdmark: pop af  
24be			endm  
# End of macro DMARK
24be						CALLMONITOR 
24be cd 1c 17			call break_point_state  
24c1				endm  
# End of macro CALLMONITOR
24c1					endif 
24c1					FORTH_DSP_VALUEHL 
24c1 cd a3 1e			call macro_dsp_valuehl 
24c4				endm 
# End of macro FORTH_DSP_VALUEHL
24c4 e5					push hl      ; 2 
24c5			 
24c5					FORTH_DSP_POP 
24c5 cd 5b 1f			call macro_forth_dsp_pop 
24c8				endm 
# End of macro FORTH_DSP_POP
24c8					 
24c8					FORTH_DSP_VALUEHL 
24c8 cd a3 1e			call macro_dsp_valuehl 
24cb				endm 
# End of macro FORTH_DSP_VALUEHL
24cb			;		push hl      ; 1 
24cb			 
24cb					FORTH_DSP_POP 
24cb cd 5b 1f			call macro_forth_dsp_pop 
24ce				endm 
# End of macro FORTH_DSP_POP
24ce			 
24ce			;		pop hl       ; 1 
24ce d1					pop de       ; 2 
24cf			 
24cf cd ac 1c				call forth_push_numhl 
24d2 eb					ex de, hl 
24d3 cd ac 1c				call forth_push_numhl 
24d6			 
24d6					 
24d6 eb					ex de, hl 
24d7			 
24d7 cd ac 1c				call forth_push_numhl 
24da eb					ex de, hl 
24db cd ac 1c				call forth_push_numhl 
24de			 
24de			 
24de					NEXTW 
24de c3 15 20			jp macro_next 
24e1				endm 
# End of macro NEXTW
24e1			.DROP2: 
24e1				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24e1 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24e2 10 25			dw .SWAP2            
24e4 06				db 5 + 1 
24e5 .. 00			db "2DROP",0              
24eb				endm 
# End of macro CWHEAD
24eb			; | 2DROP ( w w -- )    Double drop | DONE 
24eb					if DEBUG_FORTH_WORDS_KEY 
24eb						DMARK "2DR" 
24eb f5				push af  
24ec 3a 00 25			ld a, (.dmark)  
24ef 32 bd fb			ld (debug_mark),a  
24f2 3a 01 25			ld a, (.dmark+1)  
24f5 32 be fb			ld (debug_mark+1),a  
24f8 3a 02 25			ld a, (.dmark+2)  
24fb 32 bf fb			ld (debug_mark+2),a  
24fe 18 03			jr .pastdmark  
2500 ..			.dmark: db "2DR"  
2503 f1			.pastdmark: pop af  
2504			endm  
# End of macro DMARK
2504						CALLMONITOR 
2504 cd 1c 17			call break_point_state  
2507				endm  
# End of macro CALLMONITOR
2507					endif 
2507					FORTH_DSP_POP 
2507 cd 5b 1f			call macro_forth_dsp_pop 
250a				endm 
# End of macro FORTH_DSP_POP
250a					FORTH_DSP_POP 
250a cd 5b 1f			call macro_forth_dsp_pop 
250d				endm 
# End of macro FORTH_DSP_POP
250d					NEXTW 
250d c3 15 20			jp macro_next 
2510				endm 
# End of macro NEXTW
2510			.SWAP2: 
2510				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2510 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2511 39 25			dw .AT            
2513 06				db 5 + 1 
2514 .. 00			db "2SWAP",0              
251a				endm 
# End of macro CWHEAD
251a			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
251a					if DEBUG_FORTH_WORDS_KEY 
251a						DMARK "2SW" 
251a f5				push af  
251b 3a 2f 25			ld a, (.dmark)  
251e 32 bd fb			ld (debug_mark),a  
2521 3a 30 25			ld a, (.dmark+1)  
2524 32 be fb			ld (debug_mark+1),a  
2527 3a 31 25			ld a, (.dmark+2)  
252a 32 bf fb			ld (debug_mark+2),a  
252d 18 03			jr .pastdmark  
252f ..			.dmark: db "2SW"  
2532 f1			.pastdmark: pop af  
2533			endm  
# End of macro DMARK
2533						CALLMONITOR 
2533 cd 1c 17			call break_point_state  
2536				endm  
# End of macro CALLMONITOR
2536					endif 
2536					NEXTW 
2536 c3 15 20			jp macro_next 
2539				endm 
# End of macro NEXTW
2539			.AT: 
2539				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2539 1f				db WORD_SYS_CORE+OPCODE_AT             
253a 6b 25			dw .CAT            
253c 02				db 1 + 1 
253d .. 00			db "@",0              
253f				endm 
# End of macro CWHEAD
253f			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
253f			 
253f					if DEBUG_FORTH_WORDS_KEY 
253f						DMARK "AT." 
253f f5				push af  
2540 3a 54 25			ld a, (.dmark)  
2543 32 bd fb			ld (debug_mark),a  
2546 3a 55 25			ld a, (.dmark+1)  
2549 32 be fb			ld (debug_mark+1),a  
254c 3a 56 25			ld a, (.dmark+2)  
254f 32 bf fb			ld (debug_mark+2),a  
2552 18 03			jr .pastdmark  
2554 ..			.dmark: db "AT."  
2557 f1			.pastdmark: pop af  
2558			endm  
# End of macro DMARK
2558						CALLMONITOR 
2558 cd 1c 17			call break_point_state  
255b				endm  
# End of macro CALLMONITOR
255b					endif 
255b			.getbyteat:	 
255b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
255b cd a3 1e			call macro_dsp_valuehl 
255e				endm 
# End of macro FORTH_DSP_VALUEHL
255e					 
255e			;		push hl 
255e				 
255e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
255e cd 5b 1f			call macro_forth_dsp_pop 
2561				endm 
# End of macro FORTH_DSP_POP
2561			 
2561			;		pop hl 
2561			 
2561 7e					ld a, (hl) 
2562			 
2562 6f					ld l, a 
2563 26 00				ld h, 0 
2565 cd ac 1c				call forth_push_numhl 
2568			 
2568					NEXTW 
2568 c3 15 20			jp macro_next 
256b				endm 
# End of macro NEXTW
256b			.CAT: 
256b				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
256b 20				db WORD_SYS_CORE+OPCODE_CAT             
256c 94 25			dw .BANG            
256e 03				db 2 + 1 
256f .. 00			db "C@",0              
2572				endm 
# End of macro CWHEAD
2572			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2572					if DEBUG_FORTH_WORDS_KEY 
2572						DMARK "CAA" 
2572 f5				push af  
2573 3a 87 25			ld a, (.dmark)  
2576 32 bd fb			ld (debug_mark),a  
2579 3a 88 25			ld a, (.dmark+1)  
257c 32 be fb			ld (debug_mark+1),a  
257f 3a 89 25			ld a, (.dmark+2)  
2582 32 bf fb			ld (debug_mark+2),a  
2585 18 03			jr .pastdmark  
2587 ..			.dmark: db "CAA"  
258a f1			.pastdmark: pop af  
258b			endm  
# End of macro DMARK
258b						CALLMONITOR 
258b cd 1c 17			call break_point_state  
258e				endm  
# End of macro CALLMONITOR
258e					endif 
258e c3 5b 25				jp .getbyteat 
2591					NEXTW 
2591 c3 15 20			jp macro_next 
2594				endm 
# End of macro NEXTW
2594			.BANG: 
2594				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2594 21				db WORD_SYS_CORE+OPCODE_BANG             
2595 ca 25			dw .CBANG            
2597 02				db 1 + 1 
2598 .. 00			db "!",0              
259a				endm 
# End of macro CWHEAD
259a			; | ! ( x w -- ) Store x at address w      | DONE 
259a					if DEBUG_FORTH_WORDS_KEY 
259a						DMARK "BNG" 
259a f5				push af  
259b 3a af 25			ld a, (.dmark)  
259e 32 bd fb			ld (debug_mark),a  
25a1 3a b0 25			ld a, (.dmark+1)  
25a4 32 be fb			ld (debug_mark+1),a  
25a7 3a b1 25			ld a, (.dmark+2)  
25aa 32 bf fb			ld (debug_mark+2),a  
25ad 18 03			jr .pastdmark  
25af ..			.dmark: db "BNG"  
25b2 f1			.pastdmark: pop af  
25b3			endm  
# End of macro DMARK
25b3						CALLMONITOR 
25b3 cd 1c 17			call break_point_state  
25b6				endm  
# End of macro CALLMONITOR
25b6					endif 
25b6			 
25b6			.storebyteat:		 
25b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b6 cd a3 1e			call macro_dsp_valuehl 
25b9				endm 
# End of macro FORTH_DSP_VALUEHL
25b9					 
25b9 e5					push hl 
25ba				 
25ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ba cd 5b 1f			call macro_forth_dsp_pop 
25bd				endm 
# End of macro FORTH_DSP_POP
25bd			 
25bd					; get byte to poke 
25bd			 
25bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25bd cd a3 1e			call macro_dsp_valuehl 
25c0				endm 
# End of macro FORTH_DSP_VALUEHL
25c0 e5					push hl 
25c1			 
25c1			 
25c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25c1 cd 5b 1f			call macro_forth_dsp_pop 
25c4				endm 
# End of macro FORTH_DSP_POP
25c4			 
25c4			 
25c4 d1					pop de 
25c5 e1					pop hl 
25c6			 
25c6 73					ld (hl),e 
25c7			 
25c7			 
25c7					NEXTW 
25c7 c3 15 20			jp macro_next 
25ca				endm 
# End of macro NEXTW
25ca			.CBANG: 
25ca				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25ca 22				db WORD_SYS_CORE+OPCODE_CBANG             
25cb f3 25			dw .SCALL            
25cd 03				db 2 + 1 
25ce .. 00			db "C!",0              
25d1				endm 
# End of macro CWHEAD
25d1			; | C!  ( x w -- ) Store x at address w  | DONE 
25d1					if DEBUG_FORTH_WORDS_KEY 
25d1						DMARK "CBA" 
25d1 f5				push af  
25d2 3a e6 25			ld a, (.dmark)  
25d5 32 bd fb			ld (debug_mark),a  
25d8 3a e7 25			ld a, (.dmark+1)  
25db 32 be fb			ld (debug_mark+1),a  
25de 3a e8 25			ld a, (.dmark+2)  
25e1 32 bf fb			ld (debug_mark+2),a  
25e4 18 03			jr .pastdmark  
25e6 ..			.dmark: db "CBA"  
25e9 f1			.pastdmark: pop af  
25ea			endm  
# End of macro DMARK
25ea						CALLMONITOR 
25ea cd 1c 17			call break_point_state  
25ed				endm  
# End of macro CALLMONITOR
25ed					endif 
25ed c3 b6 25				jp .storebyteat 
25f0					NEXTW 
25f0 c3 15 20			jp macro_next 
25f3				endm 
# End of macro NEXTW
25f3			.SCALL: 
25f3				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25f3 23				db WORD_SYS_CORE+OPCODE_SCALL             
25f4 27 26			dw .DEPTH            
25f6 05				db 4 + 1 
25f7 .. 00			db "CALL",0              
25fc				endm 
# End of macro CWHEAD
25fc			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25fc					if DEBUG_FORTH_WORDS_KEY 
25fc						DMARK "CLL" 
25fc f5				push af  
25fd 3a 11 26			ld a, (.dmark)  
2600 32 bd fb			ld (debug_mark),a  
2603 3a 12 26			ld a, (.dmark+1)  
2606 32 be fb			ld (debug_mark+1),a  
2609 3a 13 26			ld a, (.dmark+2)  
260c 32 bf fb			ld (debug_mark+2),a  
260f 18 03			jr .pastdmark  
2611 ..			.dmark: db "CLL"  
2614 f1			.pastdmark: pop af  
2615			endm  
# End of macro DMARK
2615						CALLMONITOR 
2615 cd 1c 17			call break_point_state  
2618				endm  
# End of macro CALLMONITOR
2618					endif 
2618			 
2618					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2618 cd a3 1e			call macro_dsp_valuehl 
261b				endm 
# End of macro FORTH_DSP_VALUEHL
261b			 
261b			;		push hl 
261b			 
261b					; destroy value TOS 
261b			 
261b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261b cd 5b 1f			call macro_forth_dsp_pop 
261e				endm 
# End of macro FORTH_DSP_POP
261e			 
261e						 
261e			;		pop hl 
261e			 
261e					; how to do a call with hl???? save SP? 
261e cd be 1f				call forth_call_hl 
2621			 
2621			 
2621					; TODO push value back onto stack for another op etc 
2621			 
2621 cd ac 1c				call forth_push_numhl 
2624					NEXTW 
2624 c3 15 20			jp macro_next 
2627				endm 
# End of macro NEXTW
2627			.DEPTH: 
2627				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2627 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2628 64 26			dw .OVER            
262a 06				db 5 + 1 
262b .. 00			db "DEPTH",0              
2631				endm 
# End of macro CWHEAD
2631			; | DEPTH ( -- u ) Push count of stack | DONE 
2631					; take current TOS and remove from base value div by two to get count 
2631					if DEBUG_FORTH_WORDS_KEY 
2631						DMARK "DEP" 
2631 f5				push af  
2632 3a 46 26			ld a, (.dmark)  
2635 32 bd fb			ld (debug_mark),a  
2638 3a 47 26			ld a, (.dmark+1)  
263b 32 be fb			ld (debug_mark+1),a  
263e 3a 48 26			ld a, (.dmark+2)  
2641 32 bf fb			ld (debug_mark+2),a  
2644 18 03			jr .pastdmark  
2646 ..			.dmark: db "DEP"  
2649 f1			.pastdmark: pop af  
264a			endm  
# End of macro DMARK
264a						CALLMONITOR 
264a cd 1c 17			call break_point_state  
264d				endm  
# End of macro CALLMONITOR
264d					endif 
264d			 
264d			 
264d 2a 90 f9			ld hl, (cli_data_sp) 
2650 11 0a f5			ld de, cli_data_stack 
2653 ed 52			sbc hl,de 
2655				 
2655				; div by size of stack item 
2655			 
2655 5d				ld e,l 
2656 0e 03			ld c, 3 
2658 cd 99 0c			call Div8 
265b			 
265b 6f				ld l,a 
265c 26 00			ld h,0 
265e			 
265e				;srl h 
265e				;rr l 
265e			 
265e cd ac 1c				call forth_push_numhl 
2661					NEXTW 
2661 c3 15 20			jp macro_next 
2664				endm 
# End of macro NEXTW
2664			.OVER: 
2664				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2664 42				db WORD_SYS_CORE+46             
2665 ab 26			dw .PAUSE            
2667 05				db 4 + 1 
2668 .. 00			db "OVER",0              
266d				endm 
# End of macro CWHEAD
266d			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
266d					if DEBUG_FORTH_WORDS_KEY 
266d						DMARK "OVR" 
266d f5				push af  
266e 3a 82 26			ld a, (.dmark)  
2671 32 bd fb			ld (debug_mark),a  
2674 3a 83 26			ld a, (.dmark+1)  
2677 32 be fb			ld (debug_mark+1),a  
267a 3a 84 26			ld a, (.dmark+2)  
267d 32 bf fb			ld (debug_mark+2),a  
2680 18 03			jr .pastdmark  
2682 ..			.dmark: db "OVR"  
2685 f1			.pastdmark: pop af  
2686			endm  
# End of macro DMARK
2686						CALLMONITOR 
2686 cd 1c 17			call break_point_state  
2689				endm  
# End of macro CALLMONITOR
2689					endif 
2689			 
2689					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2689 cd a3 1e			call macro_dsp_valuehl 
268c				endm 
# End of macro FORTH_DSP_VALUEHL
268c e5					push hl    ; n2 
268d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
268d cd 5b 1f			call macro_forth_dsp_pop 
2690				endm 
# End of macro FORTH_DSP_POP
2690			 
2690					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2690 cd a3 1e			call macro_dsp_valuehl 
2693				endm 
# End of macro FORTH_DSP_VALUEHL
2693 e5					push hl    ; n1 
2694					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2694 cd 5b 1f			call macro_forth_dsp_pop 
2697				endm 
# End of macro FORTH_DSP_POP
2697			 
2697 d1					pop de     ; n1 
2698 e1					pop hl     ; n2 
2699			 
2699 d5					push de 
269a e5					push hl 
269b d5					push de 
269c			 
269c					; push back  
269c			 
269c e1					pop hl 
269d cd ac 1c				call forth_push_numhl 
26a0 e1					pop hl 
26a1 cd ac 1c				call forth_push_numhl 
26a4 e1					pop hl 
26a5 cd ac 1c				call forth_push_numhl 
26a8					NEXTW 
26a8 c3 15 20			jp macro_next 
26ab				endm 
# End of macro NEXTW
26ab			 
26ab			.PAUSE: 
26ab				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26ab 43				db WORD_SYS_CORE+47             
26ac e0 26			dw .PAUSES            
26ae 08				db 7 + 1 
26af .. 00			db "PAUSEMS",0              
26b7				endm 
# End of macro CWHEAD
26b7			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26b7					if DEBUG_FORTH_WORDS_KEY 
26b7						DMARK "PMS" 
26b7 f5				push af  
26b8 3a cc 26			ld a, (.dmark)  
26bb 32 bd fb			ld (debug_mark),a  
26be 3a cd 26			ld a, (.dmark+1)  
26c1 32 be fb			ld (debug_mark+1),a  
26c4 3a ce 26			ld a, (.dmark+2)  
26c7 32 bf fb			ld (debug_mark+2),a  
26ca 18 03			jr .pastdmark  
26cc ..			.dmark: db "PMS"  
26cf f1			.pastdmark: pop af  
26d0			endm  
# End of macro DMARK
26d0						CALLMONITOR 
26d0 cd 1c 17			call break_point_state  
26d3				endm  
# End of macro CALLMONITOR
26d3					endif 
26d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d3 cd a3 1e			call macro_dsp_valuehl 
26d6				endm 
# End of macro FORTH_DSP_VALUEHL
26d6			;		push hl    ; n2 
26d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26d6 cd 5b 1f			call macro_forth_dsp_pop 
26d9				endm 
# End of macro FORTH_DSP_POP
26d9			;		pop hl 
26d9			 
26d9 7d					ld a, l 
26da cd 3a 0a				call aDelayInMS 
26dd				       NEXTW 
26dd c3 15 20			jp macro_next 
26e0				endm 
# End of macro NEXTW
26e0			.PAUSES:  
26e0				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26e0 44				db WORD_SYS_CORE+48             
26e1 4f 27			dw .ROT            
26e3 06				db 5 + 1 
26e4 .. 00			db "PAUSE",0              
26ea				endm 
# End of macro CWHEAD
26ea			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26ea					if DEBUG_FORTH_WORDS_KEY 
26ea						DMARK "PAU" 
26ea f5				push af  
26eb 3a ff 26			ld a, (.dmark)  
26ee 32 bd fb			ld (debug_mark),a  
26f1 3a 00 27			ld a, (.dmark+1)  
26f4 32 be fb			ld (debug_mark+1),a  
26f7 3a 01 27			ld a, (.dmark+2)  
26fa 32 bf fb			ld (debug_mark+2),a  
26fd 18 03			jr .pastdmark  
26ff ..			.dmark: db "PAU"  
2702 f1			.pastdmark: pop af  
2703			endm  
# End of macro DMARK
2703						CALLMONITOR 
2703 cd 1c 17			call break_point_state  
2706				endm  
# End of macro CALLMONITOR
2706					endif 
2706					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2706 cd a3 1e			call macro_dsp_valuehl 
2709				endm 
# End of macro FORTH_DSP_VALUEHL
2709			;		push hl    ; n2 
2709					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2709 cd 5b 1f			call macro_forth_dsp_pop 
270c				endm 
# End of macro FORTH_DSP_POP
270c			;		pop hl 
270c 45					ld b, l 
270d					if DEBUG_FORTH_WORDS 
270d						DMARK "PAU" 
270d f5				push af  
270e 3a 22 27			ld a, (.dmark)  
2711 32 bd fb			ld (debug_mark),a  
2714 3a 23 27			ld a, (.dmark+1)  
2717 32 be fb			ld (debug_mark+1),a  
271a 3a 24 27			ld a, (.dmark+2)  
271d 32 bf fb			ld (debug_mark+2),a  
2720 18 03			jr .pastdmark  
2722 ..			.dmark: db "PAU"  
2725 f1			.pastdmark: pop af  
2726			endm  
# End of macro DMARK
2726						CALLMONITOR 
2726 cd 1c 17			call break_point_state  
2729				endm  
# End of macro CALLMONITOR
2729					endif 
2729 c5			.pauses1:	push bc 
272a cd 55 0a				call delay1s 
272d c1					pop bc 
272e					if DEBUG_FORTH_WORDS 
272e						DMARK "PA1" 
272e f5				push af  
272f 3a 43 27			ld a, (.dmark)  
2732 32 bd fb			ld (debug_mark),a  
2735 3a 44 27			ld a, (.dmark+1)  
2738 32 be fb			ld (debug_mark+1),a  
273b 3a 45 27			ld a, (.dmark+2)  
273e 32 bf fb			ld (debug_mark+2),a  
2741 18 03			jr .pastdmark  
2743 ..			.dmark: db "PA1"  
2746 f1			.pastdmark: pop af  
2747			endm  
# End of macro DMARK
2747						CALLMONITOR 
2747 cd 1c 17			call break_point_state  
274a				endm  
# End of macro CALLMONITOR
274a					endif 
274a 10 dd				djnz .pauses1 
274c			 
274c				       NEXTW 
274c c3 15 20			jp macro_next 
274f				endm 
# End of macro NEXTW
274f			.ROT: 
274f				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
274f 45				db WORD_SYS_CORE+49             
2750 9d 27			dw .UWORDS            
2752 04				db 3 + 1 
2753 .. 00			db "ROT",0              
2757				endm 
# End of macro CWHEAD
2757			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2757					if DEBUG_FORTH_WORDS_KEY 
2757						DMARK "ROT" 
2757 f5				push af  
2758 3a 6c 27			ld a, (.dmark)  
275b 32 bd fb			ld (debug_mark),a  
275e 3a 6d 27			ld a, (.dmark+1)  
2761 32 be fb			ld (debug_mark+1),a  
2764 3a 6e 27			ld a, (.dmark+2)  
2767 32 bf fb			ld (debug_mark+2),a  
276a 18 03			jr .pastdmark  
276c ..			.dmark: db "ROT"  
276f f1			.pastdmark: pop af  
2770			endm  
# End of macro DMARK
2770						CALLMONITOR 
2770 cd 1c 17			call break_point_state  
2773				endm  
# End of macro CALLMONITOR
2773					endif 
2773			 
2773					FORTH_DSP_VALUEHL 
2773 cd a3 1e			call macro_dsp_valuehl 
2776				endm 
# End of macro FORTH_DSP_VALUEHL
2776 e5					push hl    ; u3  
2777			 
2777					FORTH_DSP_POP 
2777 cd 5b 1f			call macro_forth_dsp_pop 
277a				endm 
# End of macro FORTH_DSP_POP
277a			   
277a					FORTH_DSP_VALUEHL 
277a cd a3 1e			call macro_dsp_valuehl 
277d				endm 
# End of macro FORTH_DSP_VALUEHL
277d e5					push hl     ; u2 
277e			 
277e					FORTH_DSP_POP 
277e cd 5b 1f			call macro_forth_dsp_pop 
2781				endm 
# End of macro FORTH_DSP_POP
2781			 
2781					FORTH_DSP_VALUEHL 
2781 cd a3 1e			call macro_dsp_valuehl 
2784				endm 
# End of macro FORTH_DSP_VALUEHL
2784 e5					push hl     ; u1 
2785			 
2785					FORTH_DSP_POP 
2785 cd 5b 1f			call macro_forth_dsp_pop 
2788				endm 
# End of macro FORTH_DSP_POP
2788			 
2788 c1					pop bc      ; u1 
2789 e1					pop hl      ; u2 
278a d1					pop de      ; u3 
278b			 
278b			 
278b c5					push bc 
278c d5					push de 
278d e5					push hl 
278e			 
278e			 
278e e1					pop hl 
278f cd ac 1c				call forth_push_numhl 
2792			 
2792 e1					pop hl 
2793 cd ac 1c				call forth_push_numhl 
2796			 
2796 e1					pop hl 
2797 cd ac 1c				call forth_push_numhl 
279a					 
279a			 
279a			 
279a			 
279a			 
279a			 
279a				       NEXTW 
279a c3 15 20			jp macro_next 
279d				endm 
# End of macro NEXTW
279d			 
279d			.UWORDS: 
279d				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
279d 50				db WORD_SYS_CORE+60             
279e 5f 28			dw .BP            
27a0 07				db 6 + 1 
27a1 .. 00			db "UWORDS",0              
27a8				endm 
# End of macro CWHEAD
27a8			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27a8			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27a8			; | | Following the count are the individual words. 
27a8			; | | 
27a8			; | | e.g. UWORDS 
27a8			; | | BOX DIRLIST 2 
27a8			; | |  
27a8			; | | Can be used to save the words to storage via: 
27a8			; | | UWORDS $01 DO $01 APPEND LOOP 
27a8				if DEBUG_FORTH_WORDS_KEY 
27a8					DMARK "UWR" 
27a8 f5				push af  
27a9 3a bd 27			ld a, (.dmark)  
27ac 32 bd fb			ld (debug_mark),a  
27af 3a be 27			ld a, (.dmark+1)  
27b2 32 be fb			ld (debug_mark+1),a  
27b5 3a bf 27			ld a, (.dmark+2)  
27b8 32 bf fb			ld (debug_mark+2),a  
27bb 18 03			jr .pastdmark  
27bd ..			.dmark: db "UWR"  
27c0 f1			.pastdmark: pop af  
27c1			endm  
# End of macro DMARK
27c1					CALLMONITOR 
27c1 cd 1c 17			call break_point_state  
27c4				endm  
# End of macro CALLMONITOR
27c4				endif 
27c4 21 00 80				ld hl, baseram 
27c7					;ld hl, baseusermem 
27c7 01 00 00				ld bc, 0    ; start a counter 
27ca			 
27ca				; skip dict stub 
27ca			 
27ca cd 66 21				call forth_tok_next 
27cd			 
27cd			 
27cd			; while we have words to look for 
27cd			 
27cd 7e			.douscan:	ld a, (hl)      
27ce				if DEBUG_FORTH_WORDS 
27ce					DMARK "UWs" 
27ce f5				push af  
27cf 3a e3 27			ld a, (.dmark)  
27d2 32 bd fb			ld (debug_mark),a  
27d5 3a e4 27			ld a, (.dmark+1)  
27d8 32 be fb			ld (debug_mark+1),a  
27db 3a e5 27			ld a, (.dmark+2)  
27de 32 bf fb			ld (debug_mark+2),a  
27e1 18 03			jr .pastdmark  
27e3 ..			.dmark: db "UWs"  
27e6 f1			.pastdmark: pop af  
27e7			endm  
# End of macro DMARK
27e7					CALLMONITOR 
27e7 cd 1c 17			call break_point_state  
27ea				endm  
# End of macro CALLMONITOR
27ea				endif 
27ea fe 00				cp WORD_SYS_END 
27ec 28 4d				jr z, .udone 
27ee fe 01				cp WORD_SYS_UWORD 
27f0 20 44				jr nz, .nuword 
27f2			 
27f2				if DEBUG_FORTH_WORDS 
27f2					DMARK "UWu" 
27f2 f5				push af  
27f3 3a 07 28			ld a, (.dmark)  
27f6 32 bd fb			ld (debug_mark),a  
27f9 3a 08 28			ld a, (.dmark+1)  
27fc 32 be fb			ld (debug_mark+1),a  
27ff 3a 09 28			ld a, (.dmark+2)  
2802 32 bf fb			ld (debug_mark+2),a  
2805 18 03			jr .pastdmark  
2807 ..			.dmark: db "UWu"  
280a f1			.pastdmark: pop af  
280b			endm  
# End of macro DMARK
280b					CALLMONITOR 
280b cd 1c 17			call break_point_state  
280e				endm  
# End of macro CALLMONITOR
280e				endif 
280e					; we have a uword so push its name to the stack 
280e			 
280e e5				   	push hl  ; save so we can move to next dict block 
280f			 
280f					; skip opcode 
280f 23					inc hl  
2810					; skip next ptr 
2810 23					inc hl  
2811 23					inc hl 
2812					; skip len 
2812 23					inc hl 
2813				if DEBUG_FORTH_WORDS 
2813					DMARK "UWt" 
2813 f5				push af  
2814 3a 28 28			ld a, (.dmark)  
2817 32 bd fb			ld (debug_mark),a  
281a 3a 29 28			ld a, (.dmark+1)  
281d 32 be fb			ld (debug_mark+1),a  
2820 3a 2a 28			ld a, (.dmark+2)  
2823 32 bf fb			ld (debug_mark+2),a  
2826 18 03			jr .pastdmark  
2828 ..			.dmark: db "UWt"  
282b f1			.pastdmark: pop af  
282c			endm  
# End of macro DMARK
282c					CALLMONITOR 
282c cd 1c 17			call break_point_state  
282f				endm  
# End of macro CALLMONITOR
282f				endif 
282f 03					inc bc 
2830			 
2830 c5					push bc 
2831 cd 1a 1d				call forth_push_str 
2834 c1					pop bc 
2835			 
2835 e1					pop hl 	 
2836			 
2836 cd 66 21		.nuword:	call forth_tok_next 
2839 18 92				jr .douscan  
283b			 
283b			.udone:		 ; push count of uwords found 
283b c5					push bc 
283c e1					pop hl 
283d			 
283d				if DEBUG_FORTH_WORDS 
283d					DMARK "UWc" 
283d f5				push af  
283e 3a 52 28			ld a, (.dmark)  
2841 32 bd fb			ld (debug_mark),a  
2844 3a 53 28			ld a, (.dmark+1)  
2847 32 be fb			ld (debug_mark+1),a  
284a 3a 54 28			ld a, (.dmark+2)  
284d 32 bf fb			ld (debug_mark+2),a  
2850 18 03			jr .pastdmark  
2852 ..			.dmark: db "UWc"  
2855 f1			.pastdmark: pop af  
2856			endm  
# End of macro DMARK
2856					CALLMONITOR 
2856 cd 1c 17			call break_point_state  
2859				endm  
# End of macro CALLMONITOR
2859				endif 
2859 cd ac 1c				call forth_push_numhl 
285c			 
285c			 
285c				       NEXTW 
285c c3 15 20			jp macro_next 
285f				endm 
# End of macro NEXTW
285f			 
285f			.BP: 
285f				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
285f 54				db WORD_SYS_CORE+64             
2860 95 28			dw .MONITOR            
2862 03				db 2 + 1 
2863 .. 00			db "BP",0              
2866				endm 
# End of macro CWHEAD
2866			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2866			; | | $00 Will enable the break points within specific code paths 
2866			; | | $01 Will disable break points 
2866			; | |  
2866			; | | By default break points are off. Either the above can be used to enable them 
2866			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2866			; | | and on release of the pressed key a message will be disaplayed to notify 
2866			; | | that break points are enabled. Pressing any key will then continue boot process. 
2866					; get byte count 
2866					if DEBUG_FORTH_WORDS_KEY 
2866						DMARK "BP." 
2866 f5				push af  
2867 3a 7b 28			ld a, (.dmark)  
286a 32 bd fb			ld (debug_mark),a  
286d 3a 7c 28			ld a, (.dmark+1)  
2870 32 be fb			ld (debug_mark+1),a  
2873 3a 7d 28			ld a, (.dmark+2)  
2876 32 bf fb			ld (debug_mark+2),a  
2879 18 03			jr .pastdmark  
287b ..			.dmark: db "BP."  
287e f1			.pastdmark: pop af  
287f			endm  
# End of macro DMARK
287f						CALLMONITOR 
287f cd 1c 17			call break_point_state  
2882				endm  
# End of macro CALLMONITOR
2882					endif 
2882			 
2882					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2882 cd a3 1e			call macro_dsp_valuehl 
2885				endm 
# End of macro FORTH_DSP_VALUEHL
2885			 
2885			;		push hl 
2885			 
2885					; destroy value TOS 
2885			 
2885					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2885 cd 5b 1f			call macro_forth_dsp_pop 
2888				endm 
# End of macro FORTH_DSP_POP
2888			 
2888			;		pop hl 
2888			 
2888 3e 00				ld a,0 
288a bd					cp l 
288b 28 02				jr z, .bpset 
288d 3e 2a				ld a, '*' 
288f			 
288f 32 94 ef		.bpset:		ld (os_view_disable), a 
2892			 
2892			 
2892					NEXTW 
2892 c3 15 20			jp macro_next 
2895				endm 
# End of macro NEXTW
2895			 
2895			 
2895			.MONITOR: 
2895				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2895 55				db WORD_SYS_CORE+65             
2896 c8 28			dw .MALLOC            
2898 08				db 7 + 1 
2899 .. 00			db "MONITOR",0              
28a1				endm 
# End of macro CWHEAD
28a1			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28a1			; | | At start the current various registers will be displayed with contents. 
28a1			; | | Top right corner will show the most recent debug marker seen. 
28a1			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28a1			; | | and the return stack pointer (RSP). 
28a1			; | | Pressing: 
28a1			; | |    1 - Initial screen 
28a1			; | |    2 - Display a data dump of HL 
28a1			; | |    3 - Display a data dump of DE 
28a1			; | |    4 - Display a data dump of BC 
28a1			; | |    5 - Display a data dump of HL 
28a1			; | |    6 - Display a data dump of DSP 
28a1			; | |    7 - Display a data dump of RSP 
28a1			; | |    8 - Display a data dump of what is at DSP 
28a1			; | |    9 - Display a data dump of what is at RSP 
28a1			; | |    0 - Exit monitor and continue running. This will also enable break points 
28a1			; | |    * - Disable break points 
28a1			; | |    # - Enter traditional monitor mode 
28a1			; | | 
28a1			; | | Monitor Mode 
28a1			; | | ------------ 
28a1			; | | A prompt of '>' will be shown for various commands: 
28a1			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28a1			; | |    C - Continue display a data dump from the last set address 
28a1			; | |    M xxxx - Set start of memory edit at address xx 
28a1			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28a1			; | |    Q - Return to previous 
28a1					if DEBUG_FORTH_WORDS_KEY 
28a1						DMARK "MON" 
28a1 f5				push af  
28a2 3a b6 28			ld a, (.dmark)  
28a5 32 bd fb			ld (debug_mark),a  
28a8 3a b7 28			ld a, (.dmark+1)  
28ab 32 be fb			ld (debug_mark+1),a  
28ae 3a b8 28			ld a, (.dmark+2)  
28b1 32 bf fb			ld (debug_mark+2),a  
28b4 18 03			jr .pastdmark  
28b6 ..			.dmark: db "MON"  
28b9 f1			.pastdmark: pop af  
28ba			endm  
# End of macro DMARK
28ba						CALLMONITOR 
28ba cd 1c 17			call break_point_state  
28bd				endm  
# End of macro CALLMONITOR
28bd					endif 
28bd 3e 00				ld a, 0 
28bf 32 94 ef				ld (os_view_disable), a 
28c2			 
28c2					CALLMONITOR 
28c2 cd 1c 17			call break_point_state  
28c5				endm  
# End of macro CALLMONITOR
28c5			 
28c5			;	call monitor 
28c5			 
28c5					NEXTW 
28c5 c3 15 20			jp macro_next 
28c8				endm 
# End of macro NEXTW
28c8			 
28c8			 
28c8			.MALLOC: 
28c8				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28c8 56				db WORD_SYS_CORE+66             
28c9 f1 28			dw .MALLOC2            
28cb 06				db 5 + 1 
28cc .. 00			db "ALLOT",0              
28d2				endm 
# End of macro CWHEAD
28d2			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28d2					if DEBUG_FORTH_WORDS_KEY 
28d2						DMARK "ALL" 
28d2 f5				push af  
28d3 3a e7 28			ld a, (.dmark)  
28d6 32 bd fb			ld (debug_mark),a  
28d9 3a e8 28			ld a, (.dmark+1)  
28dc 32 be fb			ld (debug_mark+1),a  
28df 3a e9 28			ld a, (.dmark+2)  
28e2 32 bf fb			ld (debug_mark+2),a  
28e5 18 03			jr .pastdmark  
28e7 ..			.dmark: db "ALL"  
28ea f1			.pastdmark: pop af  
28eb			endm  
# End of macro DMARK
28eb						CALLMONITOR 
28eb cd 1c 17			call break_point_state  
28ee				endm  
# End of macro CALLMONITOR
28ee					endif 
28ee c3 18 29				jp .mallocc 
28f1			.MALLOC2: 
28f1				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28f1 56				db WORD_SYS_CORE+66             
28f2 2f 29			dw .FREE            
28f4 07				db 6 + 1 
28f5 .. 00			db "MALLOC",0              
28fc				endm 
# End of macro CWHEAD
28fc			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28fc					; get byte count 
28fc					if DEBUG_FORTH_WORDS_KEY 
28fc						DMARK "MAL" 
28fc f5				push af  
28fd 3a 11 29			ld a, (.dmark)  
2900 32 bd fb			ld (debug_mark),a  
2903 3a 12 29			ld a, (.dmark+1)  
2906 32 be fb			ld (debug_mark+1),a  
2909 3a 13 29			ld a, (.dmark+2)  
290c 32 bf fb			ld (debug_mark+2),a  
290f 18 03			jr .pastdmark  
2911 ..			.dmark: db "MAL"  
2914 f1			.pastdmark: pop af  
2915			endm  
# End of macro DMARK
2915						CALLMONITOR 
2915 cd 1c 17			call break_point_state  
2918				endm  
# End of macro CALLMONITOR
2918					endif 
2918			.mallocc: 
2918					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2918 cd a3 1e			call macro_dsp_valuehl 
291b				endm 
# End of macro FORTH_DSP_VALUEHL
291b			 
291b			;		push hl 
291b			 
291b					; destroy value TOS 
291b			 
291b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291b cd 5b 1f			call macro_forth_dsp_pop 
291e				endm 
# End of macro FORTH_DSP_POP
291e			 
291e			;		pop hl 
291e cd d0 11				call malloc 
2921				if DEBUG_FORTH_MALLOC_GUARD 
2921 f5					push af 
2922 cd 32 0d				call ishlzero 
2925			;		ld a, l 
2925			;		add h 
2925			;		cp 0 
2925 f1					pop af 
2926					 
2926 cc 3a 51				call z,malloc_error 
2929				endif 
2929			 
2929 cd ac 1c				call forth_push_numhl 
292c					NEXTW 
292c c3 15 20			jp macro_next 
292f				endm 
# End of macro NEXTW
292f			 
292f			.FREE: 
292f				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
292f 57				db WORD_SYS_CORE+67             
2930 60 29			dw .LIST            
2932 05				db 4 + 1 
2933 .. 00			db "FREE",0              
2938				endm 
# End of macro CWHEAD
2938			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2938					if DEBUG_FORTH_WORDS_KEY 
2938						DMARK "FRE" 
2938 f5				push af  
2939 3a 4d 29			ld a, (.dmark)  
293c 32 bd fb			ld (debug_mark),a  
293f 3a 4e 29			ld a, (.dmark+1)  
2942 32 be fb			ld (debug_mark+1),a  
2945 3a 4f 29			ld a, (.dmark+2)  
2948 32 bf fb			ld (debug_mark+2),a  
294b 18 03			jr .pastdmark  
294d ..			.dmark: db "FRE"  
2950 f1			.pastdmark: pop af  
2951			endm  
# End of macro DMARK
2951						CALLMONITOR 
2951 cd 1c 17			call break_point_state  
2954				endm  
# End of macro CALLMONITOR
2954					endif 
2954					; get address 
2954			 
2954					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2954 cd a3 1e			call macro_dsp_valuehl 
2957				endm 
# End of macro FORTH_DSP_VALUEHL
2957			 
2957			;		push hl 
2957			 
2957					; destroy value TOS 
2957			 
2957					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2957 cd 5b 1f			call macro_forth_dsp_pop 
295a				endm 
# End of macro FORTH_DSP_POP
295a			 
295a			;		pop hl 
295a			if FORTH_ENABLE_MALLOCFREE 
295a cd 9a 12				call free 
295d			endif 
295d					NEXTW 
295d c3 15 20			jp macro_next 
2960				endm 
# End of macro NEXTW
2960			.LIST: 
2960				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2960 5c				db WORD_SYS_CORE+72             
2961 23 2b			dw .FORGET            
2963 05				db 4 + 1 
2964 .. 00			db "LIST",0              
2969				endm 
# End of macro CWHEAD
2969			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2969			; | | The quoted word must be in upper case. 
2969				if DEBUG_FORTH_WORDS_KEY 
2969					DMARK "LST" 
2969 f5				push af  
296a 3a 7e 29			ld a, (.dmark)  
296d 32 bd fb			ld (debug_mark),a  
2970 3a 7f 29			ld a, (.dmark+1)  
2973 32 be fb			ld (debug_mark+1),a  
2976 3a 80 29			ld a, (.dmark+2)  
2979 32 bf fb			ld (debug_mark+2),a  
297c 18 03			jr .pastdmark  
297e ..			.dmark: db "LST"  
2981 f1			.pastdmark: pop af  
2982			endm  
# End of macro DMARK
2982					CALLMONITOR 
2982 cd 1c 17			call break_point_state  
2985				endm  
# End of macro CALLMONITOR
2985				endif 
2985			 
2985					FORTH_DSP_VALUEHL 
2985 cd a3 1e			call macro_dsp_valuehl 
2988				endm 
# End of macro FORTH_DSP_VALUEHL
2988			 
2988 e5					push hl 
2989 c1					pop bc 
298a			 
298a			; Start format of scratch string 
298a			 
298a 21 a3 ef				ld hl, scratch 
298d			 
298d 3e 3a				ld a, ':' 
298f 77					ld (hl),a 
2990 23					inc hl 
2991 3e 20				ld a, ' ' 
2993 77					ld (hl), a 
2994			 
2994					; Get ptr to the word we need to look up 
2994			 
2994			;		FORTH_DSP_VALUEHL 
2994					;v5 FORTH_DSP_VALUE 
2994				; TODO type check 
2994			;		inc hl    ; Skip type check  
2994			;		push hl 
2994			;		ex de, hl    ; put into DE 
2994			 
2994			 
2994 21 00 80				ld hl, baseram 
2997					;ld hl, baseusermem 
2997			 
2997 e5			push hl   ; sacreifical push 
2998			 
2998			.ldouscanm: 
2998 e1				pop hl 
2999			.ldouscan: 
2999				if DEBUG_FORTH_WORDS 
2999					DMARK "LSs" 
2999 f5				push af  
299a 3a ae 29			ld a, (.dmark)  
299d 32 bd fb			ld (debug_mark),a  
29a0 3a af 29			ld a, (.dmark+1)  
29a3 32 be fb			ld (debug_mark+1),a  
29a6 3a b0 29			ld a, (.dmark+2)  
29a9 32 bf fb			ld (debug_mark+2),a  
29ac 18 03			jr .pastdmark  
29ae ..			.dmark: db "LSs"  
29b1 f1			.pastdmark: pop af  
29b2			endm  
# End of macro DMARK
29b2					CALLMONITOR 
29b2 cd 1c 17			call break_point_state  
29b5				endm  
# End of macro CALLMONITOR
29b5				endif 
29b5				; skip dict stub 
29b5 cd 66 21				call forth_tok_next 
29b8			 
29b8			 
29b8			; while we have words to look for 
29b8			 
29b8 7e				ld a, (hl)      
29b9				if DEBUG_FORTH_WORDS 
29b9					DMARK "LSk" 
29b9 f5				push af  
29ba 3a ce 29			ld a, (.dmark)  
29bd 32 bd fb			ld (debug_mark),a  
29c0 3a cf 29			ld a, (.dmark+1)  
29c3 32 be fb			ld (debug_mark+1),a  
29c6 3a d0 29			ld a, (.dmark+2)  
29c9 32 bf fb			ld (debug_mark+2),a  
29cc 18 03			jr .pastdmark  
29ce ..			.dmark: db "LSk"  
29d1 f1			.pastdmark: pop af  
29d2			endm  
# End of macro DMARK
29d2					CALLMONITOR 
29d2 cd 1c 17			call break_point_state  
29d5				endm  
# End of macro CALLMONITOR
29d5				endif 
29d5 fe 00				cp WORD_SYS_END 
29d7 ca 0a 2b				jp z, .lunotfound 
29da fe 01				cp WORD_SYS_UWORD 
29dc c2 99 29				jp nz, .ldouscan 
29df			 
29df				if DEBUG_FORTH_WORDS 
29df					DMARK "LSu" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 bd fb			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 be fb			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 bf fb			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "LSu"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8					CALLMONITOR 
29f8 cd 1c 17			call break_point_state  
29fb				endm  
# End of macro CALLMONITOR
29fb				endif 
29fb			 
29fb					; found a uword but is it the one we want... 
29fb			 
29fb c5					push bc     ; uword to find is on bc 
29fc d1					pop de 
29fd			 
29fd e5					push hl  ; to save the ptr 
29fe			 
29fe					; skip opcode 
29fe 23					inc hl  
29ff					; skip next ptr 
29ff 23					inc hl  
2a00 23					inc hl 
2a01					; skip len 
2a01 23					inc hl 
2a02			 
2a02				if DEBUG_FORTH_WORDS 
2a02					DMARK "LSc" 
2a02 f5				push af  
2a03 3a 17 2a			ld a, (.dmark)  
2a06 32 bd fb			ld (debug_mark),a  
2a09 3a 18 2a			ld a, (.dmark+1)  
2a0c 32 be fb			ld (debug_mark+1),a  
2a0f 3a 19 2a			ld a, (.dmark+2)  
2a12 32 bf fb			ld (debug_mark+2),a  
2a15 18 03			jr .pastdmark  
2a17 ..			.dmark: db "LSc"  
2a1a f1			.pastdmark: pop af  
2a1b			endm  
# End of macro DMARK
2a1b					CALLMONITOR 
2a1b cd 1c 17			call break_point_state  
2a1e				endm  
# End of macro CALLMONITOR
2a1e				endif 
2a1e cd 9f 11				call strcmp 
2a21 c2 98 29				jp nz, .ldouscanm 
2a24				 
2a24			 
2a24			 
2a24					; we have a uword so push its name to the stack 
2a24			 
2a24			;	   	push hl  ; save so we can move to next dict block 
2a24 e1			pop hl 
2a25			 
2a25				if DEBUG_FORTH_WORDS 
2a25					DMARK "LSm" 
2a25 f5				push af  
2a26 3a 3a 2a			ld a, (.dmark)  
2a29 32 bd fb			ld (debug_mark),a  
2a2c 3a 3b 2a			ld a, (.dmark+1)  
2a2f 32 be fb			ld (debug_mark+1),a  
2a32 3a 3c 2a			ld a, (.dmark+2)  
2a35 32 bf fb			ld (debug_mark+2),a  
2a38 18 03			jr .pastdmark  
2a3a ..			.dmark: db "LSm"  
2a3d f1			.pastdmark: pop af  
2a3e			endm  
# End of macro DMARK
2a3e					CALLMONITOR 
2a3e cd 1c 17			call break_point_state  
2a41				endm  
# End of macro CALLMONITOR
2a41				endif 
2a41			 
2a41					; skip opcode 
2a41 23					inc hl  
2a42					; skip next ptr 
2a42 23					inc hl  
2a43 23					inc hl 
2a44					; skip len 
2a44 7e					ld a, (hl)   ; save length to add 
2a45				if DEBUG_FORTH_WORDS 
2a45					DMARK "LS2" 
2a45 f5				push af  
2a46 3a 5a 2a			ld a, (.dmark)  
2a49 32 bd fb			ld (debug_mark),a  
2a4c 3a 5b 2a			ld a, (.dmark+1)  
2a4f 32 be fb			ld (debug_mark+1),a  
2a52 3a 5c 2a			ld a, (.dmark+2)  
2a55 32 bf fb			ld (debug_mark+2),a  
2a58 18 03			jr .pastdmark  
2a5a ..			.dmark: db "LS2"  
2a5d f1			.pastdmark: pop af  
2a5e			endm  
# End of macro DMARK
2a5e					CALLMONITOR 
2a5e cd 1c 17			call break_point_state  
2a61				endm  
# End of macro CALLMONITOR
2a61				endif 
2a61			 
2a61					; save this location 
2a61				 
2a61 e5					push hl 
2a62			 
2a62 23					inc hl 
2a63 11 a5 ef				ld de, scratch+2 
2a66 4f					ld c, a 
2a67 06 00				ld b, 0 
2a69			 
2a69				if DEBUG_FORTH_WORDS 
2a69					DMARK "LSn" 
2a69 f5				push af  
2a6a 3a 7e 2a			ld a, (.dmark)  
2a6d 32 bd fb			ld (debug_mark),a  
2a70 3a 7f 2a			ld a, (.dmark+1)  
2a73 32 be fb			ld (debug_mark+1),a  
2a76 3a 80 2a			ld a, (.dmark+2)  
2a79 32 bf fb			ld (debug_mark+2),a  
2a7c 18 03			jr .pastdmark  
2a7e ..			.dmark: db "LSn"  
2a81 f1			.pastdmark: pop af  
2a82			endm  
# End of macro DMARK
2a82					CALLMONITOR 
2a82 cd 1c 17			call break_point_state  
2a85				endm  
# End of macro CALLMONITOR
2a85				endif 
2a85			 
2a85					; copy uword name to scratch 
2a85			 
2a85 ed b0				ldir 
2a87			 
2a87 1b					dec de 
2a88 3e 20				ld a, ' '    ; change null to space 
2a8a 12					ld (de), a 
2a8b			 
2a8b 13					inc de 
2a8c			 
2a8c d5					push de 
2a8d c1					pop bc     ; move scratch pointer to end of word name and save it 
2a8e			 
2a8e e1					pop hl 
2a8f 7e					ld a, (hl) 
2a90					;inc hl 
2a90					; skip word string 
2a90 cd 09 0d				call addatohl 
2a93			 
2a93 23					inc hl 
2a94			 
2a94				if DEBUG_FORTH_WORDS 
2a94					DMARK "LS3" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 bd fb			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 be fb			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 bf fb			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "LS3"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad					CALLMONITOR 
2aad cd 1c 17			call break_point_state  
2ab0				endm  
# End of macro CALLMONITOR
2ab0				endif 
2ab0					; should now be at the start of the machine code to setup the eval of the uword 
2ab0					; now locate the ptr to the string defintion 
2ab0			 
2ab0					; skip ld hl, 
2ab0					; then load the ptr 
2ab0			 
2ab0 23					inc hl 
2ab1 5e					ld e, (hl) 
2ab2 23					inc hl 
2ab3 56					ld d, (hl) 
2ab4 eb					ex de, hl 
2ab5			 
2ab5			 
2ab5				if DEBUG_FORTH_WORDS 
2ab5					DMARK "LSt" 
2ab5 f5				push af  
2ab6 3a ca 2a			ld a, (.dmark)  
2ab9 32 bd fb			ld (debug_mark),a  
2abc 3a cb 2a			ld a, (.dmark+1)  
2abf 32 be fb			ld (debug_mark+1),a  
2ac2 3a cc 2a			ld a, (.dmark+2)  
2ac5 32 bf fb			ld (debug_mark+2),a  
2ac8 18 03			jr .pastdmark  
2aca ..			.dmark: db "LSt"  
2acd f1			.pastdmark: pop af  
2ace			endm  
# End of macro DMARK
2ace					CALLMONITOR 
2ace cd 1c 17			call break_point_state  
2ad1				endm  
# End of macro CALLMONITOR
2ad1				endif 
2ad1			 
2ad1			; cant push right now due to tokenised strings  
2ad1			 
2ad1			; get the destination of where to copy this definition to. 
2ad1			 
2ad1 c5					push bc 
2ad2 d1					pop de 
2ad3			 
2ad3 7e			.listl:         ld a,(hl) 
2ad4 fe 00				cp 0 
2ad6 28 09				jr z, .lreplsp     ; replace zero with space 
2ad8 fe 7f				cp FORTH_END_BUFFER 
2ada 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2adc				 
2adc					; just copy this char as is then 
2adc			 
2adc 12					ld (de), a 
2add			 
2add 23			.listnxt:	inc hl 
2ade 13					inc de 
2adf 18 f2				jr .listl 
2ae1			 
2ae1 3e 20		.lreplsp:	ld a,' ' 
2ae3 12					ld (de), a 
2ae4 18 f7				jr .listnxt 
2ae6			 
2ae6			; close up uword def 
2ae6			 
2ae6			.listdone: 
2ae6 3e 00				ld a, 0 
2ae8 12					ld (de), a 
2ae9			 
2ae9			; now have def so clean up and push to stack 
2ae9			 
2ae9 21 a3 ef				ld hl, scratch 
2aec				if DEBUG_FORTH_WORDS 
2aec					DMARK "Ltp" 
2aec f5				push af  
2aed 3a 01 2b			ld a, (.dmark)  
2af0 32 bd fb			ld (debug_mark),a  
2af3 3a 02 2b			ld a, (.dmark+1)  
2af6 32 be fb			ld (debug_mark+1),a  
2af9 3a 03 2b			ld a, (.dmark+2)  
2afc 32 bf fb			ld (debug_mark+2),a  
2aff 18 03			jr .pastdmark  
2b01 ..			.dmark: db "Ltp"  
2b04 f1			.pastdmark: pop af  
2b05			endm  
# End of macro DMARK
2b05					CALLMONITOR 
2b05 cd 1c 17			call break_point_state  
2b08				endm  
# End of macro CALLMONITOR
2b08				endif 
2b08			 
2b08 18 06			jr .listpush 
2b0a			 
2b0a			;.lnuword:	pop hl 
2b0a			;		call forth_tok_next 
2b0a			;		jp .ldouscan  
2b0a			 
2b0a			.lunotfound:		  
2b0a			 
2b0a			 
2b0a					 
2b0a					FORTH_DSP_POP 
2b0a cd 5b 1f			call macro_forth_dsp_pop 
2b0d				endm 
# End of macro FORTH_DSP_POP
2b0d 21 16 2b				ld hl, .luno 
2b10						 
2b10			 
2b10			.listpush: 
2b10 cd 1a 1d				call forth_push_str 
2b13			 
2b13			 
2b13			 
2b13					NEXTW 
2b13 c3 15 20			jp macro_next 
2b16				endm 
# End of macro NEXTW
2b16			 
2b16 .. 00		.luno:    db "Not found",0 
2b20			 
2b20			 
2b20			 
2b20			 
2b20			 
2b20			;		push hl   ; save pointer to start of uword def string 
2b20			; 
2b20			;; look for FORTH_EOL_LINE 
2b20			;		ld a, FORTH_END_BUFFER 
2b20			;		call strlent 
2b20			; 
2b20			;		inc hl		 ; space for coln def 
2b20			;		inc hl 
2b20			;		inc hl          ; space for terms 
2b20			;		inc hl 
2b20			; 
2b20			;		ld a, 20   ; TODO get actual length 
2b20			;		call addatohl    ; include a random amount of room for the uword name 
2b20			; 
2b20			;		 
2b20			;	if DEBUG_FORTH_WORDS 
2b20			;		DMARK "Lt1" 
2b20			;		CALLMONITOR 
2b20			;	endif 
2b20			;		 
2b20			; 
2b20			;; malloc space for the string because we cant change it 
2b20			; 
2b20			;		call malloc 
2b20			;	if DEBUG_FORTH_MALLOC_GUARD 
2b20			;		push af 
2b20			;		call ishlzero 
2b20			;		pop af 
2b20			;		 
2b20			;		call z,malloc_error 
2b20			;	endif 
2b20			; 
2b20			;	if DEBUG_FORTH_WORDS 
2b20			;		DMARK "Lt2" 
2b20			;		CALLMONITOR 
2b20			;	endif 
2b20			;		pop de 
2b20			;		push hl    ; push the malloc to release later 
2b20			;		push hl   ;  push back a copy for the later stack push 
2b20			;		 
2b20			;; copy the string swapping out the zero terms for spaces 
2b20			; 
2b20			;		; de has our source 
2b20			;		; hl has our dest 
2b20			; 
2b20			;; add the coln def 
2b20			; 
2b20			;		ld a, ':' 
2b20			;		ld (hl), a 
2b20			;		inc hl 
2b20			;		ld a, ' ' 
2b20			;		ld (hl), a 
2b20			;		inc hl 
2b20			; 
2b20			;; add the uname word 
2b20			;		push de   ; save our string for now 
2b20			;		ex de, hl 
2b20			; 
2b20			;		FORTH_DSP_VALUE 
2b20			;		;v5 FORTH_DSP_VALUE 
2b20			; 
2b20			;		inc hl   ; skip type but we know by now this is OK 
2b20			; 
2b20			;.luword:	ld a,(hl) 
2b20			;		cp 0 
2b20			;		jr z, .luword2 
2b20			;		ld (de), a 
2b20			;		inc de 
2b20			;		inc hl 
2b20			;		jr .luword 
2b20			; 
2b20			;.luword2:	ld a, ' ' 
2b20			;		ld (de), a 
2b20			;;		inc hl 
2b20			;;		inc de 
2b20			;;		ld (de), a 
2b20			;;		inc hl 
2b20			;		inc de 
2b20			; 
2b20			;		ex de, hl 
2b20			;		pop de 
2b20			;		 
2b20			;		 
2b20			; 
2b20			;; detoken that string and copy it 
2b20			; 
2b20			;	if DEBUG_FORTH_WORDS 
2b20			;		DMARK "Lt2" 
2b20			;		CALLMONITOR 
2b20			;	endif 
2b20			;.ldetok:	ld a, (de) 
2b20			;		cp FORTH_END_BUFFER 
2b20			;		jr z, .ldetokend 
2b20			;		; swap out any zero term for space 
2b20			;		cp 0 
2b20			;		jr nz, .ldetoknext 
2b20			;		ld a, ' ' 
2b20			; 
2b20			;	if DEBUG_FORTH_WORDS 
2b20			;		DMARK "LtS" 
2b20			;		CALLMONITOR 
2b20			;	endif 
2b20			;.ldetoknext:	ld (hl), a 
2b20			;		inc de 
2b20			;		inc hl 
2b20			;		jr .ldetok 
2b20			; 
2b20			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b20			;		ld (hl), a  
2b20			; 
2b20			;; free that temp malloc 
2b20			; 
2b20			;		pop hl    
2b20			; 
2b20			;	if DEBUG_FORTH_WORDS 
2b20			;		DMARK "Lt4" 
2b20			;		CALLMONITOR 
2b20			;	endif 
2b20			;		call forth_apushstrhl 
2b20			; 
2b20			;		; get rid of temp malloc area 
2b20			; 
2b20			;		pop hl 
2b20			;		call free 
2b20			; 
2b20			;		jr .ludone 
2b20			; 
2b20			;.lnuword:	pop hl 
2b20			;		call forth_tok_next 
2b20			;		jp .ldouscan  
2b20			; 
2b20			;.ludone:		 pop hl 
2b20			; 
2b20					NEXTW 
2b20 c3 15 20			jp macro_next 
2b23				endm 
# End of macro NEXTW
2b23			 
2b23			.FORGET: 
2b23				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b23 5d				db WORD_SYS_CORE+73             
2b24 9c 2b			dw .NOP            
2b26 07				db 6 + 1 
2b27 .. 00			db "FORGET",0              
2b2e				endm 
# End of macro CWHEAD
2b2e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b2e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b2e			; | |  
2b2e			; | | e.g. "MORE" forget 
2b2e					if DEBUG_FORTH_WORDS_KEY 
2b2e						DMARK "FRG" 
2b2e f5				push af  
2b2f 3a 43 2b			ld a, (.dmark)  
2b32 32 bd fb			ld (debug_mark),a  
2b35 3a 44 2b			ld a, (.dmark+1)  
2b38 32 be fb			ld (debug_mark+1),a  
2b3b 3a 45 2b			ld a, (.dmark+2)  
2b3e 32 bf fb			ld (debug_mark+2),a  
2b41 18 03			jr .pastdmark  
2b43 ..			.dmark: db "FRG"  
2b46 f1			.pastdmark: pop af  
2b47			endm  
# End of macro DMARK
2b47						CALLMONITOR 
2b47 cd 1c 17			call break_point_state  
2b4a				endm  
# End of macro CALLMONITOR
2b4a					endif 
2b4a			 
2b4a				; find uword 
2b4a			        ; update start of word with "_" 
2b4a				; replace uword with deleted flag 
2b4a			 
2b4a			 
2b4a			;	if DEBUG_FORTH_WORDS 
2b4a			;		DMARK "FOG" 
2b4a			;		CALLMONITOR 
2b4a			;	endif 
2b4a			 
2b4a			 
2b4a					; Get ptr to the word we need to look up 
2b4a			 
2b4a					FORTH_DSP_VALUEHL 
2b4a cd a3 1e			call macro_dsp_valuehl 
2b4d				endm 
# End of macro FORTH_DSP_VALUEHL
2b4d					;v5 FORTH_DSP_VALUE 
2b4d				; TODO type check 
2b4d			;		inc hl    ; Skip type check  
2b4d e5					push hl 
2b4e c1					pop bc 
2b4f			;		ex de, hl    ; put into DE 
2b4f			 
2b4f			 
2b4f 21 00 80				ld hl, baseram 
2b52					;ld hl, baseusermem 
2b52			 
2b52				; skip dict stub 
2b52			;	call forth_tok_next 
2b52 e5			push hl   ; sacreifical push 
2b53			 
2b53			.fldouscanm: 
2b53 e1				pop hl 
2b54			.fldouscan: 
2b54			;	if DEBUG_FORTH_WORDS 
2b54			;		DMARK "LSs" 
2b54			;		CALLMONITOR 
2b54			;	endif 
2b54				; skip dict stub 
2b54 cd 66 21				call forth_tok_next 
2b57			 
2b57			 
2b57			; while we have words to look for 
2b57			 
2b57 7e				ld a, (hl)      
2b58			;	if DEBUG_FORTH_WORDS 
2b58			;		DMARK "LSk" 
2b58			;		CALLMONITOR 
2b58			;	endif 
2b58 fe 00				cp WORD_SYS_END 
2b5a ca 96 2b				jp z, .flunotfound 
2b5d fe 01				cp WORD_SYS_UWORD 
2b5f c2 54 2b				jp nz, .fldouscan 
2b62			 
2b62			;	if DEBUG_FORTH_WORDS 
2b62			;		DMARK "LSu" 
2b62			;		CALLMONITOR 
2b62			;	endif 
2b62			 
2b62					; found a uword but is it the one we want... 
2b62			 
2b62 c5					push bc     ; uword to find is on bc 
2b63 d1					pop de 
2b64			 
2b64 e5					push hl  ; to save the ptr 
2b65			 
2b65					; skip opcode 
2b65 23					inc hl  
2b66					; skip next ptr 
2b66 23					inc hl  
2b67 23					inc hl 
2b68					; skip len 
2b68 23					inc hl 
2b69			 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "LSc" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69 cd 9f 11				call strcmp 
2b6c c2 53 2b				jp nz, .fldouscanm 
2b6f			; 
2b6f			; 
2b6f			;; while we have words to look for 
2b6f			; 
2b6f			;.fdouscan:	ld a, (hl)      
2b6f			;	if DEBUG_FORTH_WORDS 
2b6f			;		DMARK "LSs" 
2b6f			;		CALLMONITOR 
2b6f			;	endif 
2b6f			;		cp WORD_SYS_END 
2b6f			;		jp z, .fudone 
2b6f			;		cp WORD_SYS_UWORD 
2b6f			;		jp nz, .fnuword 
2b6f			; 
2b6f			;	if DEBUG_FORTH_WORDS 
2b6f			;		DMARK "FGu" 
2b6f			;		CALLMONITOR 
2b6f			;	endif 
2b6f			; 
2b6f			;		; found a uword but is it the one we want... 
2b6f			; 
2b6f			; 
2b6f			;	        pop de   ; get back the dsp name 
2b6f			;		push de 
2b6f			; 
2b6f			;		push hl  ; to save the ptr 
2b6f			; 
2b6f			;		; skip opcode 
2b6f			;		inc hl  
2b6f			;		; skip next ptr 
2b6f			;		inc hl  
2b6f			;		inc hl 
2b6f			;		; skip len 
2b6f			;		inc hl 
2b6f			; 
2b6f			;	if DEBUG_FORTH_WORDS 
2b6f			;		DMARK "FGc" 
2b6f			;		CALLMONITOR 
2b6f			;	endif 
2b6f			;		call strcmp 
2b6f			;		jp nz, .fnuword 
2b6f			 
2b6f			 
2b6f e1			pop hl 
2b70			 
2b70				 
2b70				if DEBUG_FORTH_WORDS 
2b70					DMARK "FGm" 
2b70 f5				push af  
2b71 3a 85 2b			ld a, (.dmark)  
2b74 32 bd fb			ld (debug_mark),a  
2b77 3a 86 2b			ld a, (.dmark+1)  
2b7a 32 be fb			ld (debug_mark+1),a  
2b7d 3a 87 2b			ld a, (.dmark+2)  
2b80 32 bf fb			ld (debug_mark+2),a  
2b83 18 03			jr .pastdmark  
2b85 ..			.dmark: db "FGm"  
2b88 f1			.pastdmark: pop af  
2b89			endm  
# End of macro DMARK
2b89					CALLMONITOR 
2b89 cd 1c 17			call break_point_state  
2b8c				endm  
# End of macro CALLMONITOR
2b8c				endif 
2b8c			 
2b8c			 
2b8c			 
2b8c					; we have a uword so push its name to the stack 
2b8c			 
2b8c			;	   	push hl  ; save so we can move to next dict block 
2b8c			;pop hl 
2b8c			 
2b8c					; update opcode to deleted 
2b8c 3e 03				ld a, WORD_SYS_DELETED 
2b8e 77					ld (hl), a 
2b8f			 
2b8f 23					inc hl  
2b90					; skip next ptr 
2b90 23					inc hl  
2b91 23					inc hl 
2b92					; skip len 
2b92 23					inc hl 
2b93			 
2b93					; TODO change parser to skip deleted words but for now mark it out 
2b93 3e 5f				ld a, "_" 
2b95 77					ld  (hl),a 
2b96			 
2b96			;		jr .fudone 
2b96			; 
2b96			;.fnuword:	pop hl 
2b96			;		call forth_tok_next 
2b96			;		jp .fdouscan  
2b96			 
2b96			.flunotfound:		  
2b96			 
2b96			 
2b96					 
2b96					FORTH_DSP_POP 
2b96 cd 5b 1f			call macro_forth_dsp_pop 
2b99				endm 
# End of macro FORTH_DSP_POP
2b99			;		ld hl, .luno 
2b99			;.fudone:		 pop hl 
2b99					NEXTW 
2b99 c3 15 20			jp macro_next 
2b9c				endm 
# End of macro NEXTW
2b9c			.NOP: 
2b9c				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b9c 61				db WORD_SYS_CORE+77             
2b9d c3 2b			dw .COMO            
2b9f 04				db 3 + 1 
2ba0 .. 00			db "NOP",0              
2ba4				endm 
# End of macro CWHEAD
2ba4			; | NOP (  --  ) Do nothing | DONE 
2ba4					if DEBUG_FORTH_WORDS_KEY 
2ba4						DMARK "NOP" 
2ba4 f5				push af  
2ba5 3a b9 2b			ld a, (.dmark)  
2ba8 32 bd fb			ld (debug_mark),a  
2bab 3a ba 2b			ld a, (.dmark+1)  
2bae 32 be fb			ld (debug_mark+1),a  
2bb1 3a bb 2b			ld a, (.dmark+2)  
2bb4 32 bf fb			ld (debug_mark+2),a  
2bb7 18 03			jr .pastdmark  
2bb9 ..			.dmark: db "NOP"  
2bbc f1			.pastdmark: pop af  
2bbd			endm  
# End of macro DMARK
2bbd						CALLMONITOR 
2bbd cd 1c 17			call break_point_state  
2bc0				endm  
# End of macro CALLMONITOR
2bc0					endif 
2bc0				       NEXTW 
2bc0 c3 15 20			jp macro_next 
2bc3				endm 
# End of macro NEXTW
2bc3			.COMO: 
2bc3				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bc3 6e				db WORD_SYS_CORE+90             
2bc4 15 2c			dw .COMC            
2bc6 02				db 1 + 1 
2bc7 .. 00			db "(",0              
2bc9				endm 
# End of macro CWHEAD
2bc9			; | ( ( -- )  Start of comment | DONE 
2bc9			 
2bc9			 
2bc9 2a a4 f2				ld hl, ( os_tok_ptr) 
2bcc 11 10 2c			ld de, .closepar 
2bcf					 
2bcf					if DEBUG_FORTH_WORDS 
2bcf						DMARK ").." 
2bcf f5				push af  
2bd0 3a e4 2b			ld a, (.dmark)  
2bd3 32 bd fb			ld (debug_mark),a  
2bd6 3a e5 2b			ld a, (.dmark+1)  
2bd9 32 be fb			ld (debug_mark+1),a  
2bdc 3a e6 2b			ld a, (.dmark+2)  
2bdf 32 bf fb			ld (debug_mark+2),a  
2be2 18 03			jr .pastdmark  
2be4 ..			.dmark: db ").."  
2be7 f1			.pastdmark: pop af  
2be8			endm  
# End of macro DMARK
2be8						CALLMONITOR 
2be8 cd 1c 17			call break_point_state  
2beb				endm  
# End of macro CALLMONITOR
2beb					endif 
2beb cd 30 21			call findnexttok  
2bee			 
2bee					if DEBUG_FORTH_WORDS 
2bee						DMARK "IF5" 
2bee f5				push af  
2bef 3a 03 2c			ld a, (.dmark)  
2bf2 32 bd fb			ld (debug_mark),a  
2bf5 3a 04 2c			ld a, (.dmark+1)  
2bf8 32 be fb			ld (debug_mark+1),a  
2bfb 3a 05 2c			ld a, (.dmark+2)  
2bfe 32 bf fb			ld (debug_mark+2),a  
2c01 18 03			jr .pastdmark  
2c03 ..			.dmark: db "IF5"  
2c06 f1			.pastdmark: pop af  
2c07			endm  
# End of macro DMARK
2c07						CALLMONITOR 
2c07 cd 1c 17			call break_point_state  
2c0a				endm  
# End of macro CALLMONITOR
2c0a					endif 
2c0a				; replace below with ) exec using tok_ptr 
2c0a 22 a4 f2			ld (os_tok_ptr), hl 
2c0d c3 a6 20			jp exec1 
2c10			 
2c10 .. 00			.closepar:   db ")",0 
2c12			 
2c12				       NEXTW 
2c12 c3 15 20			jp macro_next 
2c15				endm 
# End of macro NEXTW
2c15			.COMC: 
2c15				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c15 6f				db WORD_SYS_CORE+91             
2c16 1e 2c			dw .SCRATCH            
2c18 02				db 1 + 1 
2c19 .. 00			db ")",0              
2c1b				endm 
# End of macro CWHEAD
2c1b			; | ) ( -- )  End of comment |  DONE  
2c1b				       NEXTW 
2c1b c3 15 20			jp macro_next 
2c1e				endm 
# End of macro NEXTW
2c1e			 
2c1e			.SCRATCH: 
2c1e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c1e 6f				db WORD_SYS_CORE+91             
2c1f 59 2c			dw .INC            
2c21 08				db 7 + 1 
2c22 .. 00			db "SCRATCH",0              
2c2a				endm 
# End of macro CWHEAD
2c2a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c2a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c2a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c2a			; | |  
2c2a			; | | e.g.    : score $00 scratch ; 
2c2a			; | |  
2c2a			; | | $00 score ! 
2c2a			; | | $01 score +! 
2c2a			; | |  
2c2a			; | | e.g.   : varword $0a scratch ;  
2c2a			; | | 
2c2a			; | | $8000 varword ! 
2c2a					if DEBUG_FORTH_WORDS_KEY 
2c2a						DMARK "SCR" 
2c2a f5				push af  
2c2b 3a 3f 2c			ld a, (.dmark)  
2c2e 32 bd fb			ld (debug_mark),a  
2c31 3a 40 2c			ld a, (.dmark+1)  
2c34 32 be fb			ld (debug_mark+1),a  
2c37 3a 41 2c			ld a, (.dmark+2)  
2c3a 32 bf fb			ld (debug_mark+2),a  
2c3d 18 03			jr .pastdmark  
2c3f ..			.dmark: db "SCR"  
2c42 f1			.pastdmark: pop af  
2c43			endm  
# End of macro DMARK
2c43						CALLMONITOR 
2c43 cd 1c 17			call break_point_state  
2c46				endm  
# End of macro CALLMONITOR
2c46					endif 
2c46			 
2c46					FORTH_DSP_VALUEHL 
2c46 cd a3 1e			call macro_dsp_valuehl 
2c49				endm 
# End of macro FORTH_DSP_VALUEHL
2c49				 
2c49					FORTH_DSP_POP 
2c49 cd 5b 1f			call macro_forth_dsp_pop 
2c4c				endm 
# End of macro FORTH_DSP_POP
2c4c			 
2c4c 7d					ld a, l 
2c4d 21 c8 f4				ld hl, os_var_array 
2c50 cd 09 0d				call addatohl 
2c53			 
2c53 cd ac 1c				call forth_push_numhl 
2c56			 
2c56				       NEXTW 
2c56 c3 15 20			jp macro_next 
2c59				endm 
# End of macro NEXTW
2c59			 
2c59			.INC: 
2c59				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c59 6f				db WORD_SYS_CORE+91             
2c5a ad 2c			dw .DEC            
2c5c 03				db 2 + 1 
2c5d .. 00			db "+!",0              
2c60				endm 
# End of macro CWHEAD
2c60			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c60					if DEBUG_FORTH_WORDS_KEY 
2c60						DMARK "+s_" 
2c60 f5				push af  
2c61 3a 75 2c			ld a, (.dmark)  
2c64 32 bd fb			ld (debug_mark),a  
2c67 3a 76 2c			ld a, (.dmark+1)  
2c6a 32 be fb			ld (debug_mark+1),a  
2c6d 3a 77 2c			ld a, (.dmark+2)  
2c70 32 bf fb			ld (debug_mark+2),a  
2c73 18 03			jr .pastdmark  
2c75 ..			.dmark: db "+s_"  
2c78 f1			.pastdmark: pop af  
2c79			endm  
# End of macro DMARK
2c79						CALLMONITOR 
2c79 cd 1c 17			call break_point_state  
2c7c				endm  
# End of macro CALLMONITOR
2c7c					endif 
2c7c			 
2c7c					FORTH_DSP_VALUEHL 
2c7c cd a3 1e			call macro_dsp_valuehl 
2c7f				endm 
# End of macro FORTH_DSP_VALUEHL
2c7f			 
2c7f e5					push hl   ; save address 
2c80			 
2c80					FORTH_DSP_POP 
2c80 cd 5b 1f			call macro_forth_dsp_pop 
2c83				endm 
# End of macro FORTH_DSP_POP
2c83			 
2c83					FORTH_DSP_VALUEHL 
2c83 cd a3 1e			call macro_dsp_valuehl 
2c86				endm 
# End of macro FORTH_DSP_VALUEHL
2c86			 
2c86					FORTH_DSP_POP 
2c86 cd 5b 1f			call macro_forth_dsp_pop 
2c89				endm 
# End of macro FORTH_DSP_POP
2c89			 
2c89					; hl contains value to add to byte at a 
2c89				 
2c89 eb					ex de, hl 
2c8a			 
2c8a e1					pop hl 
2c8b			 
2c8b					if DEBUG_FORTH_WORDS 
2c8b						DMARK "INC" 
2c8b f5				push af  
2c8c 3a a0 2c			ld a, (.dmark)  
2c8f 32 bd fb			ld (debug_mark),a  
2c92 3a a1 2c			ld a, (.dmark+1)  
2c95 32 be fb			ld (debug_mark+1),a  
2c98 3a a2 2c			ld a, (.dmark+2)  
2c9b 32 bf fb			ld (debug_mark+2),a  
2c9e 18 03			jr .pastdmark  
2ca0 ..			.dmark: db "INC"  
2ca3 f1			.pastdmark: pop af  
2ca4			endm  
# End of macro DMARK
2ca4						CALLMONITOR 
2ca4 cd 1c 17			call break_point_state  
2ca7				endm  
# End of macro CALLMONITOR
2ca7					endif 
2ca7			 
2ca7 7e					ld a,(hl) 
2ca8 83					add e 
2ca9 77					ld (hl),a 
2caa			 
2caa			 
2caa			 
2caa				       NEXTW 
2caa c3 15 20			jp macro_next 
2cad				endm 
# End of macro NEXTW
2cad			 
2cad			.DEC: 
2cad				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cad 6f				db WORD_SYS_CORE+91             
2cae fe 2c			dw .INC2            
2cb0 03				db 2 + 1 
2cb1 .. 00			db "-!",0              
2cb4				endm 
# End of macro CWHEAD
2cb4			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cb4					if DEBUG_FORTH_WORDS_KEY 
2cb4						DMARK "-s_" 
2cb4 f5				push af  
2cb5 3a c9 2c			ld a, (.dmark)  
2cb8 32 bd fb			ld (debug_mark),a  
2cbb 3a ca 2c			ld a, (.dmark+1)  
2cbe 32 be fb			ld (debug_mark+1),a  
2cc1 3a cb 2c			ld a, (.dmark+2)  
2cc4 32 bf fb			ld (debug_mark+2),a  
2cc7 18 03			jr .pastdmark  
2cc9 ..			.dmark: db "-s_"  
2ccc f1			.pastdmark: pop af  
2ccd			endm  
# End of macro DMARK
2ccd						CALLMONITOR 
2ccd cd 1c 17			call break_point_state  
2cd0				endm  
# End of macro CALLMONITOR
2cd0					endif 
2cd0			 
2cd0					FORTH_DSP_VALUEHL 
2cd0 cd a3 1e			call macro_dsp_valuehl 
2cd3				endm 
# End of macro FORTH_DSP_VALUEHL
2cd3			 
2cd3 e5					push hl   ; save address 
2cd4			 
2cd4					FORTH_DSP_POP 
2cd4 cd 5b 1f			call macro_forth_dsp_pop 
2cd7				endm 
# End of macro FORTH_DSP_POP
2cd7			 
2cd7					FORTH_DSP_VALUEHL 
2cd7 cd a3 1e			call macro_dsp_valuehl 
2cda				endm 
# End of macro FORTH_DSP_VALUEHL
2cda			 
2cda					; hl contains value to add to byte at a 
2cda				 
2cda eb					ex de, hl 
2cdb			 
2cdb e1					pop hl 
2cdc			 
2cdc					if DEBUG_FORTH_WORDS 
2cdc						DMARK "DEC" 
2cdc f5				push af  
2cdd 3a f1 2c			ld a, (.dmark)  
2ce0 32 bd fb			ld (debug_mark),a  
2ce3 3a f2 2c			ld a, (.dmark+1)  
2ce6 32 be fb			ld (debug_mark+1),a  
2ce9 3a f3 2c			ld a, (.dmark+2)  
2cec 32 bf fb			ld (debug_mark+2),a  
2cef 18 03			jr .pastdmark  
2cf1 ..			.dmark: db "DEC"  
2cf4 f1			.pastdmark: pop af  
2cf5			endm  
# End of macro DMARK
2cf5						CALLMONITOR 
2cf5 cd 1c 17			call break_point_state  
2cf8				endm  
# End of macro CALLMONITOR
2cf8					endif 
2cf8			 
2cf8 7e					ld a,(hl) 
2cf9 93					sub e 
2cfa 77					ld (hl),a 
2cfb			 
2cfb			 
2cfb			 
2cfb				       NEXTW 
2cfb c3 15 20			jp macro_next 
2cfe				endm 
# End of macro NEXTW
2cfe			 
2cfe			.INC2: 
2cfe				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2cfe 6f				db WORD_SYS_CORE+91             
2cff a8 2d			dw .DEC2            
2d01 04				db 3 + 1 
2d02 .. 00			db "+2!",0              
2d06				endm 
# End of macro CWHEAD
2d06			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d06			 
2d06					if DEBUG_FORTH_WORDS_KEY 
2d06						DMARK "+2s" 
2d06 f5				push af  
2d07 3a 1b 2d			ld a, (.dmark)  
2d0a 32 bd fb			ld (debug_mark),a  
2d0d 3a 1c 2d			ld a, (.dmark+1)  
2d10 32 be fb			ld (debug_mark+1),a  
2d13 3a 1d 2d			ld a, (.dmark+2)  
2d16 32 bf fb			ld (debug_mark+2),a  
2d19 18 03			jr .pastdmark  
2d1b ..			.dmark: db "+2s"  
2d1e f1			.pastdmark: pop af  
2d1f			endm  
# End of macro DMARK
2d1f						CALLMONITOR 
2d1f cd 1c 17			call break_point_state  
2d22				endm  
# End of macro CALLMONITOR
2d22					endif 
2d22			 
2d22					; Address 
2d22			 
2d22					FORTH_DSP_VALUEHL 
2d22 cd a3 1e			call macro_dsp_valuehl 
2d25				endm 
# End of macro FORTH_DSP_VALUEHL
2d25			 
2d25 e5					push hl    ; save address 
2d26			 
2d26					; load content into de 
2d26			 
2d26 5e					ld e,(hl) 
2d27 23					inc hl 
2d28 56					ld d, (hl) 
2d29			 
2d29					if DEBUG_FORTH_WORDS 
2d29						DMARK "+2a" 
2d29 f5				push af  
2d2a 3a 3e 2d			ld a, (.dmark)  
2d2d 32 bd fb			ld (debug_mark),a  
2d30 3a 3f 2d			ld a, (.dmark+1)  
2d33 32 be fb			ld (debug_mark+1),a  
2d36 3a 40 2d			ld a, (.dmark+2)  
2d39 32 bf fb			ld (debug_mark+2),a  
2d3c 18 03			jr .pastdmark  
2d3e ..			.dmark: db "+2a"  
2d41 f1			.pastdmark: pop af  
2d42			endm  
# End of macro DMARK
2d42						CALLMONITOR 
2d42 cd 1c 17			call break_point_state  
2d45				endm  
# End of macro CALLMONITOR
2d45					endif 
2d45			 
2d45					FORTH_DSP_POP 
2d45 cd 5b 1f			call macro_forth_dsp_pop 
2d48				endm 
# End of macro FORTH_DSP_POP
2d48			 
2d48					; Get value to add 
2d48			 
2d48					FORTH_DSP_VALUE 
2d48 cd 8c 1e			call macro_forth_dsp_value 
2d4b				endm 
# End of macro FORTH_DSP_VALUE
2d4b			 
2d4b					if DEBUG_FORTH_WORDS 
2d4b						DMARK "+2v" 
2d4b f5				push af  
2d4c 3a 60 2d			ld a, (.dmark)  
2d4f 32 bd fb			ld (debug_mark),a  
2d52 3a 61 2d			ld a, (.dmark+1)  
2d55 32 be fb			ld (debug_mark+1),a  
2d58 3a 62 2d			ld a, (.dmark+2)  
2d5b 32 bf fb			ld (debug_mark+2),a  
2d5e 18 03			jr .pastdmark  
2d60 ..			.dmark: db "+2v"  
2d63 f1			.pastdmark: pop af  
2d64			endm  
# End of macro DMARK
2d64						CALLMONITOR 
2d64 cd 1c 17			call break_point_state  
2d67				endm  
# End of macro CALLMONITOR
2d67					endif 
2d67			 
2d67 19					add hl, de 
2d68			 
2d68					if DEBUG_FORTH_WORDS 
2d68						DMARK "+2+" 
2d68 f5				push af  
2d69 3a 7d 2d			ld a, (.dmark)  
2d6c 32 bd fb			ld (debug_mark),a  
2d6f 3a 7e 2d			ld a, (.dmark+1)  
2d72 32 be fb			ld (debug_mark+1),a  
2d75 3a 7f 2d			ld a, (.dmark+2)  
2d78 32 bf fb			ld (debug_mark+2),a  
2d7b 18 03			jr .pastdmark  
2d7d ..			.dmark: db "+2+"  
2d80 f1			.pastdmark: pop af  
2d81			endm  
# End of macro DMARK
2d81						CALLMONITOR 
2d81 cd 1c 17			call break_point_state  
2d84				endm  
# End of macro CALLMONITOR
2d84					endif 
2d84			 
2d84					; move result to de 
2d84			 
2d84 eb					ex de, hl 
2d85			 
2d85					; Address 
2d85			 
2d85 e1					pop hl 
2d86			 
2d86					; save it back 
2d86			 
2d86 73					ld (hl), e 
2d87 23					inc hl 
2d88 72					ld (hl), d 
2d89			 
2d89					if DEBUG_FORTH_WORDS 
2d89						DMARK "+2e" 
2d89 f5				push af  
2d8a 3a 9e 2d			ld a, (.dmark)  
2d8d 32 bd fb			ld (debug_mark),a  
2d90 3a 9f 2d			ld a, (.dmark+1)  
2d93 32 be fb			ld (debug_mark+1),a  
2d96 3a a0 2d			ld a, (.dmark+2)  
2d99 32 bf fb			ld (debug_mark+2),a  
2d9c 18 03			jr .pastdmark  
2d9e ..			.dmark: db "+2e"  
2da1 f1			.pastdmark: pop af  
2da2			endm  
# End of macro DMARK
2da2						CALLMONITOR 
2da2 cd 1c 17			call break_point_state  
2da5				endm  
# End of macro CALLMONITOR
2da5					endif 
2da5			 
2da5			 
2da5			 
2da5			 
2da5			 
2da5				       NEXTW 
2da5 c3 15 20			jp macro_next 
2da8				endm 
# End of macro NEXTW
2da8			 
2da8			.DEC2: 
2da8				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2da8 6f				db WORD_SYS_CORE+91             
2da9 54 2e			dw .GET2            
2dab 04				db 3 + 1 
2dac .. 00			db "-2!",0              
2db0				endm 
# End of macro CWHEAD
2db0			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2db0			 
2db0			 
2db0					if DEBUG_FORTH_WORDS_KEY 
2db0						DMARK "-2s" 
2db0 f5				push af  
2db1 3a c5 2d			ld a, (.dmark)  
2db4 32 bd fb			ld (debug_mark),a  
2db7 3a c6 2d			ld a, (.dmark+1)  
2dba 32 be fb			ld (debug_mark+1),a  
2dbd 3a c7 2d			ld a, (.dmark+2)  
2dc0 32 bf fb			ld (debug_mark+2),a  
2dc3 18 03			jr .pastdmark  
2dc5 ..			.dmark: db "-2s"  
2dc8 f1			.pastdmark: pop af  
2dc9			endm  
# End of macro DMARK
2dc9						CALLMONITOR 
2dc9 cd 1c 17			call break_point_state  
2dcc				endm  
# End of macro CALLMONITOR
2dcc					endif 
2dcc			 
2dcc					; Address 
2dcc			 
2dcc					FORTH_DSP_VALUEHL 
2dcc cd a3 1e			call macro_dsp_valuehl 
2dcf				endm 
# End of macro FORTH_DSP_VALUEHL
2dcf			 
2dcf e5					push hl    ; save address 
2dd0			 
2dd0					; load content into de 
2dd0			 
2dd0 5e					ld e,(hl) 
2dd1 23					inc hl 
2dd2 56					ld d, (hl) 
2dd3			 
2dd3					if DEBUG_FORTH_WORDS 
2dd3						DMARK "-2a" 
2dd3 f5				push af  
2dd4 3a e8 2d			ld a, (.dmark)  
2dd7 32 bd fb			ld (debug_mark),a  
2dda 3a e9 2d			ld a, (.dmark+1)  
2ddd 32 be fb			ld (debug_mark+1),a  
2de0 3a ea 2d			ld a, (.dmark+2)  
2de3 32 bf fb			ld (debug_mark+2),a  
2de6 18 03			jr .pastdmark  
2de8 ..			.dmark: db "-2a"  
2deb f1			.pastdmark: pop af  
2dec			endm  
# End of macro DMARK
2dec						CALLMONITOR 
2dec cd 1c 17			call break_point_state  
2def				endm  
# End of macro CALLMONITOR
2def					endif 
2def			 
2def					FORTH_DSP_POP 
2def cd 5b 1f			call macro_forth_dsp_pop 
2df2				endm 
# End of macro FORTH_DSP_POP
2df2			 
2df2					; Get value to remove 
2df2			 
2df2					FORTH_DSP_VALUE 
2df2 cd 8c 1e			call macro_forth_dsp_value 
2df5				endm 
# End of macro FORTH_DSP_VALUE
2df5			 
2df5					if DEBUG_FORTH_WORDS 
2df5						DMARK "-2v" 
2df5 f5				push af  
2df6 3a 0a 2e			ld a, (.dmark)  
2df9 32 bd fb			ld (debug_mark),a  
2dfc 3a 0b 2e			ld a, (.dmark+1)  
2dff 32 be fb			ld (debug_mark+1),a  
2e02 3a 0c 2e			ld a, (.dmark+2)  
2e05 32 bf fb			ld (debug_mark+2),a  
2e08 18 03			jr .pastdmark  
2e0a ..			.dmark: db "-2v"  
2e0d f1			.pastdmark: pop af  
2e0e			endm  
# End of macro DMARK
2e0e						CALLMONITOR 
2e0e cd 1c 17			call break_point_state  
2e11				endm  
# End of macro CALLMONITOR
2e11					endif 
2e11			 
2e11 eb					ex de, hl 
2e12 ed 52				sbc hl, de 
2e14			 
2e14					if DEBUG_FORTH_WORDS 
2e14						DMARK "-2d" 
2e14 f5				push af  
2e15 3a 29 2e			ld a, (.dmark)  
2e18 32 bd fb			ld (debug_mark),a  
2e1b 3a 2a 2e			ld a, (.dmark+1)  
2e1e 32 be fb			ld (debug_mark+1),a  
2e21 3a 2b 2e			ld a, (.dmark+2)  
2e24 32 bf fb			ld (debug_mark+2),a  
2e27 18 03			jr .pastdmark  
2e29 ..			.dmark: db "-2d"  
2e2c f1			.pastdmark: pop af  
2e2d			endm  
# End of macro DMARK
2e2d						CALLMONITOR 
2e2d cd 1c 17			call break_point_state  
2e30				endm  
# End of macro CALLMONITOR
2e30					endif 
2e30			 
2e30					; move result to de 
2e30			 
2e30 eb					ex de, hl 
2e31			 
2e31					; Address 
2e31			 
2e31 e1					pop hl 
2e32			 
2e32					; save it back 
2e32			 
2e32 73					ld (hl), e 
2e33 23					inc hl 
2e34 72					ld (hl), d 
2e35			 
2e35					if DEBUG_FORTH_WORDS 
2e35						DMARK "-2e" 
2e35 f5				push af  
2e36 3a 4a 2e			ld a, (.dmark)  
2e39 32 bd fb			ld (debug_mark),a  
2e3c 3a 4b 2e			ld a, (.dmark+1)  
2e3f 32 be fb			ld (debug_mark+1),a  
2e42 3a 4c 2e			ld a, (.dmark+2)  
2e45 32 bf fb			ld (debug_mark+2),a  
2e48 18 03			jr .pastdmark  
2e4a ..			.dmark: db "-2e"  
2e4d f1			.pastdmark: pop af  
2e4e			endm  
# End of macro DMARK
2e4e						CALLMONITOR 
2e4e cd 1c 17			call break_point_state  
2e51				endm  
# End of macro CALLMONITOR
2e51					endif 
2e51			 
2e51			 
2e51			 
2e51			 
2e51			 
2e51				       NEXTW 
2e51 c3 15 20			jp macro_next 
2e54				endm 
# End of macro NEXTW
2e54			.GET2: 
2e54				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e54 6f				db WORD_SYS_CORE+91             
2e55 84 2e			dw .BANG2            
2e57 03				db 2 + 1 
2e58 .. 00			db "2@",0              
2e5b				endm 
# End of macro CWHEAD
2e5b			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e5b					if DEBUG_FORTH_WORDS_KEY 
2e5b						DMARK "2A_" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 bd fb			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 be fb			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 bf fb			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "2A_"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74						CALLMONITOR 
2e74 cd 1c 17			call break_point_state  
2e77				endm  
# End of macro CALLMONITOR
2e77					endif 
2e77			 
2e77					FORTH_DSP_VALUEHL 
2e77 cd a3 1e			call macro_dsp_valuehl 
2e7a				endm 
# End of macro FORTH_DSP_VALUEHL
2e7a			 
2e7a 5e					ld e, (hl) 
2e7b 23					inc hl 
2e7c 56					ld d, (hl) 
2e7d			 
2e7d eb					ex de, hl 
2e7e			 
2e7e cd ac 1c				call forth_push_numhl 
2e81			 
2e81				       NEXTW 
2e81 c3 15 20			jp macro_next 
2e84				endm 
# End of macro NEXTW
2e84			.BANG2: 
2e84				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e84 6f				db WORD_SYS_CORE+91             
2e85 bc 2e			dw .CONFIG            
2e87 03				db 2 + 1 
2e88 .. 00			db "2!",0              
2e8b				endm 
# End of macro CWHEAD
2e8b			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e8b					if DEBUG_FORTH_WORDS_KEY 
2e8b						DMARK "2S_" 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 bd fb			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 be fb			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 bf fb			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "2S_"  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4						CALLMONITOR 
2ea4 cd 1c 17			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7					endif 
2ea7			 
2ea7					FORTH_DSP_VALUEHL 
2ea7 cd a3 1e			call macro_dsp_valuehl 
2eaa				endm 
# End of macro FORTH_DSP_VALUEHL
2eaa			 
2eaa e5					push hl   ; save address 
2eab			 
2eab			 
2eab					FORTH_DSP_POP 
2eab cd 5b 1f			call macro_forth_dsp_pop 
2eae				endm 
# End of macro FORTH_DSP_POP
2eae			 
2eae					 
2eae					FORTH_DSP_VALUEHL 
2eae cd a3 1e			call macro_dsp_valuehl 
2eb1				endm 
# End of macro FORTH_DSP_VALUEHL
2eb1			 
2eb1					FORTH_DSP_POP 
2eb1 cd 5b 1f			call macro_forth_dsp_pop 
2eb4				endm 
# End of macro FORTH_DSP_POP
2eb4			 
2eb4 eb					ex de, hl    ; value now in de 
2eb5			 
2eb5 e1					pop hl 
2eb6			 
2eb6 73					ld (hl), e 
2eb7			 
2eb7 23					inc hl 
2eb8			 
2eb8 72					ld (hl), d 
2eb9			 
2eb9			 
2eb9				       NEXTW 
2eb9 c3 15 20			jp macro_next 
2ebc				endm 
# End of macro NEXTW
2ebc			.CONFIG: 
2ebc				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ebc 6f				db WORD_SYS_CORE+91             
2ebd cd 2e			dw .ENDCORE            
2ebf 07				db 6 + 1 
2ec0 .. 00			db "CONFIG",0              
2ec7				endm 
# End of macro CWHEAD
2ec7			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ec7			 
2ec7 cd 69 13				call config 
2eca					NEXTW 
2eca c3 15 20			jp macro_next 
2ecd				endm 
# End of macro NEXTW
2ecd			.ENDCORE: 
2ecd			 
2ecd			; eof 
2ecd			 
2ecd			 
# End of file forth_words_core.asm
2ecd			include "forth_words_flow.asm" 
2ecd			 
2ecd			; | ## Program Flow Words 
2ecd			 
2ecd			.IF: 
2ecd				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ecd 1e				db WORD_SYS_CORE+10             
2ece c2 2f			dw .THEN            
2ed0 03				db 2 + 1 
2ed1 .. 00			db "IF",0              
2ed4				endm 
# End of macro CWHEAD
2ed4			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ed4			; 
2ed4					if DEBUG_FORTH_WORDS_KEY 
2ed4						DMARK "IF." 
2ed4 f5				push af  
2ed5 3a e9 2e			ld a, (.dmark)  
2ed8 32 bd fb			ld (debug_mark),a  
2edb 3a ea 2e			ld a, (.dmark+1)  
2ede 32 be fb			ld (debug_mark+1),a  
2ee1 3a eb 2e			ld a, (.dmark+2)  
2ee4 32 bf fb			ld (debug_mark+2),a  
2ee7 18 03			jr .pastdmark  
2ee9 ..			.dmark: db "IF."  
2eec f1			.pastdmark: pop af  
2eed			endm  
# End of macro DMARK
2eed						CALLMONITOR 
2eed cd 1c 17			call break_point_state  
2ef0				endm  
# End of macro CALLMONITOR
2ef0					endif 
2ef0			; eval TOS 
2ef0			 
2ef0				FORTH_DSP_VALUEHL 
2ef0 cd a3 1e			call macro_dsp_valuehl 
2ef3				endm 
# End of macro FORTH_DSP_VALUEHL
2ef3			 
2ef3			;	push hl 
2ef3				FORTH_DSP_POP 
2ef3 cd 5b 1f			call macro_forth_dsp_pop 
2ef6				endm 
# End of macro FORTH_DSP_POP
2ef6			;	pop hl 
2ef6			 
2ef6					if DEBUG_FORTH_WORDS 
2ef6						DMARK "IF1" 
2ef6 f5				push af  
2ef7 3a 0b 2f			ld a, (.dmark)  
2efa 32 bd fb			ld (debug_mark),a  
2efd 3a 0c 2f			ld a, (.dmark+1)  
2f00 32 be fb			ld (debug_mark+1),a  
2f03 3a 0d 2f			ld a, (.dmark+2)  
2f06 32 bf fb			ld (debug_mark+2),a  
2f09 18 03			jr .pastdmark  
2f0b ..			.dmark: db "IF1"  
2f0e f1			.pastdmark: pop af  
2f0f			endm  
# End of macro DMARK
2f0f						CALLMONITOR 
2f0f cd 1c 17			call break_point_state  
2f12				endm  
# End of macro CALLMONITOR
2f12					endif 
2f12 b7				or a        ; clear carry flag 
2f13 11 00 00			ld de, 0 
2f16 eb				ex de,hl 
2f17 ed 52			sbc hl, de 
2f19 c2 a3 2f			jp nz, .iftrue 
2f1c			 
2f1c					if DEBUG_FORTH_WORDS 
2f1c						DMARK "IF2" 
2f1c f5				push af  
2f1d 3a 31 2f			ld a, (.dmark)  
2f20 32 bd fb			ld (debug_mark),a  
2f23 3a 32 2f			ld a, (.dmark+1)  
2f26 32 be fb			ld (debug_mark+1),a  
2f29 3a 33 2f			ld a, (.dmark+2)  
2f2c 32 bf fb			ld (debug_mark+2),a  
2f2f 18 03			jr .pastdmark  
2f31 ..			.dmark: db "IF2"  
2f34 f1			.pastdmark: pop af  
2f35			endm  
# End of macro DMARK
2f35						CALLMONITOR 
2f35 cd 1c 17			call break_point_state  
2f38				endm  
# End of macro CALLMONITOR
2f38					endif 
2f38			 
2f38			; if not true then skip to THEN 
2f38			 
2f38				; TODO get tok_ptr 
2f38				; TODO consume toks until we get to THEN 
2f38			 
2f38 2a a4 f2			ld hl, (os_tok_ptr) 
2f3b					if DEBUG_FORTH_WORDS 
2f3b						DMARK "IF3" 
2f3b f5				push af  
2f3c 3a 50 2f			ld a, (.dmark)  
2f3f 32 bd fb			ld (debug_mark),a  
2f42 3a 51 2f			ld a, (.dmark+1)  
2f45 32 be fb			ld (debug_mark+1),a  
2f48 3a 52 2f			ld a, (.dmark+2)  
2f4b 32 bf fb			ld (debug_mark+2),a  
2f4e 18 03			jr .pastdmark  
2f50 ..			.dmark: db "IF3"  
2f53 f1			.pastdmark: pop af  
2f54			endm  
# End of macro DMARK
2f54						CALLMONITOR 
2f54 cd 1c 17			call break_point_state  
2f57				endm  
# End of macro CALLMONITOR
2f57						 
2f57					endif 
2f57 11 9e 2f			ld de, .ifthen 
2f5a					if DEBUG_FORTH_WORDS 
2f5a						DMARK "IF4" 
2f5a f5				push af  
2f5b 3a 6f 2f			ld a, (.dmark)  
2f5e 32 bd fb			ld (debug_mark),a  
2f61 3a 70 2f			ld a, (.dmark+1)  
2f64 32 be fb			ld (debug_mark+1),a  
2f67 3a 71 2f			ld a, (.dmark+2)  
2f6a 32 bf fb			ld (debug_mark+2),a  
2f6d 18 03			jr .pastdmark  
2f6f ..			.dmark: db "IF4"  
2f72 f1			.pastdmark: pop af  
2f73			endm  
# End of macro DMARK
2f73						CALLMONITOR 
2f73 cd 1c 17			call break_point_state  
2f76				endm  
# End of macro CALLMONITOR
2f76					endif 
2f76 cd 30 21			call findnexttok  
2f79			 
2f79					if DEBUG_FORTH_WORDS 
2f79						DMARK "IF5" 
2f79 f5				push af  
2f7a 3a 8e 2f			ld a, (.dmark)  
2f7d 32 bd fb			ld (debug_mark),a  
2f80 3a 8f 2f			ld a, (.dmark+1)  
2f83 32 be fb			ld (debug_mark+1),a  
2f86 3a 90 2f			ld a, (.dmark+2)  
2f89 32 bf fb			ld (debug_mark+2),a  
2f8c 18 03			jr .pastdmark  
2f8e ..			.dmark: db "IF5"  
2f91 f1			.pastdmark: pop af  
2f92			endm  
# End of macro DMARK
2f92						CALLMONITOR 
2f92 cd 1c 17			call break_point_state  
2f95				endm  
# End of macro CALLMONITOR
2f95					endif 
2f95				; TODO replace below with ; exec using tok_ptr 
2f95 22 a4 f2			ld (os_tok_ptr), hl 
2f98 c3 a6 20			jp exec1 
2f9b				NEXTW 
2f9b c3 15 20			jp macro_next 
2f9e				endm 
# End of macro NEXTW
2f9e			 
2f9e .. 00		.ifthen:  db "THEN",0 
2fa3			 
2fa3			.iftrue:		 
2fa3				; Exec next words normally 
2fa3			 
2fa3				; if true then exec following IF as normal 
2fa3					if DEBUG_FORTH_WORDS 
2fa3						DMARK "IFT" 
2fa3 f5				push af  
2fa4 3a b8 2f			ld a, (.dmark)  
2fa7 32 bd fb			ld (debug_mark),a  
2faa 3a b9 2f			ld a, (.dmark+1)  
2fad 32 be fb			ld (debug_mark+1),a  
2fb0 3a ba 2f			ld a, (.dmark+2)  
2fb3 32 bf fb			ld (debug_mark+2),a  
2fb6 18 03			jr .pastdmark  
2fb8 ..			.dmark: db "IFT"  
2fbb f1			.pastdmark: pop af  
2fbc			endm  
# End of macro DMARK
2fbc						CALLMONITOR 
2fbc cd 1c 17			call break_point_state  
2fbf				endm  
# End of macro CALLMONITOR
2fbf					endif 
2fbf			 
2fbf					NEXTW 
2fbf c3 15 20			jp macro_next 
2fc2				endm 
# End of macro NEXTW
2fc2			.THEN: 
2fc2				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fc2 1f				db WORD_SYS_CORE+11             
2fc3 ea 2f			dw .ELSE            
2fc5 05				db 4 + 1 
2fc6 .. 00			db "THEN",0              
2fcb				endm 
# End of macro CWHEAD
2fcb			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fcb					if DEBUG_FORTH_WORDS_KEY 
2fcb						DMARK "THN" 
2fcb f5				push af  
2fcc 3a e0 2f			ld a, (.dmark)  
2fcf 32 bd fb			ld (debug_mark),a  
2fd2 3a e1 2f			ld a, (.dmark+1)  
2fd5 32 be fb			ld (debug_mark+1),a  
2fd8 3a e2 2f			ld a, (.dmark+2)  
2fdb 32 bf fb			ld (debug_mark+2),a  
2fde 18 03			jr .pastdmark  
2fe0 ..			.dmark: db "THN"  
2fe3 f1			.pastdmark: pop af  
2fe4			endm  
# End of macro DMARK
2fe4						CALLMONITOR 
2fe4 cd 1c 17			call break_point_state  
2fe7				endm  
# End of macro CALLMONITOR
2fe7					endif 
2fe7					NEXTW 
2fe7 c3 15 20			jp macro_next 
2fea				endm 
# End of macro NEXTW
2fea			.ELSE: 
2fea				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fea 20				db WORD_SYS_CORE+12             
2feb 12 30			dw .DO            
2fed 03				db 2 + 1 
2fee .. 00			db "ELSE",0              
2ff3				endm 
# End of macro CWHEAD
2ff3			; | ELSE ( -- ) Not supported - does nothing | TODO 
2ff3			 
2ff3					if DEBUG_FORTH_WORDS_KEY 
2ff3						DMARK "ELS" 
2ff3 f5				push af  
2ff4 3a 08 30			ld a, (.dmark)  
2ff7 32 bd fb			ld (debug_mark),a  
2ffa 3a 09 30			ld a, (.dmark+1)  
2ffd 32 be fb			ld (debug_mark+1),a  
3000 3a 0a 30			ld a, (.dmark+2)  
3003 32 bf fb			ld (debug_mark+2),a  
3006 18 03			jr .pastdmark  
3008 ..			.dmark: db "ELS"  
300b f1			.pastdmark: pop af  
300c			endm  
# End of macro DMARK
300c						CALLMONITOR 
300c cd 1c 17			call break_point_state  
300f				endm  
# End of macro CALLMONITOR
300f					endif 
300f			 
300f			 
300f					NEXTW 
300f c3 15 20			jp macro_next 
3012				endm 
# End of macro NEXTW
3012			.DO: 
3012				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3012 21				db WORD_SYS_CORE+13             
3013 39 31			dw .LOOP            
3015 03				db 2 + 1 
3016 .. 00			db "DO",0              
3019				endm 
# End of macro CWHEAD
3019			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3019			 
3019					if DEBUG_FORTH_WORDS_KEY 
3019						DMARK "DO." 
3019 f5				push af  
301a 3a 2e 30			ld a, (.dmark)  
301d 32 bd fb			ld (debug_mark),a  
3020 3a 2f 30			ld a, (.dmark+1)  
3023 32 be fb			ld (debug_mark+1),a  
3026 3a 30 30			ld a, (.dmark+2)  
3029 32 bf fb			ld (debug_mark+2),a  
302c 18 03			jr .pastdmark  
302e ..			.dmark: db "DO."  
3031 f1			.pastdmark: pop af  
3032			endm  
# End of macro DMARK
3032						CALLMONITOR 
3032 cd 1c 17			call break_point_state  
3035				endm  
# End of macro CALLMONITOR
3035					endif 
3035			;  push pc to rsp stack past the DO 
3035			 
3035 2a a4 f2				ld hl, (os_tok_ptr) 
3038 23					inc hl   ; D 
3039 23					inc hl  ; O 
303a 23					inc hl   ; null 
303b					if DEBUG_FORTH_WORDS 
303b						DMARK "DO2" 
303b f5				push af  
303c 3a 50 30			ld a, (.dmark)  
303f 32 bd fb			ld (debug_mark),a  
3042 3a 51 30			ld a, (.dmark+1)  
3045 32 be fb			ld (debug_mark+1),a  
3048 3a 52 30			ld a, (.dmark+2)  
304b 32 bf fb			ld (debug_mark+2),a  
304e 18 03			jr .pastdmark  
3050 ..			.dmark: db "DO2"  
3053 f1			.pastdmark: pop af  
3054			endm  
# End of macro DMARK
3054						CALLMONITOR 
3054 cd 1c 17			call break_point_state  
3057				endm  
# End of macro CALLMONITOR
3057					endif 
3057					FORTH_RSP_NEXT 
3057 cd 53 1c			call macro_forth_rsp_next 
305a				endm 
# End of macro FORTH_RSP_NEXT
305a					if DEBUG_FORTH_WORDS 
305a						DMARK "DO3" 
305a f5				push af  
305b 3a 6f 30			ld a, (.dmark)  
305e 32 bd fb			ld (debug_mark),a  
3061 3a 70 30			ld a, (.dmark+1)  
3064 32 be fb			ld (debug_mark+1),a  
3067 3a 71 30			ld a, (.dmark+2)  
306a 32 bf fb			ld (debug_mark+2),a  
306d 18 03			jr .pastdmark  
306f ..			.dmark: db "DO3"  
3072 f1			.pastdmark: pop af  
3073			endm  
# End of macro DMARK
3073						CALLMONITOR 
3073 cd 1c 17			call break_point_state  
3076				endm  
# End of macro CALLMONITOR
3076					endif 
3076			 
3076					;if DEBUG_FORTH_WORDS 
3076				;		push hl 
3076			;		endif  
3076			 
3076			; get counters from data stack 
3076			 
3076			 
3076					FORTH_DSP_VALUEHL 
3076 cd a3 1e			call macro_dsp_valuehl 
3079				endm 
# End of macro FORTH_DSP_VALUEHL
3079 e5					push hl		 ; hl now has starting counter which needs to be tos 
307a			 
307a					if DEBUG_FORTH_WORDS 
307a						DMARK "DO4" 
307a f5				push af  
307b 3a 8f 30			ld a, (.dmark)  
307e 32 bd fb			ld (debug_mark),a  
3081 3a 90 30			ld a, (.dmark+1)  
3084 32 be fb			ld (debug_mark+1),a  
3087 3a 91 30			ld a, (.dmark+2)  
308a 32 bf fb			ld (debug_mark+2),a  
308d 18 03			jr .pastdmark  
308f ..			.dmark: db "DO4"  
3092 f1			.pastdmark: pop af  
3093			endm  
# End of macro DMARK
3093						CALLMONITOR 
3093 cd 1c 17			call break_point_state  
3096				endm  
# End of macro CALLMONITOR
3096					endif 
3096					FORTH_DSP_POP 
3096 cd 5b 1f			call macro_forth_dsp_pop 
3099				endm 
# End of macro FORTH_DSP_POP
3099			 
3099					if DEBUG_FORTH_WORDS 
3099						DMARK "DO5" 
3099 f5				push af  
309a 3a ae 30			ld a, (.dmark)  
309d 32 bd fb			ld (debug_mark),a  
30a0 3a af 30			ld a, (.dmark+1)  
30a3 32 be fb			ld (debug_mark+1),a  
30a6 3a b0 30			ld a, (.dmark+2)  
30a9 32 bf fb			ld (debug_mark+2),a  
30ac 18 03			jr .pastdmark  
30ae ..			.dmark: db "DO5"  
30b1 f1			.pastdmark: pop af  
30b2			endm  
# End of macro DMARK
30b2						CALLMONITOR 
30b2 cd 1c 17			call break_point_state  
30b5				endm  
# End of macro CALLMONITOR
30b5					endif 
30b5			 
30b5					FORTH_DSP_VALUEHL 
30b5 cd a3 1e			call macro_dsp_valuehl 
30b8				endm 
# End of macro FORTH_DSP_VALUEHL
30b8			;		push hl		 ; hl now has starting limit counter 
30b8			 
30b8					if DEBUG_FORTH_WORDS 
30b8						DMARK "DO6" 
30b8 f5				push af  
30b9 3a cd 30			ld a, (.dmark)  
30bc 32 bd fb			ld (debug_mark),a  
30bf 3a ce 30			ld a, (.dmark+1)  
30c2 32 be fb			ld (debug_mark+1),a  
30c5 3a cf 30			ld a, (.dmark+2)  
30c8 32 bf fb			ld (debug_mark+2),a  
30cb 18 03			jr .pastdmark  
30cd ..			.dmark: db "DO6"  
30d0 f1			.pastdmark: pop af  
30d1			endm  
# End of macro DMARK
30d1						CALLMONITOR 
30d1 cd 1c 17			call break_point_state  
30d4				endm  
# End of macro CALLMONITOR
30d4					endif 
30d4					FORTH_DSP_POP 
30d4 cd 5b 1f			call macro_forth_dsp_pop 
30d7				endm 
# End of macro FORTH_DSP_POP
30d7			 
30d7			; put counters on the loop stack 
30d7			 
30d7			;		pop hl			 ; limit counter 
30d7 d1					pop de			; start counter 
30d8			 
30d8					; push limit counter 
30d8			 
30d8					if DEBUG_FORTH_WORDS 
30d8						DMARK "DO7" 
30d8 f5				push af  
30d9 3a ed 30			ld a, (.dmark)  
30dc 32 bd fb			ld (debug_mark),a  
30df 3a ee 30			ld a, (.dmark+1)  
30e2 32 be fb			ld (debug_mark+1),a  
30e5 3a ef 30			ld a, (.dmark+2)  
30e8 32 bf fb			ld (debug_mark+2),a  
30eb 18 03			jr .pastdmark  
30ed ..			.dmark: db "DO7"  
30f0 f1			.pastdmark: pop af  
30f1			endm  
# End of macro DMARK
30f1						CALLMONITOR 
30f1 cd 1c 17			call break_point_state  
30f4				endm  
# End of macro CALLMONITOR
30f4					endif 
30f4					FORTH_LOOP_NEXT 
30f4 cd d4 1e			call macro_forth_loop_next 
30f7				endm 
# End of macro FORTH_LOOP_NEXT
30f7			 
30f7					; push start counter 
30f7			 
30f7 eb					ex de, hl 
30f8					if DEBUG_FORTH_WORDS 
30f8						DMARK "DO7" 
30f8 f5				push af  
30f9 3a 0d 31			ld a, (.dmark)  
30fc 32 bd fb			ld (debug_mark),a  
30ff 3a 0e 31			ld a, (.dmark+1)  
3102 32 be fb			ld (debug_mark+1),a  
3105 3a 0f 31			ld a, (.dmark+2)  
3108 32 bf fb			ld (debug_mark+2),a  
310b 18 03			jr .pastdmark  
310d ..			.dmark: db "DO7"  
3110 f1			.pastdmark: pop af  
3111			endm  
# End of macro DMARK
3111						CALLMONITOR 
3111 cd 1c 17			call break_point_state  
3114				endm  
# End of macro CALLMONITOR
3114					endif 
3114					FORTH_LOOP_NEXT 
3114 cd d4 1e			call macro_forth_loop_next 
3117				endm 
# End of macro FORTH_LOOP_NEXT
3117			 
3117			 
3117					; init first round of I counter 
3117			 
3117 22 c8 f2				ld (os_current_i), hl 
311a			 
311a					if DEBUG_FORTH_WORDS 
311a						DMARK "DO8" 
311a f5				push af  
311b 3a 2f 31			ld a, (.dmark)  
311e 32 bd fb			ld (debug_mark),a  
3121 3a 30 31			ld a, (.dmark+1)  
3124 32 be fb			ld (debug_mark+1),a  
3127 3a 31 31			ld a, (.dmark+2)  
312a 32 bf fb			ld (debug_mark+2),a  
312d 18 03			jr .pastdmark  
312f ..			.dmark: db "DO8"  
3132 f1			.pastdmark: pop af  
3133			endm  
# End of macro DMARK
3133						CALLMONITOR 
3133 cd 1c 17			call break_point_state  
3136				endm  
# End of macro CALLMONITOR
3136					endif 
3136			 
3136					NEXTW 
3136 c3 15 20			jp macro_next 
3139				endm 
# End of macro NEXTW
3139			.LOOP: 
3139				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3139 22				db WORD_SYS_CORE+14             
313a 51 32			dw .I            
313c 05				db 4 + 1 
313d .. 00			db "LOOP",0              
3142				endm 
# End of macro CWHEAD
3142			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3142			 
3142				; pop tos as current loop count to hl 
3142			 
3142				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3142			 
3142				FORTH_LOOP_TOS 
3142 cd 07 1f			call macro_forth_loop_tos 
3145				endm 
# End of macro FORTH_LOOP_TOS
3145 e5				push hl 
3146			 
3146					if DEBUG_FORTH_WORDS_KEY 
3146						DMARK "LOP" 
3146 f5				push af  
3147 3a 5b 31			ld a, (.dmark)  
314a 32 bd fb			ld (debug_mark),a  
314d 3a 5c 31			ld a, (.dmark+1)  
3150 32 be fb			ld (debug_mark+1),a  
3153 3a 5d 31			ld a, (.dmark+2)  
3156 32 bf fb			ld (debug_mark+2),a  
3159 18 03			jr .pastdmark  
315b ..			.dmark: db "LOP"  
315e f1			.pastdmark: pop af  
315f			endm  
# End of macro DMARK
315f						CALLMONITOR 
315f cd 1c 17			call break_point_state  
3162				endm  
# End of macro CALLMONITOR
3162					endif 
3162				; next item on the stack is the limit. get it 
3162			 
3162			 
3162				FORTH_LOOP_POP 
3162 cd 11 1f			call macro_forth_loop_pop 
3165				endm 
# End of macro FORTH_LOOP_POP
3165			 
3165				FORTH_LOOP_TOS 
3165 cd 07 1f			call macro_forth_loop_tos 
3168				endm 
# End of macro FORTH_LOOP_TOS
3168			 
3168 d1				pop de		 ; de = i, hl = limit 
3169			 
3169					if DEBUG_FORTH_WORDS 
3169						DMARK "LP1" 
3169 f5				push af  
316a 3a 7e 31			ld a, (.dmark)  
316d 32 bd fb			ld (debug_mark),a  
3170 3a 7f 31			ld a, (.dmark+1)  
3173 32 be fb			ld (debug_mark+1),a  
3176 3a 80 31			ld a, (.dmark+2)  
3179 32 bf fb			ld (debug_mark+2),a  
317c 18 03			jr .pastdmark  
317e ..			.dmark: db "LP1"  
3181 f1			.pastdmark: pop af  
3182			endm  
# End of macro DMARK
3182						CALLMONITOR 
3182 cd 1c 17			call break_point_state  
3185				endm  
# End of macro CALLMONITOR
3185					endif 
3185			 
3185				; go back to previous word 
3185			 
3185 d5				push de    ; save I for inc later 
3186			 
3186			 
3186				; get limit 
3186				;  is I at limit? 
3186			 
3186			 
3186					if DEBUG_FORTH_WORDS 
3186						DMARK "LP1" 
3186 f5				push af  
3187 3a 9b 31			ld a, (.dmark)  
318a 32 bd fb			ld (debug_mark),a  
318d 3a 9c 31			ld a, (.dmark+1)  
3190 32 be fb			ld (debug_mark+1),a  
3193 3a 9d 31			ld a, (.dmark+2)  
3196 32 bf fb			ld (debug_mark+2),a  
3199 18 03			jr .pastdmark  
319b ..			.dmark: db "LP1"  
319e f1			.pastdmark: pop af  
319f			endm  
# End of macro DMARK
319f						CALLMONITOR 
319f cd 1c 17			call break_point_state  
31a2				endm  
# End of macro CALLMONITOR
31a2					endif 
31a2			 
31a2 ed 52			sbc hl, de 
31a4			 
31a4			 
31a4				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31a4			 
31a4 20 26				jr nz, .loopnotdone 
31a6			 
31a6 e1				pop hl   ; get rid of saved I 
31a7				FORTH_LOOP_POP     ; get rid of limit 
31a7 cd 11 1f			call macro_forth_loop_pop 
31aa				endm 
# End of macro FORTH_LOOP_POP
31aa			 
31aa				FORTH_RSP_POP     ; get rid of DO ptr 
31aa cd 74 1c			call macro_forth_rsp_pop 
31ad				endm 
# End of macro FORTH_RSP_POP
31ad			 
31ad			if DEBUG_FORTH_WORDS 
31ad						DMARK "LP>" 
31ad f5				push af  
31ae 3a c2 31			ld a, (.dmark)  
31b1 32 bd fb			ld (debug_mark),a  
31b4 3a c3 31			ld a, (.dmark+1)  
31b7 32 be fb			ld (debug_mark+1),a  
31ba 3a c4 31			ld a, (.dmark+2)  
31bd 32 bf fb			ld (debug_mark+2),a  
31c0 18 03			jr .pastdmark  
31c2 ..			.dmark: db "LP>"  
31c5 f1			.pastdmark: pop af  
31c6			endm  
# End of macro DMARK
31c6				CALLMONITOR 
31c6 cd 1c 17			call break_point_state  
31c9				endm  
# End of macro CALLMONITOR
31c9			endif 
31c9			 
31c9					NEXTW 
31c9 c3 15 20			jp macro_next 
31cc				endm 
# End of macro NEXTW
31cc				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31cc			 
31cc			.loopnotdone: 
31cc			 
31cc e1				pop hl    ; get I 
31cd 23				inc hl 
31ce			 
31ce			   	; save new I 
31ce			 
31ce			 
31ce					; set I counter 
31ce			 
31ce 22 c8 f2				ld (os_current_i), hl 
31d1			 
31d1					if DEBUG_FORTH_WORDS 
31d1						DMARK "LPN" 
31d1 f5				push af  
31d2 3a e6 31			ld a, (.dmark)  
31d5 32 bd fb			ld (debug_mark),a  
31d8 3a e7 31			ld a, (.dmark+1)  
31db 32 be fb			ld (debug_mark+1),a  
31de 3a e8 31			ld a, (.dmark+2)  
31e1 32 bf fb			ld (debug_mark+2),a  
31e4 18 03			jr .pastdmark  
31e6 ..			.dmark: db "LPN"  
31e9 f1			.pastdmark: pop af  
31ea			endm  
# End of macro DMARK
31ea					CALLMONITOR 
31ea cd 1c 17			call break_point_state  
31ed				endm  
# End of macro CALLMONITOR
31ed					endif 
31ed					 
31ed				FORTH_LOOP_NEXT 
31ed cd d4 1e			call macro_forth_loop_next 
31f0				endm 
# End of macro FORTH_LOOP_NEXT
31f0			 
31f0			 
31f0					if DEBUG_FORTH_WORDS 
31f0 eb						ex de,hl 
31f1					endif 
31f1			 
31f1			;	; get DO ptr 
31f1			; 
31f1					if DEBUG_FORTH_WORDS 
31f1						DMARK "LP7" 
31f1 f5				push af  
31f2 3a 06 32			ld a, (.dmark)  
31f5 32 bd fb			ld (debug_mark),a  
31f8 3a 07 32			ld a, (.dmark+1)  
31fb 32 be fb			ld (debug_mark+1),a  
31fe 3a 08 32			ld a, (.dmark+2)  
3201 32 bf fb			ld (debug_mark+2),a  
3204 18 03			jr .pastdmark  
3206 ..			.dmark: db "LP7"  
3209 f1			.pastdmark: pop af  
320a			endm  
# End of macro DMARK
320a					CALLMONITOR 
320a cd 1c 17			call break_point_state  
320d				endm  
# End of macro CALLMONITOR
320d					endif 
320d				FORTH_RSP_TOS 
320d cd 6a 1c			call macro_forth_rsp_tos 
3210				endm 
# End of macro FORTH_RSP_TOS
3210			 
3210					if DEBUG_FORTH_WORDS 
3210						DMARK "LP8" 
3210 f5				push af  
3211 3a 25 32			ld a, (.dmark)  
3214 32 bd fb			ld (debug_mark),a  
3217 3a 26 32			ld a, (.dmark+1)  
321a 32 be fb			ld (debug_mark+1),a  
321d 3a 27 32			ld a, (.dmark+2)  
3220 32 bf fb			ld (debug_mark+2),a  
3223 18 03			jr .pastdmark  
3225 ..			.dmark: db "LP8"  
3228 f1			.pastdmark: pop af  
3229			endm  
# End of macro DMARK
3229					CALLMONITOR 
3229 cd 1c 17			call break_point_state  
322c				endm  
# End of macro CALLMONITOR
322c					endif 
322c				;push hl 
322c			 
322c				; not going to DO any more 
322c				; get rid of the RSP pointer as DO will add it back in 
322c				;FORTH_RSP_POP 
322c				;pop hl 
322c			 
322c				;ld hl,(cli_ret_sp) 
322c				;ld e, (hl) 
322c				;inc hl 
322c				;ld d, (hl) 
322c				;ex de,hl 
322c 22 a4 f2			ld (os_tok_ptr), hl 
322f					if DEBUG_FORTH_WORDS 
322f						DMARK "LP<" 
322f f5				push af  
3230 3a 44 32			ld a, (.dmark)  
3233 32 bd fb			ld (debug_mark),a  
3236 3a 45 32			ld a, (.dmark+1)  
3239 32 be fb			ld (debug_mark+1),a  
323c 3a 46 32			ld a, (.dmark+2)  
323f 32 bf fb			ld (debug_mark+2),a  
3242 18 03			jr .pastdmark  
3244 ..			.dmark: db "LP<"  
3247 f1			.pastdmark: pop af  
3248			endm  
# End of macro DMARK
3248					CALLMONITOR 
3248 cd 1c 17			call break_point_state  
324b				endm  
# End of macro CALLMONITOR
324b				endif 
324b c3 a6 20			jp exec1 
324e			 
324e					 
324e			 
324e			 
324e					NEXTW 
324e c3 15 20			jp macro_next 
3251				endm 
# End of macro NEXTW
3251			.I:  
3251			 
3251				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3251 5e				db WORD_SYS_CORE+74             
3252 7c 32			dw .DLOOP            
3254 02				db 1 + 1 
3255 .. 00			db "I",0              
3257				endm 
# End of macro CWHEAD
3257			; | I ( -- ) Current loop counter | DONE 
3257					if DEBUG_FORTH_WORDS_KEY 
3257						DMARK "I.." 
3257 f5				push af  
3258 3a 6c 32			ld a, (.dmark)  
325b 32 bd fb			ld (debug_mark),a  
325e 3a 6d 32			ld a, (.dmark+1)  
3261 32 be fb			ld (debug_mark+1),a  
3264 3a 6e 32			ld a, (.dmark+2)  
3267 32 bf fb			ld (debug_mark+2),a  
326a 18 03			jr .pastdmark  
326c ..			.dmark: db "I.."  
326f f1			.pastdmark: pop af  
3270			endm  
# End of macro DMARK
3270						CALLMONITOR 
3270 cd 1c 17			call break_point_state  
3273				endm  
# End of macro CALLMONITOR
3273					endif 
3273			 
3273 2a c8 f2				ld hl,(os_current_i) 
3276 cd ac 1c				call forth_push_numhl 
3279			 
3279					NEXTW 
3279 c3 15 20			jp macro_next 
327c				endm 
# End of macro NEXTW
327c			.DLOOP: 
327c				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
327c 5f				db WORD_SYS_CORE+75             
327d 5d 33			dw .REPEAT            
327f 06				db 5 + 1 
3280 .. 00			db "-LOOP",0              
3286				endm 
# End of macro CWHEAD
3286			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3286				; pop tos as current loop count to hl 
3286					if DEBUG_FORTH_WORDS_KEY 
3286						DMARK "-LP" 
3286 f5				push af  
3287 3a 9b 32			ld a, (.dmark)  
328a 32 bd fb			ld (debug_mark),a  
328d 3a 9c 32			ld a, (.dmark+1)  
3290 32 be fb			ld (debug_mark+1),a  
3293 3a 9d 32			ld a, (.dmark+2)  
3296 32 bf fb			ld (debug_mark+2),a  
3299 18 03			jr .pastdmark  
329b ..			.dmark: db "-LP"  
329e f1			.pastdmark: pop af  
329f			endm  
# End of macro DMARK
329f						CALLMONITOR 
329f cd 1c 17			call break_point_state  
32a2				endm  
# End of macro CALLMONITOR
32a2					endif 
32a2			 
32a2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32a2			 
32a2				FORTH_LOOP_TOS 
32a2 cd 07 1f			call macro_forth_loop_tos 
32a5				endm 
# End of macro FORTH_LOOP_TOS
32a5 e5				push hl 
32a6			 
32a6					if DEBUG_FORTH_WORDS 
32a6						DMARK "-LP" 
32a6 f5				push af  
32a7 3a bb 32			ld a, (.dmark)  
32aa 32 bd fb			ld (debug_mark),a  
32ad 3a bc 32			ld a, (.dmark+1)  
32b0 32 be fb			ld (debug_mark+1),a  
32b3 3a bd 32			ld a, (.dmark+2)  
32b6 32 bf fb			ld (debug_mark+2),a  
32b9 18 03			jr .pastdmark  
32bb ..			.dmark: db "-LP"  
32be f1			.pastdmark: pop af  
32bf			endm  
# End of macro DMARK
32bf						CALLMONITOR 
32bf cd 1c 17			call break_point_state  
32c2				endm  
# End of macro CALLMONITOR
32c2					endif 
32c2				; next item on the stack is the limit. get it 
32c2			 
32c2			 
32c2				FORTH_LOOP_POP 
32c2 cd 11 1f			call macro_forth_loop_pop 
32c5				endm 
# End of macro FORTH_LOOP_POP
32c5			 
32c5				FORTH_LOOP_TOS 
32c5 cd 07 1f			call macro_forth_loop_tos 
32c8				endm 
# End of macro FORTH_LOOP_TOS
32c8			 
32c8 d1				pop de		 ; de = i, hl = limit 
32c9			 
32c9					if DEBUG_FORTH_WORDS 
32c9						DMARK "-L1" 
32c9 f5				push af  
32ca 3a de 32			ld a, (.dmark)  
32cd 32 bd fb			ld (debug_mark),a  
32d0 3a df 32			ld a, (.dmark+1)  
32d3 32 be fb			ld (debug_mark+1),a  
32d6 3a e0 32			ld a, (.dmark+2)  
32d9 32 bf fb			ld (debug_mark+2),a  
32dc 18 03			jr .pastdmark  
32de ..			.dmark: db "-L1"  
32e1 f1			.pastdmark: pop af  
32e2			endm  
# End of macro DMARK
32e2						CALLMONITOR 
32e2 cd 1c 17			call break_point_state  
32e5				endm  
# End of macro CALLMONITOR
32e5					endif 
32e5			 
32e5				; go back to previous word 
32e5			 
32e5 d5				push de    ; save I for inc later 
32e6			 
32e6			 
32e6				; get limit 
32e6				;  is I at limit? 
32e6			 
32e6			 
32e6					if DEBUG_FORTH_WORDS 
32e6						DMARK "-L1" 
32e6 f5				push af  
32e7 3a fb 32			ld a, (.dmark)  
32ea 32 bd fb			ld (debug_mark),a  
32ed 3a fc 32			ld a, (.dmark+1)  
32f0 32 be fb			ld (debug_mark+1),a  
32f3 3a fd 32			ld a, (.dmark+2)  
32f6 32 bf fb			ld (debug_mark+2),a  
32f9 18 03			jr .pastdmark  
32fb ..			.dmark: db "-L1"  
32fe f1			.pastdmark: pop af  
32ff			endm  
# End of macro DMARK
32ff						CALLMONITOR 
32ff cd 1c 17			call break_point_state  
3302				endm  
# End of macro CALLMONITOR
3302					endif 
3302			 
3302 ed 52			sbc hl, de 
3304			 
3304			 
3304				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3304			 
3304 20 26				jr nz, .mloopnotdone 
3306			 
3306 e1				pop hl   ; get rid of saved I 
3307				FORTH_LOOP_POP     ; get rid of limit 
3307 cd 11 1f			call macro_forth_loop_pop 
330a				endm 
# End of macro FORTH_LOOP_POP
330a			 
330a				FORTH_RSP_POP     ; get rid of DO ptr 
330a cd 74 1c			call macro_forth_rsp_pop 
330d				endm 
# End of macro FORTH_RSP_POP
330d			 
330d			if DEBUG_FORTH_WORDS 
330d						DMARK "-L>" 
330d f5				push af  
330e 3a 22 33			ld a, (.dmark)  
3311 32 bd fb			ld (debug_mark),a  
3314 3a 23 33			ld a, (.dmark+1)  
3317 32 be fb			ld (debug_mark+1),a  
331a 3a 24 33			ld a, (.dmark+2)  
331d 32 bf fb			ld (debug_mark+2),a  
3320 18 03			jr .pastdmark  
3322 ..			.dmark: db "-L>"  
3325 f1			.pastdmark: pop af  
3326			endm  
# End of macro DMARK
3326				CALLMONITOR 
3326 cd 1c 17			call break_point_state  
3329				endm  
# End of macro CALLMONITOR
3329			endif 
3329			 
3329					NEXTW 
3329 c3 15 20			jp macro_next 
332c				endm 
# End of macro NEXTW
332c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
332c			 
332c			.mloopnotdone: 
332c			 
332c e1				pop hl    ; get I 
332d 2b				dec hl 
332e			 
332e			   	; save new I 
332e			 
332e			 
332e					; set I counter 
332e			 
332e 22 c8 f2				ld (os_current_i), hl 
3331			 
3331					 
3331				FORTH_LOOP_NEXT 
3331 cd d4 1e			call macro_forth_loop_next 
3334				endm 
# End of macro FORTH_LOOP_NEXT
3334			 
3334			 
3334					if DEBUG_FORTH_WORDS 
3334 eb						ex de,hl 
3335					endif 
3335			 
3335			;	; get DO ptr 
3335			; 
3335				FORTH_RSP_TOS 
3335 cd 6a 1c			call macro_forth_rsp_tos 
3338				endm 
# End of macro FORTH_RSP_TOS
3338			 
3338				;push hl 
3338			 
3338				; not going to DO any more 
3338				; get rid of the RSP pointer as DO will add it back in 
3338				;FORTH_RSP_POP 
3338				;pop hl 
3338			 
3338			 
3338 22 a4 f2			ld (os_tok_ptr), hl 
333b					if DEBUG_FORTH_WORDS 
333b						DMARK "-L<" 
333b f5				push af  
333c 3a 50 33			ld a, (.dmark)  
333f 32 bd fb			ld (debug_mark),a  
3342 3a 51 33			ld a, (.dmark+1)  
3345 32 be fb			ld (debug_mark+1),a  
3348 3a 52 33			ld a, (.dmark+2)  
334b 32 bf fb			ld (debug_mark+2),a  
334e 18 03			jr .pastdmark  
3350 ..			.dmark: db "-L<"  
3353 f1			.pastdmark: pop af  
3354			endm  
# End of macro DMARK
3354					CALLMONITOR 
3354 cd 1c 17			call break_point_state  
3357				endm  
# End of macro CALLMONITOR
3357				endif 
3357 c3 a6 20			jp exec1 
335a			 
335a					 
335a			 
335a			 
335a			 
335a				NEXTW 
335a c3 15 20			jp macro_next 
335d				endm 
# End of macro NEXTW
335d			 
335d			 
335d			 
335d			 
335d			.REPEAT: 
335d				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
335d 71				db WORD_SYS_CORE+93             
335e b0 33			dw .UNTIL            
3360 06				db 5 + 1 
3361 .. 00			db "REPEAT",0              
3368				endm 
# End of macro CWHEAD
3368			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3368			;  push pc to rsp stack past the REPEAT 
3368					if DEBUG_FORTH_WORDS_KEY 
3368						DMARK "REP" 
3368 f5				push af  
3369 3a 7d 33			ld a, (.dmark)  
336c 32 bd fb			ld (debug_mark),a  
336f 3a 7e 33			ld a, (.dmark+1)  
3372 32 be fb			ld (debug_mark+1),a  
3375 3a 7f 33			ld a, (.dmark+2)  
3378 32 bf fb			ld (debug_mark+2),a  
337b 18 03			jr .pastdmark  
337d ..			.dmark: db "REP"  
3380 f1			.pastdmark: pop af  
3381			endm  
# End of macro DMARK
3381						CALLMONITOR 
3381 cd 1c 17			call break_point_state  
3384				endm  
# End of macro CALLMONITOR
3384					endif 
3384			 
3384 2a a4 f2				ld hl, (os_tok_ptr) 
3387 23					inc hl   ; R 
3388 23					inc hl  ; E 
3389 23					inc hl   ; P 
338a 23					inc hl   ; E 
338b 23					inc hl   ; A 
338c 23					inc hl   ; T 
338d 23					inc hl   ; zero 
338e					FORTH_RSP_NEXT 
338e cd 53 1c			call macro_forth_rsp_next 
3391				endm 
# End of macro FORTH_RSP_NEXT
3391			 
3391			 
3391					if DEBUG_FORTH_WORDS 
3391						DMARK "REP" 
3391 f5				push af  
3392 3a a6 33			ld a, (.dmark)  
3395 32 bd fb			ld (debug_mark),a  
3398 3a a7 33			ld a, (.dmark+1)  
339b 32 be fb			ld (debug_mark+1),a  
339e 3a a8 33			ld a, (.dmark+2)  
33a1 32 bf fb			ld (debug_mark+2),a  
33a4 18 03			jr .pastdmark  
33a6 ..			.dmark: db "REP"  
33a9 f1			.pastdmark: pop af  
33aa			endm  
# End of macro DMARK
33aa						;pop bc    ; TODO BUG ?????? what is this for???? 
33aa						CALLMONITOR 
33aa cd 1c 17			call break_point_state  
33ad				endm  
# End of macro CALLMONITOR
33ad					endif 
33ad			 
33ad					NEXTW 
33ad c3 15 20			jp macro_next 
33b0				endm 
# End of macro NEXTW
33b0			;	       NEXTW 
33b0			 
33b0			.UNTIL: 
33b0				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33b0 72				db WORD_SYS_CORE+94             
33b1 47 34			dw .ENDFLOW            
33b3 06				db 5 + 1 
33b4 .. 00			db "UNTIL",0              
33ba				endm 
# End of macro CWHEAD
33ba			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33ba			 
33ba				; pop tos as check 
33ba			 
33ba				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33ba			 
33ba				FORTH_DSP_VALUEHL 
33ba cd a3 1e			call macro_dsp_valuehl 
33bd				endm 
# End of macro FORTH_DSP_VALUEHL
33bd			 
33bd					if DEBUG_FORTH_WORDS_KEY 
33bd						DMARK "UNT" 
33bd f5				push af  
33be 3a d2 33			ld a, (.dmark)  
33c1 32 bd fb			ld (debug_mark),a  
33c4 3a d3 33			ld a, (.dmark+1)  
33c7 32 be fb			ld (debug_mark+1),a  
33ca 3a d4 33			ld a, (.dmark+2)  
33cd 32 bf fb			ld (debug_mark+2),a  
33d0 18 03			jr .pastdmark  
33d2 ..			.dmark: db "UNT"  
33d5 f1			.pastdmark: pop af  
33d6			endm  
# End of macro DMARK
33d6						CALLMONITOR 
33d6 cd 1c 17			call break_point_state  
33d9				endm  
# End of macro CALLMONITOR
33d9					endif 
33d9			 
33d9			;	push hl 
33d9				FORTH_DSP_POP 
33d9 cd 5b 1f			call macro_forth_dsp_pop 
33dc				endm 
# End of macro FORTH_DSP_POP
33dc			 
33dc			;	pop hl 
33dc			 
33dc				; test if true 
33dc			 
33dc cd 32 0d			call ishlzero 
33df			;	ld a,l 
33df			;	add h 
33df			; 
33df			;	cp 0 
33df			 
33df 20 3e			jr nz, .untilnotdone 
33e1			 
33e1					if DEBUG_FORTH_WORDS 
33e1						DMARK "UNf" 
33e1 f5				push af  
33e2 3a f6 33			ld a, (.dmark)  
33e5 32 bd fb			ld (debug_mark),a  
33e8 3a f7 33			ld a, (.dmark+1)  
33eb 32 be fb			ld (debug_mark+1),a  
33ee 3a f8 33			ld a, (.dmark+2)  
33f1 32 bf fb			ld (debug_mark+2),a  
33f4 18 03			jr .pastdmark  
33f6 ..			.dmark: db "UNf"  
33f9 f1			.pastdmark: pop af  
33fa			endm  
# End of macro DMARK
33fa						CALLMONITOR 
33fa cd 1c 17			call break_point_state  
33fd				endm  
# End of macro CALLMONITOR
33fd					endif 
33fd			 
33fd			 
33fd			 
33fd				FORTH_RSP_POP     ; get rid of DO ptr 
33fd cd 74 1c			call macro_forth_rsp_pop 
3400				endm 
# End of macro FORTH_RSP_POP
3400			 
3400			if DEBUG_FORTH_WORDS 
3400						DMARK "UN>" 
3400 f5				push af  
3401 3a 15 34			ld a, (.dmark)  
3404 32 bd fb			ld (debug_mark),a  
3407 3a 16 34			ld a, (.dmark+1)  
340a 32 be fb			ld (debug_mark+1),a  
340d 3a 17 34			ld a, (.dmark+2)  
3410 32 bf fb			ld (debug_mark+2),a  
3413 18 03			jr .pastdmark  
3415 ..			.dmark: db "UN>"  
3418 f1			.pastdmark: pop af  
3419			endm  
# End of macro DMARK
3419				CALLMONITOR 
3419 cd 1c 17			call break_point_state  
341c				endm  
# End of macro CALLMONITOR
341c			endif 
341c			 
341c					NEXTW 
341c c3 15 20			jp macro_next 
341f				endm 
# End of macro NEXTW
341f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
341f			 
341f			.untilnotdone: 
341f			 
341f			 
341f			;	; get DO ptr 
341f			; 
341f				FORTH_RSP_TOS 
341f cd 6a 1c			call macro_forth_rsp_tos 
3422				endm 
# End of macro FORTH_RSP_TOS
3422			 
3422				;push hl 
3422			 
3422				; not going to DO any more 
3422				; get rid of the RSP pointer as DO will add it back in 
3422				;FORTH_RSP_POP 
3422				;pop hl 
3422			 
3422			 
3422 22 a4 f2			ld (os_tok_ptr), hl 
3425					if DEBUG_FORTH_WORDS 
3425						DMARK "UN<" 
3425 f5				push af  
3426 3a 3a 34			ld a, (.dmark)  
3429 32 bd fb			ld (debug_mark),a  
342c 3a 3b 34			ld a, (.dmark+1)  
342f 32 be fb			ld (debug_mark+1),a  
3432 3a 3c 34			ld a, (.dmark+2)  
3435 32 bf fb			ld (debug_mark+2),a  
3438 18 03			jr .pastdmark  
343a ..			.dmark: db "UN<"  
343d f1			.pastdmark: pop af  
343e			endm  
# End of macro DMARK
343e					CALLMONITOR 
343e cd 1c 17			call break_point_state  
3441				endm  
# End of macro CALLMONITOR
3441				endif 
3441 c3 a6 20			jp exec1 
3444			 
3444					 
3444			 
3444			 
3444					NEXTW 
3444 c3 15 20			jp macro_next 
3447				endm 
# End of macro NEXTW
3447			 
3447			 
3447			.ENDFLOW: 
3447			 
3447			; eof 
3447			 
# End of file forth_words_flow.asm
3447			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3447			include "forth_words_logic.asm" 
3447			 
3447			; | ## Logic Words 
3447			 
3447			.NOT: 
3447				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3447 2d				db WORD_SYS_CORE+25             
3448 8f 34			dw .IS            
344a 04				db 3 + 1 
344b .. 00			db "NOT",0              
344f				endm 
# End of macro CWHEAD
344f			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
344f					if DEBUG_FORTH_WORDS_KEY 
344f						DMARK "NOT" 
344f f5				push af  
3450 3a 64 34			ld a, (.dmark)  
3453 32 bd fb			ld (debug_mark),a  
3456 3a 65 34			ld a, (.dmark+1)  
3459 32 be fb			ld (debug_mark+1),a  
345c 3a 66 34			ld a, (.dmark+2)  
345f 32 bf fb			ld (debug_mark+2),a  
3462 18 03			jr .pastdmark  
3464 ..			.dmark: db "NOT"  
3467 f1			.pastdmark: pop af  
3468			endm  
# End of macro DMARK
3468						CALLMONITOR 
3468 cd 1c 17			call break_point_state  
346b				endm  
# End of macro CALLMONITOR
346b					endif 
346b					FORTH_DSP 
346b cd 69 1e			call macro_forth_dsp 
346e				endm 
# End of macro FORTH_DSP
346e 7e					ld a,(hl)	; get type of value on TOS 
346f fe 02				cp DS_TYPE_INUM  
3471 28 03				jr z, .noti 
3473					NEXTW 
3473 c3 15 20			jp macro_next 
3476				endm 
# End of macro NEXTW
3476			.noti:          FORTH_DSP_VALUEHL 
3476 cd a3 1e			call macro_dsp_valuehl 
3479				endm 
# End of macro FORTH_DSP_VALUEHL
3479			;		push hl 
3479					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3479 cd 5b 1f			call macro_forth_dsp_pop 
347c				endm 
# End of macro FORTH_DSP_POP
347c			;		pop hl 
347c 3e 00				ld a,0 
347e bd					cp l 
347f 28 04				jr z, .not2t 
3481 2e 00				ld l, 0 
3483 18 02				jr .notip 
3485			 
3485 2e ff		.not2t:		ld l, 255 
3487			 
3487 26 00		.notip:		ld h, 0	 
3489			 
3489 cd ac 1c				call forth_push_numhl 
348c					NEXTW 
348c c3 15 20			jp macro_next 
348f				endm 
# End of macro NEXTW
348f			 
348f			.IS: 
348f				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
348f 2d				db WORD_SYS_CORE+25             
3490 b5 34			dw .LZERO            
3492 03				db 2 + 1 
3493 .. 00			db "IS",0              
3496				endm 
# End of macro CWHEAD
3496			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3496					if DEBUG_FORTH_WORDS_KEY 
3496						DMARK "IS." 
3496 f5				push af  
3497 3a ab 34			ld a, (.dmark)  
349a 32 bd fb			ld (debug_mark),a  
349d 3a ac 34			ld a, (.dmark+1)  
34a0 32 be fb			ld (debug_mark+1),a  
34a3 3a ad 34			ld a, (.dmark+2)  
34a6 32 bf fb			ld (debug_mark+2),a  
34a9 18 03			jr .pastdmark  
34ab ..			.dmark: db "IS."  
34ae f1			.pastdmark: pop af  
34af			endm  
# End of macro DMARK
34af						CALLMONITOR 
34af cd 1c 17			call break_point_state  
34b2				endm  
# End of macro CALLMONITOR
34b2					endif 
34b2					NEXTW 
34b2 c3 15 20			jp macro_next 
34b5				endm 
# End of macro NEXTW
34b5			.LZERO: 
34b5				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34b5 2d				db WORD_SYS_CORE+25             
34b6 bf 34			dw .TZERO            
34b8 03				db 2 + 1 
34b9 .. 00			db "0<",0              
34bc				endm 
# End of macro CWHEAD
34bc			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34bc					NEXTW 
34bc c3 15 20			jp macro_next 
34bf				endm 
# End of macro NEXTW
34bf			.TZERO: 
34bf				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34bf 2e				db WORD_SYS_CORE+26             
34c0 06 35			dw .LESS            
34c2 03				db 2 + 1 
34c3 .. 00			db "0=",0              
34c6				endm 
# End of macro CWHEAD
34c6			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34c6				; TODO add floating point number detection 
34c6					;v5 FORTH_DSP_VALUE 
34c6					if DEBUG_FORTH_WORDS_KEY 
34c6						DMARK "0=." 
34c6 f5				push af  
34c7 3a db 34			ld a, (.dmark)  
34ca 32 bd fb			ld (debug_mark),a  
34cd 3a dc 34			ld a, (.dmark+1)  
34d0 32 be fb			ld (debug_mark+1),a  
34d3 3a dd 34			ld a, (.dmark+2)  
34d6 32 bf fb			ld (debug_mark+2),a  
34d9 18 03			jr .pastdmark  
34db ..			.dmark: db "0=."  
34de f1			.pastdmark: pop af  
34df			endm  
# End of macro DMARK
34df						CALLMONITOR 
34df cd 1c 17			call break_point_state  
34e2				endm  
# End of macro CALLMONITOR
34e2					endif 
34e2					FORTH_DSP 
34e2 cd 69 1e			call macro_forth_dsp 
34e5				endm 
# End of macro FORTH_DSP
34e5 7e					ld a,(hl)	; get type of value on TOS 
34e6 fe 02				cp DS_TYPE_INUM  
34e8 28 00				jr z, .tz_inum 
34ea			 
34ea				if FORTH_ENABLE_FLOATMATH 
34ea					jr .tz_done 
34ea			 
34ea				endif 
34ea					 
34ea			 
34ea			.tz_inum: 
34ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34ea cd a3 1e			call macro_dsp_valuehl 
34ed				endm 
# End of macro FORTH_DSP_VALUEHL
34ed			 
34ed			;		push hl 
34ed			 
34ed					; destroy value TOS 
34ed			 
34ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34ed cd 5b 1f			call macro_forth_dsp_pop 
34f0				endm 
# End of macro FORTH_DSP_POP
34f0			 
34f0			;		pop hl 
34f0			 
34f0 3e 00				ld a,0 
34f2			 
34f2 bd					cp l 
34f3 20 08				jr nz, .tz_notzero 
34f5			 
34f5 bc					cp h 
34f6			 
34f6 20 05				jr nz, .tz_notzero 
34f8			 
34f8			 
34f8 21 01 00				ld hl, FORTH_TRUE 
34fb 18 03				jr .tz_done 
34fd			 
34fd 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3500			 
3500					; push value back onto stack for another op etc 
3500			 
3500			.tz_done: 
3500 cd ac 1c				call forth_push_numhl 
3503			 
3503					NEXTW 
3503 c3 15 20			jp macro_next 
3506				endm 
# End of macro NEXTW
3506			.LESS: 
3506				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3506 2f				db WORD_SYS_CORE+27             
3507 6f 35			dw .GT            
3509 02				db 1 + 1 
350a .. 00			db "<",0              
350c				endm 
# End of macro CWHEAD
350c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
350c				; TODO add floating point number detection 
350c					if DEBUG_FORTH_WORDS_KEY 
350c						DMARK "LES" 
350c f5				push af  
350d 3a 21 35			ld a, (.dmark)  
3510 32 bd fb			ld (debug_mark),a  
3513 3a 22 35			ld a, (.dmark+1)  
3516 32 be fb			ld (debug_mark+1),a  
3519 3a 23 35			ld a, (.dmark+2)  
351c 32 bf fb			ld (debug_mark+2),a  
351f 18 03			jr .pastdmark  
3521 ..			.dmark: db "LES"  
3524 f1			.pastdmark: pop af  
3525			endm  
# End of macro DMARK
3525						CALLMONITOR 
3525 cd 1c 17			call break_point_state  
3528				endm  
# End of macro CALLMONITOR
3528					endif 
3528					FORTH_DSP 
3528 cd 69 1e			call macro_forth_dsp 
352b				endm 
# End of macro FORTH_DSP
352b					;v5 FORTH_DSP_VALUE 
352b 7e					ld a,(hl)	; get type of value on TOS 
352c fe 02				cp DS_TYPE_INUM  
352e 28 00				jr z, .less_inum 
3530			 
3530				if FORTH_ENABLE_FLOATMATH 
3530					jr .less_done 
3530			 
3530				endif 
3530					 
3530			 
3530			.less_inum: 
3530					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3530 cd a3 1e			call macro_dsp_valuehl 
3533				endm 
# End of macro FORTH_DSP_VALUEHL
3533			 
3533 e5					push hl  ; u2 
3534			 
3534					; destroy value TOS 
3534			 
3534					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3534 cd 5b 1f			call macro_forth_dsp_pop 
3537				endm 
# End of macro FORTH_DSP_POP
3537			 
3537			 
3537					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3537 cd a3 1e			call macro_dsp_valuehl 
353a				endm 
# End of macro FORTH_DSP_VALUEHL
353a			 
353a e5					push hl    ; u1 
353b			 
353b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
353b cd 5b 1f			call macro_forth_dsp_pop 
353e				endm 
# End of macro FORTH_DSP_POP
353e			 
353e			 
353e b7			 or a      ;clear carry flag 
353f 01 00 00		 ld bc, FORTH_FALSE 
3542 e1			  pop hl    ; u1 
3543 d1			  pop de    ; u2 
3544 ed 52		  sbc hl,de 
3546 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3548			 
3548 01 01 00		 ld bc, FORTH_TRUE 
354b			.lscont:  
354b c5					push bc 
354c e1					pop hl 
354d			 
354d					if DEBUG_FORTH_WORDS 
354d						DMARK "LT1" 
354d f5				push af  
354e 3a 62 35			ld a, (.dmark)  
3551 32 bd fb			ld (debug_mark),a  
3554 3a 63 35			ld a, (.dmark+1)  
3557 32 be fb			ld (debug_mark+1),a  
355a 3a 64 35			ld a, (.dmark+2)  
355d 32 bf fb			ld (debug_mark+2),a  
3560 18 03			jr .pastdmark  
3562 ..			.dmark: db "LT1"  
3565 f1			.pastdmark: pop af  
3566			endm  
# End of macro DMARK
3566						CALLMONITOR 
3566 cd 1c 17			call break_point_state  
3569				endm  
# End of macro CALLMONITOR
3569					endif 
3569 cd ac 1c				call forth_push_numhl 
356c			 
356c					NEXTW 
356c c3 15 20			jp macro_next 
356f				endm 
# End of macro NEXTW
356f			.GT: 
356f				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
356f 30				db WORD_SYS_CORE+28             
3570 d8 35			dw .EQUAL            
3572 02				db 1 + 1 
3573 .. 00			db ">",0              
3575				endm 
# End of macro CWHEAD
3575			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3575				; TODO add floating point number detection 
3575					if DEBUG_FORTH_WORDS_KEY 
3575						DMARK "GRT" 
3575 f5				push af  
3576 3a 8a 35			ld a, (.dmark)  
3579 32 bd fb			ld (debug_mark),a  
357c 3a 8b 35			ld a, (.dmark+1)  
357f 32 be fb			ld (debug_mark+1),a  
3582 3a 8c 35			ld a, (.dmark+2)  
3585 32 bf fb			ld (debug_mark+2),a  
3588 18 03			jr .pastdmark  
358a ..			.dmark: db "GRT"  
358d f1			.pastdmark: pop af  
358e			endm  
# End of macro DMARK
358e						CALLMONITOR 
358e cd 1c 17			call break_point_state  
3591				endm  
# End of macro CALLMONITOR
3591					endif 
3591					FORTH_DSP 
3591 cd 69 1e			call macro_forth_dsp 
3594				endm 
# End of macro FORTH_DSP
3594					;FORTH_DSP_VALUE 
3594 7e					ld a,(hl)	; get type of value on TOS 
3595 fe 02				cp DS_TYPE_INUM  
3597 28 00				jr z, .gt_inum 
3599			 
3599				if FORTH_ENABLE_FLOATMATH 
3599					jr .gt_done 
3599			 
3599				endif 
3599					 
3599			 
3599			.gt_inum: 
3599					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3599 cd a3 1e			call macro_dsp_valuehl 
359c				endm 
# End of macro FORTH_DSP_VALUEHL
359c			 
359c e5					push hl  ; u2 
359d			 
359d					; destroy value TOS 
359d			 
359d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359d cd 5b 1f			call macro_forth_dsp_pop 
35a0				endm 
# End of macro FORTH_DSP_POP
35a0			 
35a0			 
35a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a0 cd a3 1e			call macro_dsp_valuehl 
35a3				endm 
# End of macro FORTH_DSP_VALUEHL
35a3			 
35a3 e5					push hl    ; u1 
35a4			 
35a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a4 cd 5b 1f			call macro_forth_dsp_pop 
35a7				endm 
# End of macro FORTH_DSP_POP
35a7			 
35a7			 
35a7 b7			 or a      ;clear carry flag 
35a8 01 00 00		 ld bc, FORTH_FALSE 
35ab e1			  pop hl    ; u1 
35ac d1			  pop de    ; u2 
35ad ed 52		  sbc hl,de 
35af 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35b1			 
35b1 01 01 00		 ld bc, FORTH_TRUE 
35b4			.gtcont:  
35b4 c5					push bc 
35b5 e1					pop hl 
35b6			 
35b6					if DEBUG_FORTH_WORDS 
35b6						DMARK "GT1" 
35b6 f5				push af  
35b7 3a cb 35			ld a, (.dmark)  
35ba 32 bd fb			ld (debug_mark),a  
35bd 3a cc 35			ld a, (.dmark+1)  
35c0 32 be fb			ld (debug_mark+1),a  
35c3 3a cd 35			ld a, (.dmark+2)  
35c6 32 bf fb			ld (debug_mark+2),a  
35c9 18 03			jr .pastdmark  
35cb ..			.dmark: db "GT1"  
35ce f1			.pastdmark: pop af  
35cf			endm  
# End of macro DMARK
35cf						CALLMONITOR 
35cf cd 1c 17			call break_point_state  
35d2				endm  
# End of macro CALLMONITOR
35d2					endif 
35d2 cd ac 1c				call forth_push_numhl 
35d5			 
35d5					NEXTW 
35d5 c3 15 20			jp macro_next 
35d8				endm 
# End of macro NEXTW
35d8			.EQUAL: 
35d8				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35d8 31				db WORD_SYS_CORE+29             
35d9 43 36			dw .ENDLOGIC            
35db 02				db 1 + 1 
35dc .. 00			db "=",0              
35de				endm 
# End of macro CWHEAD
35de			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35de				; TODO add floating point number detection 
35de					if DEBUG_FORTH_WORDS_KEY 
35de						DMARK "EQ." 
35de f5				push af  
35df 3a f3 35			ld a, (.dmark)  
35e2 32 bd fb			ld (debug_mark),a  
35e5 3a f4 35			ld a, (.dmark+1)  
35e8 32 be fb			ld (debug_mark+1),a  
35eb 3a f5 35			ld a, (.dmark+2)  
35ee 32 bf fb			ld (debug_mark+2),a  
35f1 18 03			jr .pastdmark  
35f3 ..			.dmark: db "EQ."  
35f6 f1			.pastdmark: pop af  
35f7			endm  
# End of macro DMARK
35f7						CALLMONITOR 
35f7 cd 1c 17			call break_point_state  
35fa				endm  
# End of macro CALLMONITOR
35fa					endif 
35fa					FORTH_DSP 
35fa cd 69 1e			call macro_forth_dsp 
35fd				endm 
# End of macro FORTH_DSP
35fd					;v5 FORTH_DSP_VALUE 
35fd 7e					ld a,(hl)	; get type of value on TOS 
35fe fe 02				cp DS_TYPE_INUM  
3600 28 00				jr z, .eq_inum 
3602			 
3602				if FORTH_ENABLE_FLOATMATH 
3602					jr .eq_done 
3602			 
3602				endif 
3602					 
3602			 
3602			.eq_inum: 
3602					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3602 cd a3 1e			call macro_dsp_valuehl 
3605				endm 
# End of macro FORTH_DSP_VALUEHL
3605			 
3605 e5					push hl 
3606			 
3606					; destroy value TOS 
3606			 
3606					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3606 cd 5b 1f			call macro_forth_dsp_pop 
3609				endm 
# End of macro FORTH_DSP_POP
3609			 
3609			 
3609					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3609 cd a3 1e			call macro_dsp_valuehl 
360c				endm 
# End of macro FORTH_DSP_VALUEHL
360c			 
360c					; one value on hl get other one back 
360c			 
360c e5					push hl 
360d			 
360d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360d cd 5b 1f			call macro_forth_dsp_pop 
3610				endm 
# End of macro FORTH_DSP_POP
3610			 
3610 0e 00				ld c, FORTH_FALSE 
3612			 
3612 e1					pop hl 
3613 d1					pop de 
3614			 
3614 7b					ld a, e 
3615 bd					cp l 
3616			 
3616 20 06				jr nz, .eq_done 
3618			 
3618 7a					ld a, d 
3619 bc					cp h 
361a			 
361a 20 02				jr nz, .eq_done 
361c			 
361c 0e 01				ld c, FORTH_TRUE 
361e					 
361e			 
361e			 
361e			.eq_done: 
361e			 
361e					; TODO push value back onto stack for another op etc 
361e			 
361e 26 00				ld h, 0 
3620 69					ld l, c 
3621					if DEBUG_FORTH_WORDS 
3621						DMARK "EQ1" 
3621 f5				push af  
3622 3a 36 36			ld a, (.dmark)  
3625 32 bd fb			ld (debug_mark),a  
3628 3a 37 36			ld a, (.dmark+1)  
362b 32 be fb			ld (debug_mark+1),a  
362e 3a 38 36			ld a, (.dmark+2)  
3631 32 bf fb			ld (debug_mark+2),a  
3634 18 03			jr .pastdmark  
3636 ..			.dmark: db "EQ1"  
3639 f1			.pastdmark: pop af  
363a			endm  
# End of macro DMARK
363a						CALLMONITOR 
363a cd 1c 17			call break_point_state  
363d				endm  
# End of macro CALLMONITOR
363d					endif 
363d cd ac 1c				call forth_push_numhl 
3640			 
3640					NEXTW 
3640 c3 15 20			jp macro_next 
3643				endm 
# End of macro NEXTW
3643			 
3643			 
3643			.ENDLOGIC: 
3643			; eof 
3643			 
3643			 
# End of file forth_words_logic.asm
3643			include "forth_words_maths.asm" 
3643			 
3643			; | ## Maths Words 
3643			 
3643			.PLUS:	 
3643				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3643 15				db WORD_SYS_CORE+1             
3644 85 36			dw .NEG            
3646 02				db 1 + 1 
3647 .. 00			db "+",0              
3649				endm 
# End of macro CWHEAD
3649			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3649					if DEBUG_FORTH_WORDS_KEY 
3649						DMARK "PLU" 
3649 f5				push af  
364a 3a 5e 36			ld a, (.dmark)  
364d 32 bd fb			ld (debug_mark),a  
3650 3a 5f 36			ld a, (.dmark+1)  
3653 32 be fb			ld (debug_mark+1),a  
3656 3a 60 36			ld a, (.dmark+2)  
3659 32 bf fb			ld (debug_mark+2),a  
365c 18 03			jr .pastdmark  
365e ..			.dmark: db "PLU"  
3661 f1			.pastdmark: pop af  
3662			endm  
# End of macro DMARK
3662						CALLMONITOR 
3662 cd 1c 17			call break_point_state  
3665				endm  
# End of macro CALLMONITOR
3665					endif 
3665					; add top two values and push back result 
3665			 
3665					;for v5 FORTH_DSP_VALUE 
3665					FORTH_DSP 
3665 cd 69 1e			call macro_forth_dsp 
3668				endm 
# End of macro FORTH_DSP
3668 7e					ld a,(hl)	; get type of value on TOS 
3669 fe 02				cp DS_TYPE_INUM  
366b 28 03				jr z, .dot_inum 
366d			 
366d					NEXTW 
366d c3 15 20			jp macro_next 
3670				endm 
# End of macro NEXTW
3670			 
3670			; float maths 
3670			 
3670				if FORTH_ENABLE_FLOATMATH 
3670						inc hl      ; now at start of numeric as string 
3670			 
3670					if DEBUG_FORTH_MATHS 
3670						DMARK "ADD" 
3670				CALLMONITOR 
3670					endif 
3670			 
3670					;ld ix, hl 
3670					call CON 
3670			 
3670			 
3670					push hl 
3670					 
3670					 
3670			 
3670						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3670			 
3670					; get next number 
3670			 
3670						FORTH_DSP_VALUE 
3670			 
3670						inc hl      ; now at start of numeric as string 
3670			 
3670					;ld ix, hl 
3670					call CON 
3670			 
3670					push hl 
3670			 
3670			 
3670						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3670			 
3670						; TODO do add 
3670			 
3670						call IADD 
3670			 
3670						; TODO get result back as ascii 
3670			 
3670						; TODO push result  
3670			 
3670			 
3670			 
3670						jr .dot_done 
3670				endif 
3670			 
3670			.dot_inum: 
3670			 
3670			 
3670					if DEBUG_FORTH_DOT 
3670						DMARK "+IT" 
3670				CALLMONITOR 
3670					endif 
3670			 
3670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3670 cd a3 1e			call macro_dsp_valuehl 
3673				endm 
# End of macro FORTH_DSP_VALUEHL
3673			 
3673				; TODO add floating point number detection 
3673			 
3673 e5					push hl 
3674			 
3674					; destroy value TOS 
3674			 
3674					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3674 cd 5b 1f			call macro_forth_dsp_pop 
3677				endm 
# End of macro FORTH_DSP_POP
3677			 
3677			 
3677					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3677 cd a3 1e			call macro_dsp_valuehl 
367a				endm 
# End of macro FORTH_DSP_VALUEHL
367a			 
367a					; one value on hl get other one back 
367a			 
367a d1					pop de 
367b			 
367b					; do the add 
367b			 
367b 19					add hl,de 
367c			 
367c					; save it 
367c			 
367c			;		push hl	 
367c			 
367c					; 
367c			 
367c					; destroy value TOS 
367c			 
367c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
367c cd 5b 1f			call macro_forth_dsp_pop 
367f				endm 
# End of macro FORTH_DSP_POP
367f			 
367f					; TODO push value back onto stack for another op etc 
367f			 
367f			;		pop hl 
367f			 
367f			.dot_done: 
367f cd ac 1c				call forth_push_numhl 
3682			 
3682					NEXTW 
3682 c3 15 20			jp macro_next 
3685				endm 
# End of macro NEXTW
3685			.NEG: 
3685			 
3685				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3685 17				db WORD_SYS_CORE+3             
3686 c8 36			dw .DIV            
3688 02				db 1 + 1 
3689 .. 00			db "-",0              
368b				endm 
# End of macro CWHEAD
368b			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
368b					if DEBUG_FORTH_WORDS_KEY 
368b						DMARK "SUB" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 bd fb			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 be fb			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 bf fb			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "SUB"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4						CALLMONITOR 
36a4 cd 1c 17			call break_point_state  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7			 
36a7			 
36a7				; TODO add floating point number detection 
36a7					; v5 FORTH_DSP_VALUE 
36a7					FORTH_DSP 
36a7 cd 69 1e			call macro_forth_dsp 
36aa				endm 
# End of macro FORTH_DSP
36aa 7e					ld a,(hl)	; get type of value on TOS 
36ab fe 02				cp DS_TYPE_INUM  
36ad 28 03				jr z, .neg_inum 
36af			 
36af					NEXTW 
36af c3 15 20			jp macro_next 
36b2				endm 
# End of macro NEXTW
36b2			 
36b2			; float maths 
36b2			 
36b2				if FORTH_ENABLE_FLOATMATH 
36b2					jr .neg_done 
36b2			 
36b2				endif 
36b2					 
36b2			 
36b2			.neg_inum: 
36b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b2 cd a3 1e			call macro_dsp_valuehl 
36b5				endm 
# End of macro FORTH_DSP_VALUEHL
36b5			 
36b5 e5					push hl 
36b6			 
36b6					; destroy value TOS 
36b6			 
36b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b6 cd 5b 1f			call macro_forth_dsp_pop 
36b9				endm 
# End of macro FORTH_DSP_POP
36b9			 
36b9			 
36b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b9 cd a3 1e			call macro_dsp_valuehl 
36bc				endm 
# End of macro FORTH_DSP_VALUEHL
36bc			 
36bc					; one value on hl get other one back 
36bc			 
36bc d1					pop de 
36bd			 
36bd					; do the sub 
36bd			;		ex de, hl 
36bd			 
36bd ed 52				sbc hl,de 
36bf			 
36bf					; save it 
36bf			 
36bf			;		push hl	 
36bf			 
36bf					; 
36bf			 
36bf					; destroy value TOS 
36bf			 
36bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bf cd 5b 1f			call macro_forth_dsp_pop 
36c2				endm 
# End of macro FORTH_DSP_POP
36c2			 
36c2					; TODO push value back onto stack for another op etc 
36c2			 
36c2			;		pop hl 
36c2			 
36c2 cd ac 1c				call forth_push_numhl 
36c5			.neg_done: 
36c5			 
36c5					NEXTW 
36c5 c3 15 20			jp macro_next 
36c8				endm 
# End of macro NEXTW
36c8			.DIV: 
36c8				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36c8 18				db WORD_SYS_CORE+4             
36c9 15 37			dw .MUL            
36cb 02				db 1 + 1 
36cc .. 00			db "/",0              
36ce				endm 
# End of macro CWHEAD
36ce			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36ce					if DEBUG_FORTH_WORDS_KEY 
36ce						DMARK "DIV" 
36ce f5				push af  
36cf 3a e3 36			ld a, (.dmark)  
36d2 32 bd fb			ld (debug_mark),a  
36d5 3a e4 36			ld a, (.dmark+1)  
36d8 32 be fb			ld (debug_mark+1),a  
36db 3a e5 36			ld a, (.dmark+2)  
36de 32 bf fb			ld (debug_mark+2),a  
36e1 18 03			jr .pastdmark  
36e3 ..			.dmark: db "DIV"  
36e6 f1			.pastdmark: pop af  
36e7			endm  
# End of macro DMARK
36e7						CALLMONITOR 
36e7 cd 1c 17			call break_point_state  
36ea				endm  
# End of macro CALLMONITOR
36ea					endif 
36ea				; TODO add floating point number detection 
36ea					; v5 FORTH_DSP_VALUE 
36ea					FORTH_DSP 
36ea cd 69 1e			call macro_forth_dsp 
36ed				endm 
# End of macro FORTH_DSP
36ed 7e					ld a,(hl)	; get type of value on TOS 
36ee fe 02				cp DS_TYPE_INUM  
36f0 28 03				jr z, .div_inum 
36f2			 
36f2				if FORTH_ENABLE_FLOATMATH 
36f2					jr .div_done 
36f2			 
36f2				endif 
36f2					NEXTW 
36f2 c3 15 20			jp macro_next 
36f5				endm 
# End of macro NEXTW
36f5			.div_inum: 
36f5			 
36f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f5 cd a3 1e			call macro_dsp_valuehl 
36f8				endm 
# End of macro FORTH_DSP_VALUEHL
36f8			 
36f8 e5					push hl    ; to go to bc 
36f9			 
36f9					; destroy value TOS 
36f9			 
36f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f9 cd 5b 1f			call macro_forth_dsp_pop 
36fc				endm 
# End of macro FORTH_DSP_POP
36fc			 
36fc			 
36fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fc cd a3 1e			call macro_dsp_valuehl 
36ff				endm 
# End of macro FORTH_DSP_VALUEHL
36ff			 
36ff					; hl to go to de 
36ff			 
36ff e5					push hl 
3700			 
3700 c1					pop bc 
3701 d1					pop de		 
3702			 
3702			 
3702					if DEBUG_FORTH_MATHS 
3702						DMARK "DIV" 
3702				CALLMONITOR 
3702					endif 
3702					; one value on hl but move to a get other one back 
3702			 
3702			        
3702 cd 66 0c			call Div16 
3705			 
3705			;	push af	 
3705 e5				push hl 
3706 c5				push bc 
3707			 
3707					if DEBUG_FORTH_MATHS 
3707						DMARK "DI1" 
3707				CALLMONITOR 
3707					endif 
3707			 
3707					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3707 cd 5b 1f			call macro_forth_dsp_pop 
370a				endm 
# End of macro FORTH_DSP_POP
370a			 
370a			 
370a			 
370a e1					pop hl    ; result 
370b			 
370b cd ac 1c				call forth_push_numhl 
370e			 
370e e1					pop hl    ; reminder 
370f			;		ld h,0 
370f			;		ld l,d 
370f			 
370f cd ac 1c				call forth_push_numhl 
3712			.div_done: 
3712					NEXTW 
3712 c3 15 20			jp macro_next 
3715				endm 
# End of macro NEXTW
3715			.MUL: 
3715				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3715 19				db WORD_SYS_CORE+5             
3716 5a 37			dw .MIN            
3718 02				db 1 + 1 
3719 .. 00			db "*",0              
371b				endm 
# End of macro CWHEAD
371b			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
371b				; TODO add floating point number detection 
371b					if DEBUG_FORTH_WORDS_KEY 
371b						DMARK "MUL" 
371b f5				push af  
371c 3a 30 37			ld a, (.dmark)  
371f 32 bd fb			ld (debug_mark),a  
3722 3a 31 37			ld a, (.dmark+1)  
3725 32 be fb			ld (debug_mark+1),a  
3728 3a 32 37			ld a, (.dmark+2)  
372b 32 bf fb			ld (debug_mark+2),a  
372e 18 03			jr .pastdmark  
3730 ..			.dmark: db "MUL"  
3733 f1			.pastdmark: pop af  
3734			endm  
# End of macro DMARK
3734						CALLMONITOR 
3734 cd 1c 17			call break_point_state  
3737				endm  
# End of macro CALLMONITOR
3737					endif 
3737					FORTH_DSP 
3737 cd 69 1e			call macro_forth_dsp 
373a				endm 
# End of macro FORTH_DSP
373a					; v5 FORTH_DSP_VALUE 
373a 7e					ld a,(hl)	; get type of value on TOS 
373b fe 02				cp DS_TYPE_INUM  
373d 28 03				jr z, .mul_inum 
373f			 
373f				if FORTH_ENABLE_FLOATMATH 
373f					jr .mul_done 
373f			 
373f				endif 
373f			 
373f					NEXTW 
373f c3 15 20			jp macro_next 
3742				endm 
# End of macro NEXTW
3742			.mul_inum:	 
3742			 
3742					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3742 cd a3 1e			call macro_dsp_valuehl 
3745				endm 
# End of macro FORTH_DSP_VALUEHL
3745			 
3745 e5					push hl 
3746			 
3746					; destroy value TOS 
3746			 
3746					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3746 cd 5b 1f			call macro_forth_dsp_pop 
3749				endm 
# End of macro FORTH_DSP_POP
3749			 
3749			 
3749					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3749 cd a3 1e			call macro_dsp_valuehl 
374c				endm 
# End of macro FORTH_DSP_VALUEHL
374c			 
374c					; one value on hl but move to a get other one back 
374c			 
374c 7d					ld a, l 
374d			 
374d d1					pop de 
374e			 
374e					; do the mull 
374e			;		ex de, hl 
374e			 
374e cd 8c 0c				call Mult16 
3751					; save it 
3751			 
3751			;		push hl	 
3751			 
3751					; 
3751			 
3751					; destroy value TOS 
3751			 
3751					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3751 cd 5b 1f			call macro_forth_dsp_pop 
3754				endm 
# End of macro FORTH_DSP_POP
3754			 
3754					; TODO push value back onto stack for another op etc 
3754			 
3754			;		pop hl 
3754			 
3754 cd ac 1c				call forth_push_numhl 
3757			 
3757			.mul_done: 
3757					NEXTW 
3757 c3 15 20			jp macro_next 
375a				endm 
# End of macro NEXTW
375a			 
375a			 
375a			 
375a			 
375a			.MIN: 
375a				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
375a 49				db WORD_SYS_CORE+53             
375b db 37			dw .MAX            
375d 04				db 3 + 1 
375e .. 00			db "MIN",0              
3762				endm 
# End of macro CWHEAD
3762			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3762					if DEBUG_FORTH_WORDS_KEY 
3762						DMARK "MIN" 
3762 f5				push af  
3763 3a 77 37			ld a, (.dmark)  
3766 32 bd fb			ld (debug_mark),a  
3769 3a 78 37			ld a, (.dmark+1)  
376c 32 be fb			ld (debug_mark+1),a  
376f 3a 79 37			ld a, (.dmark+2)  
3772 32 bf fb			ld (debug_mark+2),a  
3775 18 03			jr .pastdmark  
3777 ..			.dmark: db "MIN"  
377a f1			.pastdmark: pop af  
377b			endm  
# End of macro DMARK
377b						CALLMONITOR 
377b cd 1c 17			call break_point_state  
377e				endm  
# End of macro CALLMONITOR
377e					endif 
377e					; get u2 
377e			 
377e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377e cd a3 1e			call macro_dsp_valuehl 
3781				endm 
# End of macro FORTH_DSP_VALUEHL
3781			 
3781 e5					push hl   ; u2 
3782			 
3782					; destroy value TOS 
3782			 
3782					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3782 cd 5b 1f			call macro_forth_dsp_pop 
3785				endm 
# End of macro FORTH_DSP_POP
3785			 
3785					; get u1 
3785			 
3785					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3785 cd a3 1e			call macro_dsp_valuehl 
3788				endm 
# End of macro FORTH_DSP_VALUEHL
3788			 
3788 e5					push hl  ; u1 
3789			 
3789					; destroy value TOS 
3789			 
3789					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3789 cd 5b 1f			call macro_forth_dsp_pop 
378c				endm 
# End of macro FORTH_DSP_POP
378c			 
378c b7			 or a      ;clear carry flag 
378d e1			  pop hl    ; u1 
378e d1			  pop de    ; u2 
378f e5				push hl   ; saved in case hl is lowest 
3790 ed 52		  sbc hl,de 
3792 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3794			 
3794 e1				pop hl 
3795					if DEBUG_FORTH_WORDS 
3795						DMARK "MIN" 
3795 f5				push af  
3796 3a aa 37			ld a, (.dmark)  
3799 32 bd fb			ld (debug_mark),a  
379c 3a ab 37			ld a, (.dmark+1)  
379f 32 be fb			ld (debug_mark+1),a  
37a2 3a ac 37			ld a, (.dmark+2)  
37a5 32 bf fb			ld (debug_mark+2),a  
37a8 18 03			jr .pastdmark  
37aa ..			.dmark: db "MIN"  
37ad f1			.pastdmark: pop af  
37ae			endm  
# End of macro DMARK
37ae						CALLMONITOR 
37ae cd 1c 17			call break_point_state  
37b1				endm  
# End of macro CALLMONITOR
37b1					endif 
37b1 cd ac 1c				call forth_push_numhl 
37b4			 
37b4				       NEXTW 
37b4 c3 15 20			jp macro_next 
37b7				endm 
# End of macro NEXTW
37b7			 
37b7			.mincont:  
37b7 c1				pop bc   ; tidy up 
37b8 eb				ex de , hl  
37b9					if DEBUG_FORTH_WORDS 
37b9						DMARK "MI1" 
37b9 f5				push af  
37ba 3a ce 37			ld a, (.dmark)  
37bd 32 bd fb			ld (debug_mark),a  
37c0 3a cf 37			ld a, (.dmark+1)  
37c3 32 be fb			ld (debug_mark+1),a  
37c6 3a d0 37			ld a, (.dmark+2)  
37c9 32 bf fb			ld (debug_mark+2),a  
37cc 18 03			jr .pastdmark  
37ce ..			.dmark: db "MI1"  
37d1 f1			.pastdmark: pop af  
37d2			endm  
# End of macro DMARK
37d2						CALLMONITOR 
37d2 cd 1c 17			call break_point_state  
37d5				endm  
# End of macro CALLMONITOR
37d5					endif 
37d5 cd ac 1c				call forth_push_numhl 
37d8			 
37d8				       NEXTW 
37d8 c3 15 20			jp macro_next 
37db				endm 
# End of macro NEXTW
37db			.MAX: 
37db				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37db 4a				db WORD_SYS_CORE+54             
37dc 5c 38			dw .RND16            
37de 04				db 3 + 1 
37df .. 00			db "MAX",0              
37e3				endm 
# End of macro CWHEAD
37e3			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37e3					if DEBUG_FORTH_WORDS_KEY 
37e3						DMARK "MAX" 
37e3 f5				push af  
37e4 3a f8 37			ld a, (.dmark)  
37e7 32 bd fb			ld (debug_mark),a  
37ea 3a f9 37			ld a, (.dmark+1)  
37ed 32 be fb			ld (debug_mark+1),a  
37f0 3a fa 37			ld a, (.dmark+2)  
37f3 32 bf fb			ld (debug_mark+2),a  
37f6 18 03			jr .pastdmark  
37f8 ..			.dmark: db "MAX"  
37fb f1			.pastdmark: pop af  
37fc			endm  
# End of macro DMARK
37fc						CALLMONITOR 
37fc cd 1c 17			call break_point_state  
37ff				endm  
# End of macro CALLMONITOR
37ff					endif 
37ff					; get u2 
37ff			 
37ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ff cd a3 1e			call macro_dsp_valuehl 
3802				endm 
# End of macro FORTH_DSP_VALUEHL
3802			 
3802 e5					push hl   ; u2 
3803			 
3803					; destroy value TOS 
3803			 
3803					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3803 cd 5b 1f			call macro_forth_dsp_pop 
3806				endm 
# End of macro FORTH_DSP_POP
3806			 
3806					; get u1 
3806			 
3806					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3806 cd a3 1e			call macro_dsp_valuehl 
3809				endm 
# End of macro FORTH_DSP_VALUEHL
3809			 
3809 e5					push hl  ; u1 
380a			 
380a					; destroy value TOS 
380a			 
380a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380a cd 5b 1f			call macro_forth_dsp_pop 
380d				endm 
# End of macro FORTH_DSP_POP
380d			 
380d b7			 or a      ;clear carry flag 
380e e1			  pop hl    ; u1 
380f d1			  pop de    ; u2 
3810 e5				push hl   ; saved in case hl is lowest 
3811 ed 52		  sbc hl,de 
3813 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3815			 
3815 e1				pop hl 
3816					if DEBUG_FORTH_WORDS 
3816						DMARK "MAX" 
3816 f5				push af  
3817 3a 2b 38			ld a, (.dmark)  
381a 32 bd fb			ld (debug_mark),a  
381d 3a 2c 38			ld a, (.dmark+1)  
3820 32 be fb			ld (debug_mark+1),a  
3823 3a 2d 38			ld a, (.dmark+2)  
3826 32 bf fb			ld (debug_mark+2),a  
3829 18 03			jr .pastdmark  
382b ..			.dmark: db "MAX"  
382e f1			.pastdmark: pop af  
382f			endm  
# End of macro DMARK
382f						CALLMONITOR 
382f cd 1c 17			call break_point_state  
3832				endm  
# End of macro CALLMONITOR
3832					endif 
3832 cd ac 1c				call forth_push_numhl 
3835			 
3835				       NEXTW 
3835 c3 15 20			jp macro_next 
3838				endm 
# End of macro NEXTW
3838			 
3838			.maxcont:  
3838 c1				pop bc   ; tidy up 
3839 eb				ex de , hl  
383a					if DEBUG_FORTH_WORDS 
383a						DMARK "MA1" 
383a f5				push af  
383b 3a 4f 38			ld a, (.dmark)  
383e 32 bd fb			ld (debug_mark),a  
3841 3a 50 38			ld a, (.dmark+1)  
3844 32 be fb			ld (debug_mark+1),a  
3847 3a 51 38			ld a, (.dmark+2)  
384a 32 bf fb			ld (debug_mark+2),a  
384d 18 03			jr .pastdmark  
384f ..			.dmark: db "MA1"  
3852 f1			.pastdmark: pop af  
3853			endm  
# End of macro DMARK
3853						CALLMONITOR 
3853 cd 1c 17			call break_point_state  
3856				endm  
# End of macro CALLMONITOR
3856					endif 
3856 cd ac 1c				call forth_push_numhl 
3859				       NEXTW 
3859 c3 15 20			jp macro_next 
385c				endm 
# End of macro NEXTW
385c			 
385c			.RND16: 
385c				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
385c 4e				db WORD_SYS_CORE+58             
385d 8b 38			dw .RND8            
385f 06				db 5 + 1 
3860 .. 00			db "RND16",0              
3866				endm 
# End of macro CWHEAD
3866			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3866					if DEBUG_FORTH_WORDS_KEY 
3866						DMARK "R16" 
3866 f5				push af  
3867 3a 7b 38			ld a, (.dmark)  
386a 32 bd fb			ld (debug_mark),a  
386d 3a 7c 38			ld a, (.dmark+1)  
3870 32 be fb			ld (debug_mark+1),a  
3873 3a 7d 38			ld a, (.dmark+2)  
3876 32 bf fb			ld (debug_mark+2),a  
3879 18 03			jr .pastdmark  
387b ..			.dmark: db "R16"  
387e f1			.pastdmark: pop af  
387f			endm  
# End of macro DMARK
387f						CALLMONITOR 
387f cd 1c 17			call break_point_state  
3882				endm  
# End of macro CALLMONITOR
3882					endif 
3882 cd 30 0c				call prng16  
3885 cd ac 1c				call forth_push_numhl 
3888				       NEXTW 
3888 c3 15 20			jp macro_next 
388b				endm 
# End of macro NEXTW
388b			.RND8: 
388b				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
388b 60				db WORD_SYS_CORE+76             
388c c0 38			dw .RND            
388e 05				db 4 + 1 
388f .. 00			db "RND8",0              
3894				endm 
# End of macro CWHEAD
3894			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3894					if DEBUG_FORTH_WORDS_KEY 
3894						DMARK "RN8" 
3894 f5				push af  
3895 3a a9 38			ld a, (.dmark)  
3898 32 bd fb			ld (debug_mark),a  
389b 3a aa 38			ld a, (.dmark+1)  
389e 32 be fb			ld (debug_mark+1),a  
38a1 3a ab 38			ld a, (.dmark+2)  
38a4 32 bf fb			ld (debug_mark+2),a  
38a7 18 03			jr .pastdmark  
38a9 ..			.dmark: db "RN8"  
38ac f1			.pastdmark: pop af  
38ad			endm  
# End of macro DMARK
38ad						CALLMONITOR 
38ad cd 1c 17			call break_point_state  
38b0				endm  
# End of macro CALLMONITOR
38b0					endif 
38b0 2a 3e fa				ld hl,(xrandc) 
38b3 23					inc hl 
38b4 cd 4a 0c				call xrnd 
38b7 6f					ld l,a	 
38b8 26 00				ld h,0 
38ba cd ac 1c				call forth_push_numhl 
38bd				       NEXTW 
38bd c3 15 20			jp macro_next 
38c0				endm 
# End of macro NEXTW
38c0			.RND: 
38c0				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38c0 60				db WORD_SYS_CORE+76             
38c1 c6 39			dw .ENDMATHS            
38c3 04				db 3 + 1 
38c4 .. 00			db "RND",0              
38c8				endm 
# End of macro CWHEAD
38c8			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38c8			 
38c8					if DEBUG_FORTH_WORDS_KEY 
38c8						DMARK "RND" 
38c8 f5				push af  
38c9 3a dd 38			ld a, (.dmark)  
38cc 32 bd fb			ld (debug_mark),a  
38cf 3a de 38			ld a, (.dmark+1)  
38d2 32 be fb			ld (debug_mark+1),a  
38d5 3a df 38			ld a, (.dmark+2)  
38d8 32 bf fb			ld (debug_mark+2),a  
38db 18 03			jr .pastdmark  
38dd ..			.dmark: db "RND"  
38e0 f1			.pastdmark: pop af  
38e1			endm  
# End of macro DMARK
38e1						CALLMONITOR 
38e1 cd 1c 17			call break_point_state  
38e4				endm  
# End of macro CALLMONITOR
38e4					endif 
38e4					 
38e4					FORTH_DSP_VALUEHL    ; upper range 
38e4 cd a3 1e			call macro_dsp_valuehl 
38e7				endm 
# End of macro FORTH_DSP_VALUEHL
38e7			 
38e7 22 42 fa				ld (LFSRSeed), hl	 
38ea			 
38ea					if DEBUG_FORTH_WORDS 
38ea						DMARK "RN1" 
38ea f5				push af  
38eb 3a ff 38			ld a, (.dmark)  
38ee 32 bd fb			ld (debug_mark),a  
38f1 3a 00 39			ld a, (.dmark+1)  
38f4 32 be fb			ld (debug_mark+1),a  
38f7 3a 01 39			ld a, (.dmark+2)  
38fa 32 bf fb			ld (debug_mark+2),a  
38fd 18 03			jr .pastdmark  
38ff ..			.dmark: db "RN1"  
3902 f1			.pastdmark: pop af  
3903			endm  
# End of macro DMARK
3903						CALLMONITOR 
3903 cd 1c 17			call break_point_state  
3906				endm  
# End of macro CALLMONITOR
3906					endif 
3906					FORTH_DSP_POP 
3906 cd 5b 1f			call macro_forth_dsp_pop 
3909				endm 
# End of macro FORTH_DSP_POP
3909			 
3909					FORTH_DSP_VALUEHL    ; low range 
3909 cd a3 1e			call macro_dsp_valuehl 
390c				endm 
# End of macro FORTH_DSP_VALUEHL
390c			 
390c					if DEBUG_FORTH_WORDS 
390c						DMARK "RN2" 
390c f5				push af  
390d 3a 21 39			ld a, (.dmark)  
3910 32 bd fb			ld (debug_mark),a  
3913 3a 22 39			ld a, (.dmark+1)  
3916 32 be fb			ld (debug_mark+1),a  
3919 3a 23 39			ld a, (.dmark+2)  
391c 32 bf fb			ld (debug_mark+2),a  
391f 18 03			jr .pastdmark  
3921 ..			.dmark: db "RN2"  
3924 f1			.pastdmark: pop af  
3925			endm  
# End of macro DMARK
3925						CALLMONITOR 
3925 cd 1c 17			call break_point_state  
3928				endm  
# End of macro CALLMONITOR
3928					endif 
3928 22 44 fa				ld (LFSRSeed+2), hl 
392b			 
392b					FORTH_DSP_POP 
392b cd 5b 1f			call macro_forth_dsp_pop 
392e				endm 
# End of macro FORTH_DSP_POP
392e			 
392e e5					push hl 
392f			 
392f e1			.inrange:	pop hl 
3930 cd 30 0c				call prng16  
3933					if DEBUG_FORTH_WORDS 
3933						DMARK "RN3" 
3933 f5				push af  
3934 3a 48 39			ld a, (.dmark)  
3937 32 bd fb			ld (debug_mark),a  
393a 3a 49 39			ld a, (.dmark+1)  
393d 32 be fb			ld (debug_mark+1),a  
3940 3a 4a 39			ld a, (.dmark+2)  
3943 32 bf fb			ld (debug_mark+2),a  
3946 18 03			jr .pastdmark  
3948 ..			.dmark: db "RN3"  
394b f1			.pastdmark: pop af  
394c			endm  
# End of macro DMARK
394c						CALLMONITOR 
394c cd 1c 17			call break_point_state  
394f				endm  
# End of macro CALLMONITOR
394f					endif 
394f					 
394f					; if the range is 8bit knock out the high byte 
394f			 
394f ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
3953			 
3953 3e 00				ld a, 0 
3955 ba					cp d  
3956 20 1e				jr nz, .hirange 
3958 26 00				ld h, 0   ; knock it down to 8bit 
395a			 
395a					if DEBUG_FORTH_WORDS 
395a						DMARK "RNk" 
395a f5				push af  
395b 3a 6f 39			ld a, (.dmark)  
395e 32 bd fb			ld (debug_mark),a  
3961 3a 70 39			ld a, (.dmark+1)  
3964 32 be fb			ld (debug_mark+1),a  
3967 3a 71 39			ld a, (.dmark+2)  
396a 32 bf fb			ld (debug_mark+2),a  
396d 18 03			jr .pastdmark  
396f ..			.dmark: db "RNk"  
3972 f1			.pastdmark: pop af  
3973			endm  
# End of macro DMARK
3973						CALLMONITOR 
3973 cd 1c 17			call break_point_state  
3976				endm  
# End of macro CALLMONITOR
3976					endif 
3976			.hirange:   
3976 e5					push hl  
3977 b7					or a  
3978 ed 52		                sbc hl, de 
397a			 
397a					;call cmp16 
397a			 
397a 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
397c e1					pop hl 
397d e5					push hl 
397e			 
397e					if DEBUG_FORTH_WORDS 
397e						DMARK "RN4" 
397e f5				push af  
397f 3a 93 39			ld a, (.dmark)  
3982 32 bd fb			ld (debug_mark),a  
3985 3a 94 39			ld a, (.dmark+1)  
3988 32 be fb			ld (debug_mark+1),a  
398b 3a 95 39			ld a, (.dmark+2)  
398e 32 bf fb			ld (debug_mark+2),a  
3991 18 03			jr .pastdmark  
3993 ..			.dmark: db "RN4"  
3996 f1			.pastdmark: pop af  
3997			endm  
# End of macro DMARK
3997						CALLMONITOR 
3997 cd 1c 17			call break_point_state  
399a				endm  
# End of macro CALLMONITOR
399a					endif 
399a ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
399e					;call cmp16 
399e				 
399e b7					or a  
399f ed 52		                sbc hl, de 
39a1 38 8c				jr c, .inrange 
39a3			 
39a3 e1					pop hl 
39a4					 
39a4					if DEBUG_FORTH_WORDS 
39a4						DMARK "RNd" 
39a4 f5				push af  
39a5 3a b9 39			ld a, (.dmark)  
39a8 32 bd fb			ld (debug_mark),a  
39ab 3a ba 39			ld a, (.dmark+1)  
39ae 32 be fb			ld (debug_mark+1),a  
39b1 3a bb 39			ld a, (.dmark+2)  
39b4 32 bf fb			ld (debug_mark+2),a  
39b7 18 03			jr .pastdmark  
39b9 ..			.dmark: db "RNd"  
39bc f1			.pastdmark: pop af  
39bd			endm  
# End of macro DMARK
39bd						CALLMONITOR 
39bd cd 1c 17			call break_point_state  
39c0				endm  
# End of macro CALLMONITOR
39c0					endif 
39c0			 
39c0			 
39c0 cd ac 1c				call forth_push_numhl 
39c3				       NEXTW 
39c3 c3 15 20			jp macro_next 
39c6				endm 
# End of macro NEXTW
39c6			 
39c6			.ENDMATHS: 
39c6			 
39c6			; eof 
39c6			 
# End of file forth_words_maths.asm
39c6			include "forth_words_display.asm" 
39c6			 
39c6			; | ## Display Words 
39c6			 
39c6			.ATP: 
39c6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39c6 62				db WORD_SYS_CORE+78             
39c7 3d 3a			dw .FB            
39c9 04				db 3 + 1 
39ca .. 00			db "AT?",0              
39ce				endm 
# End of macro CWHEAD
39ce			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
39ce					if DEBUG_FORTH_WORDS_KEY 
39ce						DMARK "AT?" 
39ce f5				push af  
39cf 3a e3 39			ld a, (.dmark)  
39d2 32 bd fb			ld (debug_mark),a  
39d5 3a e4 39			ld a, (.dmark+1)  
39d8 32 be fb			ld (debug_mark+1),a  
39db 3a e5 39			ld a, (.dmark+2)  
39de 32 bf fb			ld (debug_mark+2),a  
39e1 18 03			jr .pastdmark  
39e3 ..			.dmark: db "AT?"  
39e6 f1			.pastdmark: pop af  
39e7			endm  
# End of macro DMARK
39e7						CALLMONITOR 
39e7 cd 1c 17			call break_point_state  
39ea				endm  
# End of macro CALLMONITOR
39ea					endif 
39ea 3a cc f9				ld a, (f_cursor_ptr) 
39ed			 
39ed			if DEBUG_FORTH_WORDS 
39ed				DMARK "AT?" 
39ed f5				push af  
39ee 3a 02 3a			ld a, (.dmark)  
39f1 32 bd fb			ld (debug_mark),a  
39f4 3a 03 3a			ld a, (.dmark+1)  
39f7 32 be fb			ld (debug_mark+1),a  
39fa 3a 04 3a			ld a, (.dmark+2)  
39fd 32 bf fb			ld (debug_mark+2),a  
3a00 18 03			jr .pastdmark  
3a02 ..			.dmark: db "AT?"  
3a05 f1			.pastdmark: pop af  
3a06			endm  
# End of macro DMARK
3a06				CALLMONITOR 
3a06 cd 1c 17			call break_point_state  
3a09				endm  
# End of macro CALLMONITOR
3a09			endif	 
3a09					; count the number of rows 
3a09			 
3a09 06 00				ld b, 0 
3a0b 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a0c d6 14				sub display_cols 
3a0e f2 14 3a				jp p, .atprunder 
3a11 04					inc b 
3a12 18 f7				jr .atpr 
3a14			.atprunder:	 
3a14			if DEBUG_FORTH_WORDS 
3a14				DMARK "A?2" 
3a14 f5				push af  
3a15 3a 29 3a			ld a, (.dmark)  
3a18 32 bd fb			ld (debug_mark),a  
3a1b 3a 2a 3a			ld a, (.dmark+1)  
3a1e 32 be fb			ld (debug_mark+1),a  
3a21 3a 2b 3a			ld a, (.dmark+2)  
3a24 32 bf fb			ld (debug_mark+2),a  
3a27 18 03			jr .pastdmark  
3a29 ..			.dmark: db "A?2"  
3a2c f1			.pastdmark: pop af  
3a2d			endm  
# End of macro DMARK
3a2d				CALLMONITOR 
3a2d cd 1c 17			call break_point_state  
3a30				endm  
# End of macro CALLMONITOR
3a30			endif	 
3a30 26 00				ld h, 0 
3a32 69					ld l, c 
3a33 cd ac 1c				call forth_push_numhl 
3a36 68					ld l, b  
3a37 cd ac 1c				call forth_push_numhl 
3a3a			 
3a3a			 
3a3a				NEXTW 
3a3a c3 15 20			jp macro_next 
3a3d				endm 
# End of macro NEXTW
3a3d			 
3a3d			.FB: 
3a3d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a3d 1b				db WORD_SYS_CORE+7             
3a3e 8b 3a			dw .EMIT            
3a40 03				db 2 + 1 
3a41 .. 00			db "FB",0              
3a44				endm 
# End of macro CWHEAD
3a44			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a44			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a44			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a44			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a44					if DEBUG_FORTH_WORDS_KEY 
3a44						DMARK "FB." 
3a44 f5				push af  
3a45 3a 59 3a			ld a, (.dmark)  
3a48 32 bd fb			ld (debug_mark),a  
3a4b 3a 5a 3a			ld a, (.dmark+1)  
3a4e 32 be fb			ld (debug_mark+1),a  
3a51 3a 5b 3a			ld a, (.dmark+2)  
3a54 32 bf fb			ld (debug_mark+2),a  
3a57 18 03			jr .pastdmark  
3a59 ..			.dmark: db "FB."  
3a5c f1			.pastdmark: pop af  
3a5d			endm  
# End of macro DMARK
3a5d						CALLMONITOR 
3a5d cd 1c 17			call break_point_state  
3a60				endm  
# End of macro CALLMONITOR
3a60					endif 
3a60			 
3a60					FORTH_DSP_VALUEHL 
3a60 cd a3 1e			call macro_dsp_valuehl 
3a63				endm 
# End of macro FORTH_DSP_VALUEHL
3a63			 
3a63 7d					ld a, l 
3a64 fe 01				cp 1 
3a66 20 05				jr nz, .fbn1 
3a68 21 02 fb				ld hl, display_fb1 
3a6b 18 15				jr .fbset 
3a6d fe 02		.fbn1:		cp 2 
3a6f 20 05				jr nz, .fbn2 
3a71 21 60 fa				ld hl, display_fb2 
3a74 18 0c				jr .fbset 
3a76 fe 03		.fbn2:		cp 3 
3a78 20 05				jr nz, .fbn3 
3a7a 21 b1 fa				ld hl, display_fb3 
3a7d 18 03				jr .fbset 
3a7f			.fbn3:		 ; if invalid number select first 
3a7f 21 02 fb				ld hl, display_fb1 
3a82 22 5e fa		.fbset:		ld (display_fb_active), hl 
3a85			 
3a85					FORTH_DSP_POP 
3a85 cd 5b 1f			call macro_forth_dsp_pop 
3a88				endm 
# End of macro FORTH_DSP_POP
3a88			 
3a88					NEXTW 
3a88 c3 15 20			jp macro_next 
3a8b				endm 
# End of macro NEXTW
3a8b			 
3a8b			 
3a8b			.EMIT: 
3a8b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3a8b 1b				db WORD_SYS_CORE+7             
3a8c dc 3a			dw .DOTH            
3a8e 05				db 4 + 1 
3a8f .. 00			db "EMIT",0              
3a94				endm 
# End of macro CWHEAD
3a94			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3a94					; get value off TOS and display it 
3a94			 
3a94					if DEBUG_FORTH_WORDS_KEY 
3a94						DMARK "EMT" 
3a94 f5				push af  
3a95 3a a9 3a			ld a, (.dmark)  
3a98 32 bd fb			ld (debug_mark),a  
3a9b 3a aa 3a			ld a, (.dmark+1)  
3a9e 32 be fb			ld (debug_mark+1),a  
3aa1 3a ab 3a			ld a, (.dmark+2)  
3aa4 32 bf fb			ld (debug_mark+2),a  
3aa7 18 03			jr .pastdmark  
3aa9 ..			.dmark: db "EMT"  
3aac f1			.pastdmark: pop af  
3aad			endm  
# End of macro DMARK
3aad						CALLMONITOR 
3aad cd 1c 17			call break_point_state  
3ab0				endm  
# End of macro CALLMONITOR
3ab0					endif 
3ab0			 
3ab0					FORTH_DSP_VALUEHL 
3ab0 cd a3 1e			call macro_dsp_valuehl 
3ab3				endm 
# End of macro FORTH_DSP_VALUEHL
3ab3			 
3ab3 7d					ld a,l 
3ab4			 
3ab4					; TODO write to display 
3ab4			 
3ab4 32 a1 f1				ld (os_input), a 
3ab7 3e 00				ld a, 0 
3ab9 32 a2 f1				ld (os_input+1), a 
3abc					 
3abc 3a cc f9				ld a, (f_cursor_ptr) 
3abf 11 a1 f1				ld de, os_input 
3ac2 cd e8 0a				call str_at_display 
3ac5			 
3ac5			 
3ac5 3a aa f9				ld a,(cli_autodisplay) 
3ac8 fe 00				cp 0 
3aca 28 03				jr z, .enoupdate 
3acc cd f8 0a						call update_display 
3acf					.enoupdate: 
3acf			 
3acf 3a cc f9				ld a, (f_cursor_ptr) 
3ad2 3c					inc a 
3ad3 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3ad6			 
3ad6			 
3ad6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad6 cd 5b 1f			call macro_forth_dsp_pop 
3ad9				endm 
# End of macro FORTH_DSP_POP
3ad9			  
3ad9			 
3ad9					NEXTW 
3ad9 c3 15 20			jp macro_next 
3adc				endm 
# End of macro NEXTW
3adc			.DOTH: 
3adc				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3adc 1c				db WORD_SYS_CORE+8             
3add 0c 3b			dw .DOTF            
3adf 03				db 2 + 1 
3ae0 .. 00			db ".-",0              
3ae3				endm 
# End of macro CWHEAD
3ae3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3ae3					; get value off TOS and display it 
3ae3					if DEBUG_FORTH_WORDS_KEY 
3ae3						DMARK "DTD" 
3ae3 f5				push af  
3ae4 3a f8 3a			ld a, (.dmark)  
3ae7 32 bd fb			ld (debug_mark),a  
3aea 3a f9 3a			ld a, (.dmark+1)  
3aed 32 be fb			ld (debug_mark+1),a  
3af0 3a fa 3a			ld a, (.dmark+2)  
3af3 32 bf fb			ld (debug_mark+2),a  
3af6 18 03			jr .pastdmark  
3af8 ..			.dmark: db "DTD"  
3afb f1			.pastdmark: pop af  
3afc			endm  
# End of macro DMARK
3afc						CALLMONITOR 
3afc cd 1c 17			call break_point_state  
3aff				endm  
# End of macro CALLMONITOR
3aff					endif 
3aff 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b01 3e 00			ld a, 0 
3b03 32 ab f9			ld (cli_mvdot), a 
3b06 c3 63 3b			jp .dotgo 
3b09				NEXTW 
3b09 c3 15 20			jp macro_next 
3b0c				endm 
# End of macro NEXTW
3b0c			.DOTF: 
3b0c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b0c 1c				db WORD_SYS_CORE+8             
3b0d 3a 3b			dw .DOT            
3b0f 03				db 2 + 1 
3b10 .. 00			db ".>",0              
3b13				endm 
# End of macro CWHEAD
3b13			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b13					; get value off TOS and display it 
3b13			        ; TODO BUG adds extra spaces 
3b13			        ; TODO BUG handle numerics? 
3b13					if DEBUG_FORTH_WORDS_KEY 
3b13						DMARK "DTC" 
3b13 f5				push af  
3b14 3a 28 3b			ld a, (.dmark)  
3b17 32 bd fb			ld (debug_mark),a  
3b1a 3a 29 3b			ld a, (.dmark+1)  
3b1d 32 be fb			ld (debug_mark+1),a  
3b20 3a 2a 3b			ld a, (.dmark+2)  
3b23 32 bf fb			ld (debug_mark+2),a  
3b26 18 03			jr .pastdmark  
3b28 ..			.dmark: db "DTC"  
3b2b f1			.pastdmark: pop af  
3b2c			endm  
# End of macro DMARK
3b2c						CALLMONITOR 
3b2c cd 1c 17			call break_point_state  
3b2f				endm  
# End of macro CALLMONITOR
3b2f					endif 
3b2f 3e 01			ld a, 1 
3b31 32 ab f9			ld (cli_mvdot), a 
3b34 c3 63 3b			jp .dotgo 
3b37				NEXTW 
3b37 c3 15 20			jp macro_next 
3b3a				endm 
# End of macro NEXTW
3b3a			 
3b3a			.DOT: 
3b3a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b3a 1c				db WORD_SYS_CORE+8             
3b3b c6 3b			dw .CLS            
3b3d 02				db 1 + 1 
3b3e .. 00			db ".",0              
3b40				endm 
# End of macro CWHEAD
3b40			        ; | . ( u -- ) Display TOS | DONE 
3b40					; get value off TOS and display it 
3b40			 
3b40					if DEBUG_FORTH_WORDS_KEY 
3b40						DMARK "DOT" 
3b40 f5				push af  
3b41 3a 55 3b			ld a, (.dmark)  
3b44 32 bd fb			ld (debug_mark),a  
3b47 3a 56 3b			ld a, (.dmark+1)  
3b4a 32 be fb			ld (debug_mark+1),a  
3b4d 3a 57 3b			ld a, (.dmark+2)  
3b50 32 bf fb			ld (debug_mark+2),a  
3b53 18 03			jr .pastdmark  
3b55 ..			.dmark: db "DOT"  
3b58 f1			.pastdmark: pop af  
3b59			endm  
# End of macro DMARK
3b59						CALLMONITOR 
3b59 cd 1c 17			call break_point_state  
3b5c				endm  
# End of macro CALLMONITOR
3b5c					endif 
3b5c 3e 00			ld a, 0 
3b5e 32 ab f9			ld (cli_mvdot), a 
3b61 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b63				 
3b63			 
3b63			.dotgo: 
3b63			 
3b63			; move up type to on stack for parserv5 
3b63					FORTH_DSP 
3b63 cd 69 1e			call macro_forth_dsp 
3b66				endm 
# End of macro FORTH_DSP
3b66				;FORTH_DSP_VALUE  
3b66			 
3b66			if DEBUG_FORTH_DOT 
3b66				DMARK "DOT" 
3b66				CALLMONITOR 
3b66			endif	 
3b66			;		.print: 
3b66			 
3b66 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b67 23				inc hl   ; position to the actual value 
3b68 fe 01			cp DS_TYPE_STR 
3b6a 20 06			jr nz, .dotnum1  
3b6c			 
3b6c			; display string 
3b6c				FORTH_DSP_VALUE  
3b6c cd 8c 1e			call macro_forth_dsp_value 
3b6f				endm 
# End of macro FORTH_DSP_VALUE
3b6f eb				ex de,hl 
3b70 18 11			jr .dotwrite 
3b72			 
3b72			.dotnum1: 
3b72 fe 02			cp DS_TYPE_INUM 
3b74 20 0c			jr nz, .dotflot 
3b76			 
3b76			 
3b76			; display number 
3b76			 
3b76			;	push hl 
3b76			;	call clear_display 
3b76			;	pop hl 
3b76			 
3b76 5e				ld e, (hl) 
3b77 23				inc hl 
3b78 56				ld d, (hl) 
3b79 21 a3 ef			ld hl, scratch 
3b7c			if DEBUG_FORTH_DOT 
3b7c				DMARK "DT1" 
3b7c				CALLMONITOR 
3b7c			endif	 
3b7c			 
3b7c cd 16 11			call uitoa_16 
3b7f eb				ex de,hl 
3b80			 
3b80			if DEBUG_FORTH_DOT 
3b80				DMARK "DT2" 
3b80				CALLMONITOR 
3b80			endif	 
3b80			 
3b80			;	ld de, os_word_scratch 
3b80 18 01			jr .dotwrite 
3b82			 
3b82 00			.dotflot:   nop 
3b83			; TODO print floating point number 
3b83			 
3b83			.dotwrite:		 
3b83			 
3b83					; if c is set then set all '-' to spaces 
3b83					; need to also take into account .>  
3b83			 
3b83 3e 01				ld a, 1 
3b85 b9					cp c 
3b86 20 13				jr nz, .nodashswap 
3b88			 
3b88					; DE has the string to write, working with HL 
3b88			 
3b88 06 ff				ld b, 255 
3b8a d5					push de 
3b8b e1					pop hl 
3b8c			 
3b8c			if DEBUG_FORTH_DOT 
3b8c				DMARK "DT-" 
3b8c				CALLMONITOR 
3b8c			endif	 
3b8c 7e			.dashscan:	ld a, (hl) 
3b8d fe 00				cp 0 
3b8f 28 0a				jr z, .nodashswap 
3b91 fe 2d				cp '-' 
3b93 20 03				jr nz, .dashskip 
3b95 3e 20				ld a, ' ' 
3b97 77					ld (hl), a 
3b98 23			.dashskip:	inc hl 
3b99			if DEBUG_FORTH_DOT 
3b99				DMARK "D-2" 
3b99				CALLMONITOR 
3b99			endif	 
3b99 10 f1				djnz .dashscan 
3b9b			 
3b9b			if DEBUG_FORTH_DOT 
3b9b				DMARK "D-1" 
3b9b				CALLMONITOR 
3b9b			endif	 
3b9b			 
3b9b			.nodashswap: 
3b9b			 
3b9b e5					push hl   ; save string start in case we need to advance print 
3b9c			 
3b9c 3a cc f9				ld a, (f_cursor_ptr) 
3b9f cd e8 0a				call str_at_display 
3ba2 3a aa f9				ld a,(cli_autodisplay) 
3ba5 fe 00				cp 0 
3ba7 28 03				jr z, .noupdate 
3ba9 cd f8 0a						call update_display 
3bac					.noupdate: 
3bac			 
3bac			 
3bac					; see if we need to advance the print position 
3bac			 
3bac e1					pop hl   ; get back string 
3bad			 
3bad 3a ab f9				ld a, (cli_mvdot) 
3bb0			if DEBUG_FORTH_DOT 
3bb0					ld e,a 
3bb0				DMARK "D>1" 
3bb0				CALLMONITOR 
3bb0			endif	 
3bb0 fe 00				cp 0 
3bb2 28 0c				jr z, .noadv 
3bb4					; yes, lets advance the print position 
3bb4 3e 00				ld a, 0 
3bb6 cd 72 11				call strlent 
3bb9 3a cc f9				ld a, (f_cursor_ptr) 
3bbc 85					add a,l 
3bbd					;call addatohl 
3bbd					;ld a, l 
3bbd 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3bc0			 
3bc0			if DEBUG_FORTH_DOT 
3bc0				DMARK "D->" 
3bc0				CALLMONITOR 
3bc0			endif	 
3bc0			 
3bc0			.noadv:	 
3bc0			 
3bc0					if DEBUG_FORTH_DOT_WAIT 
3bc0							call next_page_prompt 
3bc0					endif	 
3bc0			; TODO this pop off the stack causes a crash. i dont know why 
3bc0			 
3bc0			 
3bc0			if DEBUG_FORTH_DOT 
3bc0				DMARK "DTh" 
3bc0				CALLMONITOR 
3bc0			endif	 
3bc0			 
3bc0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc0 cd 5b 1f			call macro_forth_dsp_pop 
3bc3				endm 
# End of macro FORTH_DSP_POP
3bc3			 
3bc3			if DEBUG_FORTH_DOT 
3bc3				DMARK "DTi" 
3bc3				CALLMONITOR 
3bc3			endif	 
3bc3			 
3bc3			 
3bc3					NEXTW 
3bc3 c3 15 20			jp macro_next 
3bc6				endm 
# End of macro NEXTW
3bc6			 
3bc6			.CLS: 
3bc6				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3bc6 35				db WORD_SYS_CORE+33             
3bc7 f3 3b			dw .DRAW            
3bc9 04				db 3 + 1 
3bca .. 00			db "CLS",0              
3bce				endm 
# End of macro CWHEAD
3bce			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3bce					if DEBUG_FORTH_WORDS_KEY 
3bce						DMARK "CLS" 
3bce f5				push af  
3bcf 3a e3 3b			ld a, (.dmark)  
3bd2 32 bd fb			ld (debug_mark),a  
3bd5 3a e4 3b			ld a, (.dmark+1)  
3bd8 32 be fb			ld (debug_mark+1),a  
3bdb 3a e5 3b			ld a, (.dmark+2)  
3bde 32 bf fb			ld (debug_mark+2),a  
3be1 18 03			jr .pastdmark  
3be3 ..			.dmark: db "CLS"  
3be6 f1			.pastdmark: pop af  
3be7			endm  
# End of macro DMARK
3be7						CALLMONITOR 
3be7 cd 1c 17			call break_point_state  
3bea				endm  
# End of macro CALLMONITOR
3bea					endif 
3bea cd d5 0a				call clear_display 
3bed c3 01 3d				jp .home		; and home cursor 
3bf0					NEXTW 
3bf0 c3 15 20			jp macro_next 
3bf3				endm 
# End of macro NEXTW
3bf3			 
3bf3			.DRAW: 
3bf3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3bf3 36				db WORD_SYS_CORE+34             
3bf4 1e 3c			dw .DUMP            
3bf6 05				db 4 + 1 
3bf7 .. 00			db "DRAW",0              
3bfc				endm 
# End of macro CWHEAD
3bfc			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3bfc					if DEBUG_FORTH_WORDS_KEY 
3bfc						DMARK "DRW" 
3bfc f5				push af  
3bfd 3a 11 3c			ld a, (.dmark)  
3c00 32 bd fb			ld (debug_mark),a  
3c03 3a 12 3c			ld a, (.dmark+1)  
3c06 32 be fb			ld (debug_mark+1),a  
3c09 3a 13 3c			ld a, (.dmark+2)  
3c0c 32 bf fb			ld (debug_mark+2),a  
3c0f 18 03			jr .pastdmark  
3c11 ..			.dmark: db "DRW"  
3c14 f1			.pastdmark: pop af  
3c15			endm  
# End of macro DMARK
3c15						CALLMONITOR 
3c15 cd 1c 17			call break_point_state  
3c18				endm  
# End of macro CALLMONITOR
3c18					endif 
3c18 cd f8 0a				call update_display 
3c1b					NEXTW 
3c1b c3 15 20			jp macro_next 
3c1e				endm 
# End of macro NEXTW
3c1e			 
3c1e			.DUMP: 
3c1e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c1e 37				db WORD_SYS_CORE+35             
3c1f 56 3c			dw .CDUMP            
3c21 05				db 4 + 1 
3c22 .. 00			db "DUMP",0              
3c27				endm 
# End of macro CWHEAD
3c27			; | DUMP ( x -- ) With address x display dump   | DONE 
3c27			; TODO pop address to use off of the stack 
3c27					if DEBUG_FORTH_WORDS_KEY 
3c27						DMARK "DUM" 
3c27 f5				push af  
3c28 3a 3c 3c			ld a, (.dmark)  
3c2b 32 bd fb			ld (debug_mark),a  
3c2e 3a 3d 3c			ld a, (.dmark+1)  
3c31 32 be fb			ld (debug_mark+1),a  
3c34 3a 3e 3c			ld a, (.dmark+2)  
3c37 32 bf fb			ld (debug_mark+2),a  
3c3a 18 03			jr .pastdmark  
3c3c ..			.dmark: db "DUM"  
3c3f f1			.pastdmark: pop af  
3c40			endm  
# End of macro DMARK
3c40						CALLMONITOR 
3c40 cd 1c 17			call break_point_state  
3c43				endm  
# End of macro CALLMONITOR
3c43					endif 
3c43 cd d5 0a				call clear_display 
3c46			 
3c46					; get address 
3c46			 
3c46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c46 cd a3 1e			call macro_dsp_valuehl 
3c49				endm 
# End of macro FORTH_DSP_VALUEHL
3c49				 
3c49					; save it for cdump 
3c49			 
3c49 22 c6 f2				ld (os_cur_ptr),hl 
3c4c			 
3c4c					; destroy value TOS 
3c4c			 
3c4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4c cd 5b 1f			call macro_forth_dsp_pop 
3c4f				endm 
# End of macro FORTH_DSP_POP
3c4f			 
3c4f cd 2c 1b				call dumpcont	; skip old style of param parsing	 
3c52 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c53					NEXTW 
3c53 c3 15 20			jp macro_next 
3c56				endm 
# End of macro NEXTW
3c56			.CDUMP: 
3c56				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c56 38				db WORD_SYS_CORE+36             
3c57 86 3c			dw .DAT            
3c59 06				db 5 + 1 
3c5a .. 00			db "CDUMP",0              
3c60				endm 
# End of macro CWHEAD
3c60			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c60					if DEBUG_FORTH_WORDS_KEY 
3c60						DMARK "CDP" 
3c60 f5				push af  
3c61 3a 75 3c			ld a, (.dmark)  
3c64 32 bd fb			ld (debug_mark),a  
3c67 3a 76 3c			ld a, (.dmark+1)  
3c6a 32 be fb			ld (debug_mark+1),a  
3c6d 3a 77 3c			ld a, (.dmark+2)  
3c70 32 bf fb			ld (debug_mark+2),a  
3c73 18 03			jr .pastdmark  
3c75 ..			.dmark: db "CDP"  
3c78 f1			.pastdmark: pop af  
3c79			endm  
# End of macro DMARK
3c79						CALLMONITOR 
3c79 cd 1c 17			call break_point_state  
3c7c				endm  
# End of macro CALLMONITOR
3c7c					endif 
3c7c cd d5 0a				call clear_display 
3c7f cd 2c 1b				call dumpcont	 
3c82 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3c83					NEXTW 
3c83 c3 15 20			jp macro_next 
3c86				endm 
# End of macro NEXTW
3c86			 
3c86			 
3c86			 
3c86			 
3c86			.DAT: 
3c86				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3c86 3d				db WORD_SYS_CORE+41             
3c87 dc 3c			dw .HOME            
3c89 03				db 2 + 1 
3c8a .. 00			db "AT",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3c8d					if DEBUG_FORTH_WORDS_KEY 
3c8d						DMARK "AT." 
3c8d f5				push af  
3c8e 3a a2 3c			ld a, (.dmark)  
3c91 32 bd fb			ld (debug_mark),a  
3c94 3a a3 3c			ld a, (.dmark+1)  
3c97 32 be fb			ld (debug_mark+1),a  
3c9a 3a a4 3c			ld a, (.dmark+2)  
3c9d 32 bf fb			ld (debug_mark+2),a  
3ca0 18 03			jr .pastdmark  
3ca2 ..			.dmark: db "AT."  
3ca5 f1			.pastdmark: pop af  
3ca6			endm  
# End of macro DMARK
3ca6						CALLMONITOR 
3ca6 cd 1c 17			call break_point_state  
3ca9				endm  
# End of macro CALLMONITOR
3ca9					endif 
3ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca9 cd a3 1e			call macro_dsp_valuehl 
3cac				endm 
# End of macro FORTH_DSP_VALUEHL
3cac			 
3cac			 
3cac					; TODO save cursor row 
3cac 7d					ld a,l 
3cad fe 02				cp 2 
3caf 20 04				jr nz, .crow3 
3cb1 3e 14				ld a, display_row_2 
3cb3 18 12				jr .ccol1 
3cb5 fe 03		.crow3:		cp 3 
3cb7 20 04				jr nz, .crow4 
3cb9 3e 28				ld a, display_row_3 
3cbb 18 0a				jr .ccol1 
3cbd fe 04		.crow4:		cp 4 
3cbf 20 04				jr nz, .crow1 
3cc1 3e 3c				ld a, display_row_4 
3cc3 18 02				jr .ccol1 
3cc5 3e 00		.crow1:		ld a,display_row_1 
3cc7 f5			.ccol1:		push af			; got row offset 
3cc8 6f					ld l,a 
3cc9 26 00				ld h,0 
3ccb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ccb cd 5b 1f			call macro_forth_dsp_pop 
3cce				endm 
# End of macro FORTH_DSP_POP
3cce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cce cd a3 1e			call macro_dsp_valuehl 
3cd1				endm 
# End of macro FORTH_DSP_VALUEHL
3cd1					; TODO save cursor col 
3cd1 f1					pop af 
3cd2 85					add l		; add col offset 
3cd3 32 cc f9				ld (f_cursor_ptr), a 
3cd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd6 cd 5b 1f			call macro_forth_dsp_pop 
3cd9				endm 
# End of macro FORTH_DSP_POP
3cd9			 
3cd9					; calculate  
3cd9			 
3cd9					NEXTW 
3cd9 c3 15 20			jp macro_next 
3cdc				endm 
# End of macro NEXTW
3cdc			 
3cdc			 
3cdc			.HOME: 
3cdc				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3cdc 41				db WORD_SYS_CORE+45             
3cdd 09 3d			dw .SPACE            
3cdf 05				db 4 + 1 
3ce0 .. 00			db "HOME",0              
3ce5				endm 
# End of macro CWHEAD
3ce5			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ce5					if DEBUG_FORTH_WORDS_KEY 
3ce5						DMARK "HOM" 
3ce5 f5				push af  
3ce6 3a fa 3c			ld a, (.dmark)  
3ce9 32 bd fb			ld (debug_mark),a  
3cec 3a fb 3c			ld a, (.dmark+1)  
3cef 32 be fb			ld (debug_mark+1),a  
3cf2 3a fc 3c			ld a, (.dmark+2)  
3cf5 32 bf fb			ld (debug_mark+2),a  
3cf8 18 03			jr .pastdmark  
3cfa ..			.dmark: db "HOM"  
3cfd f1			.pastdmark: pop af  
3cfe			endm  
# End of macro DMARK
3cfe						CALLMONITOR 
3cfe cd 1c 17			call break_point_state  
3d01				endm  
# End of macro CALLMONITOR
3d01					endif 
3d01 3e 00		.home:		ld a, 0		; and home cursor 
3d03 32 cc f9				ld (f_cursor_ptr), a 
3d06					NEXTW 
3d06 c3 15 20			jp macro_next 
3d09				endm 
# End of macro NEXTW
3d09			 
3d09			 
3d09			.SPACE: 
3d09				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d09 46				db WORD_SYS_CORE+50             
3d0a 37 3d			dw .SPACES            
3d0c 03				db 2 + 1 
3d0d .. 00			db "BL",0              
3d10				endm 
# End of macro CWHEAD
3d10			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d10					if DEBUG_FORTH_WORDS_KEY 
3d10						DMARK "BL." 
3d10 f5				push af  
3d11 3a 25 3d			ld a, (.dmark)  
3d14 32 bd fb			ld (debug_mark),a  
3d17 3a 26 3d			ld a, (.dmark+1)  
3d1a 32 be fb			ld (debug_mark+1),a  
3d1d 3a 27 3d			ld a, (.dmark+2)  
3d20 32 bf fb			ld (debug_mark+2),a  
3d23 18 03			jr .pastdmark  
3d25 ..			.dmark: db "BL."  
3d28 f1			.pastdmark: pop af  
3d29			endm  
# End of macro DMARK
3d29						CALLMONITOR 
3d29 cd 1c 17			call break_point_state  
3d2c				endm  
# End of macro CALLMONITOR
3d2c					endif 
3d2c 21 35 3d				ld hl, .blstr 
3d2f cd 1a 1d				call forth_push_str 
3d32					 
3d32				       NEXTW 
3d32 c3 15 20			jp macro_next 
3d35				endm 
# End of macro NEXTW
3d35			 
3d35 .. 00		.blstr: db " ", 0 
3d37			 
3d37			.SPACES: 
3d37				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d37 47				db WORD_SYS_CORE+51             
3d38 d2 3d			dw .SCROLL            
3d3a 07				db 6 + 1 
3d3b .. 00			db "SPACES",0              
3d42				endm 
# End of macro CWHEAD
3d42			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d42					if DEBUG_FORTH_WORDS_KEY 
3d42						DMARK "SPS" 
3d42 f5				push af  
3d43 3a 57 3d			ld a, (.dmark)  
3d46 32 bd fb			ld (debug_mark),a  
3d49 3a 58 3d			ld a, (.dmark+1)  
3d4c 32 be fb			ld (debug_mark+1),a  
3d4f 3a 59 3d			ld a, (.dmark+2)  
3d52 32 bf fb			ld (debug_mark+2),a  
3d55 18 03			jr .pastdmark  
3d57 ..			.dmark: db "SPS"  
3d5a f1			.pastdmark: pop af  
3d5b			endm  
# End of macro DMARK
3d5b						CALLMONITOR 
3d5b cd 1c 17			call break_point_state  
3d5e				endm  
# End of macro CALLMONITOR
3d5e					endif 
3d5e			 
3d5e			 
3d5e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d5e cd a3 1e			call macro_dsp_valuehl 
3d61				endm 
# End of macro FORTH_DSP_VALUEHL
3d61			 
3d61			;		push hl    ; u 
3d61					if DEBUG_FORTH_WORDS 
3d61						DMARK "SPA" 
3d61 f5				push af  
3d62 3a 76 3d			ld a, (.dmark)  
3d65 32 bd fb			ld (debug_mark),a  
3d68 3a 77 3d			ld a, (.dmark+1)  
3d6b 32 be fb			ld (debug_mark+1),a  
3d6e 3a 78 3d			ld a, (.dmark+2)  
3d71 32 bf fb			ld (debug_mark+2),a  
3d74 18 03			jr .pastdmark  
3d76 ..			.dmark: db "SPA"  
3d79 f1			.pastdmark: pop af  
3d7a			endm  
# End of macro DMARK
3d7a						CALLMONITOR 
3d7a cd 1c 17			call break_point_state  
3d7d				endm  
# End of macro CALLMONITOR
3d7d					endif 
3d7d			 
3d7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d7d cd 5b 1f			call macro_forth_dsp_pop 
3d80				endm 
# End of macro FORTH_DSP_POP
3d80			;		pop hl 
3d80 4d					ld c, l 
3d81 06 00				ld b, 0 
3d83 21 a3 ef				ld hl, scratch  
3d86			 
3d86					if DEBUG_FORTH_WORDS 
3d86						DMARK "SP2" 
3d86 f5				push af  
3d87 3a 9b 3d			ld a, (.dmark)  
3d8a 32 bd fb			ld (debug_mark),a  
3d8d 3a 9c 3d			ld a, (.dmark+1)  
3d90 32 be fb			ld (debug_mark+1),a  
3d93 3a 9d 3d			ld a, (.dmark+2)  
3d96 32 bf fb			ld (debug_mark+2),a  
3d99 18 03			jr .pastdmark  
3d9b ..			.dmark: db "SP2"  
3d9e f1			.pastdmark: pop af  
3d9f			endm  
# End of macro DMARK
3d9f						CALLMONITOR 
3d9f cd 1c 17			call break_point_state  
3da2				endm  
# End of macro CALLMONITOR
3da2					endif 
3da2 3e 20				ld a, ' ' 
3da4 c5			.spaces1:	push bc 
3da5 77					ld (hl),a 
3da6 23					inc hl 
3da7 c1					pop bc 
3da8 10 fa				djnz .spaces1 
3daa 3e 00				ld a,0 
3dac 77					ld (hl),a 
3dad 21 a3 ef				ld hl, scratch 
3db0					if DEBUG_FORTH_WORDS 
3db0						DMARK "SP3" 
3db0 f5				push af  
3db1 3a c5 3d			ld a, (.dmark)  
3db4 32 bd fb			ld (debug_mark),a  
3db7 3a c6 3d			ld a, (.dmark+1)  
3dba 32 be fb			ld (debug_mark+1),a  
3dbd 3a c7 3d			ld a, (.dmark+2)  
3dc0 32 bf fb			ld (debug_mark+2),a  
3dc3 18 03			jr .pastdmark  
3dc5 ..			.dmark: db "SP3"  
3dc8 f1			.pastdmark: pop af  
3dc9			endm  
# End of macro DMARK
3dc9						CALLMONITOR 
3dc9 cd 1c 17			call break_point_state  
3dcc				endm  
# End of macro CALLMONITOR
3dcc					endif 
3dcc cd 15 1e				call forth_apush 
3dcf			 
3dcf				       NEXTW 
3dcf c3 15 20			jp macro_next 
3dd2				endm 
# End of macro NEXTW
3dd2			 
3dd2			 
3dd2			 
3dd2			.SCROLL: 
3dd2				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3dd2 53				db WORD_SYS_CORE+63             
3dd3 ff 3d			dw .SCROLLD            
3dd5 07				db 6 + 1 
3dd6 .. 00			db "SCROLL",0              
3ddd				endm 
# End of macro CWHEAD
3ddd			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ddd					if DEBUG_FORTH_WORDS_KEY 
3ddd						DMARK "SCR" 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 bd fb			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 be fb			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 bf fb			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "SCR"  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd 1c 17			call break_point_state  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9			 
3df9 cd 97 0a			call scroll_up 
3dfc			;	call update_display 
3dfc			 
3dfc					NEXTW 
3dfc c3 15 20			jp macro_next 
3dff				endm 
# End of macro NEXTW
3dff			 
3dff			 
3dff			 
3dff			;		; get dir 
3dff			; 
3dff			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dff			; 
3dff			;		push hl 
3dff			; 
3dff			;		; destroy value TOS 
3dff			; 
3dff			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dff			; 
3dff			;		; get count 
3dff			; 
3dff			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dff			; 
3dff			;		push hl 
3dff			; 
3dff			;		; destroy value TOS 
3dff			; 
3dff			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dff			; 
3dff			;		; one value on hl get other one back 
3dff			; 
3dff			;		pop bc    ; count 
3dff			; 
3dff			;		pop de   ; dir 
3dff			; 
3dff			; 
3dff			;		ld b, c 
3dff			; 
3dff			;.scrolldir:     push bc 
3dff			;		push de 
3dff			; 
3dff			;		ld a, 0 
3dff			;		cp e 
3dff			;		jr z, .scrollup  
3dff			;		call scroll_down 
3dff			;		jr .scrollnext 
3dff			;.scrollup:	call scroll_up 
3dff			; 
3dff			;		 
3dff			;.scrollnext: 
3dff			;		pop de 
3dff			;		pop bc 
3dff			;		djnz .scrolldir 
3dff			; 
3dff			; 
3dff			; 
3dff			; 
3dff			; 
3dff			;		NEXTW 
3dff			 
3dff			.SCROLLD: 
3dff				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3dff 53				db WORD_SYS_CORE+63             
3e00 2d 3e			dw .ATQ            
3e02 08				db 7 + 1 
3e03 .. 00			db "SCROLLD",0              
3e0b				endm 
# End of macro CWHEAD
3e0b			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e0b					if DEBUG_FORTH_WORDS_KEY 
3e0b						DMARK "SCD" 
3e0b f5				push af  
3e0c 3a 20 3e			ld a, (.dmark)  
3e0f 32 bd fb			ld (debug_mark),a  
3e12 3a 21 3e			ld a, (.dmark+1)  
3e15 32 be fb			ld (debug_mark+1),a  
3e18 3a 22 3e			ld a, (.dmark+2)  
3e1b 32 bf fb			ld (debug_mark+2),a  
3e1e 18 03			jr .pastdmark  
3e20 ..			.dmark: db "SCD"  
3e23 f1			.pastdmark: pop af  
3e24			endm  
# End of macro DMARK
3e24						CALLMONITOR 
3e24 cd 1c 17			call break_point_state  
3e27				endm  
# End of macro CALLMONITOR
3e27					endif 
3e27			 
3e27 cd bb 0a			call scroll_down 
3e2a			;	call update_display 
3e2a			 
3e2a					NEXTW 
3e2a c3 15 20			jp macro_next 
3e2d				endm 
# End of macro NEXTW
3e2d			 
3e2d			 
3e2d			.ATQ: 
3e2d				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e2d 62				db WORD_SYS_CORE+78             
3e2e 8b 3e			dw .AUTODSP            
3e30 04				db 3 + 1 
3e31 .. 00			db "AT@",0              
3e35				endm 
# End of macro CWHEAD
3e35			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e35					if DEBUG_FORTH_WORDS_KEY 
3e35						DMARK "ATA" 
3e35 f5				push af  
3e36 3a 4a 3e			ld a, (.dmark)  
3e39 32 bd fb			ld (debug_mark),a  
3e3c 3a 4b 3e			ld a, (.dmark+1)  
3e3f 32 be fb			ld (debug_mark+1),a  
3e42 3a 4c 3e			ld a, (.dmark+2)  
3e45 32 bf fb			ld (debug_mark+2),a  
3e48 18 03			jr .pastdmark  
3e4a ..			.dmark: db "ATA"  
3e4d f1			.pastdmark: pop af  
3e4e			endm  
# End of macro DMARK
3e4e						CALLMONITOR 
3e4e cd 1c 17			call break_point_state  
3e51				endm  
# End of macro CALLMONITOR
3e51					endif 
3e51			 
3e51			 
3e51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e51 cd a3 1e			call macro_dsp_valuehl 
3e54				endm 
# End of macro FORTH_DSP_VALUEHL
3e54			 
3e54					; TODO save cursor row 
3e54 7d					ld a,l 
3e55 fe 02				cp 2 
3e57 20 04				jr nz, .crow3aq 
3e59 3e 14				ld a, display_row_2 
3e5b 18 12				jr .ccol1aq 
3e5d fe 03		.crow3aq:		cp 3 
3e5f 20 04				jr nz, .crow4aq 
3e61 3e 28				ld a, display_row_3 
3e63 18 0a				jr .ccol1aq 
3e65 fe 04		.crow4aq:		cp 4 
3e67 20 04				jr nz, .crow1aq 
3e69 3e 3c				ld a, display_row_4 
3e6b 18 02				jr .ccol1aq 
3e6d 3e 00		.crow1aq:		ld a,display_row_1 
3e6f f5			.ccol1aq:		push af			; got row offset 
3e70 6f					ld l,a 
3e71 26 00				ld h,0 
3e73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e73 cd 5b 1f			call macro_forth_dsp_pop 
3e76				endm 
# End of macro FORTH_DSP_POP
3e76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e76 cd a3 1e			call macro_dsp_valuehl 
3e79				endm 
# End of macro FORTH_DSP_VALUEHL
3e79					; TODO save cursor col 
3e79 f1					pop af 
3e7a 85					add l		; add col offset 
3e7b			 
3e7b					; add current frame buffer address 
3e7b 2a 5e fa				ld hl, (display_fb_active) 
3e7e cd 09 0d				call addatohl 
3e81			 
3e81			 
3e81			 
3e81			 
3e81					; get char frame buffer location offset in hl 
3e81			 
3e81 7e					ld a,(hl) 
3e82 26 00				ld h, 0 
3e84 6f					ld l, a 
3e85			 
3e85 cd ac 1c				call forth_push_numhl 
3e88			 
3e88			 
3e88					NEXTW 
3e88 c3 15 20			jp macro_next 
3e8b				endm 
# End of macro NEXTW
3e8b			 
3e8b			.AUTODSP: 
3e8b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3e8b 63				db WORD_SYS_CORE+79             
3e8c a1 3e			dw .MENU            
3e8e 05				db 4 + 1 
3e8f .. 00			db "ADSP",0              
3e94				endm 
# End of macro CWHEAD
3e94			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3e94			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3e94			 
3e94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e94 cd a3 1e			call macro_dsp_valuehl 
3e97				endm 
# End of macro FORTH_DSP_VALUEHL
3e97			 
3e97			;		push hl 
3e97			 
3e97					; destroy value TOS 
3e97			 
3e97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e97 cd 5b 1f			call macro_forth_dsp_pop 
3e9a				endm 
# End of macro FORTH_DSP_POP
3e9a			 
3e9a			;		pop hl 
3e9a			 
3e9a 7d					ld a,l 
3e9b 32 aa f9				ld (cli_autodisplay), a 
3e9e				       NEXTW 
3e9e c3 15 20			jp macro_next 
3ea1				endm 
# End of macro NEXTW
3ea1			 
3ea1			.MENU: 
3ea1				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3ea1 70				db WORD_SYS_CORE+92             
3ea2 4a 3f			dw .ENDDISPLAY            
3ea4 05				db 4 + 1 
3ea5 .. 00			db "MENU",0              
3eaa				endm 
# End of macro CWHEAD
3eaa			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3eaa			 
3eaa			;		; get number of items on the stack 
3eaa			; 
3eaa				 
3eaa					FORTH_DSP_VALUEHL 
3eaa cd a3 1e			call macro_dsp_valuehl 
3ead				endm 
# End of macro FORTH_DSP_VALUEHL
3ead				 
3ead					if DEBUG_FORTH_WORDS_KEY 
3ead						DMARK "MNU" 
3ead f5				push af  
3eae 3a c2 3e			ld a, (.dmark)  
3eb1 32 bd fb			ld (debug_mark),a  
3eb4 3a c3 3e			ld a, (.dmark+1)  
3eb7 32 be fb			ld (debug_mark+1),a  
3eba 3a c4 3e			ld a, (.dmark+2)  
3ebd 32 bf fb			ld (debug_mark+2),a  
3ec0 18 03			jr .pastdmark  
3ec2 ..			.dmark: db "MNU"  
3ec5 f1			.pastdmark: pop af  
3ec6			endm  
# End of macro DMARK
3ec6						CALLMONITOR 
3ec6 cd 1c 17			call break_point_state  
3ec9				endm  
# End of macro CALLMONITOR
3ec9					endif 
3ec9			 
3ec9 45					ld b, l	 
3eca 05					dec b 
3ecb			 
3ecb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ecb cd 5b 1f			call macro_forth_dsp_pop 
3ece				endm 
# End of macro FORTH_DSP_POP
3ece			 
3ece			 
3ece					; go directly through the stack to pluck out the string pointers and build an array 
3ece			 
3ece			;		FORTH_DSP 
3ece			 
3ece					; hl contains top most stack item 
3ece				 
3ece 11 a3 ef				ld de, scratch 
3ed1			 
3ed1			.mbuild: 
3ed1			 
3ed1					FORTH_DSP_VALUEHL 
3ed1 cd a3 1e			call macro_dsp_valuehl 
3ed4				endm 
# End of macro FORTH_DSP_VALUEHL
3ed4			 
3ed4					if DEBUG_FORTH_WORDS 
3ed4						DMARK "MN3" 
3ed4 f5				push af  
3ed5 3a e9 3e			ld a, (.dmark)  
3ed8 32 bd fb			ld (debug_mark),a  
3edb 3a ea 3e			ld a, (.dmark+1)  
3ede 32 be fb			ld (debug_mark+1),a  
3ee1 3a eb 3e			ld a, (.dmark+2)  
3ee4 32 bf fb			ld (debug_mark+2),a  
3ee7 18 03			jr .pastdmark  
3ee9 ..			.dmark: db "MN3"  
3eec f1			.pastdmark: pop af  
3eed			endm  
# End of macro DMARK
3eed						CALLMONITOR 
3eed cd 1c 17			call break_point_state  
3ef0				endm  
# End of macro CALLMONITOR
3ef0					endif 
3ef0 eb					ex de, hl 
3ef1 73					ld (hl), e 
3ef2 23					inc hl 
3ef3 72					ld (hl), d 
3ef4 23					inc hl 
3ef5 eb					ex de, hl 
3ef6			 
3ef6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef6 cd 5b 1f			call macro_forth_dsp_pop 
3ef9				endm 
# End of macro FORTH_DSP_POP
3ef9			 
3ef9 10 d6				djnz .mbuild 
3efb			 
3efb					; done add term 
3efb			 
3efb eb					ex de, hl 
3efc 36 00				ld (hl), 0 
3efe 23					inc hl 
3eff 36 00				ld (hl), 0 
3f01			 
3f01				 
3f01					 
3f01 21 a3 ef				ld hl, scratch 
3f04			 
3f04					if DEBUG_FORTH_WORDS 
3f04						DMARK "MNx" 
3f04 f5				push af  
3f05 3a 19 3f			ld a, (.dmark)  
3f08 32 bd fb			ld (debug_mark),a  
3f0b 3a 1a 3f			ld a, (.dmark+1)  
3f0e 32 be fb			ld (debug_mark+1),a  
3f11 3a 1b 3f			ld a, (.dmark+2)  
3f14 32 bf fb			ld (debug_mark+2),a  
3f17 18 03			jr .pastdmark  
3f19 ..			.dmark: db "MNx"  
3f1c f1			.pastdmark: pop af  
3f1d			endm  
# End of macro DMARK
3f1d						CALLMONITOR 
3f1d cd 1c 17			call break_point_state  
3f20				endm  
# End of macro CALLMONITOR
3f20					endif 
3f20			 
3f20			 
3f20			 
3f20 3e 00				ld a, 0 
3f22 cd 06 0b				call menu 
3f25			 
3f25			 
3f25 6f					ld l, a 
3f26 26 00				ld h, 0 
3f28			 
3f28					if DEBUG_FORTH_WORDS 
3f28						DMARK "MNr" 
3f28 f5				push af  
3f29 3a 3d 3f			ld a, (.dmark)  
3f2c 32 bd fb			ld (debug_mark),a  
3f2f 3a 3e 3f			ld a, (.dmark+1)  
3f32 32 be fb			ld (debug_mark+1),a  
3f35 3a 3f 3f			ld a, (.dmark+2)  
3f38 32 bf fb			ld (debug_mark+2),a  
3f3b 18 03			jr .pastdmark  
3f3d ..			.dmark: db "MNr"  
3f40 f1			.pastdmark: pop af  
3f41			endm  
# End of macro DMARK
3f41						CALLMONITOR 
3f41 cd 1c 17			call break_point_state  
3f44				endm  
# End of macro CALLMONITOR
3f44					endif 
3f44			 
3f44 cd ac 1c				call forth_push_numhl 
3f47			 
3f47			 
3f47			 
3f47			 
3f47				       NEXTW 
3f47 c3 15 20			jp macro_next 
3f4a				endm 
# End of macro NEXTW
3f4a			 
3f4a			 
3f4a			.ENDDISPLAY: 
3f4a			 
3f4a			; eof 
# End of file forth_words_display.asm
3f4a			include "forth_words_str.asm" 
3f4a			 
3f4a			; | ## String Words 
3f4a			 
3f4a			.PTR:   
3f4a			 
3f4a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f4a 48				db WORD_SYS_CORE+52             
3f4b 77 3f			dw .STYPE            
3f4d 04				db 3 + 1 
3f4e .. 00			db "PTR",0              
3f52				endm 
# End of macro CWHEAD
3f52			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f52			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f52			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f52			 
3f52					if DEBUG_FORTH_WORDS_KEY 
3f52						DMARK "PTR" 
3f52 f5				push af  
3f53 3a 67 3f			ld a, (.dmark)  
3f56 32 bd fb			ld (debug_mark),a  
3f59 3a 68 3f			ld a, (.dmark+1)  
3f5c 32 be fb			ld (debug_mark+1),a  
3f5f 3a 69 3f			ld a, (.dmark+2)  
3f62 32 bf fb			ld (debug_mark+2),a  
3f65 18 03			jr .pastdmark  
3f67 ..			.dmark: db "PTR"  
3f6a f1			.pastdmark: pop af  
3f6b			endm  
# End of macro DMARK
3f6b						CALLMONITOR 
3f6b cd 1c 17			call break_point_state  
3f6e				endm  
# End of macro CALLMONITOR
3f6e					endif 
3f6e					FORTH_DSP_VALUEHL 
3f6e cd a3 1e			call macro_dsp_valuehl 
3f71				endm 
# End of macro FORTH_DSP_VALUEHL
3f71 cd ac 1c				call forth_push_numhl 
3f74			 
3f74			 
3f74					NEXTW 
3f74 c3 15 20			jp macro_next 
3f77				endm 
# End of macro NEXTW
3f77			.STYPE: 
3f77				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3f77 48				db WORD_SYS_CORE+52             
3f78 c6 3f			dw .UPPER            
3f7a 06				db 5 + 1 
3f7b .. 00			db "STYPE",0              
3f81				endm 
# End of macro CWHEAD
3f81			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3f81					if DEBUG_FORTH_WORDS_KEY 
3f81						DMARK "STY" 
3f81 f5				push af  
3f82 3a 96 3f			ld a, (.dmark)  
3f85 32 bd fb			ld (debug_mark),a  
3f88 3a 97 3f			ld a, (.dmark+1)  
3f8b 32 be fb			ld (debug_mark+1),a  
3f8e 3a 98 3f			ld a, (.dmark+2)  
3f91 32 bf fb			ld (debug_mark+2),a  
3f94 18 03			jr .pastdmark  
3f96 ..			.dmark: db "STY"  
3f99 f1			.pastdmark: pop af  
3f9a			endm  
# End of macro DMARK
3f9a						CALLMONITOR 
3f9a cd 1c 17			call break_point_state  
3f9d				endm  
# End of macro CALLMONITOR
3f9d					endif 
3f9d					FORTH_DSP 
3f9d cd 69 1e			call macro_forth_dsp 
3fa0				endm 
# End of macro FORTH_DSP
3fa0					;v5 FORTH_DSP_VALUE 
3fa0			 
3fa0 7e					ld a, (hl) 
3fa1			 
3fa1 f5					push af 
3fa2			 
3fa2			; Dont destroy TOS		FORTH_DSP_POP 
3fa2			 
3fa2 f1					pop af 
3fa3			 
3fa3 fe 01				cp DS_TYPE_STR 
3fa5 28 09				jr z, .typestr 
3fa7			 
3fa7 fe 02				cp DS_TYPE_INUM 
3fa9 28 0a				jr z, .typeinum 
3fab			 
3fab 21 c4 3f				ld hl, .tna 
3fae 18 0a				jr .tpush 
3fb0			 
3fb0 21 c0 3f		.typestr:	ld hl, .tstr 
3fb3 18 05				jr .tpush 
3fb5 21 c2 3f		.typeinum:	ld hl, .tinum 
3fb8 18 00				jr .tpush 
3fba			 
3fba			.tpush: 
3fba			 
3fba cd 1a 1d				call forth_push_str 
3fbd			 
3fbd					NEXTW 
3fbd c3 15 20			jp macro_next 
3fc0				endm 
# End of macro NEXTW
3fc0 .. 00		.tstr:	db "s",0 
3fc2 .. 00		.tinum:  db "i",0 
3fc4 .. 00		.tna:   db "?", 0 
3fc6			 
3fc6			 
3fc6			.UPPER: 
3fc6				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3fc6 48				db WORD_SYS_CORE+52             
3fc7 01 40			dw .LOWER            
3fc9 06				db 5 + 1 
3fca .. 00			db "UPPER",0              
3fd0				endm 
# End of macro CWHEAD
3fd0			; | UPPER ( s -- s ) Upper case string s  | DONE 
3fd0					if DEBUG_FORTH_WORDS_KEY 
3fd0						DMARK "UPR" 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 bd fb			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 be fb			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 bf fb			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "UPR"  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9						CALLMONITOR 
3fe9 cd 1c 17			call break_point_state  
3fec				endm  
# End of macro CALLMONITOR
3fec					endif 
3fec			 
3fec					FORTH_DSP 
3fec cd 69 1e			call macro_forth_dsp 
3fef				endm 
# End of macro FORTH_DSP
3fef					 
3fef			; TODO check is string type 
3fef			 
3fef					FORTH_DSP_VALUEHL 
3fef cd a3 1e			call macro_dsp_valuehl 
3ff2				endm 
# End of macro FORTH_DSP_VALUEHL
3ff2			; get pointer to string in hl 
3ff2			 
3ff2 7e			.toup:		ld a, (hl) 
3ff3 fe 00				cp 0 
3ff5 28 07				jr z, .toupdone 
3ff7			 
3ff7 cd 76 10				call to_upper 
3ffa			 
3ffa 77					ld (hl), a 
3ffb 23					inc hl 
3ffc 18 f4				jr .toup 
3ffe			 
3ffe					 
3ffe			 
3ffe			 
3ffe			; for each char convert to upper 
3ffe					 
3ffe			.toupdone: 
3ffe			 
3ffe			 
3ffe					NEXTW 
3ffe c3 15 20			jp macro_next 
4001				endm 
# End of macro NEXTW
4001			.LOWER: 
4001				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4001 48				db WORD_SYS_CORE+52             
4002 3c 40			dw .TCASE            
4004 06				db 5 + 1 
4005 .. 00			db "LOWER",0              
400b				endm 
# End of macro CWHEAD
400b			; | LOWER ( s -- s ) Lower case string s  | DONE 
400b					if DEBUG_FORTH_WORDS_KEY 
400b						DMARK "LWR" 
400b f5				push af  
400c 3a 20 40			ld a, (.dmark)  
400f 32 bd fb			ld (debug_mark),a  
4012 3a 21 40			ld a, (.dmark+1)  
4015 32 be fb			ld (debug_mark+1),a  
4018 3a 22 40			ld a, (.dmark+2)  
401b 32 bf fb			ld (debug_mark+2),a  
401e 18 03			jr .pastdmark  
4020 ..			.dmark: db "LWR"  
4023 f1			.pastdmark: pop af  
4024			endm  
# End of macro DMARK
4024						CALLMONITOR 
4024 cd 1c 17			call break_point_state  
4027				endm  
# End of macro CALLMONITOR
4027					endif 
4027			 
4027					FORTH_DSP 
4027 cd 69 1e			call macro_forth_dsp 
402a				endm 
# End of macro FORTH_DSP
402a					 
402a			; TODO check is string type 
402a			 
402a					FORTH_DSP_VALUEHL 
402a cd a3 1e			call macro_dsp_valuehl 
402d				endm 
# End of macro FORTH_DSP_VALUEHL
402d			; get pointer to string in hl 
402d			 
402d 7e			.tolow:		ld a, (hl) 
402e fe 00				cp 0 
4030 28 07				jr z, .tolowdone 
4032			 
4032 cd 7f 10				call to_lower 
4035			 
4035 77					ld (hl), a 
4036 23					inc hl 
4037 18 f4				jr .tolow 
4039			 
4039					 
4039			 
4039			 
4039			; for each char convert to low 
4039					 
4039			.tolowdone: 
4039					NEXTW 
4039 c3 15 20			jp macro_next 
403c				endm 
# End of macro NEXTW
403c			.TCASE: 
403c				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
403c 48				db WORD_SYS_CORE+52             
403d 72 41			dw .SUBSTR            
403f 06				db 5 + 1 
4040 .. 00			db "TCASE",0              
4046				endm 
# End of macro CWHEAD
4046			; | TCASE ( s -- s ) Title case string s  | DONE 
4046					if DEBUG_FORTH_WORDS_KEY 
4046						DMARK "TCS" 
4046 f5				push af  
4047 3a 5b 40			ld a, (.dmark)  
404a 32 bd fb			ld (debug_mark),a  
404d 3a 5c 40			ld a, (.dmark+1)  
4050 32 be fb			ld (debug_mark+1),a  
4053 3a 5d 40			ld a, (.dmark+2)  
4056 32 bf fb			ld (debug_mark+2),a  
4059 18 03			jr .pastdmark  
405b ..			.dmark: db "TCS"  
405e f1			.pastdmark: pop af  
405f			endm  
# End of macro DMARK
405f						CALLMONITOR 
405f cd 1c 17			call break_point_state  
4062				endm  
# End of macro CALLMONITOR
4062					endif 
4062			 
4062					FORTH_DSP 
4062 cd 69 1e			call macro_forth_dsp 
4065				endm 
# End of macro FORTH_DSP
4065					 
4065			; TODO check is string type 
4065			 
4065					FORTH_DSP_VALUEHL 
4065 cd a3 1e			call macro_dsp_valuehl 
4068				endm 
# End of macro FORTH_DSP_VALUEHL
4068			; get pointer to string in hl 
4068			 
4068					if DEBUG_FORTH_WORDS 
4068						DMARK "TC1" 
4068 f5				push af  
4069 3a 7d 40			ld a, (.dmark)  
406c 32 bd fb			ld (debug_mark),a  
406f 3a 7e 40			ld a, (.dmark+1)  
4072 32 be fb			ld (debug_mark+1),a  
4075 3a 7f 40			ld a, (.dmark+2)  
4078 32 bf fb			ld (debug_mark+2),a  
407b 18 03			jr .pastdmark  
407d ..			.dmark: db "TC1"  
4080 f1			.pastdmark: pop af  
4081			endm  
# End of macro DMARK
4081						CALLMONITOR 
4081 cd 1c 17			call break_point_state  
4084				endm  
# End of macro CALLMONITOR
4084					endif 
4084			 
4084					; first time in turn to upper case first char 
4084			 
4084 7e					ld a, (hl) 
4085 c3 0f 41				jp .totsiptou 
4088			 
4088			 
4088 7e			.tot:		ld a, (hl) 
4089 fe 00				cp 0 
408b ca 53 41				jp z, .totdone 
408e			 
408e					if DEBUG_FORTH_WORDS 
408e						DMARK "TC2" 
408e f5				push af  
408f 3a a3 40			ld a, (.dmark)  
4092 32 bd fb			ld (debug_mark),a  
4095 3a a4 40			ld a, (.dmark+1)  
4098 32 be fb			ld (debug_mark+1),a  
409b 3a a5 40			ld a, (.dmark+2)  
409e 32 bf fb			ld (debug_mark+2),a  
40a1 18 03			jr .pastdmark  
40a3 ..			.dmark: db "TC2"  
40a6 f1			.pastdmark: pop af  
40a7			endm  
# End of macro DMARK
40a7						CALLMONITOR 
40a7 cd 1c 17			call break_point_state  
40aa				endm  
# End of macro CALLMONITOR
40aa					endif 
40aa					; check to see if current char is a space 
40aa			 
40aa fe 20				cp ' ' 
40ac 28 21				jr z, .totsp 
40ae cd 7f 10				call to_lower 
40b1					if DEBUG_FORTH_WORDS 
40b1						DMARK "TC3" 
40b1 f5				push af  
40b2 3a c6 40			ld a, (.dmark)  
40b5 32 bd fb			ld (debug_mark),a  
40b8 3a c7 40			ld a, (.dmark+1)  
40bb 32 be fb			ld (debug_mark+1),a  
40be 3a c8 40			ld a, (.dmark+2)  
40c1 32 bf fb			ld (debug_mark+2),a  
40c4 18 03			jr .pastdmark  
40c6 ..			.dmark: db "TC3"  
40c9 f1			.pastdmark: pop af  
40ca			endm  
# End of macro DMARK
40ca						CALLMONITOR 
40ca cd 1c 17			call break_point_state  
40cd				endm  
# End of macro CALLMONITOR
40cd					endif 
40cd 18 63				jr .totnxt 
40cf			 
40cf			.totsp:         ; on a space, find next char which should be upper 
40cf			 
40cf					if DEBUG_FORTH_WORDS 
40cf						DMARK "TC4" 
40cf f5				push af  
40d0 3a e4 40			ld a, (.dmark)  
40d3 32 bd fb			ld (debug_mark),a  
40d6 3a e5 40			ld a, (.dmark+1)  
40d9 32 be fb			ld (debug_mark+1),a  
40dc 3a e6 40			ld a, (.dmark+2)  
40df 32 bf fb			ld (debug_mark+2),a  
40e2 18 03			jr .pastdmark  
40e4 ..			.dmark: db "TC4"  
40e7 f1			.pastdmark: pop af  
40e8			endm  
# End of macro DMARK
40e8						CALLMONITOR 
40e8 cd 1c 17			call break_point_state  
40eb				endm  
# End of macro CALLMONITOR
40eb					endif 
40eb					;; 
40eb			 
40eb fe 20				cp ' ' 
40ed 20 20				jr nz, .totsiptou 
40ef 23					inc hl 
40f0 7e					ld a, (hl) 
40f1					if DEBUG_FORTH_WORDS 
40f1						DMARK "TC5" 
40f1 f5				push af  
40f2 3a 06 41			ld a, (.dmark)  
40f5 32 bd fb			ld (debug_mark),a  
40f8 3a 07 41			ld a, (.dmark+1)  
40fb 32 be fb			ld (debug_mark+1),a  
40fe 3a 08 41			ld a, (.dmark+2)  
4101 32 bf fb			ld (debug_mark+2),a  
4104 18 03			jr .pastdmark  
4106 ..			.dmark: db "TC5"  
4109 f1			.pastdmark: pop af  
410a			endm  
# End of macro DMARK
410a						CALLMONITOR 
410a cd 1c 17			call break_point_state  
410d				endm  
# End of macro CALLMONITOR
410d					endif 
410d 18 c0				jr .totsp 
410f fe 00		.totsiptou:    cp 0 
4111 28 40				jr z, .totdone 
4113					; not space and not zero term so upper case it 
4113 cd 76 10				call to_upper 
4116			 
4116					if DEBUG_FORTH_WORDS 
4116						DMARK "TC6" 
4116 f5				push af  
4117 3a 2b 41			ld a, (.dmark)  
411a 32 bd fb			ld (debug_mark),a  
411d 3a 2c 41			ld a, (.dmark+1)  
4120 32 be fb			ld (debug_mark+1),a  
4123 3a 2d 41			ld a, (.dmark+2)  
4126 32 bf fb			ld (debug_mark+2),a  
4129 18 03			jr .pastdmark  
412b ..			.dmark: db "TC6"  
412e f1			.pastdmark: pop af  
412f			endm  
# End of macro DMARK
412f						CALLMONITOR 
412f cd 1c 17			call break_point_state  
4132				endm  
# End of macro CALLMONITOR
4132					endif 
4132			 
4132			 
4132			.totnxt: 
4132			 
4132 77					ld (hl), a 
4133 23					inc hl 
4134					if DEBUG_FORTH_WORDS 
4134						DMARK "TC7" 
4134 f5				push af  
4135 3a 49 41			ld a, (.dmark)  
4138 32 bd fb			ld (debug_mark),a  
413b 3a 4a 41			ld a, (.dmark+1)  
413e 32 be fb			ld (debug_mark+1),a  
4141 3a 4b 41			ld a, (.dmark+2)  
4144 32 bf fb			ld (debug_mark+2),a  
4147 18 03			jr .pastdmark  
4149 ..			.dmark: db "TC7"  
414c f1			.pastdmark: pop af  
414d			endm  
# End of macro DMARK
414d						CALLMONITOR 
414d cd 1c 17			call break_point_state  
4150				endm  
# End of macro CALLMONITOR
4150					endif 
4150 c3 88 40				jp .tot 
4153			 
4153					 
4153			 
4153			 
4153			; for each char convert to low 
4153					 
4153			.totdone: 
4153					if DEBUG_FORTH_WORDS 
4153						DMARK "TCd" 
4153 f5				push af  
4154 3a 68 41			ld a, (.dmark)  
4157 32 bd fb			ld (debug_mark),a  
415a 3a 69 41			ld a, (.dmark+1)  
415d 32 be fb			ld (debug_mark+1),a  
4160 3a 6a 41			ld a, (.dmark+2)  
4163 32 bf fb			ld (debug_mark+2),a  
4166 18 03			jr .pastdmark  
4168 ..			.dmark: db "TCd"  
416b f1			.pastdmark: pop af  
416c			endm  
# End of macro DMARK
416c						CALLMONITOR 
416c cd 1c 17			call break_point_state  
416f				endm  
# End of macro CALLMONITOR
416f					endif 
416f					NEXTW 
416f c3 15 20			jp macro_next 
4172				endm 
# End of macro NEXTW
4172			 
4172			.SUBSTR: 
4172				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4172 48				db WORD_SYS_CORE+52             
4173 d0 41			dw .LEFT            
4175 07				db 6 + 1 
4176 .. 00			db "SUBSTR",0              
417d				endm 
# End of macro CWHEAD
417d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
417d			 
417d					if DEBUG_FORTH_WORDS_KEY 
417d						DMARK "SST" 
417d f5				push af  
417e 3a 92 41			ld a, (.dmark)  
4181 32 bd fb			ld (debug_mark),a  
4184 3a 93 41			ld a, (.dmark+1)  
4187 32 be fb			ld (debug_mark+1),a  
418a 3a 94 41			ld a, (.dmark+2)  
418d 32 bf fb			ld (debug_mark+2),a  
4190 18 03			jr .pastdmark  
4192 ..			.dmark: db "SST"  
4195 f1			.pastdmark: pop af  
4196			endm  
# End of macro DMARK
4196						CALLMONITOR 
4196 cd 1c 17			call break_point_state  
4199				endm  
# End of macro CALLMONITOR
4199					endif 
4199			; TODO check string type 
4199					FORTH_DSP_VALUEHL 
4199 cd a3 1e			call macro_dsp_valuehl 
419c				endm 
# End of macro FORTH_DSP_VALUEHL
419c			 
419c e5					push hl      ; string length 
419d			 
419d					FORTH_DSP_POP 
419d cd 5b 1f			call macro_forth_dsp_pop 
41a0				endm 
# End of macro FORTH_DSP_POP
41a0			 
41a0					FORTH_DSP_VALUEHL 
41a0 cd a3 1e			call macro_dsp_valuehl 
41a3				endm 
# End of macro FORTH_DSP_VALUEHL
41a3			 
41a3 e5					push hl     ; start char 
41a4			 
41a4					FORTH_DSP_POP 
41a4 cd 5b 1f			call macro_forth_dsp_pop 
41a7				endm 
# End of macro FORTH_DSP_POP
41a7			 
41a7			 
41a7					FORTH_DSP_VALUE 
41a7 cd 8c 1e			call macro_forth_dsp_value 
41aa				endm 
# End of macro FORTH_DSP_VALUE
41aa			 
41aa d1					pop de    ; get start post offset 
41ab			 
41ab 19					add hl, de    ; starting offset 
41ac			 
41ac c1					pop bc 
41ad c5					push bc      ; grab size of string 
41ae			 
41ae e5					push hl    ; save string start  
41af			 
41af 26 00				ld h, 0 
41b1 69					ld l, c 
41b2 23					inc hl 
41b3 23					inc hl 
41b4			 
41b4 cd d0 11				call malloc 
41b7				if DEBUG_FORTH_MALLOC_GUARD 
41b7 cc 3a 51				call z,malloc_error 
41ba				endif 
41ba			 
41ba eb					ex de, hl      ; save malloc area for string copy 
41bb e1					pop hl    ; get back source 
41bc c1					pop bc    ; get length of string back 
41bd			 
41bd d5					push de    ; save malloc area for after we push 
41be ed b0				ldir     ; copy substr 
41c0			 
41c0			 
41c0 eb					ex de, hl 
41c1 3e 00				ld a, 0 
41c3 77					ld (hl), a   ; term substr 
41c4			 
41c4					 
41c4 e1					pop hl    ; get malloc so we can push it 
41c5 e5					push hl   ; save so we can free it afterwards 
41c6			 
41c6 cd 1a 1d				call forth_push_str 
41c9			 
41c9 e1					pop hl 
41ca cd 9a 12				call free 
41cd			 
41cd					 
41cd					 
41cd			 
41cd			 
41cd					NEXTW 
41cd c3 15 20			jp macro_next 
41d0				endm 
# End of macro NEXTW
41d0			 
41d0			.LEFT: 
41d0				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
41d0 48				db WORD_SYS_CORE+52             
41d1 f8 41			dw .RIGHT            
41d3 05				db 4 + 1 
41d4 .. 00			db "LEFT",0              
41d9				endm 
# End of macro CWHEAD
41d9			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
41d9					if DEBUG_FORTH_WORDS_KEY 
41d9						DMARK "LEF" 
41d9 f5				push af  
41da 3a ee 41			ld a, (.dmark)  
41dd 32 bd fb			ld (debug_mark),a  
41e0 3a ef 41			ld a, (.dmark+1)  
41e3 32 be fb			ld (debug_mark+1),a  
41e6 3a f0 41			ld a, (.dmark+2)  
41e9 32 bf fb			ld (debug_mark+2),a  
41ec 18 03			jr .pastdmark  
41ee ..			.dmark: db "LEF"  
41f1 f1			.pastdmark: pop af  
41f2			endm  
# End of macro DMARK
41f2						CALLMONITOR 
41f2 cd 1c 17			call break_point_state  
41f5				endm  
# End of macro CALLMONITOR
41f5					endif 
41f5			 
41f5					NEXTW 
41f5 c3 15 20			jp macro_next 
41f8				endm 
# End of macro NEXTW
41f8			.RIGHT: 
41f8				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
41f8 48				db WORD_SYS_CORE+52             
41f9 21 42			dw .STR2NUM            
41fb 06				db 5 + 1 
41fc .. 00			db "RIGHT",0              
4202				endm 
# End of macro CWHEAD
4202			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4202					if DEBUG_FORTH_WORDS_KEY 
4202						DMARK "RIG" 
4202 f5				push af  
4203 3a 17 42			ld a, (.dmark)  
4206 32 bd fb			ld (debug_mark),a  
4209 3a 18 42			ld a, (.dmark+1)  
420c 32 be fb			ld (debug_mark+1),a  
420f 3a 19 42			ld a, (.dmark+2)  
4212 32 bf fb			ld (debug_mark+2),a  
4215 18 03			jr .pastdmark  
4217 ..			.dmark: db "RIG"  
421a f1			.pastdmark: pop af  
421b			endm  
# End of macro DMARK
421b						CALLMONITOR 
421b cd 1c 17			call break_point_state  
421e				endm  
# End of macro CALLMONITOR
421e					endif 
421e			 
421e					NEXTW 
421e c3 15 20			jp macro_next 
4221				endm 
# End of macro NEXTW
4221			 
4221			 
4221			.STR2NUM: 
4221				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4221 48				db WORD_SYS_CORE+52             
4222 ad 42			dw .NUM2STR            
4224 08				db 7 + 1 
4225 .. 00			db "STR2NUM",0              
422d				endm 
# End of macro CWHEAD
422d			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
422d			 
422d			 
422d			; TODO STR type check to do 
422d					if DEBUG_FORTH_WORDS_KEY 
422d						DMARK "S2N" 
422d f5				push af  
422e 3a 42 42			ld a, (.dmark)  
4231 32 bd fb			ld (debug_mark),a  
4234 3a 43 42			ld a, (.dmark+1)  
4237 32 be fb			ld (debug_mark+1),a  
423a 3a 44 42			ld a, (.dmark+2)  
423d 32 bf fb			ld (debug_mark+2),a  
4240 18 03			jr .pastdmark  
4242 ..			.dmark: db "S2N"  
4245 f1			.pastdmark: pop af  
4246			endm  
# End of macro DMARK
4246						CALLMONITOR 
4246 cd 1c 17			call break_point_state  
4249				endm  
# End of macro CALLMONITOR
4249					endif 
4249			 
4249					;FORTH_DSP 
4249					FORTH_DSP_VALUE 
4249 cd 8c 1e			call macro_forth_dsp_value 
424c				endm 
# End of macro FORTH_DSP_VALUE
424c					;inc hl 
424c			 
424c eb					ex de, hl 
424d					if DEBUG_FORTH_WORDS 
424d						DMARK "S2a" 
424d f5				push af  
424e 3a 62 42			ld a, (.dmark)  
4251 32 bd fb			ld (debug_mark),a  
4254 3a 63 42			ld a, (.dmark+1)  
4257 32 be fb			ld (debug_mark+1),a  
425a 3a 64 42			ld a, (.dmark+2)  
425d 32 bf fb			ld (debug_mark+2),a  
4260 18 03			jr .pastdmark  
4262 ..			.dmark: db "S2a"  
4265 f1			.pastdmark: pop af  
4266			endm  
# End of macro DMARK
4266						CALLMONITOR 
4266 cd 1c 17			call break_point_state  
4269				endm  
# End of macro CALLMONITOR
4269					endif 
4269 cd fe 10				call string_to_uint16 
426c			 
426c					if DEBUG_FORTH_WORDS 
426c						DMARK "S2b" 
426c f5				push af  
426d 3a 81 42			ld a, (.dmark)  
4270 32 bd fb			ld (debug_mark),a  
4273 3a 82 42			ld a, (.dmark+1)  
4276 32 be fb			ld (debug_mark+1),a  
4279 3a 83 42			ld a, (.dmark+2)  
427c 32 bf fb			ld (debug_mark+2),a  
427f 18 03			jr .pastdmark  
4281 ..			.dmark: db "S2b"  
4284 f1			.pastdmark: pop af  
4285			endm  
# End of macro DMARK
4285						CALLMONITOR 
4285 cd 1c 17			call break_point_state  
4288				endm  
# End of macro CALLMONITOR
4288					endif 
4288			;		push hl 
4288					FORTH_DSP_POP 
4288 cd 5b 1f			call macro_forth_dsp_pop 
428b				endm 
# End of macro FORTH_DSP_POP
428b			;		pop hl 
428b					 
428b					if DEBUG_FORTH_WORDS 
428b						DMARK "S2b" 
428b f5				push af  
428c 3a a0 42			ld a, (.dmark)  
428f 32 bd fb			ld (debug_mark),a  
4292 3a a1 42			ld a, (.dmark+1)  
4295 32 be fb			ld (debug_mark+1),a  
4298 3a a2 42			ld a, (.dmark+2)  
429b 32 bf fb			ld (debug_mark+2),a  
429e 18 03			jr .pastdmark  
42a0 ..			.dmark: db "S2b"  
42a3 f1			.pastdmark: pop af  
42a4			endm  
# End of macro DMARK
42a4						CALLMONITOR 
42a4 cd 1c 17			call break_point_state  
42a7				endm  
# End of macro CALLMONITOR
42a7					endif 
42a7 cd ac 1c				call forth_push_numhl	 
42aa			 
42aa				 
42aa				       NEXTW 
42aa c3 15 20			jp macro_next 
42ad				endm 
# End of macro NEXTW
42ad			.NUM2STR: 
42ad				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
42ad 48				db WORD_SYS_CORE+52             
42ae bc 42			dw .CONCAT            
42b0 08				db 7 + 1 
42b1 .. 00			db "NUM2STR",0              
42b9				endm 
# End of macro CWHEAD
42b9			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
42b9			 
42b9			;		; malloc a string to target 
42b9			;		ld hl, 10     ; TODO max string size should be fine 
42b9			;		call malloc 
42b9			;		push hl    ; save malloc location 
42b9			; 
42b9			; 
42b9			;; TODO check int type 
42b9			;		FORTH_DSP_VALUEHL 
42b9			;		ld a, l 
42b9			;		call DispAToASCII   
42b9			;;TODO need to chage above call to dump into string 
42b9			; 
42b9			; 
42b9			 
42b9				       NEXTW 
42b9 c3 15 20			jp macro_next 
42bc				endm 
# End of macro NEXTW
42bc			 
42bc			.CONCAT: 
42bc				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
42bc 48				db WORD_SYS_CORE+52             
42bd 6f 43			dw .FIND            
42bf 07				db 6 + 1 
42c0 .. 00			db "CONCAT",0              
42c7				endm 
# End of macro CWHEAD
42c7			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
42c7			 
42c7			; TODO check string type 
42c7			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
42c7			 
42c7					if DEBUG_FORTH_WORDS_KEY 
42c7						DMARK "CON" 
42c7 f5				push af  
42c8 3a dc 42			ld a, (.dmark)  
42cb 32 bd fb			ld (debug_mark),a  
42ce 3a dd 42			ld a, (.dmark+1)  
42d1 32 be fb			ld (debug_mark+1),a  
42d4 3a de 42			ld a, (.dmark+2)  
42d7 32 bf fb			ld (debug_mark+2),a  
42da 18 03			jr .pastdmark  
42dc ..			.dmark: db "CON"  
42df f1			.pastdmark: pop af  
42e0			endm  
# End of macro DMARK
42e0						CALLMONITOR 
42e0 cd 1c 17			call break_point_state  
42e3				endm  
# End of macro CALLMONITOR
42e3					endif 
42e3			 
42e3			 
42e3					FORTH_DSP_VALUE 
42e3 cd 8c 1e			call macro_forth_dsp_value 
42e6				endm 
# End of macro FORTH_DSP_VALUE
42e6 e5					push hl   ; s2 
42e7			 
42e7					FORTH_DSP_POP 
42e7 cd 5b 1f			call macro_forth_dsp_pop 
42ea				endm 
# End of macro FORTH_DSP_POP
42ea			 
42ea					FORTH_DSP_VALUE 
42ea cd 8c 1e			call macro_forth_dsp_value 
42ed				endm 
# End of macro FORTH_DSP_VALUE
42ed			 
42ed e5					push hl   ; s1 
42ee			 
42ee					FORTH_DSP_POP 
42ee cd 5b 1f			call macro_forth_dsp_pop 
42f1				endm 
# End of macro FORTH_DSP_POP
42f1					 
42f1			 
42f1					; copy s1 
42f1			 
42f1				 
42f1					; save ptr 
42f1 e1					pop hl  
42f2 e5					push hl 
42f3 3e 00				ld a, 0 
42f5 cd 72 11				call strlent 
42f8					;inc hl    ; zer0 
42f8 06 00				ld b, 0 
42fa 4d					ld c, l 
42fb e1					pop hl		 
42fc 11 a3 ef				ld de, scratch	 
42ff					if DEBUG_FORTH_WORDS 
42ff						DMARK "CO1" 
42ff f5				push af  
4300 3a 14 43			ld a, (.dmark)  
4303 32 bd fb			ld (debug_mark),a  
4306 3a 15 43			ld a, (.dmark+1)  
4309 32 be fb			ld (debug_mark+1),a  
430c 3a 16 43			ld a, (.dmark+2)  
430f 32 bf fb			ld (debug_mark+2),a  
4312 18 03			jr .pastdmark  
4314 ..			.dmark: db "CO1"  
4317 f1			.pastdmark: pop af  
4318			endm  
# End of macro DMARK
4318						CALLMONITOR 
4318 cd 1c 17			call break_point_state  
431b				endm  
# End of macro CALLMONITOR
431b					endif 
431b ed b0				ldir 
431d			 
431d e1					pop hl 
431e e5					push hl 
431f d5					push de 
4320			 
4320			 
4320 3e 00				ld a, 0 
4322 cd 72 11				call strlent 
4325 23					inc hl    ; zer0 
4326 23					inc hl 
4327 06 00				ld b, 0 
4329 4d					ld c, l 
432a d1					pop de 
432b e1					pop hl		 
432c					if DEBUG_FORTH_WORDS 
432c						DMARK "CO2" 
432c f5				push af  
432d 3a 41 43			ld a, (.dmark)  
4330 32 bd fb			ld (debug_mark),a  
4333 3a 42 43			ld a, (.dmark+1)  
4336 32 be fb			ld (debug_mark+1),a  
4339 3a 43 43			ld a, (.dmark+2)  
433c 32 bf fb			ld (debug_mark+2),a  
433f 18 03			jr .pastdmark  
4341 ..			.dmark: db "CO2"  
4344 f1			.pastdmark: pop af  
4345			endm  
# End of macro DMARK
4345						CALLMONITOR 
4345 cd 1c 17			call break_point_state  
4348				endm  
# End of macro CALLMONITOR
4348					endif 
4348 ed b0				ldir 
434a			 
434a			 
434a			 
434a 21 a3 ef				ld hl, scratch 
434d					if DEBUG_FORTH_WORDS 
434d						DMARK "CO5" 
434d f5				push af  
434e 3a 62 43			ld a, (.dmark)  
4351 32 bd fb			ld (debug_mark),a  
4354 3a 63 43			ld a, (.dmark+1)  
4357 32 be fb			ld (debug_mark+1),a  
435a 3a 64 43			ld a, (.dmark+2)  
435d 32 bf fb			ld (debug_mark+2),a  
4360 18 03			jr .pastdmark  
4362 ..			.dmark: db "CO5"  
4365 f1			.pastdmark: pop af  
4366			endm  
# End of macro DMARK
4366						CALLMONITOR 
4366 cd 1c 17			call break_point_state  
4369				endm  
# End of macro CALLMONITOR
4369					endif 
4369			 
4369 cd 1a 1d				call forth_push_str 
436c			 
436c			 
436c			 
436c			 
436c				       NEXTW 
436c c3 15 20			jp macro_next 
436f				endm 
# End of macro NEXTW
436f			 
436f			 
436f			.FIND: 
436f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
436f 4b				db WORD_SYS_CORE+55             
4370 2d 44			dw .LEN            
4372 05				db 4 + 1 
4373 .. 00			db "FIND",0              
4378				endm 
# End of macro CWHEAD
4378			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4378			 
4378					if DEBUG_FORTH_WORDS_KEY 
4378						DMARK "FND" 
4378 f5				push af  
4379 3a 8d 43			ld a, (.dmark)  
437c 32 bd fb			ld (debug_mark),a  
437f 3a 8e 43			ld a, (.dmark+1)  
4382 32 be fb			ld (debug_mark+1),a  
4385 3a 8f 43			ld a, (.dmark+2)  
4388 32 bf fb			ld (debug_mark+2),a  
438b 18 03			jr .pastdmark  
438d ..			.dmark: db "FND"  
4390 f1			.pastdmark: pop af  
4391			endm  
# End of macro DMARK
4391						CALLMONITOR 
4391 cd 1c 17			call break_point_state  
4394				endm  
# End of macro CALLMONITOR
4394					endif 
4394			 
4394			; TODO check string type 
4394					FORTH_DSP_VALUE 
4394 cd 8c 1e			call macro_forth_dsp_value 
4397				endm 
# End of macro FORTH_DSP_VALUE
4397			 
4397 e5					push hl    
4398 7e					ld a,(hl)    ; char to find   
4399			; TODO change char to substr 
4399			 
4399 f5					push af 
439a					 
439a			 
439a			 
439a					if DEBUG_FORTH_WORDS 
439a						DMARK "FN1" 
439a f5				push af  
439b 3a af 43			ld a, (.dmark)  
439e 32 bd fb			ld (debug_mark),a  
43a1 3a b0 43			ld a, (.dmark+1)  
43a4 32 be fb			ld (debug_mark+1),a  
43a7 3a b1 43			ld a, (.dmark+2)  
43aa 32 bf fb			ld (debug_mark+2),a  
43ad 18 03			jr .pastdmark  
43af ..			.dmark: db "FN1"  
43b2 f1			.pastdmark: pop af  
43b3			endm  
# End of macro DMARK
43b3						CALLMONITOR 
43b3 cd 1c 17			call break_point_state  
43b6				endm  
# End of macro CALLMONITOR
43b6					endif 
43b6			 
43b6					FORTH_DSP_POP 
43b6 cd 5b 1f			call macro_forth_dsp_pop 
43b9				endm 
# End of macro FORTH_DSP_POP
43b9			 
43b9					; string to search 
43b9			 
43b9					FORTH_DSP_VALUE 
43b9 cd 8c 1e			call macro_forth_dsp_value 
43bc				endm 
# End of macro FORTH_DSP_VALUE
43bc			 
43bc d1					pop de  ; d is char to find  
43bd			 
43bd					if DEBUG_FORTH_WORDS 
43bd						DMARK "FN2" 
43bd f5				push af  
43be 3a d2 43			ld a, (.dmark)  
43c1 32 bd fb			ld (debug_mark),a  
43c4 3a d3 43			ld a, (.dmark+1)  
43c7 32 be fb			ld (debug_mark+1),a  
43ca 3a d4 43			ld a, (.dmark+2)  
43cd 32 bf fb			ld (debug_mark+2),a  
43d0 18 03			jr .pastdmark  
43d2 ..			.dmark: db "FN2"  
43d5 f1			.pastdmark: pop af  
43d6			endm  
# End of macro DMARK
43d6						CALLMONITOR 
43d6 cd 1c 17			call break_point_state  
43d9				endm  
# End of macro CALLMONITOR
43d9					endif 
43d9					 
43d9 01 00 00				ld bc, 0 
43dc 7e			.findchar:      ld a,(hl) 
43dd fe 00				cp 0   		 
43df 28 27				jr z, .finddone     
43e1 ba					cp d 
43e2 28 20				jr z, .foundchar 
43e4 03					inc bc 
43e5 23					inc hl 
43e6					if DEBUG_FORTH_WORDS 
43e6						DMARK "FN3" 
43e6 f5				push af  
43e7 3a fb 43			ld a, (.dmark)  
43ea 32 bd fb			ld (debug_mark),a  
43ed 3a fc 43			ld a, (.dmark+1)  
43f0 32 be fb			ld (debug_mark+1),a  
43f3 3a fd 43			ld a, (.dmark+2)  
43f6 32 bf fb			ld (debug_mark+2),a  
43f9 18 03			jr .pastdmark  
43fb ..			.dmark: db "FN3"  
43fe f1			.pastdmark: pop af  
43ff			endm  
# End of macro DMARK
43ff						CALLMONITOR 
43ff cd 1c 17			call break_point_state  
4402				endm  
# End of macro CALLMONITOR
4402					endif 
4402 18 d8				jr .findchar 
4404			 
4404			 
4404 c5			.foundchar:	push bc 
4405 e1					pop hl 
4406 18 03				jr .findexit 
4408			 
4408			 
4408							 
4408			 
4408			.finddone:     ; got to end of string with no find 
4408 21 00 00				ld hl, 0 
440b			.findexit: 
440b			 
440b					if DEBUG_FORTH_WORDS 
440b						DMARK "FNd" 
440b f5				push af  
440c 3a 20 44			ld a, (.dmark)  
440f 32 bd fb			ld (debug_mark),a  
4412 3a 21 44			ld a, (.dmark+1)  
4415 32 be fb			ld (debug_mark+1),a  
4418 3a 22 44			ld a, (.dmark+2)  
441b 32 bf fb			ld (debug_mark+2),a  
441e 18 03			jr .pastdmark  
4420 ..			.dmark: db "FNd"  
4423 f1			.pastdmark: pop af  
4424			endm  
# End of macro DMARK
4424						CALLMONITOR 
4424 cd 1c 17			call break_point_state  
4427				endm  
# End of macro CALLMONITOR
4427					endif 
4427 cd ac 1c			call forth_push_numhl 
442a			 
442a				       NEXTW 
442a c3 15 20			jp macro_next 
442d				endm 
# End of macro NEXTW
442d			 
442d			.LEN: 
442d				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
442d 4c				db WORD_SYS_CORE+56             
442e 62 44			dw .CHAR            
4430 06				db 5 + 1 
4431 .. 00			db "COUNT",0              
4437				endm 
# End of macro CWHEAD
4437			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4437			 
4437					if DEBUG_FORTH_WORDS_KEY 
4437						DMARK "CNT" 
4437 f5				push af  
4438 3a 4c 44			ld a, (.dmark)  
443b 32 bd fb			ld (debug_mark),a  
443e 3a 4d 44			ld a, (.dmark+1)  
4441 32 be fb			ld (debug_mark+1),a  
4444 3a 4e 44			ld a, (.dmark+2)  
4447 32 bf fb			ld (debug_mark+2),a  
444a 18 03			jr .pastdmark  
444c ..			.dmark: db "CNT"  
444f f1			.pastdmark: pop af  
4450			endm  
# End of macro DMARK
4450						CALLMONITOR 
4450 cd 1c 17			call break_point_state  
4453				endm  
# End of macro CALLMONITOR
4453					endif 
4453			; TODO check string type 
4453					FORTH_DSP 
4453 cd 69 1e			call macro_forth_dsp 
4456				endm 
# End of macro FORTH_DSP
4456					;v5FORTH_DSP_VALUE 
4456			 
4456 23					inc hl 
4457			 
4457 3e 00				ld a, 0 
4459 cd 72 11				call strlent 
445c			 
445c cd ac 1c				call forth_push_numhl 
445f			 
445f			 
445f			 
445f				       NEXTW 
445f c3 15 20			jp macro_next 
4462				endm 
# End of macro NEXTW
4462			.CHAR: 
4462				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4462 4d				db WORD_SYS_CORE+57             
4463 98 44			dw .ENDSTR            
4465 05				db 4 + 1 
4466 .. 00			db "CHAR",0              
446b				endm 
# End of macro CWHEAD
446b			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
446b					if DEBUG_FORTH_WORDS_KEY 
446b						DMARK "CHR" 
446b f5				push af  
446c 3a 80 44			ld a, (.dmark)  
446f 32 bd fb			ld (debug_mark),a  
4472 3a 81 44			ld a, (.dmark+1)  
4475 32 be fb			ld (debug_mark+1),a  
4478 3a 82 44			ld a, (.dmark+2)  
447b 32 bf fb			ld (debug_mark+2),a  
447e 18 03			jr .pastdmark  
4480 ..			.dmark: db "CHR"  
4483 f1			.pastdmark: pop af  
4484			endm  
# End of macro DMARK
4484						CALLMONITOR 
4484 cd 1c 17			call break_point_state  
4487				endm  
# End of macro CALLMONITOR
4487					endif 
4487					FORTH_DSP 
4487 cd 69 1e			call macro_forth_dsp 
448a				endm 
# End of macro FORTH_DSP
448a					;v5 FORTH_DSP_VALUE 
448a 23					inc hl      ; now at start of numeric as string 
448b			 
448b			;		push hl 
448b			 
448b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
448b cd 5b 1f			call macro_forth_dsp_pop 
448e				endm 
# End of macro FORTH_DSP_POP
448e			 
448e			;		pop hl 
448e			 
448e					; push the content of a onto the stack as a value 
448e			 
448e 7e					ld a,(hl)   ; get char 
448f 26 00				ld h,0 
4491 6f					ld l,a 
4492 cd ac 1c				call forth_push_numhl 
4495			 
4495				       NEXTW 
4495 c3 15 20			jp macro_next 
4498				endm 
# End of macro NEXTW
4498			 
4498			 
4498			 
4498			 
4498			.ENDSTR: 
4498			; eof 
4498			 
# End of file forth_words_str.asm
4498			include "forth_words_key.asm" 
4498			 
4498			; | ## Keyboard Words 
4498			 
4498			.KEY: 
4498				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4498 3e				db WORD_SYS_CORE+42             
4499 c8 44			dw .WAITK            
449b 04				db 3 + 1 
449c .. 00			db "KEY",0              
44a0				endm 
# End of macro CWHEAD
44a0			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44a0			 
44a0					if DEBUG_FORTH_WORDS_KEY 
44a0						DMARK "KEY" 
44a0 f5				push af  
44a1 3a b5 44			ld a, (.dmark)  
44a4 32 bd fb			ld (debug_mark),a  
44a7 3a b6 44			ld a, (.dmark+1)  
44aa 32 be fb			ld (debug_mark+1),a  
44ad 3a b7 44			ld a, (.dmark+2)  
44b0 32 bf fb			ld (debug_mark+2),a  
44b3 18 03			jr .pastdmark  
44b5 ..			.dmark: db "KEY"  
44b8 f1			.pastdmark: pop af  
44b9			endm  
# End of macro DMARK
44b9						CALLMONITOR 
44b9 cd 1c 17			call break_point_state  
44bc				endm  
# End of macro CALLMONITOR
44bc					endif 
44bc			; TODO currently waits 
44bc cd ca 66				call cin 
44bf					;call cin_wait 
44bf 6f					ld l, a 
44c0 26 00				ld h, 0 
44c2 cd ac 1c				call forth_push_numhl 
44c5					NEXTW 
44c5 c3 15 20			jp macro_next 
44c8				endm 
# End of macro NEXTW
44c8			.WAITK: 
44c8				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
44c8 3f				db WORD_SYS_CORE+43             
44c9 fa 44			dw .ACCEPT            
44cb 06				db 5 + 1 
44cc .. 00			db "WAITK",0              
44d2				endm 
# End of macro CWHEAD
44d2			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
44d2					if DEBUG_FORTH_WORDS_KEY 
44d2						DMARK "WAI" 
44d2 f5				push af  
44d3 3a e7 44			ld a, (.dmark)  
44d6 32 bd fb			ld (debug_mark),a  
44d9 3a e8 44			ld a, (.dmark+1)  
44dc 32 be fb			ld (debug_mark+1),a  
44df 3a e9 44			ld a, (.dmark+2)  
44e2 32 bf fb			ld (debug_mark+2),a  
44e5 18 03			jr .pastdmark  
44e7 ..			.dmark: db "WAI"  
44ea f1			.pastdmark: pop af  
44eb			endm  
# End of macro DMARK
44eb						CALLMONITOR 
44eb cd 1c 17			call break_point_state  
44ee				endm  
# End of macro CALLMONITOR
44ee					endif 
44ee cd b9 66				call cin_wait 
44f1 6f					ld l, a 
44f2 26 00				ld h, 0 
44f4 cd ac 1c				call forth_push_numhl 
44f7					NEXTW 
44f7 c3 15 20			jp macro_next 
44fa				endm 
# End of macro NEXTW
44fa			.ACCEPT: 
44fa				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
44fa 40				db WORD_SYS_CORE+44             
44fb 58 45			dw .EDIT            
44fd 07				db 6 + 1 
44fe .. 00			db "ACCEPT",0              
4505				endm 
# End of macro CWHEAD
4505			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4505					; TODO crashes on push 
4505					if DEBUG_FORTH_WORDS_KEY 
4505						DMARK "ACC" 
4505 f5				push af  
4506 3a 1a 45			ld a, (.dmark)  
4509 32 bd fb			ld (debug_mark),a  
450c 3a 1b 45			ld a, (.dmark+1)  
450f 32 be fb			ld (debug_mark+1),a  
4512 3a 1c 45			ld a, (.dmark+2)  
4515 32 bf fb			ld (debug_mark+2),a  
4518 18 03			jr .pastdmark  
451a ..			.dmark: db "ACC"  
451d f1			.pastdmark: pop af  
451e			endm  
# End of macro DMARK
451e						CALLMONITOR 
451e cd 1c 17			call break_point_state  
4521				endm  
# End of macro CALLMONITOR
4521					endif 
4521 21 a1 f1				ld hl, os_input 
4524 3e 00				ld a, 0 
4526 77					ld (hl),a 
4527 3a cc f9				ld a,(f_cursor_ptr) 
452a 16 64				ld d, 100 
452c 0e 00				ld c, 0 
452e 1e 28				ld e, 40 
4530 cd 36 0d				call input_str 
4533					; TODO perhaps do a type check and wrap in quotes if not a number 
4533 21 a1 f1				ld hl, os_input 
4536					if DEBUG_FORTH_WORDS 
4536						DMARK "AC1" 
4536 f5				push af  
4537 3a 4b 45			ld a, (.dmark)  
453a 32 bd fb			ld (debug_mark),a  
453d 3a 4c 45			ld a, (.dmark+1)  
4540 32 be fb			ld (debug_mark+1),a  
4543 3a 4d 45			ld a, (.dmark+2)  
4546 32 bf fb			ld (debug_mark+2),a  
4549 18 03			jr .pastdmark  
454b ..			.dmark: db "AC1"  
454e f1			.pastdmark: pop af  
454f			endm  
# End of macro DMARK
454f						CALLMONITOR 
454f cd 1c 17			call break_point_state  
4552				endm  
# End of macro CALLMONITOR
4552					endif 
4552 cd 1a 1d				call forth_push_str 
4555					NEXTW 
4555 c3 15 20			jp macro_next 
4558				endm 
# End of macro NEXTW
4558			 
4558			.EDIT: 
4558				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4558 40				db WORD_SYS_CORE+44             
4559 e1 45			dw .ENDKEY            
455b 05				db 4 + 1 
455c .. 00			db "EDIT",0              
4561				endm 
# End of macro CWHEAD
4561			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4561			 
4561					; TODO does not copy from stack 
4561					if DEBUG_FORTH_WORDS_KEY 
4561						DMARK "EDT" 
4561 f5				push af  
4562 3a 76 45			ld a, (.dmark)  
4565 32 bd fb			ld (debug_mark),a  
4568 3a 77 45			ld a, (.dmark+1)  
456b 32 be fb			ld (debug_mark+1),a  
456e 3a 78 45			ld a, (.dmark+2)  
4571 32 bf fb			ld (debug_mark+2),a  
4574 18 03			jr .pastdmark  
4576 ..			.dmark: db "EDT"  
4579 f1			.pastdmark: pop af  
457a			endm  
# End of macro DMARK
457a						CALLMONITOR 
457a cd 1c 17			call break_point_state  
457d				endm  
# End of macro CALLMONITOR
457d					endif 
457d			 
457d					FORTH_DSP 
457d cd 69 1e			call macro_forth_dsp 
4580				endm 
# End of macro FORTH_DSP
4580					;v5 FORTH_DSP_VALUE 
4580 23					inc hl    ; TODO do type check 
4581			 
4581 e5					push hl 
4582 3e 00				ld a, 0 
4584 cd 72 11				call strlent 
4587 23					inc hl 
4588			 
4588 06 00				ld b, 0 
458a 4d					ld c, l 
458b			 
458b e1					pop hl 
458c 11 a1 f1				ld de, os_input 
458f					if DEBUG_FORTH_WORDS_KEY 
458f						DMARK "EDc" 
458f f5				push af  
4590 3a a4 45			ld a, (.dmark)  
4593 32 bd fb			ld (debug_mark),a  
4596 3a a5 45			ld a, (.dmark+1)  
4599 32 be fb			ld (debug_mark+1),a  
459c 3a a6 45			ld a, (.dmark+2)  
459f 32 bf fb			ld (debug_mark+2),a  
45a2 18 03			jr .pastdmark  
45a4 ..			.dmark: db "EDc"  
45a7 f1			.pastdmark: pop af  
45a8			endm  
# End of macro DMARK
45a8						CALLMONITOR 
45a8 cd 1c 17			call break_point_state  
45ab				endm  
# End of macro CALLMONITOR
45ab					endif 
45ab ed b0				ldir 
45ad			 
45ad			 
45ad 21 a1 f1				ld hl, os_input 
45b0					;ld a, 0 
45b0					;ld (hl),a 
45b0 3a cc f9				ld a,(f_cursor_ptr) 
45b3 16 64				ld d, 100 
45b5 0e 00				ld c, 0 
45b7 1e 28				ld e, 40 
45b9 cd 36 0d				call input_str 
45bc					; TODO perhaps do a type check and wrap in quotes if not a number 
45bc 21 a1 f1				ld hl, os_input 
45bf					if DEBUG_FORTH_WORDS 
45bf						DMARK "ED1" 
45bf f5				push af  
45c0 3a d4 45			ld a, (.dmark)  
45c3 32 bd fb			ld (debug_mark),a  
45c6 3a d5 45			ld a, (.dmark+1)  
45c9 32 be fb			ld (debug_mark+1),a  
45cc 3a d6 45			ld a, (.dmark+2)  
45cf 32 bf fb			ld (debug_mark+2),a  
45d2 18 03			jr .pastdmark  
45d4 ..			.dmark: db "ED1"  
45d7 f1			.pastdmark: pop af  
45d8			endm  
# End of macro DMARK
45d8						CALLMONITOR 
45d8 cd 1c 17			call break_point_state  
45db				endm  
# End of macro CALLMONITOR
45db					endif 
45db cd 1a 1d				call forth_push_str 
45de					NEXTW 
45de c3 15 20			jp macro_next 
45e1				endm 
# End of macro NEXTW
45e1			 
45e1			 
45e1			 
45e1			.ENDKEY: 
45e1			; eof 
45e1			 
# End of file forth_words_key.asm
45e1			 
45e1			if STORAGE_SE 
45e1			   	include "forth_words_storage.asm" 
45e1			 
45e1			; | ## Fixed Storage Words 
45e1			 
45e1			 
45e1			.BREAD: 
45e1			  
45e1				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
45e1 3a				db WORD_SYS_CORE+38             
45e2 5a 46			dw .BWRITE            
45e4 06				db 5 + 1 
45e5 .. 00			db "BREAD",0              
45eb				endm 
# End of macro CWHEAD
45eb			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
45eb				 
45eb					if DEBUG_FORTH_WORDS_KEY 
45eb						DMARK "BRD" 
45eb f5				push af  
45ec 3a 00 46			ld a, (.dmark)  
45ef 32 bd fb			ld (debug_mark),a  
45f2 3a 01 46			ld a, (.dmark+1)  
45f5 32 be fb			ld (debug_mark+1),a  
45f8 3a 02 46			ld a, (.dmark+2)  
45fb 32 bf fb			ld (debug_mark+2),a  
45fe 18 03			jr .pastdmark  
4600 ..			.dmark: db "BRD"  
4603 f1			.pastdmark: pop af  
4604			endm  
# End of macro DMARK
4604						CALLMONITOR 
4604 cd 1c 17			call break_point_state  
4607				endm  
# End of macro CALLMONITOR
4607					endif 
4607			 
4607				FORTH_DSP_VALUEHL 
4607 cd a3 1e			call macro_dsp_valuehl 
460a				endm 
# End of macro FORTH_DSP_VALUEHL
460a			 
460a				FORTH_DSP_POP 
460a cd 5b 1f			call macro_forth_dsp_pop 
460d				endm 
# End of macro FORTH_DSP_POP
460d			 
460d				; calc block address 
460d			 
460d eb				ex de, hl 
460e 3e 40			ld a, STORE_BLOCK_PHY 
4610 cd 8c 0c			call Mult16 
4613			 
4613			 
4613 11 e8 f9			ld de, store_page 
4616			 
4616					if DEBUG_FORTH_WORDS 
4616						DMARK "BR1" 
4616 f5				push af  
4617 3a 2b 46			ld a, (.dmark)  
461a 32 bd fb			ld (debug_mark),a  
461d 3a 2c 46			ld a, (.dmark+1)  
4620 32 be fb			ld (debug_mark+1),a  
4623 3a 2d 46			ld a, (.dmark+2)  
4626 32 bf fb			ld (debug_mark+2),a  
4629 18 03			jr .pastdmark  
462b ..			.dmark: db "BR1"  
462e f1			.pastdmark: pop af  
462f			endm  
# End of macro DMARK
462f						CALLMONITOR 
462f cd 1c 17			call break_point_state  
4632				endm  
# End of macro CALLMONITOR
4632					endif 
4632			 
4632 cd 09 03			call storage_read_block 
4635			 
4635 21 ea f9		        ld hl, store_page+2 
4638					if DEBUG_FORTH_WORDS 
4638						DMARK "BR2" 
4638 f5				push af  
4639 3a 4d 46			ld a, (.dmark)  
463c 32 bd fb			ld (debug_mark),a  
463f 3a 4e 46			ld a, (.dmark+1)  
4642 32 be fb			ld (debug_mark+1),a  
4645 3a 4f 46			ld a, (.dmark+2)  
4648 32 bf fb			ld (debug_mark+2),a  
464b 18 03			jr .pastdmark  
464d ..			.dmark: db "BR2"  
4650 f1			.pastdmark: pop af  
4651			endm  
# End of macro DMARK
4651						CALLMONITOR 
4651 cd 1c 17			call break_point_state  
4654				endm  
# End of macro CALLMONITOR
4654					endif 
4654 cd 1a 1d			call forth_push_str 
4657			 
4657			 
4657					NEXTW 
4657 c3 15 20			jp macro_next 
465a				endm 
# End of macro NEXTW
465a			.BWRITE: 
465a				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
465a 3a				db WORD_SYS_CORE+38             
465b ef 46			dw .BUPD            
465d 07				db 6 + 1 
465e .. 00			db "BWRITE",0              
4665				endm 
# End of macro CWHEAD
4665			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
4665			 
4665					if DEBUG_FORTH_WORDS_KEY 
4665						DMARK "BWR" 
4665 f5				push af  
4666 3a 7a 46			ld a, (.dmark)  
4669 32 bd fb			ld (debug_mark),a  
466c 3a 7b 46			ld a, (.dmark+1)  
466f 32 be fb			ld (debug_mark+1),a  
4672 3a 7c 46			ld a, (.dmark+2)  
4675 32 bf fb			ld (debug_mark+2),a  
4678 18 03			jr .pastdmark  
467a ..			.dmark: db "BWR"  
467d f1			.pastdmark: pop af  
467e			endm  
# End of macro DMARK
467e						CALLMONITOR 
467e cd 1c 17			call break_point_state  
4681				endm  
# End of macro CALLMONITOR
4681					endif 
4681			 
4681				FORTH_DSP_VALUEHL 
4681 cd a3 1e			call macro_dsp_valuehl 
4684				endm 
# End of macro FORTH_DSP_VALUEHL
4684			 
4684				; calc block address 
4684			 
4684 eb				ex de, hl 
4685 3e 40			ld a, STORE_BLOCK_PHY 
4687 cd 8c 0c			call Mult16 
468a			 
468a e5				push hl         ; address 
468b			 
468b				FORTH_DSP_POP 
468b cd 5b 1f			call macro_forth_dsp_pop 
468e				endm 
# End of macro FORTH_DSP_POP
468e			 
468e				FORTH_DSP_VALUEHL 
468e cd a3 1e			call macro_dsp_valuehl 
4691				endm 
# End of macro FORTH_DSP_VALUEHL
4691			 
4691				FORTH_DSP_POP 
4691 cd 5b 1f			call macro_forth_dsp_pop 
4694				endm 
# End of macro FORTH_DSP_POP
4694			 
4694 cd 18 0a			call storage_clear_page 
4697			 
4697				; copy string to store page 
4697			 
4697 e5				push hl     ; save string address 
4698			 
4698 3e 00			ld a, 0 
469a cd 72 11			call strlent 
469d			 
469d 23				inc hl 
469e			 
469e 4d				ld c, l 
469f 06 00			ld b, 0 
46a1			 
46a1 e1				pop hl 
46a2 11 ea f9			ld de, store_page + 2 
46a5					if DEBUG_FORTH_WORDS 
46a5						DMARK "BW1" 
46a5 f5				push af  
46a6 3a ba 46			ld a, (.dmark)  
46a9 32 bd fb			ld (debug_mark),a  
46ac 3a bb 46			ld a, (.dmark+1)  
46af 32 be fb			ld (debug_mark+1),a  
46b2 3a bc 46			ld a, (.dmark+2)  
46b5 32 bf fb			ld (debug_mark+2),a  
46b8 18 03			jr .pastdmark  
46ba ..			.dmark: db "BW1"  
46bd f1			.pastdmark: pop af  
46be			endm  
# End of macro DMARK
46be						CALLMONITOR 
46be cd 1c 17			call break_point_state  
46c1				endm  
# End of macro CALLMONITOR
46c1					endif 
46c1 ed b0			ldir 
46c3			 
46c3			 
46c3				; poke the start of the block with flags to prevent high level file ops hitting the block 
46c3			 
46c3 21 ff ff			ld hl, $ffff 
46c6			 
46c6 22 e8 f9			ld (store_page), hl	 
46c9				 
46c9 e1				pop hl    ; get address 
46ca 11 e8 f9			ld de, store_page 
46cd			 
46cd					if DEBUG_FORTH_WORDS 
46cd						DMARK "BW2" 
46cd f5				push af  
46ce 3a e2 46			ld a, (.dmark)  
46d1 32 bd fb			ld (debug_mark),a  
46d4 3a e3 46			ld a, (.dmark+1)  
46d7 32 be fb			ld (debug_mark+1),a  
46da 3a e4 46			ld a, (.dmark+2)  
46dd 32 bf fb			ld (debug_mark+2),a  
46e0 18 03			jr .pastdmark  
46e2 ..			.dmark: db "BW2"  
46e5 f1			.pastdmark: pop af  
46e6			endm  
# End of macro DMARK
46e6						CALLMONITOR 
46e6 cd 1c 17			call break_point_state  
46e9				endm  
# End of macro CALLMONITOR
46e9					endif 
46e9			 
46e9 cd 6e 03			call storage_write_block 
46ec			 
46ec					NEXTW 
46ec c3 15 20			jp macro_next 
46ef				endm 
# End of macro NEXTW
46ef			 
46ef			.BUPD: 
46ef				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
46ef 3a				db WORD_SYS_CORE+38             
46f0 45 47			dw .BYID            
46f2 05				db 4 + 1 
46f3 .. 00			db "BUPD",0              
46f8				endm 
# End of macro CWHEAD
46f8			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
46f8			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
46f8			; | | or completely different file system structure. 
46f8			 
46f8					if DEBUG_FORTH_WORDS_KEY 
46f8						DMARK "BUD" 
46f8 f5				push af  
46f9 3a 0d 47			ld a, (.dmark)  
46fc 32 bd fb			ld (debug_mark),a  
46ff 3a 0e 47			ld a, (.dmark+1)  
4702 32 be fb			ld (debug_mark+1),a  
4705 3a 0f 47			ld a, (.dmark+2)  
4708 32 bf fb			ld (debug_mark+2),a  
470b 18 03			jr .pastdmark  
470d ..			.dmark: db "BUD"  
4710 f1			.pastdmark: pop af  
4711			endm  
# End of macro DMARK
4711						CALLMONITOR 
4711 cd 1c 17			call break_point_state  
4714				endm  
# End of macro CALLMONITOR
4714					endif 
4714			 
4714				FORTH_DSP_VALUEHL 
4714 cd a3 1e			call macro_dsp_valuehl 
4717				endm 
# End of macro FORTH_DSP_VALUEHL
4717			 
4717				; calc block address 
4717			 
4717 eb				ex de, hl 
4718 3e 40			ld a, STORE_BLOCK_PHY 
471a cd 8c 0c			call Mult16 
471d			 
471d				FORTH_DSP_POP 
471d cd 5b 1f			call macro_forth_dsp_pop 
4720				endm 
# End of macro FORTH_DSP_POP
4720			 
4720			 
4720 11 e8 f9			ld de, store_page 
4723			 
4723					if DEBUG_FORTH_WORDS 
4723						DMARK "BUe" 
4723 f5				push af  
4724 3a 38 47			ld a, (.dmark)  
4727 32 bd fb			ld (debug_mark),a  
472a 3a 39 47			ld a, (.dmark+1)  
472d 32 be fb			ld (debug_mark+1),a  
4730 3a 3a 47			ld a, (.dmark+2)  
4733 32 bf fb			ld (debug_mark+2),a  
4736 18 03			jr .pastdmark  
4738 ..			.dmark: db "BUe"  
473b f1			.pastdmark: pop af  
473c			endm  
# End of macro DMARK
473c						CALLMONITOR 
473c cd 1c 17			call break_point_state  
473f				endm  
# End of macro CALLMONITOR
473f					endif 
473f			 
473f cd 6e 03			call storage_write_block 
4742			 
4742					NEXTW 
4742 c3 15 20			jp macro_next 
4745				endm 
# End of macro NEXTW
4745			 
4745			.BYID: 
4745			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4745			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4745			; 
4745			;		 
4745			;		if DEBUG_FORTH_WORDS_KEY 
4745			;			DMARK "BYID" 
4745			;			CALLMONITOR 
4745			;		endif 
4745			; 
4745			;		; get direct address 
4745			; 
4745			;		FORTH_DSP_VALUEHL 
4745			; 
4745			;		FORTH_DSP_POP 
4745			; 
4745			;	; calc block address 
4745			; 
4745			;	ex de, hl 
4745			;	ld a, STORE_BLOCK_PHY 
4745			;	call Mult16 
4745			;	;	do BREAD with number as param 
4745			;	; push the file name	 
4745			;	ld de, store_page 
4745			;	call storage_read_block 
4745			 ;       ld hl, store_page+2 
4745			; 
4745			; 
4745			;		NEXTW 
4745			;.BYNAME: 
4745			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4745			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
4745			;		NEXTW 
4745			; 
4745			.DIR: 
4745				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4745 3a				db WORD_SYS_CORE+38             
4746 49 48			dw .SAVE            
4748 04				db 3 + 1 
4749 .. 00			db "DIR",0              
474d				endm 
# End of macro CWHEAD
474d			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
474d			 
474d					if DEBUG_FORTH_WORDS_KEY 
474d						DMARK "DIR" 
474d f5				push af  
474e 3a 62 47			ld a, (.dmark)  
4751 32 bd fb			ld (debug_mark),a  
4754 3a 63 47			ld a, (.dmark+1)  
4757 32 be fb			ld (debug_mark+1),a  
475a 3a 64 47			ld a, (.dmark+2)  
475d 32 bf fb			ld (debug_mark+2),a  
4760 18 03			jr .pastdmark  
4762 ..			.dmark: db "DIR"  
4765 f1			.pastdmark: pop af  
4766			endm  
# End of macro DMARK
4766						CALLMONITOR 
4766 cd 1c 17			call break_point_state  
4769				endm  
# End of macro CALLMONITOR
4769					endif 
4769 cd ba 03			call storage_get_block_0 
476c			 
476c 21 e8 f9			ld hl, store_page     ; get current id count 
476f 46				ld b, (hl) 
4770 0e 00			ld c, 0    ; count of files   
4772					if DEBUG_FORTH_WORDS 
4772						DMARK "DI1" 
4772 f5				push af  
4773 3a 87 47			ld a, (.dmark)  
4776 32 bd fb			ld (debug_mark),a  
4779 3a 88 47			ld a, (.dmark+1)  
477c 32 be fb			ld (debug_mark+1),a  
477f 3a 89 47			ld a, (.dmark+2)  
4782 32 bf fb			ld (debug_mark+2),a  
4785 18 03			jr .pastdmark  
4787 ..			.dmark: db "DI1"  
478a f1			.pastdmark: pop af  
478b			endm  
# End of macro DMARK
478b						CALLMONITOR 
478b cd 1c 17			call break_point_state  
478e				endm  
# End of macro CALLMONITOR
478e					endif 
478e			 
478e				; check for empty drive 
478e			 
478e 3e 00			ld a, 0 
4790 b8				cp b 
4791 ca ff 47			jp z, .dirdone 
4794			 
4794				; for each of the current ids do a search for them and if found push to stack 
4794			 
4794 c5			.diritem:	push bc 
4795 21 40 00				ld hl, STORE_BLOCK_PHY 
4798 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
479a 58					ld e,b 
479b			 
479b			;		if DEBUG_FORTH_WORDS 
479b			;			DMARK "DI2" 
479b			;			CALLMONITOR 
479b			;		endif 
479b			 
479b cd 2a 06				call storage_findnextid 
479e			 
479e			;		if DEBUG_FORTH_WORDS 
479e			;			DMARK "DI3" 
479e			;			CALLMONITOR 
479e			;		endif 
479e			 
479e					; if found hl will be non zero 
479e			 
479e cd 32 0d				call ishlzero 
47a1			;		ld a, l 
47a1			;		add h 
47a1			; 
47a1			;		cp 0 
47a1 28 59				jr z, .dirnotfound 
47a3			 
47a3					; increase count 
47a3			 
47a3 c1					pop bc	 
47a4 0c					inc c 
47a5 c5					push bc 
47a6					 
47a6			 
47a6					; get file header and push the file name 
47a6			 
47a6 11 e8 f9				ld de, store_page 
47a9 cd 09 03				call storage_read_block 
47ac			 
47ac					; push file id to stack 
47ac				 
47ac 3a e8 f9				ld a, (store_page) 
47af 26 00				ld h, 0 
47b1 6f					ld l, a 
47b2 cd ac 1c				call forth_push_numhl 
47b5			 
47b5					; push extent count to stack  
47b5				 
47b5 3a ea f9				ld a, (store_page+2) 
47b8 26 00				ld h, 0 
47ba 6f					ld l, a 
47bb cd ac 1c				call forth_push_numhl 
47be			 
47be					; push file name 
47be			 
47be 21 eb f9				ld hl, store_page+3 
47c1					if DEBUG_FORTH_WORDS 
47c1						DMARK "DI5" 
47c1 f5				push af  
47c2 3a d6 47			ld a, (.dmark)  
47c5 32 bd fb			ld (debug_mark),a  
47c8 3a d7 47			ld a, (.dmark+1)  
47cb 32 be fb			ld (debug_mark+1),a  
47ce 3a d8 47			ld a, (.dmark+2)  
47d1 32 bf fb			ld (debug_mark+2),a  
47d4 18 03			jr .pastdmark  
47d6 ..			.dmark: db "DI5"  
47d9 f1			.pastdmark: pop af  
47da			endm  
# End of macro DMARK
47da						CALLMONITOR 
47da cd 1c 17			call break_point_state  
47dd				endm  
# End of macro CALLMONITOR
47dd					endif 
47dd cd 1a 1d				call forth_push_str 
47e0					if DEBUG_FORTH_WORDS 
47e0						DMARK "DI6" 
47e0 f5				push af  
47e1 3a f5 47			ld a, (.dmark)  
47e4 32 bd fb			ld (debug_mark),a  
47e7 3a f6 47			ld a, (.dmark+1)  
47ea 32 be fb			ld (debug_mark+1),a  
47ed 3a f7 47			ld a, (.dmark+2)  
47f0 32 bf fb			ld (debug_mark+2),a  
47f3 18 03			jr .pastdmark  
47f5 ..			.dmark: db "DI6"  
47f8 f1			.pastdmark: pop af  
47f9			endm  
# End of macro DMARK
47f9						CALLMONITOR 
47f9 cd 1c 17			call break_point_state  
47fc				endm  
# End of macro CALLMONITOR
47fc					endif 
47fc			.dirnotfound: 
47fc c1					pop bc     
47fd 10 95				djnz .diritem 
47ff				 
47ff			.dirdone:	 
47ff					if DEBUG_FORTH_WORDS 
47ff						DMARK "DI7" 
47ff f5				push af  
4800 3a 14 48			ld a, (.dmark)  
4803 32 bd fb			ld (debug_mark),a  
4806 3a 15 48			ld a, (.dmark+1)  
4809 32 be fb			ld (debug_mark+1),a  
480c 3a 16 48			ld a, (.dmark+2)  
480f 32 bf fb			ld (debug_mark+2),a  
4812 18 03			jr .pastdmark  
4814 ..			.dmark: db "DI7"  
4817 f1			.pastdmark: pop af  
4818			endm  
# End of macro DMARK
4818						CALLMONITOR 
4818 cd 1c 17			call break_point_state  
481b				endm  
# End of macro CALLMONITOR
481b					endif 
481b			 
481b					; push a count of the dir items found 
481b			 
481b 26 00				ld h, 0 
481d 69					ld l, c 
481e cd ac 1c				call forth_push_numhl 
4821			 
4821					; push the bank label 
4821			 
4821 cd ba 03				call storage_get_block_0 
4824			 
4824				 
4824 21 eb f9		 		ld hl, store_page+3 
4827			 
4827					if DEBUG_FORTH_WORDS 
4827						DMARK "DI8" 
4827 f5				push af  
4828 3a 3c 48			ld a, (.dmark)  
482b 32 bd fb			ld (debug_mark),a  
482e 3a 3d 48			ld a, (.dmark+1)  
4831 32 be fb			ld (debug_mark+1),a  
4834 3a 3e 48			ld a, (.dmark+2)  
4837 32 bf fb			ld (debug_mark+2),a  
483a 18 03			jr .pastdmark  
483c ..			.dmark: db "DI8"  
483f f1			.pastdmark: pop af  
4840			endm  
# End of macro DMARK
4840						CALLMONITOR 
4840 cd 1c 17			call break_point_state  
4843				endm  
# End of macro CALLMONITOR
4843					endif 
4843 cd 1a 1d				call forth_push_str 
4846			 
4846			 
4846				 
4846					NEXTW 
4846 c3 15 20			jp macro_next 
4849				endm 
# End of macro NEXTW
4849			.SAVE: 
4849			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4849			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4849			;		NEXTW 
4849			;.LOAD: 
4849			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4849			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4849			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4849			;; > > The LOAD command can not be used in any user words or compound lines. 
4849			; 
4849			;		; store_openext use it. If zero it is EOF 
4849			; 
4849			;		; read block from current stream id 
4849			;		; if the block does not contain zero term keep reading blocks until zero found 
4849			;		; push the block to stack 
4849			;		; save the block id to stream 
4849			; 
4849			; 
4849			;		FORTH_DSP_VALUEHL 
4849			; 
4849			;;		push hl 
4849			; 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LOA" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;		FORTH_DSP_POP 
4849			; 
4849			;;		pop hl 
4849			; 
4849			;		ld h, l 
4849			;		ld l, 0 
4849			; 
4849			;		push hl     ; stack holds current file id and extent to work with 
4849			; 
4849			; 
4849			;		ld de, store_page      ; get block zero of file 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LO0" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;		call storage_read 
4849			; 
4849			;		ld a, (store_page+2)    ; max extents for this file 
4849			;		ld  (store_openmaxext),a   ; get our limit 
4849			; 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LOE" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			; 
4849			;; TODO dont know why max extents are not present 
4849			;;		cp 0 
4849			;;		jp z, .loadeof     ; dont read past eof 
4849			; 
4849			;;		ld a, 1   ; start from the head of the file 
4849			; 
4849			;.loadline:	pop hl 
4849			;		inc hl 
4849			;		ld  a, (store_openmaxext)   ; get our limit 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LOx" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;		inc a 
4849			;		cp l 
4849			;		jp z, .loadeof 
4849			;		push hl    ; save current extent 
4849			; 
4849			;		ld de, store_page 
4849			; 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LO1" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;		call storage_read 
4849			; 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LO2" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;	call ishlzero 
4849			;	ld a, l 
4849			;	add h 
4849			;	cp 0 
4849			;	jr z, .loadeof 
4849			; 
4849			;	; not eof so hl should point to data to exec 
4849			; 
4849			;	; will need to add the FORTH_END_BUFFER flag 
4849			 ; 
4849			;	ld hl, store_page+2 
4849			;	ld bc, 255 
4849			;	ld a, 0 
4849			;	cpir 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LOt" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;	dec hl 
4849			;	ld a, ' ' 
4849			;	ld (hl), a 
4849			;	inc hl 
4849			;	ld (hl), a 
4849			;	inc hl 
4849			;	ld (hl), a 
4849			;	inc hl 
4849			;	ld a, FORTH_END_BUFFER 
4849			;	ld (hl), a 
4849			; 
4849			;	; TODO handle more than a single block read 
4849			; 
4849			; 
4849			;	ld hl, store_page+2 
4849			; 
4849			;	ld (os_tok_ptr), hl 
4849			; 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LO3" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			; 
4849			;	call forthparse 
4849			;	call forthexec 
4849			;	call forthexec_cleanup 
4849			; 
4849			;	; go to next extent 
4849			; 
4849			;	; get next block  or mark as eof 
4849			;	jp .loadline 
4849			; 
4849			; 
4849			; 
4849			;	       NEXTW 
4849			;.loadeof:	ld a, 0 
4849			;		ld (store_openext), a 
4849			; 
4849			;	if DEBUG_STORESE 
4849			;		DMARK "LOF" 
4849			;		CALLMONITOR 
4849			;	endif 
4849			;		ret 
4849			;		;NEXTW 
4849			;.BSAVE:   
4849			; 
4849			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4849			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4849			;		NEXTW 
4849			;.BLOAD: 
4849			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4849			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4849			;		NEXTW 
4849			;;;; counter gap 
4849			 
4849			 
4849			.SEO: 
4849				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4849 64				db WORD_SYS_CORE+80             
484a 68 48			dw .SEI            
484c 04				db 3 + 1 
484d .. 00			db "SEO",0              
4851				endm 
# End of macro CWHEAD
4851			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4851			 
4851					; get port 
4851			 
4851					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4851 cd a3 1e			call macro_dsp_valuehl 
4854				endm 
# End of macro FORTH_DSP_VALUEHL
4854			 
4854 e5					push hl    ; u2 - byte 
4855			 
4855					; destroy value TOS 
4855			 
4855					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4855 cd 5b 1f			call macro_forth_dsp_pop 
4858				endm 
# End of macro FORTH_DSP_POP
4858			 
4858					; get byte to send 
4858			 
4858					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4858 cd a3 1e			call macro_dsp_valuehl 
485b				endm 
# End of macro FORTH_DSP_VALUEHL
485b			 
485b e5					push hl    ; u1 - addr 
485c			 
485c					; destroy value TOS 
485c			 
485c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
485c cd 5b 1f			call macro_forth_dsp_pop 
485f				endm 
# End of macro FORTH_DSP_POP
485f			 
485f					; one value on hl get other one back 
485f			 
485f d1					pop de   ; u1 - byte 
4860			 
4860 e1					pop hl   ; u2 - addr 
4861			 
4861					; TODO Send SPI byte 
4861			 
4861			 
4861 7b					ld a, e 
4862 cd e7 01				call se_writebyte 
4865			 
4865					 
4865			 
4865					NEXTW 
4865 c3 15 20			jp macro_next 
4868				endm 
# End of macro NEXTW
4868			 
4868			.SEI: 
4868				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4868 65				db WORD_SYS_CORE+81             
4869 82 48			dw .SFREE            
486b 04				db 3 + 1 
486c .. 00			db "SEI",0              
4870				endm 
# End of macro CWHEAD
4870			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4870			 
4870					; get port 
4870			 
4870					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4870 cd a3 1e			call macro_dsp_valuehl 
4873				endm 
# End of macro FORTH_DSP_VALUEHL
4873			 
4873			;		push hl 
4873			 
4873					; destroy value TOS 
4873			 
4873					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4873 cd 5b 1f			call macro_forth_dsp_pop 
4876				endm 
# End of macro FORTH_DSP_POP
4876			 
4876					; one value on hl get other one back 
4876			 
4876			;		pop hl 
4876			 
4876			 
4876					; TODO Get SPI byte 
4876			 
4876 cd 89 02				call se_readbyte 
4879			 
4879 26 00				ld h, 0 
487b 6f					ld l, a 
487c cd ac 1c				call forth_push_numhl 
487f			 
487f					NEXTW 
487f c3 15 20			jp macro_next 
4882				endm 
# End of macro NEXTW
4882			 
4882			.SFREE: 
4882				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4882 67				db WORD_SYS_CORE+83             
4883 b1 48			dw .SIZE            
4885 06				db 5 + 1 
4886 .. 00			db "FFREE",0              
488c				endm 
# End of macro CWHEAD
488c			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
488c					if DEBUG_FORTH_WORDS_KEY 
488c						DMARK "FFR" 
488c f5				push af  
488d 3a a1 48			ld a, (.dmark)  
4890 32 bd fb			ld (debug_mark),a  
4893 3a a2 48			ld a, (.dmark+1)  
4896 32 be fb			ld (debug_mark+1),a  
4899 3a a3 48			ld a, (.dmark+2)  
489c 32 bf fb			ld (debug_mark+2),a  
489f 18 03			jr .pastdmark  
48a1 ..			.dmark: db "FFR"  
48a4 f1			.pastdmark: pop af  
48a5			endm  
# End of macro DMARK
48a5						CALLMONITOR 
48a5 cd 1c 17			call break_point_state  
48a8				endm  
# End of macro CALLMONITOR
48a8					endif 
48a8			 
48a8 cd c4 06				call storage_freeblocks 
48ab			 
48ab cd ac 1c				call forth_push_numhl 
48ae			 
48ae				       NEXTW 
48ae c3 15 20			jp macro_next 
48b1				endm 
# End of macro NEXTW
48b1			.SIZE: 
48b1				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
48b1 67				db WORD_SYS_CORE+83             
48b2 e5 48			dw .CREATE            
48b4 05				db 4 + 1 
48b5 .. 00			db "SIZE",0              
48ba				endm 
# End of macro CWHEAD
48ba			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
48ba					if DEBUG_FORTH_WORDS_KEY 
48ba						DMARK "SIZ" 
48ba f5				push af  
48bb 3a cf 48			ld a, (.dmark)  
48be 32 bd fb			ld (debug_mark),a  
48c1 3a d0 48			ld a, (.dmark+1)  
48c4 32 be fb			ld (debug_mark+1),a  
48c7 3a d1 48			ld a, (.dmark+2)  
48ca 32 bf fb			ld (debug_mark+2),a  
48cd 18 03			jr .pastdmark  
48cf ..			.dmark: db "SIZ"  
48d2 f1			.pastdmark: pop af  
48d3			endm  
# End of macro DMARK
48d3						CALLMONITOR 
48d3 cd 1c 17			call break_point_state  
48d6				endm  
# End of macro CALLMONITOR
48d6					endif 
48d6			 
48d6					FORTH_DSP_VALUEHL 
48d6 cd a3 1e			call macro_dsp_valuehl 
48d9				endm 
# End of macro FORTH_DSP_VALUEHL
48d9			;		push hl 
48d9					FORTH_DSP_POP 
48d9 cd 5b 1f			call macro_forth_dsp_pop 
48dc				endm 
# End of macro FORTH_DSP_POP
48dc			;		pop hl 
48dc cd 38 03				call storage_file_size 
48df			 
48df cd ac 1c				call forth_push_numhl 
48e2			  
48e2			 
48e2				       NEXTW 
48e2 c3 15 20			jp macro_next 
48e5				endm 
# End of macro NEXTW
48e5			 
48e5			.CREATE: 
48e5				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
48e5 68				db WORD_SYS_CORE+84             
48e6 53 49			dw .APPEND            
48e8 07				db 6 + 1 
48e9 .. 00			db "CREATE",0              
48f0				endm 
# End of macro CWHEAD
48f0			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
48f0			; | | e.g.  
48f0			; | | TestProgram CREATE 
48f0			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
48f0			; | |  
48f0			; | | Max file IDs are 255. 
48f0			; | |  
48f0					 
48f0					if DEBUG_FORTH_WORDS_KEY 
48f0						DMARK "CRT" 
48f0 f5				push af  
48f1 3a 05 49			ld a, (.dmark)  
48f4 32 bd fb			ld (debug_mark),a  
48f7 3a 06 49			ld a, (.dmark+1)  
48fa 32 be fb			ld (debug_mark+1),a  
48fd 3a 07 49			ld a, (.dmark+2)  
4900 32 bf fb			ld (debug_mark+2),a  
4903 18 03			jr .pastdmark  
4905 ..			.dmark: db "CRT"  
4908 f1			.pastdmark: pop af  
4909			endm  
# End of macro DMARK
4909						CALLMONITOR 
4909 cd 1c 17			call break_point_state  
490c				endm  
# End of macro CALLMONITOR
490c					endif 
490c			;		call storage_get_block_0 
490c			 
490c					; TODO pop hl 
490c			 
490c					;v5 FORTH_DSP_VALUE 
490c					FORTH_DSP_VALUE 
490c cd 8c 1e			call macro_forth_dsp_value 
490f				endm 
# End of macro FORTH_DSP_VALUE
490f			 
490f				if DEBUG_STORESE 
490f					DMARK "CR1" 
490f f5				push af  
4910 3a 24 49			ld a, (.dmark)  
4913 32 bd fb			ld (debug_mark),a  
4916 3a 25 49			ld a, (.dmark+1)  
4919 32 be fb			ld (debug_mark+1),a  
491c 3a 26 49			ld a, (.dmark+2)  
491f 32 bf fb			ld (debug_mark+2),a  
4922 18 03			jr .pastdmark  
4924 ..			.dmark: db "CR1"  
4927 f1			.pastdmark: pop af  
4928			endm  
# End of macro DMARK
4928					CALLMONITOR 
4928 cd 1c 17			call break_point_state  
492b				endm  
# End of macro CALLMONITOR
492b				endif 
492b			;		push hl 
492b			;		FORTH_DSP_POP 
492b			;		pop hl 
492b			 
492b			;		inc hl   ; move past the type marker 
492b			 
492b cd fa 06				call storage_create 
492e			 
492e				if DEBUG_STORESE 
492e					DMARK "CT1" 
492e f5				push af  
492f 3a 43 49			ld a, (.dmark)  
4932 32 bd fb			ld (debug_mark),a  
4935 3a 44 49			ld a, (.dmark+1)  
4938 32 be fb			ld (debug_mark+1),a  
493b 3a 45 49			ld a, (.dmark+2)  
493e 32 bf fb			ld (debug_mark+2),a  
4941 18 03			jr .pastdmark  
4943 ..			.dmark: db "CT1"  
4946 f1			.pastdmark: pop af  
4947			endm  
# End of macro DMARK
4947					CALLMONITOR 
4947 cd 1c 17			call break_point_state  
494a				endm  
# End of macro CALLMONITOR
494a				endif 
494a			;		push hl 
494a					FORTH_DSP_POP 
494a cd 5b 1f			call macro_forth_dsp_pop 
494d				endm 
# End of macro FORTH_DSP_POP
494d			;		pop hl 
494d					; push file id to stack 
494d cd ac 1c				call forth_push_numhl 
4950			 
4950			 
4950			 
4950				       NEXTW 
4950 c3 15 20			jp macro_next 
4953				endm 
# End of macro NEXTW
4953			 
4953			.APPEND: 
4953				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4953 69				db WORD_SYS_CORE+85             
4954 e4 49			dw .SDEL            
4956 07				db 6 + 1 
4957 .. 00			db "APPEND",0              
495e				endm 
# End of macro CWHEAD
495e			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
495e			; | | e.g. 
495e			; | | Test CREATE      -> $01 
495e			; | | "A string to add to file" $01 APPEND 
495e			; | |  
495e			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
495e					if DEBUG_FORTH_WORDS_KEY 
495e						DMARK "APP" 
495e f5				push af  
495f 3a 73 49			ld a, (.dmark)  
4962 32 bd fb			ld (debug_mark),a  
4965 3a 74 49			ld a, (.dmark+1)  
4968 32 be fb			ld (debug_mark+1),a  
496b 3a 75 49			ld a, (.dmark+2)  
496e 32 bf fb			ld (debug_mark+2),a  
4971 18 03			jr .pastdmark  
4973 ..			.dmark: db "APP"  
4976 f1			.pastdmark: pop af  
4977			endm  
# End of macro DMARK
4977						CALLMONITOR 
4977 cd 1c 17			call break_point_state  
497a				endm  
# End of macro CALLMONITOR
497a					endif 
497a			 
497a					FORTH_DSP_VALUEHL 
497a cd a3 1e			call macro_dsp_valuehl 
497d				endm 
# End of macro FORTH_DSP_VALUEHL
497d e5					push hl 	; save file id 
497e			 
497e				if DEBUG_STORESE 
497e					DMARK "AP1" 
497e f5				push af  
497f 3a 93 49			ld a, (.dmark)  
4982 32 bd fb			ld (debug_mark),a  
4985 3a 94 49			ld a, (.dmark+1)  
4988 32 be fb			ld (debug_mark+1),a  
498b 3a 95 49			ld a, (.dmark+2)  
498e 32 bf fb			ld (debug_mark+2),a  
4991 18 03			jr .pastdmark  
4993 ..			.dmark: db "AP1"  
4996 f1			.pastdmark: pop af  
4997			endm  
# End of macro DMARK
4997					CALLMONITOR 
4997 cd 1c 17			call break_point_state  
499a				endm  
# End of macro CALLMONITOR
499a				endif 
499a					FORTH_DSP_POP 
499a cd 5b 1f			call macro_forth_dsp_pop 
499d				endm 
# End of macro FORTH_DSP_POP
499d			 
499d					FORTH_DSP_VALUEHL 
499d cd a3 1e			call macro_dsp_valuehl 
49a0				endm 
# End of macro FORTH_DSP_VALUEHL
49a0					;v5 FORTH_DSP_VALUE 
49a0 e5					push hl 	; save ptr to string to save 
49a1			 
49a1				if DEBUG_STORESE 
49a1					DMARK "AP1" 
49a1 f5				push af  
49a2 3a b6 49			ld a, (.dmark)  
49a5 32 bd fb			ld (debug_mark),a  
49a8 3a b7 49			ld a, (.dmark+1)  
49ab 32 be fb			ld (debug_mark+1),a  
49ae 3a b8 49			ld a, (.dmark+2)  
49b1 32 bf fb			ld (debug_mark+2),a  
49b4 18 03			jr .pastdmark  
49b6 ..			.dmark: db "AP1"  
49b9 f1			.pastdmark: pop af  
49ba			endm  
# End of macro DMARK
49ba					CALLMONITOR 
49ba cd 1c 17			call break_point_state  
49bd				endm  
# End of macro CALLMONITOR
49bd				endif 
49bd					FORTH_DSP_POP 
49bd cd 5b 1f			call macro_forth_dsp_pop 
49c0				endm 
# End of macro FORTH_DSP_POP
49c0			 
49c0 d1					pop de 
49c1 e1					pop hl 
49c2				if DEBUG_STORESE 
49c2					DMARK "AP2" 
49c2 f5				push af  
49c3 3a d7 49			ld a, (.dmark)  
49c6 32 bd fb			ld (debug_mark),a  
49c9 3a d8 49			ld a, (.dmark+1)  
49cc 32 be fb			ld (debug_mark+1),a  
49cf 3a d9 49			ld a, (.dmark+2)  
49d2 32 bf fb			ld (debug_mark+2),a  
49d5 18 03			jr .pastdmark  
49d7 ..			.dmark: db "AP2"  
49da f1			.pastdmark: pop af  
49db			endm  
# End of macro DMARK
49db					CALLMONITOR 
49db cd 1c 17			call break_point_state  
49de				endm  
# End of macro CALLMONITOR
49de				endif 
49de					;inc de ; skip var type indicator 
49de			 
49de					; TODO how to append numerics???? 
49de			 
49de cd d7 08				call storage_append		 
49e1			 
49e1				       NEXTW 
49e1 c3 15 20			jp macro_next 
49e4				endm 
# End of macro NEXTW
49e4			.SDEL: 
49e4				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
49e4 6a				db WORD_SYS_CORE+86             
49e5 30 4a			dw .OPEN            
49e7 05				db 4 + 1 
49e8 .. 00			db "ERA",0              
49ec				endm 
# End of macro CWHEAD
49ec			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
49ec					FORTH_DSP_VALUEHL 
49ec cd a3 1e			call macro_dsp_valuehl 
49ef				endm 
# End of macro FORTH_DSP_VALUEHL
49ef			;		push hl 	; save file id 
49ef			 
49ef					if DEBUG_FORTH_WORDS_KEY 
49ef						DMARK "ERA" 
49ef f5				push af  
49f0 3a 04 4a			ld a, (.dmark)  
49f3 32 bd fb			ld (debug_mark),a  
49f6 3a 05 4a			ld a, (.dmark+1)  
49f9 32 be fb			ld (debug_mark+1),a  
49fc 3a 06 4a			ld a, (.dmark+2)  
49ff 32 bf fb			ld (debug_mark+2),a  
4a02 18 03			jr .pastdmark  
4a04 ..			.dmark: db "ERA"  
4a07 f1			.pastdmark: pop af  
4a08			endm  
# End of macro DMARK
4a08						CALLMONITOR 
4a08 cd 1c 17			call break_point_state  
4a0b				endm  
# End of macro CALLMONITOR
4a0b					endif 
4a0b				if DEBUG_STORESE 
4a0b					DMARK "ER1" 
4a0b f5				push af  
4a0c 3a 20 4a			ld a, (.dmark)  
4a0f 32 bd fb			ld (debug_mark),a  
4a12 3a 21 4a			ld a, (.dmark+1)  
4a15 32 be fb			ld (debug_mark+1),a  
4a18 3a 22 4a			ld a, (.dmark+2)  
4a1b 32 bf fb			ld (debug_mark+2),a  
4a1e 18 03			jr .pastdmark  
4a20 ..			.dmark: db "ER1"  
4a23 f1			.pastdmark: pop af  
4a24			endm  
# End of macro DMARK
4a24					CALLMONITOR 
4a24 cd 1c 17			call break_point_state  
4a27				endm  
# End of macro CALLMONITOR
4a27				endif 
4a27					FORTH_DSP_POP 
4a27 cd 5b 1f			call macro_forth_dsp_pop 
4a2a				endm 
# End of macro FORTH_DSP_POP
4a2a			 
4a2a			;		pop hl 
4a2a			 
4a2a cd 49 05				call storage_erase 
4a2d				       NEXTW 
4a2d c3 15 20			jp macro_next 
4a30				endm 
# End of macro NEXTW
4a30			 
4a30			.OPEN: 
4a30				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a30 6b				db WORD_SYS_CORE+87             
4a31 b7 4a			dw .READ            
4a33 05				db 4 + 1 
4a34 .. 00			db "OPEN",0              
4a39				endm 
# End of macro CWHEAD
4a39			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a39			; | | e.g. 
4a39			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a39			 
4a39					if DEBUG_FORTH_WORDS_KEY 
4a39						DMARK "OPN" 
4a39 f5				push af  
4a3a 3a 4e 4a			ld a, (.dmark)  
4a3d 32 bd fb			ld (debug_mark),a  
4a40 3a 4f 4a			ld a, (.dmark+1)  
4a43 32 be fb			ld (debug_mark+1),a  
4a46 3a 50 4a			ld a, (.dmark+2)  
4a49 32 bf fb			ld (debug_mark+2),a  
4a4c 18 03			jr .pastdmark  
4a4e ..			.dmark: db "OPN"  
4a51 f1			.pastdmark: pop af  
4a52			endm  
# End of macro DMARK
4a52						CALLMONITOR 
4a52 cd 1c 17			call break_point_state  
4a55				endm  
# End of macro CALLMONITOR
4a55					endif 
4a55					; TODO handle multiple file opens 
4a55			 
4a55 3e 01			       	ld a, 1 
4a57 32 df f9				ld (store_openext), a 
4a5a			 
4a5a					; get max extents for this file 
4a5a				 
4a5a								 
4a5a					FORTH_DSP_VALUEHL 
4a5a cd a3 1e			call macro_dsp_valuehl 
4a5d				endm 
# End of macro FORTH_DSP_VALUEHL
4a5d			 
4a5d 65					ld h, l 
4a5e 2e 00				ld l, 0 
4a60			 
4a60				if DEBUG_STORESE 
4a60					DMARK "OPN" 
4a60 f5				push af  
4a61 3a 75 4a			ld a, (.dmark)  
4a64 32 bd fb			ld (debug_mark),a  
4a67 3a 76 4a			ld a, (.dmark+1)  
4a6a 32 be fb			ld (debug_mark+1),a  
4a6d 3a 77 4a			ld a, (.dmark+2)  
4a70 32 bf fb			ld (debug_mark+2),a  
4a73 18 03			jr .pastdmark  
4a75 ..			.dmark: db "OPN"  
4a78 f1			.pastdmark: pop af  
4a79			endm  
# End of macro DMARK
4a79					CALLMONITOR 
4a79 cd 1c 17			call break_point_state  
4a7c				endm  
# End of macro CALLMONITOR
4a7c				endif 
4a7c			;		push hl 
4a7c					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4a7c cd 5b 1f			call macro_forth_dsp_pop 
4a7f				endm 
# End of macro FORTH_DSP_POP
4a7f			;		pop hl 
4a7f						 
4a7f 11 e8 f9				ld de, store_page      ; get block zero of file 
4a82 cd 50 08				call storage_read 
4a85			 
4a85			 
4a85 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4a88 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4a8b					 
4a8b				if DEBUG_STORESE 
4a8b					DMARK "OPx" 
4a8b f5				push af  
4a8c 3a a0 4a			ld a, (.dmark)  
4a8f 32 bd fb			ld (debug_mark),a  
4a92 3a a1 4a			ld a, (.dmark+1)  
4a95 32 be fb			ld (debug_mark+1),a  
4a98 3a a2 4a			ld a, (.dmark+2)  
4a9b 32 bf fb			ld (debug_mark+2),a  
4a9e 18 03			jr .pastdmark  
4aa0 ..			.dmark: db "OPx"  
4aa3 f1			.pastdmark: pop af  
4aa4			endm  
# End of macro DMARK
4aa4					CALLMONITOR 
4aa4 cd 1c 17			call break_point_state  
4aa7				endm  
# End of macro CALLMONITOR
4aa7				endif 
4aa7 fe 00				cp 0 
4aa9 20 03				jr nz, .skipopeneof 
4aab					; have opened an empty file 
4aab					 
4aab 32 df f9				ld (store_openext), a 
4aae			 
4aae			.skipopeneof: 
4aae			 
4aae 6f					ld l, a 
4aaf 26 00				ld h, 0 
4ab1 cd ac 1c				call forth_push_numhl 
4ab4			 
4ab4			 
4ab4				       NEXTW 
4ab4 c3 15 20			jp macro_next 
4ab7				endm 
# End of macro NEXTW
4ab7			.READ: 
4ab7				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4ab7 6c				db WORD_SYS_CORE+88             
4ab8 fe 4b			dw .EOF            
4aba 05				db 4 + 1 
4abb .. 00			db "READ",0              
4ac0				endm 
# End of macro CWHEAD
4ac0			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4ac0			; | | e.g. 
4ac0			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ac0			 
4ac0					if DEBUG_FORTH_WORDS_KEY 
4ac0						DMARK "REA" 
4ac0 f5				push af  
4ac1 3a d5 4a			ld a, (.dmark)  
4ac4 32 bd fb			ld (debug_mark),a  
4ac7 3a d6 4a			ld a, (.dmark+1)  
4aca 32 be fb			ld (debug_mark+1),a  
4acd 3a d7 4a			ld a, (.dmark+2)  
4ad0 32 bf fb			ld (debug_mark+2),a  
4ad3 18 03			jr .pastdmark  
4ad5 ..			.dmark: db "REA"  
4ad8 f1			.pastdmark: pop af  
4ad9			endm  
# End of macro DMARK
4ad9						CALLMONITOR 
4ad9 cd 1c 17			call break_point_state  
4adc				endm  
# End of macro CALLMONITOR
4adc					endif 
4adc					; store_openext use it. If zero it is EOF 
4adc			 
4adc					; read block from current stream id 
4adc					; if the block does not contain zero term keep reading blocks until zero found 
4adc					; push the block to stack 
4adc					; save the block id to stream 
4adc			 
4adc			 
4adc					FORTH_DSP_VALUEHL 
4adc cd a3 1e			call macro_dsp_valuehl 
4adf				endm 
# End of macro FORTH_DSP_VALUEHL
4adf			 
4adf			;		push hl 
4adf			 
4adf				if DEBUG_STORESE 
4adf					DMARK "REA" 
4adf f5				push af  
4ae0 3a f4 4a			ld a, (.dmark)  
4ae3 32 bd fb			ld (debug_mark),a  
4ae6 3a f5 4a			ld a, (.dmark+1)  
4ae9 32 be fb			ld (debug_mark+1),a  
4aec 3a f6 4a			ld a, (.dmark+2)  
4aef 32 bf fb			ld (debug_mark+2),a  
4af2 18 03			jr .pastdmark  
4af4 ..			.dmark: db "REA"  
4af7 f1			.pastdmark: pop af  
4af8			endm  
# End of macro DMARK
4af8					CALLMONITOR 
4af8 cd 1c 17			call break_point_state  
4afb				endm  
# End of macro CALLMONITOR
4afb				endif 
4afb					FORTH_DSP_POP 
4afb cd 5b 1f			call macro_forth_dsp_pop 
4afe				endm 
# End of macro FORTH_DSP_POP
4afe			 
4afe			;		pop hl 
4afe				 
4afe 65					ld h,l 
4aff			 
4aff 3a df f9				ld a, (store_openext) 
4b02 6f					ld l, a 
4b03					 
4b03 fe 00				cp 0 
4b05 ca d0 4b				jp z, .ateof     ; dont read past eof 
4b08			 
4b08			 
4b08 11 e8 f9				ld de, store_page 
4b0b				if DEBUG_STORESE 
4b0b					DMARK "RE1" 
4b0b f5				push af  
4b0c 3a 20 4b			ld a, (.dmark)  
4b0f 32 bd fb			ld (debug_mark),a  
4b12 3a 21 4b			ld a, (.dmark+1)  
4b15 32 be fb			ld (debug_mark+1),a  
4b18 3a 22 4b			ld a, (.dmark+2)  
4b1b 32 bf fb			ld (debug_mark+2),a  
4b1e 18 03			jr .pastdmark  
4b20 ..			.dmark: db "RE1"  
4b23 f1			.pastdmark: pop af  
4b24			endm  
# End of macro DMARK
4b24					CALLMONITOR 
4b24 cd 1c 17			call break_point_state  
4b27				endm  
# End of macro CALLMONITOR
4b27				endif 
4b27 cd 50 08				call storage_read 
4b2a			 
4b2a				if DEBUG_STORESE 
4b2a					DMARK "RE2" 
4b2a f5				push af  
4b2b 3a 3f 4b			ld a, (.dmark)  
4b2e 32 bd fb			ld (debug_mark),a  
4b31 3a 40 4b			ld a, (.dmark+1)  
4b34 32 be fb			ld (debug_mark+1),a  
4b37 3a 41 4b			ld a, (.dmark+2)  
4b3a 32 bf fb			ld (debug_mark+2),a  
4b3d 18 03			jr .pastdmark  
4b3f ..			.dmark: db "RE2"  
4b42 f1			.pastdmark: pop af  
4b43			endm  
# End of macro DMARK
4b43					CALLMONITOR 
4b43 cd 1c 17			call break_point_state  
4b46				endm  
# End of macro CALLMONITOR
4b46				endif 
4b46 cd 32 0d			call ishlzero 
4b49			;	ld a, l 
4b49			;	add h 
4b49			;	cp 0 
4b49 ca d6 4b			jp z, .readeof 
4b4c			 
4b4c				; not eof so hl should point to data to push to stack 
4b4c			 
4b4c				if DEBUG_STORESE 
4b4c					DMARK "RE3" 
4b4c f5				push af  
4b4d 3a 61 4b			ld a, (.dmark)  
4b50 32 bd fb			ld (debug_mark),a  
4b53 3a 62 4b			ld a, (.dmark+1)  
4b56 32 be fb			ld (debug_mark+1),a  
4b59 3a 63 4b			ld a, (.dmark+2)  
4b5c 32 bf fb			ld (debug_mark+2),a  
4b5f 18 03			jr .pastdmark  
4b61 ..			.dmark: db "RE3"  
4b64 f1			.pastdmark: pop af  
4b65			endm  
# End of macro DMARK
4b65					CALLMONITOR 
4b65 cd 1c 17			call break_point_state  
4b68				endm  
# End of macro CALLMONITOR
4b68				endif 
4b68 cd 1a 1d			call forth_push_str 
4b6b			 
4b6b				if DEBUG_STORESE 
4b6b					DMARK "RE4" 
4b6b f5				push af  
4b6c 3a 80 4b			ld a, (.dmark)  
4b6f 32 bd fb			ld (debug_mark),a  
4b72 3a 81 4b			ld a, (.dmark+1)  
4b75 32 be fb			ld (debug_mark+1),a  
4b78 3a 82 4b			ld a, (.dmark+2)  
4b7b 32 bf fb			ld (debug_mark+2),a  
4b7e 18 03			jr .pastdmark  
4b80 ..			.dmark: db "RE4"  
4b83 f1			.pastdmark: pop af  
4b84			endm  
# End of macro DMARK
4b84					CALLMONITOR 
4b84 cd 1c 17			call break_point_state  
4b87				endm  
# End of macro CALLMONITOR
4b87				endif 
4b87				; get next block  or mark as eof 
4b87			 
4b87 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4b8a 4f				ld c, a	 
4b8b 3a df f9			ld a, (store_openext) 
4b8e			 
4b8e				if DEBUG_STORESE 
4b8e					DMARK "RE5" 
4b8e f5				push af  
4b8f 3a a3 4b			ld a, (.dmark)  
4b92 32 bd fb			ld (debug_mark),a  
4b95 3a a4 4b			ld a, (.dmark+1)  
4b98 32 be fb			ld (debug_mark+1),a  
4b9b 3a a5 4b			ld a, (.dmark+2)  
4b9e 32 bf fb			ld (debug_mark+2),a  
4ba1 18 03			jr .pastdmark  
4ba3 ..			.dmark: db "RE5"  
4ba6 f1			.pastdmark: pop af  
4ba7			endm  
# End of macro DMARK
4ba7					CALLMONITOR 
4ba7 cd 1c 17			call break_point_state  
4baa				endm  
# End of macro CALLMONITOR
4baa				endif 
4baa b9				cp c 
4bab 28 29			jr z, .readeof     ; at last extent 
4bad			 
4bad 3c					inc a 
4bae 32 df f9				ld (store_openext), a 
4bb1			 
4bb1				if DEBUG_STORESE 
4bb1					DMARK "RE6" 
4bb1 f5				push af  
4bb2 3a c6 4b			ld a, (.dmark)  
4bb5 32 bd fb			ld (debug_mark),a  
4bb8 3a c7 4b			ld a, (.dmark+1)  
4bbb 32 be fb			ld (debug_mark+1),a  
4bbe 3a c8 4b			ld a, (.dmark+2)  
4bc1 32 bf fb			ld (debug_mark+2),a  
4bc4 18 03			jr .pastdmark  
4bc6 ..			.dmark: db "RE6"  
4bc9 f1			.pastdmark: pop af  
4bca			endm  
# End of macro DMARK
4bca					CALLMONITOR 
4bca cd 1c 17			call break_point_state  
4bcd				endm  
# End of macro CALLMONITOR
4bcd				endif 
4bcd			 
4bcd			 
4bcd				       NEXTW 
4bcd c3 15 20			jp macro_next 
4bd0				endm 
# End of macro NEXTW
4bd0			.ateof: 
4bd0 21 fa 4b				ld hl, .showeof 
4bd3 cd 1a 1d				call forth_push_str 
4bd6 3e 00		.readeof:	ld a, 0 
4bd8 32 df f9				ld (store_openext), a 
4bdb			 
4bdb					 
4bdb				if DEBUG_STORESE 
4bdb					DMARK "REF" 
4bdb f5				push af  
4bdc 3a f0 4b			ld a, (.dmark)  
4bdf 32 bd fb			ld (debug_mark),a  
4be2 3a f1 4b			ld a, (.dmark+1)  
4be5 32 be fb			ld (debug_mark+1),a  
4be8 3a f2 4b			ld a, (.dmark+2)  
4beb 32 bf fb			ld (debug_mark+2),a  
4bee 18 03			jr .pastdmark  
4bf0 ..			.dmark: db "REF"  
4bf3 f1			.pastdmark: pop af  
4bf4			endm  
# End of macro DMARK
4bf4					CALLMONITOR 
4bf4 cd 1c 17			call break_point_state  
4bf7				endm  
# End of macro CALLMONITOR
4bf7				endif 
4bf7				       NEXTW 
4bf7 c3 15 20			jp macro_next 
4bfa				endm 
# End of macro NEXTW
4bfa			 
4bfa .. 00		.showeof:   db "eof", 0 
4bfe			 
4bfe			 
4bfe			.EOF: 
4bfe				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4bfe 6d				db WORD_SYS_CORE+89             
4bff 3f 4c			dw .FORMAT            
4c01 04				db 3 + 1 
4c02 .. 00			db "EOF",0              
4c06				endm 
# End of macro CWHEAD
4c06			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c06			; | | e.g. 
4c06			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c06					; TODO if current block id for stream is zero then push true else false 
4c06			 
4c06					if DEBUG_FORTH_WORDS_KEY 
4c06						DMARK "EOF" 
4c06 f5				push af  
4c07 3a 1b 4c			ld a, (.dmark)  
4c0a 32 bd fb			ld (debug_mark),a  
4c0d 3a 1c 4c			ld a, (.dmark+1)  
4c10 32 be fb			ld (debug_mark+1),a  
4c13 3a 1d 4c			ld a, (.dmark+2)  
4c16 32 bf fb			ld (debug_mark+2),a  
4c19 18 03			jr .pastdmark  
4c1b ..			.dmark: db "EOF"  
4c1e f1			.pastdmark: pop af  
4c1f			endm  
# End of macro DMARK
4c1f						CALLMONITOR 
4c1f cd 1c 17			call break_point_state  
4c22				endm  
# End of macro CALLMONITOR
4c22					endif 
4c22			 
4c22					; TODO handlue multiple file streams 
4c22			 
4c22					FORTH_DSP_POP     ; for now just get rid of stream id 
4c22 cd 5b 1f			call macro_forth_dsp_pop 
4c25				endm 
# End of macro FORTH_DSP_POP
4c25			 
4c25 2e 01				ld l, 1 
4c27 3a de f9				ld a, (store_openmaxext) 
4c2a fe 00				cp 0 
4c2c 28 09				jr  z, .eofdone   ; empty file 
4c2e 3a df f9				ld a, (store_openext) 
4c31 fe 00				cp 0 
4c33 28 02				jr  z, .eofdone 
4c35 2e 00				ld l, 0 
4c37 26 00		.eofdone:	ld h, 0 
4c39 cd ac 1c				call forth_push_numhl 
4c3c			 
4c3c			 
4c3c				       NEXTW 
4c3c c3 15 20			jp macro_next 
4c3f				endm 
# End of macro NEXTW
4c3f			 
4c3f			.FORMAT: 
4c3f				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4c3f 6d				db WORD_SYS_CORE+89             
4c40 90 4c			dw .LABEL            
4c42 07				db 6 + 1 
4c43 .. 00			db "FORMAT",0              
4c4a				endm 
# End of macro CWHEAD
4c4a			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4c4a					; TODO if current block id for stream is zero then push true else false 
4c4a				 
4c4a				if DEBUG_STORESE 
4c4a					DMARK "FOR" 
4c4a f5				push af  
4c4b 3a 5f 4c			ld a, (.dmark)  
4c4e 32 bd fb			ld (debug_mark),a  
4c51 3a 60 4c			ld a, (.dmark+1)  
4c54 32 be fb			ld (debug_mark+1),a  
4c57 3a 61 4c			ld a, (.dmark+2)  
4c5a 32 bf fb			ld (debug_mark+2),a  
4c5d 18 03			jr .pastdmark  
4c5f ..			.dmark: db "FOR"  
4c62 f1			.pastdmark: pop af  
4c63			endm  
# End of macro DMARK
4c63					CALLMONITOR 
4c63 cd 1c 17			call break_point_state  
4c66				endm  
# End of macro CALLMONITOR
4c66				endif 
4c66					; Wipes the bank check flags to cause a reformat on next block 0 read 
4c66			 
4c66 21 01 00				ld hl, 1 
4c69 3e 00				ld a, 0 
4c6b cd e7 01				call se_writebyte 
4c6e			 
4c6e				if DEBUG_STORESE 
4c6e					DMARK "FO0" 
4c6e f5				push af  
4c6f 3a 83 4c			ld a, (.dmark)  
4c72 32 bd fb			ld (debug_mark),a  
4c75 3a 84 4c			ld a, (.dmark+1)  
4c78 32 be fb			ld (debug_mark+1),a  
4c7b 3a 85 4c			ld a, (.dmark+2)  
4c7e 32 bf fb			ld (debug_mark+2),a  
4c81 18 03			jr .pastdmark  
4c83 ..			.dmark: db "FO0"  
4c86 f1			.pastdmark: pop af  
4c87			endm  
# End of macro DMARK
4c87					CALLMONITOR 
4c87 cd 1c 17			call break_point_state  
4c8a				endm  
# End of macro CALLMONITOR
4c8a				endif 
4c8a					; force bank init 
4c8a			 
4c8a cd ba 03				call storage_get_block_0 
4c8d					 
4c8d				       NEXTW 
4c8d c3 15 20			jp macro_next 
4c90				endm 
# End of macro NEXTW
4c90			.LABEL: 
4c90				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4c90 6d				db WORD_SYS_CORE+89             
4c91 de 4c			dw .STOREPAGE            
4c93 06				db 5 + 1 
4c94 .. 00			db "LABEL",0              
4c9a				endm 
# End of macro CWHEAD
4c9a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4c9a					; TODO test to see if bank is selected 
4c9a				 
4c9a					if DEBUG_FORTH_WORDS_KEY 
4c9a						DMARK "LBL" 
4c9a f5				push af  
4c9b 3a af 4c			ld a, (.dmark)  
4c9e 32 bd fb			ld (debug_mark),a  
4ca1 3a b0 4c			ld a, (.dmark+1)  
4ca4 32 be fb			ld (debug_mark+1),a  
4ca7 3a b1 4c			ld a, (.dmark+2)  
4caa 32 bf fb			ld (debug_mark+2),a  
4cad 18 03			jr .pastdmark  
4caf ..			.dmark: db "LBL"  
4cb2 f1			.pastdmark: pop af  
4cb3			endm  
# End of macro DMARK
4cb3						CALLMONITOR 
4cb3 cd 1c 17			call break_point_state  
4cb6				endm  
# End of macro CALLMONITOR
4cb6					endif 
4cb6			;	if DEBUG_STORESE 
4cb6			;		DMARK "LBL" 
4cb6			;		CALLMONITOR 
4cb6			;	endif 
4cb6					FORTH_DSP_VALUEHL 
4cb6 cd a3 1e			call macro_dsp_valuehl 
4cb9				endm 
# End of macro FORTH_DSP_VALUEHL
4cb9					;v5FORTH_DSP_VALUE 
4cb9					 
4cb9			;		push hl 
4cb9					FORTH_DSP_POP 
4cb9 cd 5b 1f			call macro_forth_dsp_pop 
4cbc				endm 
# End of macro FORTH_DSP_POP
4cbc			;		pop hl 
4cbc			 
4cbc			;v5		inc hl   ; move past the type marker 
4cbc			 
4cbc				if DEBUG_STORESE 
4cbc					DMARK "LBl" 
4cbc f5				push af  
4cbd 3a d1 4c			ld a, (.dmark)  
4cc0 32 bd fb			ld (debug_mark),a  
4cc3 3a d2 4c			ld a, (.dmark+1)  
4cc6 32 be fb			ld (debug_mark+1),a  
4cc9 3a d3 4c			ld a, (.dmark+2)  
4ccc 32 bf fb			ld (debug_mark+2),a  
4ccf 18 03			jr .pastdmark  
4cd1 ..			.dmark: db "LBl"  
4cd4 f1			.pastdmark: pop af  
4cd5			endm  
# End of macro DMARK
4cd5					CALLMONITOR 
4cd5 cd 1c 17			call break_point_state  
4cd8				endm  
# End of macro CALLMONITOR
4cd8				endif 
4cd8 cd de 04				call storage_label 
4cdb			 
4cdb				       NEXTW 
4cdb c3 15 20			jp macro_next 
4cde				endm 
# End of macro NEXTW
4cde			.STOREPAGE: 
4cde				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4cde 6d				db WORD_SYS_CORE+89             
4cdf 11 4d			dw .LABELS            
4ce1 0a				db 9 + 1 
4ce2 .. 00			db "STOREPAGE",0              
4cec				endm 
# End of macro CWHEAD
4cec			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4cec					; TODO test to see if bank is selected 
4cec				 
4cec					if DEBUG_FORTH_WORDS_KEY 
4cec						DMARK "STP" 
4cec f5				push af  
4ced 3a 01 4d			ld a, (.dmark)  
4cf0 32 bd fb			ld (debug_mark),a  
4cf3 3a 02 4d			ld a, (.dmark+1)  
4cf6 32 be fb			ld (debug_mark+1),a  
4cf9 3a 03 4d			ld a, (.dmark+2)  
4cfc 32 bf fb			ld (debug_mark+2),a  
4cff 18 03			jr .pastdmark  
4d01 ..			.dmark: db "STP"  
4d04 f1			.pastdmark: pop af  
4d05			endm  
# End of macro DMARK
4d05						CALLMONITOR 
4d05 cd 1c 17			call break_point_state  
4d08				endm  
# End of macro CALLMONITOR
4d08					endif 
4d08			;	if DEBUG_STORESE 
4d08			;		DMARK "STP" 
4d08			;		CALLMONITOR 
4d08			;	endif 
4d08			 
4d08 21 e8 f9			ld hl, store_page 
4d0b cd ac 1c			call forth_push_numhl 
4d0e			 
4d0e			 
4d0e				       NEXTW 
4d0e c3 15 20			jp macro_next 
4d11				endm 
# End of macro NEXTW
4d11			.LABELS: 
4d11				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d11 6d				db WORD_SYS_CORE+89             
4d12 9b 4d			dw .ENDSTORAGE            
4d14 07				db 6 + 1 
4d15 .. 00			db "LABELS",0              
4d1c				endm 
# End of macro CWHEAD
4d1c			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d1c					;  
4d1c			 
4d1c					; save the current device selected to restore afterwards 
4d1c				 
4d1c 3a ce f9				ld a, (spi_device) 
4d1f f5					push af 
4d20			 
4d20			 
4d20					; run through each of the banks 
4d20			 
4d20 21 01 00				ld hl, 1 
4d23 cd ac 1c				call forth_push_numhl 
4d26 3e ff				ld a, SPI_CE_HIGH 
4d28 cb 87				res SPI_CE0, a 
4d2a 32 ce f9				ld (spi_device), a 
4d2d cd ba 03				call storage_get_block_0 
4d30 21 eb f9				ld hl, store_page+3 
4d33 cd 1a 1d				call forth_push_str 
4d36			 
4d36					 
4d36 21 02 00				ld hl, 2 
4d39 cd ac 1c				call forth_push_numhl 
4d3c 3e ff				ld a, SPI_CE_HIGH 
4d3e cb 8f				res SPI_CE1, a 
4d40 32 ce f9				ld (spi_device), a 
4d43 cd ba 03				call storage_get_block_0 
4d46 21 eb f9				ld hl, store_page+3 
4d49 cd 1a 1d				call forth_push_str 
4d4c			 
4d4c					 
4d4c 21 03 00				ld hl, 3 
4d4f cd ac 1c				call forth_push_numhl 
4d52 3e ff				ld a, SPI_CE_HIGH 
4d54 cb 97				res SPI_CE2, a 
4d56 32 ce f9				ld (spi_device), a 
4d59 cd ba 03				call storage_get_block_0 
4d5c 21 eb f9				ld hl, store_page+3 
4d5f cd 1a 1d				call forth_push_str 
4d62			 
4d62			 
4d62 21 04 00				ld hl, 4 
4d65 cd ac 1c				call forth_push_numhl 
4d68 3e ff				ld a, SPI_CE_HIGH 
4d6a cb 9f				res SPI_CE3, a 
4d6c 32 ce f9				ld (spi_device), a 
4d6f cd ba 03				call storage_get_block_0 
4d72 21 eb f9				ld hl, store_page+3 
4d75 cd 1a 1d				call forth_push_str 
4d78			 
4d78					 
4d78			 
4d78 21 05 00				ld hl, 5 
4d7b cd ac 1c				call forth_push_numhl 
4d7e 3e ff				ld a, SPI_CE_HIGH 
4d80 cb a7				res SPI_CE4, a 
4d82 32 ce f9				ld (spi_device), a 
4d85 cd ba 03				call storage_get_block_0 
4d88 21 eb f9				ld hl, store_page+3 
4d8b cd 1a 1d				call forth_push_str 
4d8e			 
4d8e					 
4d8e					; push fixed count of storage devices (on board) for now 
4d8e			 
4d8e 21 05 00				ld hl, 5 
4d91 cd ac 1c				call forth_push_numhl 
4d94			 
4d94					; restore selected device  
4d94				 
4d94 f1					pop af 
4d95 32 ce f9				ld (spi_device), a 
4d98			 
4d98				       NEXTW 
4d98 c3 15 20			jp macro_next 
4d9b				endm 
# End of macro NEXTW
4d9b			 
4d9b			.ENDSTORAGE: 
4d9b			; eof 
# End of file forth_words_storage.asm
4d9b			endif 
4d9b				include "forth_words_device.asm" 
4d9b			; Device related words 
4d9b			 
4d9b			; | ## Device Words 
4d9b			 
4d9b			if SOUND_ENABLE 
4d9b			.NOTE: 
4d9b				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4d9b			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4d9b					if DEBUG_FORTH_WORDS_KEY 
4d9b						DMARK "NTE" 
4d9b						CALLMONITOR 
4d9b					endif 
4d9b			 
4d9b				 
4d9b			 
4d9b					NEXTW 
4d9b			.AFTERSOUND: 
4d9b			endif 
4d9b			 
4d9b			 
4d9b			USE_GPIO: equ 0 
4d9b			 
4d9b			if USE_GPIO 
4d9b			.GP1: 
4d9b				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4d9b			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4d9b					NEXTW 
4d9b			.GP2: 
4d9b				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4d9b			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4d9b			 
4d9b					NEXTW 
4d9b			 
4d9b			.GP3: 
4d9b				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4d9b			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4d9b			 
4d9b					NEXTW 
4d9b			 
4d9b			.GP4: 
4d9b				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4d9b			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4d9b			 
4d9b					NEXTW 
4d9b			.SIN: 
4d9b			 
4d9b			 
4d9b			endif 
4d9b			 
4d9b			 
4d9b				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4d9b 33				db WORD_SYS_CORE+31             
4d9c d0 4d			dw .SOUT            
4d9e 03				db 2 + 1 
4d9f .. 00			db "IN",0              
4da2				endm 
# End of macro CWHEAD
4da2			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4da2					if DEBUG_FORTH_WORDS_KEY 
4da2						DMARK "IN." 
4da2 f5				push af  
4da3 3a b7 4d			ld a, (.dmark)  
4da6 32 bd fb			ld (debug_mark),a  
4da9 3a b8 4d			ld a, (.dmark+1)  
4dac 32 be fb			ld (debug_mark+1),a  
4daf 3a b9 4d			ld a, (.dmark+2)  
4db2 32 bf fb			ld (debug_mark+2),a  
4db5 18 03			jr .pastdmark  
4db7 ..			.dmark: db "IN."  
4dba f1			.pastdmark: pop af  
4dbb			endm  
# End of macro DMARK
4dbb						CALLMONITOR 
4dbb cd 1c 17			call break_point_state  
4dbe				endm  
# End of macro CALLMONITOR
4dbe					endif 
4dbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dbe cd a3 1e			call macro_dsp_valuehl 
4dc1				endm 
# End of macro FORTH_DSP_VALUEHL
4dc1			 
4dc1 e5					push hl 
4dc2			 
4dc2					; destroy value TOS 
4dc2			 
4dc2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dc2 cd 5b 1f			call macro_forth_dsp_pop 
4dc5				endm 
# End of macro FORTH_DSP_POP
4dc5			 
4dc5					; one value on hl get other one back 
4dc5			 
4dc5 c1					pop bc 
4dc6			 
4dc6					; do the sub 
4dc6			;		ex de, hl 
4dc6			 
4dc6 ed 68				in l,(c) 
4dc8			 
4dc8					; save it 
4dc8			 
4dc8 26 00				ld h,0 
4dca			 
4dca					; TODO push value back onto stack for another op etc 
4dca			 
4dca cd ac 1c				call forth_push_numhl 
4dcd					NEXTW 
4dcd c3 15 20			jp macro_next 
4dd0				endm 
# End of macro NEXTW
4dd0			.SOUT: 
4dd0				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4dd0 34				db WORD_SYS_CORE+32             
4dd1 23 4e			dw .SPIO            
4dd3 04				db 3 + 1 
4dd4 .. 00			db "OUT",0              
4dd8				endm 
# End of macro CWHEAD
4dd8			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4dd8					if DEBUG_FORTH_WORDS_KEY 
4dd8						DMARK "OUT" 
4dd8 f5				push af  
4dd9 3a ed 4d			ld a, (.dmark)  
4ddc 32 bd fb			ld (debug_mark),a  
4ddf 3a ee 4d			ld a, (.dmark+1)  
4de2 32 be fb			ld (debug_mark+1),a  
4de5 3a ef 4d			ld a, (.dmark+2)  
4de8 32 bf fb			ld (debug_mark+2),a  
4deb 18 03			jr .pastdmark  
4ded ..			.dmark: db "OUT"  
4df0 f1			.pastdmark: pop af  
4df1			endm  
# End of macro DMARK
4df1						CALLMONITOR 
4df1 cd 1c 17			call break_point_state  
4df4				endm  
# End of macro CALLMONITOR
4df4					endif 
4df4			 
4df4					; get port 
4df4			 
4df4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4df4 cd a3 1e			call macro_dsp_valuehl 
4df7				endm 
# End of macro FORTH_DSP_VALUEHL
4df7			 
4df7 e5					push hl 
4df8			 
4df8					; destroy value TOS 
4df8			 
4df8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4df8 cd 5b 1f			call macro_forth_dsp_pop 
4dfb				endm 
# End of macro FORTH_DSP_POP
4dfb			 
4dfb					; get byte to send 
4dfb			 
4dfb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dfb cd a3 1e			call macro_dsp_valuehl 
4dfe				endm 
# End of macro FORTH_DSP_VALUEHL
4dfe			 
4dfe			;		push hl 
4dfe			 
4dfe					; destroy value TOS 
4dfe			 
4dfe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dfe cd 5b 1f			call macro_forth_dsp_pop 
4e01				endm 
# End of macro FORTH_DSP_POP
4e01			 
4e01					; one value on hl get other one back 
4e01			 
4e01			;		pop hl 
4e01			 
4e01 c1					pop bc 
4e02			 
4e02					if DEBUG_FORTH_WORDS 
4e02						DMARK "OUT" 
4e02 f5				push af  
4e03 3a 17 4e			ld a, (.dmark)  
4e06 32 bd fb			ld (debug_mark),a  
4e09 3a 18 4e			ld a, (.dmark+1)  
4e0c 32 be fb			ld (debug_mark+1),a  
4e0f 3a 19 4e			ld a, (.dmark+2)  
4e12 32 bf fb			ld (debug_mark+2),a  
4e15 18 03			jr .pastdmark  
4e17 ..			.dmark: db "OUT"  
4e1a f1			.pastdmark: pop af  
4e1b			endm  
# End of macro DMARK
4e1b						CALLMONITOR 
4e1b cd 1c 17			call break_point_state  
4e1e				endm  
# End of macro CALLMONITOR
4e1e					endif 
4e1e			 
4e1e ed 69				out (c), l 
4e20			 
4e20					NEXTW 
4e20 c3 15 20			jp macro_next 
4e23				endm 
# End of macro NEXTW
4e23			 
4e23			 
4e23			.SPIO: 
4e23			 
4e23			if STORAGE_SE 
4e23				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4e23 51				db WORD_SYS_CORE+61             
4e24 34 4e			dw .SPICEH            
4e26 07				db 6 + 1 
4e27 .. 00			db "SPICEL",0              
4e2e				endm 
# End of macro CWHEAD
4e2e			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4e2e			 
4e2e cd 95 01				call spi_ce_low 
4e31			    NEXTW 
4e31 c3 15 20			jp macro_next 
4e34				endm 
# End of macro NEXTW
4e34			 
4e34			.SPICEH: 
4e34				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4e34 51				db WORD_SYS_CORE+61             
4e35 45 4e			dw .SPIOb            
4e37 07				db 6 + 1 
4e38 .. 00			db "SPICEH",0              
4e3f				endm 
# End of macro CWHEAD
4e3f			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4e3f			 
4e3f cd 84 01				call spi_ce_high 
4e42			    NEXTW 
4e42 c3 15 20			jp macro_next 
4e45				endm 
# End of macro NEXTW
4e45			 
4e45			 
4e45			.SPIOb: 
4e45			 
4e45				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4e45 51				db WORD_SYS_CORE+61             
4e46 5b 4e			dw .SPII            
4e48 05				db 4 + 1 
4e49 .. 00			db "SPIO",0              
4e4e				endm 
# End of macro CWHEAD
4e4e			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4e4e			 
4e4e					; get port 
4e4e			 
4e4e			 
4e4e					; get byte to send 
4e4e			 
4e4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e4e cd a3 1e			call macro_dsp_valuehl 
4e51				endm 
# End of macro FORTH_DSP_VALUEHL
4e51			 
4e51			;		push hl    ; u1  
4e51			 
4e51					; destroy value TOS 
4e51			 
4e51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e51 cd 5b 1f			call macro_forth_dsp_pop 
4e54				endm 
# End of macro FORTH_DSP_POP
4e54			 
4e54					; one value on hl get other one back 
4e54			 
4e54			;		pop hl   ; u2 - addr 
4e54			 
4e54					; TODO Send SPI byte 
4e54			 
4e54 7d					ld a, l 
4e55 cd b9 00				call spi_send_byte 
4e58			 
4e58					NEXTW 
4e58 c3 15 20			jp macro_next 
4e5b				endm 
# End of macro NEXTW
4e5b			 
4e5b			.SPII: 
4e5b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4e5b 52				db WORD_SYS_CORE+62             
4e5c 70 4e			dw .SESEL            
4e5e 06				db 5 + 1 
4e5f .. 00			db "SPII",0              
4e64				endm 
# End of macro CWHEAD
4e64			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4e64			 
4e64					; TODO Get SPI byte 
4e64			 
4e64 cd da 00				call spi_read_byte 
4e67			 
4e67 26 00				ld h, 0 
4e69 6f					ld l, a 
4e6a cd ac 1c				call forth_push_numhl 
4e6d			 
4e6d					NEXTW 
4e6d c3 15 20			jp macro_next 
4e70				endm 
# End of macro NEXTW
4e70			 
4e70			 
4e70			 
4e70			.SESEL: 
4e70				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4e70 66				db WORD_SYS_CORE+82             
4e71 14 4f			dw .CARTDEV            
4e73 05				db 4 + 1 
4e74 .. 00			db "BANK",0              
4e79				endm 
# End of macro CWHEAD
4e79			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4e79					if DEBUG_FORTH_WORDS_KEY 
4e79						DMARK "BNK" 
4e79 f5				push af  
4e7a 3a 8e 4e			ld a, (.dmark)  
4e7d 32 bd fb			ld (debug_mark),a  
4e80 3a 8f 4e			ld a, (.dmark+1)  
4e83 32 be fb			ld (debug_mark+1),a  
4e86 3a 90 4e			ld a, (.dmark+2)  
4e89 32 bf fb			ld (debug_mark+2),a  
4e8c 18 03			jr .pastdmark  
4e8e ..			.dmark: db "BNK"  
4e91 f1			.pastdmark: pop af  
4e92			endm  
# End of macro DMARK
4e92						CALLMONITOR 
4e92 cd 1c 17			call break_point_state  
4e95				endm  
# End of macro CALLMONITOR
4e95					endif 
4e95			 
4e95 3e ff				ld a, 255 
4e97 32 d1 f9				ld (spi_cartdev), a 
4e9a			 
4e9a					; get bank 
4e9a			 
4e9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e9a cd a3 1e			call macro_dsp_valuehl 
4e9d				endm 
# End of macro FORTH_DSP_VALUEHL
4e9d			 
4e9d			;		push hl 
4e9d			 
4e9d					; destroy value TOS 
4e9d			 
4e9d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e9d cd 5b 1f			call macro_forth_dsp_pop 
4ea0				endm 
# End of macro FORTH_DSP_POP
4ea0			 
4ea0					; one value on hl get other one back 
4ea0			 
4ea0			;		pop hl 
4ea0			 
4ea0			 
4ea0 0e ff				ld c, SPI_CE_HIGH 
4ea2 06 30				ld b, '0'    ; human readable bank number 
4ea4			 
4ea4 7d					ld a, l 
4ea5			 
4ea5					if DEBUG_FORTH_WORDS 
4ea5						DMARK "BNK" 
4ea5 f5				push af  
4ea6 3a ba 4e			ld a, (.dmark)  
4ea9 32 bd fb			ld (debug_mark),a  
4eac 3a bb 4e			ld a, (.dmark+1)  
4eaf 32 be fb			ld (debug_mark+1),a  
4eb2 3a bc 4e			ld a, (.dmark+2)  
4eb5 32 bf fb			ld (debug_mark+2),a  
4eb8 18 03			jr .pastdmark  
4eba ..			.dmark: db "BNK"  
4ebd f1			.pastdmark: pop af  
4ebe			endm  
# End of macro DMARK
4ebe						CALLMONITOR 
4ebe cd 1c 17			call break_point_state  
4ec1				endm  
# End of macro CALLMONITOR
4ec1					endif 
4ec1			 
4ec1					; active low 
4ec1			 
4ec1 fe 00				cp 0 
4ec3 28 28				jr z, .bset 
4ec5 fe 01				cp 1 
4ec7 20 04				jr nz, .b2 
4ec9 cb 81				res 0, c 
4ecb 06 31				ld b, '1'    ; human readable bank number 
4ecd fe 02		.b2:		cp 2 
4ecf 20 04				jr nz, .b3 
4ed1 cb 89				res 1, c 
4ed3 06 32				ld b, '2'    ; human readable bank number 
4ed5 fe 03		.b3:		cp 3 
4ed7 20 04				jr nz, .b4 
4ed9 cb 91				res 2, c 
4edb 06 33				ld b, '3'    ; human readable bank number 
4edd fe 04		.b4:		cp 4 
4edf 20 04				jr nz, .b5 
4ee1 cb 99				res 3, c 
4ee3 06 34				ld b, '4'    ; human readable bank number 
4ee5 fe 05		.b5:		cp 5 
4ee7 20 04				jr nz, .bset 
4ee9 cb a1				res 4, c 
4eeb 06 35				ld b, '5'    ; human readable bank number 
4eed			 
4eed			.bset: 
4eed 79					ld a, c 
4eee 32 ce f9				ld (spi_device),a 
4ef1 78					ld a, b 
4ef2 32 cd f9				ld (spi_device_id),a 
4ef5					if DEBUG_FORTH_WORDS 
4ef5						DMARK "BN2" 
4ef5 f5				push af  
4ef6 3a 0a 4f			ld a, (.dmark)  
4ef9 32 bd fb			ld (debug_mark),a  
4efc 3a 0b 4f			ld a, (.dmark+1)  
4eff 32 be fb			ld (debug_mark+1),a  
4f02 3a 0c 4f			ld a, (.dmark+2)  
4f05 32 bf fb			ld (debug_mark+2),a  
4f08 18 03			jr .pastdmark  
4f0a ..			.dmark: db "BN2"  
4f0d f1			.pastdmark: pop af  
4f0e			endm  
# End of macro DMARK
4f0e						CALLMONITOR 
4f0e cd 1c 17			call break_point_state  
4f11				endm  
# End of macro CALLMONITOR
4f11					endif 
4f11			 
4f11					NEXTW 
4f11 c3 15 20			jp macro_next 
4f14				endm 
# End of macro NEXTW
4f14			 
4f14			.CARTDEV: 
4f14				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4f14 66				db WORD_SYS_CORE+82             
4f15 bd 4f			dw .ENDDEVICE            
4f17 08				db 7 + 1 
4f18 .. 00			db "CARTDEV",0              
4f20				endm 
# End of macro CWHEAD
4f20			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4f20					if DEBUG_FORTH_WORDS_KEY 
4f20						DMARK "CDV" 
4f20 f5				push af  
4f21 3a 35 4f			ld a, (.dmark)  
4f24 32 bd fb			ld (debug_mark),a  
4f27 3a 36 4f			ld a, (.dmark+1)  
4f2a 32 be fb			ld (debug_mark+1),a  
4f2d 3a 37 4f			ld a, (.dmark+2)  
4f30 32 bf fb			ld (debug_mark+2),a  
4f33 18 03			jr .pastdmark  
4f35 ..			.dmark: db "CDV"  
4f38 f1			.pastdmark: pop af  
4f39			endm  
# End of macro DMARK
4f39						CALLMONITOR 
4f39 cd 1c 17			call break_point_state  
4f3c				endm  
# End of macro CALLMONITOR
4f3c					endif 
4f3c			 
4f3c					; disable se storage bank selection 
4f3c			 
4f3c 3e ff				ld a, SPI_CE_HIGH		; ce high 
4f3e 32 ce f9				ld (spi_device), a 
4f41			 
4f41					; get bank 
4f41			 
4f41					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f41 cd a3 1e			call macro_dsp_valuehl 
4f44				endm 
# End of macro FORTH_DSP_VALUEHL
4f44			 
4f44			;		push hl 
4f44			 
4f44					; destroy value TOS 
4f44			 
4f44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f44 cd 5b 1f			call macro_forth_dsp_pop 
4f47				endm 
# End of macro FORTH_DSP_POP
4f47			 
4f47					; one value on hl get other one back 
4f47			 
4f47			;		pop hl 
4f47			 
4f47					; active low 
4f47			 
4f47 0e ff				ld c, 255 
4f49			 
4f49 7d					ld a, l 
4f4a					if DEBUG_FORTH_WORDS 
4f4a						DMARK "CDV" 
4f4a f5				push af  
4f4b 3a 5f 4f			ld a, (.dmark)  
4f4e 32 bd fb			ld (debug_mark),a  
4f51 3a 60 4f			ld a, (.dmark+1)  
4f54 32 be fb			ld (debug_mark+1),a  
4f57 3a 61 4f			ld a, (.dmark+2)  
4f5a 32 bf fb			ld (debug_mark+2),a  
4f5d 18 03			jr .pastdmark  
4f5f ..			.dmark: db "CDV"  
4f62 f1			.pastdmark: pop af  
4f63			endm  
# End of macro DMARK
4f63						CALLMONITOR 
4f63 cd 1c 17			call break_point_state  
4f66				endm  
# End of macro CALLMONITOR
4f66					endif 
4f66 fe 00				cp 0 
4f68 28 30				jr z, .cset 
4f6a fe 01				cp 1 
4f6c 20 02				jr nz, .c2 
4f6e cb 81				res 0, c 
4f70 fe 02		.c2:		cp 2 
4f72 20 02				jr nz, .c3 
4f74 cb 89				res 1, c 
4f76 fe 03		.c3:		cp 3 
4f78 20 02				jr nz, .c4 
4f7a cb 91				res 2, c 
4f7c fe 04		.c4:		cp 4 
4f7e 20 02				jr nz, .c5 
4f80 cb 99				res 3, c 
4f82 fe 05		.c5:		cp 5 
4f84 20 02				jr nz, .c6 
4f86 cb a1				res 4, c 
4f88 fe 06		.c6:		cp 6 
4f8a 20 02				jr nz, .c7 
4f8c cb a9				res 5, c 
4f8e fe 07		.c7:		cp 7 
4f90 20 02				jr nz, .c8 
4f92 cb b1				res 6, c 
4f94 fe 08		.c8:		cp 8 
4f96 20 02				jr nz, .cset 
4f98 cb b9				res 7, c 
4f9a 79			.cset:		ld a, c 
4f9b 32 d1 f9				ld (spi_cartdev),a 
4f9e			 
4f9e					if DEBUG_FORTH_WORDS 
4f9e						DMARK "CD2" 
4f9e f5				push af  
4f9f 3a b3 4f			ld a, (.dmark)  
4fa2 32 bd fb			ld (debug_mark),a  
4fa5 3a b4 4f			ld a, (.dmark+1)  
4fa8 32 be fb			ld (debug_mark+1),a  
4fab 3a b5 4f			ld a, (.dmark+2)  
4fae 32 bf fb			ld (debug_mark+2),a  
4fb1 18 03			jr .pastdmark  
4fb3 ..			.dmark: db "CD2"  
4fb6 f1			.pastdmark: pop af  
4fb7			endm  
# End of macro DMARK
4fb7						CALLMONITOR 
4fb7 cd 1c 17			call break_point_state  
4fba				endm  
# End of macro CALLMONITOR
4fba					endif 
4fba					NEXTW 
4fba c3 15 20			jp macro_next 
4fbd				endm 
# End of macro NEXTW
4fbd			endif 
4fbd			 
4fbd			.ENDDEVICE: 
4fbd			; eof 
4fbd			 
# End of file forth_words_device.asm
4fbd			 
4fbd			; var handler 
4fbd			 
4fbd			 
4fbd			.VARS: 
4fbd				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4fbd 78				db WORD_SYS_CORE+100             
4fbe d5 4f			dw .V0Q            
4fc0 04				db 3 + 1 
4fc1 .. 00			db "V0!",0              
4fc5				endm 
# End of macro CWHEAD
4fc5			;| V0! ( u1 -- )  Store value to v0  | DONE 
4fc5			 
4fc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fc5 cd a3 1e			call macro_dsp_valuehl 
4fc8				endm 
# End of macro FORTH_DSP_VALUEHL
4fc8			 
4fc8 11 96 f9				ld de, cli_var_array 
4fcb			 
4fcb eb					ex de, hl 
4fcc 73					ld (hl), e 
4fcd 23					inc hl 
4fce 72					ld (hl), d 
4fcf			 
4fcf					; destroy value TOS 
4fcf			 
4fcf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fcf cd 5b 1f			call macro_forth_dsp_pop 
4fd2				endm 
# End of macro FORTH_DSP_POP
4fd2			 
4fd2				       NEXTW 
4fd2 c3 15 20			jp macro_next 
4fd5				endm 
# End of macro NEXTW
4fd5			.V0Q: 
4fd5				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4fd5 79				db WORD_SYS_CORE+101             
4fd6 e6 4f			dw .V1S            
4fd8 04				db 3 + 1 
4fd9 .. 00			db "V0@",0              
4fdd				endm 
# End of macro CWHEAD
4fdd			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4fdd 2a 96 f9				ld hl, (cli_var_array) 
4fe0 cd ac 1c				call forth_push_numhl 
4fe3			 
4fe3				       NEXTW 
4fe3 c3 15 20			jp macro_next 
4fe6				endm 
# End of macro NEXTW
4fe6			.V1S: 
4fe6				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4fe6 7a				db WORD_SYS_CORE+102             
4fe7 fe 4f			dw .V1Q            
4fe9 04				db 3 + 1 
4fea .. 00			db "V1!",0              
4fee				endm 
# End of macro CWHEAD
4fee			;| V1! ( u1 -- )  Store value to v1 | DONE 
4fee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fee cd a3 1e			call macro_dsp_valuehl 
4ff1				endm 
# End of macro FORTH_DSP_VALUEHL
4ff1			 
4ff1 11 98 f9				ld de, cli_var_array+2 
4ff4				 
4ff4 eb					ex de, hl 
4ff5 73					ld (hl), e 
4ff6 23					inc hl 
4ff7 72					ld (hl), d 
4ff8			 
4ff8					; destroy value TOS 
4ff8			 
4ff8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ff8 cd 5b 1f			call macro_forth_dsp_pop 
4ffb				endm 
# End of macro FORTH_DSP_POP
4ffb				       NEXTW 
4ffb c3 15 20			jp macro_next 
4ffe				endm 
# End of macro NEXTW
4ffe			.V1Q: 
4ffe				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4ffe 7b				db WORD_SYS_CORE+103             
4fff 0f 50			dw .V2S            
5001 04				db 3 + 1 
5002 .. 00			db "V1@",0              
5006				endm 
# End of macro CWHEAD
5006			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5006 2a 98 f9				ld hl, (cli_var_array+2) 
5009 cd ac 1c				call forth_push_numhl 
500c				       NEXTW 
500c c3 15 20			jp macro_next 
500f				endm 
# End of macro NEXTW
500f			.V2S: 
500f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
500f 7c				db WORD_SYS_CORE+104             
5010 27 50			dw .V2Q            
5012 04				db 3 + 1 
5013 .. 00			db "V2!",0              
5017				endm 
# End of macro CWHEAD
5017			;| V2! ( u1 -- )  Store value to v2 | DONE 
5017					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5017 cd a3 1e			call macro_dsp_valuehl 
501a				endm 
# End of macro FORTH_DSP_VALUEHL
501a			 
501a 11 9a f9				ld de, cli_var_array+4 
501d				 
501d eb					ex de, hl 
501e 73					ld (hl), e 
501f 23					inc hl 
5020 72					ld (hl), d 
5021			 
5021					; destroy value TOS 
5021			 
5021					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5021 cd 5b 1f			call macro_forth_dsp_pop 
5024				endm 
# End of macro FORTH_DSP_POP
5024				       NEXTW 
5024 c3 15 20			jp macro_next 
5027				endm 
# End of macro NEXTW
5027			.V2Q: 
5027				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5027 7d				db WORD_SYS_CORE+105             
5028 38 50			dw .V3S            
502a 04				db 3 + 1 
502b .. 00			db "V2@",0              
502f				endm 
# End of macro CWHEAD
502f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
502f 2a 9a f9				ld hl, (cli_var_array+4) 
5032 cd ac 1c				call forth_push_numhl 
5035				       NEXTW 
5035 c3 15 20			jp macro_next 
5038				endm 
# End of macro NEXTW
5038			.V3S: 
5038				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5038 7c				db WORD_SYS_CORE+104             
5039 50 50			dw .V3Q            
503b 04				db 3 + 1 
503c .. 00			db "V3!",0              
5040				endm 
# End of macro CWHEAD
5040			;| V3! ( u1 -- )  Store value to v3 | DONE 
5040					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5040 cd a3 1e			call macro_dsp_valuehl 
5043				endm 
# End of macro FORTH_DSP_VALUEHL
5043			 
5043 11 9c f9				ld de, cli_var_array+6 
5046				 
5046 eb					ex de, hl 
5047 73					ld (hl), e 
5048 23					inc hl 
5049 72					ld (hl), d 
504a			 
504a					; destroy value TOS 
504a			 
504a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
504a cd 5b 1f			call macro_forth_dsp_pop 
504d				endm 
# End of macro FORTH_DSP_POP
504d				       NEXTW 
504d c3 15 20			jp macro_next 
5050				endm 
# End of macro NEXTW
5050			.V3Q: 
5050				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5050 7d				db WORD_SYS_CORE+105             
5051 61 50			dw .END            
5053 04				db 3 + 1 
5054 .. 00			db "V3@",0              
5058				endm 
# End of macro CWHEAD
5058			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5058 2a 9c f9				ld hl, (cli_var_array+6) 
505b cd ac 1c				call forth_push_numhl 
505e				       NEXTW 
505e c3 15 20			jp macro_next 
5061				endm 
# End of macro NEXTW
5061			 
5061			 
5061			 
5061			 
5061			 
5061			; end of dict marker 
5061			 
5061 00			.END:    db WORD_SYS_END 
5062 00 00			dw 0 
5064 00				db 0 
5065			 
5065			; use to jp here for user dict words to save on macro expansion  
5065			 
5065			user_dict_next: 
5065				NEXTW 
5065 c3 15 20			jp macro_next 
5068				endm 
# End of macro NEXTW
5068			 
5068			 
5068			user_exec: 
5068				;    ld hl, <word code> 
5068				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5068				;    call forthexec 
5068				;    jp user_dict_next   (NEXT) 
5068			        ;    <word code bytes> 
5068 eb				ex de, hl 
5069 2a a4 f2			ld hl,(os_tok_ptr) 
506c				 
506c				FORTH_RSP_NEXT 
506c cd 53 1c			call macro_forth_rsp_next 
506f				endm 
# End of macro FORTH_RSP_NEXT
506f			 
506f			if DEBUG_FORTH_UWORD 
506f						DMARK "UEX" 
506f f5				push af  
5070 3a 84 50			ld a, (.dmark)  
5073 32 bd fb			ld (debug_mark),a  
5076 3a 85 50			ld a, (.dmark+1)  
5079 32 be fb			ld (debug_mark+1),a  
507c 3a 86 50			ld a, (.dmark+2)  
507f 32 bf fb			ld (debug_mark+2),a  
5082 18 03			jr .pastdmark  
5084 ..			.dmark: db "UEX"  
5087 f1			.pastdmark: pop af  
5088			endm  
# End of macro DMARK
5088				CALLMONITOR 
5088 cd 1c 17			call break_point_state  
508b				endm  
# End of macro CALLMONITOR
508b			endif 
508b			 
508b			 
508b			 
508b eb				ex de, hl 
508c 22 a4 f2			ld (os_tok_ptr), hl 
508f				 
508f				; Don't use next - Skips the first word in uword. 
508f			 
508f c3 a6 20			jp exec1 
5092			;	NEXT 
5092			 
5092			 
5092			; eof 
# End of file forth_wordsv4.asm
5092			endif 
5092			;;;;;;;;;;;;;; Debug code 
5092			 
5092			 
5092			;if DEBUG_FORTH_PARSE 
5092 .. 00		.nowordfound: db "No match",0 
509b .. 00		.compword:	db "Comparing word ",0 
50ab .. 00		.nextwordat:	db "Next word at",0 
50b8 .. 00		.charmatch:	db "Char match",0 
50c3			;endif 
50c3			if DEBUG_FORTH_JP 
50c3			.foundword:	db "Word match. Exec..",0 
50c3			endif 
50c3			;if DEBUG_FORTH_PUSH 
50c3 .. 00		.enddict:	db "Dict end. Push.",0 
50d3 .. 00		.push_str:	db "Pushing string",0 
50e2 .. 00		.push_num:	db "Pushing number",0 
50f1 .. 00		.data_sp:	db "SP:",0 
50f5 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5107 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5119 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
512b			;endif 
512b			;if DEBUG_FORTH_MALLOC 
512b .. 00		.push_malloc:	db "Malloc address",0 
513a			;endif 
513a			 
513a			 
513a			 
513a			; display malloc address and current data stack pointer  
513a			 
513a			malloc_error: 
513a d5				push de 
513b f5				push af 
513c e5				push hl 
513d cd d5 0a			call clear_display 
5140 11 62 51			ld de, .mallocerr 
5143 3e 00			ld a,0 
5145			;	ld de,os_word_scratch 
5145 cd e8 0a			call str_at_display 
5148 3e 11			ld a, display_row_1+17 
514a 11 bd fb			ld de, debug_mark 
514d cd e8 0a			call str_at_display 
5150 cd f8 0a			call update_display 
5153				;call break_point_state 
5153 cd b9 66			call cin_wait 
5156			 
5156 3e 20			ld a, ' ' 
5158 32 94 ef			ld (os_view_disable), a 
515b e1				pop hl 
515c f1				pop af 
515d d1				pop de	 
515e				CALLMONITOR 
515e cd 1c 17			call break_point_state  
5161				endm  
# End of macro CALLMONITOR
5161 c9				ret 
5162			 
5162 .. 00		.mallocerr: 	db "Malloc Error",0 
516f			;if DEBUG_FORTH_PUSH 
516f			display_data_sp: 
516f f5				push af 
5170			 
5170				; see if disabled 
5170			 
5170 3a 94 ef			ld a, (os_view_disable) 
5173 fe 2a			cp '*' 
5175 28 67			jr z, .skipdsp 
5177			 
5177 e5				push hl 
5178 e5				push hl 
5179 e5			push hl 
517a cd d5 0a			call clear_display 
517d e1			pop hl 
517e 7c				ld a,h 
517f 21 a8 f2			ld hl, os_word_scratch 
5182 cd 0a 10			call hexout 
5185 e1				pop hl 
5186 7d				ld a,l 
5187 21 aa f2			ld hl, os_word_scratch+2 
518a cd 0a 10			call hexout 
518d 21 ac f2			ld hl, os_word_scratch+4 
5190 3e 00			ld a,0 
5192 77				ld (hl),a 
5193 11 a8 f2			ld de,os_word_scratch 
5196 3e 14				ld a, display_row_2 
5198 cd e8 0a				call str_at_display 
519b 11 f5 50			ld de, .wordinhl 
519e 3e 00			ld a, display_row_1 
51a0			 
51a0 cd e8 0a				call str_at_display 
51a3 11 bd fb			ld de, debug_mark 
51a6 3e 11			ld a, display_row_1+17 
51a8			 
51a8 cd e8 0a				call str_at_display 
51ab			 
51ab				; display current data stack pointer 
51ab 11 f1 50			ld de,.data_sp 
51ae 3e 1c				ld a, display_row_2 + 8 
51b0 cd e8 0a				call str_at_display 
51b3			 
51b3 2a 90 f9			ld hl,(cli_data_sp) 
51b6 e5				push hl 
51b7 7c				ld a,h 
51b8 21 a8 f2			ld hl, os_word_scratch 
51bb cd 0a 10			call hexout 
51be e1				pop hl 
51bf 7d				ld a,l 
51c0 21 aa f2			ld hl, os_word_scratch+2 
51c3 cd 0a 10			call hexout 
51c6 21 ac f2			ld hl, os_word_scratch+4 
51c9 3e 00			ld a,0 
51cb 77				ld (hl),a 
51cc 11 a8 f2			ld de,os_word_scratch 
51cf 3e 1f				ld a, display_row_2 + 11 
51d1 cd e8 0a				call str_at_display 
51d4			 
51d4			 
51d4 cd f8 0a			call update_display 
51d7 cd 55 0a			call delay1s 
51da cd 55 0a			call delay1s 
51dd e1				pop hl 
51de			.skipdsp: 
51de f1				pop af 
51df c9				ret 
51e0			 
51e0			display_data_malloc: 
51e0			 
51e0 f5				push af 
51e1 e5				push hl 
51e2 e5				push hl 
51e3 e5			push hl 
51e4 cd d5 0a			call clear_display 
51e7 e1			pop hl 
51e8 7c				ld a,h 
51e9 21 a8 f2			ld hl, os_word_scratch 
51ec cd 0a 10			call hexout 
51ef e1				pop hl 
51f0 7d				ld a,l 
51f1 21 aa f2			ld hl, os_word_scratch+2 
51f4 cd 0a 10			call hexout 
51f7 21 ac f2			ld hl, os_word_scratch+4 
51fa 3e 00			ld a,0 
51fc 77				ld (hl),a 
51fd 11 a8 f2			ld de,os_word_scratch 
5200 3e 14				ld a, display_row_2 
5202 cd e8 0a				call str_at_display 
5205 11 2b 51			ld de, .push_malloc 
5208 3e 00			ld a, display_row_1 
520a			 
520a cd e8 0a				call str_at_display 
520d			 
520d				; display current data stack pointer 
520d 11 f1 50			ld de,.data_sp 
5210 3e 1c				ld a, display_row_2 + 8 
5212 cd e8 0a				call str_at_display 
5215			 
5215 2a 90 f9			ld hl,(cli_data_sp) 
5218 e5				push hl 
5219 7c				ld a,h 
521a 21 a8 f2			ld hl, os_word_scratch 
521d cd 0a 10			call hexout 
5220 e1				pop hl 
5221 7d				ld a,l 
5222 21 aa f2			ld hl, os_word_scratch+2 
5225 cd 0a 10			call hexout 
5228 21 ac f2			ld hl, os_word_scratch+4 
522b 3e 00			ld a,0 
522d 77				ld (hl),a 
522e 11 a8 f2			ld de,os_word_scratch 
5231 3e 1f				ld a, display_row_2 + 11 
5233 cd e8 0a				call str_at_display 
5236			 
5236 cd f8 0a			call update_display 
5239 cd 55 0a			call delay1s 
523c cd 55 0a			call delay1s 
523f e1				pop hl 
5240 f1				pop af 
5241 c9				ret 
5242			;endif 
5242			 
5242			include "forth_autostart.asm" 
5242			; list of commands to perform at system start up 
5242			 
5242			startcmds: 
5242			;	dw test11 
5242			;	dw test12 
5242			;	dw test13 
5242			;	dw test14 
5242			;	dw test15 
5242			;	dw test16 
5242			;	dw test17 
5242			;	dw ifthtest1 
5242			;	dw ifthtest2 
5242			;	dw ifthtest3 
5242			;	dw mmtest1 
5242			;	dw mmtest2 
5242			;	dw mmtest3 
5242			;	dw mmtest4 
5242			;	dw mmtest5 
5242			;	dw mmtest6 
5242			;	dw iftest1 
5242			;	dw iftest2 
5242			;	dw iftest3 
5242			;	dw looptest1 
5242			;	dw looptest2 
5242			;	dw test1 
5242			;	dw test2 
5242			;	dw test3 
5242			;	dw test4 
5242			;	dw game2r 
5242			;	dw game2b1 
5242			;	dw game2b2 
5242			 
5242				; start up words that are actually useful 
5242			 
5242 a0 52			dw clrstack 
5244 d3 52			dw type 
5246 94 54			dw stest 
5248 f7 52			dw strncpy 
524a 35 54			dw list 
524c 58 53			dw start1 
524e 6a 53			dw start2 
5250			;	dw start3 
5250 7d 53			dw start3b 
5252 d5 53			dw start3c 
5254			 
5254				; (unit) testing words 
5254			 
5254 0b 55			dw mtesta 
5256 c0 55			dw mtestb 
5258 63 56			dw mtestc 
525a 18 57			dw mtestd 
525c bc 57			dw mteste 
525e			 
525e				; demo/game words 
525e			 
525e c8 5e		        dw game3w 
5260 f6 5e		        dw game3p 
5262 14 5f		        dw game3sc 
5264 45 5f		        dw game3vsi 
5266 71 5f		        dw game3vs 
5268				 
5268 bb 5c			dw game2b 
526a 29 5d			dw game2bf 
526c 73 5d			dw game2mba 
526e 09 5e			dw game2mbas 
5270 4b 5e			dw game2mb 
5272			 
5272 7c 59			dw game1 
5274 8d 59			dw game1a 
5276 ef 59			dw game1b 
5278 24 5a			dw game1c 
527a 5a 5a			dw game1d 
527c 8b 5a			dw game1s 
527e 9f 5a			dw game1t 
5280 b4 5a			dw game1f 
5282 e8 5a			dw game1z 
5284 2c 5b			dw game1zz 
5286			 
5286 72 58			dw test5 
5288 aa 58			dw test6 
528a e2 58			dw test7 
528c f6 58			dw test8 
528e 22 59			dw test9 
5290 38 59			dw test10 
5292				 
5292 03 5c		        dw ssv5 
5294 e7 5b		        dw ssv4 
5296 cb 5b		        dw ssv3 
5298 95 5b		        dw ssv2 
529a 1c 5c		        dw ssv1 
529c 64 5c		        dw ssv1cpm 
529e			;	dw keyup 
529e			;	dw keydown 
529e			;	dw keyleft 
529e			;	dw keyright 
529e			;	dw 	keyf1 
529e			;	dw keyf2 
529e			;	dw keyf3 
529e			;	dw keyf4 
529e			;	dw keyf5 
529e			;	dw keyf6 
529e			;	dw keyf7 
529e			;	dw keyf8 
529e			;	dw keyf9 
529e			;	dw keyf10 
529e			;	dw keyf11 
529e			;	dw keyf12 
529e			;	dw keytab 
529e			;	dw keycr 
529e			;	dw keyhome 
529e			;	dw keyend 
529e			;	dw keybs 
529e 00 00			db 0, 0	 
52a0			 
52a0			 
52a0			; clear stack  
52a0			 
52a0 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
52d3			 
52d3			; type ( addr count - ) 
52d3 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
52f7			 
52f7			; some direct memory words 
52f7			; strncpy ( len t f -- t ) 
52f7			 
52f7 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5358			 
5358 .. 00		start1:     	db ": bpon $0000 bp ;",0 
536a .. 00		start2:     	db ": bpoff $0001 bp ;",0 
537d			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
537d .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
53d5 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5435			 
5435			 
5435			; a handy word to list items on the stack 
5435			 
5435 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5494			 
5494			 
5494			; test stack  
5494			; rnd8 stest 
5494			 
5494 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
550b			 
550b			; random malloc and free cycles 
550b			 
550b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55c0			 
55c0			; fixed malloc and free cycles 
55c0			 
55c0 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5663			 
5663			; fixed double string push and drop cycle  
5663			 
5663 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5718			 
5718			; consistent fixed string push and drop cycle  
5718			 
5718 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57bc			 
57bc .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5872			 
5872			;test1:		db ": aa 1 2 3 ;", 0 
5872			;test2:     	db "111 aa 888 999",0 
5872			;test3:     	db ": bb 77 ;",0 
5872			;test4:     	db "$02 $01 do i . loop bb",0 
5872			 
5872 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
58aa .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58e2 .. 00		test7:     	db ": box hline vline ;",0 
58f6 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5922 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5938 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
595d .. 00		test11:     	db "hello create .",0 
596c .. 00		test12:     	db "hello2 create .",0 
597c			 
597c			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
597c			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
597c			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
597c			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
597c			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
597c			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
597c			 
597c			;iftest1:     	db "$0001 IF cls .",0 
597c			;iftest2:     	db "$0000 IF cls .",0 
597c			;iftest3:     	db "$0002 $0003 - IF cls .",0 
597c			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
597c			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
597c			 
597c			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
597c			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
597c			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
597c			 
597c			 
597c			 
597c			; a small guess the number game 
597c			 
597c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
598d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
59ef			 
59ef .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a24 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5a5a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5a8b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5a9f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5ab4 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ae8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b2c			 
5b2c			; Using 'ga' save a high score across multiple runs using external storage 
5b2c			 
5b2c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5b95			 
5b95			 
5b95			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5b95			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b95			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5b95			 
5b95			; simple screen saver to test code memory reuse to destruction 
5b95			 
5b95 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5bcb .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5be7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c03 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c1c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5c64 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5cbb			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cbb			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5cbb			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5cbb			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5cbb			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5cbb			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5cbb			 
5cbb			 
5cbb			 
5cbb			; minesweeper/battleship finding game 
5cbb			; draws a game board of random ship/mine positions 
5cbb			; user enters coords to see if it hits on 
5cbb			; game ends when all are hit 
5cbb			; when hit or miss says how many may be in the area 
5cbb			 
5cbb			; setup the game board and then hide it 
5cbb .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d29 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5d73			; prompt for where to target 
5d73 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e09 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e2e			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e2e .. 00		game2mbht:      db ": mbckht nop ;",0 
5e3d .. 00		game2mbms:      db ": mbcms nop ;",0 
5e4b			; TODO how many might be near by 
5e4b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ec8			 
5ec8			; Game 3 
5ec8			 
5ec8			; Vert scroller ski game - avoid the trees! 
5ec8			 
5ec8			; v0 score (ie turns) 
5ec8			; v1 player pos 
5ec8			; v2 left wall 
5ec8			; v3 right wall 
5ec8			 
5ec8			; Draw side walls randomly 
5ec8			 
5ec8 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5ef6			 
5ef6			; Draw player 
5ef6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f14			 
5f14			; TODO Get Key 
5f14			 
5f14			; TODO Move left right 
5f14			 
5f14			; scroll and move walls a bit 
5f14			 
5f14 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5f45			 
5f45			; main game loop 
5f45			 
5f45 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5f71 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5fb0			 
5fb0			; key board defs 
5fb0			 
5fb0 .. 00		keyup:       db ": keyup $05 ;",0 
5fbe .. 00		keydown:       db ": keydown $0a ;",0 
5fce .. 00		keyleft:       db ": keyleft $0b ;",0 
5fde .. 00		keyright:       db ": keyright $0c ;",0 
5fef .. 00		keyf1:       db ": keyf1 $10 ;",0 
5ffd .. 00		keyf2:       db ": keyf2 $11 ;",0 
600b .. 00		keyf3:       db ": keyf3 $12 ;",0 
6019 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6027 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6035 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6043 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6051 .. 00		keyf8:       db ": keyf8 $17 ;",0 
605f .. 00		keyf9:       db ": keyf9 $18 ;",0 
606d .. 00		keyf10:       db ": keyf10 $19 ;",0 
607c .. 00		keyf11:       db ": keyf11 $1a ;",0 
608b .. 00		keyf12:       db ": keyf12 $1b ;",0 
609a			 
609a .. 00		keytab:       db ": keytab $09 ;",0 
60a9 .. 00		keycr:       db ": keycr $0d ;",0 
60b7 .. 00		keyhome:       db ": keyhome $0e ;",0 
60c7 .. 00		keyend:       db ": keyend $0f ;",0 
60d6 .. 00		keybs:       db ": keybs $08 ;",0 
60e4			 
60e4			   
60e4			 
60e4			 
60e4			 
60e4			; eof 
# End of file forth_autostart.asm
60e4			 
60e4 .. 00		sprompt1: db "Startup load...",0 
60f4 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
610a			 
610a			 
610a			 
610a			 
610a			forth_startup: 
610a 21 42 52			ld hl, startcmds 
610d 3e 00			ld a, 0 
610f 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6112			 
6112 e5			.start1:	push hl 
6113 cd d5 0a			call clear_display 
6116 11 e4 60			ld de, sprompt1 
6119 3e 00		        ld a, display_row_1 
611b cd e8 0a			call str_at_display 
611e 11 f4 60			ld de, sprompt2 
6121 3e 14		        ld a, display_row_2 
6123 cd e8 0a			call str_at_display 
6126 e1				pop hl 
6127 e5				push hl 
6128 5e				ld e,(hl) 
6129 23				inc hl 
612a 56				ld d,(hl) 
612b 3e 28		        ld a, display_row_3 
612d cd e8 0a			call str_at_display 
6130 cd f8 0a			call update_display 
6133			 
6133			 
6133 3a c9 f3			ld a, (os_last_cmd) 
6136 fe 00			cp 0 
6138 28 05			jr z, .startprompt 
613a cd 49 0a			call delay250ms 
613d 18 24			jr .startdo 
613f				 
613f				 
613f			 
613f			.startprompt: 
613f			 
613f 3e 4f			ld a,display_row_4 + display_cols - 1 
6141 11 22 1c		        ld de, endprg 
6144 cd e8 0a			call str_at_display 
6147 cd f8 0a			call update_display 
614a cd 55 0a			call delay1s 
614d cd b9 66			call cin_wait 
6150						 
6150 fe 2a			cp '*' 
6152 28 5e			jr z, .startupend1 
6154 fe 23			cp '#' 
6156 20 07			jr nz, .startno 
6158 3e 01			ld a, 1 
615a 32 c9 f3			ld (os_last_cmd),a 
615d 18 04			jr .startdo 
615f fe 31		.startno:	cp '1' 
6161 28 3a			jr z,.startnxt  
6163			 
6163				; exec startup line 
6163			.startdo:	 
6163 e1				pop hl 
6164 e5				push hl 
6165				 
6165 5e				ld e,(hl) 
6166 23				inc hl 
6167 56				ld d,(hl) 
6168 eb				ex de,hl 
6169			 
6169 e5				push hl 
616a			 
616a 3e 00			ld a, 0 
616c				;ld a, FORTH_END_BUFFER 
616c cd 72 11			call strlent 
616f 23				inc hl   ; include zero term to copy 
6170 06 00			ld b,0 
6172 4d				ld c,l 
6173 e1				pop hl 
6174 11 a3 ef			ld de, scratch 
6177 ed b0			ldir 
6179			 
6179			 
6179 21 a3 ef			ld hl, scratch 
617c cd 63 20			call forthparse 
617f cd a3 20			call forthexec 
6182 cd ba 1f			call forthexec_cleanup 
6185			 
6185 3e 3c			ld a, display_row_4 
6187 11 c6 19			ld de, endprog 
618a			 
618a cd f8 0a			call update_display		 
618d			 
618d 3a c9 f3			ld a, (os_last_cmd) 
6190 fe 00			cp 0 
6192 20 09			jr nz, .startnxt 
6194 cd 24 1c			call next_page_prompt 
6197 cd d5 0a		        call clear_display 
619a cd f8 0a			call update_display		 
619d			 
619d				; move onto next startup line? 
619d			.startnxt: 
619d			 
619d cd 49 0a			call delay250ms 
61a0 e1				pop hl 
61a1			 
61a1 23				inc hl 
61a2 23				inc hl 
61a3			 
61a3 e5				push hl 
61a4 5e				ld e, (hl) 
61a5 23				inc hl 
61a6 56				ld d, (hl) 
61a7 e1				pop hl 
61a8				; TODO replace 0 test 
61a8			 
61a8 eb				ex de, hl 
61a9 cd 32 0d			call ishlzero 
61ac			;	ld a,e 
61ac			;	add d 
61ac			;	cp 0    ; any left to do? 
61ac eb				ex de, hl 
61ad c2 12 61			jp nz, .start1 
61b0 18 01			jr .startupend 
61b2			 
61b2 e1			.startupend1: pop hl 
61b3			.startupend: 
61b3			 
61b3 cd d5 0a			call clear_display 
61b6 cd f8 0a			call update_display 
61b9 c9				ret 
61ba			 
61ba			 
61ba			; stack over and underflow checks 
61ba			 
61ba			; init the words to detect the under/overflow 
61ba			 
61ba			chk_stk_init: 
61ba				; a vague random number to check so we dont get any "lucky" hits 
61ba 3e 2d			ld a, 45 
61bc 6f				ld l, a 
61bd 00				nop 
61be 3e 17			ld a, 23 
61c0 67				ld h, a 
61c1			 
61c1 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
61c4			 
61c4			;	ld (chk_stund), hl	; stack points.... 
61c4 22 fd fb			ld (chk_stovr), hl 
61c7 22 8e f9			ld (chk_ret_und), hl 
61ca 22 0c f9			ld (chk_ret_ovr), hl 
61cd 22 0a f7			ld (chk_loop_ovr), hl 
61d0 22 08 f5			ld (chk_data_ovr), hl 
61d3 c9				ret 
61d4				 
61d4			check_stacks: 
61d4				; check all stack words 
61d4			 
61d4 e5				push hl 
61d5 d5				push de 
61d6			 
61d6			;	ld de,(chk_word) 
61d6			;	ld hl, (chk_stund)	; stack points.... 
61d6			;	if DEBUG_STK_FAULT 
61d6			;		DMARK "FAa" 
61d6			;		CALLMONITOR 
61d6			;	endif 
61d6			;	call cmp16 
61d6			;	jp z, .chk_faulta 
61d6			; 
61d6			;	ld de, sfaultsu 
61d6			;	jp .chk_fault 
61d6			 
61d6 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
61d9 ed 5b 8a ef		ld de,(chk_word) 
61dd				if DEBUG_STK_FAULT 
61dd					DMARK "FAb" 
61dd					CALLMONITOR 
61dd				endif 
61dd cd 27 0d			call cmp16 
61e0 28 06			jr z, .chk_fault1 
61e2 11 83 62			ld de, sfaultso 
61e5 c3 37 62			jp .chk_fault 
61e8			.chk_fault1:  
61e8 2a 8e f9			ld hl, (chk_ret_und) 
61eb ed 5b 8a ef		ld de,(chk_word) 
61ef				if DEBUG_STK_FAULT 
61ef					DMARK "FAU" 
61ef					CALLMONITOR 
61ef				endif 
61ef cd 27 0d			call cmp16 
61f2 ca fb 61			jp z, .chk_fault2 
61f5 11 93 62			ld de, sfaultru 
61f8 c3 37 62			jp .chk_fault 
61fb			.chk_fault2:  
61fb 2a 0c f9			ld hl, (chk_ret_ovr) 
61fe ed 5b 8a ef		ld de,(chk_word) 
6202				if DEBUG_STK_FAULT 
6202					DMARK "FA1" 
6202					CALLMONITOR 
6202				endif 
6202 cd 27 0d			call cmp16 
6205 ca 0e 62			jp z, .chk_fault3 
6208 11 a1 62			ld de, sfaultro 
620b c3 37 62			jp .chk_fault 
620e			.chk_fault3:  
620e 2a 0a f7			ld hl, (chk_loop_ovr) 
6211 ed 5b 8a ef		ld de,(chk_word) 
6215				if DEBUG_STK_FAULT 
6215					DMARK "FA2" 
6215					CALLMONITOR 
6215				endif 
6215 cd 27 0d			call cmp16 
6218 ca 21 62			jp z, .chk_fault4 
621b 11 bb 62			ld de, sfaultlo 
621e c3 37 62			jp .chk_fault 
6221			.chk_fault4:  
6221 2a 08 f5			ld hl, (chk_data_ovr) 
6224 ed 5b 8a ef		ld de,(chk_word) 
6228				if DEBUG_STK_FAULT 
6228					DMARK "FA3" 
6228					CALLMONITOR 
6228				endif 
6228 cd 27 0d			call cmp16 
622b ca 34 62			jp z, .chk_fault5 
622e 11 d5 62			ld de, sfaultdo 
6231 c3 37 62			jp .chk_fault 
6234			 
6234			 
6234			.chk_fault5:  
6234 d1				pop de 
6235 e1				pop hl 
6236			 
6236 c9				ret 
6237			 
6237 cd d5 0a		.chk_fault: 	call clear_display 
623a 3e 14				ld a, display_row_2 
623c cd e8 0a				call str_at_display 
623f 11 65 62				   ld de, .stackfault 
6242 3e 00				ld a, display_row_1 
6244 cd e8 0a				call str_at_display 
6247 11 bd fb				    ld de, debug_mark 
624a 3e 11				ld a, display_row_1+17 
624c cd e8 0a				call str_at_display 
624f cd f8 0a				call update_display 
6252			 
6252				; prompt before entering montior for investigating issue 
6252			 
6252 3e 3c			ld a, display_row_4 
6254 11 c6 19			ld de, endprog 
6257			 
6257 cd f8 0a			call update_display		 
625a			 
625a cd 24 1c			call next_page_prompt 
625d			 
625d d1				pop de 
625e e1				pop hl 
625f cd 1a 1a				call monitor 
6262 c3 11 19				jp warmstart 
6265					;jp 0 
6265					;halt 
6265			 
6265			 
6265			 
6265 .. 00		.stackfault: 	db "Stack fault:",0 
6272			 
6272 .. 00		sfaultsu: 	db	"Stack under flow",0 
6283 .. 00		sfaultso: 	db	"Stack over flow",0 
6293 .. 00		sfaultru:	db "RTS underflow",0 
62a1 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
62bb .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62d5 .. 00		sfaultdo:	db "DTS overflow", 0 
62e2			 
62e2			 
62e2			fault_dsp_under: 
62e2 11 f4 62			ld de, .dsp_under 
62e5 c3 a4 63			jp .show_fault 
62e8			 
62e8			fault_rsp_under: 
62e8 11 02 63			ld de, .rsp_under 
62eb c3 a4 63			jp .show_fault 
62ee			fault_loop_under: 
62ee 11 10 63			ld de, .loop_under 
62f1 c3 a4 63			jp .show_fault 
62f4			 
62f4 .. 00		.dsp_under: db "DSP Underflow",0 
6302 .. 00		.rsp_under: db "RSP Underflow",0 
6310 .. 00		.loop_under: db "LOOP Underflow",0 
631f			 
631f			 
631f d5			type_faultn: 	push de 
6320 e5					push hl 
6321 cd d5 0a				call clear_display 
6324 11 4b 63				   ld de, .typefaultn 
6327 3e 00				ld a, display_row_1 
6329 cd e8 0a				call str_at_display 
632c 11 bd fb				    ld de, debug_mark 
632f 3e 11				ld a, display_row_1+17 
6331 cd e8 0a				call str_at_display 
6334 cd f8 0a				call update_display 
6337			 
6337				; prompt before entering montior for investigating issue 
6337			 
6337 3e 3c			ld a, display_row_4 
6339 11 c6 19			ld de, endprog 
633c			 
633c cd f8 0a			call update_display		 
633f			 
633f cd 24 1c			call next_page_prompt 
6342			 
6342 e5					push hl 
6343 d5					push de 
6344 cd 1a 1a				call monitor 
6347 c3 11 19				jp warmstart 
634a 76					halt 
634b			 
634b			 
634b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6362			 
6362 d5			type_faults: 	push de 
6363 e5					push hl 
6364 cd d5 0a				call clear_display 
6367 11 8d 63				   ld de, .typefaults 
636a 3e 00				ld a, display_row_1 
636c cd e8 0a				call str_at_display 
636f 11 bd fb				    ld de, debug_mark 
6372 3e 11				ld a, display_row_1+17 
6374 cd e8 0a				call str_at_display 
6377 cd f8 0a				call update_display 
637a			 
637a				; prompt before entering montior for investigating issue 
637a			 
637a 3e 3c			ld a, display_row_4 
637c 11 c6 19			ld de, endprog 
637f			 
637f cd f8 0a			call update_display		 
6382			 
6382 cd 24 1c			call next_page_prompt 
6385			 
6385 e1					pop hl 
6386 d1					pop de 
6387 cd 1a 1a				call monitor 
638a c3 11 19				jp warmstart 
638d			 
638d			 
638d .. 00		.typefaults: db "STR Type Expected TOS!",0 
63a4			 
63a4			.show_fault: 	 
63a4 d5					push de 
63a5 cd d5 0a				call clear_display 
63a8 d1					pop de 
63a9 3e 00				ld a, display_row_1 
63ab cd e8 0a				call str_at_display 
63ae 11 bd fb				    ld de, debug_mark 
63b1 3e 11				ld a, display_row_1+17 
63b3 cd e8 0a				call str_at_display 
63b6 cd f8 0a				call update_display 
63b9			 
63b9				; prompt before entering montior for investigating issue 
63b9			 
63b9 3e 3c			ld a, display_row_4 
63bb 11 c6 19			ld de, endprog 
63be			 
63be cd f8 0a			call update_display		 
63c1			 
63c1 cd 24 1c			call next_page_prompt 
63c4			 
63c4 e1					pop hl 
63c5 d1					pop de 
63c6 cd 1a 1a				call monitor 
63c9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63c9			; TODO Make optional fault restart to cli or warm boot? 
63c9					;jp warmstart 
63c9 c3 6c 19				jp cli 
63cc 76					halt 
63cd			 
63cd			; handle the auto run of code from files in storage 
63cd			 
63cd			 
63cd			if STORAGE_SE 
63cd			 
63cd .. 00		sprompt3: db "Loading from start-up file?:",0 
63ea .. 00		sprompt4: db "(Y=Any key/N=No)",0 
63fb			 
63fb			 
63fb			forth_autoload: 
63fb			 
63fb				; load block 0 of store 1 
63fb				 
63fb 3e fe			ld a, $fe      ; bit 0 clear 
63fd 32 ce f9			ld (spi_device), a 
6400			 
6400 cd ba 03			call storage_get_block_0 
6403			 
6403 3a 09 fa			ld a, (store_page+STORE_0_AUTOFILE) 
6406			 
6406 fe 00			cp 0 
6408 c8				ret z     ; auto start not enabled 
6409			 
6409 cd d5 0a			call clear_display 
640c			 
640c				; set bank 
640c			 
640c 3a 0b fa				ld a, (store_page+STORE_0_BANKRUN) 
640f 32 ce f9				ld (spi_device), a 
6412			 
6412				; get file id to load from and get the file name to display 
6412			 
6412 3a 0c fa				ld a, (store_page+STORE_0_FILERUN) 
6415			 
6415 2e 00				ld l, 0 
6417 67					ld h, a 
6418 11 e8 f9				ld de, store_page 
641b			 
641b					if DEBUG_FORTH_WORDS 
641b						DMARK "ASp" 
641b f5				push af  
641c 3a 30 64			ld a, (.dmark)  
641f 32 bd fb			ld (debug_mark),a  
6422 3a 31 64			ld a, (.dmark+1)  
6425 32 be fb			ld (debug_mark+1),a  
6428 3a 32 64			ld a, (.dmark+2)  
642b 32 bf fb			ld (debug_mark+2),a  
642e 18 03			jr .pastdmark  
6430 ..			.dmark: db "ASp"  
6433 f1			.pastdmark: pop af  
6434			endm  
# End of macro DMARK
6434						CALLMONITOR 
6434 cd 1c 17			call break_point_state  
6437				endm  
# End of macro CALLMONITOR
6437					endif 
6437 cd 50 08				call storage_read 
643a			 
643a					if DEBUG_FORTH_WORDS 
643a						DMARK "ASr" 
643a f5				push af  
643b 3a 4f 64			ld a, (.dmark)  
643e 32 bd fb			ld (debug_mark),a  
6441 3a 50 64			ld a, (.dmark+1)  
6444 32 be fb			ld (debug_mark+1),a  
6447 3a 51 64			ld a, (.dmark+2)  
644a 32 bf fb			ld (debug_mark+2),a  
644d 18 03			jr .pastdmark  
644f ..			.dmark: db "ASr"  
6452 f1			.pastdmark: pop af  
6453			endm  
# End of macro DMARK
6453						CALLMONITOR 
6453 cd 1c 17			call break_point_state  
6456				endm  
# End of macro CALLMONITOR
6456					endif 
6456			 
6456 cd 32 0d				call ishlzero 
6459 c8					ret z             ; file not found 
645a			 
645a 3e 1e				ld a, display_row_2 + 10 
645c 11 eb f9				ld de, store_page+3 
645f cd e8 0a				call str_at_display 
6462				 
6462			; 
6462			 
6462 3e 05			ld a, display_row_1+5 
6464 11 cd 63			ld de, sprompt3 
6467 cd e8 0a			call str_at_display 
646a 3e 37			ld a, display_row_3+15 
646c 11 ea 63			ld de, sprompt4 
646f cd e8 0a			call str_at_display 
6472			 
6472 cd f8 0a			call update_display 
6475			 
6475 cd b9 66			call cin_wait 
6478 fe 6e			cp 'n' 
647a c8				ret z 
647b fe 4e			cp 'N' 
647d c8				ret z 
647e			 
647e cd 55 0a			call delay1s 
6481			 
6481 3a ea f9			ld a, (store_page+2) 
6484 32 de f9			ld (store_openmaxext), a    ; save count of ext 
6487 3e 01			ld a, 1  
6489 32 df f9			ld (store_openext), a    ; save count of ext 
648c			 
648c			.autof:  
648c 6f				ld l , a 
648d				 
648d 3a e8 f9			ld a, (store_page) 
6490 67				ld h, a	 
6491 11 e8 f9			ld de, store_page 
6494					if DEBUG_FORTH_WORDS 
6494						DMARK "ASl" 
6494 f5				push af  
6495 3a a9 64			ld a, (.dmark)  
6498 32 bd fb			ld (debug_mark),a  
649b 3a aa 64			ld a, (.dmark+1)  
649e 32 be fb			ld (debug_mark+1),a  
64a1 3a ab 64			ld a, (.dmark+2)  
64a4 32 bf fb			ld (debug_mark+2),a  
64a7 18 03			jr .pastdmark  
64a9 ..			.dmark: db "ASl"  
64ac f1			.pastdmark: pop af  
64ad			endm  
# End of macro DMARK
64ad						CALLMONITOR 
64ad cd 1c 17			call break_point_state  
64b0				endm  
# End of macro CALLMONITOR
64b0					endif 
64b0 cd 50 08				call storage_read 
64b3 cd 32 0d			call ishlzero 
64b6 c8				ret z 
64b7			;	jr z, .autoend 
64b7			 
64b7					if DEBUG_FORTH_WORDS 
64b7						DMARK "ASc" 
64b7 f5				push af  
64b8 3a cc 64			ld a, (.dmark)  
64bb 32 bd fb			ld (debug_mark),a  
64be 3a cd 64			ld a, (.dmark+1)  
64c1 32 be fb			ld (debug_mark+1),a  
64c4 3a ce 64			ld a, (.dmark+2)  
64c7 32 bf fb			ld (debug_mark+2),a  
64ca 18 03			jr .pastdmark  
64cc ..			.dmark: db "ASc"  
64cf f1			.pastdmark: pop af  
64d0			endm  
# End of macro DMARK
64d0						CALLMONITOR 
64d0 cd 1c 17			call break_point_state  
64d3				endm  
# End of macro CALLMONITOR
64d3					endif 
64d3 11 ea f9			ld de, store_page+2 
64d6 3e 3c			ld a, display_row_4 
64d8 cd e8 0a			call str_at_display 
64db			 
64db cd f8 0a			call update_display 
64de cd 49 0a			call delay250ms 
64e1			 
64e1			 
64e1			 
64e1 21 ea f9			ld hl, store_page+2 
64e4 cd 63 20			call forthparse 
64e7 cd a3 20			call forthexec 
64ea cd ba 1f			call forthexec_cleanup 
64ed			 
64ed				 
64ed 3a df f9			ld a, (store_openext) 
64f0 3c				inc a 
64f1 32 df f9			ld (store_openext), a    ; save count of ext 
64f4			 
64f4 18 96			jr .autof 
64f6			;.autofdone: 
64f6			; 
64f6			;		if DEBUG_FORTH_WORDS 
64f6			;			DMARK "ASx" 
64f6			;			CALLMONITOR 
64f6			;		endif 
64f6			;;	call clear_display 
64f6			;	ret 
64f6			 
64f6			 
64f6			 
64f6			endif 
64f6			 
64f6			 
64f6			; eof 
# End of file forth_kernel.asm
64f6			;include "nascombasic.asm" 
64f6			 
64f6			 
64f6			; find out where the code ends if loaded into RAM (for SC114) 
64f6			;endofcode:  
64f6			;	nop 
64f6			 
64f6			 
64f6			; eof 
64f6			 
# End of file main.asm
64f6			include "firmware_lcd_4x20.asm" 
64f6			; **********************************************************************  
64f6			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
64f6			; **********************************************************************  
64f6			;  
64f6			; **  Written as a Small Computer Monitor App  
64f6			; **  www.scc.me.uk  
64f6			;  
64f6			; History  
64f6			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
64f6			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
64f6			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
64f6			;  
64f6			; **********************************************************************  
64f6			;  
64f6			; This program is an example of one of the methods of interfacing an   
64f6			; alphanumeric LCD module.   
64f6			;  
64f6			; In this example the display is connected to either a Z80 PIO or a   
64f6			; simple 8-bit output port.   
64f6			;  
64f6			; This interfacing method uses 4-bit data mode and uses time delays  
64f6			; rather than polling the display's ready status. As a result the   
64f6			; interface only requires 6 simple output lines:  
64f6			;   Output bit 0 = not used  
64f6			;   Output bit 1 = not used  
64f6			;   Output bit 2 = RS         High = data, Low = instruction  
64f6			;   Output bit 3 = E          Active high  
64f6			;   Output bit 4 = DB4  
64f6			;   Output bit 5 = DB5  
64f6			;   Output bit 6 = DB6  
64f6			;   Output bit 7 = DB7  
64f6			; Display's R/W is connected to 0v so it is always in write mode  
64f6			;  
64f6			; This set up should work with any system supporting the RC2014 bus  
64f6			  
64f6			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
64f6			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
64f6			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
64f6			;  
64f6			; **********************************************************************  
64f6			  
64f6			; **********************************************************************  
64f6			; **  Constants  
64f6			; **********************************************************************  
64f6			; LCD constants required by LCD support module  
64f6			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
64f6			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
64f6			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
64f6			kLCDWidth:  EQU display_cols             ;Width in characters  
64f6			  
64f6			; **********************************************************************  
64f6			; **  Code library usage  
64f6			; **********************************************************************  
64f6			  
64f6			; send character to current cursor position  
64f6			; wraps and/or scrolls screen automatically  
64f6			  
64f6			  
64f6			lcd_init:  
64f6			  
64f6			; SCMonAPI functions used  
64f6			  
64f6			; Alphanumeric LCD functions used  
64f6			; no need to specify specific functions for this module  
64f6			  
64f6 3e cf		            LD   A, 11001111b  
64f8 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
64fa 3e 00		            LD   A, 00000000b  
64fc d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
64fe			  
64fe			; Initialise alphanumeric LCD module  
64fe cd 77 65		            CALL fLCD_Init      ;Initialise LCD module  
6501			  
6501 c9				ret  
6502			  
6502			;  
6502			;;  
6502			; lcd functions  
6502			;  
6502			;  
6502			  
6502			; what is at cursor position   
6502			  
6502			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6502			;		call curptr  
6502			;		ret  
6502			  
6502			  
6502			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6502			  
6502			curptr:  
6502 c5				push bc  
6503 21 53 fb			ld hl, display_fb0  
6506			cpr:	  
6506				; loop for cursor whole row  
6506 0e 14			ld c, display_cols  
6508 23			cpr1:	inc hl  
6509 0d				dec c  
650a 20 fc			jr nz, cpr1  
650c 05				dec b  
650d 20 f7			jr nz, cpr  
650f			  
650f				; add col	  
650f			  
650f 23			cpr2:	inc hl  
6510 1d				dec e  
6511 20 fc			jr nz, cpr2  
6513			  
6513 c1				pop bc  
6514 c9				ret  
6515				  
6515			  
6515			  
6515			  
6515			  
6515			; write the frame buffer given in hl to hardware   
6515 22 5b fa		write_display: ld (display_write_tmp), hl 	   
6518 3e 00			ld a, kLCD_Line1  
651a cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
651d 06 14			ld b, display_cols  
651f ed 5b 5b fa		ld de, (display_write_tmp)  
6523 cd 6f 65			call write_len_string  
6526				  
6526				  
6526 2a 5b fa			ld hl, (display_write_tmp)  
6529 11 14 00			ld de, display_cols  
652c 19				add hl,de  
652d 22 5b fa			ld (display_write_tmp),hl  
6530			  
6530				  
6530 3e 40			ld a, kLCD_Line2  
6532 cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6535 06 14			ld b, display_cols  
6537 ed 5b 5b fa		ld de, (display_write_tmp)  
653b cd 6f 65			call write_len_string  
653e				  
653e 2a 5b fa			ld hl, (display_write_tmp)  
6541 11 14 00			ld de, display_cols  
6544 19				add hl,de  
6545 22 5b fa			ld (display_write_tmp),hl  
6548			  
6548				  
6548 3e 14			ld a, kLCD_Line3  
654a cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
654d 06 14			ld b, display_cols  
654f ed 5b 5b fa		ld de, (display_write_tmp)  
6553 cd 6f 65			call write_len_string  
6556				  
6556 2a 5b fa			ld hl, (display_write_tmp)  
6559 11 14 00			ld de, display_cols  
655c 19				add hl,de  
655d 22 5b fa			ld (display_write_tmp),hl  
6560			  
6560				  
6560 3e 54			ld a, kLCD_Line4  
6562 cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6565 06 14			ld b, display_cols  
6567 ed 5b 5b fa		ld de, (display_write_tmp)  
656b cd 6f 65			call write_len_string  
656e c9					ret  
656f				  
656f				; write out a fixed length string given in b from de  
656f			  
656f 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6570 cd c1 65		            CALL fLCD_Data      ;Write character to display  
6573 13				inc de  
6574 10 f9			djnz write_len_string  
6576 c9				ret  
6577			  
6577			; Some other things to do  
6577			;            LD   A, kLCD_Clear ;Display clear  
6577			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6577			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6577			;            LD   A, kLCD_On     ;Display on with no cursor  
6577			;            ;LD   A, kLCD_Off   ;Display off  
6577			;            CALL fLCD_Inst      ;Send instruction to display  
6577			;  
6577			;  
6577			;            halt  
6577			;  
6577			;  
6577			;MsgHello:   DB  "Hello World!",0  
6577			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6577			  
6577			; Custom characters 5 pixels wide by 8 pixels high  
6577			; Up to 8 custom characters can be defined  
6577			;BitMaps:      
6577			;; Character 0x00 = Battery icon  
6577			;            DB  01110b  
6577			;            DB  11011b  
6577			;            DB  10001b  
6577			;            DB  10001b  
6577			;            DB  11111b  
6577			;            DB  11111b  
6577			;            DB  11111b  
6577			;            DB  11111b  
6577			;; Character 0x01 = Bluetooth icon  
6577			;            DB  01100b  
6577			;            DB  01010b  
6577			;            DB  11100b  
6577			;            DB  01000b  
6577			;            DB  11100b  
6577			;            DB  01010b  
6577			;            DB  01100b  
6577			;            DB  00000b  
6577			;  
6577			  
6577			  
6577			; **********************************************************************  
6577			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6577			; **********************************************************************  
6577			;  
6577			; **  Written as a Small Computer Monitor App   
6577			; **  Version 0.1 SCC 2018-05-16  
6577			; **  www.scc.me.uk  
6577			;  
6577			; **********************************************************************  
6577			;  
6577			; This module provides support for alphanumeric LCD modules using with  
6577			; *  HD44780 (or compatible) controller  
6577			; *  5 x 7 pixel fonts  
6577			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6577			; *  Interface via six digital outputs to the display (see below)  
6577			;  
6577			; LCD module pinout:  
6577			;   1  Vss   0v supply  
6577			;   2  Vdd   5v supply  
6577			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6577			;   4  RS    High = data, Low = instruction  
6577			;   5  R/W   High = Read, Low = Write  
6577			;   6  E     Enable signal (active high)  
6577			;   7  DB0   Data bit 0  
6577			;   8  DB1   Data bit 1  
6577			;   9  DB2   Data bit 2  
6577			;  10  DB3   Data bit 3  
6577			;  11  DB4   Data bit 4  
6577			;  12  DB5   Data bit 5  
6577			;  13  DB6   Data bit 6  
6577			;  14  DB7   Data bit 7  
6577			;  15  A     Backlight anode (+)  
6577			;  16  K     Backlight cathode (-)  
6577			;  
6577			; This interfacing method uses 4-bit data mode and uses time delays  
6577			; rather than polling the display's ready status. As a result the   
6577			; interface only requires 6 simple output lines:  
6577			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6577			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6577			;   LCD DB4 = Microcomputer output port bit 4  
6577			;   LCD DB5 = Microcomputer output port bit 5  
6577			;   LCD DB6 = Microcomputer output port bit 6  
6577			;   LCD DB7 = Microcomputer output port bit 7  
6577			; Display's R/W is connected to 0v so it is always in write mode  
6577			; All 6 connections must be on the same port address <kLCDPrt>  
6577			; This method also allows a decent length of cable from micro to LCD  
6577			;  
6577			; **********************************************************************  
6577			;  
6577			; To include the code for any given function provided by this module,   
6577			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6577			; the parent source file.  
6577			; For example:  #REQUIRES   uHexPrefix  
6577			;  
6577			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6577			; in the parent source file.  
6577			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6577			;  
6577			; These are the function names provided by this module:  
6577			; fLCD_Init                     ;Initialise LCD  
6577			; fLCD_Inst                     ;Send instruction to LCD  
6577			; fLCD_Data                     ;Send data byte to LCD  
6577			; fLCD_Pos                      ;Position cursor  
6577			; fLCD_Str                      ;Display string  
6577			; fLCD_Def                      ;Define custom character  
6577			;  
6577			; **********************************************************************  
6577			;  
6577			; Requires SCMonAPI.asm to also be included in the project  
6577			;  
6577			  
6577			  
6577			; **********************************************************************  
6577			; **  Constants  
6577			; **********************************************************************  
6577			  
6577			; Constants that must be defined externally  
6577			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6577			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6577			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6577			;kLCDWidth: EQU 20             ;Width in characters  
6577			  
6577			; general line offsets in any frame buffer  
6577			  
6577			  
6577			display_row_1: equ 0  
6577			display_row_2: equ display_row_1+display_cols  
6577			display_row_3: equ display_row_2 + display_cols  
6577			display_row_4: equ display_row_3 + display_cols  
6577			;display_row_4_eol:   
6577			  
6577			  
6577			; Cursor position values for the start of each line  
6577			kLCD_Line1: EQU 0x00   
6577			kLCD_Line2: EQU 0x40    
6577			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6577			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6577			  
6577			; Instructions to send as A register to fLCD_Inst  
6577			kLCD_Clear: EQU 00000001b     ;LCD clear  
6577			kLCD_Off:   EQU 00001000b     ;LCD off  
6577			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6577			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6577			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6577			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6577			  
6577			; Constants used by this code module  
6577			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6577			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6577			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6577			  
6577			  
6577			  
6577			; **********************************************************************  
6577			; **  LCD support functions  
6577			; **********************************************************************  
6577			  
6577			; Initialise alphanumeric LCD module  
6577			; LCD control register codes:  
6577			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6577			;   N    0 = 1-line mode       1 = 2-line mode  
6577			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6577			;   D    0 = Display off       1 = Display on  
6577			;   C    0 = Cursor off        1 = Cursor on  
6577			;   B    0 = Blinking off      1 = Blinking on  
6577			;   ID   0 = Decrement mode    1 = Increment mode  
6577			;   SH   0 = Entire shift off  1 = Entire shift on  
6577 3e 28		fLCD_Init:  LD   A, 40  
6579 cd 2e 66		            CALL LCDDelay       ;Delay 40ms after power up  
657c			; For reliable reset set 8-bit mode - 3 times  
657c cd 18 66		            CALL WrFn8bit       ;Function = 8-bit mode  
657f cd 18 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6582 cd 18 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6585			; Set 4-bit mode  
6585 cd 14 66		            CALL WrFn4bit       ;Function = 4-bit mode  
6588 cd 2c 66		            CALL LCDDelay1      ;Delay 37 us or more  
658b			; Function set  
658b 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
658d cd a0 65		            CALL fLCD_Inst      ;2 line, display on  
6590			; Display On/Off control  
6590 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6592 cd a0 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6595			; Display Clear  
6595 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6597 cd a0 65		            CALL fLCD_Inst      ;Clear display  
659a			; Entry mode  
659a 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
659c cd a0 65		            CALL fLCD_Inst      ;Increment mode, shift off  
659f			; Display module now initialised  
659f c9			            RET  
65a0			; ok to here  
65a0			  
65a0			; Write instruction to LCD  
65a0			;   On entry: A = Instruction byte to be written  
65a0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65a0 f5			fLCD_Inst:  PUSH AF  
65a1 f5			            PUSH AF  
65a2 cd b4 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
65a5 f1			            POP  AF  
65a6 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65a7 17			            RLA  
65a8 17			            RLA  
65a9 17			            RLA  
65aa cd b4 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
65ad 3e 02		            LD   A, 2  
65af cd 2e 66		            CALL LCDDelay       ;Delay 2 ms to complete   
65b2 f1			            POP  AF  
65b3 c9			            RET  
65b4 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
65b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65b8 cb df		            SET  kLCDBitE, A  
65ba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65bc cb 9f		            RES  kLCDBitE, A  
65be d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65c0 c9			            RET  
65c1			  
65c1			  
65c1			; Write data to LCD  
65c1			;   On entry: A = Data byte to be written  
65c1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65c1 f5			fLCD_Data:  PUSH AF  
65c2 f5			            PUSH AF  
65c3 cd d5 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
65c6 f1			            POP  AF  
65c7 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
65c8 17			            RLA  
65c9 17			            RLA  
65ca 17			            RLA  
65cb cd d5 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
65ce 3e 96		            LD   A, 150  
65d0 3d			Wait:      DEC  A              ;Wait a while to allow data   
65d1 20 fd		            JR   NZ, Wait      ;  write to complete  
65d3 f1			            POP  AF  
65d4 c9			            RET  
65d5 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
65d7 cb d7		            SET  kLCDBitRS, A  
65d9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65db cb df		            SET  kLCDBitE, A  
65dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
65df cb 9f		            RES  kLCDBitE, A  
65e1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
65e3 cb 97		            RES  kLCDBitRS, A  
65e5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65e7 c9			            RET  
65e8			  
65e8			  
65e8			; Position cursor to specified location  
65e8			;   On entry: A = Cursor position  
65e8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65e8 f5			fLCD_Pos:   PUSH AF  
65e9 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
65eb cd a0 65		            CALL fLCD_Inst      ;Write instruction to LCD  
65ee f1			            POP  AF  
65ef c9			            RET  
65f0			  
65f0			  
65f0			; Output text string to LCD  
65f0			;   On entry: DE = Pointer to null terminated text string  
65f0			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
65f0 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
65f1 b7			            OR   A              ;Null terminator?  
65f2 c8			            RET  Z              ;Yes, so finished  
65f3 cd c1 65		            CALL fLCD_Data      ;Write character to display  
65f6 13			            INC  DE             ;Point to next character  
65f7 18 f7		            JR   fLCD_Str       ;Repeat  
65f9 c9					ret  
65fa			  
65fa			; Define custom character  
65fa			;   On entry: A = Character number (0 to 7)  
65fa			;             DE = Pointer to character bitmap data  
65fa			;   On exit:  A = Next character number  
65fa			;             DE = Next location following bitmap  
65fa			;             BC HL IX IY I AF' BC' DE' HL' preserved  
65fa			; Character is   
65fa c5			fLCD_Def:   PUSH BC  
65fb f5			            PUSH AF  
65fc 07			            RLCA                ;Calculate location  
65fd 07			            RLCA                ;  for bitmap data  
65fe 07			            RLCA                ;  = 8 x CharacterNumber  
65ff f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6601 cd a0 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6604 06 00		            LD   B, 0  
6606 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6607 cd c1 65		            CALL fLCD_Data      ;Write byte to display  
660a 13			            INC  DE             ;Point to next byte  
660b 04			            INC  B              ;Count bytes  
660c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
660e 28 f6		            JR   Z, Loop       ;No, so repeat  
6610 f1			            POP  AF  
6611 3c			            INC  A              ;Increment character number  
6612 c1			            POP  BC  
6613 c9			            RET  
6614			  
6614			  
6614			; **********************************************************************  
6614			; **  Private functions  
6614			; **********************************************************************  
6614			  
6614			; Write function to LCD  
6614			;   On entry: A = Function byte to be written  
6614			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6614 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6616 18 02		            JR   WrFunc  
6618 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
661a f5			WrFunc:     PUSH AF  
661b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
661d cb df		            SET  kLCDBitE, A  
661f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6621 cb 9f		            RES  kLCDBitE, A  
6623 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6625 3e 05		            LD   A, 5  
6627 cd 2e 66		            CALL LCDDelay       ;Delay 5 ms to complete  
662a f1			            POP  AF  
662b c9			            RET  
662c			  
662c			  
662c			; Delay in milliseconds  
662c			;   On entry: A = Number of milliseconds delay  
662c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
662c 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
662e d5			LCDDelay:   PUSH DE  
662f 5f			            LD   E, A           ;Delay by 'A' ms  
6630 16 00		            LD   D, 0  
6632 cd 3a 0a		            CALL aDelayInMS  
6635 d1			            POP  DE  
6636 c9			            RET  
6637			  
6637			  
6637			  
6637			  
6637			; eof  
6637			  
# End of file firmware_lcd_4x20.asm
6637			include "firmware_key_4x4.asm" 
6637			  
6637			  
6637			; bit mask for each scan column and row for teing the matrix  
6637			  
6637			; out   
6637 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
663b			; in  
663b 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
663f			  
663f			; row/col to character map  
663f			  
663f			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
663f			;    
663f			  
663f			; physical key matrix map to face of key  
663f			  
663f			  
663f			;      	1	2	3	A  
663f			;   	abc”	def&	ghi$	s1  
663f			;			  
663f			;	4	5	6	B  
663f			; 	jkl,	mno.	pqr:	s2  
663f			;			  
663f			; 	7	8	9	C  
663f			;	stu;	vwx@	yz?!	s3  
663f			;			  
663f			; 	*	0	#	D  
663f			; 	shift lck '	Space < >	Enter ( )	s4  
663f			;       tab bs 		  
663f			  
663f			  
663f			  
663f			  
663f			key_init:  
663f			  
663f			; SCMonAPI functions used  
663f			  
663f			; Alphanumeric LCD functions used  
663f			; no need to specify specific functions for this module  
663f			  
663f			  
663f 3e cf		            LD   A, 11001111b  
6641 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6643			;            LD   A, 00000000b  
6643 3e 0f		            LD   A, 00001111b  
6645 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6647			  
6647			  
6647				; TODO Configure cursor shapes  
6647			  
6647				; Load cursor shapes   
6647 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6649 11 59 66		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
664c 06 02		            LD   B, 2           ;Number of characters to define  
664e cd fa 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6651 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6653			  
6653 3e 01				ld a, 1  
6655 32 56 fa			ld (cursor_shape),a  
6658 c9				ret  
6659			  
6659			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6659			; Up to 8 custom characters can be defined  
6659			.cursor_shapes:      
6659			;; Character 0x00 = Normal  
6659 1f			            DB  11111b  
665a 1f			            DB  11111b  
665b 1f			            DB  11111b  
665c 1f			            DB  11111b  
665d 1f			            DB  11111b  
665e 1f			            DB  11111b  
665f 1f			            DB  11111b  
6660 1f			            DB  11111b  
6661			;; Character 0x01 = Modifier  
6661 1f			            DB  11111b  
6662 1b			            DB  11011b  
6663 1b			            DB  11011b  
6664 1b			            DB  11011b  
6665 1b			            DB  11011b  
6666 1f			            DB  11111b  
6667 1b			            DB  11011b  
6668 1f			            DB  11111b  
6669			  
6669			  
6669			  
6669			  
6669			; Display custom character 0  
6669			;            LD   A, kLCD_Line1+14  
6669			;            CALL fLCD_Pos       ;Position cursor to location in A  
6669			;            LD   A, 0  
6669			;            CALL fLCD_Data      ;Write character in A at cursor  
6669			  
6669			; Display custom character 1  
6669			;            LD   A, kLCD_Line2+14  
6669			;            CALL fLCD_Pos      ;Position cursor to location in A  
6669			;            LD   A, 1  
6669			;            CALL fLCD_Data     ;Write character in A at cursor  
6669			  
6669			; keyboard scanning   
6669			  
6669			  
6669			; key_rows: equ 4  
6669			; key_cols: equ 4  
6669			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6669			  
6669			; key_scanr: equ key_row_bitmask  
6669			; key_scanc: equ key_col_bitmask  
6669			  
6669			; key_char_map: equ key_map  
6669			  
6669			  
6669			  
6669			; character in from keyboard  
6669			  
6669 ..			.matrix_to_char: db "D#0*C987B654A321"  
6679			  
6679			  
6679			; map the physical key to a char dependant on state  
6679			  
6679			.key_map_fa:   
6679			  
6679 ..					db 'D'  
667a 0d					db KEY_CR    ; cr  
667b ..					db ' '  
667c 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
667d ..					db 'C'  
667e ..					db 'y'  
667f ..					db 'v'  
6680 ..					db 's'  
6681 ..					db 'B'  
6682 ..					db 'p'  
6683 ..					db 'm'  
6684 ..					db 'j'  
6685 ..					db 'A'  
6686 ..					db 'g'  
6687 ..					db 'd'  
6688 ..					db 'a'  
6689			  
6689			.key_map_fb:  
6689			  
6689 ..					db 'A'  
668a ..					db '+'   
668b ..					db '<'  
668c ..					db  "'"    
668d			  
668d ..					db 'A'  
668e ..					db 'z'  
668f ..					db 'w'  
6690 ..					db 't'  
6691 ..					db 'A'  
6692 ..					db 'q'  
6693 ..					db 'n'  
6694 ..					db 'k'  
6695 ..					db 'A'  
6696 ..					db 'h'  
6697 ..					db 'e'  
6698 ..			 		db 'b'  
6699			  
6699			.key_map_fc:   
6699			  
6699			  
6699 ..					db 'A'  
669a ..					db '-'   
669b ..					db '>'  
669c ..					db  '='   	  
669d ..					db 'A'  
669e ..					db '?'  
669f ..					db 'x'  
66a0 ..					db 'u'  
66a1 ..					db 'A'  
66a2 ..					db 'r'  
66a3 ..					db 'o'  
66a4 ..					db 'l'  
66a5 ..					db 'A'  
66a6 ..					db 'i'  
66a7 ..					db 'f'  
66a8 ..					db 'c'  
66a9			  
66a9				  
66a9			.key_map_fd:  
66a9			  
66a9 ..					db 'A'  
66aa ..					db '/'   
66ab ..					db '%'   
66ac 08					db KEY_BS  ; back space  
66ad ..					db 'A'  
66ae ..					db '!'  
66af ..					db '@'  
66b0 ..					db ';'  
66b1 ..					db 'A'  
66b2 ..					db ':'  
66b3 ..					db '.'  
66b4 ..					db ','  
66b5 ..					db 'A'  
66b6 ..					db '$'  
66b7 ..					db '&'  
66b8 ..				 	db '"'  
66b9			  
66b9					  
66b9				  
66b9			  
66b9			; add cin and cin_wait  
66b9			  
66b9 cd ca 66		cin_wait: 	call cin  
66bc fe 00			cp 0  
66be 28 f9			jr z, cin_wait   ; block until key press  
66c0			  
66c0 f5				push af   ; save key pressed  
66c1			  
66c1 cd ca 66		.cin_wait1:	call cin  
66c4 fe 00			cp 0  
66c6 20 f9			jr nz, .cin_wait1  	; wait for key release  
66c8			  
66c8 f1				pop af   ; get key  
66c9 c9				ret  
66ca			  
66ca			  
66ca cd db 66		cin: 	call .mtoc  
66cd			  
66cd				; no key held  
66cd fe 00			cp 0  
66cf c8				ret z  
66d0			  
66d0				; stop key bounce  
66d0			  
66d0			;	ld (key_held),a		 ; save it  
66d0 47				ld b, a  
66d1			  
66d1 c5			.cina1:	push bc  
66d2 cd db 66			call .mtoc  
66d5 c1				pop bc  
66d6 b8				cp b  
66d7 28 f8			jr z, .cina1  
66d9 78				ld a,b		  
66da c9				ret  
66db			  
66db			; detect keyboard modifier key press and apply new overlay to the face key held  
66db			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
66db			  
66db			;.cin_map_modifier:   
66db			;	ld a, (hl)  
66db			;	and 255  
66db			;	ret NZ		; modifier key not flagged  
66db			;  
66db			;	; get key face  
66db			;  
66db			;	ld b,(key_face_held)  
66db			;  
66db			;	ld b, key_cols * key_rows  
66db			;  
66db			;	push de  
66db			;	pop hl  
66db			;  
66db			;.mmod1: ld a,(hl)   ; get map test  
66db			;	cp b  
66db			;	jr z, .mmod2  
66db			;  
66db			;  
66db			;  
66db			;.mmod2: inc hl    ;   
66db			;  
66db			;	  
66db			;  
66db			;	  
66db			;  
66db			;	ld hl,key_actual_pressed  
66db			;	ld (hl),a,  
66db			;	ret  
66db			  
66db				  
66db			  
66db			; map matrix key held to char on face of key  
66db			  
66db			.mtoc:  
66db			  
66db			  
66db				; TODO optimise the code....  
66db			  
66db			; scan keyboard row 1  
66db 3e 80			ld a, 128  
66dd 21 d3 fb			ld hl, keyscan_table  
66e0 cd c2 67			call .rowscan  
66e3			  
66e3				   
66e3			  
66e3 3e 40			ld a, 64  
66e5 21 d7 fb			ld hl, keyscan_table+key_cols  
66e8 cd c2 67			call .rowscan  
66eb			  
66eb			  
66eb			  
66eb			  
66eb 3e 20			ld a, 32  
66ed 21 db fb			ld hl, keyscan_table+(key_cols*2)  
66f0 cd c2 67			call .rowscan  
66f3			  
66f3			  
66f3			  
66f3 3e 10			ld a, 16  
66f5 21 df fb			ld hl, keyscan_table+(key_cols*3)  
66f8 cd c2 67			call .rowscan  
66fb			  
66fb			  
66fb				; flag if key D is held down and remove from reporting  
66fb 01 a9 66			ld bc, .key_map_fd    
66fe 21 d3 fb			ld hl, keyscan_table  
6701 11 c5 fb			ld de, key_fd  
6704 cd 54 67			call .key_shift_hold  
6707 fe ff			cp 255  
6709 28 33			jr z, .cinmap  
670b				; flag if key C is held down and remove from reporting  
670b 01 99 66			ld bc, .key_map_fc    
670e 21 d7 fb			ld hl, keyscan_table+key_cols  
6711 11 c6 fb			ld de, key_fc  
6714 cd 54 67			call .key_shift_hold  
6717 fe ff			cp 255  
6719 28 23			jr z, .cinmap  
671b				; flag if key B is held down and remove from reporting  
671b 01 89 66			ld bc, .key_map_fb    
671e 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6721 11 c7 fb			ld de, key_fb  
6724 cd 54 67			call .key_shift_hold  
6727 fe ff			cp 255  
6729 28 13			jr z, .cinmap  
672b				; flag if key A is held down and remove from reporting  
672b 01 79 66			ld bc, .key_map_fa    
672e 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6731 11 c8 fb			ld de, key_fa  
6734 cd 54 67			call .key_shift_hold  
6737 fe ff			cp 255  
6739 28 03			jr z, .cinmap  
673b			  
673b 11 69 66			ld de, .matrix_to_char  
673e			  
673e			  
673e			.cinmap:   
673e				if DEBUG_KEY  
673e			            LD   A, kLCD_Line4  
673e			            CALL fLCD_Pos       ;Position cursor to location in A  
673e					push de  
673e			            LD   DE, keyscan_table  
673e			            CALL fLCD_Str       ;Display string pointed to by DE  
673e					pop de  
673e				endif  
673e			  
673e				; scan key matrix table for any held key  
673e			  
673e				; de holds either the default matrix or one selected above  
673e			  
673e 21 d3 fb			ld hl, keyscan_table  
6741 06 10			ld b,key_cols*key_rows  
6743			  
6743 7e			.cin1:	ld a,(hl)  
6744 fe 23			cp '#'  
6746 28 08			jr z, .cinhit  
6748 23				inc hl  
6749 13				inc de  
674a 05				dec b  
674b 20 f6			jr nz, .cin1  
674d				; no key found held  
674d 3e 00			ld a,0  
674f c9				ret  
6750 d5			.cinhit: push de  
6751 e1				pop hl  
6752 7e				ld a,(hl)  
6753 c9				ret  
6754			  
6754			; flag a control key is held   
6754			; hl is key pin, de is flag indicator  
6754			  
6754			.key_shift_hold:  
6754 c5				push bc  
6755 3e 01			ld a, 1  
6757 32 56 fa			ld (cursor_shape),a  
675a 06 00			ld b, 0  
675c 7e				ld a, (hl)  
675d fe 2e			cp '.'  
675f 28 0a			jr z, .key_shift1  
6761 06 ff			ld b, 255  
6763 3e 2b			ld a, '+'    ; hide key from later scans  
6765 77				ld (hl),a  
6766 3e 02			ld a, 2  
6768 32 56 fa			ld (cursor_shape),a  
676b			.key_shift1:  
676b				; write flag indicator  
676b 78				ld a,b  
676c 12				ld (de),a  
676d			  
676d d1				pop de    ; de now holds the key map ptr  
676e c9				ret  
676f			  
676f				  
676f				  
676f			  
676f			  
676f			  
676f			  
676f			  
676f			  
676f			  
676f			  
676f			  
676f			  
676f c9				ret  
6770			  
6770			;	push hl  
6770			;	push de  
6770			;	push bc  
6770			;	call keyscan  
6770			;	; map key matrix to ascii value of key face  
6770			;  
6770			;	ld hl, key_face_map  
6770			;	ld de, keyscan_table  
6770			;  
6770			;	; get how many keys to look at  
6770			;	ld b, keyscan_table_len  
6770			;	  
6770			;  
6770			;	; at this stage fall out on first key hit  
6770			;	; TODO handle multiple key press  
6770			;  
6770			;map1:	ld a,(hl)  
6770			;	cp '#'  
6770			;	jr z, keyhit  
6770			;	inc hl  
6770			;	inc de  
6770			;	dec b  
6770			;	jr nz, map1  
6770			;nohit:	ld a, 0  
6770			;	jr keydone  
6770			;keyhit: push de  
6770			;	pop hl  
6770			;	ld a,(hl)  
6770			;keydone:  
6770			;	push bc  
6770			;	push de  
6770			; 	push hl  
6770			;	ret   
6770			;  
6770			  
6770			  
6770			  
6770			  
6770			; scan physical key matrix  
6770			  
6770			  
6770			;keyscan:  
6770			;  
6770			;; for each key_row use keyscanr bit mask for out  
6770			;; then read in for keyscanc bitmask  
6770			;; save result of row scan to keyscantable  
6770			;  
6770			;; scan keyboard row 1  
6770			;  
6770			;	ld b, key_rows  
6770			;	ld hl, key_scanr  
6770			;	ld de, keyscan_table  
6770			;  
6770			;rowloop:  
6770			;  
6770			;	ld a,(hl)		; out bit mask to energise keyboard row  
6770			;	call rowscan  
6770			;	inc hl  
6770			;	dec b  
6770			;	jr nz, rowloop  
6770			;  
6770			;	ret  
6770			;  
6770			;  
6770			;; pass a out bitmask, b row number  
6770			;arowscan:   
6770			;	push bc  
6770			;  
6770			;	ld d, b  
6770			;  
6770			;	; calculate buffer location for this row  
6770			;  
6770			;	ld hl, keyscan_table	  
6770			;kbufr:  ld e, key_cols  
6770			;kbufc:	inc hl  
6770			;	dec e  
6770			;	jr nz, kbufc  
6770			;	dec d  
6770			;	jr nz, kbufr  
6770			;  
6770			;	; energise row and read columns  
6770			;  
6770			;	out (portbdata),a  
6770			;	in a,(portbdata)  
6770			;	ld c,a  
6770			;  
6770			;  
6770			;	; save buffer loc  
6770			;  
6770			;	ld (keybufptr), hl  
6770			;  
6770			;	ld hl, key_scanc  
6770			;	ld d, key_cols  
6770			;  
6770			;	; for each column check each bit mask  
6770			;  
6770			;colloop:  
6770			;	  
6770			;  
6770			;	; reset flags for the row   
6770			;  
6770			;	ld b,'.'  
6770			;	and (hl)  
6770			;	jr z, maskskip  
6770			;	ld b,'#'  
6770			;maskskip:  
6770			;	; save  key state  
6770			;	push hl  
6770			;	ld hl, (keybufptr)  
6770			;	ld (hl), b  
6770			;	inc hl  
6770			;	ld (keybufptr), hl  
6770			;  
6770			;	; move to next bit mask  
6770			;	pop hl  
6770			;	inc hl  
6770			;  
6770			;	dec d  
6770			;	jr nz, colloop  
6770			;  
6770			;	ret  
6770			;  
6770			;  
6770			;;  
6770			; lcd functions  
6770			;  
6770			;  
6770			  
6770			;if DEBUG_KEY_MATRIX  
6770			  
6770			; test function to display hardware view of matrix state  
6770			  
6770			matrix:  
6770			  
6770			  
6770			  
6770			; scan keyboard row 1  
6770 3e 80			ld a, 128  
6772 21 f8 fb			ld hl, keyscan_table_row1  
6775 cd c2 67			call .rowscan  
6778			  
6778 3e 40			ld a, 64  
677a 21 f3 fb			ld hl, keyscan_table_row2  
677d cd c2 67			call .rowscan  
6780			  
6780 3e 20			ld a, 32  
6782 21 ee fb			ld hl, keyscan_table_row3  
6785 cd c2 67			call .rowscan  
6788			  
6788 3e 10			ld a, 16  
678a 21 e9 fb			ld hl, keyscan_table_row4  
678d cd c2 67			call .rowscan  
6790			  
6790			; Display text on first line  
6790 3e 00		            LD   A, kLCD_Line1  
6792 cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6795 11 f8 fb		            LD   DE, keyscan_table_row1  
6798			            ;LD   DE, MsgHello  
6798 cd f0 65		            CALL fLCD_Str       ;Display string pointed to by DE  
679b			  
679b			; Display text on second line  
679b 3e 40		            LD   A, kLCD_Line2  
679d cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67a0 11 f3 fb		            LD   DE, keyscan_table_row2  
67a3 cd f0 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67a6 3e 14		            LD   A, kLCD_Line3  
67a8 cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67ab 11 ee fb		            LD   DE, keyscan_table_row3  
67ae cd f0 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67b1 3e 54		            LD   A, kLCD_Line4  
67b3 cd e8 65		            CALL fLCD_Pos       ;Position cursor to location in A  
67b6 11 e9 fb		            LD   DE, keyscan_table_row4  
67b9 cd f0 65		            CALL fLCD_Str       ;Display string pointed to by DE  
67bc			  
67bc cd 49 0a			call delay250ms  
67bf c3 70 67			jp matrix  
67c2			  
67c2			; pass de as row display flags  
67c2			.rowscan:   
67c2 d3 c1			out (portbdata),a  
67c4 db c1			in a,(portbdata)  
67c6 4f				ld c,a  
67c7				; reset flags for the row   
67c7 06 2e			ld b,'.'  
67c9 e6 01			and 1  
67cb 28 02			jr z, .p1on  
67cd 06 23			ld b,'#'  
67cf			.p1on:  
67cf 70				ld (hl), b  
67d0 23				inc hl  
67d1			  
67d1 06 2e			ld b,'.'  
67d3 79				ld a,c  
67d4 e6 02			and 2  
67d6			;	bit 0,a  
67d6 28 02			jr z, .p2on  
67d8 06 23			ld b,'#'  
67da			.p2on:  
67da 70				ld (hl), b  
67db 23				inc hl  
67dc			;  
67dc 06 2e			ld b,'.'  
67de 79				ld a,c  
67df e6 04			and 4  
67e1			;;	bit 0,a  
67e1 28 02			jr z, .p3on  
67e3 06 23			ld b,'#'  
67e5			.p3on:  
67e5 70				ld (hl), b  
67e6 23				inc hl  
67e7			;;  
67e7 06 2e			ld b,'.'  
67e9			;;	bit 0,a  
67e9 79				ld a,c  
67ea e6 08			and 8  
67ec 28 02			jr z, .p4on  
67ee 06 23			ld b,'#'  
67f0			.p4on:  
67f0 70				ld (hl), b  
67f1 23				inc hl  
67f2			  
67f2			; zero term  
67f2 06 00			ld b,0  
67f4 70				ld (hl), b  
67f5			  
67f5 c9			.rscandone: ret  
67f6			  
67f6			  
67f6			  
67f6			;endif  
67f6			  
67f6			  
67f6			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
67f6
