# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 96 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 18 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 18 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 18 0d				call clear_display  
0037			  
0037			  
0037 cd 98 6d				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 2f 70			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ef 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd ac 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 3b 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 1d 0d			call fill_display  
0051 cd 3b 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 1d 0d			call fill_display  
005c cd 3b 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 1d 0d			call fill_display  
0067 cd 3b 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 c9 1a			ld de, prom_bootmsg  
0072 cd 2b 0d			call str_at_display  
0075 cd 3b 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 de 1a			ld de, prom_bootmsg1  
0083 cd 2b 0d			call str_at_display  
0086 cd 3b 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 6b fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 68 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 68 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 68 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 68 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 68 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 6a fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 67 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 6b fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 67 fa			ld (spi_device), a 
021a 32 6a fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 68 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 68 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 68 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 68 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 68 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 68 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 68 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 68 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 68 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 68 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 68 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 68 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 68 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 68 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 68 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 68 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 68 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 68 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 68 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 68 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 fe f1			ld hl,scratch+2 
02f5 cd 03 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 1f f5			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 03 f2			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a 1f f5				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a 1f f5				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 1f f5				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 1f f5				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 24 f2				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a 24 f2				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a 1f f5				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 1f f5				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 24 f2				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 1f f5				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 7a fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd f3 18			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 81 fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd f3 18			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 81 fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd f3 18			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd 75 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 7a fa				ld hl, (store_tmp1) 
03b3 11 84 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd f3 18			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd e2 13				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd f3 18			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd f3 18			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd f3 18			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd f3 18			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd 75 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 81 fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd f3 18			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd f3 18			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 81 fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 81 fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd f3 18			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 82 fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd f3 18			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd f3 18			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 81 fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 82 fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 84 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 8d fa			ld hl, store_page+3+9 
0558 3a 66 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 81 fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd f3 18			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd f3 18			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 4c 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 4c 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd f3 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 84 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd f3 18			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 81 fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd f3 18			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd f3 18			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd 75 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 81 fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd 75 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd f3 18			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 81 fa			ld a, (store_page)	; get file id 
06b3 32 75 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 74 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 81 fa			ld (store_page), a 
06c2 32 82 fa			ld (store_page+1),a 
06c5 11 81 fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd f3 18			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 74 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 75 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd f3 18			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd 75 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 81 fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 81 fa			ld (store_page), a 
0725 32 82 fa			ld (store_page+1),a 
0728 11 81 fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd f3 18			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd f3 18			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd 6a 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 4c 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd 6a 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 4c 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd f3 18			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd f3 18			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 4c 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 4c 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd f3 18			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 81 fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 81 fa			ld (store_page),a 
0846				 
0846 32 75 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 81 fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd f3 18			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 81 fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd f3 18			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd f3 18			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 6c fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 75 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 81 fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 82 fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 83 fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd f3 18			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd b5 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd f3 18			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd f3 18			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 6c fa			ld hl,(store_tmppageid) 
092e 11 81 fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd f3 18			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 75 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd f3 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd f3 18			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd f3 18			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd 75 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 72 fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd f3 18			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 4c 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 74 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd f3 18			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 7c fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 4c 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd f3 18			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd f3 18			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd f3 18			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd 75 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 72 fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd f3 18			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd f3 18			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd f3 18			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd f3 18			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 75 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 75 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd 75 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 6c fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd f3 18			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 81 fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd f3 18			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 83 fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 83 fa			ld (store_page+2), a 
0b86 32 74 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd f3 18			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 6c fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd 75 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 6c fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd f3 18			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 81 fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 75 fa				ld a, (store_tmpid) 
0bee 32 81 fa				ld (store_page), a   ; file id 
0bf1 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 82 fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 83 fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd f3 18			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 6c fa			ld hl, (store_tmppageid) 
0c28 11 81 fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd f3 18			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 75 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 81 fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 82 fa			ld de, store_page+1 
0c64 01 18 01			ld bc, STORE_BLOCK_LOG 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; information window 
0ca9			 
0ca9			; pass hl with 1st string to display 
0ca9			; pass de with 2nd string to display 
0ca9			 
0ca9			info_panel: 
0ca9 e5				push hl 
0caa			 
0caa 2a cf fb			ld hl, (display_fb_active) 
0cad e5				push hl    ; future de destination 
0cae 21 b4 fd				ld hl, display_fb0 
0cb1 22 cf fb				ld (display_fb_active), hl 
0cb4			 
0cb4			;	call clear_display 
0cb4			 
0cb4				if BASE_CPM 
0cb4				ld a, '.' 
0cb4				else 
0cb4 3e a5			ld a, 165 
0cb6				endif 
0cb6 cd 1d 0d			call fill_display 
0cb9			 
0cb9			 
0cb9 3e 55			ld a, display_row_3 + 5 
0cbb cd 2b 0d			call str_at_display 
0cbe			 
0cbe e1				pop hl 
0cbf d1				pop de 
0cc0			 
0cc0 e5				push hl 
0cc1			 
0cc1			 
0cc1 3e 2d			ld a, display_row_2 + 5 
0cc3 cd 2b 0d			call str_at_display 
0cc6			 
0cc6			 
0cc6 cd 3b 0d			call update_display 
0cc9 cd df 1e			call next_page_prompt 
0ccc cd 18 0d			call clear_display 
0ccf			 
0ccf				 
0ccf 21 13 fd				ld hl, display_fb1 
0cd2 22 cf fb				ld (display_fb_active), hl 
0cd5 cd 3b 0d			call update_display 
0cd8			 
0cd8 e1				pop hl 
0cd9			 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			 
0cda			 
0cda			; TODO windowing? 
0cda			 
0cda			; TODO scroll line up 
0cda			 
0cda			scroll_up: 
0cda			 
0cda e5				push hl 
0cdb d5				push de 
0cdc c5				push bc 
0cdd			 
0cdd				; get frame buffer  
0cdd			 
0cdd 2a cf fb			ld hl, (display_fb_active) 
0ce0 e5				push hl    ; future de destination 
0ce1			 
0ce1 11 28 00			ld  de, display_cols 
0ce4 19				add hl, de 
0ce5			 
0ce5 d1				pop de 
0ce6			 
0ce6				;ex de, hl 
0ce6 01 9f 00			ld bc, display_fb_len -1  
0ce9			;if DEBUG_FORTH_WORDS 
0ce9			;	DMARK "SCL" 
0ce9			;	CALLMONITOR 
0ce9			;endif	 
0ce9 ed b0			ldir 
0ceb			 
0ceb				; wipe bottom row 
0ceb			 
0ceb			 
0ceb 2a cf fb			ld hl, (display_fb_active) 
0cee 11 a0 00			ld de, display_cols*display_rows 
0cf1 19				add hl, de 
0cf2 06 28			ld b, display_cols 
0cf4 3e 20			ld a, ' ' 
0cf6			.scwipe: 
0cf6 77				ld (hl), a 
0cf7 2b				dec hl 
0cf8 10 fc			djnz .scwipe 
0cfa			 
0cfa				;pop hl 
0cfa			 
0cfa c1				pop bc 
0cfb d1				pop de 
0cfc e1				pop hl 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			;scroll_upo: 
0cfe			;	ld de, display_row_1 
0cfe			 ;	ld hl, display_row_2 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_2 
0cfe			 ;	ld hl, display_row_3 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_3 
0cfe			 ;	ld hl, display_row_4 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			 
0cfe			; TODO clear row 4 
0cfe			 
0cfe			;	ret 
0cfe			 
0cfe				 
0cfe			scroll_down: 
0cfe			 
0cfe e5				push hl 
0cff d5				push de 
0d00 c5				push bc 
0d01			 
0d01				; get frame buffer  
0d01			 
0d01 2a cf fb			ld hl, (display_fb_active) 
0d04			 
0d04 11 9f 00			ld de, display_fb_len - 1 
0d07 19				add hl, de 
0d08			 
0d08 e5			push hl    ; future de destination 
0d09			 
0d09 11 28 00			ld  de, display_cols 
0d0c ed 52			sbc hl, de 
0d0e			 
0d0e			 
0d0e d1				pop de 
0d0f			 
0d0f			;	ex de, hl 
0d0f 01 9f 00			ld bc, display_fb_len -1  
0d12			 
0d12			 
0d12				 
0d12			 
0d12 ed b0			ldir 
0d14			 
0d14				; wipe bottom row 
0d14			 
0d14			 
0d14			;	ld hl, (display_fb_active) 
0d14			;;	ld de, display_cols*display_rows 
0d14			;;	add hl, de 
0d14			;	ld b, display_cols 
0d14			;	ld a, ' ' 
0d14			;.scwiped: 
0d14			;	ld (hl), a 
0d14			;	dec hl 
0d14			;	djnz .scwiped 
0d14			 
0d14				;pop hl 
0d14			 
0d14 c1				pop bc 
0d15 d1				pop de 
0d16 e1				pop hl 
0d17			 
0d17 c9				ret 
0d18			;scroll_down: 
0d18			;	ld de, display_row_4 
0d18			;	ld hl, display_row_3 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_3 
0d18			; 	ld hl, display_row_2 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_2 
0d18			;	ld hl, display_row_1 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;;; TODO clear row 1 
0d18			;	ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			; clear active frame buffer 
0d18			 
0d18			clear_display: 
0d18 3e 20			ld a, ' ' 
0d1a c3 1d 0d			jp fill_display 
0d1d			 
0d1d			; fill active frame buffer with a char in A 
0d1d			 
0d1d			fill_display: 
0d1d 06 a0			ld b,display_fb_len 
0d1f 2a cf fb			ld hl, (display_fb_active) 
0d22 77			.fd1:	ld (hl),a 
0d23 23				inc hl 
0d24 10 fc			djnz .fd1 
0d26 23				inc hl 
0d27 3e 00			ld a,0 
0d29 77				ld (hl),a 
0d2a			 
0d2a			 
0d2a c9				ret 
0d2b			; Write string (DE) at pos (A) to active frame buffer 
0d2b			 
0d2b 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d2e 06 00					ld b,0 
0d30 4f					ld c,a 
0d31 09					add hl,bc 
0d32 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d33 b7			            OR   A              ;Null terminator? 
0d34 c8			            RET  Z              ;Yes, so finished 
0d35 77					ld (hl),a 
0d36 23				inc hl 
0d37 13			            INC  DE             ;Point to next character 
0d38 18 f8		            JR   .sad1     ;Repeat 
0d3a c9					ret 
0d3b			 
0d3b			; using current frame buffer write to physical display 
0d3b			 
0d3b			update_display: 
0d3b e5				push hl 
0d3c 2a cf fb			ld hl, (display_fb_active) 
0d3f cd c4 6d			call write_display 
0d42 e1				pop hl 
0d43 c9				ret 
0d44			 
0d44			; TODO scrolling 
0d44			 
0d44			 
0d44			; move cursor right one char 
0d44			cursor_right: 
0d44			 
0d44				; TODO shift right 
0d44				; TODO if beyond max col 
0d44				; TODO       cursor_next_line 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cursor_next_line: 
0d45				; TODO first char 
0d45				; TODO line down 
0d45				; TODO if past last row 
0d45				; TODO    scroll up 
0d45			 
0d45 c9				ret 
0d46			 
0d46			cursor_left: 
0d46				; TODO shift left 
0d46				; TODO if beyond left  
0d46				; TODO     cursor prev line 
0d46				 
0d46 c9				ret 
0d47			 
0d47			cursor_prev_line: 
0d47				; TODO last char 
0d47				; TODO line up 
0d47				; TODO if past first row 
0d47				; TODO   scroll down 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			cout: 
0d48				; A - char 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; Display a menu and allow item selection (optional toggle items) 
0d49			; 
0d49			; format: 
0d49			; hl pointer to word array with zero term for items 
0d49			; e.g.    db item1 
0d49			;         db .... 
0d49			;         db 0 
0d49			; 
0d49			; a = starting menu item  
0d49			; 
0d49			; de = pointer item toggle array   (todo) 
0d49			; 
0d49			; returns item selected in a 1-... 
0d49			; returns 0 if back button pressed 
0d49			; 
0d49			; NOTE: Uses system frame buffer to display 
0d49			; 
0d49			; LEFT, Q = go back 
0d49			; RIGHT, SPACE, CR = select 
0d49			; UP, A - Up 
0d49			; DOWN, Z - Down 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			menu: 
0d49			 
0d49					; keep array pointer 
0d49			 
0d49 22 7a fa				ld (store_tmp1), hl 
0d4c 32 78 fa				ld (store_tmp2), a 
0d4f			 
0d4f					; check for key bounce 
0d4f			 
0d4f			if BASE_KEV 
0d4f			 
0d4f cd 0f 71		.mbounce:	call cin 
0d52 fe 00				cp 0 
0d54 20 f9				jr nz, .mbounce 
0d56			endif 
0d56					; for ease use ex 
0d56			 
0d56					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d56 21 b4 fd				ld hl, display_fb0 
0d59 22 cf fb				ld (display_fb_active), hl 
0d5c			 
0d5c cd 18 0d		.mloop:		call clear_display 
0d5f cd 3b 0d				call update_display 
0d62			 
0d62					; draw selection id '>' at 1 
0d62			 
0d62					; init start of list display 
0d62			 
0d62 3e 05				ld a, 5 
0d64 32 76 fa				ld (store_tmp3), a   ; display row count 
0d67 3a 78 fa				ld a,( store_tmp2) 
0d6a 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d6d			 
0d6d					 
0d6d			.mitem:	 
0d6d			 
0d6d			 
0d6d 3a 79 fa				ld a,(store_tmp2+1) 
0d70 6f					ld l, a 
0d71 26 00				ld h, 0 
0d73 29					add hl, hl 
0d74 ed 5b 7a fa			ld de, (store_tmp1) 
0d78 19					add hl, de 
0d79 7e					ld a, (hl) 
0d7a 23					inc hl 
0d7b 66					ld h,(hl) 
0d7c 6f					ld l, a 
0d7d			 
0d7d cd 75 0f				call ishlzero 
0d80 28 1a				jr z, .mdone 
0d82			 
0d82 eb					ex de, hl 
0d83 3a 76 fa				ld a, (store_tmp3) 
0d86 cd 2b 0d				call str_at_display 
0d89					 
0d89			 
0d89					; next item 
0d89 3a 79 fa				ld a, (store_tmp2+1) 
0d8c 3c					inc a 
0d8d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d90			 
0d90			 		; next row 
0d90			 
0d90 3a 76 fa				ld a, (store_tmp3) 
0d93 c6 28				add display_cols 
0d95 32 76 fa				ld (store_tmp3), a 
0d98			 
0d98					; at end of screen? 
0d98			 
0d98 fe 10				cp display_rows*4 
0d9a 20 d1				jr nz, .mitem 
0d9c			 
0d9c			 
0d9c			.mdone: 
0d9c cd 75 0f				call ishlzero 
0d9f 28 08				jr z, .nodn 
0da1			 
0da1 3e 78				ld a, display_row_4 
0da3 11 22 0e				ld de, .mdown 
0da6 cd 2b 0d				call str_at_display 
0da9			 
0da9					; draw options to fill the screens with active item on line 1 
0da9					; if current option is 2 or more then display ^ in top 
0da9			 
0da9 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0dac fe 00				cp 0 
0dae 28 08				jr z, .noup 
0db0			 
0db0 3e 00				ld a, 0 
0db2 11 20 0e				ld de, .mup 
0db5 cd 2b 0d				call str_at_display 
0db8			 
0db8 3e 02		.noup:		ld a, 2 
0dba 11 1e 0e				ld de, .msel 
0dbd cd 2b 0d				call str_at_display 
0dc0			 
0dc0					; if current option + 1 is not null then display V in bottom 
0dc0					; get key 
0dc0 cd 3b 0d				call update_display 
0dc3			 
0dc3			 
0dc3					; handle key 
0dc3			 
0dc3 cd fe 70				call cin_wait 
0dc6			 
0dc6 fe 05				cp KEY_UP 
0dc8 28 2b				jr z, .mgoup 
0dca fe 61				cp 'a' 
0dcc 28 27				jr z, .mgoup 
0dce fe 0a				cp KEY_DOWN 
0dd0 28 32				jr z, .mgod 
0dd2 fe 7a				cp 'z' 
0dd4 28 2e				jr z, .mgod 
0dd6 fe 20				cp ' ' 
0dd8 28 34				jr z, .goend 
0dda fe 0c				cp KEY_RIGHT 
0ddc 28 30				jr z, .goend 
0dde fe 0d				cp KEY_CR 
0de0 28 2c				jr z, .goend 
0de2 fe 71				cp 'q' 
0de4 28 0b				jr z, .goback 
0de6			 
0de6 fe 0b				cp KEY_LEFT 
0de8 28 07				jr z, .goback 
0dea fe 08				cp KEY_BS 
0dec 28 03				jr z, .goback 
0dee c3 5c 0d				jp .mloop 
0df1			 
0df1			.goback: 
0df1 3e 00			ld a, 0 
0df3 18 1d			jr .goend2 
0df5			 
0df5				; move up one 
0df5			.mgoup: 
0df5 3a 78 fa				ld a, (store_tmp2) 
0df8 fe 00				cp 0 
0dfa ca 5c 0d				jp z, .mloop 
0dfd 3d					dec a 
0dfe 32 78 fa				ld (store_tmp2), a 
0e01 c3 5c 0d				jp .mloop 
0e04			 
0e04				; move down one 
0e04			.mgod: 
0e04 3a 78 fa				ld a, (store_tmp2) 
0e07 3c					inc a 
0e08 32 78 fa				ld (store_tmp2), a 
0e0b c3 5c 0d				jp .mloop 
0e0e			 
0e0e			 
0e0e			.goend: 
0e0e					; get selected item number 
0e0e			 
0e0e 3a 78 fa				ld a, (store_tmp2) 
0e11 3c					inc a 
0e12			 
0e12			.goend2: 
0e12 f5					push af 
0e13			 
0e13					; restore active fb 
0e13					; TODO BUG assumes fb1 
0e13			 
0e13 21 13 fd				ld hl, display_fb1 
0e16 22 cf fb				ld (display_fb_active), hl 
0e19			 
0e19					; restore main regs 
0e19			 
0e19			 
0e19 cd 3b 0d				call update_display 
0e1c			 
0e1c f1					pop af 
0e1d			 
0e1d c9				ret 
0e1e			 
0e1e .. 00		.msel:   db ">",0 
0e20 .. 00		.mup:   db "^",0 
0e22 .. 00		.mdown:   db "v",0 
0e24			 
0e24			 
0e24			; eof 
0e24			 
# End of file firmware_display.asm
0e24			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e24			; random number generators 
0e24			 
0e24			 
0e24			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e24			 
0e24			 
0e24			;-----> Generate a random number 
0e24			; output a=answer 0<=a<=255 
0e24			; all registers are preserved except: af 
0e24			random: 
0e24 e5			        push    hl 
0e25 d5			        push    de 
0e26 2a b1 fb		        ld      hl,(randData) 
0e29 ed 5f		        ld      a,r 
0e2b 57			        ld      d,a 
0e2c 5e			        ld      e,(hl) 
0e2d 19			        add     hl,de 
0e2e 85			        add     a,l 
0e2f ac			        xor     h 
0e30 22 b1 fb		        ld      (randData),hl 
0e33 d1			        pop     de 
0e34 e1			        pop     hl 
0e35 c9			        ret 
0e36			 
0e36			 
0e36			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e36			 
0e36			 
0e36			 
0e36			;------LFSR------ 
0e36			;James Montelongo 
0e36			;optimized by Spencer Putt 
0e36			;out: 
0e36			; a = 8 bit random number 
0e36			RandLFSR: 
0e36 21 b7 fb		        ld hl,LFSRSeed+4 
0e39 5e			        ld e,(hl) 
0e3a 23			        inc hl 
0e3b 56			        ld d,(hl) 
0e3c 23			        inc hl 
0e3d 4e			        ld c,(hl) 
0e3e 23			        inc hl 
0e3f 7e			        ld a,(hl) 
0e40 47			        ld b,a 
0e41 cb 13		        rl e  
0e43 cb 12			rl d 
0e45 cb 11		        rl c  
0e47 17				rla 
0e48 cb 13		        rl e  
0e4a cb 12			rl d 
0e4c cb 11		        rl c  
0e4e 17				rla 
0e4f cb 13		        rl e  
0e51 cb 12			rl d 
0e53 cb 11		        rl c  
0e55 17				rla 
0e56 67			        ld h,a 
0e57 cb 13		        rl e  
0e59 cb 12			rl d 
0e5b cb 11		        rl c  
0e5d 17				rla 
0e5e a8			        xor b 
0e5f cb 13		        rl e  
0e61 cb 12			rl d 
0e63 ac			        xor h 
0e64 a9			        xor c 
0e65 aa			        xor d 
0e66 21 b9 fb		        ld hl,LFSRSeed+6 
0e69 11 ba fb		        ld de,LFSRSeed+7 
0e6c 01 07 00		        ld bc,7 
0e6f ed b8		        lddr 
0e71 12			        ld (de),a 
0e72 c9			        ret 
0e73			 
0e73			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e73			 
0e73			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e73			 
0e73			 
0e73			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e73			 
0e73			prng16: 
0e73			;Inputs: 
0e73			;   (seed1) contains a 16-bit seed value 
0e73			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e73			;Outputs: 
0e73			;   HL is the result 
0e73			;   BC is the result of the LCG, so not that great of quality 
0e73			;   DE is preserved 
0e73			;Destroys: 
0e73			;   AF 
0e73			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e73			;160cc 
0e73			;26 bytes 
0e73 2a ab fb		    ld hl,(seed1) 
0e76 44			    ld b,h 
0e77 4d			    ld c,l 
0e78 29			    add hl,hl 
0e79 29			    add hl,hl 
0e7a 2c			    inc l 
0e7b 09			    add hl,bc 
0e7c 22 ab fb		    ld (seed1),hl 
0e7f 2a a9 fb		    ld hl,(seed2) 
0e82 29			    add hl,hl 
0e83 9f			    sbc a,a 
0e84 e6 2d		    and %00101101 
0e86 ad			    xor l 
0e87 6f			    ld l,a 
0e88 22 a9 fb		    ld (seed2),hl 
0e8b 09			    add hl,bc 
0e8c c9			    ret 
0e8d			 
0e8d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8d			 
0e8d			rand32: 
0e8d			;Inputs: 
0e8d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8d			;   **NOTE: seed2 must be non-zero 
0e8d			;Outputs: 
0e8d			;   HL is the result 
0e8d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8d			;Destroys: 
0e8d			;   AF 
0e8d			;Tested and passes all CAcert tests 
0e8d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8d			;it has a period of 18,446,744,069,414,584,320 
0e8d			;roughly 18.4 quintillion. 
0e8d			;LFSR taps: 0,2,6,7  = 11000101 
0e8d			;291cc 
0e8d			;seed1_0=$+1 
0e8d			;    ld hl,12345 
0e8d			;seed1_1=$+1 
0e8d			;    ld de,6789 
0e8d			;    ld b,h 
0e8d			;    ld c,l 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    inc l 
0e8d			;    add hl,bc 
0e8d			;    ld (seed1_0),hl 
0e8d			;    ld hl,(seed1_1) 
0e8d			;    adc hl,de 
0e8d			;    ld (seed1_1),hl 
0e8d			;    ex de,hl 
0e8d			;seed2_0=$+1 
0e8d			;    ld hl,9876 
0e8d			;seed2_1=$+1 
0e8d			;    ld bc,54321 
0e8d			;    add hl,hl \ rl c \ rl b 
0e8d			;    ld (seed2_1),bc 
0e8d			;    sbc a,a 
0e8d			;    and %11000101 
0e8d			;    xor l 
0e8d			;    ld l,a 
0e8d			;    ld (seed2_0),hl 
0e8d			;    ex de,hl 
0e8d			;    add hl,bc 
0e8d			;    ret 
0e8d			; 
0e8d			 
0e8d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8d			; 20 bytes, 86 cycles (excluding ret) 
0e8d			 
0e8d			; returns   hl = pseudorandom number 
0e8d			; corrupts   a 
0e8d			 
0e8d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8d			; using the xorshift method: 
0e8d			 
0e8d			; hl ^= hl << 7 
0e8d			; hl ^= hl >> 9 
0e8d			; hl ^= hl << 8 
0e8d			 
0e8d			; some alternative shift triplets which also perform well are: 
0e8d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8d			 
0e8d			;  org 32768 
0e8d			 
0e8d			xrnd: 
0e8d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e90 3e 00		  ld a,0 
0e92 bd			  cp l 
0e93 20 02		  jr nz, .xrnd1 
0e95 2e 01		  ld l, 1 
0e97			.xrnd1: 
0e97			 
0e97 7c			  ld a,h 
0e98 1f			  rra 
0e99 7d			  ld a,l 
0e9a 1f			  rra 
0e9b ac			  xor h 
0e9c 67			  ld h,a 
0e9d 7d			  ld a,l 
0e9e 1f			  rra 
0e9f 7c			  ld a,h 
0ea0 1f			  rra 
0ea1 ad			  xor l 
0ea2 6f			  ld l,a 
0ea3 ac			  xor h 
0ea4 67			  ld h,a 
0ea5			 
0ea5 22 af fb		  ld (xrandc),hl 
0ea8			 
0ea8 c9			  ret 
0ea9			;  
0ea9			 
0ea9			 
0ea9			;;;; int maths 
0ea9			 
0ea9			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea9			; Divide 16-bit values (with 16-bit result) 
0ea9			; In: Divide BC by divider DE 
0ea9			; Out: BC = result, HL = rest 
0ea9			; 
0ea9			Div16: 
0ea9 21 00 00		    ld hl,0 
0eac 78			    ld a,b 
0ead 06 08		    ld b,8 
0eaf			Div16_Loop1: 
0eaf 17			    rla 
0eb0 ed 6a		    adc hl,hl 
0eb2 ed 52		    sbc hl,de 
0eb4 30 01		    jr nc,Div16_NoAdd1 
0eb6 19			    add hl,de 
0eb7			Div16_NoAdd1: 
0eb7 10 f6		    djnz Div16_Loop1 
0eb9 17			    rla 
0eba 2f			    cpl 
0ebb 47			    ld b,a 
0ebc 79			    ld a,c 
0ebd 48			    ld c,b 
0ebe 06 08		    ld b,8 
0ec0			Div16_Loop2: 
0ec0 17			    rla 
0ec1 ed 6a		    adc hl,hl 
0ec3 ed 52		    sbc hl,de 
0ec5 30 01		    jr nc,Div16_NoAdd2 
0ec7 19			    add hl,de 
0ec8			Div16_NoAdd2: 
0ec8 10 f6		    djnz Div16_Loop2 
0eca 17			    rla 
0ecb 2f			    cpl 
0ecc 41			    ld b,c 
0ecd 4f			    ld c,a 
0ece c9			ret 
0ecf			 
0ecf			 
0ecf			;http://z80-heaven.wikidot.com/math 
0ecf			; 
0ecf			;Inputs: 
0ecf			;     DE and A are factors 
0ecf			;Outputs: 
0ecf			;     A is not changed 
0ecf			;     B is 0 
0ecf			;     C is not changed 
0ecf			;     DE is not changed 
0ecf			;     HL is the product 
0ecf			;Time: 
0ecf			;     342+6x 
0ecf			; 
0ecf			Mult16: 
0ecf			 
0ecf 06 08		     ld b,8          ;7           7 
0ed1 21 00 00		     ld hl,0         ;10         10 
0ed4 29			       add hl,hl     ;11*8       88 
0ed5 07			       rlca          ;4*8        32 
0ed6 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed8 19			         add hl,de   ;--         -- 
0ed9 10 f9		       djnz $-5      ;13*7+8     99 
0edb c9			ret 
0edc			 
0edc			; 
0edc			; Square root of 16-bit value 
0edc			; In:  HL = value 
0edc			; Out:  D = result (rounded down) 
0edc			; 
0edc			;Sqr16: 
0edc			;    ld de,#0040 
0edc			;    ld a,l 
0edc			;    ld l,h 
0edc			;    ld h,d 
0edc			;    or a 
0edc			;    ld b,8 
0edc			;Sqr16_Loop: 
0edc			;    sbc hl,de 
0edc			;    jr nc,Sqr16_Skip 
0edc			;    add hl,de 
0edc			;Sqr16_Skip: 
0edc			;    ccf 
0edc			;    rl d 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    djnz Sqr16_Loop 
0edc			;    ret 
0edc			; 
0edc			; 
0edc			; Divide 8-bit values 
0edc			; In: Divide E by divider C 
0edc			; Out: A = result, B = rest 
0edc			; 
0edc			Div8: 
0edc af			    xor a 
0edd 06 08		    ld b,8 
0edf			Div8_Loop: 
0edf cb 13		    rl e 
0ee1 17			    rla 
0ee2 91			    sub c 
0ee3 30 01		    jr nc,Div8_NoAdd 
0ee5 81			    add a,c 
0ee6			Div8_NoAdd: 
0ee6 10 f7		    djnz Div8_Loop 
0ee8 47			    ld b,a 
0ee9 7b			    ld a,e 
0eea 17			    rla 
0eeb 2f			    cpl 
0eec c9			    ret 
0eed			 
0eed			; 
0eed			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eed			; In: Multiply A with DE 
0eed			; Out: HL = result 
0eed			; 
0eed			Mult12U: 
0eed 2e 00		    ld l,0 
0eef 87			    add a,a 
0ef0 30 01		    jr nc,Mult12U_NoAdd0 
0ef2 19			    add hl,de 
0ef3			Mult12U_NoAdd0: 
0ef3 29			    add hl,hl 
0ef4 87			    add a,a 
0ef5 30 01		    jr nc,Mult12U_NoAdd1 
0ef7 19			    add hl,de 
0ef8			Mult12U_NoAdd1: 
0ef8 29			    add hl,hl 
0ef9 87			    add a,a 
0efa 30 01		    jr nc,Mult12U_NoAdd2 
0efc 19			    add hl,de 
0efd			Mult12U_NoAdd2: 
0efd 29			    add hl,hl 
0efe 87			    add a,a 
0eff 30 01		    jr nc,Mult12U_NoAdd3 
0f01 19			    add hl,de 
0f02			Mult12U_NoAdd3: 
0f02 29			    add hl,hl 
0f03 87			    add a,a 
0f04 30 01		    jr nc,Mult12U_NoAdd4 
0f06 19			    add hl,de 
0f07			Mult12U_NoAdd4: 
0f07 29			    add hl,hl 
0f08 87			    add a,a 
0f09 30 01		    jr nc,Mult12U_NoAdd5 
0f0b 19			    add hl,de 
0f0c			Mult12U_NoAdd5: 
0f0c 29			    add hl,hl 
0f0d 87			    add a,a 
0f0e 30 01		    jr nc,Mult12U_NoAdd6 
0f10 19			    add hl,de 
0f11			Mult12U_NoAdd6: 
0f11 29			    add hl,hl 
0f12 87			    add a,a 
0f13 d0			    ret nc 
0f14 19			    add hl,de 
0f15 c9			    ret 
0f16			 
0f16			; 
0f16			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f16			; In: Multiply A with DE 
0f16			;      Put lowest value in A for most efficient calculation 
0f16			; Out: HL = result 
0f16			; 
0f16			Mult12R: 
0f16 21 00 00		    ld hl,0 
0f19			Mult12R_Loop: 
0f19 cb 3f		    srl a 
0f1b 30 01		    jr nc,Mult12R_NoAdd 
0f1d 19			    add hl,de 
0f1e			Mult12R_NoAdd: 
0f1e cb 23		    sla e 
0f20 cb 12		    rl d 
0f22 b7			    or a 
0f23 c2 19 0f		    jp nz,Mult12R_Loop 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 16-bit values (with 32-bit result) 
0f27			; In: Multiply BC with DE 
0f27			; Out: BCHL = result 
0f27			; 
0f27			Mult32: 
0f27 79			    ld a,c 
0f28 48			    ld c,b 
0f29 21 00 00		    ld hl,0 
0f2c 06 10		    ld b,16 
0f2e			Mult32_Loop: 
0f2e 29			    add hl,hl 
0f2f 17			    rla 
0f30 cb 11		    rl c 
0f32 30 07		    jr nc,Mult32_NoAdd 
0f34 19			    add hl,de 
0f35 ce 00		    adc a,0 
0f37 d2 3b 0f		    jp nc,Mult32_NoAdd 
0f3a 0c			    inc c 
0f3b			Mult32_NoAdd: 
0f3b 10 f1		    djnz Mult32_Loop 
0f3d 41			    ld b,c 
0f3e 4f			    ld c,a 
0f3f c9			    ret 
0f40			 
0f40			 
0f40			 
0f40			; 
0f40			; Multiply 8-bit values 
0f40			; In:  Multiply H with E 
0f40			; Out: HL = result 
0f40			; 
0f40			Mult8: 
0f40 16 00		    ld d,0 
0f42 6a			    ld l,d 
0f43 06 08		    ld b,8 
0f45			Mult8_Loop: 
0f45 29			    add hl,hl 
0f46 30 01		    jr nc,Mult8_NoAdd 
0f48 19			    add hl,de 
0f49			Mult8_NoAdd: 
0f49 10 fa		    djnz Mult8_Loop 
0f4b c9			    ret 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			;;http://z80-heaven.wikidot.com/math 
0f4c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f4c			; 
0f4c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f4c			;     ld a,16        ;7 
0f4c			;     ld hl,0        ;10 
0f4c			;     jp $+5         ;10 
0f4c			;.DivLoop: 
0f4c			;       add hl,bc    ;-- 
0f4c			;       dec a        ;64 
0f4c			;       jr z,.DivLoopEnd        ;86 
0f4c			; 
0f4c			;       sla e        ;128 
0f4c			;       rl d         ;128 
0f4c			;       adc hl,hl    ;240 
0f4c			;       sbc hl,bc    ;240 
0f4c			;       jr nc,.DivLoop ;23|21 
0f4c			;       inc e        ;-- 
0f4c			;       jp .DivLoop+1 
0f4c			; 
0f4c			;.DivLoopEnd: 
0f4c			 
0f4c			;HL_Div_C: 
0f4c			;Inputs: 
0f4c			;     HL is the numerator 
0f4c			;     C is the denominator 
0f4c			;Outputs: 
0f4c			;     A is the remainder 
0f4c			;     B is 0 
0f4c			;     C is not changed 
0f4c			;     DE is not changed 
0f4c			;     HL is the quotient 
0f4c			; 
0f4c			;       ld b,16 
0f4c			;       xor a 
0f4c			;         add hl,hl 
0f4c			;         rla 
0f4c			;         cp c 
0f4c			;         jr c,$+4 
0f4c			;           inc l 
0f4c			;           sub c 
0f4c			;         djnz $-7 
0f4c			 
0f4c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f4c			 
0f4c			addatohl: 
0f4c 85			    add   a, l    ; A = A+L 
0f4d 6f			    ld    l, a    ; L = A+L 
0f4e 8c			    adc   a, h    ; A = A+L+H+carry 
0f4f 95			    sub   l       ; A = H+carry 
0f50 67			    ld    h, a    ; H = H+carry 
0f51 c9			ret 
0f52			 
0f52			addatode: 
0f52 83			    add   a, e    ; A = A+L 
0f53 5f			    ld    e, a    ; L = A+L 
0f54 8a			    adc   a, d    ; A = A+L+H+carry 
0f55 93			    sub   e       ; A = H+carry 
0f56 57			    ld    d, a    ; H = H+carry 
0f57 c9			ret 
0f58			 
0f58			 
0f58			addatobc: 
0f58 81			    add   a, c    ; A = A+L 
0f59 4f			    ld    c, a    ; L = A+L 
0f5a 88			    adc   a, b    ; A = A+L+H+carry 
0f5b 91			    sub   c       ; A = H+carry 
0f5c 47			    ld    b, a    ; H = H+carry 
0f5d c9			ret 
0f5e			 
0f5e			subafromhl: 
0f5e			   ; If A=0 do nothing 
0f5e			    ; Otherwise flip A's sign. Since 
0f5e			    ; the upper byte becomes -1, also 
0f5e			    ; substract 1 from H. 
0f5e ed 44		    neg 
0f60 ca 69 0f		    jp    z, Skip 
0f63 25			    dec   h 
0f64			     
0f64			    ; Now add the low byte as usual 
0f64			    ; Two's complement takes care of 
0f64			    ; ensuring the result is correct 
0f64 85			    add   a, l 
0f65 6f			    ld    l, a 
0f66 8c			    adc   a, h 
0f67 95			    sub   l 
0f68 67			    ld    h, a 
0f69			Skip: 
0f69 c9				ret 
0f6a			 
0f6a			 
0f6a			; compare hl and de 
0f6a			; returns:  
0f6a			; if hl = de, z=1, s=0, c0=0 
0f6a			; if hl > de, z=0, s=0, c=0 
0f6a			; if hl < de, z=0, s=1, c=1 
0f6a			cmp16:	 
0f6a b7				or a 
0f6b ed 52			sbc hl,de 
0f6d e0				ret po 
0f6e 7c				ld a,h 
0f6f 1f				rra 
0f70 ee 40			xor 01000000B 
0f72 37				scf 
0f73 8f				adc a,a 
0f74 c9				ret 
0f75			 
0f75			 
0f75			; test if hl contains zero   - A is destroyed 
0f75			 
0f75			ishlzero:    
0f75 b7				or a     ; reset flags 
0f76 7c				ld a, h 
0f77 b5				or l        	 
0f78			 
0f78 c9				ret 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			if FORTH_ENABLE_FLOATMATH 
0f79			;include "float/bbcmath.z80" 
0f79			include "float/lpfpcalc.asm" 
0f79			endif 
0f79			 
0f79			 
0f79			; eof 
0f79			 
# End of file firmware_maths.asm
0f79			include "firmware_strings.asm"   ; string handling  
0f79			 
0f79			 
0f79			; TODO string len 
0f79			; input text string, end on cr with zero term 
0f79			; a offset into frame buffer to start prompt 
0f79			; d is max length 
0f79			; e is display size TODO 
0f79			; c is current cursor position 
0f79			; hl is ptr to where string will be stored 
0f79			 
0f79			 
0f79			; TODO check limit of buffer for new inserts 
0f79			; TODO check insert does not push beyond buffer 
0f79			; TODO scroll in a limited display area 
0f79			; TODO scroll whole screen on page wrap 
0f79			 
0f79			 
0f79			; TODO handle KEY_PREVWORD 
0f79			; TODO handle KEY_NEXTWORD 
0f79			; TODO handle KEY_HOME 
0f79			; TODO handle KEY_END 
0f79			; TODO use LCD cursor? 
0f79			 
0f79 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f7c 81					add c 
0f7d 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f80 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f83 79					ld a, c 
0f84 cd 4c 0f				call addatohl 
0f87 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f8a 7a					ld a,d 
0f8b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f8e 79					ld a, c 
0f8f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f92 7b					ld a,e 
0f93 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f96					 
0f96					 
0f96			 
0f96			;		ld a,(input_ptr) 
0f96			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f96			 
0f96			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f96					; init cursor shape if not set by the cin routines 
0f96 21 c7 fb				ld hl, cursor_shape 
0f99 3e ff				ld a, 255 
0f9b 77					ld (hl), a 
0f9c 23					inc hl 
0f9d 3e 00				ld a, 0 
0f9f 77					ld (hl), a 
0fa0			 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fe				ld (input_cur_flash), a 
0fa5 3e 01				ld a, 1 
0fa7 32 62 fe				ld (input_cur_onoff),a 
0faa			 
0faa			;	if DEBUG_INPUT 
0faa			;		push af 
0faa			;		ld a, 'I' 
0faa			;		ld (debug_mark),a 
0faa			;		pop af 
0faa			;		CALLMONITOR 
0faa			;	endif 
0faa			.is1:		; main entry loop 
0faa			 
0faa			 
0faa			 
0faa					; pause 1ms 
0faa			 
0faa 3e 01				ld a, 1 
0fac cd 7a 0c				call aDelayInMS 
0faf			 
0faf					; dec flash counter 
0faf 3a 63 fe				ld a, (input_cur_flash) 
0fb2 3d					dec a 
0fb3 32 63 fe				ld (input_cur_flash), a 
0fb6 fe 00				cp 0 
0fb8 20 0d				jr nz, .nochgstate 
0fba			 
0fba			 
0fba					; change state 
0fba 3a 62 fe				ld a,(input_cur_onoff) 
0fbd ed 44				neg 
0fbf 32 62 fe				ld (input_cur_onoff),a 
0fc2			 
0fc2			 
0fc2					; reset on change of state 
0fc2 3e 0f				ld a, CUR_BLINK_RATE 
0fc4 32 63 fe				ld (input_cur_flash), a 
0fc7			 
0fc7			.nochgstate: 
0fc7					 
0fc7					 
0fc7			 
0fc7					; display cursor  
0fc7			 
0fc7			;		ld hl, (input_start) 
0fc7			;		ld a, (input_cursor) 
0fc7			;		call addatohl 
0fc7			 
0fc7					; get char under cursor and replace with cursor 
0fc7 2a 6c fe		ld hl, (input_ptr) 
0fca			;		ld a, (hl) 
0fca			;		ld (input_under_cursor),a 
0fca			;		ld a, '_' 
0fca			;		ld (hl), a 
0fca			 
0fca					; display string 
0fca			 
0fca ed 5b 6a fe			ld de, (input_start) 
0fce 3a 67 fe				ld a, (input_at_pos) 
0fd1 cd 2b 0d				call str_at_display 
0fd4			;	        call update_display 
0fd4			 
0fd4					; find place to put the cursor 
0fd4			;		add h 
0fd4			;		ld l, display_row_1 
0fd4			;		sub l 
0fd4			; (input_at_pos) 
0fd4					;ld c, a 
0fd4			;		ld a, (input_cursor) 
0fd4			;		ld l, (input_at_pos) 
0fd4			;		;ld b, h 
0fd4			;		add l 
0fd4			;		ld (input_at_cursor),a 
0fd4					;ld l,h 
0fd4			 
0fd4			;		ld h, 0 
0fd4			;		ld l,(input_at_pos) 
0fd4			;		ld a, (input_cursor) 
0fd4			;		call addatohl 
0fd4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd4			;		call subafromhl 
0fd4			;		ld a,l 
0fd4			;		ld (input_at_cursor), a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					ld a, (hardware_diag) 
0fd4					cp 0 
0fd4					jr z, .skip_input_diag 
0fd4			 
0fd4					ld a,(input_at_pos) 
0fd4					ld hl, LFSRSeed 
0fd4					call hexout 
0fd4					ld a, (input_cursor) 
0fd4					ld hl, LFSRSeed+2 
0fd4					call hexout 
0fd4					ld a,(input_at_cursor) 
0fd4					ld hl, LFSRSeed+4 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_onoff) 
0fd4					ld hl, LFSRSeed+6 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_flash) 
0fd4					ld hl, LFSRSeed+8 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_len) 
0fd4					ld hl, LFSRSeed+10 
0fd4					call hexout 
0fd4					ld hl, LFSRSeed+12 
0fd4					ld a, 0 
0fd4					ld (hl),a 
0fd4					ld a, display_row_4 
0fd4					ld de, LFSRSeed 
0fd4					call str_at_display 
0fd4					.skip_input_diag: 
0fd4				endif 
0fd4			 
0fd4					; decide on if we are showing the cursor this time round 
0fd4			 
0fd4 3a 62 fe				ld a, (input_cur_onoff) 
0fd7 fe ff				cp 255 
0fd9 28 13				jr z, .skipcur 
0fdb			 
0fdb			 
0fdb 3a 65 fe				ld a,(input_at_cursor) 
0fde 11 c7 fb				ld de, cursor_shape 
0fe1 cd 2b 0d				call str_at_display 
0fe4			 
0fe4					; save length of current input string 
0fe4 2a 6a fe				ld hl, (input_start) 
0fe7 cd aa 13				call strlenz 
0fea 7d					ld a,l 
0feb 32 5d fe				ld (input_len),a 
0fee			 
0fee			.skipcur: 
0fee			 
0fee cd 3b 0d			        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1 cd 0f 71				call cin    ; _wait 
0ff4			 
0ff4 fe 00				cp 0 
0ff6 ca aa 0f				jp z, .is1 
0ff9			 
0ff9					; get ptr to char to input into 
0ff9			 
0ff9 4f					ld c,a 
0ffa 2a 6a fe				ld hl, (input_start) 
0ffd 3a 58 fe				ld a, (input_cursor) 
1000 cd 4c 0f				call addatohl 
1003 22 6c fe				ld (input_ptr), hl 
1006 79					ld a,c 
1007			 
1007					; replace char under cursor 
1007			 
1007			;		ld hl, (input_ptr) 
1007			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1007			;		ld (hl), a 
1007			 
1007			;	if DEBUG_INPUT 
1007			;		push af 
1007			;		ld a, 'i' 
1007			;		ld (debug_mark),a 
1007			;		pop af 
1007			;		CALLMONITOR 
1007			;	endif 
1007 fe 0e				cp KEY_HOME 
1009 20 0e				jr nz, .iske 
100b			 
100b 3a 67 fe				ld a, (input_at_pos) 
100e 32 65 fe				ld (input_at_cursor),a 
1011 3e 00				ld a, 0 
1013 32 58 fe				ld (input_cursor), a 
1016 c3 aa 0f				jp .is1 
1019					 
1019 fe 0f		.iske:		cp KEY_END 
101b 20 03				jr nz, .isknw 
101d c3 aa 0f				jp .is1 
1020			 
1020 fe 06		.isknw:		cp KEY_NEXTWORD 
1022 20 1b				jr nz, .iskpw 
1024			 
1024 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1027 7e					ld a,(hl)	 
1028 fe 00				cp 0 
102a ca aa 0f				jp z, .is1    ; end of string 
102d fe 20				cp ' ' 
102f ca aa 0f				jp z, .is1    ; end of word 
1032 23					inc hl 
1033 22 6c fe				ld (input_ptr), hl 
1036 3a 65 fe				ld a, (input_at_cursor) 
1039 3c					inc a 
103a 32 65 fe				ld (input_at_cursor), a 
103d 18 e5				jr .isknwm 
103f			 
103f fe 07		.iskpw:		cp KEY_PREVWORD 
1041 20 1b				jr nz, .iskl 
1043			.iskpwm:	 
1043 2a 6c fe				ld hl, (input_ptr) 
1046 7e					ld a,(hl)	 
1047 fe 00				cp 0  
1049 ca aa 0f				jp z, .is1    ; end of string 
104c fe 20				cp ' ' 
104e ca aa 0f				jp z, .is1    ; end of word 
1051 2b					dec hl 
1052 22 6c fe				ld (input_ptr), hl 
1055 3a 65 fe				ld a, (input_at_cursor) 
1058 3d					dec a 
1059 32 65 fe				ld (input_at_cursor), a 
105c 18 e5				jr .iskpwm 
105e			 
105e			 
105e fe 0b		.iskl:		cp KEY_LEFT 
1060 20 27				jr nz, .isk1 
1062			 
1062 3a 58 fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca aa 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 58 fe				ld (input_cursor), a 
106e			 
106e 2a 6c fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 6c fe				ld (input_ptr), hl 
1075					 
1075 3a 65 fe				ld a, (input_at_cursor) 
1078 3d					dec a 
1079 32 65 fe				ld (input_at_cursor), a 
107c			 
107c 3e 01				ld a, 1		; show cursor moving 
107e 32 62 fe				ld (input_cur_onoff),a 
1081 3e 0f				ld a, CUR_BLINK_RATE 
1083 32 63 fe				ld (input_cur_flash), a 
1086			 
1086 c3 aa 0f				jp .is1 
1089			 
1089 fe 0c		.isk1:		cp KEY_RIGHT 
108b 20 2a				jr nz, .isk2 
108d			 
108d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1090 5f					ld e,a 
1091 3a 58 fe				ld a, (input_cursor) 
1094 bb					cp e 
1095 ca aa 0f				jp z, .is1		; at the end of string so dont go right 
1098			 
1098 3c					inc  a 		; TODO check overflow 
1099 32 58 fe				ld (input_cursor), a 
109c			 
109c 3a 65 fe				ld a, (input_at_cursor) 
109f 3c					inc a 
10a0 32 65 fe				ld (input_at_cursor), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 23					inc hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa 3e 01				ld a, 1		; show cursor moving 
10ac 32 62 fe				ld (input_cur_onoff),a 
10af 3e 0f				ld a, CUR_BLINK_RATE 
10b1 32 63 fe				ld (input_cur_flash), a 
10b4			 
10b4 c3 aa 0f				jp .is1 
10b7			 
10b7 fe 05		.isk2:		cp KEY_UP 
10b9			 
10b9 20 26				jr nz, .isk3 
10bb			 
10bb					; swap last command with the current on 
10bb			 
10bb					; move cursor to start of string 
10bb 2a 6a fe				ld hl, (input_start) 
10be 22 6c fe				ld (input_ptr), hl 
10c1			 
10c1 3a 67 fe				ld a, (input_at_pos) 
10c4 32 65 fe				ld (input_at_cursor), a 
10c7			 
10c7 3e 00				ld a, 0 
10c9 32 58 fe				ld (input_cursor), a 
10cc					 
10cc					; swap input and last command buffers 
10cc			 
10cc 21 23 f5				ld hl, os_cli_cmd 
10cf 11 22 f6				ld de, os_last_cmd 
10d2 06 ff				ld b, 255 
10d4 7e			.swap1:		ld a, (hl) 
10d5 4f					ld c,a 
10d6 1a					ld a, (de) 
10d7 77					ld (hl), a 
10d8 79					ld a,c 
10d9 12					ld (de),a 
10da 23					inc hl 
10db 13					inc de 
10dc 10 f6				djnz .swap1 
10de			 
10de			 
10de			 
10de			 
10de			 
10de c3 aa 0f				jp .is1 
10e1			 
10e1 fe 08		.isk3:		cp KEY_BS 
10e3 20 3c				jr nz, .isk4 
10e5			 
10e5 3a 58 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca aa 0f				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 58 fe				ld (input_cursor), a 
10f1			 
10f1					; hl is source 
10f1					; de needs to be source - 1 
10f1			 
10f1			;		ld a, 0 
10f1			;		dec hl 
10f1			;		ld (hl), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8					; shift all data 
10f8			 
10f8 e5					push hl 
10f9 23					inc hl 
10fa d1					pop de 
10fb 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fe 4f					ld c,a 
10ff 06 00				ld b,0 
1101 ed b0				ldir  
1103			 
1103			 
1103			 
1103			 
1103 3a 65 fe				ld a, (input_at_cursor) 
1106 3d					dec a 
1107 32 65 fe				ld (input_at_cursor), a 
110a			 
110a			 
110a 3e 01				ld a, 1		; show cursor moving 
110c 32 62 fe				ld (input_cur_onoff),a 
110f 3e 0f				ld a, CUR_BLINK_RATE 
1111 32 63 fe				ld (input_cur_flash), a 
1114			 
1114					; remove char 
1114 3a 65 fe				ld a, (input_at_cursor) 
1117 3c					inc a 
1118 11 a2 11				ld de,.iblank 
111b cd 2b 0d				call str_at_display 
111e			 
111e c3 aa 0f				jp .is1 
1121			 
1121 fe 0d		.isk4:		cp KEY_CR 
1123 28 6c				jr z, .endinput 
1125			 
1125					; else add the key press to the end 
1125			 
1125 4f					ld c, a			; save key pressed 
1126			 
1126 7e					ld a,(hl)		; get what is currently under char 
1127			 
1127 fe 00				cp 0			; we are at the end of the string 
1129 20 2f				jr nz, .onchar 
112b					 
112b					; add a char to the end of the string 
112b				 
112b 71					ld (hl),c 
112c 23					inc hl 
112d			;		ld a,' ' 
112d			;		ld (hl),a 
112d			;		inc hl 
112d 3e 00				ld a,0 
112f 77					ld (hl),a 
1130 2b					dec hl 
1131			 
1131 3a 58 fe				ld a, (input_cursor) 
1134 3c					inc a				; TODO check max string length and scroll  
1135 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1138							 
1138 3a 65 fe				ld a, (input_at_cursor) 
113b 3c					inc a 
113c 32 65 fe				ld (input_at_cursor), a 
113f			 
113f 2a 6c fe				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 6c fe				ld (input_ptr), hl 
1146			 
1146 2a 6c fe				ld hl, (input_ptr) 
1149 23					inc hl 
114a 22 6c fe				ld (input_ptr), hl 
114d			;	if DEBUG_INPUT 
114d			;		push af 
114d			;		ld a, '+' 
114d			;		ld (debug_mark),a 
114d			;		pop af 
114d			;		CALLMONITOR 
114d			;	endif 
114d 3e 01				ld a, 1		; show cursor moving 
114f 32 62 fe				ld (input_cur_onoff),a 
1152 3e 0f				ld a, CUR_BLINK_RATE 
1154 32 63 fe				ld (input_cur_flash), a 
1157 c3 aa 0f				jp .is1 
115a					 
115a			 
115a			 
115a					; if on a char then insert 
115a			.onchar: 
115a			 
115a					; TODO over flow check: make sure insert does not blow out buffer 
115a			 
115a					; need to do some maths to use lddr 
115a			 
115a e5					push hl   ; save char pos 
115b c5					push bc 
115c			 
115c 2a 6a fe				ld hl, (input_start) 
115f 3a 5d fe				ld a, (input_len) 
1162 cd 4c 0f				call addatohl  		; end of string 
1165 23					inc hl 
1166 23					inc hl		; past zero term 
1167 e5					push hl 
1168 23					inc hl 
1169 e5					push hl  
116a			 
116a								; start and end of lddr set, now how much to move? 
116a			 
116a							 
116a 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116d 47					ld b,a 
116e 3a 5d fe				ld a,(input_len) 
1171 5f					ld e,a 
1172 90					sub b 
1173 3c					inc a		;?? 
1174 3c					inc a		;?? 
1175 3c					inc a		;?? 
1176			 
1176 06 00				ld b,0 
1178 4f					ld c,a 
1179			 
1179				if DEBUG_INPUT 
1179					push af 
1179					ld a, 'i' 
1179					ld (debug_mark),a 
1179					pop af 
1179			;		CALLMONITOR 
1179				endif 
1179 d1					pop de 
117a e1					pop hl 
117b				if DEBUG_INPUT 
117b					push af 
117b					ld a, 'I' 
117b					ld (debug_mark),a 
117b					pop af 
117b			;		CALLMONITOR 
117b				endif 
117b ed b8				lddr 
117d				 
117d			 
117d			 
117d					; TODO have a key for insert/overwrite mode???? 
117d c1					pop bc 
117e e1					pop hl 
117f 71					ld (hl), c		; otherwise overwrite current char 
1180					 
1180			 
1180			 
1180			 
1180 3a 58 fe				ld a, (input_cursor) 
1183 3c					inc  a 		; TODO check overflow 
1184 32 58 fe				ld (input_cursor), a 
1187			 
1187 3a 65 fe				ld a, (input_at_cursor) 
118a 3c					inc a 
118b 32 65 fe				ld (input_at_cursor), a 
118e			 
118e c3 aa 0f				jp .is1 
1191			 
1191			.endinput:	; TODO look for end of string 
1191			 
1191					; add trailing space for end of token 
1191			 
1191 2a 6a fe				ld hl, (input_start) 
1194 3a 5d fe				ld a,(input_len) 
1197 cd 4c 0f				call addatohl 
119a 3e 20				ld a, ' ' 
119c 77					ld (hl),a 
119d					; TODO eof of parse marker 
119d			 
119d 23					inc hl 
119e 3e 00				ld a, 0 
11a0 77					ld (hl),a 
11a1			 
11a1			 
11a1 c9					ret 
11a2			 
11a2 .. 00		.iblank: db " ",0 
11a4			 
11a4			 
11a4 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11a7 22 6a fe				ld (input_start), hl 
11aa 3e 01				ld a,1			; add cursor 
11ac 77					ld (hl),a 
11ad 23					inc hl 
11ae 3e 00				ld a,0 
11b0 77					ld (hl),a 
11b1 22 6c fe				ld (input_ptr), hl 
11b4 7a					ld a,d 
11b5 32 69 fe				ld (input_size), a 
11b8 3e 00				ld a,0 
11ba 32 58 fe				ld (input_cursor),a 
11bd			.instr1:	 
11bd			 
11bd					; TODO do block cursor 
11bd					; TODO switch cursor depending on the modifer key 
11bd			 
11bd					; update cursor shape change on key hold 
11bd			 
11bd 2a 6c fe				ld hl, (input_ptr) 
11c0 2b					dec hl 
11c1 3a c7 fb				ld a,(cursor_shape) 
11c4 77					ld (hl), a 
11c5			 
11c5					; display entered text 
11c5 3a 67 fe				ld a,(input_at_pos) 
11c8 cd d3 6e		            	CALL fLCD_Pos       ;Position cursor to location in A 
11cb ed 5b 6a fe	            	LD   de, (input_start) 
11cf cd f5 6e		            	CALL fLCD_Str       ;Display string pointed to by DE 
11d2			 
11d2 cd 0f 71				call cin 
11d5 fe 00				cp 0 
11d7 28 e4				jr z, .instr1 
11d9			 
11d9					; proecess keyboard controls first 
11d9			 
11d9 2a 6c fe				ld hl,(input_ptr) 
11dc			 
11dc fe 0d				cp KEY_CR	 ; pressing enter ends input 
11de 28 5a				jr z, .instrcr 
11e0			 
11e0 fe 08				cp KEY_BS 	; back space 
11e2 20 0f				jr nz, .instr2 
11e4					; process back space 
11e4			 
11e4					; TODO stop back space if at start of string 
11e4 2b					dec hl 
11e5 2b					dec hl ; to over write cursor 
11e6 3a c7 fb				ld a,(cursor_shape) 
11e9					;ld a,0 
11e9 77					ld (hl),a 
11ea 23					inc hl 
11eb 3e 20				ld a," " 
11ed 77					ld (hl),a 
11ee 22 6c fe				ld (input_ptr),hl 
11f1					 
11f1			 
11f1 18 ca				jr .instr1 
11f3			 
11f3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f5 20 06				jr nz, .instr3 
11f7 2b					dec hl 
11f8 22 6c fe				ld (input_ptr),hl 
11fb 18 c0				jr .instr1 
11fd				 
11fd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ff 20 06				jr nz, .instr4 
1201 23					inc hl 
1202 22 6c fe				ld (input_ptr),hl 
1205 18 b6				jr .instr1 
1207			 
1207 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1209 20 06				jr nz, .instr5 
120b 2b					dec hl 
120c 22 6c fe				ld (input_ptr),hl 
120f 18 ac				jr .instr1 
1211			 
1211 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1213 20 06				jr nz, .instr6 
1215 2b					dec hl 
1216 22 6c fe				ld (input_ptr),hl 
1219 18 a2				jr .instr1 
121b fe 05		.instr6:        cp KEY_UP      ; recall last command 
121d 20 0b				jr nz, .instrnew 
121f			 
121f 21 fc f1			ld hl, scratch 
1222 11 22 f6			ld de, os_last_cmd 
1225 cd 43 12			call strcpy 
1228 18 93				jr .instr1 
122a			 
122a			 
122a			.instrnew:	; no special key pressed to see if we have room to store it 
122a			 
122a					; TODO do string size test 
122a			 
122a 2b					dec hl ; to over write cursor 
122b 77					ld (hl),a 
122c 23					inc hl 
122d 3a c7 fb				ld a,(cursor_shape) 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235			 
1235 22 6c fe				ld (input_ptr),hl 
1238					 
1238 18 83				jr .instr1 
123a 2b			.instrcr:	dec hl		; remove cursor 
123b 3e 20				ld a,' '	; TODO add a trailing space for safety 
123d 77					ld (hl),a 
123e 23					inc hl 
123f 3e 00				ld a,0 
1241 77					ld (hl),a 
1242			 
1242			 
1242					; if at end of line scroll up    
1242					; TODO detecting only end of line 4 for scroll up  
1242			 
1242					;ld   
1242			 
1242 c9					ret 
1243			 
1243			 
1243			; strcpy hl = dest, de source 
1243			 
1243 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1244 b7			            OR   A              ;Null terminator? 
1245 c8			            RET  Z              ;Yes, so finished 
1246 1a					ld a,(de) 
1247 77					ld (hl),a 
1248 13			            INC  DE             ;Point to next character 
1249 23					inc hl 
124a 18 f7		            JR   strcpy       ;Repeat 
124c c9					ret 
124d			 
124d			 
124d			; TODO string_at  
124d			; pass string which starts with lcd offset address and then null term string 
124d			 
124d			; TODO string to dec 
124d			; TODO string to hex 
124d			; TODO byte to string hex 
124d			; TODO byte to string dec 
124d			 
124d			 
124d			 
124d			; from z80uartmonitor 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124d			; pass hl for where to put the text 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d c5			hexout:	PUSH BC 
124e f5					PUSH AF 
124f 47					LD B, A 
1250					; Upper nybble 
1250 cb 3f				SRL A 
1252 cb 3f				SRL A 
1254 cb 3f				SRL A 
1256 cb 3f				SRL A 
1258 cd 68 12				CALL tohex 
125b 77					ld (hl),a 
125c 23					inc hl	 
125d					 
125d					; Lower nybble 
125d 78					LD A, B 
125e e6 0f				AND 0FH 
1260 cd 68 12				CALL tohex 
1263 77					ld (hl),a 
1264 23					inc hl	 
1265					 
1265 f1					POP AF 
1266 c1					POP BC 
1267 c9					RET 
1268					 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			tohex: 
1268 e5					PUSH HL 
1269 d5					PUSH DE 
126a 16 00				LD D, 0 
126c 5f					LD E, A 
126d 21 75 12				LD HL, .DATA 
1270 19					ADD HL, DE 
1271 7e					LD A, (HL) 
1272 d1					POP DE 
1273 e1					POP HL 
1274 c9					RET 
1275			 
1275			.DATA: 
1275 30					DEFB	30h	; 0 
1276 31					DEFB	31h	; 1 
1277 32					DEFB	32h	; 2 
1278 33					DEFB	33h	; 3 
1279 34					DEFB	34h	; 4 
127a 35					DEFB	35h	; 5 
127b 36					DEFB	36h	; 6 
127c 37					DEFB	37h	; 7 
127d 38					DEFB	38h	; 8 
127e 39					DEFB	39h	; 9 
127f 41					DEFB	41h	; A 
1280 42					DEFB	42h	; B 
1281 43					DEFB	43h	; C 
1282 44					DEFB	44h	; D 
1283 45					DEFB	45h	; E 
1284 46					DEFB	46h	; F 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1285			;;    subtract $30, if result > 9 then subtract $7 more 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			atohex: 
1285 d6 30				SUB $30 
1287 fe 0a				CP 10 
1289 f8					RET M		; If result negative it was 0-9 so we're done 
128a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
128c c9					RET		 
128d			 
128d			 
128d			 
128d			 
128d			; Get 2 ASCII characters as hex byte from pointer in hl 
128d			 
128d			BYTERD: 
128d 16 00			LD	D,00h		;Set up 
128f cd 97 12			CALL	HEXCON		;Get byte and convert to hex 
1292 87				ADD	A,A		;First nibble so 
1293 87				ADD	A,A		;multiply by 16 
1294 87				ADD	A,A		; 
1295 87				ADD	A,A		; 
1296 57				LD	D,A		;Save hi nibble in D 
1297			HEXCON: 
1297 7e				ld a, (hl)		;Get next chr 
1298 23				inc hl 
1299 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
129b fe 0a			CP	00Ah		;Is it 0-9 ? 
129d 38 02			JR	C,NALPHA	;If so miss next bit 
129f d6 07			SUB	007h		;Else convert alpha 
12a1			NALPHA: 
12a1 b2				OR	D		;Add hi nibble back 
12a2 c9				RET			; 
12a3			 
12a3			 
12a3			; 
12a3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a3			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a3			; characters (0-9a-f) are accepted. 
12a3			; 
12a3			;get_word        push    af 
12a3			;                call    get_byte        ; Get the upper byte 
12a3			;                ld      h, a 
12a3			;                call    get_byte        ; Get the lower byte 
12a3			;                ld      l, a 
12a3			;                pop     af 
12a3			;                ret 
12a3			; 
12a3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a3			; the routine get_nibble is used only valid characters are accepted - the  
12a3			; input routine only accepts characters 0-9a-f. 
12a3			; 
12a3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a4 7e					ld a,(hl) 
12a5 23					inc hl 
12a6 cd cb 12		                call    nibble2val      ; Get upper nibble 
12a9 cb 07		                rlc     a 
12ab cb 07		                rlc     a 
12ad cb 07		                rlc     a 
12af cb 07		                rlc     a 
12b1 47			                ld      b, a            ; Save upper four bits 
12b2 7e					ld a,(hl) 
12b3 cd cb 12		                call    nibble2val      ; Get lower nibble 
12b6 b0			                or      b               ; Combine both nibbles 
12b7 c1			                pop     bc              ; Restore B (and C) 
12b8 c9			                ret 
12b9			; 
12b9			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b9			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b9			; to the serial line interface. The lower 4 bits of A contain the value of  
12b9			; that particular digit. 
12b9			; 
12b9			;get_nibble      ld a,(hl)           ; Read a character 
12b9			;                call    to_upper        ; Convert to upper case 
12b9			;                call    is_hex          ; Was it a hex digit? 
12b9			;                jr      nc, get_nibble  ; No, get another character 
12b9			 ;               call    nibble2val      ; Convert nibble to value 
12b9			 ;               call    print_nibble 
12b9			 ;               ret 
12b9			; 
12b9			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b9			; A valid hexadecimal digit is denoted by a set C flag. 
12b9			; 
12b9			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b9			;                ret     nc              ; Yes 
12b9			;                cp      '0'             ; Less than '0'? 
12b9			;                jr      nc, is_hex_1    ; No, continue 
12b9			;                ccf                     ; Complement carry (i.e. clear it) 
12b9			;                ret 
12b9			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b9			;                ret     c               ; Yes 
12b9			;                cp      'A'             ; Less than 'A'? 
12b9			;                jr      nc, is_hex_2    ; No, continue 
12b9			;                ccf                     ; Yes - clear carry and return 
12b9			;                ret 
12b9			;is_hex_2        scf                     ; Set carry 
12b9			;                ret 
12b9			; 
12b9			; Convert a single character contained in A to upper case: 
12b9			; 
12b9 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12bb d8			                ret     c 
12bc fe 7b		                cp      'z' + 1         ; > 'z'? 
12be d0			                ret     nc              ; Nothing to do, either 
12bf e6 5f		                and     $5f             ; Convert to upper case 
12c1 c9			                ret 
12c2			 
12c2			 
12c2			to_lower: 
12c2			 
12c2			   ; if char is in [A-Z] make it lower case 
12c2			 
12c2			   ; enter : a = char 
12c2			   ; exit  : a = lower case char 
12c2			   ; uses  : af 
12c2			 
12c2 fe 41		   cp 'A' 
12c4 d8			   ret c 
12c5			    
12c5 fe 5b		   cp 'Z'+1 
12c7 d0			   ret nc 
12c8			    
12c8 f6 20		   or $20 
12ca c9			   ret 
12cb			 
12cb			; 
12cb			; Expects a hexadecimal digit (upper case!) in A and returns the 
12cb			; corresponding value in A. 
12cb			; 
12cb fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12cd 38 02		                jr      c, nibble2val_1 ; Yes 
12cf d6 07		                sub     7               ; Adjust for A-F 
12d1 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d3 e6 0f		                and     $f              ; Only return lower 4 bits 
12d5 c9			                ret 
12d6			; 
12d6			; Print_nibble prints a single hex nibble which is contained in the lower  
12d6			; four bits of A: 
12d6			; 
12d6			;print_nibble    push    af              ; We won't destroy the contents of A 
12d6			;                and     $f              ; Just in case... 
12d6			;                add     a, '0'             ; If we have a digit we are done here. 
12d6			;                cp      '9' + 1         ; Is the result > 9? 
12d6			;                jr      c, print_nibble_1 
12d6			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d6			;print_nibble_1  call    putc            ; Print the nibble and 
12d6			;                pop     af              ; restore the original value of A 
12d6			;                ret 
12d6			;; 
12d6			;; Send a CR/LF pair: 
12d6			; 
12d6			;crlf            push    af 
12d6			;                ld      a, cr 
12d6			;                call    putc 
12d6			;                ld      a, lf 
12d6			;                call    putc 
12d6			;                pop     af 
12d6			;                ret 
12d6			; 
12d6			; Print_word prints the four hex digits of a word to the serial line. The  
12d6			; word is expected to be in HL. 
12d6			; 
12d6			;print_word      push    hl 
12d6			;                push    af 
12d6			;                ld      a, h 
12d6			;                call    print_byte 
12d6			;                ld      a, l 
12d6			;                call    print_byte 
12d6			;                pop     af 
12d6			;                pop     hl 
12d6			;                ret 
12d6			; 
12d6			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d6			; The byte to be printed is expected to be in A. 
12d6			; 
12d6			;print_byte      push    af              ; Save the contents of the registers 
12d6			;                push    bc 
12d6			;                ld      b, a 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                call    print_nibble    ; Print high nibble 
12d6			;                ld      a, b 
12d6			;                call    print_nibble    ; Print low nibble 
12d6			;                pop     bc              ; Restore original register contents 
12d6			;                pop     af 
12d6			;                ret 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			fourehexhl:  
12d6 7e				ld a,(hl) 
12d7 cd 85 12			call atohex 
12da cb 3f				SRL A 
12dc cb 3f				SRL A 
12de cb 3f				SRL A 
12e0 cb 3f				SRL A 
12e2 47				ld b, a 
12e3 23				inc hl 
12e4 7e				ld a,(hl) 
12e5 23				inc hl 
12e6 cd 85 12			call atohex 
12e9 80				add b 
12ea 57				ld d,a 
12eb 7e				ld a,(hl) 
12ec cd 85 12			call atohex 
12ef cb 3f				SRL A 
12f1 cb 3f				SRL A 
12f3 cb 3f				SRL A 
12f5 cb 3f				SRL A 
12f7 47				ld b, a 
12f8 23				inc hl 
12f9 7e				ld a,(hl) 
12fa 23				inc hl 
12fb cd 85 12			call atohex 
12fe 80				add b 
12ff 5f				ld e, a 
1300 d5				push de 
1301 e1				pop hl 
1302 c9				ret 
1303			 
1303			; pass hl. returns z set if the byte at hl is a digit 
1303			;isdigithl:  
1303			;	push bc 
1303			;	ld a,(hl) 
1303			;	cp ':' 
1303			;	jr nc, .isdf 		; > 
1303			;	cp '0' 
1303			;	jr c, .isdf		; < 
1303			; 
1303			;	; TODO find a better way to set z 
1303			; 
1303			;	ld b,a 
1303			;	cp b 
1303			;	pop bc 
1303			;	ret 
1303			; 
1303			;.isdf:	; not digit so clear z 
1303			; 
1303			;	; TODO find a better way to unset z 
1303			; 
1303			;	ld b,a 
1303			;	inc b 
1303			;	cp b 
1303			; 
1303			;	pop bc 
1303			;	ret 
1303				 
1303				 
1303			 
1303			 
1303			; pass hl as the four byte address to load 
1303			 
1303			get_word_hl:  
1303 e5				push hl 
1304 cd a3 12			call get_byte 
1307				 
1307 47				ld b, a 
1308			 
1308 e1				pop hl 
1309 23				inc hl 
130a 23				inc hl 
130b			 
130b			; TODO not able to handle a-f  
130b 7e				ld a,(hl) 
130c			;	;cp ':' 
130c			;	cp 'g' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp 'G' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp '0' 
130c			;	jr c, .single_byte_hl		; < 
130c			 
130c				;call isdigithl 
130c fe 00			cp 0 
130e 28 06			jr z, .single_byte_hl 
1310			 
1310			.getwhln:   ; hex word so get next byte 
1310			 
1310 cd a3 12			call get_byte 
1313 6f				ld l, a 
1314 60				ld h,b 
1315 c9				ret 
1316 68			.single_byte_hl:   ld l,b 
1317 26 00				ld h,0 
1319 c9					ret 
131a			 
131a			 
131a			 
131a			 
131a 21 7e 1c			ld hl,asc+1 
131d			;	ld a, (hl) 
131d			;	call nibble2val 
131d cd a3 12			call get_byte 
1320			 
1320			;	call fourehexhl 
1320 32 30 f2			ld (scratch+52),a 
1323				 
1323 21 2e f2			ld hl,scratch+50 
1326 22 1f f5			ld (os_cur_ptr),hl 
1329			 
1329 c9				ret 
132a			 
132a			 
132a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
132a			 
132a			; Decimal Unsigned Version 
132a			 
132a			;Number in a to decimal ASCII 
132a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
132a			;Example: display a=56 as "056" 
132a			;input: a = number 
132a			;Output: a=0,value of a in the screen 
132a			;destroys af,bc (don't know about hl and de) 
132a			DispAToASCII: 
132a 0e 9c			ld	c,-100 
132c cd 36 13			call	.Na1 
132f 0e f6			ld	c,-10 
1331 cd 36 13			call	.Na1 
1334 0e ff			ld	c,-1 
1336 06 2f		.Na1:	ld	b,'0'-1 
1338 04			.Na2:	inc	b 
1339 81				add	a,c 
133a 38 fc			jr	c,.Na2 
133c 91				sub	c		;works as add 100/10/1 
133d f5				push af		;safer than ld c,a 
133e 78				ld	a,b		;char is in b 
133f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133f f1				pop af		;safer than ld a,c 
1340 c9				ret 
1341			 
1341			; Decimal Signed Version 
1341			 
1341			; DispA 
1341			; -------------------------------------------------------------- 
1341			; Converts a signed integer value to a zero-terminated ASCII 
1341			; string representative of that value (using radix 10). 
1341			; -------------------------------------------------------------- 
1341			; INPUTS: 
1341			;     HL     Value to convert (two's complement integer). 
1341			;     DE     Base address of string destination. (pointer). 
1341			; -------------------------------------------------------------- 
1341			; OUTPUTS: 
1341			;     None 
1341			; -------------------------------------------------------------- 
1341			; REGISTERS/MEMORY DESTROYED 
1341			; AF HL 
1341			; -------------------------------------------------------------- 
1341			 
1341			;DispHLToASCII: 
1341			;   push    de 
1341			;   push    bc 
1341			; 
1341			;; Detect sign of HL. 
1341			;    bit    7, h 
1341			;    jr     z, ._DoConvert 
1341			; 
1341			;; HL is negative. Output '-' to string and negate HL. 
1341			;    ld     a, '-' 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			; 
1341			;; Negate HL (using two's complement) 
1341			;    xor    a 
1341			;    sub    l 
1341			;    ld     l, a 
1341			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1341			;    sbc    a, h 
1341			;    ld     h, a 
1341			; 
1341			;; Convert HL to digit characters 
1341			;._DoConvert: 
1341			;    ld     b, 0     ; B will count character length of number 
1341			;-   ld     a, 10 
1341			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1341			;    push   af 
1341			;    inc    b 
1341			;    ld     a, h 
1341			;    or     l 
1341			;    jr     nz, - 
1341			; 
1341			;; Retrieve digits from stack 
1341			;-   pop    af 
1341			;    or     $30 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			;    djnz   - 
1341			; 
1341			;; Terminate string with NULL 
1341			;    xor    a 
1341			;    ld     (de), a 
1341			; 
1341			;    pop    bc 
1341			;    pop    de 
1341			;    ret 
1341			 
1341			;Comments 
1341			; 
1341			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1341			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1341			;    Note that the output string will not be fixed-width. 
1341			; 
1341			;Example Usage 
1341			; 
1341			;    ld    hl, -1004 
1341			;    ld    de, OP1 
1341			;    call  DispA 
1341			;    ld    hl, OP1 
1341			;    syscall  PutS 
1341			 
1341			 
1341			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1341			 
1341			 
1341			;Converts an ASCII string to an unsigned 16-bit integer 
1341			;Quits when it reaches a non-decimal digit 
1341			 
1341			string_to_uint16: 
1341			atoui_16: 
1341			;Input: 
1341			;     DE points to the string 
1341			;Outputs: 
1341			;     HL is the result 
1341			;     A is the 8-bit value of the number 
1341			;     DE points to the byte after the number 
1341			;Destroys: 
1341			;     BC 
1341			;       if the string is non-empty, BC is HL/10 
1341			;Size:  24 bytes 
1341			;Speed: 42+d(104+{0,9}) 
1341			;       d is the number of digits in the number 
1341			;       max is 640 cycles for a 5 digit number 
1341			;Assuming no leading zeros: 
1341			;1 digit:  146cc 
1341			;2 digit:  250cc 
1341			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1341			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1341			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1341			;avg: 544.81158447265625cc (544+13297/16384) 
1341			;=============================================================== 
1341 21 00 00		  ld hl,0 
1344			.u16a: 
1344 1a			  ld a,(de) 
1345 d6 30		  sub 30h 
1347 fe 0a		  cp 10 
1349 d0			  ret nc 
134a 13			  inc de 
134b 44			  ld b,h 
134c 4d			  ld c,l 
134d 29			  add hl,hl 
134e 29			  add hl,hl 
134f 09			  add hl,bc 
1350 29			  add hl,hl 
1351 85			  add a,l 
1352 6f			  ld l,a 
1353 30 ef		  jr nc,.u16a 
1355 24			  inc h 
1356 c3 44 13		  jp .u16a 
1359			 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1359			 
1359			;written by Zeda 
1359			;Converts a 16-bit unsigned integer to an ASCII string. 
1359			 
1359			uitoa_16: 
1359			;Input: 
1359			;   DE is the number to convert 
1359			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1359			;Output: 
1359			;   HL points to the null-terminated ASCII string 
1359			;      NOTE: This isn't necessarily the same as the input HL. 
1359 d5			  push de 
135a c5			  push bc 
135b f5			  push af 
135c eb			  ex de,hl 
135d			 
135d 01 f0 d8		  ld bc,-10000 
1360 3e 2f		  ld a,'0'-1 
1362 3c			  inc a 
1363 09			  add hl,bc  
1364 38 fc		   jr c,$-2 
1366 12			  ld (de),a 
1367 13			  inc de 
1368			 
1368 01 e8 03		  ld bc,1000 
136b 3e 3a		  ld a,'9'+1 
136d 3d			  dec a  
136e 09			  add hl,bc  
136f 30 fc		   jr nc,$-2 
1371 12			  ld (de),a 
1372 13			  inc de 
1373			 
1373 01 9c ff		  ld bc,-100 
1376 3e 2f		  ld a,'0'-1 
1378 3c			  inc a  
1379 09			  add hl,bc  
137a 38 fc		   jr c,$-2 
137c 12			  ld (de),a 
137d 13			  inc de 
137e			 
137e 7d			  ld a,l 
137f 26 3a		  ld h,'9'+1 
1381 25			  dec h  
1382 c6 0a		  add a,10  
1384 30 fb		   jr nc,$-3 
1386 c6 30		  add a,'0' 
1388 eb			  ex de,hl 
1389 72			  ld (hl),d 
138a 23			  inc hl 
138b 77			  ld (hl),a 
138c 23			  inc hl 
138d 36 00		  ld (hl),0 
138f			 
138f			;Now strip the leading zeros 
138f 0e fa		  ld c,-6 
1391 09			  add hl,bc 
1392 3e 30		  ld a,'0' 
1394 23			  inc hl  
1395 be			  cp (hl)  
1396 28 fc		  jr z,$-2 
1398			 
1398			;Make sure that the string is non-empty! 
1398 7e			  ld a,(hl) 
1399 b7			  or a 
139a 20 01		  jr nz,.atoub 
139c 2b			  dec hl 
139d			.atoub: 
139d			 
139d f1			  pop af 
139e c1			  pop bc 
139f d1			  pop de 
13a0 c9			  ret 
13a1			 
13a1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13a1			 
13a1			toUpper: 
13a1			;A is the char. 
13a1			;If A is a lowercase letter, this sets it to the matching uppercase 
13a1			;18cc or 30cc or 41cc 
13a1			;avg: 26.75cc 
13a1 fe 61		  cp 'a' 
13a3 d8			  ret c 
13a4 fe 7b		  cp 'z'+1 
13a6 d0			  ret nc 
13a7 d6 20		  sub 'a'-'A' 
13a9 c9			  ret 
13aa			 
13aa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13aa			 
13aa			; String Length 
13aa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13aa			 
13aa			; Get the length of the null-terminated string starting at $8000 hl 
13aa			;    LD     HL, $8000 
13aa			 
13aa			strlenz: 
13aa			 
13aa af			    XOR    A               ; Zero is the value we are looking for. 
13ab 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13ac 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13ad			                           ; 65, 536 bytes (the entire addressable memory space). 
13ad ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13af			 
13af			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13af 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13b0 6f			    LD     L, A             ; number of bytes 
13b1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b3 2b			    DEC    HL              ; Compensate for null. 
13b4 c9				ret 
13b5			 
13b5			; Get the length of the A terminated string starting at $8000 hl 
13b5			;    LD     HL, $8000 
13b5			 
13b5			strlent: 
13b5			 
13b5			                  ; A is the value we are looking for. 
13b5 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b7 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b9			                           ; 65, 536 bytes (the entire addressable memory space). 
13b9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13bb			 
13bb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13bb 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13bd 2e 00		    LD     L, 0             ; number of bytes 
13bf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13c1 2b			    DEC    HL              ; Compensate for null. 
13c2 c9				ret 
13c3			 
13c3			 
13c3			;Comparing Strings 
13c3			 
13c3			;IN    HL     Address of string1. 
13c3			;      DE     Address of string2. 
13c3			 
13c3			; doc given but wrong??? 
13c3			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c3			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c3			; tested 
13c3			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c3			 
13c3			strcmp_old: 
13c3 e5			    PUSH   HL 
13c4 d5			    PUSH   DE 
13c5			 
13c5 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c6 be			    CP     (HL)            ; (want to minimize work). 
13c7 38 01		    JR     C, Str1IsBigger 
13c9 7e			    LD     A, (HL) 
13ca			 
13ca			Str1IsBigger: 
13ca 4f			    LD     C, A             ; Put length in BC 
13cb 06 00		    LD     B, 0 
13cd 13			    INC    DE              ; Increment pointers to meat of string. 
13ce 23			    INC    HL 
13cf			 
13cf			CmpLoop: 
13cf 1a			    LD     A, (DE)          ; Compare bytes. 
13d0 ed a1		    CPI 
13d2 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d4 13			    INC    DE              ; Update pointer. 
13d5 ea cf 13		    JP     PE, CmpLoop 
13d8			 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13db be			    CP     (HL) 
13dc c9			    RET 
13dd			 
13dd			NoMatch: 
13dd 2b			    DEC    HL 
13de be			    CP     (HL)            ; Compare again to affect carry. 
13df d1			    POP    DE 
13e0 e1			    POP    HL 
13e1 c9			    RET 
13e2			 
13e2			;; test strmp 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr z, .z1 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z1: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr z, .z2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr c, .c1 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c1: 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr c, .c2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;	NEXTW 
13e2			;.str1:   db "string1",0 
13e2			;.str2:   db "string2",0 
13e2			 
13e2			; only care about direct match or not 
13e2			; hl and de strings 
13e2			; zero set if the same 
13e2			 
13e2			strcmp: 
13e2 1a				ld a, (de) 
13e3 be				cp (hl) 
13e4 28 02			jr z, .ssame 
13e6 b7				or a 
13e7 c9				ret 
13e8			 
13e8			.ssame:  
13e8 fe 00			cp 0 
13ea c8				ret z 
13eb			 
13eb 23				inc hl 
13ec 13				inc de 
13ed 18 f3			jr strcmp 
13ef				 
13ef				 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			; eof 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
# End of file firmware_strings.asm
13ef			include "firmware_memory.asm"   ; malloc and free  
13ef			 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			.mallocsize: db "Wants malloc >256",0 
13ef			.mallocasize: db "MALLOC gives >256",0 
13ef			.malloczero: db "MALLOC gives zero",0 
13ef			 
13ef			malloc_guard_zerolen: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef				ld de, 0 
13ef			        call cmp16 
13ef				jr nz, .lowalloz 
13ef			 
13ef				push hl 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .malloczero 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef			.lowalloz: 
13ef			 
13ef			 
13ef				pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_entry: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowalloc 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocsize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdone 
13ef			.lowalloc: 
13ef			 
13ef			 
13ef				pop hl 
13ef			.lowdone:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_exit: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowallocx 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocasize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdonex 
13ef			.lowallocx: 
13ef			 
13ef				pop hl 
13ef			.lowdonex:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			endif 
13ef			 
13ef			if MALLOC_2 
13ef			; Z80 Malloc and Free Functions 
13ef			 
13ef			; Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc: 
13ef				 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_entry 
13ef			endif 
13ef			 
13ef			 
13ef			 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "mal" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of size into A 
13ef			    or h               ; Check if size is zero 
13ef			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ef			 
13ef			    ; Allocate memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma1" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    call malloc_internal ; Call internal malloc function 
13ef			    pop af             ; Restore AF register 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret                ; Return 
13ef			 
13ef			; Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free: 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of pointer into A 
13ef			    or h               ; Check if pointer is NULL 
13ef			    jp z, free_exit    ; If pointer is NULL, exit 
13ef			 
13ef			    ; Free memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef			    call free_internal  ; Call internal free function 
13ef			    pop af             ; Restore AF register 
13ef			    ret                ; Return 
13ef			 
13ef			; Internal Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc_internal: 
13ef			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to requested size 
13ef			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			 
13ef			    ; Search for free memory block 
13ef			    ld de, (heap_end)  ; Load end of heap into DE 
13ef			    ld bc, 0           ; Initialize counter 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			malloc_search_loop: 
13ef			    ; Check if current block is free 
13ef			    ld a, (hl)         ; Load current block's status (free or used) 
13ef			    cp 0               ; Compare with zero (free) 
13ef			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ef			 
13ef			    ; Check if current block is large enough 
13ef			    ld a, (hl+1)       ; Load high byte of block size 
13ef			    cp l               ; Compare with low byte of requested size 
13ef			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ef			 
13ef			    ld a, (hl+2)       ; Load low byte of block size 
13ef			    cp h               ; Compare with high byte of requested size 
13ef			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ef			 
13ef			    ; Mark block as used 
13ef			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ef			 
13ef			    ; Calculate remaining space in block 
13ef			    ld bc, 0           ; Clear BC 
13ef			    add hl, bc         ; Increment HL to point to start of data block 
13ef			    add hl, de         ; HL = HL + DE (total size) 
13ef			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to start of data block 
13ef			 
13ef			    ; Save pointer to allocated block in HL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma5" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			malloc_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3           ; Size of management overhead 
13ef			    add hl, bc         ; Move to the next block 
13ef			    inc de             ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e            ; Load low byte of heap end address 
13ef			    cp (hl)            ; Compare with low byte of current address 
13ef			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ef			    ld a, d            ; Load high byte of heap end address 
13ef			    cp 0               ; Check if it's zero (end of memory) 
13ef			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, allocation failed 
13ef			    xor a              ; Set result to NULL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma6" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			malloc_exit: 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma7" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			; Internal Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free_internal: 
13ef			    ld de, (heap_start) ; Load start of heap into DE 
13ef			    ld bc, 0            ; Initialize counter 
13ef			 
13ef			free_search_loop: 
13ef			    ; Check if current block contains the pointer 
13ef			    ld a, l             ; Load low byte of pointer 
13ef			    cp (hl+1)           ; Compare with high byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			    ld a, h             ; Load high byte of pointer 
13ef			    cp (hl+2)           ; Compare with low byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			 
13ef			    ; Mark block as free 
13ef			    ld (hl), 0          ; Set status byte to indicate free block 
13ef			    ret                 ; Return 
13ef			 
13ef			free_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3            ; Size of management overhead 
13ef			    add hl, bc          ; Move to the next block 
13ef			    inc de              ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e             ; Load low byte of heap end address 
13ef			    cp (hl)             ; Compare with low byte of current address 
13ef			    jr nz, free_search_loop  ; If not equal, continue searching 
13ef			    ld a, d             ; Load high byte of heap end address 
13ef			    cp 0                ; Check if it's zero (end of memory) 
13ef			    jr nz, free_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, pointer is not found in heap 
13ef			    ret 
13ef			 
13ef			free_exit: 
13ef			    ret                 ; Return 
13ef			 
13ef			; Define heap start and end addresses 
13ef			;heap_start:    .dw 0xC000   ; Start of heap 
13ef			;heap_end:      .dw 0xE000   ; End of heap 
13ef			 
13ef			endif 
13ef			 
13ef			 
13ef			if MALLOC_1 
13ef			 
13ef			 
13ef			 
13ef			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ef			 
13ef			;moved to firmware.asm 
13ef			;heap_start        .equ  0x9000      ; Starting address of heap 
13ef			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ef			 
13ef			;      .org 0 
13ef			;      jp    main 
13ef			 
13ef			 
13ef			;      .org  0x100 
13ef			;main: 
13ef			;      ld    HL, 0x8100 
13ef			;      ld    SP, HL 
13ef			; 
13ef			;      call  heap_init 
13ef			; 
13ef			;      ; Make some allocations 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9004 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9014 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9024 
13ef			; 
13ef			;      ; Free some allocations 
13ef			;      ld    HL, 0x9014 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9004 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9024 
13ef			;      call  free 
13ef			; 
13ef			; 
13ef			;      halt 
13ef			 
13ef			 
13ef			;------------------------------------------------------------------------------ 
13ef			;     heap_init                                                               : 
13ef			;                                                                             : 
13ef			; Description                                                                 : 
13ef			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ef			;                                                                             : 
13ef			;     The heap is maintained as a linked list, starting with an initial       : 
13ef			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ef			;     the first free block in the heap. Each block then points to the next    : 
13ef			;     free block within the heap, and the free list ends at the first block   : 
13ef			;     with a null pointer to the next free block.                             : 
13ef			;                                                                             : 
13ef			; Parameters                                                                  : 
13ef			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ef			;     address of the heap and its size are required, along with a memory      : 
13ef			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ef			;     principally stores a pointer to the first free block in the heap.       : 
13ef			;                                                                             : 
13ef			; Returns                                                                     : 
13ef			;     Nothing                                                                 : 
13ef			;------------------------------------------------------------------------------ 
13ef			heap_init: 
13ef e5			      push  HL 
13f0			 
13f0			      ; Initialise free list struct 
13f0 21 0e 80		      ld    HL, heap_start 
13f3 22 0a 80		      ld    (free_list), HL 
13f6 21 00 00		      ld    HL, 0 
13f9 22 0c 80		      ld    (free_list+2), HL 
13fc			 
13fc			      ; Insert first free block at bottom of heap, consumes entire heap 
13fc 21 de f1		      ld    HL, heap_start+heap_size-4 
13ff 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1402 21 d0 71		      ld    HL, heap_size-4 
1405 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1408			 
1408			      ; Insert end of free list block at top of heap - two null words will 
1408			      ; terminate the free list 
1408 21 00 00		      ld    HL, 0 
140b 22 e0 f1		      ld    (heap_start+heap_size-2), HL 
140e 22 de f1		      ld    (heap_start+heap_size-4), HL 
1411			 
1411 e1			      pop   HL 
1412			 
1412 c9			      ret 
1413			 
1413			 
1413			;------------------------------------------------------------------------------ 
1413			;     malloc                                                                  : 
1413			;                                                                             : 
1413			; Description                                                                 : 
1413			;     Allocates the wanted space from the heap and returns the address of the : 
1413			;     first useable byte of the allocation.                                   : 
1413			;                                                                             : 
1413			;     Allocations can happen in one of two ways:                              : 
1413			;                                                                             : 
1413			;     1. A free block may be found which is the exact size wanted. In this    : 
1413			;        case the block is removed from the free list and retuedn to the      : 
1413			;        caller.                                                              : 
1413			;     2. A free block may be found which is larger than the size wanted. In   : 
1413			;        this case, the larger block is split into two. The first portion of  : 
1413			;        this block will become the requested space by the malloc call and    : 
1413			;        is returned to the caller. The second portion becomes a new free     : 
1413			;        block, and the free list is adjusted to maintain continuity via this : 
1413			;        newly created block.                                                 : 
1413			;                                                                             : 
1413			;     malloc does not set any initial value in the allocated space, the       : 
1413			;     caller is required to do this as required.                              : 
1413			;                                                                             : 
1413			;     This implementation of malloc uses the stack exclusively, and is        : 
1413			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1413			;     advisable to disable interrupts before calling malloc, and recommended  : 
1413			;     to avoid the use of malloc inside ISRs in general.                      : 
1413			;                                                                             : 
1413			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1413			;                                                                             : 
1413			; Parameters                                                                  : 
1413			;     HL  Number of bytes wanted                                              : 
1413			;                                                                             : 
1413			; Returns                                                                     : 
1413			;     HL  Address of the first useable byte of the allocation                 : 
1413			;                                                                             : 
1413			; Flags                                                                       : 
1413			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1413			;                                                                             : 
1413			; Stack frame                                                                 : 
1413			;       |             |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     BC      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     DE      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     IX      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |  prev_free  |                                                       : 
1413			;   +4  +-------------+                                                       : 
1413			;       |  this_free  |                                                       : 
1413			;   +2  +-------------+                                                       : 
1413			;       |  next_free  |                                                       : 
1413			;   +0  +-------------+                                                       : 
1413			;       |             |                                                       : 
1413			;                                                                             : 
1413			;------------------------------------------------------------------------------ 
1413			 
1413			 
1413			;malloc: 
1413			; 
1413			;	SAVESP ON 1 
1413			; 
1413			;	call malloc_code 
1413			; 
1413			;	CHECKSP ON 1 
1413			;	ret 
1413			 
1413			 
1413			malloc: 
1413 c5			      push  BC 
1414 d5			      push  DE 
1415 dd e5		      push  IX 
1417			if DEBUG_FORTH_MALLOC_HIGH 
1417			call malloc_guard_entry 
1417			endif 
1417			 
1417					if DEBUG_FORTH_MALLOC 
1417						DMARK "mal" 
1417						CALLMONITOR 
1417					endif 
1417 7c			      ld    A, H                    ; Exit if no space requested 
1418 b5			      or    L 
1419 ca d8 14		      jp    Z, malloc_early_exit 
141c			 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			; 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			 
141c			 
141c			 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "maA" 
141c						CALLMONITOR 
141c					endif 
141c			      ; Set up stack frame 
141c eb			      ex    DE, HL 
141d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1420 39			      add   HL, SP 
1421 f9			      ld    SP, HL 
1422 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1426 dd 39		      add   IX, SP 
1428			 
1428			      ; Setup initial state 
1428 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
142b 19			      add   HL, DE 
142c			 
142c 44			      ld    B, H                    ; Move want to BC 
142d 4d			      ld    C, L 
142e			 
142e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1431 dd 75 04		      ld    (IX+4), L 
1434 dd 74 05		      ld    (IX+5), H 
1437			 
1437 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a dd 73 02		      ld    (IX+2), E 
143d dd 72 03		      ld    (IX+3), D 
1440 eb			      ex    DE, HL                  ; this_free ptr into HL 
1441			 
1441					if DEBUG_FORTH_MALLOC 
1441						DMARK "maB" 
1441						CALLMONITOR 
1441					endif 
1441			      ; Loop through free block list to find some space 
1441			malloc_find_space: 
1441 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1442 23			      inc   HL 
1443 56			      ld    D, (HL) 
1444			 
1444 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1445 b3			      or    E 
1446 ca d2 14		      jp    Z, malloc_no_space 
1449			 
1449 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
144c dd 72 01		      ld    (IX+1), D 
144f			 
144f			      ; Does this block have enough space to make the allocation? 
144f 23			      inc   HL                      ; Load free block size into DE 
1450 5e			      ld    E, (HL) 
1451 23			      inc   HL 
1452 56			      ld    D, (HL) 
1453			 
1453 eb			      ex    DE, HL                  ; Check size of block against want 
1454 b7			      or    A                       ; Ensure carry flag clear 
1455 ed 42		      sbc   HL, BC 
1457 e5			      push  HL                      ; Store the result for later (new block size) 
1458			 
1458 ca a7 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
145b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145d			 
145d			      ; this_free block is not big enough, setup ptrs to test next free block 
145d e1			      pop   HL                      ; Discard previous result 
145e			 
145e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1461 dd 66 03		      ld    H, (IX+3) 
1464 dd 75 04		      ld    (IX+4), L 
1467 dd 74 05		      ld    (IX+5), H 
146a			 
146a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146d dd 66 01		      ld    H, (IX+1) 
1470 dd 75 02		      ld    (IX+2), L 
1473 dd 74 03		      ld    (IX+3), H 
1476			 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MA>" 
1476						CALLMONITOR 
1476					endif 
1476 18 c9		      jr    malloc_find_space 
1478			 
1478			      ; split a bigger block into two - requested size and remaining size 
1478			malloc_alloc_split: 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAs" 
1478						CALLMONITOR 
1478					endif 
1478 eb			      ex    DE, HL                  ; Calculate address of new free block 
1479 2b			      dec   HL 
147a 2b			      dec   HL 
147b 2b			      dec   HL 
147c 09			      add   HL, BC 
147d			 
147d			      ; Create a new block and point it at next_free 
147d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1480 dd 56 01		      ld    D, (IX+1) 
1483			 
1483 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1484 23			      inc   HL 
1485 72			      ld    (HL), D 
1486			 
1486 d1			      pop   DE                      ; Store size of new block into new block 
1487 23			      inc   HL 
1488 73			      ld    (HL), E 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b			      ; Update this_free ptr to point to new block 
148b 2b			      dec   HL 
148c 2b			      dec   HL 
148d 2b			      dec   HL 
148e			 
148e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1491 dd 56 03		      ld    D, (IX+3) 
1494			 
1494 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1497 dd 74 03		      ld    (IX+3), H 
149a			 
149a			      ; Modify this_free block to be allocation 
149a eb			      ex    DE, HL 
149b af			      xor   A                       ; Null the next block ptr of allocated block 
149c 77			      ld    (HL), A 
149d 23			      inc   HL 
149e 77			      ld    (HL), A 
149f			 
149f 23			      inc   HL                      ; Store want size into allocated block 
14a0 71			      ld    (HL), C 
14a1 23			      inc   HL 
14a2 70			      ld    (HL), B 
14a3 23			      inc   HL 
14a4 e5			      push  HL                      ; Address of allocation to return 
14a5			 
14a5 18 19		      jr    malloc_update_links 
14a7			 
14a7			malloc_alloc_fit: 
14a7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a8			 
14a8					if DEBUG_FORTH_MALLOC 
14a8						DMARK "MAf" 
14a8						CALLMONITOR 
14a8					endif 
14a8			      ; Modify this_free block to be allocation 
14a8 eb			      ex    DE, HL 
14a9 2b			      dec   HL 
14aa 2b			      dec   HL 
14ab 2b			      dec   HL 
14ac			 
14ac af			      xor   A                       ; Null the next block ptr of allocated block 
14ad 77			      ld    (HL), A 
14ae 23			      inc   HL 
14af 77			      ld    (HL), A 
14b0			 
14b0 23			      inc   HL                      ; Store address of allocation to return 
14b1 23			      inc   HL 
14b2 23			      inc   HL 
14b3 e5			      push  HL 
14b4			 
14b4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b4 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b7 dd 66 01		      ld    H, (IX+1) 
14ba			 
14ba dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14bd dd 74 03		      ld    (IX+3), H 
14c0			 
14c0			 
14c0			malloc_update_links: 
14c0			      ; Update prev_free ptr to point to this_free 
14c0 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c3 dd 66 05		      ld    H, (IX+5) 
14c6			 
14c6 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c9 dd 56 03		      ld    D, (IX+3) 
14cc			 
14cc 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14cd 23			      inc   HL 
14ce 72			      ld    (HL), D 
14cf			 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "Mul" 
14cf						CALLMONITOR 
14cf					endif 
14cf			      ; Clear the Z flag to indicate successful allocation 
14cf 7a			      ld    A, D 
14d0 b3			      or    E 
14d1			 
14d1 d1			      pop   DE                      ; Address of allocation 
14d2					if DEBUG_FORTH_MALLOC 
14d2						DMARK "MAu" 
14d2						CALLMONITOR 
14d2					endif 
14d2			 
14d2			malloc_no_space: 
14d2 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d5 39			      add   HL, SP 
14d6 f9			      ld    SP, HL 
14d7			 
14d7 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAN" 
14d8						CALLMONITOR 
14d8					endif 
14d8			 
14d8			malloc_early_exit: 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAx" 
14d8						CALLMONITOR 
14d8					endif 
14d8 dd e1		      pop   IX 
14da d1			      pop   DE 
14db c1			      pop   BC 
14dc			 
14dc			if DEBUG_FORTH_MALLOC_HIGH 
14dc			call malloc_guard_exit 
14dc			call malloc_guard_zerolen 
14dc			endif 
14dc c9			      ret 
14dd			 
14dd			 
14dd			;------------------------------------------------------------------------------ 
14dd			;     free                                                                    : 
14dd			;                                                                             : 
14dd			; Description                                                                 : 
14dd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14dd			;     returned by malloc, otherwise the behaviour is undefined.               : 
14dd			;                                                                             : 
14dd			;     Where possible, directly adjacent free blocks will be merged together   : 
14dd			;     into larger blocks to help ensure that the heap does not become         : 
14dd			;     excessively fragmented.                                                 : 
14dd			;                                                                             : 
14dd			;     free does not clear or set any other value into the freed space, and    : 
14dd			;     therefore its contents may be visible through subsequent malloc's. The  : 
14dd			;     caller should clear the freed space as required.                        : 
14dd			;                                                                             : 
14dd			;     This implementation of free uses the stack exclusively, and is          : 
14dd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14dd			;     advisable to disable interrupts before calling free, and recommended    : 
14dd			;     to avoid the use of free inside ISRs in general.                        : 
14dd			;                                                                             : 
14dd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14dd			;                                                                             : 
14dd			; Parameters                                                                  : 
14dd			;     HL  Pointer to address of first byte of allocation to be freed          : 
14dd			;                                                                             : 
14dd			; Returns                                                                     : 
14dd			;     Nothing                                                                 : 
14dd			;                                                                             : 
14dd			; Stack frame                                                                 : 
14dd			;       |             |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     BC      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     DE      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     IX      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |  prev_free  |                                                       : 
14dd			;   +2  +-------------+                                                       : 
14dd			;       |  next_free  |                                                       : 
14dd			;   +0  +-------------+                                                       : 
14dd			;       |             |                                                       : 
14dd			;                                                                             : 
14dd			;------------------------------------------------------------------------------ 
14dd			free: 
14dd c5			      push  BC 
14de d5			      push  DE 
14df dd e5		      push  IX 
14e1			 
14e1 7c			      ld    A, H                    ; Exit if ptr is null 
14e2 b5			      or    L 
14e3 ca a7 15		      jp    Z, free_early_exit 
14e6			 
14e6			      ; Set up stack frame 
14e6 eb			      ex    DE, HL 
14e7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ea 39			      add   HL, SP 
14eb f9			      ld    SP, HL 
14ec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f0 dd 39		      add   IX, SP 
14f2			 
14f2			      ; The address in HL points to the start of the useable allocated space, 
14f2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f2			      ; address of the block itself. 
14f2 eb			      ex    DE, HL 
14f3 11 fc ff		      ld    DE, -4 
14f6 19			      add   HL, DE 
14f7			 
14f7			      ; An allocated block must have a null next block pointer in it 
14f7 7e			      ld    A, (HL) 
14f8 23			      inc   HL 
14f9 b6			      or    (HL) 
14fa c2 a2 15		      jp    NZ, free_done 
14fd			 
14fd 2b			      dec   HL 
14fe			 
14fe 44			      ld    B, H                    ; Copy HL to BC 
14ff 4d			      ld    C, L 
1500			 
1500			      ; Loop through the free list to find the first block with an address 
1500			      ; higher than the block being freed 
1500 21 0a 80		      ld    HL, free_list 
1503			 
1503			free_find_higher_block: 
1503 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1504 23			      inc   HL 
1505 56			      ld    D, (HL) 
1506 2b			      dec   HL 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150a dd 72 01		      ld    (IX+1), D 
150d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1510 dd 74 03		      ld    (IX+3), H 
1513			 
1513 78			      ld    A, B                    ; Check if DE is greater than BC 
1514 ba			      cp    D                       ; Compare MSB first 
1515 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1517 30 04		      jr    NC, free_find_higher_block_skip 
1519 79			      ld    A, C 
151a bb			      cp    E                       ; Then compare LSB 
151b 38 08		      jr    C, free_found_higher_block 
151d			 
151d			free_find_higher_block_skip: 
151d 7a			      ld    A, D                    ; Reached the end of the free list? 
151e b3			      or    E 
151f ca a2 15		      jp    Z, free_done 
1522			 
1522 eb			      ex    DE, HL 
1523			 
1523 18 de		      jr    free_find_higher_block 
1525			 
1525			free_found_higher_block: 
1525			      ; Insert freed block between prev and next free blocks 
1525 71			      ld    (HL), C                 ; Point prev free block to freed block 
1526 23			      inc   HL 
1527 70			      ld    (HL), B 
1528			 
1528 60			      ld    H, B                    ; Point freed block at next free block 
1529 69			      ld    L, C 
152a 73			      ld    (HL), E 
152b 23			      inc   HL 
152c 72			      ld    (HL), D 
152d			 
152d			      ; Check if the freed block is adjacent to the next free block 
152d 23			      inc   HL                      ; Load size of freed block into HL 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 eb			      ex    DE, HL 
1532			 
1532 09			      add   HL, BC                  ; Add addr of freed block and its size 
1533			 
1533 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1536 dd 56 01		      ld    D, (IX+1) 
1539			 
1539 b7			      or    A                       ; Clear the carry flag 
153a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
153c 20 22		      jr    NZ, free_check_adjacent_to_prev 
153e			 
153e			      ; Freed block is adjacent to next, merge into one bigger block 
153e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153f 5e			      ld    E, (HL) 
1540 23			      inc   HL 
1541 56			      ld    D, (HL) 
1542 e5			      push  HL                      ; Save ptr to next block for later 
1543			 
1543 60			      ld    H, B                    ; Store ptr from next block into freed block 
1544 69			      ld    L, C 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548 e1			      pop   HL                      ; Restore ptr to next block 
1549 23			      inc   HL                      ; Load size of next block into DE 
154a 5e			      ld    E, (HL) 
154b 23			      inc   HL 
154c 56			      ld    D, (HL) 
154d d5			      push  DE                      ; Save next block size for later 
154e			 
154e 60			      ld    H, B                    ; Load size of freed block into HL 
154f 69			      ld    L, C 
1550 23			      inc   HL 
1551 23			      inc   HL 
1552 5e			      ld    E, (HL) 
1553 23			      inc   HL 
1554 56			      ld    D, (HL) 
1555 eb			      ex    DE, HL 
1556			 
1556 d1			      pop   DE                      ; Restore size of next block 
1557 19			      add   HL, DE                  ; Add sizes of both blocks 
1558 eb			      ex    DE, HL 
1559			 
1559 60			      ld    H, B                    ; Store new bigger size into freed block 
155a 69			      ld    L, C 
155b 23			      inc   HL 
155c 23			      inc   HL 
155d 73			      ld    (HL), E 
155e 23			      inc   HL 
155f 72			      ld    (HL), D 
1560			 
1560			free_check_adjacent_to_prev: 
1560			      ; Check if the freed block is adjacent to the prev free block 
1560 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1563 dd 66 03		      ld    H, (IX+3) 
1566			 
1566 23			      inc   HL                      ; Size of prev free block into DE 
1567 23			      inc   HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b 2b			      dec   HL 
156c 2b			      dec   HL 
156d 2b			      dec   HL 
156e			 
156e 19			      add   HL, DE                  ; Add prev block addr and size 
156f			 
156f b7			      or    A                       ; Clear the carry flag 
1570 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1572 20 2e		      jr    NZ, free_done 
1574			 
1574			      ; Freed block is adjacent to prev, merge into one bigger block 
1574 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1575 69			      ld    L, C 
1576 5e			      ld    E, (HL) 
1577 23			      inc   HL 
1578 56			      ld    D, (HL) 
1579 e5			      push  HL                      ; Save freed block ptr for later 
157a			 
157a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157d dd 66 03		      ld    H, (IX+3) 
1580 73			      ld    (HL), E 
1581 23			      inc   HL 
1582 72			      ld    (HL), D 
1583			 
1583 e1			      pop   HL                      ; Restore freed block ptr 
1584 23			      inc   HL                      ; Load size of freed block into DE 
1585 5e			      ld    E, (HL) 
1586 23			      inc   HL 
1587 56			      ld    D, (HL) 
1588 d5			      push  DE                      ; Save freed block size for later 
1589			 
1589 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
158c dd 66 03		      ld    H, (IX+3) 
158f 23			      inc   HL 
1590 23			      inc   HL 
1591 5e			      ld    E, (HL) 
1592 23			      inc   HL 
1593 56			      ld    D, (HL) 
1594			 
1594 e1			      pop   HL                      ; Add sizes of both blocks 
1595 19			      add   HL, DE 
1596 eb			      ex    DE, HL 
1597			 
1597 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159a dd 66 03		      ld    H, (IX+3) 
159d 23			      inc   HL 
159e 23			      inc   HL 
159f 73			      ld    (HL), E 
15a0 23			      inc   HL 
15a1 72			      ld    (HL), D 
15a2			 
15a2			free_done: 
15a2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a5 39			      add   HL, SP 
15a6 f9			      ld    SP, HL 
15a7			 
15a7			free_early_exit: 
15a7 dd e1		      pop   IX 
15a9 d1			      pop   DE 
15aa c1			      pop   BC 
15ab			 
15ab c9			      ret 
15ac			 
15ac			; moved to firmware.asm 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			;                  .dw   0 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_3 
15ac			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15ac			;heap_start        .equ  0x9000      ; Starting address of heap 
15ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15ac			; 
15ac			 ;     .org 0 
15ac			  ;    jp    main 
15ac			; 
15ac			; 
15ac			 ;     .org  0x100 
15ac			;main: 
15ac			 ;     ld    HL, 0x8100 
15ac			  ;    ld    SP, HL 
15ac			; 
15ac			;      call  heap_init 
15ac			 
15ac			      ; Make some allocations 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9004 
15ac			; 
15ac			 ;     ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9014 
15ac			 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9024 
15ac			 
15ac			      ; Free some allocations 
15ac			;      ld    HL, 0x9014 
15ac			;      call  free 
15ac			 
15ac			;      ld    HL, 0x9004 
15ac			;      call  free 
15ac			; 
15ac			;      ld    HL, 0x9024 
15ac			;      call  free 
15ac			 
15ac			 
15ac			 ;     halt 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     heap_init                                                               : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
15ac			;                                                                             : 
15ac			;     The heap is maintained as a linked list, starting with an initial       : 
15ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15ac			;     the first free block in the heap. Each block then points to the next    : 
15ac			;     free block within the heap, and the free list ends at the first block   : 
15ac			;     with a null pointer to the next free block.                             : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
15ac			;     address of the heap and its size are required, along with a memory      : 
15ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15ac			;     principally stores a pointer to the first free block in the heap.       : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;------------------------------------------------------------------------------ 
15ac			heap_init: 
15ac			      push  HL 
15ac			 
15ac			      ; Initialise free list struct 
15ac			      ld    HL, heap_start 
15ac			      ld    (free_list), HL 
15ac			      ld    HL, 0 
15ac			      ld    (free_list+2), HL 
15ac			 
15ac			      ; Insert first free block at bottom of heap, consumes entire heap 
15ac			      ld    HL, heap_start+heap_size-4 
15ac			      ld    (heap_start), HL        ; Next block (end of free list) 
15ac			      ld    HL, heap_size-4 
15ac			      ld    (heap_start+2), HL      ; Block size 
15ac			 
15ac			      ; Insert end of free list block at top of heap - two null words will 
15ac			      ; terminate the free list 
15ac			      ld    HL, 0 
15ac			      ld    (heap_start+heap_size-2), HL 
15ac			      ld    (heap_start+heap_size-4), HL 
15ac			 
15ac			      pop   HL 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     malloc                                                                  : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Allocates the wanted space from the heap and returns the address of the : 
15ac			;     first useable byte of the allocation.                                   : 
15ac			;                                                                             : 
15ac			;     Allocations can happen in one of two ways:                              : 
15ac			;                                                                             : 
15ac			;     1. A free block may be found which is the exact size wanted. In this    : 
15ac			;        case the block is removed from the free list and retuedn to the      : 
15ac			;        caller.                                                              : 
15ac			;     2. A free block may be found which is larger than the size wanted. In   : 
15ac			;        this case, the larger block is split into two. The first portion of  : 
15ac			;        this block will become the requested space by the malloc call and    : 
15ac			;        is returned to the caller. The second portion becomes a new free     : 
15ac			;        block, and the free list is adjusted to maintain continuity via this : 
15ac			;        newly created block.                                                 : 
15ac			;                                                                             : 
15ac			;     malloc does not set any initial value in the allocated space, the       : 
15ac			;     caller is required to do this as required.                              : 
15ac			;                                                                             : 
15ac			;     This implementation of malloc uses the stack exclusively, and is        : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling malloc, and recommended  : 
15ac			;     to avoid the use of malloc inside ISRs in general.                      : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Number of bytes wanted                                              : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     HL  Address of the first useable byte of the allocation                 : 
15ac			;                                                                             : 
15ac			; Flags                                                                       : 
15ac			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +4  +-------------+                                                       : 
15ac			;       |  this_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			malloc: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if no space requested 
15ac			      or    L 
15ac			      jp    Z, malloc_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; Setup initial state 
15ac			      ld    HL, 4                   ; want must also include space used by block struct 
15ac			      add   HL, DE 
15ac			 
15ac			      ld    B, H                    ; Move want to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ld    HL, free_list           ; Store prev_free ptr to stack 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    E, (HL)                 ; Store this_free ptr to stack 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ld    (IX+2), E 
15ac			      ld    (IX+3), D 
15ac			      ex    DE, HL                  ; this_free ptr into HL 
15ac			 
15ac			      ; Loop through free block list to find some space 
15ac			malloc_find_space: 
15ac			      ld    E, (HL)                 ; Load next_free ptr into DE 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15ac			      or    E 
15ac			      jp    Z, malloc_no_space 
15ac			 
15ac			      ld    (IX+0), E               ; Store next_free ptr to stack 
15ac			      ld    (IX+1), D 
15ac			 
15ac			      ; Does this block have enough space to make the allocation? 
15ac			      inc   HL                      ; Load free block size into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ex    DE, HL                  ; Check size of block against want 
15ac			      or    A                       ; Ensure carry flag clear 
15ac			      sbc   HL, BC 
15ac			      push  HL                      ; Store the result for later (new block size) 
15ac			 
15ac			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15ac			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15ac			 
15ac			      ; this_free block is not big enough, setup ptrs to test next free block 
15ac			      pop   HL                      ; Discard previous result 
15ac			 
15ac			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15ac			      ld    H, (IX+3) 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15ac			      ld    H, (IX+1) 
15ac			      ld    (IX+2), L 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      jr    malloc_find_space 
15ac			 
15ac			      ; split a bigger block into two - requested size and remaining size 
15ac			malloc_alloc_split: 
15ac			      ex    DE, HL                  ; Calculate address of new free block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      add   HL, BC 
15ac			 
15ac			      ; Create a new block and point it at next_free 
15ac			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      ld    (HL), E                 ; Store next_free ptr into new block 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   DE                      ; Store size of new block into new block 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Update this_free ptr to point to new block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store want size into allocated block 
15ac			      ld    (HL), C 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			      inc   HL 
15ac			      push  HL                      ; Address of allocation to return 
15ac			 
15ac			      jr    malloc_update_links 
15ac			 
15ac			malloc_alloc_fit: 
15ac			      pop   HL                      ; Dont need new block size, want is exact fit 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store address of allocation to return 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      push  HL 
15ac			 
15ac			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15ac			      ld    L, (IX+0)               ; next_free to HL 
15ac			      ld    H, (IX+1) 
15ac			 
15ac			      ld    (IX+2), L               ; HL to this_free 
15ac			      ld    (IX+3), H 
15ac			 
15ac			 
15ac			malloc_update_links: 
15ac			      ; Update prev_free ptr to point to this_free 
15ac			      ld    L, (IX+4)               ; prev_free ptr to HL 
15ac			      ld    H, (IX+5) 
15ac			 
15ac			      ld    E, (IX+2)               ; this_free ptr to DE 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (HL), E                 ; this_free ptr into prev_free 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Clear the Z flag to indicate successful allocation 
15ac			      ld    A, D 
15ac			      or    E 
15ac			 
15ac			      pop   DE                      ; Address of allocation 
15ac			 
15ac			malloc_no_space: 
15ac			      ld    HL, 6                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			      ex    DE, HL                  ; Alloc addr into HL for return 
15ac			 
15ac			malloc_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     free                                                                    : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
15ac			;                                                                             : 
15ac			;     Where possible, directly adjacent free blocks will be merged together   : 
15ac			;     into larger blocks to help ensure that the heap does not become         : 
15ac			;     excessively fragmented.                                                 : 
15ac			;                                                                             : 
15ac			;     free does not clear or set any other value into the freed space, and    : 
15ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
15ac			;     caller should clear the freed space as required.                        : 
15ac			;                                                                             : 
15ac			;     This implementation of free uses the stack exclusively, and is          : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling free, and recommended    : 
15ac			;     to avoid the use of free inside ISRs in general.                        : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			free: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if ptr is null 
15ac			      or    L 
15ac			      jp    Z, free_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; The address in HL points to the start of the useable allocated space, 
15ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15ac			      ; address of the block itself. 
15ac			      ex    DE, HL 
15ac			      ld    DE, -4 
15ac			      add   HL, DE 
15ac			 
15ac			      ; An allocated block must have a null next block pointer in it 
15ac			      ld    A, (HL) 
15ac			      inc   HL 
15ac			      or    (HL) 
15ac			      jp    NZ, free_done 
15ac			 
15ac			      dec   HL 
15ac			 
15ac			      ld    B, H                    ; Copy HL to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ; Loop through the free list to find the first block with an address 
15ac			      ; higher than the block being freed 
15ac			      ld    HL, free_list 
15ac			 
15ac			free_find_higher_block: 
15ac			      ld    E, (HL)                 ; Load next ptr from free block 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			 
15ac			      ld    (IX+0), E               ; Save ptr to next free block 
15ac			      ld    (IX+1), D 
15ac			      ld    (IX+2), L               ; Save ptr to prev free block 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ld    A, B                    ; Check if DE is greater than BC 
15ac			      cp    D                       ; Compare MSB first 
15ac			      jr    Z, $+4                  ; MSB the same, compare LSB 
15ac			      jr    NC, free_find_higher_block_skip 
15ac			      ld    A, C 
15ac			      cp    E                       ; Then compare LSB 
15ac			      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac			      ld    A, D                    ; Reached the end of the free list? 
15ac			      or    E 
15ac			      jp    Z, free_done 
15ac			 
15ac			      ex    DE, HL 
15ac			 
15ac			      jr    free_find_higher_block 
15ac			 
15ac			free_found_higher_block: 
15ac			      ; Insert freed block between prev and next free blocks 
15ac			      ld    (HL), C                 ; Point prev free block to freed block 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			 
15ac			      ld    H, B                    ; Point freed block at next free block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Check if the freed block is adjacent to the next free block 
15ac			      inc   HL                      ; Load size of freed block into HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      add   HL, BC                  ; Add addr of freed block and its size 
15ac			 
15ac			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_check_adjacent_to_prev 
15ac			 
15ac			      ; Freed block is adjacent to next, merge into one bigger block 
15ac			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save ptr to next block for later 
15ac			 
15ac			      ld    H, B                    ; Store ptr from next block into freed block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore ptr to next block 
15ac			      inc   HL                      ; Load size of next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save next block size for later 
15ac			 
15ac			      ld    H, B                    ; Load size of freed block into HL 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      pop   DE                      ; Restore size of next block 
15ac			      add   HL, DE                  ; Add sizes of both blocks 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    H, B                    ; Store new bigger size into freed block 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_check_adjacent_to_prev: 
15ac			      ; Check if the freed block is adjacent to the prev free block 
15ac			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15ac			      ld    H, (IX+3) 
15ac			 
15ac			      inc   HL                      ; Size of prev free block into DE 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      add   HL, DE                  ; Add prev block addr and size 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_done 
15ac			 
15ac			      ; Freed block is adjacent to prev, merge into one bigger block 
15ac			      ld    H, B                    ; Load next ptr from freed block into DE 
15ac			      ld    L, C 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save freed block ptr for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15ac			      ld    H, (IX+3) 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore freed block ptr 
15ac			      inc   HL                      ; Load size of freed block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save freed block size for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Load size of prev block into DE 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      pop   HL                      ; Add sizes of both blocks 
15ac			      add   HL, DE 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_done: 
15ac			      ld    HL, 4                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;      .org 0x8000 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			 ;                 .dw   0 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_4 
15ac			 
15ac			; My memory allocation code. Very very simple.... 
15ac			; allocate space under 250 chars 
15ac			 
15ac			heap_init: 
15ac				; init start of heap as zero 
15ac				;  
15ac			 
15ac				ld hl, heap_start 
15ac				ld a, 0 
15ac				ld (hl), a      ; empty block 
15ac				inc hl 
15ac				ld a, 0 
15ac				ld (hl), a      ; length of block 
15ac				; write end of list 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				 
15ac			 
15ac				; init some malloc vars 
15ac			 
15ac				ld hl, 0 
15ac				ld (free_list), hl       ; store last malloc location 
15ac			 
15ac				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15ac				ld a, 0 
15ac				ld (hl), a 
15ac			 
15ac			 
15ac				ld hl, heap_start 
15ac				;  
15ac				  
15ac				ret 
15ac			 
15ac			 
15ac			;    free block marker 
15ac			;    requested size  
15ac			;    pointer to next block 
15ac			;    .... 
15ac			;    next block marker 
15ac			 
15ac			 
15ac			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15ac			; 
15ac			 
15ac			 
15ac			malloc:  
15ac				push de 
15ac				push bc 
15ac				push af 
15ac			 
15ac				; hl space required 
15ac				 
15ac				ld c, l    ; hold space   (TODO only a max of 255) 
15ac			 
15ac			;	inc c     ; TODO BUG need to fix memory leak on push str 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			 
15ac			 
15ac			 
15ac				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15ac			 
15ac				ld a, (free_list+3) 
15ac				cp 0 
15ac				jr z, .contheap 
15ac			 
15ac				ld hl, (free_list)     ; get last alloc 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mrs" 
15ac						CALLMONITOR 
15ac					endif 
15ac				jr .startalloc 
15ac			 
15ac			.contheap: 
15ac				ld hl, heap_start 
15ac			 
15ac			.startalloc: 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mym" 
15ac						CALLMONITOR 
15ac					endif 
15ac			.findblock: 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmf" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac				ld a,(hl)  
15ac				; if byte is zero then clear to use 
15ac			 
15ac				cp 0 
15ac				jr z, .foundemptyblock 
15ac			 
15ac				; if byte is not clear 
15ac				;     then byte is offset to next block 
15ac			 
15ac				inc hl 
15ac				ld a, (hl) ; get size 
15ac			.nextblock:	inc hl 
15ac					ld e, (hl) 
15ac					inc hl 
15ac					ld d, (hl) 
15ac					ex de, hl 
15ac			;	inc hl  ; move past the store space 
15ac			;	inc hl  ; move past zero index  
15ac			 
15ac				; TODO detect no more space 
15ac			 
15ac				push hl 
15ac				ld de, heap_end 
15ac				call cmp16 
15ac				pop hl 
15ac				jr nc, .nospace 
15ac			 
15ac				jr .findblock 
15ac			 
15ac			.nospace: ld hl, 0 
15ac				jp .exit 
15ac			 
15ac			 
15ac			.foundemptyblock:	 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mme" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; TODO has block enough space if reusing??? 
15ac			 
15ac				;  
15ac			 
15ac			; see if this block has been previously used 
15ac				inc hl 
15ac				ld a, (hl) 
15ac				dec hl 
15ac				cp 0 
15ac				jr z, .newblock 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meR" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; no reusing previously allocated block 
15ac			 
15ac			; is it smaller than previously used? 
15ac				 
15ac				inc hl    ; move to size 
15ac				ld a, c 
15ac				sub (hl)        ; we want c < (hl) 
15ac				dec hl    ; move back to marker 
15ac			        jr z, .findblock 
15ac			 
15ac				; update with the new size which should be lower 
15ac			 
15ac			        ;inc  hl   ; negate next move. move back to size  
15ac			 
15ac			.newblock: 
15ac				; need to be at marker here 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meN" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			 
15ac				ld a, c 
15ac			 
15ac				ld (free_list+3), a	 ; flag resume from last malloc  
15ac				ld (free_list), hl    ; save out last location 
15ac			 
15ac			 
15ac				;inc a     ; space for length byte 
15ac				ld (hl), a     ; save block in use marker 
15ac			 
15ac				inc hl   ; move to space marker 
15ac				ld (hl), a    ; save new space 
15ac			 
15ac				inc hl   ; move to start of allocated area 
15ac				 
15ac			;	push hl     ; save where we are - 1  
15ac			 
15ac			;	inc hl  ; move past zero index  
15ac				; skip space to set down new marker 
15ac			 
15ac				; provide some extra space for now 
15ac			 
15ac				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15ac				inc a 
15ac				inc a 
15ac			 
15ac				push hl   ; save where we are in the node block 
15ac			 
15ac				call addatohl 
15ac			 
15ac				; write linked list point 
15ac			 
15ac				pop de     ; get our node position 
15ac				ex de, hl 
15ac			 
15ac				ld (hl), e 
15ac				inc hl 
15ac				ld (hl), d 
15ac			 
15ac				inc hl 
15ac			 
15ac				; now at start of allocated data so save pointer 
15ac			 
15ac				push hl 
15ac			 
15ac				; jump to position of next node and setup empty header in DE 
15ac			 
15ac				ex de, hl 
15ac			 
15ac			;	inc hl ; move past end of block 
15ac			 
15ac				ld a, 0 
15ac				ld (hl), a   ; empty marker 
15ac				inc hl 
15ac				ld (hl), a   ; size 
15ac				inc hl  
15ac				ld (hl), a   ; ptr 
15ac				inc hl 
15ac				ld (hl), a   ; ptr 
15ac			 
15ac			 
15ac				pop hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmr" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			.exit: 
15ac				pop af 
15ac				pop bc 
15ac				pop de  
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			 
15ac			free:  
15ac				push hl 
15ac				push af 
15ac				; get address in hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "fre" 
15ac						CALLMONITOR 
15ac					endif 
15ac				; data is at hl - move to block count 
15ac				dec hl 
15ac				dec hl    ; get past pointer 
15ac				dec hl 
15ac			 
15ac				ld a, (hl)    ; need this for a validation check 
15ac			 
15ac				dec hl    ; move to block marker 
15ac			 
15ac				; now check that the block count and block marker are the same  
15ac			        ; this checks that we are on a malloc node and not random memory 
15ac			        ; OK a faint chance this could be a problem but rare - famous last words! 
15ac			 
15ac				ld c, a 
15ac				ld a, (hl)    
15ac			 
15ac				cp c 
15ac				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15ac			 
15ac				; yes good chance we are on a malloc node 
15ac			 
15ac				ld a, 0      
15ac				ld (hl), a   ; mark as free 
15ac			 
15ac				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15ac			 
15ac			.freeignore:  
15ac			 
15ac				pop af 
15ac				pop hl 
15ac			 
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			; eof 
# End of file firmware_memory.asm
15ac			  
15ac			; device C  
15ac			if SOUND_ENABLE  
15ac				include "firmware_sound.asm"  
15ac			; Sound abstraction layer 
15ac			 
15ac			; support different sound chips through common interface 
15ac			 
15ac			SOUND_DEVICE_AY: equ 0 
15ac			 
15ac			SOUND_DEVICE: equ Device_A 
15ac			 
15ac			 
15ac			 
15ac			if SOUND_DEVICE_AY 
15ac				include "firmware_sound_ay38910.asm" 
15ac			else 
15ac				include "firmware_sound_sn76489an.asm" 
15ac			 
15ac			; Device support for SN76489AN sound chip 
15ac			 
15ac			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15ac			; http://danceswithferrets.org/geekblog/?p=93 
15ac			; https://www.smspower.org/Development/SN76489 
15ac			 
15ac			; D0 [ 3] 
15ac			; D1 [ 2] 
15ac			; D2 [ 1] 
15ac			; D3 [15] 
15ac			; D4 [13] 
15ac			; D5 [12] 
15ac			; D6 [11] 
15ac			; D7 [10] 
15ac			; /WE [ 5] 
15ac			; CLK [14] 
15ac			; /OE [ 6] 
15ac			; AUDIO [ 7] 
15ac			; GND 8 
15ac			; +5 16 
15ac			; 
15ac			 
15ac			; Write sequence: 
15ac			; CE low 
15ac			; Data bus 
15ac			; WE low then high 
15ac			; 32 clock cycles / 8ns write time at 4mhz 
15ac			; 
15ac			; https://github.com/jblang/SN76489 
15ac			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15ac			; Tried: 
15ac			; 
15ac			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15ac			; 
15ac			; Connected WE to OR too 
15ac			;  
15ac			; That enabled the clock when required 
15ac			; However still random bus corruption. Need further investigation 
15ac			 
15ac			 
15ac			SOUND_LATCH: equ 10000000B 
15ac			SOUND_DATA: equ 0B 
15ac			SOUND_CH0:  equ 0B    ; Tone 
15ac			SOUND_CH1: equ 0100000B        ; Tone 
15ac			SOUND_CH2: equ 1000000B   ; Tone 
15ac			SOUND_CH3: equ 1100000B    ; Noise 
15ac			SOUND_VOL: equ 10000B 
15ac			SOUND_TONE: equ 0B 
15ac			 
15ac			 
15ac			sound_init: 
15ac 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15ae cd c3 15			call note_send_byte 
15b1 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15b3 cd c3 15			call note_send_byte 
15b6 cd 89 0c			call delay250ms 
15b9 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15bb cd c3 15			call note_send_byte 
15be cd 89 0c			call delay250ms 
15c1 c9				ret 
15c2			 
15c2			; Play a note 
15c2			; h = note 
15c2			; l = duration 
15c2			; a = channel 
15c2			 
15c2			 
15c2			;  frequ = clock / ( 2 x reg valu x 32 )  
15c2			 
15c2			note:  
15c2				 
15c2			 
15c2 c9				ret 
15c3			 
15c3			note_send_byte: 
15c3				; byte in a 
15c3			 
15c3				; we high 
15c3 d3 40			out (Device_B), a 
15c5			;	ld a, 1 
15c5			;	call aDelayInMS 
15c5 00				nop  
15c6 00				nop  
15c7 00				nop  
15c8 00				nop  
15c9				; we low 
15c9 d3 40			out (Device_B), a 
15cb			;	ld a, 1 
15cb			;	call aDelayInMS 
15cb 00				nop  
15cc 00				nop  
15cd 00				nop  
15ce 00				nop  
15cf				; we high 
15cf d3 40			out (Device_B), a 
15d1			;	ld a, 1 
15d1			;	call aDelayInMS 
15d1 00				nop  
15d2 00				nop  
15d3 00				nop  
15d4 00				nop  
15d5			 
15d5			 
15d5 c9				ret 
15d6			 
15d6			;void SilenceAllChannels() 
15d6			;{ 
15d6			;  SendByte(0x9f); 
15d6			;  SendByte(0xbf); 
15d6			;  SendByte(0xdf); 
15d6			;  SendByte(0xff); 
15d6			;} 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound_sn76489an.asm
15d6			endif 
15d6			 
15d6			 
15d6			; Abstraction entry points 
15d6			 
15d6			; init  
15d6			 
15d6			; sound_init in specific hardware files 
15d6			 
15d6			; Play a note 
15d6			; h = note 
15d6			; l = duration 
15d6			; a = channel 
15d6			 
15d6			;note:     
15d6			;	ret 
15d6			 
15d6			 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound.asm
15d6			endif  
15d6			  
15d6			include "firmware_diags.asm"  
15d6			; Hardware diags menu 
15d6			 
15d6			 
15d6			config: 
15d6			 
15d6 3e 00			ld a, 0 
15d8 21 06 16			ld hl, .configmn 
15db cd 49 0d			call menu 
15de			 
15de fe 00			cp 0 
15e0 c8				ret z 
15e1			 
15e1 fe 01			cp 1 
15e3 cc df 16			call z, .savetostore 
15e6			 
15e6 fe 02			cp 2 
15e8 cc 2d 16			call z, .selautoload 
15eb fe 03			cp 3 
15ed cc 16 16			call z, .disautoload 
15f0 fe 04			cp 4 
15f2 cc dd 16			call z, .selbank 
15f5 fe 05			cp 5 
15f7 cc ba 17			call z, .debug_tog 
15fa fe 06			cp 6 
15fc cc fd 18			call z, .bpsgo 
15ff fe 07			cp 7 
1601 cc e0 17			call z, hardware_diags 
1604			 
1604 18 d0			jr config 
1606			 
1606			.configmn: 
1606 ee 1a			dw prom_c3 
1608 05 1b			dw prom_c2 
160a 1a 1b			dw prom_c2a 
160c 30 1b			dw prom_c2b 
160e			;	dw prom_c4 
160e 4d 1b			dw prom_m4 
1610 68 1b			dw prom_m4b 
1612 70 1b			dw prom_c1 
1614 00 00			dw 0 
1616				 
1616			 
1616			 
1616			 
1616			.disautoload: 
1616				if STORAGE_SE 
1616 3e fe			ld a, $fe      ; bit 0 clear 
1618 32 67 fa			ld (spi_device), a 
161b			 
161b cd cd 04			call storage_get_block_0 
161e			 
161e 3e 00			ld a, 0 
1620 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
1623			 
1623 21 00 00				ld hl, 0 
1626 11 81 fa				ld de, store_page 
1629 cd 81 04			call storage_write_block	 ; save update 
162c				else 
162c			 
162c				ld hl, prom_notav 
162c				ld de, prom_empty 
162c				call info_panel 
162c				endif 
162c			 
162c			 
162c c9				ret 
162d			 
162d			 
162d			 
162d			; Select auto start 
162d			 
162d			.selautoload: 
162d			 
162d				 
162d				if STORAGE_SE 
162d			 
162d cd 04 17				call config_dir 
1630 21 fc f1			        ld hl, scratch 
1633 3e 00				ld a, 0 
1635 cd 49 0d				call menu 
1638			 
1638 fe 00				cp 0 
163a c8					ret z 
163b			 
163b 3d					dec a 
163c			 
163c			 
163c					; locate menu option 
163c			 
163c 21 fc f1				ld hl, scratch 
163f cd 6d 0c				call table_lookup 
1642			 
1642					if DEBUG_FORTH_WORDS 
1642						DMARK "ALl" 
1642 f5				push af  
1643 3a 57 16			ld a, (.dmark)  
1646 32 6e fe			ld (debug_mark),a  
1649 3a 58 16			ld a, (.dmark+1)  
164c 32 6f fe			ld (debug_mark+1),a  
164f 3a 59 16			ld a, (.dmark+2)  
1652 32 70 fe			ld (debug_mark+2),a  
1655 18 03			jr .pastdmark  
1657 ..			.dmark: db "ALl"  
165a f1			.pastdmark: pop af  
165b			endm  
# End of macro DMARK
165b						CALLMONITOR 
165b cd f3 18			call break_point_state  
165e				endm  
# End of macro CALLMONITOR
165e					endif 
165e					; with the pointer to the menu it, the byte following the zero term is the file id 
165e			 
165e 3e 00				ld a, 0 
1660 01 32 00				ld bc, 50   ; max of bytes to look at 
1663 ed b1				cpir  
1665			 
1665					if DEBUG_FORTH_WORDS 
1665						DMARK "ALb" 
1665 f5				push af  
1666 3a 7a 16			ld a, (.dmark)  
1669 32 6e fe			ld (debug_mark),a  
166c 3a 7b 16			ld a, (.dmark+1)  
166f 32 6f fe			ld (debug_mark+1),a  
1672 3a 7c 16			ld a, (.dmark+2)  
1675 32 70 fe			ld (debug_mark+2),a  
1678 18 03			jr .pastdmark  
167a ..			.dmark: db "ALb"  
167d f1			.pastdmark: pop af  
167e			endm  
# End of macro DMARK
167e						CALLMONITOR 
167e cd f3 18			call break_point_state  
1681				endm  
# End of macro CALLMONITOR
1681					endif 
1681					;inc hl 
1681			 
1681 7e					ld a, (hl)   ; file id 
1682					 
1682				        ; save bank and file ids 
1682			 
1682 f5					push af 
1683			 
1683			; TODO need to save to block 0 on bank 1	 
1683			 
1683 cd cd 04				call storage_get_block_0 
1686			 
1686					if DEBUG_FORTH_WORDS 
1686						DMARK "AL0" 
1686 f5				push af  
1687 3a 9b 16			ld a, (.dmark)  
168a 32 6e fe			ld (debug_mark),a  
168d 3a 9c 16			ld a, (.dmark+1)  
1690 32 6f fe			ld (debug_mark+1),a  
1693 3a 9d 16			ld a, (.dmark+2)  
1696 32 70 fe			ld (debug_mark+2),a  
1699 18 03			jr .pastdmark  
169b ..			.dmark: db "AL0"  
169e f1			.pastdmark: pop af  
169f			endm  
# End of macro DMARK
169f						CALLMONITOR 
169f cd f3 18			call break_point_state  
16a2				endm  
# End of macro CALLMONITOR
16a2					endif 
16a2 f1					pop af 
16a3			 
16a3 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
16a6					 
16a6					; save bank id 
16a6			 
16a6 3a 67 fa				ld a,(spi_device) 
16a9 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
16ac			 
16ac					; enable auto run of store file 
16ac			 
16ac 3e 01				ld a, 1 
16ae 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
16b1			 
16b1					; save buffer 
16b1			 
16b1 21 00 00				ld hl, 0 
16b4 11 81 fa				ld de, store_page 
16b7					if DEBUG_FORTH_WORDS 
16b7						DMARK "ALw" 
16b7 f5				push af  
16b8 3a cc 16			ld a, (.dmark)  
16bb 32 6e fe			ld (debug_mark),a  
16be 3a cd 16			ld a, (.dmark+1)  
16c1 32 6f fe			ld (debug_mark+1),a  
16c4 3a ce 16			ld a, (.dmark+2)  
16c7 32 70 fe			ld (debug_mark+2),a  
16ca 18 03			jr .pastdmark  
16cc ..			.dmark: db "ALw"  
16cf f1			.pastdmark: pop af  
16d0			endm  
# End of macro DMARK
16d0						CALLMONITOR 
16d0 cd f3 18			call break_point_state  
16d3				endm  
# End of macro CALLMONITOR
16d3					endif 
16d3 cd 81 04			call storage_write_block	 ; save update 
16d6			  
16d6			 
16d6			 
16d6			 
16d6 21 fc f1				ld hl, scratch 
16d9 cd f1 16				call config_fdir 
16dc			 
16dc				else 
16dc			 
16dc				ld hl, prom_notav 
16dc				ld de, prom_empty 
16dc				call info_panel 
16dc			 
16dc				endif 
16dc c9				ret 
16dd			 
16dd			 
16dd			 
16dd			; Select storage bank 
16dd			 
16dd			.selbank: 
16dd			 
16dd				if STORAGE_SE 
16dd				else 
16dd			 
16dd				ld hl, prom_notav 
16dd				ld de, prom_empty 
16dd				call info_panel 
16dd				endif 
16dd				 
16dd c9				ret 
16de			 
16de			if STORAGE_SE 
16de			 
16de			.config_ldir:   
16de				; Load storage bank labels into menu array 
16de			 
16de				 
16de			 
16de			 
16de c9				ret 
16df			 
16df			 
16df			endif 
16df			 
16df			 
16df			; Save user words to storage 
16df			 
16df			.savetostore: 
16df			 
16df				if STORAGE_SE 
16df			 
16df cd 04 17				call config_dir 
16e2 21 fc f1			        ld hl, scratch 
16e5 3e 00				ld a, 0 
16e7 cd 49 0d				call menu 
16ea					 
16ea 21 fc f1				ld hl, scratch 
16ed cd f1 16				call config_fdir 
16f0			 
16f0				else 
16f0			 
16f0				ld hl, prom_notav 
16f0				ld de, prom_empty 
16f0				call info_panel 
16f0			 
16f0				endif 
16f0			 
16f0 c9				ret 
16f1			 
16f1			 
16f1			 
16f1			if STORAGE_SE 
16f1			 
16f1			config_fdir: 
16f1				; using the scratch dir go through and release the memory allocated for each string 
16f1				 
16f1 21 fc f1			ld hl, scratch 
16f4 5e			.cfdir:	ld e,(hl) 
16f5 23				inc hl 
16f6 56				ld d,(hl) 
16f7 23				inc hl 
16f8			 
16f8 eb				ex de, hl 
16f9 cd 75 0f			call ishlzero 
16fc c8				ret z     ; return on null pointer 
16fd cd dd 14			call free 
1700 eb				ex de, hl 
1701 18 f1			jr .cfdir 
1703			 
1703			 
1703 c9				ret 
1704			 
1704			 
1704			config_dir: 
1704			 
1704				; for the config menus that need to build a directory of storage call this routine 
1704				; it will construct a menu in scratch to pass to menu 
1704			 
1704				; open storage device 
1704			 
1704				; execute DIR to build a list of files and their ids into scratch in menu format 
1704				; once the menu has finished then will need to call config_fdir to release the strings 
1704				 
1704				; c = number items 
1704			 
1704				 
1704 cd cd 04			call storage_get_block_0 
1707			 
1707 21 81 fa			ld hl, store_page     ; get current id count 
170a 46				ld b, (hl) 
170b 0e 00			ld c, 0    ; count of files   
170d			 
170d			 
170d 21 fc f1			ld hl, scratch 
1710 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
1713			 
1713				; check for empty drive 
1713			 
1713 3e 00			ld a, 0 
1715 b8				cp b 
1716 ca b0 17			jp z, .dirdone 
1719			 
1719				 
1719					if DEBUG_FORTH_WORDS 
1719						DMARK "Cdc" 
1719 f5				push af  
171a 3a 2e 17			ld a, (.dmark)  
171d 32 6e fe			ld (debug_mark),a  
1720 3a 2f 17			ld a, (.dmark+1)  
1723 32 6f fe			ld (debug_mark+1),a  
1726 3a 30 17			ld a, (.dmark+2)  
1729 32 70 fe			ld (debug_mark+2),a  
172c 18 03			jr .pastdmark  
172e ..			.dmark: db "Cdc"  
1731 f1			.pastdmark: pop af  
1732			endm  
# End of macro DMARK
1732						CALLMONITOR 
1732 cd f3 18			call break_point_state  
1735				endm  
# End of macro CALLMONITOR
1735					endif 
1735			 
1735			 
1735			.diritem:	 
1735 c5				push bc 
1736				; for each of the current ids do a search for them and if found push to stack 
1736			 
1736 21 40 00				ld hl, STORE_BLOCK_PHY 
1739 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
173b 58					ld e,b 
173c			 
173c cd 4f 07				call storage_findnextid 
173f			 
173f			 
173f					; if found hl will be non zero 
173f			 
173f cd 75 0f				call ishlzero 
1742 28 69				jr z, .dirnotfound 
1744			 
1744					; increase count 
1744			 
1744 c1					pop bc	 
1745 0c					inc c 
1746 c5					push bc 
1747					 
1747			 
1747					; get file header and push the file name 
1747			 
1747 11 81 fa				ld de, store_page 
174a cd 1c 04				call storage_read_block 
174d			 
174d					; push file id to stack 
174d				 
174d 3a 81 fa				ld a, (store_page) 
1750 26 00				ld h, 0 
1752 6f					ld l, a 
1753			 
1753					;call forth_push_numhl 
1753					; TODO store id 
1753			 
1753 e5					push hl 
1754			 
1754					; push extent count to stack  
1754				 
1754 21 84 fa				ld hl, store_page+3 
1757			 
1757					; get file name length 
1757			 
1757 cd aa 13				call strlenz   
175a			 
175a 23					inc hl   ; cover zero term 
175b 23					inc hl  ; stick the id at the end of the area 
175c			 
175c e5					push hl 
175d c1					pop bc    ; move length to bc 
175e			 
175e cd 13 14				call malloc 
1761			 
1761					; TODO save malloc area to scratch 
1761			 
1761 eb					ex de, hl 
1762 2a 78 fa				ld hl, (store_tmp2) 
1765 73					ld (hl), e 
1766 23					inc hl 
1767 72					ld (hl), d 
1768 23					inc hl 
1769 22 78 fa				ld (store_tmp2), hl 
176c			 
176c					 
176c			 
176c					;pop hl   ; get source 
176c			;		ex de, hl    ; swap aronund	 
176c			 
176c 21 84 fa				ld hl, store_page+3 
176f					if DEBUG_FORTH_WORDS 
176f						DMARK "CFd" 
176f f5				push af  
1770 3a 84 17			ld a, (.dmark)  
1773 32 6e fe			ld (debug_mark),a  
1776 3a 85 17			ld a, (.dmark+1)  
1779 32 6f fe			ld (debug_mark+1),a  
177c 3a 86 17			ld a, (.dmark+2)  
177f 32 70 fe			ld (debug_mark+2),a  
1782 18 03			jr .pastdmark  
1784 ..			.dmark: db "CFd"  
1787 f1			.pastdmark: pop af  
1788			endm  
# End of macro DMARK
1788						CALLMONITOR 
1788 cd f3 18			call break_point_state  
178b				endm  
# End of macro CALLMONITOR
178b					endif 
178b ed b0				ldir 
178d			 
178d					; de is past string, move back one and store id 
178d					 
178d 1b					dec de 
178e			 
178e					; store file id 
178e			 
178e e1					pop hl 
178f eb					ex de,hl 
1790 73					ld (hl), e 
1791			 
1791					if DEBUG_FORTH_WORDS 
1791						DMARK "Cdi" 
1791 f5				push af  
1792 3a a6 17			ld a, (.dmark)  
1795 32 6e fe			ld (debug_mark),a  
1798 3a a7 17			ld a, (.dmark+1)  
179b 32 6f fe			ld (debug_mark+1),a  
179e 3a a8 17			ld a, (.dmark+2)  
17a1 32 70 fe			ld (debug_mark+2),a  
17a4 18 03			jr .pastdmark  
17a6 ..			.dmark: db "Cdi"  
17a9 f1			.pastdmark: pop af  
17aa			endm  
# End of macro DMARK
17aa						CALLMONITOR 
17aa cd f3 18			call break_point_state  
17ad				endm  
# End of macro CALLMONITOR
17ad					endif 
17ad					 
17ad			.dirnotfound: 
17ad c1					pop bc     
17ae 10 85				djnz .diritem 
17b0				 
17b0			.dirdone:	 
17b0			 
17b0 3e 00				ld a, 0 
17b2 2a 78 fa				ld hl, (store_tmp2) 
17b5 77					ld (hl), a 
17b6 23					inc hl 
17b7 77					ld (hl), a 
17b8 23					inc hl 
17b9					; push a count of the dir items found 
17b9			 
17b9			;		ld h, 0 
17b9			;		ld l, c 
17b9			 
17b9 c9				ret 
17ba			 
17ba			endif 
17ba			 
17ba			 
17ba			; Settings 
17ba			; Run  
17ba			 
17ba			 
17ba			 
17ba			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17ba			;;hd_menu2:   db "        2: Editor",0   
17ba			;hd_menu2:   db "        2: Editor       6: Menu",0   
17ba			;hd_menu3:   db "        3: Storage",0 
17ba			;hd_menu4:   db "0=quit  4: Debug",0 
17ba			;hd_don:     db "ON",0 
17ba			;hd_doff:     db "OFF",0 
17ba			; 
17ba			; 
17ba			; 
17ba			;hardware_diags_old:       
17ba			; 
17ba			;.diagmenu: 
17ba			;	call clear_display 
17ba			;	ld a, display_row_1 
17ba			;	ld de, hd_menu1 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_2 
17ba			;	ld de, hd_menu2 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_3 
17ba			;	ld de, hd_menu3 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a,  display_row_4 
17ba			;	ld de, hd_menu4 
17ba			;	call str_at_display 
17ba			; 
17ba			;	; display debug state 
17ba			; 
17ba			;	ld de, hd_don 
17ba			;	ld a, (os_view_disable) 
17ba			;	cp 0 
17ba			;	jr z, .distog 
17ba			;	ld de, hd_doff 
17ba			;.distog: ld a, display_row_4+17 
17ba			;	call str_at_display 
17ba			; 
17ba			;	call update_display 
17ba			; 
17ba			;	call cin_wait 
17ba			; 
17ba			; 
17ba			; 
17ba			;	cp '4' 
17ba			;	jr nz, .diagn1 
17ba			; 
17ba			;	; debug toggle 
17ba			; 
17ba			;	ld a, (os_view_disable) 
17ba			;	ld b, '*' 
17ba			;	cp 0 
17ba			;	jr z, .debtog 
17ba			;	ld b, 0 
17ba			;.debtog:	 
17ba			;	ld a,b 
17ba			;	ld (os_view_disable),a 
17ba			; 
17ba			;.diagn1: cp '0' 
17ba			;	 ret z 
17ba			; 
17ba			;;	cp '1' 
17ba			;;       jp z, matrix	 
17ba			;;   TODO keyboard matrix test 
17ba			; 
17ba			;	cp '2' 
17ba			;	jp z, .diagedit 
17ba			; 
17ba			;;	cp '6' 
17ba			;;	jp z, .menutest 
17ba			;;if ENABLE_BASIC 
17ba			;;	cp '6' 
17ba			;;	jp z, basic 
17ba			;;endif 
17ba			 ; 
17ba			;	jp .diagmenu 
17ba			; 
17ba			; 
17ba			;	ret 
17ba			 
17ba			 
17ba			.debug_tog: 
17ba 21 01 18			ld hl, .menudebug 
17bd				 
17bd 3a ed f1			ld a, (os_view_disable) 
17c0 fe 2a			cp '*' 
17c2 20 04			jr nz,.tdon  
17c4 3e 01			ld a, 1 
17c6 18 02			jr .tog1 
17c8 3e 00		.tdon: ld a, 0 
17ca			 
17ca			.tog1: 
17ca cd 49 0d			call menu 
17cd fe 00			cp 0 
17cf c8				ret z 
17d0 fe 01			cp 1    ; disable debug 
17d2 28 04			jr z, .dtog0 
17d4 3e 2a			ld a, '*' 
17d6 18 02			jr .dtogset 
17d8 3e 00		.dtog0: ld a, 0 
17da 32 ed f1		.dtogset:  ld (os_view_disable), a 
17dd c3 ba 17			jp .debug_tog 
17e0			 
17e0			 
17e0			hardware_diags:       
17e0			 
17e0			.diagm: 
17e0 21 f3 17			ld hl, .menuitems 
17e3 3e 00			ld a, 0 
17e5 cd 49 0d			call menu 
17e8			 
17e8 fe 00		         cp 0 
17ea c8				 ret z 
17eb			 
17eb fe 02			cp 2 
17ed ca 4c 18			jp z, .diagedit 
17f0			 
17f0			;	cp '6' 
17f0			;	jp z, .menutest 
17f0			;if ENABLE_BASIC 
17f0			;	cp '6' 
17f0			;	jp z, basic 
17f0			;endif 
17f0			  
17f0 c3 e0 17			jp .diagm 
17f3			 
17f3				 
17f3 07 18		.menuitems:   	dw .m1 
17f5 12 18				dw .m2 
17f7 19 18				dw .m3 
17f9 21 18				dw .m5 
17fb 27 18				dw .m5a 
17fd 30 18				dw .m5b 
17ff 00 00				dw 0 
1801			 
1801			.menudebug: 
1801 39 18				dw .m6 
1803 42 18				dw .m7 
1805 00 00				dw 0 
1807			 
1807 .. 00		.m1:   db "Key Matrix",0 
1812 .. 00		.m2:   db "Editor",0 
1819 .. 00		.m3:   db "Storage",0 
1821 .. 00		.m5:   db "Sound",0 
1827 .. 00		.m5a:  db "RAM Test",0 
1830 .. 00		.m5b:  db "LCD Test",0 
1839			 
1839 .. 00		.m6:   db "Debug ON",0 
1842 .. 00		.m7:   db "Debug OFF",0 
184c			 
184c			; debug editor 
184c			 
184c			.diagedit: 
184c			 
184c 21 fc f1			ld hl, scratch 
184f			;	ld bc, 250 
184f			;	ldir 
184f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
184f 3e 00			ld a, 0 
1851 77				ld (hl), a 
1852 23				inc hl 
1853 77				ld (hl), a 
1854 23				inc hl 
1855 77				ld (hl), a 
1856			 
1856 cd 18 0d		        call clear_display 
1859 cd 3b 0d			call update_display 
185c				;ld a, 1 
185c				;ld (hardware_diag), a 
185c			.diloop: 
185c 3e 00			ld a, display_row_1 
185e 0e 00			ld c, 0 
1860 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1862 1e 28			ld e, 40 
1864			 
1864 21 fc f1			ld hl, scratch	 
1867 cd 79 0f			call input_str 
186a			 
186a 3e 28			ld a, display_row_2 
186c 11 fc f1			ld de, scratch 
186f cd 2b 0d			call str_at_display 
1872 cd 3b 0d			call update_display 
1875			 
1875 c3 5c 18			jp .diloop 
1878			 
1878			 
1878			; pass word in hl 
1878			; a has display location 
1878			display_word_at: 
1878 f5				push af 
1879 e5				push hl 
187a 7c				ld a,h 
187b 21 01 f5			ld hl, os_word_scratch 
187e cd 4d 12			call hexout 
1881 e1				pop hl 
1882 7d				ld a,l 
1883 21 03 f5			ld hl, os_word_scratch+2 
1886 cd 4d 12			call hexout 
1889 21 05 f5			ld hl, os_word_scratch+4 
188c 3e 00			ld a,0 
188e 77				ld (hl),a 
188f 11 01 f5			ld de,os_word_scratch 
1892 f1				pop af 
1893 cd 2b 0d				call str_at_display 
1896 c9				ret 
1897			 
1897			display_ptr_state: 
1897			 
1897				; to restore afterwards 
1897			 
1897 d5				push de 
1898 c5				push bc 
1899 e5				push hl 
189a f5				push af 
189b			 
189b				; for use in here 
189b			 
189b			;	push bc 
189b			;	push de 
189b			;	push hl 
189b			;	push af 
189b			 
189b cd 18 0d			call clear_display 
189e			 
189e 11 71 1a			ld de, .ptrstate 
18a1 3e 00			ld a, display_row_1 
18a3 cd 2b 0d			call str_at_display 
18a6			 
18a6				; display debug step 
18a6			 
18a6			 
18a6 11 6e fe			ld de, debug_mark 
18a9 3e 26			ld a, display_row_1+display_cols-2 
18ab cd 2b 0d			call str_at_display 
18ae			 
18ae				; display a 
18ae 11 7b 1a			ld de, .ptrcliptr 
18b1 3e 28			ld a, display_row_2 
18b3 cd 2b 0d			call str_at_display 
18b6			 
18b6 f1				pop af 
18b7 2a 47 fa			ld hl,(cli_ptr) 
18ba 3e 30			ld a, display_row_2+8 
18bc cd 78 18			call display_word_at 
18bf			 
18bf			 
18bf				; display hl 
18bf			 
18bf			 
18bf 11 83 1a			ld de, .ptrclioptr 
18c2 3e 32			ld a, display_row_2+10 
18c4 cd 2b 0d			call str_at_display 
18c7			; 
18c7			;	pop hl 
18c7 3e 35			ld a, display_row_2+13 
18c9 2a 45 fa			ld hl,(cli_origptr) 
18cc cd 78 18			call display_word_at 
18cf			; 
18cf			;	 
18cf			;	; display de 
18cf			 
18cf			;	ld de, .regstatede 
18cf			;	ld a, display_row_3 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop de 
18cf			;	ld h,d 
18cf			;	ld l, e 
18cf			;	ld a, display_row_3+3 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display bc 
18cf			 
18cf			;	ld de, .regstatebc 
18cf			;	ld a, display_row_3+10 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop bc 
18cf			;	ld h,b 
18cf			;	ld l, c 
18cf			;	ld a, display_row_3+13 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display dsp 
18cf			 
18cf			;	ld de, .regstatedsp 
18cf			;	ld a, display_row_4 
18cf			;	call str_at_display 
18cf			 
18cf				 
18cf			;	ld hl,(cli_data_sp) 
18cf			;	ld a, display_row_4+4 
18cf			;	call display_word_at 
18cf			 
18cf				; display rsp 
18cf			 
18cf 11 b2 1a			ld de, .regstatersp 
18d2 3e 82			ld a, display_row_4+10 
18d4 cd 2b 0d			call str_at_display 
18d7			 
18d7				 
18d7 2a 2d fa			ld hl,(cli_ret_sp) 
18da 3e 86			ld a, display_row_4+14 
18dc cd 78 18			call display_word_at 
18df			 
18df cd 3b 0d			call update_display 
18e2			 
18e2 cd 95 0c			call delay1s 
18e5 cd 95 0c			call delay1s 
18e8 cd 95 0c			call delay1s 
18eb			 
18eb			 
18eb cd df 1e			call next_page_prompt 
18ee			 
18ee				; restore  
18ee			 
18ee f1				pop af 
18ef e1				pop hl 
18f0 c1				pop bc 
18f1 d1				pop de 
18f2 c9				ret 
18f3			 
18f3			break_point_state: 
18f3 f5				push af 
18f4			 
18f4				; see if disabled 
18f4			 
18f4 3a ed f1			ld a, (os_view_disable) 
18f7 fe 2a			cp '*' 
18f9 20 02			jr nz, .bpsgo 
18fb f1				pop af 
18fc c9				ret 
18fd			 
18fd			.bpsgo: 
18fd f1				pop af 
18fe f5				push af 
18ff 22 e9 f1			ld (os_view_hl), hl 
1902 ed 53 e7 f1		ld (os_view_de), de 
1906 ed 43 e5 f1		ld (os_view_bc), bc 
190a e5				push hl 
190b 6f				ld l, a 
190c 26 00			ld h, 0 
190e 22 eb f1			ld (os_view_af),hl 
1911			 
1911 21 b4 fd				ld hl, display_fb0 
1914 22 cf fb				ld (display_fb_active), hl 
1917 e1				pop hl	 
1918			 
1918 3e 31			ld a, '1' 
191a fe 2a		.bps1:  cp '*' 
191c 20 03			jr nz, .bps1b 
191e 32 ed f1			ld (os_view_disable),a 
1921 fe 31		.bps1b:  cp '1' 
1923 20 14			jr nz, .bps2 
1925			 
1925				; display reg 
1925			 
1925				 
1925			 
1925 3a eb f1			ld a, (os_view_af) 
1928 2a e9 f1			ld hl, (os_view_hl) 
192b ed 5b e7 f1		ld de, (os_view_de) 
192f ed 4b e5 f1		ld bc, (os_view_bc) 
1933 cd cd 19			call display_reg_state 
1936 c3 b9 19			jp .bpschk 
1939			 
1939 fe 32		.bps2:  cp '2' 
193b 20 08			jr nz, .bps3 
193d				 
193d				; display hl 
193d 2a e9 f1			ld hl, (os_view_hl) 
1940 cd b7 1a			call display_dump_at_hl 
1943			 
1943 18 74			jr .bpschk 
1945			 
1945 fe 33		.bps3:  cp '3' 
1947 20 08			jr nz, .bps4 
1949			 
1949			        ; display de 
1949 2a e7 f1			ld hl, (os_view_de) 
194c cd b7 1a			call display_dump_at_hl 
194f			 
194f 18 68			jr .bpschk 
1951 fe 34		.bps4:  cp '4' 
1953 20 08			jr nz, .bps5 
1955			 
1955			        ; display bc 
1955 2a e5 f1			ld hl, (os_view_bc) 
1958 cd b7 1a			call display_dump_at_hl 
195b			 
195b 18 5c			jr .bpschk 
195d fe 35		.bps5:  cp '5' 
195f 20 08		        jr nz, .bps7 
1961			 
1961				; display cur ptr 
1961 2a 47 fa			ld hl, (cli_ptr) 
1964 cd b7 1a			call display_dump_at_hl 
1967			 
1967 18 50			jr .bpschk 
1969 fe 36		.bps7:  cp '6' 
196b 20 08			jr nz, .bps8b 
196d				 
196d				; display cur orig ptr 
196d 2a 45 fa			ld hl, (cli_origptr) 
1970 cd b7 1a			call display_dump_at_hl 
1973 18 44			jr .bpschk 
1975 fe 37		.bps8b:  cp '7' 
1977 20 08			jr nz, .bps9 
1979				 
1979				; display dsp 
1979 2a 29 fa			ld hl, (cli_data_sp) 
197c cd b7 1a			call display_dump_at_hl 
197f			 
197f 18 38			jr .bpschk 
1981 fe 39		.bps9:  cp '9' 
1983 20 05			jr nz, .bps8c 
1985				 
1985				; display SP 
1985			;	ld hl, sp 
1985 cd b7 1a			call display_dump_at_hl 
1988			 
1988 18 2f			jr .bpschk 
198a fe 38		.bps8c:  cp '8' 
198c 20 08			jr nz, .bps8d 
198e				 
198e				; display rsp 
198e 2a 2d fa			ld hl, (cli_ret_sp) 
1991 cd b7 1a			call display_dump_at_hl 
1994			 
1994 18 23			jr .bpschk 
1996 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1998 20 05			jr nz, .bps8 
199a cd d5 1c			call monitor 
199d			 
199d 18 1a			jr .bpschk 
199f fe 30		.bps8:  cp '0' 
19a1 20 16			jr nz, .bpschk 
19a3			 
19a3 21 13 fd				ld hl, display_fb1 
19a6 22 cf fb				ld (display_fb_active), hl 
19a9 cd 3b 0d				call update_display 
19ac			 
19ac				;ld a, (os_view_af) 
19ac 2a e9 f1			ld hl, (os_view_hl) 
19af ed 5b e7 f1		ld de, (os_view_de) 
19b3 ed 4b e5 f1		ld bc, (os_view_bc) 
19b7 f1				pop af 
19b8 c9				ret 
19b9			 
19b9			.bpschk:   
19b9 cd 95 0c			call delay1s 
19bc 3e 9f		ld a,display_row_4 + display_cols - 1 
19be 11 dd 1e		        ld de, endprg 
19c1 cd 2b 0d			call str_at_display 
19c4 cd 3b 0d			call update_display 
19c7 cd fe 70			call cin_wait 
19ca			 
19ca c3 1a 19			jp .bps1 
19cd			 
19cd			 
19cd			display_reg_state: 
19cd			 
19cd				; to restore afterwards 
19cd			 
19cd d5				push de 
19ce c5				push bc 
19cf e5				push hl 
19d0 f5				push af 
19d1			 
19d1				; for use in here 
19d1			 
19d1 c5				push bc 
19d2 d5				push de 
19d3 e5				push hl 
19d4 f5				push af 
19d5			 
19d5 cd 18 0d			call clear_display 
19d8			 
19d8 11 8d 1a			ld de, .regstate 
19db 3e 00			ld a, display_row_1 
19dd cd 2b 0d			call str_at_display 
19e0			 
19e0				; display debug step 
19e0			 
19e0			 
19e0 11 6e fe			ld de, debug_mark 
19e3 3e 25			ld a, display_row_1+display_cols-3 
19e5 cd 2b 0d			call str_at_display 
19e8			 
19e8				; display a 
19e8 11 a9 1a			ld de, .regstatea 
19eb 3e 28			ld a, display_row_2 
19ed cd 2b 0d			call str_at_display 
19f0			 
19f0 e1				pop hl 
19f1			;	ld h,0 
19f1			;	ld l, a 
19f1 3e 2b			ld a, display_row_2+3 
19f3 cd 78 18			call display_word_at 
19f6			 
19f6			 
19f6				; display hl 
19f6			 
19f6			 
19f6 11 9d 1a			ld de, .regstatehl 
19f9 3e 32			ld a, display_row_2+10 
19fb cd 2b 0d			call str_at_display 
19fe			 
19fe e1				pop hl 
19ff 3e 35			ld a, display_row_2+13 
1a01 cd 78 18			call display_word_at 
1a04			 
1a04				 
1a04				; display de 
1a04			 
1a04 11 a1 1a			ld de, .regstatede 
1a07 3e 50			ld a, display_row_3 
1a09 cd 2b 0d			call str_at_display 
1a0c			 
1a0c e1				pop hl 
1a0d			;	ld h,d 
1a0d			;	ld l, e 
1a0d 3e 53			ld a, display_row_3+3 
1a0f cd 78 18			call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12 11 a5 1a			ld de, .regstatebc 
1a15 3e 5a			ld a, display_row_3+10 
1a17 cd 2b 0d			call str_at_display 
1a1a			 
1a1a e1				pop hl 
1a1b			;	ld h,b 
1a1b			;	ld l, c 
1a1b 3e 5d			ld a, display_row_3+13 
1a1d cd 78 18			call display_word_at 
1a20			 
1a20			 
1a20				; display dsp 
1a20			 
1a20 11 ad 1a			ld de, .regstatedsp 
1a23 3e 78			ld a, display_row_4 
1a25 cd 2b 0d			call str_at_display 
1a28			 
1a28				 
1a28 2a 29 fa			ld hl,(cli_data_sp) 
1a2b 3e 7c			ld a, display_row_4+4 
1a2d cd 78 18			call display_word_at 
1a30			 
1a30				; display rsp 
1a30			 
1a30 11 b2 1a			ld de, .regstatersp 
1a33 3e 82			ld a, display_row_4+10 
1a35 cd 2b 0d			call str_at_display 
1a38			 
1a38				 
1a38 2a 2d fa			ld hl,(cli_ret_sp) 
1a3b 3e 86			ld a, display_row_4+14 
1a3d cd 78 18			call display_word_at 
1a40			 
1a40 cd 3b 0d			call update_display 
1a43			 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			 
1a43			 
1a43			;	call next_page_prompt 
1a43			 
1a43				; restore  
1a43			 
1a43 f1				pop af 
1a44 e1				pop hl 
1a45 c1				pop bc 
1a46 d1				pop de 
1a47 c9				ret 
1a48			 
1a48 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a5c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a71 .. 00		.ptrstate:	db "Ptr State",0 
1a7b .. 00		.ptrcliptr:     db "cli_ptr",0 
1a83 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a8d .. 00		.regstate:	db "Reg State (1/0)",0 
1a9d .. 00		.regstatehl:	db "HL:",0 
1aa1 .. 00		.regstatede:	db "DE:",0 
1aa5 .. 00		.regstatebc:	db "BC:",0 
1aa9 .. 00		.regstatea:	db "A :",0 
1aad .. 00		.regstatedsp:	db "DSP:",0 
1ab2 .. 00		.regstatersp:	db "RSP:",0 
1ab7			 
1ab7			display_dump_at_hl: 
1ab7 e5				push hl 
1ab8 d5				push de 
1ab9 c5				push bc 
1aba f5				push af 
1abb			 
1abb 22 1f f5			ld (os_cur_ptr),hl	 
1abe cd 18 0d			call clear_display 
1ac1 cd e7 1d			call dumpcont 
1ac4			;	call delay1s 
1ac4			;	call next_page_prompt 
1ac4			 
1ac4			 
1ac4 f1				pop af 
1ac5 c1				pop bc 
1ac6 d1				pop de 
1ac7 e1				pop hl 
1ac8 c9				ret 
1ac9			 
1ac9			;if ENABLE_BASIC 
1ac9			;	include "nascombasic.asm" 
1ac9			;	basic: 
1ac9			;	include "forth/FORTH.ASM" 
1ac9			;endif 
1ac9			 
1ac9			; eof 
1ac9			 
1ac9			 
# End of file firmware_diags.asm
1ac9			  
1ac9			include "firmware_prompts.asm"  
1ac9			; Prompts  
1ac9			 
1ac9			; boot messages 
1ac9			 
1ac9 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ade .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1aee			 
1aee			 
1aee			; config menus 
1aee			 
1aee .. 00		prom_c3: db "Add Dictionary To File",0 
1b05 .. 00		prom_c2: db "Select Autoload File",0 
1b1a .. 00		prom_c2a: db "Disable Autoload File", 0 
1b30 .. 00		prom_c2b: db "Select Storage Bank",0 
1b44 .. 00		prom_c4: db "Settings",0 
1b4d .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b68 .. 00		prom_m4b:   db "Monitor",0 
1b70 .. 00		prom_c1: db "Hardware Diags",0 
1b7f			 
1b7f			 
1b7f .. 00		prom_notav:    db "Feature not available",0 
1b95 .. 00		prom_empty:    db "",0 
1b96			 
1b96			; eof 
1b96			 
# End of file firmware_prompts.asm
1b96			  
1b96			  
1b96			; eof  
1b96			  
# End of file firmware.asm
1b96			 
1b96			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b96			;if BASE_KEV  
1b96			;baseram: equ 08000h 
1b96			;endif 
1b96			 
1b96			;if BASE_SC114 
1b96			;baseram:     equ    endofcode 
1b96			;endif 
1b96			 
1b96			 
1b96			; start system 
1b96			 
1b96			coldstart: 
1b96				; set sp 
1b96				; di/ei 
1b96			 
1b96 f3				di 
1b97 31 fd ff			ld sp, tos 
1b9a			;	ei 
1b9a			 
1b9a			 
1b9a				; disable breakpoint by default 
1b9a			 
1b9a 3e 2a			ld a,'*' 
1b9c 32 ed f1			ld (os_view_disable),a 
1b9f			 
1b9f				; init hardware 
1b9f			 
1b9f				; init keyboard and screen hardware 
1b9f			 
1b9f cd 1c 00			call hardware_init 
1ba2			 
1ba2			 
1ba2 cd 95 0c			call delay1s 
1ba5 3e 58			ld a, display_row_3+8 
1ba7 11 03 00			ld de, buildtime 
1baa cd 2b 0d			call str_at_display 
1bad cd 3b 0d			call update_display 
1bb0			 
1bb0 cd 95 0c			call delay1s 
1bb3 cd 95 0c			call delay1s 
1bb6 cd 95 0c			call delay1s 
1bb9			 
1bb9				; detect if any keys are held down to enable breakpoints at start up 
1bb9			 
1bb9 cd 0f 71			call cin  
1bbc fe 00			cp 0 
1bbe 28 03			jr z, .nokeys 
1bc0			 
1bc0				;call hardware_diags 
1bc0 cd d6 15			call config 
1bc3			 
1bc3			;	ld de, .bpen 
1bc3			;	ld a, display_row_4 
1bc3			;	call str_at_display 
1bc3			;	call update_display 
1bc3			; 
1bc3			;	ld a,0 
1bc3			;	ld (os_view_disable),a 
1bc3			; 
1bc3			;.bpwait: 
1bc3			;	call cin 
1bc3			;	cp 0 
1bc3			;	jr z, .bpwait 
1bc3			;	jr .nokeys 
1bc3			; 
1bc3			; 
1bc3			;.bpen:  db "Break points enabled!",0 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			.nokeys: 
1bc3			 
1bc3			 
1bc3				 
1bc3			 
1bc3			;jp  testkey 
1bc3			 
1bc3			;call storage_get_block_0 
1bc3			; 
1bc3			;ld hl, 0 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3				 
1bc3			;ld hl, 10 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			;stop:	nop 
1bc3			;	jp stop 
1bc3			 
1bc3			 
1bc3			 
1bc3			main: 
1bc3 cd 18 0d			call clear_display 
1bc6 cd 3b 0d			call update_display 
1bc9			 
1bc9			 
1bc9			 
1bc9			;	call testlcd 
1bc9			 
1bc9			 
1bc9			 
1bc9 cd a5 22			call forth_init 
1bcc			 
1bcc			 
1bcc			warmstart: 
1bcc cd 7b 22			call forth_warmstart 
1bcf			 
1bcf				; run startup word load 
1bcf			        ; TODO prevent this running at warmstart after crash  
1bcf			 
1bcf				if STARTUP_ENABLE 
1bcf					if STORAGE_SE 
1bcf cd 9d 6c					call forth_autoload 
1bd2					endif 
1bd2 cd ac 69				call forth_startup 
1bd5			 
1bd5			 
1bd5				endif 
1bd5			 
1bd5				; show free memory after boot 
1bd5 11 6f 1c			ld de, freeram 
1bd8 3e 00			ld a, display_row_1 
1bda cd 2b 0d			call str_at_display 
1bdd			 
1bdd			; Or use heap_size word???? 
1bdd 21 e2 f1			ld hl, heap_end 
1be0 11 0e 80			ld de, heap_start 
1be3 ed 52			sbc hl, de 
1be5 e5				push hl 
1be6 7c				ld a,h	         	 
1be7 21 01 f5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bea cd 4d 12			call hexout 
1bed e1			   	pop hl 
1bee			 
1bee 7d				ld a,l 
1bef 21 03 f5			ld hl, os_word_scratch+2 
1bf2 cd 4d 12			call hexout 
1bf5 21 05 f5			ld hl, os_word_scratch+4 
1bf8 3e 00			ld a, 0 
1bfa 77				ld (hl),a 
1bfb 11 01 f5			ld de, os_word_scratch 
1bfe 3e 0d			ld a, display_row_1 + 13 
1c00 cd 2b 0d			call str_at_display 
1c03 cd 3b 0d			call update_display 
1c06			 
1c06			 
1c06				;call demo 
1c06			 
1c06			 
1c06				; init scratch input area for cli commands 
1c06			 
1c06 21 23 f5			ld hl, os_cli_cmd 
1c09 3e 00			ld a,0 
1c0b 77				ld (hl),a 
1c0c 23				inc hl 
1c0d 77				ld (hl),a 
1c0e			 
1c0e 3e 00			ld a,0 
1c10 32 22 f6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c13			 
1c13 32 1f f5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c16 32 20 f5			ld (os_cur_ptr+1),a	 
1c19			 
1c19 32 01 f5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c1c 32 02 f5			ld (os_word_scratch+1),a	 
1c1f				 
1c1f			 
1c1f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c1f 21 23 f5			ld hl, os_cli_cmd 
1c22			 
1c22 3e 00			ld a, 0		 ; init cli input 
1c24 77				ld (hl), a 
1c25 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c27			cli: 
1c27				; show cli prompt 
1c27				;push af 
1c27				;ld a, 0 
1c27				;ld de, prompt 
1c27				;call str_at_display 
1c27			 
1c27				;call update_display 
1c27				;pop af 
1c27				;inc a 
1c27				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c27 0e 00			ld c, 0 
1c29 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c2b 1e 28			ld e, 40 
1c2d			 
1c2d 21 23 f5			ld hl, os_cli_cmd 
1c30			 
1c30				STACKFRAME OFF $fefe $9f9f 
1c30				if DEBUG_STACK_IMB 
1c30					if OFF 
1c30						exx 
1c30						ld de, $fefe 
1c30						ld a, d 
1c30						ld hl, curframe 
1c30						call hexout 
1c30						ld a, e 
1c30						ld hl, curframe+2 
1c30						call hexout 
1c30						ld hl, $fefe 
1c30						push hl 
1c30						ld hl, $9f9f 
1c30						push hl 
1c30						exx 
1c30					endif 
1c30				endif 
1c30			endm 
# End of macro STACKFRAME
1c30			 
1c30 cd 79 0f			call input_str 
1c33			 
1c33				STACKFRAMECHK OFF $fefe $9f9f 
1c33				if DEBUG_STACK_IMB 
1c33					if OFF 
1c33						exx 
1c33						ld hl, $9f9f 
1c33						pop de   ; $9f9f 
1c33						call cmp16 
1c33						jr nz, .spnosame 
1c33						ld hl, $fefe 
1c33						pop de   ; $fefe 
1c33						call cmp16 
1c33						jr z, .spfrsame 
1c33						.spnosame: call showsperror 
1c33						.spfrsame: nop 
1c33						exx 
1c33					endif 
1c33				endif 
1c33			endm 
# End of macro STACKFRAMECHK
1c33			 
1c33				; copy input to last command 
1c33			 
1c33 21 23 f5			ld hl, os_cli_cmd 
1c36 11 22 f6			ld de, os_last_cmd 
1c39 01 ff 00			ld bc, 255 
1c3c ed b0			ldir 
1c3e			 
1c3e				; wipe current buffer 
1c3e			 
1c3e			;	ld a, 0 
1c3e			;	ld hl, os_cli_cmd 
1c3e			;	ld de, os_cli_cmd+1 
1c3e			;	ld bc, 254 
1c3e			;	ldir 
1c3e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c3e			;	call strcpy 
1c3e			;	ld a, 0 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			 
1c3e				; switch frame buffer to program  
1c3e			 
1c3e 21 13 fd				ld hl, display_fb1 
1c41 22 cf fb				ld (display_fb_active), hl 
1c44			 
1c44			;	nop 
1c44				STACKFRAME ON $fbfe $8f9f 
1c44				if DEBUG_STACK_IMB 
1c44					if ON 
1c44						exx 
1c44						ld de, $fbfe 
1c44						ld a, d 
1c44						ld hl, curframe 
1c44						call hexout 
1c44						ld a, e 
1c44						ld hl, curframe+2 
1c44						call hexout 
1c44						ld hl, $fbfe 
1c44						push hl 
1c44						ld hl, $8f9f 
1c44						push hl 
1c44						exx 
1c44					endif 
1c44				endif 
1c44			endm 
# End of macro STACKFRAME
1c44				; first time into the parser so pass over the current scratch pad 
1c44 21 23 f5			ld hl,os_cli_cmd 
1c47				; tokenise the entered statement(s) in HL 
1c47 cd 23 23			call forthparse 
1c4a			        ; exec forth statements in top of return stack 
1c4a cd 63 23			call forthexec 
1c4d				;call forthexec_cleanup 
1c4d			;	call parsenext 
1c4d			 
1c4d				STACKFRAMECHK ON $fbfe $8f9f 
1c4d				if DEBUG_STACK_IMB 
1c4d					if ON 
1c4d						exx 
1c4d						ld hl, $8f9f 
1c4d						pop de   ; $8f9f 
1c4d						call cmp16 
1c4d						jr nz, .spnosame 
1c4d						ld hl, $fbfe 
1c4d						pop de   ; $fbfe 
1c4d						call cmp16 
1c4d						jr z, .spfrsame 
1c4d						.spnosame: call showsperror 
1c4d						.spfrsame: nop 
1c4d						exx 
1c4d					endif 
1c4d				endif 
1c4d			endm 
# End of macro STACKFRAMECHK
1c4d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c4d			 
1c4d 3e 78			ld a, display_row_4 
1c4f 11 81 1c			ld de, endprog 
1c52			 
1c52 cd 3b 0d			call update_display		 
1c55			 
1c55 cd df 1e			call next_page_prompt 
1c58			 
1c58				; switch frame buffer to cli 
1c58			 
1c58 21 b4 fd				ld hl, display_fb0 
1c5b 22 cf fb				ld (display_fb_active), hl 
1c5e			 
1c5e			 
1c5e cd 18 0d		        call clear_display 
1c61 cd 3b 0d			call update_display		 
1c64			 
1c64 21 23 f5			ld hl, os_cli_cmd 
1c67			 
1c67 3e 00			ld a, 0		 ; init cli input 
1c69 77				ld (hl), a 
1c6a			 
1c6a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c6a			 
1c6a				; now on last line 
1c6a			 
1c6a				; TODO scroll screen up 
1c6a			 
1c6a				; TODO instead just clear screen and place at top of screen 
1c6a			 
1c6a			;	ld a, 0 
1c6a			;	ld (f_cursor_ptr),a 
1c6a			 
1c6a				;call clear_display 
1c6a				;call update_display 
1c6a			 
1c6a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6c c3 27 1c			jp cli 
1c6f			 
1c6f .. 00		freeram: db "Free bytes: $",0 
1c7d ..			asc: db "1A2F" 
1c81 .. 00		endprog: db "End prog...",0 
1c8d			 
1c8d			testenter2:   
1c8d 21 2e f2			ld hl,scratch+50 
1c90 22 1f f5			ld (os_cur_ptr),hl 
1c93 c3 27 1c			jp cli 
1c96			 
1c96			testenter:  
1c96			 
1c96 21 7d 1c			ld hl,asc 
1c99			;	ld a,(hl) 
1c99			;	call nibble2val 
1c99 cd a3 12			call get_byte 
1c9c			 
1c9c			 
1c9c			;	ld a,(hl) 
1c9c			;	call atohex 
1c9c			 
1c9c			;	call fourehexhl 
1c9c 32 2e f2			ld (scratch+50),a 
1c9f			 
1c9f			 
1c9f			 
1c9f 21 7f 1c			ld hl,asc+2 
1ca2			;	ld a, (hl) 
1ca2			;	call nibble2val 
1ca2 cd a3 12			call get_byte 
1ca5			 
1ca5			;	call fourehexhl 
1ca5 32 30 f2			ld (scratch+52),a 
1ca8				 
1ca8 21 2e f2			ld hl,scratch+50 
1cab 22 1f f5			ld (os_cur_ptr),hl 
1cae c3 27 1c			jp cli 
1cb1			 
1cb1			enter:	 
1cb1 3a 00 f2			ld a,(scratch+4) 
1cb4 fe 00			cp 0 
1cb6 28 0c			jr z, .entercont 
1cb8				; no, not a null term line so has an address to work out.... 
1cb8			 
1cb8 21 fe f1			ld hl,scratch+2 
1cbb cd 03 13			call get_word_hl 
1cbe			 
1cbe 22 1f f5			ld (os_cur_ptr),hl	 
1cc1 c3 27 1c			jp cli 
1cc4			 
1cc4			 
1cc4			.entercont:  
1cc4			 
1cc4 21 fe f1			ld hl, scratch+2 
1cc7 cd a3 12			call get_byte 
1cca			 
1cca 2a 1f f5		   	ld hl,(os_cur_ptr) 
1ccd 77					ld (hl),a 
1cce 23					inc hl 
1ccf 22 1f f5				ld (os_cur_ptr),hl 
1cd2				 
1cd2			; get byte  
1cd2			 
1cd2			 
1cd2 c3 27 1c			jp cli 
1cd5			 
1cd5			 
1cd5			; basic monitor support 
1cd5			 
1cd5			monitor: 
1cd5				;  
1cd5 cd 18 0d			call clear_display 
1cd8 3e 00			ld a, 0 
1cda 11 22 1d			ld de, .monprompt 
1cdd cd 2b 0d			call str_at_display 
1ce0 cd 3b 0d			call update_display 
1ce3			 
1ce3				; get a monitor command 
1ce3			 
1ce3 0e 00			ld c, 0     ; entry at top left 
1ce5 16 64			ld d, 100   ; max buffer size 
1ce7 1e 0f			ld e, 15    ; input scroll area 
1ce9 3e 00			ld a, 0     ; init string 
1ceb 21 fa f3			ld hl, os_input 
1cee 77				ld (hl), a 
1cef 23				inc hl 
1cf0 77				ld (hl), a 
1cf1 21 fa f3			ld hl, os_input 
1cf4 3e 01			ld a, 1     ; init string 
1cf6 cd 79 0f			call input_str 
1cf9			 
1cf9 cd 18 0d		        call clear_display 
1cfc cd 3b 0d			call update_display		 
1cff			 
1cff 3a fa f3			ld a, (os_input) 
1d02 cd a1 13			call toUpper 
1d05 fe 48		        cp 'H' 
1d07 28 6f		        jr z, .monhelp 
1d09 fe 44			cp 'D'		; dump 
1d0b ca 99 1d			jp z, .mondump	 
1d0e fe 43			cp 'C'		; dump 
1d10 ca b3 1d			jp z, .moncdump	 
1d13 fe 4d			cp 'M'		; dump 
1d15 ca 24 1d			jp z, .moneditstart 
1d18 fe 55			cp 'U'		; dump 
1d1a 28 14			jr z, .monedit	 
1d1c fe 51			cp 'Q'		; dump 
1d1e c8				ret z	 
1d1f			 
1d1f			 
1d1f				; TODO "S" to access symbol by name and not need the address 
1d1f				; TODO "F" to find a string in memory 
1d1f			 
1d1f c3 d5 1c			jp monitor 
1d22			 
1d22 .. 00		.monprompt: db ">", 0 
1d24			 
1d24			.moneditstart: 
1d24				; get starting address 
1d24			 
1d24 21 fc f3			ld hl,os_input+2 
1d27 cd 03 13			call get_word_hl 
1d2a			 
1d2a 22 1f f5			ld (os_cur_ptr),hl	 
1d2d			 
1d2d c3 d5 1c			jp monitor 
1d30			 
1d30			.monedit: 
1d30				; get byte to load 
1d30			 
1d30 21 fc f3			ld hl,os_input+2 
1d33 cd a3 12			call get_byte 
1d36			 
1d36				; get address to update 
1d36 2a 1f f5			ld hl, (os_cur_ptr) 
1d39			 
1d39				; update byte 
1d39			 
1d39 77				ld (hl), a 
1d3a			 
1d3a				; move to next address and save it 
1d3a			 
1d3a 23				inc hl 
1d3b 22 1f f5			ld (os_cur_ptr),hl	 
1d3e			 
1d3e c3 d5 1c			jp monitor 
1d41			 
1d41			 
1d41 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d55 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d71 .. 00		.monhelptext3:  db "Q-Quit",0 
1d78			        
1d78			.monhelp: 
1d78 3e 00			ld a, display_row_1 
1d7a 11 41 1d		        ld de, .monhelptext1 
1d7d			 
1d7d cd 2b 0d			call str_at_display 
1d80 3e 28			ld a, display_row_2 
1d82 11 55 1d		        ld de, .monhelptext2 
1d85					 
1d85 cd 2b 0d			call str_at_display 
1d88 3e 50			ld a, display_row_3 
1d8a 11 71 1d		        ld de, .monhelptext3 
1d8d					 
1d8d cd 2b 0d			call str_at_display 
1d90 cd 3b 0d			call update_display		 
1d93			 
1d93 cd df 1e			call next_page_prompt 
1d96 c3 d5 1c			jp monitor 
1d99			 
1d99			.mondump:    
1d99 21 fc f3			ld hl,os_input+2 
1d9c cd 03 13			call get_word_hl 
1d9f			 
1d9f 22 1f f5			ld (os_cur_ptr),hl	 
1da2 cd e7 1d			call dumpcont 
1da5 3e 78			ld a, display_row_4 
1da7 11 81 1c			ld de, endprog 
1daa			 
1daa cd 3b 0d			call update_display		 
1dad			 
1dad cd df 1e			call next_page_prompt 
1db0 c3 d5 1c			jp monitor 
1db3			.moncdump: 
1db3 cd e7 1d			call dumpcont 
1db6 3e 78			ld a, display_row_4 
1db8 11 81 1c			ld de, endprog 
1dbb			 
1dbb cd 3b 0d			call update_display		 
1dbe			 
1dbe cd df 1e			call next_page_prompt 
1dc1 c3 d5 1c			jp monitor 
1dc4			 
1dc4			 
1dc4			; TODO symbol access  
1dc4			 
1dc4			.symbols:     ;; A list of symbols that can be called up  
1dc4 b4 fd			dw display_fb0 
1dc6 .. 00			db "fb0",0  
1dca 81 fa		     	dw store_page 
1dcc .. 00			db "store_page",0 
1dd7			 
1dd7			 
1dd7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1dd7			 
1dd7 3a fd f1			ld a,(scratch+1) 
1dda fe 00			cp 0 
1ddc 28 09			jr z, dumpcont 
1dde			 
1dde				; no, not a null term line so has an address to work out.... 
1dde			 
1dde 21 fe f1			ld hl,scratch+2 
1de1 cd 03 13			call get_word_hl 
1de4			 
1de4 22 1f f5			ld (os_cur_ptr),hl	 
1de7			 
1de7			 
1de7			 
1de7			dumpcont: 
1de7			 
1de7				; dump bytes at ptr 
1de7			 
1de7			 
1de7 3e 00			ld a, display_row_1 
1de9 2a cf fb			ld hl, (display_fb_active) 
1dec cd 4c 0f			call addatohl 
1def cd 17 1e			call .dumpbyterow 
1df2			 
1df2 3e 28			ld a, display_row_2 
1df4 2a cf fb			ld hl, (display_fb_active) 
1df7 cd 4c 0f			call addatohl 
1dfa cd 17 1e			call .dumpbyterow 
1dfd			 
1dfd			 
1dfd 3e 50			ld a, display_row_3 
1dff 2a cf fb			ld hl, (display_fb_active) 
1e02 cd 4c 0f			call addatohl 
1e05 cd 17 1e			call .dumpbyterow 
1e08			 
1e08 3e 78			ld a, display_row_4 
1e0a 2a cf fb			ld hl, (display_fb_active) 
1e0d cd 4c 0f			call addatohl 
1e10 cd 17 1e			call .dumpbyterow 
1e13			 
1e13 cd 3b 0d			call update_display 
1e16			;		jp cli 
1e16 c9				ret 
1e17			 
1e17			.dumpbyterow: 
1e17			 
1e17				;push af 
1e17			 
1e17 e5				push hl 
1e18			 
1e18				; calc where to poke the ascii 
1e18			if display_cols == 20 
1e18				ld a, 16 
1e18			else 
1e18 3e 1f			ld a, 31 
1e1a			endif 
1e1a			 
1e1a cd 4c 0f			call addatohl 
1e1d 22 01 f5			ld (os_word_scratch),hl  		; save pos for later 
1e20			 
1e20			 
1e20			; display decoding address 
1e20 2a 1f f5		   	ld hl,(os_cur_ptr) 
1e23			 
1e23 7c				ld a,h 
1e24 e1				pop hl 
1e25 e5				push hl 
1e26			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1e26 cd 4d 12			call hexout 
1e29 2a 1f f5		   	ld hl,(os_cur_ptr) 
1e2c			 
1e2c 7d				ld a,l 
1e2d e1				pop hl 
1e2e 23				inc hl 
1e2f 23				inc hl 
1e30 e5				push hl 
1e31			;	ld hl, os_word_scratch+2 
1e31 cd 4d 12			call hexout 
1e34 e1				pop hl 
1e35 23				inc hl 
1e36 23				inc hl 
1e37				;ld hl, os_word_scratch+4 
1e37 3e 3a			ld a, ':' 
1e39 77				ld (hl),a 
1e3a 23				inc hl 
1e3b				;ld a, 0 
1e3b				;ld (hl),a 
1e3b				;ld de, os_word_scratch 
1e3b				;pop af 
1e3b				;push af 
1e3b			;		ld a, display_row_2 
1e3b			;		call str_at_display 
1e3b			;		call update_display 
1e3b			 
1e3b			 
1e3b			;pop af 
1e3b			;	add 5 
1e3b			 
1e3b			if display_cols == 20 
1e3b				ld b, 4 
1e3b			else 
1e3b 06 08			ld b, 8 
1e3d			endif	 
1e3d			 
1e3d			.dumpbyte: 
1e3d c5				push bc 
1e3e e5				push hl 
1e3f			 
1e3f			 
1e3f 2a 1f f5		   	ld hl,(os_cur_ptr) 
1e42 7e					ld a,(hl) 
1e43			 
1e43					; poke the ascii to display 
1e43 2a 01 f5				ld hl,(os_word_scratch) 
1e46 77					ld (hl),a 
1e47 23					inc hl 
1e48 22 01 f5				ld (os_word_scratch),hl 
1e4b			 
1e4b					 
1e4b			 
1e4b			 
1e4b e1					pop hl 
1e4c e5					push hl 
1e4d			 
1e4d cd 4d 12				call hexout 
1e50			 
1e50					 
1e50 2a 1f f5		   	ld hl,(os_cur_ptr) 
1e53 23				inc hl 
1e54 22 1f f5		   	ld (os_cur_ptr),hl 
1e57			 
1e57 e1					pop hl 
1e58 23					inc hl 
1e59 23					inc hl 
1e5a 23					inc hl 
1e5b			 
1e5b			 
1e5b			 
1e5b					;ld a,0 
1e5b					;ld (os_word_scratch+2),a 
1e5b					;pop af 
1e5b					;push af 
1e5b			 
1e5b					;ld de, os_word_scratch 
1e5b					;call str_at_display 
1e5b			;		call update_display 
1e5b			;		pop af 
1e5b c1					pop bc 
1e5c c6 03				add 3 
1e5e 10 dd			djnz .dumpbyte 
1e60			 
1e60				 
1e60			 
1e60 c9				ret 
1e61			 
1e61			jump:	 
1e61			 
1e61 21 fe f1			ld hl,scratch+2 
1e64 cd 03 13			call get_word_hl 
1e67				;ld hl,(scratch+2) 
1e67				;call fourehexhl 
1e67			 
1e67 22 1f f5			ld (os_cur_ptr),hl	 
1e6a			 
1e6a e9				jp (hl) 
1e6b			 
1e6b			 
1e6b			 
1e6b			; TODO implement a basic monitor mode to start with 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			; testing and demo code during development 
1e6b			 
1e6b			 
1e6b .. 00		str1: db "Enter some text...",0 
1e7e .. 00		clear: db "                    ",0 
1e93			 
1e93			demo: 
1e93			 
1e93			 
1e93			 
1e93			;	call update_display 
1e93			 
1e93				; init scratch input area for testing 
1e93 21 fc f1			ld hl, scratch	 
1e96 3e 00			ld a,0 
1e98 77				ld (hl),a 
1e99			 
1e99			 
1e99 3e 28		            LD   A, display_row_2 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 6b 1e		            LD   DE, str1 
1e9e cd 2b 0d			call str_at_display 
1ea1			 
1ea1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ea1			cloop:	 
1ea1 3e 50		            LD   A, display_row_3 
1ea3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ea3 11 7e 1e		            LD   DE, clear 
1ea6			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ea6 cd 2b 0d				call str_at_display 
1ea9 3e 78			ld a, display_row_4 
1eab 11 db 1e			ld de, prompt 
1eae			 
1eae cd 2b 0d				call str_at_display 
1eb1 cd 3b 0d			call update_display 
1eb4			 
1eb4 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1eb6 16 0a			ld d, 10 
1eb8 21 fc f1			ld hl, scratch	 
1ebb cd 79 0f			call input_str 
1ebe			 
1ebe			;	call clear_display 
1ebe			;'	call update_display 
1ebe			 
1ebe 3e 00		            LD   A, display_row_1 
1ec0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec0 11 7e 1e		            LD   DE, clear 
1ec3 cd 2b 0d				call str_at_display 
1ec6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ec6 3e 00		            LD   A, display_row_1 
1ec8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec8 11 fc f1		            LD   DE, scratch 
1ecb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ecb cd 2b 0d				call str_at_display 
1ece cd 3b 0d			call update_display 
1ed1			 
1ed1 3e 00				ld a,0 
1ed3 21 fc f1			ld hl, scratch 
1ed6 77				ld (hl),a 
1ed7			 
1ed7 00				nop 
1ed8 c3 a1 1e			jp cloop 
1edb			 
1edb			 
1edb			 
1edb			; OS Prompt 
1edb			 
1edb .. 00		prompt: db ">",0 
1edd .. 00		endprg: db "?",0 
1edf			 
1edf			 
1edf			; handy next page prompt 
1edf			next_page_prompt: 
1edf e5				push hl 
1ee0 d5				push de 
1ee1 f5				push af 
1ee2 c5				push bc 
1ee3			 
1ee3 3e 9f			ld a,display_row_4 + display_cols - 1 
1ee5 11 dd 1e		        ld de, endprg 
1ee8 cd 2b 0d			call str_at_display 
1eeb cd 3b 0d			call update_display 
1eee cd fe 70			call cin_wait 
1ef1 c1				pop bc 
1ef2 f1				pop af 
1ef3 d1				pop de 
1ef4 e1				pop hl 
1ef5			 
1ef5			 
1ef5 c9				ret 
1ef6			 
1ef6			 
1ef6			; forth parser 
1ef6			 
1ef6			; My forth kernel 
1ef6			include "forth_kernel.asm" 
1ef6			; 
1ef6			; kernel to the forth OS 
1ef6			 
1ef6			DS_TYPE_STR: equ 1     ; string type 
1ef6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ef6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ef6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ef6			 
1ef6			FORTH_PARSEV1: equ 0 
1ef6			FORTH_PARSEV2: equ 0 
1ef6			FORTH_PARSEV3: equ 0 
1ef6			FORTH_PARSEV4: equ 0 
1ef6			FORTH_PARSEV5: equ 1 
1ef6			 
1ef6			;if FORTH_PARSEV5 
1ef6			;	FORTH_END_BUFFER: equ 0 
1ef6			;else 
1ef6			FORTH_END_BUFFER: equ 127 
1ef6			;endif 
1ef6			 
1ef6			FORTH_TRUE: equ 1 
1ef6			FORTH_FALSE: equ 0 
1ef6			 
1ef6			if FORTH_PARSEV4 
1ef6			include "forth_stackops.asm" 
1ef6			endif 
1ef6			 
1ef6			if FORTH_PARSEV5 
1ef6			include "forth_stackopsv5.asm" 
1ef6			 
1ef6			; Stack operations for v5 parser on wards 
1ef6			; * DATA stack 
1ef6			; * LOOP stack 
1ef6			; * RETURN stack 
1ef6			 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_DSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_data_sp) 
1ef6				ld de, cli_data_stack 
1ef6				call cmp16 
1ef6				jp c, fault_dsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_RSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_ret_sp) 
1ef6				ld de, cli_ret_stack 
1ef6				call cmp16 
1ef6				jp c, fault_rsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_CHK_LOOP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_loop_sp) 
1ef6				ld de, cli_loop_stack 
1ef6				call cmp16 
1ef6				jp c, fault_loop_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTSTR: macro 
1ef6				; TOSO might need more for checks when used 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_STR 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTNUM: macro 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_INUM 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			; increase data stack pointer and save hl to it 
1ef6				 
1ef6			FORTH_DSP_NEXT: macro 
1ef6				call macro_forth_dsp_next 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			macro_forth_dsp_next: 
1ef6				if DEBUG_FORTH_STACK_GUARD 
1ef6 cd 76 6a				call check_stacks 
1ef9				endif 
1ef9 e5				push hl 
1efa d5				push de 
1efb eb				ex de,hl 
1efc 2a 29 fa			ld hl,(cli_data_sp) 
1eff 23				inc hl 
1f00 23				inc hl 
1f01			 
1f01			; PARSEV5 
1f01 23				inc hl 
1f02 22 29 fa			ld (cli_data_sp),hl 
1f05 73				ld (hl), e 
1f06 23				inc hl 
1f07 72				ld (hl), d 
1f08 d1				pop de 
1f09 e1				pop hl 
1f0a				if DEBUG_FORTH_STACK_GUARD 
1f0a cd 76 6a				call check_stacks 
1f0d				endif 
1f0d c9				ret 
1f0e			 
1f0e			 
1f0e			; increase ret stack pointer and save hl to it 
1f0e				 
1f0e			FORTH_RSP_NEXT: macro 
1f0e				call macro_forth_rsp_next 
1f0e				endm 
1f0e			 
1f0e			macro_forth_rsp_next: 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e cd 76 6a				call check_stacks 
1f11				endif 
1f11 e5				push hl 
1f12 d5				push de 
1f13 eb				ex de,hl 
1f14 2a 2d fa			ld hl,(cli_ret_sp) 
1f17 23				inc hl 
1f18 23				inc hl 
1f19 22 2d fa			ld (cli_ret_sp),hl 
1f1c 73				ld (hl), e 
1f1d 23				inc hl 
1f1e 72				ld (hl), d 
1f1f d1				pop de 
1f20 e1				pop hl 
1f21				if DEBUG_FORTH_STACK_GUARD 
1f21 cd 76 6a				call check_stacks 
1f24				endif 
1f24 c9				ret 
1f25			 
1f25			; get current ret stack pointer and save to hl  
1f25				 
1f25			FORTH_RSP_TOS: macro 
1f25				call macro_forth_rsp_tos 
1f25				endm 
1f25			 
1f25			macro_forth_rsp_tos: 
1f25				;push de 
1f25 2a 2d fa			ld hl,(cli_ret_sp) 
1f28 cd 60 1f			call loadhlptrtohl 
1f2b				;ld e, (hl) 
1f2b				;inc hl 
1f2b				;ld d, (hl) 
1f2b				;ex de, hl 
1f2b					if DEBUG_FORTH_WORDS 
1f2b			;			DMARK "RST" 
1f2b						CALLMONITOR 
1f2b cd f3 18			call break_point_state  
1f2e				endm  
# End of macro CALLMONITOR
1f2e					endif 
1f2e				;pop de 
1f2e c9				ret 
1f2f			 
1f2f			; pop ret stack pointer 
1f2f				 
1f2f			FORTH_RSP_POP: macro 
1f2f				call macro_forth_rsp_pop 
1f2f				endm 
1f2f			 
1f2f			 
1f2f			macro_forth_rsp_pop: 
1f2f				if DEBUG_FORTH_STACK_GUARD 
1f2f			;		DMARK "RPP" 
1f2f cd 76 6a				call check_stacks 
1f32					FORTH_CHK_RSP_UNDER 
1f32 e5				push hl 
1f33 d5				push de 
1f34 2a 2d fa			ld hl,(cli_ret_sp) 
1f37 11 e7 f9			ld de, cli_ret_stack 
1f3a cd 6a 0f			call cmp16 
1f3d da 8a 6b			jp c, fault_rsp_under 
1f40 d1				pop de 
1f41 e1				pop hl 
1f42				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f42				endif 
1f42 e5				push hl 
1f43 2a 2d fa			ld hl,(cli_ret_sp) 
1f46			 
1f46			 
1f46				if FORTH_ENABLE_FREE 
1f46			 
1f46					; get pointer 
1f46			 
1f46					push de 
1f46					push hl 
1f46			 
1f46					ld e, (hl) 
1f46					inc hl 
1f46					ld d, (hl) 
1f46			 
1f46					ex de, hl 
1f46					call free 
1f46			 
1f46					pop hl 
1f46					pop de 
1f46			 
1f46			 
1f46				endif 
1f46			 
1f46			 
1f46 2b				dec hl 
1f47 2b				dec hl 
1f48 22 2d fa			ld (cli_ret_sp), hl 
1f4b				; do stack underflow checks 
1f4b e1				pop hl 
1f4c				if DEBUG_FORTH_STACK_GUARD 
1f4c cd 76 6a				call check_stacks 
1f4f					FORTH_CHK_RSP_UNDER 
1f4f e5				push hl 
1f50 d5				push de 
1f51 2a 2d fa			ld hl,(cli_ret_sp) 
1f54 11 e7 f9			ld de, cli_ret_stack 
1f57 cd 6a 0f			call cmp16 
1f5a da 8a 6b			jp c, fault_rsp_under 
1f5d d1				pop de 
1f5e e1				pop hl 
1f5f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f5f				endif 
1f5f c9				ret 
1f60			 
1f60			 
1f60			 
1f60			; routine to load word pointed to by hl into hl 
1f60			 
1f60			loadhlptrtohl: 
1f60			 
1f60 d5				push de 
1f61 5e				ld e, (hl) 
1f62 23				inc hl 
1f63 56				ld d, (hl) 
1f64 eb				ex de, hl 
1f65 d1				pop de 
1f66			 
1f66 c9				ret 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			; push a number held in HL onto the data stack 
1f67			; entry point for pushing a value when already in hl used in function above 
1f67			 
1f67			forth_push_numhl: 
1f67			 
1f67 e5				push hl    ; save value to push 
1f68			 
1f68			if DEBUG_FORTH_PUSH 
1f68				; see if disabled 
1f68			 
1f68			 
1f68 f5				push af 
1f69 3a ed f1			ld a, (os_view_disable) 
1f6c fe 2a			cp '*' 
1f6e 28 34			jr z, .pskip2 
1f70 e5				push hl 
1f71 e5			push hl 
1f72 cd 18 0d			call clear_display 
1f75 e1			pop hl 
1f76 7c				ld a,h 
1f77 21 01 f5			ld hl, os_word_scratch 
1f7a cd 4d 12			call hexout 
1f7d e1				pop hl 
1f7e 7d				ld a,l 
1f7f 21 03 f5			ld hl, os_word_scratch+2 
1f82 cd 4d 12			call hexout 
1f85			 
1f85 21 05 f5			ld hl, os_word_scratch+4 
1f88 3e 00			ld a,0 
1f8a 77				ld (hl),a 
1f8b 11 01 f5			ld de,os_word_scratch 
1f8e 3e 28				ld a, display_row_2 
1f90 cd 2b 0d				call str_at_display 
1f93 11 43 56			ld de, .push_num 
1f96 3e 00			ld a, display_row_1 
1f98			 
1f98 cd 2b 0d				call str_at_display 
1f9b			 
1f9b			 
1f9b cd 3b 0d			call update_display 
1f9e cd 95 0c			call delay1s 
1fa1 cd 95 0c			call delay1s 
1fa4			.pskip2:  
1fa4			 
1fa4 f1				pop af 
1fa5			endif	 
1fa5			 
1fa5			 
1fa5				FORTH_DSP_NEXT 
1fa5 cd f6 1e			call macro_forth_dsp_next 
1fa8				endm 
# End of macro FORTH_DSP_NEXT
1fa8			 
1fa8 2a 29 fa			ld hl, (cli_data_sp) 
1fab			 
1fab				; save item type 
1fab 3e 02			ld a,  DS_TYPE_INUM 
1fad 77				ld (hl), a 
1fae 23				inc hl 
1faf			 
1faf				; get word off stack 
1faf d1				pop de 
1fb0 7b				ld a,e 
1fb1 77				ld (hl), a 
1fb2 23				inc hl 
1fb3 7a				ld a,d 
1fb4 77				ld (hl), a 
1fb5			 
1fb5			if DEBUG_FORTH_PUSH 
1fb5 2b				dec hl 
1fb6 2b				dec hl 
1fb7 2b				dec hl 
1fb8						DMARK "PH5" 
1fb8 f5				push af  
1fb9 3a cd 1f			ld a, (.dmark)  
1fbc 32 6e fe			ld (debug_mark),a  
1fbf 3a ce 1f			ld a, (.dmark+1)  
1fc2 32 6f fe			ld (debug_mark+1),a  
1fc5 3a cf 1f			ld a, (.dmark+2)  
1fc8 32 70 fe			ld (debug_mark+2),a  
1fcb 18 03			jr .pastdmark  
1fcd ..			.dmark: db "PH5"  
1fd0 f1			.pastdmark: pop af  
1fd1			endm  
# End of macro DMARK
1fd1				CALLMONITOR 
1fd1 cd f3 18			call break_point_state  
1fd4				endm  
# End of macro CALLMONITOR
1fd4			endif	 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5			 
1fd5			; Push a string to stack pointed to by hl 
1fd5			 
1fd5			forth_push_str: 
1fd5			 
1fd5			if DEBUG_FORTH_PUSH 
1fd5						DMARK "PSQ" 
1fd5 f5				push af  
1fd6 3a ea 1f			ld a, (.dmark)  
1fd9 32 6e fe			ld (debug_mark),a  
1fdc 3a eb 1f			ld a, (.dmark+1)  
1fdf 32 6f fe			ld (debug_mark+1),a  
1fe2 3a ec 1f			ld a, (.dmark+2)  
1fe5 32 70 fe			ld (debug_mark+2),a  
1fe8 18 03			jr .pastdmark  
1fea ..			.dmark: db "PSQ"  
1fed f1			.pastdmark: pop af  
1fee			endm  
# End of macro DMARK
1fee				CALLMONITOR 
1fee cd f3 18			call break_point_state  
1ff1				endm  
# End of macro CALLMONITOR
1ff1			endif	 
1ff1			    
1ff1 e5				push hl 
1ff2 e5				push hl 
1ff3			 
1ff3			;	ld a, 0   ; find end of string 
1ff3 cd aa 13			call strlenz 
1ff6			if DEBUG_FORTH_PUSH 
1ff6						DMARK "PQ2" 
1ff6 f5				push af  
1ff7 3a 0b 20			ld a, (.dmark)  
1ffa 32 6e fe			ld (debug_mark),a  
1ffd 3a 0c 20			ld a, (.dmark+1)  
2000 32 6f fe			ld (debug_mark+1),a  
2003 3a 0d 20			ld a, (.dmark+2)  
2006 32 70 fe			ld (debug_mark+2),a  
2009 18 03			jr .pastdmark  
200b ..			.dmark: db "PQ2"  
200e f1			.pastdmark: pop af  
200f			endm  
# End of macro DMARK
200f				CALLMONITOR 
200f cd f3 18			call break_point_state  
2012				endm  
# End of macro CALLMONITOR
2012			endif	 
2012 eb				ex de, hl 
2013 e1				pop hl   ; get ptr to start of string 
2014			if DEBUG_FORTH_PUSH 
2014						DMARK "PQ3" 
2014 f5				push af  
2015 3a 29 20			ld a, (.dmark)  
2018 32 6e fe			ld (debug_mark),a  
201b 3a 2a 20			ld a, (.dmark+1)  
201e 32 6f fe			ld (debug_mark+1),a  
2021 3a 2b 20			ld a, (.dmark+2)  
2024 32 70 fe			ld (debug_mark+2),a  
2027 18 03			jr .pastdmark  
2029 ..			.dmark: db "PQ3"  
202c f1			.pastdmark: pop af  
202d			endm  
# End of macro DMARK
202d				CALLMONITOR 
202d cd f3 18			call break_point_state  
2030				endm  
# End of macro CALLMONITOR
2030			endif	 
2030 19				add hl,de 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PQE" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 6e fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 6f fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 70 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PQE"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd f3 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d			 
204d 2b				dec hl    ; see if there is an optional trailing double quote 
204e 7e				ld a,(hl) 
204f fe 22			cp '"' 
2051 20 03			jr nz, .strnoq 
2053 3e 00			ld a, 0      ; get rid of double quote 
2055 77				ld (hl), a 
2056 23			.strnoq: inc hl 
2057			 
2057 3e 00			ld a, 0 
2059 77				ld (hl), a     ; add null term and get rid of trailing double quote 
205a			 
205a 13				inc de ; add one for the type string 
205b 13				inc de ; add one for null term??? 
205c			 
205c				; tos is get string pointer again 
205c				; de contains space to allocate 
205c				 
205c d5				push de 
205d			 
205d eb				ex de, hl 
205e			 
205e				;push af 
205e			 
205e			if DEBUG_FORTH_PUSH 
205e						DMARK "PHm" 
205e f5				push af  
205f 3a 73 20			ld a, (.dmark)  
2062 32 6e fe			ld (debug_mark),a  
2065 3a 74 20			ld a, (.dmark+1)  
2068 32 6f fe			ld (debug_mark+1),a  
206b 3a 75 20			ld a, (.dmark+2)  
206e 32 70 fe			ld (debug_mark+2),a  
2071 18 03			jr .pastdmark  
2073 ..			.dmark: db "PHm"  
2076 f1			.pastdmark: pop af  
2077			endm  
# End of macro DMARK
2077				CALLMONITOR 
2077 cd f3 18			call break_point_state  
207a				endm  
# End of macro CALLMONITOR
207a			endif	 
207a cd 13 14			call malloc	; on ret hl now contains allocated memory 
207d				if DEBUG_FORTH_MALLOC_GUARD 
207d cc 9b 56				call z,malloc_error 
2080				endif 
2080			 
2080				 
2080 c1				pop bc    ; get length 
2081 d1				pop de   ;  get string start    
2082			 
2082				; hl has destination from malloc 
2082			 
2082 eb				ex de, hl    ; prep for ldir 
2083			 
2083 d5				push de   ; save malloc area for DSP later 
2084				;push hl   ; save malloc area for DSP later 
2084			 
2084			if DEBUG_FORTH_PUSH 
2084						DMARK "PHc" 
2084 f5				push af  
2085 3a 99 20			ld a, (.dmark)  
2088 32 6e fe			ld (debug_mark),a  
208b 3a 9a 20			ld a, (.dmark+1)  
208e 32 6f fe			ld (debug_mark+1),a  
2091 3a 9b 20			ld a, (.dmark+2)  
2094 32 70 fe			ld (debug_mark+2),a  
2097 18 03			jr .pastdmark  
2099 ..			.dmark: db "PHc"  
209c f1			.pastdmark: pop af  
209d			endm  
# End of macro DMARK
209d				CALLMONITOR 
209d cd f3 18			call break_point_state  
20a0				endm  
# End of macro CALLMONITOR
20a0			endif	 
20a0			 
20a0			 
20a0 ed b0			ldir 
20a2			 
20a2			 
20a2				; push malloc to data stack     macro?????  
20a2			 
20a2				FORTH_DSP_NEXT 
20a2 cd f6 1e			call macro_forth_dsp_next 
20a5				endm 
# End of macro FORTH_DSP_NEXT
20a5			 
20a5				; save value and type 
20a5			 
20a5 2a 29 fa			ld hl, (cli_data_sp) 
20a8			 
20a8				; save item type 
20a8 3e 01			ld a,  DS_TYPE_STR 
20aa 77				ld (hl), a 
20ab 23				inc hl 
20ac			 
20ac				; get malloc word off stack 
20ac d1				pop de 
20ad 73				ld (hl), e 
20ae 23				inc hl 
20af 72				ld (hl), d 
20b0			 
20b0			 
20b0			 
20b0			if DEBUG_FORTH_PUSH 
20b0 2a 29 fa			ld hl, (cli_data_sp) 
20b3						DMARK "PHS" 
20b3 f5				push af  
20b4 3a c8 20			ld a, (.dmark)  
20b7 32 6e fe			ld (debug_mark),a  
20ba 3a c9 20			ld a, (.dmark+1)  
20bd 32 6f fe			ld (debug_mark+1),a  
20c0 3a ca 20			ld a, (.dmark+2)  
20c3 32 70 fe			ld (debug_mark+2),a  
20c6 18 03			jr .pastdmark  
20c8 ..			.dmark: db "PHS"  
20cb f1			.pastdmark: pop af  
20cc			endm  
# End of macro DMARK
20cc				CALLMONITOR 
20cc cd f3 18			call break_point_state  
20cf				endm  
# End of macro CALLMONITOR
20cf			;	ex de,hl 
20cf			endif	 
20cf				; in case of spaces, skip the ptr past the copied string 
20cf				;pop af 
20cf				;ld (cli_origptr),hl 
20cf			 
20cf c9				ret 
20d0			 
20d0			 
20d0			 
20d0			; TODO ascii push input onto stack given hl to start of input 
20d0			 
20d0			; identify type 
20d0			; if starts with a " then a string 
20d0			; otherwise it is a number 
20d0			;  
20d0			; if a string 
20d0			;     scan for ending " to get length of string to malloc for + 1 
20d0			;     malloc 
20d0			;     put pointer to string on stack first byte flags as string 
20d0			; 
20d0			; else a number 
20d0			;    look for number format identifier 
20d0			;    $xx hex 
20d0			;    %xxxxx bin 
20d0			;    xxxxx decimal 
20d0			;    convert number to 16bit word.  
20d0			;    malloc word + 1 with flag to identiy as num 
20d0			;    put pointer to number on stack 
20d0			;   
20d0			;  
20d0			  
20d0			forth_apush: 
20d0				; kernel push 
20d0			 
20d0			if DEBUG_FORTH_PUSH 
20d0						DMARK "PSH" 
20d0 f5				push af  
20d1 3a e5 20			ld a, (.dmark)  
20d4 32 6e fe			ld (debug_mark),a  
20d7 3a e6 20			ld a, (.dmark+1)  
20da 32 6f fe			ld (debug_mark+1),a  
20dd 3a e7 20			ld a, (.dmark+2)  
20e0 32 70 fe			ld (debug_mark+2),a  
20e3 18 03			jr .pastdmark  
20e5 ..			.dmark: db "PSH"  
20e8 f1			.pastdmark: pop af  
20e9			endm  
# End of macro DMARK
20e9				CALLMONITOR 
20e9 cd f3 18			call break_point_state  
20ec				endm  
# End of macro CALLMONITOR
20ec			endif	 
20ec				; identify input type 
20ec			 
20ec 7e				ld a,(hl) 
20ed fe 22			cp '"' 
20ef 28 0a			jr z, .fapstr 
20f1 fe 24			cp '$' 
20f3 ca 1b 21			jp z, .faphex 
20f6 fe 25			cp '%' 
20f8 ca 03 21			jp z, .fapbin 
20fb			;	cp 'b' 
20fb			;	jp z, .fabin 
20fb				; else decimal 
20fb			 
20fb				; TODO do decimal conversion 
20fb				; decimal is stored as a 16bit word 
20fb			 
20fb				; by default everything is a string if type is not detected 
20fb			.fapstr: ; 
20fb fe 22			cp '"' 
20fd 20 01			jr nz, .strnoqu 
20ff 23				inc hl 
2100			.strnoqu: 
2100 c3 d5 1f			jp forth_push_str 
2103			 
2103			 
2103			 
2103			.fapbin:    ; push a binary string.  
2103 11 00 00			ld de, 0   ; hold a 16bit value 
2106			 
2106 23			.fapbinshift:	inc hl  
2107 7e				ld a,(hl) 
2108 fe 00			cp 0     ; done scanning  
210a 28 0b			jr z, .fapbdone  	; got it in HL so push  
210c			 
210c				; left shift de 
210c eb				ex de, hl	 
210d 29				add hl, hl 
210e			 
210e				; is 1 
210e fe 31			cp '1' 
2110 20 02			jr nz, .binzero 
2112 cb 4d			bit 1, l 
2114			.binzero: 
2114 eb				ex de, hl	 ; save current de 
2115 18 ef			jr .fapbinshift 
2117			 
2117			.fapbdone: 
2117 eb				ex de, hl 
2118 c3 67 1f			jp forth_push_numhl 
211b			 
211b			 
211b			.faphex:   ; hex is always stored as a 16bit word 
211b				; skip number prefix 
211b 23				inc hl 
211c				; turn ascii into number 
211c cd 03 13			call get_word_hl	; ret 16bit word in hl 
211f			 
211f c3 67 1f			jp forth_push_numhl 
2122			 
2122 00				 nop 
2123			 
2123			.fabin:   ; TODO bin conversion 
2123			 
2123			 
2123 c9				ret 
2124			 
2124			 
2124			; get either a string ptr or a 16bit word from the data stack 
2124			 
2124			FORTH_DSP: macro 
2124				call macro_forth_dsp 
2124				endm 
2124			 
2124			macro_forth_dsp: 
2124				; data stack pointer points to current word on tos 
2124			 
2124 2a 29 fa			ld hl,(cli_data_sp) 
2127			 
2127				if DEBUG_FORTH_PUSH 
2127						DMARK "DSP" 
2127 f5				push af  
2128 3a 3c 21			ld a, (.dmark)  
212b 32 6e fe			ld (debug_mark),a  
212e 3a 3d 21			ld a, (.dmark+1)  
2131 32 6f fe			ld (debug_mark+1),a  
2134 3a 3e 21			ld a, (.dmark+2)  
2137 32 70 fe			ld (debug_mark+2),a  
213a 18 03			jr .pastdmark  
213c ..			.dmark: db "DSP"  
213f f1			.pastdmark: pop af  
2140			endm  
# End of macro DMARK
2140			 
2140 cd d0 56				call display_data_sp 
2143				;call break_point_state 
2143				;rst 030h 
2143				CALLMONITOR 
2143 cd f3 18			call break_point_state  
2146				endm  
# End of macro CALLMONITOR
2146				endif 
2146			 
2146 c9				ret 
2147			 
2147			; return hl to start of value on stack 
2147			 
2147			FORTH_DSP_VALUE: macro 
2147				call macro_forth_dsp_value 
2147				endm 
2147			 
2147			macro_forth_dsp_value: 
2147			 
2147				FORTH_DSP 
2147 cd 24 21			call macro_forth_dsp 
214a				endm 
# End of macro FORTH_DSP
214a			 
214a d5				push de 
214b			 
214b 23				inc hl ; skip type 
214c			 
214c 5e				ld e, (hl) 
214d 23				inc hl 
214e 56				ld d, (hl) 
214f eb				ex de,hl  
2150			 
2150 d1				pop de 
2151			 
2151 c9				ret 
2152			 
2152			; return hl to start of value to second item on stack 
2152			 
2152			FORTH_DSP_VALUEM1: macro 
2152				call macro_forth_dsp_value_m1 
2152				endm 
2152			 
2152			macro_forth_dsp_value_m1: 
2152			 
2152				FORTH_DSP 
2152 cd 24 21			call macro_forth_dsp 
2155				endm 
# End of macro FORTH_DSP
2155			 
2155 2b				dec hl 
2156 2b				dec hl 
2157			;	dec hl 
2157			 
2157 d5				push de 
2158			 
2158 5e				ld e, (hl) 
2159 23				inc hl 
215a 56				ld d, (hl) 
215b eb				ex de,hl  
215c			 
215c d1				pop de 
215d			 
215d c9				ret 
215e			 
215e				 
215e			 
215e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
215e			 
215e			FORTH_DSP_POP: macro 
215e				call macro_forth_dsp_pop 
215e				endm 
215e			 
215e			 
215e			; get the tos data type 
215e			 
215e			FORTH_DSP_TYPE:   macro 
215e			 
215e				;FORTH_DSP_VALUE 
215e				FORTH_DSP 
215e				 
215e				; hl points to value 
215e				; check type 
215e			 
215e				ld a,(hl) 
215e			 
215e				endm 
215e			 
215e			; load the tos value into hl 
215e			 
215e			 
215e			FORTH_DSP_VALUEHL:  macro 
215e				call macro_dsp_valuehl 
215e				endm 
215e			 
215e			 
215e			 
215e			macro_dsp_valuehl: 
215e				FORTH_DSP_VALUE 
215e cd 47 21			call macro_forth_dsp_value 
2161				endm 
# End of macro FORTH_DSP_VALUE
2161			 
2161				;FORTH_ERR_TOS_NOTNUM 
2161			 
2161				;inc hl   ; skip type id 
2161			 
2161			;	push de 
2161			; 
2161			;	ld e, (hl) 
2161			;	inc hl 
2161			;	ld d, (hl) 
2161			;	ex de,hl  
2161			 
2161			;	pop de 
2161			 
2161				if DEBUG_FORTH_PUSH 
2161						DMARK "DVL" 
2161 f5				push af  
2162 3a 76 21			ld a, (.dmark)  
2165 32 6e fe			ld (debug_mark),a  
2168 3a 77 21			ld a, (.dmark+1)  
216b 32 6f fe			ld (debug_mark+1),a  
216e 3a 78 21			ld a, (.dmark+2)  
2171 32 70 fe			ld (debug_mark+2),a  
2174 18 03			jr .pastdmark  
2176 ..			.dmark: db "DVL"  
2179 f1			.pastdmark: pop af  
217a			endm  
# End of macro DMARK
217a				CALLMONITOR 
217a cd f3 18			call break_point_state  
217d				endm  
# End of macro CALLMONITOR
217d				endif 
217d c9				ret 
217e			 
217e			forth_apushstrhl:      
217e				; push of string requires use of cli_origptr 
217e				; bodge use 
217e			 
217e				; get current cli_origptr, save, update with temp pointer  
217e ed 5b 45 fa		ld de, (cli_origptr) 
2182 22 45 fa			ld (cli_origptr), hl 
2185 d5				push de 
2186 cd d0 20			call forth_apush 
2189 d1				pop de 
218a ed 53 45 fa		ld (cli_origptr), de 
218e c9			        ret	 
218f			 
218f			 
218f			; increase loop stack pointer and save hl to it 
218f				 
218f			FORTH_LOOP_NEXT: macro 
218f				call macro_forth_loop_next 
218f				;nop 
218f				endm 
218f			 
218f			macro_forth_loop_next: 
218f				if DEBUG_FORTH_STACK_GUARD 
218f cd 76 6a				call check_stacks 
2192				endif 
2192 e5				push hl 
2193 d5				push de 
2194 eb				ex de,hl 
2195 2a 2b fa			ld hl,(cli_loop_sp) 
2198 23				inc hl 
2199 23				inc hl 
219a					if DEBUG_FORTH_WORDS 
219a						DMARK "LNX" 
219a f5				push af  
219b 3a af 21			ld a, (.dmark)  
219e 32 6e fe			ld (debug_mark),a  
21a1 3a b0 21			ld a, (.dmark+1)  
21a4 32 6f fe			ld (debug_mark+1),a  
21a7 3a b1 21			ld a, (.dmark+2)  
21aa 32 70 fe			ld (debug_mark+2),a  
21ad 18 03			jr .pastdmark  
21af ..			.dmark: db "LNX"  
21b2 f1			.pastdmark: pop af  
21b3			endm  
# End of macro DMARK
21b3						CALLMONITOR 
21b3 cd f3 18			call break_point_state  
21b6				endm  
# End of macro CALLMONITOR
21b6					endif 
21b6 22 2b fa			ld (cli_loop_sp),hl 
21b9 73				ld (hl), e 
21ba 23				inc hl 
21bb 72				ld (hl), d 
21bc d1				pop de    ; been reversed so save a swap on restore 
21bd e1				pop hl 
21be				if DEBUG_FORTH_STACK_GUARD 
21be cd 76 6a				call check_stacks 
21c1				endif 
21c1 c9				ret 
21c2			 
21c2			; get current ret stack pointer and save to hl  
21c2				 
21c2			FORTH_LOOP_TOS: macro 
21c2				call macro_forth_loop_tos 
21c2				endm 
21c2			 
21c2			macro_forth_loop_tos: 
21c2 d5				push de 
21c3 2a 2b fa			ld hl,(cli_loop_sp) 
21c6 5e				ld e, (hl) 
21c7 23				inc hl 
21c8 56				ld d, (hl) 
21c9 eb				ex de, hl 
21ca d1				pop de 
21cb c9				ret 
21cc			 
21cc			; pop loop stack pointer 
21cc				 
21cc			FORTH_LOOP_POP: macro 
21cc				call macro_forth_loop_pop 
21cc				endm 
21cc			 
21cc			 
21cc			macro_forth_loop_pop: 
21cc				if DEBUG_FORTH_STACK_GUARD 
21cc					DMARK "LPP" 
21cc f5				push af  
21cd 3a e1 21			ld a, (.dmark)  
21d0 32 6e fe			ld (debug_mark),a  
21d3 3a e2 21			ld a, (.dmark+1)  
21d6 32 6f fe			ld (debug_mark+1),a  
21d9 3a e3 21			ld a, (.dmark+2)  
21dc 32 70 fe			ld (debug_mark+2),a  
21df 18 03			jr .pastdmark  
21e1 ..			.dmark: db "LPP"  
21e4 f1			.pastdmark: pop af  
21e5			endm  
# End of macro DMARK
21e5 cd 76 6a				call check_stacks 
21e8					FORTH_CHK_LOOP_UNDER 
21e8 e5				push hl 
21e9 d5				push de 
21ea 2a 2b fa			ld hl,(cli_loop_sp) 
21ed 11 65 f9			ld de, cli_loop_stack 
21f0 cd 6a 0f			call cmp16 
21f3 da 90 6b			jp c, fault_loop_under 
21f6 d1				pop de 
21f7 e1				pop hl 
21f8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21f8				endif 
21f8 e5				push hl 
21f9 2a 2b fa			ld hl,(cli_loop_sp) 
21fc 2b				dec hl 
21fd 2b				dec hl 
21fe 22 2b fa			ld (cli_loop_sp), hl 
2201				; TODO do stack underflow checks 
2201 e1				pop hl 
2202				if DEBUG_FORTH_STACK_GUARD 
2202 cd 76 6a				call check_stacks 
2205					FORTH_CHK_LOOP_UNDER 
2205 e5				push hl 
2206 d5				push de 
2207 2a 2b fa			ld hl,(cli_loop_sp) 
220a 11 65 f9			ld de, cli_loop_stack 
220d cd 6a 0f			call cmp16 
2210 da 90 6b			jp c, fault_loop_under 
2213 d1				pop de 
2214 e1				pop hl 
2215				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2215				endif 
2215 c9				ret 
2216			 
2216			macro_forth_dsp_pop: 
2216			 
2216 e5				push hl 
2217			 
2217				; release malloc data 
2217			 
2217				if DEBUG_FORTH_STACK_GUARD 
2217 cd 76 6a				call check_stacks 
221a					FORTH_CHK_DSP_UNDER 
221a e5				push hl 
221b d5				push de 
221c 2a 29 fa			ld hl,(cli_data_sp) 
221f 11 63 f7			ld de, cli_data_stack 
2222 cd 6a 0f			call cmp16 
2225 da 84 6b			jp c, fault_dsp_under 
2228 d1				pop de 
2229 e1				pop hl 
222a				endm 
# End of macro FORTH_CHK_DSP_UNDER
222a				endif 
222a				;ld hl,(cli_data_sp) 
222a			if DEBUG_FORTH_DOT 
222a				DMARK "DPP" 
222a				CALLMONITOR 
222a			endif	 
222a			 
222a			 
222a			if FORTH_ENABLE_DSPPOPFREE 
222a			 
222a				FORTH_DSP 
222a cd 24 21			call macro_forth_dsp 
222d				endm 
# End of macro FORTH_DSP
222d			 
222d 7e				ld a, (hl) 
222e fe 01			cp DS_TYPE_STR 
2230 20 07			jr nz, .skippopfree 
2232			 
2232				FORTH_DSP_VALUEHL 
2232 cd 5e 21			call macro_dsp_valuehl 
2235				endm 
# End of macro FORTH_DSP_VALUEHL
2235 00				nop 
2236			if DEBUG_FORTH_DOT 
2236				DMARK "DPf" 
2236				CALLMONITOR 
2236			endif	 
2236 cd dd 14			call free 
2239			.skippopfree: 
2239				 
2239			 
2239			endif 
2239			 
2239			if DEBUG_FORTH_DOT_KEY 
2239				DMARK "DP2" 
2239				CALLMONITOR 
2239			endif	 
2239			 
2239				; move pointer down 
2239			 
2239 2a 29 fa			ld hl,(cli_data_sp) 
223c 2b				dec hl 
223d 2b				dec hl 
223e			; PARSEV5 
223e 2b				dec hl 
223f 22 29 fa			ld (cli_data_sp), hl 
2242			 
2242				if DEBUG_FORTH_STACK_GUARD 
2242 cd 76 6a				call check_stacks 
2245					FORTH_CHK_DSP_UNDER 
2245 e5				push hl 
2246 d5				push de 
2247 2a 29 fa			ld hl,(cli_data_sp) 
224a 11 63 f7			ld de, cli_data_stack 
224d cd 6a 0f			call cmp16 
2250 da 84 6b			jp c, fault_dsp_under 
2253 d1				pop de 
2254 e1				pop hl 
2255				endm 
# End of macro FORTH_CHK_DSP_UNDER
2255				endif 
2255			 
2255 e1				pop hl 
2256			 
2256 c9				ret 
2257			 
2257			getwordathl: 
2257				; hl points to an address 
2257				; load hl with the word at that address 
2257			 
2257 d5				push de 
2258			 
2258 5e				ld e, (hl) 
2259 23				inc hl 
225a 56				ld d, (hl) 
225b eb				ex de, hl 
225c			 
225c d1				pop de 
225d c9				ret 
225e			 
225e			 
225e			 
225e			 
225e			 
225e			; eof 
225e			 
# End of file forth_stackopsv5.asm
225e			endif 
225e			 
225e			user_word_eol:  
225e				; hl contains the pointer to where to create a linked list item from the end 
225e				; of the user dict to continue on at the system word dict 
225e				 
225e				; poke the stub of the word list linked list to repoint to rom words 
225e			 
225e				; stub format 
225e				; db   word id 
225e				; dw    link to next word 
225e			        ; db char length of token 
225e				; db string + 0 term 
225e				; db exec code....  
225e			 
225e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2260 77				ld (hl), a		; word id 
2261 23				inc hl 
2262			 
2262 11 2d 24			ld de, sysdict 
2265 73				ld (hl), e		; next word link ie system dict 
2266 23				inc hl 
2267 72				ld (hl), d		; next word link ie system dict 
2268 23				inc hl	 
2269			 
2269			;	ld (hl), sysdict		; next word link ie system dict 
2269			;	inc hl 
2269			;	inc hl 
2269			 
2269			;	inc hl 
2269			;	inc hl 
2269			 
2269 3e 02			ld a, 2			; word length is 0 
226b 77				ld (hl), a	 
226c 23				inc hl 
226d			 
226d 3e 7e			ld a, '~'			; word length is 0 
226f 77				ld (hl), a	 
2270 23				inc hl 
2271 3e 00			ld a, 0			; save empty word 
2273 77				ld (hl), a 
2274			 
2274 c9				ret 
2275			 
2275				 
2275			 
2275			forthexec_cleanup: 
2275				FORTH_RSP_POP 
2275 cd 2f 1f			call macro_forth_rsp_pop 
2278				endm 
# End of macro FORTH_RSP_POP
2278 c9				ret 
2279			 
2279			forth_call_hl: 
2279				; taking hl 
2279 e5				push hl 
227a c9				ret 
227b			 
227b			; this is called to reset Forth system but keep existing uwords etc 
227b			 
227b			forth_warmstart: 
227b				; setup stack over/under flow checks 
227b				if DEBUG_FORTH_STACK_GUARD 
227b cd 5c 6a				call chk_stk_init 
227e				endif 
227e			 
227e				; init stack pointers  - * these stacks go upwards *  
227e 21 e7 f9			ld hl, cli_ret_stack 
2281 22 2d fa			ld (cli_ret_sp), hl	 
2284				; set bottom of stack 
2284 3e 00			ld a,0 
2286 77				ld (hl),a 
2287 23				inc hl 
2288 77				ld (hl),a 
2289			 
2289 21 63 f7			ld hl, cli_data_stack 
228c 22 29 fa			ld (cli_data_sp), hl	 
228f				; set bottom of stack 
228f 3e 00			ld a,0 
2291 77				ld (hl),a 
2292 23				inc hl 
2293 77				ld (hl),a 
2294			 
2294 21 65 f9			ld hl, cli_loop_stack 
2297 22 2b fa			ld (cli_loop_sp), hl	 
229a				; set bottom of stack 
229a 3e 00			ld a,0 
229c 77				ld (hl),a 
229d 23				inc hl 
229e 77				ld (hl),a 
229f			 
229f				; init extent of current open file 
229f			 
229f 3e 00			ld a, 0 
22a1 32 71 fa			ld (store_openext), a 
22a4			 
22a4 c9				ret 
22a5			 
22a5			 
22a5			; Cold Start - this is called to setup the whole Forth system 
22a5			 
22a5			forth_init: 
22a5			 
22a5				; setup stack over/under flow checks 
22a5			 
22a5			;	if DEBUG_FORTH_STACK_GUARD 
22a5			;		call chk_stk_init 
22a5			;	endif 
22a5			 
22a5				; enable auto display updates (slow.....) 
22a5			 
22a5 3e 01			ld a, 1 
22a7 32 43 fa			ld (cli_autodisplay), a 
22aa			 
22aa				; if storage is in use disable long reads for now 
22aa 3e 00			ld a, 0 
22ac 32 7c fa			ld (store_longread), a 
22af			 
22af			 
22af				; show start up screen 
22af			 
22af cd 18 0d			call clear_display 
22b2			 
22b2 3e 00			ld a,0 
22b4 32 65 fa			ld (f_cursor_ptr), a 
22b7			 
22b7				; set start of word list in start of ram - for use when creating user words 
22b7			 
22b7 21 00 80			ld hl, baseram 
22ba 22 f9 f4			ld (os_last_new_uword), hl 
22bd cd 5e 22			call user_word_eol 
22c0				 
22c0			;		call display_data_sp 
22c0			;		call next_page_prompt 
22c0			 
22c0			 
22c0			 
22c0			 
22c0 c9				ret 
22c1			 
22c1 .. 00		.bootforth: db " Forth Kernel Init ",0 
22d5			 
22d5			; TODO push to stack 
22d5			 
22d5			;  
22d5			 
22d5			if FORTH_PARSEV2 
22d5			 
22d5			 
22d5				include "forth_parserv2.asm" 
22d5			 
22d5			endif 
22d5			 
22d5			 
22d5			; parse cli version 1 
22d5			 
22d5			if FORTH_PARSEV1 
22d5			 
22d5			 
22d5			 
22d5			      include "forth_parserv1.asm" 
22d5			endif 
22d5				 
22d5			if FORTH_PARSEV3 
22d5			 
22d5			 
22d5			 
22d5			      include "forth_parserv3.asm" 
22d5				include "forth_wordsv3.asm" 
22d5			endif 
22d5			 
22d5			if FORTH_PARSEV4 
22d5			 
22d5			 
22d5			 
22d5			      include "forth_parserv4.asm" 
22d5				include "forth_wordsv4.asm" 
22d5			endif 
22d5			 
22d5			if FORTH_PARSEV5 
22d5			 
22d5			 
22d5			 
22d5			      include "forth_parserv5.asm" 
22d5			 
22d5			 
22d5			; A better parser without using malloc and string copies all over the place.  
22d5			; Exec in situ should be faster 
22d5			 
22d5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
22d5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
22d5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
22d5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
22d5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
22d5			WORD_SYS_END: equ 0   ; Opcode for all user words 
22d5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
22d5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
22d5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
22d5			 
22d5			; Core word preamble macro 
22d5			 
22d5			CWHEAD:   macro nxtword opcode lit len opflags 
22d5				db WORD_SYS_CORE+opcode             
22d5				; internal op code number 
22d5				dw nxtword            
22d5				; link to next dict word block 
22d5				db len + 1 
22d5				; literal length of dict word inc zero term 
22d5				db lit,0              
22d5				; literal dict word 
22d5			        ; TODO db opflags        
22d5				endm 
22d5			 
22d5			 
22d5			NEXTW: macro  
22d5				jp macro_next 
22d5				endm 
22d5			 
22d5			macro_next: 
22d5			if DEBUG_FORTH_PARSE_KEY 
22d5				DMARK "NXT" 
22d5				CALLMONITOR 
22d5			endif	 
22d5			;	inc hl  ; skip token null term  
22d5 ed 4b 47 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22d9 ed 5b 45 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22dd 2a fd f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22e0			if DEBUG_FORTH_PARSE_KEY 
22e0				DMARK "}AA" 
22e0				CALLMONITOR 
22e0			endif	 
22e0 c3 e3 23			jp execnext 
22e3				;jp exec1 
22e3			       
22e3			 
22e3			 
22e3			; Another go at the parser to compile  
22e3			 
22e3			 
22e3			; TODO rework parser to change all of the string words to byte tokens 
22e3			; TODO do a search for  
22e3			 
22e3			; TODO first run normal parser to zero term sections 
22e3			; TODO for each word do a token look up to get the op code 
22e3			; TODO need some means to flag to the exec that this is a byte code form    
22e3			 
22e3			 
22e3			forthcompile: 
22e3			 
22e3			; 
22e3			; line parse: 
22e3			;       parse raw input buffer 
22e3			;       tokenise the words 
22e3			;       malloc new copy (for looping etc) 
22e3			;       copy to malloc + current pc in line to start of string and add line term 
22e3			;       save on new rsp 
22e3			; 
22e3			 
22e3			; hl to point to the line to tokenise 
22e3			 
22e3			;	push hl 
22e3 22 fd f4			ld (os_tok_ptr), hl  ; save ptr to string 
22e6			 
22e6			;	ld a,0		; string term on input 
22e6			;	call strlent 
22e6			 
22e6			;	ld (os_tok_len), hl	 ; save string length 
22e6			 
22e6			;if DEBUG_FORTH_TOK 
22e6			;	ex de,hl		 
22e6			;endif 
22e6			 
22e6			;	pop hl 		; get back string pointer 
22e6			 
22e6			if DEBUG_FORTH_TOK 
22e6						DMARK "TOc" 
22e6				CALLMONITOR 
22e6			endif 
22e6 7e			.cptoken2:    ld a,(hl) 
22e7 23				inc hl 
22e8 fe 7f			cp FORTH_END_BUFFER 
22ea 28 29			jr z, .cptokendone2 
22ec fe 00			cp 0 
22ee 28 25			jr z, .cptokendone2 
22f0 fe 22			cp '"' 
22f2 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
22f4 fe 20			cp ' ' 
22f6 20 ee			jr nz,  .cptoken2 
22f8			 
22f8			; TODO consume comments held between ( and ) 
22f8			 
22f8				; we have a space so change to zero term for dict match later 
22f8 2b				dec hl 
22f9 3e 00			ld a,0 
22fb 77				ld (hl), a 
22fc 23				inc hl 
22fd 18 e7			jr .cptoken2 
22ff				 
22ff			 
22ff			.cptokenstr2: 
22ff				; skip all white space until either eol (because forgot to term) or end double quote 
22ff			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22ff				;inc hl ; skip current double quote 
22ff 7e				ld a,(hl) 
2300 23				inc hl 
2301 fe 22			cp '"' 
2303 28 e1			jr z, .cptoken2 
2305 fe 7f			cp FORTH_END_BUFFER 
2307 28 0c			jr z, .cptokendone2 
2309 fe 00			cp 0 
230b 28 08			jr z, .cptokendone2 
230d fe 20			cp ' ' 
230f 28 02			jr z, .cptmp2 
2311 18 ec			jr .cptokenstr2 
2313			 
2313			.cptmp2:	; we have a space so change to zero term for dict match later 
2313				;dec hl 
2313				;ld a,"-"	; TODO remove this when working 
2313				;ld (hl), a 
2313				;inc hl 
2313 18 ea			jr .cptokenstr2 
2315			 
2315			.cptokendone2: 
2315				;inc hl 
2315 3e 7f			ld a, FORTH_END_BUFFER 
2317 77				ld (hl),a 
2318 23				inc hl 
2319 3e 21			ld a, '!' 
231b 77				ld (hl),a 
231c			 
231c 2a fd f4			ld hl,(os_tok_ptr) 
231f			         
231f			if DEBUG_FORTH_TOK 
231f						DMARK "Tc1" 
231f				CALLMONITOR 
231f			endif 
231f			 
231f				; push exec string to top of return stack 
231f				FORTH_RSP_NEXT 
231f cd 0e 1f			call macro_forth_rsp_next 
2322				endm 
# End of macro FORTH_RSP_NEXT
2322 c9				ret 
2323			 
2323			; Another go at the parser need to simplify the process 
2323			 
2323			forthparse: 
2323			 
2323			; 
2323			; line parse: 
2323			;       parse raw input buffer 
2323			;       tokenise the words 
2323			;       malloc new copy (for looping etc) 
2323			;       copy to malloc + current pc in line to start of string and add line term 
2323			;       save on new rsp 
2323			; 
2323			 
2323			; hl to point to the line to tokenise 
2323			 
2323			;	push hl 
2323 22 fd f4			ld (os_tok_ptr), hl  ; save ptr to string 
2326			 
2326			;	ld a,0		; string term on input 
2326			;	call strlent 
2326			 
2326			;	ld (os_tok_len), hl	 ; save string length 
2326			 
2326			;if DEBUG_FORTH_TOK 
2326			;	ex de,hl		 
2326			;endif 
2326			 
2326			;	pop hl 		; get back string pointer 
2326			 
2326			if DEBUG_FORTH_TOK 
2326						DMARK "TOK" 
2326				CALLMONITOR 
2326			endif 
2326 7e			.ptoken2:    ld a,(hl) 
2327 23				inc hl 
2328 fe 7f			cp FORTH_END_BUFFER 
232a 28 29			jr z, .ptokendone2 
232c fe 00			cp 0 
232e 28 25			jr z, .ptokendone2 
2330 fe 22			cp '"' 
2332 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2334 fe 20			cp ' ' 
2336 20 ee			jr nz,  .ptoken2 
2338			 
2338			; TODO consume comments held between ( and ) 
2338			 
2338				; we have a space so change to zero term for dict match later 
2338 2b				dec hl 
2339 3e 00			ld a,0 
233b 77				ld (hl), a 
233c 23				inc hl 
233d 18 e7			jr .ptoken2 
233f				 
233f			 
233f			.ptokenstr2: 
233f				; skip all white space until either eol (because forgot to term) or end double quote 
233f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
233f				;inc hl ; skip current double quote 
233f 7e				ld a,(hl) 
2340 23				inc hl 
2341 fe 22			cp '"' 
2343 28 e1			jr z, .ptoken2 
2345 fe 7f			cp FORTH_END_BUFFER 
2347 28 0c			jr z, .ptokendone2 
2349 fe 00			cp 0 
234b 28 08			jr z, .ptokendone2 
234d fe 20			cp ' ' 
234f 28 02			jr z, .ptmp2 
2351 18 ec			jr .ptokenstr2 
2353			 
2353			.ptmp2:	; we have a space so change to zero term for dict match later 
2353				;dec hl 
2353				;ld a,"-"	; TODO remove this when working 
2353				;ld (hl), a 
2353				;inc hl 
2353 18 ea			jr .ptokenstr2 
2355			 
2355			.ptokendone2: 
2355				;inc hl 
2355 3e 7f			ld a, FORTH_END_BUFFER 
2357 77				ld (hl),a 
2358 23				inc hl 
2359 3e 21			ld a, '!' 
235b 77				ld (hl),a 
235c			 
235c 2a fd f4			ld hl,(os_tok_ptr) 
235f			         
235f			if DEBUG_FORTH_TOK 
235f						DMARK "TK1" 
235f				CALLMONITOR 
235f			endif 
235f			 
235f				; push exec string to top of return stack 
235f				FORTH_RSP_NEXT 
235f cd 0e 1f			call macro_forth_rsp_next 
2362				endm 
# End of macro FORTH_RSP_NEXT
2362 c9				ret 
2363			 
2363			; 
2363			;	; malloc size + buffer pointer + if is loop flag 
2363			;	ld hl,(os_tok_len) 		 ; get string length 
2363			; 
2363			;	ld a,l 
2363			; 
2363			;	cp 0			; we dont want to use a null string 
2363			;	ret z 
2363			; 
2363			;;	add 3    ; prefix malloc with buffer for current word ptr 
2363			; 
2363			;	add 5     ; TODO when certain not over writing memory remove 
2363			; 
2363			;		 
2363			; 
2363			;if DEBUG_FORTH_TOK 
2363			;			DMARK "TKE" 
2363			;	CALLMONITOR 
2363			;endif 
2363			; 
2363			;	ld l,a 
2363			;	ld h,0 
2363			;;	push hl   ; save required space for the copy later 
2363			;	call malloc 
2363			;if DEBUG_FORTH_TOK 
2363			;			DMARK "TKM" 
2363			;	CALLMONITOR 
2363			;endif 
2363			;	if DEBUG_FORTH_MALLOC_GUARD 
2363			;		push af 
2363			;		call ishlzero 
2363			;;		ld a, l 
2363			;;		add h 
2363			;;		cp 0 
2363			;		pop af 
2363			;		 
2363			;		call z,malloc_error 
2363			;	endif 
2363			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2363			; 
2363			; 
2363			;if DEBUG_FORTH_TOK 
2363			;			DMARK "TKR" 
2363			;	CALLMONITOR 
2363			;endif 
2363			; 
2363			;	FORTH_RSP_NEXT 
2363			; 
2363			;	;inc hl	 ; go past current buffer pointer 
2363			;	;inc hl 
2363			;	;inc hl   ; and past if loop flag 
2363			;		; TODO Need to set flag  
2363			; 
2363			;	 
2363			;	 
2363			;	ex de,hl	; malloc is dest 
2363			;	ld hl, (os_tok_len) 
2363			;;	pop bc 
2363			;	ld c, l                
2363			;	ld b,0 
2363			;	ld hl, (os_tok_ptr) 
2363			; 
2363			;if DEBUG_FORTH_TOK 
2363			;			DMARK "TKT" 
2363			;	CALLMONITOR 
2363			;endif 
2363			; 
2363			;	; do str cpy 
2363			; 
2363			;	ldir      ; copy byte in hl to de 
2363			; 
2363			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2363			; 
2363			;if DEBUG_FORTH_TOK 
2363			; 
2363			;			DMARK "TKY" 
2363			;	CALLMONITOR 
2363			;endif 
2363			;	;ld a,0 
2363			;	;ld a,FORTH_END_BUFFER 
2363			;	ex de, hl 
2363			;	;dec hl			 ; go back over the space delim at the end of word 
2363			;	;ld (hl),a 
2363			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2363			;	ld a,FORTH_END_BUFFER 
2363			;	ld (hl),a 
2363			;	inc hl 
2363			;	ld a,FORTH_END_BUFFER 
2363			;	ld (hl),a 
2363			; 
2363			;	; init the malloc area data 
2363			;	; set pc for in current area 
2363			;	;ld hl, (os_tok_malloc) 
2363			;	;inc hl 
2363			;	;inc hl 
2363			;	;inc hl 
2363			;	;ex de,hl 
2363			;	;ld hl, (os_tok_malloc) 
2363			;	;ld (hl),e 
2363			;	;inc hl 
2363			;	;ld (hl),d 
2363			; 
2363			; 
2363			;	ld hl,(os_tok_malloc) 
2363			;if DEBUG_FORTH_PARSE_KEY 
2363			;			DMARK "TKU" 
2363			;	CALLMONITOR 
2363			;endif 
2363			; 
2363			;	ret 
2363			 
2363			forthexec: 
2363			 
2363			; line exec: 
2363			; forth parser 
2363			 
2363			; 
2363			;       get current exec line on rsp 
2363			 
2363				FORTH_RSP_TOS 
2363 cd 25 1f			call macro_forth_rsp_tos 
2366				endm 
# End of macro FORTH_RSP_TOS
2366			 
2366			;       restore current pc - hl points to malloc of data 
2366			 
2366				;ld e, (hl) 
2366				;inc hl 
2366				;ld d, (hl) 
2366				;ex de,hl 
2366			 
2366			 
2366			exec1: 
2366 22 fd f4			ld (os_tok_ptr), hl 
2369			 
2369				; copy our PC to working vars  
2369 22 47 fa			ld (cli_ptr), hl 
236c 22 45 fa			ld (cli_origptr), hl 
236f			 
236f 7e				ld a,(hl) 
2370 fe 7f			cp FORTH_END_BUFFER 
2372 c8				ret z 
2373			 
2373				; skip any nulls 
2373			 
2373 fe 00			cp 0 
2375 20 03			jr nz, .execword 
2377 23				inc hl 
2378 18 ec			jr exec1 
237a			 
237a			 
237a			.execword: 
237a			 
237a			 
237a			 
237a			if DEBUG_FORTH_PARSE_KEY 
237a						DMARK "KYQ" 
237a				CALLMONITOR 
237a			endif 
237a			;       while at start of word: 
237a			; get start of dict (in user area first) 
237a			 
237a 21 00 80		ld hl, baseram 
237d			;ld hl, sysdict 
237d 22 49 fa		ld (cli_nextword),hl 
2380			;           match word at pc 
2380			;           exec word 
2380			;           or push to dsp 
2380			;           forward to next token 
2380			;           if line term pop rsp and exit 
2380			;        
2380			 
2380			if DEBUG_FORTH_PARSE_KEY 
2380						DMARK "KYq" 
2380				CALLMONITOR 
2380			endif 
2380			 
2380			; 
2380			; word comp 
2380			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2380			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2380			;    move to start of word  
2380			;    compare word to cli_token 
2380			 
2380			.execpnword:	; HL at start of a word in the dictionary to check 
2380			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2380			;	ld (cli_ptr), hl 
2380			 
2380 2a 49 fa			ld hl,(cli_nextword) 
2383			 
2383 cd 26 24			call forth_tok_next 
2386			; tok next start here 
2386			;	; TODO skip compiled symbol for now 
2386			;	inc hl 
2386			; 
2386			;	; save pointer to next word 
2386			; 
2386			;	; hl now points to the address of the next word pointer  
2386			;	ld e, (hl) 
2386			;	inc hl 
2386			;	ld d, (hl) 
2386			;	inc l 
2386			; 
2386			;	ex de,hl 
2386			;if DEBUG_FORTH_PARSE_NEXTWORD 
2386			;	push bc 
2386			;	ld bc, (cli_nextword) 
2386			;			DMARK "NXW" 
2386			;	CALLMONITOR 
2386			;	pop bc 
2386			;endif 
2386			; tok next end here 
2386 22 49 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2389 eb				ex de, hl 
238a			 
238a			 
238a				; save the pointer of the current token - 1 to check against 
238a				 
238a 22 4d fa			ld (cli_token), hl   
238d				; TODO maybe remove below save if no debug 
238d				; save token string ptr for any debug later 
238d 23				inc hl  
238e 22 4f fa			ld (cli_origtoken), hl 
2391 2b				dec hl 
2392				; save pointer to the start of the next dictionay word 
2392 7e				ld a,(hl)   ; get string length 
2393 47				ld b,a 
2394			.execpnwordinc:  
2394 23				inc hl 
2395 10 fd			djnz .execpnwordinc 
2397 22 4b fa			ld (cli_execword), hl      ; save start of this words code 
239a			 
239a				; now check the word token against the string being parsed 
239a			 
239a 2a 4d fa			ld hl,(cli_token) 
239d 23				inc hl     ; skip string length (use zero term instead to end) 
239e 22 4d fa			ld (cli_token), hl 
23a1			 
23a1			if DEBUG_FORTH_PARSE_KEY 
23a1						DMARK "KY2" 
23a1			endif 
23a1			if DEBUG_FORTH_PARSE_EXEC 
23a1				; see if disabled 
23a1			 
23a1				ld a, (os_view_disable) 
23a1				cp '*' 
23a1				jr z, .skip 
23a1			 
23a1				push hl 
23a1				push hl 
23a1				call clear_display 
23a1				ld de, .compword 
23a1				ld a, display_row_1 
23a1				call str_at_display 
23a1				pop de 
23a1				ld a, display_row_2 
23a1				call str_at_display 
23a1				ld hl,(cli_ptr) 
23a1				ld a,(hl) 
23a1			        ld hl, os_word_scratch 
23a1				ld (hl),a 
23a1				ld a,0 
23a1				inc hl 
23a1				ld (hl),a 	 
23a1				ld de, os_word_scratch 
23a1				ld a, display_row_2+10 
23a1				call str_at_display 
23a1				call update_display 
23a1				ld a, 100 
23a1				call aDelayInMS 
23a1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23a1				call delay250ms 
23a1				endif 
23a1				pop hl 
23a1			.skip:  
23a1			endif	 
23a1			.execpnchar:    ; compare char between token and string to parse 
23a1			 
23a1			if DEBUG_FORTH_PARSE_KEY 
23a1						DMARK "Ky3" 
23a1			endif 
23a1			if DEBUG_FORTH_PARSE_EXEC 
23a1				; see if disabled 
23a1			 
23a1				ld a, (os_view_disable) 
23a1				cp '*' 
23a1				jr z, .skip2 
23a1			 
23a1			;	call clear_display 
23a1			ld hl,(cli_token) 
23a1			ld a,(hl) 
23a1			ld (os_word_scratch),a 
23a1				ld hl,(cli_ptr) 
23a1			ld a,(hl) 
23a1				ld (os_word_scratch+1),a 
23a1				ld a,0 
23a1				ld (os_word_scratch+2),a 
23a1				ld de,os_word_scratch 
23a1				ld a,display_row_4 
23a1				call str_at_display 
23a1				call update_display 
23a1			.skip2:  
23a1			endif 
23a1 2a 4d fa			ld hl,(cli_token) 
23a4 7e				ld a, (hl)	 ; char in word token 
23a5 23				inc hl 		; move to next char 
23a6 22 4d fa			ld (cli_token), hl ; and save it 
23a9 47				ld b,a 
23aa			 
23aa 2a 47 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
23ad 7e				ld a,(hl) 
23ae 23				inc hl 
23af 22 47 fa			ld (cli_ptr), hl		; move to next char 
23b2 cd a1 13			call toUpper 		; make sure the input string matches case 
23b5			 
23b5			if DEBUG_FORTH_PARSE 
23b5			endif 
23b5			 
23b5				; input stream end of token is a space so get rid of it 
23b5			 
23b5			;	cp ' ' 
23b5			;	jr nz, .pnskipspace 
23b5			; 
23b5			;	ld a, 0		; make same term as word token term 
23b5			; 
23b5			;.pnskipspace: 
23b5			 
23b5			if DEBUG_FORTH_PARSE_KEY 
23b5						DMARK "KY7" 
23b5			endif 
23b5 b8				cp b 
23b6 c2 cc 23			jp nz, .execpnskipword	 ; no match so move to next word 
23b9				 
23b9			;    if same 
23b9			;       scan for string terms 0 for token and 32 for input 
23b9			 
23b9				 
23b9			if DEBUG_FORTH_PARSE_KEY 
23b9						DMARK "KY8" 
23b9			endif 
23b9			 
23b9 80				add b			 
23ba fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23bc							; TODO need to make sure last word in zero term string is accounted for 
23bc 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23be			 
23be			 
23be				; at end of both strings so both are exact match 
23be			 
23be			;       skip ptr for next word 
23be			 
23be 2a 47 fa			ld hl,(cli_ptr) 	; at input string term 
23c1 23				inc hl			 ; at next char 
23c2 22 47 fa			ld (cli_ptr), hl     ; save for next round of the parser 
23c5 22 45 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
23c8				 
23c8				 
23c8			if DEBUG_FORTH_PARSE_KEY 
23c8						DMARK "KY3" 
23c8			endif 
23c8			 
23c8			 
23c8			 
23c8			;       exec code block 
23c8			if DEBUG_FORTH_JP 
23c8				call clear_display 
23c8				call update_display 
23c8				call delay1s 
23c8				ld hl, (cli_execword)     ; save for next check if no match on this word 
23c8				ld a,h 
23c8				ld hl, os_word_scratch 
23c8				call hexout 
23c8				ld hl, (cli_execword)     ; save for next check if no match on this word 
23c8				ld a,l 
23c8				ld hl, os_word_scratch+2 
23c8				call hexout 
23c8				ld hl, os_word_scratch+4 
23c8				ld a,0 
23c8				ld (hl),a 
23c8				ld de,os_word_scratch 
23c8				call str_at_display 
23c8					ld a, display_row_2 
23c8					call str_at_display 
23c8				ld de, (cli_origtoken) 
23c8				ld a, display_row_1+10 
23c8					call str_at_display 
23c8			 
23c8				ld a,display_row_1 
23c8				ld de, .foundword 
23c8				ld a, display_row_3 
23c8				call str_at_display 
23c8				call update_display 
23c8				call delay1s 
23c8				call delay1s 
23c8				call delay1s 
23c8			endif 
23c8			 
23c8			if DEBUG_FORTH_PARSE_KEY 
23c8						DMARK "KYj" 
23c8			endif 
23c8				; TODO save the word pointer in this exec 
23c8			 
23c8 2a 4b fa			ld hl,(cli_execword) 
23cb e9				jp (hl) 
23cc			 
23cc			 
23cc			;    if not same 
23cc			;	scan for zero term 
23cc			;	get ptr for next word 
23cc			;	goto word comp 
23cc			 
23cc			.execpnskipword:	; get pointer to next word 
23cc 2a 49 fa			ld hl,(cli_nextword) 
23cf			 
23cf 7e				ld a,(hl) 
23d0 fe 00			cp WORD_SYS_END 
23d2			;	cp 0 
23d2 28 09			jr z, .execendofdict			 ; at end of words 
23d4			 
23d4			if DEBUG_FORTH_PARSE_KEY 
23d4						DMARK "KY4" 
23d4			endif 
23d4			if DEBUG_FORTH_PARSE_EXEC 
23d4			 
23d4				; see if disabled 
23d4			 
23d4				ld a, (os_view_disable) 
23d4				cp '*' 
23d4				jr z, .noskip 
23d4			 
23d4			 
23d4				ld de, .nowordfound 
23d4				ld a, display_row_3 
23d4				call str_at_display 
23d4				call update_display 
23d4				ld a, 100 
23d4				call aDelayInMS 
23d4				 
23d4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23d4					call delay250ms 
23d4				endif 
23d4			.noskip:  
23d4			 
23d4			endif	 
23d4			 
23d4 2a 45 fa			ld hl,(cli_origptr) 
23d7 22 47 fa			ld (cli_ptr),hl 
23da			 
23da			if DEBUG_FORTH_PARSE_KEY 
23da						DMARK "KY5" 
23da			endif 
23da c3 80 23			jp .execpnword			; else go to next word 
23dd			 
23dd			.execendofdict:  
23dd			 
23dd			if DEBUG_FORTH_PARSE_KEY 
23dd						DMARK "KYe" 
23dd			endif 
23dd			if DEBUG_FORTH_PARSE_EXEC 
23dd				; see if disabled 
23dd			 
23dd				ld a, (os_view_disable) 
23dd				cp '*' 
23dd				jr z, .ispskip 
23dd			 
23dd				call clear_display 
23dd				call update_display 
23dd				call delay1s 
23dd				ld de, (cli_origptr) 
23dd				ld a, display_row_1 
23dd				call str_at_display 
23dd				 
23dd				ld de, .enddict 
23dd				ld a, display_row_3 
23dd				call str_at_display 
23dd				call update_display 
23dd				ld a, 100 
23dd				call aDelayInMS 
23dd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23dd				call delay1s 
23dd				call delay1s 
23dd				call delay1s 
23dd				endif 
23dd			.ispskip:  
23dd				 
23dd			endif	 
23dd			 
23dd			 
23dd			 
23dd				; if the word is not a keyword then must be a literal so push it to stack 
23dd			 
23dd			; push token to stack to end of word 
23dd			 
23dd				STACKFRAME ON $1efe $2f9f 
23dd				if DEBUG_STACK_IMB 
23dd					if ON 
23dd						exx 
23dd						ld de, $1efe 
23dd						ld a, d 
23dd						ld hl, curframe 
23dd						call hexout 
23dd						ld a, e 
23dd						ld hl, curframe+2 
23dd						call hexout 
23dd						ld hl, $1efe 
23dd						push hl 
23dd						ld hl, $2f9f 
23dd						push hl 
23dd						exx 
23dd					endif 
23dd				endif 
23dd			endm 
# End of macro STACKFRAME
23dd			 
23dd 2a fd f4		ld hl,(os_tok_ptr) 
23e0 cd d0 20		call forth_apush 
23e3			 
23e3				STACKFRAMECHK ON $1efe $2f9f 
23e3				if DEBUG_STACK_IMB 
23e3					if ON 
23e3						exx 
23e3						ld hl, $2f9f 
23e3						pop de   ; $2f9f 
23e3						call cmp16 
23e3						jr nz, .spnosame 
23e3						ld hl, $1efe 
23e3						pop de   ; $1efe 
23e3						call cmp16 
23e3						jr z, .spfrsame 
23e3						.spnosame: call showsperror 
23e3						.spfrsame: nop 
23e3						exx 
23e3					endif 
23e3				endif 
23e3			endm 
# End of macro STACKFRAMECHK
23e3			 
23e3			execnext: 
23e3			 
23e3			if DEBUG_FORTH_PARSE_KEY 
23e3						DMARK "KY>" 
23e3			endif 
23e3			; move past token to next word 
23e3			 
23e3 2a fd f4		ld hl, (os_tok_ptr) 
23e6 3e 00		ld a, 0 
23e8 01 ff 00		ld bc, 255     ; input buffer size 
23eb ed b1		cpir 
23ed			 
23ed			if DEBUG_FORTH_PARSE_KEY 
23ed						DMARK "KY!" 
23ed				CALLMONITOR 
23ed			endif	 
23ed			; TODO this might place hl on the null, so will need to forward on??? 
23ed			;inc hl   ; see if this gets onto the next item 
23ed			 
23ed			 
23ed			; TODO pass a pointer to the buffer to push 
23ed			; TODO call function to push 
23ed			 
23ed			; look for end of input 
23ed			 
23ed			;inc hl 
23ed			;ld a,(hl) 
23ed			;cp FORTH_END_BUFFER 
23ed			;ret z 
23ed			 
23ed			 
23ed c3 66 23		jp exec1 
23f0			 
23f0			 
23f0			 
23f0			 
23f0			 
23f0			 
23f0			 
23f0			 
23f0			 
23f0			findnexttok: 
23f0			 
23f0				; hl is pointer to move 
23f0				; de is the token to locate 
23f0			 
23f0					if DEBUG_FORTH 
23f0						DMARK "NTK" 
23f0						CALLMONITOR 
23f0					endif 
23f0 d5				push de 
23f1			 
23f1			.fnt1:	 
23f1				; find first char of token to locate 
23f1			 
23f1 1a				ld a, (de) 
23f2 4f				ld c,a 
23f3 7e				ld a,(hl) 
23f4 cd a1 13			call toUpper 
23f7					if DEBUG_FORTH 
23f7						DMARK "NT1" 
23f7						CALLMONITOR 
23f7					endif 
23f7 b9				cp c 
23f8			 
23f8 28 03			jr z, .fnt2cmpmorefirst	 
23fa			 
23fa				; first char not found move to next char 
23fa			 
23fa 23				inc hl 
23fb 18 f4			jr .fnt1 
23fd			 
23fd			.fnt2cmpmorefirst:	 
23fd				; first char of token found.  
23fd			 
23fd e5				push hl     ; save start of token just in case it is the right one 
23fe d9				exx 
23ff e1				pop hl        ; save it to hl' 
2400 d9				exx 
2401			 
2401			 
2401			.fnt2cmpmore:	 
2401				; compare the rest 
2401				 
2401 23				inc hl 
2402 13				inc de 
2403				 
2403 1a				ld a, (de) 
2404 4f				ld c,a 
2405 7e				ld a,(hl) 
2406 cd a1 13			call toUpper 
2409			 
2409					if DEBUG_FORTH 
2409						DMARK "NT2" 
2409						CALLMONITOR 
2409					endif 
2409				; c has the token to find char 
2409				; a has the mem to scan char 
2409			 
2409 b9				cp c 
240a 28 04			jr z,.fntmatch1 
240c			 
240c				; they are not the same 
240c			 
240c					if DEBUG_FORTH 
240c						DMARK "NT3" 
240c						CALLMONITOR 
240c					endif 
240c d1				pop de	; reset de token to look for 
240d d5				push de 
240e 18 e1			jr .fnt1 
2410				 
2410			.fntmatch1: 
2410			 
2410				; is the same char a null which means we might have a full hit? 
2410					if DEBUG_FORTH 
2410						DMARK "NT4" 
2410						CALLMONITOR 
2410					endif 
2410			 
2410 fe 00			cp 0 
2412 28 0b			jr z, .fntmatchyes 
2414			 
2414				; are we at the end of the token to find? 
2414			 
2414					if DEBUG_FORTH 
2414						DMARK "NT5" 
2414						CALLMONITOR 
2414					endif 
2414 3e 00			ld a, 0 
2416 b9				cp c 
2417			 
2417 c2 01 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
241a			 
241a					if DEBUG_FORTH 
241a						DMARK "NT6" 
241a						CALLMONITOR 
241a					endif 
241a				; token to find is exhusted but no match to stream 
241a			 
241a				; restore tok pointer and continue on 
241a d1				pop de 
241b d5				push de 
241c c3 f1 23			jp .fnt1 
241f			 
241f			 
241f			.fntmatchyes: 
241f			 
241f				; hl now contains the end of the found token 
241f			 
241f				; get rid of saved token pointer to find 
241f			 
241f d1				pop de 
2420			 
2420					if DEBUG_FORTH 
2420						DMARK "NT9" 
2420						CALLMONITOR 
2420					endif 
2420			 
2420				; hl will be on the null term so forward on 
2420			 
2420				; get back the saved start of the token 
2420			 
2420 d9				exx 
2421 e5				push hl     ; save start of token just in case it is the right one 
2422 d9				exx 
2423 e1				pop hl        ; save it to hl 
2424			 
2424 c9				ret 
2425			 
2425			 
2425			; LIST needs to find a specific token   
2425			; FORGET needs to find a spefici token 
2425			 
2425			; SAVE needs to find all tokens by flag 
2425			; WORDS just needs to scan through all  by flag 
2425			; UWORDS needs to scan through all by flag 
2425			 
2425			 
2425			; given hl as pointer to start of dict look up string 
2425			; return hl as pointer to start of word block 
2425			; or 0 if not found 
2425			 
2425			forth_find_tok: 
2425 c9				ret 
2426			 
2426			; given hl as pointer to dict structure 
2426			; move to the next dict block structure 
2426			 
2426			forth_tok_next: 
2426				; hl now points to the address of the next word pointer  
2426				; TODO skip compiled symbol for now 
2426			;	push de 
2426 23				inc hl 
2427 5e				ld e, (hl) 
2428 23				inc hl 
2429 56				ld d, (hl) 
242a 23				inc hl 
242b			 
242b eb				ex de,hl 
242c			if DEBUG_FORTH_PARSE_NEXTWORD 
242c				push bc 
242c				ld bc, (cli_nextword) 
242c						DMARK "NXW" 
242c				CALLMONITOR 
242c				pop bc 
242c			endif 
242c			;	pop de	 
242c c9				ret 
242d			 
242d			 
242d			 
242d			; eof 
# End of file forth_parserv5.asm
242d				include "forth_wordsv4.asm" 
242d			 
242d			; the core word dictionary v4 
242d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
242d			 
242d			; this is a linked list for each of the system words used 
242d			; user defined words will follow the same format but will be in ram 
242d			 
242d			 
242d			; 
242d			; 
242d			; define linked list: 
242d			; 
242d			; 1. compiled byte op code 
242d			; 2. len of text word 
242d			; 3. text word 
242d			; 4. ptr to next dictionary word 
242d			; 5. asm, calls etc for the word 
242d			; 
242d			;  if 1 == 0 then last word in dict  
242d			;   
242d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
242d			;  
242d			;  
242d			; create basic standard set of words 
242d			; 
242d			;  
242d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
242d			; 2DUP 2DROP 2SWAP  
242d			; @ C@ - get byte  
242d			; ! C! - store byte 
242d			; 0< true if less than zero 
242d			; 0= true if zero 
242d			; < >  
242d			; = true if same 
242d			; variables 
242d			 
242d			 
242d			; Hardware specific words I may need 
242d			; 
242d			; IN OUT  
242d			; calls to key util functions 
242d			; calls to hardward abstraction stuff 
242d			; easy control of frame buffers and lcd i/o 
242d			; keyboard  
242d			 
242d			 
242d			;DICT: macro 
242d			; op_code, len, word, next 
242d			;    word: 
242d			;    db op_code 
242d			;    ds word zero term 
242d			;    dw next 
242d			;    endm 
242d			 
242d			 
242d			 
242d			 
242d			; op code 1 is a flag for user define words which are to be handled differently 
242d			 
242d			 
242d			; 
242d			; 
242d			;    TODO on entry to a word this should be the expected environment 
242d			;    hl - tos value if number then held, if string this is the ptr 
242d			;    de -  
242d			 
242d			 
242d			; opcode ranges 
242d			; 0 - end of word dict 
242d			; 255 - user define words 
242d			 
242d			sysdict: 
242d			include "forth_opcodes.asm" 
242d			; op codes for forth keywords 
242d			; free to use code 0  
242d				OPCODE_HEAP: equ  1 
242d				OPCODE_EXEC: equ 2 
242d				OPCODE_DUP: equ 3 
242d				OPCODE_SWAP: equ 4 
242d				OPCODE_COLN: equ 5 
242d				OPCODE_SCOLN: equ 6 
242d				OPCODE_DROP: equ 7 
242d				OPCODE_DUP2: equ 8 
242d				OPCODE_DROP2: equ 9 
242d				OPCODE_SWAP2: equ 10 
242d				OPCODE_AT: equ 11 
242d				OPCODE_CAT: equ 12 
242d				OPCODE_BANG: equ 13 
242d				OPCODE_CBANG: equ 14 
242d				OPCODE_SCALL: equ 15 
242d				OPCODE_DEPTH: equ 16 
242d				OPCODE_OVER: equ 17 
242d				OPCODE_PAUSE: equ 18 
242d				OPCODE_PAUSES: equ 19 
242d				OPCODE_ROT: equ 20 
242d			;free to reuse	OPCODE_WORDS: equ 21 
242d			        OPCODE_NOT: equ 21 
242d				OPCODE_UWORDS: equ 22 
242d				OPCODE_BP: equ 23 
242d				OPCODE_MONITOR: equ 24  
242d				OPCODE_MALLOC: equ 25 
242d				OPCODE_FREE: equ 26 
242d				OPCODE_LIST: equ 27 
242d				OPCODE_FORGET: equ 28 
242d				OPCODE_NOP: equ 29 
242d				OPCODE_COMO: equ 30 
242d				OPCODE_COMC: equ 31 
242d			;free to reuse	OPCODE_ENDCORE: equ 32 
242d				OPCODE_AFTERSOUND: equ 33 
242d				OPCODE_GP2: equ 34 
242d				OPCODE_GP3: equ 35 
242d				OPCODE_GP4: equ 36 
242d				OPCODE_SIN: equ 37 
242d				OPCODE_SOUT: equ 38 
242d				OPCODE_SPIO: equ 39 
242d				OPCODE_SPICEH: equ 40 
242d				OPCODE_SPIOb: equ 41 
242d				OPCODE_SPII: equ 42 
242d				OPCODE_SESEL: equ 43 
242d				OPCODE_CARTDEV: equ 44 
242d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
242d				OPCODE_FB: equ 46 
242d				OPCODE_EMIT: equ 47 
242d				OPCODE_DOTH: equ 48 
242d				OPCODE_DOTF: equ 49 
242d				OPCODE_DOT: equ 50 
242d				OPCODE_CLS: equ 51 
242d				OPCODE_DRAW: equ 52 
242d				OPCODE_DUMP: equ 53 
242d				OPCODE_CDUMP: equ 54 
242d				OPCODE_DAT: equ 55 
242d				OPCODE_HOME: equ 56 
242d				OPCODE_SPACE: equ 57 
242d				OPCODE_SPACES: equ 58 
242d				OPCODE_SCROLL: equ 59 
242d				OPCODE_ATQ: equ 60 
242d				OPCODE_AUTODSP: equ 61 
242d				OPCODE_MENU: equ 62 
242d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
242d				OPCODE_THEN: equ 64 
242d				OPCODE_ELSE: equ 65 
242d				OPCODE_DO: equ 66 
242d				OPCODE_LOOP: equ 67 
242d				OPCODE_I: equ 68 
242d				OPCODE_DLOOP: equ 69  
242d				OPCODE_REPEAT: equ 70  
242d				OPCODE_UNTIL: equ 71 
242d				OPCODE_ENDFLOW: equ 72 
242d				OPCODE_WAITK: equ 73 
242d				OPCODE_ACCEPT: equ 74 
242d				OPCODE_EDIT: equ 75 
242d			;free to reuse	OPCODE_ENDKEY: equ 76 
242d				OPCODE_LZERO: equ 77 
242d				OPCODE_TZERO: equ 78 
242d				OPCODE_LESS: equ 79 
242d				OPCODE_GT: equ 80 
242d				OPCODE_EQUAL: equ 81  
242d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
242d				OPCODE_NEG: equ 83 
242d				OPCODE_DIV: equ 84 
242d				OPCODE_MUL: equ 85 
242d				OPCODE_MIN: equ 86 
242d				OPCODE_MAX: equ 87 
242d				OPCODE_RND16: equ 88 
242d				OPCODE_RND8: equ 89 
242d				OPCODE_RND: equ 90 
242d			;free to reuse	OPCODE_ENDMATHS: equ 91  
242d				OPCODE_BYNAME: equ 92 
242d				OPCODE_DIR: equ 93 
242d				OPCODE_SAVE: equ 94 
242d				OPCODE_LOAD: equ 95 
242d				OPCODE_BSAVE: equ 96 
242d				OPCODE_BLOAD: equ 97 
242d				OPCODE_SEO: equ 98  
242d				OPCODE_SEI: equ 99 
242d				OPCODE_SFREE: equ 100 
242d				OPCODE_SIZE: equ 101 
242d				OPCODE_CREATE: equ 102 
242d				OPCODE_APPEND: equ 103 
242d				OPCODE_SDEL: equ 104 
242d				OPCODE_OPEN: equ 105 
242d				OPCODE_READ: equ 106 
242d				OPCODE_EOF: equ 106 
242d				OPCODE_FORMAT: equ 107 
242d				OPCODE_LABEL: equ 108 
242d				OPCODE_LABELS: equ 109 
242d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
242d				OPCODE_UPPER: equ 111 
242d				OPCODE_LOWER: equ 112 
242d				OPCODE_SUBSTR: equ 113 
242d				OPCODE_LEFT: equ 114 
242d				OPCODE_RIGHT: equ 115 
242d				OPCODE_STR2NUM: equ 116 
242d				OPCODE_NUM2STR: equ 117 
242d				OPCODE_CONCAT: equ 118 
242d				OPCODE_FIND: equ 119 
242d				OPCODE_LEN: equ 120 
242d				OPCODE_CHAR: equ 121 
242d			; free to reuse	OPCODE_STRLEN: equ 122 
242d			; free to reuse	OPCODE_ENDSTR: equ 123 
242d				OPCODE_V0S: equ 124 
242d				OPCODE_V0Q: equ 125 
242d				OPCODE_V1S: equ 126 
242d				OPCODE_V1Q: equ 127 
242d				OPCODE_V2S: equ 128 
242d				OPCODE_V2Q: equ 129 
242d				OPCODE_V3S: equ 130 
242d				OPCODE_V3Q: equ 131 
242d			;free to reuse	OPCODE_END: equ 132 
242d				OPCODE_ZDUP: equ 133 
242d			 
242d			; eof 
# End of file forth_opcodes.asm
242d			 
242d			include "forth_words_core.asm" 
242d			 
242d			; | ## Core Words 
242d			 
242d			;if MALLOC_4 
242d			 
242d			.HEAP: 
242d				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
242d 15				db WORD_SYS_CORE+OPCODE_HEAP             
242e 6c 24			dw .EXEC            
2430 05				db 4 + 1 
2431 .. 00			db "HEAP",0              
2436				endm 
# End of macro CWHEAD
2436			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2436			; | | u1 - Current number of bytes in the heap 
2436			; | | u2 - Remaining bytes left on the heap 
2436			; | |  
2436			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2436			 
2436			 
2436					if DEBUG_FORTH_WORDS_KEY 
2436						DMARK "HEP" 
2436 f5				push af  
2437 3a 4b 24			ld a, (.dmark)  
243a 32 6e fe			ld (debug_mark),a  
243d 3a 4c 24			ld a, (.dmark+1)  
2440 32 6f fe			ld (debug_mark+1),a  
2443 3a 4d 24			ld a, (.dmark+2)  
2446 32 70 fe			ld (debug_mark+2),a  
2449 18 03			jr .pastdmark  
244b ..			.dmark: db "HEP"  
244e f1			.pastdmark: pop af  
244f			endm  
# End of macro DMARK
244f						CALLMONITOR 
244f cd f3 18			call break_point_state  
2452				endm  
# End of macro CALLMONITOR
2452					endif 
2452 2a 0a 80				ld hl, (free_list )      
2455 11 0e 80				ld de, heap_start 
2458			 
2458 ed 52				sbc hl, de  
245a			 
245a cd 67 1f				call forth_push_numhl 
245d			 
245d			 
245d ed 5b 0a 80			ld de, (free_list )      
2461 21 e2 f1				ld hl, heap_end 
2464			 
2464 ed 52				sbc hl, de 
2466			 
2466 cd 67 1f				call forth_push_numhl 
2469					 
2469			 
2469					 
2469			 
2469			 
2469			 
2469					NEXTW 
2469 c3 d5 22			jp macro_next 
246c				endm 
# End of macro NEXTW
246c			;endif 
246c			 
246c			.EXEC: 
246c			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
246c			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
246c			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
246c			;; > > 
246c			;; > >   
246c			;	STACKFRAME OFF $5efe $5f9f 
246c			; 
246c			;		if DEBUG_FORTH_WORDS_KEY 
246c			;			DMARK "EXE" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			; 
246c			;	FORTH_DSP_VALUEHL 
246c			; 
246c			;	FORTH_DSP_POP 
246c			; 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX1" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;;	ld e,(hl) 
246c			;;	inc hl 
246c			;;	ld d,(hl) 
246c			;;	ex de,hl 
246c			; 
246c			;;		if DEBUG_FORTH_WORDS 
246c			;;			DMARK "EX2" 
246c			;;			CALLMONITOR 
246c			;;		endif 
246c			;	push hl 
246c			; 
246c			;	;ld a, 0 
246c			;	;ld a, FORTH_END_BUFFER 
246c			;	call strlenz 
246c			;	inc hl   ; include zero term to copy 
246c			;	inc hl   ; include term 
246c			;	inc hl   ; include term 
246c			;	ld b,0 
246c			;	ld c,l 
246c			;	pop hl 
246c			;	ld de, execscratch 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX3" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	ldir 
246c			; 
246c			; 
246c			;	ld hl, execscratch 
246c			; 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EXe" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			; 
246c			;	call forthparse 
246c			;	call forthexec 
246c			;;	call forthexec_cleanup 
246c			;;	call forthparse 
246c			;;	call forthexec 
246c			; 
246c			;	STACKFRAMECHK OFF $5efe $5f9f 
246c			; 
246c			;	; an immediate word so no need to process any more words 
246c			;	ret 
246c			;	NEXTW 
246c			 
246c			; dead code - old version  
246c			;	FORTH_RSP_NEXT 
246c			 
246c			;  
246c			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
246c			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
246c			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
246c			;	push hl 
246c			;	push de 
246c			;	push bc 
246c			; 
246c			; 
246c			;		if DEBUG_FORTH_WORDS_KEY 
246c			;			DMARK "EXR" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			; 
246c			; 
246c			; 
246c			;	;v5 FORTH_DSP_VALUE 
246c			;	FORTH_DSP_VALUEHL 
246c			; 
246c			;	; TODO do string type checks 
246c			; 
246c			;;v5	inc hl   ; skip type 
246c			; 
246c			;	push hl  ; source code  
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX1" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	ld a, 0 
246c			;	call strlent 
246c			; 
246c			;	inc hl 
246c			;	inc hl 
246c			;	inc hl 
246c			;	inc hl 
246c			; 
246c			;	push hl    ; size 
246c			; 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX2" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	call malloc 
246c			; 
246c			;	ex de, hl    ; de now contains malloc area 
246c			;	pop bc   	; get byte count 
246c			;	pop hl      ; get string to copy 
246c			; 
246c			;	push de     ; save malloc for free later 
246c			; 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX3" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	ldir       ; duplicate string 
246c			; 
246c			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
246c			;	 
246c			;	; TODO fix the parse would be better than this...  
246c			;	ex de, hl 
246c			;	dec hl 
246c			;	ld a, 0 
246c			;	ld (hl), a 
246c			;	dec hl 
246c			;	ld a, ' ' 
246c			;	ld (hl), a 
246c			;	dec hl 
246c			;	ld (hl), a 
246c			; 
246c			;	dec hl 
246c			;	ld (hl), a 
246c			; 
246c			; 
246c			;	FORTH_DSP_POP  
246c			; 
246c			;	pop hl     
246c			;	push hl    ; save malloc area 
246c			; 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX4" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			; 
246c			;	call forthparse 
246c			;	call forthexec 
246c			;	 
246c			;	pop hl 
246c			;	if DEBUG_FORTH_WORDS 
246c			;		DMARK "EX5" 
246c			;		CALLMONITOR 
246c			;	endif 
246c			; 
246c			;	if FORTH_ENABLE_FREE 
246c			;	call free 
246c			;	endif 
246c			; 
246c			;	if DEBUG_FORTH_WORDS 
246c			;		DMARK "EX6" 
246c			;		CALLMONITOR 
246c			;	endif 
246c			; 
246c			;	pop bc 
246c			;	pop de 
246c			;	pop hl 
246c			;;	FORTH_RSP_POP	  
246c			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
246c			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
246c			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
246c			; 
246c			;	if DEBUG_FORTH_WORDS 
246c			;		DMARK "EX7" 
246c			;		CALLMONITOR 
246c			;	endif 
246c			;	NEXTW 
246c			 
246c			;.STKEXEC: 
246c			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
246c			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
246c			; 
246c			; 
246c			;		if DEBUG_FORTH_WORDS_KEY 
246c			;			DMARK "STX" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			; 
246c			;	FORTH_DSP_VALUEHL 
246c			; 
246c			;	ld (store_tmp1), hl    ; count 
246c			; 
246c			;	FORTH_DSP_POP 
246c			;.stkexec1: 
246c			;	ld hl, (store_tmp1)   ; count 
246c			;	ld a, 0 
246c			;	cp l 
246c			;	ret z 
246c			; 
246c			;	dec hl 
246c			;	ld (store_tmp1), hl    ; count 
246c			;	 
246c			;	FORTH_DSP_VALUEHL 
246c			;	push hl 
246c			;	 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EXp" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	FORTH_DSP_POP 
246c			; 
246c			;	call strlenz 
246c			;	inc hl   ; include zero term to copy 
246c			;	inc hl   ; include zero term to copy 
246c			;	inc hl   ; include zero term to copy 
246c			;	ld b,0 
246c			;	ld c,l 
246c			;	pop hl 
246c			;	ld de, execscratch 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EX3" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	ldir 
246c			; 
246c			; 
246c			;	ld hl, execscratch 
246c			; 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EXP" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			; 
246c			;	call forthparse 
246c			;	ld hl, execscratch 
246c			;		if DEBUG_FORTH_WORDS 
246c			;			DMARK "EXx" 
246c			;			CALLMONITOR 
246c			;		endif 
246c			;	call forthexec 
246c			; 
246c			;	jp .stkexec1 
246c			; 
246c			;	ret 
246c			 
246c			 
246c			.DUP: 
246c				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
246c 17				db WORD_SYS_CORE+OPCODE_DUP             
246d e2 24			dw .ZDUP            
246f 04				db 3 + 1 
2470 .. 00			db "DUP",0              
2474				endm 
# End of macro CWHEAD
2474			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2474			 
2474					if DEBUG_FORTH_WORDS_KEY 
2474						DMARK "DUP" 
2474 f5				push af  
2475 3a 89 24			ld a, (.dmark)  
2478 32 6e fe			ld (debug_mark),a  
247b 3a 8a 24			ld a, (.dmark+1)  
247e 32 6f fe			ld (debug_mark+1),a  
2481 3a 8b 24			ld a, (.dmark+2)  
2484 32 70 fe			ld (debug_mark+2),a  
2487 18 03			jr .pastdmark  
2489 ..			.dmark: db "DUP"  
248c f1			.pastdmark: pop af  
248d			endm  
# End of macro DMARK
248d						CALLMONITOR 
248d cd f3 18			call break_point_state  
2490				endm  
# End of macro CALLMONITOR
2490					endif 
2490			 
2490					FORTH_DSP 
2490 cd 24 21			call macro_forth_dsp 
2493				endm 
# End of macro FORTH_DSP
2493			 
2493 7e					ld a, (HL) 
2494 fe 01				cp DS_TYPE_STR 
2496 20 25				jr nz, .dupinum 
2498			 
2498					; push another string 
2498			 
2498					FORTH_DSP_VALUEHL     		 
2498 cd 5e 21			call macro_dsp_valuehl 
249b				endm 
# End of macro FORTH_DSP_VALUEHL
249b			 
249b				if DEBUG_FORTH_WORDS 
249b					DMARK "DUs" 
249b f5				push af  
249c 3a b0 24			ld a, (.dmark)  
249f 32 6e fe			ld (debug_mark),a  
24a2 3a b1 24			ld a, (.dmark+1)  
24a5 32 6f fe			ld (debug_mark+1),a  
24a8 3a b2 24			ld a, (.dmark+2)  
24ab 32 70 fe			ld (debug_mark+2),a  
24ae 18 03			jr .pastdmark  
24b0 ..			.dmark: db "DUs"  
24b3 f1			.pastdmark: pop af  
24b4			endm  
# End of macro DMARK
24b4					CALLMONITOR 
24b4 cd f3 18			call break_point_state  
24b7				endm  
# End of macro CALLMONITOR
24b7				endif 
24b7 cd d5 1f				call forth_push_str 
24ba			 
24ba					NEXTW 
24ba c3 d5 22			jp macro_next 
24bd				endm 
# End of macro NEXTW
24bd			 
24bd			 
24bd			.dupinum: 
24bd					 
24bd			 
24bd			 
24bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24bd cd 5e 21			call macro_dsp_valuehl 
24c0				endm 
# End of macro FORTH_DSP_VALUEHL
24c0			 
24c0				; TODO add floating point number detection 
24c0			 
24c0				if DEBUG_FORTH_WORDS 
24c0					DMARK "DUi" 
24c0 f5				push af  
24c1 3a d5 24			ld a, (.dmark)  
24c4 32 6e fe			ld (debug_mark),a  
24c7 3a d6 24			ld a, (.dmark+1)  
24ca 32 6f fe			ld (debug_mark+1),a  
24cd 3a d7 24			ld a, (.dmark+2)  
24d0 32 70 fe			ld (debug_mark+2),a  
24d3 18 03			jr .pastdmark  
24d5 ..			.dmark: db "DUi"  
24d8 f1			.pastdmark: pop af  
24d9			endm  
# End of macro DMARK
24d9					CALLMONITOR 
24d9 cd f3 18			call break_point_state  
24dc				endm  
# End of macro CALLMONITOR
24dc				endif 
24dc			 
24dc cd 67 1f				call forth_push_numhl 
24df					NEXTW 
24df c3 d5 22			jp macro_next 
24e2				endm 
# End of macro NEXTW
24e2			.ZDUP: 
24e2				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
24e2 99				db WORD_SYS_CORE+OPCODE_ZDUP             
24e3 1a 25			dw .SWAP            
24e5 05				db 4 + 1 
24e6 .. 00			db "?DUP",0              
24eb				endm 
# End of macro CWHEAD
24eb			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
24eb			 
24eb					if DEBUG_FORTH_WORDS_KEY 
24eb						DMARK "qDU" 
24eb f5				push af  
24ec 3a 00 25			ld a, (.dmark)  
24ef 32 6e fe			ld (debug_mark),a  
24f2 3a 01 25			ld a, (.dmark+1)  
24f5 32 6f fe			ld (debug_mark+1),a  
24f8 3a 02 25			ld a, (.dmark+2)  
24fb 32 70 fe			ld (debug_mark+2),a  
24fe 18 03			jr .pastdmark  
2500 ..			.dmark: db "qDU"  
2503 f1			.pastdmark: pop af  
2504			endm  
# End of macro DMARK
2504						CALLMONITOR 
2504 cd f3 18			call break_point_state  
2507				endm  
# End of macro CALLMONITOR
2507					endif 
2507					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2507 cd 5e 21			call macro_dsp_valuehl 
250a				endm 
# End of macro FORTH_DSP_VALUEHL
250a			 
250a e5					push hl 
250b			 
250b					; is it a zero? 
250b			 
250b 3e 00				ld a, 0 
250d 84					add h 
250e 85					add l 
250f			 
250f e1					pop hl 
2510			 
2510 fe 00				cp 0 
2512 28 03				jr z, .dup2orig 
2514			 
2514			 
2514 cd 67 1f				call forth_push_numhl 
2517			 
2517			 
2517				; TODO add floating point number detection 
2517			 
2517			.dup2orig: 
2517			 
2517					NEXTW 
2517 c3 d5 22			jp macro_next 
251a				endm 
# End of macro NEXTW
251a			.SWAP: 
251a				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
251a 18				db WORD_SYS_CORE+OPCODE_SWAP             
251b 59 25			dw .COLN            
251d 05				db 4 + 1 
251e .. 00			db "SWAP",0              
2523				endm 
# End of macro CWHEAD
2523			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2523					if DEBUG_FORTH_WORDS_KEY 
2523						DMARK "SWP" 
2523 f5				push af  
2524 3a 38 25			ld a, (.dmark)  
2527 32 6e fe			ld (debug_mark),a  
252a 3a 39 25			ld a, (.dmark+1)  
252d 32 6f fe			ld (debug_mark+1),a  
2530 3a 3a 25			ld a, (.dmark+2)  
2533 32 70 fe			ld (debug_mark+2),a  
2536 18 03			jr .pastdmark  
2538 ..			.dmark: db "SWP"  
253b f1			.pastdmark: pop af  
253c			endm  
# End of macro DMARK
253c						CALLMONITOR 
253c cd f3 18			call break_point_state  
253f				endm  
# End of macro CALLMONITOR
253f					endif 
253f			 
253f					FORTH_DSP_VALUEHL 
253f cd 5e 21			call macro_dsp_valuehl 
2542				endm 
# End of macro FORTH_DSP_VALUEHL
2542 e5					push hl     ; w2 
2543			 
2543					FORTH_DSP_POP 
2543 cd 16 22			call macro_forth_dsp_pop 
2546				endm 
# End of macro FORTH_DSP_POP
2546			 
2546					FORTH_DSP_VALUEHL 
2546 cd 5e 21			call macro_dsp_valuehl 
2549				endm 
# End of macro FORTH_DSP_VALUEHL
2549			 
2549					FORTH_DSP_POP 
2549 cd 16 22			call macro_forth_dsp_pop 
254c				endm 
# End of macro FORTH_DSP_POP
254c			 
254c d1					pop de     ; w2	, hl = w1 
254d			 
254d eb					ex de, hl 
254e d5					push de 
254f			 
254f cd 67 1f				call forth_push_numhl 
2552			 
2552 e1					pop hl 
2553			 
2553 cd 67 1f				call forth_push_numhl 
2556					 
2556			 
2556					NEXTW 
2556 c3 d5 22			jp macro_next 
2559				endm 
# End of macro NEXTW
2559			.COLN: 
2559				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2559 19				db WORD_SYS_CORE+OPCODE_COLN             
255a e5 26			dw .SCOLN            
255c 02				db 1 + 1 
255d .. 00			db ":",0              
255f				endm 
# End of macro CWHEAD
255f			; | : ( -- )         Create new word | DONE 
255f			 
255f					if DEBUG_FORTH_WORDS_KEY 
255f						DMARK "CLN" 
255f f5				push af  
2560 3a 74 25			ld a, (.dmark)  
2563 32 6e fe			ld (debug_mark),a  
2566 3a 75 25			ld a, (.dmark+1)  
2569 32 6f fe			ld (debug_mark+1),a  
256c 3a 76 25			ld a, (.dmark+2)  
256f 32 70 fe			ld (debug_mark+2),a  
2572 18 03			jr .pastdmark  
2574 ..			.dmark: db "CLN"  
2577 f1			.pastdmark: pop af  
2578			endm  
# End of macro DMARK
2578						CALLMONITOR 
2578 cd f3 18			call break_point_state  
257b				endm  
# End of macro CALLMONITOR
257b					endif 
257b				STACKFRAME OFF $8efe $989f 
257b				if DEBUG_STACK_IMB 
257b					if OFF 
257b						exx 
257b						ld de, $8efe 
257b						ld a, d 
257b						ld hl, curframe 
257b						call hexout 
257b						ld a, e 
257b						ld hl, curframe+2 
257b						call hexout 
257b						ld hl, $8efe 
257b						push hl 
257b						ld hl, $989f 
257b						push hl 
257b						exx 
257b					endif 
257b				endif 
257b			endm 
# End of macro STACKFRAME
257b				; get parser buffer length  of new word 
257b			 
257b				 
257b			 
257b					; move tok past this to start of name defintition 
257b					; TODO get word to define 
257b					; TODO Move past word token 
257b					; TODO get length of string up to the ';' 
257b			 
257b 2a fd f4			ld hl, (os_tok_ptr) 
257e 23				inc hl 
257f 23				inc hl 
2580			 
2580 3e 3b			ld a, ';' 
2582 cd b5 13			call strlent 
2585			 
2585 7d				ld a,l 
2586 32 f8 f1			ld (os_new_parse_len), a 
2589			 
2589			 
2589			if DEBUG_FORTH_UWORD 
2589 ed 5b fd f4		ld de, (os_tok_ptr) 
258d						DMARK ":01" 
258d f5				push af  
258e 3a a2 25			ld a, (.dmark)  
2591 32 6e fe			ld (debug_mark),a  
2594 3a a3 25			ld a, (.dmark+1)  
2597 32 6f fe			ld (debug_mark+1),a  
259a 3a a4 25			ld a, (.dmark+2)  
259d 32 70 fe			ld (debug_mark+2),a  
25a0 18 03			jr .pastdmark  
25a2 ..			.dmark: db ":01"  
25a5 f1			.pastdmark: pop af  
25a6			endm  
# End of macro DMARK
25a6				CALLMONITOR 
25a6 cd f3 18			call break_point_state  
25a9				endm  
# End of macro CALLMONITOR
25a9			endif 
25a9			 
25a9			; 
25a9			;  new word memory layout: 
25a9			;  
25a9			;    : adg 6666 ;  
25a9			; 
25a9			;    db   1     ; user defined word  
25a9 23				inc hl    
25aa			;    dw   sysdict 
25aa 23				inc hl 
25ab 23				inc hl 
25ac			;    db <word len>+1 (for null) 
25ac 23				inc hl 
25ad			;    db .... <word> 
25ad			; 
25ad			 
25ad 23				inc hl    ; some extras for the word preamble before the above 
25ae 23				inc hl 
25af 23				inc hl 
25b0 23				inc hl 
25b1 23				inc hl 
25b2 23				inc hl 
25b3 23				inc hl  
25b4 23				inc hl 
25b5 23				inc hl 
25b6 23				inc hl 
25b7 23				inc hl 
25b8 23				inc hl 
25b9 23				inc hl 
25ba 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25bb			;       exec word buffer 
25bb			;	<ptr word>   
25bb 23				inc hl 
25bc 23				inc hl 
25bd			;       <word list><null term> 7F final term 
25bd			 
25bd			 
25bd			if DEBUG_FORTH_UWORD 
25bd						DMARK ":02" 
25bd f5				push af  
25be 3a d2 25			ld a, (.dmark)  
25c1 32 6e fe			ld (debug_mark),a  
25c4 3a d3 25			ld a, (.dmark+1)  
25c7 32 6f fe			ld (debug_mark+1),a  
25ca 3a d4 25			ld a, (.dmark+2)  
25cd 32 70 fe			ld (debug_mark+2),a  
25d0 18 03			jr .pastdmark  
25d2 ..			.dmark: db ":02"  
25d5 f1			.pastdmark: pop af  
25d6			endm  
# End of macro DMARK
25d6				CALLMONITOR 
25d6 cd f3 18			call break_point_state  
25d9				endm  
# End of macro CALLMONITOR
25d9			endif 
25d9			 
25d9				 
25d9					; malloc the size 
25d9			 
25d9 cd 13 14				call malloc 
25dc 22 fa f1				ld (os_new_malloc), hl     ; save malloc start 
25df			 
25df			;    db   1     ; user defined word  
25df 3e 01				ld a, WORD_SYS_UWORD  
25e1 77					ld (hl), a 
25e2				 
25e2 23				inc hl    
25e3			;    dw   sysdict 
25e3 11 2d 24			ld de, sysdict       ; continue on with the scan to the system dict 
25e6 73				ld (hl), e 
25e7 23				inc hl 
25e8 72				ld (hl), d 
25e9 23				inc hl 
25ea			 
25ea			 
25ea			;    Setup dict word 
25ea			 
25ea 23				inc hl 
25eb 22 f4 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
25ee			 
25ee				; 1. get length of dict word 
25ee			 
25ee			 
25ee 2a fd f4			ld hl, (os_tok_ptr) 
25f1 23				inc hl 
25f2 23				inc hl    ; position to start of dict word 
25f3 3e 00			ld a, 0 
25f5 cd b5 13			call strlent 
25f8			 
25f8			 
25f8 23				inc hl    ; to include null??? 
25f9			 
25f9				; write length of dict word 
25f9			 
25f9 ed 5b f4 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
25fd 1b				dec de 
25fe eb				ex de, hl 
25ff 73				ld (hl), e 
2600 eb				ex de, hl 
2601			 
2601				 
2601			 
2601				; copy  
2601 4d				ld c, l 
2602 06 00			ld b, 0 
2604 ed 5b f4 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2608 2a fd f4			ld hl, (os_tok_ptr) 
260b 23				inc hl 
260c 23				inc hl    ; position to start of dict word 
260d				 
260d			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
260d				 
260d				; TODO need to convert word to upper case 
260d			 
260d			ucasetok:	 
260d 7e				ld a,(hl) 
260e cd a1 13			call toUpper 
2611 77				ld (hl),a 
2612 ed a0			ldi 
2614 f2 0d 26		 	jp p, ucasetok 
2617			 
2617			 
2617			 
2617				; de now points to start of where the word body code should be placed 
2617 ed 53 f4 f1		ld (os_new_work_ptr), de 
261b				; hl now points to the words to throw at forthexec which needs to be copied 
261b 22 f2 f1			ld (os_new_src_ptr), hl 
261e			 
261e				; TODO add 'call to forthexec' 
261e			 
261e			if DEBUG_FORTH_UWORD 
261e c5				push bc 
261f ed 4b fa f1		ld bc, (os_new_malloc) 
2623						DMARK ":0x" 
2623 f5				push af  
2624 3a 38 26			ld a, (.dmark)  
2627 32 6e fe			ld (debug_mark),a  
262a 3a 39 26			ld a, (.dmark+1)  
262d 32 6f fe			ld (debug_mark+1),a  
2630 3a 3a 26			ld a, (.dmark+2)  
2633 32 70 fe			ld (debug_mark+2),a  
2636 18 03			jr .pastdmark  
2638 ..			.dmark: db ":0x"  
263b f1			.pastdmark: pop af  
263c			endm  
# End of macro DMARK
263c				CALLMONITOR 
263c cd f3 18			call break_point_state  
263f				endm  
# End of macro CALLMONITOR
263f c1				pop bc 
2640			endif 
2640			 
2640			 
2640				; create word preamble which should be: 
2640			 
2640			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2640			 
2640				;    ld hl, <word code> 
2640				;    jp user_exec 
2640			        ;    <word code bytes> 
2640			 
2640			 
2640			;	inc de     ; TODO ??? or are we already past the word's null 
2640 eb				ex de, hl 
2641			 
2641 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2643			 
2643 23				inc hl 
2644 22 ee f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2647 23				inc hl 
2648			 
2648 23				inc hl 
2649 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
264b			 
264b 01 c9 55			ld bc, user_exec 
264e 23				inc hl 
264f 71				ld (hl), c     ; poke address of user_exec 
2650 23				inc hl 
2651 70				ld (hl), b     
2652			 ; 
2652			;	inc hl 
2652			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2652			; 
2652			; 
2652			;	ld bc, macro_forth_rsp_next 
2652			;	inc hl 
2652			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2652			;	inc hl 
2652			;	ld (hl), b     
2652			 ; 
2652			;	inc hl 
2652			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2652			; 
2652			; 
2652			;	inc hl 
2652			;	ld bc, forthexec 
2652			;	ld (hl), c     ; poke address of forthexec 
2652			;	inc hl 
2652			;	ld (hl), b      
2652			; 
2652			;	inc hl 
2652			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2652			; 
2652			;	ld bc, user_dict_next 
2652			;	inc hl 
2652			;	ld (hl), c     ; poke address of forthexec 
2652			;	inc hl 
2652			;	ld (hl), b      
2652			 
2652				; hl is now where we need to copy the word byte data to save this 
2652			 
2652 23				inc hl 
2653 22 f0 f1			ld (os_new_exec), hl 
2656				 
2656				; copy definition 
2656			 
2656 eb				ex de, hl 
2657			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2657			;	inc de    ; skip the PC for this parse 
2657 3a f8 f1			ld a, (os_new_parse_len) 
265a 4f				ld c, a 
265b 06 00			ld b, 0 
265d ed b0			ldir		 ; copy defintion 
265f			 
265f			 
265f				; poke the address of where the new word bytes live for forthexec 
265f			 
265f 2a ee f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2662			 
2662 ed 5b f0 f1		ld de, (os_new_exec)      
2666				 
2666 73				ld (hl), e 
2667 23				inc hl 
2668 72				ld (hl), d 
2669			 
2669					; TODO copy last user dict word next link to this word 
2669					; TODO update last user dict word to point to this word 
2669			; 
2669			; hl f923 de 812a ; bc 811a 
2669			 
2669			if DEBUG_FORTH_UWORD 
2669 c5				push bc 
266a ed 4b fa f1		ld bc, (os_new_malloc) 
266e						DMARK ":0A" 
266e f5				push af  
266f 3a 83 26			ld a, (.dmark)  
2672 32 6e fe			ld (debug_mark),a  
2675 3a 84 26			ld a, (.dmark+1)  
2678 32 6f fe			ld (debug_mark+1),a  
267b 3a 85 26			ld a, (.dmark+2)  
267e 32 70 fe			ld (debug_mark+2),a  
2681 18 03			jr .pastdmark  
2683 ..			.dmark: db ":0A"  
2686 f1			.pastdmark: pop af  
2687			endm  
# End of macro DMARK
2687				CALLMONITOR 
2687 cd f3 18			call break_point_state  
268a				endm  
# End of macro CALLMONITOR
268a c1				pop bc 
268b			endif 
268b			if DEBUG_FORTH_UWORD 
268b c5				push bc 
268c ed 4b fa f1		ld bc, (os_new_malloc) 
2690 03				inc bc 
2691 03				inc bc 
2692 03				inc bc 
2693 03				inc bc 
2694 03				inc bc 
2695 03				inc bc 
2696 03				inc bc 
2697 03				inc bc 
2698			 
2698						DMARK ":0B" 
2698 f5				push af  
2699 3a ad 26			ld a, (.dmark)  
269c 32 6e fe			ld (debug_mark),a  
269f 3a ae 26			ld a, (.dmark+1)  
26a2 32 6f fe			ld (debug_mark+1),a  
26a5 3a af 26			ld a, (.dmark+2)  
26a8 32 70 fe			ld (debug_mark+2),a  
26ab 18 03			jr .pastdmark  
26ad ..			.dmark: db ":0B"  
26b0 f1			.pastdmark: pop af  
26b1			endm  
# End of macro DMARK
26b1				CALLMONITOR 
26b1 cd f3 18			call break_point_state  
26b4				endm  
# End of macro CALLMONITOR
26b4 c1				pop bc 
26b5			endif 
26b5			 
26b5			; update word dict linked list for new word 
26b5			 
26b5			 
26b5 2a f9 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26b8 23			inc hl     ; move to next work linked list ptr 
26b9			 
26b9 ed 5b fa f1	ld de, (os_new_malloc)		 ; new next word 
26bd 73			ld (hl), e 
26be 23			inc hl 
26bf 72			ld (hl), d 
26c0			 
26c0			if DEBUG_FORTH_UWORD 
26c0 ed 4b f9 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
26c4			endif 
26c4			 
26c4 ed 53 f9 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
26c8			 
26c8			 
26c8			if DEBUG_FORTH_UWORD 
26c8						DMARK ":0+" 
26c8 f5				push af  
26c9 3a dd 26			ld a, (.dmark)  
26cc 32 6e fe			ld (debug_mark),a  
26cf 3a de 26			ld a, (.dmark+1)  
26d2 32 6f fe			ld (debug_mark+1),a  
26d5 3a df 26			ld a, (.dmark+2)  
26d8 32 70 fe			ld (debug_mark+2),a  
26db 18 03			jr .pastdmark  
26dd ..			.dmark: db ":0+"  
26e0 f1			.pastdmark: pop af  
26e1			endm  
# End of macro DMARK
26e1				CALLMONITOR 
26e1 cd f3 18			call break_point_state  
26e4				endm  
# End of macro CALLMONITOR
26e4			endif 
26e4			 
26e4				STACKFRAMECHK OFF $8efe $989f 
26e4				if DEBUG_STACK_IMB 
26e4					if OFF 
26e4						exx 
26e4						ld hl, $989f 
26e4						pop de   ; $989f 
26e4						call cmp16 
26e4						jr nz, .spnosame 
26e4						ld hl, $8efe 
26e4						pop de   ; $8efe 
26e4						call cmp16 
26e4						jr z, .spfrsame 
26e4						.spnosame: call showsperror 
26e4						.spfrsame: nop 
26e4						exx 
26e4					endif 
26e4				endif 
26e4			endm 
# End of macro STACKFRAMECHK
26e4			 
26e4 c9			ret    ; dont process any remaining parser tokens as they form new word 
26e5			 
26e5			 
26e5			 
26e5			 
26e5			;		NEXT 
26e5			.SCOLN: 
26e5			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
26e5 06				db OPCODE_SCOLN 
26e6 31 27			dw .DROP 
26e8 02				db 2 
26e9 .. 00			db ";",0           
26eb			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
26eb					if DEBUG_FORTH_WORDS_KEY 
26eb						DMARK "SCN" 
26eb f5				push af  
26ec 3a 00 27			ld a, (.dmark)  
26ef 32 6e fe			ld (debug_mark),a  
26f2 3a 01 27			ld a, (.dmark+1)  
26f5 32 6f fe			ld (debug_mark+1),a  
26f8 3a 02 27			ld a, (.dmark+2)  
26fb 32 70 fe			ld (debug_mark+2),a  
26fe 18 03			jr .pastdmark  
2700 ..			.dmark: db "SCN"  
2703 f1			.pastdmark: pop af  
2704			endm  
# End of macro DMARK
2704						CALLMONITOR 
2704 cd f3 18			call break_point_state  
2707				endm  
# End of macro CALLMONITOR
2707					endif 
2707					FORTH_RSP_TOS 
2707 cd 25 1f			call macro_forth_rsp_tos 
270a				endm 
# End of macro FORTH_RSP_TOS
270a e5					push hl 
270b					FORTH_RSP_POP 
270b cd 2f 1f			call macro_forth_rsp_pop 
270e				endm 
# End of macro FORTH_RSP_POP
270e e1					pop hl 
270f			;		ex de,hl 
270f 22 fd f4				ld (os_tok_ptr),hl 
2712			 
2712			if DEBUG_FORTH_UWORD 
2712						DMARK "SCL" 
2712 f5				push af  
2713 3a 27 27			ld a, (.dmark)  
2716 32 6e fe			ld (debug_mark),a  
2719 3a 28 27			ld a, (.dmark+1)  
271c 32 6f fe			ld (debug_mark+1),a  
271f 3a 29 27			ld a, (.dmark+2)  
2722 32 70 fe			ld (debug_mark+2),a  
2725 18 03			jr .pastdmark  
2727 ..			.dmark: db "SCL"  
272a f1			.pastdmark: pop af  
272b			endm  
# End of macro DMARK
272b				CALLMONITOR 
272b cd f3 18			call break_point_state  
272e				endm  
# End of macro CALLMONITOR
272e			endif 
272e					NEXTW 
272e c3 d5 22			jp macro_next 
2731				endm 
# End of macro NEXTW
2731			 
2731			.DROP: 
2731				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2731 1b				db WORD_SYS_CORE+OPCODE_DROP             
2732 5c 27			dw .DUP2            
2734 05				db 4 + 1 
2735 .. 00			db "DROP",0              
273a				endm 
# End of macro CWHEAD
273a			; | DROP ( w -- )   drop the TOS item   | DONE 
273a					if DEBUG_FORTH_WORDS_KEY 
273a						DMARK "DRP" 
273a f5				push af  
273b 3a 4f 27			ld a, (.dmark)  
273e 32 6e fe			ld (debug_mark),a  
2741 3a 50 27			ld a, (.dmark+1)  
2744 32 6f fe			ld (debug_mark+1),a  
2747 3a 51 27			ld a, (.dmark+2)  
274a 32 70 fe			ld (debug_mark+2),a  
274d 18 03			jr .pastdmark  
274f ..			.dmark: db "DRP"  
2752 f1			.pastdmark: pop af  
2753			endm  
# End of macro DMARK
2753						CALLMONITOR 
2753 cd f3 18			call break_point_state  
2756				endm  
# End of macro CALLMONITOR
2756					endif 
2756					FORTH_DSP_POP 
2756 cd 16 22			call macro_forth_dsp_pop 
2759				endm 
# End of macro FORTH_DSP_POP
2759					NEXTW 
2759 c3 d5 22			jp macro_next 
275c				endm 
# End of macro NEXTW
275c			.DUP2: 
275c				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
275c 1c				db WORD_SYS_CORE+OPCODE_DUP2             
275d a1 27			dw .DROP2            
275f 05				db 4 + 1 
2760 .. 00			db "2DUP",0              
2765				endm 
# End of macro CWHEAD
2765			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2765					if DEBUG_FORTH_WORDS_KEY 
2765						DMARK "2DU" 
2765 f5				push af  
2766 3a 7a 27			ld a, (.dmark)  
2769 32 6e fe			ld (debug_mark),a  
276c 3a 7b 27			ld a, (.dmark+1)  
276f 32 6f fe			ld (debug_mark+1),a  
2772 3a 7c 27			ld a, (.dmark+2)  
2775 32 70 fe			ld (debug_mark+2),a  
2778 18 03			jr .pastdmark  
277a ..			.dmark: db "2DU"  
277d f1			.pastdmark: pop af  
277e			endm  
# End of macro DMARK
277e						CALLMONITOR 
277e cd f3 18			call break_point_state  
2781				endm  
# End of macro CALLMONITOR
2781					endif 
2781					FORTH_DSP_VALUEHL 
2781 cd 5e 21			call macro_dsp_valuehl 
2784				endm 
# End of macro FORTH_DSP_VALUEHL
2784 e5					push hl      ; 2 
2785			 
2785					FORTH_DSP_POP 
2785 cd 16 22			call macro_forth_dsp_pop 
2788				endm 
# End of macro FORTH_DSP_POP
2788					 
2788					FORTH_DSP_VALUEHL 
2788 cd 5e 21			call macro_dsp_valuehl 
278b				endm 
# End of macro FORTH_DSP_VALUEHL
278b			;		push hl      ; 1 
278b			 
278b					FORTH_DSP_POP 
278b cd 16 22			call macro_forth_dsp_pop 
278e				endm 
# End of macro FORTH_DSP_POP
278e			 
278e			;		pop hl       ; 1 
278e d1					pop de       ; 2 
278f			 
278f cd 67 1f				call forth_push_numhl 
2792 eb					ex de, hl 
2793 cd 67 1f				call forth_push_numhl 
2796			 
2796					 
2796 eb					ex de, hl 
2797			 
2797 cd 67 1f				call forth_push_numhl 
279a eb					ex de, hl 
279b cd 67 1f				call forth_push_numhl 
279e			 
279e			 
279e					NEXTW 
279e c3 d5 22			jp macro_next 
27a1				endm 
# End of macro NEXTW
27a1			.DROP2: 
27a1				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27a1 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27a2 d0 27			dw .SWAP2            
27a4 06				db 5 + 1 
27a5 .. 00			db "2DROP",0              
27ab				endm 
# End of macro CWHEAD
27ab			; | 2DROP ( w w -- )    Double drop | DONE 
27ab					if DEBUG_FORTH_WORDS_KEY 
27ab						DMARK "2DR" 
27ab f5				push af  
27ac 3a c0 27			ld a, (.dmark)  
27af 32 6e fe			ld (debug_mark),a  
27b2 3a c1 27			ld a, (.dmark+1)  
27b5 32 6f fe			ld (debug_mark+1),a  
27b8 3a c2 27			ld a, (.dmark+2)  
27bb 32 70 fe			ld (debug_mark+2),a  
27be 18 03			jr .pastdmark  
27c0 ..			.dmark: db "2DR"  
27c3 f1			.pastdmark: pop af  
27c4			endm  
# End of macro DMARK
27c4						CALLMONITOR 
27c4 cd f3 18			call break_point_state  
27c7				endm  
# End of macro CALLMONITOR
27c7					endif 
27c7					FORTH_DSP_POP 
27c7 cd 16 22			call macro_forth_dsp_pop 
27ca				endm 
# End of macro FORTH_DSP_POP
27ca					FORTH_DSP_POP 
27ca cd 16 22			call macro_forth_dsp_pop 
27cd				endm 
# End of macro FORTH_DSP_POP
27cd					NEXTW 
27cd c3 d5 22			jp macro_next 
27d0				endm 
# End of macro NEXTW
27d0			.SWAP2: 
27d0				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
27d0 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
27d1 f9 27			dw .AT            
27d3 06				db 5 + 1 
27d4 .. 00			db "2SWAP",0              
27da				endm 
# End of macro CWHEAD
27da			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
27da					if DEBUG_FORTH_WORDS_KEY 
27da						DMARK "2SW" 
27da f5				push af  
27db 3a ef 27			ld a, (.dmark)  
27de 32 6e fe			ld (debug_mark),a  
27e1 3a f0 27			ld a, (.dmark+1)  
27e4 32 6f fe			ld (debug_mark+1),a  
27e7 3a f1 27			ld a, (.dmark+2)  
27ea 32 70 fe			ld (debug_mark+2),a  
27ed 18 03			jr .pastdmark  
27ef ..			.dmark: db "2SW"  
27f2 f1			.pastdmark: pop af  
27f3			endm  
# End of macro DMARK
27f3						CALLMONITOR 
27f3 cd f3 18			call break_point_state  
27f6				endm  
# End of macro CALLMONITOR
27f6					endif 
27f6					NEXTW 
27f6 c3 d5 22			jp macro_next 
27f9				endm 
# End of macro NEXTW
27f9			.AT: 
27f9				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
27f9 1f				db WORD_SYS_CORE+OPCODE_AT             
27fa 2b 28			dw .CAT            
27fc 02				db 1 + 1 
27fd .. 00			db "@",0              
27ff				endm 
# End of macro CWHEAD
27ff			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
27ff			 
27ff					if DEBUG_FORTH_WORDS_KEY 
27ff						DMARK "AT." 
27ff f5				push af  
2800 3a 14 28			ld a, (.dmark)  
2803 32 6e fe			ld (debug_mark),a  
2806 3a 15 28			ld a, (.dmark+1)  
2809 32 6f fe			ld (debug_mark+1),a  
280c 3a 16 28			ld a, (.dmark+2)  
280f 32 70 fe			ld (debug_mark+2),a  
2812 18 03			jr .pastdmark  
2814 ..			.dmark: db "AT."  
2817 f1			.pastdmark: pop af  
2818			endm  
# End of macro DMARK
2818						CALLMONITOR 
2818 cd f3 18			call break_point_state  
281b				endm  
# End of macro CALLMONITOR
281b					endif 
281b			.getbyteat:	 
281b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
281b cd 5e 21			call macro_dsp_valuehl 
281e				endm 
# End of macro FORTH_DSP_VALUEHL
281e					 
281e			;		push hl 
281e				 
281e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
281e cd 16 22			call macro_forth_dsp_pop 
2821				endm 
# End of macro FORTH_DSP_POP
2821			 
2821			;		pop hl 
2821			 
2821 7e					ld a, (hl) 
2822			 
2822 6f					ld l, a 
2823 26 00				ld h, 0 
2825 cd 67 1f				call forth_push_numhl 
2828			 
2828					NEXTW 
2828 c3 d5 22			jp macro_next 
282b				endm 
# End of macro NEXTW
282b			.CAT: 
282b				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
282b 20				db WORD_SYS_CORE+OPCODE_CAT             
282c 54 28			dw .BANG            
282e 03				db 2 + 1 
282f .. 00			db "C@",0              
2832				endm 
# End of macro CWHEAD
2832			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2832					if DEBUG_FORTH_WORDS_KEY 
2832						DMARK "CAA" 
2832 f5				push af  
2833 3a 47 28			ld a, (.dmark)  
2836 32 6e fe			ld (debug_mark),a  
2839 3a 48 28			ld a, (.dmark+1)  
283c 32 6f fe			ld (debug_mark+1),a  
283f 3a 49 28			ld a, (.dmark+2)  
2842 32 70 fe			ld (debug_mark+2),a  
2845 18 03			jr .pastdmark  
2847 ..			.dmark: db "CAA"  
284a f1			.pastdmark: pop af  
284b			endm  
# End of macro DMARK
284b						CALLMONITOR 
284b cd f3 18			call break_point_state  
284e				endm  
# End of macro CALLMONITOR
284e					endif 
284e c3 1b 28				jp .getbyteat 
2851					NEXTW 
2851 c3 d5 22			jp macro_next 
2854				endm 
# End of macro NEXTW
2854			.BANG: 
2854				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2854 21				db WORD_SYS_CORE+OPCODE_BANG             
2855 8a 28			dw .CBANG            
2857 02				db 1 + 1 
2858 .. 00			db "!",0              
285a				endm 
# End of macro CWHEAD
285a			; | ! ( x w -- ) Store x at address w      | DONE 
285a					if DEBUG_FORTH_WORDS_KEY 
285a						DMARK "BNG" 
285a f5				push af  
285b 3a 6f 28			ld a, (.dmark)  
285e 32 6e fe			ld (debug_mark),a  
2861 3a 70 28			ld a, (.dmark+1)  
2864 32 6f fe			ld (debug_mark+1),a  
2867 3a 71 28			ld a, (.dmark+2)  
286a 32 70 fe			ld (debug_mark+2),a  
286d 18 03			jr .pastdmark  
286f ..			.dmark: db "BNG"  
2872 f1			.pastdmark: pop af  
2873			endm  
# End of macro DMARK
2873						CALLMONITOR 
2873 cd f3 18			call break_point_state  
2876				endm  
# End of macro CALLMONITOR
2876					endif 
2876			 
2876			.storebyteat:		 
2876					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2876 cd 5e 21			call macro_dsp_valuehl 
2879				endm 
# End of macro FORTH_DSP_VALUEHL
2879					 
2879 e5					push hl 
287a				 
287a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
287a cd 16 22			call macro_forth_dsp_pop 
287d				endm 
# End of macro FORTH_DSP_POP
287d			 
287d					; get byte to poke 
287d			 
287d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
287d cd 5e 21			call macro_dsp_valuehl 
2880				endm 
# End of macro FORTH_DSP_VALUEHL
2880 e5					push hl 
2881			 
2881			 
2881					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2881 cd 16 22			call macro_forth_dsp_pop 
2884				endm 
# End of macro FORTH_DSP_POP
2884			 
2884			 
2884 d1					pop de 
2885 e1					pop hl 
2886			 
2886 73					ld (hl),e 
2887			 
2887			 
2887					NEXTW 
2887 c3 d5 22			jp macro_next 
288a				endm 
# End of macro NEXTW
288a			.CBANG: 
288a				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
288a 22				db WORD_SYS_CORE+OPCODE_CBANG             
288b b3 28			dw .SCALL            
288d 03				db 2 + 1 
288e .. 00			db "C!",0              
2891				endm 
# End of macro CWHEAD
2891			; | C!  ( x w -- ) Store x at address w  | DONE 
2891					if DEBUG_FORTH_WORDS_KEY 
2891						DMARK "CBA" 
2891 f5				push af  
2892 3a a6 28			ld a, (.dmark)  
2895 32 6e fe			ld (debug_mark),a  
2898 3a a7 28			ld a, (.dmark+1)  
289b 32 6f fe			ld (debug_mark+1),a  
289e 3a a8 28			ld a, (.dmark+2)  
28a1 32 70 fe			ld (debug_mark+2),a  
28a4 18 03			jr .pastdmark  
28a6 ..			.dmark: db "CBA"  
28a9 f1			.pastdmark: pop af  
28aa			endm  
# End of macro DMARK
28aa						CALLMONITOR 
28aa cd f3 18			call break_point_state  
28ad				endm  
# End of macro CALLMONITOR
28ad					endif 
28ad c3 76 28				jp .storebyteat 
28b0					NEXTW 
28b0 c3 d5 22			jp macro_next 
28b3				endm 
# End of macro NEXTW
28b3			.SCALL: 
28b3				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28b3 23				db WORD_SYS_CORE+OPCODE_SCALL             
28b4 e7 28			dw .DEPTH            
28b6 05				db 4 + 1 
28b7 .. 00			db "CALL",0              
28bc				endm 
# End of macro CWHEAD
28bc			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28bc					if DEBUG_FORTH_WORDS_KEY 
28bc						DMARK "CLL" 
28bc f5				push af  
28bd 3a d1 28			ld a, (.dmark)  
28c0 32 6e fe			ld (debug_mark),a  
28c3 3a d2 28			ld a, (.dmark+1)  
28c6 32 6f fe			ld (debug_mark+1),a  
28c9 3a d3 28			ld a, (.dmark+2)  
28cc 32 70 fe			ld (debug_mark+2),a  
28cf 18 03			jr .pastdmark  
28d1 ..			.dmark: db "CLL"  
28d4 f1			.pastdmark: pop af  
28d5			endm  
# End of macro DMARK
28d5						CALLMONITOR 
28d5 cd f3 18			call break_point_state  
28d8				endm  
# End of macro CALLMONITOR
28d8					endif 
28d8			 
28d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d8 cd 5e 21			call macro_dsp_valuehl 
28db				endm 
# End of macro FORTH_DSP_VALUEHL
28db			 
28db			;		push hl 
28db			 
28db					; destroy value TOS 
28db			 
28db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28db cd 16 22			call macro_forth_dsp_pop 
28de				endm 
# End of macro FORTH_DSP_POP
28de			 
28de						 
28de			;		pop hl 
28de			 
28de					; how to do a call with hl???? save SP? 
28de cd 79 22				call forth_call_hl 
28e1			 
28e1			 
28e1					; TODO push value back onto stack for another op etc 
28e1			 
28e1 cd 67 1f				call forth_push_numhl 
28e4					NEXTW 
28e4 c3 d5 22			jp macro_next 
28e7				endm 
# End of macro NEXTW
28e7			.DEPTH: 
28e7				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
28e7 24				db WORD_SYS_CORE+OPCODE_DEPTH             
28e8 24 29			dw .OVER            
28ea 06				db 5 + 1 
28eb .. 00			db "DEPTH",0              
28f1				endm 
# End of macro CWHEAD
28f1			; | DEPTH ( -- u ) Push count of stack | DONE 
28f1					; take current TOS and remove from base value div by two to get count 
28f1					if DEBUG_FORTH_WORDS_KEY 
28f1						DMARK "DEP" 
28f1 f5				push af  
28f2 3a 06 29			ld a, (.dmark)  
28f5 32 6e fe			ld (debug_mark),a  
28f8 3a 07 29			ld a, (.dmark+1)  
28fb 32 6f fe			ld (debug_mark+1),a  
28fe 3a 08 29			ld a, (.dmark+2)  
2901 32 70 fe			ld (debug_mark+2),a  
2904 18 03			jr .pastdmark  
2906 ..			.dmark: db "DEP"  
2909 f1			.pastdmark: pop af  
290a			endm  
# End of macro DMARK
290a						CALLMONITOR 
290a cd f3 18			call break_point_state  
290d				endm  
# End of macro CALLMONITOR
290d					endif 
290d			 
290d			 
290d 2a 29 fa			ld hl, (cli_data_sp) 
2910 11 63 f7			ld de, cli_data_stack 
2913 ed 52			sbc hl,de 
2915				 
2915				; div by size of stack item 
2915			 
2915 5d				ld e,l 
2916 0e 03			ld c, 3 
2918 cd dc 0e			call Div8 
291b			 
291b 6f				ld l,a 
291c 26 00			ld h,0 
291e			 
291e				;srl h 
291e				;rr l 
291e			 
291e cd 67 1f				call forth_push_numhl 
2921					NEXTW 
2921 c3 d5 22			jp macro_next 
2924				endm 
# End of macro NEXTW
2924			.OVER: 
2924				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2924 42				db WORD_SYS_CORE+46             
2925 6b 29			dw .PAUSE            
2927 05				db 4 + 1 
2928 .. 00			db "OVER",0              
292d				endm 
# End of macro CWHEAD
292d			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
292d					if DEBUG_FORTH_WORDS_KEY 
292d						DMARK "OVR" 
292d f5				push af  
292e 3a 42 29			ld a, (.dmark)  
2931 32 6e fe			ld (debug_mark),a  
2934 3a 43 29			ld a, (.dmark+1)  
2937 32 6f fe			ld (debug_mark+1),a  
293a 3a 44 29			ld a, (.dmark+2)  
293d 32 70 fe			ld (debug_mark+2),a  
2940 18 03			jr .pastdmark  
2942 ..			.dmark: db "OVR"  
2945 f1			.pastdmark: pop af  
2946			endm  
# End of macro DMARK
2946						CALLMONITOR 
2946 cd f3 18			call break_point_state  
2949				endm  
# End of macro CALLMONITOR
2949					endif 
2949			 
2949					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2949 cd 5e 21			call macro_dsp_valuehl 
294c				endm 
# End of macro FORTH_DSP_VALUEHL
294c e5					push hl    ; n2 
294d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
294d cd 16 22			call macro_forth_dsp_pop 
2950				endm 
# End of macro FORTH_DSP_POP
2950			 
2950					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2950 cd 5e 21			call macro_dsp_valuehl 
2953				endm 
# End of macro FORTH_DSP_VALUEHL
2953 e5					push hl    ; n1 
2954					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2954 cd 16 22			call macro_forth_dsp_pop 
2957				endm 
# End of macro FORTH_DSP_POP
2957			 
2957 d1					pop de     ; n1 
2958 e1					pop hl     ; n2 
2959			 
2959 d5					push de 
295a e5					push hl 
295b d5					push de 
295c			 
295c					; push back  
295c			 
295c e1					pop hl 
295d cd 67 1f				call forth_push_numhl 
2960 e1					pop hl 
2961 cd 67 1f				call forth_push_numhl 
2964 e1					pop hl 
2965 cd 67 1f				call forth_push_numhl 
2968					NEXTW 
2968 c3 d5 22			jp macro_next 
296b				endm 
# End of macro NEXTW
296b			 
296b			.PAUSE: 
296b				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
296b 43				db WORD_SYS_CORE+47             
296c a0 29			dw .PAUSES            
296e 08				db 7 + 1 
296f .. 00			db "PAUSEMS",0              
2977				endm 
# End of macro CWHEAD
2977			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2977					if DEBUG_FORTH_WORDS_KEY 
2977						DMARK "PMS" 
2977 f5				push af  
2978 3a 8c 29			ld a, (.dmark)  
297b 32 6e fe			ld (debug_mark),a  
297e 3a 8d 29			ld a, (.dmark+1)  
2981 32 6f fe			ld (debug_mark+1),a  
2984 3a 8e 29			ld a, (.dmark+2)  
2987 32 70 fe			ld (debug_mark+2),a  
298a 18 03			jr .pastdmark  
298c ..			.dmark: db "PMS"  
298f f1			.pastdmark: pop af  
2990			endm  
# End of macro DMARK
2990						CALLMONITOR 
2990 cd f3 18			call break_point_state  
2993				endm  
# End of macro CALLMONITOR
2993					endif 
2993					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2993 cd 5e 21			call macro_dsp_valuehl 
2996				endm 
# End of macro FORTH_DSP_VALUEHL
2996			;		push hl    ; n2 
2996					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2996 cd 16 22			call macro_forth_dsp_pop 
2999				endm 
# End of macro FORTH_DSP_POP
2999			;		pop hl 
2999			 
2999 7d					ld a, l 
299a cd 7a 0c				call aDelayInMS 
299d				       NEXTW 
299d c3 d5 22			jp macro_next 
29a0				endm 
# End of macro NEXTW
29a0			.PAUSES:  
29a0				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29a0 44				db WORD_SYS_CORE+48             
29a1 0f 2a			dw .ROT            
29a3 06				db 5 + 1 
29a4 .. 00			db "PAUSE",0              
29aa				endm 
# End of macro CWHEAD
29aa			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29aa					if DEBUG_FORTH_WORDS_KEY 
29aa						DMARK "PAU" 
29aa f5				push af  
29ab 3a bf 29			ld a, (.dmark)  
29ae 32 6e fe			ld (debug_mark),a  
29b1 3a c0 29			ld a, (.dmark+1)  
29b4 32 6f fe			ld (debug_mark+1),a  
29b7 3a c1 29			ld a, (.dmark+2)  
29ba 32 70 fe			ld (debug_mark+2),a  
29bd 18 03			jr .pastdmark  
29bf ..			.dmark: db "PAU"  
29c2 f1			.pastdmark: pop af  
29c3			endm  
# End of macro DMARK
29c3						CALLMONITOR 
29c3 cd f3 18			call break_point_state  
29c6				endm  
# End of macro CALLMONITOR
29c6					endif 
29c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c6 cd 5e 21			call macro_dsp_valuehl 
29c9				endm 
# End of macro FORTH_DSP_VALUEHL
29c9			;		push hl    ; n2 
29c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c9 cd 16 22			call macro_forth_dsp_pop 
29cc				endm 
# End of macro FORTH_DSP_POP
29cc			;		pop hl 
29cc 45					ld b, l 
29cd					if DEBUG_FORTH_WORDS 
29cd						DMARK "PAU" 
29cd f5				push af  
29ce 3a e2 29			ld a, (.dmark)  
29d1 32 6e fe			ld (debug_mark),a  
29d4 3a e3 29			ld a, (.dmark+1)  
29d7 32 6f fe			ld (debug_mark+1),a  
29da 3a e4 29			ld a, (.dmark+2)  
29dd 32 70 fe			ld (debug_mark+2),a  
29e0 18 03			jr .pastdmark  
29e2 ..			.dmark: db "PAU"  
29e5 f1			.pastdmark: pop af  
29e6			endm  
# End of macro DMARK
29e6						CALLMONITOR 
29e6 cd f3 18			call break_point_state  
29e9				endm  
# End of macro CALLMONITOR
29e9					endif 
29e9 c5			.pauses1:	push bc 
29ea cd 95 0c				call delay1s 
29ed c1					pop bc 
29ee					if DEBUG_FORTH_WORDS 
29ee						DMARK "PA1" 
29ee f5				push af  
29ef 3a 03 2a			ld a, (.dmark)  
29f2 32 6e fe			ld (debug_mark),a  
29f5 3a 04 2a			ld a, (.dmark+1)  
29f8 32 6f fe			ld (debug_mark+1),a  
29fb 3a 05 2a			ld a, (.dmark+2)  
29fe 32 70 fe			ld (debug_mark+2),a  
2a01 18 03			jr .pastdmark  
2a03 ..			.dmark: db "PA1"  
2a06 f1			.pastdmark: pop af  
2a07			endm  
# End of macro DMARK
2a07						CALLMONITOR 
2a07 cd f3 18			call break_point_state  
2a0a				endm  
# End of macro CALLMONITOR
2a0a					endif 
2a0a 10 dd				djnz .pauses1 
2a0c			 
2a0c				       NEXTW 
2a0c c3 d5 22			jp macro_next 
2a0f				endm 
# End of macro NEXTW
2a0f			.ROT: 
2a0f				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a0f 45				db WORD_SYS_CORE+49             
2a10 5d 2a			dw .UWORDS            
2a12 04				db 3 + 1 
2a13 .. 00			db "ROT",0              
2a17				endm 
# End of macro CWHEAD
2a17			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a17					if DEBUG_FORTH_WORDS_KEY 
2a17						DMARK "ROT" 
2a17 f5				push af  
2a18 3a 2c 2a			ld a, (.dmark)  
2a1b 32 6e fe			ld (debug_mark),a  
2a1e 3a 2d 2a			ld a, (.dmark+1)  
2a21 32 6f fe			ld (debug_mark+1),a  
2a24 3a 2e 2a			ld a, (.dmark+2)  
2a27 32 70 fe			ld (debug_mark+2),a  
2a2a 18 03			jr .pastdmark  
2a2c ..			.dmark: db "ROT"  
2a2f f1			.pastdmark: pop af  
2a30			endm  
# End of macro DMARK
2a30						CALLMONITOR 
2a30 cd f3 18			call break_point_state  
2a33				endm  
# End of macro CALLMONITOR
2a33					endif 
2a33			 
2a33					FORTH_DSP_VALUEHL 
2a33 cd 5e 21			call macro_dsp_valuehl 
2a36				endm 
# End of macro FORTH_DSP_VALUEHL
2a36 e5					push hl    ; u3  
2a37			 
2a37					FORTH_DSP_POP 
2a37 cd 16 22			call macro_forth_dsp_pop 
2a3a				endm 
# End of macro FORTH_DSP_POP
2a3a			   
2a3a					FORTH_DSP_VALUEHL 
2a3a cd 5e 21			call macro_dsp_valuehl 
2a3d				endm 
# End of macro FORTH_DSP_VALUEHL
2a3d e5					push hl     ; u2 
2a3e			 
2a3e					FORTH_DSP_POP 
2a3e cd 16 22			call macro_forth_dsp_pop 
2a41				endm 
# End of macro FORTH_DSP_POP
2a41			 
2a41					FORTH_DSP_VALUEHL 
2a41 cd 5e 21			call macro_dsp_valuehl 
2a44				endm 
# End of macro FORTH_DSP_VALUEHL
2a44 e5					push hl     ; u1 
2a45			 
2a45					FORTH_DSP_POP 
2a45 cd 16 22			call macro_forth_dsp_pop 
2a48				endm 
# End of macro FORTH_DSP_POP
2a48			 
2a48 c1					pop bc      ; u1 
2a49 e1					pop hl      ; u2 
2a4a d1					pop de      ; u3 
2a4b			 
2a4b			 
2a4b c5					push bc 
2a4c d5					push de 
2a4d e5					push hl 
2a4e			 
2a4e			 
2a4e e1					pop hl 
2a4f cd 67 1f				call forth_push_numhl 
2a52			 
2a52 e1					pop hl 
2a53 cd 67 1f				call forth_push_numhl 
2a56			 
2a56 e1					pop hl 
2a57 cd 67 1f				call forth_push_numhl 
2a5a					 
2a5a			 
2a5a			 
2a5a			 
2a5a			 
2a5a			 
2a5a				       NEXTW 
2a5a c3 d5 22			jp macro_next 
2a5d				endm 
# End of macro NEXTW
2a5d			 
2a5d			.UWORDS: 
2a5d				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a5d 50				db WORD_SYS_CORE+60             
2a5e 1f 2b			dw .BP            
2a60 07				db 6 + 1 
2a61 .. 00			db "UWORDS",0              
2a68				endm 
# End of macro CWHEAD
2a68			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a68			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a68			; | | Following the count are the individual words. 
2a68			; | | 
2a68			; | | e.g. UWORDS 
2a68			; | | BOX DIRLIST 2 
2a68			; | |  
2a68			; | | Can be used to save the words to storage via: 
2a68			; | | UWORDS $01 DO $01 APPEND LOOP 
2a68				if DEBUG_FORTH_WORDS_KEY 
2a68					DMARK "UWR" 
2a68 f5				push af  
2a69 3a 7d 2a			ld a, (.dmark)  
2a6c 32 6e fe			ld (debug_mark),a  
2a6f 3a 7e 2a			ld a, (.dmark+1)  
2a72 32 6f fe			ld (debug_mark+1),a  
2a75 3a 7f 2a			ld a, (.dmark+2)  
2a78 32 70 fe			ld (debug_mark+2),a  
2a7b 18 03			jr .pastdmark  
2a7d ..			.dmark: db "UWR"  
2a80 f1			.pastdmark: pop af  
2a81			endm  
# End of macro DMARK
2a81					CALLMONITOR 
2a81 cd f3 18			call break_point_state  
2a84				endm  
# End of macro CALLMONITOR
2a84				endif 
2a84 21 00 80				ld hl, baseram 
2a87					;ld hl, baseusermem 
2a87 01 00 00				ld bc, 0    ; start a counter 
2a8a			 
2a8a				; skip dict stub 
2a8a			 
2a8a cd 26 24				call forth_tok_next 
2a8d			 
2a8d			 
2a8d			; while we have words to look for 
2a8d			 
2a8d 7e			.douscan:	ld a, (hl)      
2a8e				if DEBUG_FORTH_WORDS 
2a8e					DMARK "UWs" 
2a8e f5				push af  
2a8f 3a a3 2a			ld a, (.dmark)  
2a92 32 6e fe			ld (debug_mark),a  
2a95 3a a4 2a			ld a, (.dmark+1)  
2a98 32 6f fe			ld (debug_mark+1),a  
2a9b 3a a5 2a			ld a, (.dmark+2)  
2a9e 32 70 fe			ld (debug_mark+2),a  
2aa1 18 03			jr .pastdmark  
2aa3 ..			.dmark: db "UWs"  
2aa6 f1			.pastdmark: pop af  
2aa7			endm  
# End of macro DMARK
2aa7					CALLMONITOR 
2aa7 cd f3 18			call break_point_state  
2aaa				endm  
# End of macro CALLMONITOR
2aaa				endif 
2aaa fe 00				cp WORD_SYS_END 
2aac 28 4d				jr z, .udone 
2aae fe 01				cp WORD_SYS_UWORD 
2ab0 20 44				jr nz, .nuword 
2ab2			 
2ab2				if DEBUG_FORTH_WORDS 
2ab2					DMARK "UWu" 
2ab2 f5				push af  
2ab3 3a c7 2a			ld a, (.dmark)  
2ab6 32 6e fe			ld (debug_mark),a  
2ab9 3a c8 2a			ld a, (.dmark+1)  
2abc 32 6f fe			ld (debug_mark+1),a  
2abf 3a c9 2a			ld a, (.dmark+2)  
2ac2 32 70 fe			ld (debug_mark+2),a  
2ac5 18 03			jr .pastdmark  
2ac7 ..			.dmark: db "UWu"  
2aca f1			.pastdmark: pop af  
2acb			endm  
# End of macro DMARK
2acb					CALLMONITOR 
2acb cd f3 18			call break_point_state  
2ace				endm  
# End of macro CALLMONITOR
2ace				endif 
2ace					; we have a uword so push its name to the stack 
2ace			 
2ace e5				   	push hl  ; save so we can move to next dict block 
2acf			 
2acf					; skip opcode 
2acf 23					inc hl  
2ad0					; skip next ptr 
2ad0 23					inc hl  
2ad1 23					inc hl 
2ad2					; skip len 
2ad2 23					inc hl 
2ad3				if DEBUG_FORTH_WORDS 
2ad3					DMARK "UWt" 
2ad3 f5				push af  
2ad4 3a e8 2a			ld a, (.dmark)  
2ad7 32 6e fe			ld (debug_mark),a  
2ada 3a e9 2a			ld a, (.dmark+1)  
2add 32 6f fe			ld (debug_mark+1),a  
2ae0 3a ea 2a			ld a, (.dmark+2)  
2ae3 32 70 fe			ld (debug_mark+2),a  
2ae6 18 03			jr .pastdmark  
2ae8 ..			.dmark: db "UWt"  
2aeb f1			.pastdmark: pop af  
2aec			endm  
# End of macro DMARK
2aec					CALLMONITOR 
2aec cd f3 18			call break_point_state  
2aef				endm  
# End of macro CALLMONITOR
2aef				endif 
2aef 03					inc bc 
2af0			 
2af0 c5					push bc 
2af1 cd d5 1f				call forth_push_str 
2af4 c1					pop bc 
2af5			 
2af5 e1					pop hl 	 
2af6			 
2af6 cd 26 24		.nuword:	call forth_tok_next 
2af9 18 92				jr .douscan  
2afb			 
2afb			.udone:		 ; push count of uwords found 
2afb c5					push bc 
2afc e1					pop hl 
2afd			 
2afd				if DEBUG_FORTH_WORDS 
2afd					DMARK "UWc" 
2afd f5				push af  
2afe 3a 12 2b			ld a, (.dmark)  
2b01 32 6e fe			ld (debug_mark),a  
2b04 3a 13 2b			ld a, (.dmark+1)  
2b07 32 6f fe			ld (debug_mark+1),a  
2b0a 3a 14 2b			ld a, (.dmark+2)  
2b0d 32 70 fe			ld (debug_mark+2),a  
2b10 18 03			jr .pastdmark  
2b12 ..			.dmark: db "UWc"  
2b15 f1			.pastdmark: pop af  
2b16			endm  
# End of macro DMARK
2b16					CALLMONITOR 
2b16 cd f3 18			call break_point_state  
2b19				endm  
# End of macro CALLMONITOR
2b19				endif 
2b19 cd 67 1f				call forth_push_numhl 
2b1c			 
2b1c			 
2b1c				       NEXTW 
2b1c c3 d5 22			jp macro_next 
2b1f				endm 
# End of macro NEXTW
2b1f			 
2b1f			.BP: 
2b1f				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b1f 54				db WORD_SYS_CORE+64             
2b20 55 2b			dw .MONITOR            
2b22 03				db 2 + 1 
2b23 .. 00			db "BP",0              
2b26				endm 
# End of macro CWHEAD
2b26			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b26			; | | $00 Will enable the break points within specific code paths 
2b26			; | | $01 Will disable break points 
2b26			; | |  
2b26			; | | By default break points are off. Either the above can be used to enable them 
2b26			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b26			; | | and on release of the pressed key a message will be disaplayed to notify 
2b26			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b26					; get byte count 
2b26					if DEBUG_FORTH_WORDS_KEY 
2b26						DMARK "BP." 
2b26 f5				push af  
2b27 3a 3b 2b			ld a, (.dmark)  
2b2a 32 6e fe			ld (debug_mark),a  
2b2d 3a 3c 2b			ld a, (.dmark+1)  
2b30 32 6f fe			ld (debug_mark+1),a  
2b33 3a 3d 2b			ld a, (.dmark+2)  
2b36 32 70 fe			ld (debug_mark+2),a  
2b39 18 03			jr .pastdmark  
2b3b ..			.dmark: db "BP."  
2b3e f1			.pastdmark: pop af  
2b3f			endm  
# End of macro DMARK
2b3f						CALLMONITOR 
2b3f cd f3 18			call break_point_state  
2b42				endm  
# End of macro CALLMONITOR
2b42					endif 
2b42			 
2b42					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b42 cd 5e 21			call macro_dsp_valuehl 
2b45				endm 
# End of macro FORTH_DSP_VALUEHL
2b45			 
2b45			;		push hl 
2b45			 
2b45					; destroy value TOS 
2b45			 
2b45					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b45 cd 16 22			call macro_forth_dsp_pop 
2b48				endm 
# End of macro FORTH_DSP_POP
2b48			 
2b48			;		pop hl 
2b48			 
2b48 3e 00				ld a,0 
2b4a bd					cp l 
2b4b 28 02				jr z, .bpset 
2b4d 3e 2a				ld a, '*' 
2b4f			 
2b4f 32 ed f1		.bpset:		ld (os_view_disable), a 
2b52			 
2b52			 
2b52					NEXTW 
2b52 c3 d5 22			jp macro_next 
2b55				endm 
# End of macro NEXTW
2b55			 
2b55			 
2b55			.MONITOR: 
2b55				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b55 55				db WORD_SYS_CORE+65             
2b56 88 2b			dw .MALLOC            
2b58 08				db 7 + 1 
2b59 .. 00			db "MONITOR",0              
2b61				endm 
# End of macro CWHEAD
2b61			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b61			; | | At start the current various registers will be displayed with contents. 
2b61			; | | Top right corner will show the most recent debug marker seen. 
2b61			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b61			; | | and the return stack pointer (RSP). 
2b61			; | | Pressing: 
2b61			; | |    1 - Initial screen 
2b61			; | |    2 - Display a data dump of HL 
2b61			; | |    3 - Display a data dump of DE 
2b61			; | |    4 - Display a data dump of BC 
2b61			; | |    5 - Display a data dump of HL 
2b61			; | |    6 - Display a data dump of DSP 
2b61			; | |    7 - Display a data dump of RSP 
2b61			; | |    8 - Display a data dump of what is at DSP 
2b61			; | |    9 - Display a data dump of what is at RSP 
2b61			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b61			; | |    * - Disable break points 
2b61			; | |    # - Enter traditional monitor mode 
2b61			; | | 
2b61			; | | Monitor Mode 
2b61			; | | ------------ 
2b61			; | | A prompt of '>' will be shown for various commands: 
2b61			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b61			; | |    C - Continue display a data dump from the last set address 
2b61			; | |    M xxxx - Set start of memory edit at address xx 
2b61			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b61			; | |    Q - Return to previous 
2b61					if DEBUG_FORTH_WORDS_KEY 
2b61						DMARK "MON" 
2b61 f5				push af  
2b62 3a 76 2b			ld a, (.dmark)  
2b65 32 6e fe			ld (debug_mark),a  
2b68 3a 77 2b			ld a, (.dmark+1)  
2b6b 32 6f fe			ld (debug_mark+1),a  
2b6e 3a 78 2b			ld a, (.dmark+2)  
2b71 32 70 fe			ld (debug_mark+2),a  
2b74 18 03			jr .pastdmark  
2b76 ..			.dmark: db "MON"  
2b79 f1			.pastdmark: pop af  
2b7a			endm  
# End of macro DMARK
2b7a						CALLMONITOR 
2b7a cd f3 18			call break_point_state  
2b7d				endm  
# End of macro CALLMONITOR
2b7d					endif 
2b7d 3e 00				ld a, 0 
2b7f 32 ed f1				ld (os_view_disable), a 
2b82			 
2b82					CALLMONITOR 
2b82 cd f3 18			call break_point_state  
2b85				endm  
# End of macro CALLMONITOR
2b85			 
2b85			;	call monitor 
2b85			 
2b85					NEXTW 
2b85 c3 d5 22			jp macro_next 
2b88				endm 
# End of macro NEXTW
2b88			 
2b88			 
2b88			.MALLOC: 
2b88				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b88 56				db WORD_SYS_CORE+66             
2b89 b1 2b			dw .MALLOC2            
2b8b 06				db 5 + 1 
2b8c .. 00			db "ALLOT",0              
2b92				endm 
# End of macro CWHEAD
2b92			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b92					if DEBUG_FORTH_WORDS_KEY 
2b92						DMARK "ALL" 
2b92 f5				push af  
2b93 3a a7 2b			ld a, (.dmark)  
2b96 32 6e fe			ld (debug_mark),a  
2b99 3a a8 2b			ld a, (.dmark+1)  
2b9c 32 6f fe			ld (debug_mark+1),a  
2b9f 3a a9 2b			ld a, (.dmark+2)  
2ba2 32 70 fe			ld (debug_mark+2),a  
2ba5 18 03			jr .pastdmark  
2ba7 ..			.dmark: db "ALL"  
2baa f1			.pastdmark: pop af  
2bab			endm  
# End of macro DMARK
2bab						CALLMONITOR 
2bab cd f3 18			call break_point_state  
2bae				endm  
# End of macro CALLMONITOR
2bae					endif 
2bae c3 d8 2b				jp .mallocc 
2bb1			.MALLOC2: 
2bb1				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2bb1 56				db WORD_SYS_CORE+66             
2bb2 ef 2b			dw .FREE            
2bb4 07				db 6 + 1 
2bb5 .. 00			db "MALLOC",0              
2bbc				endm 
# End of macro CWHEAD
2bbc			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bbc					; get byte count 
2bbc					if DEBUG_FORTH_WORDS_KEY 
2bbc						DMARK "MAL" 
2bbc f5				push af  
2bbd 3a d1 2b			ld a, (.dmark)  
2bc0 32 6e fe			ld (debug_mark),a  
2bc3 3a d2 2b			ld a, (.dmark+1)  
2bc6 32 6f fe			ld (debug_mark+1),a  
2bc9 3a d3 2b			ld a, (.dmark+2)  
2bcc 32 70 fe			ld (debug_mark+2),a  
2bcf 18 03			jr .pastdmark  
2bd1 ..			.dmark: db "MAL"  
2bd4 f1			.pastdmark: pop af  
2bd5			endm  
# End of macro DMARK
2bd5						CALLMONITOR 
2bd5 cd f3 18			call break_point_state  
2bd8				endm  
# End of macro CALLMONITOR
2bd8					endif 
2bd8			.mallocc: 
2bd8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bd8 cd 5e 21			call macro_dsp_valuehl 
2bdb				endm 
# End of macro FORTH_DSP_VALUEHL
2bdb			 
2bdb			;		push hl 
2bdb			 
2bdb					; destroy value TOS 
2bdb			 
2bdb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bdb cd 16 22			call macro_forth_dsp_pop 
2bde				endm 
# End of macro FORTH_DSP_POP
2bde			 
2bde			;		pop hl 
2bde cd 13 14				call malloc 
2be1				if DEBUG_FORTH_MALLOC_GUARD 
2be1 f5					push af 
2be2 cd 75 0f				call ishlzero 
2be5			;		ld a, l 
2be5			;		add h 
2be5			;		cp 0 
2be5 f1					pop af 
2be6					 
2be6 cc 9b 56				call z,malloc_error 
2be9				endif 
2be9			 
2be9 cd 67 1f				call forth_push_numhl 
2bec					NEXTW 
2bec c3 d5 22			jp macro_next 
2bef				endm 
# End of macro NEXTW
2bef			 
2bef			.FREE: 
2bef				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2bef 57				db WORD_SYS_CORE+67             
2bf0 20 2c			dw .LIST            
2bf2 05				db 4 + 1 
2bf3 .. 00			db "FREE",0              
2bf8				endm 
# End of macro CWHEAD
2bf8			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2bf8					if DEBUG_FORTH_WORDS_KEY 
2bf8						DMARK "FRE" 
2bf8 f5				push af  
2bf9 3a 0d 2c			ld a, (.dmark)  
2bfc 32 6e fe			ld (debug_mark),a  
2bff 3a 0e 2c			ld a, (.dmark+1)  
2c02 32 6f fe			ld (debug_mark+1),a  
2c05 3a 0f 2c			ld a, (.dmark+2)  
2c08 32 70 fe			ld (debug_mark+2),a  
2c0b 18 03			jr .pastdmark  
2c0d ..			.dmark: db "FRE"  
2c10 f1			.pastdmark: pop af  
2c11			endm  
# End of macro DMARK
2c11						CALLMONITOR 
2c11 cd f3 18			call break_point_state  
2c14				endm  
# End of macro CALLMONITOR
2c14					endif 
2c14					; get address 
2c14			 
2c14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c14 cd 5e 21			call macro_dsp_valuehl 
2c17				endm 
# End of macro FORTH_DSP_VALUEHL
2c17			 
2c17			;		push hl 
2c17			 
2c17					; destroy value TOS 
2c17			 
2c17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c17 cd 16 22			call macro_forth_dsp_pop 
2c1a				endm 
# End of macro FORTH_DSP_POP
2c1a			 
2c1a			;		pop hl 
2c1a			if FORTH_ENABLE_MALLOCFREE 
2c1a cd dd 14				call free 
2c1d			endif 
2c1d					NEXTW 
2c1d c3 d5 22			jp macro_next 
2c20				endm 
# End of macro NEXTW
2c20			.LIST: 
2c20				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c20 5c				db WORD_SYS_CORE+72             
2c21 0e 2e			dw .FORGET            
2c23 05				db 4 + 1 
2c24 .. 00			db "LIST",0              
2c29				endm 
# End of macro CWHEAD
2c29			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c29			; | | The quoted word must be in upper case. 
2c29				if DEBUG_FORTH_WORDS_KEY 
2c29					DMARK "LST" 
2c29 f5				push af  
2c2a 3a 3e 2c			ld a, (.dmark)  
2c2d 32 6e fe			ld (debug_mark),a  
2c30 3a 3f 2c			ld a, (.dmark+1)  
2c33 32 6f fe			ld (debug_mark+1),a  
2c36 3a 40 2c			ld a, (.dmark+2)  
2c39 32 70 fe			ld (debug_mark+2),a  
2c3c 18 03			jr .pastdmark  
2c3e ..			.dmark: db "LST"  
2c41 f1			.pastdmark: pop af  
2c42			endm  
# End of macro DMARK
2c42					CALLMONITOR 
2c42 cd f3 18			call break_point_state  
2c45				endm  
# End of macro CALLMONITOR
2c45				endif 
2c45			 
2c45					FORTH_DSP_VALUEHL 
2c45 cd 5e 21			call macro_dsp_valuehl 
2c48				endm 
# End of macro FORTH_DSP_VALUEHL
2c48			 
2c48 e5					push hl 
2c49					FORTH_DSP_POP 
2c49 cd 16 22			call macro_forth_dsp_pop 
2c4c				endm 
# End of macro FORTH_DSP_POP
2c4c c1					pop bc 
2c4d			 
2c4d			; Start format of scratch string 
2c4d			 
2c4d 21 fc f1				ld hl, scratch 
2c50			 
2c50 3e 3a				ld a, ':' 
2c52 77					ld (hl),a 
2c53 23					inc hl 
2c54 3e 20				ld a, ' ' 
2c56 77					ld (hl), a 
2c57			 
2c57					; Get ptr to the word we need to look up 
2c57			 
2c57			;		FORTH_DSP_VALUEHL 
2c57					;v5 FORTH_DSP_VALUE 
2c57				; TODO type check 
2c57			;		inc hl    ; Skip type check  
2c57			;		push hl 
2c57			;		ex de, hl    ; put into DE 
2c57			 
2c57			 
2c57 21 00 80				ld hl, baseram 
2c5a					;ld hl, baseusermem 
2c5a			 
2c5a e5			push hl   ; sacreifical push 
2c5b			 
2c5b			.ldouscanm: 
2c5b e1				pop hl 
2c5c			.ldouscan: 
2c5c				if DEBUG_FORTH_WORDS 
2c5c					DMARK "LSs" 
2c5c f5				push af  
2c5d 3a 71 2c			ld a, (.dmark)  
2c60 32 6e fe			ld (debug_mark),a  
2c63 3a 72 2c			ld a, (.dmark+1)  
2c66 32 6f fe			ld (debug_mark+1),a  
2c69 3a 73 2c			ld a, (.dmark+2)  
2c6c 32 70 fe			ld (debug_mark+2),a  
2c6f 18 03			jr .pastdmark  
2c71 ..			.dmark: db "LSs"  
2c74 f1			.pastdmark: pop af  
2c75			endm  
# End of macro DMARK
2c75					CALLMONITOR 
2c75 cd f3 18			call break_point_state  
2c78				endm  
# End of macro CALLMONITOR
2c78				endif 
2c78				; skip dict stub 
2c78 cd 26 24				call forth_tok_next 
2c7b			 
2c7b			 
2c7b			; while we have words to look for 
2c7b			 
2c7b 7e				ld a, (hl)      
2c7c				if DEBUG_FORTH_WORDS 
2c7c					DMARK "LSk" 
2c7c f5				push af  
2c7d 3a 91 2c			ld a, (.dmark)  
2c80 32 6e fe			ld (debug_mark),a  
2c83 3a 92 2c			ld a, (.dmark+1)  
2c86 32 6f fe			ld (debug_mark+1),a  
2c89 3a 93 2c			ld a, (.dmark+2)  
2c8c 32 70 fe			ld (debug_mark+2),a  
2c8f 18 03			jr .pastdmark  
2c91 ..			.dmark: db "LSk"  
2c94 f1			.pastdmark: pop af  
2c95			endm  
# End of macro DMARK
2c95					CALLMONITOR 
2c95 cd f3 18			call break_point_state  
2c98				endm  
# End of macro CALLMONITOR
2c98				endif 
2c98					;cp WORD_SYS_END 
2c98					;jp z, .lunotfound 
2c98			 
2c98					; if we hit non uwords then gone too far 
2c98 fe 01				cp WORD_SYS_UWORD 
2c9a c2 ca 2d				jp nz, .lunotfound 
2c9d			 
2c9d				if DEBUG_FORTH_WORDS 
2c9d					DMARK "LSu" 
2c9d f5				push af  
2c9e 3a b2 2c			ld a, (.dmark)  
2ca1 32 6e fe			ld (debug_mark),a  
2ca4 3a b3 2c			ld a, (.dmark+1)  
2ca7 32 6f fe			ld (debug_mark+1),a  
2caa 3a b4 2c			ld a, (.dmark+2)  
2cad 32 70 fe			ld (debug_mark+2),a  
2cb0 18 03			jr .pastdmark  
2cb2 ..			.dmark: db "LSu"  
2cb5 f1			.pastdmark: pop af  
2cb6			endm  
# End of macro DMARK
2cb6					CALLMONITOR 
2cb6 cd f3 18			call break_point_state  
2cb9				endm  
# End of macro CALLMONITOR
2cb9				endif 
2cb9			 
2cb9					; found a uword but is it the one we want... 
2cb9			 
2cb9 c5					push bc     ; uword to find is on bc 
2cba d1					pop de 
2cbb			 
2cbb e5					push hl  ; to save the ptr 
2cbc			 
2cbc					; skip opcode 
2cbc 23					inc hl  
2cbd					; skip next ptr 
2cbd 23					inc hl  
2cbe 23					inc hl 
2cbf					; skip len 
2cbf 23					inc hl 
2cc0			 
2cc0				if DEBUG_FORTH_WORDS 
2cc0					DMARK "LSc" 
2cc0 f5				push af  
2cc1 3a d5 2c			ld a, (.dmark)  
2cc4 32 6e fe			ld (debug_mark),a  
2cc7 3a d6 2c			ld a, (.dmark+1)  
2cca 32 6f fe			ld (debug_mark+1),a  
2ccd 3a d7 2c			ld a, (.dmark+2)  
2cd0 32 70 fe			ld (debug_mark+2),a  
2cd3 18 03			jr .pastdmark  
2cd5 ..			.dmark: db "LSc"  
2cd8 f1			.pastdmark: pop af  
2cd9			endm  
# End of macro DMARK
2cd9					CALLMONITOR 
2cd9 cd f3 18			call break_point_state  
2cdc				endm  
# End of macro CALLMONITOR
2cdc				endif 
2cdc cd e2 13				call strcmp 
2cdf c2 5b 2c				jp nz, .ldouscanm 
2ce2				 
2ce2			 
2ce2			 
2ce2					; we have a uword so push its name to the stack 
2ce2			 
2ce2			;	   	push hl  ; save so we can move to next dict block 
2ce2 e1			pop hl 
2ce3			 
2ce3				if DEBUG_FORTH_WORDS 
2ce3					DMARK "LSm" 
2ce3 f5				push af  
2ce4 3a f8 2c			ld a, (.dmark)  
2ce7 32 6e fe			ld (debug_mark),a  
2cea 3a f9 2c			ld a, (.dmark+1)  
2ced 32 6f fe			ld (debug_mark+1),a  
2cf0 3a fa 2c			ld a, (.dmark+2)  
2cf3 32 70 fe			ld (debug_mark+2),a  
2cf6 18 03			jr .pastdmark  
2cf8 ..			.dmark: db "LSm"  
2cfb f1			.pastdmark: pop af  
2cfc			endm  
# End of macro DMARK
2cfc					CALLMONITOR 
2cfc cd f3 18			call break_point_state  
2cff				endm  
# End of macro CALLMONITOR
2cff				endif 
2cff			 
2cff					; skip opcode 
2cff 23					inc hl  
2d00					; skip next ptr 
2d00 23					inc hl  
2d01 23					inc hl 
2d02					; skip len 
2d02 7e					ld a, (hl)   ; save length to add 
2d03				if DEBUG_FORTH_WORDS 
2d03					DMARK "LS2" 
2d03 f5				push af  
2d04 3a 18 2d			ld a, (.dmark)  
2d07 32 6e fe			ld (debug_mark),a  
2d0a 3a 19 2d			ld a, (.dmark+1)  
2d0d 32 6f fe			ld (debug_mark+1),a  
2d10 3a 1a 2d			ld a, (.dmark+2)  
2d13 32 70 fe			ld (debug_mark+2),a  
2d16 18 03			jr .pastdmark  
2d18 ..			.dmark: db "LS2"  
2d1b f1			.pastdmark: pop af  
2d1c			endm  
# End of macro DMARK
2d1c					CALLMONITOR 
2d1c cd f3 18			call break_point_state  
2d1f				endm  
# End of macro CALLMONITOR
2d1f				endif 
2d1f			 
2d1f					; save this location 
2d1f				 
2d1f e5					push hl 
2d20			 
2d20 23					inc hl 
2d21 11 fe f1				ld de, scratch+2 
2d24 4f					ld c, a 
2d25 06 00				ld b, 0 
2d27			 
2d27				if DEBUG_FORTH_WORDS 
2d27					DMARK "LSn" 
2d27 f5				push af  
2d28 3a 3c 2d			ld a, (.dmark)  
2d2b 32 6e fe			ld (debug_mark),a  
2d2e 3a 3d 2d			ld a, (.dmark+1)  
2d31 32 6f fe			ld (debug_mark+1),a  
2d34 3a 3e 2d			ld a, (.dmark+2)  
2d37 32 70 fe			ld (debug_mark+2),a  
2d3a 18 03			jr .pastdmark  
2d3c ..			.dmark: db "LSn"  
2d3f f1			.pastdmark: pop af  
2d40			endm  
# End of macro DMARK
2d40					CALLMONITOR 
2d40 cd f3 18			call break_point_state  
2d43				endm  
# End of macro CALLMONITOR
2d43				endif 
2d43			 
2d43					; copy uword name to scratch 
2d43			 
2d43 ed b0				ldir 
2d45			 
2d45 1b					dec de 
2d46 3e 20				ld a, ' '    ; change null to space 
2d48 12					ld (de), a 
2d49			 
2d49 13					inc de 
2d4a			 
2d4a d5					push de 
2d4b c1					pop bc     ; move scratch pointer to end of word name and save it 
2d4c			 
2d4c e1					pop hl 
2d4d 7e					ld a, (hl) 
2d4e					;inc hl 
2d4e					; skip word string 
2d4e cd 4c 0f				call addatohl 
2d51			 
2d51 23					inc hl 
2d52			 
2d52				if DEBUG_FORTH_WORDS 
2d52					DMARK "LS3" 
2d52 f5				push af  
2d53 3a 67 2d			ld a, (.dmark)  
2d56 32 6e fe			ld (debug_mark),a  
2d59 3a 68 2d			ld a, (.dmark+1)  
2d5c 32 6f fe			ld (debug_mark+1),a  
2d5f 3a 69 2d			ld a, (.dmark+2)  
2d62 32 70 fe			ld (debug_mark+2),a  
2d65 18 03			jr .pastdmark  
2d67 ..			.dmark: db "LS3"  
2d6a f1			.pastdmark: pop af  
2d6b			endm  
# End of macro DMARK
2d6b					CALLMONITOR 
2d6b cd f3 18			call break_point_state  
2d6e				endm  
# End of macro CALLMONITOR
2d6e				endif 
2d6e					; should now be at the start of the machine code to setup the eval of the uword 
2d6e					; now locate the ptr to the string defintion 
2d6e			 
2d6e					; skip ld hl, 
2d6e					; then load the ptr 
2d6e			; TODO use get from hl ptr 
2d6e 23					inc hl 
2d6f 5e					ld e, (hl) 
2d70 23					inc hl 
2d71 56					ld d, (hl) 
2d72 eb					ex de, hl 
2d73			 
2d73			 
2d73				if DEBUG_FORTH_WORDS 
2d73					DMARK "LSt" 
2d73 f5				push af  
2d74 3a 88 2d			ld a, (.dmark)  
2d77 32 6e fe			ld (debug_mark),a  
2d7a 3a 89 2d			ld a, (.dmark+1)  
2d7d 32 6f fe			ld (debug_mark+1),a  
2d80 3a 8a 2d			ld a, (.dmark+2)  
2d83 32 70 fe			ld (debug_mark+2),a  
2d86 18 03			jr .pastdmark  
2d88 ..			.dmark: db "LSt"  
2d8b f1			.pastdmark: pop af  
2d8c			endm  
# End of macro DMARK
2d8c					CALLMONITOR 
2d8c cd f3 18			call break_point_state  
2d8f				endm  
# End of macro CALLMONITOR
2d8f				endif 
2d8f			 
2d8f			; cant push right now due to tokenised strings  
2d8f			 
2d8f			; get the destination of where to copy this definition to. 
2d8f			 
2d8f c5					push bc 
2d90 d1					pop de 
2d91			 
2d91 7e			.listl:         ld a,(hl) 
2d92 fe 00				cp 0 
2d94 28 09				jr z, .lreplsp     ; replace zero with space 
2d96					;cp FORTH_END_BUFFER 
2d96 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d98 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d9a				 
2d9a					; just copy this char as is then 
2d9a			 
2d9a 12					ld (de), a 
2d9b			 
2d9b 23			.listnxt:	inc hl 
2d9c 13					inc de 
2d9d 18 f2				jr .listl 
2d9f			 
2d9f 3e 20		.lreplsp:	ld a,' ' 
2da1 12					ld (de), a 
2da2 18 f7				jr .listnxt 
2da4			 
2da4			; close up uword def 
2da4			 
2da4			.listdone: 
2da4 12					ld (de), a 
2da5 13					inc de 
2da6 3e 00				ld a, 0 
2da8 12					ld (de), a 
2da9			 
2da9			; now have def so clean up and push to stack 
2da9			 
2da9 21 fc f1				ld hl, scratch 
2dac				if DEBUG_FORTH_WORDS 
2dac					DMARK "Ltp" 
2dac f5				push af  
2dad 3a c1 2d			ld a, (.dmark)  
2db0 32 6e fe			ld (debug_mark),a  
2db3 3a c2 2d			ld a, (.dmark+1)  
2db6 32 6f fe			ld (debug_mark+1),a  
2db9 3a c3 2d			ld a, (.dmark+2)  
2dbc 32 70 fe			ld (debug_mark+2),a  
2dbf 18 03			jr .pastdmark  
2dc1 ..			.dmark: db "Ltp"  
2dc4 f1			.pastdmark: pop af  
2dc5			endm  
# End of macro DMARK
2dc5					CALLMONITOR 
2dc5 cd f3 18			call break_point_state  
2dc8				endm  
# End of macro CALLMONITOR
2dc8				endif 
2dc8			 
2dc8 18 1f			jr .listpush 
2dca			 
2dca			;.lnuword:	pop hl 
2dca			;		call forth_tok_next 
2dca			;		jp .ldouscan  
2dca			 
2dca			.lunotfound:		  
2dca			 
2dca				if DEBUG_FORTH_WORDS 
2dca					DMARK "LSn" 
2dca f5				push af  
2dcb 3a df 2d			ld a, (.dmark)  
2dce 32 6e fe			ld (debug_mark),a  
2dd1 3a e0 2d			ld a, (.dmark+1)  
2dd4 32 6f fe			ld (debug_mark+1),a  
2dd7 3a e1 2d			ld a, (.dmark+2)  
2dda 32 70 fe			ld (debug_mark+2),a  
2ddd 18 03			jr .pastdmark  
2ddf ..			.dmark: db "LSn"  
2de2 f1			.pastdmark: pop af  
2de3			endm  
# End of macro DMARK
2de3					CALLMONITOR 
2de3 cd f3 18			call break_point_state  
2de6				endm  
# End of macro CALLMONITOR
2de6				endif 
2de6			 
2de6					 
2de6			;		FORTH_DSP_POP 
2de6			;		ld hl, .luno 
2de6			 
2de6					NEXTW			 
2de6 c3 d5 22			jp macro_next 
2de9				endm 
# End of macro NEXTW
2de9			 
2de9			.listpush: 
2de9				if DEBUG_FORTH_WORDS 
2de9					DMARK "LS>" 
2de9 f5				push af  
2dea 3a fe 2d			ld a, (.dmark)  
2ded 32 6e fe			ld (debug_mark),a  
2df0 3a ff 2d			ld a, (.dmark+1)  
2df3 32 6f fe			ld (debug_mark+1),a  
2df6 3a 00 2e			ld a, (.dmark+2)  
2df9 32 70 fe			ld (debug_mark+2),a  
2dfc 18 03			jr .pastdmark  
2dfe ..			.dmark: db "LS>"  
2e01 f1			.pastdmark: pop af  
2e02			endm  
# End of macro DMARK
2e02					CALLMONITOR 
2e02 cd f3 18			call break_point_state  
2e05				endm  
# End of macro CALLMONITOR
2e05				endif 
2e05 cd d5 1f				call forth_push_str 
2e08			 
2e08			 
2e08			 
2e08					NEXTW 
2e08 c3 d5 22			jp macro_next 
2e0b				endm 
# End of macro NEXTW
2e0b			 
2e0b			;.luno:    db "Word not found",0 
2e0b			 
2e0b			 
2e0b			 
2e0b			 
2e0b			 
2e0b			;		push hl   ; save pointer to start of uword def string 
2e0b			; 
2e0b			;; look for FORTH_EOL_LINE 
2e0b			;		ld a, FORTH_END_BUFFER 
2e0b			;		call strlent 
2e0b			; 
2e0b			;		inc hl		 ; space for coln def 
2e0b			;		inc hl 
2e0b			;		inc hl          ; space for terms 
2e0b			;		inc hl 
2e0b			; 
2e0b			;		ld a, 20   ; TODO get actual length 
2e0b			;		call addatohl    ; include a random amount of room for the uword name 
2e0b			; 
2e0b			;		 
2e0b			;	if DEBUG_FORTH_WORDS 
2e0b			;		DMARK "Lt1" 
2e0b			;		CALLMONITOR 
2e0b			;	endif 
2e0b			;		 
2e0b			; 
2e0b			;; malloc space for the string because we cant change it 
2e0b			; 
2e0b			;		call malloc 
2e0b			;	if DEBUG_FORTH_MALLOC_GUARD 
2e0b			;		push af 
2e0b			;		call ishlzero 
2e0b			;		pop af 
2e0b			;		 
2e0b			;		call z,malloc_error 
2e0b			;	endif 
2e0b			; 
2e0b			;	if DEBUG_FORTH_WORDS 
2e0b			;		DMARK "Lt2" 
2e0b			;		CALLMONITOR 
2e0b			;	endif 
2e0b			;		pop de 
2e0b			;		push hl    ; push the malloc to release later 
2e0b			;		push hl   ;  push back a copy for the later stack push 
2e0b			;		 
2e0b			;; copy the string swapping out the zero terms for spaces 
2e0b			; 
2e0b			;		; de has our source 
2e0b			;		; hl has our dest 
2e0b			; 
2e0b			;; add the coln def 
2e0b			; 
2e0b			;		ld a, ':' 
2e0b			;		ld (hl), a 
2e0b			;		inc hl 
2e0b			;		ld a, ' ' 
2e0b			;		ld (hl), a 
2e0b			;		inc hl 
2e0b			; 
2e0b			;; add the uname word 
2e0b			;		push de   ; save our string for now 
2e0b			;		ex de, hl 
2e0b			; 
2e0b			;		FORTH_DSP_VALUE 
2e0b			;		;v5 FORTH_DSP_VALUE 
2e0b			; 
2e0b			;		inc hl   ; skip type but we know by now this is OK 
2e0b			; 
2e0b			;.luword:	ld a,(hl) 
2e0b			;		cp 0 
2e0b			;		jr z, .luword2 
2e0b			;		ld (de), a 
2e0b			;		inc de 
2e0b			;		inc hl 
2e0b			;		jr .luword 
2e0b			; 
2e0b			;.luword2:	ld a, ' ' 
2e0b			;		ld (de), a 
2e0b			;;		inc hl 
2e0b			;;		inc de 
2e0b			;;		ld (de), a 
2e0b			;;		inc hl 
2e0b			;		inc de 
2e0b			; 
2e0b			;		ex de, hl 
2e0b			;		pop de 
2e0b			;		 
2e0b			;		 
2e0b			; 
2e0b			;; detoken that string and copy it 
2e0b			; 
2e0b			;	if DEBUG_FORTH_WORDS 
2e0b			;		DMARK "Lt2" 
2e0b			;		CALLMONITOR 
2e0b			;	endif 
2e0b			;.ldetok:	ld a, (de) 
2e0b			;		cp FORTH_END_BUFFER 
2e0b			;		jr z, .ldetokend 
2e0b			;		; swap out any zero term for space 
2e0b			;		cp 0 
2e0b			;		jr nz, .ldetoknext 
2e0b			;		ld a, ' ' 
2e0b			; 
2e0b			;	if DEBUG_FORTH_WORDS 
2e0b			;		DMARK "LtS" 
2e0b			;		CALLMONITOR 
2e0b			;	endif 
2e0b			;.ldetoknext:	ld (hl), a 
2e0b			;		inc de 
2e0b			;		inc hl 
2e0b			;		jr .ldetok 
2e0b			; 
2e0b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e0b			;		ld (hl), a  
2e0b			; 
2e0b			;; free that temp malloc 
2e0b			; 
2e0b			;		pop hl    
2e0b			; 
2e0b			;	if DEBUG_FORTH_WORDS 
2e0b			;		DMARK "Lt4" 
2e0b			;		CALLMONITOR 
2e0b			;	endif 
2e0b			;		call forth_apushstrhl 
2e0b			; 
2e0b			;		; get rid of temp malloc area 
2e0b			; 
2e0b			;		pop hl 
2e0b			;		call free 
2e0b			; 
2e0b			;		jr .ludone 
2e0b			; 
2e0b			;.lnuword:	pop hl 
2e0b			;		call forth_tok_next 
2e0b			;		jp .ldouscan  
2e0b			; 
2e0b			;.ludone:		 pop hl 
2e0b			; 
2e0b					NEXTW 
2e0b c3 d5 22			jp macro_next 
2e0e				endm 
# End of macro NEXTW
2e0e			 
2e0e			.FORGET: 
2e0e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e0e 5d				db WORD_SYS_CORE+73             
2e0f 87 2e			dw .NOP            
2e11 07				db 6 + 1 
2e12 .. 00			db "FORGET",0              
2e19				endm 
# End of macro CWHEAD
2e19			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e19			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e19			; | |  
2e19			; | | e.g. "MORE" forget 
2e19					if DEBUG_FORTH_WORDS_KEY 
2e19						DMARK "FRG" 
2e19 f5				push af  
2e1a 3a 2e 2e			ld a, (.dmark)  
2e1d 32 6e fe			ld (debug_mark),a  
2e20 3a 2f 2e			ld a, (.dmark+1)  
2e23 32 6f fe			ld (debug_mark+1),a  
2e26 3a 30 2e			ld a, (.dmark+2)  
2e29 32 70 fe			ld (debug_mark+2),a  
2e2c 18 03			jr .pastdmark  
2e2e ..			.dmark: db "FRG"  
2e31 f1			.pastdmark: pop af  
2e32			endm  
# End of macro DMARK
2e32						CALLMONITOR 
2e32 cd f3 18			call break_point_state  
2e35				endm  
# End of macro CALLMONITOR
2e35					endif 
2e35			 
2e35				; find uword 
2e35			        ; update start of word with "_" 
2e35				; replace uword with deleted flag 
2e35			 
2e35			 
2e35			;	if DEBUG_FORTH_WORDS 
2e35			;		DMARK "FOG" 
2e35			;		CALLMONITOR 
2e35			;	endif 
2e35			 
2e35			 
2e35					; Get ptr to the word we need to look up 
2e35			 
2e35					FORTH_DSP_VALUEHL 
2e35 cd 5e 21			call macro_dsp_valuehl 
2e38				endm 
# End of macro FORTH_DSP_VALUEHL
2e38					;v5 FORTH_DSP_VALUE 
2e38				; TODO type check 
2e38			;		inc hl    ; Skip type check  
2e38 e5					push hl 
2e39 c1					pop bc 
2e3a			;		ex de, hl    ; put into DE 
2e3a			 
2e3a			 
2e3a 21 00 80				ld hl, baseram 
2e3d					;ld hl, baseusermem 
2e3d			 
2e3d				; skip dict stub 
2e3d			;	call forth_tok_next 
2e3d e5			push hl   ; sacreifical push 
2e3e			 
2e3e			.fldouscanm: 
2e3e e1				pop hl 
2e3f			.fldouscan: 
2e3f			;	if DEBUG_FORTH_WORDS 
2e3f			;		DMARK "LSs" 
2e3f			;		CALLMONITOR 
2e3f			;	endif 
2e3f				; skip dict stub 
2e3f cd 26 24				call forth_tok_next 
2e42			 
2e42			 
2e42			; while we have words to look for 
2e42			 
2e42 7e				ld a, (hl)      
2e43			;	if DEBUG_FORTH_WORDS 
2e43			;		DMARK "LSk" 
2e43			;		CALLMONITOR 
2e43			;	endif 
2e43 fe 00				cp WORD_SYS_END 
2e45 ca 81 2e				jp z, .flunotfound 
2e48 fe 01				cp WORD_SYS_UWORD 
2e4a c2 3f 2e				jp nz, .fldouscan 
2e4d			 
2e4d			;	if DEBUG_FORTH_WORDS 
2e4d			;		DMARK "LSu" 
2e4d			;		CALLMONITOR 
2e4d			;	endif 
2e4d			 
2e4d					; found a uword but is it the one we want... 
2e4d			 
2e4d c5					push bc     ; uword to find is on bc 
2e4e d1					pop de 
2e4f			 
2e4f e5					push hl  ; to save the ptr 
2e50			 
2e50					; skip opcode 
2e50 23					inc hl  
2e51					; skip next ptr 
2e51 23					inc hl  
2e52 23					inc hl 
2e53					; skip len 
2e53 23					inc hl 
2e54			 
2e54			;	if DEBUG_FORTH_WORDS 
2e54			;		DMARK "LSc" 
2e54			;		CALLMONITOR 
2e54			;	endif 
2e54 cd e2 13				call strcmp 
2e57 c2 3e 2e				jp nz, .fldouscanm 
2e5a			; 
2e5a			; 
2e5a			;; while we have words to look for 
2e5a			; 
2e5a			;.fdouscan:	ld a, (hl)      
2e5a			;	if DEBUG_FORTH_WORDS 
2e5a			;		DMARK "LSs" 
2e5a			;		CALLMONITOR 
2e5a			;	endif 
2e5a			;		cp WORD_SYS_END 
2e5a			;		jp z, .fudone 
2e5a			;		cp WORD_SYS_UWORD 
2e5a			;		jp nz, .fnuword 
2e5a			; 
2e5a			;	if DEBUG_FORTH_WORDS 
2e5a			;		DMARK "FGu" 
2e5a			;		CALLMONITOR 
2e5a			;	endif 
2e5a			; 
2e5a			;		; found a uword but is it the one we want... 
2e5a			; 
2e5a			; 
2e5a			;	        pop de   ; get back the dsp name 
2e5a			;		push de 
2e5a			; 
2e5a			;		push hl  ; to save the ptr 
2e5a			; 
2e5a			;		; skip opcode 
2e5a			;		inc hl  
2e5a			;		; skip next ptr 
2e5a			;		inc hl  
2e5a			;		inc hl 
2e5a			;		; skip len 
2e5a			;		inc hl 
2e5a			; 
2e5a			;	if DEBUG_FORTH_WORDS 
2e5a			;		DMARK "FGc" 
2e5a			;		CALLMONITOR 
2e5a			;	endif 
2e5a			;		call strcmp 
2e5a			;		jp nz, .fnuword 
2e5a			 
2e5a			 
2e5a e1			pop hl 
2e5b			 
2e5b				 
2e5b				if DEBUG_FORTH_WORDS 
2e5b					DMARK "FGm" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 6e fe			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 6f fe			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 70 fe			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "FGm"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74					CALLMONITOR 
2e74 cd f3 18			call break_point_state  
2e77				endm  
# End of macro CALLMONITOR
2e77				endif 
2e77			 
2e77			 
2e77			 
2e77					; we have a uword so push its name to the stack 
2e77			 
2e77			;	   	push hl  ; save so we can move to next dict block 
2e77			;pop hl 
2e77			 
2e77					; update opcode to deleted 
2e77 3e 03				ld a, WORD_SYS_DELETED 
2e79 77					ld (hl), a 
2e7a			 
2e7a 23					inc hl  
2e7b					; skip next ptr 
2e7b 23					inc hl  
2e7c 23					inc hl 
2e7d					; skip len 
2e7d 23					inc hl 
2e7e			 
2e7e					; TODO change parser to skip deleted words but for now mark it out 
2e7e 3e 5f				ld a, "_" 
2e80 77					ld  (hl),a 
2e81			 
2e81			;		jr .fudone 
2e81			; 
2e81			;.fnuword:	pop hl 
2e81			;		call forth_tok_next 
2e81			;		jp .fdouscan  
2e81			 
2e81			.flunotfound:		  
2e81			 
2e81			 
2e81					 
2e81					FORTH_DSP_POP 
2e81 cd 16 22			call macro_forth_dsp_pop 
2e84				endm 
# End of macro FORTH_DSP_POP
2e84			;		ld hl, .luno 
2e84			;.fudone:		 pop hl 
2e84					NEXTW 
2e84 c3 d5 22			jp macro_next 
2e87				endm 
# End of macro NEXTW
2e87			.NOP: 
2e87				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e87 61				db WORD_SYS_CORE+77             
2e88 ae 2e			dw .COMO            
2e8a 04				db 3 + 1 
2e8b .. 00			db "NOP",0              
2e8f				endm 
# End of macro CWHEAD
2e8f			; | NOP (  --  ) Do nothing | DONE 
2e8f					if DEBUG_FORTH_WORDS_KEY 
2e8f						DMARK "NOP" 
2e8f f5				push af  
2e90 3a a4 2e			ld a, (.dmark)  
2e93 32 6e fe			ld (debug_mark),a  
2e96 3a a5 2e			ld a, (.dmark+1)  
2e99 32 6f fe			ld (debug_mark+1),a  
2e9c 3a a6 2e			ld a, (.dmark+2)  
2e9f 32 70 fe			ld (debug_mark+2),a  
2ea2 18 03			jr .pastdmark  
2ea4 ..			.dmark: db "NOP"  
2ea7 f1			.pastdmark: pop af  
2ea8			endm  
# End of macro DMARK
2ea8						CALLMONITOR 
2ea8 cd f3 18			call break_point_state  
2eab				endm  
# End of macro CALLMONITOR
2eab					endif 
2eab				       NEXTW 
2eab c3 d5 22			jp macro_next 
2eae				endm 
# End of macro NEXTW
2eae			.COMO: 
2eae				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2eae 6e				db WORD_SYS_CORE+90             
2eaf 00 2f			dw .COMC            
2eb1 02				db 1 + 1 
2eb2 .. 00			db "(",0              
2eb4				endm 
# End of macro CWHEAD
2eb4			; | ( ( -- )  Start of comment | DONE 
2eb4			 
2eb4			 
2eb4 2a fd f4				ld hl, ( os_tok_ptr) 
2eb7 11 fb 2e			ld de, .closepar 
2eba					 
2eba					if DEBUG_FORTH_WORDS 
2eba						DMARK ").." 
2eba f5				push af  
2ebb 3a cf 2e			ld a, (.dmark)  
2ebe 32 6e fe			ld (debug_mark),a  
2ec1 3a d0 2e			ld a, (.dmark+1)  
2ec4 32 6f fe			ld (debug_mark+1),a  
2ec7 3a d1 2e			ld a, (.dmark+2)  
2eca 32 70 fe			ld (debug_mark+2),a  
2ecd 18 03			jr .pastdmark  
2ecf ..			.dmark: db ").."  
2ed2 f1			.pastdmark: pop af  
2ed3			endm  
# End of macro DMARK
2ed3						CALLMONITOR 
2ed3 cd f3 18			call break_point_state  
2ed6				endm  
# End of macro CALLMONITOR
2ed6					endif 
2ed6 cd f0 23			call findnexttok  
2ed9			 
2ed9					if DEBUG_FORTH_WORDS 
2ed9						DMARK "IF5" 
2ed9 f5				push af  
2eda 3a ee 2e			ld a, (.dmark)  
2edd 32 6e fe			ld (debug_mark),a  
2ee0 3a ef 2e			ld a, (.dmark+1)  
2ee3 32 6f fe			ld (debug_mark+1),a  
2ee6 3a f0 2e			ld a, (.dmark+2)  
2ee9 32 70 fe			ld (debug_mark+2),a  
2eec 18 03			jr .pastdmark  
2eee ..			.dmark: db "IF5"  
2ef1 f1			.pastdmark: pop af  
2ef2			endm  
# End of macro DMARK
2ef2						CALLMONITOR 
2ef2 cd f3 18			call break_point_state  
2ef5				endm  
# End of macro CALLMONITOR
2ef5					endif 
2ef5				; replace below with ) exec using tok_ptr 
2ef5 22 fd f4			ld (os_tok_ptr), hl 
2ef8 c3 66 23			jp exec1 
2efb			 
2efb .. 00			.closepar:   db ")",0 
2efd			 
2efd				       NEXTW 
2efd c3 d5 22			jp macro_next 
2f00				endm 
# End of macro NEXTW
2f00			.COMC: 
2f00				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f00 6f				db WORD_SYS_CORE+91             
2f01 09 2f			dw .SCRATCH            
2f03 02				db 1 + 1 
2f04 .. 00			db ")",0              
2f06				endm 
# End of macro CWHEAD
2f06			; | ) ( -- )  End of comment |  DONE  
2f06				       NEXTW 
2f06 c3 d5 22			jp macro_next 
2f09				endm 
# End of macro NEXTW
2f09			 
2f09			.SCRATCH: 
2f09				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f09 6f				db WORD_SYS_CORE+91             
2f0a 44 2f			dw .INC            
2f0c 08				db 7 + 1 
2f0d .. 00			db "SCRATCH",0              
2f15				endm 
# End of macro CWHEAD
2f15			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f15			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f15			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f15			; | |  
2f15			; | | e.g.    : score $00 scratch ; 
2f15			; | |  
2f15			; | | $00 score ! 
2f15			; | | $01 score +! 
2f15			; | |  
2f15			; | | e.g.   : varword $0a scratch ;  
2f15			; | | 
2f15			; | | $8000 varword ! 
2f15					if DEBUG_FORTH_WORDS_KEY 
2f15						DMARK "SCR" 
2f15 f5				push af  
2f16 3a 2a 2f			ld a, (.dmark)  
2f19 32 6e fe			ld (debug_mark),a  
2f1c 3a 2b 2f			ld a, (.dmark+1)  
2f1f 32 6f fe			ld (debug_mark+1),a  
2f22 3a 2c 2f			ld a, (.dmark+2)  
2f25 32 70 fe			ld (debug_mark+2),a  
2f28 18 03			jr .pastdmark  
2f2a ..			.dmark: db "SCR"  
2f2d f1			.pastdmark: pop af  
2f2e			endm  
# End of macro DMARK
2f2e						CALLMONITOR 
2f2e cd f3 18			call break_point_state  
2f31				endm  
# End of macro CALLMONITOR
2f31					endif 
2f31			 
2f31					FORTH_DSP_VALUEHL 
2f31 cd 5e 21			call macro_dsp_valuehl 
2f34				endm 
# End of macro FORTH_DSP_VALUEHL
2f34				 
2f34					FORTH_DSP_POP 
2f34 cd 16 22			call macro_forth_dsp_pop 
2f37				endm 
# End of macro FORTH_DSP_POP
2f37			 
2f37 7d					ld a, l 
2f38 21 21 f7				ld hl, os_var_array 
2f3b cd 4c 0f				call addatohl 
2f3e			 
2f3e cd 67 1f				call forth_push_numhl 
2f41			 
2f41				       NEXTW 
2f41 c3 d5 22			jp macro_next 
2f44				endm 
# End of macro NEXTW
2f44			 
2f44			.INC: 
2f44				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f44 6f				db WORD_SYS_CORE+91             
2f45 98 2f			dw .DEC            
2f47 03				db 2 + 1 
2f48 .. 00			db "+!",0              
2f4b				endm 
# End of macro CWHEAD
2f4b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f4b					if DEBUG_FORTH_WORDS_KEY 
2f4b						DMARK "+s_" 
2f4b f5				push af  
2f4c 3a 60 2f			ld a, (.dmark)  
2f4f 32 6e fe			ld (debug_mark),a  
2f52 3a 61 2f			ld a, (.dmark+1)  
2f55 32 6f fe			ld (debug_mark+1),a  
2f58 3a 62 2f			ld a, (.dmark+2)  
2f5b 32 70 fe			ld (debug_mark+2),a  
2f5e 18 03			jr .pastdmark  
2f60 ..			.dmark: db "+s_"  
2f63 f1			.pastdmark: pop af  
2f64			endm  
# End of macro DMARK
2f64						CALLMONITOR 
2f64 cd f3 18			call break_point_state  
2f67				endm  
# End of macro CALLMONITOR
2f67					endif 
2f67			 
2f67					FORTH_DSP_VALUEHL 
2f67 cd 5e 21			call macro_dsp_valuehl 
2f6a				endm 
# End of macro FORTH_DSP_VALUEHL
2f6a			 
2f6a e5					push hl   ; save address 
2f6b			 
2f6b					FORTH_DSP_POP 
2f6b cd 16 22			call macro_forth_dsp_pop 
2f6e				endm 
# End of macro FORTH_DSP_POP
2f6e			 
2f6e					FORTH_DSP_VALUEHL 
2f6e cd 5e 21			call macro_dsp_valuehl 
2f71				endm 
# End of macro FORTH_DSP_VALUEHL
2f71			 
2f71					FORTH_DSP_POP 
2f71 cd 16 22			call macro_forth_dsp_pop 
2f74				endm 
# End of macro FORTH_DSP_POP
2f74			 
2f74					; hl contains value to add to byte at a 
2f74				 
2f74 eb					ex de, hl 
2f75			 
2f75 e1					pop hl 
2f76			 
2f76					if DEBUG_FORTH_WORDS 
2f76						DMARK "INC" 
2f76 f5				push af  
2f77 3a 8b 2f			ld a, (.dmark)  
2f7a 32 6e fe			ld (debug_mark),a  
2f7d 3a 8c 2f			ld a, (.dmark+1)  
2f80 32 6f fe			ld (debug_mark+1),a  
2f83 3a 8d 2f			ld a, (.dmark+2)  
2f86 32 70 fe			ld (debug_mark+2),a  
2f89 18 03			jr .pastdmark  
2f8b ..			.dmark: db "INC"  
2f8e f1			.pastdmark: pop af  
2f8f			endm  
# End of macro DMARK
2f8f						CALLMONITOR 
2f8f cd f3 18			call break_point_state  
2f92				endm  
# End of macro CALLMONITOR
2f92					endif 
2f92			 
2f92 7e					ld a,(hl) 
2f93 83					add e 
2f94 77					ld (hl),a 
2f95			 
2f95			 
2f95			 
2f95				       NEXTW 
2f95 c3 d5 22			jp macro_next 
2f98				endm 
# End of macro NEXTW
2f98			 
2f98			.DEC: 
2f98				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f98 6f				db WORD_SYS_CORE+91             
2f99 e9 2f			dw .INC2            
2f9b 03				db 2 + 1 
2f9c .. 00			db "-!",0              
2f9f				endm 
# End of macro CWHEAD
2f9f			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f9f					if DEBUG_FORTH_WORDS_KEY 
2f9f						DMARK "-s_" 
2f9f f5				push af  
2fa0 3a b4 2f			ld a, (.dmark)  
2fa3 32 6e fe			ld (debug_mark),a  
2fa6 3a b5 2f			ld a, (.dmark+1)  
2fa9 32 6f fe			ld (debug_mark+1),a  
2fac 3a b6 2f			ld a, (.dmark+2)  
2faf 32 70 fe			ld (debug_mark+2),a  
2fb2 18 03			jr .pastdmark  
2fb4 ..			.dmark: db "-s_"  
2fb7 f1			.pastdmark: pop af  
2fb8			endm  
# End of macro DMARK
2fb8						CALLMONITOR 
2fb8 cd f3 18			call break_point_state  
2fbb				endm  
# End of macro CALLMONITOR
2fbb					endif 
2fbb			 
2fbb					FORTH_DSP_VALUEHL 
2fbb cd 5e 21			call macro_dsp_valuehl 
2fbe				endm 
# End of macro FORTH_DSP_VALUEHL
2fbe			 
2fbe e5					push hl   ; save address 
2fbf			 
2fbf					FORTH_DSP_POP 
2fbf cd 16 22			call macro_forth_dsp_pop 
2fc2				endm 
# End of macro FORTH_DSP_POP
2fc2			 
2fc2					FORTH_DSP_VALUEHL 
2fc2 cd 5e 21			call macro_dsp_valuehl 
2fc5				endm 
# End of macro FORTH_DSP_VALUEHL
2fc5			 
2fc5					; hl contains value to add to byte at a 
2fc5				 
2fc5 eb					ex de, hl 
2fc6			 
2fc6 e1					pop hl 
2fc7			 
2fc7					if DEBUG_FORTH_WORDS 
2fc7						DMARK "DEC" 
2fc7 f5				push af  
2fc8 3a dc 2f			ld a, (.dmark)  
2fcb 32 6e fe			ld (debug_mark),a  
2fce 3a dd 2f			ld a, (.dmark+1)  
2fd1 32 6f fe			ld (debug_mark+1),a  
2fd4 3a de 2f			ld a, (.dmark+2)  
2fd7 32 70 fe			ld (debug_mark+2),a  
2fda 18 03			jr .pastdmark  
2fdc ..			.dmark: db "DEC"  
2fdf f1			.pastdmark: pop af  
2fe0			endm  
# End of macro DMARK
2fe0						CALLMONITOR 
2fe0 cd f3 18			call break_point_state  
2fe3				endm  
# End of macro CALLMONITOR
2fe3					endif 
2fe3			 
2fe3 7e					ld a,(hl) 
2fe4 93					sub e 
2fe5 77					ld (hl),a 
2fe6			 
2fe6			 
2fe6			 
2fe6				       NEXTW 
2fe6 c3 d5 22			jp macro_next 
2fe9				endm 
# End of macro NEXTW
2fe9			 
2fe9			.INC2: 
2fe9				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2fe9 6f				db WORD_SYS_CORE+91             
2fea 93 30			dw .DEC2            
2fec 04				db 3 + 1 
2fed .. 00			db "+2!",0              
2ff1				endm 
# End of macro CWHEAD
2ff1			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ff1			 
2ff1					if DEBUG_FORTH_WORDS_KEY 
2ff1						DMARK "+2s" 
2ff1 f5				push af  
2ff2 3a 06 30			ld a, (.dmark)  
2ff5 32 6e fe			ld (debug_mark),a  
2ff8 3a 07 30			ld a, (.dmark+1)  
2ffb 32 6f fe			ld (debug_mark+1),a  
2ffe 3a 08 30			ld a, (.dmark+2)  
3001 32 70 fe			ld (debug_mark+2),a  
3004 18 03			jr .pastdmark  
3006 ..			.dmark: db "+2s"  
3009 f1			.pastdmark: pop af  
300a			endm  
# End of macro DMARK
300a						CALLMONITOR 
300a cd f3 18			call break_point_state  
300d				endm  
# End of macro CALLMONITOR
300d					endif 
300d			 
300d					; Address 
300d			 
300d					FORTH_DSP_VALUEHL 
300d cd 5e 21			call macro_dsp_valuehl 
3010				endm 
# End of macro FORTH_DSP_VALUEHL
3010			 
3010 e5					push hl    ; save address 
3011			 
3011					; load content into de 
3011			 
3011 5e					ld e,(hl) 
3012 23					inc hl 
3013 56					ld d, (hl) 
3014			 
3014					if DEBUG_FORTH_WORDS 
3014						DMARK "+2a" 
3014 f5				push af  
3015 3a 29 30			ld a, (.dmark)  
3018 32 6e fe			ld (debug_mark),a  
301b 3a 2a 30			ld a, (.dmark+1)  
301e 32 6f fe			ld (debug_mark+1),a  
3021 3a 2b 30			ld a, (.dmark+2)  
3024 32 70 fe			ld (debug_mark+2),a  
3027 18 03			jr .pastdmark  
3029 ..			.dmark: db "+2a"  
302c f1			.pastdmark: pop af  
302d			endm  
# End of macro DMARK
302d						CALLMONITOR 
302d cd f3 18			call break_point_state  
3030				endm  
# End of macro CALLMONITOR
3030					endif 
3030			 
3030					FORTH_DSP_POP 
3030 cd 16 22			call macro_forth_dsp_pop 
3033				endm 
# End of macro FORTH_DSP_POP
3033			 
3033					; Get value to add 
3033			 
3033					FORTH_DSP_VALUE 
3033 cd 47 21			call macro_forth_dsp_value 
3036				endm 
# End of macro FORTH_DSP_VALUE
3036			 
3036					if DEBUG_FORTH_WORDS 
3036						DMARK "+2v" 
3036 f5				push af  
3037 3a 4b 30			ld a, (.dmark)  
303a 32 6e fe			ld (debug_mark),a  
303d 3a 4c 30			ld a, (.dmark+1)  
3040 32 6f fe			ld (debug_mark+1),a  
3043 3a 4d 30			ld a, (.dmark+2)  
3046 32 70 fe			ld (debug_mark+2),a  
3049 18 03			jr .pastdmark  
304b ..			.dmark: db "+2v"  
304e f1			.pastdmark: pop af  
304f			endm  
# End of macro DMARK
304f						CALLMONITOR 
304f cd f3 18			call break_point_state  
3052				endm  
# End of macro CALLMONITOR
3052					endif 
3052			 
3052 19					add hl, de 
3053			 
3053					if DEBUG_FORTH_WORDS 
3053						DMARK "+2+" 
3053 f5				push af  
3054 3a 68 30			ld a, (.dmark)  
3057 32 6e fe			ld (debug_mark),a  
305a 3a 69 30			ld a, (.dmark+1)  
305d 32 6f fe			ld (debug_mark+1),a  
3060 3a 6a 30			ld a, (.dmark+2)  
3063 32 70 fe			ld (debug_mark+2),a  
3066 18 03			jr .pastdmark  
3068 ..			.dmark: db "+2+"  
306b f1			.pastdmark: pop af  
306c			endm  
# End of macro DMARK
306c						CALLMONITOR 
306c cd f3 18			call break_point_state  
306f				endm  
# End of macro CALLMONITOR
306f					endif 
306f			 
306f					; move result to de 
306f			 
306f eb					ex de, hl 
3070			 
3070					; Address 
3070			 
3070 e1					pop hl 
3071			 
3071					; save it back 
3071			 
3071 73					ld (hl), e 
3072 23					inc hl 
3073 72					ld (hl), d 
3074			 
3074					if DEBUG_FORTH_WORDS 
3074						DMARK "+2e" 
3074 f5				push af  
3075 3a 89 30			ld a, (.dmark)  
3078 32 6e fe			ld (debug_mark),a  
307b 3a 8a 30			ld a, (.dmark+1)  
307e 32 6f fe			ld (debug_mark+1),a  
3081 3a 8b 30			ld a, (.dmark+2)  
3084 32 70 fe			ld (debug_mark+2),a  
3087 18 03			jr .pastdmark  
3089 ..			.dmark: db "+2e"  
308c f1			.pastdmark: pop af  
308d			endm  
# End of macro DMARK
308d						CALLMONITOR 
308d cd f3 18			call break_point_state  
3090				endm  
# End of macro CALLMONITOR
3090					endif 
3090			 
3090			 
3090			 
3090			 
3090			 
3090				       NEXTW 
3090 c3 d5 22			jp macro_next 
3093				endm 
# End of macro NEXTW
3093			 
3093			.DEC2: 
3093				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3093 6f				db WORD_SYS_CORE+91             
3094 3f 31			dw .GET2            
3096 04				db 3 + 1 
3097 .. 00			db "-2!",0              
309b				endm 
# End of macro CWHEAD
309b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
309b			 
309b			 
309b					if DEBUG_FORTH_WORDS_KEY 
309b						DMARK "-2s" 
309b f5				push af  
309c 3a b0 30			ld a, (.dmark)  
309f 32 6e fe			ld (debug_mark),a  
30a2 3a b1 30			ld a, (.dmark+1)  
30a5 32 6f fe			ld (debug_mark+1),a  
30a8 3a b2 30			ld a, (.dmark+2)  
30ab 32 70 fe			ld (debug_mark+2),a  
30ae 18 03			jr .pastdmark  
30b0 ..			.dmark: db "-2s"  
30b3 f1			.pastdmark: pop af  
30b4			endm  
# End of macro DMARK
30b4						CALLMONITOR 
30b4 cd f3 18			call break_point_state  
30b7				endm  
# End of macro CALLMONITOR
30b7					endif 
30b7			 
30b7					; Address 
30b7			 
30b7					FORTH_DSP_VALUEHL 
30b7 cd 5e 21			call macro_dsp_valuehl 
30ba				endm 
# End of macro FORTH_DSP_VALUEHL
30ba			 
30ba e5					push hl    ; save address 
30bb			 
30bb					; load content into de 
30bb			 
30bb 5e					ld e,(hl) 
30bc 23					inc hl 
30bd 56					ld d, (hl) 
30be			 
30be					if DEBUG_FORTH_WORDS 
30be						DMARK "-2a" 
30be f5				push af  
30bf 3a d3 30			ld a, (.dmark)  
30c2 32 6e fe			ld (debug_mark),a  
30c5 3a d4 30			ld a, (.dmark+1)  
30c8 32 6f fe			ld (debug_mark+1),a  
30cb 3a d5 30			ld a, (.dmark+2)  
30ce 32 70 fe			ld (debug_mark+2),a  
30d1 18 03			jr .pastdmark  
30d3 ..			.dmark: db "-2a"  
30d6 f1			.pastdmark: pop af  
30d7			endm  
# End of macro DMARK
30d7						CALLMONITOR 
30d7 cd f3 18			call break_point_state  
30da				endm  
# End of macro CALLMONITOR
30da					endif 
30da			 
30da					FORTH_DSP_POP 
30da cd 16 22			call macro_forth_dsp_pop 
30dd				endm 
# End of macro FORTH_DSP_POP
30dd			 
30dd					; Get value to remove 
30dd			 
30dd					FORTH_DSP_VALUE 
30dd cd 47 21			call macro_forth_dsp_value 
30e0				endm 
# End of macro FORTH_DSP_VALUE
30e0			 
30e0					if DEBUG_FORTH_WORDS 
30e0						DMARK "-2v" 
30e0 f5				push af  
30e1 3a f5 30			ld a, (.dmark)  
30e4 32 6e fe			ld (debug_mark),a  
30e7 3a f6 30			ld a, (.dmark+1)  
30ea 32 6f fe			ld (debug_mark+1),a  
30ed 3a f7 30			ld a, (.dmark+2)  
30f0 32 70 fe			ld (debug_mark+2),a  
30f3 18 03			jr .pastdmark  
30f5 ..			.dmark: db "-2v"  
30f8 f1			.pastdmark: pop af  
30f9			endm  
# End of macro DMARK
30f9						CALLMONITOR 
30f9 cd f3 18			call break_point_state  
30fc				endm  
# End of macro CALLMONITOR
30fc					endif 
30fc			 
30fc eb					ex de, hl 
30fd ed 52				sbc hl, de 
30ff			 
30ff					if DEBUG_FORTH_WORDS 
30ff						DMARK "-2d" 
30ff f5				push af  
3100 3a 14 31			ld a, (.dmark)  
3103 32 6e fe			ld (debug_mark),a  
3106 3a 15 31			ld a, (.dmark+1)  
3109 32 6f fe			ld (debug_mark+1),a  
310c 3a 16 31			ld a, (.dmark+2)  
310f 32 70 fe			ld (debug_mark+2),a  
3112 18 03			jr .pastdmark  
3114 ..			.dmark: db "-2d"  
3117 f1			.pastdmark: pop af  
3118			endm  
# End of macro DMARK
3118						CALLMONITOR 
3118 cd f3 18			call break_point_state  
311b				endm  
# End of macro CALLMONITOR
311b					endif 
311b			 
311b					; move result to de 
311b			 
311b eb					ex de, hl 
311c			 
311c					; Address 
311c			 
311c e1					pop hl 
311d			 
311d					; save it back 
311d			 
311d 73					ld (hl), e 
311e 23					inc hl 
311f 72					ld (hl), d 
3120			 
3120					if DEBUG_FORTH_WORDS 
3120						DMARK "-2e" 
3120 f5				push af  
3121 3a 35 31			ld a, (.dmark)  
3124 32 6e fe			ld (debug_mark),a  
3127 3a 36 31			ld a, (.dmark+1)  
312a 32 6f fe			ld (debug_mark+1),a  
312d 3a 37 31			ld a, (.dmark+2)  
3130 32 70 fe			ld (debug_mark+2),a  
3133 18 03			jr .pastdmark  
3135 ..			.dmark: db "-2e"  
3138 f1			.pastdmark: pop af  
3139			endm  
# End of macro DMARK
3139						CALLMONITOR 
3139 cd f3 18			call break_point_state  
313c				endm  
# End of macro CALLMONITOR
313c					endif 
313c			 
313c			 
313c			 
313c			 
313c			 
313c				       NEXTW 
313c c3 d5 22			jp macro_next 
313f				endm 
# End of macro NEXTW
313f			.GET2: 
313f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
313f 6f				db WORD_SYS_CORE+91             
3140 6f 31			dw .BANG2            
3142 03				db 2 + 1 
3143 .. 00			db "2@",0              
3146				endm 
# End of macro CWHEAD
3146			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3146					if DEBUG_FORTH_WORDS_KEY 
3146						DMARK "2A_" 
3146 f5				push af  
3147 3a 5b 31			ld a, (.dmark)  
314a 32 6e fe			ld (debug_mark),a  
314d 3a 5c 31			ld a, (.dmark+1)  
3150 32 6f fe			ld (debug_mark+1),a  
3153 3a 5d 31			ld a, (.dmark+2)  
3156 32 70 fe			ld (debug_mark+2),a  
3159 18 03			jr .pastdmark  
315b ..			.dmark: db "2A_"  
315e f1			.pastdmark: pop af  
315f			endm  
# End of macro DMARK
315f						CALLMONITOR 
315f cd f3 18			call break_point_state  
3162				endm  
# End of macro CALLMONITOR
3162					endif 
3162			 
3162					FORTH_DSP_VALUEHL 
3162 cd 5e 21			call macro_dsp_valuehl 
3165				endm 
# End of macro FORTH_DSP_VALUEHL
3165			 
3165 5e					ld e, (hl) 
3166 23					inc hl 
3167 56					ld d, (hl) 
3168			 
3168 eb					ex de, hl 
3169			 
3169 cd 67 1f				call forth_push_numhl 
316c			 
316c				       NEXTW 
316c c3 d5 22			jp macro_next 
316f				endm 
# End of macro NEXTW
316f			.BANG2: 
316f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
316f 6f				db WORD_SYS_CORE+91             
3170 a7 31			dw .CONFIG            
3172 03				db 2 + 1 
3173 .. 00			db "2!",0              
3176				endm 
# End of macro CWHEAD
3176			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3176					if DEBUG_FORTH_WORDS_KEY 
3176						DMARK "2S_" 
3176 f5				push af  
3177 3a 8b 31			ld a, (.dmark)  
317a 32 6e fe			ld (debug_mark),a  
317d 3a 8c 31			ld a, (.dmark+1)  
3180 32 6f fe			ld (debug_mark+1),a  
3183 3a 8d 31			ld a, (.dmark+2)  
3186 32 70 fe			ld (debug_mark+2),a  
3189 18 03			jr .pastdmark  
318b ..			.dmark: db "2S_"  
318e f1			.pastdmark: pop af  
318f			endm  
# End of macro DMARK
318f						CALLMONITOR 
318f cd f3 18			call break_point_state  
3192				endm  
# End of macro CALLMONITOR
3192					endif 
3192			 
3192					FORTH_DSP_VALUEHL 
3192 cd 5e 21			call macro_dsp_valuehl 
3195				endm 
# End of macro FORTH_DSP_VALUEHL
3195			 
3195 e5					push hl   ; save address 
3196			 
3196			 
3196					FORTH_DSP_POP 
3196 cd 16 22			call macro_forth_dsp_pop 
3199				endm 
# End of macro FORTH_DSP_POP
3199			 
3199					 
3199					FORTH_DSP_VALUEHL 
3199 cd 5e 21			call macro_dsp_valuehl 
319c				endm 
# End of macro FORTH_DSP_VALUEHL
319c			 
319c					FORTH_DSP_POP 
319c cd 16 22			call macro_forth_dsp_pop 
319f				endm 
# End of macro FORTH_DSP_POP
319f			 
319f eb					ex de, hl    ; value now in de 
31a0			 
31a0 e1					pop hl 
31a1			 
31a1 73					ld (hl), e 
31a2			 
31a2 23					inc hl 
31a3			 
31a3 72					ld (hl), d 
31a4			 
31a4			 
31a4				       NEXTW 
31a4 c3 d5 22			jp macro_next 
31a7				endm 
# End of macro NEXTW
31a7			.CONFIG: 
31a7				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31a7 6f				db WORD_SYS_CORE+91             
31a8 b8 31			dw .ENDCORE            
31aa 07				db 6 + 1 
31ab .. 00			db "CONFIG",0              
31b2				endm 
# End of macro CWHEAD
31b2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31b2			 
31b2 cd d6 15				call config 
31b5					NEXTW 
31b5 c3 d5 22			jp macro_next 
31b8				endm 
# End of macro NEXTW
31b8			.ENDCORE: 
31b8			 
31b8			; eof 
31b8			 
31b8			 
# End of file forth_words_core.asm
31b8			include "forth_words_flow.asm" 
31b8			 
31b8			; | ## Program Flow Words 
31b8			 
31b8			.IF: 
31b8				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31b8 1e				db WORD_SYS_CORE+10             
31b9 ad 32			dw .THEN            
31bb 03				db 2 + 1 
31bc .. 00			db "IF",0              
31bf				endm 
# End of macro CWHEAD
31bf			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31bf			; 
31bf					if DEBUG_FORTH_WORDS_KEY 
31bf						DMARK "IF." 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 6e fe			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 6f fe			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 70 fe			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "IF."  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd f3 18			call break_point_state  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db			; eval TOS 
31db			 
31db				FORTH_DSP_VALUEHL 
31db cd 5e 21			call macro_dsp_valuehl 
31de				endm 
# End of macro FORTH_DSP_VALUEHL
31de			 
31de			;	push hl 
31de				FORTH_DSP_POP 
31de cd 16 22			call macro_forth_dsp_pop 
31e1				endm 
# End of macro FORTH_DSP_POP
31e1			;	pop hl 
31e1			 
31e1					if DEBUG_FORTH_WORDS 
31e1						DMARK "IF1" 
31e1 f5				push af  
31e2 3a f6 31			ld a, (.dmark)  
31e5 32 6e fe			ld (debug_mark),a  
31e8 3a f7 31			ld a, (.dmark+1)  
31eb 32 6f fe			ld (debug_mark+1),a  
31ee 3a f8 31			ld a, (.dmark+2)  
31f1 32 70 fe			ld (debug_mark+2),a  
31f4 18 03			jr .pastdmark  
31f6 ..			.dmark: db "IF1"  
31f9 f1			.pastdmark: pop af  
31fa			endm  
# End of macro DMARK
31fa						CALLMONITOR 
31fa cd f3 18			call break_point_state  
31fd				endm  
# End of macro CALLMONITOR
31fd					endif 
31fd b7				or a        ; clear carry flag 
31fe 11 00 00			ld de, 0 
3201 eb				ex de,hl 
3202 ed 52			sbc hl, de 
3204 c2 8e 32			jp nz, .iftrue 
3207			 
3207					if DEBUG_FORTH_WORDS 
3207						DMARK "IF2" 
3207 f5				push af  
3208 3a 1c 32			ld a, (.dmark)  
320b 32 6e fe			ld (debug_mark),a  
320e 3a 1d 32			ld a, (.dmark+1)  
3211 32 6f fe			ld (debug_mark+1),a  
3214 3a 1e 32			ld a, (.dmark+2)  
3217 32 70 fe			ld (debug_mark+2),a  
321a 18 03			jr .pastdmark  
321c ..			.dmark: db "IF2"  
321f f1			.pastdmark: pop af  
3220			endm  
# End of macro DMARK
3220						CALLMONITOR 
3220 cd f3 18			call break_point_state  
3223				endm  
# End of macro CALLMONITOR
3223					endif 
3223			 
3223			; if not true then skip to THEN 
3223			 
3223				; TODO get tok_ptr 
3223				; TODO consume toks until we get to THEN 
3223			 
3223 2a fd f4			ld hl, (os_tok_ptr) 
3226					if DEBUG_FORTH_WORDS 
3226						DMARK "IF3" 
3226 f5				push af  
3227 3a 3b 32			ld a, (.dmark)  
322a 32 6e fe			ld (debug_mark),a  
322d 3a 3c 32			ld a, (.dmark+1)  
3230 32 6f fe			ld (debug_mark+1),a  
3233 3a 3d 32			ld a, (.dmark+2)  
3236 32 70 fe			ld (debug_mark+2),a  
3239 18 03			jr .pastdmark  
323b ..			.dmark: db "IF3"  
323e f1			.pastdmark: pop af  
323f			endm  
# End of macro DMARK
323f						CALLMONITOR 
323f cd f3 18			call break_point_state  
3242				endm  
# End of macro CALLMONITOR
3242						 
3242					endif 
3242 11 89 32			ld de, .ifthen 
3245					if DEBUG_FORTH_WORDS 
3245						DMARK "IF4" 
3245 f5				push af  
3246 3a 5a 32			ld a, (.dmark)  
3249 32 6e fe			ld (debug_mark),a  
324c 3a 5b 32			ld a, (.dmark+1)  
324f 32 6f fe			ld (debug_mark+1),a  
3252 3a 5c 32			ld a, (.dmark+2)  
3255 32 70 fe			ld (debug_mark+2),a  
3258 18 03			jr .pastdmark  
325a ..			.dmark: db "IF4"  
325d f1			.pastdmark: pop af  
325e			endm  
# End of macro DMARK
325e						CALLMONITOR 
325e cd f3 18			call break_point_state  
3261				endm  
# End of macro CALLMONITOR
3261					endif 
3261 cd f0 23			call findnexttok  
3264			 
3264					if DEBUG_FORTH_WORDS 
3264						DMARK "IF5" 
3264 f5				push af  
3265 3a 79 32			ld a, (.dmark)  
3268 32 6e fe			ld (debug_mark),a  
326b 3a 7a 32			ld a, (.dmark+1)  
326e 32 6f fe			ld (debug_mark+1),a  
3271 3a 7b 32			ld a, (.dmark+2)  
3274 32 70 fe			ld (debug_mark+2),a  
3277 18 03			jr .pastdmark  
3279 ..			.dmark: db "IF5"  
327c f1			.pastdmark: pop af  
327d			endm  
# End of macro DMARK
327d						CALLMONITOR 
327d cd f3 18			call break_point_state  
3280				endm  
# End of macro CALLMONITOR
3280					endif 
3280				; TODO replace below with ; exec using tok_ptr 
3280 22 fd f4			ld (os_tok_ptr), hl 
3283 c3 66 23			jp exec1 
3286				NEXTW 
3286 c3 d5 22			jp macro_next 
3289				endm 
# End of macro NEXTW
3289			 
3289 .. 00		.ifthen:  db "THEN",0 
328e			 
328e			.iftrue:		 
328e				; Exec next words normally 
328e			 
328e				; if true then exec following IF as normal 
328e					if DEBUG_FORTH_WORDS 
328e						DMARK "IFT" 
328e f5				push af  
328f 3a a3 32			ld a, (.dmark)  
3292 32 6e fe			ld (debug_mark),a  
3295 3a a4 32			ld a, (.dmark+1)  
3298 32 6f fe			ld (debug_mark+1),a  
329b 3a a5 32			ld a, (.dmark+2)  
329e 32 70 fe			ld (debug_mark+2),a  
32a1 18 03			jr .pastdmark  
32a3 ..			.dmark: db "IFT"  
32a6 f1			.pastdmark: pop af  
32a7			endm  
# End of macro DMARK
32a7						CALLMONITOR 
32a7 cd f3 18			call break_point_state  
32aa				endm  
# End of macro CALLMONITOR
32aa					endif 
32aa			 
32aa					NEXTW 
32aa c3 d5 22			jp macro_next 
32ad				endm 
# End of macro NEXTW
32ad			.THEN: 
32ad				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32ad 1f				db WORD_SYS_CORE+11             
32ae d5 32			dw .ELSE            
32b0 05				db 4 + 1 
32b1 .. 00			db "THEN",0              
32b6				endm 
# End of macro CWHEAD
32b6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32b6					if DEBUG_FORTH_WORDS_KEY 
32b6						DMARK "THN" 
32b6 f5				push af  
32b7 3a cb 32			ld a, (.dmark)  
32ba 32 6e fe			ld (debug_mark),a  
32bd 3a cc 32			ld a, (.dmark+1)  
32c0 32 6f fe			ld (debug_mark+1),a  
32c3 3a cd 32			ld a, (.dmark+2)  
32c6 32 70 fe			ld (debug_mark+2),a  
32c9 18 03			jr .pastdmark  
32cb ..			.dmark: db "THN"  
32ce f1			.pastdmark: pop af  
32cf			endm  
# End of macro DMARK
32cf						CALLMONITOR 
32cf cd f3 18			call break_point_state  
32d2				endm  
# End of macro CALLMONITOR
32d2					endif 
32d2					NEXTW 
32d2 c3 d5 22			jp macro_next 
32d5				endm 
# End of macro NEXTW
32d5			.ELSE: 
32d5				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32d5 20				db WORD_SYS_CORE+12             
32d6 fd 32			dw .DO            
32d8 03				db 2 + 1 
32d9 .. 00			db "ELSE",0              
32de				endm 
# End of macro CWHEAD
32de			; | ELSE ( -- ) Not supported - does nothing | TODO 
32de			 
32de					if DEBUG_FORTH_WORDS_KEY 
32de						DMARK "ELS" 
32de f5				push af  
32df 3a f3 32			ld a, (.dmark)  
32e2 32 6e fe			ld (debug_mark),a  
32e5 3a f4 32			ld a, (.dmark+1)  
32e8 32 6f fe			ld (debug_mark+1),a  
32eb 3a f5 32			ld a, (.dmark+2)  
32ee 32 70 fe			ld (debug_mark+2),a  
32f1 18 03			jr .pastdmark  
32f3 ..			.dmark: db "ELS"  
32f6 f1			.pastdmark: pop af  
32f7			endm  
# End of macro DMARK
32f7						CALLMONITOR 
32f7 cd f3 18			call break_point_state  
32fa				endm  
# End of macro CALLMONITOR
32fa					endif 
32fa			 
32fa			 
32fa					NEXTW 
32fa c3 d5 22			jp macro_next 
32fd				endm 
# End of macro NEXTW
32fd			.DO: 
32fd				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
32fd 21				db WORD_SYS_CORE+13             
32fe 24 34			dw .LOOP            
3300 03				db 2 + 1 
3301 .. 00			db "DO",0              
3304				endm 
# End of macro CWHEAD
3304			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3304			 
3304					if DEBUG_FORTH_WORDS_KEY 
3304						DMARK "DO." 
3304 f5				push af  
3305 3a 19 33			ld a, (.dmark)  
3308 32 6e fe			ld (debug_mark),a  
330b 3a 1a 33			ld a, (.dmark+1)  
330e 32 6f fe			ld (debug_mark+1),a  
3311 3a 1b 33			ld a, (.dmark+2)  
3314 32 70 fe			ld (debug_mark+2),a  
3317 18 03			jr .pastdmark  
3319 ..			.dmark: db "DO."  
331c f1			.pastdmark: pop af  
331d			endm  
# End of macro DMARK
331d						CALLMONITOR 
331d cd f3 18			call break_point_state  
3320				endm  
# End of macro CALLMONITOR
3320					endif 
3320			;  push pc to rsp stack past the DO 
3320			 
3320 2a fd f4				ld hl, (os_tok_ptr) 
3323 23					inc hl   ; D 
3324 23					inc hl  ; O 
3325 23					inc hl   ; null 
3326					if DEBUG_FORTH_WORDS 
3326						DMARK "DO2" 
3326 f5				push af  
3327 3a 3b 33			ld a, (.dmark)  
332a 32 6e fe			ld (debug_mark),a  
332d 3a 3c 33			ld a, (.dmark+1)  
3330 32 6f fe			ld (debug_mark+1),a  
3333 3a 3d 33			ld a, (.dmark+2)  
3336 32 70 fe			ld (debug_mark+2),a  
3339 18 03			jr .pastdmark  
333b ..			.dmark: db "DO2"  
333e f1			.pastdmark: pop af  
333f			endm  
# End of macro DMARK
333f						CALLMONITOR 
333f cd f3 18			call break_point_state  
3342				endm  
# End of macro CALLMONITOR
3342					endif 
3342					FORTH_RSP_NEXT 
3342 cd 0e 1f			call macro_forth_rsp_next 
3345				endm 
# End of macro FORTH_RSP_NEXT
3345					if DEBUG_FORTH_WORDS 
3345						DMARK "DO3" 
3345 f5				push af  
3346 3a 5a 33			ld a, (.dmark)  
3349 32 6e fe			ld (debug_mark),a  
334c 3a 5b 33			ld a, (.dmark+1)  
334f 32 6f fe			ld (debug_mark+1),a  
3352 3a 5c 33			ld a, (.dmark+2)  
3355 32 70 fe			ld (debug_mark+2),a  
3358 18 03			jr .pastdmark  
335a ..			.dmark: db "DO3"  
335d f1			.pastdmark: pop af  
335e			endm  
# End of macro DMARK
335e						CALLMONITOR 
335e cd f3 18			call break_point_state  
3361				endm  
# End of macro CALLMONITOR
3361					endif 
3361			 
3361					;if DEBUG_FORTH_WORDS 
3361				;		push hl 
3361			;		endif  
3361			 
3361			; get counters from data stack 
3361			 
3361			 
3361					FORTH_DSP_VALUEHL 
3361 cd 5e 21			call macro_dsp_valuehl 
3364				endm 
# End of macro FORTH_DSP_VALUEHL
3364 e5					push hl		 ; hl now has starting counter which needs to be tos 
3365			 
3365					if DEBUG_FORTH_WORDS 
3365						DMARK "DO4" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 6e fe			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 6f fe			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 70 fe			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "DO4"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd f3 18			call break_point_state  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381					FORTH_DSP_POP 
3381 cd 16 22			call macro_forth_dsp_pop 
3384				endm 
# End of macro FORTH_DSP_POP
3384			 
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "DO5" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 6e fe			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 6f fe			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 70 fe			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "DO5"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd f3 18			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0			 
33a0					FORTH_DSP_VALUEHL 
33a0 cd 5e 21			call macro_dsp_valuehl 
33a3				endm 
# End of macro FORTH_DSP_VALUEHL
33a3			;		push hl		 ; hl now has starting limit counter 
33a3			 
33a3					if DEBUG_FORTH_WORDS 
33a3						DMARK "DO6" 
33a3 f5				push af  
33a4 3a b8 33			ld a, (.dmark)  
33a7 32 6e fe			ld (debug_mark),a  
33aa 3a b9 33			ld a, (.dmark+1)  
33ad 32 6f fe			ld (debug_mark+1),a  
33b0 3a ba 33			ld a, (.dmark+2)  
33b3 32 70 fe			ld (debug_mark+2),a  
33b6 18 03			jr .pastdmark  
33b8 ..			.dmark: db "DO6"  
33bb f1			.pastdmark: pop af  
33bc			endm  
# End of macro DMARK
33bc						CALLMONITOR 
33bc cd f3 18			call break_point_state  
33bf				endm  
# End of macro CALLMONITOR
33bf					endif 
33bf					FORTH_DSP_POP 
33bf cd 16 22			call macro_forth_dsp_pop 
33c2				endm 
# End of macro FORTH_DSP_POP
33c2			 
33c2			; put counters on the loop stack 
33c2			 
33c2			;		pop hl			 ; limit counter 
33c2 d1					pop de			; start counter 
33c3			 
33c3					; push limit counter 
33c3			 
33c3					if DEBUG_FORTH_WORDS 
33c3						DMARK "DO7" 
33c3 f5				push af  
33c4 3a d8 33			ld a, (.dmark)  
33c7 32 6e fe			ld (debug_mark),a  
33ca 3a d9 33			ld a, (.dmark+1)  
33cd 32 6f fe			ld (debug_mark+1),a  
33d0 3a da 33			ld a, (.dmark+2)  
33d3 32 70 fe			ld (debug_mark+2),a  
33d6 18 03			jr .pastdmark  
33d8 ..			.dmark: db "DO7"  
33db f1			.pastdmark: pop af  
33dc			endm  
# End of macro DMARK
33dc						CALLMONITOR 
33dc cd f3 18			call break_point_state  
33df				endm  
# End of macro CALLMONITOR
33df					endif 
33df					FORTH_LOOP_NEXT 
33df cd 8f 21			call macro_forth_loop_next 
33e2				endm 
# End of macro FORTH_LOOP_NEXT
33e2			 
33e2					; push start counter 
33e2			 
33e2 eb					ex de, hl 
33e3					if DEBUG_FORTH_WORDS 
33e3						DMARK "DO7" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 6e fe			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 6f fe			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 70 fe			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "DO7"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd f3 18			call break_point_state  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff					FORTH_LOOP_NEXT 
33ff cd 8f 21			call macro_forth_loop_next 
3402				endm 
# End of macro FORTH_LOOP_NEXT
3402			 
3402			 
3402					; init first round of I counter 
3402			 
3402 22 21 f5				ld (os_current_i), hl 
3405			 
3405					if DEBUG_FORTH_WORDS 
3405						DMARK "DO8" 
3405 f5				push af  
3406 3a 1a 34			ld a, (.dmark)  
3409 32 6e fe			ld (debug_mark),a  
340c 3a 1b 34			ld a, (.dmark+1)  
340f 32 6f fe			ld (debug_mark+1),a  
3412 3a 1c 34			ld a, (.dmark+2)  
3415 32 70 fe			ld (debug_mark+2),a  
3418 18 03			jr .pastdmark  
341a ..			.dmark: db "DO8"  
341d f1			.pastdmark: pop af  
341e			endm  
# End of macro DMARK
341e						CALLMONITOR 
341e cd f3 18			call break_point_state  
3421				endm  
# End of macro CALLMONITOR
3421					endif 
3421			 
3421					NEXTW 
3421 c3 d5 22			jp macro_next 
3424				endm 
# End of macro NEXTW
3424			.LOOP: 
3424				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3424 22				db WORD_SYS_CORE+14             
3425 3c 35			dw .I            
3427 05				db 4 + 1 
3428 .. 00			db "LOOP",0              
342d				endm 
# End of macro CWHEAD
342d			; | LOOP ( -- ) Increment and test loop counter  | DONE 
342d			 
342d				; pop tos as current loop count to hl 
342d			 
342d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
342d			 
342d				FORTH_LOOP_TOS 
342d cd c2 21			call macro_forth_loop_tos 
3430				endm 
# End of macro FORTH_LOOP_TOS
3430 e5				push hl 
3431			 
3431					if DEBUG_FORTH_WORDS_KEY 
3431						DMARK "LOP" 
3431 f5				push af  
3432 3a 46 34			ld a, (.dmark)  
3435 32 6e fe			ld (debug_mark),a  
3438 3a 47 34			ld a, (.dmark+1)  
343b 32 6f fe			ld (debug_mark+1),a  
343e 3a 48 34			ld a, (.dmark+2)  
3441 32 70 fe			ld (debug_mark+2),a  
3444 18 03			jr .pastdmark  
3446 ..			.dmark: db "LOP"  
3449 f1			.pastdmark: pop af  
344a			endm  
# End of macro DMARK
344a						CALLMONITOR 
344a cd f3 18			call break_point_state  
344d				endm  
# End of macro CALLMONITOR
344d					endif 
344d				; next item on the stack is the limit. get it 
344d			 
344d			 
344d				FORTH_LOOP_POP 
344d cd cc 21			call macro_forth_loop_pop 
3450				endm 
# End of macro FORTH_LOOP_POP
3450			 
3450				FORTH_LOOP_TOS 
3450 cd c2 21			call macro_forth_loop_tos 
3453				endm 
# End of macro FORTH_LOOP_TOS
3453			 
3453 d1				pop de		 ; de = i, hl = limit 
3454			 
3454					if DEBUG_FORTH_WORDS 
3454						DMARK "LP1" 
3454 f5				push af  
3455 3a 69 34			ld a, (.dmark)  
3458 32 6e fe			ld (debug_mark),a  
345b 3a 6a 34			ld a, (.dmark+1)  
345e 32 6f fe			ld (debug_mark+1),a  
3461 3a 6b 34			ld a, (.dmark+2)  
3464 32 70 fe			ld (debug_mark+2),a  
3467 18 03			jr .pastdmark  
3469 ..			.dmark: db "LP1"  
346c f1			.pastdmark: pop af  
346d			endm  
# End of macro DMARK
346d						CALLMONITOR 
346d cd f3 18			call break_point_state  
3470				endm  
# End of macro CALLMONITOR
3470					endif 
3470			 
3470				; go back to previous word 
3470			 
3470 d5				push de    ; save I for inc later 
3471			 
3471			 
3471				; get limit 
3471				;  is I at limit? 
3471			 
3471			 
3471					if DEBUG_FORTH_WORDS 
3471						DMARK "LP1" 
3471 f5				push af  
3472 3a 86 34			ld a, (.dmark)  
3475 32 6e fe			ld (debug_mark),a  
3478 3a 87 34			ld a, (.dmark+1)  
347b 32 6f fe			ld (debug_mark+1),a  
347e 3a 88 34			ld a, (.dmark+2)  
3481 32 70 fe			ld (debug_mark+2),a  
3484 18 03			jr .pastdmark  
3486 ..			.dmark: db "LP1"  
3489 f1			.pastdmark: pop af  
348a			endm  
# End of macro DMARK
348a						CALLMONITOR 
348a cd f3 18			call break_point_state  
348d				endm  
# End of macro CALLMONITOR
348d					endif 
348d			 
348d ed 52			sbc hl, de 
348f			 
348f			 
348f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
348f			 
348f 20 26				jr nz, .loopnotdone 
3491			 
3491 e1				pop hl   ; get rid of saved I 
3492				FORTH_LOOP_POP     ; get rid of limit 
3492 cd cc 21			call macro_forth_loop_pop 
3495				endm 
# End of macro FORTH_LOOP_POP
3495			 
3495				FORTH_RSP_POP     ; get rid of DO ptr 
3495 cd 2f 1f			call macro_forth_rsp_pop 
3498				endm 
# End of macro FORTH_RSP_POP
3498			 
3498			if DEBUG_FORTH_WORDS 
3498						DMARK "LP>" 
3498 f5				push af  
3499 3a ad 34			ld a, (.dmark)  
349c 32 6e fe			ld (debug_mark),a  
349f 3a ae 34			ld a, (.dmark+1)  
34a2 32 6f fe			ld (debug_mark+1),a  
34a5 3a af 34			ld a, (.dmark+2)  
34a8 32 70 fe			ld (debug_mark+2),a  
34ab 18 03			jr .pastdmark  
34ad ..			.dmark: db "LP>"  
34b0 f1			.pastdmark: pop af  
34b1			endm  
# End of macro DMARK
34b1				CALLMONITOR 
34b1 cd f3 18			call break_point_state  
34b4				endm  
# End of macro CALLMONITOR
34b4			endif 
34b4			 
34b4					NEXTW 
34b4 c3 d5 22			jp macro_next 
34b7				endm 
# End of macro NEXTW
34b7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34b7			 
34b7			.loopnotdone: 
34b7			 
34b7 e1				pop hl    ; get I 
34b8 23				inc hl 
34b9			 
34b9			   	; save new I 
34b9			 
34b9			 
34b9					; set I counter 
34b9			 
34b9 22 21 f5				ld (os_current_i), hl 
34bc			 
34bc					if DEBUG_FORTH_WORDS 
34bc						DMARK "LPN" 
34bc f5				push af  
34bd 3a d1 34			ld a, (.dmark)  
34c0 32 6e fe			ld (debug_mark),a  
34c3 3a d2 34			ld a, (.dmark+1)  
34c6 32 6f fe			ld (debug_mark+1),a  
34c9 3a d3 34			ld a, (.dmark+2)  
34cc 32 70 fe			ld (debug_mark+2),a  
34cf 18 03			jr .pastdmark  
34d1 ..			.dmark: db "LPN"  
34d4 f1			.pastdmark: pop af  
34d5			endm  
# End of macro DMARK
34d5					CALLMONITOR 
34d5 cd f3 18			call break_point_state  
34d8				endm  
# End of macro CALLMONITOR
34d8					endif 
34d8					 
34d8				FORTH_LOOP_NEXT 
34d8 cd 8f 21			call macro_forth_loop_next 
34db				endm 
# End of macro FORTH_LOOP_NEXT
34db			 
34db			 
34db					if DEBUG_FORTH_WORDS 
34db eb						ex de,hl 
34dc					endif 
34dc			 
34dc			;	; get DO ptr 
34dc			; 
34dc					if DEBUG_FORTH_WORDS 
34dc						DMARK "LP7" 
34dc f5				push af  
34dd 3a f1 34			ld a, (.dmark)  
34e0 32 6e fe			ld (debug_mark),a  
34e3 3a f2 34			ld a, (.dmark+1)  
34e6 32 6f fe			ld (debug_mark+1),a  
34e9 3a f3 34			ld a, (.dmark+2)  
34ec 32 70 fe			ld (debug_mark+2),a  
34ef 18 03			jr .pastdmark  
34f1 ..			.dmark: db "LP7"  
34f4 f1			.pastdmark: pop af  
34f5			endm  
# End of macro DMARK
34f5					CALLMONITOR 
34f5 cd f3 18			call break_point_state  
34f8				endm  
# End of macro CALLMONITOR
34f8					endif 
34f8				FORTH_RSP_TOS 
34f8 cd 25 1f			call macro_forth_rsp_tos 
34fb				endm 
# End of macro FORTH_RSP_TOS
34fb			 
34fb					if DEBUG_FORTH_WORDS 
34fb						DMARK "LP8" 
34fb f5				push af  
34fc 3a 10 35			ld a, (.dmark)  
34ff 32 6e fe			ld (debug_mark),a  
3502 3a 11 35			ld a, (.dmark+1)  
3505 32 6f fe			ld (debug_mark+1),a  
3508 3a 12 35			ld a, (.dmark+2)  
350b 32 70 fe			ld (debug_mark+2),a  
350e 18 03			jr .pastdmark  
3510 ..			.dmark: db "LP8"  
3513 f1			.pastdmark: pop af  
3514			endm  
# End of macro DMARK
3514					CALLMONITOR 
3514 cd f3 18			call break_point_state  
3517				endm  
# End of macro CALLMONITOR
3517					endif 
3517				;push hl 
3517			 
3517				; not going to DO any more 
3517				; get rid of the RSP pointer as DO will add it back in 
3517				;FORTH_RSP_POP 
3517				;pop hl 
3517			 
3517				;ld hl,(cli_ret_sp) 
3517				;ld e, (hl) 
3517				;inc hl 
3517				;ld d, (hl) 
3517				;ex de,hl 
3517 22 fd f4			ld (os_tok_ptr), hl 
351a					if DEBUG_FORTH_WORDS 
351a						DMARK "LP<" 
351a f5				push af  
351b 3a 2f 35			ld a, (.dmark)  
351e 32 6e fe			ld (debug_mark),a  
3521 3a 30 35			ld a, (.dmark+1)  
3524 32 6f fe			ld (debug_mark+1),a  
3527 3a 31 35			ld a, (.dmark+2)  
352a 32 70 fe			ld (debug_mark+2),a  
352d 18 03			jr .pastdmark  
352f ..			.dmark: db "LP<"  
3532 f1			.pastdmark: pop af  
3533			endm  
# End of macro DMARK
3533					CALLMONITOR 
3533 cd f3 18			call break_point_state  
3536				endm  
# End of macro CALLMONITOR
3536				endif 
3536 c3 66 23			jp exec1 
3539			 
3539					 
3539			 
3539			 
3539					NEXTW 
3539 c3 d5 22			jp macro_next 
353c				endm 
# End of macro NEXTW
353c			.I:  
353c			 
353c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
353c 5e				db WORD_SYS_CORE+74             
353d 67 35			dw .DLOOP            
353f 02				db 1 + 1 
3540 .. 00			db "I",0              
3542				endm 
# End of macro CWHEAD
3542			; | I ( -- ) Current loop counter | DONE 
3542					if DEBUG_FORTH_WORDS_KEY 
3542						DMARK "I.." 
3542 f5				push af  
3543 3a 57 35			ld a, (.dmark)  
3546 32 6e fe			ld (debug_mark),a  
3549 3a 58 35			ld a, (.dmark+1)  
354c 32 6f fe			ld (debug_mark+1),a  
354f 3a 59 35			ld a, (.dmark+2)  
3552 32 70 fe			ld (debug_mark+2),a  
3555 18 03			jr .pastdmark  
3557 ..			.dmark: db "I.."  
355a f1			.pastdmark: pop af  
355b			endm  
# End of macro DMARK
355b						CALLMONITOR 
355b cd f3 18			call break_point_state  
355e				endm  
# End of macro CALLMONITOR
355e					endif 
355e			 
355e 2a 21 f5				ld hl,(os_current_i) 
3561 cd 67 1f				call forth_push_numhl 
3564			 
3564					NEXTW 
3564 c3 d5 22			jp macro_next 
3567				endm 
# End of macro NEXTW
3567			.DLOOP: 
3567				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3567 5f				db WORD_SYS_CORE+75             
3568 48 36			dw .REPEAT            
356a 06				db 5 + 1 
356b .. 00			db "-LOOP",0              
3571				endm 
# End of macro CWHEAD
3571			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3571				; pop tos as current loop count to hl 
3571					if DEBUG_FORTH_WORDS_KEY 
3571						DMARK "-LP" 
3571 f5				push af  
3572 3a 86 35			ld a, (.dmark)  
3575 32 6e fe			ld (debug_mark),a  
3578 3a 87 35			ld a, (.dmark+1)  
357b 32 6f fe			ld (debug_mark+1),a  
357e 3a 88 35			ld a, (.dmark+2)  
3581 32 70 fe			ld (debug_mark+2),a  
3584 18 03			jr .pastdmark  
3586 ..			.dmark: db "-LP"  
3589 f1			.pastdmark: pop af  
358a			endm  
# End of macro DMARK
358a						CALLMONITOR 
358a cd f3 18			call break_point_state  
358d				endm  
# End of macro CALLMONITOR
358d					endif 
358d			 
358d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
358d			 
358d				FORTH_LOOP_TOS 
358d cd c2 21			call macro_forth_loop_tos 
3590				endm 
# End of macro FORTH_LOOP_TOS
3590 e5				push hl 
3591			 
3591					if DEBUG_FORTH_WORDS 
3591						DMARK "-LP" 
3591 f5				push af  
3592 3a a6 35			ld a, (.dmark)  
3595 32 6e fe			ld (debug_mark),a  
3598 3a a7 35			ld a, (.dmark+1)  
359b 32 6f fe			ld (debug_mark+1),a  
359e 3a a8 35			ld a, (.dmark+2)  
35a1 32 70 fe			ld (debug_mark+2),a  
35a4 18 03			jr .pastdmark  
35a6 ..			.dmark: db "-LP"  
35a9 f1			.pastdmark: pop af  
35aa			endm  
# End of macro DMARK
35aa						CALLMONITOR 
35aa cd f3 18			call break_point_state  
35ad				endm  
# End of macro CALLMONITOR
35ad					endif 
35ad				; next item on the stack is the limit. get it 
35ad			 
35ad			 
35ad				FORTH_LOOP_POP 
35ad cd cc 21			call macro_forth_loop_pop 
35b0				endm 
# End of macro FORTH_LOOP_POP
35b0			 
35b0				FORTH_LOOP_TOS 
35b0 cd c2 21			call macro_forth_loop_tos 
35b3				endm 
# End of macro FORTH_LOOP_TOS
35b3			 
35b3 d1				pop de		 ; de = i, hl = limit 
35b4			 
35b4					if DEBUG_FORTH_WORDS 
35b4						DMARK "-L1" 
35b4 f5				push af  
35b5 3a c9 35			ld a, (.dmark)  
35b8 32 6e fe			ld (debug_mark),a  
35bb 3a ca 35			ld a, (.dmark+1)  
35be 32 6f fe			ld (debug_mark+1),a  
35c1 3a cb 35			ld a, (.dmark+2)  
35c4 32 70 fe			ld (debug_mark+2),a  
35c7 18 03			jr .pastdmark  
35c9 ..			.dmark: db "-L1"  
35cc f1			.pastdmark: pop af  
35cd			endm  
# End of macro DMARK
35cd						CALLMONITOR 
35cd cd f3 18			call break_point_state  
35d0				endm  
# End of macro CALLMONITOR
35d0					endif 
35d0			 
35d0				; go back to previous word 
35d0			 
35d0 d5				push de    ; save I for inc later 
35d1			 
35d1			 
35d1				; get limit 
35d1				;  is I at limit? 
35d1			 
35d1			 
35d1					if DEBUG_FORTH_WORDS 
35d1						DMARK "-L1" 
35d1 f5				push af  
35d2 3a e6 35			ld a, (.dmark)  
35d5 32 6e fe			ld (debug_mark),a  
35d8 3a e7 35			ld a, (.dmark+1)  
35db 32 6f fe			ld (debug_mark+1),a  
35de 3a e8 35			ld a, (.dmark+2)  
35e1 32 70 fe			ld (debug_mark+2),a  
35e4 18 03			jr .pastdmark  
35e6 ..			.dmark: db "-L1"  
35e9 f1			.pastdmark: pop af  
35ea			endm  
# End of macro DMARK
35ea						CALLMONITOR 
35ea cd f3 18			call break_point_state  
35ed				endm  
# End of macro CALLMONITOR
35ed					endif 
35ed			 
35ed ed 52			sbc hl, de 
35ef			 
35ef			 
35ef				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35ef			 
35ef 20 26				jr nz, .mloopnotdone 
35f1			 
35f1 e1				pop hl   ; get rid of saved I 
35f2				FORTH_LOOP_POP     ; get rid of limit 
35f2 cd cc 21			call macro_forth_loop_pop 
35f5				endm 
# End of macro FORTH_LOOP_POP
35f5			 
35f5				FORTH_RSP_POP     ; get rid of DO ptr 
35f5 cd 2f 1f			call macro_forth_rsp_pop 
35f8				endm 
# End of macro FORTH_RSP_POP
35f8			 
35f8			if DEBUG_FORTH_WORDS 
35f8						DMARK "-L>" 
35f8 f5				push af  
35f9 3a 0d 36			ld a, (.dmark)  
35fc 32 6e fe			ld (debug_mark),a  
35ff 3a 0e 36			ld a, (.dmark+1)  
3602 32 6f fe			ld (debug_mark+1),a  
3605 3a 0f 36			ld a, (.dmark+2)  
3608 32 70 fe			ld (debug_mark+2),a  
360b 18 03			jr .pastdmark  
360d ..			.dmark: db "-L>"  
3610 f1			.pastdmark: pop af  
3611			endm  
# End of macro DMARK
3611				CALLMONITOR 
3611 cd f3 18			call break_point_state  
3614				endm  
# End of macro CALLMONITOR
3614			endif 
3614			 
3614					NEXTW 
3614 c3 d5 22			jp macro_next 
3617				endm 
# End of macro NEXTW
3617				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3617			 
3617			.mloopnotdone: 
3617			 
3617 e1				pop hl    ; get I 
3618 2b				dec hl 
3619			 
3619			   	; save new I 
3619			 
3619			 
3619					; set I counter 
3619			 
3619 22 21 f5				ld (os_current_i), hl 
361c			 
361c					 
361c				FORTH_LOOP_NEXT 
361c cd 8f 21			call macro_forth_loop_next 
361f				endm 
# End of macro FORTH_LOOP_NEXT
361f			 
361f			 
361f					if DEBUG_FORTH_WORDS 
361f eb						ex de,hl 
3620					endif 
3620			 
3620			;	; get DO ptr 
3620			; 
3620				FORTH_RSP_TOS 
3620 cd 25 1f			call macro_forth_rsp_tos 
3623				endm 
# End of macro FORTH_RSP_TOS
3623			 
3623				;push hl 
3623			 
3623				; not going to DO any more 
3623				; get rid of the RSP pointer as DO will add it back in 
3623				;FORTH_RSP_POP 
3623				;pop hl 
3623			 
3623			 
3623 22 fd f4			ld (os_tok_ptr), hl 
3626					if DEBUG_FORTH_WORDS 
3626						DMARK "-L<" 
3626 f5				push af  
3627 3a 3b 36			ld a, (.dmark)  
362a 32 6e fe			ld (debug_mark),a  
362d 3a 3c 36			ld a, (.dmark+1)  
3630 32 6f fe			ld (debug_mark+1),a  
3633 3a 3d 36			ld a, (.dmark+2)  
3636 32 70 fe			ld (debug_mark+2),a  
3639 18 03			jr .pastdmark  
363b ..			.dmark: db "-L<"  
363e f1			.pastdmark: pop af  
363f			endm  
# End of macro DMARK
363f					CALLMONITOR 
363f cd f3 18			call break_point_state  
3642				endm  
# End of macro CALLMONITOR
3642				endif 
3642 c3 66 23			jp exec1 
3645			 
3645					 
3645			 
3645			 
3645			 
3645				NEXTW 
3645 c3 d5 22			jp macro_next 
3648				endm 
# End of macro NEXTW
3648			 
3648			 
3648			 
3648			 
3648			.REPEAT: 
3648				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3648 71				db WORD_SYS_CORE+93             
3649 9b 36			dw .UNTIL            
364b 06				db 5 + 1 
364c .. 00			db "REPEAT",0              
3653				endm 
# End of macro CWHEAD
3653			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3653			;  push pc to rsp stack past the REPEAT 
3653					if DEBUG_FORTH_WORDS_KEY 
3653						DMARK "REP" 
3653 f5				push af  
3654 3a 68 36			ld a, (.dmark)  
3657 32 6e fe			ld (debug_mark),a  
365a 3a 69 36			ld a, (.dmark+1)  
365d 32 6f fe			ld (debug_mark+1),a  
3660 3a 6a 36			ld a, (.dmark+2)  
3663 32 70 fe			ld (debug_mark+2),a  
3666 18 03			jr .pastdmark  
3668 ..			.dmark: db "REP"  
366b f1			.pastdmark: pop af  
366c			endm  
# End of macro DMARK
366c						CALLMONITOR 
366c cd f3 18			call break_point_state  
366f				endm  
# End of macro CALLMONITOR
366f					endif 
366f			 
366f 2a fd f4				ld hl, (os_tok_ptr) 
3672 23					inc hl   ; R 
3673 23					inc hl  ; E 
3674 23					inc hl   ; P 
3675 23					inc hl   ; E 
3676 23					inc hl   ; A 
3677 23					inc hl   ; T 
3678 23					inc hl   ; zero 
3679					FORTH_RSP_NEXT 
3679 cd 0e 1f			call macro_forth_rsp_next 
367c				endm 
# End of macro FORTH_RSP_NEXT
367c			 
367c			 
367c					if DEBUG_FORTH_WORDS 
367c						DMARK "REP" 
367c f5				push af  
367d 3a 91 36			ld a, (.dmark)  
3680 32 6e fe			ld (debug_mark),a  
3683 3a 92 36			ld a, (.dmark+1)  
3686 32 6f fe			ld (debug_mark+1),a  
3689 3a 93 36			ld a, (.dmark+2)  
368c 32 70 fe			ld (debug_mark+2),a  
368f 18 03			jr .pastdmark  
3691 ..			.dmark: db "REP"  
3694 f1			.pastdmark: pop af  
3695			endm  
# End of macro DMARK
3695						;pop bc    ; TODO BUG ?????? what is this for???? 
3695						CALLMONITOR 
3695 cd f3 18			call break_point_state  
3698				endm  
# End of macro CALLMONITOR
3698					endif 
3698			 
3698					NEXTW 
3698 c3 d5 22			jp macro_next 
369b				endm 
# End of macro NEXTW
369b			;	       NEXTW 
369b			 
369b			.UNTIL: 
369b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
369b 72				db WORD_SYS_CORE+94             
369c 32 37			dw .ENDFLOW            
369e 06				db 5 + 1 
369f .. 00			db "UNTIL",0              
36a5				endm 
# End of macro CWHEAD
36a5			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36a5			 
36a5				; pop tos as check 
36a5			 
36a5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36a5			 
36a5				FORTH_DSP_VALUEHL 
36a5 cd 5e 21			call macro_dsp_valuehl 
36a8				endm 
# End of macro FORTH_DSP_VALUEHL
36a8			 
36a8					if DEBUG_FORTH_WORDS_KEY 
36a8						DMARK "UNT" 
36a8 f5				push af  
36a9 3a bd 36			ld a, (.dmark)  
36ac 32 6e fe			ld (debug_mark),a  
36af 3a be 36			ld a, (.dmark+1)  
36b2 32 6f fe			ld (debug_mark+1),a  
36b5 3a bf 36			ld a, (.dmark+2)  
36b8 32 70 fe			ld (debug_mark+2),a  
36bb 18 03			jr .pastdmark  
36bd ..			.dmark: db "UNT"  
36c0 f1			.pastdmark: pop af  
36c1			endm  
# End of macro DMARK
36c1						CALLMONITOR 
36c1 cd f3 18			call break_point_state  
36c4				endm  
# End of macro CALLMONITOR
36c4					endif 
36c4			 
36c4			;	push hl 
36c4				FORTH_DSP_POP 
36c4 cd 16 22			call macro_forth_dsp_pop 
36c7				endm 
# End of macro FORTH_DSP_POP
36c7			 
36c7			;	pop hl 
36c7			 
36c7				; test if true 
36c7			 
36c7 cd 75 0f			call ishlzero 
36ca			;	ld a,l 
36ca			;	add h 
36ca			; 
36ca			;	cp 0 
36ca			 
36ca 20 3e			jr nz, .untilnotdone 
36cc			 
36cc					if DEBUG_FORTH_WORDS 
36cc						DMARK "UNf" 
36cc f5				push af  
36cd 3a e1 36			ld a, (.dmark)  
36d0 32 6e fe			ld (debug_mark),a  
36d3 3a e2 36			ld a, (.dmark+1)  
36d6 32 6f fe			ld (debug_mark+1),a  
36d9 3a e3 36			ld a, (.dmark+2)  
36dc 32 70 fe			ld (debug_mark+2),a  
36df 18 03			jr .pastdmark  
36e1 ..			.dmark: db "UNf"  
36e4 f1			.pastdmark: pop af  
36e5			endm  
# End of macro DMARK
36e5						CALLMONITOR 
36e5 cd f3 18			call break_point_state  
36e8				endm  
# End of macro CALLMONITOR
36e8					endif 
36e8			 
36e8			 
36e8			 
36e8				FORTH_RSP_POP     ; get rid of DO ptr 
36e8 cd 2f 1f			call macro_forth_rsp_pop 
36eb				endm 
# End of macro FORTH_RSP_POP
36eb			 
36eb			if DEBUG_FORTH_WORDS 
36eb						DMARK "UN>" 
36eb f5				push af  
36ec 3a 00 37			ld a, (.dmark)  
36ef 32 6e fe			ld (debug_mark),a  
36f2 3a 01 37			ld a, (.dmark+1)  
36f5 32 6f fe			ld (debug_mark+1),a  
36f8 3a 02 37			ld a, (.dmark+2)  
36fb 32 70 fe			ld (debug_mark+2),a  
36fe 18 03			jr .pastdmark  
3700 ..			.dmark: db "UN>"  
3703 f1			.pastdmark: pop af  
3704			endm  
# End of macro DMARK
3704				CALLMONITOR 
3704 cd f3 18			call break_point_state  
3707				endm  
# End of macro CALLMONITOR
3707			endif 
3707			 
3707					NEXTW 
3707 c3 d5 22			jp macro_next 
370a				endm 
# End of macro NEXTW
370a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
370a			 
370a			.untilnotdone: 
370a			 
370a			 
370a			;	; get DO ptr 
370a			; 
370a				FORTH_RSP_TOS 
370a cd 25 1f			call macro_forth_rsp_tos 
370d				endm 
# End of macro FORTH_RSP_TOS
370d			 
370d				;push hl 
370d			 
370d				; not going to DO any more 
370d				; get rid of the RSP pointer as DO will add it back in 
370d				;FORTH_RSP_POP 
370d				;pop hl 
370d			 
370d			 
370d 22 fd f4			ld (os_tok_ptr), hl 
3710					if DEBUG_FORTH_WORDS 
3710						DMARK "UN<" 
3710 f5				push af  
3711 3a 25 37			ld a, (.dmark)  
3714 32 6e fe			ld (debug_mark),a  
3717 3a 26 37			ld a, (.dmark+1)  
371a 32 6f fe			ld (debug_mark+1),a  
371d 3a 27 37			ld a, (.dmark+2)  
3720 32 70 fe			ld (debug_mark+2),a  
3723 18 03			jr .pastdmark  
3725 ..			.dmark: db "UN<"  
3728 f1			.pastdmark: pop af  
3729			endm  
# End of macro DMARK
3729					CALLMONITOR 
3729 cd f3 18			call break_point_state  
372c				endm  
# End of macro CALLMONITOR
372c				endif 
372c c3 66 23			jp exec1 
372f			 
372f					 
372f			 
372f			 
372f					NEXTW 
372f c3 d5 22			jp macro_next 
3732				endm 
# End of macro NEXTW
3732			 
3732			 
3732			.ENDFLOW: 
3732			 
3732			; eof 
3732			 
# End of file forth_words_flow.asm
3732			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3732			include "forth_words_logic.asm" 
3732			 
3732			; | ## Logic Words 
3732			 
3732			.NOT: 
3732				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3732 2d				db WORD_SYS_CORE+25             
3733 7a 37			dw .IS            
3735 04				db 3 + 1 
3736 .. 00			db "NOT",0              
373a				endm 
# End of macro CWHEAD
373a			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
373a					if DEBUG_FORTH_WORDS_KEY 
373a						DMARK "NOT" 
373a f5				push af  
373b 3a 4f 37			ld a, (.dmark)  
373e 32 6e fe			ld (debug_mark),a  
3741 3a 50 37			ld a, (.dmark+1)  
3744 32 6f fe			ld (debug_mark+1),a  
3747 3a 51 37			ld a, (.dmark+2)  
374a 32 70 fe			ld (debug_mark+2),a  
374d 18 03			jr .pastdmark  
374f ..			.dmark: db "NOT"  
3752 f1			.pastdmark: pop af  
3753			endm  
# End of macro DMARK
3753						CALLMONITOR 
3753 cd f3 18			call break_point_state  
3756				endm  
# End of macro CALLMONITOR
3756					endif 
3756					FORTH_DSP 
3756 cd 24 21			call macro_forth_dsp 
3759				endm 
# End of macro FORTH_DSP
3759 7e					ld a,(hl)	; get type of value on TOS 
375a fe 02				cp DS_TYPE_INUM  
375c 28 03				jr z, .noti 
375e					NEXTW 
375e c3 d5 22			jp macro_next 
3761				endm 
# End of macro NEXTW
3761			.noti:          FORTH_DSP_VALUEHL 
3761 cd 5e 21			call macro_dsp_valuehl 
3764				endm 
# End of macro FORTH_DSP_VALUEHL
3764			;		push hl 
3764					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3764 cd 16 22			call macro_forth_dsp_pop 
3767				endm 
# End of macro FORTH_DSP_POP
3767			;		pop hl 
3767 3e 00				ld a,0 
3769 bd					cp l 
376a 28 04				jr z, .not2t 
376c 2e 00				ld l, 0 
376e 18 02				jr .notip 
3770			 
3770 2e ff		.not2t:		ld l, 255 
3772			 
3772 26 00		.notip:		ld h, 0	 
3774			 
3774 cd 67 1f				call forth_push_numhl 
3777					NEXTW 
3777 c3 d5 22			jp macro_next 
377a				endm 
# End of macro NEXTW
377a			 
377a			.IS: 
377a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
377a 2d				db WORD_SYS_CORE+25             
377b a0 37			dw .LZERO            
377d 03				db 2 + 1 
377e .. 00			db "IS",0              
3781				endm 
# End of macro CWHEAD
3781			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3781					if DEBUG_FORTH_WORDS_KEY 
3781						DMARK "IS." 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 6e fe			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 6f fe			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 70 fe			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "IS."  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a						CALLMONITOR 
379a cd f3 18			call break_point_state  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d					NEXTW 
379d c3 d5 22			jp macro_next 
37a0				endm 
# End of macro NEXTW
37a0			.LZERO: 
37a0				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37a0 2d				db WORD_SYS_CORE+25             
37a1 aa 37			dw .TZERO            
37a3 03				db 2 + 1 
37a4 .. 00			db "0<",0              
37a7				endm 
# End of macro CWHEAD
37a7			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37a7					NEXTW 
37a7 c3 d5 22			jp macro_next 
37aa				endm 
# End of macro NEXTW
37aa			.TZERO: 
37aa				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37aa 2e				db WORD_SYS_CORE+26             
37ab f1 37			dw .LESS            
37ad 03				db 2 + 1 
37ae .. 00			db "0=",0              
37b1				endm 
# End of macro CWHEAD
37b1			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37b1				; TODO add floating point number detection 
37b1					;v5 FORTH_DSP_VALUE 
37b1					if DEBUG_FORTH_WORDS_KEY 
37b1						DMARK "0=." 
37b1 f5				push af  
37b2 3a c6 37			ld a, (.dmark)  
37b5 32 6e fe			ld (debug_mark),a  
37b8 3a c7 37			ld a, (.dmark+1)  
37bb 32 6f fe			ld (debug_mark+1),a  
37be 3a c8 37			ld a, (.dmark+2)  
37c1 32 70 fe			ld (debug_mark+2),a  
37c4 18 03			jr .pastdmark  
37c6 ..			.dmark: db "0=."  
37c9 f1			.pastdmark: pop af  
37ca			endm  
# End of macro DMARK
37ca						CALLMONITOR 
37ca cd f3 18			call break_point_state  
37cd				endm  
# End of macro CALLMONITOR
37cd					endif 
37cd					FORTH_DSP 
37cd cd 24 21			call macro_forth_dsp 
37d0				endm 
# End of macro FORTH_DSP
37d0 7e					ld a,(hl)	; get type of value on TOS 
37d1 fe 02				cp DS_TYPE_INUM  
37d3 28 00				jr z, .tz_inum 
37d5			 
37d5				if FORTH_ENABLE_FLOATMATH 
37d5					jr .tz_done 
37d5			 
37d5				endif 
37d5					 
37d5			 
37d5			.tz_inum: 
37d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d5 cd 5e 21			call macro_dsp_valuehl 
37d8				endm 
# End of macro FORTH_DSP_VALUEHL
37d8			 
37d8			;		push hl 
37d8			 
37d8					; destroy value TOS 
37d8			 
37d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d8 cd 16 22			call macro_forth_dsp_pop 
37db				endm 
# End of macro FORTH_DSP_POP
37db			 
37db			;		pop hl 
37db			 
37db 3e 00				ld a,0 
37dd			 
37dd bd					cp l 
37de 20 08				jr nz, .tz_notzero 
37e0			 
37e0 bc					cp h 
37e1			 
37e1 20 05				jr nz, .tz_notzero 
37e3			 
37e3			 
37e3 21 01 00				ld hl, FORTH_TRUE 
37e6 18 03				jr .tz_done 
37e8			 
37e8 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37eb			 
37eb					; push value back onto stack for another op etc 
37eb			 
37eb			.tz_done: 
37eb cd 67 1f				call forth_push_numhl 
37ee			 
37ee					NEXTW 
37ee c3 d5 22			jp macro_next 
37f1				endm 
# End of macro NEXTW
37f1			.LESS: 
37f1				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
37f1 2f				db WORD_SYS_CORE+27             
37f2 5a 38			dw .GT            
37f4 02				db 1 + 1 
37f5 .. 00			db "<",0              
37f7				endm 
# End of macro CWHEAD
37f7			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
37f7				; TODO add floating point number detection 
37f7					if DEBUG_FORTH_WORDS_KEY 
37f7						DMARK "LES" 
37f7 f5				push af  
37f8 3a 0c 38			ld a, (.dmark)  
37fb 32 6e fe			ld (debug_mark),a  
37fe 3a 0d 38			ld a, (.dmark+1)  
3801 32 6f fe			ld (debug_mark+1),a  
3804 3a 0e 38			ld a, (.dmark+2)  
3807 32 70 fe			ld (debug_mark+2),a  
380a 18 03			jr .pastdmark  
380c ..			.dmark: db "LES"  
380f f1			.pastdmark: pop af  
3810			endm  
# End of macro DMARK
3810						CALLMONITOR 
3810 cd f3 18			call break_point_state  
3813				endm  
# End of macro CALLMONITOR
3813					endif 
3813					FORTH_DSP 
3813 cd 24 21			call macro_forth_dsp 
3816				endm 
# End of macro FORTH_DSP
3816					;v5 FORTH_DSP_VALUE 
3816 7e					ld a,(hl)	; get type of value on TOS 
3817 fe 02				cp DS_TYPE_INUM  
3819 28 00				jr z, .less_inum 
381b			 
381b				if FORTH_ENABLE_FLOATMATH 
381b					jr .less_done 
381b			 
381b				endif 
381b					 
381b			 
381b			.less_inum: 
381b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381b cd 5e 21			call macro_dsp_valuehl 
381e				endm 
# End of macro FORTH_DSP_VALUEHL
381e			 
381e e5					push hl  ; u2 
381f			 
381f					; destroy value TOS 
381f			 
381f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381f cd 16 22			call macro_forth_dsp_pop 
3822				endm 
# End of macro FORTH_DSP_POP
3822			 
3822			 
3822					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3822 cd 5e 21			call macro_dsp_valuehl 
3825				endm 
# End of macro FORTH_DSP_VALUEHL
3825			 
3825 e5					push hl    ; u1 
3826			 
3826					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3826 cd 16 22			call macro_forth_dsp_pop 
3829				endm 
# End of macro FORTH_DSP_POP
3829			 
3829			 
3829 b7			 or a      ;clear carry flag 
382a 01 00 00		 ld bc, FORTH_FALSE 
382d e1			  pop hl    ; u1 
382e d1			  pop de    ; u2 
382f ed 52		  sbc hl,de 
3831 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3833			 
3833 01 01 00		 ld bc, FORTH_TRUE 
3836			.lscont:  
3836 c5					push bc 
3837 e1					pop hl 
3838			 
3838					if DEBUG_FORTH_WORDS 
3838						DMARK "LT1" 
3838 f5				push af  
3839 3a 4d 38			ld a, (.dmark)  
383c 32 6e fe			ld (debug_mark),a  
383f 3a 4e 38			ld a, (.dmark+1)  
3842 32 6f fe			ld (debug_mark+1),a  
3845 3a 4f 38			ld a, (.dmark+2)  
3848 32 70 fe			ld (debug_mark+2),a  
384b 18 03			jr .pastdmark  
384d ..			.dmark: db "LT1"  
3850 f1			.pastdmark: pop af  
3851			endm  
# End of macro DMARK
3851						CALLMONITOR 
3851 cd f3 18			call break_point_state  
3854				endm  
# End of macro CALLMONITOR
3854					endif 
3854 cd 67 1f				call forth_push_numhl 
3857			 
3857					NEXTW 
3857 c3 d5 22			jp macro_next 
385a				endm 
# End of macro NEXTW
385a			.GT: 
385a				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
385a 30				db WORD_SYS_CORE+28             
385b c3 38			dw .EQUAL            
385d 02				db 1 + 1 
385e .. 00			db ">",0              
3860				endm 
# End of macro CWHEAD
3860			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3860				; TODO add floating point number detection 
3860					if DEBUG_FORTH_WORDS_KEY 
3860						DMARK "GRT" 
3860 f5				push af  
3861 3a 75 38			ld a, (.dmark)  
3864 32 6e fe			ld (debug_mark),a  
3867 3a 76 38			ld a, (.dmark+1)  
386a 32 6f fe			ld (debug_mark+1),a  
386d 3a 77 38			ld a, (.dmark+2)  
3870 32 70 fe			ld (debug_mark+2),a  
3873 18 03			jr .pastdmark  
3875 ..			.dmark: db "GRT"  
3878 f1			.pastdmark: pop af  
3879			endm  
# End of macro DMARK
3879						CALLMONITOR 
3879 cd f3 18			call break_point_state  
387c				endm  
# End of macro CALLMONITOR
387c					endif 
387c					FORTH_DSP 
387c cd 24 21			call macro_forth_dsp 
387f				endm 
# End of macro FORTH_DSP
387f					;FORTH_DSP_VALUE 
387f 7e					ld a,(hl)	; get type of value on TOS 
3880 fe 02				cp DS_TYPE_INUM  
3882 28 00				jr z, .gt_inum 
3884			 
3884				if FORTH_ENABLE_FLOATMATH 
3884					jr .gt_done 
3884			 
3884				endif 
3884					 
3884			 
3884			.gt_inum: 
3884					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3884 cd 5e 21			call macro_dsp_valuehl 
3887				endm 
# End of macro FORTH_DSP_VALUEHL
3887			 
3887 e5					push hl  ; u2 
3888			 
3888					; destroy value TOS 
3888			 
3888					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3888 cd 16 22			call macro_forth_dsp_pop 
388b				endm 
# End of macro FORTH_DSP_POP
388b			 
388b			 
388b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
388b cd 5e 21			call macro_dsp_valuehl 
388e				endm 
# End of macro FORTH_DSP_VALUEHL
388e			 
388e e5					push hl    ; u1 
388f			 
388f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388f cd 16 22			call macro_forth_dsp_pop 
3892				endm 
# End of macro FORTH_DSP_POP
3892			 
3892			 
3892 b7			 or a      ;clear carry flag 
3893 01 00 00		 ld bc, FORTH_FALSE 
3896 e1			  pop hl    ; u1 
3897 d1			  pop de    ; u2 
3898 ed 52		  sbc hl,de 
389a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
389c			 
389c 01 01 00		 ld bc, FORTH_TRUE 
389f			.gtcont:  
389f c5					push bc 
38a0 e1					pop hl 
38a1			 
38a1					if DEBUG_FORTH_WORDS 
38a1						DMARK "GT1" 
38a1 f5				push af  
38a2 3a b6 38			ld a, (.dmark)  
38a5 32 6e fe			ld (debug_mark),a  
38a8 3a b7 38			ld a, (.dmark+1)  
38ab 32 6f fe			ld (debug_mark+1),a  
38ae 3a b8 38			ld a, (.dmark+2)  
38b1 32 70 fe			ld (debug_mark+2),a  
38b4 18 03			jr .pastdmark  
38b6 ..			.dmark: db "GT1"  
38b9 f1			.pastdmark: pop af  
38ba			endm  
# End of macro DMARK
38ba						CALLMONITOR 
38ba cd f3 18			call break_point_state  
38bd				endm  
# End of macro CALLMONITOR
38bd					endif 
38bd cd 67 1f				call forth_push_numhl 
38c0			 
38c0					NEXTW 
38c0 c3 d5 22			jp macro_next 
38c3				endm 
# End of macro NEXTW
38c3			.EQUAL: 
38c3				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38c3 31				db WORD_SYS_CORE+29             
38c4 2e 39			dw .ENDLOGIC            
38c6 02				db 1 + 1 
38c7 .. 00			db "=",0              
38c9				endm 
# End of macro CWHEAD
38c9			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38c9				; TODO add floating point number detection 
38c9					if DEBUG_FORTH_WORDS_KEY 
38c9						DMARK "EQ." 
38c9 f5				push af  
38ca 3a de 38			ld a, (.dmark)  
38cd 32 6e fe			ld (debug_mark),a  
38d0 3a df 38			ld a, (.dmark+1)  
38d3 32 6f fe			ld (debug_mark+1),a  
38d6 3a e0 38			ld a, (.dmark+2)  
38d9 32 70 fe			ld (debug_mark+2),a  
38dc 18 03			jr .pastdmark  
38de ..			.dmark: db "EQ."  
38e1 f1			.pastdmark: pop af  
38e2			endm  
# End of macro DMARK
38e2						CALLMONITOR 
38e2 cd f3 18			call break_point_state  
38e5				endm  
# End of macro CALLMONITOR
38e5					endif 
38e5					FORTH_DSP 
38e5 cd 24 21			call macro_forth_dsp 
38e8				endm 
# End of macro FORTH_DSP
38e8					;v5 FORTH_DSP_VALUE 
38e8 7e					ld a,(hl)	; get type of value on TOS 
38e9 fe 02				cp DS_TYPE_INUM  
38eb 28 00				jr z, .eq_inum 
38ed			 
38ed				if FORTH_ENABLE_FLOATMATH 
38ed					jr .eq_done 
38ed			 
38ed				endif 
38ed					 
38ed			 
38ed			.eq_inum: 
38ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ed cd 5e 21			call macro_dsp_valuehl 
38f0				endm 
# End of macro FORTH_DSP_VALUEHL
38f0			 
38f0 e5					push hl 
38f1			 
38f1					; destroy value TOS 
38f1			 
38f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f1 cd 16 22			call macro_forth_dsp_pop 
38f4				endm 
# End of macro FORTH_DSP_POP
38f4			 
38f4			 
38f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38f4 cd 5e 21			call macro_dsp_valuehl 
38f7				endm 
# End of macro FORTH_DSP_VALUEHL
38f7			 
38f7					; one value on hl get other one back 
38f7			 
38f7 e5					push hl 
38f8			 
38f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f8 cd 16 22			call macro_forth_dsp_pop 
38fb				endm 
# End of macro FORTH_DSP_POP
38fb			 
38fb 0e 00				ld c, FORTH_FALSE 
38fd			 
38fd e1					pop hl 
38fe d1					pop de 
38ff			 
38ff 7b					ld a, e 
3900 bd					cp l 
3901			 
3901 20 06				jr nz, .eq_done 
3903			 
3903 7a					ld a, d 
3904 bc					cp h 
3905			 
3905 20 02				jr nz, .eq_done 
3907			 
3907 0e 01				ld c, FORTH_TRUE 
3909					 
3909			 
3909			 
3909			.eq_done: 
3909			 
3909					; TODO push value back onto stack for another op etc 
3909			 
3909 26 00				ld h, 0 
390b 69					ld l, c 
390c					if DEBUG_FORTH_WORDS 
390c						DMARK "EQ1" 
390c f5				push af  
390d 3a 21 39			ld a, (.dmark)  
3910 32 6e fe			ld (debug_mark),a  
3913 3a 22 39			ld a, (.dmark+1)  
3916 32 6f fe			ld (debug_mark+1),a  
3919 3a 23 39			ld a, (.dmark+2)  
391c 32 70 fe			ld (debug_mark+2),a  
391f 18 03			jr .pastdmark  
3921 ..			.dmark: db "EQ1"  
3924 f1			.pastdmark: pop af  
3925			endm  
# End of macro DMARK
3925						CALLMONITOR 
3925 cd f3 18			call break_point_state  
3928				endm  
# End of macro CALLMONITOR
3928					endif 
3928 cd 67 1f				call forth_push_numhl 
392b			 
392b					NEXTW 
392b c3 d5 22			jp macro_next 
392e				endm 
# End of macro NEXTW
392e			 
392e			 
392e			.ENDLOGIC: 
392e			; eof 
392e			 
392e			 
# End of file forth_words_logic.asm
392e			include "forth_words_maths.asm" 
392e			 
392e			; | ## Maths Words 
392e			 
392e			.PLUS:	 
392e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
392e 15				db WORD_SYS_CORE+1             
392f 70 39			dw .NEG            
3931 02				db 1 + 1 
3932 .. 00			db "+",0              
3934				endm 
# End of macro CWHEAD
3934			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3934					if DEBUG_FORTH_WORDS_KEY 
3934						DMARK "PLU" 
3934 f5				push af  
3935 3a 49 39			ld a, (.dmark)  
3938 32 6e fe			ld (debug_mark),a  
393b 3a 4a 39			ld a, (.dmark+1)  
393e 32 6f fe			ld (debug_mark+1),a  
3941 3a 4b 39			ld a, (.dmark+2)  
3944 32 70 fe			ld (debug_mark+2),a  
3947 18 03			jr .pastdmark  
3949 ..			.dmark: db "PLU"  
394c f1			.pastdmark: pop af  
394d			endm  
# End of macro DMARK
394d						CALLMONITOR 
394d cd f3 18			call break_point_state  
3950				endm  
# End of macro CALLMONITOR
3950					endif 
3950					; add top two values and push back result 
3950			 
3950					;for v5 FORTH_DSP_VALUE 
3950					FORTH_DSP 
3950 cd 24 21			call macro_forth_dsp 
3953				endm 
# End of macro FORTH_DSP
3953 7e					ld a,(hl)	; get type of value on TOS 
3954 fe 02				cp DS_TYPE_INUM  
3956 28 03				jr z, .dot_inum 
3958			 
3958					NEXTW 
3958 c3 d5 22			jp macro_next 
395b				endm 
# End of macro NEXTW
395b			 
395b			; float maths 
395b			 
395b				if FORTH_ENABLE_FLOATMATH 
395b						inc hl      ; now at start of numeric as string 
395b			 
395b					if DEBUG_FORTH_MATHS 
395b						DMARK "ADD" 
395b				CALLMONITOR 
395b					endif 
395b			 
395b					;ld ix, hl 
395b					call CON 
395b			 
395b			 
395b					push hl 
395b					 
395b					 
395b			 
395b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
395b			 
395b					; get next number 
395b			 
395b						FORTH_DSP_VALUE 
395b			 
395b						inc hl      ; now at start of numeric as string 
395b			 
395b					;ld ix, hl 
395b					call CON 
395b			 
395b					push hl 
395b			 
395b			 
395b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
395b			 
395b						; TODO do add 
395b			 
395b						call IADD 
395b			 
395b						; TODO get result back as ascii 
395b			 
395b						; TODO push result  
395b			 
395b			 
395b			 
395b						jr .dot_done 
395b				endif 
395b			 
395b			.dot_inum: 
395b			 
395b			 
395b					if DEBUG_FORTH_DOT 
395b						DMARK "+IT" 
395b				CALLMONITOR 
395b					endif 
395b			 
395b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
395b cd 5e 21			call macro_dsp_valuehl 
395e				endm 
# End of macro FORTH_DSP_VALUEHL
395e			 
395e				; TODO add floating point number detection 
395e			 
395e e5					push hl 
395f			 
395f					; destroy value TOS 
395f			 
395f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
395f cd 16 22			call macro_forth_dsp_pop 
3962				endm 
# End of macro FORTH_DSP_POP
3962			 
3962			 
3962					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3962 cd 5e 21			call macro_dsp_valuehl 
3965				endm 
# End of macro FORTH_DSP_VALUEHL
3965			 
3965					; one value on hl get other one back 
3965			 
3965 d1					pop de 
3966			 
3966					; do the add 
3966			 
3966 19					add hl,de 
3967			 
3967					; save it 
3967			 
3967			;		push hl	 
3967			 
3967					; 
3967			 
3967					; destroy value TOS 
3967			 
3967					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3967 cd 16 22			call macro_forth_dsp_pop 
396a				endm 
# End of macro FORTH_DSP_POP
396a			 
396a					; TODO push value back onto stack for another op etc 
396a			 
396a			;		pop hl 
396a			 
396a			.dot_done: 
396a cd 67 1f				call forth_push_numhl 
396d			 
396d					NEXTW 
396d c3 d5 22			jp macro_next 
3970				endm 
# End of macro NEXTW
3970			.NEG: 
3970			 
3970				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3970 17				db WORD_SYS_CORE+3             
3971 b3 39			dw .DIV            
3973 02				db 1 + 1 
3974 .. 00			db "-",0              
3976				endm 
# End of macro CWHEAD
3976			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3976					if DEBUG_FORTH_WORDS_KEY 
3976						DMARK "SUB" 
3976 f5				push af  
3977 3a 8b 39			ld a, (.dmark)  
397a 32 6e fe			ld (debug_mark),a  
397d 3a 8c 39			ld a, (.dmark+1)  
3980 32 6f fe			ld (debug_mark+1),a  
3983 3a 8d 39			ld a, (.dmark+2)  
3986 32 70 fe			ld (debug_mark+2),a  
3989 18 03			jr .pastdmark  
398b ..			.dmark: db "SUB"  
398e f1			.pastdmark: pop af  
398f			endm  
# End of macro DMARK
398f						CALLMONITOR 
398f cd f3 18			call break_point_state  
3992				endm  
# End of macro CALLMONITOR
3992					endif 
3992			 
3992			 
3992				; TODO add floating point number detection 
3992					; v5 FORTH_DSP_VALUE 
3992					FORTH_DSP 
3992 cd 24 21			call macro_forth_dsp 
3995				endm 
# End of macro FORTH_DSP
3995 7e					ld a,(hl)	; get type of value on TOS 
3996 fe 02				cp DS_TYPE_INUM  
3998 28 03				jr z, .neg_inum 
399a			 
399a					NEXTW 
399a c3 d5 22			jp macro_next 
399d				endm 
# End of macro NEXTW
399d			 
399d			; float maths 
399d			 
399d				if FORTH_ENABLE_FLOATMATH 
399d					jr .neg_done 
399d			 
399d				endif 
399d					 
399d			 
399d			.neg_inum: 
399d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
399d cd 5e 21			call macro_dsp_valuehl 
39a0				endm 
# End of macro FORTH_DSP_VALUEHL
39a0			 
39a0 e5					push hl 
39a1			 
39a1					; destroy value TOS 
39a1			 
39a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a1 cd 16 22			call macro_forth_dsp_pop 
39a4				endm 
# End of macro FORTH_DSP_POP
39a4			 
39a4			 
39a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39a4 cd 5e 21			call macro_dsp_valuehl 
39a7				endm 
# End of macro FORTH_DSP_VALUEHL
39a7			 
39a7					; one value on hl get other one back 
39a7			 
39a7 d1					pop de 
39a8			 
39a8					; do the sub 
39a8			;		ex de, hl 
39a8			 
39a8 ed 52				sbc hl,de 
39aa			 
39aa					; save it 
39aa			 
39aa			;		push hl	 
39aa			 
39aa					; 
39aa			 
39aa					; destroy value TOS 
39aa			 
39aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39aa cd 16 22			call macro_forth_dsp_pop 
39ad				endm 
# End of macro FORTH_DSP_POP
39ad			 
39ad					; TODO push value back onto stack for another op etc 
39ad			 
39ad			;		pop hl 
39ad			 
39ad cd 67 1f				call forth_push_numhl 
39b0			.neg_done: 
39b0			 
39b0					NEXTW 
39b0 c3 d5 22			jp macro_next 
39b3				endm 
# End of macro NEXTW
39b3			.DIV: 
39b3				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
39b3 18				db WORD_SYS_CORE+4             
39b4 00 3a			dw .MUL            
39b6 02				db 1 + 1 
39b7 .. 00			db "/",0              
39b9				endm 
# End of macro CWHEAD
39b9			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
39b9					if DEBUG_FORTH_WORDS_KEY 
39b9						DMARK "DIV" 
39b9 f5				push af  
39ba 3a ce 39			ld a, (.dmark)  
39bd 32 6e fe			ld (debug_mark),a  
39c0 3a cf 39			ld a, (.dmark+1)  
39c3 32 6f fe			ld (debug_mark+1),a  
39c6 3a d0 39			ld a, (.dmark+2)  
39c9 32 70 fe			ld (debug_mark+2),a  
39cc 18 03			jr .pastdmark  
39ce ..			.dmark: db "DIV"  
39d1 f1			.pastdmark: pop af  
39d2			endm  
# End of macro DMARK
39d2						CALLMONITOR 
39d2 cd f3 18			call break_point_state  
39d5				endm  
# End of macro CALLMONITOR
39d5					endif 
39d5				; TODO add floating point number detection 
39d5					; v5 FORTH_DSP_VALUE 
39d5					FORTH_DSP 
39d5 cd 24 21			call macro_forth_dsp 
39d8				endm 
# End of macro FORTH_DSP
39d8 7e					ld a,(hl)	; get type of value on TOS 
39d9 fe 02				cp DS_TYPE_INUM  
39db 28 03				jr z, .div_inum 
39dd			 
39dd				if FORTH_ENABLE_FLOATMATH 
39dd					jr .div_done 
39dd			 
39dd				endif 
39dd					NEXTW 
39dd c3 d5 22			jp macro_next 
39e0				endm 
# End of macro NEXTW
39e0			.div_inum: 
39e0			 
39e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e0 cd 5e 21			call macro_dsp_valuehl 
39e3				endm 
# End of macro FORTH_DSP_VALUEHL
39e3			 
39e3 e5					push hl    ; to go to bc 
39e4			 
39e4					; destroy value TOS 
39e4			 
39e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e4 cd 16 22			call macro_forth_dsp_pop 
39e7				endm 
# End of macro FORTH_DSP_POP
39e7			 
39e7			 
39e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e7 cd 5e 21			call macro_dsp_valuehl 
39ea				endm 
# End of macro FORTH_DSP_VALUEHL
39ea			 
39ea					; hl to go to de 
39ea			 
39ea e5					push hl 
39eb			 
39eb c1					pop bc 
39ec d1					pop de		 
39ed			 
39ed			 
39ed					if DEBUG_FORTH_MATHS 
39ed						DMARK "DIV" 
39ed				CALLMONITOR 
39ed					endif 
39ed					; one value on hl but move to a get other one back 
39ed			 
39ed			        
39ed cd a9 0e			call Div16 
39f0			 
39f0			;	push af	 
39f0 e5				push hl 
39f1 c5				push bc 
39f2			 
39f2					if DEBUG_FORTH_MATHS 
39f2						DMARK "DI1" 
39f2				CALLMONITOR 
39f2					endif 
39f2			 
39f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f2 cd 16 22			call macro_forth_dsp_pop 
39f5				endm 
# End of macro FORTH_DSP_POP
39f5			 
39f5			 
39f5			 
39f5 e1					pop hl    ; result 
39f6			 
39f6 cd 67 1f				call forth_push_numhl 
39f9			 
39f9 e1					pop hl    ; reminder 
39fa			;		ld h,0 
39fa			;		ld l,d 
39fa			 
39fa cd 67 1f				call forth_push_numhl 
39fd			.div_done: 
39fd					NEXTW 
39fd c3 d5 22			jp macro_next 
3a00				endm 
# End of macro NEXTW
3a00			.MUL: 
3a00				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a00 19				db WORD_SYS_CORE+5             
3a01 45 3a			dw .MIN            
3a03 02				db 1 + 1 
3a04 .. 00			db "*",0              
3a06				endm 
# End of macro CWHEAD
3a06			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a06				; TODO add floating point number detection 
3a06					if DEBUG_FORTH_WORDS_KEY 
3a06						DMARK "MUL" 
3a06 f5				push af  
3a07 3a 1b 3a			ld a, (.dmark)  
3a0a 32 6e fe			ld (debug_mark),a  
3a0d 3a 1c 3a			ld a, (.dmark+1)  
3a10 32 6f fe			ld (debug_mark+1),a  
3a13 3a 1d 3a			ld a, (.dmark+2)  
3a16 32 70 fe			ld (debug_mark+2),a  
3a19 18 03			jr .pastdmark  
3a1b ..			.dmark: db "MUL"  
3a1e f1			.pastdmark: pop af  
3a1f			endm  
# End of macro DMARK
3a1f						CALLMONITOR 
3a1f cd f3 18			call break_point_state  
3a22				endm  
# End of macro CALLMONITOR
3a22					endif 
3a22					FORTH_DSP 
3a22 cd 24 21			call macro_forth_dsp 
3a25				endm 
# End of macro FORTH_DSP
3a25					; v5 FORTH_DSP_VALUE 
3a25 7e					ld a,(hl)	; get type of value on TOS 
3a26 fe 02				cp DS_TYPE_INUM  
3a28 28 03				jr z, .mul_inum 
3a2a			 
3a2a				if FORTH_ENABLE_FLOATMATH 
3a2a					jr .mul_done 
3a2a			 
3a2a				endif 
3a2a			 
3a2a					NEXTW 
3a2a c3 d5 22			jp macro_next 
3a2d				endm 
# End of macro NEXTW
3a2d			.mul_inum:	 
3a2d			 
3a2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a2d cd 5e 21			call macro_dsp_valuehl 
3a30				endm 
# End of macro FORTH_DSP_VALUEHL
3a30			 
3a30 e5					push hl 
3a31			 
3a31					; destroy value TOS 
3a31			 
3a31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a31 cd 16 22			call macro_forth_dsp_pop 
3a34				endm 
# End of macro FORTH_DSP_POP
3a34			 
3a34			 
3a34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a34 cd 5e 21			call macro_dsp_valuehl 
3a37				endm 
# End of macro FORTH_DSP_VALUEHL
3a37			 
3a37					; one value on hl but move to a get other one back 
3a37			 
3a37 7d					ld a, l 
3a38			 
3a38 d1					pop de 
3a39			 
3a39					; do the mull 
3a39			;		ex de, hl 
3a39			 
3a39 cd cf 0e				call Mult16 
3a3c					; save it 
3a3c			 
3a3c			;		push hl	 
3a3c			 
3a3c					; 
3a3c			 
3a3c					; destroy value TOS 
3a3c			 
3a3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a3c cd 16 22			call macro_forth_dsp_pop 
3a3f				endm 
# End of macro FORTH_DSP_POP
3a3f			 
3a3f					; TODO push value back onto stack for another op etc 
3a3f			 
3a3f			;		pop hl 
3a3f			 
3a3f cd 67 1f				call forth_push_numhl 
3a42			 
3a42			.mul_done: 
3a42					NEXTW 
3a42 c3 d5 22			jp macro_next 
3a45				endm 
# End of macro NEXTW
3a45			 
3a45			 
3a45			 
3a45			 
3a45			.MIN: 
3a45				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a45 49				db WORD_SYS_CORE+53             
3a46 c6 3a			dw .MAX            
3a48 04				db 3 + 1 
3a49 .. 00			db "MIN",0              
3a4d				endm 
# End of macro CWHEAD
3a4d			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a4d					if DEBUG_FORTH_WORDS_KEY 
3a4d						DMARK "MIN" 
3a4d f5				push af  
3a4e 3a 62 3a			ld a, (.dmark)  
3a51 32 6e fe			ld (debug_mark),a  
3a54 3a 63 3a			ld a, (.dmark+1)  
3a57 32 6f fe			ld (debug_mark+1),a  
3a5a 3a 64 3a			ld a, (.dmark+2)  
3a5d 32 70 fe			ld (debug_mark+2),a  
3a60 18 03			jr .pastdmark  
3a62 ..			.dmark: db "MIN"  
3a65 f1			.pastdmark: pop af  
3a66			endm  
# End of macro DMARK
3a66						CALLMONITOR 
3a66 cd f3 18			call break_point_state  
3a69				endm  
# End of macro CALLMONITOR
3a69					endif 
3a69					; get u2 
3a69			 
3a69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a69 cd 5e 21			call macro_dsp_valuehl 
3a6c				endm 
# End of macro FORTH_DSP_VALUEHL
3a6c			 
3a6c e5					push hl   ; u2 
3a6d			 
3a6d					; destroy value TOS 
3a6d			 
3a6d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6d cd 16 22			call macro_forth_dsp_pop 
3a70				endm 
# End of macro FORTH_DSP_POP
3a70			 
3a70					; get u1 
3a70			 
3a70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a70 cd 5e 21			call macro_dsp_valuehl 
3a73				endm 
# End of macro FORTH_DSP_VALUEHL
3a73			 
3a73 e5					push hl  ; u1 
3a74			 
3a74					; destroy value TOS 
3a74			 
3a74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a74 cd 16 22			call macro_forth_dsp_pop 
3a77				endm 
# End of macro FORTH_DSP_POP
3a77			 
3a77 b7			 or a      ;clear carry flag 
3a78 e1			  pop hl    ; u1 
3a79 d1			  pop de    ; u2 
3a7a e5				push hl   ; saved in case hl is lowest 
3a7b ed 52		  sbc hl,de 
3a7d 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a7f			 
3a7f e1				pop hl 
3a80					if DEBUG_FORTH_WORDS 
3a80						DMARK "MIN" 
3a80 f5				push af  
3a81 3a 95 3a			ld a, (.dmark)  
3a84 32 6e fe			ld (debug_mark),a  
3a87 3a 96 3a			ld a, (.dmark+1)  
3a8a 32 6f fe			ld (debug_mark+1),a  
3a8d 3a 97 3a			ld a, (.dmark+2)  
3a90 32 70 fe			ld (debug_mark+2),a  
3a93 18 03			jr .pastdmark  
3a95 ..			.dmark: db "MIN"  
3a98 f1			.pastdmark: pop af  
3a99			endm  
# End of macro DMARK
3a99						CALLMONITOR 
3a99 cd f3 18			call break_point_state  
3a9c				endm  
# End of macro CALLMONITOR
3a9c					endif 
3a9c cd 67 1f				call forth_push_numhl 
3a9f			 
3a9f				       NEXTW 
3a9f c3 d5 22			jp macro_next 
3aa2				endm 
# End of macro NEXTW
3aa2			 
3aa2			.mincont:  
3aa2 c1				pop bc   ; tidy up 
3aa3 eb				ex de , hl  
3aa4					if DEBUG_FORTH_WORDS 
3aa4						DMARK "MI1" 
3aa4 f5				push af  
3aa5 3a b9 3a			ld a, (.dmark)  
3aa8 32 6e fe			ld (debug_mark),a  
3aab 3a ba 3a			ld a, (.dmark+1)  
3aae 32 6f fe			ld (debug_mark+1),a  
3ab1 3a bb 3a			ld a, (.dmark+2)  
3ab4 32 70 fe			ld (debug_mark+2),a  
3ab7 18 03			jr .pastdmark  
3ab9 ..			.dmark: db "MI1"  
3abc f1			.pastdmark: pop af  
3abd			endm  
# End of macro DMARK
3abd						CALLMONITOR 
3abd cd f3 18			call break_point_state  
3ac0				endm  
# End of macro CALLMONITOR
3ac0					endif 
3ac0 cd 67 1f				call forth_push_numhl 
3ac3			 
3ac3				       NEXTW 
3ac3 c3 d5 22			jp macro_next 
3ac6				endm 
# End of macro NEXTW
3ac6			.MAX: 
3ac6				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3ac6 4a				db WORD_SYS_CORE+54             
3ac7 47 3b			dw .RND16            
3ac9 04				db 3 + 1 
3aca .. 00			db "MAX",0              
3ace				endm 
# End of macro CWHEAD
3ace			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3ace					if DEBUG_FORTH_WORDS_KEY 
3ace						DMARK "MAX" 
3ace f5				push af  
3acf 3a e3 3a			ld a, (.dmark)  
3ad2 32 6e fe			ld (debug_mark),a  
3ad5 3a e4 3a			ld a, (.dmark+1)  
3ad8 32 6f fe			ld (debug_mark+1),a  
3adb 3a e5 3a			ld a, (.dmark+2)  
3ade 32 70 fe			ld (debug_mark+2),a  
3ae1 18 03			jr .pastdmark  
3ae3 ..			.dmark: db "MAX"  
3ae6 f1			.pastdmark: pop af  
3ae7			endm  
# End of macro DMARK
3ae7						CALLMONITOR 
3ae7 cd f3 18			call break_point_state  
3aea				endm  
# End of macro CALLMONITOR
3aea					endif 
3aea					; get u2 
3aea			 
3aea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aea cd 5e 21			call macro_dsp_valuehl 
3aed				endm 
# End of macro FORTH_DSP_VALUEHL
3aed			 
3aed e5					push hl   ; u2 
3aee			 
3aee					; destroy value TOS 
3aee			 
3aee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aee cd 16 22			call macro_forth_dsp_pop 
3af1				endm 
# End of macro FORTH_DSP_POP
3af1			 
3af1					; get u1 
3af1			 
3af1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af1 cd 5e 21			call macro_dsp_valuehl 
3af4				endm 
# End of macro FORTH_DSP_VALUEHL
3af4			 
3af4 e5					push hl  ; u1 
3af5			 
3af5					; destroy value TOS 
3af5			 
3af5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af5 cd 16 22			call macro_forth_dsp_pop 
3af8				endm 
# End of macro FORTH_DSP_POP
3af8			 
3af8 b7			 or a      ;clear carry flag 
3af9 e1			  pop hl    ; u1 
3afa d1			  pop de    ; u2 
3afb e5				push hl   ; saved in case hl is lowest 
3afc ed 52		  sbc hl,de 
3afe 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b00			 
3b00 e1				pop hl 
3b01					if DEBUG_FORTH_WORDS 
3b01						DMARK "MAX" 
3b01 f5				push af  
3b02 3a 16 3b			ld a, (.dmark)  
3b05 32 6e fe			ld (debug_mark),a  
3b08 3a 17 3b			ld a, (.dmark+1)  
3b0b 32 6f fe			ld (debug_mark+1),a  
3b0e 3a 18 3b			ld a, (.dmark+2)  
3b11 32 70 fe			ld (debug_mark+2),a  
3b14 18 03			jr .pastdmark  
3b16 ..			.dmark: db "MAX"  
3b19 f1			.pastdmark: pop af  
3b1a			endm  
# End of macro DMARK
3b1a						CALLMONITOR 
3b1a cd f3 18			call break_point_state  
3b1d				endm  
# End of macro CALLMONITOR
3b1d					endif 
3b1d cd 67 1f				call forth_push_numhl 
3b20			 
3b20				       NEXTW 
3b20 c3 d5 22			jp macro_next 
3b23				endm 
# End of macro NEXTW
3b23			 
3b23			.maxcont:  
3b23 c1				pop bc   ; tidy up 
3b24 eb				ex de , hl  
3b25					if DEBUG_FORTH_WORDS 
3b25						DMARK "MA1" 
3b25 f5				push af  
3b26 3a 3a 3b			ld a, (.dmark)  
3b29 32 6e fe			ld (debug_mark),a  
3b2c 3a 3b 3b			ld a, (.dmark+1)  
3b2f 32 6f fe			ld (debug_mark+1),a  
3b32 3a 3c 3b			ld a, (.dmark+2)  
3b35 32 70 fe			ld (debug_mark+2),a  
3b38 18 03			jr .pastdmark  
3b3a ..			.dmark: db "MA1"  
3b3d f1			.pastdmark: pop af  
3b3e			endm  
# End of macro DMARK
3b3e						CALLMONITOR 
3b3e cd f3 18			call break_point_state  
3b41				endm  
# End of macro CALLMONITOR
3b41					endif 
3b41 cd 67 1f				call forth_push_numhl 
3b44				       NEXTW 
3b44 c3 d5 22			jp macro_next 
3b47				endm 
# End of macro NEXTW
3b47			 
3b47			.RND16: 
3b47				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b47 4e				db WORD_SYS_CORE+58             
3b48 76 3b			dw .RND8            
3b4a 06				db 5 + 1 
3b4b .. 00			db "RND16",0              
3b51				endm 
# End of macro CWHEAD
3b51			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b51					if DEBUG_FORTH_WORDS_KEY 
3b51						DMARK "R16" 
3b51 f5				push af  
3b52 3a 66 3b			ld a, (.dmark)  
3b55 32 6e fe			ld (debug_mark),a  
3b58 3a 67 3b			ld a, (.dmark+1)  
3b5b 32 6f fe			ld (debug_mark+1),a  
3b5e 3a 68 3b			ld a, (.dmark+2)  
3b61 32 70 fe			ld (debug_mark+2),a  
3b64 18 03			jr .pastdmark  
3b66 ..			.dmark: db "R16"  
3b69 f1			.pastdmark: pop af  
3b6a			endm  
# End of macro DMARK
3b6a						CALLMONITOR 
3b6a cd f3 18			call break_point_state  
3b6d				endm  
# End of macro CALLMONITOR
3b6d					endif 
3b6d cd 73 0e				call prng16  
3b70 cd 67 1f				call forth_push_numhl 
3b73				       NEXTW 
3b73 c3 d5 22			jp macro_next 
3b76				endm 
# End of macro NEXTW
3b76			.RND8: 
3b76				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b76 60				db WORD_SYS_CORE+76             
3b77 ab 3b			dw .RND            
3b79 05				db 4 + 1 
3b7a .. 00			db "RND8",0              
3b7f				endm 
# End of macro CWHEAD
3b7f			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b7f					if DEBUG_FORTH_WORDS_KEY 
3b7f						DMARK "RN8" 
3b7f f5				push af  
3b80 3a 94 3b			ld a, (.dmark)  
3b83 32 6e fe			ld (debug_mark),a  
3b86 3a 95 3b			ld a, (.dmark+1)  
3b89 32 6f fe			ld (debug_mark+1),a  
3b8c 3a 96 3b			ld a, (.dmark+2)  
3b8f 32 70 fe			ld (debug_mark+2),a  
3b92 18 03			jr .pastdmark  
3b94 ..			.dmark: db "RN8"  
3b97 f1			.pastdmark: pop af  
3b98			endm  
# End of macro DMARK
3b98						CALLMONITOR 
3b98 cd f3 18			call break_point_state  
3b9b				endm  
# End of macro CALLMONITOR
3b9b					endif 
3b9b 2a af fb				ld hl,(xrandc) 
3b9e 23					inc hl 
3b9f cd 8d 0e				call xrnd 
3ba2 6f					ld l,a	 
3ba3 26 00				ld h,0 
3ba5 cd 67 1f				call forth_push_numhl 
3ba8				       NEXTW 
3ba8 c3 d5 22			jp macro_next 
3bab				endm 
# End of macro NEXTW
3bab			.RND: 
3bab				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bab 60				db WORD_SYS_CORE+76             
3bac b1 3c			dw .ENDMATHS            
3bae 04				db 3 + 1 
3baf .. 00			db "RND",0              
3bb3				endm 
# End of macro CWHEAD
3bb3			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3bb3			 
3bb3					if DEBUG_FORTH_WORDS_KEY 
3bb3						DMARK "RND" 
3bb3 f5				push af  
3bb4 3a c8 3b			ld a, (.dmark)  
3bb7 32 6e fe			ld (debug_mark),a  
3bba 3a c9 3b			ld a, (.dmark+1)  
3bbd 32 6f fe			ld (debug_mark+1),a  
3bc0 3a ca 3b			ld a, (.dmark+2)  
3bc3 32 70 fe			ld (debug_mark+2),a  
3bc6 18 03			jr .pastdmark  
3bc8 ..			.dmark: db "RND"  
3bcb f1			.pastdmark: pop af  
3bcc			endm  
# End of macro DMARK
3bcc						CALLMONITOR 
3bcc cd f3 18			call break_point_state  
3bcf				endm  
# End of macro CALLMONITOR
3bcf					endif 
3bcf					 
3bcf					FORTH_DSP_VALUEHL    ; upper range 
3bcf cd 5e 21			call macro_dsp_valuehl 
3bd2				endm 
# End of macro FORTH_DSP_VALUEHL
3bd2			 
3bd2 22 b3 fb				ld (LFSRSeed), hl	 
3bd5			 
3bd5					if DEBUG_FORTH_WORDS 
3bd5						DMARK "RN1" 
3bd5 f5				push af  
3bd6 3a ea 3b			ld a, (.dmark)  
3bd9 32 6e fe			ld (debug_mark),a  
3bdc 3a eb 3b			ld a, (.dmark+1)  
3bdf 32 6f fe			ld (debug_mark+1),a  
3be2 3a ec 3b			ld a, (.dmark+2)  
3be5 32 70 fe			ld (debug_mark+2),a  
3be8 18 03			jr .pastdmark  
3bea ..			.dmark: db "RN1"  
3bed f1			.pastdmark: pop af  
3bee			endm  
# End of macro DMARK
3bee						CALLMONITOR 
3bee cd f3 18			call break_point_state  
3bf1				endm  
# End of macro CALLMONITOR
3bf1					endif 
3bf1					FORTH_DSP_POP 
3bf1 cd 16 22			call macro_forth_dsp_pop 
3bf4				endm 
# End of macro FORTH_DSP_POP
3bf4			 
3bf4					FORTH_DSP_VALUEHL    ; low range 
3bf4 cd 5e 21			call macro_dsp_valuehl 
3bf7				endm 
# End of macro FORTH_DSP_VALUEHL
3bf7			 
3bf7					if DEBUG_FORTH_WORDS 
3bf7						DMARK "RN2" 
3bf7 f5				push af  
3bf8 3a 0c 3c			ld a, (.dmark)  
3bfb 32 6e fe			ld (debug_mark),a  
3bfe 3a 0d 3c			ld a, (.dmark+1)  
3c01 32 6f fe			ld (debug_mark+1),a  
3c04 3a 0e 3c			ld a, (.dmark+2)  
3c07 32 70 fe			ld (debug_mark+2),a  
3c0a 18 03			jr .pastdmark  
3c0c ..			.dmark: db "RN2"  
3c0f f1			.pastdmark: pop af  
3c10			endm  
# End of macro DMARK
3c10						CALLMONITOR 
3c10 cd f3 18			call break_point_state  
3c13				endm  
# End of macro CALLMONITOR
3c13					endif 
3c13 22 b5 fb				ld (LFSRSeed+2), hl 
3c16			 
3c16					FORTH_DSP_POP 
3c16 cd 16 22			call macro_forth_dsp_pop 
3c19				endm 
# End of macro FORTH_DSP_POP
3c19			 
3c19 e5					push hl 
3c1a			 
3c1a e1			.inrange:	pop hl 
3c1b cd 73 0e				call prng16  
3c1e					if DEBUG_FORTH_WORDS 
3c1e						DMARK "RN3" 
3c1e f5				push af  
3c1f 3a 33 3c			ld a, (.dmark)  
3c22 32 6e fe			ld (debug_mark),a  
3c25 3a 34 3c			ld a, (.dmark+1)  
3c28 32 6f fe			ld (debug_mark+1),a  
3c2b 3a 35 3c			ld a, (.dmark+2)  
3c2e 32 70 fe			ld (debug_mark+2),a  
3c31 18 03			jr .pastdmark  
3c33 ..			.dmark: db "RN3"  
3c36 f1			.pastdmark: pop af  
3c37			endm  
# End of macro DMARK
3c37						CALLMONITOR 
3c37 cd f3 18			call break_point_state  
3c3a				endm  
# End of macro CALLMONITOR
3c3a					endif 
3c3a					 
3c3a					; if the range is 8bit knock out the high byte 
3c3a			 
3c3a ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3c3e			 
3c3e 3e 00				ld a, 0 
3c40 ba					cp d  
3c41 20 1e				jr nz, .hirange 
3c43 26 00				ld h, 0   ; knock it down to 8bit 
3c45			 
3c45					if DEBUG_FORTH_WORDS 
3c45						DMARK "RNk" 
3c45 f5				push af  
3c46 3a 5a 3c			ld a, (.dmark)  
3c49 32 6e fe			ld (debug_mark),a  
3c4c 3a 5b 3c			ld a, (.dmark+1)  
3c4f 32 6f fe			ld (debug_mark+1),a  
3c52 3a 5c 3c			ld a, (.dmark+2)  
3c55 32 70 fe			ld (debug_mark+2),a  
3c58 18 03			jr .pastdmark  
3c5a ..			.dmark: db "RNk"  
3c5d f1			.pastdmark: pop af  
3c5e			endm  
# End of macro DMARK
3c5e						CALLMONITOR 
3c5e cd f3 18			call break_point_state  
3c61				endm  
# End of macro CALLMONITOR
3c61					endif 
3c61			.hirange:   
3c61 e5					push hl  
3c62 b7					or a  
3c63 ed 52		                sbc hl, de 
3c65			 
3c65					;call cmp16 
3c65			 
3c65 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c67 e1					pop hl 
3c68 e5					push hl 
3c69			 
3c69					if DEBUG_FORTH_WORDS 
3c69						DMARK "RN4" 
3c69 f5				push af  
3c6a 3a 7e 3c			ld a, (.dmark)  
3c6d 32 6e fe			ld (debug_mark),a  
3c70 3a 7f 3c			ld a, (.dmark+1)  
3c73 32 6f fe			ld (debug_mark+1),a  
3c76 3a 80 3c			ld a, (.dmark+2)  
3c79 32 70 fe			ld (debug_mark+2),a  
3c7c 18 03			jr .pastdmark  
3c7e ..			.dmark: db "RN4"  
3c81 f1			.pastdmark: pop af  
3c82			endm  
# End of macro DMARK
3c82						CALLMONITOR 
3c82 cd f3 18			call break_point_state  
3c85				endm  
# End of macro CALLMONITOR
3c85					endif 
3c85 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3c89					;call cmp16 
3c89				 
3c89 b7					or a  
3c8a ed 52		                sbc hl, de 
3c8c 38 8c				jr c, .inrange 
3c8e			 
3c8e e1					pop hl 
3c8f					 
3c8f					if DEBUG_FORTH_WORDS 
3c8f						DMARK "RNd" 
3c8f f5				push af  
3c90 3a a4 3c			ld a, (.dmark)  
3c93 32 6e fe			ld (debug_mark),a  
3c96 3a a5 3c			ld a, (.dmark+1)  
3c99 32 6f fe			ld (debug_mark+1),a  
3c9c 3a a6 3c			ld a, (.dmark+2)  
3c9f 32 70 fe			ld (debug_mark+2),a  
3ca2 18 03			jr .pastdmark  
3ca4 ..			.dmark: db "RNd"  
3ca7 f1			.pastdmark: pop af  
3ca8			endm  
# End of macro DMARK
3ca8						CALLMONITOR 
3ca8 cd f3 18			call break_point_state  
3cab				endm  
# End of macro CALLMONITOR
3cab					endif 
3cab			 
3cab			 
3cab cd 67 1f				call forth_push_numhl 
3cae				       NEXTW 
3cae c3 d5 22			jp macro_next 
3cb1				endm 
# End of macro NEXTW
3cb1			 
3cb1			.ENDMATHS: 
3cb1			 
3cb1			; eof 
3cb1			 
# End of file forth_words_maths.asm
3cb1			include "forth_words_display.asm" 
3cb1			 
3cb1			; | ## Display Words 
3cb1			 
3cb1			.INFO: 
3cb1			 
3cb1				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3cb1 62				db WORD_SYS_CORE+78             
3cb2 ce 3c			dw .ATP            
3cb4 05				db 4 + 1 
3cb5 .. 00			db "INFO",0              
3cba				endm 
# End of macro CWHEAD
3cba			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3cba					FORTH_DSP_VALUEHL 
3cba cd 5e 21			call macro_dsp_valuehl 
3cbd				endm 
# End of macro FORTH_DSP_VALUEHL
3cbd			 
3cbd					FORTH_DSP_POP 
3cbd cd 16 22			call macro_forth_dsp_pop 
3cc0				endm 
# End of macro FORTH_DSP_POP
3cc0			 
3cc0 e5					push hl 
3cc1			 
3cc1					FORTH_DSP_VALUEHL 
3cc1 cd 5e 21			call macro_dsp_valuehl 
3cc4				endm 
# End of macro FORTH_DSP_VALUEHL
3cc4			 
3cc4					FORTH_DSP_POP 
3cc4 cd 16 22			call macro_forth_dsp_pop 
3cc7				endm 
# End of macro FORTH_DSP_POP
3cc7			 
3cc7 d1					pop de 
3cc8			 
3cc8 cd a9 0c				call info_panel 
3ccb			 
3ccb			 
3ccb					NEXTW 
3ccb c3 d5 22			jp macro_next 
3cce				endm 
# End of macro NEXTW
3cce			.ATP: 
3cce				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3cce 62				db WORD_SYS_CORE+78             
3ccf 45 3d			dw .FB            
3cd1 04				db 3 + 1 
3cd2 .. 00			db "AT?",0              
3cd6				endm 
# End of macro CWHEAD
3cd6			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3cd6					if DEBUG_FORTH_WORDS_KEY 
3cd6						DMARK "AT?" 
3cd6 f5				push af  
3cd7 3a eb 3c			ld a, (.dmark)  
3cda 32 6e fe			ld (debug_mark),a  
3cdd 3a ec 3c			ld a, (.dmark+1)  
3ce0 32 6f fe			ld (debug_mark+1),a  
3ce3 3a ed 3c			ld a, (.dmark+2)  
3ce6 32 70 fe			ld (debug_mark+2),a  
3ce9 18 03			jr .pastdmark  
3ceb ..			.dmark: db "AT?"  
3cee f1			.pastdmark: pop af  
3cef			endm  
# End of macro DMARK
3cef						CALLMONITOR 
3cef cd f3 18			call break_point_state  
3cf2				endm  
# End of macro CALLMONITOR
3cf2					endif 
3cf2 3a 65 fa				ld a, (f_cursor_ptr) 
3cf5			 
3cf5			if DEBUG_FORTH_WORDS 
3cf5				DMARK "AT?" 
3cf5 f5				push af  
3cf6 3a 0a 3d			ld a, (.dmark)  
3cf9 32 6e fe			ld (debug_mark),a  
3cfc 3a 0b 3d			ld a, (.dmark+1)  
3cff 32 6f fe			ld (debug_mark+1),a  
3d02 3a 0c 3d			ld a, (.dmark+2)  
3d05 32 70 fe			ld (debug_mark+2),a  
3d08 18 03			jr .pastdmark  
3d0a ..			.dmark: db "AT?"  
3d0d f1			.pastdmark: pop af  
3d0e			endm  
# End of macro DMARK
3d0e				CALLMONITOR 
3d0e cd f3 18			call break_point_state  
3d11				endm  
# End of macro CALLMONITOR
3d11			endif	 
3d11					; count the number of rows 
3d11			 
3d11 06 00				ld b, 0 
3d13 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d14 d6 28				sub display_cols 
3d16 f2 1c 3d				jp p, .atprunder 
3d19 04					inc b 
3d1a 18 f7				jr .atpr 
3d1c			.atprunder:	 
3d1c			if DEBUG_FORTH_WORDS 
3d1c				DMARK "A?2" 
3d1c f5				push af  
3d1d 3a 31 3d			ld a, (.dmark)  
3d20 32 6e fe			ld (debug_mark),a  
3d23 3a 32 3d			ld a, (.dmark+1)  
3d26 32 6f fe			ld (debug_mark+1),a  
3d29 3a 33 3d			ld a, (.dmark+2)  
3d2c 32 70 fe			ld (debug_mark+2),a  
3d2f 18 03			jr .pastdmark  
3d31 ..			.dmark: db "A?2"  
3d34 f1			.pastdmark: pop af  
3d35			endm  
# End of macro DMARK
3d35				CALLMONITOR 
3d35 cd f3 18			call break_point_state  
3d38				endm  
# End of macro CALLMONITOR
3d38			endif	 
3d38 26 00				ld h, 0 
3d3a 69					ld l, c 
3d3b cd 67 1f				call forth_push_numhl 
3d3e 68					ld l, b  
3d3f cd 67 1f				call forth_push_numhl 
3d42			 
3d42			 
3d42				NEXTW 
3d42 c3 d5 22			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			 
3d45			.FB: 
3d45				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d45 1b				db WORD_SYS_CORE+7             
3d46 93 3d			dw .EMIT            
3d48 03				db 2 + 1 
3d49 .. 00			db "FB",0              
3d4c				endm 
# End of macro CWHEAD
3d4c			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d4c			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d4c			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d4c			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d4c					if DEBUG_FORTH_WORDS_KEY 
3d4c						DMARK "FB." 
3d4c f5				push af  
3d4d 3a 61 3d			ld a, (.dmark)  
3d50 32 6e fe			ld (debug_mark),a  
3d53 3a 62 3d			ld a, (.dmark+1)  
3d56 32 6f fe			ld (debug_mark+1),a  
3d59 3a 63 3d			ld a, (.dmark+2)  
3d5c 32 70 fe			ld (debug_mark+2),a  
3d5f 18 03			jr .pastdmark  
3d61 ..			.dmark: db "FB."  
3d64 f1			.pastdmark: pop af  
3d65			endm  
# End of macro DMARK
3d65						CALLMONITOR 
3d65 cd f3 18			call break_point_state  
3d68				endm  
# End of macro CALLMONITOR
3d68					endif 
3d68			 
3d68					FORTH_DSP_VALUEHL 
3d68 cd 5e 21			call macro_dsp_valuehl 
3d6b				endm 
# End of macro FORTH_DSP_VALUEHL
3d6b			 
3d6b 7d					ld a, l 
3d6c fe 01				cp 1 
3d6e 20 05				jr nz, .fbn1 
3d70 21 13 fd				ld hl, display_fb1 
3d73 18 15				jr .fbset 
3d75 fe 02		.fbn1:		cp 2 
3d77 20 05				jr nz, .fbn2 
3d79 21 d1 fb				ld hl, display_fb2 
3d7c 18 0c				jr .fbset 
3d7e fe 03		.fbn2:		cp 3 
3d80 20 05				jr nz, .fbn3 
3d82 21 72 fc				ld hl, display_fb3 
3d85 18 03				jr .fbset 
3d87			.fbn3:		 ; if invalid number select first 
3d87 21 13 fd				ld hl, display_fb1 
3d8a 22 cf fb		.fbset:		ld (display_fb_active), hl 
3d8d			 
3d8d					FORTH_DSP_POP 
3d8d cd 16 22			call macro_forth_dsp_pop 
3d90				endm 
# End of macro FORTH_DSP_POP
3d90			 
3d90					NEXTW 
3d90 c3 d5 22			jp macro_next 
3d93				endm 
# End of macro NEXTW
3d93			 
3d93			 
3d93			.EMIT: 
3d93				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d93 1b				db WORD_SYS_CORE+7             
3d94 e4 3d			dw .DOTH            
3d96 05				db 4 + 1 
3d97 .. 00			db "EMIT",0              
3d9c				endm 
# End of macro CWHEAD
3d9c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d9c					; get value off TOS and display it 
3d9c			 
3d9c					if DEBUG_FORTH_WORDS_KEY 
3d9c						DMARK "EMT" 
3d9c f5				push af  
3d9d 3a b1 3d			ld a, (.dmark)  
3da0 32 6e fe			ld (debug_mark),a  
3da3 3a b2 3d			ld a, (.dmark+1)  
3da6 32 6f fe			ld (debug_mark+1),a  
3da9 3a b3 3d			ld a, (.dmark+2)  
3dac 32 70 fe			ld (debug_mark+2),a  
3daf 18 03			jr .pastdmark  
3db1 ..			.dmark: db "EMT"  
3db4 f1			.pastdmark: pop af  
3db5			endm  
# End of macro DMARK
3db5						CALLMONITOR 
3db5 cd f3 18			call break_point_state  
3db8				endm  
# End of macro CALLMONITOR
3db8					endif 
3db8			 
3db8					FORTH_DSP_VALUEHL 
3db8 cd 5e 21			call macro_dsp_valuehl 
3dbb				endm 
# End of macro FORTH_DSP_VALUEHL
3dbb			 
3dbb 7d					ld a,l 
3dbc			 
3dbc					; TODO write to display 
3dbc			 
3dbc 32 fa f3				ld (os_input), a 
3dbf 3e 00				ld a, 0 
3dc1 32 fb f3				ld (os_input+1), a 
3dc4					 
3dc4 3a 65 fa				ld a, (f_cursor_ptr) 
3dc7 11 fa f3				ld de, os_input 
3dca cd 2b 0d				call str_at_display 
3dcd			 
3dcd			 
3dcd 3a 43 fa				ld a,(cli_autodisplay) 
3dd0 fe 00				cp 0 
3dd2 28 03				jr z, .enoupdate 
3dd4 cd 3b 0d						call update_display 
3dd7					.enoupdate: 
3dd7			 
3dd7 3a 65 fa				ld a, (f_cursor_ptr) 
3dda 3c					inc a 
3ddb 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3dde			 
3dde			 
3dde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dde cd 16 22			call macro_forth_dsp_pop 
3de1				endm 
# End of macro FORTH_DSP_POP
3de1			  
3de1			 
3de1					NEXTW 
3de1 c3 d5 22			jp macro_next 
3de4				endm 
# End of macro NEXTW
3de4			.DOTH: 
3de4				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3de4 1c				db WORD_SYS_CORE+8             
3de5 14 3e			dw .DOTF            
3de7 03				db 2 + 1 
3de8 .. 00			db ".-",0              
3deb				endm 
# End of macro CWHEAD
3deb			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3deb					; get value off TOS and display it 
3deb					if DEBUG_FORTH_WORDS_KEY 
3deb						DMARK "DTD" 
3deb f5				push af  
3dec 3a 00 3e			ld a, (.dmark)  
3def 32 6e fe			ld (debug_mark),a  
3df2 3a 01 3e			ld a, (.dmark+1)  
3df5 32 6f fe			ld (debug_mark+1),a  
3df8 3a 02 3e			ld a, (.dmark+2)  
3dfb 32 70 fe			ld (debug_mark+2),a  
3dfe 18 03			jr .pastdmark  
3e00 ..			.dmark: db "DTD"  
3e03 f1			.pastdmark: pop af  
3e04			endm  
# End of macro DMARK
3e04						CALLMONITOR 
3e04 cd f3 18			call break_point_state  
3e07				endm  
# End of macro CALLMONITOR
3e07					endif 
3e07 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e09 3e 00			ld a, 0 
3e0b 32 44 fa			ld (cli_mvdot), a 
3e0e c3 6b 3e			jp .dotgo 
3e11				NEXTW 
3e11 c3 d5 22			jp macro_next 
3e14				endm 
# End of macro NEXTW
3e14			.DOTF: 
3e14				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e14 1c				db WORD_SYS_CORE+8             
3e15 42 3e			dw .DOT            
3e17 03				db 2 + 1 
3e18 .. 00			db ".>",0              
3e1b				endm 
# End of macro CWHEAD
3e1b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e1b					; get value off TOS and display it 
3e1b			        ; TODO BUG adds extra spaces 
3e1b			        ; TODO BUG handle numerics? 
3e1b					if DEBUG_FORTH_WORDS_KEY 
3e1b						DMARK "DTC" 
3e1b f5				push af  
3e1c 3a 30 3e			ld a, (.dmark)  
3e1f 32 6e fe			ld (debug_mark),a  
3e22 3a 31 3e			ld a, (.dmark+1)  
3e25 32 6f fe			ld (debug_mark+1),a  
3e28 3a 32 3e			ld a, (.dmark+2)  
3e2b 32 70 fe			ld (debug_mark+2),a  
3e2e 18 03			jr .pastdmark  
3e30 ..			.dmark: db "DTC"  
3e33 f1			.pastdmark: pop af  
3e34			endm  
# End of macro DMARK
3e34						CALLMONITOR 
3e34 cd f3 18			call break_point_state  
3e37				endm  
# End of macro CALLMONITOR
3e37					endif 
3e37 3e 01			ld a, 1 
3e39 32 44 fa			ld (cli_mvdot), a 
3e3c c3 6b 3e			jp .dotgo 
3e3f				NEXTW 
3e3f c3 d5 22			jp macro_next 
3e42				endm 
# End of macro NEXTW
3e42			 
3e42			.DOT: 
3e42				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e42 1c				db WORD_SYS_CORE+8             
3e43 ce 3e			dw .CLS            
3e45 02				db 1 + 1 
3e46 .. 00			db ".",0              
3e48				endm 
# End of macro CWHEAD
3e48			        ; | . ( u -- ) Display TOS | DONE 
3e48					; get value off TOS and display it 
3e48			 
3e48					if DEBUG_FORTH_WORDS_KEY 
3e48						DMARK "DOT" 
3e48 f5				push af  
3e49 3a 5d 3e			ld a, (.dmark)  
3e4c 32 6e fe			ld (debug_mark),a  
3e4f 3a 5e 3e			ld a, (.dmark+1)  
3e52 32 6f fe			ld (debug_mark+1),a  
3e55 3a 5f 3e			ld a, (.dmark+2)  
3e58 32 70 fe			ld (debug_mark+2),a  
3e5b 18 03			jr .pastdmark  
3e5d ..			.dmark: db "DOT"  
3e60 f1			.pastdmark: pop af  
3e61			endm  
# End of macro DMARK
3e61						CALLMONITOR 
3e61 cd f3 18			call break_point_state  
3e64				endm  
# End of macro CALLMONITOR
3e64					endif 
3e64 3e 00			ld a, 0 
3e66 32 44 fa			ld (cli_mvdot), a 
3e69 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e6b				 
3e6b			 
3e6b			.dotgo: 
3e6b			 
3e6b			; move up type to on stack for parserv5 
3e6b					FORTH_DSP 
3e6b cd 24 21			call macro_forth_dsp 
3e6e				endm 
# End of macro FORTH_DSP
3e6e				;FORTH_DSP_VALUE  
3e6e			 
3e6e			if DEBUG_FORTH_DOT 
3e6e				DMARK "DOT" 
3e6e				CALLMONITOR 
3e6e			endif	 
3e6e			;		.print: 
3e6e			 
3e6e 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3e6f 23				inc hl   ; position to the actual value 
3e70 fe 01			cp DS_TYPE_STR 
3e72 20 06			jr nz, .dotnum1  
3e74			 
3e74			; display string 
3e74				FORTH_DSP_VALUE  
3e74 cd 47 21			call macro_forth_dsp_value 
3e77				endm 
# End of macro FORTH_DSP_VALUE
3e77 eb				ex de,hl 
3e78 18 11			jr .dotwrite 
3e7a			 
3e7a			.dotnum1: 
3e7a fe 02			cp DS_TYPE_INUM 
3e7c 20 0c			jr nz, .dotflot 
3e7e			 
3e7e			 
3e7e			; display number 
3e7e			 
3e7e			;	push hl 
3e7e			;	call clear_display 
3e7e			;	pop hl 
3e7e			 
3e7e 5e				ld e, (hl) 
3e7f 23				inc hl 
3e80 56				ld d, (hl) 
3e81 21 fc f1			ld hl, scratch 
3e84			if DEBUG_FORTH_DOT 
3e84				DMARK "DT1" 
3e84				CALLMONITOR 
3e84			endif	 
3e84			 
3e84 cd 59 13			call uitoa_16 
3e87 eb				ex de,hl 
3e88			 
3e88			if DEBUG_FORTH_DOT 
3e88				DMARK "DT2" 
3e88				CALLMONITOR 
3e88			endif	 
3e88			 
3e88			;	ld de, os_word_scratch 
3e88 18 01			jr .dotwrite 
3e8a			 
3e8a 00			.dotflot:   nop 
3e8b			; TODO print floating point number 
3e8b			 
3e8b			.dotwrite:		 
3e8b			 
3e8b					; if c is set then set all '-' to spaces 
3e8b					; need to also take into account .>  
3e8b			 
3e8b 3e 01				ld a, 1 
3e8d b9					cp c 
3e8e 20 13				jr nz, .nodashswap 
3e90			 
3e90					; DE has the string to write, working with HL 
3e90			 
3e90 06 ff				ld b, 255 
3e92 d5					push de 
3e93 e1					pop hl 
3e94			 
3e94			if DEBUG_FORTH_DOT 
3e94				DMARK "DT-" 
3e94				CALLMONITOR 
3e94			endif	 
3e94 7e			.dashscan:	ld a, (hl) 
3e95 fe 00				cp 0 
3e97 28 0a				jr z, .nodashswap 
3e99 fe 2d				cp '-' 
3e9b 20 03				jr nz, .dashskip 
3e9d 3e 20				ld a, ' ' 
3e9f 77					ld (hl), a 
3ea0 23			.dashskip:	inc hl 
3ea1			if DEBUG_FORTH_DOT 
3ea1				DMARK "D-2" 
3ea1				CALLMONITOR 
3ea1			endif	 
3ea1 10 f1				djnz .dashscan 
3ea3			 
3ea3			if DEBUG_FORTH_DOT 
3ea3				DMARK "D-1" 
3ea3				CALLMONITOR 
3ea3			endif	 
3ea3			 
3ea3			.nodashswap: 
3ea3			 
3ea3 e5					push hl   ; save string start in case we need to advance print 
3ea4			 
3ea4 3a 65 fa				ld a, (f_cursor_ptr) 
3ea7 cd 2b 0d				call str_at_display 
3eaa 3a 43 fa				ld a,(cli_autodisplay) 
3ead fe 00				cp 0 
3eaf 28 03				jr z, .noupdate 
3eb1 cd 3b 0d						call update_display 
3eb4					.noupdate: 
3eb4			 
3eb4			 
3eb4					; see if we need to advance the print position 
3eb4			 
3eb4 e1					pop hl   ; get back string 
3eb5			 
3eb5 3a 44 fa				ld a, (cli_mvdot) 
3eb8			if DEBUG_FORTH_DOT 
3eb8					ld e,a 
3eb8				DMARK "D>1" 
3eb8				CALLMONITOR 
3eb8			endif	 
3eb8 fe 00				cp 0 
3eba 28 0c				jr z, .noadv 
3ebc					; yes, lets advance the print position 
3ebc 3e 00				ld a, 0 
3ebe cd b5 13				call strlent 
3ec1 3a 65 fa				ld a, (f_cursor_ptr) 
3ec4 85					add a,l 
3ec5					;call addatohl 
3ec5					;ld a, l 
3ec5 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3ec8			 
3ec8			if DEBUG_FORTH_DOT 
3ec8				DMARK "D->" 
3ec8				CALLMONITOR 
3ec8			endif	 
3ec8			 
3ec8			.noadv:	 
3ec8			 
3ec8					if DEBUG_FORTH_DOT_WAIT 
3ec8							call next_page_prompt 
3ec8					endif	 
3ec8			; TODO this pop off the stack causes a crash. i dont know why 
3ec8			 
3ec8			 
3ec8			if DEBUG_FORTH_DOT 
3ec8				DMARK "DTh" 
3ec8				CALLMONITOR 
3ec8			endif	 
3ec8			 
3ec8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec8 cd 16 22			call macro_forth_dsp_pop 
3ecb				endm 
# End of macro FORTH_DSP_POP
3ecb			 
3ecb			if DEBUG_FORTH_DOT 
3ecb				DMARK "DTi" 
3ecb				CALLMONITOR 
3ecb			endif	 
3ecb			 
3ecb			 
3ecb					NEXTW 
3ecb c3 d5 22			jp macro_next 
3ece				endm 
# End of macro NEXTW
3ece			 
3ece			.CLS: 
3ece				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3ece 35				db WORD_SYS_CORE+33             
3ecf fb 3e			dw .DRAW            
3ed1 04				db 3 + 1 
3ed2 .. 00			db "CLS",0              
3ed6				endm 
# End of macro CWHEAD
3ed6			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3ed6					if DEBUG_FORTH_WORDS_KEY 
3ed6						DMARK "CLS" 
3ed6 f5				push af  
3ed7 3a eb 3e			ld a, (.dmark)  
3eda 32 6e fe			ld (debug_mark),a  
3edd 3a ec 3e			ld a, (.dmark+1)  
3ee0 32 6f fe			ld (debug_mark+1),a  
3ee3 3a ed 3e			ld a, (.dmark+2)  
3ee6 32 70 fe			ld (debug_mark+2),a  
3ee9 18 03			jr .pastdmark  
3eeb ..			.dmark: db "CLS"  
3eee f1			.pastdmark: pop af  
3eef			endm  
# End of macro DMARK
3eef						CALLMONITOR 
3eef cd f3 18			call break_point_state  
3ef2				endm  
# End of macro CALLMONITOR
3ef2					endif 
3ef2 cd 18 0d				call clear_display 
3ef5 c3 09 40				jp .home		; and home cursor 
3ef8					NEXTW 
3ef8 c3 d5 22			jp macro_next 
3efb				endm 
# End of macro NEXTW
3efb			 
3efb			.DRAW: 
3efb				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3efb 36				db WORD_SYS_CORE+34             
3efc 26 3f			dw .DUMP            
3efe 05				db 4 + 1 
3eff .. 00			db "DRAW",0              
3f04				endm 
# End of macro CWHEAD
3f04			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3f04					if DEBUG_FORTH_WORDS_KEY 
3f04						DMARK "DRW" 
3f04 f5				push af  
3f05 3a 19 3f			ld a, (.dmark)  
3f08 32 6e fe			ld (debug_mark),a  
3f0b 3a 1a 3f			ld a, (.dmark+1)  
3f0e 32 6f fe			ld (debug_mark+1),a  
3f11 3a 1b 3f			ld a, (.dmark+2)  
3f14 32 70 fe			ld (debug_mark+2),a  
3f17 18 03			jr .pastdmark  
3f19 ..			.dmark: db "DRW"  
3f1c f1			.pastdmark: pop af  
3f1d			endm  
# End of macro DMARK
3f1d						CALLMONITOR 
3f1d cd f3 18			call break_point_state  
3f20				endm  
# End of macro CALLMONITOR
3f20					endif 
3f20 cd 3b 0d				call update_display 
3f23					NEXTW 
3f23 c3 d5 22			jp macro_next 
3f26				endm 
# End of macro NEXTW
3f26			 
3f26			.DUMP: 
3f26				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3f26 37				db WORD_SYS_CORE+35             
3f27 5e 3f			dw .CDUMP            
3f29 05				db 4 + 1 
3f2a .. 00			db "DUMP",0              
3f2f				endm 
# End of macro CWHEAD
3f2f			; | DUMP ( x -- ) With address x display dump   | DONE 
3f2f			; TODO pop address to use off of the stack 
3f2f					if DEBUG_FORTH_WORDS_KEY 
3f2f						DMARK "DUM" 
3f2f f5				push af  
3f30 3a 44 3f			ld a, (.dmark)  
3f33 32 6e fe			ld (debug_mark),a  
3f36 3a 45 3f			ld a, (.dmark+1)  
3f39 32 6f fe			ld (debug_mark+1),a  
3f3c 3a 46 3f			ld a, (.dmark+2)  
3f3f 32 70 fe			ld (debug_mark+2),a  
3f42 18 03			jr .pastdmark  
3f44 ..			.dmark: db "DUM"  
3f47 f1			.pastdmark: pop af  
3f48			endm  
# End of macro DMARK
3f48						CALLMONITOR 
3f48 cd f3 18			call break_point_state  
3f4b				endm  
# End of macro CALLMONITOR
3f4b					endif 
3f4b cd 18 0d				call clear_display 
3f4e			 
3f4e					; get address 
3f4e			 
3f4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f4e cd 5e 21			call macro_dsp_valuehl 
3f51				endm 
# End of macro FORTH_DSP_VALUEHL
3f51				 
3f51					; save it for cdump 
3f51			 
3f51 22 1f f5				ld (os_cur_ptr),hl 
3f54			 
3f54					; destroy value TOS 
3f54			 
3f54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f54 cd 16 22			call macro_forth_dsp_pop 
3f57				endm 
# End of macro FORTH_DSP_POP
3f57			 
3f57 cd e7 1d				call dumpcont	; skip old style of param parsing	 
3f5a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3f5b					NEXTW 
3f5b c3 d5 22			jp macro_next 
3f5e				endm 
# End of macro NEXTW
3f5e			.CDUMP: 
3f5e				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3f5e 38				db WORD_SYS_CORE+36             
3f5f 8e 3f			dw .DAT            
3f61 06				db 5 + 1 
3f62 .. 00			db "CDUMP",0              
3f68				endm 
# End of macro CWHEAD
3f68			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3f68					if DEBUG_FORTH_WORDS_KEY 
3f68						DMARK "CDP" 
3f68 f5				push af  
3f69 3a 7d 3f			ld a, (.dmark)  
3f6c 32 6e fe			ld (debug_mark),a  
3f6f 3a 7e 3f			ld a, (.dmark+1)  
3f72 32 6f fe			ld (debug_mark+1),a  
3f75 3a 7f 3f			ld a, (.dmark+2)  
3f78 32 70 fe			ld (debug_mark+2),a  
3f7b 18 03			jr .pastdmark  
3f7d ..			.dmark: db "CDP"  
3f80 f1			.pastdmark: pop af  
3f81			endm  
# End of macro DMARK
3f81						CALLMONITOR 
3f81 cd f3 18			call break_point_state  
3f84				endm  
# End of macro CALLMONITOR
3f84					endif 
3f84 cd 18 0d				call clear_display 
3f87 cd e7 1d				call dumpcont	 
3f8a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f8b					NEXTW 
3f8b c3 d5 22			jp macro_next 
3f8e				endm 
# End of macro NEXTW
3f8e			 
3f8e			 
3f8e			 
3f8e			 
3f8e			.DAT: 
3f8e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f8e 3d				db WORD_SYS_CORE+41             
3f8f e4 3f			dw .HOME            
3f91 03				db 2 + 1 
3f92 .. 00			db "AT",0              
3f95				endm 
# End of macro CWHEAD
3f95			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f95					if DEBUG_FORTH_WORDS_KEY 
3f95						DMARK "AT." 
3f95 f5				push af  
3f96 3a aa 3f			ld a, (.dmark)  
3f99 32 6e fe			ld (debug_mark),a  
3f9c 3a ab 3f			ld a, (.dmark+1)  
3f9f 32 6f fe			ld (debug_mark+1),a  
3fa2 3a ac 3f			ld a, (.dmark+2)  
3fa5 32 70 fe			ld (debug_mark+2),a  
3fa8 18 03			jr .pastdmark  
3faa ..			.dmark: db "AT."  
3fad f1			.pastdmark: pop af  
3fae			endm  
# End of macro DMARK
3fae						CALLMONITOR 
3fae cd f3 18			call break_point_state  
3fb1				endm  
# End of macro CALLMONITOR
3fb1					endif 
3fb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fb1 cd 5e 21			call macro_dsp_valuehl 
3fb4				endm 
# End of macro FORTH_DSP_VALUEHL
3fb4			 
3fb4			 
3fb4					; TODO save cursor row 
3fb4 7d					ld a,l 
3fb5 fe 02				cp 2 
3fb7 20 04				jr nz, .crow3 
3fb9 3e 28				ld a, display_row_2 
3fbb 18 12				jr .ccol1 
3fbd fe 03		.crow3:		cp 3 
3fbf 20 04				jr nz, .crow4 
3fc1 3e 50				ld a, display_row_3 
3fc3 18 0a				jr .ccol1 
3fc5 fe 04		.crow4:		cp 4 
3fc7 20 04				jr nz, .crow1 
3fc9 3e 78				ld a, display_row_4 
3fcb 18 02				jr .ccol1 
3fcd 3e 00		.crow1:		ld a,display_row_1 
3fcf f5			.ccol1:		push af			; got row offset 
3fd0 6f					ld l,a 
3fd1 26 00				ld h,0 
3fd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd3 cd 16 22			call macro_forth_dsp_pop 
3fd6				endm 
# End of macro FORTH_DSP_POP
3fd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fd6 cd 5e 21			call macro_dsp_valuehl 
3fd9				endm 
# End of macro FORTH_DSP_VALUEHL
3fd9					; TODO save cursor col 
3fd9 f1					pop af 
3fda 85					add l		; add col offset 
3fdb 32 65 fa				ld (f_cursor_ptr), a 
3fde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fde cd 16 22			call macro_forth_dsp_pop 
3fe1				endm 
# End of macro FORTH_DSP_POP
3fe1			 
3fe1					; calculate  
3fe1			 
3fe1					NEXTW 
3fe1 c3 d5 22			jp macro_next 
3fe4				endm 
# End of macro NEXTW
3fe4			 
3fe4			 
3fe4			.HOME: 
3fe4				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3fe4 41				db WORD_SYS_CORE+45             
3fe5 11 40			dw .SPACE            
3fe7 05				db 4 + 1 
3fe8 .. 00			db "HOME",0              
3fed				endm 
# End of macro CWHEAD
3fed			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3fed					if DEBUG_FORTH_WORDS_KEY 
3fed						DMARK "HOM" 
3fed f5				push af  
3fee 3a 02 40			ld a, (.dmark)  
3ff1 32 6e fe			ld (debug_mark),a  
3ff4 3a 03 40			ld a, (.dmark+1)  
3ff7 32 6f fe			ld (debug_mark+1),a  
3ffa 3a 04 40			ld a, (.dmark+2)  
3ffd 32 70 fe			ld (debug_mark+2),a  
4000 18 03			jr .pastdmark  
4002 ..			.dmark: db "HOM"  
4005 f1			.pastdmark: pop af  
4006			endm  
# End of macro DMARK
4006						CALLMONITOR 
4006 cd f3 18			call break_point_state  
4009				endm  
# End of macro CALLMONITOR
4009					endif 
4009 3e 00		.home:		ld a, 0		; and home cursor 
400b 32 65 fa				ld (f_cursor_ptr), a 
400e					NEXTW 
400e c3 d5 22			jp macro_next 
4011				endm 
# End of macro NEXTW
4011			 
4011			 
4011			.SPACE: 
4011				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4011 46				db WORD_SYS_CORE+50             
4012 3f 40			dw .SPACES            
4014 03				db 2 + 1 
4015 .. 00			db "BL",0              
4018				endm 
# End of macro CWHEAD
4018			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4018					if DEBUG_FORTH_WORDS_KEY 
4018						DMARK "BL." 
4018 f5				push af  
4019 3a 2d 40			ld a, (.dmark)  
401c 32 6e fe			ld (debug_mark),a  
401f 3a 2e 40			ld a, (.dmark+1)  
4022 32 6f fe			ld (debug_mark+1),a  
4025 3a 2f 40			ld a, (.dmark+2)  
4028 32 70 fe			ld (debug_mark+2),a  
402b 18 03			jr .pastdmark  
402d ..			.dmark: db "BL."  
4030 f1			.pastdmark: pop af  
4031			endm  
# End of macro DMARK
4031						CALLMONITOR 
4031 cd f3 18			call break_point_state  
4034				endm  
# End of macro CALLMONITOR
4034					endif 
4034 21 3d 40				ld hl, .blstr 
4037 cd d5 1f				call forth_push_str 
403a					 
403a				       NEXTW 
403a c3 d5 22			jp macro_next 
403d				endm 
# End of macro NEXTW
403d			 
403d .. 00		.blstr: db " ", 0 
403f			 
403f			.SPACES: 
403f				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
403f 47				db WORD_SYS_CORE+51             
4040 da 40			dw .SCROLL            
4042 07				db 6 + 1 
4043 .. 00			db "SPACES",0              
404a				endm 
# End of macro CWHEAD
404a			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
404a					if DEBUG_FORTH_WORDS_KEY 
404a						DMARK "SPS" 
404a f5				push af  
404b 3a 5f 40			ld a, (.dmark)  
404e 32 6e fe			ld (debug_mark),a  
4051 3a 60 40			ld a, (.dmark+1)  
4054 32 6f fe			ld (debug_mark+1),a  
4057 3a 61 40			ld a, (.dmark+2)  
405a 32 70 fe			ld (debug_mark+2),a  
405d 18 03			jr .pastdmark  
405f ..			.dmark: db "SPS"  
4062 f1			.pastdmark: pop af  
4063			endm  
# End of macro DMARK
4063						CALLMONITOR 
4063 cd f3 18			call break_point_state  
4066				endm  
# End of macro CALLMONITOR
4066					endif 
4066			 
4066			 
4066					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4066 cd 5e 21			call macro_dsp_valuehl 
4069				endm 
# End of macro FORTH_DSP_VALUEHL
4069			 
4069			;		push hl    ; u 
4069					if DEBUG_FORTH_WORDS 
4069						DMARK "SPA" 
4069 f5				push af  
406a 3a 7e 40			ld a, (.dmark)  
406d 32 6e fe			ld (debug_mark),a  
4070 3a 7f 40			ld a, (.dmark+1)  
4073 32 6f fe			ld (debug_mark+1),a  
4076 3a 80 40			ld a, (.dmark+2)  
4079 32 70 fe			ld (debug_mark+2),a  
407c 18 03			jr .pastdmark  
407e ..			.dmark: db "SPA"  
4081 f1			.pastdmark: pop af  
4082			endm  
# End of macro DMARK
4082						CALLMONITOR 
4082 cd f3 18			call break_point_state  
4085				endm  
# End of macro CALLMONITOR
4085					endif 
4085			 
4085					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4085 cd 16 22			call macro_forth_dsp_pop 
4088				endm 
# End of macro FORTH_DSP_POP
4088			;		pop hl 
4088 4d					ld c, l 
4089 06 00				ld b, 0 
408b 21 fc f1				ld hl, scratch  
408e			 
408e					if DEBUG_FORTH_WORDS 
408e						DMARK "SP2" 
408e f5				push af  
408f 3a a3 40			ld a, (.dmark)  
4092 32 6e fe			ld (debug_mark),a  
4095 3a a4 40			ld a, (.dmark+1)  
4098 32 6f fe			ld (debug_mark+1),a  
409b 3a a5 40			ld a, (.dmark+2)  
409e 32 70 fe			ld (debug_mark+2),a  
40a1 18 03			jr .pastdmark  
40a3 ..			.dmark: db "SP2"  
40a6 f1			.pastdmark: pop af  
40a7			endm  
# End of macro DMARK
40a7						CALLMONITOR 
40a7 cd f3 18			call break_point_state  
40aa				endm  
# End of macro CALLMONITOR
40aa					endif 
40aa 3e 20				ld a, ' ' 
40ac c5			.spaces1:	push bc 
40ad 77					ld (hl),a 
40ae 23					inc hl 
40af c1					pop bc 
40b0 10 fa				djnz .spaces1 
40b2 3e 00				ld a,0 
40b4 77					ld (hl),a 
40b5 21 fc f1				ld hl, scratch 
40b8					if DEBUG_FORTH_WORDS 
40b8						DMARK "SP3" 
40b8 f5				push af  
40b9 3a cd 40			ld a, (.dmark)  
40bc 32 6e fe			ld (debug_mark),a  
40bf 3a ce 40			ld a, (.dmark+1)  
40c2 32 6f fe			ld (debug_mark+1),a  
40c5 3a cf 40			ld a, (.dmark+2)  
40c8 32 70 fe			ld (debug_mark+2),a  
40cb 18 03			jr .pastdmark  
40cd ..			.dmark: db "SP3"  
40d0 f1			.pastdmark: pop af  
40d1			endm  
# End of macro DMARK
40d1						CALLMONITOR 
40d1 cd f3 18			call break_point_state  
40d4				endm  
# End of macro CALLMONITOR
40d4					endif 
40d4 cd d0 20				call forth_apush 
40d7			 
40d7				       NEXTW 
40d7 c3 d5 22			jp macro_next 
40da				endm 
# End of macro NEXTW
40da			 
40da			 
40da			 
40da			.SCROLL: 
40da				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
40da 53				db WORD_SYS_CORE+63             
40db 07 41			dw .SCROLLD            
40dd 07				db 6 + 1 
40de .. 00			db "SCROLL",0              
40e5				endm 
# End of macro CWHEAD
40e5			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
40e5					if DEBUG_FORTH_WORDS_KEY 
40e5						DMARK "SCR" 
40e5 f5				push af  
40e6 3a fa 40			ld a, (.dmark)  
40e9 32 6e fe			ld (debug_mark),a  
40ec 3a fb 40			ld a, (.dmark+1)  
40ef 32 6f fe			ld (debug_mark+1),a  
40f2 3a fc 40			ld a, (.dmark+2)  
40f5 32 70 fe			ld (debug_mark+2),a  
40f8 18 03			jr .pastdmark  
40fa ..			.dmark: db "SCR"  
40fd f1			.pastdmark: pop af  
40fe			endm  
# End of macro DMARK
40fe						CALLMONITOR 
40fe cd f3 18			call break_point_state  
4101				endm  
# End of macro CALLMONITOR
4101					endif 
4101			 
4101 cd da 0c			call scroll_up 
4104			;	call update_display 
4104			 
4104					NEXTW 
4104 c3 d5 22			jp macro_next 
4107				endm 
# End of macro NEXTW
4107			 
4107			 
4107			 
4107			;		; get dir 
4107			; 
4107			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4107			; 
4107			;		push hl 
4107			; 
4107			;		; destroy value TOS 
4107			; 
4107			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4107			; 
4107			;		; get count 
4107			; 
4107			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4107			; 
4107			;		push hl 
4107			; 
4107			;		; destroy value TOS 
4107			; 
4107			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4107			; 
4107			;		; one value on hl get other one back 
4107			; 
4107			;		pop bc    ; count 
4107			; 
4107			;		pop de   ; dir 
4107			; 
4107			; 
4107			;		ld b, c 
4107			; 
4107			;.scrolldir:     push bc 
4107			;		push de 
4107			; 
4107			;		ld a, 0 
4107			;		cp e 
4107			;		jr z, .scrollup  
4107			;		call scroll_down 
4107			;		jr .scrollnext 
4107			;.scrollup:	call scroll_up 
4107			; 
4107			;		 
4107			;.scrollnext: 
4107			;		pop de 
4107			;		pop bc 
4107			;		djnz .scrolldir 
4107			; 
4107			; 
4107			; 
4107			; 
4107			; 
4107			;		NEXTW 
4107			 
4107			.SCROLLD: 
4107				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4107 53				db WORD_SYS_CORE+63             
4108 35 41			dw .ATQ            
410a 08				db 7 + 1 
410b .. 00			db "SCROLLD",0              
4113				endm 
# End of macro CWHEAD
4113			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4113					if DEBUG_FORTH_WORDS_KEY 
4113						DMARK "SCD" 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 6e fe			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 6f fe			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 70 fe			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "SCD"  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd f3 18			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f			 
412f cd fe 0c			call scroll_down 
4132			;	call update_display 
4132			 
4132					NEXTW 
4132 c3 d5 22			jp macro_next 
4135				endm 
# End of macro NEXTW
4135			 
4135			 
4135			.ATQ: 
4135				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4135 62				db WORD_SYS_CORE+78             
4136 93 41			dw .AUTODSP            
4138 04				db 3 + 1 
4139 .. 00			db "AT@",0              
413d				endm 
# End of macro CWHEAD
413d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
413d					if DEBUG_FORTH_WORDS_KEY 
413d						DMARK "ATA" 
413d f5				push af  
413e 3a 52 41			ld a, (.dmark)  
4141 32 6e fe			ld (debug_mark),a  
4144 3a 53 41			ld a, (.dmark+1)  
4147 32 6f fe			ld (debug_mark+1),a  
414a 3a 54 41			ld a, (.dmark+2)  
414d 32 70 fe			ld (debug_mark+2),a  
4150 18 03			jr .pastdmark  
4152 ..			.dmark: db "ATA"  
4155 f1			.pastdmark: pop af  
4156			endm  
# End of macro DMARK
4156						CALLMONITOR 
4156 cd f3 18			call break_point_state  
4159				endm  
# End of macro CALLMONITOR
4159					endif 
4159			 
4159			 
4159					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4159 cd 5e 21			call macro_dsp_valuehl 
415c				endm 
# End of macro FORTH_DSP_VALUEHL
415c			 
415c					; TODO save cursor row 
415c 7d					ld a,l 
415d fe 02				cp 2 
415f 20 04				jr nz, .crow3aq 
4161 3e 28				ld a, display_row_2 
4163 18 12				jr .ccol1aq 
4165 fe 03		.crow3aq:		cp 3 
4167 20 04				jr nz, .crow4aq 
4169 3e 50				ld a, display_row_3 
416b 18 0a				jr .ccol1aq 
416d fe 04		.crow4aq:		cp 4 
416f 20 04				jr nz, .crow1aq 
4171 3e 78				ld a, display_row_4 
4173 18 02				jr .ccol1aq 
4175 3e 00		.crow1aq:		ld a,display_row_1 
4177 f5			.ccol1aq:		push af			; got row offset 
4178 6f					ld l,a 
4179 26 00				ld h,0 
417b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
417b cd 16 22			call macro_forth_dsp_pop 
417e				endm 
# End of macro FORTH_DSP_POP
417e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
417e cd 5e 21			call macro_dsp_valuehl 
4181				endm 
# End of macro FORTH_DSP_VALUEHL
4181					; TODO save cursor col 
4181 f1					pop af 
4182 85					add l		; add col offset 
4183			 
4183					; add current frame buffer address 
4183 2a cf fb				ld hl, (display_fb_active) 
4186 cd 4c 0f				call addatohl 
4189			 
4189			 
4189			 
4189			 
4189					; get char frame buffer location offset in hl 
4189			 
4189 7e					ld a,(hl) 
418a 26 00				ld h, 0 
418c 6f					ld l, a 
418d			 
418d cd 67 1f				call forth_push_numhl 
4190			 
4190			 
4190					NEXTW 
4190 c3 d5 22			jp macro_next 
4193				endm 
# End of macro NEXTW
4193			 
4193			.AUTODSP: 
4193				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4193 63				db WORD_SYS_CORE+79             
4194 a9 41			dw .MENU            
4196 05				db 4 + 1 
4197 .. 00			db "ADSP",0              
419c				endm 
# End of macro CWHEAD
419c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
419c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
419c			 
419c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
419c cd 5e 21			call macro_dsp_valuehl 
419f				endm 
# End of macro FORTH_DSP_VALUEHL
419f			 
419f			;		push hl 
419f			 
419f					; destroy value TOS 
419f			 
419f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
419f cd 16 22			call macro_forth_dsp_pop 
41a2				endm 
# End of macro FORTH_DSP_POP
41a2			 
41a2			;		pop hl 
41a2			 
41a2 7d					ld a,l 
41a3 32 43 fa				ld (cli_autodisplay), a 
41a6				       NEXTW 
41a6 c3 d5 22			jp macro_next 
41a9				endm 
# End of macro NEXTW
41a9			 
41a9			.MENU: 
41a9				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
41a9 70				db WORD_SYS_CORE+92             
41aa 52 42			dw .ENDDISPLAY            
41ac 05				db 4 + 1 
41ad .. 00			db "MENU",0              
41b2				endm 
# End of macro CWHEAD
41b2			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
41b2			 
41b2			;		; get number of items on the stack 
41b2			; 
41b2				 
41b2					FORTH_DSP_VALUEHL 
41b2 cd 5e 21			call macro_dsp_valuehl 
41b5				endm 
# End of macro FORTH_DSP_VALUEHL
41b5				 
41b5					if DEBUG_FORTH_WORDS_KEY 
41b5						DMARK "MNU" 
41b5 f5				push af  
41b6 3a ca 41			ld a, (.dmark)  
41b9 32 6e fe			ld (debug_mark),a  
41bc 3a cb 41			ld a, (.dmark+1)  
41bf 32 6f fe			ld (debug_mark+1),a  
41c2 3a cc 41			ld a, (.dmark+2)  
41c5 32 70 fe			ld (debug_mark+2),a  
41c8 18 03			jr .pastdmark  
41ca ..			.dmark: db "MNU"  
41cd f1			.pastdmark: pop af  
41ce			endm  
# End of macro DMARK
41ce						CALLMONITOR 
41ce cd f3 18			call break_point_state  
41d1				endm  
# End of macro CALLMONITOR
41d1					endif 
41d1			 
41d1 45					ld b, l	 
41d2 05					dec b 
41d3			 
41d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41d3 cd 16 22			call macro_forth_dsp_pop 
41d6				endm 
# End of macro FORTH_DSP_POP
41d6			 
41d6			 
41d6					; go directly through the stack to pluck out the string pointers and build an array 
41d6			 
41d6			;		FORTH_DSP 
41d6			 
41d6					; hl contains top most stack item 
41d6				 
41d6 11 fc f1				ld de, scratch 
41d9			 
41d9			.mbuild: 
41d9			 
41d9					FORTH_DSP_VALUEHL 
41d9 cd 5e 21			call macro_dsp_valuehl 
41dc				endm 
# End of macro FORTH_DSP_VALUEHL
41dc			 
41dc					if DEBUG_FORTH_WORDS 
41dc						DMARK "MN3" 
41dc f5				push af  
41dd 3a f1 41			ld a, (.dmark)  
41e0 32 6e fe			ld (debug_mark),a  
41e3 3a f2 41			ld a, (.dmark+1)  
41e6 32 6f fe			ld (debug_mark+1),a  
41e9 3a f3 41			ld a, (.dmark+2)  
41ec 32 70 fe			ld (debug_mark+2),a  
41ef 18 03			jr .pastdmark  
41f1 ..			.dmark: db "MN3"  
41f4 f1			.pastdmark: pop af  
41f5			endm  
# End of macro DMARK
41f5						CALLMONITOR 
41f5 cd f3 18			call break_point_state  
41f8				endm  
# End of macro CALLMONITOR
41f8					endif 
41f8 eb					ex de, hl 
41f9 73					ld (hl), e 
41fa 23					inc hl 
41fb 72					ld (hl), d 
41fc 23					inc hl 
41fd eb					ex de, hl 
41fe			 
41fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41fe cd 16 22			call macro_forth_dsp_pop 
4201				endm 
# End of macro FORTH_DSP_POP
4201			 
4201 10 d6				djnz .mbuild 
4203			 
4203					; done add term 
4203			 
4203 eb					ex de, hl 
4204 36 00				ld (hl), 0 
4206 23					inc hl 
4207 36 00				ld (hl), 0 
4209			 
4209				 
4209					 
4209 21 fc f1				ld hl, scratch 
420c			 
420c					if DEBUG_FORTH_WORDS 
420c						DMARK "MNx" 
420c f5				push af  
420d 3a 21 42			ld a, (.dmark)  
4210 32 6e fe			ld (debug_mark),a  
4213 3a 22 42			ld a, (.dmark+1)  
4216 32 6f fe			ld (debug_mark+1),a  
4219 3a 23 42			ld a, (.dmark+2)  
421c 32 70 fe			ld (debug_mark+2),a  
421f 18 03			jr .pastdmark  
4221 ..			.dmark: db "MNx"  
4224 f1			.pastdmark: pop af  
4225			endm  
# End of macro DMARK
4225						CALLMONITOR 
4225 cd f3 18			call break_point_state  
4228				endm  
# End of macro CALLMONITOR
4228					endif 
4228			 
4228			 
4228			 
4228 3e 00				ld a, 0 
422a cd 49 0d				call menu 
422d			 
422d			 
422d 6f					ld l, a 
422e 26 00				ld h, 0 
4230			 
4230					if DEBUG_FORTH_WORDS 
4230						DMARK "MNr" 
4230 f5				push af  
4231 3a 45 42			ld a, (.dmark)  
4234 32 6e fe			ld (debug_mark),a  
4237 3a 46 42			ld a, (.dmark+1)  
423a 32 6f fe			ld (debug_mark+1),a  
423d 3a 47 42			ld a, (.dmark+2)  
4240 32 70 fe			ld (debug_mark+2),a  
4243 18 03			jr .pastdmark  
4245 ..			.dmark: db "MNr"  
4248 f1			.pastdmark: pop af  
4249			endm  
# End of macro DMARK
4249						CALLMONITOR 
4249 cd f3 18			call break_point_state  
424c				endm  
# End of macro CALLMONITOR
424c					endif 
424c			 
424c cd 67 1f				call forth_push_numhl 
424f			 
424f			 
424f			 
424f			 
424f				       NEXTW 
424f c3 d5 22			jp macro_next 
4252				endm 
# End of macro NEXTW
4252			 
4252			 
4252			.ENDDISPLAY: 
4252			 
4252			; eof 
# End of file forth_words_display.asm
4252			include "forth_words_str.asm" 
4252			 
4252			; | ## String Words 
4252			 
4252			.PTR:   
4252			 
4252				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4252 48				db WORD_SYS_CORE+52             
4253 7f 42			dw .STYPE            
4255 04				db 3 + 1 
4256 .. 00			db "PTR",0              
425a				endm 
# End of macro CWHEAD
425a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
425a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
425a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
425a			 
425a					if DEBUG_FORTH_WORDS_KEY 
425a						DMARK "PTR" 
425a f5				push af  
425b 3a 6f 42			ld a, (.dmark)  
425e 32 6e fe			ld (debug_mark),a  
4261 3a 70 42			ld a, (.dmark+1)  
4264 32 6f fe			ld (debug_mark+1),a  
4267 3a 71 42			ld a, (.dmark+2)  
426a 32 70 fe			ld (debug_mark+2),a  
426d 18 03			jr .pastdmark  
426f ..			.dmark: db "PTR"  
4272 f1			.pastdmark: pop af  
4273			endm  
# End of macro DMARK
4273						CALLMONITOR 
4273 cd f3 18			call break_point_state  
4276				endm  
# End of macro CALLMONITOR
4276					endif 
4276					FORTH_DSP_VALUEHL 
4276 cd 5e 21			call macro_dsp_valuehl 
4279				endm 
# End of macro FORTH_DSP_VALUEHL
4279 cd 67 1f				call forth_push_numhl 
427c			 
427c			 
427c					NEXTW 
427c c3 d5 22			jp macro_next 
427f				endm 
# End of macro NEXTW
427f			.STYPE: 
427f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
427f 48				db WORD_SYS_CORE+52             
4280 ce 42			dw .UPPER            
4282 06				db 5 + 1 
4283 .. 00			db "STYPE",0              
4289				endm 
# End of macro CWHEAD
4289			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4289					if DEBUG_FORTH_WORDS_KEY 
4289						DMARK "STY" 
4289 f5				push af  
428a 3a 9e 42			ld a, (.dmark)  
428d 32 6e fe			ld (debug_mark),a  
4290 3a 9f 42			ld a, (.dmark+1)  
4293 32 6f fe			ld (debug_mark+1),a  
4296 3a a0 42			ld a, (.dmark+2)  
4299 32 70 fe			ld (debug_mark+2),a  
429c 18 03			jr .pastdmark  
429e ..			.dmark: db "STY"  
42a1 f1			.pastdmark: pop af  
42a2			endm  
# End of macro DMARK
42a2						CALLMONITOR 
42a2 cd f3 18			call break_point_state  
42a5				endm  
# End of macro CALLMONITOR
42a5					endif 
42a5					FORTH_DSP 
42a5 cd 24 21			call macro_forth_dsp 
42a8				endm 
# End of macro FORTH_DSP
42a8					;v5 FORTH_DSP_VALUE 
42a8			 
42a8 7e					ld a, (hl) 
42a9			 
42a9 f5					push af 
42aa			 
42aa			; Dont destroy TOS		FORTH_DSP_POP 
42aa			 
42aa f1					pop af 
42ab			 
42ab fe 01				cp DS_TYPE_STR 
42ad 28 09				jr z, .typestr 
42af			 
42af fe 02				cp DS_TYPE_INUM 
42b1 28 0a				jr z, .typeinum 
42b3			 
42b3 21 cc 42				ld hl, .tna 
42b6 18 0a				jr .tpush 
42b8			 
42b8 21 c8 42		.typestr:	ld hl, .tstr 
42bb 18 05				jr .tpush 
42bd 21 ca 42		.typeinum:	ld hl, .tinum 
42c0 18 00				jr .tpush 
42c2			 
42c2			.tpush: 
42c2			 
42c2 cd d5 1f				call forth_push_str 
42c5			 
42c5					NEXTW 
42c5 c3 d5 22			jp macro_next 
42c8				endm 
# End of macro NEXTW
42c8 .. 00		.tstr:	db "s",0 
42ca .. 00		.tinum:  db "i",0 
42cc .. 00		.tna:   db "?", 0 
42ce			 
42ce			 
42ce			.UPPER: 
42ce				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
42ce 48				db WORD_SYS_CORE+52             
42cf 09 43			dw .LOWER            
42d1 06				db 5 + 1 
42d2 .. 00			db "UPPER",0              
42d8				endm 
# End of macro CWHEAD
42d8			; | UPPER ( s -- s ) Upper case string s  | DONE 
42d8					if DEBUG_FORTH_WORDS_KEY 
42d8						DMARK "UPR" 
42d8 f5				push af  
42d9 3a ed 42			ld a, (.dmark)  
42dc 32 6e fe			ld (debug_mark),a  
42df 3a ee 42			ld a, (.dmark+1)  
42e2 32 6f fe			ld (debug_mark+1),a  
42e5 3a ef 42			ld a, (.dmark+2)  
42e8 32 70 fe			ld (debug_mark+2),a  
42eb 18 03			jr .pastdmark  
42ed ..			.dmark: db "UPR"  
42f0 f1			.pastdmark: pop af  
42f1			endm  
# End of macro DMARK
42f1						CALLMONITOR 
42f1 cd f3 18			call break_point_state  
42f4				endm  
# End of macro CALLMONITOR
42f4					endif 
42f4			 
42f4					FORTH_DSP 
42f4 cd 24 21			call macro_forth_dsp 
42f7				endm 
# End of macro FORTH_DSP
42f7					 
42f7			; TODO check is string type 
42f7			 
42f7					FORTH_DSP_VALUEHL 
42f7 cd 5e 21			call macro_dsp_valuehl 
42fa				endm 
# End of macro FORTH_DSP_VALUEHL
42fa			; get pointer to string in hl 
42fa			 
42fa 7e			.toup:		ld a, (hl) 
42fb fe 00				cp 0 
42fd 28 07				jr z, .toupdone 
42ff			 
42ff cd b9 12				call to_upper 
4302			 
4302 77					ld (hl), a 
4303 23					inc hl 
4304 18 f4				jr .toup 
4306			 
4306					 
4306			 
4306			 
4306			; for each char convert to upper 
4306					 
4306			.toupdone: 
4306			 
4306			 
4306					NEXTW 
4306 c3 d5 22			jp macro_next 
4309				endm 
# End of macro NEXTW
4309			.LOWER: 
4309				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4309 48				db WORD_SYS_CORE+52             
430a 44 43			dw .TCASE            
430c 06				db 5 + 1 
430d .. 00			db "LOWER",0              
4313				endm 
# End of macro CWHEAD
4313			; | LOWER ( s -- s ) Lower case string s  | DONE 
4313					if DEBUG_FORTH_WORDS_KEY 
4313						DMARK "LWR" 
4313 f5				push af  
4314 3a 28 43			ld a, (.dmark)  
4317 32 6e fe			ld (debug_mark),a  
431a 3a 29 43			ld a, (.dmark+1)  
431d 32 6f fe			ld (debug_mark+1),a  
4320 3a 2a 43			ld a, (.dmark+2)  
4323 32 70 fe			ld (debug_mark+2),a  
4326 18 03			jr .pastdmark  
4328 ..			.dmark: db "LWR"  
432b f1			.pastdmark: pop af  
432c			endm  
# End of macro DMARK
432c						CALLMONITOR 
432c cd f3 18			call break_point_state  
432f				endm  
# End of macro CALLMONITOR
432f					endif 
432f			 
432f					FORTH_DSP 
432f cd 24 21			call macro_forth_dsp 
4332				endm 
# End of macro FORTH_DSP
4332					 
4332			; TODO check is string type 
4332			 
4332					FORTH_DSP_VALUEHL 
4332 cd 5e 21			call macro_dsp_valuehl 
4335				endm 
# End of macro FORTH_DSP_VALUEHL
4335			; get pointer to string in hl 
4335			 
4335 7e			.tolow:		ld a, (hl) 
4336 fe 00				cp 0 
4338 28 07				jr z, .tolowdone 
433a			 
433a cd c2 12				call to_lower 
433d			 
433d 77					ld (hl), a 
433e 23					inc hl 
433f 18 f4				jr .tolow 
4341			 
4341					 
4341			 
4341			 
4341			; for each char convert to low 
4341					 
4341			.tolowdone: 
4341					NEXTW 
4341 c3 d5 22			jp macro_next 
4344				endm 
# End of macro NEXTW
4344			.TCASE: 
4344				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4344 48				db WORD_SYS_CORE+52             
4345 7a 44			dw .SUBSTR            
4347 06				db 5 + 1 
4348 .. 00			db "TCASE",0              
434e				endm 
# End of macro CWHEAD
434e			; | TCASE ( s -- s ) Title case string s  | DONE 
434e					if DEBUG_FORTH_WORDS_KEY 
434e						DMARK "TCS" 
434e f5				push af  
434f 3a 63 43			ld a, (.dmark)  
4352 32 6e fe			ld (debug_mark),a  
4355 3a 64 43			ld a, (.dmark+1)  
4358 32 6f fe			ld (debug_mark+1),a  
435b 3a 65 43			ld a, (.dmark+2)  
435e 32 70 fe			ld (debug_mark+2),a  
4361 18 03			jr .pastdmark  
4363 ..			.dmark: db "TCS"  
4366 f1			.pastdmark: pop af  
4367			endm  
# End of macro DMARK
4367						CALLMONITOR 
4367 cd f3 18			call break_point_state  
436a				endm  
# End of macro CALLMONITOR
436a					endif 
436a			 
436a					FORTH_DSP 
436a cd 24 21			call macro_forth_dsp 
436d				endm 
# End of macro FORTH_DSP
436d					 
436d			; TODO check is string type 
436d			 
436d					FORTH_DSP_VALUEHL 
436d cd 5e 21			call macro_dsp_valuehl 
4370				endm 
# End of macro FORTH_DSP_VALUEHL
4370			; get pointer to string in hl 
4370			 
4370					if DEBUG_FORTH_WORDS 
4370						DMARK "TC1" 
4370 f5				push af  
4371 3a 85 43			ld a, (.dmark)  
4374 32 6e fe			ld (debug_mark),a  
4377 3a 86 43			ld a, (.dmark+1)  
437a 32 6f fe			ld (debug_mark+1),a  
437d 3a 87 43			ld a, (.dmark+2)  
4380 32 70 fe			ld (debug_mark+2),a  
4383 18 03			jr .pastdmark  
4385 ..			.dmark: db "TC1"  
4388 f1			.pastdmark: pop af  
4389			endm  
# End of macro DMARK
4389						CALLMONITOR 
4389 cd f3 18			call break_point_state  
438c				endm  
# End of macro CALLMONITOR
438c					endif 
438c			 
438c					; first time in turn to upper case first char 
438c			 
438c 7e					ld a, (hl) 
438d c3 17 44				jp .totsiptou 
4390			 
4390			 
4390 7e			.tot:		ld a, (hl) 
4391 fe 00				cp 0 
4393 ca 5b 44				jp z, .totdone 
4396			 
4396					if DEBUG_FORTH_WORDS 
4396						DMARK "TC2" 
4396 f5				push af  
4397 3a ab 43			ld a, (.dmark)  
439a 32 6e fe			ld (debug_mark),a  
439d 3a ac 43			ld a, (.dmark+1)  
43a0 32 6f fe			ld (debug_mark+1),a  
43a3 3a ad 43			ld a, (.dmark+2)  
43a6 32 70 fe			ld (debug_mark+2),a  
43a9 18 03			jr .pastdmark  
43ab ..			.dmark: db "TC2"  
43ae f1			.pastdmark: pop af  
43af			endm  
# End of macro DMARK
43af						CALLMONITOR 
43af cd f3 18			call break_point_state  
43b2				endm  
# End of macro CALLMONITOR
43b2					endif 
43b2					; check to see if current char is a space 
43b2			 
43b2 fe 20				cp ' ' 
43b4 28 21				jr z, .totsp 
43b6 cd c2 12				call to_lower 
43b9					if DEBUG_FORTH_WORDS 
43b9						DMARK "TC3" 
43b9 f5				push af  
43ba 3a ce 43			ld a, (.dmark)  
43bd 32 6e fe			ld (debug_mark),a  
43c0 3a cf 43			ld a, (.dmark+1)  
43c3 32 6f fe			ld (debug_mark+1),a  
43c6 3a d0 43			ld a, (.dmark+2)  
43c9 32 70 fe			ld (debug_mark+2),a  
43cc 18 03			jr .pastdmark  
43ce ..			.dmark: db "TC3"  
43d1 f1			.pastdmark: pop af  
43d2			endm  
# End of macro DMARK
43d2						CALLMONITOR 
43d2 cd f3 18			call break_point_state  
43d5				endm  
# End of macro CALLMONITOR
43d5					endif 
43d5 18 63				jr .totnxt 
43d7			 
43d7			.totsp:         ; on a space, find next char which should be upper 
43d7			 
43d7					if DEBUG_FORTH_WORDS 
43d7						DMARK "TC4" 
43d7 f5				push af  
43d8 3a ec 43			ld a, (.dmark)  
43db 32 6e fe			ld (debug_mark),a  
43de 3a ed 43			ld a, (.dmark+1)  
43e1 32 6f fe			ld (debug_mark+1),a  
43e4 3a ee 43			ld a, (.dmark+2)  
43e7 32 70 fe			ld (debug_mark+2),a  
43ea 18 03			jr .pastdmark  
43ec ..			.dmark: db "TC4"  
43ef f1			.pastdmark: pop af  
43f0			endm  
# End of macro DMARK
43f0						CALLMONITOR 
43f0 cd f3 18			call break_point_state  
43f3				endm  
# End of macro CALLMONITOR
43f3					endif 
43f3					;; 
43f3			 
43f3 fe 20				cp ' ' 
43f5 20 20				jr nz, .totsiptou 
43f7 23					inc hl 
43f8 7e					ld a, (hl) 
43f9					if DEBUG_FORTH_WORDS 
43f9						DMARK "TC5" 
43f9 f5				push af  
43fa 3a 0e 44			ld a, (.dmark)  
43fd 32 6e fe			ld (debug_mark),a  
4400 3a 0f 44			ld a, (.dmark+1)  
4403 32 6f fe			ld (debug_mark+1),a  
4406 3a 10 44			ld a, (.dmark+2)  
4409 32 70 fe			ld (debug_mark+2),a  
440c 18 03			jr .pastdmark  
440e ..			.dmark: db "TC5"  
4411 f1			.pastdmark: pop af  
4412			endm  
# End of macro DMARK
4412						CALLMONITOR 
4412 cd f3 18			call break_point_state  
4415				endm  
# End of macro CALLMONITOR
4415					endif 
4415 18 c0				jr .totsp 
4417 fe 00		.totsiptou:    cp 0 
4419 28 40				jr z, .totdone 
441b					; not space and not zero term so upper case it 
441b cd b9 12				call to_upper 
441e			 
441e					if DEBUG_FORTH_WORDS 
441e						DMARK "TC6" 
441e f5				push af  
441f 3a 33 44			ld a, (.dmark)  
4422 32 6e fe			ld (debug_mark),a  
4425 3a 34 44			ld a, (.dmark+1)  
4428 32 6f fe			ld (debug_mark+1),a  
442b 3a 35 44			ld a, (.dmark+2)  
442e 32 70 fe			ld (debug_mark+2),a  
4431 18 03			jr .pastdmark  
4433 ..			.dmark: db "TC6"  
4436 f1			.pastdmark: pop af  
4437			endm  
# End of macro DMARK
4437						CALLMONITOR 
4437 cd f3 18			call break_point_state  
443a				endm  
# End of macro CALLMONITOR
443a					endif 
443a			 
443a			 
443a			.totnxt: 
443a			 
443a 77					ld (hl), a 
443b 23					inc hl 
443c					if DEBUG_FORTH_WORDS 
443c						DMARK "TC7" 
443c f5				push af  
443d 3a 51 44			ld a, (.dmark)  
4440 32 6e fe			ld (debug_mark),a  
4443 3a 52 44			ld a, (.dmark+1)  
4446 32 6f fe			ld (debug_mark+1),a  
4449 3a 53 44			ld a, (.dmark+2)  
444c 32 70 fe			ld (debug_mark+2),a  
444f 18 03			jr .pastdmark  
4451 ..			.dmark: db "TC7"  
4454 f1			.pastdmark: pop af  
4455			endm  
# End of macro DMARK
4455						CALLMONITOR 
4455 cd f3 18			call break_point_state  
4458				endm  
# End of macro CALLMONITOR
4458					endif 
4458 c3 90 43				jp .tot 
445b			 
445b					 
445b			 
445b			 
445b			; for each char convert to low 
445b					 
445b			.totdone: 
445b					if DEBUG_FORTH_WORDS 
445b						DMARK "TCd" 
445b f5				push af  
445c 3a 70 44			ld a, (.dmark)  
445f 32 6e fe			ld (debug_mark),a  
4462 3a 71 44			ld a, (.dmark+1)  
4465 32 6f fe			ld (debug_mark+1),a  
4468 3a 72 44			ld a, (.dmark+2)  
446b 32 70 fe			ld (debug_mark+2),a  
446e 18 03			jr .pastdmark  
4470 ..			.dmark: db "TCd"  
4473 f1			.pastdmark: pop af  
4474			endm  
# End of macro DMARK
4474						CALLMONITOR 
4474 cd f3 18			call break_point_state  
4477				endm  
# End of macro CALLMONITOR
4477					endif 
4477					NEXTW 
4477 c3 d5 22			jp macro_next 
447a				endm 
# End of macro NEXTW
447a			 
447a			.SUBSTR: 
447a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
447a 48				db WORD_SYS_CORE+52             
447b d8 44			dw .LEFT            
447d 07				db 6 + 1 
447e .. 00			db "SUBSTR",0              
4485				endm 
# End of macro CWHEAD
4485			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4485			 
4485					if DEBUG_FORTH_WORDS_KEY 
4485						DMARK "SST" 
4485 f5				push af  
4486 3a 9a 44			ld a, (.dmark)  
4489 32 6e fe			ld (debug_mark),a  
448c 3a 9b 44			ld a, (.dmark+1)  
448f 32 6f fe			ld (debug_mark+1),a  
4492 3a 9c 44			ld a, (.dmark+2)  
4495 32 70 fe			ld (debug_mark+2),a  
4498 18 03			jr .pastdmark  
449a ..			.dmark: db "SST"  
449d f1			.pastdmark: pop af  
449e			endm  
# End of macro DMARK
449e						CALLMONITOR 
449e cd f3 18			call break_point_state  
44a1				endm  
# End of macro CALLMONITOR
44a1					endif 
44a1			; TODO check string type 
44a1					FORTH_DSP_VALUEHL 
44a1 cd 5e 21			call macro_dsp_valuehl 
44a4				endm 
# End of macro FORTH_DSP_VALUEHL
44a4			 
44a4 e5					push hl      ; string length 
44a5			 
44a5					FORTH_DSP_POP 
44a5 cd 16 22			call macro_forth_dsp_pop 
44a8				endm 
# End of macro FORTH_DSP_POP
44a8			 
44a8					FORTH_DSP_VALUEHL 
44a8 cd 5e 21			call macro_dsp_valuehl 
44ab				endm 
# End of macro FORTH_DSP_VALUEHL
44ab			 
44ab e5					push hl     ; start char 
44ac			 
44ac					FORTH_DSP_POP 
44ac cd 16 22			call macro_forth_dsp_pop 
44af				endm 
# End of macro FORTH_DSP_POP
44af			 
44af			 
44af					FORTH_DSP_VALUE 
44af cd 47 21			call macro_forth_dsp_value 
44b2				endm 
# End of macro FORTH_DSP_VALUE
44b2			 
44b2 d1					pop de    ; get start post offset 
44b3			 
44b3 19					add hl, de    ; starting offset 
44b4			 
44b4 c1					pop bc 
44b5 c5					push bc      ; grab size of string 
44b6			 
44b6 e5					push hl    ; save string start  
44b7			 
44b7 26 00				ld h, 0 
44b9 69					ld l, c 
44ba 23					inc hl 
44bb 23					inc hl 
44bc			 
44bc cd 13 14				call malloc 
44bf				if DEBUG_FORTH_MALLOC_GUARD 
44bf cc 9b 56				call z,malloc_error 
44c2				endif 
44c2			 
44c2 eb					ex de, hl      ; save malloc area for string copy 
44c3 e1					pop hl    ; get back source 
44c4 c1					pop bc    ; get length of string back 
44c5			 
44c5 d5					push de    ; save malloc area for after we push 
44c6 ed b0				ldir     ; copy substr 
44c8			 
44c8			 
44c8 eb					ex de, hl 
44c9 3e 00				ld a, 0 
44cb 77					ld (hl), a   ; term substr 
44cc			 
44cc					 
44cc e1					pop hl    ; get malloc so we can push it 
44cd e5					push hl   ; save so we can free it afterwards 
44ce			 
44ce cd d5 1f				call forth_push_str 
44d1			 
44d1 e1					pop hl 
44d2 cd dd 14				call free 
44d5			 
44d5					 
44d5					 
44d5			 
44d5			 
44d5					NEXTW 
44d5 c3 d5 22			jp macro_next 
44d8				endm 
# End of macro NEXTW
44d8			 
44d8			.LEFT: 
44d8				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
44d8 48				db WORD_SYS_CORE+52             
44d9 00 45			dw .RIGHT            
44db 05				db 4 + 1 
44dc .. 00			db "LEFT",0              
44e1				endm 
# End of macro CWHEAD
44e1			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
44e1					if DEBUG_FORTH_WORDS_KEY 
44e1						DMARK "LEF" 
44e1 f5				push af  
44e2 3a f6 44			ld a, (.dmark)  
44e5 32 6e fe			ld (debug_mark),a  
44e8 3a f7 44			ld a, (.dmark+1)  
44eb 32 6f fe			ld (debug_mark+1),a  
44ee 3a f8 44			ld a, (.dmark+2)  
44f1 32 70 fe			ld (debug_mark+2),a  
44f4 18 03			jr .pastdmark  
44f6 ..			.dmark: db "LEF"  
44f9 f1			.pastdmark: pop af  
44fa			endm  
# End of macro DMARK
44fa						CALLMONITOR 
44fa cd f3 18			call break_point_state  
44fd				endm  
# End of macro CALLMONITOR
44fd					endif 
44fd			 
44fd					NEXTW 
44fd c3 d5 22			jp macro_next 
4500				endm 
# End of macro NEXTW
4500			.RIGHT: 
4500				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4500 48				db WORD_SYS_CORE+52             
4501 29 45			dw .STR2NUM            
4503 06				db 5 + 1 
4504 .. 00			db "RIGHT",0              
450a				endm 
# End of macro CWHEAD
450a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
450a					if DEBUG_FORTH_WORDS_KEY 
450a						DMARK "RIG" 
450a f5				push af  
450b 3a 1f 45			ld a, (.dmark)  
450e 32 6e fe			ld (debug_mark),a  
4511 3a 20 45			ld a, (.dmark+1)  
4514 32 6f fe			ld (debug_mark+1),a  
4517 3a 21 45			ld a, (.dmark+2)  
451a 32 70 fe			ld (debug_mark+2),a  
451d 18 03			jr .pastdmark  
451f ..			.dmark: db "RIG"  
4522 f1			.pastdmark: pop af  
4523			endm  
# End of macro DMARK
4523						CALLMONITOR 
4523 cd f3 18			call break_point_state  
4526				endm  
# End of macro CALLMONITOR
4526					endif 
4526			 
4526					NEXTW 
4526 c3 d5 22			jp macro_next 
4529				endm 
# End of macro NEXTW
4529			 
4529			 
4529			.STR2NUM: 
4529				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4529 48				db WORD_SYS_CORE+52             
452a b5 45			dw .NUM2STR            
452c 08				db 7 + 1 
452d .. 00			db "STR2NUM",0              
4535				endm 
# End of macro CWHEAD
4535			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4535			 
4535			 
4535			; TODO STR type check to do 
4535					if DEBUG_FORTH_WORDS_KEY 
4535						DMARK "S2N" 
4535 f5				push af  
4536 3a 4a 45			ld a, (.dmark)  
4539 32 6e fe			ld (debug_mark),a  
453c 3a 4b 45			ld a, (.dmark+1)  
453f 32 6f fe			ld (debug_mark+1),a  
4542 3a 4c 45			ld a, (.dmark+2)  
4545 32 70 fe			ld (debug_mark+2),a  
4548 18 03			jr .pastdmark  
454a ..			.dmark: db "S2N"  
454d f1			.pastdmark: pop af  
454e			endm  
# End of macro DMARK
454e						CALLMONITOR 
454e cd f3 18			call break_point_state  
4551				endm  
# End of macro CALLMONITOR
4551					endif 
4551			 
4551					;FORTH_DSP 
4551					FORTH_DSP_VALUE 
4551 cd 47 21			call macro_forth_dsp_value 
4554				endm 
# End of macro FORTH_DSP_VALUE
4554					;inc hl 
4554			 
4554 eb					ex de, hl 
4555					if DEBUG_FORTH_WORDS 
4555						DMARK "S2a" 
4555 f5				push af  
4556 3a 6a 45			ld a, (.dmark)  
4559 32 6e fe			ld (debug_mark),a  
455c 3a 6b 45			ld a, (.dmark+1)  
455f 32 6f fe			ld (debug_mark+1),a  
4562 3a 6c 45			ld a, (.dmark+2)  
4565 32 70 fe			ld (debug_mark+2),a  
4568 18 03			jr .pastdmark  
456a ..			.dmark: db "S2a"  
456d f1			.pastdmark: pop af  
456e			endm  
# End of macro DMARK
456e						CALLMONITOR 
456e cd f3 18			call break_point_state  
4571				endm  
# End of macro CALLMONITOR
4571					endif 
4571 cd 41 13				call string_to_uint16 
4574			 
4574					if DEBUG_FORTH_WORDS 
4574						DMARK "S2b" 
4574 f5				push af  
4575 3a 89 45			ld a, (.dmark)  
4578 32 6e fe			ld (debug_mark),a  
457b 3a 8a 45			ld a, (.dmark+1)  
457e 32 6f fe			ld (debug_mark+1),a  
4581 3a 8b 45			ld a, (.dmark+2)  
4584 32 70 fe			ld (debug_mark+2),a  
4587 18 03			jr .pastdmark  
4589 ..			.dmark: db "S2b"  
458c f1			.pastdmark: pop af  
458d			endm  
# End of macro DMARK
458d						CALLMONITOR 
458d cd f3 18			call break_point_state  
4590				endm  
# End of macro CALLMONITOR
4590					endif 
4590			;		push hl 
4590					FORTH_DSP_POP 
4590 cd 16 22			call macro_forth_dsp_pop 
4593				endm 
# End of macro FORTH_DSP_POP
4593			;		pop hl 
4593					 
4593					if DEBUG_FORTH_WORDS 
4593						DMARK "S2b" 
4593 f5				push af  
4594 3a a8 45			ld a, (.dmark)  
4597 32 6e fe			ld (debug_mark),a  
459a 3a a9 45			ld a, (.dmark+1)  
459d 32 6f fe			ld (debug_mark+1),a  
45a0 3a aa 45			ld a, (.dmark+2)  
45a3 32 70 fe			ld (debug_mark+2),a  
45a6 18 03			jr .pastdmark  
45a8 ..			.dmark: db "S2b"  
45ab f1			.pastdmark: pop af  
45ac			endm  
# End of macro DMARK
45ac						CALLMONITOR 
45ac cd f3 18			call break_point_state  
45af				endm  
# End of macro CALLMONITOR
45af					endif 
45af cd 67 1f				call forth_push_numhl	 
45b2			 
45b2				 
45b2				       NEXTW 
45b2 c3 d5 22			jp macro_next 
45b5				endm 
# End of macro NEXTW
45b5			.NUM2STR: 
45b5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
45b5 48				db WORD_SYS_CORE+52             
45b6 c4 45			dw .CONCAT            
45b8 08				db 7 + 1 
45b9 .. 00			db "NUM2STR",0              
45c1				endm 
# End of macro CWHEAD
45c1			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
45c1			 
45c1			;		; malloc a string to target 
45c1			;		ld hl, 10     ; TODO max string size should be fine 
45c1			;		call malloc 
45c1			;		push hl    ; save malloc location 
45c1			; 
45c1			; 
45c1			;; TODO check int type 
45c1			;		FORTH_DSP_VALUEHL 
45c1			;		ld a, l 
45c1			;		call DispAToASCII   
45c1			;;TODO need to chage above call to dump into string 
45c1			; 
45c1			; 
45c1			 
45c1				       NEXTW 
45c1 c3 d5 22			jp macro_next 
45c4				endm 
# End of macro NEXTW
45c4			 
45c4			.CONCAT: 
45c4				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
45c4 48				db WORD_SYS_CORE+52             
45c5 77 46			dw .FIND            
45c7 07				db 6 + 1 
45c8 .. 00			db "CONCAT",0              
45cf				endm 
# End of macro CWHEAD
45cf			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
45cf			 
45cf			; TODO check string type 
45cf			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
45cf			 
45cf					if DEBUG_FORTH_WORDS_KEY 
45cf						DMARK "CON" 
45cf f5				push af  
45d0 3a e4 45			ld a, (.dmark)  
45d3 32 6e fe			ld (debug_mark),a  
45d6 3a e5 45			ld a, (.dmark+1)  
45d9 32 6f fe			ld (debug_mark+1),a  
45dc 3a e6 45			ld a, (.dmark+2)  
45df 32 70 fe			ld (debug_mark+2),a  
45e2 18 03			jr .pastdmark  
45e4 ..			.dmark: db "CON"  
45e7 f1			.pastdmark: pop af  
45e8			endm  
# End of macro DMARK
45e8						CALLMONITOR 
45e8 cd f3 18			call break_point_state  
45eb				endm  
# End of macro CALLMONITOR
45eb					endif 
45eb			 
45eb			 
45eb					FORTH_DSP_VALUE 
45eb cd 47 21			call macro_forth_dsp_value 
45ee				endm 
# End of macro FORTH_DSP_VALUE
45ee e5					push hl   ; s2 
45ef			 
45ef					FORTH_DSP_POP 
45ef cd 16 22			call macro_forth_dsp_pop 
45f2				endm 
# End of macro FORTH_DSP_POP
45f2			 
45f2					FORTH_DSP_VALUE 
45f2 cd 47 21			call macro_forth_dsp_value 
45f5				endm 
# End of macro FORTH_DSP_VALUE
45f5			 
45f5 e5					push hl   ; s1 
45f6			 
45f6					FORTH_DSP_POP 
45f6 cd 16 22			call macro_forth_dsp_pop 
45f9				endm 
# End of macro FORTH_DSP_POP
45f9					 
45f9			 
45f9					; copy s1 
45f9			 
45f9				 
45f9					; save ptr 
45f9 e1					pop hl  
45fa e5					push hl 
45fb 3e 00				ld a, 0 
45fd cd b5 13				call strlent 
4600					;inc hl    ; zer0 
4600 06 00				ld b, 0 
4602 4d					ld c, l 
4603 e1					pop hl		 
4604 11 fc f1				ld de, scratch	 
4607					if DEBUG_FORTH_WORDS 
4607						DMARK "CO1" 
4607 f5				push af  
4608 3a 1c 46			ld a, (.dmark)  
460b 32 6e fe			ld (debug_mark),a  
460e 3a 1d 46			ld a, (.dmark+1)  
4611 32 6f fe			ld (debug_mark+1),a  
4614 3a 1e 46			ld a, (.dmark+2)  
4617 32 70 fe			ld (debug_mark+2),a  
461a 18 03			jr .pastdmark  
461c ..			.dmark: db "CO1"  
461f f1			.pastdmark: pop af  
4620			endm  
# End of macro DMARK
4620						CALLMONITOR 
4620 cd f3 18			call break_point_state  
4623				endm  
# End of macro CALLMONITOR
4623					endif 
4623 ed b0				ldir 
4625			 
4625 e1					pop hl 
4626 e5					push hl 
4627 d5					push de 
4628			 
4628			 
4628 3e 00				ld a, 0 
462a cd b5 13				call strlent 
462d 23					inc hl    ; zer0 
462e 23					inc hl 
462f 06 00				ld b, 0 
4631 4d					ld c, l 
4632 d1					pop de 
4633 e1					pop hl		 
4634					if DEBUG_FORTH_WORDS 
4634						DMARK "CO2" 
4634 f5				push af  
4635 3a 49 46			ld a, (.dmark)  
4638 32 6e fe			ld (debug_mark),a  
463b 3a 4a 46			ld a, (.dmark+1)  
463e 32 6f fe			ld (debug_mark+1),a  
4641 3a 4b 46			ld a, (.dmark+2)  
4644 32 70 fe			ld (debug_mark+2),a  
4647 18 03			jr .pastdmark  
4649 ..			.dmark: db "CO2"  
464c f1			.pastdmark: pop af  
464d			endm  
# End of macro DMARK
464d						CALLMONITOR 
464d cd f3 18			call break_point_state  
4650				endm  
# End of macro CALLMONITOR
4650					endif 
4650 ed b0				ldir 
4652			 
4652			 
4652			 
4652 21 fc f1				ld hl, scratch 
4655					if DEBUG_FORTH_WORDS 
4655						DMARK "CO5" 
4655 f5				push af  
4656 3a 6a 46			ld a, (.dmark)  
4659 32 6e fe			ld (debug_mark),a  
465c 3a 6b 46			ld a, (.dmark+1)  
465f 32 6f fe			ld (debug_mark+1),a  
4662 3a 6c 46			ld a, (.dmark+2)  
4665 32 70 fe			ld (debug_mark+2),a  
4668 18 03			jr .pastdmark  
466a ..			.dmark: db "CO5"  
466d f1			.pastdmark: pop af  
466e			endm  
# End of macro DMARK
466e						CALLMONITOR 
466e cd f3 18			call break_point_state  
4671				endm  
# End of macro CALLMONITOR
4671					endif 
4671			 
4671 cd d5 1f				call forth_push_str 
4674			 
4674			 
4674			 
4674			 
4674				       NEXTW 
4674 c3 d5 22			jp macro_next 
4677				endm 
# End of macro NEXTW
4677			 
4677			 
4677			.FIND: 
4677				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4677 4b				db WORD_SYS_CORE+55             
4678 35 47			dw .LEN            
467a 05				db 4 + 1 
467b .. 00			db "FIND",0              
4680				endm 
# End of macro CWHEAD
4680			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4680			 
4680					if DEBUG_FORTH_WORDS_KEY 
4680						DMARK "FND" 
4680 f5				push af  
4681 3a 95 46			ld a, (.dmark)  
4684 32 6e fe			ld (debug_mark),a  
4687 3a 96 46			ld a, (.dmark+1)  
468a 32 6f fe			ld (debug_mark+1),a  
468d 3a 97 46			ld a, (.dmark+2)  
4690 32 70 fe			ld (debug_mark+2),a  
4693 18 03			jr .pastdmark  
4695 ..			.dmark: db "FND"  
4698 f1			.pastdmark: pop af  
4699			endm  
# End of macro DMARK
4699						CALLMONITOR 
4699 cd f3 18			call break_point_state  
469c				endm  
# End of macro CALLMONITOR
469c					endif 
469c			 
469c			; TODO check string type 
469c					FORTH_DSP_VALUE 
469c cd 47 21			call macro_forth_dsp_value 
469f				endm 
# End of macro FORTH_DSP_VALUE
469f			 
469f e5					push hl    
46a0 7e					ld a,(hl)    ; char to find   
46a1			; TODO change char to substr 
46a1			 
46a1 f5					push af 
46a2					 
46a2			 
46a2			 
46a2					if DEBUG_FORTH_WORDS 
46a2						DMARK "FN1" 
46a2 f5				push af  
46a3 3a b7 46			ld a, (.dmark)  
46a6 32 6e fe			ld (debug_mark),a  
46a9 3a b8 46			ld a, (.dmark+1)  
46ac 32 6f fe			ld (debug_mark+1),a  
46af 3a b9 46			ld a, (.dmark+2)  
46b2 32 70 fe			ld (debug_mark+2),a  
46b5 18 03			jr .pastdmark  
46b7 ..			.dmark: db "FN1"  
46ba f1			.pastdmark: pop af  
46bb			endm  
# End of macro DMARK
46bb						CALLMONITOR 
46bb cd f3 18			call break_point_state  
46be				endm  
# End of macro CALLMONITOR
46be					endif 
46be			 
46be					FORTH_DSP_POP 
46be cd 16 22			call macro_forth_dsp_pop 
46c1				endm 
# End of macro FORTH_DSP_POP
46c1			 
46c1					; string to search 
46c1			 
46c1					FORTH_DSP_VALUE 
46c1 cd 47 21			call macro_forth_dsp_value 
46c4				endm 
# End of macro FORTH_DSP_VALUE
46c4			 
46c4 d1					pop de  ; d is char to find  
46c5			 
46c5					if DEBUG_FORTH_WORDS 
46c5						DMARK "FN2" 
46c5 f5				push af  
46c6 3a da 46			ld a, (.dmark)  
46c9 32 6e fe			ld (debug_mark),a  
46cc 3a db 46			ld a, (.dmark+1)  
46cf 32 6f fe			ld (debug_mark+1),a  
46d2 3a dc 46			ld a, (.dmark+2)  
46d5 32 70 fe			ld (debug_mark+2),a  
46d8 18 03			jr .pastdmark  
46da ..			.dmark: db "FN2"  
46dd f1			.pastdmark: pop af  
46de			endm  
# End of macro DMARK
46de						CALLMONITOR 
46de cd f3 18			call break_point_state  
46e1				endm  
# End of macro CALLMONITOR
46e1					endif 
46e1					 
46e1 01 00 00				ld bc, 0 
46e4 7e			.findchar:      ld a,(hl) 
46e5 fe 00				cp 0   		 
46e7 28 27				jr z, .finddone     
46e9 ba					cp d 
46ea 28 20				jr z, .foundchar 
46ec 03					inc bc 
46ed 23					inc hl 
46ee					if DEBUG_FORTH_WORDS 
46ee						DMARK "FN3" 
46ee f5				push af  
46ef 3a 03 47			ld a, (.dmark)  
46f2 32 6e fe			ld (debug_mark),a  
46f5 3a 04 47			ld a, (.dmark+1)  
46f8 32 6f fe			ld (debug_mark+1),a  
46fb 3a 05 47			ld a, (.dmark+2)  
46fe 32 70 fe			ld (debug_mark+2),a  
4701 18 03			jr .pastdmark  
4703 ..			.dmark: db "FN3"  
4706 f1			.pastdmark: pop af  
4707			endm  
# End of macro DMARK
4707						CALLMONITOR 
4707 cd f3 18			call break_point_state  
470a				endm  
# End of macro CALLMONITOR
470a					endif 
470a 18 d8				jr .findchar 
470c			 
470c			 
470c c5			.foundchar:	push bc 
470d e1					pop hl 
470e 18 03				jr .findexit 
4710			 
4710			 
4710							 
4710			 
4710			.finddone:     ; got to end of string with no find 
4710 21 00 00				ld hl, 0 
4713			.findexit: 
4713			 
4713					if DEBUG_FORTH_WORDS 
4713						DMARK "FNd" 
4713 f5				push af  
4714 3a 28 47			ld a, (.dmark)  
4717 32 6e fe			ld (debug_mark),a  
471a 3a 29 47			ld a, (.dmark+1)  
471d 32 6f fe			ld (debug_mark+1),a  
4720 3a 2a 47			ld a, (.dmark+2)  
4723 32 70 fe			ld (debug_mark+2),a  
4726 18 03			jr .pastdmark  
4728 ..			.dmark: db "FNd"  
472b f1			.pastdmark: pop af  
472c			endm  
# End of macro DMARK
472c						CALLMONITOR 
472c cd f3 18			call break_point_state  
472f				endm  
# End of macro CALLMONITOR
472f					endif 
472f cd 67 1f			call forth_push_numhl 
4732			 
4732				       NEXTW 
4732 c3 d5 22			jp macro_next 
4735				endm 
# End of macro NEXTW
4735			 
4735			.LEN: 
4735				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4735 4c				db WORD_SYS_CORE+56             
4736 9f 47			dw .ASC            
4738 06				db 5 + 1 
4739 .. 00			db "COUNT",0              
473f				endm 
# End of macro CWHEAD
473f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
473f			 
473f					if DEBUG_FORTH_WORDS_KEY 
473f						DMARK "CNT" 
473f f5				push af  
4740 3a 54 47			ld a, (.dmark)  
4743 32 6e fe			ld (debug_mark),a  
4746 3a 55 47			ld a, (.dmark+1)  
4749 32 6f fe			ld (debug_mark+1),a  
474c 3a 56 47			ld a, (.dmark+2)  
474f 32 70 fe			ld (debug_mark+2),a  
4752 18 03			jr .pastdmark  
4754 ..			.dmark: db "CNT"  
4757 f1			.pastdmark: pop af  
4758			endm  
# End of macro DMARK
4758						CALLMONITOR 
4758 cd f3 18			call break_point_state  
475b				endm  
# End of macro CALLMONITOR
475b					endif 
475b			; TODO check string type 
475b					FORTH_DSP_VALUE 
475b cd 47 21			call macro_forth_dsp_value 
475e				endm 
# End of macro FORTH_DSP_VALUE
475e			 
475e			 
475e					if DEBUG_FORTH_WORDS 
475e						DMARK "CN?" 
475e f5				push af  
475f 3a 73 47			ld a, (.dmark)  
4762 32 6e fe			ld (debug_mark),a  
4765 3a 74 47			ld a, (.dmark+1)  
4768 32 6f fe			ld (debug_mark+1),a  
476b 3a 75 47			ld a, (.dmark+2)  
476e 32 70 fe			ld (debug_mark+2),a  
4771 18 03			jr .pastdmark  
4773 ..			.dmark: db "CN?"  
4776 f1			.pastdmark: pop af  
4777			endm  
# End of macro DMARK
4777						CALLMONITOR 
4777 cd f3 18			call break_point_state  
477a				endm  
# End of macro CALLMONITOR
477a					endif 
477a cd aa 13				call strlenz 
477d					if DEBUG_FORTH_WORDS 
477d						DMARK "CNl" 
477d f5				push af  
477e 3a 92 47			ld a, (.dmark)  
4781 32 6e fe			ld (debug_mark),a  
4784 3a 93 47			ld a, (.dmark+1)  
4787 32 6f fe			ld (debug_mark+1),a  
478a 3a 94 47			ld a, (.dmark+2)  
478d 32 70 fe			ld (debug_mark+2),a  
4790 18 03			jr .pastdmark  
4792 ..			.dmark: db "CNl"  
4795 f1			.pastdmark: pop af  
4796			endm  
# End of macro DMARK
4796						CALLMONITOR 
4796 cd f3 18			call break_point_state  
4799				endm  
# End of macro CALLMONITOR
4799					endif 
4799			 
4799 cd 67 1f				call forth_push_numhl 
479c			 
479c			 
479c			 
479c				       NEXTW 
479c c3 d5 22			jp macro_next 
479f				endm 
# End of macro NEXTW
479f			.ASC: 
479f				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
479f 4d				db WORD_SYS_CORE+57             
47a0 d4 47			dw .CHR            
47a2 04				db 3 + 1 
47a3 .. 00			db "ASC",0              
47a7				endm 
# End of macro CWHEAD
47a7			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
47a7					if DEBUG_FORTH_WORDS_KEY 
47a7						DMARK "ASC" 
47a7 f5				push af  
47a8 3a bc 47			ld a, (.dmark)  
47ab 32 6e fe			ld (debug_mark),a  
47ae 3a bd 47			ld a, (.dmark+1)  
47b1 32 6f fe			ld (debug_mark+1),a  
47b4 3a be 47			ld a, (.dmark+2)  
47b7 32 70 fe			ld (debug_mark+2),a  
47ba 18 03			jr .pastdmark  
47bc ..			.dmark: db "ASC"  
47bf f1			.pastdmark: pop af  
47c0			endm  
# End of macro DMARK
47c0						CALLMONITOR 
47c0 cd f3 18			call break_point_state  
47c3				endm  
# End of macro CALLMONITOR
47c3					endif 
47c3					FORTH_DSP 
47c3 cd 24 21			call macro_forth_dsp 
47c6				endm 
# End of macro FORTH_DSP
47c6					;v5 FORTH_DSP_VALUE 
47c6 23					inc hl      ; now at start of numeric as string 
47c7			 
47c7			;		push hl 
47c7			 
47c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47c7 cd 16 22			call macro_forth_dsp_pop 
47ca				endm 
# End of macro FORTH_DSP_POP
47ca			 
47ca			;		pop hl 
47ca			 
47ca					; push the content of a onto the stack as a value 
47ca			 
47ca 7e					ld a,(hl)   ; get char 
47cb 26 00				ld h,0 
47cd 6f					ld l,a 
47ce cd 67 1f				call forth_push_numhl 
47d1			 
47d1				       NEXTW 
47d1 c3 d5 22			jp macro_next 
47d4				endm 
# End of macro NEXTW
47d4			 
47d4			.CHR: 
47d4				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
47d4 4d				db WORD_SYS_CORE+57             
47d5 10 48			dw .ENDSTR            
47d7 04				db 3 + 1 
47d8 .. 00			db "CHR",0              
47dc				endm 
# End of macro CWHEAD
47dc			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
47dc					if DEBUG_FORTH_WORDS_KEY 
47dc						DMARK "CHR" 
47dc f5				push af  
47dd 3a f1 47			ld a, (.dmark)  
47e0 32 6e fe			ld (debug_mark),a  
47e3 3a f2 47			ld a, (.dmark+1)  
47e6 32 6f fe			ld (debug_mark+1),a  
47e9 3a f3 47			ld a, (.dmark+2)  
47ec 32 70 fe			ld (debug_mark+2),a  
47ef 18 03			jr .pastdmark  
47f1 ..			.dmark: db "CHR"  
47f4 f1			.pastdmark: pop af  
47f5			endm  
# End of macro DMARK
47f5						CALLMONITOR 
47f5 cd f3 18			call break_point_state  
47f8				endm  
# End of macro CALLMONITOR
47f8					endif 
47f8					FORTH_DSP_VALUEHL 
47f8 cd 5e 21			call macro_dsp_valuehl 
47fb				endm 
# End of macro FORTH_DSP_VALUEHL
47fb			 
47fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47fb cd 16 22			call macro_forth_dsp_pop 
47fe				endm 
# End of macro FORTH_DSP_POP
47fe			 
47fe					; save asci byte as a zero term string and push string 
47fe			 
47fe 7d					ld a,l 
47ff 32 fc f1				ld (scratch), a 
4802			 
4802 3e 00				ld a, 0 
4804 32 fd f1				ld (scratch+1), a 
4807			 
4807 21 fc f1				ld hl, scratch 
480a cd d5 1f				call forth_push_str 
480d			 
480d			 
480d				       NEXTW 
480d c3 d5 22			jp macro_next 
4810				endm 
# End of macro NEXTW
4810			 
4810			 
4810			 
4810			 
4810			.ENDSTR: 
4810			; eof 
4810			 
# End of file forth_words_str.asm
4810			include "forth_words_key.asm" 
4810			 
4810			; | ## Keyboard Words 
4810			 
4810			.KEY: 
4810				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4810 3e				db WORD_SYS_CORE+42             
4811 40 48			dw .WAITK            
4813 04				db 3 + 1 
4814 .. 00			db "KEY",0              
4818				endm 
# End of macro CWHEAD
4818			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4818			 
4818					if DEBUG_FORTH_WORDS_KEY 
4818						DMARK "KEY" 
4818 f5				push af  
4819 3a 2d 48			ld a, (.dmark)  
481c 32 6e fe			ld (debug_mark),a  
481f 3a 2e 48			ld a, (.dmark+1)  
4822 32 6f fe			ld (debug_mark+1),a  
4825 3a 2f 48			ld a, (.dmark+2)  
4828 32 70 fe			ld (debug_mark+2),a  
482b 18 03			jr .pastdmark  
482d ..			.dmark: db "KEY"  
4830 f1			.pastdmark: pop af  
4831			endm  
# End of macro DMARK
4831						CALLMONITOR 
4831 cd f3 18			call break_point_state  
4834				endm  
# End of macro CALLMONITOR
4834					endif 
4834			; TODO currently waits 
4834 cd 0f 71				call cin 
4837					;call cin_wait 
4837 6f					ld l, a 
4838 26 00				ld h, 0 
483a cd 67 1f				call forth_push_numhl 
483d					NEXTW 
483d c3 d5 22			jp macro_next 
4840				endm 
# End of macro NEXTW
4840			.WAITK: 
4840				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4840 3f				db WORD_SYS_CORE+43             
4841 72 48			dw .ACCEPT            
4843 06				db 5 + 1 
4844 .. 00			db "WAITK",0              
484a				endm 
# End of macro CWHEAD
484a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
484a					if DEBUG_FORTH_WORDS_KEY 
484a						DMARK "WAI" 
484a f5				push af  
484b 3a 5f 48			ld a, (.dmark)  
484e 32 6e fe			ld (debug_mark),a  
4851 3a 60 48			ld a, (.dmark+1)  
4854 32 6f fe			ld (debug_mark+1),a  
4857 3a 61 48			ld a, (.dmark+2)  
485a 32 70 fe			ld (debug_mark+2),a  
485d 18 03			jr .pastdmark  
485f ..			.dmark: db "WAI"  
4862 f1			.pastdmark: pop af  
4863			endm  
# End of macro DMARK
4863						CALLMONITOR 
4863 cd f3 18			call break_point_state  
4866				endm  
# End of macro CALLMONITOR
4866					endif 
4866 cd fe 70				call cin_wait 
4869 6f					ld l, a 
486a 26 00				ld h, 0 
486c cd 67 1f				call forth_push_numhl 
486f					NEXTW 
486f c3 d5 22			jp macro_next 
4872				endm 
# End of macro NEXTW
4872			.ACCEPT: 
4872				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4872 40				db WORD_SYS_CORE+44             
4873 d0 48			dw .EDIT            
4875 07				db 6 + 1 
4876 .. 00			db "ACCEPT",0              
487d				endm 
# End of macro CWHEAD
487d			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
487d					; TODO crashes on push 
487d					if DEBUG_FORTH_WORDS_KEY 
487d						DMARK "ACC" 
487d f5				push af  
487e 3a 92 48			ld a, (.dmark)  
4881 32 6e fe			ld (debug_mark),a  
4884 3a 93 48			ld a, (.dmark+1)  
4887 32 6f fe			ld (debug_mark+1),a  
488a 3a 94 48			ld a, (.dmark+2)  
488d 32 70 fe			ld (debug_mark+2),a  
4890 18 03			jr .pastdmark  
4892 ..			.dmark: db "ACC"  
4895 f1			.pastdmark: pop af  
4896			endm  
# End of macro DMARK
4896						CALLMONITOR 
4896 cd f3 18			call break_point_state  
4899				endm  
# End of macro CALLMONITOR
4899					endif 
4899 21 fa f3				ld hl, os_input 
489c 3e 00				ld a, 0 
489e 77					ld (hl),a 
489f 3a 65 fa				ld a,(f_cursor_ptr) 
48a2 16 64				ld d, 100 
48a4 0e 00				ld c, 0 
48a6 1e 28				ld e, 40 
48a8 cd 79 0f				call input_str 
48ab					; TODO perhaps do a type check and wrap in quotes if not a number 
48ab 21 fa f3				ld hl, os_input 
48ae					if DEBUG_FORTH_WORDS 
48ae						DMARK "AC1" 
48ae f5				push af  
48af 3a c3 48			ld a, (.dmark)  
48b2 32 6e fe			ld (debug_mark),a  
48b5 3a c4 48			ld a, (.dmark+1)  
48b8 32 6f fe			ld (debug_mark+1),a  
48bb 3a c5 48			ld a, (.dmark+2)  
48be 32 70 fe			ld (debug_mark+2),a  
48c1 18 03			jr .pastdmark  
48c3 ..			.dmark: db "AC1"  
48c6 f1			.pastdmark: pop af  
48c7			endm  
# End of macro DMARK
48c7						CALLMONITOR 
48c7 cd f3 18			call break_point_state  
48ca				endm  
# End of macro CALLMONITOR
48ca					endif 
48ca cd d5 1f				call forth_push_str 
48cd					NEXTW 
48cd c3 d5 22			jp macro_next 
48d0				endm 
# End of macro NEXTW
48d0			 
48d0			.EDIT: 
48d0				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
48d0 40				db WORD_SYS_CORE+44             
48d1 72 49			dw .ENDKEY            
48d3 05				db 4 + 1 
48d4 .. 00			db "EDIT",0              
48d9				endm 
# End of macro CWHEAD
48d9			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
48d9			 
48d9					; TODO does not copy from stack 
48d9					if DEBUG_FORTH_WORDS_KEY 
48d9						DMARK "EDT" 
48d9 f5				push af  
48da 3a ee 48			ld a, (.dmark)  
48dd 32 6e fe			ld (debug_mark),a  
48e0 3a ef 48			ld a, (.dmark+1)  
48e3 32 6f fe			ld (debug_mark+1),a  
48e6 3a f0 48			ld a, (.dmark+2)  
48e9 32 70 fe			ld (debug_mark+2),a  
48ec 18 03			jr .pastdmark  
48ee ..			.dmark: db "EDT"  
48f1 f1			.pastdmark: pop af  
48f2			endm  
# End of macro DMARK
48f2						CALLMONITOR 
48f2 cd f3 18			call break_point_state  
48f5				endm  
# End of macro CALLMONITOR
48f5					endif 
48f5			 
48f5					;FORTH_DSP 
48f5					FORTH_DSP_VALUEHL 
48f5 cd 5e 21			call macro_dsp_valuehl 
48f8				endm 
# End of macro FORTH_DSP_VALUEHL
48f8			;		inc hl    ; TODO do type check 
48f8			 
48f8			;		call get_word_hl 
48f8 e5					push hl 
48f9					if DEBUG_FORTH_WORDS 
48f9						DMARK "EDp" 
48f9 f5				push af  
48fa 3a 0e 49			ld a, (.dmark)  
48fd 32 6e fe			ld (debug_mark),a  
4900 3a 0f 49			ld a, (.dmark+1)  
4903 32 6f fe			ld (debug_mark+1),a  
4906 3a 10 49			ld a, (.dmark+2)  
4909 32 70 fe			ld (debug_mark+2),a  
490c 18 03			jr .pastdmark  
490e ..			.dmark: db "EDp"  
4911 f1			.pastdmark: pop af  
4912			endm  
# End of macro DMARK
4912						CALLMONITOR 
4912 cd f3 18			call break_point_state  
4915				endm  
# End of macro CALLMONITOR
4915					endif 
4915				;	ld a, 0 
4915 cd aa 13				call strlenz 
4918 23					inc hl 
4919			 
4919 06 00				ld b, 0 
491b 4d					ld c, l 
491c			 
491c e1					pop hl 
491d 11 fa f3				ld de, os_input 
4920					if DEBUG_FORTH_WORDS_KEY 
4920						DMARK "EDc" 
4920 f5				push af  
4921 3a 35 49			ld a, (.dmark)  
4924 32 6e fe			ld (debug_mark),a  
4927 3a 36 49			ld a, (.dmark+1)  
492a 32 6f fe			ld (debug_mark+1),a  
492d 3a 37 49			ld a, (.dmark+2)  
4930 32 70 fe			ld (debug_mark+2),a  
4933 18 03			jr .pastdmark  
4935 ..			.dmark: db "EDc"  
4938 f1			.pastdmark: pop af  
4939			endm  
# End of macro DMARK
4939						CALLMONITOR 
4939 cd f3 18			call break_point_state  
493c				endm  
# End of macro CALLMONITOR
493c					endif 
493c ed b0				ldir 
493e			 
493e			 
493e 21 fa f3				ld hl, os_input 
4941					;ld a, 0 
4941					;ld (hl),a 
4941 3a 65 fa				ld a,(f_cursor_ptr) 
4944 16 64				ld d, 100 
4946 0e 00				ld c, 0 
4948 1e 28				ld e, 40 
494a cd 79 0f				call input_str 
494d					; TODO perhaps do a type check and wrap in quotes if not a number 
494d 21 fa f3				ld hl, os_input 
4950					if DEBUG_FORTH_WORDS 
4950						DMARK "ED1" 
4950 f5				push af  
4951 3a 65 49			ld a, (.dmark)  
4954 32 6e fe			ld (debug_mark),a  
4957 3a 66 49			ld a, (.dmark+1)  
495a 32 6f fe			ld (debug_mark+1),a  
495d 3a 67 49			ld a, (.dmark+2)  
4960 32 70 fe			ld (debug_mark+2),a  
4963 18 03			jr .pastdmark  
4965 ..			.dmark: db "ED1"  
4968 f1			.pastdmark: pop af  
4969			endm  
# End of macro DMARK
4969						CALLMONITOR 
4969 cd f3 18			call break_point_state  
496c				endm  
# End of macro CALLMONITOR
496c					endif 
496c cd d5 1f				call forth_push_str 
496f					NEXTW 
496f c3 d5 22			jp macro_next 
4972				endm 
# End of macro NEXTW
4972			 
4972			 
4972			 
4972			.ENDKEY: 
4972			; eof 
4972			 
# End of file forth_words_key.asm
4972			 
4972			if STORAGE_SE 
4972			   	include "forth_words_storage.asm" 
4972			 
4972			; | ## Fixed Storage Words 
4972			 
4972			.RECORD: 
4972			  
4972				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4972 3a				db WORD_SYS_CORE+38             
4973 16 4a			dw .BREAD            
4975 07				db 6 + 1 
4976 .. 00			db "RECORD",0              
497d				endm 
# End of macro CWHEAD
497d			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
497d			 
497d					if DEBUG_FORTH_WORDS_KEY 
497d						DMARK "REC" 
497d f5				push af  
497e 3a 92 49			ld a, (.dmark)  
4981 32 6e fe			ld (debug_mark),a  
4984 3a 93 49			ld a, (.dmark+1)  
4987 32 6f fe			ld (debug_mark+1),a  
498a 3a 94 49			ld a, (.dmark+2)  
498d 32 70 fe			ld (debug_mark+2),a  
4990 18 03			jr .pastdmark  
4992 ..			.dmark: db "REC"  
4995 f1			.pastdmark: pop af  
4996			endm  
# End of macro DMARK
4996						CALLMONITOR 
4996 cd f3 18			call break_point_state  
4999				endm  
# End of macro CALLMONITOR
4999					endif 
4999			 
4999					FORTH_DSP_VALUEHL 
4999 cd 5e 21			call macro_dsp_valuehl 
499c				endm 
# End of macro FORTH_DSP_VALUEHL
499c			 
499c e5					push hl    ; id 
499d			 
499d					FORTH_DSP_POP 
499d cd 16 22			call macro_forth_dsp_pop 
49a0				endm 
# End of macro FORTH_DSP_POP
49a0			 
49a0					FORTH_DSP_VALUEHL 
49a0 cd 5e 21			call macro_dsp_valuehl 
49a3				endm 
# End of macro FORTH_DSP_VALUEHL
49a3			 
49a3					FORTH_DSP_POP 
49a3 cd 16 22			call macro_forth_dsp_pop 
49a6				endm 
# End of macro FORTH_DSP_POP
49a6			 
49a6 d1					pop de     ; get file id 
49a7			 
49a7					; e = file id 
49a7					; l = file extent 
49a7			 
49a7			 
49a7					; construct request to access file extent 
49a7			 
49a7			;		ld a, e 
49a7 63					ld h, e 
49a8					 
49a8					 
49a8					 
49a8			 
49a8					; e has id 
49a8			 
49a8 11 81 fa			ld de, store_page 
49ab					if DEBUG_FORTH_WORDS 
49ab						DMARK "REr" 
49ab f5				push af  
49ac 3a c0 49			ld a, (.dmark)  
49af 32 6e fe			ld (debug_mark),a  
49b2 3a c1 49			ld a, (.dmark+1)  
49b5 32 6f fe			ld (debug_mark+1),a  
49b8 3a c2 49			ld a, (.dmark+2)  
49bb 32 70 fe			ld (debug_mark+2),a  
49be 18 03			jr .pastdmark  
49c0 ..			.dmark: db "REr"  
49c3 f1			.pastdmark: pop af  
49c4			endm  
# End of macro DMARK
49c4						CALLMONITOR 
49c4 cd f3 18			call break_point_state  
49c7				endm  
# End of macro CALLMONITOR
49c7					endif 
49c7 cd 75 09				call storage_read 
49ca cd 75 0f			call ishlzero 
49cd 28 22			jr z, .recnotfound 
49cf			 
49cf			 
49cf					if DEBUG_FORTH_WORDS 
49cf						DMARK "REe" 
49cf f5				push af  
49d0 3a e4 49			ld a, (.dmark)  
49d3 32 6e fe			ld (debug_mark),a  
49d6 3a e5 49			ld a, (.dmark+1)  
49d9 32 6f fe			ld (debug_mark+1),a  
49dc 3a e6 49			ld a, (.dmark+2)  
49df 32 70 fe			ld (debug_mark+2),a  
49e2 18 03			jr .pastdmark  
49e4 ..			.dmark: db "REe"  
49e7 f1			.pastdmark: pop af  
49e8			endm  
# End of macro DMARK
49e8						CALLMONITOR 
49e8 cd f3 18			call break_point_state  
49eb				endm  
# End of macro CALLMONITOR
49eb					endif 
49eb cd d5 1f			call forth_push_str 
49ee			 
49ee					NEXTW 
49ee c3 d5 22			jp macro_next 
49f1				endm 
# End of macro NEXTW
49f1			 
49f1			.recnotfound: 
49f1					if DEBUG_FORTH_WORDS 
49f1						DMARK "REf" 
49f1 f5				push af  
49f2 3a 06 4a			ld a, (.dmark)  
49f5 32 6e fe			ld (debug_mark),a  
49f8 3a 07 4a			ld a, (.dmark+1)  
49fb 32 6f fe			ld (debug_mark+1),a  
49fe 3a 08 4a			ld a, (.dmark+2)  
4a01 32 70 fe			ld (debug_mark+2),a  
4a04 18 03			jr .pastdmark  
4a06 ..			.dmark: db "REf"  
4a09 f1			.pastdmark: pop af  
4a0a			endm  
# End of macro DMARK
4a0a						CALLMONITOR 
4a0a cd f3 18			call break_point_state  
4a0d				endm  
# End of macro CALLMONITOR
4a0d					endif 
4a0d 21 ff 00			ld hl, 255 
4a10 cd 67 1f			call forth_push_numhl 
4a13				NEXTW 
4a13 c3 d5 22			jp macro_next 
4a16				endm 
# End of macro NEXTW
4a16			 
4a16			 
4a16			.BREAD: 
4a16			  
4a16				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4a16 3a				db WORD_SYS_CORE+38             
4a17 99 4a			dw .BWRITE            
4a19 06				db 5 + 1 
4a1a .. 00			db "BREAD",0              
4a20				endm 
# End of macro CWHEAD
4a20			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4a20				 
4a20					if DEBUG_FORTH_WORDS_KEY 
4a20						DMARK "BRD" 
4a20 f5				push af  
4a21 3a 35 4a			ld a, (.dmark)  
4a24 32 6e fe			ld (debug_mark),a  
4a27 3a 36 4a			ld a, (.dmark+1)  
4a2a 32 6f fe			ld (debug_mark+1),a  
4a2d 3a 37 4a			ld a, (.dmark+2)  
4a30 32 70 fe			ld (debug_mark+2),a  
4a33 18 03			jr .pastdmark  
4a35 ..			.dmark: db "BRD"  
4a38 f1			.pastdmark: pop af  
4a39			endm  
# End of macro DMARK
4a39						CALLMONITOR 
4a39 cd f3 18			call break_point_state  
4a3c				endm  
# End of macro CALLMONITOR
4a3c					endif 
4a3c			 
4a3c				FORTH_DSP_VALUEHL 
4a3c cd 5e 21			call macro_dsp_valuehl 
4a3f				endm 
# End of macro FORTH_DSP_VALUEHL
4a3f			 
4a3f				FORTH_DSP_POP 
4a3f cd 16 22			call macro_forth_dsp_pop 
4a42				endm 
# End of macro FORTH_DSP_POP
4a42			 
4a42				; calc block address 
4a42			 
4a42 eb				ex de, hl 
4a43 3e 40			ld a, STORE_BLOCK_PHY 
4a45 cd cf 0e			call Mult16 
4a48			 
4a48			 
4a48 11 81 fa			ld de, store_page 
4a4b			 
4a4b					if DEBUG_FORTH_WORDS 
4a4b						DMARK "BR1" 
4a4b f5				push af  
4a4c 3a 60 4a			ld a, (.dmark)  
4a4f 32 6e fe			ld (debug_mark),a  
4a52 3a 61 4a			ld a, (.dmark+1)  
4a55 32 6f fe			ld (debug_mark+1),a  
4a58 3a 62 4a			ld a, (.dmark+2)  
4a5b 32 70 fe			ld (debug_mark+2),a  
4a5e 18 03			jr .pastdmark  
4a60 ..			.dmark: db "BR1"  
4a63 f1			.pastdmark: pop af  
4a64			endm  
# End of macro DMARK
4a64						CALLMONITOR 
4a64 cd f3 18			call break_point_state  
4a67				endm  
# End of macro CALLMONITOR
4a67					endif 
4a67			 
4a67 cd 1c 04			call storage_read_block 
4a6a			 
4a6a cd 75 0f			call ishlzero 
4a6d 20 05			jr nz, .brfound 
4a6f			 
4a6f cd 67 1f			call forth_push_numhl 
4a72 18 22			jr .brdone 
4a74			 
4a74			 
4a74			.brfound: 
4a74 21 83 fa		        ld hl, store_page+2 
4a77			 
4a77					if DEBUG_FORTH_WORDS 
4a77						DMARK "BR2" 
4a77 f5				push af  
4a78 3a 8c 4a			ld a, (.dmark)  
4a7b 32 6e fe			ld (debug_mark),a  
4a7e 3a 8d 4a			ld a, (.dmark+1)  
4a81 32 6f fe			ld (debug_mark+1),a  
4a84 3a 8e 4a			ld a, (.dmark+2)  
4a87 32 70 fe			ld (debug_mark+2),a  
4a8a 18 03			jr .pastdmark  
4a8c ..			.dmark: db "BR2"  
4a8f f1			.pastdmark: pop af  
4a90			endm  
# End of macro DMARK
4a90						CALLMONITOR 
4a90 cd f3 18			call break_point_state  
4a93				endm  
# End of macro CALLMONITOR
4a93					endif 
4a93			 
4a93 cd d5 1f			call forth_push_str 
4a96			 
4a96			 
4a96			.brdone: 
4a96			 
4a96					NEXTW 
4a96 c3 d5 22			jp macro_next 
4a99				endm 
# End of macro NEXTW
4a99			.BWRITE: 
4a99				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4a99 3a				db WORD_SYS_CORE+38             
4a9a 2e 4b			dw .BUPD            
4a9c 07				db 6 + 1 
4a9d .. 00			db "BWRITE",0              
4aa4				endm 
# End of macro CWHEAD
4aa4			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4aa4			 
4aa4					if DEBUG_FORTH_WORDS_KEY 
4aa4						DMARK "BWR" 
4aa4 f5				push af  
4aa5 3a b9 4a			ld a, (.dmark)  
4aa8 32 6e fe			ld (debug_mark),a  
4aab 3a ba 4a			ld a, (.dmark+1)  
4aae 32 6f fe			ld (debug_mark+1),a  
4ab1 3a bb 4a			ld a, (.dmark+2)  
4ab4 32 70 fe			ld (debug_mark+2),a  
4ab7 18 03			jr .pastdmark  
4ab9 ..			.dmark: db "BWR"  
4abc f1			.pastdmark: pop af  
4abd			endm  
# End of macro DMARK
4abd						CALLMONITOR 
4abd cd f3 18			call break_point_state  
4ac0				endm  
# End of macro CALLMONITOR
4ac0					endif 
4ac0			 
4ac0				FORTH_DSP_VALUEHL 
4ac0 cd 5e 21			call macro_dsp_valuehl 
4ac3				endm 
# End of macro FORTH_DSP_VALUEHL
4ac3			 
4ac3				; calc block address 
4ac3			 
4ac3 eb				ex de, hl 
4ac4 3e 40			ld a, STORE_BLOCK_PHY 
4ac6 cd cf 0e			call Mult16 
4ac9			 
4ac9 e5				push hl         ; address 
4aca			 
4aca				FORTH_DSP_POP 
4aca cd 16 22			call macro_forth_dsp_pop 
4acd				endm 
# End of macro FORTH_DSP_POP
4acd			 
4acd				FORTH_DSP_VALUEHL 
4acd cd 5e 21			call macro_dsp_valuehl 
4ad0				endm 
# End of macro FORTH_DSP_VALUEHL
4ad0			 
4ad0				FORTH_DSP_POP 
4ad0 cd 16 22			call macro_forth_dsp_pop 
4ad3				endm 
# End of macro FORTH_DSP_POP
4ad3			 
4ad3 cd 58 0c			call storage_clear_page 
4ad6			 
4ad6				; copy string to store page 
4ad6			 
4ad6 e5				push hl     ; save string address 
4ad7			 
4ad7 3e 00			ld a, 0 
4ad9 cd b5 13			call strlent 
4adc			 
4adc 23				inc hl 
4add			 
4add 4d				ld c, l 
4ade 06 00			ld b, 0 
4ae0			 
4ae0 e1				pop hl 
4ae1 11 83 fa			ld de, store_page + 2 
4ae4					if DEBUG_FORTH_WORDS 
4ae4						DMARK "BW1" 
4ae4 f5				push af  
4ae5 3a f9 4a			ld a, (.dmark)  
4ae8 32 6e fe			ld (debug_mark),a  
4aeb 3a fa 4a			ld a, (.dmark+1)  
4aee 32 6f fe			ld (debug_mark+1),a  
4af1 3a fb 4a			ld a, (.dmark+2)  
4af4 32 70 fe			ld (debug_mark+2),a  
4af7 18 03			jr .pastdmark  
4af9 ..			.dmark: db "BW1"  
4afc f1			.pastdmark: pop af  
4afd			endm  
# End of macro DMARK
4afd						CALLMONITOR 
4afd cd f3 18			call break_point_state  
4b00				endm  
# End of macro CALLMONITOR
4b00					endif 
4b00 ed b0			ldir 
4b02			 
4b02			 
4b02				; poke the start of the block with flags to prevent high level file ops hitting the block 
4b02			 
4b02 21 ff ff			ld hl, $ffff 
4b05			 
4b05 22 81 fa			ld (store_page), hl	 
4b08				 
4b08 e1				pop hl    ; get address 
4b09 11 81 fa			ld de, store_page 
4b0c			 
4b0c					if DEBUG_FORTH_WORDS 
4b0c						DMARK "BW2" 
4b0c f5				push af  
4b0d 3a 21 4b			ld a, (.dmark)  
4b10 32 6e fe			ld (debug_mark),a  
4b13 3a 22 4b			ld a, (.dmark+1)  
4b16 32 6f fe			ld (debug_mark+1),a  
4b19 3a 23 4b			ld a, (.dmark+2)  
4b1c 32 70 fe			ld (debug_mark+2),a  
4b1f 18 03			jr .pastdmark  
4b21 ..			.dmark: db "BW2"  
4b24 f1			.pastdmark: pop af  
4b25			endm  
# End of macro DMARK
4b25						CALLMONITOR 
4b25 cd f3 18			call break_point_state  
4b28				endm  
# End of macro CALLMONITOR
4b28					endif 
4b28			 
4b28 cd 81 04			call storage_write_block 
4b2b			 
4b2b					NEXTW 
4b2b c3 d5 22			jp macro_next 
4b2e				endm 
# End of macro NEXTW
4b2e			 
4b2e			.BUPD: 
4b2e				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4b2e 3a				db WORD_SYS_CORE+38             
4b2f 84 4b			dw .BYID            
4b31 05				db 4 + 1 
4b32 .. 00			db "BUPD",0              
4b37				endm 
# End of macro CWHEAD
4b37			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4b37			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4b37			; | | or completely different file system structure. 
4b37			 
4b37					if DEBUG_FORTH_WORDS_KEY 
4b37						DMARK "BUD" 
4b37 f5				push af  
4b38 3a 4c 4b			ld a, (.dmark)  
4b3b 32 6e fe			ld (debug_mark),a  
4b3e 3a 4d 4b			ld a, (.dmark+1)  
4b41 32 6f fe			ld (debug_mark+1),a  
4b44 3a 4e 4b			ld a, (.dmark+2)  
4b47 32 70 fe			ld (debug_mark+2),a  
4b4a 18 03			jr .pastdmark  
4b4c ..			.dmark: db "BUD"  
4b4f f1			.pastdmark: pop af  
4b50			endm  
# End of macro DMARK
4b50						CALLMONITOR 
4b50 cd f3 18			call break_point_state  
4b53				endm  
# End of macro CALLMONITOR
4b53					endif 
4b53			 
4b53				FORTH_DSP_VALUEHL 
4b53 cd 5e 21			call macro_dsp_valuehl 
4b56				endm 
# End of macro FORTH_DSP_VALUEHL
4b56			 
4b56				; calc block address 
4b56			 
4b56 eb				ex de, hl 
4b57 3e 40			ld a, STORE_BLOCK_PHY 
4b59 cd cf 0e			call Mult16 
4b5c			 
4b5c				FORTH_DSP_POP 
4b5c cd 16 22			call macro_forth_dsp_pop 
4b5f				endm 
# End of macro FORTH_DSP_POP
4b5f			 
4b5f			 
4b5f 11 81 fa			ld de, store_page 
4b62			 
4b62					if DEBUG_FORTH_WORDS 
4b62						DMARK "BUe" 
4b62 f5				push af  
4b63 3a 77 4b			ld a, (.dmark)  
4b66 32 6e fe			ld (debug_mark),a  
4b69 3a 78 4b			ld a, (.dmark+1)  
4b6c 32 6f fe			ld (debug_mark+1),a  
4b6f 3a 79 4b			ld a, (.dmark+2)  
4b72 32 70 fe			ld (debug_mark+2),a  
4b75 18 03			jr .pastdmark  
4b77 ..			.dmark: db "BUe"  
4b7a f1			.pastdmark: pop af  
4b7b			endm  
# End of macro DMARK
4b7b						CALLMONITOR 
4b7b cd f3 18			call break_point_state  
4b7e				endm  
# End of macro CALLMONITOR
4b7e					endif 
4b7e			 
4b7e cd 81 04			call storage_write_block 
4b81			 
4b81					NEXTW 
4b81 c3 d5 22			jp macro_next 
4b84				endm 
# End of macro NEXTW
4b84			 
4b84			.BYID: 
4b84			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4b84			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4b84			; 
4b84			;		 
4b84			;		if DEBUG_FORTH_WORDS_KEY 
4b84			;			DMARK "BYID" 
4b84			;			CALLMONITOR 
4b84			;		endif 
4b84			; 
4b84			;		; get direct address 
4b84			; 
4b84			;		FORTH_DSP_VALUEHL 
4b84			; 
4b84			;		FORTH_DSP_POP 
4b84			; 
4b84			;	; calc block address 
4b84			; 
4b84			;	ex de, hl 
4b84			;	ld a, STORE_BLOCK_PHY 
4b84			;	call Mult16 
4b84			;	;	do BREAD with number as param 
4b84			;	; push the file name	 
4b84			;	ld de, store_page 
4b84			;	call storage_read_block 
4b84			 ;       ld hl, store_page+2 
4b84			; 
4b84			; 
4b84			;		NEXTW 
4b84			;.BYNAME: 
4b84				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4b84 3a				db WORD_SYS_CORE+38             
4b85 9d 4b			dw .DIR            
4b87 06				db 5 + 1 
4b88 .. 00			db "GETID",0              
4b8e				endm 
# End of macro CWHEAD
4b8e			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4b8e			 
4b8e					; get pointer to file name to seek 
4b8e			 
4b8e					FORTH_DSP_VALUEHL 
4b8e cd 5e 21			call macro_dsp_valuehl 
4b91				endm 
# End of macro FORTH_DSP_VALUEHL
4b91			 
4b91			 
4b91 cd 43 03				call storage_getid  
4b94			 
4b94					FORTH_DSP_POP 
4b94 cd 16 22			call macro_forth_dsp_pop 
4b97				endm 
# End of macro FORTH_DSP_POP
4b97			 
4b97 cd 67 1f				call forth_push_numhl 
4b9a			 
4b9a					NEXTW 
4b9a c3 d5 22			jp macro_next 
4b9d				endm 
# End of macro NEXTW
4b9d			; 
4b9d			.DIR: 
4b9d				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4b9d 3a				db WORD_SYS_CORE+38             
4b9e a1 4c			dw .SAVE            
4ba0 04				db 3 + 1 
4ba1 .. 00			db "DIR",0              
4ba5				endm 
# End of macro CWHEAD
4ba5			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4ba5			 
4ba5					if DEBUG_FORTH_WORDS_KEY 
4ba5						DMARK "DIR" 
4ba5 f5				push af  
4ba6 3a ba 4b			ld a, (.dmark)  
4ba9 32 6e fe			ld (debug_mark),a  
4bac 3a bb 4b			ld a, (.dmark+1)  
4baf 32 6f fe			ld (debug_mark+1),a  
4bb2 3a bc 4b			ld a, (.dmark+2)  
4bb5 32 70 fe			ld (debug_mark+2),a  
4bb8 18 03			jr .pastdmark  
4bba ..			.dmark: db "DIR"  
4bbd f1			.pastdmark: pop af  
4bbe			endm  
# End of macro DMARK
4bbe						CALLMONITOR 
4bbe cd f3 18			call break_point_state  
4bc1				endm  
# End of macro CALLMONITOR
4bc1					endif 
4bc1 cd cd 04			call storage_get_block_0 
4bc4			 
4bc4 21 81 fa			ld hl, store_page     ; get current id count 
4bc7 46				ld b, (hl) 
4bc8 0e 00			ld c, 0    ; count of files   
4bca					if DEBUG_FORTH_WORDS 
4bca						DMARK "DI1" 
4bca f5				push af  
4bcb 3a df 4b			ld a, (.dmark)  
4bce 32 6e fe			ld (debug_mark),a  
4bd1 3a e0 4b			ld a, (.dmark+1)  
4bd4 32 6f fe			ld (debug_mark+1),a  
4bd7 3a e1 4b			ld a, (.dmark+2)  
4bda 32 70 fe			ld (debug_mark+2),a  
4bdd 18 03			jr .pastdmark  
4bdf ..			.dmark: db "DI1"  
4be2 f1			.pastdmark: pop af  
4be3			endm  
# End of macro DMARK
4be3						CALLMONITOR 
4be3 cd f3 18			call break_point_state  
4be6				endm  
# End of macro CALLMONITOR
4be6					endif 
4be6			 
4be6				; check for empty drive 
4be6			 
4be6 3e 00			ld a, 0 
4be8 b8				cp b 
4be9 ca 57 4c			jp z, .dirdone 
4bec			 
4bec				; for each of the current ids do a search for them and if found push to stack 
4bec			 
4bec c5			.diritem:	push bc 
4bed 21 40 00				ld hl, STORE_BLOCK_PHY 
4bf0 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4bf2 58					ld e,b 
4bf3			 
4bf3			;		if DEBUG_FORTH_WORDS 
4bf3			;			DMARK "DI2" 
4bf3			;			CALLMONITOR 
4bf3			;		endif 
4bf3			 
4bf3 cd 4f 07				call storage_findnextid 
4bf6			 
4bf6			;		if DEBUG_FORTH_WORDS 
4bf6			;			DMARK "DI3" 
4bf6			;			CALLMONITOR 
4bf6			;		endif 
4bf6			 
4bf6					; if found hl will be non zero 
4bf6			 
4bf6 cd 75 0f				call ishlzero 
4bf9			;		ld a, l 
4bf9			;		add h 
4bf9			; 
4bf9			;		cp 0 
4bf9 28 59				jr z, .dirnotfound 
4bfb			 
4bfb					; increase count 
4bfb			 
4bfb c1					pop bc	 
4bfc 0c					inc c 
4bfd c5					push bc 
4bfe					 
4bfe			 
4bfe					; get file header and push the file name 
4bfe			 
4bfe 11 81 fa				ld de, store_page 
4c01 cd 1c 04				call storage_read_block 
4c04			 
4c04					; push file id to stack 
4c04				 
4c04 3a 81 fa				ld a, (store_page) 
4c07 26 00				ld h, 0 
4c09 6f					ld l, a 
4c0a cd 67 1f				call forth_push_numhl 
4c0d			 
4c0d					; push extent count to stack  
4c0d				 
4c0d 3a 83 fa				ld a, (store_page+2) 
4c10 26 00				ld h, 0 
4c12 6f					ld l, a 
4c13 cd 67 1f				call forth_push_numhl 
4c16			 
4c16					; push file name 
4c16			 
4c16 21 84 fa				ld hl, store_page+3 
4c19					if DEBUG_FORTH_WORDS 
4c19						DMARK "DI5" 
4c19 f5				push af  
4c1a 3a 2e 4c			ld a, (.dmark)  
4c1d 32 6e fe			ld (debug_mark),a  
4c20 3a 2f 4c			ld a, (.dmark+1)  
4c23 32 6f fe			ld (debug_mark+1),a  
4c26 3a 30 4c			ld a, (.dmark+2)  
4c29 32 70 fe			ld (debug_mark+2),a  
4c2c 18 03			jr .pastdmark  
4c2e ..			.dmark: db "DI5"  
4c31 f1			.pastdmark: pop af  
4c32			endm  
# End of macro DMARK
4c32						CALLMONITOR 
4c32 cd f3 18			call break_point_state  
4c35				endm  
# End of macro CALLMONITOR
4c35					endif 
4c35 cd d5 1f				call forth_push_str 
4c38					if DEBUG_FORTH_WORDS 
4c38						DMARK "DI6" 
4c38 f5				push af  
4c39 3a 4d 4c			ld a, (.dmark)  
4c3c 32 6e fe			ld (debug_mark),a  
4c3f 3a 4e 4c			ld a, (.dmark+1)  
4c42 32 6f fe			ld (debug_mark+1),a  
4c45 3a 4f 4c			ld a, (.dmark+2)  
4c48 32 70 fe			ld (debug_mark+2),a  
4c4b 18 03			jr .pastdmark  
4c4d ..			.dmark: db "DI6"  
4c50 f1			.pastdmark: pop af  
4c51			endm  
# End of macro DMARK
4c51						CALLMONITOR 
4c51 cd f3 18			call break_point_state  
4c54				endm  
# End of macro CALLMONITOR
4c54					endif 
4c54			.dirnotfound: 
4c54 c1					pop bc     
4c55 10 95				djnz .diritem 
4c57				 
4c57			.dirdone:	 
4c57					if DEBUG_FORTH_WORDS 
4c57						DMARK "DI7" 
4c57 f5				push af  
4c58 3a 6c 4c			ld a, (.dmark)  
4c5b 32 6e fe			ld (debug_mark),a  
4c5e 3a 6d 4c			ld a, (.dmark+1)  
4c61 32 6f fe			ld (debug_mark+1),a  
4c64 3a 6e 4c			ld a, (.dmark+2)  
4c67 32 70 fe			ld (debug_mark+2),a  
4c6a 18 03			jr .pastdmark  
4c6c ..			.dmark: db "DI7"  
4c6f f1			.pastdmark: pop af  
4c70			endm  
# End of macro DMARK
4c70						CALLMONITOR 
4c70 cd f3 18			call break_point_state  
4c73				endm  
# End of macro CALLMONITOR
4c73					endif 
4c73			 
4c73					; push a count of the dir items found 
4c73			 
4c73 26 00				ld h, 0 
4c75 69					ld l, c 
4c76 cd 67 1f				call forth_push_numhl 
4c79			 
4c79					; push the bank label 
4c79			 
4c79 cd cd 04				call storage_get_block_0 
4c7c			 
4c7c				 
4c7c 21 84 fa		 		ld hl, store_page+3 
4c7f			 
4c7f					if DEBUG_FORTH_WORDS 
4c7f						DMARK "DI8" 
4c7f f5				push af  
4c80 3a 94 4c			ld a, (.dmark)  
4c83 32 6e fe			ld (debug_mark),a  
4c86 3a 95 4c			ld a, (.dmark+1)  
4c89 32 6f fe			ld (debug_mark+1),a  
4c8c 3a 96 4c			ld a, (.dmark+2)  
4c8f 32 70 fe			ld (debug_mark+2),a  
4c92 18 03			jr .pastdmark  
4c94 ..			.dmark: db "DI8"  
4c97 f1			.pastdmark: pop af  
4c98			endm  
# End of macro DMARK
4c98						CALLMONITOR 
4c98 cd f3 18			call break_point_state  
4c9b				endm  
# End of macro CALLMONITOR
4c9b					endif 
4c9b cd d5 1f				call forth_push_str 
4c9e			 
4c9e			 
4c9e				 
4c9e					NEXTW 
4c9e c3 d5 22			jp macro_next 
4ca1				endm 
# End of macro NEXTW
4ca1			.SAVE: 
4ca1			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4ca1			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4ca1			;		NEXTW 
4ca1			;.LOAD: 
4ca1			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4ca1			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4ca1			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4ca1			;; > > The LOAD command can not be used in any user words or compound lines. 
4ca1			; 
4ca1			;		; store_openext use it. If zero it is EOF 
4ca1			; 
4ca1			;		; read block from current stream id 
4ca1			;		; if the block does not contain zero term keep reading blocks until zero found 
4ca1			;		; push the block to stack 
4ca1			;		; save the block id to stream 
4ca1			; 
4ca1			; 
4ca1			;		FORTH_DSP_VALUEHL 
4ca1			; 
4ca1			;;		push hl 
4ca1			; 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LOA" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;		FORTH_DSP_POP 
4ca1			; 
4ca1			;;		pop hl 
4ca1			; 
4ca1			;		ld h, l 
4ca1			;		ld l, 0 
4ca1			; 
4ca1			;		push hl     ; stack holds current file id and extent to work with 
4ca1			; 
4ca1			; 
4ca1			;		ld de, store_page      ; get block zero of file 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LO0" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;		call storage_read 
4ca1			; 
4ca1			;		ld a, (store_page+2)    ; max extents for this file 
4ca1			;		ld  (store_openmaxext),a   ; get our limit 
4ca1			; 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LOE" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			; 
4ca1			;; TODO dont know why max extents are not present 
4ca1			;;		cp 0 
4ca1			;;		jp z, .loadeof     ; dont read past eof 
4ca1			; 
4ca1			;;		ld a, 1   ; start from the head of the file 
4ca1			; 
4ca1			;.loadline:	pop hl 
4ca1			;		inc hl 
4ca1			;		ld  a, (store_openmaxext)   ; get our limit 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LOx" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;		inc a 
4ca1			;		cp l 
4ca1			;		jp z, .loadeof 
4ca1			;		push hl    ; save current extent 
4ca1			; 
4ca1			;		ld de, store_page 
4ca1			; 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LO1" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;		call storage_read 
4ca1			; 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LO2" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;	call ishlzero 
4ca1			;	ld a, l 
4ca1			;	add h 
4ca1			;	cp 0 
4ca1			;	jr z, .loadeof 
4ca1			; 
4ca1			;	; not eof so hl should point to data to exec 
4ca1			; 
4ca1			;	; will need to add the FORTH_END_BUFFER flag 
4ca1			 ; 
4ca1			;	ld hl, store_page+2 
4ca1			;	ld bc, 255 
4ca1			;	ld a, 0 
4ca1			;	cpir 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LOt" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;	dec hl 
4ca1			;	ld a, ' ' 
4ca1			;	ld (hl), a 
4ca1			;	inc hl 
4ca1			;	ld (hl), a 
4ca1			;	inc hl 
4ca1			;	ld (hl), a 
4ca1			;	inc hl 
4ca1			;	ld a, FORTH_END_BUFFER 
4ca1			;	ld (hl), a 
4ca1			; 
4ca1			;	; TODO handle more than a single block read 
4ca1			; 
4ca1			; 
4ca1			;	ld hl, store_page+2 
4ca1			; 
4ca1			;	ld (os_tok_ptr), hl 
4ca1			; 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LO3" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			; 
4ca1			;	call forthparse 
4ca1			;	call forthexec 
4ca1			;	call forthexec_cleanup 
4ca1			; 
4ca1			;	; go to next extent 
4ca1			; 
4ca1			;	; get next block  or mark as eof 
4ca1			;	jp .loadline 
4ca1			; 
4ca1			; 
4ca1			; 
4ca1			;	       NEXTW 
4ca1			;.loadeof:	ld a, 0 
4ca1			;		ld (store_openext), a 
4ca1			; 
4ca1			;	if DEBUG_STORESE 
4ca1			;		DMARK "LOF" 
4ca1			;		CALLMONITOR 
4ca1			;	endif 
4ca1			;		ret 
4ca1			;		;NEXTW 
4ca1			;.BSAVE:   
4ca1			; 
4ca1			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4ca1			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4ca1			;		NEXTW 
4ca1			;.BLOAD: 
4ca1			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4ca1			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4ca1			;		NEXTW 
4ca1			;;;; counter gap 
4ca1			 
4ca1			 
4ca1			.SEO: 
4ca1				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4ca1 64				db WORD_SYS_CORE+80             
4ca2 c0 4c			dw .SEI            
4ca4 04				db 3 + 1 
4ca5 .. 00			db "SEO",0              
4ca9				endm 
# End of macro CWHEAD
4ca9			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4ca9			 
4ca9					; get port 
4ca9			 
4ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ca9 cd 5e 21			call macro_dsp_valuehl 
4cac				endm 
# End of macro FORTH_DSP_VALUEHL
4cac			 
4cac e5					push hl    ; u2 - byte 
4cad			 
4cad					; destroy value TOS 
4cad			 
4cad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cad cd 16 22			call macro_forth_dsp_pop 
4cb0				endm 
# End of macro FORTH_DSP_POP
4cb0			 
4cb0					; get byte to send 
4cb0			 
4cb0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cb0 cd 5e 21			call macro_dsp_valuehl 
4cb3				endm 
# End of macro FORTH_DSP_VALUEHL
4cb3			 
4cb3 e5					push hl    ; u1 - addr 
4cb4			 
4cb4					; destroy value TOS 
4cb4			 
4cb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cb4 cd 16 22			call macro_forth_dsp_pop 
4cb7				endm 
# End of macro FORTH_DSP_POP
4cb7			 
4cb7					; one value on hl get other one back 
4cb7			 
4cb7 d1					pop de   ; u1 - byte 
4cb8			 
4cb8 e1					pop hl   ; u2 - addr 
4cb9			 
4cb9					; TODO Send SPI byte 
4cb9			 
4cb9			 
4cb9 7b					ld a, e 
4cba cd 21 02				call se_writebyte 
4cbd			 
4cbd					 
4cbd			 
4cbd					NEXTW 
4cbd c3 d5 22			jp macro_next 
4cc0				endm 
# End of macro NEXTW
4cc0			 
4cc0			.SEI: 
4cc0				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4cc0 65				db WORD_SYS_CORE+81             
4cc1 da 4c			dw .SFREE            
4cc3 04				db 3 + 1 
4cc4 .. 00			db "SEI",0              
4cc8				endm 
# End of macro CWHEAD
4cc8			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4cc8			 
4cc8					; get port 
4cc8			 
4cc8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cc8 cd 5e 21			call macro_dsp_valuehl 
4ccb				endm 
# End of macro FORTH_DSP_VALUEHL
4ccb			 
4ccb			;		push hl 
4ccb			 
4ccb					; destroy value TOS 
4ccb			 
4ccb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ccb cd 16 22			call macro_forth_dsp_pop 
4cce				endm 
# End of macro FORTH_DSP_POP
4cce			 
4cce					; one value on hl get other one back 
4cce			 
4cce			;		pop hl 
4cce			 
4cce			 
4cce					; TODO Get SPI byte 
4cce			 
4cce cd c3 02				call se_readbyte 
4cd1			 
4cd1 26 00				ld h, 0 
4cd3 6f					ld l, a 
4cd4 cd 67 1f				call forth_push_numhl 
4cd7			 
4cd7					NEXTW 
4cd7 c3 d5 22			jp macro_next 
4cda				endm 
# End of macro NEXTW
4cda			 
4cda			.SFREE: 
4cda				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4cda 67				db WORD_SYS_CORE+83             
4cdb 09 4d			dw .SIZE            
4cdd 06				db 5 + 1 
4cde .. 00			db "FFREE",0              
4ce4				endm 
# End of macro CWHEAD
4ce4			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4ce4					if DEBUG_FORTH_WORDS_KEY 
4ce4						DMARK "FFR" 
4ce4 f5				push af  
4ce5 3a f9 4c			ld a, (.dmark)  
4ce8 32 6e fe			ld (debug_mark),a  
4ceb 3a fa 4c			ld a, (.dmark+1)  
4cee 32 6f fe			ld (debug_mark+1),a  
4cf1 3a fb 4c			ld a, (.dmark+2)  
4cf4 32 70 fe			ld (debug_mark+2),a  
4cf7 18 03			jr .pastdmark  
4cf9 ..			.dmark: db "FFR"  
4cfc f1			.pastdmark: pop af  
4cfd			endm  
# End of macro DMARK
4cfd						CALLMONITOR 
4cfd cd f3 18			call break_point_state  
4d00				endm  
# End of macro CALLMONITOR
4d00					endif 
4d00			 
4d00 cd e9 07				call storage_freeblocks 
4d03			 
4d03 cd 67 1f				call forth_push_numhl 
4d06			 
4d06				       NEXTW 
4d06 c3 d5 22			jp macro_next 
4d09				endm 
# End of macro NEXTW
4d09			.SIZE: 
4d09				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4d09 67				db WORD_SYS_CORE+83             
4d0a 3d 4d			dw .CREATE            
4d0c 05				db 4 + 1 
4d0d .. 00			db "SIZE",0              
4d12				endm 
# End of macro CWHEAD
4d12			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4d12					if DEBUG_FORTH_WORDS_KEY 
4d12						DMARK "SIZ" 
4d12 f5				push af  
4d13 3a 27 4d			ld a, (.dmark)  
4d16 32 6e fe			ld (debug_mark),a  
4d19 3a 28 4d			ld a, (.dmark+1)  
4d1c 32 6f fe			ld (debug_mark+1),a  
4d1f 3a 29 4d			ld a, (.dmark+2)  
4d22 32 70 fe			ld (debug_mark+2),a  
4d25 18 03			jr .pastdmark  
4d27 ..			.dmark: db "SIZ"  
4d2a f1			.pastdmark: pop af  
4d2b			endm  
# End of macro DMARK
4d2b						CALLMONITOR 
4d2b cd f3 18			call break_point_state  
4d2e				endm  
# End of macro CALLMONITOR
4d2e					endif 
4d2e			 
4d2e					FORTH_DSP_VALUEHL 
4d2e cd 5e 21			call macro_dsp_valuehl 
4d31				endm 
# End of macro FORTH_DSP_VALUEHL
4d31			;		push hl 
4d31					FORTH_DSP_POP 
4d31 cd 16 22			call macro_forth_dsp_pop 
4d34				endm 
# End of macro FORTH_DSP_POP
4d34			;		pop hl 
4d34 cd 4b 04				call storage_file_size 
4d37			 
4d37 cd 67 1f				call forth_push_numhl 
4d3a			  
4d3a			 
4d3a				       NEXTW 
4d3a c3 d5 22			jp macro_next 
4d3d				endm 
# End of macro NEXTW
4d3d			 
4d3d			.CREATE: 
4d3d				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4d3d 68				db WORD_SYS_CORE+84             
4d3e ab 4d			dw .APPEND            
4d40 07				db 6 + 1 
4d41 .. 00			db "CREATE",0              
4d48				endm 
# End of macro CWHEAD
4d48			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4d48			; | | e.g.  
4d48			; | | TestProgram CREATE 
4d48			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4d48			; | |  
4d48			; | | Max file IDs are 255. 
4d48			; | |  
4d48					 
4d48					if DEBUG_FORTH_WORDS_KEY 
4d48						DMARK "CRT" 
4d48 f5				push af  
4d49 3a 5d 4d			ld a, (.dmark)  
4d4c 32 6e fe			ld (debug_mark),a  
4d4f 3a 5e 4d			ld a, (.dmark+1)  
4d52 32 6f fe			ld (debug_mark+1),a  
4d55 3a 5f 4d			ld a, (.dmark+2)  
4d58 32 70 fe			ld (debug_mark+2),a  
4d5b 18 03			jr .pastdmark  
4d5d ..			.dmark: db "CRT"  
4d60 f1			.pastdmark: pop af  
4d61			endm  
# End of macro DMARK
4d61						CALLMONITOR 
4d61 cd f3 18			call break_point_state  
4d64				endm  
# End of macro CALLMONITOR
4d64					endif 
4d64			;		call storage_get_block_0 
4d64			 
4d64					; TODO pop hl 
4d64			 
4d64					;v5 FORTH_DSP_VALUE 
4d64					FORTH_DSP_VALUE 
4d64 cd 47 21			call macro_forth_dsp_value 
4d67				endm 
# End of macro FORTH_DSP_VALUE
4d67			 
4d67				if DEBUG_STORESE 
4d67					DMARK "CR1" 
4d67 f5				push af  
4d68 3a 7c 4d			ld a, (.dmark)  
4d6b 32 6e fe			ld (debug_mark),a  
4d6e 3a 7d 4d			ld a, (.dmark+1)  
4d71 32 6f fe			ld (debug_mark+1),a  
4d74 3a 7e 4d			ld a, (.dmark+2)  
4d77 32 70 fe			ld (debug_mark+2),a  
4d7a 18 03			jr .pastdmark  
4d7c ..			.dmark: db "CR1"  
4d7f f1			.pastdmark: pop af  
4d80			endm  
# End of macro DMARK
4d80					CALLMONITOR 
4d80 cd f3 18			call break_point_state  
4d83				endm  
# End of macro CALLMONITOR
4d83				endif 
4d83			;		push hl 
4d83			;		FORTH_DSP_POP 
4d83			;		pop hl 
4d83			 
4d83			;		inc hl   ; move past the type marker 
4d83			 
4d83 cd 1f 08				call storage_create 
4d86			 
4d86				if DEBUG_STORESE 
4d86					DMARK "CT1" 
4d86 f5				push af  
4d87 3a 9b 4d			ld a, (.dmark)  
4d8a 32 6e fe			ld (debug_mark),a  
4d8d 3a 9c 4d			ld a, (.dmark+1)  
4d90 32 6f fe			ld (debug_mark+1),a  
4d93 3a 9d 4d			ld a, (.dmark+2)  
4d96 32 70 fe			ld (debug_mark+2),a  
4d99 18 03			jr .pastdmark  
4d9b ..			.dmark: db "CT1"  
4d9e f1			.pastdmark: pop af  
4d9f			endm  
# End of macro DMARK
4d9f					CALLMONITOR 
4d9f cd f3 18			call break_point_state  
4da2				endm  
# End of macro CALLMONITOR
4da2				endif 
4da2			;		push hl 
4da2					FORTH_DSP_POP 
4da2 cd 16 22			call macro_forth_dsp_pop 
4da5				endm 
# End of macro FORTH_DSP_POP
4da5			;		pop hl 
4da5					; push file id to stack 
4da5 cd 67 1f				call forth_push_numhl 
4da8			 
4da8			 
4da8			 
4da8				       NEXTW 
4da8 c3 d5 22			jp macro_next 
4dab				endm 
# End of macro NEXTW
4dab			 
4dab			.APPEND: 
4dab				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4dab 69				db WORD_SYS_CORE+85             
4dac 3c 4e			dw .SDEL            
4dae 07				db 6 + 1 
4daf .. 00			db "APPEND",0              
4db6				endm 
# End of macro CWHEAD
4db6			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4db6			; | | e.g. 
4db6			; | | Test CREATE      -> $01 
4db6			; | | "A string to add to file" $01 APPEND 
4db6			; | |  
4db6			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4db6					if DEBUG_FORTH_WORDS_KEY 
4db6						DMARK "APP" 
4db6 f5				push af  
4db7 3a cb 4d			ld a, (.dmark)  
4dba 32 6e fe			ld (debug_mark),a  
4dbd 3a cc 4d			ld a, (.dmark+1)  
4dc0 32 6f fe			ld (debug_mark+1),a  
4dc3 3a cd 4d			ld a, (.dmark+2)  
4dc6 32 70 fe			ld (debug_mark+2),a  
4dc9 18 03			jr .pastdmark  
4dcb ..			.dmark: db "APP"  
4dce f1			.pastdmark: pop af  
4dcf			endm  
# End of macro DMARK
4dcf						CALLMONITOR 
4dcf cd f3 18			call break_point_state  
4dd2				endm  
# End of macro CALLMONITOR
4dd2					endif 
4dd2			 
4dd2					FORTH_DSP_VALUEHL 
4dd2 cd 5e 21			call macro_dsp_valuehl 
4dd5				endm 
# End of macro FORTH_DSP_VALUEHL
4dd5 e5					push hl 	; save file id 
4dd6			 
4dd6				if DEBUG_STORESE 
4dd6					DMARK "AP1" 
4dd6 f5				push af  
4dd7 3a eb 4d			ld a, (.dmark)  
4dda 32 6e fe			ld (debug_mark),a  
4ddd 3a ec 4d			ld a, (.dmark+1)  
4de0 32 6f fe			ld (debug_mark+1),a  
4de3 3a ed 4d			ld a, (.dmark+2)  
4de6 32 70 fe			ld (debug_mark+2),a  
4de9 18 03			jr .pastdmark  
4deb ..			.dmark: db "AP1"  
4dee f1			.pastdmark: pop af  
4def			endm  
# End of macro DMARK
4def					CALLMONITOR 
4def cd f3 18			call break_point_state  
4df2				endm  
# End of macro CALLMONITOR
4df2				endif 
4df2					FORTH_DSP_POP 
4df2 cd 16 22			call macro_forth_dsp_pop 
4df5				endm 
# End of macro FORTH_DSP_POP
4df5			 
4df5					FORTH_DSP_VALUEHL 
4df5 cd 5e 21			call macro_dsp_valuehl 
4df8				endm 
# End of macro FORTH_DSP_VALUEHL
4df8					;v5 FORTH_DSP_VALUE 
4df8 e5					push hl 	; save ptr to string to save 
4df9			 
4df9				if DEBUG_STORESE 
4df9					DMARK "AP1" 
4df9 f5				push af  
4dfa 3a 0e 4e			ld a, (.dmark)  
4dfd 32 6e fe			ld (debug_mark),a  
4e00 3a 0f 4e			ld a, (.dmark+1)  
4e03 32 6f fe			ld (debug_mark+1),a  
4e06 3a 10 4e			ld a, (.dmark+2)  
4e09 32 70 fe			ld (debug_mark+2),a  
4e0c 18 03			jr .pastdmark  
4e0e ..			.dmark: db "AP1"  
4e11 f1			.pastdmark: pop af  
4e12			endm  
# End of macro DMARK
4e12					CALLMONITOR 
4e12 cd f3 18			call break_point_state  
4e15				endm  
# End of macro CALLMONITOR
4e15				endif 
4e15					FORTH_DSP_POP 
4e15 cd 16 22			call macro_forth_dsp_pop 
4e18				endm 
# End of macro FORTH_DSP_POP
4e18			 
4e18 d1					pop de 
4e19 e1					pop hl 
4e1a				if DEBUG_STORESE 
4e1a					DMARK "AP2" 
4e1a f5				push af  
4e1b 3a 2f 4e			ld a, (.dmark)  
4e1e 32 6e fe			ld (debug_mark),a  
4e21 3a 30 4e			ld a, (.dmark+1)  
4e24 32 6f fe			ld (debug_mark+1),a  
4e27 3a 31 4e			ld a, (.dmark+2)  
4e2a 32 70 fe			ld (debug_mark+2),a  
4e2d 18 03			jr .pastdmark  
4e2f ..			.dmark: db "AP2"  
4e32 f1			.pastdmark: pop af  
4e33			endm  
# End of macro DMARK
4e33					CALLMONITOR 
4e33 cd f3 18			call break_point_state  
4e36				endm  
# End of macro CALLMONITOR
4e36				endif 
4e36					;inc de ; skip var type indicator 
4e36			 
4e36					; TODO how to append numerics???? 
4e36			 
4e36 cd 0c 0b				call storage_append		 
4e39			 
4e39				       NEXTW 
4e39 c3 d5 22			jp macro_next 
4e3c				endm 
# End of macro NEXTW
4e3c			.SDEL: 
4e3c				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4e3c 6a				db WORD_SYS_CORE+86             
4e3d 88 4e			dw .OPEN            
4e3f 05				db 4 + 1 
4e40 .. 00			db "ERA",0              
4e44				endm 
# End of macro CWHEAD
4e44			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4e44					FORTH_DSP_VALUEHL 
4e44 cd 5e 21			call macro_dsp_valuehl 
4e47				endm 
# End of macro FORTH_DSP_VALUEHL
4e47			;		push hl 	; save file id 
4e47			 
4e47					if DEBUG_FORTH_WORDS_KEY 
4e47						DMARK "ERA" 
4e47 f5				push af  
4e48 3a 5c 4e			ld a, (.dmark)  
4e4b 32 6e fe			ld (debug_mark),a  
4e4e 3a 5d 4e			ld a, (.dmark+1)  
4e51 32 6f fe			ld (debug_mark+1),a  
4e54 3a 5e 4e			ld a, (.dmark+2)  
4e57 32 70 fe			ld (debug_mark+2),a  
4e5a 18 03			jr .pastdmark  
4e5c ..			.dmark: db "ERA"  
4e5f f1			.pastdmark: pop af  
4e60			endm  
# End of macro DMARK
4e60						CALLMONITOR 
4e60 cd f3 18			call break_point_state  
4e63				endm  
# End of macro CALLMONITOR
4e63					endif 
4e63				if DEBUG_STORESE 
4e63					DMARK "ER1" 
4e63 f5				push af  
4e64 3a 78 4e			ld a, (.dmark)  
4e67 32 6e fe			ld (debug_mark),a  
4e6a 3a 79 4e			ld a, (.dmark+1)  
4e6d 32 6f fe			ld (debug_mark+1),a  
4e70 3a 7a 4e			ld a, (.dmark+2)  
4e73 32 70 fe			ld (debug_mark+2),a  
4e76 18 03			jr .pastdmark  
4e78 ..			.dmark: db "ER1"  
4e7b f1			.pastdmark: pop af  
4e7c			endm  
# End of macro DMARK
4e7c					CALLMONITOR 
4e7c cd f3 18			call break_point_state  
4e7f				endm  
# End of macro CALLMONITOR
4e7f				endif 
4e7f					FORTH_DSP_POP 
4e7f cd 16 22			call macro_forth_dsp_pop 
4e82				endm 
# End of macro FORTH_DSP_POP
4e82			 
4e82			;		pop hl 
4e82			 
4e82 cd 5e 06				call storage_erase 
4e85				       NEXTW 
4e85 c3 d5 22			jp macro_next 
4e88				endm 
# End of macro NEXTW
4e88			 
4e88			.OPEN: 
4e88				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4e88 6b				db WORD_SYS_CORE+87             
4e89 1c 4f			dw .READ            
4e8b 05				db 4 + 1 
4e8c .. 00			db "OPEN",0              
4e91				endm 
# End of macro CWHEAD
4e91			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4e91			; | | e.g. 
4e91			; | | $01 OPEN $01 DO $01 READ . LOOP 
4e91			; | | 
4e91			; | | Will return with 255 blocks if the file does not exist 
4e91			 
4e91					if DEBUG_FORTH_WORDS_KEY 
4e91						DMARK "OPN" 
4e91 f5				push af  
4e92 3a a6 4e			ld a, (.dmark)  
4e95 32 6e fe			ld (debug_mark),a  
4e98 3a a7 4e			ld a, (.dmark+1)  
4e9b 32 6f fe			ld (debug_mark+1),a  
4e9e 3a a8 4e			ld a, (.dmark+2)  
4ea1 32 70 fe			ld (debug_mark+2),a  
4ea4 18 03			jr .pastdmark  
4ea6 ..			.dmark: db "OPN"  
4ea9 f1			.pastdmark: pop af  
4eaa			endm  
# End of macro DMARK
4eaa						CALLMONITOR 
4eaa cd f3 18			call break_point_state  
4ead				endm  
# End of macro CALLMONITOR
4ead					endif 
4ead					; TODO handle multiple file opens 
4ead			 
4ead 3e 01			       	ld a, 1 
4eaf 32 71 fa				ld (store_openext), a 
4eb2			 
4eb2					; get max extents for this file 
4eb2				 
4eb2								 
4eb2					FORTH_DSP_VALUEHL 
4eb2 cd 5e 21			call macro_dsp_valuehl 
4eb5				endm 
# End of macro FORTH_DSP_VALUEHL
4eb5			 
4eb5 65					ld h, l 
4eb6 2e 00				ld l, 0 
4eb8			 
4eb8					; store file id 
4eb8			 
4eb8 7c					ld a, h 
4eb9 32 6e fa				ld (store_filecache), a 
4ebc			 
4ebc				if DEBUG_STORESE 
4ebc					DMARK "OPN" 
4ebc f5				push af  
4ebd 3a d1 4e			ld a, (.dmark)  
4ec0 32 6e fe			ld (debug_mark),a  
4ec3 3a d2 4e			ld a, (.dmark+1)  
4ec6 32 6f fe			ld (debug_mark+1),a  
4ec9 3a d3 4e			ld a, (.dmark+2)  
4ecc 32 70 fe			ld (debug_mark+2),a  
4ecf 18 03			jr .pastdmark  
4ed1 ..			.dmark: db "OPN"  
4ed4 f1			.pastdmark: pop af  
4ed5			endm  
# End of macro DMARK
4ed5					CALLMONITOR 
4ed5 cd f3 18			call break_point_state  
4ed8				endm  
# End of macro CALLMONITOR
4ed8				endif 
4ed8			;		push hl 
4ed8					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4ed8 cd 16 22			call macro_forth_dsp_pop 
4edb				endm 
# End of macro FORTH_DSP_POP
4edb			;		pop hl 
4edb						 
4edb 11 81 fa				ld de, store_page      ; get block zero of file 
4ede cd 75 09				call storage_read 
4ee1 cd 75 0f			call ishlzero 
4ee4 20 04			jr nz, .opfound 
4ee6			 
4ee6				; file does not exist so indicate with 255 extents in use 
4ee6			 
4ee6 3e ff			ld a, 255 
4ee8 18 29			jr .skipopeneof 
4eea			 
4eea			 
4eea			.opfound: 
4eea			 
4eea			 
4eea 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
4eed 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
4ef0					 
4ef0				if DEBUG_STORESE 
4ef0					DMARK "OPx" 
4ef0 f5				push af  
4ef1 3a 05 4f			ld a, (.dmark)  
4ef4 32 6e fe			ld (debug_mark),a  
4ef7 3a 06 4f			ld a, (.dmark+1)  
4efa 32 6f fe			ld (debug_mark+1),a  
4efd 3a 07 4f			ld a, (.dmark+2)  
4f00 32 70 fe			ld (debug_mark+2),a  
4f03 18 03			jr .pastdmark  
4f05 ..			.dmark: db "OPx"  
4f08 f1			.pastdmark: pop af  
4f09			endm  
# End of macro DMARK
4f09					CALLMONITOR 
4f09 cd f3 18			call break_point_state  
4f0c				endm  
# End of macro CALLMONITOR
4f0c				endif 
4f0c fe 00				cp 0 
4f0e 20 03				jr nz, .skipopeneof 
4f10					; have opened an empty file 
4f10					 
4f10 32 71 fa				ld (store_openext), a 
4f13			 
4f13			.skipopeneof: 
4f13			 
4f13 6f					ld l, a 
4f14 26 00				ld h, 0 
4f16 cd 67 1f				call forth_push_numhl 
4f19			 
4f19			 
4f19				       NEXTW 
4f19 c3 d5 22			jp macro_next 
4f1c				endm 
# End of macro NEXTW
4f1c			.READ: 
4f1c				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4f1c 6c				db WORD_SYS_CORE+88             
4f1d 46 50			dw .EOF            
4f1f 05				db 4 + 1 
4f20 .. 00			db "READ",0              
4f25				endm 
# End of macro CWHEAD
4f25			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4f25			; | | e.g. 
4f25			; | | $01 OPEN $01 DO READ . LOOP 
4f25			; | | 
4f25			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4f25			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4f25			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4f25			; | | two bytes contain the file id and extent. 
4f25			; | |  
4f25			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4f25			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4f25			 
4f25					if DEBUG_FORTH_WORDS_KEY 
4f25						DMARK "REA" 
4f25 f5				push af  
4f26 3a 3a 4f			ld a, (.dmark)  
4f29 32 6e fe			ld (debug_mark),a  
4f2c 3a 3b 4f			ld a, (.dmark+1)  
4f2f 32 6f fe			ld (debug_mark+1),a  
4f32 3a 3c 4f			ld a, (.dmark+2)  
4f35 32 70 fe			ld (debug_mark+2),a  
4f38 18 03			jr .pastdmark  
4f3a ..			.dmark: db "REA"  
4f3d f1			.pastdmark: pop af  
4f3e			endm  
# End of macro DMARK
4f3e						CALLMONITOR 
4f3e cd f3 18			call break_point_state  
4f41				endm  
# End of macro CALLMONITOR
4f41					endif 
4f41					; store_openext use it. If zero it is EOF 
4f41			 
4f41					; read block from current stream id 
4f41					; if the block does not contain zero term keep reading blocks until zero found 
4f41					; push the block to stack 
4f41					; save the block id to stream 
4f41			 
4f41			 
4f41 cd 73 50				call .testeof 
4f44 3e 01				ld a, 1 
4f46 bd					cp l 
4f47 ca 22 50				jp z, .ateof 
4f4a			 
4f4a			 
4f4a			;		FORTH_DSP_VALUEHL 
4f4a			 
4f4a			;		push hl 
4f4a			 
4f4a			;	if DEBUG_STORESE 
4f4a			;		DMARK "REA" 
4f4a			;		CALLMONITOR 
4f4a			;	endif 
4f4a			;		FORTH_DSP_POP 
4f4a			 
4f4a			;		pop hl 
4f4a				 
4f4a 3a 6e fa				ld a, (store_filecache) 
4f4d 67					ld h,a 
4f4e			 
4f4e 3a 71 fa				ld a, (store_openext) 
4f51 6f					ld l, a 
4f52					 
4f52 fe 00				cp 0 
4f54 ca 22 50				jp z, .ateof     ; dont read past eof 
4f57			 
4f57 cd 58 0c				call storage_clear_page 
4f5a			 
4f5a 11 81 fa				ld de, store_page 
4f5d				if DEBUG_STORESE 
4f5d					DMARK "RE1" 
4f5d f5				push af  
4f5e 3a 72 4f			ld a, (.dmark)  
4f61 32 6e fe			ld (debug_mark),a  
4f64 3a 73 4f			ld a, (.dmark+1)  
4f67 32 6f fe			ld (debug_mark+1),a  
4f6a 3a 74 4f			ld a, (.dmark+2)  
4f6d 32 70 fe			ld (debug_mark+2),a  
4f70 18 03			jr .pastdmark  
4f72 ..			.dmark: db "RE1"  
4f75 f1			.pastdmark: pop af  
4f76			endm  
# End of macro DMARK
4f76					CALLMONITOR 
4f76 cd f3 18			call break_point_state  
4f79				endm  
# End of macro CALLMONITOR
4f79				endif 
4f79 cd 75 09				call storage_read 
4f7c			 
4f7c				if DEBUG_STORESE 
4f7c					DMARK "RE2" 
4f7c f5				push af  
4f7d 3a 91 4f			ld a, (.dmark)  
4f80 32 6e fe			ld (debug_mark),a  
4f83 3a 92 4f			ld a, (.dmark+1)  
4f86 32 6f fe			ld (debug_mark+1),a  
4f89 3a 93 4f			ld a, (.dmark+2)  
4f8c 32 70 fe			ld (debug_mark+2),a  
4f8f 18 03			jr .pastdmark  
4f91 ..			.dmark: db "RE2"  
4f94 f1			.pastdmark: pop af  
4f95			endm  
# End of macro DMARK
4f95					CALLMONITOR 
4f95 cd f3 18			call break_point_state  
4f98				endm  
# End of macro CALLMONITOR
4f98				endif 
4f98 cd 75 0f			call ishlzero 
4f9b			;	ld a, l 
4f9b			;	add h 
4f9b			;	cp 0 
4f9b ca 22 50			jp z, .readeof 
4f9e			 
4f9e				; not eof so hl should point to data to push to stack 
4f9e			 
4f9e				if DEBUG_STORESE 
4f9e					DMARK "RE3" 
4f9e f5				push af  
4f9f 3a b3 4f			ld a, (.dmark)  
4fa2 32 6e fe			ld (debug_mark),a  
4fa5 3a b4 4f			ld a, (.dmark+1)  
4fa8 32 6f fe			ld (debug_mark+1),a  
4fab 3a b5 4f			ld a, (.dmark+2)  
4fae 32 70 fe			ld (debug_mark+2),a  
4fb1 18 03			jr .pastdmark  
4fb3 ..			.dmark: db "RE3"  
4fb6 f1			.pastdmark: pop af  
4fb7			endm  
# End of macro DMARK
4fb7					CALLMONITOR 
4fb7 cd f3 18			call break_point_state  
4fba				endm  
# End of macro CALLMONITOR
4fba				endif 
4fba cd d5 1f			call forth_push_str 
4fbd			 
4fbd				if DEBUG_STORESE 
4fbd					DMARK "RE4" 
4fbd f5				push af  
4fbe 3a d2 4f			ld a, (.dmark)  
4fc1 32 6e fe			ld (debug_mark),a  
4fc4 3a d3 4f			ld a, (.dmark+1)  
4fc7 32 6f fe			ld (debug_mark+1),a  
4fca 3a d4 4f			ld a, (.dmark+2)  
4fcd 32 70 fe			ld (debug_mark+2),a  
4fd0 18 03			jr .pastdmark  
4fd2 ..			.dmark: db "RE4"  
4fd5 f1			.pastdmark: pop af  
4fd6			endm  
# End of macro DMARK
4fd6					CALLMONITOR 
4fd6 cd f3 18			call break_point_state  
4fd9				endm  
# End of macro CALLMONITOR
4fd9				endif 
4fd9				; get next block  or mark as eof 
4fd9			 
4fd9 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
4fdc 4f				ld c, a	 
4fdd 3a 71 fa			ld a, (store_openext) 
4fe0			 
4fe0				if DEBUG_STORESE 
4fe0					DMARK "RE5" 
4fe0 f5				push af  
4fe1 3a f5 4f			ld a, (.dmark)  
4fe4 32 6e fe			ld (debug_mark),a  
4fe7 3a f6 4f			ld a, (.dmark+1)  
4fea 32 6f fe			ld (debug_mark+1),a  
4fed 3a f7 4f			ld a, (.dmark+2)  
4ff0 32 70 fe			ld (debug_mark+2),a  
4ff3 18 03			jr .pastdmark  
4ff5 ..			.dmark: db "RE5"  
4ff8 f1			.pastdmark: pop af  
4ff9			endm  
# End of macro DMARK
4ff9					CALLMONITOR 
4ff9 cd f3 18			call break_point_state  
4ffc				endm  
# End of macro CALLMONITOR
4ffc				endif 
4ffc b9				cp c 
4ffd 28 23			jr z, .readeof     ; at last extent 
4fff			 
4fff 3c					inc a 
5000 32 71 fa				ld (store_openext), a 
5003			 
5003				if DEBUG_STORESE 
5003					DMARK "RE6" 
5003 f5				push af  
5004 3a 18 50			ld a, (.dmark)  
5007 32 6e fe			ld (debug_mark),a  
500a 3a 19 50			ld a, (.dmark+1)  
500d 32 6f fe			ld (debug_mark+1),a  
5010 3a 1a 50			ld a, (.dmark+2)  
5013 32 70 fe			ld (debug_mark+2),a  
5016 18 03			jr .pastdmark  
5018 ..			.dmark: db "RE6"  
501b f1			.pastdmark: pop af  
501c			endm  
# End of macro DMARK
501c					CALLMONITOR 
501c cd f3 18			call break_point_state  
501f				endm  
# End of macro CALLMONITOR
501f				endif 
501f			 
501f			 
501f				       NEXTW 
501f c3 d5 22			jp macro_next 
5022				endm 
# End of macro NEXTW
5022			.ateof: 
5022				;	ld hl, .showeof 
5022				;	call forth_push_str 
5022 3e 00		.readeof:	ld a, 0 
5024 32 71 fa				ld (store_openext), a 
5027			 
5027					 
5027				if DEBUG_STORESE 
5027					DMARK "REF" 
5027 f5				push af  
5028 3a 3c 50			ld a, (.dmark)  
502b 32 6e fe			ld (debug_mark),a  
502e 3a 3d 50			ld a, (.dmark+1)  
5031 32 6f fe			ld (debug_mark+1),a  
5034 3a 3e 50			ld a, (.dmark+2)  
5037 32 70 fe			ld (debug_mark+2),a  
503a 18 03			jr .pastdmark  
503c ..			.dmark: db "REF"  
503f f1			.pastdmark: pop af  
5040			endm  
# End of macro DMARK
5040					CALLMONITOR 
5040 cd f3 18			call break_point_state  
5043				endm  
# End of macro CALLMONITOR
5043				endif 
5043				       NEXTW 
5043 c3 d5 22			jp macro_next 
5046				endm 
# End of macro NEXTW
5046			 
5046			;.showeof:   db "eof", 0 
5046			 
5046			 
5046			.EOF: 
5046				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5046 6d				db WORD_SYS_CORE+89             
5047 88 50			dw .FORMAT            
5049 04				db 3 + 1 
504a .. 00			db "EOF",0              
504e				endm 
# End of macro CWHEAD
504e			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
504e			; | | e.g. 
504e			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
504e					; TODO if current block id for stream is zero then push true else false 
504e			 
504e					if DEBUG_FORTH_WORDS_KEY 
504e						DMARK "EOF" 
504e f5				push af  
504f 3a 63 50			ld a, (.dmark)  
5052 32 6e fe			ld (debug_mark),a  
5055 3a 64 50			ld a, (.dmark+1)  
5058 32 6f fe			ld (debug_mark+1),a  
505b 3a 65 50			ld a, (.dmark+2)  
505e 32 70 fe			ld (debug_mark+2),a  
5061 18 03			jr .pastdmark  
5063 ..			.dmark: db "EOF"  
5066 f1			.pastdmark: pop af  
5067			endm  
# End of macro DMARK
5067						CALLMONITOR 
5067 cd f3 18			call break_point_state  
506a				endm  
# End of macro CALLMONITOR
506a					endif 
506a			 
506a					; TODO handlue multiple file streams 
506a			 
506a			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
506a cd 73 50				call .testeof 
506d cd 67 1f				call forth_push_numhl 
5070			 
5070			 
5070				       NEXTW 
5070 c3 d5 22			jp macro_next 
5073				endm 
# End of macro NEXTW
5073			 
5073			.testeof: 
5073 2e 01				ld l, 1 
5075 3a 70 fa				ld a, (store_openmaxext) 
5078 fe 00				cp 0 
507a 28 09				jr  z, .eofdone   ; empty file 
507c 3a 71 fa				ld a, (store_openext) 
507f fe 00				cp 0 
5081 28 02				jr  z, .eofdone 
5083 2e 00				ld l, 0 
5085 26 00		.eofdone:	ld h, 0 
5087 c9					ret 
5088			 
5088			 
5088			 
5088			 
5088			.FORMAT: 
5088				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5088 6d				db WORD_SYS_CORE+89             
5089 d9 50			dw .LABEL            
508b 07				db 6 + 1 
508c .. 00			db "FORMAT",0              
5093				endm 
# End of macro CWHEAD
5093			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5093					; TODO if current block id for stream is zero then push true else false 
5093				 
5093				if DEBUG_STORESE 
5093					DMARK "FOR" 
5093 f5				push af  
5094 3a a8 50			ld a, (.dmark)  
5097 32 6e fe			ld (debug_mark),a  
509a 3a a9 50			ld a, (.dmark+1)  
509d 32 6f fe			ld (debug_mark+1),a  
50a0 3a aa 50			ld a, (.dmark+2)  
50a3 32 70 fe			ld (debug_mark+2),a  
50a6 18 03			jr .pastdmark  
50a8 ..			.dmark: db "FOR"  
50ab f1			.pastdmark: pop af  
50ac			endm  
# End of macro DMARK
50ac					CALLMONITOR 
50ac cd f3 18			call break_point_state  
50af				endm  
# End of macro CALLMONITOR
50af				endif 
50af					; Wipes the bank check flags to cause a reformat on next block 0 read 
50af			 
50af 21 01 00				ld hl, 1 
50b2 3e 00				ld a, 0 
50b4 cd 21 02				call se_writebyte 
50b7			 
50b7				if DEBUG_STORESE 
50b7					DMARK "FO0" 
50b7 f5				push af  
50b8 3a cc 50			ld a, (.dmark)  
50bb 32 6e fe			ld (debug_mark),a  
50be 3a cd 50			ld a, (.dmark+1)  
50c1 32 6f fe			ld (debug_mark+1),a  
50c4 3a ce 50			ld a, (.dmark+2)  
50c7 32 70 fe			ld (debug_mark+2),a  
50ca 18 03			jr .pastdmark  
50cc ..			.dmark: db "FO0"  
50cf f1			.pastdmark: pop af  
50d0			endm  
# End of macro DMARK
50d0					CALLMONITOR 
50d0 cd f3 18			call break_point_state  
50d3				endm  
# End of macro CALLMONITOR
50d3				endif 
50d3					; force bank init 
50d3			 
50d3 cd cd 04				call storage_get_block_0 
50d6					 
50d6				       NEXTW 
50d6 c3 d5 22			jp macro_next 
50d9				endm 
# End of macro NEXTW
50d9			.LABEL: 
50d9				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
50d9 6d				db WORD_SYS_CORE+89             
50da 27 51			dw .STOREPAGE            
50dc 06				db 5 + 1 
50dd .. 00			db "LABEL",0              
50e3				endm 
# End of macro CWHEAD
50e3			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
50e3					; TODO test to see if bank is selected 
50e3				 
50e3					if DEBUG_FORTH_WORDS_KEY 
50e3						DMARK "LBL" 
50e3 f5				push af  
50e4 3a f8 50			ld a, (.dmark)  
50e7 32 6e fe			ld (debug_mark),a  
50ea 3a f9 50			ld a, (.dmark+1)  
50ed 32 6f fe			ld (debug_mark+1),a  
50f0 3a fa 50			ld a, (.dmark+2)  
50f3 32 70 fe			ld (debug_mark+2),a  
50f6 18 03			jr .pastdmark  
50f8 ..			.dmark: db "LBL"  
50fb f1			.pastdmark: pop af  
50fc			endm  
# End of macro DMARK
50fc						CALLMONITOR 
50fc cd f3 18			call break_point_state  
50ff				endm  
# End of macro CALLMONITOR
50ff					endif 
50ff			;	if DEBUG_STORESE 
50ff			;		DMARK "LBL" 
50ff			;		CALLMONITOR 
50ff			;	endif 
50ff					FORTH_DSP_VALUEHL 
50ff cd 5e 21			call macro_dsp_valuehl 
5102				endm 
# End of macro FORTH_DSP_VALUEHL
5102					;v5FORTH_DSP_VALUE 
5102					 
5102			;		push hl 
5102					FORTH_DSP_POP 
5102 cd 16 22			call macro_forth_dsp_pop 
5105				endm 
# End of macro FORTH_DSP_POP
5105			;		pop hl 
5105			 
5105			;v5		inc hl   ; move past the type marker 
5105			 
5105				if DEBUG_STORESE 
5105					DMARK "LBl" 
5105 f5				push af  
5106 3a 1a 51			ld a, (.dmark)  
5109 32 6e fe			ld (debug_mark),a  
510c 3a 1b 51			ld a, (.dmark+1)  
510f 32 6f fe			ld (debug_mark+1),a  
5112 3a 1c 51			ld a, (.dmark+2)  
5115 32 70 fe			ld (debug_mark+2),a  
5118 18 03			jr .pastdmark  
511a ..			.dmark: db "LBl"  
511d f1			.pastdmark: pop af  
511e			endm  
# End of macro DMARK
511e					CALLMONITOR 
511e cd f3 18			call break_point_state  
5121				endm  
# End of macro CALLMONITOR
5121				endif 
5121 cd f1 05				call storage_label 
5124			 
5124				       NEXTW 
5124 c3 d5 22			jp macro_next 
5127				endm 
# End of macro NEXTW
5127			.STOREPAGE: 
5127				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5127 6d				db WORD_SYS_CORE+89             
5128 5a 51			dw .LABELS            
512a 0a				db 9 + 1 
512b .. 00			db "STOREPAGE",0              
5135				endm 
# End of macro CWHEAD
5135			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5135					; TODO test to see if bank is selected 
5135				 
5135					if DEBUG_FORTH_WORDS_KEY 
5135						DMARK "STP" 
5135 f5				push af  
5136 3a 4a 51			ld a, (.dmark)  
5139 32 6e fe			ld (debug_mark),a  
513c 3a 4b 51			ld a, (.dmark+1)  
513f 32 6f fe			ld (debug_mark+1),a  
5142 3a 4c 51			ld a, (.dmark+2)  
5145 32 70 fe			ld (debug_mark+2),a  
5148 18 03			jr .pastdmark  
514a ..			.dmark: db "STP"  
514d f1			.pastdmark: pop af  
514e			endm  
# End of macro DMARK
514e						CALLMONITOR 
514e cd f3 18			call break_point_state  
5151				endm  
# End of macro CALLMONITOR
5151					endif 
5151			;	if DEBUG_STORESE 
5151			;		DMARK "STP" 
5151			;		CALLMONITOR 
5151			;	endif 
5151			 
5151 21 81 fa			ld hl, store_page 
5154 cd 67 1f			call forth_push_numhl 
5157			 
5157			 
5157				       NEXTW 
5157 c3 d5 22			jp macro_next 
515a				endm 
# End of macro NEXTW
515a			.LABELS: 
515a				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
515a 6d				db WORD_SYS_CORE+89             
515b e4 51			dw .SCONST1            
515d 07				db 6 + 1 
515e .. 00			db "LABELS",0              
5165				endm 
# End of macro CWHEAD
5165			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5165					;  
5165			 
5165					; save the current device selected to restore afterwards 
5165				 
5165 3a 67 fa				ld a, (spi_device) 
5168 f5					push af 
5169			 
5169			 
5169					; run through each of the banks 
5169			 
5169 21 01 00				ld hl, 1 
516c cd 67 1f				call forth_push_numhl 
516f 3e ff				ld a, SPI_CE_HIGH 
5171 cb 87				res SPI_CE0, a 
5173 32 67 fa				ld (spi_device), a 
5176 cd cd 04				call storage_get_block_0 
5179 21 84 fa				ld hl, store_page+3 
517c cd d5 1f				call forth_push_str 
517f			 
517f					 
517f 21 02 00				ld hl, 2 
5182 cd 67 1f				call forth_push_numhl 
5185 3e ff				ld a, SPI_CE_HIGH 
5187 cb 8f				res SPI_CE1, a 
5189 32 67 fa				ld (spi_device), a 
518c cd cd 04				call storage_get_block_0 
518f 21 84 fa				ld hl, store_page+3 
5192 cd d5 1f				call forth_push_str 
5195			 
5195					 
5195 21 03 00				ld hl, 3 
5198 cd 67 1f				call forth_push_numhl 
519b 3e ff				ld a, SPI_CE_HIGH 
519d cb 97				res SPI_CE2, a 
519f 32 67 fa				ld (spi_device), a 
51a2 cd cd 04				call storage_get_block_0 
51a5 21 84 fa				ld hl, store_page+3 
51a8 cd d5 1f				call forth_push_str 
51ab			 
51ab			 
51ab 21 04 00				ld hl, 4 
51ae cd 67 1f				call forth_push_numhl 
51b1 3e ff				ld a, SPI_CE_HIGH 
51b3 cb 9f				res SPI_CE3, a 
51b5 32 67 fa				ld (spi_device), a 
51b8 cd cd 04				call storage_get_block_0 
51bb 21 84 fa				ld hl, store_page+3 
51be cd d5 1f				call forth_push_str 
51c1			 
51c1					 
51c1			 
51c1 21 05 00				ld hl, 5 
51c4 cd 67 1f				call forth_push_numhl 
51c7 3e ff				ld a, SPI_CE_HIGH 
51c9 cb a7				res SPI_CE4, a 
51cb 32 67 fa				ld (spi_device), a 
51ce cd cd 04				call storage_get_block_0 
51d1 21 84 fa				ld hl, store_page+3 
51d4 cd d5 1f				call forth_push_str 
51d7			 
51d7					 
51d7					; push fixed count of storage devices (on board) for now 
51d7			 
51d7 21 05 00				ld hl, 5 
51da cd 67 1f				call forth_push_numhl 
51dd			 
51dd					; restore selected device  
51dd				 
51dd f1					pop af 
51de 32 67 fa				ld (spi_device), a 
51e1			 
51e1				       NEXTW 
51e1 c3 d5 22			jp macro_next 
51e4				endm 
# End of macro NEXTW
51e4			 
51e4			.SCONST1: 
51e4				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
51e4 6d				db WORD_SYS_CORE+89             
51e5 fb 51			dw .SCONST2            
51e7 07				db 6 + 1 
51e8 .. 00			db "FILEID",0              
51ef				endm 
# End of macro CWHEAD
51ef			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
51ef 3a 6e fa				ld a, (store_filecache) 
51f2 26 00				ld h, 0 
51f4 6f					ld l, a 
51f5 cd 67 1f				call forth_push_numhl 
51f8					NEXTW 
51f8 c3 d5 22			jp macro_next 
51fb				endm 
# End of macro NEXTW
51fb			.SCONST2: 
51fb				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
51fb 6d				db WORD_SYS_CORE+89             
51fc 13 52			dw .SCONST3            
51fe 08				db 7 + 1 
51ff .. 00			db "FILEEXT",0              
5207				endm 
# End of macro CWHEAD
5207			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5207 3a 71 fa				ld a, (store_openext) 
520a 26 00				ld h, 0 
520c 6f					ld l, a 
520d cd 67 1f				call forth_push_numhl 
5210					NEXTW 
5210 c3 d5 22			jp macro_next 
5213				endm 
# End of macro NEXTW
5213			.SCONST3: 
5213				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5213 6d				db WORD_SYS_CORE+89             
5214 2b 52			dw .SCONST4            
5216 08				db 7 + 1 
5217 .. 00			db "FILEMAX",0              
521f				endm 
# End of macro CWHEAD
521f			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
521f 3a 70 fa				ld a, (store_openmaxext) 
5222 26 00				ld h, 0 
5224 6f					ld l, a 
5225 cd 67 1f				call forth_push_numhl 
5228					NEXTW 
5228 c3 d5 22			jp macro_next 
522b				endm 
# End of macro NEXTW
522b			.SCONST4: 
522b				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
522b 6d				db WORD_SYS_CORE+89             
522c 41 52			dw .SCONST5            
522e 09				db 8 + 1 
522f .. 00			db "FILEADDR",0              
5238				endm 
# End of macro CWHEAD
5238			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5238 2a 72 fa				ld hl, (store_openaddr) 
523b cd 67 1f				call forth_push_numhl 
523e					NEXTW 
523e c3 d5 22			jp macro_next 
5241				endm 
# End of macro NEXTW
5241			.SCONST5: 
5241				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5241 6d				db WORD_SYS_CORE+89             
5242 5a 52			dw .ENDSTORAGE            
5244 09				db 8 + 1 
5245 .. 00			db "READCONT",0              
524e				endm 
# End of macro CWHEAD
524e			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
524e			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
524e			; | | a further read should, if applicable, be CONCAT to the previous read. 
524e 3a 74 fa				ld a, (store_readcont) 
5251 26 00				ld h, 0 
5253 6f					ld l, a 
5254 cd 67 1f				call forth_push_numhl 
5257					NEXTW 
5257 c3 d5 22			jp macro_next 
525a				endm 
# End of macro NEXTW
525a			.ENDSTORAGE: 
525a			; eof 
# End of file forth_words_storage.asm
525a			endif 
525a				include "forth_words_device.asm" 
525a			; Device related words 
525a			 
525a			; | ## Device Words 
525a			 
525a			if SOUND_ENABLE 
525a			.NOTE: 
525a				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
525a 33				db WORD_SYS_CORE+31             
525b 82 52			dw .AFTERSOUND            
525d 05				db 4 + 1 
525e .. 00			db "NOTE",0              
5263				endm 
# End of macro CWHEAD
5263			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5263					if DEBUG_FORTH_WORDS_KEY 
5263						DMARK "NTE" 
5263 f5				push af  
5264 3a 78 52			ld a, (.dmark)  
5267 32 6e fe			ld (debug_mark),a  
526a 3a 79 52			ld a, (.dmark+1)  
526d 32 6f fe			ld (debug_mark+1),a  
5270 3a 7a 52			ld a, (.dmark+2)  
5273 32 70 fe			ld (debug_mark+2),a  
5276 18 03			jr .pastdmark  
5278 ..			.dmark: db "NTE"  
527b f1			.pastdmark: pop af  
527c			endm  
# End of macro DMARK
527c						CALLMONITOR 
527c cd f3 18			call break_point_state  
527f				endm  
# End of macro CALLMONITOR
527f					endif 
527f			 
527f				 
527f			 
527f					NEXTW 
527f c3 d5 22			jp macro_next 
5282				endm 
# End of macro NEXTW
5282			.AFTERSOUND: 
5282			endif 
5282			 
5282			 
5282			USE_GPIO: equ 0 
5282			 
5282			if USE_GPIO 
5282			.GP1: 
5282				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5282			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
5282					NEXTW 
5282			.GP2: 
5282				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5282			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
5282			 
5282					NEXTW 
5282			 
5282			.GP3: 
5282				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5282			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
5282			 
5282					NEXTW 
5282			 
5282			.GP4: 
5282				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5282			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
5282			 
5282					NEXTW 
5282			.SIN: 
5282			 
5282			 
5282			endif 
5282			 
5282			 
5282				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5282 33				db WORD_SYS_CORE+31             
5283 b7 52			dw .SOUT            
5285 03				db 2 + 1 
5286 .. 00			db "IN",0              
5289				endm 
# End of macro CWHEAD
5289			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5289					if DEBUG_FORTH_WORDS_KEY 
5289						DMARK "IN." 
5289 f5				push af  
528a 3a 9e 52			ld a, (.dmark)  
528d 32 6e fe			ld (debug_mark),a  
5290 3a 9f 52			ld a, (.dmark+1)  
5293 32 6f fe			ld (debug_mark+1),a  
5296 3a a0 52			ld a, (.dmark+2)  
5299 32 70 fe			ld (debug_mark+2),a  
529c 18 03			jr .pastdmark  
529e ..			.dmark: db "IN."  
52a1 f1			.pastdmark: pop af  
52a2			endm  
# End of macro DMARK
52a2						CALLMONITOR 
52a2 cd f3 18			call break_point_state  
52a5				endm  
# End of macro CALLMONITOR
52a5					endif 
52a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52a5 cd 5e 21			call macro_dsp_valuehl 
52a8				endm 
# End of macro FORTH_DSP_VALUEHL
52a8			 
52a8 e5					push hl 
52a9			 
52a9					; destroy value TOS 
52a9			 
52a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52a9 cd 16 22			call macro_forth_dsp_pop 
52ac				endm 
# End of macro FORTH_DSP_POP
52ac			 
52ac					; one value on hl get other one back 
52ac			 
52ac c1					pop bc 
52ad			 
52ad					; do the sub 
52ad			;		ex de, hl 
52ad			 
52ad ed 68				in l,(c) 
52af			 
52af					; save it 
52af			 
52af 26 00				ld h,0 
52b1			 
52b1					; TODO push value back onto stack for another op etc 
52b1			 
52b1 cd 67 1f				call forth_push_numhl 
52b4					NEXTW 
52b4 c3 d5 22			jp macro_next 
52b7				endm 
# End of macro NEXTW
52b7			.SOUT: 
52b7				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
52b7 34				db WORD_SYS_CORE+32             
52b8 0a 53			dw .SPIO            
52ba 04				db 3 + 1 
52bb .. 00			db "OUT",0              
52bf				endm 
# End of macro CWHEAD
52bf			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
52bf					if DEBUG_FORTH_WORDS_KEY 
52bf						DMARK "OUT" 
52bf f5				push af  
52c0 3a d4 52			ld a, (.dmark)  
52c3 32 6e fe			ld (debug_mark),a  
52c6 3a d5 52			ld a, (.dmark+1)  
52c9 32 6f fe			ld (debug_mark+1),a  
52cc 3a d6 52			ld a, (.dmark+2)  
52cf 32 70 fe			ld (debug_mark+2),a  
52d2 18 03			jr .pastdmark  
52d4 ..			.dmark: db "OUT"  
52d7 f1			.pastdmark: pop af  
52d8			endm  
# End of macro DMARK
52d8						CALLMONITOR 
52d8 cd f3 18			call break_point_state  
52db				endm  
# End of macro CALLMONITOR
52db					endif 
52db			 
52db					; get port 
52db			 
52db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52db cd 5e 21			call macro_dsp_valuehl 
52de				endm 
# End of macro FORTH_DSP_VALUEHL
52de			 
52de e5					push hl 
52df			 
52df					; destroy value TOS 
52df			 
52df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52df cd 16 22			call macro_forth_dsp_pop 
52e2				endm 
# End of macro FORTH_DSP_POP
52e2			 
52e2					; get byte to send 
52e2			 
52e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52e2 cd 5e 21			call macro_dsp_valuehl 
52e5				endm 
# End of macro FORTH_DSP_VALUEHL
52e5			 
52e5			;		push hl 
52e5			 
52e5					; destroy value TOS 
52e5			 
52e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52e5 cd 16 22			call macro_forth_dsp_pop 
52e8				endm 
# End of macro FORTH_DSP_POP
52e8			 
52e8					; one value on hl get other one back 
52e8			 
52e8			;		pop hl 
52e8			 
52e8 c1					pop bc 
52e9			 
52e9					if DEBUG_FORTH_WORDS 
52e9						DMARK "OUT" 
52e9 f5				push af  
52ea 3a fe 52			ld a, (.dmark)  
52ed 32 6e fe			ld (debug_mark),a  
52f0 3a ff 52			ld a, (.dmark+1)  
52f3 32 6f fe			ld (debug_mark+1),a  
52f6 3a 00 53			ld a, (.dmark+2)  
52f9 32 70 fe			ld (debug_mark+2),a  
52fc 18 03			jr .pastdmark  
52fe ..			.dmark: db "OUT"  
5301 f1			.pastdmark: pop af  
5302			endm  
# End of macro DMARK
5302						CALLMONITOR 
5302 cd f3 18			call break_point_state  
5305				endm  
# End of macro CALLMONITOR
5305					endif 
5305			 
5305 ed 69				out (c), l 
5307			 
5307					NEXTW 
5307 c3 d5 22			jp macro_next 
530a				endm 
# End of macro NEXTW
530a			 
530a			 
530a			.SPIO: 
530a			 
530a			if STORAGE_SE 
530a				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
530a 51				db WORD_SYS_CORE+61             
530b 1b 53			dw .SPICEH            
530d 07				db 6 + 1 
530e .. 00			db "SPICEL",0              
5315				endm 
# End of macro CWHEAD
5315			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5315			 
5315 cd ca 01				call spi_ce_low 
5318			    NEXTW 
5318 c3 d5 22			jp macro_next 
531b				endm 
# End of macro NEXTW
531b			 
531b			.SPICEH: 
531b				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
531b 51				db WORD_SYS_CORE+61             
531c 2c 53			dw .SPIOb            
531e 07				db 6 + 1 
531f .. 00			db "SPICEH",0              
5326				endm 
# End of macro CWHEAD
5326			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5326			 
5326 cd b9 01				call spi_ce_high 
5329			    NEXTW 
5329 c3 d5 22			jp macro_next 
532c				endm 
# End of macro NEXTW
532c			 
532c			 
532c			.SPIOb: 
532c			 
532c				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
532c 51				db WORD_SYS_CORE+61             
532d 5e 53			dw .SPII            
532f 05				db 4 + 1 
5330 .. 00			db "SPIO",0              
5335				endm 
# End of macro CWHEAD
5335			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5335			 
5335					if DEBUG_FORTH_WORDS_KEY 
5335						DMARK "SPo" 
5335 f5				push af  
5336 3a 4a 53			ld a, (.dmark)  
5339 32 6e fe			ld (debug_mark),a  
533c 3a 4b 53			ld a, (.dmark+1)  
533f 32 6f fe			ld (debug_mark+1),a  
5342 3a 4c 53			ld a, (.dmark+2)  
5345 32 70 fe			ld (debug_mark+2),a  
5348 18 03			jr .pastdmark  
534a ..			.dmark: db "SPo"  
534d f1			.pastdmark: pop af  
534e			endm  
# End of macro DMARK
534e						CALLMONITOR 
534e cd f3 18			call break_point_state  
5351				endm  
# End of macro CALLMONITOR
5351					endif 
5351					; get port 
5351			 
5351			 
5351					; get byte to send 
5351			 
5351					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5351 cd 5e 21			call macro_dsp_valuehl 
5354				endm 
# End of macro FORTH_DSP_VALUEHL
5354			 
5354			;		push hl    ; u1  
5354			 
5354					; destroy value TOS 
5354			 
5354					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5354 cd 16 22			call macro_forth_dsp_pop 
5357				endm 
# End of macro FORTH_DSP_POP
5357			 
5357					; one value on hl get other one back 
5357			 
5357			;		pop hl   ; u2 - addr 
5357			 
5357					; TODO Send SPI byte 
5357			 
5357			;		push hl 
5357			;		call spi_ce_low 
5357			;		pop hl 
5357 7d					ld a, l 
5358 cd b8 00				call spi_send_byte 
535b			;		call spi_ce_high 
535b			 
535b					NEXTW 
535b c3 d5 22			jp macro_next 
535e				endm 
# End of macro NEXTW
535e			 
535e			.SPII: 
535e				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
535e 52				db WORD_SYS_CORE+62             
535f c7 53			dw .SESEL            
5361 06				db 5 + 1 
5362 .. 00			db "SPII",0              
5367				endm 
# End of macro CWHEAD
5367			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5367					if DEBUG_FORTH_WORDS_KEY 
5367						DMARK "SPi" 
5367 f5				push af  
5368 3a 7c 53			ld a, (.dmark)  
536b 32 6e fe			ld (debug_mark),a  
536e 3a 7d 53			ld a, (.dmark+1)  
5371 32 6f fe			ld (debug_mark+1),a  
5374 3a 7e 53			ld a, (.dmark+2)  
5377 32 70 fe			ld (debug_mark+2),a  
537a 18 03			jr .pastdmark  
537c ..			.dmark: db "SPi"  
537f f1			.pastdmark: pop af  
5380			endm  
# End of macro DMARK
5380						CALLMONITOR 
5380 cd f3 18			call break_point_state  
5383				endm  
# End of macro CALLMONITOR
5383					endif 
5383			 
5383					; TODO Get SPI byte 
5383			 
5383 cd df 00				call spi_read_byte 
5386			 
5386					if DEBUG_FORTH_WORDS 
5386						DMARK "Si2" 
5386 f5				push af  
5387 3a 9b 53			ld a, (.dmark)  
538a 32 6e fe			ld (debug_mark),a  
538d 3a 9c 53			ld a, (.dmark+1)  
5390 32 6f fe			ld (debug_mark+1),a  
5393 3a 9d 53			ld a, (.dmark+2)  
5396 32 70 fe			ld (debug_mark+2),a  
5399 18 03			jr .pastdmark  
539b ..			.dmark: db "Si2"  
539e f1			.pastdmark: pop af  
539f			endm  
# End of macro DMARK
539f						CALLMONITOR 
539f cd f3 18			call break_point_state  
53a2				endm  
# End of macro CALLMONITOR
53a2					endif 
53a2 26 00				ld h, 0 
53a4 6f					ld l, a 
53a5					if DEBUG_FORTH_WORDS 
53a5						DMARK "Si3" 
53a5 f5				push af  
53a6 3a ba 53			ld a, (.dmark)  
53a9 32 6e fe			ld (debug_mark),a  
53ac 3a bb 53			ld a, (.dmark+1)  
53af 32 6f fe			ld (debug_mark+1),a  
53b2 3a bc 53			ld a, (.dmark+2)  
53b5 32 70 fe			ld (debug_mark+2),a  
53b8 18 03			jr .pastdmark  
53ba ..			.dmark: db "Si3"  
53bd f1			.pastdmark: pop af  
53be			endm  
# End of macro DMARK
53be						CALLMONITOR 
53be cd f3 18			call break_point_state  
53c1				endm  
# End of macro CALLMONITOR
53c1					endif 
53c1 cd 67 1f				call forth_push_numhl 
53c4			 
53c4					NEXTW 
53c4 c3 d5 22			jp macro_next 
53c7				endm 
# End of macro NEXTW
53c7			 
53c7			 
53c7			 
53c7			.SESEL: 
53c7				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
53c7 66				db WORD_SYS_CORE+82             
53c8 70 54			dw .CARTDEV            
53ca 05				db 4 + 1 
53cb .. 00			db "BANK",0              
53d0				endm 
# End of macro CWHEAD
53d0			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
53d0					if DEBUG_FORTH_WORDS_KEY 
53d0						DMARK "BNK" 
53d0 f5				push af  
53d1 3a e5 53			ld a, (.dmark)  
53d4 32 6e fe			ld (debug_mark),a  
53d7 3a e6 53			ld a, (.dmark+1)  
53da 32 6f fe			ld (debug_mark+1),a  
53dd 3a e7 53			ld a, (.dmark+2)  
53e0 32 70 fe			ld (debug_mark+2),a  
53e3 18 03			jr .pastdmark  
53e5 ..			.dmark: db "BNK"  
53e8 f1			.pastdmark: pop af  
53e9			endm  
# End of macro DMARK
53e9						CALLMONITOR 
53e9 cd f3 18			call break_point_state  
53ec				endm  
# End of macro CALLMONITOR
53ec					endif 
53ec			 
53ec 3e ff				ld a, 255 
53ee 32 6a fa				ld (spi_cartdev), a 
53f1			 
53f1					; get bank 
53f1			 
53f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53f1 cd 5e 21			call macro_dsp_valuehl 
53f4				endm 
# End of macro FORTH_DSP_VALUEHL
53f4			 
53f4			;		push hl 
53f4			 
53f4					; destroy value TOS 
53f4			 
53f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53f4 cd 16 22			call macro_forth_dsp_pop 
53f7				endm 
# End of macro FORTH_DSP_POP
53f7			 
53f7					; one value on hl get other one back 
53f7			 
53f7			;		pop hl 
53f7			 
53f7			 
53f7 0e ff				ld c, SPI_CE_HIGH 
53f9 06 30				ld b, '0'    ; human readable bank number 
53fb			 
53fb 7d					ld a, l 
53fc			 
53fc					if DEBUG_FORTH_WORDS 
53fc						DMARK "BNK" 
53fc f5				push af  
53fd 3a 11 54			ld a, (.dmark)  
5400 32 6e fe			ld (debug_mark),a  
5403 3a 12 54			ld a, (.dmark+1)  
5406 32 6f fe			ld (debug_mark+1),a  
5409 3a 13 54			ld a, (.dmark+2)  
540c 32 70 fe			ld (debug_mark+2),a  
540f 18 03			jr .pastdmark  
5411 ..			.dmark: db "BNK"  
5414 f1			.pastdmark: pop af  
5415			endm  
# End of macro DMARK
5415						CALLMONITOR 
5415 cd f3 18			call break_point_state  
5418				endm  
# End of macro CALLMONITOR
5418					endif 
5418			 
5418					; active low 
5418			 
5418 fe 00				cp 0 
541a 28 28				jr z, .bset 
541c fe 01				cp 1 
541e 20 04				jr nz, .b2 
5420 cb 81				res 0, c 
5422 06 31				ld b, '1'    ; human readable bank number 
5424 fe 02		.b2:		cp 2 
5426 20 04				jr nz, .b3 
5428 cb 89				res 1, c 
542a 06 32				ld b, '2'    ; human readable bank number 
542c fe 03		.b3:		cp 3 
542e 20 04				jr nz, .b4 
5430 cb 91				res 2, c 
5432 06 33				ld b, '3'    ; human readable bank number 
5434 fe 04		.b4:		cp 4 
5436 20 04				jr nz, .b5 
5438 cb 99				res 3, c 
543a 06 34				ld b, '4'    ; human readable bank number 
543c fe 05		.b5:		cp 5 
543e 20 04				jr nz, .bset 
5440 cb a1				res 4, c 
5442 06 35				ld b, '5'    ; human readable bank number 
5444			 
5444			.bset: 
5444 79					ld a, c 
5445 32 67 fa				ld (spi_device),a 
5448 78					ld a, b 
5449 32 66 fa				ld (spi_device_id),a 
544c					if DEBUG_FORTH_WORDS 
544c						DMARK "BN2" 
544c f5				push af  
544d 3a 61 54			ld a, (.dmark)  
5450 32 6e fe			ld (debug_mark),a  
5453 3a 62 54			ld a, (.dmark+1)  
5456 32 6f fe			ld (debug_mark+1),a  
5459 3a 63 54			ld a, (.dmark+2)  
545c 32 70 fe			ld (debug_mark+2),a  
545f 18 03			jr .pastdmark  
5461 ..			.dmark: db "BN2"  
5464 f1			.pastdmark: pop af  
5465			endm  
# End of macro DMARK
5465						CALLMONITOR 
5465 cd f3 18			call break_point_state  
5468				endm  
# End of macro CALLMONITOR
5468					endif 
5468			 
5468					; set default SPI clk pulse time as disabled for BANK use 
5468			 
5468 3e 00				ld a, 0 
546a 32 6b fa				ld (spi_clktime), a 
546d			 
546d					NEXTW 
546d c3 d5 22			jp macro_next 
5470				endm 
# End of macro NEXTW
5470			 
5470			.CARTDEV: 
5470				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5470 66				db WORD_SYS_CORE+82             
5471 1e 55			dw .ENDDEVICE            
5473 08				db 7 + 1 
5474 .. 00			db "CARTDEV",0              
547c				endm 
# End of macro CWHEAD
547c			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
547c					if DEBUG_FORTH_WORDS_KEY 
547c						DMARK "CDV" 
547c f5				push af  
547d 3a 91 54			ld a, (.dmark)  
5480 32 6e fe			ld (debug_mark),a  
5483 3a 92 54			ld a, (.dmark+1)  
5486 32 6f fe			ld (debug_mark+1),a  
5489 3a 93 54			ld a, (.dmark+2)  
548c 32 70 fe			ld (debug_mark+2),a  
548f 18 03			jr .pastdmark  
5491 ..			.dmark: db "CDV"  
5494 f1			.pastdmark: pop af  
5495			endm  
# End of macro DMARK
5495						CALLMONITOR 
5495 cd f3 18			call break_point_state  
5498				endm  
# End of macro CALLMONITOR
5498					endif 
5498			 
5498					; disable se storage bank selection 
5498			 
5498 3e ff				ld a, SPI_CE_HIGH		; ce high 
549a 32 67 fa				ld (spi_device), a 
549d			 
549d					; get bank 
549d			 
549d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
549d cd 5e 21			call macro_dsp_valuehl 
54a0				endm 
# End of macro FORTH_DSP_VALUEHL
54a0			 
54a0			;		push hl 
54a0			 
54a0					; destroy value TOS 
54a0			 
54a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54a0 cd 16 22			call macro_forth_dsp_pop 
54a3				endm 
# End of macro FORTH_DSP_POP
54a3			 
54a3					; one value on hl get other one back 
54a3			 
54a3			;		pop hl 
54a3			 
54a3					; active low 
54a3			 
54a3 0e ff				ld c, 255 
54a5			 
54a5 7d					ld a, l 
54a6					if DEBUG_FORTH_WORDS 
54a6						DMARK "CDV" 
54a6 f5				push af  
54a7 3a bb 54			ld a, (.dmark)  
54aa 32 6e fe			ld (debug_mark),a  
54ad 3a bc 54			ld a, (.dmark+1)  
54b0 32 6f fe			ld (debug_mark+1),a  
54b3 3a bd 54			ld a, (.dmark+2)  
54b6 32 70 fe			ld (debug_mark+2),a  
54b9 18 03			jr .pastdmark  
54bb ..			.dmark: db "CDV"  
54be f1			.pastdmark: pop af  
54bf			endm  
# End of macro DMARK
54bf						CALLMONITOR 
54bf cd f3 18			call break_point_state  
54c2				endm  
# End of macro CALLMONITOR
54c2					endif 
54c2 fe 00				cp 0 
54c4 28 30				jr z, .cset 
54c6 fe 01				cp 1 
54c8 20 02				jr nz, .c2 
54ca cb 81				res 0, c 
54cc fe 02		.c2:		cp 2 
54ce 20 02				jr nz, .c3 
54d0 cb 89				res 1, c 
54d2 fe 03		.c3:		cp 3 
54d4 20 02				jr nz, .c4 
54d6 cb 91				res 2, c 
54d8 fe 04		.c4:		cp 4 
54da 20 02				jr nz, .c5 
54dc cb 99				res 3, c 
54de fe 05		.c5:		cp 5 
54e0 20 02				jr nz, .c6 
54e2 cb a1				res 4, c 
54e4 fe 06		.c6:		cp 6 
54e6 20 02				jr nz, .c7 
54e8 cb a9				res 5, c 
54ea fe 07		.c7:		cp 7 
54ec 20 02				jr nz, .c8 
54ee cb b1				res 6, c 
54f0 fe 08		.c8:		cp 8 
54f2 20 02				jr nz, .cset 
54f4 cb b9				res 7, c 
54f6 79			.cset:		ld a, c 
54f7 32 6a fa				ld (spi_cartdev),a 
54fa			 
54fa					if DEBUG_FORTH_WORDS 
54fa						DMARK "CD2" 
54fa f5				push af  
54fb 3a 0f 55			ld a, (.dmark)  
54fe 32 6e fe			ld (debug_mark),a  
5501 3a 10 55			ld a, (.dmark+1)  
5504 32 6f fe			ld (debug_mark+1),a  
5507 3a 11 55			ld a, (.dmark+2)  
550a 32 70 fe			ld (debug_mark+2),a  
550d 18 03			jr .pastdmark  
550f ..			.dmark: db "CD2"  
5512 f1			.pastdmark: pop af  
5513			endm  
# End of macro DMARK
5513						CALLMONITOR 
5513 cd f3 18			call break_point_state  
5516				endm  
# End of macro CALLMONITOR
5516					endif 
5516			 
5516					; set default SPI clk pulse time as 10ms for CARTDEV use 
5516			 
5516 3e 0a				ld a, $0a 
5518 32 6b fa				ld (spi_clktime), a 
551b					NEXTW 
551b c3 d5 22			jp macro_next 
551e				endm 
# End of macro NEXTW
551e			endif 
551e			 
551e			.ENDDEVICE: 
551e			; eof 
551e			 
# End of file forth_words_device.asm
551e			 
551e			; var handler 
551e			 
551e			 
551e			.VARS: 
551e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
551e 78				db WORD_SYS_CORE+100             
551f 36 55			dw .V0Q            
5521 04				db 3 + 1 
5522 .. 00			db "V0!",0              
5526				endm 
# End of macro CWHEAD
5526			;| V0! ( u1 -- )  Store value to v0  | DONE 
5526			 
5526					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5526 cd 5e 21			call macro_dsp_valuehl 
5529				endm 
# End of macro FORTH_DSP_VALUEHL
5529			 
5529 11 2f fa				ld de, cli_var_array 
552c			 
552c eb					ex de, hl 
552d 73					ld (hl), e 
552e 23					inc hl 
552f 72					ld (hl), d 
5530			 
5530					; destroy value TOS 
5530			 
5530					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5530 cd 16 22			call macro_forth_dsp_pop 
5533				endm 
# End of macro FORTH_DSP_POP
5533			 
5533				       NEXTW 
5533 c3 d5 22			jp macro_next 
5536				endm 
# End of macro NEXTW
5536			.V0Q: 
5536				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5536 79				db WORD_SYS_CORE+101             
5537 47 55			dw .V1S            
5539 04				db 3 + 1 
553a .. 00			db "V0@",0              
553e				endm 
# End of macro CWHEAD
553e			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
553e 2a 2f fa				ld hl, (cli_var_array) 
5541 cd 67 1f				call forth_push_numhl 
5544			 
5544				       NEXTW 
5544 c3 d5 22			jp macro_next 
5547				endm 
# End of macro NEXTW
5547			.V1S: 
5547				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5547 7a				db WORD_SYS_CORE+102             
5548 5f 55			dw .V1Q            
554a 04				db 3 + 1 
554b .. 00			db "V1!",0              
554f				endm 
# End of macro CWHEAD
554f			;| V1! ( u1 -- )  Store value to v1 | DONE 
554f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
554f cd 5e 21			call macro_dsp_valuehl 
5552				endm 
# End of macro FORTH_DSP_VALUEHL
5552			 
5552 11 31 fa				ld de, cli_var_array+2 
5555				 
5555 eb					ex de, hl 
5556 73					ld (hl), e 
5557 23					inc hl 
5558 72					ld (hl), d 
5559			 
5559					; destroy value TOS 
5559			 
5559					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5559 cd 16 22			call macro_forth_dsp_pop 
555c				endm 
# End of macro FORTH_DSP_POP
555c				       NEXTW 
555c c3 d5 22			jp macro_next 
555f				endm 
# End of macro NEXTW
555f			.V1Q: 
555f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
555f 7b				db WORD_SYS_CORE+103             
5560 70 55			dw .V2S            
5562 04				db 3 + 1 
5563 .. 00			db "V1@",0              
5567				endm 
# End of macro CWHEAD
5567			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5567 2a 31 fa				ld hl, (cli_var_array+2) 
556a cd 67 1f				call forth_push_numhl 
556d				       NEXTW 
556d c3 d5 22			jp macro_next 
5570				endm 
# End of macro NEXTW
5570			.V2S: 
5570				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5570 7c				db WORD_SYS_CORE+104             
5571 88 55			dw .V2Q            
5573 04				db 3 + 1 
5574 .. 00			db "V2!",0              
5578				endm 
# End of macro CWHEAD
5578			;| V2! ( u1 -- )  Store value to v2 | DONE 
5578					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5578 cd 5e 21			call macro_dsp_valuehl 
557b				endm 
# End of macro FORTH_DSP_VALUEHL
557b			 
557b 11 33 fa				ld de, cli_var_array+4 
557e				 
557e eb					ex de, hl 
557f 73					ld (hl), e 
5580 23					inc hl 
5581 72					ld (hl), d 
5582			 
5582					; destroy value TOS 
5582			 
5582					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5582 cd 16 22			call macro_forth_dsp_pop 
5585				endm 
# End of macro FORTH_DSP_POP
5585				       NEXTW 
5585 c3 d5 22			jp macro_next 
5588				endm 
# End of macro NEXTW
5588			.V2Q: 
5588				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5588 7d				db WORD_SYS_CORE+105             
5589 99 55			dw .V3S            
558b 04				db 3 + 1 
558c .. 00			db "V2@",0              
5590				endm 
# End of macro CWHEAD
5590			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5590 2a 33 fa				ld hl, (cli_var_array+4) 
5593 cd 67 1f				call forth_push_numhl 
5596				       NEXTW 
5596 c3 d5 22			jp macro_next 
5599				endm 
# End of macro NEXTW
5599			.V3S: 
5599				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5599 7c				db WORD_SYS_CORE+104             
559a b1 55			dw .V3Q            
559c 04				db 3 + 1 
559d .. 00			db "V3!",0              
55a1				endm 
# End of macro CWHEAD
55a1			;| V3! ( u1 -- )  Store value to v3 | DONE 
55a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
55a1 cd 5e 21			call macro_dsp_valuehl 
55a4				endm 
# End of macro FORTH_DSP_VALUEHL
55a4			 
55a4 11 35 fa				ld de, cli_var_array+6 
55a7				 
55a7 eb					ex de, hl 
55a8 73					ld (hl), e 
55a9 23					inc hl 
55aa 72					ld (hl), d 
55ab			 
55ab					; destroy value TOS 
55ab			 
55ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
55ab cd 16 22			call macro_forth_dsp_pop 
55ae				endm 
# End of macro FORTH_DSP_POP
55ae				       NEXTW 
55ae c3 d5 22			jp macro_next 
55b1				endm 
# End of macro NEXTW
55b1			.V3Q: 
55b1				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
55b1 7d				db WORD_SYS_CORE+105             
55b2 c2 55			dw .END            
55b4 04				db 3 + 1 
55b5 .. 00			db "V3@",0              
55b9				endm 
# End of macro CWHEAD
55b9			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
55b9 2a 35 fa				ld hl, (cli_var_array+6) 
55bc cd 67 1f				call forth_push_numhl 
55bf				       NEXTW 
55bf c3 d5 22			jp macro_next 
55c2				endm 
# End of macro NEXTW
55c2			 
55c2			 
55c2			 
55c2			 
55c2			 
55c2			; end of dict marker 
55c2			 
55c2 00			.END:    db WORD_SYS_END 
55c3 00 00			dw 0 
55c5 00				db 0 
55c6			 
55c6			; use to jp here for user dict words to save on macro expansion  
55c6			 
55c6			user_dict_next: 
55c6				NEXTW 
55c6 c3 d5 22			jp macro_next 
55c9				endm 
# End of macro NEXTW
55c9			 
55c9			 
55c9			user_exec: 
55c9				;    ld hl, <word code> 
55c9				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
55c9				;    call forthexec 
55c9				;    jp user_dict_next   (NEXT) 
55c9			        ;    <word code bytes> 
55c9 eb				ex de, hl 
55ca 2a fd f4			ld hl,(os_tok_ptr) 
55cd				 
55cd				FORTH_RSP_NEXT 
55cd cd 0e 1f			call macro_forth_rsp_next 
55d0				endm 
# End of macro FORTH_RSP_NEXT
55d0			 
55d0			if DEBUG_FORTH_UWORD 
55d0						DMARK "UEX" 
55d0 f5				push af  
55d1 3a e5 55			ld a, (.dmark)  
55d4 32 6e fe			ld (debug_mark),a  
55d7 3a e6 55			ld a, (.dmark+1)  
55da 32 6f fe			ld (debug_mark+1),a  
55dd 3a e7 55			ld a, (.dmark+2)  
55e0 32 70 fe			ld (debug_mark+2),a  
55e3 18 03			jr .pastdmark  
55e5 ..			.dmark: db "UEX"  
55e8 f1			.pastdmark: pop af  
55e9			endm  
# End of macro DMARK
55e9				CALLMONITOR 
55e9 cd f3 18			call break_point_state  
55ec				endm  
# End of macro CALLMONITOR
55ec			endif 
55ec			 
55ec			 
55ec			 
55ec eb				ex de, hl 
55ed 22 fd f4			ld (os_tok_ptr), hl 
55f0				 
55f0				; Don't use next - Skips the first word in uword. 
55f0			 
55f0 c3 66 23			jp exec1 
55f3			;	NEXT 
55f3			 
55f3			 
55f3			; eof 
# End of file forth_wordsv4.asm
55f3			endif 
55f3			;;;;;;;;;;;;;; Debug code 
55f3			 
55f3			 
55f3			;if DEBUG_FORTH_PARSE 
55f3 .. 00		.nowordfound: db "No match",0 
55fc .. 00		.compword:	db "Comparing word ",0 
560c .. 00		.nextwordat:	db "Next word at",0 
5619 .. 00		.charmatch:	db "Char match",0 
5624			;endif 
5624			if DEBUG_FORTH_JP 
5624			.foundword:	db "Word match. Exec..",0 
5624			endif 
5624			;if DEBUG_FORTH_PUSH 
5624 .. 00		.enddict:	db "Dict end. Push.",0 
5634 .. 00		.push_str:	db "Pushing string",0 
5643 .. 00		.push_num:	db "Pushing number",0 
5652 .. 00		.data_sp:	db "SP:",0 
5656 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5668 .. 00		.wordinde:	db "Word in DE (3/0):",0 
567a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
568c			;endif 
568c			;if DEBUG_FORTH_MALLOC 
568c .. 00		.push_malloc:	db "Malloc address",0 
569b			;endif 
569b			 
569b			 
569b			 
569b			; display malloc address and current data stack pointer  
569b			 
569b			malloc_error: 
569b d5				push de 
569c f5				push af 
569d e5				push hl 
569e cd 18 0d			call clear_display 
56a1 11 c3 56			ld de, .mallocerr 
56a4 3e 00			ld a,0 
56a6			;	ld de,os_word_scratch 
56a6 cd 2b 0d			call str_at_display 
56a9 3e 11			ld a, display_row_1+17 
56ab 11 6e fe			ld de, debug_mark 
56ae cd 2b 0d			call str_at_display 
56b1 cd 3b 0d			call update_display 
56b4				;call break_point_state 
56b4 cd fe 70			call cin_wait 
56b7			 
56b7 3e 20			ld a, ' ' 
56b9 32 ed f1			ld (os_view_disable), a 
56bc e1				pop hl 
56bd f1				pop af 
56be d1				pop de	 
56bf				CALLMONITOR 
56bf cd f3 18			call break_point_state  
56c2				endm  
# End of macro CALLMONITOR
56c2 c9				ret 
56c3			 
56c3 .. 00		.mallocerr: 	db "Malloc Error",0 
56d0			;if DEBUG_FORTH_PUSH 
56d0			display_data_sp: 
56d0 f5				push af 
56d1			 
56d1				; see if disabled 
56d1			 
56d1 3a ed f1			ld a, (os_view_disable) 
56d4 fe 2a			cp '*' 
56d6 28 67			jr z, .skipdsp 
56d8			 
56d8 e5				push hl 
56d9 e5				push hl 
56da e5			push hl 
56db cd 18 0d			call clear_display 
56de e1			pop hl 
56df 7c				ld a,h 
56e0 21 01 f5			ld hl, os_word_scratch 
56e3 cd 4d 12			call hexout 
56e6 e1				pop hl 
56e7 7d				ld a,l 
56e8 21 03 f5			ld hl, os_word_scratch+2 
56eb cd 4d 12			call hexout 
56ee 21 05 f5			ld hl, os_word_scratch+4 
56f1 3e 00			ld a,0 
56f3 77				ld (hl),a 
56f4 11 01 f5			ld de,os_word_scratch 
56f7 3e 28				ld a, display_row_2 
56f9 cd 2b 0d				call str_at_display 
56fc 11 56 56			ld de, .wordinhl 
56ff 3e 00			ld a, display_row_1 
5701			 
5701 cd 2b 0d				call str_at_display 
5704 11 6e fe			ld de, debug_mark 
5707 3e 11			ld a, display_row_1+17 
5709			 
5709 cd 2b 0d				call str_at_display 
570c			 
570c				; display current data stack pointer 
570c 11 52 56			ld de,.data_sp 
570f 3e 30				ld a, display_row_2 + 8 
5711 cd 2b 0d				call str_at_display 
5714			 
5714 2a 29 fa			ld hl,(cli_data_sp) 
5717 e5				push hl 
5718 7c				ld a,h 
5719 21 01 f5			ld hl, os_word_scratch 
571c cd 4d 12			call hexout 
571f e1				pop hl 
5720 7d				ld a,l 
5721 21 03 f5			ld hl, os_word_scratch+2 
5724 cd 4d 12			call hexout 
5727 21 05 f5			ld hl, os_word_scratch+4 
572a 3e 00			ld a,0 
572c 77				ld (hl),a 
572d 11 01 f5			ld de,os_word_scratch 
5730 3e 33				ld a, display_row_2 + 11 
5732 cd 2b 0d				call str_at_display 
5735			 
5735			 
5735 cd 3b 0d			call update_display 
5738 cd 95 0c			call delay1s 
573b cd 95 0c			call delay1s 
573e e1				pop hl 
573f			.skipdsp: 
573f f1				pop af 
5740 c9				ret 
5741			 
5741			display_data_malloc: 
5741			 
5741 f5				push af 
5742 e5				push hl 
5743 e5				push hl 
5744 e5			push hl 
5745 cd 18 0d			call clear_display 
5748 e1			pop hl 
5749 7c				ld a,h 
574a 21 01 f5			ld hl, os_word_scratch 
574d cd 4d 12			call hexout 
5750 e1				pop hl 
5751 7d				ld a,l 
5752 21 03 f5			ld hl, os_word_scratch+2 
5755 cd 4d 12			call hexout 
5758 21 05 f5			ld hl, os_word_scratch+4 
575b 3e 00			ld a,0 
575d 77				ld (hl),a 
575e 11 01 f5			ld de,os_word_scratch 
5761 3e 28				ld a, display_row_2 
5763 cd 2b 0d				call str_at_display 
5766 11 8c 56			ld de, .push_malloc 
5769 3e 00			ld a, display_row_1 
576b			 
576b cd 2b 0d				call str_at_display 
576e			 
576e				; display current data stack pointer 
576e 11 52 56			ld de,.data_sp 
5771 3e 30				ld a, display_row_2 + 8 
5773 cd 2b 0d				call str_at_display 
5776			 
5776 2a 29 fa			ld hl,(cli_data_sp) 
5779 e5				push hl 
577a 7c				ld a,h 
577b 21 01 f5			ld hl, os_word_scratch 
577e cd 4d 12			call hexout 
5781 e1				pop hl 
5782 7d				ld a,l 
5783 21 03 f5			ld hl, os_word_scratch+2 
5786 cd 4d 12			call hexout 
5789 21 05 f5			ld hl, os_word_scratch+4 
578c 3e 00			ld a,0 
578e 77				ld (hl),a 
578f 11 01 f5			ld de,os_word_scratch 
5792 3e 33				ld a, display_row_2 + 11 
5794 cd 2b 0d				call str_at_display 
5797			 
5797 cd 3b 0d			call update_display 
579a cd 95 0c			call delay1s 
579d cd 95 0c			call delay1s 
57a0 e1				pop hl 
57a1 f1				pop af 
57a2 c9				ret 
57a3			;endif 
57a3			 
57a3			include "forth_autostart.asm" 
57a3			; list of commands to perform at system start up 
57a3			 
57a3			startcmds: 
57a3			;	dw test11 
57a3			;	dw test12 
57a3			;	dw test13 
57a3			;	dw test14 
57a3			;	dw test15 
57a3			;	dw test16 
57a3			;	dw test17 
57a3			;	dw ifthtest1 
57a3			;	dw ifthtest2 
57a3			;	dw ifthtest3 
57a3			;	dw mmtest1 
57a3			;	dw mmtest2 
57a3			;	dw mmtest3 
57a3			;	dw mmtest4 
57a3			;	dw mmtest5 
57a3			;	dw mmtest6 
57a3			;	dw iftest1 
57a3			;	dw iftest2 
57a3			;	dw iftest3 
57a3			;	dw looptest1 
57a3			;	dw looptest2 
57a3			;	dw test1 
57a3			;	dw test2 
57a3			;	dw test3 
57a3			;	dw test4 
57a3			;	dw game2r 
57a3			;	dw game2b1 
57a3			;	dw game2b2 
57a3			 
57a3				; start up words that are actually useful 
57a3			 
57a3 17 58		    dw spi1 
57a5 6b 58		    dw spi2 
57a7 a1 58		    dw spi3 
57a9 dd 58		    dw spi4 
57ab 08 59		    dw spi5 
57ad 35 59		    dw spi6 
57af 8a 59		    dw spi7 
57b1			 
57b1 e2 59		    dw spi8 
57b3 01 5a		    dw spi9 
57b5 59 5a		    dw spi10 
57b7			 
57b7 cc 5a			dw longread 
57b9 13 5b			dw clrstack 
57bb 46 5b			dw type 
57bd 36 5d			dw stest 
57bf 6a 5b			dw strncpy 
57c1 cc 5c			dw list 
57c3 cb 5b			dw start1 
57c5 dd 5b			dw start2 
57c7			;	dw start3 
57c7 f0 5b			dw start3b 
57c9 6c 5c			dw start3c 
57cb			 
57cb				; (unit) testing words 
57cb			 
57cb ad 5d			dw mtesta 
57cd 62 5e			dw mtestb 
57cf 05 5f			dw mtestc 
57d1 ba 5f			dw mtestd 
57d3 5e 60			dw mteste 
57d5			 
57d5				; demo/game words 
57d5			 
57d5 6a 67		        dw game3w 
57d7 98 67		        dw game3p 
57d9 b6 67		        dw game3sc 
57db e7 67		        dw game3vsi 
57dd 13 68		        dw game3vs 
57df				 
57df 5d 65			dw game2b 
57e1 cb 65			dw game2bf 
57e3 15 66			dw game2mba 
57e5 ab 66			dw game2mbas 
57e7 ed 66			dw game2mb 
57e9			 
57e9 1e 62			dw game1 
57eb 2f 62			dw game1a 
57ed 91 62			dw game1b 
57ef c6 62			dw game1c 
57f1 fc 62			dw game1d 
57f3 2d 63			dw game1s 
57f5 41 63			dw game1t 
57f7 56 63			dw game1f 
57f9 8a 63			dw game1z 
57fb ce 63			dw game1zz 
57fd			 
57fd 14 61			dw test5 
57ff 4c 61			dw test6 
5801 84 61			dw test7 
5803 98 61			dw test8 
5805 c4 61			dw test9 
5807 da 61			dw test10 
5809				 
5809 a5 64		        dw ssv5 
580b 89 64		        dw ssv4 
580d 6d 64		        dw ssv3 
580f 37 64		        dw ssv2 
5811 be 64		        dw ssv1 
5813 06 65		        dw ssv1cpm 
5815			;	dw keyup 
5815			;	dw keydown 
5815			;	dw keyleft 
5815			;	dw keyright 
5815			;	dw 	keyf1 
5815			;	dw keyf2 
5815			;	dw keyf3 
5815			;	dw keyf4 
5815			;	dw keyf5 
5815			;	dw keyf6 
5815			;	dw keyf7 
5815			;	dw keyf8 
5815			;	dw keyf9 
5815			;	dw keyf10 
5815			;	dw keyf11 
5815			;	dw keyf12 
5815			;	dw keytab 
5815			;	dw keycr 
5815			;	dw keyhome 
5815			;	dw keyend 
5815			;	dw keybs 
5815 00 00			db 0, 0	 
5817			 
5817			; SPI Net support words 
5817			 
5817			; v0! = node to send to 
5817			; ( str count - ) 
5817 .. 00		spi1:       db ": spitype spicel $00 do dup i + @ v0@ $10 spio spio spio $01 pause loop spiceh ; ; ",0 
586b			 
586b			; spiputchr ( char node - ) 
586b .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
58a1 .. 00		spi3:       db ": storestr spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
58dd			 
58dd			; spigetchr ( - n ) 
58dd .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5908			 
5908			; getnode ( - n ) 
5908 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5935			 
5935			 
5935			; store string ( str i - ) 
5935			 
5935 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
598a			 
598a			; get string ( addr i -  )    TO FIX 
598a			 
598a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
59e2			 
59e2			 
59e2			; SPICHAT (TODO) 
59e2			; Program to allow two nodes to chat with eachother 
59e2			; 
59e2			; v0 - target node 
59e2			;  
59e2			; accept input at 0,0 
59e2			; if input is string send spitype to target node 
59e2			; starting at row 2,0 , while spigetchr is not zero ->  
59e2			; 
59e2			; ( node - ) 
59e2 .. 00		spi8:		db ": spichatp $00 $00 at accept ;", 0 
5a01 .. 00		spi9: 		db ": spichatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5a59 .. 00		spi10:		db ": spichat v0! repeat spichatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . spichatr true until ;", 0 
5acc			 
5acc			 
5acc			; Long read of currently open file 
5acc .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5b13			 
5b13			; clear stack  
5b13			 
5b13 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5b46			 
5b46			; type ( addr count - ) 
5b46 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5b6a			 
5b6a			; some direct memory words 
5b6a			; strncpy ( len t f -- t ) 
5b6a			 
5b6a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5bcb			 
5bcb .. 00		start1:     	db ": bpon $0000 bp ;",0 
5bdd .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5bf0 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5c6c .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5ccc			 
5ccc			 
5ccc			; a handy word to list items on the stack 
5ccc			 
5ccc .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5d36			 
5d36			 
5d36			; test stack  
5d36			; rnd8 stest 
5d36			 
5d36 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5dad			 
5dad			; random malloc and free cycles 
5dad			 
5dad .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5e62			 
5e62			; fixed malloc and free cycles 
5e62			 
5e62 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5f05			 
5f05			; fixed double string push and drop cycle  
5f05			 
5f05 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5fba			 
5fba			; consistent fixed string push and drop cycle  
5fba			 
5fba .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
605e			 
605e .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6114			 
6114			;test1:		db ": aa 1 2 3 ;", 0 
6114			;test2:     	db "111 aa 888 999",0 
6114			;test3:     	db ": bb 77 ;",0 
6114			;test4:     	db "$02 $01 do i . loop bb",0 
6114			 
6114 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
614c .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6184 .. 00		test7:     	db ": box hline vline ;",0 
6198 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
61c4 .. 00		test9:     	db ": sw $01 adsp world ;",0 
61da .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
61ff .. 00		test11:     	db "hello create .",0 
620e .. 00		test12:     	db "hello2 create .",0 
621e			 
621e			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
621e			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
621e			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
621e			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
621e			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
621e			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
621e			 
621e			;iftest1:     	db "$0001 IF cls .",0 
621e			;iftest2:     	db "$0000 IF cls .",0 
621e			;iftest3:     	db "$0002 $0003 - IF cls .",0 
621e			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
621e			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
621e			 
621e			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
621e			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
621e			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
621e			 
621e			 
621e			 
621e			; a small guess the number game 
621e			 
621e .. 00		game1:          db ": gsn rnd8 v1! ;",0 
622f .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6291			 
6291 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
62c6 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
62fc .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
632d .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6341 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6356 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
638a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
63ce			 
63ce			; Using 'ga' save a high score across multiple runs using external storage 
63ce			 
63ce .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6437			 
6437			 
6437			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6437			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6437			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6437			 
6437			; simple screen saver to test code memory reuse to destruction 
6437			 
6437 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
646d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6489 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
64a5 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
64be .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6506 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
655d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
655d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
655d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
655d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
655d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
655d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
655d			 
655d			 
655d			 
655d			; minesweeper/battleship finding game 
655d			; draws a game board of random ship/mine positions 
655d			; user enters coords to see if it hits on 
655d			; game ends when all are hit 
655d			; when hit or miss says how many may be in the area 
655d			 
655d			; setup the game board and then hide it 
655d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
65cb .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6615			; prompt for where to target 
6615 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
66ab .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
66d0			; TODO see if the entered coords hits or misses pushes char hit of miss 
66d0 .. 00		game2mbht:      db ": mbckht nop ;",0 
66df .. 00		game2mbms:      db ": mbcms nop ;",0 
66ed			; TODO how many might be near by 
66ed .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
676a			 
676a			; Game 3 
676a			 
676a			; Vert scroller ski game - avoid the trees! 
676a			 
676a			; v0 score (ie turns) 
676a			; v1 player pos 
676a			; v2 left wall 
676a			; v3 right wall 
676a			 
676a			; Draw side walls randomly 
676a			 
676a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6798			 
6798			; Draw player 
6798 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
67b6			 
67b6			; TODO Get Key 
67b6			 
67b6			; TODO Move left right 
67b6			 
67b6			; scroll and move walls a bit 
67b6			 
67b6 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
67e7			 
67e7			; main game loop 
67e7			 
67e7 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6813 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6852			 
6852			; key board defs 
6852			 
6852 .. 00		keyup:       db ": keyup $05 ;",0 
6860 .. 00		keydown:       db ": keydown $0a ;",0 
6870 .. 00		keyleft:       db ": keyleft $0b ;",0 
6880 .. 00		keyright:       db ": keyright $0c ;",0 
6891 .. 00		keyf1:       db ": keyf1 $10 ;",0 
689f .. 00		keyf2:       db ": keyf2 $11 ;",0 
68ad .. 00		keyf3:       db ": keyf3 $12 ;",0 
68bb .. 00		keyf4:       db ": keyf4 $13 ;",0 
68c9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
68d7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
68e5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
68f3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6901 .. 00		keyf9:       db ": keyf9 $18 ;",0 
690f .. 00		keyf10:       db ": keyf10 $19 ;",0 
691e .. 00		keyf11:       db ": keyf11 $1a ;",0 
692d .. 00		keyf12:       db ": keyf12 $1b ;",0 
693c			 
693c .. 00		keytab:       db ": keytab $09 ;",0 
694b .. 00		keycr:       db ": keycr $0d ;",0 
6959 .. 00		keyhome:       db ": keyhome $0e ;",0 
6969 .. 00		keyend:       db ": keyend $0f ;",0 
6978 .. 00		keybs:       db ": keybs $08 ;",0 
6986			 
6986			   
6986			 
6986			 
6986			 
6986			; eof 
# End of file forth_autostart.asm
6986			 
6986 .. 00		sprompt1: db "Startup load...",0 
6996 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
69ac			 
69ac			 
69ac			 
69ac			 
69ac			forth_startup: 
69ac 21 a3 57			ld hl, startcmds 
69af 3e 00			ld a, 0 
69b1 32 22 f6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
69b4			 
69b4 e5			.start1:	push hl 
69b5 cd 18 0d			call clear_display 
69b8 11 86 69			ld de, sprompt1 
69bb 3e 00		        ld a, display_row_1 
69bd cd 2b 0d			call str_at_display 
69c0 11 96 69			ld de, sprompt2 
69c3 3e 28		        ld a, display_row_2 
69c5 cd 2b 0d			call str_at_display 
69c8 e1				pop hl 
69c9 e5				push hl 
69ca 5e				ld e,(hl) 
69cb 23				inc hl 
69cc 56				ld d,(hl) 
69cd 3e 50		        ld a, display_row_3 
69cf cd 2b 0d			call str_at_display 
69d2 cd 3b 0d			call update_display 
69d5			 
69d5			 
69d5 3a 22 f6			ld a, (os_last_cmd) 
69d8 fe 00			cp 0 
69da 28 05			jr z, .startprompt 
69dc cd 89 0c			call delay250ms 
69df 18 24			jr .startdo 
69e1				 
69e1				 
69e1			 
69e1			.startprompt: 
69e1			 
69e1 3e 9f			ld a,display_row_4 + display_cols - 1 
69e3 11 dd 1e		        ld de, endprg 
69e6 cd 2b 0d			call str_at_display 
69e9 cd 3b 0d			call update_display 
69ec cd 95 0c			call delay1s 
69ef cd fe 70			call cin_wait 
69f2						 
69f2 fe 2a			cp '*' 
69f4 28 5e			jr z, .startupend1 
69f6 fe 23			cp '#' 
69f8 20 07			jr nz, .startno 
69fa 3e 01			ld a, 1 
69fc 32 22 f6			ld (os_last_cmd),a 
69ff 18 04			jr .startdo 
6a01 fe 31		.startno:	cp '1' 
6a03 28 3a			jr z,.startnxt  
6a05			 
6a05				; exec startup line 
6a05			.startdo:	 
6a05 e1				pop hl 
6a06 e5				push hl 
6a07				 
6a07 5e				ld e,(hl) 
6a08 23				inc hl 
6a09 56				ld d,(hl) 
6a0a eb				ex de,hl 
6a0b			 
6a0b e5				push hl 
6a0c			 
6a0c 3e 00			ld a, 0 
6a0e				;ld a, FORTH_END_BUFFER 
6a0e cd b5 13			call strlent 
6a11 23				inc hl   ; include zero term to copy 
6a12 06 00			ld b,0 
6a14 4d				ld c,l 
6a15 e1				pop hl 
6a16 11 fc f1			ld de, scratch 
6a19 ed b0			ldir 
6a1b			 
6a1b			 
6a1b 21 fc f1			ld hl, scratch 
6a1e cd 23 23			call forthparse 
6a21 cd 63 23			call forthexec 
6a24 cd 75 22			call forthexec_cleanup 
6a27			 
6a27 3e 78			ld a, display_row_4 
6a29 11 81 1c			ld de, endprog 
6a2c			 
6a2c cd 3b 0d			call update_display		 
6a2f			 
6a2f 3a 22 f6			ld a, (os_last_cmd) 
6a32 fe 00			cp 0 
6a34 20 09			jr nz, .startnxt 
6a36 cd df 1e			call next_page_prompt 
6a39 cd 18 0d		        call clear_display 
6a3c cd 3b 0d			call update_display		 
6a3f			 
6a3f				; move onto next startup line? 
6a3f			.startnxt: 
6a3f			 
6a3f cd 89 0c			call delay250ms 
6a42 e1				pop hl 
6a43			 
6a43 23				inc hl 
6a44 23				inc hl 
6a45			 
6a45 e5				push hl 
6a46 5e				ld e, (hl) 
6a47 23				inc hl 
6a48 56				ld d, (hl) 
6a49 e1				pop hl 
6a4a				; TODO replace 0 test 
6a4a			 
6a4a eb				ex de, hl 
6a4b cd 75 0f			call ishlzero 
6a4e			;	ld a,e 
6a4e			;	add d 
6a4e			;	cp 0    ; any left to do? 
6a4e eb				ex de, hl 
6a4f c2 b4 69			jp nz, .start1 
6a52 18 01			jr .startupend 
6a54			 
6a54 e1			.startupend1: pop hl 
6a55			.startupend: 
6a55			 
6a55 cd 18 0d			call clear_display 
6a58 cd 3b 0d			call update_display 
6a5b c9				ret 
6a5c			 
6a5c			 
6a5c			; stack over and underflow checks 
6a5c			 
6a5c			; init the words to detect the under/overflow 
6a5c			 
6a5c			chk_stk_init: 
6a5c				; a vague random number to check so we dont get any "lucky" hits 
6a5c 3e 2d			ld a, 45 
6a5e 6f				ld l, a 
6a5f 00				nop 
6a60 3e 17			ld a, 23 
6a62 67				ld h, a 
6a63			 
6a63 22 e3 f1			ld (chk_word), hl     ; the word we need to check against 
6a66			 
6a66			;	ld (chk_stund), hl	; stack points.... 
6a66 22 fd fe			ld (chk_stovr), hl 
6a69 22 27 fa			ld (chk_ret_und), hl 
6a6c 22 e5 f9			ld (chk_ret_ovr), hl 
6a6f 22 63 f9			ld (chk_loop_ovr), hl 
6a72 22 61 f7			ld (chk_data_ovr), hl 
6a75 c9				ret 
6a76				 
6a76			check_stacks: 
6a76				; check all stack words 
6a76			 
6a76 e5				push hl 
6a77 d5				push de 
6a78			 
6a78			;	ld de,(chk_word) 
6a78			;	ld hl, (chk_stund)	; stack points.... 
6a78			;	if DEBUG_STK_FAULT 
6a78			;		DMARK "FAa" 
6a78			;		CALLMONITOR 
6a78			;	endif 
6a78			;	call cmp16 
6a78			;	jp z, .chk_faulta 
6a78			; 
6a78			;	ld de, sfaultsu 
6a78			;	jp .chk_fault 
6a78			 
6a78 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6a7b ed 5b e3 f1		ld de,(chk_word) 
6a7f				if DEBUG_STK_FAULT 
6a7f					DMARK "FAb" 
6a7f					CALLMONITOR 
6a7f				endif 
6a7f cd 6a 0f			call cmp16 
6a82 28 06			jr z, .chk_fault1 
6a84 11 25 6b			ld de, sfaultso 
6a87 c3 d9 6a			jp .chk_fault 
6a8a			.chk_fault1:  
6a8a 2a 27 fa			ld hl, (chk_ret_und) 
6a8d ed 5b e3 f1		ld de,(chk_word) 
6a91				if DEBUG_STK_FAULT 
6a91					DMARK "FAU" 
6a91					CALLMONITOR 
6a91				endif 
6a91 cd 6a 0f			call cmp16 
6a94 ca 9d 6a			jp z, .chk_fault2 
6a97 11 35 6b			ld de, sfaultru 
6a9a c3 d9 6a			jp .chk_fault 
6a9d			.chk_fault2:  
6a9d 2a e5 f9			ld hl, (chk_ret_ovr) 
6aa0 ed 5b e3 f1		ld de,(chk_word) 
6aa4				if DEBUG_STK_FAULT 
6aa4					DMARK "FA1" 
6aa4					CALLMONITOR 
6aa4				endif 
6aa4 cd 6a 0f			call cmp16 
6aa7 ca b0 6a			jp z, .chk_fault3 
6aaa 11 43 6b			ld de, sfaultro 
6aad c3 d9 6a			jp .chk_fault 
6ab0			.chk_fault3:  
6ab0 2a 63 f9			ld hl, (chk_loop_ovr) 
6ab3 ed 5b e3 f1		ld de,(chk_word) 
6ab7				if DEBUG_STK_FAULT 
6ab7					DMARK "FA2" 
6ab7					CALLMONITOR 
6ab7				endif 
6ab7 cd 6a 0f			call cmp16 
6aba ca c3 6a			jp z, .chk_fault4 
6abd 11 5d 6b			ld de, sfaultlo 
6ac0 c3 d9 6a			jp .chk_fault 
6ac3			.chk_fault4:  
6ac3 2a 61 f7			ld hl, (chk_data_ovr) 
6ac6 ed 5b e3 f1		ld de,(chk_word) 
6aca				if DEBUG_STK_FAULT 
6aca					DMARK "FA3" 
6aca					CALLMONITOR 
6aca				endif 
6aca cd 6a 0f			call cmp16 
6acd ca d6 6a			jp z, .chk_fault5 
6ad0 11 77 6b			ld de, sfaultdo 
6ad3 c3 d9 6a			jp .chk_fault 
6ad6			 
6ad6			 
6ad6			.chk_fault5:  
6ad6 d1				pop de 
6ad7 e1				pop hl 
6ad8			 
6ad8 c9				ret 
6ad9			 
6ad9 cd 18 0d		.chk_fault: 	call clear_display 
6adc 3e 28				ld a, display_row_2 
6ade cd 2b 0d				call str_at_display 
6ae1 11 07 6b				   ld de, .stackfault 
6ae4 3e 00				ld a, display_row_1 
6ae6 cd 2b 0d				call str_at_display 
6ae9 11 6e fe				    ld de, debug_mark 
6aec 3e 11				ld a, display_row_1+17 
6aee cd 2b 0d				call str_at_display 
6af1 cd 3b 0d				call update_display 
6af4			 
6af4				; prompt before entering montior for investigating issue 
6af4			 
6af4 3e 78			ld a, display_row_4 
6af6 11 81 1c			ld de, endprog 
6af9			 
6af9 cd 3b 0d			call update_display		 
6afc			 
6afc cd df 1e			call next_page_prompt 
6aff			 
6aff d1				pop de 
6b00 e1				pop hl 
6b01 cd d5 1c				call monitor 
6b04 c3 cc 1b				jp warmstart 
6b07					;jp 0 
6b07					;halt 
6b07			 
6b07			 
6b07			 
6b07 .. 00		.stackfault: 	db "Stack fault:",0 
6b14			 
6b14 .. 00		sfaultsu: 	db	"Stack under flow",0 
6b25 .. 00		sfaultso: 	db	"Stack over flow",0 
6b35 .. 00		sfaultru:	db "RTS underflow",0 
6b43 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6b5d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6b77 .. 00		sfaultdo:	db "DTS overflow", 0 
6b84			 
6b84			 
6b84			fault_dsp_under: 
6b84 11 96 6b			ld de, .dsp_under 
6b87 c3 46 6c			jp .show_fault 
6b8a			 
6b8a			fault_rsp_under: 
6b8a 11 a4 6b			ld de, .rsp_under 
6b8d c3 46 6c			jp .show_fault 
6b90			fault_loop_under: 
6b90 11 b2 6b			ld de, .loop_under 
6b93 c3 46 6c			jp .show_fault 
6b96			 
6b96 .. 00		.dsp_under: db "DSP Underflow",0 
6ba4 .. 00		.rsp_under: db "RSP Underflow",0 
6bb2 .. 00		.loop_under: db "LOOP Underflow",0 
6bc1			 
6bc1			 
6bc1 d5			type_faultn: 	push de 
6bc2 e5					push hl 
6bc3 cd 18 0d				call clear_display 
6bc6 11 ed 6b				   ld de, .typefaultn 
6bc9 3e 00				ld a, display_row_1 
6bcb cd 2b 0d				call str_at_display 
6bce 11 6e fe				    ld de, debug_mark 
6bd1 3e 11				ld a, display_row_1+17 
6bd3 cd 2b 0d				call str_at_display 
6bd6 cd 3b 0d				call update_display 
6bd9			 
6bd9				; prompt before entering montior for investigating issue 
6bd9			 
6bd9 3e 78			ld a, display_row_4 
6bdb 11 81 1c			ld de, endprog 
6bde			 
6bde cd 3b 0d			call update_display		 
6be1			 
6be1 cd df 1e			call next_page_prompt 
6be4			 
6be4 e5					push hl 
6be5 d5					push de 
6be6 cd d5 1c				call monitor 
6be9 c3 cc 1b				jp warmstart 
6bec 76					halt 
6bed			 
6bed			 
6bed .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6c04			 
6c04 d5			type_faults: 	push de 
6c05 e5					push hl 
6c06 cd 18 0d				call clear_display 
6c09 11 2f 6c				   ld de, .typefaults 
6c0c 3e 00				ld a, display_row_1 
6c0e cd 2b 0d				call str_at_display 
6c11 11 6e fe				    ld de, debug_mark 
6c14 3e 11				ld a, display_row_1+17 
6c16 cd 2b 0d				call str_at_display 
6c19 cd 3b 0d				call update_display 
6c1c			 
6c1c				; prompt before entering montior for investigating issue 
6c1c			 
6c1c 3e 78			ld a, display_row_4 
6c1e 11 81 1c			ld de, endprog 
6c21			 
6c21 cd 3b 0d			call update_display		 
6c24			 
6c24 cd df 1e			call next_page_prompt 
6c27			 
6c27 e1					pop hl 
6c28 d1					pop de 
6c29 cd d5 1c				call monitor 
6c2c c3 cc 1b				jp warmstart 
6c2f			 
6c2f			 
6c2f .. 00		.typefaults: db "STR Type Expected TOS!",0 
6c46			 
6c46			.show_fault: 	 
6c46 d5					push de 
6c47 cd 18 0d				call clear_display 
6c4a d1					pop de 
6c4b 3e 00				ld a, display_row_1 
6c4d cd 2b 0d				call str_at_display 
6c50 11 6e fe				    ld de, debug_mark 
6c53 3e 11				ld a, display_row_1+17 
6c55 cd 2b 0d				call str_at_display 
6c58 cd 3b 0d				call update_display 
6c5b			 
6c5b				; prompt before entering montior for investigating issue 
6c5b			 
6c5b 3e 78			ld a, display_row_4 
6c5d 11 81 1c			ld de, endprog 
6c60			 
6c60 cd 3b 0d			call update_display		 
6c63			 
6c63 cd df 1e			call next_page_prompt 
6c66			 
6c66 e1					pop hl 
6c67 d1					pop de 
6c68 cd d5 1c				call monitor 
6c6b			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6c6b			; TODO Make optional fault restart to cli or warm boot? 
6c6b					;jp warmstart 
6c6b c3 27 1c				jp cli 
6c6e 76					halt 
6c6f			 
6c6f			; handle the auto run of code from files in storage 
6c6f			 
6c6f			 
6c6f			if STORAGE_SE 
6c6f			 
6c6f .. 00		sprompt3: db "Loading from start-up file?:",0 
6c8c .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6c9d			 
6c9d			 
6c9d			forth_autoload: 
6c9d			 
6c9d				; load block 0 of store 1 
6c9d				 
6c9d 3e fe			ld a, $fe      ; bit 0 clear 
6c9f 32 67 fa			ld (spi_device), a 
6ca2			 
6ca2 cd cd 04			call storage_get_block_0 
6ca5			 
6ca5 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
6ca8			 
6ca8 fe 00			cp 0 
6caa c8				ret z     ; auto start not enabled 
6cab			 
6cab cd 18 0d			call clear_display 
6cae			 
6cae				; set bank 
6cae			 
6cae 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
6cb1 32 67 fa				ld (spi_device), a 
6cb4			 
6cb4				; get file id to load from and get the file name to display 
6cb4			 
6cb4 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
6cb7			 
6cb7 2e 00				ld l, 0 
6cb9 67					ld h, a 
6cba 11 81 fa				ld de, store_page 
6cbd			 
6cbd					if DEBUG_FORTH_WORDS 
6cbd						DMARK "ASp" 
6cbd f5				push af  
6cbe 3a d2 6c			ld a, (.dmark)  
6cc1 32 6e fe			ld (debug_mark),a  
6cc4 3a d3 6c			ld a, (.dmark+1)  
6cc7 32 6f fe			ld (debug_mark+1),a  
6cca 3a d4 6c			ld a, (.dmark+2)  
6ccd 32 70 fe			ld (debug_mark+2),a  
6cd0 18 03			jr .pastdmark  
6cd2 ..			.dmark: db "ASp"  
6cd5 f1			.pastdmark: pop af  
6cd6			endm  
# End of macro DMARK
6cd6						CALLMONITOR 
6cd6 cd f3 18			call break_point_state  
6cd9				endm  
# End of macro CALLMONITOR
6cd9					endif 
6cd9 cd 75 09				call storage_read 
6cdc			 
6cdc					if DEBUG_FORTH_WORDS 
6cdc						DMARK "ASr" 
6cdc f5				push af  
6cdd 3a f1 6c			ld a, (.dmark)  
6ce0 32 6e fe			ld (debug_mark),a  
6ce3 3a f2 6c			ld a, (.dmark+1)  
6ce6 32 6f fe			ld (debug_mark+1),a  
6ce9 3a f3 6c			ld a, (.dmark+2)  
6cec 32 70 fe			ld (debug_mark+2),a  
6cef 18 03			jr .pastdmark  
6cf1 ..			.dmark: db "ASr"  
6cf4 f1			.pastdmark: pop af  
6cf5			endm  
# End of macro DMARK
6cf5						CALLMONITOR 
6cf5 cd f3 18			call break_point_state  
6cf8				endm  
# End of macro CALLMONITOR
6cf8					endif 
6cf8			 
6cf8 cd 75 0f				call ishlzero 
6cfb c8					ret z             ; file not found 
6cfc			 
6cfc 3e 32				ld a, display_row_2 + 10 
6cfe 11 84 fa				ld de, store_page+3 
6d01 cd 2b 0d				call str_at_display 
6d04				 
6d04			; 
6d04			 
6d04 3e 05			ld a, display_row_1+5 
6d06 11 6f 6c			ld de, sprompt3 
6d09 cd 2b 0d			call str_at_display 
6d0c 3e 5f			ld a, display_row_3+15 
6d0e 11 8c 6c			ld de, sprompt4 
6d11 cd 2b 0d			call str_at_display 
6d14			 
6d14 cd 3b 0d			call update_display 
6d17			 
6d17 cd fe 70			call cin_wait 
6d1a fe 6e			cp 'n' 
6d1c c8				ret z 
6d1d fe 4e			cp 'N' 
6d1f c8				ret z 
6d20			 
6d20 cd 95 0c			call delay1s 
6d23			 
6d23 3a 83 fa			ld a, (store_page+2) 
6d26 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
6d29 3e 01			ld a, 1  
6d2b 32 71 fa			ld (store_openext), a    ; save count of ext 
6d2e			 
6d2e			.autof:  
6d2e 6f				ld l , a 
6d2f				 
6d2f 3a 81 fa			ld a, (store_page) 
6d32 67				ld h, a	 
6d33 11 81 fa			ld de, store_page 
6d36					if DEBUG_FORTH_WORDS 
6d36						DMARK "ASl" 
6d36 f5				push af  
6d37 3a 4b 6d			ld a, (.dmark)  
6d3a 32 6e fe			ld (debug_mark),a  
6d3d 3a 4c 6d			ld a, (.dmark+1)  
6d40 32 6f fe			ld (debug_mark+1),a  
6d43 3a 4d 6d			ld a, (.dmark+2)  
6d46 32 70 fe			ld (debug_mark+2),a  
6d49 18 03			jr .pastdmark  
6d4b ..			.dmark: db "ASl"  
6d4e f1			.pastdmark: pop af  
6d4f			endm  
# End of macro DMARK
6d4f						CALLMONITOR 
6d4f cd f3 18			call break_point_state  
6d52				endm  
# End of macro CALLMONITOR
6d52					endif 
6d52 cd 75 09				call storage_read 
6d55 cd 75 0f			call ishlzero 
6d58 c8				ret z 
6d59			;	jr z, .autoend 
6d59			 
6d59					if DEBUG_FORTH_WORDS 
6d59						DMARK "ASc" 
6d59 f5				push af  
6d5a 3a 6e 6d			ld a, (.dmark)  
6d5d 32 6e fe			ld (debug_mark),a  
6d60 3a 6f 6d			ld a, (.dmark+1)  
6d63 32 6f fe			ld (debug_mark+1),a  
6d66 3a 70 6d			ld a, (.dmark+2)  
6d69 32 70 fe			ld (debug_mark+2),a  
6d6c 18 03			jr .pastdmark  
6d6e ..			.dmark: db "ASc"  
6d71 f1			.pastdmark: pop af  
6d72			endm  
# End of macro DMARK
6d72						CALLMONITOR 
6d72 cd f3 18			call break_point_state  
6d75				endm  
# End of macro CALLMONITOR
6d75					endif 
6d75 11 83 fa			ld de, store_page+2 
6d78 3e 78			ld a, display_row_4 
6d7a cd 2b 0d			call str_at_display 
6d7d			 
6d7d cd 3b 0d			call update_display 
6d80 cd 89 0c			call delay250ms 
6d83			 
6d83			 
6d83			 
6d83 21 83 fa			ld hl, store_page+2 
6d86 cd 23 23			call forthparse 
6d89 cd 63 23			call forthexec 
6d8c cd 75 22			call forthexec_cleanup 
6d8f			 
6d8f				 
6d8f 3a 71 fa			ld a, (store_openext) 
6d92 3c				inc a 
6d93 32 71 fa			ld (store_openext), a    ; save count of ext 
6d96			 
6d96 18 96			jr .autof 
6d98			;.autofdone: 
6d98			; 
6d98			;		if DEBUG_FORTH_WORDS 
6d98			;			DMARK "ASx" 
6d98			;			CALLMONITOR 
6d98			;		endif 
6d98			;;	call clear_display 
6d98			;	ret 
6d98			 
6d98			 
6d98			 
6d98			endif 
6d98			 
6d98			 
6d98			; eof 
# End of file forth_kernel.asm
6d98			;include "nascombasic.asm" 
6d98			 
6d98			 
6d98			; find out where the code ends if loaded into RAM (for SC114) 
6d98			;endofcode:  
6d98			;	nop 
6d98			 
6d98			 
6d98			; eof 
6d98			 
# End of file main.asm
6d98			include "firmware_lcd_4x40.asm" 
6d98			; **********************************************************************  
6d98			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6d98			; **********************************************************************  
6d98			;  
6d98			; **  Written as a Small Computer Monitor App  
6d98			; **  www.scc.me.uk  
6d98			;  
6d98			; History  
6d98			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6d98			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6d98			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6d98			;  
6d98			; **********************************************************************  
6d98			;  
6d98			; This program is an example of one of the methods of interfacing an   
6d98			; alphanumeric LCD module.   
6d98			;  
6d98			; In this example the display is connected to either a Z80 PIO or a   
6d98			; simple 8-bit output port.   
6d98			;  
6d98			; This interfacing method uses 4-bit data mode and uses time delays  
6d98			; rather than polling the display's ready status. As a result the   
6d98			; interface only requires 6 simple output lines:  
6d98			;   Output bit 0 = not used  
6d98			;   Output bit 1 = not used  
6d98			;   Output bit 2 = RS         High = data, Low = instruction  
6d98			;   Output bit 3 = E          Active high  
6d98			;   Output bit 4 = DB4  
6d98			;   Output bit 5 = DB5  
6d98			;   Output bit 6 = DB6  
6d98			;   Output bit 7 = DB7  
6d98			; Display's R/W is connected to 0v so it is always in write mode  
6d98			;  
6d98			; This set up should work with any system supporting the RC2014 bus  
6d98			  
6d98			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6d98			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6d98			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6d98			;  
6d98			; **********************************************************************  
6d98			  
6d98			; Additonal for 4x40. E1 and E2 instead of just E   
6d98			; TODO swipe vidout signal on port a to activate E2  
6d98			  
6d98			; **********************************************************************  
6d98			; **  Constants  
6d98			; **********************************************************************  
6d98			; LCD constants required by LCD support module  
6d98			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6d98			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6d98			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6d98			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6d98			; TODO Decide which E is being set  
6d98			kLCDWidth:  EQU display_cols             ;Width in characters  
6d98			  
6d98			; **********************************************************************  
6d98			; **  Code library usage  
6d98			; **********************************************************************  
6d98			  
6d98			; send character to current cursor position  
6d98			; wraps and/or scrolls screen automatically  
6d98			  
6d98			  
6d98			  
6d98			lcd_init:  
6d98			  
6d98			; SCMonAPI functions used  
6d98			  
6d98			; Alphanumeric LCD functions used  
6d98			; no need to specify specific functions for this module  
6d98			  
6d98 3e cf		            LD   A, 11001111b  
6d9a d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6d9c 3e 00		            LD   A, 00000000b  
6d9e d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6da0			  
6da0			; Initialise alphanumeric LCD module  
6da0 3e 00				ld a, 0  
6da2 32 ce fb				ld (display_lcde1e2), a  
6da5 cd 26 6e		            CALL fLCD_Init      ;Initialise LCD module  
6da8 3e 01				ld a, 1  
6daa 32 ce fb				ld (display_lcde1e2), a  
6dad cd 26 6e		            CALL fLCD_Init      ;Initialise LCD module  
6db0			  
6db0 c9				ret  
6db1			  
6db1			;  
6db1			;;  
6db1			; lcd functions  
6db1			;  
6db1			;  
6db1			  
6db1			; what is at cursor position   
6db1			  
6db1			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6db1			;		call curptr  
6db1			;		ret  
6db1			  
6db1			  
6db1			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6db1			  
6db1			curptr:  
6db1 c5				push bc  
6db2 21 b4 fd			ld hl, display_fb0  
6db5			cpr:	  
6db5				; loop for cursor whole row  
6db5 0e 28			ld c, display_cols  
6db7 23			cpr1:	inc hl  
6db8 0d				dec c  
6db9 20 fc			jr nz, cpr1  
6dbb 05				dec b  
6dbc 20 f7			jr nz, cpr  
6dbe			  
6dbe				; add col	  
6dbe			  
6dbe 23			cpr2:	inc hl  
6dbf 1d				dec e  
6dc0 20 fc			jr nz, cpr2  
6dc2			  
6dc2 c1				pop bc  
6dc3 c9				ret  
6dc4				  
6dc4			  
6dc4			  
6dc4			  
6dc4			  
6dc4			; write the frame buffer given in hl to hardware   
6dc4 22 cc fb		write_display: ld (display_write_tmp), hl 	   
6dc7 3e 00			ld a, kLCD_Line1  
6dc9 cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6dcc 06 28			ld b, display_cols  
6dce ed 5b cc fb		ld de, (display_write_tmp)  
6dd2 cd 1e 6e			call write_len_string  
6dd5				  
6dd5				  
6dd5 2a cc fb			ld hl, (display_write_tmp)  
6dd8 11 28 00			ld de, display_cols  
6ddb 19				add hl,de  
6ddc 22 cc fb			ld (display_write_tmp),hl  
6ddf			  
6ddf				  
6ddf 3e 28			ld a, kLCD_Line2  
6de1 cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6de4 06 28			ld b, display_cols  
6de6 ed 5b cc fb		ld de, (display_write_tmp)  
6dea cd 1e 6e			call write_len_string  
6ded				  
6ded 2a cc fb			ld hl, (display_write_tmp)  
6df0 11 28 00			ld de, display_cols  
6df3 19				add hl,de  
6df4 22 cc fb			ld (display_write_tmp),hl  
6df7			  
6df7				  
6df7 3e 50			ld a, kLCD_Line3  
6df9 cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6dfc 06 28			ld b, display_cols  
6dfe ed 5b cc fb		ld de, (display_write_tmp)  
6e02 cd 1e 6e			call write_len_string  
6e05				  
6e05 2a cc fb			ld hl, (display_write_tmp)  
6e08 11 28 00			ld de, display_cols  
6e0b 19				add hl,de  
6e0c 22 cc fb			ld (display_write_tmp),hl  
6e0f			  
6e0f				  
6e0f 3e 78			ld a, kLCD_Line4  
6e11 cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
6e14 06 28			ld b, display_cols  
6e16 ed 5b cc fb		ld de, (display_write_tmp)  
6e1a cd 1e 6e			call write_len_string  
6e1d c9					ret  
6e1e				  
6e1e				; write out a fixed length string given in b from de  
6e1e			  
6e1e 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6e1f cd 8b 6e		            CALL fLCD_Data      ;Write character to display  
6e22 13				inc de  
6e23 10 f9			djnz write_len_string  
6e25 c9				ret  
6e26			  
6e26			; Some other things to do  
6e26			;            LD   A, kLCD_Clear ;Display clear  
6e26			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6e26			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6e26			;            LD   A, kLCD_On     ;Display on with no cursor  
6e26			;            ;LD   A, kLCD_Off   ;Display off  
6e26			;            CALL fLCD_Inst      ;Send instruction to display  
6e26			;  
6e26			;  
6e26			;            halt  
6e26			;  
6e26			;  
6e26			;MsgHello:   DB  "Hello World!",0  
6e26			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6e26			  
6e26			; Custom characters 5 pixels wide by 8 pixels high  
6e26			; Up to 8 custom characters can be defined  
6e26			;BitMaps:      
6e26			;; Character 0x00 = Battery icon  
6e26			;            DB  01110b  
6e26			;            DB  11011b  
6e26			;            DB  10001b  
6e26			;            DB  10001b  
6e26			;            DB  11111b  
6e26			;            DB  11111b  
6e26			;            DB  11111b  
6e26			;            DB  11111b  
6e26			;; Character 0x01 = Bluetooth icon  
6e26			;            DB  01100b  
6e26			;            DB  01010b  
6e26			;            DB  11100b  
6e26			;            DB  01000b  
6e26			;            DB  11100b  
6e26			;            DB  01010b  
6e26			;            DB  01100b  
6e26			;            DB  00000b  
6e26			;  
6e26			  
6e26			  
6e26			; **********************************************************************  
6e26			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6e26			; **********************************************************************  
6e26			;  
6e26			; **  Written as a Small Computer Monitor App   
6e26			; **  Version 0.1 SCC 2018-05-16  
6e26			; **  www.scc.me.uk  
6e26			;  
6e26			; **********************************************************************  
6e26			;  
6e26			; This module provides support for alphanumeric LCD modules using with  
6e26			; *  HD44780 (or compatible) controller  
6e26			; *  5 x 7 pixel fonts  
6e26			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6e26			; *  Interface via six digital outputs to the display (see below)  
6e26			;  
6e26			; LCD module pinout:  
6e26			;   1  Vss   0v supply  
6e26			;   2  Vdd   5v supply  
6e26			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6e26			;   4  RS    High = data, Low = instruction  
6e26			;   5  R/W   High = Read, Low = Write  
6e26			;   6  E     Enable signal (active high)  
6e26			;   7  DB0   Data bit 0  
6e26			;   8  DB1   Data bit 1  
6e26			;   9  DB2   Data bit 2  
6e26			;  10  DB3   Data bit 3  
6e26			;  11  DB4   Data bit 4  
6e26			;  12  DB5   Data bit 5  
6e26			;  13  DB6   Data bit 6  
6e26			;  14  DB7   Data bit 7  
6e26			;  15  A     Backlight anode (+)  
6e26			;  16  K     Backlight cathode (-)  
6e26			;  
6e26			; This interfacing method uses 4-bit data mode and uses time delays  
6e26			; rather than polling the display's ready status. As a result the   
6e26			; interface only requires 6 simple output lines:  
6e26			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6e26			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6e26			;   LCD DB4 = Microcomputer output port bit 4  
6e26			;   LCD DB5 = Microcomputer output port bit 5  
6e26			;   LCD DB6 = Microcomputer output port bit 6  
6e26			;   LCD DB7 = Microcomputer output port bit 7  
6e26			; Display's R/W is connected to 0v so it is always in write mode  
6e26			; All 6 connections must be on the same port address <kLCDPrt>  
6e26			; This method also allows a decent length of cable from micro to LCD  
6e26			;  
6e26			; **********************************************************************  
6e26			;  
6e26			; To include the code for any given function provided by this module,   
6e26			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6e26			; the parent source file.  
6e26			; For example:  #REQUIRES   uHexPrefix  
6e26			;  
6e26			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6e26			; in the parent source file.  
6e26			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6e26			;  
6e26			; These are the function names provided by this module:  
6e26			; fLCD_Init                     ;Initialise LCD  
6e26			; fLCD_Inst                     ;Send instruction to LCD  
6e26			; fLCD_Data                     ;Send data byte to LCD  
6e26			; fLCD_Pos                      ;Position cursor  
6e26			; fLCD_Str                      ;Display string  
6e26			; fLCD_Def                      ;Define custom character  
6e26			;  
6e26			; **********************************************************************  
6e26			;  
6e26			; Requires SCMonAPI.asm to also be included in the project  
6e26			;  
6e26			  
6e26			  
6e26			; **********************************************************************  
6e26			; **  Constants  
6e26			; **********************************************************************  
6e26			  
6e26			; Constants that must be defined externally  
6e26			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6e26			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6e26			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6e26			;kLCDWidth: EQU 20             ;Width in characters  
6e26			  
6e26			; general line offsets in any frame buffer  
6e26			  
6e26			  
6e26			display_row_1: equ 0  
6e26			display_row_2: equ display_row_1+display_cols  
6e26			display_row_3: equ display_row_2 + display_cols  
6e26			display_row_4: equ display_row_3 + display_cols  
6e26			;display_row_4_eol:   
6e26			  
6e26			  
6e26			; Cursor position values for the start of each line  
6e26			  
6e26			; E  
6e26			kLCD_Line1: EQU 0x00   
6e26			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6e26			; E1  
6e26			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6e26			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6e26			  
6e26			; Instructions to send as A register to fLCD_Inst  
6e26			kLCD_Clear: EQU 00000001b     ;LCD clear  
6e26			kLCD_Off:   EQU 00001000b     ;LCD off  
6e26			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6e26			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6e26			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6e26			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6e26			  
6e26			; Constants used by this code module  
6e26			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6e26			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6e26			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6e26			  
6e26			  
6e26			  
6e26			; **********************************************************************  
6e26			; **  LCD support functions  
6e26			; **********************************************************************  
6e26			  
6e26			; Initialise alphanumeric LCD module  
6e26			; LCD control register codes:  
6e26			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6e26			;   N    0 = 1-line mode       1 = 2-line mode  
6e26			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6e26			;   D    0 = Display off       1 = Display on  
6e26			;   C    0 = Cursor off        1 = Cursor on  
6e26			;   B    0 = Blinking off      1 = Blinking on  
6e26			;   ID   0 = Decrement mode    1 = Increment mode  
6e26			;   SH   0 = Entire shift off  1 = Entire shift on  
6e26 3e 28		fLCD_Init:  LD   A, 40  
6e28 cd 4d 6f		            CALL LCDDelay       ;Delay 40ms after power up  
6e2b			; For reliable reset set 8-bit mode - 3 times  
6e2b cd 1d 6f		            CALL WrFn8bit       ;Function = 8-bit mode  
6e2e cd 1d 6f		            CALL WrFn8bit       ;Function = 8-bit mode  
6e31 cd 1d 6f		            CALL WrFn8bit       ;Function = 8-bit mode  
6e34			; Set 4-bit mode  
6e34 cd 19 6f		            CALL WrFn4bit       ;Function = 4-bit mode  
6e37 cd 4b 6f		            CALL LCDDelay1      ;Delay 37 us or more  
6e3a			; Function set  
6e3a 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6e3c cd 4f 6e		            CALL fLCD_Inst      ;2 line, display on  
6e3f			; Display On/Off control  
6e3f 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6e41 cd 4f 6e		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6e44			; Display Clear  
6e44 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6e46 cd 4f 6e		            CALL fLCD_Inst      ;Clear display  
6e49			; Entry mode  
6e49 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6e4b cd 4f 6e		            CALL fLCD_Inst      ;Increment mode, shift off  
6e4e			; Display module now initialised  
6e4e c9			            RET  
6e4f			; ok to here  
6e4f			  
6e4f			; Write instruction to LCD  
6e4f			;   On entry: A = Instruction byte to be written  
6e4f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6e4f f5			fLCD_Inst:  PUSH AF  
6e50 f5			            PUSH AF  
6e51 cd 63 6e		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6e54 f1			            POP  AF  
6e55 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6e56 17			            RLA  
6e57 17			            RLA  
6e58 17			            RLA  
6e59 cd 63 6e		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6e5c 3e 02		            LD   A, 2  
6e5e cd 4d 6f		            CALL LCDDelay       ;Delay 2 ms to complete   
6e61 f1			            POP  AF  
6e62 c9			            RET  
6e63			Wr4bits:   
6e63 f5					push af  
6e64 3a ce fb				ld a, (display_lcde1e2)  
6e67 fe 00				cp 0     ; e  
6e69 20 10				jr nz, .wea2	  
6e6b f1					pop af  
6e6c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6e6e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e70 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6e72 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6e74 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6e76 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6e78 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e7a c9			            RET  
6e7b f1			.wea2:		pop af  
6e7c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6e7e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e80 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6e82 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6e84 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6e86 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6e88 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6e8a c9			            RET  
6e8b			  
6e8b			  
6e8b			; Write data to LCD  
6e8b			;   On entry: A = Data byte to be written  
6e8b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6e8b f5			fLCD_Data:  PUSH AF  
6e8c f5			            PUSH AF  
6e8d cd 9f 6e		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6e90 f1			            POP  AF  
6e91 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6e92 17			            RLA  
6e93 17			            RLA  
6e94 17			            RLA  
6e95 cd 9f 6e		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6e98 3e 96		            LD   A, 150  
6e9a 3d			Wait:      DEC  A              ;Wait a while to allow data   
6e9b 20 fd		            JR   NZ, Wait      ;  write to complete  
6e9d f1			            POP  AF  
6e9e c9			            RET  
6e9f			Wr4bitsa:     
6e9f f5					push af  
6ea0 3a ce fb				ld a, (display_lcde1e2)  
6ea3 fe 00				cp 0     ; e1  
6ea5 20 16				jr nz, .we2	  
6ea7 f1					pop af  
6ea8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6eaa cb d7		            SET  kLCDBitRS, A  
6eac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6eae cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6eb0 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6eb2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6eb4 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6eb6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6eb8 cb 97		            RES  kLCDBitRS, A  
6eba d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6ebc c9			            RET  
6ebd f1			.we2:		pop af  
6ebe e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6ec0 cb d7		            SET  kLCDBitRS, A  
6ec2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6ec4 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6ec6 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6ec8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6eca cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6ecc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6ece cb 97		            RES  kLCDBitRS, A  
6ed0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6ed2 c9			            RET  
6ed3			  
6ed3			  
6ed3			; Position cursor to specified location  
6ed3			;   On entry: A = Cursor position  
6ed3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6ed3 f5			fLCD_Pos:   PUSH AF  
6ed4					; at this point set the E1 or E2 flag depending on position  
6ed4			  
6ed4 c5					push bc  
6ed5			;		push af  
6ed5 06 00				ld b, 0  
6ed7 4f					ld c, a  
6ed8 3e 4f				ld a, kLCD_Line3-1  
6eda b7			 		or a      ;clear carry flag  
6edb 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6edc 38 04				jr c, .pe1  
6ede			  
6ede					; E selection  
6ede cb 80				res 0, b         ; bit 0 unset e  
6ee0			;		pop af    ; before line 3 so recover orig pos  
6ee0			;		ld c, a    ; save for poking back  
6ee0 18 06				jr .peset	          
6ee2			.pe1:          	; E2 selection  
6ee2 cb c0				set 0, b         ; bit 0 set e1  
6ee4 79					ld a, c  
6ee5 de 4f				sbc a, kLCD_Line3-1  
6ee7 4f					ld c, a	         ; save caculated offset  
6ee8			;		pop af     ; bin this original value now we have calculated form  
6ee8			  
6ee8			.peset:		; set bit  
6ee8 78					ld a, b  
6ee9 32 ce fb				ld (display_lcde1e2), a 	  
6eec 79					ld a, c  
6eed c1					pop bc  
6eee			  
6eee f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6ef0 cd 4f 6e		            CALL fLCD_Inst      ;Write instruction to LCD  
6ef3 f1			            POP  AF  
6ef4 c9			            RET  
6ef5			  
6ef5			  
6ef5			; Output text string to LCD  
6ef5			;   On entry: DE = Pointer to null terminated text string  
6ef5			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6ef5 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6ef6 b7			            OR   A              ;Null terminator?  
6ef7 c8			            RET  Z              ;Yes, so finished  
6ef8 cd 8b 6e		            CALL fLCD_Data      ;Write character to display  
6efb 13			            INC  DE             ;Point to next character  
6efc 18 f7		            JR   fLCD_Str       ;Repeat  
6efe c9					ret  
6eff			  
6eff			; Define custom character  
6eff			;   On entry: A = Character number (0 to 7)  
6eff			;             DE = Pointer to character bitmap data  
6eff			;   On exit:  A = Next character number  
6eff			;             DE = Next location following bitmap  
6eff			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6eff			; Character is   
6eff c5			fLCD_Def:   PUSH BC  
6f00 f5			            PUSH AF  
6f01 07			            RLCA                ;Calculate location  
6f02 07			            RLCA                ;  for bitmap data  
6f03 07			            RLCA                ;  = 8 x CharacterNumber  
6f04 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6f06 cd 4f 6e		            CALL fLCD_Inst      ;Write instruction to LCD  
6f09 06 00		            LD   B, 0  
6f0b 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6f0c cd 8b 6e		            CALL fLCD_Data      ;Write byte to display  
6f0f 13			            INC  DE             ;Point to next byte  
6f10 04			            INC  B              ;Count bytes  
6f11 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6f13 28 f6		            JR   Z, Loop       ;No, so repeat  
6f15 f1			            POP  AF  
6f16 3c			            INC  A              ;Increment character number  
6f17 c1			            POP  BC  
6f18 c9			            RET  
6f19			  
6f19			  
6f19			; **********************************************************************  
6f19			; **  Private functions  
6f19			; **********************************************************************  
6f19			  
6f19			; Write function to LCD  
6f19			;   On entry: A = Function byte to be written  
6f19			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6f19 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6f1b 18 02		            JR   WrFunc  
6f1d 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6f1f f5			WrFunc:     PUSH AF  
6f20 f5					push af  
6f21 3a ce fb				ld a, (display_lcde1e2)  
6f24 fe 00				cp 0     ; e1  
6f26 20 0f				jr nz, .wfea2	  
6f28 f1					pop af  
6f29 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6f2b cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6f2d cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6f2f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6f31 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6f33 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6f35 18 0d			jr .wfskip  
6f37 f1			.wfea2:		pop af  
6f38 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6f3a cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6f3c cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6f3e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6f40 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6f42 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6f44 3e 05		.wfskip:            LD  A, 5  
6f46 cd 4d 6f		            CALL LCDDelay       ;Delay 5 ms to complete  
6f49 f1			            POP  AF  
6f4a c9			            RET  
6f4b			  
6f4b			  
6f4b			; Delay in milliseconds  
6f4b			;   On entry: A = Number of milliseconds delay  
6f4b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6f4b 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6f4d d5			LCDDelay:   PUSH DE  
6f4e 5f			            LD   E, A           ;Delay by 'A' ms  
6f4f 16 00		            LD   D, 0  
6f51 cd 7a 0c		            CALL aDelayInMS  
6f54 d1			            POP  DE  
6f55 c9			            RET  
6f56			  
6f56			  
6f56			testlcd:  
6f56 3e 00			ld a, kLCD_Line1  
6f58 cd d3 6e			call fLCD_Pos  
6f5b 06 28			ld b, 40  
6f5d 11 8b 6f			ld de, .ttext1  
6f60 cd 1e 6e			call write_len_string  
6f63			  
6f63 3e 28			ld a, kLCD_Line2  
6f65 cd d3 6e			call fLCD_Pos  
6f68 06 28			ld b, 40  
6f6a 11 b4 6f			ld de, .ttext2  
6f6d cd 1e 6e			call write_len_string  
6f70 3e 50			ld a, kLCD_Line3  
6f72 cd d3 6e			call fLCD_Pos  
6f75 06 28			ld b, 40  
6f77 11 dd 6f			ld de, .ttext3  
6f7a cd 1e 6e			call write_len_string  
6f7d 3e 78			ld a, kLCD_Line4  
6f7f cd d3 6e			call fLCD_Pos  
6f82 06 28			ld b, 40  
6f84 11 06 70			ld de, .ttext4  
6f87 cd 1e 6e			call write_len_string  
6f8a			  
6f8a 76				halt  
6f8b			  
6f8b			  
6f8b .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6fb4 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6fdd .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7006 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
702f			   
702f			  
702f			  
702f			; eof  
702f			  
# End of file firmware_lcd_4x40.asm
702f			;include "firmware_lcd_4x20.asm" 
702f			include "firmware_key_5x10.asm" 
702f			; 5 x 10 decade counter scanner  
702f			  
702f			  
702f			; TODO do cursor shape change for shift keys  
702f			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
702f			  
702f			  
702f			; bit mask for each scan column and row for teing the matrix  
702f			  
702f			  
702f			key_init:  
702f			  
702f			; SCMonAPI functions used  
702f			  
702f			; Alphanumeric LCD functions used  
702f			; no need to specify specific functions for this module  
702f			  
702f			  
702f 3e cf		            LD   A, 11001111b  
7031 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7033			;            LD   A, 00000000b  
7033 3e 1f		            LD   A, 00011111b  
7035 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7037			  
7037			  
7037				; TODO Configure cursor shapes  
7037			  
7037				; Load cursor shapes   
7037 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7039 11 49 70		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
703c 06 02		            LD   B, 2           ;Number of characters to define  
703e cd ff 6e		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7041 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7043			  
7043 3e 01				ld a, 1  
7045 32 c7 fb			ld (cursor_shape),a  
7048 c9				ret  
7049			  
7049			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7049			; Up to 8 custom characters can be defined  
7049			.cursor_shapes:      
7049			;; Character 0x00 = Normal  
7049 1f			            DB  11111b  
704a 1f			            DB  11111b  
704b 1f			            DB  11111b  
704c 1f			            DB  11111b  
704d 1f			            DB  11111b  
704e 1f			            DB  11111b  
704f 1f			            DB  11111b  
7050 1f			            DB  11111b  
7051			;; Character 0x01 = Modifier  
7051 1f			            DB  11111b  
7052 1b			            DB  11011b  
7053 1b			            DB  11011b  
7054 1b			            DB  11011b  
7055 1b			            DB  11011b  
7056 1f			            DB  11111b  
7057 1b			            DB  11011b  
7058 1f			            DB  11111b  
7059			  
7059			  
7059			  
7059			  
7059			; Display custom character 0  
7059			;            LD   A, kLCD_Line1+14  
7059			;            CALL fLCD_Pos       ;Position cursor to location in A  
7059			;            LD   A, 0  
7059			;            CALL fLCD_Data      ;Write character in A at cursor  
7059			  
7059			; Display custom character 1  
7059			;            LD   A, kLCD_Line2+14  
7059			;            CALL fLCD_Pos      ;Position cursor to location in A  
7059			;            LD   A, 1  
7059			;            CALL fLCD_Data     ;Write character in A at cursor  
7059			  
7059			; keyboard scanning   
7059			  
7059			; character in from keyboard  
7059			  
7059			; mapping for the pcb layout  
7059			  
7059			.matrix_to_char:  
7059 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7064 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
706f 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
707a 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7085 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7090			.matrix_to_shift:  
7090			  
7090 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
709b .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
70a6 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
70b1 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
70bc .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
70c7			  
70c7			.matrix_to_symbolshift:  
70c7			  
70c7 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
70d2 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
70dd 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
70e8			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
70e8 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
70f3 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
70fe			  
70fe			  
70fe			  
70fe			; mapping for a simple straight through breadboard layout  
70fe			  
70fe			;.matrix_to_char:  
70fe			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
70fe			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
70fe			;		db "asdfghjkl",KEY_CR,0  
70fe			;		db "qwertyuiop",0  
70fe			;		 db "1234567890",0  
70fe			;.matrix_to_shift:  
70fe			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
70fe			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
70fe			;		db "ASDFGHJKL",KEY_CR,0  
70fe			;		db "QWERTYUIOP",0  
70fe			;		 db "!",'"',"#$%^&*()",0  
70fe			;.matrix_to_symbolshift:  
70fe			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
70fe			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
70fe			;		db "_?*fghjk=",KEY_CR,0  
70fe			;		db "-/+*[]{}@#",0  
70fe			;		 db "1234567890",0  
70fe			  
70fe			;.matrix_to_char: db "D#0*C987B654A321"  
70fe			  
70fe			  
70fe				  
70fe			  
70fe			; add cin and cin_wait  
70fe			  
70fe cd 0f 71		cin_wait: 	call cin  
7101						if DEBUG_KEYCINWAIT  
7101							push af  
7101							  
7101							ld hl,key_repeat_ct  
7101							ld (hl),a  
7101							inc hl  
7101							call hexout  
7101							ld hl,key_repeat_ct+3  
7101							ld a,0  
7101							ld (hl),a  
7101			  
7101							    LD   A, kLCD_Line1+11  
7101							    CALL fLCD_Pos       ;Position cursor to location in A  
7101							    LD   DE, key_repeat_ct  
7101							    ;LD   DE, MsgHello  
7101							    CALL fLCD_Str       ;Display string pointed to by DE  
7101			  
7101			  
7101			  
7101							pop af  
7101						endif  
7101 fe 00			cp 0  
7103 28 f9			jr z, cin_wait   ; block until key press  
7105			  
7105							if DEBUG_KEYCINWAIT  
7105								push af  
7105			  
7105								ld a, 'A'	  
7105								ld hl,key_repeat_ct  
7105								ld (hl),a  
7105								inc hl  
7105								ld a,0  
7105								ld (hl),a  
7105			  
7105								    LD   A, kLCD_Line2+11  
7105								    CALL fLCD_Pos       ;Position cursor to location in A  
7105								    LD   DE, key_repeat_ct  
7105								    ;LD   DE, MsgHello  
7105								    CALL fLCD_Str       ;Display string pointed to by DE  
7105			  
7105							call delay500ms  
7105			  
7105								pop af  
7105							endif  
7105 f5				push af   ; save key pressed  
7106			  
7106			.cin_wait1:	  
7106							if DEBUG_KEYCINWAIT  
7106								push af  
7106			  
7106								ld a, 'b'	  
7106								ld hl,key_repeat_ct  
7106								ld (hl),a  
7106								inc hl  
7106								ld a,0  
7106								ld (hl),a  
7106			  
7106								    LD   A, kLCD_Line2+11  
7106								    CALL fLCD_Pos       ;Position cursor to location in A  
7106								    LD   DE, key_repeat_ct  
7106								    ;LD   DE, MsgHello  
7106								    CALL fLCD_Str       ;Display string pointed to by DE  
7106			  
7106			  
7106							call delay500ms  
7106			  
7106								pop af  
7106							endif  
7106			  
7106 cd 0f 71		call cin  
7109 fe 00			cp 0  
710b 20 f9			jr nz, .cin_wait1  	; wait for key release  
710d			if DEBUG_KEYCINWAIT  
710d				push af  
710d			  
710d				ld a, '3'	  
710d				ld hl,key_repeat_ct  
710d				ld (hl),a  
710d				inc hl  
710d				ld a,0  
710d				ld (hl),a  
710d			  
710d			            LD   A, kLCD_Line2+11  
710d			            CALL fLCD_Pos       ;Position cursor to location in A  
710d			            LD   DE, key_repeat_ct  
710d			            ;LD   DE, MsgHello  
710d			            CALL fLCD_Str       ;Display string pointed to by DE  
710d			  
710d			  
710d			call delay500ms  
710d			  
710d				pop af  
710d			endif  
710d			  
710d f1				pop af   ; get key  
710e c9				ret  
710f			  
710f			  
710f cd 23 71		cin: 	call .mtoc  
7112			  
7112			if DEBUG_KEYCIN  
7112				push af  
7112				  
7112				ld hl,key_repeat_ct  
7112				ld (hl),a  
7112				inc hl  
7112				call hexout  
7112				ld hl,key_repeat_ct+3  
7112				ld a,0  
7112				ld (hl),a  
7112			  
7112			            LD   A, kLCD_Line3+15  
7112			            CALL fLCD_Pos       ;Position cursor to location in A  
7112			            LD   DE, key_repeat_ct  
7112			            ;LD   DE, MsgHello  
7112			            CALL fLCD_Str       ;Display string pointed to by DE  
7112			  
7112			  
7112			call delay500ms  
7112			  
7112				pop af  
7112			endif  
7112			  
7112			  
7112				; no key held  
7112 fe 00			cp 0  
7114 c8				ret z  
7115			  
7115			if DEBUG_KEYCIN  
7115				push af  
7115			  
7115				ld a, '1'	  
7115				ld hl,key_repeat_ct  
7115				ld (hl),a  
7115				inc hl  
7115				ld a,0  
7115				ld (hl),a  
7115			  
7115			            LD   A, kLCD_Line4+15  
7115			            CALL fLCD_Pos       ;Position cursor to location in A  
7115			            LD   DE, key_repeat_ct  
7115			            ;LD   DE, MsgHello  
7115			            CALL fLCD_Str       ;Display string pointed to by DE  
7115			  
7115			  
7115			call delay500ms  
7115			  
7115				pop af  
7115			endif  
7115			  
7115				; stop key bounce  
7115			  
7115 32 88 fe			ld (key_held),a		 ; save it  
7118 47				ld b, a  
7119			  
7119 c5			.cina1:	push bc  
711a			if DEBUG_KEYCIN  
711a				push af  
711a			  
711a				ld hl,key_repeat_ct  
711a				inc hl  
711a				call hexout  
711a				ld hl,key_repeat_ct+3  
711a				ld a,0  
711a				ld (hl),a  
711a				ld hl,key_repeat_ct  
711a				ld a, '2'	  
711a				ld (hl),a  
711a			  
711a			            LD   A, kLCD_Line4+15  
711a			            CALL fLCD_Pos       ;Position cursor to location in A  
711a			            LD   DE, key_repeat_ct  
711a			            ;LD   DE, MsgHello  
711a			            CALL fLCD_Str       ;Display string pointed to by DE  
711a			  
711a				pop af  
711a			endif  
711a cd 23 71			call .mtoc  
711d c1				pop bc  
711e b8				cp b  
711f 28 f8			jr z, .cina1  
7121 78				ld a,b		  
7122			if DEBUG_KEYCIN  
7122				push af  
7122			  
7122				ld hl,key_repeat_ct  
7122				inc hl  
7122				call hexout  
7122				ld hl,key_repeat_ct+3  
7122				ld a,0  
7122				ld (hl),a  
7122				ld hl,key_repeat_ct  
7122				ld a, '3'	  
7122				ld (hl),a  
7122			  
7122			            LD   A, kLCD_Line4+15  
7122			            CALL fLCD_Pos       ;Position cursor to location in A  
7122			            LD   DE, key_repeat_ct  
7122			            ;LD   DE, MsgHello  
7122			            CALL fLCD_Str       ;Display string pointed to by DE  
7122			  
7122				pop af  
7122			endif  
7122 c9				ret  
7123			  
7123			; detect keyboard modifier key press and apply new overlay to the face key held  
7123			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7123			  
7123			;.cin_map_modifier:   
7123			;	ld a, (hl)  
7123			;	and 255  
7123			;	ret NZ		; modifier key not flagged  
7123			;  
7123			;	; get key face  
7123			;  
7123			;	ld b,(key_face_held)  
7123			;  
7123			;	ld b, key_cols * key_rows  
7123			;  
7123			;	push de  
7123			;	pop hl  
7123			;  
7123			;.mmod1: ld a,(hl)   ; get map test  
7123			;	cp b  
7123			;	jr z, .mmod2  
7123			;  
7123			;  
7123			;  
7123			;.mmod2: inc hl    ;   
7123			;  
7123			;	  
7123			;  
7123			;	  
7123			;  
7123			;	ld hl,key_actual_pressed  
7123			;	ld (hl),a,  
7123			;	ret  
7123			  
7123			; map matrix key held to char on face of key  
7123			  
7123			.mtoc:  
7123			  
7123			; test decade counter strobes  
7123			  
7123			;.decadetest1:  
7123			  
7123			; reset counter  
7123			;ld a, 128  
7123			;out (portbdata),a  
7123			  
7123			  
7123			;ld b, 5  
7123			;.dec1:  
7123			;ld a, 0  
7123			;out (portbdata),a  
7123			;call delay1s  
7123			  
7123			;ld a, 32  
7123			;out (portbdata),a  
7123			;call delay1s  
7123			;call delay1s  
7123			;call delay1s  
7123			;  
7123			;ld a, 64+32  
7123			;out (portbdata),a  
7123			;call delay1s  
7123			;;djnz .dec1  
7123			;  
7123			;jp .decadetest1  
7123			  
7123			  
7123			  
7123			  
7123			  
7123			  
7123			  
7123			  
7123			  
7123			  
7123				; scan keyboard matrix and generate raw scan map  
7123 cd b6 71			call matrix  
7126			  
7126				; reuse c bit 0 left modifer button - ie shift  
7126			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7126				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7126			  
7126 0e 00			ld c, 0  
7128			  
7128				; TODO set flags for modifer key presses   
7128				; TODO do a search for modifer key...  
7128			  
7128				;ld hl,keyscan_table_row4  
7128 21 e7 fe			ld hl,keyscan_table_row2  
712b			  
712b 7e				ld a, (hl)  
712c fe 23			cp '#'  
712e 20 07			jr nz, .nextmodcheck  
7130 cb c1			set 0, c  
7132 21 90 70			ld hl, .matrix_to_shift  
7135 18 21			jr .dokeymap  
7137				; TODO for now igonre  
7137			.nextmodcheck:  
7137 21 dc fe			ld hl,keyscan_table_row3  
713a			  
713a 7e				ld a, (hl)  
713b fe 23			cp '#'  
713d 20 07			jr nz, .nextmodcheck2  
713f cb c9			set 1, c   
7141 21 c7 70			ld hl, .matrix_to_symbolshift  
7144 18 12			jr .dokeymap  
7146			.nextmodcheck2:  
7146 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7149			  
7149 7e				ld a, (hl)  
714a fe 23			cp '#'  
714c 20 07			jr nz, .donemodcheck  
714e cb c9			set 1, c   
7150 21 90 70			ld hl, .matrix_to_shift  
7153 18 03			jr .dokeymap  
7155			  
7155				; no modifer found so just map to normal keys  
7155				; get mtoc map matrix to respective keys  
7155			;	ld hl, .matrix_to_char  
7155			;	ld hl, .matrix_to_char  
7155			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7155			;	ld a, KEY_SHIFT  
7155			;	call findchar  
7155			;  
7155			;	; got offset to key modifer in b  
7155			;  
7155			;	ld hl,keyscan_table_row5  
7155			;  
7155			;	ld a,b  
7155			;	call addatohl  
7155			;	ld a,(hl)  
7155			;  
7155			;	cp '#'  
7155			;	jr nz, .nextmodcheck  
7155			;	set 0, c  
7155			;	ld hl, .matrix_to_char  
7155			;	jr .dokeymap  
7155			;	; TODO for now igonre  
7155			;.nextmodcheck:  
7155			;	ld hl, .matrix_to_symbolshift  
7155			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7155			;	ld a, KEY_SYMBOLSHIFT  
7155			;	call findchar  
7155			;  
7155			;  
7155			;	; got offset to key modifer in b  
7155			;  
7155			;	ld hl,keyscan_table_row5  
7155			;  
7155			;	ld a,b  
7155			;	call addatohl  
7155			;	ld a,(hl)  
7155			;  
7155			;	cp '#'  
7155			;	jr nz, .donemodcheck  
7155			;	set 1, c   
7155			;	ld hl, .matrix_to_symbolshift  
7155			;	jr .dokeymap  
7155			  
7155			  
7155			  
7155			.donemodcheck:  
7155				; no modifer found so just map to normal keys  
7155				; get mtoc map matrix to respective keys  
7155 21 59 70			ld hl, .matrix_to_char  
7158			  
7158			.dokeymap:  
7158				;ld (key_fa), c   
7158 cd 71 71			call .mapkeys  
715b			  
715b			  
715b			if DEBUG_KEY  
715b			  
715b			; Display text on first line  
715b			            LD   A, kLCD_Line1  
715b			            CALL fLCD_Pos       ;Position cursor to location in A  
715b			            LD   DE, keyscan_table_row1  
715b			            ;LD   DE, MsgHello  
715b			            CALL fLCD_Str       ;Display string pointed to by DE  
715b			  
715b			; Display text on second line  
715b			            LD   A, kLCD_Line2  
715b			            CALL fLCD_Pos       ;Position cursor to location in A  
715b			            LD   DE, keyscan_table_row2  
715b			            CALL fLCD_Str       ;Display string pointed to by DE  
715b			            LD   A, kLCD_Line3  
715b			            CALL fLCD_Pos       ;Position cursor to location in A  
715b			            LD   DE, keyscan_table_row3  
715b			            CALL fLCD_Str       ;Display string pointed to by DE  
715b			            LD   A, kLCD_Line4  
715b			            CALL fLCD_Pos       ;Position cursor to location in A  
715b			            LD   DE, keyscan_table_row4  
715b			            CALL fLCD_Str       ;Display string pointed to by DE  
715b			            LD   A, kLCD_Line1+10  
715b			            CALL fLCD_Pos       ;Position cursor to location in A  
715b			            LD   DE, keyscan_table_row5  
715b			            CALL fLCD_Str       ;Display string pointed to by DE  
715b			  
715b				;call delay250ms  
715b			endif  
715b			;	jp testkey  
715b			  
715b			; get first char reported  
715b			  
715b 21 c6 fe			ld hl,keyscan_table_row5  
715e			  
715e				;ld b, 46   ; 30 keys to remap + 8 nulls   
715e 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7160			.findkey:  
7160 7e				ld a,(hl)  
7161 fe 00			cp 0  
7163 28 04			jr z, .nextkey  
7165 fe 7e			cp KEY_MATRIX_NO_PRESS  
7167 20 06			jr nz, .foundkey  
7169			.nextkey:  
7169 23				inc hl  
716a 10 f4			djnz .findkey  
716c 3e 00			ld a,0  
716e c9				ret  
716f			.foundkey:  
716f 7e				ld a,(hl)  
7170 c9				ret  
7171				  
7171			  
7171			; convert the raw key map given hl for destination key  
7171			.mapkeys:  
7171 11 c6 fe			ld de,keyscan_table_row5  
7174			  
7174 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7176			.remap:  
7176 1a				ld a,(de)  
7177 fe 23			cp '#'  
7179 20 02			jr nz, .remapnext  
717b				;CALLMONITOR  
717b 7e				ld a,(hl)  
717c 12				ld (de),a  
717d			  
717d			  
717d			  
717d			.remapnext:  
717d 23				inc hl  
717e 13				inc de  
717f 10 f5			djnz .remap  
7181				  
7181 c9				ret  
7182			  
7182			  
7182			  
7182			.mtocold2:  
7182			  
7182			;	; flag if key D is held down and remove from reporting  
7182			;	ld bc, .key_map_fd    
7182			;	ld hl, keyscan_table  
7182			;	ld de, key_fd  
7182			;	call .key_shift_hold  
7182			;	cp 255  
7182			;	jr z, .cinmap  
7182			;	; flag if key C is held down and remove from reporting  
7182			;	ld bc, .key_map_fc    
7182			;	ld hl, keyscan_table+key_cols  
7182			;	ld de, key_fc  
7182			;	call .key_shift_hold  
7182			;	cp 255  
7182			;	jr z, .cinmap  
7182			;	; flag if key B is held down and remove from reporting  
7182			;	ld bc, .key_map_fb    
7182			;	ld hl, keyscan_table+(key_cols*2)  
7182			;	ld de, key_fb  
7182			;	call .key_shift_hold  
7182			;	cp 255  
7182			;	jr z, .cinmap  
7182			;	; flag if key A is held down and remove from reporting  
7182			;	ld bc, .key_map_fa    
7182			;	ld hl, keyscan_table+(key_cols*3)  
7182			;	ld de, key_fa  
7182			;	call .key_shift_hold  
7182			;	cp 255  
7182			;	jr z, .cinmap  
7182			  
7182 11 59 70			ld de, .matrix_to_char  
7185			  
7185			  
7185			.cinmap1:   
7185				if DEBUG_KEY  
7185			            LD   A, kLCD_Line4  
7185			            CALL fLCD_Pos       ;Position cursor to location in A  
7185					push de  
7185			            LD   DE, keyscan_table  
7185			            CALL fLCD_Str       ;Display string pointed to by DE  
7185					pop de  
7185				endif  
7185			  
7185				; scan key matrix table for any held key  
7185			  
7185				; de holds either the default matrix or one selected above  
7185			  
7185 21 93 fe			ld hl, keyscan_table  
7188 06 32			ld b,key_cols*key_rows  
718a			  
718a 7e			.cin11:	ld a,(hl)  
718b fe 23			cp '#'  
718d 28 08			jr z, .cinhit1  
718f 23				inc hl  
7190 13				inc de  
7191 05				dec b  
7192 20 f6			jr nz, .cin11  
7194				; no key found held  
7194 3e 00			ld a,0  
7196 c9				ret  
7197 d5			.cinhit1: push de  
7198 e1				pop hl  
7199 7e				ld a,(hl)  
719a c9				ret  
719b			  
719b			; flag a control key is held   
719b			; hl is key pin, de is flag indicator  
719b			  
719b			.key_shift_hold1:  
719b c5				push bc  
719c 3e 01			ld a, 1  
719e 32 c7 fb			ld (cursor_shape),a  
71a1 06 00			ld b, 0  
71a3 7e				ld a, (hl)  
71a4 fe 2e			cp '.'  
71a6 28 0a			jr z, .key_shift11  
71a8 06 ff			ld b, 255  
71aa 3e 2b			ld a, '+'    ; hide key from later scans  
71ac 77				ld (hl),a  
71ad 3e 02			ld a, 2  
71af 32 c7 fb			ld (cursor_shape),a  
71b2			.key_shift11:  
71b2				; write flag indicator  
71b2 78				ld a,b  
71b3 12				ld (de),a  
71b4			  
71b4 d1				pop de    ; de now holds the key map ptr  
71b5 c9				ret  
71b6			  
71b6				  
71b6			  
71b6			; scans keyboard matrix and flags key press in memory array	  
71b6				  
71b6			matrix:  
71b6				;call matrix  
71b6				; TODO optimise the code....  
71b6			  
71b6			  
71b6			;ld hl, keyscan_table_row1  
71b6			;ld de, keyscan_table_row1+1  
71b6			;ld bc,46  
71b6			;ld a,KEY_MATRIX_NO_PRESS  
71b6			;ldir  
71b6			  
71b6			  
71b6			  
71b6			; reset counter  
71b6 3e 80		ld a, 128  
71b8 d3 c1		out (portbdata),a  
71ba			  
71ba 06 0a		ld b, 10  
71bc 0e 00		ld c, 0       ; current clock toggle  
71be			  
71be			.colscan:  
71be			  
71be			; set current column  
71be			; disable clock enable and set clock low  
71be			  
71be			;ld a, 0  
71be			;out (portbdata),a  
71be			  
71be			; For each column scan for switches  
71be			  
71be c5			push bc  
71bf 21 89 fe		ld hl, keyscan_scancol  
71c2 cd cb 72		call .rowscan  
71c5 c1			pop bc  
71c6			  
71c6			  
71c6			; get back current column  
71c6			  
71c6			; translate the row scan  
71c6			  
71c6			;   
71c6			; row 1  
71c6			  
71c6 78			ld a,b  
71c7			  
71c7 21 fc fe		LD   hl, keyscan_table_row1+10  
71ca			  
71ca cd 5e 0f		call subafromhl  
71cd			;call addatohl  
71cd			  
71cd 11 89 fe		ld de, keyscan_scancol  
71d0			  
71d0 1a			ld a,(de)  
71d1 77			ld (hl),a  
71d2			  
71d2			  
71d2			  
71d2			  
71d2			; row 2  
71d2			  
71d2 78			ld a,b  
71d3			  
71d3 21 f1 fe		LD   hl, keyscan_table_row2+10  
71d6			  
71d6			;call addatohl  
71d6 cd 5e 0f		call subafromhl  
71d9			  
71d9			  
71d9 11 8a fe		ld de, keyscan_scancol+1  
71dc			  
71dc 1a			ld a,(de)  
71dd 77			ld (hl),a  
71de			  
71de			  
71de			; row 3  
71de			  
71de 78			ld a,b  
71df			  
71df 21 e6 fe		LD   hl, keyscan_table_row3+10  
71e2			  
71e2			;call addatohl  
71e2 cd 5e 0f		call subafromhl  
71e5			  
71e5 11 8b fe		ld de, keyscan_scancol+2  
71e8			  
71e8 1a			ld a,(de)  
71e9 77			ld (hl),a  
71ea			  
71ea			  
71ea			  
71ea			; row 4  
71ea			  
71ea 78			ld a,b  
71eb			  
71eb 21 db fe		LD   hl, keyscan_table_row4+10  
71ee			  
71ee			;call addatohl  
71ee cd 5e 0f		call subafromhl  
71f1			  
71f1 11 8c fe		ld de, keyscan_scancol+3  
71f4			  
71f4 1a			ld a,(de)  
71f5 77			ld (hl),a  
71f6			  
71f6			; row 5  
71f6			  
71f6 78			ld a,b  
71f7			  
71f7 21 d0 fe		LD   hl, keyscan_table_row5+10  
71fa			  
71fa			;call addatohl  
71fa cd 5e 0f		call subafromhl  
71fd			  
71fd 11 8d fe		ld de, keyscan_scancol+4  
7200			  
7200 1a			ld a,(de)  
7201 77			ld (hl),a  
7202			  
7202			; handshake next column  
7202			  
7202			  
7202 3e 40		ld a, 64  
7204 d3 c1		out (portbdata),a  
7206			  
7206 3e 00		ld a, 0  
7208 d3 c1		out (portbdata),a  
720a			  
720a			; toggle clk and move to next column  
720a			;ld a, 64  
720a			;cp c  
720a			;  
720a			;jr z, .coltoglow  
720a			;ld c, a  
720a			;jr .coltog  
720a			;.coltoglow:  
720a			;ld c, 0  
720a			;.coltog:  
720a			;ld a, c  
720a			;out (portbdata),a  
720a			  
720a 10 b2		djnz .colscan  
720c			  
720c 3e 0a		ld a,10  
720e 21 f2 fe		LD   hl, keyscan_table_row1  
7211 cd 4c 0f		call addatohl  
7214 3e 00		ld a, 0  
7216 77			ld (hl), a  
7217			  
7217			  
7217 3e 0a		ld a,10  
7219 21 e7 fe		LD   hl, keyscan_table_row2  
721c cd 4c 0f		call addatohl  
721f 3e 00		ld a, 0  
7221 77			ld (hl), a  
7222			  
7222 3e 0a		ld a,10  
7224 21 dc fe		LD   hl, keyscan_table_row3  
7227 cd 4c 0f		call addatohl  
722a 3e 00		ld a, 0  
722c 77			ld (hl), a  
722d			  
722d 3e 0a		ld a,10  
722f 21 d1 fe		LD   hl, keyscan_table_row4  
7232 cd 4c 0f		call addatohl  
7235 3e 00		ld a, 0  
7237 77			ld (hl), a  
7238			  
7238 3e 0a		ld a,10  
723a 21 c6 fe		LD   hl, keyscan_table_row5  
723d cd 4c 0f		call addatohl  
7240 3e 00		ld a, 0  
7242 77			ld (hl), a  
7243			  
7243			if DEBUG_KEY_MATRIX  
7243			  
7243			; Display text on first line  
7243			            LD   A, kLCD_Line1  
7243			            CALL fLCD_Pos       ;Position cursor to location in A  
7243			            LD   DE, keyscan_table_row1  
7243			            ;LD   DE, MsgHello  
7243			            CALL fLCD_Str       ;Display string pointed to by DE  
7243			  
7243			; Display text on second line  
7243			            LD   A, kLCD_Line2  
7243			            CALL fLCD_Pos       ;Position cursor to location in A  
7243			            LD   DE, keyscan_table_row2  
7243			            CALL fLCD_Str       ;Display string pointed to by DE  
7243			            LD   A, kLCD_Line3  
7243			            CALL fLCD_Pos       ;Position cursor to location in A  
7243			            LD   DE, keyscan_table_row3  
7243			            CALL fLCD_Str       ;Display string pointed to by DE  
7243			            LD   A, kLCD_Line4  
7243			            CALL fLCD_Pos       ;Position cursor to location in A  
7243			            LD   DE, keyscan_table_row4  
7243			            CALL fLCD_Str       ;Display string pointed to by DE  
7243			            LD   A, kLCD_Line4+10  
7243			            CALL fLCD_Pos       ;Position cursor to location in A  
7243			            LD   DE, keyscan_table_row5  
7243			            CALL fLCD_Str       ;Display string pointed to by DE  
7243			  
7243			;call delay250ms  
7243				jp matrix  
7243			endif  
7243 c9			ret  
7244			  
7244			; using decade counter....  
7244			  
7244			  
7244			; TODO reset decade counter to start of scan  
7244			  
7244			; reset 15  
7244			; clock 14  
7244			; ce 13  
7244			  
7244			; 1 - q5  
7244			; 2 - q1  
7244			; 3 - q0  
7244			; 4 - q2  
7244			; 5 - q6  
7244			; 6 - q7  
7244			; 7 - q3  
7244			; 8 - vss  
7244			; 9 - q8  
7244			; 10 - q4  
7244			; 11 - q9  
7244			; 12 - cout  
7244			; 16 - vdd  
7244			  
7244			; clock      ce       reset     output  
7244			; 0          x        0         n  
7244			; x          1        0         n  
7244			; x          x        1         q0  
7244			; rising     0        0         n+1  
7244			; falling    x        0         n  
7244			; x          rising   0         n  
7244			; 1          falling  0         x+1  
7244			;  
7244			; x = dont care, if n < 5 carry = 1 otherwise 0  
7244			  
7244			;   
7244			; reset   
7244			; 13=0, 14=0, 15=1 .. 15=0  
7244			;  
7244			; handshake line  
7244			; 14=1.... read line 14=0  
7244			  
7244			  
7244			  
7244			  
7244			  
7244			; TODO hand shake clock for next column scan  
7244			; TODO detect each row  
7244			  
7244			  
7244			  
7244			  
7244			; reset 128  
7244			; clock 64  
7244			; ce 32  
7244			  
7244			  
7244			.cyclestart:  
7244			  
7244			; reset counter  
7244 3e 80		ld a, 128  
7246 d3 c1		out (portbdata),a  
7248			  
7248			; loop leds  
7248 06 0a		ld b,10  
724a			  
724a			.cycle1:  
724a c5			push bc  
724b 3e 00		ld a, 0  
724d d3 c1		out (portbdata),a  
724f cd 89 0c		call delay250ms  
7252			  
7252 3e 40		ld a, 64  
7254 d3 c1		out (portbdata),a  
7256 cd 89 0c		call delay250ms  
7259			  
7259 3e 00		ld a, 0  
725b d3 c1		out (portbdata),a  
725d cd 89 0c		call delay250ms  
7260			  
7260 c1			pop bc  
7261 10 e7		djnz .cycle1  
7263			  
7263			  
7263 18 df		jr .cyclestart  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			; map matrix key held to char on face of key  
7265			  
7265			;.mtocold:  
7265			;  
7265			;  
7265			;; reset counter  
7265			;ld a, 128  
7265			;out (portbdata),a  
7265			;  
7265			;  
7265			;; scan keyboard row 1  
7265			;ld a, 0  
7265			;out (portbdata),a  
7265			;;ld a, 64  
7265			;;out (portbdata),a  
7265			;  
7265			;  
7265			;	ld a, 128  
7265			;	ld hl, keyscan_table  
7265			;	call .rowscan  
7265			;  
7265			;;ld a, 0  
7265			;;out (portbdata),a  
7265			;ld a, 64  
7265			;out (portbdata),a  
7265			;  
7265			;	ld a, 64  
7265			;	ld hl, keyscan_table+key_cols  
7265			;	call .rowscan  
7265			;  
7265			;ld a, 0  
7265			;out (portbdata),a  
7265			;;ld a, 64  
7265			;;out (portbdata),a  
7265			;	ld a, 32  
7265			;	ld hl, keyscan_table+(key_cols*2)  
7265			;	call .rowscan  
7265			;  
7265			;  
7265			;;ld a, 0  
7265			;;out (portbdata),a  
7265			;ld a, 64  
7265			;out (portbdata),a  
7265			;  
7265			;	ld a, 16  
7265			;	ld hl, keyscan_table+(key_cols*3)  
7265			;	call .rowscan  
7265			;  
7265			;  
7265			;	; flag if key D is held down and remove from reporting  
7265			;	ld bc, .key_map_fd    
7265			;	ld hl, keyscan_table  
7265			;	ld de, key_fd  
7265			;	call .key_shift_hold  
7265			;	cp 255  
7265			;	jr z, .cinmap  
7265			;	; flag if key C is held down and remove from reporting  
7265			;	ld bc, .key_map_fc    
7265			;	ld hl, keyscan_table+key_cols  
7265			;	ld de, key_fc  
7265			;	call .key_shift_hold  
7265			;	cp 255  
7265			;	jr z, .cinmap  
7265			;	; flag if key B is held down and remove from reporting  
7265			;	ld bc, .key_map_fb    
7265			;	ld hl, keyscan_table+(key_cols*2)  
7265			;	ld de, key_fb  
7265			;	call .key_shift_hold  
7265			;	cp 255  
7265			;	jr z, .cinmap  
7265			;	; flag if key A is held down and remove from reporting  
7265			;	ld bc, .key_map_fa    
7265			;	ld hl, keyscan_table+(key_cols*3)  
7265			;	ld de, key_fa  
7265			;	call .key_shift_hold  
7265			;	cp 255  
7265			;	jr z, .cinmap  
7265			;  
7265			;	ld de, .matrix_to_char  
7265			;  
7265			;  
7265			;.cinmap:   
7265			;	if DEBUG_KEY  
7265			;            LD   A, kLCD_Line4  
7265			;            CALL fLCD_Pos       ;Position cursor to location in A  
7265			;		push de  
7265			;            LD   DE, keyscan_table  
7265			;            CALL fLCD_Str       ;Display string pointed to by DE  
7265			;		pop de  
7265			;	endif  
7265			  
7265				; scan key matrix table for any held key  
7265			  
7265				; de holds either the default matrix or one selected above  
7265			  
7265			;	ld hl, keyscan_table  
7265			;	ld b,key_cols*key_rows  
7265			;  
7265			;.cin1:	ld a,(hl)  
7265			;	cp '#'  
7265			;	jr z, .cinhit  
7265			;	inc hl  
7265			;	inc de  
7265			;	dec b  
7265			;	jr nz, .cin1  
7265			;	; no key found held  
7265			;	ld a,0  
7265			;	ret  
7265			;.cinhit: push de  
7265			;	pop hl  
7265			;	ld a,(hl)  
7265			;	ret  
7265			  
7265			; flag a control key is held   
7265			; hl is key pin, de is flag indicator  
7265			  
7265			;.key_shift_hold:  
7265			;	push bc  
7265			;	ld a, 1  
7265			;	ld (cursor_shape),a  
7265			;	ld b, 0  
7265			;	ld a, (hl)  
7265			;	cp '.'  
7265			;	jr z, .key_shift1  
7265			;	ld b, 255  
7265			;	ld a, '+'    ; hide key from later scans  
7265			;	ld (hl),a  
7265			;	ld a, 2  
7265			;	ld (cursor_shape),a  
7265			;.key_shift1:  
7265			;	; write flag indicator  
7265			;	ld a,b  
7265			;	ld (de),a  
7265			;  
7265			;	pop de    ; de now holds the key map ptr  
7265			;	ret  
7265			  
7265				  
7265				  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			  
7265			;	push hl  
7265			;	push de  
7265			;	push bc  
7265			;	call keyscan  
7265			;	; map key matrix to ascii value of key face  
7265			;  
7265			;	ld hl, key_face_map  
7265			;	ld de, keyscan_table  
7265			;  
7265			;	; get how many keys to look at  
7265			;	ld b, keyscan_table_len  
7265			;	  
7265			;  
7265			;	; at this stage fall out on first key hit  
7265			;	; TODO handle multiple key press  
7265			;  
7265			;map1:	ld a,(hl)  
7265			;	cp '#'  
7265			;	jr z, keyhit  
7265			;	inc hl  
7265			;	inc de  
7265			;	dec b  
7265			;	jr nz, map1  
7265			;nohit:	ld a, 0  
7265			;	jr keydone  
7265			;keyhit: push de  
7265			;	pop hl  
7265			;	ld a,(hl)  
7265			;keydone:  
7265			;	push bc  
7265			;	push de  
7265			; 	push hl  
7265			;	ret   
7265			;  
7265			  
7265			  
7265			  
7265			  
7265			; scan physical key matrix  
7265			  
7265			  
7265			;keyscan:  
7265			;  
7265			;; for each key_row use keyscanr bit mask for out  
7265			;; then read in for keyscanc bitmask  
7265			;; save result of row scan to keyscantable  
7265			;  
7265			;; scan keyboard row 1  
7265			;  
7265			;	ld b, key_rows  
7265			;	ld hl, key_scanr  
7265			;	ld de, keyscan_table  
7265			;  
7265			;rowloop:  
7265			;  
7265			;	ld a,(hl)		; out bit mask to energise keyboard row  
7265			;	call rowscan  
7265			;	inc hl  
7265			;	dec b  
7265			;	jr nz, rowloop  
7265			;  
7265			;	ret  
7265			;  
7265			;  
7265			;; pass a out bitmask, b row number  
7265			;arowscan:   
7265			;	push bc  
7265			;  
7265			;	ld d, b  
7265			;  
7265			;	; calculate buffer location for this row  
7265			;  
7265			;	ld hl, keyscan_table	  
7265			;kbufr:  ld e, key_cols  
7265			;kbufc:	inc hl  
7265			;	dec e  
7265			;	jr nz, kbufc  
7265			;	dec d  
7265			;	jr nz, kbufr  
7265			;  
7265			;	; energise row and read columns  
7265			;  
7265			;	out (portbdata),a  
7265			;	in a,(portbdata)  
7265			;	ld c,a  
7265			;  
7265			;  
7265			;	; save buffer loc  
7265			;  
7265			;	ld (keybufptr), hl  
7265			;  
7265			;	ld hl, key_scanc  
7265			;	ld d, key_cols  
7265			;  
7265			;	; for each column check each bit mask  
7265			;  
7265			;colloop:  
7265			;	  
7265			;  
7265			;	; reset flags for the row   
7265			;  
7265			;	ld b,'.'  
7265			;	and (hl)  
7265			;	jr z, maskskip  
7265			;	ld b,'#'  
7265			;maskskip:  
7265			;	; save  key state  
7265			;	push hl  
7265			;	ld hl, (keybufptr)  
7265			;	ld (hl), b  
7265			;	inc hl  
7265			;	ld (keybufptr), hl  
7265			;  
7265			;	; move to next bit mask  
7265			;	pop hl  
7265			;	inc hl  
7265			;  
7265			;	dec d  
7265			;	jr nz, colloop  
7265			;  
7265			;	ret  
7265			;  
7265			;  
7265			;;  
7265			; lcd functions  
7265			;  
7265			;  
7265			  
7265			;if DEBUG_KEY_MATRIX  
7265			  
7265			; test function to display hardware view of matrix state  
7265			  
7265			matrixold:  
7265			  
7265			  
7265			  
7265			; reset counter  
7265 3e 80		ld a, 128  
7267 d3 c1		out (portbdata),a  
7269			; scan keyboard row 1  
7269 3e 00		ld a, 0  
726b d3 c1		out (portbdata),a  
726d			;ld a, 64  
726d			;out (portbdata),a  
726d 3e 80			ld a, 128  
726f 21 f2 fe			ld hl, keyscan_table_row1  
7272 cd cb 72			call .rowscan  
7275			  
7275			;ld a, 0  
7275			;out (portbdata),a  
7275 3e 40		ld a, 64  
7277 d3 c1		out (portbdata),a  
7279 3e 40			ld a, 64  
727b 21 e7 fe			ld hl, keyscan_table_row2  
727e cd cb 72			call .rowscan  
7281			  
7281 3e 00		ld a, 0  
7283 d3 c1		out (portbdata),a  
7285			;ld a, 64  
7285			;out (portbdata),a  
7285 3e 20			ld a, 32  
7287 21 dc fe			ld hl, keyscan_table_row3  
728a cd cb 72			call .rowscan  
728d			  
728d			;ld a, 0  
728d			;out (portbdata),a  
728d 3e 40		ld a, 64  
728f d3 c1		out (portbdata),a  
7291 3e 10			ld a, 16  
7293 21 d1 fe			ld hl, keyscan_table_row4  
7296 cd cb 72			call .rowscan  
7299			  
7299			; Display text on first line  
7299 3e 00		            LD   A, kLCD_Line1  
729b cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
729e 11 f2 fe		            LD   DE, keyscan_table_row1  
72a1			            ;LD   DE, MsgHello  
72a1 cd f5 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
72a4			  
72a4			; Display text on second line  
72a4 3e 28		            LD   A, kLCD_Line2  
72a6 cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
72a9 11 e7 fe		            LD   DE, keyscan_table_row2  
72ac cd f5 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
72af 3e 50		            LD   A, kLCD_Line3  
72b1 cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
72b4 11 dc fe		            LD   DE, keyscan_table_row3  
72b7 cd f5 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
72ba 3e 78		            LD   A, kLCD_Line4  
72bc cd d3 6e		            CALL fLCD_Pos       ;Position cursor to location in A  
72bf 11 d1 fe		            LD   DE, keyscan_table_row4  
72c2 cd f5 6e		            CALL fLCD_Str       ;Display string pointed to by DE  
72c5			  
72c5 cd 89 0c			call delay250ms  
72c8 c3 b6 71			jp matrix  
72cb			  
72cb			; pass de as row display flags  
72cb			.rowscan:   
72cb			;	out (portbdata),a  
72cb db c1			in a,(portbdata)  
72cd 4f				ld c,a  
72ce				; reset flags for the row   
72ce 06 7e			ld b,KEY_MATRIX_NO_PRESS  
72d0 e6 01			and 1  
72d2 28 02			jr z, .p1on  
72d4 06 23			ld b,'#'  
72d6			.p1on:  
72d6 70				ld (hl), b  
72d7 23				inc hl  
72d8			  
72d8 06 7e			ld b,KEY_MATRIX_NO_PRESS  
72da 79				ld a,c  
72db e6 02			and 2  
72dd			;	bit 0,a  
72dd 28 02			jr z, .p2on  
72df 06 23			ld b,'#'  
72e1			.p2on:  
72e1 70				ld (hl), b  
72e2 23				inc hl  
72e3			;  
72e3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
72e5 79				ld a,c  
72e6 e6 04			and 4  
72e8			;;	bit 0,a  
72e8 28 02			jr z, .p3on  
72ea 06 23			ld b,'#'  
72ec			.p3on:  
72ec 70				ld (hl), b  
72ed 23				inc hl  
72ee			;;  
72ee 06 7e			ld b,KEY_MATRIX_NO_PRESS  
72f0			;;	bit 0,a  
72f0 79				ld a,c  
72f1 e6 08			and 8  
72f3 28 02			jr z, .p4on  
72f5 06 23			ld b,'#'  
72f7			.p4on:  
72f7 70				ld (hl), b  
72f8 23				inc hl  
72f9			  
72f9 06 7e			ld b,KEY_MATRIX_NO_PRESS  
72fb			;;	bit 0,a  
72fb 79				ld a,c  
72fc e6 10			and 16  
72fe 28 02			jr z, .p5on  
7300 06 23			ld b,'#'  
7302			.p5on:  
7302 70				ld (hl), b  
7303 23				inc hl  
7304			; zero term  
7304 06 00			ld b,0  
7306 70				ld (hl), b  
7307			  
7307 c9			.rscandone: ret  
7308			  
7308			;addatohl:  
7308			;  
7308			 ;add   a, l    ; A = A+L  
7308			  ;  ld    l, a    ; L = A+L  
7308			   ; adc   a, h    ; A = A+L+H+carry  
7308			   ; sub   l       ; A = H+carry  
7308			   ; ld    h, a    ; H = H+carry  
7308			  
7308			;ret  
7308			; eof  
# End of file firmware_key_5x10.asm
7308			;include "firmware_key_4x10.asm" 
7308			 
7308			heap_size:    equ heap_end - heap_start 
7308			;eof 
# End of file os_mega.asm
7308
