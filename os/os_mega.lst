# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 75 1e			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-08 22:30' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 58 78			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			; cursor blink rate  
0068			CUR_BLINK_RATE: equ $09  
0068			;CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 65 78				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd fc 7a			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd dd 15				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 6f 1d			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 84 1d			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd e5 14			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd c4 15				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 97 15			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 91 25			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd da 21			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 91 78			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd dc 7b		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd cb 7b				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored and edited directly 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO handle KEY_PREVWORD 
0ffc			; TODO handle KEY_NEXTWORD 
0ffc			; TODO handle KEY_HOME 
0ffc			; TODO handle KEY_END 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc			EDIT_V1: equ 0 
0ffc			EDIT_V2: equ 1 
0ffc			 
0ffc			 
0ffc			 
0ffc			if EDIT_V2 
0ffc			input_str: 
0ffc			else 
0ffc			input_str_new: 
0ffc			endif 
0ffc			 
0ffc 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
0fff			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fff 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1002			;		ld a, c 
1002			;		call addatohl 
1002			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1002 7a					ld a,d 
1003 32 a1 fd			        ld (input_size), a       ; save length of input area 
1006 79					ld a, c 
1007 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
100a 7b					ld a,e 
100b 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
100e			 
100e			 
100e					; add a trailing space to make screen refresh nicer 
100e			 
100e					;ld hl, (input_start) 
100e					;push hl 
100e					;ld a, 0 
100e					;call strlent 
100e					;ld a, l 
100e					;pop hl 
100e					;call addatohl 
100e					;dec hl 
100e					;ld a, ' ' 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld a, 0 
100e					;ld (hl), a 
100e			 
100e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
100e					; init cursor shape if not set by the cin routines 
100e 21 fc fa				ld hl, cursor_shape 
1011			if BASE_KEV 
1011 3e ff				ld a, 255 
1013			else 
1013					ld a, '#' 
1013			endif 
1013 77					ld (hl), a 
1014 23					inc hl 
1015 3e 00				ld a, 0 
1017 77					ld (hl), a 
1018			 
1018 3e 09				ld a, CUR_BLINK_RATE 
101a 32 9b fd				ld (input_cur_flash), a 
101d 3e 01				ld a, 1 
101f 32 9a fd				ld (input_cur_onoff),a 
1022			.inmain:	 
1022			 
1022 2a a2 fd				ld hl, (input_start) 
1025 3e 00				ld a, 0 
1027 cd 97 15				call strlent 
102a 7d					ld a, l 
102b 32 95 fd				ld (input_len),a 
102e cd db 10				call input_disp_ref 
1031					;call input_disp_oncur 
1031			 
1031					; TODO display current state of input buffer 
1031			 
1031			 
1031					; pause 1ms 
1031			 
1031 3e 01				ld a, 1 
1033 cd c3 0c				call aDelayInMS 
1036			 
1036			; display cursor if visible on this cycle 
1036			 
1036					; dec flash counter 
1036 3a 9b fd				ld a, (input_cur_flash) 
1039 3d					dec a 
103a 32 9b fd				ld (input_cur_flash), a 
103d fe 00				cp 0 
103f 20 0d				jr nz, .inochgstate 
1041			 
1041			 
1041					; reset on change of state 
1041 3e 09				ld a, CUR_BLINK_RATE 
1043 32 9b fd				ld (input_cur_flash), a 
1046			 
1046					; change state 
1046 3a 9a fd				ld a,(input_cur_onoff) 
1049 ed 44				neg 
104b 32 9a fd				ld (input_cur_onoff),a 
104e			 
104e			 
104e			 
104e			 
104e					; TODO is cursor visible? 
104e					; TODO if so then over write the char at curspos pos with the cursor shape 
104e			 
104e								 
104e			 
104e			.inochgstate: 
104e 3a 9a fd				ld a,(input_cur_onoff) 
1051 fe ff				cp 255 
1053 28 0e				jr z, .skipcursor 
1055 3a 9f fd				ld a, (input_at_pos) 
1058 47					ld b, a 
1059 3a 90 fd				ld a, (input_cursor) 
105c 80					add b 
105d 11 fc fa				ld de, cursor_shape 
1060					 
1060 cd ae 0d				call str_at_display 
1063			 
1063			.skipcursor: 
1063				if DEBUG_INPUTV2 
1063			 
1063 3a 9f fd				ld a,(input_at_pos) 
1066 21 e8 fa				ld hl, LFSRSeed 
1069 cd 2f 14				call hexout 
106c 3a 90 fd				ld a, (input_cursor) 
106f 21 ea fa				ld hl, LFSRSeed+2 
1072 cd 2f 14				call hexout 
1075 3a a1 fd				ld a,(input_size) 
1078 21 ec fa				ld hl, LFSRSeed+4 
107b cd 2f 14				call hexout 
107e			 
107e 3a 9a fd				ld a,(input_cur_onoff) 
1081 21 ee fa				ld hl, LFSRSeed+6 
1084 cd 2f 14				call hexout 
1087			 
1087 3a 9b fd				ld a,(input_cur_flash) 
108a 21 f0 fa				ld hl, LFSRSeed+8 
108d cd 2f 14				call hexout 
1090			 
1090 3a 95 fd				ld a,(input_len) 
1093 21 f2 fa				ld hl, LFSRSeed+10 
1096 cd 2f 14				call hexout 
1099 21 f4 fa				ld hl, LFSRSeed+12 
109c 3e 00				ld a, 0 
109e 77					ld (hl),a 
109f 3e 78				ld a, display_row_4 
10a1 11 e8 fa				ld de, LFSRSeed 
10a4 cd ae 0d				call str_at_display 
10a7				endif 
10a7 cd be 0d				call update_display 
10aa			 
10aa					; TODO keyboard processing 
10aa			 
10aa			if BASE_CPM 
10aa					call cin_wait 
10aa			else 
10aa cd dc 7b				call cin    ; _wait 
10ad			endif 
10ad fe 00				cp 0 
10af ca 22 10				jp z, .inmain 
10b2			 
10b2 fe 0b				cp KEY_LEFT    ; cursor left 
10b4 ca c7 10				jp z, input_left 
10b7				 
10b7 fe 0c				cp KEY_RIGHT      ; cursor right 
10b9 ca d1 10				jp z, input_right 
10bc			 
10bc fe 0d				cp KEY_CR 
10be c8					ret z 
10bf			 
10bf fe 08				cp KEY_BS 
10c1 ca 3e 11				jp z, input_delchar 
10c4			 
10c4			;		cp KEY_HOME    ; jump to start of line 
10c4			;		jr nz, .instr5 
10c4			;		dec hl 
10c4			;		ld (input_ptr),hl 
10c4			;		jr .instr1 
10c4			 
10c4			;		cp KEY_END     ; jump to end of line 
10c4			;		jr nz, .instr6 
10c4			;		dec hl 
10c4			;		ld (input_ptr),hl 
10c4			;		jr .instr1 
10c4			;	        cp KEY_UP      ; recall last command 
10c4			;		jr nz, .instrnew 
10c4			; 
10c4			;	ld hl, scratch 
10c4			;	ld de, os_last_cmd 
10c4			;	call strcpy 
10c4			;		jr .instr1 
10c4			 
10c4			 
10c4					; if no special key then insert as a char 
10c4			 
10c4 c3 0a 11				jp input_inschr 
10c7			 
10c7				 
10c7			 
10c7			 
10c7			 
10c7			input_left: 
10c7				; move cursor left 
10c7 3a 90 fd			ld a, (input_cursor) 
10ca			;	cp 0 
10ca			;	jp z, .inmain    ; ignore left as at the start of the string 
10ca 3d				dec a 
10cb 32 90 fd			ld (input_cursor), a 
10ce c3 22 10			jp .inmain 
10d1			 
10d1			input_right: 
10d1				; move cursor right 
10d1				 
10d1				;ld a, (input_size) 
10d1				;ld b, a 
10d1 3a 90 fd			ld a, (input_cursor) 
10d4				;dec b 
10d4				;cp 0 
10d4				;jp z, .inmain   ; ignore as at end of the string buffer 
10d4				;ld a, b 
10d4 3c				inc a 
10d5 32 90 fd			ld (input_cursor), a 
10d8 c3 22 10			jp .inmain 
10db			 
10db			 
10db			 
10db			input_disp_ref: 
10db				; display the text from start of buffer (ie full refresh) 
10db 3a 9f fd			ld a, (input_at_pos) 
10de 2a a2 fd			ld hl,(input_start) 
10e1 eb				ex de, hl 
10e2 cd ae 0d			call str_at_display  
10e5 c9				ret 
10e6			input_disp_oncur: 
10e6				; display the text from cursor position to end of buffer 
10e6				; TODO position start of string at cursor position on screen 
10e6				; TODO draw from that point on 
10e6 3a 90 fd			ld a, (input_cursor) 
10e9 47				ld b, a 
10ea 3a 9f fd			ld a, (input_at_pos) 
10ed 80				add b 
10ee 48				ld c, b     ; save a 
10ef 78				ld a, b     ; inc string start for cursor 
10f0 2a a2 fd			ld hl,(input_start) 
10f3 cd cf 0f			call addatohl 
10f6 eb				ex de, hl 
10f7 79				ld a, c 
10f8 cd ae 0d			call str_at_display  
10fb c9				ret 
10fc			 
10fc			input_nxtw: 
10fc				; Find next word 
10fc c9				ret 
10fd			 
10fd			input_prvw: 
10fd				; Find previous word 
10fd c9				ret 
10fe			 
10fe			input_lenrem:   
10fe				; Calculate the length of string remaining from current cursor 
10fe				; position to end of buffer (exc null term) 
10fe				 
10fe 3a 90 fd			ld a, (input_cursor) 
1101 4f				ld c, a 
1102 3a a1 fd			ld a, (input_size) 
1105 91				sub c 
1106 06 00			ld b, 0 
1108 0d				dec c 
1109 c9				ret	 
110a				 
110a			 
110a			input_inschr: 
110a				; Insert char at cursor position 
110a f5				push af   ; save char 
110b				;call input_lenrem    ; get bc length of remaining string 
110b			 
110b				 
110b			 
110b 2a a2 fd			ld hl, (input_start) 
110e 3a 90 fd			ld a, (input_cursor) 
1111 cd cf 0f			call addatohl 
1114				;push hl   ; save to come back to 
1114			 
1114				; shift everything up one to end of buffer 
1114			 
1114				;push hl 
1114				;dec de 
1114				;inc de 
1114			;	ldir 
1114				 
1114				;pop hl 
1114			 
1114				; are we adding to the end of line? 
1114			 
1114 3a 90 fd			ld a, (input_cursor) 
1117 47				ld b, a 
1118 3a 95 fd			ld a, (input_len) 
111b b8				cp b 
111c 20 09			jr nz, .insmid   ; no, insert in middle of text 
111e			 
111e				; tack on the end of the line 
111e f1				pop af 
111f 77				ld (hl), a   ; save new char 
1120 23				inc hl 
1121 3e 00			ld a, 0 
1123 77				ld (hl), a 
1124 c3 d1 10			jp input_right 
1127				 
1127			.insmid: 
1127				; hl has insertion point so move everything up one to allow for insertion 
1127				;call input_shiftright 
1127 f1				pop af 
1128			 
1128			.shufinsmid: 
1128 47				ld b, a     ; b contains new char, c prev char at this position  
1129 7e				ld a, (hl) 
112a			 
112a fe 00			cp 0    ; at end of string need to then dump new char and add term 
112c 28 07			jr z, .endinsmid 
112e 4f				ld c, a 
112f 78				ld a, b 
1130 77				ld (hl), a 
1131 23				inc hl 
1132 79				ld a, c 
1133 18 f3			jr .shufinsmid 
1135				 
1135			 
1135			 
1135			 
1135			.endinsmid: 
1135 78				ld a, b 
1136 77				ld (hl), a 
1137 23				inc hl 
1138 3e 00			ld a, 0 
113a 77				ld (hl), a 
113b			 
113b			 
113b			;	ld (hl), a   ; save new char 
113b			 
113b c3 d1 10			jp input_right 
113e			 
113e			;input_shiftright: 
113e			;	; shift text right at cursor, hl has shift start 
113e			;	push hl 
113e			;	push de 
113e			;	push bc 
113e			; 
113e			; 
113e			;	; move to end of string past zero term 
113e			;	ld hl,(input_start) 
113e			;	ld a, (input_len) 
113e			;	call addatohl 
113e			;	inc hl 
113e			;;	inc hl 
113e			;;	inc hl 
113e			;	ld a, 0 
113e			;	ld (hl), a 
113e			;;	dec hl 
113e			;	 
113e			;;	ld (hl), a 
113e			;;	dec hl 
113e			; 
113e			;	push hl 
113e			;	pop de 
113e			;	inc de 
113e			;	 
113e			; 
113e			;;	ld hl,(input_start) 
113e			;;	ld a, (input_cursor) 
113e			;;	call addatohl 
113e			; 
113e			; 
113e			;	; calc how many bytes from cursor pos to end of string we need to shift 
113e			;	call input_lenrem    ; get bc length of remaining string 
113e			;	;ld a, (input_cursor) 
113e			;	;ld c, a 
113e			;	ld a, (input_len) 
113e			;	cp 2 
113e			;	jr z, .iskipzero	 
113e			;	;sub c 
113e			;	;inc a 
113e			;	;ld c, a 
113e			;	;ld b, 0 
113e			;	inc c 
113e			;	inc c 
113e			;	; move data 
113e			;	lddr 
113e			;.iskipzero: 
113e			; 
113e			;	pop bc 
113e			;	pop de 
113e			;	pop hl 
113e			;	ret	 
113e			 
113e			input_delchar: 
113e				; Delete char at cursor position 
113e cd fe 10			call input_lenrem    ; get bc length of remaining string 
1141 2a a2 fd			ld hl, (input_start) 
1144 3a 90 fd			ld a, (input_cursor) 
1147 cd cf 0f			call addatohl 
114a			 
114a e5				push hl 
114b d1				pop de 
114c 1b				dec de 
114d			 
114d			.dl:	 
114d ed a0			ldi  
114f 7e				ld a, (hl) 
1150 fe 00			cp 0 
1152 28 02			jr z, .dldone 
1154 18 f7			jr .dl 
1156			.dldone: 
1156 ed a0			ldi 
1158			 
1158 c3 c7 10			jp input_left 
115b			 
115b			 
115b			 
115b			 
115b			 
115b			if EDIT_V1 
115b			input_str: 
115b			else 
115b			input_str_old: 
115b			endif 
115b			 
115b 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
115e 81					add c 
115f 32 9d fd				ld (input_at_cursor),a	; save draw pos of cursor 
1162 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1165 79					ld a, c 
1166 cd cf 0f				call addatohl 
1169 22 a4 fd				ld (input_ptr), hl     ; save ptr to point under the cursor 
116c 7a					ld a,d 
116d 32 a1 fd			        ld (input_size), a       ; save length of input area 
1170 79					ld a, c 
1171 32 90 fd				ld (input_cursor),a      ; init cursor start position  
1174 7b					ld a,e 
1175 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
1178					 
1178					 
1178			 
1178			;		ld a,(input_ptr) 
1178			;		ld (input_under_cursor),a 	; save what is under the cursor 
1178			 
1178			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
1178					; init cursor shape if not set by the cin routines 
1178 21 fc fa				ld hl, cursor_shape 
117b			if BASE_KEV 
117b 3e ff				ld a, 255 
117d			else 
117d					ld a, '#' 
117d			endif 
117d 77					ld (hl), a 
117e 23					inc hl 
117f 3e 00				ld a, 0 
1181 77					ld (hl), a 
1182			 
1182 3e 09				ld a, CUR_BLINK_RATE 
1184 32 9b fd				ld (input_cur_flash), a 
1187 3e 01				ld a, 1 
1189 32 9a fd				ld (input_cur_onoff),a 
118c			 
118c			;	if DEBUG_INPUT 
118c			;		push af 
118c			;		ld a, 'I' 
118c			;		ld (debug_mark),a 
118c			;		pop af 
118c			;		CALLMONITOR 
118c			;	endif 
118c			.is1:		; main entry loop 
118c			 
118c			 
118c			 
118c					; pause 1ms 
118c			 
118c 3e 01				ld a, 1 
118e cd c3 0c				call aDelayInMS 
1191			 
1191					; dec flash counter 
1191 3a 9b fd				ld a, (input_cur_flash) 
1194 3d					dec a 
1195 32 9b fd				ld (input_cur_flash), a 
1198 fe 00				cp 0 
119a 20 0d				jr nz, .nochgstate 
119c			 
119c			 
119c					; change state 
119c 3a 9a fd				ld a,(input_cur_onoff) 
119f ed 44				neg 
11a1 32 9a fd				ld (input_cur_onoff),a 
11a4			 
11a4			 
11a4					; reset on change of state 
11a4 3e 09				ld a, CUR_BLINK_RATE 
11a6 32 9b fd				ld (input_cur_flash), a 
11a9			 
11a9			.nochgstate: 
11a9					 
11a9					 
11a9			 
11a9					; display cursor  
11a9			 
11a9			;		ld hl, (input_start) 
11a9			;		ld a, (input_cursor) 
11a9			;		call addatohl 
11a9			 
11a9					; get char under cursor and replace with cursor 
11a9 2a a4 fd		ld hl, (input_ptr) 
11ac			;		ld a, (hl) 
11ac			;		ld (input_under_cursor),a 
11ac			;		ld a, '_' 
11ac			;		ld (hl), a 
11ac			 
11ac					; display string 
11ac			 
11ac ed 5b a2 fd			ld de, (input_start) 
11b0 3a 9f fd				ld a, (input_at_pos) 
11b3 cd ae 0d				call str_at_display 
11b6			;	        call update_display 
11b6			 
11b6					; find place to put the cursor 
11b6			;		add h 
11b6			;		ld l, display_row_1 
11b6			;		sub l 
11b6			; (input_at_pos) 
11b6					;ld c, a 
11b6			;		ld a, (input_cursor) 
11b6			;		ld l, (input_at_pos) 
11b6			;		;ld b, h 
11b6			;		add l 
11b6			;		ld (input_at_cursor),a 
11b6					;ld l,h 
11b6			 
11b6			;		ld h, 0 
11b6			;		ld l,(input_at_pos) 
11b6			;		ld a, (input_cursor) 
11b6			;		call addatohl 
11b6			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11b6			;		call subafromhl 
11b6			;		ld a,l 
11b6			;		ld (input_at_cursor), a 
11b6			 
11b6				if DEBUG_INPUT 
11b6					ld a, (hardware_diag) 
11b6					cp 0 
11b6					jr z, .skip_input_diag 
11b6			 
11b6					ld a,(input_at_pos) 
11b6					ld hl, LFSRSeed 
11b6					call hexout 
11b6					ld a, (input_cursor) 
11b6					ld hl, LFSRSeed+2 
11b6					call hexout 
11b6					ld a,(input_at_cursor) 
11b6					ld hl, LFSRSeed+4 
11b6					call hexout 
11b6			 
11b6					ld a,(input_cur_onoff) 
11b6					ld hl, LFSRSeed+6 
11b6					call hexout 
11b6			 
11b6					ld a,(input_cur_flash) 
11b6					ld hl, LFSRSeed+8 
11b6					call hexout 
11b6			 
11b6					ld a,(input_len) 
11b6					ld hl, LFSRSeed+10 
11b6					call hexout 
11b6					ld hl, LFSRSeed+12 
11b6					ld a, 0 
11b6					ld (hl),a 
11b6					ld a, display_row_4 
11b6					ld de, LFSRSeed 
11b6					call str_at_display 
11b6					.skip_input_diag: 
11b6				endif 
11b6			 
11b6					; decide on if we are showing the cursor this time round 
11b6			 
11b6 3a 9a fd				ld a, (input_cur_onoff) 
11b9 fe ff				cp 255 
11bb 28 13				jr z, .skipcur 
11bd			 
11bd			 
11bd 3a 9d fd				ld a,(input_at_cursor) 
11c0 11 fc fa				ld de, cursor_shape 
11c3 cd ae 0d				call str_at_display 
11c6			 
11c6					; save length of current input string 
11c6 2a a2 fd				ld hl, (input_start) 
11c9 cd 8c 15				call strlenz 
11cc 7d					ld a,l 
11cd 32 95 fd				ld (input_len),a 
11d0			 
11d0			.skipcur: 
11d0			 
11d0 cd be 0d			        call update_display 
11d3					 
11d3			 
11d3			 
11d3					; wait 
11d3				 
11d3					; TODO loop without wait to flash the cursor and char under cursor	 
11d3 cd dc 7b				call cin    ; _wait 
11d6			 
11d6 fe 00				cp 0 
11d8 ca 8c 11				jp z, .is1 
11db			 
11db					; get ptr to char to input into 
11db			 
11db 4f					ld c,a 
11dc 2a a2 fd				ld hl, (input_start) 
11df 3a 90 fd				ld a, (input_cursor) 
11e2 cd cf 0f				call addatohl 
11e5 22 a4 fd				ld (input_ptr), hl 
11e8 79					ld a,c 
11e9			 
11e9					; replace char under cursor 
11e9			 
11e9			;		ld hl, (input_ptr) 
11e9			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11e9			;		ld (hl), a 
11e9			 
11e9			;	if DEBUG_INPUT 
11e9			;		push af 
11e9			;		ld a, 'i' 
11e9			;		ld (debug_mark),a 
11e9			;		pop af 
11e9			;		CALLMONITOR 
11e9			;	endif 
11e9 fe 0e				cp KEY_HOME 
11eb 20 0e				jr nz, .iske 
11ed			 
11ed 3a 9f fd				ld a, (input_at_pos) 
11f0 32 9d fd				ld (input_at_cursor),a 
11f3 3e 00				ld a, 0 
11f5 32 90 fd				ld (input_cursor), a 
11f8 c3 8c 11				jp .is1 
11fb					 
11fb fe 0f		.iske:		cp KEY_END 
11fd 20 03				jr nz, .isknw 
11ff c3 8c 11				jp .is1 
1202			 
1202 fe 06		.isknw:		cp KEY_NEXTWORD 
1204 20 1b				jr nz, .iskpw 
1206			 
1206 2a a4 fd		.isknwm:	ld hl, (input_ptr) 
1209 7e					ld a,(hl)	 
120a fe 00				cp 0 
120c ca 8c 11				jp z, .is1    ; end of string 
120f fe 20				cp ' ' 
1211 ca 8c 11				jp z, .is1    ; end of word 
1214 23					inc hl 
1215 22 a4 fd				ld (input_ptr), hl 
1218 3a 9d fd				ld a, (input_at_cursor) 
121b 3c					inc a 
121c 32 9d fd				ld (input_at_cursor), a 
121f 18 e5				jr .isknwm 
1221			 
1221 fe 07		.iskpw:		cp KEY_PREVWORD 
1223 20 1b				jr nz, .iskl 
1225			.iskpwm:	 
1225 2a a4 fd				ld hl, (input_ptr) 
1228 7e					ld a,(hl)	 
1229 fe 00				cp 0  
122b ca 8c 11				jp z, .is1    ; end of string 
122e fe 20				cp ' ' 
1230 ca 8c 11				jp z, .is1    ; end of word 
1233 2b					dec hl 
1234 22 a4 fd				ld (input_ptr), hl 
1237 3a 9d fd				ld a, (input_at_cursor) 
123a 3d					dec a 
123b 32 9d fd				ld (input_at_cursor), a 
123e 18 e5				jr .iskpwm 
1240			 
1240			 
1240 fe 0b		.iskl:		cp KEY_LEFT 
1242 20 27				jr nz, .isk1 
1244			 
1244 3a 90 fd				ld a, (input_cursor) 
1247			 
1247 fe 00				cp 0 
1249 ca 8c 11				jp z, .is1 		; at start of line to ignore  
124c			 
124c 3d					dec  a 		; TODO check underflow 
124d 32 90 fd				ld (input_cursor), a 
1250			 
1250 2a a4 fd				ld hl, (input_ptr) 
1253 2b					dec hl 
1254 22 a4 fd				ld (input_ptr), hl 
1257					 
1257 3a 9d fd				ld a, (input_at_cursor) 
125a 3d					dec a 
125b 32 9d fd				ld (input_at_cursor), a 
125e			 
125e 3e 01				ld a, 1		; show cursor moving 
1260 32 9a fd				ld (input_cur_onoff),a 
1263 3e 09				ld a, CUR_BLINK_RATE 
1265 32 9b fd				ld (input_cur_flash), a 
1268			 
1268 c3 8c 11				jp .is1 
126b			 
126b fe 0c		.isk1:		cp KEY_RIGHT 
126d 20 2a				jr nz, .isk2 
126f			 
126f 3a 95 fd				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1272 5f					ld e,a 
1273 3a 90 fd				ld a, (input_cursor) 
1276 bb					cp e 
1277 ca 8c 11				jp z, .is1		; at the end of string so dont go right 
127a			 
127a 3c					inc  a 		; TODO check overflow 
127b 32 90 fd				ld (input_cursor), a 
127e			 
127e 3a 9d fd				ld a, (input_at_cursor) 
1281 3c					inc a 
1282 32 9d fd				ld (input_at_cursor), a 
1285			 
1285 2a a4 fd				ld hl, (input_ptr) 
1288 23					inc hl 
1289 22 a4 fd				ld (input_ptr), hl 
128c			 
128c 3e 01				ld a, 1		; show cursor moving 
128e 32 9a fd				ld (input_cur_onoff),a 
1291 3e 09				ld a, CUR_BLINK_RATE 
1293 32 9b fd				ld (input_cur_flash), a 
1296			 
1296 c3 8c 11				jp .is1 
1299			 
1299 fe 05		.isk2:		cp KEY_UP 
129b			 
129b 20 26				jr nz, .isk3 
129d			 
129d					; swap last command with the current on 
129d			 
129d					; move cursor to start of string 
129d 2a a2 fd				ld hl, (input_start) 
12a0 22 a4 fd				ld (input_ptr), hl 
12a3			 
12a3 3a 9f fd				ld a, (input_at_pos) 
12a6 32 9d fd				ld (input_at_cursor), a 
12a9			 
12a9 3e 00				ld a, 0 
12ab 32 90 fd				ld (input_cursor), a 
12ae					 
12ae					; swap input and last command buffers 
12ae			 
12ae 21 23 f4				ld hl, os_cli_cmd 
12b1 11 22 f5				ld de, os_last_cmd 
12b4 06 ff				ld b, 255 
12b6 7e			.swap1:		ld a, (hl) 
12b7 4f					ld c,a 
12b8 1a					ld a, (de) 
12b9 77					ld (hl), a 
12ba 79					ld a,c 
12bb 12					ld (de),a 
12bc 23					inc hl 
12bd 13					inc de 
12be 10 f6				djnz .swap1 
12c0			 
12c0			 
12c0			 
12c0			 
12c0			 
12c0 c3 8c 11				jp .is1 
12c3			 
12c3 fe 08		.isk3:		cp KEY_BS 
12c5 20 3c				jr nz, .isk4 
12c7			 
12c7 3a 90 fd				ld a, (input_cursor) 
12ca			 
12ca fe 00				cp 0 
12cc ca 8c 11				jp z, .is1 		; at start of line to ignore  
12cf			 
12cf 3d					dec  a 		; TODO check underflow 
12d0 32 90 fd				ld (input_cursor), a 
12d3			 
12d3					; hl is source 
12d3					; de needs to be source - 1 
12d3			 
12d3			;		ld a, 0 
12d3			;		dec hl 
12d3			;		ld (hl), a 
12d3			 
12d3 2a a4 fd				ld hl, (input_ptr) 
12d6 2b					dec hl 
12d7 22 a4 fd				ld (input_ptr), hl 
12da			 
12da					; shift all data 
12da			 
12da e5					push hl 
12db 23					inc hl 
12dc d1					pop de 
12dd 3a 95 fd				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
12e0 4f					ld c,a 
12e1 06 00				ld b,0 
12e3 ed b0				ldir  
12e5			 
12e5			 
12e5			 
12e5			 
12e5 3a 9d fd				ld a, (input_at_cursor) 
12e8 3d					dec a 
12e9 32 9d fd				ld (input_at_cursor), a 
12ec			 
12ec			 
12ec 3e 01				ld a, 1		; show cursor moving 
12ee 32 9a fd				ld (input_cur_onoff),a 
12f1 3e 09				ld a, CUR_BLINK_RATE 
12f3 32 9b fd				ld (input_cur_flash), a 
12f6			 
12f6					; remove char 
12f6 3a 9d fd				ld a, (input_at_cursor) 
12f9 3c					inc a 
12fa 11 84 13				ld de,.iblank 
12fd cd ae 0d				call str_at_display 
1300			 
1300 c3 8c 11				jp .is1 
1303			 
1303 fe 0d		.isk4:		cp KEY_CR 
1305 28 6c				jr z, .endinput 
1307			 
1307					; else add the key press to the end 
1307			 
1307 4f					ld c, a			; save key pressed 
1308			 
1308 7e					ld a,(hl)		; get what is currently under char 
1309			 
1309 fe 00				cp 0			; we are at the end of the string 
130b 20 2f				jr nz, .onchar 
130d					 
130d					; add a char to the end of the string 
130d				 
130d 71					ld (hl),c 
130e 23					inc hl 
130f			;		ld a,' ' 
130f			;		ld (hl),a 
130f			;		inc hl 
130f 3e 00				ld a,0 
1311 77					ld (hl),a 
1312 2b					dec hl 
1313			 
1313 3a 90 fd				ld a, (input_cursor) 
1316 3c					inc a				; TODO check max string length and scroll  
1317 32 90 fd				ld (input_cursor), a		; inc cursor pos 
131a							 
131a 3a 9d fd				ld a, (input_at_cursor) 
131d 3c					inc a 
131e 32 9d fd				ld (input_at_cursor), a 
1321			 
1321 2a a4 fd				ld hl, (input_ptr) 
1324 23					inc hl 
1325 22 a4 fd				ld (input_ptr), hl 
1328			 
1328 2a a4 fd				ld hl, (input_ptr) 
132b 23					inc hl 
132c 22 a4 fd				ld (input_ptr), hl 
132f			;	if DEBUG_INPUT 
132f			;		push af 
132f			;		ld a, '+' 
132f			;		ld (debug_mark),a 
132f			;		pop af 
132f			;		CALLMONITOR 
132f			;	endif 
132f 3e 01				ld a, 1		; show cursor moving 
1331 32 9a fd				ld (input_cur_onoff),a 
1334 3e 09				ld a, CUR_BLINK_RATE 
1336 32 9b fd				ld (input_cur_flash), a 
1339 c3 8c 11				jp .is1 
133c					 
133c			 
133c			 
133c					; if on a char then insert 
133c			.onchar: 
133c			 
133c					; TODO over flow check: make sure insert does not blow out buffer 
133c			 
133c					; need to do some maths to use lddr 
133c			 
133c e5					push hl   ; save char pos 
133d c5					push bc 
133e			 
133e 2a a2 fd				ld hl, (input_start) 
1341 3a 95 fd				ld a, (input_len) 
1344 cd cf 0f				call addatohl  		; end of string 
1347 23					inc hl 
1348 23					inc hl		; past zero term 
1349 e5					push hl 
134a 23					inc hl 
134b e5					push hl  
134c			 
134c								; start and end of lddr set, now how much to move? 
134c			 
134c							 
134c 3a 90 fd				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
134f 47					ld b,a 
1350 3a 95 fd				ld a,(input_len) 
1353 5f					ld e,a 
1354 90					sub b 
1355 3c					inc a		;?? 
1356 3c					inc a		;?? 
1357 3c					inc a		;?? 
1358			 
1358 06 00				ld b,0 
135a 4f					ld c,a 
135b			 
135b				if DEBUG_INPUT 
135b					push af 
135b					ld a, 'i' 
135b					ld (debug_mark),a 
135b					pop af 
135b			;		CALLMONITOR 
135b				endif 
135b d1					pop de 
135c e1					pop hl 
135d				if DEBUG_INPUT 
135d					push af 
135d					ld a, 'I' 
135d					ld (debug_mark),a 
135d					pop af 
135d			;		CALLMONITOR 
135d				endif 
135d ed b8				lddr 
135f				 
135f			 
135f			 
135f					; TODO have a key for insert/overwrite mode???? 
135f c1					pop bc 
1360 e1					pop hl 
1361 71					ld (hl), c		; otherwise overwrite current char 
1362					 
1362			 
1362			 
1362			 
1362 3a 90 fd				ld a, (input_cursor) 
1365 3c					inc  a 		; TODO check overflow 
1366 32 90 fd				ld (input_cursor), a 
1369			 
1369 3a 9d fd				ld a, (input_at_cursor) 
136c 3c					inc a 
136d 32 9d fd				ld (input_at_cursor), a 
1370			 
1370 c3 8c 11				jp .is1 
1373			 
1373			.endinput:	; TODO look for end of string 
1373			 
1373					; add trailing space for end of token 
1373			 
1373 2a a2 fd				ld hl, (input_start) 
1376 3a 95 fd				ld a,(input_len) 
1379 cd cf 0f				call addatohl 
137c 3e 20				ld a, ' ' 
137e 77					ld (hl),a 
137f					; TODO eof of parse marker 
137f			 
137f 23					inc hl 
1380 3e 00				ld a, 0 
1382 77					ld (hl),a 
1383			 
1383			 
1383 c9					ret 
1384			 
1384 .. 00		.iblank: db " ",0 
1386			 
1386			 
1386 32 9f fd		input_str_prev:	ld (input_at_pos), a 
1389 22 a2 fd				ld (input_start), hl 
138c 3e 01				ld a,1			; add cursor 
138e 77					ld (hl),a 
138f 23					inc hl 
1390 3e 00				ld a,0 
1392 77					ld (hl),a 
1393 22 a4 fd				ld (input_ptr), hl 
1396 7a					ld a,d 
1397 32 a1 fd				ld (input_size), a 
139a 3e 00				ld a,0 
139c 32 90 fd				ld (input_cursor),a 
139f			.instr1:	 
139f			 
139f					; TODO do block cursor 
139f					; TODO switch cursor depending on the modifer key 
139f			 
139f					; update cursor shape change on key hold 
139f			 
139f 2a a4 fd				ld hl, (input_ptr) 
13a2 2b					dec hl 
13a3 3a fc fa				ld a,(cursor_shape) 
13a6 77					ld (hl), a 
13a7			 
13a7					; display entered text 
13a7 3a 9f fd				ld a,(input_at_pos) 
13aa cd a0 79		            	CALL fLCD_Pos       ;Position cursor to location in A 
13ad ed 5b a2 fd	            	LD   de, (input_start) 
13b1 cd c2 79		            	CALL fLCD_Str       ;Display string pointed to by DE 
13b4			 
13b4 cd dc 7b				call cin 
13b7 fe 00				cp 0 
13b9 28 e4				jr z, .instr1 
13bb			 
13bb					; proecess keyboard controls first 
13bb			 
13bb 2a a4 fd				ld hl,(input_ptr) 
13be			 
13be fe 0d				cp KEY_CR	 ; pressing enter ends input 
13c0 28 5a				jr z, .instrcr 
13c2			 
13c2 fe 08				cp KEY_BS 	; back space 
13c4 20 0f				jr nz, .instr2 
13c6					; process back space 
13c6			 
13c6					; TODO stop back space if at start of string 
13c6 2b					dec hl 
13c7 2b					dec hl ; to over write cursor 
13c8 3a fc fa				ld a,(cursor_shape) 
13cb					;ld a,0 
13cb 77					ld (hl),a 
13cc 23					inc hl 
13cd 3e 20				ld a," " 
13cf 77					ld (hl),a 
13d0 22 a4 fd				ld (input_ptr),hl 
13d3					 
13d3			 
13d3 18 ca				jr .instr1 
13d5			 
13d5 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
13d7 20 06				jr nz, .instr3 
13d9 2b					dec hl 
13da 22 a4 fd				ld (input_ptr),hl 
13dd 18 c0				jr .instr1 
13df				 
13df fe 0c		.instr3:	cp KEY_RIGHT      ; cursor right 
13e1 20 06				jr nz, .instr4 
13e3 23					inc hl 
13e4 22 a4 fd				ld (input_ptr),hl 
13e7 18 b6				jr .instr1 
13e9			 
13e9 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
13eb 20 06				jr nz, .instr5 
13ed 2b					dec hl 
13ee 22 a4 fd				ld (input_ptr),hl 
13f1 18 ac				jr .instr1 
13f3			 
13f3 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
13f5 20 06				jr nz, .instr6 
13f7 2b					dec hl 
13f8 22 a4 fd				ld (input_ptr),hl 
13fb 18 a2				jr .instr1 
13fd fe 05		.instr6:        cp KEY_UP      ; recall last command 
13ff 20 0b				jr nz, .instrnew 
1401			 
1401 21 fc f0			ld hl, scratch 
1404 11 22 f5			ld de, os_last_cmd 
1407 cd 25 14			call strcpy 
140a 18 93				jr .instr1 
140c			 
140c			 
140c			.instrnew:	; no special key pressed to see if we have room to store it 
140c			 
140c					; TODO do string size test 
140c			 
140c 2b					dec hl ; to over write cursor 
140d 77					ld (hl),a 
140e 23					inc hl 
140f 3a fc fa				ld a,(cursor_shape) 
1412 77					ld (hl),a 
1413 23					inc hl 
1414 3e 00				ld a,0 
1416 77					ld (hl),a 
1417			 
1417 22 a4 fd				ld (input_ptr),hl 
141a					 
141a 18 83				jr .instr1 
141c 2b			.instrcr:	dec hl		; remove cursor 
141d 3e 20				ld a,' '	; TODO add a trailing space for safety 
141f 77					ld (hl),a 
1420 23					inc hl 
1421 3e 00				ld a,0 
1423 77					ld (hl),a 
1424			 
1424			 
1424					; if at end of line scroll up    
1424					; TODO detecting only end of line 4 for scroll up  
1424			 
1424					;ld   
1424			 
1424 c9					ret 
1425			 
1425			 
1425			; strcpy hl = dest, de source 
1425			 
1425 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1426 b7			            OR   A              ;Null terminator? 
1427 c8			            RET  Z              ;Yes, so finished 
1428 1a					ld a,(de) 
1429 77					ld (hl),a 
142a 13			            INC  DE             ;Point to next character 
142b 23					inc hl 
142c 18 f7		            JR   strcpy       ;Repeat 
142e c9					ret 
142f			 
142f			 
142f			; TODO string_at  
142f			; pass string which starts with lcd offset address and then null term string 
142f			 
142f			; TODO string to dec 
142f			; TODO string to hex 
142f			; TODO byte to string hex 
142f			; TODO byte to string dec 
142f			 
142f			 
142f			 
142f			; from z80uartmonitor 
142f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
142f			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
142f			; pass hl for where to put the text 
142f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
142f c5			hexout:	PUSH BC 
1430 f5					PUSH AF 
1431 47					LD B, A 
1432					; Upper nybble 
1432 cb 3f				SRL A 
1434 cb 3f				SRL A 
1436 cb 3f				SRL A 
1438 cb 3f				SRL A 
143a cd 4a 14				CALL tohex 
143d 77					ld (hl),a 
143e 23					inc hl	 
143f					 
143f					; Lower nybble 
143f 78					LD A, B 
1440 e6 0f				AND 0FH 
1442 cd 4a 14				CALL tohex 
1445 77					ld (hl),a 
1446 23					inc hl	 
1447					 
1447 f1					POP AF 
1448 c1					POP BC 
1449 c9					RET 
144a					 
144a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
144a			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
144a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
144a			tohex: 
144a e5					PUSH HL 
144b d5					PUSH DE 
144c 16 00				LD D, 0 
144e 5f					LD E, A 
144f 21 57 14				LD HL, .DATA 
1452 19					ADD HL, DE 
1453 7e					LD A, (HL) 
1454 d1					POP DE 
1455 e1					POP HL 
1456 c9					RET 
1457			 
1457			.DATA: 
1457 30					DEFB	30h	; 0 
1458 31					DEFB	31h	; 1 
1459 32					DEFB	32h	; 2 
145a 33					DEFB	33h	; 3 
145b 34					DEFB	34h	; 4 
145c 35					DEFB	35h	; 5 
145d 36					DEFB	36h	; 6 
145e 37					DEFB	37h	; 7 
145f 38					DEFB	38h	; 8 
1460 39					DEFB	39h	; 9 
1461 41					DEFB	41h	; A 
1462 42					DEFB	42h	; B 
1463 43					DEFB	43h	; C 
1464 44					DEFB	44h	; D 
1465 45					DEFB	45h	; E 
1466 46					DEFB	46h	; F 
1467			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1467			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1467			;;    subtract $30, if result > 9 then subtract $7 more 
1467			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1467			atohex: 
1467 d6 30				SUB $30 
1469 fe 0a				CP 10 
146b f8					RET M		; If result negative it was 0-9 so we're done 
146c d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
146e c9					RET		 
146f			 
146f			 
146f			 
146f			 
146f			; Get 2 ASCII characters as hex byte from pointer in hl 
146f			 
146f			BYTERD: 
146f 16 00			LD	D,00h		;Set up 
1471 cd 79 14			CALL	HEXCON		;Get byte and convert to hex 
1474 87				ADD	A,A		;First nibble so 
1475 87				ADD	A,A		;multiply by 16 
1476 87				ADD	A,A		; 
1477 87				ADD	A,A		; 
1478 57				LD	D,A		;Save hi nibble in D 
1479			HEXCON: 
1479 7e				ld a, (hl)		;Get next chr 
147a 23				inc hl 
147b d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
147d fe 0a			CP	00Ah		;Is it 0-9 ? 
147f 38 02			JR	C,NALPHA	;If so miss next bit 
1481 d6 07			SUB	007h		;Else convert alpha 
1483			NALPHA: 
1483 b2				OR	D		;Add hi nibble back 
1484 c9				RET			; 
1485			 
1485			 
1485			; 
1485			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1485			; Since the routines get_byte and therefore get_nibble are called, only valid 
1485			; characters (0-9a-f) are accepted. 
1485			; 
1485			;get_word        push    af 
1485			;                call    get_byte        ; Get the upper byte 
1485			;                ld      h, a 
1485			;                call    get_byte        ; Get the lower byte 
1485			;                ld      l, a 
1485			;                pop     af 
1485			;                ret 
1485			; 
1485			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1485			; the routine get_nibble is used only valid characters are accepted - the  
1485			; input routine only accepts characters 0-9a-f. 
1485			; 
1485 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1486 7e					ld a,(hl) 
1487 23					inc hl 
1488 cd ad 14		                call    nibble2val      ; Get upper nibble 
148b cb 07		                rlc     a 
148d cb 07		                rlc     a 
148f cb 07		                rlc     a 
1491 cb 07		                rlc     a 
1493 47			                ld      b, a            ; Save upper four bits 
1494 7e					ld a,(hl) 
1495 cd ad 14		                call    nibble2val      ; Get lower nibble 
1498 b0			                or      b               ; Combine both nibbles 
1499 c1			                pop     bc              ; Restore B (and C) 
149a c9			                ret 
149b			; 
149b			; Get a hexadecimal digit from the serial line. This routine blocks until 
149b			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
149b			; to the serial line interface. The lower 4 bits of A contain the value of  
149b			; that particular digit. 
149b			; 
149b			;get_nibble      ld a,(hl)           ; Read a character 
149b			;                call    to_upper        ; Convert to upper case 
149b			;                call    is_hex          ; Was it a hex digit? 
149b			;                jr      nc, get_nibble  ; No, get another character 
149b			 ;               call    nibble2val      ; Convert nibble to value 
149b			 ;               call    print_nibble 
149b			 ;               ret 
149b			; 
149b			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
149b			; A valid hexadecimal digit is denoted by a set C flag. 
149b			; 
149b			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
149b			;                ret     nc              ; Yes 
149b			;                cp      '0'             ; Less than '0'? 
149b			;                jr      nc, is_hex_1    ; No, continue 
149b			;                ccf                     ; Complement carry (i.e. clear it) 
149b			;                ret 
149b			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
149b			;                ret     c               ; Yes 
149b			;                cp      'A'             ; Less than 'A'? 
149b			;                jr      nc, is_hex_2    ; No, continue 
149b			;                ccf                     ; Yes - clear carry and return 
149b			;                ret 
149b			;is_hex_2        scf                     ; Set carry 
149b			;                ret 
149b			; 
149b			; Convert a single character contained in A to upper case: 
149b			; 
149b fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
149d d8			                ret     c 
149e fe 7b		                cp      'z' + 1         ; > 'z'? 
14a0 d0			                ret     nc              ; Nothing to do, either 
14a1 e6 5f		                and     $5f             ; Convert to upper case 
14a3 c9			                ret 
14a4			 
14a4			 
14a4			to_lower: 
14a4			 
14a4			   ; if char is in [A-Z] make it lower case 
14a4			 
14a4			   ; enter : a = char 
14a4			   ; exit  : a = lower case char 
14a4			   ; uses  : af 
14a4			 
14a4 fe 41		   cp 'A' 
14a6 d8			   ret c 
14a7			    
14a7 fe 5b		   cp 'Z'+1 
14a9 d0			   ret nc 
14aa			    
14aa f6 20		   or $20 
14ac c9			   ret 
14ad			 
14ad			; 
14ad			; Expects a hexadecimal digit (upper case!) in A and returns the 
14ad			; corresponding value in A. 
14ad			; 
14ad fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
14af 38 02		                jr      c, nibble2val_1 ; Yes 
14b1 d6 07		                sub     7               ; Adjust for A-F 
14b3 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
14b5 e6 0f		                and     $f              ; Only return lower 4 bits 
14b7 c9			                ret 
14b8			; 
14b8			; Print_nibble prints a single hex nibble which is contained in the lower  
14b8			; four bits of A: 
14b8			; 
14b8			;print_nibble    push    af              ; We won't destroy the contents of A 
14b8			;                and     $f              ; Just in case... 
14b8			;                add     a, '0'             ; If we have a digit we are done here. 
14b8			;                cp      '9' + 1         ; Is the result > 9? 
14b8			;                jr      c, print_nibble_1 
14b8			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
14b8			;print_nibble_1  call    putc            ; Print the nibble and 
14b8			;                pop     af              ; restore the original value of A 
14b8			;                ret 
14b8			;; 
14b8			;; Send a CR/LF pair: 
14b8			; 
14b8			;crlf            push    af 
14b8			;                ld      a, cr 
14b8			;                call    putc 
14b8			;                ld      a, lf 
14b8			;                call    putc 
14b8			;                pop     af 
14b8			;                ret 
14b8			; 
14b8			; Print_word prints the four hex digits of a word to the serial line. The  
14b8			; word is expected to be in HL. 
14b8			; 
14b8			;print_word      push    hl 
14b8			;                push    af 
14b8			;                ld      a, h 
14b8			;                call    print_byte 
14b8			;                ld      a, l 
14b8			;                call    print_byte 
14b8			;                pop     af 
14b8			;                pop     hl 
14b8			;                ret 
14b8			; 
14b8			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
14b8			; The byte to be printed is expected to be in A. 
14b8			; 
14b8			;print_byte      push    af              ; Save the contents of the registers 
14b8			;                push    bc 
14b8			;                ld      b, a 
14b8			;                rrca 
14b8			;                rrca 
14b8			;                rrca 
14b8			;                rrca 
14b8			;                call    print_nibble    ; Print high nibble 
14b8			;                ld      a, b 
14b8			;                call    print_nibble    ; Print low nibble 
14b8			;                pop     bc              ; Restore original register contents 
14b8			;                pop     af 
14b8			;                ret 
14b8			 
14b8			 
14b8			 
14b8			 
14b8			 
14b8			fourehexhl:  
14b8 7e				ld a,(hl) 
14b9 cd 67 14			call atohex 
14bc cb 3f				SRL A 
14be cb 3f				SRL A 
14c0 cb 3f				SRL A 
14c2 cb 3f				SRL A 
14c4 47				ld b, a 
14c5 23				inc hl 
14c6 7e				ld a,(hl) 
14c7 23				inc hl 
14c8 cd 67 14			call atohex 
14cb 80				add b 
14cc 57				ld d,a 
14cd 7e				ld a,(hl) 
14ce cd 67 14			call atohex 
14d1 cb 3f				SRL A 
14d3 cb 3f				SRL A 
14d5 cb 3f				SRL A 
14d7 cb 3f				SRL A 
14d9 47				ld b, a 
14da 23				inc hl 
14db 7e				ld a,(hl) 
14dc 23				inc hl 
14dd cd 67 14			call atohex 
14e0 80				add b 
14e1 5f				ld e, a 
14e2 d5				push de 
14e3 e1				pop hl 
14e4 c9				ret 
14e5			 
14e5			; pass hl. returns z set if the byte at hl is a digit 
14e5			;isdigithl:  
14e5			;	push bc 
14e5			;	ld a,(hl) 
14e5			;	cp ':' 
14e5			;	jr nc, .isdf 		; > 
14e5			;	cp '0' 
14e5			;	jr c, .isdf		; < 
14e5			; 
14e5			;	; TODO find a better way to set z 
14e5			; 
14e5			;	ld b,a 
14e5			;	cp b 
14e5			;	pop bc 
14e5			;	ret 
14e5			; 
14e5			;.isdf:	; not digit so clear z 
14e5			; 
14e5			;	; TODO find a better way to unset z 
14e5			; 
14e5			;	ld b,a 
14e5			;	inc b 
14e5			;	cp b 
14e5			; 
14e5			;	pop bc 
14e5			;	ret 
14e5				 
14e5				 
14e5			 
14e5			 
14e5			; pass hl as the four byte address to load 
14e5			 
14e5			get_word_hl:  
14e5 e5				push hl 
14e6 cd 85 14			call get_byte 
14e9				 
14e9 47				ld b, a 
14ea			 
14ea e1				pop hl 
14eb 23				inc hl 
14ec 23				inc hl 
14ed			 
14ed			; TODO not able to handle a-f  
14ed 7e				ld a,(hl) 
14ee			;	;cp ':' 
14ee			;	cp 'g' 
14ee			;	jr nc, .single_byte_hl 		; > 
14ee			;	cp 'G' 
14ee			;	jr nc, .single_byte_hl 		; > 
14ee			;	cp '0' 
14ee			;	jr c, .single_byte_hl		; < 
14ee			 
14ee				;call isdigithl 
14ee fe 00			cp 0 
14f0 28 06			jr z, .single_byte_hl 
14f2			 
14f2			.getwhln:   ; hex word so get next byte 
14f2			 
14f2 cd 85 14			call get_byte 
14f5 6f				ld l, a 
14f6 60				ld h,b 
14f7 c9				ret 
14f8 68			.single_byte_hl:   ld l,b 
14f9 26 00				ld h,0 
14fb c9					ret 
14fc			 
14fc			 
14fc			 
14fc			 
14fc 21 51 1f			ld hl,asc+1 
14ff			;	ld a, (hl) 
14ff			;	call nibble2val 
14ff cd 85 14			call get_byte 
1502			 
1502			;	call fourehexhl 
1502 32 30 f1			ld (scratch+52),a 
1505				 
1505 21 2e f1			ld hl,scratch+50 
1508 22 1f f4			ld (os_cur_ptr),hl 
150b			 
150b c9				ret 
150c			 
150c			 
150c			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
150c			 
150c			; Decimal Unsigned Version 
150c			 
150c			;Number in a to decimal ASCII 
150c			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
150c			;Example: display a=56 as "056" 
150c			;input: a = number 
150c			;Output: a=0,value of a in the screen 
150c			;destroys af,bc (don't know about hl and de) 
150c			DispAToASCII: 
150c 0e 9c			ld	c,-100 
150e cd 18 15			call	.Na1 
1511 0e f6			ld	c,-10 
1513 cd 18 15			call	.Na1 
1516 0e ff			ld	c,-1 
1518 06 2f		.Na1:	ld	b,'0'-1 
151a 04			.Na2:	inc	b 
151b 81				add	a,c 
151c 38 fc			jr	c,.Na2 
151e 91				sub	c		;works as add 100/10/1 
151f f5				push af		;safer than ld c,a 
1520 78				ld	a,b		;char is in b 
1521			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1521 f1				pop af		;safer than ld a,c 
1522 c9				ret 
1523			 
1523			; Decimal Signed Version 
1523			 
1523			; DispA 
1523			; -------------------------------------------------------------- 
1523			; Converts a signed integer value to a zero-terminated ASCII 
1523			; string representative of that value (using radix 10). 
1523			; -------------------------------------------------------------- 
1523			; INPUTS: 
1523			;     HL     Value to convert (two's complement integer). 
1523			;     DE     Base address of string destination. (pointer). 
1523			; -------------------------------------------------------------- 
1523			; OUTPUTS: 
1523			;     None 
1523			; -------------------------------------------------------------- 
1523			; REGISTERS/MEMORY DESTROYED 
1523			; AF HL 
1523			; -------------------------------------------------------------- 
1523			 
1523			;DispHLToASCII: 
1523			;   push    de 
1523			;   push    bc 
1523			; 
1523			;; Detect sign of HL. 
1523			;    bit    7, h 
1523			;    jr     z, ._DoConvert 
1523			; 
1523			;; HL is negative. Output '-' to string and negate HL. 
1523			;    ld     a, '-' 
1523			;    ld     (de), a 
1523			;    inc    de 
1523			; 
1523			;; Negate HL (using two's complement) 
1523			;    xor    a 
1523			;    sub    l 
1523			;    ld     l, a 
1523			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1523			;    sbc    a, h 
1523			;    ld     h, a 
1523			; 
1523			;; Convert HL to digit characters 
1523			;._DoConvert: 
1523			;    ld     b, 0     ; B will count character length of number 
1523			;-   ld     a, 10 
1523			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1523			;    push   af 
1523			;    inc    b 
1523			;    ld     a, h 
1523			;    or     l 
1523			;    jr     nz, - 
1523			; 
1523			;; Retrieve digits from stack 
1523			;-   pop    af 
1523			;    or     $30 
1523			;    ld     (de), a 
1523			;    inc    de 
1523			;    djnz   - 
1523			; 
1523			;; Terminate string with NULL 
1523			;    xor    a 
1523			;    ld     (de), a 
1523			; 
1523			;    pop    bc 
1523			;    pop    de 
1523			;    ret 
1523			 
1523			;Comments 
1523			; 
1523			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1523			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1523			;    Note that the output string will not be fixed-width. 
1523			; 
1523			;Example Usage 
1523			; 
1523			;    ld    hl, -1004 
1523			;    ld    de, OP1 
1523			;    call  DispA 
1523			;    ld    hl, OP1 
1523			;    syscall  PutS 
1523			 
1523			 
1523			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1523			 
1523			 
1523			;Converts an ASCII string to an unsigned 16-bit integer 
1523			;Quits when it reaches a non-decimal digit 
1523			 
1523			string_to_uint16: 
1523			atoui_16: 
1523			;Input: 
1523			;     DE points to the string 
1523			;Outputs: 
1523			;     HL is the result 
1523			;     A is the 8-bit value of the number 
1523			;     DE points to the byte after the number 
1523			;Destroys: 
1523			;     BC 
1523			;       if the string is non-empty, BC is HL/10 
1523			;Size:  24 bytes 
1523			;Speed: 42+d(104+{0,9}) 
1523			;       d is the number of digits in the number 
1523			;       max is 640 cycles for a 5 digit number 
1523			;Assuming no leading zeros: 
1523			;1 digit:  146cc 
1523			;2 digit:  250cc 
1523			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1523			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1523			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1523			;avg: 544.81158447265625cc (544+13297/16384) 
1523			;=============================================================== 
1523 21 00 00		  ld hl,0 
1526			.u16a: 
1526 1a			  ld a,(de) 
1527 d6 30		  sub 30h 
1529 fe 0a		  cp 10 
152b d0			  ret nc 
152c 13			  inc de 
152d 44			  ld b,h 
152e 4d			  ld c,l 
152f 29			  add hl,hl 
1530 29			  add hl,hl 
1531 09			  add hl,bc 
1532 29			  add hl,hl 
1533 85			  add a,l 
1534 6f			  ld l,a 
1535 30 ef		  jr nc,.u16a 
1537 24			  inc h 
1538 c3 26 15		  jp .u16a 
153b			 
153b			 
153b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
153b			 
153b			;written by Zeda 
153b			;Converts a 16-bit unsigned integer to an ASCII string. 
153b			 
153b			uitoa_16: 
153b			;Input: 
153b			;   DE is the number to convert 
153b			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
153b			;Output: 
153b			;   HL points to the null-terminated ASCII string 
153b			;      NOTE: This isn't necessarily the same as the input HL. 
153b d5			  push de 
153c c5			  push bc 
153d f5			  push af 
153e eb			  ex de,hl 
153f			 
153f 01 f0 d8		  ld bc,-10000 
1542 3e 2f		  ld a,'0'-1 
1544 3c			  inc a 
1545 09			  add hl,bc  
1546 38 fc		   jr c,$-2 
1548 12			  ld (de),a 
1549 13			  inc de 
154a			 
154a 01 e8 03		  ld bc,1000 
154d 3e 3a		  ld a,'9'+1 
154f 3d			  dec a  
1550 09			  add hl,bc  
1551 30 fc		   jr nc,$-2 
1553 12			  ld (de),a 
1554 13			  inc de 
1555			 
1555 01 9c ff		  ld bc,-100 
1558 3e 2f		  ld a,'0'-1 
155a 3c			  inc a  
155b 09			  add hl,bc  
155c 38 fc		   jr c,$-2 
155e 12			  ld (de),a 
155f 13			  inc de 
1560			 
1560 7d			  ld a,l 
1561 26 3a		  ld h,'9'+1 
1563 25			  dec h  
1564 c6 0a		  add a,10  
1566 30 fb		   jr nc,$-3 
1568 c6 30		  add a,'0' 
156a eb			  ex de,hl 
156b 72			  ld (hl),d 
156c 23			  inc hl 
156d 77			  ld (hl),a 
156e 23			  inc hl 
156f 36 00		  ld (hl),0 
1571			 
1571			;Now strip the leading zeros 
1571 0e fa		  ld c,-6 
1573 09			  add hl,bc 
1574 3e 30		  ld a,'0' 
1576 23			  inc hl  
1577 be			  cp (hl)  
1578 28 fc		  jr z,$-2 
157a			 
157a			;Make sure that the string is non-empty! 
157a 7e			  ld a,(hl) 
157b b7			  or a 
157c 20 01		  jr nz,.atoub 
157e 2b			  dec hl 
157f			.atoub: 
157f			 
157f f1			  pop af 
1580 c1			  pop bc 
1581 d1			  pop de 
1582 c9			  ret 
1583			 
1583			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1583			 
1583			toUpper: 
1583			;A is the char. 
1583			;If A is a lowercase letter, this sets it to the matching uppercase 
1583			;18cc or 30cc or 41cc 
1583			;avg: 26.75cc 
1583 fe 61		  cp 'a' 
1585 d8			  ret c 
1586 fe 7b		  cp 'z'+1 
1588 d0			  ret nc 
1589 d6 20		  sub 'a'-'A' 
158b c9			  ret 
158c			 
158c			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
158c			 
158c			; String Length 
158c			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
158c			 
158c			; Get the length of the null-terminated string starting at $8000 hl 
158c			;    LD     HL, $8000 
158c			 
158c			strlenz: 
158c			 
158c af			    XOR    A               ; Zero is the value we are looking for. 
158d 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
158e 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
158f			                           ; 65, 536 bytes (the entire addressable memory space). 
158f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1591			 
1591			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1591 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1592 6f			    LD     L, A             ; number of bytes 
1593 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1595 2b			    DEC    HL              ; Compensate for null. 
1596 c9				ret 
1597			 
1597			; Get the length of the A terminated string starting at $8000 hl 
1597			;    LD     HL, $8000 
1597			 
1597			strlent: 
1597			 
1597			                  ; A is the value we are looking for. 
1597 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1599 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
159b			                           ; 65, 536 bytes (the entire addressable memory space). 
159b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
159d			 
159d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
159d 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
159f 2e 00		    LD     L, 0             ; number of bytes 
15a1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
15a3 2b			    DEC    HL              ; Compensate for null. 
15a4 c9				ret 
15a5			 
15a5			 
15a5			;Comparing Strings 
15a5			 
15a5			;IN    HL     Address of string1. 
15a5			;      DE     Address of string2. 
15a5			 
15a5			; doc given but wrong??? 
15a5			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
15a5			;      carry  Set if string1 > string2, reset if string1 <= string2. 
15a5			; tested 
15a5			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
15a5			 
15a5			strcmp_old: 
15a5 e5			    PUSH   HL 
15a6 d5			    PUSH   DE 
15a7			 
15a7 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
15a8 be			    CP     (HL)            ; (want to minimize work). 
15a9 38 01		    JR     C, Str1IsBigger 
15ab 7e			    LD     A, (HL) 
15ac			 
15ac			Str1IsBigger: 
15ac 4f			    LD     C, A             ; Put length in BC 
15ad 06 00		    LD     B, 0 
15af 13			    INC    DE              ; Increment pointers to meat of string. 
15b0 23			    INC    HL 
15b1			 
15b1			CmpLoop: 
15b1 1a			    LD     A, (DE)          ; Compare bytes. 
15b2 ed a1		    CPI 
15b4 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
15b6 13			    INC    DE              ; Update pointer. 
15b7 ea b1 15		    JP     PE, CmpLoop 
15ba			 
15ba d1			    POP    DE 
15bb e1			    POP    HL 
15bc 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
15bd be			    CP     (HL) 
15be c9			    RET 
15bf			 
15bf			NoMatch: 
15bf 2b			    DEC    HL 
15c0 be			    CP     (HL)            ; Compare again to affect carry. 
15c1 d1			    POP    DE 
15c2 e1			    POP    HL 
15c3 c9			    RET 
15c4			 
15c4			;; test strmp 
15c4			; 
15c4			;ld de, .str1 
15c4			;ld hl, .str2 
15c4			;call strcmp 
15c4			;jr z, .z1 
15c4			;;this 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "NZ1" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			;.z1: 
15c4			; 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "ZZ1" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			; 
15c4			;ld de, .str1 
15c4			;ld hl, .str1 
15c4			;call strcmp 
15c4			;jr z, .z2 
15c4			;;this 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "NZ2" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			;.z2: 
15c4			; 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "ZZ2" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			; 
15c4			;ld de, .str1 
15c4			;ld hl, .str2 
15c4			;call strcmp 
15c4			;jr c, .c1 
15c4			; 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "Nc1" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			;.c1: 
15c4			;;this 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "cc1" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			; 
15c4			;ld de, .str1 
15c4			;ld hl, .str1 
15c4			;call strcmp 
15c4			;jr c, .c2 
15c4			;;this 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "Nc2" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			;.c2: 
15c4			; 
15c4			;	if DEBUG_FORTH_WORDS 
15c4			;		DMARK "cc2" 
15c4			;		CALLMONITOR 
15c4			;	endif 
15c4			;	NEXTW 
15c4			;.str1:   db "string1",0 
15c4			;.str2:   db "string2",0 
15c4			 
15c4			; only care about direct match or not 
15c4			; hl and de strings 
15c4			; zero set if the same 
15c4			 
15c4			strcmp: 
15c4 1a				ld a, (de) 
15c5 be				cp (hl) 
15c6 28 02			jr z, .ssame 
15c8 b7				or a 
15c9 c9				ret 
15ca			 
15ca			.ssame:  
15ca fe 00			cp 0 
15cc c8				ret z 
15cd			 
15cd 23				inc hl 
15ce 13				inc de 
15cf 18 f3			jr strcmp 
15d1				 
15d1				 
15d1			 
15d1			;Copyright (c) 2014, Luke Maurits 
15d1			;All rights reserved. 
15d1			; 
15d1			;Redistribution and use in source and binary forms, with or without 
15d1			;modification, are permitted provided that the following conditions are met: 
15d1			; 
15d1			;* Redistributions of source code must retain the above copyright notice, this 
15d1			;  list of conditions and the following disclaimer. 
15d1			; 
15d1			;* Redistributions in binary form must reproduce the above copyright notice, 
15d1			;  this list of conditions and the following disclaimer in the documentation 
15d1			;  and/or other materials provided with the distribution. 
15d1			; 
15d1			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
15d1			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
15d1			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
15d1			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
15d1			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
15d1			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
15d1			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
15d1			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
15d1			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
15d1			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
15d1			 
15d1			; https://github.com/lmaurits/lm512/blob/master/string.z80 
15d1			 
15d1			StrictStrCmp: 
15d1				; Load next chars of each string 
15d1 1a				ld a, (de) 
15d2 47				ld b, a 
15d3 7e				ld a, (hl) 
15d4				; Compare 
15d4 b8				cp b 
15d5				; Return non-zero if chars don't match 
15d5 c0				ret nz 
15d6				; Check for end of both strings 
15d6 fe 00			cp "\0" 
15d8				; Return if strings have ended 
15d8 c8				ret z 
15d9				; Otherwise, advance to next chars 
15d9 23				inc hl 
15da 13				inc de 
15db 18 f4			jr StrictStrCmp 
15dd			 
15dd			;end 
15dd			; eof 
15dd			 
15dd			 
15dd			 
15dd			 
15dd			 
15dd			 
# End of file firmware_strings.asm
15dd			include "firmware_memory.asm"   ; malloc and free  
15dd			 
15dd			if DEBUG_FORTH_MALLOC_HIGH 
15dd			.mallocsize: db "Wants malloc >256",0 
15dd			.mallocasize: db "MALLOC gives >256",0 
15dd			.malloczero: db "MALLOC gives zero",0 
15dd			 
15dd			malloc_guard_zerolen: 
15dd				push hl 
15dd				push de 
15dd				push af 
15dd			 
15dd				ld de, 0 
15dd			        call cmp16 
15dd				jr nz, .lowalloz 
15dd			 
15dd				push hl 
15dd				push de 
15dd					ld hl, display_fb0 
15dd					ld (display_fb_active), hl 
15dd				call clear_display 
15dd				ld a, 0 
15dd				ld de, .malloczero 
15dd				call str_at_display 
15dd				call update_display 
15dd				call delay1s 
15dd				call delay1s 
15dd				call bp_on 
15dd			;	ld a, 0 
15dd			;	ld (os_view_disable), a 
15dd			 
15dd				pop de 
15dd				pop hl 
15dd			 
15dd				 
15dd			 
15dd				CALLMONITOR 
15dd			.lowalloz: 
15dd			 
15dd			 
15dd				pop af 
15dd				pop de 
15dd				pop hl 
15dd			ret 
15dd			 
15dd			malloc_guard_entry: 
15dd				push hl 
15dd				push de 
15dd				push af 
15dd			 
15dd			 	or a      ;clear carry flag 
15dd				push hl 
15dd				ld de, 255 
15dd				sbc hl, de 
15dd				jr c, .lowalloc 
15dd			 
15dd				push de 
15dd					ld hl, display_fb0 
15dd					ld (display_fb_active), hl 
15dd				call clear_display 
15dd				ld a, 0 
15dd				ld de, .mallocsize 
15dd				call str_at_display 
15dd				call update_display 
15dd				call delay1s 
15dd				call delay1s 
15dd			;	ld a, 0 
15dd			;	ld (os_view_disable), a 
15dd				call bp_on 
15dd			 
15dd				pop de 
15dd				pop hl 
15dd			 
15dd				 
15dd			 
15dd				CALLMONITOR 
15dd				jr .lowdone 
15dd			.lowalloc: 
15dd			 
15dd			 
15dd				pop hl 
15dd			.lowdone:	pop af 
15dd				pop de 
15dd				pop hl 
15dd			ret 
15dd			 
15dd			malloc_guard_exit: 
15dd				push hl 
15dd				push de 
15dd				push af 
15dd			 
15dd			 	or a      ;clear carry flag 
15dd				push hl 
15dd				ld de, 255 
15dd				sbc hl, de 
15dd				jr c, .lowallocx 
15dd			 
15dd				push de 
15dd					ld hl, display_fb0 
15dd					ld (display_fb_active), hl 
15dd				call clear_display 
15dd				ld a, 0 
15dd				ld de, .mallocasize 
15dd				call str_at_display 
15dd				call update_display 
15dd				call delay1s 
15dd				call delay1s 
15dd			;	ld a, 0 
15dd			;	ld (os_view_disable), a 
15dd				call bp_on 
15dd				pop de 
15dd				pop hl 
15dd			 
15dd				CALLMONITOR 
15dd				jr .lowdonex 
15dd			.lowallocx: 
15dd			 
15dd				pop hl 
15dd			.lowdonex:	pop af 
15dd				pop de 
15dd				pop hl 
15dd			ret 
15dd			endif 
15dd			 
15dd			if MALLOC_2 
15dd			; Z80 Malloc and Free Functions 
15dd			 
15dd			; Malloc Function: 
15dd			; Input: 
15dd			;   HL: Size of block to allocate 
15dd			; Output: 
15dd			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
15dd			 
15dd			malloc: 
15dd				 
15dd			if DEBUG_FORTH_MALLOC_HIGH 
15dd			call malloc_guard_entry 
15dd			endif 
15dd			 
15dd			 
15dd			 
15dd			 
15dd					if DEBUG_FORTH_MALLOC 
15dd						DMARK "mal" 
15dd						CALLMONITOR 
15dd					endif 
15dd			    push af            ; Save AF register 
15dd			    ld a, l            ; Load low byte of size into A 
15dd			    or h               ; Check if size is zero 
15dd			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
15dd			 
15dd			    ; Allocate memory 
15dd			    ld hl, (heap_start) ; Load start of heap into HL 
15dd					if DEBUG_FORTH_MALLOC 
15dd						DMARK "ma1" 
15dd						CALLMONITOR 
15dd					endif 
15dd			    call malloc_internal ; Call internal malloc function 
15dd			    pop af             ; Restore AF register 
15dd			if DEBUG_FORTH_MALLOC_HIGH 
15dd			call malloc_guard_exit 
15dd			call malloc_guard_zerolen 
15dd			endif 
15dd			    ret                ; Return 
15dd			 
15dd			; Free Function: 
15dd			; Input: 
15dd			;   HL: Pointer to memory block to free 
15dd			; Output: 
15dd			;   None 
15dd			 
15dd			free: 
15dd			    push af            ; Save AF register 
15dd			    ld a, l            ; Load low byte of pointer into A 
15dd			    or h               ; Check if pointer is NULL 
15dd			    jp z, free_exit    ; If pointer is NULL, exit 
15dd			 
15dd			    ; Free memory 
15dd			    ld hl, (heap_start) ; Load start of heap into HL 
15dd			    call free_internal  ; Call internal free function 
15dd			    pop af             ; Restore AF register 
15dd			    ret                ; Return 
15dd			 
15dd			; Internal Malloc Function: 
15dd			; Input: 
15dd			;   HL: Size of block to allocate 
15dd			; Output: 
15dd			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
15dd			 
15dd			malloc_internal: 
15dd			    ld bc, 2           ; Number of bytes to allocate for management overhead 
15dd			    add hl, bc         ; Add management overhead to requested size 
15dd			    ex de, hl          ; Save total size in DE, and keep it in HL 
15dd					if DEBUG_FORTH_MALLOC 
15dd						DMARK "ma2" 
15dd						CALLMONITOR 
15dd					endif 
15dd			 
15dd			    ; Search for free memory block 
15dd			    ld de, (heap_end)  ; Load end of heap into DE 
15dd			    ld bc, 0           ; Initialize counter 
15dd			 
15dd					if DEBUG_FORTH_MALLOC 
15dd						DMARK "ma2" 
15dd						CALLMONITOR 
15dd					endif 
15dd			malloc_search_loop: 
15dd			    ; Check if current block is free 
15dd			    ld a, (hl)         ; Load current block's status (free or used) 
15dd			    cp 0               ; Compare with zero (free) 
15dd			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
15dd			 
15dd			    ; Check if current block is large enough 
15dd			    ld a, (hl+1)       ; Load high byte of block size 
15dd			    cp l               ; Compare with low byte of requested size 
15dd			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
15dd			 
15dd			    ld a, (hl+2)       ; Load low byte of block size 
15dd			    cp h               ; Compare with high byte of requested size 
15dd			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
15dd			 
15dd			    ; Mark block as used 
15dd			    ld (hl), 0xFF      ; Set status byte to indicate used block 
15dd			 
15dd			    ; Calculate remaining space in block 
15dd			    ld bc, 0           ; Clear BC 
15dd			    add hl, bc         ; Increment HL to point to start of data block 
15dd			    add hl, de         ; HL = HL + DE (total size) 
15dd			    ld bc, 1           ; Number of bytes to allocate for management overhead 
15dd			    add hl, bc         ; Add management overhead to start of data block 
15dd			 
15dd			    ; Save pointer to allocated block in HL 
15dd			if DEBUG_FORTH_MALLOC_HIGH 
15dd						DMARK "ma5" 
15dd			call malloc_guard_exit 
15dd			call malloc_guard_zerolen 
15dd			endif 
15dd			    ret 
15dd			 
15dd			malloc_skip_block_check: 
15dd			    ; Move to the next block 
15dd			    ld bc, 3           ; Size of management overhead 
15dd			    add hl, bc         ; Move to the next block 
15dd			    inc de             ; Increment counter 
15dd			 
15dd			    ; Check if we have reached the end of heap 
15dd			    ld a, e            ; Load low byte of heap end address 
15dd			    cp (hl)            ; Compare with low byte of current address 
15dd			    jr nz, malloc_search_loop  ; If not equal, continue searching 
15dd			    ld a, d            ; Load high byte of heap end address 
15dd			    cp 0               ; Check if it's zero (end of memory) 
15dd			    jr nz, malloc_search_loop  ; If not zero, continue searching 
15dd			 
15dd			    ; If we reached here, allocation failed 
15dd			    xor a              ; Set result to NULL 
15dd			if DEBUG_FORTH_MALLOC_HIGH 
15dd						DMARK "ma6" 
15dd			call malloc_guard_exit 
15dd			call malloc_guard_zerolen 
15dd			endif 
15dd			    ret 
15dd			malloc_exit: 
15dd			if DEBUG_FORTH_MALLOC_HIGH 
15dd						DMARK "ma7" 
15dd			call malloc_guard_exit 
15dd			call malloc_guard_zerolen 
15dd			endif 
15dd			    ret 
15dd			 
15dd			; Internal Free Function: 
15dd			; Input: 
15dd			;   HL: Pointer to memory block to free 
15dd			; Output: 
15dd			;   None 
15dd			 
15dd			free_internal: 
15dd			    ld de, (heap_start) ; Load start of heap into DE 
15dd			    ld bc, 0            ; Initialize counter 
15dd			 
15dd			free_search_loop: 
15dd			    ; Check if current block contains the pointer 
15dd			    ld a, l             ; Load low byte of pointer 
15dd			    cp (hl+1)           ; Compare with high byte of current block's address 
15dd			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
15dd			    ld a, h             ; Load high byte of pointer 
15dd			    cp (hl+2)           ; Compare with low byte of current block's address 
15dd			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
15dd			 
15dd			    ; Mark block as free 
15dd			    ld (hl), 0          ; Set status byte to indicate free block 
15dd			    ret                 ; Return 
15dd			 
15dd			free_skip_block_check: 
15dd			    ; Move to the next block 
15dd			    ld bc, 3            ; Size of management overhead 
15dd			    add hl, bc          ; Move to the next block 
15dd			    inc de              ; Increment counter 
15dd			 
15dd			    ; Check if we have reached the end of heap 
15dd			    ld a, e             ; Load low byte of heap end address 
15dd			    cp (hl)             ; Compare with low byte of current address 
15dd			    jr nz, free_search_loop  ; If not equal, continue searching 
15dd			    ld a, d             ; Load high byte of heap end address 
15dd			    cp 0                ; Check if it's zero (end of memory) 
15dd			    jr nz, free_search_loop  ; If not zero, continue searching 
15dd			 
15dd			    ; If we reached here, pointer is not found in heap 
15dd			    ret 
15dd			 
15dd			free_exit: 
15dd			    ret                 ; Return 
15dd			 
15dd			; Define heap start and end addresses 
15dd			;heap_start:    .dw 0xC000   ; Start of heap 
15dd			;heap_end:      .dw 0xE000   ; End of heap 
15dd			 
15dd			endif 
15dd			 
15dd			 
15dd			if MALLOC_1 
15dd			 
15dd			 
15dd			 
15dd			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
15dd			 
15dd			;moved to firmware.asm 
15dd			;heap_start        .equ  0x9000      ; Starting address of heap 
15dd			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15dd			 
15dd			;      .org 0 
15dd			;      jp    main 
15dd			 
15dd			 
15dd			;      .org  0x100 
15dd			;main: 
15dd			;      ld    HL, 0x8100 
15dd			;      ld    SP, HL 
15dd			; 
15dd			;      call  heap_init 
15dd			; 
15dd			;      ; Make some allocations 
15dd			;      ld    HL, 12 
15dd			;      call  malloc            ; Allocates 0x9004 
15dd			; 
15dd			;      ld    HL, 12 
15dd			;      call  malloc            ; Allocates 0x9014 
15dd			; 
15dd			;      ld    HL, 12 
15dd			;      call  malloc            ; Allocates 0x9024 
15dd			; 
15dd			;      ; Free some allocations 
15dd			;      ld    HL, 0x9014 
15dd			;      call  free 
15dd			; 
15dd			;      ld    HL, 0x9004 
15dd			;      call  free 
15dd			; 
15dd			;      ld    HL, 0x9024 
15dd			;      call  free 
15dd			; 
15dd			; 
15dd			;      halt 
15dd			 
15dd			 
15dd			;------------------------------------------------------------------------------ 
15dd			;     heap_init                                                               : 
15dd			;                                                                             : 
15dd			; Description                                                                 : 
15dd			;     Initialise the heap and make it ready for malloc and free operations.   : 
15dd			;                                                                             : 
15dd			;     The heap is maintained as a linked list, starting with an initial       : 
15dd			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15dd			;     the first free block in the heap. Each block then points to the next    : 
15dd			;     free block within the heap, and the free list ends at the first block   : 
15dd			;     with a null pointer to the next free block.                             : 
15dd			;                                                                             : 
15dd			; Parameters                                                                  : 
15dd			;     Inputs are compile-time only. Two defines which specify the starting    : 
15dd			;     address of the heap and its size are required, along with a memory      : 
15dd			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15dd			;     principally stores a pointer to the first free block in the heap.       : 
15dd			;                                                                             : 
15dd			; Returns                                                                     : 
15dd			;     Nothing                                                                 : 
15dd			;------------------------------------------------------------------------------ 
15dd			heap_init: 
15dd e5			      push  HL 
15de			 
15de			      ; Initialise free list struct 
15de 21 0e 80		      ld    HL, heap_start 
15e1 22 0a 80		      ld    (free_list), HL 
15e4 21 00 00		      ld    HL, 0 
15e7 22 0c 80		      ld    (free_list+2), HL 
15ea			 
15ea			      ; Insert first free block at bottom of heap, consumes entire heap 
15ea 21 d3 f0		      ld    HL, heap_start+heap_size-4 
15ed 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
15f0 21 c5 70		      ld    HL, heap_size-4 
15f3 22 10 80		      ld    (heap_start+2), HL      ; Block size 
15f6			 
15f6			      ; Insert end of free list block at top of heap - two null words will 
15f6			      ; terminate the free list 
15f6 21 00 00		      ld    HL, 0 
15f9 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
15fc 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
15ff			 
15ff e1			      pop   HL 
1600			 
1600 c9			      ret 
1601			 
1601			 
1601			;------------------------------------------------------------------------------ 
1601			;     malloc                                                                  : 
1601			;                                                                             : 
1601			; Description                                                                 : 
1601			;     Allocates the wanted space from the heap and returns the address of the : 
1601			;     first useable byte of the allocation.                                   : 
1601			;                                                                             : 
1601			;     Allocations can happen in one of two ways:                              : 
1601			;                                                                             : 
1601			;     1. A free block may be found which is the exact size wanted. In this    : 
1601			;        case the block is removed from the free list and retuedn to the      : 
1601			;        caller.                                                              : 
1601			;     2. A free block may be found which is larger than the size wanted. In   : 
1601			;        this case, the larger block is split into two. The first portion of  : 
1601			;        this block will become the requested space by the malloc call and    : 
1601			;        is returned to the caller. The second portion becomes a new free     : 
1601			;        block, and the free list is adjusted to maintain continuity via this : 
1601			;        newly created block.                                                 : 
1601			;                                                                             : 
1601			;     malloc does not set any initial value in the allocated space, the       : 
1601			;     caller is required to do this as required.                              : 
1601			;                                                                             : 
1601			;     This implementation of malloc uses the stack exclusively, and is        : 
1601			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1601			;     advisable to disable interrupts before calling malloc, and recommended  : 
1601			;     to avoid the use of malloc inside ISRs in general.                      : 
1601			;                                                                             : 
1601			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1601			;                                                                             : 
1601			; Parameters                                                                  : 
1601			;     HL  Number of bytes wanted                                              : 
1601			;                                                                             : 
1601			; Returns                                                                     : 
1601			;     HL  Address of the first useable byte of the allocation                 : 
1601			;                                                                             : 
1601			; Flags                                                                       : 
1601			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1601			;                                                                             : 
1601			; Stack frame                                                                 : 
1601			;       |             |                                                       : 
1601			;       +-------------+                                                       : 
1601			;       |     BC      |                                                       : 
1601			;       +-------------+                                                       : 
1601			;       |     DE      |                                                       : 
1601			;       +-------------+                                                       : 
1601			;       |     IX      |                                                       : 
1601			;       +-------------+                                                       : 
1601			;       |  prev_free  |                                                       : 
1601			;   +4  +-------------+                                                       : 
1601			;       |  this_free  |                                                       : 
1601			;   +2  +-------------+                                                       : 
1601			;       |  next_free  |                                                       : 
1601			;   +0  +-------------+                                                       : 
1601			;       |             |                                                       : 
1601			;                                                                             : 
1601			;------------------------------------------------------------------------------ 
1601			 
1601			 
1601			;malloc: 
1601			; 
1601			;	SAVESP ON 1 
1601			; 
1601			;	call malloc_code 
1601			; 
1601			;	CHECKSP ON 1 
1601			;	ret 
1601			 
1601			 
1601			malloc: 
1601 c5			      push  BC 
1602 d5			      push  DE 
1603 dd e5		      push  IX 
1605			if DEBUG_FORTH_MALLOC_HIGH 
1605			call malloc_guard_entry 
1605			endif 
1605			 
1605					if DEBUG_FORTH_MALLOC 
1605						DMARK "mal" 
1605						CALLMONITOR 
1605					endif 
1605 7c			      ld    A, H                    ; Exit if no space requested 
1606 b5			      or    L 
1607 ca c6 16		      jp    Z, malloc_early_exit 
160a			 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			; 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			;inc hl 
160a			 
160a			 
160a			 
160a			 
160a					if DEBUG_FORTH_MALLOC 
160a						DMARK "maA" 
160a						CALLMONITOR 
160a					endif 
160a			      ; Set up stack frame 
160a eb			      ex    DE, HL 
160b 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
160e 39			      add   HL, SP 
160f f9			      ld    SP, HL 
1610 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1614 dd 39		      add   IX, SP 
1616			 
1616			      ; Setup initial state 
1616 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1619 19			      add   HL, DE 
161a			 
161a 44			      ld    B, H                    ; Move want to BC 
161b 4d			      ld    C, L 
161c			 
161c 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
161f dd 75 04		      ld    (IX+4), L 
1622 dd 74 05		      ld    (IX+5), H 
1625			 
1625 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1626 23			      inc   HL 
1627 56			      ld    D, (HL) 
1628 dd 73 02		      ld    (IX+2), E 
162b dd 72 03		      ld    (IX+3), D 
162e eb			      ex    DE, HL                  ; this_free ptr into HL 
162f			 
162f					if DEBUG_FORTH_MALLOC 
162f						DMARK "maB" 
162f						CALLMONITOR 
162f					endif 
162f			      ; Loop through free block list to find some space 
162f			malloc_find_space: 
162f 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1630 23			      inc   HL 
1631 56			      ld    D, (HL) 
1632			 
1632 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1633 b3			      or    E 
1634 ca c0 16		      jp    Z, malloc_no_space 
1637			 
1637 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
163a dd 72 01		      ld    (IX+1), D 
163d			 
163d			      ; Does this block have enough space to make the allocation? 
163d 23			      inc   HL                      ; Load free block size into DE 
163e 5e			      ld    E, (HL) 
163f 23			      inc   HL 
1640 56			      ld    D, (HL) 
1641			 
1641 eb			      ex    DE, HL                  ; Check size of block against want 
1642 b7			      or    A                       ; Ensure carry flag clear 
1643 ed 42		      sbc   HL, BC 
1645 e5			      push  HL                      ; Store the result for later (new block size) 
1646			 
1646 ca 95 16		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1649 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
164b			 
164b			      ; this_free block is not big enough, setup ptrs to test next free block 
164b e1			      pop   HL                      ; Discard previous result 
164c			 
164c dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
164f dd 66 03		      ld    H, (IX+3) 
1652 dd 75 04		      ld    (IX+4), L 
1655 dd 74 05		      ld    (IX+5), H 
1658			 
1658 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
165b dd 66 01		      ld    H, (IX+1) 
165e dd 75 02		      ld    (IX+2), L 
1661 dd 74 03		      ld    (IX+3), H 
1664			 
1664					if DEBUG_FORTH_MALLOC 
1664						DMARK "MA>" 
1664						CALLMONITOR 
1664					endif 
1664 18 c9		      jr    malloc_find_space 
1666			 
1666			      ; split a bigger block into two - requested size and remaining size 
1666			malloc_alloc_split: 
1666					if DEBUG_FORTH_MALLOC 
1666						DMARK "MAs" 
1666						CALLMONITOR 
1666					endif 
1666 eb			      ex    DE, HL                  ; Calculate address of new free block 
1667 2b			      dec   HL 
1668 2b			      dec   HL 
1669 2b			      dec   HL 
166a 09			      add   HL, BC 
166b			 
166b			      ; Create a new block and point it at next_free 
166b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
166e dd 56 01		      ld    D, (IX+1) 
1671			 
1671 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1672 23			      inc   HL 
1673 72			      ld    (HL), D 
1674			 
1674 d1			      pop   DE                      ; Store size of new block into new block 
1675 23			      inc   HL 
1676 73			      ld    (HL), E 
1677 23			      inc   HL 
1678 72			      ld    (HL), D 
1679			 
1679			      ; Update this_free ptr to point to new block 
1679 2b			      dec   HL 
167a 2b			      dec   HL 
167b 2b			      dec   HL 
167c			 
167c dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
167f dd 56 03		      ld    D, (IX+3) 
1682			 
1682 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1685 dd 74 03		      ld    (IX+3), H 
1688			 
1688			      ; Modify this_free block to be allocation 
1688 eb			      ex    DE, HL 
1689 af			      xor   A                       ; Null the next block ptr of allocated block 
168a 77			      ld    (HL), A 
168b 23			      inc   HL 
168c 77			      ld    (HL), A 
168d			 
168d 23			      inc   HL                      ; Store want size into allocated block 
168e 71			      ld    (HL), C 
168f 23			      inc   HL 
1690 70			      ld    (HL), B 
1691 23			      inc   HL 
1692 e5			      push  HL                      ; Address of allocation to return 
1693			 
1693 18 19		      jr    malloc_update_links 
1695			 
1695			malloc_alloc_fit: 
1695 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1696			 
1696					if DEBUG_FORTH_MALLOC 
1696						DMARK "MAf" 
1696						CALLMONITOR 
1696					endif 
1696			      ; Modify this_free block to be allocation 
1696 eb			      ex    DE, HL 
1697 2b			      dec   HL 
1698 2b			      dec   HL 
1699 2b			      dec   HL 
169a			 
169a af			      xor   A                       ; Null the next block ptr of allocated block 
169b 77			      ld    (HL), A 
169c 23			      inc   HL 
169d 77			      ld    (HL), A 
169e			 
169e 23			      inc   HL                      ; Store address of allocation to return 
169f 23			      inc   HL 
16a0 23			      inc   HL 
16a1 e5			      push  HL 
16a2			 
16a2			      ; Copy next_free ptr to this_free, remove allocated block from free list 
16a2 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
16a5 dd 66 01		      ld    H, (IX+1) 
16a8			 
16a8 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
16ab dd 74 03		      ld    (IX+3), H 
16ae			 
16ae			 
16ae			malloc_update_links: 
16ae			      ; Update prev_free ptr to point to this_free 
16ae dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
16b1 dd 66 05		      ld    H, (IX+5) 
16b4			 
16b4 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
16b7 dd 56 03		      ld    D, (IX+3) 
16ba			 
16ba 73			      ld    (HL), E                 ; this_free ptr into prev_free 
16bb 23			      inc   HL 
16bc 72			      ld    (HL), D 
16bd			 
16bd					if DEBUG_FORTH_MALLOC 
16bd						DMARK "Mul" 
16bd						CALLMONITOR 
16bd					endif 
16bd			      ; Clear the Z flag to indicate successful allocation 
16bd 7a			      ld    A, D 
16be b3			      or    E 
16bf			 
16bf d1			      pop   DE                      ; Address of allocation 
16c0					if DEBUG_FORTH_MALLOC 
16c0						DMARK "MAu" 
16c0						CALLMONITOR 
16c0					endif 
16c0			 
16c0			malloc_no_space: 
16c0 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
16c3 39			      add   HL, SP 
16c4 f9			      ld    SP, HL 
16c5			 
16c5 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
16c6					if DEBUG_FORTH_MALLOC 
16c6						DMARK "MAN" 
16c6						CALLMONITOR 
16c6					endif 
16c6			 
16c6			malloc_early_exit: 
16c6					if DEBUG_FORTH_MALLOC 
16c6						DMARK "MAx" 
16c6						CALLMONITOR 
16c6					endif 
16c6 dd e1		      pop   IX 
16c8 d1			      pop   DE 
16c9 c1			      pop   BC 
16ca			 
16ca			if DEBUG_FORTH_MALLOC_HIGH 
16ca			call malloc_guard_exit 
16ca			call malloc_guard_zerolen 
16ca			endif 
16ca c9			      ret 
16cb			 
16cb			 
16cb			;------------------------------------------------------------------------------ 
16cb			;     free                                                                    : 
16cb			;                                                                             : 
16cb			; Description                                                                 : 
16cb			;     Return the space pointed to by HL to the heap. HL must be an address as : 
16cb			;     returned by malloc, otherwise the behaviour is undefined.               : 
16cb			;                                                                             : 
16cb			;     Where possible, directly adjacent free blocks will be merged together   : 
16cb			;     into larger blocks to help ensure that the heap does not become         : 
16cb			;     excessively fragmented.                                                 : 
16cb			;                                                                             : 
16cb			;     free does not clear or set any other value into the freed space, and    : 
16cb			;     therefore its contents may be visible through subsequent malloc's. The  : 
16cb			;     caller should clear the freed space as required.                        : 
16cb			;                                                                             : 
16cb			;     This implementation of free uses the stack exclusively, and is          : 
16cb			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
16cb			;     advisable to disable interrupts before calling free, and recommended    : 
16cb			;     to avoid the use of free inside ISRs in general.                        : 
16cb			;                                                                             : 
16cb			;     NOTE: heap_init must be called before malloc and free can be used.      : 
16cb			;                                                                             : 
16cb			; Parameters                                                                  : 
16cb			;     HL  Pointer to address of first byte of allocation to be freed          : 
16cb			;                                                                             : 
16cb			; Returns                                                                     : 
16cb			;     Nothing                                                                 : 
16cb			;                                                                             : 
16cb			; Stack frame                                                                 : 
16cb			;       |             |                                                       : 
16cb			;       +-------------+                                                       : 
16cb			;       |     BC      |                                                       : 
16cb			;       +-------------+                                                       : 
16cb			;       |     DE      |                                                       : 
16cb			;       +-------------+                                                       : 
16cb			;       |     IX      |                                                       : 
16cb			;       +-------------+                                                       : 
16cb			;       |  prev_free  |                                                       : 
16cb			;   +2  +-------------+                                                       : 
16cb			;       |  next_free  |                                                       : 
16cb			;   +0  +-------------+                                                       : 
16cb			;       |             |                                                       : 
16cb			;                                                                             : 
16cb			;------------------------------------------------------------------------------ 
16cb			free: 
16cb c5			      push  BC 
16cc d5			      push  DE 
16cd dd e5		      push  IX 
16cf			 
16cf 7c			      ld    A, H                    ; Exit if ptr is null 
16d0 b5			      or    L 
16d1 ca 95 17		      jp    Z, free_early_exit 
16d4			 
16d4			      ; Set up stack frame 
16d4 eb			      ex    DE, HL 
16d5 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
16d8 39			      add   HL, SP 
16d9 f9			      ld    SP, HL 
16da dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
16de dd 39		      add   IX, SP 
16e0			 
16e0			      ; The address in HL points to the start of the useable allocated space, 
16e0			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
16e0			      ; address of the block itself. 
16e0 eb			      ex    DE, HL 
16e1 11 fc ff		      ld    DE, -4 
16e4 19			      add   HL, DE 
16e5			 
16e5			      ; An allocated block must have a null next block pointer in it 
16e5 7e			      ld    A, (HL) 
16e6 23			      inc   HL 
16e7 b6			      or    (HL) 
16e8 c2 90 17		      jp    NZ, free_done 
16eb			 
16eb 2b			      dec   HL 
16ec			 
16ec 44			      ld    B, H                    ; Copy HL to BC 
16ed 4d			      ld    C, L 
16ee			 
16ee			      ; Loop through the free list to find the first block with an address 
16ee			      ; higher than the block being freed 
16ee 21 0a 80		      ld    HL, free_list 
16f1			 
16f1			free_find_higher_block: 
16f1 5e			      ld    E, (HL)                 ; Load next ptr from free block 
16f2 23			      inc   HL 
16f3 56			      ld    D, (HL) 
16f4 2b			      dec   HL 
16f5			 
16f5 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
16f8 dd 72 01		      ld    (IX+1), D 
16fb dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
16fe dd 74 03		      ld    (IX+3), H 
1701			 
1701 78			      ld    A, B                    ; Check if DE is greater than BC 
1702 ba			      cp    D                       ; Compare MSB first 
1703 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1705 30 04		      jr    NC, free_find_higher_block_skip 
1707 79			      ld    A, C 
1708 bb			      cp    E                       ; Then compare LSB 
1709 38 08		      jr    C, free_found_higher_block 
170b			 
170b			free_find_higher_block_skip: 
170b 7a			      ld    A, D                    ; Reached the end of the free list? 
170c b3			      or    E 
170d ca 90 17		      jp    Z, free_done 
1710			 
1710 eb			      ex    DE, HL 
1711			 
1711 18 de		      jr    free_find_higher_block 
1713			 
1713			free_found_higher_block: 
1713			      ; Insert freed block between prev and next free blocks 
1713 71			      ld    (HL), C                 ; Point prev free block to freed block 
1714 23			      inc   HL 
1715 70			      ld    (HL), B 
1716			 
1716 60			      ld    H, B                    ; Point freed block at next free block 
1717 69			      ld    L, C 
1718 73			      ld    (HL), E 
1719 23			      inc   HL 
171a 72			      ld    (HL), D 
171b			 
171b			      ; Check if the freed block is adjacent to the next free block 
171b 23			      inc   HL                      ; Load size of freed block into HL 
171c 5e			      ld    E, (HL) 
171d 23			      inc   HL 
171e 56			      ld    D, (HL) 
171f eb			      ex    DE, HL 
1720			 
1720 09			      add   HL, BC                  ; Add addr of freed block and its size 
1721			 
1721 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1724 dd 56 01		      ld    D, (IX+1) 
1727			 
1727 b7			      or    A                       ; Clear the carry flag 
1728 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
172a 20 22		      jr    NZ, free_check_adjacent_to_prev 
172c			 
172c			      ; Freed block is adjacent to next, merge into one bigger block 
172c eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
172d 5e			      ld    E, (HL) 
172e 23			      inc   HL 
172f 56			      ld    D, (HL) 
1730 e5			      push  HL                      ; Save ptr to next block for later 
1731			 
1731 60			      ld    H, B                    ; Store ptr from next block into freed block 
1732 69			      ld    L, C 
1733 73			      ld    (HL), E 
1734 23			      inc   HL 
1735 72			      ld    (HL), D 
1736			 
1736 e1			      pop   HL                      ; Restore ptr to next block 
1737 23			      inc   HL                      ; Load size of next block into DE 
1738 5e			      ld    E, (HL) 
1739 23			      inc   HL 
173a 56			      ld    D, (HL) 
173b d5			      push  DE                      ; Save next block size for later 
173c			 
173c 60			      ld    H, B                    ; Load size of freed block into HL 
173d 69			      ld    L, C 
173e 23			      inc   HL 
173f 23			      inc   HL 
1740 5e			      ld    E, (HL) 
1741 23			      inc   HL 
1742 56			      ld    D, (HL) 
1743 eb			      ex    DE, HL 
1744			 
1744 d1			      pop   DE                      ; Restore size of next block 
1745 19			      add   HL, DE                  ; Add sizes of both blocks 
1746 eb			      ex    DE, HL 
1747			 
1747 60			      ld    H, B                    ; Store new bigger size into freed block 
1748 69			      ld    L, C 
1749 23			      inc   HL 
174a 23			      inc   HL 
174b 73			      ld    (HL), E 
174c 23			      inc   HL 
174d 72			      ld    (HL), D 
174e			 
174e			free_check_adjacent_to_prev: 
174e			      ; Check if the freed block is adjacent to the prev free block 
174e dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1751 dd 66 03		      ld    H, (IX+3) 
1754			 
1754 23			      inc   HL                      ; Size of prev free block into DE 
1755 23			      inc   HL 
1756 5e			      ld    E, (HL) 
1757 23			      inc   HL 
1758 56			      ld    D, (HL) 
1759 2b			      dec   HL 
175a 2b			      dec   HL 
175b 2b			      dec   HL 
175c			 
175c 19			      add   HL, DE                  ; Add prev block addr and size 
175d			 
175d b7			      or    A                       ; Clear the carry flag 
175e ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1760 20 2e		      jr    NZ, free_done 
1762			 
1762			      ; Freed block is adjacent to prev, merge into one bigger block 
1762 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1763 69			      ld    L, C 
1764 5e			      ld    E, (HL) 
1765 23			      inc   HL 
1766 56			      ld    D, (HL) 
1767 e5			      push  HL                      ; Save freed block ptr for later 
1768			 
1768 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
176b dd 66 03		      ld    H, (IX+3) 
176e 73			      ld    (HL), E 
176f 23			      inc   HL 
1770 72			      ld    (HL), D 
1771			 
1771 e1			      pop   HL                      ; Restore freed block ptr 
1772 23			      inc   HL                      ; Load size of freed block into DE 
1773 5e			      ld    E, (HL) 
1774 23			      inc   HL 
1775 56			      ld    D, (HL) 
1776 d5			      push  DE                      ; Save freed block size for later 
1777			 
1777 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
177a dd 66 03		      ld    H, (IX+3) 
177d 23			      inc   HL 
177e 23			      inc   HL 
177f 5e			      ld    E, (HL) 
1780 23			      inc   HL 
1781 56			      ld    D, (HL) 
1782			 
1782 e1			      pop   HL                      ; Add sizes of both blocks 
1783 19			      add   HL, DE 
1784 eb			      ex    DE, HL 
1785			 
1785 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1788 dd 66 03		      ld    H, (IX+3) 
178b 23			      inc   HL 
178c 23			      inc   HL 
178d 73			      ld    (HL), E 
178e 23			      inc   HL 
178f 72			      ld    (HL), D 
1790			 
1790			free_done: 
1790 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1793 39			      add   HL, SP 
1794 f9			      ld    SP, HL 
1795			 
1795			free_early_exit: 
1795 dd e1		      pop   IX 
1797 d1			      pop   DE 
1798 c1			      pop   BC 
1799			 
1799 c9			      ret 
179a			 
179a			; moved to firmware.asm 
179a			; 
179a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
179a			;                  .dw   0 
179a			 
179a			 
179a			endif 
179a			 
179a			 
179a			if MALLOC_3 
179a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
179a			;heap_start        .equ  0x9000      ; Starting address of heap 
179a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
179a			; 
179a			 ;     .org 0 
179a			  ;    jp    main 
179a			; 
179a			; 
179a			 ;     .org  0x100 
179a			;main: 
179a			 ;     ld    HL, 0x8100 
179a			  ;    ld    SP, HL 
179a			; 
179a			;      call  heap_init 
179a			 
179a			      ; Make some allocations 
179a			;      ld    HL, 12 
179a			;      call  malloc            ; Allocates 0x9004 
179a			; 
179a			 ;     ld    HL, 12 
179a			;      call  malloc            ; Allocates 0x9014 
179a			 
179a			;      ld    HL, 12 
179a			;      call  malloc            ; Allocates 0x9024 
179a			 
179a			      ; Free some allocations 
179a			;      ld    HL, 0x9014 
179a			;      call  free 
179a			 
179a			;      ld    HL, 0x9004 
179a			;      call  free 
179a			; 
179a			;      ld    HL, 0x9024 
179a			;      call  free 
179a			 
179a			 
179a			 ;     halt 
179a			 
179a			 
179a			;------------------------------------------------------------------------------ 
179a			;     heap_init                                                               : 
179a			;                                                                             : 
179a			; Description                                                                 : 
179a			;     Initialise the heap and make it ready for malloc and free operations.   : 
179a			;                                                                             : 
179a			;     The heap is maintained as a linked list, starting with an initial       : 
179a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
179a			;     the first free block in the heap. Each block then points to the next    : 
179a			;     free block within the heap, and the free list ends at the first block   : 
179a			;     with a null pointer to the next free block.                             : 
179a			;                                                                             : 
179a			; Parameters                                                                  : 
179a			;     Inputs are compile-time only. Two defines which specify the starting    : 
179a			;     address of the heap and its size are required, along with a memory      : 
179a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
179a			;     principally stores a pointer to the first free block in the heap.       : 
179a			;                                                                             : 
179a			; Returns                                                                     : 
179a			;     Nothing                                                                 : 
179a			;------------------------------------------------------------------------------ 
179a			heap_init: 
179a			      push  HL 
179a			 
179a			      ; Initialise free list struct 
179a			      ld    HL, heap_start 
179a			      ld    (free_list), HL 
179a			      ld    HL, 0 
179a			      ld    (free_list+2), HL 
179a			 
179a			      ; Insert first free block at bottom of heap, consumes entire heap 
179a			      ld    HL, heap_start+heap_size-4 
179a			      ld    (heap_start), HL        ; Next block (end of free list) 
179a			      ld    HL, heap_size-4 
179a			      ld    (heap_start+2), HL      ; Block size 
179a			 
179a			      ; Insert end of free list block at top of heap - two null words will 
179a			      ; terminate the free list 
179a			      ld    HL, 0 
179a			      ld    (heap_start+heap_size-2), HL 
179a			      ld    (heap_start+heap_size-4), HL 
179a			 
179a			      pop   HL 
179a			 
179a			      ret 
179a			 
179a			 
179a			;------------------------------------------------------------------------------ 
179a			;     malloc                                                                  : 
179a			;                                                                             : 
179a			; Description                                                                 : 
179a			;     Allocates the wanted space from the heap and returns the address of the : 
179a			;     first useable byte of the allocation.                                   : 
179a			;                                                                             : 
179a			;     Allocations can happen in one of two ways:                              : 
179a			;                                                                             : 
179a			;     1. A free block may be found which is the exact size wanted. In this    : 
179a			;        case the block is removed from the free list and retuedn to the      : 
179a			;        caller.                                                              : 
179a			;     2. A free block may be found which is larger than the size wanted. In   : 
179a			;        this case, the larger block is split into two. The first portion of  : 
179a			;        this block will become the requested space by the malloc call and    : 
179a			;        is returned to the caller. The second portion becomes a new free     : 
179a			;        block, and the free list is adjusted to maintain continuity via this : 
179a			;        newly created block.                                                 : 
179a			;                                                                             : 
179a			;     malloc does not set any initial value in the allocated space, the       : 
179a			;     caller is required to do this as required.                              : 
179a			;                                                                             : 
179a			;     This implementation of malloc uses the stack exclusively, and is        : 
179a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
179a			;     advisable to disable interrupts before calling malloc, and recommended  : 
179a			;     to avoid the use of malloc inside ISRs in general.                      : 
179a			;                                                                             : 
179a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
179a			;                                                                             : 
179a			; Parameters                                                                  : 
179a			;     HL  Number of bytes wanted                                              : 
179a			;                                                                             : 
179a			; Returns                                                                     : 
179a			;     HL  Address of the first useable byte of the allocation                 : 
179a			;                                                                             : 
179a			; Flags                                                                       : 
179a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
179a			;                                                                             : 
179a			; Stack frame                                                                 : 
179a			;       |             |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |     BC      |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |     DE      |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |     IX      |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |  prev_free  |                                                       : 
179a			;   +4  +-------------+                                                       : 
179a			;       |  this_free  |                                                       : 
179a			;   +2  +-------------+                                                       : 
179a			;       |  next_free  |                                                       : 
179a			;   +0  +-------------+                                                       : 
179a			;       |             |                                                       : 
179a			;                                                                             : 
179a			;------------------------------------------------------------------------------ 
179a			malloc: 
179a			      push  BC 
179a			      push  DE 
179a			      push  IX 
179a			 
179a			      ld    A, H                    ; Exit if no space requested 
179a			      or    L 
179a			      jp    Z, malloc_early_exit 
179a			 
179a			      ; Set up stack frame 
179a			      ex    DE, HL 
179a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
179a			      add   HL, SP 
179a			      ld    SP, HL 
179a			      ld    IX, 0                   ; Use IX as a frame pointer 
179a			      add   IX, SP 
179a			 
179a			      ; Setup initial state 
179a			      ld    HL, 4                   ; want must also include space used by block struct 
179a			      add   HL, DE 
179a			 
179a			      ld    B, H                    ; Move want to BC 
179a			      ld    C, L 
179a			 
179a			      ld    HL, free_list           ; Store prev_free ptr to stack 
179a			      ld    (IX+4), L 
179a			      ld    (IX+5), H 
179a			 
179a			      ld    E, (HL)                 ; Store this_free ptr to stack 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      ld    (IX+2), E 
179a			      ld    (IX+3), D 
179a			      ex    DE, HL                  ; this_free ptr into HL 
179a			 
179a			      ; Loop through free block list to find some space 
179a			malloc_find_space: 
179a			      ld    E, (HL)                 ; Load next_free ptr into DE 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			 
179a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
179a			      or    E 
179a			      jp    Z, malloc_no_space 
179a			 
179a			      ld    (IX+0), E               ; Store next_free ptr to stack 
179a			      ld    (IX+1), D 
179a			 
179a			      ; Does this block have enough space to make the allocation? 
179a			      inc   HL                      ; Load free block size into DE 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			 
179a			      ex    DE, HL                  ; Check size of block against want 
179a			      or    A                       ; Ensure carry flag clear 
179a			      sbc   HL, BC 
179a			      push  HL                      ; Store the result for later (new block size) 
179a			 
179a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
179a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
179a			 
179a			      ; this_free block is not big enough, setup ptrs to test next free block 
179a			      pop   HL                      ; Discard previous result 
179a			 
179a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
179a			      ld    H, (IX+3) 
179a			      ld    (IX+4), L 
179a			      ld    (IX+5), H 
179a			 
179a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
179a			      ld    H, (IX+1) 
179a			      ld    (IX+2), L 
179a			      ld    (IX+3), H 
179a			 
179a			      jr    malloc_find_space 
179a			 
179a			      ; split a bigger block into two - requested size and remaining size 
179a			malloc_alloc_split: 
179a			      ex    DE, HL                  ; Calculate address of new free block 
179a			      dec   HL 
179a			      dec   HL 
179a			      dec   HL 
179a			      add   HL, BC 
179a			 
179a			      ; Create a new block and point it at next_free 
179a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
179a			      ld    D, (IX+1) 
179a			 
179a			      ld    (HL), E                 ; Store next_free ptr into new block 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			      pop   DE                      ; Store size of new block into new block 
179a			      inc   HL 
179a			      ld    (HL), E 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			      ; Update this_free ptr to point to new block 
179a			      dec   HL 
179a			      dec   HL 
179a			      dec   HL 
179a			 
179a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
179a			      ld    D, (IX+3) 
179a			 
179a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
179a			      ld    (IX+3), H 
179a			 
179a			      ; Modify this_free block to be allocation 
179a			      ex    DE, HL 
179a			      xor   A                       ; Null the next block ptr of allocated block 
179a			      ld    (HL), A 
179a			      inc   HL 
179a			      ld    (HL), A 
179a			 
179a			      inc   HL                      ; Store want size into allocated block 
179a			      ld    (HL), C 
179a			      inc   HL 
179a			      ld    (HL), B 
179a			      inc   HL 
179a			      push  HL                      ; Address of allocation to return 
179a			 
179a			      jr    malloc_update_links 
179a			 
179a			malloc_alloc_fit: 
179a			      pop   HL                      ; Dont need new block size, want is exact fit 
179a			 
179a			      ; Modify this_free block to be allocation 
179a			      ex    DE, HL 
179a			      dec   HL 
179a			      dec   HL 
179a			      dec   HL 
179a			 
179a			      xor   A                       ; Null the next block ptr of allocated block 
179a			      ld    (HL), A 
179a			      inc   HL 
179a			      ld    (HL), A 
179a			 
179a			      inc   HL                      ; Store address of allocation to return 
179a			      inc   HL 
179a			      inc   HL 
179a			      push  HL 
179a			 
179a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
179a			      ld    L, (IX+0)               ; next_free to HL 
179a			      ld    H, (IX+1) 
179a			 
179a			      ld    (IX+2), L               ; HL to this_free 
179a			      ld    (IX+3), H 
179a			 
179a			 
179a			malloc_update_links: 
179a			      ; Update prev_free ptr to point to this_free 
179a			      ld    L, (IX+4)               ; prev_free ptr to HL 
179a			      ld    H, (IX+5) 
179a			 
179a			      ld    E, (IX+2)               ; this_free ptr to DE 
179a			      ld    D, (IX+3) 
179a			 
179a			      ld    (HL), E                 ; this_free ptr into prev_free 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			      ; Clear the Z flag to indicate successful allocation 
179a			      ld    A, D 
179a			      or    E 
179a			 
179a			      pop   DE                      ; Address of allocation 
179a			 
179a			malloc_no_space: 
179a			      ld    HL, 6                   ; Clean up stack frame 
179a			      add   HL, SP 
179a			      ld    SP, HL 
179a			 
179a			      ex    DE, HL                  ; Alloc addr into HL for return 
179a			 
179a			malloc_early_exit: 
179a			      pop   IX 
179a			      pop   DE 
179a			      pop   BC 
179a			 
179a			      ret 
179a			 
179a			 
179a			;------------------------------------------------------------------------------ 
179a			;     free                                                                    : 
179a			;                                                                             : 
179a			; Description                                                                 : 
179a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
179a			;     returned by malloc, otherwise the behaviour is undefined.               : 
179a			;                                                                             : 
179a			;     Where possible, directly adjacent free blocks will be merged together   : 
179a			;     into larger blocks to help ensure that the heap does not become         : 
179a			;     excessively fragmented.                                                 : 
179a			;                                                                             : 
179a			;     free does not clear or set any other value into the freed space, and    : 
179a			;     therefore its contents may be visible through subsequent malloc's. The  : 
179a			;     caller should clear the freed space as required.                        : 
179a			;                                                                             : 
179a			;     This implementation of free uses the stack exclusively, and is          : 
179a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
179a			;     advisable to disable interrupts before calling free, and recommended    : 
179a			;     to avoid the use of free inside ISRs in general.                        : 
179a			;                                                                             : 
179a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
179a			;                                                                             : 
179a			; Parameters                                                                  : 
179a			;     HL  Pointer to address of first byte of allocation to be freed          : 
179a			;                                                                             : 
179a			; Returns                                                                     : 
179a			;     Nothing                                                                 : 
179a			;                                                                             : 
179a			; Stack frame                                                                 : 
179a			;       |             |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |     BC      |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |     DE      |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |     IX      |                                                       : 
179a			;       +-------------+                                                       : 
179a			;       |  prev_free  |                                                       : 
179a			;   +2  +-------------+                                                       : 
179a			;       |  next_free  |                                                       : 
179a			;   +0  +-------------+                                                       : 
179a			;       |             |                                                       : 
179a			;                                                                             : 
179a			;------------------------------------------------------------------------------ 
179a			free: 
179a			      push  BC 
179a			      push  DE 
179a			      push  IX 
179a			 
179a			      ld    A, H                    ; Exit if ptr is null 
179a			      or    L 
179a			      jp    Z, free_early_exit 
179a			 
179a			      ; Set up stack frame 
179a			      ex    DE, HL 
179a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
179a			      add   HL, SP 
179a			      ld    SP, HL 
179a			      ld    IX, 0                   ; Use IX as a frame pointer 
179a			      add   IX, SP 
179a			 
179a			      ; The address in HL points to the start of the useable allocated space, 
179a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
179a			      ; address of the block itself. 
179a			      ex    DE, HL 
179a			      ld    DE, -4 
179a			      add   HL, DE 
179a			 
179a			      ; An allocated block must have a null next block pointer in it 
179a			      ld    A, (HL) 
179a			      inc   HL 
179a			      or    (HL) 
179a			      jp    NZ, free_done 
179a			 
179a			      dec   HL 
179a			 
179a			      ld    B, H                    ; Copy HL to BC 
179a			      ld    C, L 
179a			 
179a			      ; Loop through the free list to find the first block with an address 
179a			      ; higher than the block being freed 
179a			      ld    HL, free_list 
179a			 
179a			free_find_higher_block: 
179a			      ld    E, (HL)                 ; Load next ptr from free block 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      dec   HL 
179a			 
179a			      ld    (IX+0), E               ; Save ptr to next free block 
179a			      ld    (IX+1), D 
179a			      ld    (IX+2), L               ; Save ptr to prev free block 
179a			      ld    (IX+3), H 
179a			 
179a			      ld    A, B                    ; Check if DE is greater than BC 
179a			      cp    D                       ; Compare MSB first 
179a			      jr    Z, $+4                  ; MSB the same, compare LSB 
179a			      jr    NC, free_find_higher_block_skip 
179a			      ld    A, C 
179a			      cp    E                       ; Then compare LSB 
179a			      jr    C, free_found_higher_block 
179a			 
179a			free_find_higher_block_skip: 
179a			      ld    A, D                    ; Reached the end of the free list? 
179a			      or    E 
179a			      jp    Z, free_done 
179a			 
179a			      ex    DE, HL 
179a			 
179a			      jr    free_find_higher_block 
179a			 
179a			free_found_higher_block: 
179a			      ; Insert freed block between prev and next free blocks 
179a			      ld    (HL), C                 ; Point prev free block to freed block 
179a			      inc   HL 
179a			      ld    (HL), B 
179a			 
179a			      ld    H, B                    ; Point freed block at next free block 
179a			      ld    L, C 
179a			      ld    (HL), E 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			      ; Check if the freed block is adjacent to the next free block 
179a			      inc   HL                      ; Load size of freed block into HL 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      ex    DE, HL 
179a			 
179a			      add   HL, BC                  ; Add addr of freed block and its size 
179a			 
179a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
179a			      ld    D, (IX+1) 
179a			 
179a			      or    A                       ; Clear the carry flag 
179a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
179a			      jr    NZ, free_check_adjacent_to_prev 
179a			 
179a			      ; Freed block is adjacent to next, merge into one bigger block 
179a			      ex    DE, HL                  ; Load next ptr from next block into DE 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      push  HL                      ; Save ptr to next block for later 
179a			 
179a			      ld    H, B                    ; Store ptr from next block into freed block 
179a			      ld    L, C 
179a			      ld    (HL), E 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			      pop   HL                      ; Restore ptr to next block 
179a			      inc   HL                      ; Load size of next block into DE 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      push  DE                      ; Save next block size for later 
179a			 
179a			      ld    H, B                    ; Load size of freed block into HL 
179a			      ld    L, C 
179a			      inc   HL 
179a			      inc   HL 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      ex    DE, HL 
179a			 
179a			      pop   DE                      ; Restore size of next block 
179a			      add   HL, DE                  ; Add sizes of both blocks 
179a			      ex    DE, HL 
179a			 
179a			      ld    H, B                    ; Store new bigger size into freed block 
179a			      ld    L, C 
179a			      inc   HL 
179a			      inc   HL 
179a			      ld    (HL), E 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			free_check_adjacent_to_prev: 
179a			      ; Check if the freed block is adjacent to the prev free block 
179a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
179a			      ld    H, (IX+3) 
179a			 
179a			      inc   HL                      ; Size of prev free block into DE 
179a			      inc   HL 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      dec   HL 
179a			      dec   HL 
179a			      dec   HL 
179a			 
179a			      add   HL, DE                  ; Add prev block addr and size 
179a			 
179a			      or    A                       ; Clear the carry flag 
179a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
179a			      jr    NZ, free_done 
179a			 
179a			      ; Freed block is adjacent to prev, merge into one bigger block 
179a			      ld    H, B                    ; Load next ptr from freed block into DE 
179a			      ld    L, C 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      push  HL                      ; Save freed block ptr for later 
179a			 
179a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
179a			      ld    H, (IX+3) 
179a			      ld    (HL), E 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			      pop   HL                      ; Restore freed block ptr 
179a			      inc   HL                      ; Load size of freed block into DE 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			      push  DE                      ; Save freed block size for later 
179a			 
179a			      ld    L, (IX+2)               ; Load size of prev block into DE 
179a			      ld    H, (IX+3) 
179a			      inc   HL 
179a			      inc   HL 
179a			      ld    E, (HL) 
179a			      inc   HL 
179a			      ld    D, (HL) 
179a			 
179a			      pop   HL                      ; Add sizes of both blocks 
179a			      add   HL, DE 
179a			      ex    DE, HL 
179a			 
179a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
179a			      ld    H, (IX+3) 
179a			      inc   HL 
179a			      inc   HL 
179a			      ld    (HL), E 
179a			      inc   HL 
179a			      ld    (HL), D 
179a			 
179a			free_done: 
179a			      ld    HL, 4                   ; Clean up stack frame 
179a			      add   HL, SP 
179a			      ld    SP, HL 
179a			 
179a			free_early_exit: 
179a			      pop   IX 
179a			      pop   DE 
179a			      pop   BC 
179a			 
179a			      ret 
179a			 
179a			 
179a			;      .org 0x8000 
179a			; 
179a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
179a			 ;                 .dw   0 
179a			 
179a			endif 
179a			 
179a			 
179a			if MALLOC_4 
179a			 
179a			; My memory allocation code. Very very simple.... 
179a			; allocate space under 250 chars 
179a			 
179a			heap_init: 
179a				; init start of heap as zero 
179a				;  
179a			 
179a				ld hl, heap_start 
179a				ld a, 0 
179a				ld (hl), a      ; empty block 
179a				inc hl 
179a				ld a, 0 
179a				ld (hl), a      ; length of block 
179a				; write end of list 
179a				inc hl 
179a				ld a,(hl) 
179a				inc hl 
179a				ld a,(hl) 
179a				 
179a			 
179a				; init some malloc vars 
179a			 
179a				ld hl, 0 
179a				ld (free_list), hl       ; store last malloc location 
179a			 
179a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
179a				ld a, 0 
179a				ld (hl), a 
179a			 
179a			 
179a				ld hl, heap_start 
179a				;  
179a				  
179a				ret 
179a			 
179a			 
179a			;    free block marker 
179a			;    requested size  
179a			;    pointer to next block 
179a			;    .... 
179a			;    next block marker 
179a			 
179a			 
179a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
179a			; 
179a			 
179a			 
179a			malloc:  
179a				push de 
179a				push bc 
179a				push af 
179a			 
179a				; hl space required 
179a				 
179a				ld c, l    ; hold space   (TODO only a max of 255) 
179a			 
179a			;	inc c     ; TODO BUG need to fix memory leak on push str 
179a			;	inc c 
179a			;	inc c 
179a			;	inc c 
179a			;	inc c 
179a			;	inc c 
179a			;	inc c 
179a			 
179a			 
179a			 
179a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
179a			 
179a				ld a, (free_list+3) 
179a				cp 0 
179a				jr z, .contheap 
179a			 
179a				ld hl, (free_list)     ; get last alloc 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "mrs" 
179a						CALLMONITOR 
179a					endif 
179a				jr .startalloc 
179a			 
179a			.contheap: 
179a				ld hl, heap_start 
179a			 
179a			.startalloc: 
179a			 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "mym" 
179a						CALLMONITOR 
179a					endif 
179a			.findblock: 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "mmf" 
179a						CALLMONITOR 
179a					endif 
179a			 
179a				ld a,(hl)  
179a				; if byte is zero then clear to use 
179a			 
179a				cp 0 
179a				jr z, .foundemptyblock 
179a			 
179a				; if byte is not clear 
179a				;     then byte is offset to next block 
179a			 
179a				inc hl 
179a				ld a, (hl) ; get size 
179a			.nextblock:	inc hl 
179a					ld e, (hl) 
179a					inc hl 
179a					ld d, (hl) 
179a					ex de, hl 
179a			;	inc hl  ; move past the store space 
179a			;	inc hl  ; move past zero index  
179a			 
179a				; TODO detect no more space 
179a			 
179a				push hl 
179a				ld de, heap_end 
179a				call cmp16 
179a				pop hl 
179a				jr nc, .nospace 
179a			 
179a				jr .findblock 
179a			 
179a			.nospace: ld hl, 0 
179a				jp .exit 
179a			 
179a			 
179a			.foundemptyblock:	 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "mme" 
179a						CALLMONITOR 
179a					endif 
179a			 
179a			; TODO has block enough space if reusing??? 
179a			 
179a				;  
179a			 
179a			; see if this block has been previously used 
179a				inc hl 
179a				ld a, (hl) 
179a				dec hl 
179a				cp 0 
179a				jr z, .newblock 
179a			 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "meR" 
179a						CALLMONITOR 
179a					endif 
179a			 
179a			; no reusing previously allocated block 
179a			 
179a			; is it smaller than previously used? 
179a				 
179a				inc hl    ; move to size 
179a				ld a, c 
179a				sub (hl)        ; we want c < (hl) 
179a				dec hl    ; move back to marker 
179a			        jr z, .findblock 
179a			 
179a				; update with the new size which should be lower 
179a			 
179a			        ;inc  hl   ; negate next move. move back to size  
179a			 
179a			.newblock: 
179a				; need to be at marker here 
179a			 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "meN" 
179a						CALLMONITOR 
179a					endif 
179a			 
179a			 
179a				ld a, c 
179a			 
179a				ld (free_list+3), a	 ; flag resume from last malloc  
179a				ld (free_list), hl    ; save out last location 
179a			 
179a			 
179a				;inc a     ; space for length byte 
179a				ld (hl), a     ; save block in use marker 
179a			 
179a				inc hl   ; move to space marker 
179a				ld (hl), a    ; save new space 
179a			 
179a				inc hl   ; move to start of allocated area 
179a				 
179a			;	push hl     ; save where we are - 1  
179a			 
179a			;	inc hl  ; move past zero index  
179a				; skip space to set down new marker 
179a			 
179a				; provide some extra space for now 
179a			 
179a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
179a				inc a 
179a				inc a 
179a			 
179a				push hl   ; save where we are in the node block 
179a			 
179a				call addatohl 
179a			 
179a				; write linked list point 
179a			 
179a				pop de     ; get our node position 
179a				ex de, hl 
179a			 
179a				ld (hl), e 
179a				inc hl 
179a				ld (hl), d 
179a			 
179a				inc hl 
179a			 
179a				; now at start of allocated data so save pointer 
179a			 
179a				push hl 
179a			 
179a				; jump to position of next node and setup empty header in DE 
179a			 
179a				ex de, hl 
179a			 
179a			;	inc hl ; move past end of block 
179a			 
179a				ld a, 0 
179a				ld (hl), a   ; empty marker 
179a				inc hl 
179a				ld (hl), a   ; size 
179a				inc hl  
179a				ld (hl), a   ; ptr 
179a				inc hl 
179a				ld (hl), a   ; ptr 
179a			 
179a			 
179a				pop hl 
179a			 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "mmr" 
179a						CALLMONITOR 
179a					endif 
179a			 
179a			.exit: 
179a				pop af 
179a				pop bc 
179a				pop de  
179a				ret 
179a			 
179a			 
179a			 
179a			 
179a			free:  
179a				push hl 
179a				push af 
179a				; get address in hl 
179a			 
179a					if DEBUG_FORTH_MALLOC_INT 
179a						DMARK "fre" 
179a						CALLMONITOR 
179a					endif 
179a				; data is at hl - move to block count 
179a				dec hl 
179a				dec hl    ; get past pointer 
179a				dec hl 
179a			 
179a				ld a, (hl)    ; need this for a validation check 
179a			 
179a				dec hl    ; move to block marker 
179a			 
179a				; now check that the block count and block marker are the same  
179a			        ; this checks that we are on a malloc node and not random memory 
179a			        ; OK a faint chance this could be a problem but rare - famous last words! 
179a			 
179a				ld c, a 
179a				ld a, (hl)    
179a			 
179a				cp c 
179a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
179a			 
179a				; yes good chance we are on a malloc node 
179a			 
179a				ld a, 0      
179a				ld (hl), a   ; mark as free 
179a			 
179a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
179a			 
179a			.freeignore:  
179a			 
179a				pop af 
179a				pop hl 
179a			 
179a				ret 
179a			 
179a			 
179a			 
179a			endif 
179a			 
179a			; eof 
# End of file firmware_memory.asm
179a			  
179a			; device C  
179a			; Now handled by SPI  
179a			;if SOUND_ENABLE  
179a			;	include "firmware_sound.asm"  
179a			;endif  
179a			  
179a			include "firmware_diags.asm"  
179a			; Hardware diags menu 
179a			 
179a			 
179a			config: 
179a			 
179a 3e 00			ld a, 0 
179c 21 c5 17			ld hl, .configmn 
179f cd cc 0d			call menu 
17a2			 
17a2 fe 00			cp 0 
17a4 c8				ret z 
17a5			 
17a5			;	cp 1 
17a5			;	call z, .savetostore 
17a5			 
17a5 fe 01			cp 1 
17a7			if STARTUP_V1 
17a7				call z, .selautoload 
17a7			endif 
17a7			 
17a7			if STARTUP_V2 
17a7 cc d3 17			call z, .enautoload 
17aa			endif 
17aa fe 02			cp 2 
17ac cc ea 17			call z, .disautoload 
17af			;	cp 3 
17af			;	call z, .selbank 
17af fe 03			cp 3 
17b1 cc 58 1a			call z, .debug_tog 
17b4 fe 04			cp 4 
17b6 cc a6 1b			call z, .bpsgo 
17b9 fe 05			cp 5 
17bb cc 81 1a			call z, hardware_diags 
17be			if STARTUP_V2 
17be fe 06			cp 6 
17c0 cc 16 18			call z, create_startup 
17c3			endif 
17c3 18 d5			jr config 
17c5			 
17c5			.configmn: 
17c5			;	dw prom_c3 
17c5 94 1d			dw prom_c2 
17c7 aa 1d			dw prom_c2a 
17c9			;	dw prom_c2b 
17c9			;	dw prom_c4 
17c9 17 1e			dw prom_m4 
17cb 32 1e			dw prom_m4b 
17cd 3a 1e			dw prom_c1 
17cf			if STARTUP_V2 
17cf 49 1e			dw prom_c9 
17d1			endif 
17d1 00 00			dw 0 
17d3				 
17d3			 
17d3			if STARTUP_V2 
17d3			.enautoload: 
17d3				if STORAGE_SE 
17d3 3e fe			ld a, $fe      ; bit 0 clear 
17d5 32 9b f9			ld (spi_device), a 
17d8			 
17d8 cd 16 05			call storage_get_block_0 
17db			 
17db 3e 01			ld a, 1 
17dd 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
17e0			 
17e0 21 00 00				ld hl, 0 
17e3 11 b5 f9				ld de, store_page 
17e6 cd ca 04			call storage_write_block	 ; save update 
17e9				else 
17e9			 
17e9				ld hl, prom_notav 
17e9				ld de, prom_empty 
17e9				call info_panel 
17e9				endif 
17e9			 
17e9			 
17e9 c9				ret 
17ea			endif 
17ea			 
17ea			.disautoload: 
17ea				if STORAGE_SE 
17ea 3e fe			ld a, $fe      ; bit 0 clear 
17ec 32 9b f9			ld (spi_device), a 
17ef			 
17ef cd 16 05			call storage_get_block_0 
17f2			 
17f2 3e 00			ld a, 0 
17f4 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
17f7			 
17f7 21 00 00				ld hl, 0 
17fa 11 b5 f9				ld de, store_page 
17fd cd ca 04			call storage_write_block	 ; save update 
1800				else 
1800			 
1800				ld hl, prom_notav 
1800				ld de, prom_empty 
1800				call info_panel 
1800				endif 
1800			 
1800			 
1800 c9				ret 
1801			 
1801			if STARTUP_V1 
1801			 
1801			; Select auto start 
1801			 
1801			.selautoload: 
1801			 
1801				 
1801				if STORAGE_SE 
1801			 
1801					call config_dir 
1801				        ld hl, scratch 
1801					ld a, 0 
1801					call menu 
1801			 
1801					cp 0 
1801					ret z 
1801			 
1801					dec a 
1801			 
1801			 
1801					; locate menu option 
1801			 
1801					ld hl, scratch 
1801					call table_lookup 
1801			 
1801					if DEBUG_FORTH_WORDS 
1801						DMARK "ALl" 
1801						CALLMONITOR 
1801					endif 
1801					; with the pointer to the menu it, the byte following the zero term is the file id 
1801			 
1801					ld a, 0 
1801					ld bc, 50   ; max of bytes to look at 
1801					cpir  
1801			 
1801					if DEBUG_FORTH_WORDS 
1801						DMARK "ALb" 
1801						CALLMONITOR 
1801					endif 
1801					;inc hl 
1801			 
1801					ld a, (hl)   ; file id 
1801					 
1801				        ; save bank and file ids 
1801			 
1801					push af 
1801			 
1801			; TODO need to save to block 0 on bank 1	 
1801			 
1801					call storage_get_block_0 
1801			 
1801					if DEBUG_FORTH_WORDS 
1801						DMARK "AL0" 
1801						CALLMONITOR 
1801					endif 
1801					pop af 
1801			 
1801					ld (store_page+STORE_0_FILERUN),a 
1801					 
1801					; save bank id 
1801			 
1801					ld a,(spi_device) 
1801					ld (store_page+STORE_0_BANKRUN),a 
1801			 
1801					; enable auto run of store file 
1801			 
1801					ld a, 1 
1801					ld (store_page+STORE_0_AUTOFILE),a 
1801			 
1801					; save buffer 
1801			 
1801					ld hl, 0 
1801					ld de, store_page 
1801					if DEBUG_FORTH_WORDS 
1801						DMARK "ALw" 
1801						CALLMONITOR 
1801					endif 
1801				call storage_write_block	 ; save update 
1801			  
1801			 
1801			 
1801			 
1801					ld hl, scratch 
1801					call config_fdir 
1801			 
1801				else 
1801			 
1801				ld hl, prom_notav 
1801				ld de, prom_empty 
1801				call info_panel 
1801			 
1801				endif 
1801				ret 
1801			endif 
1801			 
1801			 
1801			; Select storage bank 
1801			 
1801			.selbank: 
1801			 
1801			;	if STORAGE_SE 
1801			;	else 
1801			 
1801 21 5e 1e			ld hl, prom_notav 
1804 11 74 1e			ld de, prom_empty 
1807 cd 2c 0d			call info_panel 
180a			;	endif 
180a				 
180a c9				ret 
180b			 
180b			if STORAGE_SE 
180b			 
180b			.config_ldir:   
180b				; Load storage bank labels into menu array 
180b			 
180b				 
180b			 
180b			 
180b c9				ret 
180c			 
180c			 
180c			endif 
180c			 
180c			 
180c			; Save user words to storage 
180c			 
180c			.savetostore: 
180c			 
180c			;	if STORAGE_SE 
180c			; 
180c			;		call config_dir 
180c			;	        ld hl, scratch 
180c			;		ld a, 0 
180c			;		call menu 
180c			;		 
180c			;		ld hl, scratch 
180c			;		call config_fdir 
180c			; 
180c			;	else 
180c			 
180c 21 5e 1e			ld hl, prom_notav 
180f 11 74 1e			ld de, prom_empty 
1812 cd 2c 0d			call info_panel 
1815			 
1815			;	endif 
1815			 
1815 c9				ret 
1816			 
1816			if STARTUP_V2 
1816			 
1816			create_startup: 
1816			 
1816 3e 00			ld a, 0 
1818 21 7f 19			ld hl, .crstart 
181b cd cc 0d			call menu 
181e			 
181e fe 00			cp 0 
1820 c8				ret z 
1821			 
1821 fe 01			cp 1 
1823 cc 50 18			call z, .genlsword 
1826 fe 02			cp 2 
1828 cc 5a 18			call z, .genedword 
182b			 
182b fe 03			cp 3 
182d cc 64 18			call z, .gendemword 
1830			 
1830 fe 04			cp 4 
1832 cc 6e 18			call z, .genutlword 
1835 fe 05			cp 5 
1837 cc 78 18			call z, .genspiword 
183a fe 06			cp 6 
183c cc 82 18			call z, .genkeyword 
183f fe 07			cp 7 
1841 cc 46 18			call z, .gensoundword 
1844 18 d0			jr create_startup 
1846			 
1846			.gensoundword: 
1846 21 02 1e			ld hl, crs_sound 
1849 11 cf 18			ld de, .soundworddef 
184c cd 8c 18			call .genfile 
184f c9				ret 
1850			.genlsword: 
1850 21 c1 1d			ld hl, crs_s1 
1853 11 f3 18			ld de, .lsworddef 
1856 cd 8c 18			call .genfile 
1859 c9				ret 
185a			 
185a			.genedword: 
185a 11 f7 18			ld de, .edworddef 
185d 21 ca 1d			ld hl, crs_s2 
1860 cd 8c 18			call .genfile 
1863 c9				ret 
1864			 
1864			.gendemword: 
1864 11 ff 18			ld de, .demoworddef 
1867 21 d3 1d			ld hl, crs_s3 
186a cd 8c 18			call .genfile 
186d c9				ret 
186e			 
186e			.genutlword: 
186e 21 e2 1d			ld hl, crs_s4 
1871 11 e3 18			ld de, .utilwordef 
1874 cd 8c 18			call .genfile 
1877 c9				ret 
1878			.genspiword: 
1878 21 e9 1d			ld hl, crs_s5 
187b 11 45 19			ld de, .spiworddef 
187e cd 8c 18			call .genfile 
1881 c9				ret 
1882			.genkeyword: 
1882 21 f3 1d			ld hl, crs_s6 
1885 11 53 19			ld de, .keyworddef 
1888 cd 8c 18			call .genfile 
188b c9				ret 
188c			 
188c			; hl - points to file name 
188c			; de - points to strings to add to file 
188c			 
188c			.genfile: 
188c e5				push hl 
188d d5				push de 
188e			 
188e cd 9b 0d			call clear_display 
1891 3e 00			ld a, display_row_1 
1893 11 be 18			ld de, .genfiletxt 
1896 cd ae 0d			call str_at_display 
1899 cd be 0d			call update_display 
189c			 
189c d1				pop de 
189d e1				pop hl 
189e			 
189e			 
189e d5				push de 
189f cd 68 08			call storage_create 
18a2				; id in hl 
18a2 d1				pop de   ; table of strings to add 
18a3			 
18a3			.genloop: 
18a3			 
18a3 e5				push hl ; save id for next time around 
18a4 d5				push de ; save de for next time around 
18a5			 
18a5 eb				ex de, hl 
18a6 cd 91 25			call loadwordinhl 
18a9 eb				ex de, hl 
18aa			 
18aa				; need hl to be the id 
18aa				; need de to be the string ptr 
18aa				 
18aa cd 55 0b			call storage_append 
18ad			 
18ad d1				pop de 
18ae e1				pop hl 
18af			 
18af 13				inc de 
18b0 13				inc de 
18b1			 
18b1 1a				ld a,(de) 
18b2 fe 00			cp 0 
18b4 20 ed			jr nz, .genloop 
18b6 13				inc de 
18b7 1a				ld a, (de) 
18b8 1b				dec de 
18b9 fe 00			cp 0 
18bb 20 e6			jr nz, .genloop	 
18bd			 
18bd c9				ret 
18be			 
18be .. 00		.genfiletxt:  db "Creating file...",0 
18cf			 
18cf			.soundworddef: 
18cf 1a 6c			dw sound1 
18d1 3e 6c			dw sound2 
18d3 6e 6c			dw sound3 
18d5 93 6c			dw sound4 
18d7 a0 6c			dw sound5 
18d9 ad 6c			dw sound6 
18db ba 6c			dw sound7 
18dd c7 6c			dw sound8 
18df df 6c			dw sound9 
18e1 00 00			dw 0 
18e3			 
18e3			.utilwordef: 
18e3 6b 65			dw strncpy 
18e5 46 65			dw type 
18e7 12 65			dw clrstack 
18e9 cb 64			dw longread 
18eb cc 65			dw start1 
18ed dc 65			dw start2 
18ef			; duplicated 
18ef			;	dw start3b 
18ef			;	dw start3c 
18ef c8 66			dw list 
18f1 00 00			dw 0 
18f3			 
18f3			.lsworddef: 
18f3 ed 65			dw start3b 
18f5 00 00			dw 0 
18f7			 
18f7			.edworddef: 
18f7 2a 61			dw edit1 
18f9 4b 61			dw edit2 
18fb 80 61			dw edit3 
18fd 00 00			dw 0 
18ff			 
18ff			.demoworddef: 
18ff 10 6b			dw test5 
1901 48 6b			dw test6 
1903 80 6b			dw test7 
1905 94 6b			dw test8 
1907 c0 6b			dw test9 
1909 d6 6b			dw test10 
190b f6 6c			dw game1 
190d 07 6d			dw game1a 
190f 69 6d			dw game1b 
1911 9e 6d			dw game1c 
1913 d4 6d			dw game1d 
1915 05 6e			dw game1s 
1917 19 6e			dw game1t 
1919 2e 6e			dw game1f 
191b 62 6e			dw game1z 
191d a6 6e			dw game1zz 
191f 0f 6f			dw ssv2 
1921 45 6f			dw ssv3 
1923 61 6f			dw ssv4 
1925 7d 6f			dw ssv5 
1927 96 6f			dw ssv1 
1929 de 6f			dw ssv1cpm	 
192b 35 70			dw game2b 
192d a3 70			dw game2bf 
192f ed 70			dw game2mba 
1931 83 71			dw game2mbas	 
1933 a8 71			dw game2mbht 
1935 b7 71			dw game2mbms 
1937 c5 71			dw game2mb 
1939 42 72			dw game3w 
193b 70 72			dw game3p 
193d 8e 72			dw game3sc 
193f bf 72			dw game3vsi 
1941 eb 72			dw game3vs 
1943 00 00			dw 0 
1945			 
1945			 
1945			.spiworddef: 
1945			 
1945 b8 61		    dw spi1 
1947 11 62		    dw spi2 
1949 45 62		    dw spi2b 
194b c9 62		    dw spi3 
194d 73 62		    dw spi4 
194f 9c 62		    dw spi5 
1951			;    dw spi6 
1951			;    dw spi7 
1951			 
1951			;    dw spi8 
1951			;    dw spi9 
1951			;    dw spi10 
1951 00 00		    dw 0 
1953			 
1953			.keyworddef: 
1953			 
1953 2a 73			dw keyup 
1955 38 73			dw keydown 
1957 48 73			dw keyleft 
1959 58 73			dw keyright 
195b 69 73			dw 	keyf1 
195d 77 73			dw keyf2 
195f 85 73			dw keyf3 
1961 93 73			dw keyf4 
1963 a1 73			dw keyf5 
1965 af 73			dw keyf6 
1967 bd 73			dw keyf7 
1969 cb 73			dw keyf8 
196b d9 73			dw keyf9 
196d e7 73			dw keyf10 
196f f6 73			dw keyf11 
1971 05 74			dw keyf12 
1973 14 74			dw keytab 
1975 23 74			dw keycr 
1977 31 74			dw keyhome 
1979 41 74			dw keyend 
197b 50 74			dw keybs 
197d 00 00			dw 0 
197f			 
197f			.crstart: 
197f c1 1d			dw crs_s1 
1981 ca 1d			dw crs_s2 
1983 d3 1d			dw crs_s3 
1985 e2 1d			dw crs_s4 
1987 e9 1d			dw crs_s5 
1989 f3 1d			dw crs_s6 
198b 02 1e			dw crs_sound 
198d 00 00			dw 0 
198f			 
198f			endif 
198f			 
198f			 
198f			if STORAGE_SE 
198f			 
198f			config_fdir: 
198f				; using the scratch dir go through and release the memory allocated for each string 
198f				 
198f 21 fc f0			ld hl, scratch 
1992 5e			.cfdir:	ld e,(hl) 
1993 23				inc hl 
1994 56				ld d,(hl) 
1995 23				inc hl 
1996			 
1996 eb				ex de, hl 
1997 cd f8 0f			call ishlzero 
199a c8				ret z     ; return on null pointer 
199b cd cb 16			call free 
199e eb				ex de, hl 
199f 18 f1			jr .cfdir 
19a1			 
19a1			 
19a1 c9				ret 
19a2			 
19a2			 
19a2			config_dir: 
19a2			 
19a2				; for the config menus that need to build a directory of storage call this routine 
19a2				; it will construct a menu in scratch to pass to menu 
19a2			 
19a2				; open storage device 
19a2			 
19a2				; execute DIR to build a list of files and their ids into scratch in menu format 
19a2				; once the menu has finished then will need to call config_fdir to release the strings 
19a2				 
19a2				; c = number items 
19a2			 
19a2				 
19a2 cd 16 05			call storage_get_block_0 
19a5			 
19a5 21 b5 f9			ld hl, store_page     ; get current id count 
19a8 46				ld b, (hl) 
19a9 0e 00			ld c, 0    ; count of files   
19ab			 
19ab			 
19ab 21 fc f0			ld hl, scratch 
19ae 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
19b1			 
19b1				; check for empty drive 
19b1			 
19b1 3e 00			ld a, 0 
19b3 b8				cp b 
19b4 ca 4e 1a			jp z, .dirdone 
19b7			 
19b7				 
19b7					if DEBUG_FORTH_WORDS 
19b7						DMARK "Cdc" 
19b7 f5				push af  
19b8 3a cc 19			ld a, (.dmark)  
19bb 32 a6 fd			ld (debug_mark),a  
19be 3a cd 19			ld a, (.dmark+1)  
19c1 32 a7 fd			ld (debug_mark+1),a  
19c4 3a ce 19			ld a, (.dmark+2)  
19c7 32 a8 fd			ld (debug_mark+2),a  
19ca 18 03			jr .pastdmark  
19cc ..			.dmark: db "Cdc"  
19cf f1			.pastdmark: pop af  
19d0			endm  
# End of macro DMARK
19d0						CALLMONITOR 
19d0 cd aa fd			call debug_vector  
19d3				endm  
# End of macro CALLMONITOR
19d3					endif 
19d3			 
19d3			 
19d3			.diritem:	 
19d3 c5				push bc 
19d4				; for each of the current ids do a search for them and if found push to stack 
19d4			 
19d4 21 40 00				ld hl, STORE_BLOCK_PHY 
19d7 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
19d9 58					ld e,b 
19da			 
19da cd 98 07				call storage_findnextid 
19dd			 
19dd			 
19dd					; if found hl will be non zero 
19dd			 
19dd cd f8 0f				call ishlzero 
19e0 28 69				jr z, .dirnotfound 
19e2			 
19e2					; increase count 
19e2			 
19e2 c1					pop bc	 
19e3 0c					inc c 
19e4 c5					push bc 
19e5					 
19e5			 
19e5					; get file header and push the file name 
19e5			 
19e5 11 b5 f9				ld de, store_page 
19e8 cd 65 04				call storage_read_block 
19eb			 
19eb					; push file id to stack 
19eb				 
19eb 3a b5 f9				ld a, (store_page) 
19ee 26 00				ld h, 0 
19f0 6f					ld l, a 
19f1			 
19f1					;call forth_push_numhl 
19f1					; TODO store id 
19f1			 
19f1 e5					push hl 
19f2			 
19f2					; push extent count to stack  
19f2				 
19f2 21 b8 f9				ld hl, store_page+3 
19f5			 
19f5					; get file name length 
19f5			 
19f5 cd 8c 15				call strlenz   
19f8			 
19f8 23					inc hl   ; cover zero term 
19f9 23					inc hl  ; stick the id at the end of the area 
19fa			 
19fa e5					push hl 
19fb c1					pop bc    ; move length to bc 
19fc			 
19fc cd 01 16				call malloc 
19ff			 
19ff					; TODO save malloc area to scratch 
19ff			 
19ff eb					ex de, hl 
1a00 2a ac f9				ld hl, (store_tmp2) 
1a03 73					ld (hl), e 
1a04 23					inc hl 
1a05 72					ld (hl), d 
1a06 23					inc hl 
1a07 22 ac f9				ld (store_tmp2), hl 
1a0a			 
1a0a					 
1a0a			 
1a0a					;pop hl   ; get source 
1a0a			;		ex de, hl    ; swap aronund	 
1a0a			 
1a0a 21 b8 f9				ld hl, store_page+3 
1a0d					if DEBUG_FORTH_WORDS 
1a0d						DMARK "CFd" 
1a0d f5				push af  
1a0e 3a 22 1a			ld a, (.dmark)  
1a11 32 a6 fd			ld (debug_mark),a  
1a14 3a 23 1a			ld a, (.dmark+1)  
1a17 32 a7 fd			ld (debug_mark+1),a  
1a1a 3a 24 1a			ld a, (.dmark+2)  
1a1d 32 a8 fd			ld (debug_mark+2),a  
1a20 18 03			jr .pastdmark  
1a22 ..			.dmark: db "CFd"  
1a25 f1			.pastdmark: pop af  
1a26			endm  
# End of macro DMARK
1a26						CALLMONITOR 
1a26 cd aa fd			call debug_vector  
1a29				endm  
# End of macro CALLMONITOR
1a29					endif 
1a29 ed b0				ldir 
1a2b			 
1a2b					; de is past string, move back one and store id 
1a2b					 
1a2b 1b					dec de 
1a2c			 
1a2c					; store file id 
1a2c			 
1a2c e1					pop hl 
1a2d eb					ex de,hl 
1a2e 73					ld (hl), e 
1a2f			 
1a2f					if DEBUG_FORTH_WORDS 
1a2f						DMARK "Cdi" 
1a2f f5				push af  
1a30 3a 44 1a			ld a, (.dmark)  
1a33 32 a6 fd			ld (debug_mark),a  
1a36 3a 45 1a			ld a, (.dmark+1)  
1a39 32 a7 fd			ld (debug_mark+1),a  
1a3c 3a 46 1a			ld a, (.dmark+2)  
1a3f 32 a8 fd			ld (debug_mark+2),a  
1a42 18 03			jr .pastdmark  
1a44 ..			.dmark: db "Cdi"  
1a47 f1			.pastdmark: pop af  
1a48			endm  
# End of macro DMARK
1a48						CALLMONITOR 
1a48 cd aa fd			call debug_vector  
1a4b				endm  
# End of macro CALLMONITOR
1a4b					endif 
1a4b					 
1a4b			.dirnotfound: 
1a4b c1					pop bc     
1a4c 10 85				djnz .diritem 
1a4e				 
1a4e			.dirdone:	 
1a4e			 
1a4e 3e 00				ld a, 0 
1a50 2a ac f9				ld hl, (store_tmp2) 
1a53 77					ld (hl), a 
1a54 23					inc hl 
1a55 77					ld (hl), a 
1a56 23					inc hl 
1a57					; push a count of the dir items found 
1a57			 
1a57			;		ld h, 0 
1a57			;		ld l, c 
1a57			 
1a57 c9				ret 
1a58			 
1a58			endif 
1a58			 
1a58			 
1a58			; Settings 
1a58			; Run  
1a58			 
1a58			 
1a58			 
1a58			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1a58			;;hd_menu2:   db "        2: Editor",0   
1a58			;hd_menu2:   db "        2: Editor       6: Menu",0   
1a58			;hd_menu3:   db "        3: Storage",0 
1a58			;hd_menu4:   db "0=quit  4: Debug",0 
1a58			;hd_don:     db "ON",0 
1a58			;hd_doff:     db "OFF",0 
1a58			; 
1a58			; 
1a58			; 
1a58			;hardware_diags_old:       
1a58			; 
1a58			;.diagmenu: 
1a58			;	call clear_display 
1a58			;	ld a, display_row_1 
1a58			;	ld de, hd_menu1 
1a58			;	call str_at_display 
1a58			; 
1a58			;	ld a, display_row_2 
1a58			;	ld de, hd_menu2 
1a58			;	call str_at_display 
1a58			; 
1a58			;	ld a, display_row_3 
1a58			;	ld de, hd_menu3 
1a58			;	call str_at_display 
1a58			; 
1a58			;	ld a,  display_row_4 
1a58			;	ld de, hd_menu4 
1a58			;	call str_at_display 
1a58			; 
1a58			;	; display debug state 
1a58			; 
1a58			;	ld de, hd_don 
1a58			;	ld a, (os_view_disable) 
1a58			;	cp 0 
1a58			;	jr z, .distog 
1a58			;	ld de, hd_doff 
1a58			;.distog: ld a, display_row_4+17 
1a58			;	call str_at_display 
1a58			; 
1a58			;	call update_display 
1a58			; 
1a58			;	call cin_wait 
1a58			; 
1a58			; 
1a58			; 
1a58			;	cp '4' 
1a58			;	jr nz, .diagn1 
1a58			; 
1a58			;	; debug toggle 
1a58			; 
1a58			;	ld a, (os_view_disable) 
1a58			;	ld b, '*' 
1a58			;	cp 0 
1a58			;	jr z, .debtog 
1a58			;	ld b, 0 
1a58			;.debtog:	 
1a58			;	ld a,b 
1a58			;	ld (os_view_disable),a 
1a58			; 
1a58			;.diagn1: cp '0' 
1a58			;	 ret z 
1a58			; 
1a58			;;	cp '1' 
1a58			;;       jp z, matrix	 
1a58			;;   TODO keyboard matrix test 
1a58			; 
1a58			;	cp '2' 
1a58			;	jp z, .diagedit 
1a58			; 
1a58			;;	cp '6' 
1a58			;;	jp z, .menutest 
1a58			;;if ENABLE_BASIC 
1a58			;;	cp '6' 
1a58			;;	jp z, basic 
1a58			;;endif 
1a58			 ; 
1a58			;	jp .diagmenu 
1a58			; 
1a58			; 
1a58			;	ret 
1a58			 
1a58			 
1a58			.debug_tog: 
1a58 21 a2 1a			ld hl, .menudebug 
1a5b				 
1a5b			;	ld a, (os_view_disable) 
1a5b			;	cp '*' 
1a5b 3a aa fd			ld a,(debug_vector) 
1a5e fe c9			cp $C9   ; RET 
1a60 20 04			jr nz,.tdon  
1a62 3e 01			ld a, 1 
1a64 18 02			jr .tog1 
1a66 3e 00		.tdon: ld a, 0 
1a68			 
1a68			.tog1: 
1a68 cd cc 0d			call menu 
1a6b fe 00			cp 0 
1a6d c8				ret z 
1a6e fe 01			cp 1    ; disable debug 
1a70 28 04			jr z, .dtog0 
1a72 3e 2a			ld a, '*' 
1a74 18 05			jr .dtogset 
1a76			.dtog0:  
1a76				;ld a, 0 
1a76 cd 94 1b			call bp_on 
1a79 18 dd			jr .debug_tog 
1a7b			.dtogset:  
1a7b				; ld (os_view_disable), a 
1a7b cd a0 1b			call bp_off 
1a7e c3 58 1a			jp .debug_tog 
1a81			 
1a81			 
1a81			hardware_diags:       
1a81			 
1a81			.diagm: 
1a81 21 94 1a			ld hl, .menuitems 
1a84 3e 00			ld a, 0 
1a86 cd cc 0d			call menu 
1a89			 
1a89 fe 00		         cp 0 
1a8b c8				 ret z 
1a8c			 
1a8c fe 02			cp 2 
1a8e ca ed 1a			jp z, .diagedit 
1a91			 
1a91			;	cp '6' 
1a91			;	jp z, .menutest 
1a91			;if ENABLE_BASIC 
1a91			;	cp '6' 
1a91			;	jp z, basic 
1a91			;endif 
1a91			  
1a91 c3 81 1a			jp .diagm 
1a94			 
1a94				 
1a94 a8 1a		.menuitems:   	dw .m1 
1a96 b3 1a				dw .m2 
1a98 ba 1a				dw .m3 
1a9a c2 1a				dw .m5 
1a9c c8 1a				dw .m5a 
1a9e d1 1a				dw .m5b 
1aa0 00 00				dw 0 
1aa2			 
1aa2			.menudebug: 
1aa2 da 1a				dw .m6 
1aa4 e3 1a				dw .m7 
1aa6 00 00				dw 0 
1aa8			 
1aa8 .. 00		.m1:   db "Key Matrix",0 
1ab3 .. 00		.m2:   db "Editor",0 
1aba .. 00		.m3:   db "Storage",0 
1ac2 .. 00		.m5:   db "Sound",0 
1ac8 .. 00		.m5a:  db "RAM Test",0 
1ad1 .. 00		.m5b:  db "LCD Test",0 
1ada			 
1ada .. 00		.m6:   db "Debug ON",0 
1ae3 .. 00		.m7:   db "Debug OFF",0 
1aed			 
1aed			; debug editor 
1aed			 
1aed			.diagedit: 
1aed			 
1aed 21 fc f0			ld hl, scratch 
1af0			;	ld bc, 250 
1af0			;	ldir 
1af0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1af0 3e 00			ld a, 0 
1af2 77				ld (hl), a 
1af3 23				inc hl 
1af4 77				ld (hl), a 
1af5 23				inc hl 
1af6 77				ld (hl), a 
1af7			 
1af7 cd 9b 0d		        call clear_display 
1afa cd be 0d			call update_display 
1afd				;ld a, 1 
1afd				;ld (hardware_diag), a 
1afd			.diloop: 
1afd 3e 00			ld a, display_row_1 
1aff 0e 00			ld c, 0 
1b01 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1b03 1e 28			ld e, 40 
1b05			 
1b05 21 fc f0			ld hl, scratch	 
1b08 cd fc 0f			call input_str 
1b0b			 
1b0b 3e 28			ld a, display_row_2 
1b0d 11 fc f0			ld de, scratch 
1b10 cd ae 0d			call str_at_display 
1b13 cd be 0d			call update_display 
1b16			 
1b16 c3 fd 1a			jp .diloop 
1b19			 
1b19			 
1b19			; pass word in hl 
1b19			; a has display location 
1b19			display_word_at: 
1b19 f5				push af 
1b1a e5				push hl 
1b1b 7c				ld a,h 
1b1c 21 01 f4			ld hl, os_word_scratch 
1b1f cd 2f 14			call hexout 
1b22 e1				pop hl 
1b23 7d				ld a,l 
1b24 21 03 f4			ld hl, os_word_scratch+2 
1b27 cd 2f 14			call hexout 
1b2a 21 05 f4			ld hl, os_word_scratch+4 
1b2d 3e 00			ld a,0 
1b2f 77				ld (hl),a 
1b30 11 01 f4			ld de,os_word_scratch 
1b33 f1				pop af 
1b34 cd ae 0d				call str_at_display 
1b37 c9				ret 
1b38			 
1b38			display_ptr_state: 
1b38			 
1b38				; to restore afterwards 
1b38			 
1b38 d5				push de 
1b39 c5				push bc 
1b3a e5				push hl 
1b3b f5				push af 
1b3c			 
1b3c				; for use in here 
1b3c			 
1b3c			;	push bc 
1b3c			;	push de 
1b3c			;	push hl 
1b3c			;	push af 
1b3c			 
1b3c cd 9b 0d			call clear_display 
1b3f			 
1b3f 11 17 1d			ld de, .ptrstate 
1b42 3e 00			ld a, display_row_1 
1b44 cd ae 0d			call str_at_display 
1b47			 
1b47				; display debug step 
1b47			 
1b47			 
1b47 11 a6 fd			ld de, debug_mark 
1b4a 3e 26			ld a, display_row_1+display_cols-2 
1b4c cd ae 0d			call str_at_display 
1b4f			 
1b4f				; display a 
1b4f 11 21 1d			ld de, .ptrcliptr 
1b52 3e 28			ld a, display_row_2 
1b54 cd ae 0d			call str_at_display 
1b57			 
1b57 f1				pop af 
1b58 2a 7b f9			ld hl,(cli_ptr) 
1b5b 3e 30			ld a, display_row_2+8 
1b5d cd 19 1b			call display_word_at 
1b60			 
1b60			 
1b60				; display hl 
1b60			 
1b60			 
1b60 11 29 1d			ld de, .ptrclioptr 
1b63 3e 32			ld a, display_row_2+10 
1b65 cd ae 0d			call str_at_display 
1b68			; 
1b68			;	pop hl 
1b68 3e 35			ld a, display_row_2+13 
1b6a 2a 79 f9			ld hl,(cli_origptr) 
1b6d cd 19 1b			call display_word_at 
1b70			; 
1b70			;	 
1b70			;	; display de 
1b70			 
1b70			;	ld de, .regstatede 
1b70			;	ld a, display_row_3 
1b70			;	call str_at_display 
1b70			 
1b70			;	pop de 
1b70			;	ld h,d 
1b70			;	ld l, e 
1b70			;	ld a, display_row_3+3 
1b70			;	call display_word_at 
1b70			 
1b70			 
1b70				; display bc 
1b70			 
1b70			;	ld de, .regstatebc 
1b70			;	ld a, display_row_3+10 
1b70			;	call str_at_display 
1b70			 
1b70			;	pop bc 
1b70			;	ld h,b 
1b70			;	ld l, c 
1b70			;	ld a, display_row_3+13 
1b70			;	call display_word_at 
1b70			 
1b70			 
1b70				; display dsp 
1b70			 
1b70			;	ld de, .regstatedsp 
1b70			;	ld a, display_row_4 
1b70			;	call str_at_display 
1b70			 
1b70				 
1b70			;	ld hl,(cli_data_sp) 
1b70			;	ld a, display_row_4+4 
1b70			;	call display_word_at 
1b70			 
1b70				; display rsp 
1b70			 
1b70 11 58 1d			ld de, .regstatersp 
1b73 3e 82			ld a, display_row_4+10 
1b75 cd ae 0d			call str_at_display 
1b78			 
1b78				 
1b78 2a 2d f9			ld hl,(cli_ret_sp) 
1b7b 3e 86			ld a, display_row_4+14 
1b7d cd 19 1b			call display_word_at 
1b80			 
1b80 cd be 0d			call update_display 
1b83			 
1b83 cd de 0c			call delay1s 
1b86 cd de 0c			call delay1s 
1b89 cd de 0c			call delay1s 
1b8c			 
1b8c			 
1b8c cd da 21			call next_page_prompt 
1b8f			 
1b8f				; restore  
1b8f			 
1b8f f1				pop af 
1b90 e1				pop hl 
1b91 c1				pop bc 
1b92 d1				pop de 
1b93 c9				ret 
1b94			 
1b94			; Update the break point vector so that the user can hook a new routine 
1b94			 
1b94			bp_on: 
1b94 3e c3			ld a, $c3    ; JP 
1b96 32 aa fd			ld (debug_vector), a 
1b99 21 a6 1b			ld hl, break_point_state 
1b9c 22 ab fd			ld (debug_vector+1), hl 
1b9f c9				ret 
1ba0			 
1ba0			bp_off: 
1ba0 3e c9			ld a, $c9    ; RET 
1ba2 32 aa fd			ld (debug_vector), a 
1ba5 c9				ret 
1ba6			 
1ba6			 
1ba6			break_point_state: 
1ba6			;	push af 
1ba6			; 
1ba6			;	; see if disabled 
1ba6			; 
1ba6			;	ld a, (os_view_disable) 
1ba6			;	cp '*' 
1ba6			;	jr nz, .bpsgo 
1ba6			;	pop af 
1ba6			;	ret 
1ba6			 
1ba6			.bpsgo: 
1ba6			;	pop af 
1ba6 f5				push af 
1ba7 22 de f0			ld (os_view_hl), hl 
1baa ed 53 dc f0		ld (os_view_de), de 
1bae ed 43 da f0		ld (os_view_bc), bc 
1bb2 e5				push hl 
1bb3 6f				ld l, a 
1bb4 26 00			ld h, 0 
1bb6 22 e0 f0			ld (os_view_af),hl 
1bb9			 
1bb9 21 ec fc				ld hl, display_fb0 
1bbc 22 07 fb				ld (display_fb_active), hl 
1bbf e1				pop hl	 
1bc0			 
1bc0 3e 31			ld a, '1' 
1bc2 fe 2a		.bps1:  cp '*' 
1bc4 cc a0 1b			call z, bp_off 
1bc7			;	jr nz, .bps1b 
1bc7			;	ld (os_view_disable),a 
1bc7 fe 31		.bps1b:  cp '1' 
1bc9 20 14			jr nz, .bps2 
1bcb			 
1bcb				; display reg 
1bcb			 
1bcb				 
1bcb			 
1bcb 3a e0 f0			ld a, (os_view_af) 
1bce 2a de f0			ld hl, (os_view_hl) 
1bd1 ed 5b dc f0		ld de, (os_view_de) 
1bd5 ed 4b da f0		ld bc, (os_view_bc) 
1bd9 cd 73 1c			call display_reg_state 
1bdc c3 5f 1c			jp .bpschk 
1bdf			 
1bdf fe 32		.bps2:  cp '2' 
1be1 20 08			jr nz, .bps3 
1be3				 
1be3				; display hl 
1be3 2a de f0			ld hl, (os_view_hl) 
1be6 cd 5d 1d			call display_dump_at_hl 
1be9			 
1be9 18 74			jr .bpschk 
1beb			 
1beb fe 33		.bps3:  cp '3' 
1bed 20 08			jr nz, .bps4 
1bef			 
1bef			        ; display de 
1bef 2a dc f0			ld hl, (os_view_de) 
1bf2 cd 5d 1d			call display_dump_at_hl 
1bf5			 
1bf5 18 68			jr .bpschk 
1bf7 fe 34		.bps4:  cp '4' 
1bf9 20 08			jr nz, .bps5 
1bfb			 
1bfb			        ; display bc 
1bfb 2a da f0			ld hl, (os_view_bc) 
1bfe cd 5d 1d			call display_dump_at_hl 
1c01			 
1c01 18 5c			jr .bpschk 
1c03 fe 35		.bps5:  cp '5' 
1c05 20 08		        jr nz, .bps7 
1c07			 
1c07				; display cur ptr 
1c07 2a 7b f9			ld hl, (cli_ptr) 
1c0a cd 5d 1d			call display_dump_at_hl 
1c0d			 
1c0d 18 50			jr .bpschk 
1c0f fe 36		.bps7:  cp '6' 
1c11 20 08			jr nz, .bps8b 
1c13				 
1c13				; display cur orig ptr 
1c13 2a 79 f9			ld hl, (cli_origptr) 
1c16 cd 5d 1d			call display_dump_at_hl 
1c19 18 44			jr .bpschk 
1c1b fe 37		.bps8b:  cp '7' 
1c1d 20 08			jr nz, .bps9 
1c1f				 
1c1f				; display dsp 
1c1f 2a 29 f9			ld hl, (cli_data_sp) 
1c22 cd 5d 1d			call display_dump_at_hl 
1c25			 
1c25 18 38			jr .bpschk 
1c27 fe 39		.bps9:  cp '9' 
1c29 20 05			jr nz, .bps8c 
1c2b				 
1c2b				; display SP 
1c2b			;	ld hl, sp 
1c2b cd 5d 1d			call display_dump_at_hl 
1c2e			 
1c2e 18 2f			jr .bpschk 
1c30 fe 38		.bps8c:  cp '8' 
1c32 20 08			jr nz, .bps8d 
1c34				 
1c34				; display rsp 
1c34 2a 2d f9			ld hl, (cli_ret_sp) 
1c37 cd 5d 1d			call display_dump_at_hl 
1c3a			 
1c3a 18 23			jr .bpschk 
1c3c fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1c3e 20 05			jr nz, .bps8 
1c40 cd a8 1f			call monitor 
1c43			 
1c43 18 1a			jr .bpschk 
1c45 fe 30		.bps8:  cp '0' 
1c47 20 16			jr nz, .bpschk 
1c49			 
1c49 21 4b fc				ld hl, display_fb1 
1c4c 22 07 fb				ld (display_fb_active), hl 
1c4f cd be 0d				call update_display 
1c52			 
1c52				;ld a, (os_view_af) 
1c52 2a de f0			ld hl, (os_view_hl) 
1c55 ed 5b dc f0		ld de, (os_view_de) 
1c59 ed 4b da f0		ld bc, (os_view_bc) 
1c5d f1				pop af 
1c5e c9				ret 
1c5f			 
1c5f			.bpschk:   
1c5f cd de 0c			call delay1s 
1c62 3e 9f		ld a,display_row_4 + display_cols - 1 
1c64 11 d8 21		        ld de, endprg 
1c67 cd ae 0d			call str_at_display 
1c6a cd be 0d			call update_display 
1c6d cd cb 7b			call cin_wait 
1c70			 
1c70 c3 c2 1b			jp .bps1 
1c73			 
1c73			 
1c73			display_reg_state: 
1c73			 
1c73				; to restore afterwards 
1c73			 
1c73 d5				push de 
1c74 c5				push bc 
1c75 e5				push hl 
1c76 f5				push af 
1c77			 
1c77				; for use in here 
1c77			 
1c77 c5				push bc 
1c78 d5				push de 
1c79 e5				push hl 
1c7a f5				push af 
1c7b			 
1c7b cd 9b 0d			call clear_display 
1c7e			 
1c7e 11 33 1d			ld de, .regstate 
1c81 3e 00			ld a, display_row_1 
1c83 cd ae 0d			call str_at_display 
1c86			 
1c86				; display debug step 
1c86			 
1c86			 
1c86 11 a6 fd			ld de, debug_mark 
1c89 3e 25			ld a, display_row_1+display_cols-3 
1c8b cd ae 0d			call str_at_display 
1c8e			 
1c8e				; display a 
1c8e 11 4f 1d			ld de, .regstatea 
1c91 3e 28			ld a, display_row_2 
1c93 cd ae 0d			call str_at_display 
1c96			 
1c96 e1				pop hl 
1c97			;	ld h,0 
1c97			;	ld l, a 
1c97 3e 2b			ld a, display_row_2+3 
1c99 cd 19 1b			call display_word_at 
1c9c			 
1c9c			 
1c9c				; display hl 
1c9c			 
1c9c			 
1c9c 11 43 1d			ld de, .regstatehl 
1c9f 3e 32			ld a, display_row_2+10 
1ca1 cd ae 0d			call str_at_display 
1ca4			 
1ca4 e1				pop hl 
1ca5 3e 35			ld a, display_row_2+13 
1ca7 cd 19 1b			call display_word_at 
1caa			 
1caa				 
1caa				; display de 
1caa			 
1caa 11 47 1d			ld de, .regstatede 
1cad 3e 50			ld a, display_row_3 
1caf cd ae 0d			call str_at_display 
1cb2			 
1cb2 e1				pop hl 
1cb3			;	ld h,d 
1cb3			;	ld l, e 
1cb3 3e 53			ld a, display_row_3+3 
1cb5 cd 19 1b			call display_word_at 
1cb8			 
1cb8			 
1cb8				; display bc 
1cb8			 
1cb8 11 4b 1d			ld de, .regstatebc 
1cbb 3e 5a			ld a, display_row_3+10 
1cbd cd ae 0d			call str_at_display 
1cc0			 
1cc0 e1				pop hl 
1cc1			;	ld h,b 
1cc1			;	ld l, c 
1cc1 3e 5d			ld a, display_row_3+13 
1cc3 cd 19 1b			call display_word_at 
1cc6			 
1cc6			 
1cc6				; display dsp 
1cc6			 
1cc6 11 53 1d			ld de, .regstatedsp 
1cc9 3e 78			ld a, display_row_4 
1ccb cd ae 0d			call str_at_display 
1cce			 
1cce				 
1cce 2a 29 f9			ld hl,(cli_data_sp) 
1cd1 3e 7c			ld a, display_row_4+4 
1cd3 cd 19 1b			call display_word_at 
1cd6			 
1cd6				; display rsp 
1cd6			 
1cd6 11 58 1d			ld de, .regstatersp 
1cd9 3e 82			ld a, display_row_4+10 
1cdb cd ae 0d			call str_at_display 
1cde			 
1cde				 
1cde 2a 2d f9			ld hl,(cli_ret_sp) 
1ce1 3e 86			ld a, display_row_4+14 
1ce3 cd 19 1b			call display_word_at 
1ce6			 
1ce6 cd be 0d			call update_display 
1ce9			 
1ce9			;	call delay1s 
1ce9			;	call delay1s 
1ce9			;	call delay1s 
1ce9			 
1ce9			 
1ce9			;	call next_page_prompt 
1ce9			 
1ce9				; restore  
1ce9			 
1ce9 f1				pop af 
1cea e1				pop hl 
1ceb c1				pop bc 
1cec d1				pop de 
1ced c9				ret 
1cee			 
1cee .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1d02 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1d17 .. 00		.ptrstate:	db "Ptr State",0 
1d21 .. 00		.ptrcliptr:     db "cli_ptr",0 
1d29 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1d33 .. 00		.regstate:	db "Reg State (1/0)",0 
1d43 .. 00		.regstatehl:	db "HL:",0 
1d47 .. 00		.regstatede:	db "DE:",0 
1d4b .. 00		.regstatebc:	db "BC:",0 
1d4f .. 00		.regstatea:	db "A :",0 
1d53 .. 00		.regstatedsp:	db "DSP:",0 
1d58 .. 00		.regstatersp:	db "RSP:",0 
1d5d			 
1d5d			display_dump_at_hl: 
1d5d e5				push hl 
1d5e d5				push de 
1d5f c5				push bc 
1d60 f5				push af 
1d61			 
1d61 22 1f f4			ld (os_cur_ptr),hl	 
1d64 cd 9b 0d			call clear_display 
1d67 cd e2 20			call dumpcont 
1d6a			;	call delay1s 
1d6a			;	call next_page_prompt 
1d6a			 
1d6a			 
1d6a f1				pop af 
1d6b c1				pop bc 
1d6c d1				pop de 
1d6d e1				pop hl 
1d6e c9				ret 
1d6f			 
1d6f			;if ENABLE_BASIC 
1d6f			;	include "nascombasic.asm" 
1d6f			;	basic: 
1d6f			;	include "forth/FORTH.ASM" 
1d6f			;endif 
1d6f			 
1d6f			; eof 
1d6f			 
1d6f			 
# End of file firmware_diags.asm
1d6f			  
1d6f			include "firmware_prompts.asm"  
1d6f			; Prompts  
1d6f			 
1d6f			; boot messages 
1d6f			 
1d6f .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1d84 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1d94			 
1d94			 
1d94			; config menus 
1d94			 
1d94			;prom_c3: db "Add Dictionary To File",0 
1d94			 
1d94			if STARTUP_V1 
1d94			prom_c2: db "Select Autoload File",0 
1d94			prom_c2a: db "Disable Autoload File", 0 
1d94			endif 
1d94			 
1d94			if STARTUP_V2 
1d94 .. 00		prom_c2: db "Enable Autoload Files",0 
1daa .. 00		prom_c2a: db "Disable Autoload Files", 0 
1dc1			 
1dc1 .. 00		crs_s1: db "*ls-word", 0 
1dca .. 00		crs_s2: db "*ed-word", 0 
1dd3 .. 00		crs_s3: db "*Demo-Programs", 0 
1de2 .. 00		crs_s4: db "*Utils", 0 
1de9 .. 00		crs_s5: db "*SPI-Util", 0 
1df3 .. 00		crs_s6: db "*Key-constants", 0 
1e02 .. 00		crs_sound: db "*Sound-Util", 0 
1e0e			 
1e0e			 
1e0e			 
1e0e			endif 
1e0e			;prom_c2b: db "Select Storage Bank",0 
1e0e .. 00		prom_c4: db "Settings",0 
1e17 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1e32 .. 00		prom_m4b:   db "Monitor",0 
1e3a .. 00		prom_c1: db "Hardware Diags",0 
1e49			 
1e49			 
1e49			if STARTUP_V2 
1e49 .. 00		prom_c9: db "Create Startup Files",0 
1e5e			endif 
1e5e			 
1e5e .. 00		prom_notav:    db "Feature not available",0 
1e74 .. 00		prom_empty:    db "",0 
1e75			 
1e75			; eof 
1e75			 
# End of file firmware_prompts.asm
1e75			  
1e75			  
1e75			; eof  
1e75			  
# End of file firmware.asm
1e75			 
1e75			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1e75			;if BASE_KEV  
1e75			;baseram: equ 08000h 
1e75			;endif 
1e75			 
1e75			;if BASE_SC114 
1e75			;baseram:     equ    endofcode 
1e75			;endif 
1e75			 
1e75			 
1e75			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1e75			 
1e75			; start system 
1e75			 
1e75			coldstart: 
1e75				; set sp 
1e75				; di/ei 
1e75			 
1e75 f3				di 
1e76 31 fd ff			ld sp, tos 
1e79 cd 52 78			call init_nmi 
1e7c			;	ei 
1e7c			 
1e7c				; init spinner 
1e7c 3e 00			ld a,0 
1e7e 32 01 fb			ld (display_active), a 
1e81			 
1e81				; disable breakpoint by default 
1e81			 
1e81				;ld a,'*' 
1e81			;	ld a,' ' 
1e81			;	ld (os_view_disable),a 
1e81			 
1e81				; set break point vector as new break point on or off 
1e81 cd a0 1b			call bp_off 
1e84			 
1e84				; init hardware 
1e84			 
1e84				; init keyboard and screen hardware 
1e84			 
1e84 cd 68 00			call hardware_init 
1e87			 
1e87			 
1e87 cd de 0c			call delay1s 
1e8a 3e 58			ld a, display_row_3+8 
1e8c 11 03 00			ld de, buildtime 
1e8f cd ae 0d			call str_at_display 
1e92 cd be 0d			call update_display 
1e95			 
1e95 cd de 0c			call delay1s 
1e98 cd de 0c			call delay1s 
1e9b cd de 0c			call delay1s 
1e9e			 
1e9e				; detect if any keys are held down to enable breakpoints at start up 
1e9e			 
1e9e cd dc 7b			call cin  
1ea1 fe 00			cp 0 
1ea3 28 03			jr z, .nokeys 
1ea5			 
1ea5				;call hardware_diags 
1ea5 cd 9a 17			call config 
1ea8			 
1ea8			;	ld de, .bpen 
1ea8			;	ld a, display_row_4 
1ea8			;	call str_at_display 
1ea8			;	call update_display 
1ea8			; 
1ea8			;	ld a,0 
1ea8			;	ld (os_view_disable),a 
1ea8			; 
1ea8			;.bpwait: 
1ea8			;	call cin 
1ea8			;	cp 0 
1ea8			;	jr z, .bpwait 
1ea8			;	jr .nokeys 
1ea8			; 
1ea8			; 
1ea8			;.bpen:  db "Break points enabled!",0 
1ea8			 
1ea8			 
1ea8			 
1ea8			 
1ea8			 
1ea8			 
1ea8			.nokeys: 
1ea8			 
1ea8			 
1ea8				 
1ea8			 
1ea8			;jp  testkey 
1ea8			 
1ea8			;call storage_get_block_0 
1ea8			; 
1ea8			;ld hl, 0 
1ea8			;ld de, store_page 
1ea8			;call storage_read_block 
1ea8			 
1ea8				 
1ea8			;ld hl, 10 
1ea8			;ld de, store_page 
1ea8			;call storage_read_block 
1ea8			 
1ea8			 
1ea8			 
1ea8			 
1ea8			 
1ea8			;stop:	nop 
1ea8			;	jp stop 
1ea8			 
1ea8			 
1ea8			 
1ea8			main: 
1ea8 cd 9b 0d			call clear_display 
1eab cd be 0d			call update_display 
1eae			 
1eae			 
1eae			 
1eae			;	call testlcd 
1eae			 
1eae			 
1eae			 
1eae cd df 25			call forth_init 
1eb1			 
1eb1			 
1eb1			warmstart: 
1eb1 cd b5 25			call forth_warmstart 
1eb4			 
1eb4				; run startup word load 
1eb4			        ; TODO prevent this running at warmstart after crash  
1eb4			 
1eb4				if STARTUP_ENABLE 
1eb4			 
1eb4					if STARTUP_V1 
1eb4			 
1eb4						if STORAGE_SE 
1eb4							call forth_autoload 
1eb4						endif 
1eb4						call forth_startup 
1eb4					endif 
1eb4			 
1eb4					if STARTUP_V2 
1eb4			 
1eb4						if STORAGE_SE 
1eb4 cd 80 76						call forth_autoload 
1eb7						else 
1eb7							call forth_startup 
1eb7						endif 
1eb7			 
1eb7			 
1eb7					endif 
1eb7			 
1eb7				endif 
1eb7			 
1eb7				; show free memory after boot 
1eb7 11 43 1f			ld de, freeram 
1eba 3e 00			ld a, display_row_1 
1ebc cd ae 0d			call str_at_display 
1ebf			 
1ebf				; get current heap start after loading any uwords 
1ebf			 
1ebf				;ld de, (os_last_new_uword) 
1ebf				;ex de, hl 
1ebf			 
1ebf			; Or use heap_size word???? 
1ebf				;ld hl, heap_end 
1ebf				;ld hl, heap_size 
1ebf				;ld de, topusermem 
1ebf				;ld de, heap_start 
1ebf ed 5b 0a 80			ld de, (free_list )      
1ec3 21 d7 f0				ld hl, heap_end 
1ec6 ed 52			sbc hl, de 
1ec8				;push hl 
1ec8				;ld a,h	         	 
1ec8				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ec8				;call hexout 
1ec8			   	;pop hl 
1ec8			; 
1ec8			;	ld a,l 
1ec8			;	ld hl, os_word_scratch+2 
1ec8			;	call hexout 
1ec8			;	ld hl, os_word_scratch+4 
1ec8			;	ld a, 0 
1ec8			;	ld (hl),a 
1ec8 eb				ex de, hl 
1ec9 21 01 f4			ld hl, os_word_scratch 
1ecc cd 3b 15			call uitoa_16 
1ecf			 
1ecf			 
1ecf 11 01 f4			ld de, os_word_scratch 
1ed2 3e 0d			ld a, display_row_1 + 13 
1ed4 cd ae 0d			call str_at_display 
1ed7 cd be 0d			call update_display 
1eda			 
1eda			 
1eda				;call demo 
1eda			 
1eda			 
1eda				; init scratch input area for cli commands 
1eda			 
1eda 21 23 f4			ld hl, os_cli_cmd 
1edd 3e 00			ld a,0 
1edf 77				ld (hl),a 
1ee0 23				inc hl 
1ee1 77				ld (hl),a 
1ee2			 
1ee2 3e 00			ld a,0 
1ee4 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ee7			 
1ee7 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1eea 32 20 f4			ld (os_cur_ptr+1),a	 
1eed			 
1eed 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1ef0 32 02 f4			ld (os_word_scratch+1),a	 
1ef3				 
1ef3			 
1ef3				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ef3 21 23 f4			ld hl, os_cli_cmd 
1ef6			 
1ef6 3e 00			ld a, 0		 ; init cli input 
1ef8 77				ld (hl), a 
1ef9 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1efb			cli: 
1efb				; show cli prompt 
1efb				;push af 
1efb				;ld a, 0 
1efb				;ld de, prompt 
1efb				;call str_at_display 
1efb			 
1efb				;call update_display 
1efb				;pop af 
1efb				;inc a 
1efb				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1efb 0e 00			ld c, 0 
1efd 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1eff 1e 28			ld e, 40 
1f01			 
1f01 21 23 f4			ld hl, os_cli_cmd 
1f04			 
1f04				STACKFRAME OFF $fefe $9f9f 
1f04				if DEBUG_STACK_IMB 
1f04					if OFF 
1f04						exx 
1f04						ld de, $fefe 
1f04						ld a, d 
1f04						ld hl, curframe 
1f04						call hexout 
1f04						ld a, e 
1f04						ld hl, curframe+2 
1f04						call hexout 
1f04						ld hl, $fefe 
1f04						push hl 
1f04						ld hl, $9f9f 
1f04						push hl 
1f04						exx 
1f04					endif 
1f04				endif 
1f04			endm 
# End of macro STACKFRAME
1f04			 
1f04 cd fc 0f			call input_str 
1f07			 
1f07				STACKFRAMECHK OFF $fefe $9f9f 
1f07				if DEBUG_STACK_IMB 
1f07					if OFF 
1f07						exx 
1f07						ld hl, $9f9f 
1f07						pop de   ; $9f9f 
1f07						call cmp16 
1f07						jr nz, .spnosame 
1f07						ld hl, $fefe 
1f07						pop de   ; $fefe 
1f07						call cmp16 
1f07						jr z, .spfrsame 
1f07						.spnosame: call showsperror 
1f07						.spfrsame: nop 
1f07						exx 
1f07					endif 
1f07				endif 
1f07			endm 
# End of macro STACKFRAMECHK
1f07			 
1f07				; copy input to last command 
1f07			 
1f07 21 23 f4			ld hl, os_cli_cmd 
1f0a 11 22 f5			ld de, os_last_cmd 
1f0d 01 ff 00			ld bc, 255 
1f10 ed b0			ldir 
1f12			 
1f12				; wipe current buffer 
1f12			 
1f12			;	ld a, 0 
1f12			;	ld hl, os_cli_cmd 
1f12			;	ld de, os_cli_cmd+1 
1f12			;	ld bc, 254 
1f12			;	ldir 
1f12				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1f12			;	call strcpy 
1f12			;	ld a, 0 
1f12			;	ld (hl), a 
1f12			;	inc hl 
1f12			;	ld (hl), a 
1f12			;	inc hl 
1f12			;	ld (hl), a 
1f12			 
1f12				; switch frame buffer to program  
1f12			 
1f12 21 4b fc				ld hl, display_fb1 
1f15 22 07 fb				ld (display_fb_active), hl 
1f18			 
1f18			;	nop 
1f18				STACKFRAME ON $fbfe $8f9f 
1f18				if DEBUG_STACK_IMB 
1f18					if ON 
1f18						exx 
1f18						ld de, $fbfe 
1f18						ld a, d 
1f18						ld hl, curframe 
1f18						call hexout 
1f18						ld a, e 
1f18						ld hl, curframe+2 
1f18						call hexout 
1f18						ld hl, $fbfe 
1f18						push hl 
1f18						ld hl, $8f9f 
1f18						push hl 
1f18						exx 
1f18					endif 
1f18				endif 
1f18			endm 
# End of macro STACKFRAME
1f18				; first time into the parser so pass over the current scratch pad 
1f18 21 23 f4			ld hl,os_cli_cmd 
1f1b				; tokenise the entered statement(s) in HL 
1f1b cd 5d 26			call forthparse 
1f1e			        ; exec forth statements in top of return stack 
1f1e cd 9d 26			call forthexec 
1f21				;call forthexec_cleanup 
1f21			;	call parsenext 
1f21			 
1f21				STACKFRAMECHK ON $fbfe $8f9f 
1f21				if DEBUG_STACK_IMB 
1f21					if ON 
1f21						exx 
1f21						ld hl, $8f9f 
1f21						pop de   ; $8f9f 
1f21						call cmp16 
1f21						jr nz, .spnosame 
1f21						ld hl, $fbfe 
1f21						pop de   ; $fbfe 
1f21						call cmp16 
1f21						jr z, .spfrsame 
1f21						.spnosame: call showsperror 
1f21						.spfrsame: nop 
1f21						exx 
1f21					endif 
1f21				endif 
1f21			endm 
# End of macro STACKFRAMECHK
1f21				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1f21			 
1f21 3e 78			ld a, display_row_4 
1f23 11 54 1f			ld de, endprog 
1f26			 
1f26 cd be 0d			call update_display		 
1f29			 
1f29 cd da 21			call next_page_prompt 
1f2c			 
1f2c				; switch frame buffer to cli 
1f2c			 
1f2c 21 ec fc				ld hl, display_fb0 
1f2f 22 07 fb				ld (display_fb_active), hl 
1f32			 
1f32			 
1f32 cd 9b 0d		        call clear_display 
1f35 cd be 0d			call update_display		 
1f38			 
1f38 21 23 f4			ld hl, os_cli_cmd 
1f3b			 
1f3b 3e 00			ld a, 0		 ; init cli input 
1f3d 77				ld (hl), a 
1f3e			 
1f3e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1f3e			 
1f3e				; now on last line 
1f3e			 
1f3e				; TODO scroll screen up 
1f3e			 
1f3e				; TODO instead just clear screen and place at top of screen 
1f3e			 
1f3e			;	ld a, 0 
1f3e			;	ld (f_cursor_ptr),a 
1f3e			 
1f3e				;call clear_display 
1f3e				;call update_display 
1f3e			 
1f3e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1f3e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1f40 c3 fb 1e			jp cli 
1f43			 
1f43 .. 00		freeram: db "Free bytes: ",0 
1f50 ..			asc: db "1A2F" 
1f54 .. 00		endprog: db "End prog...",0 
1f60			 
1f60			testenter2:   
1f60 21 2e f1			ld hl,scratch+50 
1f63 22 1f f4			ld (os_cur_ptr),hl 
1f66 c3 fb 1e			jp cli 
1f69			 
1f69			testenter:  
1f69			 
1f69 21 50 1f			ld hl,asc 
1f6c			;	ld a,(hl) 
1f6c			;	call nibble2val 
1f6c cd 85 14			call get_byte 
1f6f			 
1f6f			 
1f6f			;	ld a,(hl) 
1f6f			;	call atohex 
1f6f			 
1f6f			;	call fourehexhl 
1f6f 32 2e f1			ld (scratch+50),a 
1f72			 
1f72			 
1f72			 
1f72 21 52 1f			ld hl,asc+2 
1f75			;	ld a, (hl) 
1f75			;	call nibble2val 
1f75 cd 85 14			call get_byte 
1f78			 
1f78			;	call fourehexhl 
1f78 32 30 f1			ld (scratch+52),a 
1f7b				 
1f7b 21 2e f1			ld hl,scratch+50 
1f7e 22 1f f4			ld (os_cur_ptr),hl 
1f81 c3 fb 1e			jp cli 
1f84			 
1f84			enter:	 
1f84 3a 00 f1			ld a,(scratch+4) 
1f87 fe 00			cp 0 
1f89 28 0c			jr z, .entercont 
1f8b				; no, not a null term line so has an address to work out.... 
1f8b			 
1f8b 21 fe f0			ld hl,scratch+2 
1f8e cd e5 14			call get_word_hl 
1f91			 
1f91 22 1f f4			ld (os_cur_ptr),hl	 
1f94 c3 fb 1e			jp cli 
1f97			 
1f97			 
1f97			.entercont:  
1f97			 
1f97 21 fe f0			ld hl, scratch+2 
1f9a cd 85 14			call get_byte 
1f9d			 
1f9d 2a 1f f4		   	ld hl,(os_cur_ptr) 
1fa0 77					ld (hl),a 
1fa1 23					inc hl 
1fa2 22 1f f4				ld (os_cur_ptr),hl 
1fa5				 
1fa5			; get byte  
1fa5			 
1fa5			 
1fa5 c3 fb 1e			jp cli 
1fa8			 
1fa8			 
1fa8			; basic monitor support 
1fa8			 
1fa8			monitor: 
1fa8				;  
1fa8 cd 9b 0d			call clear_display 
1fab 3e 00			ld a, 0 
1fad 11 fc 1f			ld de, .monprompt 
1fb0 cd ae 0d			call str_at_display 
1fb3 cd be 0d			call update_display 
1fb6			 
1fb6				; get a monitor command 
1fb6			 
1fb6 0e 00			ld c, 0     ; entry at top left 
1fb8 16 64			ld d, 100   ; max buffer size 
1fba 1e 0f			ld e, 15    ; input scroll area 
1fbc 3e 00			ld a, 0     ; init string 
1fbe 21 fa f2			ld hl, os_input 
1fc1 77				ld (hl), a 
1fc2 23				inc hl 
1fc3 77				ld (hl), a 
1fc4 21 fa f2			ld hl, os_input 
1fc7 3e 01			ld a, 1     ; init string 
1fc9 cd fc 0f			call input_str 
1fcc			 
1fcc cd 9b 0d		        call clear_display 
1fcf cd be 0d			call update_display		 
1fd2			 
1fd2 3a fa f2			ld a, (os_input) 
1fd5 cd 83 15			call toUpper 
1fd8 fe 48		        cp 'H' 
1fda ca 61 20		        jp z, .monhelp 
1fdd fe 44			cp 'D'		; dump 
1fdf ca 94 20			jp z, .mondump	 
1fe2 fe 43			cp 'C'		; dump 
1fe4 ca ae 20			jp z, .moncdump	 
1fe7 fe 4d			cp 'M'		; dump 
1fe9 ca fe 1f			jp z, .moneditstart 
1fec fe 55			cp 'U'		; dump 
1fee ca 0a 20			jp z, .monedit	 
1ff1 fe 47			cp 'G'		; dump 
1ff3 ca 8a 20			jp z, .monjump 
1ff6 fe 51			cp 'Q'		; dump 
1ff8 c8				ret z	 
1ff9			 
1ff9			 
1ff9				; TODO "S" to access symbol by name and not need the address 
1ff9				; TODO "F" to find a string in memory 
1ff9			 
1ff9 c3 a8 1f			jp monitor 
1ffc			 
1ffc .. 00		.monprompt: db ">", 0 
1ffe			 
1ffe			.moneditstart: 
1ffe				; get starting address 
1ffe			 
1ffe 21 fc f2			ld hl,os_input+2 
2001 cd e5 14			call get_word_hl 
2004			 
2004 22 1f f4			ld (os_cur_ptr),hl	 
2007			 
2007 c3 a8 1f			jp monitor 
200a			 
200a			.monedit: 
200a				; get byte to load 
200a			 
200a 21 fc f2			ld hl,os_input+2 
200d cd 85 14			call get_byte 
2010			 
2010				; get address to update 
2010 2a 1f f4			ld hl, (os_cur_ptr) 
2013			 
2013				; update byte 
2013			 
2013 77				ld (hl), a 
2014			 
2014				; move to next address and save it 
2014			 
2014 23				inc hl 
2015 22 1f f4			ld (os_cur_ptr),hl	 
2018			 
2018 c3 a8 1f			jp monitor 
201b			 
201b			 
201b .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
202f .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
204b .. 00		.monhelptext3:  db "G-Call address",0 
205a .. 00		.monhelptext4:  db "Q-Quit",0 
2061			        
2061			.monhelp: 
2061 3e 00			ld a, display_row_1 
2063 11 1b 20		        ld de, .monhelptext1 
2066			 
2066 cd ae 0d			call str_at_display 
2069 3e 28			ld a, display_row_2 
206b 11 2f 20		        ld de, .monhelptext2 
206e					 
206e cd ae 0d			call str_at_display 
2071 3e 50			ld a, display_row_3 
2073 11 4b 20		        ld de, .monhelptext3 
2076					 
2076 cd ae 0d			call str_at_display 
2079 3e 78			ld a, display_row_4 
207b 11 5a 20		        ld de, .monhelptext4 
207e cd ae 0d			call str_at_display 
2081			 
2081 cd be 0d			call update_display		 
2084			 
2084 cd da 21			call next_page_prompt 
2087 c3 a8 1f			jp monitor 
208a			 
208a			.monjump:    
208a 21 fc f2			ld hl,os_input+2 
208d cd e5 14			call get_word_hl 
2090			 
2090 e9				jp (hl) 
2091 c3 a8 1f			jp monitor 
2094			 
2094			.mondump:    
2094 21 fc f2			ld hl,os_input+2 
2097 cd e5 14			call get_word_hl 
209a			 
209a 22 1f f4			ld (os_cur_ptr),hl	 
209d cd e2 20			call dumpcont 
20a0 3e 78			ld a, display_row_4 
20a2 11 54 1f			ld de, endprog 
20a5			 
20a5 cd be 0d			call update_display		 
20a8			 
20a8 cd da 21			call next_page_prompt 
20ab c3 a8 1f			jp monitor 
20ae			.moncdump: 
20ae cd e2 20			call dumpcont 
20b1 3e 78			ld a, display_row_4 
20b3 11 54 1f			ld de, endprog 
20b6			 
20b6 cd be 0d			call update_display		 
20b9			 
20b9 cd da 21			call next_page_prompt 
20bc c3 a8 1f			jp monitor 
20bf			 
20bf			 
20bf			; TODO symbol access  
20bf			 
20bf			.symbols:     ;; A list of symbols that can be called up  
20bf ec fc			dw display_fb0 
20c1 .. 00			db "fb0",0  
20c5 b5 f9		     	dw store_page 
20c7 .. 00			db "store_page",0 
20d2			 
20d2			 
20d2			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
20d2			 
20d2 3a fd f0			ld a,(scratch+1) 
20d5 fe 00			cp 0 
20d7 28 09			jr z, dumpcont 
20d9			 
20d9				; no, not a null term line so has an address to work out.... 
20d9			 
20d9 21 fe f0			ld hl,scratch+2 
20dc cd e5 14			call get_word_hl 
20df			 
20df 22 1f f4			ld (os_cur_ptr),hl	 
20e2			 
20e2			 
20e2			 
20e2			dumpcont: 
20e2			 
20e2				; dump bytes at ptr 
20e2			 
20e2			 
20e2 3e 00			ld a, display_row_1 
20e4 2a 07 fb			ld hl, (display_fb_active) 
20e7 cd cf 0f			call addatohl 
20ea cd 12 21			call .dumpbyterow 
20ed			 
20ed 3e 28			ld a, display_row_2 
20ef 2a 07 fb			ld hl, (display_fb_active) 
20f2 cd cf 0f			call addatohl 
20f5 cd 12 21			call .dumpbyterow 
20f8			 
20f8			 
20f8 3e 50			ld a, display_row_3 
20fa 2a 07 fb			ld hl, (display_fb_active) 
20fd cd cf 0f			call addatohl 
2100 cd 12 21			call .dumpbyterow 
2103			 
2103 3e 78			ld a, display_row_4 
2105 2a 07 fb			ld hl, (display_fb_active) 
2108 cd cf 0f			call addatohl 
210b cd 12 21			call .dumpbyterow 
210e			 
210e cd be 0d			call update_display 
2111			;		jp cli 
2111 c9				ret 
2112			 
2112			.dumpbyterow: 
2112			 
2112				;push af 
2112			 
2112 e5				push hl 
2113			 
2113				; calc where to poke the ascii 
2113			if display_cols == 20 
2113				ld a, 16 
2113			else 
2113 3e 1f			ld a, 31 
2115			endif 
2115			 
2115 cd cf 0f			call addatohl 
2118 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
211b			 
211b			 
211b			; display decoding address 
211b 2a 1f f4		   	ld hl,(os_cur_ptr) 
211e			 
211e 7c				ld a,h 
211f e1				pop hl 
2120 e5				push hl 
2121			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
2121 cd 2f 14			call hexout 
2124 2a 1f f4		   	ld hl,(os_cur_ptr) 
2127			 
2127 7d				ld a,l 
2128 e1				pop hl 
2129 23				inc hl 
212a 23				inc hl 
212b e5				push hl 
212c			;	ld hl, os_word_scratch+2 
212c cd 2f 14			call hexout 
212f e1				pop hl 
2130 23				inc hl 
2131 23				inc hl 
2132				;ld hl, os_word_scratch+4 
2132 3e 3a			ld a, ':' 
2134 77				ld (hl),a 
2135 23				inc hl 
2136				;ld a, 0 
2136				;ld (hl),a 
2136				;ld de, os_word_scratch 
2136				;pop af 
2136				;push af 
2136			;		ld a, display_row_2 
2136			;		call str_at_display 
2136			;		call update_display 
2136			 
2136			 
2136			;pop af 
2136			;	add 5 
2136			 
2136			if display_cols == 20 
2136				ld b, 4 
2136			else 
2136 06 08			ld b, 8 
2138			endif	 
2138			 
2138			.dumpbyte: 
2138 c5				push bc 
2139 e5				push hl 
213a			 
213a			 
213a 2a 1f f4		   	ld hl,(os_cur_ptr) 
213d 7e					ld a,(hl) 
213e			 
213e					; poke the ascii to display 
213e 2a 01 f4				ld hl,(os_word_scratch) 
2141 77					ld (hl),a 
2142 23					inc hl 
2143 22 01 f4				ld (os_word_scratch),hl 
2146			 
2146					 
2146			 
2146			 
2146 e1					pop hl 
2147 e5					push hl 
2148			 
2148 cd 2f 14				call hexout 
214b			 
214b					 
214b 2a 1f f4		   	ld hl,(os_cur_ptr) 
214e 23				inc hl 
214f 22 1f f4		   	ld (os_cur_ptr),hl 
2152			 
2152 e1					pop hl 
2153 23					inc hl 
2154 23					inc hl 
2155 23					inc hl 
2156			 
2156			 
2156			 
2156					;ld a,0 
2156					;ld (os_word_scratch+2),a 
2156					;pop af 
2156					;push af 
2156			 
2156					;ld de, os_word_scratch 
2156					;call str_at_display 
2156			;		call update_display 
2156			;		pop af 
2156 c1					pop bc 
2157 c6 03				add 3 
2159 10 dd			djnz .dumpbyte 
215b			 
215b				 
215b			 
215b c9				ret 
215c			 
215c			jump:	 
215c			 
215c 21 fe f0			ld hl,scratch+2 
215f cd e5 14			call get_word_hl 
2162				;ld hl,(scratch+2) 
2162				;call fourehexhl 
2162			 
2162 22 1f f4			ld (os_cur_ptr),hl	 
2165			 
2165 e9				jp (hl) 
2166			 
2166			 
2166			 
2166			; TODO implement a basic monitor mode to start with 
2166			 
2166			 
2166			 
2166			 
2166			 
2166			 
2166			 
2166			 
2166			 
2166			; testing and demo code during development 
2166			 
2166			 
2166 .. 00		str1: db "Enter some text...",0 
2179 .. 00		clear: db "                    ",0 
218e			 
218e			demo: 
218e			 
218e			 
218e			 
218e			;	call update_display 
218e			 
218e				; init scratch input area for testing 
218e 21 fc f0			ld hl, scratch	 
2191 3e 00			ld a,0 
2193 77				ld (hl),a 
2194			 
2194			 
2194 3e 28		            LD   A, display_row_2 
2196			;            CALL fLCD_Pos       ;Position cursor to location in A 
2196 11 66 21		            LD   DE, str1 
2199 cd ae 0d			call str_at_display 
219c			 
219c			;            CALL fLCD_Str       ;Display string pointed to by DE 
219c			cloop:	 
219c 3e 50		            LD   A, display_row_3 
219e			;            CALL fLCD_Pos       ;Position cursor to location in A 
219e 11 79 21		            LD   DE, clear 
21a1			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
21a1 cd ae 0d				call str_at_display 
21a4 3e 78			ld a, display_row_4 
21a6 11 d6 21			ld de, prompt 
21a9			 
21a9 cd ae 0d				call str_at_display 
21ac cd be 0d			call update_display 
21af			 
21af 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
21b1 16 0a			ld d, 10 
21b3 21 fc f0			ld hl, scratch	 
21b6 cd fc 0f			call input_str 
21b9			 
21b9			;	call clear_display 
21b9			;'	call update_display 
21b9			 
21b9 3e 00		            LD   A, display_row_1 
21bb			;            CALL fLCD_Pos       ;Position cursor to location in A 
21bb 11 79 21		            LD   DE, clear 
21be cd ae 0d				call str_at_display 
21c1			;            CALL fLCD_Str       ;Display string pointed to by DE 
21c1 3e 00		            LD   A, display_row_1 
21c3			;            CALL fLCD_Pos       ;Position cursor to location in A 
21c3 11 fc f0		            LD   DE, scratch 
21c6			;            CALL fLCD_Str       ;Display string pointed to by DE 
21c6 cd ae 0d				call str_at_display 
21c9 cd be 0d			call update_display 
21cc			 
21cc 3e 00				ld a,0 
21ce 21 fc f0			ld hl, scratch 
21d1 77				ld (hl),a 
21d2			 
21d2 00				nop 
21d3 c3 9c 21			jp cloop 
21d6			 
21d6			 
21d6			 
21d6			; OS Prompt 
21d6			 
21d6 .. 00		prompt: db ">",0 
21d8 .. 00		endprg: db "?",0 
21da			 
21da			 
21da			; handy next page prompt 
21da			next_page_prompt: 
21da e5				push hl 
21db d5				push de 
21dc f5				push af 
21dd c5				push bc 
21de			 
21de 3e 9f			ld a,display_row_4 + display_cols - 1 
21e0 11 d8 21		        ld de, endprg 
21e3 cd ae 0d			call str_at_display 
21e6 cd be 0d			call update_display 
21e9 cd cb 7b			call cin_wait 
21ec c1				pop bc 
21ed f1				pop af 
21ee d1				pop de 
21ef e1				pop hl 
21f0			 
21f0			 
21f0 c9				ret 
21f1			 
21f1			 
21f1			; forth parser 
21f1			 
21f1			; My forth kernel 
21f1			include "forth_kernel.asm" 
21f1			; 
21f1			; kernel to the forth OS 
21f1			 
21f1			DS_TYPE_STR: equ 1     ; string type 
21f1			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
21f1			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
21f1			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
21f1			 
21f1			FORTH_PARSEV1: equ 0 
21f1			FORTH_PARSEV2: equ 0 
21f1			FORTH_PARSEV3: equ 0 
21f1			FORTH_PARSEV4: equ 0 
21f1			FORTH_PARSEV5: equ 1 
21f1			 
21f1			;if FORTH_PARSEV5 
21f1			;	FORTH_END_BUFFER: equ 0 
21f1			;else 
21f1			FORTH_END_BUFFER: equ 127 
21f1			;endif 
21f1			 
21f1			FORTH_TRUE: equ 1 
21f1			FORTH_FALSE: equ 0 
21f1			 
21f1			if FORTH_PARSEV4 
21f1			include "forth_stackops.asm" 
21f1			endif 
21f1			 
21f1			if FORTH_PARSEV5 
21f1			include "forth_stackopsv5.asm" 
21f1			 
21f1			; Stack operations for v5 parser on wards 
21f1			; * DATA stack 
21f1			; * LOOP stack 
21f1			; * RETURN stack 
21f1			 
21f1			 
21f1			 
21f1			FORTH_CHK_DSP_UNDER: macro 
21f1				push hl 
21f1				push de 
21f1				ld hl,(cli_data_sp) 
21f1				ld de, cli_data_stack 
21f1				call cmp16 
21f1				jp c, fault_dsp_under 
21f1				pop de 
21f1				pop hl 
21f1				endm 
21f1			 
21f1			 
21f1			FORTH_CHK_RSP_UNDER: macro 
21f1				push hl 
21f1				push de 
21f1				ld hl,(cli_ret_sp) 
21f1				ld de, cli_ret_stack 
21f1				call cmp16 
21f1				jp c, fault_rsp_under 
21f1				pop de 
21f1				pop hl 
21f1				endm 
21f1			 
21f1			FORTH_CHK_LOOP_UNDER: macro 
21f1				push hl 
21f1				push de 
21f1				ld hl,(cli_loop_sp) 
21f1				ld de, cli_loop_stack 
21f1				call cmp16 
21f1				jp c, fault_loop_under 
21f1				pop de 
21f1				pop hl 
21f1				endm 
21f1			 
21f1			FORTH_ERR_TOS_NOTSTR: macro 
21f1				; TOSO might need more for checks when used 
21f1				push af 
21f1				ld a,(hl) 
21f1				cp DS_TYPE_STR 
21f1				jp nz, type_faultn   
21f1				pop af 
21f1				endm 
21f1			 
21f1			FORTH_ERR_TOS_NOTNUM: macro 
21f1				push af 
21f1				ld a,(hl) 
21f1				cp DS_TYPE_INUM 
21f1				jp nz, type_faultn   
21f1				pop af 
21f1				endm 
21f1			 
21f1			 
21f1			; increase data stack pointer and save hl to it 
21f1				 
21f1			FORTH_DSP_NEXT: macro 
21f1				call macro_forth_dsp_next 
21f1				endm 
21f1			 
21f1			 
21f1			macro_forth_dsp_next: 
21f1				if DEBUG_FORTH_STACK_GUARD 
21f1 cd 78 74				call check_stacks 
21f4				endif 
21f4 e5				push hl 
21f5 d5				push de 
21f6 eb				ex de,hl 
21f7 2a 29 f9			ld hl,(cli_data_sp) 
21fa 23				inc hl 
21fb 23				inc hl 
21fc			 
21fc			; PARSEV5 
21fc 23				inc hl 
21fd 22 29 f9			ld (cli_data_sp),hl 
2200 73				ld (hl), e 
2201 23				inc hl 
2202 72				ld (hl), d 
2203 d1				pop de 
2204 e1				pop hl 
2205				if DEBUG_FORTH_STACK_GUARD 
2205 cd 78 74				call check_stacks 
2208				endif 
2208 c9				ret 
2209			 
2209			 
2209			; increase ret stack pointer and save hl to it 
2209				 
2209			FORTH_RSP_NEXT: macro 
2209				call macro_forth_rsp_next 
2209				endm 
2209			 
2209			macro_forth_rsp_next: 
2209				if DEBUG_FORTH_STACK_GUARD 
2209 cd 78 74				call check_stacks 
220c				endif 
220c e5				push hl 
220d d5				push de 
220e eb				ex de,hl 
220f 2a 2d f9			ld hl,(cli_ret_sp) 
2212 23				inc hl 
2213 23				inc hl 
2214 22 2d f9			ld (cli_ret_sp),hl 
2217 73				ld (hl), e 
2218 23				inc hl 
2219 72				ld (hl), d 
221a d1				pop de 
221b e1				pop hl 
221c				if DEBUG_FORTH_STACK_GUARD 
221c cd 78 74				call check_stacks 
221f				endif 
221f c9				ret 
2220			 
2220			; get current ret stack pointer and save to hl  
2220				 
2220			FORTH_RSP_TOS: macro 
2220				call macro_forth_rsp_tos 
2220				endm 
2220			 
2220			macro_forth_rsp_tos: 
2220				;push de 
2220 2a 2d f9			ld hl,(cli_ret_sp) 
2223 cd 5b 22			call loadhlptrtohl 
2226				;ld e, (hl) 
2226				;inc hl 
2226				;ld d, (hl) 
2226				;ex de, hl 
2226					if DEBUG_FORTH_WORDS 
2226			;			DMARK "RST" 
2226						CALLMONITOR 
2226 cd aa fd			call debug_vector  
2229				endm  
# End of macro CALLMONITOR
2229					endif 
2229				;pop de 
2229 c9				ret 
222a			 
222a			; pop ret stack pointer 
222a				 
222a			FORTH_RSP_POP: macro 
222a				call macro_forth_rsp_pop 
222a				endm 
222a			 
222a			 
222a			macro_forth_rsp_pop: 
222a				if DEBUG_FORTH_STACK_GUARD 
222a			;		DMARK "RPP" 
222a cd 78 74				call check_stacks 
222d					FORTH_CHK_RSP_UNDER 
222d e5				push hl 
222e d5				push de 
222f 2a 2d f9			ld hl,(cli_ret_sp) 
2232 11 e7 f8			ld de, cli_ret_stack 
2235 cd ed 0f			call cmp16 
2238 da 8c 75			jp c, fault_rsp_under 
223b d1				pop de 
223c e1				pop hl 
223d				endm 
# End of macro FORTH_CHK_RSP_UNDER
223d				endif 
223d e5				push hl 
223e 2a 2d f9			ld hl,(cli_ret_sp) 
2241			 
2241			 
2241				if FORTH_ENABLE_FREE 
2241			 
2241					; get pointer 
2241			 
2241					push de 
2241					push hl 
2241			 
2241					ld e, (hl) 
2241					inc hl 
2241					ld d, (hl) 
2241			 
2241					ex de, hl 
2241					call free 
2241			 
2241					pop hl 
2241					pop de 
2241			 
2241			 
2241				endif 
2241			 
2241			 
2241 2b				dec hl 
2242 2b				dec hl 
2243 22 2d f9			ld (cli_ret_sp), hl 
2246				; do stack underflow checks 
2246 e1				pop hl 
2247				if DEBUG_FORTH_STACK_GUARD 
2247 cd 78 74				call check_stacks 
224a					FORTH_CHK_RSP_UNDER 
224a e5				push hl 
224b d5				push de 
224c 2a 2d f9			ld hl,(cli_ret_sp) 
224f 11 e7 f8			ld de, cli_ret_stack 
2252 cd ed 0f			call cmp16 
2255 da 8c 75			jp c, fault_rsp_under 
2258 d1				pop de 
2259 e1				pop hl 
225a				endm 
# End of macro FORTH_CHK_RSP_UNDER
225a				endif 
225a c9				ret 
225b			 
225b			 
225b			 
225b			; routine to load word pointed to by hl into hl 
225b			 
225b			loadhlptrtohl: 
225b			 
225b d5				push de 
225c 5e				ld e, (hl) 
225d 23				inc hl 
225e 56				ld d, (hl) 
225f eb				ex de, hl 
2260 d1				pop de 
2261			 
2261 c9				ret 
2262			 
2262			 
2262			 
2262			 
2262			 
2262			; push a number held in HL onto the data stack 
2262			; entry point for pushing a value when already in hl used in function above 
2262			 
2262			forth_push_numhl: 
2262			 
2262 e5				push hl    ; save value to push 
2263			 
2263			if DEBUG_FORTH_PUSH 
2263				; see if disabled 
2263			 
2263			 
2263 f5				push af 
2264 3a aa fd			ld a,(debug_vector) 
2267 fe c9			cp $c9   ; ret 
2269			;	ld a, (os_view_disable) 
2269			;	cp '*' 
2269 28 34			jr z, .pskip2 
226b e5				push hl 
226c e5			push hl 
226d cd 9b 0d			call clear_display 
2270 e1			pop hl 
2271 7c				ld a,h 
2272 21 01 f4			ld hl, os_word_scratch 
2275 cd 2f 14			call hexout 
2278 e1				pop hl 
2279 7d				ld a,l 
227a 21 03 f4			ld hl, os_word_scratch+2 
227d cd 2f 14			call hexout 
2280			 
2280 21 05 f4			ld hl, os_word_scratch+4 
2283 3e 00			ld a,0 
2285 77				ld (hl),a 
2286 11 01 f4			ld de,os_word_scratch 
2289 3e 28				ld a, display_row_2 
228b cd ae 0d				call str_at_display 
228e 11 8a 5f			ld de, .push_num 
2291 3e 00			ld a, display_row_1 
2293			 
2293 cd ae 0d				call str_at_display 
2296			 
2296			 
2296 cd be 0d			call update_display 
2299 cd de 0c			call delay1s 
229c cd de 0c			call delay1s 
229f			.pskip2:  
229f			 
229f f1				pop af 
22a0			endif	 
22a0			 
22a0			 
22a0				FORTH_DSP_NEXT 
22a0 cd f1 21			call macro_forth_dsp_next 
22a3				endm 
# End of macro FORTH_DSP_NEXT
22a3			 
22a3 2a 29 f9			ld hl, (cli_data_sp) 
22a6			 
22a6				; save item type 
22a6 3e 02			ld a,  DS_TYPE_INUM 
22a8 77				ld (hl), a 
22a9 23				inc hl 
22aa			 
22aa				; get word off stack 
22aa d1				pop de 
22ab 7b				ld a,e 
22ac 77				ld (hl), a 
22ad 23				inc hl 
22ae 7a				ld a,d 
22af 77				ld (hl), a 
22b0			 
22b0			if DEBUG_FORTH_PUSH 
22b0 2b				dec hl 
22b1 2b				dec hl 
22b2 2b				dec hl 
22b3						DMARK "PH5" 
22b3 f5				push af  
22b4 3a c8 22			ld a, (.dmark)  
22b7 32 a6 fd			ld (debug_mark),a  
22ba 3a c9 22			ld a, (.dmark+1)  
22bd 32 a7 fd			ld (debug_mark+1),a  
22c0 3a ca 22			ld a, (.dmark+2)  
22c3 32 a8 fd			ld (debug_mark+2),a  
22c6 18 03			jr .pastdmark  
22c8 ..			.dmark: db "PH5"  
22cb f1			.pastdmark: pop af  
22cc			endm  
# End of macro DMARK
22cc				CALLMONITOR 
22cc cd aa fd			call debug_vector  
22cf				endm  
# End of macro CALLMONITOR
22cf			endif	 
22cf			 
22cf c9				ret 
22d0			 
22d0			 
22d0			; Push a string to stack pointed to by hl 
22d0			 
22d0			forth_push_str: 
22d0			 
22d0			if DEBUG_FORTH_PUSH 
22d0						DMARK "PSQ" 
22d0 f5				push af  
22d1 3a e5 22			ld a, (.dmark)  
22d4 32 a6 fd			ld (debug_mark),a  
22d7 3a e6 22			ld a, (.dmark+1)  
22da 32 a7 fd			ld (debug_mark+1),a  
22dd 3a e7 22			ld a, (.dmark+2)  
22e0 32 a8 fd			ld (debug_mark+2),a  
22e3 18 03			jr .pastdmark  
22e5 ..			.dmark: db "PSQ"  
22e8 f1			.pastdmark: pop af  
22e9			endm  
# End of macro DMARK
22e9				CALLMONITOR 
22e9 cd aa fd			call debug_vector  
22ec				endm  
# End of macro CALLMONITOR
22ec			endif	 
22ec			    
22ec e5				push hl 
22ed e5				push hl 
22ee			 
22ee			;	ld a, 0   ; find end of string 
22ee cd 8c 15			call strlenz 
22f1			if DEBUG_FORTH_PUSH 
22f1						DMARK "PQ2" 
22f1 f5				push af  
22f2 3a 06 23			ld a, (.dmark)  
22f5 32 a6 fd			ld (debug_mark),a  
22f8 3a 07 23			ld a, (.dmark+1)  
22fb 32 a7 fd			ld (debug_mark+1),a  
22fe 3a 08 23			ld a, (.dmark+2)  
2301 32 a8 fd			ld (debug_mark+2),a  
2304 18 03			jr .pastdmark  
2306 ..			.dmark: db "PQ2"  
2309 f1			.pastdmark: pop af  
230a			endm  
# End of macro DMARK
230a				CALLMONITOR 
230a cd aa fd			call debug_vector  
230d				endm  
# End of macro CALLMONITOR
230d			endif	 
230d eb				ex de, hl 
230e e1				pop hl   ; get ptr to start of string 
230f			if DEBUG_FORTH_PUSH 
230f						DMARK "PQ3" 
230f f5				push af  
2310 3a 24 23			ld a, (.dmark)  
2313 32 a6 fd			ld (debug_mark),a  
2316 3a 25 23			ld a, (.dmark+1)  
2319 32 a7 fd			ld (debug_mark+1),a  
231c 3a 26 23			ld a, (.dmark+2)  
231f 32 a8 fd			ld (debug_mark+2),a  
2322 18 03			jr .pastdmark  
2324 ..			.dmark: db "PQ3"  
2327 f1			.pastdmark: pop af  
2328			endm  
# End of macro DMARK
2328				CALLMONITOR 
2328 cd aa fd			call debug_vector  
232b				endm  
# End of macro CALLMONITOR
232b			endif	 
232b 19				add hl,de 
232c			if DEBUG_FORTH_PUSH 
232c						DMARK "PQE" 
232c f5				push af  
232d 3a 41 23			ld a, (.dmark)  
2330 32 a6 fd			ld (debug_mark),a  
2333 3a 42 23			ld a, (.dmark+1)  
2336 32 a7 fd			ld (debug_mark+1),a  
2339 3a 43 23			ld a, (.dmark+2)  
233c 32 a8 fd			ld (debug_mark+2),a  
233f 18 03			jr .pastdmark  
2341 ..			.dmark: db "PQE"  
2344 f1			.pastdmark: pop af  
2345			endm  
# End of macro DMARK
2345				CALLMONITOR 
2345 cd aa fd			call debug_vector  
2348				endm  
# End of macro CALLMONITOR
2348			endif	 
2348			 
2348 2b				dec hl    ; see if there is an optional trailing double quote 
2349 7e				ld a,(hl) 
234a fe 22			cp '"' 
234c 20 03			jr nz, .strnoq 
234e 3e 00			ld a, 0      ; get rid of double quote 
2350 77				ld (hl), a 
2351 23			.strnoq: inc hl 
2352			 
2352 3e 00			ld a, 0 
2354 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2355			 
2355 13				inc de ; add one for the type string 
2356 13				inc de ; add one for null term??? 
2357			 
2357				; tos is get string pointer again 
2357				; de contains space to allocate 
2357				 
2357 d5				push de 
2358			 
2358 eb				ex de, hl 
2359			 
2359				;push af 
2359			 
2359			if DEBUG_FORTH_PUSH 
2359						DMARK "PHm" 
2359 f5				push af  
235a 3a 6e 23			ld a, (.dmark)  
235d 32 a6 fd			ld (debug_mark),a  
2360 3a 6f 23			ld a, (.dmark+1)  
2363 32 a7 fd			ld (debug_mark+1),a  
2366 3a 70 23			ld a, (.dmark+2)  
2369 32 a8 fd			ld (debug_mark+2),a  
236c 18 03			jr .pastdmark  
236e ..			.dmark: db "PHm"  
2371 f1			.pastdmark: pop af  
2372			endm  
# End of macro DMARK
2372				CALLMONITOR 
2372 cd aa fd			call debug_vector  
2375				endm  
# End of macro CALLMONITOR
2375			endif	 
2375 cd 01 16			call malloc	; on ret hl now contains allocated memory 
2378				if DEBUG_FORTH_MALLOC_GUARD 
2378 cc e2 5f				call z,malloc_error 
237b				endif 
237b			 
237b				 
237b c1				pop bc    ; get length 
237c d1				pop de   ;  get string start    
237d			 
237d				; hl has destination from malloc 
237d			 
237d eb				ex de, hl    ; prep for ldir 
237e			 
237e d5				push de   ; save malloc area for DSP later 
237f				;push hl   ; save malloc area for DSP later 
237f			 
237f			if DEBUG_FORTH_PUSH 
237f						DMARK "PHc" 
237f f5				push af  
2380 3a 94 23			ld a, (.dmark)  
2383 32 a6 fd			ld (debug_mark),a  
2386 3a 95 23			ld a, (.dmark+1)  
2389 32 a7 fd			ld (debug_mark+1),a  
238c 3a 96 23			ld a, (.dmark+2)  
238f 32 a8 fd			ld (debug_mark+2),a  
2392 18 03			jr .pastdmark  
2394 ..			.dmark: db "PHc"  
2397 f1			.pastdmark: pop af  
2398			endm  
# End of macro DMARK
2398				CALLMONITOR 
2398 cd aa fd			call debug_vector  
239b				endm  
# End of macro CALLMONITOR
239b			endif	 
239b			 
239b			 
239b ed b0			ldir 
239d			 
239d			 
239d				; push malloc to data stack     macro?????  
239d			 
239d				FORTH_DSP_NEXT 
239d cd f1 21			call macro_forth_dsp_next 
23a0				endm 
# End of macro FORTH_DSP_NEXT
23a0			 
23a0				; save value and type 
23a0			 
23a0 2a 29 f9			ld hl, (cli_data_sp) 
23a3			 
23a3				; save item type 
23a3 3e 01			ld a,  DS_TYPE_STR 
23a5 77				ld (hl), a 
23a6 23				inc hl 
23a7			 
23a7				; get malloc word off stack 
23a7 d1				pop de 
23a8 73				ld (hl), e 
23a9 23				inc hl 
23aa 72				ld (hl), d 
23ab			 
23ab			 
23ab			 
23ab			if DEBUG_FORTH_PUSH 
23ab 2a 29 f9			ld hl, (cli_data_sp) 
23ae						DMARK "PHS" 
23ae f5				push af  
23af 3a c3 23			ld a, (.dmark)  
23b2 32 a6 fd			ld (debug_mark),a  
23b5 3a c4 23			ld a, (.dmark+1)  
23b8 32 a7 fd			ld (debug_mark+1),a  
23bb 3a c5 23			ld a, (.dmark+2)  
23be 32 a8 fd			ld (debug_mark+2),a  
23c1 18 03			jr .pastdmark  
23c3 ..			.dmark: db "PHS"  
23c6 f1			.pastdmark: pop af  
23c7			endm  
# End of macro DMARK
23c7				CALLMONITOR 
23c7 cd aa fd			call debug_vector  
23ca				endm  
# End of macro CALLMONITOR
23ca			;	ex de,hl 
23ca			endif	 
23ca				; in case of spaces, skip the ptr past the copied string 
23ca				;pop af 
23ca				;ld (cli_origptr),hl 
23ca			 
23ca c9				ret 
23cb			 
23cb			 
23cb			 
23cb			; TODO ascii push input onto stack given hl to start of input 
23cb			 
23cb			; identify type 
23cb			; if starts with a " then a string 
23cb			; otherwise it is a number 
23cb			;  
23cb			; if a string 
23cb			;     scan for ending " to get length of string to malloc for + 1 
23cb			;     malloc 
23cb			;     put pointer to string on stack first byte flags as string 
23cb			; 
23cb			; else a number 
23cb			;    look for number format identifier 
23cb			;    $xx hex 
23cb			;    %xxxxx bin 
23cb			;    xxxxx decimal 
23cb			;    convert number to 16bit word.  
23cb			;    malloc word + 1 with flag to identiy as num 
23cb			;    put pointer to number on stack 
23cb			;   
23cb			;  
23cb			  
23cb			forth_apush: 
23cb				; kernel push 
23cb			 
23cb			if DEBUG_FORTH_PUSH 
23cb						DMARK "PSH" 
23cb f5				push af  
23cc 3a e0 23			ld a, (.dmark)  
23cf 32 a6 fd			ld (debug_mark),a  
23d2 3a e1 23			ld a, (.dmark+1)  
23d5 32 a7 fd			ld (debug_mark+1),a  
23d8 3a e2 23			ld a, (.dmark+2)  
23db 32 a8 fd			ld (debug_mark+2),a  
23de 18 03			jr .pastdmark  
23e0 ..			.dmark: db "PSH"  
23e3 f1			.pastdmark: pop af  
23e4			endm  
# End of macro DMARK
23e4				CALLMONITOR 
23e4 cd aa fd			call debug_vector  
23e7				endm  
# End of macro CALLMONITOR
23e7			endif	 
23e7				; identify input type 
23e7			 
23e7 7e				ld a,(hl) 
23e8 fe 22			cp '"' 
23ea 28 0a			jr z, .fapstr 
23ec fe 24			cp '$' 
23ee ca 16 24			jp z, .faphex 
23f1 fe 25			cp '%' 
23f3 ca fe 23			jp z, .fapbin 
23f6			;	cp 'b' 
23f6			;	jp z, .fabin 
23f6				; else decimal 
23f6			 
23f6				; TODO do decimal conversion 
23f6				; decimal is stored as a 16bit word 
23f6			 
23f6				; by default everything is a string if type is not detected 
23f6			.fapstr: ; 
23f6 fe 22			cp '"' 
23f8 20 01			jr nz, .strnoqu 
23fa 23				inc hl 
23fb			.strnoqu: 
23fb c3 d0 22			jp forth_push_str 
23fe			 
23fe			 
23fe			 
23fe			.fapbin:    ; push a binary string.  
23fe 11 00 00			ld de, 0   ; hold a 16bit value 
2401			 
2401 23			.fapbinshift:	inc hl  
2402 7e				ld a,(hl) 
2403 fe 00			cp 0     ; done scanning  
2405 28 0b			jr z, .fapbdone  	; got it in HL so push  
2407			 
2407				; left shift de 
2407 eb				ex de, hl	 
2408 29				add hl, hl 
2409			 
2409				; is 1 
2409 fe 31			cp '1' 
240b 20 02			jr nz, .binzero 
240d cb 4d			bit 1, l 
240f			.binzero: 
240f eb				ex de, hl	 ; save current de 
2410 18 ef			jr .fapbinshift 
2412			 
2412			.fapbdone: 
2412 eb				ex de, hl 
2413 c3 62 22			jp forth_push_numhl 
2416			 
2416			 
2416			.faphex:   ; hex is always stored as a 16bit word 
2416				; skip number prefix 
2416 23				inc hl 
2417				; turn ascii into number 
2417 cd e5 14			call get_word_hl	; ret 16bit word in hl 
241a			 
241a c3 62 22			jp forth_push_numhl 
241d			 
241d 00				 nop 
241e			 
241e			.fabin:   ; TODO bin conversion 
241e			 
241e			 
241e c9				ret 
241f			 
241f			 
241f			; get either a string ptr or a 16bit word from the data stack 
241f			 
241f			FORTH_DSP: macro 
241f				call macro_forth_dsp 
241f				endm 
241f			 
241f			macro_forth_dsp: 
241f				; data stack pointer points to current word on tos 
241f			 
241f 2a 29 f9			ld hl,(cli_data_sp) 
2422			 
2422				if DEBUG_FORTH_PUSH 
2422						DMARK "DSP" 
2422 f5				push af  
2423 3a 37 24			ld a, (.dmark)  
2426 32 a6 fd			ld (debug_mark),a  
2429 3a 38 24			ld a, (.dmark+1)  
242c 32 a7 fd			ld (debug_mark+1),a  
242f 3a 39 24			ld a, (.dmark+2)  
2432 32 a8 fd			ld (debug_mark+2),a  
2435 18 03			jr .pastdmark  
2437 ..			.dmark: db "DSP"  
243a f1			.pastdmark: pop af  
243b			endm  
# End of macro DMARK
243b			 
243b cd 15 60				call display_data_sp 
243e				;call break_point_state 
243e				;rst 030h 
243e				CALLMONITOR 
243e cd aa fd			call debug_vector  
2441				endm  
# End of macro CALLMONITOR
2441				endif 
2441			 
2441 c9				ret 
2442			 
2442			; return hl to start of value on stack 
2442			 
2442			FORTH_DSP_VALUE: macro 
2442				call macro_forth_dsp_value 
2442				endm 
2442			 
2442			macro_forth_dsp_value: 
2442			 
2442				FORTH_DSP 
2442 cd 1f 24			call macro_forth_dsp 
2445				endm 
# End of macro FORTH_DSP
2445			 
2445 d5				push de 
2446			 
2446 23				inc hl ; skip type 
2447			 
2447 5e				ld e, (hl) 
2448 23				inc hl 
2449 56				ld d, (hl) 
244a eb				ex de,hl  
244b			 
244b d1				pop de 
244c			 
244c c9				ret 
244d			 
244d			; return hl to start of value to second item on stack 
244d			 
244d			FORTH_DSP_VALUEM1: macro 
244d				call macro_forth_dsp_value_m1 
244d				endm 
244d			 
244d			macro_forth_dsp_value_m1: 
244d			 
244d				FORTH_DSP 
244d cd 1f 24			call macro_forth_dsp 
2450				endm 
# End of macro FORTH_DSP
2450			 
2450 2b				dec hl 
2451 2b				dec hl 
2452			;	dec hl 
2452			 
2452 d5				push de 
2453			 
2453 5e				ld e, (hl) 
2454 23				inc hl 
2455 56				ld d, (hl) 
2456 eb				ex de,hl  
2457			 
2457 d1				pop de 
2458			 
2458 c9				ret 
2459			 
2459				 
2459			 
2459			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2459			 
2459			FORTH_DSP_POP: macro 
2459				call macro_forth_dsp_pop 
2459				endm 
2459			 
2459			 
2459			; get the tos data type 
2459			 
2459			FORTH_DSP_TYPE:   macro 
2459			 
2459				;FORTH_DSP_VALUE 
2459				FORTH_DSP 
2459				 
2459				; hl points to value 
2459				; check type 
2459			 
2459				ld a,(hl) 
2459			 
2459				endm 
2459			 
2459			; load the tos value into hl 
2459			 
2459			 
2459			FORTH_DSP_VALUEHL:  macro 
2459				call macro_dsp_valuehl 
2459				endm 
2459			 
2459			 
2459			 
2459			macro_dsp_valuehl: 
2459				FORTH_DSP_VALUE 
2459 cd 42 24			call macro_forth_dsp_value 
245c				endm 
# End of macro FORTH_DSP_VALUE
245c			 
245c				;FORTH_ERR_TOS_NOTNUM 
245c			 
245c				;inc hl   ; skip type id 
245c			 
245c			;	push de 
245c			; 
245c			;	ld e, (hl) 
245c			;	inc hl 
245c			;	ld d, (hl) 
245c			;	ex de,hl  
245c			 
245c			;	pop de 
245c			 
245c				if DEBUG_FORTH_PUSH 
245c						DMARK "DVL" 
245c f5				push af  
245d 3a 71 24			ld a, (.dmark)  
2460 32 a6 fd			ld (debug_mark),a  
2463 3a 72 24			ld a, (.dmark+1)  
2466 32 a7 fd			ld (debug_mark+1),a  
2469 3a 73 24			ld a, (.dmark+2)  
246c 32 a8 fd			ld (debug_mark+2),a  
246f 18 03			jr .pastdmark  
2471 ..			.dmark: db "DVL"  
2474 f1			.pastdmark: pop af  
2475			endm  
# End of macro DMARK
2475				CALLMONITOR 
2475 cd aa fd			call debug_vector  
2478				endm  
# End of macro CALLMONITOR
2478				endif 
2478 c9				ret 
2479			 
2479			forth_apushstrhl:      
2479				; push of string requires use of cli_origptr 
2479				; bodge use 
2479			 
2479				; get current cli_origptr, save, update with temp pointer  
2479 ed 5b 79 f9		ld de, (cli_origptr) 
247d 22 79 f9			ld (cli_origptr), hl 
2480 d5				push de 
2481 cd cb 23			call forth_apush 
2484 d1				pop de 
2485 ed 53 79 f9		ld (cli_origptr), de 
2489 c9			        ret	 
248a			 
248a			 
248a			; increase loop stack pointer and save hl to it 
248a				 
248a			FORTH_LOOP_NEXT: macro 
248a				call macro_forth_loop_next 
248a				;nop 
248a				endm 
248a			 
248a			macro_forth_loop_next: 
248a				if DEBUG_FORTH_STACK_GUARD 
248a cd 78 74				call check_stacks 
248d				endif 
248d e5				push hl 
248e d5				push de 
248f eb				ex de,hl 
2490 2a 2b f9			ld hl,(cli_loop_sp) 
2493 23				inc hl 
2494 23				inc hl 
2495					if DEBUG_FORTH_WORDS 
2495						DMARK "LNX" 
2495 f5				push af  
2496 3a aa 24			ld a, (.dmark)  
2499 32 a6 fd			ld (debug_mark),a  
249c 3a ab 24			ld a, (.dmark+1)  
249f 32 a7 fd			ld (debug_mark+1),a  
24a2 3a ac 24			ld a, (.dmark+2)  
24a5 32 a8 fd			ld (debug_mark+2),a  
24a8 18 03			jr .pastdmark  
24aa ..			.dmark: db "LNX"  
24ad f1			.pastdmark: pop af  
24ae			endm  
# End of macro DMARK
24ae						CALLMONITOR 
24ae cd aa fd			call debug_vector  
24b1				endm  
# End of macro CALLMONITOR
24b1					endif 
24b1 22 2b f9			ld (cli_loop_sp),hl 
24b4 73				ld (hl), e 
24b5 23				inc hl 
24b6 72				ld (hl), d 
24b7 d1				pop de    ; been reversed so save a swap on restore 
24b8 e1				pop hl 
24b9				if DEBUG_FORTH_STACK_GUARD 
24b9 cd 78 74				call check_stacks 
24bc				endif 
24bc c9				ret 
24bd			 
24bd			; get current ret stack pointer and save to hl  
24bd				 
24bd			FORTH_LOOP_TOS: macro 
24bd				call macro_forth_loop_tos 
24bd				endm 
24bd			 
24bd			macro_forth_loop_tos: 
24bd d5				push de 
24be 2a 2b f9			ld hl,(cli_loop_sp) 
24c1 5e				ld e, (hl) 
24c2 23				inc hl 
24c3 56				ld d, (hl) 
24c4 eb				ex de, hl 
24c5 d1				pop de 
24c6 c9				ret 
24c7			 
24c7			; pop loop stack pointer 
24c7				 
24c7			FORTH_LOOP_POP: macro 
24c7				call macro_forth_loop_pop 
24c7				endm 
24c7			 
24c7			 
24c7			macro_forth_loop_pop: 
24c7				if DEBUG_FORTH_STACK_GUARD 
24c7					DMARK "LPP" 
24c7 f5				push af  
24c8 3a dc 24			ld a, (.dmark)  
24cb 32 a6 fd			ld (debug_mark),a  
24ce 3a dd 24			ld a, (.dmark+1)  
24d1 32 a7 fd			ld (debug_mark+1),a  
24d4 3a de 24			ld a, (.dmark+2)  
24d7 32 a8 fd			ld (debug_mark+2),a  
24da 18 03			jr .pastdmark  
24dc ..			.dmark: db "LPP"  
24df f1			.pastdmark: pop af  
24e0			endm  
# End of macro DMARK
24e0 cd 78 74				call check_stacks 
24e3					FORTH_CHK_LOOP_UNDER 
24e3 e5				push hl 
24e4 d5				push de 
24e5 2a 2b f9			ld hl,(cli_loop_sp) 
24e8 11 65 f8			ld de, cli_loop_stack 
24eb cd ed 0f			call cmp16 
24ee da 92 75			jp c, fault_loop_under 
24f1 d1				pop de 
24f2 e1				pop hl 
24f3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
24f3				endif 
24f3 e5				push hl 
24f4 2a 2b f9			ld hl,(cli_loop_sp) 
24f7 2b				dec hl 
24f8 2b				dec hl 
24f9 22 2b f9			ld (cli_loop_sp), hl 
24fc				; TODO do stack underflow checks 
24fc e1				pop hl 
24fd				if DEBUG_FORTH_STACK_GUARD 
24fd cd 78 74				call check_stacks 
2500					FORTH_CHK_LOOP_UNDER 
2500 e5				push hl 
2501 d5				push de 
2502 2a 2b f9			ld hl,(cli_loop_sp) 
2505 11 65 f8			ld de, cli_loop_stack 
2508 cd ed 0f			call cmp16 
250b da 92 75			jp c, fault_loop_under 
250e d1				pop de 
250f e1				pop hl 
2510				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2510				endif 
2510 c9				ret 
2511			 
2511			macro_forth_dsp_pop: 
2511			 
2511 e5				push hl 
2512			 
2512				; release malloc data 
2512			 
2512				if DEBUG_FORTH_STACK_GUARD 
2512 cd 78 74				call check_stacks 
2515					FORTH_CHK_DSP_UNDER 
2515 e5				push hl 
2516 d5				push de 
2517 2a 29 f9			ld hl,(cli_data_sp) 
251a 11 63 f6			ld de, cli_data_stack 
251d cd ed 0f			call cmp16 
2520 da 86 75			jp c, fault_dsp_under 
2523 d1				pop de 
2524 e1				pop hl 
2525				endm 
# End of macro FORTH_CHK_DSP_UNDER
2525				endif 
2525				;ld hl,(cli_data_sp) 
2525			if DEBUG_FORTH_DOT 
2525				DMARK "DPP" 
2525 f5				push af  
2526 3a 3a 25			ld a, (.dmark)  
2529 32 a6 fd			ld (debug_mark),a  
252c 3a 3b 25			ld a, (.dmark+1)  
252f 32 a7 fd			ld (debug_mark+1),a  
2532 3a 3c 25			ld a, (.dmark+2)  
2535 32 a8 fd			ld (debug_mark+2),a  
2538 18 03			jr .pastdmark  
253a ..			.dmark: db "DPP"  
253d f1			.pastdmark: pop af  
253e			endm  
# End of macro DMARK
253e				CALLMONITOR 
253e cd aa fd			call debug_vector  
2541				endm  
# End of macro CALLMONITOR
2541			endif	 
2541			 
2541			 
2541			if FORTH_ENABLE_DSPPOPFREE 
2541			 
2541				FORTH_DSP 
2541 cd 1f 24			call macro_forth_dsp 
2544				endm 
# End of macro FORTH_DSP
2544			 
2544 7e				ld a, (hl) 
2545 fe 01			cp DS_TYPE_STR 
2547 20 23			jr nz, .skippopfree 
2549			 
2549				FORTH_DSP_VALUEHL 
2549 cd 59 24			call macro_dsp_valuehl 
254c				endm 
# End of macro FORTH_DSP_VALUEHL
254c 00				nop 
254d			if DEBUG_FORTH_DOT 
254d				DMARK "DPf" 
254d f5				push af  
254e 3a 62 25			ld a, (.dmark)  
2551 32 a6 fd			ld (debug_mark),a  
2554 3a 63 25			ld a, (.dmark+1)  
2557 32 a7 fd			ld (debug_mark+1),a  
255a 3a 64 25			ld a, (.dmark+2)  
255d 32 a8 fd			ld (debug_mark+2),a  
2560 18 03			jr .pastdmark  
2562 ..			.dmark: db "DPf"  
2565 f1			.pastdmark: pop af  
2566			endm  
# End of macro DMARK
2566				CALLMONITOR 
2566 cd aa fd			call debug_vector  
2569				endm  
# End of macro CALLMONITOR
2569			endif	 
2569 cd cb 16			call free 
256c			.skippopfree: 
256c				 
256c			 
256c			endif 
256c			 
256c			if DEBUG_FORTH_DOT_KEY 
256c				DMARK "DP2" 
256c				CALLMONITOR 
256c			endif	 
256c			 
256c				; move pointer down 
256c			 
256c 2a 29 f9			ld hl,(cli_data_sp) 
256f 2b				dec hl 
2570 2b				dec hl 
2571			; PARSEV5 
2571 2b				dec hl 
2572 22 29 f9			ld (cli_data_sp), hl 
2575			 
2575				if DEBUG_FORTH_STACK_GUARD 
2575 cd 78 74				call check_stacks 
2578					FORTH_CHK_DSP_UNDER 
2578 e5				push hl 
2579 d5				push de 
257a 2a 29 f9			ld hl,(cli_data_sp) 
257d 11 63 f6			ld de, cli_data_stack 
2580 cd ed 0f			call cmp16 
2583 da 86 75			jp c, fault_dsp_under 
2586 d1				pop de 
2587 e1				pop hl 
2588				endm 
# End of macro FORTH_CHK_DSP_UNDER
2588				endif 
2588			 
2588 e1				pop hl 
2589			 
2589 c9				ret 
258a			 
258a			getwordathl: 
258a				; hl points to an address 
258a				; load hl with the word at that address 
258a			 
258a d5				push de 
258b			 
258b 5e				ld e, (hl) 
258c 23				inc hl 
258d 56				ld d, (hl) 
258e eb				ex de, hl 
258f			 
258f d1				pop de 
2590 c9				ret 
2591			 
2591			 
2591			 
2591			 
2591			 
2591			; eof 
2591			 
# End of file forth_stackopsv5.asm
2591			endif 
2591			 
2591			loadwordinhl:	 
2591			 
2591 d5				push de 
2592			 
2592 5e				ld e, (hl) 
2593 23				inc hl 
2594 56				ld d, (hl) 
2595 eb				ex de,hl  
2596			 
2596 d1				pop de 
2597			 
2597 c9				ret 
2598			 
2598			user_word_eol:  
2598				; hl contains the pointer to where to create a linked list item from the end 
2598				; of the user dict to continue on at the system word dict 
2598				 
2598				; poke the stub of the word list linked list to repoint to rom words 
2598			 
2598				; stub format 
2598				; db   word id 
2598				; dw    link to next word 
2598			        ; db char length of token 
2598				; db string + 0 term 
2598				; db exec code....  
2598			 
2598 3e 00			ld a, WORD_SYS_ROOT     ; root word 
259a 77				ld (hl), a		; word id 
259b 23				inc hl 
259c			 
259c 11 67 27			ld de, sysdict 
259f 73				ld (hl), e		; next word link ie system dict 
25a0 23				inc hl 
25a1 72				ld (hl), d		; next word link ie system dict 
25a2 23				inc hl	 
25a3			 
25a3			;	ld (hl), sysdict		; next word link ie system dict 
25a3			;	inc hl 
25a3			;	inc hl 
25a3			 
25a3			;	inc hl 
25a3			;	inc hl 
25a3			 
25a3 3e 02			ld a, 2			; word length is 0 
25a5 77				ld (hl), a	 
25a6 23				inc hl 
25a7			 
25a7 3e 7e			ld a, '~'			; word length is 0 
25a9 77				ld (hl), a	 
25aa 23				inc hl 
25ab 3e 00			ld a, 0			; save empty word 
25ad 77				ld (hl), a 
25ae			 
25ae c9				ret 
25af			 
25af				 
25af			 
25af			forthexec_cleanup: 
25af				FORTH_RSP_POP 
25af cd 2a 22			call macro_forth_rsp_pop 
25b2				endm 
# End of macro FORTH_RSP_POP
25b2 c9				ret 
25b3			 
25b3			forth_call_hl: 
25b3				; taking hl 
25b3 e5				push hl 
25b4 c9				ret 
25b5			 
25b5			; this is called to reset Forth system but keep existing uwords etc 
25b5			 
25b5			forth_warmstart: 
25b5				; setup stack over/under flow checks 
25b5				if DEBUG_FORTH_STACK_GUARD 
25b5 cd 5e 74				call chk_stk_init 
25b8				endif 
25b8			 
25b8				; init stack pointers  - * these stacks go upwards *  
25b8 21 e7 f8			ld hl, cli_ret_stack 
25bb 22 2d f9			ld (cli_ret_sp), hl	 
25be				; set bottom of stack 
25be 3e 00			ld a,0 
25c0 77				ld (hl),a 
25c1 23				inc hl 
25c2 77				ld (hl),a 
25c3			 
25c3 21 63 f6			ld hl, cli_data_stack 
25c6 22 29 f9			ld (cli_data_sp), hl	 
25c9				; set bottom of stack 
25c9 3e 00			ld a,0 
25cb 77				ld (hl),a 
25cc 23				inc hl 
25cd 77				ld (hl),a 
25ce			 
25ce 21 65 f8			ld hl, cli_loop_stack 
25d1 22 2b f9			ld (cli_loop_sp), hl	 
25d4				; set bottom of stack 
25d4 3e 00			ld a,0 
25d6 77				ld (hl),a 
25d7 23				inc hl 
25d8 77				ld (hl),a 
25d9			 
25d9				; init extent of current open file 
25d9			 
25d9 3e 00			ld a, 0 
25db 32 a5 f9			ld (store_openext), a 
25de			 
25de c9				ret 
25df			 
25df			 
25df			 
25df			; Cold Start - this is called to setup the whole Forth system 
25df			 
25df			forth_init: 
25df			 
25df				; setup stack over/under flow checks 
25df			 
25df			;	if DEBUG_FORTH_STACK_GUARD 
25df			;		call chk_stk_init 
25df			;	endif 
25df			 
25df				; enable auto display updates (slow.....) 
25df			 
25df 3e 01			ld a, 1 
25e1 32 77 f9			ld (cli_autodisplay), a 
25e4			 
25e4				; if storage is in use disable long reads for now 
25e4 3e 00			ld a, 0 
25e6 32 b0 f9			ld (store_longread), a 
25e9			 
25e9			 
25e9				; show start up screen 
25e9			 
25e9 cd 9b 0d			call clear_display 
25ec			 
25ec 3e 00			ld a,0 
25ee 32 99 f9			ld (f_cursor_ptr), a 
25f1			 
25f1				; set start of word list in start of ram - for use when creating user words 
25f1			 
25f1 21 00 80			ld hl, baseram 
25f4 22 f9 f3			ld (os_last_new_uword), hl 
25f7 cd 98 25			call user_word_eol 
25fa				 
25fa			;		call display_data_sp 
25fa			;		call next_page_prompt 
25fa			 
25fa			 
25fa			 
25fa			 
25fa c9				ret 
25fb			 
25fb .. 00		.bootforth: db " Forth Kernel Init ",0 
260f			 
260f			; TODO push to stack 
260f			 
260f			;  
260f			 
260f			if FORTH_PARSEV2 
260f			 
260f			 
260f				include "forth_parserv2.asm" 
260f			 
260f			endif 
260f			 
260f			 
260f			; parse cli version 1 
260f			 
260f			if FORTH_PARSEV1 
260f			 
260f			 
260f			 
260f			      include "forth_parserv1.asm" 
260f			endif 
260f				 
260f			if FORTH_PARSEV3 
260f			 
260f			 
260f			 
260f			      include "forth_parserv3.asm" 
260f				include "forth_wordsv3.asm" 
260f			endif 
260f			 
260f			if FORTH_PARSEV4 
260f			 
260f			 
260f			 
260f			      include "forth_parserv4.asm" 
260f				include "forth_wordsv4.asm" 
260f			endif 
260f			 
260f			if FORTH_PARSEV5 
260f			 
260f			 
260f			 
260f			      include "forth_parserv5.asm" 
260f			 
260f			 
260f			; A better parser without using malloc and string copies all over the place.  
260f			; Exec in situ should be faster 
260f			 
260f			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
260f			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
260f			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
260f			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
260f			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
260f			WORD_SYS_END: equ 0   ; Opcode for all user words 
260f			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
260f			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
260f			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
260f			 
260f			; Core word preamble macro 
260f			 
260f			CWHEAD:   macro nxtword opcode lit len opflags 
260f				db WORD_SYS_CORE+opcode             
260f				; internal op code number 
260f				dw nxtword            
260f				; link to next dict word block 
260f				db len + 1 
260f				; literal length of dict word inc zero term 
260f				db lit,0              
260f				; literal dict word 
260f			        ; TODO db opflags        
260f				endm 
260f			 
260f			 
260f			NEXTW: macro  
260f				jp macro_next 
260f				endm 
260f			 
260f			macro_next: 
260f			if DEBUG_FORTH_PARSE_KEY 
260f				DMARK "NXT" 
260f				CALLMONITOR 
260f			endif	 
260f			;	inc hl  ; skip token null term  
260f ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2613 ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2617 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
261a			if DEBUG_FORTH_PARSE_KEY 
261a				DMARK "}AA" 
261a				CALLMONITOR 
261a			endif	 
261a c3 1d 27			jp execnext 
261d				;jp exec1 
261d			       
261d			 
261d			 
261d			; Another go at the parser to compile  
261d			 
261d			 
261d			; TODO rework parser to change all of the string words to byte tokens 
261d			; TODO do a search for  
261d			 
261d			; TODO first run normal parser to zero term sections 
261d			; TODO for each word do a token look up to get the op code 
261d			; TODO need some means to flag to the exec that this is a byte code form    
261d			 
261d			 
261d			forthcompile: 
261d			 
261d			; 
261d			; line parse: 
261d			;       parse raw input buffer 
261d			;       tokenise the words 
261d			;       malloc new copy (for looping etc) 
261d			;       copy to malloc + current pc in line to start of string and add line term 
261d			;       save on new rsp 
261d			; 
261d			 
261d			; hl to point to the line to tokenise 
261d			 
261d			;	push hl 
261d 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
2620			 
2620			;	ld a,0		; string term on input 
2620			;	call strlent 
2620			 
2620			;	ld (os_tok_len), hl	 ; save string length 
2620			 
2620			;if DEBUG_FORTH_TOK 
2620			;	ex de,hl		 
2620			;endif 
2620			 
2620			;	pop hl 		; get back string pointer 
2620			 
2620			if DEBUG_FORTH_TOK 
2620						DMARK "TOc" 
2620				CALLMONITOR 
2620			endif 
2620 7e			.cptoken2:    ld a,(hl) 
2621 23				inc hl 
2622 fe 7f			cp FORTH_END_BUFFER 
2624 28 29			jr z, .cptokendone2 
2626 fe 00			cp 0 
2628 28 25			jr z, .cptokendone2 
262a fe 22			cp '"' 
262c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
262e fe 20			cp ' ' 
2630 20 ee			jr nz,  .cptoken2 
2632			 
2632			; TODO consume comments held between ( and ) 
2632			 
2632				; we have a space so change to zero term for dict match later 
2632 2b				dec hl 
2633 3e 00			ld a,0 
2635 77				ld (hl), a 
2636 23				inc hl 
2637 18 e7			jr .cptoken2 
2639				 
2639			 
2639			.cptokenstr2: 
2639				; skip all white space until either eol (because forgot to term) or end double quote 
2639			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2639				;inc hl ; skip current double quote 
2639 7e				ld a,(hl) 
263a 23				inc hl 
263b fe 22			cp '"' 
263d 28 e1			jr z, .cptoken2 
263f fe 7f			cp FORTH_END_BUFFER 
2641 28 0c			jr z, .cptokendone2 
2643 fe 00			cp 0 
2645 28 08			jr z, .cptokendone2 
2647 fe 20			cp ' ' 
2649 28 02			jr z, .cptmp2 
264b 18 ec			jr .cptokenstr2 
264d			 
264d			.cptmp2:	; we have a space so change to zero term for dict match later 
264d				;dec hl 
264d				;ld a,"-"	; TODO remove this when working 
264d				;ld (hl), a 
264d				;inc hl 
264d 18 ea			jr .cptokenstr2 
264f			 
264f			.cptokendone2: 
264f				;inc hl 
264f 3e 7f			ld a, FORTH_END_BUFFER 
2651 77				ld (hl),a 
2652 23				inc hl 
2653 3e 21			ld a, '!' 
2655 77				ld (hl),a 
2656			 
2656 2a fd f3			ld hl,(os_tok_ptr) 
2659			         
2659			if DEBUG_FORTH_TOK 
2659						DMARK "Tc1" 
2659				CALLMONITOR 
2659			endif 
2659			 
2659				; push exec string to top of return stack 
2659				FORTH_RSP_NEXT 
2659 cd 09 22			call macro_forth_rsp_next 
265c				endm 
# End of macro FORTH_RSP_NEXT
265c c9				ret 
265d			 
265d			; Another go at the parser need to simplify the process 
265d			 
265d			forthparse: 
265d			 
265d			; 
265d			; line parse: 
265d			;       parse raw input buffer 
265d			;       tokenise the words 
265d			;       malloc new copy (for looping etc) 
265d			;       copy to malloc + current pc in line to start of string and add line term 
265d			;       save on new rsp 
265d			; 
265d			 
265d			; hl to point to the line to tokenise 
265d			 
265d			;	push hl 
265d 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
2660			 
2660			;	ld a,0		; string term on input 
2660			;	call strlent 
2660			 
2660			;	ld (os_tok_len), hl	 ; save string length 
2660			 
2660			;if DEBUG_FORTH_TOK 
2660			;	ex de,hl		 
2660			;endif 
2660			 
2660			;	pop hl 		; get back string pointer 
2660			 
2660			if DEBUG_FORTH_TOK 
2660						DMARK "TOK" 
2660				CALLMONITOR 
2660			endif 
2660 7e			.ptoken2:    ld a,(hl) 
2661 23				inc hl 
2662 fe 7f			cp FORTH_END_BUFFER 
2664 28 29			jr z, .ptokendone2 
2666 fe 00			cp 0 
2668 28 25			jr z, .ptokendone2 
266a fe 22			cp '"' 
266c 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
266e fe 20			cp ' ' 
2670 20 ee			jr nz,  .ptoken2 
2672			 
2672			; TODO consume comments held between ( and ) 
2672			 
2672				; we have a space so change to zero term for dict match later 
2672 2b				dec hl 
2673 3e 00			ld a,0 
2675 77				ld (hl), a 
2676 23				inc hl 
2677 18 e7			jr .ptoken2 
2679				 
2679			 
2679			.ptokenstr2: 
2679				; skip all white space until either eol (because forgot to term) or end double quote 
2679			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2679				;inc hl ; skip current double quote 
2679 7e				ld a,(hl) 
267a 23				inc hl 
267b fe 22			cp '"' 
267d 28 e1			jr z, .ptoken2 
267f fe 7f			cp FORTH_END_BUFFER 
2681 28 0c			jr z, .ptokendone2 
2683 fe 00			cp 0 
2685 28 08			jr z, .ptokendone2 
2687 fe 20			cp ' ' 
2689 28 02			jr z, .ptmp2 
268b 18 ec			jr .ptokenstr2 
268d			 
268d			.ptmp2:	; we have a space so change to zero term for dict match later 
268d				;dec hl 
268d				;ld a,"-"	; TODO remove this when working 
268d				;ld (hl), a 
268d				;inc hl 
268d 18 ea			jr .ptokenstr2 
268f			 
268f			.ptokendone2: 
268f				;inc hl 
268f 3e 7f			ld a, FORTH_END_BUFFER 
2691 77				ld (hl),a 
2692 23				inc hl 
2693 3e 21			ld a, '!' 
2695 77				ld (hl),a 
2696			 
2696 2a fd f3			ld hl,(os_tok_ptr) 
2699			         
2699			if DEBUG_FORTH_TOK 
2699						DMARK "TK1" 
2699				CALLMONITOR 
2699			endif 
2699			 
2699				; push exec string to top of return stack 
2699				FORTH_RSP_NEXT 
2699 cd 09 22			call macro_forth_rsp_next 
269c				endm 
# End of macro FORTH_RSP_NEXT
269c c9				ret 
269d			 
269d			; 
269d			;	; malloc size + buffer pointer + if is loop flag 
269d			;	ld hl,(os_tok_len) 		 ; get string length 
269d			; 
269d			;	ld a,l 
269d			; 
269d			;	cp 0			; we dont want to use a null string 
269d			;	ret z 
269d			; 
269d			;;	add 3    ; prefix malloc with buffer for current word ptr 
269d			; 
269d			;	add 5     ; TODO when certain not over writing memory remove 
269d			; 
269d			;		 
269d			; 
269d			;if DEBUG_FORTH_TOK 
269d			;			DMARK "TKE" 
269d			;	CALLMONITOR 
269d			;endif 
269d			; 
269d			;	ld l,a 
269d			;	ld h,0 
269d			;;	push hl   ; save required space for the copy later 
269d			;	call malloc 
269d			;if DEBUG_FORTH_TOK 
269d			;			DMARK "TKM" 
269d			;	CALLMONITOR 
269d			;endif 
269d			;	if DEBUG_FORTH_MALLOC_GUARD 
269d			;		push af 
269d			;		call ishlzero 
269d			;;		ld a, l 
269d			;;		add h 
269d			;;		cp 0 
269d			;		pop af 
269d			;		 
269d			;		call z,malloc_error 
269d			;	endif 
269d			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
269d			; 
269d			; 
269d			;if DEBUG_FORTH_TOK 
269d			;			DMARK "TKR" 
269d			;	CALLMONITOR 
269d			;endif 
269d			; 
269d			;	FORTH_RSP_NEXT 
269d			; 
269d			;	;inc hl	 ; go past current buffer pointer 
269d			;	;inc hl 
269d			;	;inc hl   ; and past if loop flag 
269d			;		; TODO Need to set flag  
269d			; 
269d			;	 
269d			;	 
269d			;	ex de,hl	; malloc is dest 
269d			;	ld hl, (os_tok_len) 
269d			;;	pop bc 
269d			;	ld c, l                
269d			;	ld b,0 
269d			;	ld hl, (os_tok_ptr) 
269d			; 
269d			;if DEBUG_FORTH_TOK 
269d			;			DMARK "TKT" 
269d			;	CALLMONITOR 
269d			;endif 
269d			; 
269d			;	; do str cpy 
269d			; 
269d			;	ldir      ; copy byte in hl to de 
269d			; 
269d			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
269d			; 
269d			;if DEBUG_FORTH_TOK 
269d			; 
269d			;			DMARK "TKY" 
269d			;	CALLMONITOR 
269d			;endif 
269d			;	;ld a,0 
269d			;	;ld a,FORTH_END_BUFFER 
269d			;	ex de, hl 
269d			;	;dec hl			 ; go back over the space delim at the end of word 
269d			;	;ld (hl),a 
269d			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
269d			;	ld a,FORTH_END_BUFFER 
269d			;	ld (hl),a 
269d			;	inc hl 
269d			;	ld a,FORTH_END_BUFFER 
269d			;	ld (hl),a 
269d			; 
269d			;	; init the malloc area data 
269d			;	; set pc for in current area 
269d			;	;ld hl, (os_tok_malloc) 
269d			;	;inc hl 
269d			;	;inc hl 
269d			;	;inc hl 
269d			;	;ex de,hl 
269d			;	;ld hl, (os_tok_malloc) 
269d			;	;ld (hl),e 
269d			;	;inc hl 
269d			;	;ld (hl),d 
269d			; 
269d			; 
269d			;	ld hl,(os_tok_malloc) 
269d			;if DEBUG_FORTH_PARSE_KEY 
269d			;			DMARK "TKU" 
269d			;	CALLMONITOR 
269d			;endif 
269d			; 
269d			;	ret 
269d			 
269d			forthexec: 
269d			 
269d			; line exec: 
269d			; forth parser 
269d			 
269d			; 
269d			;       get current exec line on rsp 
269d			 
269d				FORTH_RSP_TOS 
269d cd 20 22			call macro_forth_rsp_tos 
26a0				endm 
# End of macro FORTH_RSP_TOS
26a0			 
26a0			;       restore current pc - hl points to malloc of data 
26a0			 
26a0				;ld e, (hl) 
26a0				;inc hl 
26a0				;ld d, (hl) 
26a0				;ex de,hl 
26a0			 
26a0			 
26a0			exec1: 
26a0 22 fd f3			ld (os_tok_ptr), hl 
26a3			 
26a3				; copy our PC to working vars  
26a3 22 7b f9			ld (cli_ptr), hl 
26a6 22 79 f9			ld (cli_origptr), hl 
26a9			 
26a9 7e				ld a,(hl) 
26aa fe 7f			cp FORTH_END_BUFFER 
26ac c8				ret z 
26ad			 
26ad				; skip any nulls 
26ad			 
26ad fe 00			cp 0 
26af 20 03			jr nz, .execword 
26b1 23				inc hl 
26b2 18 ec			jr exec1 
26b4			 
26b4			 
26b4			.execword: 
26b4			 
26b4			 
26b4			 
26b4			if DEBUG_FORTH_PARSE_KEY 
26b4						DMARK "KYQ" 
26b4				CALLMONITOR 
26b4			endif 
26b4			;       while at start of word: 
26b4			; get start of dict (in user area first) 
26b4			 
26b4 21 00 80		ld hl, baseram 
26b7			;ld hl, sysdict 
26b7 22 7d f9		ld (cli_nextword),hl 
26ba			;           match word at pc 
26ba			;           exec word 
26ba			;           or push to dsp 
26ba			;           forward to next token 
26ba			;           if line term pop rsp and exit 
26ba			;        
26ba			 
26ba			if DEBUG_FORTH_PARSE_KEY 
26ba						DMARK "KYq" 
26ba				CALLMONITOR 
26ba			endif 
26ba			 
26ba			; 
26ba			; word comp 
26ba			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
26ba			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
26ba			;    move to start of word  
26ba			;    compare word to cli_token 
26ba			 
26ba			.execpnword:	; HL at start of a word in the dictionary to check 
26ba			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
26ba			;	ld (cli_ptr), hl 
26ba			 
26ba 2a 7d f9			ld hl,(cli_nextword) 
26bd			 
26bd cd 60 27			call forth_tok_next 
26c0			; tok next start here 
26c0			;	; TODO skip compiled symbol for now 
26c0			;	inc hl 
26c0			; 
26c0			;	; save pointer to next word 
26c0			; 
26c0			;	; hl now points to the address of the next word pointer  
26c0			;	ld e, (hl) 
26c0			;	inc hl 
26c0			;	ld d, (hl) 
26c0			;	inc l 
26c0			; 
26c0			;	ex de,hl 
26c0			;if DEBUG_FORTH_PARSE_NEXTWORD 
26c0			;	push bc 
26c0			;	ld bc, (cli_nextword) 
26c0			;			DMARK "NXW" 
26c0			;	CALLMONITOR 
26c0			;	pop bc 
26c0			;endif 
26c0			; tok next end here 
26c0 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
26c3 eb				ex de, hl 
26c4			 
26c4			 
26c4				; save the pointer of the current token - 1 to check against 
26c4				 
26c4 22 81 f9			ld (cli_token), hl   
26c7				; TODO maybe remove below save if no debug 
26c7				; save token string ptr for any debug later 
26c7 23				inc hl  
26c8 22 83 f9			ld (cli_origtoken), hl 
26cb 2b				dec hl 
26cc				; save pointer to the start of the next dictionay word 
26cc 7e				ld a,(hl)   ; get string length 
26cd 47				ld b,a 
26ce			.execpnwordinc:  
26ce 23				inc hl 
26cf 10 fd			djnz .execpnwordinc 
26d1 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
26d4			 
26d4				; now check the word token against the string being parsed 
26d4			 
26d4 2a 81 f9			ld hl,(cli_token) 
26d7 23				inc hl     ; skip string length (use zero term instead to end) 
26d8 22 81 f9			ld (cli_token), hl 
26db			 
26db			if DEBUG_FORTH_PARSE_KEY 
26db						DMARK "KY2" 
26db			endif 
26db			if DEBUG_FORTH_PARSE_EXEC 
26db				; see if disabled 
26db			 
26db			;	ld a, (os_view_disable) 
26db			;	cp '*' 
26db				ld a, (debug_vector) 
26db				cp $c9   ; RET  
26db				jr z, .skip 
26db			 
26db				push hl 
26db				push hl 
26db				call clear_display 
26db				ld de, .compword 
26db				ld a, display_row_1 
26db				call str_at_display 
26db				pop de 
26db				ld a, display_row_2 
26db				call str_at_display 
26db				ld hl,(cli_ptr) 
26db				ld a,(hl) 
26db			        ld hl, os_word_scratch 
26db				ld (hl),a 
26db				ld a,0 
26db				inc hl 
26db				ld (hl),a 	 
26db				ld de, os_word_scratch 
26db				ld a, display_row_2+10 
26db				call str_at_display 
26db				call update_display 
26db				ld a, 100 
26db				call aDelayInMS 
26db				if DEBUG_FORTH_PARSE_EXEC_SLOW 
26db				call delay250ms 
26db				endif 
26db				pop hl 
26db			.skip:  
26db			endif	 
26db			.execpnchar:    ; compare char between token and string to parse 
26db			 
26db			if DEBUG_FORTH_PARSE_KEY 
26db						DMARK "Ky3" 
26db			endif 
26db			if DEBUG_FORTH_PARSE_EXEC 
26db				; see if disabled 
26db			 
26db			;	ld a, (os_view_disable) 
26db			;	cp '*' 
26db				ld a, (debug_vector) 
26db				cp $C9  ; RET 
26db				jr z, .skip2 
26db			 
26db			;	call clear_display 
26db			ld hl,(cli_token) 
26db			ld a,(hl) 
26db			ld (os_word_scratch),a 
26db				ld hl,(cli_ptr) 
26db			ld a,(hl) 
26db				ld (os_word_scratch+1),a 
26db				ld a,0 
26db				ld (os_word_scratch+2),a 
26db				ld de,os_word_scratch 
26db				ld a,display_row_4 
26db				call str_at_display 
26db				call update_display 
26db			.skip2:  
26db			endif 
26db 2a 81 f9			ld hl,(cli_token) 
26de 7e				ld a, (hl)	 ; char in word token 
26df 23				inc hl 		; move to next char 
26e0 22 81 f9			ld (cli_token), hl ; and save it 
26e3 47				ld b,a 
26e4			 
26e4 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
26e7 7e				ld a,(hl) 
26e8 23				inc hl 
26e9 22 7b f9			ld (cli_ptr), hl		; move to next char 
26ec cd 83 15			call toUpper 		; make sure the input string matches case 
26ef			 
26ef			if DEBUG_FORTH_PARSE 
26ef			endif 
26ef			 
26ef				; input stream end of token is a space so get rid of it 
26ef			 
26ef			;	cp ' ' 
26ef			;	jr nz, .pnskipspace 
26ef			; 
26ef			;	ld a, 0		; make same term as word token term 
26ef			; 
26ef			;.pnskipspace: 
26ef			 
26ef			if DEBUG_FORTH_PARSE_KEY 
26ef						DMARK "KY7" 
26ef			endif 
26ef b8				cp b 
26f0 c2 06 27			jp nz, .execpnskipword	 ; no match so move to next word 
26f3				 
26f3			;    if same 
26f3			;       scan for string terms 0 for token and 32 for input 
26f3			 
26f3				 
26f3			if DEBUG_FORTH_PARSE_KEY 
26f3						DMARK "KY8" 
26f3			endif 
26f3			 
26f3 80				add b			 
26f4 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
26f6							; TODO need to make sure last word in zero term string is accounted for 
26f6 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
26f8			 
26f8			 
26f8				; at end of both strings so both are exact match 
26f8			 
26f8			;       skip ptr for next word 
26f8			 
26f8 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
26fb 23				inc hl			 ; at next char 
26fc 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
26ff 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2702				 
2702				 
2702			if DEBUG_FORTH_PARSE_KEY 
2702						DMARK "KY3" 
2702			endif 
2702			 
2702			 
2702			 
2702			;       exec code block 
2702			if DEBUG_FORTH_JP 
2702				call clear_display 
2702				call update_display 
2702				call delay1s 
2702				ld hl, (cli_execword)     ; save for next check if no match on this word 
2702				ld a,h 
2702				ld hl, os_word_scratch 
2702				call hexout 
2702				ld hl, (cli_execword)     ; save for next check if no match on this word 
2702				ld a,l 
2702				ld hl, os_word_scratch+2 
2702				call hexout 
2702				ld hl, os_word_scratch+4 
2702				ld a,0 
2702				ld (hl),a 
2702				ld de,os_word_scratch 
2702				call str_at_display 
2702					ld a, display_row_2 
2702					call str_at_display 
2702				ld de, (cli_origtoken) 
2702				ld a, display_row_1+10 
2702					call str_at_display 
2702			 
2702				ld a,display_row_1 
2702				ld de, .foundword 
2702				ld a, display_row_3 
2702				call str_at_display 
2702				call update_display 
2702				call delay1s 
2702				call delay1s 
2702				call delay1s 
2702			endif 
2702			 
2702			if DEBUG_FORTH_PARSE_KEY 
2702						DMARK "KYj" 
2702			endif 
2702				; TODO save the word pointer in this exec 
2702			 
2702 2a 7f f9			ld hl,(cli_execword) 
2705 e9				jp (hl) 
2706			 
2706			 
2706			;    if not same 
2706			;	scan for zero term 
2706			;	get ptr for next word 
2706			;	goto word comp 
2706			 
2706			.execpnskipword:	; get pointer to next word 
2706 2a 7d f9			ld hl,(cli_nextword) 
2709			 
2709 7e				ld a,(hl) 
270a fe 00			cp WORD_SYS_END 
270c			;	cp 0 
270c 28 09			jr z, .execendofdict			 ; at end of words 
270e			 
270e			if DEBUG_FORTH_PARSE_KEY 
270e						DMARK "KY4" 
270e			endif 
270e			if DEBUG_FORTH_PARSE_EXEC 
270e			 
270e				; see if disabled 
270e			 
270e			;	ld a, (os_view_disable) 
270e			;	cp '*' 
270e				ld a,(debug_vector) 
270e				cp $c9   ; RET 
270e				jr z, .noskip 
270e			 
270e			 
270e				ld de, .nowordfound 
270e				ld a, display_row_3 
270e				call str_at_display 
270e				call update_display 
270e				ld a, 100 
270e				call aDelayInMS 
270e				 
270e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
270e					call delay250ms 
270e				endif 
270e			.noskip:  
270e			 
270e			endif	 
270e			 
270e 2a 79 f9			ld hl,(cli_origptr) 
2711 22 7b f9			ld (cli_ptr),hl 
2714			 
2714			if DEBUG_FORTH_PARSE_KEY 
2714						DMARK "KY5" 
2714			endif 
2714 c3 ba 26			jp .execpnword			; else go to next word 
2717			 
2717			.execendofdict:  
2717			 
2717			if DEBUG_FORTH_PARSE_KEY 
2717						DMARK "KYe" 
2717			endif 
2717			if DEBUG_FORTH_PARSE_EXEC 
2717				; see if disabled 
2717			 
2717			;	ld a, (os_view_disable) 
2717			;	cp '*' 
2717				ld a,(debug_vector) 
2717				cp $c9   ; ret 
2717				jr z, .ispskip 
2717			 
2717				call clear_display 
2717				call update_display 
2717				call delay1s 
2717				ld de, (cli_origptr) 
2717				ld a, display_row_1 
2717				call str_at_display 
2717				 
2717				ld de, .enddict 
2717				ld a, display_row_3 
2717				call str_at_display 
2717				call update_display 
2717				ld a, 100 
2717				call aDelayInMS 
2717				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2717				call delay1s 
2717				call delay1s 
2717				call delay1s 
2717				endif 
2717			.ispskip:  
2717				 
2717			endif	 
2717			 
2717			 
2717			 
2717				; if the word is not a keyword then must be a literal so push it to stack 
2717			 
2717			; push token to stack to end of word 
2717			 
2717				STACKFRAME ON $1efe $2f9f 
2717				if DEBUG_STACK_IMB 
2717					if ON 
2717						exx 
2717						ld de, $1efe 
2717						ld a, d 
2717						ld hl, curframe 
2717						call hexout 
2717						ld a, e 
2717						ld hl, curframe+2 
2717						call hexout 
2717						ld hl, $1efe 
2717						push hl 
2717						ld hl, $2f9f 
2717						push hl 
2717						exx 
2717					endif 
2717				endif 
2717			endm 
# End of macro STACKFRAME
2717			 
2717 2a fd f3		ld hl,(os_tok_ptr) 
271a cd cb 23		call forth_apush 
271d			 
271d				STACKFRAMECHK ON $1efe $2f9f 
271d				if DEBUG_STACK_IMB 
271d					if ON 
271d						exx 
271d						ld hl, $2f9f 
271d						pop de   ; $2f9f 
271d						call cmp16 
271d						jr nz, .spnosame 
271d						ld hl, $1efe 
271d						pop de   ; $1efe 
271d						call cmp16 
271d						jr z, .spfrsame 
271d						.spnosame: call showsperror 
271d						.spfrsame: nop 
271d						exx 
271d					endif 
271d				endif 
271d			endm 
# End of macro STACKFRAMECHK
271d			 
271d			execnext: 
271d			 
271d			if DEBUG_FORTH_PARSE_KEY 
271d						DMARK "KY>" 
271d			endif 
271d			; move past token to next word 
271d			 
271d 2a fd f3		ld hl, (os_tok_ptr) 
2720 3e 00		ld a, 0 
2722 01 ff 00		ld bc, 255     ; input buffer size 
2725 ed b1		cpir 
2727			 
2727			if DEBUG_FORTH_PARSE_KEY 
2727						DMARK "KY!" 
2727				CALLMONITOR 
2727			endif	 
2727			; TODO this might place hl on the null, so will need to forward on??? 
2727			;inc hl   ; see if this gets onto the next item 
2727			 
2727			 
2727			; TODO pass a pointer to the buffer to push 
2727			; TODO call function to push 
2727			 
2727			; look for end of input 
2727			 
2727			;inc hl 
2727			;ld a,(hl) 
2727			;cp FORTH_END_BUFFER 
2727			;ret z 
2727			 
2727			 
2727 c3 a0 26		jp exec1 
272a			 
272a			 
272a			 
272a			 
272a			 
272a			 
272a			 
272a			 
272a			 
272a			findnexttok: 
272a			 
272a				; hl is pointer to move 
272a				; de is the token to locate 
272a			 
272a					if DEBUG_FORTH 
272a						DMARK "NTK" 
272a						CALLMONITOR 
272a					endif 
272a d5				push de 
272b			 
272b			.fnt1:	 
272b				; find first char of token to locate 
272b			 
272b 1a				ld a, (de) 
272c 4f				ld c,a 
272d 7e				ld a,(hl) 
272e cd 83 15			call toUpper 
2731					if DEBUG_FORTH 
2731						DMARK "NT1" 
2731						CALLMONITOR 
2731					endif 
2731 b9				cp c 
2732			 
2732 28 03			jr z, .fnt2cmpmorefirst	 
2734			 
2734				; first char not found move to next char 
2734			 
2734 23				inc hl 
2735 18 f4			jr .fnt1 
2737			 
2737			.fnt2cmpmorefirst:	 
2737				; first char of token found.  
2737			 
2737 e5				push hl     ; save start of token just in case it is the right one 
2738 d9				exx 
2739 e1				pop hl        ; save it to hl' 
273a d9				exx 
273b			 
273b			 
273b			.fnt2cmpmore:	 
273b				; compare the rest 
273b				 
273b 23				inc hl 
273c 13				inc de 
273d				 
273d 1a				ld a, (de) 
273e 4f				ld c,a 
273f 7e				ld a,(hl) 
2740 cd 83 15			call toUpper 
2743			 
2743					if DEBUG_FORTH 
2743						DMARK "NT2" 
2743						CALLMONITOR 
2743					endif 
2743				; c has the token to find char 
2743				; a has the mem to scan char 
2743			 
2743 b9				cp c 
2744 28 04			jr z,.fntmatch1 
2746			 
2746				; they are not the same 
2746			 
2746					if DEBUG_FORTH 
2746						DMARK "NT3" 
2746						CALLMONITOR 
2746					endif 
2746 d1				pop de	; reset de token to look for 
2747 d5				push de 
2748 18 e1			jr .fnt1 
274a				 
274a			.fntmatch1: 
274a			 
274a				; is the same char a null which means we might have a full hit? 
274a					if DEBUG_FORTH 
274a						DMARK "NT4" 
274a						CALLMONITOR 
274a					endif 
274a			 
274a fe 00			cp 0 
274c 28 0b			jr z, .fntmatchyes 
274e			 
274e				; are we at the end of the token to find? 
274e			 
274e					if DEBUG_FORTH 
274e						DMARK "NT5" 
274e						CALLMONITOR 
274e					endif 
274e 3e 00			ld a, 0 
2750 b9				cp c 
2751			 
2751 c2 3b 27			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2754			 
2754					if DEBUG_FORTH 
2754						DMARK "NT6" 
2754						CALLMONITOR 
2754					endif 
2754				; token to find is exhusted but no match to stream 
2754			 
2754				; restore tok pointer and continue on 
2754 d1				pop de 
2755 d5				push de 
2756 c3 2b 27			jp .fnt1 
2759			 
2759			 
2759			.fntmatchyes: 
2759			 
2759				; hl now contains the end of the found token 
2759			 
2759				; get rid of saved token pointer to find 
2759			 
2759 d1				pop de 
275a			 
275a					if DEBUG_FORTH 
275a						DMARK "NT9" 
275a						CALLMONITOR 
275a					endif 
275a			 
275a				; hl will be on the null term so forward on 
275a			 
275a				; get back the saved start of the token 
275a			 
275a d9				exx 
275b e5				push hl     ; save start of token just in case it is the right one 
275c d9				exx 
275d e1				pop hl        ; save it to hl 
275e			 
275e c9				ret 
275f			 
275f			 
275f			; LIST needs to find a specific token   
275f			; FORGET needs to find a spefici token 
275f			 
275f			; SAVE needs to find all tokens by flag 
275f			; WORDS just needs to scan through all  by flag 
275f			; UWORDS needs to scan through all by flag 
275f			 
275f			 
275f			; given hl as pointer to start of dict look up string 
275f			; return hl as pointer to start of word block 
275f			; or 0 if not found 
275f			 
275f			forth_find_tok: 
275f c9				ret 
2760			 
2760			; given hl as pointer to dict structure 
2760			; move to the next dict block structure 
2760			 
2760			forth_tok_next: 
2760				; hl now points to the address of the next word pointer  
2760				; TODO skip compiled symbol for now 
2760			;	push de 
2760 23				inc hl 
2761 5e				ld e, (hl) 
2762 23				inc hl 
2763 56				ld d, (hl) 
2764 23				inc hl 
2765			 
2765 eb				ex de,hl 
2766			if DEBUG_FORTH_PARSE_NEXTWORD 
2766				push bc 
2766				ld bc, (cli_nextword) 
2766						DMARK "NXW" 
2766				CALLMONITOR 
2766				pop bc 
2766			endif 
2766			;	pop de	 
2766 c9				ret 
2767			 
2767			 
2767			 
2767			; eof 
# End of file forth_parserv5.asm
2767				include "forth_wordsv4.asm" 
2767			 
2767			; the core word dictionary v4 
2767			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2767			 
2767			; this is a linked list for each of the system words used 
2767			; user defined words will follow the same format but will be in ram 
2767			 
2767			 
2767			; 
2767			; 
2767			; define linked list: 
2767			; 
2767			; 1. compiled byte op code 
2767			; 2. len of text word 
2767			; 3. text word 
2767			; 4. ptr to next dictionary word 
2767			; 5. asm, calls etc for the word 
2767			; 
2767			;  if 1 == 0 then last word in dict  
2767			;   
2767			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2767			;  
2767			;  
2767			; create basic standard set of words 
2767			; 
2767			;  
2767			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2767			; 2DUP 2DROP 2SWAP  
2767			; @ C@ - get byte  
2767			; ! C! - store byte 
2767			; 0< true if less than zero 
2767			; 0= true if zero 
2767			; < >  
2767			; = true if same 
2767			; variables 
2767			 
2767			 
2767			; Hardware specific words I may need 
2767			; 
2767			; IN OUT  
2767			; calls to key util functions 
2767			; calls to hardward abstraction stuff 
2767			; easy control of frame buffers and lcd i/o 
2767			; keyboard  
2767			 
2767			 
2767			;DICT: macro 
2767			; op_code, len, word, next 
2767			;    word: 
2767			;    db op_code 
2767			;    ds word zero term 
2767			;    dw next 
2767			;    endm 
2767			 
2767			 
2767			 
2767			 
2767			; op code 1 is a flag for user define words which are to be handled differently 
2767			 
2767			 
2767			; 
2767			; 
2767			;    TODO on entry to a word this should be the expected environment 
2767			;    hl - tos value if number then held, if string this is the ptr 
2767			;    de -  
2767			 
2767			 
2767			; opcode ranges 
2767			; 0 - end of word dict 
2767			; 255 - user define words 
2767			 
2767			sysdict: 
2767			include "forth_opcodes.asm" 
2767			; op codes for forth keywords 
2767			; free to use code 0  
2767				OPCODE_HEAP: equ  1 
2767				OPCODE_EXEC: equ 2 
2767				OPCODE_DUP: equ 3 
2767				OPCODE_SWAP: equ 4 
2767				OPCODE_COLN: equ 5 
2767				OPCODE_SCOLN: equ 6 
2767				OPCODE_DROP: equ 7 
2767				OPCODE_DUP2: equ 8 
2767				OPCODE_DROP2: equ 9 
2767				OPCODE_SWAP2: equ 10 
2767				OPCODE_AT: equ 11 
2767				OPCODE_CAT: equ 12 
2767				OPCODE_BANG: equ 13 
2767				OPCODE_CBANG: equ 14 
2767				OPCODE_SCALL: equ 15 
2767				OPCODE_DEPTH: equ 16 
2767				OPCODE_OVER: equ 17 
2767				OPCODE_PAUSE: equ 18 
2767				OPCODE_PAUSES: equ 19 
2767				OPCODE_ROT: equ 20 
2767			;free to reuse	OPCODE_WORDS: equ 21 
2767			        OPCODE_NOT: equ 21 
2767				OPCODE_UWORDS: equ 22 
2767				OPCODE_BP: equ 23 
2767				OPCODE_MONITOR: equ 24  
2767				OPCODE_MALLOC: equ 25 
2767				OPCODE_FREE: equ 26 
2767				OPCODE_LIST: equ 27 
2767				OPCODE_FORGET: equ 28 
2767				OPCODE_NOP: equ 29 
2767				OPCODE_COMO: equ 30 
2767				OPCODE_COMC: equ 31 
2767			;free to reuse	OPCODE_ENDCORE: equ 32 
2767				OPCODE_AFTERSOUND: equ 33 
2767				OPCODE_GP2: equ 34 
2767				OPCODE_GP3: equ 35 
2767				OPCODE_GP4: equ 36 
2767				OPCODE_SIN: equ 37 
2767				OPCODE_SOUT: equ 38 
2767				OPCODE_SPIO: equ 39 
2767				OPCODE_SPICEH: equ 40 
2767				OPCODE_SPIOb: equ 41 
2767				OPCODE_SPII: equ 42 
2767				OPCODE_SESEL: equ 43 
2767				OPCODE_CARTDEV: equ 44 
2767			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2767				OPCODE_FB: equ 46 
2767				OPCODE_EMIT: equ 47 
2767				OPCODE_DOTH: equ 48 
2767				OPCODE_DOTF: equ 49 
2767				OPCODE_DOT: equ 50 
2767				OPCODE_CLS: equ 51 
2767				OPCODE_DRAW: equ 52 
2767				OPCODE_DUMP: equ 53 
2767				OPCODE_CDUMP: equ 54 
2767				OPCODE_DAT: equ 55 
2767				OPCODE_HOME: equ 56 
2767				OPCODE_SPACE: equ 57 
2767				OPCODE_SPACES: equ 58 
2767				OPCODE_SCROLL: equ 59 
2767				OPCODE_ATQ: equ 60 
2767				OPCODE_AUTODSP: equ 61 
2767				OPCODE_MENU: equ 62 
2767			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2767				OPCODE_THEN: equ 64 
2767				OPCODE_ELSE: equ 65 
2767				OPCODE_DO: equ 66 
2767				OPCODE_LOOP: equ 67 
2767				OPCODE_I: equ 68 
2767				OPCODE_DLOOP: equ 69  
2767				OPCODE_REPEAT: equ 70  
2767				OPCODE_UNTIL: equ 71 
2767				OPCODE_ENDFLOW: equ 72 
2767				OPCODE_WAITK: equ 73 
2767				OPCODE_ACCEPT: equ 74 
2767				OPCODE_EDIT: equ 75 
2767			;free to reuse	OPCODE_ENDKEY: equ 76 
2767				OPCODE_LZERO: equ 77 
2767				OPCODE_TZERO: equ 78 
2767				OPCODE_LESS: equ 79 
2767				OPCODE_GT: equ 80 
2767				OPCODE_EQUAL: equ 81  
2767			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2767				OPCODE_NEG: equ 83 
2767				OPCODE_DIV: equ 84 
2767				OPCODE_MUL: equ 85 
2767				OPCODE_MIN: equ 86 
2767				OPCODE_MAX: equ 87 
2767				OPCODE_RND16: equ 88 
2767				OPCODE_RND8: equ 89 
2767				OPCODE_RND: equ 90 
2767			;free to reuse	OPCODE_ENDMATHS: equ 91  
2767				OPCODE_BYNAME: equ 92 
2767				OPCODE_DIR: equ 93 
2767				OPCODE_SAVE: equ 94 
2767				OPCODE_LOAD: equ 95 
2767				OPCODE_BSAVE: equ 96 
2767				OPCODE_BLOAD: equ 97 
2767				OPCODE_SEO: equ 98  
2767				OPCODE_SEI: equ 99 
2767				OPCODE_SFREE: equ 100 
2767				OPCODE_SIZE: equ 101 
2767				OPCODE_CREATE: equ 102 
2767				OPCODE_APPEND: equ 103 
2767				OPCODE_SDEL: equ 104 
2767				OPCODE_OPEN: equ 105 
2767				OPCODE_READ: equ 106 
2767				OPCODE_EOF: equ 106 
2767				OPCODE_FORMAT: equ 107 
2767				OPCODE_LABEL: equ 108 
2767				OPCODE_LABELS: equ 109 
2767			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2767				OPCODE_UPPER: equ 111 
2767				OPCODE_LOWER: equ 112 
2767				OPCODE_SUBSTR: equ 113 
2767				OPCODE_LEFT: equ 114 
2767				OPCODE_RIGHT: equ 115 
2767				OPCODE_STR2NUM: equ 116 
2767				OPCODE_NUM2STR: equ 117 
2767				OPCODE_CONCAT: equ 118 
2767				OPCODE_FIND: equ 119 
2767				OPCODE_LEN: equ 120 
2767				OPCODE_CHAR: equ 121 
2767			; free to reuse	OPCODE_STRLEN: equ 122 
2767			; free to reuse	OPCODE_ENDSTR: equ 123 
2767				OPCODE_V0S: equ 124 
2767				OPCODE_V0Q: equ 125 
2767				OPCODE_V1S: equ 126 
2767				OPCODE_V1Q: equ 127 
2767				OPCODE_V2S: equ 128 
2767				OPCODE_V2Q: equ 129 
2767				OPCODE_V3S: equ 130 
2767				OPCODE_V3Q: equ 131 
2767			;free to reuse	OPCODE_END: equ 132 
2767				OPCODE_ZDUP: equ 133 
2767			 
2767			; eof 
# End of file forth_opcodes.asm
2767			 
2767			include "forth_words_core.asm" 
2767			 
2767			; | ## Core Words 
2767			 
2767			;if MALLOC_4 
2767			 
2767			.HEAP: 
2767			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2767 15				db WORD_SYS_CORE+OPCODE_HEAP             
2768 a6 27			dw .EXEC            
276a 05				db 4 + 1 
276b .. 00			db "HEAP",0              
2770				endm 
# End of macro CWHEAD
2770			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2770			; | | u1 - Current number of bytes in the heap 
2770			; | | u2 - Remaining bytes left on the heap 
2770			; | |  
2770			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2770			 
2770			 
2770				if DEBUG_FORTH_WORDS_KEY 
2770					DMARK "HEP" 
2770 f5				push af  
2771 3a 85 27			ld a, (.dmark)  
2774 32 a6 fd			ld (debug_mark),a  
2777 3a 86 27			ld a, (.dmark+1)  
277a 32 a7 fd			ld (debug_mark+1),a  
277d 3a 87 27			ld a, (.dmark+2)  
2780 32 a8 fd			ld (debug_mark+2),a  
2783 18 03			jr .pastdmark  
2785 ..			.dmark: db "HEP"  
2788 f1			.pastdmark: pop af  
2789			endm  
# End of macro DMARK
2789					CALLMONITOR 
2789 cd aa fd			call debug_vector  
278c				endm  
# End of macro CALLMONITOR
278c				endif 
278c 2a 0a 80			ld hl, (free_list )      
278f 11 0e 80			ld de, heap_start 
2792			 
2792 ed 52			sbc hl, de  
2794			 
2794 cd 62 22			call forth_push_numhl 
2797			 
2797			 
2797 ed 5b 0a 80		ld de, (free_list )      
279b 21 d7 f0			ld hl, heap_end 
279e			 
279e ed 52			sbc hl, de 
27a0			 
27a0 cd 62 22			call forth_push_numhl 
27a3				 
27a3			 
27a3				 
27a3			 
27a3			 
27a3			 
27a3				NEXTW 
27a3 c3 0f 26			jp macro_next 
27a6				endm 
# End of macro NEXTW
27a6			;endif 
27a6			 
27a6			.EXEC: 
27a6			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
27a6			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
27a6			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
27a6			;; > > 
27a6			;; > >   
27a6			;	STACKFRAME OFF $5efe $5f9f 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS_KEY 
27a6			;			DMARK "EXE" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			; 
27a6			;	FORTH_DSP_VALUEHL 
27a6			; 
27a6			;	FORTH_DSP_POP 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX1" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;;	ld e,(hl) 
27a6			;;	inc hl 
27a6			;;	ld d,(hl) 
27a6			;;	ex de,hl 
27a6			; 
27a6			;;		if DEBUG_FORTH_WORDS 
27a6			;;			DMARK "EX2" 
27a6			;;			CALLMONITOR 
27a6			;;		endif 
27a6			;	push hl 
27a6			; 
27a6			;	;ld a, 0 
27a6			;	;ld a, FORTH_END_BUFFER 
27a6			;	call strlenz 
27a6			;	inc hl   ; include zero term to copy 
27a6			;	inc hl   ; include term 
27a6			;	inc hl   ; include term 
27a6			;	ld b,0 
27a6			;	ld c,l 
27a6			;	pop hl 
27a6			;	ld de, execscratch 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX3" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	ldir 
27a6			; 
27a6			; 
27a6			;	ld hl, execscratch 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EXe" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			; 
27a6			;	call forthparse 
27a6			;	call forthexec 
27a6			;;	call forthexec_cleanup 
27a6			;;	call forthparse 
27a6			;;	call forthexec 
27a6			; 
27a6			;	STACKFRAMECHK OFF $5efe $5f9f 
27a6			; 
27a6			;	; an immediate word so no need to process any more words 
27a6			;	ret 
27a6			;	NEXTW 
27a6			 
27a6			; dead code - old version  
27a6			;	FORTH_RSP_NEXT 
27a6			 
27a6			;  
27a6			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
27a6			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
27a6			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
27a6			;	push hl 
27a6			;	push de 
27a6			;	push bc 
27a6			; 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS_KEY 
27a6			;			DMARK "EXR" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			; 
27a6			; 
27a6			; 
27a6			;	;v5 FORTH_DSP_VALUE 
27a6			;	FORTH_DSP_VALUEHL 
27a6			; 
27a6			;	; TODO do string type checks 
27a6			; 
27a6			;;v5	inc hl   ; skip type 
27a6			; 
27a6			;	push hl  ; source code  
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX1" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	ld a, 0 
27a6			;	call strlent 
27a6			; 
27a6			;	inc hl 
27a6			;	inc hl 
27a6			;	inc hl 
27a6			;	inc hl 
27a6			; 
27a6			;	push hl    ; size 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX2" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	call malloc 
27a6			; 
27a6			;	ex de, hl    ; de now contains malloc area 
27a6			;	pop bc   	; get byte count 
27a6			;	pop hl      ; get string to copy 
27a6			; 
27a6			;	push de     ; save malloc for free later 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX3" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	ldir       ; duplicate string 
27a6			; 
27a6			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
27a6			;	 
27a6			;	; TODO fix the parse would be better than this...  
27a6			;	ex de, hl 
27a6			;	dec hl 
27a6			;	ld a, 0 
27a6			;	ld (hl), a 
27a6			;	dec hl 
27a6			;	ld a, ' ' 
27a6			;	ld (hl), a 
27a6			;	dec hl 
27a6			;	ld (hl), a 
27a6			; 
27a6			;	dec hl 
27a6			;	ld (hl), a 
27a6			; 
27a6			; 
27a6			;	FORTH_DSP_POP  
27a6			; 
27a6			;	pop hl     
27a6			;	push hl    ; save malloc area 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX4" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			; 
27a6			;	call forthparse 
27a6			;	call forthexec 
27a6			;	 
27a6			;	pop hl 
27a6			;	if DEBUG_FORTH_WORDS 
27a6			;		DMARK "EX5" 
27a6			;		CALLMONITOR 
27a6			;	endif 
27a6			; 
27a6			;	if FORTH_ENABLE_FREE 
27a6			;	call free 
27a6			;	endif 
27a6			; 
27a6			;	if DEBUG_FORTH_WORDS 
27a6			;		DMARK "EX6" 
27a6			;		CALLMONITOR 
27a6			;	endif 
27a6			; 
27a6			;	pop bc 
27a6			;	pop de 
27a6			;	pop hl 
27a6			;;	FORTH_RSP_POP	  
27a6			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
27a6			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
27a6			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
27a6			; 
27a6			;	if DEBUG_FORTH_WORDS 
27a6			;		DMARK "EX7" 
27a6			;		CALLMONITOR 
27a6			;	endif 
27a6			;	NEXTW 
27a6			 
27a6			;.STKEXEC: 
27a6			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
27a6			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
27a6			; 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS_KEY 
27a6			;			DMARK "STX" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			; 
27a6			;	FORTH_DSP_VALUEHL 
27a6			; 
27a6			;	ld (store_tmp1), hl    ; count 
27a6			; 
27a6			;	FORTH_DSP_POP 
27a6			;.stkexec1: 
27a6			;	ld hl, (store_tmp1)   ; count 
27a6			;	ld a, 0 
27a6			;	cp l 
27a6			;	ret z 
27a6			; 
27a6			;	dec hl 
27a6			;	ld (store_tmp1), hl    ; count 
27a6			;	 
27a6			;	FORTH_DSP_VALUEHL 
27a6			;	push hl 
27a6			;	 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EXp" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	FORTH_DSP_POP 
27a6			; 
27a6			;	call strlenz 
27a6			;	inc hl   ; include zero term to copy 
27a6			;	inc hl   ; include zero term to copy 
27a6			;	inc hl   ; include zero term to copy 
27a6			;	ld b,0 
27a6			;	ld c,l 
27a6			;	pop hl 
27a6			;	ld de, execscratch 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EX3" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	ldir 
27a6			; 
27a6			; 
27a6			;	ld hl, execscratch 
27a6			; 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EXP" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			; 
27a6			;	call forthparse 
27a6			;	ld hl, execscratch 
27a6			;		if DEBUG_FORTH_WORDS 
27a6			;			DMARK "EXx" 
27a6			;			CALLMONITOR 
27a6			;		endif 
27a6			;	call forthexec 
27a6			; 
27a6			;	jp .stkexec1 
27a6			; 
27a6			;	ret 
27a6			 
27a6			 
27a6			.DUP: 
27a6			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
27a6 17				db WORD_SYS_CORE+OPCODE_DUP             
27a7 1c 28			dw .ZDUP            
27a9 04				db 3 + 1 
27aa .. 00			db "DUP",0              
27ae				endm 
# End of macro CWHEAD
27ae			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
27ae			 
27ae				if DEBUG_FORTH_WORDS_KEY 
27ae					DMARK "DUP" 
27ae f5				push af  
27af 3a c3 27			ld a, (.dmark)  
27b2 32 a6 fd			ld (debug_mark),a  
27b5 3a c4 27			ld a, (.dmark+1)  
27b8 32 a7 fd			ld (debug_mark+1),a  
27bb 3a c5 27			ld a, (.dmark+2)  
27be 32 a8 fd			ld (debug_mark+2),a  
27c1 18 03			jr .pastdmark  
27c3 ..			.dmark: db "DUP"  
27c6 f1			.pastdmark: pop af  
27c7			endm  
# End of macro DMARK
27c7					CALLMONITOR 
27c7 cd aa fd			call debug_vector  
27ca				endm  
# End of macro CALLMONITOR
27ca				endif 
27ca			 
27ca				FORTH_DSP 
27ca cd 1f 24			call macro_forth_dsp 
27cd				endm 
# End of macro FORTH_DSP
27cd			 
27cd 7e				ld a, (HL) 
27ce fe 01			cp DS_TYPE_STR 
27d0 20 25			jr nz, .dupinum 
27d2			 
27d2				; push another string 
27d2			 
27d2				FORTH_DSP_VALUEHL     		 
27d2 cd 59 24			call macro_dsp_valuehl 
27d5				endm 
# End of macro FORTH_DSP_VALUEHL
27d5			 
27d5			if DEBUG_FORTH_WORDS 
27d5				DMARK "DUs" 
27d5 f5				push af  
27d6 3a ea 27			ld a, (.dmark)  
27d9 32 a6 fd			ld (debug_mark),a  
27dc 3a eb 27			ld a, (.dmark+1)  
27df 32 a7 fd			ld (debug_mark+1),a  
27e2 3a ec 27			ld a, (.dmark+2)  
27e5 32 a8 fd			ld (debug_mark+2),a  
27e8 18 03			jr .pastdmark  
27ea ..			.dmark: db "DUs"  
27ed f1			.pastdmark: pop af  
27ee			endm  
# End of macro DMARK
27ee				CALLMONITOR 
27ee cd aa fd			call debug_vector  
27f1				endm  
# End of macro CALLMONITOR
27f1			endif 
27f1 cd d0 22			call forth_push_str 
27f4			 
27f4				NEXTW 
27f4 c3 0f 26			jp macro_next 
27f7				endm 
# End of macro NEXTW
27f7			 
27f7			 
27f7			.dupinum: 
27f7				 
27f7			 
27f7			 
27f7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27f7 cd 59 24			call macro_dsp_valuehl 
27fa				endm 
# End of macro FORTH_DSP_VALUEHL
27fa			 
27fa			; TODO add floating point number detection 
27fa			 
27fa			if DEBUG_FORTH_WORDS 
27fa				DMARK "DUi" 
27fa f5				push af  
27fb 3a 0f 28			ld a, (.dmark)  
27fe 32 a6 fd			ld (debug_mark),a  
2801 3a 10 28			ld a, (.dmark+1)  
2804 32 a7 fd			ld (debug_mark+1),a  
2807 3a 11 28			ld a, (.dmark+2)  
280a 32 a8 fd			ld (debug_mark+2),a  
280d 18 03			jr .pastdmark  
280f ..			.dmark: db "DUi"  
2812 f1			.pastdmark: pop af  
2813			endm  
# End of macro DMARK
2813				CALLMONITOR 
2813 cd aa fd			call debug_vector  
2816				endm  
# End of macro CALLMONITOR
2816			endif 
2816			 
2816 cd 62 22			call forth_push_numhl 
2819				NEXTW 
2819 c3 0f 26			jp macro_next 
281c				endm 
# End of macro NEXTW
281c			.ZDUP: 
281c			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
281c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
281d 54 28			dw .SWAP            
281f 05				db 4 + 1 
2820 .. 00			db "?DUP",0              
2825				endm 
# End of macro CWHEAD
2825			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2825			 
2825				if DEBUG_FORTH_WORDS_KEY 
2825					DMARK "qDU" 
2825 f5				push af  
2826 3a 3a 28			ld a, (.dmark)  
2829 32 a6 fd			ld (debug_mark),a  
282c 3a 3b 28			ld a, (.dmark+1)  
282f 32 a7 fd			ld (debug_mark+1),a  
2832 3a 3c 28			ld a, (.dmark+2)  
2835 32 a8 fd			ld (debug_mark+2),a  
2838 18 03			jr .pastdmark  
283a ..			.dmark: db "qDU"  
283d f1			.pastdmark: pop af  
283e			endm  
# End of macro DMARK
283e					CALLMONITOR 
283e cd aa fd			call debug_vector  
2841				endm  
# End of macro CALLMONITOR
2841				endif 
2841				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2841 cd 59 24			call macro_dsp_valuehl 
2844				endm 
# End of macro FORTH_DSP_VALUEHL
2844			 
2844 e5				push hl 
2845			 
2845				; is it a zero? 
2845			 
2845 3e 00			ld a, 0 
2847 84				add h 
2848 85				add l 
2849			 
2849 e1				pop hl 
284a			 
284a fe 00			cp 0 
284c 28 03			jr z, .dup2orig 
284e			 
284e			 
284e cd 62 22			call forth_push_numhl 
2851			 
2851			 
2851			; TODO add floating point number detection 
2851			 
2851			.dup2orig: 
2851			 
2851				NEXTW 
2851 c3 0f 26			jp macro_next 
2854				endm 
# End of macro NEXTW
2854			.SWAP: 
2854			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2854 18				db WORD_SYS_CORE+OPCODE_SWAP             
2855 93 28			dw .COLN            
2857 05				db 4 + 1 
2858 .. 00			db "SWAP",0              
285d				endm 
# End of macro CWHEAD
285d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
285d				if DEBUG_FORTH_WORDS_KEY 
285d					DMARK "SWP" 
285d f5				push af  
285e 3a 72 28			ld a, (.dmark)  
2861 32 a6 fd			ld (debug_mark),a  
2864 3a 73 28			ld a, (.dmark+1)  
2867 32 a7 fd			ld (debug_mark+1),a  
286a 3a 74 28			ld a, (.dmark+2)  
286d 32 a8 fd			ld (debug_mark+2),a  
2870 18 03			jr .pastdmark  
2872 ..			.dmark: db "SWP"  
2875 f1			.pastdmark: pop af  
2876			endm  
# End of macro DMARK
2876					CALLMONITOR 
2876 cd aa fd			call debug_vector  
2879				endm  
# End of macro CALLMONITOR
2879				endif 
2879			 
2879			; TODO Use os stack swap memory 
2879				FORTH_DSP_VALUEHL 
2879 cd 59 24			call macro_dsp_valuehl 
287c				endm 
# End of macro FORTH_DSP_VALUEHL
287c e5				push hl     ; w2 
287d			 
287d				FORTH_DSP_POP 
287d cd 11 25			call macro_forth_dsp_pop 
2880				endm 
# End of macro FORTH_DSP_POP
2880			 
2880				FORTH_DSP_VALUEHL 
2880 cd 59 24			call macro_dsp_valuehl 
2883				endm 
# End of macro FORTH_DSP_VALUEHL
2883			 
2883				FORTH_DSP_POP 
2883 cd 11 25			call macro_forth_dsp_pop 
2886				endm 
# End of macro FORTH_DSP_POP
2886			 
2886 d1				pop de     ; w2	, hl = w1 
2887			 
2887 eb				ex de, hl 
2888 d5				push de 
2889			 
2889 cd 62 22			call forth_push_numhl 
288c			 
288c e1				pop hl 
288d			 
288d cd 62 22			call forth_push_numhl 
2890				 
2890			 
2890				NEXTW 
2890 c3 0f 26			jp macro_next 
2893				endm 
# End of macro NEXTW
2893			.COLN: 
2893			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2893 19				db WORD_SYS_CORE+OPCODE_COLN             
2894 1f 2a			dw .SCOLN            
2896 02				db 1 + 1 
2897 .. 00			db ":",0              
2899				endm 
# End of macro CWHEAD
2899			; | : ( -- )         Create new word | DONE 
2899			 
2899				if DEBUG_FORTH_WORDS_KEY 
2899					DMARK "CLN" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 a6 fd			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 a7 fd			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 a8 fd			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "CLN"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2					CALLMONITOR 
28b2 cd aa fd			call debug_vector  
28b5				endm  
# End of macro CALLMONITOR
28b5				endif 
28b5			STACKFRAME OFF $8efe $989f 
28b5				if DEBUG_STACK_IMB 
28b5					if OFF 
28b5						exx 
28b5						ld de, $8efe 
28b5						ld a, d 
28b5						ld hl, curframe 
28b5						call hexout 
28b5						ld a, e 
28b5						ld hl, curframe+2 
28b5						call hexout 
28b5						ld hl, $8efe 
28b5						push hl 
28b5						ld hl, $989f 
28b5						push hl 
28b5						exx 
28b5					endif 
28b5				endif 
28b5			endm 
# End of macro STACKFRAME
28b5			; get parser buffer length  of new word 
28b5			 
28b5			 
28b5			 
28b5				; move tok past this to start of name defintition 
28b5				; TODO get word to define 
28b5				; TODO Move past word token 
28b5				; TODO get length of string up to the ';' 
28b5			 
28b5 2a fd f3		ld hl, (os_tok_ptr) 
28b8 23			inc hl 
28b9 23			inc hl 
28ba			 
28ba 3e 3b		ld a, ';' 
28bc cd 97 15		call strlent 
28bf			 
28bf 7d			ld a,l 
28c0 32 ec f0		ld (os_new_parse_len), a 
28c3			 
28c3			 
28c3			if DEBUG_FORTH_UWORD 
28c3 ed 5b fd f3	ld de, (os_tok_ptr) 
28c7					DMARK ":01" 
28c7 f5				push af  
28c8 3a dc 28			ld a, (.dmark)  
28cb 32 a6 fd			ld (debug_mark),a  
28ce 3a dd 28			ld a, (.dmark+1)  
28d1 32 a7 fd			ld (debug_mark+1),a  
28d4 3a de 28			ld a, (.dmark+2)  
28d7 32 a8 fd			ld (debug_mark+2),a  
28da 18 03			jr .pastdmark  
28dc ..			.dmark: db ":01"  
28df f1			.pastdmark: pop af  
28e0			endm  
# End of macro DMARK
28e0			CALLMONITOR 
28e0 cd aa fd			call debug_vector  
28e3				endm  
# End of macro CALLMONITOR
28e3			endif 
28e3			 
28e3			; 
28e3			;  new word memory layout: 
28e3			;  
28e3			;    : adg 6666 ;  
28e3			; 
28e3			;    db   1     ; user defined word  
28e3 23			inc hl    
28e4			;    dw   sysdict 
28e4 23			inc hl 
28e5 23			inc hl 
28e6			;    db <word len>+1 (for null) 
28e6 23			inc hl 
28e7			;    db .... <word> 
28e7			; 
28e7			 
28e7 23			inc hl    ; some extras for the word preamble before the above 
28e8 23			inc hl 
28e9 23			inc hl 
28ea 23			inc hl 
28eb 23			inc hl 
28ec 23			inc hl 
28ed 23			inc hl  
28ee 23			inc hl 
28ef 23			inc hl 
28f0 23			inc hl 
28f1 23			inc hl 
28f2 23			inc hl 
28f3 23			inc hl 
28f4 23			inc hl     ; TODO how many do we really need?     maybe only 6 
28f5			;       exec word buffer 
28f5			;	<ptr word>   
28f5 23			inc hl 
28f6 23			inc hl 
28f7			;       <word list><null term> 7F final term 
28f7			 
28f7			 
28f7			if DEBUG_FORTH_UWORD 
28f7					DMARK ":02" 
28f7 f5				push af  
28f8 3a 0c 29			ld a, (.dmark)  
28fb 32 a6 fd			ld (debug_mark),a  
28fe 3a 0d 29			ld a, (.dmark+1)  
2901 32 a7 fd			ld (debug_mark+1),a  
2904 3a 0e 29			ld a, (.dmark+2)  
2907 32 a8 fd			ld (debug_mark+2),a  
290a 18 03			jr .pastdmark  
290c ..			.dmark: db ":02"  
290f f1			.pastdmark: pop af  
2910			endm  
# End of macro DMARK
2910			CALLMONITOR 
2910 cd aa fd			call debug_vector  
2913				endm  
# End of macro CALLMONITOR
2913			endif 
2913			 
2913			 
2913				; malloc the size 
2913			 
2913 cd 01 16			call malloc 
2916 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
2919			 
2919			;    db   1     ; user defined word  
2919 3e 01			ld a, WORD_SYS_UWORD  
291b 77				ld (hl), a 
291c			 
291c 23			inc hl    
291d			;    dw   sysdict 
291d 11 67 27		ld de, sysdict       ; continue on with the scan to the system dict 
2920 73			ld (hl), e 
2921 23			inc hl 
2922 72			ld (hl), d 
2923 23			inc hl 
2924			 
2924			 
2924			;    Setup dict word 
2924			 
2924 23			inc hl 
2925 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2928			 
2928			; 1. get length of dict word 
2928			 
2928			 
2928 2a fd f3		ld hl, (os_tok_ptr) 
292b 23			inc hl 
292c 23			inc hl    ; position to start of dict word 
292d 3e 00		ld a, 0 
292f cd 97 15		call strlent 
2932			 
2932			 
2932 23			inc hl    ; to include null??? 
2933			 
2933			; write length of dict word 
2933			 
2933 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2937 1b			dec de 
2938 eb			ex de, hl 
2939 73			ld (hl), e 
293a eb			ex de, hl 
293b			 
293b			 
293b			 
293b			; copy  
293b 4d			ld c, l 
293c 06 00		ld b, 0 
293e ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2942 2a fd f3		ld hl, (os_tok_ptr) 
2945 23			inc hl 
2946 23			inc hl    ; position to start of dict word 
2947			 
2947			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2947			 
2947			; TODO need to convert word to upper case 
2947			 
2947			ucasetok:	 
2947 7e			ld a,(hl) 
2948 cd 83 15		call toUpper 
294b 77			ld (hl),a 
294c ed a0		ldi 
294e f2 47 29		jp p, ucasetok 
2951			 
2951			 
2951			 
2951			; de now points to start of where the word body code should be placed 
2951 ed 53 e8 f0	ld (os_new_work_ptr), de 
2955			; hl now points to the words to throw at forthexec which needs to be copied 
2955 22 e6 f0		ld (os_new_src_ptr), hl 
2958			 
2958			; TODO add 'call to forthexec' 
2958			 
2958			if DEBUG_FORTH_UWORD 
2958 c5			push bc 
2959 ed 4b ee f0	ld bc, (os_new_malloc) 
295d					DMARK ":0x" 
295d f5				push af  
295e 3a 72 29			ld a, (.dmark)  
2961 32 a6 fd			ld (debug_mark),a  
2964 3a 73 29			ld a, (.dmark+1)  
2967 32 a7 fd			ld (debug_mark+1),a  
296a 3a 74 29			ld a, (.dmark+2)  
296d 32 a8 fd			ld (debug_mark+2),a  
2970 18 03			jr .pastdmark  
2972 ..			.dmark: db ":0x"  
2975 f1			.pastdmark: pop af  
2976			endm  
# End of macro DMARK
2976			CALLMONITOR 
2976 cd aa fd			call debug_vector  
2979				endm  
# End of macro CALLMONITOR
2979 c1			pop bc 
297a			endif 
297a			 
297a			 
297a			; create word preamble which should be: 
297a			 
297a			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
297a			 
297a			;    ld hl, <word code> 
297a			;    jp user_exec 
297a			;    <word code bytes> 
297a			 
297a			 
297a			;	inc de     ; TODO ??? or are we already past the word's null 
297a eb			ex de, hl 
297b			 
297b 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
297d			 
297d 23			inc hl 
297e 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2981 23			inc hl 
2982			 
2982 23			inc hl 
2983 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2985			 
2985 01 10 5f		ld bc, user_exec 
2988 23			inc hl 
2989 71			ld (hl), c     ; poke address of user_exec 
298a 23			inc hl 
298b 70			ld (hl), b     
298c			; 
298c			;	inc hl 
298c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
298c			; 
298c			; 
298c			;	ld bc, macro_forth_rsp_next 
298c			;	inc hl 
298c			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
298c			;	inc hl 
298c			;	ld (hl), b     
298c			; 
298c			;	inc hl 
298c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
298c			; 
298c			; 
298c			;	inc hl 
298c			;	ld bc, forthexec 
298c			;	ld (hl), c     ; poke address of forthexec 
298c			;	inc hl 
298c			;	ld (hl), b      
298c			; 
298c			;	inc hl 
298c			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
298c			; 
298c			;	ld bc, user_dict_next 
298c			;	inc hl 
298c			;	ld (hl), c     ; poke address of forthexec 
298c			;	inc hl 
298c			;	ld (hl), b      
298c			 
298c			; hl is now where we need to copy the word byte data to save this 
298c			 
298c 23			inc hl 
298d 22 e4 f0		ld (os_new_exec), hl 
2990			 
2990			; copy definition 
2990			 
2990 eb			ex de, hl 
2991			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2991			;	inc de    ; skip the PC for this parse 
2991 3a ec f0		ld a, (os_new_parse_len) 
2994 4f			ld c, a 
2995 06 00		ld b, 0 
2997 ed b0		ldir		 ; copy defintion 
2999			 
2999			 
2999			; poke the address of where the new word bytes live for forthexec 
2999			 
2999 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
299c			 
299c ed 5b e4 f0	ld de, (os_new_exec)      
29a0			 
29a0 73			ld (hl), e 
29a1 23			inc hl 
29a2 72			ld (hl), d 
29a3			 
29a3				; TODO copy last user dict word next link to this word 
29a3				; TODO update last user dict word to point to this word 
29a3			; 
29a3			; hl f923 de 812a ; bc 811a 
29a3			 
29a3			if DEBUG_FORTH_UWORD 
29a3 c5			push bc 
29a4 ed 4b ee f0	ld bc, (os_new_malloc) 
29a8					DMARK ":0A" 
29a8 f5				push af  
29a9 3a bd 29			ld a, (.dmark)  
29ac 32 a6 fd			ld (debug_mark),a  
29af 3a be 29			ld a, (.dmark+1)  
29b2 32 a7 fd			ld (debug_mark+1),a  
29b5 3a bf 29			ld a, (.dmark+2)  
29b8 32 a8 fd			ld (debug_mark+2),a  
29bb 18 03			jr .pastdmark  
29bd ..			.dmark: db ":0A"  
29c0 f1			.pastdmark: pop af  
29c1			endm  
# End of macro DMARK
29c1			CALLMONITOR 
29c1 cd aa fd			call debug_vector  
29c4				endm  
# End of macro CALLMONITOR
29c4 c1			pop bc 
29c5			endif 
29c5			if DEBUG_FORTH_UWORD 
29c5 c5			push bc 
29c6 ed 4b ee f0	ld bc, (os_new_malloc) 
29ca 03			inc bc 
29cb 03			inc bc 
29cc 03			inc bc 
29cd 03			inc bc 
29ce 03			inc bc 
29cf 03			inc bc 
29d0 03			inc bc 
29d1 03			inc bc 
29d2			 
29d2					DMARK ":0B" 
29d2 f5				push af  
29d3 3a e7 29			ld a, (.dmark)  
29d6 32 a6 fd			ld (debug_mark),a  
29d9 3a e8 29			ld a, (.dmark+1)  
29dc 32 a7 fd			ld (debug_mark+1),a  
29df 3a e9 29			ld a, (.dmark+2)  
29e2 32 a8 fd			ld (debug_mark+2),a  
29e5 18 03			jr .pastdmark  
29e7 ..			.dmark: db ":0B"  
29ea f1			.pastdmark: pop af  
29eb			endm  
# End of macro DMARK
29eb			CALLMONITOR 
29eb cd aa fd			call debug_vector  
29ee				endm  
# End of macro CALLMONITOR
29ee c1			pop bc 
29ef			endif 
29ef			 
29ef			; update word dict linked list for new word 
29ef			 
29ef			 
29ef 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
29f2 23			inc hl     ; move to next work linked list ptr 
29f3			 
29f3 ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
29f7 73			ld (hl), e 
29f8 23			inc hl 
29f9 72			ld (hl), d 
29fa			 
29fa			if DEBUG_FORTH_UWORD 
29fa ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
29fe			endif 
29fe			 
29fe ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
2a02			 
2a02			 
2a02			if DEBUG_FORTH_UWORD 
2a02					DMARK ":0+" 
2a02 f5				push af  
2a03 3a 17 2a			ld a, (.dmark)  
2a06 32 a6 fd			ld (debug_mark),a  
2a09 3a 18 2a			ld a, (.dmark+1)  
2a0c 32 a7 fd			ld (debug_mark+1),a  
2a0f 3a 19 2a			ld a, (.dmark+2)  
2a12 32 a8 fd			ld (debug_mark+2),a  
2a15 18 03			jr .pastdmark  
2a17 ..			.dmark: db ":0+"  
2a1a f1			.pastdmark: pop af  
2a1b			endm  
# End of macro DMARK
2a1b			CALLMONITOR 
2a1b cd aa fd			call debug_vector  
2a1e				endm  
# End of macro CALLMONITOR
2a1e			endif 
2a1e			 
2a1e			STACKFRAMECHK OFF $8efe $989f 
2a1e				if DEBUG_STACK_IMB 
2a1e					if OFF 
2a1e						exx 
2a1e						ld hl, $989f 
2a1e						pop de   ; $989f 
2a1e						call cmp16 
2a1e						jr nz, .spnosame 
2a1e						ld hl, $8efe 
2a1e						pop de   ; $8efe 
2a1e						call cmp16 
2a1e						jr z, .spfrsame 
2a1e						.spnosame: call showsperror 
2a1e						.spfrsame: nop 
2a1e						exx 
2a1e					endif 
2a1e				endif 
2a1e			endm 
# End of macro STACKFRAMECHK
2a1e			 
2a1e c9			ret    ; dont process any remaining parser tokens as they form new word 
2a1f			 
2a1f			 
2a1f			 
2a1f			 
2a1f			;		NEXT 
2a1f			.SCOLN: 
2a1f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2a1f 06			db OPCODE_SCOLN 
2a20 6b 2a		dw .DROP 
2a22 02			db 2 
2a23 .. 00		db ";",0           
2a25			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2a25				if DEBUG_FORTH_WORDS_KEY 
2a25					DMARK "SCN" 
2a25 f5				push af  
2a26 3a 3a 2a			ld a, (.dmark)  
2a29 32 a6 fd			ld (debug_mark),a  
2a2c 3a 3b 2a			ld a, (.dmark+1)  
2a2f 32 a7 fd			ld (debug_mark+1),a  
2a32 3a 3c 2a			ld a, (.dmark+2)  
2a35 32 a8 fd			ld (debug_mark+2),a  
2a38 18 03			jr .pastdmark  
2a3a ..			.dmark: db "SCN"  
2a3d f1			.pastdmark: pop af  
2a3e			endm  
# End of macro DMARK
2a3e					CALLMONITOR 
2a3e cd aa fd			call debug_vector  
2a41				endm  
# End of macro CALLMONITOR
2a41				endif 
2a41				FORTH_RSP_TOS 
2a41 cd 20 22			call macro_forth_rsp_tos 
2a44				endm 
# End of macro FORTH_RSP_TOS
2a44 e5				push hl 
2a45				FORTH_RSP_POP 
2a45 cd 2a 22			call macro_forth_rsp_pop 
2a48				endm 
# End of macro FORTH_RSP_POP
2a48 e1				pop hl 
2a49			;		ex de,hl 
2a49 22 fd f3			ld (os_tok_ptr),hl 
2a4c			 
2a4c			if DEBUG_FORTH_UWORD 
2a4c					DMARK "SCL" 
2a4c f5				push af  
2a4d 3a 61 2a			ld a, (.dmark)  
2a50 32 a6 fd			ld (debug_mark),a  
2a53 3a 62 2a			ld a, (.dmark+1)  
2a56 32 a7 fd			ld (debug_mark+1),a  
2a59 3a 63 2a			ld a, (.dmark+2)  
2a5c 32 a8 fd			ld (debug_mark+2),a  
2a5f 18 03			jr .pastdmark  
2a61 ..			.dmark: db "SCL"  
2a64 f1			.pastdmark: pop af  
2a65			endm  
# End of macro DMARK
2a65			CALLMONITOR 
2a65 cd aa fd			call debug_vector  
2a68				endm  
# End of macro CALLMONITOR
2a68			endif 
2a68				NEXTW 
2a68 c3 0f 26			jp macro_next 
2a6b				endm 
# End of macro NEXTW
2a6b			 
2a6b			.DROP: 
2a6b			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2a6b 1b				db WORD_SYS_CORE+OPCODE_DROP             
2a6c 96 2a			dw .DUP2            
2a6e 05				db 4 + 1 
2a6f .. 00			db "DROP",0              
2a74				endm 
# End of macro CWHEAD
2a74			; | DROP ( w -- )   drop the TOS item   | DONE 
2a74				if DEBUG_FORTH_WORDS_KEY 
2a74					DMARK "DRP" 
2a74 f5				push af  
2a75 3a 89 2a			ld a, (.dmark)  
2a78 32 a6 fd			ld (debug_mark),a  
2a7b 3a 8a 2a			ld a, (.dmark+1)  
2a7e 32 a7 fd			ld (debug_mark+1),a  
2a81 3a 8b 2a			ld a, (.dmark+2)  
2a84 32 a8 fd			ld (debug_mark+2),a  
2a87 18 03			jr .pastdmark  
2a89 ..			.dmark: db "DRP"  
2a8c f1			.pastdmark: pop af  
2a8d			endm  
# End of macro DMARK
2a8d					CALLMONITOR 
2a8d cd aa fd			call debug_vector  
2a90				endm  
# End of macro CALLMONITOR
2a90				endif 
2a90				FORTH_DSP_POP 
2a90 cd 11 25			call macro_forth_dsp_pop 
2a93				endm 
# End of macro FORTH_DSP_POP
2a93				NEXTW 
2a93 c3 0f 26			jp macro_next 
2a96				endm 
# End of macro NEXTW
2a96			.DUP2: 
2a96			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2a96 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2a97 db 2a			dw .DROP2            
2a99 05				db 4 + 1 
2a9a .. 00			db "2DUP",0              
2a9f				endm 
# End of macro CWHEAD
2a9f			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2a9f				if DEBUG_FORTH_WORDS_KEY 
2a9f					DMARK "2DU" 
2a9f f5				push af  
2aa0 3a b4 2a			ld a, (.dmark)  
2aa3 32 a6 fd			ld (debug_mark),a  
2aa6 3a b5 2a			ld a, (.dmark+1)  
2aa9 32 a7 fd			ld (debug_mark+1),a  
2aac 3a b6 2a			ld a, (.dmark+2)  
2aaf 32 a8 fd			ld (debug_mark+2),a  
2ab2 18 03			jr .pastdmark  
2ab4 ..			.dmark: db "2DU"  
2ab7 f1			.pastdmark: pop af  
2ab8			endm  
# End of macro DMARK
2ab8					CALLMONITOR 
2ab8 cd aa fd			call debug_vector  
2abb				endm  
# End of macro CALLMONITOR
2abb				endif 
2abb				FORTH_DSP_VALUEHL 
2abb cd 59 24			call macro_dsp_valuehl 
2abe				endm 
# End of macro FORTH_DSP_VALUEHL
2abe e5				push hl      ; 2 
2abf			 
2abf				FORTH_DSP_POP 
2abf cd 11 25			call macro_forth_dsp_pop 
2ac2				endm 
# End of macro FORTH_DSP_POP
2ac2				 
2ac2				FORTH_DSP_VALUEHL 
2ac2 cd 59 24			call macro_dsp_valuehl 
2ac5				endm 
# End of macro FORTH_DSP_VALUEHL
2ac5			;		push hl      ; 1 
2ac5			 
2ac5				FORTH_DSP_POP 
2ac5 cd 11 25			call macro_forth_dsp_pop 
2ac8				endm 
# End of macro FORTH_DSP_POP
2ac8			 
2ac8			;		pop hl       ; 1 
2ac8 d1				pop de       ; 2 
2ac9			 
2ac9 cd 62 22			call forth_push_numhl 
2acc eb				ex de, hl 
2acd cd 62 22			call forth_push_numhl 
2ad0			 
2ad0				 
2ad0 eb				ex de, hl 
2ad1			 
2ad1 cd 62 22			call forth_push_numhl 
2ad4 eb				ex de, hl 
2ad5 cd 62 22			call forth_push_numhl 
2ad8			 
2ad8			 
2ad8				NEXTW 
2ad8 c3 0f 26			jp macro_next 
2adb				endm 
# End of macro NEXTW
2adb			.DROP2: 
2adb			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2adb 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2adc 0a 2b			dw .SWAP2            
2ade 06				db 5 + 1 
2adf .. 00			db "2DROP",0              
2ae5				endm 
# End of macro CWHEAD
2ae5			; | 2DROP ( w w -- )    Double drop | DONE 
2ae5				if DEBUG_FORTH_WORDS_KEY 
2ae5					DMARK "2DR" 
2ae5 f5				push af  
2ae6 3a fa 2a			ld a, (.dmark)  
2ae9 32 a6 fd			ld (debug_mark),a  
2aec 3a fb 2a			ld a, (.dmark+1)  
2aef 32 a7 fd			ld (debug_mark+1),a  
2af2 3a fc 2a			ld a, (.dmark+2)  
2af5 32 a8 fd			ld (debug_mark+2),a  
2af8 18 03			jr .pastdmark  
2afa ..			.dmark: db "2DR"  
2afd f1			.pastdmark: pop af  
2afe			endm  
# End of macro DMARK
2afe					CALLMONITOR 
2afe cd aa fd			call debug_vector  
2b01				endm  
# End of macro CALLMONITOR
2b01				endif 
2b01				FORTH_DSP_POP 
2b01 cd 11 25			call macro_forth_dsp_pop 
2b04				endm 
# End of macro FORTH_DSP_POP
2b04				FORTH_DSP_POP 
2b04 cd 11 25			call macro_forth_dsp_pop 
2b07				endm 
# End of macro FORTH_DSP_POP
2b07				NEXTW 
2b07 c3 0f 26			jp macro_next 
2b0a				endm 
# End of macro NEXTW
2b0a			.SWAP2: 
2b0a			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2b0a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2b0b 33 2b			dw .AT            
2b0d 06				db 5 + 1 
2b0e .. 00			db "2SWAP",0              
2b14				endm 
# End of macro CWHEAD
2b14			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2b14				if DEBUG_FORTH_WORDS_KEY 
2b14					DMARK "2SW" 
2b14 f5				push af  
2b15 3a 29 2b			ld a, (.dmark)  
2b18 32 a6 fd			ld (debug_mark),a  
2b1b 3a 2a 2b			ld a, (.dmark+1)  
2b1e 32 a7 fd			ld (debug_mark+1),a  
2b21 3a 2b 2b			ld a, (.dmark+2)  
2b24 32 a8 fd			ld (debug_mark+2),a  
2b27 18 03			jr .pastdmark  
2b29 ..			.dmark: db "2SW"  
2b2c f1			.pastdmark: pop af  
2b2d			endm  
# End of macro DMARK
2b2d					CALLMONITOR 
2b2d cd aa fd			call debug_vector  
2b30				endm  
# End of macro CALLMONITOR
2b30				endif 
2b30			; TODO Use os stack swap memory 
2b30				NEXTW 
2b30 c3 0f 26			jp macro_next 
2b33				endm 
# End of macro NEXTW
2b33			.AT: 
2b33			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2b33 1f				db WORD_SYS_CORE+OPCODE_AT             
2b34 65 2b			dw .CAT            
2b36 02				db 1 + 1 
2b37 .. 00			db "@",0              
2b39				endm 
# End of macro CWHEAD
2b39			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2b39			 
2b39				if DEBUG_FORTH_WORDS_KEY 
2b39					DMARK "AT." 
2b39 f5				push af  
2b3a 3a 4e 2b			ld a, (.dmark)  
2b3d 32 a6 fd			ld (debug_mark),a  
2b40 3a 4f 2b			ld a, (.dmark+1)  
2b43 32 a7 fd			ld (debug_mark+1),a  
2b46 3a 50 2b			ld a, (.dmark+2)  
2b49 32 a8 fd			ld (debug_mark+2),a  
2b4c 18 03			jr .pastdmark  
2b4e ..			.dmark: db "AT."  
2b51 f1			.pastdmark: pop af  
2b52			endm  
# End of macro DMARK
2b52					CALLMONITOR 
2b52 cd aa fd			call debug_vector  
2b55				endm  
# End of macro CALLMONITOR
2b55				endif 
2b55			.getbyteat:	 
2b55				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b55 cd 59 24			call macro_dsp_valuehl 
2b58				endm 
# End of macro FORTH_DSP_VALUEHL
2b58				 
2b58			;		push hl 
2b58			 
2b58				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b58 cd 11 25			call macro_forth_dsp_pop 
2b5b				endm 
# End of macro FORTH_DSP_POP
2b5b			 
2b5b			;		pop hl 
2b5b			 
2b5b 7e				ld a, (hl) 
2b5c			 
2b5c 6f				ld l, a 
2b5d 26 00			ld h, 0 
2b5f cd 62 22			call forth_push_numhl 
2b62			 
2b62				NEXTW 
2b62 c3 0f 26			jp macro_next 
2b65				endm 
# End of macro NEXTW
2b65			.CAT: 
2b65			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2b65 20				db WORD_SYS_CORE+OPCODE_CAT             
2b66 8e 2b			dw .BANG            
2b68 03				db 2 + 1 
2b69 .. 00			db "C@",0              
2b6c				endm 
# End of macro CWHEAD
2b6c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2b6c				if DEBUG_FORTH_WORDS_KEY 
2b6c					DMARK "CAA" 
2b6c f5				push af  
2b6d 3a 81 2b			ld a, (.dmark)  
2b70 32 a6 fd			ld (debug_mark),a  
2b73 3a 82 2b			ld a, (.dmark+1)  
2b76 32 a7 fd			ld (debug_mark+1),a  
2b79 3a 83 2b			ld a, (.dmark+2)  
2b7c 32 a8 fd			ld (debug_mark+2),a  
2b7f 18 03			jr .pastdmark  
2b81 ..			.dmark: db "CAA"  
2b84 f1			.pastdmark: pop af  
2b85			endm  
# End of macro DMARK
2b85					CALLMONITOR 
2b85 cd aa fd			call debug_vector  
2b88				endm  
# End of macro CALLMONITOR
2b88				endif 
2b88 c3 55 2b			jp .getbyteat 
2b8b				NEXTW 
2b8b c3 0f 26			jp macro_next 
2b8e				endm 
# End of macro NEXTW
2b8e			.BANG: 
2b8e			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2b8e 21				db WORD_SYS_CORE+OPCODE_BANG             
2b8f c4 2b			dw .CBANG            
2b91 02				db 1 + 1 
2b92 .. 00			db "!",0              
2b94				endm 
# End of macro CWHEAD
2b94			; | ! ( x w -- ) Store x at address w      | DONE 
2b94				if DEBUG_FORTH_WORDS_KEY 
2b94					DMARK "BNG" 
2b94 f5				push af  
2b95 3a a9 2b			ld a, (.dmark)  
2b98 32 a6 fd			ld (debug_mark),a  
2b9b 3a aa 2b			ld a, (.dmark+1)  
2b9e 32 a7 fd			ld (debug_mark+1),a  
2ba1 3a ab 2b			ld a, (.dmark+2)  
2ba4 32 a8 fd			ld (debug_mark+2),a  
2ba7 18 03			jr .pastdmark  
2ba9 ..			.dmark: db "BNG"  
2bac f1			.pastdmark: pop af  
2bad			endm  
# End of macro DMARK
2bad					CALLMONITOR 
2bad cd aa fd			call debug_vector  
2bb0				endm  
# End of macro CALLMONITOR
2bb0				endif 
2bb0			 
2bb0			.storebyteat:		 
2bb0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bb0 cd 59 24			call macro_dsp_valuehl 
2bb3				endm 
# End of macro FORTH_DSP_VALUEHL
2bb3				 
2bb3 e5				push hl 
2bb4			 
2bb4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bb4 cd 11 25			call macro_forth_dsp_pop 
2bb7				endm 
# End of macro FORTH_DSP_POP
2bb7			 
2bb7				; get byte to poke 
2bb7			 
2bb7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bb7 cd 59 24			call macro_dsp_valuehl 
2bba				endm 
# End of macro FORTH_DSP_VALUEHL
2bba e5				push hl 
2bbb			 
2bbb			 
2bbb				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bbb cd 11 25			call macro_forth_dsp_pop 
2bbe				endm 
# End of macro FORTH_DSP_POP
2bbe			 
2bbe			 
2bbe d1				pop de 
2bbf e1				pop hl 
2bc0			 
2bc0 73				ld (hl),e 
2bc1			 
2bc1			 
2bc1				NEXTW 
2bc1 c3 0f 26			jp macro_next 
2bc4				endm 
# End of macro NEXTW
2bc4			.CBANG: 
2bc4			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2bc4 22				db WORD_SYS_CORE+OPCODE_CBANG             
2bc5 ed 2b			dw .SCALL            
2bc7 03				db 2 + 1 
2bc8 .. 00			db "C!",0              
2bcb				endm 
# End of macro CWHEAD
2bcb			; | C!  ( x w -- ) Store x at address w  | DONE 
2bcb				if DEBUG_FORTH_WORDS_KEY 
2bcb					DMARK "CBA" 
2bcb f5				push af  
2bcc 3a e0 2b			ld a, (.dmark)  
2bcf 32 a6 fd			ld (debug_mark),a  
2bd2 3a e1 2b			ld a, (.dmark+1)  
2bd5 32 a7 fd			ld (debug_mark+1),a  
2bd8 3a e2 2b			ld a, (.dmark+2)  
2bdb 32 a8 fd			ld (debug_mark+2),a  
2bde 18 03			jr .pastdmark  
2be0 ..			.dmark: db "CBA"  
2be3 f1			.pastdmark: pop af  
2be4			endm  
# End of macro DMARK
2be4					CALLMONITOR 
2be4 cd aa fd			call debug_vector  
2be7				endm  
# End of macro CALLMONITOR
2be7				endif 
2be7 c3 b0 2b			jp .storebyteat 
2bea				NEXTW 
2bea c3 0f 26			jp macro_next 
2bed				endm 
# End of macro NEXTW
2bed			.SCALL: 
2bed			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2bed 23				db WORD_SYS_CORE+OPCODE_SCALL             
2bee 21 2c			dw .DEPTH            
2bf0 05				db 4 + 1 
2bf1 .. 00			db "CALL",0              
2bf6				endm 
# End of macro CWHEAD
2bf6			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2bf6				if DEBUG_FORTH_WORDS_KEY 
2bf6					DMARK "CLL" 
2bf6 f5				push af  
2bf7 3a 0b 2c			ld a, (.dmark)  
2bfa 32 a6 fd			ld (debug_mark),a  
2bfd 3a 0c 2c			ld a, (.dmark+1)  
2c00 32 a7 fd			ld (debug_mark+1),a  
2c03 3a 0d 2c			ld a, (.dmark+2)  
2c06 32 a8 fd			ld (debug_mark+2),a  
2c09 18 03			jr .pastdmark  
2c0b ..			.dmark: db "CLL"  
2c0e f1			.pastdmark: pop af  
2c0f			endm  
# End of macro DMARK
2c0f					CALLMONITOR 
2c0f cd aa fd			call debug_vector  
2c12				endm  
# End of macro CALLMONITOR
2c12				endif 
2c12			 
2c12				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c12 cd 59 24			call macro_dsp_valuehl 
2c15				endm 
# End of macro FORTH_DSP_VALUEHL
2c15			 
2c15			;		push hl 
2c15			 
2c15				; destroy value TOS 
2c15			 
2c15				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c15 cd 11 25			call macro_forth_dsp_pop 
2c18				endm 
# End of macro FORTH_DSP_POP
2c18			 
2c18					 
2c18			;		pop hl 
2c18			 
2c18				; how to do a call with hl???? save SP? 
2c18 cd b3 25			call forth_call_hl 
2c1b			 
2c1b			 
2c1b				; TODO push value back onto stack for another op etc 
2c1b			 
2c1b cd 62 22			call forth_push_numhl 
2c1e				NEXTW 
2c1e c3 0f 26			jp macro_next 
2c21				endm 
# End of macro NEXTW
2c21			.DEPTH: 
2c21			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2c21 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2c22 5e 2c			dw .OVER            
2c24 06				db 5 + 1 
2c25 .. 00			db "DEPTH",0              
2c2b				endm 
# End of macro CWHEAD
2c2b			; | DEPTH ( -- u ) Push count of stack | DONE 
2c2b				; take current TOS and remove from base value div by two to get count 
2c2b				if DEBUG_FORTH_WORDS_KEY 
2c2b					DMARK "DEP" 
2c2b f5				push af  
2c2c 3a 40 2c			ld a, (.dmark)  
2c2f 32 a6 fd			ld (debug_mark),a  
2c32 3a 41 2c			ld a, (.dmark+1)  
2c35 32 a7 fd			ld (debug_mark+1),a  
2c38 3a 42 2c			ld a, (.dmark+2)  
2c3b 32 a8 fd			ld (debug_mark+2),a  
2c3e 18 03			jr .pastdmark  
2c40 ..			.dmark: db "DEP"  
2c43 f1			.pastdmark: pop af  
2c44			endm  
# End of macro DMARK
2c44					CALLMONITOR 
2c44 cd aa fd			call debug_vector  
2c47				endm  
# End of macro CALLMONITOR
2c47				endif 
2c47			 
2c47			 
2c47 2a 29 f9		ld hl, (cli_data_sp) 
2c4a 11 63 f6		ld de, cli_data_stack 
2c4d ed 52		sbc hl,de 
2c4f			 
2c4f			; div by size of stack item 
2c4f			 
2c4f 5d			ld e,l 
2c50 0e 03		ld c, 3 
2c52 cd 5f 0f		call Div8 
2c55			 
2c55 6f			ld l,a 
2c56 26 00		ld h,0 
2c58			 
2c58			;srl h 
2c58			;rr l 
2c58			 
2c58 cd 62 22			call forth_push_numhl 
2c5b				NEXTW 
2c5b c3 0f 26			jp macro_next 
2c5e				endm 
# End of macro NEXTW
2c5e			.OVER: 
2c5e			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2c5e 42				db WORD_SYS_CORE+46             
2c5f a5 2c			dw .PAUSE            
2c61 05				db 4 + 1 
2c62 .. 00			db "OVER",0              
2c67				endm 
# End of macro CWHEAD
2c67			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2c67				if DEBUG_FORTH_WORDS_KEY 
2c67					DMARK "OVR" 
2c67 f5				push af  
2c68 3a 7c 2c			ld a, (.dmark)  
2c6b 32 a6 fd			ld (debug_mark),a  
2c6e 3a 7d 2c			ld a, (.dmark+1)  
2c71 32 a7 fd			ld (debug_mark+1),a  
2c74 3a 7e 2c			ld a, (.dmark+2)  
2c77 32 a8 fd			ld (debug_mark+2),a  
2c7a 18 03			jr .pastdmark  
2c7c ..			.dmark: db "OVR"  
2c7f f1			.pastdmark: pop af  
2c80			endm  
# End of macro DMARK
2c80					CALLMONITOR 
2c80 cd aa fd			call debug_vector  
2c83				endm  
# End of macro CALLMONITOR
2c83				endif 
2c83			 
2c83			; TODO Use os stack swap memory 
2c83				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c83 cd 59 24			call macro_dsp_valuehl 
2c86				endm 
# End of macro FORTH_DSP_VALUEHL
2c86 e5				push hl    ; n2 
2c87				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c87 cd 11 25			call macro_forth_dsp_pop 
2c8a				endm 
# End of macro FORTH_DSP_POP
2c8a			 
2c8a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c8a cd 59 24			call macro_dsp_valuehl 
2c8d				endm 
# End of macro FORTH_DSP_VALUEHL
2c8d e5				push hl    ; n1 
2c8e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c8e cd 11 25			call macro_forth_dsp_pop 
2c91				endm 
# End of macro FORTH_DSP_POP
2c91			 
2c91 d1				pop de     ; n1 
2c92 e1				pop hl     ; n2 
2c93			 
2c93 d5				push de 
2c94 e5				push hl 
2c95 d5				push de 
2c96			 
2c96				; push back  
2c96			 
2c96 e1				pop hl 
2c97 cd 62 22			call forth_push_numhl 
2c9a e1				pop hl 
2c9b cd 62 22			call forth_push_numhl 
2c9e e1				pop hl 
2c9f cd 62 22			call forth_push_numhl 
2ca2				NEXTW 
2ca2 c3 0f 26			jp macro_next 
2ca5				endm 
# End of macro NEXTW
2ca5			 
2ca5			.PAUSE: 
2ca5			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2ca5 43				db WORD_SYS_CORE+47             
2ca6 da 2c			dw .PAUSES            
2ca8 08				db 7 + 1 
2ca9 .. 00			db "PAUSEMS",0              
2cb1				endm 
# End of macro CWHEAD
2cb1			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2cb1				if DEBUG_FORTH_WORDS_KEY 
2cb1					DMARK "PMS" 
2cb1 f5				push af  
2cb2 3a c6 2c			ld a, (.dmark)  
2cb5 32 a6 fd			ld (debug_mark),a  
2cb8 3a c7 2c			ld a, (.dmark+1)  
2cbb 32 a7 fd			ld (debug_mark+1),a  
2cbe 3a c8 2c			ld a, (.dmark+2)  
2cc1 32 a8 fd			ld (debug_mark+2),a  
2cc4 18 03			jr .pastdmark  
2cc6 ..			.dmark: db "PMS"  
2cc9 f1			.pastdmark: pop af  
2cca			endm  
# End of macro DMARK
2cca					CALLMONITOR 
2cca cd aa fd			call debug_vector  
2ccd				endm  
# End of macro CALLMONITOR
2ccd				endif 
2ccd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ccd cd 59 24			call macro_dsp_valuehl 
2cd0				endm 
# End of macro FORTH_DSP_VALUEHL
2cd0			;		push hl    ; n2 
2cd0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cd0 cd 11 25			call macro_forth_dsp_pop 
2cd3				endm 
# End of macro FORTH_DSP_POP
2cd3			;		pop hl 
2cd3			 
2cd3 7d				ld a, l 
2cd4 cd c3 0c			call aDelayInMS 
2cd7			       NEXTW 
2cd7 c3 0f 26			jp macro_next 
2cda				endm 
# End of macro NEXTW
2cda			.PAUSES:  
2cda			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2cda 44				db WORD_SYS_CORE+48             
2cdb 49 2d			dw .ROT            
2cdd 06				db 5 + 1 
2cde .. 00			db "PAUSE",0              
2ce4				endm 
# End of macro CWHEAD
2ce4			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2ce4				if DEBUG_FORTH_WORDS_KEY 
2ce4					DMARK "PAU" 
2ce4 f5				push af  
2ce5 3a f9 2c			ld a, (.dmark)  
2ce8 32 a6 fd			ld (debug_mark),a  
2ceb 3a fa 2c			ld a, (.dmark+1)  
2cee 32 a7 fd			ld (debug_mark+1),a  
2cf1 3a fb 2c			ld a, (.dmark+2)  
2cf4 32 a8 fd			ld (debug_mark+2),a  
2cf7 18 03			jr .pastdmark  
2cf9 ..			.dmark: db "PAU"  
2cfc f1			.pastdmark: pop af  
2cfd			endm  
# End of macro DMARK
2cfd					CALLMONITOR 
2cfd cd aa fd			call debug_vector  
2d00				endm  
# End of macro CALLMONITOR
2d00				endif 
2d00				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d00 cd 59 24			call macro_dsp_valuehl 
2d03				endm 
# End of macro FORTH_DSP_VALUEHL
2d03			;		push hl    ; n2 
2d03				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d03 cd 11 25			call macro_forth_dsp_pop 
2d06				endm 
# End of macro FORTH_DSP_POP
2d06			;		pop hl 
2d06 45				ld b, l 
2d07				if DEBUG_FORTH_WORDS 
2d07					DMARK "PAU" 
2d07 f5				push af  
2d08 3a 1c 2d			ld a, (.dmark)  
2d0b 32 a6 fd			ld (debug_mark),a  
2d0e 3a 1d 2d			ld a, (.dmark+1)  
2d11 32 a7 fd			ld (debug_mark+1),a  
2d14 3a 1e 2d			ld a, (.dmark+2)  
2d17 32 a8 fd			ld (debug_mark+2),a  
2d1a 18 03			jr .pastdmark  
2d1c ..			.dmark: db "PAU"  
2d1f f1			.pastdmark: pop af  
2d20			endm  
# End of macro DMARK
2d20					CALLMONITOR 
2d20 cd aa fd			call debug_vector  
2d23				endm  
# End of macro CALLMONITOR
2d23				endif 
2d23 c5			.pauses1:	push bc 
2d24 cd de 0c			call delay1s 
2d27 c1				pop bc 
2d28				if DEBUG_FORTH_WORDS 
2d28					DMARK "PA1" 
2d28 f5				push af  
2d29 3a 3d 2d			ld a, (.dmark)  
2d2c 32 a6 fd			ld (debug_mark),a  
2d2f 3a 3e 2d			ld a, (.dmark+1)  
2d32 32 a7 fd			ld (debug_mark+1),a  
2d35 3a 3f 2d			ld a, (.dmark+2)  
2d38 32 a8 fd			ld (debug_mark+2),a  
2d3b 18 03			jr .pastdmark  
2d3d ..			.dmark: db "PA1"  
2d40 f1			.pastdmark: pop af  
2d41			endm  
# End of macro DMARK
2d41					CALLMONITOR 
2d41 cd aa fd			call debug_vector  
2d44				endm  
# End of macro CALLMONITOR
2d44				endif 
2d44 10 dd			djnz .pauses1 
2d46			 
2d46			       NEXTW 
2d46 c3 0f 26			jp macro_next 
2d49				endm 
# End of macro NEXTW
2d49			.ROT: 
2d49			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2d49 45				db WORD_SYS_CORE+49             
2d4a 97 2d			dw .UWORDS            
2d4c 04				db 3 + 1 
2d4d .. 00			db "ROT",0              
2d51				endm 
# End of macro CWHEAD
2d51			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2d51				if DEBUG_FORTH_WORDS_KEY 
2d51					DMARK "ROT" 
2d51 f5				push af  
2d52 3a 66 2d			ld a, (.dmark)  
2d55 32 a6 fd			ld (debug_mark),a  
2d58 3a 67 2d			ld a, (.dmark+1)  
2d5b 32 a7 fd			ld (debug_mark+1),a  
2d5e 3a 68 2d			ld a, (.dmark+2)  
2d61 32 a8 fd			ld (debug_mark+2),a  
2d64 18 03			jr .pastdmark  
2d66 ..			.dmark: db "ROT"  
2d69 f1			.pastdmark: pop af  
2d6a			endm  
# End of macro DMARK
2d6a					CALLMONITOR 
2d6a cd aa fd			call debug_vector  
2d6d				endm  
# End of macro CALLMONITOR
2d6d				endif 
2d6d			 
2d6d			; TODO Use os stack swap memory 
2d6d				FORTH_DSP_VALUEHL 
2d6d cd 59 24			call macro_dsp_valuehl 
2d70				endm 
# End of macro FORTH_DSP_VALUEHL
2d70 e5				push hl    ; u3  
2d71			 
2d71				FORTH_DSP_POP 
2d71 cd 11 25			call macro_forth_dsp_pop 
2d74				endm 
# End of macro FORTH_DSP_POP
2d74			 
2d74				FORTH_DSP_VALUEHL 
2d74 cd 59 24			call macro_dsp_valuehl 
2d77				endm 
# End of macro FORTH_DSP_VALUEHL
2d77 e5				push hl     ; u2 
2d78			 
2d78				FORTH_DSP_POP 
2d78 cd 11 25			call macro_forth_dsp_pop 
2d7b				endm 
# End of macro FORTH_DSP_POP
2d7b			 
2d7b				FORTH_DSP_VALUEHL 
2d7b cd 59 24			call macro_dsp_valuehl 
2d7e				endm 
# End of macro FORTH_DSP_VALUEHL
2d7e e5				push hl     ; u1 
2d7f			 
2d7f				FORTH_DSP_POP 
2d7f cd 11 25			call macro_forth_dsp_pop 
2d82				endm 
# End of macro FORTH_DSP_POP
2d82			 
2d82 c1				pop bc      ; u1 
2d83 e1				pop hl      ; u2 
2d84 d1				pop de      ; u3 
2d85			 
2d85			 
2d85 c5				push bc 
2d86 d5				push de 
2d87 e5				push hl 
2d88			 
2d88			 
2d88 e1				pop hl 
2d89 cd 62 22			call forth_push_numhl 
2d8c			 
2d8c e1				pop hl 
2d8d cd 62 22			call forth_push_numhl 
2d90			 
2d90 e1				pop hl 
2d91 cd 62 22			call forth_push_numhl 
2d94				 
2d94			 
2d94			 
2d94			 
2d94			 
2d94			 
2d94			       NEXTW 
2d94 c3 0f 26			jp macro_next 
2d97				endm 
# End of macro NEXTW
2d97			 
2d97			.UWORDS: 
2d97			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2d97 50				db WORD_SYS_CORE+60             
2d98 59 2e			dw .BP            
2d9a 07				db 6 + 1 
2d9b .. 00			db "UWORDS",0              
2da2				endm 
# End of macro CWHEAD
2da2			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2da2			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2da2			; | | Following the count are the individual words. 
2da2			; | | 
2da2			; | | e.g. UWORDS 
2da2			; | | BOX DIRLIST 2 
2da2			; | |  
2da2			; | | Can be used to save the words to storage via: 
2da2			; | | UWORDS $01 DO $01 APPEND LOOP 
2da2			if DEBUG_FORTH_WORDS_KEY 
2da2				DMARK "UWR" 
2da2 f5				push af  
2da3 3a b7 2d			ld a, (.dmark)  
2da6 32 a6 fd			ld (debug_mark),a  
2da9 3a b8 2d			ld a, (.dmark+1)  
2dac 32 a7 fd			ld (debug_mark+1),a  
2daf 3a b9 2d			ld a, (.dmark+2)  
2db2 32 a8 fd			ld (debug_mark+2),a  
2db5 18 03			jr .pastdmark  
2db7 ..			.dmark: db "UWR"  
2dba f1			.pastdmark: pop af  
2dbb			endm  
# End of macro DMARK
2dbb				CALLMONITOR 
2dbb cd aa fd			call debug_vector  
2dbe				endm  
# End of macro CALLMONITOR
2dbe			endif 
2dbe 21 00 80			ld hl, baseram 
2dc1				;ld hl, baseusermem 
2dc1 01 00 00			ld bc, 0    ; start a counter 
2dc4			 
2dc4			; skip dict stub 
2dc4			 
2dc4 cd 60 27			call forth_tok_next 
2dc7			 
2dc7			 
2dc7			; while we have words to look for 
2dc7			 
2dc7 7e			.douscan:	ld a, (hl)      
2dc8			if DEBUG_FORTH_WORDS 
2dc8				DMARK "UWs" 
2dc8 f5				push af  
2dc9 3a dd 2d			ld a, (.dmark)  
2dcc 32 a6 fd			ld (debug_mark),a  
2dcf 3a de 2d			ld a, (.dmark+1)  
2dd2 32 a7 fd			ld (debug_mark+1),a  
2dd5 3a df 2d			ld a, (.dmark+2)  
2dd8 32 a8 fd			ld (debug_mark+2),a  
2ddb 18 03			jr .pastdmark  
2ddd ..			.dmark: db "UWs"  
2de0 f1			.pastdmark: pop af  
2de1			endm  
# End of macro DMARK
2de1				CALLMONITOR 
2de1 cd aa fd			call debug_vector  
2de4				endm  
# End of macro CALLMONITOR
2de4			endif 
2de4 fe 00			cp WORD_SYS_END 
2de6 28 4d			jr z, .udone 
2de8 fe 01			cp WORD_SYS_UWORD 
2dea 20 44			jr nz, .nuword 
2dec			 
2dec			if DEBUG_FORTH_WORDS 
2dec				DMARK "UWu" 
2dec f5				push af  
2ded 3a 01 2e			ld a, (.dmark)  
2df0 32 a6 fd			ld (debug_mark),a  
2df3 3a 02 2e			ld a, (.dmark+1)  
2df6 32 a7 fd			ld (debug_mark+1),a  
2df9 3a 03 2e			ld a, (.dmark+2)  
2dfc 32 a8 fd			ld (debug_mark+2),a  
2dff 18 03			jr .pastdmark  
2e01 ..			.dmark: db "UWu"  
2e04 f1			.pastdmark: pop af  
2e05			endm  
# End of macro DMARK
2e05				CALLMONITOR 
2e05 cd aa fd			call debug_vector  
2e08				endm  
# End of macro CALLMONITOR
2e08			endif 
2e08				; we have a uword so push its name to the stack 
2e08			 
2e08 e5				push hl  ; save so we can move to next dict block 
2e09			 
2e09				; skip opcode 
2e09 23				inc hl  
2e0a				; skip next ptr 
2e0a 23				inc hl  
2e0b 23				inc hl 
2e0c				; skip len 
2e0c 23				inc hl 
2e0d			if DEBUG_FORTH_WORDS 
2e0d				DMARK "UWt" 
2e0d f5				push af  
2e0e 3a 22 2e			ld a, (.dmark)  
2e11 32 a6 fd			ld (debug_mark),a  
2e14 3a 23 2e			ld a, (.dmark+1)  
2e17 32 a7 fd			ld (debug_mark+1),a  
2e1a 3a 24 2e			ld a, (.dmark+2)  
2e1d 32 a8 fd			ld (debug_mark+2),a  
2e20 18 03			jr .pastdmark  
2e22 ..			.dmark: db "UWt"  
2e25 f1			.pastdmark: pop af  
2e26			endm  
# End of macro DMARK
2e26				CALLMONITOR 
2e26 cd aa fd			call debug_vector  
2e29				endm  
# End of macro CALLMONITOR
2e29			endif 
2e29 03				inc bc 
2e2a			 
2e2a c5				push bc 
2e2b cd d0 22			call forth_push_str 
2e2e c1				pop bc 
2e2f			 
2e2f e1				pop hl 	 
2e30			 
2e30 cd 60 27		.nuword:	call forth_tok_next 
2e33 18 92			jr .douscan  
2e35			 
2e35			.udone:		 ; push count of uwords found 
2e35 c5				push bc 
2e36 e1				pop hl 
2e37			 
2e37			if DEBUG_FORTH_WORDS 
2e37				DMARK "UWc" 
2e37 f5				push af  
2e38 3a 4c 2e			ld a, (.dmark)  
2e3b 32 a6 fd			ld (debug_mark),a  
2e3e 3a 4d 2e			ld a, (.dmark+1)  
2e41 32 a7 fd			ld (debug_mark+1),a  
2e44 3a 4e 2e			ld a, (.dmark+2)  
2e47 32 a8 fd			ld (debug_mark+2),a  
2e4a 18 03			jr .pastdmark  
2e4c ..			.dmark: db "UWc"  
2e4f f1			.pastdmark: pop af  
2e50			endm  
# End of macro DMARK
2e50				CALLMONITOR 
2e50 cd aa fd			call debug_vector  
2e53				endm  
# End of macro CALLMONITOR
2e53			endif 
2e53 cd 62 22			call forth_push_numhl 
2e56			 
2e56			 
2e56			       NEXTW 
2e56 c3 0f 26			jp macro_next 
2e59				endm 
# End of macro NEXTW
2e59			 
2e59			.BP: 
2e59			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2e59 54				db WORD_SYS_CORE+64             
2e5a 93 2e			dw .MONITOR            
2e5c 03				db 2 + 1 
2e5d .. 00			db "BP",0              
2e60				endm 
# End of macro CWHEAD
2e60			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2e60			; | | $00 Will enable the break points within specific code paths 
2e60			; | | $01 Will disable break points 
2e60			; | |  
2e60			; | | By default break points are off. Either the above can be used to enable them 
2e60			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2e60			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2e60			; | | can disable break points. Exiting will then continue boot process. 
2e60				; get byte count 
2e60				if DEBUG_FORTH_WORDS_KEY 
2e60					DMARK "BP." 
2e60 f5				push af  
2e61 3a 75 2e			ld a, (.dmark)  
2e64 32 a6 fd			ld (debug_mark),a  
2e67 3a 76 2e			ld a, (.dmark+1)  
2e6a 32 a7 fd			ld (debug_mark+1),a  
2e6d 3a 77 2e			ld a, (.dmark+2)  
2e70 32 a8 fd			ld (debug_mark+2),a  
2e73 18 03			jr .pastdmark  
2e75 ..			.dmark: db "BP."  
2e78 f1			.pastdmark: pop af  
2e79			endm  
# End of macro DMARK
2e79					CALLMONITOR 
2e79 cd aa fd			call debug_vector  
2e7c				endm  
# End of macro CALLMONITOR
2e7c				endif 
2e7c			 
2e7c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e7c cd 59 24			call macro_dsp_valuehl 
2e7f				endm 
# End of macro FORTH_DSP_VALUEHL
2e7f			 
2e7f			;		push hl 
2e7f			 
2e7f				; destroy value TOS 
2e7f			 
2e7f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e7f cd 11 25			call macro_forth_dsp_pop 
2e82				endm 
# End of macro FORTH_DSP_POP
2e82			 
2e82			;		pop hl 
2e82			 
2e82 3e 00			ld a,0 
2e84 bd				cp l 
2e85 28 06			jr z, .bpset 
2e87			;		ld a, '*' 
2e87 cd a0 1b			call bp_off 
2e8a				NEXTW 
2e8a c3 0f 26			jp macro_next 
2e8d				endm 
# End of macro NEXTW
2e8d			 
2e8d			.bpset:	 
2e8d				;	ld (os_view_disable), a 
2e8d cd 94 1b			call bp_on 
2e90			 
2e90			 
2e90				NEXTW 
2e90 c3 0f 26			jp macro_next 
2e93				endm 
# End of macro NEXTW
2e93			 
2e93			 
2e93			.MONITOR: 
2e93			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2e93 55				db WORD_SYS_CORE+65             
2e94 c4 2e			dw .MALLOC            
2e96 08				db 7 + 1 
2e97 .. 00			db "MONITOR",0              
2e9f				endm 
# End of macro CWHEAD
2e9f			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2e9f			; | | At start the current various registers will be displayed with contents. 
2e9f			; | | Top right corner will show the most recent debug marker seen. 
2e9f			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2e9f			; | | and the return stack pointer (RSP). 
2e9f			; | | Pressing: 
2e9f			; | |    1 - Initial screen 
2e9f			; | |    2 - Display a data dump of HL 
2e9f			; | |    3 - Display a data dump of DE 
2e9f			; | |    4 - Display a data dump of BC 
2e9f			; | |    5 - Display a data dump of HL 
2e9f			; | |    6 - Display a data dump of DSP 
2e9f			; | |    7 - Display a data dump of RSP 
2e9f			; | |    8 - Display a data dump of what is at DSP 
2e9f			; | |    9 - Display a data dump of what is at RSP 
2e9f			; | |    0 - Exit monitor and continue running. This will also enable break points 
2e9f			; | |    * - Disable break points 
2e9f			; | |    # - Enter traditional monitor mode 
2e9f			; | | 
2e9f			; | | Monitor Mode 
2e9f			; | | ------------ 
2e9f			; | | A prompt of '>' will be shown for various commands: 
2e9f			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2e9f			; | |    C - Continue display a data dump from the last set address 
2e9f			; | |    M xxxx - Set start of memory edit at address xx 
2e9f			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2e9f			; | |    G xxxx - Exec code at specific address 
2e9f			; | |    Q - Return to previous 
2e9f				if DEBUG_FORTH_WORDS_KEY 
2e9f					DMARK "MON" 
2e9f f5				push af  
2ea0 3a b4 2e			ld a, (.dmark)  
2ea3 32 a6 fd			ld (debug_mark),a  
2ea6 3a b5 2e			ld a, (.dmark+1)  
2ea9 32 a7 fd			ld (debug_mark+1),a  
2eac 3a b6 2e			ld a, (.dmark+2)  
2eaf 32 a8 fd			ld (debug_mark+2),a  
2eb2 18 03			jr .pastdmark  
2eb4 ..			.dmark: db "MON"  
2eb7 f1			.pastdmark: pop af  
2eb8			endm  
# End of macro DMARK
2eb8					CALLMONITOR 
2eb8 cd aa fd			call debug_vector  
2ebb				endm  
# End of macro CALLMONITOR
2ebb				endif 
2ebb			;		ld a, 0 
2ebb			;		ld (os_view_disable), a 
2ebb cd 94 1b			call bp_on 
2ebe			 
2ebe				CALLMONITOR 
2ebe cd aa fd			call debug_vector  
2ec1				endm  
# End of macro CALLMONITOR
2ec1			 
2ec1			;	call monitor 
2ec1			 
2ec1				NEXTW 
2ec1 c3 0f 26			jp macro_next 
2ec4				endm 
# End of macro NEXTW
2ec4			 
2ec4			 
2ec4			.MALLOC: 
2ec4			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2ec4 56				db WORD_SYS_CORE+66             
2ec5 ed 2e			dw .MALLOC2            
2ec7 06				db 5 + 1 
2ec8 .. 00			db "ALLOT",0              
2ece				endm 
# End of macro CWHEAD
2ece			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ece				if DEBUG_FORTH_WORDS_KEY 
2ece					DMARK "ALL" 
2ece f5				push af  
2ecf 3a e3 2e			ld a, (.dmark)  
2ed2 32 a6 fd			ld (debug_mark),a  
2ed5 3a e4 2e			ld a, (.dmark+1)  
2ed8 32 a7 fd			ld (debug_mark+1),a  
2edb 3a e5 2e			ld a, (.dmark+2)  
2ede 32 a8 fd			ld (debug_mark+2),a  
2ee1 18 03			jr .pastdmark  
2ee3 ..			.dmark: db "ALL"  
2ee6 f1			.pastdmark: pop af  
2ee7			endm  
# End of macro DMARK
2ee7					CALLMONITOR 
2ee7 cd aa fd			call debug_vector  
2eea				endm  
# End of macro CALLMONITOR
2eea				endif 
2eea c3 14 2f			jp .mallocc 
2eed			.MALLOC2: 
2eed			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2eed 56				db WORD_SYS_CORE+66             
2eee 2b 2f			dw .FREE            
2ef0 07				db 6 + 1 
2ef1 .. 00			db "MALLOC",0              
2ef8				endm 
# End of macro CWHEAD
2ef8			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ef8				; get byte count 
2ef8				if DEBUG_FORTH_WORDS_KEY 
2ef8					DMARK "MAL" 
2ef8 f5				push af  
2ef9 3a 0d 2f			ld a, (.dmark)  
2efc 32 a6 fd			ld (debug_mark),a  
2eff 3a 0e 2f			ld a, (.dmark+1)  
2f02 32 a7 fd			ld (debug_mark+1),a  
2f05 3a 0f 2f			ld a, (.dmark+2)  
2f08 32 a8 fd			ld (debug_mark+2),a  
2f0b 18 03			jr .pastdmark  
2f0d ..			.dmark: db "MAL"  
2f10 f1			.pastdmark: pop af  
2f11			endm  
# End of macro DMARK
2f11					CALLMONITOR 
2f11 cd aa fd			call debug_vector  
2f14				endm  
# End of macro CALLMONITOR
2f14				endif 
2f14			.mallocc: 
2f14				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f14 cd 59 24			call macro_dsp_valuehl 
2f17				endm 
# End of macro FORTH_DSP_VALUEHL
2f17			 
2f17			;		push hl 
2f17			 
2f17				; destroy value TOS 
2f17			 
2f17				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f17 cd 11 25			call macro_forth_dsp_pop 
2f1a				endm 
# End of macro FORTH_DSP_POP
2f1a			 
2f1a			;		pop hl 
2f1a cd 01 16			call malloc 
2f1d			if DEBUG_FORTH_MALLOC_GUARD 
2f1d f5				push af 
2f1e cd f8 0f			call ishlzero 
2f21			;		ld a, l 
2f21			;		add h 
2f21			;		cp 0 
2f21 f1				pop af 
2f22				 
2f22 cc e2 5f			call z,malloc_error 
2f25			endif 
2f25			 
2f25 cd 62 22			call forth_push_numhl 
2f28				NEXTW 
2f28 c3 0f 26			jp macro_next 
2f2b				endm 
# End of macro NEXTW
2f2b			 
2f2b			.FREE: 
2f2b			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2f2b 57				db WORD_SYS_CORE+67             
2f2c 5c 2f			dw .LIST            
2f2e 05				db 4 + 1 
2f2f .. 00			db "FREE",0              
2f34				endm 
# End of macro CWHEAD
2f34			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2f34				if DEBUG_FORTH_WORDS_KEY 
2f34					DMARK "FRE" 
2f34 f5				push af  
2f35 3a 49 2f			ld a, (.dmark)  
2f38 32 a6 fd			ld (debug_mark),a  
2f3b 3a 4a 2f			ld a, (.dmark+1)  
2f3e 32 a7 fd			ld (debug_mark+1),a  
2f41 3a 4b 2f			ld a, (.dmark+2)  
2f44 32 a8 fd			ld (debug_mark+2),a  
2f47 18 03			jr .pastdmark  
2f49 ..			.dmark: db "FRE"  
2f4c f1			.pastdmark: pop af  
2f4d			endm  
# End of macro DMARK
2f4d					CALLMONITOR 
2f4d cd aa fd			call debug_vector  
2f50				endm  
# End of macro CALLMONITOR
2f50				endif 
2f50				; get address 
2f50			 
2f50				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f50 cd 59 24			call macro_dsp_valuehl 
2f53				endm 
# End of macro FORTH_DSP_VALUEHL
2f53			 
2f53			;		push hl 
2f53			 
2f53				; destroy value TOS 
2f53			 
2f53				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f53 cd 11 25			call macro_forth_dsp_pop 
2f56				endm 
# End of macro FORTH_DSP_POP
2f56			 
2f56			;		pop hl 
2f56			if FORTH_ENABLE_MALLOCFREE 
2f56 cd cb 16			call free 
2f59			endif 
2f59				NEXTW 
2f59 c3 0f 26			jp macro_next 
2f5c				endm 
# End of macro NEXTW
2f5c			.LIST: 
2f5c			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2f5c 5c				db WORD_SYS_CORE+72             
2f5d 4c 31			dw .FORGET            
2f5f 05				db 4 + 1 
2f60 .. 00			db "LIST",0              
2f65				endm 
# End of macro CWHEAD
2f65			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2f65			; | | The quoted word must be in upper case. 
2f65			if DEBUG_FORTH_WORDS_KEY 
2f65				DMARK "LST" 
2f65 f5				push af  
2f66 3a 7a 2f			ld a, (.dmark)  
2f69 32 a6 fd			ld (debug_mark),a  
2f6c 3a 7b 2f			ld a, (.dmark+1)  
2f6f 32 a7 fd			ld (debug_mark+1),a  
2f72 3a 7c 2f			ld a, (.dmark+2)  
2f75 32 a8 fd			ld (debug_mark+2),a  
2f78 18 03			jr .pastdmark  
2f7a ..			.dmark: db "LST"  
2f7d f1			.pastdmark: pop af  
2f7e			endm  
# End of macro DMARK
2f7e				CALLMONITOR 
2f7e cd aa fd			call debug_vector  
2f81				endm  
# End of macro CALLMONITOR
2f81			endif 
2f81			 
2f81				FORTH_DSP_VALUEHL 
2f81 cd 59 24			call macro_dsp_valuehl 
2f84				endm 
# End of macro FORTH_DSP_VALUEHL
2f84			 
2f84 e5				push hl 
2f85				FORTH_DSP_POP 
2f85 cd 11 25			call macro_forth_dsp_pop 
2f88				endm 
# End of macro FORTH_DSP_POP
2f88 c1				pop bc 
2f89			 
2f89			; Start format of scratch string 
2f89			 
2f89 21 fc f0			ld hl, scratch 
2f8c			 
2f8c 3e 3a			ld a, ':' 
2f8e 77				ld (hl),a 
2f8f 23				inc hl 
2f90 3e 20			ld a, ' ' 
2f92 77				ld (hl), a 
2f93			 
2f93				; Get ptr to the word we need to look up 
2f93			 
2f93			;		FORTH_DSP_VALUEHL 
2f93				;v5 FORTH_DSP_VALUE 
2f93			; TODO type check 
2f93			;		inc hl    ; Skip type check  
2f93			;		push hl 
2f93			;		ex de, hl    ; put into DE 
2f93			 
2f93			 
2f93 21 00 80			ld hl, baseram 
2f96				;ld hl, baseusermem 
2f96			 
2f96 e5			push hl   ; sacreifical push 
2f97			 
2f97			.ldouscanm: 
2f97 e1			pop hl 
2f98			.ldouscan: 
2f98			if DEBUG_FORTH_WORDS 
2f98				DMARK "LSs" 
2f98 f5				push af  
2f99 3a ad 2f			ld a, (.dmark)  
2f9c 32 a6 fd			ld (debug_mark),a  
2f9f 3a ae 2f			ld a, (.dmark+1)  
2fa2 32 a7 fd			ld (debug_mark+1),a  
2fa5 3a af 2f			ld a, (.dmark+2)  
2fa8 32 a8 fd			ld (debug_mark+2),a  
2fab 18 03			jr .pastdmark  
2fad ..			.dmark: db "LSs"  
2fb0 f1			.pastdmark: pop af  
2fb1			endm  
# End of macro DMARK
2fb1				CALLMONITOR 
2fb1 cd aa fd			call debug_vector  
2fb4				endm  
# End of macro CALLMONITOR
2fb4			endif 
2fb4			; skip dict stub 
2fb4 cd 60 27			call forth_tok_next 
2fb7			 
2fb7			 
2fb7			; while we have words to look for 
2fb7			 
2fb7 7e			ld a, (hl)      
2fb8			if DEBUG_FORTH_WORDS 
2fb8				DMARK "LSk" 
2fb8 f5				push af  
2fb9 3a cd 2f			ld a, (.dmark)  
2fbc 32 a6 fd			ld (debug_mark),a  
2fbf 3a ce 2f			ld a, (.dmark+1)  
2fc2 32 a7 fd			ld (debug_mark+1),a  
2fc5 3a cf 2f			ld a, (.dmark+2)  
2fc8 32 a8 fd			ld (debug_mark+2),a  
2fcb 18 03			jr .pastdmark  
2fcd ..			.dmark: db "LSk"  
2fd0 f1			.pastdmark: pop af  
2fd1			endm  
# End of macro DMARK
2fd1				CALLMONITOR 
2fd1 cd aa fd			call debug_vector  
2fd4				endm  
# End of macro CALLMONITOR
2fd4			endif 
2fd4				;cp WORD_SYS_END 
2fd4				;jp z, .lunotfound 
2fd4			 
2fd4					; if we hit non uwords then gone too far 
2fd4 fe 01				cp WORD_SYS_UWORD 
2fd6 c2 08 31				jp nz, .lunotfound 
2fd9			 
2fd9				if DEBUG_FORTH_WORDS 
2fd9					DMARK "LSu" 
2fd9 f5				push af  
2fda 3a ee 2f			ld a, (.dmark)  
2fdd 32 a6 fd			ld (debug_mark),a  
2fe0 3a ef 2f			ld a, (.dmark+1)  
2fe3 32 a7 fd			ld (debug_mark+1),a  
2fe6 3a f0 2f			ld a, (.dmark+2)  
2fe9 32 a8 fd			ld (debug_mark+2),a  
2fec 18 03			jr .pastdmark  
2fee ..			.dmark: db "LSu"  
2ff1 f1			.pastdmark: pop af  
2ff2			endm  
# End of macro DMARK
2ff2					CALLMONITOR 
2ff2 cd aa fd			call debug_vector  
2ff5				endm  
# End of macro CALLMONITOR
2ff5				endif 
2ff5			 
2ff5					; found a uword but is it the one we want... 
2ff5			 
2ff5 c5					push bc     ; uword to find is on bc 
2ff6 d1					pop de 
2ff7			 
2ff7 e5					push hl  ; to save the ptr 
2ff8			 
2ff8					; skip opcode 
2ff8 23					inc hl  
2ff9					; skip next ptr 
2ff9 23					inc hl  
2ffa 23					inc hl 
2ffb					; skip len 
2ffb 23					inc hl 
2ffc			 
2ffc				if DEBUG_FORTH_WORDS 
2ffc					DMARK "LSc" 
2ffc f5				push af  
2ffd 3a 11 30			ld a, (.dmark)  
3000 32 a6 fd			ld (debug_mark),a  
3003 3a 12 30			ld a, (.dmark+1)  
3006 32 a7 fd			ld (debug_mark+1),a  
3009 3a 13 30			ld a, (.dmark+2)  
300c 32 a8 fd			ld (debug_mark+2),a  
300f 18 03			jr .pastdmark  
3011 ..			.dmark: db "LSc"  
3014 f1			.pastdmark: pop af  
3015			endm  
# End of macro DMARK
3015					CALLMONITOR 
3015 cd aa fd			call debug_vector  
3018				endm  
# End of macro CALLMONITOR
3018				endif 
3018			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
3018			; ie. If WOO is defined first and then WO. Couldnt list WO. 
3018			; Nope that has gone the other way. It needs to be exact not on first zero 
3018			;		call strcmp 
3018 c5					push bc 
3019 cd d1 15				call StrictStrCmp 
301c c1					pop bc 
301d c2 97 2f				jp nz, .ldouscanm 
3020				 
3020			 
3020			 
3020					; we have a uword so push its name to the stack 
3020			 
3020			;	   	push hl  ; save so we can move to next dict block 
3020 e1			pop hl 
3021			 
3021				if DEBUG_FORTH_WORDS 
3021					DMARK "LSm" 
3021 f5				push af  
3022 3a 36 30			ld a, (.dmark)  
3025 32 a6 fd			ld (debug_mark),a  
3028 3a 37 30			ld a, (.dmark+1)  
302b 32 a7 fd			ld (debug_mark+1),a  
302e 3a 38 30			ld a, (.dmark+2)  
3031 32 a8 fd			ld (debug_mark+2),a  
3034 18 03			jr .pastdmark  
3036 ..			.dmark: db "LSm"  
3039 f1			.pastdmark: pop af  
303a			endm  
# End of macro DMARK
303a					CALLMONITOR 
303a cd aa fd			call debug_vector  
303d				endm  
# End of macro CALLMONITOR
303d				endif 
303d			 
303d					; skip opcode 
303d 23					inc hl  
303e					; skip next ptr 
303e 23					inc hl  
303f 23					inc hl 
3040					; skip len 
3040 7e					ld a, (hl)   ; save length to add 
3041				if DEBUG_FORTH_WORDS 
3041					DMARK "LS2" 
3041 f5				push af  
3042 3a 56 30			ld a, (.dmark)  
3045 32 a6 fd			ld (debug_mark),a  
3048 3a 57 30			ld a, (.dmark+1)  
304b 32 a7 fd			ld (debug_mark+1),a  
304e 3a 58 30			ld a, (.dmark+2)  
3051 32 a8 fd			ld (debug_mark+2),a  
3054 18 03			jr .pastdmark  
3056 ..			.dmark: db "LS2"  
3059 f1			.pastdmark: pop af  
305a			endm  
# End of macro DMARK
305a					CALLMONITOR 
305a cd aa fd			call debug_vector  
305d				endm  
# End of macro CALLMONITOR
305d				endif 
305d			 
305d					; save this location 
305d				 
305d e5					push hl 
305e			 
305e 23					inc hl 
305f 11 fe f0				ld de, scratch+2 
3062 4f					ld c, a 
3063 06 00				ld b, 0 
3065			 
3065				if DEBUG_FORTH_WORDS 
3065					DMARK "LSn" 
3065 f5				push af  
3066 3a 7a 30			ld a, (.dmark)  
3069 32 a6 fd			ld (debug_mark),a  
306c 3a 7b 30			ld a, (.dmark+1)  
306f 32 a7 fd			ld (debug_mark+1),a  
3072 3a 7c 30			ld a, (.dmark+2)  
3075 32 a8 fd			ld (debug_mark+2),a  
3078 18 03			jr .pastdmark  
307a ..			.dmark: db "LSn"  
307d f1			.pastdmark: pop af  
307e			endm  
# End of macro DMARK
307e					CALLMONITOR 
307e cd aa fd			call debug_vector  
3081				endm  
# End of macro CALLMONITOR
3081				endif 
3081			 
3081					; copy uword name to scratch 
3081			 
3081 ed b0				ldir 
3083			 
3083 1b					dec de 
3084 3e 20				ld a, ' '    ; change null to space 
3086 12					ld (de), a 
3087			 
3087 13					inc de 
3088			 
3088 d5					push de 
3089 c1					pop bc     ; move scratch pointer to end of word name and save it 
308a			 
308a e1					pop hl 
308b 7e					ld a, (hl) 
308c					;inc hl 
308c					; skip word string 
308c cd cf 0f				call addatohl 
308f			 
308f 23					inc hl 
3090			 
3090				if DEBUG_FORTH_WORDS 
3090					DMARK "LS3" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 a6 fd			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 a7 fd			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 a8 fd			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "LS3"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9					CALLMONITOR 
30a9 cd aa fd			call debug_vector  
30ac				endm  
# End of macro CALLMONITOR
30ac				endif 
30ac					; should now be at the start of the machine code to setup the eval of the uword 
30ac					; now locate the ptr to the string defintion 
30ac			 
30ac					; skip ld hl, 
30ac					; then load the ptr 
30ac			; TODO use get from hl ptr 
30ac 23					inc hl 
30ad 5e					ld e, (hl) 
30ae 23					inc hl 
30af 56					ld d, (hl) 
30b0 eb					ex de, hl 
30b1			 
30b1			 
30b1				if DEBUG_FORTH_WORDS 
30b1					DMARK "LSt" 
30b1 f5				push af  
30b2 3a c6 30			ld a, (.dmark)  
30b5 32 a6 fd			ld (debug_mark),a  
30b8 3a c7 30			ld a, (.dmark+1)  
30bb 32 a7 fd			ld (debug_mark+1),a  
30be 3a c8 30			ld a, (.dmark+2)  
30c1 32 a8 fd			ld (debug_mark+2),a  
30c4 18 03			jr .pastdmark  
30c6 ..			.dmark: db "LSt"  
30c9 f1			.pastdmark: pop af  
30ca			endm  
# End of macro DMARK
30ca					CALLMONITOR 
30ca cd aa fd			call debug_vector  
30cd				endm  
# End of macro CALLMONITOR
30cd				endif 
30cd			 
30cd			; cant push right now due to tokenised strings  
30cd			 
30cd			; get the destination of where to copy this definition to. 
30cd			 
30cd c5					push bc 
30ce d1					pop de 
30cf			 
30cf 7e			.listl:         ld a,(hl) 
30d0 fe 00				cp 0 
30d2 28 09				jr z, .lreplsp     ; replace zero with space 
30d4					;cp FORTH_END_BUFFER 
30d4 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
30d6 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
30d8				 
30d8					; just copy this char as is then 
30d8			 
30d8 12					ld (de), a 
30d9			 
30d9 23			.listnxt:	inc hl 
30da 13					inc de 
30db 18 f2				jr .listl 
30dd			 
30dd 3e 20		.lreplsp:	ld a,' ' 
30df 12					ld (de), a 
30e0 18 f7				jr .listnxt 
30e2			 
30e2			; close up uword def 
30e2			 
30e2			.listdone: 
30e2 12					ld (de), a 
30e3 13					inc de 
30e4 3e 00				ld a, 0 
30e6 12					ld (de), a 
30e7			 
30e7			; now have def so clean up and push to stack 
30e7			 
30e7 21 fc f0				ld hl, scratch 
30ea				if DEBUG_FORTH_WORDS 
30ea					DMARK "Ltp" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 a6 fd			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 a7 fd			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 a8 fd			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "Ltp"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103					CALLMONITOR 
3103 cd aa fd			call debug_vector  
3106				endm  
# End of macro CALLMONITOR
3106				endif 
3106			 
3106 18 1f			jr .listpush 
3108			 
3108			;.lnuword:	pop hl 
3108			;		call forth_tok_next 
3108			;		jp .ldouscan  
3108			 
3108			.lunotfound:		  
3108			 
3108				if DEBUG_FORTH_WORDS 
3108					DMARK "LSn" 
3108 f5				push af  
3109 3a 1d 31			ld a, (.dmark)  
310c 32 a6 fd			ld (debug_mark),a  
310f 3a 1e 31			ld a, (.dmark+1)  
3112 32 a7 fd			ld (debug_mark+1),a  
3115 3a 1f 31			ld a, (.dmark+2)  
3118 32 a8 fd			ld (debug_mark+2),a  
311b 18 03			jr .pastdmark  
311d ..			.dmark: db "LSn"  
3120 f1			.pastdmark: pop af  
3121			endm  
# End of macro DMARK
3121					CALLMONITOR 
3121 cd aa fd			call debug_vector  
3124				endm  
# End of macro CALLMONITOR
3124				endif 
3124			 
3124					 
3124			;		FORTH_DSP_POP 
3124			;		ld hl, .luno 
3124			 
3124					NEXTW			 
3124 c3 0f 26			jp macro_next 
3127				endm 
# End of macro NEXTW
3127			 
3127			.listpush: 
3127				if DEBUG_FORTH_WORDS 
3127					DMARK "LS>" 
3127 f5				push af  
3128 3a 3c 31			ld a, (.dmark)  
312b 32 a6 fd			ld (debug_mark),a  
312e 3a 3d 31			ld a, (.dmark+1)  
3131 32 a7 fd			ld (debug_mark+1),a  
3134 3a 3e 31			ld a, (.dmark+2)  
3137 32 a8 fd			ld (debug_mark+2),a  
313a 18 03			jr .pastdmark  
313c ..			.dmark: db "LS>"  
313f f1			.pastdmark: pop af  
3140			endm  
# End of macro DMARK
3140					CALLMONITOR 
3140 cd aa fd			call debug_vector  
3143				endm  
# End of macro CALLMONITOR
3143				endif 
3143 cd d0 22				call forth_push_str 
3146			 
3146			 
3146			 
3146					NEXTW 
3146 c3 0f 26			jp macro_next 
3149				endm 
# End of macro NEXTW
3149			 
3149			;.luno:    db "Word not found",0 
3149			 
3149			 
3149			 
3149			 
3149			 
3149			;		push hl   ; save pointer to start of uword def string 
3149			; 
3149			;; look for FORTH_EOL_LINE 
3149			;		ld a, FORTH_END_BUFFER 
3149			;		call strlent 
3149			; 
3149			;		inc hl		 ; space for coln def 
3149			;		inc hl 
3149			;		inc hl          ; space for terms 
3149			;		inc hl 
3149			; 
3149			;		ld a, 20   ; TODO get actual length 
3149			;		call addatohl    ; include a random amount of room for the uword name 
3149			; 
3149			;		 
3149			;	if DEBUG_FORTH_WORDS 
3149			;		DMARK "Lt1" 
3149			;		CALLMONITOR 
3149			;	endif 
3149			;		 
3149			; 
3149			;; malloc space for the string because we cant change it 
3149			; 
3149			;		call malloc 
3149			;	if DEBUG_FORTH_MALLOC_GUARD 
3149			;		push af 
3149			;		call ishlzero 
3149			;		pop af 
3149			;		 
3149			;		call z,malloc_error 
3149			;	endif 
3149			; 
3149			;	if DEBUG_FORTH_WORDS 
3149			;		DMARK "Lt2" 
3149			;		CALLMONITOR 
3149			;	endif 
3149			;		pop de 
3149			;		push hl    ; push the malloc to release later 
3149			;		push hl   ;  push back a copy for the later stack push 
3149			;		 
3149			;; copy the string swapping out the zero terms for spaces 
3149			; 
3149			;		; de has our source 
3149			;		; hl has our dest 
3149			; 
3149			;; add the coln def 
3149			; 
3149			;		ld a, ':' 
3149			;		ld (hl), a 
3149			;		inc hl 
3149			;		ld a, ' ' 
3149			;		ld (hl), a 
3149			;		inc hl 
3149			; 
3149			;; add the uname word 
3149			;		push de   ; save our string for now 
3149			;		ex de, hl 
3149			; 
3149			;		FORTH_DSP_VALUE 
3149			;		;v5 FORTH_DSP_VALUE 
3149			; 
3149			;		inc hl   ; skip type but we know by now this is OK 
3149			; 
3149			;.luword:	ld a,(hl) 
3149			;		cp 0 
3149			;		jr z, .luword2 
3149			;		ld (de), a 
3149			;		inc de 
3149			;		inc hl 
3149			;		jr .luword 
3149			; 
3149			;.luword2:	ld a, ' ' 
3149			;		ld (de), a 
3149			;;		inc hl 
3149			;;		inc de 
3149			;;		ld (de), a 
3149			;;		inc hl 
3149			;		inc de 
3149			; 
3149			;		ex de, hl 
3149			;		pop de 
3149			;		 
3149			;		 
3149			; 
3149			;; detoken that string and copy it 
3149			; 
3149			;	if DEBUG_FORTH_WORDS 
3149			;		DMARK "Lt2" 
3149			;		CALLMONITOR 
3149			;	endif 
3149			;.ldetok:	ld a, (de) 
3149			;		cp FORTH_END_BUFFER 
3149			;		jr z, .ldetokend 
3149			;		; swap out any zero term for space 
3149			;		cp 0 
3149			;		jr nz, .ldetoknext 
3149			;		ld a, ' ' 
3149			; 
3149			;	if DEBUG_FORTH_WORDS 
3149			;		DMARK "LtS" 
3149			;		CALLMONITOR 
3149			;	endif 
3149			;.ldetoknext:	ld (hl), a 
3149			;		inc de 
3149			;		inc hl 
3149			;		jr .ldetok 
3149			; 
3149			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
3149			;		ld (hl), a  
3149			; 
3149			;; free that temp malloc 
3149			; 
3149			;		pop hl    
3149			; 
3149			;	if DEBUG_FORTH_WORDS 
3149			;		DMARK "Lt4" 
3149			;		CALLMONITOR 
3149			;	endif 
3149			;		call forth_apushstrhl 
3149			; 
3149			;		; get rid of temp malloc area 
3149			; 
3149			;		pop hl 
3149			;		call free 
3149			; 
3149			;		jr .ludone 
3149			; 
3149			;.lnuword:	pop hl 
3149			;		call forth_tok_next 
3149			;		jp .ldouscan  
3149			; 
3149			;.ludone:		 pop hl 
3149			; 
3149					NEXTW 
3149 c3 0f 26			jp macro_next 
314c				endm 
# End of macro NEXTW
314c			 
314c			.FORGET: 
314c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
314c 5d				db WORD_SYS_CORE+73             
314d c5 31			dw .NOP            
314f 07				db 6 + 1 
3150 .. 00			db "FORGET",0              
3157				endm 
# End of macro CWHEAD
3157			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3157			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
3157			; | |  
3157			; | | e.g. "MORE" forget 
3157					if DEBUG_FORTH_WORDS_KEY 
3157						DMARK "FRG" 
3157 f5				push af  
3158 3a 6c 31			ld a, (.dmark)  
315b 32 a6 fd			ld (debug_mark),a  
315e 3a 6d 31			ld a, (.dmark+1)  
3161 32 a7 fd			ld (debug_mark+1),a  
3164 3a 6e 31			ld a, (.dmark+2)  
3167 32 a8 fd			ld (debug_mark+2),a  
316a 18 03			jr .pastdmark  
316c ..			.dmark: db "FRG"  
316f f1			.pastdmark: pop af  
3170			endm  
# End of macro DMARK
3170						CALLMONITOR 
3170 cd aa fd			call debug_vector  
3173				endm  
# End of macro CALLMONITOR
3173					endif 
3173			 
3173				; find uword 
3173			        ; update start of word with "_" 
3173				; replace uword with deleted flag 
3173			 
3173			 
3173			;	if DEBUG_FORTH_WORDS 
3173			;		DMARK "FOG" 
3173			;		CALLMONITOR 
3173			;	endif 
3173			 
3173			 
3173					; Get ptr to the word we need to look up 
3173			 
3173					FORTH_DSP_VALUEHL 
3173 cd 59 24			call macro_dsp_valuehl 
3176				endm 
# End of macro FORTH_DSP_VALUEHL
3176					;v5 FORTH_DSP_VALUE 
3176				; TODO type check 
3176			;		inc hl    ; Skip type check  
3176 e5					push hl 
3177 c1					pop bc 
3178			;		ex de, hl    ; put into DE 
3178			 
3178			 
3178 21 00 80				ld hl, baseram 
317b					;ld hl, baseusermem 
317b			 
317b				; skip dict stub 
317b			;	call forth_tok_next 
317b e5			push hl   ; sacreifical push 
317c			 
317c			.fldouscanm: 
317c e1				pop hl 
317d			.fldouscan: 
317d			;	if DEBUG_FORTH_WORDS 
317d			;		DMARK "LSs" 
317d			;		CALLMONITOR 
317d			;	endif 
317d				; skip dict stub 
317d cd 60 27				call forth_tok_next 
3180			 
3180			 
3180			; while we have words to look for 
3180			 
3180 7e				ld a, (hl)      
3181			;	if DEBUG_FORTH_WORDS 
3181			;		DMARK "LSk" 
3181			;		CALLMONITOR 
3181			;	endif 
3181 fe 00				cp WORD_SYS_END 
3183 ca bf 31				jp z, .flunotfound 
3186 fe 01				cp WORD_SYS_UWORD 
3188 c2 7d 31				jp nz, .fldouscan 
318b			 
318b			;	if DEBUG_FORTH_WORDS 
318b			;		DMARK "LSu" 
318b			;		CALLMONITOR 
318b			;	endif 
318b			 
318b					; found a uword but is it the one we want... 
318b			 
318b c5					push bc     ; uword to find is on bc 
318c d1					pop de 
318d			 
318d e5					push hl  ; to save the ptr 
318e			 
318e					; skip opcode 
318e 23					inc hl  
318f					; skip next ptr 
318f 23					inc hl  
3190 23					inc hl 
3191					; skip len 
3191 23					inc hl 
3192			 
3192			;	if DEBUG_FORTH_WORDS 
3192			;		DMARK "LSc" 
3192			;		CALLMONITOR 
3192			;	endif 
3192 cd c4 15				call strcmp 
3195 c2 7c 31				jp nz, .fldouscanm 
3198			; 
3198			; 
3198			;; while we have words to look for 
3198			; 
3198			;.fdouscan:	ld a, (hl)      
3198			;	if DEBUG_FORTH_WORDS 
3198			;		DMARK "LSs" 
3198			;		CALLMONITOR 
3198			;	endif 
3198			;		cp WORD_SYS_END 
3198			;		jp z, .fudone 
3198			;		cp WORD_SYS_UWORD 
3198			;		jp nz, .fnuword 
3198			; 
3198			;	if DEBUG_FORTH_WORDS 
3198			;		DMARK "FGu" 
3198			;		CALLMONITOR 
3198			;	endif 
3198			; 
3198			;		; found a uword but is it the one we want... 
3198			; 
3198			; 
3198			;	        pop de   ; get back the dsp name 
3198			;		push de 
3198			; 
3198			;		push hl  ; to save the ptr 
3198			; 
3198			;		; skip opcode 
3198			;		inc hl  
3198			;		; skip next ptr 
3198			;		inc hl  
3198			;		inc hl 
3198			;		; skip len 
3198			;		inc hl 
3198			; 
3198			;	if DEBUG_FORTH_WORDS 
3198			;		DMARK "FGc" 
3198			;		CALLMONITOR 
3198			;	endif 
3198			;		call strcmp 
3198			;		jp nz, .fnuword 
3198			 
3198			 
3198 e1			pop hl 
3199			 
3199				 
3199				if DEBUG_FORTH_WORDS 
3199					DMARK "FGm" 
3199 f5				push af  
319a 3a ae 31			ld a, (.dmark)  
319d 32 a6 fd			ld (debug_mark),a  
31a0 3a af 31			ld a, (.dmark+1)  
31a3 32 a7 fd			ld (debug_mark+1),a  
31a6 3a b0 31			ld a, (.dmark+2)  
31a9 32 a8 fd			ld (debug_mark+2),a  
31ac 18 03			jr .pastdmark  
31ae ..			.dmark: db "FGm"  
31b1 f1			.pastdmark: pop af  
31b2			endm  
# End of macro DMARK
31b2					CALLMONITOR 
31b2 cd aa fd			call debug_vector  
31b5				endm  
# End of macro CALLMONITOR
31b5				endif 
31b5			 
31b5			 
31b5			 
31b5					; we have a uword so push its name to the stack 
31b5			 
31b5			;	   	push hl  ; save so we can move to next dict block 
31b5			;pop hl 
31b5			 
31b5					; update opcode to deleted 
31b5 3e 03				ld a, WORD_SYS_DELETED 
31b7 77					ld (hl), a 
31b8			 
31b8 23					inc hl  
31b9					; skip next ptr 
31b9 23					inc hl  
31ba 23					inc hl 
31bb					; skip len 
31bb 23					inc hl 
31bc			 
31bc					; TODO change parser to skip deleted words but for now mark it out 
31bc 3e 5f				ld a, "_" 
31be 77					ld  (hl),a 
31bf			 
31bf			;		jr .fudone 
31bf			; 
31bf			;.fnuword:	pop hl 
31bf			;		call forth_tok_next 
31bf			;		jp .fdouscan  
31bf			 
31bf			.flunotfound:		  
31bf			 
31bf			 
31bf					 
31bf					FORTH_DSP_POP 
31bf cd 11 25			call macro_forth_dsp_pop 
31c2				endm 
# End of macro FORTH_DSP_POP
31c2			;		ld hl, .luno 
31c2			;.fudone:		 pop hl 
31c2					NEXTW 
31c2 c3 0f 26			jp macro_next 
31c5				endm 
# End of macro NEXTW
31c5			.NOP: 
31c5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
31c5 61				db WORD_SYS_CORE+77             
31c6 ec 31			dw .COMO            
31c8 04				db 3 + 1 
31c9 .. 00			db "NOP",0              
31cd				endm 
# End of macro CWHEAD
31cd			; | NOP (  --  ) Do nothing | DONE 
31cd					if DEBUG_FORTH_WORDS_KEY 
31cd						DMARK "NOP" 
31cd f5				push af  
31ce 3a e2 31			ld a, (.dmark)  
31d1 32 a6 fd			ld (debug_mark),a  
31d4 3a e3 31			ld a, (.dmark+1)  
31d7 32 a7 fd			ld (debug_mark+1),a  
31da 3a e4 31			ld a, (.dmark+2)  
31dd 32 a8 fd			ld (debug_mark+2),a  
31e0 18 03			jr .pastdmark  
31e2 ..			.dmark: db "NOP"  
31e5 f1			.pastdmark: pop af  
31e6			endm  
# End of macro DMARK
31e6						CALLMONITOR 
31e6 cd aa fd			call debug_vector  
31e9				endm  
# End of macro CALLMONITOR
31e9					endif 
31e9				       NEXTW 
31e9 c3 0f 26			jp macro_next 
31ec				endm 
# End of macro NEXTW
31ec			.COMO: 
31ec				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
31ec 6e				db WORD_SYS_CORE+90             
31ed 3e 32			dw .COMC            
31ef 02				db 1 + 1 
31f0 .. 00			db "(",0              
31f2				endm 
# End of macro CWHEAD
31f2			; | ( ( -- )  Start of comment | DONE 
31f2			 
31f2			 
31f2 2a fd f3				ld hl, ( os_tok_ptr) 
31f5 11 39 32			ld de, .closepar 
31f8					 
31f8					if DEBUG_FORTH_WORDS 
31f8						DMARK ").." 
31f8 f5				push af  
31f9 3a 0d 32			ld a, (.dmark)  
31fc 32 a6 fd			ld (debug_mark),a  
31ff 3a 0e 32			ld a, (.dmark+1)  
3202 32 a7 fd			ld (debug_mark+1),a  
3205 3a 0f 32			ld a, (.dmark+2)  
3208 32 a8 fd			ld (debug_mark+2),a  
320b 18 03			jr .pastdmark  
320d ..			.dmark: db ").."  
3210 f1			.pastdmark: pop af  
3211			endm  
# End of macro DMARK
3211						CALLMONITOR 
3211 cd aa fd			call debug_vector  
3214				endm  
# End of macro CALLMONITOR
3214					endif 
3214 cd 2a 27			call findnexttok  
3217			 
3217					if DEBUG_FORTH_WORDS 
3217						DMARK "IF5" 
3217 f5				push af  
3218 3a 2c 32			ld a, (.dmark)  
321b 32 a6 fd			ld (debug_mark),a  
321e 3a 2d 32			ld a, (.dmark+1)  
3221 32 a7 fd			ld (debug_mark+1),a  
3224 3a 2e 32			ld a, (.dmark+2)  
3227 32 a8 fd			ld (debug_mark+2),a  
322a 18 03			jr .pastdmark  
322c ..			.dmark: db "IF5"  
322f f1			.pastdmark: pop af  
3230			endm  
# End of macro DMARK
3230						CALLMONITOR 
3230 cd aa fd			call debug_vector  
3233				endm  
# End of macro CALLMONITOR
3233					endif 
3233				; replace below with ) exec using tok_ptr 
3233 22 fd f3			ld (os_tok_ptr), hl 
3236 c3 a0 26			jp exec1 
3239			 
3239 .. 00			.closepar:   db ")",0 
323b			 
323b				       NEXTW 
323b c3 0f 26			jp macro_next 
323e				endm 
# End of macro NEXTW
323e			.COMC: 
323e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
323e 6f				db WORD_SYS_CORE+91             
323f 47 32			dw .SCRATCH            
3241 02				db 1 + 1 
3242 .. 00			db ")",0              
3244				endm 
# End of macro CWHEAD
3244			; | ) ( -- )  End of comment |  DONE  
3244				       NEXTW 
3244 c3 0f 26			jp macro_next 
3247				endm 
# End of macro NEXTW
3247			 
3247			.SCRATCH: 
3247				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3247 6f				db WORD_SYS_CORE+91             
3248 82 32			dw .INC            
324a 08				db 7 + 1 
324b .. 00			db "SCRATCH",0              
3253				endm 
# End of macro CWHEAD
3253			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3253			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3253			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3253			; | |  
3253			; | | e.g.    : score $00 scratch ; 
3253			; | |  
3253			; | | $00 score ! 
3253			; | | $01 score +! 
3253			; | |  
3253			; | | e.g.   : varword $0a scratch ;  
3253			; | | 
3253			; | | $8000 varword ! 
3253					if DEBUG_FORTH_WORDS_KEY 
3253						DMARK "SCR" 
3253 f5				push af  
3254 3a 68 32			ld a, (.dmark)  
3257 32 a6 fd			ld (debug_mark),a  
325a 3a 69 32			ld a, (.dmark+1)  
325d 32 a7 fd			ld (debug_mark+1),a  
3260 3a 6a 32			ld a, (.dmark+2)  
3263 32 a8 fd			ld (debug_mark+2),a  
3266 18 03			jr .pastdmark  
3268 ..			.dmark: db "SCR"  
326b f1			.pastdmark: pop af  
326c			endm  
# End of macro DMARK
326c						CALLMONITOR 
326c cd aa fd			call debug_vector  
326f				endm  
# End of macro CALLMONITOR
326f					endif 
326f			 
326f					FORTH_DSP_VALUEHL 
326f cd 59 24			call macro_dsp_valuehl 
3272				endm 
# End of macro FORTH_DSP_VALUEHL
3272				 
3272					FORTH_DSP_POP 
3272 cd 11 25			call macro_forth_dsp_pop 
3275				endm 
# End of macro FORTH_DSP_POP
3275			 
3275 7d					ld a, l 
3276 21 21 f6				ld hl, os_var_array 
3279 cd cf 0f				call addatohl 
327c			 
327c cd 62 22				call forth_push_numhl 
327f			 
327f				       NEXTW 
327f c3 0f 26			jp macro_next 
3282				endm 
# End of macro NEXTW
3282			 
3282			.INC: 
3282				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3282 6f				db WORD_SYS_CORE+91             
3283 d8 32			dw .DEC            
3285 03				db 2 + 1 
3286 .. 00			db "+!",0              
3289				endm 
# End of macro CWHEAD
3289			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3289					if DEBUG_FORTH_WORDS_KEY 
3289						DMARK "+s_" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 a6 fd			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 a7 fd			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 a8 fd			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "+s_"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd aa fd			call debug_vector  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5			 
32a5					FORTH_DSP_VALUEHL 
32a5 cd 59 24			call macro_dsp_valuehl 
32a8				endm 
# End of macro FORTH_DSP_VALUEHL
32a8			 
32a8 e5					push hl   ; save address 
32a9			 
32a9					FORTH_DSP_POP 
32a9 cd 11 25			call macro_forth_dsp_pop 
32ac				endm 
# End of macro FORTH_DSP_POP
32ac			 
32ac					FORTH_DSP_VALUEHL 
32ac cd 59 24			call macro_dsp_valuehl 
32af				endm 
# End of macro FORTH_DSP_VALUEHL
32af			 
32af e5					push hl 
32b0					FORTH_DSP_POP 
32b0 cd 11 25			call macro_forth_dsp_pop 
32b3				endm 
# End of macro FORTH_DSP_POP
32b3 e1					pop hl 
32b4			 
32b4					; hl contains value to add to byte at a 
32b4				 
32b4 eb					ex de, hl 
32b5			 
32b5 e1					pop hl 
32b6			 
32b6					if DEBUG_FORTH_WORDS 
32b6						DMARK "INC" 
32b6 f5				push af  
32b7 3a cb 32			ld a, (.dmark)  
32ba 32 a6 fd			ld (debug_mark),a  
32bd 3a cc 32			ld a, (.dmark+1)  
32c0 32 a7 fd			ld (debug_mark+1),a  
32c3 3a cd 32			ld a, (.dmark+2)  
32c6 32 a8 fd			ld (debug_mark+2),a  
32c9 18 03			jr .pastdmark  
32cb ..			.dmark: db "INC"  
32ce f1			.pastdmark: pop af  
32cf			endm  
# End of macro DMARK
32cf						CALLMONITOR 
32cf cd aa fd			call debug_vector  
32d2				endm  
# End of macro CALLMONITOR
32d2					endif 
32d2			 
32d2 7e					ld a,(hl) 
32d3 83					add e 
32d4 77					ld (hl),a 
32d5			 
32d5			 
32d5			 
32d5				       NEXTW 
32d5 c3 0f 26			jp macro_next 
32d8				endm 
# End of macro NEXTW
32d8			 
32d8			.DEC: 
32d8				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
32d8 6f				db WORD_SYS_CORE+91             
32d9 2c 33			dw .INC2            
32db 03				db 2 + 1 
32dc .. 00			db "-!",0              
32df				endm 
# End of macro CWHEAD
32df			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
32df					if DEBUG_FORTH_WORDS_KEY 
32df						DMARK "-s_" 
32df f5				push af  
32e0 3a f4 32			ld a, (.dmark)  
32e3 32 a6 fd			ld (debug_mark),a  
32e6 3a f5 32			ld a, (.dmark+1)  
32e9 32 a7 fd			ld (debug_mark+1),a  
32ec 3a f6 32			ld a, (.dmark+2)  
32ef 32 a8 fd			ld (debug_mark+2),a  
32f2 18 03			jr .pastdmark  
32f4 ..			.dmark: db "-s_"  
32f7 f1			.pastdmark: pop af  
32f8			endm  
# End of macro DMARK
32f8						CALLMONITOR 
32f8 cd aa fd			call debug_vector  
32fb				endm  
# End of macro CALLMONITOR
32fb					endif 
32fb			 
32fb					FORTH_DSP_VALUEHL 
32fb cd 59 24			call macro_dsp_valuehl 
32fe				endm 
# End of macro FORTH_DSP_VALUEHL
32fe			 
32fe e5					push hl   ; save address 
32ff			 
32ff					FORTH_DSP_POP 
32ff cd 11 25			call macro_forth_dsp_pop 
3302				endm 
# End of macro FORTH_DSP_POP
3302			 
3302					FORTH_DSP_VALUEHL 
3302 cd 59 24			call macro_dsp_valuehl 
3305				endm 
# End of macro FORTH_DSP_VALUEHL
3305			 
3305					; hl contains value to add to byte at a 
3305				 
3305 eb					ex de, hl 
3306			 
3306 e1					pop hl 
3307			 
3307					if DEBUG_FORTH_WORDS 
3307						DMARK "DEC" 
3307 f5				push af  
3308 3a 1c 33			ld a, (.dmark)  
330b 32 a6 fd			ld (debug_mark),a  
330e 3a 1d 33			ld a, (.dmark+1)  
3311 32 a7 fd			ld (debug_mark+1),a  
3314 3a 1e 33			ld a, (.dmark+2)  
3317 32 a8 fd			ld (debug_mark+2),a  
331a 18 03			jr .pastdmark  
331c ..			.dmark: db "DEC"  
331f f1			.pastdmark: pop af  
3320			endm  
# End of macro DMARK
3320						CALLMONITOR 
3320 cd aa fd			call debug_vector  
3323				endm  
# End of macro CALLMONITOR
3323					endif 
3323			 
3323 7e					ld a,(hl) 
3324 93					sub e 
3325 77					ld (hl),a 
3326			 
3326			 
3326					FORTH_DSP_POP 
3326 cd 11 25			call macro_forth_dsp_pop 
3329				endm 
# End of macro FORTH_DSP_POP
3329			 
3329				       NEXTW 
3329 c3 0f 26			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			 
332c			.INC2: 
332c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
332c 6f				db WORD_SYS_CORE+91             
332d d9 33			dw .DEC2            
332f 04				db 3 + 1 
3330 .. 00			db "+2!",0              
3334				endm 
# End of macro CWHEAD
3334			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3334			 
3334					if DEBUG_FORTH_WORDS_KEY 
3334						DMARK "+2s" 
3334 f5				push af  
3335 3a 49 33			ld a, (.dmark)  
3338 32 a6 fd			ld (debug_mark),a  
333b 3a 4a 33			ld a, (.dmark+1)  
333e 32 a7 fd			ld (debug_mark+1),a  
3341 3a 4b 33			ld a, (.dmark+2)  
3344 32 a8 fd			ld (debug_mark+2),a  
3347 18 03			jr .pastdmark  
3349 ..			.dmark: db "+2s"  
334c f1			.pastdmark: pop af  
334d			endm  
# End of macro DMARK
334d						CALLMONITOR 
334d cd aa fd			call debug_vector  
3350				endm  
# End of macro CALLMONITOR
3350					endif 
3350			 
3350					; Address 
3350			 
3350					FORTH_DSP_VALUEHL 
3350 cd 59 24			call macro_dsp_valuehl 
3353				endm 
# End of macro FORTH_DSP_VALUEHL
3353			 
3353 e5					push hl    ; save address 
3354			 
3354					; load content into de 
3354			 
3354 5e					ld e,(hl) 
3355 23					inc hl 
3356 56					ld d, (hl) 
3357			 
3357					if DEBUG_FORTH_WORDS 
3357						DMARK "+2a" 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 a6 fd			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 a7 fd			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 a8 fd			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "+2a"  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd aa fd			call debug_vector  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373			 
3373					FORTH_DSP_POP 
3373 cd 11 25			call macro_forth_dsp_pop 
3376				endm 
# End of macro FORTH_DSP_POP
3376			 
3376					; Get value to add 
3376			 
3376					FORTH_DSP_VALUE 
3376 cd 42 24			call macro_forth_dsp_value 
3379				endm 
# End of macro FORTH_DSP_VALUE
3379			 
3379					if DEBUG_FORTH_WORDS 
3379						DMARK "+2v" 
3379 f5				push af  
337a 3a 8e 33			ld a, (.dmark)  
337d 32 a6 fd			ld (debug_mark),a  
3380 3a 8f 33			ld a, (.dmark+1)  
3383 32 a7 fd			ld (debug_mark+1),a  
3386 3a 90 33			ld a, (.dmark+2)  
3389 32 a8 fd			ld (debug_mark+2),a  
338c 18 03			jr .pastdmark  
338e ..			.dmark: db "+2v"  
3391 f1			.pastdmark: pop af  
3392			endm  
# End of macro DMARK
3392						CALLMONITOR 
3392 cd aa fd			call debug_vector  
3395				endm  
# End of macro CALLMONITOR
3395					endif 
3395			 
3395 19					add hl, de 
3396			 
3396					if DEBUG_FORTH_WORDS 
3396						DMARK "+2+" 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 a6 fd			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 a7 fd			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 a8 fd			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "+2+"  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd aa fd			call debug_vector  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2			 
33b2					; move result to de 
33b2			 
33b2 eb					ex de, hl 
33b3			 
33b3					; Address 
33b3			 
33b3 e1					pop hl 
33b4			 
33b4					; save it back 
33b4			 
33b4 73					ld (hl), e 
33b5 23					inc hl 
33b6 72					ld (hl), d 
33b7			 
33b7					if DEBUG_FORTH_WORDS 
33b7						DMARK "+2e" 
33b7 f5				push af  
33b8 3a cc 33			ld a, (.dmark)  
33bb 32 a6 fd			ld (debug_mark),a  
33be 3a cd 33			ld a, (.dmark+1)  
33c1 32 a7 fd			ld (debug_mark+1),a  
33c4 3a ce 33			ld a, (.dmark+2)  
33c7 32 a8 fd			ld (debug_mark+2),a  
33ca 18 03			jr .pastdmark  
33cc ..			.dmark: db "+2e"  
33cf f1			.pastdmark: pop af  
33d0			endm  
# End of macro DMARK
33d0						CALLMONITOR 
33d0 cd aa fd			call debug_vector  
33d3				endm  
# End of macro CALLMONITOR
33d3					endif 
33d3			 
33d3			 
33d3			 
33d3					FORTH_DSP_POP 
33d3 cd 11 25			call macro_forth_dsp_pop 
33d6				endm 
# End of macro FORTH_DSP_POP
33d6			 
33d6			 
33d6				       NEXTW 
33d6 c3 0f 26			jp macro_next 
33d9				endm 
# End of macro NEXTW
33d9			 
33d9			.DEC2: 
33d9				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
33d9 6f				db WORD_SYS_CORE+91             
33da 88 34			dw .GET2            
33dc 04				db 3 + 1 
33dd .. 00			db "-2!",0              
33e1				endm 
# End of macro CWHEAD
33e1			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
33e1			 
33e1			 
33e1					if DEBUG_FORTH_WORDS_KEY 
33e1						DMARK "-2s" 
33e1 f5				push af  
33e2 3a f6 33			ld a, (.dmark)  
33e5 32 a6 fd			ld (debug_mark),a  
33e8 3a f7 33			ld a, (.dmark+1)  
33eb 32 a7 fd			ld (debug_mark+1),a  
33ee 3a f8 33			ld a, (.dmark+2)  
33f1 32 a8 fd			ld (debug_mark+2),a  
33f4 18 03			jr .pastdmark  
33f6 ..			.dmark: db "-2s"  
33f9 f1			.pastdmark: pop af  
33fa			endm  
# End of macro DMARK
33fa						CALLMONITOR 
33fa cd aa fd			call debug_vector  
33fd				endm  
# End of macro CALLMONITOR
33fd					endif 
33fd			 
33fd					; Address 
33fd			 
33fd					FORTH_DSP_VALUEHL 
33fd cd 59 24			call macro_dsp_valuehl 
3400				endm 
# End of macro FORTH_DSP_VALUEHL
3400			 
3400 e5					push hl    ; save address 
3401			 
3401					; load content into de 
3401			 
3401 5e					ld e,(hl) 
3402 23					inc hl 
3403 56					ld d, (hl) 
3404			 
3404					if DEBUG_FORTH_WORDS 
3404						DMARK "-2a" 
3404 f5				push af  
3405 3a 19 34			ld a, (.dmark)  
3408 32 a6 fd			ld (debug_mark),a  
340b 3a 1a 34			ld a, (.dmark+1)  
340e 32 a7 fd			ld (debug_mark+1),a  
3411 3a 1b 34			ld a, (.dmark+2)  
3414 32 a8 fd			ld (debug_mark+2),a  
3417 18 03			jr .pastdmark  
3419 ..			.dmark: db "-2a"  
341c f1			.pastdmark: pop af  
341d			endm  
# End of macro DMARK
341d						CALLMONITOR 
341d cd aa fd			call debug_vector  
3420				endm  
# End of macro CALLMONITOR
3420					endif 
3420			 
3420					FORTH_DSP_POP 
3420 cd 11 25			call macro_forth_dsp_pop 
3423				endm 
# End of macro FORTH_DSP_POP
3423			 
3423					; Get value to remove 
3423			 
3423					FORTH_DSP_VALUE 
3423 cd 42 24			call macro_forth_dsp_value 
3426				endm 
# End of macro FORTH_DSP_VALUE
3426			 
3426					if DEBUG_FORTH_WORDS 
3426						DMARK "-2v" 
3426 f5				push af  
3427 3a 3b 34			ld a, (.dmark)  
342a 32 a6 fd			ld (debug_mark),a  
342d 3a 3c 34			ld a, (.dmark+1)  
3430 32 a7 fd			ld (debug_mark+1),a  
3433 3a 3d 34			ld a, (.dmark+2)  
3436 32 a8 fd			ld (debug_mark+2),a  
3439 18 03			jr .pastdmark  
343b ..			.dmark: db "-2v"  
343e f1			.pastdmark: pop af  
343f			endm  
# End of macro DMARK
343f						CALLMONITOR 
343f cd aa fd			call debug_vector  
3442				endm  
# End of macro CALLMONITOR
3442					endif 
3442			 
3442 eb					ex de, hl 
3443 ed 52				sbc hl, de 
3445			 
3445					if DEBUG_FORTH_WORDS 
3445						DMARK "-2d" 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 a6 fd			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 a7 fd			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 a8 fd			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "-2d"  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						CALLMONITOR 
345e cd aa fd			call debug_vector  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			 
3461					; move result to de 
3461			 
3461 eb					ex de, hl 
3462			 
3462					; Address 
3462			 
3462 e1					pop hl 
3463			 
3463					; save it back 
3463			 
3463 73					ld (hl), e 
3464 23					inc hl 
3465 72					ld (hl), d 
3466			 
3466					if DEBUG_FORTH_WORDS 
3466						DMARK "-2e" 
3466 f5				push af  
3467 3a 7b 34			ld a, (.dmark)  
346a 32 a6 fd			ld (debug_mark),a  
346d 3a 7c 34			ld a, (.dmark+1)  
3470 32 a7 fd			ld (debug_mark+1),a  
3473 3a 7d 34			ld a, (.dmark+2)  
3476 32 a8 fd			ld (debug_mark+2),a  
3479 18 03			jr .pastdmark  
347b ..			.dmark: db "-2e"  
347e f1			.pastdmark: pop af  
347f			endm  
# End of macro DMARK
347f						CALLMONITOR 
347f cd aa fd			call debug_vector  
3482				endm  
# End of macro CALLMONITOR
3482					endif 
3482			 
3482			 
3482					FORTH_DSP_POP 
3482 cd 11 25			call macro_forth_dsp_pop 
3485				endm 
# End of macro FORTH_DSP_POP
3485			 
3485			 
3485			 
3485				       NEXTW 
3485 c3 0f 26			jp macro_next 
3488				endm 
# End of macro NEXTW
3488			.GET2: 
3488				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3488 6f				db WORD_SYS_CORE+91             
3489 bd 34			dw .BANG2            
348b 03				db 2 + 1 
348c .. 00			db "2@",0              
348f				endm 
# End of macro CWHEAD
348f			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
348f					if DEBUG_FORTH_WORDS_KEY 
348f						DMARK "2A_" 
348f f5				push af  
3490 3a a4 34			ld a, (.dmark)  
3493 32 a6 fd			ld (debug_mark),a  
3496 3a a5 34			ld a, (.dmark+1)  
3499 32 a7 fd			ld (debug_mark+1),a  
349c 3a a6 34			ld a, (.dmark+2)  
349f 32 a8 fd			ld (debug_mark+2),a  
34a2 18 03			jr .pastdmark  
34a4 ..			.dmark: db "2A_"  
34a7 f1			.pastdmark: pop af  
34a8			endm  
# End of macro DMARK
34a8						CALLMONITOR 
34a8 cd aa fd			call debug_vector  
34ab				endm  
# End of macro CALLMONITOR
34ab					endif 
34ab			 
34ab					FORTH_DSP_VALUEHL 
34ab cd 59 24			call macro_dsp_valuehl 
34ae				endm 
# End of macro FORTH_DSP_VALUEHL
34ae			 
34ae e5					push hl   ; save address 
34af			 
34af					FORTH_DSP_POP 
34af cd 11 25			call macro_forth_dsp_pop 
34b2				endm 
# End of macro FORTH_DSP_POP
34b2			 
34b2 e1					pop hl 
34b3			 
34b3 5e					ld e, (hl) 
34b4 23					inc hl 
34b5 56					ld d, (hl) 
34b6			 
34b6 eb					ex de, hl 
34b7			 
34b7 cd 62 22				call forth_push_numhl 
34ba			 
34ba				       NEXTW 
34ba c3 0f 26			jp macro_next 
34bd				endm 
# End of macro NEXTW
34bd			.BANG2: 
34bd				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
34bd 6f				db WORD_SYS_CORE+91             
34be f5 34			dw .CONFIG            
34c0 03				db 2 + 1 
34c1 .. 00			db "2!",0              
34c4				endm 
# End of macro CWHEAD
34c4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
34c4					if DEBUG_FORTH_WORDS_KEY 
34c4						DMARK "2S_" 
34c4 f5				push af  
34c5 3a d9 34			ld a, (.dmark)  
34c8 32 a6 fd			ld (debug_mark),a  
34cb 3a da 34			ld a, (.dmark+1)  
34ce 32 a7 fd			ld (debug_mark+1),a  
34d1 3a db 34			ld a, (.dmark+2)  
34d4 32 a8 fd			ld (debug_mark+2),a  
34d7 18 03			jr .pastdmark  
34d9 ..			.dmark: db "2S_"  
34dc f1			.pastdmark: pop af  
34dd			endm  
# End of macro DMARK
34dd						CALLMONITOR 
34dd cd aa fd			call debug_vector  
34e0				endm  
# End of macro CALLMONITOR
34e0					endif 
34e0			 
34e0					FORTH_DSP_VALUEHL 
34e0 cd 59 24			call macro_dsp_valuehl 
34e3				endm 
# End of macro FORTH_DSP_VALUEHL
34e3			 
34e3 e5					push hl   ; save address 
34e4			 
34e4			 
34e4					FORTH_DSP_POP 
34e4 cd 11 25			call macro_forth_dsp_pop 
34e7				endm 
# End of macro FORTH_DSP_POP
34e7			 
34e7					 
34e7					FORTH_DSP_VALUEHL 
34e7 cd 59 24			call macro_dsp_valuehl 
34ea				endm 
# End of macro FORTH_DSP_VALUEHL
34ea			 
34ea					FORTH_DSP_POP 
34ea cd 11 25			call macro_forth_dsp_pop 
34ed				endm 
# End of macro FORTH_DSP_POP
34ed			 
34ed eb					ex de, hl    ; value now in de 
34ee			 
34ee e1					pop hl 
34ef			 
34ef 73					ld (hl), e 
34f0			 
34f0 23					inc hl 
34f1			 
34f1 72					ld (hl), d 
34f2			 
34f2			 
34f2				       NEXTW 
34f2 c3 0f 26			jp macro_next 
34f5				endm 
# End of macro NEXTW
34f5			.CONFIG: 
34f5				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
34f5 6f				db WORD_SYS_CORE+91             
34f6 06 35			dw .ADTOS            
34f8 07				db 6 + 1 
34f9 .. 00			db "CONFIG",0              
3500				endm 
# End of macro CWHEAD
3500			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3500			 
3500 cd 9a 17				call config 
3503					NEXTW 
3503 c3 0f 26			jp macro_next 
3506				endm 
# End of macro NEXTW
3506			 
3506			.ADTOS: 
3506				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3506 6f				db WORD_SYS_CORE+91             
3507 1c 35			dw .SBTOS            
3509 03				db 2 + 1 
350a .. 00			db "1+",0              
350d				endm 
# End of macro CWHEAD
350d			; | 1+ ( u -- u )  Increment value on TOS | DONE 
350d			 
350d					FORTH_DSP_VALUEHL 
350d cd 59 24			call macro_dsp_valuehl 
3510				endm 
# End of macro FORTH_DSP_VALUEHL
3510 e5					push hl 
3511			 
3511					FORTH_DSP_POP 
3511 cd 11 25			call macro_forth_dsp_pop 
3514				endm 
# End of macro FORTH_DSP_POP
3514 e1					pop hl 
3515			 
3515 23					inc hl 
3516 cd 62 22				call forth_push_numhl 
3519					 
3519					NEXTW 
3519 c3 0f 26			jp macro_next 
351c				endm 
# End of macro NEXTW
351c			.SBTOS: 
351c				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
351c 6f				db WORD_SYS_CORE+91             
351d 32 35			dw .ADSTORE            
351f 03				db 2 + 1 
3520 .. 00			db "1-",0              
3523				endm 
# End of macro CWHEAD
3523			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3523			 
3523					FORTH_DSP_VALUEHL 
3523 cd 59 24			call macro_dsp_valuehl 
3526				endm 
# End of macro FORTH_DSP_VALUEHL
3526 e5					push hl 
3527			 
3527					FORTH_DSP_POP 
3527 cd 11 25			call macro_forth_dsp_pop 
352a				endm 
# End of macro FORTH_DSP_POP
352a e1					pop hl 
352b			 
352b 2b					dec hl 
352c cd 62 22				call forth_push_numhl 
352f					 
352f					NEXTW 
352f c3 0f 26			jp macro_next 
3532				endm 
# End of macro NEXTW
3532			.ADSTORE: 
3532				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3532 6f				db WORD_SYS_CORE+91             
3533 48 35			dw .ADWSTORE            
3535 04				db 3 + 1 
3536 .. 00			db "1+!",0              
353a				endm 
# End of macro CWHEAD
353a			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
353a			 
353a					FORTH_DSP_VALUEHL 
353a cd 59 24			call macro_dsp_valuehl 
353d				endm 
# End of macro FORTH_DSP_VALUEHL
353d e5					push hl 
353e			 
353e					FORTH_DSP_POP 
353e cd 11 25			call macro_forth_dsp_pop 
3541				endm 
# End of macro FORTH_DSP_POP
3541 e1					pop hl 
3542			 
3542 7e					ld a, (hl) 
3543 3c					inc a 
3544 77					ld (hl), a 
3545					 
3545					NEXTW 
3545 c3 0f 26			jp macro_next 
3548				endm 
# End of macro NEXTW
3548			.ADWSTORE: 
3548				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3548 6f				db WORD_SYS_CORE+91             
3549 66 35			dw .SBSTORE            
354b 05				db 4 + 1 
354c .. 00			db "1+2!",0              
3551				endm 
# End of macro CWHEAD
3551			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3551			 
3551					FORTH_DSP_VALUEHL 
3551 cd 59 24			call macro_dsp_valuehl 
3554				endm 
# End of macro FORTH_DSP_VALUEHL
3554 e5					push hl 
3555			 
3555					FORTH_DSP_POP 
3555 cd 11 25			call macro_forth_dsp_pop 
3558				endm 
# End of macro FORTH_DSP_POP
3558 e1					pop hl 
3559			 
3559 e5					push hl 
355a			 
355a cd 91 25				call loadwordinhl 
355d 23					inc hl 
355e			 
355e d1					pop de 
355f eb					ex de, hl 
3560 73					ld (hl), e 
3561 23					inc hl 
3562 72					ld (hl), d 
3563					 
3563					NEXTW 
3563 c3 0f 26			jp macro_next 
3566				endm 
# End of macro NEXTW
3566			.SBSTORE: 
3566				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3566 6f				db WORD_SYS_CORE+91             
3567 7c 35			dw .SBWSTORE            
3569 04				db 3 + 1 
356a .. 00			db "1-!",0              
356e				endm 
# End of macro CWHEAD
356e			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
356e			 
356e					FORTH_DSP_VALUEHL 
356e cd 59 24			call macro_dsp_valuehl 
3571				endm 
# End of macro FORTH_DSP_VALUEHL
3571 e5					push hl 
3572			 
3572					FORTH_DSP_POP 
3572 cd 11 25			call macro_forth_dsp_pop 
3575				endm 
# End of macro FORTH_DSP_POP
3575 e1					pop hl 
3576			 
3576 7e					ld a, (hl) 
3577 3d					dec a 
3578 77					ld (hl), a 
3579					 
3579					NEXTW 
3579 c3 0f 26			jp macro_next 
357c				endm 
# End of macro NEXTW
357c			.SBWSTORE: 
357c				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
357c 6f				db WORD_SYS_CORE+91             
357d 9a 35			dw .ENDCORE            
357f 05				db 4 + 1 
3580 .. 00			db "1-2!",0              
3585				endm 
# End of macro CWHEAD
3585			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3585			 
3585					FORTH_DSP_VALUEHL 
3585 cd 59 24			call macro_dsp_valuehl 
3588				endm 
# End of macro FORTH_DSP_VALUEHL
3588 e5					push hl 
3589			 
3589					FORTH_DSP_POP 
3589 cd 11 25			call macro_forth_dsp_pop 
358c				endm 
# End of macro FORTH_DSP_POP
358c e1					pop hl 
358d			 
358d e5					push hl 
358e			 
358e cd 91 25				call loadwordinhl 
3591 2b					dec hl 
3592			 
3592 d1					pop de 
3593 eb					ex de, hl 
3594 73					ld (hl), e 
3595 23					inc hl 
3596 72					ld (hl), d 
3597					 
3597					NEXTW 
3597 c3 0f 26			jp macro_next 
359a				endm 
# End of macro NEXTW
359a			.ENDCORE: 
359a			 
359a			; eof 
359a			 
359a			 
# End of file forth_words_core.asm
359a			include "forth_words_flow.asm" 
359a			 
359a			; | ## Program Flow Words 
359a			 
359a			.IF: 
359a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
359a 1e				db WORD_SYS_CORE+10             
359b 8f 36			dw .THEN            
359d 03				db 2 + 1 
359e .. 00			db "IF",0              
35a1				endm 
# End of macro CWHEAD
35a1			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
35a1			; 
35a1					if DEBUG_FORTH_WORDS_KEY 
35a1						DMARK "IF." 
35a1 f5				push af  
35a2 3a b6 35			ld a, (.dmark)  
35a5 32 a6 fd			ld (debug_mark),a  
35a8 3a b7 35			ld a, (.dmark+1)  
35ab 32 a7 fd			ld (debug_mark+1),a  
35ae 3a b8 35			ld a, (.dmark+2)  
35b1 32 a8 fd			ld (debug_mark+2),a  
35b4 18 03			jr .pastdmark  
35b6 ..			.dmark: db "IF."  
35b9 f1			.pastdmark: pop af  
35ba			endm  
# End of macro DMARK
35ba						CALLMONITOR 
35ba cd aa fd			call debug_vector  
35bd				endm  
# End of macro CALLMONITOR
35bd					endif 
35bd			; eval TOS 
35bd			 
35bd				FORTH_DSP_VALUEHL 
35bd cd 59 24			call macro_dsp_valuehl 
35c0				endm 
# End of macro FORTH_DSP_VALUEHL
35c0			 
35c0			;	push hl 
35c0				FORTH_DSP_POP 
35c0 cd 11 25			call macro_forth_dsp_pop 
35c3				endm 
# End of macro FORTH_DSP_POP
35c3			;	pop hl 
35c3			 
35c3					if DEBUG_FORTH_WORDS 
35c3						DMARK "IF1" 
35c3 f5				push af  
35c4 3a d8 35			ld a, (.dmark)  
35c7 32 a6 fd			ld (debug_mark),a  
35ca 3a d9 35			ld a, (.dmark+1)  
35cd 32 a7 fd			ld (debug_mark+1),a  
35d0 3a da 35			ld a, (.dmark+2)  
35d3 32 a8 fd			ld (debug_mark+2),a  
35d6 18 03			jr .pastdmark  
35d8 ..			.dmark: db "IF1"  
35db f1			.pastdmark: pop af  
35dc			endm  
# End of macro DMARK
35dc						CALLMONITOR 
35dc cd aa fd			call debug_vector  
35df				endm  
# End of macro CALLMONITOR
35df					endif 
35df b7				or a        ; clear carry flag 
35e0 11 00 00			ld de, 0 
35e3 eb				ex de,hl 
35e4 ed 52			sbc hl, de 
35e6 c2 70 36			jp nz, .iftrue 
35e9			 
35e9					if DEBUG_FORTH_WORDS 
35e9						DMARK "IF2" 
35e9 f5				push af  
35ea 3a fe 35			ld a, (.dmark)  
35ed 32 a6 fd			ld (debug_mark),a  
35f0 3a ff 35			ld a, (.dmark+1)  
35f3 32 a7 fd			ld (debug_mark+1),a  
35f6 3a 00 36			ld a, (.dmark+2)  
35f9 32 a8 fd			ld (debug_mark+2),a  
35fc 18 03			jr .pastdmark  
35fe ..			.dmark: db "IF2"  
3601 f1			.pastdmark: pop af  
3602			endm  
# End of macro DMARK
3602						CALLMONITOR 
3602 cd aa fd			call debug_vector  
3605				endm  
# End of macro CALLMONITOR
3605					endif 
3605			 
3605			; if not true then skip to THEN 
3605			 
3605				; TODO get tok_ptr 
3605				; TODO consume toks until we get to THEN 
3605			 
3605 2a fd f3			ld hl, (os_tok_ptr) 
3608					if DEBUG_FORTH_WORDS 
3608						DMARK "IF3" 
3608 f5				push af  
3609 3a 1d 36			ld a, (.dmark)  
360c 32 a6 fd			ld (debug_mark),a  
360f 3a 1e 36			ld a, (.dmark+1)  
3612 32 a7 fd			ld (debug_mark+1),a  
3615 3a 1f 36			ld a, (.dmark+2)  
3618 32 a8 fd			ld (debug_mark+2),a  
361b 18 03			jr .pastdmark  
361d ..			.dmark: db "IF3"  
3620 f1			.pastdmark: pop af  
3621			endm  
# End of macro DMARK
3621						CALLMONITOR 
3621 cd aa fd			call debug_vector  
3624				endm  
# End of macro CALLMONITOR
3624						 
3624					endif 
3624 11 6b 36			ld de, .ifthen 
3627					if DEBUG_FORTH_WORDS 
3627						DMARK "IF4" 
3627 f5				push af  
3628 3a 3c 36			ld a, (.dmark)  
362b 32 a6 fd			ld (debug_mark),a  
362e 3a 3d 36			ld a, (.dmark+1)  
3631 32 a7 fd			ld (debug_mark+1),a  
3634 3a 3e 36			ld a, (.dmark+2)  
3637 32 a8 fd			ld (debug_mark+2),a  
363a 18 03			jr .pastdmark  
363c ..			.dmark: db "IF4"  
363f f1			.pastdmark: pop af  
3640			endm  
# End of macro DMARK
3640						CALLMONITOR 
3640 cd aa fd			call debug_vector  
3643				endm  
# End of macro CALLMONITOR
3643					endif 
3643 cd 2a 27			call findnexttok  
3646			 
3646					if DEBUG_FORTH_WORDS 
3646						DMARK "IF5" 
3646 f5				push af  
3647 3a 5b 36			ld a, (.dmark)  
364a 32 a6 fd			ld (debug_mark),a  
364d 3a 5c 36			ld a, (.dmark+1)  
3650 32 a7 fd			ld (debug_mark+1),a  
3653 3a 5d 36			ld a, (.dmark+2)  
3656 32 a8 fd			ld (debug_mark+2),a  
3659 18 03			jr .pastdmark  
365b ..			.dmark: db "IF5"  
365e f1			.pastdmark: pop af  
365f			endm  
# End of macro DMARK
365f						CALLMONITOR 
365f cd aa fd			call debug_vector  
3662				endm  
# End of macro CALLMONITOR
3662					endif 
3662				; TODO replace below with ; exec using tok_ptr 
3662 22 fd f3			ld (os_tok_ptr), hl 
3665 c3 a0 26			jp exec1 
3668				NEXTW 
3668 c3 0f 26			jp macro_next 
366b				endm 
# End of macro NEXTW
366b			 
366b .. 00		.ifthen:  db "THEN",0 
3670			 
3670			.iftrue:		 
3670				; Exec next words normally 
3670			 
3670				; if true then exec following IF as normal 
3670					if DEBUG_FORTH_WORDS 
3670						DMARK "IFT" 
3670 f5				push af  
3671 3a 85 36			ld a, (.dmark)  
3674 32 a6 fd			ld (debug_mark),a  
3677 3a 86 36			ld a, (.dmark+1)  
367a 32 a7 fd			ld (debug_mark+1),a  
367d 3a 87 36			ld a, (.dmark+2)  
3680 32 a8 fd			ld (debug_mark+2),a  
3683 18 03			jr .pastdmark  
3685 ..			.dmark: db "IFT"  
3688 f1			.pastdmark: pop af  
3689			endm  
# End of macro DMARK
3689						CALLMONITOR 
3689 cd aa fd			call debug_vector  
368c				endm  
# End of macro CALLMONITOR
368c					endif 
368c			 
368c					NEXTW 
368c c3 0f 26			jp macro_next 
368f				endm 
# End of macro NEXTW
368f			.THEN: 
368f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
368f 1f				db WORD_SYS_CORE+11             
3690 b7 36			dw .ELSE            
3692 05				db 4 + 1 
3693 .. 00			db "THEN",0              
3698				endm 
# End of macro CWHEAD
3698			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3698					if DEBUG_FORTH_WORDS_KEY 
3698						DMARK "THN" 
3698 f5				push af  
3699 3a ad 36			ld a, (.dmark)  
369c 32 a6 fd			ld (debug_mark),a  
369f 3a ae 36			ld a, (.dmark+1)  
36a2 32 a7 fd			ld (debug_mark+1),a  
36a5 3a af 36			ld a, (.dmark+2)  
36a8 32 a8 fd			ld (debug_mark+2),a  
36ab 18 03			jr .pastdmark  
36ad ..			.dmark: db "THN"  
36b0 f1			.pastdmark: pop af  
36b1			endm  
# End of macro DMARK
36b1						CALLMONITOR 
36b1 cd aa fd			call debug_vector  
36b4				endm  
# End of macro CALLMONITOR
36b4					endif 
36b4					NEXTW 
36b4 c3 0f 26			jp macro_next 
36b7				endm 
# End of macro NEXTW
36b7			.ELSE: 
36b7				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
36b7 20				db WORD_SYS_CORE+12             
36b8 df 36			dw .DO            
36ba 03				db 2 + 1 
36bb .. 00			db "ELSE",0              
36c0				endm 
# End of macro CWHEAD
36c0			; | ELSE ( -- ) Not supported - does nothing | TODO 
36c0			 
36c0					if DEBUG_FORTH_WORDS_KEY 
36c0						DMARK "ELS" 
36c0 f5				push af  
36c1 3a d5 36			ld a, (.dmark)  
36c4 32 a6 fd			ld (debug_mark),a  
36c7 3a d6 36			ld a, (.dmark+1)  
36ca 32 a7 fd			ld (debug_mark+1),a  
36cd 3a d7 36			ld a, (.dmark+2)  
36d0 32 a8 fd			ld (debug_mark+2),a  
36d3 18 03			jr .pastdmark  
36d5 ..			.dmark: db "ELS"  
36d8 f1			.pastdmark: pop af  
36d9			endm  
# End of macro DMARK
36d9						CALLMONITOR 
36d9 cd aa fd			call debug_vector  
36dc				endm  
# End of macro CALLMONITOR
36dc					endif 
36dc			 
36dc			 
36dc					NEXTW 
36dc c3 0f 26			jp macro_next 
36df				endm 
# End of macro NEXTW
36df			.DO: 
36df				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
36df 21				db WORD_SYS_CORE+13             
36e0 06 38			dw .LOOP            
36e2 03				db 2 + 1 
36e3 .. 00			db "DO",0              
36e6				endm 
# End of macro CWHEAD
36e6			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
36e6			 
36e6					if DEBUG_FORTH_WORDS_KEY 
36e6						DMARK "DO." 
36e6 f5				push af  
36e7 3a fb 36			ld a, (.dmark)  
36ea 32 a6 fd			ld (debug_mark),a  
36ed 3a fc 36			ld a, (.dmark+1)  
36f0 32 a7 fd			ld (debug_mark+1),a  
36f3 3a fd 36			ld a, (.dmark+2)  
36f6 32 a8 fd			ld (debug_mark+2),a  
36f9 18 03			jr .pastdmark  
36fb ..			.dmark: db "DO."  
36fe f1			.pastdmark: pop af  
36ff			endm  
# End of macro DMARK
36ff						CALLMONITOR 
36ff cd aa fd			call debug_vector  
3702				endm  
# End of macro CALLMONITOR
3702					endif 
3702			;  push pc to rsp stack past the DO 
3702			 
3702 2a fd f3				ld hl, (os_tok_ptr) 
3705 23					inc hl   ; D 
3706 23					inc hl  ; O 
3707 23					inc hl   ; null 
3708					if DEBUG_FORTH_WORDS 
3708						DMARK "DO2" 
3708 f5				push af  
3709 3a 1d 37			ld a, (.dmark)  
370c 32 a6 fd			ld (debug_mark),a  
370f 3a 1e 37			ld a, (.dmark+1)  
3712 32 a7 fd			ld (debug_mark+1),a  
3715 3a 1f 37			ld a, (.dmark+2)  
3718 32 a8 fd			ld (debug_mark+2),a  
371b 18 03			jr .pastdmark  
371d ..			.dmark: db "DO2"  
3720 f1			.pastdmark: pop af  
3721			endm  
# End of macro DMARK
3721						CALLMONITOR 
3721 cd aa fd			call debug_vector  
3724				endm  
# End of macro CALLMONITOR
3724					endif 
3724					FORTH_RSP_NEXT 
3724 cd 09 22			call macro_forth_rsp_next 
3727				endm 
# End of macro FORTH_RSP_NEXT
3727					if DEBUG_FORTH_WORDS 
3727						DMARK "DO3" 
3727 f5				push af  
3728 3a 3c 37			ld a, (.dmark)  
372b 32 a6 fd			ld (debug_mark),a  
372e 3a 3d 37			ld a, (.dmark+1)  
3731 32 a7 fd			ld (debug_mark+1),a  
3734 3a 3e 37			ld a, (.dmark+2)  
3737 32 a8 fd			ld (debug_mark+2),a  
373a 18 03			jr .pastdmark  
373c ..			.dmark: db "DO3"  
373f f1			.pastdmark: pop af  
3740			endm  
# End of macro DMARK
3740						CALLMONITOR 
3740 cd aa fd			call debug_vector  
3743				endm  
# End of macro CALLMONITOR
3743					endif 
3743			 
3743					;if DEBUG_FORTH_WORDS 
3743				;		push hl 
3743			;		endif  
3743			 
3743			; get counters from data stack 
3743			 
3743			 
3743					FORTH_DSP_VALUEHL 
3743 cd 59 24			call macro_dsp_valuehl 
3746				endm 
# End of macro FORTH_DSP_VALUEHL
3746 e5					push hl		 ; hl now has starting counter which needs to be tos 
3747			 
3747					if DEBUG_FORTH_WORDS 
3747						DMARK "DO4" 
3747 f5				push af  
3748 3a 5c 37			ld a, (.dmark)  
374b 32 a6 fd			ld (debug_mark),a  
374e 3a 5d 37			ld a, (.dmark+1)  
3751 32 a7 fd			ld (debug_mark+1),a  
3754 3a 5e 37			ld a, (.dmark+2)  
3757 32 a8 fd			ld (debug_mark+2),a  
375a 18 03			jr .pastdmark  
375c ..			.dmark: db "DO4"  
375f f1			.pastdmark: pop af  
3760			endm  
# End of macro DMARK
3760						CALLMONITOR 
3760 cd aa fd			call debug_vector  
3763				endm  
# End of macro CALLMONITOR
3763					endif 
3763					FORTH_DSP_POP 
3763 cd 11 25			call macro_forth_dsp_pop 
3766				endm 
# End of macro FORTH_DSP_POP
3766			 
3766					if DEBUG_FORTH_WORDS 
3766						DMARK "DO5" 
3766 f5				push af  
3767 3a 7b 37			ld a, (.dmark)  
376a 32 a6 fd			ld (debug_mark),a  
376d 3a 7c 37			ld a, (.dmark+1)  
3770 32 a7 fd			ld (debug_mark+1),a  
3773 3a 7d 37			ld a, (.dmark+2)  
3776 32 a8 fd			ld (debug_mark+2),a  
3779 18 03			jr .pastdmark  
377b ..			.dmark: db "DO5"  
377e f1			.pastdmark: pop af  
377f			endm  
# End of macro DMARK
377f						CALLMONITOR 
377f cd aa fd			call debug_vector  
3782				endm  
# End of macro CALLMONITOR
3782					endif 
3782			 
3782					FORTH_DSP_VALUEHL 
3782 cd 59 24			call macro_dsp_valuehl 
3785				endm 
# End of macro FORTH_DSP_VALUEHL
3785			;		push hl		 ; hl now has starting limit counter 
3785			 
3785					if DEBUG_FORTH_WORDS 
3785						DMARK "DO6" 
3785 f5				push af  
3786 3a 9a 37			ld a, (.dmark)  
3789 32 a6 fd			ld (debug_mark),a  
378c 3a 9b 37			ld a, (.dmark+1)  
378f 32 a7 fd			ld (debug_mark+1),a  
3792 3a 9c 37			ld a, (.dmark+2)  
3795 32 a8 fd			ld (debug_mark+2),a  
3798 18 03			jr .pastdmark  
379a ..			.dmark: db "DO6"  
379d f1			.pastdmark: pop af  
379e			endm  
# End of macro DMARK
379e						CALLMONITOR 
379e cd aa fd			call debug_vector  
37a1				endm  
# End of macro CALLMONITOR
37a1					endif 
37a1					FORTH_DSP_POP 
37a1 cd 11 25			call macro_forth_dsp_pop 
37a4				endm 
# End of macro FORTH_DSP_POP
37a4			 
37a4			; put counters on the loop stack 
37a4			 
37a4			;		pop hl			 ; limit counter 
37a4 d1					pop de			; start counter 
37a5			 
37a5					; push limit counter 
37a5			 
37a5					if DEBUG_FORTH_WORDS 
37a5						DMARK "DO7" 
37a5 f5				push af  
37a6 3a ba 37			ld a, (.dmark)  
37a9 32 a6 fd			ld (debug_mark),a  
37ac 3a bb 37			ld a, (.dmark+1)  
37af 32 a7 fd			ld (debug_mark+1),a  
37b2 3a bc 37			ld a, (.dmark+2)  
37b5 32 a8 fd			ld (debug_mark+2),a  
37b8 18 03			jr .pastdmark  
37ba ..			.dmark: db "DO7"  
37bd f1			.pastdmark: pop af  
37be			endm  
# End of macro DMARK
37be						CALLMONITOR 
37be cd aa fd			call debug_vector  
37c1				endm  
# End of macro CALLMONITOR
37c1					endif 
37c1					FORTH_LOOP_NEXT 
37c1 cd 8a 24			call macro_forth_loop_next 
37c4				endm 
# End of macro FORTH_LOOP_NEXT
37c4			 
37c4					; push start counter 
37c4			 
37c4 eb					ex de, hl 
37c5					if DEBUG_FORTH_WORDS 
37c5						DMARK "DO7" 
37c5 f5				push af  
37c6 3a da 37			ld a, (.dmark)  
37c9 32 a6 fd			ld (debug_mark),a  
37cc 3a db 37			ld a, (.dmark+1)  
37cf 32 a7 fd			ld (debug_mark+1),a  
37d2 3a dc 37			ld a, (.dmark+2)  
37d5 32 a8 fd			ld (debug_mark+2),a  
37d8 18 03			jr .pastdmark  
37da ..			.dmark: db "DO7"  
37dd f1			.pastdmark: pop af  
37de			endm  
# End of macro DMARK
37de						CALLMONITOR 
37de cd aa fd			call debug_vector  
37e1				endm  
# End of macro CALLMONITOR
37e1					endif 
37e1					FORTH_LOOP_NEXT 
37e1 cd 8a 24			call macro_forth_loop_next 
37e4				endm 
# End of macro FORTH_LOOP_NEXT
37e4			 
37e4			 
37e4					; init first round of I counter 
37e4			 
37e4 22 21 f4				ld (os_current_i), hl 
37e7			 
37e7					if DEBUG_FORTH_WORDS 
37e7						DMARK "DO8" 
37e7 f5				push af  
37e8 3a fc 37			ld a, (.dmark)  
37eb 32 a6 fd			ld (debug_mark),a  
37ee 3a fd 37			ld a, (.dmark+1)  
37f1 32 a7 fd			ld (debug_mark+1),a  
37f4 3a fe 37			ld a, (.dmark+2)  
37f7 32 a8 fd			ld (debug_mark+2),a  
37fa 18 03			jr .pastdmark  
37fc ..			.dmark: db "DO8"  
37ff f1			.pastdmark: pop af  
3800			endm  
# End of macro DMARK
3800						CALLMONITOR 
3800 cd aa fd			call debug_vector  
3803				endm  
# End of macro CALLMONITOR
3803					endif 
3803			 
3803					NEXTW 
3803 c3 0f 26			jp macro_next 
3806				endm 
# End of macro NEXTW
3806			.LOOP: 
3806				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3806 22				db WORD_SYS_CORE+14             
3807 1e 39			dw .I            
3809 05				db 4 + 1 
380a .. 00			db "LOOP",0              
380f				endm 
# End of macro CWHEAD
380f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
380f			 
380f				; pop tos as current loop count to hl 
380f			 
380f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
380f			 
380f				FORTH_LOOP_TOS 
380f cd bd 24			call macro_forth_loop_tos 
3812				endm 
# End of macro FORTH_LOOP_TOS
3812 e5				push hl 
3813			 
3813					if DEBUG_FORTH_WORDS_KEY 
3813						DMARK "LOP" 
3813 f5				push af  
3814 3a 28 38			ld a, (.dmark)  
3817 32 a6 fd			ld (debug_mark),a  
381a 3a 29 38			ld a, (.dmark+1)  
381d 32 a7 fd			ld (debug_mark+1),a  
3820 3a 2a 38			ld a, (.dmark+2)  
3823 32 a8 fd			ld (debug_mark+2),a  
3826 18 03			jr .pastdmark  
3828 ..			.dmark: db "LOP"  
382b f1			.pastdmark: pop af  
382c			endm  
# End of macro DMARK
382c						CALLMONITOR 
382c cd aa fd			call debug_vector  
382f				endm  
# End of macro CALLMONITOR
382f					endif 
382f				; next item on the stack is the limit. get it 
382f			 
382f			 
382f				FORTH_LOOP_POP 
382f cd c7 24			call macro_forth_loop_pop 
3832				endm 
# End of macro FORTH_LOOP_POP
3832			 
3832				FORTH_LOOP_TOS 
3832 cd bd 24			call macro_forth_loop_tos 
3835				endm 
# End of macro FORTH_LOOP_TOS
3835			 
3835 d1				pop de		 ; de = i, hl = limit 
3836			 
3836					if DEBUG_FORTH_WORDS 
3836						DMARK "LP1" 
3836 f5				push af  
3837 3a 4b 38			ld a, (.dmark)  
383a 32 a6 fd			ld (debug_mark),a  
383d 3a 4c 38			ld a, (.dmark+1)  
3840 32 a7 fd			ld (debug_mark+1),a  
3843 3a 4d 38			ld a, (.dmark+2)  
3846 32 a8 fd			ld (debug_mark+2),a  
3849 18 03			jr .pastdmark  
384b ..			.dmark: db "LP1"  
384e f1			.pastdmark: pop af  
384f			endm  
# End of macro DMARK
384f						CALLMONITOR 
384f cd aa fd			call debug_vector  
3852				endm  
# End of macro CALLMONITOR
3852					endif 
3852			 
3852				; go back to previous word 
3852			 
3852 d5				push de    ; save I for inc later 
3853			 
3853			 
3853				; get limit 
3853				;  is I at limit? 
3853			 
3853			 
3853					if DEBUG_FORTH_WORDS 
3853						DMARK "LP1" 
3853 f5				push af  
3854 3a 68 38			ld a, (.dmark)  
3857 32 a6 fd			ld (debug_mark),a  
385a 3a 69 38			ld a, (.dmark+1)  
385d 32 a7 fd			ld (debug_mark+1),a  
3860 3a 6a 38			ld a, (.dmark+2)  
3863 32 a8 fd			ld (debug_mark+2),a  
3866 18 03			jr .pastdmark  
3868 ..			.dmark: db "LP1"  
386b f1			.pastdmark: pop af  
386c			endm  
# End of macro DMARK
386c						CALLMONITOR 
386c cd aa fd			call debug_vector  
386f				endm  
# End of macro CALLMONITOR
386f					endif 
386f			 
386f ed 52			sbc hl, de 
3871			 
3871			 
3871				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3871			 
3871 20 26				jr nz, .loopnotdone 
3873			 
3873 e1				pop hl   ; get rid of saved I 
3874				FORTH_LOOP_POP     ; get rid of limit 
3874 cd c7 24			call macro_forth_loop_pop 
3877				endm 
# End of macro FORTH_LOOP_POP
3877			 
3877				FORTH_RSP_POP     ; get rid of DO ptr 
3877 cd 2a 22			call macro_forth_rsp_pop 
387a				endm 
# End of macro FORTH_RSP_POP
387a			 
387a			if DEBUG_FORTH_WORDS 
387a						DMARK "LP>" 
387a f5				push af  
387b 3a 8f 38			ld a, (.dmark)  
387e 32 a6 fd			ld (debug_mark),a  
3881 3a 90 38			ld a, (.dmark+1)  
3884 32 a7 fd			ld (debug_mark+1),a  
3887 3a 91 38			ld a, (.dmark+2)  
388a 32 a8 fd			ld (debug_mark+2),a  
388d 18 03			jr .pastdmark  
388f ..			.dmark: db "LP>"  
3892 f1			.pastdmark: pop af  
3893			endm  
# End of macro DMARK
3893				CALLMONITOR 
3893 cd aa fd			call debug_vector  
3896				endm  
# End of macro CALLMONITOR
3896			endif 
3896			 
3896					NEXTW 
3896 c3 0f 26			jp macro_next 
3899				endm 
# End of macro NEXTW
3899				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3899			 
3899			.loopnotdone: 
3899			 
3899 e1				pop hl    ; get I 
389a 23				inc hl 
389b			 
389b			   	; save new I 
389b			 
389b			 
389b					; set I counter 
389b			 
389b 22 21 f4				ld (os_current_i), hl 
389e			 
389e					if DEBUG_FORTH_WORDS 
389e						DMARK "LPN" 
389e f5				push af  
389f 3a b3 38			ld a, (.dmark)  
38a2 32 a6 fd			ld (debug_mark),a  
38a5 3a b4 38			ld a, (.dmark+1)  
38a8 32 a7 fd			ld (debug_mark+1),a  
38ab 3a b5 38			ld a, (.dmark+2)  
38ae 32 a8 fd			ld (debug_mark+2),a  
38b1 18 03			jr .pastdmark  
38b3 ..			.dmark: db "LPN"  
38b6 f1			.pastdmark: pop af  
38b7			endm  
# End of macro DMARK
38b7					CALLMONITOR 
38b7 cd aa fd			call debug_vector  
38ba				endm  
# End of macro CALLMONITOR
38ba					endif 
38ba					 
38ba				FORTH_LOOP_NEXT 
38ba cd 8a 24			call macro_forth_loop_next 
38bd				endm 
# End of macro FORTH_LOOP_NEXT
38bd			 
38bd			 
38bd					if DEBUG_FORTH_WORDS 
38bd eb						ex de,hl 
38be					endif 
38be			 
38be			;	; get DO ptr 
38be			; 
38be					if DEBUG_FORTH_WORDS 
38be						DMARK "LP7" 
38be f5				push af  
38bf 3a d3 38			ld a, (.dmark)  
38c2 32 a6 fd			ld (debug_mark),a  
38c5 3a d4 38			ld a, (.dmark+1)  
38c8 32 a7 fd			ld (debug_mark+1),a  
38cb 3a d5 38			ld a, (.dmark+2)  
38ce 32 a8 fd			ld (debug_mark+2),a  
38d1 18 03			jr .pastdmark  
38d3 ..			.dmark: db "LP7"  
38d6 f1			.pastdmark: pop af  
38d7			endm  
# End of macro DMARK
38d7					CALLMONITOR 
38d7 cd aa fd			call debug_vector  
38da				endm  
# End of macro CALLMONITOR
38da					endif 
38da				FORTH_RSP_TOS 
38da cd 20 22			call macro_forth_rsp_tos 
38dd				endm 
# End of macro FORTH_RSP_TOS
38dd			 
38dd					if DEBUG_FORTH_WORDS 
38dd						DMARK "LP8" 
38dd f5				push af  
38de 3a f2 38			ld a, (.dmark)  
38e1 32 a6 fd			ld (debug_mark),a  
38e4 3a f3 38			ld a, (.dmark+1)  
38e7 32 a7 fd			ld (debug_mark+1),a  
38ea 3a f4 38			ld a, (.dmark+2)  
38ed 32 a8 fd			ld (debug_mark+2),a  
38f0 18 03			jr .pastdmark  
38f2 ..			.dmark: db "LP8"  
38f5 f1			.pastdmark: pop af  
38f6			endm  
# End of macro DMARK
38f6					CALLMONITOR 
38f6 cd aa fd			call debug_vector  
38f9				endm  
# End of macro CALLMONITOR
38f9					endif 
38f9				;push hl 
38f9			 
38f9				; not going to DO any more 
38f9				; get rid of the RSP pointer as DO will add it back in 
38f9				;FORTH_RSP_POP 
38f9				;pop hl 
38f9			 
38f9				;ld hl,(cli_ret_sp) 
38f9				;ld e, (hl) 
38f9				;inc hl 
38f9				;ld d, (hl) 
38f9				;ex de,hl 
38f9 22 fd f3			ld (os_tok_ptr), hl 
38fc					if DEBUG_FORTH_WORDS 
38fc						DMARK "LP<" 
38fc f5				push af  
38fd 3a 11 39			ld a, (.dmark)  
3900 32 a6 fd			ld (debug_mark),a  
3903 3a 12 39			ld a, (.dmark+1)  
3906 32 a7 fd			ld (debug_mark+1),a  
3909 3a 13 39			ld a, (.dmark+2)  
390c 32 a8 fd			ld (debug_mark+2),a  
390f 18 03			jr .pastdmark  
3911 ..			.dmark: db "LP<"  
3914 f1			.pastdmark: pop af  
3915			endm  
# End of macro DMARK
3915					CALLMONITOR 
3915 cd aa fd			call debug_vector  
3918				endm  
# End of macro CALLMONITOR
3918				endif 
3918 c3 a0 26			jp exec1 
391b			 
391b					 
391b			 
391b			 
391b					NEXTW 
391b c3 0f 26			jp macro_next 
391e				endm 
# End of macro NEXTW
391e			.I:  
391e			 
391e				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
391e 5e				db WORD_SYS_CORE+74             
391f 49 39			dw .DLOOP            
3921 02				db 1 + 1 
3922 .. 00			db "I",0              
3924				endm 
# End of macro CWHEAD
3924			; | I ( -- ) Current loop counter | DONE 
3924					if DEBUG_FORTH_WORDS_KEY 
3924						DMARK "I.." 
3924 f5				push af  
3925 3a 39 39			ld a, (.dmark)  
3928 32 a6 fd			ld (debug_mark),a  
392b 3a 3a 39			ld a, (.dmark+1)  
392e 32 a7 fd			ld (debug_mark+1),a  
3931 3a 3b 39			ld a, (.dmark+2)  
3934 32 a8 fd			ld (debug_mark+2),a  
3937 18 03			jr .pastdmark  
3939 ..			.dmark: db "I.."  
393c f1			.pastdmark: pop af  
393d			endm  
# End of macro DMARK
393d						CALLMONITOR 
393d cd aa fd			call debug_vector  
3940				endm  
# End of macro CALLMONITOR
3940					endif 
3940			 
3940 2a 21 f4				ld hl,(os_current_i) 
3943 cd 62 22				call forth_push_numhl 
3946			 
3946					NEXTW 
3946 c3 0f 26			jp macro_next 
3949				endm 
# End of macro NEXTW
3949			.DLOOP: 
3949				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3949 5f				db WORD_SYS_CORE+75             
394a 2a 3a			dw .REPEAT            
394c 06				db 5 + 1 
394d .. 00			db "-LOOP",0              
3953				endm 
# End of macro CWHEAD
3953			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3953				; pop tos as current loop count to hl 
3953					if DEBUG_FORTH_WORDS_KEY 
3953						DMARK "-LP" 
3953 f5				push af  
3954 3a 68 39			ld a, (.dmark)  
3957 32 a6 fd			ld (debug_mark),a  
395a 3a 69 39			ld a, (.dmark+1)  
395d 32 a7 fd			ld (debug_mark+1),a  
3960 3a 6a 39			ld a, (.dmark+2)  
3963 32 a8 fd			ld (debug_mark+2),a  
3966 18 03			jr .pastdmark  
3968 ..			.dmark: db "-LP"  
396b f1			.pastdmark: pop af  
396c			endm  
# End of macro DMARK
396c						CALLMONITOR 
396c cd aa fd			call debug_vector  
396f				endm  
# End of macro CALLMONITOR
396f					endif 
396f			 
396f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
396f			 
396f				FORTH_LOOP_TOS 
396f cd bd 24			call macro_forth_loop_tos 
3972				endm 
# End of macro FORTH_LOOP_TOS
3972 e5				push hl 
3973			 
3973					if DEBUG_FORTH_WORDS 
3973						DMARK "-LP" 
3973 f5				push af  
3974 3a 88 39			ld a, (.dmark)  
3977 32 a6 fd			ld (debug_mark),a  
397a 3a 89 39			ld a, (.dmark+1)  
397d 32 a7 fd			ld (debug_mark+1),a  
3980 3a 8a 39			ld a, (.dmark+2)  
3983 32 a8 fd			ld (debug_mark+2),a  
3986 18 03			jr .pastdmark  
3988 ..			.dmark: db "-LP"  
398b f1			.pastdmark: pop af  
398c			endm  
# End of macro DMARK
398c						CALLMONITOR 
398c cd aa fd			call debug_vector  
398f				endm  
# End of macro CALLMONITOR
398f					endif 
398f				; next item on the stack is the limit. get it 
398f			 
398f			 
398f				FORTH_LOOP_POP 
398f cd c7 24			call macro_forth_loop_pop 
3992				endm 
# End of macro FORTH_LOOP_POP
3992			 
3992				FORTH_LOOP_TOS 
3992 cd bd 24			call macro_forth_loop_tos 
3995				endm 
# End of macro FORTH_LOOP_TOS
3995			 
3995 d1				pop de		 ; de = i, hl = limit 
3996			 
3996					if DEBUG_FORTH_WORDS 
3996						DMARK "-L1" 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 a6 fd			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 a7 fd			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 a8 fd			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "-L1"  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af						CALLMONITOR 
39af cd aa fd			call debug_vector  
39b2				endm  
# End of macro CALLMONITOR
39b2					endif 
39b2			 
39b2				; go back to previous word 
39b2			 
39b2 d5				push de    ; save I for inc later 
39b3			 
39b3			 
39b3				; get limit 
39b3				;  is I at limit? 
39b3			 
39b3			 
39b3					if DEBUG_FORTH_WORDS 
39b3						DMARK "-L1" 
39b3 f5				push af  
39b4 3a c8 39			ld a, (.dmark)  
39b7 32 a6 fd			ld (debug_mark),a  
39ba 3a c9 39			ld a, (.dmark+1)  
39bd 32 a7 fd			ld (debug_mark+1),a  
39c0 3a ca 39			ld a, (.dmark+2)  
39c3 32 a8 fd			ld (debug_mark+2),a  
39c6 18 03			jr .pastdmark  
39c8 ..			.dmark: db "-L1"  
39cb f1			.pastdmark: pop af  
39cc			endm  
# End of macro DMARK
39cc						CALLMONITOR 
39cc cd aa fd			call debug_vector  
39cf				endm  
# End of macro CALLMONITOR
39cf					endif 
39cf			 
39cf ed 52			sbc hl, de 
39d1			 
39d1			 
39d1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
39d1			 
39d1 20 26				jr nz, .mloopnotdone 
39d3			 
39d3 e1				pop hl   ; get rid of saved I 
39d4				FORTH_LOOP_POP     ; get rid of limit 
39d4 cd c7 24			call macro_forth_loop_pop 
39d7				endm 
# End of macro FORTH_LOOP_POP
39d7			 
39d7				FORTH_RSP_POP     ; get rid of DO ptr 
39d7 cd 2a 22			call macro_forth_rsp_pop 
39da				endm 
# End of macro FORTH_RSP_POP
39da			 
39da			if DEBUG_FORTH_WORDS 
39da						DMARK "-L>" 
39da f5				push af  
39db 3a ef 39			ld a, (.dmark)  
39de 32 a6 fd			ld (debug_mark),a  
39e1 3a f0 39			ld a, (.dmark+1)  
39e4 32 a7 fd			ld (debug_mark+1),a  
39e7 3a f1 39			ld a, (.dmark+2)  
39ea 32 a8 fd			ld (debug_mark+2),a  
39ed 18 03			jr .pastdmark  
39ef ..			.dmark: db "-L>"  
39f2 f1			.pastdmark: pop af  
39f3			endm  
# End of macro DMARK
39f3				CALLMONITOR 
39f3 cd aa fd			call debug_vector  
39f6				endm  
# End of macro CALLMONITOR
39f6			endif 
39f6			 
39f6					NEXTW 
39f6 c3 0f 26			jp macro_next 
39f9				endm 
# End of macro NEXTW
39f9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
39f9			 
39f9			.mloopnotdone: 
39f9			 
39f9 e1				pop hl    ; get I 
39fa 2b				dec hl 
39fb			 
39fb			   	; save new I 
39fb			 
39fb			 
39fb					; set I counter 
39fb			 
39fb 22 21 f4				ld (os_current_i), hl 
39fe			 
39fe					 
39fe				FORTH_LOOP_NEXT 
39fe cd 8a 24			call macro_forth_loop_next 
3a01				endm 
# End of macro FORTH_LOOP_NEXT
3a01			 
3a01			 
3a01					if DEBUG_FORTH_WORDS 
3a01 eb						ex de,hl 
3a02					endif 
3a02			 
3a02			;	; get DO ptr 
3a02			; 
3a02				FORTH_RSP_TOS 
3a02 cd 20 22			call macro_forth_rsp_tos 
3a05				endm 
# End of macro FORTH_RSP_TOS
3a05			 
3a05				;push hl 
3a05			 
3a05				; not going to DO any more 
3a05				; get rid of the RSP pointer as DO will add it back in 
3a05				;FORTH_RSP_POP 
3a05				;pop hl 
3a05			 
3a05			 
3a05 22 fd f3			ld (os_tok_ptr), hl 
3a08					if DEBUG_FORTH_WORDS 
3a08						DMARK "-L<" 
3a08 f5				push af  
3a09 3a 1d 3a			ld a, (.dmark)  
3a0c 32 a6 fd			ld (debug_mark),a  
3a0f 3a 1e 3a			ld a, (.dmark+1)  
3a12 32 a7 fd			ld (debug_mark+1),a  
3a15 3a 1f 3a			ld a, (.dmark+2)  
3a18 32 a8 fd			ld (debug_mark+2),a  
3a1b 18 03			jr .pastdmark  
3a1d ..			.dmark: db "-L<"  
3a20 f1			.pastdmark: pop af  
3a21			endm  
# End of macro DMARK
3a21					CALLMONITOR 
3a21 cd aa fd			call debug_vector  
3a24				endm  
# End of macro CALLMONITOR
3a24				endif 
3a24 c3 a0 26			jp exec1 
3a27			 
3a27					 
3a27			 
3a27			 
3a27			 
3a27				NEXTW 
3a27 c3 0f 26			jp macro_next 
3a2a				endm 
# End of macro NEXTW
3a2a			 
3a2a			 
3a2a			 
3a2a			 
3a2a			.REPEAT: 
3a2a				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3a2a 71				db WORD_SYS_CORE+93             
3a2b 7d 3a			dw .UNTIL            
3a2d 06				db 5 + 1 
3a2e .. 00			db "REPEAT",0              
3a35				endm 
# End of macro CWHEAD
3a35			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3a35			;  push pc to rsp stack past the REPEAT 
3a35					if DEBUG_FORTH_WORDS_KEY 
3a35						DMARK "REP" 
3a35 f5				push af  
3a36 3a 4a 3a			ld a, (.dmark)  
3a39 32 a6 fd			ld (debug_mark),a  
3a3c 3a 4b 3a			ld a, (.dmark+1)  
3a3f 32 a7 fd			ld (debug_mark+1),a  
3a42 3a 4c 3a			ld a, (.dmark+2)  
3a45 32 a8 fd			ld (debug_mark+2),a  
3a48 18 03			jr .pastdmark  
3a4a ..			.dmark: db "REP"  
3a4d f1			.pastdmark: pop af  
3a4e			endm  
# End of macro DMARK
3a4e						CALLMONITOR 
3a4e cd aa fd			call debug_vector  
3a51				endm  
# End of macro CALLMONITOR
3a51					endif 
3a51			 
3a51 2a fd f3				ld hl, (os_tok_ptr) 
3a54 23					inc hl   ; R 
3a55 23					inc hl  ; E 
3a56 23					inc hl   ; P 
3a57 23					inc hl   ; E 
3a58 23					inc hl   ; A 
3a59 23					inc hl   ; T 
3a5a 23					inc hl   ; zero 
3a5b					FORTH_RSP_NEXT 
3a5b cd 09 22			call macro_forth_rsp_next 
3a5e				endm 
# End of macro FORTH_RSP_NEXT
3a5e			 
3a5e			 
3a5e					if DEBUG_FORTH_WORDS 
3a5e						DMARK "REP" 
3a5e f5				push af  
3a5f 3a 73 3a			ld a, (.dmark)  
3a62 32 a6 fd			ld (debug_mark),a  
3a65 3a 74 3a			ld a, (.dmark+1)  
3a68 32 a7 fd			ld (debug_mark+1),a  
3a6b 3a 75 3a			ld a, (.dmark+2)  
3a6e 32 a8 fd			ld (debug_mark+2),a  
3a71 18 03			jr .pastdmark  
3a73 ..			.dmark: db "REP"  
3a76 f1			.pastdmark: pop af  
3a77			endm  
# End of macro DMARK
3a77						;pop bc    ; TODO BUG ?????? what is this for???? 
3a77						CALLMONITOR 
3a77 cd aa fd			call debug_vector  
3a7a				endm  
# End of macro CALLMONITOR
3a7a					endif 
3a7a			 
3a7a					NEXTW 
3a7a c3 0f 26			jp macro_next 
3a7d				endm 
# End of macro NEXTW
3a7d			;	       NEXTW 
3a7d			 
3a7d			.UNTIL: 
3a7d				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3a7d 72				db WORD_SYS_CORE+94             
3a7e 14 3b			dw .ENDFLOW            
3a80 06				db 5 + 1 
3a81 .. 00			db "UNTIL",0              
3a87				endm 
# End of macro CWHEAD
3a87			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3a87			 
3a87				; pop tos as check 
3a87			 
3a87				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3a87			 
3a87				FORTH_DSP_VALUEHL 
3a87 cd 59 24			call macro_dsp_valuehl 
3a8a				endm 
# End of macro FORTH_DSP_VALUEHL
3a8a			 
3a8a					if DEBUG_FORTH_WORDS_KEY 
3a8a						DMARK "UNT" 
3a8a f5				push af  
3a8b 3a 9f 3a			ld a, (.dmark)  
3a8e 32 a6 fd			ld (debug_mark),a  
3a91 3a a0 3a			ld a, (.dmark+1)  
3a94 32 a7 fd			ld (debug_mark+1),a  
3a97 3a a1 3a			ld a, (.dmark+2)  
3a9a 32 a8 fd			ld (debug_mark+2),a  
3a9d 18 03			jr .pastdmark  
3a9f ..			.dmark: db "UNT"  
3aa2 f1			.pastdmark: pop af  
3aa3			endm  
# End of macro DMARK
3aa3						CALLMONITOR 
3aa3 cd aa fd			call debug_vector  
3aa6				endm  
# End of macro CALLMONITOR
3aa6					endif 
3aa6			 
3aa6			;	push hl 
3aa6				FORTH_DSP_POP 
3aa6 cd 11 25			call macro_forth_dsp_pop 
3aa9				endm 
# End of macro FORTH_DSP_POP
3aa9			 
3aa9			;	pop hl 
3aa9			 
3aa9				; test if true 
3aa9			 
3aa9 cd f8 0f			call ishlzero 
3aac			;	ld a,l 
3aac			;	add h 
3aac			; 
3aac			;	cp 0 
3aac			 
3aac 20 3e			jr nz, .untilnotdone 
3aae			 
3aae					if DEBUG_FORTH_WORDS 
3aae						DMARK "UNf" 
3aae f5				push af  
3aaf 3a c3 3a			ld a, (.dmark)  
3ab2 32 a6 fd			ld (debug_mark),a  
3ab5 3a c4 3a			ld a, (.dmark+1)  
3ab8 32 a7 fd			ld (debug_mark+1),a  
3abb 3a c5 3a			ld a, (.dmark+2)  
3abe 32 a8 fd			ld (debug_mark+2),a  
3ac1 18 03			jr .pastdmark  
3ac3 ..			.dmark: db "UNf"  
3ac6 f1			.pastdmark: pop af  
3ac7			endm  
# End of macro DMARK
3ac7						CALLMONITOR 
3ac7 cd aa fd			call debug_vector  
3aca				endm  
# End of macro CALLMONITOR
3aca					endif 
3aca			 
3aca			 
3aca			 
3aca				FORTH_RSP_POP     ; get rid of DO ptr 
3aca cd 2a 22			call macro_forth_rsp_pop 
3acd				endm 
# End of macro FORTH_RSP_POP
3acd			 
3acd			if DEBUG_FORTH_WORDS 
3acd						DMARK "UN>" 
3acd f5				push af  
3ace 3a e2 3a			ld a, (.dmark)  
3ad1 32 a6 fd			ld (debug_mark),a  
3ad4 3a e3 3a			ld a, (.dmark+1)  
3ad7 32 a7 fd			ld (debug_mark+1),a  
3ada 3a e4 3a			ld a, (.dmark+2)  
3add 32 a8 fd			ld (debug_mark+2),a  
3ae0 18 03			jr .pastdmark  
3ae2 ..			.dmark: db "UN>"  
3ae5 f1			.pastdmark: pop af  
3ae6			endm  
# End of macro DMARK
3ae6				CALLMONITOR 
3ae6 cd aa fd			call debug_vector  
3ae9				endm  
# End of macro CALLMONITOR
3ae9			endif 
3ae9			 
3ae9					NEXTW 
3ae9 c3 0f 26			jp macro_next 
3aec				endm 
# End of macro NEXTW
3aec				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3aec			 
3aec			.untilnotdone: 
3aec			 
3aec			 
3aec			;	; get DO ptr 
3aec			; 
3aec				FORTH_RSP_TOS 
3aec cd 20 22			call macro_forth_rsp_tos 
3aef				endm 
# End of macro FORTH_RSP_TOS
3aef			 
3aef				;push hl 
3aef			 
3aef				; not going to DO any more 
3aef				; get rid of the RSP pointer as DO will add it back in 
3aef				;FORTH_RSP_POP 
3aef				;pop hl 
3aef			 
3aef			 
3aef 22 fd f3			ld (os_tok_ptr), hl 
3af2					if DEBUG_FORTH_WORDS 
3af2						DMARK "UN<" 
3af2 f5				push af  
3af3 3a 07 3b			ld a, (.dmark)  
3af6 32 a6 fd			ld (debug_mark),a  
3af9 3a 08 3b			ld a, (.dmark+1)  
3afc 32 a7 fd			ld (debug_mark+1),a  
3aff 3a 09 3b			ld a, (.dmark+2)  
3b02 32 a8 fd			ld (debug_mark+2),a  
3b05 18 03			jr .pastdmark  
3b07 ..			.dmark: db "UN<"  
3b0a f1			.pastdmark: pop af  
3b0b			endm  
# End of macro DMARK
3b0b					CALLMONITOR 
3b0b cd aa fd			call debug_vector  
3b0e				endm  
# End of macro CALLMONITOR
3b0e				endif 
3b0e c3 a0 26			jp exec1 
3b11			 
3b11					 
3b11			 
3b11			 
3b11					NEXTW 
3b11 c3 0f 26			jp macro_next 
3b14				endm 
# End of macro NEXTW
3b14			 
3b14			 
3b14			.ENDFLOW: 
3b14			 
3b14			; eof 
3b14			 
# End of file forth_words_flow.asm
3b14			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3b14			include "forth_words_logic.asm" 
3b14			 
3b14			; | ## Logic Words 
3b14			 
3b14			.NOT: 
3b14				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3b14 2d				db WORD_SYS_CORE+25             
3b15 5c 3b			dw .IS            
3b17 04				db 3 + 1 
3b18 .. 00			db "NOT",0              
3b1c				endm 
# End of macro CWHEAD
3b1c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3b1c					if DEBUG_FORTH_WORDS_KEY 
3b1c						DMARK "NOT" 
3b1c f5				push af  
3b1d 3a 31 3b			ld a, (.dmark)  
3b20 32 a6 fd			ld (debug_mark),a  
3b23 3a 32 3b			ld a, (.dmark+1)  
3b26 32 a7 fd			ld (debug_mark+1),a  
3b29 3a 33 3b			ld a, (.dmark+2)  
3b2c 32 a8 fd			ld (debug_mark+2),a  
3b2f 18 03			jr .pastdmark  
3b31 ..			.dmark: db "NOT"  
3b34 f1			.pastdmark: pop af  
3b35			endm  
# End of macro DMARK
3b35						CALLMONITOR 
3b35 cd aa fd			call debug_vector  
3b38				endm  
# End of macro CALLMONITOR
3b38					endif 
3b38					FORTH_DSP 
3b38 cd 1f 24			call macro_forth_dsp 
3b3b				endm 
# End of macro FORTH_DSP
3b3b 7e					ld a,(hl)	; get type of value on TOS 
3b3c fe 02				cp DS_TYPE_INUM  
3b3e 28 03				jr z, .noti 
3b40					NEXTW 
3b40 c3 0f 26			jp macro_next 
3b43				endm 
# End of macro NEXTW
3b43			.noti:          FORTH_DSP_VALUEHL 
3b43 cd 59 24			call macro_dsp_valuehl 
3b46				endm 
# End of macro FORTH_DSP_VALUEHL
3b46			;		push hl 
3b46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b46 cd 11 25			call macro_forth_dsp_pop 
3b49				endm 
# End of macro FORTH_DSP_POP
3b49			;		pop hl 
3b49 3e 00				ld a,0 
3b4b bd					cp l 
3b4c 28 04				jr z, .not2t 
3b4e 2e 00				ld l, 0 
3b50 18 02				jr .notip 
3b52			 
3b52 2e ff		.not2t:		ld l, 255 
3b54			 
3b54 26 00		.notip:		ld h, 0	 
3b56			 
3b56 cd 62 22				call forth_push_numhl 
3b59					NEXTW 
3b59 c3 0f 26			jp macro_next 
3b5c				endm 
# End of macro NEXTW
3b5c			 
3b5c			.IS: 
3b5c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3b5c 2d				db WORD_SYS_CORE+25             
3b5d 82 3b			dw .LZERO            
3b5f 03				db 2 + 1 
3b60 .. 00			db "IS",0              
3b63				endm 
# End of macro CWHEAD
3b63			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3b63					if DEBUG_FORTH_WORDS_KEY 
3b63						DMARK "IS." 
3b63 f5				push af  
3b64 3a 78 3b			ld a, (.dmark)  
3b67 32 a6 fd			ld (debug_mark),a  
3b6a 3a 79 3b			ld a, (.dmark+1)  
3b6d 32 a7 fd			ld (debug_mark+1),a  
3b70 3a 7a 3b			ld a, (.dmark+2)  
3b73 32 a8 fd			ld (debug_mark+2),a  
3b76 18 03			jr .pastdmark  
3b78 ..			.dmark: db "IS."  
3b7b f1			.pastdmark: pop af  
3b7c			endm  
# End of macro DMARK
3b7c						CALLMONITOR 
3b7c cd aa fd			call debug_vector  
3b7f				endm  
# End of macro CALLMONITOR
3b7f					endif 
3b7f					NEXTW 
3b7f c3 0f 26			jp macro_next 
3b82				endm 
# End of macro NEXTW
3b82			.LZERO: 
3b82				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3b82 2d				db WORD_SYS_CORE+25             
3b83 8c 3b			dw .TZERO            
3b85 03				db 2 + 1 
3b86 .. 00			db "0<",0              
3b89				endm 
# End of macro CWHEAD
3b89			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3b89					NEXTW 
3b89 c3 0f 26			jp macro_next 
3b8c				endm 
# End of macro NEXTW
3b8c			.TZERO: 
3b8c				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3b8c 2e				db WORD_SYS_CORE+26             
3b8d d3 3b			dw .LESS            
3b8f 03				db 2 + 1 
3b90 .. 00			db "0=",0              
3b93				endm 
# End of macro CWHEAD
3b93			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3b93				; TODO add floating point number detection 
3b93					;v5 FORTH_DSP_VALUE 
3b93					if DEBUG_FORTH_WORDS_KEY 
3b93						DMARK "0=." 
3b93 f5				push af  
3b94 3a a8 3b			ld a, (.dmark)  
3b97 32 a6 fd			ld (debug_mark),a  
3b9a 3a a9 3b			ld a, (.dmark+1)  
3b9d 32 a7 fd			ld (debug_mark+1),a  
3ba0 3a aa 3b			ld a, (.dmark+2)  
3ba3 32 a8 fd			ld (debug_mark+2),a  
3ba6 18 03			jr .pastdmark  
3ba8 ..			.dmark: db "0=."  
3bab f1			.pastdmark: pop af  
3bac			endm  
# End of macro DMARK
3bac						CALLMONITOR 
3bac cd aa fd			call debug_vector  
3baf				endm  
# End of macro CALLMONITOR
3baf					endif 
3baf					FORTH_DSP 
3baf cd 1f 24			call macro_forth_dsp 
3bb2				endm 
# End of macro FORTH_DSP
3bb2 7e					ld a,(hl)	; get type of value on TOS 
3bb3 fe 02				cp DS_TYPE_INUM  
3bb5 28 00				jr z, .tz_inum 
3bb7			 
3bb7				if FORTH_ENABLE_FLOATMATH 
3bb7					jr .tz_done 
3bb7			 
3bb7				endif 
3bb7					 
3bb7			 
3bb7			.tz_inum: 
3bb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb7 cd 59 24			call macro_dsp_valuehl 
3bba				endm 
# End of macro FORTH_DSP_VALUEHL
3bba			 
3bba			;		push hl 
3bba			 
3bba					; destroy value TOS 
3bba			 
3bba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bba cd 11 25			call macro_forth_dsp_pop 
3bbd				endm 
# End of macro FORTH_DSP_POP
3bbd			 
3bbd			;		pop hl 
3bbd			 
3bbd 3e 00				ld a,0 
3bbf			 
3bbf bd					cp l 
3bc0 20 08				jr nz, .tz_notzero 
3bc2			 
3bc2 bc					cp h 
3bc3			 
3bc3 20 05				jr nz, .tz_notzero 
3bc5			 
3bc5			 
3bc5 21 01 00				ld hl, FORTH_TRUE 
3bc8 18 03				jr .tz_done 
3bca			 
3bca 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3bcd			 
3bcd					; push value back onto stack for another op etc 
3bcd			 
3bcd			.tz_done: 
3bcd cd 62 22				call forth_push_numhl 
3bd0			 
3bd0					NEXTW 
3bd0 c3 0f 26			jp macro_next 
3bd3				endm 
# End of macro NEXTW
3bd3			.LESS: 
3bd3				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3bd3 2f				db WORD_SYS_CORE+27             
3bd4 3c 3c			dw .GT            
3bd6 02				db 1 + 1 
3bd7 .. 00			db "<",0              
3bd9				endm 
# End of macro CWHEAD
3bd9			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3bd9				; TODO add floating point number detection 
3bd9					if DEBUG_FORTH_WORDS_KEY 
3bd9						DMARK "LES" 
3bd9 f5				push af  
3bda 3a ee 3b			ld a, (.dmark)  
3bdd 32 a6 fd			ld (debug_mark),a  
3be0 3a ef 3b			ld a, (.dmark+1)  
3be3 32 a7 fd			ld (debug_mark+1),a  
3be6 3a f0 3b			ld a, (.dmark+2)  
3be9 32 a8 fd			ld (debug_mark+2),a  
3bec 18 03			jr .pastdmark  
3bee ..			.dmark: db "LES"  
3bf1 f1			.pastdmark: pop af  
3bf2			endm  
# End of macro DMARK
3bf2						CALLMONITOR 
3bf2 cd aa fd			call debug_vector  
3bf5				endm  
# End of macro CALLMONITOR
3bf5					endif 
3bf5					FORTH_DSP 
3bf5 cd 1f 24			call macro_forth_dsp 
3bf8				endm 
# End of macro FORTH_DSP
3bf8					;v5 FORTH_DSP_VALUE 
3bf8 7e					ld a,(hl)	; get type of value on TOS 
3bf9 fe 02				cp DS_TYPE_INUM  
3bfb 28 00				jr z, .less_inum 
3bfd			 
3bfd				if FORTH_ENABLE_FLOATMATH 
3bfd					jr .less_done 
3bfd			 
3bfd				endif 
3bfd					 
3bfd			 
3bfd			.less_inum: 
3bfd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bfd cd 59 24			call macro_dsp_valuehl 
3c00				endm 
# End of macro FORTH_DSP_VALUEHL
3c00			 
3c00 e5					push hl  ; u2 
3c01			 
3c01					; destroy value TOS 
3c01			 
3c01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c01 cd 11 25			call macro_forth_dsp_pop 
3c04				endm 
# End of macro FORTH_DSP_POP
3c04			 
3c04			 
3c04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c04 cd 59 24			call macro_dsp_valuehl 
3c07				endm 
# End of macro FORTH_DSP_VALUEHL
3c07			 
3c07 e5					push hl    ; u1 
3c08			 
3c08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c08 cd 11 25			call macro_forth_dsp_pop 
3c0b				endm 
# End of macro FORTH_DSP_POP
3c0b			 
3c0b			 
3c0b b7			 or a      ;clear carry flag 
3c0c 01 00 00		 ld bc, FORTH_FALSE 
3c0f e1			  pop hl    ; u1 
3c10 d1			  pop de    ; u2 
3c11 ed 52		  sbc hl,de 
3c13 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3c15			 
3c15 01 01 00		 ld bc, FORTH_TRUE 
3c18			.lscont:  
3c18 c5					push bc 
3c19 e1					pop hl 
3c1a			 
3c1a					if DEBUG_FORTH_WORDS 
3c1a						DMARK "LT1" 
3c1a f5				push af  
3c1b 3a 2f 3c			ld a, (.dmark)  
3c1e 32 a6 fd			ld (debug_mark),a  
3c21 3a 30 3c			ld a, (.dmark+1)  
3c24 32 a7 fd			ld (debug_mark+1),a  
3c27 3a 31 3c			ld a, (.dmark+2)  
3c2a 32 a8 fd			ld (debug_mark+2),a  
3c2d 18 03			jr .pastdmark  
3c2f ..			.dmark: db "LT1"  
3c32 f1			.pastdmark: pop af  
3c33			endm  
# End of macro DMARK
3c33						CALLMONITOR 
3c33 cd aa fd			call debug_vector  
3c36				endm  
# End of macro CALLMONITOR
3c36					endif 
3c36 cd 62 22				call forth_push_numhl 
3c39			 
3c39					NEXTW 
3c39 c3 0f 26			jp macro_next 
3c3c				endm 
# End of macro NEXTW
3c3c			.GT: 
3c3c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3c3c 30				db WORD_SYS_CORE+28             
3c3d a5 3c			dw .EQUAL            
3c3f 02				db 1 + 1 
3c40 .. 00			db ">",0              
3c42				endm 
# End of macro CWHEAD
3c42			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3c42				; TODO add floating point number detection 
3c42					if DEBUG_FORTH_WORDS_KEY 
3c42						DMARK "GRT" 
3c42 f5				push af  
3c43 3a 57 3c			ld a, (.dmark)  
3c46 32 a6 fd			ld (debug_mark),a  
3c49 3a 58 3c			ld a, (.dmark+1)  
3c4c 32 a7 fd			ld (debug_mark+1),a  
3c4f 3a 59 3c			ld a, (.dmark+2)  
3c52 32 a8 fd			ld (debug_mark+2),a  
3c55 18 03			jr .pastdmark  
3c57 ..			.dmark: db "GRT"  
3c5a f1			.pastdmark: pop af  
3c5b			endm  
# End of macro DMARK
3c5b						CALLMONITOR 
3c5b cd aa fd			call debug_vector  
3c5e				endm  
# End of macro CALLMONITOR
3c5e					endif 
3c5e					FORTH_DSP 
3c5e cd 1f 24			call macro_forth_dsp 
3c61				endm 
# End of macro FORTH_DSP
3c61					;FORTH_DSP_VALUE 
3c61 7e					ld a,(hl)	; get type of value on TOS 
3c62 fe 02				cp DS_TYPE_INUM  
3c64 28 00				jr z, .gt_inum 
3c66			 
3c66				if FORTH_ENABLE_FLOATMATH 
3c66					jr .gt_done 
3c66			 
3c66				endif 
3c66					 
3c66			 
3c66			.gt_inum: 
3c66					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c66 cd 59 24			call macro_dsp_valuehl 
3c69				endm 
# End of macro FORTH_DSP_VALUEHL
3c69			 
3c69 e5					push hl  ; u2 
3c6a			 
3c6a					; destroy value TOS 
3c6a			 
3c6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c6a cd 11 25			call macro_forth_dsp_pop 
3c6d				endm 
# End of macro FORTH_DSP_POP
3c6d			 
3c6d			 
3c6d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c6d cd 59 24			call macro_dsp_valuehl 
3c70				endm 
# End of macro FORTH_DSP_VALUEHL
3c70			 
3c70 e5					push hl    ; u1 
3c71			 
3c71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c71 cd 11 25			call macro_forth_dsp_pop 
3c74				endm 
# End of macro FORTH_DSP_POP
3c74			 
3c74			 
3c74 b7			 or a      ;clear carry flag 
3c75 01 00 00		 ld bc, FORTH_FALSE 
3c78 e1			  pop hl    ; u1 
3c79 d1			  pop de    ; u2 
3c7a ed 52		  sbc hl,de 
3c7c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3c7e			 
3c7e 01 01 00		 ld bc, FORTH_TRUE 
3c81			.gtcont:  
3c81 c5					push bc 
3c82 e1					pop hl 
3c83			 
3c83					if DEBUG_FORTH_WORDS 
3c83						DMARK "GT1" 
3c83 f5				push af  
3c84 3a 98 3c			ld a, (.dmark)  
3c87 32 a6 fd			ld (debug_mark),a  
3c8a 3a 99 3c			ld a, (.dmark+1)  
3c8d 32 a7 fd			ld (debug_mark+1),a  
3c90 3a 9a 3c			ld a, (.dmark+2)  
3c93 32 a8 fd			ld (debug_mark+2),a  
3c96 18 03			jr .pastdmark  
3c98 ..			.dmark: db "GT1"  
3c9b f1			.pastdmark: pop af  
3c9c			endm  
# End of macro DMARK
3c9c						CALLMONITOR 
3c9c cd aa fd			call debug_vector  
3c9f				endm  
# End of macro CALLMONITOR
3c9f					endif 
3c9f cd 62 22				call forth_push_numhl 
3ca2			 
3ca2					NEXTW 
3ca2 c3 0f 26			jp macro_next 
3ca5				endm 
# End of macro NEXTW
3ca5			.EQUAL: 
3ca5				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3ca5 31				db WORD_SYS_CORE+29             
3ca6 10 3d			dw .ENDLOGIC            
3ca8 02				db 1 + 1 
3ca9 .. 00			db "=",0              
3cab				endm 
# End of macro CWHEAD
3cab			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3cab				; TODO add floating point number detection 
3cab					if DEBUG_FORTH_WORDS_KEY 
3cab						DMARK "EQ." 
3cab f5				push af  
3cac 3a c0 3c			ld a, (.dmark)  
3caf 32 a6 fd			ld (debug_mark),a  
3cb2 3a c1 3c			ld a, (.dmark+1)  
3cb5 32 a7 fd			ld (debug_mark+1),a  
3cb8 3a c2 3c			ld a, (.dmark+2)  
3cbb 32 a8 fd			ld (debug_mark+2),a  
3cbe 18 03			jr .pastdmark  
3cc0 ..			.dmark: db "EQ."  
3cc3 f1			.pastdmark: pop af  
3cc4			endm  
# End of macro DMARK
3cc4						CALLMONITOR 
3cc4 cd aa fd			call debug_vector  
3cc7				endm  
# End of macro CALLMONITOR
3cc7					endif 
3cc7					FORTH_DSP 
3cc7 cd 1f 24			call macro_forth_dsp 
3cca				endm 
# End of macro FORTH_DSP
3cca					;v5 FORTH_DSP_VALUE 
3cca 7e					ld a,(hl)	; get type of value on TOS 
3ccb fe 02				cp DS_TYPE_INUM  
3ccd 28 00				jr z, .eq_inum 
3ccf			 
3ccf				if FORTH_ENABLE_FLOATMATH 
3ccf					jr .eq_done 
3ccf			 
3ccf				endif 
3ccf					 
3ccf			 
3ccf			.eq_inum: 
3ccf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccf cd 59 24			call macro_dsp_valuehl 
3cd2				endm 
# End of macro FORTH_DSP_VALUEHL
3cd2			 
3cd2 e5					push hl 
3cd3			 
3cd3					; destroy value TOS 
3cd3			 
3cd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd3 cd 11 25			call macro_forth_dsp_pop 
3cd6				endm 
# End of macro FORTH_DSP_POP
3cd6			 
3cd6			 
3cd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd6 cd 59 24			call macro_dsp_valuehl 
3cd9				endm 
# End of macro FORTH_DSP_VALUEHL
3cd9			 
3cd9					; one value on hl get other one back 
3cd9			 
3cd9 e5					push hl 
3cda			 
3cda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cda cd 11 25			call macro_forth_dsp_pop 
3cdd				endm 
# End of macro FORTH_DSP_POP
3cdd			 
3cdd 0e 00				ld c, FORTH_FALSE 
3cdf			 
3cdf e1					pop hl 
3ce0 d1					pop de 
3ce1			 
3ce1 7b					ld a, e 
3ce2 bd					cp l 
3ce3			 
3ce3 20 06				jr nz, .eq_done 
3ce5			 
3ce5 7a					ld a, d 
3ce6 bc					cp h 
3ce7			 
3ce7 20 02				jr nz, .eq_done 
3ce9			 
3ce9 0e 01				ld c, FORTH_TRUE 
3ceb					 
3ceb			 
3ceb			 
3ceb			.eq_done: 
3ceb			 
3ceb					; TODO push value back onto stack for another op etc 
3ceb			 
3ceb 26 00				ld h, 0 
3ced 69					ld l, c 
3cee					if DEBUG_FORTH_WORDS 
3cee						DMARK "EQ1" 
3cee f5				push af  
3cef 3a 03 3d			ld a, (.dmark)  
3cf2 32 a6 fd			ld (debug_mark),a  
3cf5 3a 04 3d			ld a, (.dmark+1)  
3cf8 32 a7 fd			ld (debug_mark+1),a  
3cfb 3a 05 3d			ld a, (.dmark+2)  
3cfe 32 a8 fd			ld (debug_mark+2),a  
3d01 18 03			jr .pastdmark  
3d03 ..			.dmark: db "EQ1"  
3d06 f1			.pastdmark: pop af  
3d07			endm  
# End of macro DMARK
3d07						CALLMONITOR 
3d07 cd aa fd			call debug_vector  
3d0a				endm  
# End of macro CALLMONITOR
3d0a					endif 
3d0a cd 62 22				call forth_push_numhl 
3d0d			 
3d0d					NEXTW 
3d0d c3 0f 26			jp macro_next 
3d10				endm 
# End of macro NEXTW
3d10			 
3d10			 
3d10			.ENDLOGIC: 
3d10			; eof 
3d10			 
3d10			 
# End of file forth_words_logic.asm
3d10			include "forth_words_maths.asm" 
3d10			 
3d10			; | ## Maths Words 
3d10			 
3d10			.PLUS:	 
3d10				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3d10 15				db WORD_SYS_CORE+1             
3d11 6e 3d			dw .NEG            
3d13 02				db 1 + 1 
3d14 .. 00			db "+",0              
3d16				endm 
# End of macro CWHEAD
3d16			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3d16					if DEBUG_FORTH_WORDS_KEY 
3d16						DMARK "PLU" 
3d16 f5				push af  
3d17 3a 2b 3d			ld a, (.dmark)  
3d1a 32 a6 fd			ld (debug_mark),a  
3d1d 3a 2c 3d			ld a, (.dmark+1)  
3d20 32 a7 fd			ld (debug_mark+1),a  
3d23 3a 2d 3d			ld a, (.dmark+2)  
3d26 32 a8 fd			ld (debug_mark+2),a  
3d29 18 03			jr .pastdmark  
3d2b ..			.dmark: db "PLU"  
3d2e f1			.pastdmark: pop af  
3d2f			endm  
# End of macro DMARK
3d2f						CALLMONITOR 
3d2f cd aa fd			call debug_vector  
3d32				endm  
# End of macro CALLMONITOR
3d32					endif 
3d32					; add top two values and push back result 
3d32			 
3d32					;for v5 FORTH_DSP_VALUE 
3d32					FORTH_DSP 
3d32 cd 1f 24			call macro_forth_dsp 
3d35				endm 
# End of macro FORTH_DSP
3d35 7e					ld a,(hl)	; get type of value on TOS 
3d36 fe 02				cp DS_TYPE_INUM  
3d38 28 03				jr z, .dot_inum 
3d3a			 
3d3a					NEXTW 
3d3a c3 0f 26			jp macro_next 
3d3d				endm 
# End of macro NEXTW
3d3d			 
3d3d			; float maths 
3d3d			 
3d3d				if FORTH_ENABLE_FLOATMATH 
3d3d						inc hl      ; now at start of numeric as string 
3d3d			 
3d3d					if DEBUG_FORTH_MATHS 
3d3d						DMARK "ADD" 
3d3d				CALLMONITOR 
3d3d					endif 
3d3d			 
3d3d					;ld ix, hl 
3d3d					call CON 
3d3d			 
3d3d			 
3d3d					push hl 
3d3d					 
3d3d					 
3d3d			 
3d3d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3d3d			 
3d3d					; get next number 
3d3d			 
3d3d						FORTH_DSP_VALUE 
3d3d			 
3d3d						inc hl      ; now at start of numeric as string 
3d3d			 
3d3d					;ld ix, hl 
3d3d					call CON 
3d3d			 
3d3d					push hl 
3d3d			 
3d3d			 
3d3d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3d			 
3d3d						; TODO do add 
3d3d			 
3d3d						call IADD 
3d3d			 
3d3d						; TODO get result back as ascii 
3d3d			 
3d3d						; TODO push result  
3d3d			 
3d3d			 
3d3d			 
3d3d						jr .dot_done 
3d3d				endif 
3d3d			 
3d3d			.dot_inum: 
3d3d			 
3d3d			 
3d3d					if DEBUG_FORTH_DOT 
3d3d						DMARK "+IT" 
3d3d f5				push af  
3d3e 3a 52 3d			ld a, (.dmark)  
3d41 32 a6 fd			ld (debug_mark),a  
3d44 3a 53 3d			ld a, (.dmark+1)  
3d47 32 a7 fd			ld (debug_mark+1),a  
3d4a 3a 54 3d			ld a, (.dmark+2)  
3d4d 32 a8 fd			ld (debug_mark+2),a  
3d50 18 03			jr .pastdmark  
3d52 ..			.dmark: db "+IT"  
3d55 f1			.pastdmark: pop af  
3d56			endm  
# End of macro DMARK
3d56				CALLMONITOR 
3d56 cd aa fd			call debug_vector  
3d59				endm  
# End of macro CALLMONITOR
3d59					endif 
3d59			 
3d59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d59 cd 59 24			call macro_dsp_valuehl 
3d5c				endm 
# End of macro FORTH_DSP_VALUEHL
3d5c			 
3d5c				; TODO add floating point number detection 
3d5c			 
3d5c e5					push hl 
3d5d			 
3d5d					; destroy value TOS 
3d5d			 
3d5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d5d cd 11 25			call macro_forth_dsp_pop 
3d60				endm 
# End of macro FORTH_DSP_POP
3d60			 
3d60			 
3d60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d60 cd 59 24			call macro_dsp_valuehl 
3d63				endm 
# End of macro FORTH_DSP_VALUEHL
3d63			 
3d63					; one value on hl get other one back 
3d63			 
3d63 d1					pop de 
3d64			 
3d64					; do the add 
3d64			 
3d64 19					add hl,de 
3d65			 
3d65					; save it 
3d65			 
3d65			;		push hl	 
3d65			 
3d65					; 
3d65			 
3d65					; destroy value TOS 
3d65			 
3d65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d65 cd 11 25			call macro_forth_dsp_pop 
3d68				endm 
# End of macro FORTH_DSP_POP
3d68			 
3d68					; TODO push value back onto stack for another op etc 
3d68			 
3d68			;		pop hl 
3d68			 
3d68			.dot_done: 
3d68 cd 62 22				call forth_push_numhl 
3d6b			 
3d6b					NEXTW 
3d6b c3 0f 26			jp macro_next 
3d6e				endm 
# End of macro NEXTW
3d6e			.NEG: 
3d6e			 
3d6e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3d6e 17				db WORD_SYS_CORE+3             
3d6f b1 3d			dw .DIV            
3d71 02				db 1 + 1 
3d72 .. 00			db "-",0              
3d74				endm 
# End of macro CWHEAD
3d74			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3d74					if DEBUG_FORTH_WORDS_KEY 
3d74						DMARK "SUB" 
3d74 f5				push af  
3d75 3a 89 3d			ld a, (.dmark)  
3d78 32 a6 fd			ld (debug_mark),a  
3d7b 3a 8a 3d			ld a, (.dmark+1)  
3d7e 32 a7 fd			ld (debug_mark+1),a  
3d81 3a 8b 3d			ld a, (.dmark+2)  
3d84 32 a8 fd			ld (debug_mark+2),a  
3d87 18 03			jr .pastdmark  
3d89 ..			.dmark: db "SUB"  
3d8c f1			.pastdmark: pop af  
3d8d			endm  
# End of macro DMARK
3d8d						CALLMONITOR 
3d8d cd aa fd			call debug_vector  
3d90				endm  
# End of macro CALLMONITOR
3d90					endif 
3d90			 
3d90			 
3d90				; TODO add floating point number detection 
3d90					; v5 FORTH_DSP_VALUE 
3d90					FORTH_DSP 
3d90 cd 1f 24			call macro_forth_dsp 
3d93				endm 
# End of macro FORTH_DSP
3d93 7e					ld a,(hl)	; get type of value on TOS 
3d94 fe 02				cp DS_TYPE_INUM  
3d96 28 03				jr z, .neg_inum 
3d98			 
3d98					NEXTW 
3d98 c3 0f 26			jp macro_next 
3d9b				endm 
# End of macro NEXTW
3d9b			 
3d9b			; float maths 
3d9b			 
3d9b				if FORTH_ENABLE_FLOATMATH 
3d9b					jr .neg_done 
3d9b			 
3d9b				endif 
3d9b					 
3d9b			 
3d9b			.neg_inum: 
3d9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d9b cd 59 24			call macro_dsp_valuehl 
3d9e				endm 
# End of macro FORTH_DSP_VALUEHL
3d9e			 
3d9e e5					push hl 
3d9f			 
3d9f					; destroy value TOS 
3d9f			 
3d9f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d9f cd 11 25			call macro_forth_dsp_pop 
3da2				endm 
# End of macro FORTH_DSP_POP
3da2			 
3da2			 
3da2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3da2 cd 59 24			call macro_dsp_valuehl 
3da5				endm 
# End of macro FORTH_DSP_VALUEHL
3da5			 
3da5					; one value on hl get other one back 
3da5			 
3da5 d1					pop de 
3da6			 
3da6					; do the sub 
3da6			;		ex de, hl 
3da6			 
3da6 ed 52				sbc hl,de 
3da8			 
3da8					; save it 
3da8			 
3da8			;		push hl	 
3da8			 
3da8					; 
3da8			 
3da8					; destroy value TOS 
3da8			 
3da8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3da8 cd 11 25			call macro_forth_dsp_pop 
3dab				endm 
# End of macro FORTH_DSP_POP
3dab			 
3dab					; TODO push value back onto stack for another op etc 
3dab			 
3dab			;		pop hl 
3dab			 
3dab cd 62 22				call forth_push_numhl 
3dae			.neg_done: 
3dae			 
3dae					NEXTW 
3dae c3 0f 26			jp macro_next 
3db1				endm 
# End of macro NEXTW
3db1			.DIV: 
3db1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3db1 18				db WORD_SYS_CORE+4             
3db2 fe 3d			dw .MUL            
3db4 02				db 1 + 1 
3db5 .. 00			db "/",0              
3db7				endm 
# End of macro CWHEAD
3db7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3db7					if DEBUG_FORTH_WORDS_KEY 
3db7						DMARK "DIV" 
3db7 f5				push af  
3db8 3a cc 3d			ld a, (.dmark)  
3dbb 32 a6 fd			ld (debug_mark),a  
3dbe 3a cd 3d			ld a, (.dmark+1)  
3dc1 32 a7 fd			ld (debug_mark+1),a  
3dc4 3a ce 3d			ld a, (.dmark+2)  
3dc7 32 a8 fd			ld (debug_mark+2),a  
3dca 18 03			jr .pastdmark  
3dcc ..			.dmark: db "DIV"  
3dcf f1			.pastdmark: pop af  
3dd0			endm  
# End of macro DMARK
3dd0						CALLMONITOR 
3dd0 cd aa fd			call debug_vector  
3dd3				endm  
# End of macro CALLMONITOR
3dd3					endif 
3dd3				; TODO add floating point number detection 
3dd3					; v5 FORTH_DSP_VALUE 
3dd3					FORTH_DSP 
3dd3 cd 1f 24			call macro_forth_dsp 
3dd6				endm 
# End of macro FORTH_DSP
3dd6 7e					ld a,(hl)	; get type of value on TOS 
3dd7 fe 02				cp DS_TYPE_INUM  
3dd9 28 03				jr z, .div_inum 
3ddb			 
3ddb				if FORTH_ENABLE_FLOATMATH 
3ddb					jr .div_done 
3ddb			 
3ddb				endif 
3ddb					NEXTW 
3ddb c3 0f 26			jp macro_next 
3dde				endm 
# End of macro NEXTW
3dde			.div_inum: 
3dde			 
3dde					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dde cd 59 24			call macro_dsp_valuehl 
3de1				endm 
# End of macro FORTH_DSP_VALUEHL
3de1			 
3de1 e5					push hl    ; to go to bc 
3de2			 
3de2					; destroy value TOS 
3de2			 
3de2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de2 cd 11 25			call macro_forth_dsp_pop 
3de5				endm 
# End of macro FORTH_DSP_POP
3de5			 
3de5			 
3de5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3de5 cd 59 24			call macro_dsp_valuehl 
3de8				endm 
# End of macro FORTH_DSP_VALUEHL
3de8			 
3de8					; hl to go to de 
3de8			 
3de8 e5					push hl 
3de9			 
3de9 c1					pop bc 
3dea d1					pop de		 
3deb			 
3deb			 
3deb					if DEBUG_FORTH_MATHS 
3deb						DMARK "DIV" 
3deb				CALLMONITOR 
3deb					endif 
3deb					; one value on hl but move to a get other one back 
3deb			 
3deb			        
3deb cd 2c 0f			call Div16 
3dee			 
3dee			;	push af	 
3dee e5				push hl 
3def c5				push bc 
3df0			 
3df0					if DEBUG_FORTH_MATHS 
3df0						DMARK "DI1" 
3df0				CALLMONITOR 
3df0					endif 
3df0			 
3df0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df0 cd 11 25			call macro_forth_dsp_pop 
3df3				endm 
# End of macro FORTH_DSP_POP
3df3			 
3df3			 
3df3			 
3df3 e1					pop hl    ; result 
3df4			 
3df4 cd 62 22				call forth_push_numhl 
3df7			 
3df7 e1					pop hl    ; reminder 
3df8			;		ld h,0 
3df8			;		ld l,d 
3df8			 
3df8 cd 62 22				call forth_push_numhl 
3dfb			.div_done: 
3dfb					NEXTW 
3dfb c3 0f 26			jp macro_next 
3dfe				endm 
# End of macro NEXTW
3dfe			.MUL: 
3dfe				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3dfe 19				db WORD_SYS_CORE+5             
3dff 43 3e			dw .MIN            
3e01 02				db 1 + 1 
3e02 .. 00			db "*",0              
3e04				endm 
# End of macro CWHEAD
3e04			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3e04				; TODO add floating point number detection 
3e04					if DEBUG_FORTH_WORDS_KEY 
3e04						DMARK "MUL" 
3e04 f5				push af  
3e05 3a 19 3e			ld a, (.dmark)  
3e08 32 a6 fd			ld (debug_mark),a  
3e0b 3a 1a 3e			ld a, (.dmark+1)  
3e0e 32 a7 fd			ld (debug_mark+1),a  
3e11 3a 1b 3e			ld a, (.dmark+2)  
3e14 32 a8 fd			ld (debug_mark+2),a  
3e17 18 03			jr .pastdmark  
3e19 ..			.dmark: db "MUL"  
3e1c f1			.pastdmark: pop af  
3e1d			endm  
# End of macro DMARK
3e1d						CALLMONITOR 
3e1d cd aa fd			call debug_vector  
3e20				endm  
# End of macro CALLMONITOR
3e20					endif 
3e20					FORTH_DSP 
3e20 cd 1f 24			call macro_forth_dsp 
3e23				endm 
# End of macro FORTH_DSP
3e23					; v5 FORTH_DSP_VALUE 
3e23 7e					ld a,(hl)	; get type of value on TOS 
3e24 fe 02				cp DS_TYPE_INUM  
3e26 28 03				jr z, .mul_inum 
3e28			 
3e28				if FORTH_ENABLE_FLOATMATH 
3e28					jr .mul_done 
3e28			 
3e28				endif 
3e28			 
3e28					NEXTW 
3e28 c3 0f 26			jp macro_next 
3e2b				endm 
# End of macro NEXTW
3e2b			.mul_inum:	 
3e2b			 
3e2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e2b cd 59 24			call macro_dsp_valuehl 
3e2e				endm 
# End of macro FORTH_DSP_VALUEHL
3e2e			 
3e2e e5					push hl 
3e2f			 
3e2f					; destroy value TOS 
3e2f			 
3e2f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e2f cd 11 25			call macro_forth_dsp_pop 
3e32				endm 
# End of macro FORTH_DSP_POP
3e32			 
3e32			 
3e32					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e32 cd 59 24			call macro_dsp_valuehl 
3e35				endm 
# End of macro FORTH_DSP_VALUEHL
3e35			 
3e35					; one value on hl but move to a get other one back 
3e35			 
3e35 7d					ld a, l 
3e36			 
3e36 d1					pop de 
3e37			 
3e37					; do the mull 
3e37			;		ex de, hl 
3e37			 
3e37 cd 52 0f				call Mult16 
3e3a					; save it 
3e3a			 
3e3a			;		push hl	 
3e3a			 
3e3a					; 
3e3a			 
3e3a					; destroy value TOS 
3e3a			 
3e3a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3a cd 11 25			call macro_forth_dsp_pop 
3e3d				endm 
# End of macro FORTH_DSP_POP
3e3d			 
3e3d					; TODO push value back onto stack for another op etc 
3e3d			 
3e3d			;		pop hl 
3e3d			 
3e3d cd 62 22				call forth_push_numhl 
3e40			 
3e40			.mul_done: 
3e40					NEXTW 
3e40 c3 0f 26			jp macro_next 
3e43				endm 
# End of macro NEXTW
3e43			 
3e43			 
3e43			 
3e43			 
3e43			.MIN: 
3e43				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3e43 49				db WORD_SYS_CORE+53             
3e44 c4 3e			dw .MAX            
3e46 04				db 3 + 1 
3e47 .. 00			db "MIN",0              
3e4b				endm 
# End of macro CWHEAD
3e4b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3e4b					if DEBUG_FORTH_WORDS_KEY 
3e4b						DMARK "MIN" 
3e4b f5				push af  
3e4c 3a 60 3e			ld a, (.dmark)  
3e4f 32 a6 fd			ld (debug_mark),a  
3e52 3a 61 3e			ld a, (.dmark+1)  
3e55 32 a7 fd			ld (debug_mark+1),a  
3e58 3a 62 3e			ld a, (.dmark+2)  
3e5b 32 a8 fd			ld (debug_mark+2),a  
3e5e 18 03			jr .pastdmark  
3e60 ..			.dmark: db "MIN"  
3e63 f1			.pastdmark: pop af  
3e64			endm  
# End of macro DMARK
3e64						CALLMONITOR 
3e64 cd aa fd			call debug_vector  
3e67				endm  
# End of macro CALLMONITOR
3e67					endif 
3e67					; get u2 
3e67			 
3e67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e67 cd 59 24			call macro_dsp_valuehl 
3e6a				endm 
# End of macro FORTH_DSP_VALUEHL
3e6a			 
3e6a e5					push hl   ; u2 
3e6b			 
3e6b					; destroy value TOS 
3e6b			 
3e6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e6b cd 11 25			call macro_forth_dsp_pop 
3e6e				endm 
# End of macro FORTH_DSP_POP
3e6e			 
3e6e					; get u1 
3e6e			 
3e6e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e6e cd 59 24			call macro_dsp_valuehl 
3e71				endm 
# End of macro FORTH_DSP_VALUEHL
3e71			 
3e71 e5					push hl  ; u1 
3e72			 
3e72					; destroy value TOS 
3e72			 
3e72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e72 cd 11 25			call macro_forth_dsp_pop 
3e75				endm 
# End of macro FORTH_DSP_POP
3e75			 
3e75 b7			 or a      ;clear carry flag 
3e76 e1			  pop hl    ; u1 
3e77 d1			  pop de    ; u2 
3e78 e5				push hl   ; saved in case hl is lowest 
3e79 ed 52		  sbc hl,de 
3e7b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3e7d			 
3e7d e1				pop hl 
3e7e					if DEBUG_FORTH_WORDS 
3e7e						DMARK "MIN" 
3e7e f5				push af  
3e7f 3a 93 3e			ld a, (.dmark)  
3e82 32 a6 fd			ld (debug_mark),a  
3e85 3a 94 3e			ld a, (.dmark+1)  
3e88 32 a7 fd			ld (debug_mark+1),a  
3e8b 3a 95 3e			ld a, (.dmark+2)  
3e8e 32 a8 fd			ld (debug_mark+2),a  
3e91 18 03			jr .pastdmark  
3e93 ..			.dmark: db "MIN"  
3e96 f1			.pastdmark: pop af  
3e97			endm  
# End of macro DMARK
3e97						CALLMONITOR 
3e97 cd aa fd			call debug_vector  
3e9a				endm  
# End of macro CALLMONITOR
3e9a					endif 
3e9a cd 62 22				call forth_push_numhl 
3e9d			 
3e9d				       NEXTW 
3e9d c3 0f 26			jp macro_next 
3ea0				endm 
# End of macro NEXTW
3ea0			 
3ea0			.mincont:  
3ea0 c1				pop bc   ; tidy up 
3ea1 eb				ex de , hl  
3ea2					if DEBUG_FORTH_WORDS 
3ea2						DMARK "MI1" 
3ea2 f5				push af  
3ea3 3a b7 3e			ld a, (.dmark)  
3ea6 32 a6 fd			ld (debug_mark),a  
3ea9 3a b8 3e			ld a, (.dmark+1)  
3eac 32 a7 fd			ld (debug_mark+1),a  
3eaf 3a b9 3e			ld a, (.dmark+2)  
3eb2 32 a8 fd			ld (debug_mark+2),a  
3eb5 18 03			jr .pastdmark  
3eb7 ..			.dmark: db "MI1"  
3eba f1			.pastdmark: pop af  
3ebb			endm  
# End of macro DMARK
3ebb						CALLMONITOR 
3ebb cd aa fd			call debug_vector  
3ebe				endm  
# End of macro CALLMONITOR
3ebe					endif 
3ebe cd 62 22				call forth_push_numhl 
3ec1			 
3ec1				       NEXTW 
3ec1 c3 0f 26			jp macro_next 
3ec4				endm 
# End of macro NEXTW
3ec4			.MAX: 
3ec4				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3ec4 4a				db WORD_SYS_CORE+54             
3ec5 45 3f			dw .RND16            
3ec7 04				db 3 + 1 
3ec8 .. 00			db "MAX",0              
3ecc				endm 
# End of macro CWHEAD
3ecc			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3ecc					if DEBUG_FORTH_WORDS_KEY 
3ecc						DMARK "MAX" 
3ecc f5				push af  
3ecd 3a e1 3e			ld a, (.dmark)  
3ed0 32 a6 fd			ld (debug_mark),a  
3ed3 3a e2 3e			ld a, (.dmark+1)  
3ed6 32 a7 fd			ld (debug_mark+1),a  
3ed9 3a e3 3e			ld a, (.dmark+2)  
3edc 32 a8 fd			ld (debug_mark+2),a  
3edf 18 03			jr .pastdmark  
3ee1 ..			.dmark: db "MAX"  
3ee4 f1			.pastdmark: pop af  
3ee5			endm  
# End of macro DMARK
3ee5						CALLMONITOR 
3ee5 cd aa fd			call debug_vector  
3ee8				endm  
# End of macro CALLMONITOR
3ee8					endif 
3ee8					; get u2 
3ee8			 
3ee8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee8 cd 59 24			call macro_dsp_valuehl 
3eeb				endm 
# End of macro FORTH_DSP_VALUEHL
3eeb			 
3eeb e5					push hl   ; u2 
3eec			 
3eec					; destroy value TOS 
3eec			 
3eec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eec cd 11 25			call macro_forth_dsp_pop 
3eef				endm 
# End of macro FORTH_DSP_POP
3eef			 
3eef					; get u1 
3eef			 
3eef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eef cd 59 24			call macro_dsp_valuehl 
3ef2				endm 
# End of macro FORTH_DSP_VALUEHL
3ef2			 
3ef2 e5					push hl  ; u1 
3ef3			 
3ef3					; destroy value TOS 
3ef3			 
3ef3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef3 cd 11 25			call macro_forth_dsp_pop 
3ef6				endm 
# End of macro FORTH_DSP_POP
3ef6			 
3ef6 b7			 or a      ;clear carry flag 
3ef7 e1			  pop hl    ; u1 
3ef8 d1			  pop de    ; u2 
3ef9 e5				push hl   ; saved in case hl is lowest 
3efa ed 52		  sbc hl,de 
3efc 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3efe			 
3efe e1				pop hl 
3eff					if DEBUG_FORTH_WORDS 
3eff						DMARK "MAX" 
3eff f5				push af  
3f00 3a 14 3f			ld a, (.dmark)  
3f03 32 a6 fd			ld (debug_mark),a  
3f06 3a 15 3f			ld a, (.dmark+1)  
3f09 32 a7 fd			ld (debug_mark+1),a  
3f0c 3a 16 3f			ld a, (.dmark+2)  
3f0f 32 a8 fd			ld (debug_mark+2),a  
3f12 18 03			jr .pastdmark  
3f14 ..			.dmark: db "MAX"  
3f17 f1			.pastdmark: pop af  
3f18			endm  
# End of macro DMARK
3f18						CALLMONITOR 
3f18 cd aa fd			call debug_vector  
3f1b				endm  
# End of macro CALLMONITOR
3f1b					endif 
3f1b cd 62 22				call forth_push_numhl 
3f1e			 
3f1e				       NEXTW 
3f1e c3 0f 26			jp macro_next 
3f21				endm 
# End of macro NEXTW
3f21			 
3f21			.maxcont:  
3f21 c1				pop bc   ; tidy up 
3f22 eb				ex de , hl  
3f23					if DEBUG_FORTH_WORDS 
3f23						DMARK "MA1" 
3f23 f5				push af  
3f24 3a 38 3f			ld a, (.dmark)  
3f27 32 a6 fd			ld (debug_mark),a  
3f2a 3a 39 3f			ld a, (.dmark+1)  
3f2d 32 a7 fd			ld (debug_mark+1),a  
3f30 3a 3a 3f			ld a, (.dmark+2)  
3f33 32 a8 fd			ld (debug_mark+2),a  
3f36 18 03			jr .pastdmark  
3f38 ..			.dmark: db "MA1"  
3f3b f1			.pastdmark: pop af  
3f3c			endm  
# End of macro DMARK
3f3c						CALLMONITOR 
3f3c cd aa fd			call debug_vector  
3f3f				endm  
# End of macro CALLMONITOR
3f3f					endif 
3f3f cd 62 22				call forth_push_numhl 
3f42				       NEXTW 
3f42 c3 0f 26			jp macro_next 
3f45				endm 
# End of macro NEXTW
3f45			 
3f45			.RND16: 
3f45				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3f45 4e				db WORD_SYS_CORE+58             
3f46 74 3f			dw .RND8            
3f48 06				db 5 + 1 
3f49 .. 00			db "RND16",0              
3f4f				endm 
# End of macro CWHEAD
3f4f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3f4f					if DEBUG_FORTH_WORDS_KEY 
3f4f						DMARK "R16" 
3f4f f5				push af  
3f50 3a 64 3f			ld a, (.dmark)  
3f53 32 a6 fd			ld (debug_mark),a  
3f56 3a 65 3f			ld a, (.dmark+1)  
3f59 32 a7 fd			ld (debug_mark+1),a  
3f5c 3a 66 3f			ld a, (.dmark+2)  
3f5f 32 a8 fd			ld (debug_mark+2),a  
3f62 18 03			jr .pastdmark  
3f64 ..			.dmark: db "R16"  
3f67 f1			.pastdmark: pop af  
3f68			endm  
# End of macro DMARK
3f68						CALLMONITOR 
3f68 cd aa fd			call debug_vector  
3f6b				endm  
# End of macro CALLMONITOR
3f6b					endif 
3f6b cd f6 0e				call prng16  
3f6e cd 62 22				call forth_push_numhl 
3f71				       NEXTW 
3f71 c3 0f 26			jp macro_next 
3f74				endm 
# End of macro NEXTW
3f74			.RND8: 
3f74				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3f74 60				db WORD_SYS_CORE+76             
3f75 a9 3f			dw .RND            
3f77 05				db 4 + 1 
3f78 .. 00			db "RND8",0              
3f7d				endm 
# End of macro CWHEAD
3f7d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3f7d					if DEBUG_FORTH_WORDS_KEY 
3f7d						DMARK "RN8" 
3f7d f5				push af  
3f7e 3a 92 3f			ld a, (.dmark)  
3f81 32 a6 fd			ld (debug_mark),a  
3f84 3a 93 3f			ld a, (.dmark+1)  
3f87 32 a7 fd			ld (debug_mark+1),a  
3f8a 3a 94 3f			ld a, (.dmark+2)  
3f8d 32 a8 fd			ld (debug_mark+2),a  
3f90 18 03			jr .pastdmark  
3f92 ..			.dmark: db "RN8"  
3f95 f1			.pastdmark: pop af  
3f96			endm  
# End of macro DMARK
3f96						CALLMONITOR 
3f96 cd aa fd			call debug_vector  
3f99				endm  
# End of macro CALLMONITOR
3f99					endif 
3f99 2a e4 fa				ld hl,(xrandc) 
3f9c 23					inc hl 
3f9d cd 10 0f				call xrnd 
3fa0 6f					ld l,a	 
3fa1 26 00				ld h,0 
3fa3 cd 62 22				call forth_push_numhl 
3fa6				       NEXTW 
3fa6 c3 0f 26			jp macro_next 
3fa9				endm 
# End of macro NEXTW
3fa9			.RND: 
3fa9				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3fa9 60				db WORD_SYS_CORE+76             
3faa af 40			dw .ENDMATHS            
3fac 04				db 3 + 1 
3fad .. 00			db "RND",0              
3fb1				endm 
# End of macro CWHEAD
3fb1			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3fb1			 
3fb1					if DEBUG_FORTH_WORDS_KEY 
3fb1						DMARK "RND" 
3fb1 f5				push af  
3fb2 3a c6 3f			ld a, (.dmark)  
3fb5 32 a6 fd			ld (debug_mark),a  
3fb8 3a c7 3f			ld a, (.dmark+1)  
3fbb 32 a7 fd			ld (debug_mark+1),a  
3fbe 3a c8 3f			ld a, (.dmark+2)  
3fc1 32 a8 fd			ld (debug_mark+2),a  
3fc4 18 03			jr .pastdmark  
3fc6 ..			.dmark: db "RND"  
3fc9 f1			.pastdmark: pop af  
3fca			endm  
# End of macro DMARK
3fca						CALLMONITOR 
3fca cd aa fd			call debug_vector  
3fcd				endm  
# End of macro CALLMONITOR
3fcd					endif 
3fcd					 
3fcd					FORTH_DSP_VALUEHL    ; upper range 
3fcd cd 59 24			call macro_dsp_valuehl 
3fd0				endm 
# End of macro FORTH_DSP_VALUEHL
3fd0			 
3fd0 22 e8 fa				ld (LFSRSeed), hl	 
3fd3			 
3fd3					if DEBUG_FORTH_WORDS 
3fd3						DMARK "RN1" 
3fd3 f5				push af  
3fd4 3a e8 3f			ld a, (.dmark)  
3fd7 32 a6 fd			ld (debug_mark),a  
3fda 3a e9 3f			ld a, (.dmark+1)  
3fdd 32 a7 fd			ld (debug_mark+1),a  
3fe0 3a ea 3f			ld a, (.dmark+2)  
3fe3 32 a8 fd			ld (debug_mark+2),a  
3fe6 18 03			jr .pastdmark  
3fe8 ..			.dmark: db "RN1"  
3feb f1			.pastdmark: pop af  
3fec			endm  
# End of macro DMARK
3fec						CALLMONITOR 
3fec cd aa fd			call debug_vector  
3fef				endm  
# End of macro CALLMONITOR
3fef					endif 
3fef					FORTH_DSP_POP 
3fef cd 11 25			call macro_forth_dsp_pop 
3ff2				endm 
# End of macro FORTH_DSP_POP
3ff2			 
3ff2					FORTH_DSP_VALUEHL    ; low range 
3ff2 cd 59 24			call macro_dsp_valuehl 
3ff5				endm 
# End of macro FORTH_DSP_VALUEHL
3ff5			 
3ff5					if DEBUG_FORTH_WORDS 
3ff5						DMARK "RN2" 
3ff5 f5				push af  
3ff6 3a 0a 40			ld a, (.dmark)  
3ff9 32 a6 fd			ld (debug_mark),a  
3ffc 3a 0b 40			ld a, (.dmark+1)  
3fff 32 a7 fd			ld (debug_mark+1),a  
4002 3a 0c 40			ld a, (.dmark+2)  
4005 32 a8 fd			ld (debug_mark+2),a  
4008 18 03			jr .pastdmark  
400a ..			.dmark: db "RN2"  
400d f1			.pastdmark: pop af  
400e			endm  
# End of macro DMARK
400e						CALLMONITOR 
400e cd aa fd			call debug_vector  
4011				endm  
# End of macro CALLMONITOR
4011					endif 
4011 22 ea fa				ld (LFSRSeed+2), hl 
4014			 
4014					FORTH_DSP_POP 
4014 cd 11 25			call macro_forth_dsp_pop 
4017				endm 
# End of macro FORTH_DSP_POP
4017			 
4017 e5					push hl 
4018			 
4018 e1			.inrange:	pop hl 
4019 cd f6 0e				call prng16  
401c					if DEBUG_FORTH_WORDS 
401c						DMARK "RN3" 
401c f5				push af  
401d 3a 31 40			ld a, (.dmark)  
4020 32 a6 fd			ld (debug_mark),a  
4023 3a 32 40			ld a, (.dmark+1)  
4026 32 a7 fd			ld (debug_mark+1),a  
4029 3a 33 40			ld a, (.dmark+2)  
402c 32 a8 fd			ld (debug_mark+2),a  
402f 18 03			jr .pastdmark  
4031 ..			.dmark: db "RN3"  
4034 f1			.pastdmark: pop af  
4035			endm  
# End of macro DMARK
4035						CALLMONITOR 
4035 cd aa fd			call debug_vector  
4038				endm  
# End of macro CALLMONITOR
4038					endif 
4038					 
4038					; if the range is 8bit knock out the high byte 
4038			 
4038 ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
403c			 
403c 3e 00				ld a, 0 
403e ba					cp d  
403f 20 1e				jr nz, .hirange 
4041 26 00				ld h, 0   ; knock it down to 8bit 
4043			 
4043					if DEBUG_FORTH_WORDS 
4043						DMARK "RNk" 
4043 f5				push af  
4044 3a 58 40			ld a, (.dmark)  
4047 32 a6 fd			ld (debug_mark),a  
404a 3a 59 40			ld a, (.dmark+1)  
404d 32 a7 fd			ld (debug_mark+1),a  
4050 3a 5a 40			ld a, (.dmark+2)  
4053 32 a8 fd			ld (debug_mark+2),a  
4056 18 03			jr .pastdmark  
4058 ..			.dmark: db "RNk"  
405b f1			.pastdmark: pop af  
405c			endm  
# End of macro DMARK
405c						CALLMONITOR 
405c cd aa fd			call debug_vector  
405f				endm  
# End of macro CALLMONITOR
405f					endif 
405f			.hirange:   
405f e5					push hl  
4060 b7					or a  
4061 ed 52		                sbc hl, de 
4063			 
4063					;call cmp16 
4063			 
4063 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
4065 e1					pop hl 
4066 e5					push hl 
4067			 
4067					if DEBUG_FORTH_WORDS 
4067						DMARK "RN4" 
4067 f5				push af  
4068 3a 7c 40			ld a, (.dmark)  
406b 32 a6 fd			ld (debug_mark),a  
406e 3a 7d 40			ld a, (.dmark+1)  
4071 32 a7 fd			ld (debug_mark+1),a  
4074 3a 7e 40			ld a, (.dmark+2)  
4077 32 a8 fd			ld (debug_mark+2),a  
407a 18 03			jr .pastdmark  
407c ..			.dmark: db "RN4"  
407f f1			.pastdmark: pop af  
4080			endm  
# End of macro DMARK
4080						CALLMONITOR 
4080 cd aa fd			call debug_vector  
4083				endm  
# End of macro CALLMONITOR
4083					endif 
4083 ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
4087					;call cmp16 
4087				 
4087 b7					or a  
4088 ed 52		                sbc hl, de 
408a 38 8c				jr c, .inrange 
408c			 
408c e1					pop hl 
408d					 
408d					if DEBUG_FORTH_WORDS 
408d						DMARK "RNd" 
408d f5				push af  
408e 3a a2 40			ld a, (.dmark)  
4091 32 a6 fd			ld (debug_mark),a  
4094 3a a3 40			ld a, (.dmark+1)  
4097 32 a7 fd			ld (debug_mark+1),a  
409a 3a a4 40			ld a, (.dmark+2)  
409d 32 a8 fd			ld (debug_mark+2),a  
40a0 18 03			jr .pastdmark  
40a2 ..			.dmark: db "RNd"  
40a5 f1			.pastdmark: pop af  
40a6			endm  
# End of macro DMARK
40a6						CALLMONITOR 
40a6 cd aa fd			call debug_vector  
40a9				endm  
# End of macro CALLMONITOR
40a9					endif 
40a9			 
40a9			 
40a9 cd 62 22				call forth_push_numhl 
40ac				       NEXTW 
40ac c3 0f 26			jp macro_next 
40af				endm 
# End of macro NEXTW
40af			 
40af			.ENDMATHS: 
40af			 
40af			; eof 
40af			 
# End of file forth_words_maths.asm
40af			include "forth_words_display.asm" 
40af			 
40af			; | ## Display Words 
40af			 
40af			.ACT: 
40af			 
40af				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
40af 62				db WORD_SYS_CORE+78             
40b0 fb 40			dw .INFO            
40b2 07				db 6 + 1 
40b3 .. 00			db "ACTIVE",0              
40ba				endm 
# End of macro CWHEAD
40ba			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
40ba			;  
40ba			; | | To display a pulsing activity indicator in a processing loop do this... 
40ba			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
40ba			 
40ba					if DEBUG_FORTH_WORDS_KEY 
40ba						DMARK "ACT" 
40ba f5				push af  
40bb 3a cf 40			ld a, (.dmark)  
40be 32 a6 fd			ld (debug_mark),a  
40c1 3a d0 40			ld a, (.dmark+1)  
40c4 32 a7 fd			ld (debug_mark+1),a  
40c7 3a d1 40			ld a, (.dmark+2)  
40ca 32 a8 fd			ld (debug_mark+2),a  
40cd 18 03			jr .pastdmark  
40cf ..			.dmark: db "ACT"  
40d2 f1			.pastdmark: pop af  
40d3			endm  
# End of macro DMARK
40d3						CALLMONITOR 
40d3 cd aa fd			call debug_vector  
40d6				endm  
# End of macro CALLMONITOR
40d6					endif 
40d6 cd f2 0c				call active 
40d9					if DEBUG_FORTH_WORDS 
40d9						DMARK "ACp" 
40d9 f5				push af  
40da 3a ee 40			ld a, (.dmark)  
40dd 32 a6 fd			ld (debug_mark),a  
40e0 3a ef 40			ld a, (.dmark+1)  
40e3 32 a7 fd			ld (debug_mark+1),a  
40e6 3a f0 40			ld a, (.dmark+2)  
40e9 32 a8 fd			ld (debug_mark+2),a  
40ec 18 03			jr .pastdmark  
40ee ..			.dmark: db "ACp"  
40f1 f1			.pastdmark: pop af  
40f2			endm  
# End of macro DMARK
40f2						CALLMONITOR 
40f2 cd aa fd			call debug_vector  
40f5				endm  
# End of macro CALLMONITOR
40f5					endif 
40f5 cd d0 22				call forth_push_str 
40f8			 
40f8					NEXTW 
40f8 c3 0f 26			jp macro_next 
40fb				endm 
# End of macro NEXTW
40fb			.INFO: 
40fb			 
40fb				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
40fb 62				db WORD_SYS_CORE+78             
40fc 18 41			dw .ATP            
40fe 05				db 4 + 1 
40ff .. 00			db "INFO",0              
4104				endm 
# End of macro CWHEAD
4104			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
4104					FORTH_DSP_VALUEHL 
4104 cd 59 24			call macro_dsp_valuehl 
4107				endm 
# End of macro FORTH_DSP_VALUEHL
4107			 
4107					FORTH_DSP_POP 
4107 cd 11 25			call macro_forth_dsp_pop 
410a				endm 
# End of macro FORTH_DSP_POP
410a			 
410a e5					push hl 
410b			 
410b					FORTH_DSP_VALUEHL 
410b cd 59 24			call macro_dsp_valuehl 
410e				endm 
# End of macro FORTH_DSP_VALUEHL
410e			 
410e					FORTH_DSP_POP 
410e cd 11 25			call macro_forth_dsp_pop 
4111				endm 
# End of macro FORTH_DSP_POP
4111			 
4111 d1					pop de 
4112			 
4112 cd 2c 0d				call info_panel 
4115			 
4115			 
4115					NEXTW 
4115 c3 0f 26			jp macro_next 
4118				endm 
# End of macro NEXTW
4118			.ATP: 
4118				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
4118 62				db WORD_SYS_CORE+78             
4119 8f 41			dw .FB            
411b 04				db 3 + 1 
411c .. 00			db "AT?",0              
4120				endm 
# End of macro CWHEAD
4120			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
4120					if DEBUG_FORTH_WORDS_KEY 
4120						DMARK "AT?" 
4120 f5				push af  
4121 3a 35 41			ld a, (.dmark)  
4124 32 a6 fd			ld (debug_mark),a  
4127 3a 36 41			ld a, (.dmark+1)  
412a 32 a7 fd			ld (debug_mark+1),a  
412d 3a 37 41			ld a, (.dmark+2)  
4130 32 a8 fd			ld (debug_mark+2),a  
4133 18 03			jr .pastdmark  
4135 ..			.dmark: db "AT?"  
4138 f1			.pastdmark: pop af  
4139			endm  
# End of macro DMARK
4139						CALLMONITOR 
4139 cd aa fd			call debug_vector  
413c				endm  
# End of macro CALLMONITOR
413c					endif 
413c 3a 99 f9				ld a, (f_cursor_ptr) 
413f			 
413f			if DEBUG_FORTH_WORDS 
413f				DMARK "AT?" 
413f f5				push af  
4140 3a 54 41			ld a, (.dmark)  
4143 32 a6 fd			ld (debug_mark),a  
4146 3a 55 41			ld a, (.dmark+1)  
4149 32 a7 fd			ld (debug_mark+1),a  
414c 3a 56 41			ld a, (.dmark+2)  
414f 32 a8 fd			ld (debug_mark+2),a  
4152 18 03			jr .pastdmark  
4154 ..			.dmark: db "AT?"  
4157 f1			.pastdmark: pop af  
4158			endm  
# End of macro DMARK
4158				CALLMONITOR 
4158 cd aa fd			call debug_vector  
415b				endm  
# End of macro CALLMONITOR
415b			endif	 
415b					; count the number of rows 
415b			 
415b 06 00				ld b, 0 
415d 4f			.atpr:		ld c, a    ; save in case we go below zero 
415e d6 28				sub display_cols 
4160 f2 66 41				jp p, .atprunder 
4163 04					inc b 
4164 18 f7				jr .atpr 
4166			.atprunder:	 
4166			if DEBUG_FORTH_WORDS 
4166				DMARK "A?2" 
4166 f5				push af  
4167 3a 7b 41			ld a, (.dmark)  
416a 32 a6 fd			ld (debug_mark),a  
416d 3a 7c 41			ld a, (.dmark+1)  
4170 32 a7 fd			ld (debug_mark+1),a  
4173 3a 7d 41			ld a, (.dmark+2)  
4176 32 a8 fd			ld (debug_mark+2),a  
4179 18 03			jr .pastdmark  
417b ..			.dmark: db "A?2"  
417e f1			.pastdmark: pop af  
417f			endm  
# End of macro DMARK
417f				CALLMONITOR 
417f cd aa fd			call debug_vector  
4182				endm  
# End of macro CALLMONITOR
4182			endif	 
4182 26 00				ld h, 0 
4184 69					ld l, c 
4185 cd 62 22				call forth_push_numhl 
4188 68					ld l, b  
4189 cd 62 22				call forth_push_numhl 
418c			 
418c			 
418c				NEXTW 
418c c3 0f 26			jp macro_next 
418f				endm 
# End of macro NEXTW
418f			 
418f			.FB: 
418f				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
418f 1b				db WORD_SYS_CORE+7             
4190 dd 41			dw .EMIT            
4192 03				db 2 + 1 
4193 .. 00			db "FB",0              
4196				endm 
# End of macro CWHEAD
4196			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4196			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4196			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4196			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4196					if DEBUG_FORTH_WORDS_KEY 
4196						DMARK "FB." 
4196 f5				push af  
4197 3a ab 41			ld a, (.dmark)  
419a 32 a6 fd			ld (debug_mark),a  
419d 3a ac 41			ld a, (.dmark+1)  
41a0 32 a7 fd			ld (debug_mark+1),a  
41a3 3a ad 41			ld a, (.dmark+2)  
41a6 32 a8 fd			ld (debug_mark+2),a  
41a9 18 03			jr .pastdmark  
41ab ..			.dmark: db "FB."  
41ae f1			.pastdmark: pop af  
41af			endm  
# End of macro DMARK
41af						CALLMONITOR 
41af cd aa fd			call debug_vector  
41b2				endm  
# End of macro CALLMONITOR
41b2					endif 
41b2			 
41b2					FORTH_DSP_VALUEHL 
41b2 cd 59 24			call macro_dsp_valuehl 
41b5				endm 
# End of macro FORTH_DSP_VALUEHL
41b5			 
41b5 7d					ld a, l 
41b6 fe 01				cp 1 
41b8 20 05				jr nz, .fbn1 
41ba 21 4b fc				ld hl, display_fb1 
41bd 18 15				jr .fbset 
41bf fe 02		.fbn1:		cp 2 
41c1 20 05				jr nz, .fbn2 
41c3 21 09 fb				ld hl, display_fb2 
41c6 18 0c				jr .fbset 
41c8 fe 03		.fbn2:		cp 3 
41ca 20 05				jr nz, .fbn3 
41cc 21 aa fb				ld hl, display_fb3 
41cf 18 03				jr .fbset 
41d1			.fbn3:		 ; if invalid number select first 
41d1 21 4b fc				ld hl, display_fb1 
41d4 22 07 fb		.fbset:		ld (display_fb_active), hl 
41d7			 
41d7					FORTH_DSP_POP 
41d7 cd 11 25			call macro_forth_dsp_pop 
41da				endm 
# End of macro FORTH_DSP_POP
41da			 
41da					NEXTW 
41da c3 0f 26			jp macro_next 
41dd				endm 
# End of macro NEXTW
41dd			 
41dd			 
41dd			.EMIT: 
41dd				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
41dd 1b				db WORD_SYS_CORE+7             
41de 2e 42			dw .DOTH            
41e0 05				db 4 + 1 
41e1 .. 00			db "EMIT",0              
41e6				endm 
# End of macro CWHEAD
41e6			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
41e6					; get value off TOS and display it 
41e6			 
41e6					if DEBUG_FORTH_WORDS_KEY 
41e6						DMARK "EMT" 
41e6 f5				push af  
41e7 3a fb 41			ld a, (.dmark)  
41ea 32 a6 fd			ld (debug_mark),a  
41ed 3a fc 41			ld a, (.dmark+1)  
41f0 32 a7 fd			ld (debug_mark+1),a  
41f3 3a fd 41			ld a, (.dmark+2)  
41f6 32 a8 fd			ld (debug_mark+2),a  
41f9 18 03			jr .pastdmark  
41fb ..			.dmark: db "EMT"  
41fe f1			.pastdmark: pop af  
41ff			endm  
# End of macro DMARK
41ff						CALLMONITOR 
41ff cd aa fd			call debug_vector  
4202				endm  
# End of macro CALLMONITOR
4202					endif 
4202			 
4202					FORTH_DSP_VALUEHL 
4202 cd 59 24			call macro_dsp_valuehl 
4205				endm 
# End of macro FORTH_DSP_VALUEHL
4205			 
4205 7d					ld a,l 
4206			 
4206					; TODO write to display 
4206			 
4206 32 fa f2				ld (os_input), a 
4209 3e 00				ld a, 0 
420b 32 fb f2				ld (os_input+1), a 
420e					 
420e 3a 99 f9				ld a, (f_cursor_ptr) 
4211 11 fa f2				ld de, os_input 
4214 cd ae 0d				call str_at_display 
4217			 
4217			 
4217 3a 77 f9				ld a,(cli_autodisplay) 
421a fe 00				cp 0 
421c 28 03				jr z, .enoupdate 
421e cd be 0d						call update_display 
4221					.enoupdate: 
4221			 
4221 3a 99 f9				ld a, (f_cursor_ptr) 
4224 3c					inc a 
4225 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
4228			 
4228			 
4228					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4228 cd 11 25			call macro_forth_dsp_pop 
422b				endm 
# End of macro FORTH_DSP_POP
422b			  
422b			 
422b					NEXTW 
422b c3 0f 26			jp macro_next 
422e				endm 
# End of macro NEXTW
422e			.DOTH: 
422e				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
422e 1c				db WORD_SYS_CORE+8             
422f 5e 42			dw .DOTF            
4231 03				db 2 + 1 
4232 .. 00			db ".-",0              
4235				endm 
# End of macro CWHEAD
4235			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4235					; get value off TOS and display it 
4235					if DEBUG_FORTH_WORDS_KEY 
4235						DMARK "DTD" 
4235 f5				push af  
4236 3a 4a 42			ld a, (.dmark)  
4239 32 a6 fd			ld (debug_mark),a  
423c 3a 4b 42			ld a, (.dmark+1)  
423f 32 a7 fd			ld (debug_mark+1),a  
4242 3a 4c 42			ld a, (.dmark+2)  
4245 32 a8 fd			ld (debug_mark+2),a  
4248 18 03			jr .pastdmark  
424a ..			.dmark: db "DTD"  
424d f1			.pastdmark: pop af  
424e			endm  
# End of macro DMARK
424e						CALLMONITOR 
424e cd aa fd			call debug_vector  
4251				endm  
# End of macro CALLMONITOR
4251					endif 
4251 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4253 3e 00			ld a, 0 
4255 32 78 f9			ld (cli_mvdot), a 
4258 c3 b5 42			jp .dotgo 
425b				NEXTW 
425b c3 0f 26			jp macro_next 
425e				endm 
# End of macro NEXTW
425e			.DOTF: 
425e				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
425e 1c				db WORD_SYS_CORE+8             
425f 8c 42			dw .DOT            
4261 03				db 2 + 1 
4262 .. 00			db ".>",0              
4265				endm 
# End of macro CWHEAD
4265			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4265					; get value off TOS and display it 
4265			        ; TODO BUG adds extra spaces 
4265			        ; TODO BUG handle numerics? 
4265					if DEBUG_FORTH_WORDS_KEY 
4265						DMARK "DTC" 
4265 f5				push af  
4266 3a 7a 42			ld a, (.dmark)  
4269 32 a6 fd			ld (debug_mark),a  
426c 3a 7b 42			ld a, (.dmark+1)  
426f 32 a7 fd			ld (debug_mark+1),a  
4272 3a 7c 42			ld a, (.dmark+2)  
4275 32 a8 fd			ld (debug_mark+2),a  
4278 18 03			jr .pastdmark  
427a ..			.dmark: db "DTC"  
427d f1			.pastdmark: pop af  
427e			endm  
# End of macro DMARK
427e						CALLMONITOR 
427e cd aa fd			call debug_vector  
4281				endm  
# End of macro CALLMONITOR
4281					endif 
4281 3e 01			ld a, 1 
4283 32 78 f9			ld (cli_mvdot), a 
4286 c3 b5 42			jp .dotgo 
4289				NEXTW 
4289 c3 0f 26			jp macro_next 
428c				endm 
# End of macro NEXTW
428c			 
428c			.DOT: 
428c				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
428c 1c				db WORD_SYS_CORE+8             
428d 68 44			dw .CLS            
428f 02				db 1 + 1 
4290 .. 00			db ".",0              
4292				endm 
# End of macro CWHEAD
4292			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4292					; get value off TOS and display it 
4292			 
4292					if DEBUG_FORTH_WORDS_KEY 
4292						DMARK "DOT" 
4292 f5				push af  
4293 3a a7 42			ld a, (.dmark)  
4296 32 a6 fd			ld (debug_mark),a  
4299 3a a8 42			ld a, (.dmark+1)  
429c 32 a7 fd			ld (debug_mark+1),a  
429f 3a a9 42			ld a, (.dmark+2)  
42a2 32 a8 fd			ld (debug_mark+2),a  
42a5 18 03			jr .pastdmark  
42a7 ..			.dmark: db "DOT"  
42aa f1			.pastdmark: pop af  
42ab			endm  
# End of macro DMARK
42ab						CALLMONITOR 
42ab cd aa fd			call debug_vector  
42ae				endm  
# End of macro CALLMONITOR
42ae					endif 
42ae 3e 00			ld a, 0 
42b0 32 78 f9			ld (cli_mvdot), a 
42b3 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
42b5				 
42b5			 
42b5			.dotgo: 
42b5			 
42b5			; move up type to on stack for parserv5 
42b5					FORTH_DSP 
42b5 cd 1f 24			call macro_forth_dsp 
42b8				endm 
# End of macro FORTH_DSP
42b8				;FORTH_DSP_VALUE  
42b8			 
42b8			if DEBUG_FORTH_DOT 
42b8				DMARK "DOT" 
42b8 f5				push af  
42b9 3a cd 42			ld a, (.dmark)  
42bc 32 a6 fd			ld (debug_mark),a  
42bf 3a ce 42			ld a, (.dmark+1)  
42c2 32 a7 fd			ld (debug_mark+1),a  
42c5 3a cf 42			ld a, (.dmark+2)  
42c8 32 a8 fd			ld (debug_mark+2),a  
42cb 18 03			jr .pastdmark  
42cd ..			.dmark: db "DOT"  
42d0 f1			.pastdmark: pop af  
42d1			endm  
# End of macro DMARK
42d1				CALLMONITOR 
42d1 cd aa fd			call debug_vector  
42d4				endm  
# End of macro CALLMONITOR
42d4			endif	 
42d4			;		.print: 
42d4			 
42d4 7e				ld a,(hl)  ; work out what type of value is on the TOS 
42d5 23				inc hl   ; position to the actual value 
42d6 fe 01			cp DS_TYPE_STR 
42d8 20 06			jr nz, .dotnum1  
42da			 
42da			; display string 
42da				FORTH_DSP_VALUE  
42da cd 42 24			call macro_forth_dsp_value 
42dd				endm 
# End of macro FORTH_DSP_VALUE
42dd eb				ex de,hl 
42de 18 49			jr .dotwrite 
42e0			 
42e0			.dotnum1: 
42e0 fe 02			cp DS_TYPE_INUM 
42e2 20 44			jr nz, .dotflot 
42e4			 
42e4			 
42e4			; display number 
42e4			 
42e4			;	push hl 
42e4			;	call clear_display 
42e4			;	pop hl 
42e4			 
42e4 5e				ld e, (hl) 
42e5 23				inc hl 
42e6 56				ld d, (hl) 
42e7 21 fc f0			ld hl, scratch 
42ea			if DEBUG_FORTH_DOT 
42ea				DMARK "DT1" 
42ea f5				push af  
42eb 3a ff 42			ld a, (.dmark)  
42ee 32 a6 fd			ld (debug_mark),a  
42f1 3a 00 43			ld a, (.dmark+1)  
42f4 32 a7 fd			ld (debug_mark+1),a  
42f7 3a 01 43			ld a, (.dmark+2)  
42fa 32 a8 fd			ld (debug_mark+2),a  
42fd 18 03			jr .pastdmark  
42ff ..			.dmark: db "DT1"  
4302 f1			.pastdmark: pop af  
4303			endm  
# End of macro DMARK
4303				CALLMONITOR 
4303 cd aa fd			call debug_vector  
4306				endm  
# End of macro CALLMONITOR
4306			endif	 
4306			 
4306 cd 3b 15			call uitoa_16 
4309 eb				ex de,hl 
430a			 
430a			if DEBUG_FORTH_DOT 
430a				DMARK "DT2" 
430a f5				push af  
430b 3a 1f 43			ld a, (.dmark)  
430e 32 a6 fd			ld (debug_mark),a  
4311 3a 20 43			ld a, (.dmark+1)  
4314 32 a7 fd			ld (debug_mark+1),a  
4317 3a 21 43			ld a, (.dmark+2)  
431a 32 a8 fd			ld (debug_mark+2),a  
431d 18 03			jr .pastdmark  
431f ..			.dmark: db "DT2"  
4322 f1			.pastdmark: pop af  
4323			endm  
# End of macro DMARK
4323				CALLMONITOR 
4323 cd aa fd			call debug_vector  
4326				endm  
# End of macro CALLMONITOR
4326			endif	 
4326			 
4326			;	ld de, os_word_scratch 
4326 18 01			jr .dotwrite 
4328			 
4328 00			.dotflot:   nop 
4329			; TODO print floating point number 
4329			 
4329			.dotwrite:		 
4329			 
4329					; if c is set then set all '-' to spaces 
4329					; need to also take into account .>  
4329			 
4329 3e 01				ld a, 1 
432b b9					cp c 
432c 20 67				jr nz, .nodashswap 
432e			 
432e					; DE has the string to write, working with HL 
432e			 
432e 06 ff				ld b, 255 
4330 d5					push de 
4331 e1					pop hl 
4332			 
4332			if DEBUG_FORTH_DOT 
4332				DMARK "DT-" 
4332 f5				push af  
4333 3a 47 43			ld a, (.dmark)  
4336 32 a6 fd			ld (debug_mark),a  
4339 3a 48 43			ld a, (.dmark+1)  
433c 32 a7 fd			ld (debug_mark+1),a  
433f 3a 49 43			ld a, (.dmark+2)  
4342 32 a8 fd			ld (debug_mark+2),a  
4345 18 03			jr .pastdmark  
4347 ..			.dmark: db "DT-"  
434a f1			.pastdmark: pop af  
434b			endm  
# End of macro DMARK
434b				CALLMONITOR 
434b cd aa fd			call debug_vector  
434e				endm  
# End of macro CALLMONITOR
434e			endif	 
434e 7e			.dashscan:	ld a, (hl) 
434f fe 00				cp 0 
4351 28 42				jr z, .nodashswap 
4353 fe 2d				cp '-' 
4355 20 03				jr nz, .dashskip 
4357 3e 20				ld a, ' ' 
4359 77					ld (hl), a 
435a 23			.dashskip:	inc hl 
435b			if DEBUG_FORTH_DOT 
435b				DMARK "D-2" 
435b f5				push af  
435c 3a 70 43			ld a, (.dmark)  
435f 32 a6 fd			ld (debug_mark),a  
4362 3a 71 43			ld a, (.dmark+1)  
4365 32 a7 fd			ld (debug_mark+1),a  
4368 3a 72 43			ld a, (.dmark+2)  
436b 32 a8 fd			ld (debug_mark+2),a  
436e 18 03			jr .pastdmark  
4370 ..			.dmark: db "D-2"  
4373 f1			.pastdmark: pop af  
4374			endm  
# End of macro DMARK
4374				CALLMONITOR 
4374 cd aa fd			call debug_vector  
4377				endm  
# End of macro CALLMONITOR
4377			endif	 
4377 10 d5				djnz .dashscan 
4379			 
4379			if DEBUG_FORTH_DOT 
4379				DMARK "D-1" 
4379 f5				push af  
437a 3a 8e 43			ld a, (.dmark)  
437d 32 a6 fd			ld (debug_mark),a  
4380 3a 8f 43			ld a, (.dmark+1)  
4383 32 a7 fd			ld (debug_mark+1),a  
4386 3a 90 43			ld a, (.dmark+2)  
4389 32 a8 fd			ld (debug_mark+2),a  
438c 18 03			jr .pastdmark  
438e ..			.dmark: db "D-1"  
4391 f1			.pastdmark: pop af  
4392			endm  
# End of macro DMARK
4392				CALLMONITOR 
4392 cd aa fd			call debug_vector  
4395				endm  
# End of macro CALLMONITOR
4395			endif	 
4395			 
4395			.nodashswap: 
4395			 
4395			if DEBUG_FORTH_DOT 
4395				DMARK "D-o" 
4395 f5				push af  
4396 3a aa 43			ld a, (.dmark)  
4399 32 a6 fd			ld (debug_mark),a  
439c 3a ab 43			ld a, (.dmark+1)  
439f 32 a7 fd			ld (debug_mark+1),a  
43a2 3a ac 43			ld a, (.dmark+2)  
43a5 32 a8 fd			ld (debug_mark+2),a  
43a8 18 03			jr .pastdmark  
43aa ..			.dmark: db "D-o"  
43ad f1			.pastdmark: pop af  
43ae			endm  
# End of macro DMARK
43ae				CALLMONITOR 
43ae cd aa fd			call debug_vector  
43b1				endm  
# End of macro CALLMONITOR
43b1			endif	 
43b1			 
43b1 d5					push de   ; save string start in case we need to advance print 
43b2			 
43b2 3a 99 f9				ld a, (f_cursor_ptr) 
43b5 cd ae 0d				call str_at_display 
43b8 3a 77 f9				ld a,(cli_autodisplay) 
43bb fe 00				cp 0 
43bd 28 03				jr z, .noupdate 
43bf cd be 0d						call update_display 
43c2					.noupdate: 
43c2			 
43c2			 
43c2					; see if we need to advance the print position 
43c2			 
43c2 e1					pop hl   ; get back string 
43c3			;		ex de,hl 
43c3			 
43c3 3a 78 f9				ld a, (cli_mvdot) 
43c6			if DEBUG_FORTH_DOT 
43c6			;		ld e,a 
43c6				DMARK "D>1" 
43c6 f5				push af  
43c7 3a db 43			ld a, (.dmark)  
43ca 32 a6 fd			ld (debug_mark),a  
43cd 3a dc 43			ld a, (.dmark+1)  
43d0 32 a7 fd			ld (debug_mark+1),a  
43d3 3a dd 43			ld a, (.dmark+2)  
43d6 32 a8 fd			ld (debug_mark+2),a  
43d9 18 03			jr .pastdmark  
43db ..			.dmark: db "D>1"  
43de f1			.pastdmark: pop af  
43df			endm  
# End of macro DMARK
43df				CALLMONITOR 
43df cd aa fd			call debug_vector  
43e2				endm  
# End of macro CALLMONITOR
43e2			endif	 
43e2 fe 00				cp 0 
43e4 28 44				jr z, .noadv 
43e6					; yes, lets advance the print position 
43e6 3e 00				ld a, 0 
43e8 cd 97 15				call strlent 
43eb			if DEBUG_FORTH_DOT 
43eb				DMARK "D-?" 
43eb f5				push af  
43ec 3a 00 44			ld a, (.dmark)  
43ef 32 a6 fd			ld (debug_mark),a  
43f2 3a 01 44			ld a, (.dmark+1)  
43f5 32 a7 fd			ld (debug_mark+1),a  
43f8 3a 02 44			ld a, (.dmark+2)  
43fb 32 a8 fd			ld (debug_mark+2),a  
43fe 18 03			jr .pastdmark  
4400 ..			.dmark: db "D-?"  
4403 f1			.pastdmark: pop af  
4404			endm  
# End of macro DMARK
4404				CALLMONITOR 
4404 cd aa fd			call debug_vector  
4407				endm  
# End of macro CALLMONITOR
4407			endif	 
4407 3a 99 f9				ld a, (f_cursor_ptr) 
440a 85					add a,l 
440b					;call addatohl 
440b					;ld a, l 
440b 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
440e			 
440e			if DEBUG_FORTH_DOT 
440e				DMARK "D->" 
440e f5				push af  
440f 3a 23 44			ld a, (.dmark)  
4412 32 a6 fd			ld (debug_mark),a  
4415 3a 24 44			ld a, (.dmark+1)  
4418 32 a7 fd			ld (debug_mark+1),a  
441b 3a 25 44			ld a, (.dmark+2)  
441e 32 a8 fd			ld (debug_mark+2),a  
4421 18 03			jr .pastdmark  
4423 ..			.dmark: db "D->"  
4426 f1			.pastdmark: pop af  
4427			endm  
# End of macro DMARK
4427				CALLMONITOR 
4427 cd aa fd			call debug_vector  
442a				endm  
# End of macro CALLMONITOR
442a			endif	 
442a			 
442a			.noadv:	 
442a			 
442a					if DEBUG_FORTH_DOT_WAIT 
442a							call next_page_prompt 
442a					endif	 
442a			; TODO this pop off the stack causes a crash. i dont know why 
442a			 
442a			 
442a			if DEBUG_FORTH_DOT 
442a				DMARK "DTh" 
442a f5				push af  
442b 3a 3f 44			ld a, (.dmark)  
442e 32 a6 fd			ld (debug_mark),a  
4431 3a 40 44			ld a, (.dmark+1)  
4434 32 a7 fd			ld (debug_mark+1),a  
4437 3a 41 44			ld a, (.dmark+2)  
443a 32 a8 fd			ld (debug_mark+2),a  
443d 18 03			jr .pastdmark  
443f ..			.dmark: db "DTh"  
4442 f1			.pastdmark: pop af  
4443			endm  
# End of macro DMARK
4443				CALLMONITOR 
4443 cd aa fd			call debug_vector  
4446				endm  
# End of macro CALLMONITOR
4446			endif	 
4446			 
4446					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4446 cd 11 25			call macro_forth_dsp_pop 
4449				endm 
# End of macro FORTH_DSP_POP
4449			 
4449			if DEBUG_FORTH_DOT 
4449				DMARK "DTi" 
4449 f5				push af  
444a 3a 5e 44			ld a, (.dmark)  
444d 32 a6 fd			ld (debug_mark),a  
4450 3a 5f 44			ld a, (.dmark+1)  
4453 32 a7 fd			ld (debug_mark+1),a  
4456 3a 60 44			ld a, (.dmark+2)  
4459 32 a8 fd			ld (debug_mark+2),a  
445c 18 03			jr .pastdmark  
445e ..			.dmark: db "DTi"  
4461 f1			.pastdmark: pop af  
4462			endm  
# End of macro DMARK
4462				CALLMONITOR 
4462 cd aa fd			call debug_vector  
4465				endm  
# End of macro CALLMONITOR
4465			endif	 
4465			 
4465			 
4465					NEXTW 
4465 c3 0f 26			jp macro_next 
4468				endm 
# End of macro NEXTW
4468			 
4468			.CLS: 
4468				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4468 35				db WORD_SYS_CORE+33             
4469 95 44			dw .DRAW            
446b 04				db 3 + 1 
446c .. 00			db "CLS",0              
4470				endm 
# End of macro CWHEAD
4470			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4470					if DEBUG_FORTH_WORDS_KEY 
4470						DMARK "CLS" 
4470 f5				push af  
4471 3a 85 44			ld a, (.dmark)  
4474 32 a6 fd			ld (debug_mark),a  
4477 3a 86 44			ld a, (.dmark+1)  
447a 32 a7 fd			ld (debug_mark+1),a  
447d 3a 87 44			ld a, (.dmark+2)  
4480 32 a8 fd			ld (debug_mark+2),a  
4483 18 03			jr .pastdmark  
4485 ..			.dmark: db "CLS"  
4488 f1			.pastdmark: pop af  
4489			endm  
# End of macro DMARK
4489						CALLMONITOR 
4489 cd aa fd			call debug_vector  
448c				endm  
# End of macro CALLMONITOR
448c					endif 
448c cd 9b 0d				call clear_display 
448f c3 a3 45				jp .home		; and home cursor 
4492					NEXTW 
4492 c3 0f 26			jp macro_next 
4495				endm 
# End of macro NEXTW
4495			 
4495			.DRAW: 
4495				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4495 36				db WORD_SYS_CORE+34             
4496 c0 44			dw .DUMP            
4498 05				db 4 + 1 
4499 .. 00			db "DRAW",0              
449e				endm 
# End of macro CWHEAD
449e			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
449e					if DEBUG_FORTH_WORDS_KEY 
449e						DMARK "DRW" 
449e f5				push af  
449f 3a b3 44			ld a, (.dmark)  
44a2 32 a6 fd			ld (debug_mark),a  
44a5 3a b4 44			ld a, (.dmark+1)  
44a8 32 a7 fd			ld (debug_mark+1),a  
44ab 3a b5 44			ld a, (.dmark+2)  
44ae 32 a8 fd			ld (debug_mark+2),a  
44b1 18 03			jr .pastdmark  
44b3 ..			.dmark: db "DRW"  
44b6 f1			.pastdmark: pop af  
44b7			endm  
# End of macro DMARK
44b7						CALLMONITOR 
44b7 cd aa fd			call debug_vector  
44ba				endm  
# End of macro CALLMONITOR
44ba					endif 
44ba cd be 0d				call update_display 
44bd					NEXTW 
44bd c3 0f 26			jp macro_next 
44c0				endm 
# End of macro NEXTW
44c0			 
44c0			.DUMP: 
44c0				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
44c0 37				db WORD_SYS_CORE+35             
44c1 f8 44			dw .CDUMP            
44c3 05				db 4 + 1 
44c4 .. 00			db "DUMP",0              
44c9				endm 
# End of macro CWHEAD
44c9			; | DUMP ( x -- ) With address x display dump   | DONE 
44c9			; TODO pop address to use off of the stack 
44c9					if DEBUG_FORTH_WORDS_KEY 
44c9						DMARK "DUM" 
44c9 f5				push af  
44ca 3a de 44			ld a, (.dmark)  
44cd 32 a6 fd			ld (debug_mark),a  
44d0 3a df 44			ld a, (.dmark+1)  
44d3 32 a7 fd			ld (debug_mark+1),a  
44d6 3a e0 44			ld a, (.dmark+2)  
44d9 32 a8 fd			ld (debug_mark+2),a  
44dc 18 03			jr .pastdmark  
44de ..			.dmark: db "DUM"  
44e1 f1			.pastdmark: pop af  
44e2			endm  
# End of macro DMARK
44e2						CALLMONITOR 
44e2 cd aa fd			call debug_vector  
44e5				endm  
# End of macro CALLMONITOR
44e5					endif 
44e5 cd 9b 0d				call clear_display 
44e8			 
44e8					; get address 
44e8			 
44e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e8 cd 59 24			call macro_dsp_valuehl 
44eb				endm 
# End of macro FORTH_DSP_VALUEHL
44eb				 
44eb					; save it for cdump 
44eb			 
44eb 22 1f f4				ld (os_cur_ptr),hl 
44ee			 
44ee					; destroy value TOS 
44ee			 
44ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ee cd 11 25			call macro_forth_dsp_pop 
44f1				endm 
# End of macro FORTH_DSP_POP
44f1			 
44f1 cd e2 20				call dumpcont	; skip old style of param parsing	 
44f4 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
44f5					NEXTW 
44f5 c3 0f 26			jp macro_next 
44f8				endm 
# End of macro NEXTW
44f8			.CDUMP: 
44f8				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
44f8 38				db WORD_SYS_CORE+36             
44f9 28 45			dw .DAT            
44fb 06				db 5 + 1 
44fc .. 00			db "CDUMP",0              
4502				endm 
# End of macro CWHEAD
4502			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4502					if DEBUG_FORTH_WORDS_KEY 
4502						DMARK "CDP" 
4502 f5				push af  
4503 3a 17 45			ld a, (.dmark)  
4506 32 a6 fd			ld (debug_mark),a  
4509 3a 18 45			ld a, (.dmark+1)  
450c 32 a7 fd			ld (debug_mark+1),a  
450f 3a 19 45			ld a, (.dmark+2)  
4512 32 a8 fd			ld (debug_mark+2),a  
4515 18 03			jr .pastdmark  
4517 ..			.dmark: db "CDP"  
451a f1			.pastdmark: pop af  
451b			endm  
# End of macro DMARK
451b						CALLMONITOR 
451b cd aa fd			call debug_vector  
451e				endm  
# End of macro CALLMONITOR
451e					endif 
451e cd 9b 0d				call clear_display 
4521 cd e2 20				call dumpcont	 
4524 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4525					NEXTW 
4525 c3 0f 26			jp macro_next 
4528				endm 
# End of macro NEXTW
4528			 
4528			 
4528			 
4528			 
4528			.DAT: 
4528				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4528 3d				db WORD_SYS_CORE+41             
4529 7e 45			dw .HOME            
452b 03				db 2 + 1 
452c .. 00			db "AT",0              
452f				endm 
# End of macro CWHEAD
452f			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
452f					if DEBUG_FORTH_WORDS_KEY 
452f						DMARK "AT." 
452f f5				push af  
4530 3a 44 45			ld a, (.dmark)  
4533 32 a6 fd			ld (debug_mark),a  
4536 3a 45 45			ld a, (.dmark+1)  
4539 32 a7 fd			ld (debug_mark+1),a  
453c 3a 46 45			ld a, (.dmark+2)  
453f 32 a8 fd			ld (debug_mark+2),a  
4542 18 03			jr .pastdmark  
4544 ..			.dmark: db "AT."  
4547 f1			.pastdmark: pop af  
4548			endm  
# End of macro DMARK
4548						CALLMONITOR 
4548 cd aa fd			call debug_vector  
454b				endm  
# End of macro CALLMONITOR
454b					endif 
454b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
454b cd 59 24			call macro_dsp_valuehl 
454e				endm 
# End of macro FORTH_DSP_VALUEHL
454e			 
454e			 
454e					; TODO save cursor row 
454e 7d					ld a,l 
454f fe 02				cp 2 
4551 20 04				jr nz, .crow3 
4553 3e 28				ld a, display_row_2 
4555 18 12				jr .ccol1 
4557 fe 03		.crow3:		cp 3 
4559 20 04				jr nz, .crow4 
455b 3e 50				ld a, display_row_3 
455d 18 0a				jr .ccol1 
455f fe 04		.crow4:		cp 4 
4561 20 04				jr nz, .crow1 
4563 3e 78				ld a, display_row_4 
4565 18 02				jr .ccol1 
4567 3e 00		.crow1:		ld a,display_row_1 
4569 f5			.ccol1:		push af			; got row offset 
456a 6f					ld l,a 
456b 26 00				ld h,0 
456d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
456d cd 11 25			call macro_forth_dsp_pop 
4570				endm 
# End of macro FORTH_DSP_POP
4570					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4570 cd 59 24			call macro_dsp_valuehl 
4573				endm 
# End of macro FORTH_DSP_VALUEHL
4573					; TODO save cursor col 
4573 f1					pop af 
4574 85					add l		; add col offset 
4575 32 99 f9				ld (f_cursor_ptr), a 
4578					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4578 cd 11 25			call macro_forth_dsp_pop 
457b				endm 
# End of macro FORTH_DSP_POP
457b			 
457b					; calculate  
457b			 
457b					NEXTW 
457b c3 0f 26			jp macro_next 
457e				endm 
# End of macro NEXTW
457e			 
457e			 
457e			.HOME: 
457e				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
457e 41				db WORD_SYS_CORE+45             
457f ab 45			dw .CR            
4581 05				db 4 + 1 
4582 .. 00			db "HOME",0              
4587				endm 
# End of macro CWHEAD
4587			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4587					if DEBUG_FORTH_WORDS_KEY 
4587						DMARK "HOM" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 a6 fd			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 a7 fd			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 a8 fd			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "HOM"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0						CALLMONITOR 
45a0 cd aa fd			call debug_vector  
45a3				endm  
# End of macro CALLMONITOR
45a3					endif 
45a3 3e 00		.home:		ld a, 0		; and home cursor 
45a5 32 99 f9				ld (f_cursor_ptr), a 
45a8					NEXTW 
45a8 c3 0f 26			jp macro_next 
45ab				endm 
# End of macro NEXTW
45ab			 
45ab			 
45ab			.CR: 
45ab				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
45ab 46				db WORD_SYS_CORE+50             
45ac e6 45			dw .SPACE            
45ae 03				db 2 + 1 
45af .. 00			db "CR",0              
45b2				endm 
# End of macro CWHEAD
45b2			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
45b2					if DEBUG_FORTH_WORDS_KEY 
45b2						DMARK "CR." 
45b2 f5				push af  
45b3 3a c7 45			ld a, (.dmark)  
45b6 32 a6 fd			ld (debug_mark),a  
45b9 3a c8 45			ld a, (.dmark+1)  
45bc 32 a7 fd			ld (debug_mark+1),a  
45bf 3a c9 45			ld a, (.dmark+2)  
45c2 32 a8 fd			ld (debug_mark+2),a  
45c5 18 03			jr .pastdmark  
45c7 ..			.dmark: db "CR."  
45ca f1			.pastdmark: pop af  
45cb			endm  
# End of macro DMARK
45cb						CALLMONITOR 
45cb cd aa fd			call debug_vector  
45ce				endm  
# End of macro CALLMONITOR
45ce					endif 
45ce 3e 0d				ld a, 13 
45d0 32 fc f0				ld (scratch),a 
45d3 3e 0a				ld a, 10 
45d5 32 fd f0				ld (scratch+1),a 
45d8 3e 00				ld a, 0 
45da 32 fe f0				ld (scratch+2),a 
45dd 21 fc f0				ld hl, scratch 
45e0 cd d0 22				call forth_push_str 
45e3					 
45e3				       NEXTW 
45e3 c3 0f 26			jp macro_next 
45e6				endm 
# End of macro NEXTW
45e6			.SPACE: 
45e6				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
45e6 46				db WORD_SYS_CORE+50             
45e7 1c 46			dw .SPACES            
45e9 03				db 2 + 1 
45ea .. 00			db "BL",0              
45ed				endm 
# End of macro CWHEAD
45ed			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
45ed					if DEBUG_FORTH_WORDS_KEY 
45ed						DMARK "BL." 
45ed f5				push af  
45ee 3a 02 46			ld a, (.dmark)  
45f1 32 a6 fd			ld (debug_mark),a  
45f4 3a 03 46			ld a, (.dmark+1)  
45f7 32 a7 fd			ld (debug_mark+1),a  
45fa 3a 04 46			ld a, (.dmark+2)  
45fd 32 a8 fd			ld (debug_mark+2),a  
4600 18 03			jr .pastdmark  
4602 ..			.dmark: db "BL."  
4605 f1			.pastdmark: pop af  
4606			endm  
# End of macro DMARK
4606						CALLMONITOR 
4606 cd aa fd			call debug_vector  
4609				endm  
# End of macro CALLMONITOR
4609					endif 
4609 3e 20				ld a, " " 
460b 32 fc f0				ld (scratch),a 
460e 3e 00				ld a, 0 
4610 32 fd f0				ld (scratch+1),a 
4613 21 fc f0				ld hl, scratch 
4616 cd d0 22				call forth_push_str 
4619					 
4619				       NEXTW 
4619 c3 0f 26			jp macro_next 
461c				endm 
# End of macro NEXTW
461c			 
461c			;.blstr: db " ", 0 
461c			 
461c			.SPACES: 
461c				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
461c 47				db WORD_SYS_CORE+51             
461d b7 46			dw .SCROLL            
461f 07				db 6 + 1 
4620 .. 00			db "SPACES",0              
4627				endm 
# End of macro CWHEAD
4627			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4627					if DEBUG_FORTH_WORDS_KEY 
4627						DMARK "SPS" 
4627 f5				push af  
4628 3a 3c 46			ld a, (.dmark)  
462b 32 a6 fd			ld (debug_mark),a  
462e 3a 3d 46			ld a, (.dmark+1)  
4631 32 a7 fd			ld (debug_mark+1),a  
4634 3a 3e 46			ld a, (.dmark+2)  
4637 32 a8 fd			ld (debug_mark+2),a  
463a 18 03			jr .pastdmark  
463c ..			.dmark: db "SPS"  
463f f1			.pastdmark: pop af  
4640			endm  
# End of macro DMARK
4640						CALLMONITOR 
4640 cd aa fd			call debug_vector  
4643				endm  
# End of macro CALLMONITOR
4643					endif 
4643			 
4643			 
4643					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4643 cd 59 24			call macro_dsp_valuehl 
4646				endm 
# End of macro FORTH_DSP_VALUEHL
4646			 
4646 e5					push hl    ; u 
4647					if DEBUG_FORTH_WORDS 
4647						DMARK "SPA" 
4647 f5				push af  
4648 3a 5c 46			ld a, (.dmark)  
464b 32 a6 fd			ld (debug_mark),a  
464e 3a 5d 46			ld a, (.dmark+1)  
4651 32 a7 fd			ld (debug_mark+1),a  
4654 3a 5e 46			ld a, (.dmark+2)  
4657 32 a8 fd			ld (debug_mark+2),a  
465a 18 03			jr .pastdmark  
465c ..			.dmark: db "SPA"  
465f f1			.pastdmark: pop af  
4660			endm  
# End of macro DMARK
4660						CALLMONITOR 
4660 cd aa fd			call debug_vector  
4663				endm  
# End of macro CALLMONITOR
4663					endif 
4663			 
4663					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4663 cd 11 25			call macro_forth_dsp_pop 
4666				endm 
# End of macro FORTH_DSP_POP
4666 e1					pop hl 
4667 0e 00				ld c, 0 
4669 45					ld b, l 
466a 21 fc f0				ld hl, scratch  
466d			 
466d					if DEBUG_FORTH_WORDS 
466d						DMARK "SP2" 
466d f5				push af  
466e 3a 82 46			ld a, (.dmark)  
4671 32 a6 fd			ld (debug_mark),a  
4674 3a 83 46			ld a, (.dmark+1)  
4677 32 a7 fd			ld (debug_mark+1),a  
467a 3a 84 46			ld a, (.dmark+2)  
467d 32 a8 fd			ld (debug_mark+2),a  
4680 18 03			jr .pastdmark  
4682 ..			.dmark: db "SP2"  
4685 f1			.pastdmark: pop af  
4686			endm  
# End of macro DMARK
4686						CALLMONITOR 
4686 cd aa fd			call debug_vector  
4689				endm  
# End of macro CALLMONITOR
4689					endif 
4689 3e 20				ld a, ' ' 
468b			.spaces1:	 
468b 77					ld (hl),a 
468c 23					inc hl 
468d					 
468d 10 fc				djnz .spaces1 
468f 3e 00				ld a,0 
4691 77					ld (hl),a 
4692 21 fc f0				ld hl, scratch 
4695					if DEBUG_FORTH_WORDS 
4695						DMARK "SP3" 
4695 f5				push af  
4696 3a aa 46			ld a, (.dmark)  
4699 32 a6 fd			ld (debug_mark),a  
469c 3a ab 46			ld a, (.dmark+1)  
469f 32 a7 fd			ld (debug_mark+1),a  
46a2 3a ac 46			ld a, (.dmark+2)  
46a5 32 a8 fd			ld (debug_mark+2),a  
46a8 18 03			jr .pastdmark  
46aa ..			.dmark: db "SP3"  
46ad f1			.pastdmark: pop af  
46ae			endm  
# End of macro DMARK
46ae						CALLMONITOR 
46ae cd aa fd			call debug_vector  
46b1				endm  
# End of macro CALLMONITOR
46b1					endif 
46b1 cd d0 22				call forth_push_str 
46b4			 
46b4				       NEXTW 
46b4 c3 0f 26			jp macro_next 
46b7				endm 
# End of macro NEXTW
46b7			 
46b7			 
46b7			 
46b7			.SCROLL: 
46b7				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
46b7 53				db WORD_SYS_CORE+63             
46b8 e4 46			dw .SCROLLD            
46ba 07				db 6 + 1 
46bb .. 00			db "SCROLL",0              
46c2				endm 
# End of macro CWHEAD
46c2			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
46c2					if DEBUG_FORTH_WORDS_KEY 
46c2						DMARK "SCR" 
46c2 f5				push af  
46c3 3a d7 46			ld a, (.dmark)  
46c6 32 a6 fd			ld (debug_mark),a  
46c9 3a d8 46			ld a, (.dmark+1)  
46cc 32 a7 fd			ld (debug_mark+1),a  
46cf 3a d9 46			ld a, (.dmark+2)  
46d2 32 a8 fd			ld (debug_mark+2),a  
46d5 18 03			jr .pastdmark  
46d7 ..			.dmark: db "SCR"  
46da f1			.pastdmark: pop af  
46db			endm  
# End of macro DMARK
46db						CALLMONITOR 
46db cd aa fd			call debug_vector  
46de				endm  
# End of macro CALLMONITOR
46de					endif 
46de			 
46de cd 5d 0d			call scroll_up 
46e1			;	call update_display 
46e1			 
46e1					NEXTW 
46e1 c3 0f 26			jp macro_next 
46e4				endm 
# End of macro NEXTW
46e4			 
46e4			 
46e4			 
46e4			;		; get dir 
46e4			; 
46e4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46e4			; 
46e4			;		push hl 
46e4			; 
46e4			;		; destroy value TOS 
46e4			; 
46e4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46e4			; 
46e4			;		; get count 
46e4			; 
46e4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46e4			; 
46e4			;		push hl 
46e4			; 
46e4			;		; destroy value TOS 
46e4			; 
46e4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46e4			; 
46e4			;		; one value on hl get other one back 
46e4			; 
46e4			;		pop bc    ; count 
46e4			; 
46e4			;		pop de   ; dir 
46e4			; 
46e4			; 
46e4			;		ld b, c 
46e4			; 
46e4			;.scrolldir:     push bc 
46e4			;		push de 
46e4			; 
46e4			;		ld a, 0 
46e4			;		cp e 
46e4			;		jr z, .scrollup  
46e4			;		call scroll_down 
46e4			;		jr .scrollnext 
46e4			;.scrollup:	call scroll_up 
46e4			; 
46e4			;		 
46e4			;.scrollnext: 
46e4			;		pop de 
46e4			;		pop bc 
46e4			;		djnz .scrolldir 
46e4			; 
46e4			; 
46e4			; 
46e4			; 
46e4			; 
46e4			;		NEXTW 
46e4			 
46e4			.SCROLLD: 
46e4				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
46e4 53				db WORD_SYS_CORE+63             
46e5 12 47			dw .ATQ            
46e7 08				db 7 + 1 
46e8 .. 00			db "SCROLLD",0              
46f0				endm 
# End of macro CWHEAD
46f0			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
46f0					if DEBUG_FORTH_WORDS_KEY 
46f0						DMARK "SCD" 
46f0 f5				push af  
46f1 3a 05 47			ld a, (.dmark)  
46f4 32 a6 fd			ld (debug_mark),a  
46f7 3a 06 47			ld a, (.dmark+1)  
46fa 32 a7 fd			ld (debug_mark+1),a  
46fd 3a 07 47			ld a, (.dmark+2)  
4700 32 a8 fd			ld (debug_mark+2),a  
4703 18 03			jr .pastdmark  
4705 ..			.dmark: db "SCD"  
4708 f1			.pastdmark: pop af  
4709			endm  
# End of macro DMARK
4709						CALLMONITOR 
4709 cd aa fd			call debug_vector  
470c				endm  
# End of macro CALLMONITOR
470c					endif 
470c			 
470c cd 81 0d			call scroll_down 
470f			;	call update_display 
470f			 
470f					NEXTW 
470f c3 0f 26			jp macro_next 
4712				endm 
# End of macro NEXTW
4712			 
4712			 
4712			.ATQ: 
4712				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4712 62				db WORD_SYS_CORE+78             
4713 70 47			dw .AUTODSP            
4715 04				db 3 + 1 
4716 .. 00			db "AT@",0              
471a				endm 
# End of macro CWHEAD
471a			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
471a					if DEBUG_FORTH_WORDS_KEY 
471a						DMARK "ATA" 
471a f5				push af  
471b 3a 2f 47			ld a, (.dmark)  
471e 32 a6 fd			ld (debug_mark),a  
4721 3a 30 47			ld a, (.dmark+1)  
4724 32 a7 fd			ld (debug_mark+1),a  
4727 3a 31 47			ld a, (.dmark+2)  
472a 32 a8 fd			ld (debug_mark+2),a  
472d 18 03			jr .pastdmark  
472f ..			.dmark: db "ATA"  
4732 f1			.pastdmark: pop af  
4733			endm  
# End of macro DMARK
4733						CALLMONITOR 
4733 cd aa fd			call debug_vector  
4736				endm  
# End of macro CALLMONITOR
4736					endif 
4736			 
4736			 
4736					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4736 cd 59 24			call macro_dsp_valuehl 
4739				endm 
# End of macro FORTH_DSP_VALUEHL
4739			 
4739					; TODO save cursor row 
4739 7d					ld a,l 
473a fe 02				cp 2 
473c 20 04				jr nz, .crow3aq 
473e 3e 28				ld a, display_row_2 
4740 18 12				jr .ccol1aq 
4742 fe 03		.crow3aq:		cp 3 
4744 20 04				jr nz, .crow4aq 
4746 3e 50				ld a, display_row_3 
4748 18 0a				jr .ccol1aq 
474a fe 04		.crow4aq:		cp 4 
474c 20 04				jr nz, .crow1aq 
474e 3e 78				ld a, display_row_4 
4750 18 02				jr .ccol1aq 
4752 3e 00		.crow1aq:		ld a,display_row_1 
4754 f5			.ccol1aq:		push af			; got row offset 
4755 6f					ld l,a 
4756 26 00				ld h,0 
4758					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4758 cd 11 25			call macro_forth_dsp_pop 
475b				endm 
# End of macro FORTH_DSP_POP
475b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
475b cd 59 24			call macro_dsp_valuehl 
475e				endm 
# End of macro FORTH_DSP_VALUEHL
475e					; TODO save cursor col 
475e f1					pop af 
475f 85					add l		; add col offset 
4760			 
4760					; add current frame buffer address 
4760 2a 07 fb				ld hl, (display_fb_active) 
4763 cd cf 0f				call addatohl 
4766			 
4766			 
4766			 
4766			 
4766					; get char frame buffer location offset in hl 
4766			 
4766 7e					ld a,(hl) 
4767 26 00				ld h, 0 
4769 6f					ld l, a 
476a			 
476a cd 62 22				call forth_push_numhl 
476d			 
476d			 
476d					NEXTW 
476d c3 0f 26			jp macro_next 
4770				endm 
# End of macro NEXTW
4770			 
4770			.AUTODSP: 
4770				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4770 63				db WORD_SYS_CORE+79             
4771 86 47			dw .MENU            
4773 05				db 4 + 1 
4774 .. 00			db "ADSP",0              
4779				endm 
# End of macro CWHEAD
4779			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4779			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4779			 
4779					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4779 cd 59 24			call macro_dsp_valuehl 
477c				endm 
# End of macro FORTH_DSP_VALUEHL
477c			 
477c			;		push hl 
477c			 
477c					; destroy value TOS 
477c			 
477c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
477c cd 11 25			call macro_forth_dsp_pop 
477f				endm 
# End of macro FORTH_DSP_POP
477f			 
477f			;		pop hl 
477f			 
477f 7d					ld a,l 
4780 32 77 f9				ld (cli_autodisplay), a 
4783				       NEXTW 
4783 c3 0f 26			jp macro_next 
4786				endm 
# End of macro NEXTW
4786			 
4786			.MENU: 
4786				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4786 70				db WORD_SYS_CORE+92             
4787 2f 48			dw .ENDDISPLAY            
4789 05				db 4 + 1 
478a .. 00			db "MENU",0              
478f				endm 
# End of macro CWHEAD
478f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
478f			 
478f			;		; get number of items on the stack 
478f			; 
478f				 
478f					FORTH_DSP_VALUEHL 
478f cd 59 24			call macro_dsp_valuehl 
4792				endm 
# End of macro FORTH_DSP_VALUEHL
4792				 
4792					if DEBUG_FORTH_WORDS_KEY 
4792						DMARK "MNU" 
4792 f5				push af  
4793 3a a7 47			ld a, (.dmark)  
4796 32 a6 fd			ld (debug_mark),a  
4799 3a a8 47			ld a, (.dmark+1)  
479c 32 a7 fd			ld (debug_mark+1),a  
479f 3a a9 47			ld a, (.dmark+2)  
47a2 32 a8 fd			ld (debug_mark+2),a  
47a5 18 03			jr .pastdmark  
47a7 ..			.dmark: db "MNU"  
47aa f1			.pastdmark: pop af  
47ab			endm  
# End of macro DMARK
47ab						CALLMONITOR 
47ab cd aa fd			call debug_vector  
47ae				endm  
# End of macro CALLMONITOR
47ae					endif 
47ae			 
47ae 45					ld b, l	 
47af 05					dec b 
47b0			 
47b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47b0 cd 11 25			call macro_forth_dsp_pop 
47b3				endm 
# End of macro FORTH_DSP_POP
47b3			 
47b3			 
47b3					; go directly through the stack to pluck out the string pointers and build an array 
47b3			 
47b3			;		FORTH_DSP 
47b3			 
47b3					; hl contains top most stack item 
47b3				 
47b3 11 fc f0				ld de, scratch 
47b6			 
47b6			.mbuild: 
47b6			 
47b6					FORTH_DSP_VALUEHL 
47b6 cd 59 24			call macro_dsp_valuehl 
47b9				endm 
# End of macro FORTH_DSP_VALUEHL
47b9			 
47b9					if DEBUG_FORTH_WORDS 
47b9						DMARK "MN3" 
47b9 f5				push af  
47ba 3a ce 47			ld a, (.dmark)  
47bd 32 a6 fd			ld (debug_mark),a  
47c0 3a cf 47			ld a, (.dmark+1)  
47c3 32 a7 fd			ld (debug_mark+1),a  
47c6 3a d0 47			ld a, (.dmark+2)  
47c9 32 a8 fd			ld (debug_mark+2),a  
47cc 18 03			jr .pastdmark  
47ce ..			.dmark: db "MN3"  
47d1 f1			.pastdmark: pop af  
47d2			endm  
# End of macro DMARK
47d2						CALLMONITOR 
47d2 cd aa fd			call debug_vector  
47d5				endm  
# End of macro CALLMONITOR
47d5					endif 
47d5 eb					ex de, hl 
47d6 73					ld (hl), e 
47d7 23					inc hl 
47d8 72					ld (hl), d 
47d9 23					inc hl 
47da eb					ex de, hl 
47db			 
47db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47db cd 11 25			call macro_forth_dsp_pop 
47de				endm 
# End of macro FORTH_DSP_POP
47de			 
47de 10 d6				djnz .mbuild 
47e0			 
47e0					; done add term 
47e0			 
47e0 eb					ex de, hl 
47e1 36 00				ld (hl), 0 
47e3 23					inc hl 
47e4 36 00				ld (hl), 0 
47e6			 
47e6				 
47e6					 
47e6 21 fc f0				ld hl, scratch 
47e9			 
47e9					if DEBUG_FORTH_WORDS 
47e9						DMARK "MNx" 
47e9 f5				push af  
47ea 3a fe 47			ld a, (.dmark)  
47ed 32 a6 fd			ld (debug_mark),a  
47f0 3a ff 47			ld a, (.dmark+1)  
47f3 32 a7 fd			ld (debug_mark+1),a  
47f6 3a 00 48			ld a, (.dmark+2)  
47f9 32 a8 fd			ld (debug_mark+2),a  
47fc 18 03			jr .pastdmark  
47fe ..			.dmark: db "MNx"  
4801 f1			.pastdmark: pop af  
4802			endm  
# End of macro DMARK
4802						CALLMONITOR 
4802 cd aa fd			call debug_vector  
4805				endm  
# End of macro CALLMONITOR
4805					endif 
4805			 
4805			 
4805			 
4805 3e 00				ld a, 0 
4807 cd cc 0d				call menu 
480a			 
480a			 
480a 6f					ld l, a 
480b 26 00				ld h, 0 
480d			 
480d					if DEBUG_FORTH_WORDS 
480d						DMARK "MNr" 
480d f5				push af  
480e 3a 22 48			ld a, (.dmark)  
4811 32 a6 fd			ld (debug_mark),a  
4814 3a 23 48			ld a, (.dmark+1)  
4817 32 a7 fd			ld (debug_mark+1),a  
481a 3a 24 48			ld a, (.dmark+2)  
481d 32 a8 fd			ld (debug_mark+2),a  
4820 18 03			jr .pastdmark  
4822 ..			.dmark: db "MNr"  
4825 f1			.pastdmark: pop af  
4826			endm  
# End of macro DMARK
4826						CALLMONITOR 
4826 cd aa fd			call debug_vector  
4829				endm  
# End of macro CALLMONITOR
4829					endif 
4829			 
4829 cd 62 22				call forth_push_numhl 
482c			 
482c			 
482c			 
482c			 
482c				       NEXTW 
482c c3 0f 26			jp macro_next 
482f				endm 
# End of macro NEXTW
482f			 
482f			 
482f			.ENDDISPLAY: 
482f			 
482f			; eof 
# End of file forth_words_display.asm
482f			include "forth_words_str.asm" 
482f			 
482f			; | ## String Words 
482f			 
482f			.PTR:   
482f			 
482f				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
482f 48				db WORD_SYS_CORE+52             
4830 5c 48			dw .STYPE            
4832 04				db 3 + 1 
4833 .. 00			db "PTR",0              
4837				endm 
# End of macro CWHEAD
4837			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4837			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4837			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4837			 
4837					if DEBUG_FORTH_WORDS_KEY 
4837						DMARK "PTR" 
4837 f5				push af  
4838 3a 4c 48			ld a, (.dmark)  
483b 32 a6 fd			ld (debug_mark),a  
483e 3a 4d 48			ld a, (.dmark+1)  
4841 32 a7 fd			ld (debug_mark+1),a  
4844 3a 4e 48			ld a, (.dmark+2)  
4847 32 a8 fd			ld (debug_mark+2),a  
484a 18 03			jr .pastdmark  
484c ..			.dmark: db "PTR"  
484f f1			.pastdmark: pop af  
4850			endm  
# End of macro DMARK
4850						CALLMONITOR 
4850 cd aa fd			call debug_vector  
4853				endm  
# End of macro CALLMONITOR
4853					endif 
4853					FORTH_DSP_VALUEHL 
4853 cd 59 24			call macro_dsp_valuehl 
4856				endm 
# End of macro FORTH_DSP_VALUEHL
4856 cd 62 22				call forth_push_numhl 
4859			 
4859			 
4859					NEXTW 
4859 c3 0f 26			jp macro_next 
485c				endm 
# End of macro NEXTW
485c			.STYPE: 
485c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
485c 48				db WORD_SYS_CORE+52             
485d ab 48			dw .UPPER            
485f 06				db 5 + 1 
4860 .. 00			db "STYPE",0              
4866				endm 
# End of macro CWHEAD
4866			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4866					if DEBUG_FORTH_WORDS_KEY 
4866						DMARK "STY" 
4866 f5				push af  
4867 3a 7b 48			ld a, (.dmark)  
486a 32 a6 fd			ld (debug_mark),a  
486d 3a 7c 48			ld a, (.dmark+1)  
4870 32 a7 fd			ld (debug_mark+1),a  
4873 3a 7d 48			ld a, (.dmark+2)  
4876 32 a8 fd			ld (debug_mark+2),a  
4879 18 03			jr .pastdmark  
487b ..			.dmark: db "STY"  
487e f1			.pastdmark: pop af  
487f			endm  
# End of macro DMARK
487f						CALLMONITOR 
487f cd aa fd			call debug_vector  
4882				endm  
# End of macro CALLMONITOR
4882					endif 
4882					FORTH_DSP 
4882 cd 1f 24			call macro_forth_dsp 
4885				endm 
# End of macro FORTH_DSP
4885					;v5 FORTH_DSP_VALUE 
4885			 
4885 7e					ld a, (hl) 
4886			 
4886 f5					push af 
4887			 
4887			; Dont destroy TOS		FORTH_DSP_POP 
4887			 
4887 f1					pop af 
4888			 
4888 fe 01				cp DS_TYPE_STR 
488a 28 09				jr z, .typestr 
488c			 
488c fe 02				cp DS_TYPE_INUM 
488e 28 0a				jr z, .typeinum 
4890			 
4890 21 a9 48				ld hl, .tna 
4893 18 0a				jr .tpush 
4895			 
4895 21 a5 48		.typestr:	ld hl, .tstr 
4898 18 05				jr .tpush 
489a 21 a7 48		.typeinum:	ld hl, .tinum 
489d 18 00				jr .tpush 
489f			 
489f			.tpush: 
489f			 
489f cd d0 22				call forth_push_str 
48a2			 
48a2					NEXTW 
48a2 c3 0f 26			jp macro_next 
48a5				endm 
# End of macro NEXTW
48a5 .. 00		.tstr:	db "s",0 
48a7 .. 00		.tinum:  db "i",0 
48a9 .. 00		.tna:   db "?", 0 
48ab			 
48ab			 
48ab			.UPPER: 
48ab				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
48ab 48				db WORD_SYS_CORE+52             
48ac e6 48			dw .LOWER            
48ae 06				db 5 + 1 
48af .. 00			db "UPPER",0              
48b5				endm 
# End of macro CWHEAD
48b5			; | UPPER ( s -- s ) Upper case string s  | DONE 
48b5					if DEBUG_FORTH_WORDS_KEY 
48b5						DMARK "UPR" 
48b5 f5				push af  
48b6 3a ca 48			ld a, (.dmark)  
48b9 32 a6 fd			ld (debug_mark),a  
48bc 3a cb 48			ld a, (.dmark+1)  
48bf 32 a7 fd			ld (debug_mark+1),a  
48c2 3a cc 48			ld a, (.dmark+2)  
48c5 32 a8 fd			ld (debug_mark+2),a  
48c8 18 03			jr .pastdmark  
48ca ..			.dmark: db "UPR"  
48cd f1			.pastdmark: pop af  
48ce			endm  
# End of macro DMARK
48ce						CALLMONITOR 
48ce cd aa fd			call debug_vector  
48d1				endm  
# End of macro CALLMONITOR
48d1					endif 
48d1			 
48d1					FORTH_DSP 
48d1 cd 1f 24			call macro_forth_dsp 
48d4				endm 
# End of macro FORTH_DSP
48d4					 
48d4			; TODO check is string type 
48d4			 
48d4					FORTH_DSP_VALUEHL 
48d4 cd 59 24			call macro_dsp_valuehl 
48d7				endm 
# End of macro FORTH_DSP_VALUEHL
48d7			; get pointer to string in hl 
48d7			 
48d7 7e			.toup:		ld a, (hl) 
48d8 fe 00				cp 0 
48da 28 07				jr z, .toupdone 
48dc			 
48dc cd 9b 14				call to_upper 
48df			 
48df 77					ld (hl), a 
48e0 23					inc hl 
48e1 18 f4				jr .toup 
48e3			 
48e3					 
48e3			 
48e3			 
48e3			; for each char convert to upper 
48e3					 
48e3			.toupdone: 
48e3			 
48e3			 
48e3					NEXTW 
48e3 c3 0f 26			jp macro_next 
48e6				endm 
# End of macro NEXTW
48e6			.LOWER: 
48e6				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
48e6 48				db WORD_SYS_CORE+52             
48e7 21 49			dw .TCASE            
48e9 06				db 5 + 1 
48ea .. 00			db "LOWER",0              
48f0				endm 
# End of macro CWHEAD
48f0			; | LOWER ( s -- s ) Lower case string s  | DONE 
48f0					if DEBUG_FORTH_WORDS_KEY 
48f0						DMARK "LWR" 
48f0 f5				push af  
48f1 3a 05 49			ld a, (.dmark)  
48f4 32 a6 fd			ld (debug_mark),a  
48f7 3a 06 49			ld a, (.dmark+1)  
48fa 32 a7 fd			ld (debug_mark+1),a  
48fd 3a 07 49			ld a, (.dmark+2)  
4900 32 a8 fd			ld (debug_mark+2),a  
4903 18 03			jr .pastdmark  
4905 ..			.dmark: db "LWR"  
4908 f1			.pastdmark: pop af  
4909			endm  
# End of macro DMARK
4909						CALLMONITOR 
4909 cd aa fd			call debug_vector  
490c				endm  
# End of macro CALLMONITOR
490c					endif 
490c			 
490c					FORTH_DSP 
490c cd 1f 24			call macro_forth_dsp 
490f				endm 
# End of macro FORTH_DSP
490f					 
490f			; TODO check is string type 
490f			 
490f					FORTH_DSP_VALUEHL 
490f cd 59 24			call macro_dsp_valuehl 
4912				endm 
# End of macro FORTH_DSP_VALUEHL
4912			; get pointer to string in hl 
4912			 
4912 7e			.tolow:		ld a, (hl) 
4913 fe 00				cp 0 
4915 28 07				jr z, .tolowdone 
4917			 
4917 cd a4 14				call to_lower 
491a			 
491a 77					ld (hl), a 
491b 23					inc hl 
491c 18 f4				jr .tolow 
491e			 
491e					 
491e			 
491e			 
491e			; for each char convert to low 
491e					 
491e			.tolowdone: 
491e					NEXTW 
491e c3 0f 26			jp macro_next 
4921				endm 
# End of macro NEXTW
4921			.TCASE: 
4921				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4921 48				db WORD_SYS_CORE+52             
4922 57 4a			dw .SUBSTR            
4924 06				db 5 + 1 
4925 .. 00			db "TCASE",0              
492b				endm 
# End of macro CWHEAD
492b			; | TCASE ( s -- s ) Title case string s  | DONE 
492b					if DEBUG_FORTH_WORDS_KEY 
492b						DMARK "TCS" 
492b f5				push af  
492c 3a 40 49			ld a, (.dmark)  
492f 32 a6 fd			ld (debug_mark),a  
4932 3a 41 49			ld a, (.dmark+1)  
4935 32 a7 fd			ld (debug_mark+1),a  
4938 3a 42 49			ld a, (.dmark+2)  
493b 32 a8 fd			ld (debug_mark+2),a  
493e 18 03			jr .pastdmark  
4940 ..			.dmark: db "TCS"  
4943 f1			.pastdmark: pop af  
4944			endm  
# End of macro DMARK
4944						CALLMONITOR 
4944 cd aa fd			call debug_vector  
4947				endm  
# End of macro CALLMONITOR
4947					endif 
4947			 
4947					FORTH_DSP 
4947 cd 1f 24			call macro_forth_dsp 
494a				endm 
# End of macro FORTH_DSP
494a					 
494a			; TODO check is string type 
494a			 
494a					FORTH_DSP_VALUEHL 
494a cd 59 24			call macro_dsp_valuehl 
494d				endm 
# End of macro FORTH_DSP_VALUEHL
494d			; get pointer to string in hl 
494d			 
494d					if DEBUG_FORTH_WORDS 
494d						DMARK "TC1" 
494d f5				push af  
494e 3a 62 49			ld a, (.dmark)  
4951 32 a6 fd			ld (debug_mark),a  
4954 3a 63 49			ld a, (.dmark+1)  
4957 32 a7 fd			ld (debug_mark+1),a  
495a 3a 64 49			ld a, (.dmark+2)  
495d 32 a8 fd			ld (debug_mark+2),a  
4960 18 03			jr .pastdmark  
4962 ..			.dmark: db "TC1"  
4965 f1			.pastdmark: pop af  
4966			endm  
# End of macro DMARK
4966						CALLMONITOR 
4966 cd aa fd			call debug_vector  
4969				endm  
# End of macro CALLMONITOR
4969					endif 
4969			 
4969					; first time in turn to upper case first char 
4969			 
4969 7e					ld a, (hl) 
496a c3 f4 49				jp .totsiptou 
496d			 
496d			 
496d 7e			.tot:		ld a, (hl) 
496e fe 00				cp 0 
4970 ca 38 4a				jp z, .totdone 
4973			 
4973					if DEBUG_FORTH_WORDS 
4973						DMARK "TC2" 
4973 f5				push af  
4974 3a 88 49			ld a, (.dmark)  
4977 32 a6 fd			ld (debug_mark),a  
497a 3a 89 49			ld a, (.dmark+1)  
497d 32 a7 fd			ld (debug_mark+1),a  
4980 3a 8a 49			ld a, (.dmark+2)  
4983 32 a8 fd			ld (debug_mark+2),a  
4986 18 03			jr .pastdmark  
4988 ..			.dmark: db "TC2"  
498b f1			.pastdmark: pop af  
498c			endm  
# End of macro DMARK
498c						CALLMONITOR 
498c cd aa fd			call debug_vector  
498f				endm  
# End of macro CALLMONITOR
498f					endif 
498f					; check to see if current char is a space 
498f			 
498f fe 20				cp ' ' 
4991 28 21				jr z, .totsp 
4993 cd a4 14				call to_lower 
4996					if DEBUG_FORTH_WORDS 
4996						DMARK "TC3" 
4996 f5				push af  
4997 3a ab 49			ld a, (.dmark)  
499a 32 a6 fd			ld (debug_mark),a  
499d 3a ac 49			ld a, (.dmark+1)  
49a0 32 a7 fd			ld (debug_mark+1),a  
49a3 3a ad 49			ld a, (.dmark+2)  
49a6 32 a8 fd			ld (debug_mark+2),a  
49a9 18 03			jr .pastdmark  
49ab ..			.dmark: db "TC3"  
49ae f1			.pastdmark: pop af  
49af			endm  
# End of macro DMARK
49af						CALLMONITOR 
49af cd aa fd			call debug_vector  
49b2				endm  
# End of macro CALLMONITOR
49b2					endif 
49b2 18 63				jr .totnxt 
49b4			 
49b4			.totsp:         ; on a space, find next char which should be upper 
49b4			 
49b4					if DEBUG_FORTH_WORDS 
49b4						DMARK "TC4" 
49b4 f5				push af  
49b5 3a c9 49			ld a, (.dmark)  
49b8 32 a6 fd			ld (debug_mark),a  
49bb 3a ca 49			ld a, (.dmark+1)  
49be 32 a7 fd			ld (debug_mark+1),a  
49c1 3a cb 49			ld a, (.dmark+2)  
49c4 32 a8 fd			ld (debug_mark+2),a  
49c7 18 03			jr .pastdmark  
49c9 ..			.dmark: db "TC4"  
49cc f1			.pastdmark: pop af  
49cd			endm  
# End of macro DMARK
49cd						CALLMONITOR 
49cd cd aa fd			call debug_vector  
49d0				endm  
# End of macro CALLMONITOR
49d0					endif 
49d0					;; 
49d0			 
49d0 fe 20				cp ' ' 
49d2 20 20				jr nz, .totsiptou 
49d4 23					inc hl 
49d5 7e					ld a, (hl) 
49d6					if DEBUG_FORTH_WORDS 
49d6						DMARK "TC5" 
49d6 f5				push af  
49d7 3a eb 49			ld a, (.dmark)  
49da 32 a6 fd			ld (debug_mark),a  
49dd 3a ec 49			ld a, (.dmark+1)  
49e0 32 a7 fd			ld (debug_mark+1),a  
49e3 3a ed 49			ld a, (.dmark+2)  
49e6 32 a8 fd			ld (debug_mark+2),a  
49e9 18 03			jr .pastdmark  
49eb ..			.dmark: db "TC5"  
49ee f1			.pastdmark: pop af  
49ef			endm  
# End of macro DMARK
49ef						CALLMONITOR 
49ef cd aa fd			call debug_vector  
49f2				endm  
# End of macro CALLMONITOR
49f2					endif 
49f2 18 c0				jr .totsp 
49f4 fe 00		.totsiptou:    cp 0 
49f6 28 40				jr z, .totdone 
49f8					; not space and not zero term so upper case it 
49f8 cd 9b 14				call to_upper 
49fb			 
49fb					if DEBUG_FORTH_WORDS 
49fb						DMARK "TC6" 
49fb f5				push af  
49fc 3a 10 4a			ld a, (.dmark)  
49ff 32 a6 fd			ld (debug_mark),a  
4a02 3a 11 4a			ld a, (.dmark+1)  
4a05 32 a7 fd			ld (debug_mark+1),a  
4a08 3a 12 4a			ld a, (.dmark+2)  
4a0b 32 a8 fd			ld (debug_mark+2),a  
4a0e 18 03			jr .pastdmark  
4a10 ..			.dmark: db "TC6"  
4a13 f1			.pastdmark: pop af  
4a14			endm  
# End of macro DMARK
4a14						CALLMONITOR 
4a14 cd aa fd			call debug_vector  
4a17				endm  
# End of macro CALLMONITOR
4a17					endif 
4a17			 
4a17			 
4a17			.totnxt: 
4a17			 
4a17 77					ld (hl), a 
4a18 23					inc hl 
4a19					if DEBUG_FORTH_WORDS 
4a19						DMARK "TC7" 
4a19 f5				push af  
4a1a 3a 2e 4a			ld a, (.dmark)  
4a1d 32 a6 fd			ld (debug_mark),a  
4a20 3a 2f 4a			ld a, (.dmark+1)  
4a23 32 a7 fd			ld (debug_mark+1),a  
4a26 3a 30 4a			ld a, (.dmark+2)  
4a29 32 a8 fd			ld (debug_mark+2),a  
4a2c 18 03			jr .pastdmark  
4a2e ..			.dmark: db "TC7"  
4a31 f1			.pastdmark: pop af  
4a32			endm  
# End of macro DMARK
4a32						CALLMONITOR 
4a32 cd aa fd			call debug_vector  
4a35				endm  
# End of macro CALLMONITOR
4a35					endif 
4a35 c3 6d 49				jp .tot 
4a38			 
4a38					 
4a38			 
4a38			 
4a38			; for each char convert to low 
4a38					 
4a38			.totdone: 
4a38					if DEBUG_FORTH_WORDS 
4a38						DMARK "TCd" 
4a38 f5				push af  
4a39 3a 4d 4a			ld a, (.dmark)  
4a3c 32 a6 fd			ld (debug_mark),a  
4a3f 3a 4e 4a			ld a, (.dmark+1)  
4a42 32 a7 fd			ld (debug_mark+1),a  
4a45 3a 4f 4a			ld a, (.dmark+2)  
4a48 32 a8 fd			ld (debug_mark+2),a  
4a4b 18 03			jr .pastdmark  
4a4d ..			.dmark: db "TCd"  
4a50 f1			.pastdmark: pop af  
4a51			endm  
# End of macro DMARK
4a51						CALLMONITOR 
4a51 cd aa fd			call debug_vector  
4a54				endm  
# End of macro CALLMONITOR
4a54					endif 
4a54					NEXTW 
4a54 c3 0f 26			jp macro_next 
4a57				endm 
# End of macro NEXTW
4a57			 
4a57			.SUBSTR: 
4a57				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4a57 48				db WORD_SYS_CORE+52             
4a58 b5 4a			dw .LEFT            
4a5a 07				db 6 + 1 
4a5b .. 00			db "SUBSTR",0              
4a62				endm 
# End of macro CWHEAD
4a62			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4a62			 
4a62					if DEBUG_FORTH_WORDS_KEY 
4a62						DMARK "SST" 
4a62 f5				push af  
4a63 3a 77 4a			ld a, (.dmark)  
4a66 32 a6 fd			ld (debug_mark),a  
4a69 3a 78 4a			ld a, (.dmark+1)  
4a6c 32 a7 fd			ld (debug_mark+1),a  
4a6f 3a 79 4a			ld a, (.dmark+2)  
4a72 32 a8 fd			ld (debug_mark+2),a  
4a75 18 03			jr .pastdmark  
4a77 ..			.dmark: db "SST"  
4a7a f1			.pastdmark: pop af  
4a7b			endm  
# End of macro DMARK
4a7b						CALLMONITOR 
4a7b cd aa fd			call debug_vector  
4a7e				endm  
# End of macro CALLMONITOR
4a7e					endif 
4a7e			; TODO check string type 
4a7e					FORTH_DSP_VALUEHL 
4a7e cd 59 24			call macro_dsp_valuehl 
4a81				endm 
# End of macro FORTH_DSP_VALUEHL
4a81			 
4a81 e5					push hl      ; string length 
4a82			 
4a82					FORTH_DSP_POP 
4a82 cd 11 25			call macro_forth_dsp_pop 
4a85				endm 
# End of macro FORTH_DSP_POP
4a85			 
4a85					FORTH_DSP_VALUEHL 
4a85 cd 59 24			call macro_dsp_valuehl 
4a88				endm 
# End of macro FORTH_DSP_VALUEHL
4a88			 
4a88 e5					push hl     ; start char 
4a89			 
4a89					FORTH_DSP_POP 
4a89 cd 11 25			call macro_forth_dsp_pop 
4a8c				endm 
# End of macro FORTH_DSP_POP
4a8c			 
4a8c			 
4a8c					FORTH_DSP_VALUE 
4a8c cd 42 24			call macro_forth_dsp_value 
4a8f				endm 
# End of macro FORTH_DSP_VALUE
4a8f			 
4a8f d1					pop de    ; get start post offset 
4a90			 
4a90 19					add hl, de    ; starting offset 
4a91			 
4a91 c1					pop bc 
4a92 c5					push bc      ; grab size of string 
4a93			 
4a93 e5					push hl    ; save string start  
4a94			 
4a94 26 00				ld h, 0 
4a96 69					ld l, c 
4a97 23					inc hl 
4a98 23					inc hl 
4a99			 
4a99 cd 01 16				call malloc 
4a9c				if DEBUG_FORTH_MALLOC_GUARD 
4a9c cc e2 5f				call z,malloc_error 
4a9f				endif 
4a9f			 
4a9f eb					ex de, hl      ; save malloc area for string copy 
4aa0 e1					pop hl    ; get back source 
4aa1 c1					pop bc    ; get length of string back 
4aa2			 
4aa2 d5					push de    ; save malloc area for after we push 
4aa3 ed b0				ldir     ; copy substr 
4aa5			 
4aa5			 
4aa5 eb					ex de, hl 
4aa6 3e 00				ld a, 0 
4aa8 77					ld (hl), a   ; term substr 
4aa9			 
4aa9					 
4aa9 e1					pop hl    ; get malloc so we can push it 
4aaa e5					push hl   ; save so we can free it afterwards 
4aab			 
4aab cd d0 22				call forth_push_str 
4aae			 
4aae e1					pop hl 
4aaf cd cb 16				call free 
4ab2			 
4ab2					 
4ab2					 
4ab2			 
4ab2			 
4ab2					NEXTW 
4ab2 c3 0f 26			jp macro_next 
4ab5				endm 
# End of macro NEXTW
4ab5			 
4ab5			.LEFT: 
4ab5				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4ab5 48				db WORD_SYS_CORE+52             
4ab6 dd 4a			dw .RIGHT            
4ab8 05				db 4 + 1 
4ab9 .. 00			db "LEFT",0              
4abe				endm 
# End of macro CWHEAD
4abe			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4abe					if DEBUG_FORTH_WORDS_KEY 
4abe						DMARK "LEF" 
4abe f5				push af  
4abf 3a d3 4a			ld a, (.dmark)  
4ac2 32 a6 fd			ld (debug_mark),a  
4ac5 3a d4 4a			ld a, (.dmark+1)  
4ac8 32 a7 fd			ld (debug_mark+1),a  
4acb 3a d5 4a			ld a, (.dmark+2)  
4ace 32 a8 fd			ld (debug_mark+2),a  
4ad1 18 03			jr .pastdmark  
4ad3 ..			.dmark: db "LEF"  
4ad6 f1			.pastdmark: pop af  
4ad7			endm  
# End of macro DMARK
4ad7						CALLMONITOR 
4ad7 cd aa fd			call debug_vector  
4ada				endm  
# End of macro CALLMONITOR
4ada					endif 
4ada			 
4ada					NEXTW 
4ada c3 0f 26			jp macro_next 
4add				endm 
# End of macro NEXTW
4add			.RIGHT: 
4add				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4add 48				db WORD_SYS_CORE+52             
4ade 06 4b			dw .STR2NUM            
4ae0 06				db 5 + 1 
4ae1 .. 00			db "RIGHT",0              
4ae7				endm 
# End of macro CWHEAD
4ae7			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4ae7					if DEBUG_FORTH_WORDS_KEY 
4ae7						DMARK "RIG" 
4ae7 f5				push af  
4ae8 3a fc 4a			ld a, (.dmark)  
4aeb 32 a6 fd			ld (debug_mark),a  
4aee 3a fd 4a			ld a, (.dmark+1)  
4af1 32 a7 fd			ld (debug_mark+1),a  
4af4 3a fe 4a			ld a, (.dmark+2)  
4af7 32 a8 fd			ld (debug_mark+2),a  
4afa 18 03			jr .pastdmark  
4afc ..			.dmark: db "RIG"  
4aff f1			.pastdmark: pop af  
4b00			endm  
# End of macro DMARK
4b00						CALLMONITOR 
4b00 cd aa fd			call debug_vector  
4b03				endm  
# End of macro CALLMONITOR
4b03					endif 
4b03			 
4b03					NEXTW 
4b03 c3 0f 26			jp macro_next 
4b06				endm 
# End of macro NEXTW
4b06			 
4b06			 
4b06			.STR2NUM: 
4b06				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4b06 48				db WORD_SYS_CORE+52             
4b07 92 4b			dw .NUM2STR            
4b09 08				db 7 + 1 
4b0a .. 00			db "STR2NUM",0              
4b12				endm 
# End of macro CWHEAD
4b12			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4b12			 
4b12			 
4b12			; TODO STR type check to do 
4b12					if DEBUG_FORTH_WORDS_KEY 
4b12						DMARK "S2N" 
4b12 f5				push af  
4b13 3a 27 4b			ld a, (.dmark)  
4b16 32 a6 fd			ld (debug_mark),a  
4b19 3a 28 4b			ld a, (.dmark+1)  
4b1c 32 a7 fd			ld (debug_mark+1),a  
4b1f 3a 29 4b			ld a, (.dmark+2)  
4b22 32 a8 fd			ld (debug_mark+2),a  
4b25 18 03			jr .pastdmark  
4b27 ..			.dmark: db "S2N"  
4b2a f1			.pastdmark: pop af  
4b2b			endm  
# End of macro DMARK
4b2b						CALLMONITOR 
4b2b cd aa fd			call debug_vector  
4b2e				endm  
# End of macro CALLMONITOR
4b2e					endif 
4b2e			 
4b2e					;FORTH_DSP 
4b2e					FORTH_DSP_VALUE 
4b2e cd 42 24			call macro_forth_dsp_value 
4b31				endm 
# End of macro FORTH_DSP_VALUE
4b31					;inc hl 
4b31			 
4b31 eb					ex de, hl 
4b32					if DEBUG_FORTH_WORDS 
4b32						DMARK "S2a" 
4b32 f5				push af  
4b33 3a 47 4b			ld a, (.dmark)  
4b36 32 a6 fd			ld (debug_mark),a  
4b39 3a 48 4b			ld a, (.dmark+1)  
4b3c 32 a7 fd			ld (debug_mark+1),a  
4b3f 3a 49 4b			ld a, (.dmark+2)  
4b42 32 a8 fd			ld (debug_mark+2),a  
4b45 18 03			jr .pastdmark  
4b47 ..			.dmark: db "S2a"  
4b4a f1			.pastdmark: pop af  
4b4b			endm  
# End of macro DMARK
4b4b						CALLMONITOR 
4b4b cd aa fd			call debug_vector  
4b4e				endm  
# End of macro CALLMONITOR
4b4e					endif 
4b4e cd 23 15				call string_to_uint16 
4b51			 
4b51					if DEBUG_FORTH_WORDS 
4b51						DMARK "S2b" 
4b51 f5				push af  
4b52 3a 66 4b			ld a, (.dmark)  
4b55 32 a6 fd			ld (debug_mark),a  
4b58 3a 67 4b			ld a, (.dmark+1)  
4b5b 32 a7 fd			ld (debug_mark+1),a  
4b5e 3a 68 4b			ld a, (.dmark+2)  
4b61 32 a8 fd			ld (debug_mark+2),a  
4b64 18 03			jr .pastdmark  
4b66 ..			.dmark: db "S2b"  
4b69 f1			.pastdmark: pop af  
4b6a			endm  
# End of macro DMARK
4b6a						CALLMONITOR 
4b6a cd aa fd			call debug_vector  
4b6d				endm  
# End of macro CALLMONITOR
4b6d					endif 
4b6d			;		push hl 
4b6d					FORTH_DSP_POP 
4b6d cd 11 25			call macro_forth_dsp_pop 
4b70				endm 
# End of macro FORTH_DSP_POP
4b70			;		pop hl 
4b70					 
4b70					if DEBUG_FORTH_WORDS 
4b70						DMARK "S2b" 
4b70 f5				push af  
4b71 3a 85 4b			ld a, (.dmark)  
4b74 32 a6 fd			ld (debug_mark),a  
4b77 3a 86 4b			ld a, (.dmark+1)  
4b7a 32 a7 fd			ld (debug_mark+1),a  
4b7d 3a 87 4b			ld a, (.dmark+2)  
4b80 32 a8 fd			ld (debug_mark+2),a  
4b83 18 03			jr .pastdmark  
4b85 ..			.dmark: db "S2b"  
4b88 f1			.pastdmark: pop af  
4b89			endm  
# End of macro DMARK
4b89						CALLMONITOR 
4b89 cd aa fd			call debug_vector  
4b8c				endm  
# End of macro CALLMONITOR
4b8c					endif 
4b8c cd 62 22				call forth_push_numhl	 
4b8f			 
4b8f				 
4b8f				       NEXTW 
4b8f c3 0f 26			jp macro_next 
4b92				endm 
# End of macro NEXTW
4b92			.NUM2STR: 
4b92				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4b92 48				db WORD_SYS_CORE+52             
4b93 a1 4b			dw .CONCAT            
4b95 08				db 7 + 1 
4b96 .. 00			db "NUM2STR",0              
4b9e				endm 
# End of macro CWHEAD
4b9e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4b9e			 
4b9e			;		; malloc a string to target 
4b9e			;		ld hl, 10     ; TODO max string size should be fine 
4b9e			;		call malloc 
4b9e			;		push hl    ; save malloc location 
4b9e			; 
4b9e			; 
4b9e			;; TODO check int type 
4b9e			;		FORTH_DSP_VALUEHL 
4b9e			;		ld a, l 
4b9e			;		call DispAToASCII   
4b9e			;;TODO need to chage above call to dump into string 
4b9e			; 
4b9e			; 
4b9e			 
4b9e				       NEXTW 
4b9e c3 0f 26			jp macro_next 
4ba1				endm 
# End of macro NEXTW
4ba1			 
4ba1			.CONCAT: 
4ba1				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4ba1 48				db WORD_SYS_CORE+52             
4ba2 54 4c			dw .FIND            
4ba4 07				db 6 + 1 
4ba5 .. 00			db "CONCAT",0              
4bac				endm 
# End of macro CWHEAD
4bac			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4bac			 
4bac			; TODO check string type 
4bac			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4bac			 
4bac					if DEBUG_FORTH_WORDS_KEY 
4bac						DMARK "CON" 
4bac f5				push af  
4bad 3a c1 4b			ld a, (.dmark)  
4bb0 32 a6 fd			ld (debug_mark),a  
4bb3 3a c2 4b			ld a, (.dmark+1)  
4bb6 32 a7 fd			ld (debug_mark+1),a  
4bb9 3a c3 4b			ld a, (.dmark+2)  
4bbc 32 a8 fd			ld (debug_mark+2),a  
4bbf 18 03			jr .pastdmark  
4bc1 ..			.dmark: db "CON"  
4bc4 f1			.pastdmark: pop af  
4bc5			endm  
# End of macro DMARK
4bc5						CALLMONITOR 
4bc5 cd aa fd			call debug_vector  
4bc8				endm  
# End of macro CALLMONITOR
4bc8					endif 
4bc8			 
4bc8			 
4bc8					FORTH_DSP_VALUE 
4bc8 cd 42 24			call macro_forth_dsp_value 
4bcb				endm 
# End of macro FORTH_DSP_VALUE
4bcb e5					push hl   ; s2 
4bcc			 
4bcc					FORTH_DSP_POP 
4bcc cd 11 25			call macro_forth_dsp_pop 
4bcf				endm 
# End of macro FORTH_DSP_POP
4bcf			 
4bcf					FORTH_DSP_VALUE 
4bcf cd 42 24			call macro_forth_dsp_value 
4bd2				endm 
# End of macro FORTH_DSP_VALUE
4bd2			 
4bd2 e5					push hl   ; s1 
4bd3			 
4bd3					FORTH_DSP_POP 
4bd3 cd 11 25			call macro_forth_dsp_pop 
4bd6				endm 
# End of macro FORTH_DSP_POP
4bd6					 
4bd6			 
4bd6					; copy s1 
4bd6			 
4bd6				 
4bd6					; save ptr 
4bd6 e1					pop hl  
4bd7 e5					push hl 
4bd8 3e 00				ld a, 0 
4bda cd 97 15				call strlent 
4bdd					;inc hl    ; zer0 
4bdd 06 00				ld b, 0 
4bdf 4d					ld c, l 
4be0 e1					pop hl		 
4be1 11 fc f0				ld de, scratch	 
4be4					if DEBUG_FORTH_WORDS 
4be4						DMARK "CO1" 
4be4 f5				push af  
4be5 3a f9 4b			ld a, (.dmark)  
4be8 32 a6 fd			ld (debug_mark),a  
4beb 3a fa 4b			ld a, (.dmark+1)  
4bee 32 a7 fd			ld (debug_mark+1),a  
4bf1 3a fb 4b			ld a, (.dmark+2)  
4bf4 32 a8 fd			ld (debug_mark+2),a  
4bf7 18 03			jr .pastdmark  
4bf9 ..			.dmark: db "CO1"  
4bfc f1			.pastdmark: pop af  
4bfd			endm  
# End of macro DMARK
4bfd						CALLMONITOR 
4bfd cd aa fd			call debug_vector  
4c00				endm  
# End of macro CALLMONITOR
4c00					endif 
4c00 ed b0				ldir 
4c02			 
4c02 e1					pop hl 
4c03 e5					push hl 
4c04 d5					push de 
4c05			 
4c05			 
4c05 3e 00				ld a, 0 
4c07 cd 97 15				call strlent 
4c0a 23					inc hl    ; zer0 
4c0b 23					inc hl 
4c0c 06 00				ld b, 0 
4c0e 4d					ld c, l 
4c0f d1					pop de 
4c10 e1					pop hl		 
4c11					if DEBUG_FORTH_WORDS 
4c11						DMARK "CO2" 
4c11 f5				push af  
4c12 3a 26 4c			ld a, (.dmark)  
4c15 32 a6 fd			ld (debug_mark),a  
4c18 3a 27 4c			ld a, (.dmark+1)  
4c1b 32 a7 fd			ld (debug_mark+1),a  
4c1e 3a 28 4c			ld a, (.dmark+2)  
4c21 32 a8 fd			ld (debug_mark+2),a  
4c24 18 03			jr .pastdmark  
4c26 ..			.dmark: db "CO2"  
4c29 f1			.pastdmark: pop af  
4c2a			endm  
# End of macro DMARK
4c2a						CALLMONITOR 
4c2a cd aa fd			call debug_vector  
4c2d				endm  
# End of macro CALLMONITOR
4c2d					endif 
4c2d ed b0				ldir 
4c2f			 
4c2f			 
4c2f			 
4c2f 21 fc f0				ld hl, scratch 
4c32					if DEBUG_FORTH_WORDS 
4c32						DMARK "CO5" 
4c32 f5				push af  
4c33 3a 47 4c			ld a, (.dmark)  
4c36 32 a6 fd			ld (debug_mark),a  
4c39 3a 48 4c			ld a, (.dmark+1)  
4c3c 32 a7 fd			ld (debug_mark+1),a  
4c3f 3a 49 4c			ld a, (.dmark+2)  
4c42 32 a8 fd			ld (debug_mark+2),a  
4c45 18 03			jr .pastdmark  
4c47 ..			.dmark: db "CO5"  
4c4a f1			.pastdmark: pop af  
4c4b			endm  
# End of macro DMARK
4c4b						CALLMONITOR 
4c4b cd aa fd			call debug_vector  
4c4e				endm  
# End of macro CALLMONITOR
4c4e					endif 
4c4e			 
4c4e cd d0 22				call forth_push_str 
4c51			 
4c51			 
4c51			 
4c51			 
4c51				       NEXTW 
4c51 c3 0f 26			jp macro_next 
4c54				endm 
# End of macro NEXTW
4c54			 
4c54			 
4c54			.FIND: 
4c54				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4c54 4b				db WORD_SYS_CORE+55             
4c55 12 4d			dw .LEN            
4c57 05				db 4 + 1 
4c58 .. 00			db "FIND",0              
4c5d				endm 
# End of macro CWHEAD
4c5d			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4c5d			 
4c5d					if DEBUG_FORTH_WORDS_KEY 
4c5d						DMARK "FND" 
4c5d f5				push af  
4c5e 3a 72 4c			ld a, (.dmark)  
4c61 32 a6 fd			ld (debug_mark),a  
4c64 3a 73 4c			ld a, (.dmark+1)  
4c67 32 a7 fd			ld (debug_mark+1),a  
4c6a 3a 74 4c			ld a, (.dmark+2)  
4c6d 32 a8 fd			ld (debug_mark+2),a  
4c70 18 03			jr .pastdmark  
4c72 ..			.dmark: db "FND"  
4c75 f1			.pastdmark: pop af  
4c76			endm  
# End of macro DMARK
4c76						CALLMONITOR 
4c76 cd aa fd			call debug_vector  
4c79				endm  
# End of macro CALLMONITOR
4c79					endif 
4c79			 
4c79			; TODO check string type 
4c79					FORTH_DSP_VALUE 
4c79 cd 42 24			call macro_forth_dsp_value 
4c7c				endm 
# End of macro FORTH_DSP_VALUE
4c7c			 
4c7c e5					push hl    
4c7d 7e					ld a,(hl)    ; char to find   
4c7e			; TODO change char to substr 
4c7e			 
4c7e f5					push af 
4c7f					 
4c7f			 
4c7f			 
4c7f					if DEBUG_FORTH_WORDS 
4c7f						DMARK "FN1" 
4c7f f5				push af  
4c80 3a 94 4c			ld a, (.dmark)  
4c83 32 a6 fd			ld (debug_mark),a  
4c86 3a 95 4c			ld a, (.dmark+1)  
4c89 32 a7 fd			ld (debug_mark+1),a  
4c8c 3a 96 4c			ld a, (.dmark+2)  
4c8f 32 a8 fd			ld (debug_mark+2),a  
4c92 18 03			jr .pastdmark  
4c94 ..			.dmark: db "FN1"  
4c97 f1			.pastdmark: pop af  
4c98			endm  
# End of macro DMARK
4c98						CALLMONITOR 
4c98 cd aa fd			call debug_vector  
4c9b				endm  
# End of macro CALLMONITOR
4c9b					endif 
4c9b			 
4c9b					FORTH_DSP_POP 
4c9b cd 11 25			call macro_forth_dsp_pop 
4c9e				endm 
# End of macro FORTH_DSP_POP
4c9e			 
4c9e					; string to search 
4c9e			 
4c9e					FORTH_DSP_VALUE 
4c9e cd 42 24			call macro_forth_dsp_value 
4ca1				endm 
# End of macro FORTH_DSP_VALUE
4ca1			 
4ca1 d1					pop de  ; d is char to find  
4ca2			 
4ca2					if DEBUG_FORTH_WORDS 
4ca2						DMARK "FN2" 
4ca2 f5				push af  
4ca3 3a b7 4c			ld a, (.dmark)  
4ca6 32 a6 fd			ld (debug_mark),a  
4ca9 3a b8 4c			ld a, (.dmark+1)  
4cac 32 a7 fd			ld (debug_mark+1),a  
4caf 3a b9 4c			ld a, (.dmark+2)  
4cb2 32 a8 fd			ld (debug_mark+2),a  
4cb5 18 03			jr .pastdmark  
4cb7 ..			.dmark: db "FN2"  
4cba f1			.pastdmark: pop af  
4cbb			endm  
# End of macro DMARK
4cbb						CALLMONITOR 
4cbb cd aa fd			call debug_vector  
4cbe				endm  
# End of macro CALLMONITOR
4cbe					endif 
4cbe					 
4cbe 01 00 00				ld bc, 0 
4cc1 7e			.findchar:      ld a,(hl) 
4cc2 fe 00				cp 0   		 
4cc4 28 27				jr z, .finddone     
4cc6 ba					cp d 
4cc7 28 20				jr z, .foundchar 
4cc9 03					inc bc 
4cca 23					inc hl 
4ccb					if DEBUG_FORTH_WORDS 
4ccb						DMARK "FN3" 
4ccb f5				push af  
4ccc 3a e0 4c			ld a, (.dmark)  
4ccf 32 a6 fd			ld (debug_mark),a  
4cd2 3a e1 4c			ld a, (.dmark+1)  
4cd5 32 a7 fd			ld (debug_mark+1),a  
4cd8 3a e2 4c			ld a, (.dmark+2)  
4cdb 32 a8 fd			ld (debug_mark+2),a  
4cde 18 03			jr .pastdmark  
4ce0 ..			.dmark: db "FN3"  
4ce3 f1			.pastdmark: pop af  
4ce4			endm  
# End of macro DMARK
4ce4						CALLMONITOR 
4ce4 cd aa fd			call debug_vector  
4ce7				endm  
# End of macro CALLMONITOR
4ce7					endif 
4ce7 18 d8				jr .findchar 
4ce9			 
4ce9			 
4ce9 c5			.foundchar:	push bc 
4cea e1					pop hl 
4ceb 18 03				jr .findexit 
4ced			 
4ced			 
4ced							 
4ced			 
4ced			.finddone:     ; got to end of string with no find 
4ced 21 00 00				ld hl, 0 
4cf0			.findexit: 
4cf0			 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "FNd" 
4cf0 f5				push af  
4cf1 3a 05 4d			ld a, (.dmark)  
4cf4 32 a6 fd			ld (debug_mark),a  
4cf7 3a 06 4d			ld a, (.dmark+1)  
4cfa 32 a7 fd			ld (debug_mark+1),a  
4cfd 3a 07 4d			ld a, (.dmark+2)  
4d00 32 a8 fd			ld (debug_mark+2),a  
4d03 18 03			jr .pastdmark  
4d05 ..			.dmark: db "FNd"  
4d08 f1			.pastdmark: pop af  
4d09			endm  
# End of macro DMARK
4d09						CALLMONITOR 
4d09 cd aa fd			call debug_vector  
4d0c				endm  
# End of macro CALLMONITOR
4d0c					endif 
4d0c cd 62 22			call forth_push_numhl 
4d0f			 
4d0f				       NEXTW 
4d0f c3 0f 26			jp macro_next 
4d12				endm 
# End of macro NEXTW
4d12			 
4d12			.LEN: 
4d12				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4d12 4c				db WORD_SYS_CORE+56             
4d13 7c 4d			dw .ASC            
4d15 06				db 5 + 1 
4d16 .. 00			db "COUNT",0              
4d1c				endm 
# End of macro CWHEAD
4d1c			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4d1c			 
4d1c					if DEBUG_FORTH_WORDS_KEY 
4d1c						DMARK "CNT" 
4d1c f5				push af  
4d1d 3a 31 4d			ld a, (.dmark)  
4d20 32 a6 fd			ld (debug_mark),a  
4d23 3a 32 4d			ld a, (.dmark+1)  
4d26 32 a7 fd			ld (debug_mark+1),a  
4d29 3a 33 4d			ld a, (.dmark+2)  
4d2c 32 a8 fd			ld (debug_mark+2),a  
4d2f 18 03			jr .pastdmark  
4d31 ..			.dmark: db "CNT"  
4d34 f1			.pastdmark: pop af  
4d35			endm  
# End of macro DMARK
4d35						CALLMONITOR 
4d35 cd aa fd			call debug_vector  
4d38				endm  
# End of macro CALLMONITOR
4d38					endif 
4d38			; TODO check string type 
4d38					FORTH_DSP_VALUE 
4d38 cd 42 24			call macro_forth_dsp_value 
4d3b				endm 
# End of macro FORTH_DSP_VALUE
4d3b			 
4d3b			 
4d3b					if DEBUG_FORTH_WORDS 
4d3b						DMARK "CN?" 
4d3b f5				push af  
4d3c 3a 50 4d			ld a, (.dmark)  
4d3f 32 a6 fd			ld (debug_mark),a  
4d42 3a 51 4d			ld a, (.dmark+1)  
4d45 32 a7 fd			ld (debug_mark+1),a  
4d48 3a 52 4d			ld a, (.dmark+2)  
4d4b 32 a8 fd			ld (debug_mark+2),a  
4d4e 18 03			jr .pastdmark  
4d50 ..			.dmark: db "CN?"  
4d53 f1			.pastdmark: pop af  
4d54			endm  
# End of macro DMARK
4d54						CALLMONITOR 
4d54 cd aa fd			call debug_vector  
4d57				endm  
# End of macro CALLMONITOR
4d57					endif 
4d57 cd 8c 15				call strlenz 
4d5a					if DEBUG_FORTH_WORDS 
4d5a						DMARK "CNl" 
4d5a f5				push af  
4d5b 3a 6f 4d			ld a, (.dmark)  
4d5e 32 a6 fd			ld (debug_mark),a  
4d61 3a 70 4d			ld a, (.dmark+1)  
4d64 32 a7 fd			ld (debug_mark+1),a  
4d67 3a 71 4d			ld a, (.dmark+2)  
4d6a 32 a8 fd			ld (debug_mark+2),a  
4d6d 18 03			jr .pastdmark  
4d6f ..			.dmark: db "CNl"  
4d72 f1			.pastdmark: pop af  
4d73			endm  
# End of macro DMARK
4d73						CALLMONITOR 
4d73 cd aa fd			call debug_vector  
4d76				endm  
# End of macro CALLMONITOR
4d76					endif 
4d76			 
4d76 cd 62 22				call forth_push_numhl 
4d79			 
4d79			 
4d79			 
4d79				       NEXTW 
4d79 c3 0f 26			jp macro_next 
4d7c				endm 
# End of macro NEXTW
4d7c			.ASC: 
4d7c				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4d7c 4d				db WORD_SYS_CORE+57             
4d7d ea 4d			dw .CHR            
4d7f 04				db 3 + 1 
4d80 .. 00			db "ASC",0              
4d84				endm 
# End of macro CWHEAD
4d84			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4d84					if DEBUG_FORTH_WORDS_KEY 
4d84						DMARK "ASC" 
4d84 f5				push af  
4d85 3a 99 4d			ld a, (.dmark)  
4d88 32 a6 fd			ld (debug_mark),a  
4d8b 3a 9a 4d			ld a, (.dmark+1)  
4d8e 32 a7 fd			ld (debug_mark+1),a  
4d91 3a 9b 4d			ld a, (.dmark+2)  
4d94 32 a8 fd			ld (debug_mark+2),a  
4d97 18 03			jr .pastdmark  
4d99 ..			.dmark: db "ASC"  
4d9c f1			.pastdmark: pop af  
4d9d			endm  
# End of macro DMARK
4d9d						CALLMONITOR 
4d9d cd aa fd			call debug_vector  
4da0				endm  
# End of macro CALLMONITOR
4da0					endif 
4da0					FORTH_DSP_VALUE 
4da0 cd 42 24			call macro_forth_dsp_value 
4da3				endm 
# End of macro FORTH_DSP_VALUE
4da3					;v5 FORTH_DSP_VALUE 
4da3			;		inc hl      ; now at start of numeric as string 
4da3			 
4da3 e5					push hl 
4da4			 
4da4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4da4 cd 11 25			call macro_forth_dsp_pop 
4da7				endm 
# End of macro FORTH_DSP_POP
4da7			 
4da7 e1					pop hl 
4da8			 
4da8					if DEBUG_FORTH_WORDS 
4da8						DMARK "AS1" 
4da8 f5				push af  
4da9 3a bd 4d			ld a, (.dmark)  
4dac 32 a6 fd			ld (debug_mark),a  
4daf 3a be 4d			ld a, (.dmark+1)  
4db2 32 a7 fd			ld (debug_mark+1),a  
4db5 3a bf 4d			ld a, (.dmark+2)  
4db8 32 a8 fd			ld (debug_mark+2),a  
4dbb 18 03			jr .pastdmark  
4dbd ..			.dmark: db "AS1"  
4dc0 f1			.pastdmark: pop af  
4dc1			endm  
# End of macro DMARK
4dc1						CALLMONITOR 
4dc1 cd aa fd			call debug_vector  
4dc4				endm  
# End of macro CALLMONITOR
4dc4					endif 
4dc4					; push the content of a onto the stack as a value 
4dc4			 
4dc4 7e					ld a,(hl)   ; get char 
4dc5 26 00				ld h,0 
4dc7 6f					ld l,a 
4dc8					if DEBUG_FORTH_WORDS 
4dc8						DMARK "AS2" 
4dc8 f5				push af  
4dc9 3a dd 4d			ld a, (.dmark)  
4dcc 32 a6 fd			ld (debug_mark),a  
4dcf 3a de 4d			ld a, (.dmark+1)  
4dd2 32 a7 fd			ld (debug_mark+1),a  
4dd5 3a df 4d			ld a, (.dmark+2)  
4dd8 32 a8 fd			ld (debug_mark+2),a  
4ddb 18 03			jr .pastdmark  
4ddd ..			.dmark: db "AS2"  
4de0 f1			.pastdmark: pop af  
4de1			endm  
# End of macro DMARK
4de1						CALLMONITOR 
4de1 cd aa fd			call debug_vector  
4de4				endm  
# End of macro CALLMONITOR
4de4					endif 
4de4 cd 62 22				call forth_push_numhl 
4de7			 
4de7				       NEXTW 
4de7 c3 0f 26			jp macro_next 
4dea				endm 
# End of macro NEXTW
4dea			 
4dea			.CHR: 
4dea				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4dea 4d				db WORD_SYS_CORE+57             
4deb 26 4e			dw .ENDSTR            
4ded 04				db 3 + 1 
4dee .. 00			db "CHR",0              
4df2				endm 
# End of macro CWHEAD
4df2			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4df2					if DEBUG_FORTH_WORDS_KEY 
4df2						DMARK "CHR" 
4df2 f5				push af  
4df3 3a 07 4e			ld a, (.dmark)  
4df6 32 a6 fd			ld (debug_mark),a  
4df9 3a 08 4e			ld a, (.dmark+1)  
4dfc 32 a7 fd			ld (debug_mark+1),a  
4dff 3a 09 4e			ld a, (.dmark+2)  
4e02 32 a8 fd			ld (debug_mark+2),a  
4e05 18 03			jr .pastdmark  
4e07 ..			.dmark: db "CHR"  
4e0a f1			.pastdmark: pop af  
4e0b			endm  
# End of macro DMARK
4e0b						CALLMONITOR 
4e0b cd aa fd			call debug_vector  
4e0e				endm  
# End of macro CALLMONITOR
4e0e					endif 
4e0e					FORTH_DSP_VALUEHL 
4e0e cd 59 24			call macro_dsp_valuehl 
4e11				endm 
# End of macro FORTH_DSP_VALUEHL
4e11			 
4e11					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e11 cd 11 25			call macro_forth_dsp_pop 
4e14				endm 
# End of macro FORTH_DSP_POP
4e14			 
4e14					; save asci byte as a zero term string and push string 
4e14			 
4e14 7d					ld a,l 
4e15 32 fc f0				ld (scratch), a 
4e18			 
4e18 3e 00				ld a, 0 
4e1a 32 fd f0				ld (scratch+1), a 
4e1d			 
4e1d 21 fc f0				ld hl, scratch 
4e20 cd d0 22				call forth_push_str 
4e23			 
4e23			 
4e23				       NEXTW 
4e23 c3 0f 26			jp macro_next 
4e26				endm 
# End of macro NEXTW
4e26			 
4e26			 
4e26			 
4e26			 
4e26			.ENDSTR: 
4e26			; eof 
4e26			 
# End of file forth_words_str.asm
4e26			include "forth_words_key.asm" 
4e26			 
4e26			; | ## Keyboard Words 
4e26			 
4e26			.KEY: 
4e26				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4e26 3e				db WORD_SYS_CORE+42             
4e27 56 4e			dw .WAITK            
4e29 04				db 3 + 1 
4e2a .. 00			db "KEY",0              
4e2e				endm 
# End of macro CWHEAD
4e2e			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4e2e			 
4e2e					if DEBUG_FORTH_WORDS_KEY 
4e2e						DMARK "KEY" 
4e2e f5				push af  
4e2f 3a 43 4e			ld a, (.dmark)  
4e32 32 a6 fd			ld (debug_mark),a  
4e35 3a 44 4e			ld a, (.dmark+1)  
4e38 32 a7 fd			ld (debug_mark+1),a  
4e3b 3a 45 4e			ld a, (.dmark+2)  
4e3e 32 a8 fd			ld (debug_mark+2),a  
4e41 18 03			jr .pastdmark  
4e43 ..			.dmark: db "KEY"  
4e46 f1			.pastdmark: pop af  
4e47			endm  
# End of macro DMARK
4e47						CALLMONITOR 
4e47 cd aa fd			call debug_vector  
4e4a				endm  
# End of macro CALLMONITOR
4e4a					endif 
4e4a			; TODO currently waits 
4e4a cd dc 7b				call cin 
4e4d					;call cin_wait 
4e4d 6f					ld l, a 
4e4e 26 00				ld h, 0 
4e50 cd 62 22				call forth_push_numhl 
4e53					NEXTW 
4e53 c3 0f 26			jp macro_next 
4e56				endm 
# End of macro NEXTW
4e56			.WAITK: 
4e56				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4e56 3f				db WORD_SYS_CORE+43             
4e57 88 4e			dw .ACCEPT            
4e59 06				db 5 + 1 
4e5a .. 00			db "WAITK",0              
4e60				endm 
# End of macro CWHEAD
4e60			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4e60					if DEBUG_FORTH_WORDS_KEY 
4e60						DMARK "WAI" 
4e60 f5				push af  
4e61 3a 75 4e			ld a, (.dmark)  
4e64 32 a6 fd			ld (debug_mark),a  
4e67 3a 76 4e			ld a, (.dmark+1)  
4e6a 32 a7 fd			ld (debug_mark+1),a  
4e6d 3a 77 4e			ld a, (.dmark+2)  
4e70 32 a8 fd			ld (debug_mark+2),a  
4e73 18 03			jr .pastdmark  
4e75 ..			.dmark: db "WAI"  
4e78 f1			.pastdmark: pop af  
4e79			endm  
# End of macro DMARK
4e79						CALLMONITOR 
4e79 cd aa fd			call debug_vector  
4e7c				endm  
# End of macro CALLMONITOR
4e7c					endif 
4e7c cd cb 7b				call cin_wait 
4e7f 6f					ld l, a 
4e80 26 00				ld h, 0 
4e82 cd 62 22				call forth_push_numhl 
4e85					NEXTW 
4e85 c3 0f 26			jp macro_next 
4e88				endm 
# End of macro NEXTW
4e88			.ACCEPT: 
4e88				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4e88 40				db WORD_SYS_CORE+44             
4e89 e6 4e			dw .EDIT            
4e8b 07				db 6 + 1 
4e8c .. 00			db "ACCEPT",0              
4e93				endm 
# End of macro CWHEAD
4e93			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4e93					; TODO crashes on push 
4e93					if DEBUG_FORTH_WORDS_KEY 
4e93						DMARK "ACC" 
4e93 f5				push af  
4e94 3a a8 4e			ld a, (.dmark)  
4e97 32 a6 fd			ld (debug_mark),a  
4e9a 3a a9 4e			ld a, (.dmark+1)  
4e9d 32 a7 fd			ld (debug_mark+1),a  
4ea0 3a aa 4e			ld a, (.dmark+2)  
4ea3 32 a8 fd			ld (debug_mark+2),a  
4ea6 18 03			jr .pastdmark  
4ea8 ..			.dmark: db "ACC"  
4eab f1			.pastdmark: pop af  
4eac			endm  
# End of macro DMARK
4eac						CALLMONITOR 
4eac cd aa fd			call debug_vector  
4eaf				endm  
# End of macro CALLMONITOR
4eaf					endif 
4eaf 21 fa f2				ld hl, os_input 
4eb2 3e 00				ld a, 0 
4eb4 77					ld (hl),a 
4eb5 3a 99 f9				ld a,(f_cursor_ptr) 
4eb8 16 64				ld d, 100 
4eba 0e 00				ld c, 0 
4ebc 1e 28				ld e, 40 
4ebe cd fc 0f				call input_str 
4ec1					; TODO perhaps do a type check and wrap in quotes if not a number 
4ec1 21 fa f2				ld hl, os_input 
4ec4					if DEBUG_FORTH_WORDS 
4ec4						DMARK "AC1" 
4ec4 f5				push af  
4ec5 3a d9 4e			ld a, (.dmark)  
4ec8 32 a6 fd			ld (debug_mark),a  
4ecb 3a da 4e			ld a, (.dmark+1)  
4ece 32 a7 fd			ld (debug_mark+1),a  
4ed1 3a db 4e			ld a, (.dmark+2)  
4ed4 32 a8 fd			ld (debug_mark+2),a  
4ed7 18 03			jr .pastdmark  
4ed9 ..			.dmark: db "AC1"  
4edc f1			.pastdmark: pop af  
4edd			endm  
# End of macro DMARK
4edd						CALLMONITOR 
4edd cd aa fd			call debug_vector  
4ee0				endm  
# End of macro CALLMONITOR
4ee0					endif 
4ee0 cd d0 22				call forth_push_str 
4ee3					NEXTW 
4ee3 c3 0f 26			jp macro_next 
4ee6				endm 
# End of macro NEXTW
4ee6			 
4ee6			.EDIT: 
4ee6				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4ee6 40				db WORD_SYS_CORE+44             
4ee7 88 4f			dw .DEDIT            
4ee9 05				db 4 + 1 
4eea .. 00			db "EDIT",0              
4eef				endm 
# End of macro CWHEAD
4eef			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4eef			 
4eef					; TODO does not copy from stack 
4eef					if DEBUG_FORTH_WORDS_KEY 
4eef						DMARK "EDT" 
4eef f5				push af  
4ef0 3a 04 4f			ld a, (.dmark)  
4ef3 32 a6 fd			ld (debug_mark),a  
4ef6 3a 05 4f			ld a, (.dmark+1)  
4ef9 32 a7 fd			ld (debug_mark+1),a  
4efc 3a 06 4f			ld a, (.dmark+2)  
4eff 32 a8 fd			ld (debug_mark+2),a  
4f02 18 03			jr .pastdmark  
4f04 ..			.dmark: db "EDT"  
4f07 f1			.pastdmark: pop af  
4f08			endm  
# End of macro DMARK
4f08						CALLMONITOR 
4f08 cd aa fd			call debug_vector  
4f0b				endm  
# End of macro CALLMONITOR
4f0b					endif 
4f0b			 
4f0b					;FORTH_DSP 
4f0b					FORTH_DSP_VALUEHL 
4f0b cd 59 24			call macro_dsp_valuehl 
4f0e				endm 
# End of macro FORTH_DSP_VALUEHL
4f0e			;		inc hl    ; TODO do type check 
4f0e			 
4f0e			;		call get_word_hl 
4f0e e5					push hl 
4f0f					if DEBUG_FORTH_WORDS 
4f0f						DMARK "EDp" 
4f0f f5				push af  
4f10 3a 24 4f			ld a, (.dmark)  
4f13 32 a6 fd			ld (debug_mark),a  
4f16 3a 25 4f			ld a, (.dmark+1)  
4f19 32 a7 fd			ld (debug_mark+1),a  
4f1c 3a 26 4f			ld a, (.dmark+2)  
4f1f 32 a8 fd			ld (debug_mark+2),a  
4f22 18 03			jr .pastdmark  
4f24 ..			.dmark: db "EDp"  
4f27 f1			.pastdmark: pop af  
4f28			endm  
# End of macro DMARK
4f28						CALLMONITOR 
4f28 cd aa fd			call debug_vector  
4f2b				endm  
# End of macro CALLMONITOR
4f2b					endif 
4f2b				;	ld a, 0 
4f2b cd 8c 15				call strlenz 
4f2e 23					inc hl 
4f2f			 
4f2f 06 00				ld b, 0 
4f31 4d					ld c, l 
4f32			 
4f32 e1					pop hl 
4f33 11 fa f2				ld de, os_input 
4f36					if DEBUG_FORTH_WORDS_KEY 
4f36						DMARK "EDc" 
4f36 f5				push af  
4f37 3a 4b 4f			ld a, (.dmark)  
4f3a 32 a6 fd			ld (debug_mark),a  
4f3d 3a 4c 4f			ld a, (.dmark+1)  
4f40 32 a7 fd			ld (debug_mark+1),a  
4f43 3a 4d 4f			ld a, (.dmark+2)  
4f46 32 a8 fd			ld (debug_mark+2),a  
4f49 18 03			jr .pastdmark  
4f4b ..			.dmark: db "EDc"  
4f4e f1			.pastdmark: pop af  
4f4f			endm  
# End of macro DMARK
4f4f						CALLMONITOR 
4f4f cd aa fd			call debug_vector  
4f52				endm  
# End of macro CALLMONITOR
4f52					endif 
4f52 ed b0				ldir 
4f54			 
4f54			 
4f54 21 fa f2				ld hl, os_input 
4f57					;ld a, 0 
4f57					;ld (hl),a 
4f57 3a 99 f9				ld a,(f_cursor_ptr) 
4f5a 16 64				ld d, 100 
4f5c 0e 00				ld c, 0 
4f5e 1e 28				ld e, 40 
4f60 cd fc 0f				call input_str 
4f63					; TODO perhaps do a type check and wrap in quotes if not a number 
4f63 21 fa f2				ld hl, os_input 
4f66					if DEBUG_FORTH_WORDS 
4f66						DMARK "ED1" 
4f66 f5				push af  
4f67 3a 7b 4f			ld a, (.dmark)  
4f6a 32 a6 fd			ld (debug_mark),a  
4f6d 3a 7c 4f			ld a, (.dmark+1)  
4f70 32 a7 fd			ld (debug_mark+1),a  
4f73 3a 7d 4f			ld a, (.dmark+2)  
4f76 32 a8 fd			ld (debug_mark+2),a  
4f79 18 03			jr .pastdmark  
4f7b ..			.dmark: db "ED1"  
4f7e f1			.pastdmark: pop af  
4f7f			endm  
# End of macro DMARK
4f7f						CALLMONITOR 
4f7f cd aa fd			call debug_vector  
4f82				endm  
# End of macro CALLMONITOR
4f82					endif 
4f82 cd d0 22				call forth_push_str 
4f85					NEXTW 
4f85 c3 0f 26			jp macro_next 
4f88				endm 
# End of macro NEXTW
4f88			 
4f88			.DEDIT: 
4f88				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4f88 40				db WORD_SYS_CORE+44             
4f89 ea 4f			dw .ENDKEY            
4f8b 06				db 5 + 1 
4f8c .. 00			db "DEDIT",0              
4f92				endm 
# End of macro CWHEAD
4f92			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4f92			 
4f92					; TODO does not copy from stack 
4f92					if DEBUG_FORTH_WORDS_KEY 
4f92						DMARK "DED" 
4f92 f5				push af  
4f93 3a a7 4f			ld a, (.dmark)  
4f96 32 a6 fd			ld (debug_mark),a  
4f99 3a a8 4f			ld a, (.dmark+1)  
4f9c 32 a7 fd			ld (debug_mark+1),a  
4f9f 3a a9 4f			ld a, (.dmark+2)  
4fa2 32 a8 fd			ld (debug_mark+2),a  
4fa5 18 03			jr .pastdmark  
4fa7 ..			.dmark: db "DED"  
4faa f1			.pastdmark: pop af  
4fab			endm  
# End of macro DMARK
4fab						CALLMONITOR 
4fab cd aa fd			call debug_vector  
4fae				endm  
# End of macro CALLMONITOR
4fae					endif 
4fae			 
4fae					;FORTH_DSP 
4fae					FORTH_DSP_VALUEHL 
4fae cd 59 24			call macro_dsp_valuehl 
4fb1				endm 
# End of macro FORTH_DSP_VALUEHL
4fb1			;		inc hl    ; TODO do type check 
4fb1			 
4fb1			;		call get_word_hl 
4fb1 e5					push hl 
4fb2 e5					push hl 
4fb3					FORTH_DSP_POP 
4fb3 cd 11 25			call macro_forth_dsp_pop 
4fb6				endm 
# End of macro FORTH_DSP_POP
4fb6 e1					pop hl 
4fb7					if DEBUG_FORTH_WORDS 
4fb7						DMARK "EDp" 
4fb7 f5				push af  
4fb8 3a cc 4f			ld a, (.dmark)  
4fbb 32 a6 fd			ld (debug_mark),a  
4fbe 3a cd 4f			ld a, (.dmark+1)  
4fc1 32 a7 fd			ld (debug_mark+1),a  
4fc4 3a ce 4f			ld a, (.dmark+2)  
4fc7 32 a8 fd			ld (debug_mark+2),a  
4fca 18 03			jr .pastdmark  
4fcc ..			.dmark: db "EDp"  
4fcf f1			.pastdmark: pop af  
4fd0			endm  
# End of macro DMARK
4fd0						CALLMONITOR 
4fd0 cd aa fd			call debug_vector  
4fd3				endm  
# End of macro CALLMONITOR
4fd3					endif 
4fd3				;	ld a, 0 
4fd3 cd 8c 15				call strlenz 
4fd6 23					inc hl 
4fd7			 
4fd7 06 00				ld b, 0 
4fd9 4d					ld c, l 
4fda			 
4fda e1					pop hl 
4fdb			 
4fdb					;ld a, 0 
4fdb					;ld (hl),a 
4fdb 3a 99 f9				ld a,(f_cursor_ptr) 
4fde 16 64				ld d, 100 
4fe0 0e 00				ld c, 0 
4fe2 1e 28				ld e, 40 
4fe4 cd fc 0f				call input_str 
4fe7					; TODO perhaps do a type check and wrap in quotes if not a number 
4fe7					NEXTW 
4fe7 c3 0f 26			jp macro_next 
4fea				endm 
# End of macro NEXTW
4fea			 
4fea			 
4fea			.ENDKEY: 
4fea			; eof 
4fea			 
# End of file forth_words_key.asm
4fea			include "forth_words_const.asm" 
4fea			 
4fea			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4fea			 
4fea			 
4fea			.SPITIME: 
4fea				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4fea 77				db WORD_SYS_CORE+99             
4feb ff 4f			dw .VA            
4fed 08				db 7 + 1 
4fee .. 00			db "SPITIME",0              
4ff6				endm 
# End of macro CWHEAD
4ff6			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4ff6			; 
4ff6			; | | If using BANK devices then leave as is. 
4ff6			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4ff6			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4ff6			 
4ff6 21 9f f9				ld hl, spi_clktime  
4ff9 cd 62 22				call forth_push_numhl 
4ffc			 
4ffc					NEXTW 
4ffc c3 0f 26			jp macro_next 
4fff				endm 
# End of macro NEXTW
4fff			 
4fff			 
4fff			.VA: 
4fff				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4fff 77				db WORD_SYS_CORE+99             
5000 0f 50			dw .SYMBOL            
5002 03				db 2 + 1 
5003 .. 00			db "VA",0              
5006				endm 
# End of macro CWHEAD
5006			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
5006 21 63 f9				ld hl, cli_var_array 
5009 cd 62 22				call forth_push_numhl 
500c			 
500c					NEXTW 
500c c3 0f 26			jp macro_next 
500f				endm 
# End of macro NEXTW
500f			 
500f			.SYMBOL: 
500f				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
500f 77				db WORD_SYS_CORE+99             
5010 19 51			dw .ENDCONST            
5012 07				db 6 + 1 
5013 .. 00			db "SYMBOL",0              
501a				endm 
# End of macro CWHEAD
501a			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
501a			; | 
501a			; | | The value is the number reference and the final address is pushed to stack 
501a			 
501a			; | | ``` 
501a			; | | dw sym_table 
501a			; | | dw nmi_vector 
501a			; | | dw cli_autodisplay 
501a			; | | dw cli_data_sp 
501a			; | | dw cli_data_stack 
501a			; | | dw cli_loop_sp 
501a			; | | dw cli_loop_stack 
501a			; | | dw cli_var_array 
501a			; | | dw cursor_col 
501a			; | | dw cursor_ptr 
501a			; | | ; 10 
501a			; | | dw cursor_row 
501a			; | | dw debug_mark 
501a			; | | dw display_fb0 
501a			; | | dw display_fb1 
501a			; | | dw display_fb2 
501a			; | | dw display_fb3 
501a			; | | dw display_fb_active 
501a			; | | dw execscratch 
501a			; | | dw f_cursor_ptr 
501a			; | | dw hardware_word 
501a			; | | ;20 
501a			; | | dw input_at_cursor 
501a			; | | dw input_at_pos 
501a			; | | dw input_cur_flash 
501a			; | | dw input_cur_onoff 
501a			; | | dw input_cursor 
501a			; | | dw input_display_size 
501a			; | | dw input_len 
501a			; | | dw input_ptr 
501a			; | | dw input_size 
501a			; | | dw input_start 
501a			; | | ; 30 
501a			; | | dw input_str 
501a			; | | dw input_under_cursor 
501a			; | | dw os_cli_cmd 
501a			; | | dw os_cur_ptr 
501a			; | | dw os_current_i 
501a			; | | dw os_input 
501a			; | | dw os_last_cmd 
501a			; | | dw os_last_new_uword 
501a			; | | dw debug_vector 
501a			; | | dw os_view_hl 
501a			; | | ;40 
501a			; | | dw os_word_scratch 
501a			; | | dw portbctl 
501a			; | | dw portbdata 
501a			; | | dw spi_cartdev 
501a			; | | dw spi_cartdev2 
501a			; | | dw spi_clktime 
501a			; | | dw spi_device 
501a			; | | dw spi_device_id 
501a			; | | dw spi_portbyte 
501a			; | | dw stackstore 
501a			; | | ; 50 
501a			; | | if STORAGE_SE 
501a			; | | dw storage_actl 
501a			; | | dw storage_adata 
501a			; | | else 
501a			; | | dw 0 
501a			; | | dw 0 
501a			; | | endif 
501a			; | | dw storage_append 
501a			; | | if STORAGE_SE 
501a			; | | dw storage_bctl 
501a			; | | else 
501a			; | | dw 0 
501a			; | | endif 
501a			; | | dw store_bank_active 
501a			; | | dw store_filecache 
501a			; | | dw store_longread 
501a			; | | dw store_openaddr 
501a			; | | dw store_openext 
501a			; | | dw store_openmaxext 
501a			; | | ; 60 
501a			; | | dw store_page 
501a			; | | dw store_readbuf 
501a			; | | dw store_readcont 
501a			; | | dw store_readptr 
501a			; | | dw store_tmpext 
501a			; | | dw store_tmpid 
501a			; | | dw store_tmppageid 
501a			; | | dw malloc 
501a			; | | dw free 
501a			; | | dw cin 
501a			; | | ; 70 
501a			; | | dw cin_wait 
501a			; | | dw forth_push_numhl 
501a			; | | dw forth_push_str 
501a			; | | ``` 
501a			 
501a					if DEBUG_FORTH_WORDS_KEY 
501a						DMARK "SYM" 
501a f5				push af  
501b 3a 2f 50			ld a, (.dmark)  
501e 32 a6 fd			ld (debug_mark),a  
5021 3a 30 50			ld a, (.dmark+1)  
5024 32 a7 fd			ld (debug_mark+1),a  
5027 3a 31 50			ld a, (.dmark+2)  
502a 32 a8 fd			ld (debug_mark+2),a  
502d 18 03			jr .pastdmark  
502f ..			.dmark: db "SYM"  
5032 f1			.pastdmark: pop af  
5033			endm  
# End of macro DMARK
5033						CALLMONITOR 
5033 cd aa fd			call debug_vector  
5036				endm  
# End of macro CALLMONITOR
5036					endif 
5036			 
5036					FORTH_DSP_VALUEHL 
5036 cd 59 24			call macro_dsp_valuehl 
5039				endm 
# End of macro FORTH_DSP_VALUEHL
5039			 
5039 7d					ld a, l     
503a			 
503a			 
503a					if DEBUG_FORTH_WORDS 
503a						DMARK "SY1" 
503a f5				push af  
503b 3a 4f 50			ld a, (.dmark)  
503e 32 a6 fd			ld (debug_mark),a  
5041 3a 50 50			ld a, (.dmark+1)  
5044 32 a7 fd			ld (debug_mark+1),a  
5047 3a 51 50			ld a, (.dmark+2)  
504a 32 a8 fd			ld (debug_mark+2),a  
504d 18 03			jr .pastdmark  
504f ..			.dmark: db "SY1"  
5052 f1			.pastdmark: pop af  
5053			endm  
# End of macro DMARK
5053						CALLMONITOR 
5053 cd aa fd			call debug_vector  
5056				endm  
# End of macro CALLMONITOR
5056					endif 
5056					 
5056 f5					push af	 
5057					FORTH_DSP_POP 
5057 cd 11 25			call macro_forth_dsp_pop 
505a				endm 
# End of macro FORTH_DSP_POP
505a f1					pop af 
505b			 
505b cb 27				sla a  
505d				 
505d					 
505d					if DEBUG_FORTH_WORDS 
505d						DMARK "SY" 
505d f5				push af  
505e 3a 72 50			ld a, (.dmark)  
5061 32 a6 fd			ld (debug_mark),a  
5064 3a 73 50			ld a, (.dmark+1)  
5067 32 a7 fd			ld (debug_mark+1),a  
506a 3a 74 50			ld a, (.dmark+2)  
506d 32 a8 fd			ld (debug_mark+2),a  
5070 18 02			jr .pastdmark  
5072 ..			.dmark: db "SY"  
5074 f1			.pastdmark: pop af  
5075			endm  
# End of macro DMARK
5075						CALLMONITOR 
5075 cd aa fd			call debug_vector  
5078				endm  
# End of macro CALLMONITOR
5078					endif 
5078			 
5078 21 87 50				ld hl, sym_table 
507b cd cf 0f				call addatohl 
507e cd 91 25				call loadwordinhl 
5081 cd 62 22				call forth_push_numhl 
5084			 
5084			 
5084				       NEXTW 
5084 c3 0f 26			jp macro_next 
5087				endm 
# End of macro NEXTW
5087			 
5087			sym_table: 
5087			 
5087			; 0 
5087 87 50		dw sym_table 
5089 ad fd		dw nmi_vector 
508b 77 f9		dw cli_autodisplay 
508d 29 f9		dw cli_data_sp 
508f 63 f6		dw cli_data_stack 
5091 2b f9		dw cli_loop_sp 
5093 65 f8		dw cli_loop_stack 
5095 63 f9		dw cli_var_array 
5097 00 fb		dw cursor_col 
5099 fe fa		dw cursor_ptr 
509b			; 10 
509b ff fa		dw cursor_row 
509d a6 fd		dw debug_mark 
509f ec fc		dw display_fb0 
50a1 4b fc		dw display_fb1 
50a3 09 fb		dw display_fb2 
50a5 aa fb		dw display_fb3 
50a7 07 fb		dw display_fb_active 
50a9 fb f1		dw execscratch 
50ab 99 f9		dw f_cursor_ptr 
50ad b0 fd		dw hardware_word 
50af			;20 
50af 9d fd		dw input_at_cursor 
50b1 9f fd		dw input_at_pos 
50b3 9b fd		dw input_cur_flash 
50b5 9a fd		dw input_cur_onoff 
50b7 90 fd		dw input_cursor 
50b9 a0 fd		dw input_display_size 
50bb 95 fd		dw input_len 
50bd a4 fd		dw input_ptr 
50bf a1 fd		dw input_size 
50c1 a2 fd		dw input_start 
50c3			; 30 
50c3 fc 0f		dw input_str 
50c5 9e fd		dw input_under_cursor 
50c7 23 f4		dw os_cli_cmd 
50c9 1f f4		dw os_cur_ptr 
50cb 21 f4		dw os_current_i 
50cd fa f2		dw os_input 
50cf 22 f5		dw os_last_cmd 
50d1 f9 f3		dw os_last_new_uword 
50d3 aa fd		dw debug_vector 
50d5 de f0		dw os_view_hl 
50d7			;40 
50d7 01 f4		dw os_word_scratch 
50d9 c3 00		dw portbctl 
50db c1 00		dw portbdata 
50dd 9e f9		dw spi_cartdev 
50df 9d f9		dw spi_cartdev2 
50e1 9f f9		dw spi_clktime 
50e3 9b f9		dw spi_device 
50e5 9a f9		dw spi_device_id 
50e7 9c f9		dw spi_portbyte 
50e9 e2 fa		dw stackstore 
50eb			; 50 
50eb			if STORAGE_SE 
50eb 82 00		dw storage_actl 
50ed 80 00		dw storage_adata 
50ef			else 
50ef			dw 0 
50ef			dw 0 
50ef			endif 
50ef 55 0b		dw storage_append 
50f1			if STORAGE_SE 
50f1 83 00		dw storage_bctl 
50f3			else 
50f3			dw 0 
50f3			endif 
50f3 ce fa		dw store_bank_active 
50f5 a2 f9		dw store_filecache 
50f7 b0 f9		dw store_longread 
50f9 a6 f9		dw store_openaddr 
50fb a5 f9		dw store_openext 
50fd a4 f9		dw store_openmaxext 
50ff			; 60 
50ff b5 f9		dw store_page 
5101 b1 f9		dw store_readbuf 
5103 a8 f9		dw store_readcont 
5105 b3 f9		dw store_readptr 
5107 a8 f9		dw store_tmpext 
5109 a9 f9		dw store_tmpid 
510b a0 f9		dw store_tmppageid 
510d 01 16		dw malloc 
510f cb 16		dw free 
5111 dc 7b		dw cin 
5113			; 70 
5113 cb 7b		dw cin_wait 
5115 62 22		dw forth_push_numhl 
5117 d0 22		dw forth_push_str 
5119			 
5119			 
5119			.ENDCONST: 
5119			 
5119			; eof 
5119			 
5119			 
# End of file forth_words_const.asm
5119			 
5119			if STORAGE_SE 
5119			   	include "forth_words_storage.asm" 
5119			 
5119			; | ## Fixed Storage Words 
5119			 
5119			.RENAME: 
5119			  
5119				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
5119 3a				db WORD_SYS_CORE+38             
511a 0f 52			dw .RECORD            
511c 07				db 6 + 1 
511d .. 00			db "RENAME",0              
5124				endm 
# End of macro CWHEAD
5124			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
5124			; | | > [!NOTE] 
5124			; | | > Compatible with PicoSPINet  
5124					if DEBUG_FORTH_WORDS_KEY 
5124						DMARK "REN" 
5124 f5				push af  
5125 3a 39 51			ld a, (.dmark)  
5128 32 a6 fd			ld (debug_mark),a  
512b 3a 3a 51			ld a, (.dmark+1)  
512e 32 a7 fd			ld (debug_mark+1),a  
5131 3a 3b 51			ld a, (.dmark+2)  
5134 32 a8 fd			ld (debug_mark+2),a  
5137 18 03			jr .pastdmark  
5139 ..			.dmark: db "REN"  
513c f1			.pastdmark: pop af  
513d			endm  
# End of macro DMARK
513d						CALLMONITOR 
513d cd aa fd			call debug_vector  
5140				endm  
# End of macro CALLMONITOR
5140					endif 
5140			 
5140			 
5140					; preserve some internal vars used by other file handing routines 
5140			 
5140 2a a6 f9				ld hl, (store_openaddr) 
5143 e5					push hl 
5144 3a a8 f9				ld a, (store_readcont) 
5147 f5					push af 
5148			 
5148					FORTH_DSP_VALUEHL 
5148 cd 59 24			call macro_dsp_valuehl 
514b				endm 
# End of macro FORTH_DSP_VALUEHL
514b			 
514b					; move ext and id around for the file header 
514b			 
514b 65					ld h, l 
514c 2e 00				ld l, 0 
514e			 
514e e5					push hl    ; id 
514f			 
514f					FORTH_DSP_POP 
514f cd 11 25			call macro_forth_dsp_pop 
5152				endm 
# End of macro FORTH_DSP_POP
5152			 
5152					; Locate the file header 
5152			 
5152 e1					pop hl 
5153 e5					push hl 
5154 11 b5 f9				ld de, store_page      ; get block zero of file 
5157					if DEBUG_FORTH_WORDS 
5157						DMARK "REr" 
5157 f5				push af  
5158 3a 6c 51			ld a, (.dmark)  
515b 32 a6 fd			ld (debug_mark),a  
515e 3a 6d 51			ld a, (.dmark+1)  
5161 32 a7 fd			ld (debug_mark+1),a  
5164 3a 6e 51			ld a, (.dmark+2)  
5167 32 a8 fd			ld (debug_mark+2),a  
516a 18 03			jr .pastdmark  
516c ..			.dmark: db "REr"  
516f f1			.pastdmark: pop af  
5170			endm  
# End of macro DMARK
5170						CALLMONITOR 
5170 cd aa fd			call debug_vector  
5173				endm  
# End of macro CALLMONITOR
5173					endif 
5173 cd be 09				call storage_read 
5176			 
5176 cd f8 0f			call ishlzero 
5179 20 05			jr nz, .rnfound 
517b			 
517b				; file does not exist so indicate with 255 extents in use 
517b			 
517b 3e ff			ld a, 255 
517d e1				pop hl ; clear dup hl 
517e 18 7b			jr .skiprneof 
5180			 
5180			 
5180			.rnfound: 
5180					; file found so rename 
5180			 
5180					FORTH_DSP_VALUEHL 
5180 cd 59 24			call macro_dsp_valuehl 
5183				endm 
# End of macro FORTH_DSP_VALUEHL
5183			 
5183 e5				push hl 
5184 3e 00			ld a, 0 
5186 cd 97 15			call strlent 
5189 23				inc hl   ; cover zero term 
518a 06 00			ld b,0 
518c 4d				ld c,l 
518d e1				pop hl 
518e 11 b8 f9				ld de, store_page + 3 
5191 ed b0				ldir 
5193			 
5193 11 b5 f9				ld de, store_page 
5196					if DEBUG_FORTH_WORDS 
5196						DMARK "RER" 
5196 f5				push af  
5197 3a ab 51			ld a, (.dmark)  
519a 32 a6 fd			ld (debug_mark),a  
519d 3a ac 51			ld a, (.dmark+1)  
51a0 32 a7 fd			ld (debug_mark+1),a  
51a3 3a ad 51			ld a, (.dmark+2)  
51a6 32 a8 fd			ld (debug_mark+2),a  
51a9 18 03			jr .pastdmark  
51ab ..			.dmark: db "RER"  
51ae f1			.pastdmark: pop af  
51af			endm  
# End of macro DMARK
51af						CALLMONITOR 
51af cd aa fd			call debug_vector  
51b2				endm  
# End of macro CALLMONITOR
51b2					endif 
51b2			 
51b2 e1					pop hl    ; get orig file id and mangle it for find id 
51b3 55					ld d, l 
51b4 5c					ld e, h 
51b5			 
51b5 21 00 00				ld hl, 0 
51b8					if DEBUG_FORTH_WORDS 
51b8						DMARK "REf" 
51b8 f5				push af  
51b9 3a cd 51			ld a, (.dmark)  
51bc 32 a6 fd			ld (debug_mark),a  
51bf 3a ce 51			ld a, (.dmark+1)  
51c2 32 a7 fd			ld (debug_mark+1),a  
51c5 3a cf 51			ld a, (.dmark+2)  
51c8 32 a8 fd			ld (debug_mark+2),a  
51cb 18 03			jr .pastdmark  
51cd ..			.dmark: db "REf"  
51d0 f1			.pastdmark: pop af  
51d1			endm  
# End of macro DMARK
51d1						CALLMONITOR 
51d1 cd aa fd			call debug_vector  
51d4				endm  
# End of macro CALLMONITOR
51d4					endif 
51d4 cd 98 07				call storage_findnextid 
51d7 11 b5 f9				ld de, store_page 
51da					if DEBUG_FORTH_WORDS 
51da						DMARK "REw" 
51da f5				push af  
51db 3a ef 51			ld a, (.dmark)  
51de 32 a6 fd			ld (debug_mark),a  
51e1 3a f0 51			ld a, (.dmark+1)  
51e4 32 a7 fd			ld (debug_mark+1),a  
51e7 3a f1 51			ld a, (.dmark+2)  
51ea 32 a8 fd			ld (debug_mark+2),a  
51ed 18 03			jr .pastdmark  
51ef ..			.dmark: db "REw"  
51f2 f1			.pastdmark: pop af  
51f3			endm  
# End of macro DMARK
51f3						CALLMONITOR 
51f3 cd aa fd			call debug_vector  
51f6				endm  
# End of macro CALLMONITOR
51f6					endif 
51f6 cd ca 04				call storage_write_block 
51f9			 
51f9 3e 00				ld a, 0 
51fb			.skiprneof: 
51fb					; drop file name 
51fb					FORTH_DSP_POP 
51fb cd 11 25			call macro_forth_dsp_pop 
51fe				endm 
# End of macro FORTH_DSP_POP
51fe			 
51fe 6f					ld l, a 
51ff 26 00				ld h, 0 
5201 cd 62 22				call forth_push_numhl 
5204			 
5204			 
5204 f1					pop af 
5205 32 a8 f9				ld (store_readcont),a 
5208 e1					pop hl 
5209 22 a6 f9				ld (store_openaddr), hl 
520c						 
520c				NEXTW 
520c c3 0f 26			jp macro_next 
520f				endm 
# End of macro NEXTW
520f			.RECORD: 
520f			  
520f				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
520f 3a				db WORD_SYS_CORE+38             
5210 b3 52			dw .BREAD            
5212 07				db 6 + 1 
5213 .. 00			db "RECORD",0              
521a				endm 
# End of macro CWHEAD
521a			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
521a			; | | > [!NOTE] 
521a			; | | > Compatible with PicoSPINet  
521a			 
521a					if DEBUG_FORTH_WORDS_KEY 
521a						DMARK "REC" 
521a f5				push af  
521b 3a 2f 52			ld a, (.dmark)  
521e 32 a6 fd			ld (debug_mark),a  
5221 3a 30 52			ld a, (.dmark+1)  
5224 32 a7 fd			ld (debug_mark+1),a  
5227 3a 31 52			ld a, (.dmark+2)  
522a 32 a8 fd			ld (debug_mark+2),a  
522d 18 03			jr .pastdmark  
522f ..			.dmark: db "REC"  
5232 f1			.pastdmark: pop af  
5233			endm  
# End of macro DMARK
5233						CALLMONITOR 
5233 cd aa fd			call debug_vector  
5236				endm  
# End of macro CALLMONITOR
5236					endif 
5236			 
5236					FORTH_DSP_VALUEHL 
5236 cd 59 24			call macro_dsp_valuehl 
5239				endm 
# End of macro FORTH_DSP_VALUEHL
5239			 
5239 e5					push hl    ; id 
523a			 
523a					FORTH_DSP_POP 
523a cd 11 25			call macro_forth_dsp_pop 
523d				endm 
# End of macro FORTH_DSP_POP
523d			 
523d					FORTH_DSP_VALUEHL 
523d cd 59 24			call macro_dsp_valuehl 
5240				endm 
# End of macro FORTH_DSP_VALUEHL
5240			 
5240					FORTH_DSP_POP 
5240 cd 11 25			call macro_forth_dsp_pop 
5243				endm 
# End of macro FORTH_DSP_POP
5243			 
5243 d1					pop de     ; get file id 
5244			 
5244					; e = file id 
5244					; l = file extent 
5244			 
5244			 
5244					; construct request to access file extent 
5244			 
5244			;		ld a, e 
5244 63					ld h, e 
5245					 
5245					 
5245					 
5245			 
5245					; e has id 
5245			 
5245 11 b5 f9			ld de, store_page 
5248					if DEBUG_FORTH_WORDS 
5248						DMARK "REr" 
5248 f5				push af  
5249 3a 5d 52			ld a, (.dmark)  
524c 32 a6 fd			ld (debug_mark),a  
524f 3a 5e 52			ld a, (.dmark+1)  
5252 32 a7 fd			ld (debug_mark+1),a  
5255 3a 5f 52			ld a, (.dmark+2)  
5258 32 a8 fd			ld (debug_mark+2),a  
525b 18 03			jr .pastdmark  
525d ..			.dmark: db "REr"  
5260 f1			.pastdmark: pop af  
5261			endm  
# End of macro DMARK
5261						CALLMONITOR 
5261 cd aa fd			call debug_vector  
5264				endm  
# End of macro CALLMONITOR
5264					endif 
5264 cd be 09				call storage_read 
5267 cd f8 0f			call ishlzero 
526a 28 22			jr z, .recnotfound 
526c			 
526c			 
526c					if DEBUG_FORTH_WORDS 
526c						DMARK "REe" 
526c f5				push af  
526d 3a 81 52			ld a, (.dmark)  
5270 32 a6 fd			ld (debug_mark),a  
5273 3a 82 52			ld a, (.dmark+1)  
5276 32 a7 fd			ld (debug_mark+1),a  
5279 3a 83 52			ld a, (.dmark+2)  
527c 32 a8 fd			ld (debug_mark+2),a  
527f 18 03			jr .pastdmark  
5281 ..			.dmark: db "REe"  
5284 f1			.pastdmark: pop af  
5285			endm  
# End of macro DMARK
5285						CALLMONITOR 
5285 cd aa fd			call debug_vector  
5288				endm  
# End of macro CALLMONITOR
5288					endif 
5288 cd d0 22			call forth_push_str 
528b			 
528b					NEXTW 
528b c3 0f 26			jp macro_next 
528e				endm 
# End of macro NEXTW
528e			 
528e			.recnotfound: 
528e					if DEBUG_FORTH_WORDS 
528e						DMARK "REf" 
528e f5				push af  
528f 3a a3 52			ld a, (.dmark)  
5292 32 a6 fd			ld (debug_mark),a  
5295 3a a4 52			ld a, (.dmark+1)  
5298 32 a7 fd			ld (debug_mark+1),a  
529b 3a a5 52			ld a, (.dmark+2)  
529e 32 a8 fd			ld (debug_mark+2),a  
52a1 18 03			jr .pastdmark  
52a3 ..			.dmark: db "REf"  
52a6 f1			.pastdmark: pop af  
52a7			endm  
# End of macro DMARK
52a7						CALLMONITOR 
52a7 cd aa fd			call debug_vector  
52aa				endm  
# End of macro CALLMONITOR
52aa					endif 
52aa 21 ff 00			ld hl, 255 
52ad cd 62 22			call forth_push_numhl 
52b0				NEXTW 
52b0 c3 0f 26			jp macro_next 
52b3				endm 
# End of macro NEXTW
52b3			 
52b3			 
52b3			.BREAD: 
52b3			  
52b3				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
52b3 3a				db WORD_SYS_CORE+38             
52b4 36 53			dw .BWRITE            
52b6 06				db 5 + 1 
52b7 .. 00			db "BREAD",0              
52bd				endm 
# End of macro CWHEAD
52bd			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
52bd			; | | > [!NOTE] 
52bd			; | | > Compatible with PicoSPINet  
52bd				 
52bd					if DEBUG_FORTH_WORDS_KEY 
52bd						DMARK "BRD" 
52bd f5				push af  
52be 3a d2 52			ld a, (.dmark)  
52c1 32 a6 fd			ld (debug_mark),a  
52c4 3a d3 52			ld a, (.dmark+1)  
52c7 32 a7 fd			ld (debug_mark+1),a  
52ca 3a d4 52			ld a, (.dmark+2)  
52cd 32 a8 fd			ld (debug_mark+2),a  
52d0 18 03			jr .pastdmark  
52d2 ..			.dmark: db "BRD"  
52d5 f1			.pastdmark: pop af  
52d6			endm  
# End of macro DMARK
52d6						CALLMONITOR 
52d6 cd aa fd			call debug_vector  
52d9				endm  
# End of macro CALLMONITOR
52d9					endif 
52d9			 
52d9				FORTH_DSP_VALUEHL 
52d9 cd 59 24			call macro_dsp_valuehl 
52dc				endm 
# End of macro FORTH_DSP_VALUEHL
52dc			 
52dc				FORTH_DSP_POP 
52dc cd 11 25			call macro_forth_dsp_pop 
52df				endm 
# End of macro FORTH_DSP_POP
52df			 
52df				; calc block address 
52df			 
52df eb				ex de, hl 
52e0 3e 40			ld a, STORE_BLOCK_PHY 
52e2 cd 52 0f			call Mult16 
52e5			 
52e5			 
52e5 11 b5 f9			ld de, store_page 
52e8			 
52e8					if DEBUG_FORTH_WORDS 
52e8						DMARK "BR1" 
52e8 f5				push af  
52e9 3a fd 52			ld a, (.dmark)  
52ec 32 a6 fd			ld (debug_mark),a  
52ef 3a fe 52			ld a, (.dmark+1)  
52f2 32 a7 fd			ld (debug_mark+1),a  
52f5 3a ff 52			ld a, (.dmark+2)  
52f8 32 a8 fd			ld (debug_mark+2),a  
52fb 18 03			jr .pastdmark  
52fd ..			.dmark: db "BR1"  
5300 f1			.pastdmark: pop af  
5301			endm  
# End of macro DMARK
5301						CALLMONITOR 
5301 cd aa fd			call debug_vector  
5304				endm  
# End of macro CALLMONITOR
5304					endif 
5304			 
5304 cd 65 04			call storage_read_block 
5307			 
5307 cd f8 0f			call ishlzero 
530a 20 05			jr nz, .brfound 
530c			 
530c cd 62 22			call forth_push_numhl 
530f 18 22			jr .brdone 
5311			 
5311			 
5311			.brfound: 
5311 21 b7 f9		        ld hl, store_page+2 
5314			 
5314					if DEBUG_FORTH_WORDS 
5314						DMARK "BR2" 
5314 f5				push af  
5315 3a 29 53			ld a, (.dmark)  
5318 32 a6 fd			ld (debug_mark),a  
531b 3a 2a 53			ld a, (.dmark+1)  
531e 32 a7 fd			ld (debug_mark+1),a  
5321 3a 2b 53			ld a, (.dmark+2)  
5324 32 a8 fd			ld (debug_mark+2),a  
5327 18 03			jr .pastdmark  
5329 ..			.dmark: db "BR2"  
532c f1			.pastdmark: pop af  
532d			endm  
# End of macro DMARK
532d						CALLMONITOR 
532d cd aa fd			call debug_vector  
5330				endm  
# End of macro CALLMONITOR
5330					endif 
5330			 
5330 cd d0 22			call forth_push_str 
5333			 
5333			 
5333			.brdone: 
5333			 
5333					NEXTW 
5333 c3 0f 26			jp macro_next 
5336				endm 
# End of macro NEXTW
5336			.BWRITE: 
5336				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5336 3a				db WORD_SYS_CORE+38             
5337 cb 53			dw .BUPD            
5339 07				db 6 + 1 
533a .. 00			db "BWRITE",0              
5341				endm 
# End of macro CWHEAD
5341			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5341			; | | > [!NOTE] 
5341			; | | > Compatible with PicoSPINet  
5341			 
5341					if DEBUG_FORTH_WORDS_KEY 
5341						DMARK "BWR" 
5341 f5				push af  
5342 3a 56 53			ld a, (.dmark)  
5345 32 a6 fd			ld (debug_mark),a  
5348 3a 57 53			ld a, (.dmark+1)  
534b 32 a7 fd			ld (debug_mark+1),a  
534e 3a 58 53			ld a, (.dmark+2)  
5351 32 a8 fd			ld (debug_mark+2),a  
5354 18 03			jr .pastdmark  
5356 ..			.dmark: db "BWR"  
5359 f1			.pastdmark: pop af  
535a			endm  
# End of macro DMARK
535a						CALLMONITOR 
535a cd aa fd			call debug_vector  
535d				endm  
# End of macro CALLMONITOR
535d					endif 
535d			 
535d				FORTH_DSP_VALUEHL 
535d cd 59 24			call macro_dsp_valuehl 
5360				endm 
# End of macro FORTH_DSP_VALUEHL
5360			 
5360				; calc block address 
5360			 
5360 eb				ex de, hl 
5361 3e 40			ld a, STORE_BLOCK_PHY 
5363 cd 52 0f			call Mult16 
5366			 
5366 e5				push hl         ; address 
5367			 
5367				FORTH_DSP_POP 
5367 cd 11 25			call macro_forth_dsp_pop 
536a				endm 
# End of macro FORTH_DSP_POP
536a			 
536a				FORTH_DSP_VALUEHL 
536a cd 59 24			call macro_dsp_valuehl 
536d				endm 
# End of macro FORTH_DSP_VALUEHL
536d			 
536d				FORTH_DSP_POP 
536d cd 11 25			call macro_forth_dsp_pop 
5370				endm 
# End of macro FORTH_DSP_POP
5370			 
5370 cd a1 0c			call storage_clear_page 
5373			 
5373				; copy string to store page 
5373			 
5373 e5				push hl     ; save string address 
5374			 
5374 3e 00			ld a, 0 
5376 cd 97 15			call strlent 
5379			 
5379 23				inc hl 
537a			 
537a 4d				ld c, l 
537b 06 00			ld b, 0 
537d			 
537d e1				pop hl 
537e 11 b7 f9			ld de, store_page + 2 
5381					if DEBUG_FORTH_WORDS 
5381						DMARK "BW1" 
5381 f5				push af  
5382 3a 96 53			ld a, (.dmark)  
5385 32 a6 fd			ld (debug_mark),a  
5388 3a 97 53			ld a, (.dmark+1)  
538b 32 a7 fd			ld (debug_mark+1),a  
538e 3a 98 53			ld a, (.dmark+2)  
5391 32 a8 fd			ld (debug_mark+2),a  
5394 18 03			jr .pastdmark  
5396 ..			.dmark: db "BW1"  
5399 f1			.pastdmark: pop af  
539a			endm  
# End of macro DMARK
539a						CALLMONITOR 
539a cd aa fd			call debug_vector  
539d				endm  
# End of macro CALLMONITOR
539d					endif 
539d ed b0			ldir 
539f			 
539f			 
539f				; poke the start of the block with flags to prevent high level file ops hitting the block 
539f			 
539f 21 ff ff			ld hl, $ffff 
53a2			 
53a2 22 b5 f9			ld (store_page), hl	 
53a5				 
53a5 e1				pop hl    ; get address 
53a6 11 b5 f9			ld de, store_page 
53a9			 
53a9					if DEBUG_FORTH_WORDS 
53a9						DMARK "BW2" 
53a9 f5				push af  
53aa 3a be 53			ld a, (.dmark)  
53ad 32 a6 fd			ld (debug_mark),a  
53b0 3a bf 53			ld a, (.dmark+1)  
53b3 32 a7 fd			ld (debug_mark+1),a  
53b6 3a c0 53			ld a, (.dmark+2)  
53b9 32 a8 fd			ld (debug_mark+2),a  
53bc 18 03			jr .pastdmark  
53be ..			.dmark: db "BW2"  
53c1 f1			.pastdmark: pop af  
53c2			endm  
# End of macro DMARK
53c2						CALLMONITOR 
53c2 cd aa fd			call debug_vector  
53c5				endm  
# End of macro CALLMONITOR
53c5					endif 
53c5			 
53c5 cd ca 04			call storage_write_block 
53c8			 
53c8					NEXTW 
53c8 c3 0f 26			jp macro_next 
53cb				endm 
# End of macro NEXTW
53cb			 
53cb			.BUPD: 
53cb				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
53cb 3a				db WORD_SYS_CORE+38             
53cc 21 54			dw .BYID            
53ce 05				db 4 + 1 
53cf .. 00			db "BUPD",0              
53d4				endm 
# End of macro CWHEAD
53d4			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
53d4			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
53d4			; | | or completely different file system structure. 
53d4			; | | > [!NOTE] 
53d4			; | | > Compatible with PicoSPINet  
53d4			 
53d4					if DEBUG_FORTH_WORDS_KEY 
53d4						DMARK "BUD" 
53d4 f5				push af  
53d5 3a e9 53			ld a, (.dmark)  
53d8 32 a6 fd			ld (debug_mark),a  
53db 3a ea 53			ld a, (.dmark+1)  
53de 32 a7 fd			ld (debug_mark+1),a  
53e1 3a eb 53			ld a, (.dmark+2)  
53e4 32 a8 fd			ld (debug_mark+2),a  
53e7 18 03			jr .pastdmark  
53e9 ..			.dmark: db "BUD"  
53ec f1			.pastdmark: pop af  
53ed			endm  
# End of macro DMARK
53ed						CALLMONITOR 
53ed cd aa fd			call debug_vector  
53f0				endm  
# End of macro CALLMONITOR
53f0					endif 
53f0			 
53f0				FORTH_DSP_VALUEHL 
53f0 cd 59 24			call macro_dsp_valuehl 
53f3				endm 
# End of macro FORTH_DSP_VALUEHL
53f3			 
53f3				; calc block address 
53f3			 
53f3 eb				ex de, hl 
53f4 3e 40			ld a, STORE_BLOCK_PHY 
53f6 cd 52 0f			call Mult16 
53f9			 
53f9				FORTH_DSP_POP 
53f9 cd 11 25			call macro_forth_dsp_pop 
53fc				endm 
# End of macro FORTH_DSP_POP
53fc			 
53fc			 
53fc 11 b5 f9			ld de, store_page 
53ff			 
53ff					if DEBUG_FORTH_WORDS 
53ff						DMARK "BUe" 
53ff f5				push af  
5400 3a 14 54			ld a, (.dmark)  
5403 32 a6 fd			ld (debug_mark),a  
5406 3a 15 54			ld a, (.dmark+1)  
5409 32 a7 fd			ld (debug_mark+1),a  
540c 3a 16 54			ld a, (.dmark+2)  
540f 32 a8 fd			ld (debug_mark+2),a  
5412 18 03			jr .pastdmark  
5414 ..			.dmark: db "BUe"  
5417 f1			.pastdmark: pop af  
5418			endm  
# End of macro DMARK
5418						CALLMONITOR 
5418 cd aa fd			call debug_vector  
541b				endm  
# End of macro CALLMONITOR
541b					endif 
541b			 
541b cd ca 04			call storage_write_block 
541e			 
541e					NEXTW 
541e c3 0f 26			jp macro_next 
5421				endm 
# End of macro NEXTW
5421			 
5421			.BYID: 
5421			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5421			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5421			; 
5421			;		 
5421			;		if DEBUG_FORTH_WORDS_KEY 
5421			;			DMARK "BYID" 
5421			;			CALLMONITOR 
5421			;		endif 
5421			; 
5421			;		; get direct address 
5421			; 
5421			;		FORTH_DSP_VALUEHL 
5421			; 
5421			;		FORTH_DSP_POP 
5421			; 
5421			;	; calc block address 
5421			; 
5421			;	ex de, hl 
5421			;	ld a, STORE_BLOCK_PHY 
5421			;	call Mult16 
5421			;	;	do BREAD with number as param 
5421			;	; push the file name	 
5421			;	ld de, store_page 
5421			;	call storage_read_block 
5421			 ;       ld hl, store_page+2 
5421			; 
5421			; 
5421			;		NEXTW 
5421			;.BYNAME: 
5421				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5421 3a				db WORD_SYS_CORE+38             
5422 3a 54			dw .DIR            
5424 06				db 5 + 1 
5425 .. 00			db "GETID",0              
542b				endm 
# End of macro CWHEAD
542b			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
542b			; | | > [!NOTE] 
542b			; | | > Compatible with PicoSPINet  
542b			 
542b					; get pointer to file name to seek 
542b			 
542b					FORTH_DSP_VALUEHL 
542b cd 59 24			call macro_dsp_valuehl 
542e				endm 
# End of macro FORTH_DSP_VALUEHL
542e			 
542e			 
542e cd 8c 03				call storage_getid  
5431			 
5431					FORTH_DSP_POP 
5431 cd 11 25			call macro_forth_dsp_pop 
5434				endm 
# End of macro FORTH_DSP_POP
5434			 
5434 cd 62 22				call forth_push_numhl 
5437			 
5437					NEXTW 
5437 c3 0f 26			jp macro_next 
543a				endm 
# End of macro NEXTW
543a			; 
543a			.DIR: 
543a				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
543a 3a				db WORD_SYS_CORE+38             
543b 3e 55			dw .SAVE            
543d 04				db 3 + 1 
543e .. 00			db "DIR",0              
5442				endm 
# End of macro CWHEAD
5442			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5442			; | | > [!NOTE] 
5442			; | | > Compatible with PicoSPINet  
5442			 
5442					if DEBUG_FORTH_WORDS_KEY 
5442						DMARK "DIR" 
5442 f5				push af  
5443 3a 57 54			ld a, (.dmark)  
5446 32 a6 fd			ld (debug_mark),a  
5449 3a 58 54			ld a, (.dmark+1)  
544c 32 a7 fd			ld (debug_mark+1),a  
544f 3a 59 54			ld a, (.dmark+2)  
5452 32 a8 fd			ld (debug_mark+2),a  
5455 18 03			jr .pastdmark  
5457 ..			.dmark: db "DIR"  
545a f1			.pastdmark: pop af  
545b			endm  
# End of macro DMARK
545b						CALLMONITOR 
545b cd aa fd			call debug_vector  
545e				endm  
# End of macro CALLMONITOR
545e					endif 
545e cd 16 05			call storage_get_block_0 
5461			 
5461 21 b5 f9			ld hl, store_page     ; get current id count 
5464 46				ld b, (hl) 
5465 0e 00			ld c, 0    ; count of files   
5467					if DEBUG_FORTH_WORDS 
5467						DMARK "DI1" 
5467 f5				push af  
5468 3a 7c 54			ld a, (.dmark)  
546b 32 a6 fd			ld (debug_mark),a  
546e 3a 7d 54			ld a, (.dmark+1)  
5471 32 a7 fd			ld (debug_mark+1),a  
5474 3a 7e 54			ld a, (.dmark+2)  
5477 32 a8 fd			ld (debug_mark+2),a  
547a 18 03			jr .pastdmark  
547c ..			.dmark: db "DI1"  
547f f1			.pastdmark: pop af  
5480			endm  
# End of macro DMARK
5480						CALLMONITOR 
5480 cd aa fd			call debug_vector  
5483				endm  
# End of macro CALLMONITOR
5483					endif 
5483			 
5483				; check for empty drive 
5483			 
5483 3e 00			ld a, 0 
5485 b8				cp b 
5486 ca f4 54			jp z, .dirdone 
5489			 
5489				; for each of the current ids do a search for them and if found push to stack 
5489			 
5489 c5			.diritem:	push bc 
548a 21 40 00				ld hl, STORE_BLOCK_PHY 
548d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
548f 58					ld e,b 
5490			 
5490			;		if DEBUG_FORTH_WORDS 
5490			;			DMARK "DI2" 
5490			;			CALLMONITOR 
5490			;		endif 
5490			 
5490 cd 98 07				call storage_findnextid 
5493			 
5493			;		if DEBUG_FORTH_WORDS 
5493			;			DMARK "DI3" 
5493			;			CALLMONITOR 
5493			;		endif 
5493			 
5493					; if found hl will be non zero 
5493			 
5493 cd f8 0f				call ishlzero 
5496			;		ld a, l 
5496			;		add h 
5496			; 
5496			;		cp 0 
5496 28 59				jr z, .dirnotfound 
5498			 
5498					; increase count 
5498			 
5498 c1					pop bc	 
5499 0c					inc c 
549a c5					push bc 
549b					 
549b			 
549b					; get file header and push the file name 
549b			 
549b 11 b5 f9				ld de, store_page 
549e cd 65 04				call storage_read_block 
54a1			 
54a1					; push file id to stack 
54a1				 
54a1 3a b5 f9				ld a, (store_page) 
54a4 26 00				ld h, 0 
54a6 6f					ld l, a 
54a7 cd 62 22				call forth_push_numhl 
54aa			 
54aa					; push extent count to stack  
54aa				 
54aa 3a b7 f9				ld a, (store_page+2) 
54ad 26 00				ld h, 0 
54af 6f					ld l, a 
54b0 cd 62 22				call forth_push_numhl 
54b3			 
54b3					; push file name 
54b3			 
54b3 21 b8 f9				ld hl, store_page+3 
54b6					if DEBUG_FORTH_WORDS 
54b6						DMARK "DI5" 
54b6 f5				push af  
54b7 3a cb 54			ld a, (.dmark)  
54ba 32 a6 fd			ld (debug_mark),a  
54bd 3a cc 54			ld a, (.dmark+1)  
54c0 32 a7 fd			ld (debug_mark+1),a  
54c3 3a cd 54			ld a, (.dmark+2)  
54c6 32 a8 fd			ld (debug_mark+2),a  
54c9 18 03			jr .pastdmark  
54cb ..			.dmark: db "DI5"  
54ce f1			.pastdmark: pop af  
54cf			endm  
# End of macro DMARK
54cf						CALLMONITOR 
54cf cd aa fd			call debug_vector  
54d2				endm  
# End of macro CALLMONITOR
54d2					endif 
54d2 cd d0 22				call forth_push_str 
54d5					if DEBUG_FORTH_WORDS 
54d5						DMARK "DI6" 
54d5 f5				push af  
54d6 3a ea 54			ld a, (.dmark)  
54d9 32 a6 fd			ld (debug_mark),a  
54dc 3a eb 54			ld a, (.dmark+1)  
54df 32 a7 fd			ld (debug_mark+1),a  
54e2 3a ec 54			ld a, (.dmark+2)  
54e5 32 a8 fd			ld (debug_mark+2),a  
54e8 18 03			jr .pastdmark  
54ea ..			.dmark: db "DI6"  
54ed f1			.pastdmark: pop af  
54ee			endm  
# End of macro DMARK
54ee						CALLMONITOR 
54ee cd aa fd			call debug_vector  
54f1				endm  
# End of macro CALLMONITOR
54f1					endif 
54f1			.dirnotfound: 
54f1 c1					pop bc     
54f2 10 95				djnz .diritem 
54f4				 
54f4			.dirdone:	 
54f4					if DEBUG_FORTH_WORDS 
54f4						DMARK "DI7" 
54f4 f5				push af  
54f5 3a 09 55			ld a, (.dmark)  
54f8 32 a6 fd			ld (debug_mark),a  
54fb 3a 0a 55			ld a, (.dmark+1)  
54fe 32 a7 fd			ld (debug_mark+1),a  
5501 3a 0b 55			ld a, (.dmark+2)  
5504 32 a8 fd			ld (debug_mark+2),a  
5507 18 03			jr .pastdmark  
5509 ..			.dmark: db "DI7"  
550c f1			.pastdmark: pop af  
550d			endm  
# End of macro DMARK
550d						CALLMONITOR 
550d cd aa fd			call debug_vector  
5510				endm  
# End of macro CALLMONITOR
5510					endif 
5510			 
5510					; push a count of the dir items found 
5510			 
5510 26 00				ld h, 0 
5512 69					ld l, c 
5513 cd 62 22				call forth_push_numhl 
5516			 
5516					; push the bank label 
5516			 
5516 cd 16 05				call storage_get_block_0 
5519			 
5519				 
5519 21 b8 f9		 		ld hl, store_page+3 
551c			 
551c					if DEBUG_FORTH_WORDS 
551c						DMARK "DI8" 
551c f5				push af  
551d 3a 31 55			ld a, (.dmark)  
5520 32 a6 fd			ld (debug_mark),a  
5523 3a 32 55			ld a, (.dmark+1)  
5526 32 a7 fd			ld (debug_mark+1),a  
5529 3a 33 55			ld a, (.dmark+2)  
552c 32 a8 fd			ld (debug_mark+2),a  
552f 18 03			jr .pastdmark  
5531 ..			.dmark: db "DI8"  
5534 f1			.pastdmark: pop af  
5535			endm  
# End of macro DMARK
5535						CALLMONITOR 
5535 cd aa fd			call debug_vector  
5538				endm  
# End of macro CALLMONITOR
5538					endif 
5538 cd d0 22				call forth_push_str 
553b			 
553b			 
553b				 
553b					NEXTW 
553b c3 0f 26			jp macro_next 
553e				endm 
# End of macro NEXTW
553e			.SAVE: 
553e			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
553e			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
553e			;		NEXTW 
553e			;.LOAD: 
553e			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
553e			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
553e			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
553e			;; > > The LOAD command can not be used in any user words or compound lines. 
553e			; 
553e			;		; store_openext use it. If zero it is EOF 
553e			; 
553e			;		; read block from current stream id 
553e			;		; if the block does not contain zero term keep reading blocks until zero found 
553e			;		; push the block to stack 
553e			;		; save the block id to stream 
553e			; 
553e			; 
553e			;		FORTH_DSP_VALUEHL 
553e			; 
553e			;;		push hl 
553e			; 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LOA" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;		FORTH_DSP_POP 
553e			; 
553e			;;		pop hl 
553e			; 
553e			;		ld h, l 
553e			;		ld l, 0 
553e			; 
553e			;		push hl     ; stack holds current file id and extent to work with 
553e			; 
553e			; 
553e			;		ld de, store_page      ; get block zero of file 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LO0" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;		call storage_read 
553e			; 
553e			;		ld a, (store_page+2)    ; max extents for this file 
553e			;		ld  (store_openmaxext),a   ; get our limit 
553e			; 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LOE" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			; 
553e			;; TODO dont know why max extents are not present 
553e			;;		cp 0 
553e			;;		jp z, .loadeof     ; dont read past eof 
553e			; 
553e			;;		ld a, 1   ; start from the head of the file 
553e			; 
553e			;.loadline:	pop hl 
553e			;		inc hl 
553e			;		ld  a, (store_openmaxext)   ; get our limit 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LOx" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;		inc a 
553e			;		cp l 
553e			;		jp z, .loadeof 
553e			;		push hl    ; save current extent 
553e			; 
553e			;		ld de, store_page 
553e			; 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LO1" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;		call storage_read 
553e			; 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LO2" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;	call ishlzero 
553e			;	ld a, l 
553e			;	add h 
553e			;	cp 0 
553e			;	jr z, .loadeof 
553e			; 
553e			;	; not eof so hl should point to data to exec 
553e			; 
553e			;	; will need to add the FORTH_END_BUFFER flag 
553e			 ; 
553e			;	ld hl, store_page+2 
553e			;	ld bc, 255 
553e			;	ld a, 0 
553e			;	cpir 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LOt" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;	dec hl 
553e			;	ld a, ' ' 
553e			;	ld (hl), a 
553e			;	inc hl 
553e			;	ld (hl), a 
553e			;	inc hl 
553e			;	ld (hl), a 
553e			;	inc hl 
553e			;	ld a, FORTH_END_BUFFER 
553e			;	ld (hl), a 
553e			; 
553e			;	; TODO handle more than a single block read 
553e			; 
553e			; 
553e			;	ld hl, store_page+2 
553e			; 
553e			;	ld (os_tok_ptr), hl 
553e			; 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LO3" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			; 
553e			;	call forthparse 
553e			;	call forthexec 
553e			;	call forthexec_cleanup 
553e			; 
553e			;	; go to next extent 
553e			; 
553e			;	; get next block  or mark as eof 
553e			;	jp .loadline 
553e			; 
553e			; 
553e			; 
553e			;	       NEXTW 
553e			;.loadeof:	ld a, 0 
553e			;		ld (store_openext), a 
553e			; 
553e			;	if DEBUG_STORESE 
553e			;		DMARK "LOF" 
553e			;		CALLMONITOR 
553e			;	endif 
553e			;		ret 
553e			;		;NEXTW 
553e			;.BSAVE:   
553e			; 
553e			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
553e			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
553e			;		NEXTW 
553e			;.BLOAD: 
553e			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
553e			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
553e			;		NEXTW 
553e			;;;; counter gap 
553e			 
553e			 
553e			.SEO: 
553e				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
553e 64				db WORD_SYS_CORE+80             
553f 5d 55			dw .SEI            
5541 04				db 3 + 1 
5542 .. 00			db "SEO",0              
5546				endm 
# End of macro CWHEAD
5546			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5546			 
5546					; get port 
5546			 
5546					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5546 cd 59 24			call macro_dsp_valuehl 
5549				endm 
# End of macro FORTH_DSP_VALUEHL
5549			 
5549 e5					push hl    ; u2 - byte 
554a			 
554a					; destroy value TOS 
554a			 
554a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
554a cd 11 25			call macro_forth_dsp_pop 
554d				endm 
# End of macro FORTH_DSP_POP
554d			 
554d					; get byte to send 
554d			 
554d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
554d cd 59 24			call macro_dsp_valuehl 
5550				endm 
# End of macro FORTH_DSP_VALUEHL
5550			 
5550 e5					push hl    ; u1 - addr 
5551			 
5551					; destroy value TOS 
5551			 
5551					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5551 cd 11 25			call macro_forth_dsp_pop 
5554				endm 
# End of macro FORTH_DSP_POP
5554			 
5554					; one value on hl get other one back 
5554			 
5554 d1					pop de   ; u1 - byte 
5555			 
5555 e1					pop hl   ; u2 - addr 
5556			 
5556					; TODO Send SPI byte 
5556			 
5556			 
5556 7b					ld a, e 
5557 cd 6a 02				call se_writebyte 
555a			 
555a					 
555a			 
555a					NEXTW 
555a c3 0f 26			jp macro_next 
555d				endm 
# End of macro NEXTW
555d			 
555d			.SEI: 
555d				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
555d 65				db WORD_SYS_CORE+81             
555e 77 55			dw .SFREE            
5560 04				db 3 + 1 
5561 .. 00			db "SEI",0              
5565				endm 
# End of macro CWHEAD
5565			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5565			 
5565					; get port 
5565			 
5565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5565 cd 59 24			call macro_dsp_valuehl 
5568				endm 
# End of macro FORTH_DSP_VALUEHL
5568			 
5568			;		push hl 
5568			 
5568					; destroy value TOS 
5568			 
5568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5568 cd 11 25			call macro_forth_dsp_pop 
556b				endm 
# End of macro FORTH_DSP_POP
556b			 
556b					; one value on hl get other one back 
556b			 
556b			;		pop hl 
556b			 
556b			 
556b					; TODO Get SPI byte 
556b			 
556b cd 0c 03				call se_readbyte 
556e			 
556e 26 00				ld h, 0 
5570 6f					ld l, a 
5571 cd 62 22				call forth_push_numhl 
5574			 
5574					NEXTW 
5574 c3 0f 26			jp macro_next 
5577				endm 
# End of macro NEXTW
5577			 
5577			.SFREE: 
5577				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5577 67				db WORD_SYS_CORE+83             
5578 a6 55			dw .SIZE            
557a 06				db 5 + 1 
557b .. 00			db "FFREE",0              
5581				endm 
# End of macro CWHEAD
5581			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5581			; | | > [!NOTE] 
5581			; | | > Compatible with PicoSPINet  
5581					if DEBUG_FORTH_WORDS_KEY 
5581						DMARK "FFR" 
5581 f5				push af  
5582 3a 96 55			ld a, (.dmark)  
5585 32 a6 fd			ld (debug_mark),a  
5588 3a 97 55			ld a, (.dmark+1)  
558b 32 a7 fd			ld (debug_mark+1),a  
558e 3a 98 55			ld a, (.dmark+2)  
5591 32 a8 fd			ld (debug_mark+2),a  
5594 18 03			jr .pastdmark  
5596 ..			.dmark: db "FFR"  
5599 f1			.pastdmark: pop af  
559a			endm  
# End of macro DMARK
559a						CALLMONITOR 
559a cd aa fd			call debug_vector  
559d				endm  
# End of macro CALLMONITOR
559d					endif 
559d			 
559d cd 32 08				call storage_freeblocks 
55a0			 
55a0 cd 62 22				call forth_push_numhl 
55a3			 
55a3				       NEXTW 
55a3 c3 0f 26			jp macro_next 
55a6				endm 
# End of macro NEXTW
55a6			.SIZE: 
55a6				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
55a6 67				db WORD_SYS_CORE+83             
55a7 da 55			dw .CREATE            
55a9 05				db 4 + 1 
55aa .. 00			db "SIZE",0              
55af				endm 
# End of macro CWHEAD
55af			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
55af			; | | > [!NOTE] 
55af			; | | > Compatible with PicoSPINet  
55af					if DEBUG_FORTH_WORDS_KEY 
55af						DMARK "SIZ" 
55af f5				push af  
55b0 3a c4 55			ld a, (.dmark)  
55b3 32 a6 fd			ld (debug_mark),a  
55b6 3a c5 55			ld a, (.dmark+1)  
55b9 32 a7 fd			ld (debug_mark+1),a  
55bc 3a c6 55			ld a, (.dmark+2)  
55bf 32 a8 fd			ld (debug_mark+2),a  
55c2 18 03			jr .pastdmark  
55c4 ..			.dmark: db "SIZ"  
55c7 f1			.pastdmark: pop af  
55c8			endm  
# End of macro DMARK
55c8						CALLMONITOR 
55c8 cd aa fd			call debug_vector  
55cb				endm  
# End of macro CALLMONITOR
55cb					endif 
55cb			 
55cb					FORTH_DSP_VALUEHL 
55cb cd 59 24			call macro_dsp_valuehl 
55ce				endm 
# End of macro FORTH_DSP_VALUEHL
55ce			;		push hl 
55ce					FORTH_DSP_POP 
55ce cd 11 25			call macro_forth_dsp_pop 
55d1				endm 
# End of macro FORTH_DSP_POP
55d1			;		pop hl 
55d1 cd 94 04				call storage_file_size 
55d4			 
55d4 cd 62 22				call forth_push_numhl 
55d7			  
55d7			 
55d7				       NEXTW 
55d7 c3 0f 26			jp macro_next 
55da				endm 
# End of macro NEXTW
55da			 
55da			.CREATE: 
55da				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
55da 68				db WORD_SYS_CORE+84             
55db 48 56			dw .APPEND            
55dd 07				db 6 + 1 
55de .. 00			db "CREATE",0              
55e5				endm 
# End of macro CWHEAD
55e5			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
55e5			; | | e.g.  
55e5			; | | TestProgram CREATE 
55e5			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
55e5			; | |  
55e5			; | | Max file IDs are 255. 
55e5			; | |  
55e5			; | | > [!NOTE] 
55e5			; | | > Compatible with PicoSPINet  
55e5					 
55e5					if DEBUG_FORTH_WORDS_KEY 
55e5						DMARK "CRT" 
55e5 f5				push af  
55e6 3a fa 55			ld a, (.dmark)  
55e9 32 a6 fd			ld (debug_mark),a  
55ec 3a fb 55			ld a, (.dmark+1)  
55ef 32 a7 fd			ld (debug_mark+1),a  
55f2 3a fc 55			ld a, (.dmark+2)  
55f5 32 a8 fd			ld (debug_mark+2),a  
55f8 18 03			jr .pastdmark  
55fa ..			.dmark: db "CRT"  
55fd f1			.pastdmark: pop af  
55fe			endm  
# End of macro DMARK
55fe						CALLMONITOR 
55fe cd aa fd			call debug_vector  
5601				endm  
# End of macro CALLMONITOR
5601					endif 
5601			;		call storage_get_block_0 
5601			 
5601					; TODO pop hl 
5601			 
5601					;v5 FORTH_DSP_VALUE 
5601					FORTH_DSP_VALUE 
5601 cd 42 24			call macro_forth_dsp_value 
5604				endm 
# End of macro FORTH_DSP_VALUE
5604			 
5604				if DEBUG_STORESE 
5604					DMARK "CR1" 
5604 f5				push af  
5605 3a 19 56			ld a, (.dmark)  
5608 32 a6 fd			ld (debug_mark),a  
560b 3a 1a 56			ld a, (.dmark+1)  
560e 32 a7 fd			ld (debug_mark+1),a  
5611 3a 1b 56			ld a, (.dmark+2)  
5614 32 a8 fd			ld (debug_mark+2),a  
5617 18 03			jr .pastdmark  
5619 ..			.dmark: db "CR1"  
561c f1			.pastdmark: pop af  
561d			endm  
# End of macro DMARK
561d					CALLMONITOR 
561d cd aa fd			call debug_vector  
5620				endm  
# End of macro CALLMONITOR
5620				endif 
5620			;		push hl 
5620			;		FORTH_DSP_POP 
5620			;		pop hl 
5620			 
5620			;		inc hl   ; move past the type marker 
5620			 
5620 cd 68 08				call storage_create 
5623			 
5623				if DEBUG_STORESE 
5623					DMARK "CT1" 
5623 f5				push af  
5624 3a 38 56			ld a, (.dmark)  
5627 32 a6 fd			ld (debug_mark),a  
562a 3a 39 56			ld a, (.dmark+1)  
562d 32 a7 fd			ld (debug_mark+1),a  
5630 3a 3a 56			ld a, (.dmark+2)  
5633 32 a8 fd			ld (debug_mark+2),a  
5636 18 03			jr .pastdmark  
5638 ..			.dmark: db "CT1"  
563b f1			.pastdmark: pop af  
563c			endm  
# End of macro DMARK
563c					CALLMONITOR 
563c cd aa fd			call debug_vector  
563f				endm  
# End of macro CALLMONITOR
563f				endif 
563f			;		push hl 
563f					FORTH_DSP_POP 
563f cd 11 25			call macro_forth_dsp_pop 
5642				endm 
# End of macro FORTH_DSP_POP
5642			;		pop hl 
5642					; push file id to stack 
5642 cd 62 22				call forth_push_numhl 
5645			 
5645			 
5645			 
5645				       NEXTW 
5645 c3 0f 26			jp macro_next 
5648				endm 
# End of macro NEXTW
5648			 
5648			.APPEND: 
5648				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5648 69				db WORD_SYS_CORE+85             
5649 d9 56			dw .SDEL            
564b 07				db 6 + 1 
564c .. 00			db "APPEND",0              
5653				endm 
# End of macro CWHEAD
5653			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5653			; | | e.g. 
5653			; | | Test CREATE      -> $01 
5653			; | | "A string to add to file" $01 APPEND 
5653			; | |  
5653			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5653			; | | > [!NOTE] 
5653			; | | > Compatible with PicoSPINet  
5653					if DEBUG_FORTH_WORDS_KEY 
5653						DMARK "APP" 
5653 f5				push af  
5654 3a 68 56			ld a, (.dmark)  
5657 32 a6 fd			ld (debug_mark),a  
565a 3a 69 56			ld a, (.dmark+1)  
565d 32 a7 fd			ld (debug_mark+1),a  
5660 3a 6a 56			ld a, (.dmark+2)  
5663 32 a8 fd			ld (debug_mark+2),a  
5666 18 03			jr .pastdmark  
5668 ..			.dmark: db "APP"  
566b f1			.pastdmark: pop af  
566c			endm  
# End of macro DMARK
566c						CALLMONITOR 
566c cd aa fd			call debug_vector  
566f				endm  
# End of macro CALLMONITOR
566f					endif 
566f			 
566f					FORTH_DSP_VALUEHL 
566f cd 59 24			call macro_dsp_valuehl 
5672				endm 
# End of macro FORTH_DSP_VALUEHL
5672 e5					push hl 	; save file id 
5673			 
5673				if DEBUG_STORESE 
5673					DMARK "AP1" 
5673 f5				push af  
5674 3a 88 56			ld a, (.dmark)  
5677 32 a6 fd			ld (debug_mark),a  
567a 3a 89 56			ld a, (.dmark+1)  
567d 32 a7 fd			ld (debug_mark+1),a  
5680 3a 8a 56			ld a, (.dmark+2)  
5683 32 a8 fd			ld (debug_mark+2),a  
5686 18 03			jr .pastdmark  
5688 ..			.dmark: db "AP1"  
568b f1			.pastdmark: pop af  
568c			endm  
# End of macro DMARK
568c					CALLMONITOR 
568c cd aa fd			call debug_vector  
568f				endm  
# End of macro CALLMONITOR
568f				endif 
568f					FORTH_DSP_POP 
568f cd 11 25			call macro_forth_dsp_pop 
5692				endm 
# End of macro FORTH_DSP_POP
5692			 
5692					FORTH_DSP_VALUEHL 
5692 cd 59 24			call macro_dsp_valuehl 
5695				endm 
# End of macro FORTH_DSP_VALUEHL
5695					;v5 FORTH_DSP_VALUE 
5695 e5					push hl 	; save ptr to string to save 
5696			 
5696				if DEBUG_STORESE 
5696					DMARK "AP1" 
5696 f5				push af  
5697 3a ab 56			ld a, (.dmark)  
569a 32 a6 fd			ld (debug_mark),a  
569d 3a ac 56			ld a, (.dmark+1)  
56a0 32 a7 fd			ld (debug_mark+1),a  
56a3 3a ad 56			ld a, (.dmark+2)  
56a6 32 a8 fd			ld (debug_mark+2),a  
56a9 18 03			jr .pastdmark  
56ab ..			.dmark: db "AP1"  
56ae f1			.pastdmark: pop af  
56af			endm  
# End of macro DMARK
56af					CALLMONITOR 
56af cd aa fd			call debug_vector  
56b2				endm  
# End of macro CALLMONITOR
56b2				endif 
56b2					FORTH_DSP_POP 
56b2 cd 11 25			call macro_forth_dsp_pop 
56b5				endm 
# End of macro FORTH_DSP_POP
56b5			 
56b5 d1					pop de 
56b6 e1					pop hl 
56b7				if DEBUG_STORESE 
56b7					DMARK "AP2" 
56b7 f5				push af  
56b8 3a cc 56			ld a, (.dmark)  
56bb 32 a6 fd			ld (debug_mark),a  
56be 3a cd 56			ld a, (.dmark+1)  
56c1 32 a7 fd			ld (debug_mark+1),a  
56c4 3a ce 56			ld a, (.dmark+2)  
56c7 32 a8 fd			ld (debug_mark+2),a  
56ca 18 03			jr .pastdmark  
56cc ..			.dmark: db "AP2"  
56cf f1			.pastdmark: pop af  
56d0			endm  
# End of macro DMARK
56d0					CALLMONITOR 
56d0 cd aa fd			call debug_vector  
56d3				endm  
# End of macro CALLMONITOR
56d3				endif 
56d3					;inc de ; skip var type indicator 
56d3			 
56d3					; TODO how to append numerics???? 
56d3			 
56d3 cd 55 0b				call storage_append		 
56d6			 
56d6				       NEXTW 
56d6 c3 0f 26			jp macro_next 
56d9				endm 
# End of macro NEXTW
56d9			.SDEL: 
56d9				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
56d9 6a				db WORD_SYS_CORE+86             
56da 25 57			dw .OPEN            
56dc 05				db 4 + 1 
56dd .. 00			db "ERA",0              
56e1				endm 
# End of macro CWHEAD
56e1			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
56e1			; | | > [!NOTE] 
56e1			; | | > Compatible with PicoSPINet  
56e1					FORTH_DSP_VALUEHL 
56e1 cd 59 24			call macro_dsp_valuehl 
56e4				endm 
# End of macro FORTH_DSP_VALUEHL
56e4			;		push hl 	; save file id 
56e4			 
56e4					if DEBUG_FORTH_WORDS_KEY 
56e4						DMARK "ERA" 
56e4 f5				push af  
56e5 3a f9 56			ld a, (.dmark)  
56e8 32 a6 fd			ld (debug_mark),a  
56eb 3a fa 56			ld a, (.dmark+1)  
56ee 32 a7 fd			ld (debug_mark+1),a  
56f1 3a fb 56			ld a, (.dmark+2)  
56f4 32 a8 fd			ld (debug_mark+2),a  
56f7 18 03			jr .pastdmark  
56f9 ..			.dmark: db "ERA"  
56fc f1			.pastdmark: pop af  
56fd			endm  
# End of macro DMARK
56fd						CALLMONITOR 
56fd cd aa fd			call debug_vector  
5700				endm  
# End of macro CALLMONITOR
5700					endif 
5700				if DEBUG_STORESE 
5700					DMARK "ER1" 
5700 f5				push af  
5701 3a 15 57			ld a, (.dmark)  
5704 32 a6 fd			ld (debug_mark),a  
5707 3a 16 57			ld a, (.dmark+1)  
570a 32 a7 fd			ld (debug_mark+1),a  
570d 3a 17 57			ld a, (.dmark+2)  
5710 32 a8 fd			ld (debug_mark+2),a  
5713 18 03			jr .pastdmark  
5715 ..			.dmark: db "ER1"  
5718 f1			.pastdmark: pop af  
5719			endm  
# End of macro DMARK
5719					CALLMONITOR 
5719 cd aa fd			call debug_vector  
571c				endm  
# End of macro CALLMONITOR
571c				endif 
571c					FORTH_DSP_POP 
571c cd 11 25			call macro_forth_dsp_pop 
571f				endm 
# End of macro FORTH_DSP_POP
571f			 
571f			;		pop hl 
571f			 
571f cd a7 06				call storage_erase 
5722				       NEXTW 
5722 c3 0f 26			jp macro_next 
5725				endm 
# End of macro NEXTW
5725			 
5725			.OPEN: 
5725				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5725 6b				db WORD_SYS_CORE+87             
5726 b9 57			dw .READ            
5728 05				db 4 + 1 
5729 .. 00			db "OPEN",0              
572e				endm 
# End of macro CWHEAD
572e			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
572e			; | | e.g. 
572e			; | | $01 OPEN $01 DO $01 READ . LOOP 
572e			; | | 
572e			; | | Will return with 255 blocks if the file does not exist 
572e			; | | > [!NOTE] 
572e			; | | > Compatible with PicoSPINet  
572e			 
572e					if DEBUG_FORTH_WORDS_KEY 
572e						DMARK "OPN" 
572e f5				push af  
572f 3a 43 57			ld a, (.dmark)  
5732 32 a6 fd			ld (debug_mark),a  
5735 3a 44 57			ld a, (.dmark+1)  
5738 32 a7 fd			ld (debug_mark+1),a  
573b 3a 45 57			ld a, (.dmark+2)  
573e 32 a8 fd			ld (debug_mark+2),a  
5741 18 03			jr .pastdmark  
5743 ..			.dmark: db "OPN"  
5746 f1			.pastdmark: pop af  
5747			endm  
# End of macro DMARK
5747						CALLMONITOR 
5747 cd aa fd			call debug_vector  
574a				endm  
# End of macro CALLMONITOR
574a					endif 
574a					; TODO handle multiple file opens 
574a			 
574a 3e 01			       	ld a, 1 
574c 32 a5 f9				ld (store_openext), a 
574f			 
574f					; get max extents for this file 
574f				 
574f								 
574f					FORTH_DSP_VALUEHL 
574f cd 59 24			call macro_dsp_valuehl 
5752				endm 
# End of macro FORTH_DSP_VALUEHL
5752			 
5752 65					ld h, l 
5753 2e 00				ld l, 0 
5755			 
5755					; store file id 
5755			 
5755 7c					ld a, h 
5756 32 a2 f9				ld (store_filecache), a 
5759			 
5759				if DEBUG_STORESE 
5759					DMARK "OPN" 
5759 f5				push af  
575a 3a 6e 57			ld a, (.dmark)  
575d 32 a6 fd			ld (debug_mark),a  
5760 3a 6f 57			ld a, (.dmark+1)  
5763 32 a7 fd			ld (debug_mark+1),a  
5766 3a 70 57			ld a, (.dmark+2)  
5769 32 a8 fd			ld (debug_mark+2),a  
576c 18 03			jr .pastdmark  
576e ..			.dmark: db "OPN"  
5771 f1			.pastdmark: pop af  
5772			endm  
# End of macro DMARK
5772					CALLMONITOR 
5772 cd aa fd			call debug_vector  
5775				endm  
# End of macro CALLMONITOR
5775				endif 
5775			;		push hl 
5775					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5775 cd 11 25			call macro_forth_dsp_pop 
5778				endm 
# End of macro FORTH_DSP_POP
5778			;		pop hl 
5778						 
5778 11 b5 f9				ld de, store_page      ; get block zero of file 
577b cd be 09				call storage_read 
577e cd f8 0f			call ishlzero 
5781 20 04			jr nz, .opfound 
5783			 
5783				; file does not exist so indicate with 255 extents in use 
5783			 
5783 3e ff			ld a, 255 
5785 18 29			jr .skipopeneof 
5787			 
5787			 
5787			.opfound: 
5787			 
5787			 
5787 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
578a 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
578d					 
578d				if DEBUG_STORESE 
578d					DMARK "OPx" 
578d f5				push af  
578e 3a a2 57			ld a, (.dmark)  
5791 32 a6 fd			ld (debug_mark),a  
5794 3a a3 57			ld a, (.dmark+1)  
5797 32 a7 fd			ld (debug_mark+1),a  
579a 3a a4 57			ld a, (.dmark+2)  
579d 32 a8 fd			ld (debug_mark+2),a  
57a0 18 03			jr .pastdmark  
57a2 ..			.dmark: db "OPx"  
57a5 f1			.pastdmark: pop af  
57a6			endm  
# End of macro DMARK
57a6					CALLMONITOR 
57a6 cd aa fd			call debug_vector  
57a9				endm  
# End of macro CALLMONITOR
57a9				endif 
57a9 fe 00				cp 0 
57ab 20 03				jr nz, .skipopeneof 
57ad					; have opened an empty file 
57ad					 
57ad 32 a5 f9				ld (store_openext), a 
57b0			 
57b0			.skipopeneof: 
57b0			 
57b0 6f					ld l, a 
57b1 26 00				ld h, 0 
57b3 cd 62 22				call forth_push_numhl 
57b6			 
57b6			 
57b6				       NEXTW 
57b6 c3 0f 26			jp macro_next 
57b9				endm 
# End of macro NEXTW
57b9			.READ: 
57b9				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
57b9 6c				db WORD_SYS_CORE+88             
57ba e3 58			dw .EOF            
57bc 05				db 4 + 1 
57bd .. 00			db "READ",0              
57c2				endm 
# End of macro CWHEAD
57c2			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
57c2			; | | e.g. 
57c2			; | | $01 OPEN $01 DO READ . LOOP 
57c2			; | | 
57c2			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
57c2			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
57c2			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
57c2			; | | two bytes contain the file id and extent. 
57c2			; | |  
57c2			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
57c2			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
57c2			; | | > [!NOTE] 
57c2			; | | > Compatible with PicoSPINet  
57c2			 
57c2					if DEBUG_FORTH_WORDS_KEY 
57c2						DMARK "REA" 
57c2 f5				push af  
57c3 3a d7 57			ld a, (.dmark)  
57c6 32 a6 fd			ld (debug_mark),a  
57c9 3a d8 57			ld a, (.dmark+1)  
57cc 32 a7 fd			ld (debug_mark+1),a  
57cf 3a d9 57			ld a, (.dmark+2)  
57d2 32 a8 fd			ld (debug_mark+2),a  
57d5 18 03			jr .pastdmark  
57d7 ..			.dmark: db "REA"  
57da f1			.pastdmark: pop af  
57db			endm  
# End of macro DMARK
57db						CALLMONITOR 
57db cd aa fd			call debug_vector  
57de				endm  
# End of macro CALLMONITOR
57de					endif 
57de					; store_openext use it. If zero it is EOF 
57de			 
57de					; read block from current stream id 
57de					; if the block does not contain zero term keep reading blocks until zero found 
57de					; push the block to stack 
57de					; save the block id to stream 
57de			 
57de			 
57de cd 10 59				call .testeof 
57e1 3e 01				ld a, 1 
57e3 bd					cp l 
57e4 ca bf 58				jp z, .ateof 
57e7			 
57e7			 
57e7			;		FORTH_DSP_VALUEHL 
57e7			 
57e7			;		push hl 
57e7			 
57e7			;	if DEBUG_STORESE 
57e7			;		DMARK "REA" 
57e7			;		CALLMONITOR 
57e7			;	endif 
57e7			;		FORTH_DSP_POP 
57e7			 
57e7			;		pop hl 
57e7				 
57e7 3a a2 f9				ld a, (store_filecache) 
57ea 67					ld h,a 
57eb			 
57eb 3a a5 f9				ld a, (store_openext) 
57ee 6f					ld l, a 
57ef					 
57ef fe 00				cp 0 
57f1 ca bf 58				jp z, .ateof     ; dont read past eof 
57f4			 
57f4 cd a1 0c				call storage_clear_page 
57f7			 
57f7 11 b5 f9				ld de, store_page 
57fa				if DEBUG_STORESE 
57fa					DMARK "RE1" 
57fa f5				push af  
57fb 3a 0f 58			ld a, (.dmark)  
57fe 32 a6 fd			ld (debug_mark),a  
5801 3a 10 58			ld a, (.dmark+1)  
5804 32 a7 fd			ld (debug_mark+1),a  
5807 3a 11 58			ld a, (.dmark+2)  
580a 32 a8 fd			ld (debug_mark+2),a  
580d 18 03			jr .pastdmark  
580f ..			.dmark: db "RE1"  
5812 f1			.pastdmark: pop af  
5813			endm  
# End of macro DMARK
5813					CALLMONITOR 
5813 cd aa fd			call debug_vector  
5816				endm  
# End of macro CALLMONITOR
5816				endif 
5816 cd be 09				call storage_read 
5819			 
5819				if DEBUG_STORESE 
5819					DMARK "RE2" 
5819 f5				push af  
581a 3a 2e 58			ld a, (.dmark)  
581d 32 a6 fd			ld (debug_mark),a  
5820 3a 2f 58			ld a, (.dmark+1)  
5823 32 a7 fd			ld (debug_mark+1),a  
5826 3a 30 58			ld a, (.dmark+2)  
5829 32 a8 fd			ld (debug_mark+2),a  
582c 18 03			jr .pastdmark  
582e ..			.dmark: db "RE2"  
5831 f1			.pastdmark: pop af  
5832			endm  
# End of macro DMARK
5832					CALLMONITOR 
5832 cd aa fd			call debug_vector  
5835				endm  
# End of macro CALLMONITOR
5835				endif 
5835 cd f8 0f			call ishlzero 
5838			;	ld a, l 
5838			;	add h 
5838			;	cp 0 
5838 ca bf 58			jp z, .readeof 
583b			 
583b				; not eof so hl should point to data to push to stack 
583b			 
583b				if DEBUG_STORESE 
583b					DMARK "RE3" 
583b f5				push af  
583c 3a 50 58			ld a, (.dmark)  
583f 32 a6 fd			ld (debug_mark),a  
5842 3a 51 58			ld a, (.dmark+1)  
5845 32 a7 fd			ld (debug_mark+1),a  
5848 3a 52 58			ld a, (.dmark+2)  
584b 32 a8 fd			ld (debug_mark+2),a  
584e 18 03			jr .pastdmark  
5850 ..			.dmark: db "RE3"  
5853 f1			.pastdmark: pop af  
5854			endm  
# End of macro DMARK
5854					CALLMONITOR 
5854 cd aa fd			call debug_vector  
5857				endm  
# End of macro CALLMONITOR
5857				endif 
5857 cd d0 22			call forth_push_str 
585a			 
585a				if DEBUG_STORESE 
585a					DMARK "RE4" 
585a f5				push af  
585b 3a 6f 58			ld a, (.dmark)  
585e 32 a6 fd			ld (debug_mark),a  
5861 3a 70 58			ld a, (.dmark+1)  
5864 32 a7 fd			ld (debug_mark+1),a  
5867 3a 71 58			ld a, (.dmark+2)  
586a 32 a8 fd			ld (debug_mark+2),a  
586d 18 03			jr .pastdmark  
586f ..			.dmark: db "RE4"  
5872 f1			.pastdmark: pop af  
5873			endm  
# End of macro DMARK
5873					CALLMONITOR 
5873 cd aa fd			call debug_vector  
5876				endm  
# End of macro CALLMONITOR
5876				endif 
5876				; get next block  or mark as eof 
5876			 
5876 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
5879 4f				ld c, a	 
587a 3a a5 f9			ld a, (store_openext) 
587d			 
587d				if DEBUG_STORESE 
587d					DMARK "RE5" 
587d f5				push af  
587e 3a 92 58			ld a, (.dmark)  
5881 32 a6 fd			ld (debug_mark),a  
5884 3a 93 58			ld a, (.dmark+1)  
5887 32 a7 fd			ld (debug_mark+1),a  
588a 3a 94 58			ld a, (.dmark+2)  
588d 32 a8 fd			ld (debug_mark+2),a  
5890 18 03			jr .pastdmark  
5892 ..			.dmark: db "RE5"  
5895 f1			.pastdmark: pop af  
5896			endm  
# End of macro DMARK
5896					CALLMONITOR 
5896 cd aa fd			call debug_vector  
5899				endm  
# End of macro CALLMONITOR
5899				endif 
5899 b9				cp c 
589a 28 23			jr z, .readeof     ; at last extent 
589c			 
589c 3c					inc a 
589d 32 a5 f9				ld (store_openext), a 
58a0			 
58a0				if DEBUG_STORESE 
58a0					DMARK "RE6" 
58a0 f5				push af  
58a1 3a b5 58			ld a, (.dmark)  
58a4 32 a6 fd			ld (debug_mark),a  
58a7 3a b6 58			ld a, (.dmark+1)  
58aa 32 a7 fd			ld (debug_mark+1),a  
58ad 3a b7 58			ld a, (.dmark+2)  
58b0 32 a8 fd			ld (debug_mark+2),a  
58b3 18 03			jr .pastdmark  
58b5 ..			.dmark: db "RE6"  
58b8 f1			.pastdmark: pop af  
58b9			endm  
# End of macro DMARK
58b9					CALLMONITOR 
58b9 cd aa fd			call debug_vector  
58bc				endm  
# End of macro CALLMONITOR
58bc				endif 
58bc			 
58bc			 
58bc				       NEXTW 
58bc c3 0f 26			jp macro_next 
58bf				endm 
# End of macro NEXTW
58bf			.ateof: 
58bf				;	ld hl, .showeof 
58bf				;	call forth_push_str 
58bf 3e 00		.readeof:	ld a, 0 
58c1 32 a5 f9				ld (store_openext), a 
58c4			 
58c4					 
58c4				if DEBUG_STORESE 
58c4					DMARK "REF" 
58c4 f5				push af  
58c5 3a d9 58			ld a, (.dmark)  
58c8 32 a6 fd			ld (debug_mark),a  
58cb 3a da 58			ld a, (.dmark+1)  
58ce 32 a7 fd			ld (debug_mark+1),a  
58d1 3a db 58			ld a, (.dmark+2)  
58d4 32 a8 fd			ld (debug_mark+2),a  
58d7 18 03			jr .pastdmark  
58d9 ..			.dmark: db "REF"  
58dc f1			.pastdmark: pop af  
58dd			endm  
# End of macro DMARK
58dd					CALLMONITOR 
58dd cd aa fd			call debug_vector  
58e0				endm  
# End of macro CALLMONITOR
58e0				endif 
58e0				       NEXTW 
58e0 c3 0f 26			jp macro_next 
58e3				endm 
# End of macro NEXTW
58e3			 
58e3			;.showeof:   db "eof", 0 
58e3			 
58e3			 
58e3			.EOF: 
58e3				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
58e3 6d				db WORD_SYS_CORE+89             
58e4 25 59			dw .FORMAT            
58e6 04				db 3 + 1 
58e7 .. 00			db "EOF",0              
58eb				endm 
# End of macro CWHEAD
58eb			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
58eb			; | | e.g. 
58eb			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
58eb			; | | > [!NOTE] 
58eb			; | | > Compatible with PicoSPINet  
58eb					; TODO if current block id for stream is zero then push true else false 
58eb			 
58eb					if DEBUG_FORTH_WORDS_KEY 
58eb						DMARK "EOF" 
58eb f5				push af  
58ec 3a 00 59			ld a, (.dmark)  
58ef 32 a6 fd			ld (debug_mark),a  
58f2 3a 01 59			ld a, (.dmark+1)  
58f5 32 a7 fd			ld (debug_mark+1),a  
58f8 3a 02 59			ld a, (.dmark+2)  
58fb 32 a8 fd			ld (debug_mark+2),a  
58fe 18 03			jr .pastdmark  
5900 ..			.dmark: db "EOF"  
5903 f1			.pastdmark: pop af  
5904			endm  
# End of macro DMARK
5904						CALLMONITOR 
5904 cd aa fd			call debug_vector  
5907				endm  
# End of macro CALLMONITOR
5907					endif 
5907			 
5907					; TODO handlue multiple file streams 
5907			 
5907			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5907 cd 10 59				call .testeof 
590a cd 62 22				call forth_push_numhl 
590d			 
590d			 
590d				       NEXTW 
590d c3 0f 26			jp macro_next 
5910				endm 
# End of macro NEXTW
5910			 
5910			.testeof: 
5910 2e 01				ld l, 1 
5912 3a a4 f9				ld a, (store_openmaxext) 
5915 fe 00				cp 0 
5917 28 09				jr  z, .eofdone   ; empty file 
5919 3a a5 f9				ld a, (store_openext) 
591c fe 00				cp 0 
591e 28 02				jr  z, .eofdone 
5920 2e 00				ld l, 0 
5922 26 00		.eofdone:	ld h, 0 
5924 c9					ret 
5925			 
5925			 
5925			 
5925			 
5925			.FORMAT: 
5925				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5925 6d				db WORD_SYS_CORE+89             
5926 76 59			dw .LABEL            
5928 07				db 6 + 1 
5929 .. 00			db "FORMAT",0              
5930				endm 
# End of macro CWHEAD
5930			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5930			; | | > [!NOTE] 
5930			; | | > Compatible with PicoSPINet  
5930					; TODO if current block id for stream is zero then push true else false 
5930				 
5930				if DEBUG_STORESE 
5930					DMARK "FOR" 
5930 f5				push af  
5931 3a 45 59			ld a, (.dmark)  
5934 32 a6 fd			ld (debug_mark),a  
5937 3a 46 59			ld a, (.dmark+1)  
593a 32 a7 fd			ld (debug_mark+1),a  
593d 3a 47 59			ld a, (.dmark+2)  
5940 32 a8 fd			ld (debug_mark+2),a  
5943 18 03			jr .pastdmark  
5945 ..			.dmark: db "FOR"  
5948 f1			.pastdmark: pop af  
5949			endm  
# End of macro DMARK
5949					CALLMONITOR 
5949 cd aa fd			call debug_vector  
594c				endm  
# End of macro CALLMONITOR
594c				endif 
594c					; Wipes the bank check flags to cause a reformat on next block 0 read 
594c			 
594c 21 01 00				ld hl, 1 
594f 3e 00				ld a, 0 
5951 cd 6a 02				call se_writebyte 
5954			 
5954				if DEBUG_STORESE 
5954					DMARK "FO0" 
5954 f5				push af  
5955 3a 69 59			ld a, (.dmark)  
5958 32 a6 fd			ld (debug_mark),a  
595b 3a 6a 59			ld a, (.dmark+1)  
595e 32 a7 fd			ld (debug_mark+1),a  
5961 3a 6b 59			ld a, (.dmark+2)  
5964 32 a8 fd			ld (debug_mark+2),a  
5967 18 03			jr .pastdmark  
5969 ..			.dmark: db "FO0"  
596c f1			.pastdmark: pop af  
596d			endm  
# End of macro DMARK
596d					CALLMONITOR 
596d cd aa fd			call debug_vector  
5970				endm  
# End of macro CALLMONITOR
5970				endif 
5970					; force bank init 
5970			 
5970 cd 16 05				call storage_get_block_0 
5973					 
5973				       NEXTW 
5973 c3 0f 26			jp macro_next 
5976				endm 
# End of macro NEXTW
5976			.LABEL: 
5976				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5976 6d				db WORD_SYS_CORE+89             
5977 c4 59			dw .STOREPAGE            
5979 06				db 5 + 1 
597a .. 00			db "LABEL",0              
5980				endm 
# End of macro CWHEAD
5980			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5980			; | | > [!NOTE] 
5980			; | | > Compatible with PicoSPINet  
5980					; TODO test to see if bank is selected 
5980				 
5980					if DEBUG_FORTH_WORDS_KEY 
5980						DMARK "LBL" 
5980 f5				push af  
5981 3a 95 59			ld a, (.dmark)  
5984 32 a6 fd			ld (debug_mark),a  
5987 3a 96 59			ld a, (.dmark+1)  
598a 32 a7 fd			ld (debug_mark+1),a  
598d 3a 97 59			ld a, (.dmark+2)  
5990 32 a8 fd			ld (debug_mark+2),a  
5993 18 03			jr .pastdmark  
5995 ..			.dmark: db "LBL"  
5998 f1			.pastdmark: pop af  
5999			endm  
# End of macro DMARK
5999						CALLMONITOR 
5999 cd aa fd			call debug_vector  
599c				endm  
# End of macro CALLMONITOR
599c					endif 
599c			;	if DEBUG_STORESE 
599c			;		DMARK "LBL" 
599c			;		CALLMONITOR 
599c			;	endif 
599c					FORTH_DSP_VALUEHL 
599c cd 59 24			call macro_dsp_valuehl 
599f				endm 
# End of macro FORTH_DSP_VALUEHL
599f					;v5FORTH_DSP_VALUE 
599f					 
599f			;		push hl 
599f					FORTH_DSP_POP 
599f cd 11 25			call macro_forth_dsp_pop 
59a2				endm 
# End of macro FORTH_DSP_POP
59a2			;		pop hl 
59a2			 
59a2			;v5		inc hl   ; move past the type marker 
59a2			 
59a2				if DEBUG_STORESE 
59a2					DMARK "LBl" 
59a2 f5				push af  
59a3 3a b7 59			ld a, (.dmark)  
59a6 32 a6 fd			ld (debug_mark),a  
59a9 3a b8 59			ld a, (.dmark+1)  
59ac 32 a7 fd			ld (debug_mark+1),a  
59af 3a b9 59			ld a, (.dmark+2)  
59b2 32 a8 fd			ld (debug_mark+2),a  
59b5 18 03			jr .pastdmark  
59b7 ..			.dmark: db "LBl"  
59ba f1			.pastdmark: pop af  
59bb			endm  
# End of macro DMARK
59bb					CALLMONITOR 
59bb cd aa fd			call debug_vector  
59be				endm  
# End of macro CALLMONITOR
59be				endif 
59be cd 3a 06				call storage_label 
59c1			 
59c1				       NEXTW 
59c1 c3 0f 26			jp macro_next 
59c4				endm 
# End of macro NEXTW
59c4			.STOREPAGE: 
59c4				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
59c4 6d				db WORD_SYS_CORE+89             
59c5 f7 59			dw .LABELS            
59c7 0a				db 9 + 1 
59c8 .. 00			db "STOREPAGE",0              
59d2				endm 
# End of macro CWHEAD
59d2			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
59d2			; | | > [!NOTE] 
59d2			; | | > Compatible with PicoSPINet  
59d2					; TODO test to see if bank is selected 
59d2				 
59d2					if DEBUG_FORTH_WORDS_KEY 
59d2						DMARK "STP" 
59d2 f5				push af  
59d3 3a e7 59			ld a, (.dmark)  
59d6 32 a6 fd			ld (debug_mark),a  
59d9 3a e8 59			ld a, (.dmark+1)  
59dc 32 a7 fd			ld (debug_mark+1),a  
59df 3a e9 59			ld a, (.dmark+2)  
59e2 32 a8 fd			ld (debug_mark+2),a  
59e5 18 03			jr .pastdmark  
59e7 ..			.dmark: db "STP"  
59ea f1			.pastdmark: pop af  
59eb			endm  
# End of macro DMARK
59eb						CALLMONITOR 
59eb cd aa fd			call debug_vector  
59ee				endm  
# End of macro CALLMONITOR
59ee					endif 
59ee			;	if DEBUG_STORESE 
59ee			;		DMARK "STP" 
59ee			;		CALLMONITOR 
59ee			;	endif 
59ee			 
59ee 21 b5 f9			ld hl, store_page 
59f1 cd 62 22			call forth_push_numhl 
59f4			 
59f4			 
59f4				       NEXTW 
59f4 c3 0f 26			jp macro_next 
59f7				endm 
# End of macro NEXTW
59f7			.LABELS: 
59f7				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
59f7 6d				db WORD_SYS_CORE+89             
59f8 81 5a			dw .SCONST1            
59fa 07				db 6 + 1 
59fb .. 00			db "LABELS",0              
5a02				endm 
# End of macro CWHEAD
5a02			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5a02			; | | > [!CAUTION] 
5a02			; | | > *NOT* Compatible with PicoSPINet  
5a02					;  
5a02			 
5a02					; save the current device selected to restore afterwards 
5a02				 
5a02 3a 9b f9				ld a, (spi_device) 
5a05 f5					push af 
5a06			 
5a06			 
5a06					; run through each of the banks 
5a06			 
5a06 21 01 00				ld hl, 1 
5a09 cd 62 22				call forth_push_numhl 
5a0c 3e ff				ld a, SPI_CE_HIGH 
5a0e cb 87				res SPI_CE0, a 
5a10 32 9b f9				ld (spi_device), a 
5a13 cd 16 05				call storage_get_block_0 
5a16 21 b8 f9				ld hl, store_page+3 
5a19 cd d0 22				call forth_push_str 
5a1c			 
5a1c					 
5a1c 21 02 00				ld hl, 2 
5a1f cd 62 22				call forth_push_numhl 
5a22 3e ff				ld a, SPI_CE_HIGH 
5a24 cb 8f				res SPI_CE1, a 
5a26 32 9b f9				ld (spi_device), a 
5a29 cd 16 05				call storage_get_block_0 
5a2c 21 b8 f9				ld hl, store_page+3 
5a2f cd d0 22				call forth_push_str 
5a32			 
5a32					 
5a32 21 03 00				ld hl, 3 
5a35 cd 62 22				call forth_push_numhl 
5a38 3e ff				ld a, SPI_CE_HIGH 
5a3a cb 97				res SPI_CE2, a 
5a3c 32 9b f9				ld (spi_device), a 
5a3f cd 16 05				call storage_get_block_0 
5a42 21 b8 f9				ld hl, store_page+3 
5a45 cd d0 22				call forth_push_str 
5a48			 
5a48			 
5a48 21 04 00				ld hl, 4 
5a4b cd 62 22				call forth_push_numhl 
5a4e 3e ff				ld a, SPI_CE_HIGH 
5a50 cb 9f				res SPI_CE3, a 
5a52 32 9b f9				ld (spi_device), a 
5a55 cd 16 05				call storage_get_block_0 
5a58 21 b8 f9				ld hl, store_page+3 
5a5b cd d0 22				call forth_push_str 
5a5e			 
5a5e					 
5a5e			 
5a5e 21 05 00				ld hl, 5 
5a61 cd 62 22				call forth_push_numhl 
5a64 3e ff				ld a, SPI_CE_HIGH 
5a66 cb a7				res SPI_CE4, a 
5a68 32 9b f9				ld (spi_device), a 
5a6b cd 16 05				call storage_get_block_0 
5a6e 21 b8 f9				ld hl, store_page+3 
5a71 cd d0 22				call forth_push_str 
5a74			 
5a74					 
5a74					; push fixed count of storage devices (on board) for now 
5a74			 
5a74 21 05 00				ld hl, 5 
5a77 cd 62 22				call forth_push_numhl 
5a7a			 
5a7a					; restore selected device  
5a7a				 
5a7a f1					pop af 
5a7b 32 9b f9				ld (spi_device), a 
5a7e			 
5a7e				       NEXTW 
5a7e c3 0f 26			jp macro_next 
5a81				endm 
# End of macro NEXTW
5a81			 
5a81			.SCONST1: 
5a81				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5a81 6d				db WORD_SYS_CORE+89             
5a82 98 5a			dw .SCONST2            
5a84 07				db 6 + 1 
5a85 .. 00			db "FILEID",0              
5a8c				endm 
# End of macro CWHEAD
5a8c			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5a8c			; | | > [!NOTE] 
5a8c			; | | > Compatible with PicoSPINet  
5a8c 3a a2 f9				ld a, (store_filecache) 
5a8f 26 00				ld h, 0 
5a91 6f					ld l, a 
5a92 cd 62 22				call forth_push_numhl 
5a95					NEXTW 
5a95 c3 0f 26			jp macro_next 
5a98				endm 
# End of macro NEXTW
5a98			.SCONST2: 
5a98				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5a98 6d				db WORD_SYS_CORE+89             
5a99 b0 5a			dw .SCONST3            
5a9b 08				db 7 + 1 
5a9c .. 00			db "FILEEXT",0              
5aa4				endm 
# End of macro CWHEAD
5aa4			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5aa4			; | | > [!NOTE] 
5aa4			; | | > Compatible with PicoSPINet  
5aa4 3a a5 f9				ld a, (store_openext) 
5aa7 26 00				ld h, 0 
5aa9 6f					ld l, a 
5aaa cd 62 22				call forth_push_numhl 
5aad					NEXTW 
5aad c3 0f 26			jp macro_next 
5ab0				endm 
# End of macro NEXTW
5ab0			.SCONST3: 
5ab0				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5ab0 6d				db WORD_SYS_CORE+89             
5ab1 c8 5a			dw .SCONST4            
5ab3 08				db 7 + 1 
5ab4 .. 00			db "FILEMAX",0              
5abc				endm 
# End of macro CWHEAD
5abc			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5abc			; | | > [!NOTE] 
5abc			; | | > Compatible with PicoSPINet  
5abc 3a a4 f9				ld a, (store_openmaxext) 
5abf 26 00				ld h, 0 
5ac1 6f					ld l, a 
5ac2 cd 62 22				call forth_push_numhl 
5ac5					NEXTW 
5ac5 c3 0f 26			jp macro_next 
5ac8				endm 
# End of macro NEXTW
5ac8			.SCONST4: 
5ac8				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5ac8 6d				db WORD_SYS_CORE+89             
5ac9 de 5a			dw .SCONST5            
5acb 09				db 8 + 1 
5acc .. 00			db "FILEADDR",0              
5ad5				endm 
# End of macro CWHEAD
5ad5			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5ad5			; | | > [!NOTE] 
5ad5			; | | > Compatible with PicoSPINet  
5ad5 2a a6 f9				ld hl, (store_openaddr) 
5ad8 cd 62 22				call forth_push_numhl 
5adb					NEXTW 
5adb c3 0f 26			jp macro_next 
5ade				endm 
# End of macro NEXTW
5ade			.SCONST5: 
5ade				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5ade 6d				db WORD_SYS_CORE+89             
5adf ff 5a			dw .SCONST6            
5ae1 09				db 8 + 1 
5ae2 .. 00			db "FILEPAGE",0              
5aeb				endm 
# End of macro CWHEAD
5aeb			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5aeb			; | | > [!NOTE] 
5aeb			; | | > Compatible with PicoSPINet  
5aeb 2a a6 f9				ld hl, (store_openaddr) 
5aee e5					push hl 
5aef c1					pop bc 
5af0 16 00				ld d, 0 
5af2 1e 40				ld e, STORE_BLOCK_PHY 
5af4 cd 2c 0f				call Div16 
5af7 c5					push bc 
5af8 e1					pop hl 
5af9 cd 62 22				call forth_push_numhl 
5afc					NEXTW 
5afc c3 0f 26			jp macro_next 
5aff				endm 
# End of macro NEXTW
5aff			.SCONST6: 
5aff				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5aff 6d				db WORD_SYS_CORE+89             
5b00 18 5b			dw .ENDSTORAGE            
5b02 09				db 8 + 1 
5b03 .. 00			db "READCONT",0              
5b0c				endm 
# End of macro CWHEAD
5b0c			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5b0c			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5b0c			; | | a further read should, if applicable, be CONCAT to the previous read. 
5b0c			; | | > [!NOTE] 
5b0c			; | | > Compatible with PicoSPINet  
5b0c 3a a8 f9				ld a, (store_readcont) 
5b0f 26 00				ld h, 0 
5b11 6f					ld l, a 
5b12 cd 62 22				call forth_push_numhl 
5b15					NEXTW 
5b15 c3 0f 26			jp macro_next 
5b18				endm 
# End of macro NEXTW
5b18			.ENDSTORAGE: 
5b18			; eof 
# End of file forth_words_storage.asm
5b18			endif 
5b18				include "forth_words_device.asm" 
5b18			; Device related words 
5b18			 
5b18			; | ## Device Words 
5b18			 
5b18			;if SOUND_ENABLE 
5b18			;.NOTE: 
5b18			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5b18			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5b18			;		if DEBUG_FORTH_WORDS_KEY 
5b18			;			DMARK "NTE" 
5b18			;			CALLMONITOR 
5b18			;		endif 
5b18			; 
5b18			;	 
5b18			; 
5b18			;		NEXTW 
5b18			;.AFTERSOUND: 
5b18			;endif 
5b18			 
5b18			 
5b18			USE_GPIO: equ 0 
5b18			 
5b18			if USE_GPIO 
5b18			.GP1: 
5b18				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5b18			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5b18					NEXTW 
5b18			.GP2: 
5b18				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5b18			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5b18			 
5b18					NEXTW 
5b18			 
5b18			.GP3: 
5b18				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5b18			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5b18			 
5b18					NEXTW 
5b18			 
5b18			.GP4: 
5b18				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5b18			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5b18			 
5b18					NEXTW 
5b18			.SIN: 
5b18			 
5b18			 
5b18			endif 
5b18			 
5b18			 
5b18				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5b18 33				db WORD_SYS_CORE+31             
5b19 4d 5b			dw .SOUT            
5b1b 03				db 2 + 1 
5b1c .. 00			db "IN",0              
5b1f				endm 
# End of macro CWHEAD
5b1f			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5b1f					if DEBUG_FORTH_WORDS_KEY 
5b1f						DMARK "IN." 
5b1f f5				push af  
5b20 3a 34 5b			ld a, (.dmark)  
5b23 32 a6 fd			ld (debug_mark),a  
5b26 3a 35 5b			ld a, (.dmark+1)  
5b29 32 a7 fd			ld (debug_mark+1),a  
5b2c 3a 36 5b			ld a, (.dmark+2)  
5b2f 32 a8 fd			ld (debug_mark+2),a  
5b32 18 03			jr .pastdmark  
5b34 ..			.dmark: db "IN."  
5b37 f1			.pastdmark: pop af  
5b38			endm  
# End of macro DMARK
5b38						CALLMONITOR 
5b38 cd aa fd			call debug_vector  
5b3b				endm  
# End of macro CALLMONITOR
5b3b					endif 
5b3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b3b cd 59 24			call macro_dsp_valuehl 
5b3e				endm 
# End of macro FORTH_DSP_VALUEHL
5b3e			 
5b3e e5					push hl 
5b3f			 
5b3f					; destroy value TOS 
5b3f			 
5b3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b3f cd 11 25			call macro_forth_dsp_pop 
5b42				endm 
# End of macro FORTH_DSP_POP
5b42			 
5b42					; one value on hl get other one back 
5b42			 
5b42 c1					pop bc 
5b43			 
5b43					; do the sub 
5b43			;		ex de, hl 
5b43			 
5b43 ed 68				in l,(c) 
5b45			 
5b45					; save it 
5b45			 
5b45 26 00				ld h,0 
5b47			 
5b47					; TODO push value back onto stack for another op etc 
5b47			 
5b47 cd 62 22				call forth_push_numhl 
5b4a					NEXTW 
5b4a c3 0f 26			jp macro_next 
5b4d				endm 
# End of macro NEXTW
5b4d			.SOUT: 
5b4d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5b4d 34				db WORD_SYS_CORE+32             
5b4e a0 5b			dw .SPIO            
5b50 04				db 3 + 1 
5b51 .. 00			db "OUT",0              
5b55				endm 
# End of macro CWHEAD
5b55			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5b55					if DEBUG_FORTH_WORDS_KEY 
5b55						DMARK "OUT" 
5b55 f5				push af  
5b56 3a 6a 5b			ld a, (.dmark)  
5b59 32 a6 fd			ld (debug_mark),a  
5b5c 3a 6b 5b			ld a, (.dmark+1)  
5b5f 32 a7 fd			ld (debug_mark+1),a  
5b62 3a 6c 5b			ld a, (.dmark+2)  
5b65 32 a8 fd			ld (debug_mark+2),a  
5b68 18 03			jr .pastdmark  
5b6a ..			.dmark: db "OUT"  
5b6d f1			.pastdmark: pop af  
5b6e			endm  
# End of macro DMARK
5b6e						CALLMONITOR 
5b6e cd aa fd			call debug_vector  
5b71				endm  
# End of macro CALLMONITOR
5b71					endif 
5b71			 
5b71					; get port 
5b71			 
5b71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b71 cd 59 24			call macro_dsp_valuehl 
5b74				endm 
# End of macro FORTH_DSP_VALUEHL
5b74			 
5b74 e5					push hl 
5b75			 
5b75					; destroy value TOS 
5b75			 
5b75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b75 cd 11 25			call macro_forth_dsp_pop 
5b78				endm 
# End of macro FORTH_DSP_POP
5b78			 
5b78					; get byte to send 
5b78			 
5b78					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b78 cd 59 24			call macro_dsp_valuehl 
5b7b				endm 
# End of macro FORTH_DSP_VALUEHL
5b7b			 
5b7b			;		push hl 
5b7b			 
5b7b					; destroy value TOS 
5b7b			 
5b7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b7b cd 11 25			call macro_forth_dsp_pop 
5b7e				endm 
# End of macro FORTH_DSP_POP
5b7e			 
5b7e					; one value on hl get other one back 
5b7e			 
5b7e			;		pop hl 
5b7e			 
5b7e c1					pop bc 
5b7f			 
5b7f					if DEBUG_FORTH_WORDS 
5b7f						DMARK "OUT" 
5b7f f5				push af  
5b80 3a 94 5b			ld a, (.dmark)  
5b83 32 a6 fd			ld (debug_mark),a  
5b86 3a 95 5b			ld a, (.dmark+1)  
5b89 32 a7 fd			ld (debug_mark+1),a  
5b8c 3a 96 5b			ld a, (.dmark+2)  
5b8f 32 a8 fd			ld (debug_mark+2),a  
5b92 18 03			jr .pastdmark  
5b94 ..			.dmark: db "OUT"  
5b97 f1			.pastdmark: pop af  
5b98			endm  
# End of macro DMARK
5b98						CALLMONITOR 
5b98 cd aa fd			call debug_vector  
5b9b				endm  
# End of macro CALLMONITOR
5b9b					endif 
5b9b			 
5b9b ed 69				out (c), l 
5b9d			 
5b9d					NEXTW 
5b9d c3 0f 26			jp macro_next 
5ba0				endm 
# End of macro NEXTW
5ba0			 
5ba0			 
5ba0			.SPIO: 
5ba0			 
5ba0			if STORAGE_SE 
5ba0				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5ba0 51				db WORD_SYS_CORE+61             
5ba1 b1 5b			dw .SPICEH            
5ba3 07				db 6 + 1 
5ba4 .. 00			db "SPICEL",0              
5bab				endm 
# End of macro CWHEAD
5bab			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5bab			 
5bab cd 13 02				call spi_ce_low 
5bae			    NEXTW 
5bae c3 0f 26			jp macro_next 
5bb1				endm 
# End of macro NEXTW
5bb1			 
5bb1			.SPICEH: 
5bb1				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5bb1 51				db WORD_SYS_CORE+61             
5bb2 c2 5b			dw .SPIOb            
5bb4 07				db 6 + 1 
5bb5 .. 00			db "SPICEH",0              
5bbc				endm 
# End of macro CWHEAD
5bbc			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5bbc			 
5bbc cd 02 02				call spi_ce_high 
5bbf			    NEXTW 
5bbf c3 0f 26			jp macro_next 
5bc2				endm 
# End of macro NEXTW
5bc2			 
5bc2			 
5bc2			.SPIOb: 
5bc2			 
5bc2				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5bc2 51				db WORD_SYS_CORE+61             
5bc3 f4 5b			dw .SPII            
5bc5 05				db 4 + 1 
5bc6 .. 00			db "SPIO",0              
5bcb				endm 
# End of macro CWHEAD
5bcb			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5bcb			 
5bcb					if DEBUG_FORTH_WORDS_KEY 
5bcb						DMARK "SPo" 
5bcb f5				push af  
5bcc 3a e0 5b			ld a, (.dmark)  
5bcf 32 a6 fd			ld (debug_mark),a  
5bd2 3a e1 5b			ld a, (.dmark+1)  
5bd5 32 a7 fd			ld (debug_mark+1),a  
5bd8 3a e2 5b			ld a, (.dmark+2)  
5bdb 32 a8 fd			ld (debug_mark+2),a  
5bde 18 03			jr .pastdmark  
5be0 ..			.dmark: db "SPo"  
5be3 f1			.pastdmark: pop af  
5be4			endm  
# End of macro DMARK
5be4						CALLMONITOR 
5be4 cd aa fd			call debug_vector  
5be7				endm  
# End of macro CALLMONITOR
5be7					endif 
5be7					; get port 
5be7			 
5be7			 
5be7					; get byte to send 
5be7			 
5be7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5be7 cd 59 24			call macro_dsp_valuehl 
5bea				endm 
# End of macro FORTH_DSP_VALUEHL
5bea			 
5bea			;		push hl    ; u1  
5bea			 
5bea					; destroy value TOS 
5bea			 
5bea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bea cd 11 25			call macro_forth_dsp_pop 
5bed				endm 
# End of macro FORTH_DSP_POP
5bed			 
5bed					; one value on hl get other one back 
5bed			 
5bed			;		pop hl   ; u2 - addr 
5bed			 
5bed					; TODO Send SPI byte 
5bed			 
5bed			;		push hl 
5bed			;		call spi_ce_low 
5bed			;		pop hl 
5bed 7d					ld a, l 
5bee cd 01 01				call spi_send_byte 
5bf1			;		call spi_ce_high 
5bf1			 
5bf1					NEXTW 
5bf1 c3 0f 26			jp macro_next 
5bf4				endm 
# End of macro NEXTW
5bf4			 
5bf4			.SPII: 
5bf4				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5bf4 52				db WORD_SYS_CORE+62             
5bf5 5d 5c			dw .SESEL            
5bf7 06				db 5 + 1 
5bf8 .. 00			db "SPII",0              
5bfd				endm 
# End of macro CWHEAD
5bfd			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5bfd					if DEBUG_FORTH_WORDS_KEY 
5bfd						DMARK "SPi" 
5bfd f5				push af  
5bfe 3a 12 5c			ld a, (.dmark)  
5c01 32 a6 fd			ld (debug_mark),a  
5c04 3a 13 5c			ld a, (.dmark+1)  
5c07 32 a7 fd			ld (debug_mark+1),a  
5c0a 3a 14 5c			ld a, (.dmark+2)  
5c0d 32 a8 fd			ld (debug_mark+2),a  
5c10 18 03			jr .pastdmark  
5c12 ..			.dmark: db "SPi"  
5c15 f1			.pastdmark: pop af  
5c16			endm  
# End of macro DMARK
5c16						CALLMONITOR 
5c16 cd aa fd			call debug_vector  
5c19				endm  
# End of macro CALLMONITOR
5c19					endif 
5c19			 
5c19					; TODO Get SPI byte 
5c19			 
5c19 cd 28 01				call spi_read_byte 
5c1c			 
5c1c					if DEBUG_FORTH_WORDS 
5c1c						DMARK "Si2" 
5c1c f5				push af  
5c1d 3a 31 5c			ld a, (.dmark)  
5c20 32 a6 fd			ld (debug_mark),a  
5c23 3a 32 5c			ld a, (.dmark+1)  
5c26 32 a7 fd			ld (debug_mark+1),a  
5c29 3a 33 5c			ld a, (.dmark+2)  
5c2c 32 a8 fd			ld (debug_mark+2),a  
5c2f 18 03			jr .pastdmark  
5c31 ..			.dmark: db "Si2"  
5c34 f1			.pastdmark: pop af  
5c35			endm  
# End of macro DMARK
5c35						CALLMONITOR 
5c35 cd aa fd			call debug_vector  
5c38				endm  
# End of macro CALLMONITOR
5c38					endif 
5c38 26 00				ld h, 0 
5c3a 6f					ld l, a 
5c3b					if DEBUG_FORTH_WORDS 
5c3b						DMARK "Si3" 
5c3b f5				push af  
5c3c 3a 50 5c			ld a, (.dmark)  
5c3f 32 a6 fd			ld (debug_mark),a  
5c42 3a 51 5c			ld a, (.dmark+1)  
5c45 32 a7 fd			ld (debug_mark+1),a  
5c48 3a 52 5c			ld a, (.dmark+2)  
5c4b 32 a8 fd			ld (debug_mark+2),a  
5c4e 18 03			jr .pastdmark  
5c50 ..			.dmark: db "Si3"  
5c53 f1			.pastdmark: pop af  
5c54			endm  
# End of macro DMARK
5c54						CALLMONITOR 
5c54 cd aa fd			call debug_vector  
5c57				endm  
# End of macro CALLMONITOR
5c57					endif 
5c57 cd 62 22				call forth_push_numhl 
5c5a			 
5c5a					NEXTW 
5c5a c3 0f 26			jp macro_next 
5c5d				endm 
# End of macro NEXTW
5c5d			 
5c5d			 
5c5d			 
5c5d			.SESEL: 
5c5d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5c5d 66				db WORD_SYS_CORE+82             
5c5e 06 5d			dw .CARTDEV            
5c60 05				db 4 + 1 
5c61 .. 00			db "BANK",0              
5c66				endm 
# End of macro CWHEAD
5c66			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5c66					if DEBUG_FORTH_WORDS_KEY 
5c66						DMARK "BNK" 
5c66 f5				push af  
5c67 3a 7b 5c			ld a, (.dmark)  
5c6a 32 a6 fd			ld (debug_mark),a  
5c6d 3a 7c 5c			ld a, (.dmark+1)  
5c70 32 a7 fd			ld (debug_mark+1),a  
5c73 3a 7d 5c			ld a, (.dmark+2)  
5c76 32 a8 fd			ld (debug_mark+2),a  
5c79 18 03			jr .pastdmark  
5c7b ..			.dmark: db "BNK"  
5c7e f1			.pastdmark: pop af  
5c7f			endm  
# End of macro DMARK
5c7f						CALLMONITOR 
5c7f cd aa fd			call debug_vector  
5c82				endm  
# End of macro CALLMONITOR
5c82					endif 
5c82			 
5c82 3e ff				ld a, 255 
5c84 32 9e f9				ld (spi_cartdev), a 
5c87			 
5c87					; get bank 
5c87			 
5c87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c87 cd 59 24			call macro_dsp_valuehl 
5c8a				endm 
# End of macro FORTH_DSP_VALUEHL
5c8a			 
5c8a			;		push hl 
5c8a			 
5c8a					; destroy value TOS 
5c8a			 
5c8a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c8a cd 11 25			call macro_forth_dsp_pop 
5c8d				endm 
# End of macro FORTH_DSP_POP
5c8d			 
5c8d					; one value on hl get other one back 
5c8d			 
5c8d			;		pop hl 
5c8d			 
5c8d			 
5c8d 0e ff				ld c, SPI_CE_HIGH 
5c8f 06 30				ld b, '0'    ; human readable bank number 
5c91			 
5c91 7d					ld a, l 
5c92			 
5c92					if DEBUG_FORTH_WORDS 
5c92						DMARK "BNK" 
5c92 f5				push af  
5c93 3a a7 5c			ld a, (.dmark)  
5c96 32 a6 fd			ld (debug_mark),a  
5c99 3a a8 5c			ld a, (.dmark+1)  
5c9c 32 a7 fd			ld (debug_mark+1),a  
5c9f 3a a9 5c			ld a, (.dmark+2)  
5ca2 32 a8 fd			ld (debug_mark+2),a  
5ca5 18 03			jr .pastdmark  
5ca7 ..			.dmark: db "BNK"  
5caa f1			.pastdmark: pop af  
5cab			endm  
# End of macro DMARK
5cab						CALLMONITOR 
5cab cd aa fd			call debug_vector  
5cae				endm  
# End of macro CALLMONITOR
5cae					endif 
5cae			 
5cae					; active low 
5cae			 
5cae fe 00				cp 0 
5cb0 28 28				jr z, .bset 
5cb2 fe 01				cp 1 
5cb4 20 04				jr nz, .b2 
5cb6 cb 81				res 0, c 
5cb8 06 31				ld b, '1'    ; human readable bank number 
5cba fe 02		.b2:		cp 2 
5cbc 20 04				jr nz, .b3 
5cbe cb 89				res 1, c 
5cc0 06 32				ld b, '2'    ; human readable bank number 
5cc2 fe 03		.b3:		cp 3 
5cc4 20 04				jr nz, .b4 
5cc6 cb 91				res 2, c 
5cc8 06 33				ld b, '3'    ; human readable bank number 
5cca fe 04		.b4:		cp 4 
5ccc 20 04				jr nz, .b5 
5cce cb 99				res 3, c 
5cd0 06 34				ld b, '4'    ; human readable bank number 
5cd2 fe 05		.b5:		cp 5 
5cd4 20 04				jr nz, .bset 
5cd6 cb a1				res 4, c 
5cd8 06 35				ld b, '5'    ; human readable bank number 
5cda			 
5cda			.bset: 
5cda 79					ld a, c 
5cdb 32 9b f9				ld (spi_device),a 
5cde 78					ld a, b 
5cdf 32 9a f9				ld (spi_device_id),a 
5ce2					if DEBUG_FORTH_WORDS 
5ce2						DMARK "BN2" 
5ce2 f5				push af  
5ce3 3a f7 5c			ld a, (.dmark)  
5ce6 32 a6 fd			ld (debug_mark),a  
5ce9 3a f8 5c			ld a, (.dmark+1)  
5cec 32 a7 fd			ld (debug_mark+1),a  
5cef 3a f9 5c			ld a, (.dmark+2)  
5cf2 32 a8 fd			ld (debug_mark+2),a  
5cf5 18 03			jr .pastdmark  
5cf7 ..			.dmark: db "BN2"  
5cfa f1			.pastdmark: pop af  
5cfb			endm  
# End of macro DMARK
5cfb						CALLMONITOR 
5cfb cd aa fd			call debug_vector  
5cfe				endm  
# End of macro CALLMONITOR
5cfe					endif 
5cfe			 
5cfe					; set default SPI clk pulse time as disabled for BANK use 
5cfe			 
5cfe 3e 00				ld a, 0 
5d00 32 9f f9				ld (spi_clktime), a 
5d03			 
5d03					NEXTW 
5d03 c3 0f 26			jp macro_next 
5d06				endm 
# End of macro NEXTW
5d06			 
5d06			.CARTDEV: 
5d06				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5d06 66				db WORD_SYS_CORE+82             
5d07 b4 5d			dw .ENDDEVICE            
5d09 08				db 7 + 1 
5d0a .. 00			db "CARTDEV",0              
5d12				endm 
# End of macro CWHEAD
5d12			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5d12					if DEBUG_FORTH_WORDS_KEY 
5d12						DMARK "CDV" 
5d12 f5				push af  
5d13 3a 27 5d			ld a, (.dmark)  
5d16 32 a6 fd			ld (debug_mark),a  
5d19 3a 28 5d			ld a, (.dmark+1)  
5d1c 32 a7 fd			ld (debug_mark+1),a  
5d1f 3a 29 5d			ld a, (.dmark+2)  
5d22 32 a8 fd			ld (debug_mark+2),a  
5d25 18 03			jr .pastdmark  
5d27 ..			.dmark: db "CDV"  
5d2a f1			.pastdmark: pop af  
5d2b			endm  
# End of macro DMARK
5d2b						CALLMONITOR 
5d2b cd aa fd			call debug_vector  
5d2e				endm  
# End of macro CALLMONITOR
5d2e					endif 
5d2e			 
5d2e					; disable se storage bank selection 
5d2e			 
5d2e 3e ff				ld a, SPI_CE_HIGH		; ce high 
5d30 32 9b f9				ld (spi_device), a 
5d33			 
5d33					; get bank 
5d33			 
5d33					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d33 cd 59 24			call macro_dsp_valuehl 
5d36				endm 
# End of macro FORTH_DSP_VALUEHL
5d36			 
5d36			;		push hl 
5d36			 
5d36					; destroy value TOS 
5d36			 
5d36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d36 cd 11 25			call macro_forth_dsp_pop 
5d39				endm 
# End of macro FORTH_DSP_POP
5d39			 
5d39					; one value on hl get other one back 
5d39			 
5d39			;		pop hl 
5d39			 
5d39					; active low 
5d39			 
5d39 0e ff				ld c, 255 
5d3b			 
5d3b 7d					ld a, l 
5d3c					if DEBUG_FORTH_WORDS 
5d3c						DMARK "CDV" 
5d3c f5				push af  
5d3d 3a 51 5d			ld a, (.dmark)  
5d40 32 a6 fd			ld (debug_mark),a  
5d43 3a 52 5d			ld a, (.dmark+1)  
5d46 32 a7 fd			ld (debug_mark+1),a  
5d49 3a 53 5d			ld a, (.dmark+2)  
5d4c 32 a8 fd			ld (debug_mark+2),a  
5d4f 18 03			jr .pastdmark  
5d51 ..			.dmark: db "CDV"  
5d54 f1			.pastdmark: pop af  
5d55			endm  
# End of macro DMARK
5d55						CALLMONITOR 
5d55 cd aa fd			call debug_vector  
5d58				endm  
# End of macro CALLMONITOR
5d58					endif 
5d58 fe 00				cp 0 
5d5a 28 30				jr z, .cset 
5d5c fe 01				cp 1 
5d5e 20 02				jr nz, .c2 
5d60 cb 81				res 0, c 
5d62 fe 02		.c2:		cp 2 
5d64 20 02				jr nz, .c3 
5d66 cb 89				res 1, c 
5d68 fe 03		.c3:		cp 3 
5d6a 20 02				jr nz, .c4 
5d6c cb 91				res 2, c 
5d6e fe 04		.c4:		cp 4 
5d70 20 02				jr nz, .c5 
5d72 cb 99				res 3, c 
5d74 fe 05		.c5:		cp 5 
5d76 20 02				jr nz, .c6 
5d78 cb a1				res 4, c 
5d7a fe 06		.c6:		cp 6 
5d7c 20 02				jr nz, .c7 
5d7e cb a9				res 5, c 
5d80 fe 07		.c7:		cp 7 
5d82 20 02				jr nz, .c8 
5d84 cb b1				res 6, c 
5d86 fe 08		.c8:		cp 8 
5d88 20 02				jr nz, .cset 
5d8a cb b9				res 7, c 
5d8c 79			.cset:		ld a, c 
5d8d 32 9e f9				ld (spi_cartdev),a 
5d90			 
5d90					if DEBUG_FORTH_WORDS 
5d90						DMARK "CD2" 
5d90 f5				push af  
5d91 3a a5 5d			ld a, (.dmark)  
5d94 32 a6 fd			ld (debug_mark),a  
5d97 3a a6 5d			ld a, (.dmark+1)  
5d9a 32 a7 fd			ld (debug_mark+1),a  
5d9d 3a a7 5d			ld a, (.dmark+2)  
5da0 32 a8 fd			ld (debug_mark+2),a  
5da3 18 03			jr .pastdmark  
5da5 ..			.dmark: db "CD2"  
5da8 f1			.pastdmark: pop af  
5da9			endm  
# End of macro DMARK
5da9						CALLMONITOR 
5da9 cd aa fd			call debug_vector  
5dac				endm  
# End of macro CALLMONITOR
5dac					endif 
5dac			 
5dac					; set default SPI clk pulse time as 10ms for CARTDEV use 
5dac			 
5dac 3e 0a				ld a, $0a 
5dae 32 9f f9				ld (spi_clktime), a 
5db1					NEXTW 
5db1 c3 0f 26			jp macro_next 
5db4				endm 
# End of macro NEXTW
5db4			endif 
5db4			 
5db4			.ENDDEVICE: 
5db4			; eof 
5db4			 
# End of file forth_words_device.asm
5db4			 
5db4			; var handler 
5db4			 
5db4			 
5db4			.VARS: 
5db4				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5db4 77				db WORD_SYS_CORE+99             
5db5 65 5e			dw .V0            
5db7 04				db 3 + 1 
5db8 .. 00			db "VAR",0              
5dbc				endm 
# End of macro CWHEAD
5dbc			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5dbc			;| 
5dbc			;| The variable name should consist of a single letter. e.g. "a" 
5dbc			;! If a full string is passed then only the first char is looked at 
5dbc			;| Any other char could exceed bounds checks!  
5dbc			 
5dbc					if DEBUG_FORTH_WORDS_KEY 
5dbc						DMARK "VAR" 
5dbc f5				push af  
5dbd 3a d1 5d			ld a, (.dmark)  
5dc0 32 a6 fd			ld (debug_mark),a  
5dc3 3a d2 5d			ld a, (.dmark+1)  
5dc6 32 a7 fd			ld (debug_mark+1),a  
5dc9 3a d3 5d			ld a, (.dmark+2)  
5dcc 32 a8 fd			ld (debug_mark+2),a  
5dcf 18 03			jr .pastdmark  
5dd1 ..			.dmark: db "VAR"  
5dd4 f1			.pastdmark: pop af  
5dd5			endm  
# End of macro DMARK
5dd5						CALLMONITOR 
5dd5 cd aa fd			call debug_vector  
5dd8				endm  
# End of macro CALLMONITOR
5dd8					endif 
5dd8			 
5dd8					FORTH_DSP_VALUEHL 
5dd8 cd 59 24			call macro_dsp_valuehl 
5ddb				endm 
# End of macro FORTH_DSP_VALUEHL
5ddb			 
5ddb 7e					ld a, (hl)    ; get first char on of the string 
5ddc			 
5ddc			 
5ddc					if DEBUG_FORTH_WORDS 
5ddc						DMARK "VR1" 
5ddc f5				push af  
5ddd 3a f1 5d			ld a, (.dmark)  
5de0 32 a6 fd			ld (debug_mark),a  
5de3 3a f2 5d			ld a, (.dmark+1)  
5de6 32 a7 fd			ld (debug_mark+1),a  
5de9 3a f3 5d			ld a, (.dmark+2)  
5dec 32 a8 fd			ld (debug_mark+2),a  
5def 18 03			jr .pastdmark  
5df1 ..			.dmark: db "VR1"  
5df4 f1			.pastdmark: pop af  
5df5			endm  
# End of macro DMARK
5df5						CALLMONITOR 
5df5 cd aa fd			call debug_vector  
5df8				endm  
# End of macro CALLMONITOR
5df8					endif 
5df8					 
5df8 f5					push af	 
5df9					FORTH_DSP_POP 
5df9 cd 11 25			call macro_forth_dsp_pop 
5dfc				endm 
# End of macro FORTH_DSP_POP
5dfc f1					pop af 
5dfd			 
5dfd					; convert to upper 
5dfd			 
5dfd cd 9b 14				call to_upper 
5e00					if DEBUG_FORTH_WORDS 
5e00						DMARK "Vaa" 
5e00 f5				push af  
5e01 3a 15 5e			ld a, (.dmark)  
5e04 32 a6 fd			ld (debug_mark),a  
5e07 3a 16 5e			ld a, (.dmark+1)  
5e0a 32 a7 fd			ld (debug_mark+1),a  
5e0d 3a 17 5e			ld a, (.dmark+2)  
5e10 32 a8 fd			ld (debug_mark+2),a  
5e13 18 03			jr .pastdmark  
5e15 ..			.dmark: db "Vaa"  
5e18 f1			.pastdmark: pop af  
5e19			endm  
# End of macro DMARK
5e19						CALLMONITOR 
5e19 cd aa fd			call debug_vector  
5e1c				endm  
# End of macro CALLMONITOR
5e1c					endif 
5e1c 06 41				ld b, 'A' 
5e1e 90					sub b			; set offset 
5e1f					if DEBUG_FORTH_WORDS 
5e1f						DMARK "Vbb" 
5e1f f5				push af  
5e20 3a 34 5e			ld a, (.dmark)  
5e23 32 a6 fd			ld (debug_mark),a  
5e26 3a 35 5e			ld a, (.dmark+1)  
5e29 32 a7 fd			ld (debug_mark+1),a  
5e2c 3a 36 5e			ld a, (.dmark+2)  
5e2f 32 a8 fd			ld (debug_mark+2),a  
5e32 18 03			jr .pastdmark  
5e34 ..			.dmark: db "Vbb"  
5e37 f1			.pastdmark: pop af  
5e38			endm  
# End of macro DMARK
5e38						CALLMONITOR 
5e38 cd aa fd			call debug_vector  
5e3b				endm  
# End of macro CALLMONITOR
5e3b					endif 
5e3b cb 27				sla a  
5e3d				 
5e3d					 
5e3d					if DEBUG_FORTH_WORDS 
5e3d						DMARK "VR2" 
5e3d f5				push af  
5e3e 3a 52 5e			ld a, (.dmark)  
5e41 32 a6 fd			ld (debug_mark),a  
5e44 3a 53 5e			ld a, (.dmark+1)  
5e47 32 a7 fd			ld (debug_mark+1),a  
5e4a 3a 54 5e			ld a, (.dmark+2)  
5e4d 32 a8 fd			ld (debug_mark+2),a  
5e50 18 03			jr .pastdmark  
5e52 ..			.dmark: db "VR2"  
5e55 f1			.pastdmark: pop af  
5e56			endm  
# End of macro DMARK
5e56						CALLMONITOR 
5e56 cd aa fd			call debug_vector  
5e59				endm  
# End of macro CALLMONITOR
5e59					endif 
5e59			 
5e59 21 2f f9				ld hl, cli_var_array2 
5e5c cd cf 0f				call addatohl 
5e5f cd 62 22				call forth_push_numhl 
5e62			 
5e62			 
5e62				       NEXTW 
5e62 c3 0f 26			jp macro_next 
5e65				endm 
# End of macro NEXTW
5e65			.V0: 
5e65				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5e65 78				db WORD_SYS_CORE+100             
5e66 7d 5e			dw .V0Q            
5e68 04				db 3 + 1 
5e69 .. 00			db "V0!",0              
5e6d				endm 
# End of macro CWHEAD
5e6d			;| V0! ( u1 -- )  Store value to v0  | DONE 
5e6d			 
5e6d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e6d cd 59 24			call macro_dsp_valuehl 
5e70				endm 
# End of macro FORTH_DSP_VALUEHL
5e70			 
5e70 11 63 f9				ld de, cli_var_array 
5e73			 
5e73 eb					ex de, hl 
5e74 73					ld (hl), e 
5e75 23					inc hl 
5e76 72					ld (hl), d 
5e77			 
5e77					; destroy value TOS 
5e77			 
5e77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e77 cd 11 25			call macro_forth_dsp_pop 
5e7a				endm 
# End of macro FORTH_DSP_POP
5e7a			 
5e7a				       NEXTW 
5e7a c3 0f 26			jp macro_next 
5e7d				endm 
# End of macro NEXTW
5e7d			.V0Q: 
5e7d				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5e7d 79				db WORD_SYS_CORE+101             
5e7e 8e 5e			dw .V1S            
5e80 04				db 3 + 1 
5e81 .. 00			db "V0@",0              
5e85				endm 
# End of macro CWHEAD
5e85			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5e85 2a 63 f9				ld hl, (cli_var_array) 
5e88 cd 62 22				call forth_push_numhl 
5e8b			 
5e8b				       NEXTW 
5e8b c3 0f 26			jp macro_next 
5e8e				endm 
# End of macro NEXTW
5e8e			.V1S: 
5e8e				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5e8e 7a				db WORD_SYS_CORE+102             
5e8f a6 5e			dw .V1Q            
5e91 04				db 3 + 1 
5e92 .. 00			db "V1!",0              
5e96				endm 
# End of macro CWHEAD
5e96			;| V1! ( u1 -- )  Store value to v1 | DONE 
5e96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e96 cd 59 24			call macro_dsp_valuehl 
5e99				endm 
# End of macro FORTH_DSP_VALUEHL
5e99			 
5e99 11 65 f9				ld de, cli_var_array+2 
5e9c				 
5e9c eb					ex de, hl 
5e9d 73					ld (hl), e 
5e9e 23					inc hl 
5e9f 72					ld (hl), d 
5ea0			 
5ea0					; destroy value TOS 
5ea0			 
5ea0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ea0 cd 11 25			call macro_forth_dsp_pop 
5ea3				endm 
# End of macro FORTH_DSP_POP
5ea3				       NEXTW 
5ea3 c3 0f 26			jp macro_next 
5ea6				endm 
# End of macro NEXTW
5ea6			.V1Q: 
5ea6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5ea6 7b				db WORD_SYS_CORE+103             
5ea7 b7 5e			dw .V2S            
5ea9 04				db 3 + 1 
5eaa .. 00			db "V1@",0              
5eae				endm 
# End of macro CWHEAD
5eae			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5eae 2a 65 f9				ld hl, (cli_var_array+2) 
5eb1 cd 62 22				call forth_push_numhl 
5eb4				       NEXTW 
5eb4 c3 0f 26			jp macro_next 
5eb7				endm 
# End of macro NEXTW
5eb7			.V2S: 
5eb7				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5eb7 7c				db WORD_SYS_CORE+104             
5eb8 cf 5e			dw .V2Q            
5eba 04				db 3 + 1 
5ebb .. 00			db "V2!",0              
5ebf				endm 
# End of macro CWHEAD
5ebf			;| V2! ( u1 -- )  Store value to v2 | DONE 
5ebf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ebf cd 59 24			call macro_dsp_valuehl 
5ec2				endm 
# End of macro FORTH_DSP_VALUEHL
5ec2			 
5ec2 11 67 f9				ld de, cli_var_array+4 
5ec5				 
5ec5 eb					ex de, hl 
5ec6 73					ld (hl), e 
5ec7 23					inc hl 
5ec8 72					ld (hl), d 
5ec9			 
5ec9					; destroy value TOS 
5ec9			 
5ec9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ec9 cd 11 25			call macro_forth_dsp_pop 
5ecc				endm 
# End of macro FORTH_DSP_POP
5ecc				       NEXTW 
5ecc c3 0f 26			jp macro_next 
5ecf				endm 
# End of macro NEXTW
5ecf			.V2Q: 
5ecf				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5ecf 7d				db WORD_SYS_CORE+105             
5ed0 e0 5e			dw .V3S            
5ed2 04				db 3 + 1 
5ed3 .. 00			db "V2@",0              
5ed7				endm 
# End of macro CWHEAD
5ed7			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5ed7 2a 67 f9				ld hl, (cli_var_array+4) 
5eda cd 62 22				call forth_push_numhl 
5edd				       NEXTW 
5edd c3 0f 26			jp macro_next 
5ee0				endm 
# End of macro NEXTW
5ee0			.V3S: 
5ee0				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5ee0 7c				db WORD_SYS_CORE+104             
5ee1 f8 5e			dw .V3Q            
5ee3 04				db 3 + 1 
5ee4 .. 00			db "V3!",0              
5ee8				endm 
# End of macro CWHEAD
5ee8			;| V3! ( u1 -- )  Store value to v3 | DONE 
5ee8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ee8 cd 59 24			call macro_dsp_valuehl 
5eeb				endm 
# End of macro FORTH_DSP_VALUEHL
5eeb			 
5eeb 11 69 f9				ld de, cli_var_array+6 
5eee				 
5eee eb					ex de, hl 
5eef 73					ld (hl), e 
5ef0 23					inc hl 
5ef1 72					ld (hl), d 
5ef2			 
5ef2					; destroy value TOS 
5ef2			 
5ef2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ef2 cd 11 25			call macro_forth_dsp_pop 
5ef5				endm 
# End of macro FORTH_DSP_POP
5ef5				       NEXTW 
5ef5 c3 0f 26			jp macro_next 
5ef8				endm 
# End of macro NEXTW
5ef8			.V3Q: 
5ef8				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5ef8 7d				db WORD_SYS_CORE+105             
5ef9 09 5f			dw .END            
5efb 04				db 3 + 1 
5efc .. 00			db "V3@",0              
5f00				endm 
# End of macro CWHEAD
5f00			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5f00 2a 69 f9				ld hl, (cli_var_array+6) 
5f03 cd 62 22				call forth_push_numhl 
5f06				       NEXTW 
5f06 c3 0f 26			jp macro_next 
5f09				endm 
# End of macro NEXTW
5f09			 
5f09			 
5f09			 
5f09			 
5f09			 
5f09			; end of dict marker 
5f09			 
5f09 00			.END:    db WORD_SYS_END 
5f0a 00 00			dw 0 
5f0c 00				db 0 
5f0d			 
5f0d			; use to jp here for user dict words to save on macro expansion  
5f0d			 
5f0d			user_dict_next: 
5f0d				NEXTW 
5f0d c3 0f 26			jp macro_next 
5f10				endm 
# End of macro NEXTW
5f10			 
5f10			 
5f10			user_exec: 
5f10				;    ld hl, <word code> 
5f10				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5f10				;    call forthexec 
5f10				;    jp user_dict_next   (NEXT) 
5f10			        ;    <word code bytes> 
5f10 eb				ex de, hl 
5f11 2a fd f3			ld hl,(os_tok_ptr) 
5f14				 
5f14				FORTH_RSP_NEXT 
5f14 cd 09 22			call macro_forth_rsp_next 
5f17				endm 
# End of macro FORTH_RSP_NEXT
5f17			 
5f17			if DEBUG_FORTH_UWORD 
5f17						DMARK "UEX" 
5f17 f5				push af  
5f18 3a 2c 5f			ld a, (.dmark)  
5f1b 32 a6 fd			ld (debug_mark),a  
5f1e 3a 2d 5f			ld a, (.dmark+1)  
5f21 32 a7 fd			ld (debug_mark+1),a  
5f24 3a 2e 5f			ld a, (.dmark+2)  
5f27 32 a8 fd			ld (debug_mark+2),a  
5f2a 18 03			jr .pastdmark  
5f2c ..			.dmark: db "UEX"  
5f2f f1			.pastdmark: pop af  
5f30			endm  
# End of macro DMARK
5f30				CALLMONITOR 
5f30 cd aa fd			call debug_vector  
5f33				endm  
# End of macro CALLMONITOR
5f33			endif 
5f33			 
5f33			 
5f33			 
5f33 eb				ex de, hl 
5f34 22 fd f3			ld (os_tok_ptr), hl 
5f37				 
5f37				; Don't use next - Skips the first word in uword. 
5f37			 
5f37 c3 a0 26			jp exec1 
5f3a			;	NEXT 
5f3a			 
5f3a			 
5f3a			; eof 
# End of file forth_wordsv4.asm
5f3a			endif 
5f3a			;;;;;;;;;;;;;; Debug code 
5f3a			 
5f3a			 
5f3a			;if DEBUG_FORTH_PARSE 
5f3a .. 00		.nowordfound: db "No match",0 
5f43 .. 00		.compword:	db "Comparing word ",0 
5f53 .. 00		.nextwordat:	db "Next word at",0 
5f60 .. 00		.charmatch:	db "Char match",0 
5f6b			;endif 
5f6b			if DEBUG_FORTH_JP 
5f6b			.foundword:	db "Word match. Exec..",0 
5f6b			endif 
5f6b			;if DEBUG_FORTH_PUSH 
5f6b .. 00		.enddict:	db "Dict end. Push.",0 
5f7b .. 00		.push_str:	db "Pushing string",0 
5f8a .. 00		.push_num:	db "Pushing number",0 
5f99 .. 00		.data_sp:	db "SP:",0 
5f9d .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5faf .. 00		.wordinde:	db "Word in DE (3/0):",0 
5fc1 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5fd3			;endif 
5fd3			;if DEBUG_FORTH_MALLOC 
5fd3 .. 00		.push_malloc:	db "Malloc address",0 
5fe2			;endif 
5fe2			 
5fe2			 
5fe2			 
5fe2			; display malloc address and current data stack pointer  
5fe2			 
5fe2			malloc_error: 
5fe2 d5				push de 
5fe3 f5				push af 
5fe4 e5				push hl 
5fe5 cd 9b 0d			call clear_display 
5fe8 11 08 60			ld de, .mallocerr 
5feb 3e 00			ld a,0 
5fed			;	ld de,os_word_scratch 
5fed cd ae 0d			call str_at_display 
5ff0 3e 11			ld a, display_row_1+17 
5ff2 11 a6 fd			ld de, debug_mark 
5ff5 cd ae 0d			call str_at_display 
5ff8 cd be 0d			call update_display 
5ffb				;call break_point_state 
5ffb cd cb 7b			call cin_wait 
5ffe			 
5ffe			;	ld a, ' ' 
5ffe			;	ld (os_view_disable), a 
5ffe cd 94 1b			call bp_on 
6001 e1				pop hl 
6002 f1				pop af 
6003 d1				pop de	 
6004				CALLMONITOR 
6004 cd aa fd			call debug_vector  
6007				endm  
# End of macro CALLMONITOR
6007 c9				ret 
6008			 
6008 .. 00		.mallocerr: 	db "Malloc Error",0 
6015			;if DEBUG_FORTH_PUSH 
6015			display_data_sp: 
6015 f5				push af 
6016			 
6016				; see if disabled 
6016			 
6016			 
6016 3a aa fd			ld a, (debug_vector) 
6019 fe c9			cp $C9  ; RET 
601b				;ld a, (os_view_disable) 
601b				;cp '*' 
601b 28 67			jr z, .skipdsp 
601d			 
601d e5				push hl 
601e e5				push hl 
601f e5			push hl 
6020 cd 9b 0d			call clear_display 
6023 e1			pop hl 
6024 7c				ld a,h 
6025 21 01 f4			ld hl, os_word_scratch 
6028 cd 2f 14			call hexout 
602b e1				pop hl 
602c 7d				ld a,l 
602d 21 03 f4			ld hl, os_word_scratch+2 
6030 cd 2f 14			call hexout 
6033 21 05 f4			ld hl, os_word_scratch+4 
6036 3e 00			ld a,0 
6038 77				ld (hl),a 
6039 11 01 f4			ld de,os_word_scratch 
603c 3e 28				ld a, display_row_2 
603e cd ae 0d				call str_at_display 
6041 11 9d 5f			ld de, .wordinhl 
6044 3e 00			ld a, display_row_1 
6046			 
6046 cd ae 0d				call str_at_display 
6049 11 a6 fd			ld de, debug_mark 
604c 3e 11			ld a, display_row_1+17 
604e			 
604e cd ae 0d				call str_at_display 
6051			 
6051				; display current data stack pointer 
6051 11 99 5f			ld de,.data_sp 
6054 3e 30				ld a, display_row_2 + 8 
6056 cd ae 0d				call str_at_display 
6059			 
6059 2a 29 f9			ld hl,(cli_data_sp) 
605c e5				push hl 
605d 7c				ld a,h 
605e 21 01 f4			ld hl, os_word_scratch 
6061 cd 2f 14			call hexout 
6064 e1				pop hl 
6065 7d				ld a,l 
6066 21 03 f4			ld hl, os_word_scratch+2 
6069 cd 2f 14			call hexout 
606c 21 05 f4			ld hl, os_word_scratch+4 
606f 3e 00			ld a,0 
6071 77				ld (hl),a 
6072 11 01 f4			ld de,os_word_scratch 
6075 3e 33				ld a, display_row_2 + 11 
6077 cd ae 0d				call str_at_display 
607a			 
607a			 
607a cd be 0d			call update_display 
607d cd de 0c			call delay1s 
6080 cd de 0c			call delay1s 
6083 e1				pop hl 
6084			.skipdsp: 
6084 f1				pop af 
6085 c9				ret 
6086			 
6086			display_data_malloc: 
6086			 
6086 f5				push af 
6087 e5				push hl 
6088 e5				push hl 
6089 e5			push hl 
608a cd 9b 0d			call clear_display 
608d e1			pop hl 
608e 7c				ld a,h 
608f 21 01 f4			ld hl, os_word_scratch 
6092 cd 2f 14			call hexout 
6095 e1				pop hl 
6096 7d				ld a,l 
6097 21 03 f4			ld hl, os_word_scratch+2 
609a cd 2f 14			call hexout 
609d 21 05 f4			ld hl, os_word_scratch+4 
60a0 3e 00			ld a,0 
60a2 77				ld (hl),a 
60a3 11 01 f4			ld de,os_word_scratch 
60a6 3e 28				ld a, display_row_2 
60a8 cd ae 0d				call str_at_display 
60ab 11 d3 5f			ld de, .push_malloc 
60ae 3e 00			ld a, display_row_1 
60b0			 
60b0 cd ae 0d				call str_at_display 
60b3			 
60b3				; display current data stack pointer 
60b3 11 99 5f			ld de,.data_sp 
60b6 3e 30				ld a, display_row_2 + 8 
60b8 cd ae 0d				call str_at_display 
60bb			 
60bb 2a 29 f9			ld hl,(cli_data_sp) 
60be e5				push hl 
60bf 7c				ld a,h 
60c0 21 01 f4			ld hl, os_word_scratch 
60c3 cd 2f 14			call hexout 
60c6 e1				pop hl 
60c7 7d				ld a,l 
60c8 21 03 f4			ld hl, os_word_scratch+2 
60cb cd 2f 14			call hexout 
60ce 21 05 f4			ld hl, os_word_scratch+4 
60d1 3e 00			ld a,0 
60d3 77				ld (hl),a 
60d4 11 01 f4			ld de,os_word_scratch 
60d7 3e 33				ld a, display_row_2 + 11 
60d9 cd ae 0d				call str_at_display 
60dc			 
60dc cd be 0d			call update_display 
60df cd de 0c			call delay1s 
60e2 cd de 0c			call delay1s 
60e5 e1				pop hl 
60e6 f1				pop af 
60e7 c9				ret 
60e8			;endif 
60e8			 
60e8			include "forth_autostart.asm" 
60e8			; list of commands to perform at system start up 
60e8			 
60e8			startcmds: 
60e8			;	dw test11 
60e8			;	dw test12 
60e8			;	dw test13 
60e8			;	dw test14 
60e8			;	dw test15 
60e8			;	dw test16 
60e8			;	dw test17 
60e8			;	dw ifthtest1 
60e8			;	dw ifthtest2 
60e8			;	dw ifthtest3 
60e8			;	dw mmtest1 
60e8			;	dw mmtest2 
60e8			;	dw mmtest3 
60e8			;	dw mmtest4 
60e8			;	dw mmtest5 
60e8			;	dw mmtest6 
60e8			;	dw iftest1 
60e8			;	dw iftest2 
60e8			;	dw iftest3 
60e8			;	dw looptest1 
60e8			;	dw looptest2 
60e8			;	dw test1 
60e8			;	dw test2 
60e8			;	dw test3 
60e8			;	dw test4 
60e8			;	dw game2r 
60e8			;	dw game2b1 
60e8			;	dw game2b2 
60e8			 
60e8				; start up words that are actually useful 
60e8			 
60e8			;    dw spi1 
60e8			;    dw spi2 
60e8			;    dw spi3 
60e8			;    dw spi4 
60e8			;    dw spi5 
60e8			;    dw spi6 
60e8			;    dw spi7 
60e8			; 
60e8			;    dw spi8 
60e8			;    dw spi9 
60e8			;    dw spi10 
60e8			 
60e8			; file editor 
60e8			;	dw edit1 
60e8			;	dw edit2 
60e8			;	dw edit3 
60e8			 
60e8			;	dw longread 
60e8 12 65			dw clrstack 
60ea 46 65			dw type 
60ec			;	dw stest 
60ec 6b 65			dw strncpy 
60ee			;	dw list 
60ee cc 65			dw start1 
60f0 dc 65			dw start2 
60f2			;	dw start3 
60f2			;	dw start3b 
60f2			;	dw start3c 
60f2			 
60f2				; (unit) testing words 
60f2			 
60f2			;	dw mtesta 
60f2			;	dw mtestb 
60f2			;	dw mtestc 
60f2			;	dw mtestd 
60f2			;	dw mteste 
60f2			 
60f2				; demo/game words 
60f2			 
60f2			;        dw game3w 
60f2			;        dw game3p 
60f2			;        dw game3sc 
60f2			;        dw game3vsi 
60f2			;        dw game3vs 
60f2				 
60f2 35 70			dw game2b 
60f4 a3 70			dw game2bf 
60f6 ed 70			dw game2mba 
60f8 83 71			dw game2mbas 
60fa c5 71			dw game2mb 
60fc			 
60fc f6 6c			dw game1 
60fe 07 6d			dw game1a 
6100 69 6d			dw game1b 
6102 9e 6d			dw game1c 
6104 d4 6d			dw game1d 
6106 05 6e			dw game1s 
6108 19 6e			dw game1t 
610a 2e 6e			dw game1f 
610c 62 6e			dw game1z 
610e a6 6e			dw game1zz 
6110			 
6110 10 6b			dw test5 
6112 48 6b			dw test6 
6114 80 6b			dw test7 
6116 94 6b			dw test8 
6118 c0 6b			dw test9 
611a d6 6b			dw test10 
611c				 
611c 7d 6f		        dw ssv5 
611e 61 6f		        dw ssv4 
6120 45 6f		        dw ssv3 
6122 0f 6f		        dw ssv2 
6124 96 6f		        dw ssv1 
6126 de 6f		        dw ssv1cpm 
6128			;	dw keyup 
6128			;	dw keydown 
6128			;	dw keyleft 
6128			;	dw keyright 
6128			;	dw 	keyf1 
6128			;	dw keyf2 
6128			;	dw keyf3 
6128			;	dw keyf4 
6128			;	dw keyf5 
6128			;	dw keyf6 
6128			;	dw keyf7 
6128			;	dw keyf8 
6128			;	dw keyf9 
6128			;	dw keyf10 
6128			;	dw keyf11 
6128			;	dw keyf12 
6128			;	dw keytab 
6128			;	dw keycr 
6128			;	dw keyhome 
6128			;	dw keyend 
6128			;	dw keybs 
6128 00 00			db 0, 0	 
612a			 
612a			 
612a			; File Editor 
612a			 
612a			; ( id - ) use 'e' to edit the displayed line 
612a .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
614b .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6180			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
6180 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
61b8			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
61b8			 
61b8			; SPI Net support words 
61b8			 
61b8			; v0! = node to send to 
61b8			; ( str count - ) 
61b8 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6211			 
6211			; spiputc ( char node - ) 
6211 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
6245			; spiputc ( u node - ) 
6245 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6273			 
6273			; spigetc ( - n ) 
6273 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
629c			 
629c			; getnode ( - n ) 
629c .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
62c9			 
62c9			; ( str node - )  
62c9 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
632f			; store string ( str i - ) 
632f			 
632f			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
632f .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6384			 
6384			; get string ( addr i -  )    TO FIX 
6384			 
6384 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
63dc			 
63dc			 
63dc			; NETCHAT (TODO) 
63dc			; Program to allow two nodes to chat with eachother 
63dc			; 
63dc			; v0 - target node 
63dc			;  
63dc			; accept input at 0,0 
63dc			; if input is string send spitype to target node 
63dc			; starting at row 2,0 , while spigetchr is not zero ->  
63dc			; 
63dc			; 
63dc			; TODO add paging of get request 
63dc			 
63dc			; ( node - ) 
63dc .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
63fb .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6453 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
64cb			 
64cb			 
64cb			; Long read of currently open file 
64cb .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6512			 
6512			; clear stack  
6512			 
6512 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6546			 
6546			; type ( addr count - ) 
6546 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
656b			 
656b			; some direct memory words 
656b			; strncpy ( len t f -- t ) 
656b			 
656b .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
65cc			 
65cc .. 00		start1:     	db ": bpon $00 bp ;",0 
65dc .. 00		start2:     	db ": bpoff $01 bp ;",0 
65ed .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6668 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
66c8			 
66c8			 
66c8			; a handy word to list items on the stack 
66c8			 
66c8 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6732			 
6732			 
6732			; test stack  
6732			; rnd8 stest 
6732			 
6732 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
67a9			 
67a9			; random malloc and free cycles 
67a9			 
67a9 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
685e			 
685e			; fixed malloc and free cycles 
685e			 
685e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6901			 
6901			; fixed double string push and drop cycle  
6901			 
6901 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
69b6			 
69b6			; consistent fixed string push and drop cycle  
69b6			 
69b6 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6a5a			 
6a5a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6b10			 
6b10			;test1:		db ": aa 1 2 3 ;", 0 
6b10			;test2:     	db "111 aa 888 999",0 
6b10			;test3:     	db ": bb 77 ;",0 
6b10			;test4:     	db "$02 $01 do i . loop bb",0 
6b10			 
6b10 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6b48 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6b80 .. 00		test7:     	db ": box hline vline ;",0 
6b94 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6bc0 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6bd6 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6bfb .. 00		test11:     	db "hello create .",0 
6c0a .. 00		test12:     	db "hello2 create .",0 
6c1a			 
6c1a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6c1a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6c1a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6c1a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6c1a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6c1a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6c1a			 
6c1a			;iftest1:     	db "$0001 IF cls .",0 
6c1a			;iftest2:     	db "$0000 IF cls .",0 
6c1a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6c1a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6c1a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6c1a			 
6c1a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6c1a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6c1a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6c1a			 
6c1a			 
6c1a .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6c3e .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6c6e .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6c93 .. 00		sound4: db ": cha $00 ; ",0 
6ca0 .. 00		sound5: db ": chb $20 ; ",0 
6cad .. 00		sound6: db ": chc $40 ; ",0 
6cba .. 00		sound7: db ": chd $60 ; ",0 
6cc7 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6cdf .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6cf6			 
6cf6			 
6cf6			 
6cf6			 
6cf6			; a small guess the number game 
6cf6			 
6cf6 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6d07 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6d69			 
6d69 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6d9e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6dd4 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6e05 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6e19 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6e2e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6e62 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6ea6			 
6ea6			; Using 'ga' save a high score across multiple runs using external storage 
6ea6			 
6ea6 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6f0f			 
6f0f			 
6f0f			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6f0f			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6f0f			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6f0f			 
6f0f			; simple screen saver to test code memory reuse to destruction 
6f0f			 
6f0f .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6f45 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6f61 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6f7d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6f96 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6fde .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
7035			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
7035			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
7035			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
7035			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
7035			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
7035			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
7035			 
7035			 
7035			 
7035			; minesweeper/battleship finding game 
7035			; draws a game board of random ship/mine positions 
7035			; user enters coords to see if it hits on 
7035			; game ends when all are hit 
7035			; when hit or miss says how many may be in the area 
7035			 
7035			; setup the game board and then hide it 
7035 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
70a3 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
70ed			; prompt for where to target 
70ed .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
7183 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
71a8			; TODO see if the entered coords hits or misses pushes char hit of miss 
71a8 .. 00		game2mbht:      db ": mbckht nop ;",0 
71b7 .. 00		game2mbms:      db ": mbcms nop ;",0 
71c5			; TODO how many might be near by 
71c5 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
7242			 
7242			; Game 3 
7242			 
7242			; Vert scroller ski game - avoid the trees! 
7242			 
7242			; v0 score (ie turns) 
7242			; v1 player pos 
7242			; v2 left wall 
7242			; v3 right wall 
7242			 
7242			; Draw side walls randomly 
7242			 
7242 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7270			 
7270			; Draw player 
7270 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
728e			 
728e			; TODO Get Key 
728e			 
728e			; TODO Move left right 
728e			 
728e			; scroll and move walls a bit 
728e			 
728e .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
72bf			 
72bf			; main game loop 
72bf			 
72bf .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
72eb .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
732a			 
732a			; key board defs 
732a			 
732a .. 00		keyup:       db ": keyup $05 ;",0 
7338 .. 00		keydown:       db ": keydown $0a ;",0 
7348 .. 00		keyleft:       db ": keyleft $0b ;",0 
7358 .. 00		keyright:       db ": keyright $0c ;",0 
7369 .. 00		keyf1:       db ": keyf1 $10 ;",0 
7377 .. 00		keyf2:       db ": keyf2 $11 ;",0 
7385 .. 00		keyf3:       db ": keyf3 $12 ;",0 
7393 .. 00		keyf4:       db ": keyf4 $13 ;",0 
73a1 .. 00		keyf5:       db ": keyf5 $14 ;",0 
73af .. 00		keyf6:       db ": keyf6 $15 ;",0 
73bd .. 00		keyf7:       db ": keyf7 $16 ;",0 
73cb .. 00		keyf8:       db ": keyf8 $17 ;",0 
73d9 .. 00		keyf9:       db ": keyf9 $18 ;",0 
73e7 .. 00		keyf10:       db ": keyf10 $19 ;",0 
73f6 .. 00		keyf11:       db ": keyf11 $1a ;",0 
7405 .. 00		keyf12:       db ": keyf12 $1b ;",0 
7414			 
7414 .. 00		keytab:       db ": keytab $09 ;",0 
7423 .. 00		keycr:       db ": keycr $0d ;",0 
7431 .. 00		keyhome:       db ": keyhome $0e ;",0 
7441 .. 00		keyend:       db ": keyend $0f ;",0 
7450 .. 00		keybs:       db ": keybs $08 ;",0 
745e			 
745e			   
745e			 
745e			 
745e			 
745e			; eof 
# End of file forth_autostart.asm
745e			 
745e			 
745e			 
745e			; stack over and underflow checks 
745e			 
745e			; init the words to detect the under/overflow 
745e			 
745e			chk_stk_init: 
745e				; a vague random number to check so we dont get any "lucky" hits 
745e 3e 2d			ld a, 45 
7460 6f				ld l, a 
7461 00				nop 
7462 3e 17			ld a, 23 
7464 67				ld h, a 
7465			 
7465 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
7468			 
7468			;	ld (chk_stund), hl	; stack points.... 
7468 22 3b fe			ld (chk_stovr), hl 
746b 22 27 f9			ld (chk_ret_und), hl 
746e 22 e5 f8			ld (chk_ret_ovr), hl 
7471 22 63 f8			ld (chk_loop_ovr), hl 
7474 22 61 f6			ld (chk_data_ovr), hl 
7477 c9				ret 
7478				 
7478			check_stacks: 
7478				; check all stack words 
7478			 
7478 e5				push hl 
7479 d5				push de 
747a			 
747a			;	ld de,(chk_word) 
747a			;	ld hl, (chk_stund)	; stack points.... 
747a			;	if DEBUG_STK_FAULT 
747a			;		DMARK "FAa" 
747a			;		CALLMONITOR 
747a			;	endif 
747a			;	call cmp16 
747a			;	jp z, .chk_faulta 
747a			; 
747a			;	ld de, sfaultsu 
747a			;	jp .chk_fault 
747a			 
747a 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
747d ed 5b d8 f0		ld de,(chk_word) 
7481				if DEBUG_STK_FAULT 
7481					DMARK "FAb" 
7481					CALLMONITOR 
7481				endif 
7481 cd ed 0f			call cmp16 
7484 28 06			jr z, .chk_fault1 
7486 11 27 75			ld de, sfaultso 
7489 c3 db 74			jp .chk_fault 
748c			.chk_fault1:  
748c 2a 27 f9			ld hl, (chk_ret_und) 
748f ed 5b d8 f0		ld de,(chk_word) 
7493				if DEBUG_STK_FAULT 
7493					DMARK "FAU" 
7493					CALLMONITOR 
7493				endif 
7493 cd ed 0f			call cmp16 
7496 ca 9f 74			jp z, .chk_fault2 
7499 11 37 75			ld de, sfaultru 
749c c3 db 74			jp .chk_fault 
749f			.chk_fault2:  
749f 2a e5 f8			ld hl, (chk_ret_ovr) 
74a2 ed 5b d8 f0		ld de,(chk_word) 
74a6				if DEBUG_STK_FAULT 
74a6					DMARK "FA1" 
74a6					CALLMONITOR 
74a6				endif 
74a6 cd ed 0f			call cmp16 
74a9 ca b2 74			jp z, .chk_fault3 
74ac 11 45 75			ld de, sfaultro 
74af c3 db 74			jp .chk_fault 
74b2			.chk_fault3:  
74b2 2a 63 f8			ld hl, (chk_loop_ovr) 
74b5 ed 5b d8 f0		ld de,(chk_word) 
74b9				if DEBUG_STK_FAULT 
74b9					DMARK "FA2" 
74b9					CALLMONITOR 
74b9				endif 
74b9 cd ed 0f			call cmp16 
74bc ca c5 74			jp z, .chk_fault4 
74bf 11 5f 75			ld de, sfaultlo 
74c2 c3 db 74			jp .chk_fault 
74c5			.chk_fault4:  
74c5 2a 61 f6			ld hl, (chk_data_ovr) 
74c8 ed 5b d8 f0		ld de,(chk_word) 
74cc				if DEBUG_STK_FAULT 
74cc					DMARK "FA3" 
74cc					CALLMONITOR 
74cc				endif 
74cc cd ed 0f			call cmp16 
74cf ca d8 74			jp z, .chk_fault5 
74d2 11 79 75			ld de, sfaultdo 
74d5 c3 db 74			jp .chk_fault 
74d8			 
74d8			 
74d8			.chk_fault5:  
74d8 d1				pop de 
74d9 e1				pop hl 
74da			 
74da c9				ret 
74db			 
74db cd 9b 0d		.chk_fault: 	call clear_display 
74de 3e 28				ld a, display_row_2 
74e0 cd ae 0d				call str_at_display 
74e3 11 09 75				   ld de, .stackfault 
74e6 3e 00				ld a, display_row_1 
74e8 cd ae 0d				call str_at_display 
74eb 11 a6 fd				    ld de, debug_mark 
74ee 3e 11				ld a, display_row_1+17 
74f0 cd ae 0d				call str_at_display 
74f3 cd be 0d				call update_display 
74f6			 
74f6				; prompt before entering montior for investigating issue 
74f6			 
74f6 3e 78			ld a, display_row_4 
74f8 11 54 1f			ld de, endprog 
74fb			 
74fb cd be 0d			call update_display		 
74fe			 
74fe cd da 21			call next_page_prompt 
7501			 
7501 d1				pop de 
7502 e1				pop hl 
7503 cd a8 1f				call monitor 
7506 c3 b1 1e				jp warmstart 
7509					;jp 0 
7509					;halt 
7509			 
7509			 
7509			 
7509 .. 00		.stackfault: 	db "Stack fault:",0 
7516			 
7516 .. 00		sfaultsu: 	db	"Stack under flow",0 
7527 .. 00		sfaultso: 	db	"Stack over flow",0 
7537 .. 00		sfaultru:	db "RTS underflow",0 
7545 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
755f .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7579 .. 00		sfaultdo:	db "DTS overflow", 0 
7586			 
7586			 
7586			fault_dsp_under: 
7586 11 98 75			ld de, .dsp_under 
7589 c3 48 76			jp .show_fault 
758c			 
758c			fault_rsp_under: 
758c 11 a6 75			ld de, .rsp_under 
758f c3 48 76			jp .show_fault 
7592			fault_loop_under: 
7592 11 b4 75			ld de, .loop_under 
7595 c3 48 76			jp .show_fault 
7598			 
7598 .. 00		.dsp_under: db "DSP Underflow",0 
75a6 .. 00		.rsp_under: db "RSP Underflow",0 
75b4 .. 00		.loop_under: db "LOOP Underflow",0 
75c3			 
75c3			 
75c3 d5			type_faultn: 	push de 
75c4 e5					push hl 
75c5 cd 9b 0d				call clear_display 
75c8 11 ef 75				   ld de, .typefaultn 
75cb 3e 00				ld a, display_row_1 
75cd cd ae 0d				call str_at_display 
75d0 11 a6 fd				    ld de, debug_mark 
75d3 3e 11				ld a, display_row_1+17 
75d5 cd ae 0d				call str_at_display 
75d8 cd be 0d				call update_display 
75db			 
75db				; prompt before entering montior for investigating issue 
75db			 
75db 3e 78			ld a, display_row_4 
75dd 11 54 1f			ld de, endprog 
75e0			 
75e0 cd be 0d			call update_display		 
75e3			 
75e3 cd da 21			call next_page_prompt 
75e6			 
75e6 e5					push hl 
75e7 d5					push de 
75e8 cd a8 1f				call monitor 
75eb c3 b1 1e				jp warmstart 
75ee 76					halt 
75ef			 
75ef			 
75ef .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7606			 
7606 d5			type_faults: 	push de 
7607 e5					push hl 
7608 cd 9b 0d				call clear_display 
760b 11 31 76				   ld de, .typefaults 
760e 3e 00				ld a, display_row_1 
7610 cd ae 0d				call str_at_display 
7613 11 a6 fd				    ld de, debug_mark 
7616 3e 11				ld a, display_row_1+17 
7618 cd ae 0d				call str_at_display 
761b cd be 0d				call update_display 
761e			 
761e				; prompt before entering montior for investigating issue 
761e			 
761e 3e 78			ld a, display_row_4 
7620 11 54 1f			ld de, endprog 
7623			 
7623 cd be 0d			call update_display		 
7626			 
7626 cd da 21			call next_page_prompt 
7629			 
7629 e1					pop hl 
762a d1					pop de 
762b cd a8 1f				call monitor 
762e c3 b1 1e				jp warmstart 
7631			 
7631			 
7631 .. 00		.typefaults: db "STR Type Expected TOS!",0 
7648			 
7648			.show_fault: 	 
7648 d5					push de 
7649 cd 9b 0d				call clear_display 
764c d1					pop de 
764d 3e 00				ld a, display_row_1 
764f cd ae 0d				call str_at_display 
7652 11 a6 fd				    ld de, debug_mark 
7655 3e 11				ld a, display_row_1+17 
7657 cd ae 0d				call str_at_display 
765a cd be 0d				call update_display 
765d			 
765d				; prompt before entering montior for investigating issue 
765d			 
765d 3e 78			ld a, display_row_4 
765f 11 54 1f			ld de, endprog 
7662			 
7662 cd be 0d			call update_display		 
7665			 
7665 cd da 21			call next_page_prompt 
7668			 
7668 e1					pop hl 
7669 d1					pop de 
766a cd a8 1f				call monitor 
766d			; do a dump to cli and not warmstart so we preserve all of the uwords.  
766d			; TODO Make optional fault restart to cli or warm boot? 
766d					;jp warmstart 
766d c3 fb 1e				jp cli 
7670 76					halt 
7671			 
7671			; handle the auto run of code from files in storage 
7671			 
7671			 
7671			include "forth_startup.asm" 
7671			; Which startup method to use? 
7671			; 
7671			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7671			; followed by loading of a list of scripts in eeprom 
7671			 
7671			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7671			; from eeprom 
7671			 
7671			; Select with define in main stubs 
7671			 
7671			if STARTUP_V1 
7671				include "forth_startupv1.asm" 
7671			endif 
7671			if STARTUP_V2 
7671				include "forth_startupv2.asm" 
7671			; Version 2 of the startup  
7671			;  
7671			; Auto load any files in bank 1 that start with a '*' 
7671			; If no se storage then revert to using eprom 
7671			 
7671			 
7671			if STORAGE_SE = 0 
7671			 
7671			sprompt1: db "Startup load...",0 
7671			sprompt2: db "Run? 1=No *=End #=All",0 
7671			 
7671			 
7671			 
7671			 
7671			forth_startup: 
7671				ld hl, startcmds 
7671				ld a, 0 
7671				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7671			 
7671			.start1:	push hl 
7671				call clear_display 
7671				ld de, sprompt1 
7671			        ld a, display_row_1 
7671				call str_at_display 
7671				ld de, sprompt2 
7671			        ld a, display_row_2 
7671				call str_at_display 
7671				pop hl 
7671				push hl 
7671				ld e,(hl) 
7671				inc hl 
7671				ld d,(hl) 
7671			        ld a, display_row_3 
7671				call str_at_display 
7671				call update_display 
7671			 
7671			 
7671				ld a, (os_last_cmd) 
7671				cp 0 
7671				jr z, .startprompt 
7671				call delay250ms 
7671				jr .startdo 
7671				 
7671				 
7671			 
7671			.startprompt: 
7671			 
7671				ld a,display_row_4 + display_cols - 1 
7671			        ld de, endprg 
7671				call str_at_display 
7671				call update_display 
7671				call delay1s 
7671				call cin_wait 
7671						 
7671				cp '*' 
7671				jr z, .startupend1 
7671				cp '#' 
7671				jr nz, .startno 
7671				ld a, 1 
7671				ld (os_last_cmd),a 
7671				jr .startdo 
7671			.startno:	cp '1' 
7671				jr z,.startnxt  
7671			 
7671				; exec startup line 
7671			.startdo:	 
7671				pop hl 
7671				push hl 
7671				 
7671				ld e,(hl) 
7671				inc hl 
7671				ld d,(hl) 
7671				ex de,hl 
7671			 
7671				push hl 
7671			 
7671				ld a, 0 
7671				;ld a, FORTH_END_BUFFER 
7671				call strlent 
7671				inc hl   ; include zero term to copy 
7671				ld b,0 
7671				ld c,l 
7671				pop hl 
7671				ld de, scratch 
7671				ldir 
7671			 
7671			 
7671				ld hl, scratch 
7671				call forthparse 
7671				call forthexec 
7671				call forthexec_cleanup 
7671			 
7671				ld a, display_row_4 
7671				ld de, endprog 
7671			 
7671				call update_display		 
7671			 
7671				ld a, (os_last_cmd) 
7671				cp 0 
7671				jr nz, .startnxt 
7671				call next_page_prompt 
7671			        call clear_display 
7671				call update_display		 
7671			 
7671				; move onto next startup line? 
7671			.startnxt: 
7671			 
7671				call delay250ms 
7671				pop hl 
7671			 
7671				inc hl 
7671				inc hl 
7671			 
7671				push hl 
7671				ld e, (hl) 
7671				inc hl 
7671				ld d, (hl) 
7671				pop hl 
7671				; TODO replace 0 test 
7671			 
7671				ex de, hl 
7671				call ishlzero 
7671			;	ld a,e 
7671			;	add d 
7671			;	cp 0    ; any left to do? 
7671				ex de, hl 
7671				jp nz, .start1 
7671				jr .startupend 
7671			 
7671			.startupend1: pop hl 
7671			.startupend: 
7671			 
7671				call clear_display 
7671				call update_display 
7671				ret 
7671			endif 
7671			 
7671			 
7671			if STORAGE_SE 
7671			 
7671			;sprompt3: db "Loading from start-up file:",0 
7671 .. 00		sprompt3: db "  Searching...",0 
7680			;sprompt4: db "(Any key to stop)",0 
7680			 
7680			 
7680			forth_autoload: 
7680			 
7680				; load block 0 of store 1 
7680				 
7680 3e fe			ld a, $fe      ; bit 0 clear 
7682 32 9b f9			ld (spi_device), a 
7685			 
7685 cd 16 05			call storage_get_block_0 
7688			 
7688 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
768b			 
768b fe 00			cp 0 
768d c8				ret z     ; auto start not enabled 
768e			 
768e cd 9b 0d			call clear_display 
7691			 
7691				; set bank 
7691			 
7691 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
7694 32 9b f9				ld (spi_device), a 
7697			 
7697			 
7697				; generate a directory of bank 1 and search for flagged files 
7697			 
7697					if DEBUG_FORTH_WORDS_KEY 
7697						DMARK "DIR" 
7697 f5				push af  
7698 3a ac 76			ld a, (.dmark)  
769b 32 a6 fd			ld (debug_mark),a  
769e 3a ad 76			ld a, (.dmark+1)  
76a1 32 a7 fd			ld (debug_mark+1),a  
76a4 3a ae 76			ld a, (.dmark+2)  
76a7 32 a8 fd			ld (debug_mark+2),a  
76aa 18 03			jr .pastdmark  
76ac ..			.dmark: db "DIR"  
76af f1			.pastdmark: pop af  
76b0			endm  
# End of macro DMARK
76b0						CALLMONITOR 
76b0 cd aa fd			call debug_vector  
76b3				endm  
# End of macro CALLMONITOR
76b3					endif 
76b3			 
76b3 cd 16 05			call storage_get_block_0 
76b6			 
76b6 21 b5 f9			ld hl, store_page     ; get current id count 
76b9 46				ld b, (hl) 
76ba 0e 00			ld c, 0    ; count of files   
76bc					if DEBUG_FORTH_WORDS 
76bc						DMARK "DI1" 
76bc f5				push af  
76bd 3a d1 76			ld a, (.dmark)  
76c0 32 a6 fd			ld (debug_mark),a  
76c3 3a d2 76			ld a, (.dmark+1)  
76c6 32 a7 fd			ld (debug_mark+1),a  
76c9 3a d3 76			ld a, (.dmark+2)  
76cc 32 a8 fd			ld (debug_mark+2),a  
76cf 18 03			jr .pastdmark  
76d1 ..			.dmark: db "DI1"  
76d4 f1			.pastdmark: pop af  
76d5			endm  
# End of macro DMARK
76d5						CALLMONITOR 
76d5 cd aa fd			call debug_vector  
76d8				endm  
# End of macro CALLMONITOR
76d8					endif 
76d8			 
76d8				; check for empty drive 
76d8			 
76d8 3e 00			ld a, 0 
76da b8				cp b 
76db ca 28 77			jp z, .dirdone 
76de			 
76de				; for each of the current ids do a search for them and if found push to stack 
76de			 
76de c5			.diritem:	push bc 
76df 21 40 00				ld hl, STORE_BLOCK_PHY 
76e2 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
76e4 58					ld e,b 
76e5			 
76e5 d5					push de 
76e6 e5					push hl 
76e7 cd 9b 0d			call clear_display 
76ea 3e 32			ld a, display_row_2 + 10 
76ec 11 71 76			ld de, sprompt3 
76ef cd ae 0d			call str_at_display 
76f2 cd f2 0c			call active 
76f5 eb				ex de, hl 
76f6 3e 2f			ld a, display_row_2 + 7 
76f8 cd ae 0d			call str_at_display 
76fb cd be 0d			call update_display 
76fe e1				pop hl 
76ff d1				pop de 
7700			 
7700			;		if DEBUG_FORTH_WORDS 
7700			;			DMARK "DI2" 
7700			;			CALLMONITOR 
7700			;		endif 
7700			 
7700 cd 98 07				call storage_findnextid 
7703			 
7703			;		if DEBUG_FORTH_WORDS 
7703			;			DMARK "DI3" 
7703			;			CALLMONITOR 
7703			;		endif 
7703			 
7703					; if found hl will be non zero 
7703			 
7703 cd f8 0f				call ishlzero 
7706			;		ld a, l 
7706			;		add h 
7706			; 
7706			;		cp 0 
7706 28 1d				jr z, .dirnotfound 
7708			 
7708					; increase count 
7708			 
7708 c1					pop bc	 
7709 0c					inc c 
770a c5					push bc 
770b					 
770b			 
770b					; get file header and push the file name 
770b			 
770b 11 b5 f9				ld de, store_page 
770e cd 65 04				call storage_read_block 
7711			 
7711					; push file id to stack 
7711				 
7711			 
7711					; is this a file we want to run? 
7711			 
7711 21 b8 f9				ld hl, store_page+3 
7714 7e					ld a,(hl) 
7715 fe 2a				cp '*' 
7717 20 0c				jr nz,  .dirnotfound 
7719					 
7719			 
7719			 
7719 3a b5 f9				ld a, (store_page) 
771c d5					push de 
771d e5					push hl 
771e c5					push bc 
771f cd 4b 77				call .autorunf 
7722 c1					pop bc 
7723 e1					pop hl 
7724 d1					pop de 
7725			 
7725			 
7725			 
7725				; save this extent 
7725			 
7725					; push file name 
7725			;display file name to run 
7725			 
7725			;		ld hl, store_page+3 
7725			;		if DEBUG_FORTH_WORDS 
7725			;			DMARK "DI5" 
7725			;			CALLMONITOR 
7725			;		endif 
7725			; 
7725			;		 
7725			; 
7725			;		call forth_push_str 
7725			;		if DEBUG_FORTH_WORDS 
7725			;			DMARK "DI6" 
7725			;			CALLMONITOR 
7725			;		endif 
7725			.dirnotfound: 
7725 c1					pop bc     
7726 10 b6				djnz .diritem 
7728				 
7728			.dirdone:	 
7728					if DEBUG_FORTH_WORDS 
7728						DMARK "DI7" 
7728 f5				push af  
7729 3a 3d 77			ld a, (.dmark)  
772c 32 a6 fd			ld (debug_mark),a  
772f 3a 3e 77			ld a, (.dmark+1)  
7732 32 a7 fd			ld (debug_mark+1),a  
7735 3a 3f 77			ld a, (.dmark+2)  
7738 32 a8 fd			ld (debug_mark+2),a  
773b 18 03			jr .pastdmark  
773d ..			.dmark: db "DI7"  
7740 f1			.pastdmark: pop af  
7741			endm  
# End of macro DMARK
7741						CALLMONITOR 
7741 cd aa fd			call debug_vector  
7744				endm  
# End of macro CALLMONITOR
7744					endif 
7744			 
7744 cd 9b 0d				call clear_display 
7747 cd be 0d				call update_display 
774a			 
774a c9					ret 
774b			 
774b			 
774b			 
774b			 
774b			 
774b			.autorunf: 
774b			 
774b			 
774b				; get file id to load from and get the file name to display 
774b			 
774b			;		ld a, (store_page+STORE_0_FILERUN) 
774b			 
774b 2e 00				ld l, 0 
774d 67					ld h, a 
774e 11 b5 f9				ld de, store_page 
7751			 
7751					if DEBUG_FORTH_WORDS 
7751						DMARK "ASp" 
7751 f5				push af  
7752 3a 66 77			ld a, (.dmark)  
7755 32 a6 fd			ld (debug_mark),a  
7758 3a 67 77			ld a, (.dmark+1)  
775b 32 a7 fd			ld (debug_mark+1),a  
775e 3a 68 77			ld a, (.dmark+2)  
7761 32 a8 fd			ld (debug_mark+2),a  
7764 18 03			jr .pastdmark  
7766 ..			.dmark: db "ASp"  
7769 f1			.pastdmark: pop af  
776a			endm  
# End of macro DMARK
776a						CALLMONITOR 
776a cd aa fd			call debug_vector  
776d				endm  
# End of macro CALLMONITOR
776d					endif 
776d cd be 09				call storage_read 
7770			 
7770					if DEBUG_FORTH_WORDS 
7770						DMARK "ASr" 
7770 f5				push af  
7771 3a 85 77			ld a, (.dmark)  
7774 32 a6 fd			ld (debug_mark),a  
7777 3a 86 77			ld a, (.dmark+1)  
777a 32 a7 fd			ld (debug_mark+1),a  
777d 3a 87 77			ld a, (.dmark+2)  
7780 32 a8 fd			ld (debug_mark+2),a  
7783 18 03			jr .pastdmark  
7785 ..			.dmark: db "ASr"  
7788 f1			.pastdmark: pop af  
7789			endm  
# End of macro DMARK
7789						CALLMONITOR 
7789 cd aa fd			call debug_vector  
778c				endm  
# End of macro CALLMONITOR
778c					endif 
778c			 
778c cd f8 0f				call ishlzero 
778f c8					ret z             ; file not found 
7790			 
7790					; display file name we are loading 
7790			 
7790 cd 9b 0d				call clear_display 
7793			 
7793 3e 32				ld a, display_row_2 + 10 
7795 11 b8 f9				ld de, store_page+3 
7798 cd ae 0d				call str_at_display 
779b				 
779b			; 
779b			 
779b			;	ld a, display_row_1+5 
779b			;	ld de, sprompt3 
779b			;	call str_at_display 
779b			;	ld a, display_row_2+7 
779b			;	call active 
779b			;	ex de, hl 
779b			;;	ld de, sprompt4 
779b			;	call str_at_display 
779b			; 
779b cd be 0d			call update_display 
779e			 
779e			;	call cin_wait 
779e			;	cp 'n' 
779e			;	ret z 
779e			;	cp 'N' 
779e			;	ret z 
779e			 
779e			;	call delay1s 
779e			 
779e 3a b7 f9			ld a, (store_page+2) 
77a1 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
77a4 3e 01			ld a, 1  
77a6 32 a5 f9			ld (store_openext), a    ; save count of ext 
77a9			 
77a9			.autof: 
77a9				; begin to read a line from file 
77a9			 
77a9 21 23 f4			ld hl, os_cli_cmd 
77ac 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
77af			  
77af			.readext: 
77af 3a a5 f9			ld a, (store_openext) 
77b2 6f				ld l , a 
77b3				 
77b3 3a b5 f9			ld a, (store_page) 
77b6 67				ld h, a	 
77b7 11 b5 f9			ld de, store_page 
77ba					if DEBUG_FORTH_WORDS 
77ba						DMARK "ASl" 
77ba f5				push af  
77bb 3a cf 77			ld a, (.dmark)  
77be 32 a6 fd			ld (debug_mark),a  
77c1 3a d0 77			ld a, (.dmark+1)  
77c4 32 a7 fd			ld (debug_mark+1),a  
77c7 3a d1 77			ld a, (.dmark+2)  
77ca 32 a8 fd			ld (debug_mark+2),a  
77cd 18 03			jr .pastdmark  
77cf ..			.dmark: db "ASl"  
77d2 f1			.pastdmark: pop af  
77d3			endm  
# End of macro DMARK
77d3						CALLMONITOR 
77d3 cd aa fd			call debug_vector  
77d6				endm  
# End of macro CALLMONITOR
77d6					endif 
77d6 cd be 09				call storage_read 
77d9 cd f8 0f			call ishlzero 
77dc c8				ret z 
77dd			 
77dd			; TODO copy to exec buffer 
77dd			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
77dd			 
77dd				; copy the record buffer to the cli buffer 
77dd			 
77dd ed 5b 21 f6		ld de, (os_var_array) 
77e1 21 b7 f9			ld hl, store_page+2 
77e4			;	ex de, hl 
77e4 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
77e7 ed b0			ldir 
77e9 ed 53 21 f6		ld (os_var_array), de 
77ed				 
77ed 3a a5 f9			ld a, (store_openext) 
77f0 3c				inc a 
77f1 32 a5 f9			ld (store_openext), a    ; save count of ext 
77f4			 
77f4			 
77f4			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
77f4				 
77f4 3a a8 f9			ld a, (store_readcont) 
77f7 fe 00			cp 0 
77f9 20 b4			jr nz, .readext 
77fb			 
77fb			;	jr z, .autoend 
77fb			 
77fb					if DEBUG_FORTH_WORDS 
77fb						DMARK "ASc" 
77fb f5				push af  
77fc 3a 10 78			ld a, (.dmark)  
77ff 32 a6 fd			ld (debug_mark),a  
7802 3a 11 78			ld a, (.dmark+1)  
7805 32 a7 fd			ld (debug_mark+1),a  
7808 3a 12 78			ld a, (.dmark+2)  
780b 32 a8 fd			ld (debug_mark+2),a  
780e 18 03			jr .pastdmark  
7810 ..			.dmark: db "ASc"  
7813 f1			.pastdmark: pop af  
7814			endm  
# End of macro DMARK
7814						CALLMONITOR 
7814 cd aa fd			call debug_vector  
7817				endm  
# End of macro CALLMONITOR
7817					endif 
7817 e5				push hl	 
7818 d5				push de 
7819 cd f2 0c			call active 
781c eb				ex de, hl 
781d 3e 2f			ld a, display_row_2 + 7 
781f cd ae 0d			call str_at_display 
7822			 
7822 cd be 0d			call update_display 
7825 d1				pop de  
7826 e1				pop hl 
7827			;	call delay250ms 
7827			 
7827			 
7827			 
7827			 
7827			.autoexec: 
7827			 
7827			 
7827 21 23 f4			ld hl, os_cli_cmd 
782a					if DEBUG_FORTH_WORDS 
782a						DMARK "ASx" 
782a f5				push af  
782b 3a 3f 78			ld a, (.dmark)  
782e 32 a6 fd			ld (debug_mark),a  
7831 3a 40 78			ld a, (.dmark+1)  
7834 32 a7 fd			ld (debug_mark+1),a  
7837 3a 41 78			ld a, (.dmark+2)  
783a 32 a8 fd			ld (debug_mark+2),a  
783d 18 03			jr .pastdmark  
783f ..			.dmark: db "ASx"  
7842 f1			.pastdmark: pop af  
7843			endm  
# End of macro DMARK
7843						CALLMONITOR 
7843 cd aa fd			call debug_vector  
7846				endm  
# End of macro CALLMONITOR
7846					endif 
7846 cd 5d 26			call forthparse 
7849 cd 9d 26			call forthexec 
784c cd af 25			call forthexec_cleanup 
784f			 
784f			 
784f			 
784f c3 a9 77			jp .autof 
7852			;.autofdone: 
7852			; 
7852			;		if DEBUG_FORTH_WORDS 
7852			;			DMARK "ASx" 
7852			;			CALLMONITOR 
7852			;		endif 
7852			;;	call clear_display 
7852			;	ret 
7852			 
7852			 
7852			 
7852			endif 
# End of file forth_startupv2.asm
7852			endif 
7852			 
# End of file forth_startup.asm
7852			 
7852			; eof 
# End of file forth_kernel.asm
7852			;include "nascombasic.asm" 
7852			 
7852			 
7852			; find out where the code ends if loaded into RAM (for SC114) 
7852			;endofcode:  
7852			;	nop 
7852			 
7852			 
7852			; jump to nmi vector 
7852			 
7852			init_nmi: 
7852 3e c9			ld a, $c9   ; RET 
7854 32 ad fd			ld (nmi_vector), a 
7857 c9				ret 
7858			nmi: 
7858 e5				push hl 
7859 d5				push de 
785a c5				push bc 
785b f5				push af 
785c cd ad fd			call nmi_vector 
785f f5				push af 
7860 c5				push bc 
7861 d5				push de 
7862 e5				push hl 
7863 ed 4d			reti 
7865			 
7865			 
7865			; eof 
7865			 
# End of file main.asm
7865			include "firmware_lcd_4x40.asm" 
7865			; **********************************************************************  
7865			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7865			; **********************************************************************  
7865			;  
7865			; **  Written as a Small Computer Monitor App  
7865			; **  www.scc.me.uk  
7865			;  
7865			; History  
7865			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7865			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7865			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7865			;  
7865			; **********************************************************************  
7865			;  
7865			; This program is an example of one of the methods of interfacing an   
7865			; alphanumeric LCD module.   
7865			;  
7865			; In this example the display is connected to either a Z80 PIO or a   
7865			; simple 8-bit output port.   
7865			;  
7865			; This interfacing method uses 4-bit data mode and uses time delays  
7865			; rather than polling the display's ready status. As a result the   
7865			; interface only requires 6 simple output lines:  
7865			;   Output bit 0 = not used  
7865			;   Output bit 1 = not used  
7865			;   Output bit 2 = RS         High = data, Low = instruction  
7865			;   Output bit 3 = E          Active high  
7865			;   Output bit 4 = DB4  
7865			;   Output bit 5 = DB5  
7865			;   Output bit 6 = DB6  
7865			;   Output bit 7 = DB7  
7865			; Display's R/W is connected to 0v so it is always in write mode  
7865			;  
7865			; This set up should work with any system supporting the RC2014 bus  
7865			  
7865			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7865			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7865			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7865			;  
7865			; **********************************************************************  
7865			  
7865			; Additonal for 4x40. E1 and E2 instead of just E   
7865			; TODO swipe vidout signal on port a to activate E2  
7865			  
7865			; **********************************************************************  
7865			; **  Constants  
7865			; **********************************************************************  
7865			; LCD constants required by LCD support module  
7865			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7865			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7865			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7865			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7865			; TODO Decide which E is being set  
7865			kLCDWidth:  EQU display_cols             ;Width in characters  
7865			  
7865			; **********************************************************************  
7865			; **  Code library usage  
7865			; **********************************************************************  
7865			  
7865			; send character to current cursor position  
7865			; wraps and/or scrolls screen automatically  
7865			  
7865			  
7865			  
7865			lcd_init:  
7865			  
7865			; SCMonAPI functions used  
7865			  
7865			; Alphanumeric LCD functions used  
7865			; no need to specify specific functions for this module  
7865			  
7865 3e cf		            LD   A, 11001111b  
7867 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7869 3e 00		            LD   A, 00000000b  
786b d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
786d			  
786d			; Initialise alphanumeric LCD module  
786d 3e 00				ld a, 0  
786f 32 06 fb				ld (display_lcde1e2), a  
7872 cd f3 78		            CALL fLCD_Init      ;Initialise LCD module  
7875 3e 01				ld a, 1  
7877 32 06 fb				ld (display_lcde1e2), a  
787a cd f3 78		            CALL fLCD_Init      ;Initialise LCD module  
787d			  
787d c9				ret  
787e			  
787e			;  
787e			;;  
787e			; lcd functions  
787e			;  
787e			;  
787e			  
787e			; what is at cursor position   
787e			  
787e			;get_cursor:	ld de, (cursor_row)   ;  row + col  
787e			;		call curptr  
787e			;		ret  
787e			  
787e			  
787e			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
787e			  
787e			curptr:  
787e c5				push bc  
787f 21 ec fc			ld hl, display_fb0  
7882			cpr:	  
7882				; loop for cursor whole row  
7882 0e 28			ld c, display_cols  
7884 23			cpr1:	inc hl  
7885 0d				dec c  
7886 20 fc			jr nz, cpr1  
7888 05				dec b  
7889 20 f7			jr nz, cpr  
788b			  
788b				; add col	  
788b			  
788b 23			cpr2:	inc hl  
788c 1d				dec e  
788d 20 fc			jr nz, cpr2  
788f			  
788f c1				pop bc  
7890 c9				ret  
7891				  
7891			  
7891			  
7891			  
7891			  
7891			; write the frame buffer given in hl to hardware   
7891 22 04 fb		write_display: ld (display_write_tmp), hl 	   
7894 3e 00			ld a, kLCD_Line1  
7896 cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
7899 06 28			ld b, display_cols  
789b ed 5b 04 fb		ld de, (display_write_tmp)  
789f cd eb 78			call write_len_string  
78a2				  
78a2				  
78a2 2a 04 fb			ld hl, (display_write_tmp)  
78a5 11 28 00			ld de, display_cols  
78a8 19				add hl,de  
78a9 22 04 fb			ld (display_write_tmp),hl  
78ac			  
78ac				  
78ac 3e 28			ld a, kLCD_Line2  
78ae cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
78b1 06 28			ld b, display_cols  
78b3 ed 5b 04 fb		ld de, (display_write_tmp)  
78b7 cd eb 78			call write_len_string  
78ba				  
78ba 2a 04 fb			ld hl, (display_write_tmp)  
78bd 11 28 00			ld de, display_cols  
78c0 19				add hl,de  
78c1 22 04 fb			ld (display_write_tmp),hl  
78c4			  
78c4				  
78c4 3e 50			ld a, kLCD_Line3  
78c6 cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
78c9 06 28			ld b, display_cols  
78cb ed 5b 04 fb		ld de, (display_write_tmp)  
78cf cd eb 78			call write_len_string  
78d2				  
78d2 2a 04 fb			ld hl, (display_write_tmp)  
78d5 11 28 00			ld de, display_cols  
78d8 19				add hl,de  
78d9 22 04 fb			ld (display_write_tmp),hl  
78dc			  
78dc				  
78dc 3e 78			ld a, kLCD_Line4  
78de cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
78e1 06 28			ld b, display_cols  
78e3 ed 5b 04 fb		ld de, (display_write_tmp)  
78e7 cd eb 78			call write_len_string  
78ea c9					ret  
78eb				  
78eb				; write out a fixed length string given in b from de  
78eb			  
78eb 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
78ec cd 58 79		            CALL fLCD_Data      ;Write character to display  
78ef 13				inc de  
78f0 10 f9			djnz write_len_string  
78f2 c9				ret  
78f3			  
78f3			; Some other things to do  
78f3			;            LD   A, kLCD_Clear ;Display clear  
78f3			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
78f3			;            LD   A, kLCD_Under ;Display on with underscore cursor  
78f3			;            LD   A, kLCD_On     ;Display on with no cursor  
78f3			;            ;LD   A, kLCD_Off   ;Display off  
78f3			;            CALL fLCD_Inst      ;Send instruction to display  
78f3			;  
78f3			;  
78f3			;            halt  
78f3			;  
78f3			;  
78f3			;MsgHello:   DB  "Hello World!",0  
78f3			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
78f3			  
78f3			; Custom characters 5 pixels wide by 8 pixels high  
78f3			; Up to 8 custom characters can be defined  
78f3			;BitMaps:      
78f3			;; Character 0x00 = Battery icon  
78f3			;            DB  01110b  
78f3			;            DB  11011b  
78f3			;            DB  10001b  
78f3			;            DB  10001b  
78f3			;            DB  11111b  
78f3			;            DB  11111b  
78f3			;            DB  11111b  
78f3			;            DB  11111b  
78f3			;; Character 0x01 = Bluetooth icon  
78f3			;            DB  01100b  
78f3			;            DB  01010b  
78f3			;            DB  11100b  
78f3			;            DB  01000b  
78f3			;            DB  11100b  
78f3			;            DB  01010b  
78f3			;            DB  01100b  
78f3			;            DB  00000b  
78f3			;  
78f3			  
78f3			  
78f3			; **********************************************************************  
78f3			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
78f3			; **********************************************************************  
78f3			;  
78f3			; **  Written as a Small Computer Monitor App   
78f3			; **  Version 0.1 SCC 2018-05-16  
78f3			; **  www.scc.me.uk  
78f3			;  
78f3			; **********************************************************************  
78f3			;  
78f3			; This module provides support for alphanumeric LCD modules using with  
78f3			; *  HD44780 (or compatible) controller  
78f3			; *  5 x 7 pixel fonts  
78f3			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
78f3			; *  Interface via six digital outputs to the display (see below)  
78f3			;  
78f3			; LCD module pinout:  
78f3			;   1  Vss   0v supply  
78f3			;   2  Vdd   5v supply  
78f3			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
78f3			;   4  RS    High = data, Low = instruction  
78f3			;   5  R/W   High = Read, Low = Write  
78f3			;   6  E     Enable signal (active high)  
78f3			;   7  DB0   Data bit 0  
78f3			;   8  DB1   Data bit 1  
78f3			;   9  DB2   Data bit 2  
78f3			;  10  DB3   Data bit 3  
78f3			;  11  DB4   Data bit 4  
78f3			;  12  DB5   Data bit 5  
78f3			;  13  DB6   Data bit 6  
78f3			;  14  DB7   Data bit 7  
78f3			;  15  A     Backlight anode (+)  
78f3			;  16  K     Backlight cathode (-)  
78f3			;  
78f3			; This interfacing method uses 4-bit data mode and uses time delays  
78f3			; rather than polling the display's ready status. As a result the   
78f3			; interface only requires 6 simple output lines:  
78f3			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
78f3			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
78f3			;   LCD DB4 = Microcomputer output port bit 4  
78f3			;   LCD DB5 = Microcomputer output port bit 5  
78f3			;   LCD DB6 = Microcomputer output port bit 6  
78f3			;   LCD DB7 = Microcomputer output port bit 7  
78f3			; Display's R/W is connected to 0v so it is always in write mode  
78f3			; All 6 connections must be on the same port address <kLCDPrt>  
78f3			; This method also allows a decent length of cable from micro to LCD  
78f3			;  
78f3			; **********************************************************************  
78f3			;  
78f3			; To include the code for any given function provided by this module,   
78f3			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
78f3			; the parent source file.  
78f3			; For example:  #REQUIRES   uHexPrefix  
78f3			;  
78f3			; Also #INCLUDE this file at some point after the #REQUIRES statements  
78f3			; in the parent source file.  
78f3			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
78f3			;  
78f3			; These are the function names provided by this module:  
78f3			; fLCD_Init                     ;Initialise LCD  
78f3			; fLCD_Inst                     ;Send instruction to LCD  
78f3			; fLCD_Data                     ;Send data byte to LCD  
78f3			; fLCD_Pos                      ;Position cursor  
78f3			; fLCD_Str                      ;Display string  
78f3			; fLCD_Def                      ;Define custom character  
78f3			;  
78f3			; **********************************************************************  
78f3			;  
78f3			; Requires SCMonAPI.asm to also be included in the project  
78f3			;  
78f3			  
78f3			  
78f3			; **********************************************************************  
78f3			; **  Constants  
78f3			; **********************************************************************  
78f3			  
78f3			; Constants that must be defined externally  
78f3			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
78f3			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
78f3			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
78f3			;kLCDWidth: EQU 20             ;Width in characters  
78f3			  
78f3			; general line offsets in any frame buffer  
78f3			  
78f3			  
78f3			display_row_1: equ 0  
78f3			display_row_2: equ display_row_1+display_cols  
78f3			display_row_3: equ display_row_2 + display_cols  
78f3			display_row_4: equ display_row_3 + display_cols  
78f3			;display_row_4_eol:   
78f3			  
78f3			  
78f3			; Cursor position values for the start of each line  
78f3			  
78f3			; E  
78f3			kLCD_Line1: EQU 0x00   
78f3			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
78f3			; E1  
78f3			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
78f3			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
78f3			  
78f3			; Instructions to send as A register to fLCD_Inst  
78f3			kLCD_Clear: EQU 00000001b     ;LCD clear  
78f3			kLCD_Off:   EQU 00001000b     ;LCD off  
78f3			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
78f3			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
78f3			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
78f3			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
78f3			  
78f3			; Constants used by this code module  
78f3			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
78f3			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
78f3			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
78f3			  
78f3			  
78f3			  
78f3			; **********************************************************************  
78f3			; **  LCD support functions  
78f3			; **********************************************************************  
78f3			  
78f3			; Initialise alphanumeric LCD module  
78f3			; LCD control register codes:  
78f3			;   DL   0 = 4-bit mode        1 = 8-bit mode  
78f3			;   N    0 = 1-line mode       1 = 2-line mode  
78f3			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
78f3			;   D    0 = Display off       1 = Display on  
78f3			;   C    0 = Cursor off        1 = Cursor on  
78f3			;   B    0 = Blinking off      1 = Blinking on  
78f3			;   ID   0 = Decrement mode    1 = Increment mode  
78f3			;   SH   0 = Entire shift off  1 = Entire shift on  
78f3 3e 28		fLCD_Init:  LD   A, 40  
78f5 cd 1a 7a		            CALL LCDDelay       ;Delay 40ms after power up  
78f8			; For reliable reset set 8-bit mode - 3 times  
78f8 cd ea 79		            CALL WrFn8bit       ;Function = 8-bit mode  
78fb cd ea 79		            CALL WrFn8bit       ;Function = 8-bit mode  
78fe cd ea 79		            CALL WrFn8bit       ;Function = 8-bit mode  
7901			; Set 4-bit mode  
7901 cd e6 79		            CALL WrFn4bit       ;Function = 4-bit mode  
7904 cd 18 7a		            CALL LCDDelay1      ;Delay 37 us or more  
7907			; Function set  
7907 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7909 cd 1c 79		            CALL fLCD_Inst      ;2 line, display on  
790c			; Display On/Off control  
790c 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
790e cd 1c 79		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7911			; Display Clear  
7911 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7913 cd 1c 79		            CALL fLCD_Inst      ;Clear display  
7916			; Entry mode  
7916 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7918 cd 1c 79		            CALL fLCD_Inst      ;Increment mode, shift off  
791b			; Display module now initialised  
791b c9			            RET  
791c			; ok to here  
791c			  
791c			; Write instruction to LCD  
791c			;   On entry: A = Instruction byte to be written  
791c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
791c f5			fLCD_Inst:  PUSH AF  
791d f5			            PUSH AF  
791e cd 30 79		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7921 f1			            POP  AF  
7922 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7923 17			            RLA  
7924 17			            RLA  
7925 17			            RLA  
7926 cd 30 79		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7929 3e 02		            LD   A, 2  
792b cd 1a 7a		            CALL LCDDelay       ;Delay 2 ms to complete   
792e f1			            POP  AF  
792f c9			            RET  
7930			Wr4bits:   
7930 f5					push af  
7931 3a 06 fb				ld a, (display_lcde1e2)  
7934 fe 00				cp 0     ; e  
7936 20 10				jr nz, .wea2	  
7938 f1					pop af  
7939 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
793b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
793d cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
793f cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7941 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7943 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7945 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7947 c9			            RET  
7948 f1			.wea2:		pop af  
7949 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
794b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
794d cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
794f cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7951 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7953 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7955 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7957 c9			            RET  
7958			  
7958			  
7958			; Write data to LCD  
7958			;   On entry: A = Data byte to be written  
7958			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7958 f5			fLCD_Data:  PUSH AF  
7959 f5			            PUSH AF  
795a cd 6c 79		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
795d f1			            POP  AF  
795e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
795f 17			            RLA  
7960 17			            RLA  
7961 17			            RLA  
7962 cd 6c 79		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7965 3e 96		            LD   A, 150  
7967 3d			Wait:      DEC  A              ;Wait a while to allow data   
7968 20 fd		            JR   NZ, Wait      ;  write to complete  
796a f1			            POP  AF  
796b c9			            RET  
796c			Wr4bitsa:     
796c f5					push af  
796d 3a 06 fb				ld a, (display_lcde1e2)  
7970 fe 00				cp 0     ; e1  
7972 20 16				jr nz, .we2	  
7974 f1					pop af  
7975 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7977 cb d7		            SET  kLCDBitRS, A  
7979 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
797b cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
797d cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
797f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7981 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7983 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7985 cb 97		            RES  kLCDBitRS, A  
7987 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7989 c9			            RET  
798a f1			.we2:		pop af  
798b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
798d cb d7		            SET  kLCDBitRS, A  
798f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7991 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7993 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7995 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7997 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7999 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
799b cb 97		            RES  kLCDBitRS, A  
799d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
799f c9			            RET  
79a0			  
79a0			  
79a0			; Position cursor to specified location  
79a0			;   On entry: A = Cursor position  
79a0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
79a0 f5			fLCD_Pos:   PUSH AF  
79a1					; at this point set the E1 or E2 flag depending on position  
79a1			  
79a1 c5					push bc  
79a2			;		push af  
79a2 06 00				ld b, 0  
79a4 4f					ld c, a  
79a5 3e 4f				ld a, kLCD_Line3-1  
79a7 b7			 		or a      ;clear carry flag  
79a8 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
79a9 38 04				jr c, .pe1  
79ab			  
79ab					; E selection  
79ab cb 80				res 0, b         ; bit 0 unset e  
79ad			;		pop af    ; before line 3 so recover orig pos  
79ad			;		ld c, a    ; save for poking back  
79ad 18 06				jr .peset	          
79af			.pe1:          	; E2 selection  
79af cb c0				set 0, b         ; bit 0 set e1  
79b1 79					ld a, c  
79b2 de 4f				sbc a, kLCD_Line3-1  
79b4 4f					ld c, a	         ; save caculated offset  
79b5			;		pop af     ; bin this original value now we have calculated form  
79b5			  
79b5			.peset:		; set bit  
79b5 78					ld a, b  
79b6 32 06 fb				ld (display_lcde1e2), a 	  
79b9 79					ld a, c  
79ba c1					pop bc  
79bb			  
79bb f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
79bd cd 1c 79		            CALL fLCD_Inst      ;Write instruction to LCD  
79c0 f1			            POP  AF  
79c1 c9			            RET  
79c2			  
79c2			  
79c2			; Output text string to LCD  
79c2			;   On entry: DE = Pointer to null terminated text string  
79c2			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
79c2 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
79c3 b7			            OR   A              ;Null terminator?  
79c4 c8			            RET  Z              ;Yes, so finished  
79c5 cd 58 79		            CALL fLCD_Data      ;Write character to display  
79c8 13			            INC  DE             ;Point to next character  
79c9 18 f7		            JR   fLCD_Str       ;Repeat  
79cb c9					ret  
79cc			  
79cc			; Define custom character  
79cc			;   On entry: A = Character number (0 to 7)  
79cc			;             DE = Pointer to character bitmap data  
79cc			;   On exit:  A = Next character number  
79cc			;             DE = Next location following bitmap  
79cc			;             BC HL IX IY I AF' BC' DE' HL' preserved  
79cc			; Character is   
79cc c5			fLCD_Def:   PUSH BC  
79cd f5			            PUSH AF  
79ce 07			            RLCA                ;Calculate location  
79cf 07			            RLCA                ;  for bitmap data  
79d0 07			            RLCA                ;  = 8 x CharacterNumber  
79d1 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
79d3 cd 1c 79		            CALL fLCD_Inst      ;Write instruction to LCD  
79d6 06 00		            LD   B, 0  
79d8 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
79d9 cd 58 79		            CALL fLCD_Data      ;Write byte to display  
79dc 13			            INC  DE             ;Point to next byte  
79dd 04			            INC  B              ;Count bytes  
79de cb 58		            BIT  3, B           ;Finish all 8 bytes?  
79e0 28 f6		            JR   Z, Loop       ;No, so repeat  
79e2 f1			            POP  AF  
79e3 3c			            INC  A              ;Increment character number  
79e4 c1			            POP  BC  
79e5 c9			            RET  
79e6			  
79e6			  
79e6			; **********************************************************************  
79e6			; **  Private functions  
79e6			; **********************************************************************  
79e6			  
79e6			; Write function to LCD  
79e6			;   On entry: A = Function byte to be written  
79e6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
79e6 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
79e8 18 02		            JR   WrFunc  
79ea 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
79ec f5			WrFunc:     PUSH AF  
79ed f5					push af  
79ee 3a 06 fb				ld a, (display_lcde1e2)  
79f1 fe 00				cp 0     ; e1  
79f3 20 0f				jr nz, .wfea2	  
79f5 f1					pop af  
79f6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
79f8 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
79fa cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
79fc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
79fe cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7a00 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a02 18 0d			jr .wfskip  
7a04 f1			.wfea2:		pop af  
7a05 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a07 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7a09 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7a0b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7a0d cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7a0f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7a11 3e 05		.wfskip:            LD  A, 5  
7a13 cd 1a 7a		            CALL LCDDelay       ;Delay 5 ms to complete  
7a16 f1			            POP  AF  
7a17 c9			            RET  
7a18			  
7a18			  
7a18			; Delay in milliseconds  
7a18			;   On entry: A = Number of milliseconds delay  
7a18			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7a18 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7a1a d5			LCDDelay:   PUSH DE  
7a1b 5f			            LD   E, A           ;Delay by 'A' ms  
7a1c 16 00		            LD   D, 0  
7a1e cd c3 0c		            CALL aDelayInMS  
7a21 d1			            POP  DE  
7a22 c9			            RET  
7a23			  
7a23			  
7a23			testlcd:  
7a23 3e 00			ld a, kLCD_Line1  
7a25 cd a0 79			call fLCD_Pos  
7a28 06 28			ld b, 40  
7a2a 11 58 7a			ld de, .ttext1  
7a2d cd eb 78			call write_len_string  
7a30			  
7a30 3e 28			ld a, kLCD_Line2  
7a32 cd a0 79			call fLCD_Pos  
7a35 06 28			ld b, 40  
7a37 11 81 7a			ld de, .ttext2  
7a3a cd eb 78			call write_len_string  
7a3d 3e 50			ld a, kLCD_Line3  
7a3f cd a0 79			call fLCD_Pos  
7a42 06 28			ld b, 40  
7a44 11 aa 7a			ld de, .ttext3  
7a47 cd eb 78			call write_len_string  
7a4a 3e 78			ld a, kLCD_Line4  
7a4c cd a0 79			call fLCD_Pos  
7a4f 06 28			ld b, 40  
7a51 11 d3 7a			ld de, .ttext4  
7a54 cd eb 78			call write_len_string  
7a57			  
7a57 76				halt  
7a58			  
7a58			  
7a58 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7a81 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7aaa .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7ad3 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7afc			   
7afc			  
7afc			  
7afc			; eof  
7afc			  
# End of file firmware_lcd_4x40.asm
7afc			;include "firmware_lcd_4x20.asm" 
7afc			include "firmware_key_5x10.asm" 
7afc			; 5 x 10 decade counter scanner  
7afc			  
7afc			  
7afc			; TODO do cursor shape change for shift keys  
7afc			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7afc			  
7afc			  
7afc			; bit mask for each scan column and row for teing the matrix  
7afc			  
7afc			  
7afc			key_init:  
7afc			  
7afc			; SCMonAPI functions used  
7afc			  
7afc			; Alphanumeric LCD functions used  
7afc			; no need to specify specific functions for this module  
7afc			  
7afc			  
7afc 3e cf		            LD   A, 11001111b  
7afe d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7b00			;            LD   A, 00000000b  
7b00 3e 1f		            LD   A, 00011111b  
7b02 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7b04			  
7b04			  
7b04				; TODO Configure cursor shapes  
7b04			  
7b04				; Load cursor shapes   
7b04 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7b06 11 16 7b		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7b09 06 02		            LD   B, 2           ;Number of characters to define  
7b0b cd cc 79		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7b0e 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7b10			  
7b10 3e 01				ld a, 1  
7b12 32 fc fa			ld (cursor_shape),a  
7b15 c9				ret  
7b16			  
7b16			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7b16			; Up to 8 custom characters can be defined  
7b16			.cursor_shapes:      
7b16			;; Character 0x00 = Normal  
7b16 1f			            DB  11111b  
7b17 1f			            DB  11111b  
7b18 1f			            DB  11111b  
7b19 1f			            DB  11111b  
7b1a 1f			            DB  11111b  
7b1b 1f			            DB  11111b  
7b1c 1f			            DB  11111b  
7b1d 1f			            DB  11111b  
7b1e			;; Character 0x01 = Modifier  
7b1e 1f			            DB  11111b  
7b1f 1b			            DB  11011b  
7b20 1b			            DB  11011b  
7b21 1b			            DB  11011b  
7b22 1b			            DB  11011b  
7b23 1f			            DB  11111b  
7b24 1b			            DB  11011b  
7b25 1f			            DB  11111b  
7b26			  
7b26			  
7b26			  
7b26			  
7b26			; Display custom character 0  
7b26			;            LD   A, kLCD_Line1+14  
7b26			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b26			;            LD   A, 0  
7b26			;            CALL fLCD_Data      ;Write character in A at cursor  
7b26			  
7b26			; Display custom character 1  
7b26			;            LD   A, kLCD_Line2+14  
7b26			;            CALL fLCD_Pos      ;Position cursor to location in A  
7b26			;            LD   A, 1  
7b26			;            CALL fLCD_Data     ;Write character in A at cursor  
7b26			  
7b26			; keyboard scanning   
7b26			  
7b26			; character in from keyboard  
7b26			  
7b26			; mapping for the pcb layout  
7b26			  
7b26			.matrix_to_char:  
7b26 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7b31 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7b3c 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7b47 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7b52 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7b5d			.matrix_to_shift:  
7b5d			  
7b5d .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7b68 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7b73 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7b7e 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7b89 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7b94			  
7b94			.matrix_to_symbolshift:  
7b94			  
7b94 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7b9f .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7baa 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7bb5			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7bb5 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7bc0 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7bcb			  
7bcb			  
7bcb			  
7bcb			; mapping for a simple straight through breadboard layout  
7bcb			  
7bcb			;.matrix_to_char:  
7bcb			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7bcb			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7bcb			;		db "asdfghjkl",KEY_CR,0  
7bcb			;		db "qwertyuiop",0  
7bcb			;		 db "1234567890",0  
7bcb			;.matrix_to_shift:  
7bcb			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7bcb			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7bcb			;		db "ASDFGHJKL",KEY_CR,0  
7bcb			;		db "QWERTYUIOP",0  
7bcb			;		 db "!",'"',"#$%^&*()",0  
7bcb			;.matrix_to_symbolshift:  
7bcb			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7bcb			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7bcb			;		db "_?*fghjk=",KEY_CR,0  
7bcb			;		db "-/+*[]{}@#",0  
7bcb			;		 db "1234567890",0  
7bcb			  
7bcb			;.matrix_to_char: db "D#0*C987B654A321"  
7bcb			  
7bcb			  
7bcb				  
7bcb			  
7bcb			; add cin and cin_wait  
7bcb			  
7bcb cd dc 7b		cin_wait: 	call cin  
7bce						if DEBUG_KEYCINWAIT  
7bce							push af  
7bce							  
7bce							ld hl,key_repeat_ct  
7bce							ld (hl),a  
7bce							inc hl  
7bce							call hexout  
7bce							ld hl,key_repeat_ct+3  
7bce							ld a,0  
7bce							ld (hl),a  
7bce			  
7bce							    LD   A, kLCD_Line1+11  
7bce							    CALL fLCD_Pos       ;Position cursor to location in A  
7bce							    LD   DE, key_repeat_ct  
7bce							    ;LD   DE, MsgHello  
7bce							    CALL fLCD_Str       ;Display string pointed to by DE  
7bce			  
7bce			  
7bce			  
7bce							pop af  
7bce						endif  
7bce fe 00			cp 0  
7bd0 28 f9			jr z, cin_wait   ; block until key press  
7bd2			  
7bd2							if DEBUG_KEYCINWAIT  
7bd2								push af  
7bd2			  
7bd2								ld a, 'A'	  
7bd2								ld hl,key_repeat_ct  
7bd2								ld (hl),a  
7bd2								inc hl  
7bd2								ld a,0  
7bd2								ld (hl),a  
7bd2			  
7bd2								    LD   A, kLCD_Line2+11  
7bd2								    CALL fLCD_Pos       ;Position cursor to location in A  
7bd2								    LD   DE, key_repeat_ct  
7bd2								    ;LD   DE, MsgHello  
7bd2								    CALL fLCD_Str       ;Display string pointed to by DE  
7bd2			  
7bd2							call delay500ms  
7bd2			  
7bd2								pop af  
7bd2							endif  
7bd2 f5				push af   ; save key pressed  
7bd3			  
7bd3			.cin_wait1:	  
7bd3							if DEBUG_KEYCINWAIT  
7bd3								push af  
7bd3			  
7bd3								ld a, 'b'	  
7bd3								ld hl,key_repeat_ct  
7bd3								ld (hl),a  
7bd3								inc hl  
7bd3								ld a,0  
7bd3								ld (hl),a  
7bd3			  
7bd3								    LD   A, kLCD_Line2+11  
7bd3								    CALL fLCD_Pos       ;Position cursor to location in A  
7bd3								    LD   DE, key_repeat_ct  
7bd3								    ;LD   DE, MsgHello  
7bd3								    CALL fLCD_Str       ;Display string pointed to by DE  
7bd3			  
7bd3			  
7bd3							call delay500ms  
7bd3			  
7bd3								pop af  
7bd3							endif  
7bd3			  
7bd3 cd dc 7b		call cin  
7bd6 fe 00			cp 0  
7bd8 20 f9			jr nz, .cin_wait1  	; wait for key release  
7bda			if DEBUG_KEYCINWAIT  
7bda				push af  
7bda			  
7bda				ld a, '3'	  
7bda				ld hl,key_repeat_ct  
7bda				ld (hl),a  
7bda				inc hl  
7bda				ld a,0  
7bda				ld (hl),a  
7bda			  
7bda			            LD   A, kLCD_Line2+11  
7bda			            CALL fLCD_Pos       ;Position cursor to location in A  
7bda			            LD   DE, key_repeat_ct  
7bda			            ;LD   DE, MsgHello  
7bda			            CALL fLCD_Str       ;Display string pointed to by DE  
7bda			  
7bda			  
7bda			call delay500ms  
7bda			  
7bda				pop af  
7bda			endif  
7bda			  
7bda f1				pop af   ; get key  
7bdb c9				ret  
7bdc			  
7bdc			  
7bdc cd f0 7b		cin: 	call .mtoc  
7bdf			  
7bdf			if DEBUG_KEYCIN  
7bdf				push af  
7bdf				  
7bdf				ld hl,key_repeat_ct  
7bdf				ld (hl),a  
7bdf				inc hl  
7bdf				call hexout  
7bdf				ld hl,key_repeat_ct+3  
7bdf				ld a,0  
7bdf				ld (hl),a  
7bdf			  
7bdf			            LD   A, kLCD_Line3+15  
7bdf			            CALL fLCD_Pos       ;Position cursor to location in A  
7bdf			            LD   DE, key_repeat_ct  
7bdf			            ;LD   DE, MsgHello  
7bdf			            CALL fLCD_Str       ;Display string pointed to by DE  
7bdf			  
7bdf			  
7bdf			call delay500ms  
7bdf			  
7bdf				pop af  
7bdf			endif  
7bdf			  
7bdf			  
7bdf				; no key held  
7bdf fe 00			cp 0  
7be1 c8				ret z  
7be2			  
7be2			if DEBUG_KEYCIN  
7be2				push af  
7be2			  
7be2				ld a, '1'	  
7be2				ld hl,key_repeat_ct  
7be2				ld (hl),a  
7be2				inc hl  
7be2				ld a,0  
7be2				ld (hl),a  
7be2			  
7be2			            LD   A, kLCD_Line4+15  
7be2			            CALL fLCD_Pos       ;Position cursor to location in A  
7be2			            LD   DE, key_repeat_ct  
7be2			            ;LD   DE, MsgHello  
7be2			            CALL fLCD_Str       ;Display string pointed to by DE  
7be2			  
7be2			  
7be2			call delay500ms  
7be2			  
7be2				pop af  
7be2			endif  
7be2			  
7be2				; stop key bounce  
7be2			  
7be2 32 c6 fd			ld (key_held),a		 ; save it  
7be5 47				ld b, a  
7be6			  
7be6 c5			.cina1:	push bc  
7be7			if DEBUG_KEYCIN  
7be7				push af  
7be7			  
7be7				ld hl,key_repeat_ct  
7be7				inc hl  
7be7				call hexout  
7be7				ld hl,key_repeat_ct+3  
7be7				ld a,0  
7be7				ld (hl),a  
7be7				ld hl,key_repeat_ct  
7be7				ld a, '2'	  
7be7				ld (hl),a  
7be7			  
7be7			            LD   A, kLCD_Line4+15  
7be7			            CALL fLCD_Pos       ;Position cursor to location in A  
7be7			            LD   DE, key_repeat_ct  
7be7			            ;LD   DE, MsgHello  
7be7			            CALL fLCD_Str       ;Display string pointed to by DE  
7be7			  
7be7				pop af  
7be7			endif  
7be7 cd f0 7b			call .mtoc  
7bea c1				pop bc  
7beb b8				cp b  
7bec 28 f8			jr z, .cina1  
7bee 78				ld a,b		  
7bef			if DEBUG_KEYCIN  
7bef				push af  
7bef			  
7bef				ld hl,key_repeat_ct  
7bef				inc hl  
7bef				call hexout  
7bef				ld hl,key_repeat_ct+3  
7bef				ld a,0  
7bef				ld (hl),a  
7bef				ld hl,key_repeat_ct  
7bef				ld a, '3'	  
7bef				ld (hl),a  
7bef			  
7bef			            LD   A, kLCD_Line4+15  
7bef			            CALL fLCD_Pos       ;Position cursor to location in A  
7bef			            LD   DE, key_repeat_ct  
7bef			            ;LD   DE, MsgHello  
7bef			            CALL fLCD_Str       ;Display string pointed to by DE  
7bef			  
7bef				pop af  
7bef			endif  
7bef c9				ret  
7bf0			  
7bf0			; detect keyboard modifier key press and apply new overlay to the face key held  
7bf0			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7bf0			  
7bf0			;.cin_map_modifier:   
7bf0			;	ld a, (hl)  
7bf0			;	and 255  
7bf0			;	ret NZ		; modifier key not flagged  
7bf0			;  
7bf0			;	; get key face  
7bf0			;  
7bf0			;	ld b,(key_face_held)  
7bf0			;  
7bf0			;	ld b, key_cols * key_rows  
7bf0			;  
7bf0			;	push de  
7bf0			;	pop hl  
7bf0			;  
7bf0			;.mmod1: ld a,(hl)   ; get map test  
7bf0			;	cp b  
7bf0			;	jr z, .mmod2  
7bf0			;  
7bf0			;  
7bf0			;  
7bf0			;.mmod2: inc hl    ;   
7bf0			;  
7bf0			;	  
7bf0			;  
7bf0			;	  
7bf0			;  
7bf0			;	ld hl,key_actual_pressed  
7bf0			;	ld (hl),a,  
7bf0			;	ret  
7bf0			  
7bf0			; map matrix key held to char on face of key  
7bf0			  
7bf0			.mtoc:  
7bf0			  
7bf0			; test decade counter strobes  
7bf0			  
7bf0			;.decadetest1:  
7bf0			  
7bf0			; reset counter  
7bf0			;ld a, 128  
7bf0			;out (portbdata),a  
7bf0			  
7bf0			  
7bf0			;ld b, 5  
7bf0			;.dec1:  
7bf0			;ld a, 0  
7bf0			;out (portbdata),a  
7bf0			;call delay1s  
7bf0			  
7bf0			;ld a, 32  
7bf0			;out (portbdata),a  
7bf0			;call delay1s  
7bf0			;call delay1s  
7bf0			;call delay1s  
7bf0			;  
7bf0			;ld a, 64+32  
7bf0			;out (portbdata),a  
7bf0			;call delay1s  
7bf0			;;djnz .dec1  
7bf0			;  
7bf0			;jp .decadetest1  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0			  
7bf0				; scan keyboard matrix and generate raw scan map  
7bf0 cd 83 7c			call matrix  
7bf3			  
7bf3				; reuse c bit 0 left modifer button - ie shift  
7bf3			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7bf3				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7bf3			  
7bf3 0e 00			ld c, 0  
7bf5			  
7bf5				; TODO set flags for modifer key presses   
7bf5				; TODO do a search for modifer key...  
7bf5			  
7bf5				;ld hl,keyscan_table_row4  
7bf5 21 25 fe			ld hl,keyscan_table_row2  
7bf8			  
7bf8 7e				ld a, (hl)  
7bf9 fe 23			cp '#'  
7bfb 20 07			jr nz, .nextmodcheck  
7bfd cb c1			set 0, c  
7bff 21 5d 7b			ld hl, .matrix_to_shift  
7c02 18 21			jr .dokeymap  
7c04				; TODO for now igonre  
7c04			.nextmodcheck:  
7c04 21 1a fe			ld hl,keyscan_table_row3  
7c07			  
7c07 7e				ld a, (hl)  
7c08 fe 23			cp '#'  
7c0a 20 07			jr nz, .nextmodcheck2  
7c0c cb c9			set 1, c   
7c0e 21 94 7b			ld hl, .matrix_to_symbolshift  
7c11 18 12			jr .dokeymap  
7c13			.nextmodcheck2:  
7c13 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7c16			  
7c16 7e				ld a, (hl)  
7c17 fe 23			cp '#'  
7c19 20 07			jr nz, .donemodcheck  
7c1b cb c9			set 1, c   
7c1d 21 5d 7b			ld hl, .matrix_to_shift  
7c20 18 03			jr .dokeymap  
7c22			  
7c22				; no modifer found so just map to normal keys  
7c22				; get mtoc map matrix to respective keys  
7c22			;	ld hl, .matrix_to_char  
7c22			;	ld hl, .matrix_to_char  
7c22			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7c22			;	ld a, KEY_SHIFT  
7c22			;	call findchar  
7c22			;  
7c22			;	; got offset to key modifer in b  
7c22			;  
7c22			;	ld hl,keyscan_table_row5  
7c22			;  
7c22			;	ld a,b  
7c22			;	call addatohl  
7c22			;	ld a,(hl)  
7c22			;  
7c22			;	cp '#'  
7c22			;	jr nz, .nextmodcheck  
7c22			;	set 0, c  
7c22			;	ld hl, .matrix_to_char  
7c22			;	jr .dokeymap  
7c22			;	; TODO for now igonre  
7c22			;.nextmodcheck:  
7c22			;	ld hl, .matrix_to_symbolshift  
7c22			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7c22			;	ld a, KEY_SYMBOLSHIFT  
7c22			;	call findchar  
7c22			;  
7c22			;  
7c22			;	; got offset to key modifer in b  
7c22			;  
7c22			;	ld hl,keyscan_table_row5  
7c22			;  
7c22			;	ld a,b  
7c22			;	call addatohl  
7c22			;	ld a,(hl)  
7c22			;  
7c22			;	cp '#'  
7c22			;	jr nz, .donemodcheck  
7c22			;	set 1, c   
7c22			;	ld hl, .matrix_to_symbolshift  
7c22			;	jr .dokeymap  
7c22			  
7c22			  
7c22			  
7c22			.donemodcheck:  
7c22				; no modifer found so just map to normal keys  
7c22				; get mtoc map matrix to respective keys  
7c22 21 26 7b			ld hl, .matrix_to_char  
7c25			  
7c25			.dokeymap:  
7c25				;ld (key_fa), c   
7c25 cd 3e 7c			call .mapkeys  
7c28			  
7c28			  
7c28			if DEBUG_KEY  
7c28			  
7c28			; Display text on first line  
7c28			            LD   A, kLCD_Line1  
7c28			            CALL fLCD_Pos       ;Position cursor to location in A  
7c28			            LD   DE, keyscan_table_row1  
7c28			            ;LD   DE, MsgHello  
7c28			            CALL fLCD_Str       ;Display string pointed to by DE  
7c28			  
7c28			; Display text on second line  
7c28			            LD   A, kLCD_Line2  
7c28			            CALL fLCD_Pos       ;Position cursor to location in A  
7c28			            LD   DE, keyscan_table_row2  
7c28			            CALL fLCD_Str       ;Display string pointed to by DE  
7c28			            LD   A, kLCD_Line3  
7c28			            CALL fLCD_Pos       ;Position cursor to location in A  
7c28			            LD   DE, keyscan_table_row3  
7c28			            CALL fLCD_Str       ;Display string pointed to by DE  
7c28			            LD   A, kLCD_Line4  
7c28			            CALL fLCD_Pos       ;Position cursor to location in A  
7c28			            LD   DE, keyscan_table_row4  
7c28			            CALL fLCD_Str       ;Display string pointed to by DE  
7c28			            LD   A, kLCD_Line1+10  
7c28			            CALL fLCD_Pos       ;Position cursor to location in A  
7c28			            LD   DE, keyscan_table_row5  
7c28			            CALL fLCD_Str       ;Display string pointed to by DE  
7c28			  
7c28				;call delay250ms  
7c28			endif  
7c28			;	jp testkey  
7c28			  
7c28			; get first char reported  
7c28			  
7c28 21 04 fe			ld hl,keyscan_table_row5  
7c2b			  
7c2b				;ld b, 46   ; 30 keys to remap + 8 nulls   
7c2b 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7c2d			.findkey:  
7c2d 7e				ld a,(hl)  
7c2e fe 00			cp 0  
7c30 28 04			jr z, .nextkey  
7c32 fe 7e			cp KEY_MATRIX_NO_PRESS  
7c34 20 06			jr nz, .foundkey  
7c36			.nextkey:  
7c36 23				inc hl  
7c37 10 f4			djnz .findkey  
7c39 3e 00			ld a,0  
7c3b c9				ret  
7c3c			.foundkey:  
7c3c 7e				ld a,(hl)  
7c3d c9				ret  
7c3e				  
7c3e			  
7c3e			; convert the raw key map given hl for destination key  
7c3e			.mapkeys:  
7c3e 11 04 fe			ld de,keyscan_table_row5  
7c41			  
7c41 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7c43			.remap:  
7c43 1a				ld a,(de)  
7c44 fe 23			cp '#'  
7c46 20 02			jr nz, .remapnext  
7c48				;CALLMONITOR  
7c48 7e				ld a,(hl)  
7c49 12				ld (de),a  
7c4a			  
7c4a			  
7c4a			  
7c4a			.remapnext:  
7c4a 23				inc hl  
7c4b 13				inc de  
7c4c 10 f5			djnz .remap  
7c4e				  
7c4e c9				ret  
7c4f			  
7c4f			  
7c4f			  
7c4f			.mtocold2:  
7c4f			  
7c4f			;	; flag if key D is held down and remove from reporting  
7c4f			;	ld bc, .key_map_fd    
7c4f			;	ld hl, keyscan_table  
7c4f			;	ld de, key_fd  
7c4f			;	call .key_shift_hold  
7c4f			;	cp 255  
7c4f			;	jr z, .cinmap  
7c4f			;	; flag if key C is held down and remove from reporting  
7c4f			;	ld bc, .key_map_fc    
7c4f			;	ld hl, keyscan_table+key_cols  
7c4f			;	ld de, key_fc  
7c4f			;	call .key_shift_hold  
7c4f			;	cp 255  
7c4f			;	jr z, .cinmap  
7c4f			;	; flag if key B is held down and remove from reporting  
7c4f			;	ld bc, .key_map_fb    
7c4f			;	ld hl, keyscan_table+(key_cols*2)  
7c4f			;	ld de, key_fb  
7c4f			;	call .key_shift_hold  
7c4f			;	cp 255  
7c4f			;	jr z, .cinmap  
7c4f			;	; flag if key A is held down and remove from reporting  
7c4f			;	ld bc, .key_map_fa    
7c4f			;	ld hl, keyscan_table+(key_cols*3)  
7c4f			;	ld de, key_fa  
7c4f			;	call .key_shift_hold  
7c4f			;	cp 255  
7c4f			;	jr z, .cinmap  
7c4f			  
7c4f 11 26 7b			ld de, .matrix_to_char  
7c52			  
7c52			  
7c52			.cinmap1:   
7c52				if DEBUG_KEY  
7c52			            LD   A, kLCD_Line4  
7c52			            CALL fLCD_Pos       ;Position cursor to location in A  
7c52					push de  
7c52			            LD   DE, keyscan_table  
7c52			            CALL fLCD_Str       ;Display string pointed to by DE  
7c52					pop de  
7c52				endif  
7c52			  
7c52				; scan key matrix table for any held key  
7c52			  
7c52				; de holds either the default matrix or one selected above  
7c52			  
7c52 21 d1 fd			ld hl, keyscan_table  
7c55 06 32			ld b,key_cols*key_rows  
7c57			  
7c57 7e			.cin11:	ld a,(hl)  
7c58 fe 23			cp '#'  
7c5a 28 08			jr z, .cinhit1  
7c5c 23				inc hl  
7c5d 13				inc de  
7c5e 05				dec b  
7c5f 20 f6			jr nz, .cin11  
7c61				; no key found held  
7c61 3e 00			ld a,0  
7c63 c9				ret  
7c64 d5			.cinhit1: push de  
7c65 e1				pop hl  
7c66 7e				ld a,(hl)  
7c67 c9				ret  
7c68			  
7c68			; flag a control key is held   
7c68			; hl is key pin, de is flag indicator  
7c68			  
7c68			.key_shift_hold1:  
7c68 c5				push bc  
7c69 3e 01			ld a, 1  
7c6b 32 fc fa			ld (cursor_shape),a  
7c6e 06 00			ld b, 0  
7c70 7e				ld a, (hl)  
7c71 fe 2e			cp '.'  
7c73 28 0a			jr z, .key_shift11  
7c75 06 ff			ld b, 255  
7c77 3e 2b			ld a, '+'    ; hide key from later scans  
7c79 77				ld (hl),a  
7c7a 3e 02			ld a, 2  
7c7c 32 fc fa			ld (cursor_shape),a  
7c7f			.key_shift11:  
7c7f				; write flag indicator  
7c7f 78				ld a,b  
7c80 12				ld (de),a  
7c81			  
7c81 d1				pop de    ; de now holds the key map ptr  
7c82 c9				ret  
7c83			  
7c83				  
7c83			  
7c83			; scans keyboard matrix and flags key press in memory array	  
7c83				  
7c83			matrix:  
7c83				;call matrix  
7c83				; TODO optimise the code....  
7c83			  
7c83			  
7c83			;ld hl, keyscan_table_row1  
7c83			;ld de, keyscan_table_row1+1  
7c83			;ld bc,46  
7c83			;ld a,KEY_MATRIX_NO_PRESS  
7c83			;ldir  
7c83			  
7c83			  
7c83			  
7c83			; reset counter  
7c83 3e 80		ld a, 128  
7c85 d3 c1		out (portbdata),a  
7c87			  
7c87 06 0a		ld b, 10  
7c89 0e 00		ld c, 0       ; current clock toggle  
7c8b			  
7c8b			.colscan:  
7c8b			  
7c8b			; set current column  
7c8b			; disable clock enable and set clock low  
7c8b			  
7c8b			;ld a, 0  
7c8b			;out (portbdata),a  
7c8b			  
7c8b			; For each column scan for switches  
7c8b			  
7c8b c5			push bc  
7c8c 21 c7 fd		ld hl, keyscan_scancol  
7c8f cd 98 7d		call .rowscan  
7c92 c1			pop bc  
7c93			  
7c93			  
7c93			; get back current column  
7c93			  
7c93			; translate the row scan  
7c93			  
7c93			;   
7c93			; row 1  
7c93			  
7c93 78			ld a,b  
7c94			  
7c94 21 3a fe		LD   hl, keyscan_table_row1+10  
7c97			  
7c97 cd e1 0f		call subafromhl  
7c9a			;call addatohl  
7c9a			  
7c9a 11 c7 fd		ld de, keyscan_scancol  
7c9d			  
7c9d 1a			ld a,(de)  
7c9e 77			ld (hl),a  
7c9f			  
7c9f			  
7c9f			  
7c9f			  
7c9f			; row 2  
7c9f			  
7c9f 78			ld a,b  
7ca0			  
7ca0 21 2f fe		LD   hl, keyscan_table_row2+10  
7ca3			  
7ca3			;call addatohl  
7ca3 cd e1 0f		call subafromhl  
7ca6			  
7ca6			  
7ca6 11 c8 fd		ld de, keyscan_scancol+1  
7ca9			  
7ca9 1a			ld a,(de)  
7caa 77			ld (hl),a  
7cab			  
7cab			  
7cab			; row 3  
7cab			  
7cab 78			ld a,b  
7cac			  
7cac 21 24 fe		LD   hl, keyscan_table_row3+10  
7caf			  
7caf			;call addatohl  
7caf cd e1 0f		call subafromhl  
7cb2			  
7cb2 11 c9 fd		ld de, keyscan_scancol+2  
7cb5			  
7cb5 1a			ld a,(de)  
7cb6 77			ld (hl),a  
7cb7			  
7cb7			  
7cb7			  
7cb7			; row 4  
7cb7			  
7cb7 78			ld a,b  
7cb8			  
7cb8 21 19 fe		LD   hl, keyscan_table_row4+10  
7cbb			  
7cbb			;call addatohl  
7cbb cd e1 0f		call subafromhl  
7cbe			  
7cbe 11 ca fd		ld de, keyscan_scancol+3  
7cc1			  
7cc1 1a			ld a,(de)  
7cc2 77			ld (hl),a  
7cc3			  
7cc3			; row 5  
7cc3			  
7cc3 78			ld a,b  
7cc4			  
7cc4 21 0e fe		LD   hl, keyscan_table_row5+10  
7cc7			  
7cc7			;call addatohl  
7cc7 cd e1 0f		call subafromhl  
7cca			  
7cca 11 cb fd		ld de, keyscan_scancol+4  
7ccd			  
7ccd 1a			ld a,(de)  
7cce 77			ld (hl),a  
7ccf			  
7ccf			; handshake next column  
7ccf			  
7ccf			  
7ccf 3e 40		ld a, 64  
7cd1 d3 c1		out (portbdata),a  
7cd3			  
7cd3 3e 00		ld a, 0  
7cd5 d3 c1		out (portbdata),a  
7cd7			  
7cd7			; toggle clk and move to next column  
7cd7			;ld a, 64  
7cd7			;cp c  
7cd7			;  
7cd7			;jr z, .coltoglow  
7cd7			;ld c, a  
7cd7			;jr .coltog  
7cd7			;.coltoglow:  
7cd7			;ld c, 0  
7cd7			;.coltog:  
7cd7			;ld a, c  
7cd7			;out (portbdata),a  
7cd7			  
7cd7 10 b2		djnz .colscan  
7cd9			  
7cd9 3e 0a		ld a,10  
7cdb 21 30 fe		LD   hl, keyscan_table_row1  
7cde cd cf 0f		call addatohl  
7ce1 3e 00		ld a, 0  
7ce3 77			ld (hl), a  
7ce4			  
7ce4			  
7ce4 3e 0a		ld a,10  
7ce6 21 25 fe		LD   hl, keyscan_table_row2  
7ce9 cd cf 0f		call addatohl  
7cec 3e 00		ld a, 0  
7cee 77			ld (hl), a  
7cef			  
7cef 3e 0a		ld a,10  
7cf1 21 1a fe		LD   hl, keyscan_table_row3  
7cf4 cd cf 0f		call addatohl  
7cf7 3e 00		ld a, 0  
7cf9 77			ld (hl), a  
7cfa			  
7cfa 3e 0a		ld a,10  
7cfc 21 0f fe		LD   hl, keyscan_table_row4  
7cff cd cf 0f		call addatohl  
7d02 3e 00		ld a, 0  
7d04 77			ld (hl), a  
7d05			  
7d05 3e 0a		ld a,10  
7d07 21 04 fe		LD   hl, keyscan_table_row5  
7d0a cd cf 0f		call addatohl  
7d0d 3e 00		ld a, 0  
7d0f 77			ld (hl), a  
7d10			  
7d10			if DEBUG_KEY_MATRIX  
7d10			  
7d10			; Display text on first line  
7d10			            LD   A, kLCD_Line1  
7d10			            CALL fLCD_Pos       ;Position cursor to location in A  
7d10			            LD   DE, keyscan_table_row1  
7d10			            ;LD   DE, MsgHello  
7d10			            CALL fLCD_Str       ;Display string pointed to by DE  
7d10			  
7d10			; Display text on second line  
7d10			            LD   A, kLCD_Line2  
7d10			            CALL fLCD_Pos       ;Position cursor to location in A  
7d10			            LD   DE, keyscan_table_row2  
7d10			            CALL fLCD_Str       ;Display string pointed to by DE  
7d10			            LD   A, kLCD_Line3  
7d10			            CALL fLCD_Pos       ;Position cursor to location in A  
7d10			            LD   DE, keyscan_table_row3  
7d10			            CALL fLCD_Str       ;Display string pointed to by DE  
7d10			            LD   A, kLCD_Line4  
7d10			            CALL fLCD_Pos       ;Position cursor to location in A  
7d10			            LD   DE, keyscan_table_row4  
7d10			            CALL fLCD_Str       ;Display string pointed to by DE  
7d10			            LD   A, kLCD_Line4+10  
7d10			            CALL fLCD_Pos       ;Position cursor to location in A  
7d10			            LD   DE, keyscan_table_row5  
7d10			            CALL fLCD_Str       ;Display string pointed to by DE  
7d10			  
7d10			;call delay250ms  
7d10				jp matrix  
7d10			endif  
7d10 c9			ret  
7d11			  
7d11			; using decade counter....  
7d11			  
7d11			  
7d11			; TODO reset decade counter to start of scan  
7d11			  
7d11			; reset 15  
7d11			; clock 14  
7d11			; ce 13  
7d11			  
7d11			; 1 - q5  
7d11			; 2 - q1  
7d11			; 3 - q0  
7d11			; 4 - q2  
7d11			; 5 - q6  
7d11			; 6 - q7  
7d11			; 7 - q3  
7d11			; 8 - vss  
7d11			; 9 - q8  
7d11			; 10 - q4  
7d11			; 11 - q9  
7d11			; 12 - cout  
7d11			; 16 - vdd  
7d11			  
7d11			; clock      ce       reset     output  
7d11			; 0          x        0         n  
7d11			; x          1        0         n  
7d11			; x          x        1         q0  
7d11			; rising     0        0         n+1  
7d11			; falling    x        0         n  
7d11			; x          rising   0         n  
7d11			; 1          falling  0         x+1  
7d11			;  
7d11			; x = dont care, if n < 5 carry = 1 otherwise 0  
7d11			  
7d11			;   
7d11			; reset   
7d11			; 13=0, 14=0, 15=1 .. 15=0  
7d11			;  
7d11			; handshake line  
7d11			; 14=1.... read line 14=0  
7d11			  
7d11			  
7d11			  
7d11			  
7d11			  
7d11			; TODO hand shake clock for next column scan  
7d11			; TODO detect each row  
7d11			  
7d11			  
7d11			  
7d11			  
7d11			; reset 128  
7d11			; clock 64  
7d11			; ce 32  
7d11			  
7d11			  
7d11			.cyclestart:  
7d11			  
7d11			; reset counter  
7d11 3e 80		ld a, 128  
7d13 d3 c1		out (portbdata),a  
7d15			  
7d15			; loop leds  
7d15 06 0a		ld b,10  
7d17			  
7d17			.cycle1:  
7d17 c5			push bc  
7d18 3e 00		ld a, 0  
7d1a d3 c1		out (portbdata),a  
7d1c cd d2 0c		call delay250ms  
7d1f			  
7d1f 3e 40		ld a, 64  
7d21 d3 c1		out (portbdata),a  
7d23 cd d2 0c		call delay250ms  
7d26			  
7d26 3e 00		ld a, 0  
7d28 d3 c1		out (portbdata),a  
7d2a cd d2 0c		call delay250ms  
7d2d			  
7d2d c1			pop bc  
7d2e 10 e7		djnz .cycle1  
7d30			  
7d30			  
7d30 18 df		jr .cyclestart  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			; map matrix key held to char on face of key  
7d32			  
7d32			;.mtocold:  
7d32			;  
7d32			;  
7d32			;; reset counter  
7d32			;ld a, 128  
7d32			;out (portbdata),a  
7d32			;  
7d32			;  
7d32			;; scan keyboard row 1  
7d32			;ld a, 0  
7d32			;out (portbdata),a  
7d32			;;ld a, 64  
7d32			;;out (portbdata),a  
7d32			;  
7d32			;  
7d32			;	ld a, 128  
7d32			;	ld hl, keyscan_table  
7d32			;	call .rowscan  
7d32			;  
7d32			;;ld a, 0  
7d32			;;out (portbdata),a  
7d32			;ld a, 64  
7d32			;out (portbdata),a  
7d32			;  
7d32			;	ld a, 64  
7d32			;	ld hl, keyscan_table+key_cols  
7d32			;	call .rowscan  
7d32			;  
7d32			;ld a, 0  
7d32			;out (portbdata),a  
7d32			;;ld a, 64  
7d32			;;out (portbdata),a  
7d32			;	ld a, 32  
7d32			;	ld hl, keyscan_table+(key_cols*2)  
7d32			;	call .rowscan  
7d32			;  
7d32			;  
7d32			;;ld a, 0  
7d32			;;out (portbdata),a  
7d32			;ld a, 64  
7d32			;out (portbdata),a  
7d32			;  
7d32			;	ld a, 16  
7d32			;	ld hl, keyscan_table+(key_cols*3)  
7d32			;	call .rowscan  
7d32			;  
7d32			;  
7d32			;	; flag if key D is held down and remove from reporting  
7d32			;	ld bc, .key_map_fd    
7d32			;	ld hl, keyscan_table  
7d32			;	ld de, key_fd  
7d32			;	call .key_shift_hold  
7d32			;	cp 255  
7d32			;	jr z, .cinmap  
7d32			;	; flag if key C is held down and remove from reporting  
7d32			;	ld bc, .key_map_fc    
7d32			;	ld hl, keyscan_table+key_cols  
7d32			;	ld de, key_fc  
7d32			;	call .key_shift_hold  
7d32			;	cp 255  
7d32			;	jr z, .cinmap  
7d32			;	; flag if key B is held down and remove from reporting  
7d32			;	ld bc, .key_map_fb    
7d32			;	ld hl, keyscan_table+(key_cols*2)  
7d32			;	ld de, key_fb  
7d32			;	call .key_shift_hold  
7d32			;	cp 255  
7d32			;	jr z, .cinmap  
7d32			;	; flag if key A is held down and remove from reporting  
7d32			;	ld bc, .key_map_fa    
7d32			;	ld hl, keyscan_table+(key_cols*3)  
7d32			;	ld de, key_fa  
7d32			;	call .key_shift_hold  
7d32			;	cp 255  
7d32			;	jr z, .cinmap  
7d32			;  
7d32			;	ld de, .matrix_to_char  
7d32			;  
7d32			;  
7d32			;.cinmap:   
7d32			;	if DEBUG_KEY  
7d32			;            LD   A, kLCD_Line4  
7d32			;            CALL fLCD_Pos       ;Position cursor to location in A  
7d32			;		push de  
7d32			;            LD   DE, keyscan_table  
7d32			;            CALL fLCD_Str       ;Display string pointed to by DE  
7d32			;		pop de  
7d32			;	endif  
7d32			  
7d32				; scan key matrix table for any held key  
7d32			  
7d32				; de holds either the default matrix or one selected above  
7d32			  
7d32			;	ld hl, keyscan_table  
7d32			;	ld b,key_cols*key_rows  
7d32			;  
7d32			;.cin1:	ld a,(hl)  
7d32			;	cp '#'  
7d32			;	jr z, .cinhit  
7d32			;	inc hl  
7d32			;	inc de  
7d32			;	dec b  
7d32			;	jr nz, .cin1  
7d32			;	; no key found held  
7d32			;	ld a,0  
7d32			;	ret  
7d32			;.cinhit: push de  
7d32			;	pop hl  
7d32			;	ld a,(hl)  
7d32			;	ret  
7d32			  
7d32			; flag a control key is held   
7d32			; hl is key pin, de is flag indicator  
7d32			  
7d32			;.key_shift_hold:  
7d32			;	push bc  
7d32			;	ld a, 1  
7d32			;	ld (cursor_shape),a  
7d32			;	ld b, 0  
7d32			;	ld a, (hl)  
7d32			;	cp '.'  
7d32			;	jr z, .key_shift1  
7d32			;	ld b, 255  
7d32			;	ld a, '+'    ; hide key from later scans  
7d32			;	ld (hl),a  
7d32			;	ld a, 2  
7d32			;	ld (cursor_shape),a  
7d32			;.key_shift1:  
7d32			;	; write flag indicator  
7d32			;	ld a,b  
7d32			;	ld (de),a  
7d32			;  
7d32			;	pop de    ; de now holds the key map ptr  
7d32			;	ret  
7d32			  
7d32				  
7d32				  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			;	push hl  
7d32			;	push de  
7d32			;	push bc  
7d32			;	call keyscan  
7d32			;	; map key matrix to ascii value of key face  
7d32			;  
7d32			;	ld hl, key_face_map  
7d32			;	ld de, keyscan_table  
7d32			;  
7d32			;	; get how many keys to look at  
7d32			;	ld b, keyscan_table_len  
7d32			;	  
7d32			;  
7d32			;	; at this stage fall out on first key hit  
7d32			;	; TODO handle multiple key press  
7d32			;  
7d32			;map1:	ld a,(hl)  
7d32			;	cp '#'  
7d32			;	jr z, keyhit  
7d32			;	inc hl  
7d32			;	inc de  
7d32			;	dec b  
7d32			;	jr nz, map1  
7d32			;nohit:	ld a, 0  
7d32			;	jr keydone  
7d32			;keyhit: push de  
7d32			;	pop hl  
7d32			;	ld a,(hl)  
7d32			;keydone:  
7d32			;	push bc  
7d32			;	push de  
7d32			; 	push hl  
7d32			;	ret   
7d32			;  
7d32			  
7d32			  
7d32			  
7d32			  
7d32			; scan physical key matrix  
7d32			  
7d32			  
7d32			;keyscan:  
7d32			;  
7d32			;; for each key_row use keyscanr bit mask for out  
7d32			;; then read in for keyscanc bitmask  
7d32			;; save result of row scan to keyscantable  
7d32			;  
7d32			;; scan keyboard row 1  
7d32			;  
7d32			;	ld b, key_rows  
7d32			;	ld hl, key_scanr  
7d32			;	ld de, keyscan_table  
7d32			;  
7d32			;rowloop:  
7d32			;  
7d32			;	ld a,(hl)		; out bit mask to energise keyboard row  
7d32			;	call rowscan  
7d32			;	inc hl  
7d32			;	dec b  
7d32			;	jr nz, rowloop  
7d32			;  
7d32			;	ret  
7d32			;  
7d32			;  
7d32			;; pass a out bitmask, b row number  
7d32			;arowscan:   
7d32			;	push bc  
7d32			;  
7d32			;	ld d, b  
7d32			;  
7d32			;	; calculate buffer location for this row  
7d32			;  
7d32			;	ld hl, keyscan_table	  
7d32			;kbufr:  ld e, key_cols  
7d32			;kbufc:	inc hl  
7d32			;	dec e  
7d32			;	jr nz, kbufc  
7d32			;	dec d  
7d32			;	jr nz, kbufr  
7d32			;  
7d32			;	; energise row and read columns  
7d32			;  
7d32			;	out (portbdata),a  
7d32			;	in a,(portbdata)  
7d32			;	ld c,a  
7d32			;  
7d32			;  
7d32			;	; save buffer loc  
7d32			;  
7d32			;	ld (keybufptr), hl  
7d32			;  
7d32			;	ld hl, key_scanc  
7d32			;	ld d, key_cols  
7d32			;  
7d32			;	; for each column check each bit mask  
7d32			;  
7d32			;colloop:  
7d32			;	  
7d32			;  
7d32			;	; reset flags for the row   
7d32			;  
7d32			;	ld b,'.'  
7d32			;	and (hl)  
7d32			;	jr z, maskskip  
7d32			;	ld b,'#'  
7d32			;maskskip:  
7d32			;	; save  key state  
7d32			;	push hl  
7d32			;	ld hl, (keybufptr)  
7d32			;	ld (hl), b  
7d32			;	inc hl  
7d32			;	ld (keybufptr), hl  
7d32			;  
7d32			;	; move to next bit mask  
7d32			;	pop hl  
7d32			;	inc hl  
7d32			;  
7d32			;	dec d  
7d32			;	jr nz, colloop  
7d32			;  
7d32			;	ret  
7d32			;  
7d32			;  
7d32			;;  
7d32			; lcd functions  
7d32			;  
7d32			;  
7d32			  
7d32			;if DEBUG_KEY_MATRIX  
7d32			  
7d32			; test function to display hardware view of matrix state  
7d32			  
7d32			matrixold:  
7d32			  
7d32			  
7d32			  
7d32			; reset counter  
7d32 3e 80		ld a, 128  
7d34 d3 c1		out (portbdata),a  
7d36			; scan keyboard row 1  
7d36 3e 00		ld a, 0  
7d38 d3 c1		out (portbdata),a  
7d3a			;ld a, 64  
7d3a			;out (portbdata),a  
7d3a 3e 80			ld a, 128  
7d3c 21 30 fe			ld hl, keyscan_table_row1  
7d3f cd 98 7d			call .rowscan  
7d42			  
7d42			;ld a, 0  
7d42			;out (portbdata),a  
7d42 3e 40		ld a, 64  
7d44 d3 c1		out (portbdata),a  
7d46 3e 40			ld a, 64  
7d48 21 25 fe			ld hl, keyscan_table_row2  
7d4b cd 98 7d			call .rowscan  
7d4e			  
7d4e 3e 00		ld a, 0  
7d50 d3 c1		out (portbdata),a  
7d52			;ld a, 64  
7d52			;out (portbdata),a  
7d52 3e 20			ld a, 32  
7d54 21 1a fe			ld hl, keyscan_table_row3  
7d57 cd 98 7d			call .rowscan  
7d5a			  
7d5a			;ld a, 0  
7d5a			;out (portbdata),a  
7d5a 3e 40		ld a, 64  
7d5c d3 c1		out (portbdata),a  
7d5e 3e 10			ld a, 16  
7d60 21 0f fe			ld hl, keyscan_table_row4  
7d63 cd 98 7d			call .rowscan  
7d66			  
7d66			; Display text on first line  
7d66 3e 00		            LD   A, kLCD_Line1  
7d68 cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
7d6b 11 30 fe		            LD   DE, keyscan_table_row1  
7d6e			            ;LD   DE, MsgHello  
7d6e cd c2 79		            CALL fLCD_Str       ;Display string pointed to by DE  
7d71			  
7d71			; Display text on second line  
7d71 3e 28		            LD   A, kLCD_Line2  
7d73 cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
7d76 11 25 fe		            LD   DE, keyscan_table_row2  
7d79 cd c2 79		            CALL fLCD_Str       ;Display string pointed to by DE  
7d7c 3e 50		            LD   A, kLCD_Line3  
7d7e cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
7d81 11 1a fe		            LD   DE, keyscan_table_row3  
7d84 cd c2 79		            CALL fLCD_Str       ;Display string pointed to by DE  
7d87 3e 78		            LD   A, kLCD_Line4  
7d89 cd a0 79		            CALL fLCD_Pos       ;Position cursor to location in A  
7d8c 11 0f fe		            LD   DE, keyscan_table_row4  
7d8f cd c2 79		            CALL fLCD_Str       ;Display string pointed to by DE  
7d92			  
7d92 cd d2 0c			call delay250ms  
7d95 c3 83 7c			jp matrix  
7d98			  
7d98			; pass de as row display flags  
7d98			.rowscan:   
7d98			;	out (portbdata),a  
7d98 db c1			in a,(portbdata)  
7d9a 4f				ld c,a  
7d9b				; reset flags for the row   
7d9b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7d9d e6 01			and 1  
7d9f 28 02			jr z, .p1on  
7da1 06 23			ld b,'#'  
7da3			.p1on:  
7da3 70				ld (hl), b  
7da4 23				inc hl  
7da5			  
7da5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7da7 79				ld a,c  
7da8 e6 02			and 2  
7daa			;	bit 0,a  
7daa 28 02			jr z, .p2on  
7dac 06 23			ld b,'#'  
7dae			.p2on:  
7dae 70				ld (hl), b  
7daf 23				inc hl  
7db0			;  
7db0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7db2 79				ld a,c  
7db3 e6 04			and 4  
7db5			;;	bit 0,a  
7db5 28 02			jr z, .p3on  
7db7 06 23			ld b,'#'  
7db9			.p3on:  
7db9 70				ld (hl), b  
7dba 23				inc hl  
7dbb			;;  
7dbb 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7dbd			;;	bit 0,a  
7dbd 79				ld a,c  
7dbe e6 08			and 8  
7dc0 28 02			jr z, .p4on  
7dc2 06 23			ld b,'#'  
7dc4			.p4on:  
7dc4 70				ld (hl), b  
7dc5 23				inc hl  
7dc6			  
7dc6 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7dc8			;;	bit 0,a  
7dc8 79				ld a,c  
7dc9 e6 10			and 16  
7dcb 28 02			jr z, .p5on  
7dcd 06 23			ld b,'#'  
7dcf			.p5on:  
7dcf 70				ld (hl), b  
7dd0 23				inc hl  
7dd1			; zero term  
7dd1 06 00			ld b,0  
7dd3 70				ld (hl), b  
7dd4			  
7dd4 c9			.rscandone: ret  
7dd5			  
7dd5			;addatohl:  
7dd5			;  
7dd5			 ;add   a, l    ; A = A+L  
7dd5			  ;  ld    l, a    ; L = A+L  
7dd5			   ; adc   a, h    ; A = A+L+H+carry  
7dd5			   ; sub   l       ; A = H+carry  
7dd5			   ; ld    h, a    ; H = H+carry  
7dd5			  
7dd5			;ret  
7dd5			; eof  
# End of file firmware_key_5x10.asm
7dd5			;include "firmware_key_4x10.asm" 
7dd5			 
7dd5			heap_size:    equ heap_end - heap_start 
7dd5			;eof 
# End of file os_mega.asm
7dd5
