# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 ca 94			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 c6 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 05 ee				ld hl, display_fb1  
800b 22 61 ed				ld (display_fb_active), hl  
800e			  
800e cd 7a 88				call clear_display  
8011			  
8011 21 63 ed				ld hl, display_fb2  
8014 22 61 ed				ld (display_fb_active), hl  
8017			  
8017 cd 7a 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 56 ee				ld hl, display_fb0  
801d 22 61 ed				ld (display_fb_active), hl  
8020			  
8020 cd 7a 88				call clear_display  
8023			  
8023			  
8023 cd bc d7				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 5e d8			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 4a 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 9d 88			call update_display  
8032 cd fa 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 7f 88			call fill_display  
803a cd 9d 88			call update_display  
803d cd fa 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 7f 88			call fill_display  
8045 cd 9d 88			call update_display  
8048 cd fa 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 7f 88			call fill_display  
8050 cd 9d 88			call update_display  
8053 cd fa 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056 3e 00		        ld a, display_row_1    
8058			else  
8058			        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 8d 88			call str_at_display  
805e cd 9d 88			call update_display  
8061			  
8061			  
8061 cd fa 87			call delay1s  
8064 cd fa 87			call delay1s  
8067			if display_cols == 20	  
8067 3e 2a		            LD   A, display_row_3+2  
8069			else  
8069			            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 8d 88			call str_at_display  
806f cd 9d 88			call update_display  
8072 cd fa 87			call delay1s  
8075 cd fa 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 c0 ee		ld (debug_mark),a  
807d 32 c1 ee		ld (debug_mark+1),a  
8080 32 c2 ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 c3 ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 c0 ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 c1 ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 c2 ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd f4 92			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 c0 ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 c1 ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 c2 ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd f4 92			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d2 83			call storage_findnextid 
8105			 
8105 cd d0 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 eb ec			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a ed ec			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 c0 ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 c1 ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 c2 ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd f4 92			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 c0 ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 c1 ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 c2 ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd f4 92			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 eb ec			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 c0 ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 c1 ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 c2 ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 eb ec				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd f4 92			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a ec ec			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 c0 ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 c1 ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 c2 ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd f4 92			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 c0 ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 c1 ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 c2 ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd f4 92			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd bd 87			call storage_clear_page 
81d3			 
81d3 21 eb ec			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 ec ec		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 ee ec		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 f7 ec			ld hl, store_page+3+9 
81ed 3a d0 ec			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 eb ec			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 c0 ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 c1 ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 c2 ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd f4 92			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 c0 ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 c1 ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 c2 ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd f4 92			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd df 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd df 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd a7 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd df 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd df 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd a7 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 c0 ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 c1 ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 c2 ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd f4 92			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 ee ec		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 c0 ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 c1 ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 c2 ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd f4 92			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 eb ec			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 c0 ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 c1 ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 c2 ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd f4 92			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 c0 ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 c1 ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 c2 ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd f4 92			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d2 83			call storage_findnextid 
8316			 
8316 e5				push hl 
8317			 
8317				; TODO check file not found 
8317			 
8317 11 eb ec			ld de, store_page 
831a cd b1 80			call storage_read_block 
831d			 
831d					if DEBUG_FORTH_WORDS 
831d						DMARK "ER1" 
831d f5				push af  
831e 3a 32 83			ld a, (.dmark)  
8321 32 c0 ee			ld (debug_mark),a  
8324 3a 33 83			ld a, (.dmark+1)  
8327 32 c1 ee			ld (debug_mark+1),a  
832a 3a 34 83			ld a, (.dmark+2)  
832d 32 c2 ee			ld (debug_mark+2),a  
8330 18 03			jr .pastdmark  
8332 ..			.dmark: db "ER1"  
8335 f1			.pastdmark: pop af  
8336			endm  
# End of macro DMARK
8336						CALLMONITOR 
8336 cd f4 92			call break_point_state  
8339				endm  
# End of macro CALLMONITOR
8339					endif 
8339 3a eb ec			ld a, (store_page)	; get file id 
833c 32 e4 ec			ld (store_tmpid), a 
833f			 
833f 3a ed ec			ld a, (store_page+2)    ; get count of extends 
8342 32 e3 ec			ld (store_tmpext), a 
8345			 
8345				; wipe file header 
8345			 
8345 e1				pop hl 
8346 3e 00			ld a, 0 
8348 32 eb ec			ld (store_page), a 
834b 32 ec ec			ld (store_page+1),a 
834e 11 eb ec			ld de, store_page 
8351					if DEBUG_FORTH_WORDS 
8351						DMARK "ER2" 
8351 f5				push af  
8352 3a 66 83			ld a, (.dmark)  
8355 32 c0 ee			ld (debug_mark),a  
8358 3a 67 83			ld a, (.dmark+1)  
835b 32 c1 ee			ld (debug_mark+1),a  
835e 3a 68 83			ld a, (.dmark+2)  
8361 32 c2 ee			ld (debug_mark+2),a  
8364 18 03			jr .pastdmark  
8366 ..			.dmark: db "ER2"  
8369 f1			.pastdmark: pop af  
836a			endm  
# End of macro DMARK
836a						CALLMONITOR 
836a cd f4 92			call break_point_state  
836d				endm  
# End of macro CALLMONITOR
836d					endif 
836d cd 16 81			call storage_write_block 
8370			 
8370			 
8370				; wipe file extents 
8370			 
8370 3a e3 ec			ld a, (store_tmpext) 
8373 47				ld b, a 
8374			 
8374			.eraext:	  
8374 c5				push bc 
8375			 
8375 21 40 00			ld hl, STORE_BLOCK_PHY 
8378 3a e4 ec			ld a,(store_tmpid) 
837b 5f				ld e, a 
837c 50				ld d, b	 
837d					if DEBUG_FORTH_WORDS 
837d						DMARK "ER3" 
837d f5				push af  
837e 3a 92 83			ld a, (.dmark)  
8381 32 c0 ee			ld (debug_mark),a  
8384 3a 93 83			ld a, (.dmark+1)  
8387 32 c1 ee			ld (debug_mark+1),a  
838a 3a 94 83			ld a, (.dmark+2)  
838d 32 c2 ee			ld (debug_mark+2),a  
8390 18 03			jr .pastdmark  
8392 ..			.dmark: db "ER3"  
8395 f1			.pastdmark: pop af  
8396			endm  
# End of macro DMARK
8396						CALLMONITOR 
8396 cd f4 92			call break_point_state  
8399				endm  
# End of macro CALLMONITOR
8399					endif 
8399 cd d2 83			call storage_findnextid 
839c			 
839c e5				push hl 
839d 11 eb ec			ld de, store_page 
83a0 cd b1 80			call storage_read_block 
83a3			 
83a3				; free block	 
83a3			 
83a3 3e 00			ld a, 0 
83a5 32 eb ec			ld (store_page), a 
83a8 32 ec ec			ld (store_page+1),a 
83ab 11 eb ec			ld de, store_page 
83ae e1				pop hl 
83af					if DEBUG_FORTH_WORDS 
83af						DMARK "ER4" 
83af f5				push af  
83b0 3a c4 83			ld a, (.dmark)  
83b3 32 c0 ee			ld (debug_mark),a  
83b6 3a c5 83			ld a, (.dmark+1)  
83b9 32 c1 ee			ld (debug_mark+1),a  
83bc 3a c6 83			ld a, (.dmark+2)  
83bf 32 c2 ee			ld (debug_mark+2),a  
83c2 18 03			jr .pastdmark  
83c4 ..			.dmark: db "ER4"  
83c7 f1			.pastdmark: pop af  
83c8			endm  
# End of macro DMARK
83c8						CALLMONITOR 
83c8 cd f4 92			call break_point_state  
83cb				endm  
# End of macro CALLMONITOR
83cb					endif 
83cb cd 16 81			call storage_write_block 
83ce			 
83ce c1				pop bc 
83cf 10 a3			djnz .eraext 
83d1			 
83d1 c9				ret 
83d2			 
83d2			 
83d2			; Find Free Block 
83d2			; --------------- 
83d2			; 
83d2			; With current bank 
83d2			;  
83d2			; From given starting logical block 
83d2			;    Read block  
83d2			;    If no file id 
83d2			;         Return block id 
83d2			 
83d2			 
83d2			; hl starting page number 
83d2			; hl contains free page number or zero if no pages free 
83d2			; e contains the file id to locate 
83d2			; d contains the block number 
83d2			 
83d2			; TODO change to find file id and use zero for free block 
83d2			 
83d2			storage_findnextid: 
83d2			 
83d2				; now locate first 0 page to mark as a free block 
83d2			 
83d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d4			;	ld hl, STORE_BLOCK_PHY 
83d4			 
83d4					if DEBUG_FORTH_WORDS 
83d4					DMARK "FNI" 
83d4 f5				push af  
83d5 3a e9 83			ld a, (.dmark)  
83d8 32 c0 ee			ld (debug_mark),a  
83db 3a ea 83			ld a, (.dmark+1)  
83de 32 c1 ee			ld (debug_mark+1),a  
83e1 3a eb 83			ld a, (.dmark+2)  
83e4 32 c2 ee			ld (debug_mark+2),a  
83e7 18 03			jr .pastdmark  
83e9 ..			.dmark: db "FNI"  
83ec f1			.pastdmark: pop af  
83ed			endm  
# End of macro DMARK
83ed						CALLMONITOR 
83ed cd f4 92			call break_point_state  
83f0				endm  
# End of macro CALLMONITOR
83f0					endif 
83f0			.ff1:   	 
83f0 e5					push hl 
83f1 c5					push bc 
83f2 d5					push de 
83f3 cd ae 80				call se_readbyte 
83f6 5f					ld e,a 
83f7 23					inc hl 
83f8 cd ae 80				call se_readbyte 
83fb 57					ld d, a 
83fc e1					pop hl 
83fd e5					push hl 
83fe cd c5 8a				call cmp16 
8401 28 49				jr z, .fffound 
8403			 
8403 d1					pop de 
8404 c1					pop bc 
8405 e1					pop hl 
8406			 
8406					; is found? 
8406					;cp e 
8406					;ret z 
8406			 
8406 3e 40				ld a, STORE_BLOCK_PHY 
8408 cd a7 8a				call addatohl 
840b 10 e3				djnz .ff1 
840d			 
840d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
840f			.ff2:   	 
840f			 
840f e5					push hl 
8410 c5					push bc 
8411 d5					push de 
8412 cd ae 80				call se_readbyte 
8415 5f					ld e,a 
8416 23					inc hl 
8417 cd ae 80				call se_readbyte 
841a 57					ld d, a 
841b			 
841b e1					pop hl 
841c e5					push hl 
841d cd c5 8a				call cmp16 
8420 28 2a				jr z, .fffound 
8422			 
8422 d1					pop de 
8423 c1					pop bc 
8424 e1					pop hl 
8425					; is found? 
8425					;cp e 
8425					;ret z 
8425			 
8425 3e 40				ld a, STORE_BLOCK_PHY 
8427 cd a7 8a				call addatohl 
842a 10 e3				djnz .ff2 
842c			 
842c			 
842c					if DEBUG_FORTH_WORDS 
842c					DMARK "FN-" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 c0 ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 c1 ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 c2 ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "FN-"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445					;	push af 
8445					;	ld a, 'n' 
8445					;	ld (debug_mark),a 
8445					;	pop af 
8445						CALLMONITOR 
8445 cd f4 92			call break_point_state  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448				; no free marks! 
8448 21 00 00				ld hl, 0 
844b c9				ret 
844c			.fffound: 
844c				 
844c			 
844c d1					pop de 
844d c1					pop bc 
844e e1					pop hl 
844f					if DEBUG_FORTH_WORDS 
844f					DMARK "FNF" 
844f f5				push af  
8450 3a 64 84			ld a, (.dmark)  
8453 32 c0 ee			ld (debug_mark),a  
8456 3a 65 84			ld a, (.dmark+1)  
8459 32 c1 ee			ld (debug_mark+1),a  
845c 3a 66 84			ld a, (.dmark+2)  
845f 32 c2 ee			ld (debug_mark+2),a  
8462 18 03			jr .pastdmark  
8464 ..			.dmark: db "FNF"  
8467 f1			.pastdmark: pop af  
8468			endm  
# End of macro DMARK
8468					;	push af 
8468					;	ld a, 'n' 
8468					;	ld (debug_mark),a 
8468					;	pop af 
8468						CALLMONITOR 
8468 cd f4 92			call break_point_state  
846b				endm  
# End of macro CALLMONITOR
846b					endif 
846b c9				ret 
846c			 
846c			 
846c			 
846c			; Free Space 
846c			; ---------- 
846c			; 
846c			; With current bank 
846c			; 
846c			; Set block count to zero 
846c			; Starting with first logical block 
846c			;      Find free block  
846c			;      If block id given, increment block count 
846c			; 
846c			;  
846c			 
846c			 
846c			; hl contains count of free blocks 
846c			 
846c			storage_freeblocks: 
846c			 
846c				; now locate first 0 page to mark as a free block 
846c			 
846c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
846e 21 40 00			ld hl, STORE_BLOCK_PHY 
8471 11 00 00			ld de, 0 
8474			 
8474			.fb1:   	 
8474 e5					push hl 
8475 c5					push bc 
8476 d5					push de 
8477 cd ae 80				call se_readbyte 
847a d1					pop de 
847b c1					pop bc 
847c e1					pop hl 
847d			 
847d					; is free? 
847d fe 00				cp 0 
847f 20 01				jr nz, .ff1cont 
8481 13					inc de 
8482			 
8482			.ff1cont: 
8482			 
8482			 
8482 3e 40				ld a, STORE_BLOCK_PHY 
8484 cd a7 8a				call addatohl 
8487 10 eb				djnz .fb1 
8489			 
8489 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848b			.fb2:   	 
848b e5					push hl 
848c c5					push bc 
848d d5					push de 
848e cd ae 80				call se_readbyte 
8491 d1					pop de 
8492 c1					pop bc 
8493 e1					pop hl 
8494			 
8494					; is free? 
8494 fe 00				cp 0 
8496 20 01				jr nz, .ff2cont 
8498 13					inc de 
8499			 
8499			.ff2cont: 
8499			 
8499 3e 40				ld a, STORE_BLOCK_PHY 
849b cd a7 8a				call addatohl 
849e 10 eb				djnz .fb2 
84a0			 
84a0 eb				ex de, hl 
84a1 c9				ret 
84a2			 
84a2			; Get File ID 
84a2			; ----------- 
84a2			; 
84a2			; With current bank 
84a2			;  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; For each logical block 
84a2			;    Read block file id 
84a2			;      If first block of file and dont have file id 
84a2			;         if file get id and exit 
84a2			 
84a2			 
84a2			 
84a2			 
84a2			; Create File 
84a2			; ----------- 
84a2			; 
84a2			; With current bank  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; Increment file id number 
84a2			; Save Config 
84a2			; Find free block 
84a2			; Set buffer with file name and file id 
84a2			; Write buffer to free block  
84a2			 
84a2			 
84a2			; hl point to file name 
84a2			; hl returns file id 
84a2			 
84a2			; file format: 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent number 
84a2			; byte 2-> data 
84a2			 
84a2			; format for extent number 0: 
84a2			; 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent 0 
84a2			; byte 2 - extent count 
84a2			; byte 3 -> file name and meta data 
84a2			 
84a2			 
84a2			storage_create: 
84a2				if DEBUG_STORESE 
84a2					DMARK "SCR" 
84a2 f5				push af  
84a3 3a b7 84			ld a, (.dmark)  
84a6 32 c0 ee			ld (debug_mark),a  
84a9 3a b8 84			ld a, (.dmark+1)  
84ac 32 c1 ee			ld (debug_mark+1),a  
84af 3a b9 84			ld a, (.dmark+2)  
84b2 32 c2 ee			ld (debug_mark+2),a  
84b5 18 03			jr .pastdmark  
84b7 ..			.dmark: db "SCR"  
84ba f1			.pastdmark: pop af  
84bb			endm  
# End of macro DMARK
84bb					CALLMONITOR 
84bb cd f4 92			call break_point_state  
84be				endm  
# End of macro CALLMONITOR
84be				endif 
84be			 
84be e5				push hl		; save file name pointer 
84bf			 
84bf cd 62 81			call storage_get_block_0 
84c2			 
84c2 3a eb ec			ld a,(store_page)	; get current file id 
84c5 3c				inc a 
84c6 32 eb ec			ld (store_page),a 
84c9				 
84c9 32 e4 ec			ld (store_tmpid),a			; save id 
84cc			 
84cc 21 00 00			ld hl, 0 
84cf 11 eb ec			ld de, store_page 
84d2				if DEBUG_STORESE 
84d2					DMARK "SCw" 
84d2 f5				push af  
84d3 3a e7 84			ld a, (.dmark)  
84d6 32 c0 ee			ld (debug_mark),a  
84d9 3a e8 84			ld a, (.dmark+1)  
84dc 32 c1 ee			ld (debug_mark+1),a  
84df 3a e9 84			ld a, (.dmark+2)  
84e2 32 c2 ee			ld (debug_mark+2),a  
84e5 18 03			jr .pastdmark  
84e7 ..			.dmark: db "SCw"  
84ea f1			.pastdmark: pop af  
84eb			endm  
# End of macro DMARK
84eb					CALLMONITOR 
84eb cd f4 92			call break_point_state  
84ee				endm  
# End of macro CALLMONITOR
84ee				endif 
84ee cd 16 81			call storage_write_block	 ; save update 
84f1			 
84f1				if DEBUG_STORESE 
84f1 11 eb ec				ld de, store_page 
84f4					DMARK "SCC" 
84f4 f5				push af  
84f5 3a 09 85			ld a, (.dmark)  
84f8 32 c0 ee			ld (debug_mark),a  
84fb 3a 0a 85			ld a, (.dmark+1)  
84fe 32 c1 ee			ld (debug_mark+1),a  
8501 3a 0b 85			ld a, (.dmark+2)  
8504 32 c2 ee			ld (debug_mark+2),a  
8507 18 03			jr .pastdmark  
8509 ..			.dmark: db "SCC"  
850c f1			.pastdmark: pop af  
850d			endm  
# End of macro DMARK
850d					CALLMONITOR 
850d cd f4 92			call break_point_state  
8510				endm  
# End of macro CALLMONITOR
8510				endif 
8510				;  
8510				 
8510 21 40 00			ld hl, STORE_BLOCK_PHY 
8513 11 00 00			ld de, 0 
8516 cd d2 83			call storage_findnextid 
8519			 
8519 22 d5 ec			ld (store_tmppageid), hl    ; save page to use  
851c			 
851c				; TODO detect 0 = no spare blocks 
851c			 
851c				; hl now contains the free page to use for the file header page 
851c			 
851c				if DEBUG_STORESE 
851c				DMARK "SCF" 
851c f5				push af  
851d 3a 31 85			ld a, (.dmark)  
8520 32 c0 ee			ld (debug_mark),a  
8523 3a 32 85			ld a, (.dmark+1)  
8526 32 c1 ee			ld (debug_mark+1),a  
8529 3a 33 85			ld a, (.dmark+2)  
852c 32 c2 ee			ld (debug_mark+2),a  
852f 18 03			jr .pastdmark  
8531 ..			.dmark: db "SCF"  
8534 f1			.pastdmark: pop af  
8535			endm  
# End of macro DMARK
8535					CALLMONITOR 
8535 cd f4 92			call break_point_state  
8538				endm  
# End of macro CALLMONITOR
8538				endif 
8538			 
8538 22 d5 ec			ld (store_tmppageid), hl 
853b				 
853b 3a e4 ec			ld a,(store_tmpid)    ; get file id 
853e			;	ld a, (store_filecache)			; save to cache 
853e			 
853e 32 eb ec			ld (store_page),a    ; set page id 
8541 3e 00			ld a, 0			 ; extent 0 is file header 
8543 32 ec ec			ld (store_page+1), a   ; set file extent 
8546			 
8546 32 ed ec			ld (store_page+2), a   ; extent count for the file 
8549			 
8549			;	inc hl 		; init block 0 of file 
8549			;	inc hl   		; skip file and extent id 
8549			 ;       ld a, 0 
8549			;	ld (hl),a 
8549			;	ld a, (store_filecache+1)  	; save to cache 
8549			 
8549			;	inc hl    ; file name 
8549				 
8549				 
8549 11 ee ec			ld de, store_page+3    ; get buffer for term string to use as file name 
854c				if DEBUG_STORESE 
854c					DMARK "SCc" 
854c f5				push af  
854d 3a 61 85			ld a, (.dmark)  
8550 32 c0 ee			ld (debug_mark),a  
8553 3a 62 85			ld a, (.dmark+1)  
8556 32 c1 ee			ld (debug_mark+1),a  
8559 3a 63 85			ld a, (.dmark+2)  
855c 32 c2 ee			ld (debug_mark+2),a  
855f 18 03			jr .pastdmark  
8561 ..			.dmark: db "SCc"  
8564 f1			.pastdmark: pop af  
8565			endm  
# End of macro DMARK
8565					CALLMONITOR 
8565 cd f4 92			call break_point_state  
8568				endm  
# End of macro CALLMONITOR
8568				endif 
8568 e1				pop hl    ; get zero term string 
8569 e5				push hl 
856a 3e 00			ld a, 0 
856c cd 10 8f			call strlent 
856f 23				inc hl   ; cover zero term 
8570 06 00			ld b,0 
8572 4d				ld c,l 
8573 e1				pop hl 
8574				;ex de, hl 
8574				if DEBUG_STORESE 
8574					DMARK "SCa" 
8574 f5				push af  
8575 3a 89 85			ld a, (.dmark)  
8578 32 c0 ee			ld (debug_mark),a  
857b 3a 8a 85			ld a, (.dmark+1)  
857e 32 c1 ee			ld (debug_mark+1),a  
8581 3a 8b 85			ld a, (.dmark+2)  
8584 32 c2 ee			ld (debug_mark+2),a  
8587 18 03			jr .pastdmark  
8589 ..			.dmark: db "SCa"  
858c f1			.pastdmark: pop af  
858d			endm  
# End of macro DMARK
858d					;push af 
858d					;ld a, 'a' 
858d					;ld (debug_mark),a 
858d					;pop af 
858d					CALLMONITOR 
858d cd f4 92			call break_point_state  
8590				endm  
# End of macro CALLMONITOR
8590				endif 
8590 ed b0			ldir    ; copy zero term string 
8592				if DEBUG_STORESE 
8592					DMARK "SCA" 
8592 f5				push af  
8593 3a a7 85			ld a, (.dmark)  
8596 32 c0 ee			ld (debug_mark),a  
8599 3a a8 85			ld a, (.dmark+1)  
859c 32 c1 ee			ld (debug_mark+1),a  
859f 3a a9 85			ld a, (.dmark+2)  
85a2 32 c2 ee			ld (debug_mark+2),a  
85a5 18 03			jr .pastdmark  
85a7 ..			.dmark: db "SCA"  
85aa f1			.pastdmark: pop af  
85ab			endm  
# End of macro DMARK
85ab					CALLMONITOR 
85ab cd f4 92			call break_point_state  
85ae				endm  
# End of macro CALLMONITOR
85ae				endif 
85ae			 
85ae				; write file header page 
85ae			 
85ae 2a d5 ec			ld hl,(store_tmppageid) 
85b1 11 eb ec			ld de, store_page 
85b4				if DEBUG_STORESE 
85b4					DMARK "SCb" 
85b4 f5				push af  
85b5 3a c9 85			ld a, (.dmark)  
85b8 32 c0 ee			ld (debug_mark),a  
85bb 3a ca 85			ld a, (.dmark+1)  
85be 32 c1 ee			ld (debug_mark+1),a  
85c1 3a cb 85			ld a, (.dmark+2)  
85c4 32 c2 ee			ld (debug_mark+2),a  
85c7 18 03			jr .pastdmark  
85c9 ..			.dmark: db "SCb"  
85cc f1			.pastdmark: pop af  
85cd			endm  
# End of macro DMARK
85cd					;push af 
85cd					;ld a, 'b' 
85cd					;ld (debug_mark),a 
85cd					;pop af 
85cd					CALLMONITOR 
85cd cd f4 92			call break_point_state  
85d0				endm  
# End of macro CALLMONITOR
85d0				endif 
85d0 cd 16 81			call storage_write_block 
85d3			 
85d3 3a e4 ec			ld a, (store_tmpid) 
85d6 6f				ld l, a 
85d7 26 00			ld h,0 
85d9				if DEBUG_STORESE 
85d9					DMARK "SCz" 
85d9 f5				push af  
85da 3a ee 85			ld a, (.dmark)  
85dd 32 c0 ee			ld (debug_mark),a  
85e0 3a ef 85			ld a, (.dmark+1)  
85e3 32 c1 ee			ld (debug_mark+1),a  
85e6 3a f0 85			ld a, (.dmark+2)  
85e9 32 c2 ee			ld (debug_mark+2),a  
85ec 18 03			jr .pastdmark  
85ee ..			.dmark: db "SCz"  
85f1 f1			.pastdmark: pop af  
85f2			endm  
# End of macro DMARK
85f2					CALLMONITOR 
85f2 cd f4 92			call break_point_state  
85f5				endm  
# End of macro CALLMONITOR
85f5				endif 
85f5 c9				ret 
85f6				 
85f6			 
85f6			 
85f6			; 
85f6			; Read File 
85f6			; 
85f6			; h - file id to locate 
85f6			; l - extent to locate 
85f6			; de - pointer to string to read into 
85f6			; 
85f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85f6			storage_read: 
85f6 d5				push de 
85f7			 
85f7			; TODO BUG the above push is it popped before the RET Z? 
85f7			 
85f7			; TODO how to handle multiple part blocks 
85f7			 
85f7				; locate file extent to read 
85f7			 
85f7 5c				ld e, h 
85f8 55				ld d, l 
85f9 21 40 00			ld hl, STORE_BLOCK_PHY 
85fc				if DEBUG_STORESE 
85fc					DMARK "SRE" 
85fc f5				push af  
85fd 3a 11 86			ld a, (.dmark)  
8600 32 c0 ee			ld (debug_mark),a  
8603 3a 12 86			ld a, (.dmark+1)  
8606 32 c1 ee			ld (debug_mark+1),a  
8609 3a 13 86			ld a, (.dmark+2)  
860c 32 c2 ee			ld (debug_mark+2),a  
860f 18 03			jr .pastdmark  
8611 ..			.dmark: db "SRE"  
8614 f1			.pastdmark: pop af  
8615			endm  
# End of macro DMARK
8615					CALLMONITOR 
8615 cd f4 92			call break_point_state  
8618				endm  
# End of macro CALLMONITOR
8618				endif 
8618 cd d2 83			call storage_findnextid 
861b			 
861b				if DEBUG_STORESE 
861b					DMARK "SRf" 
861b f5				push af  
861c 3a 30 86			ld a, (.dmark)  
861f 32 c0 ee			ld (debug_mark),a  
8622 3a 31 86			ld a, (.dmark+1)  
8625 32 c1 ee			ld (debug_mark+1),a  
8628 3a 32 86			ld a, (.dmark+2)  
862b 32 c2 ee			ld (debug_mark+2),a  
862e 18 03			jr .pastdmark  
8630 ..			.dmark: db "SRf"  
8633 f1			.pastdmark: pop af  
8634			endm  
# End of macro DMARK
8634					CALLMONITOR 
8634 cd f4 92			call break_point_state  
8637				endm  
# End of macro CALLMONITOR
8637				endif 
8637 cd d0 8a			call ishlzero 
863a			;	ld a, l 
863a			;	add h 
863a			;	cp 0 
863a c8				ret z			; block not found so EOF 
863b			 
863b				; hl contains page number to load 
863b d1				pop de   ; get storage 
863c d5				push de 
863d				if DEBUG_STORESE 
863d					DMARK "SRg" 
863d f5				push af  
863e 3a 52 86			ld a, (.dmark)  
8641 32 c0 ee			ld (debug_mark),a  
8644 3a 53 86			ld a, (.dmark+1)  
8647 32 c1 ee			ld (debug_mark+1),a  
864a 3a 54 86			ld a, (.dmark+2)  
864d 32 c2 ee			ld (debug_mark+2),a  
8650 18 03			jr .pastdmark  
8652 ..			.dmark: db "SRg"  
8655 f1			.pastdmark: pop af  
8656			endm  
# End of macro DMARK
8656					CALLMONITOR 
8656 cd f4 92			call break_point_state  
8659				endm  
# End of macro CALLMONITOR
8659				endif 
8659 cd b1 80			call storage_read_block 
865c			 
865c			 
865c			; TODO if block has no zeros then need to read next block  
865c			 
865c			 
865c					 
865c e1				pop hl 		 ; return start of data to show as not EOF 
865d 23				inc hl   ; past file id 
865e 23				inc hl   ; past ext 
865f				if DEBUG_STORESE 
865f					DMARK "SRe" 
865f f5				push af  
8660 3a 74 86			ld a, (.dmark)  
8663 32 c0 ee			ld (debug_mark),a  
8666 3a 75 86			ld a, (.dmark+1)  
8669 32 c1 ee			ld (debug_mark+1),a  
866c 3a 76 86			ld a, (.dmark+2)  
866f 32 c2 ee			ld (debug_mark+2),a  
8672 18 03			jr .pastdmark  
8674 ..			.dmark: db "SRe"  
8677 f1			.pastdmark: pop af  
8678			endm  
# End of macro DMARK
8678					CALLMONITOR 
8678 cd f4 92			call break_point_state  
867b				endm  
# End of macro CALLMONITOR
867b				endif 
867b c9					ret 
867c			 
867c			 
867c			 
867c			; 
867c			; Append File 
867c			; 
867c			; hl - file id to locate 
867c			; de - pointer to (multi block) string to write 
867c			 
867c			 
867c			storage_append: 
867c				; hl -  file id to append to 
867c				; de - string to append 
867c			 
867c d5				push de 
867d				 
867d				if DEBUG_STORESE 
867d					DMARK "AP1" 
867d f5				push af  
867e 3a 92 86			ld a, (.dmark)  
8681 32 c0 ee			ld (debug_mark),a  
8684 3a 93 86			ld a, (.dmark+1)  
8687 32 c1 ee			ld (debug_mark+1),a  
868a 3a 94 86			ld a, (.dmark+2)  
868d 32 c2 ee			ld (debug_mark+2),a  
8690 18 03			jr .pastdmark  
8692 ..			.dmark: db "AP1"  
8695 f1			.pastdmark: pop af  
8696			endm  
# End of macro DMARK
8696					CALLMONITOR 
8696 cd f4 92			call break_point_state  
8699				endm  
# End of macro CALLMONITOR
8699				endif 
8699			 
8699 7d				ld a, l 
869a 32 e4 ec			ld (store_tmpid), a 
869d			 
869d				; get file header  
869d			 
869d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
869f 3a e4 ec			ld a, (store_tmpid) 
86a2 5f				ld e, a 
86a3			 
86a3 21 40 00				ld hl, STORE_BLOCK_PHY 
86a6 cd d2 83				call storage_findnextid 
86a9			 
86a9 22 d5 ec			ld (store_tmppageid), hl 
86ac			 
86ac				; TODO handle file id not found 
86ac			 
86ac				if DEBUG_STORESE 
86ac					DMARK "AP2" 
86ac f5				push af  
86ad 3a c1 86			ld a, (.dmark)  
86b0 32 c0 ee			ld (debug_mark),a  
86b3 3a c2 86			ld a, (.dmark+1)  
86b6 32 c1 ee			ld (debug_mark+1),a  
86b9 3a c3 86			ld a, (.dmark+2)  
86bc 32 c2 ee			ld (debug_mark+2),a  
86bf 18 03			jr .pastdmark  
86c1 ..			.dmark: db "AP2"  
86c4 f1			.pastdmark: pop af  
86c5			endm  
# End of macro DMARK
86c5					CALLMONITOR 
86c5 cd f4 92			call break_point_state  
86c8				endm  
# End of macro CALLMONITOR
86c8				endif 
86c8			 
86c8				; update file extent count 
86c8			 
86c8 11 eb ec			ld de, store_page 
86cb			 
86cb cd b1 80			call storage_read_block 
86ce			 
86ce				if DEBUG_STORESE 
86ce					DMARK "AP3" 
86ce f5				push af  
86cf 3a e3 86			ld a, (.dmark)  
86d2 32 c0 ee			ld (debug_mark),a  
86d5 3a e4 86			ld a, (.dmark+1)  
86d8 32 c1 ee			ld (debug_mark+1),a  
86db 3a e5 86			ld a, (.dmark+2)  
86de 32 c2 ee			ld (debug_mark+2),a  
86e1 18 03			jr .pastdmark  
86e3 ..			.dmark: db "AP3"  
86e6 f1			.pastdmark: pop af  
86e7			endm  
# End of macro DMARK
86e7					CALLMONITOR 
86e7 cd f4 92			call break_point_state  
86ea				endm  
# End of macro CALLMONITOR
86ea				endif 
86ea			;	ld (store_tmppageid), hl 
86ea			 
86ea 3a ed ec			ld a, (store_page+2) 
86ed 3c				inc a 
86ee 32 ed ec			ld (store_page+2), a 
86f1 32 e3 ec			ld (store_tmpext), a 
86f4				 
86f4				if DEBUG_STORESE 
86f4					DMARK "AP3" 
86f4 f5				push af  
86f5 3a 09 87			ld a, (.dmark)  
86f8 32 c0 ee			ld (debug_mark),a  
86fb 3a 0a 87			ld a, (.dmark+1)  
86fe 32 c1 ee			ld (debug_mark+1),a  
8701 3a 0b 87			ld a, (.dmark+2)  
8704 32 c2 ee			ld (debug_mark+2),a  
8707 18 03			jr .pastdmark  
8709 ..			.dmark: db "AP3"  
870c f1			.pastdmark: pop af  
870d			endm  
# End of macro DMARK
870d					CALLMONITOR 
870d cd f4 92			call break_point_state  
8710				endm  
# End of macro CALLMONITOR
8710				endif 
8710 2a d5 ec			ld hl, (store_tmppageid) 
8713 11 eb ec			ld de, store_page 
8716 cd 16 81			call storage_write_block 
8719			 
8719				; find free block 
8719			 
8719 11 00 00			ld de, 0			 ; file extent to locate 
871c			 
871c 21 40 00				ld hl, STORE_BLOCK_PHY 
871f cd d2 83				call storage_findnextid 
8722			 
8722					; TODO handle no space left 
8722					 
8722 22 d5 ec				ld (store_tmppageid), hl 
8725			 
8725				if DEBUG_STORESE 
8725					DMARK "AP4" 
8725 f5				push af  
8726 3a 3a 87			ld a, (.dmark)  
8729 32 c0 ee			ld (debug_mark),a  
872c 3a 3b 87			ld a, (.dmark+1)  
872f 32 c1 ee			ld (debug_mark+1),a  
8732 3a 3c 87			ld a, (.dmark+2)  
8735 32 c2 ee			ld (debug_mark+2),a  
8738 18 03			jr .pastdmark  
873a ..			.dmark: db "AP4"  
873d f1			.pastdmark: pop af  
873e			endm  
# End of macro DMARK
873e					CALLMONITOR 
873e cd f4 92			call break_point_state  
8741				endm  
# End of macro CALLMONITOR
8741				endif 
8741					; init the buffer with zeros so we can id if the buffer is full or not 
8741			 
8741 e5					push hl 
8742 c5					push bc 
8743			 
8743 21 eb ec				ld hl, store_page 
8746 06 40				ld b, STORE_BLOCK_PHY 
8748 3e 00				ld a, 0 
874a 77			.zeroblock:	ld (hl), a 
874b 23					inc hl 
874c 10 fc				djnz .zeroblock 
874e			 
874e c1					pop bc 
874f e1					pop hl 
8750			 
8750					; construct block 
8750			 
8750 3a e4 ec				ld a, (store_tmpid) 
8753 32 eb ec				ld (store_page), a   ; file id 
8756 3a e3 ec				ld a, (store_tmpext)   ; extent for this block 
8759 32 ec ec				ld (store_page+1), a 
875c			 
875c e1					pop hl    ; get string to write 
875d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
875f 11 ed ec				ld de, store_page+2 
8762			 
8762				if DEBUG_STORESE 
8762					DMARK "AP5" 
8762 f5				push af  
8763 3a 77 87			ld a, (.dmark)  
8766 32 c0 ee			ld (debug_mark),a  
8769 3a 78 87			ld a, (.dmark+1)  
876c 32 c1 ee			ld (debug_mark+1),a  
876f 3a 79 87			ld a, (.dmark+2)  
8772 32 c2 ee			ld (debug_mark+2),a  
8775 18 03			jr .pastdmark  
8777 ..			.dmark: db "AP5"  
877a f1			.pastdmark: pop af  
877b			endm  
# End of macro DMARK
877b					CALLMONITOR 
877b cd f4 92			call break_point_state  
877e				endm  
# End of macro CALLMONITOR
877e				endif 
877e			 
877e			 
877e			 
877e					; fill buffer with data until end of string or full block 
877e			 
877e 7e			.appd:		ld a, (hl) 
877f 12					ld (de), a 
8780 fe 00				cp 0 
8782 28 04				jr z, .appdone 
8784 23					inc hl 
8785 13					inc de 
8786 10 f6				djnz .appd 
8788			 
8788 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8789 f5					push af   		; save last byte dumped 
878a			 
878a			 
878a 2a d5 ec			ld hl, (store_tmppageid) 
878d 11 eb ec			ld de, store_page 
8790				if DEBUG_STORESE 
8790					DMARK "AP6" 
8790 f5				push af  
8791 3a a5 87			ld a, (.dmark)  
8794 32 c0 ee			ld (debug_mark),a  
8797 3a a6 87			ld a, (.dmark+1)  
879a 32 c1 ee			ld (debug_mark+1),a  
879d 3a a7 87			ld a, (.dmark+2)  
87a0 32 c2 ee			ld (debug_mark+2),a  
87a3 18 03			jr .pastdmark  
87a5 ..			.dmark: db "AP6"  
87a8 f1			.pastdmark: pop af  
87a9			endm  
# End of macro DMARK
87a9					CALLMONITOR 
87a9 cd f4 92			call break_point_state  
87ac				endm  
# End of macro CALLMONITOR
87ac				endif 
87ac cd 16 81				call storage_write_block 
87af			 
87af			 
87af				; was that a full block of data written? 
87af				; any more to write out? 
87af			 
87af				; if yes then set vars and jump to start of function again 
87af			 
87af f1					pop af 
87b0 d1					pop de 
87b1			 
87b1 fe 00				cp 0		 ; no, string was fully written 
87b3 c8					ret z 
87b4			 
87b4					; setup vars for next cycle 
87b4			 
87b4 3a e4 ec				ld a, (store_tmpid) 
87b7 6f					ld l, a 
87b8 26 00				ld h, 0 
87ba			 
87ba c3 7c 86			 	jp storage_append	 ; yes, need to write out some more 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			if DEBUG_STORECF 
87bd			storageput:	 
87bd					ret 
87bd			storageread: 
87bd					ld hl, store_page 
87bd					ld b, 200 
87bd					ld a,0 
87bd			.src:		ld (hl),a 
87bd					inc hl 
87bd					djnz .src 
87bd					 
87bd			 
87bd					ld de, 0 
87bd					ld bc, 1 
87bd					ld hl, store_page 
87bd					call cfRead 
87bd			 
87bd				call cfGetError 
87bd				ld hl,scratch 
87bd				call hexout 
87bd				ld hl, scratch+2 
87bd				ld a, 0 
87bd				ld (hl),a 
87bd				ld de, scratch 
87bd				ld a,display_row_1 
87bd				call str_at_display 
87bd				call update_display 
87bd			 
87bd					ld hl, store_page 
87bd					ld (os_cur_ptr),hl 
87bd			 
87bd					ret 
87bd			endif 
87bd			 
87bd			 
87bd			; Clear out the main buffer store (used to remove junk before writing a new block) 
87bd			 
87bd			storage_clear_page: 
87bd e5				push hl 
87be d5				push de 
87bf c5				push bc 
87c0 21 eb ec			ld hl, store_page 
87c3 3e 00			ld a, 0 
87c5 77				ld (hl), a 
87c6			 
87c6 11 ec ec			ld de, store_page+1 
87c9 01 40 00			ld bc, STORE_BLOCK_PHY 
87cc			 
87cc ed b0			ldir 
87ce				 
87ce c1				pop bc 
87cf d1				pop de 
87d0 e1				pop hl 
87d1 c9				ret 
87d2			 
87d2			; eof 
# End of file firmware_storage.asm
87d2			  
87d2			; support routines for above hardware abstraction layer  
87d2			  
87d2			include "firmware_general.asm"        ; general support functions  
87d2			 
87d2			; word look up 
87d2			 
87d2			; in 
87d2			; a is the index 
87d2			; hl is pointer start of array 
87d2			; 
87d2			; returns 
87d2			; hl to the word 
87d2			; 
87d2			 
87d2			table_lookup:  
87d2 d5					push de 
87d3 eb					ex de, hl 
87d4			 
87d4 6f					ld l, a 
87d5 26 00				ld h, 0 
87d7 29					add hl, hl 
87d8 19					add hl, de 
87d9 7e					ld a, (hl) 
87da 23					inc hl 
87db 66					ld h,(hl) 
87dc 6f					ld l, a 
87dd			 
87dd d1					pop de 
87de c9					ret 
87df			 
87df			; Delay loops 
87df			 
87df			 
87df			 
87df			aDelayInMS: 
87df c5				push bc 
87e0 47				ld b,a 
87e1			msdelay: 
87e1 c5				push bc 
87e2				 
87e2			 
87e2 01 41 00			ld bc,041h 
87e5 cd fd 87			call delayloop 
87e8 c1				pop bc 
87e9 05				dec b 
87ea 20 f5			jr nz,msdelay 
87ec			 
87ec			;if CPU_CLOCK_8MHZ 
87ec			;msdelay8: 
87ec			;	push bc 
87ec			;	 
87ec			; 
87ec			;	ld bc,041h 
87ec			;	call delayloop 
87ec			;	pop bc 
87ec			;	dec b 
87ec			;	jr nz,msdelay8 
87ec			;endif 
87ec			 
87ec			 
87ec c1				pop bc 
87ed c9				ret 
87ee			 
87ee			 
87ee			delay250ms: 
87ee				;push de 
87ee 01 00 40			ld bc, 04000h 
87f1 c3 fd 87			jp delayloop 
87f4			delay500ms: 
87f4				;push de 
87f4 01 00 80			ld bc, 08000h 
87f7 c3 fd 87			jp delayloop 
87fa			delay1s: 
87fa				;push bc 
87fa			   ; Clobbers A, d and e 
87fa 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87fd			delayloop: 
87fd c5			    push bc 
87fe			 
87fe			if BASE_CPM 
87fe				ld bc, CPM_DELAY_TUNE 
87fe			.cpmloop: 
87fe				push bc 
87fe			 
87fe			endif 
87fe			 
87fe			 
87fe			 
87fe			delayloopi: 
87fe			;	push bc 
87fe			;.dl: 
87fe cb 47		    bit     0,a    	; 8 
8800 cb 47		    bit     0,a    	; 8 
8802 cb 47		    bit     0,a    	; 8 
8804 e6 ff		    and     255  	; 7 
8806 0b			    dec     bc      	; 6 
8807 79			    ld      a,c     	; 4 
8808 b0			    or      b     	; 4 
8809 c2 fe 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
880c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
880c				;pop de 
880c			;pop bc 
880c			 
880c			if BASE_CPM 
880c				pop bc 
880c				 
880c			    dec     bc      	; 6 
880c			    ld      a,c     	; 4 
880c			    or      b     	; 4 
880c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
880c				 
880c			 
880c			endif 
880c			;if CPU_CLOCK_8MHZ 
880c			;    pop bc 
880c			;    push bc 
880c			;.dl8: 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    and     255  	; 7 
880c			;    dec     bc      	; 6 
880c			;    ld      a,c     	; 4 
880c			;    or      b     	; 4 
880c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880c			;endif 
880c			 
880c			;if CPU_CLOCK_10MHZ 
880c			;    pop bc 
880c			;    push bc 
880c			;.dl8: 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    and     255  	; 7 
880c			;    dec     bc      	; 6 
880c			;    ld      a,c     	; 4 
880c			;    or      b     	; 4 
880c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880c			;endif 
880c c1			    pop bc 
880d			 
880d c9				ret 
880e			 
880e			 
880e			 
880e			; eof 
# End of file firmware_general.asm
880e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
880e			; display routines that use the physical hardware abstraction layer 
880e			 
880e			 
880e			; information window 
880e			 
880e			; pass hl with 1st string to display 
880e			; pass de with 2nd string to display 
880e			 
880e			info_panel: 
880e e5				push hl 
880f			 
880f 2a 61 ed			ld hl, (display_fb_active) 
8812 e5				push hl    ; future de destination 
8813 21 56 ee				ld hl, display_fb0 
8816 22 61 ed				ld (display_fb_active), hl 
8819			 
8819 cd 7a 88			call clear_display 
881c			 
881c			 
881c 3e 2d			ld a, display_row_3 + 5 
881e cd 8d 88			call str_at_display 
8821			 
8821 e1				pop hl 
8822 d1				pop de 
8823			 
8823 e5				push hl 
8824			 
8824			 
8824 3e 19			ld a, display_row_2 + 5 
8826 cd 8d 88			call str_at_display 
8829			 
8829			 
8829 cd 9d 88			call update_display 
882c cd f9 97			call next_page_prompt 
882f cd 7a 88			call clear_display 
8832			 
8832				 
8832 21 05 ee				ld hl, display_fb1 
8835 22 61 ed				ld (display_fb_active), hl 
8838 cd 9d 88			call update_display 
883b			 
883b			 
883b c9				ret 
883c			 
883c			 
883c			 
883c			 
883c			; TODO windowing? 
883c			 
883c			; TODO scroll line up 
883c			 
883c			scroll_up: 
883c			 
883c e5				push hl 
883d d5				push de 
883e c5				push bc 
883f			 
883f				; get frame buffer  
883f			 
883f 2a 61 ed			ld hl, (display_fb_active) 
8842 e5				push hl    ; future de destination 
8843			 
8843 11 14 00			ld  de, display_cols 
8846 19				add hl, de 
8847			 
8847 d1				pop de 
8848			 
8848				;ex de, hl 
8848 01 4f 00			ld bc, display_fb_len -1  
884b			;if DEBUG_FORTH_WORDS 
884b			;	DMARK "SCL" 
884b			;	CALLMONITOR 
884b			;endif	 
884b ed b0			ldir 
884d			 
884d				; wipe bottom row 
884d			 
884d			 
884d 2a 61 ed			ld hl, (display_fb_active) 
8850 11 50 00			ld de, display_cols*display_rows 
8853 19				add hl, de 
8854 06 14			ld b, display_cols 
8856 3e 20			ld a, ' ' 
8858			.scwipe: 
8858 77				ld (hl), a 
8859 2b				dec hl 
885a 10 fc			djnz .scwipe 
885c			 
885c				;pop hl 
885c			 
885c c1				pop bc 
885d d1				pop de 
885e e1				pop hl 
885f			 
885f c9				ret 
8860			 
8860			 
8860			;scroll_upo: 
8860			;	ld de, display_row_1 
8860			 ;	ld hl, display_row_2 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			;	ld de, display_row_2 
8860			 ;	ld hl, display_row_3 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			;	ld de, display_row_3 
8860			 ;	ld hl, display_row_4 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			 
8860			; TODO clear row 4 
8860			 
8860			;	ret 
8860			 
8860				 
8860			scroll_down: 
8860			 
8860 e5				push hl 
8861 d5				push de 
8862 c5				push bc 
8863			 
8863				; get frame buffer  
8863			 
8863 2a 61 ed			ld hl, (display_fb_active) 
8866			 
8866 11 4f 00			ld de, display_fb_len - 1 
8869 19				add hl, de 
886a			 
886a e5			push hl    ; future de destination 
886b			 
886b 11 14 00			ld  de, display_cols 
886e ed 52			sbc hl, de 
8870			 
8870			 
8870 d1				pop de 
8871			 
8871			;	ex de, hl 
8871 01 4f 00			ld bc, display_fb_len -1  
8874			 
8874			 
8874				 
8874			 
8874 ed b0			ldir 
8876			 
8876				; wipe bottom row 
8876			 
8876			 
8876			;	ld hl, (display_fb_active) 
8876			;;	ld de, display_cols*display_rows 
8876			;;	add hl, de 
8876			;	ld b, display_cols 
8876			;	ld a, ' ' 
8876			;.scwiped: 
8876			;	ld (hl), a 
8876			;	dec hl 
8876			;	djnz .scwiped 
8876			 
8876				;pop hl 
8876			 
8876 c1				pop bc 
8877 d1				pop de 
8878 e1				pop hl 
8879			 
8879 c9				ret 
887a			;scroll_down: 
887a			;	ld de, display_row_4 
887a			;	ld hl, display_row_3 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;	ld de, display_row_3 
887a			; 	ld hl, display_row_2 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;	ld de, display_row_2 
887a			;	ld hl, display_row_1 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;;; TODO clear row 1 
887a			;	ret 
887a			 
887a			 
887a			 
887a			 
887a			 
887a			; clear active frame buffer 
887a			 
887a			clear_display: 
887a 3e 20			ld a, ' ' 
887c c3 7f 88			jp fill_display 
887f			 
887f			; fill active frame buffer with a char in A 
887f			 
887f			fill_display: 
887f 06 50			ld b,display_fb_len 
8881 2a 61 ed			ld hl, (display_fb_active) 
8884 77			.fd1:	ld (hl),a 
8885 23				inc hl 
8886 10 fc			djnz .fd1 
8888 23				inc hl 
8889 3e 00			ld a,0 
888b 77				ld (hl),a 
888c			 
888c			 
888c c9				ret 
888d			; Write string (DE) at pos (A) to active frame buffer 
888d			 
888d 2a 61 ed		str_at_display:    ld hl,(display_fb_active) 
8890 06 00					ld b,0 
8892 4f					ld c,a 
8893 09					add hl,bc 
8894 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8895 b7			            OR   A              ;Null terminator? 
8896 c8			            RET  Z              ;Yes, so finished 
8897 77					ld (hl),a 
8898 23				inc hl 
8899 13			            INC  DE             ;Point to next character 
889a 18 f8		            JR   .sad1     ;Repeat 
889c c9					ret 
889d			 
889d			; using current frame buffer write to physical display 
889d			 
889d			update_display: 
889d e5				push hl 
889e 2a 61 ed			ld hl, (display_fb_active) 
88a1 cd d3 d7			call write_display 
88a4 e1				pop hl 
88a5 c9				ret 
88a6			 
88a6			; TODO scrolling 
88a6			 
88a6			 
88a6			; move cursor right one char 
88a6			cursor_right: 
88a6			 
88a6				; TODO shift right 
88a6				; TODO if beyond max col 
88a6				; TODO       cursor_next_line 
88a6			 
88a6 c9				ret 
88a7			 
88a7			 
88a7			cursor_next_line: 
88a7				; TODO first char 
88a7				; TODO line down 
88a7				; TODO if past last row 
88a7				; TODO    scroll up 
88a7			 
88a7 c9				ret 
88a8			 
88a8			cursor_left: 
88a8				; TODO shift left 
88a8				; TODO if beyond left  
88a8				; TODO     cursor prev line 
88a8				 
88a8 c9				ret 
88a9			 
88a9			cursor_prev_line: 
88a9				; TODO last char 
88a9				; TODO line up 
88a9				; TODO if past first row 
88a9				; TODO   scroll down 
88a9			 
88a9 c9				ret 
88aa			 
88aa			 
88aa			cout: 
88aa				; A - char 
88aa c9				ret 
88ab			 
88ab			 
88ab			; Display a menu and allow item selection (optional toggle items) 
88ab			; 
88ab			; format: 
88ab			; hl pointer to word array with zero term for items 
88ab			; e.g.    db item1 
88ab			;         db .... 
88ab			;         db 0 
88ab			; 
88ab			; a = starting menu item  
88ab			; 
88ab			; de = pointer item toggle array   (todo) 
88ab			; 
88ab			; returns item selected in a 1-... 
88ab			; returns 0 if back button pressed 
88ab			; 
88ab			; NOTE: Uses system frame buffer to display 
88ab			; 
88ab			; LEFT, Q = go back 
88ab			; RIGHT, SPACE, CR = select 
88ab			; UP, A - Up 
88ab			; DOWN, Z - Down 
88ab			 
88ab			 
88ab			 
88ab			 
88ab			 
88ab			menu: 
88ab			 
88ab					; keep array pointer 
88ab			 
88ab 22 e9 ec				ld (store_tmp1), hl 
88ae 32 e7 ec				ld (store_tmp2), a 
88b1			 
88b1					; check for key bounce 
88b1			 
88b1			if BASE_KEV 
88b1			 
88b1			.mbounce:	call cin 
88b1					cp 0 
88b1					jr nz, .mbounce 
88b1			endif 
88b1					; for ease use ex 
88b1			 
88b1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88b1 21 56 ee				ld hl, display_fb0 
88b4 22 61 ed				ld (display_fb_active), hl 
88b7			 
88b7 cd 7a 88		.mloop:		call clear_display 
88ba cd 9d 88				call update_display 
88bd			 
88bd					; draw selection id '>' at 1 
88bd			 
88bd					; init start of list display 
88bd			 
88bd 3e 05				ld a, 5 
88bf 32 e5 ec				ld (store_tmp3), a   ; display row count 
88c2 3a e7 ec				ld a,( store_tmp2) 
88c5 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88c8			 
88c8					 
88c8			.mitem:	 
88c8			 
88c8			 
88c8 3a e8 ec				ld a,(store_tmp2+1) 
88cb 6f					ld l, a 
88cc 26 00				ld h, 0 
88ce 29					add hl, hl 
88cf ed 5b e9 ec			ld de, (store_tmp1) 
88d3 19					add hl, de 
88d4 7e					ld a, (hl) 
88d5 23					inc hl 
88d6 66					ld h,(hl) 
88d7 6f					ld l, a 
88d8			 
88d8 cd d0 8a				call ishlzero 
88db 28 1a				jr z, .mdone 
88dd			 
88dd eb					ex de, hl 
88de 3a e5 ec				ld a, (store_tmp3) 
88e1 cd 8d 88				call str_at_display 
88e4					 
88e4			 
88e4					; next item 
88e4 3a e8 ec				ld a, (store_tmp2+1) 
88e7 3c					inc a 
88e8 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88eb			 
88eb			 		; next row 
88eb			 
88eb 3a e5 ec				ld a, (store_tmp3) 
88ee c6 14				add display_cols 
88f0 32 e5 ec				ld (store_tmp3), a 
88f3			 
88f3					; at end of screen? 
88f3			 
88f3 fe 10				cp display_rows*4 
88f5 20 d1				jr nz, .mitem 
88f7			 
88f7			 
88f7			.mdone: 
88f7 cd d0 8a				call ishlzero 
88fa 28 08				jr z, .nodn 
88fc			 
88fc 3e 3c				ld a, display_row_4 
88fe 11 7d 89				ld de, .mdown 
8901 cd 8d 88				call str_at_display 
8904			 
8904					; draw options to fill the screens with active item on line 1 
8904					; if current option is 2 or more then display ^ in top 
8904			 
8904 3a e7 ec		.nodn:		ld a, (store_tmp2) 
8907 fe 00				cp 0 
8909 28 08				jr z, .noup 
890b			 
890b 3e 00				ld a, 0 
890d 11 7b 89				ld de, .mup 
8910 cd 8d 88				call str_at_display 
8913			 
8913 3e 02		.noup:		ld a, 2 
8915 11 79 89				ld de, .msel 
8918 cd 8d 88				call str_at_display 
891b			 
891b					; if current option + 1 is not null then display V in bottom 
891b					; get key 
891b cd 9d 88				call update_display 
891e			 
891e			 
891e					; handle key 
891e			 
891e cd 5f d8				call cin_wait 
8921			 
8921 fe 05				cp KEY_UP 
8923 28 2b				jr z, .mgoup 
8925 fe 61				cp 'a' 
8927 28 27				jr z, .mgoup 
8929 fe 0a				cp KEY_DOWN 
892b 28 32				jr z, .mgod 
892d fe 7a				cp 'z' 
892f 28 2e				jr z, .mgod 
8931 fe 20				cp ' ' 
8933 28 34				jr z, .goend 
8935 fe 0c				cp KEY_RIGHT 
8937 28 30				jr z, .goend 
8939 fe 0d				cp KEY_CR 
893b 28 2c				jr z, .goend 
893d fe 71				cp 'q' 
893f 28 0b				jr z, .goback 
8941			 
8941 fe 0b				cp KEY_LEFT 
8943 28 07				jr z, .goback 
8945 fe 08				cp KEY_BS 
8947 28 03				jr z, .goback 
8949 c3 b7 88				jp .mloop 
894c			 
894c			.goback: 
894c 3e 00			ld a, 0 
894e 18 1d			jr .goend2 
8950			 
8950				; move up one 
8950			.mgoup: 
8950 3a e7 ec				ld a, (store_tmp2) 
8953 fe 00				cp 0 
8955 ca b7 88				jp z, .mloop 
8958 3d					dec a 
8959 32 e7 ec				ld (store_tmp2), a 
895c c3 b7 88				jp .mloop 
895f			 
895f				; move down one 
895f			.mgod: 
895f 3a e7 ec				ld a, (store_tmp2) 
8962 3c					inc a 
8963 32 e7 ec				ld (store_tmp2), a 
8966 c3 b7 88				jp .mloop 
8969			 
8969			 
8969			.goend: 
8969					; get selected item number 
8969			 
8969 3a e7 ec				ld a, (store_tmp2) 
896c 3c					inc a 
896d			 
896d			.goend2: 
896d f5					push af 
896e			 
896e					; restore active fb 
896e					; TODO BUG assumes fb1 
896e			 
896e 21 05 ee				ld hl, display_fb1 
8971 22 61 ed				ld (display_fb_active), hl 
8974			 
8974					; restore main regs 
8974			 
8974			 
8974 cd 9d 88				call update_display 
8977			 
8977 f1					pop af 
8978			 
8978 c9				ret 
8979			 
8979 .. 00		.msel:   db ">",0 
897b .. 00		.mup:   db "^",0 
897d .. 00		.mdown:   db "v",0 
897f			 
897f			 
897f			; eof 
897f			 
# End of file firmware_display.asm
897f			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
897f			; random number generators 
897f			 
897f			 
897f			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
897f			 
897f			 
897f			;-----> Generate a random number 
897f			; output a=answer 0<=a<=255 
897f			; all registers are preserved except: af 
897f			random: 
897f e5			        push    hl 
8980 d5			        push    de 
8981 2a 43 ed		        ld      hl,(randData) 
8984 ed 5f		        ld      a,r 
8986 57			        ld      d,a 
8987 5e			        ld      e,(hl) 
8988 19			        add     hl,de 
8989 85			        add     a,l 
898a ac			        xor     h 
898b 22 43 ed		        ld      (randData),hl 
898e d1			        pop     de 
898f e1			        pop     hl 
8990 c9			        ret 
8991			 
8991			 
8991			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8991			 
8991			 
8991			 
8991			;------LFSR------ 
8991			;James Montelongo 
8991			;optimized by Spencer Putt 
8991			;out: 
8991			; a = 8 bit random number 
8991			RandLFSR: 
8991 21 49 ed		        ld hl,LFSRSeed+4 
8994 5e			        ld e,(hl) 
8995 23			        inc hl 
8996 56			        ld d,(hl) 
8997 23			        inc hl 
8998 4e			        ld c,(hl) 
8999 23			        inc hl 
899a 7e			        ld a,(hl) 
899b 47			        ld b,a 
899c cb 13		        rl e  
899e cb 12			rl d 
89a0 cb 11		        rl c  
89a2 17				rla 
89a3 cb 13		        rl e  
89a5 cb 12			rl d 
89a7 cb 11		        rl c  
89a9 17				rla 
89aa cb 13		        rl e  
89ac cb 12			rl d 
89ae cb 11		        rl c  
89b0 17				rla 
89b1 67			        ld h,a 
89b2 cb 13		        rl e  
89b4 cb 12			rl d 
89b6 cb 11		        rl c  
89b8 17				rla 
89b9 a8			        xor b 
89ba cb 13		        rl e  
89bc cb 12			rl d 
89be ac			        xor h 
89bf a9			        xor c 
89c0 aa			        xor d 
89c1 21 4b ed		        ld hl,LFSRSeed+6 
89c4 11 4c ed		        ld de,LFSRSeed+7 
89c7 01 07 00		        ld bc,7 
89ca ed b8		        lddr 
89cc 12			        ld (de),a 
89cd c9			        ret 
89ce			 
89ce			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89ce			 
89ce			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89ce			 
89ce			 
89ce			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89ce			 
89ce			prng16: 
89ce			;Inputs: 
89ce			;   (seed1) contains a 16-bit seed value 
89ce			;   (seed2) contains a NON-ZERO 16-bit seed value 
89ce			;Outputs: 
89ce			;   HL is the result 
89ce			;   BC is the result of the LCG, so not that great of quality 
89ce			;   DE is preserved 
89ce			;Destroys: 
89ce			;   AF 
89ce			;cycle: 4,294,901,760 (almost 4.3 billion) 
89ce			;160cc 
89ce			;26 bytes 
89ce 2a 3d ed		    ld hl,(seed1) 
89d1 44			    ld b,h 
89d2 4d			    ld c,l 
89d3 29			    add hl,hl 
89d4 29			    add hl,hl 
89d5 2c			    inc l 
89d6 09			    add hl,bc 
89d7 22 3d ed		    ld (seed1),hl 
89da 2a 3b ed		    ld hl,(seed2) 
89dd 29			    add hl,hl 
89de 9f			    sbc a,a 
89df e6 2d		    and %00101101 
89e1 ad			    xor l 
89e2 6f			    ld l,a 
89e3 22 3b ed		    ld (seed2),hl 
89e6 09			    add hl,bc 
89e7 c9			    ret 
89e8			 
89e8			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89e8			 
89e8			rand32: 
89e8			;Inputs: 
89e8			;   (seed1_0) holds the lower 16 bits of the first seed 
89e8			;   (seed1_1) holds the upper 16 bits of the first seed 
89e8			;   (seed2_0) holds the lower 16 bits of the second seed 
89e8			;   (seed2_1) holds the upper 16 bits of the second seed 
89e8			;   **NOTE: seed2 must be non-zero 
89e8			;Outputs: 
89e8			;   HL is the result 
89e8			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89e8			;Destroys: 
89e8			;   AF 
89e8			;Tested and passes all CAcert tests 
89e8			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89e8			;it has a period of 18,446,744,069,414,584,320 
89e8			;roughly 18.4 quintillion. 
89e8			;LFSR taps: 0,2,6,7  = 11000101 
89e8			;291cc 
89e8			;seed1_0=$+1 
89e8			;    ld hl,12345 
89e8			;seed1_1=$+1 
89e8			;    ld de,6789 
89e8			;    ld b,h 
89e8			;    ld c,l 
89e8			;    add hl,hl \ rl e \ rl d 
89e8			;    add hl,hl \ rl e \ rl d 
89e8			;    inc l 
89e8			;    add hl,bc 
89e8			;    ld (seed1_0),hl 
89e8			;    ld hl,(seed1_1) 
89e8			;    adc hl,de 
89e8			;    ld (seed1_1),hl 
89e8			;    ex de,hl 
89e8			;seed2_0=$+1 
89e8			;    ld hl,9876 
89e8			;seed2_1=$+1 
89e8			;    ld bc,54321 
89e8			;    add hl,hl \ rl c \ rl b 
89e8			;    ld (seed2_1),bc 
89e8			;    sbc a,a 
89e8			;    and %11000101 
89e8			;    xor l 
89e8			;    ld l,a 
89e8			;    ld (seed2_0),hl 
89e8			;    ex de,hl 
89e8			;    add hl,bc 
89e8			;    ret 
89e8			; 
89e8			 
89e8			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89e8			; 20 bytes, 86 cycles (excluding ret) 
89e8			 
89e8			; returns   hl = pseudorandom number 
89e8			; corrupts   a 
89e8			 
89e8			; generates 16-bit pseudorandom numbers with a period of 65535 
89e8			; using the xorshift method: 
89e8			 
89e8			; hl ^= hl << 7 
89e8			; hl ^= hl >> 9 
89e8			; hl ^= hl << 8 
89e8			 
89e8			; some alternative shift triplets which also perform well are: 
89e8			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89e8			 
89e8			;  org 32768 
89e8			 
89e8			xrnd: 
89e8 2a 41 ed		  ld hl,(xrandc)       ; seed must not be 0 
89eb 3e 00		  ld a,0 
89ed bd			  cp l 
89ee 20 02		  jr nz, .xrnd1 
89f0 2e 01		  ld l, 1 
89f2			.xrnd1: 
89f2			 
89f2 7c			  ld a,h 
89f3 1f			  rra 
89f4 7d			  ld a,l 
89f5 1f			  rra 
89f6 ac			  xor h 
89f7 67			  ld h,a 
89f8 7d			  ld a,l 
89f9 1f			  rra 
89fa 7c			  ld a,h 
89fb 1f			  rra 
89fc ad			  xor l 
89fd 6f			  ld l,a 
89fe ac			  xor h 
89ff 67			  ld h,a 
8a00			 
8a00 22 41 ed		  ld (xrandc),hl 
8a03			 
8a03 c9			  ret 
8a04			;  
8a04			 
8a04			 
8a04			;;;; int maths 
8a04			 
8a04			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a04			; Divide 16-bit values (with 16-bit result) 
8a04			; In: Divide BC by divider DE 
8a04			; Out: BC = result, HL = rest 
8a04			; 
8a04			Div16: 
8a04 21 00 00		    ld hl,0 
8a07 78			    ld a,b 
8a08 06 08		    ld b,8 
8a0a			Div16_Loop1: 
8a0a 17			    rla 
8a0b ed 6a		    adc hl,hl 
8a0d ed 52		    sbc hl,de 
8a0f 30 01		    jr nc,Div16_NoAdd1 
8a11 19			    add hl,de 
8a12			Div16_NoAdd1: 
8a12 10 f6		    djnz Div16_Loop1 
8a14 17			    rla 
8a15 2f			    cpl 
8a16 47			    ld b,a 
8a17 79			    ld a,c 
8a18 48			    ld c,b 
8a19 06 08		    ld b,8 
8a1b			Div16_Loop2: 
8a1b 17			    rla 
8a1c ed 6a		    adc hl,hl 
8a1e ed 52		    sbc hl,de 
8a20 30 01		    jr nc,Div16_NoAdd2 
8a22 19			    add hl,de 
8a23			Div16_NoAdd2: 
8a23 10 f6		    djnz Div16_Loop2 
8a25 17			    rla 
8a26 2f			    cpl 
8a27 41			    ld b,c 
8a28 4f			    ld c,a 
8a29 c9			ret 
8a2a			 
8a2a			 
8a2a			;http://z80-heaven.wikidot.com/math 
8a2a			; 
8a2a			;Inputs: 
8a2a			;     DE and A are factors 
8a2a			;Outputs: 
8a2a			;     A is not changed 
8a2a			;     B is 0 
8a2a			;     C is not changed 
8a2a			;     DE is not changed 
8a2a			;     HL is the product 
8a2a			;Time: 
8a2a			;     342+6x 
8a2a			; 
8a2a			Mult16: 
8a2a			 
8a2a 06 08		     ld b,8          ;7           7 
8a2c 21 00 00		     ld hl,0         ;10         10 
8a2f 29			       add hl,hl     ;11*8       88 
8a30 07			       rlca          ;4*8        32 
8a31 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a33 19			         add hl,de   ;--         -- 
8a34 10 f9		       djnz $-5      ;13*7+8     99 
8a36 c9			ret 
8a37			 
8a37			; 
8a37			; Square root of 16-bit value 
8a37			; In:  HL = value 
8a37			; Out:  D = result (rounded down) 
8a37			; 
8a37			;Sqr16: 
8a37			;    ld de,#0040 
8a37			;    ld a,l 
8a37			;    ld l,h 
8a37			;    ld h,d 
8a37			;    or a 
8a37			;    ld b,8 
8a37			;Sqr16_Loop: 
8a37			;    sbc hl,de 
8a37			;    jr nc,Sqr16_Skip 
8a37			;    add hl,de 
8a37			;Sqr16_Skip: 
8a37			;    ccf 
8a37			;    rl d 
8a37			;    add a,a 
8a37			;    adc hl,hl 
8a37			;    add a,a 
8a37			;    adc hl,hl 
8a37			;    djnz Sqr16_Loop 
8a37			;    ret 
8a37			; 
8a37			; 
8a37			; Divide 8-bit values 
8a37			; In: Divide E by divider C 
8a37			; Out: A = result, B = rest 
8a37			; 
8a37			Div8: 
8a37 af			    xor a 
8a38 06 08		    ld b,8 
8a3a			Div8_Loop: 
8a3a cb 13		    rl e 
8a3c 17			    rla 
8a3d 91			    sub c 
8a3e 30 01		    jr nc,Div8_NoAdd 
8a40 81			    add a,c 
8a41			Div8_NoAdd: 
8a41 10 f7		    djnz Div8_Loop 
8a43 47			    ld b,a 
8a44 7b			    ld a,e 
8a45 17			    rla 
8a46 2f			    cpl 
8a47 c9			    ret 
8a48			 
8a48			; 
8a48			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a48			; In: Multiply A with DE 
8a48			; Out: HL = result 
8a48			; 
8a48			Mult12U: 
8a48 2e 00		    ld l,0 
8a4a 87			    add a,a 
8a4b 30 01		    jr nc,Mult12U_NoAdd0 
8a4d 19			    add hl,de 
8a4e			Mult12U_NoAdd0: 
8a4e 29			    add hl,hl 
8a4f 87			    add a,a 
8a50 30 01		    jr nc,Mult12U_NoAdd1 
8a52 19			    add hl,de 
8a53			Mult12U_NoAdd1: 
8a53 29			    add hl,hl 
8a54 87			    add a,a 
8a55 30 01		    jr nc,Mult12U_NoAdd2 
8a57 19			    add hl,de 
8a58			Mult12U_NoAdd2: 
8a58 29			    add hl,hl 
8a59 87			    add a,a 
8a5a 30 01		    jr nc,Mult12U_NoAdd3 
8a5c 19			    add hl,de 
8a5d			Mult12U_NoAdd3: 
8a5d 29			    add hl,hl 
8a5e 87			    add a,a 
8a5f 30 01		    jr nc,Mult12U_NoAdd4 
8a61 19			    add hl,de 
8a62			Mult12U_NoAdd4: 
8a62 29			    add hl,hl 
8a63 87			    add a,a 
8a64 30 01		    jr nc,Mult12U_NoAdd5 
8a66 19			    add hl,de 
8a67			Mult12U_NoAdd5: 
8a67 29			    add hl,hl 
8a68 87			    add a,a 
8a69 30 01		    jr nc,Mult12U_NoAdd6 
8a6b 19			    add hl,de 
8a6c			Mult12U_NoAdd6: 
8a6c 29			    add hl,hl 
8a6d 87			    add a,a 
8a6e d0			    ret nc 
8a6f 19			    add hl,de 
8a70 c9			    ret 
8a71			 
8a71			; 
8a71			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a71			; In: Multiply A with DE 
8a71			;      Put lowest value in A for most efficient calculation 
8a71			; Out: HL = result 
8a71			; 
8a71			Mult12R: 
8a71 21 00 00		    ld hl,0 
8a74			Mult12R_Loop: 
8a74 cb 3f		    srl a 
8a76 30 01		    jr nc,Mult12R_NoAdd 
8a78 19			    add hl,de 
8a79			Mult12R_NoAdd: 
8a79 cb 23		    sla e 
8a7b cb 12		    rl d 
8a7d b7			    or a 
8a7e c2 74 8a		    jp nz,Mult12R_Loop 
8a81 c9			    ret 
8a82			 
8a82			; 
8a82			; Multiply 16-bit values (with 32-bit result) 
8a82			; In: Multiply BC with DE 
8a82			; Out: BCHL = result 
8a82			; 
8a82			Mult32: 
8a82 79			    ld a,c 
8a83 48			    ld c,b 
8a84 21 00 00		    ld hl,0 
8a87 06 10		    ld b,16 
8a89			Mult32_Loop: 
8a89 29			    add hl,hl 
8a8a 17			    rla 
8a8b cb 11		    rl c 
8a8d 30 07		    jr nc,Mult32_NoAdd 
8a8f 19			    add hl,de 
8a90 ce 00		    adc a,0 
8a92 d2 96 8a		    jp nc,Mult32_NoAdd 
8a95 0c			    inc c 
8a96			Mult32_NoAdd: 
8a96 10 f1		    djnz Mult32_Loop 
8a98 41			    ld b,c 
8a99 4f			    ld c,a 
8a9a c9			    ret 
8a9b			 
8a9b			 
8a9b			 
8a9b			; 
8a9b			; Multiply 8-bit values 
8a9b			; In:  Multiply H with E 
8a9b			; Out: HL = result 
8a9b			; 
8a9b			Mult8: 
8a9b 16 00		    ld d,0 
8a9d 6a			    ld l,d 
8a9e 06 08		    ld b,8 
8aa0			Mult8_Loop: 
8aa0 29			    add hl,hl 
8aa1 30 01		    jr nc,Mult8_NoAdd 
8aa3 19			    add hl,de 
8aa4			Mult8_NoAdd: 
8aa4 10 fa		    djnz Mult8_Loop 
8aa6 c9			    ret 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			;;http://z80-heaven.wikidot.com/math 
8aa7			;;This divides DE by BC, storing the result in DE, remainder in HL 
8aa7			; 
8aa7			;DE_Div_BC:          ;1281-2x, x is at most 16 
8aa7			;     ld a,16        ;7 
8aa7			;     ld hl,0        ;10 
8aa7			;     jp $+5         ;10 
8aa7			;.DivLoop: 
8aa7			;       add hl,bc    ;-- 
8aa7			;       dec a        ;64 
8aa7			;       jr z,.DivLoopEnd        ;86 
8aa7			; 
8aa7			;       sla e        ;128 
8aa7			;       rl d         ;128 
8aa7			;       adc hl,hl    ;240 
8aa7			;       sbc hl,bc    ;240 
8aa7			;       jr nc,.DivLoop ;23|21 
8aa7			;       inc e        ;-- 
8aa7			;       jp .DivLoop+1 
8aa7			; 
8aa7			;.DivLoopEnd: 
8aa7			 
8aa7			;HL_Div_C: 
8aa7			;Inputs: 
8aa7			;     HL is the numerator 
8aa7			;     C is the denominator 
8aa7			;Outputs: 
8aa7			;     A is the remainder 
8aa7			;     B is 0 
8aa7			;     C is not changed 
8aa7			;     DE is not changed 
8aa7			;     HL is the quotient 
8aa7			; 
8aa7			;       ld b,16 
8aa7			;       xor a 
8aa7			;         add hl,hl 
8aa7			;         rla 
8aa7			;         cp c 
8aa7			;         jr c,$+4 
8aa7			;           inc l 
8aa7			;           sub c 
8aa7			;         djnz $-7 
8aa7			 
8aa7			; https://plutiedev.com/z80-add-8bit-to-16bit 
8aa7			 
8aa7			addatohl: 
8aa7 85			    add   a, l    ; A = A+L 
8aa8 6f			    ld    l, a    ; L = A+L 
8aa9 8c			    adc   a, h    ; A = A+L+H+carry 
8aaa 95			    sub   l       ; A = H+carry 
8aab 67			    ld    h, a    ; H = H+carry 
8aac c9			ret 
8aad			 
8aad			addatode: 
8aad 83			    add   a, e    ; A = A+L 
8aae 5f			    ld    e, a    ; L = A+L 
8aaf 8a			    adc   a, d    ; A = A+L+H+carry 
8ab0 93			    sub   e       ; A = H+carry 
8ab1 57			    ld    d, a    ; H = H+carry 
8ab2 c9			ret 
8ab3			 
8ab3			 
8ab3			addatobc: 
8ab3 81			    add   a, c    ; A = A+L 
8ab4 4f			    ld    c, a    ; L = A+L 
8ab5 88			    adc   a, b    ; A = A+L+H+carry 
8ab6 91			    sub   c       ; A = H+carry 
8ab7 47			    ld    b, a    ; H = H+carry 
8ab8 c9			ret 
8ab9			 
8ab9			subafromhl: 
8ab9			   ; If A=0 do nothing 
8ab9			    ; Otherwise flip A's sign. Since 
8ab9			    ; the upper byte becomes -1, also 
8ab9			    ; substract 1 from H. 
8ab9 ed 44		    neg 
8abb ca c4 8a		    jp    z, Skip 
8abe 25			    dec   h 
8abf			     
8abf			    ; Now add the low byte as usual 
8abf			    ; Two's complement takes care of 
8abf			    ; ensuring the result is correct 
8abf 85			    add   a, l 
8ac0 6f			    ld    l, a 
8ac1 8c			    adc   a, h 
8ac2 95			    sub   l 
8ac3 67			    ld    h, a 
8ac4			Skip: 
8ac4 c9				ret 
8ac5			 
8ac5			 
8ac5			; compare hl and de 
8ac5			; returns:  
8ac5			; if hl = de, z=1, s=0, c0=0 
8ac5			; if hl > de, z=0, s=0, c=0 
8ac5			; if hl < de, z=0, s=1, c=1 
8ac5			cmp16:	 
8ac5 b7				or a 
8ac6 ed 52			sbc hl,de 
8ac8 e0				ret po 
8ac9 7c				ld a,h 
8aca 1f				rra 
8acb ee 40			xor 01000000B 
8acd 37				scf 
8ace 8f				adc a,a 
8acf c9				ret 
8ad0			 
8ad0			 
8ad0			; test if hl contains zero   - A is destroyed 
8ad0			 
8ad0			ishlzero:    
8ad0 b7				or a     ; reset flags 
8ad1 7c				ld a, h 
8ad2 b5				or l        	 
8ad3			 
8ad3 c9				ret 
8ad4			 
8ad4			 
8ad4			 
8ad4			 
8ad4			if FORTH_ENABLE_FLOATMATH 
8ad4			;include "float/bbcmath.z80" 
8ad4			include "float/lpfpcalc.asm" 
8ad4			endif 
8ad4			 
8ad4			 
8ad4			; eof 
8ad4			 
# End of file firmware_maths.asm
8ad4			include "firmware_strings.asm"   ; string handling  
8ad4			 
8ad4			 
8ad4			; TODO string len 
8ad4			; input text string, end on cr with zero term 
8ad4			; a offset into frame buffer to start prompt 
8ad4			; d is max length 
8ad4			; e is display size TODO 
8ad4			; c is current cursor position 
8ad4			; hl is ptr to where string will be stored 
8ad4			 
8ad4			 
8ad4			; TODO check limit of buffer for new inserts 
8ad4			; TODO check insert does not push beyond buffer 
8ad4			; TODO scroll in a limited display area 
8ad4			; TODO scroll whole screen on page wrap 
8ad4			 
8ad4			 
8ad4			; TODO handle KEY_PREVWORD 
8ad4			; TODO handle KEY_NEXTWORD 
8ad4			; TODO handle KEY_HOME 
8ad4			; TODO handle KEY_END 
8ad4			; TODO use LCD cursor? 
8ad4			 
8ad4 32 b9 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ad7 81					add c 
8ad8 32 b7 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8adb 22 bc ee				ld (input_start), hl     ; save ptr to buffer 
8ade 79					ld a, c 
8adf cd a7 8a				call addatohl 
8ae2 22 be ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ae5 7a					ld a,d 
8ae6 32 bb ee			        ld (input_size), a       ; save length of input area 
8ae9 79					ld a, c 
8aea 32 aa ee				ld (input_cursor),a      ; init cursor start position  
8aed 7b					ld a,e 
8aee 32 ba ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8af1					 
8af1					 
8af1			 
8af1			;		ld a,(input_ptr) 
8af1			;		ld (input_under_cursor),a 	; save what is under the cursor 
8af1			 
8af1			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8af1					; init cursor shape if not set by the cin routines 
8af1 21 59 ed				ld hl, cursor_shape 
8af4 3e ff				ld a, 255 
8af6 77					ld (hl), a 
8af7 23					inc hl 
8af8 3e 00				ld a, 0 
8afa 77					ld (hl), a 
8afb			 
8afb 3e 0f				ld a, CUR_BLINK_RATE 
8afd 32 b5 ee				ld (input_cur_flash), a 
8b00 3e 01				ld a, 1 
8b02 32 b4 ee				ld (input_cur_onoff),a 
8b05			 
8b05			;	if DEBUG_INPUT 
8b05			;		push af 
8b05			;		ld a, 'I' 
8b05			;		ld (debug_mark),a 
8b05			;		pop af 
8b05			;		CALLMONITOR 
8b05			;	endif 
8b05			.is1:		; main entry loop 
8b05			 
8b05			 
8b05			 
8b05					; pause 1ms 
8b05			 
8b05 3e 01				ld a, 1 
8b07 cd df 87				call aDelayInMS 
8b0a			 
8b0a					; dec flash counter 
8b0a 3a b5 ee				ld a, (input_cur_flash) 
8b0d 3d					dec a 
8b0e 32 b5 ee				ld (input_cur_flash), a 
8b11 fe 00				cp 0 
8b13 20 0d				jr nz, .nochgstate 
8b15			 
8b15			 
8b15					; change state 
8b15 3a b4 ee				ld a,(input_cur_onoff) 
8b18 ed 44				neg 
8b1a 32 b4 ee				ld (input_cur_onoff),a 
8b1d			 
8b1d			 
8b1d					; reset on change of state 
8b1d 3e 0f				ld a, CUR_BLINK_RATE 
8b1f 32 b5 ee				ld (input_cur_flash), a 
8b22			 
8b22			.nochgstate: 
8b22					 
8b22					 
8b22			 
8b22					; display cursor  
8b22			 
8b22			;		ld hl, (input_start) 
8b22			;		ld a, (input_cursor) 
8b22			;		call addatohl 
8b22			 
8b22					; get char under cursor and replace with cursor 
8b22 2a be ee		ld hl, (input_ptr) 
8b25			;		ld a, (hl) 
8b25			;		ld (input_under_cursor),a 
8b25			;		ld a, '_' 
8b25			;		ld (hl), a 
8b25			 
8b25					; display string 
8b25			 
8b25 ed 5b bc ee			ld de, (input_start) 
8b29 3a b9 ee				ld a, (input_at_pos) 
8b2c cd 8d 88				call str_at_display 
8b2f			;	        call update_display 
8b2f			 
8b2f					; find place to put the cursor 
8b2f			;		add h 
8b2f			;		ld l, display_row_1 
8b2f			;		sub l 
8b2f			; (input_at_pos) 
8b2f					;ld c, a 
8b2f			;		ld a, (input_cursor) 
8b2f			;		ld l, (input_at_pos) 
8b2f			;		;ld b, h 
8b2f			;		add l 
8b2f			;		ld (input_at_cursor),a 
8b2f					;ld l,h 
8b2f			 
8b2f			;		ld h, 0 
8b2f			;		ld l,(input_at_pos) 
8b2f			;		ld a, (input_cursor) 
8b2f			;		call addatohl 
8b2f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b2f			;		call subafromhl 
8b2f			;		ld a,l 
8b2f			;		ld (input_at_cursor), a 
8b2f			 
8b2f				if DEBUG_INPUT 
8b2f					ld a, (hardware_diag) 
8b2f					cp 0 
8b2f					jr z, .skip_input_diag 
8b2f			 
8b2f					ld a,(input_at_pos) 
8b2f					ld hl, LFSRSeed 
8b2f					call hexout 
8b2f					ld a, (input_cursor) 
8b2f					ld hl, LFSRSeed+2 
8b2f					call hexout 
8b2f					ld a,(input_at_cursor) 
8b2f					ld hl, LFSRSeed+4 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_cur_onoff) 
8b2f					ld hl, LFSRSeed+6 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_cur_flash) 
8b2f					ld hl, LFSRSeed+8 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_len) 
8b2f					ld hl, LFSRSeed+10 
8b2f					call hexout 
8b2f					ld hl, LFSRSeed+12 
8b2f					ld a, 0 
8b2f					ld (hl),a 
8b2f					ld a, display_row_4 
8b2f					ld de, LFSRSeed 
8b2f					call str_at_display 
8b2f					.skip_input_diag: 
8b2f				endif 
8b2f			 
8b2f					; decide on if we are showing the cursor this time round 
8b2f			 
8b2f 3a b4 ee				ld a, (input_cur_onoff) 
8b32 fe ff				cp 255 
8b34 28 13				jr z, .skipcur 
8b36			 
8b36			 
8b36 3a b7 ee				ld a,(input_at_cursor) 
8b39 11 59 ed				ld de, cursor_shape 
8b3c cd 8d 88				call str_at_display 
8b3f			 
8b3f					; save length of current input string 
8b3f 2a bc ee				ld hl, (input_start) 
8b42 cd 05 8f				call strlenz 
8b45 7d					ld a,l 
8b46 32 af ee				ld (input_len),a 
8b49			 
8b49			.skipcur: 
8b49			 
8b49 cd 9d 88			        call update_display 
8b4c					 
8b4c			 
8b4c			 
8b4c					; wait 
8b4c				 
8b4c					; TODO loop without wait to flash the cursor and char under cursor	 
8b4c cd 65 d8				call cin    ; _wait 
8b4f			 
8b4f fe 00				cp 0 
8b51 ca 05 8b				jp z, .is1 
8b54			 
8b54					; get ptr to char to input into 
8b54			 
8b54 4f					ld c,a 
8b55 2a bc ee				ld hl, (input_start) 
8b58 3a aa ee				ld a, (input_cursor) 
8b5b cd a7 8a				call addatohl 
8b5e 22 be ee				ld (input_ptr), hl 
8b61 79					ld a,c 
8b62			 
8b62					; replace char under cursor 
8b62			 
8b62			;		ld hl, (input_ptr) 
8b62			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b62			;		ld (hl), a 
8b62			 
8b62			;	if DEBUG_INPUT 
8b62			;		push af 
8b62			;		ld a, 'i' 
8b62			;		ld (debug_mark),a 
8b62			;		pop af 
8b62			;		CALLMONITOR 
8b62			;	endif 
8b62 fe 0e				cp KEY_HOME 
8b64 20 0e				jr nz, .iske 
8b66			 
8b66 3a b9 ee				ld a, (input_at_pos) 
8b69 32 b7 ee				ld (input_at_cursor),a 
8b6c 3e 00				ld a, 0 
8b6e 32 aa ee				ld (input_cursor), a 
8b71 c3 05 8b				jp .is1 
8b74					 
8b74 fe 0f		.iske:		cp KEY_END 
8b76 20 03				jr nz, .isknw 
8b78 c3 05 8b				jp .is1 
8b7b			 
8b7b fe 06		.isknw:		cp KEY_NEXTWORD 
8b7d 20 1b				jr nz, .iskpw 
8b7f			 
8b7f 2a be ee		.isknwm:	ld hl, (input_ptr) 
8b82 7e					ld a,(hl)	 
8b83 fe 00				cp 0 
8b85 ca 05 8b				jp z, .is1    ; end of string 
8b88 fe 20				cp ' ' 
8b8a ca 05 8b				jp z, .is1    ; end of word 
8b8d 23					inc hl 
8b8e 22 be ee				ld (input_ptr), hl 
8b91 3a b7 ee				ld a, (input_at_cursor) 
8b94 3c					inc a 
8b95 32 b7 ee				ld (input_at_cursor), a 
8b98 18 e5				jr .isknwm 
8b9a			 
8b9a fe 07		.iskpw:		cp KEY_PREVWORD 
8b9c 20 1b				jr nz, .iskl 
8b9e			.iskpwm:	 
8b9e 2a be ee				ld hl, (input_ptr) 
8ba1 7e					ld a,(hl)	 
8ba2 fe 00				cp 0  
8ba4 ca 05 8b				jp z, .is1    ; end of string 
8ba7 fe 20				cp ' ' 
8ba9 ca 05 8b				jp z, .is1    ; end of word 
8bac 2b					dec hl 
8bad 22 be ee				ld (input_ptr), hl 
8bb0 3a b7 ee				ld a, (input_at_cursor) 
8bb3 3d					dec a 
8bb4 32 b7 ee				ld (input_at_cursor), a 
8bb7 18 e5				jr .iskpwm 
8bb9			 
8bb9			 
8bb9 fe 0b		.iskl:		cp KEY_LEFT 
8bbb 20 27				jr nz, .isk1 
8bbd			 
8bbd 3a aa ee				ld a, (input_cursor) 
8bc0			 
8bc0 fe 00				cp 0 
8bc2 ca 05 8b				jp z, .is1 		; at start of line to ignore  
8bc5			 
8bc5 3d					dec  a 		; TODO check underflow 
8bc6 32 aa ee				ld (input_cursor), a 
8bc9			 
8bc9 2a be ee				ld hl, (input_ptr) 
8bcc 2b					dec hl 
8bcd 22 be ee				ld (input_ptr), hl 
8bd0					 
8bd0 3a b7 ee				ld a, (input_at_cursor) 
8bd3 3d					dec a 
8bd4 32 b7 ee				ld (input_at_cursor), a 
8bd7			 
8bd7 3e 01				ld a, 1		; show cursor moving 
8bd9 32 b4 ee				ld (input_cur_onoff),a 
8bdc 3e 0f				ld a, CUR_BLINK_RATE 
8bde 32 b5 ee				ld (input_cur_flash), a 
8be1			 
8be1 c3 05 8b				jp .is1 
8be4			 
8be4 fe 0c		.isk1:		cp KEY_RIGHT 
8be6 20 2a				jr nz, .isk2 
8be8			 
8be8 3a af ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8beb 5f					ld e,a 
8bec 3a aa ee				ld a, (input_cursor) 
8bef bb					cp e 
8bf0 ca 05 8b				jp z, .is1		; at the end of string so dont go right 
8bf3			 
8bf3 3c					inc  a 		; TODO check overflow 
8bf4 32 aa ee				ld (input_cursor), a 
8bf7			 
8bf7 3a b7 ee				ld a, (input_at_cursor) 
8bfa 3c					inc a 
8bfb 32 b7 ee				ld (input_at_cursor), a 
8bfe			 
8bfe 2a be ee				ld hl, (input_ptr) 
8c01 23					inc hl 
8c02 22 be ee				ld (input_ptr), hl 
8c05			 
8c05 3e 01				ld a, 1		; show cursor moving 
8c07 32 b4 ee				ld (input_cur_onoff),a 
8c0a 3e 0f				ld a, CUR_BLINK_RATE 
8c0c 32 b5 ee				ld (input_cur_flash), a 
8c0f			 
8c0f c3 05 8b				jp .is1 
8c12			 
8c12 fe 05		.isk2:		cp KEY_UP 
8c14			 
8c14 20 26				jr nz, .isk3 
8c16			 
8c16					; swap last command with the current on 
8c16			 
8c16					; move cursor to start of string 
8c16 2a bc ee				ld hl, (input_start) 
8c19 22 be ee				ld (input_ptr), hl 
8c1c			 
8c1c 3a b9 ee				ld a, (input_at_pos) 
8c1f 32 b7 ee				ld (input_at_cursor), a 
8c22			 
8c22 3e 00				ld a, 0 
8c24 32 aa ee				ld (input_cursor), a 
8c27					 
8c27					; swap input and last command buffers 
8c27			 
8c27 21 0d e8				ld hl, os_cli_cmd 
8c2a 11 0c e9				ld de, os_last_cmd 
8c2d 06 ff				ld b, 255 
8c2f 7e			.swap1:		ld a, (hl) 
8c30 4f					ld c,a 
8c31 1a					ld a, (de) 
8c32 77					ld (hl), a 
8c33 79					ld a,c 
8c34 12					ld (de),a 
8c35 23					inc hl 
8c36 13					inc de 
8c37 10 f6				djnz .swap1 
8c39			 
8c39			 
8c39			 
8c39			 
8c39			 
8c39 c3 05 8b				jp .is1 
8c3c			 
8c3c fe 08		.isk3:		cp KEY_BS 
8c3e 20 3c				jr nz, .isk4 
8c40			 
8c40 3a aa ee				ld a, (input_cursor) 
8c43			 
8c43 fe 00				cp 0 
8c45 ca 05 8b				jp z, .is1 		; at start of line to ignore  
8c48			 
8c48 3d					dec  a 		; TODO check underflow 
8c49 32 aa ee				ld (input_cursor), a 
8c4c			 
8c4c					; hl is source 
8c4c					; de needs to be source - 1 
8c4c			 
8c4c			;		ld a, 0 
8c4c			;		dec hl 
8c4c			;		ld (hl), a 
8c4c			 
8c4c 2a be ee				ld hl, (input_ptr) 
8c4f 2b					dec hl 
8c50 22 be ee				ld (input_ptr), hl 
8c53			 
8c53					; shift all data 
8c53			 
8c53 e5					push hl 
8c54 23					inc hl 
8c55 d1					pop de 
8c56 3a af ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c59 4f					ld c,a 
8c5a 06 00				ld b,0 
8c5c ed b0				ldir  
8c5e			 
8c5e			 
8c5e			 
8c5e			 
8c5e 3a b7 ee				ld a, (input_at_cursor) 
8c61 3d					dec a 
8c62 32 b7 ee				ld (input_at_cursor), a 
8c65			 
8c65			 
8c65 3e 01				ld a, 1		; show cursor moving 
8c67 32 b4 ee				ld (input_cur_onoff),a 
8c6a 3e 0f				ld a, CUR_BLINK_RATE 
8c6c 32 b5 ee				ld (input_cur_flash), a 
8c6f			 
8c6f					; remove char 
8c6f 3a b7 ee				ld a, (input_at_cursor) 
8c72 3c					inc a 
8c73 11 fd 8c				ld de,.iblank 
8c76 cd 8d 88				call str_at_display 
8c79			 
8c79 c3 05 8b				jp .is1 
8c7c			 
8c7c fe 0d		.isk4:		cp KEY_CR 
8c7e 28 6c				jr z, .endinput 
8c80			 
8c80					; else add the key press to the end 
8c80			 
8c80 4f					ld c, a			; save key pressed 
8c81			 
8c81 7e					ld a,(hl)		; get what is currently under char 
8c82			 
8c82 fe 00				cp 0			; we are at the end of the string 
8c84 20 2f				jr nz, .onchar 
8c86					 
8c86					; add a char to the end of the string 
8c86				 
8c86 71					ld (hl),c 
8c87 23					inc hl 
8c88			;		ld a,' ' 
8c88			;		ld (hl),a 
8c88			;		inc hl 
8c88 3e 00				ld a,0 
8c8a 77					ld (hl),a 
8c8b 2b					dec hl 
8c8c			 
8c8c 3a aa ee				ld a, (input_cursor) 
8c8f 3c					inc a				; TODO check max string length and scroll  
8c90 32 aa ee				ld (input_cursor), a		; inc cursor pos 
8c93							 
8c93 3a b7 ee				ld a, (input_at_cursor) 
8c96 3c					inc a 
8c97 32 b7 ee				ld (input_at_cursor), a 
8c9a			 
8c9a 2a be ee				ld hl, (input_ptr) 
8c9d 23					inc hl 
8c9e 22 be ee				ld (input_ptr), hl 
8ca1			 
8ca1 2a be ee				ld hl, (input_ptr) 
8ca4 23					inc hl 
8ca5 22 be ee				ld (input_ptr), hl 
8ca8			;	if DEBUG_INPUT 
8ca8			;		push af 
8ca8			;		ld a, '+' 
8ca8			;		ld (debug_mark),a 
8ca8			;		pop af 
8ca8			;		CALLMONITOR 
8ca8			;	endif 
8ca8 3e 01				ld a, 1		; show cursor moving 
8caa 32 b4 ee				ld (input_cur_onoff),a 
8cad 3e 0f				ld a, CUR_BLINK_RATE 
8caf 32 b5 ee				ld (input_cur_flash), a 
8cb2 c3 05 8b				jp .is1 
8cb5					 
8cb5			 
8cb5			 
8cb5					; if on a char then insert 
8cb5			.onchar: 
8cb5			 
8cb5					; TODO over flow check: make sure insert does not blow out buffer 
8cb5			 
8cb5					; need to do some maths to use lddr 
8cb5			 
8cb5 e5					push hl   ; save char pos 
8cb6 c5					push bc 
8cb7			 
8cb7 2a bc ee				ld hl, (input_start) 
8cba 3a af ee				ld a, (input_len) 
8cbd cd a7 8a				call addatohl  		; end of string 
8cc0 23					inc hl 
8cc1 23					inc hl		; past zero term 
8cc2 e5					push hl 
8cc3 23					inc hl 
8cc4 e5					push hl  
8cc5			 
8cc5								; start and end of lddr set, now how much to move? 
8cc5			 
8cc5							 
8cc5 3a aa ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cc8 47					ld b,a 
8cc9 3a af ee				ld a,(input_len) 
8ccc 5f					ld e,a 
8ccd 90					sub b 
8cce 3c					inc a		;?? 
8ccf 3c					inc a		;?? 
8cd0 3c					inc a		;?? 
8cd1			 
8cd1 06 00				ld b,0 
8cd3 4f					ld c,a 
8cd4			 
8cd4				if DEBUG_INPUT 
8cd4					push af 
8cd4					ld a, 'i' 
8cd4					ld (debug_mark),a 
8cd4					pop af 
8cd4			;		CALLMONITOR 
8cd4				endif 
8cd4 d1					pop de 
8cd5 e1					pop hl 
8cd6				if DEBUG_INPUT 
8cd6					push af 
8cd6					ld a, 'I' 
8cd6					ld (debug_mark),a 
8cd6					pop af 
8cd6			;		CALLMONITOR 
8cd6				endif 
8cd6 ed b8				lddr 
8cd8				 
8cd8			 
8cd8			 
8cd8					; TODO have a key for insert/overwrite mode???? 
8cd8 c1					pop bc 
8cd9 e1					pop hl 
8cda 71					ld (hl), c		; otherwise overwrite current char 
8cdb					 
8cdb			 
8cdb			 
8cdb			 
8cdb 3a aa ee				ld a, (input_cursor) 
8cde 3c					inc  a 		; TODO check overflow 
8cdf 32 aa ee				ld (input_cursor), a 
8ce2			 
8ce2 3a b7 ee				ld a, (input_at_cursor) 
8ce5 3c					inc a 
8ce6 32 b7 ee				ld (input_at_cursor), a 
8ce9			 
8ce9 c3 05 8b				jp .is1 
8cec			 
8cec			.endinput:	; TODO look for end of string 
8cec			 
8cec					; add trailing space for end of token 
8cec			 
8cec 2a bc ee				ld hl, (input_start) 
8cef 3a af ee				ld a,(input_len) 
8cf2 cd a7 8a				call addatohl 
8cf5 3e 20				ld a, ' ' 
8cf7 77					ld (hl),a 
8cf8					; TODO eof of parse marker 
8cf8			 
8cf8 23					inc hl 
8cf9 3e 00				ld a, 0 
8cfb 77					ld (hl),a 
8cfc			 
8cfc			 
8cfc c9					ret 
8cfd			 
8cfd .. 00		.iblank: db " ",0 
8cff			 
8cff			 
8cff 32 b9 ee		input_str_prev:	ld (input_at_pos), a 
8d02 22 bc ee				ld (input_start), hl 
8d05 3e 01				ld a,1			; add cursor 
8d07 77					ld (hl),a 
8d08 23					inc hl 
8d09 3e 00				ld a,0 
8d0b 77					ld (hl),a 
8d0c 22 be ee				ld (input_ptr), hl 
8d0f 7a					ld a,d 
8d10 32 bb ee				ld (input_size), a 
8d13 3e 00				ld a,0 
8d15 32 aa ee				ld (input_cursor),a 
8d18			.instr1:	 
8d18			 
8d18					; TODO do block cursor 
8d18					; TODO switch cursor depending on the modifer key 
8d18			 
8d18					; update cursor shape change on key hold 
8d18			 
8d18 2a be ee				ld hl, (input_ptr) 
8d1b 2b					dec hl 
8d1c 3a 59 ed				ld a,(cursor_shape) 
8d1f 77					ld (hl), a 
8d20			 
8d20					; display entered text 
8d20 3a b9 ee				ld a,(input_at_pos) 
8d23 cd c3 d7		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d26 ed 5b bc ee	            	LD   de, (input_start) 
8d2a cd bd d7		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d2d			 
8d2d cd 65 d8				call cin 
8d30 fe 00				cp 0 
8d32 28 e4				jr z, .instr1 
8d34			 
8d34					; proecess keyboard controls first 
8d34			 
8d34 2a be ee				ld hl,(input_ptr) 
8d37			 
8d37 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d39 28 5a				jr z, .instrcr 
8d3b			 
8d3b fe 08				cp KEY_BS 	; back space 
8d3d 20 0f				jr nz, .instr2 
8d3f					; process back space 
8d3f			 
8d3f					; TODO stop back space if at start of string 
8d3f 2b					dec hl 
8d40 2b					dec hl ; to over write cursor 
8d41 3a 59 ed				ld a,(cursor_shape) 
8d44					;ld a,0 
8d44 77					ld (hl),a 
8d45 23					inc hl 
8d46 3e 20				ld a," " 
8d48 77					ld (hl),a 
8d49 22 be ee				ld (input_ptr),hl 
8d4c					 
8d4c			 
8d4c 18 ca				jr .instr1 
8d4e			 
8d4e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d50 20 06				jr nz, .instr3 
8d52 2b					dec hl 
8d53 22 be ee				ld (input_ptr),hl 
8d56 18 c0				jr .instr1 
8d58				 
8d58 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d5a 20 06				jr nz, .instr4 
8d5c 23					inc hl 
8d5d 22 be ee				ld (input_ptr),hl 
8d60 18 b6				jr .instr1 
8d62			 
8d62 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d64 20 06				jr nz, .instr5 
8d66 2b					dec hl 
8d67 22 be ee				ld (input_ptr),hl 
8d6a 18 ac				jr .instr1 
8d6c			 
8d6c fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d6e 20 06				jr nz, .instr6 
8d70 2b					dec hl 
8d71 22 be ee				ld (input_ptr),hl 
8d74 18 a2				jr .instr1 
8d76 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d78 20 0b				jr nz, .instrnew 
8d7a			 
8d7a 21 e6 e4			ld hl, scratch 
8d7d 11 0c e9			ld de, os_last_cmd 
8d80 cd 9e 8d			call strcpy 
8d83 18 93				jr .instr1 
8d85			 
8d85			 
8d85			.instrnew:	; no special key pressed to see if we have room to store it 
8d85			 
8d85					; TODO do string size test 
8d85			 
8d85 2b					dec hl ; to over write cursor 
8d86 77					ld (hl),a 
8d87 23					inc hl 
8d88 3a 59 ed				ld a,(cursor_shape) 
8d8b 77					ld (hl),a 
8d8c 23					inc hl 
8d8d 3e 00				ld a,0 
8d8f 77					ld (hl),a 
8d90			 
8d90 22 be ee				ld (input_ptr),hl 
8d93					 
8d93 18 83				jr .instr1 
8d95 2b			.instrcr:	dec hl		; remove cursor 
8d96 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d98 77					ld (hl),a 
8d99 23					inc hl 
8d9a 3e 00				ld a,0 
8d9c 77					ld (hl),a 
8d9d			 
8d9d			 
8d9d					; if at end of line scroll up    
8d9d					; TODO detecting only end of line 4 for scroll up  
8d9d			 
8d9d					;ld   
8d9d			 
8d9d c9					ret 
8d9e			 
8d9e			 
8d9e			; strcpy hl = dest, de source 
8d9e			 
8d9e 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8d9f b7			            OR   A              ;Null terminator? 
8da0 c8			            RET  Z              ;Yes, so finished 
8da1 1a					ld a,(de) 
8da2 77					ld (hl),a 
8da3 13			            INC  DE             ;Point to next character 
8da4 23					inc hl 
8da5 18 f7		            JR   strcpy       ;Repeat 
8da7 c9					ret 
8da8			 
8da8			 
8da8			; TODO string_at  
8da8			; pass string which starts with lcd offset address and then null term string 
8da8			 
8da8			; TODO string to dec 
8da8			; TODO string to hex 
8da8			; TODO byte to string hex 
8da8			; TODO byte to string dec 
8da8			 
8da8			 
8da8			 
8da8			; from z80uartmonitor 
8da8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8da8			; pass hl for where to put the text 
8da8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da8 c5			hexout:	PUSH BC 
8da9 f5					PUSH AF 
8daa 47					LD B, A 
8dab					; Upper nybble 
8dab cb 3f				SRL A 
8dad cb 3f				SRL A 
8daf cb 3f				SRL A 
8db1 cb 3f				SRL A 
8db3 cd c3 8d				CALL tohex 
8db6 77					ld (hl),a 
8db7 23					inc hl	 
8db8					 
8db8					; Lower nybble 
8db8 78					LD A, B 
8db9 e6 0f				AND 0FH 
8dbb cd c3 8d				CALL tohex 
8dbe 77					ld (hl),a 
8dbf 23					inc hl	 
8dc0					 
8dc0 f1					POP AF 
8dc1 c1					POP BC 
8dc2 c9					RET 
8dc3					 
8dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc3			tohex: 
8dc3 e5					PUSH HL 
8dc4 d5					PUSH DE 
8dc5 16 00				LD D, 0 
8dc7 5f					LD E, A 
8dc8 21 d0 8d				LD HL, .DATA 
8dcb 19					ADD HL, DE 
8dcc 7e					LD A, (HL) 
8dcd d1					POP DE 
8dce e1					POP HL 
8dcf c9					RET 
8dd0			 
8dd0			.DATA: 
8dd0 30					DEFB	30h	; 0 
8dd1 31					DEFB	31h	; 1 
8dd2 32					DEFB	32h	; 2 
8dd3 33					DEFB	33h	; 3 
8dd4 34					DEFB	34h	; 4 
8dd5 35					DEFB	35h	; 5 
8dd6 36					DEFB	36h	; 6 
8dd7 37					DEFB	37h	; 7 
8dd8 38					DEFB	38h	; 8 
8dd9 39					DEFB	39h	; 9 
8dda 41					DEFB	41h	; A 
8ddb 42					DEFB	42h	; B 
8ddc 43					DEFB	43h	; C 
8ddd 44					DEFB	44h	; D 
8dde 45					DEFB	45h	; E 
8ddf 46					DEFB	46h	; F 
8de0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8de0			;;    subtract $30, if result > 9 then subtract $7 more 
8de0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de0			atohex: 
8de0 d6 30				SUB $30 
8de2 fe 0a				CP 10 
8de4 f8					RET M		; If result negative it was 0-9 so we're done 
8de5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8de7 c9					RET		 
8de8			 
8de8			 
8de8			 
8de8			 
8de8			; Get 2 ASCII characters as hex byte from pointer in hl 
8de8			 
8de8			BYTERD: 
8de8 16 00			LD	D,00h		;Set up 
8dea cd f2 8d			CALL	HEXCON		;Get byte and convert to hex 
8ded 87				ADD	A,A		;First nibble so 
8dee 87				ADD	A,A		;multiply by 16 
8def 87				ADD	A,A		; 
8df0 87				ADD	A,A		; 
8df1 57				LD	D,A		;Save hi nibble in D 
8df2			HEXCON: 
8df2 7e				ld a, (hl)		;Get next chr 
8df3 23				inc hl 
8df4 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8df6 fe 0a			CP	00Ah		;Is it 0-9 ? 
8df8 38 02			JR	C,NALPHA	;If so miss next bit 
8dfa d6 07			SUB	007h		;Else convert alpha 
8dfc			NALPHA: 
8dfc b2				OR	D		;Add hi nibble back 
8dfd c9				RET			; 
8dfe			 
8dfe			 
8dfe			; 
8dfe			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8dfe			; Since the routines get_byte and therefore get_nibble are called, only valid 
8dfe			; characters (0-9a-f) are accepted. 
8dfe			; 
8dfe			;get_word        push    af 
8dfe			;                call    get_byte        ; Get the upper byte 
8dfe			;                ld      h, a 
8dfe			;                call    get_byte        ; Get the lower byte 
8dfe			;                ld      l, a 
8dfe			;                pop     af 
8dfe			;                ret 
8dfe			; 
8dfe			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8dfe			; the routine get_nibble is used only valid characters are accepted - the  
8dfe			; input routine only accepts characters 0-9a-f. 
8dfe			; 
8dfe c5			get_byte:        push    bc              ; Save contents of B (and C) 
8dff 7e					ld a,(hl) 
8e00 23					inc hl 
8e01 cd 26 8e		                call    nibble2val      ; Get upper nibble 
8e04 cb 07		                rlc     a 
8e06 cb 07		                rlc     a 
8e08 cb 07		                rlc     a 
8e0a cb 07		                rlc     a 
8e0c 47			                ld      b, a            ; Save upper four bits 
8e0d 7e					ld a,(hl) 
8e0e cd 26 8e		                call    nibble2val      ; Get lower nibble 
8e11 b0			                or      b               ; Combine both nibbles 
8e12 c1			                pop     bc              ; Restore B (and C) 
8e13 c9			                ret 
8e14			; 
8e14			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e14			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e14			; to the serial line interface. The lower 4 bits of A contain the value of  
8e14			; that particular digit. 
8e14			; 
8e14			;get_nibble      ld a,(hl)           ; Read a character 
8e14			;                call    to_upper        ; Convert to upper case 
8e14			;                call    is_hex          ; Was it a hex digit? 
8e14			;                jr      nc, get_nibble  ; No, get another character 
8e14			 ;               call    nibble2val      ; Convert nibble to value 
8e14			 ;               call    print_nibble 
8e14			 ;               ret 
8e14			; 
8e14			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e14			; A valid hexadecimal digit is denoted by a set C flag. 
8e14			; 
8e14			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e14			;                ret     nc              ; Yes 
8e14			;                cp      '0'             ; Less than '0'? 
8e14			;                jr      nc, is_hex_1    ; No, continue 
8e14			;                ccf                     ; Complement carry (i.e. clear it) 
8e14			;                ret 
8e14			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e14			;                ret     c               ; Yes 
8e14			;                cp      'A'             ; Less than 'A'? 
8e14			;                jr      nc, is_hex_2    ; No, continue 
8e14			;                ccf                     ; Yes - clear carry and return 
8e14			;                ret 
8e14			;is_hex_2        scf                     ; Set carry 
8e14			;                ret 
8e14			; 
8e14			; Convert a single character contained in A to upper case: 
8e14			; 
8e14 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e16 d8			                ret     c 
8e17 fe 7b		                cp      'z' + 1         ; > 'z'? 
8e19 d0			                ret     nc              ; Nothing to do, either 
8e1a e6 5f		                and     $5f             ; Convert to upper case 
8e1c c9			                ret 
8e1d			 
8e1d			 
8e1d			to_lower: 
8e1d			 
8e1d			   ; if char is in [A-Z] make it lower case 
8e1d			 
8e1d			   ; enter : a = char 
8e1d			   ; exit  : a = lower case char 
8e1d			   ; uses  : af 
8e1d			 
8e1d fe 41		   cp 'A' 
8e1f d8			   ret c 
8e20			    
8e20 fe 5b		   cp 'Z'+1 
8e22 d0			   ret nc 
8e23			    
8e23 f6 20		   or $20 
8e25 c9			   ret 
8e26			 
8e26			; 
8e26			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e26			; corresponding value in A. 
8e26			; 
8e26 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e28 38 02		                jr      c, nibble2val_1 ; Yes 
8e2a d6 07		                sub     7               ; Adjust for A-F 
8e2c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e2e e6 0f		                and     $f              ; Only return lower 4 bits 
8e30 c9			                ret 
8e31			; 
8e31			; Print_nibble prints a single hex nibble which is contained in the lower  
8e31			; four bits of A: 
8e31			; 
8e31			;print_nibble    push    af              ; We won't destroy the contents of A 
8e31			;                and     $f              ; Just in case... 
8e31			;                add     a, '0'             ; If we have a digit we are done here. 
8e31			;                cp      '9' + 1         ; Is the result > 9? 
8e31			;                jr      c, print_nibble_1 
8e31			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e31			;print_nibble_1  call    putc            ; Print the nibble and 
8e31			;                pop     af              ; restore the original value of A 
8e31			;                ret 
8e31			;; 
8e31			;; Send a CR/LF pair: 
8e31			; 
8e31			;crlf            push    af 
8e31			;                ld      a, cr 
8e31			;                call    putc 
8e31			;                ld      a, lf 
8e31			;                call    putc 
8e31			;                pop     af 
8e31			;                ret 
8e31			; 
8e31			; Print_word prints the four hex digits of a word to the serial line. The  
8e31			; word is expected to be in HL. 
8e31			; 
8e31			;print_word      push    hl 
8e31			;                push    af 
8e31			;                ld      a, h 
8e31			;                call    print_byte 
8e31			;                ld      a, l 
8e31			;                call    print_byte 
8e31			;                pop     af 
8e31			;                pop     hl 
8e31			;                ret 
8e31			; 
8e31			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e31			; The byte to be printed is expected to be in A. 
8e31			; 
8e31			;print_byte      push    af              ; Save the contents of the registers 
8e31			;                push    bc 
8e31			;                ld      b, a 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                call    print_nibble    ; Print high nibble 
8e31			;                ld      a, b 
8e31			;                call    print_nibble    ; Print low nibble 
8e31			;                pop     bc              ; Restore original register contents 
8e31			;                pop     af 
8e31			;                ret 
8e31			 
8e31			 
8e31			 
8e31			 
8e31			 
8e31			fourehexhl:  
8e31 7e				ld a,(hl) 
8e32 cd e0 8d			call atohex 
8e35 cb 3f				SRL A 
8e37 cb 3f				SRL A 
8e39 cb 3f				SRL A 
8e3b cb 3f				SRL A 
8e3d 47				ld b, a 
8e3e 23				inc hl 
8e3f 7e				ld a,(hl) 
8e40 23				inc hl 
8e41 cd e0 8d			call atohex 
8e44 80				add b 
8e45 57				ld d,a 
8e46 7e				ld a,(hl) 
8e47 cd e0 8d			call atohex 
8e4a cb 3f				SRL A 
8e4c cb 3f				SRL A 
8e4e cb 3f				SRL A 
8e50 cb 3f				SRL A 
8e52 47				ld b, a 
8e53 23				inc hl 
8e54 7e				ld a,(hl) 
8e55 23				inc hl 
8e56 cd e0 8d			call atohex 
8e59 80				add b 
8e5a 5f				ld e, a 
8e5b d5				push de 
8e5c e1				pop hl 
8e5d c9				ret 
8e5e			 
8e5e			; pass hl. returns z set if the byte at hl is a digit 
8e5e			;isdigithl:  
8e5e			;	push bc 
8e5e			;	ld a,(hl) 
8e5e			;	cp ':' 
8e5e			;	jr nc, .isdf 		; > 
8e5e			;	cp '0' 
8e5e			;	jr c, .isdf		; < 
8e5e			; 
8e5e			;	; TODO find a better way to set z 
8e5e			; 
8e5e			;	ld b,a 
8e5e			;	cp b 
8e5e			;	pop bc 
8e5e			;	ret 
8e5e			; 
8e5e			;.isdf:	; not digit so clear z 
8e5e			; 
8e5e			;	; TODO find a better way to unset z 
8e5e			; 
8e5e			;	ld b,a 
8e5e			;	inc b 
8e5e			;	cp b 
8e5e			; 
8e5e			;	pop bc 
8e5e			;	ret 
8e5e				 
8e5e				 
8e5e			 
8e5e			 
8e5e			; pass hl as the four byte address to load 
8e5e			 
8e5e			get_word_hl:  
8e5e e5				push hl 
8e5f cd fe 8d			call get_byte 
8e62				 
8e62 47				ld b, a 
8e63			 
8e63 e1				pop hl 
8e64 23				inc hl 
8e65 23				inc hl 
8e66			 
8e66			; TODO not able to handle a-f  
8e66 7e				ld a,(hl) 
8e67			;	;cp ':' 
8e67			;	cp 'g' 
8e67			;	jr nc, .single_byte_hl 		; > 
8e67			;	cp 'G' 
8e67			;	jr nc, .single_byte_hl 		; > 
8e67			;	cp '0' 
8e67			;	jr c, .single_byte_hl		; < 
8e67			 
8e67				;call isdigithl 
8e67 fe 00			cp 0 
8e69 28 06			jr z, .single_byte_hl 
8e6b			 
8e6b			.getwhln:   ; hex word so get next byte 
8e6b			 
8e6b cd fe 8d			call get_byte 
8e6e 6f				ld l, a 
8e6f 60				ld h,b 
8e70 c9				ret 
8e71 68			.single_byte_hl:   ld l,b 
8e72 26 00				ld h,0 
8e74 c9					ret 
8e75			 
8e75			 
8e75			 
8e75			 
8e75 21 98 95			ld hl,asc+1 
8e78			;	ld a, (hl) 
8e78			;	call nibble2val 
8e78 cd fe 8d			call get_byte 
8e7b			 
8e7b			;	call fourehexhl 
8e7b 32 1a e5			ld (scratch+52),a 
8e7e				 
8e7e 21 18 e5			ld hl,scratch+50 
8e81 22 09 e8			ld (os_cur_ptr),hl 
8e84			 
8e84 c9				ret 
8e85			 
8e85			 
8e85			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e85			 
8e85			; Decimal Unsigned Version 
8e85			 
8e85			;Number in a to decimal ASCII 
8e85			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e85			;Example: display a=56 as "056" 
8e85			;input: a = number 
8e85			;Output: a=0,value of a in the screen 
8e85			;destroys af,bc (don't know about hl and de) 
8e85			DispAToASCII: 
8e85 0e 9c			ld	c,-100 
8e87 cd 91 8e			call	.Na1 
8e8a 0e f6			ld	c,-10 
8e8c cd 91 8e			call	.Na1 
8e8f 0e ff			ld	c,-1 
8e91 06 2f		.Na1:	ld	b,'0'-1 
8e93 04			.Na2:	inc	b 
8e94 81				add	a,c 
8e95 38 fc			jr	c,.Na2 
8e97 91				sub	c		;works as add 100/10/1 
8e98 f5				push af		;safer than ld c,a 
8e99 78				ld	a,b		;char is in b 
8e9a			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e9a f1				pop af		;safer than ld a,c 
8e9b c9				ret 
8e9c			 
8e9c			; Decimal Signed Version 
8e9c			 
8e9c			; DispA 
8e9c			; -------------------------------------------------------------- 
8e9c			; Converts a signed integer value to a zero-terminated ASCII 
8e9c			; string representative of that value (using radix 10). 
8e9c			; -------------------------------------------------------------- 
8e9c			; INPUTS: 
8e9c			;     HL     Value to convert (two's complement integer). 
8e9c			;     DE     Base address of string destination. (pointer). 
8e9c			; -------------------------------------------------------------- 
8e9c			; OUTPUTS: 
8e9c			;     None 
8e9c			; -------------------------------------------------------------- 
8e9c			; REGISTERS/MEMORY DESTROYED 
8e9c			; AF HL 
8e9c			; -------------------------------------------------------------- 
8e9c			 
8e9c			;DispHLToASCII: 
8e9c			;   push    de 
8e9c			;   push    bc 
8e9c			; 
8e9c			;; Detect sign of HL. 
8e9c			;    bit    7, h 
8e9c			;    jr     z, ._DoConvert 
8e9c			; 
8e9c			;; HL is negative. Output '-' to string and negate HL. 
8e9c			;    ld     a, '-' 
8e9c			;    ld     (de), a 
8e9c			;    inc    de 
8e9c			; 
8e9c			;; Negate HL (using two's complement) 
8e9c			;    xor    a 
8e9c			;    sub    l 
8e9c			;    ld     l, a 
8e9c			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e9c			;    sbc    a, h 
8e9c			;    ld     h, a 
8e9c			; 
8e9c			;; Convert HL to digit characters 
8e9c			;._DoConvert: 
8e9c			;    ld     b, 0     ; B will count character length of number 
8e9c			;-   ld     a, 10 
8e9c			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e9c			;    push   af 
8e9c			;    inc    b 
8e9c			;    ld     a, h 
8e9c			;    or     l 
8e9c			;    jr     nz, - 
8e9c			; 
8e9c			;; Retrieve digits from stack 
8e9c			;-   pop    af 
8e9c			;    or     $30 
8e9c			;    ld     (de), a 
8e9c			;    inc    de 
8e9c			;    djnz   - 
8e9c			; 
8e9c			;; Terminate string with NULL 
8e9c			;    xor    a 
8e9c			;    ld     (de), a 
8e9c			; 
8e9c			;    pop    bc 
8e9c			;    pop    de 
8e9c			;    ret 
8e9c			 
8e9c			;Comments 
8e9c			; 
8e9c			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e9c			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e9c			;    Note that the output string will not be fixed-width. 
8e9c			; 
8e9c			;Example Usage 
8e9c			; 
8e9c			;    ld    hl, -1004 
8e9c			;    ld    de, OP1 
8e9c			;    call  DispA 
8e9c			;    ld    hl, OP1 
8e9c			;    syscall  PutS 
8e9c			 
8e9c			 
8e9c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e9c			 
8e9c			 
8e9c			;Converts an ASCII string to an unsigned 16-bit integer 
8e9c			;Quits when it reaches a non-decimal digit 
8e9c			 
8e9c			string_to_uint16: 
8e9c			atoui_16: 
8e9c			;Input: 
8e9c			;     DE points to the string 
8e9c			;Outputs: 
8e9c			;     HL is the result 
8e9c			;     A is the 8-bit value of the number 
8e9c			;     DE points to the byte after the number 
8e9c			;Destroys: 
8e9c			;     BC 
8e9c			;       if the string is non-empty, BC is HL/10 
8e9c			;Size:  24 bytes 
8e9c			;Speed: 42+d(104+{0,9}) 
8e9c			;       d is the number of digits in the number 
8e9c			;       max is 640 cycles for a 5 digit number 
8e9c			;Assuming no leading zeros: 
8e9c			;1 digit:  146cc 
8e9c			;2 digit:  250cc 
8e9c			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e9c			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e9c			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e9c			;avg: 544.81158447265625cc (544+13297/16384) 
8e9c			;=============================================================== 
8e9c 21 00 00		  ld hl,0 
8e9f			.u16a: 
8e9f 1a			  ld a,(de) 
8ea0 d6 30		  sub 30h 
8ea2 fe 0a		  cp 10 
8ea4 d0			  ret nc 
8ea5 13			  inc de 
8ea6 44			  ld b,h 
8ea7 4d			  ld c,l 
8ea8 29			  add hl,hl 
8ea9 29			  add hl,hl 
8eaa 09			  add hl,bc 
8eab 29			  add hl,hl 
8eac 85			  add a,l 
8ead 6f			  ld l,a 
8eae 30 ef		  jr nc,.u16a 
8eb0 24			  inc h 
8eb1 c3 9f 8e		  jp .u16a 
8eb4			 
8eb4			 
8eb4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb4			 
8eb4			;written by Zeda 
8eb4			;Converts a 16-bit unsigned integer to an ASCII string. 
8eb4			 
8eb4			uitoa_16: 
8eb4			;Input: 
8eb4			;   DE is the number to convert 
8eb4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8eb4			;Output: 
8eb4			;   HL points to the null-terminated ASCII string 
8eb4			;      NOTE: This isn't necessarily the same as the input HL. 
8eb4 d5			  push de 
8eb5 c5			  push bc 
8eb6 f5			  push af 
8eb7 eb			  ex de,hl 
8eb8			 
8eb8 01 f0 d8		  ld bc,-10000 
8ebb 3e 2f		  ld a,'0'-1 
8ebd 3c			  inc a 
8ebe 09			  add hl,bc  
8ebf 38 fc		   jr c,$-2 
8ec1 12			  ld (de),a 
8ec2 13			  inc de 
8ec3			 
8ec3 01 e8 03		  ld bc,1000 
8ec6 3e 3a		  ld a,'9'+1 
8ec8 3d			  dec a  
8ec9 09			  add hl,bc  
8eca 30 fc		   jr nc,$-2 
8ecc 12			  ld (de),a 
8ecd 13			  inc de 
8ece			 
8ece 01 9c ff		  ld bc,-100 
8ed1 3e 2f		  ld a,'0'-1 
8ed3 3c			  inc a  
8ed4 09			  add hl,bc  
8ed5 38 fc		   jr c,$-2 
8ed7 12			  ld (de),a 
8ed8 13			  inc de 
8ed9			 
8ed9 7d			  ld a,l 
8eda 26 3a		  ld h,'9'+1 
8edc 25			  dec h  
8edd c6 0a		  add a,10  
8edf 30 fb		   jr nc,$-3 
8ee1 c6 30		  add a,'0' 
8ee3 eb			  ex de,hl 
8ee4 72			  ld (hl),d 
8ee5 23			  inc hl 
8ee6 77			  ld (hl),a 
8ee7 23			  inc hl 
8ee8 36 00		  ld (hl),0 
8eea			 
8eea			;Now strip the leading zeros 
8eea 0e fa		  ld c,-6 
8eec 09			  add hl,bc 
8eed 3e 30		  ld a,'0' 
8eef 23			  inc hl  
8ef0 be			  cp (hl)  
8ef1 28 fc		  jr z,$-2 
8ef3			 
8ef3			;Make sure that the string is non-empty! 
8ef3 7e			  ld a,(hl) 
8ef4 b7			  or a 
8ef5 20 01		  jr nz,.atoub 
8ef7 2b			  dec hl 
8ef8			.atoub: 
8ef8			 
8ef8 f1			  pop af 
8ef9 c1			  pop bc 
8efa d1			  pop de 
8efb c9			  ret 
8efc			 
8efc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8efc			 
8efc			toUpper: 
8efc			;A is the char. 
8efc			;If A is a lowercase letter, this sets it to the matching uppercase 
8efc			;18cc or 30cc or 41cc 
8efc			;avg: 26.75cc 
8efc fe 61		  cp 'a' 
8efe d8			  ret c 
8eff fe 7b		  cp 'z'+1 
8f01 d0			  ret nc 
8f02 d6 20		  sub 'a'-'A' 
8f04 c9			  ret 
8f05			 
8f05			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f05			 
8f05			; String Length 
8f05			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f05			 
8f05			; Get the length of the null-terminated string starting at $8000 hl 
8f05			;    LD     HL, $8000 
8f05			 
8f05			strlenz: 
8f05			 
8f05 af			    XOR    A               ; Zero is the value we are looking for. 
8f06 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f07 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f08			                           ; 65, 536 bytes (the entire addressable memory space). 
8f08 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f0a			 
8f0a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f0a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f0b 6f			    LD     L, A             ; number of bytes 
8f0c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f0e 2b			    DEC    HL              ; Compensate for null. 
8f0f c9				ret 
8f10			 
8f10			; Get the length of the A terminated string starting at $8000 hl 
8f10			;    LD     HL, $8000 
8f10			 
8f10			strlent: 
8f10			 
8f10			                  ; A is the value we are looking for. 
8f10 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f12 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f14			                           ; 65, 536 bytes (the entire addressable memory space). 
8f14 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f16			 
8f16			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f16 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f18 2e 00		    LD     L, 0             ; number of bytes 
8f1a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f1c 2b			    DEC    HL              ; Compensate for null. 
8f1d c9				ret 
8f1e			 
8f1e			 
8f1e			;Comparing Strings 
8f1e			 
8f1e			;IN    HL     Address of string1. 
8f1e			;      DE     Address of string2. 
8f1e			 
8f1e			; doc given but wrong??? 
8f1e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f1e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f1e			; tested 
8f1e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f1e			 
8f1e			strcmp_old: 
8f1e e5			    PUSH   HL 
8f1f d5			    PUSH   DE 
8f20			 
8f20 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f21 be			    CP     (HL)            ; (want to minimize work). 
8f22 38 01		    JR     C, Str1IsBigger 
8f24 7e			    LD     A, (HL) 
8f25			 
8f25			Str1IsBigger: 
8f25 4f			    LD     C, A             ; Put length in BC 
8f26 06 00		    LD     B, 0 
8f28 13			    INC    DE              ; Increment pointers to meat of string. 
8f29 23			    INC    HL 
8f2a			 
8f2a			CmpLoop: 
8f2a 1a			    LD     A, (DE)          ; Compare bytes. 
8f2b ed a1		    CPI 
8f2d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f2f 13			    INC    DE              ; Update pointer. 
8f30 ea 2a 8f		    JP     PE, CmpLoop 
8f33			 
8f33 d1			    POP    DE 
8f34 e1			    POP    HL 
8f35 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f36 be			    CP     (HL) 
8f37 c9			    RET 
8f38			 
8f38			NoMatch: 
8f38 2b			    DEC    HL 
8f39 be			    CP     (HL)            ; Compare again to affect carry. 
8f3a d1			    POP    DE 
8f3b e1			    POP    HL 
8f3c c9			    RET 
8f3d			 
8f3d			;; test strmp 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str2 
8f3d			;call strcmp 
8f3d			;jr z, .z1 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "NZ1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.z1: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "ZZ1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str1 
8f3d			;call strcmp 
8f3d			;jr z, .z2 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "NZ2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.z2: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "ZZ2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str2 
8f3d			;call strcmp 
8f3d			;jr c, .c1 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "Nc1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.c1: 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "cc1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str1 
8f3d			;call strcmp 
8f3d			;jr c, .c2 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "Nc2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.c2: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "cc2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;	NEXTW 
8f3d			;.str1:   db "string1",0 
8f3d			;.str2:   db "string2",0 
8f3d			 
8f3d			; only care about direct match or not 
8f3d			; hl and de strings 
8f3d			; zero set if the same 
8f3d			 
8f3d			strcmp: 
8f3d 1a				ld a, (de) 
8f3e be				cp (hl) 
8f3f 28 02			jr z, .ssame 
8f41 b7				or a 
8f42 c9				ret 
8f43			 
8f43			.ssame:  
8f43 fe 00			cp 0 
8f45 c8				ret z 
8f46			 
8f46 23				inc hl 
8f47 13				inc de 
8f48 18 f3			jr strcmp 
8f4a				 
8f4a				 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			; eof 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
# End of file firmware_strings.asm
8f4a			include "firmware_memory.asm"   ; malloc and free  
8f4a			 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			.mallocsize: db "Wants malloc >256",0 
8f4a			.mallocasize: db "MALLOC gives >256",0 
8f4a			.malloczero: db "MALLOC gives zero",0 
8f4a			 
8f4a			malloc_guard_zerolen: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a				ld de, 0 
8f4a			        call cmp16 
8f4a				jr nz, .lowalloz 
8f4a			 
8f4a				push hl 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .malloczero 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a			 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				 
8f4a			 
8f4a				CALLMONITOR 
8f4a			.lowalloz: 
8f4a			 
8f4a			 
8f4a				pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			 
8f4a			malloc_guard_entry: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a			 	or a      ;clear carry flag 
8f4a				push hl 
8f4a				ld de, 255 
8f4a				sbc hl, de 
8f4a				jr c, .lowalloc 
8f4a			 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .mallocsize 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a			 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				 
8f4a			 
8f4a				CALLMONITOR 
8f4a				jr .lowdone 
8f4a			.lowalloc: 
8f4a			 
8f4a			 
8f4a				pop hl 
8f4a			.lowdone:	pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			 
8f4a			malloc_guard_exit: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a			 	or a      ;clear carry flag 
8f4a				push hl 
8f4a				ld de, 255 
8f4a				sbc hl, de 
8f4a				jr c, .lowallocx 
8f4a			 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .mallocasize 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				CALLMONITOR 
8f4a				jr .lowdonex 
8f4a			.lowallocx: 
8f4a			 
8f4a				pop hl 
8f4a			.lowdonex:	pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			endif 
8f4a			 
8f4a			if MALLOC_2 
8f4a			; Z80 Malloc and Free Functions 
8f4a			 
8f4a			; Malloc Function: 
8f4a			; Input: 
8f4a			;   HL: Size of block to allocate 
8f4a			; Output: 
8f4a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4a			 
8f4a			malloc: 
8f4a				 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			call malloc_guard_entry 
8f4a			endif 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "mal" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			    push af            ; Save AF register 
8f4a			    ld a, l            ; Load low byte of size into A 
8f4a			    or h               ; Check if size is zero 
8f4a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f4a			 
8f4a			    ; Allocate memory 
8f4a			    ld hl, (heap_start) ; Load start of heap into HL 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma1" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			    call malloc_internal ; Call internal malloc function 
8f4a			    pop af             ; Restore AF register 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret                ; Return 
8f4a			 
8f4a			; Free Function: 
8f4a			; Input: 
8f4a			;   HL: Pointer to memory block to free 
8f4a			; Output: 
8f4a			;   None 
8f4a			 
8f4a			free: 
8f4a			    push af            ; Save AF register 
8f4a			    ld a, l            ; Load low byte of pointer into A 
8f4a			    or h               ; Check if pointer is NULL 
8f4a			    jp z, free_exit    ; If pointer is NULL, exit 
8f4a			 
8f4a			    ; Free memory 
8f4a			    ld hl, (heap_start) ; Load start of heap into HL 
8f4a			    call free_internal  ; Call internal free function 
8f4a			    pop af             ; Restore AF register 
8f4a			    ret                ; Return 
8f4a			 
8f4a			; Internal Malloc Function: 
8f4a			; Input: 
8f4a			;   HL: Size of block to allocate 
8f4a			; Output: 
8f4a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4a			 
8f4a			malloc_internal: 
8f4a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f4a			    add hl, bc         ; Add management overhead to requested size 
8f4a			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma2" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			 
8f4a			    ; Search for free memory block 
8f4a			    ld de, (heap_end)  ; Load end of heap into DE 
8f4a			    ld bc, 0           ; Initialize counter 
8f4a			 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma2" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			malloc_search_loop: 
8f4a			    ; Check if current block is free 
8f4a			    ld a, (hl)         ; Load current block's status (free or used) 
8f4a			    cp 0               ; Compare with zero (free) 
8f4a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f4a			 
8f4a			    ; Check if current block is large enough 
8f4a			    ld a, (hl+1)       ; Load high byte of block size 
8f4a			    cp l               ; Compare with low byte of requested size 
8f4a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f4a			 
8f4a			    ld a, (hl+2)       ; Load low byte of block size 
8f4a			    cp h               ; Compare with high byte of requested size 
8f4a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f4a			 
8f4a			    ; Mark block as used 
8f4a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f4a			 
8f4a			    ; Calculate remaining space in block 
8f4a			    ld bc, 0           ; Clear BC 
8f4a			    add hl, bc         ; Increment HL to point to start of data block 
8f4a			    add hl, de         ; HL = HL + DE (total size) 
8f4a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f4a			    add hl, bc         ; Add management overhead to start of data block 
8f4a			 
8f4a			    ; Save pointer to allocated block in HL 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma5" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			 
8f4a			malloc_skip_block_check: 
8f4a			    ; Move to the next block 
8f4a			    ld bc, 3           ; Size of management overhead 
8f4a			    add hl, bc         ; Move to the next block 
8f4a			    inc de             ; Increment counter 
8f4a			 
8f4a			    ; Check if we have reached the end of heap 
8f4a			    ld a, e            ; Load low byte of heap end address 
8f4a			    cp (hl)            ; Compare with low byte of current address 
8f4a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f4a			    ld a, d            ; Load high byte of heap end address 
8f4a			    cp 0               ; Check if it's zero (end of memory) 
8f4a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f4a			 
8f4a			    ; If we reached here, allocation failed 
8f4a			    xor a              ; Set result to NULL 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma6" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			malloc_exit: 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma7" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			 
8f4a			; Internal Free Function: 
8f4a			; Input: 
8f4a			;   HL: Pointer to memory block to free 
8f4a			; Output: 
8f4a			;   None 
8f4a			 
8f4a			free_internal: 
8f4a			    ld de, (heap_start) ; Load start of heap into DE 
8f4a			    ld bc, 0            ; Initialize counter 
8f4a			 
8f4a			free_search_loop: 
8f4a			    ; Check if current block contains the pointer 
8f4a			    ld a, l             ; Load low byte of pointer 
8f4a			    cp (hl+1)           ; Compare with high byte of current block's address 
8f4a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4a			    ld a, h             ; Load high byte of pointer 
8f4a			    cp (hl+2)           ; Compare with low byte of current block's address 
8f4a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4a			 
8f4a			    ; Mark block as free 
8f4a			    ld (hl), 0          ; Set status byte to indicate free block 
8f4a			    ret                 ; Return 
8f4a			 
8f4a			free_skip_block_check: 
8f4a			    ; Move to the next block 
8f4a			    ld bc, 3            ; Size of management overhead 
8f4a			    add hl, bc          ; Move to the next block 
8f4a			    inc de              ; Increment counter 
8f4a			 
8f4a			    ; Check if we have reached the end of heap 
8f4a			    ld a, e             ; Load low byte of heap end address 
8f4a			    cp (hl)             ; Compare with low byte of current address 
8f4a			    jr nz, free_search_loop  ; If not equal, continue searching 
8f4a			    ld a, d             ; Load high byte of heap end address 
8f4a			    cp 0                ; Check if it's zero (end of memory) 
8f4a			    jr nz, free_search_loop  ; If not zero, continue searching 
8f4a			 
8f4a			    ; If we reached here, pointer is not found in heap 
8f4a			    ret 
8f4a			 
8f4a			free_exit: 
8f4a			    ret                 ; Return 
8f4a			 
8f4a			; Define heap start and end addresses 
8f4a			;heap_start:    .dw 0xC000   ; Start of heap 
8f4a			;heap_end:      .dw 0xE000   ; End of heap 
8f4a			 
8f4a			endif 
8f4a			 
8f4a			 
8f4a			if MALLOC_1 
8f4a			 
8f4a			 
8f4a			 
8f4a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f4a			 
8f4a			;moved to firmware.asm 
8f4a			;heap_start        .equ  0x9000      ; Starting address of heap 
8f4a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f4a			 
8f4a			;      .org 0 
8f4a			;      jp    main 
8f4a			 
8f4a			 
8f4a			;      .org  0x100 
8f4a			;main: 
8f4a			;      ld    HL, 0x8100 
8f4a			;      ld    SP, HL 
8f4a			; 
8f4a			;      call  heap_init 
8f4a			; 
8f4a			;      ; Make some allocations 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9004 
8f4a			; 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9014 
8f4a			; 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9024 
8f4a			; 
8f4a			;      ; Free some allocations 
8f4a			;      ld    HL, 0x9014 
8f4a			;      call  free 
8f4a			; 
8f4a			;      ld    HL, 0x9004 
8f4a			;      call  free 
8f4a			; 
8f4a			;      ld    HL, 0x9024 
8f4a			;      call  free 
8f4a			; 
8f4a			; 
8f4a			;      halt 
8f4a			 
8f4a			 
8f4a			;------------------------------------------------------------------------------ 
8f4a			;     heap_init                                                               : 
8f4a			;                                                                             : 
8f4a			; Description                                                                 : 
8f4a			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f4a			;                                                                             : 
8f4a			;     The heap is maintained as a linked list, starting with an initial       : 
8f4a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f4a			;     the first free block in the heap. Each block then points to the next    : 
8f4a			;     free block within the heap, and the free list ends at the first block   : 
8f4a			;     with a null pointer to the next free block.                             : 
8f4a			;                                                                             : 
8f4a			; Parameters                                                                  : 
8f4a			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f4a			;     address of the heap and its size are required, along with a memory      : 
8f4a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f4a			;     principally stores a pointer to the first free block in the heap.       : 
8f4a			;                                                                             : 
8f4a			; Returns                                                                     : 
8f4a			;     Nothing                                                                 : 
8f4a			;------------------------------------------------------------------------------ 
8f4a			heap_init: 
8f4a e5			      push  HL 
8f4b			 
8f4b			      ; Initialise free list struct 
8f4b 21 83 d8		      ld    HL, heap_start 
8f4e 22 7e d8		      ld    (free_list), HL 
8f51 21 00 00		      ld    HL, 0 
8f54 22 80 d8		      ld    (free_list+2), HL 
8f57			 
8f57			      ; Insert first free block at bottom of heap, consumes entire heap 
8f57 21 c8 e4		      ld    HL, heap_start+heap_size-4 
8f5a 22 83 d8		      ld    (heap_start), HL        ; Next block (end of free list) 
8f5d 21 45 0c		      ld    HL, heap_size-4 
8f60 22 85 d8		      ld    (heap_start+2), HL      ; Block size 
8f63			 
8f63			      ; Insert end of free list block at top of heap - two null words will 
8f63			      ; terminate the free list 
8f63 21 00 00		      ld    HL, 0 
8f66 22 ca e4		      ld    (heap_start+heap_size-2), HL 
8f69 22 c8 e4		      ld    (heap_start+heap_size-4), HL 
8f6c			 
8f6c e1			      pop   HL 
8f6d			 
8f6d c9			      ret 
8f6e			 
8f6e			 
8f6e			;------------------------------------------------------------------------------ 
8f6e			;     malloc                                                                  : 
8f6e			;                                                                             : 
8f6e			; Description                                                                 : 
8f6e			;     Allocates the wanted space from the heap and returns the address of the : 
8f6e			;     first useable byte of the allocation.                                   : 
8f6e			;                                                                             : 
8f6e			;     Allocations can happen in one of two ways:                              : 
8f6e			;                                                                             : 
8f6e			;     1. A free block may be found which is the exact size wanted. In this    : 
8f6e			;        case the block is removed from the free list and retuedn to the      : 
8f6e			;        caller.                                                              : 
8f6e			;     2. A free block may be found which is larger than the size wanted. In   : 
8f6e			;        this case, the larger block is split into two. The first portion of  : 
8f6e			;        this block will become the requested space by the malloc call and    : 
8f6e			;        is returned to the caller. The second portion becomes a new free     : 
8f6e			;        block, and the free list is adjusted to maintain continuity via this : 
8f6e			;        newly created block.                                                 : 
8f6e			;                                                                             : 
8f6e			;     malloc does not set any initial value in the allocated space, the       : 
8f6e			;     caller is required to do this as required.                              : 
8f6e			;                                                                             : 
8f6e			;     This implementation of malloc uses the stack exclusively, and is        : 
8f6e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f6e			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f6e			;     to avoid the use of malloc inside ISRs in general.                      : 
8f6e			;                                                                             : 
8f6e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f6e			;                                                                             : 
8f6e			; Parameters                                                                  : 
8f6e			;     HL  Number of bytes wanted                                              : 
8f6e			;                                                                             : 
8f6e			; Returns                                                                     : 
8f6e			;     HL  Address of the first useable byte of the allocation                 : 
8f6e			;                                                                             : 
8f6e			; Flags                                                                       : 
8f6e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f6e			;                                                                             : 
8f6e			; Stack frame                                                                 : 
8f6e			;       |             |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     BC      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     DE      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     IX      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |  prev_free  |                                                       : 
8f6e			;   +4  +-------------+                                                       : 
8f6e			;       |  this_free  |                                                       : 
8f6e			;   +2  +-------------+                                                       : 
8f6e			;       |  next_free  |                                                       : 
8f6e			;   +0  +-------------+                                                       : 
8f6e			;       |             |                                                       : 
8f6e			;                                                                             : 
8f6e			;------------------------------------------------------------------------------ 
8f6e			 
8f6e			 
8f6e			;malloc: 
8f6e			; 
8f6e			;	SAVESP ON 1 
8f6e			; 
8f6e			;	call malloc_code 
8f6e			; 
8f6e			;	CHECKSP ON 1 
8f6e			;	ret 
8f6e			 
8f6e			 
8f6e			malloc: 
8f6e c5			      push  BC 
8f6f d5			      push  DE 
8f70 dd e5		      push  IX 
8f72			if DEBUG_FORTH_MALLOC_HIGH 
8f72			call malloc_guard_entry 
8f72			endif 
8f72			 
8f72					if DEBUG_FORTH_MALLOC 
8f72						DMARK "mal" 
8f72						CALLMONITOR 
8f72					endif 
8f72 7c			      ld    A, H                    ; Exit if no space requested 
8f73 b5			      or    L 
8f74 ca 33 90		      jp    Z, malloc_early_exit 
8f77			 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			; 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			 
8f77			 
8f77			 
8f77			 
8f77					if DEBUG_FORTH_MALLOC 
8f77						DMARK "maA" 
8f77						CALLMONITOR 
8f77					endif 
8f77			      ; Set up stack frame 
8f77 eb			      ex    DE, HL 
8f78 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f7b 39			      add   HL, SP 
8f7c f9			      ld    SP, HL 
8f7d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f81 dd 39		      add   IX, SP 
8f83			 
8f83			      ; Setup initial state 
8f83 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f86 19			      add   HL, DE 
8f87			 
8f87 44			      ld    B, H                    ; Move want to BC 
8f88 4d			      ld    C, L 
8f89			 
8f89 21 7e d8		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f8c dd 75 04		      ld    (IX+4), L 
8f8f dd 74 05		      ld    (IX+5), H 
8f92			 
8f92 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f93 23			      inc   HL 
8f94 56			      ld    D, (HL) 
8f95 dd 73 02		      ld    (IX+2), E 
8f98 dd 72 03		      ld    (IX+3), D 
8f9b eb			      ex    DE, HL                  ; this_free ptr into HL 
8f9c			 
8f9c					if DEBUG_FORTH_MALLOC 
8f9c						DMARK "maB" 
8f9c						CALLMONITOR 
8f9c					endif 
8f9c			      ; Loop through free block list to find some space 
8f9c			malloc_find_space: 
8f9c 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f9d 23			      inc   HL 
8f9e 56			      ld    D, (HL) 
8f9f			 
8f9f 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fa0 b3			      or    E 
8fa1 ca 2d 90		      jp    Z, malloc_no_space 
8fa4			 
8fa4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fa7 dd 72 01		      ld    (IX+1), D 
8faa			 
8faa			      ; Does this block have enough space to make the allocation? 
8faa 23			      inc   HL                      ; Load free block size into DE 
8fab 5e			      ld    E, (HL) 
8fac 23			      inc   HL 
8fad 56			      ld    D, (HL) 
8fae			 
8fae eb			      ex    DE, HL                  ; Check size of block against want 
8faf b7			      or    A                       ; Ensure carry flag clear 
8fb0 ed 42		      sbc   HL, BC 
8fb2 e5			      push  HL                      ; Store the result for later (new block size) 
8fb3			 
8fb3 ca 02 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fb6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fb8			 
8fb8			      ; this_free block is not big enough, setup ptrs to test next free block 
8fb8 e1			      pop   HL                      ; Discard previous result 
8fb9			 
8fb9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fbc dd 66 03		      ld    H, (IX+3) 
8fbf dd 75 04		      ld    (IX+4), L 
8fc2 dd 74 05		      ld    (IX+5), H 
8fc5			 
8fc5 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fc8 dd 66 01		      ld    H, (IX+1) 
8fcb dd 75 02		      ld    (IX+2), L 
8fce dd 74 03		      ld    (IX+3), H 
8fd1			 
8fd1					if DEBUG_FORTH_MALLOC 
8fd1						DMARK "MA>" 
8fd1						CALLMONITOR 
8fd1					endif 
8fd1 18 c9		      jr    malloc_find_space 
8fd3			 
8fd3			      ; split a bigger block into two - requested size and remaining size 
8fd3			malloc_alloc_split: 
8fd3					if DEBUG_FORTH_MALLOC 
8fd3						DMARK "MAs" 
8fd3						CALLMONITOR 
8fd3					endif 
8fd3 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fd4 2b			      dec   HL 
8fd5 2b			      dec   HL 
8fd6 2b			      dec   HL 
8fd7 09			      add   HL, BC 
8fd8			 
8fd8			      ; Create a new block and point it at next_free 
8fd8 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fdb dd 56 01		      ld    D, (IX+1) 
8fde			 
8fde 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8fdf 23			      inc   HL 
8fe0 72			      ld    (HL), D 
8fe1			 
8fe1 d1			      pop   DE                      ; Store size of new block into new block 
8fe2 23			      inc   HL 
8fe3 73			      ld    (HL), E 
8fe4 23			      inc   HL 
8fe5 72			      ld    (HL), D 
8fe6			 
8fe6			      ; Update this_free ptr to point to new block 
8fe6 2b			      dec   HL 
8fe7 2b			      dec   HL 
8fe8 2b			      dec   HL 
8fe9			 
8fe9 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fec dd 56 03		      ld    D, (IX+3) 
8fef			 
8fef dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8ff2 dd 74 03		      ld    (IX+3), H 
8ff5			 
8ff5			      ; Modify this_free block to be allocation 
8ff5 eb			      ex    DE, HL 
8ff6 af			      xor   A                       ; Null the next block ptr of allocated block 
8ff7 77			      ld    (HL), A 
8ff8 23			      inc   HL 
8ff9 77			      ld    (HL), A 
8ffa			 
8ffa 23			      inc   HL                      ; Store want size into allocated block 
8ffb 71			      ld    (HL), C 
8ffc 23			      inc   HL 
8ffd 70			      ld    (HL), B 
8ffe 23			      inc   HL 
8fff e5			      push  HL                      ; Address of allocation to return 
9000			 
9000 18 19		      jr    malloc_update_links 
9002			 
9002			malloc_alloc_fit: 
9002 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9003			 
9003					if DEBUG_FORTH_MALLOC 
9003						DMARK "MAf" 
9003						CALLMONITOR 
9003					endif 
9003			      ; Modify this_free block to be allocation 
9003 eb			      ex    DE, HL 
9004 2b			      dec   HL 
9005 2b			      dec   HL 
9006 2b			      dec   HL 
9007			 
9007 af			      xor   A                       ; Null the next block ptr of allocated block 
9008 77			      ld    (HL), A 
9009 23			      inc   HL 
900a 77			      ld    (HL), A 
900b			 
900b 23			      inc   HL                      ; Store address of allocation to return 
900c 23			      inc   HL 
900d 23			      inc   HL 
900e e5			      push  HL 
900f			 
900f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
900f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9012 dd 66 01		      ld    H, (IX+1) 
9015			 
9015 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9018 dd 74 03		      ld    (IX+3), H 
901b			 
901b			 
901b			malloc_update_links: 
901b			      ; Update prev_free ptr to point to this_free 
901b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
901e dd 66 05		      ld    H, (IX+5) 
9021			 
9021 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9024 dd 56 03		      ld    D, (IX+3) 
9027			 
9027 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9028 23			      inc   HL 
9029 72			      ld    (HL), D 
902a			 
902a					if DEBUG_FORTH_MALLOC 
902a						DMARK "Mul" 
902a						CALLMONITOR 
902a					endif 
902a			      ; Clear the Z flag to indicate successful allocation 
902a 7a			      ld    A, D 
902b b3			      or    E 
902c			 
902c d1			      pop   DE                      ; Address of allocation 
902d					if DEBUG_FORTH_MALLOC 
902d						DMARK "MAu" 
902d						CALLMONITOR 
902d					endif 
902d			 
902d			malloc_no_space: 
902d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9030 39			      add   HL, SP 
9031 f9			      ld    SP, HL 
9032			 
9032 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9033					if DEBUG_FORTH_MALLOC 
9033						DMARK "MAN" 
9033						CALLMONITOR 
9033					endif 
9033			 
9033			malloc_early_exit: 
9033					if DEBUG_FORTH_MALLOC 
9033						DMARK "MAx" 
9033						CALLMONITOR 
9033					endif 
9033 dd e1		      pop   IX 
9035 d1			      pop   DE 
9036 c1			      pop   BC 
9037			 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037 c9			      ret 
9038			 
9038			 
9038			;------------------------------------------------------------------------------ 
9038			;     free                                                                    : 
9038			;                                                                             : 
9038			; Description                                                                 : 
9038			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9038			;     returned by malloc, otherwise the behaviour is undefined.               : 
9038			;                                                                             : 
9038			;     Where possible, directly adjacent free blocks will be merged together   : 
9038			;     into larger blocks to help ensure that the heap does not become         : 
9038			;     excessively fragmented.                                                 : 
9038			;                                                                             : 
9038			;     free does not clear or set any other value into the freed space, and    : 
9038			;     therefore its contents may be visible through subsequent malloc's. The  : 
9038			;     caller should clear the freed space as required.                        : 
9038			;                                                                             : 
9038			;     This implementation of free uses the stack exclusively, and is          : 
9038			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9038			;     advisable to disable interrupts before calling free, and recommended    : 
9038			;     to avoid the use of free inside ISRs in general.                        : 
9038			;                                                                             : 
9038			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9038			;                                                                             : 
9038			; Parameters                                                                  : 
9038			;     HL  Pointer to address of first byte of allocation to be freed          : 
9038			;                                                                             : 
9038			; Returns                                                                     : 
9038			;     Nothing                                                                 : 
9038			;                                                                             : 
9038			; Stack frame                                                                 : 
9038			;       |             |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     BC      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     DE      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     IX      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |  prev_free  |                                                       : 
9038			;   +2  +-------------+                                                       : 
9038			;       |  next_free  |                                                       : 
9038			;   +0  +-------------+                                                       : 
9038			;       |             |                                                       : 
9038			;                                                                             : 
9038			;------------------------------------------------------------------------------ 
9038			free: 
9038 c5			      push  BC 
9039 d5			      push  DE 
903a dd e5		      push  IX 
903c			 
903c 7c			      ld    A, H                    ; Exit if ptr is null 
903d b5			      or    L 
903e ca 02 91		      jp    Z, free_early_exit 
9041			 
9041			      ; Set up stack frame 
9041 eb			      ex    DE, HL 
9042 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9045 39			      add   HL, SP 
9046 f9			      ld    SP, HL 
9047 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
904b dd 39		      add   IX, SP 
904d			 
904d			      ; The address in HL points to the start of the useable allocated space, 
904d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
904d			      ; address of the block itself. 
904d eb			      ex    DE, HL 
904e 11 fc ff		      ld    DE, -4 
9051 19			      add   HL, DE 
9052			 
9052			      ; An allocated block must have a null next block pointer in it 
9052 7e			      ld    A, (HL) 
9053 23			      inc   HL 
9054 b6			      or    (HL) 
9055 c2 fd 90		      jp    NZ, free_done 
9058			 
9058 2b			      dec   HL 
9059			 
9059 44			      ld    B, H                    ; Copy HL to BC 
905a 4d			      ld    C, L 
905b			 
905b			      ; Loop through the free list to find the first block with an address 
905b			      ; higher than the block being freed 
905b 21 7e d8		      ld    HL, free_list 
905e			 
905e			free_find_higher_block: 
905e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
905f 23			      inc   HL 
9060 56			      ld    D, (HL) 
9061 2b			      dec   HL 
9062			 
9062 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9065 dd 72 01		      ld    (IX+1), D 
9068 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
906b dd 74 03		      ld    (IX+3), H 
906e			 
906e 78			      ld    A, B                    ; Check if DE is greater than BC 
906f ba			      cp    D                       ; Compare MSB first 
9070 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9072 30 04		      jr    NC, free_find_higher_block_skip 
9074 79			      ld    A, C 
9075 bb			      cp    E                       ; Then compare LSB 
9076 38 08		      jr    C, free_found_higher_block 
9078			 
9078			free_find_higher_block_skip: 
9078 7a			      ld    A, D                    ; Reached the end of the free list? 
9079 b3			      or    E 
907a ca fd 90		      jp    Z, free_done 
907d			 
907d eb			      ex    DE, HL 
907e			 
907e 18 de		      jr    free_find_higher_block 
9080			 
9080			free_found_higher_block: 
9080			      ; Insert freed block between prev and next free blocks 
9080 71			      ld    (HL), C                 ; Point prev free block to freed block 
9081 23			      inc   HL 
9082 70			      ld    (HL), B 
9083			 
9083 60			      ld    H, B                    ; Point freed block at next free block 
9084 69			      ld    L, C 
9085 73			      ld    (HL), E 
9086 23			      inc   HL 
9087 72			      ld    (HL), D 
9088			 
9088			      ; Check if the freed block is adjacent to the next free block 
9088 23			      inc   HL                      ; Load size of freed block into HL 
9089 5e			      ld    E, (HL) 
908a 23			      inc   HL 
908b 56			      ld    D, (HL) 
908c eb			      ex    DE, HL 
908d			 
908d 09			      add   HL, BC                  ; Add addr of freed block and its size 
908e			 
908e dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9091 dd 56 01		      ld    D, (IX+1) 
9094			 
9094 b7			      or    A                       ; Clear the carry flag 
9095 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9097 20 22		      jr    NZ, free_check_adjacent_to_prev 
9099			 
9099			      ; Freed block is adjacent to next, merge into one bigger block 
9099 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
909a 5e			      ld    E, (HL) 
909b 23			      inc   HL 
909c 56			      ld    D, (HL) 
909d e5			      push  HL                      ; Save ptr to next block for later 
909e			 
909e 60			      ld    H, B                    ; Store ptr from next block into freed block 
909f 69			      ld    L, C 
90a0 73			      ld    (HL), E 
90a1 23			      inc   HL 
90a2 72			      ld    (HL), D 
90a3			 
90a3 e1			      pop   HL                      ; Restore ptr to next block 
90a4 23			      inc   HL                      ; Load size of next block into DE 
90a5 5e			      ld    E, (HL) 
90a6 23			      inc   HL 
90a7 56			      ld    D, (HL) 
90a8 d5			      push  DE                      ; Save next block size for later 
90a9			 
90a9 60			      ld    H, B                    ; Load size of freed block into HL 
90aa 69			      ld    L, C 
90ab 23			      inc   HL 
90ac 23			      inc   HL 
90ad 5e			      ld    E, (HL) 
90ae 23			      inc   HL 
90af 56			      ld    D, (HL) 
90b0 eb			      ex    DE, HL 
90b1			 
90b1 d1			      pop   DE                      ; Restore size of next block 
90b2 19			      add   HL, DE                  ; Add sizes of both blocks 
90b3 eb			      ex    DE, HL 
90b4			 
90b4 60			      ld    H, B                    ; Store new bigger size into freed block 
90b5 69			      ld    L, C 
90b6 23			      inc   HL 
90b7 23			      inc   HL 
90b8 73			      ld    (HL), E 
90b9 23			      inc   HL 
90ba 72			      ld    (HL), D 
90bb			 
90bb			free_check_adjacent_to_prev: 
90bb			      ; Check if the freed block is adjacent to the prev free block 
90bb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90be dd 66 03		      ld    H, (IX+3) 
90c1			 
90c1 23			      inc   HL                      ; Size of prev free block into DE 
90c2 23			      inc   HL 
90c3 5e			      ld    E, (HL) 
90c4 23			      inc   HL 
90c5 56			      ld    D, (HL) 
90c6 2b			      dec   HL 
90c7 2b			      dec   HL 
90c8 2b			      dec   HL 
90c9			 
90c9 19			      add   HL, DE                  ; Add prev block addr and size 
90ca			 
90ca b7			      or    A                       ; Clear the carry flag 
90cb ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90cd 20 2e		      jr    NZ, free_done 
90cf			 
90cf			      ; Freed block is adjacent to prev, merge into one bigger block 
90cf 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90d0 69			      ld    L, C 
90d1 5e			      ld    E, (HL) 
90d2 23			      inc   HL 
90d3 56			      ld    D, (HL) 
90d4 e5			      push  HL                      ; Save freed block ptr for later 
90d5			 
90d5 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90d8 dd 66 03		      ld    H, (IX+3) 
90db 73			      ld    (HL), E 
90dc 23			      inc   HL 
90dd 72			      ld    (HL), D 
90de			 
90de e1			      pop   HL                      ; Restore freed block ptr 
90df 23			      inc   HL                      ; Load size of freed block into DE 
90e0 5e			      ld    E, (HL) 
90e1 23			      inc   HL 
90e2 56			      ld    D, (HL) 
90e3 d5			      push  DE                      ; Save freed block size for later 
90e4			 
90e4 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90e7 dd 66 03		      ld    H, (IX+3) 
90ea 23			      inc   HL 
90eb 23			      inc   HL 
90ec 5e			      ld    E, (HL) 
90ed 23			      inc   HL 
90ee 56			      ld    D, (HL) 
90ef			 
90ef e1			      pop   HL                      ; Add sizes of both blocks 
90f0 19			      add   HL, DE 
90f1 eb			      ex    DE, HL 
90f2			 
90f2 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90f5 dd 66 03		      ld    H, (IX+3) 
90f8 23			      inc   HL 
90f9 23			      inc   HL 
90fa 73			      ld    (HL), E 
90fb 23			      inc   HL 
90fc 72			      ld    (HL), D 
90fd			 
90fd			free_done: 
90fd 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9100 39			      add   HL, SP 
9101 f9			      ld    SP, HL 
9102			 
9102			free_early_exit: 
9102 dd e1		      pop   IX 
9104 d1			      pop   DE 
9105 c1			      pop   BC 
9106			 
9106 c9			      ret 
9107			 
9107			; moved to firmware.asm 
9107			; 
9107			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9107			;                  .dw   0 
9107			 
9107			 
9107			endif 
9107			 
9107			 
9107			if MALLOC_3 
9107			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9107			;heap_start        .equ  0x9000      ; Starting address of heap 
9107			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9107			; 
9107			 ;     .org 0 
9107			  ;    jp    main 
9107			; 
9107			; 
9107			 ;     .org  0x100 
9107			;main: 
9107			 ;     ld    HL, 0x8100 
9107			  ;    ld    SP, HL 
9107			; 
9107			;      call  heap_init 
9107			 
9107			      ; Make some allocations 
9107			;      ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9004 
9107			; 
9107			 ;     ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9014 
9107			 
9107			;      ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9024 
9107			 
9107			      ; Free some allocations 
9107			;      ld    HL, 0x9014 
9107			;      call  free 
9107			 
9107			;      ld    HL, 0x9004 
9107			;      call  free 
9107			; 
9107			;      ld    HL, 0x9024 
9107			;      call  free 
9107			 
9107			 
9107			 ;     halt 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     heap_init                                                               : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Initialise the heap and make it ready for malloc and free operations.   : 
9107			;                                                                             : 
9107			;     The heap is maintained as a linked list, starting with an initial       : 
9107			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9107			;     the first free block in the heap. Each block then points to the next    : 
9107			;     free block within the heap, and the free list ends at the first block   : 
9107			;     with a null pointer to the next free block.                             : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     Inputs are compile-time only. Two defines which specify the starting    : 
9107			;     address of the heap and its size are required, along with a memory      : 
9107			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9107			;     principally stores a pointer to the first free block in the heap.       : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     Nothing                                                                 : 
9107			;------------------------------------------------------------------------------ 
9107			heap_init: 
9107			      push  HL 
9107			 
9107			      ; Initialise free list struct 
9107			      ld    HL, heap_start 
9107			      ld    (free_list), HL 
9107			      ld    HL, 0 
9107			      ld    (free_list+2), HL 
9107			 
9107			      ; Insert first free block at bottom of heap, consumes entire heap 
9107			      ld    HL, heap_start+heap_size-4 
9107			      ld    (heap_start), HL        ; Next block (end of free list) 
9107			      ld    HL, heap_size-4 
9107			      ld    (heap_start+2), HL      ; Block size 
9107			 
9107			      ; Insert end of free list block at top of heap - two null words will 
9107			      ; terminate the free list 
9107			      ld    HL, 0 
9107			      ld    (heap_start+heap_size-2), HL 
9107			      ld    (heap_start+heap_size-4), HL 
9107			 
9107			      pop   HL 
9107			 
9107			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     malloc                                                                  : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Allocates the wanted space from the heap and returns the address of the : 
9107			;     first useable byte of the allocation.                                   : 
9107			;                                                                             : 
9107			;     Allocations can happen in one of two ways:                              : 
9107			;                                                                             : 
9107			;     1. A free block may be found which is the exact size wanted. In this    : 
9107			;        case the block is removed from the free list and retuedn to the      : 
9107			;        caller.                                                              : 
9107			;     2. A free block may be found which is larger than the size wanted. In   : 
9107			;        this case, the larger block is split into two. The first portion of  : 
9107			;        this block will become the requested space by the malloc call and    : 
9107			;        is returned to the caller. The second portion becomes a new free     : 
9107			;        block, and the free list is adjusted to maintain continuity via this : 
9107			;        newly created block.                                                 : 
9107			;                                                                             : 
9107			;     malloc does not set any initial value in the allocated space, the       : 
9107			;     caller is required to do this as required.                              : 
9107			;                                                                             : 
9107			;     This implementation of malloc uses the stack exclusively, and is        : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling malloc, and recommended  : 
9107			;     to avoid the use of malloc inside ISRs in general.                      : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Number of bytes wanted                                              : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     HL  Address of the first useable byte of the allocation                 : 
9107			;                                                                             : 
9107			; Flags                                                                       : 
9107			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +4  +-------------+                                                       : 
9107			;       |  this_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			malloc: 
9107			      push  BC 
9107			      push  DE 
9107			      push  IX 
9107			 
9107			      ld    A, H                    ; Exit if no space requested 
9107			      or    L 
9107			      jp    Z, malloc_early_exit 
9107			 
9107			      ; Set up stack frame 
9107			      ex    DE, HL 
9107			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			      ld    IX, 0                   ; Use IX as a frame pointer 
9107			      add   IX, SP 
9107			 
9107			      ; Setup initial state 
9107			      ld    HL, 4                   ; want must also include space used by block struct 
9107			      add   HL, DE 
9107			 
9107			      ld    B, H                    ; Move want to BC 
9107			      ld    C, L 
9107			 
9107			      ld    HL, free_list           ; Store prev_free ptr to stack 
9107			      ld    (IX+4), L 
9107			      ld    (IX+5), H 
9107			 
9107			      ld    E, (HL)                 ; Store this_free ptr to stack 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ld    (IX+2), E 
9107			      ld    (IX+3), D 
9107			      ex    DE, HL                  ; this_free ptr into HL 
9107			 
9107			      ; Loop through free block list to find some space 
9107			malloc_find_space: 
9107			      ld    E, (HL)                 ; Load next_free ptr into DE 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9107			      or    E 
9107			      jp    Z, malloc_no_space 
9107			 
9107			      ld    (IX+0), E               ; Store next_free ptr to stack 
9107			      ld    (IX+1), D 
9107			 
9107			      ; Does this block have enough space to make the allocation? 
9107			      inc   HL                      ; Load free block size into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      ex    DE, HL                  ; Check size of block against want 
9107			      or    A                       ; Ensure carry flag clear 
9107			      sbc   HL, BC 
9107			      push  HL                      ; Store the result for later (new block size) 
9107			 
9107			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9107			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9107			 
9107			      ; this_free block is not big enough, setup ptrs to test next free block 
9107			      pop   HL                      ; Discard previous result 
9107			 
9107			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9107			      ld    H, (IX+3) 
9107			      ld    (IX+4), L 
9107			      ld    (IX+5), H 
9107			 
9107			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9107			      ld    H, (IX+1) 
9107			      ld    (IX+2), L 
9107			      ld    (IX+3), H 
9107			 
9107			      jr    malloc_find_space 
9107			 
9107			      ; split a bigger block into two - requested size and remaining size 
9107			malloc_alloc_split: 
9107			      ex    DE, HL                  ; Calculate address of new free block 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			      add   HL, BC 
9107			 
9107			      ; Create a new block and point it at next_free 
9107			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9107			      ld    D, (IX+1) 
9107			 
9107			      ld    (HL), E                 ; Store next_free ptr into new block 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   DE                      ; Store size of new block into new block 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Update this_free ptr to point to new block 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9107			      ld    D, (IX+3) 
9107			 
9107			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9107			      ld    (IX+3), H 
9107			 
9107			      ; Modify this_free block to be allocation 
9107			      ex    DE, HL 
9107			      xor   A                       ; Null the next block ptr of allocated block 
9107			      ld    (HL), A 
9107			      inc   HL 
9107			      ld    (HL), A 
9107			 
9107			      inc   HL                      ; Store want size into allocated block 
9107			      ld    (HL), C 
9107			      inc   HL 
9107			      ld    (HL), B 
9107			      inc   HL 
9107			      push  HL                      ; Address of allocation to return 
9107			 
9107			      jr    malloc_update_links 
9107			 
9107			malloc_alloc_fit: 
9107			      pop   HL                      ; Dont need new block size, want is exact fit 
9107			 
9107			      ; Modify this_free block to be allocation 
9107			      ex    DE, HL 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      xor   A                       ; Null the next block ptr of allocated block 
9107			      ld    (HL), A 
9107			      inc   HL 
9107			      ld    (HL), A 
9107			 
9107			      inc   HL                      ; Store address of allocation to return 
9107			      inc   HL 
9107			      inc   HL 
9107			      push  HL 
9107			 
9107			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9107			      ld    L, (IX+0)               ; next_free to HL 
9107			      ld    H, (IX+1) 
9107			 
9107			      ld    (IX+2), L               ; HL to this_free 
9107			      ld    (IX+3), H 
9107			 
9107			 
9107			malloc_update_links: 
9107			      ; Update prev_free ptr to point to this_free 
9107			      ld    L, (IX+4)               ; prev_free ptr to HL 
9107			      ld    H, (IX+5) 
9107			 
9107			      ld    E, (IX+2)               ; this_free ptr to DE 
9107			      ld    D, (IX+3) 
9107			 
9107			      ld    (HL), E                 ; this_free ptr into prev_free 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Clear the Z flag to indicate successful allocation 
9107			      ld    A, D 
9107			      or    E 
9107			 
9107			      pop   DE                      ; Address of allocation 
9107			 
9107			malloc_no_space: 
9107			      ld    HL, 6                   ; Clean up stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			 
9107			      ex    DE, HL                  ; Alloc addr into HL for return 
9107			 
9107			malloc_early_exit: 
9107			      pop   IX 
9107			      pop   DE 
9107			      pop   BC 
9107			 
9107			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     free                                                                    : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9107			;     returned by malloc, otherwise the behaviour is undefined.               : 
9107			;                                                                             : 
9107			;     Where possible, directly adjacent free blocks will be merged together   : 
9107			;     into larger blocks to help ensure that the heap does not become         : 
9107			;     excessively fragmented.                                                 : 
9107			;                                                                             : 
9107			;     free does not clear or set any other value into the freed space, and    : 
9107			;     therefore its contents may be visible through subsequent malloc's. The  : 
9107			;     caller should clear the freed space as required.                        : 
9107			;                                                                             : 
9107			;     This implementation of free uses the stack exclusively, and is          : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling free, and recommended    : 
9107			;     to avoid the use of free inside ISRs in general.                        : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Pointer to address of first byte of allocation to be freed          : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     Nothing                                                                 : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			free: 
9107			      push  BC 
9107			      push  DE 
9107			      push  IX 
9107			 
9107			      ld    A, H                    ; Exit if ptr is null 
9107			      or    L 
9107			      jp    Z, free_early_exit 
9107			 
9107			      ; Set up stack frame 
9107			      ex    DE, HL 
9107			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			      ld    IX, 0                   ; Use IX as a frame pointer 
9107			      add   IX, SP 
9107			 
9107			      ; The address in HL points to the start of the useable allocated space, 
9107			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9107			      ; address of the block itself. 
9107			      ex    DE, HL 
9107			      ld    DE, -4 
9107			      add   HL, DE 
9107			 
9107			      ; An allocated block must have a null next block pointer in it 
9107			      ld    A, (HL) 
9107			      inc   HL 
9107			      or    (HL) 
9107			      jp    NZ, free_done 
9107			 
9107			      dec   HL 
9107			 
9107			      ld    B, H                    ; Copy HL to BC 
9107			      ld    C, L 
9107			 
9107			      ; Loop through the free list to find the first block with an address 
9107			      ; higher than the block being freed 
9107			      ld    HL, free_list 
9107			 
9107			free_find_higher_block: 
9107			      ld    E, (HL)                 ; Load next ptr from free block 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      dec   HL 
9107			 
9107			      ld    (IX+0), E               ; Save ptr to next free block 
9107			      ld    (IX+1), D 
9107			      ld    (IX+2), L               ; Save ptr to prev free block 
9107			      ld    (IX+3), H 
9107			 
9107			      ld    A, B                    ; Check if DE is greater than BC 
9107			      cp    D                       ; Compare MSB first 
9107			      jr    Z, $+4                  ; MSB the same, compare LSB 
9107			      jr    NC, free_find_higher_block_skip 
9107			      ld    A, C 
9107			      cp    E                       ; Then compare LSB 
9107			      jr    C, free_found_higher_block 
9107			 
9107			free_find_higher_block_skip: 
9107			      ld    A, D                    ; Reached the end of the free list? 
9107			      or    E 
9107			      jp    Z, free_done 
9107			 
9107			      ex    DE, HL 
9107			 
9107			      jr    free_find_higher_block 
9107			 
9107			free_found_higher_block: 
9107			      ; Insert freed block between prev and next free blocks 
9107			      ld    (HL), C                 ; Point prev free block to freed block 
9107			      inc   HL 
9107			      ld    (HL), B 
9107			 
9107			      ld    H, B                    ; Point freed block at next free block 
9107			      ld    L, C 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Check if the freed block is adjacent to the next free block 
9107			      inc   HL                      ; Load size of freed block into HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ex    DE, HL 
9107			 
9107			      add   HL, BC                  ; Add addr of freed block and its size 
9107			 
9107			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9107			      ld    D, (IX+1) 
9107			 
9107			      or    A                       ; Clear the carry flag 
9107			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9107			      jr    NZ, free_check_adjacent_to_prev 
9107			 
9107			      ; Freed block is adjacent to next, merge into one bigger block 
9107			      ex    DE, HL                  ; Load next ptr from next block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  HL                      ; Save ptr to next block for later 
9107			 
9107			      ld    H, B                    ; Store ptr from next block into freed block 
9107			      ld    L, C 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   HL                      ; Restore ptr to next block 
9107			      inc   HL                      ; Load size of next block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  DE                      ; Save next block size for later 
9107			 
9107			      ld    H, B                    ; Load size of freed block into HL 
9107			      ld    L, C 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ex    DE, HL 
9107			 
9107			      pop   DE                      ; Restore size of next block 
9107			      add   HL, DE                  ; Add sizes of both blocks 
9107			      ex    DE, HL 
9107			 
9107			      ld    H, B                    ; Store new bigger size into freed block 
9107			      ld    L, C 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			free_check_adjacent_to_prev: 
9107			      ; Check if the freed block is adjacent to the prev free block 
9107			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9107			      ld    H, (IX+3) 
9107			 
9107			      inc   HL                      ; Size of prev free block into DE 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      add   HL, DE                  ; Add prev block addr and size 
9107			 
9107			      or    A                       ; Clear the carry flag 
9107			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9107			      jr    NZ, free_done 
9107			 
9107			      ; Freed block is adjacent to prev, merge into one bigger block 
9107			      ld    H, B                    ; Load next ptr from freed block into DE 
9107			      ld    L, C 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  HL                      ; Save freed block ptr for later 
9107			 
9107			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9107			      ld    H, (IX+3) 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   HL                      ; Restore freed block ptr 
9107			      inc   HL                      ; Load size of freed block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  DE                      ; Save freed block size for later 
9107			 
9107			      ld    L, (IX+2)               ; Load size of prev block into DE 
9107			      ld    H, (IX+3) 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      pop   HL                      ; Add sizes of both blocks 
9107			      add   HL, DE 
9107			      ex    DE, HL 
9107			 
9107			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9107			      ld    H, (IX+3) 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			free_done: 
9107			      ld    HL, 4                   ; Clean up stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			 
9107			free_early_exit: 
9107			      pop   IX 
9107			      pop   DE 
9107			      pop   BC 
9107			 
9107			      ret 
9107			 
9107			 
9107			;      .org 0x8000 
9107			; 
9107			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9107			 ;                 .dw   0 
9107			 
9107			endif 
9107			 
9107			 
9107			if MALLOC_4 
9107			 
9107			; My memory allocation code. Very very simple.... 
9107			; allocate space under 250 chars 
9107			 
9107			heap_init: 
9107				; init start of heap as zero 
9107				;  
9107			 
9107				ld hl, heap_start 
9107				ld a, 0 
9107				ld (hl), a      ; empty block 
9107				inc hl 
9107				ld a, 0 
9107				ld (hl), a      ; length of block 
9107				; write end of list 
9107				inc hl 
9107				ld a,(hl) 
9107				inc hl 
9107				ld a,(hl) 
9107				 
9107			 
9107				; init some malloc vars 
9107			 
9107				ld hl, 0 
9107				ld (free_list), hl       ; store last malloc location 
9107			 
9107				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9107				ld a, 0 
9107				ld (hl), a 
9107			 
9107			 
9107				ld hl, heap_start 
9107				;  
9107				  
9107				ret 
9107			 
9107			 
9107			;    free block marker 
9107			;    requested size  
9107			;    pointer to next block 
9107			;    .... 
9107			;    next block marker 
9107			 
9107			 
9107			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9107			; 
9107			 
9107			 
9107			malloc:  
9107				push de 
9107				push bc 
9107				push af 
9107			 
9107				; hl space required 
9107				 
9107				ld c, l    ; hold space   (TODO only a max of 255) 
9107			 
9107			;	inc c     ; TODO BUG need to fix memory leak on push str 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			 
9107			 
9107			 
9107				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9107			 
9107				ld a, (free_list+3) 
9107				cp 0 
9107				jr z, .contheap 
9107			 
9107				ld hl, (free_list)     ; get last alloc 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mrs" 
9107						CALLMONITOR 
9107					endif 
9107				jr .startalloc 
9107			 
9107			.contheap: 
9107				ld hl, heap_start 
9107			 
9107			.startalloc: 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mym" 
9107						CALLMONITOR 
9107					endif 
9107			.findblock: 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mmf" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107				ld a,(hl)  
9107				; if byte is zero then clear to use 
9107			 
9107				cp 0 
9107				jr z, .foundemptyblock 
9107			 
9107				; if byte is not clear 
9107				;     then byte is offset to next block 
9107			 
9107				inc hl 
9107				ld a, (hl) ; get size 
9107			.nextblock:	inc hl 
9107					ld e, (hl) 
9107					inc hl 
9107					ld d, (hl) 
9107					ex de, hl 
9107			;	inc hl  ; move past the store space 
9107			;	inc hl  ; move past zero index  
9107			 
9107				; TODO detect no more space 
9107			 
9107				push hl 
9107				ld de, heap_end 
9107				call cmp16 
9107				pop hl 
9107				jr nc, .nospace 
9107			 
9107				jr .findblock 
9107			 
9107			.nospace: ld hl, 0 
9107				jp .exit 
9107			 
9107			 
9107			.foundemptyblock:	 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mme" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			; TODO has block enough space if reusing??? 
9107			 
9107				;  
9107			 
9107			; see if this block has been previously used 
9107				inc hl 
9107				ld a, (hl) 
9107				dec hl 
9107				cp 0 
9107				jr z, .newblock 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "meR" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			; no reusing previously allocated block 
9107			 
9107			; is it smaller than previously used? 
9107				 
9107				inc hl    ; move to size 
9107				ld a, c 
9107				sub (hl)        ; we want c < (hl) 
9107				dec hl    ; move back to marker 
9107			        jr z, .findblock 
9107			 
9107				; update with the new size which should be lower 
9107			 
9107			        ;inc  hl   ; negate next move. move back to size  
9107			 
9107			.newblock: 
9107				; need to be at marker here 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "meN" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			 
9107				ld a, c 
9107			 
9107				ld (free_list+3), a	 ; flag resume from last malloc  
9107				ld (free_list), hl    ; save out last location 
9107			 
9107			 
9107				;inc a     ; space for length byte 
9107				ld (hl), a     ; save block in use marker 
9107			 
9107				inc hl   ; move to space marker 
9107				ld (hl), a    ; save new space 
9107			 
9107				inc hl   ; move to start of allocated area 
9107				 
9107			;	push hl     ; save where we are - 1  
9107			 
9107			;	inc hl  ; move past zero index  
9107				; skip space to set down new marker 
9107			 
9107				; provide some extra space for now 
9107			 
9107				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9107				inc a 
9107				inc a 
9107			 
9107				push hl   ; save where we are in the node block 
9107			 
9107				call addatohl 
9107			 
9107				; write linked list point 
9107			 
9107				pop de     ; get our node position 
9107				ex de, hl 
9107			 
9107				ld (hl), e 
9107				inc hl 
9107				ld (hl), d 
9107			 
9107				inc hl 
9107			 
9107				; now at start of allocated data so save pointer 
9107			 
9107				push hl 
9107			 
9107				; jump to position of next node and setup empty header in DE 
9107			 
9107				ex de, hl 
9107			 
9107			;	inc hl ; move past end of block 
9107			 
9107				ld a, 0 
9107				ld (hl), a   ; empty marker 
9107				inc hl 
9107				ld (hl), a   ; size 
9107				inc hl  
9107				ld (hl), a   ; ptr 
9107				inc hl 
9107				ld (hl), a   ; ptr 
9107			 
9107			 
9107				pop hl 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mmr" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			.exit: 
9107				pop af 
9107				pop bc 
9107				pop de  
9107				ret 
9107			 
9107			 
9107			 
9107			 
9107			free:  
9107				push hl 
9107				push af 
9107				; get address in hl 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "fre" 
9107						CALLMONITOR 
9107					endif 
9107				; data is at hl - move to block count 
9107				dec hl 
9107				dec hl    ; get past pointer 
9107				dec hl 
9107			 
9107				ld a, (hl)    ; need this for a validation check 
9107			 
9107				dec hl    ; move to block marker 
9107			 
9107				; now check that the block count and block marker are the same  
9107			        ; this checks that we are on a malloc node and not random memory 
9107			        ; OK a faint chance this could be a problem but rare - famous last words! 
9107			 
9107				ld c, a 
9107				ld a, (hl)    
9107			 
9107				cp c 
9107				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9107			 
9107				; yes good chance we are on a malloc node 
9107			 
9107				ld a, 0      
9107				ld (hl), a   ; mark as free 
9107			 
9107				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9107			 
9107			.freeignore:  
9107			 
9107				pop af 
9107				pop hl 
9107			 
9107				ret 
9107			 
9107			 
9107			 
9107			endif 
9107			 
9107			; eof 
# End of file firmware_memory.asm
9107			  
9107			; device C  
9107			if SOUND_ENABLE  
9107				include "firmware_sound.asm"  
9107			endif  
9107			  
9107			include "firmware_diags.asm"  
9107			; Hardware diags menu 
9107			 
9107			 
9107			config: 
9107			 
9107 3e 00			ld a, 0 
9109 21 2d 91			ld hl, .configmn 
910c cd ab 88			call menu 
910f			 
910f fe 00			cp 0 
9111 c8				ret z 
9112			 
9112 fe 01			cp 1 
9114 cc b5 91			call z, .savetostore 
9117			 
9117 fe 02			cp 2 
9119 cc b3 91			call z, .selautoload 
911c fe 03			cp 3 
911e cc b4 91			call z, .selbank 
9121 fe 05			cp 5 
9123 cc b6 91			call z, .debug_tog 
9126 fe 06			cp 6 
9128 cc dc 91			call z, hardware_diags 
912b			 
912b 18 da			jr config 
912d			 
912d			.configmn: 
912d 3b 91			dw .c3 
912f 57 91			dw .c2 
9131 6c 91			dw .c2b 
9133 80 91			dw .c4 
9135 89 91			dw .m4 
9137 a4 91			dw .c1 
9139 00 00			dw 0 
913b				 
913b			 
913b .. 00		.c3: db "Add User Dictionary To File",0 
9157 .. 00		.c2: db "Select Autoload File",0 
916c .. 00		.c2b: db "Select Storage Bank",0 
9180 .. 00		.c4: db "Settings",0 
9189 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91a4 .. 00		.c1: db "Hardware Diags",0 
91b3			 
91b3			; Select auto start 
91b3			 
91b3			.selautoload: 
91b3			 
91b3				 
91b3				if STORAGE_SE 
91b3			 
91b3					call config_dir 
91b3				        ld hl, scratch 
91b3					ld a, 0 
91b3					call menu 
91b3			 
91b3					; locate menu option 
91b3			 
91b3					ld hl, scratch 
91b3					call table_lookup 
91b3			 
91b3					; with the pointer to the menu it, the byte following the zero term is the file id 
91b3			 
91b3					ld a, 0 
91b3					ld bc, 50   ; max of bytes to look at 
91b3					cpir  
91b3			 
91b3					inc hl 
91b3			 
91b3					ld a, (hl)   ; file id 
91b3					 
91b3				        ; save bank and file ids 
91b3			 
91b3					push af 
91b3			 
91b3			; TODO need to save to block 0 on bank 1	 
91b3			 
91b3					call storage_get_block_0 
91b3			 
91b3					pop af 
91b3			 
91b3					ld (store_page+STORE_0_FILERUN),a 
91b3					 
91b3					; save bank id 
91b3			 
91b3					ld a,(spi_device) 
91b3					ld (store_page+STORE_0_BANKRUN),a 
91b3			 
91b3					; enable auto run of store file 
91b3			 
91b3					ld a, 1 
91b3					ld (store_page+STORE_0_AUTOFILE),a 
91b3			 
91b3					; save buffer 
91b3			 
91b3					ld hl, 0 
91b3					ld de, store_page 
91b3				call storage_write_block	 ; save update 
91b3			  
91b3			 
91b3			 
91b3			 
91b3					ld hl, scratch 
91b3					call config_fdir 
91b3			 
91b3			 
91b3				endif 
91b3 c9				ret 
91b4			 
91b4			 
91b4			 
91b4			; Select storage bank 
91b4			 
91b4			.selbank: 
91b4			 
91b4				if STORAGE_SE 
91b4				endif 
91b4				 
91b4 c9				ret 
91b5			 
91b5			if STORAGE_SE 
91b5			 
91b5			.config_ldir:   
91b5				; Load storage bank labels into menu array 
91b5			 
91b5				 
91b5			 
91b5			 
91b5				ret 
91b5			 
91b5			 
91b5			endif 
91b5			 
91b5			 
91b5			; Save user words to storage 
91b5			 
91b5			.savetostore: 
91b5			 
91b5				if STORAGE_SE 
91b5			 
91b5					call config_dir 
91b5				        ld hl, scratch 
91b5					ld a, 0 
91b5					call menu 
91b5					 
91b5					ld hl, scratch 
91b5					call config_fdir 
91b5			 
91b5			 
91b5				endif 
91b5			 
91b5 c9				ret 
91b6			 
91b6			 
91b6			 
91b6			if STORAGE_SE 
91b6			 
91b6			config_fdir: 
91b6				; using the scratch dir go through and release the memory allocated for each string 
91b6				 
91b6				ld hl, scratch 
91b6			.cfdir:	ld e,(hl) 
91b6				inc hl 
91b6				ld d,(hl) 
91b6				inc hl 
91b6			 
91b6				ex de, hl 
91b6				call ishlzero 
91b6				ret z     ; return on null pointer 
91b6				call free 
91b6				ex de, hl 
91b6				jr .cfdir 
91b6			 
91b6			 
91b6				ret 
91b6			 
91b6			 
91b6			config_dir: 
91b6			 
91b6				; for the config menus that need to build a directory of storage call this routine 
91b6				; it will construct a menu in scratch to pass to menu 
91b6			 
91b6				; open storage device 
91b6			 
91b6				; execute DIR to build a list of files and their ids into scratch in menu format 
91b6				; once the menu has finished then will need to call config_fdir to release the strings 
91b6				 
91b6				; c = number items 
91b6			 
91b6				 
91b6				call storage_get_block_0 
91b6			 
91b6				ld hl, store_page     ; get current id count 
91b6				ld b, (hl) 
91b6				ld c, 0    ; count of files   
91b6			 
91b6			 
91b6				ld hl, scratch 
91b6				ld (store_tmp2), hl    ; location to poke strings 
91b6			 
91b6				; check for empty drive 
91b6			 
91b6				ld a, 0 
91b6				cp b 
91b6				jp z, .dirdone 
91b6			 
91b6				 
91b6					if DEBUG_FORTH_WORDS 
91b6						DMARK "Cdc" 
91b6						CALLMONITOR 
91b6					endif 
91b6			 
91b6			 
91b6			.diritem:	 
91b6				push bc 
91b6				; for each of the current ids do a search for them and if found push to stack 
91b6			 
91b6					ld hl, STORE_BLOCK_PHY 
91b6					ld d, 0		 ; look for extent 0 of block id as this contains file name 
91b6					ld e,b 
91b6			 
91b6					call storage_findnextid 
91b6			 
91b6			 
91b6					; if found hl will be non zero 
91b6			 
91b6					call ishlzero 
91b6					jr z, .dirnotfound 
91b6			 
91b6					; increase count 
91b6			 
91b6					pop bc	 
91b6					inc c 
91b6					push bc 
91b6					 
91b6			 
91b6					; get file header and push the file name 
91b6			 
91b6					ld de, store_page 
91b6					call storage_read_block 
91b6			 
91b6					; push file id to stack 
91b6				 
91b6					ld a, (store_page) 
91b6					ld h, 0 
91b6					ld l, a 
91b6			 
91b6					;call forth_push_numhl 
91b6					; TODO store id 
91b6			 
91b6					push hl 
91b6			 
91b6					; push extent count to stack  
91b6				 
91b6					ld hl, store_page+3 
91b6			 
91b6					; get file name length 
91b6			 
91b6					call strlenz   
91b6			 
91b6					inc hl   ; cover zero term 
91b6					inc hl  ; stick the id at the end of the area 
91b6			 
91b6					push hl 
91b6					pop bc    ; move length to bc 
91b6			 
91b6					call malloc 
91b6			 
91b6					; TODO save malloc area to scratch 
91b6			 
91b6					ex de, hl 
91b6					ld hl, (store_tmp2) 
91b6					ld (hl), e 
91b6					inc hl 
91b6					ld (hl), d 
91b6					inc hl 
91b6					ld (store_tmp2), hl 
91b6			 
91b6					 
91b6			 
91b6					;pop hl   ; get source 
91b6			;		ex de, hl    ; swap aronund	 
91b6			 
91b6					ld hl, store_page+3 
91b6					if DEBUG_FORTH_WORDS 
91b6						DMARK "CFd" 
91b6						CALLMONITOR 
91b6					endif 
91b6					ldir 
91b6			 
91b6					; de is past string, move back one and store id 
91b6					 
91b6					dec de 
91b6			 
91b6					; store file id 
91b6			 
91b6					pop hl 
91b6					ex de,hl 
91b6					ld (hl), e 
91b6			 
91b6					if DEBUG_FORTH_WORDS 
91b6						DMARK "Cdi" 
91b6						CALLMONITOR 
91b6					endif 
91b6					 
91b6			.dirnotfound: 
91b6					pop bc     
91b6					djnz .diritem 
91b6				 
91b6			.dirdone:	 
91b6			 
91b6					ld a, 0 
91b6					ld hl, (store_tmp2) 
91b6					ld (hl), a 
91b6					inc hl 
91b6					ld (hl), a 
91b6					inc hl 
91b6					; push a count of the dir items found 
91b6			 
91b6			;		ld h, 0 
91b6			;		ld l, c 
91b6			 
91b6				ret 
91b6			 
91b6			endif 
91b6			 
91b6			 
91b6			; Settings 
91b6			; Run  
91b6			 
91b6			 
91b6			 
91b6			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
91b6			;;hd_menu2:   db "        2: Editor",0   
91b6			;hd_menu2:   db "        2: Editor       6: Menu",0   
91b6			;hd_menu3:   db "        3: Storage",0 
91b6			;hd_menu4:   db "0=quit  4: Debug",0 
91b6			;hd_don:     db "ON",0 
91b6			;hd_doff:     db "OFF",0 
91b6			; 
91b6			; 
91b6			; 
91b6			;hardware_diags_old:       
91b6			; 
91b6			;.diagmenu: 
91b6			;	call clear_display 
91b6			;	ld a, display_row_1 
91b6			;	ld de, hd_menu1 
91b6			;	call str_at_display 
91b6			; 
91b6			;	ld a, display_row_2 
91b6			;	ld de, hd_menu2 
91b6			;	call str_at_display 
91b6			; 
91b6			;	ld a, display_row_3 
91b6			;	ld de, hd_menu3 
91b6			;	call str_at_display 
91b6			; 
91b6			;	ld a,  display_row_4 
91b6			;	ld de, hd_menu4 
91b6			;	call str_at_display 
91b6			; 
91b6			;	; display debug state 
91b6			; 
91b6			;	ld de, hd_don 
91b6			;	ld a, (os_view_disable) 
91b6			;	cp 0 
91b6			;	jr z, .distog 
91b6			;	ld de, hd_doff 
91b6			;.distog: ld a, display_row_4+17 
91b6			;	call str_at_display 
91b6			; 
91b6			;	call update_display 
91b6			; 
91b6			;	call cin_wait 
91b6			; 
91b6			; 
91b6			; 
91b6			;	cp '4' 
91b6			;	jr nz, .diagn1 
91b6			; 
91b6			;	; debug toggle 
91b6			; 
91b6			;	ld a, (os_view_disable) 
91b6			;	ld b, '*' 
91b6			;	cp 0 
91b6			;	jr z, .debtog 
91b6			;	ld b, 0 
91b6			;.debtog:	 
91b6			;	ld a,b 
91b6			;	ld (os_view_disable),a 
91b6			; 
91b6			;.diagn1: cp '0' 
91b6			;	 ret z 
91b6			; 
91b6			;;	cp '1' 
91b6			;;       jp z, matrix	 
91b6			;;   TODO keyboard matrix test 
91b6			; 
91b6			;	cp '2' 
91b6			;	jp z, .diagedit 
91b6			; 
91b6			;;	cp '6' 
91b6			;;	jp z, .menutest 
91b6			;;if ENABLE_BASIC 
91b6			;;	cp '6' 
91b6			;;	jp z, basic 
91b6			;;endif 
91b6			 ; 
91b6			;	jp .diagmenu 
91b6			; 
91b6			; 
91b6			;	ret 
91b6			 
91b6			 
91b6			.debug_tog: 
91b6 21 fd 91			ld hl, .menudebug 
91b9				 
91b9 3a d7 e4			ld a, (os_view_disable) 
91bc fe 2a			cp '*' 
91be 20 04			jr nz,.tdon  
91c0 3e 01			ld a, 1 
91c2 18 02			jr .tog1 
91c4 3e 00		.tdon: ld a, 0 
91c6			 
91c6			.tog1: 
91c6 cd ab 88			call menu 
91c9 fe 00			cp 0 
91cb c8				ret z 
91cc fe 01			cp 1    ; disable debug 
91ce 28 04			jr z, .dtog0 
91d0 3e 2a			ld a, '*' 
91d2 18 02			jr .dtogset 
91d4 3e 00		.dtog0: ld a, 0 
91d6 32 d7 e4		.dtogset:  ld (os_view_disable), a 
91d9 c3 b6 91			jp .debug_tog 
91dc			 
91dc			 
91dc			hardware_diags:       
91dc			 
91dc			.diagm: 
91dc 21 ef 91			ld hl, .menuitems 
91df 3e 00			ld a, 0 
91e1 cd ab 88			call menu 
91e4			 
91e4 fe 00		         cp 0 
91e6 c8				 ret z 
91e7			 
91e7 fe 02			cp 2 
91e9 ca 48 92			jp z, .diagedit 
91ec			 
91ec			;	cp '6' 
91ec			;	jp z, .menutest 
91ec			;if ENABLE_BASIC 
91ec			;	cp '6' 
91ec			;	jp z, basic 
91ec			;endif 
91ec			  
91ec c3 dc 91			jp .diagm 
91ef			 
91ef				 
91ef 03 92		.menuitems:   	dw .m1 
91f1 0e 92				dw .m2 
91f3 15 92				dw .m3 
91f5 1d 92				dw .m5 
91f7 23 92				dw .m5a 
91f9 2c 92				dw .m5b 
91fb 00 00				dw 0 
91fd			 
91fd			.menudebug: 
91fd 35 92				dw .m6 
91ff 3e 92				dw .m7 
9201 00 00				dw 0 
9203			 
9203 .. 00		.m1:   db "Key Matrix",0 
920e .. 00		.m2:   db "Editor",0 
9215 .. 00		.m3:   db "Storage",0 
921d .. 00		.m5:   db "Sound",0 
9223 .. 00		.m5a:  db "RAM Test",0 
922c .. 00		.m5b:  db "LCD Test",0 
9235			 
9235 .. 00		.m6:   db "Debug ON",0 
923e .. 00		.m7:   db "Debug OFF",0 
9248			 
9248			; debug editor 
9248			 
9248			.diagedit: 
9248			 
9248 21 e6 e4			ld hl, scratch 
924b			;	ld bc, 250 
924b			;	ldir 
924b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
924b 3e 00			ld a, 0 
924d 77				ld (hl), a 
924e 23				inc hl 
924f 77				ld (hl), a 
9250 23				inc hl 
9251 77				ld (hl), a 
9252			 
9252 cd 7a 88		        call clear_display 
9255 cd 9d 88			call update_display 
9258 3e 01			ld a, 1 
925a 32 c6 ee			ld (hardware_diag), a 
925d			.diloop: 
925d 3e 00			ld a, display_row_1 
925f 0e 00			ld c, 0 
9261 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9263 1e 28			ld e, 40 
9265			 
9265 21 e6 e4			ld hl, scratch	 
9268 cd d4 8a			call input_str 
926b			 
926b 3e 14			ld a, display_row_2 
926d 11 e6 e4			ld de, scratch 
9270 cd 8d 88			call str_at_display 
9273 cd 9d 88			call update_display 
9276			 
9276 c3 5d 92			jp .diloop 
9279			 
9279			 
9279			; pass word in hl 
9279			; a has display location 
9279			display_word_at: 
9279 f5				push af 
927a e5				push hl 
927b 7c				ld a,h 
927c 21 eb e7			ld hl, os_word_scratch 
927f cd a8 8d			call hexout 
9282 e1				pop hl 
9283 7d				ld a,l 
9284 21 ed e7			ld hl, os_word_scratch+2 
9287 cd a8 8d			call hexout 
928a 21 ef e7			ld hl, os_word_scratch+4 
928d 3e 00			ld a,0 
928f 77				ld (hl),a 
9290 11 eb e7			ld de,os_word_scratch 
9293 f1				pop af 
9294 cd 8d 88				call str_at_display 
9297 c9				ret 
9298			 
9298			display_ptr_state: 
9298			 
9298				; to restore afterwards 
9298			 
9298 d5				push de 
9299 c5				push bc 
929a e5				push hl 
929b f5				push af 
929c			 
929c				; for use in here 
929c			 
929c			;	push bc 
929c			;	push de 
929c			;	push hl 
929c			;	push af 
929c			 
929c cd 7a 88			call clear_display 
929f			 
929f 11 72 94			ld de, .ptrstate 
92a2 3e 00			ld a, display_row_1 
92a4 cd 8d 88			call str_at_display 
92a7			 
92a7				; display debug step 
92a7			 
92a7			 
92a7 11 c0 ee			ld de, debug_mark 
92aa 3e 12			ld a, display_row_1+display_cols-2 
92ac cd 8d 88			call str_at_display 
92af			 
92af				; display a 
92af 11 7c 94			ld de, .ptrcliptr 
92b2 3e 14			ld a, display_row_2 
92b4 cd 8d 88			call str_at_display 
92b7			 
92b7 f1				pop af 
92b8 2a b1 ec			ld hl,(cli_ptr) 
92bb 3e 1c			ld a, display_row_2+8 
92bd cd 79 92			call display_word_at 
92c0			 
92c0			 
92c0				; display hl 
92c0			 
92c0			 
92c0 11 84 94			ld de, .ptrclioptr 
92c3 3e 1e			ld a, display_row_2+10 
92c5 cd 8d 88			call str_at_display 
92c8			; 
92c8			;	pop hl 
92c8 3e 21			ld a, display_row_2+13 
92ca 2a af ec			ld hl,(cli_origptr) 
92cd cd 79 92			call display_word_at 
92d0			; 
92d0			;	 
92d0			;	; display de 
92d0			 
92d0			;	ld de, .regstatede 
92d0			;	ld a, display_row_3 
92d0			;	call str_at_display 
92d0			 
92d0			;	pop de 
92d0			;	ld h,d 
92d0			;	ld l, e 
92d0			;	ld a, display_row_3+3 
92d0			;	call display_word_at 
92d0			 
92d0			 
92d0				; display bc 
92d0			 
92d0			;	ld de, .regstatebc 
92d0			;	ld a, display_row_3+10 
92d0			;	call str_at_display 
92d0			 
92d0			;	pop bc 
92d0			;	ld h,b 
92d0			;	ld l, c 
92d0			;	ld a, display_row_3+13 
92d0			;	call display_word_at 
92d0			 
92d0			 
92d0				; display dsp 
92d0			 
92d0			;	ld de, .regstatedsp 
92d0			;	ld a, display_row_4 
92d0			;	call str_at_display 
92d0			 
92d0				 
92d0			;	ld hl,(cli_data_sp) 
92d0			;	ld a, display_row_4+4 
92d0			;	call display_word_at 
92d0			 
92d0				; display rsp 
92d0			 
92d0 11 b3 94			ld de, .regstatersp 
92d3 3e 46			ld a, display_row_4+10 
92d5 cd 8d 88			call str_at_display 
92d8			 
92d8				 
92d8 2a 97 ec			ld hl,(cli_ret_sp) 
92db 3e 4a			ld a, display_row_4+14 
92dd cd 79 92			call display_word_at 
92e0			 
92e0 cd 9d 88			call update_display 
92e3			 
92e3 cd fa 87			call delay1s 
92e6 cd fa 87			call delay1s 
92e9 cd fa 87			call delay1s 
92ec			 
92ec			 
92ec cd f9 97			call next_page_prompt 
92ef			 
92ef				; restore  
92ef			 
92ef f1				pop af 
92f0 e1				pop hl 
92f1 c1				pop bc 
92f2 d1				pop de 
92f3 c9				ret 
92f4			 
92f4			break_point_state: 
92f4 f5				push af 
92f5			 
92f5				; see if disabled 
92f5			 
92f5 3a d7 e4			ld a, (os_view_disable) 
92f8 fe 2a			cp '*' 
92fa 20 02			jr nz, .bpsgo 
92fc f1				pop af 
92fd c9				ret 
92fe			 
92fe			.bpsgo: 
92fe f1				pop af 
92ff f5				push af 
9300 22 d3 e4			ld (os_view_hl), hl 
9303 ed 53 d1 e4		ld (os_view_de), de 
9307 ed 43 cf e4		ld (os_view_bc), bc 
930b e5				push hl 
930c 6f				ld l, a 
930d 26 00			ld h, 0 
930f 22 d5 e4			ld (os_view_af),hl 
9312			 
9312 21 56 ee				ld hl, display_fb0 
9315 22 61 ed				ld (display_fb_active), hl 
9318 e1				pop hl	 
9319			 
9319 3e 31			ld a, '1' 
931b fe 2a		.bps1:  cp '*' 
931d 20 03			jr nz, .bps1b 
931f 32 d7 e4			ld (os_view_disable),a 
9322 fe 31		.bps1b:  cp '1' 
9324 20 14			jr nz, .bps2 
9326			 
9326				; display reg 
9326			 
9326				 
9326			 
9326 3a d5 e4			ld a, (os_view_af) 
9329 2a d3 e4			ld hl, (os_view_hl) 
932c ed 5b d1 e4		ld de, (os_view_de) 
9330 ed 4b cf e4		ld bc, (os_view_bc) 
9334 cd ce 93			call display_reg_state 
9337 c3 ba 93			jp .bpschk 
933a			 
933a fe 32		.bps2:  cp '2' 
933c 20 08			jr nz, .bps3 
933e				 
933e				; display hl 
933e 2a d3 e4			ld hl, (os_view_hl) 
9341 cd b8 94			call display_dump_at_hl 
9344			 
9344 18 74			jr .bpschk 
9346			 
9346 fe 33		.bps3:  cp '3' 
9348 20 08			jr nz, .bps4 
934a			 
934a			        ; display de 
934a 2a d1 e4			ld hl, (os_view_de) 
934d cd b8 94			call display_dump_at_hl 
9350			 
9350 18 68			jr .bpschk 
9352 fe 34		.bps4:  cp '4' 
9354 20 08			jr nz, .bps5 
9356			 
9356			        ; display bc 
9356 2a cf e4			ld hl, (os_view_bc) 
9359 cd b8 94			call display_dump_at_hl 
935c			 
935c 18 5c			jr .bpschk 
935e fe 35		.bps5:  cp '5' 
9360 20 08		        jr nz, .bps7 
9362			 
9362				; display cur ptr 
9362 2a b1 ec			ld hl, (cli_ptr) 
9365 cd b8 94			call display_dump_at_hl 
9368			 
9368 18 50			jr .bpschk 
936a fe 36		.bps7:  cp '6' 
936c 20 08			jr nz, .bps8b 
936e				 
936e				; display cur orig ptr 
936e 2a af ec			ld hl, (cli_origptr) 
9371 cd b8 94			call display_dump_at_hl 
9374 18 44			jr .bpschk 
9376 fe 37		.bps8b:  cp '7' 
9378 20 08			jr nz, .bps9 
937a				 
937a				; display dsp 
937a 2a 93 ec			ld hl, (cli_data_sp) 
937d cd b8 94			call display_dump_at_hl 
9380			 
9380 18 38			jr .bpschk 
9382 fe 39		.bps9:  cp '9' 
9384 20 05			jr nz, .bps8c 
9386				 
9386				; display SP 
9386			;	ld hl, sp 
9386 cd b8 94			call display_dump_at_hl 
9389			 
9389 18 2f			jr .bpschk 
938b fe 38		.bps8c:  cp '8' 
938d 20 08			jr nz, .bps8d 
938f				 
938f				; display rsp 
938f 2a 97 ec			ld hl, (cli_ret_sp) 
9392 cd b8 94			call display_dump_at_hl 
9395			 
9395 18 23			jr .bpschk 
9397 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9399 20 05			jr nz, .bps8 
939b cd ef 95			call monitor 
939e			 
939e 18 1a			jr .bpschk 
93a0 fe 30		.bps8:  cp '0' 
93a2 20 16			jr nz, .bpschk 
93a4			 
93a4 21 05 ee				ld hl, display_fb1 
93a7 22 61 ed				ld (display_fb_active), hl 
93aa cd 9d 88				call update_display 
93ad			 
93ad				;ld a, (os_view_af) 
93ad 2a d3 e4			ld hl, (os_view_hl) 
93b0 ed 5b d1 e4		ld de, (os_view_de) 
93b4 ed 4b cf e4		ld bc, (os_view_bc) 
93b8 f1				pop af 
93b9 c9				ret 
93ba			 
93ba			.bpschk:   
93ba cd fa 87			call delay1s 
93bd 3e 4f		ld a,display_row_4 + display_cols - 1 
93bf 11 f7 97		        ld de, endprg 
93c2 cd 8d 88			call str_at_display 
93c5 cd 9d 88			call update_display 
93c8 cd 5f d8			call cin_wait 
93cb			 
93cb c3 1b 93			jp .bps1 
93ce			 
93ce			 
93ce			display_reg_state: 
93ce			 
93ce				; to restore afterwards 
93ce			 
93ce d5				push de 
93cf c5				push bc 
93d0 e5				push hl 
93d1 f5				push af 
93d2			 
93d2				; for use in here 
93d2			 
93d2 c5				push bc 
93d3 d5				push de 
93d4 e5				push hl 
93d5 f5				push af 
93d6			 
93d6 cd 7a 88			call clear_display 
93d9			 
93d9 11 8e 94			ld de, .regstate 
93dc 3e 00			ld a, display_row_1 
93de cd 8d 88			call str_at_display 
93e1			 
93e1				; display debug step 
93e1			 
93e1			 
93e1 11 c0 ee			ld de, debug_mark 
93e4 3e 11			ld a, display_row_1+display_cols-3 
93e6 cd 8d 88			call str_at_display 
93e9			 
93e9				; display a 
93e9 11 aa 94			ld de, .regstatea 
93ec 3e 14			ld a, display_row_2 
93ee cd 8d 88			call str_at_display 
93f1			 
93f1 e1				pop hl 
93f2			;	ld h,0 
93f2			;	ld l, a 
93f2 3e 17			ld a, display_row_2+3 
93f4 cd 79 92			call display_word_at 
93f7			 
93f7			 
93f7				; display hl 
93f7			 
93f7			 
93f7 11 9e 94			ld de, .regstatehl 
93fa 3e 1e			ld a, display_row_2+10 
93fc cd 8d 88			call str_at_display 
93ff			 
93ff e1				pop hl 
9400 3e 21			ld a, display_row_2+13 
9402 cd 79 92			call display_word_at 
9405			 
9405				 
9405				; display de 
9405			 
9405 11 a2 94			ld de, .regstatede 
9408 3e 28			ld a, display_row_3 
940a cd 8d 88			call str_at_display 
940d			 
940d e1				pop hl 
940e			;	ld h,d 
940e			;	ld l, e 
940e 3e 2b			ld a, display_row_3+3 
9410 cd 79 92			call display_word_at 
9413			 
9413			 
9413				; display bc 
9413			 
9413 11 a6 94			ld de, .regstatebc 
9416 3e 32			ld a, display_row_3+10 
9418 cd 8d 88			call str_at_display 
941b			 
941b e1				pop hl 
941c			;	ld h,b 
941c			;	ld l, c 
941c 3e 35			ld a, display_row_3+13 
941e cd 79 92			call display_word_at 
9421			 
9421			 
9421				; display dsp 
9421			 
9421 11 ae 94			ld de, .regstatedsp 
9424 3e 3c			ld a, display_row_4 
9426 cd 8d 88			call str_at_display 
9429			 
9429				 
9429 2a 93 ec			ld hl,(cli_data_sp) 
942c 3e 40			ld a, display_row_4+4 
942e cd 79 92			call display_word_at 
9431			 
9431				; display rsp 
9431			 
9431 11 b3 94			ld de, .regstatersp 
9434 3e 46			ld a, display_row_4+10 
9436 cd 8d 88			call str_at_display 
9439			 
9439				 
9439 2a 97 ec			ld hl,(cli_ret_sp) 
943c 3e 4a			ld a, display_row_4+14 
943e cd 79 92			call display_word_at 
9441			 
9441 cd 9d 88			call update_display 
9444			 
9444			;	call delay1s 
9444			;	call delay1s 
9444			;	call delay1s 
9444			 
9444			 
9444			;	call next_page_prompt 
9444			 
9444				; restore  
9444			 
9444 f1				pop af 
9445 e1				pop hl 
9446 c1				pop bc 
9447 d1				pop de 
9448 c9				ret 
9449			 
9449 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
945d .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9472 .. 00		.ptrstate:	db "Ptr State",0 
947c .. 00		.ptrcliptr:     db "cli_ptr",0 
9484 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
948e .. 00		.regstate:	db "Reg State (1/0)",0 
949e .. 00		.regstatehl:	db "HL:",0 
94a2 .. 00		.regstatede:	db "DE:",0 
94a6 .. 00		.regstatebc:	db "BC:",0 
94aa .. 00		.regstatea:	db "A :",0 
94ae .. 00		.regstatedsp:	db "DSP:",0 
94b3 .. 00		.regstatersp:	db "RSP:",0 
94b8			 
94b8			display_dump_at_hl: 
94b8 e5				push hl 
94b9 d5				push de 
94ba c5				push bc 
94bb f5				push af 
94bc			 
94bc 22 09 e8			ld (os_cur_ptr),hl	 
94bf cd 7a 88			call clear_display 
94c2 cd 01 97			call dumpcont 
94c5			;	call delay1s 
94c5			;	call next_page_prompt 
94c5			 
94c5			 
94c5 f1				pop af 
94c6 c1				pop bc 
94c7 d1				pop de 
94c8 e1				pop hl 
94c9 c9				ret 
94ca			 
94ca			;if ENABLE_BASIC 
94ca			;	include "nascombasic.asm" 
94ca			;	basic: 
94ca			;	include "forth/FORTH.ASM" 
94ca			;endif 
94ca			 
94ca			; eof 
94ca			 
94ca			 
# End of file firmware_diags.asm
94ca			  
94ca			  
94ca			  
94ca			  
94ca			; eof  
94ca			  
# End of file firmware.asm
94ca			 
94ca			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
94ca			;if BASE_KEV  
94ca			;baseram: equ 08000h 
94ca			;endif 
94ca			 
94ca			;if BASE_SC114 
94ca			;baseram:     equ    endofcode 
94ca			;endif 
94ca			 
94ca			 
94ca			; start system 
94ca			 
94ca			coldstart: 
94ca				; set sp 
94ca				; di/ei 
94ca			 
94ca f3				di 
94cb 31 00 f0			ld sp, tos 
94ce			;	ei 
94ce			 
94ce			 
94ce				; disable breakpoint by default 
94ce			 
94ce 3e 2a			ld a,'*' 
94d0 32 d7 e4			ld (os_view_disable),a 
94d3			 
94d3				; init hardware 
94d3			 
94d3				; init keyboard and screen hardware 
94d3			 
94d3 cd 03 80			call hardware_init 
94d6			 
94d6			 
94d6				; detect if any keys are held down to enable breakpoints at start up 
94d6			 
94d6 cd 65 d8			call cin  
94d9 fe 00			cp 0 
94db 28 03			jr z, .nokeys 
94dd			 
94dd				;call hardware_diags 
94dd cd 07 91			call config 
94e0			 
94e0			;	ld de, .bpen 
94e0			;	ld a, display_row_4 
94e0			;	call str_at_display 
94e0			;	call update_display 
94e0			; 
94e0			;	ld a,0 
94e0			;	ld (os_view_disable),a 
94e0			; 
94e0			;.bpwait: 
94e0			;	call cin 
94e0			;	cp 0 
94e0			;	jr z, .bpwait 
94e0			;	jr .nokeys 
94e0			; 
94e0			; 
94e0			;.bpen:  db "Break points enabled!",0 
94e0			 
94e0			 
94e0			 
94e0			 
94e0			 
94e0			 
94e0			.nokeys: 
94e0			 
94e0			 
94e0				 
94e0			 
94e0			;jp  testkey 
94e0			 
94e0			;call storage_get_block_0 
94e0			; 
94e0			;ld hl, 0 
94e0			;ld de, store_page 
94e0			;call storage_read_block 
94e0			 
94e0				 
94e0			;ld hl, 10 
94e0			;ld de, store_page 
94e0			;call storage_read_block 
94e0			 
94e0			 
94e0			 
94e0			 
94e0			 
94e0			;stop:	nop 
94e0			;	jp stop 
94e0			 
94e0			 
94e0			 
94e0			main: 
94e0 cd 7a 88			call clear_display 
94e3 cd 9d 88			call update_display 
94e6			 
94e6			 
94e6			 
94e6			;	call testlcd 
94e6			 
94e6			 
94e6			 
94e6 cd bf 9b			call forth_init 
94e9			 
94e9			 
94e9			warmstart: 
94e9 cd 95 9b			call forth_warmstart 
94ec			 
94ec				; run startup word load 
94ec			        ; TODO prevent this running at warmstart after crash  
94ec			 
94ec				if STARTUP_ENABLE 
94ec cd f9 d4				call forth_startup 
94ef			 
94ef					if STORAGE_SE 
94ef						call forth_autoload 
94ef					endif 
94ef			 
94ef				endif 
94ef			 
94ef				; show free memory after boot 
94ef 11 89 95			ld de, freeram 
94f2 3e 00			ld a, display_row_1 
94f4 cd 8d 88			call str_at_display 
94f7			 
94f7			; Or use heap_size word???? 
94f7 21 cc e4			ld hl, heap_end 
94fa 11 83 d8			ld de, heap_start 
94fd ed 52			sbc hl, de 
94ff e5				push hl 
9500 7c				ld a,h	         	 
9501 21 eb e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9504 cd a8 8d			call hexout 
9507 e1			   	pop hl 
9508			 
9508 7d				ld a,l 
9509 21 ed e7			ld hl, os_word_scratch+2 
950c cd a8 8d			call hexout 
950f 21 ef e7			ld hl, os_word_scratch+4 
9512 3e 00			ld a, 0 
9514 77				ld (hl),a 
9515 11 eb e7			ld de, os_word_scratch 
9518 3e 0d			ld a, display_row_1 + 13 
951a cd 8d 88			call str_at_display 
951d cd 9d 88			call update_display 
9520			 
9520			 
9520				;call demo 
9520			 
9520			 
9520				; init scratch input area for cli commands 
9520			 
9520 21 0d e8			ld hl, os_cli_cmd 
9523 3e 00			ld a,0 
9525 77				ld (hl),a 
9526 23				inc hl 
9527 77				ld (hl),a 
9528			 
9528 3e 00			ld a,0 
952a 32 0c e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
952d			 
952d 32 09 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9530 32 0a e8			ld (os_cur_ptr+1),a	 
9533			 
9533 32 eb e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9536 32 ec e7			ld (os_word_scratch+1),a	 
9539				 
9539			 
9539				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9539 21 0d e8			ld hl, os_cli_cmd 
953c			 
953c 3e 00			ld a, 0		 ; init cli input 
953e 77				ld (hl), a 
953f 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9541			cli: 
9541				; show cli prompt 
9541				;push af 
9541				;ld a, 0 
9541				;ld de, prompt 
9541				;call str_at_display 
9541			 
9541				;call update_display 
9541				;pop af 
9541				;inc a 
9541				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9541 0e 00			ld c, 0 
9543 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9545 1e 28			ld e, 40 
9547			 
9547 21 0d e8			ld hl, os_cli_cmd 
954a			 
954a				STACKFRAME OFF $fefe $9f9f 
954a				if DEBUG_STACK_IMB 
954a					if OFF 
954a						exx 
954a						ld de, $fefe 
954a						ld a, d 
954a						ld hl, curframe 
954a						call hexout 
954a						ld a, e 
954a						ld hl, curframe+2 
954a						call hexout 
954a						ld hl, $fefe 
954a						push hl 
954a						ld hl, $9f9f 
954a						push hl 
954a						exx 
954a					endif 
954a				endif 
954a			endm 
# End of macro STACKFRAME
954a			 
954a cd d4 8a			call input_str 
954d			 
954d				STACKFRAMECHK OFF $fefe $9f9f 
954d				if DEBUG_STACK_IMB 
954d					if OFF 
954d						exx 
954d						ld hl, $9f9f 
954d						pop de   ; $9f9f 
954d						call cmp16 
954d						jr nz, .spnosame 
954d						ld hl, $fefe 
954d						pop de   ; $fefe 
954d						call cmp16 
954d						jr z, .spfrsame 
954d						.spnosame: call showsperror 
954d						.spfrsame: nop 
954d						exx 
954d					endif 
954d				endif 
954d			endm 
# End of macro STACKFRAMECHK
954d			 
954d				; copy input to last command 
954d			 
954d 21 0d e8			ld hl, os_cli_cmd 
9550 11 0c e9			ld de, os_last_cmd 
9553 01 ff 00			ld bc, 255 
9556 ed b0			ldir 
9558			 
9558				; wipe current buffer 
9558			 
9558			;	ld a, 0 
9558			;	ld hl, os_cli_cmd 
9558			;	ld de, os_cli_cmd+1 
9558			;	ld bc, 254 
9558			;	ldir 
9558				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9558			;	call strcpy 
9558			;	ld a, 0 
9558			;	ld (hl), a 
9558			;	inc hl 
9558			;	ld (hl), a 
9558			;	inc hl 
9558			;	ld (hl), a 
9558			 
9558				; switch frame buffer to program  
9558			 
9558 21 05 ee				ld hl, display_fb1 
955b 22 61 ed				ld (display_fb_active), hl 
955e			 
955e			;	nop 
955e				STACKFRAME ON $fbfe $8f9f 
955e				if DEBUG_STACK_IMB 
955e					if ON 
955e						exx 
955e						ld de, $fbfe 
955e						ld a, d 
955e						ld hl, curframe 
955e						call hexout 
955e						ld a, e 
955e						ld hl, curframe+2 
955e						call hexout 
955e						ld hl, $fbfe 
955e						push hl 
955e						ld hl, $8f9f 
955e						push hl 
955e						exx 
955e					endif 
955e				endif 
955e			endm 
# End of macro STACKFRAME
955e				; first time into the parser so pass over the current scratch pad 
955e 21 0d e8			ld hl,os_cli_cmd 
9561				; tokenise the entered statement(s) in HL 
9561 cd 38 9c			call forthparse 
9564			        ; exec forth statements in top of return stack 
9564 cd 78 9c			call forthexec 
9567				;call forthexec_cleanup 
9567			;	call parsenext 
9567			 
9567				STACKFRAMECHK ON $fbfe $8f9f 
9567				if DEBUG_STACK_IMB 
9567					if ON 
9567						exx 
9567						ld hl, $8f9f 
9567						pop de   ; $8f9f 
9567						call cmp16 
9567						jr nz, .spnosame 
9567						ld hl, $fbfe 
9567						pop de   ; $fbfe 
9567						call cmp16 
9567						jr z, .spfrsame 
9567						.spnosame: call showsperror 
9567						.spfrsame: nop 
9567						exx 
9567					endif 
9567				endif 
9567			endm 
# End of macro STACKFRAMECHK
9567				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9567			 
9567 3e 3c			ld a, display_row_4 
9569 11 9b 95			ld de, endprog 
956c			 
956c cd 9d 88			call update_display		 
956f			 
956f cd f9 97			call next_page_prompt 
9572			 
9572				; switch frame buffer to cli 
9572			 
9572 21 56 ee				ld hl, display_fb0 
9575 22 61 ed				ld (display_fb_active), hl 
9578			 
9578			 
9578 cd 7a 88		        call clear_display 
957b cd 9d 88			call update_display		 
957e			 
957e 21 0d e8			ld hl, os_cli_cmd 
9581			 
9581 3e 00			ld a, 0		 ; init cli input 
9583 77				ld (hl), a 
9584			 
9584				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9584			 
9584				; now on last line 
9584			 
9584				; TODO scroll screen up 
9584			 
9584				; TODO instead just clear screen and place at top of screen 
9584			 
9584			;	ld a, 0 
9584			;	ld (f_cursor_ptr),a 
9584			 
9584				;call clear_display 
9584				;call update_display 
9584			 
9584				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9584 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9586 c3 41 95			jp cli 
9589			 
9589 .. 00		freeram: db "Free bytes: $",0 
9597 ..			asc: db "1A2F" 
959b .. 00		endprog: db "End prog...",0 
95a7			 
95a7			testenter2:   
95a7 21 18 e5			ld hl,scratch+50 
95aa 22 09 e8			ld (os_cur_ptr),hl 
95ad c3 41 95			jp cli 
95b0			 
95b0			testenter:  
95b0			 
95b0 21 97 95			ld hl,asc 
95b3			;	ld a,(hl) 
95b3			;	call nibble2val 
95b3 cd fe 8d			call get_byte 
95b6			 
95b6			 
95b6			;	ld a,(hl) 
95b6			;	call atohex 
95b6			 
95b6			;	call fourehexhl 
95b6 32 18 e5			ld (scratch+50),a 
95b9			 
95b9			 
95b9			 
95b9 21 99 95			ld hl,asc+2 
95bc			;	ld a, (hl) 
95bc			;	call nibble2val 
95bc cd fe 8d			call get_byte 
95bf			 
95bf			;	call fourehexhl 
95bf 32 1a e5			ld (scratch+52),a 
95c2				 
95c2 21 18 e5			ld hl,scratch+50 
95c5 22 09 e8			ld (os_cur_ptr),hl 
95c8 c3 41 95			jp cli 
95cb			 
95cb			enter:	 
95cb 3a ea e4			ld a,(scratch+4) 
95ce fe 00			cp 0 
95d0 28 0c			jr z, .entercont 
95d2				; no, not a null term line so has an address to work out.... 
95d2			 
95d2 21 e8 e4			ld hl,scratch+2 
95d5 cd 5e 8e			call get_word_hl 
95d8			 
95d8 22 09 e8			ld (os_cur_ptr),hl	 
95db c3 41 95			jp cli 
95de			 
95de			 
95de			.entercont:  
95de			 
95de 21 e8 e4			ld hl, scratch+2 
95e1 cd fe 8d			call get_byte 
95e4			 
95e4 2a 09 e8		   	ld hl,(os_cur_ptr) 
95e7 77					ld (hl),a 
95e8 23					inc hl 
95e9 22 09 e8				ld (os_cur_ptr),hl 
95ec				 
95ec			; get byte  
95ec			 
95ec			 
95ec c3 41 95			jp cli 
95ef			 
95ef			 
95ef			; basic monitor support 
95ef			 
95ef			monitor: 
95ef				;  
95ef cd 7a 88			call clear_display 
95f2 3e 00			ld a, 0 
95f4 11 3c 96			ld de, .monprompt 
95f7 cd 8d 88			call str_at_display 
95fa cd 9d 88			call update_display 
95fd			 
95fd				; get a monitor command 
95fd			 
95fd 0e 00			ld c, 0     ; entry at top left 
95ff 16 64			ld d, 100   ; max buffer size 
9601 1e 0f			ld e, 15    ; input scroll area 
9603 3e 00			ld a, 0     ; init string 
9605 21 e4 e6			ld hl, os_input 
9608 77				ld (hl), a 
9609 23				inc hl 
960a 77				ld (hl), a 
960b 21 e4 e6			ld hl, os_input 
960e 3e 01			ld a, 1     ; init string 
9610 cd d4 8a			call input_str 
9613			 
9613 cd 7a 88		        call clear_display 
9616 cd 9d 88			call update_display		 
9619			 
9619 3a e4 e6			ld a, (os_input) 
961c cd fc 8e			call toUpper 
961f fe 48		        cp 'H' 
9621 28 6f		        jr z, .monhelp 
9623 fe 44			cp 'D'		; dump 
9625 ca b3 96			jp z, .mondump	 
9628 fe 43			cp 'C'		; dump 
962a ca cd 96			jp z, .moncdump	 
962d fe 4d			cp 'M'		; dump 
962f ca 3e 96			jp z, .moneditstart 
9632 fe 55			cp 'U'		; dump 
9634 28 14			jr z, .monedit	 
9636 fe 51			cp 'Q'		; dump 
9638 c8				ret z	 
9639			 
9639			 
9639				; TODO "S" to access symbol by name and not need the address 
9639				; TODO "F" to find a string in memory 
9639			 
9639 c3 ef 95			jp monitor 
963c			 
963c .. 00		.monprompt: db ">", 0 
963e			 
963e			.moneditstart: 
963e				; get starting address 
963e			 
963e 21 e6 e6			ld hl,os_input+2 
9641 cd 5e 8e			call get_word_hl 
9644			 
9644 22 09 e8			ld (os_cur_ptr),hl	 
9647			 
9647 c3 ef 95			jp monitor 
964a			 
964a			.monedit: 
964a				; get byte to load 
964a			 
964a 21 e6 e6			ld hl,os_input+2 
964d cd fe 8d			call get_byte 
9650			 
9650				; get address to update 
9650 2a 09 e8			ld hl, (os_cur_ptr) 
9653			 
9653				; update byte 
9653			 
9653 77				ld (hl), a 
9654			 
9654				; move to next address and save it 
9654			 
9654 23				inc hl 
9655 22 09 e8			ld (os_cur_ptr),hl	 
9658			 
9658 c3 ef 95			jp monitor 
965b			 
965b			 
965b .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
966f .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
968b .. 00		.monhelptext3:  db "Q-Quit",0 
9692			        
9692			.monhelp: 
9692 3e 00			ld a, display_row_1 
9694 11 5b 96		        ld de, .monhelptext1 
9697			 
9697 cd 8d 88			call str_at_display 
969a 3e 14			ld a, display_row_2 
969c 11 6f 96		        ld de, .monhelptext2 
969f					 
969f cd 8d 88			call str_at_display 
96a2 3e 28			ld a, display_row_3 
96a4 11 8b 96		        ld de, .monhelptext3 
96a7					 
96a7 cd 8d 88			call str_at_display 
96aa cd 9d 88			call update_display		 
96ad			 
96ad cd f9 97			call next_page_prompt 
96b0 c3 ef 95			jp monitor 
96b3			 
96b3			.mondump:    
96b3 21 e6 e6			ld hl,os_input+2 
96b6 cd 5e 8e			call get_word_hl 
96b9			 
96b9 22 09 e8			ld (os_cur_ptr),hl	 
96bc cd 01 97			call dumpcont 
96bf 3e 3c			ld a, display_row_4 
96c1 11 9b 95			ld de, endprog 
96c4			 
96c4 cd 9d 88			call update_display		 
96c7			 
96c7 cd f9 97			call next_page_prompt 
96ca c3 ef 95			jp monitor 
96cd			.moncdump: 
96cd cd 01 97			call dumpcont 
96d0 3e 3c			ld a, display_row_4 
96d2 11 9b 95			ld de, endprog 
96d5			 
96d5 cd 9d 88			call update_display		 
96d8			 
96d8 cd f9 97			call next_page_prompt 
96db c3 ef 95			jp monitor 
96de			 
96de			 
96de			; TODO symbol access  
96de			 
96de			.symbols:     ;; A list of symbols that can be called up  
96de 56 ee			dw display_fb0 
96e0 .. 00			db "fb0",0  
96e4 eb ec		     	dw store_page 
96e6 .. 00			db "store_page",0 
96f1			 
96f1			 
96f1			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
96f1			 
96f1 3a e7 e4			ld a,(scratch+1) 
96f4 fe 00			cp 0 
96f6 28 09			jr z, dumpcont 
96f8			 
96f8				; no, not a null term line so has an address to work out.... 
96f8			 
96f8 21 e8 e4			ld hl,scratch+2 
96fb cd 5e 8e			call get_word_hl 
96fe			 
96fe 22 09 e8			ld (os_cur_ptr),hl	 
9701			 
9701			 
9701			 
9701			dumpcont: 
9701			 
9701				; dump bytes at ptr 
9701			 
9701			 
9701 3e 00			ld a, display_row_1 
9703 2a 61 ed			ld hl, (display_fb_active) 
9706 cd a7 8a			call addatohl 
9709 cd 31 97			call .dumpbyterow 
970c			 
970c 3e 14			ld a, display_row_2 
970e 2a 61 ed			ld hl, (display_fb_active) 
9711 cd a7 8a			call addatohl 
9714 cd 31 97			call .dumpbyterow 
9717			 
9717			 
9717 3e 28			ld a, display_row_3 
9719 2a 61 ed			ld hl, (display_fb_active) 
971c cd a7 8a			call addatohl 
971f cd 31 97			call .dumpbyterow 
9722			 
9722 3e 3c			ld a, display_row_4 
9724 2a 61 ed			ld hl, (display_fb_active) 
9727 cd a7 8a			call addatohl 
972a cd 31 97			call .dumpbyterow 
972d			 
972d cd 9d 88			call update_display 
9730			;		jp cli 
9730 c9				ret 
9731			 
9731			.dumpbyterow: 
9731			 
9731				;push af 
9731			 
9731 e5				push hl 
9732			 
9732				; calc where to poke the ascii 
9732			if display_cols == 20 
9732 3e 10			ld a, 16 
9734			else 
9734				ld a, 31 
9734			endif 
9734			 
9734 cd a7 8a			call addatohl 
9737 22 eb e7			ld (os_word_scratch),hl  		; save pos for later 
973a			 
973a			 
973a			; display decoding address 
973a 2a 09 e8		   	ld hl,(os_cur_ptr) 
973d			 
973d 7c				ld a,h 
973e e1				pop hl 
973f e5				push hl 
9740			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9740 cd a8 8d			call hexout 
9743 2a 09 e8		   	ld hl,(os_cur_ptr) 
9746			 
9746 7d				ld a,l 
9747 e1				pop hl 
9748 23				inc hl 
9749 23				inc hl 
974a e5				push hl 
974b			;	ld hl, os_word_scratch+2 
974b cd a8 8d			call hexout 
974e e1				pop hl 
974f 23				inc hl 
9750 23				inc hl 
9751				;ld hl, os_word_scratch+4 
9751 3e 3a			ld a, ':' 
9753 77				ld (hl),a 
9754 23				inc hl 
9755				;ld a, 0 
9755				;ld (hl),a 
9755				;ld de, os_word_scratch 
9755				;pop af 
9755				;push af 
9755			;		ld a, display_row_2 
9755			;		call str_at_display 
9755			;		call update_display 
9755			 
9755			 
9755			;pop af 
9755			;	add 5 
9755			 
9755			if display_cols == 20 
9755 06 04			ld b, 4 
9757			else 
9757				ld b, 8 
9757			endif	 
9757			 
9757			.dumpbyte: 
9757 c5				push bc 
9758 e5				push hl 
9759			 
9759			 
9759 2a 09 e8		   	ld hl,(os_cur_ptr) 
975c 7e					ld a,(hl) 
975d			 
975d					; poke the ascii to display 
975d 2a eb e7				ld hl,(os_word_scratch) 
9760 77					ld (hl),a 
9761 23					inc hl 
9762 22 eb e7				ld (os_word_scratch),hl 
9765			 
9765					 
9765			 
9765			 
9765 e1					pop hl 
9766 e5					push hl 
9767			 
9767 cd a8 8d				call hexout 
976a			 
976a					 
976a 2a 09 e8		   	ld hl,(os_cur_ptr) 
976d 23				inc hl 
976e 22 09 e8		   	ld (os_cur_ptr),hl 
9771			 
9771 e1					pop hl 
9772 23					inc hl 
9773 23					inc hl 
9774 23					inc hl 
9775			 
9775			 
9775			 
9775					;ld a,0 
9775					;ld (os_word_scratch+2),a 
9775					;pop af 
9775					;push af 
9775			 
9775					;ld de, os_word_scratch 
9775					;call str_at_display 
9775			;		call update_display 
9775			;		pop af 
9775 c1					pop bc 
9776 c6 03				add 3 
9778 10 dd			djnz .dumpbyte 
977a			 
977a				 
977a			 
977a c9				ret 
977b			 
977b			jump:	 
977b			 
977b 21 e8 e4			ld hl,scratch+2 
977e cd 5e 8e			call get_word_hl 
9781				;ld hl,(scratch+2) 
9781				;call fourehexhl 
9781			 
9781 22 09 e8			ld (os_cur_ptr),hl	 
9784			 
9784 e9				jp (hl) 
9785			 
9785			 
9785			 
9785			; TODO implement a basic monitor mode to start with 
9785			 
9785			 
9785			 
9785			 
9785			 
9785			 
9785			 
9785			 
9785			 
9785			; testing and demo code during development 
9785			 
9785			 
9785 .. 00		str1: db "Enter some text...",0 
9798 .. 00		clear: db "                    ",0 
97ad			 
97ad			demo: 
97ad			 
97ad			 
97ad			 
97ad			;	call update_display 
97ad			 
97ad				; init scratch input area for testing 
97ad 21 e6 e4			ld hl, scratch	 
97b0 3e 00			ld a,0 
97b2 77				ld (hl),a 
97b3			 
97b3			 
97b3 3e 14		            LD   A, display_row_2 
97b5			;            CALL fLCD_Pos       ;Position cursor to location in A 
97b5 11 85 97		            LD   DE, str1 
97b8 cd 8d 88			call str_at_display 
97bb			 
97bb			;            CALL fLCD_Str       ;Display string pointed to by DE 
97bb			cloop:	 
97bb 3e 28		            LD   A, display_row_3 
97bd			;            CALL fLCD_Pos       ;Position cursor to location in A 
97bd 11 98 97		            LD   DE, clear 
97c0			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
97c0 cd 8d 88				call str_at_display 
97c3 3e 3c			ld a, display_row_4 
97c5 11 f5 97			ld de, prompt 
97c8			 
97c8 cd 8d 88				call str_at_display 
97cb cd 9d 88			call update_display 
97ce			 
97ce 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d0 16 0a			ld d, 10 
97d2 21 e6 e4			ld hl, scratch	 
97d5 cd d4 8a			call input_str 
97d8			 
97d8			;	call clear_display 
97d8			;'	call update_display 
97d8			 
97d8 3e 00		            LD   A, display_row_1 
97da			;            CALL fLCD_Pos       ;Position cursor to location in A 
97da 11 98 97		            LD   DE, clear 
97dd cd 8d 88				call str_at_display 
97e0			;            CALL fLCD_Str       ;Display string pointed to by DE 
97e0 3e 00		            LD   A, display_row_1 
97e2			;            CALL fLCD_Pos       ;Position cursor to location in A 
97e2 11 e6 e4		            LD   DE, scratch 
97e5			;            CALL fLCD_Str       ;Display string pointed to by DE 
97e5 cd 8d 88				call str_at_display 
97e8 cd 9d 88			call update_display 
97eb			 
97eb 3e 00				ld a,0 
97ed 21 e6 e4			ld hl, scratch 
97f0 77				ld (hl),a 
97f1			 
97f1 00				nop 
97f2 c3 bb 97			jp cloop 
97f5			 
97f5			 
97f5			 
97f5			; OS Prompt 
97f5			 
97f5 .. 00		prompt: db ">",0 
97f7 .. 00		endprg: db "?",0 
97f9			 
97f9			 
97f9			; handy next page prompt 
97f9			next_page_prompt: 
97f9 e5				push hl 
97fa d5				push de 
97fb f5				push af 
97fc c5				push bc 
97fd			 
97fd 3e 4f			ld a,display_row_4 + display_cols - 1 
97ff 11 f7 97		        ld de, endprg 
9802 cd 8d 88			call str_at_display 
9805 cd 9d 88			call update_display 
9808 cd 5f d8			call cin_wait 
980b c1				pop bc 
980c f1				pop af 
980d d1				pop de 
980e e1				pop hl 
980f			 
980f			 
980f c9				ret 
9810			 
9810			 
9810			; forth parser 
9810			 
9810			; My forth kernel 
9810			include "forth_kernel.asm" 
9810			; 
9810			; kernel to the forth OS 
9810			 
9810			DS_TYPE_STR: equ 1     ; string type 
9810			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9810			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9810			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9810			 
9810			FORTH_PARSEV1: equ 0 
9810			FORTH_PARSEV2: equ 0 
9810			FORTH_PARSEV3: equ 0 
9810			FORTH_PARSEV4: equ 0 
9810			FORTH_PARSEV5: equ 1 
9810			 
9810			;if FORTH_PARSEV5 
9810			;	FORTH_END_BUFFER: equ 0 
9810			;else 
9810			FORTH_END_BUFFER: equ 127 
9810			;endif 
9810			 
9810			FORTH_TRUE: equ 1 
9810			FORTH_FALSE: equ 0 
9810			 
9810			if FORTH_PARSEV4 
9810			include "forth_stackops.asm" 
9810			endif 
9810			 
9810			if FORTH_PARSEV5 
9810			include "forth_stackopsv5.asm" 
9810			 
9810			; Stack operations for v5 parser on wards 
9810			; * DATA stack 
9810			; * LOOP stack 
9810			; * RETURN stack 
9810			 
9810			 
9810			 
9810			FORTH_CHK_DSP_UNDER: macro 
9810				push hl 
9810				push de 
9810				ld hl,(cli_data_sp) 
9810				ld de, cli_data_stack 
9810				call cmp16 
9810				jp c, fault_dsp_under 
9810				pop de 
9810				pop hl 
9810				endm 
9810			 
9810			 
9810			FORTH_CHK_RSP_UNDER: macro 
9810				push hl 
9810				push de 
9810				ld hl,(cli_ret_sp) 
9810				ld de, cli_ret_stack 
9810				call cmp16 
9810				jp c, fault_rsp_under 
9810				pop de 
9810				pop hl 
9810				endm 
9810			 
9810			FORTH_CHK_LOOP_UNDER: macro 
9810				push hl 
9810				push de 
9810				ld hl,(cli_loop_sp) 
9810				ld de, cli_loop_stack 
9810				call cmp16 
9810				jp c, fault_loop_under 
9810				pop de 
9810				pop hl 
9810				endm 
9810			 
9810			FORTH_ERR_TOS_NOTSTR: macro 
9810				; TOSO might need more for checks when used 
9810				push af 
9810				ld a,(hl) 
9810				cp DS_TYPE_STR 
9810				jp nz, type_faultn   
9810				pop af 
9810				endm 
9810			 
9810			FORTH_ERR_TOS_NOTNUM: macro 
9810				push af 
9810				ld a,(hl) 
9810				cp DS_TYPE_INUM 
9810				jp nz, type_faultn   
9810				pop af 
9810				endm 
9810			 
9810			 
9810			; increase data stack pointer and save hl to it 
9810				 
9810			FORTH_DSP_NEXT: macro 
9810				call macro_forth_dsp_next 
9810				endm 
9810			 
9810			 
9810			macro_forth_dsp_next: 
9810				if DEBUG_FORTH_STACK_GUARD 
9810 cd c3 d5				call check_stacks 
9813				endif 
9813 e5				push hl 
9814 d5				push de 
9815 eb				ex de,hl 
9816 2a 93 ec			ld hl,(cli_data_sp) 
9819 23				inc hl 
981a 23				inc hl 
981b			 
981b			; PARSEV5 
981b 23				inc hl 
981c 22 93 ec			ld (cli_data_sp),hl 
981f 73				ld (hl), e 
9820 23				inc hl 
9821 72				ld (hl), d 
9822 d1				pop de 
9823 e1				pop hl 
9824				if DEBUG_FORTH_STACK_GUARD 
9824 cd c3 d5				call check_stacks 
9827				endif 
9827 c9				ret 
9828			 
9828			 
9828			; increase ret stack pointer and save hl to it 
9828				 
9828			FORTH_RSP_NEXT: macro 
9828				call macro_forth_rsp_next 
9828				endm 
9828			 
9828			macro_forth_rsp_next: 
9828				if DEBUG_FORTH_STACK_GUARD 
9828 cd c3 d5				call check_stacks 
982b				endif 
982b e5				push hl 
982c d5				push de 
982d eb				ex de,hl 
982e 2a 97 ec			ld hl,(cli_ret_sp) 
9831 23				inc hl 
9832 23				inc hl 
9833 22 97 ec			ld (cli_ret_sp),hl 
9836 73				ld (hl), e 
9837 23				inc hl 
9838 72				ld (hl), d 
9839 d1				pop de 
983a e1				pop hl 
983b				if DEBUG_FORTH_STACK_GUARD 
983b cd c3 d5				call check_stacks 
983e				endif 
983e c9				ret 
983f			 
983f			; get current ret stack pointer and save to hl  
983f				 
983f			FORTH_RSP_TOS: macro 
983f				call macro_forth_rsp_tos 
983f				endm 
983f			 
983f			macro_forth_rsp_tos: 
983f				;push de 
983f 2a 97 ec			ld hl,(cli_ret_sp) 
9842 cd 7a 98			call loadhlptrtohl 
9845				;ld e, (hl) 
9845				;inc hl 
9845				;ld d, (hl) 
9845				;ex de, hl 
9845					if DEBUG_FORTH_WORDS 
9845			;			DMARK "RST" 
9845						CALLMONITOR 
9845 cd f4 92			call break_point_state  
9848				endm  
# End of macro CALLMONITOR
9848					endif 
9848				;pop de 
9848 c9				ret 
9849			 
9849			; pop ret stack pointer 
9849				 
9849			FORTH_RSP_POP: macro 
9849				call macro_forth_rsp_pop 
9849				endm 
9849			 
9849			 
9849			macro_forth_rsp_pop: 
9849				if DEBUG_FORTH_STACK_GUARD 
9849			;		DMARK "RPP" 
9849 cd c3 d5				call check_stacks 
984c					FORTH_CHK_RSP_UNDER 
984c e5				push hl 
984d d5				push de 
984e 2a 97 ec			ld hl,(cli_ret_sp) 
9851 11 51 ec			ld de, cli_ret_stack 
9854 cd c5 8a			call cmp16 
9857 da d7 d6			jp c, fault_rsp_under 
985a d1				pop de 
985b e1				pop hl 
985c				endm 
# End of macro FORTH_CHK_RSP_UNDER
985c				endif 
985c e5				push hl 
985d 2a 97 ec			ld hl,(cli_ret_sp) 
9860			 
9860			 
9860				if FORTH_ENABLE_FREE 
9860			 
9860					; get pointer 
9860			 
9860					push de 
9860					push hl 
9860			 
9860					ld e, (hl) 
9860					inc hl 
9860					ld d, (hl) 
9860			 
9860					ex de, hl 
9860					call free 
9860			 
9860					pop hl 
9860					pop de 
9860			 
9860			 
9860				endif 
9860			 
9860			 
9860 2b				dec hl 
9861 2b				dec hl 
9862 22 97 ec			ld (cli_ret_sp), hl 
9865				; do stack underflow checks 
9865 e1				pop hl 
9866				if DEBUG_FORTH_STACK_GUARD 
9866 cd c3 d5				call check_stacks 
9869					FORTH_CHK_RSP_UNDER 
9869 e5				push hl 
986a d5				push de 
986b 2a 97 ec			ld hl,(cli_ret_sp) 
986e 11 51 ec			ld de, cli_ret_stack 
9871 cd c5 8a			call cmp16 
9874 da d7 d6			jp c, fault_rsp_under 
9877 d1				pop de 
9878 e1				pop hl 
9879				endm 
# End of macro FORTH_CHK_RSP_UNDER
9879				endif 
9879 c9				ret 
987a			 
987a			 
987a			 
987a			; routine to load word pointed to by hl into hl 
987a			 
987a			loadhlptrtohl: 
987a			 
987a d5				push de 
987b 5e				ld e, (hl) 
987c 23				inc hl 
987d 56				ld d, (hl) 
987e eb				ex de, hl 
987f d1				pop de 
9880			 
9880 c9				ret 
9881			 
9881			 
9881			 
9881			 
9881			 
9881			; push a number held in HL onto the data stack 
9881			; entry point for pushing a value when already in hl used in function above 
9881			 
9881			forth_push_numhl: 
9881			 
9881 e5				push hl    ; save value to push 
9882			 
9882			if DEBUG_FORTH_PUSH 
9882				; see if disabled 
9882			 
9882			 
9882 f5				push af 
9883 3a d7 e4			ld a, (os_view_disable) 
9886 fe 2a			cp '*' 
9888 28 34			jr z, .pskip2 
988a e5				push hl 
988b e5			push hl 
988c cd 7a 88			call clear_display 
988f e1			pop hl 
9890 7c				ld a,h 
9891 21 eb e7			ld hl, os_word_scratch 
9894 cd a8 8d			call hexout 
9897 e1				pop hl 
9898 7d				ld a,l 
9899 21 ed e7			ld hl, os_word_scratch+2 
989c cd a8 8d			call hexout 
989f			 
989f 21 ef e7			ld hl, os_word_scratch+4 
98a2 3e 00			ld a,0 
98a4 77				ld (hl),a 
98a5 11 eb e7			ld de,os_word_scratch 
98a8 3e 14				ld a, display_row_2 
98aa cd 8d 88				call str_at_display 
98ad 11 d1 c4			ld de, .push_num 
98b0 3e 00			ld a, display_row_1 
98b2			 
98b2 cd 8d 88				call str_at_display 
98b5			 
98b5			 
98b5 cd 9d 88			call update_display 
98b8 cd fa 87			call delay1s 
98bb cd fa 87			call delay1s 
98be			.pskip2:  
98be			 
98be f1				pop af 
98bf			endif	 
98bf			 
98bf			 
98bf				FORTH_DSP_NEXT 
98bf cd 10 98			call macro_forth_dsp_next 
98c2				endm 
# End of macro FORTH_DSP_NEXT
98c2			 
98c2 2a 93 ec			ld hl, (cli_data_sp) 
98c5			 
98c5				; save item type 
98c5 3e 02			ld a,  DS_TYPE_INUM 
98c7 77				ld (hl), a 
98c8 23				inc hl 
98c9			 
98c9				; get word off stack 
98c9 d1				pop de 
98ca 7b				ld a,e 
98cb 77				ld (hl), a 
98cc 23				inc hl 
98cd 7a				ld a,d 
98ce 77				ld (hl), a 
98cf			 
98cf			if DEBUG_FORTH_PUSH 
98cf 2b				dec hl 
98d0 2b				dec hl 
98d1 2b				dec hl 
98d2						DMARK "PH5" 
98d2 f5				push af  
98d3 3a e7 98			ld a, (.dmark)  
98d6 32 c0 ee			ld (debug_mark),a  
98d9 3a e8 98			ld a, (.dmark+1)  
98dc 32 c1 ee			ld (debug_mark+1),a  
98df 3a e9 98			ld a, (.dmark+2)  
98e2 32 c2 ee			ld (debug_mark+2),a  
98e5 18 03			jr .pastdmark  
98e7 ..			.dmark: db "PH5"  
98ea f1			.pastdmark: pop af  
98eb			endm  
# End of macro DMARK
98eb				CALLMONITOR 
98eb cd f4 92			call break_point_state  
98ee				endm  
# End of macro CALLMONITOR
98ee			endif	 
98ee			 
98ee c9				ret 
98ef			 
98ef			 
98ef			; Push a string to stack pointed to by hl 
98ef			 
98ef			forth_push_str: 
98ef			 
98ef			if DEBUG_FORTH_PUSH 
98ef						DMARK "PSQ" 
98ef f5				push af  
98f0 3a 04 99			ld a, (.dmark)  
98f3 32 c0 ee			ld (debug_mark),a  
98f6 3a 05 99			ld a, (.dmark+1)  
98f9 32 c1 ee			ld (debug_mark+1),a  
98fc 3a 06 99			ld a, (.dmark+2)  
98ff 32 c2 ee			ld (debug_mark+2),a  
9902 18 03			jr .pastdmark  
9904 ..			.dmark: db "PSQ"  
9907 f1			.pastdmark: pop af  
9908			endm  
# End of macro DMARK
9908				CALLMONITOR 
9908 cd f4 92			call break_point_state  
990b				endm  
# End of macro CALLMONITOR
990b			endif	 
990b			    
990b e5				push hl 
990c e5				push hl 
990d			 
990d			;	ld a, 0   ; find end of string 
990d cd 05 8f			call strlenz 
9910			if DEBUG_FORTH_PUSH 
9910						DMARK "PQ2" 
9910 f5				push af  
9911 3a 25 99			ld a, (.dmark)  
9914 32 c0 ee			ld (debug_mark),a  
9917 3a 26 99			ld a, (.dmark+1)  
991a 32 c1 ee			ld (debug_mark+1),a  
991d 3a 27 99			ld a, (.dmark+2)  
9920 32 c2 ee			ld (debug_mark+2),a  
9923 18 03			jr .pastdmark  
9925 ..			.dmark: db "PQ2"  
9928 f1			.pastdmark: pop af  
9929			endm  
# End of macro DMARK
9929				CALLMONITOR 
9929 cd f4 92			call break_point_state  
992c				endm  
# End of macro CALLMONITOR
992c			endif	 
992c eb				ex de, hl 
992d e1				pop hl   ; get ptr to start of string 
992e			if DEBUG_FORTH_PUSH 
992e						DMARK "PQ3" 
992e f5				push af  
992f 3a 43 99			ld a, (.dmark)  
9932 32 c0 ee			ld (debug_mark),a  
9935 3a 44 99			ld a, (.dmark+1)  
9938 32 c1 ee			ld (debug_mark+1),a  
993b 3a 45 99			ld a, (.dmark+2)  
993e 32 c2 ee			ld (debug_mark+2),a  
9941 18 03			jr .pastdmark  
9943 ..			.dmark: db "PQ3"  
9946 f1			.pastdmark: pop af  
9947			endm  
# End of macro DMARK
9947				CALLMONITOR 
9947 cd f4 92			call break_point_state  
994a				endm  
# End of macro CALLMONITOR
994a			endif	 
994a 19				add hl,de 
994b			if DEBUG_FORTH_PUSH 
994b						DMARK "PQE" 
994b f5				push af  
994c 3a 60 99			ld a, (.dmark)  
994f 32 c0 ee			ld (debug_mark),a  
9952 3a 61 99			ld a, (.dmark+1)  
9955 32 c1 ee			ld (debug_mark+1),a  
9958 3a 62 99			ld a, (.dmark+2)  
995b 32 c2 ee			ld (debug_mark+2),a  
995e 18 03			jr .pastdmark  
9960 ..			.dmark: db "PQE"  
9963 f1			.pastdmark: pop af  
9964			endm  
# End of macro DMARK
9964				CALLMONITOR 
9964 cd f4 92			call break_point_state  
9967				endm  
# End of macro CALLMONITOR
9967			endif	 
9967			 
9967 2b				dec hl    ; see if there is an optional trailing double quote 
9968 7e				ld a,(hl) 
9969 fe 22			cp '"' 
996b 20 03			jr nz, .strnoq 
996d 3e 00			ld a, 0      ; get rid of double quote 
996f 77				ld (hl), a 
9970 23			.strnoq: inc hl 
9971			 
9971 3e 00			ld a, 0 
9973 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9974			 
9974 13				inc de ; add one for the type string 
9975 13				inc de ; add one for null term??? 
9976			 
9976				; tos is get string pointer again 
9976				; de contains space to allocate 
9976				 
9976 d5				push de 
9977			 
9977 eb				ex de, hl 
9978			 
9978				;push af 
9978			 
9978			if DEBUG_FORTH_PUSH 
9978						DMARK "PHm" 
9978 f5				push af  
9979 3a 8d 99			ld a, (.dmark)  
997c 32 c0 ee			ld (debug_mark),a  
997f 3a 8e 99			ld a, (.dmark+1)  
9982 32 c1 ee			ld (debug_mark+1),a  
9985 3a 8f 99			ld a, (.dmark+2)  
9988 32 c2 ee			ld (debug_mark+2),a  
998b 18 03			jr .pastdmark  
998d ..			.dmark: db "PHm"  
9990 f1			.pastdmark: pop af  
9991			endm  
# End of macro DMARK
9991				CALLMONITOR 
9991 cd f4 92			call break_point_state  
9994				endm  
# End of macro CALLMONITOR
9994			endif	 
9994 cd 6e 8f			call malloc	; on ret hl now contains allocated memory 
9997				if DEBUG_FORTH_MALLOC_GUARD 
9997 cc 29 c5				call z,malloc_error 
999a				endif 
999a			 
999a				 
999a c1				pop bc    ; get length 
999b d1				pop de   ;  get string start    
999c			 
999c				; hl has destination from malloc 
999c			 
999c eb				ex de, hl    ; prep for ldir 
999d			 
999d d5				push de   ; save malloc area for DSP later 
999e				;push hl   ; save malloc area for DSP later 
999e			 
999e			if DEBUG_FORTH_PUSH 
999e						DMARK "PHc" 
999e f5				push af  
999f 3a b3 99			ld a, (.dmark)  
99a2 32 c0 ee			ld (debug_mark),a  
99a5 3a b4 99			ld a, (.dmark+1)  
99a8 32 c1 ee			ld (debug_mark+1),a  
99ab 3a b5 99			ld a, (.dmark+2)  
99ae 32 c2 ee			ld (debug_mark+2),a  
99b1 18 03			jr .pastdmark  
99b3 ..			.dmark: db "PHc"  
99b6 f1			.pastdmark: pop af  
99b7			endm  
# End of macro DMARK
99b7				CALLMONITOR 
99b7 cd f4 92			call break_point_state  
99ba				endm  
# End of macro CALLMONITOR
99ba			endif	 
99ba			 
99ba			 
99ba ed b0			ldir 
99bc			 
99bc			 
99bc				; push malloc to data stack     macro?????  
99bc			 
99bc				FORTH_DSP_NEXT 
99bc cd 10 98			call macro_forth_dsp_next 
99bf				endm 
# End of macro FORTH_DSP_NEXT
99bf			 
99bf				; save value and type 
99bf			 
99bf 2a 93 ec			ld hl, (cli_data_sp) 
99c2			 
99c2				; save item type 
99c2 3e 01			ld a,  DS_TYPE_STR 
99c4 77				ld (hl), a 
99c5 23				inc hl 
99c6			 
99c6				; get malloc word off stack 
99c6 d1				pop de 
99c7 73				ld (hl), e 
99c8 23				inc hl 
99c9 72				ld (hl), d 
99ca			 
99ca			 
99ca			 
99ca			if DEBUG_FORTH_PUSH 
99ca 2a 93 ec			ld hl, (cli_data_sp) 
99cd						DMARK "PHS" 
99cd f5				push af  
99ce 3a e2 99			ld a, (.dmark)  
99d1 32 c0 ee			ld (debug_mark),a  
99d4 3a e3 99			ld a, (.dmark+1)  
99d7 32 c1 ee			ld (debug_mark+1),a  
99da 3a e4 99			ld a, (.dmark+2)  
99dd 32 c2 ee			ld (debug_mark+2),a  
99e0 18 03			jr .pastdmark  
99e2 ..			.dmark: db "PHS"  
99e5 f1			.pastdmark: pop af  
99e6			endm  
# End of macro DMARK
99e6				CALLMONITOR 
99e6 cd f4 92			call break_point_state  
99e9				endm  
# End of macro CALLMONITOR
99e9			;	ex de,hl 
99e9			endif	 
99e9				; in case of spaces, skip the ptr past the copied string 
99e9				;pop af 
99e9				;ld (cli_origptr),hl 
99e9			 
99e9 c9				ret 
99ea			 
99ea			 
99ea			 
99ea			; TODO ascii push input onto stack given hl to start of input 
99ea			 
99ea			; identify type 
99ea			; if starts with a " then a string 
99ea			; otherwise it is a number 
99ea			;  
99ea			; if a string 
99ea			;     scan for ending " to get length of string to malloc for + 1 
99ea			;     malloc 
99ea			;     put pointer to string on stack first byte flags as string 
99ea			; 
99ea			; else a number 
99ea			;    look for number format identifier 
99ea			;    $xx hex 
99ea			;    %xxxxx bin 
99ea			;    xxxxx decimal 
99ea			;    convert number to 16bit word.  
99ea			;    malloc word + 1 with flag to identiy as num 
99ea			;    put pointer to number on stack 
99ea			;   
99ea			;  
99ea			  
99ea			forth_apush: 
99ea				; kernel push 
99ea			 
99ea			if DEBUG_FORTH_PUSH 
99ea						DMARK "PSH" 
99ea f5				push af  
99eb 3a ff 99			ld a, (.dmark)  
99ee 32 c0 ee			ld (debug_mark),a  
99f1 3a 00 9a			ld a, (.dmark+1)  
99f4 32 c1 ee			ld (debug_mark+1),a  
99f7 3a 01 9a			ld a, (.dmark+2)  
99fa 32 c2 ee			ld (debug_mark+2),a  
99fd 18 03			jr .pastdmark  
99ff ..			.dmark: db "PSH"  
9a02 f1			.pastdmark: pop af  
9a03			endm  
# End of macro DMARK
9a03				CALLMONITOR 
9a03 cd f4 92			call break_point_state  
9a06				endm  
# End of macro CALLMONITOR
9a06			endif	 
9a06				; identify input type 
9a06			 
9a06 7e				ld a,(hl) 
9a07 fe 22			cp '"' 
9a09 28 0a			jr z, .fapstr 
9a0b fe 24			cp '$' 
9a0d ca 35 9a			jp z, .faphex 
9a10 fe 25			cp '%' 
9a12 ca 1d 9a			jp z, .fapbin 
9a15			;	cp 'b' 
9a15			;	jp z, .fabin 
9a15				; else decimal 
9a15			 
9a15				; TODO do decimal conversion 
9a15				; decimal is stored as a 16bit word 
9a15			 
9a15				; by default everything is a string if type is not detected 
9a15			.fapstr: ; 
9a15 fe 22			cp '"' 
9a17 20 01			jr nz, .strnoqu 
9a19 23				inc hl 
9a1a			.strnoqu: 
9a1a c3 ef 98			jp forth_push_str 
9a1d			 
9a1d			 
9a1d			 
9a1d			.fapbin:    ; push a binary string.  
9a1d 11 00 00			ld de, 0   ; hold a 16bit value 
9a20			 
9a20 23			.fapbinshift:	inc hl  
9a21 7e				ld a,(hl) 
9a22 fe 00			cp 0     ; done scanning  
9a24 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a26			 
9a26				; left shift de 
9a26 eb				ex de, hl	 
9a27 29				add hl, hl 
9a28			 
9a28				; is 1 
9a28 fe 31			cp '1' 
9a2a 20 02			jr nz, .binzero 
9a2c cb 4d			bit 1, l 
9a2e			.binzero: 
9a2e eb				ex de, hl	 ; save current de 
9a2f 18 ef			jr .fapbinshift 
9a31			 
9a31			.fapbdone: 
9a31 eb				ex de, hl 
9a32 c3 81 98			jp forth_push_numhl 
9a35			 
9a35			 
9a35			.faphex:   ; hex is always stored as a 16bit word 
9a35				; skip number prefix 
9a35 23				inc hl 
9a36				; turn ascii into number 
9a36 cd 5e 8e			call get_word_hl	; ret 16bit word in hl 
9a39			 
9a39 c3 81 98			jp forth_push_numhl 
9a3c			 
9a3c 00				 nop 
9a3d			 
9a3d			.fabin:   ; TODO bin conversion 
9a3d			 
9a3d			 
9a3d c9				ret 
9a3e			 
9a3e			 
9a3e			; get either a string ptr or a 16bit word from the data stack 
9a3e			 
9a3e			FORTH_DSP: macro 
9a3e				call macro_forth_dsp 
9a3e				endm 
9a3e			 
9a3e			macro_forth_dsp: 
9a3e				; data stack pointer points to current word on tos 
9a3e			 
9a3e 2a 93 ec			ld hl,(cli_data_sp) 
9a41			 
9a41				if DEBUG_FORTH_PUSH 
9a41						DMARK "DSP" 
9a41 f5				push af  
9a42 3a 56 9a			ld a, (.dmark)  
9a45 32 c0 ee			ld (debug_mark),a  
9a48 3a 57 9a			ld a, (.dmark+1)  
9a4b 32 c1 ee			ld (debug_mark+1),a  
9a4e 3a 58 9a			ld a, (.dmark+2)  
9a51 32 c2 ee			ld (debug_mark+2),a  
9a54 18 03			jr .pastdmark  
9a56 ..			.dmark: db "DSP"  
9a59 f1			.pastdmark: pop af  
9a5a			endm  
# End of macro DMARK
9a5a			 
9a5a cd 5e c5				call display_data_sp 
9a5d				;call break_point_state 
9a5d				;rst 030h 
9a5d				CALLMONITOR 
9a5d cd f4 92			call break_point_state  
9a60				endm  
# End of macro CALLMONITOR
9a60				endif 
9a60			 
9a60 c9				ret 
9a61			 
9a61			; return hl to start of value on stack 
9a61			 
9a61			FORTH_DSP_VALUE: macro 
9a61				call macro_forth_dsp_value 
9a61				endm 
9a61			 
9a61			macro_forth_dsp_value: 
9a61			 
9a61				FORTH_DSP 
9a61 cd 3e 9a			call macro_forth_dsp 
9a64				endm 
# End of macro FORTH_DSP
9a64			 
9a64 d5				push de 
9a65			 
9a65 23				inc hl ; skip type 
9a66			 
9a66 5e				ld e, (hl) 
9a67 23				inc hl 
9a68 56				ld d, (hl) 
9a69 eb				ex de,hl  
9a6a			 
9a6a d1				pop de 
9a6b			 
9a6b c9				ret 
9a6c			 
9a6c			; return hl to start of value to second item on stack 
9a6c			 
9a6c			FORTH_DSP_VALUEM1: macro 
9a6c				call macro_forth_dsp_value_m1 
9a6c				endm 
9a6c			 
9a6c			macro_forth_dsp_value_m1: 
9a6c			 
9a6c				FORTH_DSP 
9a6c cd 3e 9a			call macro_forth_dsp 
9a6f				endm 
# End of macro FORTH_DSP
9a6f			 
9a6f 2b				dec hl 
9a70 2b				dec hl 
9a71			;	dec hl 
9a71			 
9a71 d5				push de 
9a72			 
9a72 5e				ld e, (hl) 
9a73 23				inc hl 
9a74 56				ld d, (hl) 
9a75 eb				ex de,hl  
9a76			 
9a76 d1				pop de 
9a77			 
9a77 c9				ret 
9a78			 
9a78				 
9a78			 
9a78			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9a78			 
9a78			FORTH_DSP_POP: macro 
9a78				call macro_forth_dsp_pop 
9a78				endm 
9a78			 
9a78			 
9a78			; get the tos data type 
9a78			 
9a78			FORTH_DSP_TYPE:   macro 
9a78			 
9a78				;FORTH_DSP_VALUE 
9a78				FORTH_DSP 
9a78				 
9a78				; hl points to value 
9a78				; check type 
9a78			 
9a78				ld a,(hl) 
9a78			 
9a78				endm 
9a78			 
9a78			; load the tos value into hl 
9a78			 
9a78			 
9a78			FORTH_DSP_VALUEHL:  macro 
9a78				call macro_dsp_valuehl 
9a78				endm 
9a78			 
9a78			 
9a78			 
9a78			macro_dsp_valuehl: 
9a78				FORTH_DSP_VALUE 
9a78 cd 61 9a			call macro_forth_dsp_value 
9a7b				endm 
# End of macro FORTH_DSP_VALUE
9a7b			 
9a7b				;FORTH_ERR_TOS_NOTNUM 
9a7b			 
9a7b				;inc hl   ; skip type id 
9a7b			 
9a7b			;	push de 
9a7b			; 
9a7b			;	ld e, (hl) 
9a7b			;	inc hl 
9a7b			;	ld d, (hl) 
9a7b			;	ex de,hl  
9a7b			 
9a7b			;	pop de 
9a7b			 
9a7b				if DEBUG_FORTH_PUSH 
9a7b						DMARK "DVL" 
9a7b f5				push af  
9a7c 3a 90 9a			ld a, (.dmark)  
9a7f 32 c0 ee			ld (debug_mark),a  
9a82 3a 91 9a			ld a, (.dmark+1)  
9a85 32 c1 ee			ld (debug_mark+1),a  
9a88 3a 92 9a			ld a, (.dmark+2)  
9a8b 32 c2 ee			ld (debug_mark+2),a  
9a8e 18 03			jr .pastdmark  
9a90 ..			.dmark: db "DVL"  
9a93 f1			.pastdmark: pop af  
9a94			endm  
# End of macro DMARK
9a94				CALLMONITOR 
9a94 cd f4 92			call break_point_state  
9a97				endm  
# End of macro CALLMONITOR
9a97				endif 
9a97 c9				ret 
9a98			 
9a98			forth_apushstrhl:      
9a98				; push of string requires use of cli_origptr 
9a98				; bodge use 
9a98			 
9a98				; get current cli_origptr, save, update with temp pointer  
9a98 ed 5b af ec		ld de, (cli_origptr) 
9a9c 22 af ec			ld (cli_origptr), hl 
9a9f d5				push de 
9aa0 cd ea 99			call forth_apush 
9aa3 d1				pop de 
9aa4 ed 53 af ec		ld (cli_origptr), de 
9aa8 c9			        ret	 
9aa9			 
9aa9			 
9aa9			; increase loop stack pointer and save hl to it 
9aa9				 
9aa9			FORTH_LOOP_NEXT: macro 
9aa9				call macro_forth_loop_next 
9aa9				;nop 
9aa9				endm 
9aa9			 
9aa9			macro_forth_loop_next: 
9aa9				if DEBUG_FORTH_STACK_GUARD 
9aa9 cd c3 d5				call check_stacks 
9aac				endif 
9aac e5				push hl 
9aad d5				push de 
9aae eb				ex de,hl 
9aaf 2a 95 ec			ld hl,(cli_loop_sp) 
9ab2 23				inc hl 
9ab3 23				inc hl 
9ab4					if DEBUG_FORTH_WORDS 
9ab4						DMARK "LNX" 
9ab4 f5				push af  
9ab5 3a c9 9a			ld a, (.dmark)  
9ab8 32 c0 ee			ld (debug_mark),a  
9abb 3a ca 9a			ld a, (.dmark+1)  
9abe 32 c1 ee			ld (debug_mark+1),a  
9ac1 3a cb 9a			ld a, (.dmark+2)  
9ac4 32 c2 ee			ld (debug_mark+2),a  
9ac7 18 03			jr .pastdmark  
9ac9 ..			.dmark: db "LNX"  
9acc f1			.pastdmark: pop af  
9acd			endm  
# End of macro DMARK
9acd						CALLMONITOR 
9acd cd f4 92			call break_point_state  
9ad0				endm  
# End of macro CALLMONITOR
9ad0					endif 
9ad0 22 95 ec			ld (cli_loop_sp),hl 
9ad3 73				ld (hl), e 
9ad4 23				inc hl 
9ad5 72				ld (hl), d 
9ad6 d1				pop de    ; been reversed so save a swap on restore 
9ad7 e1				pop hl 
9ad8				if DEBUG_FORTH_STACK_GUARD 
9ad8 cd c3 d5				call check_stacks 
9adb				endif 
9adb c9				ret 
9adc			 
9adc			; get current ret stack pointer and save to hl  
9adc				 
9adc			FORTH_LOOP_TOS: macro 
9adc				call macro_forth_loop_tos 
9adc				endm 
9adc			 
9adc			macro_forth_loop_tos: 
9adc d5				push de 
9add 2a 95 ec			ld hl,(cli_loop_sp) 
9ae0 5e				ld e, (hl) 
9ae1 23				inc hl 
9ae2 56				ld d, (hl) 
9ae3 eb				ex de, hl 
9ae4 d1				pop de 
9ae5 c9				ret 
9ae6			 
9ae6			; pop loop stack pointer 
9ae6				 
9ae6			FORTH_LOOP_POP: macro 
9ae6				call macro_forth_loop_pop 
9ae6				endm 
9ae6			 
9ae6			 
9ae6			macro_forth_loop_pop: 
9ae6				if DEBUG_FORTH_STACK_GUARD 
9ae6					DMARK "LPP" 
9ae6 f5				push af  
9ae7 3a fb 9a			ld a, (.dmark)  
9aea 32 c0 ee			ld (debug_mark),a  
9aed 3a fc 9a			ld a, (.dmark+1)  
9af0 32 c1 ee			ld (debug_mark+1),a  
9af3 3a fd 9a			ld a, (.dmark+2)  
9af6 32 c2 ee			ld (debug_mark+2),a  
9af9 18 03			jr .pastdmark  
9afb ..			.dmark: db "LPP"  
9afe f1			.pastdmark: pop af  
9aff			endm  
# End of macro DMARK
9aff cd c3 d5				call check_stacks 
9b02					FORTH_CHK_LOOP_UNDER 
9b02 e5				push hl 
9b03 d5				push de 
9b04 2a 95 ec			ld hl,(cli_loop_sp) 
9b07 11 4f eb			ld de, cli_loop_stack 
9b0a cd c5 8a			call cmp16 
9b0d da dd d6			jp c, fault_loop_under 
9b10 d1				pop de 
9b11 e1				pop hl 
9b12				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b12				endif 
9b12 e5				push hl 
9b13 2a 95 ec			ld hl,(cli_loop_sp) 
9b16 2b				dec hl 
9b17 2b				dec hl 
9b18 22 95 ec			ld (cli_loop_sp), hl 
9b1b				; TODO do stack underflow checks 
9b1b e1				pop hl 
9b1c				if DEBUG_FORTH_STACK_GUARD 
9b1c cd c3 d5				call check_stacks 
9b1f					FORTH_CHK_LOOP_UNDER 
9b1f e5				push hl 
9b20 d5				push de 
9b21 2a 95 ec			ld hl,(cli_loop_sp) 
9b24 11 4f eb			ld de, cli_loop_stack 
9b27 cd c5 8a			call cmp16 
9b2a da dd d6			jp c, fault_loop_under 
9b2d d1				pop de 
9b2e e1				pop hl 
9b2f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b2f				endif 
9b2f c9				ret 
9b30			 
9b30			macro_forth_dsp_pop: 
9b30			 
9b30 e5				push hl 
9b31			 
9b31				; release malloc data 
9b31			 
9b31				if DEBUG_FORTH_STACK_GUARD 
9b31 cd c3 d5				call check_stacks 
9b34					FORTH_CHK_DSP_UNDER 
9b34 e5				push hl 
9b35 d5				push de 
9b36 2a 93 ec			ld hl,(cli_data_sp) 
9b39 11 4d ea			ld de, cli_data_stack 
9b3c cd c5 8a			call cmp16 
9b3f da d1 d6			jp c, fault_dsp_under 
9b42 d1				pop de 
9b43 e1				pop hl 
9b44				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b44				endif 
9b44				;ld hl,(cli_data_sp) 
9b44			if DEBUG_FORTH_DOT 
9b44				DMARK "DPP" 
9b44				CALLMONITOR 
9b44			endif	 
9b44			 
9b44			 
9b44			if FORTH_ENABLE_DSPPOPFREE 
9b44			 
9b44				FORTH_DSP 
9b44 cd 3e 9a			call macro_forth_dsp 
9b47				endm 
# End of macro FORTH_DSP
9b47			 
9b47 7e				ld a, (hl) 
9b48 fe 01			cp DS_TYPE_STR 
9b4a 20 07			jr nz, .skippopfree 
9b4c			 
9b4c				FORTH_DSP_VALUEHL 
9b4c cd 78 9a			call macro_dsp_valuehl 
9b4f				endm 
# End of macro FORTH_DSP_VALUEHL
9b4f 00				nop 
9b50			if DEBUG_FORTH_DOT 
9b50				DMARK "DPf" 
9b50				CALLMONITOR 
9b50			endif	 
9b50 cd 38 90			call free 
9b53			.skippopfree: 
9b53				 
9b53			 
9b53			endif 
9b53			 
9b53			if DEBUG_FORTH_DOT_KEY 
9b53				DMARK "DP2" 
9b53				CALLMONITOR 
9b53			endif	 
9b53			 
9b53				; move pointer down 
9b53			 
9b53 2a 93 ec			ld hl,(cli_data_sp) 
9b56 2b				dec hl 
9b57 2b				dec hl 
9b58			; PARSEV5 
9b58 2b				dec hl 
9b59 22 93 ec			ld (cli_data_sp), hl 
9b5c			 
9b5c				if DEBUG_FORTH_STACK_GUARD 
9b5c cd c3 d5				call check_stacks 
9b5f					FORTH_CHK_DSP_UNDER 
9b5f e5				push hl 
9b60 d5				push de 
9b61 2a 93 ec			ld hl,(cli_data_sp) 
9b64 11 4d ea			ld de, cli_data_stack 
9b67 cd c5 8a			call cmp16 
9b6a da d1 d6			jp c, fault_dsp_under 
9b6d d1				pop de 
9b6e e1				pop hl 
9b6f				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b6f				endif 
9b6f			 
9b6f e1				pop hl 
9b70			 
9b70 c9				ret 
9b71			 
9b71			getwordathl: 
9b71				; hl points to an address 
9b71				; load hl with the word at that address 
9b71			 
9b71 d5				push de 
9b72			 
9b72 5e				ld e, (hl) 
9b73 23				inc hl 
9b74 56				ld d, (hl) 
9b75 eb				ex de, hl 
9b76			 
9b76 d1				pop de 
9b77 c9				ret 
9b78			 
9b78			 
9b78			 
9b78			 
9b78			 
9b78			; eof 
9b78			 
# End of file forth_stackopsv5.asm
9b78			endif 
9b78			 
9b78			user_word_eol:  
9b78				; hl contains the pointer to where to create a linked list item from the end 
9b78				; of the user dict to continue on at the system word dict 
9b78				 
9b78				; poke the stub of the word list linked list to repoint to rom words 
9b78			 
9b78				; stub format 
9b78				; db   word id 
9b78				; dw    link to next word 
9b78			        ; db char length of token 
9b78				; db string + 0 term 
9b78				; db exec code....  
9b78			 
9b78 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9b7a 77				ld (hl), a		; word id 
9b7b 23				inc hl 
9b7c			 
9b7c 11 42 9d			ld de, sysdict 
9b7f 73				ld (hl), e		; next word link ie system dict 
9b80 23				inc hl 
9b81 72				ld (hl), d		; next word link ie system dict 
9b82 23				inc hl	 
9b83			 
9b83			;	ld (hl), sysdict		; next word link ie system dict 
9b83			;	inc hl 
9b83			;	inc hl 
9b83			 
9b83			;	inc hl 
9b83			;	inc hl 
9b83			 
9b83 3e 02			ld a, 2			; word length is 0 
9b85 77				ld (hl), a	 
9b86 23				inc hl 
9b87			 
9b87 3e 7e			ld a, '~'			; word length is 0 
9b89 77				ld (hl), a	 
9b8a 23				inc hl 
9b8b 3e 00			ld a, 0			; save empty word 
9b8d 77				ld (hl), a 
9b8e			 
9b8e c9				ret 
9b8f			 
9b8f				 
9b8f			 
9b8f			forthexec_cleanup: 
9b8f				FORTH_RSP_POP 
9b8f cd 49 98			call macro_forth_rsp_pop 
9b92				endm 
# End of macro FORTH_RSP_POP
9b92 c9				ret 
9b93			 
9b93			forth_call_hl: 
9b93				; taking hl 
9b93 e5				push hl 
9b94 c9				ret 
9b95			 
9b95			; this is called to reset Forth system but keep existing uwords etc 
9b95			 
9b95			forth_warmstart: 
9b95				; setup stack over/under flow checks 
9b95				if DEBUG_FORTH_STACK_GUARD 
9b95 cd a9 d5				call chk_stk_init 
9b98				endif 
9b98			 
9b98				; init stack pointers  - * these stacks go upwards *  
9b98 21 51 ec			ld hl, cli_ret_stack 
9b9b 22 97 ec			ld (cli_ret_sp), hl	 
9b9e				; set bottom of stack 
9b9e 3e 00			ld a,0 
9ba0 77				ld (hl),a 
9ba1 23				inc hl 
9ba2 77				ld (hl),a 
9ba3			 
9ba3 21 4d ea			ld hl, cli_data_stack 
9ba6 22 93 ec			ld (cli_data_sp), hl	 
9ba9				; set bottom of stack 
9ba9 3e 00			ld a,0 
9bab 77				ld (hl),a 
9bac 23				inc hl 
9bad 77				ld (hl),a 
9bae			 
9bae 21 4f eb			ld hl, cli_loop_stack 
9bb1 22 95 ec			ld (cli_loop_sp), hl	 
9bb4				; set bottom of stack 
9bb4 3e 00			ld a,0 
9bb6 77				ld (hl),a 
9bb7 23				inc hl 
9bb8 77				ld (hl),a 
9bb9			 
9bb9				; init extent of current open file 
9bb9			 
9bb9 3e 00			ld a, 0 
9bbb 32 e2 ec			ld (store_openext), a 
9bbe			 
9bbe c9				ret 
9bbf			 
9bbf			 
9bbf			; Cold Start - this is called to setup the whole Forth system 
9bbf			 
9bbf			forth_init: 
9bbf			 
9bbf				; setup stack over/under flow checks 
9bbf			 
9bbf			;	if DEBUG_FORTH_STACK_GUARD 
9bbf			;		call chk_stk_init 
9bbf			;	endif 
9bbf			 
9bbf				; enable auto display updates (slow.....) 
9bbf			 
9bbf 3e 01			ld a, 1 
9bc1 32 ad ec			ld (cli_autodisplay), a 
9bc4			 
9bc4			 
9bc4			 
9bc4				; show start up screen 
9bc4			 
9bc4 cd 7a 88			call clear_display 
9bc7			 
9bc7 3e 00			ld a,0 
9bc9 32 cf ec			ld (f_cursor_ptr), a 
9bcc			 
9bcc				; set start of word list in start of ram - for use when creating user words 
9bcc			 
9bcc 21 74 d8			ld hl, baseram 
9bcf 22 e3 e7			ld (os_last_new_uword), hl 
9bd2 cd 78 9b			call user_word_eol 
9bd5				 
9bd5			;		call display_data_sp 
9bd5			;		call next_page_prompt 
9bd5			 
9bd5			 
9bd5			 
9bd5			 
9bd5 c9				ret 
9bd6			 
9bd6 .. 00		.bootforth: db " Forth Kernel Init ",0 
9bea			 
9bea			; TODO push to stack 
9bea			 
9bea			;  
9bea			 
9bea			if FORTH_PARSEV2 
9bea			 
9bea			 
9bea				include "forth_parserv2.asm" 
9bea			 
9bea			endif 
9bea			 
9bea			 
9bea			; parse cli version 1 
9bea			 
9bea			if FORTH_PARSEV1 
9bea			 
9bea			 
9bea			 
9bea			      include "forth_parserv1.asm" 
9bea			endif 
9bea				 
9bea			if FORTH_PARSEV3 
9bea			 
9bea			 
9bea			 
9bea			      include "forth_parserv3.asm" 
9bea				include "forth_wordsv3.asm" 
9bea			endif 
9bea			 
9bea			if FORTH_PARSEV4 
9bea			 
9bea			 
9bea			 
9bea			      include "forth_parserv4.asm" 
9bea				include "forth_wordsv4.asm" 
9bea			endif 
9bea			 
9bea			if FORTH_PARSEV5 
9bea			 
9bea			 
9bea			 
9bea			      include "forth_parserv5.asm" 
9bea			 
9bea			 
9bea			; A better parser without using malloc and string copies all over the place.  
9bea			; Exec in situ should be faster 
9bea			 
9bea			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9bea			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9bea			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9bea			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9bea			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9bea			WORD_SYS_END: equ 0   ; Opcode for all user words 
9bea			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9bea			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9bea			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9bea			 
9bea			; Core word preamble macro 
9bea			 
9bea			CWHEAD:   macro nxtword opcode lit len opflags 
9bea				db WORD_SYS_CORE+opcode             
9bea				; internal op code number 
9bea				dw nxtword            
9bea				; link to next dict word block 
9bea				db len + 1 
9bea				; literal length of dict word inc zero term 
9bea				db lit,0              
9bea				; literal dict word 
9bea			        ; TODO db opflags        
9bea				endm 
9bea			 
9bea			 
9bea			NEXTW: macro  
9bea				jp macro_next 
9bea				endm 
9bea			 
9bea			macro_next: 
9bea			if DEBUG_FORTH_PARSE_KEY 
9bea				DMARK "NXT" 
9bea				CALLMONITOR 
9bea			endif	 
9bea			;	inc hl  ; skip token null term  
9bea ed 4b b1 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9bee ed 5b af ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9bf2 2a e7 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9bf5			if DEBUG_FORTH_PARSE_KEY 
9bf5				DMARK "}AA" 
9bf5				CALLMONITOR 
9bf5			endif	 
9bf5 c3 f8 9c			jp execnext 
9bf8				;jp exec1 
9bf8			       
9bf8			 
9bf8			 
9bf8			; Another go at the parser to compile  
9bf8			 
9bf8			 
9bf8			; TODO rework parser to change all of the string words to byte tokens 
9bf8			; TODO do a search for  
9bf8			 
9bf8			; TODO first run normal parser to zero term sections 
9bf8			; TODO for each word do a token look up to get the op code 
9bf8			; TODO need some means to flag to the exec that this is a byte code form    
9bf8			 
9bf8			 
9bf8			forthcompile: 
9bf8			 
9bf8			; 
9bf8			; line parse: 
9bf8			;       parse raw input buffer 
9bf8			;       tokenise the words 
9bf8			;       malloc new copy (for looping etc) 
9bf8			;       copy to malloc + current pc in line to start of string and add line term 
9bf8			;       save on new rsp 
9bf8			; 
9bf8			 
9bf8			; hl to point to the line to tokenise 
9bf8			 
9bf8			;	push hl 
9bf8 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9bfb			 
9bfb			;	ld a,0		; string term on input 
9bfb			;	call strlent 
9bfb			 
9bfb			;	ld (os_tok_len), hl	 ; save string length 
9bfb			 
9bfb			;if DEBUG_FORTH_TOK 
9bfb			;	ex de,hl		 
9bfb			;endif 
9bfb			 
9bfb			;	pop hl 		; get back string pointer 
9bfb			 
9bfb			if DEBUG_FORTH_TOK 
9bfb						DMARK "TOc" 
9bfb				CALLMONITOR 
9bfb			endif 
9bfb 7e			.cptoken2:    ld a,(hl) 
9bfc 23				inc hl 
9bfd fe 7f			cp FORTH_END_BUFFER 
9bff 28 29			jr z, .cptokendone2 
9c01 fe 00			cp 0 
9c03 28 25			jr z, .cptokendone2 
9c05 fe 22			cp '"' 
9c07 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c09 fe 20			cp ' ' 
9c0b 20 ee			jr nz,  .cptoken2 
9c0d			 
9c0d			; TODO consume comments held between ( and ) 
9c0d			 
9c0d				; we have a space so change to zero term for dict match later 
9c0d 2b				dec hl 
9c0e 3e 00			ld a,0 
9c10 77				ld (hl), a 
9c11 23				inc hl 
9c12 18 e7			jr .cptoken2 
9c14				 
9c14			 
9c14			.cptokenstr2: 
9c14				; skip all white space until either eol (because forgot to term) or end double quote 
9c14			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c14				;inc hl ; skip current double quote 
9c14 7e				ld a,(hl) 
9c15 23				inc hl 
9c16 fe 22			cp '"' 
9c18 28 e1			jr z, .cptoken2 
9c1a fe 7f			cp FORTH_END_BUFFER 
9c1c 28 0c			jr z, .cptokendone2 
9c1e fe 00			cp 0 
9c20 28 08			jr z, .cptokendone2 
9c22 fe 20			cp ' ' 
9c24 28 02			jr z, .cptmp2 
9c26 18 ec			jr .cptokenstr2 
9c28			 
9c28			.cptmp2:	; we have a space so change to zero term for dict match later 
9c28				;dec hl 
9c28				;ld a,"-"	; TODO remove this when working 
9c28				;ld (hl), a 
9c28				;inc hl 
9c28 18 ea			jr .cptokenstr2 
9c2a			 
9c2a			.cptokendone2: 
9c2a				;inc hl 
9c2a 3e 7f			ld a, FORTH_END_BUFFER 
9c2c 77				ld (hl),a 
9c2d 23				inc hl 
9c2e 3e 21			ld a, '!' 
9c30 77				ld (hl),a 
9c31			 
9c31 2a e7 e7			ld hl,(os_tok_ptr) 
9c34			         
9c34			if DEBUG_FORTH_TOK 
9c34						DMARK "Tc1" 
9c34				CALLMONITOR 
9c34			endif 
9c34			 
9c34				; push exec string to top of return stack 
9c34				FORTH_RSP_NEXT 
9c34 cd 28 98			call macro_forth_rsp_next 
9c37				endm 
# End of macro FORTH_RSP_NEXT
9c37 c9				ret 
9c38			 
9c38			; Another go at the parser need to simplify the process 
9c38			 
9c38			forthparse: 
9c38			 
9c38			; 
9c38			; line parse: 
9c38			;       parse raw input buffer 
9c38			;       tokenise the words 
9c38			;       malloc new copy (for looping etc) 
9c38			;       copy to malloc + current pc in line to start of string and add line term 
9c38			;       save on new rsp 
9c38			; 
9c38			 
9c38			; hl to point to the line to tokenise 
9c38			 
9c38			;	push hl 
9c38 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c3b			 
9c3b			;	ld a,0		; string term on input 
9c3b			;	call strlent 
9c3b			 
9c3b			;	ld (os_tok_len), hl	 ; save string length 
9c3b			 
9c3b			;if DEBUG_FORTH_TOK 
9c3b			;	ex de,hl		 
9c3b			;endif 
9c3b			 
9c3b			;	pop hl 		; get back string pointer 
9c3b			 
9c3b			if DEBUG_FORTH_TOK 
9c3b						DMARK "TOK" 
9c3b				CALLMONITOR 
9c3b			endif 
9c3b 7e			.ptoken2:    ld a,(hl) 
9c3c 23				inc hl 
9c3d fe 7f			cp FORTH_END_BUFFER 
9c3f 28 29			jr z, .ptokendone2 
9c41 fe 00			cp 0 
9c43 28 25			jr z, .ptokendone2 
9c45 fe 22			cp '"' 
9c47 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c49 fe 20			cp ' ' 
9c4b 20 ee			jr nz,  .ptoken2 
9c4d			 
9c4d			; TODO consume comments held between ( and ) 
9c4d			 
9c4d				; we have a space so change to zero term for dict match later 
9c4d 2b				dec hl 
9c4e 3e 00			ld a,0 
9c50 77				ld (hl), a 
9c51 23				inc hl 
9c52 18 e7			jr .ptoken2 
9c54				 
9c54			 
9c54			.ptokenstr2: 
9c54				; skip all white space until either eol (because forgot to term) or end double quote 
9c54			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c54				;inc hl ; skip current double quote 
9c54 7e				ld a,(hl) 
9c55 23				inc hl 
9c56 fe 22			cp '"' 
9c58 28 e1			jr z, .ptoken2 
9c5a fe 7f			cp FORTH_END_BUFFER 
9c5c 28 0c			jr z, .ptokendone2 
9c5e fe 00			cp 0 
9c60 28 08			jr z, .ptokendone2 
9c62 fe 20			cp ' ' 
9c64 28 02			jr z, .ptmp2 
9c66 18 ec			jr .ptokenstr2 
9c68			 
9c68			.ptmp2:	; we have a space so change to zero term for dict match later 
9c68				;dec hl 
9c68				;ld a,"-"	; TODO remove this when working 
9c68				;ld (hl), a 
9c68				;inc hl 
9c68 18 ea			jr .ptokenstr2 
9c6a			 
9c6a			.ptokendone2: 
9c6a				;inc hl 
9c6a 3e 7f			ld a, FORTH_END_BUFFER 
9c6c 77				ld (hl),a 
9c6d 23				inc hl 
9c6e 3e 21			ld a, '!' 
9c70 77				ld (hl),a 
9c71			 
9c71 2a e7 e7			ld hl,(os_tok_ptr) 
9c74			         
9c74			if DEBUG_FORTH_TOK 
9c74						DMARK "TK1" 
9c74				CALLMONITOR 
9c74			endif 
9c74			 
9c74				; push exec string to top of return stack 
9c74				FORTH_RSP_NEXT 
9c74 cd 28 98			call macro_forth_rsp_next 
9c77				endm 
# End of macro FORTH_RSP_NEXT
9c77 c9				ret 
9c78			 
9c78			; 
9c78			;	; malloc size + buffer pointer + if is loop flag 
9c78			;	ld hl,(os_tok_len) 		 ; get string length 
9c78			; 
9c78			;	ld a,l 
9c78			; 
9c78			;	cp 0			; we dont want to use a null string 
9c78			;	ret z 
9c78			; 
9c78			;;	add 3    ; prefix malloc with buffer for current word ptr 
9c78			; 
9c78			;	add 5     ; TODO when certain not over writing memory remove 
9c78			; 
9c78			;		 
9c78			; 
9c78			;if DEBUG_FORTH_TOK 
9c78			;			DMARK "TKE" 
9c78			;	CALLMONITOR 
9c78			;endif 
9c78			; 
9c78			;	ld l,a 
9c78			;	ld h,0 
9c78			;;	push hl   ; save required space for the copy later 
9c78			;	call malloc 
9c78			;if DEBUG_FORTH_TOK 
9c78			;			DMARK "TKM" 
9c78			;	CALLMONITOR 
9c78			;endif 
9c78			;	if DEBUG_FORTH_MALLOC_GUARD 
9c78			;		push af 
9c78			;		call ishlzero 
9c78			;;		ld a, l 
9c78			;;		add h 
9c78			;;		cp 0 
9c78			;		pop af 
9c78			;		 
9c78			;		call z,malloc_error 
9c78			;	endif 
9c78			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9c78			; 
9c78			; 
9c78			;if DEBUG_FORTH_TOK 
9c78			;			DMARK "TKR" 
9c78			;	CALLMONITOR 
9c78			;endif 
9c78			; 
9c78			;	FORTH_RSP_NEXT 
9c78			; 
9c78			;	;inc hl	 ; go past current buffer pointer 
9c78			;	;inc hl 
9c78			;	;inc hl   ; and past if loop flag 
9c78			;		; TODO Need to set flag  
9c78			; 
9c78			;	 
9c78			;	 
9c78			;	ex de,hl	; malloc is dest 
9c78			;	ld hl, (os_tok_len) 
9c78			;;	pop bc 
9c78			;	ld c, l                
9c78			;	ld b,0 
9c78			;	ld hl, (os_tok_ptr) 
9c78			; 
9c78			;if DEBUG_FORTH_TOK 
9c78			;			DMARK "TKT" 
9c78			;	CALLMONITOR 
9c78			;endif 
9c78			; 
9c78			;	; do str cpy 
9c78			; 
9c78			;	ldir      ; copy byte in hl to de 
9c78			; 
9c78			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9c78			; 
9c78			;if DEBUG_FORTH_TOK 
9c78			; 
9c78			;			DMARK "TKY" 
9c78			;	CALLMONITOR 
9c78			;endif 
9c78			;	;ld a,0 
9c78			;	;ld a,FORTH_END_BUFFER 
9c78			;	ex de, hl 
9c78			;	;dec hl			 ; go back over the space delim at the end of word 
9c78			;	;ld (hl),a 
9c78			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9c78			;	ld a,FORTH_END_BUFFER 
9c78			;	ld (hl),a 
9c78			;	inc hl 
9c78			;	ld a,FORTH_END_BUFFER 
9c78			;	ld (hl),a 
9c78			; 
9c78			;	; init the malloc area data 
9c78			;	; set pc for in current area 
9c78			;	;ld hl, (os_tok_malloc) 
9c78			;	;inc hl 
9c78			;	;inc hl 
9c78			;	;inc hl 
9c78			;	;ex de,hl 
9c78			;	;ld hl, (os_tok_malloc) 
9c78			;	;ld (hl),e 
9c78			;	;inc hl 
9c78			;	;ld (hl),d 
9c78			; 
9c78			; 
9c78			;	ld hl,(os_tok_malloc) 
9c78			;if DEBUG_FORTH_PARSE_KEY 
9c78			;			DMARK "TKU" 
9c78			;	CALLMONITOR 
9c78			;endif 
9c78			; 
9c78			;	ret 
9c78			 
9c78			forthexec: 
9c78			 
9c78			; line exec: 
9c78			; forth parser 
9c78			 
9c78			; 
9c78			;       get current exec line on rsp 
9c78			 
9c78				FORTH_RSP_TOS 
9c78 cd 3f 98			call macro_forth_rsp_tos 
9c7b				endm 
# End of macro FORTH_RSP_TOS
9c7b			 
9c7b			;       restore current pc - hl points to malloc of data 
9c7b			 
9c7b				;ld e, (hl) 
9c7b				;inc hl 
9c7b				;ld d, (hl) 
9c7b				;ex de,hl 
9c7b			 
9c7b			 
9c7b			exec1: 
9c7b 22 e7 e7			ld (os_tok_ptr), hl 
9c7e			 
9c7e				; copy our PC to working vars  
9c7e 22 b1 ec			ld (cli_ptr), hl 
9c81 22 af ec			ld (cli_origptr), hl 
9c84			 
9c84 7e				ld a,(hl) 
9c85 fe 7f			cp FORTH_END_BUFFER 
9c87 c8				ret z 
9c88			 
9c88				; skip any nulls 
9c88			 
9c88 fe 00			cp 0 
9c8a 20 03			jr nz, .execword 
9c8c 23				inc hl 
9c8d 18 ec			jr exec1 
9c8f			 
9c8f			 
9c8f			.execword: 
9c8f			 
9c8f			 
9c8f			 
9c8f			if DEBUG_FORTH_PARSE_KEY 
9c8f						DMARK "KYQ" 
9c8f				CALLMONITOR 
9c8f			endif 
9c8f			;       while at start of word: 
9c8f			; get start of dict (in user area first) 
9c8f			 
9c8f 21 74 d8		ld hl, baseram 
9c92			;ld hl, sysdict 
9c92 22 b3 ec		ld (cli_nextword),hl 
9c95			;           match word at pc 
9c95			;           exec word 
9c95			;           or push to dsp 
9c95			;           forward to next token 
9c95			;           if line term pop rsp and exit 
9c95			;        
9c95			 
9c95			if DEBUG_FORTH_PARSE_KEY 
9c95						DMARK "KYq" 
9c95				CALLMONITOR 
9c95			endif 
9c95			 
9c95			; 
9c95			; word comp 
9c95			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9c95			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9c95			;    move to start of word  
9c95			;    compare word to cli_token 
9c95			 
9c95			.execpnword:	; HL at start of a word in the dictionary to check 
9c95			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9c95			;	ld (cli_ptr), hl 
9c95			 
9c95 2a b3 ec			ld hl,(cli_nextword) 
9c98			 
9c98 cd 3b 9d			call forth_tok_next 
9c9b			; tok next start here 
9c9b			;	; TODO skip compiled symbol for now 
9c9b			;	inc hl 
9c9b			; 
9c9b			;	; save pointer to next word 
9c9b			; 
9c9b			;	; hl now points to the address of the next word pointer  
9c9b			;	ld e, (hl) 
9c9b			;	inc hl 
9c9b			;	ld d, (hl) 
9c9b			;	inc l 
9c9b			; 
9c9b			;	ex de,hl 
9c9b			;if DEBUG_FORTH_PARSE_NEXTWORD 
9c9b			;	push bc 
9c9b			;	ld bc, (cli_nextword) 
9c9b			;			DMARK "NXW" 
9c9b			;	CALLMONITOR 
9c9b			;	pop bc 
9c9b			;endif 
9c9b			; tok next end here 
9c9b 22 b3 ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9c9e eb				ex de, hl 
9c9f			 
9c9f			 
9c9f				; save the pointer of the current token - 1 to check against 
9c9f				 
9c9f 22 b7 ec			ld (cli_token), hl   
9ca2				; TODO maybe remove below save if no debug 
9ca2				; save token string ptr for any debug later 
9ca2 23				inc hl  
9ca3 22 b9 ec			ld (cli_origtoken), hl 
9ca6 2b				dec hl 
9ca7				; save pointer to the start of the next dictionay word 
9ca7 7e				ld a,(hl)   ; get string length 
9ca8 47				ld b,a 
9ca9			.execpnwordinc:  
9ca9 23				inc hl 
9caa 10 fd			djnz .execpnwordinc 
9cac 22 b5 ec			ld (cli_execword), hl      ; save start of this words code 
9caf			 
9caf				; now check the word token against the string being parsed 
9caf			 
9caf 2a b7 ec			ld hl,(cli_token) 
9cb2 23				inc hl     ; skip string length (use zero term instead to end) 
9cb3 22 b7 ec			ld (cli_token), hl 
9cb6			 
9cb6			if DEBUG_FORTH_PARSE_KEY 
9cb6						DMARK "KY2" 
9cb6			endif 
9cb6			if DEBUG_FORTH_PARSE_EXEC 
9cb6				; see if disabled 
9cb6			 
9cb6				ld a, (os_view_disable) 
9cb6				cp '*' 
9cb6				jr z, .skip 
9cb6			 
9cb6				push hl 
9cb6				push hl 
9cb6				call clear_display 
9cb6				ld de, .compword 
9cb6				ld a, display_row_1 
9cb6				call str_at_display 
9cb6				pop de 
9cb6				ld a, display_row_2 
9cb6				call str_at_display 
9cb6				ld hl,(cli_ptr) 
9cb6				ld a,(hl) 
9cb6			        ld hl, os_word_scratch 
9cb6				ld (hl),a 
9cb6				ld a,0 
9cb6				inc hl 
9cb6				ld (hl),a 	 
9cb6				ld de, os_word_scratch 
9cb6				ld a, display_row_2+10 
9cb6				call str_at_display 
9cb6				call update_display 
9cb6				ld a, 100 
9cb6				call aDelayInMS 
9cb6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cb6				call delay250ms 
9cb6				endif 
9cb6				pop hl 
9cb6			.skip:  
9cb6			endif	 
9cb6			.execpnchar:    ; compare char between token and string to parse 
9cb6			 
9cb6			if DEBUG_FORTH_PARSE_KEY 
9cb6						DMARK "Ky3" 
9cb6			endif 
9cb6			if DEBUG_FORTH_PARSE_EXEC 
9cb6				; see if disabled 
9cb6			 
9cb6				ld a, (os_view_disable) 
9cb6				cp '*' 
9cb6				jr z, .skip2 
9cb6			 
9cb6			;	call clear_display 
9cb6			ld hl,(cli_token) 
9cb6			ld a,(hl) 
9cb6			ld (os_word_scratch),a 
9cb6				ld hl,(cli_ptr) 
9cb6			ld a,(hl) 
9cb6				ld (os_word_scratch+1),a 
9cb6				ld a,0 
9cb6				ld (os_word_scratch+2),a 
9cb6				ld de,os_word_scratch 
9cb6				ld a,display_row_4 
9cb6				call str_at_display 
9cb6				call update_display 
9cb6			.skip2:  
9cb6			endif 
9cb6 2a b7 ec			ld hl,(cli_token) 
9cb9 7e				ld a, (hl)	 ; char in word token 
9cba 23				inc hl 		; move to next char 
9cbb 22 b7 ec			ld (cli_token), hl ; and save it 
9cbe 47				ld b,a 
9cbf			 
9cbf 2a b1 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9cc2 7e				ld a,(hl) 
9cc3 23				inc hl 
9cc4 22 b1 ec			ld (cli_ptr), hl		; move to next char 
9cc7 cd fc 8e			call toUpper 		; make sure the input string matches case 
9cca			 
9cca			if DEBUG_FORTH_PARSE 
9cca			endif 
9cca			 
9cca				; input stream end of token is a space so get rid of it 
9cca			 
9cca			;	cp ' ' 
9cca			;	jr nz, .pnskipspace 
9cca			; 
9cca			;	ld a, 0		; make same term as word token term 
9cca			; 
9cca			;.pnskipspace: 
9cca			 
9cca			if DEBUG_FORTH_PARSE_KEY 
9cca						DMARK "KY7" 
9cca			endif 
9cca b8				cp b 
9ccb c2 e1 9c			jp nz, .execpnskipword	 ; no match so move to next word 
9cce				 
9cce			;    if same 
9cce			;       scan for string terms 0 for token and 32 for input 
9cce			 
9cce				 
9cce			if DEBUG_FORTH_PARSE_KEY 
9cce						DMARK "KY8" 
9cce			endif 
9cce			 
9cce 80				add b			 
9ccf fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9cd1							; TODO need to make sure last word in zero term string is accounted for 
9cd1 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9cd3			 
9cd3			 
9cd3				; at end of both strings so both are exact match 
9cd3			 
9cd3			;       skip ptr for next word 
9cd3			 
9cd3 2a b1 ec			ld hl,(cli_ptr) 	; at input string term 
9cd6 23				inc hl			 ; at next char 
9cd7 22 b1 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9cda 22 af ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9cdd				 
9cdd				 
9cdd			if DEBUG_FORTH_PARSE_KEY 
9cdd						DMARK "KY3" 
9cdd			endif 
9cdd			 
9cdd			 
9cdd			 
9cdd			;       exec code block 
9cdd			if DEBUG_FORTH_JP 
9cdd				call clear_display 
9cdd				call update_display 
9cdd				call delay1s 
9cdd				ld hl, (cli_execword)     ; save for next check if no match on this word 
9cdd				ld a,h 
9cdd				ld hl, os_word_scratch 
9cdd				call hexout 
9cdd				ld hl, (cli_execword)     ; save for next check if no match on this word 
9cdd				ld a,l 
9cdd				ld hl, os_word_scratch+2 
9cdd				call hexout 
9cdd				ld hl, os_word_scratch+4 
9cdd				ld a,0 
9cdd				ld (hl),a 
9cdd				ld de,os_word_scratch 
9cdd				call str_at_display 
9cdd					ld a, display_row_2 
9cdd					call str_at_display 
9cdd				ld de, (cli_origtoken) 
9cdd				ld a, display_row_1+10 
9cdd					call str_at_display 
9cdd			 
9cdd				ld a,display_row_1 
9cdd				ld de, .foundword 
9cdd				ld a, display_row_3 
9cdd				call str_at_display 
9cdd				call update_display 
9cdd				call delay1s 
9cdd				call delay1s 
9cdd				call delay1s 
9cdd			endif 
9cdd			 
9cdd			if DEBUG_FORTH_PARSE_KEY 
9cdd						DMARK "KYj" 
9cdd			endif 
9cdd				; TODO save the word pointer in this exec 
9cdd			 
9cdd 2a b5 ec			ld hl,(cli_execword) 
9ce0 e9				jp (hl) 
9ce1			 
9ce1			 
9ce1			;    if not same 
9ce1			;	scan for zero term 
9ce1			;	get ptr for next word 
9ce1			;	goto word comp 
9ce1			 
9ce1			.execpnskipword:	; get pointer to next word 
9ce1 2a b3 ec			ld hl,(cli_nextword) 
9ce4			 
9ce4 7e				ld a,(hl) 
9ce5 fe 00			cp WORD_SYS_END 
9ce7			;	cp 0 
9ce7 28 09			jr z, .execendofdict			 ; at end of words 
9ce9			 
9ce9			if DEBUG_FORTH_PARSE_KEY 
9ce9						DMARK "KY4" 
9ce9			endif 
9ce9			if DEBUG_FORTH_PARSE_EXEC 
9ce9			 
9ce9				; see if disabled 
9ce9			 
9ce9				ld a, (os_view_disable) 
9ce9				cp '*' 
9ce9				jr z, .noskip 
9ce9			 
9ce9			 
9ce9				ld de, .nowordfound 
9ce9				ld a, display_row_3 
9ce9				call str_at_display 
9ce9				call update_display 
9ce9				ld a, 100 
9ce9				call aDelayInMS 
9ce9				 
9ce9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ce9					call delay250ms 
9ce9				endif 
9ce9			.noskip:  
9ce9			 
9ce9			endif	 
9ce9			 
9ce9 2a af ec			ld hl,(cli_origptr) 
9cec 22 b1 ec			ld (cli_ptr),hl 
9cef			 
9cef			if DEBUG_FORTH_PARSE_KEY 
9cef						DMARK "KY5" 
9cef			endif 
9cef c3 95 9c			jp .execpnword			; else go to next word 
9cf2			 
9cf2			.execendofdict:  
9cf2			 
9cf2			if DEBUG_FORTH_PARSE_KEY 
9cf2						DMARK "KYe" 
9cf2			endif 
9cf2			if DEBUG_FORTH_PARSE_EXEC 
9cf2				; see if disabled 
9cf2			 
9cf2				ld a, (os_view_disable) 
9cf2				cp '*' 
9cf2				jr z, .ispskip 
9cf2			 
9cf2				call clear_display 
9cf2				call update_display 
9cf2				call delay1s 
9cf2				ld de, (cli_origptr) 
9cf2				ld a, display_row_1 
9cf2				call str_at_display 
9cf2				 
9cf2				ld de, .enddict 
9cf2				ld a, display_row_3 
9cf2				call str_at_display 
9cf2				call update_display 
9cf2				ld a, 100 
9cf2				call aDelayInMS 
9cf2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cf2				call delay1s 
9cf2				call delay1s 
9cf2				call delay1s 
9cf2				endif 
9cf2			.ispskip:  
9cf2				 
9cf2			endif	 
9cf2			 
9cf2			 
9cf2			 
9cf2				; if the word is not a keyword then must be a literal so push it to stack 
9cf2			 
9cf2			; push token to stack to end of word 
9cf2			 
9cf2				STACKFRAME ON $1efe $2f9f 
9cf2				if DEBUG_STACK_IMB 
9cf2					if ON 
9cf2						exx 
9cf2						ld de, $1efe 
9cf2						ld a, d 
9cf2						ld hl, curframe 
9cf2						call hexout 
9cf2						ld a, e 
9cf2						ld hl, curframe+2 
9cf2						call hexout 
9cf2						ld hl, $1efe 
9cf2						push hl 
9cf2						ld hl, $2f9f 
9cf2						push hl 
9cf2						exx 
9cf2					endif 
9cf2				endif 
9cf2			endm 
# End of macro STACKFRAME
9cf2			 
9cf2 2a e7 e7		ld hl,(os_tok_ptr) 
9cf5 cd ea 99		call forth_apush 
9cf8			 
9cf8				STACKFRAMECHK ON $1efe $2f9f 
9cf8				if DEBUG_STACK_IMB 
9cf8					if ON 
9cf8						exx 
9cf8						ld hl, $2f9f 
9cf8						pop de   ; $2f9f 
9cf8						call cmp16 
9cf8						jr nz, .spnosame 
9cf8						ld hl, $1efe 
9cf8						pop de   ; $1efe 
9cf8						call cmp16 
9cf8						jr z, .spfrsame 
9cf8						.spnosame: call showsperror 
9cf8						.spfrsame: nop 
9cf8						exx 
9cf8					endif 
9cf8				endif 
9cf8			endm 
# End of macro STACKFRAMECHK
9cf8			 
9cf8			execnext: 
9cf8			 
9cf8			if DEBUG_FORTH_PARSE_KEY 
9cf8						DMARK "KY>" 
9cf8			endif 
9cf8			; move past token to next word 
9cf8			 
9cf8 2a e7 e7		ld hl, (os_tok_ptr) 
9cfb 3e 00		ld a, 0 
9cfd 01 ff 00		ld bc, 255     ; input buffer size 
9d00 ed b1		cpir 
9d02			 
9d02			if DEBUG_FORTH_PARSE_KEY 
9d02						DMARK "KY!" 
9d02				CALLMONITOR 
9d02			endif	 
9d02			; TODO this might place hl on the null, so will need to forward on??? 
9d02			;inc hl   ; see if this gets onto the next item 
9d02			 
9d02			 
9d02			; TODO pass a pointer to the buffer to push 
9d02			; TODO call function to push 
9d02			 
9d02			; look for end of input 
9d02			 
9d02			;inc hl 
9d02			;ld a,(hl) 
9d02			;cp FORTH_END_BUFFER 
9d02			;ret z 
9d02			 
9d02			 
9d02 c3 7b 9c		jp exec1 
9d05			 
9d05			 
9d05			 
9d05			 
9d05			 
9d05			 
9d05			 
9d05			 
9d05			 
9d05			findnexttok: 
9d05			 
9d05				; hl is pointer to move 
9d05				; de is the token to locate 
9d05			 
9d05					if DEBUG_FORTH 
9d05						DMARK "NTK" 
9d05						CALLMONITOR 
9d05					endif 
9d05 d5				push de 
9d06			 
9d06			.fnt1:	 
9d06				; find first char of token to locate 
9d06			 
9d06 1a				ld a, (de) 
9d07 4f				ld c,a 
9d08 7e				ld a,(hl) 
9d09 cd fc 8e			call toUpper 
9d0c					if DEBUG_FORTH 
9d0c						DMARK "NT1" 
9d0c						CALLMONITOR 
9d0c					endif 
9d0c b9				cp c 
9d0d			 
9d0d 28 03			jr z, .fnt2cmpmorefirst	 
9d0f			 
9d0f				; first char not found move to next char 
9d0f			 
9d0f 23				inc hl 
9d10 18 f4			jr .fnt1 
9d12			 
9d12			.fnt2cmpmorefirst:	 
9d12				; first char of token found.  
9d12			 
9d12 e5				push hl     ; save start of token just in case it is the right one 
9d13 d9				exx 
9d14 e1				pop hl        ; save it to hl' 
9d15 d9				exx 
9d16			 
9d16			 
9d16			.fnt2cmpmore:	 
9d16				; compare the rest 
9d16				 
9d16 23				inc hl 
9d17 13				inc de 
9d18				 
9d18 1a				ld a, (de) 
9d19 4f				ld c,a 
9d1a 7e				ld a,(hl) 
9d1b cd fc 8e			call toUpper 
9d1e			 
9d1e					if DEBUG_FORTH 
9d1e						DMARK "NT2" 
9d1e						CALLMONITOR 
9d1e					endif 
9d1e				; c has the token to find char 
9d1e				; a has the mem to scan char 
9d1e			 
9d1e b9				cp c 
9d1f 28 04			jr z,.fntmatch1 
9d21			 
9d21				; they are not the same 
9d21			 
9d21					if DEBUG_FORTH 
9d21						DMARK "NT3" 
9d21						CALLMONITOR 
9d21					endif 
9d21 d1				pop de	; reset de token to look for 
9d22 d5				push de 
9d23 18 e1			jr .fnt1 
9d25				 
9d25			.fntmatch1: 
9d25			 
9d25				; is the same char a null which means we might have a full hit? 
9d25					if DEBUG_FORTH 
9d25						DMARK "NT4" 
9d25						CALLMONITOR 
9d25					endif 
9d25			 
9d25 fe 00			cp 0 
9d27 28 0b			jr z, .fntmatchyes 
9d29			 
9d29				; are we at the end of the token to find? 
9d29			 
9d29					if DEBUG_FORTH 
9d29						DMARK "NT5" 
9d29						CALLMONITOR 
9d29					endif 
9d29 3e 00			ld a, 0 
9d2b b9				cp c 
9d2c			 
9d2c c2 16 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d2f			 
9d2f					if DEBUG_FORTH 
9d2f						DMARK "NT6" 
9d2f						CALLMONITOR 
9d2f					endif 
9d2f				; token to find is exhusted but no match to stream 
9d2f			 
9d2f				; restore tok pointer and continue on 
9d2f d1				pop de 
9d30 d5				push de 
9d31 c3 06 9d			jp .fnt1 
9d34			 
9d34			 
9d34			.fntmatchyes: 
9d34			 
9d34				; hl now contains the end of the found token 
9d34			 
9d34				; get rid of saved token pointer to find 
9d34			 
9d34 d1				pop de 
9d35			 
9d35					if DEBUG_FORTH 
9d35						DMARK "NT9" 
9d35						CALLMONITOR 
9d35					endif 
9d35			 
9d35				; hl will be on the null term so forward on 
9d35			 
9d35				; get back the saved start of the token 
9d35			 
9d35 d9				exx 
9d36 e5				push hl     ; save start of token just in case it is the right one 
9d37 d9				exx 
9d38 e1				pop hl        ; save it to hl 
9d39			 
9d39 c9				ret 
9d3a			 
9d3a			 
9d3a			; LIST needs to find a specific token   
9d3a			; FORGET needs to find a spefici token 
9d3a			 
9d3a			; SAVE needs to find all tokens by flag 
9d3a			; WORDS just needs to scan through all  by flag 
9d3a			; UWORDS needs to scan through all by flag 
9d3a			 
9d3a			 
9d3a			; given hl as pointer to start of dict look up string 
9d3a			; return hl as pointer to start of word block 
9d3a			; or 0 if not found 
9d3a			 
9d3a			forth_find_tok: 
9d3a c9				ret 
9d3b			 
9d3b			; given hl as pointer to dict structure 
9d3b			; move to the next dict block structure 
9d3b			 
9d3b			forth_tok_next: 
9d3b				; hl now points to the address of the next word pointer  
9d3b				; TODO skip compiled symbol for now 
9d3b			;	push de 
9d3b 23				inc hl 
9d3c 5e				ld e, (hl) 
9d3d 23				inc hl 
9d3e 56				ld d, (hl) 
9d3f 23				inc hl 
9d40			 
9d40 eb				ex de,hl 
9d41			if DEBUG_FORTH_PARSE_NEXTWORD 
9d41				push bc 
9d41				ld bc, (cli_nextword) 
9d41						DMARK "NXW" 
9d41				CALLMONITOR 
9d41				pop bc 
9d41			endif 
9d41			;	pop de	 
9d41 c9				ret 
9d42			 
9d42			 
9d42			 
9d42			; eof 
# End of file forth_parserv5.asm
9d42				include "forth_wordsv4.asm" 
9d42			 
9d42			; the core word dictionary v4 
9d42			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9d42			 
9d42			; this is a linked list for each of the system words used 
9d42			; user defined words will follow the same format but will be in ram 
9d42			 
9d42			 
9d42			; 
9d42			; 
9d42			; define linked list: 
9d42			; 
9d42			; 1. compiled byte op code 
9d42			; 2. len of text word 
9d42			; 3. text word 
9d42			; 4. ptr to next dictionary word 
9d42			; 5. asm, calls etc for the word 
9d42			; 
9d42			;  if 1 == 0 then last word in dict  
9d42			;   
9d42			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9d42			;  
9d42			;  
9d42			; create basic standard set of words 
9d42			; 
9d42			;  
9d42			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9d42			; 2DUP 2DROP 2SWAP  
9d42			; @ C@ - get byte  
9d42			; ! C! - store byte 
9d42			; 0< true if less than zero 
9d42			; 0= true if zero 
9d42			; < >  
9d42			; = true if same 
9d42			; variables 
9d42			 
9d42			 
9d42			; Hardware specific words I may need 
9d42			; 
9d42			; IN OUT  
9d42			; calls to key util functions 
9d42			; calls to hardward abstraction stuff 
9d42			; easy control of frame buffers and lcd i/o 
9d42			; keyboard  
9d42			 
9d42			 
9d42			;DICT: macro 
9d42			; op_code, len, word, next 
9d42			;    word: 
9d42			;    db op_code 
9d42			;    ds word zero term 
9d42			;    dw next 
9d42			;    endm 
9d42			 
9d42			 
9d42			 
9d42			 
9d42			; op code 1 is a flag for user define words which are to be handled differently 
9d42			 
9d42			 
9d42			; 
9d42			; 
9d42			;    TODO on entry to a word this should be the expected environment 
9d42			;    hl - tos value if number then held, if string this is the ptr 
9d42			;    de -  
9d42			 
9d42			 
9d42			; opcode ranges 
9d42			; 0 - end of word dict 
9d42			; 255 - user define words 
9d42			 
9d42			sysdict: 
9d42			include "forth_opcodes.asm" 
9d42			; op codes for forth keywords 
9d42			; free to use code 0  
9d42				OPCODE_HEAP: equ  1 
9d42				OPCODE_EXEC: equ 2 
9d42				OPCODE_DUP: equ 3 
9d42				OPCODE_SWAP: equ 4 
9d42				OPCODE_COLN: equ 5 
9d42				OPCODE_SCOLN: equ 6 
9d42				OPCODE_DROP: equ 7 
9d42				OPCODE_DUP2: equ 8 
9d42				OPCODE_DROP2: equ 9 
9d42				OPCODE_SWAP2: equ 10 
9d42				OPCODE_AT: equ 11 
9d42				OPCODE_CAT: equ 12 
9d42				OPCODE_BANG: equ 13 
9d42				OPCODE_CBANG: equ 14 
9d42				OPCODE_SCALL: equ 15 
9d42				OPCODE_DEPTH: equ 16 
9d42				OPCODE_OVER: equ 17 
9d42				OPCODE_PAUSE: equ 18 
9d42				OPCODE_PAUSES: equ 19 
9d42				OPCODE_ROT: equ 20 
9d42			;free to reuse	OPCODE_WORDS: equ 21 
9d42			        OPCODE_NOT: equ 21 
9d42				OPCODE_UWORDS: equ 22 
9d42				OPCODE_BP: equ 23 
9d42				OPCODE_MONITOR: equ 24  
9d42				OPCODE_MALLOC: equ 25 
9d42				OPCODE_FREE: equ 26 
9d42				OPCODE_LIST: equ 27 
9d42				OPCODE_FORGET: equ 28 
9d42				OPCODE_NOP: equ 29 
9d42				OPCODE_COMO: equ 30 
9d42				OPCODE_COMC: equ 31 
9d42			;free to reuse	OPCODE_ENDCORE: equ 32 
9d42				OPCODE_AFTERSOUND: equ 33 
9d42				OPCODE_GP2: equ 34 
9d42				OPCODE_GP3: equ 35 
9d42				OPCODE_GP4: equ 36 
9d42				OPCODE_SIN: equ 37 
9d42				OPCODE_SOUT: equ 38 
9d42				OPCODE_SPIO: equ 39 
9d42				OPCODE_SPICEH: equ 40 
9d42				OPCODE_SPIOb: equ 41 
9d42				OPCODE_SPII: equ 42 
9d42				OPCODE_SESEL: equ 43 
9d42				OPCODE_CARTDEV: equ 44 
9d42			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9d42				OPCODE_FB: equ 46 
9d42				OPCODE_EMIT: equ 47 
9d42				OPCODE_DOTH: equ 48 
9d42				OPCODE_DOTF: equ 49 
9d42				OPCODE_DOT: equ 50 
9d42				OPCODE_CLS: equ 51 
9d42				OPCODE_DRAW: equ 52 
9d42				OPCODE_DUMP: equ 53 
9d42				OPCODE_CDUMP: equ 54 
9d42				OPCODE_DAT: equ 55 
9d42				OPCODE_HOME: equ 56 
9d42				OPCODE_SPACE: equ 57 
9d42				OPCODE_SPACES: equ 58 
9d42				OPCODE_SCROLL: equ 59 
9d42				OPCODE_ATQ: equ 60 
9d42				OPCODE_AUTODSP: equ 61 
9d42				OPCODE_MENU: equ 62 
9d42			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9d42				OPCODE_THEN: equ 64 
9d42				OPCODE_ELSE: equ 65 
9d42				OPCODE_DO: equ 66 
9d42				OPCODE_LOOP: equ 67 
9d42				OPCODE_I: equ 68 
9d42				OPCODE_DLOOP: equ 69  
9d42				OPCODE_REPEAT: equ 70  
9d42				OPCODE_UNTIL: equ 71 
9d42				OPCODE_ENDFLOW: equ 72 
9d42				OPCODE_WAITK: equ 73 
9d42				OPCODE_ACCEPT: equ 74 
9d42				OPCODE_EDIT: equ 75 
9d42			;free to reuse	OPCODE_ENDKEY: equ 76 
9d42				OPCODE_LZERO: equ 77 
9d42				OPCODE_TZERO: equ 78 
9d42				OPCODE_LESS: equ 79 
9d42				OPCODE_GT: equ 80 
9d42				OPCODE_EQUAL: equ 81  
9d42			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9d42				OPCODE_NEG: equ 83 
9d42				OPCODE_DIV: equ 84 
9d42				OPCODE_MUL: equ 85 
9d42				OPCODE_MIN: equ 86 
9d42				OPCODE_MAX: equ 87 
9d42				OPCODE_RND16: equ 88 
9d42				OPCODE_RND8: equ 89 
9d42				OPCODE_RND: equ 90 
9d42			;free to reuse	OPCODE_ENDMATHS: equ 91  
9d42				OPCODE_BYNAME: equ 92 
9d42				OPCODE_DIR: equ 93 
9d42				OPCODE_SAVE: equ 94 
9d42				OPCODE_LOAD: equ 95 
9d42				OPCODE_BSAVE: equ 96 
9d42				OPCODE_BLOAD: equ 97 
9d42				OPCODE_SEO: equ 98  
9d42				OPCODE_SEI: equ 99 
9d42				OPCODE_SFREE: equ 100 
9d42				OPCODE_SIZE: equ 101 
9d42				OPCODE_CREATE: equ 102 
9d42				OPCODE_APPEND: equ 103 
9d42				OPCODE_SDEL: equ 104 
9d42				OPCODE_OPEN: equ 105 
9d42				OPCODE_READ: equ 106 
9d42				OPCODE_EOF: equ 106 
9d42				OPCODE_FORMAT: equ 107 
9d42				OPCODE_LABEL: equ 108 
9d42				OPCODE_LABELS: equ 109 
9d42			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9d42				OPCODE_UPPER: equ 111 
9d42				OPCODE_LOWER: equ 112 
9d42				OPCODE_SUBSTR: equ 113 
9d42				OPCODE_LEFT: equ 114 
9d42				OPCODE_RIGHT: equ 115 
9d42				OPCODE_STR2NUM: equ 116 
9d42				OPCODE_NUM2STR: equ 117 
9d42				OPCODE_CONCAT: equ 118 
9d42				OPCODE_FIND: equ 119 
9d42				OPCODE_LEN: equ 120 
9d42				OPCODE_CHAR: equ 121 
9d42			; free to reuse	OPCODE_STRLEN: equ 122 
9d42			; free to reuse	OPCODE_ENDSTR: equ 123 
9d42				OPCODE_V0S: equ 124 
9d42				OPCODE_V0Q: equ 125 
9d42				OPCODE_V1S: equ 126 
9d42				OPCODE_V1Q: equ 127 
9d42				OPCODE_V2S: equ 128 
9d42				OPCODE_V2Q: equ 129 
9d42				OPCODE_V3S: equ 130 
9d42				OPCODE_V3Q: equ 131 
9d42			;free to reuse	OPCODE_END: equ 132 
9d42				OPCODE_ZDUP: equ 133 
9d42			 
9d42			; eof 
# End of file forth_opcodes.asm
9d42			 
9d42			include "forth_words_core.asm" 
9d42			 
9d42			; | ## Core Words 
9d42			 
9d42			;if MALLOC_4 
9d42			 
9d42			.HEAP: 
9d42				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9d42 15				db WORD_SYS_CORE+OPCODE_HEAP             
9d43 81 9d			dw .EXEC            
9d45 05				db 4 + 1 
9d46 .. 00			db "HEAP",0              
9d4b				endm 
# End of macro CWHEAD
9d4b			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d4b			; | | u1 - Current number of bytes in the heap 
9d4b			; | | u2 - Remaining bytes left on the heap 
9d4b			; | |  
9d4b			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d4b			 
9d4b			 
9d4b					if DEBUG_FORTH_WORDS_KEY 
9d4b						DMARK "HEP" 
9d4b f5				push af  
9d4c 3a 60 9d			ld a, (.dmark)  
9d4f 32 c0 ee			ld (debug_mark),a  
9d52 3a 61 9d			ld a, (.dmark+1)  
9d55 32 c1 ee			ld (debug_mark+1),a  
9d58 3a 62 9d			ld a, (.dmark+2)  
9d5b 32 c2 ee			ld (debug_mark+2),a  
9d5e 18 03			jr .pastdmark  
9d60 ..			.dmark: db "HEP"  
9d63 f1			.pastdmark: pop af  
9d64			endm  
# End of macro DMARK
9d64						CALLMONITOR 
9d64 cd f4 92			call break_point_state  
9d67				endm  
# End of macro CALLMONITOR
9d67					endif 
9d67 2a 7e d8				ld hl, (free_list )      
9d6a 11 83 d8				ld de, heap_start 
9d6d			 
9d6d ed 52				sbc hl, de  
9d6f			 
9d6f cd 81 98				call forth_push_numhl 
9d72			 
9d72			 
9d72 ed 5b 7e d8			ld de, (free_list )      
9d76 21 cc e4				ld hl, heap_end 
9d79			 
9d79 ed 52				sbc hl, de 
9d7b			 
9d7b cd 81 98				call forth_push_numhl 
9d7e					 
9d7e			 
9d7e					 
9d7e			 
9d7e			 
9d7e			 
9d7e					NEXTW 
9d7e c3 ea 9b			jp macro_next 
9d81				endm 
# End of macro NEXTW
9d81			;endif 
9d81			 
9d81			.EXEC: 
9d81				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9d81 16				db WORD_SYS_CORE+OPCODE_EXEC             
9d82 1d 9e			dw .STKEXEC            
9d84 05				db 4 + 1 
9d85 .. 00			db "EXEC",0              
9d8a				endm 
# End of macro CWHEAD
9d8a			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
9d8a			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9d8a			; | | 
9d8a			; | |   
9d8a				STACKFRAME OFF $5efe $5f9f 
9d8a				if DEBUG_STACK_IMB 
9d8a					if OFF 
9d8a						exx 
9d8a						ld de, $5efe 
9d8a						ld a, d 
9d8a						ld hl, curframe 
9d8a						call hexout 
9d8a						ld a, e 
9d8a						ld hl, curframe+2 
9d8a						call hexout 
9d8a						ld hl, $5efe 
9d8a						push hl 
9d8a						ld hl, $5f9f 
9d8a						push hl 
9d8a						exx 
9d8a					endif 
9d8a				endif 
9d8a			endm 
# End of macro STACKFRAME
9d8a			 
9d8a					if DEBUG_FORTH_WORDS_KEY 
9d8a						DMARK "EXE" 
9d8a f5				push af  
9d8b 3a 9f 9d			ld a, (.dmark)  
9d8e 32 c0 ee			ld (debug_mark),a  
9d91 3a a0 9d			ld a, (.dmark+1)  
9d94 32 c1 ee			ld (debug_mark+1),a  
9d97 3a a1 9d			ld a, (.dmark+2)  
9d9a 32 c2 ee			ld (debug_mark+2),a  
9d9d 18 03			jr .pastdmark  
9d9f ..			.dmark: db "EXE"  
9da2 f1			.pastdmark: pop af  
9da3			endm  
# End of macro DMARK
9da3						CALLMONITOR 
9da3 cd f4 92			call break_point_state  
9da6				endm  
# End of macro CALLMONITOR
9da6					endif 
9da6			 
9da6				FORTH_DSP_VALUEHL 
9da6 cd 78 9a			call macro_dsp_valuehl 
9da9				endm 
# End of macro FORTH_DSP_VALUEHL
9da9			 
9da9				FORTH_DSP_POP 
9da9 cd 30 9b			call macro_forth_dsp_pop 
9dac				endm 
# End of macro FORTH_DSP_POP
9dac			 
9dac					if DEBUG_FORTH_WORDS 
9dac						DMARK "EX1" 
9dac f5				push af  
9dad 3a c1 9d			ld a, (.dmark)  
9db0 32 c0 ee			ld (debug_mark),a  
9db3 3a c2 9d			ld a, (.dmark+1)  
9db6 32 c1 ee			ld (debug_mark+1),a  
9db9 3a c3 9d			ld a, (.dmark+2)  
9dbc 32 c2 ee			ld (debug_mark+2),a  
9dbf 18 03			jr .pastdmark  
9dc1 ..			.dmark: db "EX1"  
9dc4 f1			.pastdmark: pop af  
9dc5			endm  
# End of macro DMARK
9dc5						CALLMONITOR 
9dc5 cd f4 92			call break_point_state  
9dc8				endm  
# End of macro CALLMONITOR
9dc8					endif 
9dc8			;	ld e,(hl) 
9dc8			;	inc hl 
9dc8			;	ld d,(hl) 
9dc8			;	ex de,hl 
9dc8			 
9dc8			;		if DEBUG_FORTH_WORDS 
9dc8			;			DMARK "EX2" 
9dc8			;			CALLMONITOR 
9dc8			;		endif 
9dc8 e5				push hl 
9dc9			 
9dc9				;ld a, 0 
9dc9				;ld a, FORTH_END_BUFFER 
9dc9 cd 05 8f			call strlenz 
9dcc 23				inc hl   ; include zero term to copy 
9dcd 23				inc hl   ; include term 
9dce 23				inc hl   ; include term 
9dcf 06 00			ld b,0 
9dd1 4d				ld c,l 
9dd2 e1				pop hl 
9dd3 11 e5 e5			ld de, execscratch 
9dd6					if DEBUG_FORTH_WORDS 
9dd6						DMARK "EX3" 
9dd6 f5				push af  
9dd7 3a eb 9d			ld a, (.dmark)  
9dda 32 c0 ee			ld (debug_mark),a  
9ddd 3a ec 9d			ld a, (.dmark+1)  
9de0 32 c1 ee			ld (debug_mark+1),a  
9de3 3a ed 9d			ld a, (.dmark+2)  
9de6 32 c2 ee			ld (debug_mark+2),a  
9de9 18 03			jr .pastdmark  
9deb ..			.dmark: db "EX3"  
9dee f1			.pastdmark: pop af  
9def			endm  
# End of macro DMARK
9def						CALLMONITOR 
9def cd f4 92			call break_point_state  
9df2				endm  
# End of macro CALLMONITOR
9df2					endif 
9df2 ed b0			ldir 
9df4			 
9df4			 
9df4 21 e5 e5			ld hl, execscratch 
9df7			 
9df7					if DEBUG_FORTH_WORDS 
9df7						DMARK "EXe" 
9df7 f5				push af  
9df8 3a 0c 9e			ld a, (.dmark)  
9dfb 32 c0 ee			ld (debug_mark),a  
9dfe 3a 0d 9e			ld a, (.dmark+1)  
9e01 32 c1 ee			ld (debug_mark+1),a  
9e04 3a 0e 9e			ld a, (.dmark+2)  
9e07 32 c2 ee			ld (debug_mark+2),a  
9e0a 18 03			jr .pastdmark  
9e0c ..			.dmark: db "EXe"  
9e0f f1			.pastdmark: pop af  
9e10			endm  
# End of macro DMARK
9e10						CALLMONITOR 
9e10 cd f4 92			call break_point_state  
9e13				endm  
# End of macro CALLMONITOR
9e13					endif 
9e13			 
9e13 cd 38 9c			call forthparse 
9e16 cd 78 9c			call forthexec 
9e19			;	call forthexec_cleanup 
9e19			;	call forthparse 
9e19			;	call forthexec 
9e19			 
9e19				STACKFRAMECHK OFF $5efe $5f9f 
9e19				if DEBUG_STACK_IMB 
9e19					if OFF 
9e19						exx 
9e19						ld hl, $5f9f 
9e19						pop de   ; $5f9f 
9e19						call cmp16 
9e19						jr nz, .spnosame 
9e19						ld hl, $5efe 
9e19						pop de   ; $5efe 
9e19						call cmp16 
9e19						jr z, .spfrsame 
9e19						.spnosame: call showsperror 
9e19						.spfrsame: nop 
9e19						exx 
9e19					endif 
9e19				endif 
9e19			endm 
# End of macro STACKFRAMECHK
9e19			 
9e19				; an immediate word so no need to process any more words 
9e19 c9				ret 
9e1a				NEXTW 
9e1a c3 ea 9b			jp macro_next 
9e1d				endm 
# End of macro NEXTW
9e1d			 
9e1d			; dead code - old version  
9e1d			;	FORTH_RSP_NEXT 
9e1d			 
9e1d			;  
9e1d			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e1d			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e1d			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e1d			;	push hl 
9e1d			;	push de 
9e1d			;	push bc 
9e1d			; 
9e1d			; 
9e1d			;		if DEBUG_FORTH_WORDS_KEY 
9e1d			;			DMARK "EXR" 
9e1d			;			CALLMONITOR 
9e1d			;		endif 
9e1d			; 
9e1d			; 
9e1d			; 
9e1d			;	;v5 FORTH_DSP_VALUE 
9e1d			;	FORTH_DSP_VALUEHL 
9e1d			; 
9e1d			;	; TODO do string type checks 
9e1d			; 
9e1d			;;v5	inc hl   ; skip type 
9e1d			; 
9e1d			;	push hl  ; source code  
9e1d			;		if DEBUG_FORTH_WORDS 
9e1d			;			DMARK "EX1" 
9e1d			;			CALLMONITOR 
9e1d			;		endif 
9e1d			;	ld a, 0 
9e1d			;	call strlent 
9e1d			; 
9e1d			;	inc hl 
9e1d			;	inc hl 
9e1d			;	inc hl 
9e1d			;	inc hl 
9e1d			; 
9e1d			;	push hl    ; size 
9e1d			; 
9e1d			;		if DEBUG_FORTH_WORDS 
9e1d			;			DMARK "EX2" 
9e1d			;			CALLMONITOR 
9e1d			;		endif 
9e1d			;	call malloc 
9e1d			; 
9e1d			;	ex de, hl    ; de now contains malloc area 
9e1d			;	pop bc   	; get byte count 
9e1d			;	pop hl      ; get string to copy 
9e1d			; 
9e1d			;	push de     ; save malloc for free later 
9e1d			; 
9e1d			;		if DEBUG_FORTH_WORDS 
9e1d			;			DMARK "EX3" 
9e1d			;			CALLMONITOR 
9e1d			;		endif 
9e1d			;	ldir       ; duplicate string 
9e1d			; 
9e1d			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9e1d			;	 
9e1d			;	; TODO fix the parse would be better than this...  
9e1d			;	ex de, hl 
9e1d			;	dec hl 
9e1d			;	ld a, 0 
9e1d			;	ld (hl), a 
9e1d			;	dec hl 
9e1d			;	ld a, ' ' 
9e1d			;	ld (hl), a 
9e1d			;	dec hl 
9e1d			;	ld (hl), a 
9e1d			; 
9e1d			;	dec hl 
9e1d			;	ld (hl), a 
9e1d			; 
9e1d			; 
9e1d			;	FORTH_DSP_POP  
9e1d			; 
9e1d			;	pop hl     
9e1d			;	push hl    ; save malloc area 
9e1d			; 
9e1d			;		if DEBUG_FORTH_WORDS 
9e1d			;			DMARK "EX4" 
9e1d			;			CALLMONITOR 
9e1d			;		endif 
9e1d			; 
9e1d			;	call forthparse 
9e1d			;	call forthexec 
9e1d			;	 
9e1d			;	pop hl 
9e1d			;	if DEBUG_FORTH_WORDS 
9e1d			;		DMARK "EX5" 
9e1d			;		CALLMONITOR 
9e1d			;	endif 
9e1d			; 
9e1d			;	if FORTH_ENABLE_FREE 
9e1d			;	call free 
9e1d			;	endif 
9e1d			; 
9e1d			;	if DEBUG_FORTH_WORDS 
9e1d			;		DMARK "EX6" 
9e1d			;		CALLMONITOR 
9e1d			;	endif 
9e1d			; 
9e1d			;	pop bc 
9e1d			;	pop de 
9e1d			;	pop hl 
9e1d			;;	FORTH_RSP_POP	  
9e1d			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9e1d			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9e1d			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9e1d			; 
9e1d			;	if DEBUG_FORTH_WORDS 
9e1d			;		DMARK "EX7" 
9e1d			;		CALLMONITOR 
9e1d			;	endif 
9e1d			;	NEXTW 
9e1d			 
9e1d			.STKEXEC: 
9e1d				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9e1d 3f				db WORD_SYS_CORE+43             
9e1e 65 9f			dw .ZDUP            
9e20 08				db 7 + 1 
9e21 .. 00			db "STKEXEC",0              
9e29				endm 
# End of macro CWHEAD
9e29			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
9e29			 
9e29			 
9e29					if DEBUG_FORTH_WORDS_KEY 
9e29						DMARK "STX" 
9e29 f5				push af  
9e2a 3a 3e 9e			ld a, (.dmark)  
9e2d 32 c0 ee			ld (debug_mark),a  
9e30 3a 3f 9e			ld a, (.dmark+1)  
9e33 32 c1 ee			ld (debug_mark+1),a  
9e36 3a 40 9e			ld a, (.dmark+2)  
9e39 32 c2 ee			ld (debug_mark+2),a  
9e3c 18 03			jr .pastdmark  
9e3e ..			.dmark: db "STX"  
9e41 f1			.pastdmark: pop af  
9e42			endm  
# End of macro DMARK
9e42						CALLMONITOR 
9e42 cd f4 92			call break_point_state  
9e45				endm  
# End of macro CALLMONITOR
9e45					endif 
9e45			 
9e45				FORTH_DSP_VALUEHL 
9e45 cd 78 9a			call macro_dsp_valuehl 
9e48				endm 
# End of macro FORTH_DSP_VALUEHL
9e48			 
9e48 22 e9 ec			ld (store_tmp1), hl    ; count 
9e4b			 
9e4b				FORTH_DSP_POP 
9e4b cd 30 9b			call macro_forth_dsp_pop 
9e4e				endm 
# End of macro FORTH_DSP_POP
9e4e			.stkexec1: 
9e4e 2a e9 ec			ld hl, (store_tmp1)   ; count 
9e51 3e 00			ld a, 0 
9e53 bd				cp l 
9e54 c8				ret z 
9e55			 
9e55 2b				dec hl 
9e56 22 e9 ec			ld (store_tmp1), hl    ; count 
9e59				 
9e59				FORTH_DSP_VALUEHL 
9e59 cd 78 9a			call macro_dsp_valuehl 
9e5c				endm 
# End of macro FORTH_DSP_VALUEHL
9e5c e5				push hl 
9e5d				 
9e5d					if DEBUG_FORTH_WORDS 
9e5d						DMARK "EXp" 
9e5d f5				push af  
9e5e 3a 72 9e			ld a, (.dmark)  
9e61 32 c0 ee			ld (debug_mark),a  
9e64 3a 73 9e			ld a, (.dmark+1)  
9e67 32 c1 ee			ld (debug_mark+1),a  
9e6a 3a 74 9e			ld a, (.dmark+2)  
9e6d 32 c2 ee			ld (debug_mark+2),a  
9e70 18 03			jr .pastdmark  
9e72 ..			.dmark: db "EXp"  
9e75 f1			.pastdmark: pop af  
9e76			endm  
# End of macro DMARK
9e76						CALLMONITOR 
9e76 cd f4 92			call break_point_state  
9e79				endm  
# End of macro CALLMONITOR
9e79					endif 
9e79				FORTH_DSP_POP 
9e79 cd 30 9b			call macro_forth_dsp_pop 
9e7c				endm 
# End of macro FORTH_DSP_POP
9e7c			 
9e7c cd 05 8f			call strlenz 
9e7f 23				inc hl   ; include zero term to copy 
9e80 23				inc hl   ; include zero term to copy 
9e81 23				inc hl   ; include zero term to copy 
9e82 06 00			ld b,0 
9e84 4d				ld c,l 
9e85 e1				pop hl 
9e86 11 e5 e5			ld de, execscratch 
9e89					if DEBUG_FORTH_WORDS 
9e89						DMARK "EX3" 
9e89 f5				push af  
9e8a 3a 9e 9e			ld a, (.dmark)  
9e8d 32 c0 ee			ld (debug_mark),a  
9e90 3a 9f 9e			ld a, (.dmark+1)  
9e93 32 c1 ee			ld (debug_mark+1),a  
9e96 3a a0 9e			ld a, (.dmark+2)  
9e99 32 c2 ee			ld (debug_mark+2),a  
9e9c 18 03			jr .pastdmark  
9e9e ..			.dmark: db "EX3"  
9ea1 f1			.pastdmark: pop af  
9ea2			endm  
# End of macro DMARK
9ea2						CALLMONITOR 
9ea2 cd f4 92			call break_point_state  
9ea5				endm  
# End of macro CALLMONITOR
9ea5					endif 
9ea5 ed b0			ldir 
9ea7			 
9ea7			 
9ea7 21 e5 e5			ld hl, execscratch 
9eaa			 
9eaa					if DEBUG_FORTH_WORDS 
9eaa						DMARK "EXP" 
9eaa f5				push af  
9eab 3a bf 9e			ld a, (.dmark)  
9eae 32 c0 ee			ld (debug_mark),a  
9eb1 3a c0 9e			ld a, (.dmark+1)  
9eb4 32 c1 ee			ld (debug_mark+1),a  
9eb7 3a c1 9e			ld a, (.dmark+2)  
9eba 32 c2 ee			ld (debug_mark+2),a  
9ebd 18 03			jr .pastdmark  
9ebf ..			.dmark: db "EXP"  
9ec2 f1			.pastdmark: pop af  
9ec3			endm  
# End of macro DMARK
9ec3						CALLMONITOR 
9ec3 cd f4 92			call break_point_state  
9ec6				endm  
# End of macro CALLMONITOR
9ec6					endif 
9ec6			 
9ec6 cd 38 9c			call forthparse 
9ec9 21 e5 e5			ld hl, execscratch 
9ecc					if DEBUG_FORTH_WORDS 
9ecc						DMARK "EXx" 
9ecc f5				push af  
9ecd 3a e1 9e			ld a, (.dmark)  
9ed0 32 c0 ee			ld (debug_mark),a  
9ed3 3a e2 9e			ld a, (.dmark+1)  
9ed6 32 c1 ee			ld (debug_mark+1),a  
9ed9 3a e3 9e			ld a, (.dmark+2)  
9edc 32 c2 ee			ld (debug_mark+2),a  
9edf 18 03			jr .pastdmark  
9ee1 ..			.dmark: db "EXx"  
9ee4 f1			.pastdmark: pop af  
9ee5			endm  
# End of macro DMARK
9ee5						CALLMONITOR 
9ee5 cd f4 92			call break_point_state  
9ee8				endm  
# End of macro CALLMONITOR
9ee8					endif 
9ee8 cd 78 9c			call forthexec 
9eeb			 
9eeb c3 4e 9e			jp .stkexec1 
9eee			 
9eee c9				ret 
9eef			 
9eef			 
9eef			.DUP: 
9eef				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9eef 17				db WORD_SYS_CORE+OPCODE_DUP             
9ef0 65 9f			dw .ZDUP            
9ef2 04				db 3 + 1 
9ef3 .. 00			db "DUP",0              
9ef7				endm 
# End of macro CWHEAD
9ef7			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9ef7			 
9ef7					if DEBUG_FORTH_WORDS_KEY 
9ef7						DMARK "DUP" 
9ef7 f5				push af  
9ef8 3a 0c 9f			ld a, (.dmark)  
9efb 32 c0 ee			ld (debug_mark),a  
9efe 3a 0d 9f			ld a, (.dmark+1)  
9f01 32 c1 ee			ld (debug_mark+1),a  
9f04 3a 0e 9f			ld a, (.dmark+2)  
9f07 32 c2 ee			ld (debug_mark+2),a  
9f0a 18 03			jr .pastdmark  
9f0c ..			.dmark: db "DUP"  
9f0f f1			.pastdmark: pop af  
9f10			endm  
# End of macro DMARK
9f10						CALLMONITOR 
9f10 cd f4 92			call break_point_state  
9f13				endm  
# End of macro CALLMONITOR
9f13					endif 
9f13			 
9f13					FORTH_DSP 
9f13 cd 3e 9a			call macro_forth_dsp 
9f16				endm 
# End of macro FORTH_DSP
9f16			 
9f16 7e					ld a, (HL) 
9f17 fe 01				cp DS_TYPE_STR 
9f19 20 25				jr nz, .dupinum 
9f1b			 
9f1b					; push another string 
9f1b			 
9f1b					FORTH_DSP_VALUEHL     		 
9f1b cd 78 9a			call macro_dsp_valuehl 
9f1e				endm 
# End of macro FORTH_DSP_VALUEHL
9f1e			 
9f1e				if DEBUG_FORTH_WORDS 
9f1e					DMARK "DUs" 
9f1e f5				push af  
9f1f 3a 33 9f			ld a, (.dmark)  
9f22 32 c0 ee			ld (debug_mark),a  
9f25 3a 34 9f			ld a, (.dmark+1)  
9f28 32 c1 ee			ld (debug_mark+1),a  
9f2b 3a 35 9f			ld a, (.dmark+2)  
9f2e 32 c2 ee			ld (debug_mark+2),a  
9f31 18 03			jr .pastdmark  
9f33 ..			.dmark: db "DUs"  
9f36 f1			.pastdmark: pop af  
9f37			endm  
# End of macro DMARK
9f37					CALLMONITOR 
9f37 cd f4 92			call break_point_state  
9f3a				endm  
# End of macro CALLMONITOR
9f3a				endif 
9f3a cd ef 98				call forth_push_str 
9f3d			 
9f3d					NEXTW 
9f3d c3 ea 9b			jp macro_next 
9f40				endm 
# End of macro NEXTW
9f40			 
9f40			 
9f40			.dupinum: 
9f40					 
9f40			 
9f40			 
9f40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f40 cd 78 9a			call macro_dsp_valuehl 
9f43				endm 
# End of macro FORTH_DSP_VALUEHL
9f43			 
9f43				; TODO add floating point number detection 
9f43			 
9f43				if DEBUG_FORTH_WORDS 
9f43					DMARK "DUi" 
9f43 f5				push af  
9f44 3a 58 9f			ld a, (.dmark)  
9f47 32 c0 ee			ld (debug_mark),a  
9f4a 3a 59 9f			ld a, (.dmark+1)  
9f4d 32 c1 ee			ld (debug_mark+1),a  
9f50 3a 5a 9f			ld a, (.dmark+2)  
9f53 32 c2 ee			ld (debug_mark+2),a  
9f56 18 03			jr .pastdmark  
9f58 ..			.dmark: db "DUi"  
9f5b f1			.pastdmark: pop af  
9f5c			endm  
# End of macro DMARK
9f5c					CALLMONITOR 
9f5c cd f4 92			call break_point_state  
9f5f				endm  
# End of macro CALLMONITOR
9f5f				endif 
9f5f			 
9f5f cd 81 98				call forth_push_numhl 
9f62					NEXTW 
9f62 c3 ea 9b			jp macro_next 
9f65				endm 
# End of macro NEXTW
9f65			.ZDUP: 
9f65				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9f65 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9f66 9d 9f			dw .SWAP            
9f68 05				db 4 + 1 
9f69 .. 00			db "?DUP",0              
9f6e				endm 
# End of macro CWHEAD
9f6e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9f6e			 
9f6e					if DEBUG_FORTH_WORDS_KEY 
9f6e						DMARK "qDU" 
9f6e f5				push af  
9f6f 3a 83 9f			ld a, (.dmark)  
9f72 32 c0 ee			ld (debug_mark),a  
9f75 3a 84 9f			ld a, (.dmark+1)  
9f78 32 c1 ee			ld (debug_mark+1),a  
9f7b 3a 85 9f			ld a, (.dmark+2)  
9f7e 32 c2 ee			ld (debug_mark+2),a  
9f81 18 03			jr .pastdmark  
9f83 ..			.dmark: db "qDU"  
9f86 f1			.pastdmark: pop af  
9f87			endm  
# End of macro DMARK
9f87						CALLMONITOR 
9f87 cd f4 92			call break_point_state  
9f8a				endm  
# End of macro CALLMONITOR
9f8a					endif 
9f8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f8a cd 78 9a			call macro_dsp_valuehl 
9f8d				endm 
# End of macro FORTH_DSP_VALUEHL
9f8d			 
9f8d e5					push hl 
9f8e			 
9f8e					; is it a zero? 
9f8e			 
9f8e 3e 00				ld a, 0 
9f90 84					add h 
9f91 85					add l 
9f92			 
9f92 e1					pop hl 
9f93			 
9f93 fe 00				cp 0 
9f95 28 03				jr z, .dup2orig 
9f97			 
9f97			 
9f97 cd 81 98				call forth_push_numhl 
9f9a			 
9f9a			 
9f9a				; TODO add floating point number detection 
9f9a			 
9f9a			.dup2orig: 
9f9a			 
9f9a					NEXTW 
9f9a c3 ea 9b			jp macro_next 
9f9d				endm 
# End of macro NEXTW
9f9d			.SWAP: 
9f9d				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9f9d 18				db WORD_SYS_CORE+OPCODE_SWAP             
9f9e dc 9f			dw .COLN            
9fa0 05				db 4 + 1 
9fa1 .. 00			db "SWAP",0              
9fa6				endm 
# End of macro CWHEAD
9fa6			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9fa6					if DEBUG_FORTH_WORDS_KEY 
9fa6						DMARK "SWP" 
9fa6 f5				push af  
9fa7 3a bb 9f			ld a, (.dmark)  
9faa 32 c0 ee			ld (debug_mark),a  
9fad 3a bc 9f			ld a, (.dmark+1)  
9fb0 32 c1 ee			ld (debug_mark+1),a  
9fb3 3a bd 9f			ld a, (.dmark+2)  
9fb6 32 c2 ee			ld (debug_mark+2),a  
9fb9 18 03			jr .pastdmark  
9fbb ..			.dmark: db "SWP"  
9fbe f1			.pastdmark: pop af  
9fbf			endm  
# End of macro DMARK
9fbf						CALLMONITOR 
9fbf cd f4 92			call break_point_state  
9fc2				endm  
# End of macro CALLMONITOR
9fc2					endif 
9fc2			 
9fc2					FORTH_DSP_VALUEHL 
9fc2 cd 78 9a			call macro_dsp_valuehl 
9fc5				endm 
# End of macro FORTH_DSP_VALUEHL
9fc5 e5					push hl     ; w2 
9fc6			 
9fc6					FORTH_DSP_POP 
9fc6 cd 30 9b			call macro_forth_dsp_pop 
9fc9				endm 
# End of macro FORTH_DSP_POP
9fc9			 
9fc9					FORTH_DSP_VALUEHL 
9fc9 cd 78 9a			call macro_dsp_valuehl 
9fcc				endm 
# End of macro FORTH_DSP_VALUEHL
9fcc			 
9fcc					FORTH_DSP_POP 
9fcc cd 30 9b			call macro_forth_dsp_pop 
9fcf				endm 
# End of macro FORTH_DSP_POP
9fcf			 
9fcf d1					pop de     ; w2	, hl = w1 
9fd0			 
9fd0 eb					ex de, hl 
9fd1 d5					push de 
9fd2			 
9fd2 cd 81 98				call forth_push_numhl 
9fd5			 
9fd5 e1					pop hl 
9fd6			 
9fd6 cd 81 98				call forth_push_numhl 
9fd9					 
9fd9			 
9fd9					NEXTW 
9fd9 c3 ea 9b			jp macro_next 
9fdc				endm 
# End of macro NEXTW
9fdc			.COLN: 
9fdc				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9fdc 19				db WORD_SYS_CORE+OPCODE_COLN             
9fdd 68 a1			dw .SCOLN            
9fdf 02				db 1 + 1 
9fe0 .. 00			db ":",0              
9fe2				endm 
# End of macro CWHEAD
9fe2			; | : ( -- )         Create new word | DONE 
9fe2			 
9fe2					if DEBUG_FORTH_WORDS_KEY 
9fe2						DMARK "CLN" 
9fe2 f5				push af  
9fe3 3a f7 9f			ld a, (.dmark)  
9fe6 32 c0 ee			ld (debug_mark),a  
9fe9 3a f8 9f			ld a, (.dmark+1)  
9fec 32 c1 ee			ld (debug_mark+1),a  
9fef 3a f9 9f			ld a, (.dmark+2)  
9ff2 32 c2 ee			ld (debug_mark+2),a  
9ff5 18 03			jr .pastdmark  
9ff7 ..			.dmark: db "CLN"  
9ffa f1			.pastdmark: pop af  
9ffb			endm  
# End of macro DMARK
9ffb						CALLMONITOR 
9ffb cd f4 92			call break_point_state  
9ffe				endm  
# End of macro CALLMONITOR
9ffe					endif 
9ffe				STACKFRAME OFF $8efe $989f 
9ffe				if DEBUG_STACK_IMB 
9ffe					if OFF 
9ffe						exx 
9ffe						ld de, $8efe 
9ffe						ld a, d 
9ffe						ld hl, curframe 
9ffe						call hexout 
9ffe						ld a, e 
9ffe						ld hl, curframe+2 
9ffe						call hexout 
9ffe						ld hl, $8efe 
9ffe						push hl 
9ffe						ld hl, $989f 
9ffe						push hl 
9ffe						exx 
9ffe					endif 
9ffe				endif 
9ffe			endm 
# End of macro STACKFRAME
9ffe				; get parser buffer length  of new word 
9ffe			 
9ffe				 
9ffe			 
9ffe					; move tok past this to start of name defintition 
9ffe					; TODO get word to define 
9ffe					; TODO Move past word token 
9ffe					; TODO get length of string up to the ';' 
9ffe			 
9ffe 2a e7 e7			ld hl, (os_tok_ptr) 
a001 23				inc hl 
a002 23				inc hl 
a003			 
a003 3e 3b			ld a, ';' 
a005 cd 10 8f			call strlent 
a008			 
a008 7d				ld a,l 
a009 32 e2 e4			ld (os_new_parse_len), a 
a00c			 
a00c			 
a00c			if DEBUG_FORTH_UWORD 
a00c ed 5b e7 e7		ld de, (os_tok_ptr) 
a010						DMARK ":01" 
a010 f5				push af  
a011 3a 25 a0			ld a, (.dmark)  
a014 32 c0 ee			ld (debug_mark),a  
a017 3a 26 a0			ld a, (.dmark+1)  
a01a 32 c1 ee			ld (debug_mark+1),a  
a01d 3a 27 a0			ld a, (.dmark+2)  
a020 32 c2 ee			ld (debug_mark+2),a  
a023 18 03			jr .pastdmark  
a025 ..			.dmark: db ":01"  
a028 f1			.pastdmark: pop af  
a029			endm  
# End of macro DMARK
a029				CALLMONITOR 
a029 cd f4 92			call break_point_state  
a02c				endm  
# End of macro CALLMONITOR
a02c			endif 
a02c			 
a02c			; 
a02c			;  new word memory layout: 
a02c			;  
a02c			;    : adg 6666 ;  
a02c			; 
a02c			;    db   1     ; user defined word  
a02c 23				inc hl    
a02d			;    dw   sysdict 
a02d 23				inc hl 
a02e 23				inc hl 
a02f			;    db <word len>+1 (for null) 
a02f 23				inc hl 
a030			;    db .... <word> 
a030			; 
a030			 
a030 23				inc hl    ; some extras for the word preamble before the above 
a031 23				inc hl 
a032 23				inc hl 
a033 23				inc hl 
a034 23				inc hl 
a035 23				inc hl 
a036 23				inc hl  
a037 23				inc hl 
a038 23				inc hl 
a039 23				inc hl 
a03a 23				inc hl 
a03b 23				inc hl 
a03c 23				inc hl 
a03d 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a03e			;       exec word buffer 
a03e			;	<ptr word>   
a03e 23				inc hl 
a03f 23				inc hl 
a040			;       <word list><null term> 7F final term 
a040			 
a040			 
a040			if DEBUG_FORTH_UWORD 
a040						DMARK ":02" 
a040 f5				push af  
a041 3a 55 a0			ld a, (.dmark)  
a044 32 c0 ee			ld (debug_mark),a  
a047 3a 56 a0			ld a, (.dmark+1)  
a04a 32 c1 ee			ld (debug_mark+1),a  
a04d 3a 57 a0			ld a, (.dmark+2)  
a050 32 c2 ee			ld (debug_mark+2),a  
a053 18 03			jr .pastdmark  
a055 ..			.dmark: db ":02"  
a058 f1			.pastdmark: pop af  
a059			endm  
# End of macro DMARK
a059				CALLMONITOR 
a059 cd f4 92			call break_point_state  
a05c				endm  
# End of macro CALLMONITOR
a05c			endif 
a05c			 
a05c				 
a05c					; malloc the size 
a05c			 
a05c cd 6e 8f				call malloc 
a05f 22 e4 e4				ld (os_new_malloc), hl     ; save malloc start 
a062			 
a062			;    db   1     ; user defined word  
a062 3e 01				ld a, WORD_SYS_UWORD  
a064 77					ld (hl), a 
a065				 
a065 23				inc hl    
a066			;    dw   sysdict 
a066 11 42 9d			ld de, sysdict       ; continue on with the scan to the system dict 
a069 73				ld (hl), e 
a06a 23				inc hl 
a06b 72				ld (hl), d 
a06c 23				inc hl 
a06d			 
a06d			 
a06d			;    Setup dict word 
a06d			 
a06d 23				inc hl 
a06e 22 de e4			ld (os_new_work_ptr), hl     ; save start of dict word  
a071			 
a071				; 1. get length of dict word 
a071			 
a071			 
a071 2a e7 e7			ld hl, (os_tok_ptr) 
a074 23				inc hl 
a075 23				inc hl    ; position to start of dict word 
a076 3e 00			ld a, 0 
a078 cd 10 8f			call strlent 
a07b			 
a07b			 
a07b 23				inc hl    ; to include null??? 
a07c			 
a07c				; write length of dict word 
a07c			 
a07c ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a080 1b				dec de 
a081 eb				ex de, hl 
a082 73				ld (hl), e 
a083 eb				ex de, hl 
a084			 
a084				 
a084			 
a084				; copy  
a084 4d				ld c, l 
a085 06 00			ld b, 0 
a087 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a08b 2a e7 e7			ld hl, (os_tok_ptr) 
a08e 23				inc hl 
a08f 23				inc hl    ; position to start of dict word 
a090				 
a090			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a090				 
a090				; TODO need to convert word to upper case 
a090			 
a090			ucasetok:	 
a090 7e				ld a,(hl) 
a091 cd fc 8e			call toUpper 
a094 77				ld (hl),a 
a095 ed a0			ldi 
a097 f2 90 a0		 	jp p, ucasetok 
a09a			 
a09a			 
a09a			 
a09a				; de now points to start of where the word body code should be placed 
a09a ed 53 de e4		ld (os_new_work_ptr), de 
a09e				; hl now points to the words to throw at forthexec which needs to be copied 
a09e 22 dc e4			ld (os_new_src_ptr), hl 
a0a1			 
a0a1				; TODO add 'call to forthexec' 
a0a1			 
a0a1			if DEBUG_FORTH_UWORD 
a0a1 c5				push bc 
a0a2 ed 4b e4 e4		ld bc, (os_new_malloc) 
a0a6						DMARK ":0x" 
a0a6 f5				push af  
a0a7 3a bb a0			ld a, (.dmark)  
a0aa 32 c0 ee			ld (debug_mark),a  
a0ad 3a bc a0			ld a, (.dmark+1)  
a0b0 32 c1 ee			ld (debug_mark+1),a  
a0b3 3a bd a0			ld a, (.dmark+2)  
a0b6 32 c2 ee			ld (debug_mark+2),a  
a0b9 18 03			jr .pastdmark  
a0bb ..			.dmark: db ":0x"  
a0be f1			.pastdmark: pop af  
a0bf			endm  
# End of macro DMARK
a0bf				CALLMONITOR 
a0bf cd f4 92			call break_point_state  
a0c2				endm  
# End of macro CALLMONITOR
a0c2 c1				pop bc 
a0c3			endif 
a0c3			 
a0c3			 
a0c3				; create word preamble which should be: 
a0c3			 
a0c3			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a0c3			 
a0c3				;    ld hl, <word code> 
a0c3				;    jp user_exec 
a0c3			        ;    <word code bytes> 
a0c3			 
a0c3			 
a0c3			;	inc de     ; TODO ??? or are we already past the word's null 
a0c3 eb				ex de, hl 
a0c4			 
a0c4 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a0c6			 
a0c6 23				inc hl 
a0c7 22 d8 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a0ca 23				inc hl 
a0cb			 
a0cb 23				inc hl 
a0cc 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a0ce			 
a0ce 01 57 c4			ld bc, user_exec 
a0d1 23				inc hl 
a0d2 71				ld (hl), c     ; poke address of user_exec 
a0d3 23				inc hl 
a0d4 70				ld (hl), b     
a0d5			 ; 
a0d5			;	inc hl 
a0d5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0d5			; 
a0d5			; 
a0d5			;	ld bc, macro_forth_rsp_next 
a0d5			;	inc hl 
a0d5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a0d5			;	inc hl 
a0d5			;	ld (hl), b     
a0d5			 ; 
a0d5			;	inc hl 
a0d5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0d5			; 
a0d5			; 
a0d5			;	inc hl 
a0d5			;	ld bc, forthexec 
a0d5			;	ld (hl), c     ; poke address of forthexec 
a0d5			;	inc hl 
a0d5			;	ld (hl), b      
a0d5			; 
a0d5			;	inc hl 
a0d5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a0d5			; 
a0d5			;	ld bc, user_dict_next 
a0d5			;	inc hl 
a0d5			;	ld (hl), c     ; poke address of forthexec 
a0d5			;	inc hl 
a0d5			;	ld (hl), b      
a0d5			 
a0d5				; hl is now where we need to copy the word byte data to save this 
a0d5			 
a0d5 23				inc hl 
a0d6 22 da e4			ld (os_new_exec), hl 
a0d9				 
a0d9				; copy definition 
a0d9			 
a0d9 eb				ex de, hl 
a0da			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a0da			;	inc de    ; skip the PC for this parse 
a0da 3a e2 e4			ld a, (os_new_parse_len) 
a0dd 4f				ld c, a 
a0de 06 00			ld b, 0 
a0e0 ed b0			ldir		 ; copy defintion 
a0e2			 
a0e2			 
a0e2				; poke the address of where the new word bytes live for forthexec 
a0e2			 
a0e2 2a d8 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a0e5			 
a0e5 ed 5b da e4		ld de, (os_new_exec)      
a0e9				 
a0e9 73				ld (hl), e 
a0ea 23				inc hl 
a0eb 72				ld (hl), d 
a0ec			 
a0ec					; TODO copy last user dict word next link to this word 
a0ec					; TODO update last user dict word to point to this word 
a0ec			; 
a0ec			; hl f923 de 812a ; bc 811a 
a0ec			 
a0ec			if DEBUG_FORTH_UWORD 
a0ec c5				push bc 
a0ed ed 4b e4 e4		ld bc, (os_new_malloc) 
a0f1						DMARK ":0A" 
a0f1 f5				push af  
a0f2 3a 06 a1			ld a, (.dmark)  
a0f5 32 c0 ee			ld (debug_mark),a  
a0f8 3a 07 a1			ld a, (.dmark+1)  
a0fb 32 c1 ee			ld (debug_mark+1),a  
a0fe 3a 08 a1			ld a, (.dmark+2)  
a101 32 c2 ee			ld (debug_mark+2),a  
a104 18 03			jr .pastdmark  
a106 ..			.dmark: db ":0A"  
a109 f1			.pastdmark: pop af  
a10a			endm  
# End of macro DMARK
a10a				CALLMONITOR 
a10a cd f4 92			call break_point_state  
a10d				endm  
# End of macro CALLMONITOR
a10d c1				pop bc 
a10e			endif 
a10e			if DEBUG_FORTH_UWORD 
a10e c5				push bc 
a10f ed 4b e4 e4		ld bc, (os_new_malloc) 
a113 03				inc bc 
a114 03				inc bc 
a115 03				inc bc 
a116 03				inc bc 
a117 03				inc bc 
a118 03				inc bc 
a119 03				inc bc 
a11a 03				inc bc 
a11b			 
a11b						DMARK ":0B" 
a11b f5				push af  
a11c 3a 30 a1			ld a, (.dmark)  
a11f 32 c0 ee			ld (debug_mark),a  
a122 3a 31 a1			ld a, (.dmark+1)  
a125 32 c1 ee			ld (debug_mark+1),a  
a128 3a 32 a1			ld a, (.dmark+2)  
a12b 32 c2 ee			ld (debug_mark+2),a  
a12e 18 03			jr .pastdmark  
a130 ..			.dmark: db ":0B"  
a133 f1			.pastdmark: pop af  
a134			endm  
# End of macro DMARK
a134				CALLMONITOR 
a134 cd f4 92			call break_point_state  
a137				endm  
# End of macro CALLMONITOR
a137 c1				pop bc 
a138			endif 
a138			 
a138			; update word dict linked list for new word 
a138			 
a138			 
a138 2a e3 e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a13b 23			inc hl     ; move to next work linked list ptr 
a13c			 
a13c ed 5b e4 e4	ld de, (os_new_malloc)		 ; new next word 
a140 73			ld (hl), e 
a141 23			inc hl 
a142 72			ld (hl), d 
a143			 
a143			if DEBUG_FORTH_UWORD 
a143 ed 4b e3 e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a147			endif 
a147			 
a147 ed 53 e3 e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a14b			 
a14b			 
a14b			if DEBUG_FORTH_UWORD 
a14b						DMARK ":0+" 
a14b f5				push af  
a14c 3a 60 a1			ld a, (.dmark)  
a14f 32 c0 ee			ld (debug_mark),a  
a152 3a 61 a1			ld a, (.dmark+1)  
a155 32 c1 ee			ld (debug_mark+1),a  
a158 3a 62 a1			ld a, (.dmark+2)  
a15b 32 c2 ee			ld (debug_mark+2),a  
a15e 18 03			jr .pastdmark  
a160 ..			.dmark: db ":0+"  
a163 f1			.pastdmark: pop af  
a164			endm  
# End of macro DMARK
a164				CALLMONITOR 
a164 cd f4 92			call break_point_state  
a167				endm  
# End of macro CALLMONITOR
a167			endif 
a167			 
a167				STACKFRAMECHK OFF $8efe $989f 
a167				if DEBUG_STACK_IMB 
a167					if OFF 
a167						exx 
a167						ld hl, $989f 
a167						pop de   ; $989f 
a167						call cmp16 
a167						jr nz, .spnosame 
a167						ld hl, $8efe 
a167						pop de   ; $8efe 
a167						call cmp16 
a167						jr z, .spfrsame 
a167						.spnosame: call showsperror 
a167						.spfrsame: nop 
a167						exx 
a167					endif 
a167				endif 
a167			endm 
# End of macro STACKFRAMECHK
a167			 
a167 c9			ret    ; dont process any remaining parser tokens as they form new word 
a168			 
a168			 
a168			 
a168			 
a168			;		NEXT 
a168			.SCOLN: 
a168			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a168 06				db OPCODE_SCOLN 
a169 b4 a1			dw .DROP 
a16b 02				db 2 
a16c .. 00			db ";",0           
a16e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a16e					if DEBUG_FORTH_WORDS_KEY 
a16e						DMARK "SCN" 
a16e f5				push af  
a16f 3a 83 a1			ld a, (.dmark)  
a172 32 c0 ee			ld (debug_mark),a  
a175 3a 84 a1			ld a, (.dmark+1)  
a178 32 c1 ee			ld (debug_mark+1),a  
a17b 3a 85 a1			ld a, (.dmark+2)  
a17e 32 c2 ee			ld (debug_mark+2),a  
a181 18 03			jr .pastdmark  
a183 ..			.dmark: db "SCN"  
a186 f1			.pastdmark: pop af  
a187			endm  
# End of macro DMARK
a187						CALLMONITOR 
a187 cd f4 92			call break_point_state  
a18a				endm  
# End of macro CALLMONITOR
a18a					endif 
a18a					FORTH_RSP_TOS 
a18a cd 3f 98			call macro_forth_rsp_tos 
a18d				endm 
# End of macro FORTH_RSP_TOS
a18d e5					push hl 
a18e					FORTH_RSP_POP 
a18e cd 49 98			call macro_forth_rsp_pop 
a191				endm 
# End of macro FORTH_RSP_POP
a191 e1					pop hl 
a192			;		ex de,hl 
a192 22 e7 e7				ld (os_tok_ptr),hl 
a195			 
a195			if DEBUG_FORTH_UWORD 
a195						DMARK "SCL" 
a195 f5				push af  
a196 3a aa a1			ld a, (.dmark)  
a199 32 c0 ee			ld (debug_mark),a  
a19c 3a ab a1			ld a, (.dmark+1)  
a19f 32 c1 ee			ld (debug_mark+1),a  
a1a2 3a ac a1			ld a, (.dmark+2)  
a1a5 32 c2 ee			ld (debug_mark+2),a  
a1a8 18 03			jr .pastdmark  
a1aa ..			.dmark: db "SCL"  
a1ad f1			.pastdmark: pop af  
a1ae			endm  
# End of macro DMARK
a1ae				CALLMONITOR 
a1ae cd f4 92			call break_point_state  
a1b1				endm  
# End of macro CALLMONITOR
a1b1			endif 
a1b1					NEXTW 
a1b1 c3 ea 9b			jp macro_next 
a1b4				endm 
# End of macro NEXTW
a1b4			 
a1b4			.DROP: 
a1b4				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a1b4 1b				db WORD_SYS_CORE+OPCODE_DROP             
a1b5 df a1			dw .DUP2            
a1b7 05				db 4 + 1 
a1b8 .. 00			db "DROP",0              
a1bd				endm 
# End of macro CWHEAD
a1bd			; | DROP ( w -- )   drop the TOS item   | DONE 
a1bd					if DEBUG_FORTH_WORDS_KEY 
a1bd						DMARK "DRP" 
a1bd f5				push af  
a1be 3a d2 a1			ld a, (.dmark)  
a1c1 32 c0 ee			ld (debug_mark),a  
a1c4 3a d3 a1			ld a, (.dmark+1)  
a1c7 32 c1 ee			ld (debug_mark+1),a  
a1ca 3a d4 a1			ld a, (.dmark+2)  
a1cd 32 c2 ee			ld (debug_mark+2),a  
a1d0 18 03			jr .pastdmark  
a1d2 ..			.dmark: db "DRP"  
a1d5 f1			.pastdmark: pop af  
a1d6			endm  
# End of macro DMARK
a1d6						CALLMONITOR 
a1d6 cd f4 92			call break_point_state  
a1d9				endm  
# End of macro CALLMONITOR
a1d9					endif 
a1d9					FORTH_DSP_POP 
a1d9 cd 30 9b			call macro_forth_dsp_pop 
a1dc				endm 
# End of macro FORTH_DSP_POP
a1dc					NEXTW 
a1dc c3 ea 9b			jp macro_next 
a1df				endm 
# End of macro NEXTW
a1df			.DUP2: 
a1df				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a1df 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a1e0 24 a2			dw .DROP2            
a1e2 05				db 4 + 1 
a1e3 .. 00			db "2DUP",0              
a1e8				endm 
# End of macro CWHEAD
a1e8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a1e8					if DEBUG_FORTH_WORDS_KEY 
a1e8						DMARK "2DU" 
a1e8 f5				push af  
a1e9 3a fd a1			ld a, (.dmark)  
a1ec 32 c0 ee			ld (debug_mark),a  
a1ef 3a fe a1			ld a, (.dmark+1)  
a1f2 32 c1 ee			ld (debug_mark+1),a  
a1f5 3a ff a1			ld a, (.dmark+2)  
a1f8 32 c2 ee			ld (debug_mark+2),a  
a1fb 18 03			jr .pastdmark  
a1fd ..			.dmark: db "2DU"  
a200 f1			.pastdmark: pop af  
a201			endm  
# End of macro DMARK
a201						CALLMONITOR 
a201 cd f4 92			call break_point_state  
a204				endm  
# End of macro CALLMONITOR
a204					endif 
a204					FORTH_DSP_VALUEHL 
a204 cd 78 9a			call macro_dsp_valuehl 
a207				endm 
# End of macro FORTH_DSP_VALUEHL
a207 e5					push hl      ; 2 
a208			 
a208					FORTH_DSP_POP 
a208 cd 30 9b			call macro_forth_dsp_pop 
a20b				endm 
# End of macro FORTH_DSP_POP
a20b					 
a20b					FORTH_DSP_VALUEHL 
a20b cd 78 9a			call macro_dsp_valuehl 
a20e				endm 
# End of macro FORTH_DSP_VALUEHL
a20e			;		push hl      ; 1 
a20e			 
a20e					FORTH_DSP_POP 
a20e cd 30 9b			call macro_forth_dsp_pop 
a211				endm 
# End of macro FORTH_DSP_POP
a211			 
a211			;		pop hl       ; 1 
a211 d1					pop de       ; 2 
a212			 
a212 cd 81 98				call forth_push_numhl 
a215 eb					ex de, hl 
a216 cd 81 98				call forth_push_numhl 
a219			 
a219					 
a219 eb					ex de, hl 
a21a			 
a21a cd 81 98				call forth_push_numhl 
a21d eb					ex de, hl 
a21e cd 81 98				call forth_push_numhl 
a221			 
a221			 
a221					NEXTW 
a221 c3 ea 9b			jp macro_next 
a224				endm 
# End of macro NEXTW
a224			.DROP2: 
a224				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a224 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a225 53 a2			dw .SWAP2            
a227 06				db 5 + 1 
a228 .. 00			db "2DROP",0              
a22e				endm 
# End of macro CWHEAD
a22e			; | 2DROP ( w w -- )    Double drop | DONE 
a22e					if DEBUG_FORTH_WORDS_KEY 
a22e						DMARK "2DR" 
a22e f5				push af  
a22f 3a 43 a2			ld a, (.dmark)  
a232 32 c0 ee			ld (debug_mark),a  
a235 3a 44 a2			ld a, (.dmark+1)  
a238 32 c1 ee			ld (debug_mark+1),a  
a23b 3a 45 a2			ld a, (.dmark+2)  
a23e 32 c2 ee			ld (debug_mark+2),a  
a241 18 03			jr .pastdmark  
a243 ..			.dmark: db "2DR"  
a246 f1			.pastdmark: pop af  
a247			endm  
# End of macro DMARK
a247						CALLMONITOR 
a247 cd f4 92			call break_point_state  
a24a				endm  
# End of macro CALLMONITOR
a24a					endif 
a24a					FORTH_DSP_POP 
a24a cd 30 9b			call macro_forth_dsp_pop 
a24d				endm 
# End of macro FORTH_DSP_POP
a24d					FORTH_DSP_POP 
a24d cd 30 9b			call macro_forth_dsp_pop 
a250				endm 
# End of macro FORTH_DSP_POP
a250					NEXTW 
a250 c3 ea 9b			jp macro_next 
a253				endm 
# End of macro NEXTW
a253			.SWAP2: 
a253				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a253 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a254 7c a2			dw .AT            
a256 06				db 5 + 1 
a257 .. 00			db "2SWAP",0              
a25d				endm 
# End of macro CWHEAD
a25d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a25d					if DEBUG_FORTH_WORDS_KEY 
a25d						DMARK "2SW" 
a25d f5				push af  
a25e 3a 72 a2			ld a, (.dmark)  
a261 32 c0 ee			ld (debug_mark),a  
a264 3a 73 a2			ld a, (.dmark+1)  
a267 32 c1 ee			ld (debug_mark+1),a  
a26a 3a 74 a2			ld a, (.dmark+2)  
a26d 32 c2 ee			ld (debug_mark+2),a  
a270 18 03			jr .pastdmark  
a272 ..			.dmark: db "2SW"  
a275 f1			.pastdmark: pop af  
a276			endm  
# End of macro DMARK
a276						CALLMONITOR 
a276 cd f4 92			call break_point_state  
a279				endm  
# End of macro CALLMONITOR
a279					endif 
a279					NEXTW 
a279 c3 ea 9b			jp macro_next 
a27c				endm 
# End of macro NEXTW
a27c			.AT: 
a27c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a27c 1f				db WORD_SYS_CORE+OPCODE_AT             
a27d ae a2			dw .CAT            
a27f 02				db 1 + 1 
a280 .. 00			db "@",0              
a282				endm 
# End of macro CWHEAD
a282			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a282			 
a282					if DEBUG_FORTH_WORDS_KEY 
a282						DMARK "AT." 
a282 f5				push af  
a283 3a 97 a2			ld a, (.dmark)  
a286 32 c0 ee			ld (debug_mark),a  
a289 3a 98 a2			ld a, (.dmark+1)  
a28c 32 c1 ee			ld (debug_mark+1),a  
a28f 3a 99 a2			ld a, (.dmark+2)  
a292 32 c2 ee			ld (debug_mark+2),a  
a295 18 03			jr .pastdmark  
a297 ..			.dmark: db "AT."  
a29a f1			.pastdmark: pop af  
a29b			endm  
# End of macro DMARK
a29b						CALLMONITOR 
a29b cd f4 92			call break_point_state  
a29e				endm  
# End of macro CALLMONITOR
a29e					endif 
a29e			.getbyteat:	 
a29e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a29e cd 78 9a			call macro_dsp_valuehl 
a2a1				endm 
# End of macro FORTH_DSP_VALUEHL
a2a1					 
a2a1			;		push hl 
a2a1				 
a2a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2a1 cd 30 9b			call macro_forth_dsp_pop 
a2a4				endm 
# End of macro FORTH_DSP_POP
a2a4			 
a2a4			;		pop hl 
a2a4			 
a2a4 7e					ld a, (hl) 
a2a5			 
a2a5 6f					ld l, a 
a2a6 26 00				ld h, 0 
a2a8 cd 81 98				call forth_push_numhl 
a2ab			 
a2ab					NEXTW 
a2ab c3 ea 9b			jp macro_next 
a2ae				endm 
# End of macro NEXTW
a2ae			.CAT: 
a2ae				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a2ae 20				db WORD_SYS_CORE+OPCODE_CAT             
a2af d7 a2			dw .BANG            
a2b1 03				db 2 + 1 
a2b2 .. 00			db "C@",0              
a2b5				endm 
# End of macro CWHEAD
a2b5			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a2b5					if DEBUG_FORTH_WORDS_KEY 
a2b5						DMARK "CAA" 
a2b5 f5				push af  
a2b6 3a ca a2			ld a, (.dmark)  
a2b9 32 c0 ee			ld (debug_mark),a  
a2bc 3a cb a2			ld a, (.dmark+1)  
a2bf 32 c1 ee			ld (debug_mark+1),a  
a2c2 3a cc a2			ld a, (.dmark+2)  
a2c5 32 c2 ee			ld (debug_mark+2),a  
a2c8 18 03			jr .pastdmark  
a2ca ..			.dmark: db "CAA"  
a2cd f1			.pastdmark: pop af  
a2ce			endm  
# End of macro DMARK
a2ce						CALLMONITOR 
a2ce cd f4 92			call break_point_state  
a2d1				endm  
# End of macro CALLMONITOR
a2d1					endif 
a2d1 c3 9e a2				jp .getbyteat 
a2d4					NEXTW 
a2d4 c3 ea 9b			jp macro_next 
a2d7				endm 
# End of macro NEXTW
a2d7			.BANG: 
a2d7				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a2d7 21				db WORD_SYS_CORE+OPCODE_BANG             
a2d8 0d a3			dw .CBANG            
a2da 02				db 1 + 1 
a2db .. 00			db "!",0              
a2dd				endm 
# End of macro CWHEAD
a2dd			; | ! ( x w -- ) Store x at address w      | DONE 
a2dd					if DEBUG_FORTH_WORDS_KEY 
a2dd						DMARK "BNG" 
a2dd f5				push af  
a2de 3a f2 a2			ld a, (.dmark)  
a2e1 32 c0 ee			ld (debug_mark),a  
a2e4 3a f3 a2			ld a, (.dmark+1)  
a2e7 32 c1 ee			ld (debug_mark+1),a  
a2ea 3a f4 a2			ld a, (.dmark+2)  
a2ed 32 c2 ee			ld (debug_mark+2),a  
a2f0 18 03			jr .pastdmark  
a2f2 ..			.dmark: db "BNG"  
a2f5 f1			.pastdmark: pop af  
a2f6			endm  
# End of macro DMARK
a2f6						CALLMONITOR 
a2f6 cd f4 92			call break_point_state  
a2f9				endm  
# End of macro CALLMONITOR
a2f9					endif 
a2f9			 
a2f9			.storebyteat:		 
a2f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2f9 cd 78 9a			call macro_dsp_valuehl 
a2fc				endm 
# End of macro FORTH_DSP_VALUEHL
a2fc					 
a2fc e5					push hl 
a2fd				 
a2fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2fd cd 30 9b			call macro_forth_dsp_pop 
a300				endm 
# End of macro FORTH_DSP_POP
a300			 
a300					; get byte to poke 
a300			 
a300					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a300 cd 78 9a			call macro_dsp_valuehl 
a303				endm 
# End of macro FORTH_DSP_VALUEHL
a303 e5					push hl 
a304			 
a304			 
a304					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a304 cd 30 9b			call macro_forth_dsp_pop 
a307				endm 
# End of macro FORTH_DSP_POP
a307			 
a307			 
a307 d1					pop de 
a308 e1					pop hl 
a309			 
a309 73					ld (hl),e 
a30a			 
a30a			 
a30a					NEXTW 
a30a c3 ea 9b			jp macro_next 
a30d				endm 
# End of macro NEXTW
a30d			.CBANG: 
a30d				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a30d 22				db WORD_SYS_CORE+OPCODE_CBANG             
a30e 36 a3			dw .SCALL            
a310 03				db 2 + 1 
a311 .. 00			db "C!",0              
a314				endm 
# End of macro CWHEAD
a314			; | C!  ( x w -- ) Store x at address w  | DONE 
a314					if DEBUG_FORTH_WORDS_KEY 
a314						DMARK "CBA" 
a314 f5				push af  
a315 3a 29 a3			ld a, (.dmark)  
a318 32 c0 ee			ld (debug_mark),a  
a31b 3a 2a a3			ld a, (.dmark+1)  
a31e 32 c1 ee			ld (debug_mark+1),a  
a321 3a 2b a3			ld a, (.dmark+2)  
a324 32 c2 ee			ld (debug_mark+2),a  
a327 18 03			jr .pastdmark  
a329 ..			.dmark: db "CBA"  
a32c f1			.pastdmark: pop af  
a32d			endm  
# End of macro DMARK
a32d						CALLMONITOR 
a32d cd f4 92			call break_point_state  
a330				endm  
# End of macro CALLMONITOR
a330					endif 
a330 c3 f9 a2				jp .storebyteat 
a333					NEXTW 
a333 c3 ea 9b			jp macro_next 
a336				endm 
# End of macro NEXTW
a336			.SCALL: 
a336				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a336 23				db WORD_SYS_CORE+OPCODE_SCALL             
a337 6a a3			dw .DEPTH            
a339 05				db 4 + 1 
a33a .. 00			db "CALL",0              
a33f				endm 
# End of macro CWHEAD
a33f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a33f					if DEBUG_FORTH_WORDS_KEY 
a33f						DMARK "CLL" 
a33f f5				push af  
a340 3a 54 a3			ld a, (.dmark)  
a343 32 c0 ee			ld (debug_mark),a  
a346 3a 55 a3			ld a, (.dmark+1)  
a349 32 c1 ee			ld (debug_mark+1),a  
a34c 3a 56 a3			ld a, (.dmark+2)  
a34f 32 c2 ee			ld (debug_mark+2),a  
a352 18 03			jr .pastdmark  
a354 ..			.dmark: db "CLL"  
a357 f1			.pastdmark: pop af  
a358			endm  
# End of macro DMARK
a358						CALLMONITOR 
a358 cd f4 92			call break_point_state  
a35b				endm  
# End of macro CALLMONITOR
a35b					endif 
a35b			 
a35b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a35b cd 78 9a			call macro_dsp_valuehl 
a35e				endm 
# End of macro FORTH_DSP_VALUEHL
a35e			 
a35e			;		push hl 
a35e			 
a35e					; destroy value TOS 
a35e			 
a35e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a35e cd 30 9b			call macro_forth_dsp_pop 
a361				endm 
# End of macro FORTH_DSP_POP
a361			 
a361						 
a361			;		pop hl 
a361			 
a361					; how to do a call with hl???? save SP? 
a361 cd 93 9b				call forth_call_hl 
a364			 
a364			 
a364					; TODO push value back onto stack for another op etc 
a364			 
a364 cd 81 98				call forth_push_numhl 
a367					NEXTW 
a367 c3 ea 9b			jp macro_next 
a36a				endm 
# End of macro NEXTW
a36a			.DEPTH: 
a36a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a36a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a36b a7 a3			dw .OVER            
a36d 06				db 5 + 1 
a36e .. 00			db "DEPTH",0              
a374				endm 
# End of macro CWHEAD
a374			; | DEPTH ( -- u ) Push count of stack | DONE 
a374					; take current TOS and remove from base value div by two to get count 
a374					if DEBUG_FORTH_WORDS_KEY 
a374						DMARK "DEP" 
a374 f5				push af  
a375 3a 89 a3			ld a, (.dmark)  
a378 32 c0 ee			ld (debug_mark),a  
a37b 3a 8a a3			ld a, (.dmark+1)  
a37e 32 c1 ee			ld (debug_mark+1),a  
a381 3a 8b a3			ld a, (.dmark+2)  
a384 32 c2 ee			ld (debug_mark+2),a  
a387 18 03			jr .pastdmark  
a389 ..			.dmark: db "DEP"  
a38c f1			.pastdmark: pop af  
a38d			endm  
# End of macro DMARK
a38d						CALLMONITOR 
a38d cd f4 92			call break_point_state  
a390				endm  
# End of macro CALLMONITOR
a390					endif 
a390			 
a390			 
a390 2a 93 ec			ld hl, (cli_data_sp) 
a393 11 4d ea			ld de, cli_data_stack 
a396 ed 52			sbc hl,de 
a398				 
a398				; div by size of stack item 
a398			 
a398 5d				ld e,l 
a399 0e 03			ld c, 3 
a39b cd 37 8a			call Div8 
a39e			 
a39e 6f				ld l,a 
a39f 26 00			ld h,0 
a3a1			 
a3a1				;srl h 
a3a1				;rr l 
a3a1			 
a3a1 cd 81 98				call forth_push_numhl 
a3a4					NEXTW 
a3a4 c3 ea 9b			jp macro_next 
a3a7				endm 
# End of macro NEXTW
a3a7			.OVER: 
a3a7				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a3a7 42				db WORD_SYS_CORE+46             
a3a8 ee a3			dw .PAUSE            
a3aa 05				db 4 + 1 
a3ab .. 00			db "OVER",0              
a3b0				endm 
# End of macro CWHEAD
a3b0			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a3b0					if DEBUG_FORTH_WORDS_KEY 
a3b0						DMARK "OVR" 
a3b0 f5				push af  
a3b1 3a c5 a3			ld a, (.dmark)  
a3b4 32 c0 ee			ld (debug_mark),a  
a3b7 3a c6 a3			ld a, (.dmark+1)  
a3ba 32 c1 ee			ld (debug_mark+1),a  
a3bd 3a c7 a3			ld a, (.dmark+2)  
a3c0 32 c2 ee			ld (debug_mark+2),a  
a3c3 18 03			jr .pastdmark  
a3c5 ..			.dmark: db "OVR"  
a3c8 f1			.pastdmark: pop af  
a3c9			endm  
# End of macro DMARK
a3c9						CALLMONITOR 
a3c9 cd f4 92			call break_point_state  
a3cc				endm  
# End of macro CALLMONITOR
a3cc					endif 
a3cc			 
a3cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3cc cd 78 9a			call macro_dsp_valuehl 
a3cf				endm 
# End of macro FORTH_DSP_VALUEHL
a3cf e5					push hl    ; n2 
a3d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3d0 cd 30 9b			call macro_forth_dsp_pop 
a3d3				endm 
# End of macro FORTH_DSP_POP
a3d3			 
a3d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3d3 cd 78 9a			call macro_dsp_valuehl 
a3d6				endm 
# End of macro FORTH_DSP_VALUEHL
a3d6 e5					push hl    ; n1 
a3d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3d7 cd 30 9b			call macro_forth_dsp_pop 
a3da				endm 
# End of macro FORTH_DSP_POP
a3da			 
a3da d1					pop de     ; n1 
a3db e1					pop hl     ; n2 
a3dc			 
a3dc d5					push de 
a3dd e5					push hl 
a3de d5					push de 
a3df			 
a3df					; push back  
a3df			 
a3df e1					pop hl 
a3e0 cd 81 98				call forth_push_numhl 
a3e3 e1					pop hl 
a3e4 cd 81 98				call forth_push_numhl 
a3e7 e1					pop hl 
a3e8 cd 81 98				call forth_push_numhl 
a3eb					NEXTW 
a3eb c3 ea 9b			jp macro_next 
a3ee				endm 
# End of macro NEXTW
a3ee			 
a3ee			.PAUSE: 
a3ee				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a3ee 43				db WORD_SYS_CORE+47             
a3ef 23 a4			dw .PAUSES            
a3f1 08				db 7 + 1 
a3f2 .. 00			db "PAUSEMS",0              
a3fa				endm 
# End of macro CWHEAD
a3fa			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a3fa					if DEBUG_FORTH_WORDS_KEY 
a3fa						DMARK "PMS" 
a3fa f5				push af  
a3fb 3a 0f a4			ld a, (.dmark)  
a3fe 32 c0 ee			ld (debug_mark),a  
a401 3a 10 a4			ld a, (.dmark+1)  
a404 32 c1 ee			ld (debug_mark+1),a  
a407 3a 11 a4			ld a, (.dmark+2)  
a40a 32 c2 ee			ld (debug_mark+2),a  
a40d 18 03			jr .pastdmark  
a40f ..			.dmark: db "PMS"  
a412 f1			.pastdmark: pop af  
a413			endm  
# End of macro DMARK
a413						CALLMONITOR 
a413 cd f4 92			call break_point_state  
a416				endm  
# End of macro CALLMONITOR
a416					endif 
a416					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a416 cd 78 9a			call macro_dsp_valuehl 
a419				endm 
# End of macro FORTH_DSP_VALUEHL
a419			;		push hl    ; n2 
a419					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a419 cd 30 9b			call macro_forth_dsp_pop 
a41c				endm 
# End of macro FORTH_DSP_POP
a41c			;		pop hl 
a41c			 
a41c 7d					ld a, l 
a41d cd df 87				call aDelayInMS 
a420				       NEXTW 
a420 c3 ea 9b			jp macro_next 
a423				endm 
# End of macro NEXTW
a423			.PAUSES:  
a423				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a423 44				db WORD_SYS_CORE+48             
a424 92 a4			dw .ROT            
a426 06				db 5 + 1 
a427 .. 00			db "PAUSE",0              
a42d				endm 
# End of macro CWHEAD
a42d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a42d					if DEBUG_FORTH_WORDS_KEY 
a42d						DMARK "PAU" 
a42d f5				push af  
a42e 3a 42 a4			ld a, (.dmark)  
a431 32 c0 ee			ld (debug_mark),a  
a434 3a 43 a4			ld a, (.dmark+1)  
a437 32 c1 ee			ld (debug_mark+1),a  
a43a 3a 44 a4			ld a, (.dmark+2)  
a43d 32 c2 ee			ld (debug_mark+2),a  
a440 18 03			jr .pastdmark  
a442 ..			.dmark: db "PAU"  
a445 f1			.pastdmark: pop af  
a446			endm  
# End of macro DMARK
a446						CALLMONITOR 
a446 cd f4 92			call break_point_state  
a449				endm  
# End of macro CALLMONITOR
a449					endif 
a449					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a449 cd 78 9a			call macro_dsp_valuehl 
a44c				endm 
# End of macro FORTH_DSP_VALUEHL
a44c			;		push hl    ; n2 
a44c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a44c cd 30 9b			call macro_forth_dsp_pop 
a44f				endm 
# End of macro FORTH_DSP_POP
a44f			;		pop hl 
a44f 45					ld b, l 
a450					if DEBUG_FORTH_WORDS 
a450						DMARK "PAU" 
a450 f5				push af  
a451 3a 65 a4			ld a, (.dmark)  
a454 32 c0 ee			ld (debug_mark),a  
a457 3a 66 a4			ld a, (.dmark+1)  
a45a 32 c1 ee			ld (debug_mark+1),a  
a45d 3a 67 a4			ld a, (.dmark+2)  
a460 32 c2 ee			ld (debug_mark+2),a  
a463 18 03			jr .pastdmark  
a465 ..			.dmark: db "PAU"  
a468 f1			.pastdmark: pop af  
a469			endm  
# End of macro DMARK
a469						CALLMONITOR 
a469 cd f4 92			call break_point_state  
a46c				endm  
# End of macro CALLMONITOR
a46c					endif 
a46c c5			.pauses1:	push bc 
a46d cd fa 87				call delay1s 
a470 c1					pop bc 
a471					if DEBUG_FORTH_WORDS 
a471						DMARK "PA1" 
a471 f5				push af  
a472 3a 86 a4			ld a, (.dmark)  
a475 32 c0 ee			ld (debug_mark),a  
a478 3a 87 a4			ld a, (.dmark+1)  
a47b 32 c1 ee			ld (debug_mark+1),a  
a47e 3a 88 a4			ld a, (.dmark+2)  
a481 32 c2 ee			ld (debug_mark+2),a  
a484 18 03			jr .pastdmark  
a486 ..			.dmark: db "PA1"  
a489 f1			.pastdmark: pop af  
a48a			endm  
# End of macro DMARK
a48a						CALLMONITOR 
a48a cd f4 92			call break_point_state  
a48d				endm  
# End of macro CALLMONITOR
a48d					endif 
a48d 10 dd				djnz .pauses1 
a48f			 
a48f				       NEXTW 
a48f c3 ea 9b			jp macro_next 
a492				endm 
# End of macro NEXTW
a492			.ROT: 
a492				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a492 45				db WORD_SYS_CORE+49             
a493 e0 a4			dw .UWORDS            
a495 04				db 3 + 1 
a496 .. 00			db "ROT",0              
a49a				endm 
# End of macro CWHEAD
a49a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a49a					if DEBUG_FORTH_WORDS_KEY 
a49a						DMARK "ROT" 
a49a f5				push af  
a49b 3a af a4			ld a, (.dmark)  
a49e 32 c0 ee			ld (debug_mark),a  
a4a1 3a b0 a4			ld a, (.dmark+1)  
a4a4 32 c1 ee			ld (debug_mark+1),a  
a4a7 3a b1 a4			ld a, (.dmark+2)  
a4aa 32 c2 ee			ld (debug_mark+2),a  
a4ad 18 03			jr .pastdmark  
a4af ..			.dmark: db "ROT"  
a4b2 f1			.pastdmark: pop af  
a4b3			endm  
# End of macro DMARK
a4b3						CALLMONITOR 
a4b3 cd f4 92			call break_point_state  
a4b6				endm  
# End of macro CALLMONITOR
a4b6					endif 
a4b6			 
a4b6					FORTH_DSP_VALUEHL 
a4b6 cd 78 9a			call macro_dsp_valuehl 
a4b9				endm 
# End of macro FORTH_DSP_VALUEHL
a4b9 e5					push hl    ; u3  
a4ba			 
a4ba					FORTH_DSP_POP 
a4ba cd 30 9b			call macro_forth_dsp_pop 
a4bd				endm 
# End of macro FORTH_DSP_POP
a4bd			   
a4bd					FORTH_DSP_VALUEHL 
a4bd cd 78 9a			call macro_dsp_valuehl 
a4c0				endm 
# End of macro FORTH_DSP_VALUEHL
a4c0 e5					push hl     ; u2 
a4c1			 
a4c1					FORTH_DSP_POP 
a4c1 cd 30 9b			call macro_forth_dsp_pop 
a4c4				endm 
# End of macro FORTH_DSP_POP
a4c4			 
a4c4					FORTH_DSP_VALUEHL 
a4c4 cd 78 9a			call macro_dsp_valuehl 
a4c7				endm 
# End of macro FORTH_DSP_VALUEHL
a4c7 e5					push hl     ; u1 
a4c8			 
a4c8					FORTH_DSP_POP 
a4c8 cd 30 9b			call macro_forth_dsp_pop 
a4cb				endm 
# End of macro FORTH_DSP_POP
a4cb			 
a4cb c1					pop bc      ; u1 
a4cc e1					pop hl      ; u2 
a4cd d1					pop de      ; u3 
a4ce			 
a4ce			 
a4ce c5					push bc 
a4cf d5					push de 
a4d0 e5					push hl 
a4d1			 
a4d1			 
a4d1 e1					pop hl 
a4d2 cd 81 98				call forth_push_numhl 
a4d5			 
a4d5 e1					pop hl 
a4d6 cd 81 98				call forth_push_numhl 
a4d9			 
a4d9 e1					pop hl 
a4da cd 81 98				call forth_push_numhl 
a4dd					 
a4dd			 
a4dd			 
a4dd			 
a4dd			 
a4dd			 
a4dd				       NEXTW 
a4dd c3 ea 9b			jp macro_next 
a4e0				endm 
# End of macro NEXTW
a4e0			 
a4e0			.UWORDS: 
a4e0				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a4e0 50				db WORD_SYS_CORE+60             
a4e1 a2 a5			dw .BP            
a4e3 07				db 6 + 1 
a4e4 .. 00			db "UWORDS",0              
a4eb				endm 
# End of macro CWHEAD
a4eb			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a4eb			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a4eb			; | | Following the count are the individual words. 
a4eb			; | | 
a4eb			; | | e.g. UWORDS 
a4eb			; | | BOX DIRLIST 2 
a4eb			; | |  
a4eb			; | | Can be used to save the words to storage via: 
a4eb			; | | UWORDS $01 DO $01 APPEND LOOP 
a4eb				if DEBUG_FORTH_WORDS_KEY 
a4eb					DMARK "UWR" 
a4eb f5				push af  
a4ec 3a 00 a5			ld a, (.dmark)  
a4ef 32 c0 ee			ld (debug_mark),a  
a4f2 3a 01 a5			ld a, (.dmark+1)  
a4f5 32 c1 ee			ld (debug_mark+1),a  
a4f8 3a 02 a5			ld a, (.dmark+2)  
a4fb 32 c2 ee			ld (debug_mark+2),a  
a4fe 18 03			jr .pastdmark  
a500 ..			.dmark: db "UWR"  
a503 f1			.pastdmark: pop af  
a504			endm  
# End of macro DMARK
a504					CALLMONITOR 
a504 cd f4 92			call break_point_state  
a507				endm  
# End of macro CALLMONITOR
a507				endif 
a507 21 74 d8				ld hl, baseram 
a50a					;ld hl, baseusermem 
a50a 01 00 00				ld bc, 0    ; start a counter 
a50d			 
a50d				; skip dict stub 
a50d			 
a50d cd 3b 9d				call forth_tok_next 
a510			 
a510			 
a510			; while we have words to look for 
a510			 
a510 7e			.douscan:	ld a, (hl)      
a511				if DEBUG_FORTH_WORDS 
a511					DMARK "UWs" 
a511 f5				push af  
a512 3a 26 a5			ld a, (.dmark)  
a515 32 c0 ee			ld (debug_mark),a  
a518 3a 27 a5			ld a, (.dmark+1)  
a51b 32 c1 ee			ld (debug_mark+1),a  
a51e 3a 28 a5			ld a, (.dmark+2)  
a521 32 c2 ee			ld (debug_mark+2),a  
a524 18 03			jr .pastdmark  
a526 ..			.dmark: db "UWs"  
a529 f1			.pastdmark: pop af  
a52a			endm  
# End of macro DMARK
a52a					CALLMONITOR 
a52a cd f4 92			call break_point_state  
a52d				endm  
# End of macro CALLMONITOR
a52d				endif 
a52d fe 00				cp WORD_SYS_END 
a52f 28 4d				jr z, .udone 
a531 fe 01				cp WORD_SYS_UWORD 
a533 20 44				jr nz, .nuword 
a535			 
a535				if DEBUG_FORTH_WORDS 
a535					DMARK "UWu" 
a535 f5				push af  
a536 3a 4a a5			ld a, (.dmark)  
a539 32 c0 ee			ld (debug_mark),a  
a53c 3a 4b a5			ld a, (.dmark+1)  
a53f 32 c1 ee			ld (debug_mark+1),a  
a542 3a 4c a5			ld a, (.dmark+2)  
a545 32 c2 ee			ld (debug_mark+2),a  
a548 18 03			jr .pastdmark  
a54a ..			.dmark: db "UWu"  
a54d f1			.pastdmark: pop af  
a54e			endm  
# End of macro DMARK
a54e					CALLMONITOR 
a54e cd f4 92			call break_point_state  
a551				endm  
# End of macro CALLMONITOR
a551				endif 
a551					; we have a uword so push its name to the stack 
a551			 
a551 e5				   	push hl  ; save so we can move to next dict block 
a552			 
a552					; skip opcode 
a552 23					inc hl  
a553					; skip next ptr 
a553 23					inc hl  
a554 23					inc hl 
a555					; skip len 
a555 23					inc hl 
a556				if DEBUG_FORTH_WORDS 
a556					DMARK "UWt" 
a556 f5				push af  
a557 3a 6b a5			ld a, (.dmark)  
a55a 32 c0 ee			ld (debug_mark),a  
a55d 3a 6c a5			ld a, (.dmark+1)  
a560 32 c1 ee			ld (debug_mark+1),a  
a563 3a 6d a5			ld a, (.dmark+2)  
a566 32 c2 ee			ld (debug_mark+2),a  
a569 18 03			jr .pastdmark  
a56b ..			.dmark: db "UWt"  
a56e f1			.pastdmark: pop af  
a56f			endm  
# End of macro DMARK
a56f					CALLMONITOR 
a56f cd f4 92			call break_point_state  
a572				endm  
# End of macro CALLMONITOR
a572				endif 
a572 03					inc bc 
a573			 
a573 c5					push bc 
a574 cd ef 98				call forth_push_str 
a577 c1					pop bc 
a578			 
a578 e1					pop hl 	 
a579			 
a579 cd 3b 9d		.nuword:	call forth_tok_next 
a57c 18 92				jr .douscan  
a57e			 
a57e			.udone:		 ; push count of uwords found 
a57e c5					push bc 
a57f e1					pop hl 
a580			 
a580				if DEBUG_FORTH_WORDS 
a580					DMARK "UWc" 
a580 f5				push af  
a581 3a 95 a5			ld a, (.dmark)  
a584 32 c0 ee			ld (debug_mark),a  
a587 3a 96 a5			ld a, (.dmark+1)  
a58a 32 c1 ee			ld (debug_mark+1),a  
a58d 3a 97 a5			ld a, (.dmark+2)  
a590 32 c2 ee			ld (debug_mark+2),a  
a593 18 03			jr .pastdmark  
a595 ..			.dmark: db "UWc"  
a598 f1			.pastdmark: pop af  
a599			endm  
# End of macro DMARK
a599					CALLMONITOR 
a599 cd f4 92			call break_point_state  
a59c				endm  
# End of macro CALLMONITOR
a59c				endif 
a59c cd 81 98				call forth_push_numhl 
a59f			 
a59f			 
a59f				       NEXTW 
a59f c3 ea 9b			jp macro_next 
a5a2				endm 
# End of macro NEXTW
a5a2			 
a5a2			.BP: 
a5a2				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a5a2 54				db WORD_SYS_CORE+64             
a5a3 d8 a5			dw .MONITOR            
a5a5 03				db 2 + 1 
a5a6 .. 00			db "BP",0              
a5a9				endm 
# End of macro CWHEAD
a5a9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a5a9			; | | $00 Will enable the break points within specific code paths 
a5a9			; | | $01 Will disable break points 
a5a9			; | |  
a5a9			; | | By default break points are off. Either the above can be used to enable them 
a5a9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a5a9			; | | and on release of the pressed key a message will be disaplayed to notify 
a5a9			; | | that break points are enabled. Pressing any key will then continue boot process. 
a5a9					; get byte count 
a5a9					if DEBUG_FORTH_WORDS_KEY 
a5a9						DMARK "BP." 
a5a9 f5				push af  
a5aa 3a be a5			ld a, (.dmark)  
a5ad 32 c0 ee			ld (debug_mark),a  
a5b0 3a bf a5			ld a, (.dmark+1)  
a5b3 32 c1 ee			ld (debug_mark+1),a  
a5b6 3a c0 a5			ld a, (.dmark+2)  
a5b9 32 c2 ee			ld (debug_mark+2),a  
a5bc 18 03			jr .pastdmark  
a5be ..			.dmark: db "BP."  
a5c1 f1			.pastdmark: pop af  
a5c2			endm  
# End of macro DMARK
a5c2						CALLMONITOR 
a5c2 cd f4 92			call break_point_state  
a5c5				endm  
# End of macro CALLMONITOR
a5c5					endif 
a5c5			 
a5c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5c5 cd 78 9a			call macro_dsp_valuehl 
a5c8				endm 
# End of macro FORTH_DSP_VALUEHL
a5c8			 
a5c8			;		push hl 
a5c8			 
a5c8					; destroy value TOS 
a5c8			 
a5c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5c8 cd 30 9b			call macro_forth_dsp_pop 
a5cb				endm 
# End of macro FORTH_DSP_POP
a5cb			 
a5cb			;		pop hl 
a5cb			 
a5cb 3e 00				ld a,0 
a5cd bd					cp l 
a5ce 28 02				jr z, .bpset 
a5d0 3e 2a				ld a, '*' 
a5d2			 
a5d2 32 d7 e4		.bpset:		ld (os_view_disable), a 
a5d5			 
a5d5			 
a5d5					NEXTW 
a5d5 c3 ea 9b			jp macro_next 
a5d8				endm 
# End of macro NEXTW
a5d8			 
a5d8			 
a5d8			.MONITOR: 
a5d8				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a5d8 55				db WORD_SYS_CORE+65             
a5d9 0b a6			dw .MALLOC            
a5db 08				db 7 + 1 
a5dc .. 00			db "MONITOR",0              
a5e4				endm 
# End of macro CWHEAD
a5e4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a5e4			; | | At start the current various registers will be displayed with contents. 
a5e4			; | | Top right corner will show the most recent debug marker seen. 
a5e4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a5e4			; | | and the return stack pointer (RSP). 
a5e4			; | | Pressing: 
a5e4			; | |    1 - Initial screen 
a5e4			; | |    2 - Display a data dump of HL 
a5e4			; | |    3 - Display a data dump of DE 
a5e4			; | |    4 - Display a data dump of BC 
a5e4			; | |    5 - Display a data dump of HL 
a5e4			; | |    6 - Display a data dump of DSP 
a5e4			; | |    7 - Display a data dump of RSP 
a5e4			; | |    8 - Display a data dump of what is at DSP 
a5e4			; | |    9 - Display a data dump of what is at RSP 
a5e4			; | |    0 - Exit monitor and continue running. This will also enable break points 
a5e4			; | |    * - Disable break points 
a5e4			; | |    # - Enter traditional monitor mode 
a5e4			; | | 
a5e4			; | | Monitor Mode 
a5e4			; | | ------------ 
a5e4			; | | A prompt of '>' will be shown for various commands: 
a5e4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a5e4			; | |    C - Continue display a data dump from the last set address 
a5e4			; | |    M xxxx - Set start of memory edit at address xx 
a5e4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a5e4			; | |    Q - Return to previous 
a5e4					if DEBUG_FORTH_WORDS_KEY 
a5e4						DMARK "MON" 
a5e4 f5				push af  
a5e5 3a f9 a5			ld a, (.dmark)  
a5e8 32 c0 ee			ld (debug_mark),a  
a5eb 3a fa a5			ld a, (.dmark+1)  
a5ee 32 c1 ee			ld (debug_mark+1),a  
a5f1 3a fb a5			ld a, (.dmark+2)  
a5f4 32 c2 ee			ld (debug_mark+2),a  
a5f7 18 03			jr .pastdmark  
a5f9 ..			.dmark: db "MON"  
a5fc f1			.pastdmark: pop af  
a5fd			endm  
# End of macro DMARK
a5fd						CALLMONITOR 
a5fd cd f4 92			call break_point_state  
a600				endm  
# End of macro CALLMONITOR
a600					endif 
a600 3e 00				ld a, 0 
a602 32 d7 e4				ld (os_view_disable), a 
a605			 
a605					CALLMONITOR 
a605 cd f4 92			call break_point_state  
a608				endm  
# End of macro CALLMONITOR
a608			 
a608			;	call monitor 
a608			 
a608					NEXTW 
a608 c3 ea 9b			jp macro_next 
a60b				endm 
# End of macro NEXTW
a60b			 
a60b			 
a60b			.MALLOC: 
a60b				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a60b 56				db WORD_SYS_CORE+66             
a60c 34 a6			dw .MALLOC2            
a60e 06				db 5 + 1 
a60f .. 00			db "ALLOT",0              
a615				endm 
# End of macro CWHEAD
a615			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a615					if DEBUG_FORTH_WORDS_KEY 
a615						DMARK "ALL" 
a615 f5				push af  
a616 3a 2a a6			ld a, (.dmark)  
a619 32 c0 ee			ld (debug_mark),a  
a61c 3a 2b a6			ld a, (.dmark+1)  
a61f 32 c1 ee			ld (debug_mark+1),a  
a622 3a 2c a6			ld a, (.dmark+2)  
a625 32 c2 ee			ld (debug_mark+2),a  
a628 18 03			jr .pastdmark  
a62a ..			.dmark: db "ALL"  
a62d f1			.pastdmark: pop af  
a62e			endm  
# End of macro DMARK
a62e						CALLMONITOR 
a62e cd f4 92			call break_point_state  
a631				endm  
# End of macro CALLMONITOR
a631					endif 
a631 c3 5b a6				jp .mallocc 
a634			.MALLOC2: 
a634				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a634 56				db WORD_SYS_CORE+66             
a635 72 a6			dw .FREE            
a637 07				db 6 + 1 
a638 .. 00			db "MALLOC",0              
a63f				endm 
# End of macro CWHEAD
a63f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a63f					; get byte count 
a63f					if DEBUG_FORTH_WORDS_KEY 
a63f						DMARK "MAL" 
a63f f5				push af  
a640 3a 54 a6			ld a, (.dmark)  
a643 32 c0 ee			ld (debug_mark),a  
a646 3a 55 a6			ld a, (.dmark+1)  
a649 32 c1 ee			ld (debug_mark+1),a  
a64c 3a 56 a6			ld a, (.dmark+2)  
a64f 32 c2 ee			ld (debug_mark+2),a  
a652 18 03			jr .pastdmark  
a654 ..			.dmark: db "MAL"  
a657 f1			.pastdmark: pop af  
a658			endm  
# End of macro DMARK
a658						CALLMONITOR 
a658 cd f4 92			call break_point_state  
a65b				endm  
# End of macro CALLMONITOR
a65b					endif 
a65b			.mallocc: 
a65b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a65b cd 78 9a			call macro_dsp_valuehl 
a65e				endm 
# End of macro FORTH_DSP_VALUEHL
a65e			 
a65e			;		push hl 
a65e			 
a65e					; destroy value TOS 
a65e			 
a65e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a65e cd 30 9b			call macro_forth_dsp_pop 
a661				endm 
# End of macro FORTH_DSP_POP
a661			 
a661			;		pop hl 
a661 cd 6e 8f				call malloc 
a664				if DEBUG_FORTH_MALLOC_GUARD 
a664 f5					push af 
a665 cd d0 8a				call ishlzero 
a668			;		ld a, l 
a668			;		add h 
a668			;		cp 0 
a668 f1					pop af 
a669					 
a669 cc 29 c5				call z,malloc_error 
a66c				endif 
a66c			 
a66c cd 81 98				call forth_push_numhl 
a66f					NEXTW 
a66f c3 ea 9b			jp macro_next 
a672				endm 
# End of macro NEXTW
a672			 
a672			.FREE: 
a672				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a672 57				db WORD_SYS_CORE+67             
a673 a3 a6			dw .LIST            
a675 05				db 4 + 1 
a676 .. 00			db "FREE",0              
a67b				endm 
# End of macro CWHEAD
a67b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a67b					if DEBUG_FORTH_WORDS_KEY 
a67b						DMARK "FRE" 
a67b f5				push af  
a67c 3a 90 a6			ld a, (.dmark)  
a67f 32 c0 ee			ld (debug_mark),a  
a682 3a 91 a6			ld a, (.dmark+1)  
a685 32 c1 ee			ld (debug_mark+1),a  
a688 3a 92 a6			ld a, (.dmark+2)  
a68b 32 c2 ee			ld (debug_mark+2),a  
a68e 18 03			jr .pastdmark  
a690 ..			.dmark: db "FRE"  
a693 f1			.pastdmark: pop af  
a694			endm  
# End of macro DMARK
a694						CALLMONITOR 
a694 cd f4 92			call break_point_state  
a697				endm  
# End of macro CALLMONITOR
a697					endif 
a697					; get address 
a697			 
a697					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a697 cd 78 9a			call macro_dsp_valuehl 
a69a				endm 
# End of macro FORTH_DSP_VALUEHL
a69a			 
a69a			;		push hl 
a69a			 
a69a					; destroy value TOS 
a69a			 
a69a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a69a cd 30 9b			call macro_forth_dsp_pop 
a69d				endm 
# End of macro FORTH_DSP_POP
a69d			 
a69d			;		pop hl 
a69d			if FORTH_ENABLE_MALLOCFREE 
a69d cd 38 90				call free 
a6a0			endif 
a6a0					NEXTW 
a6a0 c3 ea 9b			jp macro_next 
a6a3				endm 
# End of macro NEXTW
a6a3			.LIST: 
a6a3				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a6a3 5c				db WORD_SYS_CORE+72             
a6a4 66 a8			dw .FORGET            
a6a6 05				db 4 + 1 
a6a7 .. 00			db "LIST",0              
a6ac				endm 
# End of macro CWHEAD
a6ac			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a6ac			; | | The quoted word must be in upper case. 
a6ac				if DEBUG_FORTH_WORDS_KEY 
a6ac					DMARK "LST" 
a6ac f5				push af  
a6ad 3a c1 a6			ld a, (.dmark)  
a6b0 32 c0 ee			ld (debug_mark),a  
a6b3 3a c2 a6			ld a, (.dmark+1)  
a6b6 32 c1 ee			ld (debug_mark+1),a  
a6b9 3a c3 a6			ld a, (.dmark+2)  
a6bc 32 c2 ee			ld (debug_mark+2),a  
a6bf 18 03			jr .pastdmark  
a6c1 ..			.dmark: db "LST"  
a6c4 f1			.pastdmark: pop af  
a6c5			endm  
# End of macro DMARK
a6c5					CALLMONITOR 
a6c5 cd f4 92			call break_point_state  
a6c8				endm  
# End of macro CALLMONITOR
a6c8				endif 
a6c8			 
a6c8					FORTH_DSP_VALUEHL 
a6c8 cd 78 9a			call macro_dsp_valuehl 
a6cb				endm 
# End of macro FORTH_DSP_VALUEHL
a6cb			 
a6cb e5					push hl 
a6cc c1					pop bc 
a6cd			 
a6cd			; Start format of scratch string 
a6cd			 
a6cd 21 e6 e4				ld hl, scratch 
a6d0			 
a6d0 3e 3a				ld a, ':' 
a6d2 77					ld (hl),a 
a6d3 23					inc hl 
a6d4 3e 20				ld a, ' ' 
a6d6 77					ld (hl), a 
a6d7			 
a6d7					; Get ptr to the word we need to look up 
a6d7			 
a6d7			;		FORTH_DSP_VALUEHL 
a6d7					;v5 FORTH_DSP_VALUE 
a6d7				; TODO type check 
a6d7			;		inc hl    ; Skip type check  
a6d7			;		push hl 
a6d7			;		ex de, hl    ; put into DE 
a6d7			 
a6d7			 
a6d7 21 74 d8				ld hl, baseram 
a6da					;ld hl, baseusermem 
a6da			 
a6da e5			push hl   ; sacreifical push 
a6db			 
a6db			.ldouscanm: 
a6db e1				pop hl 
a6dc			.ldouscan: 
a6dc				if DEBUG_FORTH_WORDS 
a6dc					DMARK "LSs" 
a6dc f5				push af  
a6dd 3a f1 a6			ld a, (.dmark)  
a6e0 32 c0 ee			ld (debug_mark),a  
a6e3 3a f2 a6			ld a, (.dmark+1)  
a6e6 32 c1 ee			ld (debug_mark+1),a  
a6e9 3a f3 a6			ld a, (.dmark+2)  
a6ec 32 c2 ee			ld (debug_mark+2),a  
a6ef 18 03			jr .pastdmark  
a6f1 ..			.dmark: db "LSs"  
a6f4 f1			.pastdmark: pop af  
a6f5			endm  
# End of macro DMARK
a6f5					CALLMONITOR 
a6f5 cd f4 92			call break_point_state  
a6f8				endm  
# End of macro CALLMONITOR
a6f8				endif 
a6f8				; skip dict stub 
a6f8 cd 3b 9d				call forth_tok_next 
a6fb			 
a6fb			 
a6fb			; while we have words to look for 
a6fb			 
a6fb 7e				ld a, (hl)      
a6fc				if DEBUG_FORTH_WORDS 
a6fc					DMARK "LSk" 
a6fc f5				push af  
a6fd 3a 11 a7			ld a, (.dmark)  
a700 32 c0 ee			ld (debug_mark),a  
a703 3a 12 a7			ld a, (.dmark+1)  
a706 32 c1 ee			ld (debug_mark+1),a  
a709 3a 13 a7			ld a, (.dmark+2)  
a70c 32 c2 ee			ld (debug_mark+2),a  
a70f 18 03			jr .pastdmark  
a711 ..			.dmark: db "LSk"  
a714 f1			.pastdmark: pop af  
a715			endm  
# End of macro DMARK
a715					CALLMONITOR 
a715 cd f4 92			call break_point_state  
a718				endm  
# End of macro CALLMONITOR
a718				endif 
a718 fe 00				cp WORD_SYS_END 
a71a ca 4d a8				jp z, .lunotfound 
a71d fe 01				cp WORD_SYS_UWORD 
a71f c2 dc a6				jp nz, .ldouscan 
a722			 
a722				if DEBUG_FORTH_WORDS 
a722					DMARK "LSu" 
a722 f5				push af  
a723 3a 37 a7			ld a, (.dmark)  
a726 32 c0 ee			ld (debug_mark),a  
a729 3a 38 a7			ld a, (.dmark+1)  
a72c 32 c1 ee			ld (debug_mark+1),a  
a72f 3a 39 a7			ld a, (.dmark+2)  
a732 32 c2 ee			ld (debug_mark+2),a  
a735 18 03			jr .pastdmark  
a737 ..			.dmark: db "LSu"  
a73a f1			.pastdmark: pop af  
a73b			endm  
# End of macro DMARK
a73b					CALLMONITOR 
a73b cd f4 92			call break_point_state  
a73e				endm  
# End of macro CALLMONITOR
a73e				endif 
a73e			 
a73e					; found a uword but is it the one we want... 
a73e			 
a73e c5					push bc     ; uword to find is on bc 
a73f d1					pop de 
a740			 
a740 e5					push hl  ; to save the ptr 
a741			 
a741					; skip opcode 
a741 23					inc hl  
a742					; skip next ptr 
a742 23					inc hl  
a743 23					inc hl 
a744					; skip len 
a744 23					inc hl 
a745			 
a745				if DEBUG_FORTH_WORDS 
a745					DMARK "LSc" 
a745 f5				push af  
a746 3a 5a a7			ld a, (.dmark)  
a749 32 c0 ee			ld (debug_mark),a  
a74c 3a 5b a7			ld a, (.dmark+1)  
a74f 32 c1 ee			ld (debug_mark+1),a  
a752 3a 5c a7			ld a, (.dmark+2)  
a755 32 c2 ee			ld (debug_mark+2),a  
a758 18 03			jr .pastdmark  
a75a ..			.dmark: db "LSc"  
a75d f1			.pastdmark: pop af  
a75e			endm  
# End of macro DMARK
a75e					CALLMONITOR 
a75e cd f4 92			call break_point_state  
a761				endm  
# End of macro CALLMONITOR
a761				endif 
a761 cd 3d 8f				call strcmp 
a764 c2 db a6				jp nz, .ldouscanm 
a767				 
a767			 
a767			 
a767					; we have a uword so push its name to the stack 
a767			 
a767			;	   	push hl  ; save so we can move to next dict block 
a767 e1			pop hl 
a768			 
a768				if DEBUG_FORTH_WORDS 
a768					DMARK "LSm" 
a768 f5				push af  
a769 3a 7d a7			ld a, (.dmark)  
a76c 32 c0 ee			ld (debug_mark),a  
a76f 3a 7e a7			ld a, (.dmark+1)  
a772 32 c1 ee			ld (debug_mark+1),a  
a775 3a 7f a7			ld a, (.dmark+2)  
a778 32 c2 ee			ld (debug_mark+2),a  
a77b 18 03			jr .pastdmark  
a77d ..			.dmark: db "LSm"  
a780 f1			.pastdmark: pop af  
a781			endm  
# End of macro DMARK
a781					CALLMONITOR 
a781 cd f4 92			call break_point_state  
a784				endm  
# End of macro CALLMONITOR
a784				endif 
a784			 
a784					; skip opcode 
a784 23					inc hl  
a785					; skip next ptr 
a785 23					inc hl  
a786 23					inc hl 
a787					; skip len 
a787 7e					ld a, (hl)   ; save length to add 
a788				if DEBUG_FORTH_WORDS 
a788					DMARK "LS2" 
a788 f5				push af  
a789 3a 9d a7			ld a, (.dmark)  
a78c 32 c0 ee			ld (debug_mark),a  
a78f 3a 9e a7			ld a, (.dmark+1)  
a792 32 c1 ee			ld (debug_mark+1),a  
a795 3a 9f a7			ld a, (.dmark+2)  
a798 32 c2 ee			ld (debug_mark+2),a  
a79b 18 03			jr .pastdmark  
a79d ..			.dmark: db "LS2"  
a7a0 f1			.pastdmark: pop af  
a7a1			endm  
# End of macro DMARK
a7a1					CALLMONITOR 
a7a1 cd f4 92			call break_point_state  
a7a4				endm  
# End of macro CALLMONITOR
a7a4				endif 
a7a4			 
a7a4					; save this location 
a7a4				 
a7a4 e5					push hl 
a7a5			 
a7a5 23					inc hl 
a7a6 11 e8 e4				ld de, scratch+2 
a7a9 4f					ld c, a 
a7aa 06 00				ld b, 0 
a7ac			 
a7ac				if DEBUG_FORTH_WORDS 
a7ac					DMARK "LSn" 
a7ac f5				push af  
a7ad 3a c1 a7			ld a, (.dmark)  
a7b0 32 c0 ee			ld (debug_mark),a  
a7b3 3a c2 a7			ld a, (.dmark+1)  
a7b6 32 c1 ee			ld (debug_mark+1),a  
a7b9 3a c3 a7			ld a, (.dmark+2)  
a7bc 32 c2 ee			ld (debug_mark+2),a  
a7bf 18 03			jr .pastdmark  
a7c1 ..			.dmark: db "LSn"  
a7c4 f1			.pastdmark: pop af  
a7c5			endm  
# End of macro DMARK
a7c5					CALLMONITOR 
a7c5 cd f4 92			call break_point_state  
a7c8				endm  
# End of macro CALLMONITOR
a7c8				endif 
a7c8			 
a7c8					; copy uword name to scratch 
a7c8			 
a7c8 ed b0				ldir 
a7ca			 
a7ca 1b					dec de 
a7cb 3e 20				ld a, ' '    ; change null to space 
a7cd 12					ld (de), a 
a7ce			 
a7ce 13					inc de 
a7cf			 
a7cf d5					push de 
a7d0 c1					pop bc     ; move scratch pointer to end of word name and save it 
a7d1			 
a7d1 e1					pop hl 
a7d2 7e					ld a, (hl) 
a7d3					;inc hl 
a7d3					; skip word string 
a7d3 cd a7 8a				call addatohl 
a7d6			 
a7d6 23					inc hl 
a7d7			 
a7d7				if DEBUG_FORTH_WORDS 
a7d7					DMARK "LS3" 
a7d7 f5				push af  
a7d8 3a ec a7			ld a, (.dmark)  
a7db 32 c0 ee			ld (debug_mark),a  
a7de 3a ed a7			ld a, (.dmark+1)  
a7e1 32 c1 ee			ld (debug_mark+1),a  
a7e4 3a ee a7			ld a, (.dmark+2)  
a7e7 32 c2 ee			ld (debug_mark+2),a  
a7ea 18 03			jr .pastdmark  
a7ec ..			.dmark: db "LS3"  
a7ef f1			.pastdmark: pop af  
a7f0			endm  
# End of macro DMARK
a7f0					CALLMONITOR 
a7f0 cd f4 92			call break_point_state  
a7f3				endm  
# End of macro CALLMONITOR
a7f3				endif 
a7f3					; should now be at the start of the machine code to setup the eval of the uword 
a7f3					; now locate the ptr to the string defintion 
a7f3			 
a7f3					; skip ld hl, 
a7f3					; then load the ptr 
a7f3			 
a7f3 23					inc hl 
a7f4 5e					ld e, (hl) 
a7f5 23					inc hl 
a7f6 56					ld d, (hl) 
a7f7 eb					ex de, hl 
a7f8			 
a7f8			 
a7f8				if DEBUG_FORTH_WORDS 
a7f8					DMARK "LSt" 
a7f8 f5				push af  
a7f9 3a 0d a8			ld a, (.dmark)  
a7fc 32 c0 ee			ld (debug_mark),a  
a7ff 3a 0e a8			ld a, (.dmark+1)  
a802 32 c1 ee			ld (debug_mark+1),a  
a805 3a 0f a8			ld a, (.dmark+2)  
a808 32 c2 ee			ld (debug_mark+2),a  
a80b 18 03			jr .pastdmark  
a80d ..			.dmark: db "LSt"  
a810 f1			.pastdmark: pop af  
a811			endm  
# End of macro DMARK
a811					CALLMONITOR 
a811 cd f4 92			call break_point_state  
a814				endm  
# End of macro CALLMONITOR
a814				endif 
a814			 
a814			; cant push right now due to tokenised strings  
a814			 
a814			; get the destination of where to copy this definition to. 
a814			 
a814 c5					push bc 
a815 d1					pop de 
a816			 
a816 7e			.listl:         ld a,(hl) 
a817 fe 00				cp 0 
a819 28 09				jr z, .lreplsp     ; replace zero with space 
a81b fe 7f				cp FORTH_END_BUFFER 
a81d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a81f				 
a81f					; just copy this char as is then 
a81f			 
a81f 12					ld (de), a 
a820			 
a820 23			.listnxt:	inc hl 
a821 13					inc de 
a822 18 f2				jr .listl 
a824			 
a824 3e 20		.lreplsp:	ld a,' ' 
a826 12					ld (de), a 
a827 18 f7				jr .listnxt 
a829			 
a829			; close up uword def 
a829			 
a829			.listdone: 
a829 3e 00				ld a, 0 
a82b 12					ld (de), a 
a82c			 
a82c			; now have def so clean up and push to stack 
a82c			 
a82c 21 e6 e4				ld hl, scratch 
a82f				if DEBUG_FORTH_WORDS 
a82f					DMARK "Ltp" 
a82f f5				push af  
a830 3a 44 a8			ld a, (.dmark)  
a833 32 c0 ee			ld (debug_mark),a  
a836 3a 45 a8			ld a, (.dmark+1)  
a839 32 c1 ee			ld (debug_mark+1),a  
a83c 3a 46 a8			ld a, (.dmark+2)  
a83f 32 c2 ee			ld (debug_mark+2),a  
a842 18 03			jr .pastdmark  
a844 ..			.dmark: db "Ltp"  
a847 f1			.pastdmark: pop af  
a848			endm  
# End of macro DMARK
a848					CALLMONITOR 
a848 cd f4 92			call break_point_state  
a84b				endm  
# End of macro CALLMONITOR
a84b				endif 
a84b			 
a84b 18 06			jr .listpush 
a84d			 
a84d			;.lnuword:	pop hl 
a84d			;		call forth_tok_next 
a84d			;		jp .ldouscan  
a84d			 
a84d			.lunotfound:		  
a84d			 
a84d			 
a84d					 
a84d					FORTH_DSP_POP 
a84d cd 30 9b			call macro_forth_dsp_pop 
a850				endm 
# End of macro FORTH_DSP_POP
a850 21 59 a8				ld hl, .luno 
a853						 
a853			 
a853			.listpush: 
a853 cd ef 98				call forth_push_str 
a856			 
a856			 
a856			 
a856					NEXTW 
a856 c3 ea 9b			jp macro_next 
a859				endm 
# End of macro NEXTW
a859			 
a859 .. 00		.luno:    db "Not found",0 
a863			 
a863			 
a863			 
a863			 
a863			 
a863			;		push hl   ; save pointer to start of uword def string 
a863			; 
a863			;; look for FORTH_EOL_LINE 
a863			;		ld a, FORTH_END_BUFFER 
a863			;		call strlent 
a863			; 
a863			;		inc hl		 ; space for coln def 
a863			;		inc hl 
a863			;		inc hl          ; space for terms 
a863			;		inc hl 
a863			; 
a863			;		ld a, 20   ; TODO get actual length 
a863			;		call addatohl    ; include a random amount of room for the uword name 
a863			; 
a863			;		 
a863			;	if DEBUG_FORTH_WORDS 
a863			;		DMARK "Lt1" 
a863			;		CALLMONITOR 
a863			;	endif 
a863			;		 
a863			; 
a863			;; malloc space for the string because we cant change it 
a863			; 
a863			;		call malloc 
a863			;	if DEBUG_FORTH_MALLOC_GUARD 
a863			;		push af 
a863			;		call ishlzero 
a863			;		pop af 
a863			;		 
a863			;		call z,malloc_error 
a863			;	endif 
a863			; 
a863			;	if DEBUG_FORTH_WORDS 
a863			;		DMARK "Lt2" 
a863			;		CALLMONITOR 
a863			;	endif 
a863			;		pop de 
a863			;		push hl    ; push the malloc to release later 
a863			;		push hl   ;  push back a copy for the later stack push 
a863			;		 
a863			;; copy the string swapping out the zero terms for spaces 
a863			; 
a863			;		; de has our source 
a863			;		; hl has our dest 
a863			; 
a863			;; add the coln def 
a863			; 
a863			;		ld a, ':' 
a863			;		ld (hl), a 
a863			;		inc hl 
a863			;		ld a, ' ' 
a863			;		ld (hl), a 
a863			;		inc hl 
a863			; 
a863			;; add the uname word 
a863			;		push de   ; save our string for now 
a863			;		ex de, hl 
a863			; 
a863			;		FORTH_DSP_VALUE 
a863			;		;v5 FORTH_DSP_VALUE 
a863			; 
a863			;		inc hl   ; skip type but we know by now this is OK 
a863			; 
a863			;.luword:	ld a,(hl) 
a863			;		cp 0 
a863			;		jr z, .luword2 
a863			;		ld (de), a 
a863			;		inc de 
a863			;		inc hl 
a863			;		jr .luword 
a863			; 
a863			;.luword2:	ld a, ' ' 
a863			;		ld (de), a 
a863			;;		inc hl 
a863			;;		inc de 
a863			;;		ld (de), a 
a863			;;		inc hl 
a863			;		inc de 
a863			; 
a863			;		ex de, hl 
a863			;		pop de 
a863			;		 
a863			;		 
a863			; 
a863			;; detoken that string and copy it 
a863			; 
a863			;	if DEBUG_FORTH_WORDS 
a863			;		DMARK "Lt2" 
a863			;		CALLMONITOR 
a863			;	endif 
a863			;.ldetok:	ld a, (de) 
a863			;		cp FORTH_END_BUFFER 
a863			;		jr z, .ldetokend 
a863			;		; swap out any zero term for space 
a863			;		cp 0 
a863			;		jr nz, .ldetoknext 
a863			;		ld a, ' ' 
a863			; 
a863			;	if DEBUG_FORTH_WORDS 
a863			;		DMARK "LtS" 
a863			;		CALLMONITOR 
a863			;	endif 
a863			;.ldetoknext:	ld (hl), a 
a863			;		inc de 
a863			;		inc hl 
a863			;		jr .ldetok 
a863			; 
a863			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a863			;		ld (hl), a  
a863			; 
a863			;; free that temp malloc 
a863			; 
a863			;		pop hl    
a863			; 
a863			;	if DEBUG_FORTH_WORDS 
a863			;		DMARK "Lt4" 
a863			;		CALLMONITOR 
a863			;	endif 
a863			;		call forth_apushstrhl 
a863			; 
a863			;		; get rid of temp malloc area 
a863			; 
a863			;		pop hl 
a863			;		call free 
a863			; 
a863			;		jr .ludone 
a863			; 
a863			;.lnuword:	pop hl 
a863			;		call forth_tok_next 
a863			;		jp .ldouscan  
a863			; 
a863			;.ludone:		 pop hl 
a863			; 
a863					NEXTW 
a863 c3 ea 9b			jp macro_next 
a866				endm 
# End of macro NEXTW
a866			 
a866			.FORGET: 
a866				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a866 5d				db WORD_SYS_CORE+73             
a867 df a8			dw .NOP            
a869 07				db 6 + 1 
a86a .. 00			db "FORGET",0              
a871				endm 
# End of macro CWHEAD
a871			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a871			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a871			; | |  
a871			; | | e.g. "MORE" forget 
a871					if DEBUG_FORTH_WORDS_KEY 
a871						DMARK "FRG" 
a871 f5				push af  
a872 3a 86 a8			ld a, (.dmark)  
a875 32 c0 ee			ld (debug_mark),a  
a878 3a 87 a8			ld a, (.dmark+1)  
a87b 32 c1 ee			ld (debug_mark+1),a  
a87e 3a 88 a8			ld a, (.dmark+2)  
a881 32 c2 ee			ld (debug_mark+2),a  
a884 18 03			jr .pastdmark  
a886 ..			.dmark: db "FRG"  
a889 f1			.pastdmark: pop af  
a88a			endm  
# End of macro DMARK
a88a						CALLMONITOR 
a88a cd f4 92			call break_point_state  
a88d				endm  
# End of macro CALLMONITOR
a88d					endif 
a88d			 
a88d				; find uword 
a88d			        ; update start of word with "_" 
a88d				; replace uword with deleted flag 
a88d			 
a88d			 
a88d			;	if DEBUG_FORTH_WORDS 
a88d			;		DMARK "FOG" 
a88d			;		CALLMONITOR 
a88d			;	endif 
a88d			 
a88d			 
a88d					; Get ptr to the word we need to look up 
a88d			 
a88d					FORTH_DSP_VALUEHL 
a88d cd 78 9a			call macro_dsp_valuehl 
a890				endm 
# End of macro FORTH_DSP_VALUEHL
a890					;v5 FORTH_DSP_VALUE 
a890				; TODO type check 
a890			;		inc hl    ; Skip type check  
a890 e5					push hl 
a891 c1					pop bc 
a892			;		ex de, hl    ; put into DE 
a892			 
a892			 
a892 21 74 d8				ld hl, baseram 
a895					;ld hl, baseusermem 
a895			 
a895				; skip dict stub 
a895			;	call forth_tok_next 
a895 e5			push hl   ; sacreifical push 
a896			 
a896			.fldouscanm: 
a896 e1				pop hl 
a897			.fldouscan: 
a897			;	if DEBUG_FORTH_WORDS 
a897			;		DMARK "LSs" 
a897			;		CALLMONITOR 
a897			;	endif 
a897				; skip dict stub 
a897 cd 3b 9d				call forth_tok_next 
a89a			 
a89a			 
a89a			; while we have words to look for 
a89a			 
a89a 7e				ld a, (hl)      
a89b			;	if DEBUG_FORTH_WORDS 
a89b			;		DMARK "LSk" 
a89b			;		CALLMONITOR 
a89b			;	endif 
a89b fe 00				cp WORD_SYS_END 
a89d ca d9 a8				jp z, .flunotfound 
a8a0 fe 01				cp WORD_SYS_UWORD 
a8a2 c2 97 a8				jp nz, .fldouscan 
a8a5			 
a8a5			;	if DEBUG_FORTH_WORDS 
a8a5			;		DMARK "LSu" 
a8a5			;		CALLMONITOR 
a8a5			;	endif 
a8a5			 
a8a5					; found a uword but is it the one we want... 
a8a5			 
a8a5 c5					push bc     ; uword to find is on bc 
a8a6 d1					pop de 
a8a7			 
a8a7 e5					push hl  ; to save the ptr 
a8a8			 
a8a8					; skip opcode 
a8a8 23					inc hl  
a8a9					; skip next ptr 
a8a9 23					inc hl  
a8aa 23					inc hl 
a8ab					; skip len 
a8ab 23					inc hl 
a8ac			 
a8ac			;	if DEBUG_FORTH_WORDS 
a8ac			;		DMARK "LSc" 
a8ac			;		CALLMONITOR 
a8ac			;	endif 
a8ac cd 3d 8f				call strcmp 
a8af c2 96 a8				jp nz, .fldouscanm 
a8b2			; 
a8b2			; 
a8b2			;; while we have words to look for 
a8b2			; 
a8b2			;.fdouscan:	ld a, (hl)      
a8b2			;	if DEBUG_FORTH_WORDS 
a8b2			;		DMARK "LSs" 
a8b2			;		CALLMONITOR 
a8b2			;	endif 
a8b2			;		cp WORD_SYS_END 
a8b2			;		jp z, .fudone 
a8b2			;		cp WORD_SYS_UWORD 
a8b2			;		jp nz, .fnuword 
a8b2			; 
a8b2			;	if DEBUG_FORTH_WORDS 
a8b2			;		DMARK "FGu" 
a8b2			;		CALLMONITOR 
a8b2			;	endif 
a8b2			; 
a8b2			;		; found a uword but is it the one we want... 
a8b2			; 
a8b2			; 
a8b2			;	        pop de   ; get back the dsp name 
a8b2			;		push de 
a8b2			; 
a8b2			;		push hl  ; to save the ptr 
a8b2			; 
a8b2			;		; skip opcode 
a8b2			;		inc hl  
a8b2			;		; skip next ptr 
a8b2			;		inc hl  
a8b2			;		inc hl 
a8b2			;		; skip len 
a8b2			;		inc hl 
a8b2			; 
a8b2			;	if DEBUG_FORTH_WORDS 
a8b2			;		DMARK "FGc" 
a8b2			;		CALLMONITOR 
a8b2			;	endif 
a8b2			;		call strcmp 
a8b2			;		jp nz, .fnuword 
a8b2			 
a8b2			 
a8b2 e1			pop hl 
a8b3			 
a8b3				 
a8b3				if DEBUG_FORTH_WORDS 
a8b3					DMARK "FGm" 
a8b3 f5				push af  
a8b4 3a c8 a8			ld a, (.dmark)  
a8b7 32 c0 ee			ld (debug_mark),a  
a8ba 3a c9 a8			ld a, (.dmark+1)  
a8bd 32 c1 ee			ld (debug_mark+1),a  
a8c0 3a ca a8			ld a, (.dmark+2)  
a8c3 32 c2 ee			ld (debug_mark+2),a  
a8c6 18 03			jr .pastdmark  
a8c8 ..			.dmark: db "FGm"  
a8cb f1			.pastdmark: pop af  
a8cc			endm  
# End of macro DMARK
a8cc					CALLMONITOR 
a8cc cd f4 92			call break_point_state  
a8cf				endm  
# End of macro CALLMONITOR
a8cf				endif 
a8cf			 
a8cf			 
a8cf			 
a8cf					; we have a uword so push its name to the stack 
a8cf			 
a8cf			;	   	push hl  ; save so we can move to next dict block 
a8cf			;pop hl 
a8cf			 
a8cf					; update opcode to deleted 
a8cf 3e 03				ld a, WORD_SYS_DELETED 
a8d1 77					ld (hl), a 
a8d2			 
a8d2 23					inc hl  
a8d3					; skip next ptr 
a8d3 23					inc hl  
a8d4 23					inc hl 
a8d5					; skip len 
a8d5 23					inc hl 
a8d6			 
a8d6					; TODO change parser to skip deleted words but for now mark it out 
a8d6 3e 5f				ld a, "_" 
a8d8 77					ld  (hl),a 
a8d9			 
a8d9			;		jr .fudone 
a8d9			; 
a8d9			;.fnuword:	pop hl 
a8d9			;		call forth_tok_next 
a8d9			;		jp .fdouscan  
a8d9			 
a8d9			.flunotfound:		  
a8d9			 
a8d9			 
a8d9					 
a8d9					FORTH_DSP_POP 
a8d9 cd 30 9b			call macro_forth_dsp_pop 
a8dc				endm 
# End of macro FORTH_DSP_POP
a8dc			;		ld hl, .luno 
a8dc			;.fudone:		 pop hl 
a8dc					NEXTW 
a8dc c3 ea 9b			jp macro_next 
a8df				endm 
# End of macro NEXTW
a8df			.NOP: 
a8df				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a8df 61				db WORD_SYS_CORE+77             
a8e0 06 a9			dw .COMO            
a8e2 04				db 3 + 1 
a8e3 .. 00			db "NOP",0              
a8e7				endm 
# End of macro CWHEAD
a8e7			; | NOP (  --  ) Do nothing | DONE 
a8e7					if DEBUG_FORTH_WORDS_KEY 
a8e7						DMARK "NOP" 
a8e7 f5				push af  
a8e8 3a fc a8			ld a, (.dmark)  
a8eb 32 c0 ee			ld (debug_mark),a  
a8ee 3a fd a8			ld a, (.dmark+1)  
a8f1 32 c1 ee			ld (debug_mark+1),a  
a8f4 3a fe a8			ld a, (.dmark+2)  
a8f7 32 c2 ee			ld (debug_mark+2),a  
a8fa 18 03			jr .pastdmark  
a8fc ..			.dmark: db "NOP"  
a8ff f1			.pastdmark: pop af  
a900			endm  
# End of macro DMARK
a900						CALLMONITOR 
a900 cd f4 92			call break_point_state  
a903				endm  
# End of macro CALLMONITOR
a903					endif 
a903				       NEXTW 
a903 c3 ea 9b			jp macro_next 
a906				endm 
# End of macro NEXTW
a906			.COMO: 
a906				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a906 6e				db WORD_SYS_CORE+90             
a907 58 a9			dw .COMC            
a909 02				db 1 + 1 
a90a .. 00			db "(",0              
a90c				endm 
# End of macro CWHEAD
a90c			; | ( ( -- )  Start of comment | DONE 
a90c			 
a90c			 
a90c 2a e7 e7				ld hl, ( os_tok_ptr) 
a90f 11 53 a9			ld de, .closepar 
a912					 
a912					if DEBUG_FORTH_WORDS 
a912						DMARK ").." 
a912 f5				push af  
a913 3a 27 a9			ld a, (.dmark)  
a916 32 c0 ee			ld (debug_mark),a  
a919 3a 28 a9			ld a, (.dmark+1)  
a91c 32 c1 ee			ld (debug_mark+1),a  
a91f 3a 29 a9			ld a, (.dmark+2)  
a922 32 c2 ee			ld (debug_mark+2),a  
a925 18 03			jr .pastdmark  
a927 ..			.dmark: db ").."  
a92a f1			.pastdmark: pop af  
a92b			endm  
# End of macro DMARK
a92b						CALLMONITOR 
a92b cd f4 92			call break_point_state  
a92e				endm  
# End of macro CALLMONITOR
a92e					endif 
a92e cd 05 9d			call findnexttok  
a931			 
a931					if DEBUG_FORTH_WORDS 
a931						DMARK "IF5" 
a931 f5				push af  
a932 3a 46 a9			ld a, (.dmark)  
a935 32 c0 ee			ld (debug_mark),a  
a938 3a 47 a9			ld a, (.dmark+1)  
a93b 32 c1 ee			ld (debug_mark+1),a  
a93e 3a 48 a9			ld a, (.dmark+2)  
a941 32 c2 ee			ld (debug_mark+2),a  
a944 18 03			jr .pastdmark  
a946 ..			.dmark: db "IF5"  
a949 f1			.pastdmark: pop af  
a94a			endm  
# End of macro DMARK
a94a						CALLMONITOR 
a94a cd f4 92			call break_point_state  
a94d				endm  
# End of macro CALLMONITOR
a94d					endif 
a94d				; replace below with ) exec using tok_ptr 
a94d 22 e7 e7			ld (os_tok_ptr), hl 
a950 c3 7b 9c			jp exec1 
a953			 
a953 .. 00			.closepar:   db ")",0 
a955			 
a955				       NEXTW 
a955 c3 ea 9b			jp macro_next 
a958				endm 
# End of macro NEXTW
a958			.COMC: 
a958				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a958 6f				db WORD_SYS_CORE+91             
a959 61 a9			dw .SCRATCH            
a95b 02				db 1 + 1 
a95c .. 00			db ")",0              
a95e				endm 
# End of macro CWHEAD
a95e			; | ) ( -- )  End of comment |  DONE  
a95e				       NEXTW 
a95e c3 ea 9b			jp macro_next 
a961				endm 
# End of macro NEXTW
a961			 
a961			.SCRATCH: 
a961				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a961 6f				db WORD_SYS_CORE+91             
a962 9c a9			dw .INC            
a964 08				db 7 + 1 
a965 .. 00			db "SCRATCH",0              
a96d				endm 
# End of macro CWHEAD
a96d			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a96d			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a96d			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a96d			; | |  
a96d			; | | e.g.    : score $00 scratch ; 
a96d			; | |  
a96d			; | | $00 score ! 
a96d			; | | $01 score +! 
a96d			; | |  
a96d			; | | e.g.   : varword $0a scratch ;  
a96d			; | | 
a96d			; | | $8000 varword ! 
a96d					if DEBUG_FORTH_WORDS_KEY 
a96d						DMARK "SCR" 
a96d f5				push af  
a96e 3a 82 a9			ld a, (.dmark)  
a971 32 c0 ee			ld (debug_mark),a  
a974 3a 83 a9			ld a, (.dmark+1)  
a977 32 c1 ee			ld (debug_mark+1),a  
a97a 3a 84 a9			ld a, (.dmark+2)  
a97d 32 c2 ee			ld (debug_mark+2),a  
a980 18 03			jr .pastdmark  
a982 ..			.dmark: db "SCR"  
a985 f1			.pastdmark: pop af  
a986			endm  
# End of macro DMARK
a986						CALLMONITOR 
a986 cd f4 92			call break_point_state  
a989				endm  
# End of macro CALLMONITOR
a989					endif 
a989			 
a989					FORTH_DSP_VALUEHL 
a989 cd 78 9a			call macro_dsp_valuehl 
a98c				endm 
# End of macro FORTH_DSP_VALUEHL
a98c				 
a98c					FORTH_DSP_POP 
a98c cd 30 9b			call macro_forth_dsp_pop 
a98f				endm 
# End of macro FORTH_DSP_POP
a98f			 
a98f 7d					ld a, l 
a990 21 0b ea				ld hl, os_var_array 
a993 cd a7 8a				call addatohl 
a996			 
a996 cd 81 98				call forth_push_numhl 
a999			 
a999				       NEXTW 
a999 c3 ea 9b			jp macro_next 
a99c				endm 
# End of macro NEXTW
a99c			 
a99c			.INC: 
a99c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a99c 6f				db WORD_SYS_CORE+91             
a99d f0 a9			dw .DEC            
a99f 03				db 2 + 1 
a9a0 .. 00			db "+!",0              
a9a3				endm 
# End of macro CWHEAD
a9a3			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a9a3					if DEBUG_FORTH_WORDS_KEY 
a9a3						DMARK "+s_" 
a9a3 f5				push af  
a9a4 3a b8 a9			ld a, (.dmark)  
a9a7 32 c0 ee			ld (debug_mark),a  
a9aa 3a b9 a9			ld a, (.dmark+1)  
a9ad 32 c1 ee			ld (debug_mark+1),a  
a9b0 3a ba a9			ld a, (.dmark+2)  
a9b3 32 c2 ee			ld (debug_mark+2),a  
a9b6 18 03			jr .pastdmark  
a9b8 ..			.dmark: db "+s_"  
a9bb f1			.pastdmark: pop af  
a9bc			endm  
# End of macro DMARK
a9bc						CALLMONITOR 
a9bc cd f4 92			call break_point_state  
a9bf				endm  
# End of macro CALLMONITOR
a9bf					endif 
a9bf			 
a9bf					FORTH_DSP_VALUEHL 
a9bf cd 78 9a			call macro_dsp_valuehl 
a9c2				endm 
# End of macro FORTH_DSP_VALUEHL
a9c2			 
a9c2 e5					push hl   ; save address 
a9c3			 
a9c3					FORTH_DSP_POP 
a9c3 cd 30 9b			call macro_forth_dsp_pop 
a9c6				endm 
# End of macro FORTH_DSP_POP
a9c6			 
a9c6					FORTH_DSP_VALUEHL 
a9c6 cd 78 9a			call macro_dsp_valuehl 
a9c9				endm 
# End of macro FORTH_DSP_VALUEHL
a9c9			 
a9c9					FORTH_DSP_POP 
a9c9 cd 30 9b			call macro_forth_dsp_pop 
a9cc				endm 
# End of macro FORTH_DSP_POP
a9cc			 
a9cc					; hl contains value to add to byte at a 
a9cc				 
a9cc eb					ex de, hl 
a9cd			 
a9cd e1					pop hl 
a9ce			 
a9ce					if DEBUG_FORTH_WORDS 
a9ce						DMARK "INC" 
a9ce f5				push af  
a9cf 3a e3 a9			ld a, (.dmark)  
a9d2 32 c0 ee			ld (debug_mark),a  
a9d5 3a e4 a9			ld a, (.dmark+1)  
a9d8 32 c1 ee			ld (debug_mark+1),a  
a9db 3a e5 a9			ld a, (.dmark+2)  
a9de 32 c2 ee			ld (debug_mark+2),a  
a9e1 18 03			jr .pastdmark  
a9e3 ..			.dmark: db "INC"  
a9e6 f1			.pastdmark: pop af  
a9e7			endm  
# End of macro DMARK
a9e7						CALLMONITOR 
a9e7 cd f4 92			call break_point_state  
a9ea				endm  
# End of macro CALLMONITOR
a9ea					endif 
a9ea			 
a9ea 7e					ld a,(hl) 
a9eb 83					add e 
a9ec 77					ld (hl),a 
a9ed			 
a9ed			 
a9ed			 
a9ed				       NEXTW 
a9ed c3 ea 9b			jp macro_next 
a9f0				endm 
# End of macro NEXTW
a9f0			 
a9f0			.DEC: 
a9f0				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a9f0 6f				db WORD_SYS_CORE+91             
a9f1 41 aa			dw .INC2            
a9f3 03				db 2 + 1 
a9f4 .. 00			db "-!",0              
a9f7				endm 
# End of macro CWHEAD
a9f7			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a9f7					if DEBUG_FORTH_WORDS_KEY 
a9f7						DMARK "-s_" 
a9f7 f5				push af  
a9f8 3a 0c aa			ld a, (.dmark)  
a9fb 32 c0 ee			ld (debug_mark),a  
a9fe 3a 0d aa			ld a, (.dmark+1)  
aa01 32 c1 ee			ld (debug_mark+1),a  
aa04 3a 0e aa			ld a, (.dmark+2)  
aa07 32 c2 ee			ld (debug_mark+2),a  
aa0a 18 03			jr .pastdmark  
aa0c ..			.dmark: db "-s_"  
aa0f f1			.pastdmark: pop af  
aa10			endm  
# End of macro DMARK
aa10						CALLMONITOR 
aa10 cd f4 92			call break_point_state  
aa13				endm  
# End of macro CALLMONITOR
aa13					endif 
aa13			 
aa13					FORTH_DSP_VALUEHL 
aa13 cd 78 9a			call macro_dsp_valuehl 
aa16				endm 
# End of macro FORTH_DSP_VALUEHL
aa16			 
aa16 e5					push hl   ; save address 
aa17			 
aa17					FORTH_DSP_POP 
aa17 cd 30 9b			call macro_forth_dsp_pop 
aa1a				endm 
# End of macro FORTH_DSP_POP
aa1a			 
aa1a					FORTH_DSP_VALUEHL 
aa1a cd 78 9a			call macro_dsp_valuehl 
aa1d				endm 
# End of macro FORTH_DSP_VALUEHL
aa1d			 
aa1d					; hl contains value to add to byte at a 
aa1d				 
aa1d eb					ex de, hl 
aa1e			 
aa1e e1					pop hl 
aa1f			 
aa1f					if DEBUG_FORTH_WORDS 
aa1f						DMARK "DEC" 
aa1f f5				push af  
aa20 3a 34 aa			ld a, (.dmark)  
aa23 32 c0 ee			ld (debug_mark),a  
aa26 3a 35 aa			ld a, (.dmark+1)  
aa29 32 c1 ee			ld (debug_mark+1),a  
aa2c 3a 36 aa			ld a, (.dmark+2)  
aa2f 32 c2 ee			ld (debug_mark+2),a  
aa32 18 03			jr .pastdmark  
aa34 ..			.dmark: db "DEC"  
aa37 f1			.pastdmark: pop af  
aa38			endm  
# End of macro DMARK
aa38						CALLMONITOR 
aa38 cd f4 92			call break_point_state  
aa3b				endm  
# End of macro CALLMONITOR
aa3b					endif 
aa3b			 
aa3b 7e					ld a,(hl) 
aa3c 93					sub e 
aa3d 77					ld (hl),a 
aa3e			 
aa3e			 
aa3e			 
aa3e				       NEXTW 
aa3e c3 ea 9b			jp macro_next 
aa41				endm 
# End of macro NEXTW
aa41			 
aa41			.INC2: 
aa41				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
aa41 6f				db WORD_SYS_CORE+91             
aa42 eb aa			dw .DEC2            
aa44 04				db 3 + 1 
aa45 .. 00			db "+2!",0              
aa49				endm 
# End of macro CWHEAD
aa49			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
aa49			 
aa49					if DEBUG_FORTH_WORDS_KEY 
aa49						DMARK "+2s" 
aa49 f5				push af  
aa4a 3a 5e aa			ld a, (.dmark)  
aa4d 32 c0 ee			ld (debug_mark),a  
aa50 3a 5f aa			ld a, (.dmark+1)  
aa53 32 c1 ee			ld (debug_mark+1),a  
aa56 3a 60 aa			ld a, (.dmark+2)  
aa59 32 c2 ee			ld (debug_mark+2),a  
aa5c 18 03			jr .pastdmark  
aa5e ..			.dmark: db "+2s"  
aa61 f1			.pastdmark: pop af  
aa62			endm  
# End of macro DMARK
aa62						CALLMONITOR 
aa62 cd f4 92			call break_point_state  
aa65				endm  
# End of macro CALLMONITOR
aa65					endif 
aa65			 
aa65					; Address 
aa65			 
aa65					FORTH_DSP_VALUEHL 
aa65 cd 78 9a			call macro_dsp_valuehl 
aa68				endm 
# End of macro FORTH_DSP_VALUEHL
aa68			 
aa68 e5					push hl    ; save address 
aa69			 
aa69					; load content into de 
aa69			 
aa69 5e					ld e,(hl) 
aa6a 23					inc hl 
aa6b 56					ld d, (hl) 
aa6c			 
aa6c					if DEBUG_FORTH_WORDS 
aa6c						DMARK "+2a" 
aa6c f5				push af  
aa6d 3a 81 aa			ld a, (.dmark)  
aa70 32 c0 ee			ld (debug_mark),a  
aa73 3a 82 aa			ld a, (.dmark+1)  
aa76 32 c1 ee			ld (debug_mark+1),a  
aa79 3a 83 aa			ld a, (.dmark+2)  
aa7c 32 c2 ee			ld (debug_mark+2),a  
aa7f 18 03			jr .pastdmark  
aa81 ..			.dmark: db "+2a"  
aa84 f1			.pastdmark: pop af  
aa85			endm  
# End of macro DMARK
aa85						CALLMONITOR 
aa85 cd f4 92			call break_point_state  
aa88				endm  
# End of macro CALLMONITOR
aa88					endif 
aa88			 
aa88					FORTH_DSP_POP 
aa88 cd 30 9b			call macro_forth_dsp_pop 
aa8b				endm 
# End of macro FORTH_DSP_POP
aa8b			 
aa8b					; Get value to add 
aa8b			 
aa8b					FORTH_DSP_VALUE 
aa8b cd 61 9a			call macro_forth_dsp_value 
aa8e				endm 
# End of macro FORTH_DSP_VALUE
aa8e			 
aa8e					if DEBUG_FORTH_WORDS 
aa8e						DMARK "+2v" 
aa8e f5				push af  
aa8f 3a a3 aa			ld a, (.dmark)  
aa92 32 c0 ee			ld (debug_mark),a  
aa95 3a a4 aa			ld a, (.dmark+1)  
aa98 32 c1 ee			ld (debug_mark+1),a  
aa9b 3a a5 aa			ld a, (.dmark+2)  
aa9e 32 c2 ee			ld (debug_mark+2),a  
aaa1 18 03			jr .pastdmark  
aaa3 ..			.dmark: db "+2v"  
aaa6 f1			.pastdmark: pop af  
aaa7			endm  
# End of macro DMARK
aaa7						CALLMONITOR 
aaa7 cd f4 92			call break_point_state  
aaaa				endm  
# End of macro CALLMONITOR
aaaa					endif 
aaaa			 
aaaa 19					add hl, de 
aaab			 
aaab					if DEBUG_FORTH_WORDS 
aaab						DMARK "+2+" 
aaab f5				push af  
aaac 3a c0 aa			ld a, (.dmark)  
aaaf 32 c0 ee			ld (debug_mark),a  
aab2 3a c1 aa			ld a, (.dmark+1)  
aab5 32 c1 ee			ld (debug_mark+1),a  
aab8 3a c2 aa			ld a, (.dmark+2)  
aabb 32 c2 ee			ld (debug_mark+2),a  
aabe 18 03			jr .pastdmark  
aac0 ..			.dmark: db "+2+"  
aac3 f1			.pastdmark: pop af  
aac4			endm  
# End of macro DMARK
aac4						CALLMONITOR 
aac4 cd f4 92			call break_point_state  
aac7				endm  
# End of macro CALLMONITOR
aac7					endif 
aac7			 
aac7					; move result to de 
aac7			 
aac7 eb					ex de, hl 
aac8			 
aac8					; Address 
aac8			 
aac8 e1					pop hl 
aac9			 
aac9					; save it back 
aac9			 
aac9 73					ld (hl), e 
aaca 23					inc hl 
aacb 72					ld (hl), d 
aacc			 
aacc					if DEBUG_FORTH_WORDS 
aacc						DMARK "+2e" 
aacc f5				push af  
aacd 3a e1 aa			ld a, (.dmark)  
aad0 32 c0 ee			ld (debug_mark),a  
aad3 3a e2 aa			ld a, (.dmark+1)  
aad6 32 c1 ee			ld (debug_mark+1),a  
aad9 3a e3 aa			ld a, (.dmark+2)  
aadc 32 c2 ee			ld (debug_mark+2),a  
aadf 18 03			jr .pastdmark  
aae1 ..			.dmark: db "+2e"  
aae4 f1			.pastdmark: pop af  
aae5			endm  
# End of macro DMARK
aae5						CALLMONITOR 
aae5 cd f4 92			call break_point_state  
aae8				endm  
# End of macro CALLMONITOR
aae8					endif 
aae8			 
aae8			 
aae8			 
aae8			 
aae8			 
aae8				       NEXTW 
aae8 c3 ea 9b			jp macro_next 
aaeb				endm 
# End of macro NEXTW
aaeb			 
aaeb			.DEC2: 
aaeb				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aaeb 6f				db WORD_SYS_CORE+91             
aaec 97 ab			dw .GET2            
aaee 04				db 3 + 1 
aaef .. 00			db "-2!",0              
aaf3				endm 
# End of macro CWHEAD
aaf3			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aaf3			 
aaf3			 
aaf3					if DEBUG_FORTH_WORDS_KEY 
aaf3						DMARK "-2s" 
aaf3 f5				push af  
aaf4 3a 08 ab			ld a, (.dmark)  
aaf7 32 c0 ee			ld (debug_mark),a  
aafa 3a 09 ab			ld a, (.dmark+1)  
aafd 32 c1 ee			ld (debug_mark+1),a  
ab00 3a 0a ab			ld a, (.dmark+2)  
ab03 32 c2 ee			ld (debug_mark+2),a  
ab06 18 03			jr .pastdmark  
ab08 ..			.dmark: db "-2s"  
ab0b f1			.pastdmark: pop af  
ab0c			endm  
# End of macro DMARK
ab0c						CALLMONITOR 
ab0c cd f4 92			call break_point_state  
ab0f				endm  
# End of macro CALLMONITOR
ab0f					endif 
ab0f			 
ab0f					; Address 
ab0f			 
ab0f					FORTH_DSP_VALUEHL 
ab0f cd 78 9a			call macro_dsp_valuehl 
ab12				endm 
# End of macro FORTH_DSP_VALUEHL
ab12			 
ab12 e5					push hl    ; save address 
ab13			 
ab13					; load content into de 
ab13			 
ab13 5e					ld e,(hl) 
ab14 23					inc hl 
ab15 56					ld d, (hl) 
ab16			 
ab16					if DEBUG_FORTH_WORDS 
ab16						DMARK "-2a" 
ab16 f5				push af  
ab17 3a 2b ab			ld a, (.dmark)  
ab1a 32 c0 ee			ld (debug_mark),a  
ab1d 3a 2c ab			ld a, (.dmark+1)  
ab20 32 c1 ee			ld (debug_mark+1),a  
ab23 3a 2d ab			ld a, (.dmark+2)  
ab26 32 c2 ee			ld (debug_mark+2),a  
ab29 18 03			jr .pastdmark  
ab2b ..			.dmark: db "-2a"  
ab2e f1			.pastdmark: pop af  
ab2f			endm  
# End of macro DMARK
ab2f						CALLMONITOR 
ab2f cd f4 92			call break_point_state  
ab32				endm  
# End of macro CALLMONITOR
ab32					endif 
ab32			 
ab32					FORTH_DSP_POP 
ab32 cd 30 9b			call macro_forth_dsp_pop 
ab35				endm 
# End of macro FORTH_DSP_POP
ab35			 
ab35					; Get value to remove 
ab35			 
ab35					FORTH_DSP_VALUE 
ab35 cd 61 9a			call macro_forth_dsp_value 
ab38				endm 
# End of macro FORTH_DSP_VALUE
ab38			 
ab38					if DEBUG_FORTH_WORDS 
ab38						DMARK "-2v" 
ab38 f5				push af  
ab39 3a 4d ab			ld a, (.dmark)  
ab3c 32 c0 ee			ld (debug_mark),a  
ab3f 3a 4e ab			ld a, (.dmark+1)  
ab42 32 c1 ee			ld (debug_mark+1),a  
ab45 3a 4f ab			ld a, (.dmark+2)  
ab48 32 c2 ee			ld (debug_mark+2),a  
ab4b 18 03			jr .pastdmark  
ab4d ..			.dmark: db "-2v"  
ab50 f1			.pastdmark: pop af  
ab51			endm  
# End of macro DMARK
ab51						CALLMONITOR 
ab51 cd f4 92			call break_point_state  
ab54				endm  
# End of macro CALLMONITOR
ab54					endif 
ab54			 
ab54 eb					ex de, hl 
ab55 ed 52				sbc hl, de 
ab57			 
ab57					if DEBUG_FORTH_WORDS 
ab57						DMARK "-2d" 
ab57 f5				push af  
ab58 3a 6c ab			ld a, (.dmark)  
ab5b 32 c0 ee			ld (debug_mark),a  
ab5e 3a 6d ab			ld a, (.dmark+1)  
ab61 32 c1 ee			ld (debug_mark+1),a  
ab64 3a 6e ab			ld a, (.dmark+2)  
ab67 32 c2 ee			ld (debug_mark+2),a  
ab6a 18 03			jr .pastdmark  
ab6c ..			.dmark: db "-2d"  
ab6f f1			.pastdmark: pop af  
ab70			endm  
# End of macro DMARK
ab70						CALLMONITOR 
ab70 cd f4 92			call break_point_state  
ab73				endm  
# End of macro CALLMONITOR
ab73					endif 
ab73			 
ab73					; move result to de 
ab73			 
ab73 eb					ex de, hl 
ab74			 
ab74					; Address 
ab74			 
ab74 e1					pop hl 
ab75			 
ab75					; save it back 
ab75			 
ab75 73					ld (hl), e 
ab76 23					inc hl 
ab77 72					ld (hl), d 
ab78			 
ab78					if DEBUG_FORTH_WORDS 
ab78						DMARK "-2e" 
ab78 f5				push af  
ab79 3a 8d ab			ld a, (.dmark)  
ab7c 32 c0 ee			ld (debug_mark),a  
ab7f 3a 8e ab			ld a, (.dmark+1)  
ab82 32 c1 ee			ld (debug_mark+1),a  
ab85 3a 8f ab			ld a, (.dmark+2)  
ab88 32 c2 ee			ld (debug_mark+2),a  
ab8b 18 03			jr .pastdmark  
ab8d ..			.dmark: db "-2e"  
ab90 f1			.pastdmark: pop af  
ab91			endm  
# End of macro DMARK
ab91						CALLMONITOR 
ab91 cd f4 92			call break_point_state  
ab94				endm  
# End of macro CALLMONITOR
ab94					endif 
ab94			 
ab94			 
ab94			 
ab94			 
ab94			 
ab94				       NEXTW 
ab94 c3 ea 9b			jp macro_next 
ab97				endm 
# End of macro NEXTW
ab97			.GET2: 
ab97				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ab97 6f				db WORD_SYS_CORE+91             
ab98 c7 ab			dw .BANG2            
ab9a 03				db 2 + 1 
ab9b .. 00			db "2@",0              
ab9e				endm 
# End of macro CWHEAD
ab9e			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ab9e					if DEBUG_FORTH_WORDS_KEY 
ab9e						DMARK "2A_" 
ab9e f5				push af  
ab9f 3a b3 ab			ld a, (.dmark)  
aba2 32 c0 ee			ld (debug_mark),a  
aba5 3a b4 ab			ld a, (.dmark+1)  
aba8 32 c1 ee			ld (debug_mark+1),a  
abab 3a b5 ab			ld a, (.dmark+2)  
abae 32 c2 ee			ld (debug_mark+2),a  
abb1 18 03			jr .pastdmark  
abb3 ..			.dmark: db "2A_"  
abb6 f1			.pastdmark: pop af  
abb7			endm  
# End of macro DMARK
abb7						CALLMONITOR 
abb7 cd f4 92			call break_point_state  
abba				endm  
# End of macro CALLMONITOR
abba					endif 
abba			 
abba					FORTH_DSP_VALUEHL 
abba cd 78 9a			call macro_dsp_valuehl 
abbd				endm 
# End of macro FORTH_DSP_VALUEHL
abbd			 
abbd 5e					ld e, (hl) 
abbe 23					inc hl 
abbf 56					ld d, (hl) 
abc0			 
abc0 eb					ex de, hl 
abc1			 
abc1 cd 81 98				call forth_push_numhl 
abc4			 
abc4				       NEXTW 
abc4 c3 ea 9b			jp macro_next 
abc7				endm 
# End of macro NEXTW
abc7			.BANG2: 
abc7				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
abc7 6f				db WORD_SYS_CORE+91             
abc8 ff ab			dw .CONFIG            
abca 03				db 2 + 1 
abcb .. 00			db "2!",0              
abce				endm 
# End of macro CWHEAD
abce			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
abce					if DEBUG_FORTH_WORDS_KEY 
abce						DMARK "2S_" 
abce f5				push af  
abcf 3a e3 ab			ld a, (.dmark)  
abd2 32 c0 ee			ld (debug_mark),a  
abd5 3a e4 ab			ld a, (.dmark+1)  
abd8 32 c1 ee			ld (debug_mark+1),a  
abdb 3a e5 ab			ld a, (.dmark+2)  
abde 32 c2 ee			ld (debug_mark+2),a  
abe1 18 03			jr .pastdmark  
abe3 ..			.dmark: db "2S_"  
abe6 f1			.pastdmark: pop af  
abe7			endm  
# End of macro DMARK
abe7						CALLMONITOR 
abe7 cd f4 92			call break_point_state  
abea				endm  
# End of macro CALLMONITOR
abea					endif 
abea			 
abea					FORTH_DSP_VALUEHL 
abea cd 78 9a			call macro_dsp_valuehl 
abed				endm 
# End of macro FORTH_DSP_VALUEHL
abed			 
abed e5					push hl   ; save address 
abee			 
abee			 
abee					FORTH_DSP_POP 
abee cd 30 9b			call macro_forth_dsp_pop 
abf1				endm 
# End of macro FORTH_DSP_POP
abf1			 
abf1					 
abf1					FORTH_DSP_VALUEHL 
abf1 cd 78 9a			call macro_dsp_valuehl 
abf4				endm 
# End of macro FORTH_DSP_VALUEHL
abf4			 
abf4					FORTH_DSP_POP 
abf4 cd 30 9b			call macro_forth_dsp_pop 
abf7				endm 
# End of macro FORTH_DSP_POP
abf7			 
abf7 eb					ex de, hl    ; value now in de 
abf8			 
abf8 e1					pop hl 
abf9			 
abf9 73					ld (hl), e 
abfa			 
abfa 23					inc hl 
abfb			 
abfb 72					ld (hl), d 
abfc			 
abfc			 
abfc				       NEXTW 
abfc c3 ea 9b			jp macro_next 
abff				endm 
# End of macro NEXTW
abff			.CONFIG: 
abff				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
abff 6f				db WORD_SYS_CORE+91             
ac00 10 ac			dw .ENDCORE            
ac02 07				db 6 + 1 
ac03 .. 00			db "CONFIG",0              
ac0a				endm 
# End of macro CWHEAD
ac0a			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
ac0a			 
ac0a cd 07 91				call config 
ac0d					NEXTW 
ac0d c3 ea 9b			jp macro_next 
ac10				endm 
# End of macro NEXTW
ac10			.ENDCORE: 
ac10			 
ac10			; eof 
ac10			 
ac10			 
# End of file forth_words_core.asm
ac10			include "forth_words_flow.asm" 
ac10			 
ac10			; | ## Program Flow Words 
ac10			 
ac10			.IF: 
ac10				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ac10 1e				db WORD_SYS_CORE+10             
ac11 05 ad			dw .THEN            
ac13 03				db 2 + 1 
ac14 .. 00			db "IF",0              
ac17				endm 
# End of macro CWHEAD
ac17			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ac17			; 
ac17					if DEBUG_FORTH_WORDS_KEY 
ac17						DMARK "IF." 
ac17 f5				push af  
ac18 3a 2c ac			ld a, (.dmark)  
ac1b 32 c0 ee			ld (debug_mark),a  
ac1e 3a 2d ac			ld a, (.dmark+1)  
ac21 32 c1 ee			ld (debug_mark+1),a  
ac24 3a 2e ac			ld a, (.dmark+2)  
ac27 32 c2 ee			ld (debug_mark+2),a  
ac2a 18 03			jr .pastdmark  
ac2c ..			.dmark: db "IF."  
ac2f f1			.pastdmark: pop af  
ac30			endm  
# End of macro DMARK
ac30						CALLMONITOR 
ac30 cd f4 92			call break_point_state  
ac33				endm  
# End of macro CALLMONITOR
ac33					endif 
ac33			; eval TOS 
ac33			 
ac33				FORTH_DSP_VALUEHL 
ac33 cd 78 9a			call macro_dsp_valuehl 
ac36				endm 
# End of macro FORTH_DSP_VALUEHL
ac36			 
ac36			;	push hl 
ac36				FORTH_DSP_POP 
ac36 cd 30 9b			call macro_forth_dsp_pop 
ac39				endm 
# End of macro FORTH_DSP_POP
ac39			;	pop hl 
ac39			 
ac39					if DEBUG_FORTH_WORDS 
ac39						DMARK "IF1" 
ac39 f5				push af  
ac3a 3a 4e ac			ld a, (.dmark)  
ac3d 32 c0 ee			ld (debug_mark),a  
ac40 3a 4f ac			ld a, (.dmark+1)  
ac43 32 c1 ee			ld (debug_mark+1),a  
ac46 3a 50 ac			ld a, (.dmark+2)  
ac49 32 c2 ee			ld (debug_mark+2),a  
ac4c 18 03			jr .pastdmark  
ac4e ..			.dmark: db "IF1"  
ac51 f1			.pastdmark: pop af  
ac52			endm  
# End of macro DMARK
ac52						CALLMONITOR 
ac52 cd f4 92			call break_point_state  
ac55				endm  
# End of macro CALLMONITOR
ac55					endif 
ac55 b7				or a        ; clear carry flag 
ac56 11 00 00			ld de, 0 
ac59 eb				ex de,hl 
ac5a ed 52			sbc hl, de 
ac5c c2 e6 ac			jp nz, .iftrue 
ac5f			 
ac5f					if DEBUG_FORTH_WORDS 
ac5f						DMARK "IF2" 
ac5f f5				push af  
ac60 3a 74 ac			ld a, (.dmark)  
ac63 32 c0 ee			ld (debug_mark),a  
ac66 3a 75 ac			ld a, (.dmark+1)  
ac69 32 c1 ee			ld (debug_mark+1),a  
ac6c 3a 76 ac			ld a, (.dmark+2)  
ac6f 32 c2 ee			ld (debug_mark+2),a  
ac72 18 03			jr .pastdmark  
ac74 ..			.dmark: db "IF2"  
ac77 f1			.pastdmark: pop af  
ac78			endm  
# End of macro DMARK
ac78						CALLMONITOR 
ac78 cd f4 92			call break_point_state  
ac7b				endm  
# End of macro CALLMONITOR
ac7b					endif 
ac7b			 
ac7b			; if not true then skip to THEN 
ac7b			 
ac7b				; TODO get tok_ptr 
ac7b				; TODO consume toks until we get to THEN 
ac7b			 
ac7b 2a e7 e7			ld hl, (os_tok_ptr) 
ac7e					if DEBUG_FORTH_WORDS 
ac7e						DMARK "IF3" 
ac7e f5				push af  
ac7f 3a 93 ac			ld a, (.dmark)  
ac82 32 c0 ee			ld (debug_mark),a  
ac85 3a 94 ac			ld a, (.dmark+1)  
ac88 32 c1 ee			ld (debug_mark+1),a  
ac8b 3a 95 ac			ld a, (.dmark+2)  
ac8e 32 c2 ee			ld (debug_mark+2),a  
ac91 18 03			jr .pastdmark  
ac93 ..			.dmark: db "IF3"  
ac96 f1			.pastdmark: pop af  
ac97			endm  
# End of macro DMARK
ac97						CALLMONITOR 
ac97 cd f4 92			call break_point_state  
ac9a				endm  
# End of macro CALLMONITOR
ac9a						 
ac9a					endif 
ac9a 11 e1 ac			ld de, .ifthen 
ac9d					if DEBUG_FORTH_WORDS 
ac9d						DMARK "IF4" 
ac9d f5				push af  
ac9e 3a b2 ac			ld a, (.dmark)  
aca1 32 c0 ee			ld (debug_mark),a  
aca4 3a b3 ac			ld a, (.dmark+1)  
aca7 32 c1 ee			ld (debug_mark+1),a  
acaa 3a b4 ac			ld a, (.dmark+2)  
acad 32 c2 ee			ld (debug_mark+2),a  
acb0 18 03			jr .pastdmark  
acb2 ..			.dmark: db "IF4"  
acb5 f1			.pastdmark: pop af  
acb6			endm  
# End of macro DMARK
acb6						CALLMONITOR 
acb6 cd f4 92			call break_point_state  
acb9				endm  
# End of macro CALLMONITOR
acb9					endif 
acb9 cd 05 9d			call findnexttok  
acbc			 
acbc					if DEBUG_FORTH_WORDS 
acbc						DMARK "IF5" 
acbc f5				push af  
acbd 3a d1 ac			ld a, (.dmark)  
acc0 32 c0 ee			ld (debug_mark),a  
acc3 3a d2 ac			ld a, (.dmark+1)  
acc6 32 c1 ee			ld (debug_mark+1),a  
acc9 3a d3 ac			ld a, (.dmark+2)  
accc 32 c2 ee			ld (debug_mark+2),a  
accf 18 03			jr .pastdmark  
acd1 ..			.dmark: db "IF5"  
acd4 f1			.pastdmark: pop af  
acd5			endm  
# End of macro DMARK
acd5						CALLMONITOR 
acd5 cd f4 92			call break_point_state  
acd8				endm  
# End of macro CALLMONITOR
acd8					endif 
acd8				; TODO replace below with ; exec using tok_ptr 
acd8 22 e7 e7			ld (os_tok_ptr), hl 
acdb c3 7b 9c			jp exec1 
acde				NEXTW 
acde c3 ea 9b			jp macro_next 
ace1				endm 
# End of macro NEXTW
ace1			 
ace1 .. 00		.ifthen:  db "THEN",0 
ace6			 
ace6			.iftrue:		 
ace6				; Exec next words normally 
ace6			 
ace6				; if true then exec following IF as normal 
ace6					if DEBUG_FORTH_WORDS 
ace6						DMARK "IFT" 
ace6 f5				push af  
ace7 3a fb ac			ld a, (.dmark)  
acea 32 c0 ee			ld (debug_mark),a  
aced 3a fc ac			ld a, (.dmark+1)  
acf0 32 c1 ee			ld (debug_mark+1),a  
acf3 3a fd ac			ld a, (.dmark+2)  
acf6 32 c2 ee			ld (debug_mark+2),a  
acf9 18 03			jr .pastdmark  
acfb ..			.dmark: db "IFT"  
acfe f1			.pastdmark: pop af  
acff			endm  
# End of macro DMARK
acff						CALLMONITOR 
acff cd f4 92			call break_point_state  
ad02				endm  
# End of macro CALLMONITOR
ad02					endif 
ad02			 
ad02					NEXTW 
ad02 c3 ea 9b			jp macro_next 
ad05				endm 
# End of macro NEXTW
ad05			.THEN: 
ad05				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ad05 1f				db WORD_SYS_CORE+11             
ad06 2d ad			dw .ELSE            
ad08 05				db 4 + 1 
ad09 .. 00			db "THEN",0              
ad0e				endm 
# End of macro CWHEAD
ad0e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ad0e					if DEBUG_FORTH_WORDS_KEY 
ad0e						DMARK "THN" 
ad0e f5				push af  
ad0f 3a 23 ad			ld a, (.dmark)  
ad12 32 c0 ee			ld (debug_mark),a  
ad15 3a 24 ad			ld a, (.dmark+1)  
ad18 32 c1 ee			ld (debug_mark+1),a  
ad1b 3a 25 ad			ld a, (.dmark+2)  
ad1e 32 c2 ee			ld (debug_mark+2),a  
ad21 18 03			jr .pastdmark  
ad23 ..			.dmark: db "THN"  
ad26 f1			.pastdmark: pop af  
ad27			endm  
# End of macro DMARK
ad27						CALLMONITOR 
ad27 cd f4 92			call break_point_state  
ad2a				endm  
# End of macro CALLMONITOR
ad2a					endif 
ad2a					NEXTW 
ad2a c3 ea 9b			jp macro_next 
ad2d				endm 
# End of macro NEXTW
ad2d			.ELSE: 
ad2d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ad2d 20				db WORD_SYS_CORE+12             
ad2e 55 ad			dw .DO            
ad30 03				db 2 + 1 
ad31 .. 00			db "ELSE",0              
ad36				endm 
# End of macro CWHEAD
ad36			; | ELSE ( -- ) Not supported - does nothing | TODO 
ad36			 
ad36					if DEBUG_FORTH_WORDS_KEY 
ad36						DMARK "ELS" 
ad36 f5				push af  
ad37 3a 4b ad			ld a, (.dmark)  
ad3a 32 c0 ee			ld (debug_mark),a  
ad3d 3a 4c ad			ld a, (.dmark+1)  
ad40 32 c1 ee			ld (debug_mark+1),a  
ad43 3a 4d ad			ld a, (.dmark+2)  
ad46 32 c2 ee			ld (debug_mark+2),a  
ad49 18 03			jr .pastdmark  
ad4b ..			.dmark: db "ELS"  
ad4e f1			.pastdmark: pop af  
ad4f			endm  
# End of macro DMARK
ad4f						CALLMONITOR 
ad4f cd f4 92			call break_point_state  
ad52				endm  
# End of macro CALLMONITOR
ad52					endif 
ad52			 
ad52			 
ad52					NEXTW 
ad52 c3 ea 9b			jp macro_next 
ad55				endm 
# End of macro NEXTW
ad55			.DO: 
ad55				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ad55 21				db WORD_SYS_CORE+13             
ad56 7c ae			dw .LOOP            
ad58 03				db 2 + 1 
ad59 .. 00			db "DO",0              
ad5c				endm 
# End of macro CWHEAD
ad5c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ad5c			 
ad5c					if DEBUG_FORTH_WORDS_KEY 
ad5c						DMARK "DO." 
ad5c f5				push af  
ad5d 3a 71 ad			ld a, (.dmark)  
ad60 32 c0 ee			ld (debug_mark),a  
ad63 3a 72 ad			ld a, (.dmark+1)  
ad66 32 c1 ee			ld (debug_mark+1),a  
ad69 3a 73 ad			ld a, (.dmark+2)  
ad6c 32 c2 ee			ld (debug_mark+2),a  
ad6f 18 03			jr .pastdmark  
ad71 ..			.dmark: db "DO."  
ad74 f1			.pastdmark: pop af  
ad75			endm  
# End of macro DMARK
ad75						CALLMONITOR 
ad75 cd f4 92			call break_point_state  
ad78				endm  
# End of macro CALLMONITOR
ad78					endif 
ad78			;  push pc to rsp stack past the DO 
ad78			 
ad78 2a e7 e7				ld hl, (os_tok_ptr) 
ad7b 23					inc hl   ; D 
ad7c 23					inc hl  ; O 
ad7d 23					inc hl   ; null 
ad7e					if DEBUG_FORTH_WORDS 
ad7e						DMARK "DO2" 
ad7e f5				push af  
ad7f 3a 93 ad			ld a, (.dmark)  
ad82 32 c0 ee			ld (debug_mark),a  
ad85 3a 94 ad			ld a, (.dmark+1)  
ad88 32 c1 ee			ld (debug_mark+1),a  
ad8b 3a 95 ad			ld a, (.dmark+2)  
ad8e 32 c2 ee			ld (debug_mark+2),a  
ad91 18 03			jr .pastdmark  
ad93 ..			.dmark: db "DO2"  
ad96 f1			.pastdmark: pop af  
ad97			endm  
# End of macro DMARK
ad97						CALLMONITOR 
ad97 cd f4 92			call break_point_state  
ad9a				endm  
# End of macro CALLMONITOR
ad9a					endif 
ad9a					FORTH_RSP_NEXT 
ad9a cd 28 98			call macro_forth_rsp_next 
ad9d				endm 
# End of macro FORTH_RSP_NEXT
ad9d					if DEBUG_FORTH_WORDS 
ad9d						DMARK "DO3" 
ad9d f5				push af  
ad9e 3a b2 ad			ld a, (.dmark)  
ada1 32 c0 ee			ld (debug_mark),a  
ada4 3a b3 ad			ld a, (.dmark+1)  
ada7 32 c1 ee			ld (debug_mark+1),a  
adaa 3a b4 ad			ld a, (.dmark+2)  
adad 32 c2 ee			ld (debug_mark+2),a  
adb0 18 03			jr .pastdmark  
adb2 ..			.dmark: db "DO3"  
adb5 f1			.pastdmark: pop af  
adb6			endm  
# End of macro DMARK
adb6						CALLMONITOR 
adb6 cd f4 92			call break_point_state  
adb9				endm  
# End of macro CALLMONITOR
adb9					endif 
adb9			 
adb9					;if DEBUG_FORTH_WORDS 
adb9				;		push hl 
adb9			;		endif  
adb9			 
adb9			; get counters from data stack 
adb9			 
adb9			 
adb9					FORTH_DSP_VALUEHL 
adb9 cd 78 9a			call macro_dsp_valuehl 
adbc				endm 
# End of macro FORTH_DSP_VALUEHL
adbc e5					push hl		 ; hl now has starting counter which needs to be tos 
adbd			 
adbd					if DEBUG_FORTH_WORDS 
adbd						DMARK "DO4" 
adbd f5				push af  
adbe 3a d2 ad			ld a, (.dmark)  
adc1 32 c0 ee			ld (debug_mark),a  
adc4 3a d3 ad			ld a, (.dmark+1)  
adc7 32 c1 ee			ld (debug_mark+1),a  
adca 3a d4 ad			ld a, (.dmark+2)  
adcd 32 c2 ee			ld (debug_mark+2),a  
add0 18 03			jr .pastdmark  
add2 ..			.dmark: db "DO4"  
add5 f1			.pastdmark: pop af  
add6			endm  
# End of macro DMARK
add6						CALLMONITOR 
add6 cd f4 92			call break_point_state  
add9				endm  
# End of macro CALLMONITOR
add9					endif 
add9					FORTH_DSP_POP 
add9 cd 30 9b			call macro_forth_dsp_pop 
addc				endm 
# End of macro FORTH_DSP_POP
addc			 
addc					if DEBUG_FORTH_WORDS 
addc						DMARK "DO5" 
addc f5				push af  
addd 3a f1 ad			ld a, (.dmark)  
ade0 32 c0 ee			ld (debug_mark),a  
ade3 3a f2 ad			ld a, (.dmark+1)  
ade6 32 c1 ee			ld (debug_mark+1),a  
ade9 3a f3 ad			ld a, (.dmark+2)  
adec 32 c2 ee			ld (debug_mark+2),a  
adef 18 03			jr .pastdmark  
adf1 ..			.dmark: db "DO5"  
adf4 f1			.pastdmark: pop af  
adf5			endm  
# End of macro DMARK
adf5						CALLMONITOR 
adf5 cd f4 92			call break_point_state  
adf8				endm  
# End of macro CALLMONITOR
adf8					endif 
adf8			 
adf8					FORTH_DSP_VALUEHL 
adf8 cd 78 9a			call macro_dsp_valuehl 
adfb				endm 
# End of macro FORTH_DSP_VALUEHL
adfb			;		push hl		 ; hl now has starting limit counter 
adfb			 
adfb					if DEBUG_FORTH_WORDS 
adfb						DMARK "DO6" 
adfb f5				push af  
adfc 3a 10 ae			ld a, (.dmark)  
adff 32 c0 ee			ld (debug_mark),a  
ae02 3a 11 ae			ld a, (.dmark+1)  
ae05 32 c1 ee			ld (debug_mark+1),a  
ae08 3a 12 ae			ld a, (.dmark+2)  
ae0b 32 c2 ee			ld (debug_mark+2),a  
ae0e 18 03			jr .pastdmark  
ae10 ..			.dmark: db "DO6"  
ae13 f1			.pastdmark: pop af  
ae14			endm  
# End of macro DMARK
ae14						CALLMONITOR 
ae14 cd f4 92			call break_point_state  
ae17				endm  
# End of macro CALLMONITOR
ae17					endif 
ae17					FORTH_DSP_POP 
ae17 cd 30 9b			call macro_forth_dsp_pop 
ae1a				endm 
# End of macro FORTH_DSP_POP
ae1a			 
ae1a			; put counters on the loop stack 
ae1a			 
ae1a			;		pop hl			 ; limit counter 
ae1a d1					pop de			; start counter 
ae1b			 
ae1b					; push limit counter 
ae1b			 
ae1b					if DEBUG_FORTH_WORDS 
ae1b						DMARK "DO7" 
ae1b f5				push af  
ae1c 3a 30 ae			ld a, (.dmark)  
ae1f 32 c0 ee			ld (debug_mark),a  
ae22 3a 31 ae			ld a, (.dmark+1)  
ae25 32 c1 ee			ld (debug_mark+1),a  
ae28 3a 32 ae			ld a, (.dmark+2)  
ae2b 32 c2 ee			ld (debug_mark+2),a  
ae2e 18 03			jr .pastdmark  
ae30 ..			.dmark: db "DO7"  
ae33 f1			.pastdmark: pop af  
ae34			endm  
# End of macro DMARK
ae34						CALLMONITOR 
ae34 cd f4 92			call break_point_state  
ae37				endm  
# End of macro CALLMONITOR
ae37					endif 
ae37					FORTH_LOOP_NEXT 
ae37 cd a9 9a			call macro_forth_loop_next 
ae3a				endm 
# End of macro FORTH_LOOP_NEXT
ae3a			 
ae3a					; push start counter 
ae3a			 
ae3a eb					ex de, hl 
ae3b					if DEBUG_FORTH_WORDS 
ae3b						DMARK "DO7" 
ae3b f5				push af  
ae3c 3a 50 ae			ld a, (.dmark)  
ae3f 32 c0 ee			ld (debug_mark),a  
ae42 3a 51 ae			ld a, (.dmark+1)  
ae45 32 c1 ee			ld (debug_mark+1),a  
ae48 3a 52 ae			ld a, (.dmark+2)  
ae4b 32 c2 ee			ld (debug_mark+2),a  
ae4e 18 03			jr .pastdmark  
ae50 ..			.dmark: db "DO7"  
ae53 f1			.pastdmark: pop af  
ae54			endm  
# End of macro DMARK
ae54						CALLMONITOR 
ae54 cd f4 92			call break_point_state  
ae57				endm  
# End of macro CALLMONITOR
ae57					endif 
ae57					FORTH_LOOP_NEXT 
ae57 cd a9 9a			call macro_forth_loop_next 
ae5a				endm 
# End of macro FORTH_LOOP_NEXT
ae5a			 
ae5a			 
ae5a					; init first round of I counter 
ae5a			 
ae5a 22 0b e8				ld (os_current_i), hl 
ae5d			 
ae5d					if DEBUG_FORTH_WORDS 
ae5d						DMARK "DO8" 
ae5d f5				push af  
ae5e 3a 72 ae			ld a, (.dmark)  
ae61 32 c0 ee			ld (debug_mark),a  
ae64 3a 73 ae			ld a, (.dmark+1)  
ae67 32 c1 ee			ld (debug_mark+1),a  
ae6a 3a 74 ae			ld a, (.dmark+2)  
ae6d 32 c2 ee			ld (debug_mark+2),a  
ae70 18 03			jr .pastdmark  
ae72 ..			.dmark: db "DO8"  
ae75 f1			.pastdmark: pop af  
ae76			endm  
# End of macro DMARK
ae76						CALLMONITOR 
ae76 cd f4 92			call break_point_state  
ae79				endm  
# End of macro CALLMONITOR
ae79					endif 
ae79			 
ae79					NEXTW 
ae79 c3 ea 9b			jp macro_next 
ae7c				endm 
# End of macro NEXTW
ae7c			.LOOP: 
ae7c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ae7c 22				db WORD_SYS_CORE+14             
ae7d 94 af			dw .I            
ae7f 05				db 4 + 1 
ae80 .. 00			db "LOOP",0              
ae85				endm 
# End of macro CWHEAD
ae85			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ae85			 
ae85				; pop tos as current loop count to hl 
ae85			 
ae85				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ae85			 
ae85				FORTH_LOOP_TOS 
ae85 cd dc 9a			call macro_forth_loop_tos 
ae88				endm 
# End of macro FORTH_LOOP_TOS
ae88 e5				push hl 
ae89			 
ae89					if DEBUG_FORTH_WORDS_KEY 
ae89						DMARK "LOP" 
ae89 f5				push af  
ae8a 3a 9e ae			ld a, (.dmark)  
ae8d 32 c0 ee			ld (debug_mark),a  
ae90 3a 9f ae			ld a, (.dmark+1)  
ae93 32 c1 ee			ld (debug_mark+1),a  
ae96 3a a0 ae			ld a, (.dmark+2)  
ae99 32 c2 ee			ld (debug_mark+2),a  
ae9c 18 03			jr .pastdmark  
ae9e ..			.dmark: db "LOP"  
aea1 f1			.pastdmark: pop af  
aea2			endm  
# End of macro DMARK
aea2						CALLMONITOR 
aea2 cd f4 92			call break_point_state  
aea5				endm  
# End of macro CALLMONITOR
aea5					endif 
aea5				; next item on the stack is the limit. get it 
aea5			 
aea5			 
aea5				FORTH_LOOP_POP 
aea5 cd e6 9a			call macro_forth_loop_pop 
aea8				endm 
# End of macro FORTH_LOOP_POP
aea8			 
aea8				FORTH_LOOP_TOS 
aea8 cd dc 9a			call macro_forth_loop_tos 
aeab				endm 
# End of macro FORTH_LOOP_TOS
aeab			 
aeab d1				pop de		 ; de = i, hl = limit 
aeac			 
aeac					if DEBUG_FORTH_WORDS 
aeac						DMARK "LP1" 
aeac f5				push af  
aead 3a c1 ae			ld a, (.dmark)  
aeb0 32 c0 ee			ld (debug_mark),a  
aeb3 3a c2 ae			ld a, (.dmark+1)  
aeb6 32 c1 ee			ld (debug_mark+1),a  
aeb9 3a c3 ae			ld a, (.dmark+2)  
aebc 32 c2 ee			ld (debug_mark+2),a  
aebf 18 03			jr .pastdmark  
aec1 ..			.dmark: db "LP1"  
aec4 f1			.pastdmark: pop af  
aec5			endm  
# End of macro DMARK
aec5						CALLMONITOR 
aec5 cd f4 92			call break_point_state  
aec8				endm  
# End of macro CALLMONITOR
aec8					endif 
aec8			 
aec8				; go back to previous word 
aec8			 
aec8 d5				push de    ; save I for inc later 
aec9			 
aec9			 
aec9				; get limit 
aec9				;  is I at limit? 
aec9			 
aec9			 
aec9					if DEBUG_FORTH_WORDS 
aec9						DMARK "LP1" 
aec9 f5				push af  
aeca 3a de ae			ld a, (.dmark)  
aecd 32 c0 ee			ld (debug_mark),a  
aed0 3a df ae			ld a, (.dmark+1)  
aed3 32 c1 ee			ld (debug_mark+1),a  
aed6 3a e0 ae			ld a, (.dmark+2)  
aed9 32 c2 ee			ld (debug_mark+2),a  
aedc 18 03			jr .pastdmark  
aede ..			.dmark: db "LP1"  
aee1 f1			.pastdmark: pop af  
aee2			endm  
# End of macro DMARK
aee2						CALLMONITOR 
aee2 cd f4 92			call break_point_state  
aee5				endm  
# End of macro CALLMONITOR
aee5					endif 
aee5			 
aee5 ed 52			sbc hl, de 
aee7			 
aee7			 
aee7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
aee7			 
aee7 20 26				jr nz, .loopnotdone 
aee9			 
aee9 e1				pop hl   ; get rid of saved I 
aeea				FORTH_LOOP_POP     ; get rid of limit 
aeea cd e6 9a			call macro_forth_loop_pop 
aeed				endm 
# End of macro FORTH_LOOP_POP
aeed			 
aeed				FORTH_RSP_POP     ; get rid of DO ptr 
aeed cd 49 98			call macro_forth_rsp_pop 
aef0				endm 
# End of macro FORTH_RSP_POP
aef0			 
aef0			if DEBUG_FORTH_WORDS 
aef0						DMARK "LP>" 
aef0 f5				push af  
aef1 3a 05 af			ld a, (.dmark)  
aef4 32 c0 ee			ld (debug_mark),a  
aef7 3a 06 af			ld a, (.dmark+1)  
aefa 32 c1 ee			ld (debug_mark+1),a  
aefd 3a 07 af			ld a, (.dmark+2)  
af00 32 c2 ee			ld (debug_mark+2),a  
af03 18 03			jr .pastdmark  
af05 ..			.dmark: db "LP>"  
af08 f1			.pastdmark: pop af  
af09			endm  
# End of macro DMARK
af09				CALLMONITOR 
af09 cd f4 92			call break_point_state  
af0c				endm  
# End of macro CALLMONITOR
af0c			endif 
af0c			 
af0c					NEXTW 
af0c c3 ea 9b			jp macro_next 
af0f				endm 
# End of macro NEXTW
af0f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af0f			 
af0f			.loopnotdone: 
af0f			 
af0f e1				pop hl    ; get I 
af10 23				inc hl 
af11			 
af11			   	; save new I 
af11			 
af11			 
af11					; set I counter 
af11			 
af11 22 0b e8				ld (os_current_i), hl 
af14			 
af14					if DEBUG_FORTH_WORDS 
af14						DMARK "LPN" 
af14 f5				push af  
af15 3a 29 af			ld a, (.dmark)  
af18 32 c0 ee			ld (debug_mark),a  
af1b 3a 2a af			ld a, (.dmark+1)  
af1e 32 c1 ee			ld (debug_mark+1),a  
af21 3a 2b af			ld a, (.dmark+2)  
af24 32 c2 ee			ld (debug_mark+2),a  
af27 18 03			jr .pastdmark  
af29 ..			.dmark: db "LPN"  
af2c f1			.pastdmark: pop af  
af2d			endm  
# End of macro DMARK
af2d					CALLMONITOR 
af2d cd f4 92			call break_point_state  
af30				endm  
# End of macro CALLMONITOR
af30					endif 
af30					 
af30				FORTH_LOOP_NEXT 
af30 cd a9 9a			call macro_forth_loop_next 
af33				endm 
# End of macro FORTH_LOOP_NEXT
af33			 
af33			 
af33					if DEBUG_FORTH_WORDS 
af33 eb						ex de,hl 
af34					endif 
af34			 
af34			;	; get DO ptr 
af34			; 
af34					if DEBUG_FORTH_WORDS 
af34						DMARK "LP7" 
af34 f5				push af  
af35 3a 49 af			ld a, (.dmark)  
af38 32 c0 ee			ld (debug_mark),a  
af3b 3a 4a af			ld a, (.dmark+1)  
af3e 32 c1 ee			ld (debug_mark+1),a  
af41 3a 4b af			ld a, (.dmark+2)  
af44 32 c2 ee			ld (debug_mark+2),a  
af47 18 03			jr .pastdmark  
af49 ..			.dmark: db "LP7"  
af4c f1			.pastdmark: pop af  
af4d			endm  
# End of macro DMARK
af4d					CALLMONITOR 
af4d cd f4 92			call break_point_state  
af50				endm  
# End of macro CALLMONITOR
af50					endif 
af50				FORTH_RSP_TOS 
af50 cd 3f 98			call macro_forth_rsp_tos 
af53				endm 
# End of macro FORTH_RSP_TOS
af53			 
af53					if DEBUG_FORTH_WORDS 
af53						DMARK "LP8" 
af53 f5				push af  
af54 3a 68 af			ld a, (.dmark)  
af57 32 c0 ee			ld (debug_mark),a  
af5a 3a 69 af			ld a, (.dmark+1)  
af5d 32 c1 ee			ld (debug_mark+1),a  
af60 3a 6a af			ld a, (.dmark+2)  
af63 32 c2 ee			ld (debug_mark+2),a  
af66 18 03			jr .pastdmark  
af68 ..			.dmark: db "LP8"  
af6b f1			.pastdmark: pop af  
af6c			endm  
# End of macro DMARK
af6c					CALLMONITOR 
af6c cd f4 92			call break_point_state  
af6f				endm  
# End of macro CALLMONITOR
af6f					endif 
af6f				;push hl 
af6f			 
af6f				; not going to DO any more 
af6f				; get rid of the RSP pointer as DO will add it back in 
af6f				;FORTH_RSP_POP 
af6f				;pop hl 
af6f			 
af6f				;ld hl,(cli_ret_sp) 
af6f				;ld e, (hl) 
af6f				;inc hl 
af6f				;ld d, (hl) 
af6f				;ex de,hl 
af6f 22 e7 e7			ld (os_tok_ptr), hl 
af72					if DEBUG_FORTH_WORDS 
af72						DMARK "LP<" 
af72 f5				push af  
af73 3a 87 af			ld a, (.dmark)  
af76 32 c0 ee			ld (debug_mark),a  
af79 3a 88 af			ld a, (.dmark+1)  
af7c 32 c1 ee			ld (debug_mark+1),a  
af7f 3a 89 af			ld a, (.dmark+2)  
af82 32 c2 ee			ld (debug_mark+2),a  
af85 18 03			jr .pastdmark  
af87 ..			.dmark: db "LP<"  
af8a f1			.pastdmark: pop af  
af8b			endm  
# End of macro DMARK
af8b					CALLMONITOR 
af8b cd f4 92			call break_point_state  
af8e				endm  
# End of macro CALLMONITOR
af8e				endif 
af8e c3 7b 9c			jp exec1 
af91			 
af91					 
af91			 
af91			 
af91					NEXTW 
af91 c3 ea 9b			jp macro_next 
af94				endm 
# End of macro NEXTW
af94			.I:  
af94			 
af94				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
af94 5e				db WORD_SYS_CORE+74             
af95 bf af			dw .DLOOP            
af97 02				db 1 + 1 
af98 .. 00			db "I",0              
af9a				endm 
# End of macro CWHEAD
af9a			; | I ( -- ) Current loop counter | DONE 
af9a					if DEBUG_FORTH_WORDS_KEY 
af9a						DMARK "I.." 
af9a f5				push af  
af9b 3a af af			ld a, (.dmark)  
af9e 32 c0 ee			ld (debug_mark),a  
afa1 3a b0 af			ld a, (.dmark+1)  
afa4 32 c1 ee			ld (debug_mark+1),a  
afa7 3a b1 af			ld a, (.dmark+2)  
afaa 32 c2 ee			ld (debug_mark+2),a  
afad 18 03			jr .pastdmark  
afaf ..			.dmark: db "I.."  
afb2 f1			.pastdmark: pop af  
afb3			endm  
# End of macro DMARK
afb3						CALLMONITOR 
afb3 cd f4 92			call break_point_state  
afb6				endm  
# End of macro CALLMONITOR
afb6					endif 
afb6			 
afb6 2a 0b e8				ld hl,(os_current_i) 
afb9 cd 81 98				call forth_push_numhl 
afbc			 
afbc					NEXTW 
afbc c3 ea 9b			jp macro_next 
afbf				endm 
# End of macro NEXTW
afbf			.DLOOP: 
afbf				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
afbf 5f				db WORD_SYS_CORE+75             
afc0 a0 b0			dw .REPEAT            
afc2 06				db 5 + 1 
afc3 .. 00			db "-LOOP",0              
afc9				endm 
# End of macro CWHEAD
afc9			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
afc9				; pop tos as current loop count to hl 
afc9					if DEBUG_FORTH_WORDS_KEY 
afc9						DMARK "-LP" 
afc9 f5				push af  
afca 3a de af			ld a, (.dmark)  
afcd 32 c0 ee			ld (debug_mark),a  
afd0 3a df af			ld a, (.dmark+1)  
afd3 32 c1 ee			ld (debug_mark+1),a  
afd6 3a e0 af			ld a, (.dmark+2)  
afd9 32 c2 ee			ld (debug_mark+2),a  
afdc 18 03			jr .pastdmark  
afde ..			.dmark: db "-LP"  
afe1 f1			.pastdmark: pop af  
afe2			endm  
# End of macro DMARK
afe2						CALLMONITOR 
afe2 cd f4 92			call break_point_state  
afe5				endm  
# End of macro CALLMONITOR
afe5					endif 
afe5			 
afe5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afe5			 
afe5				FORTH_LOOP_TOS 
afe5 cd dc 9a			call macro_forth_loop_tos 
afe8				endm 
# End of macro FORTH_LOOP_TOS
afe8 e5				push hl 
afe9			 
afe9					if DEBUG_FORTH_WORDS 
afe9						DMARK "-LP" 
afe9 f5				push af  
afea 3a fe af			ld a, (.dmark)  
afed 32 c0 ee			ld (debug_mark),a  
aff0 3a ff af			ld a, (.dmark+1)  
aff3 32 c1 ee			ld (debug_mark+1),a  
aff6 3a 00 b0			ld a, (.dmark+2)  
aff9 32 c2 ee			ld (debug_mark+2),a  
affc 18 03			jr .pastdmark  
affe ..			.dmark: db "-LP"  
b001 f1			.pastdmark: pop af  
b002			endm  
# End of macro DMARK
b002						CALLMONITOR 
b002 cd f4 92			call break_point_state  
b005				endm  
# End of macro CALLMONITOR
b005					endif 
b005				; next item on the stack is the limit. get it 
b005			 
b005			 
b005				FORTH_LOOP_POP 
b005 cd e6 9a			call macro_forth_loop_pop 
b008				endm 
# End of macro FORTH_LOOP_POP
b008			 
b008				FORTH_LOOP_TOS 
b008 cd dc 9a			call macro_forth_loop_tos 
b00b				endm 
# End of macro FORTH_LOOP_TOS
b00b			 
b00b d1				pop de		 ; de = i, hl = limit 
b00c			 
b00c					if DEBUG_FORTH_WORDS 
b00c						DMARK "-L1" 
b00c f5				push af  
b00d 3a 21 b0			ld a, (.dmark)  
b010 32 c0 ee			ld (debug_mark),a  
b013 3a 22 b0			ld a, (.dmark+1)  
b016 32 c1 ee			ld (debug_mark+1),a  
b019 3a 23 b0			ld a, (.dmark+2)  
b01c 32 c2 ee			ld (debug_mark+2),a  
b01f 18 03			jr .pastdmark  
b021 ..			.dmark: db "-L1"  
b024 f1			.pastdmark: pop af  
b025			endm  
# End of macro DMARK
b025						CALLMONITOR 
b025 cd f4 92			call break_point_state  
b028				endm  
# End of macro CALLMONITOR
b028					endif 
b028			 
b028				; go back to previous word 
b028			 
b028 d5				push de    ; save I for inc later 
b029			 
b029			 
b029				; get limit 
b029				;  is I at limit? 
b029			 
b029			 
b029					if DEBUG_FORTH_WORDS 
b029						DMARK "-L1" 
b029 f5				push af  
b02a 3a 3e b0			ld a, (.dmark)  
b02d 32 c0 ee			ld (debug_mark),a  
b030 3a 3f b0			ld a, (.dmark+1)  
b033 32 c1 ee			ld (debug_mark+1),a  
b036 3a 40 b0			ld a, (.dmark+2)  
b039 32 c2 ee			ld (debug_mark+2),a  
b03c 18 03			jr .pastdmark  
b03e ..			.dmark: db "-L1"  
b041 f1			.pastdmark: pop af  
b042			endm  
# End of macro DMARK
b042						CALLMONITOR 
b042 cd f4 92			call break_point_state  
b045				endm  
# End of macro CALLMONITOR
b045					endif 
b045			 
b045 ed 52			sbc hl, de 
b047			 
b047			 
b047				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b047			 
b047 20 26				jr nz, .mloopnotdone 
b049			 
b049 e1				pop hl   ; get rid of saved I 
b04a				FORTH_LOOP_POP     ; get rid of limit 
b04a cd e6 9a			call macro_forth_loop_pop 
b04d				endm 
# End of macro FORTH_LOOP_POP
b04d			 
b04d				FORTH_RSP_POP     ; get rid of DO ptr 
b04d cd 49 98			call macro_forth_rsp_pop 
b050				endm 
# End of macro FORTH_RSP_POP
b050			 
b050			if DEBUG_FORTH_WORDS 
b050						DMARK "-L>" 
b050 f5				push af  
b051 3a 65 b0			ld a, (.dmark)  
b054 32 c0 ee			ld (debug_mark),a  
b057 3a 66 b0			ld a, (.dmark+1)  
b05a 32 c1 ee			ld (debug_mark+1),a  
b05d 3a 67 b0			ld a, (.dmark+2)  
b060 32 c2 ee			ld (debug_mark+2),a  
b063 18 03			jr .pastdmark  
b065 ..			.dmark: db "-L>"  
b068 f1			.pastdmark: pop af  
b069			endm  
# End of macro DMARK
b069				CALLMONITOR 
b069 cd f4 92			call break_point_state  
b06c				endm  
# End of macro CALLMONITOR
b06c			endif 
b06c			 
b06c					NEXTW 
b06c c3 ea 9b			jp macro_next 
b06f				endm 
# End of macro NEXTW
b06f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b06f			 
b06f			.mloopnotdone: 
b06f			 
b06f e1				pop hl    ; get I 
b070 2b				dec hl 
b071			 
b071			   	; save new I 
b071			 
b071			 
b071					; set I counter 
b071			 
b071 22 0b e8				ld (os_current_i), hl 
b074			 
b074					 
b074				FORTH_LOOP_NEXT 
b074 cd a9 9a			call macro_forth_loop_next 
b077				endm 
# End of macro FORTH_LOOP_NEXT
b077			 
b077			 
b077					if DEBUG_FORTH_WORDS 
b077 eb						ex de,hl 
b078					endif 
b078			 
b078			;	; get DO ptr 
b078			; 
b078				FORTH_RSP_TOS 
b078 cd 3f 98			call macro_forth_rsp_tos 
b07b				endm 
# End of macro FORTH_RSP_TOS
b07b			 
b07b				;push hl 
b07b			 
b07b				; not going to DO any more 
b07b				; get rid of the RSP pointer as DO will add it back in 
b07b				;FORTH_RSP_POP 
b07b				;pop hl 
b07b			 
b07b			 
b07b 22 e7 e7			ld (os_tok_ptr), hl 
b07e					if DEBUG_FORTH_WORDS 
b07e						DMARK "-L<" 
b07e f5				push af  
b07f 3a 93 b0			ld a, (.dmark)  
b082 32 c0 ee			ld (debug_mark),a  
b085 3a 94 b0			ld a, (.dmark+1)  
b088 32 c1 ee			ld (debug_mark+1),a  
b08b 3a 95 b0			ld a, (.dmark+2)  
b08e 32 c2 ee			ld (debug_mark+2),a  
b091 18 03			jr .pastdmark  
b093 ..			.dmark: db "-L<"  
b096 f1			.pastdmark: pop af  
b097			endm  
# End of macro DMARK
b097					CALLMONITOR 
b097 cd f4 92			call break_point_state  
b09a				endm  
# End of macro CALLMONITOR
b09a				endif 
b09a c3 7b 9c			jp exec1 
b09d			 
b09d					 
b09d			 
b09d			 
b09d			 
b09d				NEXTW 
b09d c3 ea 9b			jp macro_next 
b0a0				endm 
# End of macro NEXTW
b0a0			 
b0a0			 
b0a0			 
b0a0			 
b0a0			.REPEAT: 
b0a0				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b0a0 71				db WORD_SYS_CORE+93             
b0a1 f3 b0			dw .UNTIL            
b0a3 06				db 5 + 1 
b0a4 .. 00			db "REPEAT",0              
b0ab				endm 
# End of macro CWHEAD
b0ab			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b0ab			;  push pc to rsp stack past the REPEAT 
b0ab					if DEBUG_FORTH_WORDS_KEY 
b0ab						DMARK "REP" 
b0ab f5				push af  
b0ac 3a c0 b0			ld a, (.dmark)  
b0af 32 c0 ee			ld (debug_mark),a  
b0b2 3a c1 b0			ld a, (.dmark+1)  
b0b5 32 c1 ee			ld (debug_mark+1),a  
b0b8 3a c2 b0			ld a, (.dmark+2)  
b0bb 32 c2 ee			ld (debug_mark+2),a  
b0be 18 03			jr .pastdmark  
b0c0 ..			.dmark: db "REP"  
b0c3 f1			.pastdmark: pop af  
b0c4			endm  
# End of macro DMARK
b0c4						CALLMONITOR 
b0c4 cd f4 92			call break_point_state  
b0c7				endm  
# End of macro CALLMONITOR
b0c7					endif 
b0c7			 
b0c7 2a e7 e7				ld hl, (os_tok_ptr) 
b0ca 23					inc hl   ; R 
b0cb 23					inc hl  ; E 
b0cc 23					inc hl   ; P 
b0cd 23					inc hl   ; E 
b0ce 23					inc hl   ; A 
b0cf 23					inc hl   ; T 
b0d0 23					inc hl   ; zero 
b0d1					FORTH_RSP_NEXT 
b0d1 cd 28 98			call macro_forth_rsp_next 
b0d4				endm 
# End of macro FORTH_RSP_NEXT
b0d4			 
b0d4			 
b0d4					if DEBUG_FORTH_WORDS 
b0d4						DMARK "REP" 
b0d4 f5				push af  
b0d5 3a e9 b0			ld a, (.dmark)  
b0d8 32 c0 ee			ld (debug_mark),a  
b0db 3a ea b0			ld a, (.dmark+1)  
b0de 32 c1 ee			ld (debug_mark+1),a  
b0e1 3a eb b0			ld a, (.dmark+2)  
b0e4 32 c2 ee			ld (debug_mark+2),a  
b0e7 18 03			jr .pastdmark  
b0e9 ..			.dmark: db "REP"  
b0ec f1			.pastdmark: pop af  
b0ed			endm  
# End of macro DMARK
b0ed						;pop bc    ; TODO BUG ?????? what is this for???? 
b0ed						CALLMONITOR 
b0ed cd f4 92			call break_point_state  
b0f0				endm  
# End of macro CALLMONITOR
b0f0					endif 
b0f0			 
b0f0					NEXTW 
b0f0 c3 ea 9b			jp macro_next 
b0f3				endm 
# End of macro NEXTW
b0f3			;	       NEXTW 
b0f3			 
b0f3			.UNTIL: 
b0f3				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b0f3 72				db WORD_SYS_CORE+94             
b0f4 8a b1			dw .ENDFLOW            
b0f6 06				db 5 + 1 
b0f7 .. 00			db "UNTIL",0              
b0fd				endm 
# End of macro CWHEAD
b0fd			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b0fd			 
b0fd				; pop tos as check 
b0fd			 
b0fd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0fd			 
b0fd				FORTH_DSP_VALUEHL 
b0fd cd 78 9a			call macro_dsp_valuehl 
b100				endm 
# End of macro FORTH_DSP_VALUEHL
b100			 
b100					if DEBUG_FORTH_WORDS_KEY 
b100						DMARK "UNT" 
b100 f5				push af  
b101 3a 15 b1			ld a, (.dmark)  
b104 32 c0 ee			ld (debug_mark),a  
b107 3a 16 b1			ld a, (.dmark+1)  
b10a 32 c1 ee			ld (debug_mark+1),a  
b10d 3a 17 b1			ld a, (.dmark+2)  
b110 32 c2 ee			ld (debug_mark+2),a  
b113 18 03			jr .pastdmark  
b115 ..			.dmark: db "UNT"  
b118 f1			.pastdmark: pop af  
b119			endm  
# End of macro DMARK
b119						CALLMONITOR 
b119 cd f4 92			call break_point_state  
b11c				endm  
# End of macro CALLMONITOR
b11c					endif 
b11c			 
b11c			;	push hl 
b11c				FORTH_DSP_POP 
b11c cd 30 9b			call macro_forth_dsp_pop 
b11f				endm 
# End of macro FORTH_DSP_POP
b11f			 
b11f			;	pop hl 
b11f			 
b11f				; test if true 
b11f			 
b11f cd d0 8a			call ishlzero 
b122			;	ld a,l 
b122			;	add h 
b122			; 
b122			;	cp 0 
b122			 
b122 20 3e			jr nz, .untilnotdone 
b124			 
b124					if DEBUG_FORTH_WORDS 
b124						DMARK "UNf" 
b124 f5				push af  
b125 3a 39 b1			ld a, (.dmark)  
b128 32 c0 ee			ld (debug_mark),a  
b12b 3a 3a b1			ld a, (.dmark+1)  
b12e 32 c1 ee			ld (debug_mark+1),a  
b131 3a 3b b1			ld a, (.dmark+2)  
b134 32 c2 ee			ld (debug_mark+2),a  
b137 18 03			jr .pastdmark  
b139 ..			.dmark: db "UNf"  
b13c f1			.pastdmark: pop af  
b13d			endm  
# End of macro DMARK
b13d						CALLMONITOR 
b13d cd f4 92			call break_point_state  
b140				endm  
# End of macro CALLMONITOR
b140					endif 
b140			 
b140			 
b140			 
b140				FORTH_RSP_POP     ; get rid of DO ptr 
b140 cd 49 98			call macro_forth_rsp_pop 
b143				endm 
# End of macro FORTH_RSP_POP
b143			 
b143			if DEBUG_FORTH_WORDS 
b143						DMARK "UN>" 
b143 f5				push af  
b144 3a 58 b1			ld a, (.dmark)  
b147 32 c0 ee			ld (debug_mark),a  
b14a 3a 59 b1			ld a, (.dmark+1)  
b14d 32 c1 ee			ld (debug_mark+1),a  
b150 3a 5a b1			ld a, (.dmark+2)  
b153 32 c2 ee			ld (debug_mark+2),a  
b156 18 03			jr .pastdmark  
b158 ..			.dmark: db "UN>"  
b15b f1			.pastdmark: pop af  
b15c			endm  
# End of macro DMARK
b15c				CALLMONITOR 
b15c cd f4 92			call break_point_state  
b15f				endm  
# End of macro CALLMONITOR
b15f			endif 
b15f			 
b15f					NEXTW 
b15f c3 ea 9b			jp macro_next 
b162				endm 
# End of macro NEXTW
b162				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b162			 
b162			.untilnotdone: 
b162			 
b162			 
b162			;	; get DO ptr 
b162			; 
b162				FORTH_RSP_TOS 
b162 cd 3f 98			call macro_forth_rsp_tos 
b165				endm 
# End of macro FORTH_RSP_TOS
b165			 
b165				;push hl 
b165			 
b165				; not going to DO any more 
b165				; get rid of the RSP pointer as DO will add it back in 
b165				;FORTH_RSP_POP 
b165				;pop hl 
b165			 
b165			 
b165 22 e7 e7			ld (os_tok_ptr), hl 
b168					if DEBUG_FORTH_WORDS 
b168						DMARK "UN<" 
b168 f5				push af  
b169 3a 7d b1			ld a, (.dmark)  
b16c 32 c0 ee			ld (debug_mark),a  
b16f 3a 7e b1			ld a, (.dmark+1)  
b172 32 c1 ee			ld (debug_mark+1),a  
b175 3a 7f b1			ld a, (.dmark+2)  
b178 32 c2 ee			ld (debug_mark+2),a  
b17b 18 03			jr .pastdmark  
b17d ..			.dmark: db "UN<"  
b180 f1			.pastdmark: pop af  
b181			endm  
# End of macro DMARK
b181					CALLMONITOR 
b181 cd f4 92			call break_point_state  
b184				endm  
# End of macro CALLMONITOR
b184				endif 
b184 c3 7b 9c			jp exec1 
b187			 
b187					 
b187			 
b187			 
b187					NEXTW 
b187 c3 ea 9b			jp macro_next 
b18a				endm 
# End of macro NEXTW
b18a			 
b18a			 
b18a			.ENDFLOW: 
b18a			 
b18a			; eof 
b18a			 
# End of file forth_words_flow.asm
b18a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b18a			include "forth_words_logic.asm" 
b18a			 
b18a			; | ## Logic Words 
b18a			 
b18a			.NOT: 
b18a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b18a 2d				db WORD_SYS_CORE+25             
b18b d2 b1			dw .IS            
b18d 04				db 3 + 1 
b18e .. 00			db "NOT",0              
b192				endm 
# End of macro CWHEAD
b192			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b192					if DEBUG_FORTH_WORDS_KEY 
b192						DMARK "NOT" 
b192 f5				push af  
b193 3a a7 b1			ld a, (.dmark)  
b196 32 c0 ee			ld (debug_mark),a  
b199 3a a8 b1			ld a, (.dmark+1)  
b19c 32 c1 ee			ld (debug_mark+1),a  
b19f 3a a9 b1			ld a, (.dmark+2)  
b1a2 32 c2 ee			ld (debug_mark+2),a  
b1a5 18 03			jr .pastdmark  
b1a7 ..			.dmark: db "NOT"  
b1aa f1			.pastdmark: pop af  
b1ab			endm  
# End of macro DMARK
b1ab						CALLMONITOR 
b1ab cd f4 92			call break_point_state  
b1ae				endm  
# End of macro CALLMONITOR
b1ae					endif 
b1ae					FORTH_DSP 
b1ae cd 3e 9a			call macro_forth_dsp 
b1b1				endm 
# End of macro FORTH_DSP
b1b1 7e					ld a,(hl)	; get type of value on TOS 
b1b2 fe 02				cp DS_TYPE_INUM  
b1b4 28 03				jr z, .noti 
b1b6					NEXTW 
b1b6 c3 ea 9b			jp macro_next 
b1b9				endm 
# End of macro NEXTW
b1b9			.noti:          FORTH_DSP_VALUEHL 
b1b9 cd 78 9a			call macro_dsp_valuehl 
b1bc				endm 
# End of macro FORTH_DSP_VALUEHL
b1bc			;		push hl 
b1bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1bc cd 30 9b			call macro_forth_dsp_pop 
b1bf				endm 
# End of macro FORTH_DSP_POP
b1bf			;		pop hl 
b1bf 3e 00				ld a,0 
b1c1 bd					cp l 
b1c2 28 04				jr z, .not2t 
b1c4 2e 00				ld l, 0 
b1c6 18 02				jr .notip 
b1c8			 
b1c8 2e ff		.not2t:		ld l, 255 
b1ca			 
b1ca 26 00		.notip:		ld h, 0	 
b1cc			 
b1cc cd 81 98				call forth_push_numhl 
b1cf					NEXTW 
b1cf c3 ea 9b			jp macro_next 
b1d2				endm 
# End of macro NEXTW
b1d2			 
b1d2			.IS: 
b1d2				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b1d2 2d				db WORD_SYS_CORE+25             
b1d3 f8 b1			dw .LZERO            
b1d5 03				db 2 + 1 
b1d6 .. 00			db "IS",0              
b1d9				endm 
# End of macro CWHEAD
b1d9			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b1d9					if DEBUG_FORTH_WORDS_KEY 
b1d9						DMARK "IS." 
b1d9 f5				push af  
b1da 3a ee b1			ld a, (.dmark)  
b1dd 32 c0 ee			ld (debug_mark),a  
b1e0 3a ef b1			ld a, (.dmark+1)  
b1e3 32 c1 ee			ld (debug_mark+1),a  
b1e6 3a f0 b1			ld a, (.dmark+2)  
b1e9 32 c2 ee			ld (debug_mark+2),a  
b1ec 18 03			jr .pastdmark  
b1ee ..			.dmark: db "IS."  
b1f1 f1			.pastdmark: pop af  
b1f2			endm  
# End of macro DMARK
b1f2						CALLMONITOR 
b1f2 cd f4 92			call break_point_state  
b1f5				endm  
# End of macro CALLMONITOR
b1f5					endif 
b1f5					NEXTW 
b1f5 c3 ea 9b			jp macro_next 
b1f8				endm 
# End of macro NEXTW
b1f8			.LZERO: 
b1f8				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b1f8 2d				db WORD_SYS_CORE+25             
b1f9 02 b2			dw .TZERO            
b1fb 03				db 2 + 1 
b1fc .. 00			db "0<",0              
b1ff				endm 
# End of macro CWHEAD
b1ff			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b1ff					NEXTW 
b1ff c3 ea 9b			jp macro_next 
b202				endm 
# End of macro NEXTW
b202			.TZERO: 
b202				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b202 2e				db WORD_SYS_CORE+26             
b203 49 b2			dw .LESS            
b205 03				db 2 + 1 
b206 .. 00			db "0=",0              
b209				endm 
# End of macro CWHEAD
b209			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b209				; TODO add floating point number detection 
b209					;v5 FORTH_DSP_VALUE 
b209					if DEBUG_FORTH_WORDS_KEY 
b209						DMARK "0=." 
b209 f5				push af  
b20a 3a 1e b2			ld a, (.dmark)  
b20d 32 c0 ee			ld (debug_mark),a  
b210 3a 1f b2			ld a, (.dmark+1)  
b213 32 c1 ee			ld (debug_mark+1),a  
b216 3a 20 b2			ld a, (.dmark+2)  
b219 32 c2 ee			ld (debug_mark+2),a  
b21c 18 03			jr .pastdmark  
b21e ..			.dmark: db "0=."  
b221 f1			.pastdmark: pop af  
b222			endm  
# End of macro DMARK
b222						CALLMONITOR 
b222 cd f4 92			call break_point_state  
b225				endm  
# End of macro CALLMONITOR
b225					endif 
b225					FORTH_DSP 
b225 cd 3e 9a			call macro_forth_dsp 
b228				endm 
# End of macro FORTH_DSP
b228 7e					ld a,(hl)	; get type of value on TOS 
b229 fe 02				cp DS_TYPE_INUM  
b22b 28 00				jr z, .tz_inum 
b22d			 
b22d				if FORTH_ENABLE_FLOATMATH 
b22d					jr .tz_done 
b22d			 
b22d				endif 
b22d					 
b22d			 
b22d			.tz_inum: 
b22d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b22d cd 78 9a			call macro_dsp_valuehl 
b230				endm 
# End of macro FORTH_DSP_VALUEHL
b230			 
b230			;		push hl 
b230			 
b230					; destroy value TOS 
b230			 
b230					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b230 cd 30 9b			call macro_forth_dsp_pop 
b233				endm 
# End of macro FORTH_DSP_POP
b233			 
b233			;		pop hl 
b233			 
b233 3e 00				ld a,0 
b235			 
b235 bd					cp l 
b236 20 08				jr nz, .tz_notzero 
b238			 
b238 bc					cp h 
b239			 
b239 20 05				jr nz, .tz_notzero 
b23b			 
b23b			 
b23b 21 01 00				ld hl, FORTH_TRUE 
b23e 18 03				jr .tz_done 
b240			 
b240 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b243			 
b243					; push value back onto stack for another op etc 
b243			 
b243			.tz_done: 
b243 cd 81 98				call forth_push_numhl 
b246			 
b246					NEXTW 
b246 c3 ea 9b			jp macro_next 
b249				endm 
# End of macro NEXTW
b249			.LESS: 
b249				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b249 2f				db WORD_SYS_CORE+27             
b24a b2 b2			dw .GT            
b24c 02				db 1 + 1 
b24d .. 00			db "<",0              
b24f				endm 
# End of macro CWHEAD
b24f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b24f				; TODO add floating point number detection 
b24f					if DEBUG_FORTH_WORDS_KEY 
b24f						DMARK "LES" 
b24f f5				push af  
b250 3a 64 b2			ld a, (.dmark)  
b253 32 c0 ee			ld (debug_mark),a  
b256 3a 65 b2			ld a, (.dmark+1)  
b259 32 c1 ee			ld (debug_mark+1),a  
b25c 3a 66 b2			ld a, (.dmark+2)  
b25f 32 c2 ee			ld (debug_mark+2),a  
b262 18 03			jr .pastdmark  
b264 ..			.dmark: db "LES"  
b267 f1			.pastdmark: pop af  
b268			endm  
# End of macro DMARK
b268						CALLMONITOR 
b268 cd f4 92			call break_point_state  
b26b				endm  
# End of macro CALLMONITOR
b26b					endif 
b26b					FORTH_DSP 
b26b cd 3e 9a			call macro_forth_dsp 
b26e				endm 
# End of macro FORTH_DSP
b26e					;v5 FORTH_DSP_VALUE 
b26e 7e					ld a,(hl)	; get type of value on TOS 
b26f fe 02				cp DS_TYPE_INUM  
b271 28 00				jr z, .less_inum 
b273			 
b273				if FORTH_ENABLE_FLOATMATH 
b273					jr .less_done 
b273			 
b273				endif 
b273					 
b273			 
b273			.less_inum: 
b273					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b273 cd 78 9a			call macro_dsp_valuehl 
b276				endm 
# End of macro FORTH_DSP_VALUEHL
b276			 
b276 e5					push hl  ; u2 
b277			 
b277					; destroy value TOS 
b277			 
b277					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b277 cd 30 9b			call macro_forth_dsp_pop 
b27a				endm 
# End of macro FORTH_DSP_POP
b27a			 
b27a			 
b27a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b27a cd 78 9a			call macro_dsp_valuehl 
b27d				endm 
# End of macro FORTH_DSP_VALUEHL
b27d			 
b27d e5					push hl    ; u1 
b27e			 
b27e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b27e cd 30 9b			call macro_forth_dsp_pop 
b281				endm 
# End of macro FORTH_DSP_POP
b281			 
b281			 
b281 b7			 or a      ;clear carry flag 
b282 01 00 00		 ld bc, FORTH_FALSE 
b285 e1			  pop hl    ; u1 
b286 d1			  pop de    ; u2 
b287 ed 52		  sbc hl,de 
b289 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b28b			 
b28b 01 01 00		 ld bc, FORTH_TRUE 
b28e			.lscont:  
b28e c5					push bc 
b28f e1					pop hl 
b290			 
b290					if DEBUG_FORTH_WORDS 
b290						DMARK "LT1" 
b290 f5				push af  
b291 3a a5 b2			ld a, (.dmark)  
b294 32 c0 ee			ld (debug_mark),a  
b297 3a a6 b2			ld a, (.dmark+1)  
b29a 32 c1 ee			ld (debug_mark+1),a  
b29d 3a a7 b2			ld a, (.dmark+2)  
b2a0 32 c2 ee			ld (debug_mark+2),a  
b2a3 18 03			jr .pastdmark  
b2a5 ..			.dmark: db "LT1"  
b2a8 f1			.pastdmark: pop af  
b2a9			endm  
# End of macro DMARK
b2a9						CALLMONITOR 
b2a9 cd f4 92			call break_point_state  
b2ac				endm  
# End of macro CALLMONITOR
b2ac					endif 
b2ac cd 81 98				call forth_push_numhl 
b2af			 
b2af					NEXTW 
b2af c3 ea 9b			jp macro_next 
b2b2				endm 
# End of macro NEXTW
b2b2			.GT: 
b2b2				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b2b2 30				db WORD_SYS_CORE+28             
b2b3 1b b3			dw .EQUAL            
b2b5 02				db 1 + 1 
b2b6 .. 00			db ">",0              
b2b8				endm 
# End of macro CWHEAD
b2b8			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b2b8				; TODO add floating point number detection 
b2b8					if DEBUG_FORTH_WORDS_KEY 
b2b8						DMARK "GRT" 
b2b8 f5				push af  
b2b9 3a cd b2			ld a, (.dmark)  
b2bc 32 c0 ee			ld (debug_mark),a  
b2bf 3a ce b2			ld a, (.dmark+1)  
b2c2 32 c1 ee			ld (debug_mark+1),a  
b2c5 3a cf b2			ld a, (.dmark+2)  
b2c8 32 c2 ee			ld (debug_mark+2),a  
b2cb 18 03			jr .pastdmark  
b2cd ..			.dmark: db "GRT"  
b2d0 f1			.pastdmark: pop af  
b2d1			endm  
# End of macro DMARK
b2d1						CALLMONITOR 
b2d1 cd f4 92			call break_point_state  
b2d4				endm  
# End of macro CALLMONITOR
b2d4					endif 
b2d4					FORTH_DSP 
b2d4 cd 3e 9a			call macro_forth_dsp 
b2d7				endm 
# End of macro FORTH_DSP
b2d7					;FORTH_DSP_VALUE 
b2d7 7e					ld a,(hl)	; get type of value on TOS 
b2d8 fe 02				cp DS_TYPE_INUM  
b2da 28 00				jr z, .gt_inum 
b2dc			 
b2dc				if FORTH_ENABLE_FLOATMATH 
b2dc					jr .gt_done 
b2dc			 
b2dc				endif 
b2dc					 
b2dc			 
b2dc			.gt_inum: 
b2dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2dc cd 78 9a			call macro_dsp_valuehl 
b2df				endm 
# End of macro FORTH_DSP_VALUEHL
b2df			 
b2df e5					push hl  ; u2 
b2e0			 
b2e0					; destroy value TOS 
b2e0			 
b2e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2e0 cd 30 9b			call macro_forth_dsp_pop 
b2e3				endm 
# End of macro FORTH_DSP_POP
b2e3			 
b2e3			 
b2e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2e3 cd 78 9a			call macro_dsp_valuehl 
b2e6				endm 
# End of macro FORTH_DSP_VALUEHL
b2e6			 
b2e6 e5					push hl    ; u1 
b2e7			 
b2e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2e7 cd 30 9b			call macro_forth_dsp_pop 
b2ea				endm 
# End of macro FORTH_DSP_POP
b2ea			 
b2ea			 
b2ea b7			 or a      ;clear carry flag 
b2eb 01 00 00		 ld bc, FORTH_FALSE 
b2ee e1			  pop hl    ; u1 
b2ef d1			  pop de    ; u2 
b2f0 ed 52		  sbc hl,de 
b2f2 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b2f4			 
b2f4 01 01 00		 ld bc, FORTH_TRUE 
b2f7			.gtcont:  
b2f7 c5					push bc 
b2f8 e1					pop hl 
b2f9			 
b2f9					if DEBUG_FORTH_WORDS 
b2f9						DMARK "GT1" 
b2f9 f5				push af  
b2fa 3a 0e b3			ld a, (.dmark)  
b2fd 32 c0 ee			ld (debug_mark),a  
b300 3a 0f b3			ld a, (.dmark+1)  
b303 32 c1 ee			ld (debug_mark+1),a  
b306 3a 10 b3			ld a, (.dmark+2)  
b309 32 c2 ee			ld (debug_mark+2),a  
b30c 18 03			jr .pastdmark  
b30e ..			.dmark: db "GT1"  
b311 f1			.pastdmark: pop af  
b312			endm  
# End of macro DMARK
b312						CALLMONITOR 
b312 cd f4 92			call break_point_state  
b315				endm  
# End of macro CALLMONITOR
b315					endif 
b315 cd 81 98				call forth_push_numhl 
b318			 
b318					NEXTW 
b318 c3 ea 9b			jp macro_next 
b31b				endm 
# End of macro NEXTW
b31b			.EQUAL: 
b31b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b31b 31				db WORD_SYS_CORE+29             
b31c 86 b3			dw .ENDLOGIC            
b31e 02				db 1 + 1 
b31f .. 00			db "=",0              
b321				endm 
# End of macro CWHEAD
b321			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b321				; TODO add floating point number detection 
b321					if DEBUG_FORTH_WORDS_KEY 
b321						DMARK "EQ." 
b321 f5				push af  
b322 3a 36 b3			ld a, (.dmark)  
b325 32 c0 ee			ld (debug_mark),a  
b328 3a 37 b3			ld a, (.dmark+1)  
b32b 32 c1 ee			ld (debug_mark+1),a  
b32e 3a 38 b3			ld a, (.dmark+2)  
b331 32 c2 ee			ld (debug_mark+2),a  
b334 18 03			jr .pastdmark  
b336 ..			.dmark: db "EQ."  
b339 f1			.pastdmark: pop af  
b33a			endm  
# End of macro DMARK
b33a						CALLMONITOR 
b33a cd f4 92			call break_point_state  
b33d				endm  
# End of macro CALLMONITOR
b33d					endif 
b33d					FORTH_DSP 
b33d cd 3e 9a			call macro_forth_dsp 
b340				endm 
# End of macro FORTH_DSP
b340					;v5 FORTH_DSP_VALUE 
b340 7e					ld a,(hl)	; get type of value on TOS 
b341 fe 02				cp DS_TYPE_INUM  
b343 28 00				jr z, .eq_inum 
b345			 
b345				if FORTH_ENABLE_FLOATMATH 
b345					jr .eq_done 
b345			 
b345				endif 
b345					 
b345			 
b345			.eq_inum: 
b345					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b345 cd 78 9a			call macro_dsp_valuehl 
b348				endm 
# End of macro FORTH_DSP_VALUEHL
b348			 
b348 e5					push hl 
b349			 
b349					; destroy value TOS 
b349			 
b349					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b349 cd 30 9b			call macro_forth_dsp_pop 
b34c				endm 
# End of macro FORTH_DSP_POP
b34c			 
b34c			 
b34c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b34c cd 78 9a			call macro_dsp_valuehl 
b34f				endm 
# End of macro FORTH_DSP_VALUEHL
b34f			 
b34f					; one value on hl get other one back 
b34f			 
b34f e5					push hl 
b350			 
b350					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b350 cd 30 9b			call macro_forth_dsp_pop 
b353				endm 
# End of macro FORTH_DSP_POP
b353			 
b353 0e 00				ld c, FORTH_FALSE 
b355			 
b355 e1					pop hl 
b356 d1					pop de 
b357			 
b357 7b					ld a, e 
b358 bd					cp l 
b359			 
b359 20 06				jr nz, .eq_done 
b35b			 
b35b 7a					ld a, d 
b35c bc					cp h 
b35d			 
b35d 20 02				jr nz, .eq_done 
b35f			 
b35f 0e 01				ld c, FORTH_TRUE 
b361					 
b361			 
b361			 
b361			.eq_done: 
b361			 
b361					; TODO push value back onto stack for another op etc 
b361			 
b361 26 00				ld h, 0 
b363 69					ld l, c 
b364					if DEBUG_FORTH_WORDS 
b364						DMARK "EQ1" 
b364 f5				push af  
b365 3a 79 b3			ld a, (.dmark)  
b368 32 c0 ee			ld (debug_mark),a  
b36b 3a 7a b3			ld a, (.dmark+1)  
b36e 32 c1 ee			ld (debug_mark+1),a  
b371 3a 7b b3			ld a, (.dmark+2)  
b374 32 c2 ee			ld (debug_mark+2),a  
b377 18 03			jr .pastdmark  
b379 ..			.dmark: db "EQ1"  
b37c f1			.pastdmark: pop af  
b37d			endm  
# End of macro DMARK
b37d						CALLMONITOR 
b37d cd f4 92			call break_point_state  
b380				endm  
# End of macro CALLMONITOR
b380					endif 
b380 cd 81 98				call forth_push_numhl 
b383			 
b383					NEXTW 
b383 c3 ea 9b			jp macro_next 
b386				endm 
# End of macro NEXTW
b386			 
b386			 
b386			.ENDLOGIC: 
b386			; eof 
b386			 
b386			 
# End of file forth_words_logic.asm
b386			include "forth_words_maths.asm" 
b386			 
b386			; | ## Maths Words 
b386			 
b386			.PLUS:	 
b386				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b386 15				db WORD_SYS_CORE+1             
b387 c8 b3			dw .NEG            
b389 02				db 1 + 1 
b38a .. 00			db "+",0              
b38c				endm 
# End of macro CWHEAD
b38c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b38c					if DEBUG_FORTH_WORDS_KEY 
b38c						DMARK "PLU" 
b38c f5				push af  
b38d 3a a1 b3			ld a, (.dmark)  
b390 32 c0 ee			ld (debug_mark),a  
b393 3a a2 b3			ld a, (.dmark+1)  
b396 32 c1 ee			ld (debug_mark+1),a  
b399 3a a3 b3			ld a, (.dmark+2)  
b39c 32 c2 ee			ld (debug_mark+2),a  
b39f 18 03			jr .pastdmark  
b3a1 ..			.dmark: db "PLU"  
b3a4 f1			.pastdmark: pop af  
b3a5			endm  
# End of macro DMARK
b3a5						CALLMONITOR 
b3a5 cd f4 92			call break_point_state  
b3a8				endm  
# End of macro CALLMONITOR
b3a8					endif 
b3a8					; add top two values and push back result 
b3a8			 
b3a8					;for v5 FORTH_DSP_VALUE 
b3a8					FORTH_DSP 
b3a8 cd 3e 9a			call macro_forth_dsp 
b3ab				endm 
# End of macro FORTH_DSP
b3ab 7e					ld a,(hl)	; get type of value on TOS 
b3ac fe 02				cp DS_TYPE_INUM  
b3ae 28 03				jr z, .dot_inum 
b3b0			 
b3b0					NEXTW 
b3b0 c3 ea 9b			jp macro_next 
b3b3				endm 
# End of macro NEXTW
b3b3			 
b3b3			; float maths 
b3b3			 
b3b3				if FORTH_ENABLE_FLOATMATH 
b3b3						inc hl      ; now at start of numeric as string 
b3b3			 
b3b3					if DEBUG_FORTH_MATHS 
b3b3						DMARK "ADD" 
b3b3				CALLMONITOR 
b3b3					endif 
b3b3			 
b3b3					;ld ix, hl 
b3b3					call CON 
b3b3			 
b3b3			 
b3b3					push hl 
b3b3					 
b3b3					 
b3b3			 
b3b3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b3b3			 
b3b3					; get next number 
b3b3			 
b3b3						FORTH_DSP_VALUE 
b3b3			 
b3b3						inc hl      ; now at start of numeric as string 
b3b3			 
b3b3					;ld ix, hl 
b3b3					call CON 
b3b3			 
b3b3					push hl 
b3b3			 
b3b3			 
b3b3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b3			 
b3b3						; TODO do add 
b3b3			 
b3b3						call IADD 
b3b3			 
b3b3						; TODO get result back as ascii 
b3b3			 
b3b3						; TODO push result  
b3b3			 
b3b3			 
b3b3			 
b3b3						jr .dot_done 
b3b3				endif 
b3b3			 
b3b3			.dot_inum: 
b3b3			 
b3b3			 
b3b3					if DEBUG_FORTH_DOT 
b3b3						DMARK "+IT" 
b3b3				CALLMONITOR 
b3b3					endif 
b3b3			 
b3b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b3 cd 78 9a			call macro_dsp_valuehl 
b3b6				endm 
# End of macro FORTH_DSP_VALUEHL
b3b6			 
b3b6				; TODO add floating point number detection 
b3b6			 
b3b6 e5					push hl 
b3b7			 
b3b7					; destroy value TOS 
b3b7			 
b3b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b7 cd 30 9b			call macro_forth_dsp_pop 
b3ba				endm 
# End of macro FORTH_DSP_POP
b3ba			 
b3ba			 
b3ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3ba cd 78 9a			call macro_dsp_valuehl 
b3bd				endm 
# End of macro FORTH_DSP_VALUEHL
b3bd			 
b3bd					; one value on hl get other one back 
b3bd			 
b3bd d1					pop de 
b3be			 
b3be					; do the add 
b3be			 
b3be 19					add hl,de 
b3bf			 
b3bf					; save it 
b3bf			 
b3bf			;		push hl	 
b3bf			 
b3bf					; 
b3bf			 
b3bf					; destroy value TOS 
b3bf			 
b3bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3bf cd 30 9b			call macro_forth_dsp_pop 
b3c2				endm 
# End of macro FORTH_DSP_POP
b3c2			 
b3c2					; TODO push value back onto stack for another op etc 
b3c2			 
b3c2			;		pop hl 
b3c2			 
b3c2			.dot_done: 
b3c2 cd 81 98				call forth_push_numhl 
b3c5			 
b3c5					NEXTW 
b3c5 c3 ea 9b			jp macro_next 
b3c8				endm 
# End of macro NEXTW
b3c8			.NEG: 
b3c8			 
b3c8				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b3c8 17				db WORD_SYS_CORE+3             
b3c9 0b b4			dw .DIV            
b3cb 02				db 1 + 1 
b3cc .. 00			db "-",0              
b3ce				endm 
# End of macro CWHEAD
b3ce			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b3ce					if DEBUG_FORTH_WORDS_KEY 
b3ce						DMARK "SUB" 
b3ce f5				push af  
b3cf 3a e3 b3			ld a, (.dmark)  
b3d2 32 c0 ee			ld (debug_mark),a  
b3d5 3a e4 b3			ld a, (.dmark+1)  
b3d8 32 c1 ee			ld (debug_mark+1),a  
b3db 3a e5 b3			ld a, (.dmark+2)  
b3de 32 c2 ee			ld (debug_mark+2),a  
b3e1 18 03			jr .pastdmark  
b3e3 ..			.dmark: db "SUB"  
b3e6 f1			.pastdmark: pop af  
b3e7			endm  
# End of macro DMARK
b3e7						CALLMONITOR 
b3e7 cd f4 92			call break_point_state  
b3ea				endm  
# End of macro CALLMONITOR
b3ea					endif 
b3ea			 
b3ea			 
b3ea				; TODO add floating point number detection 
b3ea					; v5 FORTH_DSP_VALUE 
b3ea					FORTH_DSP 
b3ea cd 3e 9a			call macro_forth_dsp 
b3ed				endm 
# End of macro FORTH_DSP
b3ed 7e					ld a,(hl)	; get type of value on TOS 
b3ee fe 02				cp DS_TYPE_INUM  
b3f0 28 03				jr z, .neg_inum 
b3f2			 
b3f2					NEXTW 
b3f2 c3 ea 9b			jp macro_next 
b3f5				endm 
# End of macro NEXTW
b3f5			 
b3f5			; float maths 
b3f5			 
b3f5				if FORTH_ENABLE_FLOATMATH 
b3f5					jr .neg_done 
b3f5			 
b3f5				endif 
b3f5					 
b3f5			 
b3f5			.neg_inum: 
b3f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f5 cd 78 9a			call macro_dsp_valuehl 
b3f8				endm 
# End of macro FORTH_DSP_VALUEHL
b3f8			 
b3f8 e5					push hl 
b3f9			 
b3f9					; destroy value TOS 
b3f9			 
b3f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3f9 cd 30 9b			call macro_forth_dsp_pop 
b3fc				endm 
# End of macro FORTH_DSP_POP
b3fc			 
b3fc			 
b3fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fc cd 78 9a			call macro_dsp_valuehl 
b3ff				endm 
# End of macro FORTH_DSP_VALUEHL
b3ff			 
b3ff					; one value on hl get other one back 
b3ff			 
b3ff d1					pop de 
b400			 
b400					; do the sub 
b400			;		ex de, hl 
b400			 
b400 ed 52				sbc hl,de 
b402			 
b402					; save it 
b402			 
b402			;		push hl	 
b402			 
b402					; 
b402			 
b402					; destroy value TOS 
b402			 
b402					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b402 cd 30 9b			call macro_forth_dsp_pop 
b405				endm 
# End of macro FORTH_DSP_POP
b405			 
b405					; TODO push value back onto stack for another op etc 
b405			 
b405			;		pop hl 
b405			 
b405 cd 81 98				call forth_push_numhl 
b408			.neg_done: 
b408			 
b408					NEXTW 
b408 c3 ea 9b			jp macro_next 
b40b				endm 
# End of macro NEXTW
b40b			.DIV: 
b40b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b40b 18				db WORD_SYS_CORE+4             
b40c 58 b4			dw .MUL            
b40e 02				db 1 + 1 
b40f .. 00			db "/",0              
b411				endm 
# End of macro CWHEAD
b411			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b411					if DEBUG_FORTH_WORDS_KEY 
b411						DMARK "DIV" 
b411 f5				push af  
b412 3a 26 b4			ld a, (.dmark)  
b415 32 c0 ee			ld (debug_mark),a  
b418 3a 27 b4			ld a, (.dmark+1)  
b41b 32 c1 ee			ld (debug_mark+1),a  
b41e 3a 28 b4			ld a, (.dmark+2)  
b421 32 c2 ee			ld (debug_mark+2),a  
b424 18 03			jr .pastdmark  
b426 ..			.dmark: db "DIV"  
b429 f1			.pastdmark: pop af  
b42a			endm  
# End of macro DMARK
b42a						CALLMONITOR 
b42a cd f4 92			call break_point_state  
b42d				endm  
# End of macro CALLMONITOR
b42d					endif 
b42d				; TODO add floating point number detection 
b42d					; v5 FORTH_DSP_VALUE 
b42d					FORTH_DSP 
b42d cd 3e 9a			call macro_forth_dsp 
b430				endm 
# End of macro FORTH_DSP
b430 7e					ld a,(hl)	; get type of value on TOS 
b431 fe 02				cp DS_TYPE_INUM  
b433 28 03				jr z, .div_inum 
b435			 
b435				if FORTH_ENABLE_FLOATMATH 
b435					jr .div_done 
b435			 
b435				endif 
b435					NEXTW 
b435 c3 ea 9b			jp macro_next 
b438				endm 
# End of macro NEXTW
b438			.div_inum: 
b438			 
b438					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b438 cd 78 9a			call macro_dsp_valuehl 
b43b				endm 
# End of macro FORTH_DSP_VALUEHL
b43b			 
b43b e5					push hl    ; to go to bc 
b43c			 
b43c					; destroy value TOS 
b43c			 
b43c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b43c cd 30 9b			call macro_forth_dsp_pop 
b43f				endm 
# End of macro FORTH_DSP_POP
b43f			 
b43f			 
b43f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b43f cd 78 9a			call macro_dsp_valuehl 
b442				endm 
# End of macro FORTH_DSP_VALUEHL
b442			 
b442					; hl to go to de 
b442			 
b442 e5					push hl 
b443			 
b443 c1					pop bc 
b444 d1					pop de		 
b445			 
b445			 
b445					if DEBUG_FORTH_MATHS 
b445						DMARK "DIV" 
b445				CALLMONITOR 
b445					endif 
b445					; one value on hl but move to a get other one back 
b445			 
b445			        
b445 cd 04 8a			call Div16 
b448			 
b448			;	push af	 
b448 e5				push hl 
b449 c5				push bc 
b44a			 
b44a					if DEBUG_FORTH_MATHS 
b44a						DMARK "DI1" 
b44a				CALLMONITOR 
b44a					endif 
b44a			 
b44a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44a cd 30 9b			call macro_forth_dsp_pop 
b44d				endm 
# End of macro FORTH_DSP_POP
b44d			 
b44d			 
b44d			 
b44d e1					pop hl    ; result 
b44e			 
b44e cd 81 98				call forth_push_numhl 
b451			 
b451 e1					pop hl    ; reminder 
b452			;		ld h,0 
b452			;		ld l,d 
b452			 
b452 cd 81 98				call forth_push_numhl 
b455			.div_done: 
b455					NEXTW 
b455 c3 ea 9b			jp macro_next 
b458				endm 
# End of macro NEXTW
b458			.MUL: 
b458				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b458 19				db WORD_SYS_CORE+5             
b459 9d b4			dw .MIN            
b45b 02				db 1 + 1 
b45c .. 00			db "*",0              
b45e				endm 
# End of macro CWHEAD
b45e			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b45e				; TODO add floating point number detection 
b45e					if DEBUG_FORTH_WORDS_KEY 
b45e						DMARK "MUL" 
b45e f5				push af  
b45f 3a 73 b4			ld a, (.dmark)  
b462 32 c0 ee			ld (debug_mark),a  
b465 3a 74 b4			ld a, (.dmark+1)  
b468 32 c1 ee			ld (debug_mark+1),a  
b46b 3a 75 b4			ld a, (.dmark+2)  
b46e 32 c2 ee			ld (debug_mark+2),a  
b471 18 03			jr .pastdmark  
b473 ..			.dmark: db "MUL"  
b476 f1			.pastdmark: pop af  
b477			endm  
# End of macro DMARK
b477						CALLMONITOR 
b477 cd f4 92			call break_point_state  
b47a				endm  
# End of macro CALLMONITOR
b47a					endif 
b47a					FORTH_DSP 
b47a cd 3e 9a			call macro_forth_dsp 
b47d				endm 
# End of macro FORTH_DSP
b47d					; v5 FORTH_DSP_VALUE 
b47d 7e					ld a,(hl)	; get type of value on TOS 
b47e fe 02				cp DS_TYPE_INUM  
b480 28 03				jr z, .mul_inum 
b482			 
b482				if FORTH_ENABLE_FLOATMATH 
b482					jr .mul_done 
b482			 
b482				endif 
b482			 
b482					NEXTW 
b482 c3 ea 9b			jp macro_next 
b485				endm 
# End of macro NEXTW
b485			.mul_inum:	 
b485			 
b485					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b485 cd 78 9a			call macro_dsp_valuehl 
b488				endm 
# End of macro FORTH_DSP_VALUEHL
b488			 
b488 e5					push hl 
b489			 
b489					; destroy value TOS 
b489			 
b489					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b489 cd 30 9b			call macro_forth_dsp_pop 
b48c				endm 
# End of macro FORTH_DSP_POP
b48c			 
b48c			 
b48c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b48c cd 78 9a			call macro_dsp_valuehl 
b48f				endm 
# End of macro FORTH_DSP_VALUEHL
b48f			 
b48f					; one value on hl but move to a get other one back 
b48f			 
b48f 7d					ld a, l 
b490			 
b490 d1					pop de 
b491			 
b491					; do the mull 
b491			;		ex de, hl 
b491			 
b491 cd 2a 8a				call Mult16 
b494					; save it 
b494			 
b494			;		push hl	 
b494			 
b494					; 
b494			 
b494					; destroy value TOS 
b494			 
b494					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b494 cd 30 9b			call macro_forth_dsp_pop 
b497				endm 
# End of macro FORTH_DSP_POP
b497			 
b497					; TODO push value back onto stack for another op etc 
b497			 
b497			;		pop hl 
b497			 
b497 cd 81 98				call forth_push_numhl 
b49a			 
b49a			.mul_done: 
b49a					NEXTW 
b49a c3 ea 9b			jp macro_next 
b49d				endm 
# End of macro NEXTW
b49d			 
b49d			 
b49d			 
b49d			 
b49d			.MIN: 
b49d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b49d 49				db WORD_SYS_CORE+53             
b49e 1e b5			dw .MAX            
b4a0 04				db 3 + 1 
b4a1 .. 00			db "MIN",0              
b4a5				endm 
# End of macro CWHEAD
b4a5			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b4a5					if DEBUG_FORTH_WORDS_KEY 
b4a5						DMARK "MIN" 
b4a5 f5				push af  
b4a6 3a ba b4			ld a, (.dmark)  
b4a9 32 c0 ee			ld (debug_mark),a  
b4ac 3a bb b4			ld a, (.dmark+1)  
b4af 32 c1 ee			ld (debug_mark+1),a  
b4b2 3a bc b4			ld a, (.dmark+2)  
b4b5 32 c2 ee			ld (debug_mark+2),a  
b4b8 18 03			jr .pastdmark  
b4ba ..			.dmark: db "MIN"  
b4bd f1			.pastdmark: pop af  
b4be			endm  
# End of macro DMARK
b4be						CALLMONITOR 
b4be cd f4 92			call break_point_state  
b4c1				endm  
# End of macro CALLMONITOR
b4c1					endif 
b4c1					; get u2 
b4c1			 
b4c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4c1 cd 78 9a			call macro_dsp_valuehl 
b4c4				endm 
# End of macro FORTH_DSP_VALUEHL
b4c4			 
b4c4 e5					push hl   ; u2 
b4c5			 
b4c5					; destroy value TOS 
b4c5			 
b4c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4c5 cd 30 9b			call macro_forth_dsp_pop 
b4c8				endm 
# End of macro FORTH_DSP_POP
b4c8			 
b4c8					; get u1 
b4c8			 
b4c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4c8 cd 78 9a			call macro_dsp_valuehl 
b4cb				endm 
# End of macro FORTH_DSP_VALUEHL
b4cb			 
b4cb e5					push hl  ; u1 
b4cc			 
b4cc					; destroy value TOS 
b4cc			 
b4cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4cc cd 30 9b			call macro_forth_dsp_pop 
b4cf				endm 
# End of macro FORTH_DSP_POP
b4cf			 
b4cf b7			 or a      ;clear carry flag 
b4d0 e1			  pop hl    ; u1 
b4d1 d1			  pop de    ; u2 
b4d2 e5				push hl   ; saved in case hl is lowest 
b4d3 ed 52		  sbc hl,de 
b4d5 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b4d7			 
b4d7 e1				pop hl 
b4d8					if DEBUG_FORTH_WORDS 
b4d8						DMARK "MIN" 
b4d8 f5				push af  
b4d9 3a ed b4			ld a, (.dmark)  
b4dc 32 c0 ee			ld (debug_mark),a  
b4df 3a ee b4			ld a, (.dmark+1)  
b4e2 32 c1 ee			ld (debug_mark+1),a  
b4e5 3a ef b4			ld a, (.dmark+2)  
b4e8 32 c2 ee			ld (debug_mark+2),a  
b4eb 18 03			jr .pastdmark  
b4ed ..			.dmark: db "MIN"  
b4f0 f1			.pastdmark: pop af  
b4f1			endm  
# End of macro DMARK
b4f1						CALLMONITOR 
b4f1 cd f4 92			call break_point_state  
b4f4				endm  
# End of macro CALLMONITOR
b4f4					endif 
b4f4 cd 81 98				call forth_push_numhl 
b4f7			 
b4f7				       NEXTW 
b4f7 c3 ea 9b			jp macro_next 
b4fa				endm 
# End of macro NEXTW
b4fa			 
b4fa			.mincont:  
b4fa c1				pop bc   ; tidy up 
b4fb eb				ex de , hl  
b4fc					if DEBUG_FORTH_WORDS 
b4fc						DMARK "MI1" 
b4fc f5				push af  
b4fd 3a 11 b5			ld a, (.dmark)  
b500 32 c0 ee			ld (debug_mark),a  
b503 3a 12 b5			ld a, (.dmark+1)  
b506 32 c1 ee			ld (debug_mark+1),a  
b509 3a 13 b5			ld a, (.dmark+2)  
b50c 32 c2 ee			ld (debug_mark+2),a  
b50f 18 03			jr .pastdmark  
b511 ..			.dmark: db "MI1"  
b514 f1			.pastdmark: pop af  
b515			endm  
# End of macro DMARK
b515						CALLMONITOR 
b515 cd f4 92			call break_point_state  
b518				endm  
# End of macro CALLMONITOR
b518					endif 
b518 cd 81 98				call forth_push_numhl 
b51b			 
b51b				       NEXTW 
b51b c3 ea 9b			jp macro_next 
b51e				endm 
# End of macro NEXTW
b51e			.MAX: 
b51e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b51e 4a				db WORD_SYS_CORE+54             
b51f 9f b5			dw .RND16            
b521 04				db 3 + 1 
b522 .. 00			db "MAX",0              
b526				endm 
# End of macro CWHEAD
b526			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b526					if DEBUG_FORTH_WORDS_KEY 
b526						DMARK "MAX" 
b526 f5				push af  
b527 3a 3b b5			ld a, (.dmark)  
b52a 32 c0 ee			ld (debug_mark),a  
b52d 3a 3c b5			ld a, (.dmark+1)  
b530 32 c1 ee			ld (debug_mark+1),a  
b533 3a 3d b5			ld a, (.dmark+2)  
b536 32 c2 ee			ld (debug_mark+2),a  
b539 18 03			jr .pastdmark  
b53b ..			.dmark: db "MAX"  
b53e f1			.pastdmark: pop af  
b53f			endm  
# End of macro DMARK
b53f						CALLMONITOR 
b53f cd f4 92			call break_point_state  
b542				endm  
# End of macro CALLMONITOR
b542					endif 
b542					; get u2 
b542			 
b542					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b542 cd 78 9a			call macro_dsp_valuehl 
b545				endm 
# End of macro FORTH_DSP_VALUEHL
b545			 
b545 e5					push hl   ; u2 
b546			 
b546					; destroy value TOS 
b546			 
b546					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b546 cd 30 9b			call macro_forth_dsp_pop 
b549				endm 
# End of macro FORTH_DSP_POP
b549			 
b549					; get u1 
b549			 
b549					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b549 cd 78 9a			call macro_dsp_valuehl 
b54c				endm 
# End of macro FORTH_DSP_VALUEHL
b54c			 
b54c e5					push hl  ; u1 
b54d			 
b54d					; destroy value TOS 
b54d			 
b54d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b54d cd 30 9b			call macro_forth_dsp_pop 
b550				endm 
# End of macro FORTH_DSP_POP
b550			 
b550 b7			 or a      ;clear carry flag 
b551 e1			  pop hl    ; u1 
b552 d1			  pop de    ; u2 
b553 e5				push hl   ; saved in case hl is lowest 
b554 ed 52		  sbc hl,de 
b556 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b558			 
b558 e1				pop hl 
b559					if DEBUG_FORTH_WORDS 
b559						DMARK "MAX" 
b559 f5				push af  
b55a 3a 6e b5			ld a, (.dmark)  
b55d 32 c0 ee			ld (debug_mark),a  
b560 3a 6f b5			ld a, (.dmark+1)  
b563 32 c1 ee			ld (debug_mark+1),a  
b566 3a 70 b5			ld a, (.dmark+2)  
b569 32 c2 ee			ld (debug_mark+2),a  
b56c 18 03			jr .pastdmark  
b56e ..			.dmark: db "MAX"  
b571 f1			.pastdmark: pop af  
b572			endm  
# End of macro DMARK
b572						CALLMONITOR 
b572 cd f4 92			call break_point_state  
b575				endm  
# End of macro CALLMONITOR
b575					endif 
b575 cd 81 98				call forth_push_numhl 
b578			 
b578				       NEXTW 
b578 c3 ea 9b			jp macro_next 
b57b				endm 
# End of macro NEXTW
b57b			 
b57b			.maxcont:  
b57b c1				pop bc   ; tidy up 
b57c eb				ex de , hl  
b57d					if DEBUG_FORTH_WORDS 
b57d						DMARK "MA1" 
b57d f5				push af  
b57e 3a 92 b5			ld a, (.dmark)  
b581 32 c0 ee			ld (debug_mark),a  
b584 3a 93 b5			ld a, (.dmark+1)  
b587 32 c1 ee			ld (debug_mark+1),a  
b58a 3a 94 b5			ld a, (.dmark+2)  
b58d 32 c2 ee			ld (debug_mark+2),a  
b590 18 03			jr .pastdmark  
b592 ..			.dmark: db "MA1"  
b595 f1			.pastdmark: pop af  
b596			endm  
# End of macro DMARK
b596						CALLMONITOR 
b596 cd f4 92			call break_point_state  
b599				endm  
# End of macro CALLMONITOR
b599					endif 
b599 cd 81 98				call forth_push_numhl 
b59c				       NEXTW 
b59c c3 ea 9b			jp macro_next 
b59f				endm 
# End of macro NEXTW
b59f			 
b59f			.RND16: 
b59f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b59f 4e				db WORD_SYS_CORE+58             
b5a0 ce b5			dw .RND8            
b5a2 06				db 5 + 1 
b5a3 .. 00			db "RND16",0              
b5a9				endm 
# End of macro CWHEAD
b5a9			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b5a9					if DEBUG_FORTH_WORDS_KEY 
b5a9						DMARK "R16" 
b5a9 f5				push af  
b5aa 3a be b5			ld a, (.dmark)  
b5ad 32 c0 ee			ld (debug_mark),a  
b5b0 3a bf b5			ld a, (.dmark+1)  
b5b3 32 c1 ee			ld (debug_mark+1),a  
b5b6 3a c0 b5			ld a, (.dmark+2)  
b5b9 32 c2 ee			ld (debug_mark+2),a  
b5bc 18 03			jr .pastdmark  
b5be ..			.dmark: db "R16"  
b5c1 f1			.pastdmark: pop af  
b5c2			endm  
# End of macro DMARK
b5c2						CALLMONITOR 
b5c2 cd f4 92			call break_point_state  
b5c5				endm  
# End of macro CALLMONITOR
b5c5					endif 
b5c5 cd ce 89				call prng16  
b5c8 cd 81 98				call forth_push_numhl 
b5cb				       NEXTW 
b5cb c3 ea 9b			jp macro_next 
b5ce				endm 
# End of macro NEXTW
b5ce			.RND8: 
b5ce				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b5ce 60				db WORD_SYS_CORE+76             
b5cf 03 b6			dw .RND            
b5d1 05				db 4 + 1 
b5d2 .. 00			db "RND8",0              
b5d7				endm 
# End of macro CWHEAD
b5d7			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b5d7					if DEBUG_FORTH_WORDS_KEY 
b5d7						DMARK "RN8" 
b5d7 f5				push af  
b5d8 3a ec b5			ld a, (.dmark)  
b5db 32 c0 ee			ld (debug_mark),a  
b5de 3a ed b5			ld a, (.dmark+1)  
b5e1 32 c1 ee			ld (debug_mark+1),a  
b5e4 3a ee b5			ld a, (.dmark+2)  
b5e7 32 c2 ee			ld (debug_mark+2),a  
b5ea 18 03			jr .pastdmark  
b5ec ..			.dmark: db "RN8"  
b5ef f1			.pastdmark: pop af  
b5f0			endm  
# End of macro DMARK
b5f0						CALLMONITOR 
b5f0 cd f4 92			call break_point_state  
b5f3				endm  
# End of macro CALLMONITOR
b5f3					endif 
b5f3 2a 41 ed				ld hl,(xrandc) 
b5f6 23					inc hl 
b5f7 cd e8 89				call xrnd 
b5fa 6f					ld l,a	 
b5fb 26 00				ld h,0 
b5fd cd 81 98				call forth_push_numhl 
b600				       NEXTW 
b600 c3 ea 9b			jp macro_next 
b603				endm 
# End of macro NEXTW
b603			.RND: 
b603				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b603 60				db WORD_SYS_CORE+76             
b604 09 b7			dw .ENDMATHS            
b606 04				db 3 + 1 
b607 .. 00			db "RND",0              
b60b				endm 
# End of macro CWHEAD
b60b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b60b			 
b60b					if DEBUG_FORTH_WORDS_KEY 
b60b						DMARK "RND" 
b60b f5				push af  
b60c 3a 20 b6			ld a, (.dmark)  
b60f 32 c0 ee			ld (debug_mark),a  
b612 3a 21 b6			ld a, (.dmark+1)  
b615 32 c1 ee			ld (debug_mark+1),a  
b618 3a 22 b6			ld a, (.dmark+2)  
b61b 32 c2 ee			ld (debug_mark+2),a  
b61e 18 03			jr .pastdmark  
b620 ..			.dmark: db "RND"  
b623 f1			.pastdmark: pop af  
b624			endm  
# End of macro DMARK
b624						CALLMONITOR 
b624 cd f4 92			call break_point_state  
b627				endm  
# End of macro CALLMONITOR
b627					endif 
b627					 
b627					FORTH_DSP_VALUEHL    ; upper range 
b627 cd 78 9a			call macro_dsp_valuehl 
b62a				endm 
# End of macro FORTH_DSP_VALUEHL
b62a			 
b62a 22 45 ed				ld (LFSRSeed), hl	 
b62d			 
b62d					if DEBUG_FORTH_WORDS 
b62d						DMARK "RN1" 
b62d f5				push af  
b62e 3a 42 b6			ld a, (.dmark)  
b631 32 c0 ee			ld (debug_mark),a  
b634 3a 43 b6			ld a, (.dmark+1)  
b637 32 c1 ee			ld (debug_mark+1),a  
b63a 3a 44 b6			ld a, (.dmark+2)  
b63d 32 c2 ee			ld (debug_mark+2),a  
b640 18 03			jr .pastdmark  
b642 ..			.dmark: db "RN1"  
b645 f1			.pastdmark: pop af  
b646			endm  
# End of macro DMARK
b646						CALLMONITOR 
b646 cd f4 92			call break_point_state  
b649				endm  
# End of macro CALLMONITOR
b649					endif 
b649					FORTH_DSP_POP 
b649 cd 30 9b			call macro_forth_dsp_pop 
b64c				endm 
# End of macro FORTH_DSP_POP
b64c			 
b64c					FORTH_DSP_VALUEHL    ; low range 
b64c cd 78 9a			call macro_dsp_valuehl 
b64f				endm 
# End of macro FORTH_DSP_VALUEHL
b64f			 
b64f					if DEBUG_FORTH_WORDS 
b64f						DMARK "RN2" 
b64f f5				push af  
b650 3a 64 b6			ld a, (.dmark)  
b653 32 c0 ee			ld (debug_mark),a  
b656 3a 65 b6			ld a, (.dmark+1)  
b659 32 c1 ee			ld (debug_mark+1),a  
b65c 3a 66 b6			ld a, (.dmark+2)  
b65f 32 c2 ee			ld (debug_mark+2),a  
b662 18 03			jr .pastdmark  
b664 ..			.dmark: db "RN2"  
b667 f1			.pastdmark: pop af  
b668			endm  
# End of macro DMARK
b668						CALLMONITOR 
b668 cd f4 92			call break_point_state  
b66b				endm  
# End of macro CALLMONITOR
b66b					endif 
b66b 22 47 ed				ld (LFSRSeed+2), hl 
b66e			 
b66e					FORTH_DSP_POP 
b66e cd 30 9b			call macro_forth_dsp_pop 
b671				endm 
# End of macro FORTH_DSP_POP
b671			 
b671 e5					push hl 
b672			 
b672 e1			.inrange:	pop hl 
b673 cd ce 89				call prng16  
b676					if DEBUG_FORTH_WORDS 
b676						DMARK "RN3" 
b676 f5				push af  
b677 3a 8b b6			ld a, (.dmark)  
b67a 32 c0 ee			ld (debug_mark),a  
b67d 3a 8c b6			ld a, (.dmark+1)  
b680 32 c1 ee			ld (debug_mark+1),a  
b683 3a 8d b6			ld a, (.dmark+2)  
b686 32 c2 ee			ld (debug_mark+2),a  
b689 18 03			jr .pastdmark  
b68b ..			.dmark: db "RN3"  
b68e f1			.pastdmark: pop af  
b68f			endm  
# End of macro DMARK
b68f						CALLMONITOR 
b68f cd f4 92			call break_point_state  
b692				endm  
# End of macro CALLMONITOR
b692					endif 
b692					 
b692					; if the range is 8bit knock out the high byte 
b692			 
b692 ed 5b 45 ed			ld de, (LFSRSeed)     ; check high level 
b696			 
b696 3e 00				ld a, 0 
b698 ba					cp d  
b699 20 1e				jr nz, .hirange 
b69b 26 00				ld h, 0   ; knock it down to 8bit 
b69d			 
b69d					if DEBUG_FORTH_WORDS 
b69d						DMARK "RNk" 
b69d f5				push af  
b69e 3a b2 b6			ld a, (.dmark)  
b6a1 32 c0 ee			ld (debug_mark),a  
b6a4 3a b3 b6			ld a, (.dmark+1)  
b6a7 32 c1 ee			ld (debug_mark+1),a  
b6aa 3a b4 b6			ld a, (.dmark+2)  
b6ad 32 c2 ee			ld (debug_mark+2),a  
b6b0 18 03			jr .pastdmark  
b6b2 ..			.dmark: db "RNk"  
b6b5 f1			.pastdmark: pop af  
b6b6			endm  
# End of macro DMARK
b6b6						CALLMONITOR 
b6b6 cd f4 92			call break_point_state  
b6b9				endm  
# End of macro CALLMONITOR
b6b9					endif 
b6b9			.hirange:   
b6b9 e5					push hl  
b6ba b7					or a  
b6bb ed 52		                sbc hl, de 
b6bd			 
b6bd					;call cmp16 
b6bd			 
b6bd 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b6bf e1					pop hl 
b6c0 e5					push hl 
b6c1			 
b6c1					if DEBUG_FORTH_WORDS 
b6c1						DMARK "RN4" 
b6c1 f5				push af  
b6c2 3a d6 b6			ld a, (.dmark)  
b6c5 32 c0 ee			ld (debug_mark),a  
b6c8 3a d7 b6			ld a, (.dmark+1)  
b6cb 32 c1 ee			ld (debug_mark+1),a  
b6ce 3a d8 b6			ld a, (.dmark+2)  
b6d1 32 c2 ee			ld (debug_mark+2),a  
b6d4 18 03			jr .pastdmark  
b6d6 ..			.dmark: db "RN4"  
b6d9 f1			.pastdmark: pop af  
b6da			endm  
# End of macro DMARK
b6da						CALLMONITOR 
b6da cd f4 92			call break_point_state  
b6dd				endm  
# End of macro CALLMONITOR
b6dd					endif 
b6dd ed 5b 47 ed			ld de, (LFSRSeed+2)   ; check low range 
b6e1					;call cmp16 
b6e1				 
b6e1 b7					or a  
b6e2 ed 52		                sbc hl, de 
b6e4 38 8c				jr c, .inrange 
b6e6			 
b6e6 e1					pop hl 
b6e7					 
b6e7					if DEBUG_FORTH_WORDS 
b6e7						DMARK "RNd" 
b6e7 f5				push af  
b6e8 3a fc b6			ld a, (.dmark)  
b6eb 32 c0 ee			ld (debug_mark),a  
b6ee 3a fd b6			ld a, (.dmark+1)  
b6f1 32 c1 ee			ld (debug_mark+1),a  
b6f4 3a fe b6			ld a, (.dmark+2)  
b6f7 32 c2 ee			ld (debug_mark+2),a  
b6fa 18 03			jr .pastdmark  
b6fc ..			.dmark: db "RNd"  
b6ff f1			.pastdmark: pop af  
b700			endm  
# End of macro DMARK
b700						CALLMONITOR 
b700 cd f4 92			call break_point_state  
b703				endm  
# End of macro CALLMONITOR
b703					endif 
b703			 
b703			 
b703 cd 81 98				call forth_push_numhl 
b706				       NEXTW 
b706 c3 ea 9b			jp macro_next 
b709				endm 
# End of macro NEXTW
b709			 
b709			.ENDMATHS: 
b709			 
b709			; eof 
b709			 
# End of file forth_words_maths.asm
b709			include "forth_words_display.asm" 
b709			 
b709			; | ## Display Words 
b709			 
b709			.ATP: 
b709				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b709 62				db WORD_SYS_CORE+78             
b70a 80 b7			dw .FB            
b70c 04				db 3 + 1 
b70d .. 00			db "AT?",0              
b711				endm 
# End of macro CWHEAD
b711			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b711					if DEBUG_FORTH_WORDS_KEY 
b711						DMARK "AT?" 
b711 f5				push af  
b712 3a 26 b7			ld a, (.dmark)  
b715 32 c0 ee			ld (debug_mark),a  
b718 3a 27 b7			ld a, (.dmark+1)  
b71b 32 c1 ee			ld (debug_mark+1),a  
b71e 3a 28 b7			ld a, (.dmark+2)  
b721 32 c2 ee			ld (debug_mark+2),a  
b724 18 03			jr .pastdmark  
b726 ..			.dmark: db "AT?"  
b729 f1			.pastdmark: pop af  
b72a			endm  
# End of macro DMARK
b72a						CALLMONITOR 
b72a cd f4 92			call break_point_state  
b72d				endm  
# End of macro CALLMONITOR
b72d					endif 
b72d 3a cf ec				ld a, (f_cursor_ptr) 
b730			 
b730			if DEBUG_FORTH_WORDS 
b730				DMARK "AT?" 
b730 f5				push af  
b731 3a 45 b7			ld a, (.dmark)  
b734 32 c0 ee			ld (debug_mark),a  
b737 3a 46 b7			ld a, (.dmark+1)  
b73a 32 c1 ee			ld (debug_mark+1),a  
b73d 3a 47 b7			ld a, (.dmark+2)  
b740 32 c2 ee			ld (debug_mark+2),a  
b743 18 03			jr .pastdmark  
b745 ..			.dmark: db "AT?"  
b748 f1			.pastdmark: pop af  
b749			endm  
# End of macro DMARK
b749				CALLMONITOR 
b749 cd f4 92			call break_point_state  
b74c				endm  
# End of macro CALLMONITOR
b74c			endif	 
b74c					; count the number of rows 
b74c			 
b74c 06 00				ld b, 0 
b74e 4f			.atpr:		ld c, a    ; save in case we go below zero 
b74f d6 14				sub display_cols 
b751 f2 57 b7				jp p, .atprunder 
b754 04					inc b 
b755 18 f7				jr .atpr 
b757			.atprunder:	 
b757			if DEBUG_FORTH_WORDS 
b757				DMARK "A?2" 
b757 f5				push af  
b758 3a 6c b7			ld a, (.dmark)  
b75b 32 c0 ee			ld (debug_mark),a  
b75e 3a 6d b7			ld a, (.dmark+1)  
b761 32 c1 ee			ld (debug_mark+1),a  
b764 3a 6e b7			ld a, (.dmark+2)  
b767 32 c2 ee			ld (debug_mark+2),a  
b76a 18 03			jr .pastdmark  
b76c ..			.dmark: db "A?2"  
b76f f1			.pastdmark: pop af  
b770			endm  
# End of macro DMARK
b770				CALLMONITOR 
b770 cd f4 92			call break_point_state  
b773				endm  
# End of macro CALLMONITOR
b773			endif	 
b773 26 00				ld h, 0 
b775 69					ld l, c 
b776 cd 81 98				call forth_push_numhl 
b779 68					ld l, b  
b77a cd 81 98				call forth_push_numhl 
b77d			 
b77d			 
b77d				NEXTW 
b77d c3 ea 9b			jp macro_next 
b780				endm 
# End of macro NEXTW
b780			 
b780			.FB: 
b780				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b780 1b				db WORD_SYS_CORE+7             
b781 ce b7			dw .EMIT            
b783 03				db 2 + 1 
b784 .. 00			db "FB",0              
b787				endm 
# End of macro CWHEAD
b787			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b787			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b787			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b787			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b787					if DEBUG_FORTH_WORDS_KEY 
b787						DMARK "FB." 
b787 f5				push af  
b788 3a 9c b7			ld a, (.dmark)  
b78b 32 c0 ee			ld (debug_mark),a  
b78e 3a 9d b7			ld a, (.dmark+1)  
b791 32 c1 ee			ld (debug_mark+1),a  
b794 3a 9e b7			ld a, (.dmark+2)  
b797 32 c2 ee			ld (debug_mark+2),a  
b79a 18 03			jr .pastdmark  
b79c ..			.dmark: db "FB."  
b79f f1			.pastdmark: pop af  
b7a0			endm  
# End of macro DMARK
b7a0						CALLMONITOR 
b7a0 cd f4 92			call break_point_state  
b7a3				endm  
# End of macro CALLMONITOR
b7a3					endif 
b7a3			 
b7a3					FORTH_DSP_VALUEHL 
b7a3 cd 78 9a			call macro_dsp_valuehl 
b7a6				endm 
# End of macro FORTH_DSP_VALUEHL
b7a6			 
b7a6 7d					ld a, l 
b7a7 fe 01				cp 1 
b7a9 20 05				jr nz, .fbn1 
b7ab 21 05 ee				ld hl, display_fb1 
b7ae 18 15				jr .fbset 
b7b0 fe 02		.fbn1:		cp 2 
b7b2 20 05				jr nz, .fbn2 
b7b4 21 63 ed				ld hl, display_fb2 
b7b7 18 0c				jr .fbset 
b7b9 fe 03		.fbn2:		cp 3 
b7bb 20 05				jr nz, .fbn3 
b7bd 21 b4 ed				ld hl, display_fb3 
b7c0 18 03				jr .fbset 
b7c2			.fbn3:		 ; if invalid number select first 
b7c2 21 05 ee				ld hl, display_fb1 
b7c5 22 61 ed		.fbset:		ld (display_fb_active), hl 
b7c8			 
b7c8					FORTH_DSP_POP 
b7c8 cd 30 9b			call macro_forth_dsp_pop 
b7cb				endm 
# End of macro FORTH_DSP_POP
b7cb			 
b7cb					NEXTW 
b7cb c3 ea 9b			jp macro_next 
b7ce				endm 
# End of macro NEXTW
b7ce			 
b7ce			 
b7ce			.EMIT: 
b7ce				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b7ce 1b				db WORD_SYS_CORE+7             
b7cf 1f b8			dw .DOTH            
b7d1 05				db 4 + 1 
b7d2 .. 00			db "EMIT",0              
b7d7				endm 
# End of macro CWHEAD
b7d7			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b7d7					; get value off TOS and display it 
b7d7			 
b7d7					if DEBUG_FORTH_WORDS_KEY 
b7d7						DMARK "EMT" 
b7d7 f5				push af  
b7d8 3a ec b7			ld a, (.dmark)  
b7db 32 c0 ee			ld (debug_mark),a  
b7de 3a ed b7			ld a, (.dmark+1)  
b7e1 32 c1 ee			ld (debug_mark+1),a  
b7e4 3a ee b7			ld a, (.dmark+2)  
b7e7 32 c2 ee			ld (debug_mark+2),a  
b7ea 18 03			jr .pastdmark  
b7ec ..			.dmark: db "EMT"  
b7ef f1			.pastdmark: pop af  
b7f0			endm  
# End of macro DMARK
b7f0						CALLMONITOR 
b7f0 cd f4 92			call break_point_state  
b7f3				endm  
# End of macro CALLMONITOR
b7f3					endif 
b7f3			 
b7f3					FORTH_DSP_VALUEHL 
b7f3 cd 78 9a			call macro_dsp_valuehl 
b7f6				endm 
# End of macro FORTH_DSP_VALUEHL
b7f6			 
b7f6 7d					ld a,l 
b7f7			 
b7f7					; TODO write to display 
b7f7			 
b7f7 32 e4 e6				ld (os_input), a 
b7fa 3e 00				ld a, 0 
b7fc 32 e5 e6				ld (os_input+1), a 
b7ff					 
b7ff 3a cf ec				ld a, (f_cursor_ptr) 
b802 11 e4 e6				ld de, os_input 
b805 cd 8d 88				call str_at_display 
b808			 
b808			 
b808 3a ad ec				ld a,(cli_autodisplay) 
b80b fe 00				cp 0 
b80d 28 03				jr z, .enoupdate 
b80f cd 9d 88						call update_display 
b812					.enoupdate: 
b812			 
b812 3a cf ec				ld a, (f_cursor_ptr) 
b815 3c					inc a 
b816 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b819			 
b819			 
b819					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b819 cd 30 9b			call macro_forth_dsp_pop 
b81c				endm 
# End of macro FORTH_DSP_POP
b81c			  
b81c			 
b81c					NEXTW 
b81c c3 ea 9b			jp macro_next 
b81f				endm 
# End of macro NEXTW
b81f			.DOTH: 
b81f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b81f 1c				db WORD_SYS_CORE+8             
b820 4f b8			dw .DOTF            
b822 03				db 2 + 1 
b823 .. 00			db ".-",0              
b826				endm 
# End of macro CWHEAD
b826			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b826					; get value off TOS and display it 
b826					if DEBUG_FORTH_WORDS_KEY 
b826						DMARK "DTD" 
b826 f5				push af  
b827 3a 3b b8			ld a, (.dmark)  
b82a 32 c0 ee			ld (debug_mark),a  
b82d 3a 3c b8			ld a, (.dmark+1)  
b830 32 c1 ee			ld (debug_mark+1),a  
b833 3a 3d b8			ld a, (.dmark+2)  
b836 32 c2 ee			ld (debug_mark+2),a  
b839 18 03			jr .pastdmark  
b83b ..			.dmark: db "DTD"  
b83e f1			.pastdmark: pop af  
b83f			endm  
# End of macro DMARK
b83f						CALLMONITOR 
b83f cd f4 92			call break_point_state  
b842				endm  
# End of macro CALLMONITOR
b842					endif 
b842 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b844 3e 00			ld a, 0 
b846 32 ae ec			ld (cli_mvdot), a 
b849 c3 a6 b8			jp .dotgo 
b84c				NEXTW 
b84c c3 ea 9b			jp macro_next 
b84f				endm 
# End of macro NEXTW
b84f			.DOTF: 
b84f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b84f 1c				db WORD_SYS_CORE+8             
b850 7d b8			dw .DOT            
b852 03				db 2 + 1 
b853 .. 00			db ".>",0              
b856				endm 
# End of macro CWHEAD
b856			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b856					; get value off TOS and display it 
b856			        ; TODO BUG adds extra spaces 
b856			        ; TODO BUG handle numerics? 
b856					if DEBUG_FORTH_WORDS_KEY 
b856						DMARK "DTC" 
b856 f5				push af  
b857 3a 6b b8			ld a, (.dmark)  
b85a 32 c0 ee			ld (debug_mark),a  
b85d 3a 6c b8			ld a, (.dmark+1)  
b860 32 c1 ee			ld (debug_mark+1),a  
b863 3a 6d b8			ld a, (.dmark+2)  
b866 32 c2 ee			ld (debug_mark+2),a  
b869 18 03			jr .pastdmark  
b86b ..			.dmark: db "DTC"  
b86e f1			.pastdmark: pop af  
b86f			endm  
# End of macro DMARK
b86f						CALLMONITOR 
b86f cd f4 92			call break_point_state  
b872				endm  
# End of macro CALLMONITOR
b872					endif 
b872 3e 01			ld a, 1 
b874 32 ae ec			ld (cli_mvdot), a 
b877 c3 a6 b8			jp .dotgo 
b87a				NEXTW 
b87a c3 ea 9b			jp macro_next 
b87d				endm 
# End of macro NEXTW
b87d			 
b87d			.DOT: 
b87d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b87d 1c				db WORD_SYS_CORE+8             
b87e 09 b9			dw .CLS            
b880 02				db 1 + 1 
b881 .. 00			db ".",0              
b883				endm 
# End of macro CWHEAD
b883			        ; | . ( u -- ) Display TOS | DONE 
b883					; get value off TOS and display it 
b883			 
b883					if DEBUG_FORTH_WORDS_KEY 
b883						DMARK "DOT" 
b883 f5				push af  
b884 3a 98 b8			ld a, (.dmark)  
b887 32 c0 ee			ld (debug_mark),a  
b88a 3a 99 b8			ld a, (.dmark+1)  
b88d 32 c1 ee			ld (debug_mark+1),a  
b890 3a 9a b8			ld a, (.dmark+2)  
b893 32 c2 ee			ld (debug_mark+2),a  
b896 18 03			jr .pastdmark  
b898 ..			.dmark: db "DOT"  
b89b f1			.pastdmark: pop af  
b89c			endm  
# End of macro DMARK
b89c						CALLMONITOR 
b89c cd f4 92			call break_point_state  
b89f				endm  
# End of macro CALLMONITOR
b89f					endif 
b89f 3e 00			ld a, 0 
b8a1 32 ae ec			ld (cli_mvdot), a 
b8a4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b8a6				 
b8a6			 
b8a6			.dotgo: 
b8a6			 
b8a6			; move up type to on stack for parserv5 
b8a6					FORTH_DSP 
b8a6 cd 3e 9a			call macro_forth_dsp 
b8a9				endm 
# End of macro FORTH_DSP
b8a9				;FORTH_DSP_VALUE  
b8a9			 
b8a9			if DEBUG_FORTH_DOT 
b8a9				DMARK "DOT" 
b8a9				CALLMONITOR 
b8a9			endif	 
b8a9			;		.print: 
b8a9			 
b8a9 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b8aa 23				inc hl   ; position to the actual value 
b8ab fe 01			cp DS_TYPE_STR 
b8ad 20 06			jr nz, .dotnum1  
b8af			 
b8af			; display string 
b8af				FORTH_DSP_VALUE  
b8af cd 61 9a			call macro_forth_dsp_value 
b8b2				endm 
# End of macro FORTH_DSP_VALUE
b8b2 eb				ex de,hl 
b8b3 18 11			jr .dotwrite 
b8b5			 
b8b5			.dotnum1: 
b8b5 fe 02			cp DS_TYPE_INUM 
b8b7 20 0c			jr nz, .dotflot 
b8b9			 
b8b9			 
b8b9			; display number 
b8b9			 
b8b9			;	push hl 
b8b9			;	call clear_display 
b8b9			;	pop hl 
b8b9			 
b8b9 5e				ld e, (hl) 
b8ba 23				inc hl 
b8bb 56				ld d, (hl) 
b8bc 21 e6 e4			ld hl, scratch 
b8bf			if DEBUG_FORTH_DOT 
b8bf				DMARK "DT1" 
b8bf				CALLMONITOR 
b8bf			endif	 
b8bf			 
b8bf cd b4 8e			call uitoa_16 
b8c2 eb				ex de,hl 
b8c3			 
b8c3			if DEBUG_FORTH_DOT 
b8c3				DMARK "DT2" 
b8c3				CALLMONITOR 
b8c3			endif	 
b8c3			 
b8c3			;	ld de, os_word_scratch 
b8c3 18 01			jr .dotwrite 
b8c5			 
b8c5 00			.dotflot:   nop 
b8c6			; TODO print floating point number 
b8c6			 
b8c6			.dotwrite:		 
b8c6			 
b8c6					; if c is set then set all '-' to spaces 
b8c6					; need to also take into account .>  
b8c6			 
b8c6 3e 01				ld a, 1 
b8c8 b9					cp c 
b8c9 20 13				jr nz, .nodashswap 
b8cb			 
b8cb					; DE has the string to write, working with HL 
b8cb			 
b8cb 06 ff				ld b, 255 
b8cd d5					push de 
b8ce e1					pop hl 
b8cf			 
b8cf			if DEBUG_FORTH_DOT 
b8cf				DMARK "DT-" 
b8cf				CALLMONITOR 
b8cf			endif	 
b8cf 7e			.dashscan:	ld a, (hl) 
b8d0 fe 00				cp 0 
b8d2 28 0a				jr z, .nodashswap 
b8d4 fe 2d				cp '-' 
b8d6 20 03				jr nz, .dashskip 
b8d8 3e 20				ld a, ' ' 
b8da 77					ld (hl), a 
b8db 23			.dashskip:	inc hl 
b8dc			if DEBUG_FORTH_DOT 
b8dc				DMARK "D-2" 
b8dc				CALLMONITOR 
b8dc			endif	 
b8dc 10 f1				djnz .dashscan 
b8de			 
b8de			if DEBUG_FORTH_DOT 
b8de				DMARK "D-1" 
b8de				CALLMONITOR 
b8de			endif	 
b8de			 
b8de			.nodashswap: 
b8de			 
b8de e5					push hl   ; save string start in case we need to advance print 
b8df			 
b8df 3a cf ec				ld a, (f_cursor_ptr) 
b8e2 cd 8d 88				call str_at_display 
b8e5 3a ad ec				ld a,(cli_autodisplay) 
b8e8 fe 00				cp 0 
b8ea 28 03				jr z, .noupdate 
b8ec cd 9d 88						call update_display 
b8ef					.noupdate: 
b8ef			 
b8ef			 
b8ef					; see if we need to advance the print position 
b8ef			 
b8ef e1					pop hl   ; get back string 
b8f0			 
b8f0 3a ae ec				ld a, (cli_mvdot) 
b8f3			if DEBUG_FORTH_DOT 
b8f3					ld e,a 
b8f3				DMARK "D>1" 
b8f3				CALLMONITOR 
b8f3			endif	 
b8f3 fe 00				cp 0 
b8f5 28 0c				jr z, .noadv 
b8f7					; yes, lets advance the print position 
b8f7 3e 00				ld a, 0 
b8f9 cd 10 8f				call strlent 
b8fc 3a cf ec				ld a, (f_cursor_ptr) 
b8ff 85					add a,l 
b900					;call addatohl 
b900					;ld a, l 
b900 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b903			 
b903			if DEBUG_FORTH_DOT 
b903				DMARK "D->" 
b903				CALLMONITOR 
b903			endif	 
b903			 
b903			.noadv:	 
b903			 
b903					if DEBUG_FORTH_DOT_WAIT 
b903							call next_page_prompt 
b903					endif	 
b903			; TODO this pop off the stack causes a crash. i dont know why 
b903			 
b903			 
b903			if DEBUG_FORTH_DOT 
b903				DMARK "DTh" 
b903				CALLMONITOR 
b903			endif	 
b903			 
b903					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b903 cd 30 9b			call macro_forth_dsp_pop 
b906				endm 
# End of macro FORTH_DSP_POP
b906			 
b906			if DEBUG_FORTH_DOT 
b906				DMARK "DTi" 
b906				CALLMONITOR 
b906			endif	 
b906			 
b906			 
b906					NEXTW 
b906 c3 ea 9b			jp macro_next 
b909				endm 
# End of macro NEXTW
b909			 
b909			.CLS: 
b909				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b909 35				db WORD_SYS_CORE+33             
b90a 36 b9			dw .DRAW            
b90c 04				db 3 + 1 
b90d .. 00			db "CLS",0              
b911				endm 
# End of macro CWHEAD
b911			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b911					if DEBUG_FORTH_WORDS_KEY 
b911						DMARK "CLS" 
b911 f5				push af  
b912 3a 26 b9			ld a, (.dmark)  
b915 32 c0 ee			ld (debug_mark),a  
b918 3a 27 b9			ld a, (.dmark+1)  
b91b 32 c1 ee			ld (debug_mark+1),a  
b91e 3a 28 b9			ld a, (.dmark+2)  
b921 32 c2 ee			ld (debug_mark+2),a  
b924 18 03			jr .pastdmark  
b926 ..			.dmark: db "CLS"  
b929 f1			.pastdmark: pop af  
b92a			endm  
# End of macro DMARK
b92a						CALLMONITOR 
b92a cd f4 92			call break_point_state  
b92d				endm  
# End of macro CALLMONITOR
b92d					endif 
b92d cd 7a 88				call clear_display 
b930 c3 44 ba				jp .home		; and home cursor 
b933					NEXTW 
b933 c3 ea 9b			jp macro_next 
b936				endm 
# End of macro NEXTW
b936			 
b936			.DRAW: 
b936				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b936 36				db WORD_SYS_CORE+34             
b937 61 b9			dw .DUMP            
b939 05				db 4 + 1 
b93a .. 00			db "DRAW",0              
b93f				endm 
# End of macro CWHEAD
b93f			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b93f					if DEBUG_FORTH_WORDS_KEY 
b93f						DMARK "DRW" 
b93f f5				push af  
b940 3a 54 b9			ld a, (.dmark)  
b943 32 c0 ee			ld (debug_mark),a  
b946 3a 55 b9			ld a, (.dmark+1)  
b949 32 c1 ee			ld (debug_mark+1),a  
b94c 3a 56 b9			ld a, (.dmark+2)  
b94f 32 c2 ee			ld (debug_mark+2),a  
b952 18 03			jr .pastdmark  
b954 ..			.dmark: db "DRW"  
b957 f1			.pastdmark: pop af  
b958			endm  
# End of macro DMARK
b958						CALLMONITOR 
b958 cd f4 92			call break_point_state  
b95b				endm  
# End of macro CALLMONITOR
b95b					endif 
b95b cd 9d 88				call update_display 
b95e					NEXTW 
b95e c3 ea 9b			jp macro_next 
b961				endm 
# End of macro NEXTW
b961			 
b961			.DUMP: 
b961				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b961 37				db WORD_SYS_CORE+35             
b962 99 b9			dw .CDUMP            
b964 05				db 4 + 1 
b965 .. 00			db "DUMP",0              
b96a				endm 
# End of macro CWHEAD
b96a			; | DUMP ( x -- ) With address x display dump   | DONE 
b96a			; TODO pop address to use off of the stack 
b96a					if DEBUG_FORTH_WORDS_KEY 
b96a						DMARK "DUM" 
b96a f5				push af  
b96b 3a 7f b9			ld a, (.dmark)  
b96e 32 c0 ee			ld (debug_mark),a  
b971 3a 80 b9			ld a, (.dmark+1)  
b974 32 c1 ee			ld (debug_mark+1),a  
b977 3a 81 b9			ld a, (.dmark+2)  
b97a 32 c2 ee			ld (debug_mark+2),a  
b97d 18 03			jr .pastdmark  
b97f ..			.dmark: db "DUM"  
b982 f1			.pastdmark: pop af  
b983			endm  
# End of macro DMARK
b983						CALLMONITOR 
b983 cd f4 92			call break_point_state  
b986				endm  
# End of macro CALLMONITOR
b986					endif 
b986 cd 7a 88				call clear_display 
b989			 
b989					; get address 
b989			 
b989					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b989 cd 78 9a			call macro_dsp_valuehl 
b98c				endm 
# End of macro FORTH_DSP_VALUEHL
b98c				 
b98c					; save it for cdump 
b98c			 
b98c 22 09 e8				ld (os_cur_ptr),hl 
b98f			 
b98f					; destroy value TOS 
b98f			 
b98f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b98f cd 30 9b			call macro_forth_dsp_pop 
b992				endm 
# End of macro FORTH_DSP_POP
b992			 
b992 cd 01 97				call dumpcont	; skip old style of param parsing	 
b995 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b996					NEXTW 
b996 c3 ea 9b			jp macro_next 
b999				endm 
# End of macro NEXTW
b999			.CDUMP: 
b999				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b999 38				db WORD_SYS_CORE+36             
b99a c9 b9			dw .DAT            
b99c 06				db 5 + 1 
b99d .. 00			db "CDUMP",0              
b9a3				endm 
# End of macro CWHEAD
b9a3			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b9a3					if DEBUG_FORTH_WORDS_KEY 
b9a3						DMARK "CDP" 
b9a3 f5				push af  
b9a4 3a b8 b9			ld a, (.dmark)  
b9a7 32 c0 ee			ld (debug_mark),a  
b9aa 3a b9 b9			ld a, (.dmark+1)  
b9ad 32 c1 ee			ld (debug_mark+1),a  
b9b0 3a ba b9			ld a, (.dmark+2)  
b9b3 32 c2 ee			ld (debug_mark+2),a  
b9b6 18 03			jr .pastdmark  
b9b8 ..			.dmark: db "CDP"  
b9bb f1			.pastdmark: pop af  
b9bc			endm  
# End of macro DMARK
b9bc						CALLMONITOR 
b9bc cd f4 92			call break_point_state  
b9bf				endm  
# End of macro CALLMONITOR
b9bf					endif 
b9bf cd 7a 88				call clear_display 
b9c2 cd 01 97				call dumpcont	 
b9c5 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b9c6					NEXTW 
b9c6 c3 ea 9b			jp macro_next 
b9c9				endm 
# End of macro NEXTW
b9c9			 
b9c9			 
b9c9			 
b9c9			 
b9c9			.DAT: 
b9c9				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b9c9 3d				db WORD_SYS_CORE+41             
b9ca 1f ba			dw .HOME            
b9cc 03				db 2 + 1 
b9cd .. 00			db "AT",0              
b9d0				endm 
# End of macro CWHEAD
b9d0			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b9d0					if DEBUG_FORTH_WORDS_KEY 
b9d0						DMARK "AT." 
b9d0 f5				push af  
b9d1 3a e5 b9			ld a, (.dmark)  
b9d4 32 c0 ee			ld (debug_mark),a  
b9d7 3a e6 b9			ld a, (.dmark+1)  
b9da 32 c1 ee			ld (debug_mark+1),a  
b9dd 3a e7 b9			ld a, (.dmark+2)  
b9e0 32 c2 ee			ld (debug_mark+2),a  
b9e3 18 03			jr .pastdmark  
b9e5 ..			.dmark: db "AT."  
b9e8 f1			.pastdmark: pop af  
b9e9			endm  
# End of macro DMARK
b9e9						CALLMONITOR 
b9e9 cd f4 92			call break_point_state  
b9ec				endm  
# End of macro CALLMONITOR
b9ec					endif 
b9ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9ec cd 78 9a			call macro_dsp_valuehl 
b9ef				endm 
# End of macro FORTH_DSP_VALUEHL
b9ef			 
b9ef			 
b9ef					; TODO save cursor row 
b9ef 7d					ld a,l 
b9f0 fe 02				cp 2 
b9f2 20 04				jr nz, .crow3 
b9f4 3e 14				ld a, display_row_2 
b9f6 18 12				jr .ccol1 
b9f8 fe 03		.crow3:		cp 3 
b9fa 20 04				jr nz, .crow4 
b9fc 3e 28				ld a, display_row_3 
b9fe 18 0a				jr .ccol1 
ba00 fe 04		.crow4:		cp 4 
ba02 20 04				jr nz, .crow1 
ba04 3e 3c				ld a, display_row_4 
ba06 18 02				jr .ccol1 
ba08 3e 00		.crow1:		ld a,display_row_1 
ba0a f5			.ccol1:		push af			; got row offset 
ba0b 6f					ld l,a 
ba0c 26 00				ld h,0 
ba0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba0e cd 30 9b			call macro_forth_dsp_pop 
ba11				endm 
# End of macro FORTH_DSP_POP
ba11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba11 cd 78 9a			call macro_dsp_valuehl 
ba14				endm 
# End of macro FORTH_DSP_VALUEHL
ba14					; TODO save cursor col 
ba14 f1					pop af 
ba15 85					add l		; add col offset 
ba16 32 cf ec				ld (f_cursor_ptr), a 
ba19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba19 cd 30 9b			call macro_forth_dsp_pop 
ba1c				endm 
# End of macro FORTH_DSP_POP
ba1c			 
ba1c					; calculate  
ba1c			 
ba1c					NEXTW 
ba1c c3 ea 9b			jp macro_next 
ba1f				endm 
# End of macro NEXTW
ba1f			 
ba1f			 
ba1f			.HOME: 
ba1f				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
ba1f 41				db WORD_SYS_CORE+45             
ba20 4c ba			dw .SPACE            
ba22 05				db 4 + 1 
ba23 .. 00			db "HOME",0              
ba28				endm 
# End of macro CWHEAD
ba28			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
ba28					if DEBUG_FORTH_WORDS_KEY 
ba28						DMARK "HOM" 
ba28 f5				push af  
ba29 3a 3d ba			ld a, (.dmark)  
ba2c 32 c0 ee			ld (debug_mark),a  
ba2f 3a 3e ba			ld a, (.dmark+1)  
ba32 32 c1 ee			ld (debug_mark+1),a  
ba35 3a 3f ba			ld a, (.dmark+2)  
ba38 32 c2 ee			ld (debug_mark+2),a  
ba3b 18 03			jr .pastdmark  
ba3d ..			.dmark: db "HOM"  
ba40 f1			.pastdmark: pop af  
ba41			endm  
# End of macro DMARK
ba41						CALLMONITOR 
ba41 cd f4 92			call break_point_state  
ba44				endm  
# End of macro CALLMONITOR
ba44					endif 
ba44 3e 00		.home:		ld a, 0		; and home cursor 
ba46 32 cf ec				ld (f_cursor_ptr), a 
ba49					NEXTW 
ba49 c3 ea 9b			jp macro_next 
ba4c				endm 
# End of macro NEXTW
ba4c			 
ba4c			 
ba4c			.SPACE: 
ba4c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
ba4c 46				db WORD_SYS_CORE+50             
ba4d 7a ba			dw .SPACES            
ba4f 03				db 2 + 1 
ba50 .. 00			db "BL",0              
ba53				endm 
# End of macro CWHEAD
ba53			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
ba53					if DEBUG_FORTH_WORDS_KEY 
ba53						DMARK "BL." 
ba53 f5				push af  
ba54 3a 68 ba			ld a, (.dmark)  
ba57 32 c0 ee			ld (debug_mark),a  
ba5a 3a 69 ba			ld a, (.dmark+1)  
ba5d 32 c1 ee			ld (debug_mark+1),a  
ba60 3a 6a ba			ld a, (.dmark+2)  
ba63 32 c2 ee			ld (debug_mark+2),a  
ba66 18 03			jr .pastdmark  
ba68 ..			.dmark: db "BL."  
ba6b f1			.pastdmark: pop af  
ba6c			endm  
# End of macro DMARK
ba6c						CALLMONITOR 
ba6c cd f4 92			call break_point_state  
ba6f				endm  
# End of macro CALLMONITOR
ba6f					endif 
ba6f 21 78 ba				ld hl, .blstr 
ba72 cd ef 98				call forth_push_str 
ba75					 
ba75				       NEXTW 
ba75 c3 ea 9b			jp macro_next 
ba78				endm 
# End of macro NEXTW
ba78			 
ba78 .. 00		.blstr: db " ", 0 
ba7a			 
ba7a			.SPACES: 
ba7a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
ba7a 47				db WORD_SYS_CORE+51             
ba7b 15 bb			dw .SCROLL            
ba7d 07				db 6 + 1 
ba7e .. 00			db "SPACES",0              
ba85				endm 
# End of macro CWHEAD
ba85			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
ba85					if DEBUG_FORTH_WORDS_KEY 
ba85						DMARK "SPS" 
ba85 f5				push af  
ba86 3a 9a ba			ld a, (.dmark)  
ba89 32 c0 ee			ld (debug_mark),a  
ba8c 3a 9b ba			ld a, (.dmark+1)  
ba8f 32 c1 ee			ld (debug_mark+1),a  
ba92 3a 9c ba			ld a, (.dmark+2)  
ba95 32 c2 ee			ld (debug_mark+2),a  
ba98 18 03			jr .pastdmark  
ba9a ..			.dmark: db "SPS"  
ba9d f1			.pastdmark: pop af  
ba9e			endm  
# End of macro DMARK
ba9e						CALLMONITOR 
ba9e cd f4 92			call break_point_state  
baa1				endm  
# End of macro CALLMONITOR
baa1					endif 
baa1			 
baa1			 
baa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
baa1 cd 78 9a			call macro_dsp_valuehl 
baa4				endm 
# End of macro FORTH_DSP_VALUEHL
baa4			 
baa4			;		push hl    ; u 
baa4					if DEBUG_FORTH_WORDS 
baa4						DMARK "SPA" 
baa4 f5				push af  
baa5 3a b9 ba			ld a, (.dmark)  
baa8 32 c0 ee			ld (debug_mark),a  
baab 3a ba ba			ld a, (.dmark+1)  
baae 32 c1 ee			ld (debug_mark+1),a  
bab1 3a bb ba			ld a, (.dmark+2)  
bab4 32 c2 ee			ld (debug_mark+2),a  
bab7 18 03			jr .pastdmark  
bab9 ..			.dmark: db "SPA"  
babc f1			.pastdmark: pop af  
babd			endm  
# End of macro DMARK
babd						CALLMONITOR 
babd cd f4 92			call break_point_state  
bac0				endm  
# End of macro CALLMONITOR
bac0					endif 
bac0			 
bac0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bac0 cd 30 9b			call macro_forth_dsp_pop 
bac3				endm 
# End of macro FORTH_DSP_POP
bac3			;		pop hl 
bac3 4d					ld c, l 
bac4 06 00				ld b, 0 
bac6 21 e6 e4				ld hl, scratch  
bac9			 
bac9					if DEBUG_FORTH_WORDS 
bac9						DMARK "SP2" 
bac9 f5				push af  
baca 3a de ba			ld a, (.dmark)  
bacd 32 c0 ee			ld (debug_mark),a  
bad0 3a df ba			ld a, (.dmark+1)  
bad3 32 c1 ee			ld (debug_mark+1),a  
bad6 3a e0 ba			ld a, (.dmark+2)  
bad9 32 c2 ee			ld (debug_mark+2),a  
badc 18 03			jr .pastdmark  
bade ..			.dmark: db "SP2"  
bae1 f1			.pastdmark: pop af  
bae2			endm  
# End of macro DMARK
bae2						CALLMONITOR 
bae2 cd f4 92			call break_point_state  
bae5				endm  
# End of macro CALLMONITOR
bae5					endif 
bae5 3e 20				ld a, ' ' 
bae7 c5			.spaces1:	push bc 
bae8 77					ld (hl),a 
bae9 23					inc hl 
baea c1					pop bc 
baeb 10 fa				djnz .spaces1 
baed 3e 00				ld a,0 
baef 77					ld (hl),a 
baf0 21 e6 e4				ld hl, scratch 
baf3					if DEBUG_FORTH_WORDS 
baf3						DMARK "SP3" 
baf3 f5				push af  
baf4 3a 08 bb			ld a, (.dmark)  
baf7 32 c0 ee			ld (debug_mark),a  
bafa 3a 09 bb			ld a, (.dmark+1)  
bafd 32 c1 ee			ld (debug_mark+1),a  
bb00 3a 0a bb			ld a, (.dmark+2)  
bb03 32 c2 ee			ld (debug_mark+2),a  
bb06 18 03			jr .pastdmark  
bb08 ..			.dmark: db "SP3"  
bb0b f1			.pastdmark: pop af  
bb0c			endm  
# End of macro DMARK
bb0c						CALLMONITOR 
bb0c cd f4 92			call break_point_state  
bb0f				endm  
# End of macro CALLMONITOR
bb0f					endif 
bb0f cd ea 99				call forth_apush 
bb12			 
bb12				       NEXTW 
bb12 c3 ea 9b			jp macro_next 
bb15				endm 
# End of macro NEXTW
bb15			 
bb15			 
bb15			 
bb15			.SCROLL: 
bb15				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bb15 53				db WORD_SYS_CORE+63             
bb16 42 bb			dw .SCROLLD            
bb18 07				db 6 + 1 
bb19 .. 00			db "SCROLL",0              
bb20				endm 
# End of macro CWHEAD
bb20			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bb20					if DEBUG_FORTH_WORDS_KEY 
bb20						DMARK "SCR" 
bb20 f5				push af  
bb21 3a 35 bb			ld a, (.dmark)  
bb24 32 c0 ee			ld (debug_mark),a  
bb27 3a 36 bb			ld a, (.dmark+1)  
bb2a 32 c1 ee			ld (debug_mark+1),a  
bb2d 3a 37 bb			ld a, (.dmark+2)  
bb30 32 c2 ee			ld (debug_mark+2),a  
bb33 18 03			jr .pastdmark  
bb35 ..			.dmark: db "SCR"  
bb38 f1			.pastdmark: pop af  
bb39			endm  
# End of macro DMARK
bb39						CALLMONITOR 
bb39 cd f4 92			call break_point_state  
bb3c				endm  
# End of macro CALLMONITOR
bb3c					endif 
bb3c			 
bb3c cd 3c 88			call scroll_up 
bb3f			;	call update_display 
bb3f			 
bb3f					NEXTW 
bb3f c3 ea 9b			jp macro_next 
bb42				endm 
# End of macro NEXTW
bb42			 
bb42			 
bb42			 
bb42			;		; get dir 
bb42			; 
bb42			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb42			; 
bb42			;		push hl 
bb42			; 
bb42			;		; destroy value TOS 
bb42			; 
bb42			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb42			; 
bb42			;		; get count 
bb42			; 
bb42			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb42			; 
bb42			;		push hl 
bb42			; 
bb42			;		; destroy value TOS 
bb42			; 
bb42			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb42			; 
bb42			;		; one value on hl get other one back 
bb42			; 
bb42			;		pop bc    ; count 
bb42			; 
bb42			;		pop de   ; dir 
bb42			; 
bb42			; 
bb42			;		ld b, c 
bb42			; 
bb42			;.scrolldir:     push bc 
bb42			;		push de 
bb42			; 
bb42			;		ld a, 0 
bb42			;		cp e 
bb42			;		jr z, .scrollup  
bb42			;		call scroll_down 
bb42			;		jr .scrollnext 
bb42			;.scrollup:	call scroll_up 
bb42			; 
bb42			;		 
bb42			;.scrollnext: 
bb42			;		pop de 
bb42			;		pop bc 
bb42			;		djnz .scrolldir 
bb42			; 
bb42			; 
bb42			; 
bb42			; 
bb42			; 
bb42			;		NEXTW 
bb42			 
bb42			.SCROLLD: 
bb42				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bb42 53				db WORD_SYS_CORE+63             
bb43 70 bb			dw .ATQ            
bb45 08				db 7 + 1 
bb46 .. 00			db "SCROLLD",0              
bb4e				endm 
# End of macro CWHEAD
bb4e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bb4e					if DEBUG_FORTH_WORDS_KEY 
bb4e						DMARK "SCD" 
bb4e f5				push af  
bb4f 3a 63 bb			ld a, (.dmark)  
bb52 32 c0 ee			ld (debug_mark),a  
bb55 3a 64 bb			ld a, (.dmark+1)  
bb58 32 c1 ee			ld (debug_mark+1),a  
bb5b 3a 65 bb			ld a, (.dmark+2)  
bb5e 32 c2 ee			ld (debug_mark+2),a  
bb61 18 03			jr .pastdmark  
bb63 ..			.dmark: db "SCD"  
bb66 f1			.pastdmark: pop af  
bb67			endm  
# End of macro DMARK
bb67						CALLMONITOR 
bb67 cd f4 92			call break_point_state  
bb6a				endm  
# End of macro CALLMONITOR
bb6a					endif 
bb6a			 
bb6a cd 60 88			call scroll_down 
bb6d			;	call update_display 
bb6d			 
bb6d					NEXTW 
bb6d c3 ea 9b			jp macro_next 
bb70				endm 
# End of macro NEXTW
bb70			 
bb70			 
bb70			.ATQ: 
bb70				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bb70 62				db WORD_SYS_CORE+78             
bb71 ce bb			dw .AUTODSP            
bb73 04				db 3 + 1 
bb74 .. 00			db "AT@",0              
bb78				endm 
# End of macro CWHEAD
bb78			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bb78					if DEBUG_FORTH_WORDS_KEY 
bb78						DMARK "ATA" 
bb78 f5				push af  
bb79 3a 8d bb			ld a, (.dmark)  
bb7c 32 c0 ee			ld (debug_mark),a  
bb7f 3a 8e bb			ld a, (.dmark+1)  
bb82 32 c1 ee			ld (debug_mark+1),a  
bb85 3a 8f bb			ld a, (.dmark+2)  
bb88 32 c2 ee			ld (debug_mark+2),a  
bb8b 18 03			jr .pastdmark  
bb8d ..			.dmark: db "ATA"  
bb90 f1			.pastdmark: pop af  
bb91			endm  
# End of macro DMARK
bb91						CALLMONITOR 
bb91 cd f4 92			call break_point_state  
bb94				endm  
# End of macro CALLMONITOR
bb94					endif 
bb94			 
bb94			 
bb94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb94 cd 78 9a			call macro_dsp_valuehl 
bb97				endm 
# End of macro FORTH_DSP_VALUEHL
bb97			 
bb97					; TODO save cursor row 
bb97 7d					ld a,l 
bb98 fe 02				cp 2 
bb9a 20 04				jr nz, .crow3aq 
bb9c 3e 14				ld a, display_row_2 
bb9e 18 12				jr .ccol1aq 
bba0 fe 03		.crow3aq:		cp 3 
bba2 20 04				jr nz, .crow4aq 
bba4 3e 28				ld a, display_row_3 
bba6 18 0a				jr .ccol1aq 
bba8 fe 04		.crow4aq:		cp 4 
bbaa 20 04				jr nz, .crow1aq 
bbac 3e 3c				ld a, display_row_4 
bbae 18 02				jr .ccol1aq 
bbb0 3e 00		.crow1aq:		ld a,display_row_1 
bbb2 f5			.ccol1aq:		push af			; got row offset 
bbb3 6f					ld l,a 
bbb4 26 00				ld h,0 
bbb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbb6 cd 30 9b			call macro_forth_dsp_pop 
bbb9				endm 
# End of macro FORTH_DSP_POP
bbb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbb9 cd 78 9a			call macro_dsp_valuehl 
bbbc				endm 
# End of macro FORTH_DSP_VALUEHL
bbbc					; TODO save cursor col 
bbbc f1					pop af 
bbbd 85					add l		; add col offset 
bbbe			 
bbbe					; add current frame buffer address 
bbbe 2a 61 ed				ld hl, (display_fb_active) 
bbc1 cd a7 8a				call addatohl 
bbc4			 
bbc4			 
bbc4			 
bbc4			 
bbc4					; get char frame buffer location offset in hl 
bbc4			 
bbc4 7e					ld a,(hl) 
bbc5 26 00				ld h, 0 
bbc7 6f					ld l, a 
bbc8			 
bbc8 cd 81 98				call forth_push_numhl 
bbcb			 
bbcb			 
bbcb					NEXTW 
bbcb c3 ea 9b			jp macro_next 
bbce				endm 
# End of macro NEXTW
bbce			 
bbce			.AUTODSP: 
bbce				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bbce 63				db WORD_SYS_CORE+79             
bbcf e4 bb			dw .MENU            
bbd1 05				db 4 + 1 
bbd2 .. 00			db "ADSP",0              
bbd7				endm 
# End of macro CWHEAD
bbd7			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bbd7			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bbd7			 
bbd7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbd7 cd 78 9a			call macro_dsp_valuehl 
bbda				endm 
# End of macro FORTH_DSP_VALUEHL
bbda			 
bbda			;		push hl 
bbda			 
bbda					; destroy value TOS 
bbda			 
bbda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbda cd 30 9b			call macro_forth_dsp_pop 
bbdd				endm 
# End of macro FORTH_DSP_POP
bbdd			 
bbdd			;		pop hl 
bbdd			 
bbdd 7d					ld a,l 
bbde 32 ad ec				ld (cli_autodisplay), a 
bbe1				       NEXTW 
bbe1 c3 ea 9b			jp macro_next 
bbe4				endm 
# End of macro NEXTW
bbe4			 
bbe4			.MENU: 
bbe4				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bbe4 70				db WORD_SYS_CORE+92             
bbe5 8d bc			dw .ENDDISPLAY            
bbe7 05				db 4 + 1 
bbe8 .. 00			db "MENU",0              
bbed				endm 
# End of macro CWHEAD
bbed			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bbed			 
bbed			;		; get number of items on the stack 
bbed			; 
bbed				 
bbed					FORTH_DSP_VALUEHL 
bbed cd 78 9a			call macro_dsp_valuehl 
bbf0				endm 
# End of macro FORTH_DSP_VALUEHL
bbf0				 
bbf0					if DEBUG_FORTH_WORDS_KEY 
bbf0						DMARK "MNU" 
bbf0 f5				push af  
bbf1 3a 05 bc			ld a, (.dmark)  
bbf4 32 c0 ee			ld (debug_mark),a  
bbf7 3a 06 bc			ld a, (.dmark+1)  
bbfa 32 c1 ee			ld (debug_mark+1),a  
bbfd 3a 07 bc			ld a, (.dmark+2)  
bc00 32 c2 ee			ld (debug_mark+2),a  
bc03 18 03			jr .pastdmark  
bc05 ..			.dmark: db "MNU"  
bc08 f1			.pastdmark: pop af  
bc09			endm  
# End of macro DMARK
bc09						CALLMONITOR 
bc09 cd f4 92			call break_point_state  
bc0c				endm  
# End of macro CALLMONITOR
bc0c					endif 
bc0c			 
bc0c 45					ld b, l	 
bc0d 05					dec b 
bc0e			 
bc0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc0e cd 30 9b			call macro_forth_dsp_pop 
bc11				endm 
# End of macro FORTH_DSP_POP
bc11			 
bc11			 
bc11					; go directly through the stack to pluck out the string pointers and build an array 
bc11			 
bc11			;		FORTH_DSP 
bc11			 
bc11					; hl contains top most stack item 
bc11				 
bc11 11 e6 e4				ld de, scratch 
bc14			 
bc14			.mbuild: 
bc14			 
bc14					FORTH_DSP_VALUEHL 
bc14 cd 78 9a			call macro_dsp_valuehl 
bc17				endm 
# End of macro FORTH_DSP_VALUEHL
bc17			 
bc17					if DEBUG_FORTH_WORDS 
bc17						DMARK "MN3" 
bc17 f5				push af  
bc18 3a 2c bc			ld a, (.dmark)  
bc1b 32 c0 ee			ld (debug_mark),a  
bc1e 3a 2d bc			ld a, (.dmark+1)  
bc21 32 c1 ee			ld (debug_mark+1),a  
bc24 3a 2e bc			ld a, (.dmark+2)  
bc27 32 c2 ee			ld (debug_mark+2),a  
bc2a 18 03			jr .pastdmark  
bc2c ..			.dmark: db "MN3"  
bc2f f1			.pastdmark: pop af  
bc30			endm  
# End of macro DMARK
bc30						CALLMONITOR 
bc30 cd f4 92			call break_point_state  
bc33				endm  
# End of macro CALLMONITOR
bc33					endif 
bc33 eb					ex de, hl 
bc34 73					ld (hl), e 
bc35 23					inc hl 
bc36 72					ld (hl), d 
bc37 23					inc hl 
bc38 eb					ex de, hl 
bc39			 
bc39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc39 cd 30 9b			call macro_forth_dsp_pop 
bc3c				endm 
# End of macro FORTH_DSP_POP
bc3c			 
bc3c 10 d6				djnz .mbuild 
bc3e			 
bc3e					; done add term 
bc3e			 
bc3e eb					ex de, hl 
bc3f 36 00				ld (hl), 0 
bc41 23					inc hl 
bc42 36 00				ld (hl), 0 
bc44			 
bc44				 
bc44					 
bc44 21 e6 e4				ld hl, scratch 
bc47			 
bc47					if DEBUG_FORTH_WORDS 
bc47						DMARK "MNx" 
bc47 f5				push af  
bc48 3a 5c bc			ld a, (.dmark)  
bc4b 32 c0 ee			ld (debug_mark),a  
bc4e 3a 5d bc			ld a, (.dmark+1)  
bc51 32 c1 ee			ld (debug_mark+1),a  
bc54 3a 5e bc			ld a, (.dmark+2)  
bc57 32 c2 ee			ld (debug_mark+2),a  
bc5a 18 03			jr .pastdmark  
bc5c ..			.dmark: db "MNx"  
bc5f f1			.pastdmark: pop af  
bc60			endm  
# End of macro DMARK
bc60						CALLMONITOR 
bc60 cd f4 92			call break_point_state  
bc63				endm  
# End of macro CALLMONITOR
bc63					endif 
bc63			 
bc63			 
bc63			 
bc63 3e 00				ld a, 0 
bc65 cd ab 88				call menu 
bc68			 
bc68			 
bc68 6f					ld l, a 
bc69 26 00				ld h, 0 
bc6b			 
bc6b					if DEBUG_FORTH_WORDS 
bc6b						DMARK "MNr" 
bc6b f5				push af  
bc6c 3a 80 bc			ld a, (.dmark)  
bc6f 32 c0 ee			ld (debug_mark),a  
bc72 3a 81 bc			ld a, (.dmark+1)  
bc75 32 c1 ee			ld (debug_mark+1),a  
bc78 3a 82 bc			ld a, (.dmark+2)  
bc7b 32 c2 ee			ld (debug_mark+2),a  
bc7e 18 03			jr .pastdmark  
bc80 ..			.dmark: db "MNr"  
bc83 f1			.pastdmark: pop af  
bc84			endm  
# End of macro DMARK
bc84						CALLMONITOR 
bc84 cd f4 92			call break_point_state  
bc87				endm  
# End of macro CALLMONITOR
bc87					endif 
bc87			 
bc87 cd 81 98				call forth_push_numhl 
bc8a			 
bc8a			 
bc8a			 
bc8a			 
bc8a				       NEXTW 
bc8a c3 ea 9b			jp macro_next 
bc8d				endm 
# End of macro NEXTW
bc8d			 
bc8d			 
bc8d			.ENDDISPLAY: 
bc8d			 
bc8d			; eof 
# End of file forth_words_display.asm
bc8d			include "forth_words_str.asm" 
bc8d			 
bc8d			; | ## String Words 
bc8d			 
bc8d			.PTR:   
bc8d			 
bc8d				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bc8d 48				db WORD_SYS_CORE+52             
bc8e ba bc			dw .STYPE            
bc90 04				db 3 + 1 
bc91 .. 00			db "PTR",0              
bc95				endm 
# End of macro CWHEAD
bc95			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bc95			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bc95			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bc95			 
bc95					if DEBUG_FORTH_WORDS_KEY 
bc95						DMARK "PTR" 
bc95 f5				push af  
bc96 3a aa bc			ld a, (.dmark)  
bc99 32 c0 ee			ld (debug_mark),a  
bc9c 3a ab bc			ld a, (.dmark+1)  
bc9f 32 c1 ee			ld (debug_mark+1),a  
bca2 3a ac bc			ld a, (.dmark+2)  
bca5 32 c2 ee			ld (debug_mark+2),a  
bca8 18 03			jr .pastdmark  
bcaa ..			.dmark: db "PTR"  
bcad f1			.pastdmark: pop af  
bcae			endm  
# End of macro DMARK
bcae						CALLMONITOR 
bcae cd f4 92			call break_point_state  
bcb1				endm  
# End of macro CALLMONITOR
bcb1					endif 
bcb1					FORTH_DSP_VALUEHL 
bcb1 cd 78 9a			call macro_dsp_valuehl 
bcb4				endm 
# End of macro FORTH_DSP_VALUEHL
bcb4 cd 81 98				call forth_push_numhl 
bcb7			 
bcb7			 
bcb7					NEXTW 
bcb7 c3 ea 9b			jp macro_next 
bcba				endm 
# End of macro NEXTW
bcba			.STYPE: 
bcba				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bcba 48				db WORD_SYS_CORE+52             
bcbb 09 bd			dw .UPPER            
bcbd 06				db 5 + 1 
bcbe .. 00			db "STYPE",0              
bcc4				endm 
# End of macro CWHEAD
bcc4			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bcc4					if DEBUG_FORTH_WORDS_KEY 
bcc4						DMARK "STY" 
bcc4 f5				push af  
bcc5 3a d9 bc			ld a, (.dmark)  
bcc8 32 c0 ee			ld (debug_mark),a  
bccb 3a da bc			ld a, (.dmark+1)  
bcce 32 c1 ee			ld (debug_mark+1),a  
bcd1 3a db bc			ld a, (.dmark+2)  
bcd4 32 c2 ee			ld (debug_mark+2),a  
bcd7 18 03			jr .pastdmark  
bcd9 ..			.dmark: db "STY"  
bcdc f1			.pastdmark: pop af  
bcdd			endm  
# End of macro DMARK
bcdd						CALLMONITOR 
bcdd cd f4 92			call break_point_state  
bce0				endm  
# End of macro CALLMONITOR
bce0					endif 
bce0					FORTH_DSP 
bce0 cd 3e 9a			call macro_forth_dsp 
bce3				endm 
# End of macro FORTH_DSP
bce3					;v5 FORTH_DSP_VALUE 
bce3			 
bce3 7e					ld a, (hl) 
bce4			 
bce4 f5					push af 
bce5			 
bce5			; Dont destroy TOS		FORTH_DSP_POP 
bce5			 
bce5 f1					pop af 
bce6			 
bce6 fe 01				cp DS_TYPE_STR 
bce8 28 09				jr z, .typestr 
bcea			 
bcea fe 02				cp DS_TYPE_INUM 
bcec 28 0a				jr z, .typeinum 
bcee			 
bcee 21 07 bd				ld hl, .tna 
bcf1 18 0a				jr .tpush 
bcf3			 
bcf3 21 03 bd		.typestr:	ld hl, .tstr 
bcf6 18 05				jr .tpush 
bcf8 21 05 bd		.typeinum:	ld hl, .tinum 
bcfb 18 00				jr .tpush 
bcfd			 
bcfd			.tpush: 
bcfd			 
bcfd cd ef 98				call forth_push_str 
bd00			 
bd00					NEXTW 
bd00 c3 ea 9b			jp macro_next 
bd03				endm 
# End of macro NEXTW
bd03 .. 00		.tstr:	db "s",0 
bd05 .. 00		.tinum:  db "i",0 
bd07 .. 00		.tna:   db "?", 0 
bd09			 
bd09			 
bd09			.UPPER: 
bd09				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bd09 48				db WORD_SYS_CORE+52             
bd0a 44 bd			dw .LOWER            
bd0c 06				db 5 + 1 
bd0d .. 00			db "UPPER",0              
bd13				endm 
# End of macro CWHEAD
bd13			; | UPPER ( s -- s ) Upper case string s  | DONE 
bd13					if DEBUG_FORTH_WORDS_KEY 
bd13						DMARK "UPR" 
bd13 f5				push af  
bd14 3a 28 bd			ld a, (.dmark)  
bd17 32 c0 ee			ld (debug_mark),a  
bd1a 3a 29 bd			ld a, (.dmark+1)  
bd1d 32 c1 ee			ld (debug_mark+1),a  
bd20 3a 2a bd			ld a, (.dmark+2)  
bd23 32 c2 ee			ld (debug_mark+2),a  
bd26 18 03			jr .pastdmark  
bd28 ..			.dmark: db "UPR"  
bd2b f1			.pastdmark: pop af  
bd2c			endm  
# End of macro DMARK
bd2c						CALLMONITOR 
bd2c cd f4 92			call break_point_state  
bd2f				endm  
# End of macro CALLMONITOR
bd2f					endif 
bd2f			 
bd2f					FORTH_DSP 
bd2f cd 3e 9a			call macro_forth_dsp 
bd32				endm 
# End of macro FORTH_DSP
bd32					 
bd32			; TODO check is string type 
bd32			 
bd32					FORTH_DSP_VALUEHL 
bd32 cd 78 9a			call macro_dsp_valuehl 
bd35				endm 
# End of macro FORTH_DSP_VALUEHL
bd35			; get pointer to string in hl 
bd35			 
bd35 7e			.toup:		ld a, (hl) 
bd36 fe 00				cp 0 
bd38 28 07				jr z, .toupdone 
bd3a			 
bd3a cd 14 8e				call to_upper 
bd3d			 
bd3d 77					ld (hl), a 
bd3e 23					inc hl 
bd3f 18 f4				jr .toup 
bd41			 
bd41					 
bd41			 
bd41			 
bd41			; for each char convert to upper 
bd41					 
bd41			.toupdone: 
bd41			 
bd41			 
bd41					NEXTW 
bd41 c3 ea 9b			jp macro_next 
bd44				endm 
# End of macro NEXTW
bd44			.LOWER: 
bd44				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bd44 48				db WORD_SYS_CORE+52             
bd45 7f bd			dw .TCASE            
bd47 06				db 5 + 1 
bd48 .. 00			db "LOWER",0              
bd4e				endm 
# End of macro CWHEAD
bd4e			; | LOWER ( s -- s ) Lower case string s  | DONE 
bd4e					if DEBUG_FORTH_WORDS_KEY 
bd4e						DMARK "LWR" 
bd4e f5				push af  
bd4f 3a 63 bd			ld a, (.dmark)  
bd52 32 c0 ee			ld (debug_mark),a  
bd55 3a 64 bd			ld a, (.dmark+1)  
bd58 32 c1 ee			ld (debug_mark+1),a  
bd5b 3a 65 bd			ld a, (.dmark+2)  
bd5e 32 c2 ee			ld (debug_mark+2),a  
bd61 18 03			jr .pastdmark  
bd63 ..			.dmark: db "LWR"  
bd66 f1			.pastdmark: pop af  
bd67			endm  
# End of macro DMARK
bd67						CALLMONITOR 
bd67 cd f4 92			call break_point_state  
bd6a				endm  
# End of macro CALLMONITOR
bd6a					endif 
bd6a			 
bd6a					FORTH_DSP 
bd6a cd 3e 9a			call macro_forth_dsp 
bd6d				endm 
# End of macro FORTH_DSP
bd6d					 
bd6d			; TODO check is string type 
bd6d			 
bd6d					FORTH_DSP_VALUEHL 
bd6d cd 78 9a			call macro_dsp_valuehl 
bd70				endm 
# End of macro FORTH_DSP_VALUEHL
bd70			; get pointer to string in hl 
bd70			 
bd70 7e			.tolow:		ld a, (hl) 
bd71 fe 00				cp 0 
bd73 28 07				jr z, .tolowdone 
bd75			 
bd75 cd 1d 8e				call to_lower 
bd78			 
bd78 77					ld (hl), a 
bd79 23					inc hl 
bd7a 18 f4				jr .tolow 
bd7c			 
bd7c					 
bd7c			 
bd7c			 
bd7c			; for each char convert to low 
bd7c					 
bd7c			.tolowdone: 
bd7c					NEXTW 
bd7c c3 ea 9b			jp macro_next 
bd7f				endm 
# End of macro NEXTW
bd7f			.TCASE: 
bd7f				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bd7f 48				db WORD_SYS_CORE+52             
bd80 b5 be			dw .SUBSTR            
bd82 06				db 5 + 1 
bd83 .. 00			db "TCASE",0              
bd89				endm 
# End of macro CWHEAD
bd89			; | TCASE ( s -- s ) Title case string s  | DONE 
bd89					if DEBUG_FORTH_WORDS_KEY 
bd89						DMARK "TCS" 
bd89 f5				push af  
bd8a 3a 9e bd			ld a, (.dmark)  
bd8d 32 c0 ee			ld (debug_mark),a  
bd90 3a 9f bd			ld a, (.dmark+1)  
bd93 32 c1 ee			ld (debug_mark+1),a  
bd96 3a a0 bd			ld a, (.dmark+2)  
bd99 32 c2 ee			ld (debug_mark+2),a  
bd9c 18 03			jr .pastdmark  
bd9e ..			.dmark: db "TCS"  
bda1 f1			.pastdmark: pop af  
bda2			endm  
# End of macro DMARK
bda2						CALLMONITOR 
bda2 cd f4 92			call break_point_state  
bda5				endm  
# End of macro CALLMONITOR
bda5					endif 
bda5			 
bda5					FORTH_DSP 
bda5 cd 3e 9a			call macro_forth_dsp 
bda8				endm 
# End of macro FORTH_DSP
bda8					 
bda8			; TODO check is string type 
bda8			 
bda8					FORTH_DSP_VALUEHL 
bda8 cd 78 9a			call macro_dsp_valuehl 
bdab				endm 
# End of macro FORTH_DSP_VALUEHL
bdab			; get pointer to string in hl 
bdab			 
bdab					if DEBUG_FORTH_WORDS 
bdab						DMARK "TC1" 
bdab f5				push af  
bdac 3a c0 bd			ld a, (.dmark)  
bdaf 32 c0 ee			ld (debug_mark),a  
bdb2 3a c1 bd			ld a, (.dmark+1)  
bdb5 32 c1 ee			ld (debug_mark+1),a  
bdb8 3a c2 bd			ld a, (.dmark+2)  
bdbb 32 c2 ee			ld (debug_mark+2),a  
bdbe 18 03			jr .pastdmark  
bdc0 ..			.dmark: db "TC1"  
bdc3 f1			.pastdmark: pop af  
bdc4			endm  
# End of macro DMARK
bdc4						CALLMONITOR 
bdc4 cd f4 92			call break_point_state  
bdc7				endm  
# End of macro CALLMONITOR
bdc7					endif 
bdc7			 
bdc7					; first time in turn to upper case first char 
bdc7			 
bdc7 7e					ld a, (hl) 
bdc8 c3 52 be				jp .totsiptou 
bdcb			 
bdcb			 
bdcb 7e			.tot:		ld a, (hl) 
bdcc fe 00				cp 0 
bdce ca 96 be				jp z, .totdone 
bdd1			 
bdd1					if DEBUG_FORTH_WORDS 
bdd1						DMARK "TC2" 
bdd1 f5				push af  
bdd2 3a e6 bd			ld a, (.dmark)  
bdd5 32 c0 ee			ld (debug_mark),a  
bdd8 3a e7 bd			ld a, (.dmark+1)  
bddb 32 c1 ee			ld (debug_mark+1),a  
bdde 3a e8 bd			ld a, (.dmark+2)  
bde1 32 c2 ee			ld (debug_mark+2),a  
bde4 18 03			jr .pastdmark  
bde6 ..			.dmark: db "TC2"  
bde9 f1			.pastdmark: pop af  
bdea			endm  
# End of macro DMARK
bdea						CALLMONITOR 
bdea cd f4 92			call break_point_state  
bded				endm  
# End of macro CALLMONITOR
bded					endif 
bded					; check to see if current char is a space 
bded			 
bded fe 20				cp ' ' 
bdef 28 21				jr z, .totsp 
bdf1 cd 1d 8e				call to_lower 
bdf4					if DEBUG_FORTH_WORDS 
bdf4						DMARK "TC3" 
bdf4 f5				push af  
bdf5 3a 09 be			ld a, (.dmark)  
bdf8 32 c0 ee			ld (debug_mark),a  
bdfb 3a 0a be			ld a, (.dmark+1)  
bdfe 32 c1 ee			ld (debug_mark+1),a  
be01 3a 0b be			ld a, (.dmark+2)  
be04 32 c2 ee			ld (debug_mark+2),a  
be07 18 03			jr .pastdmark  
be09 ..			.dmark: db "TC3"  
be0c f1			.pastdmark: pop af  
be0d			endm  
# End of macro DMARK
be0d						CALLMONITOR 
be0d cd f4 92			call break_point_state  
be10				endm  
# End of macro CALLMONITOR
be10					endif 
be10 18 63				jr .totnxt 
be12			 
be12			.totsp:         ; on a space, find next char which should be upper 
be12			 
be12					if DEBUG_FORTH_WORDS 
be12						DMARK "TC4" 
be12 f5				push af  
be13 3a 27 be			ld a, (.dmark)  
be16 32 c0 ee			ld (debug_mark),a  
be19 3a 28 be			ld a, (.dmark+1)  
be1c 32 c1 ee			ld (debug_mark+1),a  
be1f 3a 29 be			ld a, (.dmark+2)  
be22 32 c2 ee			ld (debug_mark+2),a  
be25 18 03			jr .pastdmark  
be27 ..			.dmark: db "TC4"  
be2a f1			.pastdmark: pop af  
be2b			endm  
# End of macro DMARK
be2b						CALLMONITOR 
be2b cd f4 92			call break_point_state  
be2e				endm  
# End of macro CALLMONITOR
be2e					endif 
be2e					;; 
be2e			 
be2e fe 20				cp ' ' 
be30 20 20				jr nz, .totsiptou 
be32 23					inc hl 
be33 7e					ld a, (hl) 
be34					if DEBUG_FORTH_WORDS 
be34						DMARK "TC5" 
be34 f5				push af  
be35 3a 49 be			ld a, (.dmark)  
be38 32 c0 ee			ld (debug_mark),a  
be3b 3a 4a be			ld a, (.dmark+1)  
be3e 32 c1 ee			ld (debug_mark+1),a  
be41 3a 4b be			ld a, (.dmark+2)  
be44 32 c2 ee			ld (debug_mark+2),a  
be47 18 03			jr .pastdmark  
be49 ..			.dmark: db "TC5"  
be4c f1			.pastdmark: pop af  
be4d			endm  
# End of macro DMARK
be4d						CALLMONITOR 
be4d cd f4 92			call break_point_state  
be50				endm  
# End of macro CALLMONITOR
be50					endif 
be50 18 c0				jr .totsp 
be52 fe 00		.totsiptou:    cp 0 
be54 28 40				jr z, .totdone 
be56					; not space and not zero term so upper case it 
be56 cd 14 8e				call to_upper 
be59			 
be59					if DEBUG_FORTH_WORDS 
be59						DMARK "TC6" 
be59 f5				push af  
be5a 3a 6e be			ld a, (.dmark)  
be5d 32 c0 ee			ld (debug_mark),a  
be60 3a 6f be			ld a, (.dmark+1)  
be63 32 c1 ee			ld (debug_mark+1),a  
be66 3a 70 be			ld a, (.dmark+2)  
be69 32 c2 ee			ld (debug_mark+2),a  
be6c 18 03			jr .pastdmark  
be6e ..			.dmark: db "TC6"  
be71 f1			.pastdmark: pop af  
be72			endm  
# End of macro DMARK
be72						CALLMONITOR 
be72 cd f4 92			call break_point_state  
be75				endm  
# End of macro CALLMONITOR
be75					endif 
be75			 
be75			 
be75			.totnxt: 
be75			 
be75 77					ld (hl), a 
be76 23					inc hl 
be77					if DEBUG_FORTH_WORDS 
be77						DMARK "TC7" 
be77 f5				push af  
be78 3a 8c be			ld a, (.dmark)  
be7b 32 c0 ee			ld (debug_mark),a  
be7e 3a 8d be			ld a, (.dmark+1)  
be81 32 c1 ee			ld (debug_mark+1),a  
be84 3a 8e be			ld a, (.dmark+2)  
be87 32 c2 ee			ld (debug_mark+2),a  
be8a 18 03			jr .pastdmark  
be8c ..			.dmark: db "TC7"  
be8f f1			.pastdmark: pop af  
be90			endm  
# End of macro DMARK
be90						CALLMONITOR 
be90 cd f4 92			call break_point_state  
be93				endm  
# End of macro CALLMONITOR
be93					endif 
be93 c3 cb bd				jp .tot 
be96			 
be96					 
be96			 
be96			 
be96			; for each char convert to low 
be96					 
be96			.totdone: 
be96					if DEBUG_FORTH_WORDS 
be96						DMARK "TCd" 
be96 f5				push af  
be97 3a ab be			ld a, (.dmark)  
be9a 32 c0 ee			ld (debug_mark),a  
be9d 3a ac be			ld a, (.dmark+1)  
bea0 32 c1 ee			ld (debug_mark+1),a  
bea3 3a ad be			ld a, (.dmark+2)  
bea6 32 c2 ee			ld (debug_mark+2),a  
bea9 18 03			jr .pastdmark  
beab ..			.dmark: db "TCd"  
beae f1			.pastdmark: pop af  
beaf			endm  
# End of macro DMARK
beaf						CALLMONITOR 
beaf cd f4 92			call break_point_state  
beb2				endm  
# End of macro CALLMONITOR
beb2					endif 
beb2					NEXTW 
beb2 c3 ea 9b			jp macro_next 
beb5				endm 
# End of macro NEXTW
beb5			 
beb5			.SUBSTR: 
beb5				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
beb5 48				db WORD_SYS_CORE+52             
beb6 13 bf			dw .LEFT            
beb8 07				db 6 + 1 
beb9 .. 00			db "SUBSTR",0              
bec0				endm 
# End of macro CWHEAD
bec0			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bec0			 
bec0					if DEBUG_FORTH_WORDS_KEY 
bec0						DMARK "SST" 
bec0 f5				push af  
bec1 3a d5 be			ld a, (.dmark)  
bec4 32 c0 ee			ld (debug_mark),a  
bec7 3a d6 be			ld a, (.dmark+1)  
beca 32 c1 ee			ld (debug_mark+1),a  
becd 3a d7 be			ld a, (.dmark+2)  
bed0 32 c2 ee			ld (debug_mark+2),a  
bed3 18 03			jr .pastdmark  
bed5 ..			.dmark: db "SST"  
bed8 f1			.pastdmark: pop af  
bed9			endm  
# End of macro DMARK
bed9						CALLMONITOR 
bed9 cd f4 92			call break_point_state  
bedc				endm  
# End of macro CALLMONITOR
bedc					endif 
bedc			; TODO check string type 
bedc					FORTH_DSP_VALUEHL 
bedc cd 78 9a			call macro_dsp_valuehl 
bedf				endm 
# End of macro FORTH_DSP_VALUEHL
bedf			 
bedf e5					push hl      ; string length 
bee0			 
bee0					FORTH_DSP_POP 
bee0 cd 30 9b			call macro_forth_dsp_pop 
bee3				endm 
# End of macro FORTH_DSP_POP
bee3			 
bee3					FORTH_DSP_VALUEHL 
bee3 cd 78 9a			call macro_dsp_valuehl 
bee6				endm 
# End of macro FORTH_DSP_VALUEHL
bee6			 
bee6 e5					push hl     ; start char 
bee7			 
bee7					FORTH_DSP_POP 
bee7 cd 30 9b			call macro_forth_dsp_pop 
beea				endm 
# End of macro FORTH_DSP_POP
beea			 
beea			 
beea					FORTH_DSP_VALUE 
beea cd 61 9a			call macro_forth_dsp_value 
beed				endm 
# End of macro FORTH_DSP_VALUE
beed			 
beed d1					pop de    ; get start post offset 
beee			 
beee 19					add hl, de    ; starting offset 
beef			 
beef c1					pop bc 
bef0 c5					push bc      ; grab size of string 
bef1			 
bef1 e5					push hl    ; save string start  
bef2			 
bef2 26 00				ld h, 0 
bef4 69					ld l, c 
bef5 23					inc hl 
bef6 23					inc hl 
bef7			 
bef7 cd 6e 8f				call malloc 
befa				if DEBUG_FORTH_MALLOC_GUARD 
befa cc 29 c5				call z,malloc_error 
befd				endif 
befd			 
befd eb					ex de, hl      ; save malloc area for string copy 
befe e1					pop hl    ; get back source 
beff c1					pop bc    ; get length of string back 
bf00			 
bf00 d5					push de    ; save malloc area for after we push 
bf01 ed b0				ldir     ; copy substr 
bf03			 
bf03			 
bf03 eb					ex de, hl 
bf04 3e 00				ld a, 0 
bf06 77					ld (hl), a   ; term substr 
bf07			 
bf07					 
bf07 e1					pop hl    ; get malloc so we can push it 
bf08 e5					push hl   ; save so we can free it afterwards 
bf09			 
bf09 cd ef 98				call forth_push_str 
bf0c			 
bf0c e1					pop hl 
bf0d cd 38 90				call free 
bf10			 
bf10					 
bf10					 
bf10			 
bf10			 
bf10					NEXTW 
bf10 c3 ea 9b			jp macro_next 
bf13				endm 
# End of macro NEXTW
bf13			 
bf13			.LEFT: 
bf13				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bf13 48				db WORD_SYS_CORE+52             
bf14 3b bf			dw .RIGHT            
bf16 05				db 4 + 1 
bf17 .. 00			db "LEFT",0              
bf1c				endm 
# End of macro CWHEAD
bf1c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bf1c					if DEBUG_FORTH_WORDS_KEY 
bf1c						DMARK "LEF" 
bf1c f5				push af  
bf1d 3a 31 bf			ld a, (.dmark)  
bf20 32 c0 ee			ld (debug_mark),a  
bf23 3a 32 bf			ld a, (.dmark+1)  
bf26 32 c1 ee			ld (debug_mark+1),a  
bf29 3a 33 bf			ld a, (.dmark+2)  
bf2c 32 c2 ee			ld (debug_mark+2),a  
bf2f 18 03			jr .pastdmark  
bf31 ..			.dmark: db "LEF"  
bf34 f1			.pastdmark: pop af  
bf35			endm  
# End of macro DMARK
bf35						CALLMONITOR 
bf35 cd f4 92			call break_point_state  
bf38				endm  
# End of macro CALLMONITOR
bf38					endif 
bf38			 
bf38					NEXTW 
bf38 c3 ea 9b			jp macro_next 
bf3b				endm 
# End of macro NEXTW
bf3b			.RIGHT: 
bf3b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bf3b 48				db WORD_SYS_CORE+52             
bf3c 64 bf			dw .STR2NUM            
bf3e 06				db 5 + 1 
bf3f .. 00			db "RIGHT",0              
bf45				endm 
# End of macro CWHEAD
bf45			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bf45					if DEBUG_FORTH_WORDS_KEY 
bf45						DMARK "RIG" 
bf45 f5				push af  
bf46 3a 5a bf			ld a, (.dmark)  
bf49 32 c0 ee			ld (debug_mark),a  
bf4c 3a 5b bf			ld a, (.dmark+1)  
bf4f 32 c1 ee			ld (debug_mark+1),a  
bf52 3a 5c bf			ld a, (.dmark+2)  
bf55 32 c2 ee			ld (debug_mark+2),a  
bf58 18 03			jr .pastdmark  
bf5a ..			.dmark: db "RIG"  
bf5d f1			.pastdmark: pop af  
bf5e			endm  
# End of macro DMARK
bf5e						CALLMONITOR 
bf5e cd f4 92			call break_point_state  
bf61				endm  
# End of macro CALLMONITOR
bf61					endif 
bf61			 
bf61					NEXTW 
bf61 c3 ea 9b			jp macro_next 
bf64				endm 
# End of macro NEXTW
bf64			 
bf64			 
bf64			.STR2NUM: 
bf64				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bf64 48				db WORD_SYS_CORE+52             
bf65 f0 bf			dw .NUM2STR            
bf67 08				db 7 + 1 
bf68 .. 00			db "STR2NUM",0              
bf70				endm 
# End of macro CWHEAD
bf70			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bf70			 
bf70			 
bf70			; TODO STR type check to do 
bf70					if DEBUG_FORTH_WORDS_KEY 
bf70						DMARK "S2N" 
bf70 f5				push af  
bf71 3a 85 bf			ld a, (.dmark)  
bf74 32 c0 ee			ld (debug_mark),a  
bf77 3a 86 bf			ld a, (.dmark+1)  
bf7a 32 c1 ee			ld (debug_mark+1),a  
bf7d 3a 87 bf			ld a, (.dmark+2)  
bf80 32 c2 ee			ld (debug_mark+2),a  
bf83 18 03			jr .pastdmark  
bf85 ..			.dmark: db "S2N"  
bf88 f1			.pastdmark: pop af  
bf89			endm  
# End of macro DMARK
bf89						CALLMONITOR 
bf89 cd f4 92			call break_point_state  
bf8c				endm  
# End of macro CALLMONITOR
bf8c					endif 
bf8c			 
bf8c					;FORTH_DSP 
bf8c					FORTH_DSP_VALUE 
bf8c cd 61 9a			call macro_forth_dsp_value 
bf8f				endm 
# End of macro FORTH_DSP_VALUE
bf8f					;inc hl 
bf8f			 
bf8f eb					ex de, hl 
bf90					if DEBUG_FORTH_WORDS 
bf90						DMARK "S2a" 
bf90 f5				push af  
bf91 3a a5 bf			ld a, (.dmark)  
bf94 32 c0 ee			ld (debug_mark),a  
bf97 3a a6 bf			ld a, (.dmark+1)  
bf9a 32 c1 ee			ld (debug_mark+1),a  
bf9d 3a a7 bf			ld a, (.dmark+2)  
bfa0 32 c2 ee			ld (debug_mark+2),a  
bfa3 18 03			jr .pastdmark  
bfa5 ..			.dmark: db "S2a"  
bfa8 f1			.pastdmark: pop af  
bfa9			endm  
# End of macro DMARK
bfa9						CALLMONITOR 
bfa9 cd f4 92			call break_point_state  
bfac				endm  
# End of macro CALLMONITOR
bfac					endif 
bfac cd 9c 8e				call string_to_uint16 
bfaf			 
bfaf					if DEBUG_FORTH_WORDS 
bfaf						DMARK "S2b" 
bfaf f5				push af  
bfb0 3a c4 bf			ld a, (.dmark)  
bfb3 32 c0 ee			ld (debug_mark),a  
bfb6 3a c5 bf			ld a, (.dmark+1)  
bfb9 32 c1 ee			ld (debug_mark+1),a  
bfbc 3a c6 bf			ld a, (.dmark+2)  
bfbf 32 c2 ee			ld (debug_mark+2),a  
bfc2 18 03			jr .pastdmark  
bfc4 ..			.dmark: db "S2b"  
bfc7 f1			.pastdmark: pop af  
bfc8			endm  
# End of macro DMARK
bfc8						CALLMONITOR 
bfc8 cd f4 92			call break_point_state  
bfcb				endm  
# End of macro CALLMONITOR
bfcb					endif 
bfcb			;		push hl 
bfcb					FORTH_DSP_POP 
bfcb cd 30 9b			call macro_forth_dsp_pop 
bfce				endm 
# End of macro FORTH_DSP_POP
bfce			;		pop hl 
bfce					 
bfce					if DEBUG_FORTH_WORDS 
bfce						DMARK "S2b" 
bfce f5				push af  
bfcf 3a e3 bf			ld a, (.dmark)  
bfd2 32 c0 ee			ld (debug_mark),a  
bfd5 3a e4 bf			ld a, (.dmark+1)  
bfd8 32 c1 ee			ld (debug_mark+1),a  
bfdb 3a e5 bf			ld a, (.dmark+2)  
bfde 32 c2 ee			ld (debug_mark+2),a  
bfe1 18 03			jr .pastdmark  
bfe3 ..			.dmark: db "S2b"  
bfe6 f1			.pastdmark: pop af  
bfe7			endm  
# End of macro DMARK
bfe7						CALLMONITOR 
bfe7 cd f4 92			call break_point_state  
bfea				endm  
# End of macro CALLMONITOR
bfea					endif 
bfea cd 81 98				call forth_push_numhl	 
bfed			 
bfed				 
bfed				       NEXTW 
bfed c3 ea 9b			jp macro_next 
bff0				endm 
# End of macro NEXTW
bff0			.NUM2STR: 
bff0				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bff0 48				db WORD_SYS_CORE+52             
bff1 ff bf			dw .CONCAT            
bff3 08				db 7 + 1 
bff4 .. 00			db "NUM2STR",0              
bffc				endm 
# End of macro CWHEAD
bffc			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bffc			 
bffc			;		; malloc a string to target 
bffc			;		ld hl, 10     ; TODO max string size should be fine 
bffc			;		call malloc 
bffc			;		push hl    ; save malloc location 
bffc			; 
bffc			; 
bffc			;; TODO check int type 
bffc			;		FORTH_DSP_VALUEHL 
bffc			;		ld a, l 
bffc			;		call DispAToASCII   
bffc			;;TODO need to chage above call to dump into string 
bffc			; 
bffc			; 
bffc			 
bffc				       NEXTW 
bffc c3 ea 9b			jp macro_next 
bfff				endm 
# End of macro NEXTW
bfff			 
bfff			.CONCAT: 
bfff				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bfff 48				db WORD_SYS_CORE+52             
c000 b2 c0			dw .FIND            
c002 07				db 6 + 1 
c003 .. 00			db "CONCAT",0              
c00a				endm 
# End of macro CWHEAD
c00a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c00a			 
c00a			; TODO check string type 
c00a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c00a			 
c00a					if DEBUG_FORTH_WORDS_KEY 
c00a						DMARK "CON" 
c00a f5				push af  
c00b 3a 1f c0			ld a, (.dmark)  
c00e 32 c0 ee			ld (debug_mark),a  
c011 3a 20 c0			ld a, (.dmark+1)  
c014 32 c1 ee			ld (debug_mark+1),a  
c017 3a 21 c0			ld a, (.dmark+2)  
c01a 32 c2 ee			ld (debug_mark+2),a  
c01d 18 03			jr .pastdmark  
c01f ..			.dmark: db "CON"  
c022 f1			.pastdmark: pop af  
c023			endm  
# End of macro DMARK
c023						CALLMONITOR 
c023 cd f4 92			call break_point_state  
c026				endm  
# End of macro CALLMONITOR
c026					endif 
c026			 
c026			 
c026					FORTH_DSP_VALUE 
c026 cd 61 9a			call macro_forth_dsp_value 
c029				endm 
# End of macro FORTH_DSP_VALUE
c029 e5					push hl   ; s2 
c02a			 
c02a					FORTH_DSP_POP 
c02a cd 30 9b			call macro_forth_dsp_pop 
c02d				endm 
# End of macro FORTH_DSP_POP
c02d			 
c02d					FORTH_DSP_VALUE 
c02d cd 61 9a			call macro_forth_dsp_value 
c030				endm 
# End of macro FORTH_DSP_VALUE
c030			 
c030 e5					push hl   ; s1 
c031			 
c031					FORTH_DSP_POP 
c031 cd 30 9b			call macro_forth_dsp_pop 
c034				endm 
# End of macro FORTH_DSP_POP
c034					 
c034			 
c034					; copy s1 
c034			 
c034				 
c034					; save ptr 
c034 e1					pop hl  
c035 e5					push hl 
c036 3e 00				ld a, 0 
c038 cd 10 8f				call strlent 
c03b					;inc hl    ; zer0 
c03b 06 00				ld b, 0 
c03d 4d					ld c, l 
c03e e1					pop hl		 
c03f 11 e6 e4				ld de, scratch	 
c042					if DEBUG_FORTH_WORDS 
c042						DMARK "CO1" 
c042 f5				push af  
c043 3a 57 c0			ld a, (.dmark)  
c046 32 c0 ee			ld (debug_mark),a  
c049 3a 58 c0			ld a, (.dmark+1)  
c04c 32 c1 ee			ld (debug_mark+1),a  
c04f 3a 59 c0			ld a, (.dmark+2)  
c052 32 c2 ee			ld (debug_mark+2),a  
c055 18 03			jr .pastdmark  
c057 ..			.dmark: db "CO1"  
c05a f1			.pastdmark: pop af  
c05b			endm  
# End of macro DMARK
c05b						CALLMONITOR 
c05b cd f4 92			call break_point_state  
c05e				endm  
# End of macro CALLMONITOR
c05e					endif 
c05e ed b0				ldir 
c060			 
c060 e1					pop hl 
c061 e5					push hl 
c062 d5					push de 
c063			 
c063			 
c063 3e 00				ld a, 0 
c065 cd 10 8f				call strlent 
c068 23					inc hl    ; zer0 
c069 23					inc hl 
c06a 06 00				ld b, 0 
c06c 4d					ld c, l 
c06d d1					pop de 
c06e e1					pop hl		 
c06f					if DEBUG_FORTH_WORDS 
c06f						DMARK "CO2" 
c06f f5				push af  
c070 3a 84 c0			ld a, (.dmark)  
c073 32 c0 ee			ld (debug_mark),a  
c076 3a 85 c0			ld a, (.dmark+1)  
c079 32 c1 ee			ld (debug_mark+1),a  
c07c 3a 86 c0			ld a, (.dmark+2)  
c07f 32 c2 ee			ld (debug_mark+2),a  
c082 18 03			jr .pastdmark  
c084 ..			.dmark: db "CO2"  
c087 f1			.pastdmark: pop af  
c088			endm  
# End of macro DMARK
c088						CALLMONITOR 
c088 cd f4 92			call break_point_state  
c08b				endm  
# End of macro CALLMONITOR
c08b					endif 
c08b ed b0				ldir 
c08d			 
c08d			 
c08d			 
c08d 21 e6 e4				ld hl, scratch 
c090					if DEBUG_FORTH_WORDS 
c090						DMARK "CO5" 
c090 f5				push af  
c091 3a a5 c0			ld a, (.dmark)  
c094 32 c0 ee			ld (debug_mark),a  
c097 3a a6 c0			ld a, (.dmark+1)  
c09a 32 c1 ee			ld (debug_mark+1),a  
c09d 3a a7 c0			ld a, (.dmark+2)  
c0a0 32 c2 ee			ld (debug_mark+2),a  
c0a3 18 03			jr .pastdmark  
c0a5 ..			.dmark: db "CO5"  
c0a8 f1			.pastdmark: pop af  
c0a9			endm  
# End of macro DMARK
c0a9						CALLMONITOR 
c0a9 cd f4 92			call break_point_state  
c0ac				endm  
# End of macro CALLMONITOR
c0ac					endif 
c0ac			 
c0ac cd ef 98				call forth_push_str 
c0af			 
c0af			 
c0af			 
c0af			 
c0af				       NEXTW 
c0af c3 ea 9b			jp macro_next 
c0b2				endm 
# End of macro NEXTW
c0b2			 
c0b2			 
c0b2			.FIND: 
c0b2				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c0b2 4b				db WORD_SYS_CORE+55             
c0b3 70 c1			dw .LEN            
c0b5 05				db 4 + 1 
c0b6 .. 00			db "FIND",0              
c0bb				endm 
# End of macro CWHEAD
c0bb			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c0bb			 
c0bb					if DEBUG_FORTH_WORDS_KEY 
c0bb						DMARK "FND" 
c0bb f5				push af  
c0bc 3a d0 c0			ld a, (.dmark)  
c0bf 32 c0 ee			ld (debug_mark),a  
c0c2 3a d1 c0			ld a, (.dmark+1)  
c0c5 32 c1 ee			ld (debug_mark+1),a  
c0c8 3a d2 c0			ld a, (.dmark+2)  
c0cb 32 c2 ee			ld (debug_mark+2),a  
c0ce 18 03			jr .pastdmark  
c0d0 ..			.dmark: db "FND"  
c0d3 f1			.pastdmark: pop af  
c0d4			endm  
# End of macro DMARK
c0d4						CALLMONITOR 
c0d4 cd f4 92			call break_point_state  
c0d7				endm  
# End of macro CALLMONITOR
c0d7					endif 
c0d7			 
c0d7			; TODO check string type 
c0d7					FORTH_DSP_VALUE 
c0d7 cd 61 9a			call macro_forth_dsp_value 
c0da				endm 
# End of macro FORTH_DSP_VALUE
c0da			 
c0da e5					push hl    
c0db 7e					ld a,(hl)    ; char to find   
c0dc			; TODO change char to substr 
c0dc			 
c0dc f5					push af 
c0dd					 
c0dd			 
c0dd			 
c0dd					if DEBUG_FORTH_WORDS 
c0dd						DMARK "FN1" 
c0dd f5				push af  
c0de 3a f2 c0			ld a, (.dmark)  
c0e1 32 c0 ee			ld (debug_mark),a  
c0e4 3a f3 c0			ld a, (.dmark+1)  
c0e7 32 c1 ee			ld (debug_mark+1),a  
c0ea 3a f4 c0			ld a, (.dmark+2)  
c0ed 32 c2 ee			ld (debug_mark+2),a  
c0f0 18 03			jr .pastdmark  
c0f2 ..			.dmark: db "FN1"  
c0f5 f1			.pastdmark: pop af  
c0f6			endm  
# End of macro DMARK
c0f6						CALLMONITOR 
c0f6 cd f4 92			call break_point_state  
c0f9				endm  
# End of macro CALLMONITOR
c0f9					endif 
c0f9			 
c0f9					FORTH_DSP_POP 
c0f9 cd 30 9b			call macro_forth_dsp_pop 
c0fc				endm 
# End of macro FORTH_DSP_POP
c0fc			 
c0fc					; string to search 
c0fc			 
c0fc					FORTH_DSP_VALUE 
c0fc cd 61 9a			call macro_forth_dsp_value 
c0ff				endm 
# End of macro FORTH_DSP_VALUE
c0ff			 
c0ff d1					pop de  ; d is char to find  
c100			 
c100					if DEBUG_FORTH_WORDS 
c100						DMARK "FN2" 
c100 f5				push af  
c101 3a 15 c1			ld a, (.dmark)  
c104 32 c0 ee			ld (debug_mark),a  
c107 3a 16 c1			ld a, (.dmark+1)  
c10a 32 c1 ee			ld (debug_mark+1),a  
c10d 3a 17 c1			ld a, (.dmark+2)  
c110 32 c2 ee			ld (debug_mark+2),a  
c113 18 03			jr .pastdmark  
c115 ..			.dmark: db "FN2"  
c118 f1			.pastdmark: pop af  
c119			endm  
# End of macro DMARK
c119						CALLMONITOR 
c119 cd f4 92			call break_point_state  
c11c				endm  
# End of macro CALLMONITOR
c11c					endif 
c11c					 
c11c 01 00 00				ld bc, 0 
c11f 7e			.findchar:      ld a,(hl) 
c120 fe 00				cp 0   		 
c122 28 27				jr z, .finddone     
c124 ba					cp d 
c125 28 20				jr z, .foundchar 
c127 03					inc bc 
c128 23					inc hl 
c129					if DEBUG_FORTH_WORDS 
c129						DMARK "FN3" 
c129 f5				push af  
c12a 3a 3e c1			ld a, (.dmark)  
c12d 32 c0 ee			ld (debug_mark),a  
c130 3a 3f c1			ld a, (.dmark+1)  
c133 32 c1 ee			ld (debug_mark+1),a  
c136 3a 40 c1			ld a, (.dmark+2)  
c139 32 c2 ee			ld (debug_mark+2),a  
c13c 18 03			jr .pastdmark  
c13e ..			.dmark: db "FN3"  
c141 f1			.pastdmark: pop af  
c142			endm  
# End of macro DMARK
c142						CALLMONITOR 
c142 cd f4 92			call break_point_state  
c145				endm  
# End of macro CALLMONITOR
c145					endif 
c145 18 d8				jr .findchar 
c147			 
c147			 
c147 c5			.foundchar:	push bc 
c148 e1					pop hl 
c149 18 03				jr .findexit 
c14b			 
c14b			 
c14b							 
c14b			 
c14b			.finddone:     ; got to end of string with no find 
c14b 21 00 00				ld hl, 0 
c14e			.findexit: 
c14e			 
c14e					if DEBUG_FORTH_WORDS 
c14e						DMARK "FNd" 
c14e f5				push af  
c14f 3a 63 c1			ld a, (.dmark)  
c152 32 c0 ee			ld (debug_mark),a  
c155 3a 64 c1			ld a, (.dmark+1)  
c158 32 c1 ee			ld (debug_mark+1),a  
c15b 3a 65 c1			ld a, (.dmark+2)  
c15e 32 c2 ee			ld (debug_mark+2),a  
c161 18 03			jr .pastdmark  
c163 ..			.dmark: db "FNd"  
c166 f1			.pastdmark: pop af  
c167			endm  
# End of macro DMARK
c167						CALLMONITOR 
c167 cd f4 92			call break_point_state  
c16a				endm  
# End of macro CALLMONITOR
c16a					endif 
c16a cd 81 98			call forth_push_numhl 
c16d			 
c16d				       NEXTW 
c16d c3 ea 9b			jp macro_next 
c170				endm 
# End of macro NEXTW
c170			 
c170			.LEN: 
c170				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c170 4c				db WORD_SYS_CORE+56             
c171 a5 c1			dw .CHAR            
c173 06				db 5 + 1 
c174 .. 00			db "COUNT",0              
c17a				endm 
# End of macro CWHEAD
c17a			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c17a			 
c17a					if DEBUG_FORTH_WORDS_KEY 
c17a						DMARK "CNT" 
c17a f5				push af  
c17b 3a 8f c1			ld a, (.dmark)  
c17e 32 c0 ee			ld (debug_mark),a  
c181 3a 90 c1			ld a, (.dmark+1)  
c184 32 c1 ee			ld (debug_mark+1),a  
c187 3a 91 c1			ld a, (.dmark+2)  
c18a 32 c2 ee			ld (debug_mark+2),a  
c18d 18 03			jr .pastdmark  
c18f ..			.dmark: db "CNT"  
c192 f1			.pastdmark: pop af  
c193			endm  
# End of macro DMARK
c193						CALLMONITOR 
c193 cd f4 92			call break_point_state  
c196				endm  
# End of macro CALLMONITOR
c196					endif 
c196			; TODO check string type 
c196					FORTH_DSP 
c196 cd 3e 9a			call macro_forth_dsp 
c199				endm 
# End of macro FORTH_DSP
c199					;v5FORTH_DSP_VALUE 
c199			 
c199 23					inc hl 
c19a			 
c19a 3e 00				ld a, 0 
c19c cd 10 8f				call strlent 
c19f			 
c19f cd 81 98				call forth_push_numhl 
c1a2			 
c1a2			 
c1a2			 
c1a2				       NEXTW 
c1a2 c3 ea 9b			jp macro_next 
c1a5				endm 
# End of macro NEXTW
c1a5			.CHAR: 
c1a5				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c1a5 4d				db WORD_SYS_CORE+57             
c1a6 db c1			dw .ENDSTR            
c1a8 05				db 4 + 1 
c1a9 .. 00			db "CHAR",0              
c1ae				endm 
# End of macro CWHEAD
c1ae			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c1ae					if DEBUG_FORTH_WORDS_KEY 
c1ae						DMARK "CHR" 
c1ae f5				push af  
c1af 3a c3 c1			ld a, (.dmark)  
c1b2 32 c0 ee			ld (debug_mark),a  
c1b5 3a c4 c1			ld a, (.dmark+1)  
c1b8 32 c1 ee			ld (debug_mark+1),a  
c1bb 3a c5 c1			ld a, (.dmark+2)  
c1be 32 c2 ee			ld (debug_mark+2),a  
c1c1 18 03			jr .pastdmark  
c1c3 ..			.dmark: db "CHR"  
c1c6 f1			.pastdmark: pop af  
c1c7			endm  
# End of macro DMARK
c1c7						CALLMONITOR 
c1c7 cd f4 92			call break_point_state  
c1ca				endm  
# End of macro CALLMONITOR
c1ca					endif 
c1ca					FORTH_DSP 
c1ca cd 3e 9a			call macro_forth_dsp 
c1cd				endm 
# End of macro FORTH_DSP
c1cd					;v5 FORTH_DSP_VALUE 
c1cd 23					inc hl      ; now at start of numeric as string 
c1ce			 
c1ce			;		push hl 
c1ce			 
c1ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1ce cd 30 9b			call macro_forth_dsp_pop 
c1d1				endm 
# End of macro FORTH_DSP_POP
c1d1			 
c1d1			;		pop hl 
c1d1			 
c1d1					; push the content of a onto the stack as a value 
c1d1			 
c1d1 7e					ld a,(hl)   ; get char 
c1d2 26 00				ld h,0 
c1d4 6f					ld l,a 
c1d5 cd 81 98				call forth_push_numhl 
c1d8			 
c1d8				       NEXTW 
c1d8 c3 ea 9b			jp macro_next 
c1db				endm 
# End of macro NEXTW
c1db			 
c1db			 
c1db			 
c1db			 
c1db			.ENDSTR: 
c1db			; eof 
c1db			 
# End of file forth_words_str.asm
c1db			include "forth_words_key.asm" 
c1db			 
c1db			; | ## Keyboard Words 
c1db			 
c1db			.KEY: 
c1db				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c1db 3e				db WORD_SYS_CORE+42             
c1dc 0b c2			dw .WAITK            
c1de 04				db 3 + 1 
c1df .. 00			db "KEY",0              
c1e3				endm 
# End of macro CWHEAD
c1e3			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c1e3			 
c1e3					if DEBUG_FORTH_WORDS_KEY 
c1e3						DMARK "KEY" 
c1e3 f5				push af  
c1e4 3a f8 c1			ld a, (.dmark)  
c1e7 32 c0 ee			ld (debug_mark),a  
c1ea 3a f9 c1			ld a, (.dmark+1)  
c1ed 32 c1 ee			ld (debug_mark+1),a  
c1f0 3a fa c1			ld a, (.dmark+2)  
c1f3 32 c2 ee			ld (debug_mark+2),a  
c1f6 18 03			jr .pastdmark  
c1f8 ..			.dmark: db "KEY"  
c1fb f1			.pastdmark: pop af  
c1fc			endm  
# End of macro DMARK
c1fc						CALLMONITOR 
c1fc cd f4 92			call break_point_state  
c1ff				endm  
# End of macro CALLMONITOR
c1ff					endif 
c1ff			; TODO currently waits 
c1ff cd 65 d8				call cin 
c202					;call cin_wait 
c202 6f					ld l, a 
c203 26 00				ld h, 0 
c205 cd 81 98				call forth_push_numhl 
c208					NEXTW 
c208 c3 ea 9b			jp macro_next 
c20b				endm 
# End of macro NEXTW
c20b			.WAITK: 
c20b				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c20b 3f				db WORD_SYS_CORE+43             
c20c 3d c2			dw .ACCEPT            
c20e 06				db 5 + 1 
c20f .. 00			db "WAITK",0              
c215				endm 
# End of macro CWHEAD
c215			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c215					if DEBUG_FORTH_WORDS_KEY 
c215						DMARK "WAI" 
c215 f5				push af  
c216 3a 2a c2			ld a, (.dmark)  
c219 32 c0 ee			ld (debug_mark),a  
c21c 3a 2b c2			ld a, (.dmark+1)  
c21f 32 c1 ee			ld (debug_mark+1),a  
c222 3a 2c c2			ld a, (.dmark+2)  
c225 32 c2 ee			ld (debug_mark+2),a  
c228 18 03			jr .pastdmark  
c22a ..			.dmark: db "WAI"  
c22d f1			.pastdmark: pop af  
c22e			endm  
# End of macro DMARK
c22e						CALLMONITOR 
c22e cd f4 92			call break_point_state  
c231				endm  
# End of macro CALLMONITOR
c231					endif 
c231 cd 5f d8				call cin_wait 
c234 6f					ld l, a 
c235 26 00				ld h, 0 
c237 cd 81 98				call forth_push_numhl 
c23a					NEXTW 
c23a c3 ea 9b			jp macro_next 
c23d				endm 
# End of macro NEXTW
c23d			.ACCEPT: 
c23d				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c23d 40				db WORD_SYS_CORE+44             
c23e 9b c2			dw .EDIT            
c240 07				db 6 + 1 
c241 .. 00			db "ACCEPT",0              
c248				endm 
# End of macro CWHEAD
c248			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c248					; TODO crashes on push 
c248					if DEBUG_FORTH_WORDS_KEY 
c248						DMARK "ACC" 
c248 f5				push af  
c249 3a 5d c2			ld a, (.dmark)  
c24c 32 c0 ee			ld (debug_mark),a  
c24f 3a 5e c2			ld a, (.dmark+1)  
c252 32 c1 ee			ld (debug_mark+1),a  
c255 3a 5f c2			ld a, (.dmark+2)  
c258 32 c2 ee			ld (debug_mark+2),a  
c25b 18 03			jr .pastdmark  
c25d ..			.dmark: db "ACC"  
c260 f1			.pastdmark: pop af  
c261			endm  
# End of macro DMARK
c261						CALLMONITOR 
c261 cd f4 92			call break_point_state  
c264				endm  
# End of macro CALLMONITOR
c264					endif 
c264 21 e4 e6				ld hl, os_input 
c267 3e 00				ld a, 0 
c269 77					ld (hl),a 
c26a 3a cf ec				ld a,(f_cursor_ptr) 
c26d 16 64				ld d, 100 
c26f 0e 00				ld c, 0 
c271 1e 28				ld e, 40 
c273 cd d4 8a				call input_str 
c276					; TODO perhaps do a type check and wrap in quotes if not a number 
c276 21 e4 e6				ld hl, os_input 
c279					if DEBUG_FORTH_WORDS 
c279						DMARK "AC1" 
c279 f5				push af  
c27a 3a 8e c2			ld a, (.dmark)  
c27d 32 c0 ee			ld (debug_mark),a  
c280 3a 8f c2			ld a, (.dmark+1)  
c283 32 c1 ee			ld (debug_mark+1),a  
c286 3a 90 c2			ld a, (.dmark+2)  
c289 32 c2 ee			ld (debug_mark+2),a  
c28c 18 03			jr .pastdmark  
c28e ..			.dmark: db "AC1"  
c291 f1			.pastdmark: pop af  
c292			endm  
# End of macro DMARK
c292						CALLMONITOR 
c292 cd f4 92			call break_point_state  
c295				endm  
# End of macro CALLMONITOR
c295					endif 
c295 cd ef 98				call forth_push_str 
c298					NEXTW 
c298 c3 ea 9b			jp macro_next 
c29b				endm 
# End of macro NEXTW
c29b			 
c29b			.EDIT: 
c29b				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c29b 40				db WORD_SYS_CORE+44             
c29c 24 c3			dw .ENDKEY            
c29e 05				db 4 + 1 
c29f .. 00			db "EDIT",0              
c2a4				endm 
# End of macro CWHEAD
c2a4			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c2a4			 
c2a4					; TODO does not copy from stack 
c2a4					if DEBUG_FORTH_WORDS_KEY 
c2a4						DMARK "EDT" 
c2a4 f5				push af  
c2a5 3a b9 c2			ld a, (.dmark)  
c2a8 32 c0 ee			ld (debug_mark),a  
c2ab 3a ba c2			ld a, (.dmark+1)  
c2ae 32 c1 ee			ld (debug_mark+1),a  
c2b1 3a bb c2			ld a, (.dmark+2)  
c2b4 32 c2 ee			ld (debug_mark+2),a  
c2b7 18 03			jr .pastdmark  
c2b9 ..			.dmark: db "EDT"  
c2bc f1			.pastdmark: pop af  
c2bd			endm  
# End of macro DMARK
c2bd						CALLMONITOR 
c2bd cd f4 92			call break_point_state  
c2c0				endm  
# End of macro CALLMONITOR
c2c0					endif 
c2c0			 
c2c0					FORTH_DSP 
c2c0 cd 3e 9a			call macro_forth_dsp 
c2c3				endm 
# End of macro FORTH_DSP
c2c3					;v5 FORTH_DSP_VALUE 
c2c3 23					inc hl    ; TODO do type check 
c2c4			 
c2c4 e5					push hl 
c2c5 3e 00				ld a, 0 
c2c7 cd 10 8f				call strlent 
c2ca 23					inc hl 
c2cb			 
c2cb 06 00				ld b, 0 
c2cd 4d					ld c, l 
c2ce			 
c2ce e1					pop hl 
c2cf 11 e4 e6				ld de, os_input 
c2d2					if DEBUG_FORTH_WORDS_KEY 
c2d2						DMARK "EDc" 
c2d2 f5				push af  
c2d3 3a e7 c2			ld a, (.dmark)  
c2d6 32 c0 ee			ld (debug_mark),a  
c2d9 3a e8 c2			ld a, (.dmark+1)  
c2dc 32 c1 ee			ld (debug_mark+1),a  
c2df 3a e9 c2			ld a, (.dmark+2)  
c2e2 32 c2 ee			ld (debug_mark+2),a  
c2e5 18 03			jr .pastdmark  
c2e7 ..			.dmark: db "EDc"  
c2ea f1			.pastdmark: pop af  
c2eb			endm  
# End of macro DMARK
c2eb						CALLMONITOR 
c2eb cd f4 92			call break_point_state  
c2ee				endm  
# End of macro CALLMONITOR
c2ee					endif 
c2ee ed b0				ldir 
c2f0			 
c2f0			 
c2f0 21 e4 e6				ld hl, os_input 
c2f3					;ld a, 0 
c2f3					;ld (hl),a 
c2f3 3a cf ec				ld a,(f_cursor_ptr) 
c2f6 16 64				ld d, 100 
c2f8 0e 00				ld c, 0 
c2fa 1e 28				ld e, 40 
c2fc cd d4 8a				call input_str 
c2ff					; TODO perhaps do a type check and wrap in quotes if not a number 
c2ff 21 e4 e6				ld hl, os_input 
c302					if DEBUG_FORTH_WORDS 
c302						DMARK "ED1" 
c302 f5				push af  
c303 3a 17 c3			ld a, (.dmark)  
c306 32 c0 ee			ld (debug_mark),a  
c309 3a 18 c3			ld a, (.dmark+1)  
c30c 32 c1 ee			ld (debug_mark+1),a  
c30f 3a 19 c3			ld a, (.dmark+2)  
c312 32 c2 ee			ld (debug_mark+2),a  
c315 18 03			jr .pastdmark  
c317 ..			.dmark: db "ED1"  
c31a f1			.pastdmark: pop af  
c31b			endm  
# End of macro DMARK
c31b						CALLMONITOR 
c31b cd f4 92			call break_point_state  
c31e				endm  
# End of macro CALLMONITOR
c31e					endif 
c31e cd ef 98				call forth_push_str 
c321					NEXTW 
c321 c3 ea 9b			jp macro_next 
c324				endm 
# End of macro NEXTW
c324			 
c324			 
c324			 
c324			.ENDKEY: 
c324			; eof 
c324			 
# End of file forth_words_key.asm
c324			 
c324			if STORAGE_SE 
c324			   	include "forth_words_storage.asm" 
c324			endif 
c324				include "forth_words_device.asm" 
c324			; Device related words 
c324			 
c324			; | ## Device Words 
c324			 
c324			if SOUND_ENABLE 
c324			.NOTE: 
c324				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c324			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c324					if DEBUG_FORTH_WORDS_KEY 
c324						DMARK "NTE" 
c324						CALLMONITOR 
c324					endif 
c324			 
c324				 
c324			 
c324					NEXTW 
c324			.AFTERSOUND: 
c324			endif 
c324			 
c324			 
c324			USE_GPIO: equ 0 
c324			 
c324			if USE_GPIO 
c324			.GP1: 
c324				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c324			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c324					NEXTW 
c324			.GP2: 
c324				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c324			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c324			 
c324					NEXTW 
c324			 
c324			.GP3: 
c324				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c324			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c324			 
c324					NEXTW 
c324			 
c324			.GP4: 
c324				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c324			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c324			 
c324					NEXTW 
c324			.SIN: 
c324			 
c324			 
c324			endif 
c324			 
c324			 
c324				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c324 33				db WORD_SYS_CORE+31             
c325 59 c3			dw .SOUT            
c327 03				db 2 + 1 
c328 .. 00			db "IN",0              
c32b				endm 
# End of macro CWHEAD
c32b			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c32b					if DEBUG_FORTH_WORDS_KEY 
c32b						DMARK "IN." 
c32b f5				push af  
c32c 3a 40 c3			ld a, (.dmark)  
c32f 32 c0 ee			ld (debug_mark),a  
c332 3a 41 c3			ld a, (.dmark+1)  
c335 32 c1 ee			ld (debug_mark+1),a  
c338 3a 42 c3			ld a, (.dmark+2)  
c33b 32 c2 ee			ld (debug_mark+2),a  
c33e 18 03			jr .pastdmark  
c340 ..			.dmark: db "IN."  
c343 f1			.pastdmark: pop af  
c344			endm  
# End of macro DMARK
c344						CALLMONITOR 
c344 cd f4 92			call break_point_state  
c347				endm  
# End of macro CALLMONITOR
c347					endif 
c347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c347 cd 78 9a			call macro_dsp_valuehl 
c34a				endm 
# End of macro FORTH_DSP_VALUEHL
c34a			 
c34a e5					push hl 
c34b			 
c34b					; destroy value TOS 
c34b			 
c34b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c34b cd 30 9b			call macro_forth_dsp_pop 
c34e				endm 
# End of macro FORTH_DSP_POP
c34e			 
c34e					; one value on hl get other one back 
c34e			 
c34e c1					pop bc 
c34f			 
c34f					; do the sub 
c34f			;		ex de, hl 
c34f			 
c34f ed 68				in l,(c) 
c351			 
c351					; save it 
c351			 
c351 26 00				ld h,0 
c353			 
c353					; TODO push value back onto stack for another op etc 
c353			 
c353 cd 81 98				call forth_push_numhl 
c356					NEXTW 
c356 c3 ea 9b			jp macro_next 
c359				endm 
# End of macro NEXTW
c359			.SOUT: 
c359				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c359 34				db WORD_SYS_CORE+32             
c35a ac c3			dw .SPIO            
c35c 04				db 3 + 1 
c35d .. 00			db "OUT",0              
c361				endm 
# End of macro CWHEAD
c361			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c361					if DEBUG_FORTH_WORDS_KEY 
c361						DMARK "OUT" 
c361 f5				push af  
c362 3a 76 c3			ld a, (.dmark)  
c365 32 c0 ee			ld (debug_mark),a  
c368 3a 77 c3			ld a, (.dmark+1)  
c36b 32 c1 ee			ld (debug_mark+1),a  
c36e 3a 78 c3			ld a, (.dmark+2)  
c371 32 c2 ee			ld (debug_mark+2),a  
c374 18 03			jr .pastdmark  
c376 ..			.dmark: db "OUT"  
c379 f1			.pastdmark: pop af  
c37a			endm  
# End of macro DMARK
c37a						CALLMONITOR 
c37a cd f4 92			call break_point_state  
c37d				endm  
# End of macro CALLMONITOR
c37d					endif 
c37d			 
c37d					; get port 
c37d			 
c37d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c37d cd 78 9a			call macro_dsp_valuehl 
c380				endm 
# End of macro FORTH_DSP_VALUEHL
c380			 
c380 e5					push hl 
c381			 
c381					; destroy value TOS 
c381			 
c381					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c381 cd 30 9b			call macro_forth_dsp_pop 
c384				endm 
# End of macro FORTH_DSP_POP
c384			 
c384					; get byte to send 
c384			 
c384					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c384 cd 78 9a			call macro_dsp_valuehl 
c387				endm 
# End of macro FORTH_DSP_VALUEHL
c387			 
c387			;		push hl 
c387			 
c387					; destroy value TOS 
c387			 
c387					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c387 cd 30 9b			call macro_forth_dsp_pop 
c38a				endm 
# End of macro FORTH_DSP_POP
c38a			 
c38a					; one value on hl get other one back 
c38a			 
c38a			;		pop hl 
c38a			 
c38a c1					pop bc 
c38b			 
c38b					if DEBUG_FORTH_WORDS 
c38b						DMARK "OUT" 
c38b f5				push af  
c38c 3a a0 c3			ld a, (.dmark)  
c38f 32 c0 ee			ld (debug_mark),a  
c392 3a a1 c3			ld a, (.dmark+1)  
c395 32 c1 ee			ld (debug_mark+1),a  
c398 3a a2 c3			ld a, (.dmark+2)  
c39b 32 c2 ee			ld (debug_mark+2),a  
c39e 18 03			jr .pastdmark  
c3a0 ..			.dmark: db "OUT"  
c3a3 f1			.pastdmark: pop af  
c3a4			endm  
# End of macro DMARK
c3a4						CALLMONITOR 
c3a4 cd f4 92			call break_point_state  
c3a7				endm  
# End of macro CALLMONITOR
c3a7					endif 
c3a7			 
c3a7 ed 69				out (c), l 
c3a9			 
c3a9					NEXTW 
c3a9 c3 ea 9b			jp macro_next 
c3ac				endm 
# End of macro NEXTW
c3ac			 
c3ac			 
c3ac			.SPIO: 
c3ac			 
c3ac			if STORAGE_SE 
c3ac				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c3ac			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c3ac			 
c3ac					call spi_ce_low 
c3ac			    NEXTW 
c3ac			 
c3ac			.SPICEH: 
c3ac				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c3ac			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c3ac			 
c3ac					call spi_ce_high 
c3ac			    NEXTW 
c3ac			 
c3ac			 
c3ac			.SPIOb: 
c3ac			 
c3ac				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c3ac			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c3ac			 
c3ac					; get port 
c3ac			 
c3ac			 
c3ac					; get byte to send 
c3ac			 
c3ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3ac			 
c3ac			;		push hl    ; u1  
c3ac			 
c3ac					; destroy value TOS 
c3ac			 
c3ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3ac			 
c3ac					; one value on hl get other one back 
c3ac			 
c3ac			;		pop hl   ; u2 - addr 
c3ac			 
c3ac					; TODO Send SPI byte 
c3ac			 
c3ac					ld a, l 
c3ac					call spi_send_byte 
c3ac			 
c3ac					NEXTW 
c3ac			 
c3ac			.SPII: 
c3ac				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c3ac			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c3ac			 
c3ac					; TODO Get SPI byte 
c3ac			 
c3ac					call spi_read_byte 
c3ac			 
c3ac					ld h, 0 
c3ac					ld l, a 
c3ac					call forth_push_numhl 
c3ac			 
c3ac					NEXTW 
c3ac			 
c3ac			 
c3ac			 
c3ac			.SESEL: 
c3ac				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c3ac			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c3ac					if DEBUG_FORTH_WORDS_KEY 
c3ac						DMARK "BNK" 
c3ac						CALLMONITOR 
c3ac					endif 
c3ac			 
c3ac					ld a, 255 
c3ac					ld (spi_cartdev), a 
c3ac			 
c3ac					; get bank 
c3ac			 
c3ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3ac			 
c3ac			;		push hl 
c3ac			 
c3ac					; destroy value TOS 
c3ac			 
c3ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3ac			 
c3ac					; one value on hl get other one back 
c3ac			 
c3ac			;		pop hl 
c3ac			 
c3ac			 
c3ac					ld c, SPI_CE_HIGH 
c3ac					ld b, '0'    ; human readable bank number 
c3ac			 
c3ac					ld a, l 
c3ac			 
c3ac					if DEBUG_FORTH_WORDS 
c3ac						DMARK "BNK" 
c3ac						CALLMONITOR 
c3ac					endif 
c3ac			 
c3ac					; active low 
c3ac			 
c3ac					cp 0 
c3ac					jr z, .bset 
c3ac					cp 1 
c3ac					jr nz, .b2 
c3ac					res 0, c 
c3ac					ld b, '1'    ; human readable bank number 
c3ac			.b2:		cp 2 
c3ac					jr nz, .b3 
c3ac					res 1, c 
c3ac					ld b, '2'    ; human readable bank number 
c3ac			.b3:		cp 3 
c3ac					jr nz, .b4 
c3ac					res 2, c 
c3ac					ld b, '3'    ; human readable bank number 
c3ac			.b4:		cp 4 
c3ac					jr nz, .b5 
c3ac					res 3, c 
c3ac					ld b, '4'    ; human readable bank number 
c3ac			.b5:		cp 5 
c3ac					jr nz, .bset 
c3ac					res 4, c 
c3ac					ld b, '5'    ; human readable bank number 
c3ac			 
c3ac			.bset: 
c3ac					ld a, c 
c3ac					ld (spi_device),a 
c3ac					ld a, b 
c3ac					ld (spi_device_id),a 
c3ac					if DEBUG_FORTH_WORDS 
c3ac						DMARK "BN2" 
c3ac						CALLMONITOR 
c3ac					endif 
c3ac			 
c3ac					NEXTW 
c3ac			 
c3ac			.CARTDEV: 
c3ac				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c3ac			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c3ac					if DEBUG_FORTH_WORDS_KEY 
c3ac						DMARK "CDV" 
c3ac						CALLMONITOR 
c3ac					endif 
c3ac			 
c3ac					; disable se storage bank selection 
c3ac			 
c3ac					ld a, SPI_CE_HIGH		; ce high 
c3ac					ld (spi_device), a 
c3ac			 
c3ac					; get bank 
c3ac			 
c3ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3ac			 
c3ac			;		push hl 
c3ac			 
c3ac					; destroy value TOS 
c3ac			 
c3ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3ac			 
c3ac					; one value on hl get other one back 
c3ac			 
c3ac			;		pop hl 
c3ac			 
c3ac					; active low 
c3ac			 
c3ac					ld c, 255 
c3ac			 
c3ac					ld a, l 
c3ac					if DEBUG_FORTH_WORDS 
c3ac						DMARK "CDV" 
c3ac						CALLMONITOR 
c3ac					endif 
c3ac					cp 0 
c3ac					jr z, .cset 
c3ac					cp 1 
c3ac					jr nz, .c2 
c3ac					res 0, c 
c3ac			.c2:		cp 2 
c3ac					jr nz, .c3 
c3ac					res 1, c 
c3ac			.c3:		cp 3 
c3ac					jr nz, .c4 
c3ac					res 2, c 
c3ac			.c4:		cp 4 
c3ac					jr nz, .c5 
c3ac					res 3, c 
c3ac			.c5:		cp 5 
c3ac					jr nz, .c6 
c3ac					res 4, c 
c3ac			.c6:		cp 6 
c3ac					jr nz, .c7 
c3ac					res 5, c 
c3ac			.c7:		cp 7 
c3ac					jr nz, .c8 
c3ac					res 6, c 
c3ac			.c8:		cp 8 
c3ac					jr nz, .cset 
c3ac					res 7, c 
c3ac			.cset:		ld a, c 
c3ac					ld (spi_cartdev),a 
c3ac			 
c3ac					if DEBUG_FORTH_WORDS 
c3ac						DMARK "CD2" 
c3ac						CALLMONITOR 
c3ac					endif 
c3ac					NEXTW 
c3ac			endif 
c3ac			 
c3ac			.ENDDEVICE: 
c3ac			; eof 
c3ac			 
# End of file forth_words_device.asm
c3ac			 
c3ac			; var handler 
c3ac			 
c3ac			 
c3ac			.VARS: 
c3ac				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c3ac 78				db WORD_SYS_CORE+100             
c3ad c4 c3			dw .V0Q            
c3af 04				db 3 + 1 
c3b0 .. 00			db "V0!",0              
c3b4				endm 
# End of macro CWHEAD
c3b4			;| V0! ( u1 -- )  Store value to v0  | DONE 
c3b4			 
c3b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3b4 cd 78 9a			call macro_dsp_valuehl 
c3b7				endm 
# End of macro FORTH_DSP_VALUEHL
c3b7			 
c3b7 11 99 ec				ld de, cli_var_array 
c3ba			 
c3ba eb					ex de, hl 
c3bb 73					ld (hl), e 
c3bc 23					inc hl 
c3bd 72					ld (hl), d 
c3be			 
c3be					; destroy value TOS 
c3be			 
c3be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3be cd 30 9b			call macro_forth_dsp_pop 
c3c1				endm 
# End of macro FORTH_DSP_POP
c3c1			 
c3c1				       NEXTW 
c3c1 c3 ea 9b			jp macro_next 
c3c4				endm 
# End of macro NEXTW
c3c4			.V0Q: 
c3c4				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c3c4 79				db WORD_SYS_CORE+101             
c3c5 d5 c3			dw .V1S            
c3c7 04				db 3 + 1 
c3c8 .. 00			db "V0@",0              
c3cc				endm 
# End of macro CWHEAD
c3cc			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c3cc 2a 99 ec				ld hl, (cli_var_array) 
c3cf cd 81 98				call forth_push_numhl 
c3d2			 
c3d2				       NEXTW 
c3d2 c3 ea 9b			jp macro_next 
c3d5				endm 
# End of macro NEXTW
c3d5			.V1S: 
c3d5				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c3d5 7a				db WORD_SYS_CORE+102             
c3d6 ed c3			dw .V1Q            
c3d8 04				db 3 + 1 
c3d9 .. 00			db "V1!",0              
c3dd				endm 
# End of macro CWHEAD
c3dd			;| V1! ( u1 -- )  Store value to v1 | DONE 
c3dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3dd cd 78 9a			call macro_dsp_valuehl 
c3e0				endm 
# End of macro FORTH_DSP_VALUEHL
c3e0			 
c3e0 11 9b ec				ld de, cli_var_array+2 
c3e3				 
c3e3 eb					ex de, hl 
c3e4 73					ld (hl), e 
c3e5 23					inc hl 
c3e6 72					ld (hl), d 
c3e7			 
c3e7					; destroy value TOS 
c3e7			 
c3e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3e7 cd 30 9b			call macro_forth_dsp_pop 
c3ea				endm 
# End of macro FORTH_DSP_POP
c3ea				       NEXTW 
c3ea c3 ea 9b			jp macro_next 
c3ed				endm 
# End of macro NEXTW
c3ed			.V1Q: 
c3ed				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c3ed 7b				db WORD_SYS_CORE+103             
c3ee fe c3			dw .V2S            
c3f0 04				db 3 + 1 
c3f1 .. 00			db "V1@",0              
c3f5				endm 
# End of macro CWHEAD
c3f5			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c3f5 2a 9b ec				ld hl, (cli_var_array+2) 
c3f8 cd 81 98				call forth_push_numhl 
c3fb				       NEXTW 
c3fb c3 ea 9b			jp macro_next 
c3fe				endm 
# End of macro NEXTW
c3fe			.V2S: 
c3fe				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c3fe 7c				db WORD_SYS_CORE+104             
c3ff 16 c4			dw .V2Q            
c401 04				db 3 + 1 
c402 .. 00			db "V2!",0              
c406				endm 
# End of macro CWHEAD
c406			;| V2! ( u1 -- )  Store value to v2 | DONE 
c406					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c406 cd 78 9a			call macro_dsp_valuehl 
c409				endm 
# End of macro FORTH_DSP_VALUEHL
c409			 
c409 11 9d ec				ld de, cli_var_array+4 
c40c				 
c40c eb					ex de, hl 
c40d 73					ld (hl), e 
c40e 23					inc hl 
c40f 72					ld (hl), d 
c410			 
c410					; destroy value TOS 
c410			 
c410					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c410 cd 30 9b			call macro_forth_dsp_pop 
c413				endm 
# End of macro FORTH_DSP_POP
c413				       NEXTW 
c413 c3 ea 9b			jp macro_next 
c416				endm 
# End of macro NEXTW
c416			.V2Q: 
c416				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c416 7d				db WORD_SYS_CORE+105             
c417 27 c4			dw .V3S            
c419 04				db 3 + 1 
c41a .. 00			db "V2@",0              
c41e				endm 
# End of macro CWHEAD
c41e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c41e 2a 9d ec				ld hl, (cli_var_array+4) 
c421 cd 81 98				call forth_push_numhl 
c424				       NEXTW 
c424 c3 ea 9b			jp macro_next 
c427				endm 
# End of macro NEXTW
c427			.V3S: 
c427				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c427 7c				db WORD_SYS_CORE+104             
c428 3f c4			dw .V3Q            
c42a 04				db 3 + 1 
c42b .. 00			db "V3!",0              
c42f				endm 
# End of macro CWHEAD
c42f			;| V3! ( u1 -- )  Store value to v3 | DONE 
c42f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c42f cd 78 9a			call macro_dsp_valuehl 
c432				endm 
# End of macro FORTH_DSP_VALUEHL
c432			 
c432 11 9f ec				ld de, cli_var_array+6 
c435				 
c435 eb					ex de, hl 
c436 73					ld (hl), e 
c437 23					inc hl 
c438 72					ld (hl), d 
c439			 
c439					; destroy value TOS 
c439			 
c439					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c439 cd 30 9b			call macro_forth_dsp_pop 
c43c				endm 
# End of macro FORTH_DSP_POP
c43c				       NEXTW 
c43c c3 ea 9b			jp macro_next 
c43f				endm 
# End of macro NEXTW
c43f			.V3Q: 
c43f				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c43f 7d				db WORD_SYS_CORE+105             
c440 50 c4			dw .END            
c442 04				db 3 + 1 
c443 .. 00			db "V3@",0              
c447				endm 
# End of macro CWHEAD
c447			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c447 2a 9f ec				ld hl, (cli_var_array+6) 
c44a cd 81 98				call forth_push_numhl 
c44d				       NEXTW 
c44d c3 ea 9b			jp macro_next 
c450				endm 
# End of macro NEXTW
c450			 
c450			 
c450			 
c450			 
c450			 
c450			; end of dict marker 
c450			 
c450 00			.END:    db WORD_SYS_END 
c451 00 00			dw 0 
c453 00				db 0 
c454			 
c454			; use to jp here for user dict words to save on macro expansion  
c454			 
c454			user_dict_next: 
c454				NEXTW 
c454 c3 ea 9b			jp macro_next 
c457				endm 
# End of macro NEXTW
c457			 
c457			 
c457			user_exec: 
c457				;    ld hl, <word code> 
c457				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c457				;    call forthexec 
c457				;    jp user_dict_next   (NEXT) 
c457			        ;    <word code bytes> 
c457 eb				ex de, hl 
c458 2a e7 e7			ld hl,(os_tok_ptr) 
c45b				 
c45b				FORTH_RSP_NEXT 
c45b cd 28 98			call macro_forth_rsp_next 
c45e				endm 
# End of macro FORTH_RSP_NEXT
c45e			 
c45e			if DEBUG_FORTH_UWORD 
c45e						DMARK "UEX" 
c45e f5				push af  
c45f 3a 73 c4			ld a, (.dmark)  
c462 32 c0 ee			ld (debug_mark),a  
c465 3a 74 c4			ld a, (.dmark+1)  
c468 32 c1 ee			ld (debug_mark+1),a  
c46b 3a 75 c4			ld a, (.dmark+2)  
c46e 32 c2 ee			ld (debug_mark+2),a  
c471 18 03			jr .pastdmark  
c473 ..			.dmark: db "UEX"  
c476 f1			.pastdmark: pop af  
c477			endm  
# End of macro DMARK
c477				CALLMONITOR 
c477 cd f4 92			call break_point_state  
c47a				endm  
# End of macro CALLMONITOR
c47a			endif 
c47a			 
c47a			 
c47a			 
c47a eb				ex de, hl 
c47b 22 e7 e7			ld (os_tok_ptr), hl 
c47e				 
c47e				; Don't use next - Skips the first word in uword. 
c47e			 
c47e c3 7b 9c			jp exec1 
c481			;	NEXT 
c481			 
c481			 
c481			; eof 
# End of file forth_wordsv4.asm
c481			endif 
c481			;;;;;;;;;;;;;; Debug code 
c481			 
c481			 
c481			;if DEBUG_FORTH_PARSE 
c481 .. 00		.nowordfound: db "No match",0 
c48a .. 00		.compword:	db "Comparing word ",0 
c49a .. 00		.nextwordat:	db "Next word at",0 
c4a7 .. 00		.charmatch:	db "Char match",0 
c4b2			;endif 
c4b2			if DEBUG_FORTH_JP 
c4b2			.foundword:	db "Word match. Exec..",0 
c4b2			endif 
c4b2			;if DEBUG_FORTH_PUSH 
c4b2 .. 00		.enddict:	db "Dict end. Push.",0 
c4c2 .. 00		.push_str:	db "Pushing string",0 
c4d1 .. 00		.push_num:	db "Pushing number",0 
c4e0 .. 00		.data_sp:	db "SP:",0 
c4e4 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c4f6 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c508 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c51a			;endif 
c51a			;if DEBUG_FORTH_MALLOC 
c51a .. 00		.push_malloc:	db "Malloc address",0 
c529			;endif 
c529			 
c529			 
c529			 
c529			; display malloc address and current data stack pointer  
c529			 
c529			malloc_error: 
c529 d5				push de 
c52a f5				push af 
c52b e5				push hl 
c52c cd 7a 88			call clear_display 
c52f 11 51 c5			ld de, .mallocerr 
c532 3e 00			ld a,0 
c534			;	ld de,os_word_scratch 
c534 cd 8d 88			call str_at_display 
c537 3e 11			ld a, display_row_1+17 
c539 11 c0 ee			ld de, debug_mark 
c53c cd 8d 88			call str_at_display 
c53f cd 9d 88			call update_display 
c542				;call break_point_state 
c542 cd 5f d8			call cin_wait 
c545			 
c545 3e 20			ld a, ' ' 
c547 32 d7 e4			ld (os_view_disable), a 
c54a e1				pop hl 
c54b f1				pop af 
c54c d1				pop de	 
c54d				CALLMONITOR 
c54d cd f4 92			call break_point_state  
c550				endm  
# End of macro CALLMONITOR
c550 c9				ret 
c551			 
c551 .. 00		.mallocerr: 	db "Malloc Error",0 
c55e			;if DEBUG_FORTH_PUSH 
c55e			display_data_sp: 
c55e f5				push af 
c55f			 
c55f				; see if disabled 
c55f			 
c55f 3a d7 e4			ld a, (os_view_disable) 
c562 fe 2a			cp '*' 
c564 28 67			jr z, .skipdsp 
c566			 
c566 e5				push hl 
c567 e5				push hl 
c568 e5			push hl 
c569 cd 7a 88			call clear_display 
c56c e1			pop hl 
c56d 7c				ld a,h 
c56e 21 eb e7			ld hl, os_word_scratch 
c571 cd a8 8d			call hexout 
c574 e1				pop hl 
c575 7d				ld a,l 
c576 21 ed e7			ld hl, os_word_scratch+2 
c579 cd a8 8d			call hexout 
c57c 21 ef e7			ld hl, os_word_scratch+4 
c57f 3e 00			ld a,0 
c581 77				ld (hl),a 
c582 11 eb e7			ld de,os_word_scratch 
c585 3e 14				ld a, display_row_2 
c587 cd 8d 88				call str_at_display 
c58a 11 e4 c4			ld de, .wordinhl 
c58d 3e 00			ld a, display_row_1 
c58f			 
c58f cd 8d 88				call str_at_display 
c592 11 c0 ee			ld de, debug_mark 
c595 3e 11			ld a, display_row_1+17 
c597			 
c597 cd 8d 88				call str_at_display 
c59a			 
c59a				; display current data stack pointer 
c59a 11 e0 c4			ld de,.data_sp 
c59d 3e 1c				ld a, display_row_2 + 8 
c59f cd 8d 88				call str_at_display 
c5a2			 
c5a2 2a 93 ec			ld hl,(cli_data_sp) 
c5a5 e5				push hl 
c5a6 7c				ld a,h 
c5a7 21 eb e7			ld hl, os_word_scratch 
c5aa cd a8 8d			call hexout 
c5ad e1				pop hl 
c5ae 7d				ld a,l 
c5af 21 ed e7			ld hl, os_word_scratch+2 
c5b2 cd a8 8d			call hexout 
c5b5 21 ef e7			ld hl, os_word_scratch+4 
c5b8 3e 00			ld a,0 
c5ba 77				ld (hl),a 
c5bb 11 eb e7			ld de,os_word_scratch 
c5be 3e 1f				ld a, display_row_2 + 11 
c5c0 cd 8d 88				call str_at_display 
c5c3			 
c5c3			 
c5c3 cd 9d 88			call update_display 
c5c6 cd fa 87			call delay1s 
c5c9 cd fa 87			call delay1s 
c5cc e1				pop hl 
c5cd			.skipdsp: 
c5cd f1				pop af 
c5ce c9				ret 
c5cf			 
c5cf			display_data_malloc: 
c5cf			 
c5cf f5				push af 
c5d0 e5				push hl 
c5d1 e5				push hl 
c5d2 e5			push hl 
c5d3 cd 7a 88			call clear_display 
c5d6 e1			pop hl 
c5d7 7c				ld a,h 
c5d8 21 eb e7			ld hl, os_word_scratch 
c5db cd a8 8d			call hexout 
c5de e1				pop hl 
c5df 7d				ld a,l 
c5e0 21 ed e7			ld hl, os_word_scratch+2 
c5e3 cd a8 8d			call hexout 
c5e6 21 ef e7			ld hl, os_word_scratch+4 
c5e9 3e 00			ld a,0 
c5eb 77				ld (hl),a 
c5ec 11 eb e7			ld de,os_word_scratch 
c5ef 3e 14				ld a, display_row_2 
c5f1 cd 8d 88				call str_at_display 
c5f4 11 1a c5			ld de, .push_malloc 
c5f7 3e 00			ld a, display_row_1 
c5f9			 
c5f9 cd 8d 88				call str_at_display 
c5fc			 
c5fc				; display current data stack pointer 
c5fc 11 e0 c4			ld de,.data_sp 
c5ff 3e 1c				ld a, display_row_2 + 8 
c601 cd 8d 88				call str_at_display 
c604			 
c604 2a 93 ec			ld hl,(cli_data_sp) 
c607 e5				push hl 
c608 7c				ld a,h 
c609 21 eb e7			ld hl, os_word_scratch 
c60c cd a8 8d			call hexout 
c60f e1				pop hl 
c610 7d				ld a,l 
c611 21 ed e7			ld hl, os_word_scratch+2 
c614 cd a8 8d			call hexout 
c617 21 ef e7			ld hl, os_word_scratch+4 
c61a 3e 00			ld a,0 
c61c 77				ld (hl),a 
c61d 11 eb e7			ld de,os_word_scratch 
c620 3e 1f				ld a, display_row_2 + 11 
c622 cd 8d 88				call str_at_display 
c625			 
c625 cd 9d 88			call update_display 
c628 cd fa 87			call delay1s 
c62b cd fa 87			call delay1s 
c62e e1				pop hl 
c62f f1				pop af 
c630 c9				ret 
c631			;endif 
c631			 
c631			include "forth_autostart.asm" 
c631			; list of commands to perform at system start up 
c631			 
c631			startcmds: 
c631			;	dw test11 
c631			;	dw test12 
c631			;	dw test13 
c631			;	dw test14 
c631			;	dw test15 
c631			;	dw test16 
c631			;	dw test17 
c631			;	dw ifthtest1 
c631			;	dw ifthtest2 
c631			;	dw ifthtest3 
c631			;	dw mmtest1 
c631			;	dw mmtest2 
c631			;	dw mmtest3 
c631			;	dw mmtest4 
c631			;	dw mmtest5 
c631			;	dw mmtest6 
c631			;	dw iftest1 
c631			;	dw iftest2 
c631			;	dw iftest3 
c631			;	dw looptest1 
c631			;	dw looptest2 
c631			;	dw test1 
c631			;	dw test2 
c631			;	dw test3 
c631			;	dw test4 
c631			;	dw game2r 
c631			;	dw game2b1 
c631			;	dw game2b2 
c631			 
c631				; start up words that are actually useful 
c631			 
c631 8f c6			dw clrstack 
c633 c2 c6			dw type 
c635 83 c8			dw stest 
c637 e6 c6			dw strncpy 
c639 24 c8			dw list 
c63b 47 c7			dw start1 
c63d 59 c7			dw start2 
c63f			;	dw start3 
c63f 6c c7			dw start3b 
c641 c4 c7			dw start3c 
c643			 
c643				; (unit) testing words 
c643			 
c643 fa c8			dw mtesta 
c645 af c9			dw mtestb 
c647 52 ca			dw mtestc 
c649 07 cb			dw mtestd 
c64b ab cb			dw mteste 
c64d			 
c64d				; demo/game words 
c64d			 
c64d b7 d2		        dw game3w 
c64f e5 d2		        dw game3p 
c651 03 d3		        dw game3sc 
c653 34 d3		        dw game3vsi 
c655 60 d3		        dw game3vs 
c657				 
c657 aa d0			dw game2b 
c659 18 d1			dw game2bf 
c65b 62 d1			dw game2mba 
c65d f8 d1			dw game2mbas 
c65f 3a d2			dw game2mb 
c661			 
c661 6b cd			dw game1 
c663 7c cd			dw game1a 
c665 de cd			dw game1b 
c667 13 ce			dw game1c 
c669 49 ce			dw game1d 
c66b 7a ce			dw game1s 
c66d 8e ce			dw game1t 
c66f a3 ce			dw game1f 
c671 d7 ce			dw game1z 
c673 1b cf			dw game1zz 
c675			 
c675 61 cc			dw test5 
c677 99 cc			dw test6 
c679 d1 cc			dw test7 
c67b e5 cc			dw test8 
c67d 11 cd			dw test9 
c67f 27 cd			dw test10 
c681				 
c681 f2 cf		        dw ssv5 
c683 d6 cf		        dw ssv4 
c685 ba cf		        dw ssv3 
c687 84 cf		        dw ssv2 
c689 0b d0		        dw ssv1 
c68b 53 d0		        dw ssv1cpm 
c68d			;	dw keyup 
c68d			;	dw keydown 
c68d			;	dw keyleft 
c68d			;	dw keyright 
c68d			;	dw 	keyf1 
c68d			;	dw keyf2 
c68d			;	dw keyf3 
c68d			;	dw keyf4 
c68d			;	dw keyf5 
c68d			;	dw keyf6 
c68d			;	dw keyf7 
c68d			;	dw keyf8 
c68d			;	dw keyf9 
c68d			;	dw keyf10 
c68d			;	dw keyf11 
c68d			;	dw keyf12 
c68d			;	dw keytab 
c68d			;	dw keycr 
c68d			;	dw keyhome 
c68d			;	dw keyend 
c68d			;	dw keybs 
c68d 00 00			db 0, 0	 
c68f			 
c68f			 
c68f			; clear stack  
c68f			 
c68f .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c6c2			 
c6c2			; type ( addr count - ) 
c6c2 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c6e6			 
c6e6			; some direct memory words 
c6e6			; strncpy ( len t f -- t ) 
c6e6			 
c6e6 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c747			 
c747 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c759 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c76c			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c76c .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c7c4 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c824			 
c824			 
c824			; a handy word to list items on the stack 
c824			 
c824 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c883			 
c883			 
c883			; test stack  
c883			; rnd8 stest 
c883			 
c883 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c8fa			 
c8fa			; random malloc and free cycles 
c8fa			 
c8fa .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c9af			 
c9af			; fixed malloc and free cycles 
c9af			 
c9af .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
ca52			 
ca52			; fixed double string push and drop cycle  
ca52			 
ca52 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cb07			 
cb07			; consistent fixed string push and drop cycle  
cb07			 
cb07 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cbab			 
cbab .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cc61			 
cc61			;test1:		db ": aa 1 2 3 ;", 0 
cc61			;test2:     	db "111 aa 888 999",0 
cc61			;test3:     	db ": bb 77 ;",0 
cc61			;test4:     	db "$02 $01 do i . loop bb",0 
cc61			 
cc61 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cc99 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
ccd1 .. 00		test7:     	db ": box hline vline ;",0 
cce5 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cd11 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cd27 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cd4c .. 00		test11:     	db "hello create .",0 
cd5b .. 00		test12:     	db "hello2 create .",0 
cd6b			 
cd6b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cd6b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cd6b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cd6b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cd6b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cd6b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cd6b			 
cd6b			;iftest1:     	db "$0001 IF cls .",0 
cd6b			;iftest2:     	db "$0000 IF cls .",0 
cd6b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cd6b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cd6b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cd6b			 
cd6b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd6b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd6b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd6b			 
cd6b			 
cd6b			 
cd6b			; a small guess the number game 
cd6b			 
cd6b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cd7c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cdde			 
cdde .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ce13 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
ce49 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
ce7a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
ce8e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cea3 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
ced7 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cf1b			 
cf1b			; Using 'ga' save a high score across multiple runs using external storage 
cf1b			 
cf1b .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cf84			 
cf84			 
cf84			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cf84			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cf84			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cf84			 
cf84			; simple screen saver to test code memory reuse to destruction 
cf84			 
cf84 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cfba .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cfd6 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cff2 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d00b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d053 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d0aa			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d0aa			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d0aa			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d0aa			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d0aa			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d0aa			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d0aa			 
d0aa			 
d0aa			 
d0aa			; minesweeper/battleship finding game 
d0aa			; draws a game board of random ship/mine positions 
d0aa			; user enters coords to see if it hits on 
d0aa			; game ends when all are hit 
d0aa			; when hit or miss says how many may be in the area 
d0aa			 
d0aa			; setup the game board and then hide it 
d0aa .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d118 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d162			; prompt for where to target 
d162 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d1f8 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d21d			; TODO see if the entered coords hits or misses pushes char hit of miss 
d21d .. 00		game2mbht:      db ": mbckht nop ;",0 
d22c .. 00		game2mbms:      db ": mbcms nop ;",0 
d23a			; TODO how many might be near by 
d23a .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d2b7			 
d2b7			; Game 3 
d2b7			 
d2b7			; Vert scroller ski game - avoid the trees! 
d2b7			 
d2b7			; v0 score (ie turns) 
d2b7			; v1 player pos 
d2b7			; v2 left wall 
d2b7			; v3 right wall 
d2b7			 
d2b7			; Draw side walls randomly 
d2b7			 
d2b7 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d2e5			 
d2e5			; Draw player 
d2e5 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d303			 
d303			; TODO Get Key 
d303			 
d303			; TODO Move left right 
d303			 
d303			; scroll and move walls a bit 
d303			 
d303 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d334			 
d334			; main game loop 
d334			 
d334 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d360 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d39f			 
d39f			; key board defs 
d39f			 
d39f .. 00		keyup:       db ": keyup $05 ;",0 
d3ad .. 00		keydown:       db ": keydown $0a ;",0 
d3bd .. 00		keyleft:       db ": keyleft $0b ;",0 
d3cd .. 00		keyright:       db ": keyright $0c ;",0 
d3de .. 00		keyf1:       db ": keyf1 $10 ;",0 
d3ec .. 00		keyf2:       db ": keyf2 $11 ;",0 
d3fa .. 00		keyf3:       db ": keyf3 $12 ;",0 
d408 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d416 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d424 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d432 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d440 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d44e .. 00		keyf9:       db ": keyf9 $18 ;",0 
d45c .. 00		keyf10:       db ": keyf10 $19 ;",0 
d46b .. 00		keyf11:       db ": keyf11 $1a ;",0 
d47a .. 00		keyf12:       db ": keyf12 $1b ;",0 
d489			 
d489 .. 00		keytab:       db ": keytab $09 ;",0 
d498 .. 00		keycr:       db ": keycr $0d ;",0 
d4a6 .. 00		keyhome:       db ": keyhome $0e ;",0 
d4b6 .. 00		keyend:       db ": keyend $0f ;",0 
d4c5 .. 00		keybs:       db ": keybs $08 ;",0 
d4d3			 
d4d3			   
d4d3			 
d4d3			 
d4d3			 
d4d3			; eof 
# End of file forth_autostart.asm
d4d3			 
d4d3 .. 00		sprompt1: db "Startup load...",0 
d4e3 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d4f9			 
d4f9			 
d4f9			 
d4f9			 
d4f9			forth_startup: 
d4f9 21 31 c6			ld hl, startcmds 
d4fc 3e 00			ld a, 0 
d4fe 32 0c e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d501			 
d501 e5			.start1:	push hl 
d502 cd 7a 88			call clear_display 
d505 11 d3 d4			ld de, sprompt1 
d508 3e 00		        ld a, display_row_1 
d50a cd 8d 88			call str_at_display 
d50d 11 e3 d4			ld de, sprompt2 
d510 3e 14		        ld a, display_row_2 
d512 cd 8d 88			call str_at_display 
d515 e1				pop hl 
d516 e5				push hl 
d517 5e				ld e,(hl) 
d518 23				inc hl 
d519 56				ld d,(hl) 
d51a 3e 28		        ld a, display_row_3 
d51c cd 8d 88			call str_at_display 
d51f cd 9d 88			call update_display 
d522			 
d522			 
d522 3a 0c e9			ld a, (os_last_cmd) 
d525 fe 00			cp 0 
d527 28 05			jr z, .startprompt 
d529 cd ee 87			call delay250ms 
d52c 18 24			jr .startdo 
d52e				 
d52e				 
d52e			 
d52e			.startprompt: 
d52e			 
d52e 3e 4f			ld a,display_row_4 + display_cols - 1 
d530 11 f7 97		        ld de, endprg 
d533 cd 8d 88			call str_at_display 
d536 cd 9d 88			call update_display 
d539 cd fa 87			call delay1s 
d53c cd 5f d8			call cin_wait 
d53f						 
d53f fe 2a			cp '*' 
d541 28 5e			jr z, .startupend1 
d543 fe 23			cp '#' 
d545 20 07			jr nz, .startno 
d547 3e 01			ld a, 1 
d549 32 0c e9			ld (os_last_cmd),a 
d54c 18 04			jr .startdo 
d54e fe 31		.startno:	cp '1' 
d550 28 3a			jr z,.startnxt  
d552			 
d552				; exec startup line 
d552			.startdo:	 
d552 e1				pop hl 
d553 e5				push hl 
d554				 
d554 5e				ld e,(hl) 
d555 23				inc hl 
d556 56				ld d,(hl) 
d557 eb				ex de,hl 
d558			 
d558 e5				push hl 
d559			 
d559 3e 00			ld a, 0 
d55b				;ld a, FORTH_END_BUFFER 
d55b cd 10 8f			call strlent 
d55e 23				inc hl   ; include zero term to copy 
d55f 06 00			ld b,0 
d561 4d				ld c,l 
d562 e1				pop hl 
d563 11 e6 e4			ld de, scratch 
d566 ed b0			ldir 
d568			 
d568			 
d568 21 e6 e4			ld hl, scratch 
d56b cd 38 9c			call forthparse 
d56e cd 78 9c			call forthexec 
d571 cd 8f 9b			call forthexec_cleanup 
d574			 
d574 3e 3c			ld a, display_row_4 
d576 11 9b 95			ld de, endprog 
d579			 
d579 cd 9d 88			call update_display		 
d57c			 
d57c 3a 0c e9			ld a, (os_last_cmd) 
d57f fe 00			cp 0 
d581 20 09			jr nz, .startnxt 
d583 cd f9 97			call next_page_prompt 
d586 cd 7a 88		        call clear_display 
d589 cd 9d 88			call update_display		 
d58c			 
d58c				; move onto next startup line? 
d58c			.startnxt: 
d58c			 
d58c cd ee 87			call delay250ms 
d58f e1				pop hl 
d590			 
d590 23				inc hl 
d591 23				inc hl 
d592			 
d592 e5				push hl 
d593 5e				ld e, (hl) 
d594 23				inc hl 
d595 56				ld d, (hl) 
d596 e1				pop hl 
d597				; TODO replace 0 test 
d597			 
d597 eb				ex de, hl 
d598 cd d0 8a			call ishlzero 
d59b			;	ld a,e 
d59b			;	add d 
d59b			;	cp 0    ; any left to do? 
d59b eb				ex de, hl 
d59c c2 01 d5			jp nz, .start1 
d59f 18 01			jr .startupend 
d5a1			 
d5a1 e1			.startupend1: pop hl 
d5a2			.startupend: 
d5a2			 
d5a2 cd 7a 88			call clear_display 
d5a5 cd 9d 88			call update_display 
d5a8 c9				ret 
d5a9			 
d5a9			 
d5a9			; stack over and underflow checks 
d5a9			 
d5a9			; init the words to detect the under/overflow 
d5a9			 
d5a9			chk_stk_init: 
d5a9				; a vague random number to check so we dont get any "lucky" hits 
d5a9 3e 2d			ld a, 45 
d5ab 6f				ld l, a 
d5ac 00				nop 
d5ad 3e 17			ld a, 23 
d5af 67				ld h, a 
d5b0			 
d5b0 22 cd e4			ld (chk_word), hl     ; the word we need to check against 
d5b3			 
d5b3			;	ld (chk_stund), hl	; stack points.... 
d5b3 22 00 ef			ld (chk_stovr), hl 
d5b6 22 91 ec			ld (chk_ret_und), hl 
d5b9 22 4f ec			ld (chk_ret_ovr), hl 
d5bc 22 4d eb			ld (chk_loop_ovr), hl 
d5bf 22 4b ea			ld (chk_data_ovr), hl 
d5c2 c9				ret 
d5c3				 
d5c3			check_stacks: 
d5c3				; check all stack words 
d5c3			 
d5c3 e5				push hl 
d5c4 d5				push de 
d5c5			 
d5c5			;	ld de,(chk_word) 
d5c5			;	ld hl, (chk_stund)	; stack points.... 
d5c5			;	if DEBUG_STK_FAULT 
d5c5			;		DMARK "FAa" 
d5c5			;		CALLMONITOR 
d5c5			;	endif 
d5c5			;	call cmp16 
d5c5			;	jp z, .chk_faulta 
d5c5			; 
d5c5			;	ld de, sfaultsu 
d5c5			;	jp .chk_fault 
d5c5			 
d5c5 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d5c8 ed 5b cd e4		ld de,(chk_word) 
d5cc				if DEBUG_STK_FAULT 
d5cc					DMARK "FAb" 
d5cc					CALLMONITOR 
d5cc				endif 
d5cc cd c5 8a			call cmp16 
d5cf 28 06			jr z, .chk_fault1 
d5d1 11 72 d6			ld de, sfaultso 
d5d4 c3 26 d6			jp .chk_fault 
d5d7			.chk_fault1:  
d5d7 2a 91 ec			ld hl, (chk_ret_und) 
d5da ed 5b cd e4		ld de,(chk_word) 
d5de				if DEBUG_STK_FAULT 
d5de					DMARK "FAU" 
d5de					CALLMONITOR 
d5de				endif 
d5de cd c5 8a			call cmp16 
d5e1 ca ea d5			jp z, .chk_fault2 
d5e4 11 82 d6			ld de, sfaultru 
d5e7 c3 26 d6			jp .chk_fault 
d5ea			.chk_fault2:  
d5ea 2a 4f ec			ld hl, (chk_ret_ovr) 
d5ed ed 5b cd e4		ld de,(chk_word) 
d5f1				if DEBUG_STK_FAULT 
d5f1					DMARK "FA1" 
d5f1					CALLMONITOR 
d5f1				endif 
d5f1 cd c5 8a			call cmp16 
d5f4 ca fd d5			jp z, .chk_fault3 
d5f7 11 90 d6			ld de, sfaultro 
d5fa c3 26 d6			jp .chk_fault 
d5fd			.chk_fault3:  
d5fd 2a 4d eb			ld hl, (chk_loop_ovr) 
d600 ed 5b cd e4		ld de,(chk_word) 
d604				if DEBUG_STK_FAULT 
d604					DMARK "FA2" 
d604					CALLMONITOR 
d604				endif 
d604 cd c5 8a			call cmp16 
d607 ca 10 d6			jp z, .chk_fault4 
d60a 11 aa d6			ld de, sfaultlo 
d60d c3 26 d6			jp .chk_fault 
d610			.chk_fault4:  
d610 2a 4b ea			ld hl, (chk_data_ovr) 
d613 ed 5b cd e4		ld de,(chk_word) 
d617				if DEBUG_STK_FAULT 
d617					DMARK "FA3" 
d617					CALLMONITOR 
d617				endif 
d617 cd c5 8a			call cmp16 
d61a ca 23 d6			jp z, .chk_fault5 
d61d 11 c4 d6			ld de, sfaultdo 
d620 c3 26 d6			jp .chk_fault 
d623			 
d623			 
d623			.chk_fault5:  
d623 d1				pop de 
d624 e1				pop hl 
d625			 
d625 c9				ret 
d626			 
d626 cd 7a 88		.chk_fault: 	call clear_display 
d629 3e 14				ld a, display_row_2 
d62b cd 8d 88				call str_at_display 
d62e 11 54 d6				   ld de, .stackfault 
d631 3e 00				ld a, display_row_1 
d633 cd 8d 88				call str_at_display 
d636 11 c0 ee				    ld de, debug_mark 
d639 3e 11				ld a, display_row_1+17 
d63b cd 8d 88				call str_at_display 
d63e cd 9d 88				call update_display 
d641			 
d641				; prompt before entering montior for investigating issue 
d641			 
d641 3e 3c			ld a, display_row_4 
d643 11 9b 95			ld de, endprog 
d646			 
d646 cd 9d 88			call update_display		 
d649			 
d649 cd f9 97			call next_page_prompt 
d64c			 
d64c d1				pop de 
d64d e1				pop hl 
d64e cd ef 95				call monitor 
d651 c3 e9 94				jp warmstart 
d654					;jp 0 
d654					;halt 
d654			 
d654			 
d654			 
d654 .. 00		.stackfault: 	db "Stack fault:",0 
d661			 
d661 .. 00		sfaultsu: 	db	"Stack under flow",0 
d672 .. 00		sfaultso: 	db	"Stack over flow",0 
d682 .. 00		sfaultru:	db "RTS underflow",0 
d690 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d6aa .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d6c4 .. 00		sfaultdo:	db "DTS overflow", 0 
d6d1			 
d6d1			 
d6d1			fault_dsp_under: 
d6d1 11 e3 d6			ld de, .dsp_under 
d6d4 c3 93 d7			jp .show_fault 
d6d7			 
d6d7			fault_rsp_under: 
d6d7 11 f1 d6			ld de, .rsp_under 
d6da c3 93 d7			jp .show_fault 
d6dd			fault_loop_under: 
d6dd 11 ff d6			ld de, .loop_under 
d6e0 c3 93 d7			jp .show_fault 
d6e3			 
d6e3 .. 00		.dsp_under: db "DSP Underflow",0 
d6f1 .. 00		.rsp_under: db "RSP Underflow",0 
d6ff .. 00		.loop_under: db "LOOP Underflow",0 
d70e			 
d70e			 
d70e d5			type_faultn: 	push de 
d70f e5					push hl 
d710 cd 7a 88				call clear_display 
d713 11 3a d7				   ld de, .typefaultn 
d716 3e 00				ld a, display_row_1 
d718 cd 8d 88				call str_at_display 
d71b 11 c0 ee				    ld de, debug_mark 
d71e 3e 11				ld a, display_row_1+17 
d720 cd 8d 88				call str_at_display 
d723 cd 9d 88				call update_display 
d726			 
d726				; prompt before entering montior for investigating issue 
d726			 
d726 3e 3c			ld a, display_row_4 
d728 11 9b 95			ld de, endprog 
d72b			 
d72b cd 9d 88			call update_display		 
d72e			 
d72e cd f9 97			call next_page_prompt 
d731			 
d731 e5					push hl 
d732 d5					push de 
d733 cd ef 95				call monitor 
d736 c3 e9 94				jp warmstart 
d739 76					halt 
d73a			 
d73a			 
d73a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d751			 
d751 d5			type_faults: 	push de 
d752 e5					push hl 
d753 cd 7a 88				call clear_display 
d756 11 7c d7				   ld de, .typefaults 
d759 3e 00				ld a, display_row_1 
d75b cd 8d 88				call str_at_display 
d75e 11 c0 ee				    ld de, debug_mark 
d761 3e 11				ld a, display_row_1+17 
d763 cd 8d 88				call str_at_display 
d766 cd 9d 88				call update_display 
d769			 
d769				; prompt before entering montior for investigating issue 
d769			 
d769 3e 3c			ld a, display_row_4 
d76b 11 9b 95			ld de, endprog 
d76e			 
d76e cd 9d 88			call update_display		 
d771			 
d771 cd f9 97			call next_page_prompt 
d774			 
d774 e1					pop hl 
d775 d1					pop de 
d776 cd ef 95				call monitor 
d779 c3 e9 94				jp warmstart 
d77c			 
d77c			 
d77c .. 00		.typefaults: db "STR Type Expected TOS!",0 
d793			 
d793			.show_fault: 	 
d793 d5					push de 
d794 cd 7a 88				call clear_display 
d797 d1					pop de 
d798 3e 00				ld a, display_row_1 
d79a cd 8d 88				call str_at_display 
d79d 11 c0 ee				    ld de, debug_mark 
d7a0 3e 11				ld a, display_row_1+17 
d7a2 cd 8d 88				call str_at_display 
d7a5 cd 9d 88				call update_display 
d7a8			 
d7a8				; prompt before entering montior for investigating issue 
d7a8			 
d7a8 3e 3c			ld a, display_row_4 
d7aa 11 9b 95			ld de, endprog 
d7ad			 
d7ad cd 9d 88			call update_display		 
d7b0			 
d7b0 cd f9 97			call next_page_prompt 
d7b3			 
d7b3 e1					pop hl 
d7b4 d1					pop de 
d7b5 cd ef 95				call monitor 
d7b8			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d7b8			; TODO Make optional fault restart to cli or warm boot? 
d7b8					;jp warmstart 
d7b8 c3 41 95				jp cli 
d7bb 76					halt 
d7bc			 
d7bc			; handle the auto run of code from files in storage 
d7bc			 
d7bc			 
d7bc			if STORAGE_SE 
d7bc			 
d7bc			sprompt3: db "Loading from start-up file:",0 
d7bc			 
d7bc			 
d7bc			forth_autoload: 
d7bc			 
d7bc				; load block 0 of store 1 
d7bc				 
d7bc				ld a, $fe      ; bit 0 clear 
d7bc				ld (spi_device), a 
d7bc			 
d7bc				call storage_get_block_0 
d7bc			 
d7bc				ld a, (store_page+STORE_0_AUTOFILE) 
d7bc			 
d7bc				cp 0 
d7bc				ret z     ; auto start not enabled 
d7bc			 
d7bc				call clear_display 
d7bc			 
d7bc				; set bank 
d7bc			 
d7bc					ld a, (store_page+STORE_0_BANKRUN) 
d7bc					ld (spi_device), a 
d7bc			 
d7bc				; get file id to load from and get the file name to display 
d7bc			 
d7bc					ld a, (store_page+STORE_0_AUTOFILE) 
d7bc			 
d7bc					ld l, 0 
d7bc					ld h, a 
d7bc					ld de, store_page 
d7bc			 
d7bc					call storage_read 
d7bc			 
d7bc					call ishlzero 
d7bc					ret z             ; file not found 
d7bc			 
d7bc					ld a, display_row_3 + 10 
d7bc					ld de, store_page+3 
d7bc					call str_at_display 
d7bc				 
d7bc			; 
d7bc			 
d7bc				ld a, display_row_2+5 
d7bc				ld de, sprompt3 
d7bc				call str_at_display 
d7bc			 
d7bc				call update_display 
d7bc			 
d7bc			 
d7bc				call delay1s 
d7bc			 
d7bc				ret 
d7bc			 
d7bc			 
d7bc			 
d7bc			endif 
d7bc			 
d7bc			 
d7bc			; eof 
# End of file forth_kernel.asm
d7bc			;include "nascombasic.asm" 
d7bc			 
d7bc			 
d7bc			; find out where the code ends if loaded into RAM (for SC114) 
d7bc			;endofcode:  
d7bc			;	nop 
d7bc			 
d7bc			 
d7bc			; eof 
d7bc			 
# End of file main.asm
d7bc			;include "firmware_lcd_4x20.asm" 
d7bc			;include "firmware_key_4x4.asm" 
d7bc			include "firmware_serial_display.asm" 
d7bc			 
d7bc			; Serial display interface for SC114 
d7bc			 
d7bc			 
d7bc			display_row_1: equ 0 
d7bc			display_row_2: equ display_row_1+display_cols 
d7bc			display_row_3: equ display_row_2 + display_cols 
d7bc			display_row_4: equ display_row_3 + display_cols 
d7bc			 
d7bc			kLCDWidth:  EQU display_cols             ;Width in characters 
d7bc			kLCD_Line1: EQU 0x00  
d7bc			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d7bc			; E1 
d7bc			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d7bc			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d7bc			 
d7bc			lcd_init: 
d7bc				; no init as handled by the SCM bios 
d7bc c9				ret 
d7bd			 
d7bd			 
d7bd			; low level functions for direct screen writes 
d7bd			 
d7bd			; output char at pos? 
d7bd			fLCD_Str: 
d7bd			        ;out (SC114_SIO_1_OUT),a 
d7bd c5				push bc 
d7be 0e 02			ld c, $02 
d7c0 f7				rst $30 
d7c1 c1				pop bc 
d7c2 c9				ret 
d7c3			 
d7c3			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d7c3			fLCD_Pos: 
d7c3				; use ASCII escape to position 
d7c3			        ;out (SC114_SIO_1_OUT),a 
d7c3 c5				push bc 
d7c4 0e 02			ld c, $02 
d7c6 f7				rst $30 
d7c7 c1				pop bc 
d7c8			 
d7c8 c9				ret 
d7c9			 
d7c9			; output char at pos 
d7c9			fLCD_Data: 
d7c9			      ;  out (SC114_SIO_1_OUT),a 
d7c9 c5				push bc 
d7ca 0e 02			ld c, $02 
d7cc f7				rst $30 
d7cd c1				pop bc 
d7ce			 
d7ce c9				ret 
d7cf			 
d7cf			; ascii cls  
d7cf			 
d7cf 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d7d3			 
d7d3			; write the frame buffer given in hl to hardware  
d7d3			write_display: 
d7d3			 
d7d3			API: equ 0 
d7d3			 
d7d3			if API 
d7d3				push bc 
d7d3				ld b, 4 
d7d3			 
d7d3			        ld (display_write_tmp), hl 	  
d7d3			 
d7d3				; clear and home cursor 
d7d3			 
d7d3				ld c, 6 
d7d3				ld de, .cls 
d7d3				rst $30 
d7d3			 
d7d3			 
d7d3			.writeln: 
d7d3			 
d7d3				ld de, (display_write_tmp) 
d7d3				ld c, 6 
d7d3				rst $30 
d7d3				ld c, 7 
d7d3				rst $30 
d7d3			 
d7d3				ld hl, (display_write_tmp) 
d7d3				ld de, display_cols 
d7d3				add hl,de 
d7d3				ld (display_write_tmp),hl 
d7d3			 
d7d3				djnz  .writeln 
d7d3			 
d7d3				pop bc 
d7d3			 
d7d3			 
d7d3				ret 
d7d3			endif 
d7d3 e5				push hl 
d7d4 c5				push bc 
d7d5 d5				push de 
d7d6			 
d7d6			;	ld c, 2 
d7d6			;	;ld de, .cls 
d7d6			;	ld a, 27 
d7d6			;	rst $30 
d7d6			;	ld c, 2 
d7d6			;	;ld de, .cls 
d7d6			;	ld a, '[' 
d7d6			;	rst $30 
d7d6			; 
d7d6			;	ld c, 2 
d7d6			;	;ld de, .cls 
d7d6			;	ld a, 'H' 
d7d6			;	rst $30 
d7d6			; 
d7d6			 
d7d6 0e 02			ld c, 2 
d7d8				;ld de, .cls 
d7d8 3e 1b			ld a, 27 
d7da f7				rst $30 
d7db			 
d7db			 
d7db 0e 02			ld c, 2 
d7dd				;ld de, .cls 
d7dd 3e 5b			ld a, '[' 
d7df f7				rst $30 
d7e0 0e 02			ld c, 2 
d7e2				;ld de, .cls 
d7e2 3e 32			ld a, '2' 
d7e4 f7				rst $30 
d7e5 0e 02			ld c, 2 
d7e7				;ld de, .cls 
d7e7 3e 4a			ld a, 'J' 
d7e9 f7				rst $30 
d7ea d1				pop de 
d7eb c1				pop bc 
d7ec e1				pop hl 
d7ed			 
d7ed			 
d7ed 22 5e ed		        ld (display_write_tmp), hl 	  
d7f0 3e 00			ld a, kLCD_Line1 
d7f2			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d7f2 06 14			ld b, display_cols 
d7f4 ed 5b 5e ed		ld de, (display_write_tmp) 
d7f8 cd 56 d8			call write_len_string 
d7fb				 
d7fb			 
d7fb e5			push hl 
d7fc d5			push de 
d7fd c5			push bc 
d7fe 0e 07			ld c, 7 
d800 f7				rst $30 
d801 c1			pop bc 
d802 d1			pop de 
d803 e1			pop hl 
d804			 
d804				 
d804 2a 5e ed			ld hl, (display_write_tmp) 
d807 11 14 00			ld de, display_cols 
d80a 19				add hl,de 
d80b 22 5e ed			ld (display_write_tmp),hl 
d80e			 
d80e				 
d80e 3e 14			ld a, kLCD_Line2 
d810			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d810 06 14			ld b, display_cols 
d812 ed 5b 5e ed		ld de, (display_write_tmp) 
d816 cd 56 d8			call write_len_string 
d819				 
d819 2a 5e ed			ld hl, (display_write_tmp) 
d81c 11 14 00			ld de, display_cols 
d81f 19				add hl,de 
d820 22 5e ed			ld (display_write_tmp),hl 
d823			 
d823 e5			push hl 
d824 d5			push de 
d825 c5			push bc 
d826 0e 07			ld c, 7 
d828 f7				rst $30 
d829 c1			pop bc 
d82a d1			pop de 
d82b e1			pop hl 
d82c			 
d82c				 
d82c 3e 28			ld a, kLCD_Line3 
d82e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d82e 06 14			ld b, display_cols 
d830 ed 5b 5e ed		ld de, (display_write_tmp) 
d834 cd 56 d8			call write_len_string 
d837				 
d837 2a 5e ed			ld hl, (display_write_tmp) 
d83a 11 14 00			ld de, display_cols 
d83d 19				add hl,de 
d83e 22 5e ed			ld (display_write_tmp),hl 
d841			 
d841 e5			push hl 
d842 d5			push de 
d843 c5			push bc 
d844 0e 07			ld c, 7 
d846 f7				rst $30 
d847 c1			pop bc 
d848 d1			pop de 
d849 e1			pop hl 
d84a			 
d84a				 
d84a 3e 3c			ld a, kLCD_Line4 
d84c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d84c 06 14			ld b, display_cols 
d84e ed 5b 5e ed		ld de, (display_write_tmp) 
d852 cd 56 d8			call write_len_string 
d855 c9					ret 
d856			 
d856			 
d856				; write out a fixed length string given in b from de 
d856			 
d856 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d857 cd c9 d7		            CALL fLCD_Data      ;Write character to display 
d85a 13				inc de 
d85b 10 f9			djnz write_len_string 
d85d c9				ret 
d85e			 
d85e			 
d85e			; eof 
# End of file firmware_serial_display.asm
d85e			include "firmware_key_serial.asm" 
d85e			; Serial keyboard interface for SC114 
d85e			 
d85e			key_init: 
d85e				; no init as handled by the SCM bios 
d85e c9				ret 
d85f			 
d85f			 
d85f			cin_wait: 
d85f			;	ld a, 0 
d85f			;	ret 
d85f			 
d85f				;in a,(SC114_SIO_1_IN) 
d85f			        ; Use SCM API to get from whatever console device we are using 
d85f c5				push bc 
d860 0e 01			ld c, $01 
d862 f7				rst $30 
d863 c1				pop bc 
d864 c9				ret 
d865			 
d865			cin: 
d865			 
d865			 
d865 c5				push bc 
d866			 
d866				; any key waiting to process? 
d866 0e 03			ld c, $03 
d868 f7				rst $30 
d869 28 05			jr z, .cin_skip 
d86b			 
d86b				; yep, get it 
d86b			 
d86b 0e 01			ld c, $01 
d86d f7				rst $30 
d86e c1				pop bc 
d86f c9				ret 
d870			.cin_skip: 
d870 3e 00			ld a, 0 
d872 c1				pop bc 
d873 c9				ret 
d874			 
d874			 
d874			 
d874			 
# End of file firmware_key_serial.asm
d874			 
d874			baseram:  
d874			endofcode: 
d874 00				nop 
d875			 
d875			heap_start: equ baseram+15  ; Starting address of heap 
d875			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d875			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d875			; 
d875			 
# End of file os_mini_sc114.asm
d875
