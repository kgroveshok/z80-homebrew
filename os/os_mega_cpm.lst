# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 7c 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-09-06 15:40' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			  
011f			debug_umark: equ debug_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 0a ed				ld hl, display_fb1  
0122 22 c6 eb				ld (display_fb_active), hl  
0125			  
0125 cd c8 0b				call clear_display  
0128			  
0128 21 c8 eb				ld hl, display_fb2  
012b 22 c6 eb				ld (display_fb_active), hl  
012e			  
012e cd c8 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 ab ed				ld hl, display_fb0  
0134 22 c6 eb				ld (display_fb_active), hl  
0137			  
0137 cd c8 0b				call clear_display  
013a			  
013a			  
013a cd 12 63				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd 00 64			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd ac 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd eb 0b			call update_display  
0149 cd 00 0b			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd cd 0b			call fill_display  
0151 cd eb 0b			call update_display  
0154 cd 00 0b			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd cd 0b			call fill_display  
015c cd eb 0b			call update_display  
015f cd 00 0b			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd cd 0b			call fill_display  
0167 cd eb 0b			call update_display  
016a cd 00 0b			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 da 16			ld de, prom_bootmsg  
0172 cd db 0b			call str_at_display  
0175 cd eb 0b			call update_display  
0178			  
0178			  
0178 cd 00 0b			call delay1s  
017b cd 00 0b			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 ef 16			ld de, prom_bootmsg1  
0183 cd db 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd db 0b			call str_at_display  
018e			  
018e cd eb 0b			call update_display  
0191 cd 00 0b			call delay1s  
0194 cd 00 0b			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 65 ee		ld (debug_mark),a  
019c 32 66 ee		ld (debug_mark+1),a  
019f 32 67 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 68 ee		ld (debug_mark+3),a  
01a7 32 69 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 6d ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 65 ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 66 ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 67 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6f ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 38 03			call storage_get_block_0 
01d0			 
01d0 3a 74 ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 65 ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 66 ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 67 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6f ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 74 ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 65 ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 66 ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 67 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6f ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd e0 07				call storage_read 
0216 cd 1e 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 6d ea				ld hl, (store_tmp1) 
021e 11 77 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 65 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 66 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 67 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6f ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 93 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 65 ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 66 ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 67 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6f ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 65 ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 66 ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 67 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6f ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 65 ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 66 ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 67 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6f ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 65 ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 66 ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 67 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6f ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd ba 05			call storage_findnextid 
02db			 
02db cd 1e 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 74 ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 76 ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 65 ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 66 ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 67 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6f ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311 00				nop 
0312 00				nop 
0313 00				nop 
0314			;	if DEBUG_STORESE 
0314			;		push af 
0314			;		ld a, 'w' 
0314			;		ld (debug_mark),a 
0314			;		pop af 
0314			;		CALLMONITOR 
0314			;	endif 
0314 c1				pop bc 
0315 d1				pop de 
0316 e1				pop hl 
0317 23				inc hl 
0318 13				inc de 
0319			 
0319			 
0319 10 ef			djnz .wl1 
031b			 
031b				if DEBUG_STORESE 
031b					DMARK "SW2" 
031b f5				push af  
031c 3a 30 03			ld a, (.dmark)  
031f 32 65 ee			ld (debug_mark),a  
0322 3a 31 03			ld a, (.dmark+1)  
0325 32 66 ee			ld (debug_mark+1),a  
0328 3a 32 03			ld a, (.dmark+2)  
032b 32 67 ee			ld (debug_mark+2),a  
032e 18 03			jr .pastdmark  
0330 ..			.dmark: db "SW2"  
0333 f1			.pastdmark: pop af  
0334			endm  
# End of macro DMARK
0334			 
0334					;push af 
0334					;ld a, 'W' 
0334					;ld (debug_mark),a 
0334					;pop af 
0334					CALLMONITOR 
0334 cd 6f ee			call debug_vector  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338			 
0338			; Init bank 
0338			; --------- 
0338			; 
0338			; With current bank 
0338			; 
0338			; Setup block 0 config 
0338			;     Set 0 file id counter 
0338			;     Set formatted byte pattern 
0338			;     Zero out bank label 
0338			;      
0338			; For every logical block write 0-1 byte as null 
0338			 
0338			storage_get_block_0: 
0338			 
0338				; TODO check presence 
0338			 
0338				; get block 0 config 
0338			 
0338 21 00 00			ld hl, 0 
033b 11 74 ea			ld de, store_page 
033e cd 87 02			call storage_read_block 
0341			 
0341				if DEBUG_STORESE 
0341					DMARK "SB0" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 65 ee			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 66 ee			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 67 ee			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SB0"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a 11 74 ea				ld de, store_page 
035d			;		push af 
035d			;		ld a, 'i' 
035d			;		ld (debug_mark),a 
035d			;		pop af 
035d					CALLMONITOR 
035d cd 6f ee			call debug_vector  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360			 
0360				; is this area formatted? 
0360			 
0360			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0360 2a 75 ea			ld hl, (store_page+1) 
0363 3e 80			ld a,0x80 
0365 bd				cp l 
0366 20 22			jr nz, .ininotformatted 
0368				; do a double check 
0368 3e 27			ld a, 0x27 
036a bc				cp h 
036b 20 1d			jr nz, .ininotformatted 
036d			 
036d				; formatted then 
036d			 
036d				if DEBUG_STORESE 
036d					DMARK "SB1" 
036d f5				push af  
036e 3a 82 03			ld a, (.dmark)  
0371 32 65 ee			ld (debug_mark),a  
0374 3a 83 03			ld a, (.dmark+1)  
0377 32 66 ee			ld (debug_mark+1),a  
037a 3a 84 03			ld a, (.dmark+2)  
037d 32 67 ee			ld (debug_mark+2),a  
0380 18 03			jr .pastdmark  
0382 ..			.dmark: db "SB1"  
0385 f1			.pastdmark: pop af  
0386			endm  
# End of macro DMARK
0386					;push af 
0386					;ld a, 'I' 
0386					;ld (debug_mark),a 
0386					;pop af 
0386					CALLMONITOR 
0386 cd 6f ee			call debug_vector  
0389				endm  
# End of macro CALLMONITOR
0389				endif 
0389 c9				ret 
038a			 
038a			.ininotformatted: 
038a				; bank not formatted so poke various bits to make sure 
038a			 
038a				if DEBUG_STORESE 
038a					DMARK "SB2" 
038a f5				push af  
038b 3a 9f 03			ld a, (.dmark)  
038e 32 65 ee			ld (debug_mark),a  
0391 3a a0 03			ld a, (.dmark+1)  
0394 32 66 ee			ld (debug_mark+1),a  
0397 3a a1 03			ld a, (.dmark+2)  
039a 32 67 ee			ld (debug_mark+2),a  
039d 18 03			jr .pastdmark  
039f ..			.dmark: db "SB2"  
03a2 f1			.pastdmark: pop af  
03a3			endm  
# End of macro DMARK
03a3					;push af 
03a3					;ld a, 'f' 
03a3					;ld (debug_mark),a 
03a3					;pop af 
03a3					CALLMONITOR 
03a3 cd 6f ee			call debug_vector  
03a6				endm  
# End of macro CALLMONITOR
03a6				endif 
03a6			 
03a6 cd c3 0a			call storage_clear_page 
03a9			 
03a9 21 74 ea			ld hl, store_page 
03ac 3e 00			ld a, 0 
03ae				 
03ae 77				ld (hl),a   ; reset file counter 
03af			 
03af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03b2 22 75 ea		 	ld (store_page+1), hl	 
03b5			 
03b5				; set default label 
03b5			 
03b5 21 51 04			ld hl, .defaultbanklabl 
03b8 11 77 ea		 	ld de, store_page+3 
03bb 01 0f 00			ld bc, 15 
03be ed b0			ldir 
03c0			 
03c0				; Append the current bank id 
03c0 21 80 ea			ld hl, store_page+3+9 
03c3 3a 59 ea			ld a, (spi_device_id) 
03c6 77				ld (hl), a 
03c7			 
03c7				; save default page 0 
03c7			 
03c7 21 00 00			ld hl, 0 
03ca 11 74 ea			ld de, store_page 
03cd				if DEBUG_STORESE 
03cd					DMARK "SB3" 
03cd f5				push af  
03ce 3a e2 03			ld a, (.dmark)  
03d1 32 65 ee			ld (debug_mark),a  
03d4 3a e3 03			ld a, (.dmark+1)  
03d7 32 66 ee			ld (debug_mark+1),a  
03da 3a e4 03			ld a, (.dmark+2)  
03dd 32 67 ee			ld (debug_mark+2),a  
03e0 18 03			jr .pastdmark  
03e2 ..			.dmark: db "SB3"  
03e5 f1			.pastdmark: pop af  
03e6			endm  
# End of macro DMARK
03e6			;		push af 
03e6			;		ld a, 'F' 
03e6			;		ld (debug_mark),a 
03e6			;		pop af 
03e6					CALLMONITOR 
03e6 cd 6f ee			call debug_vector  
03e9				endm  
# End of macro CALLMONITOR
03e9				endif 
03e9 cd ec 02			call storage_write_block 
03ec				if DEBUG_STORESE 
03ec					DMARK "SB4" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 65 ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 66 ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 67 ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "SB4"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405			;		push af 
0405			;		ld a, '>' 
0405			;		ld (debug_mark),a 
0405			;		pop af 
0405					CALLMONITOR 
0405 cd 6f ee			call debug_vector  
0408				endm  
# End of macro CALLMONITOR
0408				endif 
0408			 
0408 00				nop 
0409 00				nop 
040a 00				nop 
040b			 
040b				; now set 0 in every page to mark as a free block 
040b			 
040b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040d 21 40 00			ld hl, STORE_BLOCK_PHY 
0410			 
0410 3e 00		.setmark1:   	ld a,0 
0412 e5					push hl 
0413 c5					push bc 
0414 cd ac 01				call se_writebyte 
0417 3e 0a			ld a, 10 
0419 cd e5 0a			call aDelayInMS 
041c 23				inc hl 
041d cd ac 01				call se_writebyte 
0420 3e 0a			ld a, 10 
0422 cd e5 0a			call aDelayInMS 
0425 2b				dec hl 
0426 c1					pop bc 
0427 e1					pop hl 
0428 3e 40				ld a, STORE_BLOCK_PHY 
042a cd f5 0d				call addatohl 
042d 10 e1				djnz .setmark1 
042f			 
042f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0431 3e 00		.setmark2:   	ld a,0 
0433 e5					push hl 
0434 c5					push bc 
0435 cd ac 01				call se_writebyte 
0438 3e 0a			ld a, 10 
043a cd e5 0a			call aDelayInMS 
043d 23				inc hl 
043e cd ac 01				call se_writebyte 
0441 3e 0a			ld a, 10 
0443 cd e5 0a			call aDelayInMS 
0446 2b				dec hl 
0447 c1					pop bc 
0448 e1					pop hl 
0449 3e 40				ld a, STORE_BLOCK_PHY 
044b cd f5 0d				call addatohl 
044e 10 e1				djnz .setmark2 
0450			 
0450					 
0450			 
0450			 
0450 c9				ret 
0451			 
0451			 
0451			 
0451			 
0451 .. 00		.defaultbanklabl:   db "BankLabel_",0 
045c			 
045c			 
045c			 
045c			; Label Bank 
045c			; ---------- 
045c			; 
045c			; With current bank 
045c			; Read block 0 
045c			; Set label 
045c			; Write block 0 
045c			 
045c			; label str pointer in hl 
045c			 
045c			storage_label:     
045c			 
045c				if DEBUG_STORESE 
045c					DMARK "LBL" 
045c f5				push af  
045d 3a 71 04			ld a, (.dmark)  
0460 32 65 ee			ld (debug_mark),a  
0463 3a 72 04			ld a, (.dmark+1)  
0466 32 66 ee			ld (debug_mark+1),a  
0469 3a 73 04			ld a, (.dmark+2)  
046c 32 67 ee			ld (debug_mark+2),a  
046f 18 03			jr .pastdmark  
0471 ..			.dmark: db "LBL"  
0474 f1			.pastdmark: pop af  
0475			endm  
# End of macro DMARK
0475					CALLMONITOR 
0475 cd 6f ee			call debug_vector  
0478				endm  
# End of macro CALLMONITOR
0478				endif 
0478			 
0478 e5				push hl 
0479			 
0479 cd 38 03			call storage_get_block_0 
047c			 
047c				; set default label 
047c			 
047c e1				pop hl 
047d			 
047d 11 77 ea		 	ld de, store_page+3 
0480 01 0f 00			ld bc, 15 
0483				if DEBUG_STORESE 
0483					DMARK "LB3" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 65 ee			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 66 ee			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 67 ee			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "LB3"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c					CALLMONITOR 
049c cd 6f ee			call debug_vector  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f ed b0			ldir 
04a1				; save default page 0 
04a1			 
04a1 21 00 00			ld hl, 0 
04a4 11 74 ea			ld de, store_page 
04a7				if DEBUG_STORESE 
04a7					DMARK "LBW" 
04a7 f5				push af  
04a8 3a bc 04			ld a, (.dmark)  
04ab 32 65 ee			ld (debug_mark),a  
04ae 3a bd 04			ld a, (.dmark+1)  
04b1 32 66 ee			ld (debug_mark+1),a  
04b4 3a be 04			ld a, (.dmark+2)  
04b7 32 67 ee			ld (debug_mark+2),a  
04ba 18 03			jr .pastdmark  
04bc ..			.dmark: db "LBW"  
04bf f1			.pastdmark: pop af  
04c0			endm  
# End of macro DMARK
04c0					CALLMONITOR 
04c0 cd 6f ee			call debug_vector  
04c3				endm  
# End of macro CALLMONITOR
04c3				endif 
04c3 cd ec 02			call storage_write_block 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			 
04c7			; Read Block 0 - Config 
04c7			; --------------------- 
04c7			; 
04c7			; With current bank 
04c7			; Call presence test 
04c7			;    If not present format/init bank  
04c7			; Read block 0  
04c7			;  
04c7			 
04c7			 
04c7			; Dir 
04c7			; --- 
04c7			; 
04c7			; With current bank 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block read byte 2 
04c7			;      if first block of file 
04c7			;         Display file name 
04c7			;         Display type flags for file 
04c7			;        
04c7			 
04c7			; moving to words as this requires stack control 
04c7			 
04c7			 
04c7			; Delete File 
04c7			; ----------- 
04c7			; 
04c7			; With current bank 
04c7			; 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block file id 
04c7			;      If first block of file and dont have file id 
04c7			;         if file to delete 
04c7			;         Save file id 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			;      If file id is one saved 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			 
04c7			 
04c7			.se_done: 
04c7 e1				pop hl 
04c8 c9				ret 
04c9			 
04c9			storage_erase: 
04c9			 
04c9				; hl contains the file id 
04c9			 
04c9 5d				ld e, l 
04ca 16 00			ld d, 0 
04cc 21 40 00			ld hl, STORE_BLOCK_PHY 
04cf					if DEBUG_FORTH_WORDS 
04cf						DMARK "ERA" 
04cf f5				push af  
04d0 3a e4 04			ld a, (.dmark)  
04d3 32 65 ee			ld (debug_mark),a  
04d6 3a e5 04			ld a, (.dmark+1)  
04d9 32 66 ee			ld (debug_mark+1),a  
04dc 3a e6 04			ld a, (.dmark+2)  
04df 32 67 ee			ld (debug_mark+2),a  
04e2 18 03			jr .pastdmark  
04e4 ..			.dmark: db "ERA"  
04e7 f1			.pastdmark: pop af  
04e8			endm  
# End of macro DMARK
04e8						CALLMONITOR 
04e8 cd 6f ee			call debug_vector  
04eb				endm  
# End of macro CALLMONITOR
04eb					endif 
04eb cd ba 05			call storage_findnextid 
04ee cd 1e 0e			call ishlzero 
04f1 c8				ret z 
04f2			 
04f2 e5				push hl 
04f3			 
04f3				; TODO check file not found 
04f3			 
04f3 11 74 ea			ld de, store_page 
04f6 cd 87 02			call storage_read_block 
04f9			 
04f9 cd 1e 0e			call ishlzero 
04fc ca c7 04			jp z,.se_done 
04ff			 
04ff					if DEBUG_FORTH_WORDS 
04ff						DMARK "ER1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 65 ee			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 66 ee			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 67 ee			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "ER1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518						CALLMONITOR 
0518 cd 6f ee			call debug_vector  
051b				endm  
# End of macro CALLMONITOR
051b					endif 
051b 3a 74 ea			ld a, (store_page)	; get file id 
051e 32 68 ea			ld (store_tmpid), a 
0521			 
0521 3a 76 ea			ld a, (store_page+2)    ; get count of extends 
0524 32 67 ea			ld (store_tmpext), a 
0527			 
0527				; wipe file header 
0527			 
0527 e1				pop hl 
0528 3e 00			ld a, 0 
052a 32 74 ea			ld (store_page), a 
052d 32 75 ea			ld (store_page+1),a 
0530 11 74 ea			ld de, store_page 
0533					if DEBUG_FORTH_WORDS 
0533						DMARK "ER2" 
0533 f5				push af  
0534 3a 48 05			ld a, (.dmark)  
0537 32 65 ee			ld (debug_mark),a  
053a 3a 49 05			ld a, (.dmark+1)  
053d 32 66 ee			ld (debug_mark+1),a  
0540 3a 4a 05			ld a, (.dmark+2)  
0543 32 67 ee			ld (debug_mark+2),a  
0546 18 03			jr .pastdmark  
0548 ..			.dmark: db "ER2"  
054b f1			.pastdmark: pop af  
054c			endm  
# End of macro DMARK
054c						CALLMONITOR 
054c cd 6f ee			call debug_vector  
054f				endm  
# End of macro CALLMONITOR
054f					endif 
054f cd ec 02			call storage_write_block 
0552			 
0552			 
0552				; wipe file extents 
0552			 
0552 3a 67 ea			ld a, (store_tmpext) 
0555 47				ld b, a 
0556			 
0556			.eraext:	  
0556 c5				push bc 
0557			 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a 3a 68 ea			ld a,(store_tmpid) 
055d 5f				ld e, a 
055e 50				ld d, b	 
055f					if DEBUG_FORTH_WORDS 
055f						DMARK "ER3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 65 ee			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 66 ee			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 67 ee			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "ER3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578						CALLMONITOR 
0578 cd 6f ee			call debug_vector  
057b				endm  
# End of macro CALLMONITOR
057b					endif 
057b cd ba 05			call storage_findnextid 
057e cd 1e 0e			call ishlzero 
0581 ca c7 04			jp z,.se_done 
0584			 
0584 e5				push hl 
0585 11 74 ea			ld de, store_page 
0588 cd 87 02			call storage_read_block 
058b			 
058b				; free block	 
058b			 
058b 3e 00			ld a, 0 
058d 32 74 ea			ld (store_page), a 
0590 32 75 ea			ld (store_page+1),a 
0593 11 74 ea			ld de, store_page 
0596 e1				pop hl 
0597					if DEBUG_FORTH_WORDS 
0597						DMARK "ER4" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 65 ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 66 ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 67 ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "ER4"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0						CALLMONITOR 
05b0 cd 6f ee			call debug_vector  
05b3				endm  
# End of macro CALLMONITOR
05b3					endif 
05b3 cd ec 02			call storage_write_block 
05b6			 
05b6 c1				pop bc 
05b7 10 9d			djnz .eraext 
05b9			 
05b9 c9				ret 
05ba			 
05ba			 
05ba			; Find Free Block 
05ba			; --------------- 
05ba			; 
05ba			; With current bank 
05ba			;  
05ba			; From given starting logical block 
05ba			;    Read block  
05ba			;    If no file id 
05ba			;         Return block id 
05ba			 
05ba			 
05ba			; hl starting page number 
05ba			; hl contains free page number or zero if no pages free 
05ba			; e contains the file id to locate 
05ba			; d contains the block number 
05ba			 
05ba			; TODO change to find file id and use zero for free block 
05ba			 
05ba			storage_findnextid: 
05ba			 
05ba				; now locate first 0 page to mark as a free block 
05ba			 
05ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05bc			;	ld hl, STORE_BLOCK_PHY 
05bc			 
05bc					if DEBUG_FORTH_WORDS 
05bc					DMARK "FNI" 
05bc f5				push af  
05bd 3a d1 05			ld a, (.dmark)  
05c0 32 65 ee			ld (debug_mark),a  
05c3 3a d2 05			ld a, (.dmark+1)  
05c6 32 66 ee			ld (debug_mark+1),a  
05c9 3a d3 05			ld a, (.dmark+2)  
05cc 32 67 ee			ld (debug_mark+2),a  
05cf 18 03			jr .pastdmark  
05d1 ..			.dmark: db "FNI"  
05d4 f1			.pastdmark: pop af  
05d5			endm  
# End of macro DMARK
05d5						CALLMONITOR 
05d5 cd 6f ee			call debug_vector  
05d8				endm  
# End of macro CALLMONITOR
05d8					endif 
05d8			.ff1:   	 
05d8 e5					push hl 
05d9 c5					push bc 
05da d5					push de 
05db cd ab 01				call se_readbyte 
05de 5f					ld e,a 
05df 23					inc hl 
05e0 cd ab 01				call se_readbyte 
05e3 57					ld d, a 
05e4 e1					pop hl 
05e5 e5					push hl 
05e6 cd 13 0e				call cmp16 
05e9 28 49				jr z, .fffound 
05eb			 
05eb d1					pop de 
05ec c1					pop bc 
05ed e1					pop hl 
05ee			 
05ee					; is found? 
05ee					;cp e 
05ee					;ret z 
05ee			 
05ee 3e 40				ld a, STORE_BLOCK_PHY 
05f0 cd f5 0d				call addatohl 
05f3 10 e3				djnz .ff1 
05f5			 
05f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f7			.ff2:   	 
05f7			 
05f7 e5					push hl 
05f8 c5					push bc 
05f9 d5					push de 
05fa cd ab 01				call se_readbyte 
05fd 5f					ld e,a 
05fe 23					inc hl 
05ff cd ab 01				call se_readbyte 
0602 57					ld d, a 
0603			 
0603 e1					pop hl 
0604 e5					push hl 
0605 cd 13 0e				call cmp16 
0608 28 2a				jr z, .fffound 
060a			 
060a d1					pop de 
060b c1					pop bc 
060c e1					pop hl 
060d					; is found? 
060d					;cp e 
060d					;ret z 
060d			 
060d 3e 40				ld a, STORE_BLOCK_PHY 
060f cd f5 0d				call addatohl 
0612 10 e3				djnz .ff2 
0614			 
0614			 
0614					if DEBUG_FORTH_WORDS 
0614					DMARK "FN-" 
0614 f5				push af  
0615 3a 29 06			ld a, (.dmark)  
0618 32 65 ee			ld (debug_mark),a  
061b 3a 2a 06			ld a, (.dmark+1)  
061e 32 66 ee			ld (debug_mark+1),a  
0621 3a 2b 06			ld a, (.dmark+2)  
0624 32 67 ee			ld (debug_mark+2),a  
0627 18 03			jr .pastdmark  
0629 ..			.dmark: db "FN-"  
062c f1			.pastdmark: pop af  
062d			endm  
# End of macro DMARK
062d					;	push af 
062d					;	ld a, 'n' 
062d					;	ld (debug_mark),a 
062d					;	pop af 
062d						CALLMONITOR 
062d cd 6f ee			call debug_vector  
0630				endm  
# End of macro CALLMONITOR
0630					endif 
0630				; no free marks! 
0630 21 00 00				ld hl, 0 
0633 c9				ret 
0634			.fffound: 
0634				 
0634			 
0634 d1					pop de 
0635 c1					pop bc 
0636 e1					pop hl 
0637					if DEBUG_FORTH_WORDS 
0637					DMARK "FNF" 
0637 f5				push af  
0638 3a 4c 06			ld a, (.dmark)  
063b 32 65 ee			ld (debug_mark),a  
063e 3a 4d 06			ld a, (.dmark+1)  
0641 32 66 ee			ld (debug_mark+1),a  
0644 3a 4e 06			ld a, (.dmark+2)  
0647 32 67 ee			ld (debug_mark+2),a  
064a 18 03			jr .pastdmark  
064c ..			.dmark: db "FNF"  
064f f1			.pastdmark: pop af  
0650			endm  
# End of macro DMARK
0650					;	push af 
0650					;	ld a, 'n' 
0650					;	ld (debug_mark),a 
0650					;	pop af 
0650						CALLMONITOR 
0650 cd 6f ee			call debug_vector  
0653				endm  
# End of macro CALLMONITOR
0653					endif 
0653 c9				ret 
0654			 
0654			 
0654			 
0654			; Free Space 
0654			; ---------- 
0654			; 
0654			; With current bank 
0654			; 
0654			; Set block count to zero 
0654			; Starting with first logical block 
0654			;      Find free block  
0654			;      If block id given, increment block count 
0654			; 
0654			;  
0654			 
0654			 
0654			; hl contains count of free blocks 
0654			 
0654			storage_freeblocks: 
0654			 
0654				; now locate first 0 page to mark as a free block 
0654			 
0654 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0656 21 40 00			ld hl, STORE_BLOCK_PHY 
0659 11 00 00			ld de, 0 
065c			 
065c			.fb1:   	 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd ab 01				call se_readbyte 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665			 
0665					; is free? 
0665 fe 00				cp 0 
0667 20 01				jr nz, .ff1cont 
0669 13					inc de 
066a			 
066a			.ff1cont: 
066a			 
066a			 
066a 3e 40				ld a, STORE_BLOCK_PHY 
066c cd f5 0d				call addatohl 
066f 10 eb				djnz .fb1 
0671			 
0671 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0673			.fb2:   	 
0673 e5					push hl 
0674 c5					push bc 
0675 d5					push de 
0676 cd ab 01				call se_readbyte 
0679 d1					pop de 
067a c1					pop bc 
067b e1					pop hl 
067c			 
067c					; is free? 
067c fe 00				cp 0 
067e 20 01				jr nz, .ff2cont 
0680 13					inc de 
0681			 
0681			.ff2cont: 
0681			 
0681 3e 40				ld a, STORE_BLOCK_PHY 
0683 cd f5 0d				call addatohl 
0686 10 eb				djnz .fb2 
0688			 
0688 eb				ex de, hl 
0689 c9				ret 
068a			 
068a			; Get File ID 
068a			; ----------- 
068a			; 
068a			; With current bank 
068a			;  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; For each logical block 
068a			;    Read block file id 
068a			;      If first block of file and dont have file id 
068a			;         if file get id and exit 
068a			 
068a			 
068a			 
068a			 
068a			; Create File 
068a			; ----------- 
068a			; 
068a			; With current bank  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; Increment file id number 
068a			; Save Config 
068a			; Find free block 
068a			; Set buffer with file name and file id 
068a			; Write buffer to free block  
068a			 
068a			 
068a			; hl point to file name 
068a			; hl returns file id 
068a			 
068a			; file format: 
068a			; byte 0 - file id 
068a			; byte 1 - extent number 
068a			; byte 2-> data 
068a			 
068a			; format for extent number 0: 
068a			; 
068a			; byte 0 - file id 
068a			; byte 1 - extent 0 
068a			; byte 2 - extent count 
068a			; byte 3 -> file name and meta data 
068a			 
068a			 
068a			storage_create: 
068a				if DEBUG_STORESE 
068a					DMARK "SCR" 
068a f5				push af  
068b 3a 9f 06			ld a, (.dmark)  
068e 32 65 ee			ld (debug_mark),a  
0691 3a a0 06			ld a, (.dmark+1)  
0694 32 66 ee			ld (debug_mark+1),a  
0697 3a a1 06			ld a, (.dmark+2)  
069a 32 67 ee			ld (debug_mark+2),a  
069d 18 03			jr .pastdmark  
069f ..			.dmark: db "SCR"  
06a2 f1			.pastdmark: pop af  
06a3			endm  
# End of macro DMARK
06a3					CALLMONITOR 
06a3 cd 6f ee			call debug_vector  
06a6				endm  
# End of macro CALLMONITOR
06a6				endif 
06a6			 
06a6 e5				push hl		; save file name pointer 
06a7			 
06a7 cd 38 03			call storage_get_block_0 
06aa			 
06aa 3a 74 ea			ld a,(store_page)	; get current file id 
06ad 3c				inc a 
06ae 32 74 ea			ld (store_page),a 
06b1				 
06b1 32 68 ea			ld (store_tmpid),a			; save id 
06b4			 
06b4 21 00 00			ld hl, 0 
06b7 11 74 ea			ld de, store_page 
06ba				if DEBUG_STORESE 
06ba					DMARK "SCw" 
06ba f5				push af  
06bb 3a cf 06			ld a, (.dmark)  
06be 32 65 ee			ld (debug_mark),a  
06c1 3a d0 06			ld a, (.dmark+1)  
06c4 32 66 ee			ld (debug_mark+1),a  
06c7 3a d1 06			ld a, (.dmark+2)  
06ca 32 67 ee			ld (debug_mark+2),a  
06cd 18 03			jr .pastdmark  
06cf ..			.dmark: db "SCw"  
06d2 f1			.pastdmark: pop af  
06d3			endm  
# End of macro DMARK
06d3					CALLMONITOR 
06d3 cd 6f ee			call debug_vector  
06d6				endm  
# End of macro CALLMONITOR
06d6				endif 
06d6 cd ec 02			call storage_write_block	 ; save update 
06d9			 
06d9				if DEBUG_STORESE 
06d9 11 74 ea				ld de, store_page 
06dc					DMARK "SCC" 
06dc f5				push af  
06dd 3a f1 06			ld a, (.dmark)  
06e0 32 65 ee			ld (debug_mark),a  
06e3 3a f2 06			ld a, (.dmark+1)  
06e6 32 66 ee			ld (debug_mark+1),a  
06e9 3a f3 06			ld a, (.dmark+2)  
06ec 32 67 ee			ld (debug_mark+2),a  
06ef 18 03			jr .pastdmark  
06f1 ..			.dmark: db "SCC"  
06f4 f1			.pastdmark: pop af  
06f5			endm  
# End of macro DMARK
06f5					CALLMONITOR 
06f5 cd 6f ee			call debug_vector  
06f8				endm  
# End of macro CALLMONITOR
06f8				endif 
06f8				;  
06f8				 
06f8 21 40 00			ld hl, STORE_BLOCK_PHY 
06fb 11 00 00			ld de, 0 
06fe cd ba 05			call storage_findnextid 
0701			 
0701 22 5f ea			ld (store_tmppageid), hl    ; save page to use  
0704			 
0704				; TODO detect 0 = no spare blocks 
0704			 
0704				; hl now contains the free page to use for the file header page 
0704			 
0704				if DEBUG_STORESE 
0704				DMARK "SCF" 
0704 f5				push af  
0705 3a 19 07			ld a, (.dmark)  
0708 32 65 ee			ld (debug_mark),a  
070b 3a 1a 07			ld a, (.dmark+1)  
070e 32 66 ee			ld (debug_mark+1),a  
0711 3a 1b 07			ld a, (.dmark+2)  
0714 32 67 ee			ld (debug_mark+2),a  
0717 18 03			jr .pastdmark  
0719 ..			.dmark: db "SCF"  
071c f1			.pastdmark: pop af  
071d			endm  
# End of macro DMARK
071d					CALLMONITOR 
071d cd 6f ee			call debug_vector  
0720				endm  
# End of macro CALLMONITOR
0720				endif 
0720			 
0720 22 5f ea			ld (store_tmppageid), hl 
0723				 
0723 3a 68 ea			ld a,(store_tmpid)    ; get file id 
0726			;	ld a, (store_filecache)			; save to cache 
0726			 
0726 32 74 ea			ld (store_page),a    ; set page id 
0729 3e 00			ld a, 0			 ; extent 0 is file header 
072b 32 75 ea			ld (store_page+1), a   ; set file extent 
072e			 
072e 32 76 ea			ld (store_page+2), a   ; extent count for the file 
0731			 
0731			;	inc hl 		; init block 0 of file 
0731			;	inc hl   		; skip file and extent id 
0731			 ;       ld a, 0 
0731			;	ld (hl),a 
0731			;	ld a, (store_filecache+1)  	; save to cache 
0731			 
0731			;	inc hl    ; file name 
0731				 
0731				 
0731 11 77 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0734				if DEBUG_STORESE 
0734					DMARK "SCc" 
0734 f5				push af  
0735 3a 49 07			ld a, (.dmark)  
0738 32 65 ee			ld (debug_mark),a  
073b 3a 4a 07			ld a, (.dmark+1)  
073e 32 66 ee			ld (debug_mark+1),a  
0741 3a 4b 07			ld a, (.dmark+2)  
0744 32 67 ee			ld (debug_mark+2),a  
0747 18 03			jr .pastdmark  
0749 ..			.dmark: db "SCc"  
074c f1			.pastdmark: pop af  
074d			endm  
# End of macro DMARK
074d					CALLMONITOR 
074d cd 6f ee			call debug_vector  
0750				endm  
# End of macro CALLMONITOR
0750				endif 
0750 e1				pop hl    ; get zero term string 
0751 e5				push hl 
0752 3e 00			ld a, 0 
0754 cd 66 11			call strlent 
0757 23				inc hl   ; cover zero term 
0758 06 00			ld b,0 
075a 4d				ld c,l 
075b e1				pop hl 
075c				;ex de, hl 
075c				if DEBUG_STORESE 
075c					DMARK "SCa" 
075c f5				push af  
075d 3a 71 07			ld a, (.dmark)  
0760 32 65 ee			ld (debug_mark),a  
0763 3a 72 07			ld a, (.dmark+1)  
0766 32 66 ee			ld (debug_mark+1),a  
0769 3a 73 07			ld a, (.dmark+2)  
076c 32 67 ee			ld (debug_mark+2),a  
076f 18 03			jr .pastdmark  
0771 ..			.dmark: db "SCa"  
0774 f1			.pastdmark: pop af  
0775			endm  
# End of macro DMARK
0775					;push af 
0775					;ld a, 'a' 
0775					;ld (debug_mark),a 
0775					;pop af 
0775					CALLMONITOR 
0775 cd 6f ee			call debug_vector  
0778				endm  
# End of macro CALLMONITOR
0778				endif 
0778 ed b0			ldir    ; copy zero term string 
077a				if DEBUG_STORESE 
077a					DMARK "SCA" 
077a f5				push af  
077b 3a 8f 07			ld a, (.dmark)  
077e 32 65 ee			ld (debug_mark),a  
0781 3a 90 07			ld a, (.dmark+1)  
0784 32 66 ee			ld (debug_mark+1),a  
0787 3a 91 07			ld a, (.dmark+2)  
078a 32 67 ee			ld (debug_mark+2),a  
078d 18 03			jr .pastdmark  
078f ..			.dmark: db "SCA"  
0792 f1			.pastdmark: pop af  
0793			endm  
# End of macro DMARK
0793					CALLMONITOR 
0793 cd 6f ee			call debug_vector  
0796				endm  
# End of macro CALLMONITOR
0796				endif 
0796			 
0796				; write file header page 
0796			 
0796 2a 5f ea			ld hl,(store_tmppageid) 
0799 11 74 ea			ld de, store_page 
079c				if DEBUG_STORESE 
079c					DMARK "SCb" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 65 ee			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 66 ee			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 67 ee			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCb"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					;push af 
07b5					;ld a, 'b' 
07b5					;ld (debug_mark),a 
07b5					;pop af 
07b5					CALLMONITOR 
07b5 cd 6f ee			call debug_vector  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 cd ec 02			call storage_write_block 
07bb			 
07bb 3a 68 ea			ld a, (store_tmpid) 
07be 6f				ld l, a 
07bf 26 00			ld h,0 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCz" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 65 ee			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 66 ee			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 67 ee			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCz"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					CALLMONITOR 
07da cd 6f ee			call debug_vector  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd c9				ret 
07de				 
07de			 
07de			 
07de			; 
07de			; Read File 
07de			; 
07de			; h - file id to locate 
07de			; l - extent to locate 
07de			; de - pointer to string to read into 
07de			; 
07de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07de			 
07de			.sr_fail: 
07de d1				pop de 
07df c9				ret 
07e0			 
07e0			storage_read: 
07e0			 
07e0			 
07e0 d5				push de 
07e1			 
07e1			; TODO BUG the above push is it popped before the RET Z? 
07e1			 
07e1			; TODO how to handle multiple part blocks 
07e1			 
07e1				; locate file extent to read 
07e1			 
07e1 5c				ld e, h 
07e2 55				ld d, l 
07e3			 
07e3			.srext: 
07e3 22 72 ea			ld (store_readptr), hl     ; save the current extent to load 
07e6 ed 53 70 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07ea			 
07ea 21 40 00			ld hl, STORE_BLOCK_PHY 
07ed				if DEBUG_STORESE 
07ed					DMARK "sre" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 65 ee			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 66 ee			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 67 ee			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "sre"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 6f ee			call debug_vector  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809 cd ba 05			call storage_findnextid 
080c			 
080c				if DEBUG_STORESE 
080c					DMARK "srf" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 65 ee			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 66 ee			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 67 ee			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "srf"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					CALLMONITOR 
0825 cd 6f ee			call debug_vector  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 1e 0e			call ishlzero 
082b			;	ld a, l 
082b			;	add h 
082b			;	cp 0 
082b 28 b1			jr z,.sr_fail			; block not found so EOF 
082d			 
082d				; save current address for use by higher level words etc 
082d			 
082d 22 65 ea			ld (store_openaddr),hl 
0830			 
0830			 
0830				; hl contains page number to load 
0830 d1				pop de   ; get storage 
0831 ed 53 70 ea		ld (store_readbuf), de     ; current buffer to load in to 
0835 d5				push de 
0836				if DEBUG_STORESE 
0836					DMARK "srg" 
0836 f5				push af  
0837 3a 4b 08			ld a, (.dmark)  
083a 32 65 ee			ld (debug_mark),a  
083d 3a 4c 08			ld a, (.dmark+1)  
0840 32 66 ee			ld (debug_mark+1),a  
0843 3a 4d 08			ld a, (.dmark+2)  
0846 32 67 ee			ld (debug_mark+2),a  
0849 18 03			jr .pastdmark  
084b ..			.dmark: db "srg"  
084e f1			.pastdmark: pop af  
084f			endm  
# End of macro DMARK
084f					CALLMONITOR 
084f cd 6f ee			call debug_vector  
0852				endm  
# End of macro CALLMONITOR
0852				endif 
0852 cd 87 02			call storage_read_block 
0855			 
0855				; if this a continuation read??? 
0855			 
0855 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0858			 
0858 3e 3f			ld a, STORE_BLOCK_PHY-1 
085a cd f5 0d			call addatohl 
085d 7e				ld a,(hl) 
085e fe 00			cp 0 
0860 28 02			jr z, .markiscont 
0862 3e ff			ld a, 255 
0864			 
0864			.markiscont: 
0864 32 67 ea			ld (store_readcont), a 
0867			 
0867				if DEBUG_STORESE 
0867					DMARK "srC" 
0867 f5				push af  
0868 3a 7c 08			ld a, (.dmark)  
086b 32 65 ee			ld (debug_mark),a  
086e 3a 7d 08			ld a, (.dmark+1)  
0871 32 66 ee			ld (debug_mark+1),a  
0874 3a 7e 08			ld a, (.dmark+2)  
0877 32 67 ee			ld (debug_mark+2),a  
087a 18 03			jr .pastdmark  
087c ..			.dmark: db "srC"  
087f f1			.pastdmark: pop af  
0880			endm  
# End of macro DMARK
0880					CALLMONITOR 
0880 cd 6f ee			call debug_vector  
0883				endm  
# End of macro CALLMONITOR
0883				endif 
0883				; only short reads enabled 
0883			 
0883 3a 6f ea			ld a, (store_longread) 
0886 fe 00			cp 0 
0888 ca 55 09			jp z, .readdone 
088b			 
088b			; TODO if block has no zeros then need to read next block  
088b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
088b			; check last byte of physical block. 
088b			; if not zero then the next block needs to be loaded 
088b			 
088b			 
088b 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
088e			 
088e 3e 3f			ld a, STORE_BLOCK_PHY-1 
0890 cd f5 0d			call addatohl 
0893				;dec hl 
0893 7e				ld a,(hl) 
0894				if DEBUG_STORESE 
0894					DMARK "sr?" 
0894 f5				push af  
0895 3a a9 08			ld a, (.dmark)  
0898 32 65 ee			ld (debug_mark),a  
089b 3a aa 08			ld a, (.dmark+1)  
089e 32 66 ee			ld (debug_mark+1),a  
08a1 3a ab 08			ld a, (.dmark+2)  
08a4 32 67 ee			ld (debug_mark+2),a  
08a7 18 03			jr .pastdmark  
08a9 ..			.dmark: db "sr?"  
08ac f1			.pastdmark: pop af  
08ad			endm  
# End of macro DMARK
08ad					CALLMONITOR 
08ad cd 6f ee			call debug_vector  
08b0				endm  
# End of macro CALLMONITOR
08b0				endif 
08b0 fe 00			cp 0 
08b2 ca 55 09			jp z, .readdone 
08b5			 
08b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08b5			 
08b5 23				inc hl 
08b6			 
08b6 22 70 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08b9			 
08b9 ed 5b 72 ea		ld de, (store_readptr)     ; save the current extent to load 
08bd			 
08bd eb				ex de, hl 
08be			 
08be				; next ext 
08be			 
08be 23				inc hl 
08bf 22 72 ea			ld  (store_readptr), hl     ; save the current extent to load 
08c2			 
08c2				if DEBUG_STORESE 
08c2					DMARK "sF2" 
08c2 f5				push af  
08c3 3a d7 08			ld a, (.dmark)  
08c6 32 65 ee			ld (debug_mark),a  
08c9 3a d8 08			ld a, (.dmark+1)  
08cc 32 66 ee			ld (debug_mark+1),a  
08cf 3a d9 08			ld a, (.dmark+2)  
08d2 32 67 ee			ld (debug_mark+2),a  
08d5 18 03			jr .pastdmark  
08d7 ..			.dmark: db "sF2"  
08da f1			.pastdmark: pop af  
08db			endm  
# End of macro DMARK
08db					CALLMONITOR 
08db cd 6f ee			call debug_vector  
08de				endm  
# End of macro CALLMONITOR
08de				endif 
08de			 
08de				; get and load block 
08de			 
08de cd ba 05			call storage_findnextid 
08e1			 
08e1				if DEBUG_STORESE 
08e1					DMARK "sf2" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 65 ee			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 66 ee			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 67 ee			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "sf2"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd 6f ee			call debug_vector  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd cd 1e 0e			call ishlzero 
0900			;	ld a, l 
0900			;	add h 
0900			;	cp 0 
0900 ca de 07			jp z,.sr_fail			; block not found so EOF 
0903				 
0903				; save current address for use by higher level words etc 
0903			 
0903 22 65 ea			ld (store_openaddr),hl 
0906			 
0906 cd 87 02			call storage_read_block 
0909			 
0909				; on a continuation block, we now have the file id and ext in the middle of the block 
0909				; we need to pull everything back  
0909			 
0909 ed 5b 70 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
090d 2a 70 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0910 23				inc hl 
0911 23				inc hl     ; skip id and ext 
0912 01 40 00			ld bc, STORE_BLOCK_PHY 
0915				if DEBUG_STORESE 
0915					DMARK "SR<" 
0915 f5				push af  
0916 3a 2a 09			ld a, (.dmark)  
0919 32 65 ee			ld (debug_mark),a  
091c 3a 2b 09			ld a, (.dmark+1)  
091f 32 66 ee			ld (debug_mark+1),a  
0922 3a 2c 09			ld a, (.dmark+2)  
0925 32 67 ee			ld (debug_mark+2),a  
0928 18 03			jr .pastdmark  
092a ..			.dmark: db "SR<"  
092d f1			.pastdmark: pop af  
092e			endm  
# End of macro DMARK
092e					CALLMONITOR 
092e cd 6f ee			call debug_vector  
0931				endm  
# End of macro CALLMONITOR
0931				endif 
0931 ed b0			ldir     ; copy data 
0933			 
0933				; move the pointer back and pretend we have a full buffer for next recheck 
0933			 
0933 1b				dec de 
0934 1b				dec de 
0935			 
0935			; TODO do pop below now short circuit loop????? 
0935 c1				pop bc     ; get rid of spare de on stack 
0936				if DEBUG_STORESE 
0936					DMARK "SR>" 
0936 f5				push af  
0937 3a 4b 09			ld a, (.dmark)  
093a 32 65 ee			ld (debug_mark),a  
093d 3a 4c 09			ld a, (.dmark+1)  
0940 32 66 ee			ld (debug_mark+1),a  
0943 3a 4d 09			ld a, (.dmark+2)  
0946 32 67 ee			ld (debug_mark+2),a  
0949 18 03			jr .pastdmark  
094b ..			.dmark: db "SR>"  
094e f1			.pastdmark: pop af  
094f			endm  
# End of macro DMARK
094f					CALLMONITOR 
094f cd 6f ee			call debug_vector  
0952				endm  
# End of macro CALLMONITOR
0952				endif 
0952 c3 e3 07			jp .srext 
0955			 
0955			 
0955			 
0955			 
0955			 
0955			.readdone:		 
0955 e1				pop hl 		 ; return start of data to show as not EOF 
0956 23				inc hl   ; past file id 
0957 23				inc hl   ; past ext 
0958				if DEBUG_STORESE 
0958					DMARK "SRe" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 65 ee			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 66 ee			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 67 ee			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SRe"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd 6f ee			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974 c9					ret 
0975			 
0975			 
0975			 
0975			; 
0975			; Append File 
0975			; 
0975			; hl - file id to locate 
0975			; de - pointer to (multi block) string to write 
0975			 
0975			.sa_notfound: 
0975 d1				pop de 
0976 c9				ret 
0977			 
0977			 
0977			storage_append: 
0977				; hl -  file id to append to 
0977				; de - string to append 
0977			 
0977 d5				push de 
0978				 
0978				if DEBUG_STORESE 
0978					DMARK "AP1" 
0978 f5				push af  
0979 3a 8d 09			ld a, (.dmark)  
097c 32 65 ee			ld (debug_mark),a  
097f 3a 8e 09			ld a, (.dmark+1)  
0982 32 66 ee			ld (debug_mark+1),a  
0985 3a 8f 09			ld a, (.dmark+2)  
0988 32 67 ee			ld (debug_mark+2),a  
098b 18 03			jr .pastdmark  
098d ..			.dmark: db "AP1"  
0990 f1			.pastdmark: pop af  
0991			endm  
# End of macro DMARK
0991					CALLMONITOR 
0991 cd 6f ee			call debug_vector  
0994				endm  
# End of macro CALLMONITOR
0994				endif 
0994			 
0994 7d				ld a, l 
0995 32 68 ea			ld (store_tmpid), a 
0998			 
0998				; get file header  
0998			 
0998 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
099a 3a 68 ea			ld a, (store_tmpid) 
099d 5f				ld e, a 
099e			 
099e 21 40 00				ld hl, STORE_BLOCK_PHY 
09a1 cd ba 05				call storage_findnextid 
09a4			 
09a4 cd 1e 0e			call ishlzero 
09a7 28 cc			jr z, .sa_notfound 
09a9			 
09a9 22 5f ea			ld (store_tmppageid), hl 
09ac			 
09ac				; TODO handle file id not found 
09ac			 
09ac				if DEBUG_STORESE 
09ac					DMARK "AP2" 
09ac f5				push af  
09ad 3a c1 09			ld a, (.dmark)  
09b0 32 65 ee			ld (debug_mark),a  
09b3 3a c2 09			ld a, (.dmark+1)  
09b6 32 66 ee			ld (debug_mark+1),a  
09b9 3a c3 09			ld a, (.dmark+2)  
09bc 32 67 ee			ld (debug_mark+2),a  
09bf 18 03			jr .pastdmark  
09c1 ..			.dmark: db "AP2"  
09c4 f1			.pastdmark: pop af  
09c5			endm  
# End of macro DMARK
09c5					CALLMONITOR 
09c5 cd 6f ee			call debug_vector  
09c8				endm  
# End of macro CALLMONITOR
09c8				endif 
09c8			 
09c8				; update file extent count 
09c8			 
09c8 11 74 ea			ld de, store_page 
09cb			 
09cb cd 87 02			call storage_read_block 
09ce			 
09ce				if DEBUG_STORESE 
09ce					DMARK "AP3" 
09ce f5				push af  
09cf 3a e3 09			ld a, (.dmark)  
09d2 32 65 ee			ld (debug_mark),a  
09d5 3a e4 09			ld a, (.dmark+1)  
09d8 32 66 ee			ld (debug_mark+1),a  
09db 3a e5 09			ld a, (.dmark+2)  
09de 32 67 ee			ld (debug_mark+2),a  
09e1 18 03			jr .pastdmark  
09e3 ..			.dmark: db "AP3"  
09e6 f1			.pastdmark: pop af  
09e7			endm  
# End of macro DMARK
09e7					CALLMONITOR 
09e7 cd 6f ee			call debug_vector  
09ea				endm  
# End of macro CALLMONITOR
09ea				endif 
09ea			;	ld (store_tmppageid), hl 
09ea			 
09ea 3a 76 ea			ld a, (store_page+2) 
09ed 3c				inc a 
09ee 32 76 ea			ld (store_page+2), a 
09f1 32 67 ea			ld (store_tmpext), a 
09f4				 
09f4				if DEBUG_STORESE 
09f4					DMARK "AP3" 
09f4 f5				push af  
09f5 3a 09 0a			ld a, (.dmark)  
09f8 32 65 ee			ld (debug_mark),a  
09fb 3a 0a 0a			ld a, (.dmark+1)  
09fe 32 66 ee			ld (debug_mark+1),a  
0a01 3a 0b 0a			ld a, (.dmark+2)  
0a04 32 67 ee			ld (debug_mark+2),a  
0a07 18 03			jr .pastdmark  
0a09 ..			.dmark: db "AP3"  
0a0c f1			.pastdmark: pop af  
0a0d			endm  
# End of macro DMARK
0a0d					CALLMONITOR 
0a0d cd 6f ee			call debug_vector  
0a10				endm  
# End of macro CALLMONITOR
0a10				endif 
0a10 2a 5f ea			ld hl, (store_tmppageid) 
0a13 11 74 ea			ld de, store_page 
0a16 cd ec 02			call storage_write_block 
0a19			 
0a19				; find free block 
0a19			 
0a19 11 00 00			ld de, 0			 ; file extent to locate 
0a1c			 
0a1c 21 40 00				ld hl, STORE_BLOCK_PHY 
0a1f cd ba 05				call storage_findnextid 
0a22 cd 1e 0e			call ishlzero 
0a25 ca 75 09			jp z, .sa_notfound 
0a28			 
0a28					; TODO handle no space left 
0a28					 
0a28 22 5f ea				ld (store_tmppageid), hl 
0a2b			 
0a2b				if DEBUG_STORESE 
0a2b					DMARK "AP4" 
0a2b f5				push af  
0a2c 3a 40 0a			ld a, (.dmark)  
0a2f 32 65 ee			ld (debug_mark),a  
0a32 3a 41 0a			ld a, (.dmark+1)  
0a35 32 66 ee			ld (debug_mark+1),a  
0a38 3a 42 0a			ld a, (.dmark+2)  
0a3b 32 67 ee			ld (debug_mark+2),a  
0a3e 18 03			jr .pastdmark  
0a40 ..			.dmark: db "AP4"  
0a43 f1			.pastdmark: pop af  
0a44			endm  
# End of macro DMARK
0a44					CALLMONITOR 
0a44 cd 6f ee			call debug_vector  
0a47				endm  
# End of macro CALLMONITOR
0a47				endif 
0a47					; init the buffer with zeros so we can id if the buffer is full or not 
0a47			 
0a47 e5					push hl 
0a48 c5					push bc 
0a49			 
0a49 21 74 ea				ld hl, store_page 
0a4c 06 40				ld b, STORE_BLOCK_PHY 
0a4e 3e 00				ld a, 0 
0a50 77			.zeroblock:	ld (hl), a 
0a51 23					inc hl 
0a52 10 fc				djnz .zeroblock 
0a54			 
0a54 c1					pop bc 
0a55 e1					pop hl 
0a56			 
0a56					; construct block 
0a56			 
0a56 3a 68 ea				ld a, (store_tmpid) 
0a59 32 74 ea				ld (store_page), a   ; file id 
0a5c 3a 67 ea				ld a, (store_tmpext)   ; extent for this block 
0a5f 32 75 ea				ld (store_page+1), a 
0a62			 
0a62 e1					pop hl    ; get string to write 
0a63 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a65 11 76 ea				ld de, store_page+2 
0a68			 
0a68				if DEBUG_STORESE 
0a68					DMARK "AP5" 
0a68 f5				push af  
0a69 3a 7d 0a			ld a, (.dmark)  
0a6c 32 65 ee			ld (debug_mark),a  
0a6f 3a 7e 0a			ld a, (.dmark+1)  
0a72 32 66 ee			ld (debug_mark+1),a  
0a75 3a 7f 0a			ld a, (.dmark+2)  
0a78 32 67 ee			ld (debug_mark+2),a  
0a7b 18 03			jr .pastdmark  
0a7d ..			.dmark: db "AP5"  
0a80 f1			.pastdmark: pop af  
0a81			endm  
# End of macro DMARK
0a81					CALLMONITOR 
0a81 cd 6f ee			call debug_vector  
0a84				endm  
# End of macro CALLMONITOR
0a84				endif 
0a84			 
0a84			 
0a84			 
0a84					; fill buffer with data until end of string or full block 
0a84			 
0a84 7e			.appd:		ld a, (hl) 
0a85 12					ld (de), a 
0a86 fe 00				cp 0 
0a88 28 04				jr z, .appdone 
0a8a 23					inc hl 
0a8b 13					inc de 
0a8c 10 f6				djnz .appd 
0a8e			 
0a8e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a8f f5					push af   		; save last byte dumped 
0a90			 
0a90			 
0a90 2a 5f ea			ld hl, (store_tmppageid) 
0a93 11 74 ea			ld de, store_page 
0a96				if DEBUG_STORESE 
0a96					DMARK "AP6" 
0a96 f5				push af  
0a97 3a ab 0a			ld a, (.dmark)  
0a9a 32 65 ee			ld (debug_mark),a  
0a9d 3a ac 0a			ld a, (.dmark+1)  
0aa0 32 66 ee			ld (debug_mark+1),a  
0aa3 3a ad 0a			ld a, (.dmark+2)  
0aa6 32 67 ee			ld (debug_mark+2),a  
0aa9 18 03			jr .pastdmark  
0aab ..			.dmark: db "AP6"  
0aae f1			.pastdmark: pop af  
0aaf			endm  
# End of macro DMARK
0aaf					CALLMONITOR 
0aaf cd 6f ee			call debug_vector  
0ab2				endm  
# End of macro CALLMONITOR
0ab2				endif 
0ab2 cd ec 02				call storage_write_block 
0ab5			 
0ab5			 
0ab5				; was that a full block of data written? 
0ab5				; any more to write out? 
0ab5			 
0ab5				; if yes then set vars and jump to start of function again 
0ab5			 
0ab5 f1					pop af 
0ab6 d1					pop de 
0ab7			 
0ab7 fe 00				cp 0		 ; no, string was fully written 
0ab9 c8					ret z 
0aba			 
0aba					; setup vars for next cycle 
0aba			 
0aba 3a 68 ea				ld a, (store_tmpid) 
0abd 6f					ld l, a 
0abe 26 00				ld h, 0 
0ac0			 
0ac0 c3 77 09			 	jp storage_append	 ; yes, need to write out some more 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			if DEBUG_STORECF 
0ac3			storageput:	 
0ac3					ret 
0ac3			storageread: 
0ac3					ld hl, store_page 
0ac3					ld b, 200 
0ac3					ld a,0 
0ac3			.src:		ld (hl),a 
0ac3					inc hl 
0ac3					djnz .src 
0ac3					 
0ac3			 
0ac3					ld de, 0 
0ac3					ld bc, 1 
0ac3					ld hl, store_page 
0ac3					call cfRead 
0ac3			 
0ac3				call cfGetError 
0ac3				ld hl,scratch 
0ac3				call hexout 
0ac3				ld hl, scratch+2 
0ac3				ld a, 0 
0ac3				ld (hl),a 
0ac3				ld de, scratch 
0ac3				ld a,display_row_1 
0ac3				call str_at_display 
0ac3				call update_display 
0ac3			 
0ac3					ld hl, store_page 
0ac3					ld (os_cur_ptr),hl 
0ac3			 
0ac3					ret 
0ac3			endif 
0ac3			 
0ac3			 
0ac3			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ac3			 
0ac3			storage_clear_page: 
0ac3 e5				push hl 
0ac4 d5				push de 
0ac5 c5				push bc 
0ac6 21 74 ea			ld hl, store_page 
0ac9 3e 00			ld a, 0 
0acb 77				ld (hl), a 
0acc			 
0acc 11 75 ea			ld de, store_page+1 
0acf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ad2			 
0ad2 ed b0			ldir 
0ad4				 
0ad4 c1				pop bc 
0ad5 d1				pop de 
0ad6 e1				pop hl 
0ad7 c9				ret 
0ad8			 
0ad8			; eof 
# End of file firmware_storage.asm
0ad8			  
0ad8			; support routines for above hardware abstraction layer  
0ad8			  
0ad8			include "firmware_general.asm"        ; general support functions  
0ad8			 
0ad8			; word look up 
0ad8			 
0ad8			; in 
0ad8			; a is the index 
0ad8			; hl is pointer start of array 
0ad8			; 
0ad8			; returns 
0ad8			; hl to the word 
0ad8			; 
0ad8			 
0ad8			table_lookup:  
0ad8 d5					push de 
0ad9 eb					ex de, hl 
0ada			 
0ada 6f					ld l, a 
0adb 26 00				ld h, 0 
0add 29					add hl, hl 
0ade 19					add hl, de 
0adf 7e					ld a, (hl) 
0ae0 23					inc hl 
0ae1 66					ld h,(hl) 
0ae2 6f					ld l, a 
0ae3			 
0ae3 d1					pop de 
0ae4 c9					ret 
0ae5			 
0ae5			; Delay loops 
0ae5			 
0ae5			 
0ae5			 
0ae5			aDelayInMS: 
0ae5 c5				push bc 
0ae6 47				ld b,a 
0ae7			msdelay: 
0ae7 c5				push bc 
0ae8				 
0ae8			 
0ae8 01 41 00			ld bc,041h 
0aeb cd 03 0b			call delayloop 
0aee c1				pop bc 
0aef 05				dec b 
0af0 20 f5			jr nz,msdelay 
0af2			 
0af2			;if CPU_CLOCK_8MHZ 
0af2			;msdelay8: 
0af2			;	push bc 
0af2			;	 
0af2			; 
0af2			;	ld bc,041h 
0af2			;	call delayloop 
0af2			;	pop bc 
0af2			;	dec b 
0af2			;	jr nz,msdelay8 
0af2			;endif 
0af2			 
0af2			 
0af2 c1				pop bc 
0af3 c9				ret 
0af4			 
0af4			 
0af4			delay250ms: 
0af4				;push de 
0af4 01 00 40			ld bc, 04000h 
0af7 c3 03 0b			jp delayloop 
0afa			delay500ms: 
0afa				;push de 
0afa 01 00 80			ld bc, 08000h 
0afd c3 03 0b			jp delayloop 
0b00			delay1s: 
0b00				;push bc 
0b00			   ; Clobbers A, d and e 
0b00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b03			delayloop: 
0b03 c5			    push bc 
0b04			 
0b04			if BASE_CPM 
0b04 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0b07			.cpmloop: 
0b07 c5				push bc 
0b08			 
0b08			endif 
0b08			 
0b08			 
0b08			 
0b08			delayloopi: 
0b08			;	push bc 
0b08			;.dl: 
0b08 cb 47		    bit     0,a    	; 8 
0b0a cb 47		    bit     0,a    	; 8 
0b0c cb 47		    bit     0,a    	; 8 
0b0e e6 ff		    and     255  	; 7 
0b10 0b			    dec     bc      	; 6 
0b11 79			    ld      a,c     	; 4 
0b12 b0			    or      b     	; 4 
0b13 c2 08 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b16			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b16				;pop de 
0b16			;pop bc 
0b16			 
0b16			if BASE_CPM 
0b16 c1				pop bc 
0b17				 
0b17 0b			    dec     bc      	; 6 
0b18 79			    ld      a,c     	; 4 
0b19 b0			    or      b     	; 4 
0b1a c2 07 0b		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b1d				 
0b1d			 
0b1d			endif 
0b1d			;if CPU_CLOCK_8MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d			 
0b1d			;if CPU_CLOCK_10MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d c1			    pop bc 
0b1e			 
0b1e c9				ret 
0b1f			 
0b1f			 
0b1f			 
0b1f			; eof 
# End of file firmware_general.asm
0b1f			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b1f			; display routines that use the physical hardware abstraction layer 
0b1f			 
0b1f			 
0b1f			; Display an activity indicator 
0b1f			; Each call returns the new char pointed to in hl 
0b1f			 
0b1f			active: 
0b1f 3a c0 eb			ld a, (display_active) 
0b22 fe 06			cp 6 
0b24			 
0b24 20 02			jr nz, .sne 
0b26				; gone past the last one reset sequence 
0b26 3e ff			ld a, 255 
0b28			 
0b28			.sne:   
0b28				; get the next char in seq 
0b28 3c				inc a 
0b29 32 c0 eb			ld (display_active), a 
0b2c			 
0b2c				; look up the string in the table 
0b2c 21 43 0b			ld hl, actseq 
0b2f cb 27			sla a 
0b31 cd f5 0d			call addatohl 
0b34 cd 02 1f			call loadwordinhl 
0b37			 
0b37				; forth will write the to string when pushing so move from rom to ram 
0b37			 
0b37 11 c1 eb			ld de, display_active+1 
0b3a 01 02 00			ld bc, 2 
0b3d ed b0			ldir 
0b3f			 
0b3f 21 c1 eb			ld hl, display_active+1 
0b42 c9				ret 
0b43				 
0b43				 
0b43			 
0b43			 
0b43			;db "|/-\|-\" 
0b43			 
0b43			actseq: 
0b43			 
0b43 51 0b		dw spin0 
0b45 53 0b		dw spin1 
0b47 55 0b		dw spin2 
0b49 57 0b		dw spin3 
0b4b 55 0b		dw spin2 
0b4d 53 0b		dw spin1 
0b4f 51 0b		dw spin0 
0b51			 
0b51 .. 00		spin0: db " ", 0 
0b53 .. 00		spin1: db "-", 0 
0b55 .. 00		spin2: db "+", 0 
0b57 .. 00		spin3: db "#", 0 
0b59			 
0b59			 
0b59			; information window 
0b59			 
0b59			; pass hl with 1st string to display 
0b59			; pass de with 2nd string to display 
0b59			 
0b59			info_panel: 
0b59 e5				push hl 
0b5a			 
0b5a 2a c6 eb			ld hl, (display_fb_active) 
0b5d e5				push hl    ; future de destination 
0b5e 21 ab ed				ld hl, display_fb0 
0b61 22 c6 eb				ld (display_fb_active), hl 
0b64			 
0b64			;	call clear_display 
0b64			 
0b64				if BASE_CPM 
0b64 3e 2e			ld a, '.' 
0b66				else 
0b66				ld a, 165 
0b66				endif 
0b66 cd cd 0b			call fill_display 
0b69			 
0b69			 
0b69 3e 55			ld a, display_row_3 + 5 
0b6b cd db 0b			call str_at_display 
0b6e			 
0b6e e1				pop hl 
0b6f d1				pop de 
0b70			 
0b70 e5				push hl 
0b71			 
0b71			 
0b71 3e 2d			ld a, display_row_2 + 5 
0b73 cd db 0b			call str_at_display 
0b76			 
0b76			 
0b76 cd eb 0b			call update_display 
0b79 cd 08 1b			call next_page_prompt 
0b7c cd c8 0b			call clear_display 
0b7f			 
0b7f				 
0b7f 21 0a ed				ld hl, display_fb1 
0b82 22 c6 eb				ld (display_fb_active), hl 
0b85 cd eb 0b			call update_display 
0b88			 
0b88 e1				pop hl 
0b89			 
0b89 c9				ret 
0b8a			 
0b8a			 
0b8a			 
0b8a			 
0b8a			; TODO windowing? 
0b8a			 
0b8a			; TODO scroll line up 
0b8a			 
0b8a			scroll_up: 
0b8a			 
0b8a e5				push hl 
0b8b d5				push de 
0b8c c5				push bc 
0b8d			 
0b8d				; get frame buffer  
0b8d			 
0b8d 2a c6 eb			ld hl, (display_fb_active) 
0b90 e5				push hl    ; future de destination 
0b91			 
0b91 11 28 00			ld  de, display_cols 
0b94 19				add hl, de 
0b95			 
0b95 d1				pop de 
0b96			 
0b96				;ex de, hl 
0b96 01 9f 00			ld bc, display_fb_len -1  
0b99			;if DEBUG_FORTH_WORDS 
0b99			;	DMARK "SCL" 
0b99			;	CALLMONITOR 
0b99			;endif	 
0b99 ed b0			ldir 
0b9b			 
0b9b				; wipe bottom row 
0b9b			 
0b9b			 
0b9b 2a c6 eb			ld hl, (display_fb_active) 
0b9e 11 a0 00			ld de, display_cols*display_rows 
0ba1 19				add hl, de 
0ba2 06 28			ld b, display_cols 
0ba4 3e 20			ld a, ' ' 
0ba6			.scwipe: 
0ba6 77				ld (hl), a 
0ba7 2b				dec hl 
0ba8 10 fc			djnz .scwipe 
0baa			 
0baa				;pop hl 
0baa			 
0baa c1				pop bc 
0bab d1				pop de 
0bac e1				pop hl 
0bad			 
0bad c9				ret 
0bae			 
0bae			 
0bae			;scroll_upo: 
0bae			;	ld de, display_row_1 
0bae			 ;	ld hl, display_row_2 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_2 
0bae			 ;	ld hl, display_row_3 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_3 
0bae			 ;	ld hl, display_row_4 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			 
0bae			; TODO clear row 4 
0bae			 
0bae			;	ret 
0bae			 
0bae				 
0bae			scroll_down: 
0bae			 
0bae e5				push hl 
0baf d5				push de 
0bb0 c5				push bc 
0bb1			 
0bb1				; get frame buffer  
0bb1			 
0bb1 2a c6 eb			ld hl, (display_fb_active) 
0bb4			 
0bb4 11 9f 00			ld de, display_fb_len - 1 
0bb7 19				add hl, de 
0bb8			 
0bb8 e5			push hl    ; future de destination 
0bb9			 
0bb9 11 28 00			ld  de, display_cols 
0bbc ed 52			sbc hl, de 
0bbe			 
0bbe			 
0bbe d1				pop de 
0bbf			 
0bbf			;	ex de, hl 
0bbf 01 9f 00			ld bc, display_fb_len -1  
0bc2			 
0bc2			 
0bc2				 
0bc2			 
0bc2 ed b0			ldir 
0bc4			 
0bc4				; wipe bottom row 
0bc4			 
0bc4			 
0bc4			;	ld hl, (display_fb_active) 
0bc4			;;	ld de, display_cols*display_rows 
0bc4			;;	add hl, de 
0bc4			;	ld b, display_cols 
0bc4			;	ld a, ' ' 
0bc4			;.scwiped: 
0bc4			;	ld (hl), a 
0bc4			;	dec hl 
0bc4			;	djnz .scwiped 
0bc4			 
0bc4				;pop hl 
0bc4			 
0bc4 c1				pop bc 
0bc5 d1				pop de 
0bc6 e1				pop hl 
0bc7			 
0bc7 c9				ret 
0bc8			;scroll_down: 
0bc8			;	ld de, display_row_4 
0bc8			;	ld hl, display_row_3 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_3 
0bc8			; 	ld hl, display_row_2 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_2 
0bc8			;	ld hl, display_row_1 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;;; TODO clear row 1 
0bc8			;	ret 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			; clear active frame buffer 
0bc8			 
0bc8			clear_display: 
0bc8 3e 20			ld a, ' ' 
0bca c3 cd 0b			jp fill_display 
0bcd			 
0bcd			; fill active frame buffer with a char in A 
0bcd			 
0bcd			fill_display: 
0bcd 06 a0			ld b,display_fb_len 
0bcf 2a c6 eb			ld hl, (display_fb_active) 
0bd2 77			.fd1:	ld (hl),a 
0bd3 23				inc hl 
0bd4 10 fc			djnz .fd1 
0bd6 23				inc hl 
0bd7 3e 00			ld a,0 
0bd9 77				ld (hl),a 
0bda			 
0bda			 
0bda c9				ret 
0bdb			; Write string (DE) at pos (A) to active frame buffer 
0bdb			 
0bdb 2a c6 eb		str_at_display:    ld hl,(display_fb_active) 
0bde 06 00					ld b,0 
0be0 4f					ld c,a 
0be1 09					add hl,bc 
0be2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0be3 b7			            OR   A              ;Null terminator? 
0be4 c8			            RET  Z              ;Yes, so finished 
0be5 77					ld (hl),a 
0be6 23				inc hl 
0be7 13			            INC  DE             ;Point to next character 
0be8 18 f8		            JR   .sad1     ;Repeat 
0bea c9					ret 
0beb			 
0beb			; using current frame buffer write to physical display 
0beb			 
0beb			update_display: 
0beb e5				push hl 
0bec 2a c6 eb			ld hl, (display_fb_active) 
0bef cd 4f 63			call write_display 
0bf2 e1				pop hl 
0bf3 c9				ret 
0bf4			 
0bf4			; TODO scrolling 
0bf4			 
0bf4			 
0bf4			; move cursor right one char 
0bf4			cursor_right: 
0bf4			 
0bf4				; TODO shift right 
0bf4				; TODO if beyond max col 
0bf4				; TODO       cursor_next_line 
0bf4			 
0bf4 c9				ret 
0bf5			 
0bf5			 
0bf5			cursor_next_line: 
0bf5				; TODO first char 
0bf5				; TODO line down 
0bf5				; TODO if past last row 
0bf5				; TODO    scroll up 
0bf5			 
0bf5 c9				ret 
0bf6			 
0bf6			cursor_left: 
0bf6				; TODO shift left 
0bf6				; TODO if beyond left  
0bf6				; TODO     cursor prev line 
0bf6				 
0bf6 c9				ret 
0bf7			 
0bf7			cursor_prev_line: 
0bf7				; TODO last char 
0bf7				; TODO line up 
0bf7				; TODO if past first row 
0bf7				; TODO   scroll down 
0bf7			 
0bf7 c9				ret 
0bf8			 
0bf8			 
0bf8			cout: 
0bf8				; A - char 
0bf8 c9				ret 
0bf9			 
0bf9			 
0bf9			; Display a menu and allow item selection (optional toggle items) 
0bf9			; 
0bf9			; format: 
0bf9			; hl pointer to word array with zero term for items 
0bf9			; e.g.    db item1 
0bf9			;         db .... 
0bf9			;         db 0 
0bf9			; 
0bf9			; a = starting menu item  
0bf9			; 
0bf9			; de = pointer item toggle array   (todo) 
0bf9			; 
0bf9			; returns item selected in a 1-... 
0bf9			; returns 0 if back button pressed 
0bf9			; 
0bf9			; NOTE: Uses system frame buffer to display 
0bf9			; 
0bf9			; LEFT, Q = go back 
0bf9			; RIGHT, SPACE, CR = select 
0bf9			; UP, A - Up 
0bf9			; DOWN, Z - Down 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			menu: 
0bf9			 
0bf9					; keep array pointer 
0bf9			 
0bf9 22 6d ea				ld (store_tmp1), hl 
0bfc 32 6b ea				ld (store_tmp2), a 
0bff			 
0bff					; check for key bounce 
0bff			 
0bff			if BASE_KEV 
0bff			 
0bff			.mbounce:	call cin 
0bff					cp 0 
0bff					jr nz, .mbounce 
0bff			endif 
0bff					; for ease use ex 
0bff			 
0bff					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bff 21 ab ed				ld hl, display_fb0 
0c02 22 c6 eb				ld (display_fb_active), hl 
0c05			 
0c05 cd c8 0b		.mloop:		call clear_display 
0c08 cd eb 0b				call update_display 
0c0b			 
0c0b					; draw selection id '>' at 1 
0c0b			 
0c0b					; init start of list display 
0c0b			 
0c0b 3e 05				ld a, 5 
0c0d 32 69 ea				ld (store_tmp3), a   ; display row count 
0c10 3a 6b ea				ld a,( store_tmp2) 
0c13 32 6c ea				ld (store_tmp2+1), a   ; display item count 
0c16			 
0c16					 
0c16			.mitem:	 
0c16			 
0c16			 
0c16 3a 6c ea				ld a,(store_tmp2+1) 
0c19 6f					ld l, a 
0c1a 26 00				ld h, 0 
0c1c 29					add hl, hl 
0c1d ed 5b 6d ea			ld de, (store_tmp1) 
0c21 19					add hl, de 
0c22 7e					ld a, (hl) 
0c23 23					inc hl 
0c24 66					ld h,(hl) 
0c25 6f					ld l, a 
0c26			 
0c26 cd 1e 0e				call ishlzero 
0c29 28 1a				jr z, .mdone 
0c2b			 
0c2b eb					ex de, hl 
0c2c 3a 69 ea				ld a, (store_tmp3) 
0c2f cd db 0b				call str_at_display 
0c32					 
0c32			 
0c32					; next item 
0c32 3a 6c ea				ld a, (store_tmp2+1) 
0c35 3c					inc a 
0c36 32 6c ea				ld (store_tmp2+1), a   ; display item count 
0c39			 
0c39			 		; next row 
0c39			 
0c39 3a 69 ea				ld a, (store_tmp3) 
0c3c c6 28				add display_cols 
0c3e 32 69 ea				ld (store_tmp3), a 
0c41			 
0c41					; at end of screen? 
0c41			 
0c41 fe 10				cp display_rows*4 
0c43 20 d1				jr nz, .mitem 
0c45			 
0c45			 
0c45			.mdone: 
0c45 cd 1e 0e				call ishlzero 
0c48 28 08				jr z, .nodn 
0c4a			 
0c4a 3e 78				ld a, display_row_4 
0c4c 11 cb 0c				ld de, .mdown 
0c4f cd db 0b				call str_at_display 
0c52			 
0c52					; draw options to fill the screens with active item on line 1 
0c52					; if current option is 2 or more then display ^ in top 
0c52			 
0c52 3a 6b ea		.nodn:		ld a, (store_tmp2) 
0c55 fe 00				cp 0 
0c57 28 08				jr z, .noup 
0c59			 
0c59 3e 00				ld a, 0 
0c5b 11 c9 0c				ld de, .mup 
0c5e cd db 0b				call str_at_display 
0c61			 
0c61 3e 02		.noup:		ld a, 2 
0c63 11 c7 0c				ld de, .msel 
0c66 cd db 0b				call str_at_display 
0c69			 
0c69					; if current option + 1 is not null then display V in bottom 
0c69					; get key 
0c69 cd eb 0b				call update_display 
0c6c			 
0c6c			 
0c6c					; handle key 
0c6c			 
0c6c cd 01 64				call cin_wait 
0c6f			 
0c6f fe 05				cp KEY_UP 
0c71 28 2b				jr z, .mgoup 
0c73 fe 61				cp 'a' 
0c75 28 27				jr z, .mgoup 
0c77 fe 0a				cp KEY_DOWN 
0c79 28 32				jr z, .mgod 
0c7b fe 7a				cp 'z' 
0c7d 28 2e				jr z, .mgod 
0c7f fe 20				cp ' ' 
0c81 28 34				jr z, .goend 
0c83 fe 0c				cp KEY_RIGHT 
0c85 28 30				jr z, .goend 
0c87 fe 0d				cp KEY_CR 
0c89 28 2c				jr z, .goend 
0c8b fe 71				cp 'q' 
0c8d 28 0b				jr z, .goback 
0c8f			 
0c8f fe 0b				cp KEY_LEFT 
0c91 28 07				jr z, .goback 
0c93 fe 08				cp KEY_BS 
0c95 28 03				jr z, .goback 
0c97 c3 05 0c				jp .mloop 
0c9a			 
0c9a			.goback: 
0c9a 3e 00			ld a, 0 
0c9c 18 1d			jr .goend2 
0c9e			 
0c9e				; move up one 
0c9e			.mgoup: 
0c9e 3a 6b ea				ld a, (store_tmp2) 
0ca1 fe 00				cp 0 
0ca3 ca 05 0c				jp z, .mloop 
0ca6 3d					dec a 
0ca7 32 6b ea				ld (store_tmp2), a 
0caa c3 05 0c				jp .mloop 
0cad			 
0cad				; move down one 
0cad			.mgod: 
0cad 3a 6b ea				ld a, (store_tmp2) 
0cb0 3c					inc a 
0cb1 32 6b ea				ld (store_tmp2), a 
0cb4 c3 05 0c				jp .mloop 
0cb7			 
0cb7			 
0cb7			.goend: 
0cb7					; get selected item number 
0cb7			 
0cb7 3a 6b ea				ld a, (store_tmp2) 
0cba 3c					inc a 
0cbb			 
0cbb			.goend2: 
0cbb f5					push af 
0cbc			 
0cbc					; restore active fb 
0cbc					; TODO BUG assumes fb1 
0cbc			 
0cbc 21 0a ed				ld hl, display_fb1 
0cbf 22 c6 eb				ld (display_fb_active), hl 
0cc2			 
0cc2					; restore main regs 
0cc2			 
0cc2			 
0cc2 cd eb 0b				call update_display 
0cc5			 
0cc5 f1					pop af 
0cc6			 
0cc6 c9				ret 
0cc7			 
0cc7 .. 00		.msel:   db ">",0 
0cc9 .. 00		.mup:   db "^",0 
0ccb .. 00		.mdown:   db "v",0 
0ccd			 
0ccd			 
0ccd			; eof 
0ccd			 
# End of file firmware_display.asm
0ccd			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ccd			; random number generators 
0ccd			 
0ccd			 
0ccd			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ccd			 
0ccd			 
0ccd			;-----> Generate a random number 
0ccd			; output a=answer 0<=a<=255 
0ccd			; all registers are preserved except: af 
0ccd			random: 
0ccd e5			        push    hl 
0cce d5			        push    de 
0ccf 2a a5 eb		        ld      hl,(randData) 
0cd2 ed 5f		        ld      a,r 
0cd4 57			        ld      d,a 
0cd5 5e			        ld      e,(hl) 
0cd6 19			        add     hl,de 
0cd7 85			        add     a,l 
0cd8 ac			        xor     h 
0cd9 22 a5 eb		        ld      (randData),hl 
0cdc d1			        pop     de 
0cdd e1			        pop     hl 
0cde c9			        ret 
0cdf			 
0cdf			 
0cdf			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdf			 
0cdf			 
0cdf			 
0cdf			;------LFSR------ 
0cdf			;James Montelongo 
0cdf			;optimized by Spencer Putt 
0cdf			;out: 
0cdf			; a = 8 bit random number 
0cdf			RandLFSR: 
0cdf 21 ab eb		        ld hl,LFSRSeed+4 
0ce2 5e			        ld e,(hl) 
0ce3 23			        inc hl 
0ce4 56			        ld d,(hl) 
0ce5 23			        inc hl 
0ce6 4e			        ld c,(hl) 
0ce7 23			        inc hl 
0ce8 7e			        ld a,(hl) 
0ce9 47			        ld b,a 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 cb 13		        rl e  
0cfa cb 12			rl d 
0cfc cb 11		        rl c  
0cfe 17				rla 
0cff 67			        ld h,a 
0d00 cb 13		        rl e  
0d02 cb 12			rl d 
0d04 cb 11		        rl c  
0d06 17				rla 
0d07 a8			        xor b 
0d08 cb 13		        rl e  
0d0a cb 12			rl d 
0d0c ac			        xor h 
0d0d a9			        xor c 
0d0e aa			        xor d 
0d0f 21 ad eb		        ld hl,LFSRSeed+6 
0d12 11 ae eb		        ld de,LFSRSeed+7 
0d15 01 07 00		        ld bc,7 
0d18 ed b8		        lddr 
0d1a 12			        ld (de),a 
0d1b c9			        ret 
0d1c			 
0d1c			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d1c			 
0d1c			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d1c			 
0d1c			 
0d1c			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d1c			 
0d1c			prng16: 
0d1c			;Inputs: 
0d1c			;   (seed1) contains a 16-bit seed value 
0d1c			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d1c			;Outputs: 
0d1c			;   HL is the result 
0d1c			;   BC is the result of the LCG, so not that great of quality 
0d1c			;   DE is preserved 
0d1c			;Destroys: 
0d1c			;   AF 
0d1c			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d1c			;160cc 
0d1c			;26 bytes 
0d1c 2a 9f eb		    ld hl,(seed1) 
0d1f 44			    ld b,h 
0d20 4d			    ld c,l 
0d21 29			    add hl,hl 
0d22 29			    add hl,hl 
0d23 2c			    inc l 
0d24 09			    add hl,bc 
0d25 22 9f eb		    ld (seed1),hl 
0d28 2a 9d eb		    ld hl,(seed2) 
0d2b 29			    add hl,hl 
0d2c 9f			    sbc a,a 
0d2d e6 2d		    and %00101101 
0d2f ad			    xor l 
0d30 6f			    ld l,a 
0d31 22 9d eb		    ld (seed2),hl 
0d34 09			    add hl,bc 
0d35 c9			    ret 
0d36			 
0d36			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d36			 
0d36			rand32: 
0d36			;Inputs: 
0d36			;   (seed1_0) holds the lower 16 bits of the first seed 
0d36			;   (seed1_1) holds the upper 16 bits of the first seed 
0d36			;   (seed2_0) holds the lower 16 bits of the second seed 
0d36			;   (seed2_1) holds the upper 16 bits of the second seed 
0d36			;   **NOTE: seed2 must be non-zero 
0d36			;Outputs: 
0d36			;   HL is the result 
0d36			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d36			;Destroys: 
0d36			;   AF 
0d36			;Tested and passes all CAcert tests 
0d36			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d36			;it has a period of 18,446,744,069,414,584,320 
0d36			;roughly 18.4 quintillion. 
0d36			;LFSR taps: 0,2,6,7  = 11000101 
0d36			;291cc 
0d36			;seed1_0=$+1 
0d36			;    ld hl,12345 
0d36			;seed1_1=$+1 
0d36			;    ld de,6789 
0d36			;    ld b,h 
0d36			;    ld c,l 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    inc l 
0d36			;    add hl,bc 
0d36			;    ld (seed1_0),hl 
0d36			;    ld hl,(seed1_1) 
0d36			;    adc hl,de 
0d36			;    ld (seed1_1),hl 
0d36			;    ex de,hl 
0d36			;seed2_0=$+1 
0d36			;    ld hl,9876 
0d36			;seed2_1=$+1 
0d36			;    ld bc,54321 
0d36			;    add hl,hl \ rl c \ rl b 
0d36			;    ld (seed2_1),bc 
0d36			;    sbc a,a 
0d36			;    and %11000101 
0d36			;    xor l 
0d36			;    ld l,a 
0d36			;    ld (seed2_0),hl 
0d36			;    ex de,hl 
0d36			;    add hl,bc 
0d36			;    ret 
0d36			; 
0d36			 
0d36			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d36			; 20 bytes, 86 cycles (excluding ret) 
0d36			 
0d36			; returns   hl = pseudorandom number 
0d36			; corrupts   a 
0d36			 
0d36			; generates 16-bit pseudorandom numbers with a period of 65535 
0d36			; using the xorshift method: 
0d36			 
0d36			; hl ^= hl << 7 
0d36			; hl ^= hl >> 9 
0d36			; hl ^= hl << 8 
0d36			 
0d36			; some alternative shift triplets which also perform well are: 
0d36			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d36			 
0d36			;  org 32768 
0d36			 
0d36			xrnd: 
0d36 2a a3 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d39 3e 00		  ld a,0 
0d3b bd			  cp l 
0d3c 20 02		  jr nz, .xrnd1 
0d3e 2e 01		  ld l, 1 
0d40			.xrnd1: 
0d40			 
0d40 7c			  ld a,h 
0d41 1f			  rra 
0d42 7d			  ld a,l 
0d43 1f			  rra 
0d44 ac			  xor h 
0d45 67			  ld h,a 
0d46 7d			  ld a,l 
0d47 1f			  rra 
0d48 7c			  ld a,h 
0d49 1f			  rra 
0d4a ad			  xor l 
0d4b 6f			  ld l,a 
0d4c ac			  xor h 
0d4d 67			  ld h,a 
0d4e			 
0d4e 22 a3 eb		  ld (xrandc),hl 
0d51			 
0d51 c9			  ret 
0d52			;  
0d52			 
0d52			 
0d52			;;;; int maths 
0d52			 
0d52			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d52			; Divide 16-bit values (with 16-bit result) 
0d52			; In: Divide BC by divider DE 
0d52			; Out: BC = result, HL = rest 
0d52			; 
0d52			Div16: 
0d52 21 00 00		    ld hl,0 
0d55 78			    ld a,b 
0d56 06 08		    ld b,8 
0d58			Div16_Loop1: 
0d58 17			    rla 
0d59 ed 6a		    adc hl,hl 
0d5b ed 52		    sbc hl,de 
0d5d 30 01		    jr nc,Div16_NoAdd1 
0d5f 19			    add hl,de 
0d60			Div16_NoAdd1: 
0d60 10 f6		    djnz Div16_Loop1 
0d62 17			    rla 
0d63 2f			    cpl 
0d64 47			    ld b,a 
0d65 79			    ld a,c 
0d66 48			    ld c,b 
0d67 06 08		    ld b,8 
0d69			Div16_Loop2: 
0d69 17			    rla 
0d6a ed 6a		    adc hl,hl 
0d6c ed 52		    sbc hl,de 
0d6e 30 01		    jr nc,Div16_NoAdd2 
0d70 19			    add hl,de 
0d71			Div16_NoAdd2: 
0d71 10 f6		    djnz Div16_Loop2 
0d73 17			    rla 
0d74 2f			    cpl 
0d75 41			    ld b,c 
0d76 4f			    ld c,a 
0d77 c9			ret 
0d78			 
0d78			 
0d78			;http://z80-heaven.wikidot.com/math 
0d78			; 
0d78			;Inputs: 
0d78			;     DE and A are factors 
0d78			;Outputs: 
0d78			;     A is not changed 
0d78			;     B is 0 
0d78			;     C is not changed 
0d78			;     DE is not changed 
0d78			;     HL is the product 
0d78			;Time: 
0d78			;     342+6x 
0d78			; 
0d78			Mult16: 
0d78			 
0d78 06 08		     ld b,8          ;7           7 
0d7a 21 00 00		     ld hl,0         ;10         10 
0d7d 29			       add hl,hl     ;11*8       88 
0d7e 07			       rlca          ;4*8        32 
0d7f 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d81 19			         add hl,de   ;--         -- 
0d82 10 f9		       djnz $-5      ;13*7+8     99 
0d84 c9			ret 
0d85			 
0d85			; 
0d85			; Square root of 16-bit value 
0d85			; In:  HL = value 
0d85			; Out:  D = result (rounded down) 
0d85			; 
0d85			;Sqr16: 
0d85			;    ld de,#0040 
0d85			;    ld a,l 
0d85			;    ld l,h 
0d85			;    ld h,d 
0d85			;    or a 
0d85			;    ld b,8 
0d85			;Sqr16_Loop: 
0d85			;    sbc hl,de 
0d85			;    jr nc,Sqr16_Skip 
0d85			;    add hl,de 
0d85			;Sqr16_Skip: 
0d85			;    ccf 
0d85			;    rl d 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    djnz Sqr16_Loop 
0d85			;    ret 
0d85			; 
0d85			; 
0d85			; Divide 8-bit values 
0d85			; In: Divide E by divider C 
0d85			; Out: A = result, B = rest 
0d85			; 
0d85			Div8: 
0d85 af			    xor a 
0d86 06 08		    ld b,8 
0d88			Div8_Loop: 
0d88 cb 13		    rl e 
0d8a 17			    rla 
0d8b 91			    sub c 
0d8c 30 01		    jr nc,Div8_NoAdd 
0d8e 81			    add a,c 
0d8f			Div8_NoAdd: 
0d8f 10 f7		    djnz Div8_Loop 
0d91 47			    ld b,a 
0d92 7b			    ld a,e 
0d93 17			    rla 
0d94 2f			    cpl 
0d95 c9			    ret 
0d96			 
0d96			; 
0d96			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d96			; In: Multiply A with DE 
0d96			; Out: HL = result 
0d96			; 
0d96			Mult12U: 
0d96 2e 00		    ld l,0 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd0 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd0: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd1 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd1: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd2 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd2: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd3 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd3: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad 30 01		    jr nc,Mult12U_NoAdd4 
0daf 19			    add hl,de 
0db0			Mult12U_NoAdd4: 
0db0 29			    add hl,hl 
0db1 87			    add a,a 
0db2 30 01		    jr nc,Mult12U_NoAdd5 
0db4 19			    add hl,de 
0db5			Mult12U_NoAdd5: 
0db5 29			    add hl,hl 
0db6 87			    add a,a 
0db7 30 01		    jr nc,Mult12U_NoAdd6 
0db9 19			    add hl,de 
0dba			Mult12U_NoAdd6: 
0dba 29			    add hl,hl 
0dbb 87			    add a,a 
0dbc d0			    ret nc 
0dbd 19			    add hl,de 
0dbe c9			    ret 
0dbf			 
0dbf			; 
0dbf			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbf			; In: Multiply A with DE 
0dbf			;      Put lowest value in A for most efficient calculation 
0dbf			; Out: HL = result 
0dbf			; 
0dbf			Mult12R: 
0dbf 21 00 00		    ld hl,0 
0dc2			Mult12R_Loop: 
0dc2 cb 3f		    srl a 
0dc4 30 01		    jr nc,Mult12R_NoAdd 
0dc6 19			    add hl,de 
0dc7			Mult12R_NoAdd: 
0dc7 cb 23		    sla e 
0dc9 cb 12		    rl d 
0dcb b7			    or a 
0dcc c2 c2 0d		    jp nz,Mult12R_Loop 
0dcf c9			    ret 
0dd0			 
0dd0			; 
0dd0			; Multiply 16-bit values (with 32-bit result) 
0dd0			; In: Multiply BC with DE 
0dd0			; Out: BCHL = result 
0dd0			; 
0dd0			Mult32: 
0dd0 79			    ld a,c 
0dd1 48			    ld c,b 
0dd2 21 00 00		    ld hl,0 
0dd5 06 10		    ld b,16 
0dd7			Mult32_Loop: 
0dd7 29			    add hl,hl 
0dd8 17			    rla 
0dd9 cb 11		    rl c 
0ddb 30 07		    jr nc,Mult32_NoAdd 
0ddd 19			    add hl,de 
0dde ce 00		    adc a,0 
0de0 d2 e4 0d		    jp nc,Mult32_NoAdd 
0de3 0c			    inc c 
0de4			Mult32_NoAdd: 
0de4 10 f1		    djnz Mult32_Loop 
0de6 41			    ld b,c 
0de7 4f			    ld c,a 
0de8 c9			    ret 
0de9			 
0de9			 
0de9			 
0de9			; 
0de9			; Multiply 8-bit values 
0de9			; In:  Multiply H with E 
0de9			; Out: HL = result 
0de9			; 
0de9			Mult8: 
0de9 16 00		    ld d,0 
0deb 6a			    ld l,d 
0dec 06 08		    ld b,8 
0dee			Mult8_Loop: 
0dee 29			    add hl,hl 
0def 30 01		    jr nc,Mult8_NoAdd 
0df1 19			    add hl,de 
0df2			Mult8_NoAdd: 
0df2 10 fa		    djnz Mult8_Loop 
0df4 c9			    ret 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			;;http://z80-heaven.wikidot.com/math 
0df5			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df5			; 
0df5			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df5			;     ld a,16        ;7 
0df5			;     ld hl,0        ;10 
0df5			;     jp $+5         ;10 
0df5			;.DivLoop: 
0df5			;       add hl,bc    ;-- 
0df5			;       dec a        ;64 
0df5			;       jr z,.DivLoopEnd        ;86 
0df5			; 
0df5			;       sla e        ;128 
0df5			;       rl d         ;128 
0df5			;       adc hl,hl    ;240 
0df5			;       sbc hl,bc    ;240 
0df5			;       jr nc,.DivLoop ;23|21 
0df5			;       inc e        ;-- 
0df5			;       jp .DivLoop+1 
0df5			; 
0df5			;.DivLoopEnd: 
0df5			 
0df5			;HL_Div_C: 
0df5			;Inputs: 
0df5			;     HL is the numerator 
0df5			;     C is the denominator 
0df5			;Outputs: 
0df5			;     A is the remainder 
0df5			;     B is 0 
0df5			;     C is not changed 
0df5			;     DE is not changed 
0df5			;     HL is the quotient 
0df5			; 
0df5			;       ld b,16 
0df5			;       xor a 
0df5			;         add hl,hl 
0df5			;         rla 
0df5			;         cp c 
0df5			;         jr c,$+4 
0df5			;           inc l 
0df5			;           sub c 
0df5			;         djnz $-7 
0df5			 
0df5			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df5			 
0df5			addatohl: 
0df5 85			    add   a, l    ; A = A+L 
0df6 6f			    ld    l, a    ; L = A+L 
0df7 8c			    adc   a, h    ; A = A+L+H+carry 
0df8 95			    sub   l       ; A = H+carry 
0df9 67			    ld    h, a    ; H = H+carry 
0dfa c9			ret 
0dfb			 
0dfb			addatode: 
0dfb 83			    add   a, e    ; A = A+L 
0dfc 5f			    ld    e, a    ; L = A+L 
0dfd 8a			    adc   a, d    ; A = A+L+H+carry 
0dfe 93			    sub   e       ; A = H+carry 
0dff 57			    ld    d, a    ; H = H+carry 
0e00 c9			ret 
0e01			 
0e01			 
0e01			addatobc: 
0e01 81			    add   a, c    ; A = A+L 
0e02 4f			    ld    c, a    ; L = A+L 
0e03 88			    adc   a, b    ; A = A+L+H+carry 
0e04 91			    sub   c       ; A = H+carry 
0e05 47			    ld    b, a    ; H = H+carry 
0e06 c9			ret 
0e07			 
0e07			subafromhl: 
0e07			   ; If A=0 do nothing 
0e07			    ; Otherwise flip A's sign. Since 
0e07			    ; the upper byte becomes -1, also 
0e07			    ; substract 1 from H. 
0e07 ed 44		    neg 
0e09 ca 12 0e		    jp    z, Skip 
0e0c 25			    dec   h 
0e0d			     
0e0d			    ; Now add the low byte as usual 
0e0d			    ; Two's complement takes care of 
0e0d			    ; ensuring the result is correct 
0e0d 85			    add   a, l 
0e0e 6f			    ld    l, a 
0e0f 8c			    adc   a, h 
0e10 95			    sub   l 
0e11 67			    ld    h, a 
0e12			Skip: 
0e12 c9				ret 
0e13			 
0e13			 
0e13			; compare hl and de 
0e13			; returns:  
0e13			; if hl = de, z=1, s=0, c0=0 
0e13			; if hl > de, z=0, s=0, c=0 
0e13			; if hl < de, z=0, s=1, c=1 
0e13			cmp16:	 
0e13 b7				or a 
0e14 ed 52			sbc hl,de 
0e16 e0				ret po 
0e17 7c				ld a,h 
0e18 1f				rra 
0e19 ee 40			xor 01000000B 
0e1b 37				scf 
0e1c 8f				adc a,a 
0e1d c9				ret 
0e1e			 
0e1e			 
0e1e			; test if hl contains zero   - A is destroyed 
0e1e			 
0e1e			ishlzero:    
0e1e b7				or a     ; reset flags 
0e1f 7c				ld a, h 
0e20 b5				or l        	 
0e21			 
0e21 c9				ret 
0e22			 
0e22			 
0e22			 
0e22			 
0e22			if FORTH_ENABLE_FLOATMATH 
0e22			;include "float/bbcmath.z80" 
0e22			include "float/lpfpcalc.asm" 
0e22			endif 
0e22			 
0e22			 
0e22			; eof 
0e22			 
# End of file firmware_maths.asm
0e22			include "firmware_strings.asm"   ; string handling  
0e22			 
0e22			 
0e22			; TODO string len 
0e22			; input text string, end on cr with zero term 
0e22			; a offset into frame buffer to start prompt 
0e22			; d is max length 
0e22			; e is display size TODO 
0e22			; c is current cursor position 
0e22			; hl is ptr to where string will be stored and edited directly 
0e22			 
0e22			 
0e22			; TODO check limit of buffer for new inserts 
0e22			; TODO check insert does not push beyond buffer 
0e22			; TODO scroll in a limited display area 
0e22			; TODO scroll whole screen on page wrap 
0e22			 
0e22			 
0e22			; TODO use LCD cursor? 
0e22			 
0e22			EDIT_V1: equ 0 
0e22			EDIT_V2: equ 1 
0e22			 
0e22			 
0e22			 
0e22			if EDIT_V2 
0e22			input_str: 
0e22			 
0e22 32 5e ee			    	ld (input_at_pos),a      ; save display position to start 
0e25			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e25 22 61 ee				ld (input_start), hl     ; save ptr to buffer 
0e28			;		ld a, c 
0e28			;		call addatohl 
0e28			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e28 7a					ld a,d 
0e29 32 60 ee			        ld (input_size), a       ; save length of input area 
0e2c 79					ld a, c 
0e2d 32 4f ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e30 7b					ld a,e 
0e31 32 5f ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e34			 
0e34			 
0e34					; add a trailing space to make screen refresh nicer 
0e34			 
0e34					;ld hl, (input_start) 
0e34					;push hl 
0e34					;ld a, 0 
0e34					;call strlent 
0e34					;ld a, l 
0e34					;pop hl 
0e34					;call addatohl 
0e34					;dec hl 
0e34					;ld a, ' ' 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld a, 0 
0e34					;ld (hl), a 
0e34			 
0e34			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e34					; init cursor shape if not set by the cin routines 
0e34 21 bb eb				ld hl, cursor_shape 
0e37			if BASE_KEV 
0e37					ld a, 255 
0e37			else 
0e37 3e 23				ld a, '#' 
0e39			endif 
0e39 77					ld (hl), a 
0e3a 23					inc hl 
0e3b 3e 00				ld a, 0 
0e3d 77					ld (hl), a 
0e3e			 
0e3e 3e 09				ld a, CUR_BLINK_RATE 
0e40 32 5a ee				ld (input_cur_flash), a 
0e43 3e 01				ld a, 1 
0e45 32 59 ee				ld (input_cur_onoff),a 
0e48			.inmain:	 
0e48			 
0e48 cd 70 0f				call input_disp_ref 
0e4b			 
0e4b					; save current length of string 
0e4b			 
0e4b 2a 61 ee				ld hl, (input_start) 
0e4e 3e 00				ld a, 0 
0e50 cd 66 11				call strlent 
0e53 7d					ld a,l 
0e54 32 54 ee				ld (input_len), a 
0e57			 
0e57					;call input_disp_oncur 
0e57			 
0e57					; display current state of input buffer 
0e57			 
0e57					; clean any backspace chars 
0e57			 
0e57 3e 20				ld a, " " 
0e59 32 bb e2				ld (scratch),a 
0e5c 3e 00				ld a, 0 
0e5e 32 bc e2				ld (scratch+1),a 
0e61 3a 5e ee				ld a,(input_at_pos) 
0e64 85					add l 
0e65 11 bb e2				ld de, scratch 
0e68 cd db 0b				call str_at_display 
0e6b			 
0e6b					; pause 1ms 
0e6b			 
0e6b 3e 01				ld a, 1 
0e6d cd e5 0a				call aDelayInMS 
0e70			 
0e70			; display cursor if visible on this cycle 
0e70			 
0e70					; dec flash counter 
0e70 3a 5a ee				ld a, (input_cur_flash) 
0e73 3d					dec a 
0e74 32 5a ee				ld (input_cur_flash), a 
0e77 fe 00				cp 0 
0e79 20 0d				jr nz, .inochgstate 
0e7b			 
0e7b			 
0e7b					; reset on change of state 
0e7b 3e 09				ld a, CUR_BLINK_RATE 
0e7d 32 5a ee				ld (input_cur_flash), a 
0e80			 
0e80					; change state 
0e80 3a 59 ee				ld a,(input_cur_onoff) 
0e83 ed 44				neg 
0e85 32 59 ee				ld (input_cur_onoff),a 
0e88			 
0e88			 
0e88			 
0e88			 
0e88					; TODO is cursor visible? 
0e88					; TODO if so then over write the char at curspos pos with the cursor shape 
0e88			 
0e88								 
0e88			 
0e88			.inochgstate: 
0e88 3a 59 ee				ld a,(input_cur_onoff) 
0e8b fe ff				cp 255 
0e8d 28 0e				jr z, .skipcursor 
0e8f 3a 5e ee				ld a, (input_at_pos) 
0e92 47					ld b, a 
0e93 3a 4f ee				ld a, (input_cursor) 
0e96 80					add b 
0e97 11 bb eb				ld de, cursor_shape 
0e9a					 
0e9a cd db 0b				call str_at_display 
0e9d			 
0e9d			.skipcursor: 
0e9d				if DEBUG_INPUTV2 
0e9d			 
0e9d					ld a,(input_at_pos) 
0e9d					ld hl, LFSRSeed 
0e9d					call hexout 
0e9d					ld a, (input_cursor) 
0e9d					ld hl, LFSRSeed+2 
0e9d					call hexout 
0e9d					ld a,(input_size) 
0e9d					ld hl, LFSRSeed+4 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_onoff) 
0e9d					ld hl, LFSRSeed+6 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_flash) 
0e9d					ld hl, LFSRSeed+8 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_len) 
0e9d					ld hl, LFSRSeed+10 
0e9d					call hexout 
0e9d					ld hl, LFSRSeed+12 
0e9d					ld a, 0 
0e9d					ld (hl),a 
0e9d					ld a, display_row_4 
0e9d					ld de, LFSRSeed 
0e9d					call str_at_display 
0e9d				endif 
0e9d cd eb 0b				call update_display 
0ea0			 
0ea0					; TODO keyboard processing 
0ea0			 
0ea0			if BASE_CPM 
0ea0 cd 01 64				call cin_wait 
0ea3			else 
0ea3					call cin    ; _wait 
0ea3			endif 
0ea3 fe 00				cp 0 
0ea5 ca 48 0e				jp z, .inmain 
0ea8			 
0ea8 fe 0b				cp KEY_LEFT    ; cursor left 
0eaa ca 62 0f				jp z, input_left 
0ead				 
0ead fe 0c				cp KEY_RIGHT      ; cursor right 
0eaf ca 69 0f				jp z, input_right 
0eb2			 
0eb2 fe 0d				cp KEY_CR 
0eb4 c8					ret z 
0eb5			 
0eb5 fe 08				cp KEY_BS 
0eb7 ca d7 0f				jp z, input_delchar 
0eba			 
0eba fe 06				cp KEY_NEXTWORD 
0ebc ca e3 0e				jp z, input_nxtword 
0ebf			 
0ebf fe 07				cp KEY_PREVWORD 
0ec1 ca 0a 0f				jp z, input_prvword 
0ec4			 
0ec4 fe 0e				cp KEY_HOME    ; jump to start of line 
0ec6 20 08				jr nz, .ikh 
0ec8 3e 00				ld a, 0 
0eca 32 4f ee				ld (input_cursor), a 
0ecd ca 48 0e				jp z, .inmain 
0ed0			.ikh: 
0ed0			 
0ed0 fe 0f				cp KEY_END     ; jump to end of line 
0ed2 20 09				jr nz, .ike 
0ed4 3a 54 ee				ld a, (input_len) 
0ed7 32 4f ee				ld (input_cursor),a 
0eda ca 48 0e				jp z, .inmain 
0edd			.ike: 
0edd fe 05			        cp KEY_UP      ; recall last command 
0edf c8					ret z 
0ee0			;jr nz, .irec 
0ee0			; TODO next word 
0ee0			; TODO prev word 
0ee0			;  
0ee0			; 
0ee0			;	ld hl, scratch 
0ee0			;	ld de, os_last_cmd 
0ee0			;	call strcpy 
0ee0			;		jp  .inmain 
0ee0			.irec: 
0ee0			;		jr .instr1 
0ee0			 
0ee0			 
0ee0			 
0ee0					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ee0			 
0ee0			; TODO return if any special keys are given 
0ee0			;		ld l, a 
0ee0			;		ld a, 28 ; KEY_F12   ; 27 
0ee0			;		sub l 
0ee0			;		ret m 
0ee0			;		ld a, l 
0ee0					; if no special key then insert as a char 
0ee0			 
0ee0 c3 a9 0f				jp input_inschr 
0ee3			 
0ee3				 
0ee3			input_nxtword: 
0ee3				; jump to start next word after the cursor 
0ee3			 
0ee3			.insknwn:	 
0ee3 cd 9f 0f				call input_curptr	 
0ee6 7e					ld a,(hl)	 
0ee7 fe 00				cp 0 
0ee9 ca 48 0e				jp z, .inmain    ; end of string 
0eec			 
0eec			; if we are on a word, then move off of it 
0eec			 
0eec fe 20				cp ' ' 
0eee 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ef0 21 4f ee				ld hl, input_cursor 
0ef3 34					inc (hl) 
0ef4 18 ed				jr .insknwn 
0ef6			 
0ef6			.inspace: 
0ef6			 
0ef6 cd 9f 0f				call input_curptr	 
0ef9 7e					ld a,(hl)	 
0efa fe 00				cp 0 
0efc ca 48 0e				jp z, .inmain    ; end of string 
0eff			 
0eff			; if we are on a word, then move off of it 
0eff			 
0eff fe 20				cp ' ' 
0f01 c2 48 0e				jp nz, .inmain     ; we are on non space so at next word 
0f04 21 4f ee				ld hl, input_cursor 
0f07 34					inc (hl) 
0f08 18 ec				jr .inspace 
0f0a			 
0f0a			 
0f0a			 
0f0a			 
0f0a			input_prvword: 
0f0a				; jump to the start of previous word before the cursor 
0f0a			 
0f0a			; where are we to start with currently? 
0f0a			 
0f0a cd 9f 0f				call input_curptr	 
0f0d 7e					ld a, (hl) 
0f0e fe 20				cp ' ' 
0f10 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f12			 
0f12			 
0f12			 
0f12			.inskpwn:	 
0f12 3a 4f ee				ld a,(input_cursor) 
0f15 fe 00				cp 0 
0f17 ca 48 0e				jp z, .inmain    ; start of string 
0f1a			 
0f1a			;if we are on a word, then move off of it 
0f1a			 
0f1a cd 9f 0f				call input_curptr	 
0f1d 7e					ld a, (hl) 
0f1e fe 20				cp ' ' 
0f20 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f22					;jp z, .inmain    ; start of string 
0f22 21 4f ee				ld hl, input_cursor 
0f25 35					dec (hl) 
0f26 18 ea				jr .inskpwn 
0f28			.iwstart: 
0f28 21 4f ee				ld hl, input_cursor 
0f2b 34					inc (hl) 
0f2c c3 48 0e				jp .inmain 
0f2f					 
0f2f			 
0f2f			.inspacep: 
0f2f			 
0f2f					;jp .inmain    ; start of string 
0f2f			 
0f2f			 
0f2f			 
0f2f 3a 4f ee				ld a,(input_cursor) 
0f32 fe 00				cp 0 
0f34 ca 48 0e				jp z, .inmain    ; start of string 
0f37			 
0f37			; if we are on a word, then move off of it 
0f37			 
0f37 cd 9f 0f				call input_curptr	 
0f3a 7e					ld a, (hl) 
0f3b fe 20				cp ' ' 
0f3d c2 46 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f40 21 4f ee				ld hl, input_cursor 
0f43 35					dec (hl) 
0f44 18 e9				jr .inspacep 
0f46			 
0f46			 
0f46			.incharp:	 
0f46					; eat the word to get to the start 
0f46 3a 4f ee				ld a,(input_cursor) 
0f49 fe 00				cp 0 
0f4b ca 48 0e				jp z, .inmain    ; start of string 
0f4e			 
0f4e			; if we are on a word, then move off of it 
0f4e			 
0f4e cd 9f 0f				call input_curptr	 
0f51 7e					ld a, (hl) 
0f52 fe 20				cp ' ' 
0f54 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f56 21 4f ee				ld hl, input_cursor 
0f59 35					dec (hl) 
0f5a 18 ea				jr .incharp 
0f5c			.ipwordst: 
0f5c					; at space before the prev word so reposition over it 
0f5c 21 4f ee				ld hl, input_cursor 
0f5f 34					inc (hl) 
0f60 18 b0				jr .inskpwn 
0f62					 
0f62			 
0f62			 
0f62			input_left: 
0f62				; move cursor left 
0f62 21 4f ee			ld hl, input_cursor 
0f65 35				dec (hl) 
0f66			;	cp 0 
0f66			;	jp z, .inmain    ; ignore left as at the start of the string 
0f66 c3 48 0e			jp .inmain 
0f69			 
0f69			input_right: 
0f69				; move cursor right 
0f69				 
0f69				;ld a, (input_size) 
0f69				;ld b, a 
0f69 21 4f ee			ld hl, input_cursor 
0f6c 34				inc (hl) 
0f6d				;dec b 
0f6d				;cp 0 
0f6d				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6d				;ld a, b 
0f6d				;inc a 
0f6d				;ld (input_cursor), a 
0f6d c3 48 0e			jp .inmain 
0f70			 
0f70			 
0f70			 
0f70			input_disp_ref: 
0f70				; display the text from start of buffer (ie full refresh) 
0f70 3a 5e ee			ld a, (input_at_pos) 
0f73 2a 61 ee			ld hl,(input_start) 
0f76 eb				ex de, hl 
0f77 cd db 0b			call str_at_display  
0f7a c9				ret 
0f7b			input_disp_oncur: 
0f7b				; display the text from cursor position to end of buffer 
0f7b				; TODO position start of string at cursor position on screen 
0f7b				; TODO draw from that point on 
0f7b 3a 4f ee			ld a, (input_cursor) 
0f7e 47				ld b, a 
0f7f 3a 5e ee			ld a, (input_at_pos) 
0f82 80				add b 
0f83 48				ld c, b     ; save a 
0f84 78				ld a, b     ; inc string start for cursor 
0f85 2a 61 ee			ld hl,(input_start) 
0f88 cd f5 0d			call addatohl 
0f8b eb				ex de, hl 
0f8c 79				ld a, c 
0f8d cd db 0b			call str_at_display  
0f90 c9				ret 
0f91			 
0f91			input_nxtw: 
0f91				; Find next word 
0f91 c9				ret 
0f92			 
0f92			input_prvw: 
0f92				; Find previous word 
0f92 c9				ret 
0f93			 
0f93			input_lenrem:   
0f93				; Calculate the length of string remaining from current cursor 
0f93				; position to end of buffer (exc null term) 
0f93				 
0f93 3a 4f ee			ld a, (input_cursor) 
0f96 4f				ld c, a 
0f97 3a 60 ee			ld a, (input_size) 
0f9a 91				sub c 
0f9b 06 00			ld b, 0 
0f9d 0d				dec c 
0f9e c9				ret	 
0f9f			 
0f9f			input_curptr: 
0f9f				; calc address of the character under the cursor 
0f9f				 
0f9f 2a 61 ee			ld hl, (input_start) 
0fa2 3a 4f ee			ld a, (input_cursor) 
0fa5 cd f5 0d			call addatohl 
0fa8 c9				ret 
0fa9			 
0fa9			input_inschr: 
0fa9				; Insert char at cursor position 
0fa9 f5				push af   ; save char 
0faa				;call input_lenrem    ; get bc length of remaining string 
0faa			 
0faa				 
0faa cd 9f 0f			call input_curptr 
0fad			;	ld hl, (input_start) 
0fad			;	ld a, (input_cursor) 
0fad			;	call addatohl 
0fad				;push hl   ; save to come back to 
0fad			 
0fad				; shift everything up one to end of buffer 
0fad			 
0fad				;push hl 
0fad				;dec de 
0fad				;inc de 
0fad			;	ldir 
0fad				 
0fad				;pop hl 
0fad			 
0fad				; are we adding to the end of line? 
0fad			 
0fad 3a 4f ee			ld a, (input_cursor) 
0fb0 47				ld b, a 
0fb1 3a 54 ee			ld a, (input_len) 
0fb4 b8				cp b 
0fb5 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb7			 
0fb7				; tack on the end of the line 
0fb7 f1				pop af 
0fb8 77				ld (hl), a   ; save new char 
0fb9 23				inc hl 
0fba 3e 00			ld a, 0 
0fbc 77				ld (hl), a 
0fbd c3 69 0f			jp input_right 
0fc0				 
0fc0			.insmid: 
0fc0				; hl has insertion point so move everything up one to allow for insertion 
0fc0				;call input_shiftright 
0fc0 f1				pop af 
0fc1			 
0fc1			.shufinsmid: 
0fc1 47				ld b, a     ; b contains new char, c prev char at this position  
0fc2 7e				ld a, (hl) 
0fc3			 
0fc3 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc5 28 07			jr z, .endinsmid 
0fc7 4f				ld c, a 
0fc8 78				ld a, b 
0fc9 77				ld (hl), a 
0fca 23				inc hl 
0fcb 79				ld a, c 
0fcc 18 f3			jr .shufinsmid 
0fce				 
0fce			 
0fce			 
0fce			 
0fce			.endinsmid: 
0fce 78				ld a, b 
0fcf 77				ld (hl), a 
0fd0 23				inc hl 
0fd1 3e 00			ld a, 0 
0fd3 77				ld (hl), a 
0fd4			 
0fd4			 
0fd4			;	ld (hl), a   ; save new char 
0fd4			 
0fd4 c3 69 0f			jp input_right 
0fd7			 
0fd7			;input_shiftright: 
0fd7			;	; shift text right at cursor, hl has shift start 
0fd7			;	push hl 
0fd7			;	push de 
0fd7			;	push bc 
0fd7			; 
0fd7			; 
0fd7			;	; move to end of string past zero term 
0fd7			;	ld hl,(input_start) 
0fd7			;	ld a, (input_len) 
0fd7			;	call addatohl 
0fd7			;	inc hl 
0fd7			;;	inc hl 
0fd7			;;	inc hl 
0fd7			;	ld a, 0 
0fd7			;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			;	 
0fd7			;;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			; 
0fd7			;	push hl 
0fd7			;	pop de 
0fd7			;	inc de 
0fd7			;	 
0fd7			; 
0fd7			;;	ld hl,(input_start) 
0fd7			;;	ld a, (input_cursor) 
0fd7			;;	call addatohl 
0fd7			; 
0fd7			; 
0fd7			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd7			;	call input_lenrem    ; get bc length of remaining string 
0fd7			;	;ld a, (input_cursor) 
0fd7			;	;ld c, a 
0fd7			;	ld a, (input_len) 
0fd7			;	cp 2 
0fd7			;	jr z, .iskipzero	 
0fd7			;	;sub c 
0fd7			;	;inc a 
0fd7			;	;ld c, a 
0fd7			;	;ld b, 0 
0fd7			;	inc c 
0fd7			;	inc c 
0fd7			;	; move data 
0fd7			;	lddr 
0fd7			;.iskipzero: 
0fd7			; 
0fd7			;	pop bc 
0fd7			;	pop de 
0fd7			;	pop hl 
0fd7			;	ret	 
0fd7			 
0fd7			input_delchar: 
0fd7				; Delete char at cursor position 
0fd7 cd 93 0f			call input_lenrem    ; get bc length of remaining string 
0fda 2a 61 ee			ld hl, (input_start) 
0fdd 3a 4f ee			ld a, (input_cursor) 
0fe0 cd f5 0d			call addatohl 
0fe3			 
0fe3 e5				push hl 
0fe4 d1				pop de 
0fe5 1b				dec de 
0fe6			 
0fe6			.dl:	 
0fe6 ed a0			ldi  
0fe8 7e				ld a, (hl) 
0fe9 fe 00			cp 0 
0feb 28 02			jr z, .dldone 
0fed 18 f7			jr .dl 
0fef			.dldone: 
0fef ed a0			ldi 
0ff1			 
0ff1 c3 62 0f			jp input_left 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			 
0ff4			 
0ff4			 
0ff4			if EDIT_V1 
0ff4			input_str: 
0ff4			 
0ff4				    	ld (input_at_pos),a      ; save display position to start 
0ff4					add c 
0ff4					ld (input_at_cursor),a	; save draw pos of cursor 
0ff4					ld (input_start), hl     ; save ptr to buffer 
0ff4					ld a, c 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff4					ld a,d 
0ff4				        ld (input_size), a       ; save length of input area 
0ff4					ld a, c 
0ff4					ld (input_cursor),a      ; init cursor start position  
0ff4					ld a,e 
0ff4				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff4					 
0ff4					 
0ff4			 
0ff4			;		ld a,(input_ptr) 
0ff4			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff4			 
0ff4			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff4					; init cursor shape if not set by the cin routines 
0ff4					ld hl, cursor_shape 
0ff4			if BASE_KEV 
0ff4					ld a, 255 
0ff4			else 
0ff4					ld a, '#' 
0ff4			endif 
0ff4					ld (hl), a 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl), a 
0ff4			 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					ld a, 1 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'I' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4			.is1:		; main entry loop 
0ff4			 
0ff4			 
0ff4			 
0ff4					; pause 1ms 
0ff4			 
0ff4					ld a, 1 
0ff4					call aDelayInMS 
0ff4			 
0ff4					; dec flash counter 
0ff4					ld a, (input_cur_flash) 
0ff4					dec a 
0ff4					ld (input_cur_flash), a 
0ff4					cp 0 
0ff4					jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4					ld a,(input_cur_onoff) 
0ff4					neg 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			 
0ff4					; reset on change of state 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4			.nochgstate: 
0ff4					 
0ff4					 
0ff4			 
0ff4					; display cursor  
0ff4			 
0ff4			;		ld hl, (input_start) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			 
0ff4					; get char under cursor and replace with cursor 
0ff4			ld hl, (input_ptr) 
0ff4			;		ld a, (hl) 
0ff4			;		ld (input_under_cursor),a 
0ff4			;		ld a, '_' 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					; display string 
0ff4			 
0ff4					ld de, (input_start) 
0ff4					ld a, (input_at_pos) 
0ff4					call str_at_display 
0ff4			;	        call update_display 
0ff4			 
0ff4					; find place to put the cursor 
0ff4			;		add h 
0ff4			;		ld l, display_row_1 
0ff4			;		sub l 
0ff4			; (input_at_pos) 
0ff4					;ld c, a 
0ff4			;		ld a, (input_cursor) 
0ff4			;		ld l, (input_at_pos) 
0ff4			;		;ld b, h 
0ff4			;		add l 
0ff4			;		ld (input_at_cursor),a 
0ff4					;ld l,h 
0ff4			 
0ff4			;		ld h, 0 
0ff4			;		ld l,(input_at_pos) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff4			;		call subafromhl 
0ff4			;		ld a,l 
0ff4			;		ld (input_at_cursor), a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					ld a, (hardware_diag) 
0ff4					cp 0 
0ff4					jr z, .skip_input_diag 
0ff4			 
0ff4					ld a,(input_at_pos) 
0ff4					ld hl, LFSRSeed 
0ff4					call hexout 
0ff4					ld a, (input_cursor) 
0ff4					ld hl, LFSRSeed+2 
0ff4					call hexout 
0ff4					ld a,(input_at_cursor) 
0ff4					ld hl, LFSRSeed+4 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_onoff) 
0ff4					ld hl, LFSRSeed+6 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_flash) 
0ff4					ld hl, LFSRSeed+8 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_len) 
0ff4					ld hl, LFSRSeed+10 
0ff4					call hexout 
0ff4					ld hl, LFSRSeed+12 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4					ld a, display_row_4 
0ff4					ld de, LFSRSeed 
0ff4					call str_at_display 
0ff4					.skip_input_diag: 
0ff4				endif 
0ff4			 
0ff4					; decide on if we are showing the cursor this time round 
0ff4			 
0ff4					ld a, (input_cur_onoff) 
0ff4					cp 255 
0ff4					jr z, .skipcur 
0ff4			 
0ff4			 
0ff4					ld a,(input_at_cursor) 
0ff4					ld de, cursor_shape 
0ff4					call str_at_display 
0ff4			 
0ff4					; save length of current input string 
0ff4					ld hl, (input_start) 
0ff4					ld a, 0 
0ff4					call strlent 
0ff4					ld a,l 
0ff4					ld (input_len),a 
0ff4			 
0ff4			.skipcur: 
0ff4			 
0ff4				        call update_display 
0ff4					 
0ff4			 
0ff4			 
0ff4					; wait 
0ff4				 
0ff4					; TODO loop without wait to flash the cursor and char under cursor	 
0ff4					call cin    ; _wait 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 
0ff4			 
0ff4					; get ptr to char to input into 
0ff4			 
0ff4					ld c,a 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_cursor) 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl 
0ff4					ld a,c 
0ff4			 
0ff4					; replace char under cursor 
0ff4			 
0ff4			;		ld hl, (input_ptr) 
0ff4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff4			;		ld (hl), a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'i' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					cp KEY_HOME 
0ff4					jr nz, .iske 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor),a 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					jp .is1 
0ff4					 
0ff4			.iske:		cp KEY_END 
0ff4					jr nz, .isknw 
0ff4					jp .is1 
0ff4			 
0ff4			.isknw:		cp KEY_NEXTWORD 
0ff4					jr nz, .iskpw 
0ff4			 
0ff4			.isknwm:	ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0 
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .isknwm 
0ff4			 
0ff4			.iskpw:		cp KEY_PREVWORD 
0ff4					jr nz, .iskl 
0ff4			.iskpwm:	 
0ff4					ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0  
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .iskpwm 
0ff4			 
0ff4			 
0ff4			.iskl:		cp KEY_LEFT 
0ff4					jr nz, .isk1 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk1:		cp KEY_RIGHT 
0ff4					jr nz, .isk2 
0ff4			 
0ff4					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff4					ld e,a 
0ff4					ld a, (input_cursor) 
0ff4					cp e 
0ff4					jp z, .is1		; at the end of string so dont go right 
0ff4			 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk2:		cp KEY_UP 
0ff4			 
0ff4					jr nz, .isk3 
0ff4			 
0ff4					; swap last command with the current on 
0ff4			 
0ff4					; move cursor to start of string 
0ff4					ld hl, (input_start) 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					 
0ff4					; swap input and last command buffers 
0ff4			 
0ff4					ld hl, os_cli_cmd 
0ff4					ld de, os_last_cmd 
0ff4					ld b, 255 
0ff4			.swap1:		ld a, (hl) 
0ff4					ld c,a 
0ff4					ld a, (de) 
0ff4					ld (hl), a 
0ff4					ld a,c 
0ff4					ld (de),a 
0ff4					inc hl 
0ff4					inc de 
0ff4					djnz .swap1 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk3:		cp KEY_BS 
0ff4					jr nz, .isk4 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					; hl is source 
0ff4					; de needs to be source - 1 
0ff4			 
0ff4			;		ld a, 0 
0ff4			;		dec hl 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					; shift all data 
0ff4			 
0ff4					push hl 
0ff4					inc hl 
0ff4					pop de 
0ff4					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff4					ld c,a 
0ff4					ld b,0 
0ff4					ldir  
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					; remove char 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld de,.iblank 
0ff4					call str_at_display 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk4:		cp KEY_CR 
0ff4					jr z, .endinput 
0ff4			 
0ff4					; else add the key press to the end 
0ff4			 
0ff4					ld c, a			; save key pressed 
0ff4			 
0ff4					ld a,(hl)		; get what is currently under char 
0ff4			 
0ff4					cp 0			; we are at the end of the string 
0ff4					jr nz, .onchar 
0ff4					 
0ff4					; add a char to the end of the string 
0ff4				 
0ff4					ld (hl),c 
0ff4					inc hl 
0ff4			;		ld a,' ' 
0ff4			;		ld (hl),a 
0ff4			;		inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					dec hl 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc a				; TODO check max string length and scroll  
0ff4					ld (input_cursor), a		; inc cursor pos 
0ff4							 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, '+' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					jp .is1 
0ff4					 
0ff4			 
0ff4			 
0ff4					; if on a char then insert 
0ff4			.onchar: 
0ff4			 
0ff4					; TODO over flow check: make sure insert does not blow out buffer 
0ff4			 
0ff4					; need to do some maths to use lddr 
0ff4			 
0ff4					push hl   ; save char pos 
0ff4					push bc 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_len) 
0ff4					call addatohl  		; end of string 
0ff4					inc hl 
0ff4					inc hl		; past zero term 
0ff4					push hl 
0ff4					inc hl 
0ff4					push hl  
0ff4			 
0ff4								; start and end of lddr set, now how much to move? 
0ff4			 
0ff4							 
0ff4					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff4					ld b,a 
0ff4					ld a,(input_len) 
0ff4					ld e,a 
0ff4					sub b 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4			 
0ff4					ld b,0 
0ff4					ld c,a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'i' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					pop de 
0ff4					pop hl 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'I' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					lddr 
0ff4				 
0ff4			 
0ff4			 
0ff4					; TODO have a key for insert/overwrite mode???? 
0ff4					pop bc 
0ff4					pop hl 
0ff4					ld (hl), c		; otherwise overwrite current char 
0ff4					 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.endinput:	; TODO look for end of string 
0ff4			 
0ff4					; add trailing space for end of token 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a,(input_len) 
0ff4					call addatohl 
0ff4					ld a, ' ' 
0ff4					ld (hl),a 
0ff4					; TODO eof of parse marker 
0ff4			 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					ret 
0ff4			 
0ff4			.iblank: db " ",0 
0ff4			 
0ff4			 
0ff4			input_str_prev:	ld (input_at_pos), a 
0ff4					ld (input_start), hl 
0ff4					ld a,1			; add cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					ld (input_ptr), hl 
0ff4					ld a,d 
0ff4					ld (input_size), a 
0ff4					ld a,0 
0ff4					ld (input_cursor),a 
0ff4			.instr1:	 
0ff4			 
0ff4					; TODO do block cursor 
0ff4					; TODO switch cursor depending on the modifer key 
0ff4			 
0ff4					; update cursor shape change on key hold 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl), a 
0ff4			 
0ff4					; display entered text 
0ff4					ld a,(input_at_pos) 
0ff4			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff4			            	LD   de, (input_start) 
0ff4			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff4			 
0ff4					call cin 
0ff4					cp 0 
0ff4					jr z, .instr1 
0ff4			 
0ff4					; proecess keyboard controls first 
0ff4			 
0ff4					ld hl,(input_ptr) 
0ff4			 
0ff4					cp KEY_CR	 ; pressing enter ends input 
0ff4					jr z, .instrcr 
0ff4			 
0ff4					cp KEY_BS 	; back space 
0ff4					jr nz, .instr2 
0ff4					; process back space 
0ff4			 
0ff4					; TODO stop back space if at start of string 
0ff4					dec hl 
0ff4					dec hl ; to over write cursor 
0ff4					ld a,(cursor_shape) 
0ff4					;ld a,0 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a," " 
0ff4					ld (hl),a 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4			 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr2:	cp KEY_LEFT    ; cursor left 
0ff4					jr nz, .instr3 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4				 
0ff4			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff4					jr nz, .instr4 
0ff4					inc hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff4					jr nz, .instr5 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr5:	cp KEY_END     ; jump to end of line 
0ff4					jr nz, .instr6 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			.instr6:        cp KEY_UP      ; recall last command 
0ff4					jr nz, .instrnew 
0ff4			 
0ff4				ld hl, scratch 
0ff4				ld de, os_last_cmd 
0ff4				call strcpy 
0ff4					jr .instr1 
0ff4			 
0ff4			 
0ff4			.instrnew:	; no special key pressed to see if we have room to store it 
0ff4			 
0ff4					; TODO do string size test 
0ff4			 
0ff4					dec hl ; to over write cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4					jr .instr1 
0ff4			.instrcr:	dec hl		; remove cursor 
0ff4					ld a,' '	; TODO add a trailing space for safety 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					; if at end of line scroll up    
0ff4					; TODO detecting only end of line 4 for scroll up  
0ff4			 
0ff4					;ld   
0ff4			 
0ff4					ret 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			; strcpy hl = dest, de source 
0ff4			 
0ff4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff5 b7			            OR   A              ;Null terminator? 
0ff6 c8			            RET  Z              ;Yes, so finished 
0ff7 1a					ld a,(de) 
0ff8 77					ld (hl),a 
0ff9 13			            INC  DE             ;Point to next character 
0ffa 23					inc hl 
0ffb 18 f7		            JR   strcpy       ;Repeat 
0ffd c9					ret 
0ffe			 
0ffe			 
0ffe			; TODO string_at  
0ffe			; pass string which starts with lcd offset address and then null term string 
0ffe			 
0ffe			; TODO string to dec 
0ffe			; TODO string to hex 
0ffe			; TODO byte to string hex 
0ffe			; TODO byte to string dec 
0ffe			 
0ffe			 
0ffe			 
0ffe			; from z80uartmonitor 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffe			; pass hl for where to put the text 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe c5			hexout:	PUSH BC 
0fff f5					PUSH AF 
1000 47					LD B, A 
1001					; Upper nybble 
1001 cb 3f				SRL A 
1003 cb 3f				SRL A 
1005 cb 3f				SRL A 
1007 cb 3f				SRL A 
1009 cd 19 10				CALL tohex 
100c 77					ld (hl),a 
100d 23					inc hl	 
100e					 
100e					; Lower nybble 
100e 78					LD A, B 
100f e6 0f				AND 0FH 
1011 cd 19 10				CALL tohex 
1014 77					ld (hl),a 
1015 23					inc hl	 
1016					 
1016 f1					POP AF 
1017 c1					POP BC 
1018 c9					RET 
1019					 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			tohex: 
1019 e5					PUSH HL 
101a d5					PUSH DE 
101b 16 00				LD D, 0 
101d 5f					LD E, A 
101e 21 26 10				LD HL, .DATA 
1021 19					ADD HL, DE 
1022 7e					LD A, (HL) 
1023 d1					POP DE 
1024 e1					POP HL 
1025 c9					RET 
1026			 
1026			.DATA: 
1026 30					DEFB	30h	; 0 
1027 31					DEFB	31h	; 1 
1028 32					DEFB	32h	; 2 
1029 33					DEFB	33h	; 3 
102a 34					DEFB	34h	; 4 
102b 35					DEFB	35h	; 5 
102c 36					DEFB	36h	; 6 
102d 37					DEFB	37h	; 7 
102e 38					DEFB	38h	; 8 
102f 39					DEFB	39h	; 9 
1030 41					DEFB	41h	; A 
1031 42					DEFB	42h	; B 
1032 43					DEFB	43h	; C 
1033 44					DEFB	44h	; D 
1034 45					DEFB	45h	; E 
1035 46					DEFB	46h	; F 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1036			;;    subtract $30, if result > 9 then subtract $7 more 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			atohex: 
1036 d6 30				SUB $30 
1038 fe 0a				CP 10 
103a f8					RET M		; If result negative it was 0-9 so we're done 
103b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103d c9					RET		 
103e			 
103e			 
103e			 
103e			 
103e			; Get 2 ASCII characters as hex byte from pointer in hl 
103e			 
103e			BYTERD: 
103e 16 00			LD	D,00h		;Set up 
1040 cd 48 10			CALL	HEXCON		;Get byte and convert to hex 
1043 87				ADD	A,A		;First nibble so 
1044 87				ADD	A,A		;multiply by 16 
1045 87				ADD	A,A		; 
1046 87				ADD	A,A		; 
1047 57				LD	D,A		;Save hi nibble in D 
1048			HEXCON: 
1048 7e				ld a, (hl)		;Get next chr 
1049 23				inc hl 
104a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
104c fe 0a			CP	00Ah		;Is it 0-9 ? 
104e 38 02			JR	C,NALPHA	;If so miss next bit 
1050 d6 07			SUB	007h		;Else convert alpha 
1052			NALPHA: 
1052 b2				OR	D		;Add hi nibble back 
1053 c9				RET			; 
1054			 
1054			 
1054			; 
1054			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1054			; Since the routines get_byte and therefore get_nibble are called, only valid 
1054			; characters (0-9a-f) are accepted. 
1054			; 
1054			;get_word        push    af 
1054			;                call    get_byte        ; Get the upper byte 
1054			;                ld      h, a 
1054			;                call    get_byte        ; Get the lower byte 
1054			;                ld      l, a 
1054			;                pop     af 
1054			;                ret 
1054			; 
1054			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1054			; the routine get_nibble is used only valid characters are accepted - the  
1054			; input routine only accepts characters 0-9a-f. 
1054			; 
1054 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1055 7e					ld a,(hl) 
1056 23					inc hl 
1057 cd 7c 10		                call    nibble2val      ; Get upper nibble 
105a cb 07		                rlc     a 
105c cb 07		                rlc     a 
105e cb 07		                rlc     a 
1060 cb 07		                rlc     a 
1062 47			                ld      b, a            ; Save upper four bits 
1063 7e					ld a,(hl) 
1064 cd 7c 10		                call    nibble2val      ; Get lower nibble 
1067 b0			                or      b               ; Combine both nibbles 
1068 c1			                pop     bc              ; Restore B (and C) 
1069 c9			                ret 
106a			; 
106a			; Get a hexadecimal digit from the serial line. This routine blocks until 
106a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
106a			; to the serial line interface. The lower 4 bits of A contain the value of  
106a			; that particular digit. 
106a			; 
106a			;get_nibble      ld a,(hl)           ; Read a character 
106a			;                call    to_upper        ; Convert to upper case 
106a			;                call    is_hex          ; Was it a hex digit? 
106a			;                jr      nc, get_nibble  ; No, get another character 
106a			 ;               call    nibble2val      ; Convert nibble to value 
106a			 ;               call    print_nibble 
106a			 ;               ret 
106a			; 
106a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
106a			; A valid hexadecimal digit is denoted by a set C flag. 
106a			; 
106a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
106a			;                ret     nc              ; Yes 
106a			;                cp      '0'             ; Less than '0'? 
106a			;                jr      nc, is_hex_1    ; No, continue 
106a			;                ccf                     ; Complement carry (i.e. clear it) 
106a			;                ret 
106a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
106a			;                ret     c               ; Yes 
106a			;                cp      'A'             ; Less than 'A'? 
106a			;                jr      nc, is_hex_2    ; No, continue 
106a			;                ccf                     ; Yes - clear carry and return 
106a			;                ret 
106a			;is_hex_2        scf                     ; Set carry 
106a			;                ret 
106a			; 
106a			; Convert a single character contained in A to upper case: 
106a			; 
106a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
106c d8			                ret     c 
106d fe 7b		                cp      'z' + 1         ; > 'z'? 
106f d0			                ret     nc              ; Nothing to do, either 
1070 e6 5f		                and     $5f             ; Convert to upper case 
1072 c9			                ret 
1073			 
1073			 
1073			to_lower: 
1073			 
1073			   ; if char is in [A-Z] make it lower case 
1073			 
1073			   ; enter : a = char 
1073			   ; exit  : a = lower case char 
1073			   ; uses  : af 
1073			 
1073 fe 41		   cp 'A' 
1075 d8			   ret c 
1076			    
1076 fe 5b		   cp 'Z'+1 
1078 d0			   ret nc 
1079			    
1079 f6 20		   or $20 
107b c9			   ret 
107c			 
107c			; 
107c			; Expects a hexadecimal digit (upper case!) in A and returns the 
107c			; corresponding value in A. 
107c			; 
107c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107e 38 02		                jr      c, nibble2val_1 ; Yes 
1080 d6 07		                sub     7               ; Adjust for A-F 
1082 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1084 e6 0f		                and     $f              ; Only return lower 4 bits 
1086 c9			                ret 
1087			; 
1087			; Print_nibble prints a single hex nibble which is contained in the lower  
1087			; four bits of A: 
1087			; 
1087			;print_nibble    push    af              ; We won't destroy the contents of A 
1087			;                and     $f              ; Just in case... 
1087			;                add     a, '0'             ; If we have a digit we are done here. 
1087			;                cp      '9' + 1         ; Is the result > 9? 
1087			;                jr      c, print_nibble_1 
1087			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1087			;print_nibble_1  call    putc            ; Print the nibble and 
1087			;                pop     af              ; restore the original value of A 
1087			;                ret 
1087			;; 
1087			;; Send a CR/LF pair: 
1087			; 
1087			;crlf            push    af 
1087			;                ld      a, cr 
1087			;                call    putc 
1087			;                ld      a, lf 
1087			;                call    putc 
1087			;                pop     af 
1087			;                ret 
1087			; 
1087			; Print_word prints the four hex digits of a word to the serial line. The  
1087			; word is expected to be in HL. 
1087			; 
1087			;print_word      push    hl 
1087			;                push    af 
1087			;                ld      a, h 
1087			;                call    print_byte 
1087			;                ld      a, l 
1087			;                call    print_byte 
1087			;                pop     af 
1087			;                pop     hl 
1087			;                ret 
1087			; 
1087			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1087			; The byte to be printed is expected to be in A. 
1087			; 
1087			;print_byte      push    af              ; Save the contents of the registers 
1087			;                push    bc 
1087			;                ld      b, a 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                call    print_nibble    ; Print high nibble 
1087			;                ld      a, b 
1087			;                call    print_nibble    ; Print low nibble 
1087			;                pop     bc              ; Restore original register contents 
1087			;                pop     af 
1087			;                ret 
1087			 
1087			 
1087			 
1087			 
1087			 
1087			fourehexhl:  
1087 7e				ld a,(hl) 
1088 cd 36 10			call atohex 
108b cb 3f				SRL A 
108d cb 3f				SRL A 
108f cb 3f				SRL A 
1091 cb 3f				SRL A 
1093 47				ld b, a 
1094 23				inc hl 
1095 7e				ld a,(hl) 
1096 23				inc hl 
1097 cd 36 10			call atohex 
109a 80				add b 
109b 57				ld d,a 
109c 7e				ld a,(hl) 
109d cd 36 10			call atohex 
10a0 cb 3f				SRL A 
10a2 cb 3f				SRL A 
10a4 cb 3f				SRL A 
10a6 cb 3f				SRL A 
10a8 47				ld b, a 
10a9 23				inc hl 
10aa 7e				ld a,(hl) 
10ab 23				inc hl 
10ac cd 36 10			call atohex 
10af 80				add b 
10b0 5f				ld e, a 
10b1 d5				push de 
10b2 e1				pop hl 
10b3 c9				ret 
10b4			 
10b4			; pass hl. returns z set if the byte at hl is a digit 
10b4			;isdigithl:  
10b4			;	push bc 
10b4			;	ld a,(hl) 
10b4			;	cp ':' 
10b4			;	jr nc, .isdf 		; > 
10b4			;	cp '0' 
10b4			;	jr c, .isdf		; < 
10b4			; 
10b4			;	; TODO find a better way to set z 
10b4			; 
10b4			;	ld b,a 
10b4			;	cp b 
10b4			;	pop bc 
10b4			;	ret 
10b4			; 
10b4			;.isdf:	; not digit so clear z 
10b4			; 
10b4			;	; TODO find a better way to unset z 
10b4			; 
10b4			;	ld b,a 
10b4			;	inc b 
10b4			;	cp b 
10b4			; 
10b4			;	pop bc 
10b4			;	ret 
10b4				 
10b4				 
10b4			 
10b4			 
10b4			; pass hl as the four byte address to load 
10b4			 
10b4			get_word_hl:  
10b4 e5				push hl 
10b5 cd 54 10			call get_byte 
10b8				 
10b8 47				ld b, a 
10b9			 
10b9 e1				pop hl 
10ba 23				inc hl 
10bb 23				inc hl 
10bc			 
10bc			; TODO not able to handle a-f  
10bc 7e				ld a,(hl) 
10bd			;	;cp ':' 
10bd			;	cp 'g' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp 'G' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .single_byte_hl		; < 
10bd			 
10bd				;call isdigithl 
10bd fe 00			cp 0 
10bf 28 06			jr z, .single_byte_hl 
10c1			 
10c1			.getwhln:   ; hex word so get next byte 
10c1			 
10c1 cd 54 10			call get_byte 
10c4 6f				ld l, a 
10c5 60				ld h,b 
10c6 c9				ret 
10c7 68			.single_byte_hl:   ld l,b 
10c8 26 00				ld h,0 
10ca c9					ret 
10cb			 
10cb			 
10cb			 
10cb			 
10cb 21 6b 18			ld hl,asc+1 
10ce			;	ld a, (hl) 
10ce			;	call nibble2val 
10ce cd 54 10			call get_byte 
10d1			 
10d1			;	call fourehexhl 
10d1 32 ef e2			ld (scratch+52),a 
10d4				 
10d4 21 ed e2			ld hl,scratch+50 
10d7 22 de e5			ld (os_cur_ptr),hl 
10da			 
10da c9				ret 
10db			 
10db			 
10db			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10db			 
10db			; Decimal Unsigned Version 
10db			 
10db			;Number in a to decimal ASCII 
10db			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10db			;Example: display a=56 as "056" 
10db			;input: a = number 
10db			;Output: a=0,value of a in the screen 
10db			;destroys af,bc (don't know about hl and de) 
10db			DispAToASCII: 
10db 0e 9c			ld	c,-100 
10dd cd e7 10			call	.Na1 
10e0 0e f6			ld	c,-10 
10e2 cd e7 10			call	.Na1 
10e5 0e ff			ld	c,-1 
10e7 06 2f		.Na1:	ld	b,'0'-1 
10e9 04			.Na2:	inc	b 
10ea 81				add	a,c 
10eb 38 fc			jr	c,.Na2 
10ed 91				sub	c		;works as add 100/10/1 
10ee f5				push af		;safer than ld c,a 
10ef 78				ld	a,b		;char is in b 
10f0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f0 f1				pop af		;safer than ld a,c 
10f1 c9				ret 
10f2			 
10f2			; Decimal Signed Version 
10f2			 
10f2			; DispA 
10f2			; -------------------------------------------------------------- 
10f2			; Converts a signed integer value to a zero-terminated ASCII 
10f2			; string representative of that value (using radix 10). 
10f2			; -------------------------------------------------------------- 
10f2			; INPUTS: 
10f2			;     HL     Value to convert (two's complement integer). 
10f2			;     DE     Base address of string destination. (pointer). 
10f2			; -------------------------------------------------------------- 
10f2			; OUTPUTS: 
10f2			;     None 
10f2			; -------------------------------------------------------------- 
10f2			; REGISTERS/MEMORY DESTROYED 
10f2			; AF HL 
10f2			; -------------------------------------------------------------- 
10f2			 
10f2			;DispHLToASCII: 
10f2			;   push    de 
10f2			;   push    bc 
10f2			; 
10f2			;; Detect sign of HL. 
10f2			;    bit    7, h 
10f2			;    jr     z, ._DoConvert 
10f2			; 
10f2			;; HL is negative. Output '-' to string and negate HL. 
10f2			;    ld     a, '-' 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			; 
10f2			;; Negate HL (using two's complement) 
10f2			;    xor    a 
10f2			;    sub    l 
10f2			;    ld     l, a 
10f2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f2			;    sbc    a, h 
10f2			;    ld     h, a 
10f2			; 
10f2			;; Convert HL to digit characters 
10f2			;._DoConvert: 
10f2			;    ld     b, 0     ; B will count character length of number 
10f2			;-   ld     a, 10 
10f2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f2			;    push   af 
10f2			;    inc    b 
10f2			;    ld     a, h 
10f2			;    or     l 
10f2			;    jr     nz, - 
10f2			; 
10f2			;; Retrieve digits from stack 
10f2			;-   pop    af 
10f2			;    or     $30 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			;    djnz   - 
10f2			; 
10f2			;; Terminate string with NULL 
10f2			;    xor    a 
10f2			;    ld     (de), a 
10f2			; 
10f2			;    pop    bc 
10f2			;    pop    de 
10f2			;    ret 
10f2			 
10f2			;Comments 
10f2			; 
10f2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f2			;    Note that the output string will not be fixed-width. 
10f2			; 
10f2			;Example Usage 
10f2			; 
10f2			;    ld    hl, -1004 
10f2			;    ld    de, OP1 
10f2			;    call  DispA 
10f2			;    ld    hl, OP1 
10f2			;    syscall  PutS 
10f2			 
10f2			 
10f2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f2			 
10f2			 
10f2			;Converts an ASCII string to an unsigned 16-bit integer 
10f2			;Quits when it reaches a non-decimal digit 
10f2			 
10f2			string_to_uint16: 
10f2			atoui_16: 
10f2			;Input: 
10f2			;     DE points to the string 
10f2			;Outputs: 
10f2			;     HL is the result 
10f2			;     A is the 8-bit value of the number 
10f2			;     DE points to the byte after the number 
10f2			;Destroys: 
10f2			;     BC 
10f2			;       if the string is non-empty, BC is HL/10 
10f2			;Size:  24 bytes 
10f2			;Speed: 42+d(104+{0,9}) 
10f2			;       d is the number of digits in the number 
10f2			;       max is 640 cycles for a 5 digit number 
10f2			;Assuming no leading zeros: 
10f2			;1 digit:  146cc 
10f2			;2 digit:  250cc 
10f2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f2			;avg: 544.81158447265625cc (544+13297/16384) 
10f2			;=============================================================== 
10f2 21 00 00		  ld hl,0 
10f5			.u16a: 
10f5 1a			  ld a,(de) 
10f6 d6 30		  sub 30h 
10f8 fe 0a		  cp 10 
10fa d0			  ret nc 
10fb 13			  inc de 
10fc 44			  ld b,h 
10fd 4d			  ld c,l 
10fe 29			  add hl,hl 
10ff 29			  add hl,hl 
1100 09			  add hl,bc 
1101 29			  add hl,hl 
1102 85			  add a,l 
1103 6f			  ld l,a 
1104 30 ef		  jr nc,.u16a 
1106 24			  inc h 
1107 c3 f5 10		  jp .u16a 
110a			 
110a			 
110a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110a			 
110a			;written by Zeda 
110a			;Converts a 16-bit unsigned integer to an ASCII string. 
110a			 
110a			uitoa_16: 
110a			;Input: 
110a			;   DE is the number to convert 
110a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
110a			;Output: 
110a			;   HL points to the null-terminated ASCII string 
110a			;      NOTE: This isn't necessarily the same as the input HL. 
110a d5			  push de 
110b c5			  push bc 
110c f5			  push af 
110d eb			  ex de,hl 
110e			 
110e 01 f0 d8		  ld bc,-10000 
1111 3e 2f		  ld a,'0'-1 
1113 3c			  inc a 
1114 09			  add hl,bc  
1115 38 fc		   jr c,$-2 
1117 12			  ld (de),a 
1118 13			  inc de 
1119			 
1119 01 e8 03		  ld bc,1000 
111c 3e 3a		  ld a,'9'+1 
111e 3d			  dec a  
111f 09			  add hl,bc  
1120 30 fc		   jr nc,$-2 
1122 12			  ld (de),a 
1123 13			  inc de 
1124			 
1124 01 9c ff		  ld bc,-100 
1127 3e 2f		  ld a,'0'-1 
1129 3c			  inc a  
112a 09			  add hl,bc  
112b 38 fc		   jr c,$-2 
112d 12			  ld (de),a 
112e 13			  inc de 
112f			 
112f 7d			  ld a,l 
1130 26 3a		  ld h,'9'+1 
1132 25			  dec h  
1133 c6 0a		  add a,10  
1135 30 fb		   jr nc,$-3 
1137 c6 30		  add a,'0' 
1139 eb			  ex de,hl 
113a 72			  ld (hl),d 
113b 23			  inc hl 
113c 77			  ld (hl),a 
113d 23			  inc hl 
113e 36 00		  ld (hl),0 
1140			 
1140			;Now strip the leading zeros 
1140 0e fa		  ld c,-6 
1142 09			  add hl,bc 
1143 3e 30		  ld a,'0' 
1145 23			  inc hl  
1146 be			  cp (hl)  
1147 28 fc		  jr z,$-2 
1149			 
1149			;Make sure that the string is non-empty! 
1149 7e			  ld a,(hl) 
114a b7			  or a 
114b 20 01		  jr nz,.atoub 
114d 2b			  dec hl 
114e			.atoub: 
114e			 
114e f1			  pop af 
114f c1			  pop bc 
1150 d1			  pop de 
1151 c9			  ret 
1152			 
1152			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1152			 
1152			toUpper: 
1152			;A is the char. 
1152			;If A is a lowercase letter, this sets it to the matching uppercase 
1152			;18cc or 30cc or 41cc 
1152			;avg: 26.75cc 
1152 fe 61		  cp 'a' 
1154 d8			  ret c 
1155 fe 7b		  cp 'z'+1 
1157 d0			  ret nc 
1158 d6 20		  sub 'a'-'A' 
115a c9			  ret 
115b			 
115b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
115b			 
115b			; String Length 
115b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
115b			 
115b			; Get the length of the null-terminated string starting at $8000 hl 
115b			;    LD     HL, $8000 
115b			 
115b			strlenz: 
115b			 
115b af			    XOR    A               ; Zero is the value we are looking for. 
115c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115e			                           ; 65, 536 bytes (the entire addressable memory space). 
115e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1160			 
1160			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1160 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1161 6f			    LD     L, A             ; number of bytes 
1162 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1164 2b			    DEC    HL              ; Compensate for null. 
1165 c9				ret 
1166			 
1166			; Get the length of the A terminated string starting at $8000 hl 
1166			;    LD     HL, $8000 
1166			 
1166			strlent: 
1166			 
1166			                  ; A is the value we are looking for. 
1166 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1168 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116e 2e 00		    LD     L, 0             ; number of bytes 
1170 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1172 2b			    DEC    HL              ; Compensate for null. 
1173 c9				ret 
1174			 
1174			 
1174			;Comparing Strings 
1174			 
1174			;IN    HL     Address of string1. 
1174			;      DE     Address of string2. 
1174			 
1174			; doc given but wrong??? 
1174			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1174			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1174			; tested 
1174			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1174			 
1174			strcmp_old: 
1174 e5			    PUSH   HL 
1175 d5			    PUSH   DE 
1176			 
1176 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1177 be			    CP     (HL)            ; (want to minimize work). 
1178 38 01		    JR     C, Str1IsBigger 
117a 7e			    LD     A, (HL) 
117b			 
117b			Str1IsBigger: 
117b 4f			    LD     C, A             ; Put length in BC 
117c 06 00		    LD     B, 0 
117e 13			    INC    DE              ; Increment pointers to meat of string. 
117f 23			    INC    HL 
1180			 
1180			CmpLoop: 
1180 1a			    LD     A, (DE)          ; Compare bytes. 
1181 ed a1		    CPI 
1183 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1185 13			    INC    DE              ; Update pointer. 
1186 ea 80 11		    JP     PE, CmpLoop 
1189			 
1189 d1			    POP    DE 
118a e1			    POP    HL 
118b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
118c be			    CP     (HL) 
118d c9			    RET 
118e			 
118e			NoMatch: 
118e 2b			    DEC    HL 
118f be			    CP     (HL)            ; Compare again to affect carry. 
1190 d1			    POP    DE 
1191 e1			    POP    HL 
1192 c9			    RET 
1193			 
1193			;; test strmp 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr z, .z1 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z1: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr z, .z2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr c, .c1 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c1: 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr c, .c2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;	NEXTW 
1193			;.str1:   db "string1",0 
1193			;.str2:   db "string2",0 
1193			 
1193			; only care about direct match or not 
1193			; hl and de strings 
1193			; zero set if the same 
1193			 
1193			strcmp: 
1193 1a				ld a, (de) 
1194 be				cp (hl) 
1195 28 02			jr z, .ssame 
1197 b7				or a 
1198 c9				ret 
1199			 
1199			.ssame:  
1199 fe 00			cp 0 
119b c8				ret z 
119c			 
119c 23				inc hl 
119d 13				inc de 
119e 18 f3			jr strcmp 
11a0				 
11a0				 
11a0			 
11a0			;Copyright (c) 2014, Luke Maurits 
11a0			;All rights reserved. 
11a0			; 
11a0			;Redistribution and use in source and binary forms, with or without 
11a0			;modification, are permitted provided that the following conditions are met: 
11a0			; 
11a0			;* Redistributions of source code must retain the above copyright notice, this 
11a0			;  list of conditions and the following disclaimer. 
11a0			; 
11a0			;* Redistributions in binary form must reproduce the above copyright notice, 
11a0			;  this list of conditions and the following disclaimer in the documentation 
11a0			;  and/or other materials provided with the distribution. 
11a0			; 
11a0			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
11a0			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
11a0			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
11a0			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
11a0			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
11a0			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
11a0			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
11a0			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
11a0			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
11a0			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
11a0			 
11a0			; https://github.com/lmaurits/lm512/blob/master/string.z80 
11a0			 
11a0			StrictStrCmp: 
11a0				; Load next chars of each string 
11a0 1a				ld a, (de) 
11a1 47				ld b, a 
11a2 7e				ld a, (hl) 
11a3				; Compare 
11a3 b8				cp b 
11a4				; Return non-zero if chars don't match 
11a4 c0				ret nz 
11a5				; Check for end of both strings 
11a5 fe 00			cp "\0" 
11a7				; Return if strings have ended 
11a7 c8				ret z 
11a8				; Otherwise, advance to next chars 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f4			jr StrictStrCmp 
11ac			 
11ac			;end 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				call bp_on 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 31 64		      ld    HL, heap_start 
11b0 22 2c 64		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 2e 64		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 92 e2		      ld    HL, heap_start+heap_size-4 
11bc 22 31 64		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 61 7e		      ld    HL, heap_size-4 
11c2 22 33 64		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 94 e2		      ld    (heap_start+heap_size-2), HL 
11cb 22 92 e2		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 2c 64		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 2c 64		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			; Now handled by SPI  
1369			;if SOUND_ENABLE  
1369			;	include "firmware_sound.asm"  
1369			;endif  
1369			  
1369			include "firmware_diags.asm"  
1369			; Hardware diags menu 
1369			 
1369			 
1369			config: 
1369			 
1369 3e 00			ld a, 0 
136b 21 8f 13			ld hl, .configmn 
136e cd f9 0b			call menu 
1371			 
1371 fe 00			cp 0 
1373 c8				ret z 
1374			 
1374			;	cp 1 
1374			;	call z, .savetostore 
1374			 
1374 fe 01			cp 1 
1376			if STARTUP_V1 
1376 cc a5 13			call z, .selautoload 
1379			endif 
1379			 
1379			if STARTUP_V2 
1379				call z, .enautoload 
1379			endif 
1379 fe 02			cp 2 
137b cc 9b 13			call z, .disautoload 
137e			;	cp 3 
137e			;	call z, .selbank 
137e fe 03			cp 3 
1380 cc c3 13			call z, .debug_tog 
1383 fe 04			cp 4 
1385 cc 11 15			call z, .bpsgo 
1388 fe 05			cp 5 
138a cc ec 13			call z, hardware_diags 
138d			if STARTUP_V2 
138d				cp 6 
138d				call z, create_startup 
138d			endif 
138d 18 da			jr config 
138f			 
138f			.configmn: 
138f			;	dw prom_c3 
138f ff 16			dw prom_c2 
1391 14 17			dw prom_c2a 
1393			;	dw prom_c2b 
1393			;	dw prom_c4 
1393 33 17			dw prom_m4 
1395 4e 17			dw prom_m4b 
1397 56 17			dw prom_c1 
1399			if STARTUP_V2 
1399				dw prom_c9 
1399			endif 
1399 00 00			dw 0 
139b				 
139b			 
139b			if STARTUP_V2 
139b			.enautoload: 
139b				if STORAGE_SE 
139b				ld a, $fe      ; bit 0 clear 
139b				ld (spi_device), a 
139b			 
139b				call storage_get_block_0 
139b			 
139b				ld a, 1 
139b				ld (store_page+STORE_0_AUTOFILE), a 
139b			 
139b					ld hl, 0 
139b					ld de, store_page 
139b				call storage_write_block	 ; save update 
139b				else 
139b			 
139b				ld hl, prom_notav 
139b				ld de, prom_empty 
139b				call info_panel 
139b				endif 
139b			 
139b			 
139b				ret 
139b			endif 
139b			 
139b			.disautoload: 
139b				if STORAGE_SE 
139b				ld a, $fe      ; bit 0 clear 
139b				ld (spi_device), a 
139b			 
139b				call storage_get_block_0 
139b			 
139b				ld a, 0 
139b				ld (store_page+STORE_0_AUTOFILE), a 
139b			 
139b					ld hl, 0 
139b					ld de, store_page 
139b				call storage_write_block	 ; save update 
139b				else 
139b			 
139b 21 65 17			ld hl, prom_notav 
139e 11 7b 17			ld de, prom_empty 
13a1 cd 59 0b			call info_panel 
13a4				endif 
13a4			 
13a4			 
13a4 c9				ret 
13a5			 
13a5			if STARTUP_V1 
13a5			 
13a5			; Select auto start 
13a5			 
13a5			.selautoload: 
13a5			 
13a5				 
13a5				if STORAGE_SE 
13a5			 
13a5					call config_dir 
13a5				        ld hl, scratch 
13a5					ld a, 0 
13a5					call menu 
13a5			 
13a5					cp 0 
13a5					ret z 
13a5			 
13a5					dec a 
13a5			 
13a5			 
13a5					; locate menu option 
13a5			 
13a5					ld hl, scratch 
13a5					call table_lookup 
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALl" 
13a5						CALLMONITOR 
13a5					endif 
13a5					; with the pointer to the menu it, the byte following the zero term is the file id 
13a5			 
13a5					ld a, 0 
13a5					ld bc, 50   ; max of bytes to look at 
13a5					cpir  
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALb" 
13a5						CALLMONITOR 
13a5					endif 
13a5					;inc hl 
13a5			 
13a5					ld a, (hl)   ; file id 
13a5					 
13a5				        ; save bank and file ids 
13a5			 
13a5					push af 
13a5			 
13a5			; TODO need to save to block 0 on bank 1	 
13a5			 
13a5					call storage_get_block_0 
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "AL0" 
13a5						CALLMONITOR 
13a5					endif 
13a5					pop af 
13a5			 
13a5					ld (store_page+STORE_0_FILERUN),a 
13a5					 
13a5					; save bank id 
13a5			 
13a5					ld a,(spi_device) 
13a5					ld (store_page+STORE_0_BANKRUN),a 
13a5			 
13a5					; enable auto run of store file 
13a5			 
13a5					ld a, 1 
13a5					ld (store_page+STORE_0_AUTOFILE),a 
13a5			 
13a5					; save buffer 
13a5			 
13a5					ld hl, 0 
13a5					ld de, store_page 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALw" 
13a5						CALLMONITOR 
13a5					endif 
13a5				call storage_write_block	 ; save update 
13a5			  
13a5			 
13a5			 
13a5			 
13a5					ld hl, scratch 
13a5					call config_fdir 
13a5			 
13a5				else 
13a5			 
13a5 21 65 17			ld hl, prom_notav 
13a8 11 7b 17			ld de, prom_empty 
13ab cd 59 0b			call info_panel 
13ae			 
13ae				endif 
13ae c9				ret 
13af			endif 
13af			 
13af			 
13af			; Select storage bank 
13af			 
13af			.selbank: 
13af			 
13af			;	if STORAGE_SE 
13af			;	else 
13af			 
13af 21 65 17			ld hl, prom_notav 
13b2 11 7b 17			ld de, prom_empty 
13b5 cd 59 0b			call info_panel 
13b8			;	endif 
13b8				 
13b8 c9				ret 
13b9			 
13b9			if STORAGE_SE 
13b9			 
13b9			.config_ldir:   
13b9				; Load storage bank labels into menu array 
13b9			 
13b9				 
13b9			 
13b9			 
13b9				ret 
13b9			 
13b9			 
13b9			endif 
13b9			 
13b9			 
13b9			; Save user words to storage 
13b9			 
13b9			.savetostore: 
13b9			 
13b9			;	if STORAGE_SE 
13b9			; 
13b9			;		call config_dir 
13b9			;	        ld hl, scratch 
13b9			;		ld a, 0 
13b9			;		call menu 
13b9			;		 
13b9			;		ld hl, scratch 
13b9			;		call config_fdir 
13b9			; 
13b9			;	else 
13b9			 
13b9 21 65 17			ld hl, prom_notav 
13bc 11 7b 17			ld de, prom_empty 
13bf cd 59 0b			call info_panel 
13c2			 
13c2			;	endif 
13c2			 
13c2 c9				ret 
13c3			 
13c3			if STARTUP_V2 
13c3			 
13c3			create_startup: 
13c3			 
13c3				ld a, 0 
13c3				ld hl, .crstart 
13c3				call menu 
13c3			 
13c3				cp 0 
13c3				ret z 
13c3			 
13c3				cp 1 
13c3				call z, .genlsword 
13c3				cp 2 
13c3				call z, .genedword 
13c3			 
13c3				cp 3 
13c3				call z, .gendemword 
13c3			 
13c3				cp 4 
13c3				call z, .genutlword 
13c3				cp 5 
13c3				call z, .genspiword 
13c3				cp 6 
13c3				call z, .genkeyword 
13c3				cp 7 
13c3				call z, .gensoundword 
13c3				cp 8 
13c3				call z, .genhwword 
13c3				jr create_startup 
13c3			 
13c3			.genhwword: 
13c3				ld hl, crs_hw 
13c3				ld de, .hwworddef 
13c3				call .genfile 
13c3				ret 
13c3			.gensoundword: 
13c3				ld hl, crs_sound 
13c3				ld de, .soundworddef 
13c3				call .genfile 
13c3				ret 
13c3			.genlsword: 
13c3				ld hl, crs_s1 
13c3				ld de, .lsworddef 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.genedword: 
13c3				ld de, .edworddef 
13c3				ld hl, crs_s2 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.gendemword: 
13c3				ld de, .demoworddef 
13c3				ld hl, crs_s3 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.genutlword: 
13c3				ld hl, crs_s4 
13c3				ld de, .utilwordef 
13c3				call .genfile 
13c3				ret 
13c3			.genspiword: 
13c3				ld hl, crs_s5 
13c3				ld de, .spiworddef 
13c3				call .genfile 
13c3				ret 
13c3			.genkeyword: 
13c3				ld hl, crs_s6 
13c3				ld de, .keyworddef 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			; hl - points to file name 
13c3			; de - points to strings to add to file 
13c3			 
13c3			.genfile: 
13c3				push hl 
13c3				push de 
13c3			 
13c3				call clear_display 
13c3				ld a, display_row_1 
13c3				ld de, .genfiletxt 
13c3				call str_at_display 
13c3				call update_display 
13c3			 
13c3				pop de 
13c3				pop hl 
13c3			 
13c3			 
13c3				push de 
13c3				call storage_create 
13c3				; id in hl 
13c3				pop de   ; table of strings to add 
13c3			 
13c3			.genloop: 
13c3			 
13c3				push hl ; save id for next time around 
13c3				push de ; save de for next time around 
13c3			 
13c3				ex de, hl 
13c3				call loadwordinhl 
13c3				ex de, hl 
13c3			 
13c3				; need hl to be the id 
13c3				; need de to be the string ptr 
13c3				 
13c3				call storage_append 
13c3			 
13c3				pop de 
13c3				pop hl 
13c3			 
13c3				inc de 
13c3				inc de 
13c3			 
13c3				ld a,(de) 
13c3				cp 0 
13c3				jr nz, .genloop 
13c3				inc de 
13c3				ld a, (de) 
13c3				dec de 
13c3				cp 0 
13c3				jr nz, .genloop	 
13c3			 
13c3				ret 
13c3			 
13c3			.genfiletxt:  db "Creating file...",0 
13c3			 
13c3			.hwworddef: 
13c3				dw test5 
13c3				dw test6 
13c3				dw test7 
13c3				dw test8 
13c3				dw test9 
13c3				dw test10 
13c3				dw 0 
13c3			 
13c3			.soundworddef: 
13c3				dw sound1 
13c3				dw sound2 
13c3				dw sound3 
13c3				dw sound4 
13c3				dw sound5 
13c3				dw sound6 
13c3				dw sound7 
13c3				dw sound8 
13c3				dw sound9 
13c3				dw 0 
13c3			 
13c3			.utilwordef: 
13c3				dw strncpy 
13c3				dw type 
13c3				dw tuck 
13c3				dw clrstack 
13c3				dw longread 
13c3				dw start1 
13c3				dw start2 
13c3			; duplicated 
13c3			;	dw start3b 
13c3			;	dw start3c 
13c3				dw list 
13c3				dw 0 
13c3			 
13c3			.lsworddef: 
13c3				dw start3b 
13c3				dw 0 
13c3			 
13c3			.edworddef: 
13c3				dw edit1 
13c3				dw edit2 
13c3				dw edit3 
13c3				dw 0 
13c3			 
13c3			.demoworddef: 
13c3				dw game1 
13c3				dw game1a 
13c3				dw game1b 
13c3				dw game1c 
13c3				dw game1d 
13c3				dw game1s 
13c3				dw game1t 
13c3				dw game1f 
13c3				dw game1z 
13c3				dw game1zz 
13c3				dw ssv2 
13c3				dw ssv3 
13c3				dw ssv4 
13c3				dw ssv5 
13c3				dw ssv1 
13c3				dw ssv1cpm	 
13c3			;	dw game2b 
13c3			;	dw game2bf 
13c3			;	dw game2mba 
13c3			;	dw game2mbas	 
13c3			;	dw game2mbht 
13c3			;	dw game2mbms 
13c3			;	dw game2mb 
13c3			;	dw game3w 
13c3			;	dw game3p 
13c3			;	dw game3sc 
13c3			;	dw game3vsi 
13c3			;	dw game3vs 
13c3				dw 0 
13c3			 
13c3			 
13c3			.spiworddef: 
13c3			 
13c3			    dw spi1 
13c3			    dw spi2 
13c3			    dw spi2b 
13c3			    dw spi3 
13c3			    dw spi4 
13c3			    dw spi5 
13c3			;    dw spi6 
13c3			;    dw spi7 
13c3			 
13c3			;    dw spi8 
13c3			;    dw spi9 
13c3			;    dw spi10 
13c3			    dw 0 
13c3			 
13c3			.keyworddef: 
13c3			 
13c3				dw keyup 
13c3				dw keydown 
13c3				dw keyleft 
13c3				dw keyright 
13c3				dw 	keyf1 
13c3				dw keyf2 
13c3				dw keyf3 
13c3				dw keyf4 
13c3				dw keyf5 
13c3				dw keyf6 
13c3				dw keyf7 
13c3				dw keyf8 
13c3				dw keyf9 
13c3				dw keyf10 
13c3				dw keyf11 
13c3				dw keyf12 
13c3				dw keytab 
13c3				dw keycr 
13c3				dw keyhome 
13c3				dw keyend 
13c3				dw keybs 
13c3				dw 0 
13c3			 
13c3			.crstart: 
13c3				dw crs_s1 
13c3				dw crs_s2 
13c3				dw crs_s3 
13c3				dw crs_s4 
13c3				dw crs_s5 
13c3				dw crs_s6 
13c3				dw crs_sound 
13c3				dw crs_hw 
13c3				dw 0 
13c3			 
13c3			endif 
13c3			 
13c3			 
13c3			if STORAGE_SE 
13c3			 
13c3			config_fdir: 
13c3				; using the scratch dir go through and release the memory allocated for each string 
13c3				 
13c3				ld hl, scratch 
13c3			.cfdir:	ld e,(hl) 
13c3				inc hl 
13c3				ld d,(hl) 
13c3				inc hl 
13c3			 
13c3				ex de, hl 
13c3				call ishlzero 
13c3				ret z     ; return on null pointer 
13c3				call free 
13c3				ex de, hl 
13c3				jr .cfdir 
13c3			 
13c3			 
13c3				ret 
13c3			 
13c3			 
13c3			config_dir: 
13c3			 
13c3				; for the config menus that need to build a directory of storage call this routine 
13c3				; it will construct a menu in scratch to pass to menu 
13c3			 
13c3				; open storage device 
13c3			 
13c3				; execute DIR to build a list of files and their ids into scratch in menu format 
13c3				; once the menu has finished then will need to call config_fdir to release the strings 
13c3				 
13c3				; c = number items 
13c3			 
13c3				 
13c3				call storage_get_block_0 
13c3			 
13c3				ld hl, store_page     ; get current id count 
13c3				ld b, (hl) 
13c3				ld c, 0    ; count of files   
13c3			 
13c3			 
13c3				ld hl, scratch 
13c3				ld (store_tmp2), hl    ; location to poke strings 
13c3			 
13c3				; check for empty drive 
13c3			 
13c3				ld a, 0 
13c3				cp b 
13c3				jp z, .dirdone 
13c3			 
13c3				 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "Cdc" 
13c3						CALLMONITOR 
13c3					endif 
13c3			 
13c3			 
13c3			.diritem:	 
13c3				push bc 
13c3				; for each of the current ids do a search for them and if found push to stack 
13c3			 
13c3					ld hl, STORE_BLOCK_PHY 
13c3					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13c3					ld e,b 
13c3			 
13c3					call storage_findnextid 
13c3			 
13c3			 
13c3					; if found hl will be non zero 
13c3			 
13c3					call ishlzero 
13c3					jr z, .dirnotfound 
13c3			 
13c3					; increase count 
13c3			 
13c3					pop bc	 
13c3					inc c 
13c3					push bc 
13c3					 
13c3			 
13c3					; get file header and push the file name 
13c3			 
13c3					ld de, store_page 
13c3					call storage_read_block 
13c3			 
13c3					; push file id to stack 
13c3				 
13c3					ld a, (store_page) 
13c3					ld h, 0 
13c3					ld l, a 
13c3			 
13c3					;call forth_push_numhl 
13c3					; TODO store id 
13c3			 
13c3					push hl 
13c3			 
13c3					; push extent count to stack  
13c3				 
13c3					ld hl, store_page+3 
13c3			 
13c3					; get file name length 
13c3			 
13c3					call strlenz   
13c3			 
13c3					inc hl   ; cover zero term 
13c3					inc hl  ; stick the id at the end of the area 
13c3			 
13c3					push hl 
13c3					pop bc    ; move length to bc 
13c3			 
13c3					call malloc 
13c3			 
13c3					; TODO save malloc area to scratch 
13c3			 
13c3					ex de, hl 
13c3					ld hl, (store_tmp2) 
13c3					ld (hl), e 
13c3					inc hl 
13c3					ld (hl), d 
13c3					inc hl 
13c3					ld (store_tmp2), hl 
13c3			 
13c3					 
13c3			 
13c3					;pop hl   ; get source 
13c3			;		ex de, hl    ; swap aronund	 
13c3			 
13c3					ld hl, store_page+3 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "CFd" 
13c3						CALLMONITOR 
13c3					endif 
13c3					ldir 
13c3			 
13c3					; de is past string, move back one and store id 
13c3					 
13c3					dec de 
13c3			 
13c3					; store file id 
13c3			 
13c3					pop hl 
13c3					ex de,hl 
13c3					ld (hl), e 
13c3			 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "Cdi" 
13c3						CALLMONITOR 
13c3					endif 
13c3					 
13c3			.dirnotfound: 
13c3					pop bc     
13c3					djnz .diritem 
13c3				 
13c3			.dirdone:	 
13c3			 
13c3					ld a, 0 
13c3					ld hl, (store_tmp2) 
13c3					ld (hl), a 
13c3					inc hl 
13c3					ld (hl), a 
13c3					inc hl 
13c3					; push a count of the dir items found 
13c3			 
13c3			;		ld h, 0 
13c3			;		ld l, c 
13c3			 
13c3				ret 
13c3			 
13c3			endif 
13c3			 
13c3			 
13c3			; Settings 
13c3			; Run  
13c3			 
13c3			 
13c3			 
13c3			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13c3			;;hd_menu2:   db "        2: Editor",0   
13c3			;hd_menu2:   db "        2: Editor       6: Menu",0   
13c3			;hd_menu3:   db "        3: Storage",0 
13c3			;hd_menu4:   db "0=quit  4: Debug",0 
13c3			;hd_don:     db "ON",0 
13c3			;hd_doff:     db "OFF",0 
13c3			; 
13c3			; 
13c3			; 
13c3			;hardware_diags_old:       
13c3			; 
13c3			;.diagmenu: 
13c3			;	call clear_display 
13c3			;	ld a, display_row_1 
13c3			;	ld de, hd_menu1 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a, display_row_2 
13c3			;	ld de, hd_menu2 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a, display_row_3 
13c3			;	ld de, hd_menu3 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a,  display_row_4 
13c3			;	ld de, hd_menu4 
13c3			;	call str_at_display 
13c3			; 
13c3			;	; display debug state 
13c3			; 
13c3			;	ld de, hd_don 
13c3			;	ld a, (os_view_disable) 
13c3			;	cp 0 
13c3			;	jr z, .distog 
13c3			;	ld de, hd_doff 
13c3			;.distog: ld a, display_row_4+17 
13c3			;	call str_at_display 
13c3			; 
13c3			;	call update_display 
13c3			; 
13c3			;	call cin_wait 
13c3			; 
13c3			; 
13c3			; 
13c3			;	cp '4' 
13c3			;	jr nz, .diagn1 
13c3			; 
13c3			;	; debug toggle 
13c3			; 
13c3			;	ld a, (os_view_disable) 
13c3			;	ld b, '*' 
13c3			;	cp 0 
13c3			;	jr z, .debtog 
13c3			;	ld b, 0 
13c3			;.debtog:	 
13c3			;	ld a,b 
13c3			;	ld (os_view_disable),a 
13c3			; 
13c3			;.diagn1: cp '0' 
13c3			;	 ret z 
13c3			; 
13c3			;;	cp '1' 
13c3			;;       jp z, matrix	 
13c3			;;   TODO keyboard matrix test 
13c3			; 
13c3			;	cp '2' 
13c3			;	jp z, .diagedit 
13c3			; 
13c3			;;	cp '6' 
13c3			;;	jp z, .menutest 
13c3			;;if ENABLE_BASIC 
13c3			;;	cp '6' 
13c3			;;	jp z, basic 
13c3			;;endif 
13c3			 ; 
13c3			;	jp .diagmenu 
13c3			; 
13c3			; 
13c3			;	ret 
13c3			 
13c3			 
13c3			.debug_tog: 
13c3 21 0d 14			ld hl, .menudebug 
13c6				 
13c6			;	ld a, (os_view_disable) 
13c6			;	cp '*' 
13c6 3a 6f ee			ld a,(debug_vector) 
13c9 fe c9			cp $C9   ; RET 
13cb 20 04			jr nz,.tdon  
13cd 3e 01			ld a, 1 
13cf 18 02			jr .tog1 
13d1 3e 00		.tdon: ld a, 0 
13d3			 
13d3			.tog1: 
13d3 cd f9 0b			call menu 
13d6 fe 00			cp 0 
13d8 c8				ret z 
13d9 fe 01			cp 1    ; disable debug 
13db 28 04			jr z, .dtog0 
13dd 3e 2a			ld a, '*' 
13df 18 05			jr .dtogset 
13e1			.dtog0:  
13e1				;ld a, 0 
13e1 cd ff 14			call bp_on 
13e4 18 dd			jr .debug_tog 
13e6			.dtogset:  
13e6				; ld (os_view_disable), a 
13e6 cd 0b 15			call bp_off 
13e9 c3 c3 13			jp .debug_tog 
13ec			 
13ec			 
13ec			hardware_diags:       
13ec			 
13ec			.diagm: 
13ec 21 ff 13			ld hl, .menuitems 
13ef 3e 00			ld a, 0 
13f1 cd f9 0b			call menu 
13f4			 
13f4 fe 00		         cp 0 
13f6 c8				 ret z 
13f7			 
13f7 fe 02			cp 2 
13f9 ca 58 14			jp z, .diagedit 
13fc			 
13fc			;	cp '6' 
13fc			;	jp z, .menutest 
13fc			;if ENABLE_BASIC 
13fc			;	cp '6' 
13fc			;	jp z, basic 
13fc			;endif 
13fc			  
13fc c3 ec 13			jp .diagm 
13ff			 
13ff				 
13ff 13 14		.menuitems:   	dw .m1 
1401 1e 14				dw .m2 
1403 25 14				dw .m3 
1405 2d 14				dw .m5 
1407 33 14				dw .m5a 
1409 3c 14				dw .m5b 
140b 00 00				dw 0 
140d			 
140d			.menudebug: 
140d 45 14				dw .m6 
140f 4e 14				dw .m7 
1411 00 00				dw 0 
1413			 
1413 .. 00		.m1:   db "Key Matrix",0 
141e .. 00		.m2:   db "Editor",0 
1425 .. 00		.m3:   db "Storage",0 
142d .. 00		.m5:   db "Sound",0 
1433 .. 00		.m5a:  db "RAM Test",0 
143c .. 00		.m5b:  db "LCD Test",0 
1445			 
1445 .. 00		.m6:   db "Debug ON",0 
144e .. 00		.m7:   db "Debug OFF",0 
1458			 
1458			; debug editor 
1458			 
1458			.diagedit: 
1458			 
1458 21 bb e2			ld hl, scratch 
145b			;	ld bc, 250 
145b			;	ldir 
145b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
145b 3e 00			ld a, 0 
145d 77				ld (hl), a 
145e 23				inc hl 
145f 77				ld (hl), a 
1460 23				inc hl 
1461 77				ld (hl), a 
1462			 
1462 cd c8 0b		        call clear_display 
1465 cd eb 0b			call update_display 
1468				;ld a, 1 
1468				;ld (hardware_diag), a 
1468			.diloop: 
1468 3e 00			ld a, display_row_1 
146a 0e 00			ld c, 0 
146c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
146e 1e 28			ld e, 40 
1470			 
1470 21 bb e2			ld hl, scratch	 
1473 cd 22 0e			call input_str 
1476			 
1476 3e 28			ld a, display_row_2 
1478 11 bb e2			ld de, scratch 
147b cd db 0b			call str_at_display 
147e cd eb 0b			call update_display 
1481			 
1481 c3 68 14			jp .diloop 
1484			 
1484			 
1484			; pass word in hl 
1484			; a has display location 
1484			display_word_at: 
1484 f5				push af 
1485 e5				push hl 
1486 7c				ld a,h 
1487 21 c0 e5			ld hl, os_word_scratch 
148a cd fe 0f			call hexout 
148d e1				pop hl 
148e 7d				ld a,l 
148f 21 c2 e5			ld hl, os_word_scratch+2 
1492 cd fe 0f			call hexout 
1495 21 c4 e5			ld hl, os_word_scratch+4 
1498 3e 00			ld a,0 
149a 77				ld (hl),a 
149b 11 c0 e5			ld de,os_word_scratch 
149e f1				pop af 
149f cd db 0b				call str_at_display 
14a2 c9				ret 
14a3			 
14a3			display_ptr_state: 
14a3			 
14a3				; to restore afterwards 
14a3			 
14a3 d5				push de 
14a4 c5				push bc 
14a5 e5				push hl 
14a6 f5				push af 
14a7			 
14a7				; for use in here 
14a7			 
14a7			;	push bc 
14a7			;	push de 
14a7			;	push hl 
14a7			;	push af 
14a7			 
14a7 cd c8 0b			call clear_display 
14aa			 
14aa 11 82 16			ld de, .ptrstate 
14ad 3e 00			ld a, display_row_1 
14af cd db 0b			call str_at_display 
14b2			 
14b2				; display debug step 
14b2			 
14b2			 
14b2 11 65 ee			ld de, debug_mark 
14b5 3e 26			ld a, display_row_1+display_cols-2 
14b7 cd db 0b			call str_at_display 
14ba			 
14ba				; display a 
14ba 11 8c 16			ld de, .ptrcliptr 
14bd 3e 28			ld a, display_row_2 
14bf cd db 0b			call str_at_display 
14c2			 
14c2 f1				pop af 
14c3 2a 3a ea			ld hl,(cli_ptr) 
14c6 3e 30			ld a, display_row_2+8 
14c8 cd 84 14			call display_word_at 
14cb			 
14cb			 
14cb				; display hl 
14cb			 
14cb			 
14cb 11 94 16			ld de, .ptrclioptr 
14ce 3e 32			ld a, display_row_2+10 
14d0 cd db 0b			call str_at_display 
14d3			; 
14d3			;	pop hl 
14d3 3e 35			ld a, display_row_2+13 
14d5 2a 38 ea			ld hl,(cli_origptr) 
14d8 cd 84 14			call display_word_at 
14db			; 
14db			;	 
14db			;	; display de 
14db			 
14db			;	ld de, .regstatede 
14db			;	ld a, display_row_3 
14db			;	call str_at_display 
14db			 
14db			;	pop de 
14db			;	ld h,d 
14db			;	ld l, e 
14db			;	ld a, display_row_3+3 
14db			;	call display_word_at 
14db			 
14db			 
14db				; display bc 
14db			 
14db			;	ld de, .regstatebc 
14db			;	ld a, display_row_3+10 
14db			;	call str_at_display 
14db			 
14db			;	pop bc 
14db			;	ld h,b 
14db			;	ld l, c 
14db			;	ld a, display_row_3+13 
14db			;	call display_word_at 
14db			 
14db			 
14db				; display dsp 
14db			 
14db			;	ld de, .regstatedsp 
14db			;	ld a, display_row_4 
14db			;	call str_at_display 
14db			 
14db				 
14db			;	ld hl,(cli_data_sp) 
14db			;	ld a, display_row_4+4 
14db			;	call display_word_at 
14db			 
14db				; display rsp 
14db			 
14db 11 c3 16			ld de, .regstatersp 
14de 3e 82			ld a, display_row_4+10 
14e0 cd db 0b			call str_at_display 
14e3			 
14e3				 
14e3 2a ec e9			ld hl,(cli_ret_sp) 
14e6 3e 86			ld a, display_row_4+14 
14e8 cd 84 14			call display_word_at 
14eb			 
14eb cd eb 0b			call update_display 
14ee			 
14ee cd 00 0b			call delay1s 
14f1 cd 00 0b			call delay1s 
14f4 cd 00 0b			call delay1s 
14f7			 
14f7			 
14f7 cd 08 1b			call next_page_prompt 
14fa			 
14fa				; restore  
14fa			 
14fa f1				pop af 
14fb e1				pop hl 
14fc c1				pop bc 
14fd d1				pop de 
14fe c9				ret 
14ff			 
14ff			; Update the break point vector so that the user can hook a new routine 
14ff			 
14ff			bp_on: 
14ff 3e c3			ld a, $c3    ; JP 
1501 32 6f ee			ld (debug_vector), a 
1504 21 11 15			ld hl, break_point_state 
1507 22 70 ee			ld (debug_vector+1), hl 
150a c9				ret 
150b			 
150b			bp_off: 
150b 3e c9			ld a, $c9    ; RET 
150d 32 6f ee			ld (debug_vector), a 
1510 c9				ret 
1511			 
1511			 
1511			break_point_state: 
1511			;	push af 
1511			; 
1511			;	; see if disabled 
1511			; 
1511			;	ld a, (os_view_disable) 
1511			;	cp '*' 
1511			;	jr nz, .bpsgo 
1511			;	pop af 
1511			;	ret 
1511			 
1511			.bpsgo: 
1511			;	pop af 
1511 f5				push af 
1512 22 9d e2			ld (os_view_hl), hl 
1515 ed 53 9b e2		ld (os_view_de), de 
1519 ed 43 99 e2		ld (os_view_bc), bc 
151d e5				push hl 
151e 6f				ld l, a 
151f 26 00			ld h, 0 
1521 22 9f e2			ld (os_view_af),hl 
1524			 
1524 21 ab ed				ld hl, display_fb0 
1527 22 c6 eb				ld (display_fb_active), hl 
152a e1				pop hl	 
152b			 
152b 3e 31			ld a, '1' 
152d fe 2a		.bps1:  cp '*' 
152f cc 0b 15			call z, bp_off 
1532			;	jr nz, .bps1b 
1532			;	ld (os_view_disable),a 
1532 fe 31		.bps1b:  cp '1' 
1534 20 14			jr nz, .bps2 
1536			 
1536				; display reg 
1536			 
1536				 
1536			 
1536 3a 9f e2			ld a, (os_view_af) 
1539 2a 9d e2			ld hl, (os_view_hl) 
153c ed 5b 9b e2		ld de, (os_view_de) 
1540 ed 4b 99 e2		ld bc, (os_view_bc) 
1544 cd de 15			call display_reg_state 
1547 c3 ca 15			jp .bpschk 
154a			 
154a fe 32		.bps2:  cp '2' 
154c 20 08			jr nz, .bps3 
154e				 
154e				; display hl 
154e 2a 9d e2			ld hl, (os_view_hl) 
1551 cd c8 16			call display_dump_at_hl 
1554			 
1554 18 74			jr .bpschk 
1556			 
1556 fe 33		.bps3:  cp '3' 
1558 20 08			jr nz, .bps4 
155a			 
155a			        ; display de 
155a 2a 9b e2			ld hl, (os_view_de) 
155d cd c8 16			call display_dump_at_hl 
1560			 
1560 18 68			jr .bpschk 
1562 fe 34		.bps4:  cp '4' 
1564 20 08			jr nz, .bps5 
1566			 
1566			        ; display bc 
1566 2a 99 e2			ld hl, (os_view_bc) 
1569 cd c8 16			call display_dump_at_hl 
156c			 
156c 18 5c			jr .bpschk 
156e fe 35		.bps5:  cp '5' 
1570 20 08		        jr nz, .bps7 
1572			 
1572				; display cur ptr 
1572 2a 3a ea			ld hl, (cli_ptr) 
1575 cd c8 16			call display_dump_at_hl 
1578			 
1578 18 50			jr .bpschk 
157a fe 36		.bps7:  cp '6' 
157c 20 08			jr nz, .bps8b 
157e				 
157e				; display cur orig ptr 
157e 2a 38 ea			ld hl, (cli_origptr) 
1581 cd c8 16			call display_dump_at_hl 
1584 18 44			jr .bpschk 
1586 fe 37		.bps8b:  cp '7' 
1588 20 08			jr nz, .bps9 
158a				 
158a				; display dsp 
158a 2a e8 e9			ld hl, (cli_data_sp) 
158d cd c8 16			call display_dump_at_hl 
1590			 
1590 18 38			jr .bpschk 
1592 fe 39		.bps9:  cp '9' 
1594 20 05			jr nz, .bps8c 
1596				 
1596				; display SP 
1596			;	ld hl, sp 
1596 cd c8 16			call display_dump_at_hl 
1599			 
1599 18 2f			jr .bpschk 
159b fe 38		.bps8c:  cp '8' 
159d 20 08			jr nz, .bps8d 
159f				 
159f				; display rsp 
159f 2a ec e9			ld hl, (cli_ret_sp) 
15a2 cd c8 16			call display_dump_at_hl 
15a5			 
15a5 18 23			jr .bpschk 
15a7 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a9 20 05			jr nz, .bps8 
15ab cd c2 18			call monitor 
15ae			 
15ae 18 1a			jr .bpschk 
15b0 fe 30		.bps8:  cp '0' 
15b2 20 16			jr nz, .bpschk 
15b4			 
15b4 21 0a ed				ld hl, display_fb1 
15b7 22 c6 eb				ld (display_fb_active), hl 
15ba cd eb 0b				call update_display 
15bd			 
15bd				;ld a, (os_view_af) 
15bd 2a 9d e2			ld hl, (os_view_hl) 
15c0 ed 5b 9b e2		ld de, (os_view_de) 
15c4 ed 4b 99 e2		ld bc, (os_view_bc) 
15c8 f1				pop af 
15c9 c9				ret 
15ca			 
15ca			.bpschk:   
15ca cd 00 0b			call delay1s 
15cd 3e 9f		ld a,display_row_4 + display_cols - 1 
15cf 11 06 1b		        ld de, endprg 
15d2 cd db 0b			call str_at_display 
15d5 cd eb 0b			call update_display 
15d8 cd 01 64			call cin_wait 
15db			 
15db c3 2d 15			jp .bps1 
15de			 
15de			 
15de			display_reg_state: 
15de			 
15de				; to restore afterwards 
15de			 
15de d5				push de 
15df c5				push bc 
15e0 e5				push hl 
15e1 f5				push af 
15e2			 
15e2				; for use in here 
15e2			 
15e2 c5				push bc 
15e3 d5				push de 
15e4 e5				push hl 
15e5 f5				push af 
15e6			 
15e6 cd c8 0b			call clear_display 
15e9			 
15e9 11 9e 16			ld de, .regstate 
15ec 3e 00			ld a, display_row_1 
15ee cd db 0b			call str_at_display 
15f1			 
15f1				; display debug step 
15f1			 
15f1			 
15f1 11 65 ee			ld de, debug_mark 
15f4 3e 25			ld a, display_row_1+display_cols-3 
15f6 cd db 0b			call str_at_display 
15f9			 
15f9				; display a 
15f9 11 ba 16			ld de, .regstatea 
15fc 3e 28			ld a, display_row_2 
15fe cd db 0b			call str_at_display 
1601			 
1601 e1				pop hl 
1602			;	ld h,0 
1602			;	ld l, a 
1602 3e 2b			ld a, display_row_2+3 
1604 cd 84 14			call display_word_at 
1607			 
1607			 
1607				; display hl 
1607			 
1607			 
1607 11 ae 16			ld de, .regstatehl 
160a 3e 32			ld a, display_row_2+10 
160c cd db 0b			call str_at_display 
160f			 
160f e1				pop hl 
1610 3e 35			ld a, display_row_2+13 
1612 cd 84 14			call display_word_at 
1615			 
1615				 
1615				; display de 
1615			 
1615 11 b2 16			ld de, .regstatede 
1618 3e 50			ld a, display_row_3 
161a cd db 0b			call str_at_display 
161d			 
161d e1				pop hl 
161e			;	ld h,d 
161e			;	ld l, e 
161e 3e 53			ld a, display_row_3+3 
1620 cd 84 14			call display_word_at 
1623			 
1623			 
1623				; display bc 
1623			 
1623 11 b6 16			ld de, .regstatebc 
1626 3e 5a			ld a, display_row_3+10 
1628 cd db 0b			call str_at_display 
162b			 
162b e1				pop hl 
162c			;	ld h,b 
162c			;	ld l, c 
162c 3e 5d			ld a, display_row_3+13 
162e cd 84 14			call display_word_at 
1631			 
1631			 
1631				; display dsp 
1631			 
1631 11 be 16			ld de, .regstatedsp 
1634 3e 78			ld a, display_row_4 
1636 cd db 0b			call str_at_display 
1639			 
1639				 
1639 2a e8 e9			ld hl,(cli_data_sp) 
163c 3e 7c			ld a, display_row_4+4 
163e cd 84 14			call display_word_at 
1641			 
1641				; display rsp 
1641			 
1641 11 c3 16			ld de, .regstatersp 
1644 3e 82			ld a, display_row_4+10 
1646 cd db 0b			call str_at_display 
1649			 
1649				 
1649 2a ec e9			ld hl,(cli_ret_sp) 
164c 3e 86			ld a, display_row_4+14 
164e cd 84 14			call display_word_at 
1651			 
1651 cd eb 0b			call update_display 
1654			 
1654			;	call delay1s 
1654			;	call delay1s 
1654			;	call delay1s 
1654			 
1654			 
1654			;	call next_page_prompt 
1654			 
1654				; restore  
1654			 
1654 f1				pop af 
1655 e1				pop hl 
1656 c1				pop bc 
1657 d1				pop de 
1658 c9				ret 
1659			 
1659 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166d .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1682 .. 00		.ptrstate:	db "Ptr State",0 
168c .. 00		.ptrcliptr:     db "cli_ptr",0 
1694 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169e .. 00		.regstate:	db "Reg State (1/0)",0 
16ae .. 00		.regstatehl:	db "HL:",0 
16b2 .. 00		.regstatede:	db "DE:",0 
16b6 .. 00		.regstatebc:	db "BC:",0 
16ba .. 00		.regstatea:	db "A :",0 
16be .. 00		.regstatedsp:	db "DSP:",0 
16c3 .. 00		.regstatersp:	db "RSP:",0 
16c8			 
16c8			display_dump_at_hl: 
16c8 e5				push hl 
16c9 d5				push de 
16ca c5				push bc 
16cb f5				push af 
16cc			 
16cc 22 de e5			ld (os_cur_ptr),hl	 
16cf cd c8 0b			call clear_display 
16d2 cd 10 1a			call dumpcont 
16d5			;	call delay1s 
16d5			;	call next_page_prompt 
16d5			 
16d5			 
16d5 f1				pop af 
16d6 c1				pop bc 
16d7 d1				pop de 
16d8 e1				pop hl 
16d9 c9				ret 
16da			 
16da			;if ENABLE_BASIC 
16da			;	include "nascombasic.asm" 
16da			;	basic: 
16da			;	include "forth/FORTH.ASM" 
16da			;endif 
16da			 
16da			; eof 
16da			 
16da			 
# End of file firmware_diags.asm
16da			  
16da			include "firmware_prompts.asm"  
16da			; Prompts  
16da			 
16da			; boot messages 
16da			 
16da .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16ef .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16ff			 
16ff			 
16ff			; config menus 
16ff			 
16ff			;prom_c3: db "Add Dictionary To File",0 
16ff			 
16ff			if STARTUP_V1 
16ff .. 00		prom_c2: db "Select Autoload File",0 
1714 .. 00		prom_c2a: db "Disable Autoload File", 0 
172a			endif 
172a			 
172a			if STARTUP_V2 
172a			prom_c2: db "Enable Autoload Files",0 
172a			prom_c2a: db "Disable Autoload Files", 0 
172a			 
172a			crs_s1: db "*ls-word", 0 
172a			crs_s2: db "*ed-word", 0 
172a			crs_s3: db "*Demo-Games", 0 
172a			crs_s4: db "*Utils", 0 
172a			crs_s5: db "*SPI-Util", 0 
172a			crs_s6: db "*Key-Constants", 0 
172a			crs_sound: db "*Sound-Util", 0 
172a			crs_hw: db "*Hello-World",0 
172a			 
172a			 
172a			 
172a			endif 
172a			;prom_c2b: db "Select Storage Bank",0 
172a .. 00		prom_c4: db "Settings",0 
1733 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
174e .. 00		prom_m4b:   db "Monitor",0 
1756 .. 00		prom_c1: db "Hardware Diags",0 
1765			 
1765			 
1765			if STARTUP_V2 
1765			prom_c9: db "Create Startup Files",0 
1765			endif 
1765			 
1765 .. 00		prom_notav:    db "Feature not available",0 
177b .. 00		prom_empty:    db "",0 
177c			 
177c			; eof 
177c			 
# End of file firmware_prompts.asm
177c			  
177c			; eof  
177c			  
# End of file firmware.asm
177c			 
177c			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
177c			;if BASE_KEV  
177c			;baseram: equ 08000h 
177c			;endif 
177c			 
177c			;if BASE_SC114 
177c			;baseram:     equ    endofcode 
177c			;endif 
177c			 
177c			 
177c			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
177c			 
177c			; start system 
177c			 
177c			coldstart: 
177c				; set sp 
177c				; di/ei 
177c			 
177c f3				di 
177d 31 00 f0			ld sp, tos 
1780 cd ff 62			call init_nmi 
1783			;	ei 
1783			 
1783				; init spinner 
1783 3e 00			ld a,0 
1785 32 c0 eb			ld (display_active), a 
1788			 
1788				; disable breakpoint by default 
1788			 
1788				;ld a,'*' 
1788			;	ld a,' ' 
1788			;	ld (os_view_disable),a 
1788			 
1788				; set break point vector as new break point on or off 
1788 cd 0b 15			call bp_off 
178b			 
178b				; init hardware 
178b			 
178b				; init keyboard and screen hardware 
178b			 
178b cd 1f 01			call hardware_init 
178e			 
178e			 
178e cd 00 0b			call delay1s 
1791 3e 58			ld a, display_row_3+8 
1793 11 03 01			ld de, buildtime 
1796 cd db 0b			call str_at_display 
1799 cd eb 0b			call update_display 
179c			 
179c cd 00 0b			call delay1s 
179f cd 00 0b			call delay1s 
17a2 cd 00 0b			call delay1s 
17a5			 
17a5				; detect if any keys are held down to enable breakpoints at start up 
17a5			 
17a5 cd 09 64			call cin  
17a8 fe 00			cp 0 
17aa 28 03			jr z, .nokeys 
17ac			 
17ac				;call hardware_diags 
17ac cd 69 13			call config 
17af			 
17af			;	ld de, .bpen 
17af			;	ld a, display_row_4 
17af			;	call str_at_display 
17af			;	call update_display 
17af			; 
17af			;	ld a,0 
17af			;	ld (os_view_disable),a 
17af			; 
17af			;.bpwait: 
17af			;	call cin 
17af			;	cp 0 
17af			;	jr z, .bpwait 
17af			;	jr .nokeys 
17af			; 
17af			; 
17af			;.bpen:  db "Break points enabled!",0 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			.nokeys: 
17af			 
17af			 
17af				 
17af			 
17af			;jp  testkey 
17af			 
17af			;call storage_get_block_0 
17af			; 
17af			;ld hl, 0 
17af			;ld de, store_page 
17af			;call storage_read_block 
17af			 
17af				 
17af			;ld hl, 10 
17af			;ld de, store_page 
17af			;call storage_read_block 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			;stop:	nop 
17af			;	jp stop 
17af			 
17af			 
17af			 
17af			main: 
17af cd c8 0b			call clear_display 
17b2 cd eb 0b			call update_display 
17b5			 
17b5			 
17b5			 
17b5			;	call testlcd 
17b5			 
17b5			 
17b5			 
17b5 cd 50 1f			call forth_init 
17b8			 
17b8			 
17b8			warmstart: 
17b8 cd 26 1f			call forth_warmstart 
17bb			 
17bb				; run startup word load 
17bb			        ; TODO prevent this running at warmstart after crash  
17bb			 
17bb				if STARTUP_ENABLE 
17bb			 
17bb					if STARTUP_V1 
17bb			 
17bb						if STORAGE_SE 
17bb							call forth_autoload 
17bb						endif 
17bb cd 4f 62					call forth_startup 
17be					endif 
17be			 
17be					if STARTUP_V2 
17be			 
17be						if STORAGE_SE 
17be							call forth_autoload 
17be						else 
17be							call forth_startup 
17be						endif 
17be			 
17be			 
17be					endif 
17be			 
17be				endif 
17be			 
17be			warmstart_afterauto: 
17be			 
17be				; show free memory after boot 
17be 11 5d 18			ld de, freeram 
17c1 3e 00			ld a, display_row_1 
17c3 cd db 0b			call str_at_display 
17c6			 
17c6				; get current heap start after loading any uwords 
17c6			 
17c6				;ld de, (os_last_new_uword) 
17c6				;ex de, hl 
17c6			 
17c6			; Or use heap_size word???? 
17c6				;ld hl, heap_end 
17c6				;ld hl, heap_size 
17c6				;ld de, topusermem 
17c6				;ld de, heap_start 
17c6 ed 5b 2c 64			ld de, (free_list )      
17ca 21 96 e2				ld hl, heap_end 
17cd ed 52			sbc hl, de 
17cf				;push hl 
17cf				;ld a,h	         	 
17cf				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17cf				;call hexout 
17cf			   	;pop hl 
17cf			; 
17cf			;	ld a,l 
17cf			;	ld hl, os_word_scratch+2 
17cf			;	call hexout 
17cf			;	ld hl, os_word_scratch+4 
17cf			;	ld a, 0 
17cf			;	ld (hl),a 
17cf eb				ex de, hl 
17d0 21 c0 e5			ld hl, os_word_scratch 
17d3 cd 0a 11			call uitoa_16 
17d6			 
17d6			 
17d6 11 c0 e5			ld de, os_word_scratch 
17d9 3e 0d			ld a, display_row_1 + 13 
17db cd db 0b			call str_at_display 
17de cd eb 0b			call update_display 
17e1			 
17e1			 
17e1				;call demo 
17e1			 
17e1			 
17e1				; init scratch input area for cli commands 
17e1			 
17e1 21 e2 e5			ld hl, os_cli_cmd 
17e4 3e 00			ld a,0 
17e6 77				ld (hl),a 
17e7 23				inc hl 
17e8 77				ld (hl),a 
17e9			 
17e9 3e 00			ld a,0 
17eb 32 e1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17ee			 
17ee 32 de e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17f1 32 df e5			ld (os_cur_ptr+1),a	 
17f4			 
17f4 32 c0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17f7 32 c1 e5			ld (os_word_scratch+1),a	 
17fa				 
17fa			 
17fa				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17fa 21 e2 e5			ld hl, os_cli_cmd 
17fd			 
17fd 3e 00			ld a, 0		 ; init cli input 
17ff 77				ld (hl), a 
1800 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1802			cli: 
1802				; show cli prompt 
1802				;push af 
1802				;ld a, 0 
1802				;ld de, prompt 
1802				;call str_at_display 
1802			 
1802				;call update_display 
1802				;pop af 
1802				;inc a 
1802				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1802			 
1802			.lastrecall: 
1802			 
1802 0e 00			ld c, 0 
1804 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1806 1e 28			ld e, 40 
1808			 
1808 21 e2 e5			ld hl, os_cli_cmd 
180b			 
180b				STACKFRAME OFF $fefe $9f9f 
180b				if DEBUG_STACK_IMB 
180b					if OFF 
180b						exx 
180b						ld de, $fefe 
180b						ld a, d 
180b						ld hl, curframe 
180b						call hexout 
180b						ld a, e 
180b						ld hl, curframe+2 
180b						call hexout 
180b						ld hl, $fefe 
180b						push hl 
180b						ld hl, $9f9f 
180b						push hl 
180b						exx 
180b					endif 
180b				endif 
180b			endm 
# End of macro STACKFRAME
180b			 
180b cd 22 0e			call input_str 
180e			 
180e				STACKFRAMECHK OFF $fefe $9f9f 
180e				if DEBUG_STACK_IMB 
180e					if OFF 
180e						exx 
180e						ld hl, $9f9f 
180e						pop de   ; $9f9f 
180e						call cmp16 
180e						jr nz, .spnosame 
180e						ld hl, $fefe 
180e						pop de   ; $fefe 
180e						call cmp16 
180e						jr z, .spfrsame 
180e						.spnosame: call showsperror 
180e						.spfrsame: nop 
180e						exx 
180e					endif 
180e				endif 
180e			endm 
# End of macro STACKFRAMECHK
180e			 
180e			 
180e				; check to see if last line recall has been requested 
180e			 
180e			if EDIT_V2 
180e fe 05			cp KEY_UP 
1810 20 0f			jr nz, .noexecline 
1812			 
1812 11 e2 e5			ld de, os_cli_cmd 
1815 21 e1 e6			ld hl, os_last_cmd 
1818 01 ff 00			ld bc, 255 
181b ed b0			ldir 
181d 3e 00			ld a, 0 
181f 18 e1			jr .lastrecall 
1821			endif 
1821			 
1821			.noexecline: 
1821				; no so exec the line		 
1821			 
1821				; copy input to last command 
1821			 
1821 21 e2 e5			ld hl, os_cli_cmd 
1824 11 e1 e6			ld de, os_last_cmd 
1827 01 ff 00			ld bc, 255 
182a ed b0			ldir 
182c			 
182c				; wipe current buffer 
182c			 
182c			;	ld a, 0 
182c			;	ld hl, os_cli_cmd 
182c			;	ld de, os_cli_cmd+1 
182c			;	ld bc, 254 
182c			;	ldir 
182c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
182c			;	call strcpy 
182c			;	ld a, 0 
182c			;	ld (hl), a 
182c			;	inc hl 
182c			;	ld (hl), a 
182c			;	inc hl 
182c			;	ld (hl), a 
182c			 
182c				; switch frame buffer to program  
182c			 
182c 21 0a ed				ld hl, display_fb1 
182f 22 c6 eb				ld (display_fb_active), hl 
1832			 
1832			;	nop 
1832				STACKFRAME ON $fbfe $8f9f 
1832				if DEBUG_STACK_IMB 
1832					if ON 
1832						exx 
1832						ld de, $fbfe 
1832						ld a, d 
1832						ld hl, curframe 
1832						call hexout 
1832						ld a, e 
1832						ld hl, curframe+2 
1832						call hexout 
1832						ld hl, $fbfe 
1832						push hl 
1832						ld hl, $8f9f 
1832						push hl 
1832						exx 
1832					endif 
1832				endif 
1832			endm 
# End of macro STACKFRAME
1832				; first time into the parser so pass over the current scratch pad 
1832 21 e2 e5			ld hl,os_cli_cmd 
1835				; tokenise the entered statement(s) in HL 
1835 cd ca 1f			call forthparse 
1838			        ; exec forth statements in top of return stack 
1838 cd 06 20			call forthexec 
183b				;call forthexec_cleanup 
183b			;	call parsenext 
183b			 
183b				STACKFRAMECHK ON $fbfe $8f9f 
183b				if DEBUG_STACK_IMB 
183b					if ON 
183b						exx 
183b						ld hl, $8f9f 
183b						pop de   ; $8f9f 
183b						call cmp16 
183b						jr nz, .spnosame 
183b						ld hl, $fbfe 
183b						pop de   ; $fbfe 
183b						call cmp16 
183b						jr z, .spfrsame 
183b						.spnosame: call showsperror 
183b						.spfrsame: nop 
183b						exx 
183b					endif 
183b				endif 
183b			endm 
# End of macro STACKFRAMECHK
183b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
183b			 
183b 3e 78			ld a, display_row_4 
183d 11 6e 18			ld de, endprog 
1840			 
1840 cd eb 0b			call update_display		 
1843			 
1843 cd 08 1b			call next_page_prompt 
1846			 
1846				; switch frame buffer to cli 
1846			 
1846 21 ab ed				ld hl, display_fb0 
1849 22 c6 eb				ld (display_fb_active), hl 
184c			 
184c			 
184c cd c8 0b		        call clear_display 
184f cd eb 0b			call update_display		 
1852			 
1852 21 e2 e5			ld hl, os_cli_cmd 
1855			 
1855 3e 00			ld a, 0		 ; init cli input 
1857 77				ld (hl), a 
1858			 
1858				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1858			 
1858				; now on last line 
1858			 
1858				; TODO scroll screen up 
1858			 
1858				; TODO instead just clear screen and place at top of screen 
1858			 
1858			;	ld a, 0 
1858			;	ld (f_cursor_ptr),a 
1858			 
1858				;call clear_display 
1858				;call update_display 
1858			 
1858				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1858 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
185a c3 02 18			jp cli 
185d			 
185d .. 00		freeram: db "Free bytes: ",0 
186a ..			asc: db "1A2F" 
186e .. 00		endprog: db "End prog...",0 
187a			 
187a			testenter2:   
187a 21 ed e2			ld hl,scratch+50 
187d 22 de e5			ld (os_cur_ptr),hl 
1880 c3 02 18			jp cli 
1883			 
1883			testenter:  
1883			 
1883 21 6a 18			ld hl,asc 
1886			;	ld a,(hl) 
1886			;	call nibble2val 
1886 cd 54 10			call get_byte 
1889			 
1889			 
1889			;	ld a,(hl) 
1889			;	call atohex 
1889			 
1889			;	call fourehexhl 
1889 32 ed e2			ld (scratch+50),a 
188c			 
188c			 
188c			 
188c 21 6c 18			ld hl,asc+2 
188f			;	ld a, (hl) 
188f			;	call nibble2val 
188f cd 54 10			call get_byte 
1892			 
1892			;	call fourehexhl 
1892 32 ef e2			ld (scratch+52),a 
1895				 
1895 21 ed e2			ld hl,scratch+50 
1898 22 de e5			ld (os_cur_ptr),hl 
189b c3 02 18			jp cli 
189e			 
189e			enter:	 
189e 3a bf e2			ld a,(scratch+4) 
18a1 fe 00			cp 0 
18a3 28 0c			jr z, .entercont 
18a5				; no, not a null term line so has an address to work out.... 
18a5			 
18a5 21 bd e2			ld hl,scratch+2 
18a8 cd b4 10			call get_word_hl 
18ab			 
18ab 22 de e5			ld (os_cur_ptr),hl	 
18ae c3 02 18			jp cli 
18b1			 
18b1			 
18b1			.entercont:  
18b1			 
18b1 21 bd e2			ld hl, scratch+2 
18b4 cd 54 10			call get_byte 
18b7			 
18b7 2a de e5		   	ld hl,(os_cur_ptr) 
18ba 77					ld (hl),a 
18bb 23					inc hl 
18bc 22 de e5				ld (os_cur_ptr),hl 
18bf				 
18bf			; get byte  
18bf			 
18bf			 
18bf c3 02 18			jp cli 
18c2			 
18c2			 
18c2			; basic monitor support 
18c2			 
18c2			monitor: 
18c2				;  
18c2 cd c8 0b			call clear_display 
18c5 3e 00			ld a, 0 
18c7 11 1b 19			ld de, .monprompt 
18ca cd db 0b			call str_at_display 
18cd cd eb 0b			call update_display 
18d0			 
18d0				; get a monitor command 
18d0			 
18d0 0e 00			ld c, 0     ; entry at top left 
18d2 16 64			ld d, 100   ; max buffer size 
18d4 1e 0f			ld e, 15    ; input scroll area 
18d6 3e 00			ld a, 0     ; init string 
18d8 21 b9 e4			ld hl, os_input 
18db 77				ld (hl), a 
18dc 23				inc hl 
18dd 77				ld (hl), a 
18de 21 b9 e4			ld hl, os_input 
18e1 3e 01			ld a, 1     ; init string 
18e3 cd 22 0e			call input_str 
18e6			 
18e6 cd c8 0b		        call clear_display 
18e9 cd eb 0b			call update_display		 
18ec			 
18ec 3a b9 e4			ld a, (os_input) 
18ef cd 52 11			call toUpper 
18f2 fe 48		        cp 'H' 
18f4 ca 8f 19		        jp z, .monhelp 
18f7 fe 44			cp 'D'		; dump 
18f9 ca c2 19			jp z, .mondump	 
18fc fe 43			cp 'C'		; dump 
18fe ca dc 19			jp z, .moncdump	 
1901 fe 4d			cp 'M'		; dump 
1903 ca 1d 19			jp z, .moneditstart 
1906 fe 55			cp 'U'		; dump 
1908 ca 29 19			jp z, .monedit	 
190b fe 47			cp 'G'		; dump 
190d ca b8 19			jp z, .monjump 
1910 fe 42			cp 'B'		; forth breakpoint 
1912 cc 11 15			call z, break_point_state 
1915 fe 51			cp 'Q'		; dump 
1917 c8				ret z	 
1918			 
1918			 
1918				; TODO "S" to access symbol by name and not need the address 
1918				; TODO "F" to find a string in memory 
1918			 
1918 c3 c2 18			jp monitor 
191b			 
191b .. 00		.monprompt: db ">", 0 
191d			 
191d			.moneditstart: 
191d				; get starting address 
191d			 
191d 21 bb e4			ld hl,os_input+2 
1920 cd b4 10			call get_word_hl 
1923			 
1923 22 de e5			ld (os_cur_ptr),hl	 
1926			 
1926 c3 c2 18			jp monitor 
1929			 
1929			.monedit: 
1929				; get byte to load 
1929			 
1929 21 bb e4			ld hl,os_input+2 
192c cd 54 10			call get_byte 
192f			 
192f				; get address to update 
192f 2a de e5			ld hl, (os_cur_ptr) 
1932			 
1932				; update byte 
1932			 
1932 77				ld (hl), a 
1933			 
1933				; move to next address and save it 
1933			 
1933 23				inc hl 
1934 22 de e5			ld (os_cur_ptr),hl	 
1937			 
1937 c3 c2 18			jp monitor 
193a			 
193a			 
193a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
194e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
196a .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1988 .. 00		.monhelptext4:  db "Q-Quit",0 
198f			        
198f			.monhelp: 
198f 3e 00			ld a, display_row_1 
1991 11 3a 19		        ld de, .monhelptext1 
1994			 
1994 cd db 0b			call str_at_display 
1997 3e 28			ld a, display_row_2 
1999 11 4e 19		        ld de, .monhelptext2 
199c					 
199c cd db 0b			call str_at_display 
199f 3e 50			ld a, display_row_3 
19a1 11 6a 19		        ld de, .monhelptext3 
19a4					 
19a4 cd db 0b			call str_at_display 
19a7 3e 78			ld a, display_row_4 
19a9 11 88 19		        ld de, .monhelptext4 
19ac cd db 0b			call str_at_display 
19af			 
19af cd eb 0b			call update_display		 
19b2			 
19b2 cd 08 1b			call next_page_prompt 
19b5 c3 c2 18			jp monitor 
19b8			 
19b8			.monjump:    
19b8 21 bb e4			ld hl,os_input+2 
19bb cd b4 10			call get_word_hl 
19be			 
19be e9				jp (hl) 
19bf c3 c2 18			jp monitor 
19c2			 
19c2			.mondump:    
19c2 21 bb e4			ld hl,os_input+2 
19c5 cd b4 10			call get_word_hl 
19c8			 
19c8 22 de e5			ld (os_cur_ptr),hl	 
19cb cd 10 1a			call dumpcont 
19ce 3e 78			ld a, display_row_4 
19d0 11 6e 18			ld de, endprog 
19d3			 
19d3 cd eb 0b			call update_display		 
19d6			 
19d6 cd 08 1b			call next_page_prompt 
19d9 c3 c2 18			jp monitor 
19dc			.moncdump: 
19dc cd 10 1a			call dumpcont 
19df 3e 78			ld a, display_row_4 
19e1 11 6e 18			ld de, endprog 
19e4			 
19e4 cd eb 0b			call update_display		 
19e7			 
19e7 cd 08 1b			call next_page_prompt 
19ea c3 c2 18			jp monitor 
19ed			 
19ed			 
19ed			; TODO symbol access  
19ed			 
19ed			.symbols:     ;; A list of symbols that can be called up  
19ed ab ed			dw display_fb0 
19ef .. 00			db "fb0",0  
19f3 74 ea		     	dw store_page 
19f5 .. 00			db "store_page",0 
1a00			 
1a00			 
1a00			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a00			 
1a00 3a bc e2			ld a,(scratch+1) 
1a03 fe 00			cp 0 
1a05 28 09			jr z, dumpcont 
1a07			 
1a07				; no, not a null term line so has an address to work out.... 
1a07			 
1a07 21 bd e2			ld hl,scratch+2 
1a0a cd b4 10			call get_word_hl 
1a0d			 
1a0d 22 de e5			ld (os_cur_ptr),hl	 
1a10			 
1a10			 
1a10			 
1a10			dumpcont: 
1a10			 
1a10				; dump bytes at ptr 
1a10			 
1a10			 
1a10 3e 00			ld a, display_row_1 
1a12 2a c6 eb			ld hl, (display_fb_active) 
1a15 cd f5 0d			call addatohl 
1a18 cd 40 1a			call .dumpbyterow 
1a1b			 
1a1b 3e 28			ld a, display_row_2 
1a1d 2a c6 eb			ld hl, (display_fb_active) 
1a20 cd f5 0d			call addatohl 
1a23 cd 40 1a			call .dumpbyterow 
1a26			 
1a26			 
1a26 3e 50			ld a, display_row_3 
1a28 2a c6 eb			ld hl, (display_fb_active) 
1a2b cd f5 0d			call addatohl 
1a2e cd 40 1a			call .dumpbyterow 
1a31			 
1a31 3e 78			ld a, display_row_4 
1a33 2a c6 eb			ld hl, (display_fb_active) 
1a36 cd f5 0d			call addatohl 
1a39 cd 40 1a			call .dumpbyterow 
1a3c			 
1a3c cd eb 0b			call update_display 
1a3f			;		jp cli 
1a3f c9				ret 
1a40			 
1a40			.dumpbyterow: 
1a40			 
1a40				;push af 
1a40			 
1a40 e5				push hl 
1a41			 
1a41				; calc where to poke the ascii 
1a41			if display_cols == 20 
1a41				ld a, 16 
1a41			else 
1a41 3e 1f			ld a, 31 
1a43			endif 
1a43			 
1a43 cd f5 0d			call addatohl 
1a46 22 c0 e5			ld (os_word_scratch),hl  		; save pos for later 
1a49			 
1a49			 
1a49			; display decoding address 
1a49 2a de e5		   	ld hl,(os_cur_ptr) 
1a4c			 
1a4c 7c				ld a,h 
1a4d e1				pop hl 
1a4e e5				push hl 
1a4f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a4f cd fe 0f			call hexout 
1a52 2a de e5		   	ld hl,(os_cur_ptr) 
1a55			 
1a55 7d				ld a,l 
1a56 e1				pop hl 
1a57 23				inc hl 
1a58 23				inc hl 
1a59 e5				push hl 
1a5a			;	ld hl, os_word_scratch+2 
1a5a cd fe 0f			call hexout 
1a5d e1				pop hl 
1a5e 23				inc hl 
1a5f 23				inc hl 
1a60				;ld hl, os_word_scratch+4 
1a60 3e 3a			ld a, ':' 
1a62 77				ld (hl),a 
1a63 23				inc hl 
1a64				;ld a, 0 
1a64				;ld (hl),a 
1a64				;ld de, os_word_scratch 
1a64				;pop af 
1a64				;push af 
1a64			;		ld a, display_row_2 
1a64			;		call str_at_display 
1a64			;		call update_display 
1a64			 
1a64			 
1a64			;pop af 
1a64			;	add 5 
1a64			 
1a64			if display_cols == 20 
1a64				ld b, 4 
1a64			else 
1a64 06 08			ld b, 8 
1a66			endif	 
1a66			 
1a66			.dumpbyte: 
1a66 c5				push bc 
1a67 e5				push hl 
1a68			 
1a68			 
1a68 2a de e5		   	ld hl,(os_cur_ptr) 
1a6b 7e					ld a,(hl) 
1a6c			 
1a6c					; poke the ascii to display 
1a6c 2a c0 e5				ld hl,(os_word_scratch) 
1a6f 77					ld (hl),a 
1a70 23					inc hl 
1a71 22 c0 e5				ld (os_word_scratch),hl 
1a74			 
1a74					 
1a74			 
1a74			 
1a74 e1					pop hl 
1a75 e5					push hl 
1a76			 
1a76 cd fe 0f				call hexout 
1a79			 
1a79					 
1a79 2a de e5		   	ld hl,(os_cur_ptr) 
1a7c 23				inc hl 
1a7d 22 de e5		   	ld (os_cur_ptr),hl 
1a80			 
1a80 e1					pop hl 
1a81 23					inc hl 
1a82 23					inc hl 
1a83 23					inc hl 
1a84			 
1a84			 
1a84			 
1a84					;ld a,0 
1a84					;ld (os_word_scratch+2),a 
1a84					;pop af 
1a84					;push af 
1a84			 
1a84					;ld de, os_word_scratch 
1a84					;call str_at_display 
1a84			;		call update_display 
1a84			;		pop af 
1a84 c1					pop bc 
1a85 c6 03				add 3 
1a87 10 dd			djnz .dumpbyte 
1a89			 
1a89				 
1a89			 
1a89 c9				ret 
1a8a			 
1a8a			jump:	 
1a8a			 
1a8a 21 bd e2			ld hl,scratch+2 
1a8d cd b4 10			call get_word_hl 
1a90				;ld hl,(scratch+2) 
1a90				;call fourehexhl 
1a90			 
1a90 22 de e5			ld (os_cur_ptr),hl	 
1a93			 
1a93 e9				jp (hl) 
1a94			 
1a94			 
1a94			 
1a94			; TODO implement a basic monitor mode to start with 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			; testing and demo code during development 
1a94			 
1a94			 
1a94 .. 00		str1: db "Enter some text...",0 
1aa7 .. 00		clear: db "                    ",0 
1abc			 
1abc			demo: 
1abc			 
1abc			 
1abc			 
1abc			;	call update_display 
1abc			 
1abc				; init scratch input area for testing 
1abc 21 bb e2			ld hl, scratch	 
1abf 3e 00			ld a,0 
1ac1 77				ld (hl),a 
1ac2			 
1ac2			 
1ac2 3e 28		            LD   A, display_row_2 
1ac4			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac4 11 94 1a		            LD   DE, str1 
1ac7 cd db 0b			call str_at_display 
1aca			 
1aca			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aca			cloop:	 
1aca 3e 50		            LD   A, display_row_3 
1acc			;            CALL fLCD_Pos       ;Position cursor to location in A 
1acc 11 a7 1a		            LD   DE, clear 
1acf			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1acf cd db 0b				call str_at_display 
1ad2 3e 78			ld a, display_row_4 
1ad4 11 04 1b			ld de, prompt 
1ad7			 
1ad7 cd db 0b				call str_at_display 
1ada cd eb 0b			call update_display 
1add			 
1add 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1adf 16 0a			ld d, 10 
1ae1 21 bb e2			ld hl, scratch	 
1ae4 cd 22 0e			call input_str 
1ae7			 
1ae7			;	call clear_display 
1ae7			;'	call update_display 
1ae7			 
1ae7 3e 00		            LD   A, display_row_1 
1ae9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ae9 11 a7 1a		            LD   DE, clear 
1aec cd db 0b				call str_at_display 
1aef			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aef 3e 00		            LD   A, display_row_1 
1af1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1af1 11 bb e2		            LD   DE, scratch 
1af4			;            CALL fLCD_Str       ;Display string pointed to by DE 
1af4 cd db 0b				call str_at_display 
1af7 cd eb 0b			call update_display 
1afa			 
1afa 3e 00				ld a,0 
1afc 21 bb e2			ld hl, scratch 
1aff 77				ld (hl),a 
1b00			 
1b00 00				nop 
1b01 c3 ca 1a			jp cloop 
1b04			 
1b04			 
1b04			 
1b04			; OS Prompt 
1b04			 
1b04 .. 00		prompt: db ">",0 
1b06 .. 00		endprg: db "?",0 
1b08			 
1b08			 
1b08			; handy next page prompt 
1b08			next_page_prompt: 
1b08 e5				push hl 
1b09 d5				push de 
1b0a f5				push af 
1b0b c5				push bc 
1b0c			 
1b0c 3e 9f			ld a,display_row_4 + display_cols - 1 
1b0e 11 06 1b		        ld de, endprg 
1b11 cd db 0b			call str_at_display 
1b14 cd eb 0b			call update_display 
1b17 cd 01 64			call cin_wait 
1b1a c1				pop bc 
1b1b f1				pop af 
1b1c d1				pop de 
1b1d e1				pop hl 
1b1e			 
1b1e			 
1b1e c9				ret 
1b1f			 
1b1f			 
1b1f			; forth parser 
1b1f			 
1b1f			; My forth kernel 
1b1f			include "forth_kernel.asm" 
1b1f			; 
1b1f			; kernel to the forth OS 
1b1f			 
1b1f			DS_TYPE_STR: equ 1     ; string type 
1b1f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b1f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b1f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b1f			 
1b1f			FORTH_PARSEV1: equ 0 
1b1f			FORTH_PARSEV2: equ 0 
1b1f			FORTH_PARSEV3: equ 0 
1b1f			FORTH_PARSEV4: equ 0 
1b1f			FORTH_PARSEV5: equ 0 
1b1f			FORTH_PARSEV6: equ 1 
1b1f			 
1b1f			;if FORTH_PARSEV5 
1b1f			;	FORTH_END_BUFFER: equ 0 
1b1f			;else 
1b1f			FORTH_END_BUFFER: equ 127 
1b1f			;endif 
1b1f			 
1b1f			FORTH_TRUE: equ 1 
1b1f			FORTH_FALSE: equ 0 
1b1f			 
1b1f			if FORTH_PARSEV4 
1b1f			include "forth_stackops.asm" 
1b1f			endif 
1b1f			 
1b1f			if FORTH_PARSEV5 
1b1f			include "forth_stackopsv5.asm" 
1b1f			endif 
1b1f			 
1b1f			if FORTH_PARSEV6 
1b1f			include "forth_stackopsv5.asm" 
1b1f			 
1b1f			; Stack operations for v5 parser on wards 
1b1f			; * DATA stack 
1b1f			; * LOOP stack 
1b1f			; * RETURN stack 
1b1f			 
1b1f			 
1b1f			 
1b1f			FORTH_CHK_DSP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_data_sp) 
1b1f				ld de, cli_data_stack 
1b1f				call cmp16 
1b1f				jp c, fault_dsp_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			FORTH_CHK_RSP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_ret_sp) 
1b1f				ld de, cli_ret_stack 
1b1f				call cmp16 
1b1f				jp c, fault_rsp_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			FORTH_CHK_LOOP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_loop_sp) 
1b1f				ld de, cli_loop_stack 
1b1f				call cmp16 
1b1f				jp c, fault_loop_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			FORTH_ERR_TOS_NOTSTR: macro 
1b1f				; TOSO might need more for checks when used 
1b1f				push af 
1b1f				ld a,(hl) 
1b1f				cp DS_TYPE_STR 
1b1f				jp nz, type_faultn   
1b1f				pop af 
1b1f				endm 
1b1f			 
1b1f			FORTH_ERR_TOS_NOTNUM: macro 
1b1f				push af 
1b1f				ld a,(hl) 
1b1f				cp DS_TYPE_INUM 
1b1f				jp nz, type_faultn   
1b1f				pop af 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			; increase data stack pointer and save hl to it 
1b1f				 
1b1f			FORTH_DSP_NEXT: macro 
1b1f				call macro_forth_dsp_next 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			macro_forth_dsp_next: 
1b1f				if DEBUG_FORTH_STACK_GUARD 
1b1f cd 27 60				call check_stacks 
1b22				endif 
1b22 e5				push hl 
1b23 d5				push de 
1b24 eb				ex de,hl 
1b25 2a e8 e9			ld hl,(cli_data_sp) 
1b28 23				inc hl 
1b29 23				inc hl 
1b2a			 
1b2a			; PARSEV5 
1b2a 23				inc hl 
1b2b 22 e8 e9			ld (cli_data_sp),hl 
1b2e 73				ld (hl), e 
1b2f 23				inc hl 
1b30 72				ld (hl), d 
1b31 d1				pop de 
1b32 e1				pop hl 
1b33				if DEBUG_FORTH_STACK_GUARD 
1b33 cd 27 60				call check_stacks 
1b36				endif 
1b36 c9				ret 
1b37			 
1b37			 
1b37			; increase ret stack pointer and save hl to it 
1b37				 
1b37			FORTH_RSP_NEXT: macro 
1b37				call macro_forth_rsp_next 
1b37				endm 
1b37			 
1b37			macro_forth_rsp_next: 
1b37				if DEBUG_FORTH_STACK_GUARD 
1b37 cd 27 60				call check_stacks 
1b3a				endif 
1b3a e5				push hl 
1b3b d5				push de 
1b3c eb				ex de,hl 
1b3d 2a ec e9			ld hl,(cli_ret_sp) 
1b40 23				inc hl 
1b41 23				inc hl 
1b42 22 ec e9			ld (cli_ret_sp),hl 
1b45 73				ld (hl), e 
1b46 23				inc hl 
1b47 72				ld (hl), d 
1b48 d1				pop de 
1b49 e1				pop hl 
1b4a				if DEBUG_FORTH_STACK_GUARD 
1b4a cd 27 60				call check_stacks 
1b4d				endif 
1b4d c9				ret 
1b4e			 
1b4e			; get current ret stack pointer and save to hl  
1b4e				 
1b4e			FORTH_RSP_TOS: macro 
1b4e				call macro_forth_rsp_tos 
1b4e				endm 
1b4e			 
1b4e			macro_forth_rsp_tos: 
1b4e				;push de 
1b4e 2a ec e9			ld hl,(cli_ret_sp) 
1b51 cd 89 1b			call loadhlptrtohl 
1b54				;ld e, (hl) 
1b54				;inc hl 
1b54				;ld d, (hl) 
1b54				;ex de, hl 
1b54					if DEBUG_FORTH_WORDS 
1b54			;			DMARK "RST" 
1b54						CALLMONITOR 
1b54 cd 6f ee			call debug_vector  
1b57				endm  
# End of macro CALLMONITOR
1b57					endif 
1b57				;pop de 
1b57 c9				ret 
1b58			 
1b58			; pop ret stack pointer 
1b58				 
1b58			FORTH_RSP_POP: macro 
1b58				call macro_forth_rsp_pop 
1b58				endm 
1b58			 
1b58			 
1b58			macro_forth_rsp_pop: 
1b58				if DEBUG_FORTH_STACK_GUARD 
1b58			;		DMARK "RPP" 
1b58 cd 27 60				call check_stacks 
1b5b					FORTH_CHK_RSP_UNDER 
1b5b e5				push hl 
1b5c d5				push de 
1b5d 2a ec e9			ld hl,(cli_ret_sp) 
1b60 11 a6 e9			ld de, cli_ret_stack 
1b63 cd 13 0e			call cmp16 
1b66 da 3e 61			jp c, fault_rsp_under 
1b69 d1				pop de 
1b6a e1				pop hl 
1b6b				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b6b				endif 
1b6b e5				push hl 
1b6c 2a ec e9			ld hl,(cli_ret_sp) 
1b6f			 
1b6f			 
1b6f				if FORTH_ENABLE_FREE 
1b6f			 
1b6f					; get pointer 
1b6f			 
1b6f					push de 
1b6f					push hl 
1b6f			 
1b6f					ld e, (hl) 
1b6f					inc hl 
1b6f					ld d, (hl) 
1b6f			 
1b6f					ex de, hl 
1b6f					call free 
1b6f			 
1b6f					pop hl 
1b6f					pop de 
1b6f			 
1b6f			 
1b6f				endif 
1b6f			 
1b6f			 
1b6f 2b				dec hl 
1b70 2b				dec hl 
1b71 22 ec e9			ld (cli_ret_sp), hl 
1b74				; do stack underflow checks 
1b74 e1				pop hl 
1b75				if DEBUG_FORTH_STACK_GUARD 
1b75 cd 27 60				call check_stacks 
1b78					FORTH_CHK_RSP_UNDER 
1b78 e5				push hl 
1b79 d5				push de 
1b7a 2a ec e9			ld hl,(cli_ret_sp) 
1b7d 11 a6 e9			ld de, cli_ret_stack 
1b80 cd 13 0e			call cmp16 
1b83 da 3e 61			jp c, fault_rsp_under 
1b86 d1				pop de 
1b87 e1				pop hl 
1b88				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b88				endif 
1b88 c9				ret 
1b89			 
1b89			 
1b89			 
1b89			; routine to load word pointed to by hl into hl 
1b89			 
1b89			loadhlptrtohl: 
1b89			 
1b89 d5				push de 
1b8a 5e				ld e, (hl) 
1b8b 23				inc hl 
1b8c 56				ld d, (hl) 
1b8d eb				ex de, hl 
1b8e d1				pop de 
1b8f			 
1b8f c9				ret 
1b90			 
1b90			 
1b90			 
1b90			 
1b90			 
1b90			; push a number held in HL onto the data stack 
1b90			; entry point for pushing a value when already in hl used in function above 
1b90			 
1b90			forth_push_numhl: 
1b90			 
1b90 e5				push hl    ; save value to push 
1b91			 
1b91			if DEBUG_FORTH_PUSH 
1b91				; see if disabled 
1b91			 
1b91			 
1b91 f5				push af 
1b92 3a 6f ee			ld a,(debug_vector) 
1b95 fe c9			cp $c9   ; ret 
1b97			;	ld a, (os_view_disable) 
1b97			;	cp '*' 
1b97 28 34			jr z, .pskip2 
1b99 e5				push hl 
1b9a e5			push hl 
1b9b cd c8 0b			call clear_display 
1b9e e1			pop hl 
1b9f 7c				ld a,h 
1ba0 21 c0 e5			ld hl, os_word_scratch 
1ba3 cd fe 0f			call hexout 
1ba6 e1				pop hl 
1ba7 7d				ld a,l 
1ba8 21 c2 e5			ld hl, os_word_scratch+2 
1bab cd fe 0f			call hexout 
1bae			 
1bae 21 c4 e5			ld hl, os_word_scratch+4 
1bb1 3e 00			ld a,0 
1bb3 77				ld (hl),a 
1bb4 11 c0 e5			ld de,os_word_scratch 
1bb7 3e 28				ld a, display_row_2 
1bb9 cd db 0b				call str_at_display 
1bbc 11 20 52			ld de, .push_num 
1bbf 3e 00			ld a, display_row_1 
1bc1			 
1bc1 cd db 0b				call str_at_display 
1bc4			 
1bc4			 
1bc4 cd eb 0b			call update_display 
1bc7 cd 00 0b			call delay1s 
1bca cd 00 0b			call delay1s 
1bcd			.pskip2:  
1bcd			 
1bcd f1				pop af 
1bce			endif	 
1bce			 
1bce			 
1bce				FORTH_DSP_NEXT 
1bce cd 1f 1b			call macro_forth_dsp_next 
1bd1				endm 
# End of macro FORTH_DSP_NEXT
1bd1			 
1bd1 2a e8 e9			ld hl, (cli_data_sp) 
1bd4			 
1bd4				; save item type 
1bd4 3e 02			ld a,  DS_TYPE_INUM 
1bd6 77				ld (hl), a 
1bd7 23				inc hl 
1bd8			 
1bd8				; get word off stack 
1bd8 d1				pop de 
1bd9 7b				ld a,e 
1bda 77				ld (hl), a 
1bdb 23				inc hl 
1bdc 7a				ld a,d 
1bdd 77				ld (hl), a 
1bde			 
1bde			if DEBUG_FORTH_PUSH 
1bde 2b				dec hl 
1bdf 2b				dec hl 
1be0 2b				dec hl 
1be1						DMARK "PH5" 
1be1 f5				push af  
1be2 3a f6 1b			ld a, (.dmark)  
1be5 32 65 ee			ld (debug_mark),a  
1be8 3a f7 1b			ld a, (.dmark+1)  
1beb 32 66 ee			ld (debug_mark+1),a  
1bee 3a f8 1b			ld a, (.dmark+2)  
1bf1 32 67 ee			ld (debug_mark+2),a  
1bf4 18 03			jr .pastdmark  
1bf6 ..			.dmark: db "PH5"  
1bf9 f1			.pastdmark: pop af  
1bfa			endm  
# End of macro DMARK
1bfa				CALLMONITOR 
1bfa cd 6f ee			call debug_vector  
1bfd				endm  
# End of macro CALLMONITOR
1bfd			endif	 
1bfd			 
1bfd c9				ret 
1bfe			 
1bfe			 
1bfe			; Push a string to stack pointed to by hl 
1bfe			 
1bfe			forth_push_str: 
1bfe			 
1bfe			if DEBUG_FORTH_PUSH 
1bfe						DMARK "PSQ" 
1bfe f5				push af  
1bff 3a 13 1c			ld a, (.dmark)  
1c02 32 65 ee			ld (debug_mark),a  
1c05 3a 14 1c			ld a, (.dmark+1)  
1c08 32 66 ee			ld (debug_mark+1),a  
1c0b 3a 15 1c			ld a, (.dmark+2)  
1c0e 32 67 ee			ld (debug_mark+2),a  
1c11 18 03			jr .pastdmark  
1c13 ..			.dmark: db "PSQ"  
1c16 f1			.pastdmark: pop af  
1c17			endm  
# End of macro DMARK
1c17				CALLMONITOR 
1c17 cd 6f ee			call debug_vector  
1c1a				endm  
# End of macro CALLMONITOR
1c1a			endif	 
1c1a			 
1c1a			 
1c1a			    
1c1a e5				push hl 
1c1b e5				push hl 
1c1c			 
1c1c			;	ld a, 0   ; find end of string 
1c1c cd 5b 11			call strlenz 
1c1f			if DEBUG_FORTH_PUSH 
1c1f						DMARK "PQ2" 
1c1f f5				push af  
1c20 3a 34 1c			ld a, (.dmark)  
1c23 32 65 ee			ld (debug_mark),a  
1c26 3a 35 1c			ld a, (.dmark+1)  
1c29 32 66 ee			ld (debug_mark+1),a  
1c2c 3a 36 1c			ld a, (.dmark+2)  
1c2f 32 67 ee			ld (debug_mark+2),a  
1c32 18 03			jr .pastdmark  
1c34 ..			.dmark: db "PQ2"  
1c37 f1			.pastdmark: pop af  
1c38			endm  
# End of macro DMARK
1c38				CALLMONITOR 
1c38 cd 6f ee			call debug_vector  
1c3b				endm  
# End of macro CALLMONITOR
1c3b			endif	 
1c3b eb				ex de, hl 
1c3c e1				pop hl   ; get ptr to start of string 
1c3d			if DEBUG_FORTH_PUSH 
1c3d						DMARK "PQ3" 
1c3d f5				push af  
1c3e 3a 52 1c			ld a, (.dmark)  
1c41 32 65 ee			ld (debug_mark),a  
1c44 3a 53 1c			ld a, (.dmark+1)  
1c47 32 66 ee			ld (debug_mark+1),a  
1c4a 3a 54 1c			ld a, (.dmark+2)  
1c4d 32 67 ee			ld (debug_mark+2),a  
1c50 18 03			jr .pastdmark  
1c52 ..			.dmark: db "PQ3"  
1c55 f1			.pastdmark: pop af  
1c56			endm  
# End of macro DMARK
1c56				CALLMONITOR 
1c56 cd 6f ee			call debug_vector  
1c59				endm  
# End of macro CALLMONITOR
1c59			endif	 
1c59 19				add hl,de 
1c5a			if DEBUG_FORTH_PUSH 
1c5a						DMARK "PQE" 
1c5a f5				push af  
1c5b 3a 6f 1c			ld a, (.dmark)  
1c5e 32 65 ee			ld (debug_mark),a  
1c61 3a 70 1c			ld a, (.dmark+1)  
1c64 32 66 ee			ld (debug_mark+1),a  
1c67 3a 71 1c			ld a, (.dmark+2)  
1c6a 32 67 ee			ld (debug_mark+2),a  
1c6d 18 03			jr .pastdmark  
1c6f ..			.dmark: db "PQE"  
1c72 f1			.pastdmark: pop af  
1c73			endm  
# End of macro DMARK
1c73				CALLMONITOR 
1c73 cd 6f ee			call debug_vector  
1c76				endm  
# End of macro CALLMONITOR
1c76			endif	 
1c76			 
1c76 2b				dec hl    ; see if there is an optional trailing double quote 
1c77 7e				ld a,(hl) 
1c78 fe 22			cp '"' 
1c7a 20 03			jr nz, .strnoq 
1c7c 3e 00			ld a, 0      ; get rid of double quote 
1c7e 77				ld (hl), a 
1c7f 23			.strnoq: inc hl 
1c80			 
1c80 3e 00			ld a, 0 
1c82 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c83			 
1c83 13				inc de ; add one for the type string 
1c84 13				inc de ; add one for null term??? 
1c85			 
1c85				; tos is get string pointer again 
1c85				; de contains space to allocate 
1c85				 
1c85 d5				push de 
1c86			 
1c86 eb				ex de, hl 
1c87			 
1c87				;push af 
1c87			 
1c87			if DEBUG_FORTH_PUSH 
1c87						DMARK "PHm" 
1c87 f5				push af  
1c88 3a 9c 1c			ld a, (.dmark)  
1c8b 32 65 ee			ld (debug_mark),a  
1c8e 3a 9d 1c			ld a, (.dmark+1)  
1c91 32 66 ee			ld (debug_mark+1),a  
1c94 3a 9e 1c			ld a, (.dmark+2)  
1c97 32 67 ee			ld (debug_mark+2),a  
1c9a 18 03			jr .pastdmark  
1c9c ..			.dmark: db "PHm"  
1c9f f1			.pastdmark: pop af  
1ca0			endm  
# End of macro DMARK
1ca0				CALLMONITOR 
1ca0 cd 6f ee			call debug_vector  
1ca3				endm  
# End of macro CALLMONITOR
1ca3			endif	 
1ca3 cd d0 11			call malloc	; on ret hl now contains allocated memory 
1ca6				if DEBUG_FORTH_MALLOC_GUARD 
1ca6 cc 78 52				call z,malloc_error 
1ca9				endif 
1ca9			 
1ca9				 
1ca9 c1				pop bc    ; get length 
1caa d1				pop de   ;  get string start    
1cab			 
1cab				; hl has destination from malloc 
1cab			 
1cab eb				ex de, hl    ; prep for ldir 
1cac			 
1cac d5				push de   ; save malloc area for DSP later 
1cad				;push hl   ; save malloc area for DSP later 
1cad			 
1cad			if DEBUG_FORTH_PUSH 
1cad						DMARK "PHc" 
1cad f5				push af  
1cae 3a c2 1c			ld a, (.dmark)  
1cb1 32 65 ee			ld (debug_mark),a  
1cb4 3a c3 1c			ld a, (.dmark+1)  
1cb7 32 66 ee			ld (debug_mark+1),a  
1cba 3a c4 1c			ld a, (.dmark+2)  
1cbd 32 67 ee			ld (debug_mark+2),a  
1cc0 18 03			jr .pastdmark  
1cc2 ..			.dmark: db "PHc"  
1cc5 f1			.pastdmark: pop af  
1cc6			endm  
# End of macro DMARK
1cc6				CALLMONITOR 
1cc6 cd 6f ee			call debug_vector  
1cc9				endm  
# End of macro CALLMONITOR
1cc9			endif	 
1cc9			 
1cc9			 
1cc9 ed b0			ldir 
1ccb			 
1ccb			 
1ccb				; push malloc to data stack     macro?????  
1ccb			 
1ccb				FORTH_DSP_NEXT 
1ccb cd 1f 1b			call macro_forth_dsp_next 
1cce				endm 
# End of macro FORTH_DSP_NEXT
1cce			 
1cce				; save value and type 
1cce			 
1cce 2a e8 e9			ld hl, (cli_data_sp) 
1cd1			 
1cd1				; save item type 
1cd1 3e 01			ld a,  DS_TYPE_STR 
1cd3 77				ld (hl), a 
1cd4 23				inc hl 
1cd5			 
1cd5				; get malloc word off stack 
1cd5 d1				pop de 
1cd6 73				ld (hl), e 
1cd7 23				inc hl 
1cd8 72				ld (hl), d 
1cd9			 
1cd9			 
1cd9			 
1cd9			if DEBUG_FORTH_PUSH 
1cd9 2a e8 e9			ld hl, (cli_data_sp) 
1cdc						DMARK "PHS" 
1cdc f5				push af  
1cdd 3a f1 1c			ld a, (.dmark)  
1ce0 32 65 ee			ld (debug_mark),a  
1ce3 3a f2 1c			ld a, (.dmark+1)  
1ce6 32 66 ee			ld (debug_mark+1),a  
1ce9 3a f3 1c			ld a, (.dmark+2)  
1cec 32 67 ee			ld (debug_mark+2),a  
1cef 18 03			jr .pastdmark  
1cf1 ..			.dmark: db "PHS"  
1cf4 f1			.pastdmark: pop af  
1cf5			endm  
# End of macro DMARK
1cf5				CALLMONITOR 
1cf5 cd 6f ee			call debug_vector  
1cf8				endm  
# End of macro CALLMONITOR
1cf8			;	ex de,hl 
1cf8			endif	 
1cf8				; in case of spaces, skip the ptr past the copied string 
1cf8				;pop af 
1cf8				;ld (cli_origptr),hl 
1cf8			 
1cf8 c9				ret 
1cf9			 
1cf9			 
1cf9			 
1cf9			; TODO ascii push input onto stack given hl to start of input 
1cf9			 
1cf9			; identify type 
1cf9			; if starts with a " then a string 
1cf9			; otherwise it is a number 
1cf9			;  
1cf9			; if a string 
1cf9			;     scan for ending " to get length of string to malloc for + 1 
1cf9			;     malloc 
1cf9			;     put pointer to string on stack first byte flags as string 
1cf9			; 
1cf9			; else a number 
1cf9			;    look for number format identifier 
1cf9			;    $xx hex 
1cf9			;    %xxxxx bin 
1cf9			;    xxxxx decimal 
1cf9			;    convert number to 16bit word.  
1cf9			;    malloc word + 1 with flag to identiy as num 
1cf9			;    put pointer to number on stack 
1cf9			;   
1cf9			;  
1cf9			  
1cf9			forth_apush: 
1cf9				; kernel push 
1cf9			 
1cf9			if DEBUG_FORTH_PUSH 
1cf9						DMARK "PSH" 
1cf9 f5				push af  
1cfa 3a 0e 1d			ld a, (.dmark)  
1cfd 32 65 ee			ld (debug_mark),a  
1d00 3a 0f 1d			ld a, (.dmark+1)  
1d03 32 66 ee			ld (debug_mark+1),a  
1d06 3a 10 1d			ld a, (.dmark+2)  
1d09 32 67 ee			ld (debug_mark+2),a  
1d0c 18 03			jr .pastdmark  
1d0e ..			.dmark: db "PSH"  
1d11 f1			.pastdmark: pop af  
1d12			endm  
# End of macro DMARK
1d12				CALLMONITOR 
1d12 cd 6f ee			call debug_vector  
1d15				endm  
# End of macro CALLMONITOR
1d15			endif	 
1d15				; identify input type 
1d15			 
1d15 7e				ld a,(hl) 
1d16			 
1d16 fe 23			cp '#' 
1d18 ca 52 1d			jp z, .fapdec 
1d1b			 
1d1b			 
1d1b fe 22			cp '"' 
1d1d 28 0a			jr z, .fapstr 
1d1f fe 24			cp '$' 
1d21 ca 49 1d			jp z, .faphex 
1d24 fe 25			cp '%' 
1d26 ca 31 1d			jp z, .fapbin 
1d29			;	cp 'b' 
1d29			;	jp z, .fabin 
1d29				; else decimal 
1d29			 
1d29				; TODO do decimal conversion 
1d29				; decimal is stored as a 16bit word 
1d29			 
1d29				; by default everything is a string if type is not detected 
1d29			.fapstr: ; 
1d29 fe 22			cp '"' 
1d2b 20 01			jr nz, .strnoqu 
1d2d 23				inc hl 
1d2e			.strnoqu: 
1d2e c3 fe 1b			jp forth_push_str 
1d31			 
1d31			 
1d31			 
1d31			.fapbin:    ; push a binary string.  
1d31 11 00 00			ld de, 0   ; hold a 16bit value 
1d34			 
1d34 23			.fapbinshift:	inc hl  
1d35 7e				ld a,(hl) 
1d36 fe 00			cp 0     ; done scanning  
1d38 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d3a			 
1d3a				; left shift de 
1d3a eb				ex de, hl	 
1d3b 29				add hl, hl 
1d3c			 
1d3c				; is 1 
1d3c fe 31			cp '1' 
1d3e 20 02			jr nz, .binzero 
1d40 cb 4d			bit 1, l 
1d42			.binzero: 
1d42 eb				ex de, hl	 ; save current de 
1d43 18 ef			jr .fapbinshift 
1d45			 
1d45			.fapbdone: 
1d45 eb				ex de, hl 
1d46 c3 90 1b			jp forth_push_numhl 
1d49			 
1d49			 
1d49			.faphex:   ; hex is always stored as a 16bit word 
1d49				; skip number prefix 
1d49 23				inc hl 
1d4a				; turn ascii into number 
1d4a cd b4 10			call get_word_hl	; ret 16bit word in hl 
1d4d			 
1d4d c3 90 1b			jp forth_push_numhl 
1d50			 
1d50 00				 nop 
1d51			 
1d51			.fabin:   ; TODO bin conversion 
1d51			 
1d51			 
1d51 c9				ret 
1d52			.fapdec:	 
1d52				; string to dec conversion 
1d52 23				inc hl 
1d53 eb				ex de, hl 
1d54 cd f2 10			call string_to_uint16 
1d57 c3 90 1b			jp forth_push_numhl 
1d5a c9				ret 
1d5b				 
1d5b			;atoui_16: 
1d5b			 
1d5b			; get either a string ptr or a 16bit word from the data stack 
1d5b			 
1d5b			FORTH_DSP: macro 
1d5b				call macro_forth_dsp 
1d5b				endm 
1d5b			 
1d5b			macro_forth_dsp: 
1d5b				; data stack pointer points to current word on tos 
1d5b			 
1d5b 2a e8 e9			ld hl,(cli_data_sp) 
1d5e			 
1d5e				if DEBUG_FORTH_PUSH 
1d5e						DMARK "DSP" 
1d5e f5				push af  
1d5f 3a 73 1d			ld a, (.dmark)  
1d62 32 65 ee			ld (debug_mark),a  
1d65 3a 74 1d			ld a, (.dmark+1)  
1d68 32 66 ee			ld (debug_mark+1),a  
1d6b 3a 75 1d			ld a, (.dmark+2)  
1d6e 32 67 ee			ld (debug_mark+2),a  
1d71 18 03			jr .pastdmark  
1d73 ..			.dmark: db "DSP"  
1d76 f1			.pastdmark: pop af  
1d77			endm  
# End of macro DMARK
1d77			 
1d77 cd ab 52				call display_data_sp 
1d7a				;call break_point_state 
1d7a				;rst 030h 
1d7a				CALLMONITOR 
1d7a cd 6f ee			call debug_vector  
1d7d				endm  
# End of macro CALLMONITOR
1d7d				endif 
1d7d			 
1d7d c9				ret 
1d7e			 
1d7e			; return hl to start of value on stack 
1d7e			 
1d7e			FORTH_DSP_VALUE: macro 
1d7e				call macro_forth_dsp_value 
1d7e				endm 
1d7e			 
1d7e			macro_forth_dsp_value: 
1d7e			 
1d7e				FORTH_DSP 
1d7e cd 5b 1d			call macro_forth_dsp 
1d81				endm 
# End of macro FORTH_DSP
1d81			 
1d81 d5				push de 
1d82			 
1d82 23				inc hl ; skip type 
1d83			 
1d83 5e				ld e, (hl) 
1d84 23				inc hl 
1d85 56				ld d, (hl) 
1d86 eb				ex de,hl  
1d87			 
1d87 d1				pop de 
1d88			 
1d88 c9				ret 
1d89			 
1d89			; return hl to start of value to second item on stack 
1d89			 
1d89			FORTH_DSP_VALUEM1: macro 
1d89				call macro_forth_dsp_value_m1 
1d89				endm 
1d89			 
1d89			macro_forth_dsp_value_m1: 
1d89			 
1d89				FORTH_DSP 
1d89 cd 5b 1d			call macro_forth_dsp 
1d8c				endm 
# End of macro FORTH_DSP
1d8c			 
1d8c 2b				dec hl 
1d8d 2b				dec hl 
1d8e			;	dec hl 
1d8e			 
1d8e d5				push de 
1d8f			 
1d8f 5e				ld e, (hl) 
1d90 23				inc hl 
1d91 56				ld d, (hl) 
1d92 eb				ex de,hl  
1d93			 
1d93 d1				pop de 
1d94			 
1d94 c9				ret 
1d95			 
1d95				 
1d95			 
1d95			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d95			 
1d95			FORTH_DSP_POP: macro 
1d95				call macro_forth_dsp_pop 
1d95				endm 
1d95			 
1d95			 
1d95			; get the tos data type 
1d95			 
1d95			FORTH_DSP_TYPE:   macro 
1d95			 
1d95				;FORTH_DSP_VALUE 
1d95				FORTH_DSP 
1d95				 
1d95				; hl points to value 
1d95				; check type 
1d95			 
1d95				ld a,(hl) 
1d95			 
1d95				endm 
1d95			 
1d95			; load the tos value into hl 
1d95			 
1d95			 
1d95			FORTH_DSP_VALUEHL:  macro 
1d95				call macro_dsp_valuehl 
1d95				endm 
1d95			 
1d95			 
1d95			 
1d95			macro_dsp_valuehl: 
1d95				FORTH_DSP_VALUE 
1d95 cd 7e 1d			call macro_forth_dsp_value 
1d98				endm 
# End of macro FORTH_DSP_VALUE
1d98			 
1d98				;FORTH_ERR_TOS_NOTNUM 
1d98			 
1d98				;inc hl   ; skip type id 
1d98			 
1d98			;	push de 
1d98			; 
1d98			;	ld e, (hl) 
1d98			;	inc hl 
1d98			;	ld d, (hl) 
1d98			;	ex de,hl  
1d98			 
1d98			;	pop de 
1d98			 
1d98				if DEBUG_FORTH_PUSH 
1d98						DMARK "DVL" 
1d98 f5				push af  
1d99 3a ad 1d			ld a, (.dmark)  
1d9c 32 65 ee			ld (debug_mark),a  
1d9f 3a ae 1d			ld a, (.dmark+1)  
1da2 32 66 ee			ld (debug_mark+1),a  
1da5 3a af 1d			ld a, (.dmark+2)  
1da8 32 67 ee			ld (debug_mark+2),a  
1dab 18 03			jr .pastdmark  
1dad ..			.dmark: db "DVL"  
1db0 f1			.pastdmark: pop af  
1db1			endm  
# End of macro DMARK
1db1				CALLMONITOR 
1db1 cd 6f ee			call debug_vector  
1db4				endm  
# End of macro CALLMONITOR
1db4				endif 
1db4 c9				ret 
1db5			 
1db5			forth_apushstrhl:      
1db5				; push of string requires use of cli_origptr 
1db5				; bodge use 
1db5			 
1db5				; get current cli_origptr, save, update with temp pointer  
1db5 ed 5b 38 ea		ld de, (cli_origptr) 
1db9 22 38 ea			ld (cli_origptr), hl 
1dbc d5				push de 
1dbd cd f9 1c			call forth_apush 
1dc0 d1				pop de 
1dc1 ed 53 38 ea		ld (cli_origptr), de 
1dc5 c9			        ret	 
1dc6			 
1dc6			 
1dc6			; increase loop stack pointer and save hl to it 
1dc6				 
1dc6			FORTH_LOOP_NEXT: macro 
1dc6				call macro_forth_loop_next 
1dc6				;nop 
1dc6				endm 
1dc6			 
1dc6			macro_forth_loop_next: 
1dc6				if DEBUG_FORTH_STACK_GUARD 
1dc6 cd 27 60				call check_stacks 
1dc9				endif 
1dc9 e5				push hl 
1dca d5				push de 
1dcb eb				ex de,hl 
1dcc 2a ea e9			ld hl,(cli_loop_sp) 
1dcf 23				inc hl 
1dd0 23				inc hl 
1dd1					if DEBUG_FORTH_WORDS 
1dd1						DMARK "LNX" 
1dd1 f5				push af  
1dd2 3a e6 1d			ld a, (.dmark)  
1dd5 32 65 ee			ld (debug_mark),a  
1dd8 3a e7 1d			ld a, (.dmark+1)  
1ddb 32 66 ee			ld (debug_mark+1),a  
1dde 3a e8 1d			ld a, (.dmark+2)  
1de1 32 67 ee			ld (debug_mark+2),a  
1de4 18 03			jr .pastdmark  
1de6 ..			.dmark: db "LNX"  
1de9 f1			.pastdmark: pop af  
1dea			endm  
# End of macro DMARK
1dea						CALLMONITOR 
1dea cd 6f ee			call debug_vector  
1ded				endm  
# End of macro CALLMONITOR
1ded					endif 
1ded 22 ea e9			ld (cli_loop_sp),hl 
1df0 73				ld (hl), e 
1df1 23				inc hl 
1df2 72				ld (hl), d 
1df3 d1				pop de    ; been reversed so save a swap on restore 
1df4 e1				pop hl 
1df5				if DEBUG_FORTH_STACK_GUARD 
1df5 cd 27 60				call check_stacks 
1df8				endif 
1df8 c9				ret 
1df9			 
1df9			; get current ret stack pointer and save to hl  
1df9				 
1df9			FORTH_LOOP_TOS: macro 
1df9				call macro_forth_loop_tos 
1df9				endm 
1df9			 
1df9			macro_forth_loop_tos: 
1df9 d5				push de 
1dfa 2a ea e9			ld hl,(cli_loop_sp) 
1dfd 5e				ld e, (hl) 
1dfe 23				inc hl 
1dff 56				ld d, (hl) 
1e00 eb				ex de, hl 
1e01 d1				pop de 
1e02 c9				ret 
1e03			 
1e03			; pop loop stack pointer 
1e03				 
1e03			FORTH_LOOP_POP: macro 
1e03				call macro_forth_loop_pop 
1e03				endm 
1e03			 
1e03			 
1e03			macro_forth_loop_pop: 
1e03				if DEBUG_FORTH_STACK_GUARD 
1e03					DMARK "LPP" 
1e03 f5				push af  
1e04 3a 18 1e			ld a, (.dmark)  
1e07 32 65 ee			ld (debug_mark),a  
1e0a 3a 19 1e			ld a, (.dmark+1)  
1e0d 32 66 ee			ld (debug_mark+1),a  
1e10 3a 1a 1e			ld a, (.dmark+2)  
1e13 32 67 ee			ld (debug_mark+2),a  
1e16 18 03			jr .pastdmark  
1e18 ..			.dmark: db "LPP"  
1e1b f1			.pastdmark: pop af  
1e1c			endm  
# End of macro DMARK
1e1c cd 27 60				call check_stacks 
1e1f					FORTH_CHK_LOOP_UNDER 
1e1f e5				push hl 
1e20 d5				push de 
1e21 2a ea e9			ld hl,(cli_loop_sp) 
1e24 11 24 e9			ld de, cli_loop_stack 
1e27 cd 13 0e			call cmp16 
1e2a da 44 61			jp c, fault_loop_under 
1e2d d1				pop de 
1e2e e1				pop hl 
1e2f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e2f				endif 
1e2f e5				push hl 
1e30 2a ea e9			ld hl,(cli_loop_sp) 
1e33 2b				dec hl 
1e34 2b				dec hl 
1e35 22 ea e9			ld (cli_loop_sp), hl 
1e38				; TODO do stack underflow checks 
1e38 e1				pop hl 
1e39				if DEBUG_FORTH_STACK_GUARD 
1e39 cd 27 60				call check_stacks 
1e3c					FORTH_CHK_LOOP_UNDER 
1e3c e5				push hl 
1e3d d5				push de 
1e3e 2a ea e9			ld hl,(cli_loop_sp) 
1e41 11 24 e9			ld de, cli_loop_stack 
1e44 cd 13 0e			call cmp16 
1e47 da 44 61			jp c, fault_loop_under 
1e4a d1				pop de 
1e4b e1				pop hl 
1e4c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e4c				endif 
1e4c c9				ret 
1e4d			 
1e4d			macro_forth_dsp_pop: 
1e4d			 
1e4d e5				push hl 
1e4e			 
1e4e				; release malloc data 
1e4e			 
1e4e				if DEBUG_FORTH_STACK_GUARD 
1e4e cd 27 60				call check_stacks 
1e51					FORTH_CHK_DSP_UNDER 
1e51 e5				push hl 
1e52 d5				push de 
1e53 2a e8 e9			ld hl,(cli_data_sp) 
1e56 11 22 e8			ld de, cli_data_stack 
1e59 cd 13 0e			call cmp16 
1e5c da 38 61			jp c, fault_dsp_under 
1e5f d1				pop de 
1e60 e1				pop hl 
1e61				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e61				endif 
1e61				;ld hl,(cli_data_sp) 
1e61			if DEBUG_FORTH_DOT 
1e61				DMARK "DPP" 
1e61 f5				push af  
1e62 3a 76 1e			ld a, (.dmark)  
1e65 32 65 ee			ld (debug_mark),a  
1e68 3a 77 1e			ld a, (.dmark+1)  
1e6b 32 66 ee			ld (debug_mark+1),a  
1e6e 3a 78 1e			ld a, (.dmark+2)  
1e71 32 67 ee			ld (debug_mark+2),a  
1e74 18 03			jr .pastdmark  
1e76 ..			.dmark: db "DPP"  
1e79 f1			.pastdmark: pop af  
1e7a			endm  
# End of macro DMARK
1e7a				CALLMONITOR 
1e7a cd 6f ee			call debug_vector  
1e7d				endm  
# End of macro CALLMONITOR
1e7d			endif	 
1e7d			 
1e7d			 
1e7d			if FORTH_ENABLE_DSPPOPFREE 
1e7d			 
1e7d				FORTH_DSP 
1e7d cd 5b 1d			call macro_forth_dsp 
1e80				endm 
# End of macro FORTH_DSP
1e80			 
1e80 7e				ld a, (hl) 
1e81 fe 01			cp DS_TYPE_STR 
1e83 20 22			jr nz, .skippopfree 
1e85			 
1e85				FORTH_DSP_VALUEHL 
1e85 cd 95 1d			call macro_dsp_valuehl 
1e88				endm 
# End of macro FORTH_DSP_VALUEHL
1e88			;	nop 
1e88			if DEBUG_FORTH_DOT 
1e88				DMARK "DPf" 
1e88 f5				push af  
1e89 3a 9d 1e			ld a, (.dmark)  
1e8c 32 65 ee			ld (debug_mark),a  
1e8f 3a 9e 1e			ld a, (.dmark+1)  
1e92 32 66 ee			ld (debug_mark+1),a  
1e95 3a 9f 1e			ld a, (.dmark+2)  
1e98 32 67 ee			ld (debug_mark+2),a  
1e9b 18 03			jr .pastdmark  
1e9d ..			.dmark: db "DPf"  
1ea0 f1			.pastdmark: pop af  
1ea1			endm  
# End of macro DMARK
1ea1				CALLMONITOR 
1ea1 cd 6f ee			call debug_vector  
1ea4				endm  
# End of macro CALLMONITOR
1ea4			endif	 
1ea4 cd 9a 12			call free 
1ea7			.skippopfree: 
1ea7				 
1ea7			 
1ea7			endif 
1ea7			 
1ea7			if DEBUG_FORTH_DOT_KEY 
1ea7				DMARK "DP2" 
1ea7				CALLMONITOR 
1ea7			endif	 
1ea7			 
1ea7				; move pointer down 
1ea7			 
1ea7 2a e8 e9			ld hl,(cli_data_sp) 
1eaa 2b				dec hl 
1eab 2b				dec hl 
1eac			; PARSEV5 
1eac 2b				dec hl 
1ead 22 e8 e9			ld (cli_data_sp), hl 
1eb0			 
1eb0				if DEBUG_FORTH_STACK_GUARD 
1eb0 cd 27 60				call check_stacks 
1eb3					FORTH_CHK_DSP_UNDER 
1eb3 e5				push hl 
1eb4 d5				push de 
1eb5 2a e8 e9			ld hl,(cli_data_sp) 
1eb8 11 22 e8			ld de, cli_data_stack 
1ebb cd 13 0e			call cmp16 
1ebe da 38 61			jp c, fault_dsp_under 
1ec1 d1				pop de 
1ec2 e1				pop hl 
1ec3				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ec3				endif 
1ec3			 
1ec3 e1				pop hl 
1ec4			 
1ec4 c9				ret 
1ec5			 
1ec5			getwordathl: 
1ec5				; hl points to an address 
1ec5				; load hl with the word at that address 
1ec5			 
1ec5 d5				push de 
1ec6			 
1ec6 5e				ld e, (hl) 
1ec7 23				inc hl 
1ec8 56				ld d, (hl) 
1ec9 eb				ex de, hl 
1eca			 
1eca d1				pop de 
1ecb c9				ret 
1ecc			 
1ecc			 
1ecc			; functions to manuplite stack pointers 
1ecc			 
1ecc			; generate fragment to set hl to be pointer to a stack item 
1ecc			 
1ecc			FORTH_DSP_PTR: macro  x 
1ecc				ld hl,(cli_data_sp) 
1ecc				ld de, x * 3 
1ecc				sbc hl, de 
1ecc				endm 
1ecc			 
1ecc			 
1ecc			 
1ecc			; copy point in hl to stack tmp storage slots 1-4 
1ecc			hltostack1: 
1ecc 11 b8 e2			ld de, os_stack_1  
1ecf c3 fa 1e			jp hltostackmv 
1ed2			 
1ed2			hltostack2:  
1ed2 11 b5 e2			ld de, os_stack_2 
1ed5 c3 fa 1e			jp hltostackmv 
1ed8			 
1ed8			hltostack3:  
1ed8 11 b2 e2			ld de, os_stack_3 
1edb c3 fa 1e			jp hltostackmv 
1ede			 
1ede			hltostack4:  
1ede 11 af e2			ld de, os_stack_4  
1ee1 c3 fa 1e			jp hltostackmv 
1ee4			 
1ee4			; copy to point in hl from stack tmp storage slots 1-4 
1ee4			hlfromstack1: 
1ee4 11 b8 e2			ld de, os_stack_1 
1ee7 c3 f9 1e			jp hlfromsttackmv 
1eea			 
1eea			hlfromstack2:  
1eea 11 b5 e2			ld de, os_stack_2 
1eed c3 f9 1e			jp hlfromsttackmv 
1ef0			 
1ef0			hlfromstack3:  
1ef0 11 b2 e2			ld de, os_stack_3 
1ef3 c3 f9 1e			jp hlfromsttackmv 
1ef6			 
1ef6			hlfromstack4:  
1ef6 11 af e2			ld de, os_stack_4 
1ef9			 
1ef9			hlfromsttackmv: 
1ef9 eb				ex de, hl 
1efa			 
1efa			hltostackmv: 
1efa			 
1efa				; do stack move 
1efa c5				push bc 
1efb 01 03 00			ld bc, 3 
1efe ed b0			ldir  
1f00 c1				pop bc	 
1f01 c9				ret 
1f02			 
1f02			; eof 
1f02			 
# End of file forth_stackopsv5.asm
1f02			endif 
1f02			loadwordinhl:	 
1f02			 
1f02 d5				push de 
1f03			 
1f03 5e				ld e, (hl) 
1f04 23				inc hl 
1f05 56				ld d, (hl) 
1f06 eb				ex de,hl  
1f07			 
1f07 d1				pop de 
1f08			 
1f08 c9				ret 
1f09			 
1f09			user_word_eol:  
1f09				; hl contains the pointer to where to create a linked list item from the end 
1f09				; of the user dict to continue on at the system word dict 
1f09				 
1f09				; poke the stub of the word list linked list to repoint to rom words 
1f09			 
1f09				; stub format 
1f09				; db   word id 
1f09				; dw    link to next word 
1f09			        ; db char length of token 
1f09				; db string + 0 term 
1f09				; db exec code....  
1f09			 
1f09 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f0b 77				ld (hl), a		; word id 
1f0c 23				inc hl 
1f0d			 
1f0d 11 c4 20			ld de, sysdict 
1f10 73				ld (hl), e		; next word link ie system dict 
1f11 23				inc hl 
1f12 72				ld (hl), d		; next word link ie system dict 
1f13 23				inc hl	 
1f14			 
1f14			;	ld (hl), sysdict		; next word link ie system dict 
1f14			;	inc hl 
1f14			;	inc hl 
1f14			 
1f14			;	inc hl 
1f14			;	inc hl 
1f14			 
1f14 3e 02			ld a, 2			; word length is 0 
1f16 77				ld (hl), a	 
1f17 23				inc hl 
1f18			 
1f18 3e 7e			ld a, '~'			; word length is 0 
1f1a 77				ld (hl), a	 
1f1b 23				inc hl 
1f1c 3e 00			ld a, 0			; save empty word 
1f1e 77				ld (hl), a 
1f1f			 
1f1f c9				ret 
1f20			 
1f20				 
1f20			 
1f20			forthexec_cleanup: 
1f20				FORTH_RSP_POP 
1f20 cd 58 1b			call macro_forth_rsp_pop 
1f23				endm 
# End of macro FORTH_RSP_POP
1f23 c9				ret 
1f24			 
1f24			forth_call_hl: 
1f24				; taking hl 
1f24 e5				push hl 
1f25 c9				ret 
1f26			 
1f26			; this is called to reset Forth system but keep existing uwords etc 
1f26			 
1f26			forth_warmstart: 
1f26				; setup stack over/under flow checks 
1f26				if DEBUG_FORTH_STACK_GUARD 
1f26 cd 0d 60				call chk_stk_init 
1f29				endif 
1f29			 
1f29				; init stack pointers  - * these stacks go upwards *  
1f29 21 a6 e9			ld hl, cli_ret_stack 
1f2c 22 ec e9			ld (cli_ret_sp), hl	 
1f2f				; set bottom of stack 
1f2f 3e 00			ld a,0 
1f31 77				ld (hl),a 
1f32 23				inc hl 
1f33 77				ld (hl),a 
1f34			 
1f34 21 22 e8			ld hl, cli_data_stack 
1f37 22 e8 e9			ld (cli_data_sp), hl	 
1f3a				; set bottom of stack 
1f3a 3e 00			ld a,0 
1f3c 77				ld (hl),a 
1f3d 23				inc hl 
1f3e 77				ld (hl),a 
1f3f			 
1f3f 21 24 e9			ld hl, cli_loop_stack 
1f42 22 ea e9			ld (cli_loop_sp), hl	 
1f45				; set bottom of stack 
1f45 3e 00			ld a,0 
1f47 77				ld (hl),a 
1f48 23				inc hl 
1f49 77				ld (hl),a 
1f4a			 
1f4a				; init extent of current open file 
1f4a			 
1f4a 3e 00			ld a, 0 
1f4c 32 64 ea			ld (store_openext), a 
1f4f			 
1f4f c9				ret 
1f50			 
1f50			 
1f50			 
1f50			; Cold Start - this is called to setup the whole Forth system 
1f50			 
1f50			forth_init: 
1f50			 
1f50				; setup stack over/under flow checks 
1f50			 
1f50			;	if DEBUG_FORTH_STACK_GUARD 
1f50			;		call chk_stk_init 
1f50			;	endif 
1f50			 
1f50				; enable auto display updates (slow.....) 
1f50			 
1f50 3e 01			ld a, 1 
1f52 32 36 ea			ld (cli_autodisplay), a 
1f55			 
1f55				; if storage is in use disable long reads for now 
1f55 3e 00			ld a, 0 
1f57 32 6f ea			ld (store_longread), a 
1f5a			 
1f5a			 
1f5a				; show start up screen 
1f5a			 
1f5a cd c8 0b			call clear_display 
1f5d			 
1f5d 3e 00			ld a,0 
1f5f 32 58 ea			ld (f_cursor_ptr), a 
1f62			 
1f62				; set start of word list in start of ram - for use when creating user words 
1f62			 
1f62 21 22 64			ld hl, baseram 
1f65 22 b8 e5			ld (os_last_new_uword), hl 
1f68 cd 09 1f			call user_word_eol 
1f6b				 
1f6b			;		call display_data_sp 
1f6b			;		call next_page_prompt 
1f6b			 
1f6b			 
1f6b			 
1f6b			 
1f6b c9				ret 
1f6c			 
1f6c .. 00		.bootforth: db " Forth Kernel Init ",0 
1f80			 
1f80			; TODO push to stack 
1f80			 
1f80			;  
1f80			 
1f80			if FORTH_PARSEV2 
1f80			 
1f80			 
1f80				include "forth_parserv2.asm" 
1f80			 
1f80			endif 
1f80			 
1f80			 
1f80			; parse cli version 1 
1f80			 
1f80			if FORTH_PARSEV1 
1f80			 
1f80			 
1f80			 
1f80			      include "forth_parserv1.asm" 
1f80			endif 
1f80				 
1f80			if FORTH_PARSEV3 
1f80			      include "forth_parserv3.asm" 
1f80				include "forth_wordsv3.asm" 
1f80			endif 
1f80			 
1f80			if FORTH_PARSEV4 
1f80			      include "forth_parserv4.asm" 
1f80				include "forth_wordsv4.asm" 
1f80			endif 
1f80			 
1f80			if FORTH_PARSEV5 
1f80			      include "forth_parserv5.asm" 
1f80				include "forth_wordsv4.asm" 
1f80			endif 
1f80			 
1f80			if FORTH_PARSEV6 
1f80			      include "forth_parserv6.asm" 
1f80			 
1f80			 
1f80			; A better parser without using malloc and string copies all over the place.  
1f80			; Exec in situ should be faster 
1f80			 
1f80			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f80			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f80			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f80			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f80			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f80			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f80			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f80			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f80			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f80			 
1f80			; Core word preamble macro 
1f80			 
1f80			CWHEAD:   macro nxtword opcode lit len opflags 
1f80				db WORD_SYS_CORE+opcode             
1f80				; internal op code number 
1f80				dw nxtword            
1f80				; link to next dict word block 
1f80				db len + 1 
1f80				; literal length of dict word inc zero term 
1f80				db lit,0              
1f80				; literal dict word 
1f80			        ; TODO db opflags        
1f80				endm 
1f80			 
1f80			 
1f80			NEXTW: macro  
1f80				jp macro_next 
1f80				endm 
1f80			 
1f80			macro_next: 
1f80			if DEBUG_FORTH_PARSE_EXEC 
1f80				DMARK "NXT" 
1f80				CALLMONITOR 
1f80			endif	 
1f80			;	inc hl  ; skip token null term  
1f80 ed 4b 3a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f84 ed 5b 38 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f88 2a bc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f8b			if DEBUG_FORTH_PARSE_EXEC 
1f8b				DMARK "}AA" 
1f8b				CALLMONITOR 
1f8b			endif	 
1f8b c3 7a 20			jp execnext 
1f8e				;jp exec1 
1f8e			       
1f8e			 
1f8e			 
1f8e			; Another go at the parser to compile  
1f8e			 
1f8e			 
1f8e			; TODO rework parser to change all of the string words to byte tokens 
1f8e			; TODO do a search for  
1f8e			 
1f8e			; TODO first run normal parser to zero term sections 
1f8e			; TODO for each word do a token look up to get the op code 
1f8e			; TODO need some means to flag to the exec that this is a byte code form    
1f8e			 
1f8e			 
1f8e			forthcompile: 
1f8e			 
1f8e			; 
1f8e			; line parse: 
1f8e			;       parse raw input buffer 
1f8e			;       tokenise the words 
1f8e			;       malloc new copy (for looping etc) 
1f8e			;       copy to malloc + current pc in line to start of string and add line term 
1f8e			;       save on new rsp 
1f8e			; 
1f8e			 
1f8e			; hl to point to the line to tokenise 
1f8e			 
1f8e			;	push hl 
1f8e 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f91			 
1f91			;	ld a,0		; string term on input 
1f91			;	call strlent 
1f91			 
1f91			;	ld (os_tok_len), hl	 ; save string length 
1f91			 
1f91			;if DEBUG_FORTH_TOK 
1f91			;	ex de,hl		 
1f91			;endif 
1f91			 
1f91			;	pop hl 		; get back string pointer 
1f91			 
1f91			if DEBUG_FORTH_TOK 
1f91						DMARK "TOc" 
1f91				CALLMONITOR 
1f91			endif 
1f91 7e			.cptoken2:    ld a,(hl) 
1f92 23				inc hl 
1f93 fe 7f			cp FORTH_END_BUFFER 
1f95 28 29			jr z, .cptokendone2 
1f97 fe 00			cp 0 
1f99 28 25			jr z, .cptokendone2 
1f9b fe 22			cp '"' 
1f9d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f9f fe 20			cp ' ' 
1fa1 20 ee			jr nz,  .cptoken2 
1fa3			 
1fa3			; TODO consume comments held between ( and ) 
1fa3			 
1fa3				; we have a space so change to zero term for dict match later 
1fa3 2b				dec hl 
1fa4 3e 00			ld a,0 
1fa6 77				ld (hl), a 
1fa7 23				inc hl 
1fa8 18 e7			jr .cptoken2 
1faa				 
1faa			 
1faa			.cptokenstr2: 
1faa				; skip all white space until either eol (because forgot to term) or end double quote 
1faa			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1faa				;inc hl ; skip current double quote 
1faa 7e				ld a,(hl) 
1fab 23				inc hl 
1fac fe 22			cp '"' 
1fae 28 e1			jr z, .cptoken2 
1fb0 fe 7f			cp FORTH_END_BUFFER 
1fb2 28 0c			jr z, .cptokendone2 
1fb4 fe 00			cp 0 
1fb6 28 08			jr z, .cptokendone2 
1fb8 fe 20			cp ' ' 
1fba 28 02			jr z, .cptmp2 
1fbc 18 ec			jr .cptokenstr2 
1fbe			 
1fbe			.cptmp2:	; we have a space so change to zero term for dict match later 
1fbe				;dec hl 
1fbe				;ld a,"-"	; TODO remove this when working 
1fbe				;ld (hl), a 
1fbe				;inc hl 
1fbe 18 ea			jr .cptokenstr2 
1fc0			 
1fc0			.cptokendone2: 
1fc0				;inc hl 
1fc0 3e 7f			ld a, FORTH_END_BUFFER 
1fc2 77				ld (hl),a 
1fc3			;	inc hl 
1fc3			;	ld a, '!' 
1fc3			;	ld (hl),a 
1fc3			 
1fc3 2a bc e5			ld hl,(os_tok_ptr) 
1fc6			         
1fc6			if DEBUG_FORTH_TOK 
1fc6						DMARK "Tc1" 
1fc6				CALLMONITOR 
1fc6			endif 
1fc6			 
1fc6				; push exec string to top of return stack 
1fc6				FORTH_RSP_NEXT 
1fc6 cd 37 1b			call macro_forth_rsp_next 
1fc9				endm 
# End of macro FORTH_RSP_NEXT
1fc9 c9				ret 
1fca			 
1fca			; Another go at the parser need to simplify the process 
1fca			 
1fca			forthparse: 
1fca			 
1fca			; 
1fca			; line parse: 
1fca			;       parse raw input buffer 
1fca			;       tokenise the words 
1fca			;       malloc new copy (for looping etc) 
1fca			;       copy to malloc + current pc in line to start of string and add line term 
1fca			;       save on new rsp 
1fca			; 
1fca			 
1fca			; hl to point to the line to tokenise 
1fca			 
1fca			;	push hl 
1fca 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1fcd			 
1fcd			;	ld a,0		; string term on input 
1fcd			;	call strlent 
1fcd			 
1fcd			;	ld (os_tok_len), hl	 ; save string length 
1fcd			 
1fcd			;if DEBUG_FORTH_TOK 
1fcd			;	ex de,hl		 
1fcd			;endif 
1fcd			 
1fcd			;	pop hl 		; get back string pointer 
1fcd			 
1fcd			if DEBUG_FORTH_TOK 
1fcd						DMARK "TOK" 
1fcd				CALLMONITOR 
1fcd			endif 
1fcd 7e			.ptoken2:    ld a,(hl) 
1fce 23				inc hl 
1fcf fe 7f			cp FORTH_END_BUFFER 
1fd1 28 29			jr z, .ptokendone2 
1fd3 fe 00			cp 0 
1fd5 28 25			jr z, .ptokendone2 
1fd7 fe 22			cp '"' 
1fd9 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fdb fe 20			cp ' ' 
1fdd 20 ee			jr nz,  .ptoken2 
1fdf			 
1fdf			; TODO consume comments held between ( and ) 
1fdf			 
1fdf				; we have a space so change to zero term for dict match later 
1fdf 2b				dec hl 
1fe0 3e 00			ld a,0 
1fe2 77				ld (hl), a 
1fe3 23				inc hl 
1fe4 18 e7			jr .ptoken2 
1fe6				 
1fe6			 
1fe6			.ptokenstr2: 
1fe6				; skip all white space until either eol (because forgot to term) or end double quote 
1fe6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fe6				;inc hl ; skip current double quote 
1fe6 7e				ld a,(hl) 
1fe7 23				inc hl 
1fe8 fe 22			cp '"' 
1fea 28 e1			jr z, .ptoken2 
1fec fe 7f			cp FORTH_END_BUFFER 
1fee 28 0c			jr z, .ptokendone2 
1ff0 fe 00			cp 0 
1ff2 28 08			jr z, .ptokendone2 
1ff4 fe 20			cp ' ' 
1ff6 28 02			jr z, .ptmp2 
1ff8 18 ec			jr .ptokenstr2 
1ffa			 
1ffa			.ptmp2:	; we have a space so change to zero term for dict match later 
1ffa				;dec hl 
1ffa				;ld a,"-"	; TODO remove this when working 
1ffa				;ld (hl), a 
1ffa				;inc hl 
1ffa 18 ea			jr .ptokenstr2 
1ffc			 
1ffc			.ptokendone2: 
1ffc				;inc hl 
1ffc 3e 7f			ld a, FORTH_END_BUFFER 
1ffe 77				ld (hl),a 
1fff			;	inc hl 
1fff			;	ld a, '!' 
1fff			;	ld (hl),a 
1fff			 
1fff 2a bc e5			ld hl,(os_tok_ptr) 
2002			         
2002			if DEBUG_FORTH_TOK 
2002						DMARK "TK1" 
2002				CALLMONITOR 
2002			endif 
2002			 
2002				; push exec string to top of return stack 
2002				FORTH_RSP_NEXT 
2002 cd 37 1b			call macro_forth_rsp_next 
2005				endm 
# End of macro FORTH_RSP_NEXT
2005 c9				ret 
2006			 
2006			; 
2006			;	; malloc size + buffer pointer + if is loop flag 
2006			;	ld hl,(os_tok_len) 		 ; get string length 
2006			; 
2006			;	ld a,l 
2006			; 
2006			;	cp 0			; we dont want to use a null string 
2006			;	ret z 
2006			; 
2006			;;	add 3    ; prefix malloc with buffer for current word ptr 
2006			; 
2006			;	add 5     ; TODO when certain not over writing memory remove 
2006			; 
2006			;		 
2006			; 
2006			;if DEBUG_FORTH_TOK 
2006			;			DMARK "TKE" 
2006			;	CALLMONITOR 
2006			;endif 
2006			; 
2006			;	ld l,a 
2006			;	ld h,0 
2006			;;	push hl   ; save required space for the copy later 
2006			;	call malloc 
2006			;if DEBUG_FORTH_TOK 
2006			;			DMARK "TKM" 
2006			;	CALLMONITOR 
2006			;endif 
2006			;	if DEBUG_FORTH_MALLOC_GUARD 
2006			;		push af 
2006			;		call ishlzero 
2006			;;		ld a, l 
2006			;;		add h 
2006			;;		cp 0 
2006			;		pop af 
2006			;		 
2006			;		call z,malloc_error 
2006			;	endif 
2006			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2006			; 
2006			; 
2006			;if DEBUG_FORTH_TOK 
2006			;			DMARK "TKR" 
2006			;	CALLMONITOR 
2006			;endif 
2006			; 
2006			;	FORTH_RSP_NEXT 
2006			; 
2006			;	;inc hl	 ; go past current buffer pointer 
2006			;	;inc hl 
2006			;	;inc hl   ; and past if loop flag 
2006			;		; TODO Need to set flag  
2006			; 
2006			;	 
2006			;	 
2006			;	ex de,hl	; malloc is dest 
2006			;	ld hl, (os_tok_len) 
2006			;;	pop bc 
2006			;	ld c, l                
2006			;	ld b,0 
2006			;	ld hl, (os_tok_ptr) 
2006			; 
2006			;if DEBUG_FORTH_TOK 
2006			;			DMARK "TKT" 
2006			;	CALLMONITOR 
2006			;endif 
2006			; 
2006			;	; do str cpy 
2006			; 
2006			;	ldir      ; copy byte in hl to de 
2006			; 
2006			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2006			; 
2006			;if DEBUG_FORTH_TOK 
2006			; 
2006			;			DMARK "TKY" 
2006			;	CALLMONITOR 
2006			;endif 
2006			;	;ld a,0 
2006			;	;ld a,FORTH_END_BUFFER 
2006			;	ex de, hl 
2006			;	;dec hl			 ; go back over the space delim at the end of word 
2006			;	;ld (hl),a 
2006			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2006			;	ld a,FORTH_END_BUFFER 
2006			;	ld (hl),a 
2006			;	inc hl 
2006			;	ld a,FORTH_END_BUFFER 
2006			;	ld (hl),a 
2006			; 
2006			;	; init the malloc area data 
2006			;	; set pc for in current area 
2006			;	;ld hl, (os_tok_malloc) 
2006			;	;inc hl 
2006			;	;inc hl 
2006			;	;inc hl 
2006			;	;ex de,hl 
2006			;	;ld hl, (os_tok_malloc) 
2006			;	;ld (hl),e 
2006			;	;inc hl 
2006			;	;ld (hl),d 
2006			; 
2006			; 
2006			;	ld hl,(os_tok_malloc) 
2006			;if DEBUG_FORTH_PARSE_KEY 
2006			;			DMARK "TKU" 
2006			;	CALLMONITOR 
2006			;endif 
2006			; 
2006			;	ret 
2006			 
2006			forthexec: 
2006			 
2006			; line exec: 
2006			; forth parser 
2006			 
2006			; 
2006			;       get current exec line on rsp 
2006			 
2006				FORTH_RSP_TOS 
2006 cd 4e 1b			call macro_forth_rsp_tos 
2009				endm 
# End of macro FORTH_RSP_TOS
2009			 
2009			;       restore current pc - hl points to malloc of data 
2009			 
2009				;ld e, (hl) 
2009				;inc hl 
2009				;ld d, (hl) 
2009				;ex de,hl 
2009			 
2009			 
2009			exec1: 
2009 22 bc e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
200c			 
200c				; copy our PC to working vars  
200c 22 3a ea			ld (cli_ptr), hl                    ; here 
200f 22 38 ea			ld (cli_origptr), hl                ; here 
2012			 
2012 7e				ld a,(hl)                           ; here make hl be the ram ptr 
2013 fe 7f			cp FORTH_END_BUFFER 
2015 c8				ret z 
2016			 
2016				; skip any nulls 
2016			 
2016 fe 00			cp 0 
2018 20 03			jr nz, .execword 
201a 23				inc hl 
201b 18 ec			jr exec1 
201d			 
201d			 
201d			.execword: 
201d			 
201d			 
201d			 
201d			if DEBUG_FORTH_PARSE_EXEC 
201d						DMARK "KYQ" 
201d				CALLMONITOR 
201d			endif 
201d			;       while at start of word: 
201d			; get start of dict (in user area first) 
201d			 
201d 21 22 64		ld hl, baseram 
2020			;ld hl, sysdict 
2020 22 3c ea		ld (cli_nextword),hl                            ; here do we need to do this? 
2023			;           match word at pc 
2023			;           exec word 
2023			;           or push to dsp 
2023			;           forward to next token 
2023			;           if line term pop rsp and exit 
2023			;        
2023			 
2023			if DEBUG_FORTH_PARSE_EXEC 
2023						DMARK "KYq" 
2023				CALLMONITOR 
2023			endif 
2023			 
2023			; 
2023			; word comp 
2023			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2023			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2023			;    move to start of word  
2023			;    compare word to cli_token 
2023			 
2023			.execpnword:	; HL at start of a word in the dictionary to check 
2023			 
2023 2a 3c ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
2026			 
2026 cd bd 20			call forth_tok_next 
2029			; tok next end here 
2029 22 3c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
202c eb				ex de, hl 
202d			 
202d			 
202d				; save the pointer of the current token - 1 to check against 
202d				 
202d 22 40 ea			ld (cli_token), hl   
2030				; TODO maybe remove below save if no debug 
2030				; save token string ptr for any debug later 
2030 23				inc hl  
2031 22 42 ea			ld (cli_origtoken), hl 
2034 2b				dec hl 
2035				; save pointer to the start of the next dictionay word 
2035 7e				ld a,(hl)   ; get string length 
2036 47				ld b,a 
2037			.execpnwordinc:  
2037 23				inc hl 
2038 10 fd			djnz .execpnwordinc 
203a 22 3e ea			ld (cli_execword), hl      ; save start of this words code 
203d			 
203d				; now check the word token against the string being parsed 
203d			 
203d 2a 40 ea			ld hl,(cli_token) 
2040 23				inc hl     ; skip string length (use zero term instead to end) 
2041				;ld (cli_token), hl 
2041			 
2041			.execpnchar:    ; compare char between token and string to parse 
2041			 
2041			 
2041				;ld hl, (cli_token)     ; the dict word  
2041 ed 5b 3a ea		ld de, (cli_ptr)     ; cli to parse 
2045			 
2045			 
2045			.execpncharl:    ; compare char between token and string to parse (loop) 
2045			 
2045 1a				ld a,(de) 
2046 cd 52 11			call toUpper 		; make sure the input string matches case 
2049 be				cp (hl) 
204a			 
204a c2 63 20			jp nz, .execpnskipword	 ; no match so move to next word 
204d				 
204d			;    if same 
204d			;       scan for string terms 0 for token and 32 for input 
204d 46				ld b,(hl) 
204e 80				add b			 
204f 23				inc hl 
2050 13				inc de 
2051 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2053							; TODO need to make sure last word in zero term string is accounted for 
2053 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
2055			 
2055			 
2055				; at end of both strings so both are exact match 
2055			 
2055			;       skip ptr for next word 
2055			 
2055 2a 3a ea			ld hl,(cli_ptr) 	; at input string term 
2058 23				inc hl			 ; at next char 
2059 22 3a ea			ld (cli_ptr), hl     ; save for next round of the parser 
205c 22 38 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
205f				 
205f				 
205f			 
205f			 
205f			 
205f			;       exec code block 
205f			if DEBUG_FORTH_JP 
205f				call clear_display 
205f				call update_display 
205f				call delay1s 
205f				ld hl, (cli_execword)     ; save for next check if no match on this word 
205f				ld a,h 
205f				ld hl, os_word_scratch 
205f				call hexout 
205f				ld hl, (cli_execword)     ; save for next check if no match on this word 
205f				ld a,l 
205f				ld hl, os_word_scratch+2 
205f				call hexout 
205f				ld hl, os_word_scratch+4 
205f				ld a,0 
205f				ld (hl),a 
205f				ld de,os_word_scratch 
205f				call str_at_display 
205f					ld a, display_row_2 
205f					call str_at_display 
205f				ld de, (cli_origtoken) 
205f				ld a, display_row_1+10 
205f					call str_at_display 
205f			 
205f				ld a,display_row_1 
205f				ld de, .foundword 
205f				ld a, display_row_3 
205f				call str_at_display 
205f				call update_display 
205f				call delay1s 
205f				call delay1s 
205f				call delay1s 
205f			endif 
205f			 
205f			if DEBUG_FORTH_PARSE_EXEC 
205f						DMARK "KYj" 
205f			endif 
205f				; TODO save the word pointer in this exec 
205f			 
205f 2a 3e ea			ld hl,(cli_execword) 
2062 e9				jp (hl) 
2063			 
2063			 
2063			;    if not same 
2063			;	scan for zero term 
2063			;	get ptr for next word 
2063			;	goto word comp 
2063			 
2063			.execpnskipword:	; get pointer to next word 
2063 2a 3c ea			ld hl,(cli_nextword) 
2066			 
2066 7e				ld a,(hl) 
2067 fe 00			cp WORD_SYS_END 
2069			;	cp 0 
2069 28 09			jr z, .execendofdict			 ; at end of words 
206b			 
206b			if DEBUG_FORTH_PARSE_EXEC 
206b						DMARK "KY4" 
206b			endif 
206b			if DEBUG_FORTH_PARSE_EXEC 
206b			 
206b				; see if disabled 
206b			 
206b			;	ld a, (os_view_disable) 
206b			;	cp '*' 
206b				ld a,(debug_vector) 
206b				cp $c9   ; RET 
206b				jr z, .noskip 
206b			 
206b			 
206b				ld de, .nowordfound 
206b				ld a, display_row_3 
206b				call str_at_display 
206b				call update_display 
206b				ld a, 100 
206b				call aDelayInMS 
206b				 
206b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
206b					call delay250ms 
206b				endif 
206b			.noskip:  
206b			 
206b			endif	 
206b			 
206b 2a 38 ea			ld hl,(cli_origptr) 
206e 22 3a ea			ld (cli_ptr),hl 
2071			 
2071			if DEBUG_FORTH_PARSE_EXEC 
2071						DMARK "KY5" 
2071			endif 
2071 c3 23 20			jp .execpnword			; else go to next word 
2074			 
2074			.execendofdict:  
2074			 
2074			if DEBUG_FORTH_PARSE_EXEC 
2074						DMARK "KYe" 
2074			endif 
2074			if DEBUG_FORTH_PARSE_EXEC 
2074				; see if disabled 
2074			 
2074			;	ld a, (os_view_disable) 
2074			;	cp '*' 
2074				ld a,(debug_vector) 
2074				cp $c9   ; ret 
2074				jr z, .ispskip 
2074			 
2074				call clear_display 
2074				call update_display 
2074				call delay1s 
2074				ld de, (cli_origptr) 
2074				ld a, display_row_1 
2074				call str_at_display 
2074				 
2074				ld de, .enddict 
2074				ld a, display_row_3 
2074				call str_at_display 
2074				call update_display 
2074				ld a, 100 
2074				call aDelayInMS 
2074				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2074				call delay1s 
2074				call delay1s 
2074				call delay1s 
2074				endif 
2074			.ispskip:  
2074				 
2074			endif	 
2074			 
2074			 
2074			 
2074				; if the word is not a keyword then must be a literal so push it to stack 
2074			 
2074			; push token to stack to end of word 
2074			 
2074				STACKFRAME ON $1efe $2f9f 
2074				if DEBUG_STACK_IMB 
2074					if ON 
2074						exx 
2074						ld de, $1efe 
2074						ld a, d 
2074						ld hl, curframe 
2074						call hexout 
2074						ld a, e 
2074						ld hl, curframe+2 
2074						call hexout 
2074						ld hl, $1efe 
2074						push hl 
2074						ld hl, $2f9f 
2074						push hl 
2074						exx 
2074					endif 
2074				endif 
2074			endm 
# End of macro STACKFRAME
2074			 
2074 2a bc e5		ld hl,(os_tok_ptr) 
2077 cd f9 1c		call forth_apush 
207a			 
207a				STACKFRAMECHK ON $1efe $2f9f 
207a				if DEBUG_STACK_IMB 
207a					if ON 
207a						exx 
207a						ld hl, $2f9f 
207a						pop de   ; $2f9f 
207a						call cmp16 
207a						jr nz, .spnosame 
207a						ld hl, $1efe 
207a						pop de   ; $1efe 
207a						call cmp16 
207a						jr z, .spfrsame 
207a						.spnosame: call showsperror 
207a						.spfrsame: nop 
207a						exx 
207a					endif 
207a				endif 
207a			endm 
# End of macro STACKFRAMECHK
207a			 
207a			execnext: 
207a			 
207a			if DEBUG_FORTH_PARSE_EXEC 
207a						DMARK "KY>" 
207a			endif 
207a			; move past token to next word 
207a			 
207a 2a bc e5		ld hl, (os_tok_ptr) 
207d 3e 00		ld a, 0 
207f 01 ff 00		ld bc, 255     ; input buffer size 
2082 ed b1		cpir 
2084			 
2084			if DEBUG_FORTH_PARSE_EXEC 
2084						DMARK "KY!" 
2084				CALLMONITOR 
2084			endif	 
2084			; TODO this might place hl on the null, so will need to forward on??? 
2084			;inc hl   ; see if this gets onto the next item 
2084			 
2084			 
2084			; TODO pass a pointer to the buffer to push 
2084			; TODO call function to push 
2084			 
2084			; look for end of input 
2084			 
2084			;inc hl 
2084			;ld a,(hl) 
2084			;cp FORTH_END_BUFFER 
2084			;ret z 
2084			 
2084			 
2084 c3 09 20		jp exec1 
2087			 
2087			 
2087			 
2087			 
2087			 
2087			 
2087			 
2087			 
2087			 
2087			findnexttok: 
2087			 
2087				; hl is pointer to move 
2087				; de is the token to locate 
2087			 
2087					if DEBUG_FORTH 
2087						DMARK "NTK" 
2087						CALLMONITOR 
2087					endif 
2087 d5				push de 
2088			 
2088			.fnt1:	 
2088				; find first char of token to locate 
2088			 
2088 1a				ld a, (de) 
2089 4f				ld c,a 
208a 7e				ld a,(hl) 
208b cd 52 11			call toUpper 
208e					if DEBUG_FORTH 
208e						DMARK "NT1" 
208e						CALLMONITOR 
208e					endif 
208e b9				cp c 
208f			 
208f 28 03			jr z, .fnt2cmpmorefirst	 
2091			 
2091				; first char not found move to next char 
2091			 
2091 23				inc hl 
2092 18 f4			jr .fnt1 
2094			 
2094			.fnt2cmpmorefirst:	 
2094				; first char of token found.  
2094			 
2094 e5				push hl     ; save start of token just in case it is the right one 
2095 d9				exx 
2096 e1				pop hl        ; save it to hl' 
2097 d9				exx 
2098			 
2098			 
2098			.fnt2cmpmore:	 
2098				; compare the rest 
2098				 
2098 23				inc hl 
2099 13				inc de 
209a				 
209a 1a				ld a, (de) 
209b 4f				ld c,a 
209c 7e				ld a,(hl) 
209d cd 52 11			call toUpper 
20a0			 
20a0					if DEBUG_FORTH 
20a0						DMARK "NT2" 
20a0						CALLMONITOR 
20a0					endif 
20a0				; c has the token to find char 
20a0				; a has the mem to scan char 
20a0			 
20a0 b9				cp c 
20a1 28 04			jr z,.fntmatch1 
20a3			 
20a3				; they are not the same 
20a3			 
20a3					if DEBUG_FORTH 
20a3						DMARK "NT3" 
20a3						CALLMONITOR 
20a3					endif 
20a3 d1				pop de	; reset de token to look for 
20a4 d5				push de 
20a5 18 e1			jr .fnt1 
20a7				 
20a7			.fntmatch1: 
20a7			 
20a7				; is the same char a null which means we might have a full hit? 
20a7					if DEBUG_FORTH 
20a7						DMARK "NT4" 
20a7						CALLMONITOR 
20a7					endif 
20a7			 
20a7 fe 00			cp 0 
20a9 28 0b			jr z, .fntmatchyes 
20ab			 
20ab				; are we at the end of the token to find? 
20ab			 
20ab					if DEBUG_FORTH 
20ab						DMARK "NT5" 
20ab						CALLMONITOR 
20ab					endif 
20ab 3e 00			ld a, 0 
20ad b9				cp c 
20ae			 
20ae c2 98 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20b1			 
20b1					if DEBUG_FORTH 
20b1						DMARK "NT6" 
20b1						CALLMONITOR 
20b1					endif 
20b1				; token to find is exhusted but no match to stream 
20b1			 
20b1				; restore tok pointer and continue on 
20b1 d1				pop de 
20b2 d5				push de 
20b3 c3 88 20			jp .fnt1 
20b6			 
20b6			 
20b6			.fntmatchyes: 
20b6			 
20b6				; hl now contains the end of the found token 
20b6			 
20b6				; get rid of saved token pointer to find 
20b6			 
20b6 d1				pop de 
20b7			 
20b7					if DEBUG_FORTH 
20b7						DMARK "NT9" 
20b7						CALLMONITOR 
20b7					endif 
20b7			 
20b7				; hl will be on the null term so forward on 
20b7			 
20b7				; get back the saved start of the token 
20b7			 
20b7 d9				exx 
20b8 e5				push hl     ; save start of token just in case it is the right one 
20b9 d9				exx 
20ba e1				pop hl        ; save it to hl 
20bb			 
20bb c9				ret 
20bc			 
20bc			 
20bc			; LIST needs to find a specific token   
20bc			; FORGET needs to find a spefici token 
20bc			 
20bc			; SAVE needs to find all tokens by flag 
20bc			; WORDS just needs to scan through all  by flag 
20bc			; UWORDS needs to scan through all by flag 
20bc			 
20bc			 
20bc			; given hl as pointer to start of dict look up string 
20bc			; return hl as pointer to start of word block 
20bc			; or 0 if not found 
20bc			 
20bc			forth_find_tok: 
20bc c9				ret 
20bd			 
20bd			; given hl as pointer to dict structure 
20bd			; move to the next dict block structure 
20bd			 
20bd			forth_tok_next: 
20bd				; hl now points to the address of the next word pointer  
20bd				; TODO skip compiled symbol for now 
20bd			;	push de 
20bd 23				inc hl 
20be 5e				ld e, (hl) 
20bf 23				inc hl 
20c0 56				ld d, (hl) 
20c1 23				inc hl 
20c2			 
20c2 eb				ex de,hl 
20c3			if DEBUG_FORTH_PARSE_NEXTWORD 
20c3				push bc 
20c3				ld bc, (cli_nextword) 
20c3						DMARK "NXW" 
20c3				CALLMONITOR 
20c3				pop bc 
20c3			endif 
20c3			;	pop de	 
20c3 c9				ret 
20c4			 
20c4			 
20c4			 
20c4			; eof 
# End of file forth_parserv6.asm
20c4				include "forth_wordsv4.asm" 
20c4			 
20c4			; the core word dictionary v4 
20c4			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20c4			 
20c4			; this is a linked list for each of the system words used 
20c4			; user defined words will follow the same format but will be in ram 
20c4			 
20c4			 
20c4			; 
20c4			; 
20c4			; define linked list: 
20c4			; 
20c4			; 1. compiled byte op code 
20c4			; 2. len of text word 
20c4			; 3. text word 
20c4			; 4. ptr to next dictionary word 
20c4			; 5. asm, calls etc for the word 
20c4			; 
20c4			;  if 1 == 0 then last word in dict  
20c4			;   
20c4			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20c4			;  
20c4			;  
20c4			; create basic standard set of words 
20c4			; 
20c4			;  
20c4			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20c4			; 2DUP 2DROP 2SWAP  
20c4			; @ C@ - get byte  
20c4			; ! C! - store byte 
20c4			; 0< true if less than zero 
20c4			; 0= true if zero 
20c4			; < >  
20c4			; = true if same 
20c4			; variables 
20c4			 
20c4			 
20c4			; Hardware specific words I may need 
20c4			; 
20c4			; IN OUT  
20c4			; calls to key util functions 
20c4			; calls to hardward abstraction stuff 
20c4			; easy control of frame buffers and lcd i/o 
20c4			; keyboard  
20c4			 
20c4			 
20c4			;DICT: macro 
20c4			; op_code, len, word, next 
20c4			;    word: 
20c4			;    db op_code 
20c4			;    ds word zero term 
20c4			;    dw next 
20c4			;    endm 
20c4			 
20c4			 
20c4			 
20c4			 
20c4			; op code 1 is a flag for user define words which are to be handled differently 
20c4			 
20c4			 
20c4			; 
20c4			; 
20c4			;    TODO on entry to a word this should be the expected environment 
20c4			;    hl - tos value if number then held, if string this is the ptr 
20c4			;    de -  
20c4			 
20c4			 
20c4			; opcode ranges 
20c4			; 0 - end of word dict 
20c4			; 255 - user define words 
20c4			 
20c4			sysdict: 
20c4			include "forth_opcodes.asm" 
20c4			; op codes for forth keywords 
20c4			 
20c4			; Changing use of opcodes to flag is the word exists in compiled form or not.  
20c4			; This provides a means to compile uwords if required for higher performance 
20c4			; by avoiding the use of the keyword parser and just jumping directly to the code 
20c4			; Actually there is already a flag for if the code exists as binary thinking about it... 
20c4			 
20c4			 
20c4			 
20c4			 
20c4			 
20c4			; free to use code 0  
20c4				OPCODE_HEAP: equ  1 
20c4				OPCODE_EXEC: equ 2 
20c4				OPCODE_DUP: equ 3 
20c4				OPCODE_SWAP: equ 4 
20c4				OPCODE_COLN: equ 5 
20c4				OPCODE_SCOLN: equ 6 
20c4				OPCODE_DROP: equ 7 
20c4				OPCODE_DUP2: equ 8 
20c4				OPCODE_DROP2: equ 9 
20c4				OPCODE_SWAP2: equ 10 
20c4				OPCODE_AT: equ 11 
20c4				OPCODE_CAT: equ 12 
20c4				OPCODE_BANG: equ 13 
20c4				OPCODE_CBANG: equ 14 
20c4				OPCODE_SCALL: equ 15 
20c4				OPCODE_DEPTH: equ 16 
20c4				OPCODE_OVER: equ 17 
20c4				OPCODE_PAUSE: equ 18 
20c4				OPCODE_PAUSES: equ 19 
20c4				OPCODE_ROT: equ 20 
20c4			;free to reuse	OPCODE_WORDS: equ 21 
20c4			        OPCODE_NOT: equ 21 
20c4				OPCODE_UWORDS: equ 22 
20c4				OPCODE_BP: equ 23 
20c4				OPCODE_MONITOR: equ 24  
20c4				OPCODE_MALLOC: equ 25 
20c4				OPCODE_FREE: equ 26 
20c4				OPCODE_LIST: equ 27 
20c4				OPCODE_FORGET: equ 28 
20c4				OPCODE_NOP: equ 29 
20c4				OPCODE_COMO: equ 30 
20c4				OPCODE_COMC: equ 31 
20c4			;free to reuse	OPCODE_ENDCORE: equ 32 
20c4				OPCODE_AFTERSOUND: equ 33 
20c4				OPCODE_GP2: equ 34 
20c4				OPCODE_GP3: equ 35 
20c4				OPCODE_GP4: equ 36 
20c4				OPCODE_SIN: equ 37 
20c4				OPCODE_SOUT: equ 38 
20c4				OPCODE_SPIO: equ 39 
20c4				OPCODE_SPICEH: equ 40 
20c4				OPCODE_SPIOb: equ 41 
20c4				OPCODE_SPII: equ 42 
20c4				OPCODE_SESEL: equ 43 
20c4				OPCODE_CARTDEV: equ 44 
20c4			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20c4				OPCODE_FB: equ 46 
20c4				OPCODE_EMIT: equ 47 
20c4				OPCODE_DOTH: equ 48 
20c4				OPCODE_DOTF: equ 49 
20c4				OPCODE_DOT: equ 50 
20c4				OPCODE_CLS: equ 51 
20c4				OPCODE_DRAW: equ 52 
20c4				OPCODE_DUMP: equ 53 
20c4				OPCODE_CDUMP: equ 54 
20c4				OPCODE_DAT: equ 55 
20c4				OPCODE_HOME: equ 56 
20c4				OPCODE_SPACE: equ 57 
20c4				OPCODE_SPACES: equ 58 
20c4				OPCODE_SCROLL: equ 59 
20c4				OPCODE_ATQ: equ 60 
20c4				OPCODE_AUTODSP: equ 61 
20c4				OPCODE_MENU: equ 62 
20c4			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20c4				OPCODE_THEN: equ 64 
20c4				OPCODE_ELSE: equ 65 
20c4				OPCODE_DO: equ 66 
20c4				OPCODE_LOOP: equ 67 
20c4				OPCODE_I: equ 68 
20c4				OPCODE_DLOOP: equ 69  
20c4				OPCODE_REPEAT: equ 70  
20c4				OPCODE_UNTIL: equ 71 
20c4				OPCODE_ENDFLOW: equ 72 
20c4				OPCODE_WAITK: equ 73 
20c4				OPCODE_ACCEPT: equ 74 
20c4				OPCODE_EDIT: equ 75 
20c4			;free to reuse	OPCODE_ENDKEY: equ 76 
20c4				OPCODE_LZERO: equ 77 
20c4				OPCODE_TZERO: equ 78 
20c4				OPCODE_LESS: equ 79 
20c4				OPCODE_GT: equ 80 
20c4				OPCODE_EQUAL: equ 81  
20c4			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20c4				OPCODE_NEG: equ 83 
20c4				OPCODE_DIV: equ 84 
20c4				OPCODE_MUL: equ 85 
20c4				OPCODE_MIN: equ 86 
20c4				OPCODE_MAX: equ 87 
20c4				OPCODE_RND16: equ 88 
20c4				OPCODE_RND8: equ 89 
20c4				OPCODE_RND: equ 90 
20c4			;free to reuse	OPCODE_ENDMATHS: equ 91  
20c4				OPCODE_BYNAME: equ 92 
20c4				OPCODE_DIR: equ 93 
20c4				OPCODE_SAVE: equ 94 
20c4				OPCODE_LOAD: equ 95 
20c4				OPCODE_BSAVE: equ 96 
20c4				OPCODE_BLOAD: equ 97 
20c4				OPCODE_SEO: equ 98  
20c4				OPCODE_SEI: equ 99 
20c4				OPCODE_SFREE: equ 100 
20c4				OPCODE_SIZE: equ 101 
20c4				OPCODE_CREATE: equ 102 
20c4				OPCODE_APPEND: equ 103 
20c4				OPCODE_SDEL: equ 104 
20c4				OPCODE_OPEN: equ 105 
20c4				OPCODE_READ: equ 106 
20c4				OPCODE_EOF: equ 106 
20c4				OPCODE_FORMAT: equ 107 
20c4				OPCODE_LABEL: equ 108 
20c4				OPCODE_LABELS: equ 109 
20c4			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20c4				OPCODE_UPPER: equ 111 
20c4				OPCODE_LOWER: equ 112 
20c4				OPCODE_SUBSTR: equ 113 
20c4				OPCODE_LEFT: equ 114 
20c4				OPCODE_RIGHT: equ 115 
20c4				OPCODE_STR2NUM: equ 116 
20c4				OPCODE_NUM2STR: equ 117 
20c4				OPCODE_CONCAT: equ 118 
20c4				OPCODE_FIND: equ 119 
20c4				OPCODE_LEN: equ 120 
20c4				OPCODE_CHAR: equ 121 
20c4			; free to reuse	OPCODE_STRLEN: equ 122 
20c4			; free to reuse	OPCODE_ENDSTR: equ 123 
20c4				OPCODE_V0S: equ 124 
20c4				OPCODE_V0Q: equ 125 
20c4				OPCODE_V1S: equ 126 
20c4				OPCODE_V1Q: equ 127 
20c4				OPCODE_V2S: equ 128 
20c4				OPCODE_V2Q: equ 129 
20c4				OPCODE_V3S: equ 130 
20c4				OPCODE_V3Q: equ 131 
20c4			;free to reuse	OPCODE_END: equ 132 
20c4				OPCODE_ZDUP: equ 133 
20c4			 
20c4			; eof 
# End of file forth_opcodes.asm
20c4			 
20c4			include "forth_words_core.asm" 
20c4			 
20c4			; | ## Core Words 
20c4			 
20c4			;if MALLOC_4 
20c4			 
20c4			.HEAP: 
20c4			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20c4 15				db WORD_SYS_CORE+OPCODE_HEAP             
20c5 03 21			dw .EXEC            
20c7 05				db 4 + 1 
20c8 .. 00			db "HEAP",0              
20cd				endm 
# End of macro CWHEAD
20cd			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20cd			; | | u1 - Current number of bytes in the heap 
20cd			; | | u2 - Remaining bytes left on the heap 
20cd			; | |  
20cd			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20cd			 
20cd			 
20cd				if DEBUG_FORTH_WORDS_KEY 
20cd					DMARK "HEP" 
20cd f5				push af  
20ce 3a e2 20			ld a, (.dmark)  
20d1 32 65 ee			ld (debug_mark),a  
20d4 3a e3 20			ld a, (.dmark+1)  
20d7 32 66 ee			ld (debug_mark+1),a  
20da 3a e4 20			ld a, (.dmark+2)  
20dd 32 67 ee			ld (debug_mark+2),a  
20e0 18 03			jr .pastdmark  
20e2 ..			.dmark: db "HEP"  
20e5 f1			.pastdmark: pop af  
20e6			endm  
# End of macro DMARK
20e6					CALLMONITOR 
20e6 cd 6f ee			call debug_vector  
20e9				endm  
# End of macro CALLMONITOR
20e9				endif 
20e9 2a 2c 64			ld hl, (free_list )      
20ec 11 31 64			ld de, heap_start 
20ef			 
20ef ed 52			sbc hl, de  
20f1			 
20f1 cd 90 1b			call forth_push_numhl 
20f4			 
20f4			 
20f4 ed 5b 2c 64		ld de, (free_list )      
20f8 21 96 e2			ld hl, heap_end 
20fb			 
20fb ed 52			sbc hl, de 
20fd			 
20fd cd 90 1b			call forth_push_numhl 
2100				 
2100			 
2100				 
2100			 
2100			 
2100			 
2100				NEXTW 
2100 c3 80 1f			jp macro_next 
2103				endm 
# End of macro NEXTW
2103			;endif 
2103			 
2103			.EXEC: 
2103			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2103			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2103			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2103			;; > > 
2103			;; > >   
2103			;	STACKFRAME OFF $5efe $5f9f 
2103			; 
2103			;		if DEBUG_FORTH_WORDS_KEY 
2103			;			DMARK "EXE" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			; 
2103			;	FORTH_DSP_VALUEHL 
2103			; 
2103			;	FORTH_DSP_POP 
2103			; 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX1" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;;	ld e,(hl) 
2103			;;	inc hl 
2103			;;	ld d,(hl) 
2103			;;	ex de,hl 
2103			; 
2103			;;		if DEBUG_FORTH_WORDS 
2103			;;			DMARK "EX2" 
2103			;;			CALLMONITOR 
2103			;;		endif 
2103			;	push hl 
2103			; 
2103			;	;ld a, 0 
2103			;	;ld a, FORTH_END_BUFFER 
2103			;	call strlenz 
2103			;	inc hl   ; include zero term to copy 
2103			;	inc hl   ; include term 
2103			;	inc hl   ; include term 
2103			;	ld b,0 
2103			;	ld c,l 
2103			;	pop hl 
2103			;	ld de, execscratch 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX3" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	ldir 
2103			; 
2103			; 
2103			;	ld hl, execscratch 
2103			; 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EXe" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			; 
2103			;	call forthparse 
2103			;	call forthexec 
2103			;;	call forthexec_cleanup 
2103			;;	call forthparse 
2103			;;	call forthexec 
2103			; 
2103			;	STACKFRAMECHK OFF $5efe $5f9f 
2103			; 
2103			;	; an immediate word so no need to process any more words 
2103			;	ret 
2103			;	NEXTW 
2103			 
2103			; dead code - old version  
2103			;	FORTH_RSP_NEXT 
2103			 
2103			;  
2103			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2103			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2103			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2103			;	push hl 
2103			;	push de 
2103			;	push bc 
2103			; 
2103			; 
2103			;		if DEBUG_FORTH_WORDS_KEY 
2103			;			DMARK "EXR" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			; 
2103			; 
2103			; 
2103			;	;v5 FORTH_DSP_VALUE 
2103			;	FORTH_DSP_VALUEHL 
2103			; 
2103			;	; TODO do string type checks 
2103			; 
2103			;;v5	inc hl   ; skip type 
2103			; 
2103			;	push hl  ; source code  
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX1" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	ld a, 0 
2103			;	call strlent 
2103			; 
2103			;	inc hl 
2103			;	inc hl 
2103			;	inc hl 
2103			;	inc hl 
2103			; 
2103			;	push hl    ; size 
2103			; 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX2" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	call malloc 
2103			; 
2103			;	ex de, hl    ; de now contains malloc area 
2103			;	pop bc   	; get byte count 
2103			;	pop hl      ; get string to copy 
2103			; 
2103			;	push de     ; save malloc for free later 
2103			; 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX3" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	ldir       ; duplicate string 
2103			; 
2103			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2103			;	 
2103			;	; TODO fix the parse would be better than this...  
2103			;	ex de, hl 
2103			;	dec hl 
2103			;	ld a, 0 
2103			;	ld (hl), a 
2103			;	dec hl 
2103			;	ld a, ' ' 
2103			;	ld (hl), a 
2103			;	dec hl 
2103			;	ld (hl), a 
2103			; 
2103			;	dec hl 
2103			;	ld (hl), a 
2103			; 
2103			; 
2103			;	FORTH_DSP_POP  
2103			; 
2103			;	pop hl     
2103			;	push hl    ; save malloc area 
2103			; 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX4" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			; 
2103			;	call forthparse 
2103			;	call forthexec 
2103			;	 
2103			;	pop hl 
2103			;	if DEBUG_FORTH_WORDS 
2103			;		DMARK "EX5" 
2103			;		CALLMONITOR 
2103			;	endif 
2103			; 
2103			;	if FORTH_ENABLE_FREE 
2103			;	call free 
2103			;	endif 
2103			; 
2103			;	if DEBUG_FORTH_WORDS 
2103			;		DMARK "EX6" 
2103			;		CALLMONITOR 
2103			;	endif 
2103			; 
2103			;	pop bc 
2103			;	pop de 
2103			;	pop hl 
2103			;;	FORTH_RSP_POP	  
2103			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2103			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2103			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2103			; 
2103			;	if DEBUG_FORTH_WORDS 
2103			;		DMARK "EX7" 
2103			;		CALLMONITOR 
2103			;	endif 
2103			;	NEXTW 
2103			 
2103			;.STKEXEC: 
2103			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2103			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2103			; 
2103			; 
2103			;		if DEBUG_FORTH_WORDS_KEY 
2103			;			DMARK "STX" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			; 
2103			;	FORTH_DSP_VALUEHL 
2103			; 
2103			;	ld (store_tmp1), hl    ; count 
2103			; 
2103			;	FORTH_DSP_POP 
2103			;.stkexec1: 
2103			;	ld hl, (store_tmp1)   ; count 
2103			;	ld a, 0 
2103			;	cp l 
2103			;	ret z 
2103			; 
2103			;	dec hl 
2103			;	ld (store_tmp1), hl    ; count 
2103			;	 
2103			;	FORTH_DSP_VALUEHL 
2103			;	push hl 
2103			;	 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EXp" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	FORTH_DSP_POP 
2103			; 
2103			;	call strlenz 
2103			;	inc hl   ; include zero term to copy 
2103			;	inc hl   ; include zero term to copy 
2103			;	inc hl   ; include zero term to copy 
2103			;	ld b,0 
2103			;	ld c,l 
2103			;	pop hl 
2103			;	ld de, execscratch 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EX3" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	ldir 
2103			; 
2103			; 
2103			;	ld hl, execscratch 
2103			; 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EXP" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			; 
2103			;	call forthparse 
2103			;	ld hl, execscratch 
2103			;		if DEBUG_FORTH_WORDS 
2103			;			DMARK "EXx" 
2103			;			CALLMONITOR 
2103			;		endif 
2103			;	call forthexec 
2103			; 
2103			;	jp .stkexec1 
2103			; 
2103			;	ret 
2103			 
2103			 
2103			.DUP: 
2103			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2103 17				db WORD_SYS_CORE+OPCODE_DUP             
2104 79 21			dw .ZDUP            
2106 04				db 3 + 1 
2107 .. 00			db "DUP",0              
210b				endm 
# End of macro CWHEAD
210b			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
210b			 
210b				if DEBUG_FORTH_WORDS_KEY 
210b					DMARK "DUP" 
210b f5				push af  
210c 3a 20 21			ld a, (.dmark)  
210f 32 65 ee			ld (debug_mark),a  
2112 3a 21 21			ld a, (.dmark+1)  
2115 32 66 ee			ld (debug_mark+1),a  
2118 3a 22 21			ld a, (.dmark+2)  
211b 32 67 ee			ld (debug_mark+2),a  
211e 18 03			jr .pastdmark  
2120 ..			.dmark: db "DUP"  
2123 f1			.pastdmark: pop af  
2124			endm  
# End of macro DMARK
2124					CALLMONITOR 
2124 cd 6f ee			call debug_vector  
2127				endm  
# End of macro CALLMONITOR
2127				endif 
2127			 
2127				FORTH_DSP 
2127 cd 5b 1d			call macro_forth_dsp 
212a				endm 
# End of macro FORTH_DSP
212a			 
212a 7e				ld a, (HL) 
212b fe 01			cp DS_TYPE_STR 
212d 20 25			jr nz, .dupinum 
212f			 
212f				; push another string 
212f			 
212f				FORTH_DSP_VALUEHL     		 
212f cd 95 1d			call macro_dsp_valuehl 
2132				endm 
# End of macro FORTH_DSP_VALUEHL
2132			 
2132			if DEBUG_FORTH_WORDS 
2132				DMARK "DUs" 
2132 f5				push af  
2133 3a 47 21			ld a, (.dmark)  
2136 32 65 ee			ld (debug_mark),a  
2139 3a 48 21			ld a, (.dmark+1)  
213c 32 66 ee			ld (debug_mark+1),a  
213f 3a 49 21			ld a, (.dmark+2)  
2142 32 67 ee			ld (debug_mark+2),a  
2145 18 03			jr .pastdmark  
2147 ..			.dmark: db "DUs"  
214a f1			.pastdmark: pop af  
214b			endm  
# End of macro DMARK
214b				CALLMONITOR 
214b cd 6f ee			call debug_vector  
214e				endm  
# End of macro CALLMONITOR
214e			endif 
214e cd fe 1b			call forth_push_str 
2151			 
2151				NEXTW 
2151 c3 80 1f			jp macro_next 
2154				endm 
# End of macro NEXTW
2154			 
2154			 
2154			.dupinum: 
2154				 
2154			 
2154			 
2154				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2154 cd 95 1d			call macro_dsp_valuehl 
2157				endm 
# End of macro FORTH_DSP_VALUEHL
2157			 
2157			; TODO add floating point number detection 
2157			 
2157			if DEBUG_FORTH_WORDS 
2157				DMARK "DUi" 
2157 f5				push af  
2158 3a 6c 21			ld a, (.dmark)  
215b 32 65 ee			ld (debug_mark),a  
215e 3a 6d 21			ld a, (.dmark+1)  
2161 32 66 ee			ld (debug_mark+1),a  
2164 3a 6e 21			ld a, (.dmark+2)  
2167 32 67 ee			ld (debug_mark+2),a  
216a 18 03			jr .pastdmark  
216c ..			.dmark: db "DUi"  
216f f1			.pastdmark: pop af  
2170			endm  
# End of macro DMARK
2170				CALLMONITOR 
2170 cd 6f ee			call debug_vector  
2173				endm  
# End of macro CALLMONITOR
2173			endif 
2173			 
2173 cd 90 1b			call forth_push_numhl 
2176				NEXTW 
2176 c3 80 1f			jp macro_next 
2179				endm 
# End of macro NEXTW
2179			.ZDUP: 
2179			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2179 99				db WORD_SYS_CORE+OPCODE_ZDUP             
217a b1 21			dw .DMRK            
217c 05				db 4 + 1 
217d .. 00			db "?DUP",0              
2182				endm 
# End of macro CWHEAD
2182			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
2182			 
2182				if DEBUG_FORTH_WORDS_KEY 
2182					DMARK "qDU" 
2182 f5				push af  
2183 3a 97 21			ld a, (.dmark)  
2186 32 65 ee			ld (debug_mark),a  
2189 3a 98 21			ld a, (.dmark+1)  
218c 32 66 ee			ld (debug_mark+1),a  
218f 3a 99 21			ld a, (.dmark+2)  
2192 32 67 ee			ld (debug_mark+2),a  
2195 18 03			jr .pastdmark  
2197 ..			.dmark: db "qDU"  
219a f1			.pastdmark: pop af  
219b			endm  
# End of macro DMARK
219b					CALLMONITOR 
219b cd 6f ee			call debug_vector  
219e				endm  
# End of macro CALLMONITOR
219e				endif 
219e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
219e cd 95 1d			call macro_dsp_valuehl 
21a1				endm 
# End of macro FORTH_DSP_VALUEHL
21a1			 
21a1 e5				push hl 
21a2			 
21a2				; is it a zero? 
21a2			 
21a2 3e 00			ld a, 0 
21a4 84				add h 
21a5 85				add l 
21a6			 
21a6 e1				pop hl 
21a7			 
21a7 fe 00			cp 0 
21a9 28 03			jr z, .dup2orig 
21ab			 
21ab			 
21ab cd 90 1b			call forth_push_numhl 
21ae			 
21ae			 
21ae			; TODO add floating point number detection 
21ae			 
21ae			.dup2orig: 
21ae			 
21ae				NEXTW 
21ae c3 80 1f			jp macro_next 
21b1				endm 
# End of macro NEXTW
21b1			.DMRK: 
21b1			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
21b1 99				db WORD_SYS_CORE+OPCODE_ZDUP             
21b2 ee 21			dw .LSHIFT            
21b4 06				db 5 + 1 
21b5 .. 00			db "DMARK",0              
21bb				endm 
# End of macro CWHEAD
21bb			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
21bb			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
21bb				if DEBUG_FORTH_WORDS_KEY 
21bb					DMARK "DMK" 
21bb f5				push af  
21bc 3a d0 21			ld a, (.dmark)  
21bf 32 65 ee			ld (debug_mark),a  
21c2 3a d1 21			ld a, (.dmark+1)  
21c5 32 66 ee			ld (debug_mark+1),a  
21c8 3a d2 21			ld a, (.dmark+2)  
21cb 32 67 ee			ld (debug_mark+2),a  
21ce 18 03			jr .pastdmark  
21d0 ..			.dmark: db "DMK"  
21d3 f1			.pastdmark: pop af  
21d4			endm  
# End of macro DMARK
21d4					CALLMONITOR 
21d4 cd 6f ee			call debug_vector  
21d7				endm  
# End of macro CALLMONITOR
21d7				endif 
21d7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21d7 cd 95 1d			call macro_dsp_valuehl 
21da				endm 
# End of macro FORTH_DSP_VALUEHL
21da			 
21da 7e				ld a, (hl) 
21db 32 65 ee			ld (debug_mark),a 
21de 23				inc hl 
21df 7e				ld a, (hl) 
21e0 32 66 ee			ld (debug_mark+1),a 
21e3 23				inc hl 
21e4 7e				ld a, (hl) 
21e5 32 67 ee			ld (debug_mark+2),a 
21e8			 
21e8			 
21e8				FORTH_DSP_POP 
21e8 cd 4d 1e			call macro_forth_dsp_pop 
21eb				endm 
# End of macro FORTH_DSP_POP
21eb				NEXTW 
21eb c3 80 1f			jp macro_next 
21ee				endm 
# End of macro NEXTW
21ee			.LSHIFT: 
21ee			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
21ee 99				db WORD_SYS_CORE+OPCODE_ZDUP             
21ef 22 22			dw .RSHIFT            
21f1 07				db 6 + 1 
21f2 .. 00			db "LSHIFT",0              
21f9				endm 
# End of macro CWHEAD
21f9			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
21f9				if DEBUG_FORTH_WORDS_KEY 
21f9					DMARK "LSH" 
21f9 f5				push af  
21fa 3a 0e 22			ld a, (.dmark)  
21fd 32 65 ee			ld (debug_mark),a  
2200 3a 0f 22			ld a, (.dmark+1)  
2203 32 66 ee			ld (debug_mark+1),a  
2206 3a 10 22			ld a, (.dmark+2)  
2209 32 67 ee			ld (debug_mark+2),a  
220c 18 03			jr .pastdmark  
220e ..			.dmark: db "LSH"  
2211 f1			.pastdmark: pop af  
2212			endm  
# End of macro DMARK
2212					CALLMONITOR 
2212 cd 6f ee			call debug_vector  
2215				endm  
# End of macro CALLMONITOR
2215				endif 
2215				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2215 cd 95 1d			call macro_dsp_valuehl 
2218				endm 
# End of macro FORTH_DSP_VALUEHL
2218				FORTH_DSP_POP 
2218 cd 4d 1e			call macro_forth_dsp_pop 
221b				endm 
# End of macro FORTH_DSP_POP
221b			 
221b 29				add hl, hl 
221c cd 90 1b			call forth_push_numhl 
221f				NEXTW 
221f c3 80 1f			jp macro_next 
2222				endm 
# End of macro NEXTW
2222			.RSHIFT: 
2222			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
2222 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2223 59 22			dw .SWAP            
2225 07				db 6 + 1 
2226 .. 00			db "RSHIFT",0              
222d				endm 
# End of macro CWHEAD
222d			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
222d				if DEBUG_FORTH_WORDS_KEY 
222d					DMARK "RSH" 
222d f5				push af  
222e 3a 42 22			ld a, (.dmark)  
2231 32 65 ee			ld (debug_mark),a  
2234 3a 43 22			ld a, (.dmark+1)  
2237 32 66 ee			ld (debug_mark+1),a  
223a 3a 44 22			ld a, (.dmark+2)  
223d 32 67 ee			ld (debug_mark+2),a  
2240 18 03			jr .pastdmark  
2242 ..			.dmark: db "RSH"  
2245 f1			.pastdmark: pop af  
2246			endm  
# End of macro DMARK
2246					CALLMONITOR 
2246 cd 6f ee			call debug_vector  
2249				endm  
# End of macro CALLMONITOR
2249				endif 
2249				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2249 cd 95 1d			call macro_dsp_valuehl 
224c				endm 
# End of macro FORTH_DSP_VALUEHL
224c				FORTH_DSP_POP 
224c cd 4d 1e			call macro_forth_dsp_pop 
224f				endm 
# End of macro FORTH_DSP_POP
224f cb 3c			srl h 
2251 cb 1d			rr l 
2253 cd 90 1b			call forth_push_numhl 
2256				NEXTW 
2256 c3 80 1f			jp macro_next 
2259				endm 
# End of macro NEXTW
2259			.SWAP: 
2259			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2259 18				db WORD_SYS_CORE+OPCODE_SWAP             
225a ad 22			dw .COLN            
225c 05				db 4 + 1 
225d .. 00			db "SWAP",0              
2262				endm 
# End of macro CWHEAD
2262			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2262				if DEBUG_FORTH_WORDS_KEY 
2262					DMARK "SWP" 
2262 f5				push af  
2263 3a 77 22			ld a, (.dmark)  
2266 32 65 ee			ld (debug_mark),a  
2269 3a 78 22			ld a, (.dmark+1)  
226c 32 66 ee			ld (debug_mark+1),a  
226f 3a 79 22			ld a, (.dmark+2)  
2272 32 67 ee			ld (debug_mark+2),a  
2275 18 03			jr .pastdmark  
2277 ..			.dmark: db "SWP"  
227a f1			.pastdmark: pop af  
227b			endm  
# End of macro DMARK
227b					CALLMONITOR 
227b cd 6f ee			call debug_vector  
227e				endm  
# End of macro CALLMONITOR
227e				endif 
227e			 
227e			; DONE Use os stack swap memory 
227e			 
227e				FORTH_DSP_PTR 0     ; TOS 
227e 2a e8 e9			ld hl,(cli_data_sp) 
2281 11 00 00			ld de, 0 * 3 
2284 ed 52			sbc hl, de 
2286				endm 
# End of macro FORTH_DSP_PTR
2286 cd cc 1e			call hltostack1 
2289			  
2289				FORTH_DSP_PTR 1     ; TOS 
2289 2a e8 e9			ld hl,(cli_data_sp) 
228c 11 03 00			ld de, 1 * 3 
228f ed 52			sbc hl, de 
2291				endm 
# End of macro FORTH_DSP_PTR
2291 cd d2 1e			call hltostack2 
2294			 
2294				FORTH_DSP_PTR 0     ; TOS 
2294 2a e8 e9			ld hl,(cli_data_sp) 
2297 11 00 00			ld de, 0 * 3 
229a ed 52			sbc hl, de 
229c				endm 
# End of macro FORTH_DSP_PTR
229c cd ea 1e			call hlfromstack2 
229f			 
229f				FORTH_DSP_PTR 1     ; TOS 
229f 2a e8 e9			ld hl,(cli_data_sp) 
22a2 11 03 00			ld de, 1 * 3 
22a5 ed 52			sbc hl, de 
22a7				endm 
# End of macro FORTH_DSP_PTR
22a7 cd e4 1e			call hlfromstack1 
22aa			;	FORTH_DSP_VALUEHL 
22aa			;	push hl     ; w2 
22aa			; 
22aa			;	FORTH_DSP_POP 
22aa			; 
22aa			;	FORTH_DSP_VALUEHL 
22aa			; 
22aa			;	FORTH_DSP_POP 
22aa			; 
22aa			;	pop de     ; w2	, hl = w1 
22aa			; 
22aa			;	ex de, hl 
22aa			;	push de 
22aa			; 
22aa			;	call forth_push_numhl 
22aa			; 
22aa			;	pop hl 
22aa			; 
22aa			;	call forth_push_numhl 
22aa				 
22aa			 
22aa				NEXTW 
22aa c3 80 1f			jp macro_next 
22ad				endm 
# End of macro NEXTW
22ad			.COLN: 
22ad			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22ad 19				db WORD_SYS_CORE+OPCODE_COLN             
22ae 39 24			dw .SCOLN            
22b0 02				db 1 + 1 
22b1 .. 00			db ":",0              
22b3				endm 
# End of macro CWHEAD
22b3			; | : ( -- )         Create new word | DONE 
22b3			 
22b3				if DEBUG_FORTH_WORDS_KEY 
22b3					DMARK "CLN" 
22b3 f5				push af  
22b4 3a c8 22			ld a, (.dmark)  
22b7 32 65 ee			ld (debug_mark),a  
22ba 3a c9 22			ld a, (.dmark+1)  
22bd 32 66 ee			ld (debug_mark+1),a  
22c0 3a ca 22			ld a, (.dmark+2)  
22c3 32 67 ee			ld (debug_mark+2),a  
22c6 18 03			jr .pastdmark  
22c8 ..			.dmark: db "CLN"  
22cb f1			.pastdmark: pop af  
22cc			endm  
# End of macro DMARK
22cc					CALLMONITOR 
22cc cd 6f ee			call debug_vector  
22cf				endm  
# End of macro CALLMONITOR
22cf				endif 
22cf			STACKFRAME OFF $8efe $989f 
22cf				if DEBUG_STACK_IMB 
22cf					if OFF 
22cf						exx 
22cf						ld de, $8efe 
22cf						ld a, d 
22cf						ld hl, curframe 
22cf						call hexout 
22cf						ld a, e 
22cf						ld hl, curframe+2 
22cf						call hexout 
22cf						ld hl, $8efe 
22cf						push hl 
22cf						ld hl, $989f 
22cf						push hl 
22cf						exx 
22cf					endif 
22cf				endif 
22cf			endm 
# End of macro STACKFRAME
22cf			; get parser buffer length  of new word 
22cf			 
22cf			 
22cf			 
22cf				; move tok past this to start of name defintition 
22cf				; TODO get word to define 
22cf				; TODO Move past word token 
22cf				; TODO get length of string up to the ';' 
22cf			 
22cf 2a bc e5		ld hl, (os_tok_ptr) 
22d2 23			inc hl 
22d3 23			inc hl 
22d4			 
22d4 3e 3b		ld a, ';' 
22d6 cd 66 11		call strlent 
22d9			 
22d9 7d			ld a,l 
22da 32 ab e2		ld (os_new_parse_len), a 
22dd			 
22dd			 
22dd			if DEBUG_FORTH_UWORD 
22dd ed 5b bc e5	ld de, (os_tok_ptr) 
22e1					DMARK ":01" 
22e1 f5				push af  
22e2 3a f6 22			ld a, (.dmark)  
22e5 32 65 ee			ld (debug_mark),a  
22e8 3a f7 22			ld a, (.dmark+1)  
22eb 32 66 ee			ld (debug_mark+1),a  
22ee 3a f8 22			ld a, (.dmark+2)  
22f1 32 67 ee			ld (debug_mark+2),a  
22f4 18 03			jr .pastdmark  
22f6 ..			.dmark: db ":01"  
22f9 f1			.pastdmark: pop af  
22fa			endm  
# End of macro DMARK
22fa			CALLMONITOR 
22fa cd 6f ee			call debug_vector  
22fd				endm  
# End of macro CALLMONITOR
22fd			endif 
22fd			 
22fd			; 
22fd			;  new word memory layout: 
22fd			;  
22fd			;    : adg 6666 ;  
22fd			; 
22fd			;    db   1     ; user defined word  
22fd 23			inc hl    
22fe			;    dw   sysdict 
22fe 23			inc hl 
22ff 23			inc hl 
2300			;    db <word len>+1 (for null) 
2300 23			inc hl 
2301			;    db .... <word> 
2301			; 
2301			 
2301 23			inc hl    ; some extras for the word preamble before the above 
2302 23			inc hl 
2303 23			inc hl 
2304 23			inc hl 
2305 23			inc hl 
2306 23			inc hl 
2307 23			inc hl  
2308 23			inc hl 
2309 23			inc hl 
230a 23			inc hl 
230b 23			inc hl 
230c 23			inc hl 
230d 23			inc hl 
230e 23			inc hl     ; TODO how many do we really need?     maybe only 6 
230f			;       exec word buffer 
230f			;	<ptr word>   
230f 23			inc hl 
2310 23			inc hl 
2311			;       <word list><null term> 7F final term 
2311			 
2311			 
2311			if DEBUG_FORTH_UWORD 
2311					DMARK ":02" 
2311 f5				push af  
2312 3a 26 23			ld a, (.dmark)  
2315 32 65 ee			ld (debug_mark),a  
2318 3a 27 23			ld a, (.dmark+1)  
231b 32 66 ee			ld (debug_mark+1),a  
231e 3a 28 23			ld a, (.dmark+2)  
2321 32 67 ee			ld (debug_mark+2),a  
2324 18 03			jr .pastdmark  
2326 ..			.dmark: db ":02"  
2329 f1			.pastdmark: pop af  
232a			endm  
# End of macro DMARK
232a			CALLMONITOR 
232a cd 6f ee			call debug_vector  
232d				endm  
# End of macro CALLMONITOR
232d			endif 
232d			 
232d			 
232d				; malloc the size 
232d			 
232d cd d0 11			call malloc 
2330 22 ad e2			ld (os_new_malloc), hl     ; save malloc start 
2333			 
2333			;    db   1     ; user defined word  
2333 3e 01			ld a, WORD_SYS_UWORD  
2335 77				ld (hl), a 
2336			 
2336 23			inc hl    
2337			;    dw   sysdict 
2337 11 c4 20		ld de, sysdict       ; continue on with the scan to the system dict 
233a 73			ld (hl), e 
233b 23			inc hl 
233c 72			ld (hl), d 
233d 23			inc hl 
233e			 
233e			 
233e			;    Setup dict word 
233e			 
233e 23			inc hl 
233f 22 a7 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2342			 
2342			; 1. get length of dict word 
2342			 
2342			 
2342 2a bc e5		ld hl, (os_tok_ptr) 
2345 23			inc hl 
2346 23			inc hl    ; position to start of dict word 
2347 3e 00		ld a, 0 
2349 cd 66 11		call strlent 
234c			 
234c			 
234c 23			inc hl    ; to include null??? 
234d			 
234d			; write length of dict word 
234d			 
234d ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2351 1b			dec de 
2352 eb			ex de, hl 
2353 73			ld (hl), e 
2354 eb			ex de, hl 
2355			 
2355			 
2355			 
2355			; copy  
2355 4d			ld c, l 
2356 06 00		ld b, 0 
2358 ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
235c 2a bc e5		ld hl, (os_tok_ptr) 
235f 23			inc hl 
2360 23			inc hl    ; position to start of dict word 
2361			 
2361			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2361			 
2361			; TODO need to convert word to upper case 
2361			 
2361			ucasetok:	 
2361 7e			ld a,(hl) 
2362 cd 52 11		call toUpper 
2365 77			ld (hl),a 
2366 ed a0		ldi 
2368 f2 61 23		jp p, ucasetok 
236b			 
236b			 
236b			 
236b			; de now points to start of where the word body code should be placed 
236b ed 53 a7 e2	ld (os_new_work_ptr), de 
236f			; hl now points to the words to throw at forthexec which needs to be copied 
236f 22 a5 e2		ld (os_new_src_ptr), hl 
2372			 
2372			; TODO add 'call to forthexec' 
2372			 
2372			if DEBUG_FORTH_UWORD 
2372 c5			push bc 
2373 ed 4b ad e2	ld bc, (os_new_malloc) 
2377					DMARK ":0x" 
2377 f5				push af  
2378 3a 8c 23			ld a, (.dmark)  
237b 32 65 ee			ld (debug_mark),a  
237e 3a 8d 23			ld a, (.dmark+1)  
2381 32 66 ee			ld (debug_mark+1),a  
2384 3a 8e 23			ld a, (.dmark+2)  
2387 32 67 ee			ld (debug_mark+2),a  
238a 18 03			jr .pastdmark  
238c ..			.dmark: db ":0x"  
238f f1			.pastdmark: pop af  
2390			endm  
# End of macro DMARK
2390			CALLMONITOR 
2390 cd 6f ee			call debug_vector  
2393				endm  
# End of macro CALLMONITOR
2393 c1			pop bc 
2394			endif 
2394			 
2394			 
2394			; create word preamble which should be: 
2394			 
2394			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2394			 
2394			;    ld hl, <word code> 
2394			;    jp user_exec 
2394			;    <word code bytes> 
2394			 
2394			 
2394			;	inc de     ; TODO ??? or are we already past the word's null 
2394 eb			ex de, hl 
2395			 
2395 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2397			 
2397 23			inc hl 
2398 22 a1 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
239b 23			inc hl 
239c			 
239c 23			inc hl 
239d 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
239f			 
239f 01 a6 51		ld bc, user_exec 
23a2 23			inc hl 
23a3 71			ld (hl), c     ; poke address of user_exec 
23a4 23			inc hl 
23a5 70			ld (hl), b     
23a6			; 
23a6			;	inc hl 
23a6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23a6			; 
23a6			; 
23a6			;	ld bc, macro_forth_rsp_next 
23a6			;	inc hl 
23a6			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23a6			;	inc hl 
23a6			;	ld (hl), b     
23a6			; 
23a6			;	inc hl 
23a6			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23a6			; 
23a6			; 
23a6			;	inc hl 
23a6			;	ld bc, forthexec 
23a6			;	ld (hl), c     ; poke address of forthexec 
23a6			;	inc hl 
23a6			;	ld (hl), b      
23a6			; 
23a6			;	inc hl 
23a6			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23a6			; 
23a6			;	ld bc, user_dict_next 
23a6			;	inc hl 
23a6			;	ld (hl), c     ; poke address of forthexec 
23a6			;	inc hl 
23a6			;	ld (hl), b      
23a6			 
23a6			; hl is now where we need to copy the word byte data to save this 
23a6			 
23a6 23			inc hl 
23a7 22 a3 e2		ld (os_new_exec), hl 
23aa			 
23aa			; copy definition 
23aa			 
23aa eb			ex de, hl 
23ab			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23ab			;	inc de    ; skip the PC for this parse 
23ab 3a ab e2		ld a, (os_new_parse_len) 
23ae 4f			ld c, a 
23af 06 00		ld b, 0 
23b1 ed b0		ldir		 ; copy defintion 
23b3			 
23b3			 
23b3			; poke the address of where the new word bytes live for forthexec 
23b3			 
23b3 2a a1 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23b6			 
23b6 ed 5b a3 e2	ld de, (os_new_exec)      
23ba			 
23ba 73			ld (hl), e 
23bb 23			inc hl 
23bc 72			ld (hl), d 
23bd			 
23bd				; TODO copy last user dict word next link to this word 
23bd				; TODO update last user dict word to point to this word 
23bd			; 
23bd			; hl f923 de 812a ; bc 811a 
23bd			 
23bd			if DEBUG_FORTH_UWORD 
23bd c5			push bc 
23be ed 4b ad e2	ld bc, (os_new_malloc) 
23c2					DMARK ":0A" 
23c2 f5				push af  
23c3 3a d7 23			ld a, (.dmark)  
23c6 32 65 ee			ld (debug_mark),a  
23c9 3a d8 23			ld a, (.dmark+1)  
23cc 32 66 ee			ld (debug_mark+1),a  
23cf 3a d9 23			ld a, (.dmark+2)  
23d2 32 67 ee			ld (debug_mark+2),a  
23d5 18 03			jr .pastdmark  
23d7 ..			.dmark: db ":0A"  
23da f1			.pastdmark: pop af  
23db			endm  
# End of macro DMARK
23db			CALLMONITOR 
23db cd 6f ee			call debug_vector  
23de				endm  
# End of macro CALLMONITOR
23de c1			pop bc 
23df			endif 
23df			if DEBUG_FORTH_UWORD 
23df c5			push bc 
23e0 ed 4b ad e2	ld bc, (os_new_malloc) 
23e4 03			inc bc 
23e5 03			inc bc 
23e6 03			inc bc 
23e7 03			inc bc 
23e8 03			inc bc 
23e9 03			inc bc 
23ea 03			inc bc 
23eb 03			inc bc 
23ec			 
23ec					DMARK ":0B" 
23ec f5				push af  
23ed 3a 01 24			ld a, (.dmark)  
23f0 32 65 ee			ld (debug_mark),a  
23f3 3a 02 24			ld a, (.dmark+1)  
23f6 32 66 ee			ld (debug_mark+1),a  
23f9 3a 03 24			ld a, (.dmark+2)  
23fc 32 67 ee			ld (debug_mark+2),a  
23ff 18 03			jr .pastdmark  
2401 ..			.dmark: db ":0B"  
2404 f1			.pastdmark: pop af  
2405			endm  
# End of macro DMARK
2405			CALLMONITOR 
2405 cd 6f ee			call debug_vector  
2408				endm  
# End of macro CALLMONITOR
2408 c1			pop bc 
2409			endif 
2409			 
2409			; update word dict linked list for new word 
2409			 
2409			 
2409 2a b8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
240c 23			inc hl     ; move to next work linked list ptr 
240d			 
240d ed 5b ad e2	ld de, (os_new_malloc)		 ; new next word 
2411 73			ld (hl), e 
2412 23			inc hl 
2413 72			ld (hl), d 
2414			 
2414			if DEBUG_FORTH_UWORD 
2414 ed 4b b8 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2418			endif 
2418			 
2418 ed 53 b8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
241c			 
241c			 
241c			if DEBUG_FORTH_UWORD 
241c					DMARK ":0+" 
241c f5				push af  
241d 3a 31 24			ld a, (.dmark)  
2420 32 65 ee			ld (debug_mark),a  
2423 3a 32 24			ld a, (.dmark+1)  
2426 32 66 ee			ld (debug_mark+1),a  
2429 3a 33 24			ld a, (.dmark+2)  
242c 32 67 ee			ld (debug_mark+2),a  
242f 18 03			jr .pastdmark  
2431 ..			.dmark: db ":0+"  
2434 f1			.pastdmark: pop af  
2435			endm  
# End of macro DMARK
2435			CALLMONITOR 
2435 cd 6f ee			call debug_vector  
2438				endm  
# End of macro CALLMONITOR
2438			endif 
2438			 
2438			STACKFRAMECHK OFF $8efe $989f 
2438				if DEBUG_STACK_IMB 
2438					if OFF 
2438						exx 
2438						ld hl, $989f 
2438						pop de   ; $989f 
2438						call cmp16 
2438						jr nz, .spnosame 
2438						ld hl, $8efe 
2438						pop de   ; $8efe 
2438						call cmp16 
2438						jr z, .spfrsame 
2438						.spnosame: call showsperror 
2438						.spfrsame: nop 
2438						exx 
2438					endif 
2438				endif 
2438			endm 
# End of macro STACKFRAMECHK
2438			 
2438 c9			ret    ; dont process any remaining parser tokens as they form new word 
2439			 
2439			 
2439			 
2439			 
2439			;		NEXT 
2439			.SCOLN: 
2439			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2439 06			db OPCODE_SCOLN 
243a 85 24		dw .DROP 
243c 02			db 2 
243d .. 00		db ";",0           
243f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
243f				if DEBUG_FORTH_WORDS_KEY 
243f					DMARK "SCN" 
243f f5				push af  
2440 3a 54 24			ld a, (.dmark)  
2443 32 65 ee			ld (debug_mark),a  
2446 3a 55 24			ld a, (.dmark+1)  
2449 32 66 ee			ld (debug_mark+1),a  
244c 3a 56 24			ld a, (.dmark+2)  
244f 32 67 ee			ld (debug_mark+2),a  
2452 18 03			jr .pastdmark  
2454 ..			.dmark: db "SCN"  
2457 f1			.pastdmark: pop af  
2458			endm  
# End of macro DMARK
2458					CALLMONITOR 
2458 cd 6f ee			call debug_vector  
245b				endm  
# End of macro CALLMONITOR
245b				endif 
245b				FORTH_RSP_TOS 
245b cd 4e 1b			call macro_forth_rsp_tos 
245e				endm 
# End of macro FORTH_RSP_TOS
245e e5				push hl 
245f				FORTH_RSP_POP 
245f cd 58 1b			call macro_forth_rsp_pop 
2462				endm 
# End of macro FORTH_RSP_POP
2462 e1				pop hl 
2463			;		ex de,hl 
2463 22 bc e5			ld (os_tok_ptr),hl 
2466			 
2466			if DEBUG_FORTH_UWORD 
2466					DMARK "SCL" 
2466 f5				push af  
2467 3a 7b 24			ld a, (.dmark)  
246a 32 65 ee			ld (debug_mark),a  
246d 3a 7c 24			ld a, (.dmark+1)  
2470 32 66 ee			ld (debug_mark+1),a  
2473 3a 7d 24			ld a, (.dmark+2)  
2476 32 67 ee			ld (debug_mark+2),a  
2479 18 03			jr .pastdmark  
247b ..			.dmark: db "SCL"  
247e f1			.pastdmark: pop af  
247f			endm  
# End of macro DMARK
247f			CALLMONITOR 
247f cd 6f ee			call debug_vector  
2482				endm  
# End of macro CALLMONITOR
2482			endif 
2482				NEXTW 
2482 c3 80 1f			jp macro_next 
2485				endm 
# End of macro NEXTW
2485			 
2485			.DROP: 
2485			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2485 1b				db WORD_SYS_CORE+OPCODE_DROP             
2486 b0 24			dw .DUP2            
2488 05				db 4 + 1 
2489 .. 00			db "DROP",0              
248e				endm 
# End of macro CWHEAD
248e			; | DROP ( w -- )   drop the TOS item   | DONE 
248e				if DEBUG_FORTH_WORDS_KEY 
248e					DMARK "DRP" 
248e f5				push af  
248f 3a a3 24			ld a, (.dmark)  
2492 32 65 ee			ld (debug_mark),a  
2495 3a a4 24			ld a, (.dmark+1)  
2498 32 66 ee			ld (debug_mark+1),a  
249b 3a a5 24			ld a, (.dmark+2)  
249e 32 67 ee			ld (debug_mark+2),a  
24a1 18 03			jr .pastdmark  
24a3 ..			.dmark: db "DRP"  
24a6 f1			.pastdmark: pop af  
24a7			endm  
# End of macro DMARK
24a7					CALLMONITOR 
24a7 cd 6f ee			call debug_vector  
24aa				endm  
# End of macro CALLMONITOR
24aa				endif 
24aa				FORTH_DSP_POP 
24aa cd 4d 1e			call macro_forth_dsp_pop 
24ad				endm 
# End of macro FORTH_DSP_POP
24ad				NEXTW 
24ad c3 80 1f			jp macro_next 
24b0				endm 
# End of macro NEXTW
24b0			.DUP2: 
24b0			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24b0 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24b1 f5 24			dw .DROP2            
24b3 05				db 4 + 1 
24b4 .. 00			db "2DUP",0              
24b9				endm 
# End of macro CWHEAD
24b9			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
24b9				if DEBUG_FORTH_WORDS_KEY 
24b9					DMARK "2DU" 
24b9 f5				push af  
24ba 3a ce 24			ld a, (.dmark)  
24bd 32 65 ee			ld (debug_mark),a  
24c0 3a cf 24			ld a, (.dmark+1)  
24c3 32 66 ee			ld (debug_mark+1),a  
24c6 3a d0 24			ld a, (.dmark+2)  
24c9 32 67 ee			ld (debug_mark+2),a  
24cc 18 03			jr .pastdmark  
24ce ..			.dmark: db "2DU"  
24d1 f1			.pastdmark: pop af  
24d2			endm  
# End of macro DMARK
24d2					CALLMONITOR 
24d2 cd 6f ee			call debug_vector  
24d5				endm  
# End of macro CALLMONITOR
24d5				endif 
24d5				FORTH_DSP_VALUEHL 
24d5 cd 95 1d			call macro_dsp_valuehl 
24d8				endm 
# End of macro FORTH_DSP_VALUEHL
24d8 e5				push hl      ; 2 
24d9			 
24d9				FORTH_DSP_POP 
24d9 cd 4d 1e			call macro_forth_dsp_pop 
24dc				endm 
# End of macro FORTH_DSP_POP
24dc				 
24dc				FORTH_DSP_VALUEHL 
24dc cd 95 1d			call macro_dsp_valuehl 
24df				endm 
# End of macro FORTH_DSP_VALUEHL
24df			;		push hl      ; 1 
24df			 
24df				FORTH_DSP_POP 
24df cd 4d 1e			call macro_forth_dsp_pop 
24e2				endm 
# End of macro FORTH_DSP_POP
24e2			 
24e2			;		pop hl       ; 1 
24e2 d1				pop de       ; 2 
24e3			 
24e3 cd 90 1b			call forth_push_numhl 
24e6 eb				ex de, hl 
24e7 cd 90 1b			call forth_push_numhl 
24ea			 
24ea				 
24ea eb				ex de, hl 
24eb			 
24eb cd 90 1b			call forth_push_numhl 
24ee eb				ex de, hl 
24ef cd 90 1b			call forth_push_numhl 
24f2			 
24f2			 
24f2				NEXTW 
24f2 c3 80 1f			jp macro_next 
24f5				endm 
# End of macro NEXTW
24f5			.DROP2: 
24f5			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24f5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24f6 24 25			dw .PICK            
24f8 06				db 5 + 1 
24f9 .. 00			db "2DROP",0              
24ff				endm 
# End of macro CWHEAD
24ff			; | 2DROP ( w w -- )    Double drop | DONE 
24ff				if DEBUG_FORTH_WORDS_KEY 
24ff					DMARK "2DR" 
24ff f5				push af  
2500 3a 14 25			ld a, (.dmark)  
2503 32 65 ee			ld (debug_mark),a  
2506 3a 15 25			ld a, (.dmark+1)  
2509 32 66 ee			ld (debug_mark+1),a  
250c 3a 16 25			ld a, (.dmark+2)  
250f 32 67 ee			ld (debug_mark+2),a  
2512 18 03			jr .pastdmark  
2514 ..			.dmark: db "2DR"  
2517 f1			.pastdmark: pop af  
2518			endm  
# End of macro DMARK
2518					CALLMONITOR 
2518 cd 6f ee			call debug_vector  
251b				endm  
# End of macro CALLMONITOR
251b				endif 
251b				FORTH_DSP_POP 
251b cd 4d 1e			call macro_forth_dsp_pop 
251e				endm 
# End of macro FORTH_DSP_POP
251e				FORTH_DSP_POP 
251e cd 4d 1e			call macro_forth_dsp_pop 
2521				endm 
# End of macro FORTH_DSP_POP
2521				NEXTW 
2521 c3 80 1f			jp macro_next 
2524				endm 
# End of macro NEXTW
2524			.PICK: 
2524			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2524 77				db WORD_SYS_CORE+99             
2525 be 25			dw .SWAP2            
2527 05				db 4 + 1 
2528 .. 00			db "PICK",0              
252d				endm 
# End of macro CWHEAD
252d			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
252d			; | | >[!NOTE] 
252d			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
252d				if DEBUG_FORTH_WORDS_KEY 
252d					DMARK "PIK" 
252d f5				push af  
252e 3a 42 25			ld a, (.dmark)  
2531 32 65 ee			ld (debug_mark),a  
2534 3a 43 25			ld a, (.dmark+1)  
2537 32 66 ee			ld (debug_mark+1),a  
253a 3a 44 25			ld a, (.dmark+2)  
253d 32 67 ee			ld (debug_mark+2),a  
2540 18 03			jr .pastdmark  
2542 ..			.dmark: db "PIK"  
2545 f1			.pastdmark: pop af  
2546			endm  
# End of macro DMARK
2546					CALLMONITOR 
2546 cd 6f ee			call debug_vector  
2549				endm  
# End of macro CALLMONITOR
2549				endif 
2549			 
2549				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2549 cd 95 1d			call macro_dsp_valuehl 
254c				endm 
# End of macro FORTH_DSP_VALUEHL
254c				 
254c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
254c cd 4d 1e			call macro_forth_dsp_pop 
254f				endm 
# End of macro FORTH_DSP_POP
254f			 
254f				; init from TOS 
254f e5				push hl 
2550				FORTH_DSP 
2550 cd 5b 1d			call macro_forth_dsp 
2553				endm 
# End of macro FORTH_DSP
2553			;	ld hl, cli_data_sp 
2553				if DEBUG_FORTH_WORDS 
2553					DMARK "PK1" 
2553 f5				push af  
2554 3a 68 25			ld a, (.dmark)  
2557 32 65 ee			ld (debug_mark),a  
255a 3a 69 25			ld a, (.dmark+1)  
255d 32 66 ee			ld (debug_mark+1),a  
2560 3a 6a 25			ld a, (.dmark+2)  
2563 32 67 ee			ld (debug_mark+2),a  
2566 18 03			jr .pastdmark  
2568 ..			.dmark: db "PK1"  
256b f1			.pastdmark: pop af  
256c			endm  
# End of macro DMARK
256c					CALLMONITOR 
256c cd 6f ee			call debug_vector  
256f				endm  
# End of macro CALLMONITOR
256f				endif 
256f c1				pop bc 
2570 41				ld b,c 
2571 3e 00			ld a, 0 
2573 b8				cp b 
2574 28 21			jr z, .pdone	 
2576			.pkl: 
2576 2b				dec hl 
2577 2b				dec hl 
2578 2b				dec hl 
2579			 
2579				if DEBUG_FORTH_WORDS 
2579					DMARK "PKl" 
2579 f5				push af  
257a 3a 8e 25			ld a, (.dmark)  
257d 32 65 ee			ld (debug_mark),a  
2580 3a 8f 25			ld a, (.dmark+1)  
2583 32 66 ee			ld (debug_mark+1),a  
2586 3a 90 25			ld a, (.dmark+2)  
2589 32 67 ee			ld (debug_mark+2),a  
258c 18 03			jr .pastdmark  
258e ..			.dmark: db "PKl"  
2591 f1			.pastdmark: pop af  
2592			endm  
# End of macro DMARK
2592					CALLMONITOR 
2592 cd 6f ee			call debug_vector  
2595				endm  
# End of macro CALLMONITOR
2595				endif 
2595 10 df			djnz .pkl 
2597			.pdone: 
2597				 
2597				; TODO do type check with correct push 
2597			 
2597 23				inc hl 
2598				;call loadwordinhl 
2598 5e				ld e, (hl) 
2599 23				inc hl 
259a 56				ld d, (hl) 
259b eb				ex de,hl 
259c				if DEBUG_FORTH_WORDS 
259c					DMARK "PKp" 
259c f5				push af  
259d 3a b1 25			ld a, (.dmark)  
25a0 32 65 ee			ld (debug_mark),a  
25a3 3a b2 25			ld a, (.dmark+1)  
25a6 32 66 ee			ld (debug_mark+1),a  
25a9 3a b3 25			ld a, (.dmark+2)  
25ac 32 67 ee			ld (debug_mark+2),a  
25af 18 03			jr .pastdmark  
25b1 ..			.dmark: db "PKp"  
25b4 f1			.pastdmark: pop af  
25b5			endm  
# End of macro DMARK
25b5					CALLMONITOR 
25b5 cd 6f ee			call debug_vector  
25b8				endm  
# End of macro CALLMONITOR
25b8				endif 
25b8 cd 90 1b			call forth_push_numhl 
25bb			 
25bb				NEXTW 
25bb c3 80 1f			jp macro_next 
25be				endm 
# End of macro NEXTW
25be			.SWAP2: 
25be			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
25be 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
25bf 3f 26			dw .AT            
25c1 06				db 5 + 1 
25c2 .. 00			db "2SWAP",0              
25c8				endm 
# End of macro CWHEAD
25c8			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
25c8				if DEBUG_FORTH_WORDS_KEY 
25c8					DMARK "2SW" 
25c8 f5				push af  
25c9 3a dd 25			ld a, (.dmark)  
25cc 32 65 ee			ld (debug_mark),a  
25cf 3a de 25			ld a, (.dmark+1)  
25d2 32 66 ee			ld (debug_mark+1),a  
25d5 3a df 25			ld a, (.dmark+2)  
25d8 32 67 ee			ld (debug_mark+2),a  
25db 18 03			jr .pastdmark  
25dd ..			.dmark: db "2SW"  
25e0 f1			.pastdmark: pop af  
25e1			endm  
# End of macro DMARK
25e1					CALLMONITOR 
25e1 cd 6f ee			call debug_vector  
25e4				endm  
# End of macro CALLMONITOR
25e4				endif 
25e4			; TODO Use os stack swap memory 
25e4			 
25e4				FORTH_DSP_PTR 0     ; TOS    w4 
25e4 2a e8 e9			ld hl,(cli_data_sp) 
25e7 11 00 00			ld de, 0 * 3 
25ea ed 52			sbc hl, de 
25ec				endm 
# End of macro FORTH_DSP_PTR
25ec cd cc 1e			call hltostack1 
25ef			  
25ef				FORTH_DSP_PTR 1     ; TOS    w3 
25ef 2a e8 e9			ld hl,(cli_data_sp) 
25f2 11 03 00			ld de, 1 * 3 
25f5 ed 52			sbc hl, de 
25f7				endm 
# End of macro FORTH_DSP_PTR
25f7 cd d2 1e			call hltostack2 
25fa			 
25fa			 
25fa			 
25fa				FORTH_DSP_PTR 2     ; TOS    w2 
25fa 2a e8 e9			ld hl,(cli_data_sp) 
25fd 11 06 00			ld de, 2 * 3 
2600 ed 52			sbc hl, de 
2602				endm 
# End of macro FORTH_DSP_PTR
2602 cd d8 1e			call hltostack3 
2605			 
2605				FORTH_DSP_PTR 3     ; TOS   w1 
2605 2a e8 e9			ld hl,(cli_data_sp) 
2608 11 09 00			ld de, 3 * 3 
260b ed 52			sbc hl, de 
260d				endm 
# End of macro FORTH_DSP_PTR
260d cd de 1e			call hltostack4 
2610			 
2610			 
2610			 
2610			 
2610				FORTH_DSP_PTR 0     ; TOS 
2610 2a e8 e9			ld hl,(cli_data_sp) 
2613 11 00 00			ld de, 0 * 3 
2616 ed 52			sbc hl, de 
2618				endm 
# End of macro FORTH_DSP_PTR
2618 cd f0 1e			call hlfromstack3 
261b			 
261b				FORTH_DSP_PTR 1     ; TOS 
261b 2a e8 e9			ld hl,(cli_data_sp) 
261e 11 03 00			ld de, 1 * 3 
2621 ed 52			sbc hl, de 
2623				endm 
# End of macro FORTH_DSP_PTR
2623 cd f6 1e			call hlfromstack4 
2626			 
2626			 
2626			 
2626				FORTH_DSP_PTR 2     ; TOS 
2626 2a e8 e9			ld hl,(cli_data_sp) 
2629 11 06 00			ld de, 2 * 3 
262c ed 52			sbc hl, de 
262e				endm 
# End of macro FORTH_DSP_PTR
262e cd e4 1e			call hlfromstack1 
2631			 
2631				FORTH_DSP_PTR 3     ; TOS 
2631 2a e8 e9			ld hl,(cli_data_sp) 
2634 11 09 00			ld de, 3 * 3 
2637 ed 52			sbc hl, de 
2639				endm 
# End of macro FORTH_DSP_PTR
2639 cd ea 1e			call hlfromstack2 
263c			 
263c				NEXTW 
263c c3 80 1f			jp macro_next 
263f				endm 
# End of macro NEXTW
263f			.AT: 
263f			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
263f 1f				db WORD_SYS_CORE+OPCODE_AT             
2640 71 26			dw .CAT            
2642 02				db 1 + 1 
2643 .. 00			db "@",0              
2645				endm 
# End of macro CWHEAD
2645			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2645			 
2645				if DEBUG_FORTH_WORDS_KEY 
2645					DMARK "AT." 
2645 f5				push af  
2646 3a 5a 26			ld a, (.dmark)  
2649 32 65 ee			ld (debug_mark),a  
264c 3a 5b 26			ld a, (.dmark+1)  
264f 32 66 ee			ld (debug_mark+1),a  
2652 3a 5c 26			ld a, (.dmark+2)  
2655 32 67 ee			ld (debug_mark+2),a  
2658 18 03			jr .pastdmark  
265a ..			.dmark: db "AT."  
265d f1			.pastdmark: pop af  
265e			endm  
# End of macro DMARK
265e					CALLMONITOR 
265e cd 6f ee			call debug_vector  
2661				endm  
# End of macro CALLMONITOR
2661				endif 
2661			.getbyteat:	 
2661				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2661 cd 95 1d			call macro_dsp_valuehl 
2664				endm 
# End of macro FORTH_DSP_VALUEHL
2664				 
2664			;		push hl 
2664			 
2664				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2664 cd 4d 1e			call macro_forth_dsp_pop 
2667				endm 
# End of macro FORTH_DSP_POP
2667			 
2667			;		pop hl 
2667			 
2667 7e				ld a, (hl) 
2668			 
2668 6f				ld l, a 
2669 26 00			ld h, 0 
266b cd 90 1b			call forth_push_numhl 
266e			 
266e				NEXTW 
266e c3 80 1f			jp macro_next 
2671				endm 
# End of macro NEXTW
2671			.CAT: 
2671			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2671 20				db WORD_SYS_CORE+OPCODE_CAT             
2672 9a 26			dw .BANG            
2674 03				db 2 + 1 
2675 .. 00			db "C@",0              
2678				endm 
# End of macro CWHEAD
2678			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2678				if DEBUG_FORTH_WORDS_KEY 
2678					DMARK "CAA" 
2678 f5				push af  
2679 3a 8d 26			ld a, (.dmark)  
267c 32 65 ee			ld (debug_mark),a  
267f 3a 8e 26			ld a, (.dmark+1)  
2682 32 66 ee			ld (debug_mark+1),a  
2685 3a 8f 26			ld a, (.dmark+2)  
2688 32 67 ee			ld (debug_mark+2),a  
268b 18 03			jr .pastdmark  
268d ..			.dmark: db "CAA"  
2690 f1			.pastdmark: pop af  
2691			endm  
# End of macro DMARK
2691					CALLMONITOR 
2691 cd 6f ee			call debug_vector  
2694				endm  
# End of macro CALLMONITOR
2694				endif 
2694 c3 61 26			jp .getbyteat 
2697				NEXTW 
2697 c3 80 1f			jp macro_next 
269a				endm 
# End of macro NEXTW
269a			.BANG: 
269a			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
269a 21				db WORD_SYS_CORE+OPCODE_BANG             
269b d0 26			dw .CBANG            
269d 02				db 1 + 1 
269e .. 00			db "!",0              
26a0				endm 
# End of macro CWHEAD
26a0			; | ! ( x w -- ) Store x at address w      | DONE 
26a0				if DEBUG_FORTH_WORDS_KEY 
26a0					DMARK "BNG" 
26a0 f5				push af  
26a1 3a b5 26			ld a, (.dmark)  
26a4 32 65 ee			ld (debug_mark),a  
26a7 3a b6 26			ld a, (.dmark+1)  
26aa 32 66 ee			ld (debug_mark+1),a  
26ad 3a b7 26			ld a, (.dmark+2)  
26b0 32 67 ee			ld (debug_mark+2),a  
26b3 18 03			jr .pastdmark  
26b5 ..			.dmark: db "BNG"  
26b8 f1			.pastdmark: pop af  
26b9			endm  
# End of macro DMARK
26b9					CALLMONITOR 
26b9 cd 6f ee			call debug_vector  
26bc				endm  
# End of macro CALLMONITOR
26bc				endif 
26bc			 
26bc			.storebyteat:		 
26bc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bc cd 95 1d			call macro_dsp_valuehl 
26bf				endm 
# End of macro FORTH_DSP_VALUEHL
26bf				 
26bf e5				push hl 
26c0			 
26c0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c0 cd 4d 1e			call macro_forth_dsp_pop 
26c3				endm 
# End of macro FORTH_DSP_POP
26c3			 
26c3				; get byte to poke 
26c3			 
26c3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c3 cd 95 1d			call macro_dsp_valuehl 
26c6				endm 
# End of macro FORTH_DSP_VALUEHL
26c6 e5				push hl 
26c7			 
26c7			 
26c7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c7 cd 4d 1e			call macro_forth_dsp_pop 
26ca				endm 
# End of macro FORTH_DSP_POP
26ca			 
26ca			 
26ca d1				pop de 
26cb e1				pop hl 
26cc			 
26cc 73				ld (hl),e 
26cd			 
26cd			 
26cd				NEXTW 
26cd c3 80 1f			jp macro_next 
26d0				endm 
# End of macro NEXTW
26d0			.CBANG: 
26d0			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
26d0 22				db WORD_SYS_CORE+OPCODE_CBANG             
26d1 f9 26			dw .SCALL            
26d3 03				db 2 + 1 
26d4 .. 00			db "C!",0              
26d7				endm 
# End of macro CWHEAD
26d7			; | C!  ( x w -- ) Store x at address w  | DONE 
26d7				if DEBUG_FORTH_WORDS_KEY 
26d7					DMARK "CBA" 
26d7 f5				push af  
26d8 3a ec 26			ld a, (.dmark)  
26db 32 65 ee			ld (debug_mark),a  
26de 3a ed 26			ld a, (.dmark+1)  
26e1 32 66 ee			ld (debug_mark+1),a  
26e4 3a ee 26			ld a, (.dmark+2)  
26e7 32 67 ee			ld (debug_mark+2),a  
26ea 18 03			jr .pastdmark  
26ec ..			.dmark: db "CBA"  
26ef f1			.pastdmark: pop af  
26f0			endm  
# End of macro DMARK
26f0					CALLMONITOR 
26f0 cd 6f ee			call debug_vector  
26f3				endm  
# End of macro CALLMONITOR
26f3				endif 
26f3 c3 bc 26			jp .storebyteat 
26f6				NEXTW 
26f6 c3 80 1f			jp macro_next 
26f9				endm 
# End of macro NEXTW
26f9			.SCALL: 
26f9			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26f9 23				db WORD_SYS_CORE+OPCODE_SCALL             
26fa 2d 27			dw .DEPTH            
26fc 05				db 4 + 1 
26fd .. 00			db "CALL",0              
2702				endm 
# End of macro CWHEAD
2702			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2702				if DEBUG_FORTH_WORDS_KEY 
2702					DMARK "CLL" 
2702 f5				push af  
2703 3a 17 27			ld a, (.dmark)  
2706 32 65 ee			ld (debug_mark),a  
2709 3a 18 27			ld a, (.dmark+1)  
270c 32 66 ee			ld (debug_mark+1),a  
270f 3a 19 27			ld a, (.dmark+2)  
2712 32 67 ee			ld (debug_mark+2),a  
2715 18 03			jr .pastdmark  
2717 ..			.dmark: db "CLL"  
271a f1			.pastdmark: pop af  
271b			endm  
# End of macro DMARK
271b					CALLMONITOR 
271b cd 6f ee			call debug_vector  
271e				endm  
# End of macro CALLMONITOR
271e				endif 
271e			 
271e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
271e cd 95 1d			call macro_dsp_valuehl 
2721				endm 
# End of macro FORTH_DSP_VALUEHL
2721			 
2721			;		push hl 
2721			 
2721				; destroy value TOS 
2721			 
2721				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2721 cd 4d 1e			call macro_forth_dsp_pop 
2724				endm 
# End of macro FORTH_DSP_POP
2724			 
2724					 
2724			;		pop hl 
2724			 
2724				; how to do a call with hl???? save SP? 
2724 cd 24 1f			call forth_call_hl 
2727			 
2727			 
2727				; TODO push value back onto stack for another op etc 
2727			 
2727 cd 90 1b			call forth_push_numhl 
272a				NEXTW 
272a c3 80 1f			jp macro_next 
272d				endm 
# End of macro NEXTW
272d			.DEPTH: 
272d			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
272d 24				db WORD_SYS_CORE+OPCODE_DEPTH             
272e 6a 27			dw .OVER            
2730 06				db 5 + 1 
2731 .. 00			db "DEPTH",0              
2737				endm 
# End of macro CWHEAD
2737			; | DEPTH ( -- u ) Push count of stack | DONE 
2737				; take current TOS and remove from base value div by two to get count 
2737				if DEBUG_FORTH_WORDS_KEY 
2737					DMARK "DEP" 
2737 f5				push af  
2738 3a 4c 27			ld a, (.dmark)  
273b 32 65 ee			ld (debug_mark),a  
273e 3a 4d 27			ld a, (.dmark+1)  
2741 32 66 ee			ld (debug_mark+1),a  
2744 3a 4e 27			ld a, (.dmark+2)  
2747 32 67 ee			ld (debug_mark+2),a  
274a 18 03			jr .pastdmark  
274c ..			.dmark: db "DEP"  
274f f1			.pastdmark: pop af  
2750			endm  
# End of macro DMARK
2750					CALLMONITOR 
2750 cd 6f ee			call debug_vector  
2753				endm  
# End of macro CALLMONITOR
2753				endif 
2753			 
2753			 
2753 2a e8 e9		ld hl, (cli_data_sp) 
2756 11 22 e8		ld de, cli_data_stack 
2759 ed 52		sbc hl,de 
275b			 
275b			; div by size of stack item 
275b			 
275b 5d			ld e,l 
275c 0e 03		ld c, 3 
275e cd 85 0d		call Div8 
2761			 
2761 6f			ld l,a 
2762 26 00		ld h,0 
2764			 
2764			;srl h 
2764			;rr l 
2764			 
2764 cd 90 1b			call forth_push_numhl 
2767				NEXTW 
2767 c3 80 1f			jp macro_next 
276a				endm 
# End of macro NEXTW
276a			.OVER: 
276a			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
276a 42				db WORD_SYS_CORE+46             
276b b1 27			dw .PAUSE            
276d 05				db 4 + 1 
276e .. 00			db "OVER",0              
2773				endm 
# End of macro CWHEAD
2773			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2773			; | | If the copied item is a string it is properly duplicated allowing for a safe release after use.  
2773				if DEBUG_FORTH_WORDS_KEY 
2773					DMARK "OVR" 
2773 f5				push af  
2774 3a 88 27			ld a, (.dmark)  
2777 32 65 ee			ld (debug_mark),a  
277a 3a 89 27			ld a, (.dmark+1)  
277d 32 66 ee			ld (debug_mark+1),a  
2780 3a 8a 27			ld a, (.dmark+2)  
2783 32 67 ee			ld (debug_mark+2),a  
2786 18 03			jr .pastdmark  
2788 ..			.dmark: db "OVR"  
278b f1			.pastdmark: pop af  
278c			endm  
# End of macro DMARK
278c					CALLMONITOR 
278c cd 6f ee			call debug_vector  
278f				endm  
# End of macro CALLMONITOR
278f				endif 
278f			 
278f			; TODO Use os stack swap memory 
278f			 
278f				; work out what type we are looking at 
278f			 
278f				FORTH_DSP_PTR 1 
278f 2a e8 e9			ld hl,(cli_data_sp) 
2792 11 03 00			ld de, 1 * 3 
2795 ed 52			sbc hl, de 
2797				endm 
# End of macro FORTH_DSP_PTR
2797			 
2797 7e				ld a, (hl) 
2798				 
2798 f5				push af 
2799				; whatever the type lets get the pointer or word 
2799 23				inc hl 
279a			;; 
279a			 
279a				; type check now to decide on how to push  
279a			 
279a cd 02 1f			call loadwordinhl 
279d f1				pop af 
279e fe 01			cp DS_TYPE_STR 
27a0 28 06			jr z, .ovstr 
27a2			 
27a2				; we have a numeric so load the word and push 
27a2			;	ld e, (hl) 
27a2			;	inc hl 
27a2			;	ld d, (hl) 
27a2			;	ex de, hl 
27a2 cd 90 1b			call forth_push_numhl 
27a5				NEXTW 
27a5 c3 80 1f			jp macro_next 
27a8				endm 
# End of macro NEXTW
27a8			 
27a8			.ovstr: 
27a8				; ok, a string so get the pointer and push as a string 
27a8			 
27a8			;	call loadwordinhl 
27a8 cd fe 1b			call forth_push_str 
27ab				NEXTW 
27ab c3 80 1f			jp macro_next 
27ae				endm 
# End of macro NEXTW
27ae			 
27ae			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ae			;	push hl    ; n2 
27ae			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ae			; 
27ae			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27ae			;	push hl    ; n1 
27ae			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ae			; 
27ae			;	pop de     ; n1 
27ae			;	pop hl     ; n2 
27ae			; 
27ae			;	push de 
27ae			;	push hl 
27ae			;	push de 
27ae			 
27ae				; push back  
27ae			 
27ae			;	pop hl 
27ae			;	call forth_push_numhl 
27ae			;	pop hl 
27ae			;	call forth_push_numhl 
27ae			;	pop hl 
27ae			;	call forth_push_numhl 
27ae				NEXTW 
27ae c3 80 1f			jp macro_next 
27b1				endm 
# End of macro NEXTW
27b1			 
27b1			.PAUSE: 
27b1			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
27b1 43				db WORD_SYS_CORE+47             
27b2 e6 27			dw .PAUSES            
27b4 08				db 7 + 1 
27b5 .. 00			db "PAUSEMS",0              
27bd				endm 
# End of macro CWHEAD
27bd			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
27bd				if DEBUG_FORTH_WORDS_KEY 
27bd					DMARK "PMS" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 65 ee			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 66 ee			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 67 ee			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db "PMS"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6					CALLMONITOR 
27d6 cd 6f ee			call debug_vector  
27d9				endm  
# End of macro CALLMONITOR
27d9				endif 
27d9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27d9 cd 95 1d			call macro_dsp_valuehl 
27dc				endm 
# End of macro FORTH_DSP_VALUEHL
27dc			;		push hl    ; n2 
27dc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27dc cd 4d 1e			call macro_forth_dsp_pop 
27df				endm 
# End of macro FORTH_DSP_POP
27df			;		pop hl 
27df			 
27df 7d				ld a, l 
27e0 cd e5 0a			call aDelayInMS 
27e3			       NEXTW 
27e3 c3 80 1f			jp macro_next 
27e6				endm 
# End of macro NEXTW
27e6			.PAUSES:  
27e6			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
27e6 44				db WORD_SYS_CORE+48             
27e7 55 28			dw .ROT            
27e9 06				db 5 + 1 
27ea .. 00			db "PAUSE",0              
27f0				endm 
# End of macro CWHEAD
27f0			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27f0				if DEBUG_FORTH_WORDS_KEY 
27f0					DMARK "PAU" 
27f0 f5				push af  
27f1 3a 05 28			ld a, (.dmark)  
27f4 32 65 ee			ld (debug_mark),a  
27f7 3a 06 28			ld a, (.dmark+1)  
27fa 32 66 ee			ld (debug_mark+1),a  
27fd 3a 07 28			ld a, (.dmark+2)  
2800 32 67 ee			ld (debug_mark+2),a  
2803 18 03			jr .pastdmark  
2805 ..			.dmark: db "PAU"  
2808 f1			.pastdmark: pop af  
2809			endm  
# End of macro DMARK
2809					CALLMONITOR 
2809 cd 6f ee			call debug_vector  
280c				endm  
# End of macro CALLMONITOR
280c				endif 
280c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
280c cd 95 1d			call macro_dsp_valuehl 
280f				endm 
# End of macro FORTH_DSP_VALUEHL
280f			;		push hl    ; n2 
280f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
280f cd 4d 1e			call macro_forth_dsp_pop 
2812				endm 
# End of macro FORTH_DSP_POP
2812			;		pop hl 
2812 45				ld b, l 
2813				if DEBUG_FORTH_WORDS 
2813					DMARK "PAU" 
2813 f5				push af  
2814 3a 28 28			ld a, (.dmark)  
2817 32 65 ee			ld (debug_mark),a  
281a 3a 29 28			ld a, (.dmark+1)  
281d 32 66 ee			ld (debug_mark+1),a  
2820 3a 2a 28			ld a, (.dmark+2)  
2823 32 67 ee			ld (debug_mark+2),a  
2826 18 03			jr .pastdmark  
2828 ..			.dmark: db "PAU"  
282b f1			.pastdmark: pop af  
282c			endm  
# End of macro DMARK
282c					CALLMONITOR 
282c cd 6f ee			call debug_vector  
282f				endm  
# End of macro CALLMONITOR
282f				endif 
282f c5			.pauses1:	push bc 
2830 cd 00 0b			call delay1s 
2833 c1				pop bc 
2834				if DEBUG_FORTH_WORDS 
2834					DMARK "PA1" 
2834 f5				push af  
2835 3a 49 28			ld a, (.dmark)  
2838 32 65 ee			ld (debug_mark),a  
283b 3a 4a 28			ld a, (.dmark+1)  
283e 32 66 ee			ld (debug_mark+1),a  
2841 3a 4b 28			ld a, (.dmark+2)  
2844 32 67 ee			ld (debug_mark+2),a  
2847 18 03			jr .pastdmark  
2849 ..			.dmark: db "PA1"  
284c f1			.pastdmark: pop af  
284d			endm  
# End of macro DMARK
284d					CALLMONITOR 
284d cd 6f ee			call debug_vector  
2850				endm  
# End of macro CALLMONITOR
2850				endif 
2850 10 dd			djnz .pauses1 
2852			 
2852			       NEXTW 
2852 c3 80 1f			jp macro_next 
2855				endm 
# End of macro NEXTW
2855			.ROT: 
2855			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2855 45				db WORD_SYS_CORE+49             
2856 be 28			dw .UWORDS            
2858 04				db 3 + 1 
2859 .. 00			db "ROT",0              
285d				endm 
# End of macro CWHEAD
285d			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
285d				if DEBUG_FORTH_WORDS_KEY 
285d					DMARK "ROT" 
285d f5				push af  
285e 3a 72 28			ld a, (.dmark)  
2861 32 65 ee			ld (debug_mark),a  
2864 3a 73 28			ld a, (.dmark+1)  
2867 32 66 ee			ld (debug_mark+1),a  
286a 3a 74 28			ld a, (.dmark+2)  
286d 32 67 ee			ld (debug_mark+2),a  
2870 18 03			jr .pastdmark  
2872 ..			.dmark: db "ROT"  
2875 f1			.pastdmark: pop af  
2876			endm  
# End of macro DMARK
2876					CALLMONITOR 
2876 cd 6f ee			call debug_vector  
2879				endm  
# End of macro CALLMONITOR
2879				endif 
2879			 
2879			; DONE Use os stack swap memory 
2879			 
2879				FORTH_DSP_PTR 0     ; u3 
2879 2a e8 e9			ld hl,(cli_data_sp) 
287c 11 00 00			ld de, 0 * 3 
287f ed 52			sbc hl, de 
2881				endm 
# End of macro FORTH_DSP_PTR
2881 cd cc 1e			call hltostack1     
2884			  
2884				FORTH_DSP_PTR 1     ; u2 
2884 2a e8 e9			ld hl,(cli_data_sp) 
2887 11 03 00			ld de, 1 * 3 
288a ed 52			sbc hl, de 
288c				endm 
# End of macro FORTH_DSP_PTR
288c cd d2 1e			call hltostack2      
288f			 
288f				FORTH_DSP_PTR 2     ; u1 
288f 2a e8 e9			ld hl,(cli_data_sp) 
2892 11 06 00			ld de, 2 * 3 
2895 ed 52			sbc hl, de 
2897				endm 
# End of macro FORTH_DSP_PTR
2897 cd d8 1e			call hltostack3 
289a			 
289a			 
289a				FORTH_DSP_PTR 0     ;  
289a 2a e8 e9			ld hl,(cli_data_sp) 
289d 11 00 00			ld de, 0 * 3 
28a0 ed 52			sbc hl, de 
28a2				endm 
# End of macro FORTH_DSP_PTR
28a2 cd f0 1e			call hlfromstack3 
28a5			 
28a5				FORTH_DSP_PTR 1     ; TOS 
28a5 2a e8 e9			ld hl,(cli_data_sp) 
28a8 11 03 00			ld de, 1 * 3 
28ab ed 52			sbc hl, de 
28ad				endm 
# End of macro FORTH_DSP_PTR
28ad cd e4 1e			call hlfromstack1 
28b0			 
28b0				FORTH_DSP_PTR 2     ; TOS 
28b0 2a e8 e9			ld hl,(cli_data_sp) 
28b3 11 06 00			ld de, 2 * 3 
28b6 ed 52			sbc hl, de 
28b8				endm 
# End of macro FORTH_DSP_PTR
28b8 cd ea 1e			call hlfromstack2 
28bb			 
28bb			 
28bb			;	FORTH_DSP_VALUEHL 
28bb			;	push hl    ; u3  
28bb			; 
28bb			;	FORTH_DSP_POP 
28bb			; 
28bb			;	FORTH_DSP_VALUEHL 
28bb			;	push hl     ; u2 
28bb			; 
28bb			;	FORTH_DSP_POP 
28bb			; 
28bb			;	FORTH_DSP_VALUEHL 
28bb			;	push hl     ; u1 
28bb			; 
28bb			;	FORTH_DSP_POP 
28bb			; 
28bb			;	pop bc      ; u1 
28bb			;	pop hl      ; u2 
28bb			;	pop de      ; u3 
28bb			; 
28bb			; 
28bb			;	push bc 
28bb			;	push de 
28bb			;	push hl 
28bb			; 
28bb			; 
28bb			;	pop hl 
28bb			;	call forth_push_numhl 
28bb			; 
28bb			;	pop hl 
28bb			;	call forth_push_numhl 
28bb			; 
28bb			;	pop hl 
28bb			;	call forth_push_numhl 
28bb				 
28bb			 
28bb			 
28bb			 
28bb			 
28bb			 
28bb			       NEXTW 
28bb c3 80 1f			jp macro_next 
28be				endm 
# End of macro NEXTW
28be			 
28be			.UWORDS: 
28be			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28be 50				db WORD_SYS_CORE+60             
28bf 80 29			dw .BP            
28c1 07				db 6 + 1 
28c2 .. 00			db "UWORDS",0              
28c9				endm 
# End of macro CWHEAD
28c9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
28c9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
28c9			; | | Following the count are the individual words. 
28c9			; | | 
28c9			; | | e.g. UWORDS 
28c9			; | | BOX DIRLIST 2 
28c9			; | |  
28c9			; | | Can be used to save the words to storage via: 
28c9			; | | UWORDS $01 DO $01 APPEND LOOP 
28c9			if DEBUG_FORTH_WORDS_KEY 
28c9				DMARK "UWR" 
28c9 f5				push af  
28ca 3a de 28			ld a, (.dmark)  
28cd 32 65 ee			ld (debug_mark),a  
28d0 3a df 28			ld a, (.dmark+1)  
28d3 32 66 ee			ld (debug_mark+1),a  
28d6 3a e0 28			ld a, (.dmark+2)  
28d9 32 67 ee			ld (debug_mark+2),a  
28dc 18 03			jr .pastdmark  
28de ..			.dmark: db "UWR"  
28e1 f1			.pastdmark: pop af  
28e2			endm  
# End of macro DMARK
28e2				CALLMONITOR 
28e2 cd 6f ee			call debug_vector  
28e5				endm  
# End of macro CALLMONITOR
28e5			endif 
28e5 21 22 64			ld hl, baseram 
28e8				;ld hl, baseusermem 
28e8 01 00 00			ld bc, 0    ; start a counter 
28eb			 
28eb			; skip dict stub 
28eb			 
28eb cd bd 20			call forth_tok_next 
28ee			 
28ee			 
28ee			; while we have words to look for 
28ee			 
28ee 7e			.douscan:	ld a, (hl)      
28ef			if DEBUG_FORTH_WORDS 
28ef				DMARK "UWs" 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 65 ee			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 66 ee			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 67 ee			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "UWs"  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908				CALLMONITOR 
2908 cd 6f ee			call debug_vector  
290b				endm  
# End of macro CALLMONITOR
290b			endif 
290b fe 00			cp WORD_SYS_END 
290d 28 4d			jr z, .udone 
290f fe 01			cp WORD_SYS_UWORD 
2911 20 44			jr nz, .nuword 
2913			 
2913			if DEBUG_FORTH_WORDS 
2913				DMARK "UWu" 
2913 f5				push af  
2914 3a 28 29			ld a, (.dmark)  
2917 32 65 ee			ld (debug_mark),a  
291a 3a 29 29			ld a, (.dmark+1)  
291d 32 66 ee			ld (debug_mark+1),a  
2920 3a 2a 29			ld a, (.dmark+2)  
2923 32 67 ee			ld (debug_mark+2),a  
2926 18 03			jr .pastdmark  
2928 ..			.dmark: db "UWu"  
292b f1			.pastdmark: pop af  
292c			endm  
# End of macro DMARK
292c				CALLMONITOR 
292c cd 6f ee			call debug_vector  
292f				endm  
# End of macro CALLMONITOR
292f			endif 
292f				; we have a uword so push its name to the stack 
292f			 
292f e5				push hl  ; save so we can move to next dict block 
2930			 
2930				; skip opcode 
2930 23				inc hl  
2931				; skip next ptr 
2931 23				inc hl  
2932 23				inc hl 
2933				; skip len 
2933 23				inc hl 
2934			if DEBUG_FORTH_WORDS 
2934				DMARK "UWt" 
2934 f5				push af  
2935 3a 49 29			ld a, (.dmark)  
2938 32 65 ee			ld (debug_mark),a  
293b 3a 4a 29			ld a, (.dmark+1)  
293e 32 66 ee			ld (debug_mark+1),a  
2941 3a 4b 29			ld a, (.dmark+2)  
2944 32 67 ee			ld (debug_mark+2),a  
2947 18 03			jr .pastdmark  
2949 ..			.dmark: db "UWt"  
294c f1			.pastdmark: pop af  
294d			endm  
# End of macro DMARK
294d				CALLMONITOR 
294d cd 6f ee			call debug_vector  
2950				endm  
# End of macro CALLMONITOR
2950			endif 
2950 03				inc bc 
2951			 
2951 c5				push bc 
2952 cd fe 1b			call forth_push_str 
2955 c1				pop bc 
2956			 
2956 e1				pop hl 	 
2957			 
2957 cd bd 20		.nuword:	call forth_tok_next 
295a 18 92			jr .douscan  
295c			 
295c			.udone:		 ; push count of uwords found 
295c c5				push bc 
295d e1				pop hl 
295e			 
295e			if DEBUG_FORTH_WORDS 
295e				DMARK "UWc" 
295e f5				push af  
295f 3a 73 29			ld a, (.dmark)  
2962 32 65 ee			ld (debug_mark),a  
2965 3a 74 29			ld a, (.dmark+1)  
2968 32 66 ee			ld (debug_mark+1),a  
296b 3a 75 29			ld a, (.dmark+2)  
296e 32 67 ee			ld (debug_mark+2),a  
2971 18 03			jr .pastdmark  
2973 ..			.dmark: db "UWc"  
2976 f1			.pastdmark: pop af  
2977			endm  
# End of macro DMARK
2977				CALLMONITOR 
2977 cd 6f ee			call debug_vector  
297a				endm  
# End of macro CALLMONITOR
297a			endif 
297a cd 90 1b			call forth_push_numhl 
297d			 
297d			 
297d			       NEXTW 
297d c3 80 1f			jp macro_next 
2980				endm 
# End of macro NEXTW
2980			 
2980			.BP: 
2980			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2980 54				db WORD_SYS_CORE+64             
2981 ba 29			dw .MONITOR            
2983 03				db 2 + 1 
2984 .. 00			db "BP",0              
2987				endm 
# End of macro CWHEAD
2987			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2987			; | | $00 Will enable the break points within specific code paths 
2987			; | | $01 Will disable break points 
2987			; | |  
2987			; | | By default break points are off. Either the above can be used to enable them 
2987			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2987			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2987			; | | can disable break points. Exiting will then continue boot process. 
2987				; get byte count 
2987				if DEBUG_FORTH_WORDS_KEY 
2987					DMARK "BP." 
2987 f5				push af  
2988 3a 9c 29			ld a, (.dmark)  
298b 32 65 ee			ld (debug_mark),a  
298e 3a 9d 29			ld a, (.dmark+1)  
2991 32 66 ee			ld (debug_mark+1),a  
2994 3a 9e 29			ld a, (.dmark+2)  
2997 32 67 ee			ld (debug_mark+2),a  
299a 18 03			jr .pastdmark  
299c ..			.dmark: db "BP."  
299f f1			.pastdmark: pop af  
29a0			endm  
# End of macro DMARK
29a0					CALLMONITOR 
29a0 cd 6f ee			call debug_vector  
29a3				endm  
# End of macro CALLMONITOR
29a3				endif 
29a3			 
29a3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29a3 cd 95 1d			call macro_dsp_valuehl 
29a6				endm 
# End of macro FORTH_DSP_VALUEHL
29a6			 
29a6			;		push hl 
29a6			 
29a6				; destroy value TOS 
29a6			 
29a6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29a6 cd 4d 1e			call macro_forth_dsp_pop 
29a9				endm 
# End of macro FORTH_DSP_POP
29a9			 
29a9			;		pop hl 
29a9			 
29a9 3e 00			ld a,0 
29ab bd				cp l 
29ac 28 06			jr z, .bpset 
29ae			;		ld a, '*' 
29ae cd 0b 15			call bp_off 
29b1				NEXTW 
29b1 c3 80 1f			jp macro_next 
29b4				endm 
# End of macro NEXTW
29b4			 
29b4			.bpset:	 
29b4				;	ld (os_view_disable), a 
29b4 cd ff 14			call bp_on 
29b7			 
29b7			 
29b7				NEXTW 
29b7 c3 80 1f			jp macro_next 
29ba				endm 
# End of macro NEXTW
29ba			 
29ba			 
29ba			.MONITOR: 
29ba			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
29ba 55				db WORD_SYS_CORE+65             
29bb eb 29			dw .MALLOC            
29bd 08				db 7 + 1 
29be .. 00			db "MONITOR",0              
29c6				endm 
# End of macro CWHEAD
29c6			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
29c6			; | | At start the current various registers will be displayed with contents. 
29c6			; | | Top right corner will show the most recent debug marker seen. 
29c6			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
29c6			; | | and the return stack pointer (RSP). 
29c6			; | | Pressing: 
29c6			; | |    1 - Initial screen 
29c6			; | |    2 - Display a data dump of HL 
29c6			; | |    3 - Display a data dump of DE 
29c6			; | |    4 - Display a data dump of BC 
29c6			; | |    5 - Display a data dump of HL 
29c6			; | |    6 - Display a data dump of DSP 
29c6			; | |    7 - Display a data dump of RSP 
29c6			; | |    8 - Display a data dump of what is at DSP 
29c6			; | |    9 - Display a data dump of what is at RSP 
29c6			; | |    0 - Exit monitor and continue running. This will also enable break points 
29c6			; | |    * - Disable break points 
29c6			; | |    # - Enter traditional monitor mode 
29c6			; | | 
29c6			; | | Monitor Mode 
29c6			; | | ------------ 
29c6			; | | A prompt of '>' will be shown for various commands: 
29c6			; | |    D xxxx - Display a data dump starting from hex address xxxx 
29c6			; | |    C - Continue display a data dump from the last set address 
29c6			; | |    M xxxx - Set start of memory edit at address xx 
29c6			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
29c6			; | |    G xxxx - Exec code at specific address 
29c6			; | |    Q - Return to previous 
29c6				if DEBUG_FORTH_WORDS_KEY 
29c6					DMARK "MON" 
29c6 f5				push af  
29c7 3a db 29			ld a, (.dmark)  
29ca 32 65 ee			ld (debug_mark),a  
29cd 3a dc 29			ld a, (.dmark+1)  
29d0 32 66 ee			ld (debug_mark+1),a  
29d3 3a dd 29			ld a, (.dmark+2)  
29d6 32 67 ee			ld (debug_mark+2),a  
29d9 18 03			jr .pastdmark  
29db ..			.dmark: db "MON"  
29de f1			.pastdmark: pop af  
29df			endm  
# End of macro DMARK
29df					CALLMONITOR 
29df cd 6f ee			call debug_vector  
29e2				endm  
# End of macro CALLMONITOR
29e2				endif 
29e2			;		ld a, 0 
29e2			;		ld (os_view_disable), a 
29e2 cd ff 14			call bp_on 
29e5			 
29e5				CALLMONITOR 
29e5 cd 6f ee			call debug_vector  
29e8				endm  
# End of macro CALLMONITOR
29e8			 
29e8			;	call monitor 
29e8			 
29e8				NEXTW 
29e8 c3 80 1f			jp macro_next 
29eb				endm 
# End of macro NEXTW
29eb			 
29eb			 
29eb			.MALLOC: 
29eb			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29eb 56				db WORD_SYS_CORE+66             
29ec 14 2a			dw .MALLOC2            
29ee 06				db 5 + 1 
29ef .. 00			db "ALLOT",0              
29f5				endm 
# End of macro CWHEAD
29f5			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29f5				if DEBUG_FORTH_WORDS_KEY 
29f5					DMARK "ALL" 
29f5 f5				push af  
29f6 3a 0a 2a			ld a, (.dmark)  
29f9 32 65 ee			ld (debug_mark),a  
29fc 3a 0b 2a			ld a, (.dmark+1)  
29ff 32 66 ee			ld (debug_mark+1),a  
2a02 3a 0c 2a			ld a, (.dmark+2)  
2a05 32 67 ee			ld (debug_mark+2),a  
2a08 18 03			jr .pastdmark  
2a0a ..			.dmark: db "ALL"  
2a0d f1			.pastdmark: pop af  
2a0e			endm  
# End of macro DMARK
2a0e					CALLMONITOR 
2a0e cd 6f ee			call debug_vector  
2a11				endm  
# End of macro CALLMONITOR
2a11				endif 
2a11 c3 3b 2a			jp .mallocc 
2a14			.MALLOC2: 
2a14			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a14 56				db WORD_SYS_CORE+66             
2a15 52 2a			dw .FREE            
2a17 07				db 6 + 1 
2a18 .. 00			db "MALLOC",0              
2a1f				endm 
# End of macro CWHEAD
2a1f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a1f				; get byte count 
2a1f				if DEBUG_FORTH_WORDS_KEY 
2a1f					DMARK "MAL" 
2a1f f5				push af  
2a20 3a 34 2a			ld a, (.dmark)  
2a23 32 65 ee			ld (debug_mark),a  
2a26 3a 35 2a			ld a, (.dmark+1)  
2a29 32 66 ee			ld (debug_mark+1),a  
2a2c 3a 36 2a			ld a, (.dmark+2)  
2a2f 32 67 ee			ld (debug_mark+2),a  
2a32 18 03			jr .pastdmark  
2a34 ..			.dmark: db "MAL"  
2a37 f1			.pastdmark: pop af  
2a38			endm  
# End of macro DMARK
2a38					CALLMONITOR 
2a38 cd 6f ee			call debug_vector  
2a3b				endm  
# End of macro CALLMONITOR
2a3b				endif 
2a3b			.mallocc: 
2a3b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a3b cd 95 1d			call macro_dsp_valuehl 
2a3e				endm 
# End of macro FORTH_DSP_VALUEHL
2a3e			 
2a3e			;		push hl 
2a3e			 
2a3e				; destroy value TOS 
2a3e			 
2a3e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a3e cd 4d 1e			call macro_forth_dsp_pop 
2a41				endm 
# End of macro FORTH_DSP_POP
2a41			 
2a41			;		pop hl 
2a41 cd d0 11			call malloc 
2a44			if DEBUG_FORTH_MALLOC_GUARD 
2a44 f5				push af 
2a45 cd 1e 0e			call ishlzero 
2a48			;		ld a, l 
2a48			;		add h 
2a48			;		cp 0 
2a48 f1				pop af 
2a49				 
2a49 cc 78 52			call z,malloc_error 
2a4c			endif 
2a4c			 
2a4c cd 90 1b			call forth_push_numhl 
2a4f				NEXTW 
2a4f c3 80 1f			jp macro_next 
2a52				endm 
# End of macro NEXTW
2a52			 
2a52			.FREE: 
2a52			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2a52 57				db WORD_SYS_CORE+67             
2a53 83 2a			dw .UPTR            
2a55 05				db 4 + 1 
2a56 .. 00			db "FREE",0              
2a5b				endm 
# End of macro CWHEAD
2a5b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a5b				if DEBUG_FORTH_WORDS_KEY 
2a5b					DMARK "FRE" 
2a5b f5				push af  
2a5c 3a 70 2a			ld a, (.dmark)  
2a5f 32 65 ee			ld (debug_mark),a  
2a62 3a 71 2a			ld a, (.dmark+1)  
2a65 32 66 ee			ld (debug_mark+1),a  
2a68 3a 72 2a			ld a, (.dmark+2)  
2a6b 32 67 ee			ld (debug_mark+2),a  
2a6e 18 03			jr .pastdmark  
2a70 ..			.dmark: db "FRE"  
2a73 f1			.pastdmark: pop af  
2a74			endm  
# End of macro DMARK
2a74					CALLMONITOR 
2a74 cd 6f ee			call debug_vector  
2a77				endm  
# End of macro CALLMONITOR
2a77				endif 
2a77				; get address 
2a77			 
2a77				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a77 cd 95 1d			call macro_dsp_valuehl 
2a7a				endm 
# End of macro FORTH_DSP_VALUEHL
2a7a			 
2a7a			;		push hl 
2a7a			 
2a7a				; destroy value TOS 
2a7a			 
2a7a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a7a cd 4d 1e			call macro_forth_dsp_pop 
2a7d				endm 
# End of macro FORTH_DSP_POP
2a7d			 
2a7d			;		pop hl 
2a7d			if FORTH_ENABLE_MALLOCFREE 
2a7d cd 9a 12			call free 
2a80			endif 
2a80				NEXTW 
2a80 c3 80 1f			jp macro_next 
2a83				endm 
# End of macro NEXTW
2a83			.UPTR: 
2a83			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2a83 57				db WORD_SYS_CORE+67             
2a84 86 2b			dw .LIST            
2a86 05				db 4 + 1 
2a87 .. 00			db "UPTR",0              
2a8c				endm 
# End of macro CWHEAD
2a8c			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2a8c				if DEBUG_FORTH_WORDS_KEY 
2a8c					DMARK "UPT" 
2a8c f5				push af  
2a8d 3a a1 2a			ld a, (.dmark)  
2a90 32 65 ee			ld (debug_mark),a  
2a93 3a a2 2a			ld a, (.dmark+1)  
2a96 32 66 ee			ld (debug_mark+1),a  
2a99 3a a3 2a			ld a, (.dmark+2)  
2a9c 32 67 ee			ld (debug_mark+2),a  
2a9f 18 03			jr .pastdmark  
2aa1 ..			.dmark: db "UPT"  
2aa4 f1			.pastdmark: pop af  
2aa5			endm  
# End of macro DMARK
2aa5					CALLMONITOR 
2aa5 cd 6f ee			call debug_vector  
2aa8				endm  
# End of macro CALLMONITOR
2aa8				endif 
2aa8				FORTH_DSP_VALUEHL 
2aa8 cd 95 1d			call macro_dsp_valuehl 
2aab				endm 
# End of macro FORTH_DSP_VALUEHL
2aab			 
2aab e5				push hl 
2aac				FORTH_DSP_POP 
2aac cd 4d 1e			call macro_forth_dsp_pop 
2aaf				endm 
# End of macro FORTH_DSP_POP
2aaf c1				pop bc 
2ab0			 
2ab0			 
2ab0				; Get ptr to the word we need to look up 
2ab0			 
2ab0			;		FORTH_DSP_VALUEHL 
2ab0				;v5 FORTH_DSP_VALUE 
2ab0			; TODO type check 
2ab0			;		inc hl    ; Skip type check  
2ab0			;		push hl 
2ab0			;		ex de, hl    ; put into DE 
2ab0			 
2ab0			 
2ab0 21 22 64			ld hl, baseram 
2ab3				;ld hl, baseusermem 
2ab3			 
2ab3 e5			push hl   ; sacreifical push 
2ab4			 
2ab4			.uldouscanm: 
2ab4 e1			pop hl 
2ab5			.uldouscan: 
2ab5			if DEBUG_FORTH_WORDS 
2ab5				DMARK "LSs" 
2ab5 f5				push af  
2ab6 3a ca 2a			ld a, (.dmark)  
2ab9 32 65 ee			ld (debug_mark),a  
2abc 3a cb 2a			ld a, (.dmark+1)  
2abf 32 66 ee			ld (debug_mark+1),a  
2ac2 3a cc 2a			ld a, (.dmark+2)  
2ac5 32 67 ee			ld (debug_mark+2),a  
2ac8 18 03			jr .pastdmark  
2aca ..			.dmark: db "LSs"  
2acd f1			.pastdmark: pop af  
2ace			endm  
# End of macro DMARK
2ace				CALLMONITOR 
2ace cd 6f ee			call debug_vector  
2ad1				endm  
# End of macro CALLMONITOR
2ad1			endif 
2ad1			; skip dict stub 
2ad1 cd bd 20			call forth_tok_next 
2ad4			 
2ad4			 
2ad4			; while we have words to look for 
2ad4			 
2ad4 7e			ld a, (hl)      
2ad5			if DEBUG_FORTH_WORDS 
2ad5				DMARK "LSk" 
2ad5 f5				push af  
2ad6 3a ea 2a			ld a, (.dmark)  
2ad9 32 65 ee			ld (debug_mark),a  
2adc 3a eb 2a			ld a, (.dmark+1)  
2adf 32 66 ee			ld (debug_mark+1),a  
2ae2 3a ec 2a			ld a, (.dmark+2)  
2ae5 32 67 ee			ld (debug_mark+2),a  
2ae8 18 03			jr .pastdmark  
2aea ..			.dmark: db "LSk"  
2aed f1			.pastdmark: pop af  
2aee			endm  
# End of macro DMARK
2aee				CALLMONITOR 
2aee cd 6f ee			call debug_vector  
2af1				endm  
# End of macro CALLMONITOR
2af1			endif 
2af1				;cp WORD_SYS_END 
2af1				;jp z, .lunotfound 
2af1			 
2af1					; if we hit non uwords then gone too far 
2af1 fe 01				cp WORD_SYS_UWORD 
2af3 c2 80 2b				jp nz, .ulunotfound 
2af6			 
2af6				if DEBUG_FORTH_WORDS 
2af6					DMARK "LSu" 
2af6 f5				push af  
2af7 3a 0b 2b			ld a, (.dmark)  
2afa 32 65 ee			ld (debug_mark),a  
2afd 3a 0c 2b			ld a, (.dmark+1)  
2b00 32 66 ee			ld (debug_mark+1),a  
2b03 3a 0d 2b			ld a, (.dmark+2)  
2b06 32 67 ee			ld (debug_mark+2),a  
2b09 18 03			jr .pastdmark  
2b0b ..			.dmark: db "LSu"  
2b0e f1			.pastdmark: pop af  
2b0f			endm  
# End of macro DMARK
2b0f					CALLMONITOR 
2b0f cd 6f ee			call debug_vector  
2b12				endm  
# End of macro CALLMONITOR
2b12				endif 
2b12			 
2b12					; found a uword but is it the one we want... 
2b12			 
2b12 c5					push bc     ; uword to find is on bc 
2b13 d1					pop de 
2b14			 
2b14 e5					push hl  ; to save the ptr 
2b15			 
2b15					; skip opcode 
2b15 23					inc hl  
2b16					; skip next ptr 
2b16 23					inc hl  
2b17 23					inc hl 
2b18					; skip len 
2b18 23					inc hl 
2b19			 
2b19				if DEBUG_FORTH_WORDS 
2b19					DMARK "LSc" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 65 ee			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 66 ee			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 67 ee			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "LSc"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32					CALLMONITOR 
2b32 cd 6f ee			call debug_vector  
2b35				endm  
# End of macro CALLMONITOR
2b35				endif 
2b35			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2b35			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2b35			; Nope that has gone the other way. It needs to be exact not on first zero 
2b35			;		call strcmp 
2b35 c5					push bc 
2b36 cd a0 11				call StrictStrCmp 
2b39 c1					pop bc 
2b3a c2 b4 2a				jp nz, .uldouscanm 
2b3d				 
2b3d			 
2b3d			 
2b3d					; we have a uword so push its name to the stack 
2b3d			 
2b3d			;	   	push hl  ; save so we can move to next dict block 
2b3d e1			pop hl 
2b3e			 
2b3e				if DEBUG_FORTH_WORDS 
2b3e					DMARK "LSm" 
2b3e f5				push af  
2b3f 3a 53 2b			ld a, (.dmark)  
2b42 32 65 ee			ld (debug_mark),a  
2b45 3a 54 2b			ld a, (.dmark+1)  
2b48 32 66 ee			ld (debug_mark+1),a  
2b4b 3a 55 2b			ld a, (.dmark+2)  
2b4e 32 67 ee			ld (debug_mark+2),a  
2b51 18 03			jr .pastdmark  
2b53 ..			.dmark: db "LSm"  
2b56 f1			.pastdmark: pop af  
2b57			endm  
# End of macro DMARK
2b57					CALLMONITOR 
2b57 cd 6f ee			call debug_vector  
2b5a				endm  
# End of macro CALLMONITOR
2b5a				endif 
2b5a			 
2b5a					; skip opcode 
2b5a 23					inc hl  
2b5b					; skip next ptr 
2b5b 23					inc hl  
2b5c 23					inc hl 
2b5d					; skip len 
2b5d 7e					ld a, (hl)   ; save length to add 
2b5e				if DEBUG_FORTH_WORDS 
2b5e					DMARK "LS2" 
2b5e f5				push af  
2b5f 3a 73 2b			ld a, (.dmark)  
2b62 32 65 ee			ld (debug_mark),a  
2b65 3a 74 2b			ld a, (.dmark+1)  
2b68 32 66 ee			ld (debug_mark+1),a  
2b6b 3a 75 2b			ld a, (.dmark+2)  
2b6e 32 67 ee			ld (debug_mark+2),a  
2b71 18 03			jr .pastdmark  
2b73 ..			.dmark: db "LS2"  
2b76 f1			.pastdmark: pop af  
2b77			endm  
# End of macro DMARK
2b77					CALLMONITOR 
2b77 cd 6f ee			call debug_vector  
2b7a				endm  
# End of macro CALLMONITOR
2b7a				endif 
2b7a			 
2b7a				; skip zero term and other uword defs to position right at the exec code 
2b7a 06 04			ld b, 4 
2b7c 80				add a,b 
2b7d			 
2b7d cd f5 0d			call addatohl 
2b80					; save this location 
2b80				 
2b80			.ulunotfound: 
2b80 cd 90 1b			call forth_push_numhl 
2b83						 
2b83				NEXTW 
2b83 c3 80 1f			jp macro_next 
2b86				endm 
# End of macro NEXTW
2b86			.LIST: 
2b86			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b86 5c				db WORD_SYS_CORE+72             
2b87 82 2d			dw .FORGET            
2b89 05				db 4 + 1 
2b8a .. 00			db "LIST",0              
2b8f				endm 
# End of macro CWHEAD
2b8f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b8f			; | | The quoted word must be in upper case. 
2b8f			if DEBUG_FORTH_WORDS_KEY 
2b8f				DMARK "LST" 
2b8f f5				push af  
2b90 3a a4 2b			ld a, (.dmark)  
2b93 32 65 ee			ld (debug_mark),a  
2b96 3a a5 2b			ld a, (.dmark+1)  
2b99 32 66 ee			ld (debug_mark+1),a  
2b9c 3a a6 2b			ld a, (.dmark+2)  
2b9f 32 67 ee			ld (debug_mark+2),a  
2ba2 18 03			jr .pastdmark  
2ba4 ..			.dmark: db "LST"  
2ba7 f1			.pastdmark: pop af  
2ba8			endm  
# End of macro DMARK
2ba8				CALLMONITOR 
2ba8 cd 6f ee			call debug_vector  
2bab				endm  
# End of macro CALLMONITOR
2bab			endif 
2bab			 
2bab				FORTH_DSP_VALUEHL 
2bab cd 95 1d			call macro_dsp_valuehl 
2bae				endm 
# End of macro FORTH_DSP_VALUEHL
2bae			 
2bae e5				push hl 
2baf				FORTH_DSP_POP 
2baf cd 4d 1e			call macro_forth_dsp_pop 
2bb2				endm 
# End of macro FORTH_DSP_POP
2bb2 c1				pop bc 
2bb3			 
2bb3			; Start format of scratch string 
2bb3			 
2bb3 21 bb e2			ld hl, scratch 
2bb6			 
2bb6 3e 3a			ld a, ':' 
2bb8 77				ld (hl),a 
2bb9 23				inc hl 
2bba 3e 20			ld a, ' ' 
2bbc 77				ld (hl), a 
2bbd			 
2bbd				; Get ptr to the word we need to look up 
2bbd			 
2bbd			;		FORTH_DSP_VALUEHL 
2bbd				;v5 FORTH_DSP_VALUE 
2bbd			; TODO type check 
2bbd			;		inc hl    ; Skip type check  
2bbd			;		push hl 
2bbd			;		ex de, hl    ; put into DE 
2bbd			 
2bbd			 
2bbd 21 22 64			ld hl, baseram 
2bc0				;ld hl, baseusermem 
2bc0			 
2bc0 e5			push hl   ; sacreifical push 
2bc1			 
2bc1			.ldouscanm: 
2bc1 e1			pop hl 
2bc2			.ldouscan: 
2bc2			if DEBUG_FORTH_WORDS 
2bc2				DMARK "LSs" 
2bc2 f5				push af  
2bc3 3a d7 2b			ld a, (.dmark)  
2bc6 32 65 ee			ld (debug_mark),a  
2bc9 3a d8 2b			ld a, (.dmark+1)  
2bcc 32 66 ee			ld (debug_mark+1),a  
2bcf 3a d9 2b			ld a, (.dmark+2)  
2bd2 32 67 ee			ld (debug_mark+2),a  
2bd5 18 03			jr .pastdmark  
2bd7 ..			.dmark: db "LSs"  
2bda f1			.pastdmark: pop af  
2bdb			endm  
# End of macro DMARK
2bdb				CALLMONITOR 
2bdb cd 6f ee			call debug_vector  
2bde				endm  
# End of macro CALLMONITOR
2bde			endif 
2bde			; skip dict stub 
2bde cd bd 20			call forth_tok_next 
2be1			 
2be1			 
2be1			; while we have words to look for 
2be1			 
2be1 7e			ld a, (hl)      
2be2			if DEBUG_FORTH_WORDS 
2be2				DMARK "LSk" 
2be2 f5				push af  
2be3 3a f7 2b			ld a, (.dmark)  
2be6 32 65 ee			ld (debug_mark),a  
2be9 3a f8 2b			ld a, (.dmark+1)  
2bec 32 66 ee			ld (debug_mark+1),a  
2bef 3a f9 2b			ld a, (.dmark+2)  
2bf2 32 67 ee			ld (debug_mark+2),a  
2bf5 18 03			jr .pastdmark  
2bf7 ..			.dmark: db "LSk"  
2bfa f1			.pastdmark: pop af  
2bfb			endm  
# End of macro DMARK
2bfb				CALLMONITOR 
2bfb cd 6f ee			call debug_vector  
2bfe				endm  
# End of macro CALLMONITOR
2bfe			endif 
2bfe				;cp WORD_SYS_END 
2bfe				;jp z, .lunotfound 
2bfe			 
2bfe					; if we hit non uwords then gone too far 
2bfe fe 01				cp WORD_SYS_UWORD 
2c00 c2 3e 2d				jp nz, .lunotfound 
2c03			 
2c03				if DEBUG_FORTH_WORDS 
2c03					DMARK "LSu" 
2c03 f5				push af  
2c04 3a 18 2c			ld a, (.dmark)  
2c07 32 65 ee			ld (debug_mark),a  
2c0a 3a 19 2c			ld a, (.dmark+1)  
2c0d 32 66 ee			ld (debug_mark+1),a  
2c10 3a 1a 2c			ld a, (.dmark+2)  
2c13 32 67 ee			ld (debug_mark+2),a  
2c16 18 03			jr .pastdmark  
2c18 ..			.dmark: db "LSu"  
2c1b f1			.pastdmark: pop af  
2c1c			endm  
# End of macro DMARK
2c1c					CALLMONITOR 
2c1c cd 6f ee			call debug_vector  
2c1f				endm  
# End of macro CALLMONITOR
2c1f				endif 
2c1f			 
2c1f					; found a uword but is it the one we want... 
2c1f			 
2c1f c5					push bc     ; uword to find is on bc 
2c20 d1					pop de 
2c21			 
2c21 e5					push hl  ; to save the ptr 
2c22			 
2c22					; skip opcode 
2c22 23					inc hl  
2c23					; skip next ptr 
2c23 23					inc hl  
2c24 23					inc hl 
2c25					; skip len 
2c25 23					inc hl 
2c26			 
2c26				if DEBUG_FORTH_WORDS 
2c26					DMARK "LSc" 
2c26 f5				push af  
2c27 3a 3b 2c			ld a, (.dmark)  
2c2a 32 65 ee			ld (debug_mark),a  
2c2d 3a 3c 2c			ld a, (.dmark+1)  
2c30 32 66 ee			ld (debug_mark+1),a  
2c33 3a 3d 2c			ld a, (.dmark+2)  
2c36 32 67 ee			ld (debug_mark+2),a  
2c39 18 03			jr .pastdmark  
2c3b ..			.dmark: db "LSc"  
2c3e f1			.pastdmark: pop af  
2c3f			endm  
# End of macro DMARK
2c3f					CALLMONITOR 
2c3f cd 6f ee			call debug_vector  
2c42				endm  
# End of macro CALLMONITOR
2c42				endif 
2c42			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2c42			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2c42			; Nope that has gone the other way. It needs to be exact not on first zero 
2c42			;		call strcmp 
2c42 c5					push bc 
2c43 cd a0 11				call StrictStrCmp 
2c46 c1					pop bc 
2c47 c2 c1 2b				jp nz, .ldouscanm 
2c4a				 
2c4a			 
2c4a			 
2c4a					; we have a uword so push its name to the stack 
2c4a			 
2c4a			;	   	push hl  ; save so we can move to next dict block 
2c4a e1			pop hl 
2c4b			 
2c4b				if DEBUG_FORTH_WORDS 
2c4b					DMARK "LSm" 
2c4b f5				push af  
2c4c 3a 60 2c			ld a, (.dmark)  
2c4f 32 65 ee			ld (debug_mark),a  
2c52 3a 61 2c			ld a, (.dmark+1)  
2c55 32 66 ee			ld (debug_mark+1),a  
2c58 3a 62 2c			ld a, (.dmark+2)  
2c5b 32 67 ee			ld (debug_mark+2),a  
2c5e 18 03			jr .pastdmark  
2c60 ..			.dmark: db "LSm"  
2c63 f1			.pastdmark: pop af  
2c64			endm  
# End of macro DMARK
2c64					CALLMONITOR 
2c64 cd 6f ee			call debug_vector  
2c67				endm  
# End of macro CALLMONITOR
2c67				endif 
2c67			 
2c67					; skip opcode 
2c67 23					inc hl  
2c68					; skip next ptr 
2c68 23					inc hl  
2c69 23					inc hl 
2c6a					; skip len 
2c6a 7e					ld a, (hl)   ; save length to add 
2c6b				if DEBUG_FORTH_WORDS 
2c6b					DMARK "LS2" 
2c6b f5				push af  
2c6c 3a 80 2c			ld a, (.dmark)  
2c6f 32 65 ee			ld (debug_mark),a  
2c72 3a 81 2c			ld a, (.dmark+1)  
2c75 32 66 ee			ld (debug_mark+1),a  
2c78 3a 82 2c			ld a, (.dmark+2)  
2c7b 32 67 ee			ld (debug_mark+2),a  
2c7e 18 03			jr .pastdmark  
2c80 ..			.dmark: db "LS2"  
2c83 f1			.pastdmark: pop af  
2c84			endm  
# End of macro DMARK
2c84					CALLMONITOR 
2c84 cd 6f ee			call debug_vector  
2c87				endm  
# End of macro CALLMONITOR
2c87				endif 
2c87			 
2c87					; save this location 
2c87				 
2c87 e5					push hl 
2c88			 
2c88 23					inc hl 
2c89 11 bd e2				ld de, scratch+2 
2c8c 4f					ld c, a 
2c8d 06 00				ld b, 0 
2c8f			 
2c8f				if DEBUG_FORTH_WORDS 
2c8f					DMARK "LSn" 
2c8f f5				push af  
2c90 3a a4 2c			ld a, (.dmark)  
2c93 32 65 ee			ld (debug_mark),a  
2c96 3a a5 2c			ld a, (.dmark+1)  
2c99 32 66 ee			ld (debug_mark+1),a  
2c9c 3a a6 2c			ld a, (.dmark+2)  
2c9f 32 67 ee			ld (debug_mark+2),a  
2ca2 18 03			jr .pastdmark  
2ca4 ..			.dmark: db "LSn"  
2ca7 f1			.pastdmark: pop af  
2ca8			endm  
# End of macro DMARK
2ca8					CALLMONITOR 
2ca8 cd 6f ee			call debug_vector  
2cab				endm  
# End of macro CALLMONITOR
2cab				endif 
2cab			 
2cab					; copy uword name to scratch 
2cab			 
2cab			;		ldir 
2cab			.licplw:	; copy uword name to scratch converting to lower case as we go 
2cab ed a0				ldi 
2cad 1b					dec de 
2cae 1a					ld a, (de) 
2caf cd 73 10				call to_lower 
2cb2 12					ld (de),a 
2cb3 13					inc de 
2cb4 3e 00				ld a, 0 
2cb6 b9					cp c 
2cb7 20 f2				jr nz, .licplw 
2cb9			 
2cb9			 
2cb9			 
2cb9 1b					dec de 
2cba 3e 20				ld a, ' '    ; change null to space 
2cbc 12					ld (de), a 
2cbd			 
2cbd 13					inc de 
2cbe			 
2cbe d5					push de 
2cbf c1					pop bc     ; move scratch pointer to end of word name and save it 
2cc0			 
2cc0 e1					pop hl 
2cc1 7e					ld a, (hl) 
2cc2					;inc hl 
2cc2					; skip word string 
2cc2 cd f5 0d				call addatohl 
2cc5			 
2cc5 23					inc hl 
2cc6			 
2cc6				if DEBUG_FORTH_WORDS 
2cc6					DMARK "LS3" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 65 ee			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 66 ee			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 67 ee			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "LS3"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf					CALLMONITOR 
2cdf cd 6f ee			call debug_vector  
2ce2				endm  
# End of macro CALLMONITOR
2ce2				endif 
2ce2					; should now be at the start of the machine code to setup the eval of the uword 
2ce2					; now locate the ptr to the string defintion 
2ce2			 
2ce2					; skip ld hl, 
2ce2					; then load the ptr 
2ce2			; TODO use get from hl ptr 
2ce2 23					inc hl 
2ce3 5e					ld e, (hl) 
2ce4 23					inc hl 
2ce5 56					ld d, (hl) 
2ce6 eb					ex de, hl 
2ce7			 
2ce7			 
2ce7				if DEBUG_FORTH_WORDS 
2ce7					DMARK "LSt" 
2ce7 f5				push af  
2ce8 3a fc 2c			ld a, (.dmark)  
2ceb 32 65 ee			ld (debug_mark),a  
2cee 3a fd 2c			ld a, (.dmark+1)  
2cf1 32 66 ee			ld (debug_mark+1),a  
2cf4 3a fe 2c			ld a, (.dmark+2)  
2cf7 32 67 ee			ld (debug_mark+2),a  
2cfa 18 03			jr .pastdmark  
2cfc ..			.dmark: db "LSt"  
2cff f1			.pastdmark: pop af  
2d00			endm  
# End of macro DMARK
2d00					CALLMONITOR 
2d00 cd 6f ee			call debug_vector  
2d03				endm  
# End of macro CALLMONITOR
2d03				endif 
2d03			 
2d03			; cant push right now due to tokenised strings  
2d03			 
2d03			; get the destination of where to copy this definition to. 
2d03			 
2d03 c5					push bc 
2d04 d1					pop de 
2d05			 
2d05 7e			.listl:         ld a,(hl) 
2d06 fe 00				cp 0 
2d08 28 09				jr z, .lreplsp     ; replace zero with space 
2d0a					;cp FORTH_END_BUFFER 
2d0a fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d0c 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d0e				 
2d0e					; just copy this char as is then 
2d0e			 
2d0e 12					ld (de), a 
2d0f			 
2d0f 23			.listnxt:	inc hl 
2d10 13					inc de 
2d11 18 f2				jr .listl 
2d13			 
2d13 3e 20		.lreplsp:	ld a,' ' 
2d15 12					ld (de), a 
2d16 18 f7				jr .listnxt 
2d18			 
2d18			; close up uword def 
2d18			 
2d18			.listdone: 
2d18 12					ld (de), a 
2d19 13					inc de 
2d1a 3e 00				ld a, 0 
2d1c 12					ld (de), a 
2d1d			 
2d1d			; now have def so clean up and push to stack 
2d1d			 
2d1d 21 bb e2				ld hl, scratch 
2d20				if DEBUG_FORTH_WORDS 
2d20					DMARK "Ltp" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 65 ee			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 66 ee			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 67 ee			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "Ltp"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39					CALLMONITOR 
2d39 cd 6f ee			call debug_vector  
2d3c				endm  
# End of macro CALLMONITOR
2d3c				endif 
2d3c			 
2d3c 18 1f			jr .listpush 
2d3e			 
2d3e			;.lnuword:	pop hl 
2d3e			;		call forth_tok_next 
2d3e			;		jp .ldouscan  
2d3e			 
2d3e			.lunotfound:		  
2d3e			 
2d3e				if DEBUG_FORTH_WORDS 
2d3e					DMARK "LSn" 
2d3e f5				push af  
2d3f 3a 53 2d			ld a, (.dmark)  
2d42 32 65 ee			ld (debug_mark),a  
2d45 3a 54 2d			ld a, (.dmark+1)  
2d48 32 66 ee			ld (debug_mark+1),a  
2d4b 3a 55 2d			ld a, (.dmark+2)  
2d4e 32 67 ee			ld (debug_mark+2),a  
2d51 18 03			jr .pastdmark  
2d53 ..			.dmark: db "LSn"  
2d56 f1			.pastdmark: pop af  
2d57			endm  
# End of macro DMARK
2d57					CALLMONITOR 
2d57 cd 6f ee			call debug_vector  
2d5a				endm  
# End of macro CALLMONITOR
2d5a				endif 
2d5a			 
2d5a					 
2d5a			;		FORTH_DSP_POP 
2d5a			;		ld hl, .luno 
2d5a			 
2d5a					NEXTW			 
2d5a c3 80 1f			jp macro_next 
2d5d				endm 
# End of macro NEXTW
2d5d			 
2d5d			.listpush: 
2d5d				if DEBUG_FORTH_WORDS 
2d5d					DMARK "LS>" 
2d5d f5				push af  
2d5e 3a 72 2d			ld a, (.dmark)  
2d61 32 65 ee			ld (debug_mark),a  
2d64 3a 73 2d			ld a, (.dmark+1)  
2d67 32 66 ee			ld (debug_mark+1),a  
2d6a 3a 74 2d			ld a, (.dmark+2)  
2d6d 32 67 ee			ld (debug_mark+2),a  
2d70 18 03			jr .pastdmark  
2d72 ..			.dmark: db "LS>"  
2d75 f1			.pastdmark: pop af  
2d76			endm  
# End of macro DMARK
2d76					CALLMONITOR 
2d76 cd 6f ee			call debug_vector  
2d79				endm  
# End of macro CALLMONITOR
2d79				endif 
2d79 cd fe 1b				call forth_push_str 
2d7c			 
2d7c			 
2d7c			 
2d7c					NEXTW 
2d7c c3 80 1f			jp macro_next 
2d7f				endm 
# End of macro NEXTW
2d7f			 
2d7f			;.luno:    db "Word not found",0 
2d7f			 
2d7f			 
2d7f			 
2d7f			 
2d7f			 
2d7f			;		push hl   ; save pointer to start of uword def string 
2d7f			; 
2d7f			;; look for FORTH_EOL_LINE 
2d7f			;		ld a, FORTH_END_BUFFER 
2d7f			;		call strlent 
2d7f			; 
2d7f			;		inc hl		 ; space for coln def 
2d7f			;		inc hl 
2d7f			;		inc hl          ; space for terms 
2d7f			;		inc hl 
2d7f			; 
2d7f			;		ld a, 20   ; TODO get actual length 
2d7f			;		call addatohl    ; include a random amount of room for the uword name 
2d7f			; 
2d7f			;		 
2d7f			;	if DEBUG_FORTH_WORDS 
2d7f			;		DMARK "Lt1" 
2d7f			;		CALLMONITOR 
2d7f			;	endif 
2d7f			;		 
2d7f			; 
2d7f			;; malloc space for the string because we cant change it 
2d7f			; 
2d7f			;		call malloc 
2d7f			;	if DEBUG_FORTH_MALLOC_GUARD 
2d7f			;		push af 
2d7f			;		call ishlzero 
2d7f			;		pop af 
2d7f			;		 
2d7f			;		call z,malloc_error 
2d7f			;	endif 
2d7f			; 
2d7f			;	if DEBUG_FORTH_WORDS 
2d7f			;		DMARK "Lt2" 
2d7f			;		CALLMONITOR 
2d7f			;	endif 
2d7f			;		pop de 
2d7f			;		push hl    ; push the malloc to release later 
2d7f			;		push hl   ;  push back a copy for the later stack push 
2d7f			;		 
2d7f			;; copy the string swapping out the zero terms for spaces 
2d7f			; 
2d7f			;		; de has our source 
2d7f			;		; hl has our dest 
2d7f			; 
2d7f			;; add the coln def 
2d7f			; 
2d7f			;		ld a, ':' 
2d7f			;		ld (hl), a 
2d7f			;		inc hl 
2d7f			;		ld a, ' ' 
2d7f			;		ld (hl), a 
2d7f			;		inc hl 
2d7f			; 
2d7f			;; add the uname word 
2d7f			;		push de   ; save our string for now 
2d7f			;		ex de, hl 
2d7f			; 
2d7f			;		FORTH_DSP_VALUE 
2d7f			;		;v5 FORTH_DSP_VALUE 
2d7f			; 
2d7f			;		inc hl   ; skip type but we know by now this is OK 
2d7f			; 
2d7f			;.luword:	ld a,(hl) 
2d7f			;		cp 0 
2d7f			;		jr z, .luword2 
2d7f			;		ld (de), a 
2d7f			;		inc de 
2d7f			;		inc hl 
2d7f			;		jr .luword 
2d7f			; 
2d7f			;.luword2:	ld a, ' ' 
2d7f			;		ld (de), a 
2d7f			;;		inc hl 
2d7f			;;		inc de 
2d7f			;;		ld (de), a 
2d7f			;;		inc hl 
2d7f			;		inc de 
2d7f			; 
2d7f			;		ex de, hl 
2d7f			;		pop de 
2d7f			;		 
2d7f			;		 
2d7f			; 
2d7f			;; detoken that string and copy it 
2d7f			; 
2d7f			;	if DEBUG_FORTH_WORDS 
2d7f			;		DMARK "Lt2" 
2d7f			;		CALLMONITOR 
2d7f			;	endif 
2d7f			;.ldetok:	ld a, (de) 
2d7f			;		cp FORTH_END_BUFFER 
2d7f			;		jr z, .ldetokend 
2d7f			;		; swap out any zero term for space 
2d7f			;		cp 0 
2d7f			;		jr nz, .ldetoknext 
2d7f			;		ld a, ' ' 
2d7f			; 
2d7f			;	if DEBUG_FORTH_WORDS 
2d7f			;		DMARK "LtS" 
2d7f			;		CALLMONITOR 
2d7f			;	endif 
2d7f			;.ldetoknext:	ld (hl), a 
2d7f			;		inc de 
2d7f			;		inc hl 
2d7f			;		jr .ldetok 
2d7f			; 
2d7f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d7f			;		ld (hl), a  
2d7f			; 
2d7f			;; free that temp malloc 
2d7f			; 
2d7f			;		pop hl    
2d7f			; 
2d7f			;	if DEBUG_FORTH_WORDS 
2d7f			;		DMARK "Lt4" 
2d7f			;		CALLMONITOR 
2d7f			;	endif 
2d7f			;		call forth_apushstrhl 
2d7f			; 
2d7f			;		; get rid of temp malloc area 
2d7f			; 
2d7f			;		pop hl 
2d7f			;		call free 
2d7f			; 
2d7f			;		jr .ludone 
2d7f			; 
2d7f			;.lnuword:	pop hl 
2d7f			;		call forth_tok_next 
2d7f			;		jp .ldouscan  
2d7f			; 
2d7f			;.ludone:		 pop hl 
2d7f			; 
2d7f					NEXTW 
2d7f c3 80 1f			jp macro_next 
2d82				endm 
# End of macro NEXTW
2d82			 
2d82			.FORGET: 
2d82				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d82 5d				db WORD_SYS_CORE+73             
2d83 fb 2d			dw .NOP            
2d85 07				db 6 + 1 
2d86 .. 00			db "FORGET",0              
2d8d				endm 
# End of macro CWHEAD
2d8d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d8d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2d8d			; | |  
2d8d			; | | e.g. "MORE" forget 
2d8d					if DEBUG_FORTH_WORDS_KEY 
2d8d						DMARK "FRG" 
2d8d f5				push af  
2d8e 3a a2 2d			ld a, (.dmark)  
2d91 32 65 ee			ld (debug_mark),a  
2d94 3a a3 2d			ld a, (.dmark+1)  
2d97 32 66 ee			ld (debug_mark+1),a  
2d9a 3a a4 2d			ld a, (.dmark+2)  
2d9d 32 67 ee			ld (debug_mark+2),a  
2da0 18 03			jr .pastdmark  
2da2 ..			.dmark: db "FRG"  
2da5 f1			.pastdmark: pop af  
2da6			endm  
# End of macro DMARK
2da6						CALLMONITOR 
2da6 cd 6f ee			call debug_vector  
2da9				endm  
# End of macro CALLMONITOR
2da9					endif 
2da9			 
2da9				; find uword 
2da9			        ; update start of word with "_" 
2da9				; replace uword with deleted flag 
2da9			 
2da9			 
2da9			;	if DEBUG_FORTH_WORDS 
2da9			;		DMARK "FOG" 
2da9			;		CALLMONITOR 
2da9			;	endif 
2da9			 
2da9			 
2da9					; Get ptr to the word we need to look up 
2da9			 
2da9					FORTH_DSP_VALUEHL 
2da9 cd 95 1d			call macro_dsp_valuehl 
2dac				endm 
# End of macro FORTH_DSP_VALUEHL
2dac					;v5 FORTH_DSP_VALUE 
2dac				; TODO type check 
2dac			;		inc hl    ; Skip type check  
2dac e5					push hl 
2dad c1					pop bc 
2dae			;		ex de, hl    ; put into DE 
2dae			 
2dae			 
2dae 21 22 64				ld hl, baseram 
2db1					;ld hl, baseusermem 
2db1			 
2db1				; skip dict stub 
2db1			;	call forth_tok_next 
2db1 e5			push hl   ; sacreifical push 
2db2			 
2db2			.fldouscanm: 
2db2 e1				pop hl 
2db3			.fldouscan: 
2db3			;	if DEBUG_FORTH_WORDS 
2db3			;		DMARK "LSs" 
2db3			;		CALLMONITOR 
2db3			;	endif 
2db3				; skip dict stub 
2db3 cd bd 20				call forth_tok_next 
2db6			 
2db6			 
2db6			; while we have words to look for 
2db6			 
2db6 7e				ld a, (hl)      
2db7			;	if DEBUG_FORTH_WORDS 
2db7			;		DMARK "LSk" 
2db7			;		CALLMONITOR 
2db7			;	endif 
2db7 fe 00				cp WORD_SYS_END 
2db9 ca f5 2d				jp z, .flunotfound 
2dbc fe 01				cp WORD_SYS_UWORD 
2dbe c2 b3 2d				jp nz, .fldouscan 
2dc1			 
2dc1			;	if DEBUG_FORTH_WORDS 
2dc1			;		DMARK "LSu" 
2dc1			;		CALLMONITOR 
2dc1			;	endif 
2dc1			 
2dc1					; found a uword but is it the one we want... 
2dc1			 
2dc1 c5					push bc     ; uword to find is on bc 
2dc2 d1					pop de 
2dc3			 
2dc3 e5					push hl  ; to save the ptr 
2dc4			 
2dc4					; skip opcode 
2dc4 23					inc hl  
2dc5					; skip next ptr 
2dc5 23					inc hl  
2dc6 23					inc hl 
2dc7					; skip len 
2dc7 23					inc hl 
2dc8			 
2dc8			;	if DEBUG_FORTH_WORDS 
2dc8			;		DMARK "LSc" 
2dc8			;		CALLMONITOR 
2dc8			;	endif 
2dc8 cd 93 11				call strcmp 
2dcb c2 b2 2d				jp nz, .fldouscanm 
2dce			; 
2dce			; 
2dce			;; while we have words to look for 
2dce			; 
2dce			;.fdouscan:	ld a, (hl)      
2dce			;	if DEBUG_FORTH_WORDS 
2dce			;		DMARK "LSs" 
2dce			;		CALLMONITOR 
2dce			;	endif 
2dce			;		cp WORD_SYS_END 
2dce			;		jp z, .fudone 
2dce			;		cp WORD_SYS_UWORD 
2dce			;		jp nz, .fnuword 
2dce			; 
2dce			;	if DEBUG_FORTH_WORDS 
2dce			;		DMARK "FGu" 
2dce			;		CALLMONITOR 
2dce			;	endif 
2dce			; 
2dce			;		; found a uword but is it the one we want... 
2dce			; 
2dce			; 
2dce			;	        pop de   ; get back the dsp name 
2dce			;		push de 
2dce			; 
2dce			;		push hl  ; to save the ptr 
2dce			; 
2dce			;		; skip opcode 
2dce			;		inc hl  
2dce			;		; skip next ptr 
2dce			;		inc hl  
2dce			;		inc hl 
2dce			;		; skip len 
2dce			;		inc hl 
2dce			; 
2dce			;	if DEBUG_FORTH_WORDS 
2dce			;		DMARK "FGc" 
2dce			;		CALLMONITOR 
2dce			;	endif 
2dce			;		call strcmp 
2dce			;		jp nz, .fnuword 
2dce			 
2dce			 
2dce e1			pop hl 
2dcf			 
2dcf				 
2dcf				if DEBUG_FORTH_WORDS 
2dcf					DMARK "FGm" 
2dcf f5				push af  
2dd0 3a e4 2d			ld a, (.dmark)  
2dd3 32 65 ee			ld (debug_mark),a  
2dd6 3a e5 2d			ld a, (.dmark+1)  
2dd9 32 66 ee			ld (debug_mark+1),a  
2ddc 3a e6 2d			ld a, (.dmark+2)  
2ddf 32 67 ee			ld (debug_mark+2),a  
2de2 18 03			jr .pastdmark  
2de4 ..			.dmark: db "FGm"  
2de7 f1			.pastdmark: pop af  
2de8			endm  
# End of macro DMARK
2de8					CALLMONITOR 
2de8 cd 6f ee			call debug_vector  
2deb				endm  
# End of macro CALLMONITOR
2deb				endif 
2deb			 
2deb			 
2deb			 
2deb					; we have a uword so push its name to the stack 
2deb			 
2deb			;	   	push hl  ; save so we can move to next dict block 
2deb			;pop hl 
2deb			 
2deb					; update opcode to deleted 
2deb 3e 03				ld a, WORD_SYS_DELETED 
2ded 77					ld (hl), a 
2dee			 
2dee 23					inc hl  
2def					; skip next ptr 
2def 23					inc hl  
2df0 23					inc hl 
2df1					; skip len 
2df1 23					inc hl 
2df2			 
2df2					; TODO change parser to skip deleted words but for now mark it out 
2df2 3e 5f				ld a, "_" 
2df4 77					ld  (hl),a 
2df5			 
2df5			;		jr .fudone 
2df5			; 
2df5			;.fnuword:	pop hl 
2df5			;		call forth_tok_next 
2df5			;		jp .fdouscan  
2df5			 
2df5			.flunotfound:		  
2df5			 
2df5			 
2df5					 
2df5					FORTH_DSP_POP 
2df5 cd 4d 1e			call macro_forth_dsp_pop 
2df8				endm 
# End of macro FORTH_DSP_POP
2df8			;		ld hl, .luno 
2df8			;.fudone:		 pop hl 
2df8					NEXTW 
2df8 c3 80 1f			jp macro_next 
2dfb				endm 
# End of macro NEXTW
2dfb			.NOP: 
2dfb				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2dfb 61				db WORD_SYS_CORE+77             
2dfc 22 2e			dw .COMO            
2dfe 04				db 3 + 1 
2dff .. 00			db "NOP",0              
2e03				endm 
# End of macro CWHEAD
2e03			; | NOP (  --  ) Do nothing | DONE 
2e03					if DEBUG_FORTH_WORDS_KEY 
2e03						DMARK "NOP" 
2e03 f5				push af  
2e04 3a 18 2e			ld a, (.dmark)  
2e07 32 65 ee			ld (debug_mark),a  
2e0a 3a 19 2e			ld a, (.dmark+1)  
2e0d 32 66 ee			ld (debug_mark+1),a  
2e10 3a 1a 2e			ld a, (.dmark+2)  
2e13 32 67 ee			ld (debug_mark+2),a  
2e16 18 03			jr .pastdmark  
2e18 ..			.dmark: db "NOP"  
2e1b f1			.pastdmark: pop af  
2e1c			endm  
# End of macro DMARK
2e1c						CALLMONITOR 
2e1c cd 6f ee			call debug_vector  
2e1f				endm  
# End of macro CALLMONITOR
2e1f					endif 
2e1f				       NEXTW 
2e1f c3 80 1f			jp macro_next 
2e22				endm 
# End of macro NEXTW
2e22			.COMO: 
2e22				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e22 6e				db WORD_SYS_CORE+90             
2e23 74 2e			dw .COMC            
2e25 02				db 1 + 1 
2e26 .. 00			db "(",0              
2e28				endm 
# End of macro CWHEAD
2e28			; | ( ( -- )  Start of comment | DONE 
2e28			 
2e28			 
2e28 2a bc e5				ld hl, ( os_tok_ptr) 
2e2b 11 6f 2e			ld de, .closepar 
2e2e					 
2e2e					if DEBUG_FORTH_WORDS 
2e2e						DMARK ").." 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 65 ee			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 66 ee			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 67 ee			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db ").."  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47						CALLMONITOR 
2e47 cd 6f ee			call debug_vector  
2e4a				endm  
# End of macro CALLMONITOR
2e4a					endif 
2e4a cd 87 20			call findnexttok  
2e4d			 
2e4d					if DEBUG_FORTH_WORDS 
2e4d						DMARK "IF5" 
2e4d f5				push af  
2e4e 3a 62 2e			ld a, (.dmark)  
2e51 32 65 ee			ld (debug_mark),a  
2e54 3a 63 2e			ld a, (.dmark+1)  
2e57 32 66 ee			ld (debug_mark+1),a  
2e5a 3a 64 2e			ld a, (.dmark+2)  
2e5d 32 67 ee			ld (debug_mark+2),a  
2e60 18 03			jr .pastdmark  
2e62 ..			.dmark: db "IF5"  
2e65 f1			.pastdmark: pop af  
2e66			endm  
# End of macro DMARK
2e66						CALLMONITOR 
2e66 cd 6f ee			call debug_vector  
2e69				endm  
# End of macro CALLMONITOR
2e69					endif 
2e69				; replace below with ) exec using tok_ptr 
2e69 22 bc e5			ld (os_tok_ptr), hl 
2e6c c3 09 20			jp exec1 
2e6f			 
2e6f .. 00			.closepar:   db ")",0 
2e71			 
2e71				       NEXTW 
2e71 c3 80 1f			jp macro_next 
2e74				endm 
# End of macro NEXTW
2e74			.COMC: 
2e74				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e74 6f				db WORD_SYS_CORE+91             
2e75 7d 2e			dw .SCRATCH            
2e77 02				db 1 + 1 
2e78 .. 00			db ")",0              
2e7a				endm 
# End of macro CWHEAD
2e7a			; | ) ( -- )  End of comment |  DONE  
2e7a				       NEXTW 
2e7a c3 80 1f			jp macro_next 
2e7d				endm 
# End of macro NEXTW
2e7d			 
2e7d			.SCRATCH: 
2e7d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e7d 6f				db WORD_SYS_CORE+91             
2e7e b8 2e			dw .INC            
2e80 08				db 7 + 1 
2e81 .. 00			db "SCRATCH",0              
2e89				endm 
# End of macro CWHEAD
2e89			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e89			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e89			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e89			; | |  
2e89			; | | e.g.    : score $00 scratch ; 
2e89			; | |  
2e89			; | | $00 score ! 
2e89			; | | $01 score +! 
2e89			; | |  
2e89			; | | e.g.   : varword $0a scratch ;  
2e89			; | | 
2e89			; | | $8000 varword ! 
2e89					if DEBUG_FORTH_WORDS_KEY 
2e89						DMARK "SCR" 
2e89 f5				push af  
2e8a 3a 9e 2e			ld a, (.dmark)  
2e8d 32 65 ee			ld (debug_mark),a  
2e90 3a 9f 2e			ld a, (.dmark+1)  
2e93 32 66 ee			ld (debug_mark+1),a  
2e96 3a a0 2e			ld a, (.dmark+2)  
2e99 32 67 ee			ld (debug_mark+2),a  
2e9c 18 03			jr .pastdmark  
2e9e ..			.dmark: db "SCR"  
2ea1 f1			.pastdmark: pop af  
2ea2			endm  
# End of macro DMARK
2ea2						CALLMONITOR 
2ea2 cd 6f ee			call debug_vector  
2ea5				endm  
# End of macro CALLMONITOR
2ea5					endif 
2ea5			 
2ea5					FORTH_DSP_VALUEHL 
2ea5 cd 95 1d			call macro_dsp_valuehl 
2ea8				endm 
# End of macro FORTH_DSP_VALUEHL
2ea8				 
2ea8					FORTH_DSP_POP 
2ea8 cd 4d 1e			call macro_forth_dsp_pop 
2eab				endm 
# End of macro FORTH_DSP_POP
2eab			 
2eab 7d					ld a, l 
2eac 21 e0 e7				ld hl, os_var_array 
2eaf cd f5 0d				call addatohl 
2eb2			 
2eb2 cd 90 1b				call forth_push_numhl 
2eb5			 
2eb5				       NEXTW 
2eb5 c3 80 1f			jp macro_next 
2eb8				endm 
# End of macro NEXTW
2eb8			 
2eb8			.INC: 
2eb8				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2eb8 6f				db WORD_SYS_CORE+91             
2eb9 0e 2f			dw .DEC            
2ebb 03				db 2 + 1 
2ebc .. 00			db "+!",0              
2ebf				endm 
# End of macro CWHEAD
2ebf			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ebf					if DEBUG_FORTH_WORDS_KEY 
2ebf						DMARK "+s_" 
2ebf f5				push af  
2ec0 3a d4 2e			ld a, (.dmark)  
2ec3 32 65 ee			ld (debug_mark),a  
2ec6 3a d5 2e			ld a, (.dmark+1)  
2ec9 32 66 ee			ld (debug_mark+1),a  
2ecc 3a d6 2e			ld a, (.dmark+2)  
2ecf 32 67 ee			ld (debug_mark+2),a  
2ed2 18 03			jr .pastdmark  
2ed4 ..			.dmark: db "+s_"  
2ed7 f1			.pastdmark: pop af  
2ed8			endm  
# End of macro DMARK
2ed8						CALLMONITOR 
2ed8 cd 6f ee			call debug_vector  
2edb				endm  
# End of macro CALLMONITOR
2edb					endif 
2edb			 
2edb					FORTH_DSP_VALUEHL 
2edb cd 95 1d			call macro_dsp_valuehl 
2ede				endm 
# End of macro FORTH_DSP_VALUEHL
2ede			 
2ede e5					push hl   ; save address 
2edf			 
2edf					FORTH_DSP_POP 
2edf cd 4d 1e			call macro_forth_dsp_pop 
2ee2				endm 
# End of macro FORTH_DSP_POP
2ee2			 
2ee2					FORTH_DSP_VALUEHL 
2ee2 cd 95 1d			call macro_dsp_valuehl 
2ee5				endm 
# End of macro FORTH_DSP_VALUEHL
2ee5			 
2ee5 e5					push hl 
2ee6					FORTH_DSP_POP 
2ee6 cd 4d 1e			call macro_forth_dsp_pop 
2ee9				endm 
# End of macro FORTH_DSP_POP
2ee9 e1					pop hl 
2eea			 
2eea					; hl contains value to add to byte at a 
2eea				 
2eea eb					ex de, hl 
2eeb			 
2eeb e1					pop hl 
2eec			 
2eec					if DEBUG_FORTH_WORDS 
2eec						DMARK "INC" 
2eec f5				push af  
2eed 3a 01 2f			ld a, (.dmark)  
2ef0 32 65 ee			ld (debug_mark),a  
2ef3 3a 02 2f			ld a, (.dmark+1)  
2ef6 32 66 ee			ld (debug_mark+1),a  
2ef9 3a 03 2f			ld a, (.dmark+2)  
2efc 32 67 ee			ld (debug_mark+2),a  
2eff 18 03			jr .pastdmark  
2f01 ..			.dmark: db "INC"  
2f04 f1			.pastdmark: pop af  
2f05			endm  
# End of macro DMARK
2f05						CALLMONITOR 
2f05 cd 6f ee			call debug_vector  
2f08				endm  
# End of macro CALLMONITOR
2f08					endif 
2f08			 
2f08 7e					ld a,(hl) 
2f09 83					add e 
2f0a 77					ld (hl),a 
2f0b			 
2f0b			 
2f0b			 
2f0b				       NEXTW 
2f0b c3 80 1f			jp macro_next 
2f0e				endm 
# End of macro NEXTW
2f0e			 
2f0e			.DEC: 
2f0e				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f0e 6f				db WORD_SYS_CORE+91             
2f0f 62 2f			dw .INC2            
2f11 03				db 2 + 1 
2f12 .. 00			db "-!",0              
2f15				endm 
# End of macro CWHEAD
2f15			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f15					if DEBUG_FORTH_WORDS_KEY 
2f15						DMARK "-s_" 
2f15 f5				push af  
2f16 3a 2a 2f			ld a, (.dmark)  
2f19 32 65 ee			ld (debug_mark),a  
2f1c 3a 2b 2f			ld a, (.dmark+1)  
2f1f 32 66 ee			ld (debug_mark+1),a  
2f22 3a 2c 2f			ld a, (.dmark+2)  
2f25 32 67 ee			ld (debug_mark+2),a  
2f28 18 03			jr .pastdmark  
2f2a ..			.dmark: db "-s_"  
2f2d f1			.pastdmark: pop af  
2f2e			endm  
# End of macro DMARK
2f2e						CALLMONITOR 
2f2e cd 6f ee			call debug_vector  
2f31				endm  
# End of macro CALLMONITOR
2f31					endif 
2f31			 
2f31					FORTH_DSP_VALUEHL 
2f31 cd 95 1d			call macro_dsp_valuehl 
2f34				endm 
# End of macro FORTH_DSP_VALUEHL
2f34			 
2f34 e5					push hl   ; save address 
2f35			 
2f35					FORTH_DSP_POP 
2f35 cd 4d 1e			call macro_forth_dsp_pop 
2f38				endm 
# End of macro FORTH_DSP_POP
2f38			 
2f38					FORTH_DSP_VALUEHL 
2f38 cd 95 1d			call macro_dsp_valuehl 
2f3b				endm 
# End of macro FORTH_DSP_VALUEHL
2f3b			 
2f3b					; hl contains value to add to byte at a 
2f3b				 
2f3b eb					ex de, hl 
2f3c			 
2f3c e1					pop hl 
2f3d			 
2f3d					if DEBUG_FORTH_WORDS 
2f3d						DMARK "DEC" 
2f3d f5				push af  
2f3e 3a 52 2f			ld a, (.dmark)  
2f41 32 65 ee			ld (debug_mark),a  
2f44 3a 53 2f			ld a, (.dmark+1)  
2f47 32 66 ee			ld (debug_mark+1),a  
2f4a 3a 54 2f			ld a, (.dmark+2)  
2f4d 32 67 ee			ld (debug_mark+2),a  
2f50 18 03			jr .pastdmark  
2f52 ..			.dmark: db "DEC"  
2f55 f1			.pastdmark: pop af  
2f56			endm  
# End of macro DMARK
2f56						CALLMONITOR 
2f56 cd 6f ee			call debug_vector  
2f59				endm  
# End of macro CALLMONITOR
2f59					endif 
2f59			 
2f59 7e					ld a,(hl) 
2f5a 93					sub e 
2f5b 77					ld (hl),a 
2f5c			 
2f5c			 
2f5c					FORTH_DSP_POP 
2f5c cd 4d 1e			call macro_forth_dsp_pop 
2f5f				endm 
# End of macro FORTH_DSP_POP
2f5f			 
2f5f				       NEXTW 
2f5f c3 80 1f			jp macro_next 
2f62				endm 
# End of macro NEXTW
2f62			 
2f62			.INC2: 
2f62				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f62 6f				db WORD_SYS_CORE+91             
2f63 0f 30			dw .DEC2            
2f65 04				db 3 + 1 
2f66 .. 00			db "+2!",0              
2f6a				endm 
# End of macro CWHEAD
2f6a			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f6a			 
2f6a					if DEBUG_FORTH_WORDS_KEY 
2f6a						DMARK "+2s" 
2f6a f5				push af  
2f6b 3a 7f 2f			ld a, (.dmark)  
2f6e 32 65 ee			ld (debug_mark),a  
2f71 3a 80 2f			ld a, (.dmark+1)  
2f74 32 66 ee			ld (debug_mark+1),a  
2f77 3a 81 2f			ld a, (.dmark+2)  
2f7a 32 67 ee			ld (debug_mark+2),a  
2f7d 18 03			jr .pastdmark  
2f7f ..			.dmark: db "+2s"  
2f82 f1			.pastdmark: pop af  
2f83			endm  
# End of macro DMARK
2f83						CALLMONITOR 
2f83 cd 6f ee			call debug_vector  
2f86				endm  
# End of macro CALLMONITOR
2f86					endif 
2f86			 
2f86					; Address 
2f86			 
2f86					FORTH_DSP_VALUEHL 
2f86 cd 95 1d			call macro_dsp_valuehl 
2f89				endm 
# End of macro FORTH_DSP_VALUEHL
2f89			 
2f89 e5					push hl    ; save address 
2f8a			 
2f8a					; load content into de 
2f8a			 
2f8a 5e					ld e,(hl) 
2f8b 23					inc hl 
2f8c 56					ld d, (hl) 
2f8d			 
2f8d					if DEBUG_FORTH_WORDS 
2f8d						DMARK "+2a" 
2f8d f5				push af  
2f8e 3a a2 2f			ld a, (.dmark)  
2f91 32 65 ee			ld (debug_mark),a  
2f94 3a a3 2f			ld a, (.dmark+1)  
2f97 32 66 ee			ld (debug_mark+1),a  
2f9a 3a a4 2f			ld a, (.dmark+2)  
2f9d 32 67 ee			ld (debug_mark+2),a  
2fa0 18 03			jr .pastdmark  
2fa2 ..			.dmark: db "+2a"  
2fa5 f1			.pastdmark: pop af  
2fa6			endm  
# End of macro DMARK
2fa6						CALLMONITOR 
2fa6 cd 6f ee			call debug_vector  
2fa9				endm  
# End of macro CALLMONITOR
2fa9					endif 
2fa9			 
2fa9					FORTH_DSP_POP 
2fa9 cd 4d 1e			call macro_forth_dsp_pop 
2fac				endm 
# End of macro FORTH_DSP_POP
2fac			 
2fac					; Get value to add 
2fac			 
2fac					FORTH_DSP_VALUE 
2fac cd 7e 1d			call macro_forth_dsp_value 
2faf				endm 
# End of macro FORTH_DSP_VALUE
2faf			 
2faf					if DEBUG_FORTH_WORDS 
2faf						DMARK "+2v" 
2faf f5				push af  
2fb0 3a c4 2f			ld a, (.dmark)  
2fb3 32 65 ee			ld (debug_mark),a  
2fb6 3a c5 2f			ld a, (.dmark+1)  
2fb9 32 66 ee			ld (debug_mark+1),a  
2fbc 3a c6 2f			ld a, (.dmark+2)  
2fbf 32 67 ee			ld (debug_mark+2),a  
2fc2 18 03			jr .pastdmark  
2fc4 ..			.dmark: db "+2v"  
2fc7 f1			.pastdmark: pop af  
2fc8			endm  
# End of macro DMARK
2fc8						CALLMONITOR 
2fc8 cd 6f ee			call debug_vector  
2fcb				endm  
# End of macro CALLMONITOR
2fcb					endif 
2fcb			 
2fcb 19					add hl, de 
2fcc			 
2fcc					if DEBUG_FORTH_WORDS 
2fcc						DMARK "+2+" 
2fcc f5				push af  
2fcd 3a e1 2f			ld a, (.dmark)  
2fd0 32 65 ee			ld (debug_mark),a  
2fd3 3a e2 2f			ld a, (.dmark+1)  
2fd6 32 66 ee			ld (debug_mark+1),a  
2fd9 3a e3 2f			ld a, (.dmark+2)  
2fdc 32 67 ee			ld (debug_mark+2),a  
2fdf 18 03			jr .pastdmark  
2fe1 ..			.dmark: db "+2+"  
2fe4 f1			.pastdmark: pop af  
2fe5			endm  
# End of macro DMARK
2fe5						CALLMONITOR 
2fe5 cd 6f ee			call debug_vector  
2fe8				endm  
# End of macro CALLMONITOR
2fe8					endif 
2fe8			 
2fe8					; move result to de 
2fe8			 
2fe8 eb					ex de, hl 
2fe9			 
2fe9					; Address 
2fe9			 
2fe9 e1					pop hl 
2fea			 
2fea					; save it back 
2fea			 
2fea 73					ld (hl), e 
2feb 23					inc hl 
2fec 72					ld (hl), d 
2fed			 
2fed					if DEBUG_FORTH_WORDS 
2fed						DMARK "+2e" 
2fed f5				push af  
2fee 3a 02 30			ld a, (.dmark)  
2ff1 32 65 ee			ld (debug_mark),a  
2ff4 3a 03 30			ld a, (.dmark+1)  
2ff7 32 66 ee			ld (debug_mark+1),a  
2ffa 3a 04 30			ld a, (.dmark+2)  
2ffd 32 67 ee			ld (debug_mark+2),a  
3000 18 03			jr .pastdmark  
3002 ..			.dmark: db "+2e"  
3005 f1			.pastdmark: pop af  
3006			endm  
# End of macro DMARK
3006						CALLMONITOR 
3006 cd 6f ee			call debug_vector  
3009				endm  
# End of macro CALLMONITOR
3009					endif 
3009			 
3009			 
3009			 
3009					FORTH_DSP_POP 
3009 cd 4d 1e			call macro_forth_dsp_pop 
300c				endm 
# End of macro FORTH_DSP_POP
300c			 
300c			 
300c				       NEXTW 
300c c3 80 1f			jp macro_next 
300f				endm 
# End of macro NEXTW
300f			 
300f			.DEC2: 
300f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
300f 6f				db WORD_SYS_CORE+91             
3010 be 30			dw .GET2            
3012 04				db 3 + 1 
3013 .. 00			db "-2!",0              
3017				endm 
# End of macro CWHEAD
3017			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3017			 
3017			 
3017					if DEBUG_FORTH_WORDS_KEY 
3017						DMARK "-2s" 
3017 f5				push af  
3018 3a 2c 30			ld a, (.dmark)  
301b 32 65 ee			ld (debug_mark),a  
301e 3a 2d 30			ld a, (.dmark+1)  
3021 32 66 ee			ld (debug_mark+1),a  
3024 3a 2e 30			ld a, (.dmark+2)  
3027 32 67 ee			ld (debug_mark+2),a  
302a 18 03			jr .pastdmark  
302c ..			.dmark: db "-2s"  
302f f1			.pastdmark: pop af  
3030			endm  
# End of macro DMARK
3030						CALLMONITOR 
3030 cd 6f ee			call debug_vector  
3033				endm  
# End of macro CALLMONITOR
3033					endif 
3033			 
3033					; Address 
3033			 
3033					FORTH_DSP_VALUEHL 
3033 cd 95 1d			call macro_dsp_valuehl 
3036				endm 
# End of macro FORTH_DSP_VALUEHL
3036			 
3036 e5					push hl    ; save address 
3037			 
3037					; load content into de 
3037			 
3037 5e					ld e,(hl) 
3038 23					inc hl 
3039 56					ld d, (hl) 
303a			 
303a					if DEBUG_FORTH_WORDS 
303a						DMARK "-2a" 
303a f5				push af  
303b 3a 4f 30			ld a, (.dmark)  
303e 32 65 ee			ld (debug_mark),a  
3041 3a 50 30			ld a, (.dmark+1)  
3044 32 66 ee			ld (debug_mark+1),a  
3047 3a 51 30			ld a, (.dmark+2)  
304a 32 67 ee			ld (debug_mark+2),a  
304d 18 03			jr .pastdmark  
304f ..			.dmark: db "-2a"  
3052 f1			.pastdmark: pop af  
3053			endm  
# End of macro DMARK
3053						CALLMONITOR 
3053 cd 6f ee			call debug_vector  
3056				endm  
# End of macro CALLMONITOR
3056					endif 
3056			 
3056					FORTH_DSP_POP 
3056 cd 4d 1e			call macro_forth_dsp_pop 
3059				endm 
# End of macro FORTH_DSP_POP
3059			 
3059					; Get value to remove 
3059			 
3059					FORTH_DSP_VALUE 
3059 cd 7e 1d			call macro_forth_dsp_value 
305c				endm 
# End of macro FORTH_DSP_VALUE
305c			 
305c					if DEBUG_FORTH_WORDS 
305c						DMARK "-2v" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 65 ee			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 66 ee			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 67 ee			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "-2v"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd 6f ee			call debug_vector  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078			 
3078 eb					ex de, hl 
3079 ed 52				sbc hl, de 
307b			 
307b					if DEBUG_FORTH_WORDS 
307b						DMARK "-2d" 
307b f5				push af  
307c 3a 90 30			ld a, (.dmark)  
307f 32 65 ee			ld (debug_mark),a  
3082 3a 91 30			ld a, (.dmark+1)  
3085 32 66 ee			ld (debug_mark+1),a  
3088 3a 92 30			ld a, (.dmark+2)  
308b 32 67 ee			ld (debug_mark+2),a  
308e 18 03			jr .pastdmark  
3090 ..			.dmark: db "-2d"  
3093 f1			.pastdmark: pop af  
3094			endm  
# End of macro DMARK
3094						CALLMONITOR 
3094 cd 6f ee			call debug_vector  
3097				endm  
# End of macro CALLMONITOR
3097					endif 
3097			 
3097					; move result to de 
3097			 
3097 eb					ex de, hl 
3098			 
3098					; Address 
3098			 
3098 e1					pop hl 
3099			 
3099					; save it back 
3099			 
3099 73					ld (hl), e 
309a 23					inc hl 
309b 72					ld (hl), d 
309c			 
309c					if DEBUG_FORTH_WORDS 
309c						DMARK "-2e" 
309c f5				push af  
309d 3a b1 30			ld a, (.dmark)  
30a0 32 65 ee			ld (debug_mark),a  
30a3 3a b2 30			ld a, (.dmark+1)  
30a6 32 66 ee			ld (debug_mark+1),a  
30a9 3a b3 30			ld a, (.dmark+2)  
30ac 32 67 ee			ld (debug_mark+2),a  
30af 18 03			jr .pastdmark  
30b1 ..			.dmark: db "-2e"  
30b4 f1			.pastdmark: pop af  
30b5			endm  
# End of macro DMARK
30b5						CALLMONITOR 
30b5 cd 6f ee			call debug_vector  
30b8				endm  
# End of macro CALLMONITOR
30b8					endif 
30b8			 
30b8			 
30b8					FORTH_DSP_POP 
30b8 cd 4d 1e			call macro_forth_dsp_pop 
30bb				endm 
# End of macro FORTH_DSP_POP
30bb			 
30bb			 
30bb			 
30bb				       NEXTW 
30bb c3 80 1f			jp macro_next 
30be				endm 
# End of macro NEXTW
30be			.GET2: 
30be				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30be 6f				db WORD_SYS_CORE+91             
30bf f3 30			dw .BANG2            
30c1 03				db 2 + 1 
30c2 .. 00			db "2@",0              
30c5				endm 
# End of macro CWHEAD
30c5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30c5					if DEBUG_FORTH_WORDS_KEY 
30c5						DMARK "2A_" 
30c5 f5				push af  
30c6 3a da 30			ld a, (.dmark)  
30c9 32 65 ee			ld (debug_mark),a  
30cc 3a db 30			ld a, (.dmark+1)  
30cf 32 66 ee			ld (debug_mark+1),a  
30d2 3a dc 30			ld a, (.dmark+2)  
30d5 32 67 ee			ld (debug_mark+2),a  
30d8 18 03			jr .pastdmark  
30da ..			.dmark: db "2A_"  
30dd f1			.pastdmark: pop af  
30de			endm  
# End of macro DMARK
30de						CALLMONITOR 
30de cd 6f ee			call debug_vector  
30e1				endm  
# End of macro CALLMONITOR
30e1					endif 
30e1			 
30e1					FORTH_DSP_VALUEHL 
30e1 cd 95 1d			call macro_dsp_valuehl 
30e4				endm 
# End of macro FORTH_DSP_VALUEHL
30e4			 
30e4 e5					push hl   ; save address 
30e5			 
30e5					FORTH_DSP_POP 
30e5 cd 4d 1e			call macro_forth_dsp_pop 
30e8				endm 
# End of macro FORTH_DSP_POP
30e8			 
30e8 e1					pop hl 
30e9			 
30e9 5e					ld e, (hl) 
30ea 23					inc hl 
30eb 56					ld d, (hl) 
30ec			 
30ec eb					ex de, hl 
30ed			 
30ed cd 90 1b				call forth_push_numhl 
30f0			 
30f0				       NEXTW 
30f0 c3 80 1f			jp macro_next 
30f3				endm 
# End of macro NEXTW
30f3			.BANG2: 
30f3				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30f3 6f				db WORD_SYS_CORE+91             
30f4 2b 31			dw .CONFIG            
30f6 03				db 2 + 1 
30f7 .. 00			db "2!",0              
30fa				endm 
# End of macro CWHEAD
30fa			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30fa					if DEBUG_FORTH_WORDS_KEY 
30fa						DMARK "2S_" 
30fa f5				push af  
30fb 3a 0f 31			ld a, (.dmark)  
30fe 32 65 ee			ld (debug_mark),a  
3101 3a 10 31			ld a, (.dmark+1)  
3104 32 66 ee			ld (debug_mark+1),a  
3107 3a 11 31			ld a, (.dmark+2)  
310a 32 67 ee			ld (debug_mark+2),a  
310d 18 03			jr .pastdmark  
310f ..			.dmark: db "2S_"  
3112 f1			.pastdmark: pop af  
3113			endm  
# End of macro DMARK
3113						CALLMONITOR 
3113 cd 6f ee			call debug_vector  
3116				endm  
# End of macro CALLMONITOR
3116					endif 
3116			 
3116					FORTH_DSP_VALUEHL 
3116 cd 95 1d			call macro_dsp_valuehl 
3119				endm 
# End of macro FORTH_DSP_VALUEHL
3119			 
3119 e5					push hl   ; save address 
311a			 
311a			 
311a					FORTH_DSP_POP 
311a cd 4d 1e			call macro_forth_dsp_pop 
311d				endm 
# End of macro FORTH_DSP_POP
311d			 
311d					 
311d					FORTH_DSP_VALUEHL 
311d cd 95 1d			call macro_dsp_valuehl 
3120				endm 
# End of macro FORTH_DSP_VALUEHL
3120			 
3120					FORTH_DSP_POP 
3120 cd 4d 1e			call macro_forth_dsp_pop 
3123				endm 
# End of macro FORTH_DSP_POP
3123			 
3123 eb					ex de, hl    ; value now in de 
3124			 
3124 e1					pop hl 
3125			 
3125 73					ld (hl), e 
3126			 
3126 23					inc hl 
3127			 
3127 72					ld (hl), d 
3128			 
3128			 
3128				       NEXTW 
3128 c3 80 1f			jp macro_next 
312b				endm 
# End of macro NEXTW
312b			.CONFIG: 
312b				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
312b 6f				db WORD_SYS_CORE+91             
312c 3c 31			dw .ADTOS            
312e 07				db 6 + 1 
312f .. 00			db "CONFIG",0              
3136				endm 
# End of macro CWHEAD
3136			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3136			 
3136 cd 69 13				call config 
3139					NEXTW 
3139 c3 80 1f			jp macro_next 
313c				endm 
# End of macro NEXTW
313c			 
313c			.ADTOS: 
313c				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
313c 6f				db WORD_SYS_CORE+91             
313d 52 31			dw .SBTOS            
313f 03				db 2 + 1 
3140 .. 00			db "1+",0              
3143				endm 
# End of macro CWHEAD
3143			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3143			 
3143					FORTH_DSP_VALUEHL 
3143 cd 95 1d			call macro_dsp_valuehl 
3146				endm 
# End of macro FORTH_DSP_VALUEHL
3146 e5					push hl 
3147			 
3147					FORTH_DSP_POP 
3147 cd 4d 1e			call macro_forth_dsp_pop 
314a				endm 
# End of macro FORTH_DSP_POP
314a e1					pop hl 
314b			 
314b 23					inc hl 
314c cd 90 1b				call forth_push_numhl 
314f					 
314f					NEXTW 
314f c3 80 1f			jp macro_next 
3152				endm 
# End of macro NEXTW
3152			.SBTOS: 
3152				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3152 6f				db WORD_SYS_CORE+91             
3153 68 31			dw .ADSTORE            
3155 03				db 2 + 1 
3156 .. 00			db "1-",0              
3159				endm 
# End of macro CWHEAD
3159			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3159			 
3159					FORTH_DSP_VALUEHL 
3159 cd 95 1d			call macro_dsp_valuehl 
315c				endm 
# End of macro FORTH_DSP_VALUEHL
315c e5					push hl 
315d			 
315d					FORTH_DSP_POP 
315d cd 4d 1e			call macro_forth_dsp_pop 
3160				endm 
# End of macro FORTH_DSP_POP
3160 e1					pop hl 
3161			 
3161 2b					dec hl 
3162 cd 90 1b				call forth_push_numhl 
3165					 
3165					NEXTW 
3165 c3 80 1f			jp macro_next 
3168				endm 
# End of macro NEXTW
3168			.ADSTORE: 
3168				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3168 6f				db WORD_SYS_CORE+91             
3169 7e 31			dw .ADWSTORE            
316b 04				db 3 + 1 
316c .. 00			db "1+!",0              
3170				endm 
# End of macro CWHEAD
3170			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3170			 
3170					FORTH_DSP_VALUEHL 
3170 cd 95 1d			call macro_dsp_valuehl 
3173				endm 
# End of macro FORTH_DSP_VALUEHL
3173 e5					push hl 
3174			 
3174					FORTH_DSP_POP 
3174 cd 4d 1e			call macro_forth_dsp_pop 
3177				endm 
# End of macro FORTH_DSP_POP
3177 e1					pop hl 
3178			 
3178 7e					ld a, (hl) 
3179 3c					inc a 
317a 77					ld (hl), a 
317b					 
317b					NEXTW 
317b c3 80 1f			jp macro_next 
317e				endm 
# End of macro NEXTW
317e			.ADWSTORE: 
317e				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
317e 6f				db WORD_SYS_CORE+91             
317f 9c 31			dw .SBSTORE            
3181 05				db 4 + 1 
3182 .. 00			db "1+2!",0              
3187				endm 
# End of macro CWHEAD
3187			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3187			 
3187					FORTH_DSP_VALUEHL 
3187 cd 95 1d			call macro_dsp_valuehl 
318a				endm 
# End of macro FORTH_DSP_VALUEHL
318a e5					push hl 
318b			 
318b					FORTH_DSP_POP 
318b cd 4d 1e			call macro_forth_dsp_pop 
318e				endm 
# End of macro FORTH_DSP_POP
318e e1					pop hl 
318f			 
318f e5					push hl 
3190			 
3190 cd 02 1f				call loadwordinhl 
3193 23					inc hl 
3194			 
3194 d1					pop de 
3195 eb					ex de, hl 
3196 73					ld (hl), e 
3197 23					inc hl 
3198 72					ld (hl), d 
3199					 
3199					NEXTW 
3199 c3 80 1f			jp macro_next 
319c				endm 
# End of macro NEXTW
319c			.SBSTORE: 
319c				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
319c 6f				db WORD_SYS_CORE+91             
319d b2 31			dw .SBWSTORE            
319f 04				db 3 + 1 
31a0 .. 00			db "1-!",0              
31a4				endm 
# End of macro CWHEAD
31a4			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
31a4			 
31a4					FORTH_DSP_VALUEHL 
31a4 cd 95 1d			call macro_dsp_valuehl 
31a7				endm 
# End of macro FORTH_DSP_VALUEHL
31a7 e5					push hl 
31a8			 
31a8					FORTH_DSP_POP 
31a8 cd 4d 1e			call macro_forth_dsp_pop 
31ab				endm 
# End of macro FORTH_DSP_POP
31ab e1					pop hl 
31ac			 
31ac 7e					ld a, (hl) 
31ad 3d					dec a 
31ae 77					ld (hl), a 
31af					 
31af					NEXTW 
31af c3 80 1f			jp macro_next 
31b2				endm 
# End of macro NEXTW
31b2			.SBWSTORE: 
31b2				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
31b2 6f				db WORD_SYS_CORE+91             
31b3 d0 31			dw .ENDCORE            
31b5 05				db 4 + 1 
31b6 .. 00			db "1-2!",0              
31bb				endm 
# End of macro CWHEAD
31bb			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
31bb			 
31bb					FORTH_DSP_VALUEHL 
31bb cd 95 1d			call macro_dsp_valuehl 
31be				endm 
# End of macro FORTH_DSP_VALUEHL
31be e5					push hl 
31bf			 
31bf					FORTH_DSP_POP 
31bf cd 4d 1e			call macro_forth_dsp_pop 
31c2				endm 
# End of macro FORTH_DSP_POP
31c2 e1					pop hl 
31c3			 
31c3 e5					push hl 
31c4			 
31c4 cd 02 1f				call loadwordinhl 
31c7 2b					dec hl 
31c8			 
31c8 d1					pop de 
31c9 eb					ex de, hl 
31ca 73					ld (hl), e 
31cb 23					inc hl 
31cc 72					ld (hl), d 
31cd					 
31cd					NEXTW 
31cd c3 80 1f			jp macro_next 
31d0				endm 
# End of macro NEXTW
31d0			.ENDCORE: 
31d0			 
31d0			; eof 
31d0			 
31d0			 
# End of file forth_words_core.asm
31d0			include "forth_words_flow.asm" 
31d0			 
31d0			; | ## Program Flow Words 
31d0			 
31d0			.IF: 
31d0				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31d0 1e				db WORD_SYS_CORE+10             
31d1 c5 32			dw .THEN            
31d3 03				db 2 + 1 
31d4 .. 00			db "IF",0              
31d7				endm 
# End of macro CWHEAD
31d7			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
31d7			; | | Note: currently not supporting ELSE or nested IF 
31d7			; 
31d7					if DEBUG_FORTH_WORDS_KEY 
31d7						DMARK "IF." 
31d7 f5				push af  
31d8 3a ec 31			ld a, (.dmark)  
31db 32 65 ee			ld (debug_mark),a  
31de 3a ed 31			ld a, (.dmark+1)  
31e1 32 66 ee			ld (debug_mark+1),a  
31e4 3a ee 31			ld a, (.dmark+2)  
31e7 32 67 ee			ld (debug_mark+2),a  
31ea 18 03			jr .pastdmark  
31ec ..			.dmark: db "IF."  
31ef f1			.pastdmark: pop af  
31f0			endm  
# End of macro DMARK
31f0						CALLMONITOR 
31f0 cd 6f ee			call debug_vector  
31f3				endm  
# End of macro CALLMONITOR
31f3					endif 
31f3			; eval TOS 
31f3			 
31f3				FORTH_DSP_VALUEHL 
31f3 cd 95 1d			call macro_dsp_valuehl 
31f6				endm 
# End of macro FORTH_DSP_VALUEHL
31f6			 
31f6			;	push hl 
31f6				FORTH_DSP_POP 
31f6 cd 4d 1e			call macro_forth_dsp_pop 
31f9				endm 
# End of macro FORTH_DSP_POP
31f9			;	pop hl 
31f9			 
31f9					if DEBUG_FORTH_WORDS 
31f9						DMARK "IF1" 
31f9 f5				push af  
31fa 3a 0e 32			ld a, (.dmark)  
31fd 32 65 ee			ld (debug_mark),a  
3200 3a 0f 32			ld a, (.dmark+1)  
3203 32 66 ee			ld (debug_mark+1),a  
3206 3a 10 32			ld a, (.dmark+2)  
3209 32 67 ee			ld (debug_mark+2),a  
320c 18 03			jr .pastdmark  
320e ..			.dmark: db "IF1"  
3211 f1			.pastdmark: pop af  
3212			endm  
# End of macro DMARK
3212						CALLMONITOR 
3212 cd 6f ee			call debug_vector  
3215				endm  
# End of macro CALLMONITOR
3215					endif 
3215 b7				or a        ; clear carry flag 
3216 11 00 00			ld de, 0 
3219 eb				ex de,hl 
321a ed 52			sbc hl, de 
321c c2 a6 32			jp nz, .iftrue 
321f			 
321f					if DEBUG_FORTH_WORDS 
321f						DMARK "IF2" 
321f f5				push af  
3220 3a 34 32			ld a, (.dmark)  
3223 32 65 ee			ld (debug_mark),a  
3226 3a 35 32			ld a, (.dmark+1)  
3229 32 66 ee			ld (debug_mark+1),a  
322c 3a 36 32			ld a, (.dmark+2)  
322f 32 67 ee			ld (debug_mark+2),a  
3232 18 03			jr .pastdmark  
3234 ..			.dmark: db "IF2"  
3237 f1			.pastdmark: pop af  
3238			endm  
# End of macro DMARK
3238						CALLMONITOR 
3238 cd 6f ee			call debug_vector  
323b				endm  
# End of macro CALLMONITOR
323b					endif 
323b			 
323b			; if not true then skip to THEN 
323b			 
323b				; TODO get tok_ptr 
323b				; TODO consume toks until we get to THEN 
323b			 
323b 2a bc e5			ld hl, (os_tok_ptr) 
323e					if DEBUG_FORTH_WORDS 
323e						DMARK "IF3" 
323e f5				push af  
323f 3a 53 32			ld a, (.dmark)  
3242 32 65 ee			ld (debug_mark),a  
3245 3a 54 32			ld a, (.dmark+1)  
3248 32 66 ee			ld (debug_mark+1),a  
324b 3a 55 32			ld a, (.dmark+2)  
324e 32 67 ee			ld (debug_mark+2),a  
3251 18 03			jr .pastdmark  
3253 ..			.dmark: db "IF3"  
3256 f1			.pastdmark: pop af  
3257			endm  
# End of macro DMARK
3257						CALLMONITOR 
3257 cd 6f ee			call debug_vector  
325a				endm  
# End of macro CALLMONITOR
325a						 
325a					endif 
325a 11 a1 32			ld de, .ifthen 
325d					if DEBUG_FORTH_WORDS 
325d						DMARK "IF4" 
325d f5				push af  
325e 3a 72 32			ld a, (.dmark)  
3261 32 65 ee			ld (debug_mark),a  
3264 3a 73 32			ld a, (.dmark+1)  
3267 32 66 ee			ld (debug_mark+1),a  
326a 3a 74 32			ld a, (.dmark+2)  
326d 32 67 ee			ld (debug_mark+2),a  
3270 18 03			jr .pastdmark  
3272 ..			.dmark: db "IF4"  
3275 f1			.pastdmark: pop af  
3276			endm  
# End of macro DMARK
3276						CALLMONITOR 
3276 cd 6f ee			call debug_vector  
3279				endm  
# End of macro CALLMONITOR
3279					endif 
3279 cd 87 20			call findnexttok  
327c			 
327c					if DEBUG_FORTH_WORDS 
327c						DMARK "IF5" 
327c f5				push af  
327d 3a 91 32			ld a, (.dmark)  
3280 32 65 ee			ld (debug_mark),a  
3283 3a 92 32			ld a, (.dmark+1)  
3286 32 66 ee			ld (debug_mark+1),a  
3289 3a 93 32			ld a, (.dmark+2)  
328c 32 67 ee			ld (debug_mark+2),a  
328f 18 03			jr .pastdmark  
3291 ..			.dmark: db "IF5"  
3294 f1			.pastdmark: pop af  
3295			endm  
# End of macro DMARK
3295						CALLMONITOR 
3295 cd 6f ee			call debug_vector  
3298				endm  
# End of macro CALLMONITOR
3298					endif 
3298				; TODO replace below with ; exec using tok_ptr 
3298 22 bc e5			ld (os_tok_ptr), hl 
329b c3 09 20			jp exec1 
329e				NEXTW 
329e c3 80 1f			jp macro_next 
32a1				endm 
# End of macro NEXTW
32a1			 
32a1 .. 00		.ifthen:  db "THEN",0 
32a6			 
32a6			.iftrue:		 
32a6				; Exec next words normally 
32a6			 
32a6				; if true then exec following IF as normal 
32a6					if DEBUG_FORTH_WORDS 
32a6						DMARK "IFT" 
32a6 f5				push af  
32a7 3a bb 32			ld a, (.dmark)  
32aa 32 65 ee			ld (debug_mark),a  
32ad 3a bc 32			ld a, (.dmark+1)  
32b0 32 66 ee			ld (debug_mark+1),a  
32b3 3a bd 32			ld a, (.dmark+2)  
32b6 32 67 ee			ld (debug_mark+2),a  
32b9 18 03			jr .pastdmark  
32bb ..			.dmark: db "IFT"  
32be f1			.pastdmark: pop af  
32bf			endm  
# End of macro DMARK
32bf						CALLMONITOR 
32bf cd 6f ee			call debug_vector  
32c2				endm  
# End of macro CALLMONITOR
32c2					endif 
32c2			 
32c2					NEXTW 
32c2 c3 80 1f			jp macro_next 
32c5				endm 
# End of macro NEXTW
32c5			.THEN: 
32c5				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32c5 1f				db WORD_SYS_CORE+11             
32c6 ed 32			dw .ELSE            
32c8 05				db 4 + 1 
32c9 .. 00			db "THEN",0              
32ce				endm 
# End of macro CWHEAD
32ce			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32ce					if DEBUG_FORTH_WORDS_KEY 
32ce						DMARK "THN" 
32ce f5				push af  
32cf 3a e3 32			ld a, (.dmark)  
32d2 32 65 ee			ld (debug_mark),a  
32d5 3a e4 32			ld a, (.dmark+1)  
32d8 32 66 ee			ld (debug_mark+1),a  
32db 3a e5 32			ld a, (.dmark+2)  
32de 32 67 ee			ld (debug_mark+2),a  
32e1 18 03			jr .pastdmark  
32e3 ..			.dmark: db "THN"  
32e6 f1			.pastdmark: pop af  
32e7			endm  
# End of macro DMARK
32e7						CALLMONITOR 
32e7 cd 6f ee			call debug_vector  
32ea				endm  
# End of macro CALLMONITOR
32ea					endif 
32ea					NEXTW 
32ea c3 80 1f			jp macro_next 
32ed				endm 
# End of macro NEXTW
32ed			.ELSE: 
32ed				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32ed 20				db WORD_SYS_CORE+12             
32ee 15 33			dw .DO            
32f0 03				db 2 + 1 
32f1 .. 00			db "ELSE",0              
32f6				endm 
# End of macro CWHEAD
32f6			; | ELSE ( -- ) Not supported - does nothing | TODO 
32f6			 
32f6					if DEBUG_FORTH_WORDS_KEY 
32f6						DMARK "ELS" 
32f6 f5				push af  
32f7 3a 0b 33			ld a, (.dmark)  
32fa 32 65 ee			ld (debug_mark),a  
32fd 3a 0c 33			ld a, (.dmark+1)  
3300 32 66 ee			ld (debug_mark+1),a  
3303 3a 0d 33			ld a, (.dmark+2)  
3306 32 67 ee			ld (debug_mark+2),a  
3309 18 03			jr .pastdmark  
330b ..			.dmark: db "ELS"  
330e f1			.pastdmark: pop af  
330f			endm  
# End of macro DMARK
330f						CALLMONITOR 
330f cd 6f ee			call debug_vector  
3312				endm  
# End of macro CALLMONITOR
3312					endif 
3312			 
3312			 
3312					NEXTW 
3312 c3 80 1f			jp macro_next 
3315				endm 
# End of macro NEXTW
3315			.DO: 
3315				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3315 21				db WORD_SYS_CORE+13             
3316 3c 34			dw .LOOP            
3318 03				db 2 + 1 
3319 .. 00			db "DO",0              
331c				endm 
# End of macro CWHEAD
331c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
331c			 
331c					if DEBUG_FORTH_WORDS_KEY 
331c						DMARK "DO." 
331c f5				push af  
331d 3a 31 33			ld a, (.dmark)  
3320 32 65 ee			ld (debug_mark),a  
3323 3a 32 33			ld a, (.dmark+1)  
3326 32 66 ee			ld (debug_mark+1),a  
3329 3a 33 33			ld a, (.dmark+2)  
332c 32 67 ee			ld (debug_mark+2),a  
332f 18 03			jr .pastdmark  
3331 ..			.dmark: db "DO."  
3334 f1			.pastdmark: pop af  
3335			endm  
# End of macro DMARK
3335						CALLMONITOR 
3335 cd 6f ee			call debug_vector  
3338				endm  
# End of macro CALLMONITOR
3338					endif 
3338			;  push pc to rsp stack past the DO 
3338			 
3338 2a bc e5				ld hl, (os_tok_ptr) 
333b 23					inc hl   ; D 
333c 23					inc hl  ; O 
333d 23					inc hl   ; null 
333e					if DEBUG_FORTH_WORDS 
333e						DMARK "DO2" 
333e f5				push af  
333f 3a 53 33			ld a, (.dmark)  
3342 32 65 ee			ld (debug_mark),a  
3345 3a 54 33			ld a, (.dmark+1)  
3348 32 66 ee			ld (debug_mark+1),a  
334b 3a 55 33			ld a, (.dmark+2)  
334e 32 67 ee			ld (debug_mark+2),a  
3351 18 03			jr .pastdmark  
3353 ..			.dmark: db "DO2"  
3356 f1			.pastdmark: pop af  
3357			endm  
# End of macro DMARK
3357						CALLMONITOR 
3357 cd 6f ee			call debug_vector  
335a				endm  
# End of macro CALLMONITOR
335a					endif 
335a					FORTH_RSP_NEXT 
335a cd 37 1b			call macro_forth_rsp_next 
335d				endm 
# End of macro FORTH_RSP_NEXT
335d					if DEBUG_FORTH_WORDS 
335d						DMARK "DO3" 
335d f5				push af  
335e 3a 72 33			ld a, (.dmark)  
3361 32 65 ee			ld (debug_mark),a  
3364 3a 73 33			ld a, (.dmark+1)  
3367 32 66 ee			ld (debug_mark+1),a  
336a 3a 74 33			ld a, (.dmark+2)  
336d 32 67 ee			ld (debug_mark+2),a  
3370 18 03			jr .pastdmark  
3372 ..			.dmark: db "DO3"  
3375 f1			.pastdmark: pop af  
3376			endm  
# End of macro DMARK
3376						CALLMONITOR 
3376 cd 6f ee			call debug_vector  
3379				endm  
# End of macro CALLMONITOR
3379					endif 
3379			 
3379					;if DEBUG_FORTH_WORDS 
3379				;		push hl 
3379			;		endif  
3379			 
3379			; get counters from data stack 
3379			 
3379			 
3379					FORTH_DSP_VALUEHL 
3379 cd 95 1d			call macro_dsp_valuehl 
337c				endm 
# End of macro FORTH_DSP_VALUEHL
337c e5					push hl		 ; hl now has starting counter which needs to be tos 
337d			 
337d					if DEBUG_FORTH_WORDS 
337d						DMARK "DO4" 
337d f5				push af  
337e 3a 92 33			ld a, (.dmark)  
3381 32 65 ee			ld (debug_mark),a  
3384 3a 93 33			ld a, (.dmark+1)  
3387 32 66 ee			ld (debug_mark+1),a  
338a 3a 94 33			ld a, (.dmark+2)  
338d 32 67 ee			ld (debug_mark+2),a  
3390 18 03			jr .pastdmark  
3392 ..			.dmark: db "DO4"  
3395 f1			.pastdmark: pop af  
3396			endm  
# End of macro DMARK
3396						CALLMONITOR 
3396 cd 6f ee			call debug_vector  
3399				endm  
# End of macro CALLMONITOR
3399					endif 
3399					FORTH_DSP_POP 
3399 cd 4d 1e			call macro_forth_dsp_pop 
339c				endm 
# End of macro FORTH_DSP_POP
339c			 
339c					if DEBUG_FORTH_WORDS 
339c						DMARK "DO5" 
339c f5				push af  
339d 3a b1 33			ld a, (.dmark)  
33a0 32 65 ee			ld (debug_mark),a  
33a3 3a b2 33			ld a, (.dmark+1)  
33a6 32 66 ee			ld (debug_mark+1),a  
33a9 3a b3 33			ld a, (.dmark+2)  
33ac 32 67 ee			ld (debug_mark+2),a  
33af 18 03			jr .pastdmark  
33b1 ..			.dmark: db "DO5"  
33b4 f1			.pastdmark: pop af  
33b5			endm  
# End of macro DMARK
33b5						CALLMONITOR 
33b5 cd 6f ee			call debug_vector  
33b8				endm  
# End of macro CALLMONITOR
33b8					endif 
33b8			 
33b8					FORTH_DSP_VALUEHL 
33b8 cd 95 1d			call macro_dsp_valuehl 
33bb				endm 
# End of macro FORTH_DSP_VALUEHL
33bb			;		push hl		 ; hl now has starting limit counter 
33bb			 
33bb					if DEBUG_FORTH_WORDS 
33bb						DMARK "DO6" 
33bb f5				push af  
33bc 3a d0 33			ld a, (.dmark)  
33bf 32 65 ee			ld (debug_mark),a  
33c2 3a d1 33			ld a, (.dmark+1)  
33c5 32 66 ee			ld (debug_mark+1),a  
33c8 3a d2 33			ld a, (.dmark+2)  
33cb 32 67 ee			ld (debug_mark+2),a  
33ce 18 03			jr .pastdmark  
33d0 ..			.dmark: db "DO6"  
33d3 f1			.pastdmark: pop af  
33d4			endm  
# End of macro DMARK
33d4						CALLMONITOR 
33d4 cd 6f ee			call debug_vector  
33d7				endm  
# End of macro CALLMONITOR
33d7					endif 
33d7					FORTH_DSP_POP 
33d7 cd 4d 1e			call macro_forth_dsp_pop 
33da				endm 
# End of macro FORTH_DSP_POP
33da			 
33da			; put counters on the loop stack 
33da			 
33da			;		pop hl			 ; limit counter 
33da d1					pop de			; start counter 
33db			 
33db					; push limit counter 
33db			 
33db					if DEBUG_FORTH_WORDS 
33db						DMARK "DO7" 
33db f5				push af  
33dc 3a f0 33			ld a, (.dmark)  
33df 32 65 ee			ld (debug_mark),a  
33e2 3a f1 33			ld a, (.dmark+1)  
33e5 32 66 ee			ld (debug_mark+1),a  
33e8 3a f2 33			ld a, (.dmark+2)  
33eb 32 67 ee			ld (debug_mark+2),a  
33ee 18 03			jr .pastdmark  
33f0 ..			.dmark: db "DO7"  
33f3 f1			.pastdmark: pop af  
33f4			endm  
# End of macro DMARK
33f4						CALLMONITOR 
33f4 cd 6f ee			call debug_vector  
33f7				endm  
# End of macro CALLMONITOR
33f7					endif 
33f7					FORTH_LOOP_NEXT 
33f7 cd c6 1d			call macro_forth_loop_next 
33fa				endm 
# End of macro FORTH_LOOP_NEXT
33fa			 
33fa					; push start counter 
33fa			 
33fa eb					ex de, hl 
33fb					if DEBUG_FORTH_WORDS 
33fb						DMARK "DO7" 
33fb f5				push af  
33fc 3a 10 34			ld a, (.dmark)  
33ff 32 65 ee			ld (debug_mark),a  
3402 3a 11 34			ld a, (.dmark+1)  
3405 32 66 ee			ld (debug_mark+1),a  
3408 3a 12 34			ld a, (.dmark+2)  
340b 32 67 ee			ld (debug_mark+2),a  
340e 18 03			jr .pastdmark  
3410 ..			.dmark: db "DO7"  
3413 f1			.pastdmark: pop af  
3414			endm  
# End of macro DMARK
3414						CALLMONITOR 
3414 cd 6f ee			call debug_vector  
3417				endm  
# End of macro CALLMONITOR
3417					endif 
3417					FORTH_LOOP_NEXT 
3417 cd c6 1d			call macro_forth_loop_next 
341a				endm 
# End of macro FORTH_LOOP_NEXT
341a			 
341a			 
341a					; init first round of I counter 
341a			 
341a 22 e0 e5				ld (os_current_i), hl 
341d			 
341d					if DEBUG_FORTH_WORDS 
341d						DMARK "DO8" 
341d f5				push af  
341e 3a 32 34			ld a, (.dmark)  
3421 32 65 ee			ld (debug_mark),a  
3424 3a 33 34			ld a, (.dmark+1)  
3427 32 66 ee			ld (debug_mark+1),a  
342a 3a 34 34			ld a, (.dmark+2)  
342d 32 67 ee			ld (debug_mark+2),a  
3430 18 03			jr .pastdmark  
3432 ..			.dmark: db "DO8"  
3435 f1			.pastdmark: pop af  
3436			endm  
# End of macro DMARK
3436						CALLMONITOR 
3436 cd 6f ee			call debug_vector  
3439				endm  
# End of macro CALLMONITOR
3439					endif 
3439			 
3439					NEXTW 
3439 c3 80 1f			jp macro_next 
343c				endm 
# End of macro NEXTW
343c			.LOOP: 
343c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
343c 22				db WORD_SYS_CORE+14             
343d 54 35			dw .I            
343f 05				db 4 + 1 
3440 .. 00			db "LOOP",0              
3445				endm 
# End of macro CWHEAD
3445			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3445			 
3445				; pop tos as current loop count to hl 
3445			 
3445				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3445			 
3445				FORTH_LOOP_TOS 
3445 cd f9 1d			call macro_forth_loop_tos 
3448				endm 
# End of macro FORTH_LOOP_TOS
3448 e5				push hl 
3449			 
3449					if DEBUG_FORTH_WORDS_KEY 
3449						DMARK "LOP" 
3449 f5				push af  
344a 3a 5e 34			ld a, (.dmark)  
344d 32 65 ee			ld (debug_mark),a  
3450 3a 5f 34			ld a, (.dmark+1)  
3453 32 66 ee			ld (debug_mark+1),a  
3456 3a 60 34			ld a, (.dmark+2)  
3459 32 67 ee			ld (debug_mark+2),a  
345c 18 03			jr .pastdmark  
345e ..			.dmark: db "LOP"  
3461 f1			.pastdmark: pop af  
3462			endm  
# End of macro DMARK
3462						CALLMONITOR 
3462 cd 6f ee			call debug_vector  
3465				endm  
# End of macro CALLMONITOR
3465					endif 
3465				; next item on the stack is the limit. get it 
3465			 
3465			 
3465				FORTH_LOOP_POP 
3465 cd 03 1e			call macro_forth_loop_pop 
3468				endm 
# End of macro FORTH_LOOP_POP
3468			 
3468				FORTH_LOOP_TOS 
3468 cd f9 1d			call macro_forth_loop_tos 
346b				endm 
# End of macro FORTH_LOOP_TOS
346b			 
346b d1				pop de		 ; de = i, hl = limit 
346c			 
346c					if DEBUG_FORTH_WORDS 
346c						DMARK "LP1" 
346c f5				push af  
346d 3a 81 34			ld a, (.dmark)  
3470 32 65 ee			ld (debug_mark),a  
3473 3a 82 34			ld a, (.dmark+1)  
3476 32 66 ee			ld (debug_mark+1),a  
3479 3a 83 34			ld a, (.dmark+2)  
347c 32 67 ee			ld (debug_mark+2),a  
347f 18 03			jr .pastdmark  
3481 ..			.dmark: db "LP1"  
3484 f1			.pastdmark: pop af  
3485			endm  
# End of macro DMARK
3485						CALLMONITOR 
3485 cd 6f ee			call debug_vector  
3488				endm  
# End of macro CALLMONITOR
3488					endif 
3488			 
3488				; go back to previous word 
3488			 
3488 d5				push de    ; save I for inc later 
3489			 
3489			 
3489				; get limit 
3489				;  is I at limit? 
3489			 
3489			 
3489					if DEBUG_FORTH_WORDS 
3489						DMARK "LP1" 
3489 f5				push af  
348a 3a 9e 34			ld a, (.dmark)  
348d 32 65 ee			ld (debug_mark),a  
3490 3a 9f 34			ld a, (.dmark+1)  
3493 32 66 ee			ld (debug_mark+1),a  
3496 3a a0 34			ld a, (.dmark+2)  
3499 32 67 ee			ld (debug_mark+2),a  
349c 18 03			jr .pastdmark  
349e ..			.dmark: db "LP1"  
34a1 f1			.pastdmark: pop af  
34a2			endm  
# End of macro DMARK
34a2						CALLMONITOR 
34a2 cd 6f ee			call debug_vector  
34a5				endm  
# End of macro CALLMONITOR
34a5					endif 
34a5			 
34a5 ed 52			sbc hl, de 
34a7			 
34a7			 
34a7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34a7			 
34a7 20 26				jr nz, .loopnotdone 
34a9			 
34a9 e1				pop hl   ; get rid of saved I 
34aa				FORTH_LOOP_POP     ; get rid of limit 
34aa cd 03 1e			call macro_forth_loop_pop 
34ad				endm 
# End of macro FORTH_LOOP_POP
34ad			 
34ad				FORTH_RSP_POP     ; get rid of DO ptr 
34ad cd 58 1b			call macro_forth_rsp_pop 
34b0				endm 
# End of macro FORTH_RSP_POP
34b0			 
34b0			if DEBUG_FORTH_WORDS 
34b0						DMARK "LP>" 
34b0 f5				push af  
34b1 3a c5 34			ld a, (.dmark)  
34b4 32 65 ee			ld (debug_mark),a  
34b7 3a c6 34			ld a, (.dmark+1)  
34ba 32 66 ee			ld (debug_mark+1),a  
34bd 3a c7 34			ld a, (.dmark+2)  
34c0 32 67 ee			ld (debug_mark+2),a  
34c3 18 03			jr .pastdmark  
34c5 ..			.dmark: db "LP>"  
34c8 f1			.pastdmark: pop af  
34c9			endm  
# End of macro DMARK
34c9				CALLMONITOR 
34c9 cd 6f ee			call debug_vector  
34cc				endm  
# End of macro CALLMONITOR
34cc			endif 
34cc			 
34cc					NEXTW 
34cc c3 80 1f			jp macro_next 
34cf				endm 
# End of macro NEXTW
34cf				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34cf			 
34cf			.loopnotdone: 
34cf			 
34cf e1				pop hl    ; get I 
34d0 23				inc hl 
34d1			 
34d1			   	; save new I 
34d1			 
34d1			 
34d1					; set I counter 
34d1			 
34d1 22 e0 e5				ld (os_current_i), hl 
34d4			 
34d4					if DEBUG_FORTH_WORDS 
34d4						DMARK "LPN" 
34d4 f5				push af  
34d5 3a e9 34			ld a, (.dmark)  
34d8 32 65 ee			ld (debug_mark),a  
34db 3a ea 34			ld a, (.dmark+1)  
34de 32 66 ee			ld (debug_mark+1),a  
34e1 3a eb 34			ld a, (.dmark+2)  
34e4 32 67 ee			ld (debug_mark+2),a  
34e7 18 03			jr .pastdmark  
34e9 ..			.dmark: db "LPN"  
34ec f1			.pastdmark: pop af  
34ed			endm  
# End of macro DMARK
34ed					CALLMONITOR 
34ed cd 6f ee			call debug_vector  
34f0				endm  
# End of macro CALLMONITOR
34f0					endif 
34f0					 
34f0				FORTH_LOOP_NEXT 
34f0 cd c6 1d			call macro_forth_loop_next 
34f3				endm 
# End of macro FORTH_LOOP_NEXT
34f3			 
34f3			 
34f3					if DEBUG_FORTH_WORDS 
34f3 eb						ex de,hl 
34f4					endif 
34f4			 
34f4			;	; get DO ptr 
34f4			; 
34f4					if DEBUG_FORTH_WORDS 
34f4						DMARK "LP7" 
34f4 f5				push af  
34f5 3a 09 35			ld a, (.dmark)  
34f8 32 65 ee			ld (debug_mark),a  
34fb 3a 0a 35			ld a, (.dmark+1)  
34fe 32 66 ee			ld (debug_mark+1),a  
3501 3a 0b 35			ld a, (.dmark+2)  
3504 32 67 ee			ld (debug_mark+2),a  
3507 18 03			jr .pastdmark  
3509 ..			.dmark: db "LP7"  
350c f1			.pastdmark: pop af  
350d			endm  
# End of macro DMARK
350d					CALLMONITOR 
350d cd 6f ee			call debug_vector  
3510				endm  
# End of macro CALLMONITOR
3510					endif 
3510				FORTH_RSP_TOS 
3510 cd 4e 1b			call macro_forth_rsp_tos 
3513				endm 
# End of macro FORTH_RSP_TOS
3513			 
3513					if DEBUG_FORTH_WORDS 
3513						DMARK "LP8" 
3513 f5				push af  
3514 3a 28 35			ld a, (.dmark)  
3517 32 65 ee			ld (debug_mark),a  
351a 3a 29 35			ld a, (.dmark+1)  
351d 32 66 ee			ld (debug_mark+1),a  
3520 3a 2a 35			ld a, (.dmark+2)  
3523 32 67 ee			ld (debug_mark+2),a  
3526 18 03			jr .pastdmark  
3528 ..			.dmark: db "LP8"  
352b f1			.pastdmark: pop af  
352c			endm  
# End of macro DMARK
352c					CALLMONITOR 
352c cd 6f ee			call debug_vector  
352f				endm  
# End of macro CALLMONITOR
352f					endif 
352f				;push hl 
352f			 
352f				; not going to DO any more 
352f				; get rid of the RSP pointer as DO will add it back in 
352f				;FORTH_RSP_POP 
352f				;pop hl 
352f			 
352f				;ld hl,(cli_ret_sp) 
352f				;ld e, (hl) 
352f				;inc hl 
352f				;ld d, (hl) 
352f				;ex de,hl 
352f 22 bc e5			ld (os_tok_ptr), hl 
3532					if DEBUG_FORTH_WORDS 
3532						DMARK "LP<" 
3532 f5				push af  
3533 3a 47 35			ld a, (.dmark)  
3536 32 65 ee			ld (debug_mark),a  
3539 3a 48 35			ld a, (.dmark+1)  
353c 32 66 ee			ld (debug_mark+1),a  
353f 3a 49 35			ld a, (.dmark+2)  
3542 32 67 ee			ld (debug_mark+2),a  
3545 18 03			jr .pastdmark  
3547 ..			.dmark: db "LP<"  
354a f1			.pastdmark: pop af  
354b			endm  
# End of macro DMARK
354b					CALLMONITOR 
354b cd 6f ee			call debug_vector  
354e				endm  
# End of macro CALLMONITOR
354e				endif 
354e c3 09 20			jp exec1 
3551			 
3551					 
3551			 
3551			 
3551					NEXTW 
3551 c3 80 1f			jp macro_next 
3554				endm 
# End of macro NEXTW
3554			.I:  
3554			 
3554				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3554 5e				db WORD_SYS_CORE+74             
3555 7f 35			dw .DLOOP            
3557 02				db 1 + 1 
3558 .. 00			db "I",0              
355a				endm 
# End of macro CWHEAD
355a			; | I ( -- ) Current loop counter | DONE 
355a					if DEBUG_FORTH_WORDS_KEY 
355a						DMARK "I.." 
355a f5				push af  
355b 3a 6f 35			ld a, (.dmark)  
355e 32 65 ee			ld (debug_mark),a  
3561 3a 70 35			ld a, (.dmark+1)  
3564 32 66 ee			ld (debug_mark+1),a  
3567 3a 71 35			ld a, (.dmark+2)  
356a 32 67 ee			ld (debug_mark+2),a  
356d 18 03			jr .pastdmark  
356f ..			.dmark: db "I.."  
3572 f1			.pastdmark: pop af  
3573			endm  
# End of macro DMARK
3573						CALLMONITOR 
3573 cd 6f ee			call debug_vector  
3576				endm  
# End of macro CALLMONITOR
3576					endif 
3576			 
3576 2a e0 e5				ld hl,(os_current_i) 
3579 cd 90 1b				call forth_push_numhl 
357c			 
357c					NEXTW 
357c c3 80 1f			jp macro_next 
357f				endm 
# End of macro NEXTW
357f			.DLOOP: 
357f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
357f 5f				db WORD_SYS_CORE+75             
3580 60 36			dw .REPEAT            
3582 06				db 5 + 1 
3583 .. 00			db "-LOOP",0              
3589				endm 
# End of macro CWHEAD
3589			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3589				; pop tos as current loop count to hl 
3589					if DEBUG_FORTH_WORDS_KEY 
3589						DMARK "-LP" 
3589 f5				push af  
358a 3a 9e 35			ld a, (.dmark)  
358d 32 65 ee			ld (debug_mark),a  
3590 3a 9f 35			ld a, (.dmark+1)  
3593 32 66 ee			ld (debug_mark+1),a  
3596 3a a0 35			ld a, (.dmark+2)  
3599 32 67 ee			ld (debug_mark+2),a  
359c 18 03			jr .pastdmark  
359e ..			.dmark: db "-LP"  
35a1 f1			.pastdmark: pop af  
35a2			endm  
# End of macro DMARK
35a2						CALLMONITOR 
35a2 cd 6f ee			call debug_vector  
35a5				endm  
# End of macro CALLMONITOR
35a5					endif 
35a5			 
35a5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35a5			 
35a5				FORTH_LOOP_TOS 
35a5 cd f9 1d			call macro_forth_loop_tos 
35a8				endm 
# End of macro FORTH_LOOP_TOS
35a8 e5				push hl 
35a9			 
35a9					if DEBUG_FORTH_WORDS 
35a9						DMARK "-LP" 
35a9 f5				push af  
35aa 3a be 35			ld a, (.dmark)  
35ad 32 65 ee			ld (debug_mark),a  
35b0 3a bf 35			ld a, (.dmark+1)  
35b3 32 66 ee			ld (debug_mark+1),a  
35b6 3a c0 35			ld a, (.dmark+2)  
35b9 32 67 ee			ld (debug_mark+2),a  
35bc 18 03			jr .pastdmark  
35be ..			.dmark: db "-LP"  
35c1 f1			.pastdmark: pop af  
35c2			endm  
# End of macro DMARK
35c2						CALLMONITOR 
35c2 cd 6f ee			call debug_vector  
35c5				endm  
# End of macro CALLMONITOR
35c5					endif 
35c5				; next item on the stack is the limit. get it 
35c5			 
35c5			 
35c5				FORTH_LOOP_POP 
35c5 cd 03 1e			call macro_forth_loop_pop 
35c8				endm 
# End of macro FORTH_LOOP_POP
35c8			 
35c8				FORTH_LOOP_TOS 
35c8 cd f9 1d			call macro_forth_loop_tos 
35cb				endm 
# End of macro FORTH_LOOP_TOS
35cb			 
35cb d1				pop de		 ; de = i, hl = limit 
35cc			 
35cc					if DEBUG_FORTH_WORDS 
35cc						DMARK "-L1" 
35cc f5				push af  
35cd 3a e1 35			ld a, (.dmark)  
35d0 32 65 ee			ld (debug_mark),a  
35d3 3a e2 35			ld a, (.dmark+1)  
35d6 32 66 ee			ld (debug_mark+1),a  
35d9 3a e3 35			ld a, (.dmark+2)  
35dc 32 67 ee			ld (debug_mark+2),a  
35df 18 03			jr .pastdmark  
35e1 ..			.dmark: db "-L1"  
35e4 f1			.pastdmark: pop af  
35e5			endm  
# End of macro DMARK
35e5						CALLMONITOR 
35e5 cd 6f ee			call debug_vector  
35e8				endm  
# End of macro CALLMONITOR
35e8					endif 
35e8			 
35e8				; go back to previous word 
35e8			 
35e8 d5				push de    ; save I for inc later 
35e9			 
35e9			 
35e9				; get limit 
35e9				;  is I at limit? 
35e9			 
35e9			 
35e9					if DEBUG_FORTH_WORDS 
35e9						DMARK "-L1" 
35e9 f5				push af  
35ea 3a fe 35			ld a, (.dmark)  
35ed 32 65 ee			ld (debug_mark),a  
35f0 3a ff 35			ld a, (.dmark+1)  
35f3 32 66 ee			ld (debug_mark+1),a  
35f6 3a 00 36			ld a, (.dmark+2)  
35f9 32 67 ee			ld (debug_mark+2),a  
35fc 18 03			jr .pastdmark  
35fe ..			.dmark: db "-L1"  
3601 f1			.pastdmark: pop af  
3602			endm  
# End of macro DMARK
3602						CALLMONITOR 
3602 cd 6f ee			call debug_vector  
3605				endm  
# End of macro CALLMONITOR
3605					endif 
3605			 
3605 ed 52			sbc hl, de 
3607			 
3607			 
3607				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3607			 
3607 20 26				jr nz, .mloopnotdone 
3609			 
3609 e1				pop hl   ; get rid of saved I 
360a				FORTH_LOOP_POP     ; get rid of limit 
360a cd 03 1e			call macro_forth_loop_pop 
360d				endm 
# End of macro FORTH_LOOP_POP
360d			 
360d				FORTH_RSP_POP     ; get rid of DO ptr 
360d cd 58 1b			call macro_forth_rsp_pop 
3610				endm 
# End of macro FORTH_RSP_POP
3610			 
3610			if DEBUG_FORTH_WORDS 
3610						DMARK "-L>" 
3610 f5				push af  
3611 3a 25 36			ld a, (.dmark)  
3614 32 65 ee			ld (debug_mark),a  
3617 3a 26 36			ld a, (.dmark+1)  
361a 32 66 ee			ld (debug_mark+1),a  
361d 3a 27 36			ld a, (.dmark+2)  
3620 32 67 ee			ld (debug_mark+2),a  
3623 18 03			jr .pastdmark  
3625 ..			.dmark: db "-L>"  
3628 f1			.pastdmark: pop af  
3629			endm  
# End of macro DMARK
3629				CALLMONITOR 
3629 cd 6f ee			call debug_vector  
362c				endm  
# End of macro CALLMONITOR
362c			endif 
362c			 
362c					NEXTW 
362c c3 80 1f			jp macro_next 
362f				endm 
# End of macro NEXTW
362f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
362f			 
362f			.mloopnotdone: 
362f			 
362f e1				pop hl    ; get I 
3630 2b				dec hl 
3631			 
3631			   	; save new I 
3631			 
3631			 
3631					; set I counter 
3631			 
3631 22 e0 e5				ld (os_current_i), hl 
3634			 
3634					 
3634				FORTH_LOOP_NEXT 
3634 cd c6 1d			call macro_forth_loop_next 
3637				endm 
# End of macro FORTH_LOOP_NEXT
3637			 
3637			 
3637					if DEBUG_FORTH_WORDS 
3637 eb						ex de,hl 
3638					endif 
3638			 
3638			;	; get DO ptr 
3638			; 
3638				FORTH_RSP_TOS 
3638 cd 4e 1b			call macro_forth_rsp_tos 
363b				endm 
# End of macro FORTH_RSP_TOS
363b			 
363b				;push hl 
363b			 
363b				; not going to DO any more 
363b				; get rid of the RSP pointer as DO will add it back in 
363b				;FORTH_RSP_POP 
363b				;pop hl 
363b			 
363b			 
363b 22 bc e5			ld (os_tok_ptr), hl 
363e					if DEBUG_FORTH_WORDS 
363e						DMARK "-L<" 
363e f5				push af  
363f 3a 53 36			ld a, (.dmark)  
3642 32 65 ee			ld (debug_mark),a  
3645 3a 54 36			ld a, (.dmark+1)  
3648 32 66 ee			ld (debug_mark+1),a  
364b 3a 55 36			ld a, (.dmark+2)  
364e 32 67 ee			ld (debug_mark+2),a  
3651 18 03			jr .pastdmark  
3653 ..			.dmark: db "-L<"  
3656 f1			.pastdmark: pop af  
3657			endm  
# End of macro DMARK
3657					CALLMONITOR 
3657 cd 6f ee			call debug_vector  
365a				endm  
# End of macro CALLMONITOR
365a				endif 
365a c3 09 20			jp exec1 
365d			 
365d					 
365d			 
365d			 
365d			 
365d				NEXTW 
365d c3 80 1f			jp macro_next 
3660				endm 
# End of macro NEXTW
3660			 
3660			 
3660			 
3660			 
3660			.REPEAT: 
3660				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3660 71				db WORD_SYS_CORE+93             
3661 b3 36			dw .UNTIL            
3663 06				db 5 + 1 
3664 .. 00			db "REPEAT",0              
366b				endm 
# End of macro CWHEAD
366b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
366b			;  push pc to rsp stack past the REPEAT 
366b					if DEBUG_FORTH_WORDS_KEY 
366b						DMARK "REP" 
366b f5				push af  
366c 3a 80 36			ld a, (.dmark)  
366f 32 65 ee			ld (debug_mark),a  
3672 3a 81 36			ld a, (.dmark+1)  
3675 32 66 ee			ld (debug_mark+1),a  
3678 3a 82 36			ld a, (.dmark+2)  
367b 32 67 ee			ld (debug_mark+2),a  
367e 18 03			jr .pastdmark  
3680 ..			.dmark: db "REP"  
3683 f1			.pastdmark: pop af  
3684			endm  
# End of macro DMARK
3684						CALLMONITOR 
3684 cd 6f ee			call debug_vector  
3687				endm  
# End of macro CALLMONITOR
3687					endif 
3687			 
3687 2a bc e5				ld hl, (os_tok_ptr) 
368a 23					inc hl   ; R 
368b 23					inc hl  ; E 
368c 23					inc hl   ; P 
368d 23					inc hl   ; E 
368e 23					inc hl   ; A 
368f 23					inc hl   ; T 
3690 23					inc hl   ; zero 
3691					FORTH_RSP_NEXT 
3691 cd 37 1b			call macro_forth_rsp_next 
3694				endm 
# End of macro FORTH_RSP_NEXT
3694			 
3694			 
3694					if DEBUG_FORTH_WORDS 
3694						DMARK "REP" 
3694 f5				push af  
3695 3a a9 36			ld a, (.dmark)  
3698 32 65 ee			ld (debug_mark),a  
369b 3a aa 36			ld a, (.dmark+1)  
369e 32 66 ee			ld (debug_mark+1),a  
36a1 3a ab 36			ld a, (.dmark+2)  
36a4 32 67 ee			ld (debug_mark+2),a  
36a7 18 03			jr .pastdmark  
36a9 ..			.dmark: db "REP"  
36ac f1			.pastdmark: pop af  
36ad			endm  
# End of macro DMARK
36ad						;pop bc    ; TODO BUG ?????? what is this for???? 
36ad						CALLMONITOR 
36ad cd 6f ee			call debug_vector  
36b0				endm  
# End of macro CALLMONITOR
36b0					endif 
36b0			 
36b0					NEXTW 
36b0 c3 80 1f			jp macro_next 
36b3				endm 
# End of macro NEXTW
36b3			;	       NEXTW 
36b3			 
36b3			.UNTIL: 
36b3				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36b3 72				db WORD_SYS_CORE+94             
36b4 4a 37			dw .ENDFLOW            
36b6 06				db 5 + 1 
36b7 .. 00			db "UNTIL",0              
36bd				endm 
# End of macro CWHEAD
36bd			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36bd			 
36bd				; pop tos as check 
36bd			 
36bd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36bd			 
36bd				FORTH_DSP_VALUEHL 
36bd cd 95 1d			call macro_dsp_valuehl 
36c0				endm 
# End of macro FORTH_DSP_VALUEHL
36c0			 
36c0					if DEBUG_FORTH_WORDS_KEY 
36c0						DMARK "UNT" 
36c0 f5				push af  
36c1 3a d5 36			ld a, (.dmark)  
36c4 32 65 ee			ld (debug_mark),a  
36c7 3a d6 36			ld a, (.dmark+1)  
36ca 32 66 ee			ld (debug_mark+1),a  
36cd 3a d7 36			ld a, (.dmark+2)  
36d0 32 67 ee			ld (debug_mark+2),a  
36d3 18 03			jr .pastdmark  
36d5 ..			.dmark: db "UNT"  
36d8 f1			.pastdmark: pop af  
36d9			endm  
# End of macro DMARK
36d9						CALLMONITOR 
36d9 cd 6f ee			call debug_vector  
36dc				endm  
# End of macro CALLMONITOR
36dc					endif 
36dc			 
36dc			;	push hl 
36dc				FORTH_DSP_POP 
36dc cd 4d 1e			call macro_forth_dsp_pop 
36df				endm 
# End of macro FORTH_DSP_POP
36df			 
36df			;	pop hl 
36df			 
36df				; test if true 
36df			 
36df cd 1e 0e			call ishlzero 
36e2			;	ld a,l 
36e2			;	add h 
36e2			; 
36e2			;	cp 0 
36e2			 
36e2 20 3e			jr nz, .untilnotdone 
36e4			 
36e4					if DEBUG_FORTH_WORDS 
36e4						DMARK "UNf" 
36e4 f5				push af  
36e5 3a f9 36			ld a, (.dmark)  
36e8 32 65 ee			ld (debug_mark),a  
36eb 3a fa 36			ld a, (.dmark+1)  
36ee 32 66 ee			ld (debug_mark+1),a  
36f1 3a fb 36			ld a, (.dmark+2)  
36f4 32 67 ee			ld (debug_mark+2),a  
36f7 18 03			jr .pastdmark  
36f9 ..			.dmark: db "UNf"  
36fc f1			.pastdmark: pop af  
36fd			endm  
# End of macro DMARK
36fd						CALLMONITOR 
36fd cd 6f ee			call debug_vector  
3700				endm  
# End of macro CALLMONITOR
3700					endif 
3700			 
3700			 
3700			 
3700				FORTH_RSP_POP     ; get rid of DO ptr 
3700 cd 58 1b			call macro_forth_rsp_pop 
3703				endm 
# End of macro FORTH_RSP_POP
3703			 
3703			if DEBUG_FORTH_WORDS 
3703						DMARK "UN>" 
3703 f5				push af  
3704 3a 18 37			ld a, (.dmark)  
3707 32 65 ee			ld (debug_mark),a  
370a 3a 19 37			ld a, (.dmark+1)  
370d 32 66 ee			ld (debug_mark+1),a  
3710 3a 1a 37			ld a, (.dmark+2)  
3713 32 67 ee			ld (debug_mark+2),a  
3716 18 03			jr .pastdmark  
3718 ..			.dmark: db "UN>"  
371b f1			.pastdmark: pop af  
371c			endm  
# End of macro DMARK
371c				CALLMONITOR 
371c cd 6f ee			call debug_vector  
371f				endm  
# End of macro CALLMONITOR
371f			endif 
371f			 
371f					NEXTW 
371f c3 80 1f			jp macro_next 
3722				endm 
# End of macro NEXTW
3722				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3722			 
3722			.untilnotdone: 
3722			 
3722			 
3722			;	; get DO ptr 
3722			; 
3722				FORTH_RSP_TOS 
3722 cd 4e 1b			call macro_forth_rsp_tos 
3725				endm 
# End of macro FORTH_RSP_TOS
3725			 
3725				;push hl 
3725			 
3725				; not going to DO any more 
3725				; get rid of the RSP pointer as DO will add it back in 
3725				;FORTH_RSP_POP 
3725				;pop hl 
3725			 
3725			 
3725 22 bc e5			ld (os_tok_ptr), hl 
3728					if DEBUG_FORTH_WORDS 
3728						DMARK "UN<" 
3728 f5				push af  
3729 3a 3d 37			ld a, (.dmark)  
372c 32 65 ee			ld (debug_mark),a  
372f 3a 3e 37			ld a, (.dmark+1)  
3732 32 66 ee			ld (debug_mark+1),a  
3735 3a 3f 37			ld a, (.dmark+2)  
3738 32 67 ee			ld (debug_mark+2),a  
373b 18 03			jr .pastdmark  
373d ..			.dmark: db "UN<"  
3740 f1			.pastdmark: pop af  
3741			endm  
# End of macro DMARK
3741					CALLMONITOR 
3741 cd 6f ee			call debug_vector  
3744				endm  
# End of macro CALLMONITOR
3744				endif 
3744 c3 09 20			jp exec1 
3747			 
3747					 
3747			 
3747			 
3747					NEXTW 
3747 c3 80 1f			jp macro_next 
374a				endm 
# End of macro NEXTW
374a			 
374a			 
374a			.ENDFLOW: 
374a			 
374a			; eof 
374a			 
# End of file forth_words_flow.asm
374a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
374a			include "forth_words_logic.asm" 
374a			 
374a			; | ## Logic Words 
374a			 
374a			.NOT: 
374a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
374a 2d				db WORD_SYS_CORE+25             
374b 92 37			dw .IS            
374d 04				db 3 + 1 
374e .. 00			db "NOT",0              
3752				endm 
# End of macro CWHEAD
3752			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3752					if DEBUG_FORTH_WORDS_KEY 
3752						DMARK "NOT" 
3752 f5				push af  
3753 3a 67 37			ld a, (.dmark)  
3756 32 65 ee			ld (debug_mark),a  
3759 3a 68 37			ld a, (.dmark+1)  
375c 32 66 ee			ld (debug_mark+1),a  
375f 3a 69 37			ld a, (.dmark+2)  
3762 32 67 ee			ld (debug_mark+2),a  
3765 18 03			jr .pastdmark  
3767 ..			.dmark: db "NOT"  
376a f1			.pastdmark: pop af  
376b			endm  
# End of macro DMARK
376b						CALLMONITOR 
376b cd 6f ee			call debug_vector  
376e				endm  
# End of macro CALLMONITOR
376e					endif 
376e					FORTH_DSP 
376e cd 5b 1d			call macro_forth_dsp 
3771				endm 
# End of macro FORTH_DSP
3771 7e					ld a,(hl)	; get type of value on TOS 
3772 fe 02				cp DS_TYPE_INUM  
3774 28 03				jr z, .noti 
3776					NEXTW 
3776 c3 80 1f			jp macro_next 
3779				endm 
# End of macro NEXTW
3779			.noti:          FORTH_DSP_VALUEHL 
3779 cd 95 1d			call macro_dsp_valuehl 
377c				endm 
# End of macro FORTH_DSP_VALUEHL
377c			;		push hl 
377c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377c cd 4d 1e			call macro_forth_dsp_pop 
377f				endm 
# End of macro FORTH_DSP_POP
377f			;		pop hl 
377f 3e 00				ld a,0 
3781 bd					cp l 
3782 28 04				jr z, .not2t 
3784 2e 00				ld l, 0 
3786 18 02				jr .notip 
3788			 
3788 2e ff		.not2t:		ld l, 255 
378a			 
378a 26 00		.notip:		ld h, 0	 
378c			 
378c cd 90 1b				call forth_push_numhl 
378f					NEXTW 
378f c3 80 1f			jp macro_next 
3792				endm 
# End of macro NEXTW
3792			 
3792			.IS: 
3792				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3792 2d				db WORD_SYS_CORE+25             
3793 d3 37			dw .LZERO            
3795 08				db 7 + 1 
3796 .. 00			db "COMPARE",0              
379e				endm 
# End of macro CWHEAD
379e			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
379e					if DEBUG_FORTH_WORDS_KEY 
379e						DMARK "CMP" 
379e f5				push af  
379f 3a b3 37			ld a, (.dmark)  
37a2 32 65 ee			ld (debug_mark),a  
37a5 3a b4 37			ld a, (.dmark+1)  
37a8 32 66 ee			ld (debug_mark+1),a  
37ab 3a b5 37			ld a, (.dmark+2)  
37ae 32 67 ee			ld (debug_mark+2),a  
37b1 18 03			jr .pastdmark  
37b3 ..			.dmark: db "CMP"  
37b6 f1			.pastdmark: pop af  
37b7			endm  
# End of macro DMARK
37b7						CALLMONITOR 
37b7 cd 6f ee			call debug_vector  
37ba				endm  
# End of macro CALLMONITOR
37ba					endif 
37ba			 
37ba					FORTH_DSP_VALUEHL 
37ba cd 95 1d			call macro_dsp_valuehl 
37bd				endm 
# End of macro FORTH_DSP_VALUEHL
37bd			 
37bd e5					push hl 
37be			 
37be					FORTH_DSP_VALUEM1 
37be cd 89 1d			call macro_forth_dsp_value_m1 
37c1				endm 
# End of macro FORTH_DSP_VALUEM1
37c1			 
37c1 d1					pop de 
37c2			 
37c2					; got pointers to both. Now check. 
37c2			 
37c2 cd 93 11				call strcmp 
37c5				 
37c5 26 00				ld h, 0 
37c7 2e 00				ld l, 0 
37c9 20 02				jr nz, .compnsame 
37cb 2e 01				ld l, 1	 
37cd			.compnsame: 
37cd cd 90 1b				call forth_push_numhl 
37d0			 
37d0					NEXTW 
37d0 c3 80 1f			jp macro_next 
37d3				endm 
# End of macro NEXTW
37d3			.LZERO: 
37d3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37d3 2d				db WORD_SYS_CORE+25             
37d4 dd 37			dw .TZERO            
37d6 03				db 2 + 1 
37d7 .. 00			db "0<",0              
37da				endm 
# End of macro CWHEAD
37da			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37da					NEXTW 
37da c3 80 1f			jp macro_next 
37dd				endm 
# End of macro NEXTW
37dd			.TZERO: 
37dd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37dd 2e				db WORD_SYS_CORE+26             
37de 24 38			dw .LESS            
37e0 03				db 2 + 1 
37e1 .. 00			db "0=",0              
37e4				endm 
# End of macro CWHEAD
37e4			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
37e4				; TODO add floating point number detection 
37e4					;v5 FORTH_DSP_VALUE 
37e4					if DEBUG_FORTH_WORDS_KEY 
37e4						DMARK "0=." 
37e4 f5				push af  
37e5 3a f9 37			ld a, (.dmark)  
37e8 32 65 ee			ld (debug_mark),a  
37eb 3a fa 37			ld a, (.dmark+1)  
37ee 32 66 ee			ld (debug_mark+1),a  
37f1 3a fb 37			ld a, (.dmark+2)  
37f4 32 67 ee			ld (debug_mark+2),a  
37f7 18 03			jr .pastdmark  
37f9 ..			.dmark: db "0=."  
37fc f1			.pastdmark: pop af  
37fd			endm  
# End of macro DMARK
37fd						CALLMONITOR 
37fd cd 6f ee			call debug_vector  
3800				endm  
# End of macro CALLMONITOR
3800					endif 
3800					FORTH_DSP 
3800 cd 5b 1d			call macro_forth_dsp 
3803				endm 
# End of macro FORTH_DSP
3803 7e					ld a,(hl)	; get type of value on TOS 
3804 fe 02				cp DS_TYPE_INUM  
3806 28 00				jr z, .tz_inum 
3808			 
3808				if FORTH_ENABLE_FLOATMATH 
3808					jr .tz_done 
3808			 
3808				endif 
3808					 
3808			 
3808			.tz_inum: 
3808					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3808 cd 95 1d			call macro_dsp_valuehl 
380b				endm 
# End of macro FORTH_DSP_VALUEHL
380b			 
380b			;		push hl 
380b			 
380b					; destroy value TOS 
380b			 
380b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380b cd 4d 1e			call macro_forth_dsp_pop 
380e				endm 
# End of macro FORTH_DSP_POP
380e			 
380e			;		pop hl 
380e			 
380e 3e 00				ld a,0 
3810			 
3810 bd					cp l 
3811 20 08				jr nz, .tz_notzero 
3813			 
3813 bc					cp h 
3814			 
3814 20 05				jr nz, .tz_notzero 
3816			 
3816			 
3816 21 01 00				ld hl, FORTH_TRUE 
3819 18 03				jr .tz_done 
381b			 
381b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
381e			 
381e					; push value back onto stack for another op etc 
381e			 
381e			.tz_done: 
381e cd 90 1b				call forth_push_numhl 
3821			 
3821					NEXTW 
3821 c3 80 1f			jp macro_next 
3824				endm 
# End of macro NEXTW
3824			.LESS: 
3824				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3824 2f				db WORD_SYS_CORE+27             
3825 8d 38			dw .GT            
3827 02				db 1 + 1 
3828 .. 00			db "<",0              
382a				endm 
# End of macro CWHEAD
382a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
382a				; TODO add floating point number detection 
382a					if DEBUG_FORTH_WORDS_KEY 
382a						DMARK "LES" 
382a f5				push af  
382b 3a 3f 38			ld a, (.dmark)  
382e 32 65 ee			ld (debug_mark),a  
3831 3a 40 38			ld a, (.dmark+1)  
3834 32 66 ee			ld (debug_mark+1),a  
3837 3a 41 38			ld a, (.dmark+2)  
383a 32 67 ee			ld (debug_mark+2),a  
383d 18 03			jr .pastdmark  
383f ..			.dmark: db "LES"  
3842 f1			.pastdmark: pop af  
3843			endm  
# End of macro DMARK
3843						CALLMONITOR 
3843 cd 6f ee			call debug_vector  
3846				endm  
# End of macro CALLMONITOR
3846					endif 
3846					FORTH_DSP 
3846 cd 5b 1d			call macro_forth_dsp 
3849				endm 
# End of macro FORTH_DSP
3849					;v5 FORTH_DSP_VALUE 
3849 7e					ld a,(hl)	; get type of value on TOS 
384a fe 02				cp DS_TYPE_INUM  
384c 28 00				jr z, .less_inum 
384e			 
384e				if FORTH_ENABLE_FLOATMATH 
384e					jr .less_done 
384e			 
384e				endif 
384e					 
384e			 
384e			.less_inum: 
384e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
384e cd 95 1d			call macro_dsp_valuehl 
3851				endm 
# End of macro FORTH_DSP_VALUEHL
3851			 
3851 e5					push hl  ; u2 
3852			 
3852					; destroy value TOS 
3852			 
3852					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3852 cd 4d 1e			call macro_forth_dsp_pop 
3855				endm 
# End of macro FORTH_DSP_POP
3855			 
3855			 
3855					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3855 cd 95 1d			call macro_dsp_valuehl 
3858				endm 
# End of macro FORTH_DSP_VALUEHL
3858			 
3858 e5					push hl    ; u1 
3859			 
3859					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3859 cd 4d 1e			call macro_forth_dsp_pop 
385c				endm 
# End of macro FORTH_DSP_POP
385c			 
385c			 
385c b7			 or a      ;clear carry flag 
385d 01 00 00		 ld bc, FORTH_FALSE 
3860 e1			  pop hl    ; u1 
3861 d1			  pop de    ; u2 
3862 ed 52		  sbc hl,de 
3864 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3866			 
3866 01 01 00		 ld bc, FORTH_TRUE 
3869			.lscont:  
3869 c5					push bc 
386a e1					pop hl 
386b			 
386b					if DEBUG_FORTH_WORDS 
386b						DMARK "LT1" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 65 ee			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 66 ee			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 67 ee			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "LT1"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd 6f ee			call debug_vector  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887 cd 90 1b				call forth_push_numhl 
388a			 
388a					NEXTW 
388a c3 80 1f			jp macro_next 
388d				endm 
# End of macro NEXTW
388d			.GT: 
388d				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
388d 30				db WORD_SYS_CORE+28             
388e f6 38			dw .EQUAL            
3890 02				db 1 + 1 
3891 .. 00			db ">",0              
3893				endm 
# End of macro CWHEAD
3893			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3893				; TODO add floating point number detection 
3893					if DEBUG_FORTH_WORDS_KEY 
3893						DMARK "GRT" 
3893 f5				push af  
3894 3a a8 38			ld a, (.dmark)  
3897 32 65 ee			ld (debug_mark),a  
389a 3a a9 38			ld a, (.dmark+1)  
389d 32 66 ee			ld (debug_mark+1),a  
38a0 3a aa 38			ld a, (.dmark+2)  
38a3 32 67 ee			ld (debug_mark+2),a  
38a6 18 03			jr .pastdmark  
38a8 ..			.dmark: db "GRT"  
38ab f1			.pastdmark: pop af  
38ac			endm  
# End of macro DMARK
38ac						CALLMONITOR 
38ac cd 6f ee			call debug_vector  
38af				endm  
# End of macro CALLMONITOR
38af					endif 
38af					FORTH_DSP 
38af cd 5b 1d			call macro_forth_dsp 
38b2				endm 
# End of macro FORTH_DSP
38b2					;FORTH_DSP_VALUE 
38b2 7e					ld a,(hl)	; get type of value on TOS 
38b3 fe 02				cp DS_TYPE_INUM  
38b5 28 00				jr z, .gt_inum 
38b7			 
38b7				if FORTH_ENABLE_FLOATMATH 
38b7					jr .gt_done 
38b7			 
38b7				endif 
38b7					 
38b7			 
38b7			.gt_inum: 
38b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b7 cd 95 1d			call macro_dsp_valuehl 
38ba				endm 
# End of macro FORTH_DSP_VALUEHL
38ba			 
38ba e5					push hl  ; u2 
38bb			 
38bb					; destroy value TOS 
38bb			 
38bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bb cd 4d 1e			call macro_forth_dsp_pop 
38be				endm 
# End of macro FORTH_DSP_POP
38be			 
38be			 
38be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38be cd 95 1d			call macro_dsp_valuehl 
38c1				endm 
# End of macro FORTH_DSP_VALUEHL
38c1			 
38c1 e5					push hl    ; u1 
38c2			 
38c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c2 cd 4d 1e			call macro_forth_dsp_pop 
38c5				endm 
# End of macro FORTH_DSP_POP
38c5			 
38c5			 
38c5 b7			 or a      ;clear carry flag 
38c6 01 00 00		 ld bc, FORTH_FALSE 
38c9 e1			  pop hl    ; u1 
38ca d1			  pop de    ; u2 
38cb ed 52		  sbc hl,de 
38cd 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38cf			 
38cf 01 01 00		 ld bc, FORTH_TRUE 
38d2			.gtcont:  
38d2 c5					push bc 
38d3 e1					pop hl 
38d4			 
38d4					if DEBUG_FORTH_WORDS 
38d4						DMARK "GT1" 
38d4 f5				push af  
38d5 3a e9 38			ld a, (.dmark)  
38d8 32 65 ee			ld (debug_mark),a  
38db 3a ea 38			ld a, (.dmark+1)  
38de 32 66 ee			ld (debug_mark+1),a  
38e1 3a eb 38			ld a, (.dmark+2)  
38e4 32 67 ee			ld (debug_mark+2),a  
38e7 18 03			jr .pastdmark  
38e9 ..			.dmark: db "GT1"  
38ec f1			.pastdmark: pop af  
38ed			endm  
# End of macro DMARK
38ed						CALLMONITOR 
38ed cd 6f ee			call debug_vector  
38f0				endm  
# End of macro CALLMONITOR
38f0					endif 
38f0 cd 90 1b				call forth_push_numhl 
38f3			 
38f3					NEXTW 
38f3 c3 80 1f			jp macro_next 
38f6				endm 
# End of macro NEXTW
38f6			.EQUAL: 
38f6				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38f6 31				db WORD_SYS_CORE+29             
38f7 61 39			dw .ENDLOGIC            
38f9 02				db 1 + 1 
38fa .. 00			db "=",0              
38fc				endm 
# End of macro CWHEAD
38fc			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38fc				; TODO add floating point number detection 
38fc					if DEBUG_FORTH_WORDS_KEY 
38fc						DMARK "EQ." 
38fc f5				push af  
38fd 3a 11 39			ld a, (.dmark)  
3900 32 65 ee			ld (debug_mark),a  
3903 3a 12 39			ld a, (.dmark+1)  
3906 32 66 ee			ld (debug_mark+1),a  
3909 3a 13 39			ld a, (.dmark+2)  
390c 32 67 ee			ld (debug_mark+2),a  
390f 18 03			jr .pastdmark  
3911 ..			.dmark: db "EQ."  
3914 f1			.pastdmark: pop af  
3915			endm  
# End of macro DMARK
3915						CALLMONITOR 
3915 cd 6f ee			call debug_vector  
3918				endm  
# End of macro CALLMONITOR
3918					endif 
3918					FORTH_DSP 
3918 cd 5b 1d			call macro_forth_dsp 
391b				endm 
# End of macro FORTH_DSP
391b					;v5 FORTH_DSP_VALUE 
391b 7e					ld a,(hl)	; get type of value on TOS 
391c fe 02				cp DS_TYPE_INUM  
391e 28 00				jr z, .eq_inum 
3920			 
3920				if FORTH_ENABLE_FLOATMATH 
3920					jr .eq_done 
3920			 
3920				endif 
3920					 
3920			 
3920			.eq_inum: 
3920					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3920 cd 95 1d			call macro_dsp_valuehl 
3923				endm 
# End of macro FORTH_DSP_VALUEHL
3923			 
3923 e5					push hl 
3924			 
3924					; destroy value TOS 
3924			 
3924					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3924 cd 4d 1e			call macro_forth_dsp_pop 
3927				endm 
# End of macro FORTH_DSP_POP
3927			 
3927			 
3927					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3927 cd 95 1d			call macro_dsp_valuehl 
392a				endm 
# End of macro FORTH_DSP_VALUEHL
392a			 
392a					; one value on hl get other one back 
392a			 
392a e5					push hl 
392b			 
392b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392b cd 4d 1e			call macro_forth_dsp_pop 
392e				endm 
# End of macro FORTH_DSP_POP
392e			 
392e 0e 00				ld c, FORTH_FALSE 
3930			 
3930 e1					pop hl 
3931 d1					pop de 
3932			 
3932 7b					ld a, e 
3933 bd					cp l 
3934			 
3934 20 06				jr nz, .eq_done 
3936			 
3936 7a					ld a, d 
3937 bc					cp h 
3938			 
3938 20 02				jr nz, .eq_done 
393a			 
393a 0e 01				ld c, FORTH_TRUE 
393c					 
393c			 
393c			 
393c			.eq_done: 
393c			 
393c					; TODO push value back onto stack for another op etc 
393c			 
393c 26 00				ld h, 0 
393e 69					ld l, c 
393f					if DEBUG_FORTH_WORDS 
393f						DMARK "EQ1" 
393f f5				push af  
3940 3a 54 39			ld a, (.dmark)  
3943 32 65 ee			ld (debug_mark),a  
3946 3a 55 39			ld a, (.dmark+1)  
3949 32 66 ee			ld (debug_mark+1),a  
394c 3a 56 39			ld a, (.dmark+2)  
394f 32 67 ee			ld (debug_mark+2),a  
3952 18 03			jr .pastdmark  
3954 ..			.dmark: db "EQ1"  
3957 f1			.pastdmark: pop af  
3958			endm  
# End of macro DMARK
3958						CALLMONITOR 
3958 cd 6f ee			call debug_vector  
395b				endm  
# End of macro CALLMONITOR
395b					endif 
395b cd 90 1b				call forth_push_numhl 
395e			 
395e					NEXTW 
395e c3 80 1f			jp macro_next 
3961				endm 
# End of macro NEXTW
3961			 
3961			 
3961			.ENDLOGIC: 
3961			; eof 
3961			 
3961			 
# End of file forth_words_logic.asm
3961			include "forth_words_maths.asm" 
3961			 
3961			; | ## Maths Words 
3961			 
3961			.PLUS:	 
3961				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3961 15				db WORD_SYS_CORE+1             
3962 bf 39			dw .NEG            
3964 02				db 1 + 1 
3965 .. 00			db "+",0              
3967				endm 
# End of macro CWHEAD
3967			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3967					if DEBUG_FORTH_WORDS_KEY 
3967						DMARK "PLU" 
3967 f5				push af  
3968 3a 7c 39			ld a, (.dmark)  
396b 32 65 ee			ld (debug_mark),a  
396e 3a 7d 39			ld a, (.dmark+1)  
3971 32 66 ee			ld (debug_mark+1),a  
3974 3a 7e 39			ld a, (.dmark+2)  
3977 32 67 ee			ld (debug_mark+2),a  
397a 18 03			jr .pastdmark  
397c ..			.dmark: db "PLU"  
397f f1			.pastdmark: pop af  
3980			endm  
# End of macro DMARK
3980						CALLMONITOR 
3980 cd 6f ee			call debug_vector  
3983				endm  
# End of macro CALLMONITOR
3983					endif 
3983					; add top two values and push back result 
3983			 
3983					;for v5 FORTH_DSP_VALUE 
3983					FORTH_DSP 
3983 cd 5b 1d			call macro_forth_dsp 
3986				endm 
# End of macro FORTH_DSP
3986 7e					ld a,(hl)	; get type of value on TOS 
3987 fe 02				cp DS_TYPE_INUM  
3989 28 03				jr z, .dot_inum 
398b			 
398b					NEXTW 
398b c3 80 1f			jp macro_next 
398e				endm 
# End of macro NEXTW
398e			 
398e			; float maths 
398e			 
398e				if FORTH_ENABLE_FLOATMATH 
398e						inc hl      ; now at start of numeric as string 
398e			 
398e					if DEBUG_FORTH_MATHS 
398e						DMARK "ADD" 
398e				CALLMONITOR 
398e					endif 
398e			 
398e					;ld ix, hl 
398e					call CON 
398e			 
398e			 
398e					push hl 
398e					 
398e					 
398e			 
398e						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
398e			 
398e					; get next number 
398e			 
398e						FORTH_DSP_VALUE 
398e			 
398e						inc hl      ; now at start of numeric as string 
398e			 
398e					;ld ix, hl 
398e					call CON 
398e			 
398e					push hl 
398e			 
398e			 
398e						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398e			 
398e						; TODO do add 
398e			 
398e						call IADD 
398e			 
398e						; TODO get result back as ascii 
398e			 
398e						; TODO push result  
398e			 
398e			 
398e			 
398e						jr .dot_done 
398e				endif 
398e			 
398e			.dot_inum: 
398e			 
398e			 
398e					if DEBUG_FORTH_DOT 
398e						DMARK "+IT" 
398e f5				push af  
398f 3a a3 39			ld a, (.dmark)  
3992 32 65 ee			ld (debug_mark),a  
3995 3a a4 39			ld a, (.dmark+1)  
3998 32 66 ee			ld (debug_mark+1),a  
399b 3a a5 39			ld a, (.dmark+2)  
399e 32 67 ee			ld (debug_mark+2),a  
39a1 18 03			jr .pastdmark  
39a3 ..			.dmark: db "+IT"  
39a6 f1			.pastdmark: pop af  
39a7			endm  
# End of macro DMARK
39a7				CALLMONITOR 
39a7 cd 6f ee			call debug_vector  
39aa				endm  
# End of macro CALLMONITOR
39aa					endif 
39aa			 
39aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39aa cd 95 1d			call macro_dsp_valuehl 
39ad				endm 
# End of macro FORTH_DSP_VALUEHL
39ad			 
39ad				; TODO add floating point number detection 
39ad			 
39ad e5					push hl 
39ae			 
39ae					; destroy value TOS 
39ae			 
39ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ae cd 4d 1e			call macro_forth_dsp_pop 
39b1				endm 
# End of macro FORTH_DSP_POP
39b1			 
39b1			 
39b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b1 cd 95 1d			call macro_dsp_valuehl 
39b4				endm 
# End of macro FORTH_DSP_VALUEHL
39b4			 
39b4					; one value on hl get other one back 
39b4			 
39b4 d1					pop de 
39b5			 
39b5					; do the add 
39b5			 
39b5 19					add hl,de 
39b6			 
39b6					; save it 
39b6			 
39b6			;		push hl	 
39b6			 
39b6					; 
39b6			 
39b6					; destroy value TOS 
39b6			 
39b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b6 cd 4d 1e			call macro_forth_dsp_pop 
39b9				endm 
# End of macro FORTH_DSP_POP
39b9			 
39b9					; TODO push value back onto stack for another op etc 
39b9			 
39b9			;		pop hl 
39b9			 
39b9			.dot_done: 
39b9 cd 90 1b				call forth_push_numhl 
39bc			 
39bc					NEXTW 
39bc c3 80 1f			jp macro_next 
39bf				endm 
# End of macro NEXTW
39bf			.NEG: 
39bf			 
39bf				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39bf 17				db WORD_SYS_CORE+3             
39c0 02 3a			dw .DIV            
39c2 02				db 1 + 1 
39c3 .. 00			db "-",0              
39c5				endm 
# End of macro CWHEAD
39c5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39c5					if DEBUG_FORTH_WORDS_KEY 
39c5						DMARK "SUB" 
39c5 f5				push af  
39c6 3a da 39			ld a, (.dmark)  
39c9 32 65 ee			ld (debug_mark),a  
39cc 3a db 39			ld a, (.dmark+1)  
39cf 32 66 ee			ld (debug_mark+1),a  
39d2 3a dc 39			ld a, (.dmark+2)  
39d5 32 67 ee			ld (debug_mark+2),a  
39d8 18 03			jr .pastdmark  
39da ..			.dmark: db "SUB"  
39dd f1			.pastdmark: pop af  
39de			endm  
# End of macro DMARK
39de						CALLMONITOR 
39de cd 6f ee			call debug_vector  
39e1				endm  
# End of macro CALLMONITOR
39e1					endif 
39e1			 
39e1			 
39e1				; TODO add floating point number detection 
39e1					; v5 FORTH_DSP_VALUE 
39e1					FORTH_DSP 
39e1 cd 5b 1d			call macro_forth_dsp 
39e4				endm 
# End of macro FORTH_DSP
39e4 7e					ld a,(hl)	; get type of value on TOS 
39e5 fe 02				cp DS_TYPE_INUM  
39e7 28 03				jr z, .neg_inum 
39e9			 
39e9					NEXTW 
39e9 c3 80 1f			jp macro_next 
39ec				endm 
# End of macro NEXTW
39ec			 
39ec			; float maths 
39ec			 
39ec				if FORTH_ENABLE_FLOATMATH 
39ec					jr .neg_done 
39ec			 
39ec				endif 
39ec					 
39ec			 
39ec			.neg_inum: 
39ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ec cd 95 1d			call macro_dsp_valuehl 
39ef				endm 
# End of macro FORTH_DSP_VALUEHL
39ef			 
39ef e5					push hl 
39f0			 
39f0					; destroy value TOS 
39f0			 
39f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f0 cd 4d 1e			call macro_forth_dsp_pop 
39f3				endm 
# End of macro FORTH_DSP_POP
39f3			 
39f3			 
39f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f3 cd 95 1d			call macro_dsp_valuehl 
39f6				endm 
# End of macro FORTH_DSP_VALUEHL
39f6			 
39f6					; one value on hl get other one back 
39f6			 
39f6 d1					pop de 
39f7			 
39f7					; do the sub 
39f7			;		ex de, hl 
39f7			 
39f7 ed 52				sbc hl,de 
39f9			 
39f9					; save it 
39f9			 
39f9			;		push hl	 
39f9			 
39f9					; 
39f9			 
39f9					; destroy value TOS 
39f9			 
39f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f9 cd 4d 1e			call macro_forth_dsp_pop 
39fc				endm 
# End of macro FORTH_DSP_POP
39fc			 
39fc					; TODO push value back onto stack for another op etc 
39fc			 
39fc			;		pop hl 
39fc			 
39fc cd 90 1b				call forth_push_numhl 
39ff			.neg_done: 
39ff			 
39ff					NEXTW 
39ff c3 80 1f			jp macro_next 
3a02				endm 
# End of macro NEXTW
3a02			.DIV: 
3a02				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a02 18				db WORD_SYS_CORE+4             
3a03 4f 3a			dw .MUL            
3a05 02				db 1 + 1 
3a06 .. 00			db "/",0              
3a08				endm 
# End of macro CWHEAD
3a08			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a08					if DEBUG_FORTH_WORDS_KEY 
3a08						DMARK "DIV" 
3a08 f5				push af  
3a09 3a 1d 3a			ld a, (.dmark)  
3a0c 32 65 ee			ld (debug_mark),a  
3a0f 3a 1e 3a			ld a, (.dmark+1)  
3a12 32 66 ee			ld (debug_mark+1),a  
3a15 3a 1f 3a			ld a, (.dmark+2)  
3a18 32 67 ee			ld (debug_mark+2),a  
3a1b 18 03			jr .pastdmark  
3a1d ..			.dmark: db "DIV"  
3a20 f1			.pastdmark: pop af  
3a21			endm  
# End of macro DMARK
3a21						CALLMONITOR 
3a21 cd 6f ee			call debug_vector  
3a24				endm  
# End of macro CALLMONITOR
3a24					endif 
3a24				; TODO add floating point number detection 
3a24					; v5 FORTH_DSP_VALUE 
3a24					FORTH_DSP 
3a24 cd 5b 1d			call macro_forth_dsp 
3a27				endm 
# End of macro FORTH_DSP
3a27 7e					ld a,(hl)	; get type of value on TOS 
3a28 fe 02				cp DS_TYPE_INUM  
3a2a 28 03				jr z, .div_inum 
3a2c			 
3a2c				if FORTH_ENABLE_FLOATMATH 
3a2c					jr .div_done 
3a2c			 
3a2c				endif 
3a2c					NEXTW 
3a2c c3 80 1f			jp macro_next 
3a2f				endm 
# End of macro NEXTW
3a2f			.div_inum: 
3a2f			 
3a2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a2f cd 95 1d			call macro_dsp_valuehl 
3a32				endm 
# End of macro FORTH_DSP_VALUEHL
3a32			 
3a32 e5					push hl    ; to go to bc 
3a33			 
3a33					; destroy value TOS 
3a33			 
3a33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a33 cd 4d 1e			call macro_forth_dsp_pop 
3a36				endm 
# End of macro FORTH_DSP_POP
3a36			 
3a36			 
3a36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a36 cd 95 1d			call macro_dsp_valuehl 
3a39				endm 
# End of macro FORTH_DSP_VALUEHL
3a39			 
3a39					; hl to go to de 
3a39			 
3a39 e5					push hl 
3a3a			 
3a3a c1					pop bc 
3a3b d1					pop de		 
3a3c			 
3a3c			 
3a3c					if DEBUG_FORTH_MATHS 
3a3c						DMARK "DIV" 
3a3c				CALLMONITOR 
3a3c					endif 
3a3c					; one value on hl but move to a get other one back 
3a3c			 
3a3c			        
3a3c cd 52 0d			call Div16 
3a3f			 
3a3f			;	push af	 
3a3f e5				push hl 
3a40 c5				push bc 
3a41			 
3a41					if DEBUG_FORTH_MATHS 
3a41						DMARK "DI1" 
3a41				CALLMONITOR 
3a41					endif 
3a41			 
3a41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a41 cd 4d 1e			call macro_forth_dsp_pop 
3a44				endm 
# End of macro FORTH_DSP_POP
3a44			 
3a44			 
3a44			 
3a44 e1					pop hl    ; result 
3a45			 
3a45 cd 90 1b				call forth_push_numhl 
3a48			 
3a48 e1					pop hl    ; reminder 
3a49			;		ld h,0 
3a49			;		ld l,d 
3a49			 
3a49 cd 90 1b				call forth_push_numhl 
3a4c			.div_done: 
3a4c					NEXTW 
3a4c c3 80 1f			jp macro_next 
3a4f				endm 
# End of macro NEXTW
3a4f			.MUL: 
3a4f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a4f 19				db WORD_SYS_CORE+5             
3a50 94 3a			dw .MIN            
3a52 02				db 1 + 1 
3a53 .. 00			db "*",0              
3a55				endm 
# End of macro CWHEAD
3a55			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a55				; TODO add floating point number detection 
3a55					if DEBUG_FORTH_WORDS_KEY 
3a55						DMARK "MUL" 
3a55 f5				push af  
3a56 3a 6a 3a			ld a, (.dmark)  
3a59 32 65 ee			ld (debug_mark),a  
3a5c 3a 6b 3a			ld a, (.dmark+1)  
3a5f 32 66 ee			ld (debug_mark+1),a  
3a62 3a 6c 3a			ld a, (.dmark+2)  
3a65 32 67 ee			ld (debug_mark+2),a  
3a68 18 03			jr .pastdmark  
3a6a ..			.dmark: db "MUL"  
3a6d f1			.pastdmark: pop af  
3a6e			endm  
# End of macro DMARK
3a6e						CALLMONITOR 
3a6e cd 6f ee			call debug_vector  
3a71				endm  
# End of macro CALLMONITOR
3a71					endif 
3a71					FORTH_DSP 
3a71 cd 5b 1d			call macro_forth_dsp 
3a74				endm 
# End of macro FORTH_DSP
3a74					; v5 FORTH_DSP_VALUE 
3a74 7e					ld a,(hl)	; get type of value on TOS 
3a75 fe 02				cp DS_TYPE_INUM  
3a77 28 03				jr z, .mul_inum 
3a79			 
3a79				if FORTH_ENABLE_FLOATMATH 
3a79					jr .mul_done 
3a79			 
3a79				endif 
3a79			 
3a79					NEXTW 
3a79 c3 80 1f			jp macro_next 
3a7c				endm 
# End of macro NEXTW
3a7c			.mul_inum:	 
3a7c			 
3a7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a7c cd 95 1d			call macro_dsp_valuehl 
3a7f				endm 
# End of macro FORTH_DSP_VALUEHL
3a7f			 
3a7f e5					push hl 
3a80			 
3a80					; destroy value TOS 
3a80			 
3a80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a80 cd 4d 1e			call macro_forth_dsp_pop 
3a83				endm 
# End of macro FORTH_DSP_POP
3a83			 
3a83			 
3a83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a83 cd 95 1d			call macro_dsp_valuehl 
3a86				endm 
# End of macro FORTH_DSP_VALUEHL
3a86			 
3a86					; one value on hl but move to a get other one back 
3a86			 
3a86 7d					ld a, l 
3a87			 
3a87 d1					pop de 
3a88			 
3a88					; do the mull 
3a88			;		ex de, hl 
3a88			 
3a88 cd 78 0d				call Mult16 
3a8b					; save it 
3a8b			 
3a8b			;		push hl	 
3a8b			 
3a8b					; 
3a8b			 
3a8b					; destroy value TOS 
3a8b			 
3a8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a8b cd 4d 1e			call macro_forth_dsp_pop 
3a8e				endm 
# End of macro FORTH_DSP_POP
3a8e			 
3a8e					; TODO push value back onto stack for another op etc 
3a8e			 
3a8e			;		pop hl 
3a8e			 
3a8e cd 90 1b				call forth_push_numhl 
3a91			 
3a91			.mul_done: 
3a91					NEXTW 
3a91 c3 80 1f			jp macro_next 
3a94				endm 
# End of macro NEXTW
3a94			 
3a94			 
3a94			 
3a94			 
3a94			.MIN: 
3a94				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a94 49				db WORD_SYS_CORE+53             
3a95 15 3b			dw .MAX            
3a97 04				db 3 + 1 
3a98 .. 00			db "MIN",0              
3a9c				endm 
# End of macro CWHEAD
3a9c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a9c					if DEBUG_FORTH_WORDS_KEY 
3a9c						DMARK "MIN" 
3a9c f5				push af  
3a9d 3a b1 3a			ld a, (.dmark)  
3aa0 32 65 ee			ld (debug_mark),a  
3aa3 3a b2 3a			ld a, (.dmark+1)  
3aa6 32 66 ee			ld (debug_mark+1),a  
3aa9 3a b3 3a			ld a, (.dmark+2)  
3aac 32 67 ee			ld (debug_mark+2),a  
3aaf 18 03			jr .pastdmark  
3ab1 ..			.dmark: db "MIN"  
3ab4 f1			.pastdmark: pop af  
3ab5			endm  
# End of macro DMARK
3ab5						CALLMONITOR 
3ab5 cd 6f ee			call debug_vector  
3ab8				endm  
# End of macro CALLMONITOR
3ab8					endif 
3ab8					; get u2 
3ab8			 
3ab8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab8 cd 95 1d			call macro_dsp_valuehl 
3abb				endm 
# End of macro FORTH_DSP_VALUEHL
3abb			 
3abb e5					push hl   ; u2 
3abc			 
3abc					; destroy value TOS 
3abc			 
3abc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3abc cd 4d 1e			call macro_forth_dsp_pop 
3abf				endm 
# End of macro FORTH_DSP_POP
3abf			 
3abf					; get u1 
3abf			 
3abf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abf cd 95 1d			call macro_dsp_valuehl 
3ac2				endm 
# End of macro FORTH_DSP_VALUEHL
3ac2			 
3ac2 e5					push hl  ; u1 
3ac3			 
3ac3					; destroy value TOS 
3ac3			 
3ac3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac3 cd 4d 1e			call macro_forth_dsp_pop 
3ac6				endm 
# End of macro FORTH_DSP_POP
3ac6			 
3ac6 b7			 or a      ;clear carry flag 
3ac7 e1			  pop hl    ; u1 
3ac8 d1			  pop de    ; u2 
3ac9 e5				push hl   ; saved in case hl is lowest 
3aca ed 52		  sbc hl,de 
3acc 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3ace			 
3ace e1				pop hl 
3acf					if DEBUG_FORTH_WORDS 
3acf						DMARK "MIN" 
3acf f5				push af  
3ad0 3a e4 3a			ld a, (.dmark)  
3ad3 32 65 ee			ld (debug_mark),a  
3ad6 3a e5 3a			ld a, (.dmark+1)  
3ad9 32 66 ee			ld (debug_mark+1),a  
3adc 3a e6 3a			ld a, (.dmark+2)  
3adf 32 67 ee			ld (debug_mark+2),a  
3ae2 18 03			jr .pastdmark  
3ae4 ..			.dmark: db "MIN"  
3ae7 f1			.pastdmark: pop af  
3ae8			endm  
# End of macro DMARK
3ae8						CALLMONITOR 
3ae8 cd 6f ee			call debug_vector  
3aeb				endm  
# End of macro CALLMONITOR
3aeb					endif 
3aeb cd 90 1b				call forth_push_numhl 
3aee			 
3aee				       NEXTW 
3aee c3 80 1f			jp macro_next 
3af1				endm 
# End of macro NEXTW
3af1			 
3af1			.mincont:  
3af1 c1				pop bc   ; tidy up 
3af2 eb				ex de , hl  
3af3					if DEBUG_FORTH_WORDS 
3af3						DMARK "MI1" 
3af3 f5				push af  
3af4 3a 08 3b			ld a, (.dmark)  
3af7 32 65 ee			ld (debug_mark),a  
3afa 3a 09 3b			ld a, (.dmark+1)  
3afd 32 66 ee			ld (debug_mark+1),a  
3b00 3a 0a 3b			ld a, (.dmark+2)  
3b03 32 67 ee			ld (debug_mark+2),a  
3b06 18 03			jr .pastdmark  
3b08 ..			.dmark: db "MI1"  
3b0b f1			.pastdmark: pop af  
3b0c			endm  
# End of macro DMARK
3b0c						CALLMONITOR 
3b0c cd 6f ee			call debug_vector  
3b0f				endm  
# End of macro CALLMONITOR
3b0f					endif 
3b0f cd 90 1b				call forth_push_numhl 
3b12			 
3b12				       NEXTW 
3b12 c3 80 1f			jp macro_next 
3b15				endm 
# End of macro NEXTW
3b15			.MAX: 
3b15				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b15 4a				db WORD_SYS_CORE+54             
3b16 96 3b			dw .RND16            
3b18 04				db 3 + 1 
3b19 .. 00			db "MAX",0              
3b1d				endm 
# End of macro CWHEAD
3b1d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b1d					if DEBUG_FORTH_WORDS_KEY 
3b1d						DMARK "MAX" 
3b1d f5				push af  
3b1e 3a 32 3b			ld a, (.dmark)  
3b21 32 65 ee			ld (debug_mark),a  
3b24 3a 33 3b			ld a, (.dmark+1)  
3b27 32 66 ee			ld (debug_mark+1),a  
3b2a 3a 34 3b			ld a, (.dmark+2)  
3b2d 32 67 ee			ld (debug_mark+2),a  
3b30 18 03			jr .pastdmark  
3b32 ..			.dmark: db "MAX"  
3b35 f1			.pastdmark: pop af  
3b36			endm  
# End of macro DMARK
3b36						CALLMONITOR 
3b36 cd 6f ee			call debug_vector  
3b39				endm  
# End of macro CALLMONITOR
3b39					endif 
3b39					; get u2 
3b39			 
3b39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b39 cd 95 1d			call macro_dsp_valuehl 
3b3c				endm 
# End of macro FORTH_DSP_VALUEHL
3b3c			 
3b3c e5					push hl   ; u2 
3b3d			 
3b3d					; destroy value TOS 
3b3d			 
3b3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b3d cd 4d 1e			call macro_forth_dsp_pop 
3b40				endm 
# End of macro FORTH_DSP_POP
3b40			 
3b40					; get u1 
3b40			 
3b40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b40 cd 95 1d			call macro_dsp_valuehl 
3b43				endm 
# End of macro FORTH_DSP_VALUEHL
3b43			 
3b43 e5					push hl  ; u1 
3b44			 
3b44					; destroy value TOS 
3b44			 
3b44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b44 cd 4d 1e			call macro_forth_dsp_pop 
3b47				endm 
# End of macro FORTH_DSP_POP
3b47			 
3b47 b7			 or a      ;clear carry flag 
3b48 e1			  pop hl    ; u1 
3b49 d1			  pop de    ; u2 
3b4a e5				push hl   ; saved in case hl is lowest 
3b4b ed 52		  sbc hl,de 
3b4d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b4f			 
3b4f e1				pop hl 
3b50					if DEBUG_FORTH_WORDS 
3b50						DMARK "MAX" 
3b50 f5				push af  
3b51 3a 65 3b			ld a, (.dmark)  
3b54 32 65 ee			ld (debug_mark),a  
3b57 3a 66 3b			ld a, (.dmark+1)  
3b5a 32 66 ee			ld (debug_mark+1),a  
3b5d 3a 67 3b			ld a, (.dmark+2)  
3b60 32 67 ee			ld (debug_mark+2),a  
3b63 18 03			jr .pastdmark  
3b65 ..			.dmark: db "MAX"  
3b68 f1			.pastdmark: pop af  
3b69			endm  
# End of macro DMARK
3b69						CALLMONITOR 
3b69 cd 6f ee			call debug_vector  
3b6c				endm  
# End of macro CALLMONITOR
3b6c					endif 
3b6c cd 90 1b				call forth_push_numhl 
3b6f			 
3b6f				       NEXTW 
3b6f c3 80 1f			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			 
3b72			.maxcont:  
3b72 c1				pop bc   ; tidy up 
3b73 eb				ex de , hl  
3b74					if DEBUG_FORTH_WORDS 
3b74						DMARK "MA1" 
3b74 f5				push af  
3b75 3a 89 3b			ld a, (.dmark)  
3b78 32 65 ee			ld (debug_mark),a  
3b7b 3a 8a 3b			ld a, (.dmark+1)  
3b7e 32 66 ee			ld (debug_mark+1),a  
3b81 3a 8b 3b			ld a, (.dmark+2)  
3b84 32 67 ee			ld (debug_mark+2),a  
3b87 18 03			jr .pastdmark  
3b89 ..			.dmark: db "MA1"  
3b8c f1			.pastdmark: pop af  
3b8d			endm  
# End of macro DMARK
3b8d						CALLMONITOR 
3b8d cd 6f ee			call debug_vector  
3b90				endm  
# End of macro CALLMONITOR
3b90					endif 
3b90 cd 90 1b				call forth_push_numhl 
3b93				       NEXTW 
3b93 c3 80 1f			jp macro_next 
3b96				endm 
# End of macro NEXTW
3b96			 
3b96			.RND16: 
3b96				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b96 4e				db WORD_SYS_CORE+58             
3b97 c5 3b			dw .RND8            
3b99 06				db 5 + 1 
3b9a .. 00			db "RND16",0              
3ba0				endm 
# End of macro CWHEAD
3ba0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3ba0					if DEBUG_FORTH_WORDS_KEY 
3ba0						DMARK "R16" 
3ba0 f5				push af  
3ba1 3a b5 3b			ld a, (.dmark)  
3ba4 32 65 ee			ld (debug_mark),a  
3ba7 3a b6 3b			ld a, (.dmark+1)  
3baa 32 66 ee			ld (debug_mark+1),a  
3bad 3a b7 3b			ld a, (.dmark+2)  
3bb0 32 67 ee			ld (debug_mark+2),a  
3bb3 18 03			jr .pastdmark  
3bb5 ..			.dmark: db "R16"  
3bb8 f1			.pastdmark: pop af  
3bb9			endm  
# End of macro DMARK
3bb9						CALLMONITOR 
3bb9 cd 6f ee			call debug_vector  
3bbc				endm  
# End of macro CALLMONITOR
3bbc					endif 
3bbc cd 1c 0d				call prng16  
3bbf cd 90 1b				call forth_push_numhl 
3bc2				       NEXTW 
3bc2 c3 80 1f			jp macro_next 
3bc5				endm 
# End of macro NEXTW
3bc5			.RND8: 
3bc5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bc5 60				db WORD_SYS_CORE+76             
3bc6 fa 3b			dw .RND            
3bc8 05				db 4 + 1 
3bc9 .. 00			db "RND8",0              
3bce				endm 
# End of macro CWHEAD
3bce			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bce					if DEBUG_FORTH_WORDS_KEY 
3bce						DMARK "RN8" 
3bce f5				push af  
3bcf 3a e3 3b			ld a, (.dmark)  
3bd2 32 65 ee			ld (debug_mark),a  
3bd5 3a e4 3b			ld a, (.dmark+1)  
3bd8 32 66 ee			ld (debug_mark+1),a  
3bdb 3a e5 3b			ld a, (.dmark+2)  
3bde 32 67 ee			ld (debug_mark+2),a  
3be1 18 03			jr .pastdmark  
3be3 ..			.dmark: db "RN8"  
3be6 f1			.pastdmark: pop af  
3be7			endm  
# End of macro DMARK
3be7						CALLMONITOR 
3be7 cd 6f ee			call debug_vector  
3bea				endm  
# End of macro CALLMONITOR
3bea					endif 
3bea 2a a3 eb				ld hl,(xrandc) 
3bed 23					inc hl 
3bee cd 36 0d				call xrnd 
3bf1 6f					ld l,a	 
3bf2 26 00				ld h,0 
3bf4 cd 90 1b				call forth_push_numhl 
3bf7				       NEXTW 
3bf7 c3 80 1f			jp macro_next 
3bfa				endm 
# End of macro NEXTW
3bfa			.RND: 
3bfa				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bfa 60				db WORD_SYS_CORE+76             
3bfb 00 3d			dw .ENDMATHS            
3bfd 04				db 3 + 1 
3bfe .. 00			db "RND",0              
3c02				endm 
# End of macro CWHEAD
3c02			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c02			 
3c02					if DEBUG_FORTH_WORDS_KEY 
3c02						DMARK "RND" 
3c02 f5				push af  
3c03 3a 17 3c			ld a, (.dmark)  
3c06 32 65 ee			ld (debug_mark),a  
3c09 3a 18 3c			ld a, (.dmark+1)  
3c0c 32 66 ee			ld (debug_mark+1),a  
3c0f 3a 19 3c			ld a, (.dmark+2)  
3c12 32 67 ee			ld (debug_mark+2),a  
3c15 18 03			jr .pastdmark  
3c17 ..			.dmark: db "RND"  
3c1a f1			.pastdmark: pop af  
3c1b			endm  
# End of macro DMARK
3c1b						CALLMONITOR 
3c1b cd 6f ee			call debug_vector  
3c1e				endm  
# End of macro CALLMONITOR
3c1e					endif 
3c1e					 
3c1e					FORTH_DSP_VALUEHL    ; upper range 
3c1e cd 95 1d			call macro_dsp_valuehl 
3c21				endm 
# End of macro FORTH_DSP_VALUEHL
3c21			 
3c21 22 a7 eb				ld (LFSRSeed), hl	 
3c24			 
3c24					if DEBUG_FORTH_WORDS 
3c24						DMARK "RN1" 
3c24 f5				push af  
3c25 3a 39 3c			ld a, (.dmark)  
3c28 32 65 ee			ld (debug_mark),a  
3c2b 3a 3a 3c			ld a, (.dmark+1)  
3c2e 32 66 ee			ld (debug_mark+1),a  
3c31 3a 3b 3c			ld a, (.dmark+2)  
3c34 32 67 ee			ld (debug_mark+2),a  
3c37 18 03			jr .pastdmark  
3c39 ..			.dmark: db "RN1"  
3c3c f1			.pastdmark: pop af  
3c3d			endm  
# End of macro DMARK
3c3d						CALLMONITOR 
3c3d cd 6f ee			call debug_vector  
3c40				endm  
# End of macro CALLMONITOR
3c40					endif 
3c40					FORTH_DSP_POP 
3c40 cd 4d 1e			call macro_forth_dsp_pop 
3c43				endm 
# End of macro FORTH_DSP_POP
3c43			 
3c43					FORTH_DSP_VALUEHL    ; low range 
3c43 cd 95 1d			call macro_dsp_valuehl 
3c46				endm 
# End of macro FORTH_DSP_VALUEHL
3c46			 
3c46					if DEBUG_FORTH_WORDS 
3c46						DMARK "RN2" 
3c46 f5				push af  
3c47 3a 5b 3c			ld a, (.dmark)  
3c4a 32 65 ee			ld (debug_mark),a  
3c4d 3a 5c 3c			ld a, (.dmark+1)  
3c50 32 66 ee			ld (debug_mark+1),a  
3c53 3a 5d 3c			ld a, (.dmark+2)  
3c56 32 67 ee			ld (debug_mark+2),a  
3c59 18 03			jr .pastdmark  
3c5b ..			.dmark: db "RN2"  
3c5e f1			.pastdmark: pop af  
3c5f			endm  
# End of macro DMARK
3c5f						CALLMONITOR 
3c5f cd 6f ee			call debug_vector  
3c62				endm  
# End of macro CALLMONITOR
3c62					endif 
3c62 22 a9 eb				ld (LFSRSeed+2), hl 
3c65			 
3c65					FORTH_DSP_POP 
3c65 cd 4d 1e			call macro_forth_dsp_pop 
3c68				endm 
# End of macro FORTH_DSP_POP
3c68			 
3c68 e5					push hl 
3c69			 
3c69 e1			.inrange:	pop hl 
3c6a cd 1c 0d				call prng16  
3c6d					if DEBUG_FORTH_WORDS 
3c6d						DMARK "RN3" 
3c6d f5				push af  
3c6e 3a 82 3c			ld a, (.dmark)  
3c71 32 65 ee			ld (debug_mark),a  
3c74 3a 83 3c			ld a, (.dmark+1)  
3c77 32 66 ee			ld (debug_mark+1),a  
3c7a 3a 84 3c			ld a, (.dmark+2)  
3c7d 32 67 ee			ld (debug_mark+2),a  
3c80 18 03			jr .pastdmark  
3c82 ..			.dmark: db "RN3"  
3c85 f1			.pastdmark: pop af  
3c86			endm  
# End of macro DMARK
3c86						CALLMONITOR 
3c86 cd 6f ee			call debug_vector  
3c89				endm  
# End of macro CALLMONITOR
3c89					endif 
3c89					 
3c89					; if the range is 8bit knock out the high byte 
3c89			 
3c89 ed 5b a7 eb			ld de, (LFSRSeed)     ; check high level 
3c8d			 
3c8d 3e 00				ld a, 0 
3c8f ba					cp d  
3c90 20 1e				jr nz, .hirange 
3c92 26 00				ld h, 0   ; knock it down to 8bit 
3c94			 
3c94					if DEBUG_FORTH_WORDS 
3c94						DMARK "RNk" 
3c94 f5				push af  
3c95 3a a9 3c			ld a, (.dmark)  
3c98 32 65 ee			ld (debug_mark),a  
3c9b 3a aa 3c			ld a, (.dmark+1)  
3c9e 32 66 ee			ld (debug_mark+1),a  
3ca1 3a ab 3c			ld a, (.dmark+2)  
3ca4 32 67 ee			ld (debug_mark+2),a  
3ca7 18 03			jr .pastdmark  
3ca9 ..			.dmark: db "RNk"  
3cac f1			.pastdmark: pop af  
3cad			endm  
# End of macro DMARK
3cad						CALLMONITOR 
3cad cd 6f ee			call debug_vector  
3cb0				endm  
# End of macro CALLMONITOR
3cb0					endif 
3cb0			.hirange:   
3cb0 e5					push hl  
3cb1 b7					or a  
3cb2 ed 52		                sbc hl, de 
3cb4			 
3cb4					;call cmp16 
3cb4			 
3cb4 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3cb6 e1					pop hl 
3cb7 e5					push hl 
3cb8			 
3cb8					if DEBUG_FORTH_WORDS 
3cb8						DMARK "RN4" 
3cb8 f5				push af  
3cb9 3a cd 3c			ld a, (.dmark)  
3cbc 32 65 ee			ld (debug_mark),a  
3cbf 3a ce 3c			ld a, (.dmark+1)  
3cc2 32 66 ee			ld (debug_mark+1),a  
3cc5 3a cf 3c			ld a, (.dmark+2)  
3cc8 32 67 ee			ld (debug_mark+2),a  
3ccb 18 03			jr .pastdmark  
3ccd ..			.dmark: db "RN4"  
3cd0 f1			.pastdmark: pop af  
3cd1			endm  
# End of macro DMARK
3cd1						CALLMONITOR 
3cd1 cd 6f ee			call debug_vector  
3cd4				endm  
# End of macro CALLMONITOR
3cd4					endif 
3cd4 ed 5b a9 eb			ld de, (LFSRSeed+2)   ; check low range 
3cd8					;call cmp16 
3cd8				 
3cd8 b7					or a  
3cd9 ed 52		                sbc hl, de 
3cdb 38 8c				jr c, .inrange 
3cdd			 
3cdd e1					pop hl 
3cde					 
3cde					if DEBUG_FORTH_WORDS 
3cde						DMARK "RNd" 
3cde f5				push af  
3cdf 3a f3 3c			ld a, (.dmark)  
3ce2 32 65 ee			ld (debug_mark),a  
3ce5 3a f4 3c			ld a, (.dmark+1)  
3ce8 32 66 ee			ld (debug_mark+1),a  
3ceb 3a f5 3c			ld a, (.dmark+2)  
3cee 32 67 ee			ld (debug_mark+2),a  
3cf1 18 03			jr .pastdmark  
3cf3 ..			.dmark: db "RNd"  
3cf6 f1			.pastdmark: pop af  
3cf7			endm  
# End of macro DMARK
3cf7						CALLMONITOR 
3cf7 cd 6f ee			call debug_vector  
3cfa				endm  
# End of macro CALLMONITOR
3cfa					endif 
3cfa			 
3cfa			 
3cfa cd 90 1b				call forth_push_numhl 
3cfd				       NEXTW 
3cfd c3 80 1f			jp macro_next 
3d00				endm 
# End of macro NEXTW
3d00			 
3d00			.ENDMATHS: 
3d00			 
3d00			; eof 
3d00			 
# End of file forth_words_maths.asm
3d00			include "forth_words_display.asm" 
3d00			 
3d00			; | ## Display Words 
3d00			 
3d00			.ACT: 
3d00			 
3d00				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3d00 62				db WORD_SYS_CORE+78             
3d01 4c 3d			dw .INFO            
3d03 07				db 6 + 1 
3d04 .. 00			db "ACTIVE",0              
3d0b				endm 
# End of macro CWHEAD
3d0b			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3d0b			;  
3d0b			; | | To display a pulsing activity indicator in a processing loop do this... 
3d0b			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3d0b			 
3d0b					if DEBUG_FORTH_WORDS_KEY 
3d0b						DMARK "ACT" 
3d0b f5				push af  
3d0c 3a 20 3d			ld a, (.dmark)  
3d0f 32 65 ee			ld (debug_mark),a  
3d12 3a 21 3d			ld a, (.dmark+1)  
3d15 32 66 ee			ld (debug_mark+1),a  
3d18 3a 22 3d			ld a, (.dmark+2)  
3d1b 32 67 ee			ld (debug_mark+2),a  
3d1e 18 03			jr .pastdmark  
3d20 ..			.dmark: db "ACT"  
3d23 f1			.pastdmark: pop af  
3d24			endm  
# End of macro DMARK
3d24						CALLMONITOR 
3d24 cd 6f ee			call debug_vector  
3d27				endm  
# End of macro CALLMONITOR
3d27					endif 
3d27 cd 1f 0b				call active 
3d2a					if DEBUG_FORTH_WORDS 
3d2a						DMARK "ACp" 
3d2a f5				push af  
3d2b 3a 3f 3d			ld a, (.dmark)  
3d2e 32 65 ee			ld (debug_mark),a  
3d31 3a 40 3d			ld a, (.dmark+1)  
3d34 32 66 ee			ld (debug_mark+1),a  
3d37 3a 41 3d			ld a, (.dmark+2)  
3d3a 32 67 ee			ld (debug_mark+2),a  
3d3d 18 03			jr .pastdmark  
3d3f ..			.dmark: db "ACp"  
3d42 f1			.pastdmark: pop af  
3d43			endm  
# End of macro DMARK
3d43						CALLMONITOR 
3d43 cd 6f ee			call debug_vector  
3d46				endm  
# End of macro CALLMONITOR
3d46					endif 
3d46 cd fe 1b				call forth_push_str 
3d49			 
3d49					NEXTW 
3d49 c3 80 1f			jp macro_next 
3d4c				endm 
# End of macro NEXTW
3d4c			.INFO: 
3d4c			 
3d4c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d4c 62				db WORD_SYS_CORE+78             
3d4d 69 3d			dw .ATP            
3d4f 05				db 4 + 1 
3d50 .. 00			db "INFO",0              
3d55				endm 
# End of macro CWHEAD
3d55			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d55					FORTH_DSP_VALUEHL 
3d55 cd 95 1d			call macro_dsp_valuehl 
3d58				endm 
# End of macro FORTH_DSP_VALUEHL
3d58			 
3d58					FORTH_DSP_POP 
3d58 cd 4d 1e			call macro_forth_dsp_pop 
3d5b				endm 
# End of macro FORTH_DSP_POP
3d5b			 
3d5b e5					push hl 
3d5c			 
3d5c					FORTH_DSP_VALUEHL 
3d5c cd 95 1d			call macro_dsp_valuehl 
3d5f				endm 
# End of macro FORTH_DSP_VALUEHL
3d5f			 
3d5f					FORTH_DSP_POP 
3d5f cd 4d 1e			call macro_forth_dsp_pop 
3d62				endm 
# End of macro FORTH_DSP_POP
3d62			 
3d62 d1					pop de 
3d63			 
3d63 cd 59 0b				call info_panel 
3d66			 
3d66			 
3d66					NEXTW 
3d66 c3 80 1f			jp macro_next 
3d69				endm 
# End of macro NEXTW
3d69			.ATP: 
3d69				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3d69 62				db WORD_SYS_CORE+78             
3d6a e0 3d			dw .FB            
3d6c 04				db 3 + 1 
3d6d .. 00			db "AT?",0              
3d71				endm 
# End of macro CWHEAD
3d71			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d71					if DEBUG_FORTH_WORDS_KEY 
3d71						DMARK "AT?" 
3d71 f5				push af  
3d72 3a 86 3d			ld a, (.dmark)  
3d75 32 65 ee			ld (debug_mark),a  
3d78 3a 87 3d			ld a, (.dmark+1)  
3d7b 32 66 ee			ld (debug_mark+1),a  
3d7e 3a 88 3d			ld a, (.dmark+2)  
3d81 32 67 ee			ld (debug_mark+2),a  
3d84 18 03			jr .pastdmark  
3d86 ..			.dmark: db "AT?"  
3d89 f1			.pastdmark: pop af  
3d8a			endm  
# End of macro DMARK
3d8a						CALLMONITOR 
3d8a cd 6f ee			call debug_vector  
3d8d				endm  
# End of macro CALLMONITOR
3d8d					endif 
3d8d 3a 58 ea				ld a, (f_cursor_ptr) 
3d90			 
3d90			if DEBUG_FORTH_WORDS 
3d90				DMARK "AT?" 
3d90 f5				push af  
3d91 3a a5 3d			ld a, (.dmark)  
3d94 32 65 ee			ld (debug_mark),a  
3d97 3a a6 3d			ld a, (.dmark+1)  
3d9a 32 66 ee			ld (debug_mark+1),a  
3d9d 3a a7 3d			ld a, (.dmark+2)  
3da0 32 67 ee			ld (debug_mark+2),a  
3da3 18 03			jr .pastdmark  
3da5 ..			.dmark: db "AT?"  
3da8 f1			.pastdmark: pop af  
3da9			endm  
# End of macro DMARK
3da9				CALLMONITOR 
3da9 cd 6f ee			call debug_vector  
3dac				endm  
# End of macro CALLMONITOR
3dac			endif	 
3dac					; count the number of rows 
3dac			 
3dac 06 00				ld b, 0 
3dae 4f			.atpr:		ld c, a    ; save in case we go below zero 
3daf d6 28				sub display_cols 
3db1 f2 b7 3d				jp p, .atprunder 
3db4 04					inc b 
3db5 18 f7				jr .atpr 
3db7			.atprunder:	 
3db7			if DEBUG_FORTH_WORDS 
3db7				DMARK "A?2" 
3db7 f5				push af  
3db8 3a cc 3d			ld a, (.dmark)  
3dbb 32 65 ee			ld (debug_mark),a  
3dbe 3a cd 3d			ld a, (.dmark+1)  
3dc1 32 66 ee			ld (debug_mark+1),a  
3dc4 3a ce 3d			ld a, (.dmark+2)  
3dc7 32 67 ee			ld (debug_mark+2),a  
3dca 18 03			jr .pastdmark  
3dcc ..			.dmark: db "A?2"  
3dcf f1			.pastdmark: pop af  
3dd0			endm  
# End of macro DMARK
3dd0				CALLMONITOR 
3dd0 cd 6f ee			call debug_vector  
3dd3				endm  
# End of macro CALLMONITOR
3dd3			endif	 
3dd3 26 00				ld h, 0 
3dd5 69					ld l, c 
3dd6 cd 90 1b				call forth_push_numhl 
3dd9 68					ld l, b  
3dda cd 90 1b				call forth_push_numhl 
3ddd			 
3ddd			 
3ddd				NEXTW 
3ddd c3 80 1f			jp macro_next 
3de0				endm 
# End of macro NEXTW
3de0			 
3de0			.FB: 
3de0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3de0 1b				db WORD_SYS_CORE+7             
3de1 2e 3e			dw .EMIT            
3de3 03				db 2 + 1 
3de4 .. 00			db "FB",0              
3de7				endm 
# End of macro CWHEAD
3de7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3de7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3de7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3de7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3de7					if DEBUG_FORTH_WORDS_KEY 
3de7						DMARK "FB." 
3de7 f5				push af  
3de8 3a fc 3d			ld a, (.dmark)  
3deb 32 65 ee			ld (debug_mark),a  
3dee 3a fd 3d			ld a, (.dmark+1)  
3df1 32 66 ee			ld (debug_mark+1),a  
3df4 3a fe 3d			ld a, (.dmark+2)  
3df7 32 67 ee			ld (debug_mark+2),a  
3dfa 18 03			jr .pastdmark  
3dfc ..			.dmark: db "FB."  
3dff f1			.pastdmark: pop af  
3e00			endm  
# End of macro DMARK
3e00						CALLMONITOR 
3e00 cd 6f ee			call debug_vector  
3e03				endm  
# End of macro CALLMONITOR
3e03					endif 
3e03			 
3e03					FORTH_DSP_VALUEHL 
3e03 cd 95 1d			call macro_dsp_valuehl 
3e06				endm 
# End of macro FORTH_DSP_VALUEHL
3e06			 
3e06 7d					ld a, l 
3e07 fe 01				cp 1 
3e09 20 05				jr nz, .fbn1 
3e0b 21 0a ed				ld hl, display_fb1 
3e0e 18 15				jr .fbset 
3e10 fe 02		.fbn1:		cp 2 
3e12 20 05				jr nz, .fbn2 
3e14 21 c8 eb				ld hl, display_fb2 
3e17 18 0c				jr .fbset 
3e19 fe 03		.fbn2:		cp 3 
3e1b 20 05				jr nz, .fbn3 
3e1d 21 69 ec				ld hl, display_fb3 
3e20 18 03				jr .fbset 
3e22			.fbn3:		 ; if invalid number select first 
3e22 21 0a ed				ld hl, display_fb1 
3e25 22 c6 eb		.fbset:		ld (display_fb_active), hl 
3e28			 
3e28					FORTH_DSP_POP 
3e28 cd 4d 1e			call macro_forth_dsp_pop 
3e2b				endm 
# End of macro FORTH_DSP_POP
3e2b			 
3e2b					NEXTW 
3e2b c3 80 1f			jp macro_next 
3e2e				endm 
# End of macro NEXTW
3e2e			 
3e2e			 
3e2e			.EMIT: 
3e2e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3e2e 1b				db WORD_SYS_CORE+7             
3e2f 7f 3e			dw .DOTH            
3e31 05				db 4 + 1 
3e32 .. 00			db "EMIT",0              
3e37				endm 
# End of macro CWHEAD
3e37			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3e37					; get value off TOS and display it 
3e37			 
3e37					if DEBUG_FORTH_WORDS_KEY 
3e37						DMARK "EMT" 
3e37 f5				push af  
3e38 3a 4c 3e			ld a, (.dmark)  
3e3b 32 65 ee			ld (debug_mark),a  
3e3e 3a 4d 3e			ld a, (.dmark+1)  
3e41 32 66 ee			ld (debug_mark+1),a  
3e44 3a 4e 3e			ld a, (.dmark+2)  
3e47 32 67 ee			ld (debug_mark+2),a  
3e4a 18 03			jr .pastdmark  
3e4c ..			.dmark: db "EMT"  
3e4f f1			.pastdmark: pop af  
3e50			endm  
# End of macro DMARK
3e50						CALLMONITOR 
3e50 cd 6f ee			call debug_vector  
3e53				endm  
# End of macro CALLMONITOR
3e53					endif 
3e53			 
3e53					FORTH_DSP_VALUEHL 
3e53 cd 95 1d			call macro_dsp_valuehl 
3e56				endm 
# End of macro FORTH_DSP_VALUEHL
3e56			 
3e56 7d					ld a,l 
3e57			 
3e57					; TODO write to display 
3e57			 
3e57 32 b9 e4				ld (os_input), a 
3e5a 3e 00				ld a, 0 
3e5c 32 ba e4				ld (os_input+1), a 
3e5f					 
3e5f 3a 58 ea				ld a, (f_cursor_ptr) 
3e62 11 b9 e4				ld de, os_input 
3e65 cd db 0b				call str_at_display 
3e68			 
3e68			 
3e68 3a 36 ea				ld a,(cli_autodisplay) 
3e6b fe 00				cp 0 
3e6d 28 03				jr z, .enoupdate 
3e6f cd eb 0b						call update_display 
3e72					.enoupdate: 
3e72			 
3e72 3a 58 ea				ld a, (f_cursor_ptr) 
3e75 3c					inc a 
3e76 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
3e79			 
3e79			 
3e79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e79 cd 4d 1e			call macro_forth_dsp_pop 
3e7c				endm 
# End of macro FORTH_DSP_POP
3e7c			  
3e7c			 
3e7c					NEXTW 
3e7c c3 80 1f			jp macro_next 
3e7f				endm 
# End of macro NEXTW
3e7f			.DOTH: 
3e7f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e7f 1c				db WORD_SYS_CORE+8             
3e80 af 3e			dw .DOTF            
3e82 03				db 2 + 1 
3e83 .. 00			db ".-",0              
3e86				endm 
# End of macro CWHEAD
3e86			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e86					; get value off TOS and display it 
3e86					if DEBUG_FORTH_WORDS_KEY 
3e86						DMARK "DTD" 
3e86 f5				push af  
3e87 3a 9b 3e			ld a, (.dmark)  
3e8a 32 65 ee			ld (debug_mark),a  
3e8d 3a 9c 3e			ld a, (.dmark+1)  
3e90 32 66 ee			ld (debug_mark+1),a  
3e93 3a 9d 3e			ld a, (.dmark+2)  
3e96 32 67 ee			ld (debug_mark+2),a  
3e99 18 03			jr .pastdmark  
3e9b ..			.dmark: db "DTD"  
3e9e f1			.pastdmark: pop af  
3e9f			endm  
# End of macro DMARK
3e9f						CALLMONITOR 
3e9f cd 6f ee			call debug_vector  
3ea2				endm  
# End of macro CALLMONITOR
3ea2					endif 
3ea2 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ea4 3e 00			ld a, 0 
3ea6 32 37 ea			ld (cli_mvdot), a 
3ea9 c3 06 3f			jp .dotgo 
3eac				NEXTW 
3eac c3 80 1f			jp macro_next 
3eaf				endm 
# End of macro NEXTW
3eaf			.DOTF: 
3eaf				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3eaf 1c				db WORD_SYS_CORE+8             
3eb0 dd 3e			dw .DOT            
3eb2 03				db 2 + 1 
3eb3 .. 00			db ".>",0              
3eb6				endm 
# End of macro CWHEAD
3eb6			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3eb6					; get value off TOS and display it 
3eb6			        ; TODO BUG adds extra spaces 
3eb6			        ; TODO BUG handle numerics? 
3eb6					if DEBUG_FORTH_WORDS_KEY 
3eb6						DMARK "DTC" 
3eb6 f5				push af  
3eb7 3a cb 3e			ld a, (.dmark)  
3eba 32 65 ee			ld (debug_mark),a  
3ebd 3a cc 3e			ld a, (.dmark+1)  
3ec0 32 66 ee			ld (debug_mark+1),a  
3ec3 3a cd 3e			ld a, (.dmark+2)  
3ec6 32 67 ee			ld (debug_mark+2),a  
3ec9 18 03			jr .pastdmark  
3ecb ..			.dmark: db "DTC"  
3ece f1			.pastdmark: pop af  
3ecf			endm  
# End of macro DMARK
3ecf						CALLMONITOR 
3ecf cd 6f ee			call debug_vector  
3ed2				endm  
# End of macro CALLMONITOR
3ed2					endif 
3ed2 3e 01			ld a, 1 
3ed4 32 37 ea			ld (cli_mvdot), a 
3ed7 c3 06 3f			jp .dotgo 
3eda				NEXTW 
3eda c3 80 1f			jp macro_next 
3edd				endm 
# End of macro NEXTW
3edd			 
3edd			.DOT: 
3edd				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3edd 1c				db WORD_SYS_CORE+8             
3ede b9 40			dw .CLS            
3ee0 02				db 1 + 1 
3ee1 .. 00			db ".",0              
3ee3				endm 
# End of macro CWHEAD
3ee3			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3ee3					; get value off TOS and display it 
3ee3			 
3ee3					if DEBUG_FORTH_WORDS_KEY 
3ee3						DMARK "DOT" 
3ee3 f5				push af  
3ee4 3a f8 3e			ld a, (.dmark)  
3ee7 32 65 ee			ld (debug_mark),a  
3eea 3a f9 3e			ld a, (.dmark+1)  
3eed 32 66 ee			ld (debug_mark+1),a  
3ef0 3a fa 3e			ld a, (.dmark+2)  
3ef3 32 67 ee			ld (debug_mark+2),a  
3ef6 18 03			jr .pastdmark  
3ef8 ..			.dmark: db "DOT"  
3efb f1			.pastdmark: pop af  
3efc			endm  
# End of macro DMARK
3efc						CALLMONITOR 
3efc cd 6f ee			call debug_vector  
3eff				endm  
# End of macro CALLMONITOR
3eff					endif 
3eff 3e 00			ld a, 0 
3f01 32 37 ea			ld (cli_mvdot), a 
3f04 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3f06				 
3f06			 
3f06			.dotgo: 
3f06			 
3f06			; move up type to on stack for parserv5 
3f06					FORTH_DSP 
3f06 cd 5b 1d			call macro_forth_dsp 
3f09				endm 
# End of macro FORTH_DSP
3f09				;FORTH_DSP_VALUE  
3f09			 
3f09			if DEBUG_FORTH_DOT 
3f09				DMARK "DOT" 
3f09 f5				push af  
3f0a 3a 1e 3f			ld a, (.dmark)  
3f0d 32 65 ee			ld (debug_mark),a  
3f10 3a 1f 3f			ld a, (.dmark+1)  
3f13 32 66 ee			ld (debug_mark+1),a  
3f16 3a 20 3f			ld a, (.dmark+2)  
3f19 32 67 ee			ld (debug_mark+2),a  
3f1c 18 03			jr .pastdmark  
3f1e ..			.dmark: db "DOT"  
3f21 f1			.pastdmark: pop af  
3f22			endm  
# End of macro DMARK
3f22				CALLMONITOR 
3f22 cd 6f ee			call debug_vector  
3f25				endm  
# End of macro CALLMONITOR
3f25			endif	 
3f25			;		.print: 
3f25			 
3f25 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3f26 23				inc hl   ; position to the actual value 
3f27 fe 01			cp DS_TYPE_STR 
3f29 20 06			jr nz, .dotnum1  
3f2b			 
3f2b			; display string 
3f2b				FORTH_DSP_VALUE  
3f2b cd 7e 1d			call macro_forth_dsp_value 
3f2e				endm 
# End of macro FORTH_DSP_VALUE
3f2e eb				ex de,hl 
3f2f 18 49			jr .dotwrite 
3f31			 
3f31			.dotnum1: 
3f31 fe 02			cp DS_TYPE_INUM 
3f33 20 44			jr nz, .dotflot 
3f35			 
3f35			 
3f35			; display number 
3f35			 
3f35			;	push hl 
3f35			;	call clear_display 
3f35			;	pop hl 
3f35			 
3f35 5e				ld e, (hl) 
3f36 23				inc hl 
3f37 56				ld d, (hl) 
3f38 21 bb e2			ld hl, scratch 
3f3b			if DEBUG_FORTH_DOT 
3f3b				DMARK "DT1" 
3f3b f5				push af  
3f3c 3a 50 3f			ld a, (.dmark)  
3f3f 32 65 ee			ld (debug_mark),a  
3f42 3a 51 3f			ld a, (.dmark+1)  
3f45 32 66 ee			ld (debug_mark+1),a  
3f48 3a 52 3f			ld a, (.dmark+2)  
3f4b 32 67 ee			ld (debug_mark+2),a  
3f4e 18 03			jr .pastdmark  
3f50 ..			.dmark: db "DT1"  
3f53 f1			.pastdmark: pop af  
3f54			endm  
# End of macro DMARK
3f54				CALLMONITOR 
3f54 cd 6f ee			call debug_vector  
3f57				endm  
# End of macro CALLMONITOR
3f57			endif	 
3f57			 
3f57 cd 0a 11			call uitoa_16 
3f5a eb				ex de,hl 
3f5b			 
3f5b			if DEBUG_FORTH_DOT 
3f5b				DMARK "DT2" 
3f5b f5				push af  
3f5c 3a 70 3f			ld a, (.dmark)  
3f5f 32 65 ee			ld (debug_mark),a  
3f62 3a 71 3f			ld a, (.dmark+1)  
3f65 32 66 ee			ld (debug_mark+1),a  
3f68 3a 72 3f			ld a, (.dmark+2)  
3f6b 32 67 ee			ld (debug_mark+2),a  
3f6e 18 03			jr .pastdmark  
3f70 ..			.dmark: db "DT2"  
3f73 f1			.pastdmark: pop af  
3f74			endm  
# End of macro DMARK
3f74				CALLMONITOR 
3f74 cd 6f ee			call debug_vector  
3f77				endm  
# End of macro CALLMONITOR
3f77			endif	 
3f77			 
3f77			;	ld de, os_word_scratch 
3f77 18 01			jr .dotwrite 
3f79			 
3f79 00			.dotflot:   nop 
3f7a			; TODO print floating point number 
3f7a			 
3f7a			.dotwrite:		 
3f7a			 
3f7a					; if c is set then set all '-' to spaces 
3f7a					; need to also take into account .>  
3f7a			 
3f7a 3e 01				ld a, 1 
3f7c b9					cp c 
3f7d 20 67				jr nz, .nodashswap 
3f7f			 
3f7f					; DE has the string to write, working with HL 
3f7f			 
3f7f 06 ff				ld b, 255 
3f81 d5					push de 
3f82 e1					pop hl 
3f83			 
3f83			if DEBUG_FORTH_DOT 
3f83				DMARK "DT-" 
3f83 f5				push af  
3f84 3a 98 3f			ld a, (.dmark)  
3f87 32 65 ee			ld (debug_mark),a  
3f8a 3a 99 3f			ld a, (.dmark+1)  
3f8d 32 66 ee			ld (debug_mark+1),a  
3f90 3a 9a 3f			ld a, (.dmark+2)  
3f93 32 67 ee			ld (debug_mark+2),a  
3f96 18 03			jr .pastdmark  
3f98 ..			.dmark: db "DT-"  
3f9b f1			.pastdmark: pop af  
3f9c			endm  
# End of macro DMARK
3f9c				CALLMONITOR 
3f9c cd 6f ee			call debug_vector  
3f9f				endm  
# End of macro CALLMONITOR
3f9f			endif	 
3f9f 7e			.dashscan:	ld a, (hl) 
3fa0 fe 00				cp 0 
3fa2 28 42				jr z, .nodashswap 
3fa4 fe 2d				cp '-' 
3fa6 20 03				jr nz, .dashskip 
3fa8 3e 20				ld a, ' ' 
3faa 77					ld (hl), a 
3fab 23			.dashskip:	inc hl 
3fac			if DEBUG_FORTH_DOT 
3fac				DMARK "D-2" 
3fac f5				push af  
3fad 3a c1 3f			ld a, (.dmark)  
3fb0 32 65 ee			ld (debug_mark),a  
3fb3 3a c2 3f			ld a, (.dmark+1)  
3fb6 32 66 ee			ld (debug_mark+1),a  
3fb9 3a c3 3f			ld a, (.dmark+2)  
3fbc 32 67 ee			ld (debug_mark+2),a  
3fbf 18 03			jr .pastdmark  
3fc1 ..			.dmark: db "D-2"  
3fc4 f1			.pastdmark: pop af  
3fc5			endm  
# End of macro DMARK
3fc5				CALLMONITOR 
3fc5 cd 6f ee			call debug_vector  
3fc8				endm  
# End of macro CALLMONITOR
3fc8			endif	 
3fc8 10 d5				djnz .dashscan 
3fca			 
3fca			if DEBUG_FORTH_DOT 
3fca				DMARK "D-1" 
3fca f5				push af  
3fcb 3a df 3f			ld a, (.dmark)  
3fce 32 65 ee			ld (debug_mark),a  
3fd1 3a e0 3f			ld a, (.dmark+1)  
3fd4 32 66 ee			ld (debug_mark+1),a  
3fd7 3a e1 3f			ld a, (.dmark+2)  
3fda 32 67 ee			ld (debug_mark+2),a  
3fdd 18 03			jr .pastdmark  
3fdf ..			.dmark: db "D-1"  
3fe2 f1			.pastdmark: pop af  
3fe3			endm  
# End of macro DMARK
3fe3				CALLMONITOR 
3fe3 cd 6f ee			call debug_vector  
3fe6				endm  
# End of macro CALLMONITOR
3fe6			endif	 
3fe6			 
3fe6			.nodashswap: 
3fe6			 
3fe6			if DEBUG_FORTH_DOT 
3fe6				DMARK "D-o" 
3fe6 f5				push af  
3fe7 3a fb 3f			ld a, (.dmark)  
3fea 32 65 ee			ld (debug_mark),a  
3fed 3a fc 3f			ld a, (.dmark+1)  
3ff0 32 66 ee			ld (debug_mark+1),a  
3ff3 3a fd 3f			ld a, (.dmark+2)  
3ff6 32 67 ee			ld (debug_mark+2),a  
3ff9 18 03			jr .pastdmark  
3ffb ..			.dmark: db "D-o"  
3ffe f1			.pastdmark: pop af  
3fff			endm  
# End of macro DMARK
3fff				CALLMONITOR 
3fff cd 6f ee			call debug_vector  
4002				endm  
# End of macro CALLMONITOR
4002			endif	 
4002			 
4002 d5					push de   ; save string start in case we need to advance print 
4003			 
4003 3a 58 ea				ld a, (f_cursor_ptr) 
4006 cd db 0b				call str_at_display 
4009 3a 36 ea				ld a,(cli_autodisplay) 
400c fe 00				cp 0 
400e 28 03				jr z, .noupdate 
4010 cd eb 0b						call update_display 
4013					.noupdate: 
4013			 
4013			 
4013					; see if we need to advance the print position 
4013			 
4013 e1					pop hl   ; get back string 
4014			;		ex de,hl 
4014			 
4014 3a 37 ea				ld a, (cli_mvdot) 
4017			if DEBUG_FORTH_DOT 
4017			;		ld e,a 
4017				DMARK "D>1" 
4017 f5				push af  
4018 3a 2c 40			ld a, (.dmark)  
401b 32 65 ee			ld (debug_mark),a  
401e 3a 2d 40			ld a, (.dmark+1)  
4021 32 66 ee			ld (debug_mark+1),a  
4024 3a 2e 40			ld a, (.dmark+2)  
4027 32 67 ee			ld (debug_mark+2),a  
402a 18 03			jr .pastdmark  
402c ..			.dmark: db "D>1"  
402f f1			.pastdmark: pop af  
4030			endm  
# End of macro DMARK
4030				CALLMONITOR 
4030 cd 6f ee			call debug_vector  
4033				endm  
# End of macro CALLMONITOR
4033			endif	 
4033 fe 00				cp 0 
4035 28 44				jr z, .noadv 
4037					; yes, lets advance the print position 
4037 3e 00				ld a, 0 
4039 cd 66 11				call strlent 
403c			if DEBUG_FORTH_DOT 
403c				DMARK "D-?" 
403c f5				push af  
403d 3a 51 40			ld a, (.dmark)  
4040 32 65 ee			ld (debug_mark),a  
4043 3a 52 40			ld a, (.dmark+1)  
4046 32 66 ee			ld (debug_mark+1),a  
4049 3a 53 40			ld a, (.dmark+2)  
404c 32 67 ee			ld (debug_mark+2),a  
404f 18 03			jr .pastdmark  
4051 ..			.dmark: db "D-?"  
4054 f1			.pastdmark: pop af  
4055			endm  
# End of macro DMARK
4055				CALLMONITOR 
4055 cd 6f ee			call debug_vector  
4058				endm  
# End of macro CALLMONITOR
4058			endif	 
4058 3a 58 ea				ld a, (f_cursor_ptr) 
405b 85					add a,l 
405c					;call addatohl 
405c					;ld a, l 
405c 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
405f			 
405f			if DEBUG_FORTH_DOT 
405f				DMARK "D->" 
405f f5				push af  
4060 3a 74 40			ld a, (.dmark)  
4063 32 65 ee			ld (debug_mark),a  
4066 3a 75 40			ld a, (.dmark+1)  
4069 32 66 ee			ld (debug_mark+1),a  
406c 3a 76 40			ld a, (.dmark+2)  
406f 32 67 ee			ld (debug_mark+2),a  
4072 18 03			jr .pastdmark  
4074 ..			.dmark: db "D->"  
4077 f1			.pastdmark: pop af  
4078			endm  
# End of macro DMARK
4078				CALLMONITOR 
4078 cd 6f ee			call debug_vector  
407b				endm  
# End of macro CALLMONITOR
407b			endif	 
407b			 
407b			.noadv:	 
407b			 
407b					if DEBUG_FORTH_DOT_WAIT 
407b							call next_page_prompt 
407b					endif	 
407b			; TODO this pop off the stack causes a crash. i dont know why 
407b			 
407b			 
407b			if DEBUG_FORTH_DOT 
407b				DMARK "DTh" 
407b f5				push af  
407c 3a 90 40			ld a, (.dmark)  
407f 32 65 ee			ld (debug_mark),a  
4082 3a 91 40			ld a, (.dmark+1)  
4085 32 66 ee			ld (debug_mark+1),a  
4088 3a 92 40			ld a, (.dmark+2)  
408b 32 67 ee			ld (debug_mark+2),a  
408e 18 03			jr .pastdmark  
4090 ..			.dmark: db "DTh"  
4093 f1			.pastdmark: pop af  
4094			endm  
# End of macro DMARK
4094				CALLMONITOR 
4094 cd 6f ee			call debug_vector  
4097				endm  
# End of macro CALLMONITOR
4097			endif	 
4097			 
4097					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4097 cd 4d 1e			call macro_forth_dsp_pop 
409a				endm 
# End of macro FORTH_DSP_POP
409a			 
409a			if DEBUG_FORTH_DOT 
409a				DMARK "DTi" 
409a f5				push af  
409b 3a af 40			ld a, (.dmark)  
409e 32 65 ee			ld (debug_mark),a  
40a1 3a b0 40			ld a, (.dmark+1)  
40a4 32 66 ee			ld (debug_mark+1),a  
40a7 3a b1 40			ld a, (.dmark+2)  
40aa 32 67 ee			ld (debug_mark+2),a  
40ad 18 03			jr .pastdmark  
40af ..			.dmark: db "DTi"  
40b2 f1			.pastdmark: pop af  
40b3			endm  
# End of macro DMARK
40b3				CALLMONITOR 
40b3 cd 6f ee			call debug_vector  
40b6				endm  
# End of macro CALLMONITOR
40b6			endif	 
40b6			 
40b6			 
40b6					NEXTW 
40b6 c3 80 1f			jp macro_next 
40b9				endm 
# End of macro NEXTW
40b9			 
40b9			.CLS: 
40b9				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
40b9 35				db WORD_SYS_CORE+33             
40ba e6 40			dw .DRAW            
40bc 04				db 3 + 1 
40bd .. 00			db "CLS",0              
40c1				endm 
# End of macro CWHEAD
40c1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
40c1					if DEBUG_FORTH_WORDS_KEY 
40c1						DMARK "CLS" 
40c1 f5				push af  
40c2 3a d6 40			ld a, (.dmark)  
40c5 32 65 ee			ld (debug_mark),a  
40c8 3a d7 40			ld a, (.dmark+1)  
40cb 32 66 ee			ld (debug_mark+1),a  
40ce 3a d8 40			ld a, (.dmark+2)  
40d1 32 67 ee			ld (debug_mark+2),a  
40d4 18 03			jr .pastdmark  
40d6 ..			.dmark: db "CLS"  
40d9 f1			.pastdmark: pop af  
40da			endm  
# End of macro DMARK
40da						CALLMONITOR 
40da cd 6f ee			call debug_vector  
40dd				endm  
# End of macro CALLMONITOR
40dd					endif 
40dd cd c8 0b				call clear_display 
40e0 c3 f4 41				jp .home		; and home cursor 
40e3					NEXTW 
40e3 c3 80 1f			jp macro_next 
40e6				endm 
# End of macro NEXTW
40e6			 
40e6			.DRAW: 
40e6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
40e6 36				db WORD_SYS_CORE+34             
40e7 11 41			dw .DUMP            
40e9 05				db 4 + 1 
40ea .. 00			db "DRAW",0              
40ef				endm 
# End of macro CWHEAD
40ef			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
40ef					if DEBUG_FORTH_WORDS_KEY 
40ef						DMARK "DRW" 
40ef f5				push af  
40f0 3a 04 41			ld a, (.dmark)  
40f3 32 65 ee			ld (debug_mark),a  
40f6 3a 05 41			ld a, (.dmark+1)  
40f9 32 66 ee			ld (debug_mark+1),a  
40fc 3a 06 41			ld a, (.dmark+2)  
40ff 32 67 ee			ld (debug_mark+2),a  
4102 18 03			jr .pastdmark  
4104 ..			.dmark: db "DRW"  
4107 f1			.pastdmark: pop af  
4108			endm  
# End of macro DMARK
4108						CALLMONITOR 
4108 cd 6f ee			call debug_vector  
410b				endm  
# End of macro CALLMONITOR
410b					endif 
410b cd eb 0b				call update_display 
410e					NEXTW 
410e c3 80 1f			jp macro_next 
4111				endm 
# End of macro NEXTW
4111			 
4111			.DUMP: 
4111				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4111 37				db WORD_SYS_CORE+35             
4112 49 41			dw .CDUMP            
4114 05				db 4 + 1 
4115 .. 00			db "DUMP",0              
411a				endm 
# End of macro CWHEAD
411a			; | DUMP ( x -- ) With address x display dump   | DONE 
411a			; TODO pop address to use off of the stack 
411a					if DEBUG_FORTH_WORDS_KEY 
411a						DMARK "DUM" 
411a f5				push af  
411b 3a 2f 41			ld a, (.dmark)  
411e 32 65 ee			ld (debug_mark),a  
4121 3a 30 41			ld a, (.dmark+1)  
4124 32 66 ee			ld (debug_mark+1),a  
4127 3a 31 41			ld a, (.dmark+2)  
412a 32 67 ee			ld (debug_mark+2),a  
412d 18 03			jr .pastdmark  
412f ..			.dmark: db "DUM"  
4132 f1			.pastdmark: pop af  
4133			endm  
# End of macro DMARK
4133						CALLMONITOR 
4133 cd 6f ee			call debug_vector  
4136				endm  
# End of macro CALLMONITOR
4136					endif 
4136 cd c8 0b				call clear_display 
4139			 
4139					; get address 
4139			 
4139					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4139 cd 95 1d			call macro_dsp_valuehl 
413c				endm 
# End of macro FORTH_DSP_VALUEHL
413c				 
413c					; save it for cdump 
413c			 
413c 22 de e5				ld (os_cur_ptr),hl 
413f			 
413f					; destroy value TOS 
413f			 
413f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
413f cd 4d 1e			call macro_forth_dsp_pop 
4142				endm 
# End of macro FORTH_DSP_POP
4142			 
4142 cd 10 1a				call dumpcont	; skip old style of param parsing	 
4145 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4146					NEXTW 
4146 c3 80 1f			jp macro_next 
4149				endm 
# End of macro NEXTW
4149			.CDUMP: 
4149				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4149 38				db WORD_SYS_CORE+36             
414a 79 41			dw .DAT            
414c 06				db 5 + 1 
414d .. 00			db "CDUMP",0              
4153				endm 
# End of macro CWHEAD
4153			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4153					if DEBUG_FORTH_WORDS_KEY 
4153						DMARK "CDP" 
4153 f5				push af  
4154 3a 68 41			ld a, (.dmark)  
4157 32 65 ee			ld (debug_mark),a  
415a 3a 69 41			ld a, (.dmark+1)  
415d 32 66 ee			ld (debug_mark+1),a  
4160 3a 6a 41			ld a, (.dmark+2)  
4163 32 67 ee			ld (debug_mark+2),a  
4166 18 03			jr .pastdmark  
4168 ..			.dmark: db "CDP"  
416b f1			.pastdmark: pop af  
416c			endm  
# End of macro DMARK
416c						CALLMONITOR 
416c cd 6f ee			call debug_vector  
416f				endm  
# End of macro CALLMONITOR
416f					endif 
416f cd c8 0b				call clear_display 
4172 cd 10 1a				call dumpcont	 
4175 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4176					NEXTW 
4176 c3 80 1f			jp macro_next 
4179				endm 
# End of macro NEXTW
4179			 
4179			 
4179			 
4179			 
4179			.DAT: 
4179				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4179 3d				db WORD_SYS_CORE+41             
417a cf 41			dw .HOME            
417c 03				db 2 + 1 
417d .. 00			db "AT",0              
4180				endm 
# End of macro CWHEAD
4180			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4180					if DEBUG_FORTH_WORDS_KEY 
4180						DMARK "AT." 
4180 f5				push af  
4181 3a 95 41			ld a, (.dmark)  
4184 32 65 ee			ld (debug_mark),a  
4187 3a 96 41			ld a, (.dmark+1)  
418a 32 66 ee			ld (debug_mark+1),a  
418d 3a 97 41			ld a, (.dmark+2)  
4190 32 67 ee			ld (debug_mark+2),a  
4193 18 03			jr .pastdmark  
4195 ..			.dmark: db "AT."  
4198 f1			.pastdmark: pop af  
4199			endm  
# End of macro DMARK
4199						CALLMONITOR 
4199 cd 6f ee			call debug_vector  
419c				endm  
# End of macro CALLMONITOR
419c					endif 
419c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
419c cd 95 1d			call macro_dsp_valuehl 
419f				endm 
# End of macro FORTH_DSP_VALUEHL
419f			 
419f			 
419f					; TODO save cursor row 
419f 7d					ld a,l 
41a0 fe 02				cp 2 
41a2 20 04				jr nz, .crow3 
41a4 3e 28				ld a, display_row_2 
41a6 18 12				jr .ccol1 
41a8 fe 03		.crow3:		cp 3 
41aa 20 04				jr nz, .crow4 
41ac 3e 50				ld a, display_row_3 
41ae 18 0a				jr .ccol1 
41b0 fe 04		.crow4:		cp 4 
41b2 20 04				jr nz, .crow1 
41b4 3e 78				ld a, display_row_4 
41b6 18 02				jr .ccol1 
41b8 3e 00		.crow1:		ld a,display_row_1 
41ba f5			.ccol1:		push af			; got row offset 
41bb 6f					ld l,a 
41bc 26 00				ld h,0 
41be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41be cd 4d 1e			call macro_forth_dsp_pop 
41c1				endm 
# End of macro FORTH_DSP_POP
41c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41c1 cd 95 1d			call macro_dsp_valuehl 
41c4				endm 
# End of macro FORTH_DSP_VALUEHL
41c4					; TODO save cursor col 
41c4 f1					pop af 
41c5 85					add l		; add col offset 
41c6 32 58 ea				ld (f_cursor_ptr), a 
41c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41c9 cd 4d 1e			call macro_forth_dsp_pop 
41cc				endm 
# End of macro FORTH_DSP_POP
41cc			 
41cc					; calculate  
41cc			 
41cc					NEXTW 
41cc c3 80 1f			jp macro_next 
41cf				endm 
# End of macro NEXTW
41cf			 
41cf			 
41cf			.HOME: 
41cf				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
41cf 41				db WORD_SYS_CORE+45             
41d0 fc 41			dw .CR            
41d2 05				db 4 + 1 
41d3 .. 00			db "HOME",0              
41d8				endm 
# End of macro CWHEAD
41d8			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
41d8					if DEBUG_FORTH_WORDS_KEY 
41d8						DMARK "HOM" 
41d8 f5				push af  
41d9 3a ed 41			ld a, (.dmark)  
41dc 32 65 ee			ld (debug_mark),a  
41df 3a ee 41			ld a, (.dmark+1)  
41e2 32 66 ee			ld (debug_mark+1),a  
41e5 3a ef 41			ld a, (.dmark+2)  
41e8 32 67 ee			ld (debug_mark+2),a  
41eb 18 03			jr .pastdmark  
41ed ..			.dmark: db "HOM"  
41f0 f1			.pastdmark: pop af  
41f1			endm  
# End of macro DMARK
41f1						CALLMONITOR 
41f1 cd 6f ee			call debug_vector  
41f4				endm  
# End of macro CALLMONITOR
41f4					endif 
41f4 3e 00		.home:		ld a, 0		; and home cursor 
41f6 32 58 ea				ld (f_cursor_ptr), a 
41f9					NEXTW 
41f9 c3 80 1f			jp macro_next 
41fc				endm 
# End of macro NEXTW
41fc			 
41fc			 
41fc			.CR: 
41fc				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
41fc 46				db WORD_SYS_CORE+50             
41fd 37 42			dw .SPACE            
41ff 03				db 2 + 1 
4200 .. 00			db "CR",0              
4203				endm 
# End of macro CWHEAD
4203			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4203					if DEBUG_FORTH_WORDS_KEY 
4203						DMARK "CR." 
4203 f5				push af  
4204 3a 18 42			ld a, (.dmark)  
4207 32 65 ee			ld (debug_mark),a  
420a 3a 19 42			ld a, (.dmark+1)  
420d 32 66 ee			ld (debug_mark+1),a  
4210 3a 1a 42			ld a, (.dmark+2)  
4213 32 67 ee			ld (debug_mark+2),a  
4216 18 03			jr .pastdmark  
4218 ..			.dmark: db "CR."  
421b f1			.pastdmark: pop af  
421c			endm  
# End of macro DMARK
421c						CALLMONITOR 
421c cd 6f ee			call debug_vector  
421f				endm  
# End of macro CALLMONITOR
421f					endif 
421f 3e 0d				ld a, 13 
4221 32 bb e2				ld (scratch),a 
4224 3e 0a				ld a, 10 
4226 32 bc e2				ld (scratch+1),a 
4229 3e 00				ld a, 0 
422b 32 bd e2				ld (scratch+2),a 
422e 21 bb e2				ld hl, scratch 
4231 cd fe 1b				call forth_push_str 
4234					 
4234				       NEXTW 
4234 c3 80 1f			jp macro_next 
4237				endm 
# End of macro NEXTW
4237			.SPACE: 
4237				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4237 46				db WORD_SYS_CORE+50             
4238 6d 42			dw .SPACES            
423a 03				db 2 + 1 
423b .. 00			db "BL",0              
423e				endm 
# End of macro CWHEAD
423e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
423e					if DEBUG_FORTH_WORDS_KEY 
423e						DMARK "BL." 
423e f5				push af  
423f 3a 53 42			ld a, (.dmark)  
4242 32 65 ee			ld (debug_mark),a  
4245 3a 54 42			ld a, (.dmark+1)  
4248 32 66 ee			ld (debug_mark+1),a  
424b 3a 55 42			ld a, (.dmark+2)  
424e 32 67 ee			ld (debug_mark+2),a  
4251 18 03			jr .pastdmark  
4253 ..			.dmark: db "BL."  
4256 f1			.pastdmark: pop af  
4257			endm  
# End of macro DMARK
4257						CALLMONITOR 
4257 cd 6f ee			call debug_vector  
425a				endm  
# End of macro CALLMONITOR
425a					endif 
425a 3e 20				ld a, " " 
425c 32 bb e2				ld (scratch),a 
425f 3e 00				ld a, 0 
4261 32 bc e2				ld (scratch+1),a 
4264 21 bb e2				ld hl, scratch 
4267 cd fe 1b				call forth_push_str 
426a					 
426a				       NEXTW 
426a c3 80 1f			jp macro_next 
426d				endm 
# End of macro NEXTW
426d			 
426d			;.blstr: db " ", 0 
426d			 
426d			.SPACES: 
426d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
426d 47				db WORD_SYS_CORE+51             
426e 08 43			dw .SCROLL            
4270 07				db 6 + 1 
4271 .. 00			db "SPACES",0              
4278				endm 
# End of macro CWHEAD
4278			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4278					if DEBUG_FORTH_WORDS_KEY 
4278						DMARK "SPS" 
4278 f5				push af  
4279 3a 8d 42			ld a, (.dmark)  
427c 32 65 ee			ld (debug_mark),a  
427f 3a 8e 42			ld a, (.dmark+1)  
4282 32 66 ee			ld (debug_mark+1),a  
4285 3a 8f 42			ld a, (.dmark+2)  
4288 32 67 ee			ld (debug_mark+2),a  
428b 18 03			jr .pastdmark  
428d ..			.dmark: db "SPS"  
4290 f1			.pastdmark: pop af  
4291			endm  
# End of macro DMARK
4291						CALLMONITOR 
4291 cd 6f ee			call debug_vector  
4294				endm  
# End of macro CALLMONITOR
4294					endif 
4294			 
4294			 
4294					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4294 cd 95 1d			call macro_dsp_valuehl 
4297				endm 
# End of macro FORTH_DSP_VALUEHL
4297			 
4297 e5					push hl    ; u 
4298					if DEBUG_FORTH_WORDS 
4298						DMARK "SPA" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 65 ee			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 66 ee			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 67 ee			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "SPA"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 6f ee			call debug_vector  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4			 
42b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42b4 cd 4d 1e			call macro_forth_dsp_pop 
42b7				endm 
# End of macro FORTH_DSP_POP
42b7 e1					pop hl 
42b8 0e 00				ld c, 0 
42ba 45					ld b, l 
42bb 21 bb e2				ld hl, scratch  
42be			 
42be					if DEBUG_FORTH_WORDS 
42be						DMARK "SP2" 
42be f5				push af  
42bf 3a d3 42			ld a, (.dmark)  
42c2 32 65 ee			ld (debug_mark),a  
42c5 3a d4 42			ld a, (.dmark+1)  
42c8 32 66 ee			ld (debug_mark+1),a  
42cb 3a d5 42			ld a, (.dmark+2)  
42ce 32 67 ee			ld (debug_mark+2),a  
42d1 18 03			jr .pastdmark  
42d3 ..			.dmark: db "SP2"  
42d6 f1			.pastdmark: pop af  
42d7			endm  
# End of macro DMARK
42d7						CALLMONITOR 
42d7 cd 6f ee			call debug_vector  
42da				endm  
# End of macro CALLMONITOR
42da					endif 
42da 3e 20				ld a, ' ' 
42dc			.spaces1:	 
42dc 77					ld (hl),a 
42dd 23					inc hl 
42de					 
42de 10 fc				djnz .spaces1 
42e0 3e 00				ld a,0 
42e2 77					ld (hl),a 
42e3 21 bb e2				ld hl, scratch 
42e6					if DEBUG_FORTH_WORDS 
42e6						DMARK "SP3" 
42e6 f5				push af  
42e7 3a fb 42			ld a, (.dmark)  
42ea 32 65 ee			ld (debug_mark),a  
42ed 3a fc 42			ld a, (.dmark+1)  
42f0 32 66 ee			ld (debug_mark+1),a  
42f3 3a fd 42			ld a, (.dmark+2)  
42f6 32 67 ee			ld (debug_mark+2),a  
42f9 18 03			jr .pastdmark  
42fb ..			.dmark: db "SP3"  
42fe f1			.pastdmark: pop af  
42ff			endm  
# End of macro DMARK
42ff						CALLMONITOR 
42ff cd 6f ee			call debug_vector  
4302				endm  
# End of macro CALLMONITOR
4302					endif 
4302 cd fe 1b				call forth_push_str 
4305			 
4305				       NEXTW 
4305 c3 80 1f			jp macro_next 
4308				endm 
# End of macro NEXTW
4308			 
4308			 
4308			 
4308			.SCROLL: 
4308				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4308 53				db WORD_SYS_CORE+63             
4309 35 43			dw .SCROLLD            
430b 07				db 6 + 1 
430c .. 00			db "SCROLL",0              
4313				endm 
# End of macro CWHEAD
4313			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4313					if DEBUG_FORTH_WORDS_KEY 
4313						DMARK "SCR" 
4313 f5				push af  
4314 3a 28 43			ld a, (.dmark)  
4317 32 65 ee			ld (debug_mark),a  
431a 3a 29 43			ld a, (.dmark+1)  
431d 32 66 ee			ld (debug_mark+1),a  
4320 3a 2a 43			ld a, (.dmark+2)  
4323 32 67 ee			ld (debug_mark+2),a  
4326 18 03			jr .pastdmark  
4328 ..			.dmark: db "SCR"  
432b f1			.pastdmark: pop af  
432c			endm  
# End of macro DMARK
432c						CALLMONITOR 
432c cd 6f ee			call debug_vector  
432f				endm  
# End of macro CALLMONITOR
432f					endif 
432f			 
432f cd 8a 0b			call scroll_up 
4332			;	call update_display 
4332			 
4332					NEXTW 
4332 c3 80 1f			jp macro_next 
4335				endm 
# End of macro NEXTW
4335			 
4335			 
4335			 
4335			;		; get dir 
4335			; 
4335			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4335			; 
4335			;		push hl 
4335			; 
4335			;		; destroy value TOS 
4335			; 
4335			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4335			; 
4335			;		; get count 
4335			; 
4335			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4335			; 
4335			;		push hl 
4335			; 
4335			;		; destroy value TOS 
4335			; 
4335			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4335			; 
4335			;		; one value on hl get other one back 
4335			; 
4335			;		pop bc    ; count 
4335			; 
4335			;		pop de   ; dir 
4335			; 
4335			; 
4335			;		ld b, c 
4335			; 
4335			;.scrolldir:     push bc 
4335			;		push de 
4335			; 
4335			;		ld a, 0 
4335			;		cp e 
4335			;		jr z, .scrollup  
4335			;		call scroll_down 
4335			;		jr .scrollnext 
4335			;.scrollup:	call scroll_up 
4335			; 
4335			;		 
4335			;.scrollnext: 
4335			;		pop de 
4335			;		pop bc 
4335			;		djnz .scrolldir 
4335			; 
4335			; 
4335			; 
4335			; 
4335			; 
4335			;		NEXTW 
4335			 
4335			.SCROLLD: 
4335				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4335 53				db WORD_SYS_CORE+63             
4336 63 43			dw .ATQ            
4338 08				db 7 + 1 
4339 .. 00			db "SCROLLD",0              
4341				endm 
# End of macro CWHEAD
4341			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4341					if DEBUG_FORTH_WORDS_KEY 
4341						DMARK "SCD" 
4341 f5				push af  
4342 3a 56 43			ld a, (.dmark)  
4345 32 65 ee			ld (debug_mark),a  
4348 3a 57 43			ld a, (.dmark+1)  
434b 32 66 ee			ld (debug_mark+1),a  
434e 3a 58 43			ld a, (.dmark+2)  
4351 32 67 ee			ld (debug_mark+2),a  
4354 18 03			jr .pastdmark  
4356 ..			.dmark: db "SCD"  
4359 f1			.pastdmark: pop af  
435a			endm  
# End of macro DMARK
435a						CALLMONITOR 
435a cd 6f ee			call debug_vector  
435d				endm  
# End of macro CALLMONITOR
435d					endif 
435d			 
435d cd ae 0b			call scroll_down 
4360			;	call update_display 
4360			 
4360					NEXTW 
4360 c3 80 1f			jp macro_next 
4363				endm 
# End of macro NEXTW
4363			 
4363			 
4363			.ATQ: 
4363				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4363 62				db WORD_SYS_CORE+78             
4364 c1 43			dw .AUTODSP            
4366 04				db 3 + 1 
4367 .. 00			db "AT@",0              
436b				endm 
# End of macro CWHEAD
436b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
436b					if DEBUG_FORTH_WORDS_KEY 
436b						DMARK "ATA" 
436b f5				push af  
436c 3a 80 43			ld a, (.dmark)  
436f 32 65 ee			ld (debug_mark),a  
4372 3a 81 43			ld a, (.dmark+1)  
4375 32 66 ee			ld (debug_mark+1),a  
4378 3a 82 43			ld a, (.dmark+2)  
437b 32 67 ee			ld (debug_mark+2),a  
437e 18 03			jr .pastdmark  
4380 ..			.dmark: db "ATA"  
4383 f1			.pastdmark: pop af  
4384			endm  
# End of macro DMARK
4384						CALLMONITOR 
4384 cd 6f ee			call debug_vector  
4387				endm  
# End of macro CALLMONITOR
4387					endif 
4387			 
4387			 
4387					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4387 cd 95 1d			call macro_dsp_valuehl 
438a				endm 
# End of macro FORTH_DSP_VALUEHL
438a			 
438a					; TODO save cursor row 
438a 7d					ld a,l 
438b fe 02				cp 2 
438d 20 04				jr nz, .crow3aq 
438f 3e 28				ld a, display_row_2 
4391 18 12				jr .ccol1aq 
4393 fe 03		.crow3aq:		cp 3 
4395 20 04				jr nz, .crow4aq 
4397 3e 50				ld a, display_row_3 
4399 18 0a				jr .ccol1aq 
439b fe 04		.crow4aq:		cp 4 
439d 20 04				jr nz, .crow1aq 
439f 3e 78				ld a, display_row_4 
43a1 18 02				jr .ccol1aq 
43a3 3e 00		.crow1aq:		ld a,display_row_1 
43a5 f5			.ccol1aq:		push af			; got row offset 
43a6 6f					ld l,a 
43a7 26 00				ld h,0 
43a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43a9 cd 4d 1e			call macro_forth_dsp_pop 
43ac				endm 
# End of macro FORTH_DSP_POP
43ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ac cd 95 1d			call macro_dsp_valuehl 
43af				endm 
# End of macro FORTH_DSP_VALUEHL
43af					; TODO save cursor col 
43af f1					pop af 
43b0 85					add l		; add col offset 
43b1			 
43b1					; add current frame buffer address 
43b1 2a c6 eb				ld hl, (display_fb_active) 
43b4 cd f5 0d				call addatohl 
43b7			 
43b7			 
43b7			 
43b7			 
43b7					; get char frame buffer location offset in hl 
43b7			 
43b7 7e					ld a,(hl) 
43b8 26 00				ld h, 0 
43ba 6f					ld l, a 
43bb			 
43bb cd 90 1b				call forth_push_numhl 
43be			 
43be			 
43be					NEXTW 
43be c3 80 1f			jp macro_next 
43c1				endm 
# End of macro NEXTW
43c1			 
43c1			.AUTODSP: 
43c1				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
43c1 63				db WORD_SYS_CORE+79             
43c2 d7 43			dw .MENU            
43c4 05				db 4 + 1 
43c5 .. 00			db "ADSP",0              
43ca				endm 
# End of macro CWHEAD
43ca			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
43ca			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
43ca			 
43ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ca cd 95 1d			call macro_dsp_valuehl 
43cd				endm 
# End of macro FORTH_DSP_VALUEHL
43cd			 
43cd			;		push hl 
43cd			 
43cd					; destroy value TOS 
43cd			 
43cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43cd cd 4d 1e			call macro_forth_dsp_pop 
43d0				endm 
# End of macro FORTH_DSP_POP
43d0			 
43d0			;		pop hl 
43d0			 
43d0 7d					ld a,l 
43d1 32 36 ea				ld (cli_autodisplay), a 
43d4				       NEXTW 
43d4 c3 80 1f			jp macro_next 
43d7				endm 
# End of macro NEXTW
43d7			 
43d7			.MENU: 
43d7				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
43d7 70				db WORD_SYS_CORE+92             
43d8 80 44			dw .ENDDISPLAY            
43da 05				db 4 + 1 
43db .. 00			db "MENU",0              
43e0				endm 
# End of macro CWHEAD
43e0			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
43e0			 
43e0			;		; get number of items on the stack 
43e0			; 
43e0				 
43e0					FORTH_DSP_VALUEHL 
43e0 cd 95 1d			call macro_dsp_valuehl 
43e3				endm 
# End of macro FORTH_DSP_VALUEHL
43e3				 
43e3					if DEBUG_FORTH_WORDS_KEY 
43e3						DMARK "MNU" 
43e3 f5				push af  
43e4 3a f8 43			ld a, (.dmark)  
43e7 32 65 ee			ld (debug_mark),a  
43ea 3a f9 43			ld a, (.dmark+1)  
43ed 32 66 ee			ld (debug_mark+1),a  
43f0 3a fa 43			ld a, (.dmark+2)  
43f3 32 67 ee			ld (debug_mark+2),a  
43f6 18 03			jr .pastdmark  
43f8 ..			.dmark: db "MNU"  
43fb f1			.pastdmark: pop af  
43fc			endm  
# End of macro DMARK
43fc						CALLMONITOR 
43fc cd 6f ee			call debug_vector  
43ff				endm  
# End of macro CALLMONITOR
43ff					endif 
43ff			 
43ff 45					ld b, l	 
4400 05					dec b 
4401			 
4401					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4401 cd 4d 1e			call macro_forth_dsp_pop 
4404				endm 
# End of macro FORTH_DSP_POP
4404			 
4404			 
4404					; go directly through the stack to pluck out the string pointers and build an array 
4404			 
4404			;		FORTH_DSP 
4404			 
4404					; hl contains top most stack item 
4404				 
4404 11 bb e2				ld de, scratch 
4407			 
4407			.mbuild: 
4407			 
4407					FORTH_DSP_VALUEHL 
4407 cd 95 1d			call macro_dsp_valuehl 
440a				endm 
# End of macro FORTH_DSP_VALUEHL
440a			 
440a					if DEBUG_FORTH_WORDS 
440a						DMARK "MN3" 
440a f5				push af  
440b 3a 1f 44			ld a, (.dmark)  
440e 32 65 ee			ld (debug_mark),a  
4411 3a 20 44			ld a, (.dmark+1)  
4414 32 66 ee			ld (debug_mark+1),a  
4417 3a 21 44			ld a, (.dmark+2)  
441a 32 67 ee			ld (debug_mark+2),a  
441d 18 03			jr .pastdmark  
441f ..			.dmark: db "MN3"  
4422 f1			.pastdmark: pop af  
4423			endm  
# End of macro DMARK
4423						CALLMONITOR 
4423 cd 6f ee			call debug_vector  
4426				endm  
# End of macro CALLMONITOR
4426					endif 
4426 eb					ex de, hl 
4427 73					ld (hl), e 
4428 23					inc hl 
4429 72					ld (hl), d 
442a 23					inc hl 
442b eb					ex de, hl 
442c			 
442c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
442c cd 4d 1e			call macro_forth_dsp_pop 
442f				endm 
# End of macro FORTH_DSP_POP
442f			 
442f 10 d6				djnz .mbuild 
4431			 
4431					; done add term 
4431			 
4431 eb					ex de, hl 
4432 36 00				ld (hl), 0 
4434 23					inc hl 
4435 36 00				ld (hl), 0 
4437			 
4437				 
4437					 
4437 21 bb e2				ld hl, scratch 
443a			 
443a					if DEBUG_FORTH_WORDS 
443a						DMARK "MNx" 
443a f5				push af  
443b 3a 4f 44			ld a, (.dmark)  
443e 32 65 ee			ld (debug_mark),a  
4441 3a 50 44			ld a, (.dmark+1)  
4444 32 66 ee			ld (debug_mark+1),a  
4447 3a 51 44			ld a, (.dmark+2)  
444a 32 67 ee			ld (debug_mark+2),a  
444d 18 03			jr .pastdmark  
444f ..			.dmark: db "MNx"  
4452 f1			.pastdmark: pop af  
4453			endm  
# End of macro DMARK
4453						CALLMONITOR 
4453 cd 6f ee			call debug_vector  
4456				endm  
# End of macro CALLMONITOR
4456					endif 
4456			 
4456			 
4456			 
4456 3e 00				ld a, 0 
4458 cd f9 0b				call menu 
445b			 
445b			 
445b 6f					ld l, a 
445c 26 00				ld h, 0 
445e			 
445e					if DEBUG_FORTH_WORDS 
445e						DMARK "MNr" 
445e f5				push af  
445f 3a 73 44			ld a, (.dmark)  
4462 32 65 ee			ld (debug_mark),a  
4465 3a 74 44			ld a, (.dmark+1)  
4468 32 66 ee			ld (debug_mark+1),a  
446b 3a 75 44			ld a, (.dmark+2)  
446e 32 67 ee			ld (debug_mark+2),a  
4471 18 03			jr .pastdmark  
4473 ..			.dmark: db "MNr"  
4476 f1			.pastdmark: pop af  
4477			endm  
# End of macro DMARK
4477						CALLMONITOR 
4477 cd 6f ee			call debug_vector  
447a				endm  
# End of macro CALLMONITOR
447a					endif 
447a			 
447a cd 90 1b				call forth_push_numhl 
447d			 
447d			 
447d			 
447d			 
447d				       NEXTW 
447d c3 80 1f			jp macro_next 
4480				endm 
# End of macro NEXTW
4480			 
4480			 
4480			.ENDDISPLAY: 
4480			 
4480			; eof 
# End of file forth_words_display.asm
4480			include "forth_words_str.asm" 
4480			 
4480			; | ## String Words 
4480			 
4480			.SPLIT:   
4480			 
4480				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4480 48				db WORD_SYS_CORE+52             
4481 75 45			dw .PTR            
4483 06				db 5 + 1 
4484 .. 00			db "SPLIT",0              
448a				endm 
# End of macro CWHEAD
448a			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
448a					if DEBUG_FORTH_WORDS_KEY 
448a						DMARK "SPT" 
448a f5				push af  
448b 3a 9f 44			ld a, (.dmark)  
448e 32 65 ee			ld (debug_mark),a  
4491 3a a0 44			ld a, (.dmark+1)  
4494 32 66 ee			ld (debug_mark+1),a  
4497 3a a1 44			ld a, (.dmark+2)  
449a 32 67 ee			ld (debug_mark+2),a  
449d 18 03			jr .pastdmark  
449f ..			.dmark: db "SPT"  
44a2 f1			.pastdmark: pop af  
44a3			endm  
# End of macro DMARK
44a3						CALLMONITOR 
44a3 cd 6f ee			call debug_vector  
44a6				endm  
# End of macro CALLMONITOR
44a6					endif 
44a6			 
44a6					; get delim 
44a6					FORTH_DSP_VALUEHL 
44a6 cd 95 1d			call macro_dsp_valuehl 
44a9				endm 
# End of macro FORTH_DSP_VALUEHL
44a9			 
44a9					FORTH_DSP_POP 
44a9 cd 4d 1e			call macro_forth_dsp_pop 
44ac				endm 
# End of macro FORTH_DSP_POP
44ac					 
44ac			 
44ac 45					ld b, l    ; move delim to b 
44ad 0e 01				ld c, 1   ; count of poritions 
44af			 
44af c5					push bc 
44b0			 
44b0					if DEBUG_FORTH_WORDS 
44b0						DMARK "SPa" 
44b0 f5				push af  
44b1 3a c5 44			ld a, (.dmark)  
44b4 32 65 ee			ld (debug_mark),a  
44b7 3a c6 44			ld a, (.dmark+1)  
44ba 32 66 ee			ld (debug_mark+1),a  
44bd 3a c7 44			ld a, (.dmark+2)  
44c0 32 67 ee			ld (debug_mark+2),a  
44c3 18 03			jr .pastdmark  
44c5 ..			.dmark: db "SPa"  
44c8 f1			.pastdmark: pop af  
44c9			endm  
# End of macro DMARK
44c9						CALLMONITOR 
44c9 cd 6f ee			call debug_vector  
44cc				endm  
# End of macro CALLMONITOR
44cc					endif 
44cc					; get pointer to string to chop up 
44cc					FORTH_DSP_VALUEHL 
44cc cd 95 1d			call macro_dsp_valuehl 
44cf				endm 
# End of macro FORTH_DSP_VALUEHL
44cf			 
44cf			;		push hl 
44cf 11 bb e2				ld de, scratch 
44d2			.spllop: 
44d2 c1					pop bc 
44d3 c5					push bc 
44d4			;		pop hl 
44d4					if DEBUG_FORTH_WORDS 
44d4						DMARK "SPl" 
44d4 f5				push af  
44d5 3a e9 44			ld a, (.dmark)  
44d8 32 65 ee			ld (debug_mark),a  
44db 3a ea 44			ld a, (.dmark+1)  
44de 32 66 ee			ld (debug_mark+1),a  
44e1 3a eb 44			ld a, (.dmark+2)  
44e4 32 67 ee			ld (debug_mark+2),a  
44e7 18 03			jr .pastdmark  
44e9 ..			.dmark: db "SPl"  
44ec f1			.pastdmark: pop af  
44ed			endm  
# End of macro DMARK
44ed						CALLMONITOR 
44ed cd 6f ee			call debug_vector  
44f0				endm  
# End of macro CALLMONITOR
44f0					endif 
44f0 7e					ld a, (hl) 
44f1 b8					cp b 
44f2 28 08				jr z, .splnxt 
44f4 fe 00				cp 0 
44f6 28 34				jr z, .splend 
44f8 ed a0				ldi 
44fa 18 d6				jr .spllop 
44fc			 
44fc					; hit dlim 
44fc			 
44fc			.splnxt: 
44fc					if DEBUG_FORTH_WORDS 
44fc						DMARK "SPx" 
44fc f5				push af  
44fd 3a 11 45			ld a, (.dmark)  
4500 32 65 ee			ld (debug_mark),a  
4503 3a 12 45			ld a, (.dmark+1)  
4506 32 66 ee			ld (debug_mark+1),a  
4509 3a 13 45			ld a, (.dmark+2)  
450c 32 67 ee			ld (debug_mark+2),a  
450f 18 03			jr .pastdmark  
4511 ..			.dmark: db "SPx"  
4514 f1			.pastdmark: pop af  
4515			endm  
# End of macro DMARK
4515						CALLMONITOR 
4515 cd 6f ee			call debug_vector  
4518				endm  
# End of macro CALLMONITOR
4518					endif 
4518 3e 00				ld a, 0 
451a 12					ld (de), a 
451b					;ex de, hl 
451b e5					push hl 
451c 21 bb e2				ld hl, scratch 
451f cd fe 1b				call forth_push_str 
4522 e1					pop hl 
4523					;ex de, hl 
4523 23					inc hl 
4524 c1					pop bc 
4525 0c					inc c 
4526 c5					push bc 
4527 11 bb e2				ld de, scratch 
452a 18 a6				jr .spllop 
452c			 
452c			.splend:		 
452c					if DEBUG_FORTH_WORDS 
452c						DMARK "SPe" 
452c f5				push af  
452d 3a 41 45			ld a, (.dmark)  
4530 32 65 ee			ld (debug_mark),a  
4533 3a 42 45			ld a, (.dmark+1)  
4536 32 66 ee			ld (debug_mark+1),a  
4539 3a 43 45			ld a, (.dmark+2)  
453c 32 67 ee			ld (debug_mark+2),a  
453f 18 03			jr .pastdmark  
4541 ..			.dmark: db "SPe"  
4544 f1			.pastdmark: pop af  
4545			endm  
# End of macro DMARK
4545						CALLMONITOR 
4545 cd 6f ee			call debug_vector  
4548				endm  
# End of macro CALLMONITOR
4548					endif 
4548 12					ld (de), a 
4549 eb					ex de, hl 
454a			;		push hl 
454a 21 bb e2				ld hl, scratch 
454d cd fe 1b				call forth_push_str 
4550					 
4550					if DEBUG_FORTH_WORDS 
4550						DMARK "SPc" 
4550 f5				push af  
4551 3a 65 45			ld a, (.dmark)  
4554 32 65 ee			ld (debug_mark),a  
4557 3a 66 45			ld a, (.dmark+1)  
455a 32 66 ee			ld (debug_mark+1),a  
455d 3a 67 45			ld a, (.dmark+2)  
4560 32 67 ee			ld (debug_mark+2),a  
4563 18 03			jr .pastdmark  
4565 ..			.dmark: db "SPc"  
4568 f1			.pastdmark: pop af  
4569			endm  
# End of macro DMARK
4569						CALLMONITOR 
4569 cd 6f ee			call debug_vector  
456c				endm  
# End of macro CALLMONITOR
456c					endif 
456c			 
456c e1					pop hl    ; get counter from bc which has been push 
456d 26 00				ld h, 0 
456f			;		ld l, c 
456f cd 90 1b				call forth_push_numhl 
4572			 
4572			 
4572				NEXTW 
4572 c3 80 1f			jp macro_next 
4575				endm 
# End of macro NEXTW
4575			.PTR:   
4575			 
4575				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4575 48				db WORD_SYS_CORE+52             
4576 a2 45			dw .STYPE            
4578 04				db 3 + 1 
4579 .. 00			db "PTR",0              
457d				endm 
# End of macro CWHEAD
457d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
457d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
457d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
457d			 
457d					if DEBUG_FORTH_WORDS_KEY 
457d						DMARK "PTR" 
457d f5				push af  
457e 3a 92 45			ld a, (.dmark)  
4581 32 65 ee			ld (debug_mark),a  
4584 3a 93 45			ld a, (.dmark+1)  
4587 32 66 ee			ld (debug_mark+1),a  
458a 3a 94 45			ld a, (.dmark+2)  
458d 32 67 ee			ld (debug_mark+2),a  
4590 18 03			jr .pastdmark  
4592 ..			.dmark: db "PTR"  
4595 f1			.pastdmark: pop af  
4596			endm  
# End of macro DMARK
4596						CALLMONITOR 
4596 cd 6f ee			call debug_vector  
4599				endm  
# End of macro CALLMONITOR
4599					endif 
4599					FORTH_DSP_VALUEHL 
4599 cd 95 1d			call macro_dsp_valuehl 
459c				endm 
# End of macro FORTH_DSP_VALUEHL
459c cd 90 1b				call forth_push_numhl 
459f			 
459f			 
459f					NEXTW 
459f c3 80 1f			jp macro_next 
45a2				endm 
# End of macro NEXTW
45a2			.STYPE: 
45a2				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
45a2 48				db WORD_SYS_CORE+52             
45a3 f1 45			dw .UPPER            
45a5 06				db 5 + 1 
45a6 .. 00			db "STYPE",0              
45ac				endm 
# End of macro CWHEAD
45ac			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
45ac			; | | 's' string or 'i' integer 
45ac					if DEBUG_FORTH_WORDS_KEY 
45ac						DMARK "STY" 
45ac f5				push af  
45ad 3a c1 45			ld a, (.dmark)  
45b0 32 65 ee			ld (debug_mark),a  
45b3 3a c2 45			ld a, (.dmark+1)  
45b6 32 66 ee			ld (debug_mark+1),a  
45b9 3a c3 45			ld a, (.dmark+2)  
45bc 32 67 ee			ld (debug_mark+2),a  
45bf 18 03			jr .pastdmark  
45c1 ..			.dmark: db "STY"  
45c4 f1			.pastdmark: pop af  
45c5			endm  
# End of macro DMARK
45c5						CALLMONITOR 
45c5 cd 6f ee			call debug_vector  
45c8				endm  
# End of macro CALLMONITOR
45c8					endif 
45c8					FORTH_DSP 
45c8 cd 5b 1d			call macro_forth_dsp 
45cb				endm 
# End of macro FORTH_DSP
45cb					;v5 FORTH_DSP_VALUE 
45cb			 
45cb 7e					ld a, (hl) 
45cc			 
45cc f5					push af 
45cd			 
45cd			; Dont destroy TOS		FORTH_DSP_POP 
45cd			 
45cd f1					pop af 
45ce			 
45ce fe 01				cp DS_TYPE_STR 
45d0 28 09				jr z, .typestr 
45d2			 
45d2 fe 02				cp DS_TYPE_INUM 
45d4 28 0a				jr z, .typeinum 
45d6			 
45d6 21 ef 45				ld hl, .tna 
45d9 18 0a				jr .tpush 
45db			 
45db 21 eb 45		.typestr:	ld hl, .tstr 
45de 18 05				jr .tpush 
45e0 21 ed 45		.typeinum:	ld hl, .tinum 
45e3 18 00				jr .tpush 
45e5			 
45e5			.tpush: 
45e5			 
45e5 cd fe 1b				call forth_push_str 
45e8			 
45e8					NEXTW 
45e8 c3 80 1f			jp macro_next 
45eb				endm 
# End of macro NEXTW
45eb .. 00		.tstr:	db "s",0 
45ed .. 00		.tinum:  db "i",0 
45ef .. 00		.tna:   db "?", 0 
45f1			 
45f1			 
45f1			.UPPER: 
45f1				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
45f1 48				db WORD_SYS_CORE+52             
45f2 2c 46			dw .LOWER            
45f4 06				db 5 + 1 
45f5 .. 00			db "UPPER",0              
45fb				endm 
# End of macro CWHEAD
45fb			; | UPPER ( s -- s ) Upper case string s  | DONE 
45fb					if DEBUG_FORTH_WORDS_KEY 
45fb						DMARK "UPR" 
45fb f5				push af  
45fc 3a 10 46			ld a, (.dmark)  
45ff 32 65 ee			ld (debug_mark),a  
4602 3a 11 46			ld a, (.dmark+1)  
4605 32 66 ee			ld (debug_mark+1),a  
4608 3a 12 46			ld a, (.dmark+2)  
460b 32 67 ee			ld (debug_mark+2),a  
460e 18 03			jr .pastdmark  
4610 ..			.dmark: db "UPR"  
4613 f1			.pastdmark: pop af  
4614			endm  
# End of macro DMARK
4614						CALLMONITOR 
4614 cd 6f ee			call debug_vector  
4617				endm  
# End of macro CALLMONITOR
4617					endif 
4617			 
4617					FORTH_DSP 
4617 cd 5b 1d			call macro_forth_dsp 
461a				endm 
# End of macro FORTH_DSP
461a					 
461a			; TODO check is string type 
461a			 
461a					FORTH_DSP_VALUEHL 
461a cd 95 1d			call macro_dsp_valuehl 
461d				endm 
# End of macro FORTH_DSP_VALUEHL
461d			; get pointer to string in hl 
461d			 
461d 7e			.toup:		ld a, (hl) 
461e fe 00				cp 0 
4620 28 07				jr z, .toupdone 
4622			 
4622 cd 6a 10				call to_upper 
4625			 
4625 77					ld (hl), a 
4626 23					inc hl 
4627 18 f4				jr .toup 
4629			 
4629					 
4629			 
4629			 
4629			; for each char convert to upper 
4629					 
4629			.toupdone: 
4629			 
4629			 
4629					NEXTW 
4629 c3 80 1f			jp macro_next 
462c				endm 
# End of macro NEXTW
462c			.LOWER: 
462c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
462c 48				db WORD_SYS_CORE+52             
462d 67 46			dw .TCASE            
462f 06				db 5 + 1 
4630 .. 00			db "LOWER",0              
4636				endm 
# End of macro CWHEAD
4636			; | LOWER ( s -- s ) Lower case string s  | DONE 
4636					if DEBUG_FORTH_WORDS_KEY 
4636						DMARK "LWR" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 65 ee			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 66 ee			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 67 ee			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "LWR"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd 6f ee			call debug_vector  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652			 
4652					FORTH_DSP 
4652 cd 5b 1d			call macro_forth_dsp 
4655				endm 
# End of macro FORTH_DSP
4655					 
4655			; TODO check is string type 
4655			 
4655					FORTH_DSP_VALUEHL 
4655 cd 95 1d			call macro_dsp_valuehl 
4658				endm 
# End of macro FORTH_DSP_VALUEHL
4658			; get pointer to string in hl 
4658			 
4658 7e			.tolow:		ld a, (hl) 
4659 fe 00				cp 0 
465b 28 07				jr z, .tolowdone 
465d			 
465d cd 73 10				call to_lower 
4660			 
4660 77					ld (hl), a 
4661 23					inc hl 
4662 18 f4				jr .tolow 
4664			 
4664					 
4664			 
4664			 
4664			; for each char convert to low 
4664					 
4664			.tolowdone: 
4664					NEXTW 
4664 c3 80 1f			jp macro_next 
4667				endm 
# End of macro NEXTW
4667			.TCASE: 
4667				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4667 48				db WORD_SYS_CORE+52             
4668 9d 47			dw .SUBSTR            
466a 06				db 5 + 1 
466b .. 00			db "TCASE",0              
4671				endm 
# End of macro CWHEAD
4671			; | TCASE ( s -- s ) Title case string s  | DONE 
4671					if DEBUG_FORTH_WORDS_KEY 
4671						DMARK "TCS" 
4671 f5				push af  
4672 3a 86 46			ld a, (.dmark)  
4675 32 65 ee			ld (debug_mark),a  
4678 3a 87 46			ld a, (.dmark+1)  
467b 32 66 ee			ld (debug_mark+1),a  
467e 3a 88 46			ld a, (.dmark+2)  
4681 32 67 ee			ld (debug_mark+2),a  
4684 18 03			jr .pastdmark  
4686 ..			.dmark: db "TCS"  
4689 f1			.pastdmark: pop af  
468a			endm  
# End of macro DMARK
468a						CALLMONITOR 
468a cd 6f ee			call debug_vector  
468d				endm  
# End of macro CALLMONITOR
468d					endif 
468d			 
468d					FORTH_DSP 
468d cd 5b 1d			call macro_forth_dsp 
4690				endm 
# End of macro FORTH_DSP
4690					 
4690			; TODO check is string type 
4690			 
4690					FORTH_DSP_VALUEHL 
4690 cd 95 1d			call macro_dsp_valuehl 
4693				endm 
# End of macro FORTH_DSP_VALUEHL
4693			; get pointer to string in hl 
4693			 
4693					if DEBUG_FORTH_WORDS 
4693						DMARK "TC1" 
4693 f5				push af  
4694 3a a8 46			ld a, (.dmark)  
4697 32 65 ee			ld (debug_mark),a  
469a 3a a9 46			ld a, (.dmark+1)  
469d 32 66 ee			ld (debug_mark+1),a  
46a0 3a aa 46			ld a, (.dmark+2)  
46a3 32 67 ee			ld (debug_mark+2),a  
46a6 18 03			jr .pastdmark  
46a8 ..			.dmark: db "TC1"  
46ab f1			.pastdmark: pop af  
46ac			endm  
# End of macro DMARK
46ac						CALLMONITOR 
46ac cd 6f ee			call debug_vector  
46af				endm  
# End of macro CALLMONITOR
46af					endif 
46af			 
46af					; first time in turn to upper case first char 
46af			 
46af 7e					ld a, (hl) 
46b0 c3 3a 47				jp .totsiptou 
46b3			 
46b3			 
46b3 7e			.tot:		ld a, (hl) 
46b4 fe 00				cp 0 
46b6 ca 7e 47				jp z, .totdone 
46b9			 
46b9					if DEBUG_FORTH_WORDS 
46b9						DMARK "TC2" 
46b9 f5				push af  
46ba 3a ce 46			ld a, (.dmark)  
46bd 32 65 ee			ld (debug_mark),a  
46c0 3a cf 46			ld a, (.dmark+1)  
46c3 32 66 ee			ld (debug_mark+1),a  
46c6 3a d0 46			ld a, (.dmark+2)  
46c9 32 67 ee			ld (debug_mark+2),a  
46cc 18 03			jr .pastdmark  
46ce ..			.dmark: db "TC2"  
46d1 f1			.pastdmark: pop af  
46d2			endm  
# End of macro DMARK
46d2						CALLMONITOR 
46d2 cd 6f ee			call debug_vector  
46d5				endm  
# End of macro CALLMONITOR
46d5					endif 
46d5					; check to see if current char is a space 
46d5			 
46d5 fe 20				cp ' ' 
46d7 28 21				jr z, .totsp 
46d9 cd 73 10				call to_lower 
46dc					if DEBUG_FORTH_WORDS 
46dc						DMARK "TC3" 
46dc f5				push af  
46dd 3a f1 46			ld a, (.dmark)  
46e0 32 65 ee			ld (debug_mark),a  
46e3 3a f2 46			ld a, (.dmark+1)  
46e6 32 66 ee			ld (debug_mark+1),a  
46e9 3a f3 46			ld a, (.dmark+2)  
46ec 32 67 ee			ld (debug_mark+2),a  
46ef 18 03			jr .pastdmark  
46f1 ..			.dmark: db "TC3"  
46f4 f1			.pastdmark: pop af  
46f5			endm  
# End of macro DMARK
46f5						CALLMONITOR 
46f5 cd 6f ee			call debug_vector  
46f8				endm  
# End of macro CALLMONITOR
46f8					endif 
46f8 18 63				jr .totnxt 
46fa			 
46fa			.totsp:         ; on a space, find next char which should be upper 
46fa			 
46fa					if DEBUG_FORTH_WORDS 
46fa						DMARK "TC4" 
46fa f5				push af  
46fb 3a 0f 47			ld a, (.dmark)  
46fe 32 65 ee			ld (debug_mark),a  
4701 3a 10 47			ld a, (.dmark+1)  
4704 32 66 ee			ld (debug_mark+1),a  
4707 3a 11 47			ld a, (.dmark+2)  
470a 32 67 ee			ld (debug_mark+2),a  
470d 18 03			jr .pastdmark  
470f ..			.dmark: db "TC4"  
4712 f1			.pastdmark: pop af  
4713			endm  
# End of macro DMARK
4713						CALLMONITOR 
4713 cd 6f ee			call debug_vector  
4716				endm  
# End of macro CALLMONITOR
4716					endif 
4716					;; 
4716			 
4716 fe 20				cp ' ' 
4718 20 20				jr nz, .totsiptou 
471a 23					inc hl 
471b 7e					ld a, (hl) 
471c					if DEBUG_FORTH_WORDS 
471c						DMARK "TC5" 
471c f5				push af  
471d 3a 31 47			ld a, (.dmark)  
4720 32 65 ee			ld (debug_mark),a  
4723 3a 32 47			ld a, (.dmark+1)  
4726 32 66 ee			ld (debug_mark+1),a  
4729 3a 33 47			ld a, (.dmark+2)  
472c 32 67 ee			ld (debug_mark+2),a  
472f 18 03			jr .pastdmark  
4731 ..			.dmark: db "TC5"  
4734 f1			.pastdmark: pop af  
4735			endm  
# End of macro DMARK
4735						CALLMONITOR 
4735 cd 6f ee			call debug_vector  
4738				endm  
# End of macro CALLMONITOR
4738					endif 
4738 18 c0				jr .totsp 
473a fe 00		.totsiptou:    cp 0 
473c 28 40				jr z, .totdone 
473e					; not space and not zero term so upper case it 
473e cd 6a 10				call to_upper 
4741			 
4741					if DEBUG_FORTH_WORDS 
4741						DMARK "TC6" 
4741 f5				push af  
4742 3a 56 47			ld a, (.dmark)  
4745 32 65 ee			ld (debug_mark),a  
4748 3a 57 47			ld a, (.dmark+1)  
474b 32 66 ee			ld (debug_mark+1),a  
474e 3a 58 47			ld a, (.dmark+2)  
4751 32 67 ee			ld (debug_mark+2),a  
4754 18 03			jr .pastdmark  
4756 ..			.dmark: db "TC6"  
4759 f1			.pastdmark: pop af  
475a			endm  
# End of macro DMARK
475a						CALLMONITOR 
475a cd 6f ee			call debug_vector  
475d				endm  
# End of macro CALLMONITOR
475d					endif 
475d			 
475d			 
475d			.totnxt: 
475d			 
475d 77					ld (hl), a 
475e 23					inc hl 
475f					if DEBUG_FORTH_WORDS 
475f						DMARK "TC7" 
475f f5				push af  
4760 3a 74 47			ld a, (.dmark)  
4763 32 65 ee			ld (debug_mark),a  
4766 3a 75 47			ld a, (.dmark+1)  
4769 32 66 ee			ld (debug_mark+1),a  
476c 3a 76 47			ld a, (.dmark+2)  
476f 32 67 ee			ld (debug_mark+2),a  
4772 18 03			jr .pastdmark  
4774 ..			.dmark: db "TC7"  
4777 f1			.pastdmark: pop af  
4778			endm  
# End of macro DMARK
4778						CALLMONITOR 
4778 cd 6f ee			call debug_vector  
477b				endm  
# End of macro CALLMONITOR
477b					endif 
477b c3 b3 46				jp .tot 
477e			 
477e					 
477e			 
477e			 
477e			; for each char convert to low 
477e					 
477e			.totdone: 
477e					if DEBUG_FORTH_WORDS 
477e						DMARK "TCd" 
477e f5				push af  
477f 3a 93 47			ld a, (.dmark)  
4782 32 65 ee			ld (debug_mark),a  
4785 3a 94 47			ld a, (.dmark+1)  
4788 32 66 ee			ld (debug_mark+1),a  
478b 3a 95 47			ld a, (.dmark+2)  
478e 32 67 ee			ld (debug_mark+2),a  
4791 18 03			jr .pastdmark  
4793 ..			.dmark: db "TCd"  
4796 f1			.pastdmark: pop af  
4797			endm  
# End of macro DMARK
4797						CALLMONITOR 
4797 cd 6f ee			call debug_vector  
479a				endm  
# End of macro CALLMONITOR
479a					endif 
479a					NEXTW 
479a c3 80 1f			jp macro_next 
479d				endm 
# End of macro NEXTW
479d			 
479d			.SUBSTR: 
479d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
479d 48				db WORD_SYS_CORE+52             
479e fb 47			dw .LEFT            
47a0 07				db 6 + 1 
47a1 .. 00			db "SUBSTR",0              
47a8				endm 
# End of macro CWHEAD
47a8			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
47a8			 
47a8					if DEBUG_FORTH_WORDS_KEY 
47a8						DMARK "SST" 
47a8 f5				push af  
47a9 3a bd 47			ld a, (.dmark)  
47ac 32 65 ee			ld (debug_mark),a  
47af 3a be 47			ld a, (.dmark+1)  
47b2 32 66 ee			ld (debug_mark+1),a  
47b5 3a bf 47			ld a, (.dmark+2)  
47b8 32 67 ee			ld (debug_mark+2),a  
47bb 18 03			jr .pastdmark  
47bd ..			.dmark: db "SST"  
47c0 f1			.pastdmark: pop af  
47c1			endm  
# End of macro DMARK
47c1						CALLMONITOR 
47c1 cd 6f ee			call debug_vector  
47c4				endm  
# End of macro CALLMONITOR
47c4					endif 
47c4			; TODO check string type 
47c4					FORTH_DSP_VALUEHL 
47c4 cd 95 1d			call macro_dsp_valuehl 
47c7				endm 
# End of macro FORTH_DSP_VALUEHL
47c7			 
47c7 e5					push hl      ; string length 
47c8			 
47c8					FORTH_DSP_POP 
47c8 cd 4d 1e			call macro_forth_dsp_pop 
47cb				endm 
# End of macro FORTH_DSP_POP
47cb			 
47cb					FORTH_DSP_VALUEHL 
47cb cd 95 1d			call macro_dsp_valuehl 
47ce				endm 
# End of macro FORTH_DSP_VALUEHL
47ce			 
47ce e5					push hl     ; start char 
47cf			 
47cf					FORTH_DSP_POP 
47cf cd 4d 1e			call macro_forth_dsp_pop 
47d2				endm 
# End of macro FORTH_DSP_POP
47d2			 
47d2			 
47d2					FORTH_DSP_VALUE 
47d2 cd 7e 1d			call macro_forth_dsp_value 
47d5				endm 
# End of macro FORTH_DSP_VALUE
47d5			 
47d5 d1					pop de    ; get start post offset 
47d6			 
47d6 19					add hl, de    ; starting offset 
47d7			 
47d7 c1					pop bc 
47d8 c5					push bc      ; grab size of string 
47d9			 
47d9 e5					push hl    ; save string start  
47da			 
47da 26 00				ld h, 0 
47dc 69					ld l, c 
47dd 23					inc hl 
47de 23					inc hl 
47df			 
47df cd d0 11				call malloc 
47e2				if DEBUG_FORTH_MALLOC_GUARD 
47e2 cc 78 52				call z,malloc_error 
47e5				endif 
47e5			 
47e5 eb					ex de, hl      ; save malloc area for string copy 
47e6 e1					pop hl    ; get back source 
47e7 c1					pop bc    ; get length of string back 
47e8			 
47e8 d5					push de    ; save malloc area for after we push 
47e9 ed b0				ldir     ; copy substr 
47eb			 
47eb			 
47eb eb					ex de, hl 
47ec 3e 00				ld a, 0 
47ee 77					ld (hl), a   ; term substr 
47ef			 
47ef					 
47ef e1					pop hl    ; get malloc so we can push it 
47f0 e5					push hl   ; save so we can free it afterwards 
47f1			 
47f1 cd fe 1b				call forth_push_str 
47f4			 
47f4 e1					pop hl 
47f5 cd 9a 12				call free 
47f8			 
47f8					 
47f8					 
47f8			 
47f8			 
47f8					NEXTW 
47f8 c3 80 1f			jp macro_next 
47fb				endm 
# End of macro NEXTW
47fb			 
47fb			.LEFT: 
47fb				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
47fb 48				db WORD_SYS_CORE+52             
47fc 3c 48			dw .RIGHT            
47fe 05				db 4 + 1 
47ff .. 00			db "LEFT",0              
4804				endm 
# End of macro CWHEAD
4804			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4804					if DEBUG_FORTH_WORDS_KEY 
4804						DMARK "LEF" 
4804 f5				push af  
4805 3a 19 48			ld a, (.dmark)  
4808 32 65 ee			ld (debug_mark),a  
480b 3a 1a 48			ld a, (.dmark+1)  
480e 32 66 ee			ld (debug_mark+1),a  
4811 3a 1b 48			ld a, (.dmark+2)  
4814 32 67 ee			ld (debug_mark+2),a  
4817 18 03			jr .pastdmark  
4819 ..			.dmark: db "LEF"  
481c f1			.pastdmark: pop af  
481d			endm  
# End of macro DMARK
481d						CALLMONITOR 
481d cd 6f ee			call debug_vector  
4820				endm  
# End of macro CALLMONITOR
4820					endif 
4820			 
4820					 
4820			; TODO check string type 
4820					FORTH_DSP_VALUEHL 
4820 cd 95 1d			call macro_dsp_valuehl 
4823				endm 
# End of macro FORTH_DSP_VALUEHL
4823			 
4823 e5					push hl      ; string length 
4824			 
4824					FORTH_DSP_POP 
4824 cd 4d 1e			call macro_forth_dsp_pop 
4827				endm 
# End of macro FORTH_DSP_POP
4827			 
4827					FORTH_DSP_VALUEHL 
4827 cd 95 1d			call macro_dsp_valuehl 
482a				endm 
# End of macro FORTH_DSP_VALUEHL
482a			 
482a c1					pop bc 
482b			 
482b 11 bb e2				ld de, scratch 
482e ed b0				ldir 
4830 3e 00				ld a, 0 
4832 12					ld (de), a 
4833					 
4833 21 bb e2				ld hl, scratch 
4836 cd fe 1b				call forth_push_str 
4839			 
4839					NEXTW 
4839 c3 80 1f			jp macro_next 
483c				endm 
# End of macro NEXTW
483c			.RIGHT: 
483c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
483c 48				db WORD_SYS_CORE+52             
483d fa 48			dw .STR2NUM            
483f 06				db 5 + 1 
4840 .. 00			db "RIGHT",0              
4846				endm 
# End of macro CWHEAD
4846			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
4846					if DEBUG_FORTH_WORDS_KEY 
4846						DMARK "RIG" 
4846 f5				push af  
4847 3a 5b 48			ld a, (.dmark)  
484a 32 65 ee			ld (debug_mark),a  
484d 3a 5c 48			ld a, (.dmark+1)  
4850 32 66 ee			ld (debug_mark+1),a  
4853 3a 5d 48			ld a, (.dmark+2)  
4856 32 67 ee			ld (debug_mark+2),a  
4859 18 03			jr .pastdmark  
485b ..			.dmark: db "RIG"  
485e f1			.pastdmark: pop af  
485f			endm  
# End of macro DMARK
485f						CALLMONITOR 
485f cd 6f ee			call debug_vector  
4862				endm  
# End of macro CALLMONITOR
4862					endif 
4862			 
4862			; TODO check string type 
4862					FORTH_DSP_VALUEHL 
4862 cd 95 1d			call macro_dsp_valuehl 
4865				endm 
# End of macro FORTH_DSP_VALUEHL
4865			 
4865 e5					push hl      ; string length 
4866			 
4866					FORTH_DSP_POP 
4866 cd 4d 1e			call macro_forth_dsp_pop 
4869				endm 
# End of macro FORTH_DSP_POP
4869			 
4869					FORTH_DSP_VALUEHL 
4869 cd 95 1d			call macro_dsp_valuehl 
486c				endm 
# End of macro FORTH_DSP_VALUEHL
486c			 
486c					if DEBUG_FORTH_WORDS 
486c						DMARK "RI1" 
486c f5				push af  
486d 3a 81 48			ld a, (.dmark)  
4870 32 65 ee			ld (debug_mark),a  
4873 3a 82 48			ld a, (.dmark+1)  
4876 32 66 ee			ld (debug_mark+1),a  
4879 3a 83 48			ld a, (.dmark+2)  
487c 32 67 ee			ld (debug_mark+2),a  
487f 18 03			jr .pastdmark  
4881 ..			.dmark: db "RI1"  
4884 f1			.pastdmark: pop af  
4885			endm  
# End of macro DMARK
4885						CALLMONITOR 
4885 cd 6f ee			call debug_vector  
4888				endm  
# End of macro CALLMONITOR
4888					endif 
4888					; from the pointer to string get to the end of string 
4888			 
4888 01 ff 00				ld bc, 255 
488b 3e 00				ld a, 0 
488d ed b1				cpir 
488f 2b					dec hl 
4890			 
4890					;  
4890			 
4890					if DEBUG_FORTH_WORDS 
4890						DMARK "RI2" 
4890 f5				push af  
4891 3a a5 48			ld a, (.dmark)  
4894 32 65 ee			ld (debug_mark),a  
4897 3a a6 48			ld a, (.dmark+1)  
489a 32 66 ee			ld (debug_mark+1),a  
489d 3a a7 48			ld a, (.dmark+2)  
48a0 32 67 ee			ld (debug_mark+2),a  
48a3 18 03			jr .pastdmark  
48a5 ..			.dmark: db "RI2"  
48a8 f1			.pastdmark: pop af  
48a9			endm  
# End of macro DMARK
48a9						CALLMONITOR 
48a9 cd 6f ee			call debug_vector  
48ac				endm  
# End of macro CALLMONITOR
48ac					endif 
48ac			 
48ac c1					pop bc    ;  length of string to copy 
48ad			 
48ad 79					ld a, c 
48ae eb					ex de, hl 
48af 21 bb e2				ld hl, scratch  
48b2 cd f5 0d				call addatohl 
48b5			 
48b5 eb					ex de, hl 
48b6			 
48b6					if DEBUG_FORTH_WORDS 
48b6						DMARK "RI3" 
48b6 f5				push af  
48b7 3a cb 48			ld a, (.dmark)  
48ba 32 65 ee			ld (debug_mark),a  
48bd 3a cc 48			ld a, (.dmark+1)  
48c0 32 66 ee			ld (debug_mark+1),a  
48c3 3a cd 48			ld a, (.dmark+2)  
48c6 32 67 ee			ld (debug_mark+2),a  
48c9 18 03			jr .pastdmark  
48cb ..			.dmark: db "RI3"  
48ce f1			.pastdmark: pop af  
48cf			endm  
# End of macro DMARK
48cf						CALLMONITOR 
48cf cd 6f ee			call debug_vector  
48d2				endm  
# End of macro CALLMONITOR
48d2					endif 
48d2			 
48d2 03					inc bc 
48d3 ed b8				lddr 
48d5					 
48d5 21 bb e2				ld hl, scratch 
48d8					if DEBUG_FORTH_WORDS 
48d8						DMARK "RI4" 
48d8 f5				push af  
48d9 3a ed 48			ld a, (.dmark)  
48dc 32 65 ee			ld (debug_mark),a  
48df 3a ee 48			ld a, (.dmark+1)  
48e2 32 66 ee			ld (debug_mark+1),a  
48e5 3a ef 48			ld a, (.dmark+2)  
48e8 32 67 ee			ld (debug_mark+2),a  
48eb 18 03			jr .pastdmark  
48ed ..			.dmark: db "RI4"  
48f0 f1			.pastdmark: pop af  
48f1			endm  
# End of macro DMARK
48f1						CALLMONITOR 
48f1 cd 6f ee			call debug_vector  
48f4				endm  
# End of macro CALLMONITOR
48f4					endif 
48f4 cd fe 1b				call forth_push_str 
48f7			 
48f7			 
48f7					NEXTW 
48f7 c3 80 1f			jp macro_next 
48fa				endm 
# End of macro NEXTW
48fa			 
48fa			 
48fa			.STR2NUM: 
48fa				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48fa 48				db WORD_SYS_CORE+52             
48fb 86 49			dw .NUM2STR            
48fd 08				db 7 + 1 
48fe .. 00			db "STR2NUM",0              
4906				endm 
# End of macro CWHEAD
4906			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4906			 
4906			 
4906			; TODO STR type check to do 
4906					if DEBUG_FORTH_WORDS_KEY 
4906						DMARK "S2N" 
4906 f5				push af  
4907 3a 1b 49			ld a, (.dmark)  
490a 32 65 ee			ld (debug_mark),a  
490d 3a 1c 49			ld a, (.dmark+1)  
4910 32 66 ee			ld (debug_mark+1),a  
4913 3a 1d 49			ld a, (.dmark+2)  
4916 32 67 ee			ld (debug_mark+2),a  
4919 18 03			jr .pastdmark  
491b ..			.dmark: db "S2N"  
491e f1			.pastdmark: pop af  
491f			endm  
# End of macro DMARK
491f						CALLMONITOR 
491f cd 6f ee			call debug_vector  
4922				endm  
# End of macro CALLMONITOR
4922					endif 
4922			 
4922					;FORTH_DSP 
4922					FORTH_DSP_VALUE 
4922 cd 7e 1d			call macro_forth_dsp_value 
4925				endm 
# End of macro FORTH_DSP_VALUE
4925					;inc hl 
4925			 
4925 eb					ex de, hl 
4926					if DEBUG_FORTH_WORDS 
4926						DMARK "S2a" 
4926 f5				push af  
4927 3a 3b 49			ld a, (.dmark)  
492a 32 65 ee			ld (debug_mark),a  
492d 3a 3c 49			ld a, (.dmark+1)  
4930 32 66 ee			ld (debug_mark+1),a  
4933 3a 3d 49			ld a, (.dmark+2)  
4936 32 67 ee			ld (debug_mark+2),a  
4939 18 03			jr .pastdmark  
493b ..			.dmark: db "S2a"  
493e f1			.pastdmark: pop af  
493f			endm  
# End of macro DMARK
493f						CALLMONITOR 
493f cd 6f ee			call debug_vector  
4942				endm  
# End of macro CALLMONITOR
4942					endif 
4942 cd f2 10				call string_to_uint16 
4945			 
4945					if DEBUG_FORTH_WORDS 
4945						DMARK "S2b" 
4945 f5				push af  
4946 3a 5a 49			ld a, (.dmark)  
4949 32 65 ee			ld (debug_mark),a  
494c 3a 5b 49			ld a, (.dmark+1)  
494f 32 66 ee			ld (debug_mark+1),a  
4952 3a 5c 49			ld a, (.dmark+2)  
4955 32 67 ee			ld (debug_mark+2),a  
4958 18 03			jr .pastdmark  
495a ..			.dmark: db "S2b"  
495d f1			.pastdmark: pop af  
495e			endm  
# End of macro DMARK
495e						CALLMONITOR 
495e cd 6f ee			call debug_vector  
4961				endm  
# End of macro CALLMONITOR
4961					endif 
4961			;		push hl 
4961					FORTH_DSP_POP 
4961 cd 4d 1e			call macro_forth_dsp_pop 
4964				endm 
# End of macro FORTH_DSP_POP
4964			;		pop hl 
4964					 
4964					if DEBUG_FORTH_WORDS 
4964						DMARK "S2b" 
4964 f5				push af  
4965 3a 79 49			ld a, (.dmark)  
4968 32 65 ee			ld (debug_mark),a  
496b 3a 7a 49			ld a, (.dmark+1)  
496e 32 66 ee			ld (debug_mark+1),a  
4971 3a 7b 49			ld a, (.dmark+2)  
4974 32 67 ee			ld (debug_mark+2),a  
4977 18 03			jr .pastdmark  
4979 ..			.dmark: db "S2b"  
497c f1			.pastdmark: pop af  
497d			endm  
# End of macro DMARK
497d						CALLMONITOR 
497d cd 6f ee			call debug_vector  
4980				endm  
# End of macro CALLMONITOR
4980					endif 
4980 cd 90 1b				call forth_push_numhl	 
4983			 
4983				 
4983				       NEXTW 
4983 c3 80 1f			jp macro_next 
4986				endm 
# End of macro NEXTW
4986			.NUM2STR: 
4986				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4986 48				db WORD_SYS_CORE+52             
4987 18 4a			dw .CONCAT            
4989 08				db 7 + 1 
498a .. 00			db "NUM2STR",0              
4992				endm 
# End of macro CWHEAD
4992			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4992			 
4992			;		; malloc a string to target 
4992			;		ld hl, 10     ; TODO max string size should be fine 
4992			;		call malloc 
4992			;		push hl    ; save malloc location 
4992			; 
4992			; 
4992			;; TODO check int type 
4992					if DEBUG_FORTH_WORDS_KEY 
4992						DMARK "N2S" 
4992 f5				push af  
4993 3a a7 49			ld a, (.dmark)  
4996 32 65 ee			ld (debug_mark),a  
4999 3a a8 49			ld a, (.dmark+1)  
499c 32 66 ee			ld (debug_mark+1),a  
499f 3a a9 49			ld a, (.dmark+2)  
49a2 32 67 ee			ld (debug_mark+2),a  
49a5 18 03			jr .pastdmark  
49a7 ..			.dmark: db "N2S"  
49aa f1			.pastdmark: pop af  
49ab			endm  
# End of macro DMARK
49ab						CALLMONITOR 
49ab cd 6f ee			call debug_vector  
49ae				endm  
# End of macro CALLMONITOR
49ae					endif 
49ae			 
49ae					FORTH_DSP_VALUEHL 
49ae cd 95 1d			call macro_dsp_valuehl 
49b1				endm 
# End of macro FORTH_DSP_VALUEHL
49b1			 
49b1					if DEBUG_FORTH_WORDS 
49b1						DMARK "NS1" 
49b1 f5				push af  
49b2 3a c6 49			ld a, (.dmark)  
49b5 32 65 ee			ld (debug_mark),a  
49b8 3a c7 49			ld a, (.dmark+1)  
49bb 32 66 ee			ld (debug_mark+1),a  
49be 3a c8 49			ld a, (.dmark+2)  
49c1 32 67 ee			ld (debug_mark+2),a  
49c4 18 03			jr .pastdmark  
49c6 ..			.dmark: db "NS1"  
49c9 f1			.pastdmark: pop af  
49ca			endm  
# End of macro DMARK
49ca						CALLMONITOR 
49ca cd 6f ee			call debug_vector  
49cd				endm  
# End of macro CALLMONITOR
49cd					endif 
49cd					FORTH_DSP_POP 
49cd cd 4d 1e			call macro_forth_dsp_pop 
49d0				endm 
# End of macro FORTH_DSP_POP
49d0			 
49d0 eb					ex de, hl 
49d1 21 bb e2				ld hl, scratch 
49d4					if DEBUG_FORTH_WORDS 
49d4						DMARK "NS2" 
49d4 f5				push af  
49d5 3a e9 49			ld a, (.dmark)  
49d8 32 65 ee			ld (debug_mark),a  
49db 3a ea 49			ld a, (.dmark+1)  
49de 32 66 ee			ld (debug_mark+1),a  
49e1 3a eb 49			ld a, (.dmark+2)  
49e4 32 67 ee			ld (debug_mark+2),a  
49e7 18 03			jr .pastdmark  
49e9 ..			.dmark: db "NS2"  
49ec f1			.pastdmark: pop af  
49ed			endm  
# End of macro DMARK
49ed						CALLMONITOR 
49ed cd 6f ee			call debug_vector  
49f0				endm  
# End of macro CALLMONITOR
49f0					endif 
49f0 cd 0a 11				call uitoa_16 
49f3 21 bb e2				ld hl, scratch 
49f6					if DEBUG_FORTH_WORDS 
49f6						DMARK "NS3" 
49f6 f5				push af  
49f7 3a 0b 4a			ld a, (.dmark)  
49fa 32 65 ee			ld (debug_mark),a  
49fd 3a 0c 4a			ld a, (.dmark+1)  
4a00 32 66 ee			ld (debug_mark+1),a  
4a03 3a 0d 4a			ld a, (.dmark+2)  
4a06 32 67 ee			ld (debug_mark+2),a  
4a09 18 03			jr .pastdmark  
4a0b ..			.dmark: db "NS3"  
4a0e f1			.pastdmark: pop af  
4a0f			endm  
# End of macro DMARK
4a0f						CALLMONITOR 
4a0f cd 6f ee			call debug_vector  
4a12				endm  
# End of macro CALLMONITOR
4a12					endif 
4a12 cd fe 1b				call forth_push_str 
4a15			;		ld a, l 
4a15			;		call DispAToASCII   
4a15			;;TODO need to chage above call to dump into string 
4a15			; 
4a15			; 
4a15			 
4a15				       NEXTW 
4a15 c3 80 1f			jp macro_next 
4a18				endm 
# End of macro NEXTW
4a18			 
4a18			.CONCAT: 
4a18				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4a18 48				db WORD_SYS_CORE+52             
4a19 cb 4a			dw .FIND            
4a1b 07				db 6 + 1 
4a1c .. 00			db "CONCAT",0              
4a23				endm 
# End of macro CWHEAD
4a23			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4a23			 
4a23			; TODO check string type 
4a23			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4a23			 
4a23					if DEBUG_FORTH_WORDS_KEY 
4a23						DMARK "CON" 
4a23 f5				push af  
4a24 3a 38 4a			ld a, (.dmark)  
4a27 32 65 ee			ld (debug_mark),a  
4a2a 3a 39 4a			ld a, (.dmark+1)  
4a2d 32 66 ee			ld (debug_mark+1),a  
4a30 3a 3a 4a			ld a, (.dmark+2)  
4a33 32 67 ee			ld (debug_mark+2),a  
4a36 18 03			jr .pastdmark  
4a38 ..			.dmark: db "CON"  
4a3b f1			.pastdmark: pop af  
4a3c			endm  
# End of macro DMARK
4a3c						CALLMONITOR 
4a3c cd 6f ee			call debug_vector  
4a3f				endm  
# End of macro CALLMONITOR
4a3f					endif 
4a3f			 
4a3f			 
4a3f					FORTH_DSP_VALUE 
4a3f cd 7e 1d			call macro_forth_dsp_value 
4a42				endm 
# End of macro FORTH_DSP_VALUE
4a42 e5					push hl   ; s2 
4a43			 
4a43					FORTH_DSP_POP 
4a43 cd 4d 1e			call macro_forth_dsp_pop 
4a46				endm 
# End of macro FORTH_DSP_POP
4a46			 
4a46					FORTH_DSP_VALUE 
4a46 cd 7e 1d			call macro_forth_dsp_value 
4a49				endm 
# End of macro FORTH_DSP_VALUE
4a49			 
4a49 e5					push hl   ; s1 
4a4a			 
4a4a					FORTH_DSP_POP 
4a4a cd 4d 1e			call macro_forth_dsp_pop 
4a4d				endm 
# End of macro FORTH_DSP_POP
4a4d					 
4a4d			 
4a4d					; copy s1 
4a4d			 
4a4d				 
4a4d					; save ptr 
4a4d e1					pop hl  
4a4e e5					push hl 
4a4f 3e 00				ld a, 0 
4a51 cd 66 11				call strlent 
4a54					;inc hl    ; zer0 
4a54 06 00				ld b, 0 
4a56 4d					ld c, l 
4a57 e1					pop hl		 
4a58 11 bb e2				ld de, scratch	 
4a5b					if DEBUG_FORTH_WORDS 
4a5b						DMARK "CO1" 
4a5b f5				push af  
4a5c 3a 70 4a			ld a, (.dmark)  
4a5f 32 65 ee			ld (debug_mark),a  
4a62 3a 71 4a			ld a, (.dmark+1)  
4a65 32 66 ee			ld (debug_mark+1),a  
4a68 3a 72 4a			ld a, (.dmark+2)  
4a6b 32 67 ee			ld (debug_mark+2),a  
4a6e 18 03			jr .pastdmark  
4a70 ..			.dmark: db "CO1"  
4a73 f1			.pastdmark: pop af  
4a74			endm  
# End of macro DMARK
4a74						CALLMONITOR 
4a74 cd 6f ee			call debug_vector  
4a77				endm  
# End of macro CALLMONITOR
4a77					endif 
4a77 ed b0				ldir 
4a79			 
4a79 e1					pop hl 
4a7a e5					push hl 
4a7b d5					push de 
4a7c			 
4a7c			 
4a7c 3e 00				ld a, 0 
4a7e cd 66 11				call strlent 
4a81 23					inc hl    ; zer0 
4a82 23					inc hl 
4a83 06 00				ld b, 0 
4a85 4d					ld c, l 
4a86 d1					pop de 
4a87 e1					pop hl		 
4a88					if DEBUG_FORTH_WORDS 
4a88						DMARK "CO2" 
4a88 f5				push af  
4a89 3a 9d 4a			ld a, (.dmark)  
4a8c 32 65 ee			ld (debug_mark),a  
4a8f 3a 9e 4a			ld a, (.dmark+1)  
4a92 32 66 ee			ld (debug_mark+1),a  
4a95 3a 9f 4a			ld a, (.dmark+2)  
4a98 32 67 ee			ld (debug_mark+2),a  
4a9b 18 03			jr .pastdmark  
4a9d ..			.dmark: db "CO2"  
4aa0 f1			.pastdmark: pop af  
4aa1			endm  
# End of macro DMARK
4aa1						CALLMONITOR 
4aa1 cd 6f ee			call debug_vector  
4aa4				endm  
# End of macro CALLMONITOR
4aa4					endif 
4aa4 ed b0				ldir 
4aa6			 
4aa6			 
4aa6			 
4aa6 21 bb e2				ld hl, scratch 
4aa9					if DEBUG_FORTH_WORDS 
4aa9						DMARK "CO5" 
4aa9 f5				push af  
4aaa 3a be 4a			ld a, (.dmark)  
4aad 32 65 ee			ld (debug_mark),a  
4ab0 3a bf 4a			ld a, (.dmark+1)  
4ab3 32 66 ee			ld (debug_mark+1),a  
4ab6 3a c0 4a			ld a, (.dmark+2)  
4ab9 32 67 ee			ld (debug_mark+2),a  
4abc 18 03			jr .pastdmark  
4abe ..			.dmark: db "CO5"  
4ac1 f1			.pastdmark: pop af  
4ac2			endm  
# End of macro DMARK
4ac2						CALLMONITOR 
4ac2 cd 6f ee			call debug_vector  
4ac5				endm  
# End of macro CALLMONITOR
4ac5					endif 
4ac5			 
4ac5 cd fe 1b				call forth_push_str 
4ac8			 
4ac8			 
4ac8			 
4ac8			 
4ac8				       NEXTW 
4ac8 c3 80 1f			jp macro_next 
4acb				endm 
# End of macro NEXTW
4acb			 
4acb			 
4acb			.FIND: 
4acb				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4acb 4b				db WORD_SYS_CORE+55             
4acc 89 4b			dw .LEN            
4ace 05				db 4 + 1 
4acf .. 00			db "FIND",0              
4ad4				endm 
# End of macro CWHEAD
4ad4			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4ad4			 
4ad4					if DEBUG_FORTH_WORDS_KEY 
4ad4						DMARK "FND" 
4ad4 f5				push af  
4ad5 3a e9 4a			ld a, (.dmark)  
4ad8 32 65 ee			ld (debug_mark),a  
4adb 3a ea 4a			ld a, (.dmark+1)  
4ade 32 66 ee			ld (debug_mark+1),a  
4ae1 3a eb 4a			ld a, (.dmark+2)  
4ae4 32 67 ee			ld (debug_mark+2),a  
4ae7 18 03			jr .pastdmark  
4ae9 ..			.dmark: db "FND"  
4aec f1			.pastdmark: pop af  
4aed			endm  
# End of macro DMARK
4aed						CALLMONITOR 
4aed cd 6f ee			call debug_vector  
4af0				endm  
# End of macro CALLMONITOR
4af0					endif 
4af0			 
4af0			; TODO check string type 
4af0					FORTH_DSP_VALUE 
4af0 cd 7e 1d			call macro_forth_dsp_value 
4af3				endm 
# End of macro FORTH_DSP_VALUE
4af3			 
4af3 e5					push hl    
4af4 7e					ld a,(hl)    ; char to find   
4af5			; TODO change char to substr 
4af5			 
4af5 f5					push af 
4af6					 
4af6			 
4af6			 
4af6					if DEBUG_FORTH_WORDS 
4af6						DMARK "FN1" 
4af6 f5				push af  
4af7 3a 0b 4b			ld a, (.dmark)  
4afa 32 65 ee			ld (debug_mark),a  
4afd 3a 0c 4b			ld a, (.dmark+1)  
4b00 32 66 ee			ld (debug_mark+1),a  
4b03 3a 0d 4b			ld a, (.dmark+2)  
4b06 32 67 ee			ld (debug_mark+2),a  
4b09 18 03			jr .pastdmark  
4b0b ..			.dmark: db "FN1"  
4b0e f1			.pastdmark: pop af  
4b0f			endm  
# End of macro DMARK
4b0f						CALLMONITOR 
4b0f cd 6f ee			call debug_vector  
4b12				endm  
# End of macro CALLMONITOR
4b12					endif 
4b12			 
4b12					FORTH_DSP_POP 
4b12 cd 4d 1e			call macro_forth_dsp_pop 
4b15				endm 
# End of macro FORTH_DSP_POP
4b15			 
4b15					; string to search 
4b15			 
4b15					FORTH_DSP_VALUE 
4b15 cd 7e 1d			call macro_forth_dsp_value 
4b18				endm 
# End of macro FORTH_DSP_VALUE
4b18			 
4b18 d1					pop de  ; d is char to find  
4b19			 
4b19					if DEBUG_FORTH_WORDS 
4b19						DMARK "FN2" 
4b19 f5				push af  
4b1a 3a 2e 4b			ld a, (.dmark)  
4b1d 32 65 ee			ld (debug_mark),a  
4b20 3a 2f 4b			ld a, (.dmark+1)  
4b23 32 66 ee			ld (debug_mark+1),a  
4b26 3a 30 4b			ld a, (.dmark+2)  
4b29 32 67 ee			ld (debug_mark+2),a  
4b2c 18 03			jr .pastdmark  
4b2e ..			.dmark: db "FN2"  
4b31 f1			.pastdmark: pop af  
4b32			endm  
# End of macro DMARK
4b32						CALLMONITOR 
4b32 cd 6f ee			call debug_vector  
4b35				endm  
# End of macro CALLMONITOR
4b35					endif 
4b35					 
4b35 01 00 00				ld bc, 0 
4b38 7e			.findchar:      ld a,(hl) 
4b39 fe 00				cp 0   		 
4b3b 28 27				jr z, .finddone     
4b3d ba					cp d 
4b3e 28 20				jr z, .foundchar 
4b40 03					inc bc 
4b41 23					inc hl 
4b42					if DEBUG_FORTH_WORDS 
4b42						DMARK "FN3" 
4b42 f5				push af  
4b43 3a 57 4b			ld a, (.dmark)  
4b46 32 65 ee			ld (debug_mark),a  
4b49 3a 58 4b			ld a, (.dmark+1)  
4b4c 32 66 ee			ld (debug_mark+1),a  
4b4f 3a 59 4b			ld a, (.dmark+2)  
4b52 32 67 ee			ld (debug_mark+2),a  
4b55 18 03			jr .pastdmark  
4b57 ..			.dmark: db "FN3"  
4b5a f1			.pastdmark: pop af  
4b5b			endm  
# End of macro DMARK
4b5b						CALLMONITOR 
4b5b cd 6f ee			call debug_vector  
4b5e				endm  
# End of macro CALLMONITOR
4b5e					endif 
4b5e 18 d8				jr .findchar 
4b60			 
4b60			 
4b60 c5			.foundchar:	push bc 
4b61 e1					pop hl 
4b62 18 03				jr .findexit 
4b64			 
4b64			 
4b64							 
4b64			 
4b64			.finddone:     ; got to end of string with no find 
4b64 21 00 00				ld hl, 0 
4b67			.findexit: 
4b67			 
4b67					if DEBUG_FORTH_WORDS 
4b67						DMARK "FNd" 
4b67 f5				push af  
4b68 3a 7c 4b			ld a, (.dmark)  
4b6b 32 65 ee			ld (debug_mark),a  
4b6e 3a 7d 4b			ld a, (.dmark+1)  
4b71 32 66 ee			ld (debug_mark+1),a  
4b74 3a 7e 4b			ld a, (.dmark+2)  
4b77 32 67 ee			ld (debug_mark+2),a  
4b7a 18 03			jr .pastdmark  
4b7c ..			.dmark: db "FNd"  
4b7f f1			.pastdmark: pop af  
4b80			endm  
# End of macro DMARK
4b80						CALLMONITOR 
4b80 cd 6f ee			call debug_vector  
4b83				endm  
# End of macro CALLMONITOR
4b83					endif 
4b83 cd 90 1b			call forth_push_numhl 
4b86			 
4b86				       NEXTW 
4b86 c3 80 1f			jp macro_next 
4b89				endm 
# End of macro NEXTW
4b89			 
4b89			.LEN: 
4b89				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b89 4c				db WORD_SYS_CORE+56             
4b8a f3 4b			dw .ASC            
4b8c 06				db 5 + 1 
4b8d .. 00			db "COUNT",0              
4b93				endm 
# End of macro CWHEAD
4b93			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b93			 
4b93					if DEBUG_FORTH_WORDS_KEY 
4b93						DMARK "CNT" 
4b93 f5				push af  
4b94 3a a8 4b			ld a, (.dmark)  
4b97 32 65 ee			ld (debug_mark),a  
4b9a 3a a9 4b			ld a, (.dmark+1)  
4b9d 32 66 ee			ld (debug_mark+1),a  
4ba0 3a aa 4b			ld a, (.dmark+2)  
4ba3 32 67 ee			ld (debug_mark+2),a  
4ba6 18 03			jr .pastdmark  
4ba8 ..			.dmark: db "CNT"  
4bab f1			.pastdmark: pop af  
4bac			endm  
# End of macro DMARK
4bac						CALLMONITOR 
4bac cd 6f ee			call debug_vector  
4baf				endm  
# End of macro CALLMONITOR
4baf					endif 
4baf			; TODO check string type 
4baf					FORTH_DSP_VALUE 
4baf cd 7e 1d			call macro_forth_dsp_value 
4bb2				endm 
# End of macro FORTH_DSP_VALUE
4bb2			 
4bb2			 
4bb2					if DEBUG_FORTH_WORDS 
4bb2						DMARK "CN?" 
4bb2 f5				push af  
4bb3 3a c7 4b			ld a, (.dmark)  
4bb6 32 65 ee			ld (debug_mark),a  
4bb9 3a c8 4b			ld a, (.dmark+1)  
4bbc 32 66 ee			ld (debug_mark+1),a  
4bbf 3a c9 4b			ld a, (.dmark+2)  
4bc2 32 67 ee			ld (debug_mark+2),a  
4bc5 18 03			jr .pastdmark  
4bc7 ..			.dmark: db "CN?"  
4bca f1			.pastdmark: pop af  
4bcb			endm  
# End of macro DMARK
4bcb						CALLMONITOR 
4bcb cd 6f ee			call debug_vector  
4bce				endm  
# End of macro CALLMONITOR
4bce					endif 
4bce cd 5b 11				call strlenz 
4bd1					if DEBUG_FORTH_WORDS 
4bd1						DMARK "CNl" 
4bd1 f5				push af  
4bd2 3a e6 4b			ld a, (.dmark)  
4bd5 32 65 ee			ld (debug_mark),a  
4bd8 3a e7 4b			ld a, (.dmark+1)  
4bdb 32 66 ee			ld (debug_mark+1),a  
4bde 3a e8 4b			ld a, (.dmark+2)  
4be1 32 67 ee			ld (debug_mark+2),a  
4be4 18 03			jr .pastdmark  
4be6 ..			.dmark: db "CNl"  
4be9 f1			.pastdmark: pop af  
4bea			endm  
# End of macro DMARK
4bea						CALLMONITOR 
4bea cd 6f ee			call debug_vector  
4bed				endm  
# End of macro CALLMONITOR
4bed					endif 
4bed			 
4bed cd 90 1b				call forth_push_numhl 
4bf0			 
4bf0			 
4bf0			 
4bf0				       NEXTW 
4bf0 c3 80 1f			jp macro_next 
4bf3				endm 
# End of macro NEXTW
4bf3			.ASC: 
4bf3				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4bf3 4d				db WORD_SYS_CORE+57             
4bf4 61 4c			dw .CHR            
4bf6 04				db 3 + 1 
4bf7 .. 00			db "ASC",0              
4bfb				endm 
# End of macro CWHEAD
4bfb			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4bfb					if DEBUG_FORTH_WORDS_KEY 
4bfb						DMARK "ASC" 
4bfb f5				push af  
4bfc 3a 10 4c			ld a, (.dmark)  
4bff 32 65 ee			ld (debug_mark),a  
4c02 3a 11 4c			ld a, (.dmark+1)  
4c05 32 66 ee			ld (debug_mark+1),a  
4c08 3a 12 4c			ld a, (.dmark+2)  
4c0b 32 67 ee			ld (debug_mark+2),a  
4c0e 18 03			jr .pastdmark  
4c10 ..			.dmark: db "ASC"  
4c13 f1			.pastdmark: pop af  
4c14			endm  
# End of macro DMARK
4c14						CALLMONITOR 
4c14 cd 6f ee			call debug_vector  
4c17				endm  
# End of macro CALLMONITOR
4c17					endif 
4c17					FORTH_DSP_VALUE 
4c17 cd 7e 1d			call macro_forth_dsp_value 
4c1a				endm 
# End of macro FORTH_DSP_VALUE
4c1a					;v5 FORTH_DSP_VALUE 
4c1a			;		inc hl      ; now at start of numeric as string 
4c1a			 
4c1a e5					push hl 
4c1b			 
4c1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c1b cd 4d 1e			call macro_forth_dsp_pop 
4c1e				endm 
# End of macro FORTH_DSP_POP
4c1e			 
4c1e e1					pop hl 
4c1f			 
4c1f					if DEBUG_FORTH_WORDS 
4c1f						DMARK "AS1" 
4c1f f5				push af  
4c20 3a 34 4c			ld a, (.dmark)  
4c23 32 65 ee			ld (debug_mark),a  
4c26 3a 35 4c			ld a, (.dmark+1)  
4c29 32 66 ee			ld (debug_mark+1),a  
4c2c 3a 36 4c			ld a, (.dmark+2)  
4c2f 32 67 ee			ld (debug_mark+2),a  
4c32 18 03			jr .pastdmark  
4c34 ..			.dmark: db "AS1"  
4c37 f1			.pastdmark: pop af  
4c38			endm  
# End of macro DMARK
4c38						CALLMONITOR 
4c38 cd 6f ee			call debug_vector  
4c3b				endm  
# End of macro CALLMONITOR
4c3b					endif 
4c3b					; push the content of a onto the stack as a value 
4c3b			 
4c3b 7e					ld a,(hl)   ; get char 
4c3c 26 00				ld h,0 
4c3e 6f					ld l,a 
4c3f					if DEBUG_FORTH_WORDS 
4c3f						DMARK "AS2" 
4c3f f5				push af  
4c40 3a 54 4c			ld a, (.dmark)  
4c43 32 65 ee			ld (debug_mark),a  
4c46 3a 55 4c			ld a, (.dmark+1)  
4c49 32 66 ee			ld (debug_mark+1),a  
4c4c 3a 56 4c			ld a, (.dmark+2)  
4c4f 32 67 ee			ld (debug_mark+2),a  
4c52 18 03			jr .pastdmark  
4c54 ..			.dmark: db "AS2"  
4c57 f1			.pastdmark: pop af  
4c58			endm  
# End of macro DMARK
4c58						CALLMONITOR 
4c58 cd 6f ee			call debug_vector  
4c5b				endm  
# End of macro CALLMONITOR
4c5b					endif 
4c5b cd 90 1b				call forth_push_numhl 
4c5e			 
4c5e				       NEXTW 
4c5e c3 80 1f			jp macro_next 
4c61				endm 
# End of macro NEXTW
4c61			 
4c61			.CHR: 
4c61				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c61 4d				db WORD_SYS_CORE+57             
4c62 9d 4c			dw .ENDSTR            
4c64 04				db 3 + 1 
4c65 .. 00			db "CHR",0              
4c69				endm 
# End of macro CWHEAD
4c69			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c69					if DEBUG_FORTH_WORDS_KEY 
4c69						DMARK "CHR" 
4c69 f5				push af  
4c6a 3a 7e 4c			ld a, (.dmark)  
4c6d 32 65 ee			ld (debug_mark),a  
4c70 3a 7f 4c			ld a, (.dmark+1)  
4c73 32 66 ee			ld (debug_mark+1),a  
4c76 3a 80 4c			ld a, (.dmark+2)  
4c79 32 67 ee			ld (debug_mark+2),a  
4c7c 18 03			jr .pastdmark  
4c7e ..			.dmark: db "CHR"  
4c81 f1			.pastdmark: pop af  
4c82			endm  
# End of macro DMARK
4c82						CALLMONITOR 
4c82 cd 6f ee			call debug_vector  
4c85				endm  
# End of macro CALLMONITOR
4c85					endif 
4c85					FORTH_DSP_VALUEHL 
4c85 cd 95 1d			call macro_dsp_valuehl 
4c88				endm 
# End of macro FORTH_DSP_VALUEHL
4c88			 
4c88					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c88 cd 4d 1e			call macro_forth_dsp_pop 
4c8b				endm 
# End of macro FORTH_DSP_POP
4c8b			 
4c8b					; save asci byte as a zero term string and push string 
4c8b			 
4c8b 7d					ld a,l 
4c8c 32 bb e2				ld (scratch), a 
4c8f			 
4c8f 3e 00				ld a, 0 
4c91 32 bc e2				ld (scratch+1), a 
4c94			 
4c94 21 bb e2				ld hl, scratch 
4c97 cd fe 1b				call forth_push_str 
4c9a			 
4c9a			 
4c9a				       NEXTW 
4c9a c3 80 1f			jp macro_next 
4c9d				endm 
# End of macro NEXTW
4c9d			 
4c9d			 
4c9d			 
4c9d			 
4c9d			.ENDSTR: 
4c9d			; eof 
4c9d			 
# End of file forth_words_str.asm
4c9d			include "forth_words_key.asm" 
4c9d			 
4c9d			; | ## Keyboard Words 
4c9d			 
4c9d			.KEY: 
4c9d				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4c9d 3e				db WORD_SYS_CORE+42             
4c9e cd 4c			dw .KEYDB            
4ca0 04				db 3 + 1 
4ca1 .. 00			db "KEY",0              
4ca5				endm 
# End of macro CWHEAD
4ca5			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4ca5			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4ca5			; | | Can use something like this to process: 
4ca5			; | | > repeat active . key ?dup if emit then #1 until  
4ca5			 
4ca5					if DEBUG_FORTH_WORDS_KEY 
4ca5						DMARK "KEY" 
4ca5 f5				push af  
4ca6 3a ba 4c			ld a, (.dmark)  
4ca9 32 65 ee			ld (debug_mark),a  
4cac 3a bb 4c			ld a, (.dmark+1)  
4caf 32 66 ee			ld (debug_mark+1),a  
4cb2 3a bc 4c			ld a, (.dmark+2)  
4cb5 32 67 ee			ld (debug_mark+2),a  
4cb8 18 03			jr .pastdmark  
4cba ..			.dmark: db "KEY"  
4cbd f1			.pastdmark: pop af  
4cbe			endm  
# End of macro DMARK
4cbe						CALLMONITOR 
4cbe cd 6f ee			call debug_vector  
4cc1				endm  
# End of macro CALLMONITOR
4cc1					endif 
4cc1			; TODO currently waits 
4cc1 cd 09 64				call cinndb 
4cc4					;call cin_wait 
4cc4 6f					ld l, a 
4cc5 26 00				ld h, 0 
4cc7 cd 90 1b				call forth_push_numhl 
4cca					NEXTW 
4cca c3 80 1f			jp macro_next 
4ccd				endm 
# End of macro NEXTW
4ccd			.KEYDB: 
4ccd				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4ccd 3e				db WORD_SYS_CORE+42             
4cce ff 4c			dw .WAITK            
4cd0 06				db 5 + 1 
4cd1 .. 00			db "KEYDB",0              
4cd7				endm 
# End of macro CWHEAD
4cd7			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4cd7			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4cd7			; | | Can use something like this to process: 
4cd7			; | | > repeat active . key ?dup if emit then #1 until  
4cd7			 
4cd7					if DEBUG_FORTH_WORDS_KEY 
4cd7						DMARK "KEB" 
4cd7 f5				push af  
4cd8 3a ec 4c			ld a, (.dmark)  
4cdb 32 65 ee			ld (debug_mark),a  
4cde 3a ed 4c			ld a, (.dmark+1)  
4ce1 32 66 ee			ld (debug_mark+1),a  
4ce4 3a ee 4c			ld a, (.dmark+2)  
4ce7 32 67 ee			ld (debug_mark+2),a  
4cea 18 03			jr .pastdmark  
4cec ..			.dmark: db "KEB"  
4cef f1			.pastdmark: pop af  
4cf0			endm  
# End of macro DMARK
4cf0						CALLMONITOR 
4cf0 cd 6f ee			call debug_vector  
4cf3				endm  
# End of macro CALLMONITOR
4cf3					endif 
4cf3			; TODO currently waits 
4cf3 cd 09 64				call cin 
4cf6					;call cin_wait 
4cf6 6f					ld l, a 
4cf7 26 00				ld h, 0 
4cf9 cd 90 1b				call forth_push_numhl 
4cfc					NEXTW 
4cfc c3 80 1f			jp macro_next 
4cff				endm 
# End of macro NEXTW
4cff			.WAITK: 
4cff				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4cff 3f				db WORD_SYS_CORE+43             
4d00 31 4d			dw .ACCEPT            
4d02 06				db 5 + 1 
4d03 .. 00			db "WAITK",0              
4d09				endm 
# End of macro CWHEAD
4d09			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4d09					if DEBUG_FORTH_WORDS_KEY 
4d09						DMARK "WAI" 
4d09 f5				push af  
4d0a 3a 1e 4d			ld a, (.dmark)  
4d0d 32 65 ee			ld (debug_mark),a  
4d10 3a 1f 4d			ld a, (.dmark+1)  
4d13 32 66 ee			ld (debug_mark+1),a  
4d16 3a 20 4d			ld a, (.dmark+2)  
4d19 32 67 ee			ld (debug_mark+2),a  
4d1c 18 03			jr .pastdmark  
4d1e ..			.dmark: db "WAI"  
4d21 f1			.pastdmark: pop af  
4d22			endm  
# End of macro DMARK
4d22						CALLMONITOR 
4d22 cd 6f ee			call debug_vector  
4d25				endm  
# End of macro CALLMONITOR
4d25					endif 
4d25 cd 01 64				call cin_wait 
4d28 6f					ld l, a 
4d29 26 00				ld h, 0 
4d2b cd 90 1b				call forth_push_numhl 
4d2e					NEXTW 
4d2e c3 80 1f			jp macro_next 
4d31				endm 
# End of macro NEXTW
4d31			.ACCEPT: 
4d31				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4d31 40				db WORD_SYS_CORE+44             
4d32 8f 4d			dw .EDIT            
4d34 07				db 6 + 1 
4d35 .. 00			db "ACCEPT",0              
4d3c				endm 
# End of macro CWHEAD
4d3c			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4d3c					; TODO crashes on push 
4d3c					if DEBUG_FORTH_WORDS_KEY 
4d3c						DMARK "ACC" 
4d3c f5				push af  
4d3d 3a 51 4d			ld a, (.dmark)  
4d40 32 65 ee			ld (debug_mark),a  
4d43 3a 52 4d			ld a, (.dmark+1)  
4d46 32 66 ee			ld (debug_mark+1),a  
4d49 3a 53 4d			ld a, (.dmark+2)  
4d4c 32 67 ee			ld (debug_mark+2),a  
4d4f 18 03			jr .pastdmark  
4d51 ..			.dmark: db "ACC"  
4d54 f1			.pastdmark: pop af  
4d55			endm  
# End of macro DMARK
4d55						CALLMONITOR 
4d55 cd 6f ee			call debug_vector  
4d58				endm  
# End of macro CALLMONITOR
4d58					endif 
4d58 21 b9 e4				ld hl, os_input 
4d5b 3e 00				ld a, 0 
4d5d 77					ld (hl),a 
4d5e 3a 58 ea				ld a,(f_cursor_ptr) 
4d61 16 64				ld d, 100 
4d63 0e 00				ld c, 0 
4d65 1e 28				ld e, 40 
4d67 cd 22 0e				call input_str 
4d6a					; TODO perhaps do a type check and wrap in quotes if not a number 
4d6a 21 b9 e4				ld hl, os_input 
4d6d					if DEBUG_FORTH_WORDS 
4d6d						DMARK "AC1" 
4d6d f5				push af  
4d6e 3a 82 4d			ld a, (.dmark)  
4d71 32 65 ee			ld (debug_mark),a  
4d74 3a 83 4d			ld a, (.dmark+1)  
4d77 32 66 ee			ld (debug_mark+1),a  
4d7a 3a 84 4d			ld a, (.dmark+2)  
4d7d 32 67 ee			ld (debug_mark+2),a  
4d80 18 03			jr .pastdmark  
4d82 ..			.dmark: db "AC1"  
4d85 f1			.pastdmark: pop af  
4d86			endm  
# End of macro DMARK
4d86						CALLMONITOR 
4d86 cd 6f ee			call debug_vector  
4d89				endm  
# End of macro CALLMONITOR
4d89					endif 
4d89 cd fe 1b				call forth_push_str 
4d8c					NEXTW 
4d8c c3 80 1f			jp macro_next 
4d8f				endm 
# End of macro NEXTW
4d8f			 
4d8f			.EDIT: 
4d8f				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d8f 40				db WORD_SYS_CORE+44             
4d90 31 4e			dw .DEDIT            
4d92 05				db 4 + 1 
4d93 .. 00			db "EDIT",0              
4d98				endm 
# End of macro CWHEAD
4d98			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d98			 
4d98					; TODO does not copy from stack 
4d98					if DEBUG_FORTH_WORDS_KEY 
4d98						DMARK "EDT" 
4d98 f5				push af  
4d99 3a ad 4d			ld a, (.dmark)  
4d9c 32 65 ee			ld (debug_mark),a  
4d9f 3a ae 4d			ld a, (.dmark+1)  
4da2 32 66 ee			ld (debug_mark+1),a  
4da5 3a af 4d			ld a, (.dmark+2)  
4da8 32 67 ee			ld (debug_mark+2),a  
4dab 18 03			jr .pastdmark  
4dad ..			.dmark: db "EDT"  
4db0 f1			.pastdmark: pop af  
4db1			endm  
# End of macro DMARK
4db1						CALLMONITOR 
4db1 cd 6f ee			call debug_vector  
4db4				endm  
# End of macro CALLMONITOR
4db4					endif 
4db4			 
4db4					;FORTH_DSP 
4db4					FORTH_DSP_VALUEHL 
4db4 cd 95 1d			call macro_dsp_valuehl 
4db7				endm 
# End of macro FORTH_DSP_VALUEHL
4db7			;		inc hl    ; TODO do type check 
4db7			 
4db7			;		call get_word_hl 
4db7 e5					push hl 
4db8					if DEBUG_FORTH_WORDS 
4db8						DMARK "EDp" 
4db8 f5				push af  
4db9 3a cd 4d			ld a, (.dmark)  
4dbc 32 65 ee			ld (debug_mark),a  
4dbf 3a ce 4d			ld a, (.dmark+1)  
4dc2 32 66 ee			ld (debug_mark+1),a  
4dc5 3a cf 4d			ld a, (.dmark+2)  
4dc8 32 67 ee			ld (debug_mark+2),a  
4dcb 18 03			jr .pastdmark  
4dcd ..			.dmark: db "EDp"  
4dd0 f1			.pastdmark: pop af  
4dd1			endm  
# End of macro DMARK
4dd1						CALLMONITOR 
4dd1 cd 6f ee			call debug_vector  
4dd4				endm  
# End of macro CALLMONITOR
4dd4					endif 
4dd4				;	ld a, 0 
4dd4 cd 5b 11				call strlenz 
4dd7 23					inc hl 
4dd8			 
4dd8 06 00				ld b, 0 
4dda 4d					ld c, l 
4ddb			 
4ddb e1					pop hl 
4ddc 11 b9 e4				ld de, os_input 
4ddf					if DEBUG_FORTH_WORDS_KEY 
4ddf						DMARK "EDc" 
4ddf f5				push af  
4de0 3a f4 4d			ld a, (.dmark)  
4de3 32 65 ee			ld (debug_mark),a  
4de6 3a f5 4d			ld a, (.dmark+1)  
4de9 32 66 ee			ld (debug_mark+1),a  
4dec 3a f6 4d			ld a, (.dmark+2)  
4def 32 67 ee			ld (debug_mark+2),a  
4df2 18 03			jr .pastdmark  
4df4 ..			.dmark: db "EDc"  
4df7 f1			.pastdmark: pop af  
4df8			endm  
# End of macro DMARK
4df8						CALLMONITOR 
4df8 cd 6f ee			call debug_vector  
4dfb				endm  
# End of macro CALLMONITOR
4dfb					endif 
4dfb ed b0				ldir 
4dfd			 
4dfd			 
4dfd 21 b9 e4				ld hl, os_input 
4e00					;ld a, 0 
4e00					;ld (hl),a 
4e00 3a 58 ea				ld a,(f_cursor_ptr) 
4e03 16 64				ld d, 100 
4e05 0e 00				ld c, 0 
4e07 1e 28				ld e, 40 
4e09 cd 22 0e				call input_str 
4e0c					; TODO perhaps do a type check and wrap in quotes if not a number 
4e0c 21 b9 e4				ld hl, os_input 
4e0f					if DEBUG_FORTH_WORDS 
4e0f						DMARK "ED1" 
4e0f f5				push af  
4e10 3a 24 4e			ld a, (.dmark)  
4e13 32 65 ee			ld (debug_mark),a  
4e16 3a 25 4e			ld a, (.dmark+1)  
4e19 32 66 ee			ld (debug_mark+1),a  
4e1c 3a 26 4e			ld a, (.dmark+2)  
4e1f 32 67 ee			ld (debug_mark+2),a  
4e22 18 03			jr .pastdmark  
4e24 ..			.dmark: db "ED1"  
4e27 f1			.pastdmark: pop af  
4e28			endm  
# End of macro DMARK
4e28						CALLMONITOR 
4e28 cd 6f ee			call debug_vector  
4e2b				endm  
# End of macro CALLMONITOR
4e2b					endif 
4e2b cd fe 1b				call forth_push_str 
4e2e					NEXTW 
4e2e c3 80 1f			jp macro_next 
4e31				endm 
# End of macro NEXTW
4e31			 
4e31			.DEDIT: 
4e31				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4e31 40				db WORD_SYS_CORE+44             
4e32 93 4e			dw .ENDKEY            
4e34 06				db 5 + 1 
4e35 .. 00			db "DEDIT",0              
4e3b				endm 
# End of macro CWHEAD
4e3b			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
4e3b			 
4e3b					; TODO does not copy from stack 
4e3b					if DEBUG_FORTH_WORDS_KEY 
4e3b						DMARK "DED" 
4e3b f5				push af  
4e3c 3a 50 4e			ld a, (.dmark)  
4e3f 32 65 ee			ld (debug_mark),a  
4e42 3a 51 4e			ld a, (.dmark+1)  
4e45 32 66 ee			ld (debug_mark+1),a  
4e48 3a 52 4e			ld a, (.dmark+2)  
4e4b 32 67 ee			ld (debug_mark+2),a  
4e4e 18 03			jr .pastdmark  
4e50 ..			.dmark: db "DED"  
4e53 f1			.pastdmark: pop af  
4e54			endm  
# End of macro DMARK
4e54						CALLMONITOR 
4e54 cd 6f ee			call debug_vector  
4e57				endm  
# End of macro CALLMONITOR
4e57					endif 
4e57			 
4e57					;FORTH_DSP 
4e57					FORTH_DSP_VALUEHL 
4e57 cd 95 1d			call macro_dsp_valuehl 
4e5a				endm 
# End of macro FORTH_DSP_VALUEHL
4e5a			;		inc hl    ; TODO do type check 
4e5a			 
4e5a			;		call get_word_hl 
4e5a e5					push hl 
4e5b e5					push hl 
4e5c					FORTH_DSP_POP 
4e5c cd 4d 1e			call macro_forth_dsp_pop 
4e5f				endm 
# End of macro FORTH_DSP_POP
4e5f e1					pop hl 
4e60					if DEBUG_FORTH_WORDS 
4e60						DMARK "EDp" 
4e60 f5				push af  
4e61 3a 75 4e			ld a, (.dmark)  
4e64 32 65 ee			ld (debug_mark),a  
4e67 3a 76 4e			ld a, (.dmark+1)  
4e6a 32 66 ee			ld (debug_mark+1),a  
4e6d 3a 77 4e			ld a, (.dmark+2)  
4e70 32 67 ee			ld (debug_mark+2),a  
4e73 18 03			jr .pastdmark  
4e75 ..			.dmark: db "EDp"  
4e78 f1			.pastdmark: pop af  
4e79			endm  
# End of macro DMARK
4e79						CALLMONITOR 
4e79 cd 6f ee			call debug_vector  
4e7c				endm  
# End of macro CALLMONITOR
4e7c					endif 
4e7c				;	ld a, 0 
4e7c cd 5b 11				call strlenz 
4e7f 23					inc hl 
4e80			 
4e80 06 00				ld b, 0 
4e82 4d					ld c, l 
4e83			 
4e83 e1					pop hl 
4e84			 
4e84					;ld a, 0 
4e84					;ld (hl),a 
4e84 3a 58 ea				ld a,(f_cursor_ptr) 
4e87 16 64				ld d, 100 
4e89 0e 00				ld c, 0 
4e8b 1e 28				ld e, 40 
4e8d cd 22 0e				call input_str 
4e90					; TODO perhaps do a type check and wrap in quotes if not a number 
4e90					NEXTW 
4e90 c3 80 1f			jp macro_next 
4e93				endm 
# End of macro NEXTW
4e93			 
4e93			 
4e93			.ENDKEY: 
4e93			; eof 
4e93			 
# End of file forth_words_key.asm
4e93			include "forth_words_const.asm" 
4e93			 
4e93			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e93			 
4e93			 
4e93			.SPITIME: 
4e93				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e93 77				db WORD_SYS_CORE+99             
4e94 a8 4e			dw .VA            
4e96 08				db 7 + 1 
4e97 .. 00			db "SPITIME",0              
4e9f				endm 
# End of macro CWHEAD
4e9f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4e9f			; 
4e9f			; | | If using BANK devices then leave as is. 
4e9f			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4e9f			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4e9f			 
4e9f 21 5e ea				ld hl, spi_clktime  
4ea2 cd 90 1b				call forth_push_numhl 
4ea5			 
4ea5					NEXTW 
4ea5 c3 80 1f			jp macro_next 
4ea8				endm 
# End of macro NEXTW
4ea8			 
4ea8			 
4ea8			.VA: 
4ea8				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4ea8 77				db WORD_SYS_CORE+99             
4ea9 b8 4e			dw .SYMBOL            
4eab 03				db 2 + 1 
4eac .. 00			db "VA",0              
4eaf				endm 
# End of macro CWHEAD
4eaf			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4eaf 21 22 ea				ld hl, cli_var_array 
4eb2 cd 90 1b				call forth_push_numhl 
4eb5			 
4eb5					NEXTW 
4eb5 c3 80 1f			jp macro_next 
4eb8				endm 
# End of macro NEXTW
4eb8			 
4eb8			.SYMBOL: 
4eb8				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4eb8 77				db WORD_SYS_CORE+99             
4eb9 c2 4f			dw .ENDCONST            
4ebb 07				db 6 + 1 
4ebc .. 00			db "SYMBOL",0              
4ec3				endm 
# End of macro CWHEAD
4ec3			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4ec3			; | 
4ec3			; | | The value is the number reference and the final address is pushed to stack 
4ec3			 
4ec3			; | | ``` 
4ec3			; | | dw sym_table 
4ec3			; | | dw nmi_vector 
4ec3			; | | dw cli_autodisplay 
4ec3			; | | dw cli_data_sp 
4ec3			; | | dw cli_data_stack 
4ec3			; | | dw cli_loop_sp 
4ec3			; | | dw cli_loop_stack 
4ec3			; | | dw cli_var_array 
4ec3			; | | dw cursor_col 
4ec3			; | | dw cursor_ptr 
4ec3			; | | ; 10 
4ec3			; | | dw cursor_row 
4ec3			; | | dw debug_mark 
4ec3			; | | dw display_fb0 
4ec3			; | | dw display_fb1 
4ec3			; | | dw display_fb2 
4ec3			; | | dw display_fb3 
4ec3			; | | dw display_fb_active 
4ec3			; | | dw execscratch 
4ec3			; | | dw f_cursor_ptr 
4ec3			; | | dw hardware_word 
4ec3			; | | ;20 
4ec3			; | | dw input_at_cursor 
4ec3			; | | dw input_at_pos 
4ec3			; | | dw input_cur_flash 
4ec3			; | | dw input_cur_onoff 
4ec3			; | | dw input_cursor 
4ec3			; | | dw input_display_size 
4ec3			; | | dw input_len 
4ec3			; | | dw input_ptr 
4ec3			; | | dw input_size 
4ec3			; | | dw input_start 
4ec3			; | | ; 30 
4ec3			; | | dw input_str 
4ec3			; | | dw input_under_cursor 
4ec3			; | | dw os_cli_cmd 
4ec3			; | | dw os_cur_ptr 
4ec3			; | | dw os_current_i 
4ec3			; | | dw os_input 
4ec3			; | | dw os_last_cmd 
4ec3			; | | dw os_last_new_uword 
4ec3			; | | dw debug_vector 
4ec3			; | | dw os_view_hl 
4ec3			; | | ;40 
4ec3			; | | dw os_word_scratch 
4ec3			; | | dw portbctl 
4ec3			; | | dw portbdata 
4ec3			; | | dw spi_cartdev 
4ec3			; | | dw spi_cartdev2 
4ec3			; | | dw spi_clktime 
4ec3			; | | dw spi_device 
4ec3			; | | dw spi_device_id 
4ec3			; | | dw spi_portbyte 
4ec3			; | | dw stackstore 
4ec3			; | | ; 50 
4ec3			; | | if STORAGE_SE 
4ec3			; | | dw storage_actl 
4ec3			; | | dw storage_adata 
4ec3			; | | else 
4ec3			; | | dw 0 
4ec3			; | | dw 0 
4ec3			; | | endif 
4ec3			; | | dw storage_append 
4ec3			; | | if STORAGE_SE 
4ec3			; | | dw storage_bctl 
4ec3			; | | else 
4ec3			; | | dw 0 
4ec3			; | | endif 
4ec3			; | | dw store_bank_active 
4ec3			; | | dw store_filecache 
4ec3			; | | dw store_longread 
4ec3			; | | dw store_openaddr 
4ec3			; | | dw store_openext 
4ec3			; | | dw store_openmaxext 
4ec3			; | | ; 60 
4ec3			; | | dw store_page 
4ec3			; | | dw store_readbuf 
4ec3			; | | dw store_readcont 
4ec3			; | | dw store_readptr 
4ec3			; | | dw store_tmpext 
4ec3			; | | dw store_tmpid 
4ec3			; | | dw store_tmppageid 
4ec3			; | | dw malloc 
4ec3			; | | dw free 
4ec3			; | | dw cin 
4ec3			; | | ; 70 
4ec3			; | | dw cin_wait 
4ec3			; | | dw forth_push_numhl 
4ec3			; | | dw forth_push_str 
4ec3			; | | ``` 
4ec3			 
4ec3					if DEBUG_FORTH_WORDS_KEY 
4ec3						DMARK "SYM" 
4ec3 f5				push af  
4ec4 3a d8 4e			ld a, (.dmark)  
4ec7 32 65 ee			ld (debug_mark),a  
4eca 3a d9 4e			ld a, (.dmark+1)  
4ecd 32 66 ee			ld (debug_mark+1),a  
4ed0 3a da 4e			ld a, (.dmark+2)  
4ed3 32 67 ee			ld (debug_mark+2),a  
4ed6 18 03			jr .pastdmark  
4ed8 ..			.dmark: db "SYM"  
4edb f1			.pastdmark: pop af  
4edc			endm  
# End of macro DMARK
4edc						CALLMONITOR 
4edc cd 6f ee			call debug_vector  
4edf				endm  
# End of macro CALLMONITOR
4edf					endif 
4edf			 
4edf					FORTH_DSP_VALUEHL 
4edf cd 95 1d			call macro_dsp_valuehl 
4ee2				endm 
# End of macro FORTH_DSP_VALUEHL
4ee2			 
4ee2 7d					ld a, l     
4ee3			 
4ee3			 
4ee3					if DEBUG_FORTH_WORDS 
4ee3						DMARK "SY1" 
4ee3 f5				push af  
4ee4 3a f8 4e			ld a, (.dmark)  
4ee7 32 65 ee			ld (debug_mark),a  
4eea 3a f9 4e			ld a, (.dmark+1)  
4eed 32 66 ee			ld (debug_mark+1),a  
4ef0 3a fa 4e			ld a, (.dmark+2)  
4ef3 32 67 ee			ld (debug_mark+2),a  
4ef6 18 03			jr .pastdmark  
4ef8 ..			.dmark: db "SY1"  
4efb f1			.pastdmark: pop af  
4efc			endm  
# End of macro DMARK
4efc						CALLMONITOR 
4efc cd 6f ee			call debug_vector  
4eff				endm  
# End of macro CALLMONITOR
4eff					endif 
4eff					 
4eff f5					push af	 
4f00					FORTH_DSP_POP 
4f00 cd 4d 1e			call macro_forth_dsp_pop 
4f03				endm 
# End of macro FORTH_DSP_POP
4f03 f1					pop af 
4f04			 
4f04 cb 27				sla a  
4f06				 
4f06					 
4f06					if DEBUG_FORTH_WORDS 
4f06						DMARK "SY" 
4f06 f5				push af  
4f07 3a 1b 4f			ld a, (.dmark)  
4f0a 32 65 ee			ld (debug_mark),a  
4f0d 3a 1c 4f			ld a, (.dmark+1)  
4f10 32 66 ee			ld (debug_mark+1),a  
4f13 3a 1d 4f			ld a, (.dmark+2)  
4f16 32 67 ee			ld (debug_mark+2),a  
4f19 18 02			jr .pastdmark  
4f1b ..			.dmark: db "SY"  
4f1d f1			.pastdmark: pop af  
4f1e			endm  
# End of macro DMARK
4f1e						CALLMONITOR 
4f1e cd 6f ee			call debug_vector  
4f21				endm  
# End of macro CALLMONITOR
4f21					endif 
4f21			 
4f21 21 30 4f				ld hl, sym_table 
4f24 cd f5 0d				call addatohl 
4f27 cd 02 1f				call loadwordinhl 
4f2a cd 90 1b				call forth_push_numhl 
4f2d			 
4f2d			 
4f2d				       NEXTW 
4f2d c3 80 1f			jp macro_next 
4f30				endm 
# End of macro NEXTW
4f30			 
4f30			sym_table: 
4f30			 
4f30			; 0 
4f30 30 4f		dw sym_table 
4f32 72 ee		dw nmi_vector 
4f34 36 ea		dw cli_autodisplay 
4f36 e8 e9		dw cli_data_sp 
4f38 22 e8		dw cli_data_stack 
4f3a ea e9		dw cli_loop_sp 
4f3c 24 e9		dw cli_loop_stack 
4f3e 22 ea		dw cli_var_array 
4f40 bf eb		dw cursor_col 
4f42 bd eb		dw cursor_ptr 
4f44			; 10 
4f44 be eb		dw cursor_row 
4f46 65 ee		dw debug_mark 
4f48 ab ed		dw display_fb0 
4f4a 0a ed		dw display_fb1 
4f4c c8 eb		dw display_fb2 
4f4e 69 ec		dw display_fb3 
4f50 c6 eb		dw display_fb_active 
4f52 ba e3		dw execscratch 
4f54 58 ea		dw f_cursor_ptr 
4f56 75 ee		dw hardware_word 
4f58			;20 
4f58 5c ee		dw input_at_cursor 
4f5a 5e ee		dw input_at_pos 
4f5c 5a ee		dw input_cur_flash 
4f5e 59 ee		dw input_cur_onoff 
4f60 4f ee		dw input_cursor 
4f62 5f ee		dw input_display_size 
4f64 54 ee		dw input_len 
4f66 63 ee		dw input_ptr 
4f68 60 ee		dw input_size 
4f6a 61 ee		dw input_start 
4f6c			; 30 
4f6c 22 0e		dw input_str 
4f6e 5d ee		dw input_under_cursor 
4f70 e2 e5		dw os_cli_cmd 
4f72 de e5		dw os_cur_ptr 
4f74 e0 e5		dw os_current_i 
4f76 b9 e4		dw os_input 
4f78 e1 e6		dw os_last_cmd 
4f7a b8 e5		dw os_last_new_uword 
4f7c 6f ee		dw debug_vector 
4f7e 9d e2		dw os_view_hl 
4f80			;40 
4f80 c0 e5		dw os_word_scratch 
4f82 c3 00		dw portbctl 
4f84 c1 00		dw portbdata 
4f86 5d ea		dw spi_cartdev 
4f88 5c ea		dw spi_cartdev2 
4f8a 5e ea		dw spi_clktime 
4f8c 5a ea		dw spi_device 
4f8e 59 ea		dw spi_device_id 
4f90 5b ea		dw spi_portbyte 
4f92 a1 eb		dw stackstore 
4f94			; 50 
4f94			if STORAGE_SE 
4f94			dw storage_actl 
4f94			dw storage_adata 
4f94			else 
4f94 00 00		dw 0 
4f96 00 00		dw 0 
4f98			endif 
4f98 77 09		dw storage_append 
4f9a			if STORAGE_SE 
4f9a			dw storage_bctl 
4f9a			else 
4f9a 00 00		dw 0 
4f9c			endif 
4f9c 8d eb		dw store_bank_active 
4f9e 61 ea		dw store_filecache 
4fa0 6f ea		dw store_longread 
4fa2 65 ea		dw store_openaddr 
4fa4 64 ea		dw store_openext 
4fa6 63 ea		dw store_openmaxext 
4fa8			; 60 
4fa8 74 ea		dw store_page 
4faa 70 ea		dw store_readbuf 
4fac 67 ea		dw store_readcont 
4fae 72 ea		dw store_readptr 
4fb0 67 ea		dw store_tmpext 
4fb2 68 ea		dw store_tmpid 
4fb4 5f ea		dw store_tmppageid 
4fb6 d0 11		dw malloc 
4fb8 9a 12		dw free 
4fba 09 64		dw cin 
4fbc			; 70 
4fbc 01 64		dw cin_wait 
4fbe 90 1b		dw forth_push_numhl 
4fc0 fe 1b		dw forth_push_str 
4fc2			 
4fc2			 
4fc2			.ENDCONST: 
4fc2			 
4fc2			; eof 
4fc2			 
4fc2			 
# End of file forth_words_const.asm
4fc2			 
4fc2			if STORAGE_SE 
4fc2			   	include "forth_words_storage.asm" 
4fc2			endif 
4fc2				include "forth_words_device.asm" 
4fc2			; Device related words 
4fc2			 
4fc2			; | ## Device Words 
4fc2			 
4fc2			;if SOUND_ENABLE 
4fc2			;.NOTE: 
4fc2			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4fc2			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4fc2			;		if DEBUG_FORTH_WORDS_KEY 
4fc2			;			DMARK "NTE" 
4fc2			;			CALLMONITOR 
4fc2			;		endif 
4fc2			; 
4fc2			;	 
4fc2			; 
4fc2			;		NEXTW 
4fc2			;.AFTERSOUND: 
4fc2			;endif 
4fc2			 
4fc2			 
4fc2			USE_GPIO: equ 0 
4fc2			 
4fc2			if USE_GPIO 
4fc2			.GP1: 
4fc2				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4fc2			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4fc2					NEXTW 
4fc2			.GP2: 
4fc2				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4fc2			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4fc2			 
4fc2					NEXTW 
4fc2			 
4fc2			.GP3: 
4fc2				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4fc2			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4fc2			 
4fc2					NEXTW 
4fc2			 
4fc2			.GP4: 
4fc2				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4fc2			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4fc2			 
4fc2					NEXTW 
4fc2			.SIN: 
4fc2			 
4fc2			 
4fc2			endif 
4fc2			 
4fc2			 
4fc2				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4fc2 33				db WORD_SYS_CORE+31             
4fc3 f7 4f			dw .SOUT            
4fc5 03				db 2 + 1 
4fc6 .. 00			db "IN",0              
4fc9				endm 
# End of macro CWHEAD
4fc9			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4fc9					if DEBUG_FORTH_WORDS_KEY 
4fc9						DMARK "IN." 
4fc9 f5				push af  
4fca 3a de 4f			ld a, (.dmark)  
4fcd 32 65 ee			ld (debug_mark),a  
4fd0 3a df 4f			ld a, (.dmark+1)  
4fd3 32 66 ee			ld (debug_mark+1),a  
4fd6 3a e0 4f			ld a, (.dmark+2)  
4fd9 32 67 ee			ld (debug_mark+2),a  
4fdc 18 03			jr .pastdmark  
4fde ..			.dmark: db "IN."  
4fe1 f1			.pastdmark: pop af  
4fe2			endm  
# End of macro DMARK
4fe2						CALLMONITOR 
4fe2 cd 6f ee			call debug_vector  
4fe5				endm  
# End of macro CALLMONITOR
4fe5					endif 
4fe5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fe5 cd 95 1d			call macro_dsp_valuehl 
4fe8				endm 
# End of macro FORTH_DSP_VALUEHL
4fe8			 
4fe8 e5					push hl 
4fe9			 
4fe9					; destroy value TOS 
4fe9			 
4fe9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fe9 cd 4d 1e			call macro_forth_dsp_pop 
4fec				endm 
# End of macro FORTH_DSP_POP
4fec			 
4fec					; one value on hl get other one back 
4fec			 
4fec c1					pop bc 
4fed			 
4fed					; do the sub 
4fed			;		ex de, hl 
4fed			 
4fed ed 68				in l,(c) 
4fef			 
4fef					; save it 
4fef			 
4fef 26 00				ld h,0 
4ff1			 
4ff1					; TODO push value back onto stack for another op etc 
4ff1			 
4ff1 cd 90 1b				call forth_push_numhl 
4ff4					NEXTW 
4ff4 c3 80 1f			jp macro_next 
4ff7				endm 
# End of macro NEXTW
4ff7			.SOUT: 
4ff7				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ff7 34				db WORD_SYS_CORE+32             
4ff8 4a 50			dw .SPIO            
4ffa 04				db 3 + 1 
4ffb .. 00			db "OUT",0              
4fff				endm 
# End of macro CWHEAD
4fff			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4fff					if DEBUG_FORTH_WORDS_KEY 
4fff						DMARK "OUT" 
4fff f5				push af  
5000 3a 14 50			ld a, (.dmark)  
5003 32 65 ee			ld (debug_mark),a  
5006 3a 15 50			ld a, (.dmark+1)  
5009 32 66 ee			ld (debug_mark+1),a  
500c 3a 16 50			ld a, (.dmark+2)  
500f 32 67 ee			ld (debug_mark+2),a  
5012 18 03			jr .pastdmark  
5014 ..			.dmark: db "OUT"  
5017 f1			.pastdmark: pop af  
5018			endm  
# End of macro DMARK
5018						CALLMONITOR 
5018 cd 6f ee			call debug_vector  
501b				endm  
# End of macro CALLMONITOR
501b					endif 
501b			 
501b					; get port 
501b			 
501b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
501b cd 95 1d			call macro_dsp_valuehl 
501e				endm 
# End of macro FORTH_DSP_VALUEHL
501e			 
501e e5					push hl 
501f			 
501f					; destroy value TOS 
501f			 
501f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
501f cd 4d 1e			call macro_forth_dsp_pop 
5022				endm 
# End of macro FORTH_DSP_POP
5022			 
5022					; get byte to send 
5022			 
5022					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5022 cd 95 1d			call macro_dsp_valuehl 
5025				endm 
# End of macro FORTH_DSP_VALUEHL
5025			 
5025			;		push hl 
5025			 
5025					; destroy value TOS 
5025			 
5025					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5025 cd 4d 1e			call macro_forth_dsp_pop 
5028				endm 
# End of macro FORTH_DSP_POP
5028			 
5028					; one value on hl get other one back 
5028			 
5028			;		pop hl 
5028			 
5028 c1					pop bc 
5029			 
5029					if DEBUG_FORTH_WORDS 
5029						DMARK "OUT" 
5029 f5				push af  
502a 3a 3e 50			ld a, (.dmark)  
502d 32 65 ee			ld (debug_mark),a  
5030 3a 3f 50			ld a, (.dmark+1)  
5033 32 66 ee			ld (debug_mark+1),a  
5036 3a 40 50			ld a, (.dmark+2)  
5039 32 67 ee			ld (debug_mark+2),a  
503c 18 03			jr .pastdmark  
503e ..			.dmark: db "OUT"  
5041 f1			.pastdmark: pop af  
5042			endm  
# End of macro DMARK
5042						CALLMONITOR 
5042 cd 6f ee			call debug_vector  
5045				endm  
# End of macro CALLMONITOR
5045					endif 
5045			 
5045 ed 69				out (c), l 
5047			 
5047					NEXTW 
5047 c3 80 1f			jp macro_next 
504a				endm 
# End of macro NEXTW
504a			 
504a			 
504a			.SPIO: 
504a			 
504a			if STORAGE_SE 
504a				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
504a			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
504a			 
504a					call spi_ce_low 
504a			    NEXTW 
504a			 
504a			.SPICEH: 
504a				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
504a			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
504a			 
504a					call spi_ce_high 
504a			    NEXTW 
504a			 
504a			 
504a			.SPIOb: 
504a			 
504a				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
504a			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
504a			 
504a					if DEBUG_FORTH_WORDS_KEY 
504a						DMARK "SPo" 
504a						CALLMONITOR 
504a					endif 
504a					; get port 
504a			 
504a			 
504a					; get byte to send 
504a			 
504a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
504a			 
504a			;		push hl    ; u1  
504a			 
504a					; destroy value TOS 
504a			 
504a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
504a			 
504a					; one value on hl get other one back 
504a			 
504a			;		pop hl   ; u2 - addr 
504a			 
504a					; TODO Send SPI byte 
504a			 
504a			;		push hl 
504a			;		call spi_ce_low 
504a			;		pop hl 
504a					ld a, l 
504a					call spi_send_byte 
504a			;		call spi_ce_high 
504a			 
504a					NEXTW 
504a			 
504a			.SPII: 
504a				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
504a			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
504a					if DEBUG_FORTH_WORDS_KEY 
504a						DMARK "SPi" 
504a						CALLMONITOR 
504a					endif 
504a			 
504a					; TODO Get SPI byte 
504a			 
504a					call spi_read_byte 
504a			 
504a					if DEBUG_FORTH_WORDS 
504a						DMARK "Si2" 
504a						CALLMONITOR 
504a					endif 
504a					ld h, 0 
504a					ld l, a 
504a					if DEBUG_FORTH_WORDS 
504a						DMARK "Si3" 
504a						CALLMONITOR 
504a					endif 
504a					call forth_push_numhl 
504a			 
504a					NEXTW 
504a			 
504a			 
504a			 
504a			.SESEL: 
504a				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
504a			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
504a					if DEBUG_FORTH_WORDS_KEY 
504a						DMARK "BNK" 
504a						CALLMONITOR 
504a					endif 
504a			 
504a					ld a, 255 
504a					ld (spi_cartdev), a 
504a			 
504a					; get bank 
504a			 
504a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
504a			 
504a			;		push hl 
504a			 
504a					; destroy value TOS 
504a			 
504a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
504a			 
504a					; one value on hl get other one back 
504a			 
504a			;		pop hl 
504a			 
504a			 
504a					ld c, SPI_CE_HIGH 
504a					ld b, '0'    ; human readable bank number 
504a			 
504a					ld a, l 
504a			 
504a					if DEBUG_FORTH_WORDS 
504a						DMARK "BNK" 
504a						CALLMONITOR 
504a					endif 
504a			 
504a					; active low 
504a			 
504a					cp 0 
504a					jr z, .bset 
504a					cp 1 
504a					jr nz, .b2 
504a					res 0, c 
504a					ld b, '1'    ; human readable bank number 
504a			.b2:		cp 2 
504a					jr nz, .b3 
504a					res 1, c 
504a					ld b, '2'    ; human readable bank number 
504a			.b3:		cp 3 
504a					jr nz, .b4 
504a					res 2, c 
504a					ld b, '3'    ; human readable bank number 
504a			.b4:		cp 4 
504a					jr nz, .b5 
504a					res 3, c 
504a					ld b, '4'    ; human readable bank number 
504a			.b5:		cp 5 
504a					jr nz, .bset 
504a					res 4, c 
504a					ld b, '5'    ; human readable bank number 
504a			 
504a			.bset: 
504a					ld a, c 
504a					ld (spi_device),a 
504a					ld a, b 
504a					ld (spi_device_id),a 
504a					if DEBUG_FORTH_WORDS 
504a						DMARK "BN2" 
504a						CALLMONITOR 
504a					endif 
504a			 
504a					; set default SPI clk pulse time as disabled for BANK use 
504a			 
504a					ld a, 0 
504a					ld (spi_clktime), a 
504a			 
504a					NEXTW 
504a			 
504a			.CARTDEV: 
504a				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
504a			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
504a					if DEBUG_FORTH_WORDS_KEY 
504a						DMARK "CDV" 
504a						CALLMONITOR 
504a					endif 
504a			 
504a					; disable se storage bank selection 
504a			 
504a					ld a, SPI_CE_HIGH		; ce high 
504a					ld (spi_device), a 
504a			 
504a					; get bank 
504a			 
504a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
504a			 
504a			;		push hl 
504a			 
504a					; destroy value TOS 
504a			 
504a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
504a			 
504a					; one value on hl get other one back 
504a			 
504a			;		pop hl 
504a			 
504a					; active low 
504a			 
504a					ld c, 255 
504a			 
504a					ld a, l 
504a					if DEBUG_FORTH_WORDS 
504a						DMARK "CDV" 
504a						CALLMONITOR 
504a					endif 
504a					cp 0 
504a					jr z, .cset 
504a					cp 1 
504a					jr nz, .c2 
504a					res 0, c 
504a			.c2:		cp 2 
504a					jr nz, .c3 
504a					res 1, c 
504a			.c3:		cp 3 
504a					jr nz, .c4 
504a					res 2, c 
504a			.c4:		cp 4 
504a					jr nz, .c5 
504a					res 3, c 
504a			.c5:		cp 5 
504a					jr nz, .c6 
504a					res 4, c 
504a			.c6:		cp 6 
504a					jr nz, .c7 
504a					res 5, c 
504a			.c7:		cp 7 
504a					jr nz, .c8 
504a					res 6, c 
504a			.c8:		cp 8 
504a					jr nz, .cset 
504a					res 7, c 
504a			.cset:		ld a, c 
504a					ld (spi_cartdev),a 
504a			 
504a					if DEBUG_FORTH_WORDS 
504a						DMARK "CD2" 
504a						CALLMONITOR 
504a					endif 
504a			 
504a					; set default SPI clk pulse time as 10ms for CARTDEV use 
504a			 
504a					ld a, $0a 
504a					ld (spi_clktime), a 
504a					NEXTW 
504a			endif 
504a			 
504a			.ENDDEVICE: 
504a			; eof 
504a			 
# End of file forth_words_device.asm
504a			 
504a			; var handler 
504a			 
504a			 
504a			.VARS: 
504a				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
504a 77				db WORD_SYS_CORE+99             
504b fb 50			dw .V0            
504d 04				db 3 + 1 
504e .. 00			db "VAR",0              
5052				endm 
# End of macro CWHEAD
5052			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5052			;| 
5052			;| The variable name should consist of a single letter. e.g. "a" 
5052			;! If a full string is passed then only the first char is looked at 
5052			;| Any other char could exceed bounds checks!  
5052			 
5052					if DEBUG_FORTH_WORDS_KEY 
5052						DMARK "VAR" 
5052 f5				push af  
5053 3a 67 50			ld a, (.dmark)  
5056 32 65 ee			ld (debug_mark),a  
5059 3a 68 50			ld a, (.dmark+1)  
505c 32 66 ee			ld (debug_mark+1),a  
505f 3a 69 50			ld a, (.dmark+2)  
5062 32 67 ee			ld (debug_mark+2),a  
5065 18 03			jr .pastdmark  
5067 ..			.dmark: db "VAR"  
506a f1			.pastdmark: pop af  
506b			endm  
# End of macro DMARK
506b						CALLMONITOR 
506b cd 6f ee			call debug_vector  
506e				endm  
# End of macro CALLMONITOR
506e					endif 
506e			 
506e					FORTH_DSP_VALUEHL 
506e cd 95 1d			call macro_dsp_valuehl 
5071				endm 
# End of macro FORTH_DSP_VALUEHL
5071			 
5071 7e					ld a, (hl)    ; get first char on of the string 
5072			 
5072			 
5072					if DEBUG_FORTH_WORDS 
5072						DMARK "VR1" 
5072 f5				push af  
5073 3a 87 50			ld a, (.dmark)  
5076 32 65 ee			ld (debug_mark),a  
5079 3a 88 50			ld a, (.dmark+1)  
507c 32 66 ee			ld (debug_mark+1),a  
507f 3a 89 50			ld a, (.dmark+2)  
5082 32 67 ee			ld (debug_mark+2),a  
5085 18 03			jr .pastdmark  
5087 ..			.dmark: db "VR1"  
508a f1			.pastdmark: pop af  
508b			endm  
# End of macro DMARK
508b						CALLMONITOR 
508b cd 6f ee			call debug_vector  
508e				endm  
# End of macro CALLMONITOR
508e					endif 
508e					 
508e f5					push af	 
508f					FORTH_DSP_POP 
508f cd 4d 1e			call macro_forth_dsp_pop 
5092				endm 
# End of macro FORTH_DSP_POP
5092 f1					pop af 
5093			 
5093					; convert to upper 
5093			 
5093 cd 6a 10				call to_upper 
5096					if DEBUG_FORTH_WORDS 
5096						DMARK "Vaa" 
5096 f5				push af  
5097 3a ab 50			ld a, (.dmark)  
509a 32 65 ee			ld (debug_mark),a  
509d 3a ac 50			ld a, (.dmark+1)  
50a0 32 66 ee			ld (debug_mark+1),a  
50a3 3a ad 50			ld a, (.dmark+2)  
50a6 32 67 ee			ld (debug_mark+2),a  
50a9 18 03			jr .pastdmark  
50ab ..			.dmark: db "Vaa"  
50ae f1			.pastdmark: pop af  
50af			endm  
# End of macro DMARK
50af						CALLMONITOR 
50af cd 6f ee			call debug_vector  
50b2				endm  
# End of macro CALLMONITOR
50b2					endif 
50b2 06 41				ld b, 'A' 
50b4 90					sub b			; set offset 
50b5					if DEBUG_FORTH_WORDS 
50b5						DMARK "Vbb" 
50b5 f5				push af  
50b6 3a ca 50			ld a, (.dmark)  
50b9 32 65 ee			ld (debug_mark),a  
50bc 3a cb 50			ld a, (.dmark+1)  
50bf 32 66 ee			ld (debug_mark+1),a  
50c2 3a cc 50			ld a, (.dmark+2)  
50c5 32 67 ee			ld (debug_mark+2),a  
50c8 18 03			jr .pastdmark  
50ca ..			.dmark: db "Vbb"  
50cd f1			.pastdmark: pop af  
50ce			endm  
# End of macro DMARK
50ce						CALLMONITOR 
50ce cd 6f ee			call debug_vector  
50d1				endm  
# End of macro CALLMONITOR
50d1					endif 
50d1 cb 27				sla a  
50d3				 
50d3					 
50d3					if DEBUG_FORTH_WORDS 
50d3						DMARK "VR2" 
50d3 f5				push af  
50d4 3a e8 50			ld a, (.dmark)  
50d7 32 65 ee			ld (debug_mark),a  
50da 3a e9 50			ld a, (.dmark+1)  
50dd 32 66 ee			ld (debug_mark+1),a  
50e0 3a ea 50			ld a, (.dmark+2)  
50e3 32 67 ee			ld (debug_mark+2),a  
50e6 18 03			jr .pastdmark  
50e8 ..			.dmark: db "VR2"  
50eb f1			.pastdmark: pop af  
50ec			endm  
# End of macro DMARK
50ec						CALLMONITOR 
50ec cd 6f ee			call debug_vector  
50ef				endm  
# End of macro CALLMONITOR
50ef					endif 
50ef			 
50ef 21 ee e9				ld hl, cli_var_array2 
50f2 cd f5 0d				call addatohl 
50f5 cd 90 1b				call forth_push_numhl 
50f8			 
50f8			 
50f8				       NEXTW 
50f8 c3 80 1f			jp macro_next 
50fb				endm 
# End of macro NEXTW
50fb			.V0: 
50fb				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50fb 78				db WORD_SYS_CORE+100             
50fc 13 51			dw .V0Q            
50fe 04				db 3 + 1 
50ff .. 00			db "V0!",0              
5103				endm 
# End of macro CWHEAD
5103			;| V0! ( u1 -- )  Store value to v0  | DONE 
5103			 
5103					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5103 cd 95 1d			call macro_dsp_valuehl 
5106				endm 
# End of macro FORTH_DSP_VALUEHL
5106			 
5106 11 22 ea				ld de, cli_var_array 
5109			 
5109 eb					ex de, hl 
510a 73					ld (hl), e 
510b 23					inc hl 
510c 72					ld (hl), d 
510d			 
510d					; destroy value TOS 
510d			 
510d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
510d cd 4d 1e			call macro_forth_dsp_pop 
5110				endm 
# End of macro FORTH_DSP_POP
5110			 
5110				       NEXTW 
5110 c3 80 1f			jp macro_next 
5113				endm 
# End of macro NEXTW
5113			.V0Q: 
5113				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5113 79				db WORD_SYS_CORE+101             
5114 24 51			dw .V1S            
5116 04				db 3 + 1 
5117 .. 00			db "V0@",0              
511b				endm 
# End of macro CWHEAD
511b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
511b 2a 22 ea				ld hl, (cli_var_array) 
511e cd 90 1b				call forth_push_numhl 
5121			 
5121				       NEXTW 
5121 c3 80 1f			jp macro_next 
5124				endm 
# End of macro NEXTW
5124			.V1S: 
5124				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5124 7a				db WORD_SYS_CORE+102             
5125 3c 51			dw .V1Q            
5127 04				db 3 + 1 
5128 .. 00			db "V1!",0              
512c				endm 
# End of macro CWHEAD
512c			;| V1! ( u1 -- )  Store value to v1 | DONE 
512c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
512c cd 95 1d			call macro_dsp_valuehl 
512f				endm 
# End of macro FORTH_DSP_VALUEHL
512f			 
512f 11 24 ea				ld de, cli_var_array+2 
5132				 
5132 eb					ex de, hl 
5133 73					ld (hl), e 
5134 23					inc hl 
5135 72					ld (hl), d 
5136			 
5136					; destroy value TOS 
5136			 
5136					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5136 cd 4d 1e			call macro_forth_dsp_pop 
5139				endm 
# End of macro FORTH_DSP_POP
5139				       NEXTW 
5139 c3 80 1f			jp macro_next 
513c				endm 
# End of macro NEXTW
513c			.V1Q: 
513c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
513c 7b				db WORD_SYS_CORE+103             
513d 4d 51			dw .V2S            
513f 04				db 3 + 1 
5140 .. 00			db "V1@",0              
5144				endm 
# End of macro CWHEAD
5144			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5144 2a 24 ea				ld hl, (cli_var_array+2) 
5147 cd 90 1b				call forth_push_numhl 
514a				       NEXTW 
514a c3 80 1f			jp macro_next 
514d				endm 
# End of macro NEXTW
514d			.V2S: 
514d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
514d 7c				db WORD_SYS_CORE+104             
514e 65 51			dw .V2Q            
5150 04				db 3 + 1 
5151 .. 00			db "V2!",0              
5155				endm 
# End of macro CWHEAD
5155			;| V2! ( u1 -- )  Store value to v2 | DONE 
5155					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5155 cd 95 1d			call macro_dsp_valuehl 
5158				endm 
# End of macro FORTH_DSP_VALUEHL
5158			 
5158 11 26 ea				ld de, cli_var_array+4 
515b				 
515b eb					ex de, hl 
515c 73					ld (hl), e 
515d 23					inc hl 
515e 72					ld (hl), d 
515f			 
515f					; destroy value TOS 
515f			 
515f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
515f cd 4d 1e			call macro_forth_dsp_pop 
5162				endm 
# End of macro FORTH_DSP_POP
5162				       NEXTW 
5162 c3 80 1f			jp macro_next 
5165				endm 
# End of macro NEXTW
5165			.V2Q: 
5165				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5165 7d				db WORD_SYS_CORE+105             
5166 76 51			dw .V3S            
5168 04				db 3 + 1 
5169 .. 00			db "V2@",0              
516d				endm 
# End of macro CWHEAD
516d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
516d 2a 26 ea				ld hl, (cli_var_array+4) 
5170 cd 90 1b				call forth_push_numhl 
5173				       NEXTW 
5173 c3 80 1f			jp macro_next 
5176				endm 
# End of macro NEXTW
5176			.V3S: 
5176				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5176 7c				db WORD_SYS_CORE+104             
5177 8e 51			dw .V3Q            
5179 04				db 3 + 1 
517a .. 00			db "V3!",0              
517e				endm 
# End of macro CWHEAD
517e			;| V3! ( u1 -- )  Store value to v3 | DONE 
517e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
517e cd 95 1d			call macro_dsp_valuehl 
5181				endm 
# End of macro FORTH_DSP_VALUEHL
5181			 
5181 11 28 ea				ld de, cli_var_array+6 
5184				 
5184 eb					ex de, hl 
5185 73					ld (hl), e 
5186 23					inc hl 
5187 72					ld (hl), d 
5188			 
5188					; destroy value TOS 
5188			 
5188					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5188 cd 4d 1e			call macro_forth_dsp_pop 
518b				endm 
# End of macro FORTH_DSP_POP
518b				       NEXTW 
518b c3 80 1f			jp macro_next 
518e				endm 
# End of macro NEXTW
518e			.V3Q: 
518e				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
518e 7d				db WORD_SYS_CORE+105             
518f 9f 51			dw .END            
5191 04				db 3 + 1 
5192 .. 00			db "V3@",0              
5196				endm 
# End of macro CWHEAD
5196			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5196 2a 28 ea				ld hl, (cli_var_array+6) 
5199 cd 90 1b				call forth_push_numhl 
519c				       NEXTW 
519c c3 80 1f			jp macro_next 
519f				endm 
# End of macro NEXTW
519f			 
519f			 
519f			 
519f			 
519f			 
519f			; end of dict marker 
519f			 
519f 00			.END:    db WORD_SYS_END 
51a0 00 00			dw 0 
51a2 00				db 0 
51a3			 
51a3			; use to jp here for user dict words to save on macro expansion  
51a3			 
51a3			user_dict_next: 
51a3				NEXTW 
51a3 c3 80 1f			jp macro_next 
51a6				endm 
# End of macro NEXTW
51a6			 
51a6			 
51a6			user_exec: 
51a6				;    ld hl, <word code> 
51a6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
51a6				;    call forthexec 
51a6				;    jp user_dict_next   (NEXT) 
51a6			        ;    <word code bytes> 
51a6 eb				ex de, hl 
51a7 2a bc e5			ld hl,(os_tok_ptr) 
51aa				 
51aa				FORTH_RSP_NEXT 
51aa cd 37 1b			call macro_forth_rsp_next 
51ad				endm 
# End of macro FORTH_RSP_NEXT
51ad			 
51ad			if DEBUG_FORTH_UWORD 
51ad						DMARK "UEX" 
51ad f5				push af  
51ae 3a c2 51			ld a, (.dmark)  
51b1 32 65 ee			ld (debug_mark),a  
51b4 3a c3 51			ld a, (.dmark+1)  
51b7 32 66 ee			ld (debug_mark+1),a  
51ba 3a c4 51			ld a, (.dmark+2)  
51bd 32 67 ee			ld (debug_mark+2),a  
51c0 18 03			jr .pastdmark  
51c2 ..			.dmark: db "UEX"  
51c5 f1			.pastdmark: pop af  
51c6			endm  
# End of macro DMARK
51c6				CALLMONITOR 
51c6 cd 6f ee			call debug_vector  
51c9				endm  
# End of macro CALLMONITOR
51c9			endif 
51c9			 
51c9			 
51c9			 
51c9 eb				ex de, hl 
51ca 22 bc e5			ld (os_tok_ptr), hl 
51cd				 
51cd				; Don't use next - Skips the first word in uword. 
51cd			 
51cd c3 09 20			jp exec1 
51d0			;	NEXT 
51d0			 
51d0			 
51d0			; eof 
# End of file forth_wordsv4.asm
51d0			endif 
51d0			;;;;;;;;;;;;;; Debug code 
51d0			 
51d0			 
51d0			;if DEBUG_FORTH_PARSE 
51d0 .. 00		.nowordfound: db "No match",0 
51d9 .. 00		.compword:	db "Comparing word ",0 
51e9 .. 00		.nextwordat:	db "Next word at",0 
51f6 .. 00		.charmatch:	db "Char match",0 
5201			;endif 
5201			if DEBUG_FORTH_JP 
5201			.foundword:	db "Word match. Exec..",0 
5201			endif 
5201			;if DEBUG_FORTH_PUSH 
5201 .. 00		.enddict:	db "Dict end. Push.",0 
5211 .. 00		.push_str:	db "Pushing string",0 
5220 .. 00		.push_num:	db "Pushing number",0 
522f .. 00		.data_sp:	db "SP:",0 
5233 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5245 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5257 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5269			;endif 
5269			;if DEBUG_FORTH_MALLOC 
5269 .. 00		.push_malloc:	db "Malloc address",0 
5278			;endif 
5278			 
5278			 
5278			 
5278			; display malloc address and current data stack pointer  
5278			 
5278			malloc_error: 
5278 d5				push de 
5279 f5				push af 
527a e5				push hl 
527b cd c8 0b			call clear_display 
527e 11 9e 52			ld de, .mallocerr 
5281 3e 00			ld a,0 
5283			;	ld de,os_word_scratch 
5283 cd db 0b			call str_at_display 
5286 3e 11			ld a, display_row_1+17 
5288 11 65 ee			ld de, debug_mark 
528b cd db 0b			call str_at_display 
528e cd eb 0b			call update_display 
5291				;call break_point_state 
5291 cd 01 64			call cin_wait 
5294			 
5294			;	ld a, ' ' 
5294			;	ld (os_view_disable), a 
5294 cd ff 14			call bp_on 
5297 e1				pop hl 
5298 f1				pop af 
5299 d1				pop de	 
529a				CALLMONITOR 
529a cd 6f ee			call debug_vector  
529d				endm  
# End of macro CALLMONITOR
529d c9				ret 
529e			 
529e .. 00		.mallocerr: 	db "Malloc Error",0 
52ab			;if DEBUG_FORTH_PUSH 
52ab			display_data_sp: 
52ab f5				push af 
52ac			 
52ac				; see if disabled 
52ac			 
52ac			 
52ac 3a 6f ee			ld a, (debug_vector) 
52af fe c9			cp $C9  ; RET 
52b1				;ld a, (os_view_disable) 
52b1				;cp '*' 
52b1 28 67			jr z, .skipdsp 
52b3			 
52b3 e5				push hl 
52b4 e5				push hl 
52b5 e5			push hl 
52b6 cd c8 0b			call clear_display 
52b9 e1			pop hl 
52ba 7c				ld a,h 
52bb 21 c0 e5			ld hl, os_word_scratch 
52be cd fe 0f			call hexout 
52c1 e1				pop hl 
52c2 7d				ld a,l 
52c3 21 c2 e5			ld hl, os_word_scratch+2 
52c6 cd fe 0f			call hexout 
52c9 21 c4 e5			ld hl, os_word_scratch+4 
52cc 3e 00			ld a,0 
52ce 77				ld (hl),a 
52cf 11 c0 e5			ld de,os_word_scratch 
52d2 3e 28				ld a, display_row_2 
52d4 cd db 0b				call str_at_display 
52d7 11 33 52			ld de, .wordinhl 
52da 3e 00			ld a, display_row_1 
52dc			 
52dc cd db 0b				call str_at_display 
52df 11 65 ee			ld de, debug_mark 
52e2 3e 11			ld a, display_row_1+17 
52e4			 
52e4 cd db 0b				call str_at_display 
52e7			 
52e7				; display current data stack pointer 
52e7 11 2f 52			ld de,.data_sp 
52ea 3e 30				ld a, display_row_2 + 8 
52ec cd db 0b				call str_at_display 
52ef			 
52ef 2a e8 e9			ld hl,(cli_data_sp) 
52f2 e5				push hl 
52f3 7c				ld a,h 
52f4 21 c0 e5			ld hl, os_word_scratch 
52f7 cd fe 0f			call hexout 
52fa e1				pop hl 
52fb 7d				ld a,l 
52fc 21 c2 e5			ld hl, os_word_scratch+2 
52ff cd fe 0f			call hexout 
5302 21 c4 e5			ld hl, os_word_scratch+4 
5305 3e 00			ld a,0 
5307 77				ld (hl),a 
5308 11 c0 e5			ld de,os_word_scratch 
530b 3e 33				ld a, display_row_2 + 11 
530d cd db 0b				call str_at_display 
5310			 
5310			 
5310 cd eb 0b			call update_display 
5313 cd 00 0b			call delay1s 
5316 cd 00 0b			call delay1s 
5319 e1				pop hl 
531a			.skipdsp: 
531a f1				pop af 
531b c9				ret 
531c			 
531c			display_data_malloc: 
531c			 
531c f5				push af 
531d e5				push hl 
531e e5				push hl 
531f e5			push hl 
5320 cd c8 0b			call clear_display 
5323 e1			pop hl 
5324 7c				ld a,h 
5325 21 c0 e5			ld hl, os_word_scratch 
5328 cd fe 0f			call hexout 
532b e1				pop hl 
532c 7d				ld a,l 
532d 21 c2 e5			ld hl, os_word_scratch+2 
5330 cd fe 0f			call hexout 
5333 21 c4 e5			ld hl, os_word_scratch+4 
5336 3e 00			ld a,0 
5338 77				ld (hl),a 
5339 11 c0 e5			ld de,os_word_scratch 
533c 3e 28				ld a, display_row_2 
533e cd db 0b				call str_at_display 
5341 11 69 52			ld de, .push_malloc 
5344 3e 00			ld a, display_row_1 
5346			 
5346 cd db 0b				call str_at_display 
5349			 
5349				; display current data stack pointer 
5349 11 2f 52			ld de,.data_sp 
534c 3e 30				ld a, display_row_2 + 8 
534e cd db 0b				call str_at_display 
5351			 
5351 2a e8 e9			ld hl,(cli_data_sp) 
5354 e5				push hl 
5355 7c				ld a,h 
5356 21 c0 e5			ld hl, os_word_scratch 
5359 cd fe 0f			call hexout 
535c e1				pop hl 
535d 7d				ld a,l 
535e 21 c2 e5			ld hl, os_word_scratch+2 
5361 cd fe 0f			call hexout 
5364 21 c4 e5			ld hl, os_word_scratch+4 
5367 3e 00			ld a,0 
5369 77				ld (hl),a 
536a 11 c0 e5			ld de,os_word_scratch 
536d 3e 33				ld a, display_row_2 + 11 
536f cd db 0b				call str_at_display 
5372			 
5372 cd eb 0b			call update_display 
5375 cd 00 0b			call delay1s 
5378 cd 00 0b			call delay1s 
537b e1				pop hl 
537c f1				pop af 
537d c9				ret 
537e			;endif 
537e			 
537e			include "forth_autostart.asm" 
537e			; list of commands to perform at system start up 
537e			 
537e			startcmds: 
537e			;	dw test11 
537e			;	dw test12 
537e			;	dw test13 
537e			;	dw test14 
537e			;	dw test15 
537e			;	dw test16 
537e			;	dw test17 
537e			;	dw ifthtest1 
537e			;	dw ifthtest2 
537e			;	dw ifthtest3 
537e			;	dw mmtest1 
537e			;	dw mmtest2 
537e			;	dw mmtest3 
537e			;	dw mmtest4 
537e			;	dw mmtest5 
537e			;	dw mmtest6 
537e			;	dw iftest1 
537e			;	dw iftest2 
537e			;	dw iftest3 
537e			;	dw looptest1 
537e			;	dw looptest2 
537e			;	dw test1 
537e			;	dw test2 
537e			;	dw test3 
537e			;	dw test4 
537e			;	dw game2r 
537e			;	dw game2b1 
537e			;	dw game2b2 
537e			 
537e				; start up words that are actually useful 
537e			 
537e			;    dw spi1 
537e			;    dw spi2 
537e			;    dw spi3 
537e			;    dw spi4 
537e			;    dw spi5 
537e			;    dw spi6 
537e			;    dw spi7 
537e			; 
537e			;    dw spi8 
537e			;    dw spi9 
537e			;    dw spi10 
537e			 
537e			; file editor 
537e			;	dw edit1 
537e			;	dw edit2 
537e			;	dw edit3 
537e			 
537e			;	dw longread 
537e a0 57			dw clrstack 
5380 d4 57			dw type 
5382			;	dw stest 
5382 f9 57			dw strncpy 
5384 69 59			dw list 
5386 5a 58			dw start1 
5388 6a 58			dw start2 
538a			;	dw start3 
538a			;	dw start3b 
538a			;	dw start3c 
538a			 
538a				; (unit) testing words 
538a			 
538a			;	dw mtesta 
538a			;	dw mtestb 
538a			;	dw mtestc 
538a			;	dw mtestd 
538a			;	dw mteste 
538a			 
538a				; demo/game words 
538a			 
538a			;        dw game3w 
538a			;        dw game3p 
538a			;        dw game3sc 
538a			;        dw game3vsi 
538a			;        dw game3vs 
538a				 
538a			;	dw game2b 
538a			;	dw game2bf 
538a			;	dw game2mba 
538a			;	dw game2mbas 
538a			;	dw game2mb 
538a			 
538a 9a 5b			dw game1 
538c ab 5b			dw game1a 
538e 0d 5c			dw game1b 
5390 42 5c			dw game1c 
5392 78 5c			dw game1d 
5394 a9 5c			dw game1s 
5396 bd 5c			dw game1t 
5398 d2 5c			dw game1f 
539a 06 5d			dw game1z 
539c 4a 5d			dw game1zz 
539e			 
539e d3 59			dw test5 
53a0 0b 5a			dw test6 
53a2 43 5a			dw test7 
53a4 57 5a			dw test8 
53a6 83 5a			dw test9 
53a8 99 5a			dw test10 
53aa				 
53aa 21 5e		        dw ssv5 
53ac 05 5e		        dw ssv4 
53ae e9 5d		        dw ssv3 
53b0 b3 5d		        dw ssv2 
53b2 3a 5e		        dw ssv1 
53b4 82 5e		        dw ssv1cpm 
53b6			;	dw keyup 
53b6			;	dw keydown 
53b6			;	dw keyleft 
53b6			;	dw keyright 
53b6			;	dw 	keyf1 
53b6			;	dw keyf2 
53b6			;	dw keyf3 
53b6			;	dw keyf4 
53b6			;	dw keyf5 
53b6			;	dw keyf6 
53b6			;	dw keyf7 
53b6			;	dw keyf8 
53b6			;	dw keyf9 
53b6			;	dw keyf10 
53b6			;	dw keyf11 
53b6			;	dw keyf12 
53b6			;	dw keytab 
53b6			;	dw keycr 
53b6			;	dw keyhome 
53b6			;	dw keyend 
53b6			;	dw keybs 
53b6 00 00			db 0, 0	 
53b8			 
53b8			 
53b8			; File Editor 
53b8			 
53b8			; ( id - ) use 'e' to edit the displayed line 
53b8 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
53d9 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
540e			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
540e .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5446			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5446			 
5446			; SPI Net support words 
5446			 
5446			; v0! = node to send to 
5446			; ( str count - ) 
5446 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
549f			 
549f			; spiputc ( char node - ) 
549f .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
54d3			; spiputc ( u node - ) 
54d3 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
5501			 
5501			; spigetc ( - n ) 
5501 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
552a			 
552a			; getnode ( - n ) 
552a .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5557			 
5557			; ( str node - )  
5557 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
55bd			; store string ( str i - ) 
55bd			 
55bd			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
55bd .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5612			 
5612			; get string ( addr i -  )    TO FIX 
5612			 
5612 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
566a			 
566a			 
566a			; NETCHAT (TODO) 
566a			; Program to allow two nodes to chat with eachother 
566a			; 
566a			; v0 - target node 
566a			;  
566a			; accept input at 0,0 
566a			; if input is string send spitype to target node 
566a			; starting at row 2,0 , while spigetchr is not zero ->  
566a			; 
566a			; 
566a			; TODO add paging of get request 
566a			 
566a			; ( node - ) 
566a .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5689 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
56e1 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5759			 
5759			 
5759			; Long read of currently open file 
5759 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
57a0			 
57a0			; clear stack  
57a0			 
57a0 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
57d4			 
57d4			; type ( addr count - ) 
57d4 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
57f9			 
57f9			; some direct memory words 
57f9			; strncpy ( len t f -- t ) 
57f9			 
57f9 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
585a			 
585a .. 00		start1:     	db ": bpon $00 bp ;",0 
586a .. 00		start2:     	db ": bpoff $01 bp ;",0 
587b .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
58f6 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5956			 
5956 .. 00		tuck:         db ": tuck swap over ;", 0 
5969			 
5969			; a handy word to list items on the stack 
5969			 
5969 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
59d3			 
59d3			 
59d3			; test stack  
59d3			; rnd8 stest 
59d3			 
59d3			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
59d3			 
59d3			; random malloc and free cycles 
59d3			 
59d3			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
59d3			 
59d3			; fixed malloc and free cycles 
59d3			 
59d3			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
59d3			 
59d3			; fixed double string push and drop cycle  
59d3			 
59d3			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
59d3			 
59d3			; consistent fixed string push and drop cycle  
59d3			 
59d3			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
59d3			 
59d3			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
59d3			 
59d3			;test1:		db ": aa 1 2 3 ;", 0 
59d3			;test2:     	db "111 aa 888 999",0 
59d3			;test3:     	db ": bb 77 ;",0 
59d3			;test4:     	db "$02 $01 do i . loop bb",0 
59d3			 
59d3 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5a0b .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5a43 .. 00		test7:     	db ": box hline vline ;",0 
5a57 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a83 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a99 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5abe			;test11:     	db "hello create .",0 
5abe			;test12:     	db "hello2 create .",0 
5abe			 
5abe			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5abe			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5abe			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5abe			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5abe			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5abe			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5abe			 
5abe			;iftest1:     	db "$0001 IF cls .",0 
5abe			;iftest2:     	db "$0000 IF cls .",0 
5abe			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5abe			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5abe			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5abe			 
5abe			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5abe			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5abe			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5abe			 
5abe			 
5abe .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5ae2 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5b12 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5b37 .. 00		sound4: db ": cha $00 ; ",0 
5b44 .. 00		sound5: db ": chb $20 ; ",0 
5b51 .. 00		sound6: db ": chc $40 ; ",0 
5b5e .. 00		sound7: db ": chd $60 ; ",0 
5b6b .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5b83 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5b9a			 
5b9a			 
5b9a			 
5b9a			 
5b9a			; a small guess the number game 
5b9a			 
5b9a .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5bab .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5c0d			 
5c0d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5c42 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5c78 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5ca9 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5cbd .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5cd2 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5d06 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5d4a			 
5d4a			; Using 'ga' save a high score across multiple runs using external storage 
5d4a			 
5d4a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5db3			 
5db3			 
5db3			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5db3			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5db3			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5db3			 
5db3			; simple screen saver to test code memory reuse to destruction 
5db3			 
5db3 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5de9 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5e05 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5e21 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5e3a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5e82 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5ed9			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5ed9			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5ed9			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5ed9			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5ed9			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5ed9			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5ed9			 
5ed9			 
5ed9			 
5ed9			; minesweeper/battleship finding game 
5ed9			; draws a game board of random ship/mine positions 
5ed9			; user enters coords to see if it hits on 
5ed9			; game ends when all are hit 
5ed9			; when hit or miss says how many may be in the area 
5ed9			 
5ed9			; setup the game board and then hide it 
5ed9			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5ed9			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5ed9			;; prompt for where to target 
5ed9			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ed9			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ed9			;; TODO see if the entered coords hits or misses pushes char hit of miss 
5ed9			;game2mbht:      db ": mbckht nop ;",0 
5ed9			;game2mbms:      db ": mbcms nop ;",0 
5ed9			; TODO how many might be near by 
5ed9			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5ed9			 
5ed9			; Game 3 
5ed9			 
5ed9			; Vert scroller ski game - avoid the trees! 
5ed9			 
5ed9			; v0 score (ie turns) 
5ed9			; v1 player pos 
5ed9			; v2 left wall 
5ed9			; v3 right wall 
5ed9			 
5ed9			; Draw side walls randomly 
5ed9			 
5ed9			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5ed9			 
5ed9			; Draw player 
5ed9			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5ed9			 
5ed9			; TODO Get Key 
5ed9			 
5ed9			; TODO Move left right 
5ed9			 
5ed9			; scroll and move walls a bit 
5ed9			 
5ed9			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ed9			 
5ed9			; main game loop 
5ed9			 
5ed9			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5ed9			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5ed9			 
5ed9			; key board defs 
5ed9			 
5ed9 .. 00		keyup:       db ": keyup $05 ;",0 
5ee7 .. 00		keydown:       db ": keydown $0a ;",0 
5ef7 .. 00		keyleft:       db ": keyleft $0b ;",0 
5f07 .. 00		keyright:       db ": keyright $0c ;",0 
5f18 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5f26 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5f34 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5f42 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5f50 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5f5e .. 00		keyf6:       db ": keyf6 $15 ;",0 
5f6c .. 00		keyf7:       db ": keyf7 $16 ;",0 
5f7a .. 00		keyf8:       db ": keyf8 $17 ;",0 
5f88 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5f96 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5fa5 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5fb4 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5fc3			 
5fc3 .. 00		keytab:       db ": keytab $09 ;",0 
5fd2 .. 00		keycr:       db ": keycr $0d ;",0 
5fe0 .. 00		keyhome:       db ": keyhome $0e ;",0 
5ff0 .. 00		keyend:       db ": keyend $0f ;",0 
5fff .. 00		keybs:       db ": keybs $08 ;",0 
600d			 
600d			   
600d			 
600d			 
600d			 
600d			; eof 
# End of file forth_autostart.asm
600d			 
600d			 
600d			 
600d			; stack over and underflow checks 
600d			 
600d			; init the words to detect the under/overflow 
600d			 
600d			chk_stk_init: 
600d				; a vague random number to check so we dont get any "lucky" hits 
600d 3e 2d			ld a, 45 
600f 6f				ld l, a 
6010 00				nop 
6011 3e 17			ld a, 23 
6013 67				ld h, a 
6014			 
6014 22 97 e2			ld (chk_word), hl     ; the word we need to check against 
6017			 
6017			;	ld (chk_stund), hl	; stack points.... 
6017 22 00 ef			ld (chk_stovr), hl 
601a 22 e6 e9			ld (chk_ret_und), hl 
601d 22 a4 e9			ld (chk_ret_ovr), hl 
6020 22 22 e9			ld (chk_loop_ovr), hl 
6023 22 20 e8			ld (chk_data_ovr), hl 
6026 c9				ret 
6027				 
6027			check_stacks: 
6027				; check all stack words 
6027			 
6027 e5				push hl 
6028 d5				push de 
6029			 
6029			;	ld de,(chk_word) 
6029			;	ld hl, (chk_stund)	; stack points.... 
6029			;	if DEBUG_STK_FAULT 
6029			;		DMARK "FAa" 
6029			;		CALLMONITOR 
6029			;	endif 
6029			;	call cmp16 
6029			;	jp z, .chk_faulta 
6029			; 
6029			;	ld de, sfaultsu 
6029			;	jp .chk_fault 
6029			 
6029 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
602c ed 5b 97 e2		ld de,(chk_word) 
6030				if DEBUG_STK_FAULT 
6030					DMARK "FAb" 
6030					CALLMONITOR 
6030				endif 
6030 cd 13 0e			call cmp16 
6033 28 06			jr z, .chk_fault1 
6035 11 d9 60			ld de, sfaultso 
6038 c3 8a 60			jp .chk_fault 
603b			.chk_fault1:  
603b 2a e6 e9			ld hl, (chk_ret_und) 
603e ed 5b 97 e2		ld de,(chk_word) 
6042				if DEBUG_STK_FAULT 
6042					DMARK "FAU" 
6042					CALLMONITOR 
6042				endif 
6042 cd 13 0e			call cmp16 
6045 ca 4e 60			jp z, .chk_fault2 
6048 11 e9 60			ld de, sfaultru 
604b c3 8a 60			jp .chk_fault 
604e			.chk_fault2:  
604e 2a a4 e9			ld hl, (chk_ret_ovr) 
6051 ed 5b 97 e2		ld de,(chk_word) 
6055				if DEBUG_STK_FAULT 
6055					DMARK "FA1" 
6055					CALLMONITOR 
6055				endif 
6055 cd 13 0e			call cmp16 
6058 ca 61 60			jp z, .chk_fault3 
605b 11 f7 60			ld de, sfaultro 
605e c3 8a 60			jp .chk_fault 
6061			.chk_fault3:  
6061 2a 22 e9			ld hl, (chk_loop_ovr) 
6064 ed 5b 97 e2		ld de,(chk_word) 
6068				if DEBUG_STK_FAULT 
6068					DMARK "FA2" 
6068					CALLMONITOR 
6068				endif 
6068 cd 13 0e			call cmp16 
606b ca 74 60			jp z, .chk_fault4 
606e 11 11 61			ld de, sfaultlo 
6071 c3 8a 60			jp .chk_fault 
6074			.chk_fault4:  
6074 2a 20 e8			ld hl, (chk_data_ovr) 
6077 ed 5b 97 e2		ld de,(chk_word) 
607b				if DEBUG_STK_FAULT 
607b					DMARK "FA3" 
607b					CALLMONITOR 
607b				endif 
607b cd 13 0e			call cmp16 
607e ca 87 60			jp z, .chk_fault5 
6081 11 2b 61			ld de, sfaultdo 
6084 c3 8a 60			jp .chk_fault 
6087			 
6087			 
6087			.chk_fault5:  
6087 d1				pop de 
6088 e1				pop hl 
6089			 
6089 c9				ret 
608a			 
608a cd c8 0b		.chk_fault: 	call clear_display 
608d 3e 28				ld a, display_row_2 
608f cd db 0b				call str_at_display 
6092 11 bb 60				   ld de, .stackfault 
6095 3e 00				ld a, display_row_1 
6097 cd db 0b				call str_at_display 
609a 11 65 ee				    ld de, debug_mark 
609d 3e 11				ld a, display_row_1+17 
609f cd db 0b				call str_at_display 
60a2 cd eb 0b				call update_display 
60a5			 
60a5				; prompt before entering montior for investigating issue 
60a5			 
60a5 3e 78			ld a, display_row_4 
60a7 11 6e 18			ld de, endprog 
60aa			 
60aa cd eb 0b			call update_display		 
60ad			 
60ad cd 08 1b			call next_page_prompt 
60b0			 
60b0 d1				pop de 
60b1 e1				pop hl 
60b2 cd c2 18				call monitor 
60b5 cd 26 1f				call forth_warmstart 
60b8 c3 be 17				jp warmstart_afterauto 
60bb					;jp 0 
60bb					;halt 
60bb			 
60bb			 
60bb			 
60bb .. 00		.stackfault: 	db "Stack fault:",0 
60c8			 
60c8 .. 00		sfaultsu: 	db	"Stack under flow",0 
60d9 .. 00		sfaultso: 	db	"Stack over flow",0 
60e9 .. 00		sfaultru:	db "RTS underflow",0 
60f7 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6111 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
612b .. 00		sfaultdo:	db "DTS overflow", 0 
6138			 
6138			 
6138			fault_dsp_under: 
6138 11 4a 61			ld de, .dsp_under 
613b c3 00 62			jp .show_fault 
613e			 
613e			fault_rsp_under: 
613e 11 58 61			ld de, .rsp_under 
6141 c3 00 62			jp .show_fault 
6144			fault_loop_under: 
6144 11 66 61			ld de, .loop_under 
6147 c3 00 62			jp .show_fault 
614a			 
614a .. 00		.dsp_under: db "DSP Underflow",0 
6158 .. 00		.rsp_under: db "RSP Underflow",0 
6166 .. 00		.loop_under: db "LOOP Underflow",0 
6175			 
6175			 
6175 d5			type_faultn: 	push de 
6176 e5					push hl 
6177 cd c8 0b				call clear_display 
617a 11 a4 61				   ld de, .typefaultn 
617d 3e 00				ld a, display_row_1 
617f cd db 0b				call str_at_display 
6182 11 65 ee				    ld de, debug_mark 
6185 3e 11				ld a, display_row_1+17 
6187 cd db 0b				call str_at_display 
618a cd eb 0b				call update_display 
618d			 
618d				; prompt before entering montior for investigating issue 
618d			 
618d 3e 78			ld a, display_row_4 
618f 11 6e 18			ld de, endprog 
6192			 
6192 cd eb 0b			call update_display		 
6195			 
6195 cd 08 1b			call next_page_prompt 
6198			 
6198 e5					push hl 
6199 d5					push de 
619a cd c2 18				call monitor 
619d cd 26 1f				call forth_warmstart 
61a0 c3 be 17				jp warmstart_afterauto 
61a3 76					halt 
61a4			 
61a4			 
61a4 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
61bb			 
61bb d5			type_faults: 	push de 
61bc e5					push hl 
61bd cd c8 0b				call clear_display 
61c0 11 e9 61				   ld de, .typefaults 
61c3 3e 00				ld a, display_row_1 
61c5 cd db 0b				call str_at_display 
61c8 11 65 ee				    ld de, debug_mark 
61cb 3e 11				ld a, display_row_1+17 
61cd cd db 0b				call str_at_display 
61d0 cd eb 0b				call update_display 
61d3			 
61d3				; prompt before entering montior for investigating issue 
61d3			 
61d3 3e 78			ld a, display_row_4 
61d5 11 6e 18			ld de, endprog 
61d8			 
61d8 cd eb 0b			call update_display		 
61db			 
61db cd 08 1b			call next_page_prompt 
61de			 
61de e1					pop hl 
61df d1					pop de 
61e0 cd c2 18				call monitor 
61e3 cd 26 1f				call forth_warmstart 
61e6 c3 be 17				jp warmstart_afterauto 
61e9			 
61e9			 
61e9 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6200			 
6200			.show_fault: 	 
6200 d5					push de 
6201 cd c8 0b				call clear_display 
6204 d1					pop de 
6205 3e 00				ld a, display_row_1 
6207 cd db 0b				call str_at_display 
620a 11 65 ee				    ld de, debug_mark 
620d 3e 11				ld a, display_row_1+17 
620f cd db 0b				call str_at_display 
6212 cd eb 0b				call update_display 
6215			 
6215				; prompt before entering montior for investigating issue 
6215			 
6215 3e 78			ld a, display_row_4 
6217 11 6e 18			ld de, endprog 
621a			 
621a cd eb 0b			call update_display		 
621d			 
621d cd 08 1b			call next_page_prompt 
6220			 
6220 e1					pop hl 
6221 d1					pop de 
6222 cd c2 18				call monitor 
6225			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6225			; TODO Make optional fault restart to cli or warm boot? 
6225					;jp warmstart 
6225 c3 02 18				jp cli 
6228 76					halt 
6229			 
6229			 
6229			; handle the auto run of code from files in storage 
6229			 
6229			 
6229			include "forth_startup.asm" 
6229			; Which startup method to use? 
6229			; 
6229			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6229			; followed by loading of a list of scripts in eeprom 
6229			 
6229			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6229			; from eeprom 
6229			 
6229			; Select with define in main stubs 
6229			 
6229			if STARTUP_V1 
6229				include "forth_startupv1.asm" 
6229			; Startup script loading version 1 
6229			 
6229			; If SE storage is available first stage is to use the selected file 
6229			; then go through the eeprom list 
6229			 
6229 .. 00		sprompt1: db "Startup load...",0 
6239 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
624f			 
624f			 
624f			 
624f			 
624f			forth_startup: 
624f 21 7e 53			ld hl, startcmds 
6252 3e 00			ld a, 0 
6254 32 e1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6257			 
6257 e5			.start1:	push hl 
6258 cd c8 0b			call clear_display 
625b 11 29 62			ld de, sprompt1 
625e 3e 00		        ld a, display_row_1 
6260 cd db 0b			call str_at_display 
6263 11 39 62			ld de, sprompt2 
6266 3e 28		        ld a, display_row_2 
6268 cd db 0b			call str_at_display 
626b e1				pop hl 
626c e5				push hl 
626d 5e				ld e,(hl) 
626e 23				inc hl 
626f 56				ld d,(hl) 
6270 3e 50		        ld a, display_row_3 
6272 cd db 0b			call str_at_display 
6275 cd eb 0b			call update_display 
6278			 
6278			 
6278 3a e1 e6			ld a, (os_last_cmd) 
627b fe 00			cp 0 
627d 28 05			jr z, .startprompt 
627f cd f4 0a			call delay250ms 
6282 18 24			jr .startdo 
6284				 
6284				 
6284			 
6284			.startprompt: 
6284			 
6284 3e 9f			ld a,display_row_4 + display_cols - 1 
6286 11 06 1b		        ld de, endprg 
6289 cd db 0b			call str_at_display 
628c cd eb 0b			call update_display 
628f cd 00 0b			call delay1s 
6292 cd 01 64			call cin_wait 
6295						 
6295 fe 2a			cp '*' 
6297 28 5e			jr z, .startupend1 
6299 fe 23			cp '#' 
629b 20 07			jr nz, .startno 
629d 3e 01			ld a, 1 
629f 32 e1 e6			ld (os_last_cmd),a 
62a2 18 04			jr .startdo 
62a4 fe 31		.startno:	cp '1' 
62a6 28 3a			jr z,.startnxt  
62a8			 
62a8				; exec startup line 
62a8			.startdo:	 
62a8 e1				pop hl 
62a9 e5				push hl 
62aa				 
62aa 5e				ld e,(hl) 
62ab 23				inc hl 
62ac 56				ld d,(hl) 
62ad eb				ex de,hl 
62ae			 
62ae e5				push hl 
62af			 
62af 3e 00			ld a, 0 
62b1				;ld a, FORTH_END_BUFFER 
62b1 cd 66 11			call strlent 
62b4 23				inc hl   ; include zero term to copy 
62b5 06 00			ld b,0 
62b7 4d				ld c,l 
62b8 e1				pop hl 
62b9 11 bb e2			ld de, scratch 
62bc ed b0			ldir 
62be			 
62be			 
62be 21 bb e2			ld hl, scratch 
62c1 cd ca 1f			call forthparse 
62c4 cd 06 20			call forthexec 
62c7 cd 20 1f			call forthexec_cleanup 
62ca			 
62ca 3e 78			ld a, display_row_4 
62cc 11 6e 18			ld de, endprog 
62cf			 
62cf cd eb 0b			call update_display		 
62d2			 
62d2 3a e1 e6			ld a, (os_last_cmd) 
62d5 fe 00			cp 0 
62d7 20 09			jr nz, .startnxt 
62d9 cd 08 1b			call next_page_prompt 
62dc cd c8 0b		        call clear_display 
62df cd eb 0b			call update_display		 
62e2			 
62e2				; move onto next startup line? 
62e2			.startnxt: 
62e2			 
62e2 cd f4 0a			call delay250ms 
62e5 e1				pop hl 
62e6			 
62e6 23				inc hl 
62e7 23				inc hl 
62e8			 
62e8 e5				push hl 
62e9 5e				ld e, (hl) 
62ea 23				inc hl 
62eb 56				ld d, (hl) 
62ec e1				pop hl 
62ed				; TODO replace 0 test 
62ed			 
62ed eb				ex de, hl 
62ee cd 1e 0e			call ishlzero 
62f1			;	ld a,e 
62f1			;	add d 
62f1			;	cp 0    ; any left to do? 
62f1 eb				ex de, hl 
62f2 c2 57 62			jp nz, .start1 
62f5 18 01			jr .startupend 
62f7			 
62f7 e1			.startupend1: pop hl 
62f8			.startupend: 
62f8			 
62f8 cd c8 0b			call clear_display 
62fb cd eb 0b			call update_display 
62fe c9				ret 
62ff			if STORAGE_SE 
62ff			 
62ff			sprompt3: db "Loading from start-up file?:",0 
62ff			sprompt4: db "(Y=Any key/N=No)",0 
62ff			 
62ff			 
62ff			forth_autoload: 
62ff			 
62ff				; load block 0 of store 1 
62ff				 
62ff				ld a, $fe      ; bit 0 clear 
62ff				ld (spi_device), a 
62ff			 
62ff				call storage_get_block_0 
62ff			 
62ff				ld a, (store_page+STORE_0_AUTOFILE) 
62ff			 
62ff				cp 0 
62ff				ret z     ; auto start not enabled 
62ff			 
62ff				call clear_display 
62ff			 
62ff				; set bank 
62ff			 
62ff					ld a, (store_page+STORE_0_BANKRUN) 
62ff					ld (spi_device), a 
62ff			 
62ff				; get file id to load from and get the file name to display 
62ff			 
62ff					ld a, (store_page+STORE_0_FILERUN) 
62ff			 
62ff					ld l, 0 
62ff					ld h, a 
62ff					ld de, store_page 
62ff			 
62ff					if DEBUG_FORTH_WORDS 
62ff						DMARK "ASp" 
62ff						CALLMONITOR 
62ff					endif 
62ff					call storage_read 
62ff			 
62ff					if DEBUG_FORTH_WORDS 
62ff						DMARK "ASr" 
62ff						CALLMONITOR 
62ff					endif 
62ff			 
62ff					call ishlzero 
62ff					ret z             ; file not found 
62ff			 
62ff					ld a, display_row_2 + 10 
62ff					ld de, store_page+3 
62ff					call str_at_display 
62ff				 
62ff			; 
62ff			 
62ff				ld a, display_row_1+5 
62ff				ld de, sprompt3 
62ff				call str_at_display 
62ff				ld a, display_row_3+15 
62ff				ld de, sprompt4 
62ff				call str_at_display 
62ff			 
62ff				call update_display 
62ff			 
62ff				call cin_wait 
62ff				cp 'n' 
62ff				ret z 
62ff				cp 'N' 
62ff				ret z 
62ff			 
62ff				call delay1s 
62ff			 
62ff				ld a, (store_page+2) 
62ff				ld (store_openmaxext), a    ; save count of ext 
62ff				ld a, 1  
62ff				ld (store_openext), a    ; save count of ext 
62ff			 
62ff			.autof:  
62ff				ld l , a 
62ff				 
62ff				ld a, (store_page) 
62ff				ld h, a	 
62ff				ld de, store_page 
62ff					if DEBUG_FORTH_WORDS 
62ff						DMARK "ASl" 
62ff						CALLMONITOR 
62ff					endif 
62ff					call storage_read 
62ff				call ishlzero 
62ff				ret z 
62ff			;	jr z, .autoend 
62ff			 
62ff					if DEBUG_FORTH_WORDS 
62ff						DMARK "ASc" 
62ff						CALLMONITOR 
62ff					endif 
62ff				ld de, store_page+2 
62ff				ld a, display_row_4 
62ff				call str_at_display 
62ff			 
62ff				call update_display 
62ff				call delay250ms 
62ff			 
62ff			 
62ff			 
62ff				ld hl, store_page+2 
62ff				call forthparse 
62ff				call forthexec 
62ff				call forthexec_cleanup 
62ff			 
62ff				 
62ff				ld a, (store_openext) 
62ff				inc a 
62ff				ld (store_openext), a    ; save count of ext 
62ff			 
62ff				jr .autof 
62ff			;.autofdone: 
62ff			; 
62ff			;		if DEBUG_FORTH_WORDS 
62ff			;			DMARK "ASx" 
62ff			;			CALLMONITOR 
62ff			;		endif 
62ff			;;	call clear_display 
62ff			;	ret 
62ff			 
62ff			 
62ff			 
62ff			endif 
# End of file forth_startupv1.asm
62ff			endif 
62ff			if STARTUP_V2 
62ff				include "forth_startupv2.asm" 
62ff			endif 
62ff			 
# End of file forth_startup.asm
62ff			 
62ff			; eof 
# End of file forth_kernel.asm
62ff			;include "nascombasic.asm" 
62ff			 
62ff			 
62ff			; find out where the code ends if loaded into RAM (for SC114) 
62ff			;endofcode:  
62ff			;	nop 
62ff			 
62ff			 
62ff			; jump to nmi vector 
62ff			 
62ff			init_nmi: 
62ff 3e c9			ld a, $c9   ; RET 
6301 32 72 ee			ld (nmi_vector), a 
6304 c9				ret 
6305			nmi: 
6305 e5				push hl 
6306 d5				push de 
6307 c5				push bc 
6308 f5				push af 
6309 cd 72 ee			call nmi_vector 
630c f5				push af 
630d c5				push bc 
630e d5				push de 
630f e5				push hl 
6310 ed 4d			reti 
6312			 
6312			 
6312			; eof 
6312			 
# End of file main.asm
6312			;include "firmware_lcd_4x40.asm" 
6312			;;include "firmware_lcd_4x20.asm" 
6312			include "firmware_cpm_display.asm" 
6312			 
6312			; Serial display interface for SC114 
6312			 
6312			 
6312			display_row_1: equ 0 
6312			display_row_2: equ display_row_1+display_cols 
6312			display_row_3: equ display_row_2 + display_cols 
6312			display_row_4: equ display_row_3 + display_cols 
6312			 
6312			kLCDWidth:  EQU display_cols             ;Width in characters 
6312			kLCD_Line1: EQU 0x00  
6312			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6312			; E1 
6312			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6312			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6312			 
6312			lcd_init: 
6312				; no init as handled by the SCM bios 
6312 c9				ret 
6313			 
6313			 
6313			; low level functions for direct screen writes 
6313			 
6313			; output char at pos? 
6313			fLCD_Str: 
6313			        ;out (SC114_SIO_1_OUT),a 
6313 c5				push bc 
6314 d5				push de 
6315 5f				ld e, a 
6316			; TODO Replace with CP/M BIOS call 
6316 0e 02			ld c, $02 
6318 cd 05 00			call 5 
631b d1				pop de 
631c c1				pop bc 
631d c9				ret 
631e			 
631e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
631e			fLCD_Pos: 
631e				; use ASCII escape to position 
631e			        ;out (SC114_SIO_1_OUT),a 
631e c5				push bc 
631f d5				push de 
6320 5f				ld e, a 
6321 0e 02			ld c, $02 
6323			; TODO Replace with CP/M BIOS call 
6323 cd 05 00			call 5 
6326 d1				pop de 
6327 c1				pop bc 
6328			 
6328 c9				ret 
6329			 
6329			; output char at pos 
6329			fLCD_Data: 
6329			      ;  out (SC114_SIO_1_OUT),a 
6329 c5				push bc 
632a d5				push de 
632b 0e 02			ld c, $02 
632d 5f				ld e, a 
632e			; TODO Replace with CP/M BIOS call 
632e cd 05 00			call 5 
6331 d1				pop de 
6332 c1				pop bc 
6333			 
6333 c9				ret 
6334			 
6334			; ascii cls  
6334			 
6334 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
6338			 
6338 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
634f			;.clscpm: db 3, $3c,"$" 
634f			 
634f			; write the frame buffer given in hl to hardware  
634f			write_display: 
634f			 
634f			API: equ 0 
634f			 
634f			if API 
634f				push bc 
634f				ld b, 4 
634f			 
634f			        ld (display_write_tmp), hl 	  
634f			 
634f				; clear and home cursor 
634f			 
634f				ld c, 9 
634f				ld de, .cls 
634f			; TODO Replace with CP/M BIOS call 
634f				call 5 
634f			 
634f			 
634f			.writeln: 
634f			 
634f				ld de, (display_write_tmp) 
634f				ld c, 6 
634f			; TODO Replace with CP/M BIOS call 
634f				rst $30 
634f				ld c, 7 
634f				rst $30 
634f			 
634f				ld hl, (display_write_tmp) 
634f				ld de, display_cols 
634f				add hl,de 
634f				ld (display_write_tmp),hl 
634f			 
634f				djnz  .writeln 
634f			 
634f				pop bc 
634f			 
634f			 
634f				ret 
634f			endif 
634f e5				push hl 
6350 c5				push bc 
6351 d5				push de 
6352			 
6352			;	ld c, 2 
6352			;	;ld de, .cls 
6352			;	ld a, 27 
6352			;	rst $30 
6352			;	ld c, 2 
6352			;	;ld de, .cls 
6352			;	ld a, '[' 
6352			;	rst $30 
6352			; 
6352			;	ld c, 2 
6352			;	;ld de, .cls 
6352			;	ld a, 'H' 
6352			;	rst $30 
6352			; 
6352			 
6352			 
6352			; lots of CR/LF 
6352			;	ld c, 9 
6352			;	ld de, .clscpm 
6352			;	call 5 
6352			 
6352			; xterm cls 
6352 0e 02			ld c, 2 
6354 1e 1b			ld e, 27 
6356 cd 05 00			call 5 
6359			; cls causes too much flicker 
6359			;	ld c, 2 
6359			;	ld e, 'c' 
6359			;	call 5 
6359			 
6359			; use xterm home instead 
6359 0e 02			ld c, 2 
635b 1e 5b			ld e, '[' 
635d cd 05 00			call 5 
6360 0e 02			ld c, 2 
6362 1e 48			ld e, 'H' 
6364 cd 05 00			call 5 
6367			LLL: equ 0 
6367			 
6367			if LLL 
6367			 
6367				ld c, 2 
6367				;ld de, .cls 
6367				ld e, 27 
6367			; TODO Replace with CP/M BIOS call 
6367				call 5 
6367			 
6367			 
6367				ld c, 2 
6367				;ld de, .cls 
6367				ld e, '[' 
6367			; TODO Replace with CP/M BIOS call 
6367				call 5 
6367				ld c, 2 
6367				;ld de, .cls 
6367				ld e, '2' 
6367			; TODO Replace with CP/M BIOS call 
6367				call 5 
6367				ld c, 2 
6367				;ld de, .cls 
6367				ld e, 'J' 
6367			; TODO Replace with CP/M BIOS call 
6367				call 5 
6367			 
6367			endif 
6367			 
6367 d1				pop de 
6368 c1				pop bc 
6369 e1				pop hl 
636a			 
636a			 
636a 22 c3 eb		        ld (display_write_tmp), hl 	  
636d 3e 00			ld a, kLCD_Line1 
636f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
636f 06 28			ld b, display_cols 
6371 ed 5b c3 eb		ld de, (display_write_tmp) 
6375 cd f8 63			call write_len_string 
6378				 
6378			 
6378 e5			push hl 
6379 d5			push de 
637a c5			push bc 
637b 0e 02			ld c, 2 
637d 1e 0a			ld e, 10 
637f cd 05 00			call 5 
6382 0e 02			ld c, 2 
6384 1e 0d			ld e, 13 
6386 cd 05 00			call 5 
6389			; TODO Replace with CP/M BIOS call 
6389				;rst $30 
6389 c1			pop bc 
638a d1			pop de 
638b e1			pop hl 
638c			 
638c				 
638c 2a c3 eb			ld hl, (display_write_tmp) 
638f 11 28 00			ld de, display_cols 
6392 19				add hl,de 
6393 22 c3 eb			ld (display_write_tmp),hl 
6396			 
6396				 
6396 3e 28			ld a, kLCD_Line2 
6398			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6398 06 28			ld b, display_cols 
639a ed 5b c3 eb		ld de, (display_write_tmp) 
639e cd f8 63			call write_len_string 
63a1				 
63a1 2a c3 eb			ld hl, (display_write_tmp) 
63a4 11 28 00			ld de, display_cols 
63a7 19				add hl,de 
63a8 22 c3 eb			ld (display_write_tmp),hl 
63ab			 
63ab e5			push hl 
63ac d5			push de 
63ad c5			push bc 
63ae 0e 07			ld c, 7 
63b0			; TODO Replace with CP/M BIOS call 
63b0				;rst $30 
63b0 0e 02			ld c, 2 
63b2 1e 0a			ld e, 10 
63b4 cd 05 00			call 5 
63b7 0e 02			ld c, 2 
63b9 1e 0d			ld e, 13 
63bb cd 05 00			call 5 
63be c1			pop bc 
63bf d1			pop de 
63c0 e1			pop hl 
63c1			 
63c1				 
63c1 3e 50			ld a, kLCD_Line3 
63c3			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
63c3 06 28			ld b, display_cols 
63c5 ed 5b c3 eb		ld de, (display_write_tmp) 
63c9 cd f8 63			call write_len_string 
63cc				 
63cc 2a c3 eb			ld hl, (display_write_tmp) 
63cf 11 28 00			ld de, display_cols 
63d2 19				add hl,de 
63d3 22 c3 eb			ld (display_write_tmp),hl 
63d6			 
63d6 e5			push hl 
63d7 d5			push de 
63d8 c5			push bc 
63d9 0e 07			ld c, 7 
63db			; TODO Replace with CP/M BIOS call 
63db				;rst $30 
63db 0e 02			ld c, 2 
63dd 1e 0a			ld e, 10 
63df cd 05 00			call 5 
63e2 0e 02			ld c, 2 
63e4 1e 0d			ld e, 13 
63e6 cd 05 00			call 5 
63e9 c1			pop bc 
63ea d1			pop de 
63eb e1			pop hl 
63ec			 
63ec				 
63ec 3e 78			ld a, kLCD_Line4 
63ee			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
63ee 06 28			ld b, display_cols 
63f0 ed 5b c3 eb		ld de, (display_write_tmp) 
63f4 cd f8 63			call write_len_string 
63f7 c9					ret 
63f8			 
63f8			 
63f8				; write out a fixed length string given in b from de 
63f8			 
63f8 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
63f9 cd 29 63		            CALL fLCD_Data      ;Write character to display 
63fc 13				inc de 
63fd 10 f9			djnz write_len_string 
63ff c9				ret 
6400			 
6400			 
6400			; eof 
# End of file firmware_cpm_display.asm
6400			;include "firmware_key_5x10.asm" 
6400			;;include "firmware_key_4x10.asm" 
6400			include "firmware_key_cpm.asm" 
6400			; Serial keyboard interface for SC114 
6400			 
6400			 
6400			key_init: 
6400				; no init as handled by the SCM bios 
6400 c9				ret 
6401			 
6401			 
6401			cin_wait: 
6401			;	ld a, 0 
6401			;	ret 
6401			 
6401				;in a,(SC114_SIO_1_IN) 
6401			        ; Use SCM API to get from whatever console device we are using 
6401			 
6401			; TODO Replace with CP/M BIOS call 
6401 c5				push bc 
6402 0e 01			ld c, $01 
6404 cd 05 00			call 5 
6407 c1				pop bc 
6408 c9				ret 
6409			 
6409			cinndb:  
6409			cin: 
6409			 
6409			 
6409 c5				push bc 
640a			 
640a				; any key waiting to process? 
640a			; TODO Replace with CP/M BIOS call 
640a 0e 06			ld c, $06 
640c cd 05 00			call 5 
640f 28 0d			jr z, .cin_skip 
6411			 
6411				; yep, get it 
6411			 
6411 0e 01			ld c, $01 
6413			; TODO Replace with CP/M BIOS call 
6413 cd 05 00			call 5 
6416			 
6416 fe 7f			cp $7f     ; back space 
6418 20 02			jr nz, .skipbs 
641a 3e 08			ld a, KEY_BS 
641c			.skipbs: 
641c			 
641c c1				pop bc 
641d c9				ret 
641e			.cin_skip: 
641e 3e 00			ld a, 0 
6420 c1				pop bc 
6421 c9				ret 
6422			 
6422			 
6422			 
6422			 
# End of file firmware_key_cpm.asm
6422			endofcode:  
6422			baseram:  
6422 00				nop 
6423			 
6423			heap_start: equ baseram+15  ; Starting address of heap 
6423			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6423			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6423			;VDU:  EQU     endofcode           ; BASIC Work space 
6423			; eof 
6423			 
# End of file os_mega_cpm.asm
6423
