# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 1b 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openext: equ store_readcont - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd c7 0c				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd c7 0c				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd c7 0c				call clear_display  
0037			  
0037			  
0037 cd 61 69				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd aa 6a			call key_init  
003d cd b8 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 9e 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd ea 0c			call update_display  
0046 cd 44 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd cc 0c			call fill_display  
004e cd ea 0c			call update_display  
0051 cd 44 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd cc 0c			call fill_display  
0059 cd ea 0c			call update_display  
005c cd 44 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd cc 0c			call fill_display  
0064 cd ea 0c			call update_display  
0067 cd 44 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 4e 1a			ld de, prom_bootmsg  
006f cd da 0c			call str_at_display  
0072 cd ea 0c			call update_display  
0075			  
0075			  
0075 cd 44 0c			call delay1s  
0078 cd 44 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 63 1a			ld de, prom_bootmsg1  
0080 cd da 0c			call str_at_display  
0083 cd ea 0c			call update_display  
0086 cd 44 0c			call delay1s  
0089 cd 44 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			 
009d			; TODO store port id for spi device ie dev c 
009d			; TODO store pin for SO 
009d			; TODO store pin for SI 
009d			; TODO store pin for SCLK 
009d			 
009d			; 
009d			 
009d			; ensure that spi bus is in a stable state with default pins  
009d			 
009d			se_stable_spi:   
009d			 
009d				 ; set DI high, CE high , SCLK low 
009d				;ld a, SPI_DI | SPI_CE0 
009d 3e 07			ld a, SPI_DI  
009f cd 73 01			call spi_ce_high 
00a2 d3 80			 out (storage_adata),a 
00a4 32 f1 fb			ld (spi_portbyte),a 
00a7			 
00a7				if DEBUG_SPI 
00a7					push hl 
00a7					ld l, a 
00a7					DMARK "SPI" 
00a7					CALLMONITOR 
00a7					pop hl 
00a7				endif 
00a7 c9				ret 
00a8			 
00a8			; byte to send in a 
00a8			 
00a8			spi_send_byte: 
00a8				; save byte to send for bit mask shift out 
00a8 4f			        ld c,a 
00a9 3a f1 fb			ld a,(spi_portbyte) 
00ac				  
00ac				; clock out	each bit of the byte msb first 
00ac			 
00ac 06 08			ld b, 8 
00ae			.ssb1: 
00ae				; clear so bit  
00ae cb bf			res SPI_DI, a 
00b0 cb 11			rl c 
00b2				; if bit 7 is set then carry is set 
00b2 30 02			jr nc, .ssb2 
00b4 cb ff			set SPI_DI,a 
00b6			.ssb2:  ; output bit to ensure it is stable 
00b6 d3 80			out (storage_adata),a 
00b8 00				nop 
00b9				; clock bit high 
00b9 cb ef			set SPI_SCLK,a 
00bb d3 80			out (storage_adata),a 
00bd 00				nop 
00be				; then low 
00be cb af			res SPI_SCLK,a 
00c0 d3 80			out (storage_adata),a 
00c2 00				nop 
00c3 10 e9			djnz .ssb1 
00c5			 
00c5 32 f1 fb			ld (spi_portbyte),a 
00c8 c9				ret 
00c9			 
00c9			; TODO low level get byte into A on spi 
00c9			 
00c9			spi_read_byte:  
00c9			 
00c9				; save byte to send for bit mask shift out 
00c9 0e 00		    ld c,0 
00cb 3a f1 fb			ld a,(spi_portbyte) 
00ce				  
00ce				; clock out	each bit of the byte msb first 
00ce			 
00ce			 
00ce				; clock bit high 
00ce cb ef			set SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3			 
00d3			    ; read DO  
00d3			 
00d3 cb f9		    set 7,c 
00d5 db 80			in a,(storage_adata) 
00d7 cb 77		    bit SPI_DO,a 
00d9 20 02		    jr nz, .b7 
00db cb b9		    res 7,c 
00dd			.b7: 
00dd				; then low 
00dd cb af			res SPI_SCLK,a 
00df d3 80			out (storage_adata),a 
00e1 00				nop 
00e2			     
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f1		    set 6,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b6 
00ef cb b1		    res 6,c 
00f1			.b6: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb e9		    set 5,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b5 
0103 cb a9		    res 5,c 
0105			.b5: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			    ; read DO  
010f			 
010f cb e1		    set 4,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b4 
0117 cb a1		    res 4,c 
0119			.b4: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb d9		    set 3,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b3 
012b cb 99		    res 3,c 
012d			.b3: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d1		    set 2,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b2 
013f cb 91		    res 2,c 
0141			.b2: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb c9		    set 1,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b1 
0153 cb 89		    res 1,c 
0155			.b1: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c1		    set 0,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b0 
0167 cb 81		    res 0,c 
0169			.b0: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e			 
016e			 
016e 32 f1 fb			ld (spi_portbyte),a 
0171			 
0171			    ; return byte 
0171 79			    ld a,c 
0172			 
0172			 
0172 c9				ret 
0173			 
0173			 
0173			 
0173			spi_ce_high: 
0173			 
0173				if DEBUG_SPI_HARD_CE0 
0173			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0173					ret 
0173			 
0173				endif 
0173			 
0173			 
0173 f5				push af 
0174			 
0174				; send direct ce to port b 
0174 3e ff			ld a, 255 
0176 d3 81			out (storage_bdata), a 
0178			 
0178 f1				pop af 
0179			 
0179				; for port a that shares with spi lines AND the mask 
0179			  
0179				if DEBUG_SPI 
0179					push hl 
0179					ld h, a 
0179				endif 
0179			;	ld c, SPI_CE_HIGH 
0179			;	and c 
0179 cb c7			set SPI_CE0, a 
017b cb cf			set SPI_CE1, a 
017d cb d7			set SPI_CE2, a 
017f cb df			set SPI_CE3, a 
0181 cb e7			set SPI_CE4, a 
0183			 
0183				if DEBUG_SPI 
0183					ld l, a 
0183					DMARK "CEh" 
0183					CALLMONITOR 
0183					pop hl 
0183				endif 
0183 c9				ret 
0184			 
0184			 
0184			spi_ce_low: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184 c5				push bc 
0185 f5				push af 
0186			 
0186				; send direct ce to port b 
0186 3a f3 fb			ld a, (spi_cartdev) 
0189 d3 81			out (storage_bdata), a 
018b			 
018b			 
018b			 
018b				; for port a that shares with spi lines AND the mask 
018b			 
018b 3a f0 fb			ld a, (spi_device)  
018e 4f				ld c, a 
018f			 
018f f1				pop af 
0190			 
0190				; detect CEx 
0190			 
0190				if DEBUG_SPI 
0190					push hl 
0190					ld h, a 
0190				endif 
0190			 
0190 cb 41			bit SPI_CE0, c 
0192 20 04			jr nz, .cel1 
0194 cb 87			res SPI_CE0, a 
0196 18 1e			jr .celn 
0198			.cel1: 
0198 cb 49			bit SPI_CE1, c 
019a 20 04			jr nz, .cel2 
019c cb 8f			res SPI_CE1, a 
019e 18 16			jr .celn 
01a0			.cel2: 
01a0 cb 51			bit SPI_CE2, c 
01a2 20 04			jr nz, .cel3 
01a4 cb 97			res SPI_CE2, a 
01a6 18 0e			jr .celn 
01a8			.cel3: 
01a8 cb 59			bit SPI_CE3, c 
01aa 20 04			jr nz, .cel4 
01ac cb 9f			res SPI_CE3, a 
01ae 18 06			jr .celn 
01b0			.cel4: 
01b0 cb 61			bit SPI_CE4, c 
01b2 20 02			jr nz, .celn 
01b4 cb a7			res SPI_CE4, a 
01b6			.celn: 
01b6			 
01b6			 
01b6			 
01b6			;	add c 
01b6			 
01b6				if DEBUG_SPI 
01b6					ld l, a 
01b6					DMARK "CEl" 
01b6					CALLMONITOR 
01b6					pop hl 
01b6				endif 
01b6 c1				pop bc 
01b7 c9				ret 
01b8			 
01b8			 
01b8			 
01b8			; eof 
01b8			 
01b8			 
01b8			 
01b8			 
01b8			 
# End of file firmware_spi.asm
01b8				include "firmware_seeprom.asm"  
01b8			; 
01b8			; persisent storage interface via microchip serial eeprom 
01b8			 
01b8			; port a pio 2 
01b8			; pa 7 - si 
01b8			; pa 6 - sclk  
01b8			; pa 5 - so 
01b8			; pa 4 - cs 
01b8			; pa 3 - cs 
01b8			; pa 2 - cs 
01b8			; pa 1 - cs 
01b8			; pa 0 - cs 
01b8			; 
01b8			; TODO get block 
01b8			; TODO save block 
01b8			; TODO load file 
01b8			; TODO save file 
01b8			; TODO get dir  
01b8			 
01b8			;  
01b8			storage_adata: equ Device_C    ; device c port a - onboard storage 
01b8			storage_actl: equ Device_C+2     ; device c port a 
01b8			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01b8			storage_bctl: equ Device_C+3     ; device c port b 
01b8			 
01b8			 
01b8			; TODO move these to hardware driver file 
01b8			 
01b8			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01b8			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01b8			; storage bank file system format 
01b8			; 
01b8			; first page of bank: 
01b8			; 	addr 0 - status check 
01b8			;       addr 1 - write protect flag 
01b8			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01b8			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01b8			;         TODO see if scanning whole of for available next file id is fast enough 
01b8			;	addr 4 > zero term string of bank label 
01b8			; 
01b8			;        
01b8			;  
01b8			; first page of any file: 
01b8			;      byte 0 - file id  
01b8			;      byte 1-17 - fixed file name  
01b8			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01b8			; 
01b8			; other pages of any file: 
01b8			;      byte 0 - file id 
01b8			;      byte 1> - file data 
01b8			; 
01b8			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01b8			;  
01b8			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01b8			 
01b8			 
01b8			;storage_so_bit: 5 
01b8			;storage_si_bit: 7 
01b8			;storage_sclk_bit: 6 
01b8			  
01b8			 
01b8			; init storage pio 
01b8			 
01b8			storage_init: 
01b8			 
01b8 3e cf		            LD   A, 11001111b 
01ba d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bc 3e 00		            LD   A, 00000000b 
01be cb f7			set SPI_DO,a 
01c0			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c0 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c2			 
01c2 3e cf		            LD   A, 11001111b 
01c4 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c6 3e 00		            LD   A, 00000000b 
01c8 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01ca			 
01ca				; set all external spi devices off 
01ca 3e 00			ld a, 0 
01cc 32 f0 fb			ld (spi_device), a 
01cf 32 f3 fb			ld (spi_cartdev), a 
01d2			 
01d2					; ensure the spi bus is in a default stable state 
01d2 cd 9d 00				call se_stable_spi 
01d5			 
01d5			; TODO scan spi bus and gather which storage banks are present 
01d5			 
01d5			; populate store_bank_active  
01d5			; for each ce line activate and attempt to write first byte of bank and read back 
01d5			; if zero is returned then bank is empty 
01d5			;   
01d5			; 
01d5			 
01d5					; init file extent cache to save on slow reads 
01d5			 
01d5			;	ld hl, store_filecache 
01d5			;	ld de, 0 
01d5			;	ld hl,(de)	 
01d5			 
01d5			 
01d5 c9			    ret 
01d6			 
01d6			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d6			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d6			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d6			 
01d6			; INSTRUCTION SET 
01d6			; READ 0000 0011 Read data from memory array beginning at selected address 
01d6			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d6			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d6			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d6			; RDSR 0000 0101 Read STATUS register 
01d6			; WRSR 0000 0001 Write STATUS register 
01d6			; PE 0100 0010 Page Erase – erase one page in memory array 
01d6			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d6			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d6			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d6			 
01d6			; TODO send byte steam for page without setting the address for every single byte 
01d6			; TODO read byte  
01d6			 
01d6			; byte in a 
01d6			; address in hl  
01d6			se_writebyte: 
01d6			        
01d6			    ;   ld c, a 
01d6 f5			        push af 
01d7 e5			        push hl 
01d8			 
01d8			    ; initi write mode 
01d8			    ; 
01d8			    ;CS low 
01d8			 
01d8 3a f1 fb		       ld a,(spi_portbyte) 
01db cd 84 01			call spi_ce_low 
01de			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01de d3 80		       out (storage_adata),a 
01e0 32 f1 fb		       ld (spi_portbyte), a 
01e3			 
01e3			    ;clock out wren instruction 
01e3			 
01e3 3e 06		    ld a, store_wren_ins 
01e5 cd a8 00		    call spi_send_byte  
01e8			 
01e8			    ;cs high to enable write latch 
01e8			 
01e8 3a f1 fb		       ld a,(spi_portbyte) 
01eb cd 73 01			call spi_ce_high 
01ee			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ee d3 80		       out (storage_adata),a 
01f0 32 f1 fb		       ld (spi_portbyte), a 
01f3			 
01f3 00				nop 
01f4			    ; 
01f4			    ; intial write data 
01f4			    ; 
01f4			    ; cs low 
01f4			     
01f4 3a f1 fb		       ld a,(spi_portbyte) 
01f7 cd 84 01			call spi_ce_low 
01fa			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fa d3 80		       out (storage_adata),a 
01fc 32 f1 fb		       ld (spi_portbyte), a 
01ff			 
01ff			    ; clock out write instruction 
01ff			     
01ff 3e 02		    ld a, store_write_ins  
0201 cd a8 00		    call spi_send_byte  
0204			 
0204			    ; clock out address (depending on address size) 
0204			     
0204 e1			    pop hl 
0205 7c			    ld a,h    ; address out msb first 
0206 cd a8 00		    call spi_send_byte  
0209 7d			    ld a,l 
020a cd a8 00		    call spi_send_byte  
020d			 
020d			    ; clock out byte(s) for page 
020d			 
020d f1			    pop af 
020e cd a8 00		    call spi_send_byte  
0211			 
0211			    ; end write with ce high 
0211 3a f1 fb		       ld a,(spi_portbyte) 
0214			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0214 cd 73 01			call spi_ce_high 
0217 d3 80		       out (storage_adata),a 
0219 32 f1 fb		       ld (spi_portbyte), a 
021c			 
021c				; pause for internal write cycle 
021c 3e 0a			ld a, 10 
021e cd 29 0c			call aDelayInMS 
0221 c9			    ret 
0222			 
0222			; buffer to write in de 
0222			; address in hl  
0222			se_writepage: 
0222			        
0222			    ;   ld c, a 
0222 d5				push de 
0223 e5			        push hl 
0224			 
0224			    ; initi write mode 
0224			    ; 
0224			    ;CS low 
0224			 
0224 3a f1 fb		       ld a,(spi_portbyte) 
0227 cd 84 01			call spi_ce_low 
022a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022a d3 80		       out (storage_adata),a 
022c 32 f1 fb		       ld (spi_portbyte), a 
022f			 
022f			    ;clock out wren instruction 
022f			 
022f 3e 06		    ld a, store_wren_ins 
0231 cd a8 00		    call spi_send_byte  
0234			 
0234			    ;cs high to enable write latch 
0234			 
0234 3a f1 fb		       ld a,(spi_portbyte) 
0237 cd 73 01			call spi_ce_high 
023a			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023a d3 80		       out (storage_adata),a 
023c 32 f1 fb		       ld (spi_portbyte), a 
023f			 
023f 00				nop 
0240			    ; 
0240			    ; intial write data 
0240			    ; 
0240			    ; cs low 
0240			     
0240 3a f1 fb		       ld a,(spi_portbyte) 
0243			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0243 cd 84 01			call spi_ce_low 
0246 d3 80		       out (storage_adata),a 
0248 32 f1 fb		       ld (spi_portbyte), a 
024b			 
024b			    ; clock out write instruction 
024b			     
024b 3e 02		    ld a, store_write_ins  
024d cd a8 00		    call spi_send_byte  
0250			 
0250			    ; clock out address (depending on address size) 
0250			     
0250 e1			    pop hl 
0251 7c			    ld a,h    ; address out msb first 
0252 cd a8 00		    call spi_send_byte  
0255 7d			    ld a,l 
0256 cd a8 00		    call spi_send_byte  
0259			 
0259			    ; clock out byte(s) for page 
0259			 
0259 e1				pop hl 
025a 06 40			ld b, STORE_BLOCK_PHY 
025c			.bytewrite: 
025c			 
025c 7e				ld a,(hl) 
025d e5			    push hl 
025e c5				push bc 
025f cd a8 00		    call spi_send_byte  
0262 c1				pop bc 
0263 e1				pop hl 
0264			 
0264			    ; end write with ce high 
0264 3a f1 fb		       ld a,(spi_portbyte) 
0267 cd 73 01			call spi_ce_high 
026a			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026a d3 80		       out (storage_adata),a 
026c 32 f1 fb		       ld (spi_portbyte), a 
026f			 
026f 23				inc hl 
0270 10 ea			djnz .bytewrite 
0272			 
0272				; pause for internal write cycle 
0272 3e 64			ld a, 100 
0274 cd 29 0c			call aDelayInMS 
0277 c9			    ret 
0278			; returns byte in a 
0278			; address in hl  
0278			se_readbyte: 
0278 d5				push de 
0279 c5				push bc 
027a			 
027a			    ;   ld c, a 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a f1 fb		       ld a,(spi_portbyte) 
027e cd 84 01			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 f1 fb		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 03		    ld a, store_read_ins 
0288 cd a8 00		    call spi_send_byte  
028b			 
028b			 
028b			    ; clock out address (depending on address size) 
028b			     
028b e1			    pop hl 
028c 7c			    ld a,h    ; address out msb first 
028d cd a8 00		    call spi_send_byte  
0290 7d			    ld a,l 
0291 cd a8 00		    call spi_send_byte  
0294			 
0294			    ; clock in byte(s) for page 
0294			 
0294 cd c9 00		    call spi_read_byte  
0297 f5				push af 
0298			 
0298			    ; end write with ce high 
0298 3a f1 fb		       ld a,(spi_portbyte) 
029b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029b cd 73 01			call spi_ce_high 
029e d3 80		       out (storage_adata),a 
02a0 32 f1 fb		       ld (spi_portbyte), a 
02a3			 
02a3 f1				pop af 
02a4			 
02a4 c1				pop bc 
02a5 d1				pop de 
02a6			 
02a6 c9			    ret 
02a7			 
02a7			if DEBUG_STORESE 
02a7			 
02a7			storageput:  
02a7			 
02a7			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02a7			 
02a7 21 87 f3			ld hl,scratch+2 
02aa cd b2 12			call get_word_hl 
02ad			 
02ad				; stuff it here for the moment as it will be overwritten later anyway 
02ad			 
02ad 22 a8 f6			ld (os_cur_ptr),hl	 
02b0			 
02b0			 
02b0			; get pointer to start of string 
02b0			 
02b0 21 8c f3			ld hl, scratch+7 
02b3			 
02b3			; loop writing char of string to eeprom 
02b3			 
02b3 7e			.writestr:	ld a,(hl) 
02b4 fe 00				cp 0 
02b6 28 12				jr z, .wsdone		; done writing 
02b8 e5					push hl 
02b9 2a a8 f6				ld hl,(os_cur_ptr) 
02bc cd d6 01				call se_writebyte 
02bf			 
02bf 2a a8 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c2 23					inc hl 
02c3 22 a8 f6				ld (os_cur_ptr),hl 
02c6			 
02c6					; restore string pointer and get next char 
02c6			 
02c6 e1					pop hl 
02c7 23					inc hl 
02c8 18 e9				jr .writestr 
02ca			 
02ca			 
02ca			 
02ca			.wsdone: 
02ca			 
02ca			 
02ca			; when done load first page into a buffer  
02ca			 
02ca 21 00 80				ld hl,08000h		; start in ram 
02cd 22 a8 f6				ld (os_cur_ptr),hl 
02d0 21 00 00				ld hl, 0		 ; start of page 
02d3 22 ad f3				ld (scratch+40),hl	; hang on to it 
02d6			 
02d6 06 80				ld b, 128		; actually get more then one page 
02d8 c5			.wsload:	push bc 
02d9 2a ad f3				ld hl,(scratch+40) 
02dc e5					push hl 
02dd cd 78 02				call se_readbyte 
02e0			 
02e0					; a now as the byte 
02e0			 
02e0 2a a8 f6				ld hl,(os_cur_ptr) 
02e3 77					ld (hl),a 
02e4					; inc next buffer area 
02e4 23					inc hl 
02e5 22 a8 f6				ld (os_cur_ptr),hl 
02e8			 
02e8					; get eeprom position, inc and save for next round 
02e8 e1					pop hl		 
02e9 23					inc hl 
02ea 22 ad f3				ld (scratch+40),hl 
02ed c1					pop bc 
02ee 10 e8				djnz .wsload 
02f0			 
02f0			; set 'd' pointer to start of buffer 
02f0			 
02f0 21 00 80				ld hl,08000h 
02f3 22 a8 f6				ld (os_cur_ptr),hl 
02f6			 
02f6			 
02f6 c9			ret 
02f7			 
02f7			 
02f7 c9			storageread: ret 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			 
02f8			endif 
02f8			 
02f8			 
02f8			 
# End of file firmware_seeprom.asm
02f8			else  
02f8			   ; create some stubs for the labels  
02f8			se_readbyte: ret  
02f8			se_writebyte: ret  
02f8			storage_init: ret  
02f8			  
02f8			endif  
02f8			  
02f8			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02f8			;include "firmware_cf.asm"  
02f8			  
02f8			; load up high level storage hardward abstractions  
02f8			include "firmware_storage.asm"  
02f8			 
02f8			; persisent storage hardware abstraction layer  
02f8			 
02f8			 
02f8			 
02f8			; Block 0 on storage is a config state 
02f8			 
02f8			 
02f8			 
02f8			; TODO add read phy block and write phy block functions 
02f8			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02f8			 
02f8			; Abstraction layer  
02f8			 
02f8			; Logocial block size is same size as physical size - using tape concept 
02f8			 
02f8			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02f8			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02f8			 
02f8			 
02f8			 
02f8			; Filesystem layout (Logical layout) 
02f8			; 
02f8			; Block 0 - Bank config  
02f8			; 
02f8			;      Byte - 0 file id counter 
02f8			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02f8			;      Byte - 3-20 zero terminated bank label 
02f8			; 
02f8			; Block 1 > File storage 
02f8			; 
02f8			;      Byte 0 file id    - block 0 file details 
02f8			;      Byte 1 block id - block 0 is file  
02f8			;            Byte 2-15 - File name 
02f8			; 
02f8			;       - to end of block data 
02f8			; 
02f8			 
02f8			; Get ID for the file named in pointer held HL 
02f8			; Returns ID in HL = 255 if no file found 
02f8			 
02f8			storage_getid: 
02f8			 
02f8 22 00 fc			ld (store_tmp1), hl 
02fb			 
02fb				if DEBUG_STORESE 
02fb					DMARK "SGI" 
02fb f5				push af  
02fc 3a 10 03			ld a, (.dmark)  
02ff 32 b4 fe			ld (debug_mark),a  
0302 3a 11 03			ld a, (.dmark+1)  
0305 32 b5 fe			ld (debug_mark+1),a  
0308 3a 12 03			ld a, (.dmark+2)  
030b 32 b6 fe			ld (debug_mark+2),a  
030e 18 03			jr .pastdmark  
0310 ..			.dmark: db "SGI"  
0313 f1			.pastdmark: pop af  
0314			endm  
# End of macro DMARK
0314					CALLMONITOR 
0314 cd 78 18			call break_point_state  
0317				endm  
# End of macro CALLMONITOR
0317				endif 
0317				; get block 0 and set counter for number of files to scan 
0317			 
0317 cd 82 04			call storage_get_block_0 
031a			 
031a 3a 07 fc			ld a, (store_page) 
031d 47				ld b, a 
031e			 
031e				; get extent 0 of each file id 
031e			 
031e				if DEBUG_STORESE 
031e					DMARK "SGc" 
031e f5				push af  
031f 3a 33 03			ld a, (.dmark)  
0322 32 b4 fe			ld (debug_mark),a  
0325 3a 34 03			ld a, (.dmark+1)  
0328 32 b5 fe			ld (debug_mark+1),a  
032b 3a 35 03			ld a, (.dmark+2)  
032e 32 b6 fe			ld (debug_mark+2),a  
0331 18 03			jr .pastdmark  
0333 ..			.dmark: db "SGc"  
0336 f1			.pastdmark: pop af  
0337			endm  
# End of macro DMARK
0337					CALLMONITOR 
0337 cd 78 18			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a 60			.getloop:	ld h, b 
033b 2e 00				ld l, 0 
033d c5					push bc 
033e			 
033e 11 07 fc				ld de, store_page 
0341				if DEBUG_STORESE 
0341					DMARK "SGr" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 b4 fe			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 b5 fe			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 b6 fe			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SGr"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a					CALLMONITOR 
035a cd 78 18			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d				endif 
035d cd 2a 09				call storage_read 
0360 cd 24 0f				call ishlzero 
0363 28 2d				jr z, .gap 
0365					 
0365					; have a file name read. Is it one we want. 
0365			 
0365 2a 00 fc				ld hl, (store_tmp1) 
0368 11 0a fc				ld de, store_page+3   ; file name 
036b			 
036b				if DEBUG_STORESE 
036b					DMARK "SGc" 
036b f5				push af  
036c 3a 80 03			ld a, (.dmark)  
036f 32 b4 fe			ld (debug_mark),a  
0372 3a 81 03			ld a, (.dmark+1)  
0375 32 b5 fe			ld (debug_mark+1),a  
0378 3a 82 03			ld a, (.dmark+2)  
037b 32 b6 fe			ld (debug_mark+2),a  
037e 18 03			jr .pastdmark  
0380 ..			.dmark: db "SGc"  
0383 f1			.pastdmark: pop af  
0384			endm  
# End of macro DMARK
0384					CALLMONITOR 
0384 cd 78 18			call break_point_state  
0387				endm  
# End of macro CALLMONITOR
0387				endif 
0387 cd 91 13				call strcmp 
038a 20 06				jr nz, .gap   ; not this one 
038c			 
038c c1				        pop bc 
038d			 
038d 26 00				ld h, 0 
038f 68					ld l, b 
0390 18 22				jr .getdone 
0392						 
0392			 
0392			 
0392			 
0392			.gap: 
0392				if DEBUG_STORESE 
0392					DMARK "SGg" 
0392 f5				push af  
0393 3a a7 03			ld a, (.dmark)  
0396 32 b4 fe			ld (debug_mark),a  
0399 3a a8 03			ld a, (.dmark+1)  
039c 32 b5 fe			ld (debug_mark+1),a  
039f 3a a9 03			ld a, (.dmark+2)  
03a2 32 b6 fe			ld (debug_mark+2),a  
03a5 18 03			jr .pastdmark  
03a7 ..			.dmark: db "SGg"  
03aa f1			.pastdmark: pop af  
03ab			endm  
# End of macro DMARK
03ab					CALLMONITOR 
03ab cd 78 18			call break_point_state  
03ae				endm  
# End of macro CALLMONITOR
03ae				endif 
03ae			 
03ae c1					pop bc 
03af 10 89				djnz .getloop 
03b1 21 ff 00				ld hl, 255 
03b4			.getdone: 
03b4			 
03b4				if DEBUG_STORESE 
03b4					DMARK "SGe" 
03b4 f5				push af  
03b5 3a c9 03			ld a, (.dmark)  
03b8 32 b4 fe			ld (debug_mark),a  
03bb 3a ca 03			ld a, (.dmark+1)  
03be 32 b5 fe			ld (debug_mark+1),a  
03c1 3a cb 03			ld a, (.dmark+2)  
03c4 32 b6 fe			ld (debug_mark+2),a  
03c7 18 03			jr .pastdmark  
03c9 ..			.dmark: db "SGe"  
03cc f1			.pastdmark: pop af  
03cd			endm  
# End of macro DMARK
03cd					CALLMONITOR 
03cd cd 78 18			call break_point_state  
03d0				endm  
# End of macro CALLMONITOR
03d0				endif 
03d0			 
03d0 c9				ret 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			 
03d1			; Read Block 
03d1			; ---------- 
03d1			; 
03d1			; With current bank 
03d1			;  
03d1			; Get block number to read 
03d1			; Load physical blocks starting at start block into buffer 
03d1			 
03d1			; de points to buffer to use 
03d1			; hl holds logical block number  
03d1			 
03d1			storage_read_block: 
03d1			 
03d1				; TODO bank selection 
03d1			 
03d1				; for each of the physical blocks read it into the buffer 
03d1 06 40			ld b, STORE_BLOCK_PHY 
03d3			 
03d3				if DEBUG_STORESE 
03d3 d5					push de 
03d4				endif 
03d4				 
03d4			.rl1:    
03d4			 
03d4				; read physical block at hl into de 
03d4			        ; increment hl and de to next read position on exit 
03d4			 
03d4 e5				push hl 
03d5 d5				push de	 
03d6 c5				push bc 
03d7			;	if DEBUG_STORESE 
03d7			;		push af 
03d7			;		ld a, 'R' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7			;		CALLMONITOR 
03d7			;	endif 
03d7 cd 78 02			call se_readbyte 
03da			;	if DEBUG_STORESE 
03da			;		ld a,(spi_portbyte) 
03da			;		ld l, a 
03da			;		push af 
03da			;		ld a, '1' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da c1				pop bc 
03db d1				pop de 
03dc e1				pop hl 
03dd 12				ld (de),a 
03de 23				inc hl 
03df 13				inc de 
03e0			 
03e0			;	if DEBUG_STORESE 
03e0			;		push af 
03e0			;		ld a, 'r' 
03e0			;		ld (debug_mark),a 
03e0			;		pop af 
03e0			;		CALLMONITOR 
03e0			;	endif 
03e0			 
03e0 10 f2			djnz .rl1 
03e2			 
03e2				if DEBUG_STORESE 
03e2					DMARK "SRB" 
03e2 f5				push af  
03e3 3a f7 03			ld a, (.dmark)  
03e6 32 b4 fe			ld (debug_mark),a  
03e9 3a f8 03			ld a, (.dmark+1)  
03ec 32 b5 fe			ld (debug_mark+1),a  
03ef 3a f9 03			ld a, (.dmark+2)  
03f2 32 b6 fe			ld (debug_mark+2),a  
03f5 18 03			jr .pastdmark  
03f7 ..			.dmark: db "SRB"  
03fa f1			.pastdmark: pop af  
03fb			endm  
# End of macro DMARK
03fb d1					pop de 
03fc			; 
03fc			;		push af 
03fc			;		ld a, 'R' 
03fc			;		ld (debug_mark),a 
03fc			;		pop af 
03fc					CALLMONITOR 
03fc cd 78 18			call break_point_state  
03ff				endm  
# End of macro CALLMONITOR
03ff				endif 
03ff c9				ret	 
0400				 
0400			 
0400			; File Size 
0400			; --------- 
0400			; 
0400			;   hl file id 
0400			; 
0400			;  returns in hl the number of blocks 
0400			 
0400			storage_file_size: 
0400 5d				ld e, l 
0401 16 00			ld d, 0 
0403 21 40 00			ld hl, STORE_BLOCK_PHY 
0406					if DEBUG_FORTH_WORDS 
0406						DMARK "SIZ" 
0406 f5				push af  
0407 3a 1b 04			ld a, (.dmark)  
040a 32 b4 fe			ld (debug_mark),a  
040d 3a 1c 04			ld a, (.dmark+1)  
0410 32 b5 fe			ld (debug_mark+1),a  
0413 3a 1d 04			ld a, (.dmark+2)  
0416 32 b6 fe			ld (debug_mark+2),a  
0419 18 03			jr .pastdmark  
041b ..			.dmark: db "SIZ"  
041e f1			.pastdmark: pop af  
041f			endm  
# End of macro DMARK
041f						CALLMONITOR 
041f cd 78 18			call break_point_state  
0422				endm  
# End of macro CALLMONITOR
0422					endif 
0422 cd 04 07			call storage_findnextid 
0425			 
0425 cd 24 0f			call ishlzero 
0428			;	ld a, l 
0428			;	add h 
0428			;	cp 0 
0428 c8				ret z			; block not found so EOF 
0429			 
0429 11 07 fc			ld de, store_page 
042c cd d1 03			call storage_read_block 
042f			 
042f 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
0432 6f				ld l, a 
0433 26 00			ld h, 0 
0435 c9			 	ret 
0436			 
0436			 
0436			; Write Block 
0436			; ----------- 
0436			; 
0436			; With current bank 
0436			;  
0436			; Get block number to write 
0436			; Write physical blocks starting at start block from buffer 
0436			  
0436			storage_write_block: 
0436				; TODO bank selection 
0436			 
0436				; for each of the physical blocks read it into the buffer 
0436 06 40			ld b, STORE_BLOCK_PHY 
0438			 
0438				if DEBUG_STORESE 
0438					DMARK "SWB" 
0438 f5				push af  
0439 3a 4d 04			ld a, (.dmark)  
043c 32 b4 fe			ld (debug_mark),a  
043f 3a 4e 04			ld a, (.dmark+1)  
0442 32 b5 fe			ld (debug_mark+1),a  
0445 3a 4f 04			ld a, (.dmark+2)  
0448 32 b6 fe			ld (debug_mark+2),a  
044b 18 03			jr .pastdmark  
044d ..			.dmark: db "SWB"  
0450 f1			.pastdmark: pop af  
0451			endm  
# End of macro DMARK
0451			 
0451					;push af 
0451					;ld a, 'W' 
0451					;ld (debug_mark),a 
0451					;pop af 
0451					CALLMONITOR 
0451 cd 78 18			call break_point_state  
0454				endm  
# End of macro CALLMONITOR
0454				endif 
0454			 
0454			; might not be working 
0454			;	call se_writepage 
0454			 
0454			;	ret 
0454			; 
0454			 
0454			 
0454			 
0454			.wl1:    
0454			 
0454				; read physical block at hl into de 
0454			        ; increment hl and de to next read position on exit 
0454			 
0454 e5				push hl 
0455 d5				push de	 
0456 c5				push bc 
0457 1a				ld a,(de) 
0458				;if DEBUG_STORESE 
0458			;		push af 
0458			;		ld a, 'W' 
0458			;		ld (debug_mark),a 
0458			;		pop af 
0458			;		CALLMONITOR 
0458			;	endif 
0458 cd d6 01			call se_writebyte 
045b			;	call delay250ms 
045b 00				nop 
045c 00				nop 
045d 00				nop 
045e			;	if DEBUG_STORESE 
045e			;		push af 
045e			;		ld a, 'w' 
045e			;		ld (debug_mark),a 
045e			;		pop af 
045e			;		CALLMONITOR 
045e			;	endif 
045e c1				pop bc 
045f d1				pop de 
0460 e1				pop hl 
0461 23				inc hl 
0462 13				inc de 
0463			 
0463			 
0463 10 ef			djnz .wl1 
0465			 
0465				if DEBUG_STORESE 
0465					DMARK "SW2" 
0465 f5				push af  
0466 3a 7a 04			ld a, (.dmark)  
0469 32 b4 fe			ld (debug_mark),a  
046c 3a 7b 04			ld a, (.dmark+1)  
046f 32 b5 fe			ld (debug_mark+1),a  
0472 3a 7c 04			ld a, (.dmark+2)  
0475 32 b6 fe			ld (debug_mark+2),a  
0478 18 03			jr .pastdmark  
047a ..			.dmark: db "SW2"  
047d f1			.pastdmark: pop af  
047e			endm  
# End of macro DMARK
047e			 
047e					;push af 
047e					;ld a, 'W' 
047e					;ld (debug_mark),a 
047e					;pop af 
047e					CALLMONITOR 
047e cd 78 18			call break_point_state  
0481				endm  
# End of macro CALLMONITOR
0481				endif 
0481 c9				ret	 
0482			 
0482			; Init bank 
0482			; --------- 
0482			; 
0482			; With current bank 
0482			; 
0482			; Setup block 0 config 
0482			;     Set 0 file id counter 
0482			;     Set formatted byte pattern 
0482			;     Zero out bank label 
0482			;      
0482			; For every logical block write 0-1 byte as null 
0482			 
0482			storage_get_block_0: 
0482			 
0482				; TODO check presence 
0482			 
0482				; get block 0 config 
0482			 
0482 21 00 00			ld hl, 0 
0485 11 07 fc			ld de, store_page 
0488 cd d1 03			call storage_read_block 
048b			 
048b				if DEBUG_STORESE 
048b					DMARK "SB0" 
048b f5				push af  
048c 3a a0 04			ld a, (.dmark)  
048f 32 b4 fe			ld (debug_mark),a  
0492 3a a1 04			ld a, (.dmark+1)  
0495 32 b5 fe			ld (debug_mark+1),a  
0498 3a a2 04			ld a, (.dmark+2)  
049b 32 b6 fe			ld (debug_mark+2),a  
049e 18 03			jr .pastdmark  
04a0 ..			.dmark: db "SB0"  
04a3 f1			.pastdmark: pop af  
04a4			endm  
# End of macro DMARK
04a4 11 07 fc				ld de, store_page 
04a7			;		push af 
04a7			;		ld a, 'i' 
04a7			;		ld (debug_mark),a 
04a7			;		pop af 
04a7					CALLMONITOR 
04a7 cd 78 18			call break_point_state  
04aa				endm  
# End of macro CALLMONITOR
04aa				endif 
04aa			 
04aa				; is this area formatted? 
04aa			 
04aa			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04aa 2a 08 fc			ld hl, (store_page+1) 
04ad 3e 80			ld a,0x80 
04af bd				cp l 
04b0 20 22			jr nz, .ininotformatted 
04b2				; do a double check 
04b2 3e 27			ld a, 0x27 
04b4 bc				cp h 
04b5 20 1d			jr nz, .ininotformatted 
04b7			 
04b7				; formatted then 
04b7			 
04b7				if DEBUG_STORESE 
04b7					DMARK "SB1" 
04b7 f5				push af  
04b8 3a cc 04			ld a, (.dmark)  
04bb 32 b4 fe			ld (debug_mark),a  
04be 3a cd 04			ld a, (.dmark+1)  
04c1 32 b5 fe			ld (debug_mark+1),a  
04c4 3a ce 04			ld a, (.dmark+2)  
04c7 32 b6 fe			ld (debug_mark+2),a  
04ca 18 03			jr .pastdmark  
04cc ..			.dmark: db "SB1"  
04cf f1			.pastdmark: pop af  
04d0			endm  
# End of macro DMARK
04d0					;push af 
04d0					;ld a, 'I' 
04d0					;ld (debug_mark),a 
04d0					;pop af 
04d0					CALLMONITOR 
04d0 cd 78 18			call break_point_state  
04d3				endm  
# End of macro CALLMONITOR
04d3				endif 
04d3 c9				ret 
04d4			 
04d4			.ininotformatted: 
04d4				; bank not formatted so poke various bits to make sure 
04d4			 
04d4				if DEBUG_STORESE 
04d4					DMARK "SB2" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 b4 fe			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 b5 fe			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 b6 fe			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "SB2"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed					;push af 
04ed					;ld a, 'f' 
04ed					;ld (debug_mark),a 
04ed					;pop af 
04ed					CALLMONITOR 
04ed cd 78 18			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0				endif 
04f0			 
04f0 cd 07 0c			call storage_clear_page 
04f3			 
04f3 21 07 fc			ld hl, store_page 
04f6 3e 00			ld a, 0 
04f8				 
04f8 77				ld (hl),a   ; reset file counter 
04f9			 
04f9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04fc 22 08 fc		 	ld (store_page+1), hl	 
04ff			 
04ff				; set default label 
04ff			 
04ff 21 9b 05			ld hl, .defaultbanklabl 
0502 11 0a fc		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508 ed b0			ldir 
050a			 
050a				; Append the current bank id 
050a 21 13 fc			ld hl, store_page+3+9 
050d 3a ef fb			ld a, (spi_device_id) 
0510 77				ld (hl), a 
0511			 
0511				; save default page 0 
0511			 
0511 21 00 00			ld hl, 0 
0514 11 07 fc			ld de, store_page 
0517				if DEBUG_STORESE 
0517					DMARK "SB3" 
0517 f5				push af  
0518 3a 2c 05			ld a, (.dmark)  
051b 32 b4 fe			ld (debug_mark),a  
051e 3a 2d 05			ld a, (.dmark+1)  
0521 32 b5 fe			ld (debug_mark+1),a  
0524 3a 2e 05			ld a, (.dmark+2)  
0527 32 b6 fe			ld (debug_mark+2),a  
052a 18 03			jr .pastdmark  
052c ..			.dmark: db "SB3"  
052f f1			.pastdmark: pop af  
0530			endm  
# End of macro DMARK
0530			;		push af 
0530			;		ld a, 'F' 
0530			;		ld (debug_mark),a 
0530			;		pop af 
0530					CALLMONITOR 
0530 cd 78 18			call break_point_state  
0533				endm  
# End of macro CALLMONITOR
0533				endif 
0533 cd 36 04			call storage_write_block 
0536				if DEBUG_STORESE 
0536					DMARK "SB4" 
0536 f5				push af  
0537 3a 4b 05			ld a, (.dmark)  
053a 32 b4 fe			ld (debug_mark),a  
053d 3a 4c 05			ld a, (.dmark+1)  
0540 32 b5 fe			ld (debug_mark+1),a  
0543 3a 4d 05			ld a, (.dmark+2)  
0546 32 b6 fe			ld (debug_mark+2),a  
0549 18 03			jr .pastdmark  
054b ..			.dmark: db "SB4"  
054e f1			.pastdmark: pop af  
054f			endm  
# End of macro DMARK
054f			;		push af 
054f			;		ld a, '>' 
054f			;		ld (debug_mark),a 
054f			;		pop af 
054f					CALLMONITOR 
054f cd 78 18			call break_point_state  
0552				endm  
# End of macro CALLMONITOR
0552				endif 
0552			 
0552 00				nop 
0553 00				nop 
0554 00				nop 
0555			 
0555				; now set 0 in every page to mark as a free block 
0555			 
0555 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a			 
055a 3e 00		.setmark1:   	ld a,0 
055c e5					push hl 
055d c5					push bc 
055e cd d6 01				call se_writebyte 
0561 3e 0a			ld a, 10 
0563 cd 29 0c			call aDelayInMS 
0566 23				inc hl 
0567 cd d6 01				call se_writebyte 
056a 3e 0a			ld a, 10 
056c cd 29 0c			call aDelayInMS 
056f 2b				dec hl 
0570 c1					pop bc 
0571 e1					pop hl 
0572 3e 40				ld a, STORE_BLOCK_PHY 
0574 cd fb 0e				call addatohl 
0577 10 e1				djnz .setmark1 
0579			 
0579 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057b 3e 00		.setmark2:   	ld a,0 
057d e5					push hl 
057e c5					push bc 
057f cd d6 01				call se_writebyte 
0582 3e 0a			ld a, 10 
0584 cd 29 0c			call aDelayInMS 
0587 23				inc hl 
0588 cd d6 01				call se_writebyte 
058b 3e 0a			ld a, 10 
058d cd 29 0c			call aDelayInMS 
0590 2b				dec hl 
0591 c1					pop bc 
0592 e1					pop hl 
0593 3e 40				ld a, STORE_BLOCK_PHY 
0595 cd fb 0e				call addatohl 
0598 10 e1				djnz .setmark2 
059a			 
059a					 
059a			 
059a			 
059a c9				ret 
059b			 
059b			 
059b			 
059b			 
059b .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a6			 
05a6			 
05a6			 
05a6			; Label Bank 
05a6			; ---------- 
05a6			; 
05a6			; With current bank 
05a6			; Read block 0 
05a6			; Set label 
05a6			; Write block 0 
05a6			 
05a6			; label str pointer in hl 
05a6			 
05a6			storage_label:     
05a6			 
05a6				if DEBUG_STORESE 
05a6					DMARK "LBL" 
05a6 f5				push af  
05a7 3a bb 05			ld a, (.dmark)  
05aa 32 b4 fe			ld (debug_mark),a  
05ad 3a bc 05			ld a, (.dmark+1)  
05b0 32 b5 fe			ld (debug_mark+1),a  
05b3 3a bd 05			ld a, (.dmark+2)  
05b6 32 b6 fe			ld (debug_mark+2),a  
05b9 18 03			jr .pastdmark  
05bb ..			.dmark: db "LBL"  
05be f1			.pastdmark: pop af  
05bf			endm  
# End of macro DMARK
05bf					CALLMONITOR 
05bf cd 78 18			call break_point_state  
05c2				endm  
# End of macro CALLMONITOR
05c2				endif 
05c2			 
05c2 e5				push hl 
05c3			 
05c3 cd 82 04			call storage_get_block_0 
05c6			 
05c6				; set default label 
05c6			 
05c6 e1				pop hl 
05c7			 
05c7 11 0a fc		 	ld de, store_page+3 
05ca 01 0f 00			ld bc, 15 
05cd				if DEBUG_STORESE 
05cd					DMARK "LB3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 b4 fe			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 b5 fe			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 b6 fe			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "LB3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6					CALLMONITOR 
05e6 cd 78 18			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9				endif 
05e9 ed b0			ldir 
05eb				; save default page 0 
05eb			 
05eb 21 00 00			ld hl, 0 
05ee 11 07 fc			ld de, store_page 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBW" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 b4 fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 b5 fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 b6 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBW"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd 78 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d cd 36 04			call storage_write_block 
0610			 
0610 c9				ret 
0611			 
0611			 
0611			 
0611			; Read Block 0 - Config 
0611			; --------------------- 
0611			; 
0611			; With current bank 
0611			; Call presence test 
0611			;    If not present format/init bank  
0611			; Read block 0  
0611			;  
0611			 
0611			 
0611			; Dir 
0611			; --- 
0611			; 
0611			; With current bank 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block read byte 2 
0611			;      if first block of file 
0611			;         Display file name 
0611			;         Display type flags for file 
0611			;        
0611			 
0611			; moving to words as this requires stack control 
0611			 
0611			 
0611			; Delete File 
0611			; ----------- 
0611			; 
0611			; With current bank 
0611			; 
0611			; Load Block 0 Config 
0611			; Get max file id number 
0611			; For each logical block 
0611			;    Read block file id 
0611			;      If first block of file and dont have file id 
0611			;         if file to delete 
0611			;         Save file id 
0611			;         Null file id 
0611			;         Write this block back 
0611			;      If file id is one saved 
0611			;         Null file id 
0611			;         Write this block back 
0611			 
0611			 
0611			.se_done: 
0611 e1				pop hl 
0612 c9				ret 
0613			 
0613			storage_erase: 
0613			 
0613				; hl contains the file id 
0613			 
0613 5d				ld e, l 
0614 16 00			ld d, 0 
0616 21 40 00			ld hl, STORE_BLOCK_PHY 
0619					if DEBUG_FORTH_WORDS 
0619						DMARK "ERA" 
0619 f5				push af  
061a 3a 2e 06			ld a, (.dmark)  
061d 32 b4 fe			ld (debug_mark),a  
0620 3a 2f 06			ld a, (.dmark+1)  
0623 32 b5 fe			ld (debug_mark+1),a  
0626 3a 30 06			ld a, (.dmark+2)  
0629 32 b6 fe			ld (debug_mark+2),a  
062c 18 03			jr .pastdmark  
062e ..			.dmark: db "ERA"  
0631 f1			.pastdmark: pop af  
0632			endm  
# End of macro DMARK
0632						CALLMONITOR 
0632 cd 78 18			call break_point_state  
0635				endm  
# End of macro CALLMONITOR
0635					endif 
0635 cd 04 07			call storage_findnextid 
0638 cd 24 0f			call ishlzero 
063b c8				ret z 
063c			 
063c e5				push hl 
063d			 
063d				; TODO check file not found 
063d			 
063d 11 07 fc			ld de, store_page 
0640 cd d1 03			call storage_read_block 
0643			 
0643 cd 24 0f			call ishlzero 
0646 ca 11 06			jp z,.se_done 
0649			 
0649					if DEBUG_FORTH_WORDS 
0649						DMARK "ER1" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 b4 fe			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 b5 fe			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 b6 fe			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "ER1"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662						CALLMONITOR 
0662 cd 78 18			call break_point_state  
0665				endm  
# End of macro CALLMONITOR
0665					endif 
0665 3a 07 fc			ld a, (store_page)	; get file id 
0668 32 fb fb			ld (store_tmpid), a 
066b			 
066b 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
066e 32 fa fb			ld (store_tmpext), a 
0671			 
0671				; wipe file header 
0671			 
0671 e1				pop hl 
0672 3e 00			ld a, 0 
0674 32 07 fc			ld (store_page), a 
0677 32 08 fc			ld (store_page+1),a 
067a 11 07 fc			ld de, store_page 
067d					if DEBUG_FORTH_WORDS 
067d						DMARK "ER2" 
067d f5				push af  
067e 3a 92 06			ld a, (.dmark)  
0681 32 b4 fe			ld (debug_mark),a  
0684 3a 93 06			ld a, (.dmark+1)  
0687 32 b5 fe			ld (debug_mark+1),a  
068a 3a 94 06			ld a, (.dmark+2)  
068d 32 b6 fe			ld (debug_mark+2),a  
0690 18 03			jr .pastdmark  
0692 ..			.dmark: db "ER2"  
0695 f1			.pastdmark: pop af  
0696			endm  
# End of macro DMARK
0696						CALLMONITOR 
0696 cd 78 18			call break_point_state  
0699				endm  
# End of macro CALLMONITOR
0699					endif 
0699 cd 36 04			call storage_write_block 
069c			 
069c			 
069c				; wipe file extents 
069c			 
069c 3a fa fb			ld a, (store_tmpext) 
069f 47				ld b, a 
06a0			 
06a0			.eraext:	  
06a0 c5				push bc 
06a1			 
06a1 21 40 00			ld hl, STORE_BLOCK_PHY 
06a4 3a fb fb			ld a,(store_tmpid) 
06a7 5f				ld e, a 
06a8 50				ld d, b	 
06a9					if DEBUG_FORTH_WORDS 
06a9						DMARK "ER3" 
06a9 f5				push af  
06aa 3a be 06			ld a, (.dmark)  
06ad 32 b4 fe			ld (debug_mark),a  
06b0 3a bf 06			ld a, (.dmark+1)  
06b3 32 b5 fe			ld (debug_mark+1),a  
06b6 3a c0 06			ld a, (.dmark+2)  
06b9 32 b6 fe			ld (debug_mark+2),a  
06bc 18 03			jr .pastdmark  
06be ..			.dmark: db "ER3"  
06c1 f1			.pastdmark: pop af  
06c2			endm  
# End of macro DMARK
06c2						CALLMONITOR 
06c2 cd 78 18			call break_point_state  
06c5				endm  
# End of macro CALLMONITOR
06c5					endif 
06c5 cd 04 07			call storage_findnextid 
06c8 cd 24 0f			call ishlzero 
06cb ca 11 06			jp z,.se_done 
06ce			 
06ce e5				push hl 
06cf 11 07 fc			ld de, store_page 
06d2 cd d1 03			call storage_read_block 
06d5			 
06d5				; free block	 
06d5			 
06d5 3e 00			ld a, 0 
06d7 32 07 fc			ld (store_page), a 
06da 32 08 fc			ld (store_page+1),a 
06dd 11 07 fc			ld de, store_page 
06e0 e1				pop hl 
06e1					if DEBUG_FORTH_WORDS 
06e1						DMARK "ER4" 
06e1 f5				push af  
06e2 3a f6 06			ld a, (.dmark)  
06e5 32 b4 fe			ld (debug_mark),a  
06e8 3a f7 06			ld a, (.dmark+1)  
06eb 32 b5 fe			ld (debug_mark+1),a  
06ee 3a f8 06			ld a, (.dmark+2)  
06f1 32 b6 fe			ld (debug_mark+2),a  
06f4 18 03			jr .pastdmark  
06f6 ..			.dmark: db "ER4"  
06f9 f1			.pastdmark: pop af  
06fa			endm  
# End of macro DMARK
06fa						CALLMONITOR 
06fa cd 78 18			call break_point_state  
06fd				endm  
# End of macro CALLMONITOR
06fd					endif 
06fd cd 36 04			call storage_write_block 
0700			 
0700 c1				pop bc 
0701 10 9d			djnz .eraext 
0703			 
0703 c9				ret 
0704			 
0704			 
0704			; Find Free Block 
0704			; --------------- 
0704			; 
0704			; With current bank 
0704			;  
0704			; From given starting logical block 
0704			;    Read block  
0704			;    If no file id 
0704			;         Return block id 
0704			 
0704			 
0704			; hl starting page number 
0704			; hl contains free page number or zero if no pages free 
0704			; e contains the file id to locate 
0704			; d contains the block number 
0704			 
0704			; TODO change to find file id and use zero for free block 
0704			 
0704			storage_findnextid: 
0704			 
0704				; now locate first 0 page to mark as a free block 
0704			 
0704 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0706			;	ld hl, STORE_BLOCK_PHY 
0706			 
0706					if DEBUG_FORTH_WORDS 
0706					DMARK "FNI" 
0706 f5				push af  
0707 3a 1b 07			ld a, (.dmark)  
070a 32 b4 fe			ld (debug_mark),a  
070d 3a 1c 07			ld a, (.dmark+1)  
0710 32 b5 fe			ld (debug_mark+1),a  
0713 3a 1d 07			ld a, (.dmark+2)  
0716 32 b6 fe			ld (debug_mark+2),a  
0719 18 03			jr .pastdmark  
071b ..			.dmark: db "FNI"  
071e f1			.pastdmark: pop af  
071f			endm  
# End of macro DMARK
071f						CALLMONITOR 
071f cd 78 18			call break_point_state  
0722				endm  
# End of macro CALLMONITOR
0722					endif 
0722			.ff1:   	 
0722 e5					push hl 
0723 c5					push bc 
0724 d5					push de 
0725 cd 78 02				call se_readbyte 
0728 5f					ld e,a 
0729 23					inc hl 
072a cd 78 02				call se_readbyte 
072d 57					ld d, a 
072e e1					pop hl 
072f e5					push hl 
0730 cd 19 0f				call cmp16 
0733 28 49				jr z, .fffound 
0735			 
0735 d1					pop de 
0736 c1					pop bc 
0737 e1					pop hl 
0738			 
0738					; is found? 
0738					;cp e 
0738					;ret z 
0738			 
0738 3e 40				ld a, STORE_BLOCK_PHY 
073a cd fb 0e				call addatohl 
073d 10 e3				djnz .ff1 
073f			 
073f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0741			.ff2:   	 
0741			 
0741 e5					push hl 
0742 c5					push bc 
0743 d5					push de 
0744 cd 78 02				call se_readbyte 
0747 5f					ld e,a 
0748 23					inc hl 
0749 cd 78 02				call se_readbyte 
074c 57					ld d, a 
074d			 
074d e1					pop hl 
074e e5					push hl 
074f cd 19 0f				call cmp16 
0752 28 2a				jr z, .fffound 
0754			 
0754 d1					pop de 
0755 c1					pop bc 
0756 e1					pop hl 
0757					; is found? 
0757					;cp e 
0757					;ret z 
0757			 
0757 3e 40				ld a, STORE_BLOCK_PHY 
0759 cd fb 0e				call addatohl 
075c 10 e3				djnz .ff2 
075e			 
075e			 
075e					if DEBUG_FORTH_WORDS 
075e					DMARK "FN-" 
075e f5				push af  
075f 3a 73 07			ld a, (.dmark)  
0762 32 b4 fe			ld (debug_mark),a  
0765 3a 74 07			ld a, (.dmark+1)  
0768 32 b5 fe			ld (debug_mark+1),a  
076b 3a 75 07			ld a, (.dmark+2)  
076e 32 b6 fe			ld (debug_mark+2),a  
0771 18 03			jr .pastdmark  
0773 ..			.dmark: db "FN-"  
0776 f1			.pastdmark: pop af  
0777			endm  
# End of macro DMARK
0777					;	push af 
0777					;	ld a, 'n' 
0777					;	ld (debug_mark),a 
0777					;	pop af 
0777						CALLMONITOR 
0777 cd 78 18			call break_point_state  
077a				endm  
# End of macro CALLMONITOR
077a					endif 
077a				; no free marks! 
077a 21 00 00				ld hl, 0 
077d c9				ret 
077e			.fffound: 
077e				 
077e			 
077e d1					pop de 
077f c1					pop bc 
0780 e1					pop hl 
0781					if DEBUG_FORTH_WORDS 
0781					DMARK "FNF" 
0781 f5				push af  
0782 3a 96 07			ld a, (.dmark)  
0785 32 b4 fe			ld (debug_mark),a  
0788 3a 97 07			ld a, (.dmark+1)  
078b 32 b5 fe			ld (debug_mark+1),a  
078e 3a 98 07			ld a, (.dmark+2)  
0791 32 b6 fe			ld (debug_mark+2),a  
0794 18 03			jr .pastdmark  
0796 ..			.dmark: db "FNF"  
0799 f1			.pastdmark: pop af  
079a			endm  
# End of macro DMARK
079a					;	push af 
079a					;	ld a, 'n' 
079a					;	ld (debug_mark),a 
079a					;	pop af 
079a						CALLMONITOR 
079a cd 78 18			call break_point_state  
079d				endm  
# End of macro CALLMONITOR
079d					endif 
079d c9				ret 
079e			 
079e			 
079e			 
079e			; Free Space 
079e			; ---------- 
079e			; 
079e			; With current bank 
079e			; 
079e			; Set block count to zero 
079e			; Starting with first logical block 
079e			;      Find free block  
079e			;      If block id given, increment block count 
079e			; 
079e			;  
079e			 
079e			 
079e			; hl contains count of free blocks 
079e			 
079e			storage_freeblocks: 
079e			 
079e				; now locate first 0 page to mark as a free block 
079e			 
079e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a0 21 40 00			ld hl, STORE_BLOCK_PHY 
07a3 11 00 00			ld de, 0 
07a6			 
07a6			.fb1:   	 
07a6 e5					push hl 
07a7 c5					push bc 
07a8 d5					push de 
07a9 cd 78 02				call se_readbyte 
07ac d1					pop de 
07ad c1					pop bc 
07ae e1					pop hl 
07af			 
07af					; is free? 
07af fe 00				cp 0 
07b1 20 01				jr nz, .ff1cont 
07b3 13					inc de 
07b4			 
07b4			.ff1cont: 
07b4			 
07b4			 
07b4 3e 40				ld a, STORE_BLOCK_PHY 
07b6 cd fb 0e				call addatohl 
07b9 10 eb				djnz .fb1 
07bb			 
07bb 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07bd			.fb2:   	 
07bd e5					push hl 
07be c5					push bc 
07bf d5					push de 
07c0 cd 78 02				call se_readbyte 
07c3 d1					pop de 
07c4 c1					pop bc 
07c5 e1					pop hl 
07c6			 
07c6					; is free? 
07c6 fe 00				cp 0 
07c8 20 01				jr nz, .ff2cont 
07ca 13					inc de 
07cb			 
07cb			.ff2cont: 
07cb			 
07cb 3e 40				ld a, STORE_BLOCK_PHY 
07cd cd fb 0e				call addatohl 
07d0 10 eb				djnz .fb2 
07d2			 
07d2 eb				ex de, hl 
07d3 c9				ret 
07d4			 
07d4			; Get File ID 
07d4			; ----------- 
07d4			; 
07d4			; With current bank 
07d4			;  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; For each logical block 
07d4			;    Read block file id 
07d4			;      If first block of file and dont have file id 
07d4			;         if file get id and exit 
07d4			 
07d4			 
07d4			 
07d4			 
07d4			; Create File 
07d4			; ----------- 
07d4			; 
07d4			; With current bank  
07d4			; Load Block 0 Config 
07d4			; Get max file id number 
07d4			; Increment file id number 
07d4			; Save Config 
07d4			; Find free block 
07d4			; Set buffer with file name and file id 
07d4			; Write buffer to free block  
07d4			 
07d4			 
07d4			; hl point to file name 
07d4			; hl returns file id 
07d4			 
07d4			; file format: 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent number 
07d4			; byte 2-> data 
07d4			 
07d4			; format for extent number 0: 
07d4			; 
07d4			; byte 0 - file id 
07d4			; byte 1 - extent 0 
07d4			; byte 2 - extent count 
07d4			; byte 3 -> file name and meta data 
07d4			 
07d4			 
07d4			storage_create: 
07d4				if DEBUG_STORESE 
07d4					DMARK "SCR" 
07d4 f5				push af  
07d5 3a e9 07			ld a, (.dmark)  
07d8 32 b4 fe			ld (debug_mark),a  
07db 3a ea 07			ld a, (.dmark+1)  
07de 32 b5 fe			ld (debug_mark+1),a  
07e1 3a eb 07			ld a, (.dmark+2)  
07e4 32 b6 fe			ld (debug_mark+2),a  
07e7 18 03			jr .pastdmark  
07e9 ..			.dmark: db "SCR"  
07ec f1			.pastdmark: pop af  
07ed			endm  
# End of macro DMARK
07ed					CALLMONITOR 
07ed cd 78 18			call break_point_state  
07f0				endm  
# End of macro CALLMONITOR
07f0				endif 
07f0			 
07f0 e5				push hl		; save file name pointer 
07f1			 
07f1 cd 82 04			call storage_get_block_0 
07f4			 
07f4 3a 07 fc			ld a,(store_page)	; get current file id 
07f7 3c				inc a 
07f8 32 07 fc			ld (store_page),a 
07fb				 
07fb 32 fb fb			ld (store_tmpid),a			; save id 
07fe			 
07fe 21 00 00			ld hl, 0 
0801 11 07 fc			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCw" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 b4 fe			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 b5 fe			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 b6 fe			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCw"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					CALLMONITOR 
081d cd 78 18			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 36 04			call storage_write_block	 ; save update 
0823			 
0823				if DEBUG_STORESE 
0823 11 07 fc				ld de, store_page 
0826					DMARK "SCC" 
0826 f5				push af  
0827 3a 3b 08			ld a, (.dmark)  
082a 32 b4 fe			ld (debug_mark),a  
082d 3a 3c 08			ld a, (.dmark+1)  
0830 32 b5 fe			ld (debug_mark+1),a  
0833 3a 3d 08			ld a, (.dmark+2)  
0836 32 b6 fe			ld (debug_mark+2),a  
0839 18 03			jr .pastdmark  
083b ..			.dmark: db "SCC"  
083e f1			.pastdmark: pop af  
083f			endm  
# End of macro DMARK
083f					CALLMONITOR 
083f cd 78 18			call break_point_state  
0842				endm  
# End of macro CALLMONITOR
0842				endif 
0842				;  
0842				 
0842 21 40 00			ld hl, STORE_BLOCK_PHY 
0845 11 00 00			ld de, 0 
0848 cd 04 07			call storage_findnextid 
084b			 
084b 22 f4 fb			ld (store_tmppageid), hl    ; save page to use  
084e			 
084e				; TODO detect 0 = no spare blocks 
084e			 
084e				; hl now contains the free page to use for the file header page 
084e			 
084e				if DEBUG_STORESE 
084e				DMARK "SCF" 
084e f5				push af  
084f 3a 63 08			ld a, (.dmark)  
0852 32 b4 fe			ld (debug_mark),a  
0855 3a 64 08			ld a, (.dmark+1)  
0858 32 b5 fe			ld (debug_mark+1),a  
085b 3a 65 08			ld a, (.dmark+2)  
085e 32 b6 fe			ld (debug_mark+2),a  
0861 18 03			jr .pastdmark  
0863 ..			.dmark: db "SCF"  
0866 f1			.pastdmark: pop af  
0867			endm  
# End of macro DMARK
0867					CALLMONITOR 
0867 cd 78 18			call break_point_state  
086a				endm  
# End of macro CALLMONITOR
086a				endif 
086a			 
086a 22 f4 fb			ld (store_tmppageid), hl 
086d				 
086d 3a fb fb			ld a,(store_tmpid)    ; get file id 
0870			;	ld a, (store_filecache)			; save to cache 
0870			 
0870 32 07 fc			ld (store_page),a    ; set page id 
0873 3e 00			ld a, 0			 ; extent 0 is file header 
0875 32 08 fc			ld (store_page+1), a   ; set file extent 
0878			 
0878 32 09 fc			ld (store_page+2), a   ; extent count for the file 
087b			 
087b			;	inc hl 		; init block 0 of file 
087b			;	inc hl   		; skip file and extent id 
087b			 ;       ld a, 0 
087b			;	ld (hl),a 
087b			;	ld a, (store_filecache+1)  	; save to cache 
087b			 
087b			;	inc hl    ; file name 
087b				 
087b				 
087b 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
087e				if DEBUG_STORESE 
087e					DMARK "SCc" 
087e f5				push af  
087f 3a 93 08			ld a, (.dmark)  
0882 32 b4 fe			ld (debug_mark),a  
0885 3a 94 08			ld a, (.dmark+1)  
0888 32 b5 fe			ld (debug_mark+1),a  
088b 3a 95 08			ld a, (.dmark+2)  
088e 32 b6 fe			ld (debug_mark+2),a  
0891 18 03			jr .pastdmark  
0893 ..			.dmark: db "SCc"  
0896 f1			.pastdmark: pop af  
0897			endm  
# End of macro DMARK
0897					CALLMONITOR 
0897 cd 78 18			call break_point_state  
089a				endm  
# End of macro CALLMONITOR
089a				endif 
089a e1				pop hl    ; get zero term string 
089b e5				push hl 
089c 3e 00			ld a, 0 
089e cd 64 13			call strlent 
08a1 23				inc hl   ; cover zero term 
08a2 06 00			ld b,0 
08a4 4d				ld c,l 
08a5 e1				pop hl 
08a6				;ex de, hl 
08a6				if DEBUG_STORESE 
08a6					DMARK "SCa" 
08a6 f5				push af  
08a7 3a bb 08			ld a, (.dmark)  
08aa 32 b4 fe			ld (debug_mark),a  
08ad 3a bc 08			ld a, (.dmark+1)  
08b0 32 b5 fe			ld (debug_mark+1),a  
08b3 3a bd 08			ld a, (.dmark+2)  
08b6 32 b6 fe			ld (debug_mark+2),a  
08b9 18 03			jr .pastdmark  
08bb ..			.dmark: db "SCa"  
08be f1			.pastdmark: pop af  
08bf			endm  
# End of macro DMARK
08bf					;push af 
08bf					;ld a, 'a' 
08bf					;ld (debug_mark),a 
08bf					;pop af 
08bf					CALLMONITOR 
08bf cd 78 18			call break_point_state  
08c2				endm  
# End of macro CALLMONITOR
08c2				endif 
08c2 ed b0			ldir    ; copy zero term string 
08c4				if DEBUG_STORESE 
08c4					DMARK "SCA" 
08c4 f5				push af  
08c5 3a d9 08			ld a, (.dmark)  
08c8 32 b4 fe			ld (debug_mark),a  
08cb 3a da 08			ld a, (.dmark+1)  
08ce 32 b5 fe			ld (debug_mark+1),a  
08d1 3a db 08			ld a, (.dmark+2)  
08d4 32 b6 fe			ld (debug_mark+2),a  
08d7 18 03			jr .pastdmark  
08d9 ..			.dmark: db "SCA"  
08dc f1			.pastdmark: pop af  
08dd			endm  
# End of macro DMARK
08dd					CALLMONITOR 
08dd cd 78 18			call break_point_state  
08e0				endm  
# End of macro CALLMONITOR
08e0				endif 
08e0			 
08e0				; write file header page 
08e0			 
08e0 2a f4 fb			ld hl,(store_tmppageid) 
08e3 11 07 fc			ld de, store_page 
08e6				if DEBUG_STORESE 
08e6					DMARK "SCb" 
08e6 f5				push af  
08e7 3a fb 08			ld a, (.dmark)  
08ea 32 b4 fe			ld (debug_mark),a  
08ed 3a fc 08			ld a, (.dmark+1)  
08f0 32 b5 fe			ld (debug_mark+1),a  
08f3 3a fd 08			ld a, (.dmark+2)  
08f6 32 b6 fe			ld (debug_mark+2),a  
08f9 18 03			jr .pastdmark  
08fb ..			.dmark: db "SCb"  
08fe f1			.pastdmark: pop af  
08ff			endm  
# End of macro DMARK
08ff					;push af 
08ff					;ld a, 'b' 
08ff					;ld (debug_mark),a 
08ff					;pop af 
08ff					CALLMONITOR 
08ff cd 78 18			call break_point_state  
0902				endm  
# End of macro CALLMONITOR
0902				endif 
0902 cd 36 04			call storage_write_block 
0905			 
0905 3a fb fb			ld a, (store_tmpid) 
0908 6f				ld l, a 
0909 26 00			ld h,0 
090b				if DEBUG_STORESE 
090b					DMARK "SCz" 
090b f5				push af  
090c 3a 20 09			ld a, (.dmark)  
090f 32 b4 fe			ld (debug_mark),a  
0912 3a 21 09			ld a, (.dmark+1)  
0915 32 b5 fe			ld (debug_mark+1),a  
0918 3a 22 09			ld a, (.dmark+2)  
091b 32 b6 fe			ld (debug_mark+2),a  
091e 18 03			jr .pastdmark  
0920 ..			.dmark: db "SCz"  
0923 f1			.pastdmark: pop af  
0924			endm  
# End of macro DMARK
0924					CALLMONITOR 
0924 cd 78 18			call break_point_state  
0927				endm  
# End of macro CALLMONITOR
0927				endif 
0927 c9				ret 
0928				 
0928			 
0928			 
0928			; 
0928			; Read File 
0928			; 
0928			; h - file id to locate 
0928			; l - extent to locate 
0928			; de - pointer to string to read into 
0928			; 
0928			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0928			 
0928			.sr_fail: 
0928 d1				pop de 
0929 c9				ret 
092a			 
092a			storage_read: 
092a			 
092a			 
092a d5				push de 
092b			 
092b			; TODO BUG the above push is it popped before the RET Z? 
092b			 
092b			; TODO how to handle multiple part blocks 
092b			 
092b				; locate file extent to read 
092b			 
092b 5c				ld e, h 
092c 55				ld d, l 
092d			 
092d			.srext: 
092d 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0930 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
0934			 
0934 21 40 00			ld hl, STORE_BLOCK_PHY 
0937				if DEBUG_STORESE 
0937					DMARK "sre" 
0937 f5				push af  
0938 3a 4c 09			ld a, (.dmark)  
093b 32 b4 fe			ld (debug_mark),a  
093e 3a 4d 09			ld a, (.dmark+1)  
0941 32 b5 fe			ld (debug_mark+1),a  
0944 3a 4e 09			ld a, (.dmark+2)  
0947 32 b6 fe			ld (debug_mark+2),a  
094a 18 03			jr .pastdmark  
094c ..			.dmark: db "sre"  
094f f1			.pastdmark: pop af  
0950			endm  
# End of macro DMARK
0950					CALLMONITOR 
0950 cd 78 18			call break_point_state  
0953				endm  
# End of macro CALLMONITOR
0953				endif 
0953 cd 04 07			call storage_findnextid 
0956			 
0956				if DEBUG_STORESE 
0956					DMARK "srf" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 b4 fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 b5 fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 b6 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "srf"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd 78 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 cd 24 0f			call ishlzero 
0975			;	ld a, l 
0975			;	add h 
0975			;	cp 0 
0975 28 b1			jr z,.sr_fail			; block not found so EOF 
0977			 
0977				; hl contains page number to load 
0977 d1				pop de   ; get storage 
0978 ed 53 03 fc		ld (store_readbuf), de     ; current buffer to load in to 
097c d5				push de 
097d				if DEBUG_STORESE 
097d					DMARK "srg" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 b4 fe			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 b5 fe			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 b6 fe			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "srg"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd 78 18			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999 cd d1 03			call storage_read_block 
099c			 
099c				; if this a continuation read??? 
099c			 
099c 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
099f			 
099f 3e 3f			ld a, STORE_BLOCK_PHY-1 
09a1 cd fb 0e			call addatohl 
09a4 7e				ld a,(hl) 
09a5 fe 00			cp 0 
09a7 28 02			jr z, .markiscont 
09a9 3e ff			ld a, 255 
09ab			 
09ab			.markiscont: 
09ab 32 fa fb			ld (store_readcont), a 
09ae			 
09ae				if DEBUG_STORESE 
09ae					DMARK "srC" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 b4 fe			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 b5 fe			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 b6 fe			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "srC"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd 78 18			call break_point_state  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca				; only short reads enabled 
09ca			 
09ca 3a 02 fc			ld a, (store_longread) 
09cd fe 00			cp 0 
09cf ca 99 0a			jp z, .readdone 
09d2			 
09d2			; TODO if block has no zeros then need to read next block  
09d2			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
09d2			; check last byte of physical block. 
09d2			; if not zero then the next block needs to be loaded 
09d2			 
09d2			 
09d2 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09d5			 
09d5 3e 3f			ld a, STORE_BLOCK_PHY-1 
09d7 cd fb 0e			call addatohl 
09da				;dec hl 
09da 7e				ld a,(hl) 
09db				if DEBUG_STORESE 
09db					DMARK "sr?" 
09db f5				push af  
09dc 3a f0 09			ld a, (.dmark)  
09df 32 b4 fe			ld (debug_mark),a  
09e2 3a f1 09			ld a, (.dmark+1)  
09e5 32 b5 fe			ld (debug_mark+1),a  
09e8 3a f2 09			ld a, (.dmark+2)  
09eb 32 b6 fe			ld (debug_mark+2),a  
09ee 18 03			jr .pastdmark  
09f0 ..			.dmark: db "sr?"  
09f3 f1			.pastdmark: pop af  
09f4			endm  
# End of macro DMARK
09f4					CALLMONITOR 
09f4 cd 78 18			call break_point_state  
09f7				endm  
# End of macro CALLMONITOR
09f7				endif 
09f7 fe 00			cp 0 
09f9 ca 99 0a			jp z, .readdone 
09fc			 
09fc				; last byte is not zero so there is more in the next extent. Load it on the end.	 
09fc			 
09fc 23				inc hl 
09fd			 
09fd 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a00			 
0a00 ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
0a04			 
0a04 eb				ex de, hl 
0a05			 
0a05				; next ext 
0a05			 
0a05 23				inc hl 
0a06 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
0a09			 
0a09				if DEBUG_STORESE 
0a09					DMARK "sF2" 
0a09 f5				push af  
0a0a 3a 1e 0a			ld a, (.dmark)  
0a0d 32 b4 fe			ld (debug_mark),a  
0a10 3a 1f 0a			ld a, (.dmark+1)  
0a13 32 b5 fe			ld (debug_mark+1),a  
0a16 3a 20 0a			ld a, (.dmark+2)  
0a19 32 b6 fe			ld (debug_mark+2),a  
0a1c 18 03			jr .pastdmark  
0a1e ..			.dmark: db "sF2"  
0a21 f1			.pastdmark: pop af  
0a22			endm  
# End of macro DMARK
0a22					CALLMONITOR 
0a22 cd 78 18			call break_point_state  
0a25				endm  
# End of macro CALLMONITOR
0a25				endif 
0a25			 
0a25				; get and load block 
0a25			 
0a25 cd 04 07			call storage_findnextid 
0a28			 
0a28				if DEBUG_STORESE 
0a28					DMARK "sf2" 
0a28 f5				push af  
0a29 3a 3d 0a			ld a, (.dmark)  
0a2c 32 b4 fe			ld (debug_mark),a  
0a2f 3a 3e 0a			ld a, (.dmark+1)  
0a32 32 b5 fe			ld (debug_mark+1),a  
0a35 3a 3f 0a			ld a, (.dmark+2)  
0a38 32 b6 fe			ld (debug_mark+2),a  
0a3b 18 03			jr .pastdmark  
0a3d ..			.dmark: db "sf2"  
0a40 f1			.pastdmark: pop af  
0a41			endm  
# End of macro DMARK
0a41					CALLMONITOR 
0a41 cd 78 18			call break_point_state  
0a44				endm  
# End of macro CALLMONITOR
0a44				endif 
0a44 cd 24 0f			call ishlzero 
0a47			;	ld a, l 
0a47			;	add h 
0a47			;	cp 0 
0a47 ca 28 09			jp z,.sr_fail			; block not found so EOF 
0a4a				 
0a4a cd d1 03			call storage_read_block 
0a4d			 
0a4d				; on a continuation block, we now have the file id and ext in the middle of the block 
0a4d				; we need to pull everything back  
0a4d			 
0a4d ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a51 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0a54 23				inc hl 
0a55 23				inc hl     ; skip id and ext 
0a56 01 40 00			ld bc, STORE_BLOCK_PHY 
0a59				if DEBUG_STORESE 
0a59					DMARK "SR<" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 b4 fe			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 b5 fe			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 b6 fe			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "SR<"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 78 18			call break_point_state  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75 ed b0			ldir     ; copy data 
0a77			 
0a77				; move the pointer back and pretend we have a full buffer for next recheck 
0a77			 
0a77 1b				dec de 
0a78 1b				dec de 
0a79			 
0a79			; TODO do pop below now short circuit loop????? 
0a79 c1				pop bc     ; get rid of spare de on stack 
0a7a				if DEBUG_STORESE 
0a7a					DMARK "SR>" 
0a7a f5				push af  
0a7b 3a 8f 0a			ld a, (.dmark)  
0a7e 32 b4 fe			ld (debug_mark),a  
0a81 3a 90 0a			ld a, (.dmark+1)  
0a84 32 b5 fe			ld (debug_mark+1),a  
0a87 3a 91 0a			ld a, (.dmark+2)  
0a8a 32 b6 fe			ld (debug_mark+2),a  
0a8d 18 03			jr .pastdmark  
0a8f ..			.dmark: db "SR>"  
0a92 f1			.pastdmark: pop af  
0a93			endm  
# End of macro DMARK
0a93					CALLMONITOR 
0a93 cd 78 18			call break_point_state  
0a96				endm  
# End of macro CALLMONITOR
0a96				endif 
0a96 c3 2d 09			jp .srext 
0a99			 
0a99			 
0a99			 
0a99			 
0a99			 
0a99			.readdone:		 
0a99 e1				pop hl 		 ; return start of data to show as not EOF 
0a9a 23				inc hl   ; past file id 
0a9b 23				inc hl   ; past ext 
0a9c				if DEBUG_STORESE 
0a9c					DMARK "SRe" 
0a9c f5				push af  
0a9d 3a b1 0a			ld a, (.dmark)  
0aa0 32 b4 fe			ld (debug_mark),a  
0aa3 3a b2 0a			ld a, (.dmark+1)  
0aa6 32 b5 fe			ld (debug_mark+1),a  
0aa9 3a b3 0a			ld a, (.dmark+2)  
0aac 32 b6 fe			ld (debug_mark+2),a  
0aaf 18 03			jr .pastdmark  
0ab1 ..			.dmark: db "SRe"  
0ab4 f1			.pastdmark: pop af  
0ab5			endm  
# End of macro DMARK
0ab5					CALLMONITOR 
0ab5 cd 78 18			call break_point_state  
0ab8				endm  
# End of macro CALLMONITOR
0ab8				endif 
0ab8 c9					ret 
0ab9			 
0ab9			 
0ab9			 
0ab9			; 
0ab9			; Append File 
0ab9			; 
0ab9			; hl - file id to locate 
0ab9			; de - pointer to (multi block) string to write 
0ab9			 
0ab9			.sa_notfound: 
0ab9 d1				pop de 
0aba c9				ret 
0abb			 
0abb			 
0abb			storage_append: 
0abb				; hl -  file id to append to 
0abb				; de - string to append 
0abb			 
0abb d5				push de 
0abc				 
0abc				if DEBUG_STORESE 
0abc					DMARK "AP1" 
0abc f5				push af  
0abd 3a d1 0a			ld a, (.dmark)  
0ac0 32 b4 fe			ld (debug_mark),a  
0ac3 3a d2 0a			ld a, (.dmark+1)  
0ac6 32 b5 fe			ld (debug_mark+1),a  
0ac9 3a d3 0a			ld a, (.dmark+2)  
0acc 32 b6 fe			ld (debug_mark+2),a  
0acf 18 03			jr .pastdmark  
0ad1 ..			.dmark: db "AP1"  
0ad4 f1			.pastdmark: pop af  
0ad5			endm  
# End of macro DMARK
0ad5					CALLMONITOR 
0ad5 cd 78 18			call break_point_state  
0ad8				endm  
# End of macro CALLMONITOR
0ad8				endif 
0ad8			 
0ad8 7d				ld a, l 
0ad9 32 fb fb			ld (store_tmpid), a 
0adc			 
0adc				; get file header  
0adc			 
0adc 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0ade 3a fb fb			ld a, (store_tmpid) 
0ae1 5f				ld e, a 
0ae2			 
0ae2 21 40 00				ld hl, STORE_BLOCK_PHY 
0ae5 cd 04 07				call storage_findnextid 
0ae8			 
0ae8 cd 24 0f			call ishlzero 
0aeb 28 cc			jr z, .sa_notfound 
0aed			 
0aed 22 f4 fb			ld (store_tmppageid), hl 
0af0			 
0af0				; TODO handle file id not found 
0af0			 
0af0				if DEBUG_STORESE 
0af0					DMARK "AP2" 
0af0 f5				push af  
0af1 3a 05 0b			ld a, (.dmark)  
0af4 32 b4 fe			ld (debug_mark),a  
0af7 3a 06 0b			ld a, (.dmark+1)  
0afa 32 b5 fe			ld (debug_mark+1),a  
0afd 3a 07 0b			ld a, (.dmark+2)  
0b00 32 b6 fe			ld (debug_mark+2),a  
0b03 18 03			jr .pastdmark  
0b05 ..			.dmark: db "AP2"  
0b08 f1			.pastdmark: pop af  
0b09			endm  
# End of macro DMARK
0b09					CALLMONITOR 
0b09 cd 78 18			call break_point_state  
0b0c				endm  
# End of macro CALLMONITOR
0b0c				endif 
0b0c			 
0b0c				; update file extent count 
0b0c			 
0b0c 11 07 fc			ld de, store_page 
0b0f			 
0b0f cd d1 03			call storage_read_block 
0b12			 
0b12				if DEBUG_STORESE 
0b12					DMARK "AP3" 
0b12 f5				push af  
0b13 3a 27 0b			ld a, (.dmark)  
0b16 32 b4 fe			ld (debug_mark),a  
0b19 3a 28 0b			ld a, (.dmark+1)  
0b1c 32 b5 fe			ld (debug_mark+1),a  
0b1f 3a 29 0b			ld a, (.dmark+2)  
0b22 32 b6 fe			ld (debug_mark+2),a  
0b25 18 03			jr .pastdmark  
0b27 ..			.dmark: db "AP3"  
0b2a f1			.pastdmark: pop af  
0b2b			endm  
# End of macro DMARK
0b2b					CALLMONITOR 
0b2b cd 78 18			call break_point_state  
0b2e				endm  
# End of macro CALLMONITOR
0b2e				endif 
0b2e			;	ld (store_tmppageid), hl 
0b2e			 
0b2e 3a 09 fc			ld a, (store_page+2) 
0b31 3c				inc a 
0b32 32 09 fc			ld (store_page+2), a 
0b35 32 fa fb			ld (store_tmpext), a 
0b38				 
0b38				if DEBUG_STORESE 
0b38					DMARK "AP3" 
0b38 f5				push af  
0b39 3a 4d 0b			ld a, (.dmark)  
0b3c 32 b4 fe			ld (debug_mark),a  
0b3f 3a 4e 0b			ld a, (.dmark+1)  
0b42 32 b5 fe			ld (debug_mark+1),a  
0b45 3a 4f 0b			ld a, (.dmark+2)  
0b48 32 b6 fe			ld (debug_mark+2),a  
0b4b 18 03			jr .pastdmark  
0b4d ..			.dmark: db "AP3"  
0b50 f1			.pastdmark: pop af  
0b51			endm  
# End of macro DMARK
0b51					CALLMONITOR 
0b51 cd 78 18			call break_point_state  
0b54				endm  
# End of macro CALLMONITOR
0b54				endif 
0b54 2a f4 fb			ld hl, (store_tmppageid) 
0b57 11 07 fc			ld de, store_page 
0b5a cd 36 04			call storage_write_block 
0b5d			 
0b5d				; find free block 
0b5d			 
0b5d 11 00 00			ld de, 0			 ; file extent to locate 
0b60			 
0b60 21 40 00				ld hl, STORE_BLOCK_PHY 
0b63 cd 04 07				call storage_findnextid 
0b66 cd 24 0f			call ishlzero 
0b69 ca b9 0a			jp z, .sa_notfound 
0b6c			 
0b6c					; TODO handle no space left 
0b6c					 
0b6c 22 f4 fb				ld (store_tmppageid), hl 
0b6f			 
0b6f				if DEBUG_STORESE 
0b6f					DMARK "AP4" 
0b6f f5				push af  
0b70 3a 84 0b			ld a, (.dmark)  
0b73 32 b4 fe			ld (debug_mark),a  
0b76 3a 85 0b			ld a, (.dmark+1)  
0b79 32 b5 fe			ld (debug_mark+1),a  
0b7c 3a 86 0b			ld a, (.dmark+2)  
0b7f 32 b6 fe			ld (debug_mark+2),a  
0b82 18 03			jr .pastdmark  
0b84 ..			.dmark: db "AP4"  
0b87 f1			.pastdmark: pop af  
0b88			endm  
# End of macro DMARK
0b88					CALLMONITOR 
0b88 cd 78 18			call break_point_state  
0b8b				endm  
# End of macro CALLMONITOR
0b8b				endif 
0b8b					; init the buffer with zeros so we can id if the buffer is full or not 
0b8b			 
0b8b e5					push hl 
0b8c c5					push bc 
0b8d			 
0b8d 21 07 fc				ld hl, store_page 
0b90 06 40				ld b, STORE_BLOCK_PHY 
0b92 3e 00				ld a, 0 
0b94 77			.zeroblock:	ld (hl), a 
0b95 23					inc hl 
0b96 10 fc				djnz .zeroblock 
0b98			 
0b98 c1					pop bc 
0b99 e1					pop hl 
0b9a			 
0b9a					; construct block 
0b9a			 
0b9a 3a fb fb				ld a, (store_tmpid) 
0b9d 32 07 fc				ld (store_page), a   ; file id 
0ba0 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0ba3 32 08 fc				ld (store_page+1), a 
0ba6			 
0ba6 e1					pop hl    ; get string to write 
0ba7 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0ba9 11 09 fc				ld de, store_page+2 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP5" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 b4 fe			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 b5 fe			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 b6 fe			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP5"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd 78 18			call break_point_state  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			 
0bc8			 
0bc8			 
0bc8					; fill buffer with data until end of string or full block 
0bc8			 
0bc8 7e			.appd:		ld a, (hl) 
0bc9 12					ld (de), a 
0bca fe 00				cp 0 
0bcc 28 04				jr z, .appdone 
0bce 23					inc hl 
0bcf 13					inc de 
0bd0 10 f6				djnz .appd 
0bd2			 
0bd2 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0bd3 f5					push af   		; save last byte dumped 
0bd4			 
0bd4			 
0bd4 2a f4 fb			ld hl, (store_tmppageid) 
0bd7 11 07 fc			ld de, store_page 
0bda				if DEBUG_STORESE 
0bda					DMARK "AP6" 
0bda f5				push af  
0bdb 3a ef 0b			ld a, (.dmark)  
0bde 32 b4 fe			ld (debug_mark),a  
0be1 3a f0 0b			ld a, (.dmark+1)  
0be4 32 b5 fe			ld (debug_mark+1),a  
0be7 3a f1 0b			ld a, (.dmark+2)  
0bea 32 b6 fe			ld (debug_mark+2),a  
0bed 18 03			jr .pastdmark  
0bef ..			.dmark: db "AP6"  
0bf2 f1			.pastdmark: pop af  
0bf3			endm  
# End of macro DMARK
0bf3					CALLMONITOR 
0bf3 cd 78 18			call break_point_state  
0bf6				endm  
# End of macro CALLMONITOR
0bf6				endif 
0bf6 cd 36 04				call storage_write_block 
0bf9			 
0bf9			 
0bf9				; was that a full block of data written? 
0bf9				; any more to write out? 
0bf9			 
0bf9				; if yes then set vars and jump to start of function again 
0bf9			 
0bf9 f1					pop af 
0bfa d1					pop de 
0bfb			 
0bfb fe 00				cp 0		 ; no, string was fully written 
0bfd c8					ret z 
0bfe			 
0bfe					; setup vars for next cycle 
0bfe			 
0bfe 3a fb fb				ld a, (store_tmpid) 
0c01 6f					ld l, a 
0c02 26 00				ld h, 0 
0c04			 
0c04 c3 bb 0a			 	jp storage_append	 ; yes, need to write out some more 
0c07			 
0c07			 
0c07			 
0c07			 
0c07			 
0c07			 
0c07			 
0c07			if DEBUG_STORECF 
0c07			storageput:	 
0c07					ret 
0c07			storageread: 
0c07					ld hl, store_page 
0c07					ld b, 200 
0c07					ld a,0 
0c07			.src:		ld (hl),a 
0c07					inc hl 
0c07					djnz .src 
0c07					 
0c07			 
0c07					ld de, 0 
0c07					ld bc, 1 
0c07					ld hl, store_page 
0c07					call cfRead 
0c07			 
0c07				call cfGetError 
0c07				ld hl,scratch 
0c07				call hexout 
0c07				ld hl, scratch+2 
0c07				ld a, 0 
0c07				ld (hl),a 
0c07				ld de, scratch 
0c07				ld a,display_row_1 
0c07				call str_at_display 
0c07				call update_display 
0c07			 
0c07					ld hl, store_page 
0c07					ld (os_cur_ptr),hl 
0c07			 
0c07					ret 
0c07			endif 
0c07			 
0c07			 
0c07			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c07			 
0c07			storage_clear_page: 
0c07 e5				push hl 
0c08 d5				push de 
0c09 c5				push bc 
0c0a 21 07 fc			ld hl, store_page 
0c0d 3e 00			ld a, 0 
0c0f 77				ld (hl), a 
0c10			 
0c10 11 08 fc			ld de, store_page+1 
0c13 01 18 01			ld bc, STORE_BLOCK_LOG 
0c16			 
0c16 ed b0			ldir 
0c18				 
0c18 c1				pop bc 
0c19 d1				pop de 
0c1a e1				pop hl 
0c1b c9				ret 
0c1c			 
0c1c			; eof 
# End of file firmware_storage.asm
0c1c			  
0c1c			; support routines for above hardware abstraction layer  
0c1c			  
0c1c			include "firmware_general.asm"        ; general support functions  
0c1c			 
0c1c			; word look up 
0c1c			 
0c1c			; in 
0c1c			; a is the index 
0c1c			; hl is pointer start of array 
0c1c			; 
0c1c			; returns 
0c1c			; hl to the word 
0c1c			; 
0c1c			 
0c1c			table_lookup:  
0c1c d5					push de 
0c1d eb					ex de, hl 
0c1e			 
0c1e 6f					ld l, a 
0c1f 26 00				ld h, 0 
0c21 29					add hl, hl 
0c22 19					add hl, de 
0c23 7e					ld a, (hl) 
0c24 23					inc hl 
0c25 66					ld h,(hl) 
0c26 6f					ld l, a 
0c27			 
0c27 d1					pop de 
0c28 c9					ret 
0c29			 
0c29			; Delay loops 
0c29			 
0c29			 
0c29			 
0c29			aDelayInMS: 
0c29 c5				push bc 
0c2a 47				ld b,a 
0c2b			msdelay: 
0c2b c5				push bc 
0c2c				 
0c2c			 
0c2c 01 41 00			ld bc,041h 
0c2f cd 47 0c			call delayloop 
0c32 c1				pop bc 
0c33 05				dec b 
0c34 20 f5			jr nz,msdelay 
0c36			 
0c36			;if CPU_CLOCK_8MHZ 
0c36			;msdelay8: 
0c36			;	push bc 
0c36			;	 
0c36			; 
0c36			;	ld bc,041h 
0c36			;	call delayloop 
0c36			;	pop bc 
0c36			;	dec b 
0c36			;	jr nz,msdelay8 
0c36			;endif 
0c36			 
0c36			 
0c36 c1				pop bc 
0c37 c9				ret 
0c38			 
0c38			 
0c38			delay250ms: 
0c38				;push de 
0c38 01 00 40			ld bc, 04000h 
0c3b c3 47 0c			jp delayloop 
0c3e			delay500ms: 
0c3e				;push de 
0c3e 01 00 80			ld bc, 08000h 
0c41 c3 47 0c			jp delayloop 
0c44			delay1s: 
0c44				;push bc 
0c44			   ; Clobbers A, d and e 
0c44 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c47			delayloop: 
0c47 c5			    push bc 
0c48			 
0c48			if BASE_CPM 
0c48				ld bc, CPM_DELAY_TUNE 
0c48			.cpmloop: 
0c48				push bc 
0c48			 
0c48			endif 
0c48			 
0c48			 
0c48			 
0c48			delayloopi: 
0c48			;	push bc 
0c48			;.dl: 
0c48 cb 47		    bit     0,a    	; 8 
0c4a cb 47		    bit     0,a    	; 8 
0c4c cb 47		    bit     0,a    	; 8 
0c4e e6 ff		    and     255  	; 7 
0c50 0b			    dec     bc      	; 6 
0c51 79			    ld      a,c     	; 4 
0c52 b0			    or      b     	; 4 
0c53 c2 48 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0c56			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0c56				;pop de 
0c56			;pop bc 
0c56			 
0c56			if BASE_CPM 
0c56				pop bc 
0c56				 
0c56			    dec     bc      	; 6 
0c56			    ld      a,c     	; 4 
0c56			    or      b     	; 4 
0c56			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0c56				 
0c56			 
0c56			endif 
0c56			;if CPU_CLOCK_8MHZ 
0c56			;    pop bc 
0c56			;    push bc 
0c56			;.dl8: 
0c56			;    bit     0,a    	; 8 
0c56			;    bit     0,a    	; 8 
0c56			;    bit     0,a    	; 8 
0c56			;    and     255  	; 7 
0c56			;    dec     bc      	; 6 
0c56			;    ld      a,c     	; 4 
0c56			;    or      b     	; 4 
0c56			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c56			;endif 
0c56			 
0c56			;if CPU_CLOCK_10MHZ 
0c56			;    pop bc 
0c56			;    push bc 
0c56			;.dl8: 
0c56			;    bit     0,a    	; 8 
0c56			;    bit     0,a    	; 8 
0c56			;    bit     0,a    	; 8 
0c56			;    and     255  	; 7 
0c56			;    dec     bc      	; 6 
0c56			;    ld      a,c     	; 4 
0c56			;    or      b     	; 4 
0c56			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c56			;endif 
0c56 c1			    pop bc 
0c57			 
0c57 c9				ret 
0c58			 
0c58			 
0c58			 
0c58			; eof 
# End of file firmware_general.asm
0c58			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0c58			; display routines that use the physical hardware abstraction layer 
0c58			 
0c58			 
0c58			; information window 
0c58			 
0c58			; pass hl with 1st string to display 
0c58			; pass de with 2nd string to display 
0c58			 
0c58			info_panel: 
0c58 e5				push hl 
0c59			 
0c59 2a 55 fd			ld hl, (display_fb_active) 
0c5c e5				push hl    ; future de destination 
0c5d 21 4a fe				ld hl, display_fb0 
0c60 22 55 fd				ld (display_fb_active), hl 
0c63			 
0c63			;	call clear_display 
0c63			 
0c63				if BASE_CPM 
0c63				ld a, '.' 
0c63				else 
0c63 3e a5			ld a, 165 
0c65				endif 
0c65 cd cc 0c			call fill_display 
0c68			 
0c68			 
0c68 3e 2d			ld a, display_row_3 + 5 
0c6a cd da 0c			call str_at_display 
0c6d			 
0c6d e1				pop hl 
0c6e d1				pop de 
0c6f			 
0c6f e5				push hl 
0c70			 
0c70			 
0c70 3e 19			ld a, display_row_2 + 5 
0c72 cd da 0c			call str_at_display 
0c75			 
0c75			 
0c75 cd ea 0c			call update_display 
0c78 cd 64 1e			call next_page_prompt 
0c7b cd c7 0c			call clear_display 
0c7e			 
0c7e				 
0c7e 21 f9 fd				ld hl, display_fb1 
0c81 22 55 fd				ld (display_fb_active), hl 
0c84 cd ea 0c			call update_display 
0c87			 
0c87 e1				pop hl 
0c88			 
0c88 c9				ret 
0c89			 
0c89			 
0c89			 
0c89			 
0c89			; TODO windowing? 
0c89			 
0c89			; TODO scroll line up 
0c89			 
0c89			scroll_up: 
0c89			 
0c89 e5				push hl 
0c8a d5				push de 
0c8b c5				push bc 
0c8c			 
0c8c				; get frame buffer  
0c8c			 
0c8c 2a 55 fd			ld hl, (display_fb_active) 
0c8f e5				push hl    ; future de destination 
0c90			 
0c90 11 14 00			ld  de, display_cols 
0c93 19				add hl, de 
0c94			 
0c94 d1				pop de 
0c95			 
0c95				;ex de, hl 
0c95 01 4f 00			ld bc, display_fb_len -1  
0c98			;if DEBUG_FORTH_WORDS 
0c98			;	DMARK "SCL" 
0c98			;	CALLMONITOR 
0c98			;endif	 
0c98 ed b0			ldir 
0c9a			 
0c9a				; wipe bottom row 
0c9a			 
0c9a			 
0c9a 2a 55 fd			ld hl, (display_fb_active) 
0c9d 11 50 00			ld de, display_cols*display_rows 
0ca0 19				add hl, de 
0ca1 06 14			ld b, display_cols 
0ca3 3e 20			ld a, ' ' 
0ca5			.scwipe: 
0ca5 77				ld (hl), a 
0ca6 2b				dec hl 
0ca7 10 fc			djnz .scwipe 
0ca9			 
0ca9				;pop hl 
0ca9			 
0ca9 c1				pop bc 
0caa d1				pop de 
0cab e1				pop hl 
0cac			 
0cac c9				ret 
0cad			 
0cad			 
0cad			;scroll_upo: 
0cad			;	ld de, display_row_1 
0cad			 ;	ld hl, display_row_2 
0cad			;	ld bc, display_cols 
0cad			;	ldir 
0cad			;	ld de, display_row_2 
0cad			 ;	ld hl, display_row_3 
0cad			;	ld bc, display_cols 
0cad			;	ldir 
0cad			;	ld de, display_row_3 
0cad			 ;	ld hl, display_row_4 
0cad			;	ld bc, display_cols 
0cad			;	ldir 
0cad			 
0cad			; TODO clear row 4 
0cad			 
0cad			;	ret 
0cad			 
0cad				 
0cad			scroll_down: 
0cad			 
0cad e5				push hl 
0cae d5				push de 
0caf c5				push bc 
0cb0			 
0cb0				; get frame buffer  
0cb0			 
0cb0 2a 55 fd			ld hl, (display_fb_active) 
0cb3			 
0cb3 11 4f 00			ld de, display_fb_len - 1 
0cb6 19				add hl, de 
0cb7			 
0cb7 e5			push hl    ; future de destination 
0cb8			 
0cb8 11 14 00			ld  de, display_cols 
0cbb ed 52			sbc hl, de 
0cbd			 
0cbd			 
0cbd d1				pop de 
0cbe			 
0cbe			;	ex de, hl 
0cbe 01 4f 00			ld bc, display_fb_len -1  
0cc1			 
0cc1			 
0cc1				 
0cc1			 
0cc1 ed b0			ldir 
0cc3			 
0cc3				; wipe bottom row 
0cc3			 
0cc3			 
0cc3			;	ld hl, (display_fb_active) 
0cc3			;;	ld de, display_cols*display_rows 
0cc3			;;	add hl, de 
0cc3			;	ld b, display_cols 
0cc3			;	ld a, ' ' 
0cc3			;.scwiped: 
0cc3			;	ld (hl), a 
0cc3			;	dec hl 
0cc3			;	djnz .scwiped 
0cc3			 
0cc3				;pop hl 
0cc3			 
0cc3 c1				pop bc 
0cc4 d1				pop de 
0cc5 e1				pop hl 
0cc6			 
0cc6 c9				ret 
0cc7			;scroll_down: 
0cc7			;	ld de, display_row_4 
0cc7			;	ld hl, display_row_3 
0cc7			;	ld bc, display_cols 
0cc7			;	ldir 
0cc7			;	ld de, display_row_3 
0cc7			; 	ld hl, display_row_2 
0cc7			;	ld bc, display_cols 
0cc7			;	ldir 
0cc7			;	ld de, display_row_2 
0cc7			;	ld hl, display_row_1 
0cc7			;	ld bc, display_cols 
0cc7			;	ldir 
0cc7			;;; TODO clear row 1 
0cc7			;	ret 
0cc7			 
0cc7			 
0cc7			 
0cc7			 
0cc7			 
0cc7			; clear active frame buffer 
0cc7			 
0cc7			clear_display: 
0cc7 3e 20			ld a, ' ' 
0cc9 c3 cc 0c			jp fill_display 
0ccc			 
0ccc			; fill active frame buffer with a char in A 
0ccc			 
0ccc			fill_display: 
0ccc 06 50			ld b,display_fb_len 
0cce 2a 55 fd			ld hl, (display_fb_active) 
0cd1 77			.fd1:	ld (hl),a 
0cd2 23				inc hl 
0cd3 10 fc			djnz .fd1 
0cd5 23				inc hl 
0cd6 3e 00			ld a,0 
0cd8 77				ld (hl),a 
0cd9			 
0cd9			 
0cd9 c9				ret 
0cda			; Write string (DE) at pos (A) to active frame buffer 
0cda			 
0cda 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0cdd 06 00					ld b,0 
0cdf 4f					ld c,a 
0ce0 09					add hl,bc 
0ce1 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ce2 b7			            OR   A              ;Null terminator? 
0ce3 c8			            RET  Z              ;Yes, so finished 
0ce4 77					ld (hl),a 
0ce5 23				inc hl 
0ce6 13			            INC  DE             ;Point to next character 
0ce7 18 f8		            JR   .sad1     ;Repeat 
0ce9 c9					ret 
0cea			 
0cea			; using current frame buffer write to physical display 
0cea			 
0cea			update_display: 
0cea e5				push hl 
0ceb 2a 55 fd			ld hl, (display_fb_active) 
0cee cd 80 69			call write_display 
0cf1 e1				pop hl 
0cf2 c9				ret 
0cf3			 
0cf3			; TODO scrolling 
0cf3			 
0cf3			 
0cf3			; move cursor right one char 
0cf3			cursor_right: 
0cf3			 
0cf3				; TODO shift right 
0cf3				; TODO if beyond max col 
0cf3				; TODO       cursor_next_line 
0cf3			 
0cf3 c9				ret 
0cf4			 
0cf4			 
0cf4			cursor_next_line: 
0cf4				; TODO first char 
0cf4				; TODO line down 
0cf4				; TODO if past last row 
0cf4				; TODO    scroll up 
0cf4			 
0cf4 c9				ret 
0cf5			 
0cf5			cursor_left: 
0cf5				; TODO shift left 
0cf5				; TODO if beyond left  
0cf5				; TODO     cursor prev line 
0cf5				 
0cf5 c9				ret 
0cf6			 
0cf6			cursor_prev_line: 
0cf6				; TODO last char 
0cf6				; TODO line up 
0cf6				; TODO if past first row 
0cf6				; TODO   scroll down 
0cf6			 
0cf6 c9				ret 
0cf7			 
0cf7			 
0cf7			cout: 
0cf7				; A - char 
0cf7 c9				ret 
0cf8			 
0cf8			 
0cf8			; Display a menu and allow item selection (optional toggle items) 
0cf8			; 
0cf8			; format: 
0cf8			; hl pointer to word array with zero term for items 
0cf8			; e.g.    db item1 
0cf8			;         db .... 
0cf8			;         db 0 
0cf8			; 
0cf8			; a = starting menu item  
0cf8			; 
0cf8			; de = pointer item toggle array   (todo) 
0cf8			; 
0cf8			; returns item selected in a 1-... 
0cf8			; returns 0 if back button pressed 
0cf8			; 
0cf8			; NOTE: Uses system frame buffer to display 
0cf8			; 
0cf8			; LEFT, Q = go back 
0cf8			; RIGHT, SPACE, CR = select 
0cf8			; UP, A - Up 
0cf8			; DOWN, Z - Down 
0cf8			 
0cf8			 
0cf8			 
0cf8			 
0cf8			 
0cf8			menu: 
0cf8			 
0cf8					; keep array pointer 
0cf8			 
0cf8 22 00 fc				ld (store_tmp1), hl 
0cfb 32 fe fb				ld (store_tmp2), a 
0cfe			 
0cfe					; check for key bounce 
0cfe			 
0cfe			if BASE_KEV 
0cfe			 
0cfe cd 35 6b		.mbounce:	call cin 
0d01 fe 00				cp 0 
0d03 20 f9				jr nz, .mbounce 
0d05			endif 
0d05					; for ease use ex 
0d05			 
0d05					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d05 21 4a fe				ld hl, display_fb0 
0d08 22 55 fd				ld (display_fb_active), hl 
0d0b			 
0d0b cd c7 0c		.mloop:		call clear_display 
0d0e cd ea 0c				call update_display 
0d11			 
0d11					; draw selection id '>' at 1 
0d11			 
0d11					; init start of list display 
0d11			 
0d11 3e 05				ld a, 5 
0d13 32 fc fb				ld (store_tmp3), a   ; display row count 
0d16 3a fe fb				ld a,( store_tmp2) 
0d19 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d1c			 
0d1c					 
0d1c			.mitem:	 
0d1c			 
0d1c			 
0d1c 3a ff fb				ld a,(store_tmp2+1) 
0d1f 6f					ld l, a 
0d20 26 00				ld h, 0 
0d22 29					add hl, hl 
0d23 ed 5b 00 fc			ld de, (store_tmp1) 
0d27 19					add hl, de 
0d28 7e					ld a, (hl) 
0d29 23					inc hl 
0d2a 66					ld h,(hl) 
0d2b 6f					ld l, a 
0d2c			 
0d2c cd 24 0f				call ishlzero 
0d2f 28 1a				jr z, .mdone 
0d31			 
0d31 eb					ex de, hl 
0d32 3a fc fb				ld a, (store_tmp3) 
0d35 cd da 0c				call str_at_display 
0d38					 
0d38			 
0d38					; next item 
0d38 3a ff fb				ld a, (store_tmp2+1) 
0d3b 3c					inc a 
0d3c 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d3f			 
0d3f			 		; next row 
0d3f			 
0d3f 3a fc fb				ld a, (store_tmp3) 
0d42 c6 14				add display_cols 
0d44 32 fc fb				ld (store_tmp3), a 
0d47			 
0d47					; at end of screen? 
0d47			 
0d47 fe 10				cp display_rows*4 
0d49 20 d1				jr nz, .mitem 
0d4b			 
0d4b			 
0d4b			.mdone: 
0d4b cd 24 0f				call ishlzero 
0d4e 28 08				jr z, .nodn 
0d50			 
0d50 3e 3c				ld a, display_row_4 
0d52 11 d1 0d				ld de, .mdown 
0d55 cd da 0c				call str_at_display 
0d58			 
0d58					; draw options to fill the screens with active item on line 1 
0d58					; if current option is 2 or more then display ^ in top 
0d58			 
0d58 3a fe fb		.nodn:		ld a, (store_tmp2) 
0d5b fe 00				cp 0 
0d5d 28 08				jr z, .noup 
0d5f			 
0d5f 3e 00				ld a, 0 
0d61 11 cf 0d				ld de, .mup 
0d64 cd da 0c				call str_at_display 
0d67			 
0d67 3e 02		.noup:		ld a, 2 
0d69 11 cd 0d				ld de, .msel 
0d6c cd da 0c				call str_at_display 
0d6f			 
0d6f					; if current option + 1 is not null then display V in bottom 
0d6f					; get key 
0d6f cd ea 0c				call update_display 
0d72			 
0d72			 
0d72					; handle key 
0d72			 
0d72 cd 24 6b				call cin_wait 
0d75			 
0d75 fe 05				cp KEY_UP 
0d77 28 2b				jr z, .mgoup 
0d79 fe 61				cp 'a' 
0d7b 28 27				jr z, .mgoup 
0d7d fe 0a				cp KEY_DOWN 
0d7f 28 32				jr z, .mgod 
0d81 fe 7a				cp 'z' 
0d83 28 2e				jr z, .mgod 
0d85 fe 20				cp ' ' 
0d87 28 34				jr z, .goend 
0d89 fe 0c				cp KEY_RIGHT 
0d8b 28 30				jr z, .goend 
0d8d fe 0d				cp KEY_CR 
0d8f 28 2c				jr z, .goend 
0d91 fe 71				cp 'q' 
0d93 28 0b				jr z, .goback 
0d95			 
0d95 fe 0b				cp KEY_LEFT 
0d97 28 07				jr z, .goback 
0d99 fe 08				cp KEY_BS 
0d9b 28 03				jr z, .goback 
0d9d c3 0b 0d				jp .mloop 
0da0			 
0da0			.goback: 
0da0 3e 00			ld a, 0 
0da2 18 1d			jr .goend2 
0da4			 
0da4				; move up one 
0da4			.mgoup: 
0da4 3a fe fb				ld a, (store_tmp2) 
0da7 fe 00				cp 0 
0da9 ca 0b 0d				jp z, .mloop 
0dac 3d					dec a 
0dad 32 fe fb				ld (store_tmp2), a 
0db0 c3 0b 0d				jp .mloop 
0db3			 
0db3				; move down one 
0db3			.mgod: 
0db3 3a fe fb				ld a, (store_tmp2) 
0db6 3c					inc a 
0db7 32 fe fb				ld (store_tmp2), a 
0dba c3 0b 0d				jp .mloop 
0dbd			 
0dbd			 
0dbd			.goend: 
0dbd					; get selected item number 
0dbd			 
0dbd 3a fe fb				ld a, (store_tmp2) 
0dc0 3c					inc a 
0dc1			 
0dc1			.goend2: 
0dc1 f5					push af 
0dc2			 
0dc2					; restore active fb 
0dc2					; TODO BUG assumes fb1 
0dc2			 
0dc2 21 f9 fd				ld hl, display_fb1 
0dc5 22 55 fd				ld (display_fb_active), hl 
0dc8			 
0dc8					; restore main regs 
0dc8			 
0dc8			 
0dc8 cd ea 0c				call update_display 
0dcb			 
0dcb f1					pop af 
0dcc			 
0dcc c9				ret 
0dcd			 
0dcd .. 00		.msel:   db ">",0 
0dcf .. 00		.mup:   db "^",0 
0dd1 .. 00		.mdown:   db "v",0 
0dd3			 
0dd3			 
0dd3			; eof 
0dd3			 
# End of file firmware_display.asm
0dd3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0dd3			; random number generators 
0dd3			 
0dd3			 
0dd3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0dd3			 
0dd3			 
0dd3			;-----> Generate a random number 
0dd3			; output a=answer 0<=a<=255 
0dd3			; all registers are preserved except: af 
0dd3			random: 
0dd3 e5			        push    hl 
0dd4 d5			        push    de 
0dd5 2a 37 fd		        ld      hl,(randData) 
0dd8 ed 5f		        ld      a,r 
0dda 57			        ld      d,a 
0ddb 5e			        ld      e,(hl) 
0ddc 19			        add     hl,de 
0ddd 85			        add     a,l 
0dde ac			        xor     h 
0ddf 22 37 fd		        ld      (randData),hl 
0de2 d1			        pop     de 
0de3 e1			        pop     hl 
0de4 c9			        ret 
0de5			 
0de5			 
0de5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0de5			 
0de5			 
0de5			 
0de5			;------LFSR------ 
0de5			;James Montelongo 
0de5			;optimized by Spencer Putt 
0de5			;out: 
0de5			; a = 8 bit random number 
0de5			RandLFSR: 
0de5 21 3d fd		        ld hl,LFSRSeed+4 
0de8 5e			        ld e,(hl) 
0de9 23			        inc hl 
0dea 56			        ld d,(hl) 
0deb 23			        inc hl 
0dec 4e			        ld c,(hl) 
0ded 23			        inc hl 
0dee 7e			        ld a,(hl) 
0def 47			        ld b,a 
0df0 cb 13		        rl e  
0df2 cb 12			rl d 
0df4 cb 11		        rl c  
0df6 17				rla 
0df7 cb 13		        rl e  
0df9 cb 12			rl d 
0dfb cb 11		        rl c  
0dfd 17				rla 
0dfe cb 13		        rl e  
0e00 cb 12			rl d 
0e02 cb 11		        rl c  
0e04 17				rla 
0e05 67			        ld h,a 
0e06 cb 13		        rl e  
0e08 cb 12			rl d 
0e0a cb 11		        rl c  
0e0c 17				rla 
0e0d a8			        xor b 
0e0e cb 13		        rl e  
0e10 cb 12			rl d 
0e12 ac			        xor h 
0e13 a9			        xor c 
0e14 aa			        xor d 
0e15 21 3f fd		        ld hl,LFSRSeed+6 
0e18 11 40 fd		        ld de,LFSRSeed+7 
0e1b 01 07 00		        ld bc,7 
0e1e ed b8		        lddr 
0e20 12			        ld (de),a 
0e21 c9			        ret 
0e22			 
0e22			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e22			 
0e22			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e22			 
0e22			 
0e22			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e22			 
0e22			prng16: 
0e22			;Inputs: 
0e22			;   (seed1) contains a 16-bit seed value 
0e22			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e22			;Outputs: 
0e22			;   HL is the result 
0e22			;   BC is the result of the LCG, so not that great of quality 
0e22			;   DE is preserved 
0e22			;Destroys: 
0e22			;   AF 
0e22			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e22			;160cc 
0e22			;26 bytes 
0e22 2a 31 fd		    ld hl,(seed1) 
0e25 44			    ld b,h 
0e26 4d			    ld c,l 
0e27 29			    add hl,hl 
0e28 29			    add hl,hl 
0e29 2c			    inc l 
0e2a 09			    add hl,bc 
0e2b 22 31 fd		    ld (seed1),hl 
0e2e 2a 2f fd		    ld hl,(seed2) 
0e31 29			    add hl,hl 
0e32 9f			    sbc a,a 
0e33 e6 2d		    and %00101101 
0e35 ad			    xor l 
0e36 6f			    ld l,a 
0e37 22 2f fd		    ld (seed2),hl 
0e3a 09			    add hl,bc 
0e3b c9			    ret 
0e3c			 
0e3c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e3c			 
0e3c			rand32: 
0e3c			;Inputs: 
0e3c			;   (seed1_0) holds the lower 16 bits of the first seed 
0e3c			;   (seed1_1) holds the upper 16 bits of the first seed 
0e3c			;   (seed2_0) holds the lower 16 bits of the second seed 
0e3c			;   (seed2_1) holds the upper 16 bits of the second seed 
0e3c			;   **NOTE: seed2 must be non-zero 
0e3c			;Outputs: 
0e3c			;   HL is the result 
0e3c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e3c			;Destroys: 
0e3c			;   AF 
0e3c			;Tested and passes all CAcert tests 
0e3c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e3c			;it has a period of 18,446,744,069,414,584,320 
0e3c			;roughly 18.4 quintillion. 
0e3c			;LFSR taps: 0,2,6,7  = 11000101 
0e3c			;291cc 
0e3c			;seed1_0=$+1 
0e3c			;    ld hl,12345 
0e3c			;seed1_1=$+1 
0e3c			;    ld de,6789 
0e3c			;    ld b,h 
0e3c			;    ld c,l 
0e3c			;    add hl,hl \ rl e \ rl d 
0e3c			;    add hl,hl \ rl e \ rl d 
0e3c			;    inc l 
0e3c			;    add hl,bc 
0e3c			;    ld (seed1_0),hl 
0e3c			;    ld hl,(seed1_1) 
0e3c			;    adc hl,de 
0e3c			;    ld (seed1_1),hl 
0e3c			;    ex de,hl 
0e3c			;seed2_0=$+1 
0e3c			;    ld hl,9876 
0e3c			;seed2_1=$+1 
0e3c			;    ld bc,54321 
0e3c			;    add hl,hl \ rl c \ rl b 
0e3c			;    ld (seed2_1),bc 
0e3c			;    sbc a,a 
0e3c			;    and %11000101 
0e3c			;    xor l 
0e3c			;    ld l,a 
0e3c			;    ld (seed2_0),hl 
0e3c			;    ex de,hl 
0e3c			;    add hl,bc 
0e3c			;    ret 
0e3c			; 
0e3c			 
0e3c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e3c			; 20 bytes, 86 cycles (excluding ret) 
0e3c			 
0e3c			; returns   hl = pseudorandom number 
0e3c			; corrupts   a 
0e3c			 
0e3c			; generates 16-bit pseudorandom numbers with a period of 65535 
0e3c			; using the xorshift method: 
0e3c			 
0e3c			; hl ^= hl << 7 
0e3c			; hl ^= hl >> 9 
0e3c			; hl ^= hl << 8 
0e3c			 
0e3c			; some alternative shift triplets which also perform well are: 
0e3c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e3c			 
0e3c			;  org 32768 
0e3c			 
0e3c			xrnd: 
0e3c 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e3f 3e 00		  ld a,0 
0e41 bd			  cp l 
0e42 20 02		  jr nz, .xrnd1 
0e44 2e 01		  ld l, 1 
0e46			.xrnd1: 
0e46			 
0e46 7c			  ld a,h 
0e47 1f			  rra 
0e48 7d			  ld a,l 
0e49 1f			  rra 
0e4a ac			  xor h 
0e4b 67			  ld h,a 
0e4c 7d			  ld a,l 
0e4d 1f			  rra 
0e4e 7c			  ld a,h 
0e4f 1f			  rra 
0e50 ad			  xor l 
0e51 6f			  ld l,a 
0e52 ac			  xor h 
0e53 67			  ld h,a 
0e54			 
0e54 22 35 fd		  ld (xrandc),hl 
0e57			 
0e57 c9			  ret 
0e58			;  
0e58			 
0e58			 
0e58			;;;; int maths 
0e58			 
0e58			; https://map.grauw.nl/articles/mult_div_shifts.php 
0e58			; Divide 16-bit values (with 16-bit result) 
0e58			; In: Divide BC by divider DE 
0e58			; Out: BC = result, HL = rest 
0e58			; 
0e58			Div16: 
0e58 21 00 00		    ld hl,0 
0e5b 78			    ld a,b 
0e5c 06 08		    ld b,8 
0e5e			Div16_Loop1: 
0e5e 17			    rla 
0e5f ed 6a		    adc hl,hl 
0e61 ed 52		    sbc hl,de 
0e63 30 01		    jr nc,Div16_NoAdd1 
0e65 19			    add hl,de 
0e66			Div16_NoAdd1: 
0e66 10 f6		    djnz Div16_Loop1 
0e68 17			    rla 
0e69 2f			    cpl 
0e6a 47			    ld b,a 
0e6b 79			    ld a,c 
0e6c 48			    ld c,b 
0e6d 06 08		    ld b,8 
0e6f			Div16_Loop2: 
0e6f 17			    rla 
0e70 ed 6a		    adc hl,hl 
0e72 ed 52		    sbc hl,de 
0e74 30 01		    jr nc,Div16_NoAdd2 
0e76 19			    add hl,de 
0e77			Div16_NoAdd2: 
0e77 10 f6		    djnz Div16_Loop2 
0e79 17			    rla 
0e7a 2f			    cpl 
0e7b 41			    ld b,c 
0e7c 4f			    ld c,a 
0e7d c9			ret 
0e7e			 
0e7e			 
0e7e			;http://z80-heaven.wikidot.com/math 
0e7e			; 
0e7e			;Inputs: 
0e7e			;     DE and A are factors 
0e7e			;Outputs: 
0e7e			;     A is not changed 
0e7e			;     B is 0 
0e7e			;     C is not changed 
0e7e			;     DE is not changed 
0e7e			;     HL is the product 
0e7e			;Time: 
0e7e			;     342+6x 
0e7e			; 
0e7e			Mult16: 
0e7e			 
0e7e 06 08		     ld b,8          ;7           7 
0e80 21 00 00		     ld hl,0         ;10         10 
0e83 29			       add hl,hl     ;11*8       88 
0e84 07			       rlca          ;4*8        32 
0e85 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0e87 19			         add hl,de   ;--         -- 
0e88 10 f9		       djnz $-5      ;13*7+8     99 
0e8a c9			ret 
0e8b			 
0e8b			; 
0e8b			; Square root of 16-bit value 
0e8b			; In:  HL = value 
0e8b			; Out:  D = result (rounded down) 
0e8b			; 
0e8b			;Sqr16: 
0e8b			;    ld de,#0040 
0e8b			;    ld a,l 
0e8b			;    ld l,h 
0e8b			;    ld h,d 
0e8b			;    or a 
0e8b			;    ld b,8 
0e8b			;Sqr16_Loop: 
0e8b			;    sbc hl,de 
0e8b			;    jr nc,Sqr16_Skip 
0e8b			;    add hl,de 
0e8b			;Sqr16_Skip: 
0e8b			;    ccf 
0e8b			;    rl d 
0e8b			;    add a,a 
0e8b			;    adc hl,hl 
0e8b			;    add a,a 
0e8b			;    adc hl,hl 
0e8b			;    djnz Sqr16_Loop 
0e8b			;    ret 
0e8b			; 
0e8b			; 
0e8b			; Divide 8-bit values 
0e8b			; In: Divide E by divider C 
0e8b			; Out: A = result, B = rest 
0e8b			; 
0e8b			Div8: 
0e8b af			    xor a 
0e8c 06 08		    ld b,8 
0e8e			Div8_Loop: 
0e8e cb 13		    rl e 
0e90 17			    rla 
0e91 91			    sub c 
0e92 30 01		    jr nc,Div8_NoAdd 
0e94 81			    add a,c 
0e95			Div8_NoAdd: 
0e95 10 f7		    djnz Div8_Loop 
0e97 47			    ld b,a 
0e98 7b			    ld a,e 
0e99 17			    rla 
0e9a 2f			    cpl 
0e9b c9			    ret 
0e9c			 
0e9c			; 
0e9c			; Multiply 8-bit value with a 16-bit value (unrolled) 
0e9c			; In: Multiply A with DE 
0e9c			; Out: HL = result 
0e9c			; 
0e9c			Mult12U: 
0e9c 2e 00		    ld l,0 
0e9e 87			    add a,a 
0e9f 30 01		    jr nc,Mult12U_NoAdd0 
0ea1 19			    add hl,de 
0ea2			Mult12U_NoAdd0: 
0ea2 29			    add hl,hl 
0ea3 87			    add a,a 
0ea4 30 01		    jr nc,Mult12U_NoAdd1 
0ea6 19			    add hl,de 
0ea7			Mult12U_NoAdd1: 
0ea7 29			    add hl,hl 
0ea8 87			    add a,a 
0ea9 30 01		    jr nc,Mult12U_NoAdd2 
0eab 19			    add hl,de 
0eac			Mult12U_NoAdd2: 
0eac 29			    add hl,hl 
0ead 87			    add a,a 
0eae 30 01		    jr nc,Mult12U_NoAdd3 
0eb0 19			    add hl,de 
0eb1			Mult12U_NoAdd3: 
0eb1 29			    add hl,hl 
0eb2 87			    add a,a 
0eb3 30 01		    jr nc,Mult12U_NoAdd4 
0eb5 19			    add hl,de 
0eb6			Mult12U_NoAdd4: 
0eb6 29			    add hl,hl 
0eb7 87			    add a,a 
0eb8 30 01		    jr nc,Mult12U_NoAdd5 
0eba 19			    add hl,de 
0ebb			Mult12U_NoAdd5: 
0ebb 29			    add hl,hl 
0ebc 87			    add a,a 
0ebd 30 01		    jr nc,Mult12U_NoAdd6 
0ebf 19			    add hl,de 
0ec0			Mult12U_NoAdd6: 
0ec0 29			    add hl,hl 
0ec1 87			    add a,a 
0ec2 d0			    ret nc 
0ec3 19			    add hl,de 
0ec4 c9			    ret 
0ec5			 
0ec5			; 
0ec5			; Multiply 8-bit value with a 16-bit value (right rotating) 
0ec5			; In: Multiply A with DE 
0ec5			;      Put lowest value in A for most efficient calculation 
0ec5			; Out: HL = result 
0ec5			; 
0ec5			Mult12R: 
0ec5 21 00 00		    ld hl,0 
0ec8			Mult12R_Loop: 
0ec8 cb 3f		    srl a 
0eca 30 01		    jr nc,Mult12R_NoAdd 
0ecc 19			    add hl,de 
0ecd			Mult12R_NoAdd: 
0ecd cb 23		    sla e 
0ecf cb 12		    rl d 
0ed1 b7			    or a 
0ed2 c2 c8 0e		    jp nz,Mult12R_Loop 
0ed5 c9			    ret 
0ed6			 
0ed6			; 
0ed6			; Multiply 16-bit values (with 32-bit result) 
0ed6			; In: Multiply BC with DE 
0ed6			; Out: BCHL = result 
0ed6			; 
0ed6			Mult32: 
0ed6 79			    ld a,c 
0ed7 48			    ld c,b 
0ed8 21 00 00		    ld hl,0 
0edb 06 10		    ld b,16 
0edd			Mult32_Loop: 
0edd 29			    add hl,hl 
0ede 17			    rla 
0edf cb 11		    rl c 
0ee1 30 07		    jr nc,Mult32_NoAdd 
0ee3 19			    add hl,de 
0ee4 ce 00		    adc a,0 
0ee6 d2 ea 0e		    jp nc,Mult32_NoAdd 
0ee9 0c			    inc c 
0eea			Mult32_NoAdd: 
0eea 10 f1		    djnz Mult32_Loop 
0eec 41			    ld b,c 
0eed 4f			    ld c,a 
0eee c9			    ret 
0eef			 
0eef			 
0eef			 
0eef			; 
0eef			; Multiply 8-bit values 
0eef			; In:  Multiply H with E 
0eef			; Out: HL = result 
0eef			; 
0eef			Mult8: 
0eef 16 00		    ld d,0 
0ef1 6a			    ld l,d 
0ef2 06 08		    ld b,8 
0ef4			Mult8_Loop: 
0ef4 29			    add hl,hl 
0ef5 30 01		    jr nc,Mult8_NoAdd 
0ef7 19			    add hl,de 
0ef8			Mult8_NoAdd: 
0ef8 10 fa		    djnz Mult8_Loop 
0efa c9			    ret 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			;;http://z80-heaven.wikidot.com/math 
0efb			;;This divides DE by BC, storing the result in DE, remainder in HL 
0efb			; 
0efb			;DE_Div_BC:          ;1281-2x, x is at most 16 
0efb			;     ld a,16        ;7 
0efb			;     ld hl,0        ;10 
0efb			;     jp $+5         ;10 
0efb			;.DivLoop: 
0efb			;       add hl,bc    ;-- 
0efb			;       dec a        ;64 
0efb			;       jr z,.DivLoopEnd        ;86 
0efb			; 
0efb			;       sla e        ;128 
0efb			;       rl d         ;128 
0efb			;       adc hl,hl    ;240 
0efb			;       sbc hl,bc    ;240 
0efb			;       jr nc,.DivLoop ;23|21 
0efb			;       inc e        ;-- 
0efb			;       jp .DivLoop+1 
0efb			; 
0efb			;.DivLoopEnd: 
0efb			 
0efb			;HL_Div_C: 
0efb			;Inputs: 
0efb			;     HL is the numerator 
0efb			;     C is the denominator 
0efb			;Outputs: 
0efb			;     A is the remainder 
0efb			;     B is 0 
0efb			;     C is not changed 
0efb			;     DE is not changed 
0efb			;     HL is the quotient 
0efb			; 
0efb			;       ld b,16 
0efb			;       xor a 
0efb			;         add hl,hl 
0efb			;         rla 
0efb			;         cp c 
0efb			;         jr c,$+4 
0efb			;           inc l 
0efb			;           sub c 
0efb			;         djnz $-7 
0efb			 
0efb			; https://plutiedev.com/z80-add-8bit-to-16bit 
0efb			 
0efb			addatohl: 
0efb 85			    add   a, l    ; A = A+L 
0efc 6f			    ld    l, a    ; L = A+L 
0efd 8c			    adc   a, h    ; A = A+L+H+carry 
0efe 95			    sub   l       ; A = H+carry 
0eff 67			    ld    h, a    ; H = H+carry 
0f00 c9			ret 
0f01			 
0f01			addatode: 
0f01 83			    add   a, e    ; A = A+L 
0f02 5f			    ld    e, a    ; L = A+L 
0f03 8a			    adc   a, d    ; A = A+L+H+carry 
0f04 93			    sub   e       ; A = H+carry 
0f05 57			    ld    d, a    ; H = H+carry 
0f06 c9			ret 
0f07			 
0f07			 
0f07			addatobc: 
0f07 81			    add   a, c    ; A = A+L 
0f08 4f			    ld    c, a    ; L = A+L 
0f09 88			    adc   a, b    ; A = A+L+H+carry 
0f0a 91			    sub   c       ; A = H+carry 
0f0b 47			    ld    b, a    ; H = H+carry 
0f0c c9			ret 
0f0d			 
0f0d			subafromhl: 
0f0d			   ; If A=0 do nothing 
0f0d			    ; Otherwise flip A's sign. Since 
0f0d			    ; the upper byte becomes -1, also 
0f0d			    ; substract 1 from H. 
0f0d ed 44		    neg 
0f0f ca 18 0f		    jp    z, Skip 
0f12 25			    dec   h 
0f13			     
0f13			    ; Now add the low byte as usual 
0f13			    ; Two's complement takes care of 
0f13			    ; ensuring the result is correct 
0f13 85			    add   a, l 
0f14 6f			    ld    l, a 
0f15 8c			    adc   a, h 
0f16 95			    sub   l 
0f17 67			    ld    h, a 
0f18			Skip: 
0f18 c9				ret 
0f19			 
0f19			 
0f19			; compare hl and de 
0f19			; returns:  
0f19			; if hl = de, z=1, s=0, c0=0 
0f19			; if hl > de, z=0, s=0, c=0 
0f19			; if hl < de, z=0, s=1, c=1 
0f19			cmp16:	 
0f19 b7				or a 
0f1a ed 52			sbc hl,de 
0f1c e0				ret po 
0f1d 7c				ld a,h 
0f1e 1f				rra 
0f1f ee 40			xor 01000000B 
0f21 37				scf 
0f22 8f				adc a,a 
0f23 c9				ret 
0f24			 
0f24			 
0f24			; test if hl contains zero   - A is destroyed 
0f24			 
0f24			ishlzero:    
0f24 b7				or a     ; reset flags 
0f25 7c				ld a, h 
0f26 b5				or l        	 
0f27			 
0f27 c9				ret 
0f28			 
0f28			 
0f28			 
0f28			 
0f28			if FORTH_ENABLE_FLOATMATH 
0f28			;include "float/bbcmath.z80" 
0f28			include "float/lpfpcalc.asm" 
0f28			endif 
0f28			 
0f28			 
0f28			; eof 
0f28			 
# End of file firmware_maths.asm
0f28			include "firmware_strings.asm"   ; string handling  
0f28			 
0f28			 
0f28			; TODO string len 
0f28			; input text string, end on cr with zero term 
0f28			; a offset into frame buffer to start prompt 
0f28			; d is max length 
0f28			; e is display size TODO 
0f28			; c is current cursor position 
0f28			; hl is ptr to where string will be stored 
0f28			 
0f28			 
0f28			; TODO check limit of buffer for new inserts 
0f28			; TODO check insert does not push beyond buffer 
0f28			; TODO scroll in a limited display area 
0f28			; TODO scroll whole screen on page wrap 
0f28			 
0f28			 
0f28			; TODO handle KEY_PREVWORD 
0f28			; TODO handle KEY_NEXTWORD 
0f28			; TODO handle KEY_HOME 
0f28			; TODO handle KEY_END 
0f28			; TODO use LCD cursor? 
0f28			 
0f28 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f2b 81					add c 
0f2c 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f2f 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f32 79					ld a, c 
0f33 cd fb 0e				call addatohl 
0f36 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f39 7a					ld a,d 
0f3a 32 af fe			        ld (input_size), a       ; save length of input area 
0f3d 79					ld a, c 
0f3e 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f41 7b					ld a,e 
0f42 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f45					 
0f45					 
0f45			 
0f45			;		ld a,(input_ptr) 
0f45			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f45			 
0f45			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f45					; init cursor shape if not set by the cin routines 
0f45 21 4d fd				ld hl, cursor_shape 
0f48 3e ff				ld a, 255 
0f4a 77					ld (hl), a 
0f4b 23					inc hl 
0f4c 3e 00				ld a, 0 
0f4e 77					ld (hl), a 
0f4f			 
0f4f 3e 0f				ld a, CUR_BLINK_RATE 
0f51 32 a9 fe				ld (input_cur_flash), a 
0f54 3e 01				ld a, 1 
0f56 32 a8 fe				ld (input_cur_onoff),a 
0f59			 
0f59			;	if DEBUG_INPUT 
0f59			;		push af 
0f59			;		ld a, 'I' 
0f59			;		ld (debug_mark),a 
0f59			;		pop af 
0f59			;		CALLMONITOR 
0f59			;	endif 
0f59			.is1:		; main entry loop 
0f59			 
0f59			 
0f59			 
0f59					; pause 1ms 
0f59			 
0f59 3e 01				ld a, 1 
0f5b cd 29 0c				call aDelayInMS 
0f5e			 
0f5e					; dec flash counter 
0f5e 3a a9 fe				ld a, (input_cur_flash) 
0f61 3d					dec a 
0f62 32 a9 fe				ld (input_cur_flash), a 
0f65 fe 00				cp 0 
0f67 20 0d				jr nz, .nochgstate 
0f69			 
0f69			 
0f69					; change state 
0f69 3a a8 fe				ld a,(input_cur_onoff) 
0f6c ed 44				neg 
0f6e 32 a8 fe				ld (input_cur_onoff),a 
0f71			 
0f71			 
0f71					; reset on change of state 
0f71 3e 0f				ld a, CUR_BLINK_RATE 
0f73 32 a9 fe				ld (input_cur_flash), a 
0f76			 
0f76			.nochgstate: 
0f76					 
0f76					 
0f76			 
0f76					; display cursor  
0f76			 
0f76			;		ld hl, (input_start) 
0f76			;		ld a, (input_cursor) 
0f76			;		call addatohl 
0f76			 
0f76					; get char under cursor and replace with cursor 
0f76 2a b2 fe		ld hl, (input_ptr) 
0f79			;		ld a, (hl) 
0f79			;		ld (input_under_cursor),a 
0f79			;		ld a, '_' 
0f79			;		ld (hl), a 
0f79			 
0f79					; display string 
0f79			 
0f79 ed 5b b0 fe			ld de, (input_start) 
0f7d 3a ad fe				ld a, (input_at_pos) 
0f80 cd da 0c				call str_at_display 
0f83			;	        call update_display 
0f83			 
0f83					; find place to put the cursor 
0f83			;		add h 
0f83			;		ld l, display_row_1 
0f83			;		sub l 
0f83			; (input_at_pos) 
0f83					;ld c, a 
0f83			;		ld a, (input_cursor) 
0f83			;		ld l, (input_at_pos) 
0f83			;		;ld b, h 
0f83			;		add l 
0f83			;		ld (input_at_cursor),a 
0f83					;ld l,h 
0f83			 
0f83			;		ld h, 0 
0f83			;		ld l,(input_at_pos) 
0f83			;		ld a, (input_cursor) 
0f83			;		call addatohl 
0f83			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0f83			;		call subafromhl 
0f83			;		ld a,l 
0f83			;		ld (input_at_cursor), a 
0f83			 
0f83				if DEBUG_INPUT 
0f83					ld a, (hardware_diag) 
0f83					cp 0 
0f83					jr z, .skip_input_diag 
0f83			 
0f83					ld a,(input_at_pos) 
0f83					ld hl, LFSRSeed 
0f83					call hexout 
0f83					ld a, (input_cursor) 
0f83					ld hl, LFSRSeed+2 
0f83					call hexout 
0f83					ld a,(input_at_cursor) 
0f83					ld hl, LFSRSeed+4 
0f83					call hexout 
0f83			 
0f83					ld a,(input_cur_onoff) 
0f83					ld hl, LFSRSeed+6 
0f83					call hexout 
0f83			 
0f83					ld a,(input_cur_flash) 
0f83					ld hl, LFSRSeed+8 
0f83					call hexout 
0f83			 
0f83					ld a,(input_len) 
0f83					ld hl, LFSRSeed+10 
0f83					call hexout 
0f83					ld hl, LFSRSeed+12 
0f83					ld a, 0 
0f83					ld (hl),a 
0f83					ld a, display_row_4 
0f83					ld de, LFSRSeed 
0f83					call str_at_display 
0f83					.skip_input_diag: 
0f83				endif 
0f83			 
0f83					; decide on if we are showing the cursor this time round 
0f83			 
0f83 3a a8 fe				ld a, (input_cur_onoff) 
0f86 fe ff				cp 255 
0f88 28 13				jr z, .skipcur 
0f8a			 
0f8a			 
0f8a 3a ab fe				ld a,(input_at_cursor) 
0f8d 11 4d fd				ld de, cursor_shape 
0f90 cd da 0c				call str_at_display 
0f93			 
0f93					; save length of current input string 
0f93 2a b0 fe				ld hl, (input_start) 
0f96 cd 59 13				call strlenz 
0f99 7d					ld a,l 
0f9a 32 a3 fe				ld (input_len),a 
0f9d			 
0f9d			.skipcur: 
0f9d			 
0f9d cd ea 0c			        call update_display 
0fa0					 
0fa0			 
0fa0			 
0fa0					; wait 
0fa0				 
0fa0					; TODO loop without wait to flash the cursor and char under cursor	 
0fa0 cd 35 6b				call cin    ; _wait 
0fa3			 
0fa3 fe 00				cp 0 
0fa5 ca 59 0f				jp z, .is1 
0fa8			 
0fa8					; get ptr to char to input into 
0fa8			 
0fa8 4f					ld c,a 
0fa9 2a b0 fe				ld hl, (input_start) 
0fac 3a 9e fe				ld a, (input_cursor) 
0faf cd fb 0e				call addatohl 
0fb2 22 b2 fe				ld (input_ptr), hl 
0fb5 79					ld a,c 
0fb6			 
0fb6					; replace char under cursor 
0fb6			 
0fb6			;		ld hl, (input_ptr) 
0fb6			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fb6			;		ld (hl), a 
0fb6			 
0fb6			;	if DEBUG_INPUT 
0fb6			;		push af 
0fb6			;		ld a, 'i' 
0fb6			;		ld (debug_mark),a 
0fb6			;		pop af 
0fb6			;		CALLMONITOR 
0fb6			;	endif 
0fb6 fe 0e				cp KEY_HOME 
0fb8 20 0e				jr nz, .iske 
0fba			 
0fba 3a ad fe				ld a, (input_at_pos) 
0fbd 32 ab fe				ld (input_at_cursor),a 
0fc0 3e 00				ld a, 0 
0fc2 32 9e fe				ld (input_cursor), a 
0fc5 c3 59 0f				jp .is1 
0fc8					 
0fc8 fe 0f		.iske:		cp KEY_END 
0fca 20 03				jr nz, .isknw 
0fcc c3 59 0f				jp .is1 
0fcf			 
0fcf fe 06		.isknw:		cp KEY_NEXTWORD 
0fd1 20 1b				jr nz, .iskpw 
0fd3			 
0fd3 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
0fd6 7e					ld a,(hl)	 
0fd7 fe 00				cp 0 
0fd9 ca 59 0f				jp z, .is1    ; end of string 
0fdc fe 20				cp ' ' 
0fde ca 59 0f				jp z, .is1    ; end of word 
0fe1 23					inc hl 
0fe2 22 b2 fe				ld (input_ptr), hl 
0fe5 3a ab fe				ld a, (input_at_cursor) 
0fe8 3c					inc a 
0fe9 32 ab fe				ld (input_at_cursor), a 
0fec 18 e5				jr .isknwm 
0fee			 
0fee fe 07		.iskpw:		cp KEY_PREVWORD 
0ff0 20 1b				jr nz, .iskl 
0ff2			.iskpwm:	 
0ff2 2a b2 fe				ld hl, (input_ptr) 
0ff5 7e					ld a,(hl)	 
0ff6 fe 00				cp 0  
0ff8 ca 59 0f				jp z, .is1    ; end of string 
0ffb fe 20				cp ' ' 
0ffd ca 59 0f				jp z, .is1    ; end of word 
1000 2b					dec hl 
1001 22 b2 fe				ld (input_ptr), hl 
1004 3a ab fe				ld a, (input_at_cursor) 
1007 3d					dec a 
1008 32 ab fe				ld (input_at_cursor), a 
100b 18 e5				jr .iskpwm 
100d			 
100d			 
100d fe 0b		.iskl:		cp KEY_LEFT 
100f 20 27				jr nz, .isk1 
1011			 
1011 3a 9e fe				ld a, (input_cursor) 
1014			 
1014 fe 00				cp 0 
1016 ca 59 0f				jp z, .is1 		; at start of line to ignore  
1019			 
1019 3d					dec  a 		; TODO check underflow 
101a 32 9e fe				ld (input_cursor), a 
101d			 
101d 2a b2 fe				ld hl, (input_ptr) 
1020 2b					dec hl 
1021 22 b2 fe				ld (input_ptr), hl 
1024					 
1024 3a ab fe				ld a, (input_at_cursor) 
1027 3d					dec a 
1028 32 ab fe				ld (input_at_cursor), a 
102b			 
102b 3e 01				ld a, 1		; show cursor moving 
102d 32 a8 fe				ld (input_cur_onoff),a 
1030 3e 0f				ld a, CUR_BLINK_RATE 
1032 32 a9 fe				ld (input_cur_flash), a 
1035			 
1035 c3 59 0f				jp .is1 
1038			 
1038 fe 0c		.isk1:		cp KEY_RIGHT 
103a 20 2a				jr nz, .isk2 
103c			 
103c 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
103f 5f					ld e,a 
1040 3a 9e fe				ld a, (input_cursor) 
1043 bb					cp e 
1044 ca 59 0f				jp z, .is1		; at the end of string so dont go right 
1047			 
1047 3c					inc  a 		; TODO check overflow 
1048 32 9e fe				ld (input_cursor), a 
104b			 
104b 3a ab fe				ld a, (input_at_cursor) 
104e 3c					inc a 
104f 32 ab fe				ld (input_at_cursor), a 
1052			 
1052 2a b2 fe				ld hl, (input_ptr) 
1055 23					inc hl 
1056 22 b2 fe				ld (input_ptr), hl 
1059			 
1059 3e 01				ld a, 1		; show cursor moving 
105b 32 a8 fe				ld (input_cur_onoff),a 
105e 3e 0f				ld a, CUR_BLINK_RATE 
1060 32 a9 fe				ld (input_cur_flash), a 
1063			 
1063 c3 59 0f				jp .is1 
1066			 
1066 fe 05		.isk2:		cp KEY_UP 
1068			 
1068 20 26				jr nz, .isk3 
106a			 
106a					; swap last command with the current on 
106a			 
106a					; move cursor to start of string 
106a 2a b0 fe				ld hl, (input_start) 
106d 22 b2 fe				ld (input_ptr), hl 
1070			 
1070 3a ad fe				ld a, (input_at_pos) 
1073 32 ab fe				ld (input_at_cursor), a 
1076			 
1076 3e 00				ld a, 0 
1078 32 9e fe				ld (input_cursor), a 
107b					 
107b					; swap input and last command buffers 
107b			 
107b 21 ac f6				ld hl, os_cli_cmd 
107e 11 ab f7				ld de, os_last_cmd 
1081 06 ff				ld b, 255 
1083 7e			.swap1:		ld a, (hl) 
1084 4f					ld c,a 
1085 1a					ld a, (de) 
1086 77					ld (hl), a 
1087 79					ld a,c 
1088 12					ld (de),a 
1089 23					inc hl 
108a 13					inc de 
108b 10 f6				djnz .swap1 
108d			 
108d			 
108d			 
108d			 
108d			 
108d c3 59 0f				jp .is1 
1090			 
1090 fe 08		.isk3:		cp KEY_BS 
1092 20 3c				jr nz, .isk4 
1094			 
1094 3a 9e fe				ld a, (input_cursor) 
1097			 
1097 fe 00				cp 0 
1099 ca 59 0f				jp z, .is1 		; at start of line to ignore  
109c			 
109c 3d					dec  a 		; TODO check underflow 
109d 32 9e fe				ld (input_cursor), a 
10a0			 
10a0					; hl is source 
10a0					; de needs to be source - 1 
10a0			 
10a0			;		ld a, 0 
10a0			;		dec hl 
10a0			;		ld (hl), a 
10a0			 
10a0 2a b2 fe				ld hl, (input_ptr) 
10a3 2b					dec hl 
10a4 22 b2 fe				ld (input_ptr), hl 
10a7			 
10a7					; shift all data 
10a7			 
10a7 e5					push hl 
10a8 23					inc hl 
10a9 d1					pop de 
10aa 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10ad 4f					ld c,a 
10ae 06 00				ld b,0 
10b0 ed b0				ldir  
10b2			 
10b2			 
10b2			 
10b2			 
10b2 3a ab fe				ld a, (input_at_cursor) 
10b5 3d					dec a 
10b6 32 ab fe				ld (input_at_cursor), a 
10b9			 
10b9			 
10b9 3e 01				ld a, 1		; show cursor moving 
10bb 32 a8 fe				ld (input_cur_onoff),a 
10be 3e 0f				ld a, CUR_BLINK_RATE 
10c0 32 a9 fe				ld (input_cur_flash), a 
10c3			 
10c3					; remove char 
10c3 3a ab fe				ld a, (input_at_cursor) 
10c6 3c					inc a 
10c7 11 51 11				ld de,.iblank 
10ca cd da 0c				call str_at_display 
10cd			 
10cd c3 59 0f				jp .is1 
10d0			 
10d0 fe 0d		.isk4:		cp KEY_CR 
10d2 28 6c				jr z, .endinput 
10d4			 
10d4					; else add the key press to the end 
10d4			 
10d4 4f					ld c, a			; save key pressed 
10d5			 
10d5 7e					ld a,(hl)		; get what is currently under char 
10d6			 
10d6 fe 00				cp 0			; we are at the end of the string 
10d8 20 2f				jr nz, .onchar 
10da					 
10da					; add a char to the end of the string 
10da				 
10da 71					ld (hl),c 
10db 23					inc hl 
10dc			;		ld a,' ' 
10dc			;		ld (hl),a 
10dc			;		inc hl 
10dc 3e 00				ld a,0 
10de 77					ld (hl),a 
10df 2b					dec hl 
10e0			 
10e0 3a 9e fe				ld a, (input_cursor) 
10e3 3c					inc a				; TODO check max string length and scroll  
10e4 32 9e fe				ld (input_cursor), a		; inc cursor pos 
10e7							 
10e7 3a ab fe				ld a, (input_at_cursor) 
10ea 3c					inc a 
10eb 32 ab fe				ld (input_at_cursor), a 
10ee			 
10ee 2a b2 fe				ld hl, (input_ptr) 
10f1 23					inc hl 
10f2 22 b2 fe				ld (input_ptr), hl 
10f5			 
10f5 2a b2 fe				ld hl, (input_ptr) 
10f8 23					inc hl 
10f9 22 b2 fe				ld (input_ptr), hl 
10fc			;	if DEBUG_INPUT 
10fc			;		push af 
10fc			;		ld a, '+' 
10fc			;		ld (debug_mark),a 
10fc			;		pop af 
10fc			;		CALLMONITOR 
10fc			;	endif 
10fc 3e 01				ld a, 1		; show cursor moving 
10fe 32 a8 fe				ld (input_cur_onoff),a 
1101 3e 0f				ld a, CUR_BLINK_RATE 
1103 32 a9 fe				ld (input_cur_flash), a 
1106 c3 59 0f				jp .is1 
1109					 
1109			 
1109			 
1109					; if on a char then insert 
1109			.onchar: 
1109			 
1109					; TODO over flow check: make sure insert does not blow out buffer 
1109			 
1109					; need to do some maths to use lddr 
1109			 
1109 e5					push hl   ; save char pos 
110a c5					push bc 
110b			 
110b 2a b0 fe				ld hl, (input_start) 
110e 3a a3 fe				ld a, (input_len) 
1111 cd fb 0e				call addatohl  		; end of string 
1114 23					inc hl 
1115 23					inc hl		; past zero term 
1116 e5					push hl 
1117 23					inc hl 
1118 e5					push hl  
1119			 
1119								; start and end of lddr set, now how much to move? 
1119			 
1119							 
1119 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
111c 47					ld b,a 
111d 3a a3 fe				ld a,(input_len) 
1120 5f					ld e,a 
1121 90					sub b 
1122 3c					inc a		;?? 
1123 3c					inc a		;?? 
1124 3c					inc a		;?? 
1125			 
1125 06 00				ld b,0 
1127 4f					ld c,a 
1128			 
1128				if DEBUG_INPUT 
1128					push af 
1128					ld a, 'i' 
1128					ld (debug_mark),a 
1128					pop af 
1128			;		CALLMONITOR 
1128				endif 
1128 d1					pop de 
1129 e1					pop hl 
112a				if DEBUG_INPUT 
112a					push af 
112a					ld a, 'I' 
112a					ld (debug_mark),a 
112a					pop af 
112a			;		CALLMONITOR 
112a				endif 
112a ed b8				lddr 
112c				 
112c			 
112c			 
112c					; TODO have a key for insert/overwrite mode???? 
112c c1					pop bc 
112d e1					pop hl 
112e 71					ld (hl), c		; otherwise overwrite current char 
112f					 
112f			 
112f			 
112f			 
112f 3a 9e fe				ld a, (input_cursor) 
1132 3c					inc  a 		; TODO check overflow 
1133 32 9e fe				ld (input_cursor), a 
1136			 
1136 3a ab fe				ld a, (input_at_cursor) 
1139 3c					inc a 
113a 32 ab fe				ld (input_at_cursor), a 
113d			 
113d c3 59 0f				jp .is1 
1140			 
1140			.endinput:	; TODO look for end of string 
1140			 
1140					; add trailing space for end of token 
1140			 
1140 2a b0 fe				ld hl, (input_start) 
1143 3a a3 fe				ld a,(input_len) 
1146 cd fb 0e				call addatohl 
1149 3e 20				ld a, ' ' 
114b 77					ld (hl),a 
114c					; TODO eof of parse marker 
114c			 
114c 23					inc hl 
114d 3e 00				ld a, 0 
114f 77					ld (hl),a 
1150			 
1150			 
1150 c9					ret 
1151			 
1151 .. 00		.iblank: db " ",0 
1153			 
1153			 
1153 32 ad fe		input_str_prev:	ld (input_at_pos), a 
1156 22 b0 fe				ld (input_start), hl 
1159 3e 01				ld a,1			; add cursor 
115b 77					ld (hl),a 
115c 23					inc hl 
115d 3e 00				ld a,0 
115f 77					ld (hl),a 
1160 22 b2 fe				ld (input_ptr), hl 
1163 7a					ld a,d 
1164 32 af fe				ld (input_size), a 
1167 3e 00				ld a,0 
1169 32 9e fe				ld (input_cursor),a 
116c			.instr1:	 
116c			 
116c					; TODO do block cursor 
116c					; TODO switch cursor depending on the modifer key 
116c			 
116c					; update cursor shape change on key hold 
116c			 
116c 2a b2 fe				ld hl, (input_ptr) 
116f 2b					dec hl 
1170 3a 4d fd				ld a,(cursor_shape) 
1173 77					ld (hl), a 
1174			 
1174					; display entered text 
1174 3a ad fe				ld a,(input_at_pos) 
1177 cd 53 6a		            	CALL fLCD_Pos       ;Position cursor to location in A 
117a ed 5b b0 fe	            	LD   de, (input_start) 
117e cd 5b 6a		            	CALL fLCD_Str       ;Display string pointed to by DE 
1181			 
1181 cd 35 6b				call cin 
1184 fe 00				cp 0 
1186 28 e4				jr z, .instr1 
1188			 
1188					; proecess keyboard controls first 
1188			 
1188 2a b2 fe				ld hl,(input_ptr) 
118b			 
118b fe 0d				cp KEY_CR	 ; pressing enter ends input 
118d 28 5a				jr z, .instrcr 
118f			 
118f fe 08				cp KEY_BS 	; back space 
1191 20 0f				jr nz, .instr2 
1193					; process back space 
1193			 
1193					; TODO stop back space if at start of string 
1193 2b					dec hl 
1194 2b					dec hl ; to over write cursor 
1195 3a 4d fd				ld a,(cursor_shape) 
1198					;ld a,0 
1198 77					ld (hl),a 
1199 23					inc hl 
119a 3e 20				ld a," " 
119c 77					ld (hl),a 
119d 22 b2 fe				ld (input_ptr),hl 
11a0					 
11a0			 
11a0 18 ca				jr .instr1 
11a2			 
11a2 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11a4 20 06				jr nz, .instr3 
11a6 2b					dec hl 
11a7 22 b2 fe				ld (input_ptr),hl 
11aa 18 c0				jr .instr1 
11ac				 
11ac fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ae 20 06				jr nz, .instr4 
11b0 23					inc hl 
11b1 22 b2 fe				ld (input_ptr),hl 
11b4 18 b6				jr .instr1 
11b6			 
11b6 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
11b8 20 06				jr nz, .instr5 
11ba 2b					dec hl 
11bb 22 b2 fe				ld (input_ptr),hl 
11be 18 ac				jr .instr1 
11c0			 
11c0 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
11c2 20 06				jr nz, .instr6 
11c4 2b					dec hl 
11c5 22 b2 fe				ld (input_ptr),hl 
11c8 18 a2				jr .instr1 
11ca fe 05		.instr6:        cp KEY_UP      ; recall last command 
11cc 20 0b				jr nz, .instrnew 
11ce			 
11ce 21 85 f3			ld hl, scratch 
11d1 11 ab f7			ld de, os_last_cmd 
11d4 cd f2 11			call strcpy 
11d7 18 93				jr .instr1 
11d9			 
11d9			 
11d9			.instrnew:	; no special key pressed to see if we have room to store it 
11d9			 
11d9					; TODO do string size test 
11d9			 
11d9 2b					dec hl ; to over write cursor 
11da 77					ld (hl),a 
11db 23					inc hl 
11dc 3a 4d fd				ld a,(cursor_shape) 
11df 77					ld (hl),a 
11e0 23					inc hl 
11e1 3e 00				ld a,0 
11e3 77					ld (hl),a 
11e4			 
11e4 22 b2 fe				ld (input_ptr),hl 
11e7					 
11e7 18 83				jr .instr1 
11e9 2b			.instrcr:	dec hl		; remove cursor 
11ea 3e 20				ld a,' '	; TODO add a trailing space for safety 
11ec 77					ld (hl),a 
11ed 23					inc hl 
11ee 3e 00				ld a,0 
11f0 77					ld (hl),a 
11f1			 
11f1			 
11f1					; if at end of line scroll up    
11f1					; TODO detecting only end of line 4 for scroll up  
11f1			 
11f1					;ld   
11f1			 
11f1 c9					ret 
11f2			 
11f2			 
11f2			; strcpy hl = dest, de source 
11f2			 
11f2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11f3 b7			            OR   A              ;Null terminator? 
11f4 c8			            RET  Z              ;Yes, so finished 
11f5 1a					ld a,(de) 
11f6 77					ld (hl),a 
11f7 13			            INC  DE             ;Point to next character 
11f8 23					inc hl 
11f9 18 f7		            JR   strcpy       ;Repeat 
11fb c9					ret 
11fc			 
11fc			 
11fc			; TODO string_at  
11fc			; pass string which starts with lcd offset address and then null term string 
11fc			 
11fc			; TODO string to dec 
11fc			; TODO string to hex 
11fc			; TODO byte to string hex 
11fc			; TODO byte to string dec 
11fc			 
11fc			 
11fc			 
11fc			; from z80uartmonitor 
11fc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11fc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11fc			; pass hl for where to put the text 
11fc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11fc c5			hexout:	PUSH BC 
11fd f5					PUSH AF 
11fe 47					LD B, A 
11ff					; Upper nybble 
11ff cb 3f				SRL A 
1201 cb 3f				SRL A 
1203 cb 3f				SRL A 
1205 cb 3f				SRL A 
1207 cd 17 12				CALL tohex 
120a 77					ld (hl),a 
120b 23					inc hl	 
120c					 
120c					; Lower nybble 
120c 78					LD A, B 
120d e6 0f				AND 0FH 
120f cd 17 12				CALL tohex 
1212 77					ld (hl),a 
1213 23					inc hl	 
1214					 
1214 f1					POP AF 
1215 c1					POP BC 
1216 c9					RET 
1217					 
1217			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1217			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1217			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1217			tohex: 
1217 e5					PUSH HL 
1218 d5					PUSH DE 
1219 16 00				LD D, 0 
121b 5f					LD E, A 
121c 21 24 12				LD HL, .DATA 
121f 19					ADD HL, DE 
1220 7e					LD A, (HL) 
1221 d1					POP DE 
1222 e1					POP HL 
1223 c9					RET 
1224			 
1224			.DATA: 
1224 30					DEFB	30h	; 0 
1225 31					DEFB	31h	; 1 
1226 32					DEFB	32h	; 2 
1227 33					DEFB	33h	; 3 
1228 34					DEFB	34h	; 4 
1229 35					DEFB	35h	; 5 
122a 36					DEFB	36h	; 6 
122b 37					DEFB	37h	; 7 
122c 38					DEFB	38h	; 8 
122d 39					DEFB	39h	; 9 
122e 41					DEFB	41h	; A 
122f 42					DEFB	42h	; B 
1230 43					DEFB	43h	; C 
1231 44					DEFB	44h	; D 
1232 45					DEFB	45h	; E 
1233 46					DEFB	46h	; F 
1234			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1234			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1234			;;    subtract $30, if result > 9 then subtract $7 more 
1234			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1234			atohex: 
1234 d6 30				SUB $30 
1236 fe 0a				CP 10 
1238 f8					RET M		; If result negative it was 0-9 so we're done 
1239 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
123b c9					RET		 
123c			 
123c			 
123c			 
123c			 
123c			; Get 2 ASCII characters as hex byte from pointer in hl 
123c			 
123c			BYTERD: 
123c 16 00			LD	D,00h		;Set up 
123e cd 46 12			CALL	HEXCON		;Get byte and convert to hex 
1241 87				ADD	A,A		;First nibble so 
1242 87				ADD	A,A		;multiply by 16 
1243 87				ADD	A,A		; 
1244 87				ADD	A,A		; 
1245 57				LD	D,A		;Save hi nibble in D 
1246			HEXCON: 
1246 7e				ld a, (hl)		;Get next chr 
1247 23				inc hl 
1248 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
124a fe 0a			CP	00Ah		;Is it 0-9 ? 
124c 38 02			JR	C,NALPHA	;If so miss next bit 
124e d6 07			SUB	007h		;Else convert alpha 
1250			NALPHA: 
1250 b2				OR	D		;Add hi nibble back 
1251 c9				RET			; 
1252			 
1252			 
1252			; 
1252			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1252			; Since the routines get_byte and therefore get_nibble are called, only valid 
1252			; characters (0-9a-f) are accepted. 
1252			; 
1252			;get_word        push    af 
1252			;                call    get_byte        ; Get the upper byte 
1252			;                ld      h, a 
1252			;                call    get_byte        ; Get the lower byte 
1252			;                ld      l, a 
1252			;                pop     af 
1252			;                ret 
1252			; 
1252			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1252			; the routine get_nibble is used only valid characters are accepted - the  
1252			; input routine only accepts characters 0-9a-f. 
1252			; 
1252 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1253 7e					ld a,(hl) 
1254 23					inc hl 
1255 cd 7a 12		                call    nibble2val      ; Get upper nibble 
1258 cb 07		                rlc     a 
125a cb 07		                rlc     a 
125c cb 07		                rlc     a 
125e cb 07		                rlc     a 
1260 47			                ld      b, a            ; Save upper four bits 
1261 7e					ld a,(hl) 
1262 cd 7a 12		                call    nibble2val      ; Get lower nibble 
1265 b0			                or      b               ; Combine both nibbles 
1266 c1			                pop     bc              ; Restore B (and C) 
1267 c9			                ret 
1268			; 
1268			; Get a hexadecimal digit from the serial line. This routine blocks until 
1268			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1268			; to the serial line interface. The lower 4 bits of A contain the value of  
1268			; that particular digit. 
1268			; 
1268			;get_nibble      ld a,(hl)           ; Read a character 
1268			;                call    to_upper        ; Convert to upper case 
1268			;                call    is_hex          ; Was it a hex digit? 
1268			;                jr      nc, get_nibble  ; No, get another character 
1268			 ;               call    nibble2val      ; Convert nibble to value 
1268			 ;               call    print_nibble 
1268			 ;               ret 
1268			; 
1268			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1268			; A valid hexadecimal digit is denoted by a set C flag. 
1268			; 
1268			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1268			;                ret     nc              ; Yes 
1268			;                cp      '0'             ; Less than '0'? 
1268			;                jr      nc, is_hex_1    ; No, continue 
1268			;                ccf                     ; Complement carry (i.e. clear it) 
1268			;                ret 
1268			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1268			;                ret     c               ; Yes 
1268			;                cp      'A'             ; Less than 'A'? 
1268			;                jr      nc, is_hex_2    ; No, continue 
1268			;                ccf                     ; Yes - clear carry and return 
1268			;                ret 
1268			;is_hex_2        scf                     ; Set carry 
1268			;                ret 
1268			; 
1268			; Convert a single character contained in A to upper case: 
1268			; 
1268 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
126a d8			                ret     c 
126b fe 7b		                cp      'z' + 1         ; > 'z'? 
126d d0			                ret     nc              ; Nothing to do, either 
126e e6 5f		                and     $5f             ; Convert to upper case 
1270 c9			                ret 
1271			 
1271			 
1271			to_lower: 
1271			 
1271			   ; if char is in [A-Z] make it lower case 
1271			 
1271			   ; enter : a = char 
1271			   ; exit  : a = lower case char 
1271			   ; uses  : af 
1271			 
1271 fe 41		   cp 'A' 
1273 d8			   ret c 
1274			    
1274 fe 5b		   cp 'Z'+1 
1276 d0			   ret nc 
1277			    
1277 f6 20		   or $20 
1279 c9			   ret 
127a			 
127a			; 
127a			; Expects a hexadecimal digit (upper case!) in A and returns the 
127a			; corresponding value in A. 
127a			; 
127a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
127c 38 02		                jr      c, nibble2val_1 ; Yes 
127e d6 07		                sub     7               ; Adjust for A-F 
1280 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1282 e6 0f		                and     $f              ; Only return lower 4 bits 
1284 c9			                ret 
1285			; 
1285			; Print_nibble prints a single hex nibble which is contained in the lower  
1285			; four bits of A: 
1285			; 
1285			;print_nibble    push    af              ; We won't destroy the contents of A 
1285			;                and     $f              ; Just in case... 
1285			;                add     a, '0'             ; If we have a digit we are done here. 
1285			;                cp      '9' + 1         ; Is the result > 9? 
1285			;                jr      c, print_nibble_1 
1285			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1285			;print_nibble_1  call    putc            ; Print the nibble and 
1285			;                pop     af              ; restore the original value of A 
1285			;                ret 
1285			;; 
1285			;; Send a CR/LF pair: 
1285			; 
1285			;crlf            push    af 
1285			;                ld      a, cr 
1285			;                call    putc 
1285			;                ld      a, lf 
1285			;                call    putc 
1285			;                pop     af 
1285			;                ret 
1285			; 
1285			; Print_word prints the four hex digits of a word to the serial line. The  
1285			; word is expected to be in HL. 
1285			; 
1285			;print_word      push    hl 
1285			;                push    af 
1285			;                ld      a, h 
1285			;                call    print_byte 
1285			;                ld      a, l 
1285			;                call    print_byte 
1285			;                pop     af 
1285			;                pop     hl 
1285			;                ret 
1285			; 
1285			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1285			; The byte to be printed is expected to be in A. 
1285			; 
1285			;print_byte      push    af              ; Save the contents of the registers 
1285			;                push    bc 
1285			;                ld      b, a 
1285			;                rrca 
1285			;                rrca 
1285			;                rrca 
1285			;                rrca 
1285			;                call    print_nibble    ; Print high nibble 
1285			;                ld      a, b 
1285			;                call    print_nibble    ; Print low nibble 
1285			;                pop     bc              ; Restore original register contents 
1285			;                pop     af 
1285			;                ret 
1285			 
1285			 
1285			 
1285			 
1285			 
1285			fourehexhl:  
1285 7e				ld a,(hl) 
1286 cd 34 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 34 12			call atohex 
1298 80				add b 
1299 57				ld d,a 
129a 7e				ld a,(hl) 
129b cd 34 12			call atohex 
129e cb 3f				SRL A 
12a0 cb 3f				SRL A 
12a2 cb 3f				SRL A 
12a4 cb 3f				SRL A 
12a6 47				ld b, a 
12a7 23				inc hl 
12a8 7e				ld a,(hl) 
12a9 23				inc hl 
12aa cd 34 12			call atohex 
12ad 80				add b 
12ae 5f				ld e, a 
12af d5				push de 
12b0 e1				pop hl 
12b1 c9				ret 
12b2			 
12b2			; pass hl. returns z set if the byte at hl is a digit 
12b2			;isdigithl:  
12b2			;	push bc 
12b2			;	ld a,(hl) 
12b2			;	cp ':' 
12b2			;	jr nc, .isdf 		; > 
12b2			;	cp '0' 
12b2			;	jr c, .isdf		; < 
12b2			; 
12b2			;	; TODO find a better way to set z 
12b2			; 
12b2			;	ld b,a 
12b2			;	cp b 
12b2			;	pop bc 
12b2			;	ret 
12b2			; 
12b2			;.isdf:	; not digit so clear z 
12b2			; 
12b2			;	; TODO find a better way to unset z 
12b2			; 
12b2			;	ld b,a 
12b2			;	inc b 
12b2			;	cp b 
12b2			; 
12b2			;	pop bc 
12b2			;	ret 
12b2				 
12b2				 
12b2			 
12b2			 
12b2			; pass hl as the four byte address to load 
12b2			 
12b2			get_word_hl:  
12b2 e5				push hl 
12b3 cd 52 12			call get_byte 
12b6				 
12b6 47				ld b, a 
12b7			 
12b7 e1				pop hl 
12b8 23				inc hl 
12b9 23				inc hl 
12ba			 
12ba			; TODO not able to handle a-f  
12ba 7e				ld a,(hl) 
12bb			;	;cp ':' 
12bb			;	cp 'g' 
12bb			;	jr nc, .single_byte_hl 		; > 
12bb			;	cp 'G' 
12bb			;	jr nc, .single_byte_hl 		; > 
12bb			;	cp '0' 
12bb			;	jr c, .single_byte_hl		; < 
12bb			 
12bb				;call isdigithl 
12bb fe 00			cp 0 
12bd 28 06			jr z, .single_byte_hl 
12bf			 
12bf			.getwhln:   ; hex word so get next byte 
12bf			 
12bf cd 52 12			call get_byte 
12c2 6f				ld l, a 
12c3 60				ld h,b 
12c4 c9				ret 
12c5 68			.single_byte_hl:   ld l,b 
12c6 26 00				ld h,0 
12c8 c9					ret 
12c9			 
12c9			 
12c9			 
12c9			 
12c9 21 03 1c			ld hl,asc+1 
12cc			;	ld a, (hl) 
12cc			;	call nibble2val 
12cc cd 52 12			call get_byte 
12cf			 
12cf			;	call fourehexhl 
12cf 32 b9 f3			ld (scratch+52),a 
12d2				 
12d2 21 b7 f3			ld hl,scratch+50 
12d5 22 a8 f6			ld (os_cur_ptr),hl 
12d8			 
12d8 c9				ret 
12d9			 
12d9			 
12d9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12d9			 
12d9			; Decimal Unsigned Version 
12d9			 
12d9			;Number in a to decimal ASCII 
12d9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12d9			;Example: display a=56 as "056" 
12d9			;input: a = number 
12d9			;Output: a=0,value of a in the screen 
12d9			;destroys af,bc (don't know about hl and de) 
12d9			DispAToASCII: 
12d9 0e 9c			ld	c,-100 
12db cd e5 12			call	.Na1 
12de 0e f6			ld	c,-10 
12e0 cd e5 12			call	.Na1 
12e3 0e ff			ld	c,-1 
12e5 06 2f		.Na1:	ld	b,'0'-1 
12e7 04			.Na2:	inc	b 
12e8 81				add	a,c 
12e9 38 fc			jr	c,.Na2 
12eb 91				sub	c		;works as add 100/10/1 
12ec f5				push af		;safer than ld c,a 
12ed 78				ld	a,b		;char is in b 
12ee			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12ee f1				pop af		;safer than ld a,c 
12ef c9				ret 
12f0			 
12f0			; Decimal Signed Version 
12f0			 
12f0			; DispA 
12f0			; -------------------------------------------------------------- 
12f0			; Converts a signed integer value to a zero-terminated ASCII 
12f0			; string representative of that value (using radix 10). 
12f0			; -------------------------------------------------------------- 
12f0			; INPUTS: 
12f0			;     HL     Value to convert (two's complement integer). 
12f0			;     DE     Base address of string destination. (pointer). 
12f0			; -------------------------------------------------------------- 
12f0			; OUTPUTS: 
12f0			;     None 
12f0			; -------------------------------------------------------------- 
12f0			; REGISTERS/MEMORY DESTROYED 
12f0			; AF HL 
12f0			; -------------------------------------------------------------- 
12f0			 
12f0			;DispHLToASCII: 
12f0			;   push    de 
12f0			;   push    bc 
12f0			; 
12f0			;; Detect sign of HL. 
12f0			;    bit    7, h 
12f0			;    jr     z, ._DoConvert 
12f0			; 
12f0			;; HL is negative. Output '-' to string and negate HL. 
12f0			;    ld     a, '-' 
12f0			;    ld     (de), a 
12f0			;    inc    de 
12f0			; 
12f0			;; Negate HL (using two's complement) 
12f0			;    xor    a 
12f0			;    sub    l 
12f0			;    ld     l, a 
12f0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12f0			;    sbc    a, h 
12f0			;    ld     h, a 
12f0			; 
12f0			;; Convert HL to digit characters 
12f0			;._DoConvert: 
12f0			;    ld     b, 0     ; B will count character length of number 
12f0			;-   ld     a, 10 
12f0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12f0			;    push   af 
12f0			;    inc    b 
12f0			;    ld     a, h 
12f0			;    or     l 
12f0			;    jr     nz, - 
12f0			; 
12f0			;; Retrieve digits from stack 
12f0			;-   pop    af 
12f0			;    or     $30 
12f0			;    ld     (de), a 
12f0			;    inc    de 
12f0			;    djnz   - 
12f0			; 
12f0			;; Terminate string with NULL 
12f0			;    xor    a 
12f0			;    ld     (de), a 
12f0			; 
12f0			;    pop    bc 
12f0			;    pop    de 
12f0			;    ret 
12f0			 
12f0			;Comments 
12f0			; 
12f0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12f0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12f0			;    Note that the output string will not be fixed-width. 
12f0			; 
12f0			;Example Usage 
12f0			; 
12f0			;    ld    hl, -1004 
12f0			;    ld    de, OP1 
12f0			;    call  DispA 
12f0			;    ld    hl, OP1 
12f0			;    syscall  PutS 
12f0			 
12f0			 
12f0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f0			 
12f0			 
12f0			;Converts an ASCII string to an unsigned 16-bit integer 
12f0			;Quits when it reaches a non-decimal digit 
12f0			 
12f0			string_to_uint16: 
12f0			atoui_16: 
12f0			;Input: 
12f0			;     DE points to the string 
12f0			;Outputs: 
12f0			;     HL is the result 
12f0			;     A is the 8-bit value of the number 
12f0			;     DE points to the byte after the number 
12f0			;Destroys: 
12f0			;     BC 
12f0			;       if the string is non-empty, BC is HL/10 
12f0			;Size:  24 bytes 
12f0			;Speed: 42+d(104+{0,9}) 
12f0			;       d is the number of digits in the number 
12f0			;       max is 640 cycles for a 5 digit number 
12f0			;Assuming no leading zeros: 
12f0			;1 digit:  146cc 
12f0			;2 digit:  250cc 
12f0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12f0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12f0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12f0			;avg: 544.81158447265625cc (544+13297/16384) 
12f0			;=============================================================== 
12f0 21 00 00		  ld hl,0 
12f3			.u16a: 
12f3 1a			  ld a,(de) 
12f4 d6 30		  sub 30h 
12f6 fe 0a		  cp 10 
12f8 d0			  ret nc 
12f9 13			  inc de 
12fa 44			  ld b,h 
12fb 4d			  ld c,l 
12fc 29			  add hl,hl 
12fd 29			  add hl,hl 
12fe 09			  add hl,bc 
12ff 29			  add hl,hl 
1300 85			  add a,l 
1301 6f			  ld l,a 
1302 30 ef		  jr nc,.u16a 
1304 24			  inc h 
1305 c3 f3 12		  jp .u16a 
1308			 
1308			 
1308			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1308			 
1308			;written by Zeda 
1308			;Converts a 16-bit unsigned integer to an ASCII string. 
1308			 
1308			uitoa_16: 
1308			;Input: 
1308			;   DE is the number to convert 
1308			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1308			;Output: 
1308			;   HL points to the null-terminated ASCII string 
1308			;      NOTE: This isn't necessarily the same as the input HL. 
1308 d5			  push de 
1309 c5			  push bc 
130a f5			  push af 
130b eb			  ex de,hl 
130c			 
130c 01 f0 d8		  ld bc,-10000 
130f 3e 2f		  ld a,'0'-1 
1311 3c			  inc a 
1312 09			  add hl,bc  
1313 38 fc		   jr c,$-2 
1315 12			  ld (de),a 
1316 13			  inc de 
1317			 
1317 01 e8 03		  ld bc,1000 
131a 3e 3a		  ld a,'9'+1 
131c 3d			  dec a  
131d 09			  add hl,bc  
131e 30 fc		   jr nc,$-2 
1320 12			  ld (de),a 
1321 13			  inc de 
1322			 
1322 01 9c ff		  ld bc,-100 
1325 3e 2f		  ld a,'0'-1 
1327 3c			  inc a  
1328 09			  add hl,bc  
1329 38 fc		   jr c,$-2 
132b 12			  ld (de),a 
132c 13			  inc de 
132d			 
132d 7d			  ld a,l 
132e 26 3a		  ld h,'9'+1 
1330 25			  dec h  
1331 c6 0a		  add a,10  
1333 30 fb		   jr nc,$-3 
1335 c6 30		  add a,'0' 
1337 eb			  ex de,hl 
1338 72			  ld (hl),d 
1339 23			  inc hl 
133a 77			  ld (hl),a 
133b 23			  inc hl 
133c 36 00		  ld (hl),0 
133e			 
133e			;Now strip the leading zeros 
133e 0e fa		  ld c,-6 
1340 09			  add hl,bc 
1341 3e 30		  ld a,'0' 
1343 23			  inc hl  
1344 be			  cp (hl)  
1345 28 fc		  jr z,$-2 
1347			 
1347			;Make sure that the string is non-empty! 
1347 7e			  ld a,(hl) 
1348 b7			  or a 
1349 20 01		  jr nz,.atoub 
134b 2b			  dec hl 
134c			.atoub: 
134c			 
134c f1			  pop af 
134d c1			  pop bc 
134e d1			  pop de 
134f c9			  ret 
1350			 
1350			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1350			 
1350			toUpper: 
1350			;A is the char. 
1350			;If A is a lowercase letter, this sets it to the matching uppercase 
1350			;18cc or 30cc or 41cc 
1350			;avg: 26.75cc 
1350 fe 61		  cp 'a' 
1352 d8			  ret c 
1353 fe 7b		  cp 'z'+1 
1355 d0			  ret nc 
1356 d6 20		  sub 'a'-'A' 
1358 c9			  ret 
1359			 
1359			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1359			 
1359			; String Length 
1359			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1359			 
1359			; Get the length of the null-terminated string starting at $8000 hl 
1359			;    LD     HL, $8000 
1359			 
1359			strlenz: 
1359			 
1359 af			    XOR    A               ; Zero is the value we are looking for. 
135a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
135b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
135c			                           ; 65, 536 bytes (the entire addressable memory space). 
135c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
135e			 
135e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
135e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
135f 6f			    LD     L, A             ; number of bytes 
1360 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1362 2b			    DEC    HL              ; Compensate for null. 
1363 c9				ret 
1364			 
1364			; Get the length of the A terminated string starting at $8000 hl 
1364			;    LD     HL, $8000 
1364			 
1364			strlent: 
1364			 
1364			                  ; A is the value we are looking for. 
1364 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1366 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1368			                           ; 65, 536 bytes (the entire addressable memory space). 
1368 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
136a			 
136a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
136a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
136c 2e 00		    LD     L, 0             ; number of bytes 
136e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1370 2b			    DEC    HL              ; Compensate for null. 
1371 c9				ret 
1372			 
1372			 
1372			;Comparing Strings 
1372			 
1372			;IN    HL     Address of string1. 
1372			;      DE     Address of string2. 
1372			 
1372			; doc given but wrong??? 
1372			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1372			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1372			; tested 
1372			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1372			 
1372			strcmp_old: 
1372 e5			    PUSH   HL 
1373 d5			    PUSH   DE 
1374			 
1374 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1375 be			    CP     (HL)            ; (want to minimize work). 
1376 38 01		    JR     C, Str1IsBigger 
1378 7e			    LD     A, (HL) 
1379			 
1379			Str1IsBigger: 
1379 4f			    LD     C, A             ; Put length in BC 
137a 06 00		    LD     B, 0 
137c 13			    INC    DE              ; Increment pointers to meat of string. 
137d 23			    INC    HL 
137e			 
137e			CmpLoop: 
137e 1a			    LD     A, (DE)          ; Compare bytes. 
137f ed a1		    CPI 
1381 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1383 13			    INC    DE              ; Update pointer. 
1384 ea 7e 13		    JP     PE, CmpLoop 
1387			 
1387 d1			    POP    DE 
1388 e1			    POP    HL 
1389 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
138a be			    CP     (HL) 
138b c9			    RET 
138c			 
138c			NoMatch: 
138c 2b			    DEC    HL 
138d be			    CP     (HL)            ; Compare again to affect carry. 
138e d1			    POP    DE 
138f e1			    POP    HL 
1390 c9			    RET 
1391			 
1391			;; test strmp 
1391			; 
1391			;ld de, .str1 
1391			;ld hl, .str2 
1391			;call strcmp 
1391			;jr z, .z1 
1391			;;this 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "NZ1" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			;.z1: 
1391			; 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "ZZ1" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			; 
1391			;ld de, .str1 
1391			;ld hl, .str1 
1391			;call strcmp 
1391			;jr z, .z2 
1391			;;this 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "NZ2" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			;.z2: 
1391			; 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "ZZ2" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			; 
1391			;ld de, .str1 
1391			;ld hl, .str2 
1391			;call strcmp 
1391			;jr c, .c1 
1391			; 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "Nc1" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			;.c1: 
1391			;;this 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "cc1" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			; 
1391			;ld de, .str1 
1391			;ld hl, .str1 
1391			;call strcmp 
1391			;jr c, .c2 
1391			;;this 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "Nc2" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			;.c2: 
1391			; 
1391			;	if DEBUG_FORTH_WORDS 
1391			;		DMARK "cc2" 
1391			;		CALLMONITOR 
1391			;	endif 
1391			;	NEXTW 
1391			;.str1:   db "string1",0 
1391			;.str2:   db "string2",0 
1391			 
1391			; only care about direct match or not 
1391			; hl and de strings 
1391			; zero set if the same 
1391			 
1391			strcmp: 
1391 1a				ld a, (de) 
1392 be				cp (hl) 
1393 28 02			jr z, .ssame 
1395 b7				or a 
1396 c9				ret 
1397			 
1397			.ssame:  
1397 fe 00			cp 0 
1399 c8				ret z 
139a			 
139a 23				inc hl 
139b 13				inc de 
139c 18 f3			jr strcmp 
139e				 
139e				 
139e			 
139e			 
139e			 
139e			 
139e			; eof 
139e			 
139e			 
139e			 
139e			 
139e			 
139e			 
# End of file firmware_strings.asm
139e			include "firmware_memory.asm"   ; malloc and free  
139e			 
139e			if DEBUG_FORTH_MALLOC_HIGH 
139e			.mallocsize: db "Wants malloc >256",0 
139e			.mallocasize: db "MALLOC gives >256",0 
139e			.malloczero: db "MALLOC gives zero",0 
139e			 
139e			malloc_guard_zerolen: 
139e				push hl 
139e				push de 
139e				push af 
139e			 
139e				ld de, 0 
139e			        call cmp16 
139e				jr nz, .lowalloz 
139e			 
139e				push hl 
139e				push de 
139e					ld hl, display_fb0 
139e					ld (display_fb_active), hl 
139e				call clear_display 
139e				ld a, 0 
139e				ld de, .malloczero 
139e				call str_at_display 
139e				call update_display 
139e				call delay1s 
139e				call delay1s 
139e				ld a, 0 
139e				ld (os_view_disable), a 
139e			 
139e				pop de 
139e				pop hl 
139e			 
139e				 
139e			 
139e				CALLMONITOR 
139e			.lowalloz: 
139e			 
139e			 
139e				pop af 
139e				pop de 
139e				pop hl 
139e			ret 
139e			 
139e			malloc_guard_entry: 
139e				push hl 
139e				push de 
139e				push af 
139e			 
139e			 	or a      ;clear carry flag 
139e				push hl 
139e				ld de, 255 
139e				sbc hl, de 
139e				jr c, .lowalloc 
139e			 
139e				push de 
139e					ld hl, display_fb0 
139e					ld (display_fb_active), hl 
139e				call clear_display 
139e				ld a, 0 
139e				ld de, .mallocsize 
139e				call str_at_display 
139e				call update_display 
139e				call delay1s 
139e				call delay1s 
139e				ld a, 0 
139e				ld (os_view_disable), a 
139e			 
139e				pop de 
139e				pop hl 
139e			 
139e				 
139e			 
139e				CALLMONITOR 
139e				jr .lowdone 
139e			.lowalloc: 
139e			 
139e			 
139e				pop hl 
139e			.lowdone:	pop af 
139e				pop de 
139e				pop hl 
139e			ret 
139e			 
139e			malloc_guard_exit: 
139e				push hl 
139e				push de 
139e				push af 
139e			 
139e			 	or a      ;clear carry flag 
139e				push hl 
139e				ld de, 255 
139e				sbc hl, de 
139e				jr c, .lowallocx 
139e			 
139e				push de 
139e					ld hl, display_fb0 
139e					ld (display_fb_active), hl 
139e				call clear_display 
139e				ld a, 0 
139e				ld de, .mallocasize 
139e				call str_at_display 
139e				call update_display 
139e				call delay1s 
139e				call delay1s 
139e				ld a, 0 
139e				ld (os_view_disable), a 
139e				pop de 
139e				pop hl 
139e			 
139e				CALLMONITOR 
139e				jr .lowdonex 
139e			.lowallocx: 
139e			 
139e				pop hl 
139e			.lowdonex:	pop af 
139e				pop de 
139e				pop hl 
139e			ret 
139e			endif 
139e			 
139e			if MALLOC_2 
139e			; Z80 Malloc and Free Functions 
139e			 
139e			; Malloc Function: 
139e			; Input: 
139e			;   HL: Size of block to allocate 
139e			; Output: 
139e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
139e			 
139e			malloc: 
139e				 
139e			if DEBUG_FORTH_MALLOC_HIGH 
139e			call malloc_guard_entry 
139e			endif 
139e			 
139e			 
139e			 
139e			 
139e					if DEBUG_FORTH_MALLOC 
139e						DMARK "mal" 
139e						CALLMONITOR 
139e					endif 
139e			    push af            ; Save AF register 
139e			    ld a, l            ; Load low byte of size into A 
139e			    or h               ; Check if size is zero 
139e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
139e			 
139e			    ; Allocate memory 
139e			    ld hl, (heap_start) ; Load start of heap into HL 
139e					if DEBUG_FORTH_MALLOC 
139e						DMARK "ma1" 
139e						CALLMONITOR 
139e					endif 
139e			    call malloc_internal ; Call internal malloc function 
139e			    pop af             ; Restore AF register 
139e			if DEBUG_FORTH_MALLOC_HIGH 
139e			call malloc_guard_exit 
139e			call malloc_guard_zerolen 
139e			endif 
139e			    ret                ; Return 
139e			 
139e			; Free Function: 
139e			; Input: 
139e			;   HL: Pointer to memory block to free 
139e			; Output: 
139e			;   None 
139e			 
139e			free: 
139e			    push af            ; Save AF register 
139e			    ld a, l            ; Load low byte of pointer into A 
139e			    or h               ; Check if pointer is NULL 
139e			    jp z, free_exit    ; If pointer is NULL, exit 
139e			 
139e			    ; Free memory 
139e			    ld hl, (heap_start) ; Load start of heap into HL 
139e			    call free_internal  ; Call internal free function 
139e			    pop af             ; Restore AF register 
139e			    ret                ; Return 
139e			 
139e			; Internal Malloc Function: 
139e			; Input: 
139e			;   HL: Size of block to allocate 
139e			; Output: 
139e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
139e			 
139e			malloc_internal: 
139e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
139e			    add hl, bc         ; Add management overhead to requested size 
139e			    ex de, hl          ; Save total size in DE, and keep it in HL 
139e					if DEBUG_FORTH_MALLOC 
139e						DMARK "ma2" 
139e						CALLMONITOR 
139e					endif 
139e			 
139e			    ; Search for free memory block 
139e			    ld de, (heap_end)  ; Load end of heap into DE 
139e			    ld bc, 0           ; Initialize counter 
139e			 
139e					if DEBUG_FORTH_MALLOC 
139e						DMARK "ma2" 
139e						CALLMONITOR 
139e					endif 
139e			malloc_search_loop: 
139e			    ; Check if current block is free 
139e			    ld a, (hl)         ; Load current block's status (free or used) 
139e			    cp 0               ; Compare with zero (free) 
139e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
139e			 
139e			    ; Check if current block is large enough 
139e			    ld a, (hl+1)       ; Load high byte of block size 
139e			    cp l               ; Compare with low byte of requested size 
139e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
139e			 
139e			    ld a, (hl+2)       ; Load low byte of block size 
139e			    cp h               ; Compare with high byte of requested size 
139e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
139e			 
139e			    ; Mark block as used 
139e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
139e			 
139e			    ; Calculate remaining space in block 
139e			    ld bc, 0           ; Clear BC 
139e			    add hl, bc         ; Increment HL to point to start of data block 
139e			    add hl, de         ; HL = HL + DE (total size) 
139e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
139e			    add hl, bc         ; Add management overhead to start of data block 
139e			 
139e			    ; Save pointer to allocated block in HL 
139e			if DEBUG_FORTH_MALLOC_HIGH 
139e						DMARK "ma5" 
139e			call malloc_guard_exit 
139e			call malloc_guard_zerolen 
139e			endif 
139e			    ret 
139e			 
139e			malloc_skip_block_check: 
139e			    ; Move to the next block 
139e			    ld bc, 3           ; Size of management overhead 
139e			    add hl, bc         ; Move to the next block 
139e			    inc de             ; Increment counter 
139e			 
139e			    ; Check if we have reached the end of heap 
139e			    ld a, e            ; Load low byte of heap end address 
139e			    cp (hl)            ; Compare with low byte of current address 
139e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
139e			    ld a, d            ; Load high byte of heap end address 
139e			    cp 0               ; Check if it's zero (end of memory) 
139e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
139e			 
139e			    ; If we reached here, allocation failed 
139e			    xor a              ; Set result to NULL 
139e			if DEBUG_FORTH_MALLOC_HIGH 
139e						DMARK "ma6" 
139e			call malloc_guard_exit 
139e			call malloc_guard_zerolen 
139e			endif 
139e			    ret 
139e			malloc_exit: 
139e			if DEBUG_FORTH_MALLOC_HIGH 
139e						DMARK "ma7" 
139e			call malloc_guard_exit 
139e			call malloc_guard_zerolen 
139e			endif 
139e			    ret 
139e			 
139e			; Internal Free Function: 
139e			; Input: 
139e			;   HL: Pointer to memory block to free 
139e			; Output: 
139e			;   None 
139e			 
139e			free_internal: 
139e			    ld de, (heap_start) ; Load start of heap into DE 
139e			    ld bc, 0            ; Initialize counter 
139e			 
139e			free_search_loop: 
139e			    ; Check if current block contains the pointer 
139e			    ld a, l             ; Load low byte of pointer 
139e			    cp (hl+1)           ; Compare with high byte of current block's address 
139e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
139e			    ld a, h             ; Load high byte of pointer 
139e			    cp (hl+2)           ; Compare with low byte of current block's address 
139e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
139e			 
139e			    ; Mark block as free 
139e			    ld (hl), 0          ; Set status byte to indicate free block 
139e			    ret                 ; Return 
139e			 
139e			free_skip_block_check: 
139e			    ; Move to the next block 
139e			    ld bc, 3            ; Size of management overhead 
139e			    add hl, bc          ; Move to the next block 
139e			    inc de              ; Increment counter 
139e			 
139e			    ; Check if we have reached the end of heap 
139e			    ld a, e             ; Load low byte of heap end address 
139e			    cp (hl)             ; Compare with low byte of current address 
139e			    jr nz, free_search_loop  ; If not equal, continue searching 
139e			    ld a, d             ; Load high byte of heap end address 
139e			    cp 0                ; Check if it's zero (end of memory) 
139e			    jr nz, free_search_loop  ; If not zero, continue searching 
139e			 
139e			    ; If we reached here, pointer is not found in heap 
139e			    ret 
139e			 
139e			free_exit: 
139e			    ret                 ; Return 
139e			 
139e			; Define heap start and end addresses 
139e			;heap_start:    .dw 0xC000   ; Start of heap 
139e			;heap_end:      .dw 0xE000   ; End of heap 
139e			 
139e			endif 
139e			 
139e			 
139e			if MALLOC_1 
139e			 
139e			 
139e			 
139e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
139e			 
139e			;moved to firmware.asm 
139e			;heap_start        .equ  0x9000      ; Starting address of heap 
139e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
139e			 
139e			;      .org 0 
139e			;      jp    main 
139e			 
139e			 
139e			;      .org  0x100 
139e			;main: 
139e			;      ld    HL, 0x8100 
139e			;      ld    SP, HL 
139e			; 
139e			;      call  heap_init 
139e			; 
139e			;      ; Make some allocations 
139e			;      ld    HL, 12 
139e			;      call  malloc            ; Allocates 0x9004 
139e			; 
139e			;      ld    HL, 12 
139e			;      call  malloc            ; Allocates 0x9014 
139e			; 
139e			;      ld    HL, 12 
139e			;      call  malloc            ; Allocates 0x9024 
139e			; 
139e			;      ; Free some allocations 
139e			;      ld    HL, 0x9014 
139e			;      call  free 
139e			; 
139e			;      ld    HL, 0x9004 
139e			;      call  free 
139e			; 
139e			;      ld    HL, 0x9024 
139e			;      call  free 
139e			; 
139e			; 
139e			;      halt 
139e			 
139e			 
139e			;------------------------------------------------------------------------------ 
139e			;     heap_init                                                               : 
139e			;                                                                             : 
139e			; Description                                                                 : 
139e			;     Initialise the heap and make it ready for malloc and free operations.   : 
139e			;                                                                             : 
139e			;     The heap is maintained as a linked list, starting with an initial       : 
139e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
139e			;     the first free block in the heap. Each block then points to the next    : 
139e			;     free block within the heap, and the free list ends at the first block   : 
139e			;     with a null pointer to the next free block.                             : 
139e			;                                                                             : 
139e			; Parameters                                                                  : 
139e			;     Inputs are compile-time only. Two defines which specify the starting    : 
139e			;     address of the heap and its size are required, along with a memory      : 
139e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
139e			;     principally stores a pointer to the first free block in the heap.       : 
139e			;                                                                             : 
139e			; Returns                                                                     : 
139e			;     Nothing                                                                 : 
139e			;------------------------------------------------------------------------------ 
139e			heap_init: 
139e e5			      push  HL 
139f			 
139f			      ; Initialise free list struct 
139f 21 0e 80		      ld    HL, heap_start 
13a2 22 0a 80		      ld    (free_list), HL 
13a5 21 00 00		      ld    HL, 0 
13a8 22 0c 80		      ld    (free_list+2), HL 
13ab			 
13ab			      ; Insert first free block at bottom of heap, consumes entire heap 
13ab 21 0a 80		      ld    HL, heap_start+heap_size-4 
13ae 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13b1 21 fc ff		      ld    HL, heap_size-4 
13b4 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13b7			 
13b7			      ; Insert end of free list block at top of heap - two null words will 
13b7			      ; terminate the free list 
13b7 21 00 00		      ld    HL, 0 
13ba 22 0c 80		      ld    (heap_start+heap_size-2), HL 
13bd 22 0a 80		      ld    (heap_start+heap_size-4), HL 
13c0			 
13c0 e1			      pop   HL 
13c1			 
13c1 c9			      ret 
13c2			 
13c2			 
13c2			;------------------------------------------------------------------------------ 
13c2			;     malloc                                                                  : 
13c2			;                                                                             : 
13c2			; Description                                                                 : 
13c2			;     Allocates the wanted space from the heap and returns the address of the : 
13c2			;     first useable byte of the allocation.                                   : 
13c2			;                                                                             : 
13c2			;     Allocations can happen in one of two ways:                              : 
13c2			;                                                                             : 
13c2			;     1. A free block may be found which is the exact size wanted. In this    : 
13c2			;        case the block is removed from the free list and retuedn to the      : 
13c2			;        caller.                                                              : 
13c2			;     2. A free block may be found which is larger than the size wanted. In   : 
13c2			;        this case, the larger block is split into two. The first portion of  : 
13c2			;        this block will become the requested space by the malloc call and    : 
13c2			;        is returned to the caller. The second portion becomes a new free     : 
13c2			;        block, and the free list is adjusted to maintain continuity via this : 
13c2			;        newly created block.                                                 : 
13c2			;                                                                             : 
13c2			;     malloc does not set any initial value in the allocated space, the       : 
13c2			;     caller is required to do this as required.                              : 
13c2			;                                                                             : 
13c2			;     This implementation of malloc uses the stack exclusively, and is        : 
13c2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13c2			;     advisable to disable interrupts before calling malloc, and recommended  : 
13c2			;     to avoid the use of malloc inside ISRs in general.                      : 
13c2			;                                                                             : 
13c2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13c2			;                                                                             : 
13c2			; Parameters                                                                  : 
13c2			;     HL  Number of bytes wanted                                              : 
13c2			;                                                                             : 
13c2			; Returns                                                                     : 
13c2			;     HL  Address of the first useable byte of the allocation                 : 
13c2			;                                                                             : 
13c2			; Flags                                                                       : 
13c2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13c2			;                                                                             : 
13c2			; Stack frame                                                                 : 
13c2			;       |             |                                                       : 
13c2			;       +-------------+                                                       : 
13c2			;       |     BC      |                                                       : 
13c2			;       +-------------+                                                       : 
13c2			;       |     DE      |                                                       : 
13c2			;       +-------------+                                                       : 
13c2			;       |     IX      |                                                       : 
13c2			;       +-------------+                                                       : 
13c2			;       |  prev_free  |                                                       : 
13c2			;   +4  +-------------+                                                       : 
13c2			;       |  this_free  |                                                       : 
13c2			;   +2  +-------------+                                                       : 
13c2			;       |  next_free  |                                                       : 
13c2			;   +0  +-------------+                                                       : 
13c2			;       |             |                                                       : 
13c2			;                                                                             : 
13c2			;------------------------------------------------------------------------------ 
13c2			 
13c2			 
13c2			;malloc: 
13c2			; 
13c2			;	SAVESP ON 1 
13c2			; 
13c2			;	call malloc_code 
13c2			; 
13c2			;	CHECKSP ON 1 
13c2			;	ret 
13c2			 
13c2			 
13c2			malloc: 
13c2 c5			      push  BC 
13c3 d5			      push  DE 
13c4 dd e5		      push  IX 
13c6			if DEBUG_FORTH_MALLOC_HIGH 
13c6			call malloc_guard_entry 
13c6			endif 
13c6			 
13c6					if DEBUG_FORTH_MALLOC 
13c6						DMARK "mal" 
13c6						CALLMONITOR 
13c6					endif 
13c6 7c			      ld    A, H                    ; Exit if no space requested 
13c7 b5			      or    L 
13c8 ca 87 14		      jp    Z, malloc_early_exit 
13cb			 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			; 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			;inc hl 
13cb			 
13cb			 
13cb			 
13cb			 
13cb					if DEBUG_FORTH_MALLOC 
13cb						DMARK "maA" 
13cb						CALLMONITOR 
13cb					endif 
13cb			      ; Set up stack frame 
13cb eb			      ex    DE, HL 
13cc 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13cf 39			      add   HL, SP 
13d0 f9			      ld    SP, HL 
13d1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13d5 dd 39		      add   IX, SP 
13d7			 
13d7			      ; Setup initial state 
13d7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13da 19			      add   HL, DE 
13db			 
13db 44			      ld    B, H                    ; Move want to BC 
13dc 4d			      ld    C, L 
13dd			 
13dd 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13e0 dd 75 04		      ld    (IX+4), L 
13e3 dd 74 05		      ld    (IX+5), H 
13e6			 
13e6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13e7 23			      inc   HL 
13e8 56			      ld    D, (HL) 
13e9 dd 73 02		      ld    (IX+2), E 
13ec dd 72 03		      ld    (IX+3), D 
13ef eb			      ex    DE, HL                  ; this_free ptr into HL 
13f0			 
13f0					if DEBUG_FORTH_MALLOC 
13f0						DMARK "maB" 
13f0						CALLMONITOR 
13f0					endif 
13f0			      ; Loop through free block list to find some space 
13f0			malloc_find_space: 
13f0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13f1 23			      inc   HL 
13f2 56			      ld    D, (HL) 
13f3			 
13f3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13f4 b3			      or    E 
13f5 ca 81 14		      jp    Z, malloc_no_space 
13f8			 
13f8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13fb dd 72 01		      ld    (IX+1), D 
13fe			 
13fe			      ; Does this block have enough space to make the allocation? 
13fe 23			      inc   HL                      ; Load free block size into DE 
13ff 5e			      ld    E, (HL) 
1400 23			      inc   HL 
1401 56			      ld    D, (HL) 
1402			 
1402 eb			      ex    DE, HL                  ; Check size of block against want 
1403 b7			      or    A                       ; Ensure carry flag clear 
1404 ed 42		      sbc   HL, BC 
1406 e5			      push  HL                      ; Store the result for later (new block size) 
1407			 
1407 ca 56 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
140a 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
140c			 
140c			      ; this_free block is not big enough, setup ptrs to test next free block 
140c e1			      pop   HL                      ; Discard previous result 
140d			 
140d dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1410 dd 66 03		      ld    H, (IX+3) 
1413 dd 75 04		      ld    (IX+4), L 
1416 dd 74 05		      ld    (IX+5), H 
1419			 
1419 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
141c dd 66 01		      ld    H, (IX+1) 
141f dd 75 02		      ld    (IX+2), L 
1422 dd 74 03		      ld    (IX+3), H 
1425			 
1425					if DEBUG_FORTH_MALLOC 
1425						DMARK "MA>" 
1425						CALLMONITOR 
1425					endif 
1425 18 c9		      jr    malloc_find_space 
1427			 
1427			      ; split a bigger block into two - requested size and remaining size 
1427			malloc_alloc_split: 
1427					if DEBUG_FORTH_MALLOC 
1427						DMARK "MAs" 
1427						CALLMONITOR 
1427					endif 
1427 eb			      ex    DE, HL                  ; Calculate address of new free block 
1428 2b			      dec   HL 
1429 2b			      dec   HL 
142a 2b			      dec   HL 
142b 09			      add   HL, BC 
142c			 
142c			      ; Create a new block and point it at next_free 
142c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
142f dd 56 01		      ld    D, (IX+1) 
1432			 
1432 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1433 23			      inc   HL 
1434 72			      ld    (HL), D 
1435			 
1435 d1			      pop   DE                      ; Store size of new block into new block 
1436 23			      inc   HL 
1437 73			      ld    (HL), E 
1438 23			      inc   HL 
1439 72			      ld    (HL), D 
143a			 
143a			      ; Update this_free ptr to point to new block 
143a 2b			      dec   HL 
143b 2b			      dec   HL 
143c 2b			      dec   HL 
143d			 
143d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1440 dd 56 03		      ld    D, (IX+3) 
1443			 
1443 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1446 dd 74 03		      ld    (IX+3), H 
1449			 
1449			      ; Modify this_free block to be allocation 
1449 eb			      ex    DE, HL 
144a af			      xor   A                       ; Null the next block ptr of allocated block 
144b 77			      ld    (HL), A 
144c 23			      inc   HL 
144d 77			      ld    (HL), A 
144e			 
144e 23			      inc   HL                      ; Store want size into allocated block 
144f 71			      ld    (HL), C 
1450 23			      inc   HL 
1451 70			      ld    (HL), B 
1452 23			      inc   HL 
1453 e5			      push  HL                      ; Address of allocation to return 
1454			 
1454 18 19		      jr    malloc_update_links 
1456			 
1456			malloc_alloc_fit: 
1456 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1457			 
1457					if DEBUG_FORTH_MALLOC 
1457						DMARK "MAf" 
1457						CALLMONITOR 
1457					endif 
1457			      ; Modify this_free block to be allocation 
1457 eb			      ex    DE, HL 
1458 2b			      dec   HL 
1459 2b			      dec   HL 
145a 2b			      dec   HL 
145b			 
145b af			      xor   A                       ; Null the next block ptr of allocated block 
145c 77			      ld    (HL), A 
145d 23			      inc   HL 
145e 77			      ld    (HL), A 
145f			 
145f 23			      inc   HL                      ; Store address of allocation to return 
1460 23			      inc   HL 
1461 23			      inc   HL 
1462 e5			      push  HL 
1463			 
1463			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1463 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1466 dd 66 01		      ld    H, (IX+1) 
1469			 
1469 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
146c dd 74 03		      ld    (IX+3), H 
146f			 
146f			 
146f			malloc_update_links: 
146f			      ; Update prev_free ptr to point to this_free 
146f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1472 dd 66 05		      ld    H, (IX+5) 
1475			 
1475 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1478 dd 56 03		      ld    D, (IX+3) 
147b			 
147b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
147c 23			      inc   HL 
147d 72			      ld    (HL), D 
147e			 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "Mul" 
147e						CALLMONITOR 
147e					endif 
147e			      ; Clear the Z flag to indicate successful allocation 
147e 7a			      ld    A, D 
147f b3			      or    E 
1480			 
1480 d1			      pop   DE                      ; Address of allocation 
1481					if DEBUG_FORTH_MALLOC 
1481						DMARK "MAu" 
1481						CALLMONITOR 
1481					endif 
1481			 
1481			malloc_no_space: 
1481 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1484 39			      add   HL, SP 
1485 f9			      ld    SP, HL 
1486			 
1486 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1487					if DEBUG_FORTH_MALLOC 
1487						DMARK "MAN" 
1487						CALLMONITOR 
1487					endif 
1487			 
1487			malloc_early_exit: 
1487					if DEBUG_FORTH_MALLOC 
1487						DMARK "MAx" 
1487						CALLMONITOR 
1487					endif 
1487 dd e1		      pop   IX 
1489 d1			      pop   DE 
148a c1			      pop   BC 
148b			 
148b			if DEBUG_FORTH_MALLOC_HIGH 
148b			call malloc_guard_exit 
148b			call malloc_guard_zerolen 
148b			endif 
148b c9			      ret 
148c			 
148c			 
148c			;------------------------------------------------------------------------------ 
148c			;     free                                                                    : 
148c			;                                                                             : 
148c			; Description                                                                 : 
148c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
148c			;     returned by malloc, otherwise the behaviour is undefined.               : 
148c			;                                                                             : 
148c			;     Where possible, directly adjacent free blocks will be merged together   : 
148c			;     into larger blocks to help ensure that the heap does not become         : 
148c			;     excessively fragmented.                                                 : 
148c			;                                                                             : 
148c			;     free does not clear or set any other value into the freed space, and    : 
148c			;     therefore its contents may be visible through subsequent malloc's. The  : 
148c			;     caller should clear the freed space as required.                        : 
148c			;                                                                             : 
148c			;     This implementation of free uses the stack exclusively, and is          : 
148c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
148c			;     advisable to disable interrupts before calling free, and recommended    : 
148c			;     to avoid the use of free inside ISRs in general.                        : 
148c			;                                                                             : 
148c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
148c			;                                                                             : 
148c			; Parameters                                                                  : 
148c			;     HL  Pointer to address of first byte of allocation to be freed          : 
148c			;                                                                             : 
148c			; Returns                                                                     : 
148c			;     Nothing                                                                 : 
148c			;                                                                             : 
148c			; Stack frame                                                                 : 
148c			;       |             |                                                       : 
148c			;       +-------------+                                                       : 
148c			;       |     BC      |                                                       : 
148c			;       +-------------+                                                       : 
148c			;       |     DE      |                                                       : 
148c			;       +-------------+                                                       : 
148c			;       |     IX      |                                                       : 
148c			;       +-------------+                                                       : 
148c			;       |  prev_free  |                                                       : 
148c			;   +2  +-------------+                                                       : 
148c			;       |  next_free  |                                                       : 
148c			;   +0  +-------------+                                                       : 
148c			;       |             |                                                       : 
148c			;                                                                             : 
148c			;------------------------------------------------------------------------------ 
148c			free: 
148c c5			      push  BC 
148d d5			      push  DE 
148e dd e5		      push  IX 
1490			 
1490 7c			      ld    A, H                    ; Exit if ptr is null 
1491 b5			      or    L 
1492 ca 56 15		      jp    Z, free_early_exit 
1495			 
1495			      ; Set up stack frame 
1495 eb			      ex    DE, HL 
1496 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1499 39			      add   HL, SP 
149a f9			      ld    SP, HL 
149b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
149f dd 39		      add   IX, SP 
14a1			 
14a1			      ; The address in HL points to the start of the useable allocated space, 
14a1			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14a1			      ; address of the block itself. 
14a1 eb			      ex    DE, HL 
14a2 11 fc ff		      ld    DE, -4 
14a5 19			      add   HL, DE 
14a6			 
14a6			      ; An allocated block must have a null next block pointer in it 
14a6 7e			      ld    A, (HL) 
14a7 23			      inc   HL 
14a8 b6			      or    (HL) 
14a9 c2 51 15		      jp    NZ, free_done 
14ac			 
14ac 2b			      dec   HL 
14ad			 
14ad 44			      ld    B, H                    ; Copy HL to BC 
14ae 4d			      ld    C, L 
14af			 
14af			      ; Loop through the free list to find the first block with an address 
14af			      ; higher than the block being freed 
14af 21 0a 80		      ld    HL, free_list 
14b2			 
14b2			free_find_higher_block: 
14b2 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14b3 23			      inc   HL 
14b4 56			      ld    D, (HL) 
14b5 2b			      dec   HL 
14b6			 
14b6 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b9 dd 72 01		      ld    (IX+1), D 
14bc dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14bf dd 74 03		      ld    (IX+3), H 
14c2			 
14c2 78			      ld    A, B                    ; Check if DE is greater than BC 
14c3 ba			      cp    D                       ; Compare MSB first 
14c4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14c6 30 04		      jr    NC, free_find_higher_block_skip 
14c8 79			      ld    A, C 
14c9 bb			      cp    E                       ; Then compare LSB 
14ca 38 08		      jr    C, free_found_higher_block 
14cc			 
14cc			free_find_higher_block_skip: 
14cc 7a			      ld    A, D                    ; Reached the end of the free list? 
14cd b3			      or    E 
14ce ca 51 15		      jp    Z, free_done 
14d1			 
14d1 eb			      ex    DE, HL 
14d2			 
14d2 18 de		      jr    free_find_higher_block 
14d4			 
14d4			free_found_higher_block: 
14d4			      ; Insert freed block between prev and next free blocks 
14d4 71			      ld    (HL), C                 ; Point prev free block to freed block 
14d5 23			      inc   HL 
14d6 70			      ld    (HL), B 
14d7			 
14d7 60			      ld    H, B                    ; Point freed block at next free block 
14d8 69			      ld    L, C 
14d9 73			      ld    (HL), E 
14da 23			      inc   HL 
14db 72			      ld    (HL), D 
14dc			 
14dc			      ; Check if the freed block is adjacent to the next free block 
14dc 23			      inc   HL                      ; Load size of freed block into HL 
14dd 5e			      ld    E, (HL) 
14de 23			      inc   HL 
14df 56			      ld    D, (HL) 
14e0 eb			      ex    DE, HL 
14e1			 
14e1 09			      add   HL, BC                  ; Add addr of freed block and its size 
14e2			 
14e2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14e5 dd 56 01		      ld    D, (IX+1) 
14e8			 
14e8 b7			      or    A                       ; Clear the carry flag 
14e9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14eb 20 22		      jr    NZ, free_check_adjacent_to_prev 
14ed			 
14ed			      ; Freed block is adjacent to next, merge into one bigger block 
14ed eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14ee 5e			      ld    E, (HL) 
14ef 23			      inc   HL 
14f0 56			      ld    D, (HL) 
14f1 e5			      push  HL                      ; Save ptr to next block for later 
14f2			 
14f2 60			      ld    H, B                    ; Store ptr from next block into freed block 
14f3 69			      ld    L, C 
14f4 73			      ld    (HL), E 
14f5 23			      inc   HL 
14f6 72			      ld    (HL), D 
14f7			 
14f7 e1			      pop   HL                      ; Restore ptr to next block 
14f8 23			      inc   HL                      ; Load size of next block into DE 
14f9 5e			      ld    E, (HL) 
14fa 23			      inc   HL 
14fb 56			      ld    D, (HL) 
14fc d5			      push  DE                      ; Save next block size for later 
14fd			 
14fd 60			      ld    H, B                    ; Load size of freed block into HL 
14fe 69			      ld    L, C 
14ff 23			      inc   HL 
1500 23			      inc   HL 
1501 5e			      ld    E, (HL) 
1502 23			      inc   HL 
1503 56			      ld    D, (HL) 
1504 eb			      ex    DE, HL 
1505			 
1505 d1			      pop   DE                      ; Restore size of next block 
1506 19			      add   HL, DE                  ; Add sizes of both blocks 
1507 eb			      ex    DE, HL 
1508			 
1508 60			      ld    H, B                    ; Store new bigger size into freed block 
1509 69			      ld    L, C 
150a 23			      inc   HL 
150b 23			      inc   HL 
150c 73			      ld    (HL), E 
150d 23			      inc   HL 
150e 72			      ld    (HL), D 
150f			 
150f			free_check_adjacent_to_prev: 
150f			      ; Check if the freed block is adjacent to the prev free block 
150f dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1512 dd 66 03		      ld    H, (IX+3) 
1515			 
1515 23			      inc   HL                      ; Size of prev free block into DE 
1516 23			      inc   HL 
1517 5e			      ld    E, (HL) 
1518 23			      inc   HL 
1519 56			      ld    D, (HL) 
151a 2b			      dec   HL 
151b 2b			      dec   HL 
151c 2b			      dec   HL 
151d			 
151d 19			      add   HL, DE                  ; Add prev block addr and size 
151e			 
151e b7			      or    A                       ; Clear the carry flag 
151f ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1521 20 2e		      jr    NZ, free_done 
1523			 
1523			      ; Freed block is adjacent to prev, merge into one bigger block 
1523 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1524 69			      ld    L, C 
1525 5e			      ld    E, (HL) 
1526 23			      inc   HL 
1527 56			      ld    D, (HL) 
1528 e5			      push  HL                      ; Save freed block ptr for later 
1529			 
1529 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
152c dd 66 03		      ld    H, (IX+3) 
152f 73			      ld    (HL), E 
1530 23			      inc   HL 
1531 72			      ld    (HL), D 
1532			 
1532 e1			      pop   HL                      ; Restore freed block ptr 
1533 23			      inc   HL                      ; Load size of freed block into DE 
1534 5e			      ld    E, (HL) 
1535 23			      inc   HL 
1536 56			      ld    D, (HL) 
1537 d5			      push  DE                      ; Save freed block size for later 
1538			 
1538 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
153b dd 66 03		      ld    H, (IX+3) 
153e 23			      inc   HL 
153f 23			      inc   HL 
1540 5e			      ld    E, (HL) 
1541 23			      inc   HL 
1542 56			      ld    D, (HL) 
1543			 
1543 e1			      pop   HL                      ; Add sizes of both blocks 
1544 19			      add   HL, DE 
1545 eb			      ex    DE, HL 
1546			 
1546 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1549 dd 66 03		      ld    H, (IX+3) 
154c 23			      inc   HL 
154d 23			      inc   HL 
154e 73			      ld    (HL), E 
154f 23			      inc   HL 
1550 72			      ld    (HL), D 
1551			 
1551			free_done: 
1551 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1554 39			      add   HL, SP 
1555 f9			      ld    SP, HL 
1556			 
1556			free_early_exit: 
1556 dd e1		      pop   IX 
1558 d1			      pop   DE 
1559 c1			      pop   BC 
155a			 
155a c9			      ret 
155b			 
155b			; moved to firmware.asm 
155b			; 
155b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
155b			;                  .dw   0 
155b			 
155b			 
155b			endif 
155b			 
155b			 
155b			if MALLOC_3 
155b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
155b			;heap_start        .equ  0x9000      ; Starting address of heap 
155b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
155b			; 
155b			 ;     .org 0 
155b			  ;    jp    main 
155b			; 
155b			; 
155b			 ;     .org  0x100 
155b			;main: 
155b			 ;     ld    HL, 0x8100 
155b			  ;    ld    SP, HL 
155b			; 
155b			;      call  heap_init 
155b			 
155b			      ; Make some allocations 
155b			;      ld    HL, 12 
155b			;      call  malloc            ; Allocates 0x9004 
155b			; 
155b			 ;     ld    HL, 12 
155b			;      call  malloc            ; Allocates 0x9014 
155b			 
155b			;      ld    HL, 12 
155b			;      call  malloc            ; Allocates 0x9024 
155b			 
155b			      ; Free some allocations 
155b			;      ld    HL, 0x9014 
155b			;      call  free 
155b			 
155b			;      ld    HL, 0x9004 
155b			;      call  free 
155b			; 
155b			;      ld    HL, 0x9024 
155b			;      call  free 
155b			 
155b			 
155b			 ;     halt 
155b			 
155b			 
155b			;------------------------------------------------------------------------------ 
155b			;     heap_init                                                               : 
155b			;                                                                             : 
155b			; Description                                                                 : 
155b			;     Initialise the heap and make it ready for malloc and free operations.   : 
155b			;                                                                             : 
155b			;     The heap is maintained as a linked list, starting with an initial       : 
155b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
155b			;     the first free block in the heap. Each block then points to the next    : 
155b			;     free block within the heap, and the free list ends at the first block   : 
155b			;     with a null pointer to the next free block.                             : 
155b			;                                                                             : 
155b			; Parameters                                                                  : 
155b			;     Inputs are compile-time only. Two defines which specify the starting    : 
155b			;     address of the heap and its size are required, along with a memory      : 
155b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
155b			;     principally stores a pointer to the first free block in the heap.       : 
155b			;                                                                             : 
155b			; Returns                                                                     : 
155b			;     Nothing                                                                 : 
155b			;------------------------------------------------------------------------------ 
155b			heap_init: 
155b			      push  HL 
155b			 
155b			      ; Initialise free list struct 
155b			      ld    HL, heap_start 
155b			      ld    (free_list), HL 
155b			      ld    HL, 0 
155b			      ld    (free_list+2), HL 
155b			 
155b			      ; Insert first free block at bottom of heap, consumes entire heap 
155b			      ld    HL, heap_start+heap_size-4 
155b			      ld    (heap_start), HL        ; Next block (end of free list) 
155b			      ld    HL, heap_size-4 
155b			      ld    (heap_start+2), HL      ; Block size 
155b			 
155b			      ; Insert end of free list block at top of heap - two null words will 
155b			      ; terminate the free list 
155b			      ld    HL, 0 
155b			      ld    (heap_start+heap_size-2), HL 
155b			      ld    (heap_start+heap_size-4), HL 
155b			 
155b			      pop   HL 
155b			 
155b			      ret 
155b			 
155b			 
155b			;------------------------------------------------------------------------------ 
155b			;     malloc                                                                  : 
155b			;                                                                             : 
155b			; Description                                                                 : 
155b			;     Allocates the wanted space from the heap and returns the address of the : 
155b			;     first useable byte of the allocation.                                   : 
155b			;                                                                             : 
155b			;     Allocations can happen in one of two ways:                              : 
155b			;                                                                             : 
155b			;     1. A free block may be found which is the exact size wanted. In this    : 
155b			;        case the block is removed from the free list and retuedn to the      : 
155b			;        caller.                                                              : 
155b			;     2. A free block may be found which is larger than the size wanted. In   : 
155b			;        this case, the larger block is split into two. The first portion of  : 
155b			;        this block will become the requested space by the malloc call and    : 
155b			;        is returned to the caller. The second portion becomes a new free     : 
155b			;        block, and the free list is adjusted to maintain continuity via this : 
155b			;        newly created block.                                                 : 
155b			;                                                                             : 
155b			;     malloc does not set any initial value in the allocated space, the       : 
155b			;     caller is required to do this as required.                              : 
155b			;                                                                             : 
155b			;     This implementation of malloc uses the stack exclusively, and is        : 
155b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
155b			;     advisable to disable interrupts before calling malloc, and recommended  : 
155b			;     to avoid the use of malloc inside ISRs in general.                      : 
155b			;                                                                             : 
155b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
155b			;                                                                             : 
155b			; Parameters                                                                  : 
155b			;     HL  Number of bytes wanted                                              : 
155b			;                                                                             : 
155b			; Returns                                                                     : 
155b			;     HL  Address of the first useable byte of the allocation                 : 
155b			;                                                                             : 
155b			; Flags                                                                       : 
155b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
155b			;                                                                             : 
155b			; Stack frame                                                                 : 
155b			;       |             |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |     BC      |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |     DE      |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |     IX      |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |  prev_free  |                                                       : 
155b			;   +4  +-------------+                                                       : 
155b			;       |  this_free  |                                                       : 
155b			;   +2  +-------------+                                                       : 
155b			;       |  next_free  |                                                       : 
155b			;   +0  +-------------+                                                       : 
155b			;       |             |                                                       : 
155b			;                                                                             : 
155b			;------------------------------------------------------------------------------ 
155b			malloc: 
155b			      push  BC 
155b			      push  DE 
155b			      push  IX 
155b			 
155b			      ld    A, H                    ; Exit if no space requested 
155b			      or    L 
155b			      jp    Z, malloc_early_exit 
155b			 
155b			      ; Set up stack frame 
155b			      ex    DE, HL 
155b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
155b			      add   HL, SP 
155b			      ld    SP, HL 
155b			      ld    IX, 0                   ; Use IX as a frame pointer 
155b			      add   IX, SP 
155b			 
155b			      ; Setup initial state 
155b			      ld    HL, 4                   ; want must also include space used by block struct 
155b			      add   HL, DE 
155b			 
155b			      ld    B, H                    ; Move want to BC 
155b			      ld    C, L 
155b			 
155b			      ld    HL, free_list           ; Store prev_free ptr to stack 
155b			      ld    (IX+4), L 
155b			      ld    (IX+5), H 
155b			 
155b			      ld    E, (HL)                 ; Store this_free ptr to stack 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      ld    (IX+2), E 
155b			      ld    (IX+3), D 
155b			      ex    DE, HL                  ; this_free ptr into HL 
155b			 
155b			      ; Loop through free block list to find some space 
155b			malloc_find_space: 
155b			      ld    E, (HL)                 ; Load next_free ptr into DE 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			 
155b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
155b			      or    E 
155b			      jp    Z, malloc_no_space 
155b			 
155b			      ld    (IX+0), E               ; Store next_free ptr to stack 
155b			      ld    (IX+1), D 
155b			 
155b			      ; Does this block have enough space to make the allocation? 
155b			      inc   HL                      ; Load free block size into DE 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			 
155b			      ex    DE, HL                  ; Check size of block against want 
155b			      or    A                       ; Ensure carry flag clear 
155b			      sbc   HL, BC 
155b			      push  HL                      ; Store the result for later (new block size) 
155b			 
155b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
155b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
155b			 
155b			      ; this_free block is not big enough, setup ptrs to test next free block 
155b			      pop   HL                      ; Discard previous result 
155b			 
155b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
155b			      ld    H, (IX+3) 
155b			      ld    (IX+4), L 
155b			      ld    (IX+5), H 
155b			 
155b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
155b			      ld    H, (IX+1) 
155b			      ld    (IX+2), L 
155b			      ld    (IX+3), H 
155b			 
155b			      jr    malloc_find_space 
155b			 
155b			      ; split a bigger block into two - requested size and remaining size 
155b			malloc_alloc_split: 
155b			      ex    DE, HL                  ; Calculate address of new free block 
155b			      dec   HL 
155b			      dec   HL 
155b			      dec   HL 
155b			      add   HL, BC 
155b			 
155b			      ; Create a new block and point it at next_free 
155b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
155b			      ld    D, (IX+1) 
155b			 
155b			      ld    (HL), E                 ; Store next_free ptr into new block 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			      pop   DE                      ; Store size of new block into new block 
155b			      inc   HL 
155b			      ld    (HL), E 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			      ; Update this_free ptr to point to new block 
155b			      dec   HL 
155b			      dec   HL 
155b			      dec   HL 
155b			 
155b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
155b			      ld    D, (IX+3) 
155b			 
155b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
155b			      ld    (IX+3), H 
155b			 
155b			      ; Modify this_free block to be allocation 
155b			      ex    DE, HL 
155b			      xor   A                       ; Null the next block ptr of allocated block 
155b			      ld    (HL), A 
155b			      inc   HL 
155b			      ld    (HL), A 
155b			 
155b			      inc   HL                      ; Store want size into allocated block 
155b			      ld    (HL), C 
155b			      inc   HL 
155b			      ld    (HL), B 
155b			      inc   HL 
155b			      push  HL                      ; Address of allocation to return 
155b			 
155b			      jr    malloc_update_links 
155b			 
155b			malloc_alloc_fit: 
155b			      pop   HL                      ; Dont need new block size, want is exact fit 
155b			 
155b			      ; Modify this_free block to be allocation 
155b			      ex    DE, HL 
155b			      dec   HL 
155b			      dec   HL 
155b			      dec   HL 
155b			 
155b			      xor   A                       ; Null the next block ptr of allocated block 
155b			      ld    (HL), A 
155b			      inc   HL 
155b			      ld    (HL), A 
155b			 
155b			      inc   HL                      ; Store address of allocation to return 
155b			      inc   HL 
155b			      inc   HL 
155b			      push  HL 
155b			 
155b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
155b			      ld    L, (IX+0)               ; next_free to HL 
155b			      ld    H, (IX+1) 
155b			 
155b			      ld    (IX+2), L               ; HL to this_free 
155b			      ld    (IX+3), H 
155b			 
155b			 
155b			malloc_update_links: 
155b			      ; Update prev_free ptr to point to this_free 
155b			      ld    L, (IX+4)               ; prev_free ptr to HL 
155b			      ld    H, (IX+5) 
155b			 
155b			      ld    E, (IX+2)               ; this_free ptr to DE 
155b			      ld    D, (IX+3) 
155b			 
155b			      ld    (HL), E                 ; this_free ptr into prev_free 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			      ; Clear the Z flag to indicate successful allocation 
155b			      ld    A, D 
155b			      or    E 
155b			 
155b			      pop   DE                      ; Address of allocation 
155b			 
155b			malloc_no_space: 
155b			      ld    HL, 6                   ; Clean up stack frame 
155b			      add   HL, SP 
155b			      ld    SP, HL 
155b			 
155b			      ex    DE, HL                  ; Alloc addr into HL for return 
155b			 
155b			malloc_early_exit: 
155b			      pop   IX 
155b			      pop   DE 
155b			      pop   BC 
155b			 
155b			      ret 
155b			 
155b			 
155b			;------------------------------------------------------------------------------ 
155b			;     free                                                                    : 
155b			;                                                                             : 
155b			; Description                                                                 : 
155b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
155b			;     returned by malloc, otherwise the behaviour is undefined.               : 
155b			;                                                                             : 
155b			;     Where possible, directly adjacent free blocks will be merged together   : 
155b			;     into larger blocks to help ensure that the heap does not become         : 
155b			;     excessively fragmented.                                                 : 
155b			;                                                                             : 
155b			;     free does not clear or set any other value into the freed space, and    : 
155b			;     therefore its contents may be visible through subsequent malloc's. The  : 
155b			;     caller should clear the freed space as required.                        : 
155b			;                                                                             : 
155b			;     This implementation of free uses the stack exclusively, and is          : 
155b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
155b			;     advisable to disable interrupts before calling free, and recommended    : 
155b			;     to avoid the use of free inside ISRs in general.                        : 
155b			;                                                                             : 
155b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
155b			;                                                                             : 
155b			; Parameters                                                                  : 
155b			;     HL  Pointer to address of first byte of allocation to be freed          : 
155b			;                                                                             : 
155b			; Returns                                                                     : 
155b			;     Nothing                                                                 : 
155b			;                                                                             : 
155b			; Stack frame                                                                 : 
155b			;       |             |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |     BC      |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |     DE      |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |     IX      |                                                       : 
155b			;       +-------------+                                                       : 
155b			;       |  prev_free  |                                                       : 
155b			;   +2  +-------------+                                                       : 
155b			;       |  next_free  |                                                       : 
155b			;   +0  +-------------+                                                       : 
155b			;       |             |                                                       : 
155b			;                                                                             : 
155b			;------------------------------------------------------------------------------ 
155b			free: 
155b			      push  BC 
155b			      push  DE 
155b			      push  IX 
155b			 
155b			      ld    A, H                    ; Exit if ptr is null 
155b			      or    L 
155b			      jp    Z, free_early_exit 
155b			 
155b			      ; Set up stack frame 
155b			      ex    DE, HL 
155b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
155b			      add   HL, SP 
155b			      ld    SP, HL 
155b			      ld    IX, 0                   ; Use IX as a frame pointer 
155b			      add   IX, SP 
155b			 
155b			      ; The address in HL points to the start of the useable allocated space, 
155b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
155b			      ; address of the block itself. 
155b			      ex    DE, HL 
155b			      ld    DE, -4 
155b			      add   HL, DE 
155b			 
155b			      ; An allocated block must have a null next block pointer in it 
155b			      ld    A, (HL) 
155b			      inc   HL 
155b			      or    (HL) 
155b			      jp    NZ, free_done 
155b			 
155b			      dec   HL 
155b			 
155b			      ld    B, H                    ; Copy HL to BC 
155b			      ld    C, L 
155b			 
155b			      ; Loop through the free list to find the first block with an address 
155b			      ; higher than the block being freed 
155b			      ld    HL, free_list 
155b			 
155b			free_find_higher_block: 
155b			      ld    E, (HL)                 ; Load next ptr from free block 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      dec   HL 
155b			 
155b			      ld    (IX+0), E               ; Save ptr to next free block 
155b			      ld    (IX+1), D 
155b			      ld    (IX+2), L               ; Save ptr to prev free block 
155b			      ld    (IX+3), H 
155b			 
155b			      ld    A, B                    ; Check if DE is greater than BC 
155b			      cp    D                       ; Compare MSB first 
155b			      jr    Z, $+4                  ; MSB the same, compare LSB 
155b			      jr    NC, free_find_higher_block_skip 
155b			      ld    A, C 
155b			      cp    E                       ; Then compare LSB 
155b			      jr    C, free_found_higher_block 
155b			 
155b			free_find_higher_block_skip: 
155b			      ld    A, D                    ; Reached the end of the free list? 
155b			      or    E 
155b			      jp    Z, free_done 
155b			 
155b			      ex    DE, HL 
155b			 
155b			      jr    free_find_higher_block 
155b			 
155b			free_found_higher_block: 
155b			      ; Insert freed block between prev and next free blocks 
155b			      ld    (HL), C                 ; Point prev free block to freed block 
155b			      inc   HL 
155b			      ld    (HL), B 
155b			 
155b			      ld    H, B                    ; Point freed block at next free block 
155b			      ld    L, C 
155b			      ld    (HL), E 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			      ; Check if the freed block is adjacent to the next free block 
155b			      inc   HL                      ; Load size of freed block into HL 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      ex    DE, HL 
155b			 
155b			      add   HL, BC                  ; Add addr of freed block and its size 
155b			 
155b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
155b			      ld    D, (IX+1) 
155b			 
155b			      or    A                       ; Clear the carry flag 
155b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
155b			      jr    NZ, free_check_adjacent_to_prev 
155b			 
155b			      ; Freed block is adjacent to next, merge into one bigger block 
155b			      ex    DE, HL                  ; Load next ptr from next block into DE 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      push  HL                      ; Save ptr to next block for later 
155b			 
155b			      ld    H, B                    ; Store ptr from next block into freed block 
155b			      ld    L, C 
155b			      ld    (HL), E 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			      pop   HL                      ; Restore ptr to next block 
155b			      inc   HL                      ; Load size of next block into DE 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      push  DE                      ; Save next block size for later 
155b			 
155b			      ld    H, B                    ; Load size of freed block into HL 
155b			      ld    L, C 
155b			      inc   HL 
155b			      inc   HL 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      ex    DE, HL 
155b			 
155b			      pop   DE                      ; Restore size of next block 
155b			      add   HL, DE                  ; Add sizes of both blocks 
155b			      ex    DE, HL 
155b			 
155b			      ld    H, B                    ; Store new bigger size into freed block 
155b			      ld    L, C 
155b			      inc   HL 
155b			      inc   HL 
155b			      ld    (HL), E 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			free_check_adjacent_to_prev: 
155b			      ; Check if the freed block is adjacent to the prev free block 
155b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
155b			      ld    H, (IX+3) 
155b			 
155b			      inc   HL                      ; Size of prev free block into DE 
155b			      inc   HL 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      dec   HL 
155b			      dec   HL 
155b			      dec   HL 
155b			 
155b			      add   HL, DE                  ; Add prev block addr and size 
155b			 
155b			      or    A                       ; Clear the carry flag 
155b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
155b			      jr    NZ, free_done 
155b			 
155b			      ; Freed block is adjacent to prev, merge into one bigger block 
155b			      ld    H, B                    ; Load next ptr from freed block into DE 
155b			      ld    L, C 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      push  HL                      ; Save freed block ptr for later 
155b			 
155b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
155b			      ld    H, (IX+3) 
155b			      ld    (HL), E 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			      pop   HL                      ; Restore freed block ptr 
155b			      inc   HL                      ; Load size of freed block into DE 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			      push  DE                      ; Save freed block size for later 
155b			 
155b			      ld    L, (IX+2)               ; Load size of prev block into DE 
155b			      ld    H, (IX+3) 
155b			      inc   HL 
155b			      inc   HL 
155b			      ld    E, (HL) 
155b			      inc   HL 
155b			      ld    D, (HL) 
155b			 
155b			      pop   HL                      ; Add sizes of both blocks 
155b			      add   HL, DE 
155b			      ex    DE, HL 
155b			 
155b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
155b			      ld    H, (IX+3) 
155b			      inc   HL 
155b			      inc   HL 
155b			      ld    (HL), E 
155b			      inc   HL 
155b			      ld    (HL), D 
155b			 
155b			free_done: 
155b			      ld    HL, 4                   ; Clean up stack frame 
155b			      add   HL, SP 
155b			      ld    SP, HL 
155b			 
155b			free_early_exit: 
155b			      pop   IX 
155b			      pop   DE 
155b			      pop   BC 
155b			 
155b			      ret 
155b			 
155b			 
155b			;      .org 0x8000 
155b			; 
155b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
155b			 ;                 .dw   0 
155b			 
155b			endif 
155b			 
155b			 
155b			if MALLOC_4 
155b			 
155b			; My memory allocation code. Very very simple.... 
155b			; allocate space under 250 chars 
155b			 
155b			heap_init: 
155b				; init start of heap as zero 
155b				;  
155b			 
155b				ld hl, heap_start 
155b				ld a, 0 
155b				ld (hl), a      ; empty block 
155b				inc hl 
155b				ld a, 0 
155b				ld (hl), a      ; length of block 
155b				; write end of list 
155b				inc hl 
155b				ld a,(hl) 
155b				inc hl 
155b				ld a,(hl) 
155b				 
155b			 
155b				; init some malloc vars 
155b			 
155b				ld hl, 0 
155b				ld (free_list), hl       ; store last malloc location 
155b			 
155b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
155b				ld a, 0 
155b				ld (hl), a 
155b			 
155b			 
155b				ld hl, heap_start 
155b				;  
155b				  
155b				ret 
155b			 
155b			 
155b			;    free block marker 
155b			;    requested size  
155b			;    pointer to next block 
155b			;    .... 
155b			;    next block marker 
155b			 
155b			 
155b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
155b			; 
155b			 
155b			 
155b			malloc:  
155b				push de 
155b				push bc 
155b				push af 
155b			 
155b				; hl space required 
155b				 
155b				ld c, l    ; hold space   (TODO only a max of 255) 
155b			 
155b			;	inc c     ; TODO BUG need to fix memory leak on push str 
155b			;	inc c 
155b			;	inc c 
155b			;	inc c 
155b			;	inc c 
155b			;	inc c 
155b			;	inc c 
155b			 
155b			 
155b			 
155b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
155b			 
155b				ld a, (free_list+3) 
155b				cp 0 
155b				jr z, .contheap 
155b			 
155b				ld hl, (free_list)     ; get last alloc 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "mrs" 
155b						CALLMONITOR 
155b					endif 
155b				jr .startalloc 
155b			 
155b			.contheap: 
155b				ld hl, heap_start 
155b			 
155b			.startalloc: 
155b			 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "mym" 
155b						CALLMONITOR 
155b					endif 
155b			.findblock: 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "mmf" 
155b						CALLMONITOR 
155b					endif 
155b			 
155b				ld a,(hl)  
155b				; if byte is zero then clear to use 
155b			 
155b				cp 0 
155b				jr z, .foundemptyblock 
155b			 
155b				; if byte is not clear 
155b				;     then byte is offset to next block 
155b			 
155b				inc hl 
155b				ld a, (hl) ; get size 
155b			.nextblock:	inc hl 
155b					ld e, (hl) 
155b					inc hl 
155b					ld d, (hl) 
155b					ex de, hl 
155b			;	inc hl  ; move past the store space 
155b			;	inc hl  ; move past zero index  
155b			 
155b				; TODO detect no more space 
155b			 
155b				push hl 
155b				ld de, heap_end 
155b				call cmp16 
155b				pop hl 
155b				jr nc, .nospace 
155b			 
155b				jr .findblock 
155b			 
155b			.nospace: ld hl, 0 
155b				jp .exit 
155b			 
155b			 
155b			.foundemptyblock:	 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "mme" 
155b						CALLMONITOR 
155b					endif 
155b			 
155b			; TODO has block enough space if reusing??? 
155b			 
155b				;  
155b			 
155b			; see if this block has been previously used 
155b				inc hl 
155b				ld a, (hl) 
155b				dec hl 
155b				cp 0 
155b				jr z, .newblock 
155b			 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "meR" 
155b						CALLMONITOR 
155b					endif 
155b			 
155b			; no reusing previously allocated block 
155b			 
155b			; is it smaller than previously used? 
155b				 
155b				inc hl    ; move to size 
155b				ld a, c 
155b				sub (hl)        ; we want c < (hl) 
155b				dec hl    ; move back to marker 
155b			        jr z, .findblock 
155b			 
155b				; update with the new size which should be lower 
155b			 
155b			        ;inc  hl   ; negate next move. move back to size  
155b			 
155b			.newblock: 
155b				; need to be at marker here 
155b			 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "meN" 
155b						CALLMONITOR 
155b					endif 
155b			 
155b			 
155b				ld a, c 
155b			 
155b				ld (free_list+3), a	 ; flag resume from last malloc  
155b				ld (free_list), hl    ; save out last location 
155b			 
155b			 
155b				;inc a     ; space for length byte 
155b				ld (hl), a     ; save block in use marker 
155b			 
155b				inc hl   ; move to space marker 
155b				ld (hl), a    ; save new space 
155b			 
155b				inc hl   ; move to start of allocated area 
155b				 
155b			;	push hl     ; save where we are - 1  
155b			 
155b			;	inc hl  ; move past zero index  
155b				; skip space to set down new marker 
155b			 
155b				; provide some extra space for now 
155b			 
155b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
155b				inc a 
155b				inc a 
155b			 
155b				push hl   ; save where we are in the node block 
155b			 
155b				call addatohl 
155b			 
155b				; write linked list point 
155b			 
155b				pop de     ; get our node position 
155b				ex de, hl 
155b			 
155b				ld (hl), e 
155b				inc hl 
155b				ld (hl), d 
155b			 
155b				inc hl 
155b			 
155b				; now at start of allocated data so save pointer 
155b			 
155b				push hl 
155b			 
155b				; jump to position of next node and setup empty header in DE 
155b			 
155b				ex de, hl 
155b			 
155b			;	inc hl ; move past end of block 
155b			 
155b				ld a, 0 
155b				ld (hl), a   ; empty marker 
155b				inc hl 
155b				ld (hl), a   ; size 
155b				inc hl  
155b				ld (hl), a   ; ptr 
155b				inc hl 
155b				ld (hl), a   ; ptr 
155b			 
155b			 
155b				pop hl 
155b			 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "mmr" 
155b						CALLMONITOR 
155b					endif 
155b			 
155b			.exit: 
155b				pop af 
155b				pop bc 
155b				pop de  
155b				ret 
155b			 
155b			 
155b			 
155b			 
155b			free:  
155b				push hl 
155b				push af 
155b				; get address in hl 
155b			 
155b					if DEBUG_FORTH_MALLOC_INT 
155b						DMARK "fre" 
155b						CALLMONITOR 
155b					endif 
155b				; data is at hl - move to block count 
155b				dec hl 
155b				dec hl    ; get past pointer 
155b				dec hl 
155b			 
155b				ld a, (hl)    ; need this for a validation check 
155b			 
155b				dec hl    ; move to block marker 
155b			 
155b				; now check that the block count and block marker are the same  
155b			        ; this checks that we are on a malloc node and not random memory 
155b			        ; OK a faint chance this could be a problem but rare - famous last words! 
155b			 
155b				ld c, a 
155b				ld a, (hl)    
155b			 
155b				cp c 
155b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
155b			 
155b				; yes good chance we are on a malloc node 
155b			 
155b				ld a, 0      
155b				ld (hl), a   ; mark as free 
155b			 
155b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
155b			 
155b			.freeignore:  
155b			 
155b				pop af 
155b				pop hl 
155b			 
155b				ret 
155b			 
155b			 
155b			 
155b			endif 
155b			 
155b			; eof 
# End of file firmware_memory.asm
155b			  
155b			; device C  
155b			if SOUND_ENABLE  
155b				include "firmware_sound.asm"  
155b			endif  
155b			  
155b			include "firmware_diags.asm"  
155b			; Hardware diags menu 
155b			 
155b			 
155b			config: 
155b			 
155b 3e 00			ld a, 0 
155d 21 8b 15			ld hl, .configmn 
1560 cd f8 0c			call menu 
1563			 
1563 fe 00			cp 0 
1565 c8				ret z 
1566			 
1566 fe 01			cp 1 
1568 cc 64 16			call z, .savetostore 
156b			 
156b fe 02			cp 2 
156d cc b2 15			call z, .selautoload 
1570 fe 03			cp 3 
1572 cc 9b 15			call z, .disautoload 
1575 fe 04			cp 4 
1577 cc 62 16			call z, .selbank 
157a fe 05			cp 5 
157c cc 3f 17			call z, .debug_tog 
157f fe 06			cp 6 
1581 cc 82 18			call z, .bpsgo 
1584 fe 07			cp 7 
1586 cc 65 17			call z, hardware_diags 
1589			 
1589 18 d0			jr config 
158b			 
158b			.configmn: 
158b 73 1a			dw prom_c3 
158d 8a 1a			dw prom_c2 
158f 9f 1a			dw prom_c2a 
1591 b5 1a			dw prom_c2b 
1593			;	dw prom_c4 
1593 d2 1a			dw prom_m4 
1595 ed 1a			dw prom_m4b 
1597 f5 1a			dw prom_c1 
1599 00 00			dw 0 
159b				 
159b			 
159b			 
159b			 
159b			.disautoload: 
159b				if STORAGE_SE 
159b 3e fe			ld a, $fe      ; bit 0 clear 
159d 32 f0 fb			ld (spi_device), a 
15a0			 
15a0 cd 82 04			call storage_get_block_0 
15a3			 
15a3 3e 00			ld a, 0 
15a5 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
15a8			 
15a8 21 00 00				ld hl, 0 
15ab 11 07 fc				ld de, store_page 
15ae cd 36 04			call storage_write_block	 ; save update 
15b1				else 
15b1			 
15b1				ld hl, prom_notav 
15b1				ld de, prom_empty 
15b1				call info_panel 
15b1				endif 
15b1			 
15b1			 
15b1 c9				ret 
15b2			 
15b2			 
15b2			 
15b2			; Select auto start 
15b2			 
15b2			.selautoload: 
15b2			 
15b2				 
15b2				if STORAGE_SE 
15b2			 
15b2 cd 89 16				call config_dir 
15b5 21 85 f3			        ld hl, scratch 
15b8 3e 00				ld a, 0 
15ba cd f8 0c				call menu 
15bd			 
15bd fe 00				cp 0 
15bf c8					ret z 
15c0			 
15c0 3d					dec a 
15c1			 
15c1			 
15c1					; locate menu option 
15c1			 
15c1 21 85 f3				ld hl, scratch 
15c4 cd 1c 0c				call table_lookup 
15c7			 
15c7					if DEBUG_FORTH_WORDS 
15c7						DMARK "ALl" 
15c7 f5				push af  
15c8 3a dc 15			ld a, (.dmark)  
15cb 32 b4 fe			ld (debug_mark),a  
15ce 3a dd 15			ld a, (.dmark+1)  
15d1 32 b5 fe			ld (debug_mark+1),a  
15d4 3a de 15			ld a, (.dmark+2)  
15d7 32 b6 fe			ld (debug_mark+2),a  
15da 18 03			jr .pastdmark  
15dc ..			.dmark: db "ALl"  
15df f1			.pastdmark: pop af  
15e0			endm  
# End of macro DMARK
15e0						CALLMONITOR 
15e0 cd 78 18			call break_point_state  
15e3				endm  
# End of macro CALLMONITOR
15e3					endif 
15e3					; with the pointer to the menu it, the byte following the zero term is the file id 
15e3			 
15e3 3e 00				ld a, 0 
15e5 01 32 00				ld bc, 50   ; max of bytes to look at 
15e8 ed b1				cpir  
15ea			 
15ea					if DEBUG_FORTH_WORDS 
15ea						DMARK "ALb" 
15ea f5				push af  
15eb 3a ff 15			ld a, (.dmark)  
15ee 32 b4 fe			ld (debug_mark),a  
15f1 3a 00 16			ld a, (.dmark+1)  
15f4 32 b5 fe			ld (debug_mark+1),a  
15f7 3a 01 16			ld a, (.dmark+2)  
15fa 32 b6 fe			ld (debug_mark+2),a  
15fd 18 03			jr .pastdmark  
15ff ..			.dmark: db "ALb"  
1602 f1			.pastdmark: pop af  
1603			endm  
# End of macro DMARK
1603						CALLMONITOR 
1603 cd 78 18			call break_point_state  
1606				endm  
# End of macro CALLMONITOR
1606					endif 
1606					;inc hl 
1606			 
1606 7e					ld a, (hl)   ; file id 
1607					 
1607				        ; save bank and file ids 
1607			 
1607 f5					push af 
1608			 
1608			; TODO need to save to block 0 on bank 1	 
1608			 
1608 cd 82 04				call storage_get_block_0 
160b			 
160b					if DEBUG_FORTH_WORDS 
160b						DMARK "AL0" 
160b f5				push af  
160c 3a 20 16			ld a, (.dmark)  
160f 32 b4 fe			ld (debug_mark),a  
1612 3a 21 16			ld a, (.dmark+1)  
1615 32 b5 fe			ld (debug_mark+1),a  
1618 3a 22 16			ld a, (.dmark+2)  
161b 32 b6 fe			ld (debug_mark+2),a  
161e 18 03			jr .pastdmark  
1620 ..			.dmark: db "AL0"  
1623 f1			.pastdmark: pop af  
1624			endm  
# End of macro DMARK
1624						CALLMONITOR 
1624 cd 78 18			call break_point_state  
1627				endm  
# End of macro CALLMONITOR
1627					endif 
1627 f1					pop af 
1628			 
1628 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
162b					 
162b					; save bank id 
162b			 
162b 3a f0 fb				ld a,(spi_device) 
162e 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
1631			 
1631					; enable auto run of store file 
1631			 
1631 3e 01				ld a, 1 
1633 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
1636			 
1636					; save buffer 
1636			 
1636 21 00 00				ld hl, 0 
1639 11 07 fc				ld de, store_page 
163c					if DEBUG_FORTH_WORDS 
163c						DMARK "ALw" 
163c f5				push af  
163d 3a 51 16			ld a, (.dmark)  
1640 32 b4 fe			ld (debug_mark),a  
1643 3a 52 16			ld a, (.dmark+1)  
1646 32 b5 fe			ld (debug_mark+1),a  
1649 3a 53 16			ld a, (.dmark+2)  
164c 32 b6 fe			ld (debug_mark+2),a  
164f 18 03			jr .pastdmark  
1651 ..			.dmark: db "ALw"  
1654 f1			.pastdmark: pop af  
1655			endm  
# End of macro DMARK
1655						CALLMONITOR 
1655 cd 78 18			call break_point_state  
1658				endm  
# End of macro CALLMONITOR
1658					endif 
1658 cd 36 04			call storage_write_block	 ; save update 
165b			  
165b			 
165b			 
165b			 
165b 21 85 f3				ld hl, scratch 
165e cd 76 16				call config_fdir 
1661			 
1661				else 
1661			 
1661				ld hl, prom_notav 
1661				ld de, prom_empty 
1661				call info_panel 
1661			 
1661				endif 
1661 c9				ret 
1662			 
1662			 
1662			 
1662			; Select storage bank 
1662			 
1662			.selbank: 
1662			 
1662				if STORAGE_SE 
1662				else 
1662			 
1662				ld hl, prom_notav 
1662				ld de, prom_empty 
1662				call info_panel 
1662				endif 
1662				 
1662 c9				ret 
1663			 
1663			if STORAGE_SE 
1663			 
1663			.config_ldir:   
1663				; Load storage bank labels into menu array 
1663			 
1663				 
1663			 
1663			 
1663 c9				ret 
1664			 
1664			 
1664			endif 
1664			 
1664			 
1664			; Save user words to storage 
1664			 
1664			.savetostore: 
1664			 
1664				if STORAGE_SE 
1664			 
1664 cd 89 16				call config_dir 
1667 21 85 f3			        ld hl, scratch 
166a 3e 00				ld a, 0 
166c cd f8 0c				call menu 
166f					 
166f 21 85 f3				ld hl, scratch 
1672 cd 76 16				call config_fdir 
1675			 
1675				else 
1675			 
1675				ld hl, prom_notav 
1675				ld de, prom_empty 
1675				call info_panel 
1675			 
1675				endif 
1675			 
1675 c9				ret 
1676			 
1676			 
1676			 
1676			if STORAGE_SE 
1676			 
1676			config_fdir: 
1676				; using the scratch dir go through and release the memory allocated for each string 
1676				 
1676 21 85 f3			ld hl, scratch 
1679 5e			.cfdir:	ld e,(hl) 
167a 23				inc hl 
167b 56				ld d,(hl) 
167c 23				inc hl 
167d			 
167d eb				ex de, hl 
167e cd 24 0f			call ishlzero 
1681 c8				ret z     ; return on null pointer 
1682 cd 8c 14			call free 
1685 eb				ex de, hl 
1686 18 f1			jr .cfdir 
1688			 
1688			 
1688 c9				ret 
1689			 
1689			 
1689			config_dir: 
1689			 
1689				; for the config menus that need to build a directory of storage call this routine 
1689				; it will construct a menu in scratch to pass to menu 
1689			 
1689				; open storage device 
1689			 
1689				; execute DIR to build a list of files and their ids into scratch in menu format 
1689				; once the menu has finished then will need to call config_fdir to release the strings 
1689				 
1689				; c = number items 
1689			 
1689				 
1689 cd 82 04			call storage_get_block_0 
168c			 
168c 21 07 fc			ld hl, store_page     ; get current id count 
168f 46				ld b, (hl) 
1690 0e 00			ld c, 0    ; count of files   
1692			 
1692			 
1692 21 85 f3			ld hl, scratch 
1695 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
1698			 
1698				; check for empty drive 
1698			 
1698 3e 00			ld a, 0 
169a b8				cp b 
169b ca 35 17			jp z, .dirdone 
169e			 
169e				 
169e					if DEBUG_FORTH_WORDS 
169e						DMARK "Cdc" 
169e f5				push af  
169f 3a b3 16			ld a, (.dmark)  
16a2 32 b4 fe			ld (debug_mark),a  
16a5 3a b4 16			ld a, (.dmark+1)  
16a8 32 b5 fe			ld (debug_mark+1),a  
16ab 3a b5 16			ld a, (.dmark+2)  
16ae 32 b6 fe			ld (debug_mark+2),a  
16b1 18 03			jr .pastdmark  
16b3 ..			.dmark: db "Cdc"  
16b6 f1			.pastdmark: pop af  
16b7			endm  
# End of macro DMARK
16b7						CALLMONITOR 
16b7 cd 78 18			call break_point_state  
16ba				endm  
# End of macro CALLMONITOR
16ba					endif 
16ba			 
16ba			 
16ba			.diritem:	 
16ba c5				push bc 
16bb				; for each of the current ids do a search for them and if found push to stack 
16bb			 
16bb 21 40 00				ld hl, STORE_BLOCK_PHY 
16be 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
16c0 58					ld e,b 
16c1			 
16c1 cd 04 07				call storage_findnextid 
16c4			 
16c4			 
16c4					; if found hl will be non zero 
16c4			 
16c4 cd 24 0f				call ishlzero 
16c7 28 69				jr z, .dirnotfound 
16c9			 
16c9					; increase count 
16c9			 
16c9 c1					pop bc	 
16ca 0c					inc c 
16cb c5					push bc 
16cc					 
16cc			 
16cc					; get file header and push the file name 
16cc			 
16cc 11 07 fc				ld de, store_page 
16cf cd d1 03				call storage_read_block 
16d2			 
16d2					; push file id to stack 
16d2				 
16d2 3a 07 fc				ld a, (store_page) 
16d5 26 00				ld h, 0 
16d7 6f					ld l, a 
16d8			 
16d8					;call forth_push_numhl 
16d8					; TODO store id 
16d8			 
16d8 e5					push hl 
16d9			 
16d9					; push extent count to stack  
16d9				 
16d9 21 0a fc				ld hl, store_page+3 
16dc			 
16dc					; get file name length 
16dc			 
16dc cd 59 13				call strlenz   
16df			 
16df 23					inc hl   ; cover zero term 
16e0 23					inc hl  ; stick the id at the end of the area 
16e1			 
16e1 e5					push hl 
16e2 c1					pop bc    ; move length to bc 
16e3			 
16e3 cd c2 13				call malloc 
16e6			 
16e6					; TODO save malloc area to scratch 
16e6			 
16e6 eb					ex de, hl 
16e7 2a fe fb				ld hl, (store_tmp2) 
16ea 73					ld (hl), e 
16eb 23					inc hl 
16ec 72					ld (hl), d 
16ed 23					inc hl 
16ee 22 fe fb				ld (store_tmp2), hl 
16f1			 
16f1					 
16f1			 
16f1					;pop hl   ; get source 
16f1			;		ex de, hl    ; swap aronund	 
16f1			 
16f1 21 0a fc				ld hl, store_page+3 
16f4					if DEBUG_FORTH_WORDS 
16f4						DMARK "CFd" 
16f4 f5				push af  
16f5 3a 09 17			ld a, (.dmark)  
16f8 32 b4 fe			ld (debug_mark),a  
16fb 3a 0a 17			ld a, (.dmark+1)  
16fe 32 b5 fe			ld (debug_mark+1),a  
1701 3a 0b 17			ld a, (.dmark+2)  
1704 32 b6 fe			ld (debug_mark+2),a  
1707 18 03			jr .pastdmark  
1709 ..			.dmark: db "CFd"  
170c f1			.pastdmark: pop af  
170d			endm  
# End of macro DMARK
170d						CALLMONITOR 
170d cd 78 18			call break_point_state  
1710				endm  
# End of macro CALLMONITOR
1710					endif 
1710 ed b0				ldir 
1712			 
1712					; de is past string, move back one and store id 
1712					 
1712 1b					dec de 
1713			 
1713					; store file id 
1713			 
1713 e1					pop hl 
1714 eb					ex de,hl 
1715 73					ld (hl), e 
1716			 
1716					if DEBUG_FORTH_WORDS 
1716						DMARK "Cdi" 
1716 f5				push af  
1717 3a 2b 17			ld a, (.dmark)  
171a 32 b4 fe			ld (debug_mark),a  
171d 3a 2c 17			ld a, (.dmark+1)  
1720 32 b5 fe			ld (debug_mark+1),a  
1723 3a 2d 17			ld a, (.dmark+2)  
1726 32 b6 fe			ld (debug_mark+2),a  
1729 18 03			jr .pastdmark  
172b ..			.dmark: db "Cdi"  
172e f1			.pastdmark: pop af  
172f			endm  
# End of macro DMARK
172f						CALLMONITOR 
172f cd 78 18			call break_point_state  
1732				endm  
# End of macro CALLMONITOR
1732					endif 
1732					 
1732			.dirnotfound: 
1732 c1					pop bc     
1733 10 85				djnz .diritem 
1735				 
1735			.dirdone:	 
1735			 
1735 3e 00				ld a, 0 
1737 2a fe fb				ld hl, (store_tmp2) 
173a 77					ld (hl), a 
173b 23					inc hl 
173c 77					ld (hl), a 
173d 23					inc hl 
173e					; push a count of the dir items found 
173e			 
173e			;		ld h, 0 
173e			;		ld l, c 
173e			 
173e c9				ret 
173f			 
173f			endif 
173f			 
173f			 
173f			; Settings 
173f			; Run  
173f			 
173f			 
173f			 
173f			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
173f			;;hd_menu2:   db "        2: Editor",0   
173f			;hd_menu2:   db "        2: Editor       6: Menu",0   
173f			;hd_menu3:   db "        3: Storage",0 
173f			;hd_menu4:   db "0=quit  4: Debug",0 
173f			;hd_don:     db "ON",0 
173f			;hd_doff:     db "OFF",0 
173f			; 
173f			; 
173f			; 
173f			;hardware_diags_old:       
173f			; 
173f			;.diagmenu: 
173f			;	call clear_display 
173f			;	ld a, display_row_1 
173f			;	ld de, hd_menu1 
173f			;	call str_at_display 
173f			; 
173f			;	ld a, display_row_2 
173f			;	ld de, hd_menu2 
173f			;	call str_at_display 
173f			; 
173f			;	ld a, display_row_3 
173f			;	ld de, hd_menu3 
173f			;	call str_at_display 
173f			; 
173f			;	ld a,  display_row_4 
173f			;	ld de, hd_menu4 
173f			;	call str_at_display 
173f			; 
173f			;	; display debug state 
173f			; 
173f			;	ld de, hd_don 
173f			;	ld a, (os_view_disable) 
173f			;	cp 0 
173f			;	jr z, .distog 
173f			;	ld de, hd_doff 
173f			;.distog: ld a, display_row_4+17 
173f			;	call str_at_display 
173f			; 
173f			;	call update_display 
173f			; 
173f			;	call cin_wait 
173f			; 
173f			; 
173f			; 
173f			;	cp '4' 
173f			;	jr nz, .diagn1 
173f			; 
173f			;	; debug toggle 
173f			; 
173f			;	ld a, (os_view_disable) 
173f			;	ld b, '*' 
173f			;	cp 0 
173f			;	jr z, .debtog 
173f			;	ld b, 0 
173f			;.debtog:	 
173f			;	ld a,b 
173f			;	ld (os_view_disable),a 
173f			; 
173f			;.diagn1: cp '0' 
173f			;	 ret z 
173f			; 
173f			;;	cp '1' 
173f			;;       jp z, matrix	 
173f			;;   TODO keyboard matrix test 
173f			; 
173f			;	cp '2' 
173f			;	jp z, .diagedit 
173f			; 
173f			;;	cp '6' 
173f			;;	jp z, .menutest 
173f			;;if ENABLE_BASIC 
173f			;;	cp '6' 
173f			;;	jp z, basic 
173f			;;endif 
173f			 ; 
173f			;	jp .diagmenu 
173f			; 
173f			; 
173f			;	ret 
173f			 
173f			 
173f			.debug_tog: 
173f 21 86 17			ld hl, .menudebug 
1742				 
1742 3a 76 f3			ld a, (os_view_disable) 
1745 fe 2a			cp '*' 
1747 20 04			jr nz,.tdon  
1749 3e 01			ld a, 1 
174b 18 02			jr .tog1 
174d 3e 00		.tdon: ld a, 0 
174f			 
174f			.tog1: 
174f cd f8 0c			call menu 
1752 fe 00			cp 0 
1754 c8				ret z 
1755 fe 01			cp 1    ; disable debug 
1757 28 04			jr z, .dtog0 
1759 3e 2a			ld a, '*' 
175b 18 02			jr .dtogset 
175d 3e 00		.dtog0: ld a, 0 
175f 32 76 f3		.dtogset:  ld (os_view_disable), a 
1762 c3 3f 17			jp .debug_tog 
1765			 
1765			 
1765			hardware_diags:       
1765			 
1765			.diagm: 
1765 21 78 17			ld hl, .menuitems 
1768 3e 00			ld a, 0 
176a cd f8 0c			call menu 
176d			 
176d fe 00		         cp 0 
176f c8				 ret z 
1770			 
1770 fe 02			cp 2 
1772 ca d1 17			jp z, .diagedit 
1775			 
1775			;	cp '6' 
1775			;	jp z, .menutest 
1775			;if ENABLE_BASIC 
1775			;	cp '6' 
1775			;	jp z, basic 
1775			;endif 
1775			  
1775 c3 65 17			jp .diagm 
1778			 
1778				 
1778 8c 17		.menuitems:   	dw .m1 
177a 97 17				dw .m2 
177c 9e 17				dw .m3 
177e a6 17				dw .m5 
1780 ac 17				dw .m5a 
1782 b5 17				dw .m5b 
1784 00 00				dw 0 
1786			 
1786			.menudebug: 
1786 be 17				dw .m6 
1788 c7 17				dw .m7 
178a 00 00				dw 0 
178c			 
178c .. 00		.m1:   db "Key Matrix",0 
1797 .. 00		.m2:   db "Editor",0 
179e .. 00		.m3:   db "Storage",0 
17a6 .. 00		.m5:   db "Sound",0 
17ac .. 00		.m5a:  db "RAM Test",0 
17b5 .. 00		.m5b:  db "LCD Test",0 
17be			 
17be .. 00		.m6:   db "Debug ON",0 
17c7 .. 00		.m7:   db "Debug OFF",0 
17d1			 
17d1			; debug editor 
17d1			 
17d1			.diagedit: 
17d1			 
17d1 21 85 f3			ld hl, scratch 
17d4			;	ld bc, 250 
17d4			;	ldir 
17d4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
17d4 3e 00			ld a, 0 
17d6 77				ld (hl), a 
17d7 23				inc hl 
17d8 77				ld (hl), a 
17d9 23				inc hl 
17da 77				ld (hl), a 
17db			 
17db cd c7 0c		        call clear_display 
17de cd ea 0c			call update_display 
17e1				;ld a, 1 
17e1				;ld (hardware_diag), a 
17e1			.diloop: 
17e1 3e 00			ld a, display_row_1 
17e3 0e 00			ld c, 0 
17e5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17e7 1e 28			ld e, 40 
17e9			 
17e9 21 85 f3			ld hl, scratch	 
17ec cd 28 0f			call input_str 
17ef			 
17ef 3e 14			ld a, display_row_2 
17f1 11 85 f3			ld de, scratch 
17f4 cd da 0c			call str_at_display 
17f7 cd ea 0c			call update_display 
17fa			 
17fa c3 e1 17			jp .diloop 
17fd			 
17fd			 
17fd			; pass word in hl 
17fd			; a has display location 
17fd			display_word_at: 
17fd f5				push af 
17fe e5				push hl 
17ff 7c				ld a,h 
1800 21 8a f6			ld hl, os_word_scratch 
1803 cd fc 11			call hexout 
1806 e1				pop hl 
1807 7d				ld a,l 
1808 21 8c f6			ld hl, os_word_scratch+2 
180b cd fc 11			call hexout 
180e 21 8e f6			ld hl, os_word_scratch+4 
1811 3e 00			ld a,0 
1813 77				ld (hl),a 
1814 11 8a f6			ld de,os_word_scratch 
1817 f1				pop af 
1818 cd da 0c				call str_at_display 
181b c9				ret 
181c			 
181c			display_ptr_state: 
181c			 
181c				; to restore afterwards 
181c			 
181c d5				push de 
181d c5				push bc 
181e e5				push hl 
181f f5				push af 
1820			 
1820				; for use in here 
1820			 
1820			;	push bc 
1820			;	push de 
1820			;	push hl 
1820			;	push af 
1820			 
1820 cd c7 0c			call clear_display 
1823			 
1823 11 f6 19			ld de, .ptrstate 
1826 3e 00			ld a, display_row_1 
1828 cd da 0c			call str_at_display 
182b			 
182b				; display debug step 
182b			 
182b			 
182b 11 b4 fe			ld de, debug_mark 
182e 3e 12			ld a, display_row_1+display_cols-2 
1830 cd da 0c			call str_at_display 
1833			 
1833				; display a 
1833 11 00 1a			ld de, .ptrcliptr 
1836 3e 14			ld a, display_row_2 
1838 cd da 0c			call str_at_display 
183b			 
183b f1				pop af 
183c 2a d0 fb			ld hl,(cli_ptr) 
183f 3e 1c			ld a, display_row_2+8 
1841 cd fd 17			call display_word_at 
1844			 
1844			 
1844				; display hl 
1844			 
1844			 
1844 11 08 1a			ld de, .ptrclioptr 
1847 3e 1e			ld a, display_row_2+10 
1849 cd da 0c			call str_at_display 
184c			; 
184c			;	pop hl 
184c 3e 21			ld a, display_row_2+13 
184e 2a ce fb			ld hl,(cli_origptr) 
1851 cd fd 17			call display_word_at 
1854			; 
1854			;	 
1854			;	; display de 
1854			 
1854			;	ld de, .regstatede 
1854			;	ld a, display_row_3 
1854			;	call str_at_display 
1854			 
1854			;	pop de 
1854			;	ld h,d 
1854			;	ld l, e 
1854			;	ld a, display_row_3+3 
1854			;	call display_word_at 
1854			 
1854			 
1854				; display bc 
1854			 
1854			;	ld de, .regstatebc 
1854			;	ld a, display_row_3+10 
1854			;	call str_at_display 
1854			 
1854			;	pop bc 
1854			;	ld h,b 
1854			;	ld l, c 
1854			;	ld a, display_row_3+13 
1854			;	call display_word_at 
1854			 
1854			 
1854				; display dsp 
1854			 
1854			;	ld de, .regstatedsp 
1854			;	ld a, display_row_4 
1854			;	call str_at_display 
1854			 
1854				 
1854			;	ld hl,(cli_data_sp) 
1854			;	ld a, display_row_4+4 
1854			;	call display_word_at 
1854			 
1854				; display rsp 
1854			 
1854 11 37 1a			ld de, .regstatersp 
1857 3e 46			ld a, display_row_4+10 
1859 cd da 0c			call str_at_display 
185c			 
185c				 
185c 2a b6 fb			ld hl,(cli_ret_sp) 
185f 3e 4a			ld a, display_row_4+14 
1861 cd fd 17			call display_word_at 
1864			 
1864 cd ea 0c			call update_display 
1867			 
1867 cd 44 0c			call delay1s 
186a cd 44 0c			call delay1s 
186d cd 44 0c			call delay1s 
1870			 
1870			 
1870 cd 64 1e			call next_page_prompt 
1873			 
1873				; restore  
1873			 
1873 f1				pop af 
1874 e1				pop hl 
1875 c1				pop bc 
1876 d1				pop de 
1877 c9				ret 
1878			 
1878			break_point_state: 
1878 f5				push af 
1879			 
1879				; see if disabled 
1879			 
1879 3a 76 f3			ld a, (os_view_disable) 
187c fe 2a			cp '*' 
187e 20 02			jr nz, .bpsgo 
1880 f1				pop af 
1881 c9				ret 
1882			 
1882			.bpsgo: 
1882 f1				pop af 
1883 f5				push af 
1884 22 72 f3			ld (os_view_hl), hl 
1887 ed 53 70 f3		ld (os_view_de), de 
188b ed 43 6e f3		ld (os_view_bc), bc 
188f e5				push hl 
1890 6f				ld l, a 
1891 26 00			ld h, 0 
1893 22 74 f3			ld (os_view_af),hl 
1896			 
1896 21 4a fe				ld hl, display_fb0 
1899 22 55 fd				ld (display_fb_active), hl 
189c e1				pop hl	 
189d			 
189d 3e 31			ld a, '1' 
189f fe 2a		.bps1:  cp '*' 
18a1 20 03			jr nz, .bps1b 
18a3 32 76 f3			ld (os_view_disable),a 
18a6 fe 31		.bps1b:  cp '1' 
18a8 20 14			jr nz, .bps2 
18aa			 
18aa				; display reg 
18aa			 
18aa				 
18aa			 
18aa 3a 74 f3			ld a, (os_view_af) 
18ad 2a 72 f3			ld hl, (os_view_hl) 
18b0 ed 5b 70 f3		ld de, (os_view_de) 
18b4 ed 4b 6e f3		ld bc, (os_view_bc) 
18b8 cd 52 19			call display_reg_state 
18bb c3 3e 19			jp .bpschk 
18be			 
18be fe 32		.bps2:  cp '2' 
18c0 20 08			jr nz, .bps3 
18c2				 
18c2				; display hl 
18c2 2a 72 f3			ld hl, (os_view_hl) 
18c5 cd 3c 1a			call display_dump_at_hl 
18c8			 
18c8 18 74			jr .bpschk 
18ca			 
18ca fe 33		.bps3:  cp '3' 
18cc 20 08			jr nz, .bps4 
18ce			 
18ce			        ; display de 
18ce 2a 70 f3			ld hl, (os_view_de) 
18d1 cd 3c 1a			call display_dump_at_hl 
18d4			 
18d4 18 68			jr .bpschk 
18d6 fe 34		.bps4:  cp '4' 
18d8 20 08			jr nz, .bps5 
18da			 
18da			        ; display bc 
18da 2a 6e f3			ld hl, (os_view_bc) 
18dd cd 3c 1a			call display_dump_at_hl 
18e0			 
18e0 18 5c			jr .bpschk 
18e2 fe 35		.bps5:  cp '5' 
18e4 20 08		        jr nz, .bps7 
18e6			 
18e6				; display cur ptr 
18e6 2a d0 fb			ld hl, (cli_ptr) 
18e9 cd 3c 1a			call display_dump_at_hl 
18ec			 
18ec 18 50			jr .bpschk 
18ee fe 36		.bps7:  cp '6' 
18f0 20 08			jr nz, .bps8b 
18f2				 
18f2				; display cur orig ptr 
18f2 2a ce fb			ld hl, (cli_origptr) 
18f5 cd 3c 1a			call display_dump_at_hl 
18f8 18 44			jr .bpschk 
18fa fe 37		.bps8b:  cp '7' 
18fc 20 08			jr nz, .bps9 
18fe				 
18fe				; display dsp 
18fe 2a b2 fb			ld hl, (cli_data_sp) 
1901 cd 3c 1a			call display_dump_at_hl 
1904			 
1904 18 38			jr .bpschk 
1906 fe 39		.bps9:  cp '9' 
1908 20 05			jr nz, .bps8c 
190a				 
190a				; display SP 
190a			;	ld hl, sp 
190a cd 3c 1a			call display_dump_at_hl 
190d			 
190d 18 2f			jr .bpschk 
190f fe 38		.bps8c:  cp '8' 
1911 20 08			jr nz, .bps8d 
1913				 
1913				; display rsp 
1913 2a b6 fb			ld hl, (cli_ret_sp) 
1916 cd 3c 1a			call display_dump_at_hl 
1919			 
1919 18 23			jr .bpschk 
191b fe 23		.bps8d:  cp '#'     ; access monitor sub system 
191d 20 05			jr nz, .bps8 
191f cd 5a 1c			call monitor 
1922			 
1922 18 1a			jr .bpschk 
1924 fe 30		.bps8:  cp '0' 
1926 20 16			jr nz, .bpschk 
1928			 
1928 21 f9 fd				ld hl, display_fb1 
192b 22 55 fd				ld (display_fb_active), hl 
192e cd ea 0c				call update_display 
1931			 
1931				;ld a, (os_view_af) 
1931 2a 72 f3			ld hl, (os_view_hl) 
1934 ed 5b 70 f3		ld de, (os_view_de) 
1938 ed 4b 6e f3		ld bc, (os_view_bc) 
193c f1				pop af 
193d c9				ret 
193e			 
193e			.bpschk:   
193e cd 44 0c			call delay1s 
1941 3e 4f		ld a,display_row_4 + display_cols - 1 
1943 11 62 1e		        ld de, endprg 
1946 cd da 0c			call str_at_display 
1949 cd ea 0c			call update_display 
194c cd 24 6b			call cin_wait 
194f			 
194f c3 9f 18			jp .bps1 
1952			 
1952			 
1952			display_reg_state: 
1952			 
1952				; to restore afterwards 
1952			 
1952 d5				push de 
1953 c5				push bc 
1954 e5				push hl 
1955 f5				push af 
1956			 
1956				; for use in here 
1956			 
1956 c5				push bc 
1957 d5				push de 
1958 e5				push hl 
1959 f5				push af 
195a			 
195a cd c7 0c			call clear_display 
195d			 
195d 11 12 1a			ld de, .regstate 
1960 3e 00			ld a, display_row_1 
1962 cd da 0c			call str_at_display 
1965			 
1965				; display debug step 
1965			 
1965			 
1965 11 b4 fe			ld de, debug_mark 
1968 3e 11			ld a, display_row_1+display_cols-3 
196a cd da 0c			call str_at_display 
196d			 
196d				; display a 
196d 11 2e 1a			ld de, .regstatea 
1970 3e 14			ld a, display_row_2 
1972 cd da 0c			call str_at_display 
1975			 
1975 e1				pop hl 
1976			;	ld h,0 
1976			;	ld l, a 
1976 3e 17			ld a, display_row_2+3 
1978 cd fd 17			call display_word_at 
197b			 
197b			 
197b				; display hl 
197b			 
197b			 
197b 11 22 1a			ld de, .regstatehl 
197e 3e 1e			ld a, display_row_2+10 
1980 cd da 0c			call str_at_display 
1983			 
1983 e1				pop hl 
1984 3e 21			ld a, display_row_2+13 
1986 cd fd 17			call display_word_at 
1989			 
1989				 
1989				; display de 
1989			 
1989 11 26 1a			ld de, .regstatede 
198c 3e 28			ld a, display_row_3 
198e cd da 0c			call str_at_display 
1991			 
1991 e1				pop hl 
1992			;	ld h,d 
1992			;	ld l, e 
1992 3e 2b			ld a, display_row_3+3 
1994 cd fd 17			call display_word_at 
1997			 
1997			 
1997				; display bc 
1997			 
1997 11 2a 1a			ld de, .regstatebc 
199a 3e 32			ld a, display_row_3+10 
199c cd da 0c			call str_at_display 
199f			 
199f e1				pop hl 
19a0			;	ld h,b 
19a0			;	ld l, c 
19a0 3e 35			ld a, display_row_3+13 
19a2 cd fd 17			call display_word_at 
19a5			 
19a5			 
19a5				; display dsp 
19a5			 
19a5 11 32 1a			ld de, .regstatedsp 
19a8 3e 3c			ld a, display_row_4 
19aa cd da 0c			call str_at_display 
19ad			 
19ad				 
19ad 2a b2 fb			ld hl,(cli_data_sp) 
19b0 3e 40			ld a, display_row_4+4 
19b2 cd fd 17			call display_word_at 
19b5			 
19b5				; display rsp 
19b5			 
19b5 11 37 1a			ld de, .regstatersp 
19b8 3e 46			ld a, display_row_4+10 
19ba cd da 0c			call str_at_display 
19bd			 
19bd				 
19bd 2a b6 fb			ld hl,(cli_ret_sp) 
19c0 3e 4a			ld a, display_row_4+14 
19c2 cd fd 17			call display_word_at 
19c5			 
19c5 cd ea 0c			call update_display 
19c8			 
19c8			;	call delay1s 
19c8			;	call delay1s 
19c8			;	call delay1s 
19c8			 
19c8			 
19c8			;	call next_page_prompt 
19c8			 
19c8				; restore  
19c8			 
19c8 f1				pop af 
19c9 e1				pop hl 
19ca c1				pop bc 
19cb d1				pop de 
19cc c9				ret 
19cd			 
19cd .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
19e1 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
19f6 .. 00		.ptrstate:	db "Ptr State",0 
1a00 .. 00		.ptrcliptr:     db "cli_ptr",0 
1a08 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a12 .. 00		.regstate:	db "Reg State (1/0)",0 
1a22 .. 00		.regstatehl:	db "HL:",0 
1a26 .. 00		.regstatede:	db "DE:",0 
1a2a .. 00		.regstatebc:	db "BC:",0 
1a2e .. 00		.regstatea:	db "A :",0 
1a32 .. 00		.regstatedsp:	db "DSP:",0 
1a37 .. 00		.regstatersp:	db "RSP:",0 
1a3c			 
1a3c			display_dump_at_hl: 
1a3c e5				push hl 
1a3d d5				push de 
1a3e c5				push bc 
1a3f f5				push af 
1a40			 
1a40 22 a8 f6			ld (os_cur_ptr),hl	 
1a43 cd c7 0c			call clear_display 
1a46 cd 6c 1d			call dumpcont 
1a49			;	call delay1s 
1a49			;	call next_page_prompt 
1a49			 
1a49			 
1a49 f1				pop af 
1a4a c1				pop bc 
1a4b d1				pop de 
1a4c e1				pop hl 
1a4d c9				ret 
1a4e			 
1a4e			;if ENABLE_BASIC 
1a4e			;	include "nascombasic.asm" 
1a4e			;	basic: 
1a4e			;	include "forth/FORTH.ASM" 
1a4e			;endif 
1a4e			 
1a4e			; eof 
1a4e			 
1a4e			 
# End of file firmware_diags.asm
1a4e			  
1a4e			include "firmware_prompts.asm"  
1a4e			; Prompts  
1a4e			 
1a4e			; boot messages 
1a4e			 
1a4e .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1a63 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1a73			 
1a73			 
1a73			; config menus 
1a73			 
1a73 .. 00		prom_c3: db "Add Dictionary To File",0 
1a8a .. 00		prom_c2: db "Select Autoload File",0 
1a9f .. 00		prom_c2a: db "Disable Autoload File", 0 
1ab5 .. 00		prom_c2b: db "Select Storage Bank",0 
1ac9 .. 00		prom_c4: db "Settings",0 
1ad2 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1aed .. 00		prom_m4b:   db "Monitor",0 
1af5 .. 00		prom_c1: db "Hardware Diags",0 
1b04			 
1b04			 
1b04 .. 00		prom_notav:    db "Feature not available",0 
1b1a .. 00		prom_empty:    db "",0 
1b1b			 
1b1b			; eof 
1b1b			 
# End of file firmware_prompts.asm
1b1b			  
1b1b			  
1b1b			; eof  
1b1b			  
# End of file firmware.asm
1b1b			 
1b1b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b1b			;if BASE_KEV  
1b1b			;baseram: equ 08000h 
1b1b			;endif 
1b1b			 
1b1b			;if BASE_SC114 
1b1b			;baseram:     equ    endofcode 
1b1b			;endif 
1b1b			 
1b1b			 
1b1b			; start system 
1b1b			 
1b1b			coldstart: 
1b1b				; set sp 
1b1b				; di/ei 
1b1b			 
1b1b f3				di 
1b1c 31 fd ff			ld sp, tos 
1b1f			;	ei 
1b1f			 
1b1f			 
1b1f				; disable breakpoint by default 
1b1f			 
1b1f 3e 2a			ld a,'*' 
1b21 32 76 f3			ld (os_view_disable),a 
1b24			 
1b24				; init hardware 
1b24			 
1b24				; init keyboard and screen hardware 
1b24			 
1b24 cd 1c 00			call hardware_init 
1b27			 
1b27			 
1b27 cd 44 0c			call delay1s 
1b2a 3e 30			ld a, display_row_3+8 
1b2c 11 03 00			ld de, buildtime 
1b2f cd da 0c			call str_at_display 
1b32 cd ea 0c			call update_display 
1b35			 
1b35 cd 44 0c			call delay1s 
1b38 cd 44 0c			call delay1s 
1b3b cd 44 0c			call delay1s 
1b3e			 
1b3e				; detect if any keys are held down to enable breakpoints at start up 
1b3e			 
1b3e cd 35 6b			call cin  
1b41 fe 00			cp 0 
1b43 28 03			jr z, .nokeys 
1b45			 
1b45				;call hardware_diags 
1b45 cd 5b 15			call config 
1b48			 
1b48			;	ld de, .bpen 
1b48			;	ld a, display_row_4 
1b48			;	call str_at_display 
1b48			;	call update_display 
1b48			; 
1b48			;	ld a,0 
1b48			;	ld (os_view_disable),a 
1b48			; 
1b48			;.bpwait: 
1b48			;	call cin 
1b48			;	cp 0 
1b48			;	jr z, .bpwait 
1b48			;	jr .nokeys 
1b48			; 
1b48			; 
1b48			;.bpen:  db "Break points enabled!",0 
1b48			 
1b48			 
1b48			 
1b48			 
1b48			 
1b48			 
1b48			.nokeys: 
1b48			 
1b48			 
1b48				 
1b48			 
1b48			;jp  testkey 
1b48			 
1b48			;call storage_get_block_0 
1b48			; 
1b48			;ld hl, 0 
1b48			;ld de, store_page 
1b48			;call storage_read_block 
1b48			 
1b48				 
1b48			;ld hl, 10 
1b48			;ld de, store_page 
1b48			;call storage_read_block 
1b48			 
1b48			 
1b48			 
1b48			 
1b48			 
1b48			;stop:	nop 
1b48			;	jp stop 
1b48			 
1b48			 
1b48			 
1b48			main: 
1b48 cd c7 0c			call clear_display 
1b4b cd ea 0c			call update_display 
1b4e			 
1b4e			 
1b4e			 
1b4e			;	call testlcd 
1b4e			 
1b4e			 
1b4e			 
1b4e cd 2a 22			call forth_init 
1b51			 
1b51			 
1b51			warmstart: 
1b51 cd 00 22			call forth_warmstart 
1b54			 
1b54				; run startup word load 
1b54			        ; TODO prevent this running at warmstart after crash  
1b54			 
1b54				if STARTUP_ENABLE 
1b54					if STORAGE_SE 
1b54 cd 66 68					call forth_autoload 
1b57					endif 
1b57 cd 75 65				call forth_startup 
1b5a			 
1b5a			 
1b5a				endif 
1b5a			 
1b5a				; show free memory after boot 
1b5a 11 f4 1b			ld de, freeram 
1b5d 3e 00			ld a, display_row_1 
1b5f cd da 0c			call str_at_display 
1b62			 
1b62			; Or use heap_size word???? 
1b62 21 6b f3			ld hl, heap_end 
1b65 11 0e 80			ld de, heap_start 
1b68 ed 52			sbc hl, de 
1b6a e5				push hl 
1b6b 7c				ld a,h	         	 
1b6c 21 8a f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b6f cd fc 11			call hexout 
1b72 e1			   	pop hl 
1b73			 
1b73 7d				ld a,l 
1b74 21 8c f6			ld hl, os_word_scratch+2 
1b77 cd fc 11			call hexout 
1b7a 21 8e f6			ld hl, os_word_scratch+4 
1b7d 3e 00			ld a, 0 
1b7f 77				ld (hl),a 
1b80 11 8a f6			ld de, os_word_scratch 
1b83 3e 0d			ld a, display_row_1 + 13 
1b85 cd da 0c			call str_at_display 
1b88 cd ea 0c			call update_display 
1b8b			 
1b8b			 
1b8b				;call demo 
1b8b			 
1b8b			 
1b8b				; init scratch input area for cli commands 
1b8b			 
1b8b 21 ac f6			ld hl, os_cli_cmd 
1b8e 3e 00			ld a,0 
1b90 77				ld (hl),a 
1b91 23				inc hl 
1b92 77				ld (hl),a 
1b93			 
1b93 3e 00			ld a,0 
1b95 32 ab f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1b98			 
1b98 32 a8 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1b9b 32 a9 f6			ld (os_cur_ptr+1),a	 
1b9e			 
1b9e 32 8a f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1ba1 32 8b f6			ld (os_word_scratch+1),a	 
1ba4				 
1ba4			 
1ba4				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ba4 21 ac f6			ld hl, os_cli_cmd 
1ba7			 
1ba7 3e 00			ld a, 0		 ; init cli input 
1ba9 77				ld (hl), a 
1baa 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bac			cli: 
1bac				; show cli prompt 
1bac				;push af 
1bac				;ld a, 0 
1bac				;ld de, prompt 
1bac				;call str_at_display 
1bac			 
1bac				;call update_display 
1bac				;pop af 
1bac				;inc a 
1bac				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bac 0e 00			ld c, 0 
1bae 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bb0 1e 28			ld e, 40 
1bb2			 
1bb2 21 ac f6			ld hl, os_cli_cmd 
1bb5			 
1bb5				STACKFRAME OFF $fefe $9f9f 
1bb5				if DEBUG_STACK_IMB 
1bb5					if OFF 
1bb5						exx 
1bb5						ld de, $fefe 
1bb5						ld a, d 
1bb5						ld hl, curframe 
1bb5						call hexout 
1bb5						ld a, e 
1bb5						ld hl, curframe+2 
1bb5						call hexout 
1bb5						ld hl, $fefe 
1bb5						push hl 
1bb5						ld hl, $9f9f 
1bb5						push hl 
1bb5						exx 
1bb5					endif 
1bb5				endif 
1bb5			endm 
# End of macro STACKFRAME
1bb5			 
1bb5 cd 28 0f			call input_str 
1bb8			 
1bb8				STACKFRAMECHK OFF $fefe $9f9f 
1bb8				if DEBUG_STACK_IMB 
1bb8					if OFF 
1bb8						exx 
1bb8						ld hl, $9f9f 
1bb8						pop de   ; $9f9f 
1bb8						call cmp16 
1bb8						jr nz, .spnosame 
1bb8						ld hl, $fefe 
1bb8						pop de   ; $fefe 
1bb8						call cmp16 
1bb8						jr z, .spfrsame 
1bb8						.spnosame: call showsperror 
1bb8						.spfrsame: nop 
1bb8						exx 
1bb8					endif 
1bb8				endif 
1bb8			endm 
# End of macro STACKFRAMECHK
1bb8			 
1bb8				; copy input to last command 
1bb8			 
1bb8 21 ac f6			ld hl, os_cli_cmd 
1bbb 11 ab f7			ld de, os_last_cmd 
1bbe 01 ff 00			ld bc, 255 
1bc1 ed b0			ldir 
1bc3			 
1bc3				; wipe current buffer 
1bc3			 
1bc3			;	ld a, 0 
1bc3			;	ld hl, os_cli_cmd 
1bc3			;	ld de, os_cli_cmd+1 
1bc3			;	ld bc, 254 
1bc3			;	ldir 
1bc3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1bc3			;	call strcpy 
1bc3			;	ld a, 0 
1bc3			;	ld (hl), a 
1bc3			;	inc hl 
1bc3			;	ld (hl), a 
1bc3			;	inc hl 
1bc3			;	ld (hl), a 
1bc3			 
1bc3				; switch frame buffer to program  
1bc3			 
1bc3 21 f9 fd				ld hl, display_fb1 
1bc6 22 55 fd				ld (display_fb_active), hl 
1bc9			 
1bc9			;	nop 
1bc9				STACKFRAME ON $fbfe $8f9f 
1bc9				if DEBUG_STACK_IMB 
1bc9					if ON 
1bc9						exx 
1bc9						ld de, $fbfe 
1bc9						ld a, d 
1bc9						ld hl, curframe 
1bc9						call hexout 
1bc9						ld a, e 
1bc9						ld hl, curframe+2 
1bc9						call hexout 
1bc9						ld hl, $fbfe 
1bc9						push hl 
1bc9						ld hl, $8f9f 
1bc9						push hl 
1bc9						exx 
1bc9					endif 
1bc9				endif 
1bc9			endm 
# End of macro STACKFRAME
1bc9				; first time into the parser so pass over the current scratch pad 
1bc9 21 ac f6			ld hl,os_cli_cmd 
1bcc				; tokenise the entered statement(s) in HL 
1bcc cd a8 22			call forthparse 
1bcf			        ; exec forth statements in top of return stack 
1bcf cd e8 22			call forthexec 
1bd2				;call forthexec_cleanup 
1bd2			;	call parsenext 
1bd2			 
1bd2				STACKFRAMECHK ON $fbfe $8f9f 
1bd2				if DEBUG_STACK_IMB 
1bd2					if ON 
1bd2						exx 
1bd2						ld hl, $8f9f 
1bd2						pop de   ; $8f9f 
1bd2						call cmp16 
1bd2						jr nz, .spnosame 
1bd2						ld hl, $fbfe 
1bd2						pop de   ; $fbfe 
1bd2						call cmp16 
1bd2						jr z, .spfrsame 
1bd2						.spnosame: call showsperror 
1bd2						.spfrsame: nop 
1bd2						exx 
1bd2					endif 
1bd2				endif 
1bd2			endm 
# End of macro STACKFRAMECHK
1bd2				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1bd2			 
1bd2 3e 3c			ld a, display_row_4 
1bd4 11 06 1c			ld de, endprog 
1bd7			 
1bd7 cd ea 0c			call update_display		 
1bda			 
1bda cd 64 1e			call next_page_prompt 
1bdd			 
1bdd				; switch frame buffer to cli 
1bdd			 
1bdd 21 4a fe				ld hl, display_fb0 
1be0 22 55 fd				ld (display_fb_active), hl 
1be3			 
1be3			 
1be3 cd c7 0c		        call clear_display 
1be6 cd ea 0c			call update_display		 
1be9			 
1be9 21 ac f6			ld hl, os_cli_cmd 
1bec			 
1bec 3e 00			ld a, 0		 ; init cli input 
1bee 77				ld (hl), a 
1bef			 
1bef				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1bef			 
1bef				; now on last line 
1bef			 
1bef				; TODO scroll screen up 
1bef			 
1bef				; TODO instead just clear screen and place at top of screen 
1bef			 
1bef			;	ld a, 0 
1bef			;	ld (f_cursor_ptr),a 
1bef			 
1bef				;call clear_display 
1bef				;call update_display 
1bef			 
1bef				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bef 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf1 c3 ac 1b			jp cli 
1bf4			 
1bf4 .. 00		freeram: db "Free bytes: $",0 
1c02 ..			asc: db "1A2F" 
1c06 .. 00		endprog: db "End prog...",0 
1c12			 
1c12			testenter2:   
1c12 21 b7 f3			ld hl,scratch+50 
1c15 22 a8 f6			ld (os_cur_ptr),hl 
1c18 c3 ac 1b			jp cli 
1c1b			 
1c1b			testenter:  
1c1b			 
1c1b 21 02 1c			ld hl,asc 
1c1e			;	ld a,(hl) 
1c1e			;	call nibble2val 
1c1e cd 52 12			call get_byte 
1c21			 
1c21			 
1c21			;	ld a,(hl) 
1c21			;	call atohex 
1c21			 
1c21			;	call fourehexhl 
1c21 32 b7 f3			ld (scratch+50),a 
1c24			 
1c24			 
1c24			 
1c24 21 04 1c			ld hl,asc+2 
1c27			;	ld a, (hl) 
1c27			;	call nibble2val 
1c27 cd 52 12			call get_byte 
1c2a			 
1c2a			;	call fourehexhl 
1c2a 32 b9 f3			ld (scratch+52),a 
1c2d				 
1c2d 21 b7 f3			ld hl,scratch+50 
1c30 22 a8 f6			ld (os_cur_ptr),hl 
1c33 c3 ac 1b			jp cli 
1c36			 
1c36			enter:	 
1c36 3a 89 f3			ld a,(scratch+4) 
1c39 fe 00			cp 0 
1c3b 28 0c			jr z, .entercont 
1c3d				; no, not a null term line so has an address to work out.... 
1c3d			 
1c3d 21 87 f3			ld hl,scratch+2 
1c40 cd b2 12			call get_word_hl 
1c43			 
1c43 22 a8 f6			ld (os_cur_ptr),hl	 
1c46 c3 ac 1b			jp cli 
1c49			 
1c49			 
1c49			.entercont:  
1c49			 
1c49 21 87 f3			ld hl, scratch+2 
1c4c cd 52 12			call get_byte 
1c4f			 
1c4f 2a a8 f6		   	ld hl,(os_cur_ptr) 
1c52 77					ld (hl),a 
1c53 23					inc hl 
1c54 22 a8 f6				ld (os_cur_ptr),hl 
1c57				 
1c57			; get byte  
1c57			 
1c57			 
1c57 c3 ac 1b			jp cli 
1c5a			 
1c5a			 
1c5a			; basic monitor support 
1c5a			 
1c5a			monitor: 
1c5a				;  
1c5a cd c7 0c			call clear_display 
1c5d 3e 00			ld a, 0 
1c5f 11 a7 1c			ld de, .monprompt 
1c62 cd da 0c			call str_at_display 
1c65 cd ea 0c			call update_display 
1c68			 
1c68				; get a monitor command 
1c68			 
1c68 0e 00			ld c, 0     ; entry at top left 
1c6a 16 64			ld d, 100   ; max buffer size 
1c6c 1e 0f			ld e, 15    ; input scroll area 
1c6e 3e 00			ld a, 0     ; init string 
1c70 21 83 f5			ld hl, os_input 
1c73 77				ld (hl), a 
1c74 23				inc hl 
1c75 77				ld (hl), a 
1c76 21 83 f5			ld hl, os_input 
1c79 3e 01			ld a, 1     ; init string 
1c7b cd 28 0f			call input_str 
1c7e			 
1c7e cd c7 0c		        call clear_display 
1c81 cd ea 0c			call update_display		 
1c84			 
1c84 3a 83 f5			ld a, (os_input) 
1c87 cd 50 13			call toUpper 
1c8a fe 48		        cp 'H' 
1c8c 28 6f		        jr z, .monhelp 
1c8e fe 44			cp 'D'		; dump 
1c90 ca 1e 1d			jp z, .mondump	 
1c93 fe 43			cp 'C'		; dump 
1c95 ca 38 1d			jp z, .moncdump	 
1c98 fe 4d			cp 'M'		; dump 
1c9a ca a9 1c			jp z, .moneditstart 
1c9d fe 55			cp 'U'		; dump 
1c9f 28 14			jr z, .monedit	 
1ca1 fe 51			cp 'Q'		; dump 
1ca3 c8				ret z	 
1ca4			 
1ca4			 
1ca4				; TODO "S" to access symbol by name and not need the address 
1ca4				; TODO "F" to find a string in memory 
1ca4			 
1ca4 c3 5a 1c			jp monitor 
1ca7			 
1ca7 .. 00		.monprompt: db ">", 0 
1ca9			 
1ca9			.moneditstart: 
1ca9				; get starting address 
1ca9			 
1ca9 21 85 f5			ld hl,os_input+2 
1cac cd b2 12			call get_word_hl 
1caf			 
1caf 22 a8 f6			ld (os_cur_ptr),hl	 
1cb2			 
1cb2 c3 5a 1c			jp monitor 
1cb5			 
1cb5			.monedit: 
1cb5				; get byte to load 
1cb5			 
1cb5 21 85 f5			ld hl,os_input+2 
1cb8 cd 52 12			call get_byte 
1cbb			 
1cbb				; get address to update 
1cbb 2a a8 f6			ld hl, (os_cur_ptr) 
1cbe			 
1cbe				; update byte 
1cbe			 
1cbe 77				ld (hl), a 
1cbf			 
1cbf				; move to next address and save it 
1cbf			 
1cbf 23				inc hl 
1cc0 22 a8 f6			ld (os_cur_ptr),hl	 
1cc3			 
1cc3 c3 5a 1c			jp monitor 
1cc6			 
1cc6			 
1cc6 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1cda .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1cf6 .. 00		.monhelptext3:  db "Q-Quit",0 
1cfd			        
1cfd			.monhelp: 
1cfd 3e 00			ld a, display_row_1 
1cff 11 c6 1c		        ld de, .monhelptext1 
1d02			 
1d02 cd da 0c			call str_at_display 
1d05 3e 14			ld a, display_row_2 
1d07 11 da 1c		        ld de, .monhelptext2 
1d0a					 
1d0a cd da 0c			call str_at_display 
1d0d 3e 28			ld a, display_row_3 
1d0f 11 f6 1c		        ld de, .monhelptext3 
1d12					 
1d12 cd da 0c			call str_at_display 
1d15 cd ea 0c			call update_display		 
1d18			 
1d18 cd 64 1e			call next_page_prompt 
1d1b c3 5a 1c			jp monitor 
1d1e			 
1d1e			.mondump:    
1d1e 21 85 f5			ld hl,os_input+2 
1d21 cd b2 12			call get_word_hl 
1d24			 
1d24 22 a8 f6			ld (os_cur_ptr),hl	 
1d27 cd 6c 1d			call dumpcont 
1d2a 3e 3c			ld a, display_row_4 
1d2c 11 06 1c			ld de, endprog 
1d2f			 
1d2f cd ea 0c			call update_display		 
1d32			 
1d32 cd 64 1e			call next_page_prompt 
1d35 c3 5a 1c			jp monitor 
1d38			.moncdump: 
1d38 cd 6c 1d			call dumpcont 
1d3b 3e 3c			ld a, display_row_4 
1d3d 11 06 1c			ld de, endprog 
1d40			 
1d40 cd ea 0c			call update_display		 
1d43			 
1d43 cd 64 1e			call next_page_prompt 
1d46 c3 5a 1c			jp monitor 
1d49			 
1d49			 
1d49			; TODO symbol access  
1d49			 
1d49			.symbols:     ;; A list of symbols that can be called up  
1d49 4a fe			dw display_fb0 
1d4b .. 00			db "fb0",0  
1d4f 07 fc		     	dw store_page 
1d51 .. 00			db "store_page",0 
1d5c			 
1d5c			 
1d5c			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1d5c			 
1d5c 3a 86 f3			ld a,(scratch+1) 
1d5f fe 00			cp 0 
1d61 28 09			jr z, dumpcont 
1d63			 
1d63				; no, not a null term line so has an address to work out.... 
1d63			 
1d63 21 87 f3			ld hl,scratch+2 
1d66 cd b2 12			call get_word_hl 
1d69			 
1d69 22 a8 f6			ld (os_cur_ptr),hl	 
1d6c			 
1d6c			 
1d6c			 
1d6c			dumpcont: 
1d6c			 
1d6c				; dump bytes at ptr 
1d6c			 
1d6c			 
1d6c 3e 00			ld a, display_row_1 
1d6e 2a 55 fd			ld hl, (display_fb_active) 
1d71 cd fb 0e			call addatohl 
1d74 cd 9c 1d			call .dumpbyterow 
1d77			 
1d77 3e 14			ld a, display_row_2 
1d79 2a 55 fd			ld hl, (display_fb_active) 
1d7c cd fb 0e			call addatohl 
1d7f cd 9c 1d			call .dumpbyterow 
1d82			 
1d82			 
1d82 3e 28			ld a, display_row_3 
1d84 2a 55 fd			ld hl, (display_fb_active) 
1d87 cd fb 0e			call addatohl 
1d8a cd 9c 1d			call .dumpbyterow 
1d8d			 
1d8d 3e 3c			ld a, display_row_4 
1d8f 2a 55 fd			ld hl, (display_fb_active) 
1d92 cd fb 0e			call addatohl 
1d95 cd 9c 1d			call .dumpbyterow 
1d98			 
1d98 cd ea 0c			call update_display 
1d9b			;		jp cli 
1d9b c9				ret 
1d9c			 
1d9c			.dumpbyterow: 
1d9c			 
1d9c				;push af 
1d9c			 
1d9c e5				push hl 
1d9d			 
1d9d				; calc where to poke the ascii 
1d9d			if display_cols == 20 
1d9d 3e 10			ld a, 16 
1d9f			else 
1d9f				ld a, 31 
1d9f			endif 
1d9f			 
1d9f cd fb 0e			call addatohl 
1da2 22 8a f6			ld (os_word_scratch),hl  		; save pos for later 
1da5			 
1da5			 
1da5			; display decoding address 
1da5 2a a8 f6		   	ld hl,(os_cur_ptr) 
1da8			 
1da8 7c				ld a,h 
1da9 e1				pop hl 
1daa e5				push hl 
1dab			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1dab cd fc 11			call hexout 
1dae 2a a8 f6		   	ld hl,(os_cur_ptr) 
1db1			 
1db1 7d				ld a,l 
1db2 e1				pop hl 
1db3 23				inc hl 
1db4 23				inc hl 
1db5 e5				push hl 
1db6			;	ld hl, os_word_scratch+2 
1db6 cd fc 11			call hexout 
1db9 e1				pop hl 
1dba 23				inc hl 
1dbb 23				inc hl 
1dbc				;ld hl, os_word_scratch+4 
1dbc 3e 3a			ld a, ':' 
1dbe 77				ld (hl),a 
1dbf 23				inc hl 
1dc0				;ld a, 0 
1dc0				;ld (hl),a 
1dc0				;ld de, os_word_scratch 
1dc0				;pop af 
1dc0				;push af 
1dc0			;		ld a, display_row_2 
1dc0			;		call str_at_display 
1dc0			;		call update_display 
1dc0			 
1dc0			 
1dc0			;pop af 
1dc0			;	add 5 
1dc0			 
1dc0			if display_cols == 20 
1dc0 06 04			ld b, 4 
1dc2			else 
1dc2				ld b, 8 
1dc2			endif	 
1dc2			 
1dc2			.dumpbyte: 
1dc2 c5				push bc 
1dc3 e5				push hl 
1dc4			 
1dc4			 
1dc4 2a a8 f6		   	ld hl,(os_cur_ptr) 
1dc7 7e					ld a,(hl) 
1dc8			 
1dc8					; poke the ascii to display 
1dc8 2a 8a f6				ld hl,(os_word_scratch) 
1dcb 77					ld (hl),a 
1dcc 23					inc hl 
1dcd 22 8a f6				ld (os_word_scratch),hl 
1dd0			 
1dd0					 
1dd0			 
1dd0			 
1dd0 e1					pop hl 
1dd1 e5					push hl 
1dd2			 
1dd2 cd fc 11				call hexout 
1dd5			 
1dd5					 
1dd5 2a a8 f6		   	ld hl,(os_cur_ptr) 
1dd8 23				inc hl 
1dd9 22 a8 f6		   	ld (os_cur_ptr),hl 
1ddc			 
1ddc e1					pop hl 
1ddd 23					inc hl 
1dde 23					inc hl 
1ddf 23					inc hl 
1de0			 
1de0			 
1de0			 
1de0					;ld a,0 
1de0					;ld (os_word_scratch+2),a 
1de0					;pop af 
1de0					;push af 
1de0			 
1de0					;ld de, os_word_scratch 
1de0					;call str_at_display 
1de0			;		call update_display 
1de0			;		pop af 
1de0 c1					pop bc 
1de1 c6 03				add 3 
1de3 10 dd			djnz .dumpbyte 
1de5			 
1de5				 
1de5			 
1de5 c9				ret 
1de6			 
1de6			jump:	 
1de6			 
1de6 21 87 f3			ld hl,scratch+2 
1de9 cd b2 12			call get_word_hl 
1dec				;ld hl,(scratch+2) 
1dec				;call fourehexhl 
1dec			 
1dec 22 a8 f6			ld (os_cur_ptr),hl	 
1def			 
1def e9				jp (hl) 
1df0			 
1df0			 
1df0			 
1df0			; TODO implement a basic monitor mode to start with 
1df0			 
1df0			 
1df0			 
1df0			 
1df0			 
1df0			 
1df0			 
1df0			 
1df0			 
1df0			; testing and demo code during development 
1df0			 
1df0			 
1df0 .. 00		str1: db "Enter some text...",0 
1e03 .. 00		clear: db "                    ",0 
1e18			 
1e18			demo: 
1e18			 
1e18			 
1e18			 
1e18			;	call update_display 
1e18			 
1e18				; init scratch input area for testing 
1e18 21 85 f3			ld hl, scratch	 
1e1b 3e 00			ld a,0 
1e1d 77				ld (hl),a 
1e1e			 
1e1e			 
1e1e 3e 14		            LD   A, display_row_2 
1e20			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e20 11 f0 1d		            LD   DE, str1 
1e23 cd da 0c			call str_at_display 
1e26			 
1e26			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e26			cloop:	 
1e26 3e 28		            LD   A, display_row_3 
1e28			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e28 11 03 1e		            LD   DE, clear 
1e2b			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e2b cd da 0c				call str_at_display 
1e2e 3e 3c			ld a, display_row_4 
1e30 11 60 1e			ld de, prompt 
1e33			 
1e33 cd da 0c				call str_at_display 
1e36 cd ea 0c			call update_display 
1e39			 
1e39 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e3b 16 0a			ld d, 10 
1e3d 21 85 f3			ld hl, scratch	 
1e40 cd 28 0f			call input_str 
1e43			 
1e43			;	call clear_display 
1e43			;'	call update_display 
1e43			 
1e43 3e 00		            LD   A, display_row_1 
1e45			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e45 11 03 1e		            LD   DE, clear 
1e48 cd da 0c				call str_at_display 
1e4b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e4b 3e 00		            LD   A, display_row_1 
1e4d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e4d 11 85 f3		            LD   DE, scratch 
1e50			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e50 cd da 0c				call str_at_display 
1e53 cd ea 0c			call update_display 
1e56			 
1e56 3e 00				ld a,0 
1e58 21 85 f3			ld hl, scratch 
1e5b 77				ld (hl),a 
1e5c			 
1e5c 00				nop 
1e5d c3 26 1e			jp cloop 
1e60			 
1e60			 
1e60			 
1e60			; OS Prompt 
1e60			 
1e60 .. 00		prompt: db ">",0 
1e62 .. 00		endprg: db "?",0 
1e64			 
1e64			 
1e64			; handy next page prompt 
1e64			next_page_prompt: 
1e64 e5				push hl 
1e65 d5				push de 
1e66 f5				push af 
1e67 c5				push bc 
1e68			 
1e68 3e 4f			ld a,display_row_4 + display_cols - 1 
1e6a 11 62 1e		        ld de, endprg 
1e6d cd da 0c			call str_at_display 
1e70 cd ea 0c			call update_display 
1e73 cd 24 6b			call cin_wait 
1e76 c1				pop bc 
1e77 f1				pop af 
1e78 d1				pop de 
1e79 e1				pop hl 
1e7a			 
1e7a			 
1e7a c9				ret 
1e7b			 
1e7b			 
1e7b			; forth parser 
1e7b			 
1e7b			; My forth kernel 
1e7b			include "forth_kernel.asm" 
1e7b			; 
1e7b			; kernel to the forth OS 
1e7b			 
1e7b			DS_TYPE_STR: equ 1     ; string type 
1e7b			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1e7b			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1e7b			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1e7b			 
1e7b			FORTH_PARSEV1: equ 0 
1e7b			FORTH_PARSEV2: equ 0 
1e7b			FORTH_PARSEV3: equ 0 
1e7b			FORTH_PARSEV4: equ 0 
1e7b			FORTH_PARSEV5: equ 1 
1e7b			 
1e7b			;if FORTH_PARSEV5 
1e7b			;	FORTH_END_BUFFER: equ 0 
1e7b			;else 
1e7b			FORTH_END_BUFFER: equ 127 
1e7b			;endif 
1e7b			 
1e7b			FORTH_TRUE: equ 1 
1e7b			FORTH_FALSE: equ 0 
1e7b			 
1e7b			if FORTH_PARSEV4 
1e7b			include "forth_stackops.asm" 
1e7b			endif 
1e7b			 
1e7b			if FORTH_PARSEV5 
1e7b			include "forth_stackopsv5.asm" 
1e7b			 
1e7b			; Stack operations for v5 parser on wards 
1e7b			; * DATA stack 
1e7b			; * LOOP stack 
1e7b			; * RETURN stack 
1e7b			 
1e7b			 
1e7b			 
1e7b			FORTH_CHK_DSP_UNDER: macro 
1e7b				push hl 
1e7b				push de 
1e7b				ld hl,(cli_data_sp) 
1e7b				ld de, cli_data_stack 
1e7b				call cmp16 
1e7b				jp c, fault_dsp_under 
1e7b				pop de 
1e7b				pop hl 
1e7b				endm 
1e7b			 
1e7b			 
1e7b			FORTH_CHK_RSP_UNDER: macro 
1e7b				push hl 
1e7b				push de 
1e7b				ld hl,(cli_ret_sp) 
1e7b				ld de, cli_ret_stack 
1e7b				call cmp16 
1e7b				jp c, fault_rsp_under 
1e7b				pop de 
1e7b				pop hl 
1e7b				endm 
1e7b			 
1e7b			FORTH_CHK_LOOP_UNDER: macro 
1e7b				push hl 
1e7b				push de 
1e7b				ld hl,(cli_loop_sp) 
1e7b				ld de, cli_loop_stack 
1e7b				call cmp16 
1e7b				jp c, fault_loop_under 
1e7b				pop de 
1e7b				pop hl 
1e7b				endm 
1e7b			 
1e7b			FORTH_ERR_TOS_NOTSTR: macro 
1e7b				; TOSO might need more for checks when used 
1e7b				push af 
1e7b				ld a,(hl) 
1e7b				cp DS_TYPE_STR 
1e7b				jp nz, type_faultn   
1e7b				pop af 
1e7b				endm 
1e7b			 
1e7b			FORTH_ERR_TOS_NOTNUM: macro 
1e7b				push af 
1e7b				ld a,(hl) 
1e7b				cp DS_TYPE_INUM 
1e7b				jp nz, type_faultn   
1e7b				pop af 
1e7b				endm 
1e7b			 
1e7b			 
1e7b			; increase data stack pointer and save hl to it 
1e7b				 
1e7b			FORTH_DSP_NEXT: macro 
1e7b				call macro_forth_dsp_next 
1e7b				endm 
1e7b			 
1e7b			 
1e7b			macro_forth_dsp_next: 
1e7b				if DEBUG_FORTH_STACK_GUARD 
1e7b cd 3f 66				call check_stacks 
1e7e				endif 
1e7e e5				push hl 
1e7f d5				push de 
1e80 eb				ex de,hl 
1e81 2a b2 fb			ld hl,(cli_data_sp) 
1e84 23				inc hl 
1e85 23				inc hl 
1e86			 
1e86			; PARSEV5 
1e86 23				inc hl 
1e87 22 b2 fb			ld (cli_data_sp),hl 
1e8a 73				ld (hl), e 
1e8b 23				inc hl 
1e8c 72				ld (hl), d 
1e8d d1				pop de 
1e8e e1				pop hl 
1e8f				if DEBUG_FORTH_STACK_GUARD 
1e8f cd 3f 66				call check_stacks 
1e92				endif 
1e92 c9				ret 
1e93			 
1e93			 
1e93			; increase ret stack pointer and save hl to it 
1e93				 
1e93			FORTH_RSP_NEXT: macro 
1e93				call macro_forth_rsp_next 
1e93				endm 
1e93			 
1e93			macro_forth_rsp_next: 
1e93				if DEBUG_FORTH_STACK_GUARD 
1e93 cd 3f 66				call check_stacks 
1e96				endif 
1e96 e5				push hl 
1e97 d5				push de 
1e98 eb				ex de,hl 
1e99 2a b6 fb			ld hl,(cli_ret_sp) 
1e9c 23				inc hl 
1e9d 23				inc hl 
1e9e 22 b6 fb			ld (cli_ret_sp),hl 
1ea1 73				ld (hl), e 
1ea2 23				inc hl 
1ea3 72				ld (hl), d 
1ea4 d1				pop de 
1ea5 e1				pop hl 
1ea6				if DEBUG_FORTH_STACK_GUARD 
1ea6 cd 3f 66				call check_stacks 
1ea9				endif 
1ea9 c9				ret 
1eaa			 
1eaa			; get current ret stack pointer and save to hl  
1eaa				 
1eaa			FORTH_RSP_TOS: macro 
1eaa				call macro_forth_rsp_tos 
1eaa				endm 
1eaa			 
1eaa			macro_forth_rsp_tos: 
1eaa				;push de 
1eaa 2a b6 fb			ld hl,(cli_ret_sp) 
1ead cd e5 1e			call loadhlptrtohl 
1eb0				;ld e, (hl) 
1eb0				;inc hl 
1eb0				;ld d, (hl) 
1eb0				;ex de, hl 
1eb0					if DEBUG_FORTH_WORDS 
1eb0			;			DMARK "RST" 
1eb0						CALLMONITOR 
1eb0 cd 78 18			call break_point_state  
1eb3				endm  
# End of macro CALLMONITOR
1eb3					endif 
1eb3				;pop de 
1eb3 c9				ret 
1eb4			 
1eb4			; pop ret stack pointer 
1eb4				 
1eb4			FORTH_RSP_POP: macro 
1eb4				call macro_forth_rsp_pop 
1eb4				endm 
1eb4			 
1eb4			 
1eb4			macro_forth_rsp_pop: 
1eb4				if DEBUG_FORTH_STACK_GUARD 
1eb4			;		DMARK "RPP" 
1eb4 cd 3f 66				call check_stacks 
1eb7					FORTH_CHK_RSP_UNDER 
1eb7 e5				push hl 
1eb8 d5				push de 
1eb9 2a b6 fb			ld hl,(cli_ret_sp) 
1ebc 11 70 fb			ld de, cli_ret_stack 
1ebf cd 19 0f			call cmp16 
1ec2 da 53 67			jp c, fault_rsp_under 
1ec5 d1				pop de 
1ec6 e1				pop hl 
1ec7				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ec7				endif 
1ec7 e5				push hl 
1ec8 2a b6 fb			ld hl,(cli_ret_sp) 
1ecb			 
1ecb			 
1ecb				if FORTH_ENABLE_FREE 
1ecb			 
1ecb					; get pointer 
1ecb			 
1ecb					push de 
1ecb					push hl 
1ecb			 
1ecb					ld e, (hl) 
1ecb					inc hl 
1ecb					ld d, (hl) 
1ecb			 
1ecb					ex de, hl 
1ecb					call free 
1ecb			 
1ecb					pop hl 
1ecb					pop de 
1ecb			 
1ecb			 
1ecb				endif 
1ecb			 
1ecb			 
1ecb 2b				dec hl 
1ecc 2b				dec hl 
1ecd 22 b6 fb			ld (cli_ret_sp), hl 
1ed0				; do stack underflow checks 
1ed0 e1				pop hl 
1ed1				if DEBUG_FORTH_STACK_GUARD 
1ed1 cd 3f 66				call check_stacks 
1ed4					FORTH_CHK_RSP_UNDER 
1ed4 e5				push hl 
1ed5 d5				push de 
1ed6 2a b6 fb			ld hl,(cli_ret_sp) 
1ed9 11 70 fb			ld de, cli_ret_stack 
1edc cd 19 0f			call cmp16 
1edf da 53 67			jp c, fault_rsp_under 
1ee2 d1				pop de 
1ee3 e1				pop hl 
1ee4				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ee4				endif 
1ee4 c9				ret 
1ee5			 
1ee5			 
1ee5			 
1ee5			; routine to load word pointed to by hl into hl 
1ee5			 
1ee5			loadhlptrtohl: 
1ee5			 
1ee5 d5				push de 
1ee6 5e				ld e, (hl) 
1ee7 23				inc hl 
1ee8 56				ld d, (hl) 
1ee9 eb				ex de, hl 
1eea d1				pop de 
1eeb			 
1eeb c9				ret 
1eec			 
1eec			 
1eec			 
1eec			 
1eec			 
1eec			; push a number held in HL onto the data stack 
1eec			; entry point for pushing a value when already in hl used in function above 
1eec			 
1eec			forth_push_numhl: 
1eec			 
1eec e5				push hl    ; save value to push 
1eed			 
1eed			if DEBUG_FORTH_PUSH 
1eed				; see if disabled 
1eed			 
1eed			 
1eed f5				push af 
1eee 3a 76 f3			ld a, (os_view_disable) 
1ef1 fe 2a			cp '*' 
1ef3 28 34			jr z, .pskip2 
1ef5 e5				push hl 
1ef6 e5			push hl 
1ef7 cd c7 0c			call clear_display 
1efa e1			pop hl 
1efb 7c				ld a,h 
1efc 21 8a f6			ld hl, os_word_scratch 
1eff cd fc 11			call hexout 
1f02 e1				pop hl 
1f03 7d				ld a,l 
1f04 21 8c f6			ld hl, os_word_scratch+2 
1f07 cd fc 11			call hexout 
1f0a			 
1f0a 21 8e f6			ld hl, os_word_scratch+4 
1f0d 3e 00			ld a,0 
1f0f 77				ld (hl),a 
1f10 11 8a f6			ld de,os_word_scratch 
1f13 3e 14				ld a, display_row_2 
1f15 cd da 0c				call str_at_display 
1f18 11 d5 54			ld de, .push_num 
1f1b 3e 00			ld a, display_row_1 
1f1d			 
1f1d cd da 0c				call str_at_display 
1f20			 
1f20			 
1f20 cd ea 0c			call update_display 
1f23 cd 44 0c			call delay1s 
1f26 cd 44 0c			call delay1s 
1f29			.pskip2:  
1f29			 
1f29 f1				pop af 
1f2a			endif	 
1f2a			 
1f2a			 
1f2a				FORTH_DSP_NEXT 
1f2a cd 7b 1e			call macro_forth_dsp_next 
1f2d				endm 
# End of macro FORTH_DSP_NEXT
1f2d			 
1f2d 2a b2 fb			ld hl, (cli_data_sp) 
1f30			 
1f30				; save item type 
1f30 3e 02			ld a,  DS_TYPE_INUM 
1f32 77				ld (hl), a 
1f33 23				inc hl 
1f34			 
1f34				; get word off stack 
1f34 d1				pop de 
1f35 7b				ld a,e 
1f36 77				ld (hl), a 
1f37 23				inc hl 
1f38 7a				ld a,d 
1f39 77				ld (hl), a 
1f3a			 
1f3a			if DEBUG_FORTH_PUSH 
1f3a 2b				dec hl 
1f3b 2b				dec hl 
1f3c 2b				dec hl 
1f3d						DMARK "PH5" 
1f3d f5				push af  
1f3e 3a 52 1f			ld a, (.dmark)  
1f41 32 b4 fe			ld (debug_mark),a  
1f44 3a 53 1f			ld a, (.dmark+1)  
1f47 32 b5 fe			ld (debug_mark+1),a  
1f4a 3a 54 1f			ld a, (.dmark+2)  
1f4d 32 b6 fe			ld (debug_mark+2),a  
1f50 18 03			jr .pastdmark  
1f52 ..			.dmark: db "PH5"  
1f55 f1			.pastdmark: pop af  
1f56			endm  
# End of macro DMARK
1f56				CALLMONITOR 
1f56 cd 78 18			call break_point_state  
1f59				endm  
# End of macro CALLMONITOR
1f59			endif	 
1f59			 
1f59 c9				ret 
1f5a			 
1f5a			 
1f5a			; Push a string to stack pointed to by hl 
1f5a			 
1f5a			forth_push_str: 
1f5a			 
1f5a			if DEBUG_FORTH_PUSH 
1f5a						DMARK "PSQ" 
1f5a f5				push af  
1f5b 3a 6f 1f			ld a, (.dmark)  
1f5e 32 b4 fe			ld (debug_mark),a  
1f61 3a 70 1f			ld a, (.dmark+1)  
1f64 32 b5 fe			ld (debug_mark+1),a  
1f67 3a 71 1f			ld a, (.dmark+2)  
1f6a 32 b6 fe			ld (debug_mark+2),a  
1f6d 18 03			jr .pastdmark  
1f6f ..			.dmark: db "PSQ"  
1f72 f1			.pastdmark: pop af  
1f73			endm  
# End of macro DMARK
1f73				CALLMONITOR 
1f73 cd 78 18			call break_point_state  
1f76				endm  
# End of macro CALLMONITOR
1f76			endif	 
1f76			    
1f76 e5				push hl 
1f77 e5				push hl 
1f78			 
1f78			;	ld a, 0   ; find end of string 
1f78 cd 59 13			call strlenz 
1f7b			if DEBUG_FORTH_PUSH 
1f7b						DMARK "PQ2" 
1f7b f5				push af  
1f7c 3a 90 1f			ld a, (.dmark)  
1f7f 32 b4 fe			ld (debug_mark),a  
1f82 3a 91 1f			ld a, (.dmark+1)  
1f85 32 b5 fe			ld (debug_mark+1),a  
1f88 3a 92 1f			ld a, (.dmark+2)  
1f8b 32 b6 fe			ld (debug_mark+2),a  
1f8e 18 03			jr .pastdmark  
1f90 ..			.dmark: db "PQ2"  
1f93 f1			.pastdmark: pop af  
1f94			endm  
# End of macro DMARK
1f94				CALLMONITOR 
1f94 cd 78 18			call break_point_state  
1f97				endm  
# End of macro CALLMONITOR
1f97			endif	 
1f97 eb				ex de, hl 
1f98 e1				pop hl   ; get ptr to start of string 
1f99			if DEBUG_FORTH_PUSH 
1f99						DMARK "PQ3" 
1f99 f5				push af  
1f9a 3a ae 1f			ld a, (.dmark)  
1f9d 32 b4 fe			ld (debug_mark),a  
1fa0 3a af 1f			ld a, (.dmark+1)  
1fa3 32 b5 fe			ld (debug_mark+1),a  
1fa6 3a b0 1f			ld a, (.dmark+2)  
1fa9 32 b6 fe			ld (debug_mark+2),a  
1fac 18 03			jr .pastdmark  
1fae ..			.dmark: db "PQ3"  
1fb1 f1			.pastdmark: pop af  
1fb2			endm  
# End of macro DMARK
1fb2				CALLMONITOR 
1fb2 cd 78 18			call break_point_state  
1fb5				endm  
# End of macro CALLMONITOR
1fb5			endif	 
1fb5 19				add hl,de 
1fb6			if DEBUG_FORTH_PUSH 
1fb6						DMARK "PQE" 
1fb6 f5				push af  
1fb7 3a cb 1f			ld a, (.dmark)  
1fba 32 b4 fe			ld (debug_mark),a  
1fbd 3a cc 1f			ld a, (.dmark+1)  
1fc0 32 b5 fe			ld (debug_mark+1),a  
1fc3 3a cd 1f			ld a, (.dmark+2)  
1fc6 32 b6 fe			ld (debug_mark+2),a  
1fc9 18 03			jr .pastdmark  
1fcb ..			.dmark: db "PQE"  
1fce f1			.pastdmark: pop af  
1fcf			endm  
# End of macro DMARK
1fcf				CALLMONITOR 
1fcf cd 78 18			call break_point_state  
1fd2				endm  
# End of macro CALLMONITOR
1fd2			endif	 
1fd2			 
1fd2 2b				dec hl    ; see if there is an optional trailing double quote 
1fd3 7e				ld a,(hl) 
1fd4 fe 22			cp '"' 
1fd6 20 03			jr nz, .strnoq 
1fd8 3e 00			ld a, 0      ; get rid of double quote 
1fda 77				ld (hl), a 
1fdb 23			.strnoq: inc hl 
1fdc			 
1fdc 3e 00			ld a, 0 
1fde 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1fdf			 
1fdf 13				inc de ; add one for the type string 
1fe0 13				inc de ; add one for null term??? 
1fe1			 
1fe1				; tos is get string pointer again 
1fe1				; de contains space to allocate 
1fe1				 
1fe1 d5				push de 
1fe2			 
1fe2 eb				ex de, hl 
1fe3			 
1fe3				;push af 
1fe3			 
1fe3			if DEBUG_FORTH_PUSH 
1fe3						DMARK "PHm" 
1fe3 f5				push af  
1fe4 3a f8 1f			ld a, (.dmark)  
1fe7 32 b4 fe			ld (debug_mark),a  
1fea 3a f9 1f			ld a, (.dmark+1)  
1fed 32 b5 fe			ld (debug_mark+1),a  
1ff0 3a fa 1f			ld a, (.dmark+2)  
1ff3 32 b6 fe			ld (debug_mark+2),a  
1ff6 18 03			jr .pastdmark  
1ff8 ..			.dmark: db "PHm"  
1ffb f1			.pastdmark: pop af  
1ffc			endm  
# End of macro DMARK
1ffc				CALLMONITOR 
1ffc cd 78 18			call break_point_state  
1fff				endm  
# End of macro CALLMONITOR
1fff			endif	 
1fff cd c2 13			call malloc	; on ret hl now contains allocated memory 
2002				if DEBUG_FORTH_MALLOC_GUARD 
2002 cc 2d 55				call z,malloc_error 
2005				endif 
2005			 
2005				 
2005 c1				pop bc    ; get length 
2006 d1				pop de   ;  get string start    
2007			 
2007				; hl has destination from malloc 
2007			 
2007 eb				ex de, hl    ; prep for ldir 
2008			 
2008 d5				push de   ; save malloc area for DSP later 
2009				;push hl   ; save malloc area for DSP later 
2009			 
2009			if DEBUG_FORTH_PUSH 
2009						DMARK "PHc" 
2009 f5				push af  
200a 3a 1e 20			ld a, (.dmark)  
200d 32 b4 fe			ld (debug_mark),a  
2010 3a 1f 20			ld a, (.dmark+1)  
2013 32 b5 fe			ld (debug_mark+1),a  
2016 3a 20 20			ld a, (.dmark+2)  
2019 32 b6 fe			ld (debug_mark+2),a  
201c 18 03			jr .pastdmark  
201e ..			.dmark: db "PHc"  
2021 f1			.pastdmark: pop af  
2022			endm  
# End of macro DMARK
2022				CALLMONITOR 
2022 cd 78 18			call break_point_state  
2025				endm  
# End of macro CALLMONITOR
2025			endif	 
2025			 
2025			 
2025 ed b0			ldir 
2027			 
2027			 
2027				; push malloc to data stack     macro?????  
2027			 
2027				FORTH_DSP_NEXT 
2027 cd 7b 1e			call macro_forth_dsp_next 
202a				endm 
# End of macro FORTH_DSP_NEXT
202a			 
202a				; save value and type 
202a			 
202a 2a b2 fb			ld hl, (cli_data_sp) 
202d			 
202d				; save item type 
202d 3e 01			ld a,  DS_TYPE_STR 
202f 77				ld (hl), a 
2030 23				inc hl 
2031			 
2031				; get malloc word off stack 
2031 d1				pop de 
2032 73				ld (hl), e 
2033 23				inc hl 
2034 72				ld (hl), d 
2035			 
2035			 
2035			 
2035			if DEBUG_FORTH_PUSH 
2035 2a b2 fb			ld hl, (cli_data_sp) 
2038						DMARK "PHS" 
2038 f5				push af  
2039 3a 4d 20			ld a, (.dmark)  
203c 32 b4 fe			ld (debug_mark),a  
203f 3a 4e 20			ld a, (.dmark+1)  
2042 32 b5 fe			ld (debug_mark+1),a  
2045 3a 4f 20			ld a, (.dmark+2)  
2048 32 b6 fe			ld (debug_mark+2),a  
204b 18 03			jr .pastdmark  
204d ..			.dmark: db "PHS"  
2050 f1			.pastdmark: pop af  
2051			endm  
# End of macro DMARK
2051				CALLMONITOR 
2051 cd 78 18			call break_point_state  
2054				endm  
# End of macro CALLMONITOR
2054			;	ex de,hl 
2054			endif	 
2054				; in case of spaces, skip the ptr past the copied string 
2054				;pop af 
2054				;ld (cli_origptr),hl 
2054			 
2054 c9				ret 
2055			 
2055			 
2055			 
2055			; TODO ascii push input onto stack given hl to start of input 
2055			 
2055			; identify type 
2055			; if starts with a " then a string 
2055			; otherwise it is a number 
2055			;  
2055			; if a string 
2055			;     scan for ending " to get length of string to malloc for + 1 
2055			;     malloc 
2055			;     put pointer to string on stack first byte flags as string 
2055			; 
2055			; else a number 
2055			;    look for number format identifier 
2055			;    $xx hex 
2055			;    %xxxxx bin 
2055			;    xxxxx decimal 
2055			;    convert number to 16bit word.  
2055			;    malloc word + 1 with flag to identiy as num 
2055			;    put pointer to number on stack 
2055			;   
2055			;  
2055			  
2055			forth_apush: 
2055				; kernel push 
2055			 
2055			if DEBUG_FORTH_PUSH 
2055						DMARK "PSH" 
2055 f5				push af  
2056 3a 6a 20			ld a, (.dmark)  
2059 32 b4 fe			ld (debug_mark),a  
205c 3a 6b 20			ld a, (.dmark+1)  
205f 32 b5 fe			ld (debug_mark+1),a  
2062 3a 6c 20			ld a, (.dmark+2)  
2065 32 b6 fe			ld (debug_mark+2),a  
2068 18 03			jr .pastdmark  
206a ..			.dmark: db "PSH"  
206d f1			.pastdmark: pop af  
206e			endm  
# End of macro DMARK
206e				CALLMONITOR 
206e cd 78 18			call break_point_state  
2071				endm  
# End of macro CALLMONITOR
2071			endif	 
2071				; identify input type 
2071			 
2071 7e				ld a,(hl) 
2072 fe 22			cp '"' 
2074 28 0a			jr z, .fapstr 
2076 fe 24			cp '$' 
2078 ca a0 20			jp z, .faphex 
207b fe 25			cp '%' 
207d ca 88 20			jp z, .fapbin 
2080			;	cp 'b' 
2080			;	jp z, .fabin 
2080				; else decimal 
2080			 
2080				; TODO do decimal conversion 
2080				; decimal is stored as a 16bit word 
2080			 
2080				; by default everything is a string if type is not detected 
2080			.fapstr: ; 
2080 fe 22			cp '"' 
2082 20 01			jr nz, .strnoqu 
2084 23				inc hl 
2085			.strnoqu: 
2085 c3 5a 1f			jp forth_push_str 
2088			 
2088			 
2088			 
2088			.fapbin:    ; push a binary string.  
2088 11 00 00			ld de, 0   ; hold a 16bit value 
208b			 
208b 23			.fapbinshift:	inc hl  
208c 7e				ld a,(hl) 
208d fe 00			cp 0     ; done scanning  
208f 28 0b			jr z, .fapbdone  	; got it in HL so push  
2091			 
2091				; left shift de 
2091 eb				ex de, hl	 
2092 29				add hl, hl 
2093			 
2093				; is 1 
2093 fe 31			cp '1' 
2095 20 02			jr nz, .binzero 
2097 cb 4d			bit 1, l 
2099			.binzero: 
2099 eb				ex de, hl	 ; save current de 
209a 18 ef			jr .fapbinshift 
209c			 
209c			.fapbdone: 
209c eb				ex de, hl 
209d c3 ec 1e			jp forth_push_numhl 
20a0			 
20a0			 
20a0			.faphex:   ; hex is always stored as a 16bit word 
20a0				; skip number prefix 
20a0 23				inc hl 
20a1				; turn ascii into number 
20a1 cd b2 12			call get_word_hl	; ret 16bit word in hl 
20a4			 
20a4 c3 ec 1e			jp forth_push_numhl 
20a7			 
20a7 00				 nop 
20a8			 
20a8			.fabin:   ; TODO bin conversion 
20a8			 
20a8			 
20a8 c9				ret 
20a9			 
20a9			 
20a9			; get either a string ptr or a 16bit word from the data stack 
20a9			 
20a9			FORTH_DSP: macro 
20a9				call macro_forth_dsp 
20a9				endm 
20a9			 
20a9			macro_forth_dsp: 
20a9				; data stack pointer points to current word on tos 
20a9			 
20a9 2a b2 fb			ld hl,(cli_data_sp) 
20ac			 
20ac				if DEBUG_FORTH_PUSH 
20ac						DMARK "DSP" 
20ac f5				push af  
20ad 3a c1 20			ld a, (.dmark)  
20b0 32 b4 fe			ld (debug_mark),a  
20b3 3a c2 20			ld a, (.dmark+1)  
20b6 32 b5 fe			ld (debug_mark+1),a  
20b9 3a c3 20			ld a, (.dmark+2)  
20bc 32 b6 fe			ld (debug_mark+2),a  
20bf 18 03			jr .pastdmark  
20c1 ..			.dmark: db "DSP"  
20c4 f1			.pastdmark: pop af  
20c5			endm  
# End of macro DMARK
20c5			 
20c5 cd 62 55				call display_data_sp 
20c8				;call break_point_state 
20c8				;rst 030h 
20c8				CALLMONITOR 
20c8 cd 78 18			call break_point_state  
20cb				endm  
# End of macro CALLMONITOR
20cb				endif 
20cb			 
20cb c9				ret 
20cc			 
20cc			; return hl to start of value on stack 
20cc			 
20cc			FORTH_DSP_VALUE: macro 
20cc				call macro_forth_dsp_value 
20cc				endm 
20cc			 
20cc			macro_forth_dsp_value: 
20cc			 
20cc				FORTH_DSP 
20cc cd a9 20			call macro_forth_dsp 
20cf				endm 
# End of macro FORTH_DSP
20cf			 
20cf d5				push de 
20d0			 
20d0 23				inc hl ; skip type 
20d1			 
20d1 5e				ld e, (hl) 
20d2 23				inc hl 
20d3 56				ld d, (hl) 
20d4 eb				ex de,hl  
20d5			 
20d5 d1				pop de 
20d6			 
20d6 c9				ret 
20d7			 
20d7			; return hl to start of value to second item on stack 
20d7			 
20d7			FORTH_DSP_VALUEM1: macro 
20d7				call macro_forth_dsp_value_m1 
20d7				endm 
20d7			 
20d7			macro_forth_dsp_value_m1: 
20d7			 
20d7				FORTH_DSP 
20d7 cd a9 20			call macro_forth_dsp 
20da				endm 
# End of macro FORTH_DSP
20da			 
20da 2b				dec hl 
20db 2b				dec hl 
20dc			;	dec hl 
20dc			 
20dc d5				push de 
20dd			 
20dd 5e				ld e, (hl) 
20de 23				inc hl 
20df 56				ld d, (hl) 
20e0 eb				ex de,hl  
20e1			 
20e1 d1				pop de 
20e2			 
20e2 c9				ret 
20e3			 
20e3				 
20e3			 
20e3			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
20e3			 
20e3			FORTH_DSP_POP: macro 
20e3				call macro_forth_dsp_pop 
20e3				endm 
20e3			 
20e3			 
20e3			; get the tos data type 
20e3			 
20e3			FORTH_DSP_TYPE:   macro 
20e3			 
20e3				;FORTH_DSP_VALUE 
20e3				FORTH_DSP 
20e3				 
20e3				; hl points to value 
20e3				; check type 
20e3			 
20e3				ld a,(hl) 
20e3			 
20e3				endm 
20e3			 
20e3			; load the tos value into hl 
20e3			 
20e3			 
20e3			FORTH_DSP_VALUEHL:  macro 
20e3				call macro_dsp_valuehl 
20e3				endm 
20e3			 
20e3			 
20e3			 
20e3			macro_dsp_valuehl: 
20e3				FORTH_DSP_VALUE 
20e3 cd cc 20			call macro_forth_dsp_value 
20e6				endm 
# End of macro FORTH_DSP_VALUE
20e6			 
20e6				;FORTH_ERR_TOS_NOTNUM 
20e6			 
20e6				;inc hl   ; skip type id 
20e6			 
20e6			;	push de 
20e6			; 
20e6			;	ld e, (hl) 
20e6			;	inc hl 
20e6			;	ld d, (hl) 
20e6			;	ex de,hl  
20e6			 
20e6			;	pop de 
20e6			 
20e6				if DEBUG_FORTH_PUSH 
20e6						DMARK "DVL" 
20e6 f5				push af  
20e7 3a fb 20			ld a, (.dmark)  
20ea 32 b4 fe			ld (debug_mark),a  
20ed 3a fc 20			ld a, (.dmark+1)  
20f0 32 b5 fe			ld (debug_mark+1),a  
20f3 3a fd 20			ld a, (.dmark+2)  
20f6 32 b6 fe			ld (debug_mark+2),a  
20f9 18 03			jr .pastdmark  
20fb ..			.dmark: db "DVL"  
20fe f1			.pastdmark: pop af  
20ff			endm  
# End of macro DMARK
20ff				CALLMONITOR 
20ff cd 78 18			call break_point_state  
2102				endm  
# End of macro CALLMONITOR
2102				endif 
2102 c9				ret 
2103			 
2103			forth_apushstrhl:      
2103				; push of string requires use of cli_origptr 
2103				; bodge use 
2103			 
2103				; get current cli_origptr, save, update with temp pointer  
2103 ed 5b ce fb		ld de, (cli_origptr) 
2107 22 ce fb			ld (cli_origptr), hl 
210a d5				push de 
210b cd 55 20			call forth_apush 
210e d1				pop de 
210f ed 53 ce fb		ld (cli_origptr), de 
2113 c9			        ret	 
2114			 
2114			 
2114			; increase loop stack pointer and save hl to it 
2114				 
2114			FORTH_LOOP_NEXT: macro 
2114				call macro_forth_loop_next 
2114				;nop 
2114				endm 
2114			 
2114			macro_forth_loop_next: 
2114				if DEBUG_FORTH_STACK_GUARD 
2114 cd 3f 66				call check_stacks 
2117				endif 
2117 e5				push hl 
2118 d5				push de 
2119 eb				ex de,hl 
211a 2a b4 fb			ld hl,(cli_loop_sp) 
211d 23				inc hl 
211e 23				inc hl 
211f					if DEBUG_FORTH_WORDS 
211f						DMARK "LNX" 
211f f5				push af  
2120 3a 34 21			ld a, (.dmark)  
2123 32 b4 fe			ld (debug_mark),a  
2126 3a 35 21			ld a, (.dmark+1)  
2129 32 b5 fe			ld (debug_mark+1),a  
212c 3a 36 21			ld a, (.dmark+2)  
212f 32 b6 fe			ld (debug_mark+2),a  
2132 18 03			jr .pastdmark  
2134 ..			.dmark: db "LNX"  
2137 f1			.pastdmark: pop af  
2138			endm  
# End of macro DMARK
2138						CALLMONITOR 
2138 cd 78 18			call break_point_state  
213b				endm  
# End of macro CALLMONITOR
213b					endif 
213b 22 b4 fb			ld (cli_loop_sp),hl 
213e 73				ld (hl), e 
213f 23				inc hl 
2140 72				ld (hl), d 
2141 d1				pop de    ; been reversed so save a swap on restore 
2142 e1				pop hl 
2143				if DEBUG_FORTH_STACK_GUARD 
2143 cd 3f 66				call check_stacks 
2146				endif 
2146 c9				ret 
2147			 
2147			; get current ret stack pointer and save to hl  
2147				 
2147			FORTH_LOOP_TOS: macro 
2147				call macro_forth_loop_tos 
2147				endm 
2147			 
2147			macro_forth_loop_tos: 
2147 d5				push de 
2148 2a b4 fb			ld hl,(cli_loop_sp) 
214b 5e				ld e, (hl) 
214c 23				inc hl 
214d 56				ld d, (hl) 
214e eb				ex de, hl 
214f d1				pop de 
2150 c9				ret 
2151			 
2151			; pop loop stack pointer 
2151				 
2151			FORTH_LOOP_POP: macro 
2151				call macro_forth_loop_pop 
2151				endm 
2151			 
2151			 
2151			macro_forth_loop_pop: 
2151				if DEBUG_FORTH_STACK_GUARD 
2151					DMARK "LPP" 
2151 f5				push af  
2152 3a 66 21			ld a, (.dmark)  
2155 32 b4 fe			ld (debug_mark),a  
2158 3a 67 21			ld a, (.dmark+1)  
215b 32 b5 fe			ld (debug_mark+1),a  
215e 3a 68 21			ld a, (.dmark+2)  
2161 32 b6 fe			ld (debug_mark+2),a  
2164 18 03			jr .pastdmark  
2166 ..			.dmark: db "LPP"  
2169 f1			.pastdmark: pop af  
216a			endm  
# End of macro DMARK
216a cd 3f 66				call check_stacks 
216d					FORTH_CHK_LOOP_UNDER 
216d e5				push hl 
216e d5				push de 
216f 2a b4 fb			ld hl,(cli_loop_sp) 
2172 11 ee fa			ld de, cli_loop_stack 
2175 cd 19 0f			call cmp16 
2178 da 59 67			jp c, fault_loop_under 
217b d1				pop de 
217c e1				pop hl 
217d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
217d				endif 
217d e5				push hl 
217e 2a b4 fb			ld hl,(cli_loop_sp) 
2181 2b				dec hl 
2182 2b				dec hl 
2183 22 b4 fb			ld (cli_loop_sp), hl 
2186				; TODO do stack underflow checks 
2186 e1				pop hl 
2187				if DEBUG_FORTH_STACK_GUARD 
2187 cd 3f 66				call check_stacks 
218a					FORTH_CHK_LOOP_UNDER 
218a e5				push hl 
218b d5				push de 
218c 2a b4 fb			ld hl,(cli_loop_sp) 
218f 11 ee fa			ld de, cli_loop_stack 
2192 cd 19 0f			call cmp16 
2195 da 59 67			jp c, fault_loop_under 
2198 d1				pop de 
2199 e1				pop hl 
219a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
219a				endif 
219a c9				ret 
219b			 
219b			macro_forth_dsp_pop: 
219b			 
219b e5				push hl 
219c			 
219c				; release malloc data 
219c			 
219c				if DEBUG_FORTH_STACK_GUARD 
219c cd 3f 66				call check_stacks 
219f					FORTH_CHK_DSP_UNDER 
219f e5				push hl 
21a0 d5				push de 
21a1 2a b2 fb			ld hl,(cli_data_sp) 
21a4 11 ec f8			ld de, cli_data_stack 
21a7 cd 19 0f			call cmp16 
21aa da 4d 67			jp c, fault_dsp_under 
21ad d1				pop de 
21ae e1				pop hl 
21af				endm 
# End of macro FORTH_CHK_DSP_UNDER
21af				endif 
21af				;ld hl,(cli_data_sp) 
21af			if DEBUG_FORTH_DOT 
21af				DMARK "DPP" 
21af				CALLMONITOR 
21af			endif	 
21af			 
21af			 
21af			if FORTH_ENABLE_DSPPOPFREE 
21af			 
21af				FORTH_DSP 
21af cd a9 20			call macro_forth_dsp 
21b2				endm 
# End of macro FORTH_DSP
21b2			 
21b2 7e				ld a, (hl) 
21b3 fe 01			cp DS_TYPE_STR 
21b5 20 07			jr nz, .skippopfree 
21b7			 
21b7				FORTH_DSP_VALUEHL 
21b7 cd e3 20			call macro_dsp_valuehl 
21ba				endm 
# End of macro FORTH_DSP_VALUEHL
21ba 00				nop 
21bb			if DEBUG_FORTH_DOT 
21bb				DMARK "DPf" 
21bb				CALLMONITOR 
21bb			endif	 
21bb cd 8c 14			call free 
21be			.skippopfree: 
21be				 
21be			 
21be			endif 
21be			 
21be			if DEBUG_FORTH_DOT_KEY 
21be				DMARK "DP2" 
21be				CALLMONITOR 
21be			endif	 
21be			 
21be				; move pointer down 
21be			 
21be 2a b2 fb			ld hl,(cli_data_sp) 
21c1 2b				dec hl 
21c2 2b				dec hl 
21c3			; PARSEV5 
21c3 2b				dec hl 
21c4 22 b2 fb			ld (cli_data_sp), hl 
21c7			 
21c7				if DEBUG_FORTH_STACK_GUARD 
21c7 cd 3f 66				call check_stacks 
21ca					FORTH_CHK_DSP_UNDER 
21ca e5				push hl 
21cb d5				push de 
21cc 2a b2 fb			ld hl,(cli_data_sp) 
21cf 11 ec f8			ld de, cli_data_stack 
21d2 cd 19 0f			call cmp16 
21d5 da 4d 67			jp c, fault_dsp_under 
21d8 d1				pop de 
21d9 e1				pop hl 
21da				endm 
# End of macro FORTH_CHK_DSP_UNDER
21da				endif 
21da			 
21da e1				pop hl 
21db			 
21db c9				ret 
21dc			 
21dc			getwordathl: 
21dc				; hl points to an address 
21dc				; load hl with the word at that address 
21dc			 
21dc d5				push de 
21dd			 
21dd 5e				ld e, (hl) 
21de 23				inc hl 
21df 56				ld d, (hl) 
21e0 eb				ex de, hl 
21e1			 
21e1 d1				pop de 
21e2 c9				ret 
21e3			 
21e3			 
21e3			 
21e3			 
21e3			 
21e3			; eof 
21e3			 
# End of file forth_stackopsv5.asm
21e3			endif 
21e3			 
21e3			user_word_eol:  
21e3				; hl contains the pointer to where to create a linked list item from the end 
21e3				; of the user dict to continue on at the system word dict 
21e3				 
21e3				; poke the stub of the word list linked list to repoint to rom words 
21e3			 
21e3				; stub format 
21e3				; db   word id 
21e3				; dw    link to next word 
21e3			        ; db char length of token 
21e3				; db string + 0 term 
21e3				; db exec code....  
21e3			 
21e3 3e 00			ld a, WORD_SYS_ROOT     ; root word 
21e5 77				ld (hl), a		; word id 
21e6 23				inc hl 
21e7			 
21e7 11 b2 23			ld de, sysdict 
21ea 73				ld (hl), e		; next word link ie system dict 
21eb 23				inc hl 
21ec 72				ld (hl), d		; next word link ie system dict 
21ed 23				inc hl	 
21ee			 
21ee			;	ld (hl), sysdict		; next word link ie system dict 
21ee			;	inc hl 
21ee			;	inc hl 
21ee			 
21ee			;	inc hl 
21ee			;	inc hl 
21ee			 
21ee 3e 02			ld a, 2			; word length is 0 
21f0 77				ld (hl), a	 
21f1 23				inc hl 
21f2			 
21f2 3e 7e			ld a, '~'			; word length is 0 
21f4 77				ld (hl), a	 
21f5 23				inc hl 
21f6 3e 00			ld a, 0			; save empty word 
21f8 77				ld (hl), a 
21f9			 
21f9 c9				ret 
21fa			 
21fa				 
21fa			 
21fa			forthexec_cleanup: 
21fa				FORTH_RSP_POP 
21fa cd b4 1e			call macro_forth_rsp_pop 
21fd				endm 
# End of macro FORTH_RSP_POP
21fd c9				ret 
21fe			 
21fe			forth_call_hl: 
21fe				; taking hl 
21fe e5				push hl 
21ff c9				ret 
2200			 
2200			; this is called to reset Forth system but keep existing uwords etc 
2200			 
2200			forth_warmstart: 
2200				; setup stack over/under flow checks 
2200				if DEBUG_FORTH_STACK_GUARD 
2200 cd 25 66				call chk_stk_init 
2203				endif 
2203			 
2203				; init stack pointers  - * these stacks go upwards *  
2203 21 70 fb			ld hl, cli_ret_stack 
2206 22 b6 fb			ld (cli_ret_sp), hl	 
2209				; set bottom of stack 
2209 3e 00			ld a,0 
220b 77				ld (hl),a 
220c 23				inc hl 
220d 77				ld (hl),a 
220e			 
220e 21 ec f8			ld hl, cli_data_stack 
2211 22 b2 fb			ld (cli_data_sp), hl	 
2214				; set bottom of stack 
2214 3e 00			ld a,0 
2216 77				ld (hl),a 
2217 23				inc hl 
2218 77				ld (hl),a 
2219			 
2219 21 ee fa			ld hl, cli_loop_stack 
221c 22 b4 fb			ld (cli_loop_sp), hl	 
221f				; set bottom of stack 
221f 3e 00			ld a,0 
2221 77				ld (hl),a 
2222 23				inc hl 
2223 77				ld (hl),a 
2224			 
2224				; init extent of current open file 
2224			 
2224 3e 00			ld a, 0 
2226 32 f9 fb			ld (store_openext), a 
2229			 
2229 c9				ret 
222a			 
222a			 
222a			; Cold Start - this is called to setup the whole Forth system 
222a			 
222a			forth_init: 
222a			 
222a				; setup stack over/under flow checks 
222a			 
222a			;	if DEBUG_FORTH_STACK_GUARD 
222a			;		call chk_stk_init 
222a			;	endif 
222a			 
222a				; enable auto display updates (slow.....) 
222a			 
222a 3e 01			ld a, 1 
222c 32 cc fb			ld (cli_autodisplay), a 
222f			 
222f				; if storage is in use disable long reads for now 
222f 3e 00			ld a, 0 
2231 32 02 fc			ld (store_longread), a 
2234			 
2234			 
2234				; show start up screen 
2234			 
2234 cd c7 0c			call clear_display 
2237			 
2237 3e 00			ld a,0 
2239 32 ee fb			ld (f_cursor_ptr), a 
223c			 
223c				; set start of word list in start of ram - for use when creating user words 
223c			 
223c 21 00 80			ld hl, baseram 
223f 22 82 f6			ld (os_last_new_uword), hl 
2242 cd e3 21			call user_word_eol 
2245				 
2245			;		call display_data_sp 
2245			;		call next_page_prompt 
2245			 
2245			 
2245			 
2245			 
2245 c9				ret 
2246			 
2246 .. 00		.bootforth: db " Forth Kernel Init ",0 
225a			 
225a			; TODO push to stack 
225a			 
225a			;  
225a			 
225a			if FORTH_PARSEV2 
225a			 
225a			 
225a				include "forth_parserv2.asm" 
225a			 
225a			endif 
225a			 
225a			 
225a			; parse cli version 1 
225a			 
225a			if FORTH_PARSEV1 
225a			 
225a			 
225a			 
225a			      include "forth_parserv1.asm" 
225a			endif 
225a				 
225a			if FORTH_PARSEV3 
225a			 
225a			 
225a			 
225a			      include "forth_parserv3.asm" 
225a				include "forth_wordsv3.asm" 
225a			endif 
225a			 
225a			if FORTH_PARSEV4 
225a			 
225a			 
225a			 
225a			      include "forth_parserv4.asm" 
225a				include "forth_wordsv4.asm" 
225a			endif 
225a			 
225a			if FORTH_PARSEV5 
225a			 
225a			 
225a			 
225a			      include "forth_parserv5.asm" 
225a			 
225a			 
225a			; A better parser without using malloc and string copies all over the place.  
225a			; Exec in situ should be faster 
225a			 
225a			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
225a			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
225a			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
225a			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
225a			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
225a			WORD_SYS_END: equ 0   ; Opcode for all user words 
225a			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
225a			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
225a			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
225a			 
225a			; Core word preamble macro 
225a			 
225a			CWHEAD:   macro nxtword opcode lit len opflags 
225a				db WORD_SYS_CORE+opcode             
225a				; internal op code number 
225a				dw nxtword            
225a				; link to next dict word block 
225a				db len + 1 
225a				; literal length of dict word inc zero term 
225a				db lit,0              
225a				; literal dict word 
225a			        ; TODO db opflags        
225a				endm 
225a			 
225a			 
225a			NEXTW: macro  
225a				jp macro_next 
225a				endm 
225a			 
225a			macro_next: 
225a			if DEBUG_FORTH_PARSE_KEY 
225a				DMARK "NXT" 
225a				CALLMONITOR 
225a			endif	 
225a			;	inc hl  ; skip token null term  
225a ed 4b d0 fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
225e ed 5b ce fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2262 2a 86 f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2265			if DEBUG_FORTH_PARSE_KEY 
2265				DMARK "}AA" 
2265				CALLMONITOR 
2265			endif	 
2265 c3 68 23			jp execnext 
2268				;jp exec1 
2268			       
2268			 
2268			 
2268			; Another go at the parser to compile  
2268			 
2268			 
2268			; TODO rework parser to change all of the string words to byte tokens 
2268			; TODO do a search for  
2268			 
2268			; TODO first run normal parser to zero term sections 
2268			; TODO for each word do a token look up to get the op code 
2268			; TODO need some means to flag to the exec that this is a byte code form    
2268			 
2268			 
2268			forthcompile: 
2268			 
2268			; 
2268			; line parse: 
2268			;       parse raw input buffer 
2268			;       tokenise the words 
2268			;       malloc new copy (for looping etc) 
2268			;       copy to malloc + current pc in line to start of string and add line term 
2268			;       save on new rsp 
2268			; 
2268			 
2268			; hl to point to the line to tokenise 
2268			 
2268			;	push hl 
2268 22 86 f6			ld (os_tok_ptr), hl  ; save ptr to string 
226b			 
226b			;	ld a,0		; string term on input 
226b			;	call strlent 
226b			 
226b			;	ld (os_tok_len), hl	 ; save string length 
226b			 
226b			;if DEBUG_FORTH_TOK 
226b			;	ex de,hl		 
226b			;endif 
226b			 
226b			;	pop hl 		; get back string pointer 
226b			 
226b			if DEBUG_FORTH_TOK 
226b						DMARK "TOc" 
226b				CALLMONITOR 
226b			endif 
226b 7e			.cptoken2:    ld a,(hl) 
226c 23				inc hl 
226d fe 7f			cp FORTH_END_BUFFER 
226f 28 29			jr z, .cptokendone2 
2271 fe 00			cp 0 
2273 28 25			jr z, .cptokendone2 
2275 fe 22			cp '"' 
2277 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2279 fe 20			cp ' ' 
227b 20 ee			jr nz,  .cptoken2 
227d			 
227d			; TODO consume comments held between ( and ) 
227d			 
227d				; we have a space so change to zero term for dict match later 
227d 2b				dec hl 
227e 3e 00			ld a,0 
2280 77				ld (hl), a 
2281 23				inc hl 
2282 18 e7			jr .cptoken2 
2284				 
2284			 
2284			.cptokenstr2: 
2284				; skip all white space until either eol (because forgot to term) or end double quote 
2284			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2284				;inc hl ; skip current double quote 
2284 7e				ld a,(hl) 
2285 23				inc hl 
2286 fe 22			cp '"' 
2288 28 e1			jr z, .cptoken2 
228a fe 7f			cp FORTH_END_BUFFER 
228c 28 0c			jr z, .cptokendone2 
228e fe 00			cp 0 
2290 28 08			jr z, .cptokendone2 
2292 fe 20			cp ' ' 
2294 28 02			jr z, .cptmp2 
2296 18 ec			jr .cptokenstr2 
2298			 
2298			.cptmp2:	; we have a space so change to zero term for dict match later 
2298				;dec hl 
2298				;ld a,"-"	; TODO remove this when working 
2298				;ld (hl), a 
2298				;inc hl 
2298 18 ea			jr .cptokenstr2 
229a			 
229a			.cptokendone2: 
229a				;inc hl 
229a 3e 7f			ld a, FORTH_END_BUFFER 
229c 77				ld (hl),a 
229d 23				inc hl 
229e 3e 21			ld a, '!' 
22a0 77				ld (hl),a 
22a1			 
22a1 2a 86 f6			ld hl,(os_tok_ptr) 
22a4			         
22a4			if DEBUG_FORTH_TOK 
22a4						DMARK "Tc1" 
22a4				CALLMONITOR 
22a4			endif 
22a4			 
22a4				; push exec string to top of return stack 
22a4				FORTH_RSP_NEXT 
22a4 cd 93 1e			call macro_forth_rsp_next 
22a7				endm 
# End of macro FORTH_RSP_NEXT
22a7 c9				ret 
22a8			 
22a8			; Another go at the parser need to simplify the process 
22a8			 
22a8			forthparse: 
22a8			 
22a8			; 
22a8			; line parse: 
22a8			;       parse raw input buffer 
22a8			;       tokenise the words 
22a8			;       malloc new copy (for looping etc) 
22a8			;       copy to malloc + current pc in line to start of string and add line term 
22a8			;       save on new rsp 
22a8			; 
22a8			 
22a8			; hl to point to the line to tokenise 
22a8			 
22a8			;	push hl 
22a8 22 86 f6			ld (os_tok_ptr), hl  ; save ptr to string 
22ab			 
22ab			;	ld a,0		; string term on input 
22ab			;	call strlent 
22ab			 
22ab			;	ld (os_tok_len), hl	 ; save string length 
22ab			 
22ab			;if DEBUG_FORTH_TOK 
22ab			;	ex de,hl		 
22ab			;endif 
22ab			 
22ab			;	pop hl 		; get back string pointer 
22ab			 
22ab			if DEBUG_FORTH_TOK 
22ab						DMARK "TOK" 
22ab				CALLMONITOR 
22ab			endif 
22ab 7e			.ptoken2:    ld a,(hl) 
22ac 23				inc hl 
22ad fe 7f			cp FORTH_END_BUFFER 
22af 28 29			jr z, .ptokendone2 
22b1 fe 00			cp 0 
22b3 28 25			jr z, .ptokendone2 
22b5 fe 22			cp '"' 
22b7 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
22b9 fe 20			cp ' ' 
22bb 20 ee			jr nz,  .ptoken2 
22bd			 
22bd			; TODO consume comments held between ( and ) 
22bd			 
22bd				; we have a space so change to zero term for dict match later 
22bd 2b				dec hl 
22be 3e 00			ld a,0 
22c0 77				ld (hl), a 
22c1 23				inc hl 
22c2 18 e7			jr .ptoken2 
22c4				 
22c4			 
22c4			.ptokenstr2: 
22c4				; skip all white space until either eol (because forgot to term) or end double quote 
22c4			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22c4				;inc hl ; skip current double quote 
22c4 7e				ld a,(hl) 
22c5 23				inc hl 
22c6 fe 22			cp '"' 
22c8 28 e1			jr z, .ptoken2 
22ca fe 7f			cp FORTH_END_BUFFER 
22cc 28 0c			jr z, .ptokendone2 
22ce fe 00			cp 0 
22d0 28 08			jr z, .ptokendone2 
22d2 fe 20			cp ' ' 
22d4 28 02			jr z, .ptmp2 
22d6 18 ec			jr .ptokenstr2 
22d8			 
22d8			.ptmp2:	; we have a space so change to zero term for dict match later 
22d8				;dec hl 
22d8				;ld a,"-"	; TODO remove this when working 
22d8				;ld (hl), a 
22d8				;inc hl 
22d8 18 ea			jr .ptokenstr2 
22da			 
22da			.ptokendone2: 
22da				;inc hl 
22da 3e 7f			ld a, FORTH_END_BUFFER 
22dc 77				ld (hl),a 
22dd 23				inc hl 
22de 3e 21			ld a, '!' 
22e0 77				ld (hl),a 
22e1			 
22e1 2a 86 f6			ld hl,(os_tok_ptr) 
22e4			         
22e4			if DEBUG_FORTH_TOK 
22e4						DMARK "TK1" 
22e4				CALLMONITOR 
22e4			endif 
22e4			 
22e4				; push exec string to top of return stack 
22e4				FORTH_RSP_NEXT 
22e4 cd 93 1e			call macro_forth_rsp_next 
22e7				endm 
# End of macro FORTH_RSP_NEXT
22e7 c9				ret 
22e8			 
22e8			; 
22e8			;	; malloc size + buffer pointer + if is loop flag 
22e8			;	ld hl,(os_tok_len) 		 ; get string length 
22e8			; 
22e8			;	ld a,l 
22e8			; 
22e8			;	cp 0			; we dont want to use a null string 
22e8			;	ret z 
22e8			; 
22e8			;;	add 3    ; prefix malloc with buffer for current word ptr 
22e8			; 
22e8			;	add 5     ; TODO when certain not over writing memory remove 
22e8			; 
22e8			;		 
22e8			; 
22e8			;if DEBUG_FORTH_TOK 
22e8			;			DMARK "TKE" 
22e8			;	CALLMONITOR 
22e8			;endif 
22e8			; 
22e8			;	ld l,a 
22e8			;	ld h,0 
22e8			;;	push hl   ; save required space for the copy later 
22e8			;	call malloc 
22e8			;if DEBUG_FORTH_TOK 
22e8			;			DMARK "TKM" 
22e8			;	CALLMONITOR 
22e8			;endif 
22e8			;	if DEBUG_FORTH_MALLOC_GUARD 
22e8			;		push af 
22e8			;		call ishlzero 
22e8			;;		ld a, l 
22e8			;;		add h 
22e8			;;		cp 0 
22e8			;		pop af 
22e8			;		 
22e8			;		call z,malloc_error 
22e8			;	endif 
22e8			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
22e8			; 
22e8			; 
22e8			;if DEBUG_FORTH_TOK 
22e8			;			DMARK "TKR" 
22e8			;	CALLMONITOR 
22e8			;endif 
22e8			; 
22e8			;	FORTH_RSP_NEXT 
22e8			; 
22e8			;	;inc hl	 ; go past current buffer pointer 
22e8			;	;inc hl 
22e8			;	;inc hl   ; and past if loop flag 
22e8			;		; TODO Need to set flag  
22e8			; 
22e8			;	 
22e8			;	 
22e8			;	ex de,hl	; malloc is dest 
22e8			;	ld hl, (os_tok_len) 
22e8			;;	pop bc 
22e8			;	ld c, l                
22e8			;	ld b,0 
22e8			;	ld hl, (os_tok_ptr) 
22e8			; 
22e8			;if DEBUG_FORTH_TOK 
22e8			;			DMARK "TKT" 
22e8			;	CALLMONITOR 
22e8			;endif 
22e8			; 
22e8			;	; do str cpy 
22e8			; 
22e8			;	ldir      ; copy byte in hl to de 
22e8			; 
22e8			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
22e8			; 
22e8			;if DEBUG_FORTH_TOK 
22e8			; 
22e8			;			DMARK "TKY" 
22e8			;	CALLMONITOR 
22e8			;endif 
22e8			;	;ld a,0 
22e8			;	;ld a,FORTH_END_BUFFER 
22e8			;	ex de, hl 
22e8			;	;dec hl			 ; go back over the space delim at the end of word 
22e8			;	;ld (hl),a 
22e8			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
22e8			;	ld a,FORTH_END_BUFFER 
22e8			;	ld (hl),a 
22e8			;	inc hl 
22e8			;	ld a,FORTH_END_BUFFER 
22e8			;	ld (hl),a 
22e8			; 
22e8			;	; init the malloc area data 
22e8			;	; set pc for in current area 
22e8			;	;ld hl, (os_tok_malloc) 
22e8			;	;inc hl 
22e8			;	;inc hl 
22e8			;	;inc hl 
22e8			;	;ex de,hl 
22e8			;	;ld hl, (os_tok_malloc) 
22e8			;	;ld (hl),e 
22e8			;	;inc hl 
22e8			;	;ld (hl),d 
22e8			; 
22e8			; 
22e8			;	ld hl,(os_tok_malloc) 
22e8			;if DEBUG_FORTH_PARSE_KEY 
22e8			;			DMARK "TKU" 
22e8			;	CALLMONITOR 
22e8			;endif 
22e8			; 
22e8			;	ret 
22e8			 
22e8			forthexec: 
22e8			 
22e8			; line exec: 
22e8			; forth parser 
22e8			 
22e8			; 
22e8			;       get current exec line on rsp 
22e8			 
22e8				FORTH_RSP_TOS 
22e8 cd aa 1e			call macro_forth_rsp_tos 
22eb				endm 
# End of macro FORTH_RSP_TOS
22eb			 
22eb			;       restore current pc - hl points to malloc of data 
22eb			 
22eb				;ld e, (hl) 
22eb				;inc hl 
22eb				;ld d, (hl) 
22eb				;ex de,hl 
22eb			 
22eb			 
22eb			exec1: 
22eb 22 86 f6			ld (os_tok_ptr), hl 
22ee			 
22ee				; copy our PC to working vars  
22ee 22 d0 fb			ld (cli_ptr), hl 
22f1 22 ce fb			ld (cli_origptr), hl 
22f4			 
22f4 7e				ld a,(hl) 
22f5 fe 7f			cp FORTH_END_BUFFER 
22f7 c8				ret z 
22f8			 
22f8				; skip any nulls 
22f8			 
22f8 fe 00			cp 0 
22fa 20 03			jr nz, .execword 
22fc 23				inc hl 
22fd 18 ec			jr exec1 
22ff			 
22ff			 
22ff			.execword: 
22ff			 
22ff			 
22ff			 
22ff			if DEBUG_FORTH_PARSE_KEY 
22ff						DMARK "KYQ" 
22ff				CALLMONITOR 
22ff			endif 
22ff			;       while at start of word: 
22ff			; get start of dict (in user area first) 
22ff			 
22ff 21 00 80		ld hl, baseram 
2302			;ld hl, sysdict 
2302 22 d2 fb		ld (cli_nextword),hl 
2305			;           match word at pc 
2305			;           exec word 
2305			;           or push to dsp 
2305			;           forward to next token 
2305			;           if line term pop rsp and exit 
2305			;        
2305			 
2305			if DEBUG_FORTH_PARSE_KEY 
2305						DMARK "KYq" 
2305				CALLMONITOR 
2305			endif 
2305			 
2305			; 
2305			; word comp 
2305			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2305			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2305			;    move to start of word  
2305			;    compare word to cli_token 
2305			 
2305			.execpnword:	; HL at start of a word in the dictionary to check 
2305			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2305			;	ld (cli_ptr), hl 
2305			 
2305 2a d2 fb			ld hl,(cli_nextword) 
2308			 
2308 cd ab 23			call forth_tok_next 
230b			; tok next start here 
230b			;	; TODO skip compiled symbol for now 
230b			;	inc hl 
230b			; 
230b			;	; save pointer to next word 
230b			; 
230b			;	; hl now points to the address of the next word pointer  
230b			;	ld e, (hl) 
230b			;	inc hl 
230b			;	ld d, (hl) 
230b			;	inc l 
230b			; 
230b			;	ex de,hl 
230b			;if DEBUG_FORTH_PARSE_NEXTWORD 
230b			;	push bc 
230b			;	ld bc, (cli_nextword) 
230b			;			DMARK "NXW" 
230b			;	CALLMONITOR 
230b			;	pop bc 
230b			;endif 
230b			; tok next end here 
230b 22 d2 fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
230e eb				ex de, hl 
230f			 
230f			 
230f				; save the pointer of the current token - 1 to check against 
230f				 
230f 22 d6 fb			ld (cli_token), hl   
2312				; TODO maybe remove below save if no debug 
2312				; save token string ptr for any debug later 
2312 23				inc hl  
2313 22 d8 fb			ld (cli_origtoken), hl 
2316 2b				dec hl 
2317				; save pointer to the start of the next dictionay word 
2317 7e				ld a,(hl)   ; get string length 
2318 47				ld b,a 
2319			.execpnwordinc:  
2319 23				inc hl 
231a 10 fd			djnz .execpnwordinc 
231c 22 d4 fb			ld (cli_execword), hl      ; save start of this words code 
231f			 
231f				; now check the word token against the string being parsed 
231f			 
231f 2a d6 fb			ld hl,(cli_token) 
2322 23				inc hl     ; skip string length (use zero term instead to end) 
2323 22 d6 fb			ld (cli_token), hl 
2326			 
2326			if DEBUG_FORTH_PARSE_KEY 
2326						DMARK "KY2" 
2326			endif 
2326			if DEBUG_FORTH_PARSE_EXEC 
2326				; see if disabled 
2326			 
2326				ld a, (os_view_disable) 
2326				cp '*' 
2326				jr z, .skip 
2326			 
2326				push hl 
2326				push hl 
2326				call clear_display 
2326				ld de, .compword 
2326				ld a, display_row_1 
2326				call str_at_display 
2326				pop de 
2326				ld a, display_row_2 
2326				call str_at_display 
2326				ld hl,(cli_ptr) 
2326				ld a,(hl) 
2326			        ld hl, os_word_scratch 
2326				ld (hl),a 
2326				ld a,0 
2326				inc hl 
2326				ld (hl),a 	 
2326				ld de, os_word_scratch 
2326				ld a, display_row_2+10 
2326				call str_at_display 
2326				call update_display 
2326				ld a, 100 
2326				call aDelayInMS 
2326				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2326				call delay250ms 
2326				endif 
2326				pop hl 
2326			.skip:  
2326			endif	 
2326			.execpnchar:    ; compare char between token and string to parse 
2326			 
2326			if DEBUG_FORTH_PARSE_KEY 
2326						DMARK "Ky3" 
2326			endif 
2326			if DEBUG_FORTH_PARSE_EXEC 
2326				; see if disabled 
2326			 
2326				ld a, (os_view_disable) 
2326				cp '*' 
2326				jr z, .skip2 
2326			 
2326			;	call clear_display 
2326			ld hl,(cli_token) 
2326			ld a,(hl) 
2326			ld (os_word_scratch),a 
2326				ld hl,(cli_ptr) 
2326			ld a,(hl) 
2326				ld (os_word_scratch+1),a 
2326				ld a,0 
2326				ld (os_word_scratch+2),a 
2326				ld de,os_word_scratch 
2326				ld a,display_row_4 
2326				call str_at_display 
2326				call update_display 
2326			.skip2:  
2326			endif 
2326 2a d6 fb			ld hl,(cli_token) 
2329 7e				ld a, (hl)	 ; char in word token 
232a 23				inc hl 		; move to next char 
232b 22 d6 fb			ld (cli_token), hl ; and save it 
232e 47				ld b,a 
232f			 
232f 2a d0 fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
2332 7e				ld a,(hl) 
2333 23				inc hl 
2334 22 d0 fb			ld (cli_ptr), hl		; move to next char 
2337 cd 50 13			call toUpper 		; make sure the input string matches case 
233a			 
233a			if DEBUG_FORTH_PARSE 
233a			endif 
233a			 
233a				; input stream end of token is a space so get rid of it 
233a			 
233a			;	cp ' ' 
233a			;	jr nz, .pnskipspace 
233a			; 
233a			;	ld a, 0		; make same term as word token term 
233a			; 
233a			;.pnskipspace: 
233a			 
233a			if DEBUG_FORTH_PARSE_KEY 
233a						DMARK "KY7" 
233a			endif 
233a b8				cp b 
233b c2 51 23			jp nz, .execpnskipword	 ; no match so move to next word 
233e				 
233e			;    if same 
233e			;       scan for string terms 0 for token and 32 for input 
233e			 
233e				 
233e			if DEBUG_FORTH_PARSE_KEY 
233e						DMARK "KY8" 
233e			endif 
233e			 
233e 80				add b			 
233f fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2341							; TODO need to make sure last word in zero term string is accounted for 
2341 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2343			 
2343			 
2343				; at end of both strings so both are exact match 
2343			 
2343			;       skip ptr for next word 
2343			 
2343 2a d0 fb			ld hl,(cli_ptr) 	; at input string term 
2346 23				inc hl			 ; at next char 
2347 22 d0 fb			ld (cli_ptr), hl     ; save for next round of the parser 
234a 22 ce fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
234d				 
234d				 
234d			if DEBUG_FORTH_PARSE_KEY 
234d						DMARK "KY3" 
234d			endif 
234d			 
234d			 
234d			 
234d			;       exec code block 
234d			if DEBUG_FORTH_JP 
234d				call clear_display 
234d				call update_display 
234d				call delay1s 
234d				ld hl, (cli_execword)     ; save for next check if no match on this word 
234d				ld a,h 
234d				ld hl, os_word_scratch 
234d				call hexout 
234d				ld hl, (cli_execword)     ; save for next check if no match on this word 
234d				ld a,l 
234d				ld hl, os_word_scratch+2 
234d				call hexout 
234d				ld hl, os_word_scratch+4 
234d				ld a,0 
234d				ld (hl),a 
234d				ld de,os_word_scratch 
234d				call str_at_display 
234d					ld a, display_row_2 
234d					call str_at_display 
234d				ld de, (cli_origtoken) 
234d				ld a, display_row_1+10 
234d					call str_at_display 
234d			 
234d				ld a,display_row_1 
234d				ld de, .foundword 
234d				ld a, display_row_3 
234d				call str_at_display 
234d				call update_display 
234d				call delay1s 
234d				call delay1s 
234d				call delay1s 
234d			endif 
234d			 
234d			if DEBUG_FORTH_PARSE_KEY 
234d						DMARK "KYj" 
234d			endif 
234d				; TODO save the word pointer in this exec 
234d			 
234d 2a d4 fb			ld hl,(cli_execword) 
2350 e9				jp (hl) 
2351			 
2351			 
2351			;    if not same 
2351			;	scan for zero term 
2351			;	get ptr for next word 
2351			;	goto word comp 
2351			 
2351			.execpnskipword:	; get pointer to next word 
2351 2a d2 fb			ld hl,(cli_nextword) 
2354			 
2354 7e				ld a,(hl) 
2355 fe 00			cp WORD_SYS_END 
2357			;	cp 0 
2357 28 09			jr z, .execendofdict			 ; at end of words 
2359			 
2359			if DEBUG_FORTH_PARSE_KEY 
2359						DMARK "KY4" 
2359			endif 
2359			if DEBUG_FORTH_PARSE_EXEC 
2359			 
2359				; see if disabled 
2359			 
2359				ld a, (os_view_disable) 
2359				cp '*' 
2359				jr z, .noskip 
2359			 
2359			 
2359				ld de, .nowordfound 
2359				ld a, display_row_3 
2359				call str_at_display 
2359				call update_display 
2359				ld a, 100 
2359				call aDelayInMS 
2359				 
2359				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2359					call delay250ms 
2359				endif 
2359			.noskip:  
2359			 
2359			endif	 
2359			 
2359 2a ce fb			ld hl,(cli_origptr) 
235c 22 d0 fb			ld (cli_ptr),hl 
235f			 
235f			if DEBUG_FORTH_PARSE_KEY 
235f						DMARK "KY5" 
235f			endif 
235f c3 05 23			jp .execpnword			; else go to next word 
2362			 
2362			.execendofdict:  
2362			 
2362			if DEBUG_FORTH_PARSE_KEY 
2362						DMARK "KYe" 
2362			endif 
2362			if DEBUG_FORTH_PARSE_EXEC 
2362				; see if disabled 
2362			 
2362				ld a, (os_view_disable) 
2362				cp '*' 
2362				jr z, .ispskip 
2362			 
2362				call clear_display 
2362				call update_display 
2362				call delay1s 
2362				ld de, (cli_origptr) 
2362				ld a, display_row_1 
2362				call str_at_display 
2362				 
2362				ld de, .enddict 
2362				ld a, display_row_3 
2362				call str_at_display 
2362				call update_display 
2362				ld a, 100 
2362				call aDelayInMS 
2362				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2362				call delay1s 
2362				call delay1s 
2362				call delay1s 
2362				endif 
2362			.ispskip:  
2362				 
2362			endif	 
2362			 
2362			 
2362			 
2362				; if the word is not a keyword then must be a literal so push it to stack 
2362			 
2362			; push token to stack to end of word 
2362			 
2362				STACKFRAME ON $1efe $2f9f 
2362				if DEBUG_STACK_IMB 
2362					if ON 
2362						exx 
2362						ld de, $1efe 
2362						ld a, d 
2362						ld hl, curframe 
2362						call hexout 
2362						ld a, e 
2362						ld hl, curframe+2 
2362						call hexout 
2362						ld hl, $1efe 
2362						push hl 
2362						ld hl, $2f9f 
2362						push hl 
2362						exx 
2362					endif 
2362				endif 
2362			endm 
# End of macro STACKFRAME
2362			 
2362 2a 86 f6		ld hl,(os_tok_ptr) 
2365 cd 55 20		call forth_apush 
2368			 
2368				STACKFRAMECHK ON $1efe $2f9f 
2368				if DEBUG_STACK_IMB 
2368					if ON 
2368						exx 
2368						ld hl, $2f9f 
2368						pop de   ; $2f9f 
2368						call cmp16 
2368						jr nz, .spnosame 
2368						ld hl, $1efe 
2368						pop de   ; $1efe 
2368						call cmp16 
2368						jr z, .spfrsame 
2368						.spnosame: call showsperror 
2368						.spfrsame: nop 
2368						exx 
2368					endif 
2368				endif 
2368			endm 
# End of macro STACKFRAMECHK
2368			 
2368			execnext: 
2368			 
2368			if DEBUG_FORTH_PARSE_KEY 
2368						DMARK "KY>" 
2368			endif 
2368			; move past token to next word 
2368			 
2368 2a 86 f6		ld hl, (os_tok_ptr) 
236b 3e 00		ld a, 0 
236d 01 ff 00		ld bc, 255     ; input buffer size 
2370 ed b1		cpir 
2372			 
2372			if DEBUG_FORTH_PARSE_KEY 
2372						DMARK "KY!" 
2372				CALLMONITOR 
2372			endif	 
2372			; TODO this might place hl on the null, so will need to forward on??? 
2372			;inc hl   ; see if this gets onto the next item 
2372			 
2372			 
2372			; TODO pass a pointer to the buffer to push 
2372			; TODO call function to push 
2372			 
2372			; look for end of input 
2372			 
2372			;inc hl 
2372			;ld a,(hl) 
2372			;cp FORTH_END_BUFFER 
2372			;ret z 
2372			 
2372			 
2372 c3 eb 22		jp exec1 
2375			 
2375			 
2375			 
2375			 
2375			 
2375			 
2375			 
2375			 
2375			 
2375			findnexttok: 
2375			 
2375				; hl is pointer to move 
2375				; de is the token to locate 
2375			 
2375					if DEBUG_FORTH 
2375						DMARK "NTK" 
2375						CALLMONITOR 
2375					endif 
2375 d5				push de 
2376			 
2376			.fnt1:	 
2376				; find first char of token to locate 
2376			 
2376 1a				ld a, (de) 
2377 4f				ld c,a 
2378 7e				ld a,(hl) 
2379 cd 50 13			call toUpper 
237c					if DEBUG_FORTH 
237c						DMARK "NT1" 
237c						CALLMONITOR 
237c					endif 
237c b9				cp c 
237d			 
237d 28 03			jr z, .fnt2cmpmorefirst	 
237f			 
237f				; first char not found move to next char 
237f			 
237f 23				inc hl 
2380 18 f4			jr .fnt1 
2382			 
2382			.fnt2cmpmorefirst:	 
2382				; first char of token found.  
2382			 
2382 e5				push hl     ; save start of token just in case it is the right one 
2383 d9				exx 
2384 e1				pop hl        ; save it to hl' 
2385 d9				exx 
2386			 
2386			 
2386			.fnt2cmpmore:	 
2386				; compare the rest 
2386				 
2386 23				inc hl 
2387 13				inc de 
2388				 
2388 1a				ld a, (de) 
2389 4f				ld c,a 
238a 7e				ld a,(hl) 
238b cd 50 13			call toUpper 
238e			 
238e					if DEBUG_FORTH 
238e						DMARK "NT2" 
238e						CALLMONITOR 
238e					endif 
238e				; c has the token to find char 
238e				; a has the mem to scan char 
238e			 
238e b9				cp c 
238f 28 04			jr z,.fntmatch1 
2391			 
2391				; they are not the same 
2391			 
2391					if DEBUG_FORTH 
2391						DMARK "NT3" 
2391						CALLMONITOR 
2391					endif 
2391 d1				pop de	; reset de token to look for 
2392 d5				push de 
2393 18 e1			jr .fnt1 
2395				 
2395			.fntmatch1: 
2395			 
2395				; is the same char a null which means we might have a full hit? 
2395					if DEBUG_FORTH 
2395						DMARK "NT4" 
2395						CALLMONITOR 
2395					endif 
2395			 
2395 fe 00			cp 0 
2397 28 0b			jr z, .fntmatchyes 
2399			 
2399				; are we at the end of the token to find? 
2399			 
2399					if DEBUG_FORTH 
2399						DMARK "NT5" 
2399						CALLMONITOR 
2399					endif 
2399 3e 00			ld a, 0 
239b b9				cp c 
239c			 
239c c2 86 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
239f			 
239f					if DEBUG_FORTH 
239f						DMARK "NT6" 
239f						CALLMONITOR 
239f					endif 
239f				; token to find is exhusted but no match to stream 
239f			 
239f				; restore tok pointer and continue on 
239f d1				pop de 
23a0 d5				push de 
23a1 c3 76 23			jp .fnt1 
23a4			 
23a4			 
23a4			.fntmatchyes: 
23a4			 
23a4				; hl now contains the end of the found token 
23a4			 
23a4				; get rid of saved token pointer to find 
23a4			 
23a4 d1				pop de 
23a5			 
23a5					if DEBUG_FORTH 
23a5						DMARK "NT9" 
23a5						CALLMONITOR 
23a5					endif 
23a5			 
23a5				; hl will be on the null term so forward on 
23a5			 
23a5				; get back the saved start of the token 
23a5			 
23a5 d9				exx 
23a6 e5				push hl     ; save start of token just in case it is the right one 
23a7 d9				exx 
23a8 e1				pop hl        ; save it to hl 
23a9			 
23a9 c9				ret 
23aa			 
23aa			 
23aa			; LIST needs to find a specific token   
23aa			; FORGET needs to find a spefici token 
23aa			 
23aa			; SAVE needs to find all tokens by flag 
23aa			; WORDS just needs to scan through all  by flag 
23aa			; UWORDS needs to scan through all by flag 
23aa			 
23aa			 
23aa			; given hl as pointer to start of dict look up string 
23aa			; return hl as pointer to start of word block 
23aa			; or 0 if not found 
23aa			 
23aa			forth_find_tok: 
23aa c9				ret 
23ab			 
23ab			; given hl as pointer to dict structure 
23ab			; move to the next dict block structure 
23ab			 
23ab			forth_tok_next: 
23ab				; hl now points to the address of the next word pointer  
23ab				; TODO skip compiled symbol for now 
23ab			;	push de 
23ab 23				inc hl 
23ac 5e				ld e, (hl) 
23ad 23				inc hl 
23ae 56				ld d, (hl) 
23af 23				inc hl 
23b0			 
23b0 eb				ex de,hl 
23b1			if DEBUG_FORTH_PARSE_NEXTWORD 
23b1				push bc 
23b1				ld bc, (cli_nextword) 
23b1						DMARK "NXW" 
23b1				CALLMONITOR 
23b1				pop bc 
23b1			endif 
23b1			;	pop de	 
23b1 c9				ret 
23b2			 
23b2			 
23b2			 
23b2			; eof 
# End of file forth_parserv5.asm
23b2				include "forth_wordsv4.asm" 
23b2			 
23b2			; the core word dictionary v4 
23b2			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
23b2			 
23b2			; this is a linked list for each of the system words used 
23b2			; user defined words will follow the same format but will be in ram 
23b2			 
23b2			 
23b2			; 
23b2			; 
23b2			; define linked list: 
23b2			; 
23b2			; 1. compiled byte op code 
23b2			; 2. len of text word 
23b2			; 3. text word 
23b2			; 4. ptr to next dictionary word 
23b2			; 5. asm, calls etc for the word 
23b2			; 
23b2			;  if 1 == 0 then last word in dict  
23b2			;   
23b2			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
23b2			;  
23b2			;  
23b2			; create basic standard set of words 
23b2			; 
23b2			;  
23b2			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
23b2			; 2DUP 2DROP 2SWAP  
23b2			; @ C@ - get byte  
23b2			; ! C! - store byte 
23b2			; 0< true if less than zero 
23b2			; 0= true if zero 
23b2			; < >  
23b2			; = true if same 
23b2			; variables 
23b2			 
23b2			 
23b2			; Hardware specific words I may need 
23b2			; 
23b2			; IN OUT  
23b2			; calls to key util functions 
23b2			; calls to hardward abstraction stuff 
23b2			; easy control of frame buffers and lcd i/o 
23b2			; keyboard  
23b2			 
23b2			 
23b2			;DICT: macro 
23b2			; op_code, len, word, next 
23b2			;    word: 
23b2			;    db op_code 
23b2			;    ds word zero term 
23b2			;    dw next 
23b2			;    endm 
23b2			 
23b2			 
23b2			 
23b2			 
23b2			; op code 1 is a flag for user define words which are to be handled differently 
23b2			 
23b2			 
23b2			; 
23b2			; 
23b2			;    TODO on entry to a word this should be the expected environment 
23b2			;    hl - tos value if number then held, if string this is the ptr 
23b2			;    de -  
23b2			 
23b2			 
23b2			; opcode ranges 
23b2			; 0 - end of word dict 
23b2			; 255 - user define words 
23b2			 
23b2			sysdict: 
23b2			include "forth_opcodes.asm" 
23b2			; op codes for forth keywords 
23b2			; free to use code 0  
23b2				OPCODE_HEAP: equ  1 
23b2				OPCODE_EXEC: equ 2 
23b2				OPCODE_DUP: equ 3 
23b2				OPCODE_SWAP: equ 4 
23b2				OPCODE_COLN: equ 5 
23b2				OPCODE_SCOLN: equ 6 
23b2				OPCODE_DROP: equ 7 
23b2				OPCODE_DUP2: equ 8 
23b2				OPCODE_DROP2: equ 9 
23b2				OPCODE_SWAP2: equ 10 
23b2				OPCODE_AT: equ 11 
23b2				OPCODE_CAT: equ 12 
23b2				OPCODE_BANG: equ 13 
23b2				OPCODE_CBANG: equ 14 
23b2				OPCODE_SCALL: equ 15 
23b2				OPCODE_DEPTH: equ 16 
23b2				OPCODE_OVER: equ 17 
23b2				OPCODE_PAUSE: equ 18 
23b2				OPCODE_PAUSES: equ 19 
23b2				OPCODE_ROT: equ 20 
23b2			;free to reuse	OPCODE_WORDS: equ 21 
23b2			        OPCODE_NOT: equ 21 
23b2				OPCODE_UWORDS: equ 22 
23b2				OPCODE_BP: equ 23 
23b2				OPCODE_MONITOR: equ 24  
23b2				OPCODE_MALLOC: equ 25 
23b2				OPCODE_FREE: equ 26 
23b2				OPCODE_LIST: equ 27 
23b2				OPCODE_FORGET: equ 28 
23b2				OPCODE_NOP: equ 29 
23b2				OPCODE_COMO: equ 30 
23b2				OPCODE_COMC: equ 31 
23b2			;free to reuse	OPCODE_ENDCORE: equ 32 
23b2				OPCODE_AFTERSOUND: equ 33 
23b2				OPCODE_GP2: equ 34 
23b2				OPCODE_GP3: equ 35 
23b2				OPCODE_GP4: equ 36 
23b2				OPCODE_SIN: equ 37 
23b2				OPCODE_SOUT: equ 38 
23b2				OPCODE_SPIO: equ 39 
23b2				OPCODE_SPICEH: equ 40 
23b2				OPCODE_SPIOb: equ 41 
23b2				OPCODE_SPII: equ 42 
23b2				OPCODE_SESEL: equ 43 
23b2				OPCODE_CARTDEV: equ 44 
23b2			; free to reuse	OPCODE_ENDDEVICE: equ 45 
23b2				OPCODE_FB: equ 46 
23b2				OPCODE_EMIT: equ 47 
23b2				OPCODE_DOTH: equ 48 
23b2				OPCODE_DOTF: equ 49 
23b2				OPCODE_DOT: equ 50 
23b2				OPCODE_CLS: equ 51 
23b2				OPCODE_DRAW: equ 52 
23b2				OPCODE_DUMP: equ 53 
23b2				OPCODE_CDUMP: equ 54 
23b2				OPCODE_DAT: equ 55 
23b2				OPCODE_HOME: equ 56 
23b2				OPCODE_SPACE: equ 57 
23b2				OPCODE_SPACES: equ 58 
23b2				OPCODE_SCROLL: equ 59 
23b2				OPCODE_ATQ: equ 60 
23b2				OPCODE_AUTODSP: equ 61 
23b2				OPCODE_MENU: equ 62 
23b2			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
23b2				OPCODE_THEN: equ 64 
23b2				OPCODE_ELSE: equ 65 
23b2				OPCODE_DO: equ 66 
23b2				OPCODE_LOOP: equ 67 
23b2				OPCODE_I: equ 68 
23b2				OPCODE_DLOOP: equ 69  
23b2				OPCODE_REPEAT: equ 70  
23b2				OPCODE_UNTIL: equ 71 
23b2				OPCODE_ENDFLOW: equ 72 
23b2				OPCODE_WAITK: equ 73 
23b2				OPCODE_ACCEPT: equ 74 
23b2				OPCODE_EDIT: equ 75 
23b2			;free to reuse	OPCODE_ENDKEY: equ 76 
23b2				OPCODE_LZERO: equ 77 
23b2				OPCODE_TZERO: equ 78 
23b2				OPCODE_LESS: equ 79 
23b2				OPCODE_GT: equ 80 
23b2				OPCODE_EQUAL: equ 81  
23b2			;free to reuse	OPCODE_ENDLOGIC: equ 82 
23b2				OPCODE_NEG: equ 83 
23b2				OPCODE_DIV: equ 84 
23b2				OPCODE_MUL: equ 85 
23b2				OPCODE_MIN: equ 86 
23b2				OPCODE_MAX: equ 87 
23b2				OPCODE_RND16: equ 88 
23b2				OPCODE_RND8: equ 89 
23b2				OPCODE_RND: equ 90 
23b2			;free to reuse	OPCODE_ENDMATHS: equ 91  
23b2				OPCODE_BYNAME: equ 92 
23b2				OPCODE_DIR: equ 93 
23b2				OPCODE_SAVE: equ 94 
23b2				OPCODE_LOAD: equ 95 
23b2				OPCODE_BSAVE: equ 96 
23b2				OPCODE_BLOAD: equ 97 
23b2				OPCODE_SEO: equ 98  
23b2				OPCODE_SEI: equ 99 
23b2				OPCODE_SFREE: equ 100 
23b2				OPCODE_SIZE: equ 101 
23b2				OPCODE_CREATE: equ 102 
23b2				OPCODE_APPEND: equ 103 
23b2				OPCODE_SDEL: equ 104 
23b2				OPCODE_OPEN: equ 105 
23b2				OPCODE_READ: equ 106 
23b2				OPCODE_EOF: equ 106 
23b2				OPCODE_FORMAT: equ 107 
23b2				OPCODE_LABEL: equ 108 
23b2				OPCODE_LABELS: equ 109 
23b2			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
23b2				OPCODE_UPPER: equ 111 
23b2				OPCODE_LOWER: equ 112 
23b2				OPCODE_SUBSTR: equ 113 
23b2				OPCODE_LEFT: equ 114 
23b2				OPCODE_RIGHT: equ 115 
23b2				OPCODE_STR2NUM: equ 116 
23b2				OPCODE_NUM2STR: equ 117 
23b2				OPCODE_CONCAT: equ 118 
23b2				OPCODE_FIND: equ 119 
23b2				OPCODE_LEN: equ 120 
23b2				OPCODE_CHAR: equ 121 
23b2			; free to reuse	OPCODE_STRLEN: equ 122 
23b2			; free to reuse	OPCODE_ENDSTR: equ 123 
23b2				OPCODE_V0S: equ 124 
23b2				OPCODE_V0Q: equ 125 
23b2				OPCODE_V1S: equ 126 
23b2				OPCODE_V1Q: equ 127 
23b2				OPCODE_V2S: equ 128 
23b2				OPCODE_V2Q: equ 129 
23b2				OPCODE_V3S: equ 130 
23b2				OPCODE_V3Q: equ 131 
23b2			;free to reuse	OPCODE_END: equ 132 
23b2				OPCODE_ZDUP: equ 133 
23b2			 
23b2			; eof 
# End of file forth_opcodes.asm
23b2			 
23b2			include "forth_words_core.asm" 
23b2			 
23b2			; | ## Core Words 
23b2			 
23b2			;if MALLOC_4 
23b2			 
23b2			.HEAP: 
23b2				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
23b2 15				db WORD_SYS_CORE+OPCODE_HEAP             
23b3 f1 23			dw .EXEC            
23b5 05				db 4 + 1 
23b6 .. 00			db "HEAP",0              
23bb				endm 
# End of macro CWHEAD
23bb			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
23bb			; | | u1 - Current number of bytes in the heap 
23bb			; | | u2 - Remaining bytes left on the heap 
23bb			; | |  
23bb			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
23bb			 
23bb			 
23bb					if DEBUG_FORTH_WORDS_KEY 
23bb						DMARK "HEP" 
23bb f5				push af  
23bc 3a d0 23			ld a, (.dmark)  
23bf 32 b4 fe			ld (debug_mark),a  
23c2 3a d1 23			ld a, (.dmark+1)  
23c5 32 b5 fe			ld (debug_mark+1),a  
23c8 3a d2 23			ld a, (.dmark+2)  
23cb 32 b6 fe			ld (debug_mark+2),a  
23ce 18 03			jr .pastdmark  
23d0 ..			.dmark: db "HEP"  
23d3 f1			.pastdmark: pop af  
23d4			endm  
# End of macro DMARK
23d4						CALLMONITOR 
23d4 cd 78 18			call break_point_state  
23d7				endm  
# End of macro CALLMONITOR
23d7					endif 
23d7 2a 0a 80				ld hl, (free_list )      
23da 11 0e 80				ld de, heap_start 
23dd			 
23dd ed 52				sbc hl, de  
23df			 
23df cd ec 1e				call forth_push_numhl 
23e2			 
23e2			 
23e2 ed 5b 0a 80			ld de, (free_list )      
23e6 21 6b f3				ld hl, heap_end 
23e9			 
23e9 ed 52				sbc hl, de 
23eb			 
23eb cd ec 1e				call forth_push_numhl 
23ee					 
23ee			 
23ee					 
23ee			 
23ee			 
23ee			 
23ee					NEXTW 
23ee c3 5a 22			jp macro_next 
23f1				endm 
# End of macro NEXTW
23f1			;endif 
23f1			 
23f1			.EXEC: 
23f1			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
23f1			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
23f1			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
23f1			;; > > 
23f1			;; > >   
23f1			;	STACKFRAME OFF $5efe $5f9f 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS_KEY 
23f1			;			DMARK "EXE" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			; 
23f1			;	FORTH_DSP_VALUEHL 
23f1			; 
23f1			;	FORTH_DSP_POP 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX1" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;;	ld e,(hl) 
23f1			;;	inc hl 
23f1			;;	ld d,(hl) 
23f1			;;	ex de,hl 
23f1			; 
23f1			;;		if DEBUG_FORTH_WORDS 
23f1			;;			DMARK "EX2" 
23f1			;;			CALLMONITOR 
23f1			;;		endif 
23f1			;	push hl 
23f1			; 
23f1			;	;ld a, 0 
23f1			;	;ld a, FORTH_END_BUFFER 
23f1			;	call strlenz 
23f1			;	inc hl   ; include zero term to copy 
23f1			;	inc hl   ; include term 
23f1			;	inc hl   ; include term 
23f1			;	ld b,0 
23f1			;	ld c,l 
23f1			;	pop hl 
23f1			;	ld de, execscratch 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX3" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	ldir 
23f1			; 
23f1			; 
23f1			;	ld hl, execscratch 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EXe" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			; 
23f1			;	call forthparse 
23f1			;	call forthexec 
23f1			;;	call forthexec_cleanup 
23f1			;;	call forthparse 
23f1			;;	call forthexec 
23f1			; 
23f1			;	STACKFRAMECHK OFF $5efe $5f9f 
23f1			; 
23f1			;	; an immediate word so no need to process any more words 
23f1			;	ret 
23f1			;	NEXTW 
23f1			 
23f1			; dead code - old version  
23f1			;	FORTH_RSP_NEXT 
23f1			 
23f1			;  
23f1			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23f1			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23f1			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23f1			;	push hl 
23f1			;	push de 
23f1			;	push bc 
23f1			; 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS_KEY 
23f1			;			DMARK "EXR" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			; 
23f1			; 
23f1			; 
23f1			;	;v5 FORTH_DSP_VALUE 
23f1			;	FORTH_DSP_VALUEHL 
23f1			; 
23f1			;	; TODO do string type checks 
23f1			; 
23f1			;;v5	inc hl   ; skip type 
23f1			; 
23f1			;	push hl  ; source code  
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX1" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	ld a, 0 
23f1			;	call strlent 
23f1			; 
23f1			;	inc hl 
23f1			;	inc hl 
23f1			;	inc hl 
23f1			;	inc hl 
23f1			; 
23f1			;	push hl    ; size 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX2" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	call malloc 
23f1			; 
23f1			;	ex de, hl    ; de now contains malloc area 
23f1			;	pop bc   	; get byte count 
23f1			;	pop hl      ; get string to copy 
23f1			; 
23f1			;	push de     ; save malloc for free later 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX3" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	ldir       ; duplicate string 
23f1			; 
23f1			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
23f1			;	 
23f1			;	; TODO fix the parse would be better than this...  
23f1			;	ex de, hl 
23f1			;	dec hl 
23f1			;	ld a, 0 
23f1			;	ld (hl), a 
23f1			;	dec hl 
23f1			;	ld a, ' ' 
23f1			;	ld (hl), a 
23f1			;	dec hl 
23f1			;	ld (hl), a 
23f1			; 
23f1			;	dec hl 
23f1			;	ld (hl), a 
23f1			; 
23f1			; 
23f1			;	FORTH_DSP_POP  
23f1			; 
23f1			;	pop hl     
23f1			;	push hl    ; save malloc area 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX4" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			; 
23f1			;	call forthparse 
23f1			;	call forthexec 
23f1			;	 
23f1			;	pop hl 
23f1			;	if DEBUG_FORTH_WORDS 
23f1			;		DMARK "EX5" 
23f1			;		CALLMONITOR 
23f1			;	endif 
23f1			; 
23f1			;	if FORTH_ENABLE_FREE 
23f1			;	call free 
23f1			;	endif 
23f1			; 
23f1			;	if DEBUG_FORTH_WORDS 
23f1			;		DMARK "EX6" 
23f1			;		CALLMONITOR 
23f1			;	endif 
23f1			; 
23f1			;	pop bc 
23f1			;	pop de 
23f1			;	pop hl 
23f1			;;	FORTH_RSP_POP	  
23f1			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
23f1			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
23f1			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
23f1			; 
23f1			;	if DEBUG_FORTH_WORDS 
23f1			;		DMARK "EX7" 
23f1			;		CALLMONITOR 
23f1			;	endif 
23f1			;	NEXTW 
23f1			 
23f1			;.STKEXEC: 
23f1			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
23f1			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
23f1			; 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS_KEY 
23f1			;			DMARK "STX" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			; 
23f1			;	FORTH_DSP_VALUEHL 
23f1			; 
23f1			;	ld (store_tmp1), hl    ; count 
23f1			; 
23f1			;	FORTH_DSP_POP 
23f1			;.stkexec1: 
23f1			;	ld hl, (store_tmp1)   ; count 
23f1			;	ld a, 0 
23f1			;	cp l 
23f1			;	ret z 
23f1			; 
23f1			;	dec hl 
23f1			;	ld (store_tmp1), hl    ; count 
23f1			;	 
23f1			;	FORTH_DSP_VALUEHL 
23f1			;	push hl 
23f1			;	 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EXp" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	FORTH_DSP_POP 
23f1			; 
23f1			;	call strlenz 
23f1			;	inc hl   ; include zero term to copy 
23f1			;	inc hl   ; include zero term to copy 
23f1			;	inc hl   ; include zero term to copy 
23f1			;	ld b,0 
23f1			;	ld c,l 
23f1			;	pop hl 
23f1			;	ld de, execscratch 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EX3" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	ldir 
23f1			; 
23f1			; 
23f1			;	ld hl, execscratch 
23f1			; 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EXP" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			; 
23f1			;	call forthparse 
23f1			;	ld hl, execscratch 
23f1			;		if DEBUG_FORTH_WORDS 
23f1			;			DMARK "EXx" 
23f1			;			CALLMONITOR 
23f1			;		endif 
23f1			;	call forthexec 
23f1			; 
23f1			;	jp .stkexec1 
23f1			; 
23f1			;	ret 
23f1			 
23f1			 
23f1			.DUP: 
23f1				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
23f1 17				db WORD_SYS_CORE+OPCODE_DUP             
23f2 67 24			dw .ZDUP            
23f4 04				db 3 + 1 
23f5 .. 00			db "DUP",0              
23f9				endm 
# End of macro CWHEAD
23f9			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
23f9			 
23f9					if DEBUG_FORTH_WORDS_KEY 
23f9						DMARK "DUP" 
23f9 f5				push af  
23fa 3a 0e 24			ld a, (.dmark)  
23fd 32 b4 fe			ld (debug_mark),a  
2400 3a 0f 24			ld a, (.dmark+1)  
2403 32 b5 fe			ld (debug_mark+1),a  
2406 3a 10 24			ld a, (.dmark+2)  
2409 32 b6 fe			ld (debug_mark+2),a  
240c 18 03			jr .pastdmark  
240e ..			.dmark: db "DUP"  
2411 f1			.pastdmark: pop af  
2412			endm  
# End of macro DMARK
2412						CALLMONITOR 
2412 cd 78 18			call break_point_state  
2415				endm  
# End of macro CALLMONITOR
2415					endif 
2415			 
2415					FORTH_DSP 
2415 cd a9 20			call macro_forth_dsp 
2418				endm 
# End of macro FORTH_DSP
2418			 
2418 7e					ld a, (HL) 
2419 fe 01				cp DS_TYPE_STR 
241b 20 25				jr nz, .dupinum 
241d			 
241d					; push another string 
241d			 
241d					FORTH_DSP_VALUEHL     		 
241d cd e3 20			call macro_dsp_valuehl 
2420				endm 
# End of macro FORTH_DSP_VALUEHL
2420			 
2420				if DEBUG_FORTH_WORDS 
2420					DMARK "DUs" 
2420 f5				push af  
2421 3a 35 24			ld a, (.dmark)  
2424 32 b4 fe			ld (debug_mark),a  
2427 3a 36 24			ld a, (.dmark+1)  
242a 32 b5 fe			ld (debug_mark+1),a  
242d 3a 37 24			ld a, (.dmark+2)  
2430 32 b6 fe			ld (debug_mark+2),a  
2433 18 03			jr .pastdmark  
2435 ..			.dmark: db "DUs"  
2438 f1			.pastdmark: pop af  
2439			endm  
# End of macro DMARK
2439					CALLMONITOR 
2439 cd 78 18			call break_point_state  
243c				endm  
# End of macro CALLMONITOR
243c				endif 
243c cd 5a 1f				call forth_push_str 
243f			 
243f					NEXTW 
243f c3 5a 22			jp macro_next 
2442				endm 
# End of macro NEXTW
2442			 
2442			 
2442			.dupinum: 
2442					 
2442			 
2442			 
2442					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2442 cd e3 20			call macro_dsp_valuehl 
2445				endm 
# End of macro FORTH_DSP_VALUEHL
2445			 
2445				; TODO add floating point number detection 
2445			 
2445				if DEBUG_FORTH_WORDS 
2445					DMARK "DUi" 
2445 f5				push af  
2446 3a 5a 24			ld a, (.dmark)  
2449 32 b4 fe			ld (debug_mark),a  
244c 3a 5b 24			ld a, (.dmark+1)  
244f 32 b5 fe			ld (debug_mark+1),a  
2452 3a 5c 24			ld a, (.dmark+2)  
2455 32 b6 fe			ld (debug_mark+2),a  
2458 18 03			jr .pastdmark  
245a ..			.dmark: db "DUi"  
245d f1			.pastdmark: pop af  
245e			endm  
# End of macro DMARK
245e					CALLMONITOR 
245e cd 78 18			call break_point_state  
2461				endm  
# End of macro CALLMONITOR
2461				endif 
2461			 
2461 cd ec 1e				call forth_push_numhl 
2464					NEXTW 
2464 c3 5a 22			jp macro_next 
2467				endm 
# End of macro NEXTW
2467			.ZDUP: 
2467				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2467 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2468 9f 24			dw .SWAP            
246a 05				db 4 + 1 
246b .. 00			db "?DUP",0              
2470				endm 
# End of macro CWHEAD
2470			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2470			 
2470					if DEBUG_FORTH_WORDS_KEY 
2470						DMARK "qDU" 
2470 f5				push af  
2471 3a 85 24			ld a, (.dmark)  
2474 32 b4 fe			ld (debug_mark),a  
2477 3a 86 24			ld a, (.dmark+1)  
247a 32 b5 fe			ld (debug_mark+1),a  
247d 3a 87 24			ld a, (.dmark+2)  
2480 32 b6 fe			ld (debug_mark+2),a  
2483 18 03			jr .pastdmark  
2485 ..			.dmark: db "qDU"  
2488 f1			.pastdmark: pop af  
2489			endm  
# End of macro DMARK
2489						CALLMONITOR 
2489 cd 78 18			call break_point_state  
248c				endm  
# End of macro CALLMONITOR
248c					endif 
248c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
248c cd e3 20			call macro_dsp_valuehl 
248f				endm 
# End of macro FORTH_DSP_VALUEHL
248f			 
248f e5					push hl 
2490			 
2490					; is it a zero? 
2490			 
2490 3e 00				ld a, 0 
2492 84					add h 
2493 85					add l 
2494			 
2494 e1					pop hl 
2495			 
2495 fe 00				cp 0 
2497 28 03				jr z, .dup2orig 
2499			 
2499			 
2499 cd ec 1e				call forth_push_numhl 
249c			 
249c			 
249c				; TODO add floating point number detection 
249c			 
249c			.dup2orig: 
249c			 
249c					NEXTW 
249c c3 5a 22			jp macro_next 
249f				endm 
# End of macro NEXTW
249f			.SWAP: 
249f				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
249f 18				db WORD_SYS_CORE+OPCODE_SWAP             
24a0 de 24			dw .COLN            
24a2 05				db 4 + 1 
24a3 .. 00			db "SWAP",0              
24a8				endm 
# End of macro CWHEAD
24a8			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
24a8					if DEBUG_FORTH_WORDS_KEY 
24a8						DMARK "SWP" 
24a8 f5				push af  
24a9 3a bd 24			ld a, (.dmark)  
24ac 32 b4 fe			ld (debug_mark),a  
24af 3a be 24			ld a, (.dmark+1)  
24b2 32 b5 fe			ld (debug_mark+1),a  
24b5 3a bf 24			ld a, (.dmark+2)  
24b8 32 b6 fe			ld (debug_mark+2),a  
24bb 18 03			jr .pastdmark  
24bd ..			.dmark: db "SWP"  
24c0 f1			.pastdmark: pop af  
24c1			endm  
# End of macro DMARK
24c1						CALLMONITOR 
24c1 cd 78 18			call break_point_state  
24c4				endm  
# End of macro CALLMONITOR
24c4					endif 
24c4			 
24c4					FORTH_DSP_VALUEHL 
24c4 cd e3 20			call macro_dsp_valuehl 
24c7				endm 
# End of macro FORTH_DSP_VALUEHL
24c7 e5					push hl     ; w2 
24c8			 
24c8					FORTH_DSP_POP 
24c8 cd 9b 21			call macro_forth_dsp_pop 
24cb				endm 
# End of macro FORTH_DSP_POP
24cb			 
24cb					FORTH_DSP_VALUEHL 
24cb cd e3 20			call macro_dsp_valuehl 
24ce				endm 
# End of macro FORTH_DSP_VALUEHL
24ce			 
24ce					FORTH_DSP_POP 
24ce cd 9b 21			call macro_forth_dsp_pop 
24d1				endm 
# End of macro FORTH_DSP_POP
24d1			 
24d1 d1					pop de     ; w2	, hl = w1 
24d2			 
24d2 eb					ex de, hl 
24d3 d5					push de 
24d4			 
24d4 cd ec 1e				call forth_push_numhl 
24d7			 
24d7 e1					pop hl 
24d8			 
24d8 cd ec 1e				call forth_push_numhl 
24db					 
24db			 
24db					NEXTW 
24db c3 5a 22			jp macro_next 
24de				endm 
# End of macro NEXTW
24de			.COLN: 
24de				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
24de 19				db WORD_SYS_CORE+OPCODE_COLN             
24df 6a 26			dw .SCOLN            
24e1 02				db 1 + 1 
24e2 .. 00			db ":",0              
24e4				endm 
# End of macro CWHEAD
24e4			; | : ( -- )         Create new word | DONE 
24e4			 
24e4					if DEBUG_FORTH_WORDS_KEY 
24e4						DMARK "CLN" 
24e4 f5				push af  
24e5 3a f9 24			ld a, (.dmark)  
24e8 32 b4 fe			ld (debug_mark),a  
24eb 3a fa 24			ld a, (.dmark+1)  
24ee 32 b5 fe			ld (debug_mark+1),a  
24f1 3a fb 24			ld a, (.dmark+2)  
24f4 32 b6 fe			ld (debug_mark+2),a  
24f7 18 03			jr .pastdmark  
24f9 ..			.dmark: db "CLN"  
24fc f1			.pastdmark: pop af  
24fd			endm  
# End of macro DMARK
24fd						CALLMONITOR 
24fd cd 78 18			call break_point_state  
2500				endm  
# End of macro CALLMONITOR
2500					endif 
2500				STACKFRAME OFF $8efe $989f 
2500				if DEBUG_STACK_IMB 
2500					if OFF 
2500						exx 
2500						ld de, $8efe 
2500						ld a, d 
2500						ld hl, curframe 
2500						call hexout 
2500						ld a, e 
2500						ld hl, curframe+2 
2500						call hexout 
2500						ld hl, $8efe 
2500						push hl 
2500						ld hl, $989f 
2500						push hl 
2500						exx 
2500					endif 
2500				endif 
2500			endm 
# End of macro STACKFRAME
2500				; get parser buffer length  of new word 
2500			 
2500				 
2500			 
2500					; move tok past this to start of name defintition 
2500					; TODO get word to define 
2500					; TODO Move past word token 
2500					; TODO get length of string up to the ';' 
2500			 
2500 2a 86 f6			ld hl, (os_tok_ptr) 
2503 23				inc hl 
2504 23				inc hl 
2505			 
2505 3e 3b			ld a, ';' 
2507 cd 64 13			call strlent 
250a			 
250a 7d				ld a,l 
250b 32 81 f3			ld (os_new_parse_len), a 
250e			 
250e			 
250e			if DEBUG_FORTH_UWORD 
250e ed 5b 86 f6		ld de, (os_tok_ptr) 
2512						DMARK ":01" 
2512 f5				push af  
2513 3a 27 25			ld a, (.dmark)  
2516 32 b4 fe			ld (debug_mark),a  
2519 3a 28 25			ld a, (.dmark+1)  
251c 32 b5 fe			ld (debug_mark+1),a  
251f 3a 29 25			ld a, (.dmark+2)  
2522 32 b6 fe			ld (debug_mark+2),a  
2525 18 03			jr .pastdmark  
2527 ..			.dmark: db ":01"  
252a f1			.pastdmark: pop af  
252b			endm  
# End of macro DMARK
252b				CALLMONITOR 
252b cd 78 18			call break_point_state  
252e				endm  
# End of macro CALLMONITOR
252e			endif 
252e			 
252e			; 
252e			;  new word memory layout: 
252e			;  
252e			;    : adg 6666 ;  
252e			; 
252e			;    db   1     ; user defined word  
252e 23				inc hl    
252f			;    dw   sysdict 
252f 23				inc hl 
2530 23				inc hl 
2531			;    db <word len>+1 (for null) 
2531 23				inc hl 
2532			;    db .... <word> 
2532			; 
2532			 
2532 23				inc hl    ; some extras for the word preamble before the above 
2533 23				inc hl 
2534 23				inc hl 
2535 23				inc hl 
2536 23				inc hl 
2537 23				inc hl 
2538 23				inc hl  
2539 23				inc hl 
253a 23				inc hl 
253b 23				inc hl 
253c 23				inc hl 
253d 23				inc hl 
253e 23				inc hl 
253f 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2540			;       exec word buffer 
2540			;	<ptr word>   
2540 23				inc hl 
2541 23				inc hl 
2542			;       <word list><null term> 7F final term 
2542			 
2542			 
2542			if DEBUG_FORTH_UWORD 
2542						DMARK ":02" 
2542 f5				push af  
2543 3a 57 25			ld a, (.dmark)  
2546 32 b4 fe			ld (debug_mark),a  
2549 3a 58 25			ld a, (.dmark+1)  
254c 32 b5 fe			ld (debug_mark+1),a  
254f 3a 59 25			ld a, (.dmark+2)  
2552 32 b6 fe			ld (debug_mark+2),a  
2555 18 03			jr .pastdmark  
2557 ..			.dmark: db ":02"  
255a f1			.pastdmark: pop af  
255b			endm  
# End of macro DMARK
255b				CALLMONITOR 
255b cd 78 18			call break_point_state  
255e				endm  
# End of macro CALLMONITOR
255e			endif 
255e			 
255e				 
255e					; malloc the size 
255e			 
255e cd c2 13				call malloc 
2561 22 83 f3				ld (os_new_malloc), hl     ; save malloc start 
2564			 
2564			;    db   1     ; user defined word  
2564 3e 01				ld a, WORD_SYS_UWORD  
2566 77					ld (hl), a 
2567				 
2567 23				inc hl    
2568			;    dw   sysdict 
2568 11 b2 23			ld de, sysdict       ; continue on with the scan to the system dict 
256b 73				ld (hl), e 
256c 23				inc hl 
256d 72				ld (hl), d 
256e 23				inc hl 
256f			 
256f			 
256f			;    Setup dict word 
256f			 
256f 23				inc hl 
2570 22 7d f3			ld (os_new_work_ptr), hl     ; save start of dict word  
2573			 
2573				; 1. get length of dict word 
2573			 
2573			 
2573 2a 86 f6			ld hl, (os_tok_ptr) 
2576 23				inc hl 
2577 23				inc hl    ; position to start of dict word 
2578 3e 00			ld a, 0 
257a cd 64 13			call strlent 
257d			 
257d			 
257d 23				inc hl    ; to include null??? 
257e			 
257e				; write length of dict word 
257e			 
257e ed 5b 7d f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2582 1b				dec de 
2583 eb				ex de, hl 
2584 73				ld (hl), e 
2585 eb				ex de, hl 
2586			 
2586				 
2586			 
2586				; copy  
2586 4d				ld c, l 
2587 06 00			ld b, 0 
2589 ed 5b 7d f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
258d 2a 86 f6			ld hl, (os_tok_ptr) 
2590 23				inc hl 
2591 23				inc hl    ; position to start of dict word 
2592				 
2592			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2592				 
2592				; TODO need to convert word to upper case 
2592			 
2592			ucasetok:	 
2592 7e				ld a,(hl) 
2593 cd 50 13			call toUpper 
2596 77				ld (hl),a 
2597 ed a0			ldi 
2599 f2 92 25		 	jp p, ucasetok 
259c			 
259c			 
259c			 
259c				; de now points to start of where the word body code should be placed 
259c ed 53 7d f3		ld (os_new_work_ptr), de 
25a0				; hl now points to the words to throw at forthexec which needs to be copied 
25a0 22 7b f3			ld (os_new_src_ptr), hl 
25a3			 
25a3				; TODO add 'call to forthexec' 
25a3			 
25a3			if DEBUG_FORTH_UWORD 
25a3 c5				push bc 
25a4 ed 4b 83 f3		ld bc, (os_new_malloc) 
25a8						DMARK ":0x" 
25a8 f5				push af  
25a9 3a bd 25			ld a, (.dmark)  
25ac 32 b4 fe			ld (debug_mark),a  
25af 3a be 25			ld a, (.dmark+1)  
25b2 32 b5 fe			ld (debug_mark+1),a  
25b5 3a bf 25			ld a, (.dmark+2)  
25b8 32 b6 fe			ld (debug_mark+2),a  
25bb 18 03			jr .pastdmark  
25bd ..			.dmark: db ":0x"  
25c0 f1			.pastdmark: pop af  
25c1			endm  
# End of macro DMARK
25c1				CALLMONITOR 
25c1 cd 78 18			call break_point_state  
25c4				endm  
# End of macro CALLMONITOR
25c4 c1				pop bc 
25c5			endif 
25c5			 
25c5			 
25c5				; create word preamble which should be: 
25c5			 
25c5			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
25c5			 
25c5				;    ld hl, <word code> 
25c5				;    jp user_exec 
25c5			        ;    <word code bytes> 
25c5			 
25c5			 
25c5			;	inc de     ; TODO ??? or are we already past the word's null 
25c5 eb				ex de, hl 
25c6			 
25c6 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
25c8			 
25c8 23				inc hl 
25c9 22 77 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
25cc 23				inc hl 
25cd			 
25cd 23				inc hl 
25ce 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
25d0			 
25d0 01 5b 54			ld bc, user_exec 
25d3 23				inc hl 
25d4 71				ld (hl), c     ; poke address of user_exec 
25d5 23				inc hl 
25d6 70				ld (hl), b     
25d7			 ; 
25d7			;	inc hl 
25d7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25d7			; 
25d7			; 
25d7			;	ld bc, macro_forth_rsp_next 
25d7			;	inc hl 
25d7			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
25d7			;	inc hl 
25d7			;	ld (hl), b     
25d7			 ; 
25d7			;	inc hl 
25d7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25d7			; 
25d7			; 
25d7			;	inc hl 
25d7			;	ld bc, forthexec 
25d7			;	ld (hl), c     ; poke address of forthexec 
25d7			;	inc hl 
25d7			;	ld (hl), b      
25d7			; 
25d7			;	inc hl 
25d7			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
25d7			; 
25d7			;	ld bc, user_dict_next 
25d7			;	inc hl 
25d7			;	ld (hl), c     ; poke address of forthexec 
25d7			;	inc hl 
25d7			;	ld (hl), b      
25d7			 
25d7				; hl is now where we need to copy the word byte data to save this 
25d7			 
25d7 23				inc hl 
25d8 22 79 f3			ld (os_new_exec), hl 
25db				 
25db				; copy definition 
25db			 
25db eb				ex de, hl 
25dc			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
25dc			;	inc de    ; skip the PC for this parse 
25dc 3a 81 f3			ld a, (os_new_parse_len) 
25df 4f				ld c, a 
25e0 06 00			ld b, 0 
25e2 ed b0			ldir		 ; copy defintion 
25e4			 
25e4			 
25e4				; poke the address of where the new word bytes live for forthexec 
25e4			 
25e4 2a 77 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
25e7			 
25e7 ed 5b 79 f3		ld de, (os_new_exec)      
25eb				 
25eb 73				ld (hl), e 
25ec 23				inc hl 
25ed 72				ld (hl), d 
25ee			 
25ee					; TODO copy last user dict word next link to this word 
25ee					; TODO update last user dict word to point to this word 
25ee			; 
25ee			; hl f923 de 812a ; bc 811a 
25ee			 
25ee			if DEBUG_FORTH_UWORD 
25ee c5				push bc 
25ef ed 4b 83 f3		ld bc, (os_new_malloc) 
25f3						DMARK ":0A" 
25f3 f5				push af  
25f4 3a 08 26			ld a, (.dmark)  
25f7 32 b4 fe			ld (debug_mark),a  
25fa 3a 09 26			ld a, (.dmark+1)  
25fd 32 b5 fe			ld (debug_mark+1),a  
2600 3a 0a 26			ld a, (.dmark+2)  
2603 32 b6 fe			ld (debug_mark+2),a  
2606 18 03			jr .pastdmark  
2608 ..			.dmark: db ":0A"  
260b f1			.pastdmark: pop af  
260c			endm  
# End of macro DMARK
260c				CALLMONITOR 
260c cd 78 18			call break_point_state  
260f				endm  
# End of macro CALLMONITOR
260f c1				pop bc 
2610			endif 
2610			if DEBUG_FORTH_UWORD 
2610 c5				push bc 
2611 ed 4b 83 f3		ld bc, (os_new_malloc) 
2615 03				inc bc 
2616 03				inc bc 
2617 03				inc bc 
2618 03				inc bc 
2619 03				inc bc 
261a 03				inc bc 
261b 03				inc bc 
261c 03				inc bc 
261d			 
261d						DMARK ":0B" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 b4 fe			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 b5 fe			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 b6 fe			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db ":0B"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636				CALLMONITOR 
2636 cd 78 18			call break_point_state  
2639				endm  
# End of macro CALLMONITOR
2639 c1				pop bc 
263a			endif 
263a			 
263a			; update word dict linked list for new word 
263a			 
263a			 
263a 2a 82 f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
263d 23			inc hl     ; move to next work linked list ptr 
263e			 
263e ed 5b 83 f3	ld de, (os_new_malloc)		 ; new next word 
2642 73			ld (hl), e 
2643 23			inc hl 
2644 72			ld (hl), d 
2645			 
2645			if DEBUG_FORTH_UWORD 
2645 ed 4b 82 f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2649			endif 
2649			 
2649 ed 53 82 f6	ld (os_last_new_uword), de      ; update last new uword ptr 
264d			 
264d			 
264d			if DEBUG_FORTH_UWORD 
264d						DMARK ":0+" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 b4 fe			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 b5 fe			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 b6 fe			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db ":0+"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666				CALLMONITOR 
2666 cd 78 18			call break_point_state  
2669				endm  
# End of macro CALLMONITOR
2669			endif 
2669			 
2669				STACKFRAMECHK OFF $8efe $989f 
2669				if DEBUG_STACK_IMB 
2669					if OFF 
2669						exx 
2669						ld hl, $989f 
2669						pop de   ; $989f 
2669						call cmp16 
2669						jr nz, .spnosame 
2669						ld hl, $8efe 
2669						pop de   ; $8efe 
2669						call cmp16 
2669						jr z, .spfrsame 
2669						.spnosame: call showsperror 
2669						.spfrsame: nop 
2669						exx 
2669					endif 
2669				endif 
2669			endm 
# End of macro STACKFRAMECHK
2669			 
2669 c9			ret    ; dont process any remaining parser tokens as they form new word 
266a			 
266a			 
266a			 
266a			 
266a			;		NEXT 
266a			.SCOLN: 
266a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
266a 06				db OPCODE_SCOLN 
266b b6 26			dw .DROP 
266d 02				db 2 
266e .. 00			db ";",0           
2670			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2670					if DEBUG_FORTH_WORDS_KEY 
2670						DMARK "SCN" 
2670 f5				push af  
2671 3a 85 26			ld a, (.dmark)  
2674 32 b4 fe			ld (debug_mark),a  
2677 3a 86 26			ld a, (.dmark+1)  
267a 32 b5 fe			ld (debug_mark+1),a  
267d 3a 87 26			ld a, (.dmark+2)  
2680 32 b6 fe			ld (debug_mark+2),a  
2683 18 03			jr .pastdmark  
2685 ..			.dmark: db "SCN"  
2688 f1			.pastdmark: pop af  
2689			endm  
# End of macro DMARK
2689						CALLMONITOR 
2689 cd 78 18			call break_point_state  
268c				endm  
# End of macro CALLMONITOR
268c					endif 
268c					FORTH_RSP_TOS 
268c cd aa 1e			call macro_forth_rsp_tos 
268f				endm 
# End of macro FORTH_RSP_TOS
268f e5					push hl 
2690					FORTH_RSP_POP 
2690 cd b4 1e			call macro_forth_rsp_pop 
2693				endm 
# End of macro FORTH_RSP_POP
2693 e1					pop hl 
2694			;		ex de,hl 
2694 22 86 f6				ld (os_tok_ptr),hl 
2697			 
2697			if DEBUG_FORTH_UWORD 
2697						DMARK "SCL" 
2697 f5				push af  
2698 3a ac 26			ld a, (.dmark)  
269b 32 b4 fe			ld (debug_mark),a  
269e 3a ad 26			ld a, (.dmark+1)  
26a1 32 b5 fe			ld (debug_mark+1),a  
26a4 3a ae 26			ld a, (.dmark+2)  
26a7 32 b6 fe			ld (debug_mark+2),a  
26aa 18 03			jr .pastdmark  
26ac ..			.dmark: db "SCL"  
26af f1			.pastdmark: pop af  
26b0			endm  
# End of macro DMARK
26b0				CALLMONITOR 
26b0 cd 78 18			call break_point_state  
26b3				endm  
# End of macro CALLMONITOR
26b3			endif 
26b3					NEXTW 
26b3 c3 5a 22			jp macro_next 
26b6				endm 
# End of macro NEXTW
26b6			 
26b6			.DROP: 
26b6				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
26b6 1b				db WORD_SYS_CORE+OPCODE_DROP             
26b7 e1 26			dw .DUP2            
26b9 05				db 4 + 1 
26ba .. 00			db "DROP",0              
26bf				endm 
# End of macro CWHEAD
26bf			; | DROP ( w -- )   drop the TOS item   | DONE 
26bf					if DEBUG_FORTH_WORDS_KEY 
26bf						DMARK "DRP" 
26bf f5				push af  
26c0 3a d4 26			ld a, (.dmark)  
26c3 32 b4 fe			ld (debug_mark),a  
26c6 3a d5 26			ld a, (.dmark+1)  
26c9 32 b5 fe			ld (debug_mark+1),a  
26cc 3a d6 26			ld a, (.dmark+2)  
26cf 32 b6 fe			ld (debug_mark+2),a  
26d2 18 03			jr .pastdmark  
26d4 ..			.dmark: db "DRP"  
26d7 f1			.pastdmark: pop af  
26d8			endm  
# End of macro DMARK
26d8						CALLMONITOR 
26d8 cd 78 18			call break_point_state  
26db				endm  
# End of macro CALLMONITOR
26db					endif 
26db					FORTH_DSP_POP 
26db cd 9b 21			call macro_forth_dsp_pop 
26de				endm 
# End of macro FORTH_DSP_POP
26de					NEXTW 
26de c3 5a 22			jp macro_next 
26e1				endm 
# End of macro NEXTW
26e1			.DUP2: 
26e1				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
26e1 1c				db WORD_SYS_CORE+OPCODE_DUP2             
26e2 26 27			dw .DROP2            
26e4 05				db 4 + 1 
26e5 .. 00			db "2DUP",0              
26ea				endm 
# End of macro CWHEAD
26ea			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
26ea					if DEBUG_FORTH_WORDS_KEY 
26ea						DMARK "2DU" 
26ea f5				push af  
26eb 3a ff 26			ld a, (.dmark)  
26ee 32 b4 fe			ld (debug_mark),a  
26f1 3a 00 27			ld a, (.dmark+1)  
26f4 32 b5 fe			ld (debug_mark+1),a  
26f7 3a 01 27			ld a, (.dmark+2)  
26fa 32 b6 fe			ld (debug_mark+2),a  
26fd 18 03			jr .pastdmark  
26ff ..			.dmark: db "2DU"  
2702 f1			.pastdmark: pop af  
2703			endm  
# End of macro DMARK
2703						CALLMONITOR 
2703 cd 78 18			call break_point_state  
2706				endm  
# End of macro CALLMONITOR
2706					endif 
2706					FORTH_DSP_VALUEHL 
2706 cd e3 20			call macro_dsp_valuehl 
2709				endm 
# End of macro FORTH_DSP_VALUEHL
2709 e5					push hl      ; 2 
270a			 
270a					FORTH_DSP_POP 
270a cd 9b 21			call macro_forth_dsp_pop 
270d				endm 
# End of macro FORTH_DSP_POP
270d					 
270d					FORTH_DSP_VALUEHL 
270d cd e3 20			call macro_dsp_valuehl 
2710				endm 
# End of macro FORTH_DSP_VALUEHL
2710			;		push hl      ; 1 
2710			 
2710					FORTH_DSP_POP 
2710 cd 9b 21			call macro_forth_dsp_pop 
2713				endm 
# End of macro FORTH_DSP_POP
2713			 
2713			;		pop hl       ; 1 
2713 d1					pop de       ; 2 
2714			 
2714 cd ec 1e				call forth_push_numhl 
2717 eb					ex de, hl 
2718 cd ec 1e				call forth_push_numhl 
271b			 
271b					 
271b eb					ex de, hl 
271c			 
271c cd ec 1e				call forth_push_numhl 
271f eb					ex de, hl 
2720 cd ec 1e				call forth_push_numhl 
2723			 
2723			 
2723					NEXTW 
2723 c3 5a 22			jp macro_next 
2726				endm 
# End of macro NEXTW
2726			.DROP2: 
2726				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2726 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2727 55 27			dw .SWAP2            
2729 06				db 5 + 1 
272a .. 00			db "2DROP",0              
2730				endm 
# End of macro CWHEAD
2730			; | 2DROP ( w w -- )    Double drop | DONE 
2730					if DEBUG_FORTH_WORDS_KEY 
2730						DMARK "2DR" 
2730 f5				push af  
2731 3a 45 27			ld a, (.dmark)  
2734 32 b4 fe			ld (debug_mark),a  
2737 3a 46 27			ld a, (.dmark+1)  
273a 32 b5 fe			ld (debug_mark+1),a  
273d 3a 47 27			ld a, (.dmark+2)  
2740 32 b6 fe			ld (debug_mark+2),a  
2743 18 03			jr .pastdmark  
2745 ..			.dmark: db "2DR"  
2748 f1			.pastdmark: pop af  
2749			endm  
# End of macro DMARK
2749						CALLMONITOR 
2749 cd 78 18			call break_point_state  
274c				endm  
# End of macro CALLMONITOR
274c					endif 
274c					FORTH_DSP_POP 
274c cd 9b 21			call macro_forth_dsp_pop 
274f				endm 
# End of macro FORTH_DSP_POP
274f					FORTH_DSP_POP 
274f cd 9b 21			call macro_forth_dsp_pop 
2752				endm 
# End of macro FORTH_DSP_POP
2752					NEXTW 
2752 c3 5a 22			jp macro_next 
2755				endm 
# End of macro NEXTW
2755			.SWAP2: 
2755				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2755 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2756 7e 27			dw .AT            
2758 06				db 5 + 1 
2759 .. 00			db "2SWAP",0              
275f				endm 
# End of macro CWHEAD
275f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
275f					if DEBUG_FORTH_WORDS_KEY 
275f						DMARK "2SW" 
275f f5				push af  
2760 3a 74 27			ld a, (.dmark)  
2763 32 b4 fe			ld (debug_mark),a  
2766 3a 75 27			ld a, (.dmark+1)  
2769 32 b5 fe			ld (debug_mark+1),a  
276c 3a 76 27			ld a, (.dmark+2)  
276f 32 b6 fe			ld (debug_mark+2),a  
2772 18 03			jr .pastdmark  
2774 ..			.dmark: db "2SW"  
2777 f1			.pastdmark: pop af  
2778			endm  
# End of macro DMARK
2778						CALLMONITOR 
2778 cd 78 18			call break_point_state  
277b				endm  
# End of macro CALLMONITOR
277b					endif 
277b					NEXTW 
277b c3 5a 22			jp macro_next 
277e				endm 
# End of macro NEXTW
277e			.AT: 
277e				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
277e 1f				db WORD_SYS_CORE+OPCODE_AT             
277f b0 27			dw .CAT            
2781 02				db 1 + 1 
2782 .. 00			db "@",0              
2784				endm 
# End of macro CWHEAD
2784			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2784			 
2784					if DEBUG_FORTH_WORDS_KEY 
2784						DMARK "AT." 
2784 f5				push af  
2785 3a 99 27			ld a, (.dmark)  
2788 32 b4 fe			ld (debug_mark),a  
278b 3a 9a 27			ld a, (.dmark+1)  
278e 32 b5 fe			ld (debug_mark+1),a  
2791 3a 9b 27			ld a, (.dmark+2)  
2794 32 b6 fe			ld (debug_mark+2),a  
2797 18 03			jr .pastdmark  
2799 ..			.dmark: db "AT."  
279c f1			.pastdmark: pop af  
279d			endm  
# End of macro DMARK
279d						CALLMONITOR 
279d cd 78 18			call break_point_state  
27a0				endm  
# End of macro CALLMONITOR
27a0					endif 
27a0			.getbyteat:	 
27a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27a0 cd e3 20			call macro_dsp_valuehl 
27a3				endm 
# End of macro FORTH_DSP_VALUEHL
27a3					 
27a3			;		push hl 
27a3				 
27a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27a3 cd 9b 21			call macro_forth_dsp_pop 
27a6				endm 
# End of macro FORTH_DSP_POP
27a6			 
27a6			;		pop hl 
27a6			 
27a6 7e					ld a, (hl) 
27a7			 
27a7 6f					ld l, a 
27a8 26 00				ld h, 0 
27aa cd ec 1e				call forth_push_numhl 
27ad			 
27ad					NEXTW 
27ad c3 5a 22			jp macro_next 
27b0				endm 
# End of macro NEXTW
27b0			.CAT: 
27b0				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
27b0 20				db WORD_SYS_CORE+OPCODE_CAT             
27b1 d9 27			dw .BANG            
27b3 03				db 2 + 1 
27b4 .. 00			db "C@",0              
27b7				endm 
# End of macro CWHEAD
27b7			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
27b7					if DEBUG_FORTH_WORDS_KEY 
27b7						DMARK "CAA" 
27b7 f5				push af  
27b8 3a cc 27			ld a, (.dmark)  
27bb 32 b4 fe			ld (debug_mark),a  
27be 3a cd 27			ld a, (.dmark+1)  
27c1 32 b5 fe			ld (debug_mark+1),a  
27c4 3a ce 27			ld a, (.dmark+2)  
27c7 32 b6 fe			ld (debug_mark+2),a  
27ca 18 03			jr .pastdmark  
27cc ..			.dmark: db "CAA"  
27cf f1			.pastdmark: pop af  
27d0			endm  
# End of macro DMARK
27d0						CALLMONITOR 
27d0 cd 78 18			call break_point_state  
27d3				endm  
# End of macro CALLMONITOR
27d3					endif 
27d3 c3 a0 27				jp .getbyteat 
27d6					NEXTW 
27d6 c3 5a 22			jp macro_next 
27d9				endm 
# End of macro NEXTW
27d9			.BANG: 
27d9				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
27d9 21				db WORD_SYS_CORE+OPCODE_BANG             
27da 0f 28			dw .CBANG            
27dc 02				db 1 + 1 
27dd .. 00			db "!",0              
27df				endm 
# End of macro CWHEAD
27df			; | ! ( x w -- ) Store x at address w      | DONE 
27df					if DEBUG_FORTH_WORDS_KEY 
27df						DMARK "BNG" 
27df f5				push af  
27e0 3a f4 27			ld a, (.dmark)  
27e3 32 b4 fe			ld (debug_mark),a  
27e6 3a f5 27			ld a, (.dmark+1)  
27e9 32 b5 fe			ld (debug_mark+1),a  
27ec 3a f6 27			ld a, (.dmark+2)  
27ef 32 b6 fe			ld (debug_mark+2),a  
27f2 18 03			jr .pastdmark  
27f4 ..			.dmark: db "BNG"  
27f7 f1			.pastdmark: pop af  
27f8			endm  
# End of macro DMARK
27f8						CALLMONITOR 
27f8 cd 78 18			call break_point_state  
27fb				endm  
# End of macro CALLMONITOR
27fb					endif 
27fb			 
27fb			.storebyteat:		 
27fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27fb cd e3 20			call macro_dsp_valuehl 
27fe				endm 
# End of macro FORTH_DSP_VALUEHL
27fe					 
27fe e5					push hl 
27ff				 
27ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27ff cd 9b 21			call macro_forth_dsp_pop 
2802				endm 
# End of macro FORTH_DSP_POP
2802			 
2802					; get byte to poke 
2802			 
2802					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2802 cd e3 20			call macro_dsp_valuehl 
2805				endm 
# End of macro FORTH_DSP_VALUEHL
2805 e5					push hl 
2806			 
2806			 
2806					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2806 cd 9b 21			call macro_forth_dsp_pop 
2809				endm 
# End of macro FORTH_DSP_POP
2809			 
2809			 
2809 d1					pop de 
280a e1					pop hl 
280b			 
280b 73					ld (hl),e 
280c			 
280c			 
280c					NEXTW 
280c c3 5a 22			jp macro_next 
280f				endm 
# End of macro NEXTW
280f			.CBANG: 
280f				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
280f 22				db WORD_SYS_CORE+OPCODE_CBANG             
2810 38 28			dw .SCALL            
2812 03				db 2 + 1 
2813 .. 00			db "C!",0              
2816				endm 
# End of macro CWHEAD
2816			; | C!  ( x w -- ) Store x at address w  | DONE 
2816					if DEBUG_FORTH_WORDS_KEY 
2816						DMARK "CBA" 
2816 f5				push af  
2817 3a 2b 28			ld a, (.dmark)  
281a 32 b4 fe			ld (debug_mark),a  
281d 3a 2c 28			ld a, (.dmark+1)  
2820 32 b5 fe			ld (debug_mark+1),a  
2823 3a 2d 28			ld a, (.dmark+2)  
2826 32 b6 fe			ld (debug_mark+2),a  
2829 18 03			jr .pastdmark  
282b ..			.dmark: db "CBA"  
282e f1			.pastdmark: pop af  
282f			endm  
# End of macro DMARK
282f						CALLMONITOR 
282f cd 78 18			call break_point_state  
2832				endm  
# End of macro CALLMONITOR
2832					endif 
2832 c3 fb 27				jp .storebyteat 
2835					NEXTW 
2835 c3 5a 22			jp macro_next 
2838				endm 
# End of macro NEXTW
2838			.SCALL: 
2838				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2838 23				db WORD_SYS_CORE+OPCODE_SCALL             
2839 6c 28			dw .DEPTH            
283b 05				db 4 + 1 
283c .. 00			db "CALL",0              
2841				endm 
# End of macro CWHEAD
2841			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2841					if DEBUG_FORTH_WORDS_KEY 
2841						DMARK "CLL" 
2841 f5				push af  
2842 3a 56 28			ld a, (.dmark)  
2845 32 b4 fe			ld (debug_mark),a  
2848 3a 57 28			ld a, (.dmark+1)  
284b 32 b5 fe			ld (debug_mark+1),a  
284e 3a 58 28			ld a, (.dmark+2)  
2851 32 b6 fe			ld (debug_mark+2),a  
2854 18 03			jr .pastdmark  
2856 ..			.dmark: db "CLL"  
2859 f1			.pastdmark: pop af  
285a			endm  
# End of macro DMARK
285a						CALLMONITOR 
285a cd 78 18			call break_point_state  
285d				endm  
# End of macro CALLMONITOR
285d					endif 
285d			 
285d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285d cd e3 20			call macro_dsp_valuehl 
2860				endm 
# End of macro FORTH_DSP_VALUEHL
2860			 
2860			;		push hl 
2860			 
2860					; destroy value TOS 
2860			 
2860					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2860 cd 9b 21			call macro_forth_dsp_pop 
2863				endm 
# End of macro FORTH_DSP_POP
2863			 
2863						 
2863			;		pop hl 
2863			 
2863					; how to do a call with hl???? save SP? 
2863 cd fe 21				call forth_call_hl 
2866			 
2866			 
2866					; TODO push value back onto stack for another op etc 
2866			 
2866 cd ec 1e				call forth_push_numhl 
2869					NEXTW 
2869 c3 5a 22			jp macro_next 
286c				endm 
# End of macro NEXTW
286c			.DEPTH: 
286c				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
286c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
286d a9 28			dw .OVER            
286f 06				db 5 + 1 
2870 .. 00			db "DEPTH",0              
2876				endm 
# End of macro CWHEAD
2876			; | DEPTH ( -- u ) Push count of stack | DONE 
2876					; take current TOS and remove from base value div by two to get count 
2876					if DEBUG_FORTH_WORDS_KEY 
2876						DMARK "DEP" 
2876 f5				push af  
2877 3a 8b 28			ld a, (.dmark)  
287a 32 b4 fe			ld (debug_mark),a  
287d 3a 8c 28			ld a, (.dmark+1)  
2880 32 b5 fe			ld (debug_mark+1),a  
2883 3a 8d 28			ld a, (.dmark+2)  
2886 32 b6 fe			ld (debug_mark+2),a  
2889 18 03			jr .pastdmark  
288b ..			.dmark: db "DEP"  
288e f1			.pastdmark: pop af  
288f			endm  
# End of macro DMARK
288f						CALLMONITOR 
288f cd 78 18			call break_point_state  
2892				endm  
# End of macro CALLMONITOR
2892					endif 
2892			 
2892			 
2892 2a b2 fb			ld hl, (cli_data_sp) 
2895 11 ec f8			ld de, cli_data_stack 
2898 ed 52			sbc hl,de 
289a				 
289a				; div by size of stack item 
289a			 
289a 5d				ld e,l 
289b 0e 03			ld c, 3 
289d cd 8b 0e			call Div8 
28a0			 
28a0 6f				ld l,a 
28a1 26 00			ld h,0 
28a3			 
28a3				;srl h 
28a3				;rr l 
28a3			 
28a3 cd ec 1e				call forth_push_numhl 
28a6					NEXTW 
28a6 c3 5a 22			jp macro_next 
28a9				endm 
# End of macro NEXTW
28a9			.OVER: 
28a9				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
28a9 42				db WORD_SYS_CORE+46             
28aa f0 28			dw .PAUSE            
28ac 05				db 4 + 1 
28ad .. 00			db "OVER",0              
28b2				endm 
# End of macro CWHEAD
28b2			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
28b2					if DEBUG_FORTH_WORDS_KEY 
28b2						DMARK "OVR" 
28b2 f5				push af  
28b3 3a c7 28			ld a, (.dmark)  
28b6 32 b4 fe			ld (debug_mark),a  
28b9 3a c8 28			ld a, (.dmark+1)  
28bc 32 b5 fe			ld (debug_mark+1),a  
28bf 3a c9 28			ld a, (.dmark+2)  
28c2 32 b6 fe			ld (debug_mark+2),a  
28c5 18 03			jr .pastdmark  
28c7 ..			.dmark: db "OVR"  
28ca f1			.pastdmark: pop af  
28cb			endm  
# End of macro DMARK
28cb						CALLMONITOR 
28cb cd 78 18			call break_point_state  
28ce				endm  
# End of macro CALLMONITOR
28ce					endif 
28ce			 
28ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28ce cd e3 20			call macro_dsp_valuehl 
28d1				endm 
# End of macro FORTH_DSP_VALUEHL
28d1 e5					push hl    ; n2 
28d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d2 cd 9b 21			call macro_forth_dsp_pop 
28d5				endm 
# End of macro FORTH_DSP_POP
28d5			 
28d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d5 cd e3 20			call macro_dsp_valuehl 
28d8				endm 
# End of macro FORTH_DSP_VALUEHL
28d8 e5					push hl    ; n1 
28d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d9 cd 9b 21			call macro_forth_dsp_pop 
28dc				endm 
# End of macro FORTH_DSP_POP
28dc			 
28dc d1					pop de     ; n1 
28dd e1					pop hl     ; n2 
28de			 
28de d5					push de 
28df e5					push hl 
28e0 d5					push de 
28e1			 
28e1					; push back  
28e1			 
28e1 e1					pop hl 
28e2 cd ec 1e				call forth_push_numhl 
28e5 e1					pop hl 
28e6 cd ec 1e				call forth_push_numhl 
28e9 e1					pop hl 
28ea cd ec 1e				call forth_push_numhl 
28ed					NEXTW 
28ed c3 5a 22			jp macro_next 
28f0				endm 
# End of macro NEXTW
28f0			 
28f0			.PAUSE: 
28f0				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
28f0 43				db WORD_SYS_CORE+47             
28f1 25 29			dw .PAUSES            
28f3 08				db 7 + 1 
28f4 .. 00			db "PAUSEMS",0              
28fc				endm 
# End of macro CWHEAD
28fc			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
28fc					if DEBUG_FORTH_WORDS_KEY 
28fc						DMARK "PMS" 
28fc f5				push af  
28fd 3a 11 29			ld a, (.dmark)  
2900 32 b4 fe			ld (debug_mark),a  
2903 3a 12 29			ld a, (.dmark+1)  
2906 32 b5 fe			ld (debug_mark+1),a  
2909 3a 13 29			ld a, (.dmark+2)  
290c 32 b6 fe			ld (debug_mark+2),a  
290f 18 03			jr .pastdmark  
2911 ..			.dmark: db "PMS"  
2914 f1			.pastdmark: pop af  
2915			endm  
# End of macro DMARK
2915						CALLMONITOR 
2915 cd 78 18			call break_point_state  
2918				endm  
# End of macro CALLMONITOR
2918					endif 
2918					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2918 cd e3 20			call macro_dsp_valuehl 
291b				endm 
# End of macro FORTH_DSP_VALUEHL
291b			;		push hl    ; n2 
291b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291b cd 9b 21			call macro_forth_dsp_pop 
291e				endm 
# End of macro FORTH_DSP_POP
291e			;		pop hl 
291e			 
291e 7d					ld a, l 
291f cd 29 0c				call aDelayInMS 
2922				       NEXTW 
2922 c3 5a 22			jp macro_next 
2925				endm 
# End of macro NEXTW
2925			.PAUSES:  
2925				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2925 44				db WORD_SYS_CORE+48             
2926 94 29			dw .ROT            
2928 06				db 5 + 1 
2929 .. 00			db "PAUSE",0              
292f				endm 
# End of macro CWHEAD
292f			; | PAUSE ( n -- )  Pause for n seconds | DONE 
292f					if DEBUG_FORTH_WORDS_KEY 
292f						DMARK "PAU" 
292f f5				push af  
2930 3a 44 29			ld a, (.dmark)  
2933 32 b4 fe			ld (debug_mark),a  
2936 3a 45 29			ld a, (.dmark+1)  
2939 32 b5 fe			ld (debug_mark+1),a  
293c 3a 46 29			ld a, (.dmark+2)  
293f 32 b6 fe			ld (debug_mark+2),a  
2942 18 03			jr .pastdmark  
2944 ..			.dmark: db "PAU"  
2947 f1			.pastdmark: pop af  
2948			endm  
# End of macro DMARK
2948						CALLMONITOR 
2948 cd 78 18			call break_point_state  
294b				endm  
# End of macro CALLMONITOR
294b					endif 
294b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
294b cd e3 20			call macro_dsp_valuehl 
294e				endm 
# End of macro FORTH_DSP_VALUEHL
294e			;		push hl    ; n2 
294e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
294e cd 9b 21			call macro_forth_dsp_pop 
2951				endm 
# End of macro FORTH_DSP_POP
2951			;		pop hl 
2951 45					ld b, l 
2952					if DEBUG_FORTH_WORDS 
2952						DMARK "PAU" 
2952 f5				push af  
2953 3a 67 29			ld a, (.dmark)  
2956 32 b4 fe			ld (debug_mark),a  
2959 3a 68 29			ld a, (.dmark+1)  
295c 32 b5 fe			ld (debug_mark+1),a  
295f 3a 69 29			ld a, (.dmark+2)  
2962 32 b6 fe			ld (debug_mark+2),a  
2965 18 03			jr .pastdmark  
2967 ..			.dmark: db "PAU"  
296a f1			.pastdmark: pop af  
296b			endm  
# End of macro DMARK
296b						CALLMONITOR 
296b cd 78 18			call break_point_state  
296e				endm  
# End of macro CALLMONITOR
296e					endif 
296e c5			.pauses1:	push bc 
296f cd 44 0c				call delay1s 
2972 c1					pop bc 
2973					if DEBUG_FORTH_WORDS 
2973						DMARK "PA1" 
2973 f5				push af  
2974 3a 88 29			ld a, (.dmark)  
2977 32 b4 fe			ld (debug_mark),a  
297a 3a 89 29			ld a, (.dmark+1)  
297d 32 b5 fe			ld (debug_mark+1),a  
2980 3a 8a 29			ld a, (.dmark+2)  
2983 32 b6 fe			ld (debug_mark+2),a  
2986 18 03			jr .pastdmark  
2988 ..			.dmark: db "PA1"  
298b f1			.pastdmark: pop af  
298c			endm  
# End of macro DMARK
298c						CALLMONITOR 
298c cd 78 18			call break_point_state  
298f				endm  
# End of macro CALLMONITOR
298f					endif 
298f 10 dd				djnz .pauses1 
2991			 
2991				       NEXTW 
2991 c3 5a 22			jp macro_next 
2994				endm 
# End of macro NEXTW
2994			.ROT: 
2994				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2994 45				db WORD_SYS_CORE+49             
2995 e2 29			dw .UWORDS            
2997 04				db 3 + 1 
2998 .. 00			db "ROT",0              
299c				endm 
# End of macro CWHEAD
299c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
299c					if DEBUG_FORTH_WORDS_KEY 
299c						DMARK "ROT" 
299c f5				push af  
299d 3a b1 29			ld a, (.dmark)  
29a0 32 b4 fe			ld (debug_mark),a  
29a3 3a b2 29			ld a, (.dmark+1)  
29a6 32 b5 fe			ld (debug_mark+1),a  
29a9 3a b3 29			ld a, (.dmark+2)  
29ac 32 b6 fe			ld (debug_mark+2),a  
29af 18 03			jr .pastdmark  
29b1 ..			.dmark: db "ROT"  
29b4 f1			.pastdmark: pop af  
29b5			endm  
# End of macro DMARK
29b5						CALLMONITOR 
29b5 cd 78 18			call break_point_state  
29b8				endm  
# End of macro CALLMONITOR
29b8					endif 
29b8			 
29b8					FORTH_DSP_VALUEHL 
29b8 cd e3 20			call macro_dsp_valuehl 
29bb				endm 
# End of macro FORTH_DSP_VALUEHL
29bb e5					push hl    ; u3  
29bc			 
29bc					FORTH_DSP_POP 
29bc cd 9b 21			call macro_forth_dsp_pop 
29bf				endm 
# End of macro FORTH_DSP_POP
29bf			   
29bf					FORTH_DSP_VALUEHL 
29bf cd e3 20			call macro_dsp_valuehl 
29c2				endm 
# End of macro FORTH_DSP_VALUEHL
29c2 e5					push hl     ; u2 
29c3			 
29c3					FORTH_DSP_POP 
29c3 cd 9b 21			call macro_forth_dsp_pop 
29c6				endm 
# End of macro FORTH_DSP_POP
29c6			 
29c6					FORTH_DSP_VALUEHL 
29c6 cd e3 20			call macro_dsp_valuehl 
29c9				endm 
# End of macro FORTH_DSP_VALUEHL
29c9 e5					push hl     ; u1 
29ca			 
29ca					FORTH_DSP_POP 
29ca cd 9b 21			call macro_forth_dsp_pop 
29cd				endm 
# End of macro FORTH_DSP_POP
29cd			 
29cd c1					pop bc      ; u1 
29ce e1					pop hl      ; u2 
29cf d1					pop de      ; u3 
29d0			 
29d0			 
29d0 c5					push bc 
29d1 d5					push de 
29d2 e5					push hl 
29d3			 
29d3			 
29d3 e1					pop hl 
29d4 cd ec 1e				call forth_push_numhl 
29d7			 
29d7 e1					pop hl 
29d8 cd ec 1e				call forth_push_numhl 
29db			 
29db e1					pop hl 
29dc cd ec 1e				call forth_push_numhl 
29df					 
29df			 
29df			 
29df			 
29df			 
29df			 
29df				       NEXTW 
29df c3 5a 22			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			 
29e2			.UWORDS: 
29e2				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
29e2 50				db WORD_SYS_CORE+60             
29e3 a4 2a			dw .BP            
29e5 07				db 6 + 1 
29e6 .. 00			db "UWORDS",0              
29ed				endm 
# End of macro CWHEAD
29ed			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
29ed			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
29ed			; | | Following the count are the individual words. 
29ed			; | | 
29ed			; | | e.g. UWORDS 
29ed			; | | BOX DIRLIST 2 
29ed			; | |  
29ed			; | | Can be used to save the words to storage via: 
29ed			; | | UWORDS $01 DO $01 APPEND LOOP 
29ed				if DEBUG_FORTH_WORDS_KEY 
29ed					DMARK "UWR" 
29ed f5				push af  
29ee 3a 02 2a			ld a, (.dmark)  
29f1 32 b4 fe			ld (debug_mark),a  
29f4 3a 03 2a			ld a, (.dmark+1)  
29f7 32 b5 fe			ld (debug_mark+1),a  
29fa 3a 04 2a			ld a, (.dmark+2)  
29fd 32 b6 fe			ld (debug_mark+2),a  
2a00 18 03			jr .pastdmark  
2a02 ..			.dmark: db "UWR"  
2a05 f1			.pastdmark: pop af  
2a06			endm  
# End of macro DMARK
2a06					CALLMONITOR 
2a06 cd 78 18			call break_point_state  
2a09				endm  
# End of macro CALLMONITOR
2a09				endif 
2a09 21 00 80				ld hl, baseram 
2a0c					;ld hl, baseusermem 
2a0c 01 00 00				ld bc, 0    ; start a counter 
2a0f			 
2a0f				; skip dict stub 
2a0f			 
2a0f cd ab 23				call forth_tok_next 
2a12			 
2a12			 
2a12			; while we have words to look for 
2a12			 
2a12 7e			.douscan:	ld a, (hl)      
2a13				if DEBUG_FORTH_WORDS 
2a13					DMARK "UWs" 
2a13 f5				push af  
2a14 3a 28 2a			ld a, (.dmark)  
2a17 32 b4 fe			ld (debug_mark),a  
2a1a 3a 29 2a			ld a, (.dmark+1)  
2a1d 32 b5 fe			ld (debug_mark+1),a  
2a20 3a 2a 2a			ld a, (.dmark+2)  
2a23 32 b6 fe			ld (debug_mark+2),a  
2a26 18 03			jr .pastdmark  
2a28 ..			.dmark: db "UWs"  
2a2b f1			.pastdmark: pop af  
2a2c			endm  
# End of macro DMARK
2a2c					CALLMONITOR 
2a2c cd 78 18			call break_point_state  
2a2f				endm  
# End of macro CALLMONITOR
2a2f				endif 
2a2f fe 00				cp WORD_SYS_END 
2a31 28 4d				jr z, .udone 
2a33 fe 01				cp WORD_SYS_UWORD 
2a35 20 44				jr nz, .nuword 
2a37			 
2a37				if DEBUG_FORTH_WORDS 
2a37					DMARK "UWu" 
2a37 f5				push af  
2a38 3a 4c 2a			ld a, (.dmark)  
2a3b 32 b4 fe			ld (debug_mark),a  
2a3e 3a 4d 2a			ld a, (.dmark+1)  
2a41 32 b5 fe			ld (debug_mark+1),a  
2a44 3a 4e 2a			ld a, (.dmark+2)  
2a47 32 b6 fe			ld (debug_mark+2),a  
2a4a 18 03			jr .pastdmark  
2a4c ..			.dmark: db "UWu"  
2a4f f1			.pastdmark: pop af  
2a50			endm  
# End of macro DMARK
2a50					CALLMONITOR 
2a50 cd 78 18			call break_point_state  
2a53				endm  
# End of macro CALLMONITOR
2a53				endif 
2a53					; we have a uword so push its name to the stack 
2a53			 
2a53 e5				   	push hl  ; save so we can move to next dict block 
2a54			 
2a54					; skip opcode 
2a54 23					inc hl  
2a55					; skip next ptr 
2a55 23					inc hl  
2a56 23					inc hl 
2a57					; skip len 
2a57 23					inc hl 
2a58				if DEBUG_FORTH_WORDS 
2a58					DMARK "UWt" 
2a58 f5				push af  
2a59 3a 6d 2a			ld a, (.dmark)  
2a5c 32 b4 fe			ld (debug_mark),a  
2a5f 3a 6e 2a			ld a, (.dmark+1)  
2a62 32 b5 fe			ld (debug_mark+1),a  
2a65 3a 6f 2a			ld a, (.dmark+2)  
2a68 32 b6 fe			ld (debug_mark+2),a  
2a6b 18 03			jr .pastdmark  
2a6d ..			.dmark: db "UWt"  
2a70 f1			.pastdmark: pop af  
2a71			endm  
# End of macro DMARK
2a71					CALLMONITOR 
2a71 cd 78 18			call break_point_state  
2a74				endm  
# End of macro CALLMONITOR
2a74				endif 
2a74 03					inc bc 
2a75			 
2a75 c5					push bc 
2a76 cd 5a 1f				call forth_push_str 
2a79 c1					pop bc 
2a7a			 
2a7a e1					pop hl 	 
2a7b			 
2a7b cd ab 23		.nuword:	call forth_tok_next 
2a7e 18 92				jr .douscan  
2a80			 
2a80			.udone:		 ; push count of uwords found 
2a80 c5					push bc 
2a81 e1					pop hl 
2a82			 
2a82				if DEBUG_FORTH_WORDS 
2a82					DMARK "UWc" 
2a82 f5				push af  
2a83 3a 97 2a			ld a, (.dmark)  
2a86 32 b4 fe			ld (debug_mark),a  
2a89 3a 98 2a			ld a, (.dmark+1)  
2a8c 32 b5 fe			ld (debug_mark+1),a  
2a8f 3a 99 2a			ld a, (.dmark+2)  
2a92 32 b6 fe			ld (debug_mark+2),a  
2a95 18 03			jr .pastdmark  
2a97 ..			.dmark: db "UWc"  
2a9a f1			.pastdmark: pop af  
2a9b			endm  
# End of macro DMARK
2a9b					CALLMONITOR 
2a9b cd 78 18			call break_point_state  
2a9e				endm  
# End of macro CALLMONITOR
2a9e				endif 
2a9e cd ec 1e				call forth_push_numhl 
2aa1			 
2aa1			 
2aa1				       NEXTW 
2aa1 c3 5a 22			jp macro_next 
2aa4				endm 
# End of macro NEXTW
2aa4			 
2aa4			.BP: 
2aa4				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2aa4 54				db WORD_SYS_CORE+64             
2aa5 da 2a			dw .MONITOR            
2aa7 03				db 2 + 1 
2aa8 .. 00			db "BP",0              
2aab				endm 
# End of macro CWHEAD
2aab			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2aab			; | | $00 Will enable the break points within specific code paths 
2aab			; | | $01 Will disable break points 
2aab			; | |  
2aab			; | | By default break points are off. Either the above can be used to enable them 
2aab			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2aab			; | | and on release of the pressed key a message will be disaplayed to notify 
2aab			; | | that break points are enabled. Pressing any key will then continue boot process. 
2aab					; get byte count 
2aab					if DEBUG_FORTH_WORDS_KEY 
2aab						DMARK "BP." 
2aab f5				push af  
2aac 3a c0 2a			ld a, (.dmark)  
2aaf 32 b4 fe			ld (debug_mark),a  
2ab2 3a c1 2a			ld a, (.dmark+1)  
2ab5 32 b5 fe			ld (debug_mark+1),a  
2ab8 3a c2 2a			ld a, (.dmark+2)  
2abb 32 b6 fe			ld (debug_mark+2),a  
2abe 18 03			jr .pastdmark  
2ac0 ..			.dmark: db "BP."  
2ac3 f1			.pastdmark: pop af  
2ac4			endm  
# End of macro DMARK
2ac4						CALLMONITOR 
2ac4 cd 78 18			call break_point_state  
2ac7				endm  
# End of macro CALLMONITOR
2ac7					endif 
2ac7			 
2ac7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac7 cd e3 20			call macro_dsp_valuehl 
2aca				endm 
# End of macro FORTH_DSP_VALUEHL
2aca			 
2aca			;		push hl 
2aca			 
2aca					; destroy value TOS 
2aca			 
2aca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aca cd 9b 21			call macro_forth_dsp_pop 
2acd				endm 
# End of macro FORTH_DSP_POP
2acd			 
2acd			;		pop hl 
2acd			 
2acd 3e 00				ld a,0 
2acf bd					cp l 
2ad0 28 02				jr z, .bpset 
2ad2 3e 2a				ld a, '*' 
2ad4			 
2ad4 32 76 f3		.bpset:		ld (os_view_disable), a 
2ad7			 
2ad7			 
2ad7					NEXTW 
2ad7 c3 5a 22			jp macro_next 
2ada				endm 
# End of macro NEXTW
2ada			 
2ada			 
2ada			.MONITOR: 
2ada				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2ada 55				db WORD_SYS_CORE+65             
2adb 0d 2b			dw .MALLOC            
2add 08				db 7 + 1 
2ade .. 00			db "MONITOR",0              
2ae6				endm 
# End of macro CWHEAD
2ae6			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2ae6			; | | At start the current various registers will be displayed with contents. 
2ae6			; | | Top right corner will show the most recent debug marker seen. 
2ae6			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2ae6			; | | and the return stack pointer (RSP). 
2ae6			; | | Pressing: 
2ae6			; | |    1 - Initial screen 
2ae6			; | |    2 - Display a data dump of HL 
2ae6			; | |    3 - Display a data dump of DE 
2ae6			; | |    4 - Display a data dump of BC 
2ae6			; | |    5 - Display a data dump of HL 
2ae6			; | |    6 - Display a data dump of DSP 
2ae6			; | |    7 - Display a data dump of RSP 
2ae6			; | |    8 - Display a data dump of what is at DSP 
2ae6			; | |    9 - Display a data dump of what is at RSP 
2ae6			; | |    0 - Exit monitor and continue running. This will also enable break points 
2ae6			; | |    * - Disable break points 
2ae6			; | |    # - Enter traditional monitor mode 
2ae6			; | | 
2ae6			; | | Monitor Mode 
2ae6			; | | ------------ 
2ae6			; | | A prompt of '>' will be shown for various commands: 
2ae6			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2ae6			; | |    C - Continue display a data dump from the last set address 
2ae6			; | |    M xxxx - Set start of memory edit at address xx 
2ae6			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2ae6			; | |    Q - Return to previous 
2ae6					if DEBUG_FORTH_WORDS_KEY 
2ae6						DMARK "MON" 
2ae6 f5				push af  
2ae7 3a fb 2a			ld a, (.dmark)  
2aea 32 b4 fe			ld (debug_mark),a  
2aed 3a fc 2a			ld a, (.dmark+1)  
2af0 32 b5 fe			ld (debug_mark+1),a  
2af3 3a fd 2a			ld a, (.dmark+2)  
2af6 32 b6 fe			ld (debug_mark+2),a  
2af9 18 03			jr .pastdmark  
2afb ..			.dmark: db "MON"  
2afe f1			.pastdmark: pop af  
2aff			endm  
# End of macro DMARK
2aff						CALLMONITOR 
2aff cd 78 18			call break_point_state  
2b02				endm  
# End of macro CALLMONITOR
2b02					endif 
2b02 3e 00				ld a, 0 
2b04 32 76 f3				ld (os_view_disable), a 
2b07			 
2b07					CALLMONITOR 
2b07 cd 78 18			call break_point_state  
2b0a				endm  
# End of macro CALLMONITOR
2b0a			 
2b0a			;	call monitor 
2b0a			 
2b0a					NEXTW 
2b0a c3 5a 22			jp macro_next 
2b0d				endm 
# End of macro NEXTW
2b0d			 
2b0d			 
2b0d			.MALLOC: 
2b0d				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b0d 56				db WORD_SYS_CORE+66             
2b0e 36 2b			dw .MALLOC2            
2b10 06				db 5 + 1 
2b11 .. 00			db "ALLOT",0              
2b17				endm 
# End of macro CWHEAD
2b17			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b17					if DEBUG_FORTH_WORDS_KEY 
2b17						DMARK "ALL" 
2b17 f5				push af  
2b18 3a 2c 2b			ld a, (.dmark)  
2b1b 32 b4 fe			ld (debug_mark),a  
2b1e 3a 2d 2b			ld a, (.dmark+1)  
2b21 32 b5 fe			ld (debug_mark+1),a  
2b24 3a 2e 2b			ld a, (.dmark+2)  
2b27 32 b6 fe			ld (debug_mark+2),a  
2b2a 18 03			jr .pastdmark  
2b2c ..			.dmark: db "ALL"  
2b2f f1			.pastdmark: pop af  
2b30			endm  
# End of macro DMARK
2b30						CALLMONITOR 
2b30 cd 78 18			call break_point_state  
2b33				endm  
# End of macro CALLMONITOR
2b33					endif 
2b33 c3 5d 2b				jp .mallocc 
2b36			.MALLOC2: 
2b36				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b36 56				db WORD_SYS_CORE+66             
2b37 74 2b			dw .FREE            
2b39 07				db 6 + 1 
2b3a .. 00			db "MALLOC",0              
2b41				endm 
# End of macro CWHEAD
2b41			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b41					; get byte count 
2b41					if DEBUG_FORTH_WORDS_KEY 
2b41						DMARK "MAL" 
2b41 f5				push af  
2b42 3a 56 2b			ld a, (.dmark)  
2b45 32 b4 fe			ld (debug_mark),a  
2b48 3a 57 2b			ld a, (.dmark+1)  
2b4b 32 b5 fe			ld (debug_mark+1),a  
2b4e 3a 58 2b			ld a, (.dmark+2)  
2b51 32 b6 fe			ld (debug_mark+2),a  
2b54 18 03			jr .pastdmark  
2b56 ..			.dmark: db "MAL"  
2b59 f1			.pastdmark: pop af  
2b5a			endm  
# End of macro DMARK
2b5a						CALLMONITOR 
2b5a cd 78 18			call break_point_state  
2b5d				endm  
# End of macro CALLMONITOR
2b5d					endif 
2b5d			.mallocc: 
2b5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b5d cd e3 20			call macro_dsp_valuehl 
2b60				endm 
# End of macro FORTH_DSP_VALUEHL
2b60			 
2b60			;		push hl 
2b60			 
2b60					; destroy value TOS 
2b60			 
2b60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b60 cd 9b 21			call macro_forth_dsp_pop 
2b63				endm 
# End of macro FORTH_DSP_POP
2b63			 
2b63			;		pop hl 
2b63 cd c2 13				call malloc 
2b66				if DEBUG_FORTH_MALLOC_GUARD 
2b66 f5					push af 
2b67 cd 24 0f				call ishlzero 
2b6a			;		ld a, l 
2b6a			;		add h 
2b6a			;		cp 0 
2b6a f1					pop af 
2b6b					 
2b6b cc 2d 55				call z,malloc_error 
2b6e				endif 
2b6e			 
2b6e cd ec 1e				call forth_push_numhl 
2b71					NEXTW 
2b71 c3 5a 22			jp macro_next 
2b74				endm 
# End of macro NEXTW
2b74			 
2b74			.FREE: 
2b74				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2b74 57				db WORD_SYS_CORE+67             
2b75 a5 2b			dw .LIST            
2b77 05				db 4 + 1 
2b78 .. 00			db "FREE",0              
2b7d				endm 
# End of macro CWHEAD
2b7d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2b7d					if DEBUG_FORTH_WORDS_KEY 
2b7d						DMARK "FRE" 
2b7d f5				push af  
2b7e 3a 92 2b			ld a, (.dmark)  
2b81 32 b4 fe			ld (debug_mark),a  
2b84 3a 93 2b			ld a, (.dmark+1)  
2b87 32 b5 fe			ld (debug_mark+1),a  
2b8a 3a 94 2b			ld a, (.dmark+2)  
2b8d 32 b6 fe			ld (debug_mark+2),a  
2b90 18 03			jr .pastdmark  
2b92 ..			.dmark: db "FRE"  
2b95 f1			.pastdmark: pop af  
2b96			endm  
# End of macro DMARK
2b96						CALLMONITOR 
2b96 cd 78 18			call break_point_state  
2b99				endm  
# End of macro CALLMONITOR
2b99					endif 
2b99					; get address 
2b99			 
2b99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b99 cd e3 20			call macro_dsp_valuehl 
2b9c				endm 
# End of macro FORTH_DSP_VALUEHL
2b9c			 
2b9c			;		push hl 
2b9c			 
2b9c					; destroy value TOS 
2b9c			 
2b9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b9c cd 9b 21			call macro_forth_dsp_pop 
2b9f				endm 
# End of macro FORTH_DSP_POP
2b9f			 
2b9f			;		pop hl 
2b9f			if FORTH_ENABLE_MALLOCFREE 
2b9f cd 8c 14				call free 
2ba2			endif 
2ba2					NEXTW 
2ba2 c3 5a 22			jp macro_next 
2ba5				endm 
# End of macro NEXTW
2ba5			.LIST: 
2ba5				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2ba5 5c				db WORD_SYS_CORE+72             
2ba6 93 2d			dw .FORGET            
2ba8 05				db 4 + 1 
2ba9 .. 00			db "LIST",0              
2bae				endm 
# End of macro CWHEAD
2bae			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2bae			; | | The quoted word must be in upper case. 
2bae				if DEBUG_FORTH_WORDS_KEY 
2bae					DMARK "LST" 
2bae f5				push af  
2baf 3a c3 2b			ld a, (.dmark)  
2bb2 32 b4 fe			ld (debug_mark),a  
2bb5 3a c4 2b			ld a, (.dmark+1)  
2bb8 32 b5 fe			ld (debug_mark+1),a  
2bbb 3a c5 2b			ld a, (.dmark+2)  
2bbe 32 b6 fe			ld (debug_mark+2),a  
2bc1 18 03			jr .pastdmark  
2bc3 ..			.dmark: db "LST"  
2bc6 f1			.pastdmark: pop af  
2bc7			endm  
# End of macro DMARK
2bc7					CALLMONITOR 
2bc7 cd 78 18			call break_point_state  
2bca				endm  
# End of macro CALLMONITOR
2bca				endif 
2bca			 
2bca					FORTH_DSP_VALUEHL 
2bca cd e3 20			call macro_dsp_valuehl 
2bcd				endm 
# End of macro FORTH_DSP_VALUEHL
2bcd			 
2bcd e5					push hl 
2bce					FORTH_DSP_POP 
2bce cd 9b 21			call macro_forth_dsp_pop 
2bd1				endm 
# End of macro FORTH_DSP_POP
2bd1 c1					pop bc 
2bd2			 
2bd2			; Start format of scratch string 
2bd2			 
2bd2 21 85 f3				ld hl, scratch 
2bd5			 
2bd5 3e 3a				ld a, ':' 
2bd7 77					ld (hl),a 
2bd8 23					inc hl 
2bd9 3e 20				ld a, ' ' 
2bdb 77					ld (hl), a 
2bdc			 
2bdc					; Get ptr to the word we need to look up 
2bdc			 
2bdc			;		FORTH_DSP_VALUEHL 
2bdc					;v5 FORTH_DSP_VALUE 
2bdc				; TODO type check 
2bdc			;		inc hl    ; Skip type check  
2bdc			;		push hl 
2bdc			;		ex de, hl    ; put into DE 
2bdc			 
2bdc			 
2bdc 21 00 80				ld hl, baseram 
2bdf					;ld hl, baseusermem 
2bdf			 
2bdf e5			push hl   ; sacreifical push 
2be0			 
2be0			.ldouscanm: 
2be0 e1				pop hl 
2be1			.ldouscan: 
2be1				if DEBUG_FORTH_WORDS 
2be1					DMARK "LSs" 
2be1 f5				push af  
2be2 3a f6 2b			ld a, (.dmark)  
2be5 32 b4 fe			ld (debug_mark),a  
2be8 3a f7 2b			ld a, (.dmark+1)  
2beb 32 b5 fe			ld (debug_mark+1),a  
2bee 3a f8 2b			ld a, (.dmark+2)  
2bf1 32 b6 fe			ld (debug_mark+2),a  
2bf4 18 03			jr .pastdmark  
2bf6 ..			.dmark: db "LSs"  
2bf9 f1			.pastdmark: pop af  
2bfa			endm  
# End of macro DMARK
2bfa					CALLMONITOR 
2bfa cd 78 18			call break_point_state  
2bfd				endm  
# End of macro CALLMONITOR
2bfd				endif 
2bfd				; skip dict stub 
2bfd cd ab 23				call forth_tok_next 
2c00			 
2c00			 
2c00			; while we have words to look for 
2c00			 
2c00 7e				ld a, (hl)      
2c01				if DEBUG_FORTH_WORDS 
2c01					DMARK "LSk" 
2c01 f5				push af  
2c02 3a 16 2c			ld a, (.dmark)  
2c05 32 b4 fe			ld (debug_mark),a  
2c08 3a 17 2c			ld a, (.dmark+1)  
2c0b 32 b5 fe			ld (debug_mark+1),a  
2c0e 3a 18 2c			ld a, (.dmark+2)  
2c11 32 b6 fe			ld (debug_mark+2),a  
2c14 18 03			jr .pastdmark  
2c16 ..			.dmark: db "LSk"  
2c19 f1			.pastdmark: pop af  
2c1a			endm  
# End of macro DMARK
2c1a					CALLMONITOR 
2c1a cd 78 18			call break_point_state  
2c1d				endm  
# End of macro CALLMONITOR
2c1d				endif 
2c1d					;cp WORD_SYS_END 
2c1d					;jp z, .lunotfound 
2c1d			 
2c1d					; if we hit non uwords then gone too far 
2c1d fe 01				cp WORD_SYS_UWORD 
2c1f c2 4f 2d				jp nz, .lunotfound 
2c22			 
2c22				if DEBUG_FORTH_WORDS 
2c22					DMARK "LSu" 
2c22 f5				push af  
2c23 3a 37 2c			ld a, (.dmark)  
2c26 32 b4 fe			ld (debug_mark),a  
2c29 3a 38 2c			ld a, (.dmark+1)  
2c2c 32 b5 fe			ld (debug_mark+1),a  
2c2f 3a 39 2c			ld a, (.dmark+2)  
2c32 32 b6 fe			ld (debug_mark+2),a  
2c35 18 03			jr .pastdmark  
2c37 ..			.dmark: db "LSu"  
2c3a f1			.pastdmark: pop af  
2c3b			endm  
# End of macro DMARK
2c3b					CALLMONITOR 
2c3b cd 78 18			call break_point_state  
2c3e				endm  
# End of macro CALLMONITOR
2c3e				endif 
2c3e			 
2c3e					; found a uword but is it the one we want... 
2c3e			 
2c3e c5					push bc     ; uword to find is on bc 
2c3f d1					pop de 
2c40			 
2c40 e5					push hl  ; to save the ptr 
2c41			 
2c41					; skip opcode 
2c41 23					inc hl  
2c42					; skip next ptr 
2c42 23					inc hl  
2c43 23					inc hl 
2c44					; skip len 
2c44 23					inc hl 
2c45			 
2c45				if DEBUG_FORTH_WORDS 
2c45					DMARK "LSc" 
2c45 f5				push af  
2c46 3a 5a 2c			ld a, (.dmark)  
2c49 32 b4 fe			ld (debug_mark),a  
2c4c 3a 5b 2c			ld a, (.dmark+1)  
2c4f 32 b5 fe			ld (debug_mark+1),a  
2c52 3a 5c 2c			ld a, (.dmark+2)  
2c55 32 b6 fe			ld (debug_mark+2),a  
2c58 18 03			jr .pastdmark  
2c5a ..			.dmark: db "LSc"  
2c5d f1			.pastdmark: pop af  
2c5e			endm  
# End of macro DMARK
2c5e					CALLMONITOR 
2c5e cd 78 18			call break_point_state  
2c61				endm  
# End of macro CALLMONITOR
2c61				endif 
2c61 cd 91 13				call strcmp 
2c64 c2 e0 2b				jp nz, .ldouscanm 
2c67				 
2c67			 
2c67			 
2c67					; we have a uword so push its name to the stack 
2c67			 
2c67			;	   	push hl  ; save so we can move to next dict block 
2c67 e1			pop hl 
2c68			 
2c68				if DEBUG_FORTH_WORDS 
2c68					DMARK "LSm" 
2c68 f5				push af  
2c69 3a 7d 2c			ld a, (.dmark)  
2c6c 32 b4 fe			ld (debug_mark),a  
2c6f 3a 7e 2c			ld a, (.dmark+1)  
2c72 32 b5 fe			ld (debug_mark+1),a  
2c75 3a 7f 2c			ld a, (.dmark+2)  
2c78 32 b6 fe			ld (debug_mark+2),a  
2c7b 18 03			jr .pastdmark  
2c7d ..			.dmark: db "LSm"  
2c80 f1			.pastdmark: pop af  
2c81			endm  
# End of macro DMARK
2c81					CALLMONITOR 
2c81 cd 78 18			call break_point_state  
2c84				endm  
# End of macro CALLMONITOR
2c84				endif 
2c84			 
2c84					; skip opcode 
2c84 23					inc hl  
2c85					; skip next ptr 
2c85 23					inc hl  
2c86 23					inc hl 
2c87					; skip len 
2c87 7e					ld a, (hl)   ; save length to add 
2c88				if DEBUG_FORTH_WORDS 
2c88					DMARK "LS2" 
2c88 f5				push af  
2c89 3a 9d 2c			ld a, (.dmark)  
2c8c 32 b4 fe			ld (debug_mark),a  
2c8f 3a 9e 2c			ld a, (.dmark+1)  
2c92 32 b5 fe			ld (debug_mark+1),a  
2c95 3a 9f 2c			ld a, (.dmark+2)  
2c98 32 b6 fe			ld (debug_mark+2),a  
2c9b 18 03			jr .pastdmark  
2c9d ..			.dmark: db "LS2"  
2ca0 f1			.pastdmark: pop af  
2ca1			endm  
# End of macro DMARK
2ca1					CALLMONITOR 
2ca1 cd 78 18			call break_point_state  
2ca4				endm  
# End of macro CALLMONITOR
2ca4				endif 
2ca4			 
2ca4					; save this location 
2ca4				 
2ca4 e5					push hl 
2ca5			 
2ca5 23					inc hl 
2ca6 11 87 f3				ld de, scratch+2 
2ca9 4f					ld c, a 
2caa 06 00				ld b, 0 
2cac			 
2cac				if DEBUG_FORTH_WORDS 
2cac					DMARK "LSn" 
2cac f5				push af  
2cad 3a c1 2c			ld a, (.dmark)  
2cb0 32 b4 fe			ld (debug_mark),a  
2cb3 3a c2 2c			ld a, (.dmark+1)  
2cb6 32 b5 fe			ld (debug_mark+1),a  
2cb9 3a c3 2c			ld a, (.dmark+2)  
2cbc 32 b6 fe			ld (debug_mark+2),a  
2cbf 18 03			jr .pastdmark  
2cc1 ..			.dmark: db "LSn"  
2cc4 f1			.pastdmark: pop af  
2cc5			endm  
# End of macro DMARK
2cc5					CALLMONITOR 
2cc5 cd 78 18			call break_point_state  
2cc8				endm  
# End of macro CALLMONITOR
2cc8				endif 
2cc8			 
2cc8					; copy uword name to scratch 
2cc8			 
2cc8 ed b0				ldir 
2cca			 
2cca 1b					dec de 
2ccb 3e 20				ld a, ' '    ; change null to space 
2ccd 12					ld (de), a 
2cce			 
2cce 13					inc de 
2ccf			 
2ccf d5					push de 
2cd0 c1					pop bc     ; move scratch pointer to end of word name and save it 
2cd1			 
2cd1 e1					pop hl 
2cd2 7e					ld a, (hl) 
2cd3					;inc hl 
2cd3					; skip word string 
2cd3 cd fb 0e				call addatohl 
2cd6			 
2cd6 23					inc hl 
2cd7			 
2cd7				if DEBUG_FORTH_WORDS 
2cd7					DMARK "LS3" 
2cd7 f5				push af  
2cd8 3a ec 2c			ld a, (.dmark)  
2cdb 32 b4 fe			ld (debug_mark),a  
2cde 3a ed 2c			ld a, (.dmark+1)  
2ce1 32 b5 fe			ld (debug_mark+1),a  
2ce4 3a ee 2c			ld a, (.dmark+2)  
2ce7 32 b6 fe			ld (debug_mark+2),a  
2cea 18 03			jr .pastdmark  
2cec ..			.dmark: db "LS3"  
2cef f1			.pastdmark: pop af  
2cf0			endm  
# End of macro DMARK
2cf0					CALLMONITOR 
2cf0 cd 78 18			call break_point_state  
2cf3				endm  
# End of macro CALLMONITOR
2cf3				endif 
2cf3					; should now be at the start of the machine code to setup the eval of the uword 
2cf3					; now locate the ptr to the string defintion 
2cf3			 
2cf3					; skip ld hl, 
2cf3					; then load the ptr 
2cf3			; TODO use get from hl ptr 
2cf3 23					inc hl 
2cf4 5e					ld e, (hl) 
2cf5 23					inc hl 
2cf6 56					ld d, (hl) 
2cf7 eb					ex de, hl 
2cf8			 
2cf8			 
2cf8				if DEBUG_FORTH_WORDS 
2cf8					DMARK "LSt" 
2cf8 f5				push af  
2cf9 3a 0d 2d			ld a, (.dmark)  
2cfc 32 b4 fe			ld (debug_mark),a  
2cff 3a 0e 2d			ld a, (.dmark+1)  
2d02 32 b5 fe			ld (debug_mark+1),a  
2d05 3a 0f 2d			ld a, (.dmark+2)  
2d08 32 b6 fe			ld (debug_mark+2),a  
2d0b 18 03			jr .pastdmark  
2d0d ..			.dmark: db "LSt"  
2d10 f1			.pastdmark: pop af  
2d11			endm  
# End of macro DMARK
2d11					CALLMONITOR 
2d11 cd 78 18			call break_point_state  
2d14				endm  
# End of macro CALLMONITOR
2d14				endif 
2d14			 
2d14			; cant push right now due to tokenised strings  
2d14			 
2d14			; get the destination of where to copy this definition to. 
2d14			 
2d14 c5					push bc 
2d15 d1					pop de 
2d16			 
2d16 7e			.listl:         ld a,(hl) 
2d17 fe 00				cp 0 
2d19 28 09				jr z, .lreplsp     ; replace zero with space 
2d1b					;cp FORTH_END_BUFFER 
2d1b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d1d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d1f				 
2d1f					; just copy this char as is then 
2d1f			 
2d1f 12					ld (de), a 
2d20			 
2d20 23			.listnxt:	inc hl 
2d21 13					inc de 
2d22 18 f2				jr .listl 
2d24			 
2d24 3e 20		.lreplsp:	ld a,' ' 
2d26 12					ld (de), a 
2d27 18 f7				jr .listnxt 
2d29			 
2d29			; close up uword def 
2d29			 
2d29			.listdone: 
2d29 12					ld (de), a 
2d2a 13					inc de 
2d2b 3e 00				ld a, 0 
2d2d 12					ld (de), a 
2d2e			 
2d2e			; now have def so clean up and push to stack 
2d2e			 
2d2e 21 85 f3				ld hl, scratch 
2d31				if DEBUG_FORTH_WORDS 
2d31					DMARK "Ltp" 
2d31 f5				push af  
2d32 3a 46 2d			ld a, (.dmark)  
2d35 32 b4 fe			ld (debug_mark),a  
2d38 3a 47 2d			ld a, (.dmark+1)  
2d3b 32 b5 fe			ld (debug_mark+1),a  
2d3e 3a 48 2d			ld a, (.dmark+2)  
2d41 32 b6 fe			ld (debug_mark+2),a  
2d44 18 03			jr .pastdmark  
2d46 ..			.dmark: db "Ltp"  
2d49 f1			.pastdmark: pop af  
2d4a			endm  
# End of macro DMARK
2d4a					CALLMONITOR 
2d4a cd 78 18			call break_point_state  
2d4d				endm  
# End of macro CALLMONITOR
2d4d				endif 
2d4d			 
2d4d 18 1f			jr .listpush 
2d4f			 
2d4f			;.lnuword:	pop hl 
2d4f			;		call forth_tok_next 
2d4f			;		jp .ldouscan  
2d4f			 
2d4f			.lunotfound:		  
2d4f			 
2d4f				if DEBUG_FORTH_WORDS 
2d4f					DMARK "LSn" 
2d4f f5				push af  
2d50 3a 64 2d			ld a, (.dmark)  
2d53 32 b4 fe			ld (debug_mark),a  
2d56 3a 65 2d			ld a, (.dmark+1)  
2d59 32 b5 fe			ld (debug_mark+1),a  
2d5c 3a 66 2d			ld a, (.dmark+2)  
2d5f 32 b6 fe			ld (debug_mark+2),a  
2d62 18 03			jr .pastdmark  
2d64 ..			.dmark: db "LSn"  
2d67 f1			.pastdmark: pop af  
2d68			endm  
# End of macro DMARK
2d68					CALLMONITOR 
2d68 cd 78 18			call break_point_state  
2d6b				endm  
# End of macro CALLMONITOR
2d6b				endif 
2d6b			 
2d6b					 
2d6b			;		FORTH_DSP_POP 
2d6b			;		ld hl, .luno 
2d6b			 
2d6b					NEXTW			 
2d6b c3 5a 22			jp macro_next 
2d6e				endm 
# End of macro NEXTW
2d6e			 
2d6e			.listpush: 
2d6e				if DEBUG_FORTH_WORDS 
2d6e					DMARK "LS>" 
2d6e f5				push af  
2d6f 3a 83 2d			ld a, (.dmark)  
2d72 32 b4 fe			ld (debug_mark),a  
2d75 3a 84 2d			ld a, (.dmark+1)  
2d78 32 b5 fe			ld (debug_mark+1),a  
2d7b 3a 85 2d			ld a, (.dmark+2)  
2d7e 32 b6 fe			ld (debug_mark+2),a  
2d81 18 03			jr .pastdmark  
2d83 ..			.dmark: db "LS>"  
2d86 f1			.pastdmark: pop af  
2d87			endm  
# End of macro DMARK
2d87					CALLMONITOR 
2d87 cd 78 18			call break_point_state  
2d8a				endm  
# End of macro CALLMONITOR
2d8a				endif 
2d8a cd 5a 1f				call forth_push_str 
2d8d			 
2d8d			 
2d8d			 
2d8d					NEXTW 
2d8d c3 5a 22			jp macro_next 
2d90				endm 
# End of macro NEXTW
2d90			 
2d90			;.luno:    db "Word not found",0 
2d90			 
2d90			 
2d90			 
2d90			 
2d90			 
2d90			;		push hl   ; save pointer to start of uword def string 
2d90			; 
2d90			;; look for FORTH_EOL_LINE 
2d90			;		ld a, FORTH_END_BUFFER 
2d90			;		call strlent 
2d90			; 
2d90			;		inc hl		 ; space for coln def 
2d90			;		inc hl 
2d90			;		inc hl          ; space for terms 
2d90			;		inc hl 
2d90			; 
2d90			;		ld a, 20   ; TODO get actual length 
2d90			;		call addatohl    ; include a random amount of room for the uword name 
2d90			; 
2d90			;		 
2d90			;	if DEBUG_FORTH_WORDS 
2d90			;		DMARK "Lt1" 
2d90			;		CALLMONITOR 
2d90			;	endif 
2d90			;		 
2d90			; 
2d90			;; malloc space for the string because we cant change it 
2d90			; 
2d90			;		call malloc 
2d90			;	if DEBUG_FORTH_MALLOC_GUARD 
2d90			;		push af 
2d90			;		call ishlzero 
2d90			;		pop af 
2d90			;		 
2d90			;		call z,malloc_error 
2d90			;	endif 
2d90			; 
2d90			;	if DEBUG_FORTH_WORDS 
2d90			;		DMARK "Lt2" 
2d90			;		CALLMONITOR 
2d90			;	endif 
2d90			;		pop de 
2d90			;		push hl    ; push the malloc to release later 
2d90			;		push hl   ;  push back a copy for the later stack push 
2d90			;		 
2d90			;; copy the string swapping out the zero terms for spaces 
2d90			; 
2d90			;		; de has our source 
2d90			;		; hl has our dest 
2d90			; 
2d90			;; add the coln def 
2d90			; 
2d90			;		ld a, ':' 
2d90			;		ld (hl), a 
2d90			;		inc hl 
2d90			;		ld a, ' ' 
2d90			;		ld (hl), a 
2d90			;		inc hl 
2d90			; 
2d90			;; add the uname word 
2d90			;		push de   ; save our string for now 
2d90			;		ex de, hl 
2d90			; 
2d90			;		FORTH_DSP_VALUE 
2d90			;		;v5 FORTH_DSP_VALUE 
2d90			; 
2d90			;		inc hl   ; skip type but we know by now this is OK 
2d90			; 
2d90			;.luword:	ld a,(hl) 
2d90			;		cp 0 
2d90			;		jr z, .luword2 
2d90			;		ld (de), a 
2d90			;		inc de 
2d90			;		inc hl 
2d90			;		jr .luword 
2d90			; 
2d90			;.luword2:	ld a, ' ' 
2d90			;		ld (de), a 
2d90			;;		inc hl 
2d90			;;		inc de 
2d90			;;		ld (de), a 
2d90			;;		inc hl 
2d90			;		inc de 
2d90			; 
2d90			;		ex de, hl 
2d90			;		pop de 
2d90			;		 
2d90			;		 
2d90			; 
2d90			;; detoken that string and copy it 
2d90			; 
2d90			;	if DEBUG_FORTH_WORDS 
2d90			;		DMARK "Lt2" 
2d90			;		CALLMONITOR 
2d90			;	endif 
2d90			;.ldetok:	ld a, (de) 
2d90			;		cp FORTH_END_BUFFER 
2d90			;		jr z, .ldetokend 
2d90			;		; swap out any zero term for space 
2d90			;		cp 0 
2d90			;		jr nz, .ldetoknext 
2d90			;		ld a, ' ' 
2d90			; 
2d90			;	if DEBUG_FORTH_WORDS 
2d90			;		DMARK "LtS" 
2d90			;		CALLMONITOR 
2d90			;	endif 
2d90			;.ldetoknext:	ld (hl), a 
2d90			;		inc de 
2d90			;		inc hl 
2d90			;		jr .ldetok 
2d90			; 
2d90			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d90			;		ld (hl), a  
2d90			; 
2d90			;; free that temp malloc 
2d90			; 
2d90			;		pop hl    
2d90			; 
2d90			;	if DEBUG_FORTH_WORDS 
2d90			;		DMARK "Lt4" 
2d90			;		CALLMONITOR 
2d90			;	endif 
2d90			;		call forth_apushstrhl 
2d90			; 
2d90			;		; get rid of temp malloc area 
2d90			; 
2d90			;		pop hl 
2d90			;		call free 
2d90			; 
2d90			;		jr .ludone 
2d90			; 
2d90			;.lnuword:	pop hl 
2d90			;		call forth_tok_next 
2d90			;		jp .ldouscan  
2d90			; 
2d90			;.ludone:		 pop hl 
2d90			; 
2d90					NEXTW 
2d90 c3 5a 22			jp macro_next 
2d93				endm 
# End of macro NEXTW
2d93			 
2d93			.FORGET: 
2d93				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d93 5d				db WORD_SYS_CORE+73             
2d94 0c 2e			dw .NOP            
2d96 07				db 6 + 1 
2d97 .. 00			db "FORGET",0              
2d9e				endm 
# End of macro CWHEAD
2d9e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d9e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2d9e			; | |  
2d9e			; | | e.g. "MORE" forget 
2d9e					if DEBUG_FORTH_WORDS_KEY 
2d9e						DMARK "FRG" 
2d9e f5				push af  
2d9f 3a b3 2d			ld a, (.dmark)  
2da2 32 b4 fe			ld (debug_mark),a  
2da5 3a b4 2d			ld a, (.dmark+1)  
2da8 32 b5 fe			ld (debug_mark+1),a  
2dab 3a b5 2d			ld a, (.dmark+2)  
2dae 32 b6 fe			ld (debug_mark+2),a  
2db1 18 03			jr .pastdmark  
2db3 ..			.dmark: db "FRG"  
2db6 f1			.pastdmark: pop af  
2db7			endm  
# End of macro DMARK
2db7						CALLMONITOR 
2db7 cd 78 18			call break_point_state  
2dba				endm  
# End of macro CALLMONITOR
2dba					endif 
2dba			 
2dba				; find uword 
2dba			        ; update start of word with "_" 
2dba				; replace uword with deleted flag 
2dba			 
2dba			 
2dba			;	if DEBUG_FORTH_WORDS 
2dba			;		DMARK "FOG" 
2dba			;		CALLMONITOR 
2dba			;	endif 
2dba			 
2dba			 
2dba					; Get ptr to the word we need to look up 
2dba			 
2dba					FORTH_DSP_VALUEHL 
2dba cd e3 20			call macro_dsp_valuehl 
2dbd				endm 
# End of macro FORTH_DSP_VALUEHL
2dbd					;v5 FORTH_DSP_VALUE 
2dbd				; TODO type check 
2dbd			;		inc hl    ; Skip type check  
2dbd e5					push hl 
2dbe c1					pop bc 
2dbf			;		ex de, hl    ; put into DE 
2dbf			 
2dbf			 
2dbf 21 00 80				ld hl, baseram 
2dc2					;ld hl, baseusermem 
2dc2			 
2dc2				; skip dict stub 
2dc2			;	call forth_tok_next 
2dc2 e5			push hl   ; sacreifical push 
2dc3			 
2dc3			.fldouscanm: 
2dc3 e1				pop hl 
2dc4			.fldouscan: 
2dc4			;	if DEBUG_FORTH_WORDS 
2dc4			;		DMARK "LSs" 
2dc4			;		CALLMONITOR 
2dc4			;	endif 
2dc4				; skip dict stub 
2dc4 cd ab 23				call forth_tok_next 
2dc7			 
2dc7			 
2dc7			; while we have words to look for 
2dc7			 
2dc7 7e				ld a, (hl)      
2dc8			;	if DEBUG_FORTH_WORDS 
2dc8			;		DMARK "LSk" 
2dc8			;		CALLMONITOR 
2dc8			;	endif 
2dc8 fe 00				cp WORD_SYS_END 
2dca ca 06 2e				jp z, .flunotfound 
2dcd fe 01				cp WORD_SYS_UWORD 
2dcf c2 c4 2d				jp nz, .fldouscan 
2dd2			 
2dd2			;	if DEBUG_FORTH_WORDS 
2dd2			;		DMARK "LSu" 
2dd2			;		CALLMONITOR 
2dd2			;	endif 
2dd2			 
2dd2					; found a uword but is it the one we want... 
2dd2			 
2dd2 c5					push bc     ; uword to find is on bc 
2dd3 d1					pop de 
2dd4			 
2dd4 e5					push hl  ; to save the ptr 
2dd5			 
2dd5					; skip opcode 
2dd5 23					inc hl  
2dd6					; skip next ptr 
2dd6 23					inc hl  
2dd7 23					inc hl 
2dd8					; skip len 
2dd8 23					inc hl 
2dd9			 
2dd9			;	if DEBUG_FORTH_WORDS 
2dd9			;		DMARK "LSc" 
2dd9			;		CALLMONITOR 
2dd9			;	endif 
2dd9 cd 91 13				call strcmp 
2ddc c2 c3 2d				jp nz, .fldouscanm 
2ddf			; 
2ddf			; 
2ddf			;; while we have words to look for 
2ddf			; 
2ddf			;.fdouscan:	ld a, (hl)      
2ddf			;	if DEBUG_FORTH_WORDS 
2ddf			;		DMARK "LSs" 
2ddf			;		CALLMONITOR 
2ddf			;	endif 
2ddf			;		cp WORD_SYS_END 
2ddf			;		jp z, .fudone 
2ddf			;		cp WORD_SYS_UWORD 
2ddf			;		jp nz, .fnuword 
2ddf			; 
2ddf			;	if DEBUG_FORTH_WORDS 
2ddf			;		DMARK "FGu" 
2ddf			;		CALLMONITOR 
2ddf			;	endif 
2ddf			; 
2ddf			;		; found a uword but is it the one we want... 
2ddf			; 
2ddf			; 
2ddf			;	        pop de   ; get back the dsp name 
2ddf			;		push de 
2ddf			; 
2ddf			;		push hl  ; to save the ptr 
2ddf			; 
2ddf			;		; skip opcode 
2ddf			;		inc hl  
2ddf			;		; skip next ptr 
2ddf			;		inc hl  
2ddf			;		inc hl 
2ddf			;		; skip len 
2ddf			;		inc hl 
2ddf			; 
2ddf			;	if DEBUG_FORTH_WORDS 
2ddf			;		DMARK "FGc" 
2ddf			;		CALLMONITOR 
2ddf			;	endif 
2ddf			;		call strcmp 
2ddf			;		jp nz, .fnuword 
2ddf			 
2ddf			 
2ddf e1			pop hl 
2de0			 
2de0				 
2de0				if DEBUG_FORTH_WORDS 
2de0					DMARK "FGm" 
2de0 f5				push af  
2de1 3a f5 2d			ld a, (.dmark)  
2de4 32 b4 fe			ld (debug_mark),a  
2de7 3a f6 2d			ld a, (.dmark+1)  
2dea 32 b5 fe			ld (debug_mark+1),a  
2ded 3a f7 2d			ld a, (.dmark+2)  
2df0 32 b6 fe			ld (debug_mark+2),a  
2df3 18 03			jr .pastdmark  
2df5 ..			.dmark: db "FGm"  
2df8 f1			.pastdmark: pop af  
2df9			endm  
# End of macro DMARK
2df9					CALLMONITOR 
2df9 cd 78 18			call break_point_state  
2dfc				endm  
# End of macro CALLMONITOR
2dfc				endif 
2dfc			 
2dfc			 
2dfc			 
2dfc					; we have a uword so push its name to the stack 
2dfc			 
2dfc			;	   	push hl  ; save so we can move to next dict block 
2dfc			;pop hl 
2dfc			 
2dfc					; update opcode to deleted 
2dfc 3e 03				ld a, WORD_SYS_DELETED 
2dfe 77					ld (hl), a 
2dff			 
2dff 23					inc hl  
2e00					; skip next ptr 
2e00 23					inc hl  
2e01 23					inc hl 
2e02					; skip len 
2e02 23					inc hl 
2e03			 
2e03					; TODO change parser to skip deleted words but for now mark it out 
2e03 3e 5f				ld a, "_" 
2e05 77					ld  (hl),a 
2e06			 
2e06			;		jr .fudone 
2e06			; 
2e06			;.fnuword:	pop hl 
2e06			;		call forth_tok_next 
2e06			;		jp .fdouscan  
2e06			 
2e06			.flunotfound:		  
2e06			 
2e06			 
2e06					 
2e06					FORTH_DSP_POP 
2e06 cd 9b 21			call macro_forth_dsp_pop 
2e09				endm 
# End of macro FORTH_DSP_POP
2e09			;		ld hl, .luno 
2e09			;.fudone:		 pop hl 
2e09					NEXTW 
2e09 c3 5a 22			jp macro_next 
2e0c				endm 
# End of macro NEXTW
2e0c			.NOP: 
2e0c				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e0c 61				db WORD_SYS_CORE+77             
2e0d 33 2e			dw .COMO            
2e0f 04				db 3 + 1 
2e10 .. 00			db "NOP",0              
2e14				endm 
# End of macro CWHEAD
2e14			; | NOP (  --  ) Do nothing | DONE 
2e14					if DEBUG_FORTH_WORDS_KEY 
2e14						DMARK "NOP" 
2e14 f5				push af  
2e15 3a 29 2e			ld a, (.dmark)  
2e18 32 b4 fe			ld (debug_mark),a  
2e1b 3a 2a 2e			ld a, (.dmark+1)  
2e1e 32 b5 fe			ld (debug_mark+1),a  
2e21 3a 2b 2e			ld a, (.dmark+2)  
2e24 32 b6 fe			ld (debug_mark+2),a  
2e27 18 03			jr .pastdmark  
2e29 ..			.dmark: db "NOP"  
2e2c f1			.pastdmark: pop af  
2e2d			endm  
# End of macro DMARK
2e2d						CALLMONITOR 
2e2d cd 78 18			call break_point_state  
2e30				endm  
# End of macro CALLMONITOR
2e30					endif 
2e30				       NEXTW 
2e30 c3 5a 22			jp macro_next 
2e33				endm 
# End of macro NEXTW
2e33			.COMO: 
2e33				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e33 6e				db WORD_SYS_CORE+90             
2e34 85 2e			dw .COMC            
2e36 02				db 1 + 1 
2e37 .. 00			db "(",0              
2e39				endm 
# End of macro CWHEAD
2e39			; | ( ( -- )  Start of comment | DONE 
2e39			 
2e39			 
2e39 2a 86 f6				ld hl, ( os_tok_ptr) 
2e3c 11 80 2e			ld de, .closepar 
2e3f					 
2e3f					if DEBUG_FORTH_WORDS 
2e3f						DMARK ").." 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 b4 fe			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 b5 fe			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 b6 fe			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db ").."  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58						CALLMONITOR 
2e58 cd 78 18			call break_point_state  
2e5b				endm  
# End of macro CALLMONITOR
2e5b					endif 
2e5b cd 75 23			call findnexttok  
2e5e			 
2e5e					if DEBUG_FORTH_WORDS 
2e5e						DMARK "IF5" 
2e5e f5				push af  
2e5f 3a 73 2e			ld a, (.dmark)  
2e62 32 b4 fe			ld (debug_mark),a  
2e65 3a 74 2e			ld a, (.dmark+1)  
2e68 32 b5 fe			ld (debug_mark+1),a  
2e6b 3a 75 2e			ld a, (.dmark+2)  
2e6e 32 b6 fe			ld (debug_mark+2),a  
2e71 18 03			jr .pastdmark  
2e73 ..			.dmark: db "IF5"  
2e76 f1			.pastdmark: pop af  
2e77			endm  
# End of macro DMARK
2e77						CALLMONITOR 
2e77 cd 78 18			call break_point_state  
2e7a				endm  
# End of macro CALLMONITOR
2e7a					endif 
2e7a				; replace below with ) exec using tok_ptr 
2e7a 22 86 f6			ld (os_tok_ptr), hl 
2e7d c3 eb 22			jp exec1 
2e80			 
2e80 .. 00			.closepar:   db ")",0 
2e82			 
2e82				       NEXTW 
2e82 c3 5a 22			jp macro_next 
2e85				endm 
# End of macro NEXTW
2e85			.COMC: 
2e85				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e85 6f				db WORD_SYS_CORE+91             
2e86 8e 2e			dw .SCRATCH            
2e88 02				db 1 + 1 
2e89 .. 00			db ")",0              
2e8b				endm 
# End of macro CWHEAD
2e8b			; | ) ( -- )  End of comment |  DONE  
2e8b				       NEXTW 
2e8b c3 5a 22			jp macro_next 
2e8e				endm 
# End of macro NEXTW
2e8e			 
2e8e			.SCRATCH: 
2e8e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e8e 6f				db WORD_SYS_CORE+91             
2e8f c9 2e			dw .INC            
2e91 08				db 7 + 1 
2e92 .. 00			db "SCRATCH",0              
2e9a				endm 
# End of macro CWHEAD
2e9a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e9a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e9a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e9a			; | |  
2e9a			; | | e.g.    : score $00 scratch ; 
2e9a			; | |  
2e9a			; | | $00 score ! 
2e9a			; | | $01 score +! 
2e9a			; | |  
2e9a			; | | e.g.   : varword $0a scratch ;  
2e9a			; | | 
2e9a			; | | $8000 varword ! 
2e9a					if DEBUG_FORTH_WORDS_KEY 
2e9a						DMARK "SCR" 
2e9a f5				push af  
2e9b 3a af 2e			ld a, (.dmark)  
2e9e 32 b4 fe			ld (debug_mark),a  
2ea1 3a b0 2e			ld a, (.dmark+1)  
2ea4 32 b5 fe			ld (debug_mark+1),a  
2ea7 3a b1 2e			ld a, (.dmark+2)  
2eaa 32 b6 fe			ld (debug_mark+2),a  
2ead 18 03			jr .pastdmark  
2eaf ..			.dmark: db "SCR"  
2eb2 f1			.pastdmark: pop af  
2eb3			endm  
# End of macro DMARK
2eb3						CALLMONITOR 
2eb3 cd 78 18			call break_point_state  
2eb6				endm  
# End of macro CALLMONITOR
2eb6					endif 
2eb6			 
2eb6					FORTH_DSP_VALUEHL 
2eb6 cd e3 20			call macro_dsp_valuehl 
2eb9				endm 
# End of macro FORTH_DSP_VALUEHL
2eb9				 
2eb9					FORTH_DSP_POP 
2eb9 cd 9b 21			call macro_forth_dsp_pop 
2ebc				endm 
# End of macro FORTH_DSP_POP
2ebc			 
2ebc 7d					ld a, l 
2ebd 21 aa f8				ld hl, os_var_array 
2ec0 cd fb 0e				call addatohl 
2ec3			 
2ec3 cd ec 1e				call forth_push_numhl 
2ec6			 
2ec6				       NEXTW 
2ec6 c3 5a 22			jp macro_next 
2ec9				endm 
# End of macro NEXTW
2ec9			 
2ec9			.INC: 
2ec9				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ec9 6f				db WORD_SYS_CORE+91             
2eca 1d 2f			dw .DEC            
2ecc 03				db 2 + 1 
2ecd .. 00			db "+!",0              
2ed0				endm 
# End of macro CWHEAD
2ed0			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ed0					if DEBUG_FORTH_WORDS_KEY 
2ed0						DMARK "+s_" 
2ed0 f5				push af  
2ed1 3a e5 2e			ld a, (.dmark)  
2ed4 32 b4 fe			ld (debug_mark),a  
2ed7 3a e6 2e			ld a, (.dmark+1)  
2eda 32 b5 fe			ld (debug_mark+1),a  
2edd 3a e7 2e			ld a, (.dmark+2)  
2ee0 32 b6 fe			ld (debug_mark+2),a  
2ee3 18 03			jr .pastdmark  
2ee5 ..			.dmark: db "+s_"  
2ee8 f1			.pastdmark: pop af  
2ee9			endm  
# End of macro DMARK
2ee9						CALLMONITOR 
2ee9 cd 78 18			call break_point_state  
2eec				endm  
# End of macro CALLMONITOR
2eec					endif 
2eec			 
2eec					FORTH_DSP_VALUEHL 
2eec cd e3 20			call macro_dsp_valuehl 
2eef				endm 
# End of macro FORTH_DSP_VALUEHL
2eef			 
2eef e5					push hl   ; save address 
2ef0			 
2ef0					FORTH_DSP_POP 
2ef0 cd 9b 21			call macro_forth_dsp_pop 
2ef3				endm 
# End of macro FORTH_DSP_POP
2ef3			 
2ef3					FORTH_DSP_VALUEHL 
2ef3 cd e3 20			call macro_dsp_valuehl 
2ef6				endm 
# End of macro FORTH_DSP_VALUEHL
2ef6			 
2ef6					FORTH_DSP_POP 
2ef6 cd 9b 21			call macro_forth_dsp_pop 
2ef9				endm 
# End of macro FORTH_DSP_POP
2ef9			 
2ef9					; hl contains value to add to byte at a 
2ef9				 
2ef9 eb					ex de, hl 
2efa			 
2efa e1					pop hl 
2efb			 
2efb					if DEBUG_FORTH_WORDS 
2efb						DMARK "INC" 
2efb f5				push af  
2efc 3a 10 2f			ld a, (.dmark)  
2eff 32 b4 fe			ld (debug_mark),a  
2f02 3a 11 2f			ld a, (.dmark+1)  
2f05 32 b5 fe			ld (debug_mark+1),a  
2f08 3a 12 2f			ld a, (.dmark+2)  
2f0b 32 b6 fe			ld (debug_mark+2),a  
2f0e 18 03			jr .pastdmark  
2f10 ..			.dmark: db "INC"  
2f13 f1			.pastdmark: pop af  
2f14			endm  
# End of macro DMARK
2f14						CALLMONITOR 
2f14 cd 78 18			call break_point_state  
2f17				endm  
# End of macro CALLMONITOR
2f17					endif 
2f17			 
2f17 7e					ld a,(hl) 
2f18 83					add e 
2f19 77					ld (hl),a 
2f1a			 
2f1a			 
2f1a			 
2f1a				       NEXTW 
2f1a c3 5a 22			jp macro_next 
2f1d				endm 
# End of macro NEXTW
2f1d			 
2f1d			.DEC: 
2f1d				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f1d 6f				db WORD_SYS_CORE+91             
2f1e 6e 2f			dw .INC2            
2f20 03				db 2 + 1 
2f21 .. 00			db "-!",0              
2f24				endm 
# End of macro CWHEAD
2f24			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f24					if DEBUG_FORTH_WORDS_KEY 
2f24						DMARK "-s_" 
2f24 f5				push af  
2f25 3a 39 2f			ld a, (.dmark)  
2f28 32 b4 fe			ld (debug_mark),a  
2f2b 3a 3a 2f			ld a, (.dmark+1)  
2f2e 32 b5 fe			ld (debug_mark+1),a  
2f31 3a 3b 2f			ld a, (.dmark+2)  
2f34 32 b6 fe			ld (debug_mark+2),a  
2f37 18 03			jr .pastdmark  
2f39 ..			.dmark: db "-s_"  
2f3c f1			.pastdmark: pop af  
2f3d			endm  
# End of macro DMARK
2f3d						CALLMONITOR 
2f3d cd 78 18			call break_point_state  
2f40				endm  
# End of macro CALLMONITOR
2f40					endif 
2f40			 
2f40					FORTH_DSP_VALUEHL 
2f40 cd e3 20			call macro_dsp_valuehl 
2f43				endm 
# End of macro FORTH_DSP_VALUEHL
2f43			 
2f43 e5					push hl   ; save address 
2f44			 
2f44					FORTH_DSP_POP 
2f44 cd 9b 21			call macro_forth_dsp_pop 
2f47				endm 
# End of macro FORTH_DSP_POP
2f47			 
2f47					FORTH_DSP_VALUEHL 
2f47 cd e3 20			call macro_dsp_valuehl 
2f4a				endm 
# End of macro FORTH_DSP_VALUEHL
2f4a			 
2f4a					; hl contains value to add to byte at a 
2f4a				 
2f4a eb					ex de, hl 
2f4b			 
2f4b e1					pop hl 
2f4c			 
2f4c					if DEBUG_FORTH_WORDS 
2f4c						DMARK "DEC" 
2f4c f5				push af  
2f4d 3a 61 2f			ld a, (.dmark)  
2f50 32 b4 fe			ld (debug_mark),a  
2f53 3a 62 2f			ld a, (.dmark+1)  
2f56 32 b5 fe			ld (debug_mark+1),a  
2f59 3a 63 2f			ld a, (.dmark+2)  
2f5c 32 b6 fe			ld (debug_mark+2),a  
2f5f 18 03			jr .pastdmark  
2f61 ..			.dmark: db "DEC"  
2f64 f1			.pastdmark: pop af  
2f65			endm  
# End of macro DMARK
2f65						CALLMONITOR 
2f65 cd 78 18			call break_point_state  
2f68				endm  
# End of macro CALLMONITOR
2f68					endif 
2f68			 
2f68 7e					ld a,(hl) 
2f69 93					sub e 
2f6a 77					ld (hl),a 
2f6b			 
2f6b			 
2f6b			 
2f6b				       NEXTW 
2f6b c3 5a 22			jp macro_next 
2f6e				endm 
# End of macro NEXTW
2f6e			 
2f6e			.INC2: 
2f6e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f6e 6f				db WORD_SYS_CORE+91             
2f6f 18 30			dw .DEC2            
2f71 04				db 3 + 1 
2f72 .. 00			db "+2!",0              
2f76				endm 
# End of macro CWHEAD
2f76			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f76			 
2f76					if DEBUG_FORTH_WORDS_KEY 
2f76						DMARK "+2s" 
2f76 f5				push af  
2f77 3a 8b 2f			ld a, (.dmark)  
2f7a 32 b4 fe			ld (debug_mark),a  
2f7d 3a 8c 2f			ld a, (.dmark+1)  
2f80 32 b5 fe			ld (debug_mark+1),a  
2f83 3a 8d 2f			ld a, (.dmark+2)  
2f86 32 b6 fe			ld (debug_mark+2),a  
2f89 18 03			jr .pastdmark  
2f8b ..			.dmark: db "+2s"  
2f8e f1			.pastdmark: pop af  
2f8f			endm  
# End of macro DMARK
2f8f						CALLMONITOR 
2f8f cd 78 18			call break_point_state  
2f92				endm  
# End of macro CALLMONITOR
2f92					endif 
2f92			 
2f92					; Address 
2f92			 
2f92					FORTH_DSP_VALUEHL 
2f92 cd e3 20			call macro_dsp_valuehl 
2f95				endm 
# End of macro FORTH_DSP_VALUEHL
2f95			 
2f95 e5					push hl    ; save address 
2f96			 
2f96					; load content into de 
2f96			 
2f96 5e					ld e,(hl) 
2f97 23					inc hl 
2f98 56					ld d, (hl) 
2f99			 
2f99					if DEBUG_FORTH_WORDS 
2f99						DMARK "+2a" 
2f99 f5				push af  
2f9a 3a ae 2f			ld a, (.dmark)  
2f9d 32 b4 fe			ld (debug_mark),a  
2fa0 3a af 2f			ld a, (.dmark+1)  
2fa3 32 b5 fe			ld (debug_mark+1),a  
2fa6 3a b0 2f			ld a, (.dmark+2)  
2fa9 32 b6 fe			ld (debug_mark+2),a  
2fac 18 03			jr .pastdmark  
2fae ..			.dmark: db "+2a"  
2fb1 f1			.pastdmark: pop af  
2fb2			endm  
# End of macro DMARK
2fb2						CALLMONITOR 
2fb2 cd 78 18			call break_point_state  
2fb5				endm  
# End of macro CALLMONITOR
2fb5					endif 
2fb5			 
2fb5					FORTH_DSP_POP 
2fb5 cd 9b 21			call macro_forth_dsp_pop 
2fb8				endm 
# End of macro FORTH_DSP_POP
2fb8			 
2fb8					; Get value to add 
2fb8			 
2fb8					FORTH_DSP_VALUE 
2fb8 cd cc 20			call macro_forth_dsp_value 
2fbb				endm 
# End of macro FORTH_DSP_VALUE
2fbb			 
2fbb					if DEBUG_FORTH_WORDS 
2fbb						DMARK "+2v" 
2fbb f5				push af  
2fbc 3a d0 2f			ld a, (.dmark)  
2fbf 32 b4 fe			ld (debug_mark),a  
2fc2 3a d1 2f			ld a, (.dmark+1)  
2fc5 32 b5 fe			ld (debug_mark+1),a  
2fc8 3a d2 2f			ld a, (.dmark+2)  
2fcb 32 b6 fe			ld (debug_mark+2),a  
2fce 18 03			jr .pastdmark  
2fd0 ..			.dmark: db "+2v"  
2fd3 f1			.pastdmark: pop af  
2fd4			endm  
# End of macro DMARK
2fd4						CALLMONITOR 
2fd4 cd 78 18			call break_point_state  
2fd7				endm  
# End of macro CALLMONITOR
2fd7					endif 
2fd7			 
2fd7 19					add hl, de 
2fd8			 
2fd8					if DEBUG_FORTH_WORDS 
2fd8						DMARK "+2+" 
2fd8 f5				push af  
2fd9 3a ed 2f			ld a, (.dmark)  
2fdc 32 b4 fe			ld (debug_mark),a  
2fdf 3a ee 2f			ld a, (.dmark+1)  
2fe2 32 b5 fe			ld (debug_mark+1),a  
2fe5 3a ef 2f			ld a, (.dmark+2)  
2fe8 32 b6 fe			ld (debug_mark+2),a  
2feb 18 03			jr .pastdmark  
2fed ..			.dmark: db "+2+"  
2ff0 f1			.pastdmark: pop af  
2ff1			endm  
# End of macro DMARK
2ff1						CALLMONITOR 
2ff1 cd 78 18			call break_point_state  
2ff4				endm  
# End of macro CALLMONITOR
2ff4					endif 
2ff4			 
2ff4					; move result to de 
2ff4			 
2ff4 eb					ex de, hl 
2ff5			 
2ff5					; Address 
2ff5			 
2ff5 e1					pop hl 
2ff6			 
2ff6					; save it back 
2ff6			 
2ff6 73					ld (hl), e 
2ff7 23					inc hl 
2ff8 72					ld (hl), d 
2ff9			 
2ff9					if DEBUG_FORTH_WORDS 
2ff9						DMARK "+2e" 
2ff9 f5				push af  
2ffa 3a 0e 30			ld a, (.dmark)  
2ffd 32 b4 fe			ld (debug_mark),a  
3000 3a 0f 30			ld a, (.dmark+1)  
3003 32 b5 fe			ld (debug_mark+1),a  
3006 3a 10 30			ld a, (.dmark+2)  
3009 32 b6 fe			ld (debug_mark+2),a  
300c 18 03			jr .pastdmark  
300e ..			.dmark: db "+2e"  
3011 f1			.pastdmark: pop af  
3012			endm  
# End of macro DMARK
3012						CALLMONITOR 
3012 cd 78 18			call break_point_state  
3015				endm  
# End of macro CALLMONITOR
3015					endif 
3015			 
3015			 
3015			 
3015			 
3015			 
3015				       NEXTW 
3015 c3 5a 22			jp macro_next 
3018				endm 
# End of macro NEXTW
3018			 
3018			.DEC2: 
3018				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3018 6f				db WORD_SYS_CORE+91             
3019 c4 30			dw .GET2            
301b 04				db 3 + 1 
301c .. 00			db "-2!",0              
3020				endm 
# End of macro CWHEAD
3020			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3020			 
3020			 
3020					if DEBUG_FORTH_WORDS_KEY 
3020						DMARK "-2s" 
3020 f5				push af  
3021 3a 35 30			ld a, (.dmark)  
3024 32 b4 fe			ld (debug_mark),a  
3027 3a 36 30			ld a, (.dmark+1)  
302a 32 b5 fe			ld (debug_mark+1),a  
302d 3a 37 30			ld a, (.dmark+2)  
3030 32 b6 fe			ld (debug_mark+2),a  
3033 18 03			jr .pastdmark  
3035 ..			.dmark: db "-2s"  
3038 f1			.pastdmark: pop af  
3039			endm  
# End of macro DMARK
3039						CALLMONITOR 
3039 cd 78 18			call break_point_state  
303c				endm  
# End of macro CALLMONITOR
303c					endif 
303c			 
303c					; Address 
303c			 
303c					FORTH_DSP_VALUEHL 
303c cd e3 20			call macro_dsp_valuehl 
303f				endm 
# End of macro FORTH_DSP_VALUEHL
303f			 
303f e5					push hl    ; save address 
3040			 
3040					; load content into de 
3040			 
3040 5e					ld e,(hl) 
3041 23					inc hl 
3042 56					ld d, (hl) 
3043			 
3043					if DEBUG_FORTH_WORDS 
3043						DMARK "-2a" 
3043 f5				push af  
3044 3a 58 30			ld a, (.dmark)  
3047 32 b4 fe			ld (debug_mark),a  
304a 3a 59 30			ld a, (.dmark+1)  
304d 32 b5 fe			ld (debug_mark+1),a  
3050 3a 5a 30			ld a, (.dmark+2)  
3053 32 b6 fe			ld (debug_mark+2),a  
3056 18 03			jr .pastdmark  
3058 ..			.dmark: db "-2a"  
305b f1			.pastdmark: pop af  
305c			endm  
# End of macro DMARK
305c						CALLMONITOR 
305c cd 78 18			call break_point_state  
305f				endm  
# End of macro CALLMONITOR
305f					endif 
305f			 
305f					FORTH_DSP_POP 
305f cd 9b 21			call macro_forth_dsp_pop 
3062				endm 
# End of macro FORTH_DSP_POP
3062			 
3062					; Get value to remove 
3062			 
3062					FORTH_DSP_VALUE 
3062 cd cc 20			call macro_forth_dsp_value 
3065				endm 
# End of macro FORTH_DSP_VALUE
3065			 
3065					if DEBUG_FORTH_WORDS 
3065						DMARK "-2v" 
3065 f5				push af  
3066 3a 7a 30			ld a, (.dmark)  
3069 32 b4 fe			ld (debug_mark),a  
306c 3a 7b 30			ld a, (.dmark+1)  
306f 32 b5 fe			ld (debug_mark+1),a  
3072 3a 7c 30			ld a, (.dmark+2)  
3075 32 b6 fe			ld (debug_mark+2),a  
3078 18 03			jr .pastdmark  
307a ..			.dmark: db "-2v"  
307d f1			.pastdmark: pop af  
307e			endm  
# End of macro DMARK
307e						CALLMONITOR 
307e cd 78 18			call break_point_state  
3081				endm  
# End of macro CALLMONITOR
3081					endif 
3081			 
3081 eb					ex de, hl 
3082 ed 52				sbc hl, de 
3084			 
3084					if DEBUG_FORTH_WORDS 
3084						DMARK "-2d" 
3084 f5				push af  
3085 3a 99 30			ld a, (.dmark)  
3088 32 b4 fe			ld (debug_mark),a  
308b 3a 9a 30			ld a, (.dmark+1)  
308e 32 b5 fe			ld (debug_mark+1),a  
3091 3a 9b 30			ld a, (.dmark+2)  
3094 32 b6 fe			ld (debug_mark+2),a  
3097 18 03			jr .pastdmark  
3099 ..			.dmark: db "-2d"  
309c f1			.pastdmark: pop af  
309d			endm  
# End of macro DMARK
309d						CALLMONITOR 
309d cd 78 18			call break_point_state  
30a0				endm  
# End of macro CALLMONITOR
30a0					endif 
30a0			 
30a0					; move result to de 
30a0			 
30a0 eb					ex de, hl 
30a1			 
30a1					; Address 
30a1			 
30a1 e1					pop hl 
30a2			 
30a2					; save it back 
30a2			 
30a2 73					ld (hl), e 
30a3 23					inc hl 
30a4 72					ld (hl), d 
30a5			 
30a5					if DEBUG_FORTH_WORDS 
30a5						DMARK "-2e" 
30a5 f5				push af  
30a6 3a ba 30			ld a, (.dmark)  
30a9 32 b4 fe			ld (debug_mark),a  
30ac 3a bb 30			ld a, (.dmark+1)  
30af 32 b5 fe			ld (debug_mark+1),a  
30b2 3a bc 30			ld a, (.dmark+2)  
30b5 32 b6 fe			ld (debug_mark+2),a  
30b8 18 03			jr .pastdmark  
30ba ..			.dmark: db "-2e"  
30bd f1			.pastdmark: pop af  
30be			endm  
# End of macro DMARK
30be						CALLMONITOR 
30be cd 78 18			call break_point_state  
30c1				endm  
# End of macro CALLMONITOR
30c1					endif 
30c1			 
30c1			 
30c1			 
30c1			 
30c1			 
30c1				       NEXTW 
30c1 c3 5a 22			jp macro_next 
30c4				endm 
# End of macro NEXTW
30c4			.GET2: 
30c4				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30c4 6f				db WORD_SYS_CORE+91             
30c5 f4 30			dw .BANG2            
30c7 03				db 2 + 1 
30c8 .. 00			db "2@",0              
30cb				endm 
# End of macro CWHEAD
30cb			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30cb					if DEBUG_FORTH_WORDS_KEY 
30cb						DMARK "2A_" 
30cb f5				push af  
30cc 3a e0 30			ld a, (.dmark)  
30cf 32 b4 fe			ld (debug_mark),a  
30d2 3a e1 30			ld a, (.dmark+1)  
30d5 32 b5 fe			ld (debug_mark+1),a  
30d8 3a e2 30			ld a, (.dmark+2)  
30db 32 b6 fe			ld (debug_mark+2),a  
30de 18 03			jr .pastdmark  
30e0 ..			.dmark: db "2A_"  
30e3 f1			.pastdmark: pop af  
30e4			endm  
# End of macro DMARK
30e4						CALLMONITOR 
30e4 cd 78 18			call break_point_state  
30e7				endm  
# End of macro CALLMONITOR
30e7					endif 
30e7			 
30e7					FORTH_DSP_VALUEHL 
30e7 cd e3 20			call macro_dsp_valuehl 
30ea				endm 
# End of macro FORTH_DSP_VALUEHL
30ea			 
30ea 5e					ld e, (hl) 
30eb 23					inc hl 
30ec 56					ld d, (hl) 
30ed			 
30ed eb					ex de, hl 
30ee			 
30ee cd ec 1e				call forth_push_numhl 
30f1			 
30f1				       NEXTW 
30f1 c3 5a 22			jp macro_next 
30f4				endm 
# End of macro NEXTW
30f4			.BANG2: 
30f4				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30f4 6f				db WORD_SYS_CORE+91             
30f5 2c 31			dw .CONFIG            
30f7 03				db 2 + 1 
30f8 .. 00			db "2!",0              
30fb				endm 
# End of macro CWHEAD
30fb			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30fb					if DEBUG_FORTH_WORDS_KEY 
30fb						DMARK "2S_" 
30fb f5				push af  
30fc 3a 10 31			ld a, (.dmark)  
30ff 32 b4 fe			ld (debug_mark),a  
3102 3a 11 31			ld a, (.dmark+1)  
3105 32 b5 fe			ld (debug_mark+1),a  
3108 3a 12 31			ld a, (.dmark+2)  
310b 32 b6 fe			ld (debug_mark+2),a  
310e 18 03			jr .pastdmark  
3110 ..			.dmark: db "2S_"  
3113 f1			.pastdmark: pop af  
3114			endm  
# End of macro DMARK
3114						CALLMONITOR 
3114 cd 78 18			call break_point_state  
3117				endm  
# End of macro CALLMONITOR
3117					endif 
3117			 
3117					FORTH_DSP_VALUEHL 
3117 cd e3 20			call macro_dsp_valuehl 
311a				endm 
# End of macro FORTH_DSP_VALUEHL
311a			 
311a e5					push hl   ; save address 
311b			 
311b			 
311b					FORTH_DSP_POP 
311b cd 9b 21			call macro_forth_dsp_pop 
311e				endm 
# End of macro FORTH_DSP_POP
311e			 
311e					 
311e					FORTH_DSP_VALUEHL 
311e cd e3 20			call macro_dsp_valuehl 
3121				endm 
# End of macro FORTH_DSP_VALUEHL
3121			 
3121					FORTH_DSP_POP 
3121 cd 9b 21			call macro_forth_dsp_pop 
3124				endm 
# End of macro FORTH_DSP_POP
3124			 
3124 eb					ex de, hl    ; value now in de 
3125			 
3125 e1					pop hl 
3126			 
3126 73					ld (hl), e 
3127			 
3127 23					inc hl 
3128			 
3128 72					ld (hl), d 
3129			 
3129			 
3129				       NEXTW 
3129 c3 5a 22			jp macro_next 
312c				endm 
# End of macro NEXTW
312c			.CONFIG: 
312c				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
312c 6f				db WORD_SYS_CORE+91             
312d 3d 31			dw .ENDCORE            
312f 07				db 6 + 1 
3130 .. 00			db "CONFIG",0              
3137				endm 
# End of macro CWHEAD
3137			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3137			 
3137 cd 5b 15				call config 
313a					NEXTW 
313a c3 5a 22			jp macro_next 
313d				endm 
# End of macro NEXTW
313d			.ENDCORE: 
313d			 
313d			; eof 
313d			 
313d			 
# End of file forth_words_core.asm
313d			include "forth_words_flow.asm" 
313d			 
313d			; | ## Program Flow Words 
313d			 
313d			.IF: 
313d				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
313d 1e				db WORD_SYS_CORE+10             
313e 32 32			dw .THEN            
3140 03				db 2 + 1 
3141 .. 00			db "IF",0              
3144				endm 
# End of macro CWHEAD
3144			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3144			; 
3144					if DEBUG_FORTH_WORDS_KEY 
3144						DMARK "IF." 
3144 f5				push af  
3145 3a 59 31			ld a, (.dmark)  
3148 32 b4 fe			ld (debug_mark),a  
314b 3a 5a 31			ld a, (.dmark+1)  
314e 32 b5 fe			ld (debug_mark+1),a  
3151 3a 5b 31			ld a, (.dmark+2)  
3154 32 b6 fe			ld (debug_mark+2),a  
3157 18 03			jr .pastdmark  
3159 ..			.dmark: db "IF."  
315c f1			.pastdmark: pop af  
315d			endm  
# End of macro DMARK
315d						CALLMONITOR 
315d cd 78 18			call break_point_state  
3160				endm  
# End of macro CALLMONITOR
3160					endif 
3160			; eval TOS 
3160			 
3160				FORTH_DSP_VALUEHL 
3160 cd e3 20			call macro_dsp_valuehl 
3163				endm 
# End of macro FORTH_DSP_VALUEHL
3163			 
3163			;	push hl 
3163				FORTH_DSP_POP 
3163 cd 9b 21			call macro_forth_dsp_pop 
3166				endm 
# End of macro FORTH_DSP_POP
3166			;	pop hl 
3166			 
3166					if DEBUG_FORTH_WORDS 
3166						DMARK "IF1" 
3166 f5				push af  
3167 3a 7b 31			ld a, (.dmark)  
316a 32 b4 fe			ld (debug_mark),a  
316d 3a 7c 31			ld a, (.dmark+1)  
3170 32 b5 fe			ld (debug_mark+1),a  
3173 3a 7d 31			ld a, (.dmark+2)  
3176 32 b6 fe			ld (debug_mark+2),a  
3179 18 03			jr .pastdmark  
317b ..			.dmark: db "IF1"  
317e f1			.pastdmark: pop af  
317f			endm  
# End of macro DMARK
317f						CALLMONITOR 
317f cd 78 18			call break_point_state  
3182				endm  
# End of macro CALLMONITOR
3182					endif 
3182 b7				or a        ; clear carry flag 
3183 11 00 00			ld de, 0 
3186 eb				ex de,hl 
3187 ed 52			sbc hl, de 
3189 c2 13 32			jp nz, .iftrue 
318c			 
318c					if DEBUG_FORTH_WORDS 
318c						DMARK "IF2" 
318c f5				push af  
318d 3a a1 31			ld a, (.dmark)  
3190 32 b4 fe			ld (debug_mark),a  
3193 3a a2 31			ld a, (.dmark+1)  
3196 32 b5 fe			ld (debug_mark+1),a  
3199 3a a3 31			ld a, (.dmark+2)  
319c 32 b6 fe			ld (debug_mark+2),a  
319f 18 03			jr .pastdmark  
31a1 ..			.dmark: db "IF2"  
31a4 f1			.pastdmark: pop af  
31a5			endm  
# End of macro DMARK
31a5						CALLMONITOR 
31a5 cd 78 18			call break_point_state  
31a8				endm  
# End of macro CALLMONITOR
31a8					endif 
31a8			 
31a8			; if not true then skip to THEN 
31a8			 
31a8				; TODO get tok_ptr 
31a8				; TODO consume toks until we get to THEN 
31a8			 
31a8 2a 86 f6			ld hl, (os_tok_ptr) 
31ab					if DEBUG_FORTH_WORDS 
31ab						DMARK "IF3" 
31ab f5				push af  
31ac 3a c0 31			ld a, (.dmark)  
31af 32 b4 fe			ld (debug_mark),a  
31b2 3a c1 31			ld a, (.dmark+1)  
31b5 32 b5 fe			ld (debug_mark+1),a  
31b8 3a c2 31			ld a, (.dmark+2)  
31bb 32 b6 fe			ld (debug_mark+2),a  
31be 18 03			jr .pastdmark  
31c0 ..			.dmark: db "IF3"  
31c3 f1			.pastdmark: pop af  
31c4			endm  
# End of macro DMARK
31c4						CALLMONITOR 
31c4 cd 78 18			call break_point_state  
31c7				endm  
# End of macro CALLMONITOR
31c7						 
31c7					endif 
31c7 11 0e 32			ld de, .ifthen 
31ca					if DEBUG_FORTH_WORDS 
31ca						DMARK "IF4" 
31ca f5				push af  
31cb 3a df 31			ld a, (.dmark)  
31ce 32 b4 fe			ld (debug_mark),a  
31d1 3a e0 31			ld a, (.dmark+1)  
31d4 32 b5 fe			ld (debug_mark+1),a  
31d7 3a e1 31			ld a, (.dmark+2)  
31da 32 b6 fe			ld (debug_mark+2),a  
31dd 18 03			jr .pastdmark  
31df ..			.dmark: db "IF4"  
31e2 f1			.pastdmark: pop af  
31e3			endm  
# End of macro DMARK
31e3						CALLMONITOR 
31e3 cd 78 18			call break_point_state  
31e6				endm  
# End of macro CALLMONITOR
31e6					endif 
31e6 cd 75 23			call findnexttok  
31e9			 
31e9					if DEBUG_FORTH_WORDS 
31e9						DMARK "IF5" 
31e9 f5				push af  
31ea 3a fe 31			ld a, (.dmark)  
31ed 32 b4 fe			ld (debug_mark),a  
31f0 3a ff 31			ld a, (.dmark+1)  
31f3 32 b5 fe			ld (debug_mark+1),a  
31f6 3a 00 32			ld a, (.dmark+2)  
31f9 32 b6 fe			ld (debug_mark+2),a  
31fc 18 03			jr .pastdmark  
31fe ..			.dmark: db "IF5"  
3201 f1			.pastdmark: pop af  
3202			endm  
# End of macro DMARK
3202						CALLMONITOR 
3202 cd 78 18			call break_point_state  
3205				endm  
# End of macro CALLMONITOR
3205					endif 
3205				; TODO replace below with ; exec using tok_ptr 
3205 22 86 f6			ld (os_tok_ptr), hl 
3208 c3 eb 22			jp exec1 
320b				NEXTW 
320b c3 5a 22			jp macro_next 
320e				endm 
# End of macro NEXTW
320e			 
320e .. 00		.ifthen:  db "THEN",0 
3213			 
3213			.iftrue:		 
3213				; Exec next words normally 
3213			 
3213				; if true then exec following IF as normal 
3213					if DEBUG_FORTH_WORDS 
3213						DMARK "IFT" 
3213 f5				push af  
3214 3a 28 32			ld a, (.dmark)  
3217 32 b4 fe			ld (debug_mark),a  
321a 3a 29 32			ld a, (.dmark+1)  
321d 32 b5 fe			ld (debug_mark+1),a  
3220 3a 2a 32			ld a, (.dmark+2)  
3223 32 b6 fe			ld (debug_mark+2),a  
3226 18 03			jr .pastdmark  
3228 ..			.dmark: db "IFT"  
322b f1			.pastdmark: pop af  
322c			endm  
# End of macro DMARK
322c						CALLMONITOR 
322c cd 78 18			call break_point_state  
322f				endm  
# End of macro CALLMONITOR
322f					endif 
322f			 
322f					NEXTW 
322f c3 5a 22			jp macro_next 
3232				endm 
# End of macro NEXTW
3232			.THEN: 
3232				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3232 1f				db WORD_SYS_CORE+11             
3233 5a 32			dw .ELSE            
3235 05				db 4 + 1 
3236 .. 00			db "THEN",0              
323b				endm 
# End of macro CWHEAD
323b			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
323b					if DEBUG_FORTH_WORDS_KEY 
323b						DMARK "THN" 
323b f5				push af  
323c 3a 50 32			ld a, (.dmark)  
323f 32 b4 fe			ld (debug_mark),a  
3242 3a 51 32			ld a, (.dmark+1)  
3245 32 b5 fe			ld (debug_mark+1),a  
3248 3a 52 32			ld a, (.dmark+2)  
324b 32 b6 fe			ld (debug_mark+2),a  
324e 18 03			jr .pastdmark  
3250 ..			.dmark: db "THN"  
3253 f1			.pastdmark: pop af  
3254			endm  
# End of macro DMARK
3254						CALLMONITOR 
3254 cd 78 18			call break_point_state  
3257				endm  
# End of macro CALLMONITOR
3257					endif 
3257					NEXTW 
3257 c3 5a 22			jp macro_next 
325a				endm 
# End of macro NEXTW
325a			.ELSE: 
325a				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
325a 20				db WORD_SYS_CORE+12             
325b 82 32			dw .DO            
325d 03				db 2 + 1 
325e .. 00			db "ELSE",0              
3263				endm 
# End of macro CWHEAD
3263			; | ELSE ( -- ) Not supported - does nothing | TODO 
3263			 
3263					if DEBUG_FORTH_WORDS_KEY 
3263						DMARK "ELS" 
3263 f5				push af  
3264 3a 78 32			ld a, (.dmark)  
3267 32 b4 fe			ld (debug_mark),a  
326a 3a 79 32			ld a, (.dmark+1)  
326d 32 b5 fe			ld (debug_mark+1),a  
3270 3a 7a 32			ld a, (.dmark+2)  
3273 32 b6 fe			ld (debug_mark+2),a  
3276 18 03			jr .pastdmark  
3278 ..			.dmark: db "ELS"  
327b f1			.pastdmark: pop af  
327c			endm  
# End of macro DMARK
327c						CALLMONITOR 
327c cd 78 18			call break_point_state  
327f				endm  
# End of macro CALLMONITOR
327f					endif 
327f			 
327f			 
327f					NEXTW 
327f c3 5a 22			jp macro_next 
3282				endm 
# End of macro NEXTW
3282			.DO: 
3282				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3282 21				db WORD_SYS_CORE+13             
3283 a9 33			dw .LOOP            
3285 03				db 2 + 1 
3286 .. 00			db "DO",0              
3289				endm 
# End of macro CWHEAD
3289			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3289			 
3289					if DEBUG_FORTH_WORDS_KEY 
3289						DMARK "DO." 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 b4 fe			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 b5 fe			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 b6 fe			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "DO."  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd 78 18			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5			;  push pc to rsp stack past the DO 
32a5			 
32a5 2a 86 f6				ld hl, (os_tok_ptr) 
32a8 23					inc hl   ; D 
32a9 23					inc hl  ; O 
32aa 23					inc hl   ; null 
32ab					if DEBUG_FORTH_WORDS 
32ab						DMARK "DO2" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 b4 fe			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 b5 fe			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 b6 fe			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "DO2"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd 78 18			call break_point_state  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7					FORTH_RSP_NEXT 
32c7 cd 93 1e			call macro_forth_rsp_next 
32ca				endm 
# End of macro FORTH_RSP_NEXT
32ca					if DEBUG_FORTH_WORDS 
32ca						DMARK "DO3" 
32ca f5				push af  
32cb 3a df 32			ld a, (.dmark)  
32ce 32 b4 fe			ld (debug_mark),a  
32d1 3a e0 32			ld a, (.dmark+1)  
32d4 32 b5 fe			ld (debug_mark+1),a  
32d7 3a e1 32			ld a, (.dmark+2)  
32da 32 b6 fe			ld (debug_mark+2),a  
32dd 18 03			jr .pastdmark  
32df ..			.dmark: db "DO3"  
32e2 f1			.pastdmark: pop af  
32e3			endm  
# End of macro DMARK
32e3						CALLMONITOR 
32e3 cd 78 18			call break_point_state  
32e6				endm  
# End of macro CALLMONITOR
32e6					endif 
32e6			 
32e6					;if DEBUG_FORTH_WORDS 
32e6				;		push hl 
32e6			;		endif  
32e6			 
32e6			; get counters from data stack 
32e6			 
32e6			 
32e6					FORTH_DSP_VALUEHL 
32e6 cd e3 20			call macro_dsp_valuehl 
32e9				endm 
# End of macro FORTH_DSP_VALUEHL
32e9 e5					push hl		 ; hl now has starting counter which needs to be tos 
32ea			 
32ea					if DEBUG_FORTH_WORDS 
32ea						DMARK "DO4" 
32ea f5				push af  
32eb 3a ff 32			ld a, (.dmark)  
32ee 32 b4 fe			ld (debug_mark),a  
32f1 3a 00 33			ld a, (.dmark+1)  
32f4 32 b5 fe			ld (debug_mark+1),a  
32f7 3a 01 33			ld a, (.dmark+2)  
32fa 32 b6 fe			ld (debug_mark+2),a  
32fd 18 03			jr .pastdmark  
32ff ..			.dmark: db "DO4"  
3302 f1			.pastdmark: pop af  
3303			endm  
# End of macro DMARK
3303						CALLMONITOR 
3303 cd 78 18			call break_point_state  
3306				endm  
# End of macro CALLMONITOR
3306					endif 
3306					FORTH_DSP_POP 
3306 cd 9b 21			call macro_forth_dsp_pop 
3309				endm 
# End of macro FORTH_DSP_POP
3309			 
3309					if DEBUG_FORTH_WORDS 
3309						DMARK "DO5" 
3309 f5				push af  
330a 3a 1e 33			ld a, (.dmark)  
330d 32 b4 fe			ld (debug_mark),a  
3310 3a 1f 33			ld a, (.dmark+1)  
3313 32 b5 fe			ld (debug_mark+1),a  
3316 3a 20 33			ld a, (.dmark+2)  
3319 32 b6 fe			ld (debug_mark+2),a  
331c 18 03			jr .pastdmark  
331e ..			.dmark: db "DO5"  
3321 f1			.pastdmark: pop af  
3322			endm  
# End of macro DMARK
3322						CALLMONITOR 
3322 cd 78 18			call break_point_state  
3325				endm  
# End of macro CALLMONITOR
3325					endif 
3325			 
3325					FORTH_DSP_VALUEHL 
3325 cd e3 20			call macro_dsp_valuehl 
3328				endm 
# End of macro FORTH_DSP_VALUEHL
3328			;		push hl		 ; hl now has starting limit counter 
3328			 
3328					if DEBUG_FORTH_WORDS 
3328						DMARK "DO6" 
3328 f5				push af  
3329 3a 3d 33			ld a, (.dmark)  
332c 32 b4 fe			ld (debug_mark),a  
332f 3a 3e 33			ld a, (.dmark+1)  
3332 32 b5 fe			ld (debug_mark+1),a  
3335 3a 3f 33			ld a, (.dmark+2)  
3338 32 b6 fe			ld (debug_mark+2),a  
333b 18 03			jr .pastdmark  
333d ..			.dmark: db "DO6"  
3340 f1			.pastdmark: pop af  
3341			endm  
# End of macro DMARK
3341						CALLMONITOR 
3341 cd 78 18			call break_point_state  
3344				endm  
# End of macro CALLMONITOR
3344					endif 
3344					FORTH_DSP_POP 
3344 cd 9b 21			call macro_forth_dsp_pop 
3347				endm 
# End of macro FORTH_DSP_POP
3347			 
3347			; put counters on the loop stack 
3347			 
3347			;		pop hl			 ; limit counter 
3347 d1					pop de			; start counter 
3348			 
3348					; push limit counter 
3348			 
3348					if DEBUG_FORTH_WORDS 
3348						DMARK "DO7" 
3348 f5				push af  
3349 3a 5d 33			ld a, (.dmark)  
334c 32 b4 fe			ld (debug_mark),a  
334f 3a 5e 33			ld a, (.dmark+1)  
3352 32 b5 fe			ld (debug_mark+1),a  
3355 3a 5f 33			ld a, (.dmark+2)  
3358 32 b6 fe			ld (debug_mark+2),a  
335b 18 03			jr .pastdmark  
335d ..			.dmark: db "DO7"  
3360 f1			.pastdmark: pop af  
3361			endm  
# End of macro DMARK
3361						CALLMONITOR 
3361 cd 78 18			call break_point_state  
3364				endm  
# End of macro CALLMONITOR
3364					endif 
3364					FORTH_LOOP_NEXT 
3364 cd 14 21			call macro_forth_loop_next 
3367				endm 
# End of macro FORTH_LOOP_NEXT
3367			 
3367					; push start counter 
3367			 
3367 eb					ex de, hl 
3368					if DEBUG_FORTH_WORDS 
3368						DMARK "DO7" 
3368 f5				push af  
3369 3a 7d 33			ld a, (.dmark)  
336c 32 b4 fe			ld (debug_mark),a  
336f 3a 7e 33			ld a, (.dmark+1)  
3372 32 b5 fe			ld (debug_mark+1),a  
3375 3a 7f 33			ld a, (.dmark+2)  
3378 32 b6 fe			ld (debug_mark+2),a  
337b 18 03			jr .pastdmark  
337d ..			.dmark: db "DO7"  
3380 f1			.pastdmark: pop af  
3381			endm  
# End of macro DMARK
3381						CALLMONITOR 
3381 cd 78 18			call break_point_state  
3384				endm  
# End of macro CALLMONITOR
3384					endif 
3384					FORTH_LOOP_NEXT 
3384 cd 14 21			call macro_forth_loop_next 
3387				endm 
# End of macro FORTH_LOOP_NEXT
3387			 
3387			 
3387					; init first round of I counter 
3387			 
3387 22 aa f6				ld (os_current_i), hl 
338a			 
338a					if DEBUG_FORTH_WORDS 
338a						DMARK "DO8" 
338a f5				push af  
338b 3a 9f 33			ld a, (.dmark)  
338e 32 b4 fe			ld (debug_mark),a  
3391 3a a0 33			ld a, (.dmark+1)  
3394 32 b5 fe			ld (debug_mark+1),a  
3397 3a a1 33			ld a, (.dmark+2)  
339a 32 b6 fe			ld (debug_mark+2),a  
339d 18 03			jr .pastdmark  
339f ..			.dmark: db "DO8"  
33a2 f1			.pastdmark: pop af  
33a3			endm  
# End of macro DMARK
33a3						CALLMONITOR 
33a3 cd 78 18			call break_point_state  
33a6				endm  
# End of macro CALLMONITOR
33a6					endif 
33a6			 
33a6					NEXTW 
33a6 c3 5a 22			jp macro_next 
33a9				endm 
# End of macro NEXTW
33a9			.LOOP: 
33a9				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
33a9 22				db WORD_SYS_CORE+14             
33aa c1 34			dw .I            
33ac 05				db 4 + 1 
33ad .. 00			db "LOOP",0              
33b2				endm 
# End of macro CWHEAD
33b2			; | LOOP ( -- ) Increment and test loop counter  | DONE 
33b2			 
33b2				; pop tos as current loop count to hl 
33b2			 
33b2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33b2			 
33b2				FORTH_LOOP_TOS 
33b2 cd 47 21			call macro_forth_loop_tos 
33b5				endm 
# End of macro FORTH_LOOP_TOS
33b5 e5				push hl 
33b6			 
33b6					if DEBUG_FORTH_WORDS_KEY 
33b6						DMARK "LOP" 
33b6 f5				push af  
33b7 3a cb 33			ld a, (.dmark)  
33ba 32 b4 fe			ld (debug_mark),a  
33bd 3a cc 33			ld a, (.dmark+1)  
33c0 32 b5 fe			ld (debug_mark+1),a  
33c3 3a cd 33			ld a, (.dmark+2)  
33c6 32 b6 fe			ld (debug_mark+2),a  
33c9 18 03			jr .pastdmark  
33cb ..			.dmark: db "LOP"  
33ce f1			.pastdmark: pop af  
33cf			endm  
# End of macro DMARK
33cf						CALLMONITOR 
33cf cd 78 18			call break_point_state  
33d2				endm  
# End of macro CALLMONITOR
33d2					endif 
33d2				; next item on the stack is the limit. get it 
33d2			 
33d2			 
33d2				FORTH_LOOP_POP 
33d2 cd 51 21			call macro_forth_loop_pop 
33d5				endm 
# End of macro FORTH_LOOP_POP
33d5			 
33d5				FORTH_LOOP_TOS 
33d5 cd 47 21			call macro_forth_loop_tos 
33d8				endm 
# End of macro FORTH_LOOP_TOS
33d8			 
33d8 d1				pop de		 ; de = i, hl = limit 
33d9			 
33d9					if DEBUG_FORTH_WORDS 
33d9						DMARK "LP1" 
33d9 f5				push af  
33da 3a ee 33			ld a, (.dmark)  
33dd 32 b4 fe			ld (debug_mark),a  
33e0 3a ef 33			ld a, (.dmark+1)  
33e3 32 b5 fe			ld (debug_mark+1),a  
33e6 3a f0 33			ld a, (.dmark+2)  
33e9 32 b6 fe			ld (debug_mark+2),a  
33ec 18 03			jr .pastdmark  
33ee ..			.dmark: db "LP1"  
33f1 f1			.pastdmark: pop af  
33f2			endm  
# End of macro DMARK
33f2						CALLMONITOR 
33f2 cd 78 18			call break_point_state  
33f5				endm  
# End of macro CALLMONITOR
33f5					endif 
33f5			 
33f5				; go back to previous word 
33f5			 
33f5 d5				push de    ; save I for inc later 
33f6			 
33f6			 
33f6				; get limit 
33f6				;  is I at limit? 
33f6			 
33f6			 
33f6					if DEBUG_FORTH_WORDS 
33f6						DMARK "LP1" 
33f6 f5				push af  
33f7 3a 0b 34			ld a, (.dmark)  
33fa 32 b4 fe			ld (debug_mark),a  
33fd 3a 0c 34			ld a, (.dmark+1)  
3400 32 b5 fe			ld (debug_mark+1),a  
3403 3a 0d 34			ld a, (.dmark+2)  
3406 32 b6 fe			ld (debug_mark+2),a  
3409 18 03			jr .pastdmark  
340b ..			.dmark: db "LP1"  
340e f1			.pastdmark: pop af  
340f			endm  
# End of macro DMARK
340f						CALLMONITOR 
340f cd 78 18			call break_point_state  
3412				endm  
# End of macro CALLMONITOR
3412					endif 
3412			 
3412 ed 52			sbc hl, de 
3414			 
3414			 
3414				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3414			 
3414 20 26				jr nz, .loopnotdone 
3416			 
3416 e1				pop hl   ; get rid of saved I 
3417				FORTH_LOOP_POP     ; get rid of limit 
3417 cd 51 21			call macro_forth_loop_pop 
341a				endm 
# End of macro FORTH_LOOP_POP
341a			 
341a				FORTH_RSP_POP     ; get rid of DO ptr 
341a cd b4 1e			call macro_forth_rsp_pop 
341d				endm 
# End of macro FORTH_RSP_POP
341d			 
341d			if DEBUG_FORTH_WORDS 
341d						DMARK "LP>" 
341d f5				push af  
341e 3a 32 34			ld a, (.dmark)  
3421 32 b4 fe			ld (debug_mark),a  
3424 3a 33 34			ld a, (.dmark+1)  
3427 32 b5 fe			ld (debug_mark+1),a  
342a 3a 34 34			ld a, (.dmark+2)  
342d 32 b6 fe			ld (debug_mark+2),a  
3430 18 03			jr .pastdmark  
3432 ..			.dmark: db "LP>"  
3435 f1			.pastdmark: pop af  
3436			endm  
# End of macro DMARK
3436				CALLMONITOR 
3436 cd 78 18			call break_point_state  
3439				endm  
# End of macro CALLMONITOR
3439			endif 
3439			 
3439					NEXTW 
3439 c3 5a 22			jp macro_next 
343c				endm 
# End of macro NEXTW
343c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
343c			 
343c			.loopnotdone: 
343c			 
343c e1				pop hl    ; get I 
343d 23				inc hl 
343e			 
343e			   	; save new I 
343e			 
343e			 
343e					; set I counter 
343e			 
343e 22 aa f6				ld (os_current_i), hl 
3441			 
3441					if DEBUG_FORTH_WORDS 
3441						DMARK "LPN" 
3441 f5				push af  
3442 3a 56 34			ld a, (.dmark)  
3445 32 b4 fe			ld (debug_mark),a  
3448 3a 57 34			ld a, (.dmark+1)  
344b 32 b5 fe			ld (debug_mark+1),a  
344e 3a 58 34			ld a, (.dmark+2)  
3451 32 b6 fe			ld (debug_mark+2),a  
3454 18 03			jr .pastdmark  
3456 ..			.dmark: db "LPN"  
3459 f1			.pastdmark: pop af  
345a			endm  
# End of macro DMARK
345a					CALLMONITOR 
345a cd 78 18			call break_point_state  
345d				endm  
# End of macro CALLMONITOR
345d					endif 
345d					 
345d				FORTH_LOOP_NEXT 
345d cd 14 21			call macro_forth_loop_next 
3460				endm 
# End of macro FORTH_LOOP_NEXT
3460			 
3460			 
3460					if DEBUG_FORTH_WORDS 
3460 eb						ex de,hl 
3461					endif 
3461			 
3461			;	; get DO ptr 
3461			; 
3461					if DEBUG_FORTH_WORDS 
3461						DMARK "LP7" 
3461 f5				push af  
3462 3a 76 34			ld a, (.dmark)  
3465 32 b4 fe			ld (debug_mark),a  
3468 3a 77 34			ld a, (.dmark+1)  
346b 32 b5 fe			ld (debug_mark+1),a  
346e 3a 78 34			ld a, (.dmark+2)  
3471 32 b6 fe			ld (debug_mark+2),a  
3474 18 03			jr .pastdmark  
3476 ..			.dmark: db "LP7"  
3479 f1			.pastdmark: pop af  
347a			endm  
# End of macro DMARK
347a					CALLMONITOR 
347a cd 78 18			call break_point_state  
347d				endm  
# End of macro CALLMONITOR
347d					endif 
347d				FORTH_RSP_TOS 
347d cd aa 1e			call macro_forth_rsp_tos 
3480				endm 
# End of macro FORTH_RSP_TOS
3480			 
3480					if DEBUG_FORTH_WORDS 
3480						DMARK "LP8" 
3480 f5				push af  
3481 3a 95 34			ld a, (.dmark)  
3484 32 b4 fe			ld (debug_mark),a  
3487 3a 96 34			ld a, (.dmark+1)  
348a 32 b5 fe			ld (debug_mark+1),a  
348d 3a 97 34			ld a, (.dmark+2)  
3490 32 b6 fe			ld (debug_mark+2),a  
3493 18 03			jr .pastdmark  
3495 ..			.dmark: db "LP8"  
3498 f1			.pastdmark: pop af  
3499			endm  
# End of macro DMARK
3499					CALLMONITOR 
3499 cd 78 18			call break_point_state  
349c				endm  
# End of macro CALLMONITOR
349c					endif 
349c				;push hl 
349c			 
349c				; not going to DO any more 
349c				; get rid of the RSP pointer as DO will add it back in 
349c				;FORTH_RSP_POP 
349c				;pop hl 
349c			 
349c				;ld hl,(cli_ret_sp) 
349c				;ld e, (hl) 
349c				;inc hl 
349c				;ld d, (hl) 
349c				;ex de,hl 
349c 22 86 f6			ld (os_tok_ptr), hl 
349f					if DEBUG_FORTH_WORDS 
349f						DMARK "LP<" 
349f f5				push af  
34a0 3a b4 34			ld a, (.dmark)  
34a3 32 b4 fe			ld (debug_mark),a  
34a6 3a b5 34			ld a, (.dmark+1)  
34a9 32 b5 fe			ld (debug_mark+1),a  
34ac 3a b6 34			ld a, (.dmark+2)  
34af 32 b6 fe			ld (debug_mark+2),a  
34b2 18 03			jr .pastdmark  
34b4 ..			.dmark: db "LP<"  
34b7 f1			.pastdmark: pop af  
34b8			endm  
# End of macro DMARK
34b8					CALLMONITOR 
34b8 cd 78 18			call break_point_state  
34bb				endm  
# End of macro CALLMONITOR
34bb				endif 
34bb c3 eb 22			jp exec1 
34be			 
34be					 
34be			 
34be			 
34be					NEXTW 
34be c3 5a 22			jp macro_next 
34c1				endm 
# End of macro NEXTW
34c1			.I:  
34c1			 
34c1				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
34c1 5e				db WORD_SYS_CORE+74             
34c2 ec 34			dw .DLOOP            
34c4 02				db 1 + 1 
34c5 .. 00			db "I",0              
34c7				endm 
# End of macro CWHEAD
34c7			; | I ( -- ) Current loop counter | DONE 
34c7					if DEBUG_FORTH_WORDS_KEY 
34c7						DMARK "I.." 
34c7 f5				push af  
34c8 3a dc 34			ld a, (.dmark)  
34cb 32 b4 fe			ld (debug_mark),a  
34ce 3a dd 34			ld a, (.dmark+1)  
34d1 32 b5 fe			ld (debug_mark+1),a  
34d4 3a de 34			ld a, (.dmark+2)  
34d7 32 b6 fe			ld (debug_mark+2),a  
34da 18 03			jr .pastdmark  
34dc ..			.dmark: db "I.."  
34df f1			.pastdmark: pop af  
34e0			endm  
# End of macro DMARK
34e0						CALLMONITOR 
34e0 cd 78 18			call break_point_state  
34e3				endm  
# End of macro CALLMONITOR
34e3					endif 
34e3			 
34e3 2a aa f6				ld hl,(os_current_i) 
34e6 cd ec 1e				call forth_push_numhl 
34e9			 
34e9					NEXTW 
34e9 c3 5a 22			jp macro_next 
34ec				endm 
# End of macro NEXTW
34ec			.DLOOP: 
34ec				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
34ec 5f				db WORD_SYS_CORE+75             
34ed cd 35			dw .REPEAT            
34ef 06				db 5 + 1 
34f0 .. 00			db "-LOOP",0              
34f6				endm 
# End of macro CWHEAD
34f6			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
34f6				; pop tos as current loop count to hl 
34f6					if DEBUG_FORTH_WORDS_KEY 
34f6						DMARK "-LP" 
34f6 f5				push af  
34f7 3a 0b 35			ld a, (.dmark)  
34fa 32 b4 fe			ld (debug_mark),a  
34fd 3a 0c 35			ld a, (.dmark+1)  
3500 32 b5 fe			ld (debug_mark+1),a  
3503 3a 0d 35			ld a, (.dmark+2)  
3506 32 b6 fe			ld (debug_mark+2),a  
3509 18 03			jr .pastdmark  
350b ..			.dmark: db "-LP"  
350e f1			.pastdmark: pop af  
350f			endm  
# End of macro DMARK
350f						CALLMONITOR 
350f cd 78 18			call break_point_state  
3512				endm  
# End of macro CALLMONITOR
3512					endif 
3512			 
3512				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3512			 
3512				FORTH_LOOP_TOS 
3512 cd 47 21			call macro_forth_loop_tos 
3515				endm 
# End of macro FORTH_LOOP_TOS
3515 e5				push hl 
3516			 
3516					if DEBUG_FORTH_WORDS 
3516						DMARK "-LP" 
3516 f5				push af  
3517 3a 2b 35			ld a, (.dmark)  
351a 32 b4 fe			ld (debug_mark),a  
351d 3a 2c 35			ld a, (.dmark+1)  
3520 32 b5 fe			ld (debug_mark+1),a  
3523 3a 2d 35			ld a, (.dmark+2)  
3526 32 b6 fe			ld (debug_mark+2),a  
3529 18 03			jr .pastdmark  
352b ..			.dmark: db "-LP"  
352e f1			.pastdmark: pop af  
352f			endm  
# End of macro DMARK
352f						CALLMONITOR 
352f cd 78 18			call break_point_state  
3532				endm  
# End of macro CALLMONITOR
3532					endif 
3532				; next item on the stack is the limit. get it 
3532			 
3532			 
3532				FORTH_LOOP_POP 
3532 cd 51 21			call macro_forth_loop_pop 
3535				endm 
# End of macro FORTH_LOOP_POP
3535			 
3535				FORTH_LOOP_TOS 
3535 cd 47 21			call macro_forth_loop_tos 
3538				endm 
# End of macro FORTH_LOOP_TOS
3538			 
3538 d1				pop de		 ; de = i, hl = limit 
3539			 
3539					if DEBUG_FORTH_WORDS 
3539						DMARK "-L1" 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 b4 fe			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 b5 fe			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 b6 fe			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "-L1"  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552						CALLMONITOR 
3552 cd 78 18			call break_point_state  
3555				endm  
# End of macro CALLMONITOR
3555					endif 
3555			 
3555				; go back to previous word 
3555			 
3555 d5				push de    ; save I for inc later 
3556			 
3556			 
3556				; get limit 
3556				;  is I at limit? 
3556			 
3556			 
3556					if DEBUG_FORTH_WORDS 
3556						DMARK "-L1" 
3556 f5				push af  
3557 3a 6b 35			ld a, (.dmark)  
355a 32 b4 fe			ld (debug_mark),a  
355d 3a 6c 35			ld a, (.dmark+1)  
3560 32 b5 fe			ld (debug_mark+1),a  
3563 3a 6d 35			ld a, (.dmark+2)  
3566 32 b6 fe			ld (debug_mark+2),a  
3569 18 03			jr .pastdmark  
356b ..			.dmark: db "-L1"  
356e f1			.pastdmark: pop af  
356f			endm  
# End of macro DMARK
356f						CALLMONITOR 
356f cd 78 18			call break_point_state  
3572				endm  
# End of macro CALLMONITOR
3572					endif 
3572			 
3572 ed 52			sbc hl, de 
3574			 
3574			 
3574				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3574			 
3574 20 26				jr nz, .mloopnotdone 
3576			 
3576 e1				pop hl   ; get rid of saved I 
3577				FORTH_LOOP_POP     ; get rid of limit 
3577 cd 51 21			call macro_forth_loop_pop 
357a				endm 
# End of macro FORTH_LOOP_POP
357a			 
357a				FORTH_RSP_POP     ; get rid of DO ptr 
357a cd b4 1e			call macro_forth_rsp_pop 
357d				endm 
# End of macro FORTH_RSP_POP
357d			 
357d			if DEBUG_FORTH_WORDS 
357d						DMARK "-L>" 
357d f5				push af  
357e 3a 92 35			ld a, (.dmark)  
3581 32 b4 fe			ld (debug_mark),a  
3584 3a 93 35			ld a, (.dmark+1)  
3587 32 b5 fe			ld (debug_mark+1),a  
358a 3a 94 35			ld a, (.dmark+2)  
358d 32 b6 fe			ld (debug_mark+2),a  
3590 18 03			jr .pastdmark  
3592 ..			.dmark: db "-L>"  
3595 f1			.pastdmark: pop af  
3596			endm  
# End of macro DMARK
3596				CALLMONITOR 
3596 cd 78 18			call break_point_state  
3599				endm  
# End of macro CALLMONITOR
3599			endif 
3599			 
3599					NEXTW 
3599 c3 5a 22			jp macro_next 
359c				endm 
# End of macro NEXTW
359c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
359c			 
359c			.mloopnotdone: 
359c			 
359c e1				pop hl    ; get I 
359d 2b				dec hl 
359e			 
359e			   	; save new I 
359e			 
359e			 
359e					; set I counter 
359e			 
359e 22 aa f6				ld (os_current_i), hl 
35a1			 
35a1					 
35a1				FORTH_LOOP_NEXT 
35a1 cd 14 21			call macro_forth_loop_next 
35a4				endm 
# End of macro FORTH_LOOP_NEXT
35a4			 
35a4			 
35a4					if DEBUG_FORTH_WORDS 
35a4 eb						ex de,hl 
35a5					endif 
35a5			 
35a5			;	; get DO ptr 
35a5			; 
35a5				FORTH_RSP_TOS 
35a5 cd aa 1e			call macro_forth_rsp_tos 
35a8				endm 
# End of macro FORTH_RSP_TOS
35a8			 
35a8				;push hl 
35a8			 
35a8				; not going to DO any more 
35a8				; get rid of the RSP pointer as DO will add it back in 
35a8				;FORTH_RSP_POP 
35a8				;pop hl 
35a8			 
35a8			 
35a8 22 86 f6			ld (os_tok_ptr), hl 
35ab					if DEBUG_FORTH_WORDS 
35ab						DMARK "-L<" 
35ab f5				push af  
35ac 3a c0 35			ld a, (.dmark)  
35af 32 b4 fe			ld (debug_mark),a  
35b2 3a c1 35			ld a, (.dmark+1)  
35b5 32 b5 fe			ld (debug_mark+1),a  
35b8 3a c2 35			ld a, (.dmark+2)  
35bb 32 b6 fe			ld (debug_mark+2),a  
35be 18 03			jr .pastdmark  
35c0 ..			.dmark: db "-L<"  
35c3 f1			.pastdmark: pop af  
35c4			endm  
# End of macro DMARK
35c4					CALLMONITOR 
35c4 cd 78 18			call break_point_state  
35c7				endm  
# End of macro CALLMONITOR
35c7				endif 
35c7 c3 eb 22			jp exec1 
35ca			 
35ca					 
35ca			 
35ca			 
35ca			 
35ca				NEXTW 
35ca c3 5a 22			jp macro_next 
35cd				endm 
# End of macro NEXTW
35cd			 
35cd			 
35cd			 
35cd			 
35cd			.REPEAT: 
35cd				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
35cd 71				db WORD_SYS_CORE+93             
35ce 20 36			dw .UNTIL            
35d0 06				db 5 + 1 
35d1 .. 00			db "REPEAT",0              
35d8				endm 
# End of macro CWHEAD
35d8			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
35d8			;  push pc to rsp stack past the REPEAT 
35d8					if DEBUG_FORTH_WORDS_KEY 
35d8						DMARK "REP" 
35d8 f5				push af  
35d9 3a ed 35			ld a, (.dmark)  
35dc 32 b4 fe			ld (debug_mark),a  
35df 3a ee 35			ld a, (.dmark+1)  
35e2 32 b5 fe			ld (debug_mark+1),a  
35e5 3a ef 35			ld a, (.dmark+2)  
35e8 32 b6 fe			ld (debug_mark+2),a  
35eb 18 03			jr .pastdmark  
35ed ..			.dmark: db "REP"  
35f0 f1			.pastdmark: pop af  
35f1			endm  
# End of macro DMARK
35f1						CALLMONITOR 
35f1 cd 78 18			call break_point_state  
35f4				endm  
# End of macro CALLMONITOR
35f4					endif 
35f4			 
35f4 2a 86 f6				ld hl, (os_tok_ptr) 
35f7 23					inc hl   ; R 
35f8 23					inc hl  ; E 
35f9 23					inc hl   ; P 
35fa 23					inc hl   ; E 
35fb 23					inc hl   ; A 
35fc 23					inc hl   ; T 
35fd 23					inc hl   ; zero 
35fe					FORTH_RSP_NEXT 
35fe cd 93 1e			call macro_forth_rsp_next 
3601				endm 
# End of macro FORTH_RSP_NEXT
3601			 
3601			 
3601					if DEBUG_FORTH_WORDS 
3601						DMARK "REP" 
3601 f5				push af  
3602 3a 16 36			ld a, (.dmark)  
3605 32 b4 fe			ld (debug_mark),a  
3608 3a 17 36			ld a, (.dmark+1)  
360b 32 b5 fe			ld (debug_mark+1),a  
360e 3a 18 36			ld a, (.dmark+2)  
3611 32 b6 fe			ld (debug_mark+2),a  
3614 18 03			jr .pastdmark  
3616 ..			.dmark: db "REP"  
3619 f1			.pastdmark: pop af  
361a			endm  
# End of macro DMARK
361a						;pop bc    ; TODO BUG ?????? what is this for???? 
361a						CALLMONITOR 
361a cd 78 18			call break_point_state  
361d				endm  
# End of macro CALLMONITOR
361d					endif 
361d			 
361d					NEXTW 
361d c3 5a 22			jp macro_next 
3620				endm 
# End of macro NEXTW
3620			;	       NEXTW 
3620			 
3620			.UNTIL: 
3620				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3620 72				db WORD_SYS_CORE+94             
3621 b7 36			dw .ENDFLOW            
3623 06				db 5 + 1 
3624 .. 00			db "UNTIL",0              
362a				endm 
# End of macro CWHEAD
362a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
362a			 
362a				; pop tos as check 
362a			 
362a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
362a			 
362a				FORTH_DSP_VALUEHL 
362a cd e3 20			call macro_dsp_valuehl 
362d				endm 
# End of macro FORTH_DSP_VALUEHL
362d			 
362d					if DEBUG_FORTH_WORDS_KEY 
362d						DMARK "UNT" 
362d f5				push af  
362e 3a 42 36			ld a, (.dmark)  
3631 32 b4 fe			ld (debug_mark),a  
3634 3a 43 36			ld a, (.dmark+1)  
3637 32 b5 fe			ld (debug_mark+1),a  
363a 3a 44 36			ld a, (.dmark+2)  
363d 32 b6 fe			ld (debug_mark+2),a  
3640 18 03			jr .pastdmark  
3642 ..			.dmark: db "UNT"  
3645 f1			.pastdmark: pop af  
3646			endm  
# End of macro DMARK
3646						CALLMONITOR 
3646 cd 78 18			call break_point_state  
3649				endm  
# End of macro CALLMONITOR
3649					endif 
3649			 
3649			;	push hl 
3649				FORTH_DSP_POP 
3649 cd 9b 21			call macro_forth_dsp_pop 
364c				endm 
# End of macro FORTH_DSP_POP
364c			 
364c			;	pop hl 
364c			 
364c				; test if true 
364c			 
364c cd 24 0f			call ishlzero 
364f			;	ld a,l 
364f			;	add h 
364f			; 
364f			;	cp 0 
364f			 
364f 20 3e			jr nz, .untilnotdone 
3651			 
3651					if DEBUG_FORTH_WORDS 
3651						DMARK "UNf" 
3651 f5				push af  
3652 3a 66 36			ld a, (.dmark)  
3655 32 b4 fe			ld (debug_mark),a  
3658 3a 67 36			ld a, (.dmark+1)  
365b 32 b5 fe			ld (debug_mark+1),a  
365e 3a 68 36			ld a, (.dmark+2)  
3661 32 b6 fe			ld (debug_mark+2),a  
3664 18 03			jr .pastdmark  
3666 ..			.dmark: db "UNf"  
3669 f1			.pastdmark: pop af  
366a			endm  
# End of macro DMARK
366a						CALLMONITOR 
366a cd 78 18			call break_point_state  
366d				endm  
# End of macro CALLMONITOR
366d					endif 
366d			 
366d			 
366d			 
366d				FORTH_RSP_POP     ; get rid of DO ptr 
366d cd b4 1e			call macro_forth_rsp_pop 
3670				endm 
# End of macro FORTH_RSP_POP
3670			 
3670			if DEBUG_FORTH_WORDS 
3670						DMARK "UN>" 
3670 f5				push af  
3671 3a 85 36			ld a, (.dmark)  
3674 32 b4 fe			ld (debug_mark),a  
3677 3a 86 36			ld a, (.dmark+1)  
367a 32 b5 fe			ld (debug_mark+1),a  
367d 3a 87 36			ld a, (.dmark+2)  
3680 32 b6 fe			ld (debug_mark+2),a  
3683 18 03			jr .pastdmark  
3685 ..			.dmark: db "UN>"  
3688 f1			.pastdmark: pop af  
3689			endm  
# End of macro DMARK
3689				CALLMONITOR 
3689 cd 78 18			call break_point_state  
368c				endm  
# End of macro CALLMONITOR
368c			endif 
368c			 
368c					NEXTW 
368c c3 5a 22			jp macro_next 
368f				endm 
# End of macro NEXTW
368f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
368f			 
368f			.untilnotdone: 
368f			 
368f			 
368f			;	; get DO ptr 
368f			; 
368f				FORTH_RSP_TOS 
368f cd aa 1e			call macro_forth_rsp_tos 
3692				endm 
# End of macro FORTH_RSP_TOS
3692			 
3692				;push hl 
3692			 
3692				; not going to DO any more 
3692				; get rid of the RSP pointer as DO will add it back in 
3692				;FORTH_RSP_POP 
3692				;pop hl 
3692			 
3692			 
3692 22 86 f6			ld (os_tok_ptr), hl 
3695					if DEBUG_FORTH_WORDS 
3695						DMARK "UN<" 
3695 f5				push af  
3696 3a aa 36			ld a, (.dmark)  
3699 32 b4 fe			ld (debug_mark),a  
369c 3a ab 36			ld a, (.dmark+1)  
369f 32 b5 fe			ld (debug_mark+1),a  
36a2 3a ac 36			ld a, (.dmark+2)  
36a5 32 b6 fe			ld (debug_mark+2),a  
36a8 18 03			jr .pastdmark  
36aa ..			.dmark: db "UN<"  
36ad f1			.pastdmark: pop af  
36ae			endm  
# End of macro DMARK
36ae					CALLMONITOR 
36ae cd 78 18			call break_point_state  
36b1				endm  
# End of macro CALLMONITOR
36b1				endif 
36b1 c3 eb 22			jp exec1 
36b4			 
36b4					 
36b4			 
36b4			 
36b4					NEXTW 
36b4 c3 5a 22			jp macro_next 
36b7				endm 
# End of macro NEXTW
36b7			 
36b7			 
36b7			.ENDFLOW: 
36b7			 
36b7			; eof 
36b7			 
# End of file forth_words_flow.asm
36b7			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
36b7			include "forth_words_logic.asm" 
36b7			 
36b7			; | ## Logic Words 
36b7			 
36b7			.NOT: 
36b7				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
36b7 2d				db WORD_SYS_CORE+25             
36b8 ff 36			dw .IS            
36ba 04				db 3 + 1 
36bb .. 00			db "NOT",0              
36bf				endm 
# End of macro CWHEAD
36bf			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
36bf					if DEBUG_FORTH_WORDS_KEY 
36bf						DMARK "NOT" 
36bf f5				push af  
36c0 3a d4 36			ld a, (.dmark)  
36c3 32 b4 fe			ld (debug_mark),a  
36c6 3a d5 36			ld a, (.dmark+1)  
36c9 32 b5 fe			ld (debug_mark+1),a  
36cc 3a d6 36			ld a, (.dmark+2)  
36cf 32 b6 fe			ld (debug_mark+2),a  
36d2 18 03			jr .pastdmark  
36d4 ..			.dmark: db "NOT"  
36d7 f1			.pastdmark: pop af  
36d8			endm  
# End of macro DMARK
36d8						CALLMONITOR 
36d8 cd 78 18			call break_point_state  
36db				endm  
# End of macro CALLMONITOR
36db					endif 
36db					FORTH_DSP 
36db cd a9 20			call macro_forth_dsp 
36de				endm 
# End of macro FORTH_DSP
36de 7e					ld a,(hl)	; get type of value on TOS 
36df fe 02				cp DS_TYPE_INUM  
36e1 28 03				jr z, .noti 
36e3					NEXTW 
36e3 c3 5a 22			jp macro_next 
36e6				endm 
# End of macro NEXTW
36e6			.noti:          FORTH_DSP_VALUEHL 
36e6 cd e3 20			call macro_dsp_valuehl 
36e9				endm 
# End of macro FORTH_DSP_VALUEHL
36e9			;		push hl 
36e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e9 cd 9b 21			call macro_forth_dsp_pop 
36ec				endm 
# End of macro FORTH_DSP_POP
36ec			;		pop hl 
36ec 3e 00				ld a,0 
36ee bd					cp l 
36ef 28 04				jr z, .not2t 
36f1 2e 00				ld l, 0 
36f3 18 02				jr .notip 
36f5			 
36f5 2e ff		.not2t:		ld l, 255 
36f7			 
36f7 26 00		.notip:		ld h, 0	 
36f9			 
36f9 cd ec 1e				call forth_push_numhl 
36fc					NEXTW 
36fc c3 5a 22			jp macro_next 
36ff				endm 
# End of macro NEXTW
36ff			 
36ff			.IS: 
36ff				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
36ff 2d				db WORD_SYS_CORE+25             
3700 25 37			dw .LZERO            
3702 03				db 2 + 1 
3703 .. 00			db "IS",0              
3706				endm 
# End of macro CWHEAD
3706			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3706					if DEBUG_FORTH_WORDS_KEY 
3706						DMARK "IS." 
3706 f5				push af  
3707 3a 1b 37			ld a, (.dmark)  
370a 32 b4 fe			ld (debug_mark),a  
370d 3a 1c 37			ld a, (.dmark+1)  
3710 32 b5 fe			ld (debug_mark+1),a  
3713 3a 1d 37			ld a, (.dmark+2)  
3716 32 b6 fe			ld (debug_mark+2),a  
3719 18 03			jr .pastdmark  
371b ..			.dmark: db "IS."  
371e f1			.pastdmark: pop af  
371f			endm  
# End of macro DMARK
371f						CALLMONITOR 
371f cd 78 18			call break_point_state  
3722				endm  
# End of macro CALLMONITOR
3722					endif 
3722					NEXTW 
3722 c3 5a 22			jp macro_next 
3725				endm 
# End of macro NEXTW
3725			.LZERO: 
3725				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3725 2d				db WORD_SYS_CORE+25             
3726 2f 37			dw .TZERO            
3728 03				db 2 + 1 
3729 .. 00			db "0<",0              
372c				endm 
# End of macro CWHEAD
372c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
372c					NEXTW 
372c c3 5a 22			jp macro_next 
372f				endm 
# End of macro NEXTW
372f			.TZERO: 
372f				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
372f 2e				db WORD_SYS_CORE+26             
3730 76 37			dw .LESS            
3732 03				db 2 + 1 
3733 .. 00			db "0=",0              
3736				endm 
# End of macro CWHEAD
3736			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3736				; TODO add floating point number detection 
3736					;v5 FORTH_DSP_VALUE 
3736					if DEBUG_FORTH_WORDS_KEY 
3736						DMARK "0=." 
3736 f5				push af  
3737 3a 4b 37			ld a, (.dmark)  
373a 32 b4 fe			ld (debug_mark),a  
373d 3a 4c 37			ld a, (.dmark+1)  
3740 32 b5 fe			ld (debug_mark+1),a  
3743 3a 4d 37			ld a, (.dmark+2)  
3746 32 b6 fe			ld (debug_mark+2),a  
3749 18 03			jr .pastdmark  
374b ..			.dmark: db "0=."  
374e f1			.pastdmark: pop af  
374f			endm  
# End of macro DMARK
374f						CALLMONITOR 
374f cd 78 18			call break_point_state  
3752				endm  
# End of macro CALLMONITOR
3752					endif 
3752					FORTH_DSP 
3752 cd a9 20			call macro_forth_dsp 
3755				endm 
# End of macro FORTH_DSP
3755 7e					ld a,(hl)	; get type of value on TOS 
3756 fe 02				cp DS_TYPE_INUM  
3758 28 00				jr z, .tz_inum 
375a			 
375a				if FORTH_ENABLE_FLOATMATH 
375a					jr .tz_done 
375a			 
375a				endif 
375a					 
375a			 
375a			.tz_inum: 
375a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
375a cd e3 20			call macro_dsp_valuehl 
375d				endm 
# End of macro FORTH_DSP_VALUEHL
375d			 
375d			;		push hl 
375d			 
375d					; destroy value TOS 
375d			 
375d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375d cd 9b 21			call macro_forth_dsp_pop 
3760				endm 
# End of macro FORTH_DSP_POP
3760			 
3760			;		pop hl 
3760			 
3760 3e 00				ld a,0 
3762			 
3762 bd					cp l 
3763 20 08				jr nz, .tz_notzero 
3765			 
3765 bc					cp h 
3766			 
3766 20 05				jr nz, .tz_notzero 
3768			 
3768			 
3768 21 01 00				ld hl, FORTH_TRUE 
376b 18 03				jr .tz_done 
376d			 
376d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3770			 
3770					; push value back onto stack for another op etc 
3770			 
3770			.tz_done: 
3770 cd ec 1e				call forth_push_numhl 
3773			 
3773					NEXTW 
3773 c3 5a 22			jp macro_next 
3776				endm 
# End of macro NEXTW
3776			.LESS: 
3776				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3776 2f				db WORD_SYS_CORE+27             
3777 df 37			dw .GT            
3779 02				db 1 + 1 
377a .. 00			db "<",0              
377c				endm 
# End of macro CWHEAD
377c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
377c				; TODO add floating point number detection 
377c					if DEBUG_FORTH_WORDS_KEY 
377c						DMARK "LES" 
377c f5				push af  
377d 3a 91 37			ld a, (.dmark)  
3780 32 b4 fe			ld (debug_mark),a  
3783 3a 92 37			ld a, (.dmark+1)  
3786 32 b5 fe			ld (debug_mark+1),a  
3789 3a 93 37			ld a, (.dmark+2)  
378c 32 b6 fe			ld (debug_mark+2),a  
378f 18 03			jr .pastdmark  
3791 ..			.dmark: db "LES"  
3794 f1			.pastdmark: pop af  
3795			endm  
# End of macro DMARK
3795						CALLMONITOR 
3795 cd 78 18			call break_point_state  
3798				endm  
# End of macro CALLMONITOR
3798					endif 
3798					FORTH_DSP 
3798 cd a9 20			call macro_forth_dsp 
379b				endm 
# End of macro FORTH_DSP
379b					;v5 FORTH_DSP_VALUE 
379b 7e					ld a,(hl)	; get type of value on TOS 
379c fe 02				cp DS_TYPE_INUM  
379e 28 00				jr z, .less_inum 
37a0			 
37a0				if FORTH_ENABLE_FLOATMATH 
37a0					jr .less_done 
37a0			 
37a0				endif 
37a0					 
37a0			 
37a0			.less_inum: 
37a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a0 cd e3 20			call macro_dsp_valuehl 
37a3				endm 
# End of macro FORTH_DSP_VALUEHL
37a3			 
37a3 e5					push hl  ; u2 
37a4			 
37a4					; destroy value TOS 
37a4			 
37a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a4 cd 9b 21			call macro_forth_dsp_pop 
37a7				endm 
# End of macro FORTH_DSP_POP
37a7			 
37a7			 
37a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a7 cd e3 20			call macro_dsp_valuehl 
37aa				endm 
# End of macro FORTH_DSP_VALUEHL
37aa			 
37aa e5					push hl    ; u1 
37ab			 
37ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ab cd 9b 21			call macro_forth_dsp_pop 
37ae				endm 
# End of macro FORTH_DSP_POP
37ae			 
37ae			 
37ae b7			 or a      ;clear carry flag 
37af 01 00 00		 ld bc, FORTH_FALSE 
37b2 e1			  pop hl    ; u1 
37b3 d1			  pop de    ; u2 
37b4 ed 52		  sbc hl,de 
37b6 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
37b8			 
37b8 01 01 00		 ld bc, FORTH_TRUE 
37bb			.lscont:  
37bb c5					push bc 
37bc e1					pop hl 
37bd			 
37bd					if DEBUG_FORTH_WORDS 
37bd						DMARK "LT1" 
37bd f5				push af  
37be 3a d2 37			ld a, (.dmark)  
37c1 32 b4 fe			ld (debug_mark),a  
37c4 3a d3 37			ld a, (.dmark+1)  
37c7 32 b5 fe			ld (debug_mark+1),a  
37ca 3a d4 37			ld a, (.dmark+2)  
37cd 32 b6 fe			ld (debug_mark+2),a  
37d0 18 03			jr .pastdmark  
37d2 ..			.dmark: db "LT1"  
37d5 f1			.pastdmark: pop af  
37d6			endm  
# End of macro DMARK
37d6						CALLMONITOR 
37d6 cd 78 18			call break_point_state  
37d9				endm  
# End of macro CALLMONITOR
37d9					endif 
37d9 cd ec 1e				call forth_push_numhl 
37dc			 
37dc					NEXTW 
37dc c3 5a 22			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			.GT: 
37df				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
37df 30				db WORD_SYS_CORE+28             
37e0 48 38			dw .EQUAL            
37e2 02				db 1 + 1 
37e3 .. 00			db ">",0              
37e5				endm 
# End of macro CWHEAD
37e5			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
37e5				; TODO add floating point number detection 
37e5					if DEBUG_FORTH_WORDS_KEY 
37e5						DMARK "GRT" 
37e5 f5				push af  
37e6 3a fa 37			ld a, (.dmark)  
37e9 32 b4 fe			ld (debug_mark),a  
37ec 3a fb 37			ld a, (.dmark+1)  
37ef 32 b5 fe			ld (debug_mark+1),a  
37f2 3a fc 37			ld a, (.dmark+2)  
37f5 32 b6 fe			ld (debug_mark+2),a  
37f8 18 03			jr .pastdmark  
37fa ..			.dmark: db "GRT"  
37fd f1			.pastdmark: pop af  
37fe			endm  
# End of macro DMARK
37fe						CALLMONITOR 
37fe cd 78 18			call break_point_state  
3801				endm  
# End of macro CALLMONITOR
3801					endif 
3801					FORTH_DSP 
3801 cd a9 20			call macro_forth_dsp 
3804				endm 
# End of macro FORTH_DSP
3804					;FORTH_DSP_VALUE 
3804 7e					ld a,(hl)	; get type of value on TOS 
3805 fe 02				cp DS_TYPE_INUM  
3807 28 00				jr z, .gt_inum 
3809			 
3809				if FORTH_ENABLE_FLOATMATH 
3809					jr .gt_done 
3809			 
3809				endif 
3809					 
3809			 
3809			.gt_inum: 
3809					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3809 cd e3 20			call macro_dsp_valuehl 
380c				endm 
# End of macro FORTH_DSP_VALUEHL
380c			 
380c e5					push hl  ; u2 
380d			 
380d					; destroy value TOS 
380d			 
380d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380d cd 9b 21			call macro_forth_dsp_pop 
3810				endm 
# End of macro FORTH_DSP_POP
3810			 
3810			 
3810					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3810 cd e3 20			call macro_dsp_valuehl 
3813				endm 
# End of macro FORTH_DSP_VALUEHL
3813			 
3813 e5					push hl    ; u1 
3814			 
3814					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3814 cd 9b 21			call macro_forth_dsp_pop 
3817				endm 
# End of macro FORTH_DSP_POP
3817			 
3817			 
3817 b7			 or a      ;clear carry flag 
3818 01 00 00		 ld bc, FORTH_FALSE 
381b e1			  pop hl    ; u1 
381c d1			  pop de    ; u2 
381d ed 52		  sbc hl,de 
381f 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3821			 
3821 01 01 00		 ld bc, FORTH_TRUE 
3824			.gtcont:  
3824 c5					push bc 
3825 e1					pop hl 
3826			 
3826					if DEBUG_FORTH_WORDS 
3826						DMARK "GT1" 
3826 f5				push af  
3827 3a 3b 38			ld a, (.dmark)  
382a 32 b4 fe			ld (debug_mark),a  
382d 3a 3c 38			ld a, (.dmark+1)  
3830 32 b5 fe			ld (debug_mark+1),a  
3833 3a 3d 38			ld a, (.dmark+2)  
3836 32 b6 fe			ld (debug_mark+2),a  
3839 18 03			jr .pastdmark  
383b ..			.dmark: db "GT1"  
383e f1			.pastdmark: pop af  
383f			endm  
# End of macro DMARK
383f						CALLMONITOR 
383f cd 78 18			call break_point_state  
3842				endm  
# End of macro CALLMONITOR
3842					endif 
3842 cd ec 1e				call forth_push_numhl 
3845			 
3845					NEXTW 
3845 c3 5a 22			jp macro_next 
3848				endm 
# End of macro NEXTW
3848			.EQUAL: 
3848				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3848 31				db WORD_SYS_CORE+29             
3849 b3 38			dw .ENDLOGIC            
384b 02				db 1 + 1 
384c .. 00			db "=",0              
384e				endm 
# End of macro CWHEAD
384e			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
384e				; TODO add floating point number detection 
384e					if DEBUG_FORTH_WORDS_KEY 
384e						DMARK "EQ." 
384e f5				push af  
384f 3a 63 38			ld a, (.dmark)  
3852 32 b4 fe			ld (debug_mark),a  
3855 3a 64 38			ld a, (.dmark+1)  
3858 32 b5 fe			ld (debug_mark+1),a  
385b 3a 65 38			ld a, (.dmark+2)  
385e 32 b6 fe			ld (debug_mark+2),a  
3861 18 03			jr .pastdmark  
3863 ..			.dmark: db "EQ."  
3866 f1			.pastdmark: pop af  
3867			endm  
# End of macro DMARK
3867						CALLMONITOR 
3867 cd 78 18			call break_point_state  
386a				endm  
# End of macro CALLMONITOR
386a					endif 
386a					FORTH_DSP 
386a cd a9 20			call macro_forth_dsp 
386d				endm 
# End of macro FORTH_DSP
386d					;v5 FORTH_DSP_VALUE 
386d 7e					ld a,(hl)	; get type of value on TOS 
386e fe 02				cp DS_TYPE_INUM  
3870 28 00				jr z, .eq_inum 
3872			 
3872				if FORTH_ENABLE_FLOATMATH 
3872					jr .eq_done 
3872			 
3872				endif 
3872					 
3872			 
3872			.eq_inum: 
3872					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3872 cd e3 20			call macro_dsp_valuehl 
3875				endm 
# End of macro FORTH_DSP_VALUEHL
3875			 
3875 e5					push hl 
3876			 
3876					; destroy value TOS 
3876			 
3876					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3876 cd 9b 21			call macro_forth_dsp_pop 
3879				endm 
# End of macro FORTH_DSP_POP
3879			 
3879			 
3879					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3879 cd e3 20			call macro_dsp_valuehl 
387c				endm 
# End of macro FORTH_DSP_VALUEHL
387c			 
387c					; one value on hl get other one back 
387c			 
387c e5					push hl 
387d			 
387d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
387d cd 9b 21			call macro_forth_dsp_pop 
3880				endm 
# End of macro FORTH_DSP_POP
3880			 
3880 0e 00				ld c, FORTH_FALSE 
3882			 
3882 e1					pop hl 
3883 d1					pop de 
3884			 
3884 7b					ld a, e 
3885 bd					cp l 
3886			 
3886 20 06				jr nz, .eq_done 
3888			 
3888 7a					ld a, d 
3889 bc					cp h 
388a			 
388a 20 02				jr nz, .eq_done 
388c			 
388c 0e 01				ld c, FORTH_TRUE 
388e					 
388e			 
388e			 
388e			.eq_done: 
388e			 
388e					; TODO push value back onto stack for another op etc 
388e			 
388e 26 00				ld h, 0 
3890 69					ld l, c 
3891					if DEBUG_FORTH_WORDS 
3891						DMARK "EQ1" 
3891 f5				push af  
3892 3a a6 38			ld a, (.dmark)  
3895 32 b4 fe			ld (debug_mark),a  
3898 3a a7 38			ld a, (.dmark+1)  
389b 32 b5 fe			ld (debug_mark+1),a  
389e 3a a8 38			ld a, (.dmark+2)  
38a1 32 b6 fe			ld (debug_mark+2),a  
38a4 18 03			jr .pastdmark  
38a6 ..			.dmark: db "EQ1"  
38a9 f1			.pastdmark: pop af  
38aa			endm  
# End of macro DMARK
38aa						CALLMONITOR 
38aa cd 78 18			call break_point_state  
38ad				endm  
# End of macro CALLMONITOR
38ad					endif 
38ad cd ec 1e				call forth_push_numhl 
38b0			 
38b0					NEXTW 
38b0 c3 5a 22			jp macro_next 
38b3				endm 
# End of macro NEXTW
38b3			 
38b3			 
38b3			.ENDLOGIC: 
38b3			; eof 
38b3			 
38b3			 
# End of file forth_words_logic.asm
38b3			include "forth_words_maths.asm" 
38b3			 
38b3			; | ## Maths Words 
38b3			 
38b3			.PLUS:	 
38b3				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
38b3 15				db WORD_SYS_CORE+1             
38b4 f5 38			dw .NEG            
38b6 02				db 1 + 1 
38b7 .. 00			db "+",0              
38b9				endm 
# End of macro CWHEAD
38b9			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
38b9					if DEBUG_FORTH_WORDS_KEY 
38b9						DMARK "PLU" 
38b9 f5				push af  
38ba 3a ce 38			ld a, (.dmark)  
38bd 32 b4 fe			ld (debug_mark),a  
38c0 3a cf 38			ld a, (.dmark+1)  
38c3 32 b5 fe			ld (debug_mark+1),a  
38c6 3a d0 38			ld a, (.dmark+2)  
38c9 32 b6 fe			ld (debug_mark+2),a  
38cc 18 03			jr .pastdmark  
38ce ..			.dmark: db "PLU"  
38d1 f1			.pastdmark: pop af  
38d2			endm  
# End of macro DMARK
38d2						CALLMONITOR 
38d2 cd 78 18			call break_point_state  
38d5				endm  
# End of macro CALLMONITOR
38d5					endif 
38d5					; add top two values and push back result 
38d5			 
38d5					;for v5 FORTH_DSP_VALUE 
38d5					FORTH_DSP 
38d5 cd a9 20			call macro_forth_dsp 
38d8				endm 
# End of macro FORTH_DSP
38d8 7e					ld a,(hl)	; get type of value on TOS 
38d9 fe 02				cp DS_TYPE_INUM  
38db 28 03				jr z, .dot_inum 
38dd			 
38dd					NEXTW 
38dd c3 5a 22			jp macro_next 
38e0				endm 
# End of macro NEXTW
38e0			 
38e0			; float maths 
38e0			 
38e0				if FORTH_ENABLE_FLOATMATH 
38e0						inc hl      ; now at start of numeric as string 
38e0			 
38e0					if DEBUG_FORTH_MATHS 
38e0						DMARK "ADD" 
38e0				CALLMONITOR 
38e0					endif 
38e0			 
38e0					;ld ix, hl 
38e0					call CON 
38e0			 
38e0			 
38e0					push hl 
38e0					 
38e0					 
38e0			 
38e0						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
38e0			 
38e0					; get next number 
38e0			 
38e0						FORTH_DSP_VALUE 
38e0			 
38e0						inc hl      ; now at start of numeric as string 
38e0			 
38e0					;ld ix, hl 
38e0					call CON 
38e0			 
38e0					push hl 
38e0			 
38e0			 
38e0						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e0			 
38e0						; TODO do add 
38e0			 
38e0						call IADD 
38e0			 
38e0						; TODO get result back as ascii 
38e0			 
38e0						; TODO push result  
38e0			 
38e0			 
38e0			 
38e0						jr .dot_done 
38e0				endif 
38e0			 
38e0			.dot_inum: 
38e0			 
38e0			 
38e0					if DEBUG_FORTH_DOT 
38e0						DMARK "+IT" 
38e0				CALLMONITOR 
38e0					endif 
38e0			 
38e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e0 cd e3 20			call macro_dsp_valuehl 
38e3				endm 
# End of macro FORTH_DSP_VALUEHL
38e3			 
38e3				; TODO add floating point number detection 
38e3			 
38e3 e5					push hl 
38e4			 
38e4					; destroy value TOS 
38e4			 
38e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e4 cd 9b 21			call macro_forth_dsp_pop 
38e7				endm 
# End of macro FORTH_DSP_POP
38e7			 
38e7			 
38e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e7 cd e3 20			call macro_dsp_valuehl 
38ea				endm 
# End of macro FORTH_DSP_VALUEHL
38ea			 
38ea					; one value on hl get other one back 
38ea			 
38ea d1					pop de 
38eb			 
38eb					; do the add 
38eb			 
38eb 19					add hl,de 
38ec			 
38ec					; save it 
38ec			 
38ec			;		push hl	 
38ec			 
38ec					; 
38ec			 
38ec					; destroy value TOS 
38ec			 
38ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ec cd 9b 21			call macro_forth_dsp_pop 
38ef				endm 
# End of macro FORTH_DSP_POP
38ef			 
38ef					; TODO push value back onto stack for another op etc 
38ef			 
38ef			;		pop hl 
38ef			 
38ef			.dot_done: 
38ef cd ec 1e				call forth_push_numhl 
38f2			 
38f2					NEXTW 
38f2 c3 5a 22			jp macro_next 
38f5				endm 
# End of macro NEXTW
38f5			.NEG: 
38f5			 
38f5				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
38f5 17				db WORD_SYS_CORE+3             
38f6 38 39			dw .DIV            
38f8 02				db 1 + 1 
38f9 .. 00			db "-",0              
38fb				endm 
# End of macro CWHEAD
38fb			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
38fb					if DEBUG_FORTH_WORDS_KEY 
38fb						DMARK "SUB" 
38fb f5				push af  
38fc 3a 10 39			ld a, (.dmark)  
38ff 32 b4 fe			ld (debug_mark),a  
3902 3a 11 39			ld a, (.dmark+1)  
3905 32 b5 fe			ld (debug_mark+1),a  
3908 3a 12 39			ld a, (.dmark+2)  
390b 32 b6 fe			ld (debug_mark+2),a  
390e 18 03			jr .pastdmark  
3910 ..			.dmark: db "SUB"  
3913 f1			.pastdmark: pop af  
3914			endm  
# End of macro DMARK
3914						CALLMONITOR 
3914 cd 78 18			call break_point_state  
3917				endm  
# End of macro CALLMONITOR
3917					endif 
3917			 
3917			 
3917				; TODO add floating point number detection 
3917					; v5 FORTH_DSP_VALUE 
3917					FORTH_DSP 
3917 cd a9 20			call macro_forth_dsp 
391a				endm 
# End of macro FORTH_DSP
391a 7e					ld a,(hl)	; get type of value on TOS 
391b fe 02				cp DS_TYPE_INUM  
391d 28 03				jr z, .neg_inum 
391f			 
391f					NEXTW 
391f c3 5a 22			jp macro_next 
3922				endm 
# End of macro NEXTW
3922			 
3922			; float maths 
3922			 
3922				if FORTH_ENABLE_FLOATMATH 
3922					jr .neg_done 
3922			 
3922				endif 
3922					 
3922			 
3922			.neg_inum: 
3922					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3922 cd e3 20			call macro_dsp_valuehl 
3925				endm 
# End of macro FORTH_DSP_VALUEHL
3925			 
3925 e5					push hl 
3926			 
3926					; destroy value TOS 
3926			 
3926					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3926 cd 9b 21			call macro_forth_dsp_pop 
3929				endm 
# End of macro FORTH_DSP_POP
3929			 
3929			 
3929					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3929 cd e3 20			call macro_dsp_valuehl 
392c				endm 
# End of macro FORTH_DSP_VALUEHL
392c			 
392c					; one value on hl get other one back 
392c			 
392c d1					pop de 
392d			 
392d					; do the sub 
392d			;		ex de, hl 
392d			 
392d ed 52				sbc hl,de 
392f			 
392f					; save it 
392f			 
392f			;		push hl	 
392f			 
392f					; 
392f			 
392f					; destroy value TOS 
392f			 
392f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392f cd 9b 21			call macro_forth_dsp_pop 
3932				endm 
# End of macro FORTH_DSP_POP
3932			 
3932					; TODO push value back onto stack for another op etc 
3932			 
3932			;		pop hl 
3932			 
3932 cd ec 1e				call forth_push_numhl 
3935			.neg_done: 
3935			 
3935					NEXTW 
3935 c3 5a 22			jp macro_next 
3938				endm 
# End of macro NEXTW
3938			.DIV: 
3938				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3938 18				db WORD_SYS_CORE+4             
3939 85 39			dw .MUL            
393b 02				db 1 + 1 
393c .. 00			db "/",0              
393e				endm 
# End of macro CWHEAD
393e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
393e					if DEBUG_FORTH_WORDS_KEY 
393e						DMARK "DIV" 
393e f5				push af  
393f 3a 53 39			ld a, (.dmark)  
3942 32 b4 fe			ld (debug_mark),a  
3945 3a 54 39			ld a, (.dmark+1)  
3948 32 b5 fe			ld (debug_mark+1),a  
394b 3a 55 39			ld a, (.dmark+2)  
394e 32 b6 fe			ld (debug_mark+2),a  
3951 18 03			jr .pastdmark  
3953 ..			.dmark: db "DIV"  
3956 f1			.pastdmark: pop af  
3957			endm  
# End of macro DMARK
3957						CALLMONITOR 
3957 cd 78 18			call break_point_state  
395a				endm  
# End of macro CALLMONITOR
395a					endif 
395a				; TODO add floating point number detection 
395a					; v5 FORTH_DSP_VALUE 
395a					FORTH_DSP 
395a cd a9 20			call macro_forth_dsp 
395d				endm 
# End of macro FORTH_DSP
395d 7e					ld a,(hl)	; get type of value on TOS 
395e fe 02				cp DS_TYPE_INUM  
3960 28 03				jr z, .div_inum 
3962			 
3962				if FORTH_ENABLE_FLOATMATH 
3962					jr .div_done 
3962			 
3962				endif 
3962					NEXTW 
3962 c3 5a 22			jp macro_next 
3965				endm 
# End of macro NEXTW
3965			.div_inum: 
3965			 
3965					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3965 cd e3 20			call macro_dsp_valuehl 
3968				endm 
# End of macro FORTH_DSP_VALUEHL
3968			 
3968 e5					push hl    ; to go to bc 
3969			 
3969					; destroy value TOS 
3969			 
3969					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3969 cd 9b 21			call macro_forth_dsp_pop 
396c				endm 
# End of macro FORTH_DSP_POP
396c			 
396c			 
396c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396c cd e3 20			call macro_dsp_valuehl 
396f				endm 
# End of macro FORTH_DSP_VALUEHL
396f			 
396f					; hl to go to de 
396f			 
396f e5					push hl 
3970			 
3970 c1					pop bc 
3971 d1					pop de		 
3972			 
3972			 
3972					if DEBUG_FORTH_MATHS 
3972						DMARK "DIV" 
3972				CALLMONITOR 
3972					endif 
3972					; one value on hl but move to a get other one back 
3972			 
3972			        
3972 cd 58 0e			call Div16 
3975			 
3975			;	push af	 
3975 e5				push hl 
3976 c5				push bc 
3977			 
3977					if DEBUG_FORTH_MATHS 
3977						DMARK "DI1" 
3977				CALLMONITOR 
3977					endif 
3977			 
3977					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3977 cd 9b 21			call macro_forth_dsp_pop 
397a				endm 
# End of macro FORTH_DSP_POP
397a			 
397a			 
397a			 
397a e1					pop hl    ; result 
397b			 
397b cd ec 1e				call forth_push_numhl 
397e			 
397e e1					pop hl    ; reminder 
397f			;		ld h,0 
397f			;		ld l,d 
397f			 
397f cd ec 1e				call forth_push_numhl 
3982			.div_done: 
3982					NEXTW 
3982 c3 5a 22			jp macro_next 
3985				endm 
# End of macro NEXTW
3985			.MUL: 
3985				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3985 19				db WORD_SYS_CORE+5             
3986 ca 39			dw .MIN            
3988 02				db 1 + 1 
3989 .. 00			db "*",0              
398b				endm 
# End of macro CWHEAD
398b			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
398b				; TODO add floating point number detection 
398b					if DEBUG_FORTH_WORDS_KEY 
398b						DMARK "MUL" 
398b f5				push af  
398c 3a a0 39			ld a, (.dmark)  
398f 32 b4 fe			ld (debug_mark),a  
3992 3a a1 39			ld a, (.dmark+1)  
3995 32 b5 fe			ld (debug_mark+1),a  
3998 3a a2 39			ld a, (.dmark+2)  
399b 32 b6 fe			ld (debug_mark+2),a  
399e 18 03			jr .pastdmark  
39a0 ..			.dmark: db "MUL"  
39a3 f1			.pastdmark: pop af  
39a4			endm  
# End of macro DMARK
39a4						CALLMONITOR 
39a4 cd 78 18			call break_point_state  
39a7				endm  
# End of macro CALLMONITOR
39a7					endif 
39a7					FORTH_DSP 
39a7 cd a9 20			call macro_forth_dsp 
39aa				endm 
# End of macro FORTH_DSP
39aa					; v5 FORTH_DSP_VALUE 
39aa 7e					ld a,(hl)	; get type of value on TOS 
39ab fe 02				cp DS_TYPE_INUM  
39ad 28 03				jr z, .mul_inum 
39af			 
39af				if FORTH_ENABLE_FLOATMATH 
39af					jr .mul_done 
39af			 
39af				endif 
39af			 
39af					NEXTW 
39af c3 5a 22			jp macro_next 
39b2				endm 
# End of macro NEXTW
39b2			.mul_inum:	 
39b2			 
39b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b2 cd e3 20			call macro_dsp_valuehl 
39b5				endm 
# End of macro FORTH_DSP_VALUEHL
39b5			 
39b5 e5					push hl 
39b6			 
39b6					; destroy value TOS 
39b6			 
39b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b6 cd 9b 21			call macro_forth_dsp_pop 
39b9				endm 
# End of macro FORTH_DSP_POP
39b9			 
39b9			 
39b9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b9 cd e3 20			call macro_dsp_valuehl 
39bc				endm 
# End of macro FORTH_DSP_VALUEHL
39bc			 
39bc					; one value on hl but move to a get other one back 
39bc			 
39bc 7d					ld a, l 
39bd			 
39bd d1					pop de 
39be			 
39be					; do the mull 
39be			;		ex de, hl 
39be			 
39be cd 7e 0e				call Mult16 
39c1					; save it 
39c1			 
39c1			;		push hl	 
39c1			 
39c1					; 
39c1			 
39c1					; destroy value TOS 
39c1			 
39c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c1 cd 9b 21			call macro_forth_dsp_pop 
39c4				endm 
# End of macro FORTH_DSP_POP
39c4			 
39c4					; TODO push value back onto stack for another op etc 
39c4			 
39c4			;		pop hl 
39c4			 
39c4 cd ec 1e				call forth_push_numhl 
39c7			 
39c7			.mul_done: 
39c7					NEXTW 
39c7 c3 5a 22			jp macro_next 
39ca				endm 
# End of macro NEXTW
39ca			 
39ca			 
39ca			 
39ca			 
39ca			.MIN: 
39ca				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
39ca 49				db WORD_SYS_CORE+53             
39cb 4b 3a			dw .MAX            
39cd 04				db 3 + 1 
39ce .. 00			db "MIN",0              
39d2				endm 
# End of macro CWHEAD
39d2			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
39d2					if DEBUG_FORTH_WORDS_KEY 
39d2						DMARK "MIN" 
39d2 f5				push af  
39d3 3a e7 39			ld a, (.dmark)  
39d6 32 b4 fe			ld (debug_mark),a  
39d9 3a e8 39			ld a, (.dmark+1)  
39dc 32 b5 fe			ld (debug_mark+1),a  
39df 3a e9 39			ld a, (.dmark+2)  
39e2 32 b6 fe			ld (debug_mark+2),a  
39e5 18 03			jr .pastdmark  
39e7 ..			.dmark: db "MIN"  
39ea f1			.pastdmark: pop af  
39eb			endm  
# End of macro DMARK
39eb						CALLMONITOR 
39eb cd 78 18			call break_point_state  
39ee				endm  
# End of macro CALLMONITOR
39ee					endif 
39ee					; get u2 
39ee			 
39ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ee cd e3 20			call macro_dsp_valuehl 
39f1				endm 
# End of macro FORTH_DSP_VALUEHL
39f1			 
39f1 e5					push hl   ; u2 
39f2			 
39f2					; destroy value TOS 
39f2			 
39f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f2 cd 9b 21			call macro_forth_dsp_pop 
39f5				endm 
# End of macro FORTH_DSP_POP
39f5			 
39f5					; get u1 
39f5			 
39f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f5 cd e3 20			call macro_dsp_valuehl 
39f8				endm 
# End of macro FORTH_DSP_VALUEHL
39f8			 
39f8 e5					push hl  ; u1 
39f9			 
39f9					; destroy value TOS 
39f9			 
39f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f9 cd 9b 21			call macro_forth_dsp_pop 
39fc				endm 
# End of macro FORTH_DSP_POP
39fc			 
39fc b7			 or a      ;clear carry flag 
39fd e1			  pop hl    ; u1 
39fe d1			  pop de    ; u2 
39ff e5				push hl   ; saved in case hl is lowest 
3a00 ed 52		  sbc hl,de 
3a02 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3a04			 
3a04 e1				pop hl 
3a05					if DEBUG_FORTH_WORDS 
3a05						DMARK "MIN" 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 b4 fe			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 b5 fe			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 b6 fe			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "MIN"  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd 78 18			call break_point_state  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21 cd ec 1e				call forth_push_numhl 
3a24			 
3a24				       NEXTW 
3a24 c3 5a 22			jp macro_next 
3a27				endm 
# End of macro NEXTW
3a27			 
3a27			.mincont:  
3a27 c1				pop bc   ; tidy up 
3a28 eb				ex de , hl  
3a29					if DEBUG_FORTH_WORDS 
3a29						DMARK "MI1" 
3a29 f5				push af  
3a2a 3a 3e 3a			ld a, (.dmark)  
3a2d 32 b4 fe			ld (debug_mark),a  
3a30 3a 3f 3a			ld a, (.dmark+1)  
3a33 32 b5 fe			ld (debug_mark+1),a  
3a36 3a 40 3a			ld a, (.dmark+2)  
3a39 32 b6 fe			ld (debug_mark+2),a  
3a3c 18 03			jr .pastdmark  
3a3e ..			.dmark: db "MI1"  
3a41 f1			.pastdmark: pop af  
3a42			endm  
# End of macro DMARK
3a42						CALLMONITOR 
3a42 cd 78 18			call break_point_state  
3a45				endm  
# End of macro CALLMONITOR
3a45					endif 
3a45 cd ec 1e				call forth_push_numhl 
3a48			 
3a48				       NEXTW 
3a48 c3 5a 22			jp macro_next 
3a4b				endm 
# End of macro NEXTW
3a4b			.MAX: 
3a4b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a4b 4a				db WORD_SYS_CORE+54             
3a4c cc 3a			dw .RND16            
3a4e 04				db 3 + 1 
3a4f .. 00			db "MAX",0              
3a53				endm 
# End of macro CWHEAD
3a53			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a53					if DEBUG_FORTH_WORDS_KEY 
3a53						DMARK "MAX" 
3a53 f5				push af  
3a54 3a 68 3a			ld a, (.dmark)  
3a57 32 b4 fe			ld (debug_mark),a  
3a5a 3a 69 3a			ld a, (.dmark+1)  
3a5d 32 b5 fe			ld (debug_mark+1),a  
3a60 3a 6a 3a			ld a, (.dmark+2)  
3a63 32 b6 fe			ld (debug_mark+2),a  
3a66 18 03			jr .pastdmark  
3a68 ..			.dmark: db "MAX"  
3a6b f1			.pastdmark: pop af  
3a6c			endm  
# End of macro DMARK
3a6c						CALLMONITOR 
3a6c cd 78 18			call break_point_state  
3a6f				endm  
# End of macro CALLMONITOR
3a6f					endif 
3a6f					; get u2 
3a6f			 
3a6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a6f cd e3 20			call macro_dsp_valuehl 
3a72				endm 
# End of macro FORTH_DSP_VALUEHL
3a72			 
3a72 e5					push hl   ; u2 
3a73			 
3a73					; destroy value TOS 
3a73			 
3a73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a73 cd 9b 21			call macro_forth_dsp_pop 
3a76				endm 
# End of macro FORTH_DSP_POP
3a76			 
3a76					; get u1 
3a76			 
3a76					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a76 cd e3 20			call macro_dsp_valuehl 
3a79				endm 
# End of macro FORTH_DSP_VALUEHL
3a79			 
3a79 e5					push hl  ; u1 
3a7a			 
3a7a					; destroy value TOS 
3a7a			 
3a7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a7a cd 9b 21			call macro_forth_dsp_pop 
3a7d				endm 
# End of macro FORTH_DSP_POP
3a7d			 
3a7d b7			 or a      ;clear carry flag 
3a7e e1			  pop hl    ; u1 
3a7f d1			  pop de    ; u2 
3a80 e5				push hl   ; saved in case hl is lowest 
3a81 ed 52		  sbc hl,de 
3a83 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3a85			 
3a85 e1				pop hl 
3a86					if DEBUG_FORTH_WORDS 
3a86						DMARK "MAX" 
3a86 f5				push af  
3a87 3a 9b 3a			ld a, (.dmark)  
3a8a 32 b4 fe			ld (debug_mark),a  
3a8d 3a 9c 3a			ld a, (.dmark+1)  
3a90 32 b5 fe			ld (debug_mark+1),a  
3a93 3a 9d 3a			ld a, (.dmark+2)  
3a96 32 b6 fe			ld (debug_mark+2),a  
3a99 18 03			jr .pastdmark  
3a9b ..			.dmark: db "MAX"  
3a9e f1			.pastdmark: pop af  
3a9f			endm  
# End of macro DMARK
3a9f						CALLMONITOR 
3a9f cd 78 18			call break_point_state  
3aa2				endm  
# End of macro CALLMONITOR
3aa2					endif 
3aa2 cd ec 1e				call forth_push_numhl 
3aa5			 
3aa5				       NEXTW 
3aa5 c3 5a 22			jp macro_next 
3aa8				endm 
# End of macro NEXTW
3aa8			 
3aa8			.maxcont:  
3aa8 c1				pop bc   ; tidy up 
3aa9 eb				ex de , hl  
3aaa					if DEBUG_FORTH_WORDS 
3aaa						DMARK "MA1" 
3aaa f5				push af  
3aab 3a bf 3a			ld a, (.dmark)  
3aae 32 b4 fe			ld (debug_mark),a  
3ab1 3a c0 3a			ld a, (.dmark+1)  
3ab4 32 b5 fe			ld (debug_mark+1),a  
3ab7 3a c1 3a			ld a, (.dmark+2)  
3aba 32 b6 fe			ld (debug_mark+2),a  
3abd 18 03			jr .pastdmark  
3abf ..			.dmark: db "MA1"  
3ac2 f1			.pastdmark: pop af  
3ac3			endm  
# End of macro DMARK
3ac3						CALLMONITOR 
3ac3 cd 78 18			call break_point_state  
3ac6				endm  
# End of macro CALLMONITOR
3ac6					endif 
3ac6 cd ec 1e				call forth_push_numhl 
3ac9				       NEXTW 
3ac9 c3 5a 22			jp macro_next 
3acc				endm 
# End of macro NEXTW
3acc			 
3acc			.RND16: 
3acc				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3acc 4e				db WORD_SYS_CORE+58             
3acd fb 3a			dw .RND8            
3acf 06				db 5 + 1 
3ad0 .. 00			db "RND16",0              
3ad6				endm 
# End of macro CWHEAD
3ad6			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3ad6					if DEBUG_FORTH_WORDS_KEY 
3ad6						DMARK "R16" 
3ad6 f5				push af  
3ad7 3a eb 3a			ld a, (.dmark)  
3ada 32 b4 fe			ld (debug_mark),a  
3add 3a ec 3a			ld a, (.dmark+1)  
3ae0 32 b5 fe			ld (debug_mark+1),a  
3ae3 3a ed 3a			ld a, (.dmark+2)  
3ae6 32 b6 fe			ld (debug_mark+2),a  
3ae9 18 03			jr .pastdmark  
3aeb ..			.dmark: db "R16"  
3aee f1			.pastdmark: pop af  
3aef			endm  
# End of macro DMARK
3aef						CALLMONITOR 
3aef cd 78 18			call break_point_state  
3af2				endm  
# End of macro CALLMONITOR
3af2					endif 
3af2 cd 22 0e				call prng16  
3af5 cd ec 1e				call forth_push_numhl 
3af8				       NEXTW 
3af8 c3 5a 22			jp macro_next 
3afb				endm 
# End of macro NEXTW
3afb			.RND8: 
3afb				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3afb 60				db WORD_SYS_CORE+76             
3afc 30 3b			dw .RND            
3afe 05				db 4 + 1 
3aff .. 00			db "RND8",0              
3b04				endm 
# End of macro CWHEAD
3b04			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3b04					if DEBUG_FORTH_WORDS_KEY 
3b04						DMARK "RN8" 
3b04 f5				push af  
3b05 3a 19 3b			ld a, (.dmark)  
3b08 32 b4 fe			ld (debug_mark),a  
3b0b 3a 1a 3b			ld a, (.dmark+1)  
3b0e 32 b5 fe			ld (debug_mark+1),a  
3b11 3a 1b 3b			ld a, (.dmark+2)  
3b14 32 b6 fe			ld (debug_mark+2),a  
3b17 18 03			jr .pastdmark  
3b19 ..			.dmark: db "RN8"  
3b1c f1			.pastdmark: pop af  
3b1d			endm  
# End of macro DMARK
3b1d						CALLMONITOR 
3b1d cd 78 18			call break_point_state  
3b20				endm  
# End of macro CALLMONITOR
3b20					endif 
3b20 2a 35 fd				ld hl,(xrandc) 
3b23 23					inc hl 
3b24 cd 3c 0e				call xrnd 
3b27 6f					ld l,a	 
3b28 26 00				ld h,0 
3b2a cd ec 1e				call forth_push_numhl 
3b2d				       NEXTW 
3b2d c3 5a 22			jp macro_next 
3b30				endm 
# End of macro NEXTW
3b30			.RND: 
3b30				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3b30 60				db WORD_SYS_CORE+76             
3b31 36 3c			dw .ENDMATHS            
3b33 04				db 3 + 1 
3b34 .. 00			db "RND",0              
3b38				endm 
# End of macro CWHEAD
3b38			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b38			 
3b38					if DEBUG_FORTH_WORDS_KEY 
3b38						DMARK "RND" 
3b38 f5				push af  
3b39 3a 4d 3b			ld a, (.dmark)  
3b3c 32 b4 fe			ld (debug_mark),a  
3b3f 3a 4e 3b			ld a, (.dmark+1)  
3b42 32 b5 fe			ld (debug_mark+1),a  
3b45 3a 4f 3b			ld a, (.dmark+2)  
3b48 32 b6 fe			ld (debug_mark+2),a  
3b4b 18 03			jr .pastdmark  
3b4d ..			.dmark: db "RND"  
3b50 f1			.pastdmark: pop af  
3b51			endm  
# End of macro DMARK
3b51						CALLMONITOR 
3b51 cd 78 18			call break_point_state  
3b54				endm  
# End of macro CALLMONITOR
3b54					endif 
3b54					 
3b54					FORTH_DSP_VALUEHL    ; upper range 
3b54 cd e3 20			call macro_dsp_valuehl 
3b57				endm 
# End of macro FORTH_DSP_VALUEHL
3b57			 
3b57 22 39 fd				ld (LFSRSeed), hl	 
3b5a			 
3b5a					if DEBUG_FORTH_WORDS 
3b5a						DMARK "RN1" 
3b5a f5				push af  
3b5b 3a 6f 3b			ld a, (.dmark)  
3b5e 32 b4 fe			ld (debug_mark),a  
3b61 3a 70 3b			ld a, (.dmark+1)  
3b64 32 b5 fe			ld (debug_mark+1),a  
3b67 3a 71 3b			ld a, (.dmark+2)  
3b6a 32 b6 fe			ld (debug_mark+2),a  
3b6d 18 03			jr .pastdmark  
3b6f ..			.dmark: db "RN1"  
3b72 f1			.pastdmark: pop af  
3b73			endm  
# End of macro DMARK
3b73						CALLMONITOR 
3b73 cd 78 18			call break_point_state  
3b76				endm  
# End of macro CALLMONITOR
3b76					endif 
3b76					FORTH_DSP_POP 
3b76 cd 9b 21			call macro_forth_dsp_pop 
3b79				endm 
# End of macro FORTH_DSP_POP
3b79			 
3b79					FORTH_DSP_VALUEHL    ; low range 
3b79 cd e3 20			call macro_dsp_valuehl 
3b7c				endm 
# End of macro FORTH_DSP_VALUEHL
3b7c			 
3b7c					if DEBUG_FORTH_WORDS 
3b7c						DMARK "RN2" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 b4 fe			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 b5 fe			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 b6 fe			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "RN2"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						CALLMONITOR 
3b95 cd 78 18			call break_point_state  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98 22 3b fd				ld (LFSRSeed+2), hl 
3b9b			 
3b9b					FORTH_DSP_POP 
3b9b cd 9b 21			call macro_forth_dsp_pop 
3b9e				endm 
# End of macro FORTH_DSP_POP
3b9e			 
3b9e e5					push hl 
3b9f			 
3b9f e1			.inrange:	pop hl 
3ba0 cd 22 0e				call prng16  
3ba3					if DEBUG_FORTH_WORDS 
3ba3						DMARK "RN3" 
3ba3 f5				push af  
3ba4 3a b8 3b			ld a, (.dmark)  
3ba7 32 b4 fe			ld (debug_mark),a  
3baa 3a b9 3b			ld a, (.dmark+1)  
3bad 32 b5 fe			ld (debug_mark+1),a  
3bb0 3a ba 3b			ld a, (.dmark+2)  
3bb3 32 b6 fe			ld (debug_mark+2),a  
3bb6 18 03			jr .pastdmark  
3bb8 ..			.dmark: db "RN3"  
3bbb f1			.pastdmark: pop af  
3bbc			endm  
# End of macro DMARK
3bbc						CALLMONITOR 
3bbc cd 78 18			call break_point_state  
3bbf				endm  
# End of macro CALLMONITOR
3bbf					endif 
3bbf					 
3bbf					; if the range is 8bit knock out the high byte 
3bbf			 
3bbf ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3bc3			 
3bc3 3e 00				ld a, 0 
3bc5 ba					cp d  
3bc6 20 1e				jr nz, .hirange 
3bc8 26 00				ld h, 0   ; knock it down to 8bit 
3bca			 
3bca					if DEBUG_FORTH_WORDS 
3bca						DMARK "RNk" 
3bca f5				push af  
3bcb 3a df 3b			ld a, (.dmark)  
3bce 32 b4 fe			ld (debug_mark),a  
3bd1 3a e0 3b			ld a, (.dmark+1)  
3bd4 32 b5 fe			ld (debug_mark+1),a  
3bd7 3a e1 3b			ld a, (.dmark+2)  
3bda 32 b6 fe			ld (debug_mark+2),a  
3bdd 18 03			jr .pastdmark  
3bdf ..			.dmark: db "RNk"  
3be2 f1			.pastdmark: pop af  
3be3			endm  
# End of macro DMARK
3be3						CALLMONITOR 
3be3 cd 78 18			call break_point_state  
3be6				endm  
# End of macro CALLMONITOR
3be6					endif 
3be6			.hirange:   
3be6 e5					push hl  
3be7 b7					or a  
3be8 ed 52		                sbc hl, de 
3bea			 
3bea					;call cmp16 
3bea			 
3bea 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3bec e1					pop hl 
3bed e5					push hl 
3bee			 
3bee					if DEBUG_FORTH_WORDS 
3bee						DMARK "RN4" 
3bee f5				push af  
3bef 3a 03 3c			ld a, (.dmark)  
3bf2 32 b4 fe			ld (debug_mark),a  
3bf5 3a 04 3c			ld a, (.dmark+1)  
3bf8 32 b5 fe			ld (debug_mark+1),a  
3bfb 3a 05 3c			ld a, (.dmark+2)  
3bfe 32 b6 fe			ld (debug_mark+2),a  
3c01 18 03			jr .pastdmark  
3c03 ..			.dmark: db "RN4"  
3c06 f1			.pastdmark: pop af  
3c07			endm  
# End of macro DMARK
3c07						CALLMONITOR 
3c07 cd 78 18			call break_point_state  
3c0a				endm  
# End of macro CALLMONITOR
3c0a					endif 
3c0a ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3c0e					;call cmp16 
3c0e				 
3c0e b7					or a  
3c0f ed 52		                sbc hl, de 
3c11 38 8c				jr c, .inrange 
3c13			 
3c13 e1					pop hl 
3c14					 
3c14					if DEBUG_FORTH_WORDS 
3c14						DMARK "RNd" 
3c14 f5				push af  
3c15 3a 29 3c			ld a, (.dmark)  
3c18 32 b4 fe			ld (debug_mark),a  
3c1b 3a 2a 3c			ld a, (.dmark+1)  
3c1e 32 b5 fe			ld (debug_mark+1),a  
3c21 3a 2b 3c			ld a, (.dmark+2)  
3c24 32 b6 fe			ld (debug_mark+2),a  
3c27 18 03			jr .pastdmark  
3c29 ..			.dmark: db "RNd"  
3c2c f1			.pastdmark: pop af  
3c2d			endm  
# End of macro DMARK
3c2d						CALLMONITOR 
3c2d cd 78 18			call break_point_state  
3c30				endm  
# End of macro CALLMONITOR
3c30					endif 
3c30			 
3c30			 
3c30 cd ec 1e				call forth_push_numhl 
3c33				       NEXTW 
3c33 c3 5a 22			jp macro_next 
3c36				endm 
# End of macro NEXTW
3c36			 
3c36			.ENDMATHS: 
3c36			 
3c36			; eof 
3c36			 
# End of file forth_words_maths.asm
3c36			include "forth_words_display.asm" 
3c36			 
3c36			; | ## Display Words 
3c36			 
3c36			.INFO: 
3c36			 
3c36				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c36 62				db WORD_SYS_CORE+78             
3c37 53 3c			dw .ATP            
3c39 05				db 4 + 1 
3c3a .. 00			db "INFO",0              
3c3f				endm 
# End of macro CWHEAD
3c3f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c3f					FORTH_DSP_VALUEHL 
3c3f cd e3 20			call macro_dsp_valuehl 
3c42				endm 
# End of macro FORTH_DSP_VALUEHL
3c42			 
3c42					FORTH_DSP_POP 
3c42 cd 9b 21			call macro_forth_dsp_pop 
3c45				endm 
# End of macro FORTH_DSP_POP
3c45			 
3c45 e5					push hl 
3c46			 
3c46					FORTH_DSP_VALUEHL 
3c46 cd e3 20			call macro_dsp_valuehl 
3c49				endm 
# End of macro FORTH_DSP_VALUEHL
3c49			 
3c49					FORTH_DSP_POP 
3c49 cd 9b 21			call macro_forth_dsp_pop 
3c4c				endm 
# End of macro FORTH_DSP_POP
3c4c			 
3c4c d1					pop de 
3c4d			 
3c4d cd 58 0c				call info_panel 
3c50			 
3c50			 
3c50					NEXTW 
3c50 c3 5a 22			jp macro_next 
3c53				endm 
# End of macro NEXTW
3c53			.ATP: 
3c53				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c53 62				db WORD_SYS_CORE+78             
3c54 ca 3c			dw .FB            
3c56 04				db 3 + 1 
3c57 .. 00			db "AT?",0              
3c5b				endm 
# End of macro CWHEAD
3c5b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c5b					if DEBUG_FORTH_WORDS_KEY 
3c5b						DMARK "AT?" 
3c5b f5				push af  
3c5c 3a 70 3c			ld a, (.dmark)  
3c5f 32 b4 fe			ld (debug_mark),a  
3c62 3a 71 3c			ld a, (.dmark+1)  
3c65 32 b5 fe			ld (debug_mark+1),a  
3c68 3a 72 3c			ld a, (.dmark+2)  
3c6b 32 b6 fe			ld (debug_mark+2),a  
3c6e 18 03			jr .pastdmark  
3c70 ..			.dmark: db "AT?"  
3c73 f1			.pastdmark: pop af  
3c74			endm  
# End of macro DMARK
3c74						CALLMONITOR 
3c74 cd 78 18			call break_point_state  
3c77				endm  
# End of macro CALLMONITOR
3c77					endif 
3c77 3a ee fb				ld a, (f_cursor_ptr) 
3c7a			 
3c7a			if DEBUG_FORTH_WORDS 
3c7a				DMARK "AT?" 
3c7a f5				push af  
3c7b 3a 8f 3c			ld a, (.dmark)  
3c7e 32 b4 fe			ld (debug_mark),a  
3c81 3a 90 3c			ld a, (.dmark+1)  
3c84 32 b5 fe			ld (debug_mark+1),a  
3c87 3a 91 3c			ld a, (.dmark+2)  
3c8a 32 b6 fe			ld (debug_mark+2),a  
3c8d 18 03			jr .pastdmark  
3c8f ..			.dmark: db "AT?"  
3c92 f1			.pastdmark: pop af  
3c93			endm  
# End of macro DMARK
3c93				CALLMONITOR 
3c93 cd 78 18			call break_point_state  
3c96				endm  
# End of macro CALLMONITOR
3c96			endif	 
3c96					; count the number of rows 
3c96			 
3c96 06 00				ld b, 0 
3c98 4f			.atpr:		ld c, a    ; save in case we go below zero 
3c99 d6 14				sub display_cols 
3c9b f2 a1 3c				jp p, .atprunder 
3c9e 04					inc b 
3c9f 18 f7				jr .atpr 
3ca1			.atprunder:	 
3ca1			if DEBUG_FORTH_WORDS 
3ca1				DMARK "A?2" 
3ca1 f5				push af  
3ca2 3a b6 3c			ld a, (.dmark)  
3ca5 32 b4 fe			ld (debug_mark),a  
3ca8 3a b7 3c			ld a, (.dmark+1)  
3cab 32 b5 fe			ld (debug_mark+1),a  
3cae 3a b8 3c			ld a, (.dmark+2)  
3cb1 32 b6 fe			ld (debug_mark+2),a  
3cb4 18 03			jr .pastdmark  
3cb6 ..			.dmark: db "A?2"  
3cb9 f1			.pastdmark: pop af  
3cba			endm  
# End of macro DMARK
3cba				CALLMONITOR 
3cba cd 78 18			call break_point_state  
3cbd				endm  
# End of macro CALLMONITOR
3cbd			endif	 
3cbd 26 00				ld h, 0 
3cbf 69					ld l, c 
3cc0 cd ec 1e				call forth_push_numhl 
3cc3 68					ld l, b  
3cc4 cd ec 1e				call forth_push_numhl 
3cc7			 
3cc7			 
3cc7				NEXTW 
3cc7 c3 5a 22			jp macro_next 
3cca				endm 
# End of macro NEXTW
3cca			 
3cca			.FB: 
3cca				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3cca 1b				db WORD_SYS_CORE+7             
3ccb 18 3d			dw .EMIT            
3ccd 03				db 2 + 1 
3cce .. 00			db "FB",0              
3cd1				endm 
# End of macro CWHEAD
3cd1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3cd1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3cd1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3cd1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3cd1					if DEBUG_FORTH_WORDS_KEY 
3cd1						DMARK "FB." 
3cd1 f5				push af  
3cd2 3a e6 3c			ld a, (.dmark)  
3cd5 32 b4 fe			ld (debug_mark),a  
3cd8 3a e7 3c			ld a, (.dmark+1)  
3cdb 32 b5 fe			ld (debug_mark+1),a  
3cde 3a e8 3c			ld a, (.dmark+2)  
3ce1 32 b6 fe			ld (debug_mark+2),a  
3ce4 18 03			jr .pastdmark  
3ce6 ..			.dmark: db "FB."  
3ce9 f1			.pastdmark: pop af  
3cea			endm  
# End of macro DMARK
3cea						CALLMONITOR 
3cea cd 78 18			call break_point_state  
3ced				endm  
# End of macro CALLMONITOR
3ced					endif 
3ced			 
3ced					FORTH_DSP_VALUEHL 
3ced cd e3 20			call macro_dsp_valuehl 
3cf0				endm 
# End of macro FORTH_DSP_VALUEHL
3cf0			 
3cf0 7d					ld a, l 
3cf1 fe 01				cp 1 
3cf3 20 05				jr nz, .fbn1 
3cf5 21 f9 fd				ld hl, display_fb1 
3cf8 18 15				jr .fbset 
3cfa fe 02		.fbn1:		cp 2 
3cfc 20 05				jr nz, .fbn2 
3cfe 21 57 fd				ld hl, display_fb2 
3d01 18 0c				jr .fbset 
3d03 fe 03		.fbn2:		cp 3 
3d05 20 05				jr nz, .fbn3 
3d07 21 a8 fd				ld hl, display_fb3 
3d0a 18 03				jr .fbset 
3d0c			.fbn3:		 ; if invalid number select first 
3d0c 21 f9 fd				ld hl, display_fb1 
3d0f 22 55 fd		.fbset:		ld (display_fb_active), hl 
3d12			 
3d12					FORTH_DSP_POP 
3d12 cd 9b 21			call macro_forth_dsp_pop 
3d15				endm 
# End of macro FORTH_DSP_POP
3d15			 
3d15					NEXTW 
3d15 c3 5a 22			jp macro_next 
3d18				endm 
# End of macro NEXTW
3d18			 
3d18			 
3d18			.EMIT: 
3d18				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d18 1b				db WORD_SYS_CORE+7             
3d19 69 3d			dw .DOTH            
3d1b 05				db 4 + 1 
3d1c .. 00			db "EMIT",0              
3d21				endm 
# End of macro CWHEAD
3d21			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d21					; get value off TOS and display it 
3d21			 
3d21					if DEBUG_FORTH_WORDS_KEY 
3d21						DMARK "EMT" 
3d21 f5				push af  
3d22 3a 36 3d			ld a, (.dmark)  
3d25 32 b4 fe			ld (debug_mark),a  
3d28 3a 37 3d			ld a, (.dmark+1)  
3d2b 32 b5 fe			ld (debug_mark+1),a  
3d2e 3a 38 3d			ld a, (.dmark+2)  
3d31 32 b6 fe			ld (debug_mark+2),a  
3d34 18 03			jr .pastdmark  
3d36 ..			.dmark: db "EMT"  
3d39 f1			.pastdmark: pop af  
3d3a			endm  
# End of macro DMARK
3d3a						CALLMONITOR 
3d3a cd 78 18			call break_point_state  
3d3d				endm  
# End of macro CALLMONITOR
3d3d					endif 
3d3d			 
3d3d					FORTH_DSP_VALUEHL 
3d3d cd e3 20			call macro_dsp_valuehl 
3d40				endm 
# End of macro FORTH_DSP_VALUEHL
3d40			 
3d40 7d					ld a,l 
3d41			 
3d41					; TODO write to display 
3d41			 
3d41 32 83 f5				ld (os_input), a 
3d44 3e 00				ld a, 0 
3d46 32 84 f5				ld (os_input+1), a 
3d49					 
3d49 3a ee fb				ld a, (f_cursor_ptr) 
3d4c 11 83 f5				ld de, os_input 
3d4f cd da 0c				call str_at_display 
3d52			 
3d52			 
3d52 3a cc fb				ld a,(cli_autodisplay) 
3d55 fe 00				cp 0 
3d57 28 03				jr z, .enoupdate 
3d59 cd ea 0c						call update_display 
3d5c					.enoupdate: 
3d5c			 
3d5c 3a ee fb				ld a, (f_cursor_ptr) 
3d5f 3c					inc a 
3d60 32 ee fb				ld (f_cursor_ptr), a   ; save new pos 
3d63			 
3d63			 
3d63					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d63 cd 9b 21			call macro_forth_dsp_pop 
3d66				endm 
# End of macro FORTH_DSP_POP
3d66			  
3d66			 
3d66					NEXTW 
3d66 c3 5a 22			jp macro_next 
3d69				endm 
# End of macro NEXTW
3d69			.DOTH: 
3d69				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d69 1c				db WORD_SYS_CORE+8             
3d6a 99 3d			dw .DOTF            
3d6c 03				db 2 + 1 
3d6d .. 00			db ".-",0              
3d70				endm 
# End of macro CWHEAD
3d70			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3d70					; get value off TOS and display it 
3d70					if DEBUG_FORTH_WORDS_KEY 
3d70						DMARK "DTD" 
3d70 f5				push af  
3d71 3a 85 3d			ld a, (.dmark)  
3d74 32 b4 fe			ld (debug_mark),a  
3d77 3a 86 3d			ld a, (.dmark+1)  
3d7a 32 b5 fe			ld (debug_mark+1),a  
3d7d 3a 87 3d			ld a, (.dmark+2)  
3d80 32 b6 fe			ld (debug_mark+2),a  
3d83 18 03			jr .pastdmark  
3d85 ..			.dmark: db "DTD"  
3d88 f1			.pastdmark: pop af  
3d89			endm  
# End of macro DMARK
3d89						CALLMONITOR 
3d89 cd 78 18			call break_point_state  
3d8c				endm  
# End of macro CALLMONITOR
3d8c					endif 
3d8c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3d8e 3e 00			ld a, 0 
3d90 32 cd fb			ld (cli_mvdot), a 
3d93 c3 f0 3d			jp .dotgo 
3d96				NEXTW 
3d96 c3 5a 22			jp macro_next 
3d99				endm 
# End of macro NEXTW
3d99			.DOTF: 
3d99				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3d99 1c				db WORD_SYS_CORE+8             
3d9a c7 3d			dw .DOT            
3d9c 03				db 2 + 1 
3d9d .. 00			db ".>",0              
3da0				endm 
# End of macro CWHEAD
3da0			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3da0					; get value off TOS and display it 
3da0			        ; TODO BUG adds extra spaces 
3da0			        ; TODO BUG handle numerics? 
3da0					if DEBUG_FORTH_WORDS_KEY 
3da0						DMARK "DTC" 
3da0 f5				push af  
3da1 3a b5 3d			ld a, (.dmark)  
3da4 32 b4 fe			ld (debug_mark),a  
3da7 3a b6 3d			ld a, (.dmark+1)  
3daa 32 b5 fe			ld (debug_mark+1),a  
3dad 3a b7 3d			ld a, (.dmark+2)  
3db0 32 b6 fe			ld (debug_mark+2),a  
3db3 18 03			jr .pastdmark  
3db5 ..			.dmark: db "DTC"  
3db8 f1			.pastdmark: pop af  
3db9			endm  
# End of macro DMARK
3db9						CALLMONITOR 
3db9 cd 78 18			call break_point_state  
3dbc				endm  
# End of macro CALLMONITOR
3dbc					endif 
3dbc 3e 01			ld a, 1 
3dbe 32 cd fb			ld (cli_mvdot), a 
3dc1 c3 f0 3d			jp .dotgo 
3dc4				NEXTW 
3dc4 c3 5a 22			jp macro_next 
3dc7				endm 
# End of macro NEXTW
3dc7			 
3dc7			.DOT: 
3dc7				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3dc7 1c				db WORD_SYS_CORE+8             
3dc8 53 3e			dw .CLS            
3dca 02				db 1 + 1 
3dcb .. 00			db ".",0              
3dcd				endm 
# End of macro CWHEAD
3dcd			        ; | . ( u -- ) Display TOS | DONE 
3dcd					; get value off TOS and display it 
3dcd			 
3dcd					if DEBUG_FORTH_WORDS_KEY 
3dcd						DMARK "DOT" 
3dcd f5				push af  
3dce 3a e2 3d			ld a, (.dmark)  
3dd1 32 b4 fe			ld (debug_mark),a  
3dd4 3a e3 3d			ld a, (.dmark+1)  
3dd7 32 b5 fe			ld (debug_mark+1),a  
3dda 3a e4 3d			ld a, (.dmark+2)  
3ddd 32 b6 fe			ld (debug_mark+2),a  
3de0 18 03			jr .pastdmark  
3de2 ..			.dmark: db "DOT"  
3de5 f1			.pastdmark: pop af  
3de6			endm  
# End of macro DMARK
3de6						CALLMONITOR 
3de6 cd 78 18			call break_point_state  
3de9				endm  
# End of macro CALLMONITOR
3de9					endif 
3de9 3e 00			ld a, 0 
3deb 32 cd fb			ld (cli_mvdot), a 
3dee 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3df0				 
3df0			 
3df0			.dotgo: 
3df0			 
3df0			; move up type to on stack for parserv5 
3df0					FORTH_DSP 
3df0 cd a9 20			call macro_forth_dsp 
3df3				endm 
# End of macro FORTH_DSP
3df3				;FORTH_DSP_VALUE  
3df3			 
3df3			if DEBUG_FORTH_DOT 
3df3				DMARK "DOT" 
3df3				CALLMONITOR 
3df3			endif	 
3df3			;		.print: 
3df3			 
3df3 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3df4 23				inc hl   ; position to the actual value 
3df5 fe 01			cp DS_TYPE_STR 
3df7 20 06			jr nz, .dotnum1  
3df9			 
3df9			; display string 
3df9				FORTH_DSP_VALUE  
3df9 cd cc 20			call macro_forth_dsp_value 
3dfc				endm 
# End of macro FORTH_DSP_VALUE
3dfc eb				ex de,hl 
3dfd 18 11			jr .dotwrite 
3dff			 
3dff			.dotnum1: 
3dff fe 02			cp DS_TYPE_INUM 
3e01 20 0c			jr nz, .dotflot 
3e03			 
3e03			 
3e03			; display number 
3e03			 
3e03			;	push hl 
3e03			;	call clear_display 
3e03			;	pop hl 
3e03			 
3e03 5e				ld e, (hl) 
3e04 23				inc hl 
3e05 56				ld d, (hl) 
3e06 21 85 f3			ld hl, scratch 
3e09			if DEBUG_FORTH_DOT 
3e09				DMARK "DT1" 
3e09				CALLMONITOR 
3e09			endif	 
3e09			 
3e09 cd 08 13			call uitoa_16 
3e0c eb				ex de,hl 
3e0d			 
3e0d			if DEBUG_FORTH_DOT 
3e0d				DMARK "DT2" 
3e0d				CALLMONITOR 
3e0d			endif	 
3e0d			 
3e0d			;	ld de, os_word_scratch 
3e0d 18 01			jr .dotwrite 
3e0f			 
3e0f 00			.dotflot:   nop 
3e10			; TODO print floating point number 
3e10			 
3e10			.dotwrite:		 
3e10			 
3e10					; if c is set then set all '-' to spaces 
3e10					; need to also take into account .>  
3e10			 
3e10 3e 01				ld a, 1 
3e12 b9					cp c 
3e13 20 13				jr nz, .nodashswap 
3e15			 
3e15					; DE has the string to write, working with HL 
3e15			 
3e15 06 ff				ld b, 255 
3e17 d5					push de 
3e18 e1					pop hl 
3e19			 
3e19			if DEBUG_FORTH_DOT 
3e19				DMARK "DT-" 
3e19				CALLMONITOR 
3e19			endif	 
3e19 7e			.dashscan:	ld a, (hl) 
3e1a fe 00				cp 0 
3e1c 28 0a				jr z, .nodashswap 
3e1e fe 2d				cp '-' 
3e20 20 03				jr nz, .dashskip 
3e22 3e 20				ld a, ' ' 
3e24 77					ld (hl), a 
3e25 23			.dashskip:	inc hl 
3e26			if DEBUG_FORTH_DOT 
3e26				DMARK "D-2" 
3e26				CALLMONITOR 
3e26			endif	 
3e26 10 f1				djnz .dashscan 
3e28			 
3e28			if DEBUG_FORTH_DOT 
3e28				DMARK "D-1" 
3e28				CALLMONITOR 
3e28			endif	 
3e28			 
3e28			.nodashswap: 
3e28			 
3e28 e5					push hl   ; save string start in case we need to advance print 
3e29			 
3e29 3a ee fb				ld a, (f_cursor_ptr) 
3e2c cd da 0c				call str_at_display 
3e2f 3a cc fb				ld a,(cli_autodisplay) 
3e32 fe 00				cp 0 
3e34 28 03				jr z, .noupdate 
3e36 cd ea 0c						call update_display 
3e39					.noupdate: 
3e39			 
3e39			 
3e39					; see if we need to advance the print position 
3e39			 
3e39 e1					pop hl   ; get back string 
3e3a			 
3e3a 3a cd fb				ld a, (cli_mvdot) 
3e3d			if DEBUG_FORTH_DOT 
3e3d					ld e,a 
3e3d				DMARK "D>1" 
3e3d				CALLMONITOR 
3e3d			endif	 
3e3d fe 00				cp 0 
3e3f 28 0c				jr z, .noadv 
3e41					; yes, lets advance the print position 
3e41 3e 00				ld a, 0 
3e43 cd 64 13				call strlent 
3e46 3a ee fb				ld a, (f_cursor_ptr) 
3e49 85					add a,l 
3e4a					;call addatohl 
3e4a					;ld a, l 
3e4a 32 ee fb				ld (f_cursor_ptr), a   ; save new pos 
3e4d			 
3e4d			if DEBUG_FORTH_DOT 
3e4d				DMARK "D->" 
3e4d				CALLMONITOR 
3e4d			endif	 
3e4d			 
3e4d			.noadv:	 
3e4d			 
3e4d					if DEBUG_FORTH_DOT_WAIT 
3e4d							call next_page_prompt 
3e4d					endif	 
3e4d			; TODO this pop off the stack causes a crash. i dont know why 
3e4d			 
3e4d			 
3e4d			if DEBUG_FORTH_DOT 
3e4d				DMARK "DTh" 
3e4d				CALLMONITOR 
3e4d			endif	 
3e4d			 
3e4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e4d cd 9b 21			call macro_forth_dsp_pop 
3e50				endm 
# End of macro FORTH_DSP_POP
3e50			 
3e50			if DEBUG_FORTH_DOT 
3e50				DMARK "DTi" 
3e50				CALLMONITOR 
3e50			endif	 
3e50			 
3e50			 
3e50					NEXTW 
3e50 c3 5a 22			jp macro_next 
3e53				endm 
# End of macro NEXTW
3e53			 
3e53			.CLS: 
3e53				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e53 35				db WORD_SYS_CORE+33             
3e54 80 3e			dw .DRAW            
3e56 04				db 3 + 1 
3e57 .. 00			db "CLS",0              
3e5b				endm 
# End of macro CWHEAD
3e5b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e5b					if DEBUG_FORTH_WORDS_KEY 
3e5b						DMARK "CLS" 
3e5b f5				push af  
3e5c 3a 70 3e			ld a, (.dmark)  
3e5f 32 b4 fe			ld (debug_mark),a  
3e62 3a 71 3e			ld a, (.dmark+1)  
3e65 32 b5 fe			ld (debug_mark+1),a  
3e68 3a 72 3e			ld a, (.dmark+2)  
3e6b 32 b6 fe			ld (debug_mark+2),a  
3e6e 18 03			jr .pastdmark  
3e70 ..			.dmark: db "CLS"  
3e73 f1			.pastdmark: pop af  
3e74			endm  
# End of macro DMARK
3e74						CALLMONITOR 
3e74 cd 78 18			call break_point_state  
3e77				endm  
# End of macro CALLMONITOR
3e77					endif 
3e77 cd c7 0c				call clear_display 
3e7a c3 8e 3f				jp .home		; and home cursor 
3e7d					NEXTW 
3e7d c3 5a 22			jp macro_next 
3e80				endm 
# End of macro NEXTW
3e80			 
3e80			.DRAW: 
3e80				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e80 36				db WORD_SYS_CORE+34             
3e81 ab 3e			dw .DUMP            
3e83 05				db 4 + 1 
3e84 .. 00			db "DRAW",0              
3e89				endm 
# End of macro CWHEAD
3e89			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e89					if DEBUG_FORTH_WORDS_KEY 
3e89						DMARK "DRW" 
3e89 f5				push af  
3e8a 3a 9e 3e			ld a, (.dmark)  
3e8d 32 b4 fe			ld (debug_mark),a  
3e90 3a 9f 3e			ld a, (.dmark+1)  
3e93 32 b5 fe			ld (debug_mark+1),a  
3e96 3a a0 3e			ld a, (.dmark+2)  
3e99 32 b6 fe			ld (debug_mark+2),a  
3e9c 18 03			jr .pastdmark  
3e9e ..			.dmark: db "DRW"  
3ea1 f1			.pastdmark: pop af  
3ea2			endm  
# End of macro DMARK
3ea2						CALLMONITOR 
3ea2 cd 78 18			call break_point_state  
3ea5				endm  
# End of macro CALLMONITOR
3ea5					endif 
3ea5 cd ea 0c				call update_display 
3ea8					NEXTW 
3ea8 c3 5a 22			jp macro_next 
3eab				endm 
# End of macro NEXTW
3eab			 
3eab			.DUMP: 
3eab				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3eab 37				db WORD_SYS_CORE+35             
3eac e3 3e			dw .CDUMP            
3eae 05				db 4 + 1 
3eaf .. 00			db "DUMP",0              
3eb4				endm 
# End of macro CWHEAD
3eb4			; | DUMP ( x -- ) With address x display dump   | DONE 
3eb4			; TODO pop address to use off of the stack 
3eb4					if DEBUG_FORTH_WORDS_KEY 
3eb4						DMARK "DUM" 
3eb4 f5				push af  
3eb5 3a c9 3e			ld a, (.dmark)  
3eb8 32 b4 fe			ld (debug_mark),a  
3ebb 3a ca 3e			ld a, (.dmark+1)  
3ebe 32 b5 fe			ld (debug_mark+1),a  
3ec1 3a cb 3e			ld a, (.dmark+2)  
3ec4 32 b6 fe			ld (debug_mark+2),a  
3ec7 18 03			jr .pastdmark  
3ec9 ..			.dmark: db "DUM"  
3ecc f1			.pastdmark: pop af  
3ecd			endm  
# End of macro DMARK
3ecd						CALLMONITOR 
3ecd cd 78 18			call break_point_state  
3ed0				endm  
# End of macro CALLMONITOR
3ed0					endif 
3ed0 cd c7 0c				call clear_display 
3ed3			 
3ed3					; get address 
3ed3			 
3ed3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed3 cd e3 20			call macro_dsp_valuehl 
3ed6				endm 
# End of macro FORTH_DSP_VALUEHL
3ed6				 
3ed6					; save it for cdump 
3ed6			 
3ed6 22 a8 f6				ld (os_cur_ptr),hl 
3ed9			 
3ed9					; destroy value TOS 
3ed9			 
3ed9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed9 cd 9b 21			call macro_forth_dsp_pop 
3edc				endm 
# End of macro FORTH_DSP_POP
3edc			 
3edc cd 6c 1d				call dumpcont	; skip old style of param parsing	 
3edf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ee0					NEXTW 
3ee0 c3 5a 22			jp macro_next 
3ee3				endm 
# End of macro NEXTW
3ee3			.CDUMP: 
3ee3				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ee3 38				db WORD_SYS_CORE+36             
3ee4 13 3f			dw .DAT            
3ee6 06				db 5 + 1 
3ee7 .. 00			db "CDUMP",0              
3eed				endm 
# End of macro CWHEAD
3eed			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3eed					if DEBUG_FORTH_WORDS_KEY 
3eed						DMARK "CDP" 
3eed f5				push af  
3eee 3a 02 3f			ld a, (.dmark)  
3ef1 32 b4 fe			ld (debug_mark),a  
3ef4 3a 03 3f			ld a, (.dmark+1)  
3ef7 32 b5 fe			ld (debug_mark+1),a  
3efa 3a 04 3f			ld a, (.dmark+2)  
3efd 32 b6 fe			ld (debug_mark+2),a  
3f00 18 03			jr .pastdmark  
3f02 ..			.dmark: db "CDP"  
3f05 f1			.pastdmark: pop af  
3f06			endm  
# End of macro DMARK
3f06						CALLMONITOR 
3f06 cd 78 18			call break_point_state  
3f09				endm  
# End of macro CALLMONITOR
3f09					endif 
3f09 cd c7 0c				call clear_display 
3f0c cd 6c 1d				call dumpcont	 
3f0f c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f10					NEXTW 
3f10 c3 5a 22			jp macro_next 
3f13				endm 
# End of macro NEXTW
3f13			 
3f13			 
3f13			 
3f13			 
3f13			.DAT: 
3f13				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f13 3d				db WORD_SYS_CORE+41             
3f14 69 3f			dw .HOME            
3f16 03				db 2 + 1 
3f17 .. 00			db "AT",0              
3f1a				endm 
# End of macro CWHEAD
3f1a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f1a					if DEBUG_FORTH_WORDS_KEY 
3f1a						DMARK "AT." 
3f1a f5				push af  
3f1b 3a 2f 3f			ld a, (.dmark)  
3f1e 32 b4 fe			ld (debug_mark),a  
3f21 3a 30 3f			ld a, (.dmark+1)  
3f24 32 b5 fe			ld (debug_mark+1),a  
3f27 3a 31 3f			ld a, (.dmark+2)  
3f2a 32 b6 fe			ld (debug_mark+2),a  
3f2d 18 03			jr .pastdmark  
3f2f ..			.dmark: db "AT."  
3f32 f1			.pastdmark: pop af  
3f33			endm  
# End of macro DMARK
3f33						CALLMONITOR 
3f33 cd 78 18			call break_point_state  
3f36				endm  
# End of macro CALLMONITOR
3f36					endif 
3f36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f36 cd e3 20			call macro_dsp_valuehl 
3f39				endm 
# End of macro FORTH_DSP_VALUEHL
3f39			 
3f39			 
3f39					; TODO save cursor row 
3f39 7d					ld a,l 
3f3a fe 02				cp 2 
3f3c 20 04				jr nz, .crow3 
3f3e 3e 14				ld a, display_row_2 
3f40 18 12				jr .ccol1 
3f42 fe 03		.crow3:		cp 3 
3f44 20 04				jr nz, .crow4 
3f46 3e 28				ld a, display_row_3 
3f48 18 0a				jr .ccol1 
3f4a fe 04		.crow4:		cp 4 
3f4c 20 04				jr nz, .crow1 
3f4e 3e 3c				ld a, display_row_4 
3f50 18 02				jr .ccol1 
3f52 3e 00		.crow1:		ld a,display_row_1 
3f54 f5			.ccol1:		push af			; got row offset 
3f55 6f					ld l,a 
3f56 26 00				ld h,0 
3f58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f58 cd 9b 21			call macro_forth_dsp_pop 
3f5b				endm 
# End of macro FORTH_DSP_POP
3f5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f5b cd e3 20			call macro_dsp_valuehl 
3f5e				endm 
# End of macro FORTH_DSP_VALUEHL
3f5e					; TODO save cursor col 
3f5e f1					pop af 
3f5f 85					add l		; add col offset 
3f60 32 ee fb				ld (f_cursor_ptr), a 
3f63					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f63 cd 9b 21			call macro_forth_dsp_pop 
3f66				endm 
# End of macro FORTH_DSP_POP
3f66			 
3f66					; calculate  
3f66			 
3f66					NEXTW 
3f66 c3 5a 22			jp macro_next 
3f69				endm 
# End of macro NEXTW
3f69			 
3f69			 
3f69			.HOME: 
3f69				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f69 41				db WORD_SYS_CORE+45             
3f6a 96 3f			dw .SPACE            
3f6c 05				db 4 + 1 
3f6d .. 00			db "HOME",0              
3f72				endm 
# End of macro CWHEAD
3f72			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f72					if DEBUG_FORTH_WORDS_KEY 
3f72						DMARK "HOM" 
3f72 f5				push af  
3f73 3a 87 3f			ld a, (.dmark)  
3f76 32 b4 fe			ld (debug_mark),a  
3f79 3a 88 3f			ld a, (.dmark+1)  
3f7c 32 b5 fe			ld (debug_mark+1),a  
3f7f 3a 89 3f			ld a, (.dmark+2)  
3f82 32 b6 fe			ld (debug_mark+2),a  
3f85 18 03			jr .pastdmark  
3f87 ..			.dmark: db "HOM"  
3f8a f1			.pastdmark: pop af  
3f8b			endm  
# End of macro DMARK
3f8b						CALLMONITOR 
3f8b cd 78 18			call break_point_state  
3f8e				endm  
# End of macro CALLMONITOR
3f8e					endif 
3f8e 3e 00		.home:		ld a, 0		; and home cursor 
3f90 32 ee fb				ld (f_cursor_ptr), a 
3f93					NEXTW 
3f93 c3 5a 22			jp macro_next 
3f96				endm 
# End of macro NEXTW
3f96			 
3f96			 
3f96			.SPACE: 
3f96				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f96 46				db WORD_SYS_CORE+50             
3f97 c4 3f			dw .SPACES            
3f99 03				db 2 + 1 
3f9a .. 00			db "BL",0              
3f9d				endm 
# End of macro CWHEAD
3f9d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f9d					if DEBUG_FORTH_WORDS_KEY 
3f9d						DMARK "BL." 
3f9d f5				push af  
3f9e 3a b2 3f			ld a, (.dmark)  
3fa1 32 b4 fe			ld (debug_mark),a  
3fa4 3a b3 3f			ld a, (.dmark+1)  
3fa7 32 b5 fe			ld (debug_mark+1),a  
3faa 3a b4 3f			ld a, (.dmark+2)  
3fad 32 b6 fe			ld (debug_mark+2),a  
3fb0 18 03			jr .pastdmark  
3fb2 ..			.dmark: db "BL."  
3fb5 f1			.pastdmark: pop af  
3fb6			endm  
# End of macro DMARK
3fb6						CALLMONITOR 
3fb6 cd 78 18			call break_point_state  
3fb9				endm  
# End of macro CALLMONITOR
3fb9					endif 
3fb9 21 c2 3f				ld hl, .blstr 
3fbc cd 5a 1f				call forth_push_str 
3fbf					 
3fbf				       NEXTW 
3fbf c3 5a 22			jp macro_next 
3fc2				endm 
# End of macro NEXTW
3fc2			 
3fc2 .. 00		.blstr: db " ", 0 
3fc4			 
3fc4			.SPACES: 
3fc4				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3fc4 47				db WORD_SYS_CORE+51             
3fc5 5f 40			dw .SCROLL            
3fc7 07				db 6 + 1 
3fc8 .. 00			db "SPACES",0              
3fcf				endm 
# End of macro CWHEAD
3fcf			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3fcf					if DEBUG_FORTH_WORDS_KEY 
3fcf						DMARK "SPS" 
3fcf f5				push af  
3fd0 3a e4 3f			ld a, (.dmark)  
3fd3 32 b4 fe			ld (debug_mark),a  
3fd6 3a e5 3f			ld a, (.dmark+1)  
3fd9 32 b5 fe			ld (debug_mark+1),a  
3fdc 3a e6 3f			ld a, (.dmark+2)  
3fdf 32 b6 fe			ld (debug_mark+2),a  
3fe2 18 03			jr .pastdmark  
3fe4 ..			.dmark: db "SPS"  
3fe7 f1			.pastdmark: pop af  
3fe8			endm  
# End of macro DMARK
3fe8						CALLMONITOR 
3fe8 cd 78 18			call break_point_state  
3feb				endm  
# End of macro CALLMONITOR
3feb					endif 
3feb			 
3feb			 
3feb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3feb cd e3 20			call macro_dsp_valuehl 
3fee				endm 
# End of macro FORTH_DSP_VALUEHL
3fee			 
3fee			;		push hl    ; u 
3fee					if DEBUG_FORTH_WORDS 
3fee						DMARK "SPA" 
3fee f5				push af  
3fef 3a 03 40			ld a, (.dmark)  
3ff2 32 b4 fe			ld (debug_mark),a  
3ff5 3a 04 40			ld a, (.dmark+1)  
3ff8 32 b5 fe			ld (debug_mark+1),a  
3ffb 3a 05 40			ld a, (.dmark+2)  
3ffe 32 b6 fe			ld (debug_mark+2),a  
4001 18 03			jr .pastdmark  
4003 ..			.dmark: db "SPA"  
4006 f1			.pastdmark: pop af  
4007			endm  
# End of macro DMARK
4007						CALLMONITOR 
4007 cd 78 18			call break_point_state  
400a				endm  
# End of macro CALLMONITOR
400a					endif 
400a			 
400a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
400a cd 9b 21			call macro_forth_dsp_pop 
400d				endm 
# End of macro FORTH_DSP_POP
400d			;		pop hl 
400d 4d					ld c, l 
400e 06 00				ld b, 0 
4010 21 85 f3				ld hl, scratch  
4013			 
4013					if DEBUG_FORTH_WORDS 
4013						DMARK "SP2" 
4013 f5				push af  
4014 3a 28 40			ld a, (.dmark)  
4017 32 b4 fe			ld (debug_mark),a  
401a 3a 29 40			ld a, (.dmark+1)  
401d 32 b5 fe			ld (debug_mark+1),a  
4020 3a 2a 40			ld a, (.dmark+2)  
4023 32 b6 fe			ld (debug_mark+2),a  
4026 18 03			jr .pastdmark  
4028 ..			.dmark: db "SP2"  
402b f1			.pastdmark: pop af  
402c			endm  
# End of macro DMARK
402c						CALLMONITOR 
402c cd 78 18			call break_point_state  
402f				endm  
# End of macro CALLMONITOR
402f					endif 
402f 3e 20				ld a, ' ' 
4031 c5			.spaces1:	push bc 
4032 77					ld (hl),a 
4033 23					inc hl 
4034 c1					pop bc 
4035 10 fa				djnz .spaces1 
4037 3e 00				ld a,0 
4039 77					ld (hl),a 
403a 21 85 f3				ld hl, scratch 
403d					if DEBUG_FORTH_WORDS 
403d						DMARK "SP3" 
403d f5				push af  
403e 3a 52 40			ld a, (.dmark)  
4041 32 b4 fe			ld (debug_mark),a  
4044 3a 53 40			ld a, (.dmark+1)  
4047 32 b5 fe			ld (debug_mark+1),a  
404a 3a 54 40			ld a, (.dmark+2)  
404d 32 b6 fe			ld (debug_mark+2),a  
4050 18 03			jr .pastdmark  
4052 ..			.dmark: db "SP3"  
4055 f1			.pastdmark: pop af  
4056			endm  
# End of macro DMARK
4056						CALLMONITOR 
4056 cd 78 18			call break_point_state  
4059				endm  
# End of macro CALLMONITOR
4059					endif 
4059 cd 55 20				call forth_apush 
405c			 
405c				       NEXTW 
405c c3 5a 22			jp macro_next 
405f				endm 
# End of macro NEXTW
405f			 
405f			 
405f			 
405f			.SCROLL: 
405f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
405f 53				db WORD_SYS_CORE+63             
4060 8c 40			dw .SCROLLD            
4062 07				db 6 + 1 
4063 .. 00			db "SCROLL",0              
406a				endm 
# End of macro CWHEAD
406a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
406a					if DEBUG_FORTH_WORDS_KEY 
406a						DMARK "SCR" 
406a f5				push af  
406b 3a 7f 40			ld a, (.dmark)  
406e 32 b4 fe			ld (debug_mark),a  
4071 3a 80 40			ld a, (.dmark+1)  
4074 32 b5 fe			ld (debug_mark+1),a  
4077 3a 81 40			ld a, (.dmark+2)  
407a 32 b6 fe			ld (debug_mark+2),a  
407d 18 03			jr .pastdmark  
407f ..			.dmark: db "SCR"  
4082 f1			.pastdmark: pop af  
4083			endm  
# End of macro DMARK
4083						CALLMONITOR 
4083 cd 78 18			call break_point_state  
4086				endm  
# End of macro CALLMONITOR
4086					endif 
4086			 
4086 cd 89 0c			call scroll_up 
4089			;	call update_display 
4089			 
4089					NEXTW 
4089 c3 5a 22			jp macro_next 
408c				endm 
# End of macro NEXTW
408c			 
408c			 
408c			 
408c			;		; get dir 
408c			; 
408c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408c			; 
408c			;		push hl 
408c			; 
408c			;		; destroy value TOS 
408c			; 
408c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408c			; 
408c			;		; get count 
408c			; 
408c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408c			; 
408c			;		push hl 
408c			; 
408c			;		; destroy value TOS 
408c			; 
408c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408c			; 
408c			;		; one value on hl get other one back 
408c			; 
408c			;		pop bc    ; count 
408c			; 
408c			;		pop de   ; dir 
408c			; 
408c			; 
408c			;		ld b, c 
408c			; 
408c			;.scrolldir:     push bc 
408c			;		push de 
408c			; 
408c			;		ld a, 0 
408c			;		cp e 
408c			;		jr z, .scrollup  
408c			;		call scroll_down 
408c			;		jr .scrollnext 
408c			;.scrollup:	call scroll_up 
408c			; 
408c			;		 
408c			;.scrollnext: 
408c			;		pop de 
408c			;		pop bc 
408c			;		djnz .scrolldir 
408c			; 
408c			; 
408c			; 
408c			; 
408c			; 
408c			;		NEXTW 
408c			 
408c			.SCROLLD: 
408c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
408c 53				db WORD_SYS_CORE+63             
408d ba 40			dw .ATQ            
408f 08				db 7 + 1 
4090 .. 00			db "SCROLLD",0              
4098				endm 
# End of macro CWHEAD
4098			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4098					if DEBUG_FORTH_WORDS_KEY 
4098						DMARK "SCD" 
4098 f5				push af  
4099 3a ad 40			ld a, (.dmark)  
409c 32 b4 fe			ld (debug_mark),a  
409f 3a ae 40			ld a, (.dmark+1)  
40a2 32 b5 fe			ld (debug_mark+1),a  
40a5 3a af 40			ld a, (.dmark+2)  
40a8 32 b6 fe			ld (debug_mark+2),a  
40ab 18 03			jr .pastdmark  
40ad ..			.dmark: db "SCD"  
40b0 f1			.pastdmark: pop af  
40b1			endm  
# End of macro DMARK
40b1						CALLMONITOR 
40b1 cd 78 18			call break_point_state  
40b4				endm  
# End of macro CALLMONITOR
40b4					endif 
40b4			 
40b4 cd ad 0c			call scroll_down 
40b7			;	call update_display 
40b7			 
40b7					NEXTW 
40b7 c3 5a 22			jp macro_next 
40ba				endm 
# End of macro NEXTW
40ba			 
40ba			 
40ba			.ATQ: 
40ba				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40ba 62				db WORD_SYS_CORE+78             
40bb 18 41			dw .AUTODSP            
40bd 04				db 3 + 1 
40be .. 00			db "AT@",0              
40c2				endm 
# End of macro CWHEAD
40c2			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40c2					if DEBUG_FORTH_WORDS_KEY 
40c2						DMARK "ATA" 
40c2 f5				push af  
40c3 3a d7 40			ld a, (.dmark)  
40c6 32 b4 fe			ld (debug_mark),a  
40c9 3a d8 40			ld a, (.dmark+1)  
40cc 32 b5 fe			ld (debug_mark+1),a  
40cf 3a d9 40			ld a, (.dmark+2)  
40d2 32 b6 fe			ld (debug_mark+2),a  
40d5 18 03			jr .pastdmark  
40d7 ..			.dmark: db "ATA"  
40da f1			.pastdmark: pop af  
40db			endm  
# End of macro DMARK
40db						CALLMONITOR 
40db cd 78 18			call break_point_state  
40de				endm  
# End of macro CALLMONITOR
40de					endif 
40de			 
40de			 
40de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40de cd e3 20			call macro_dsp_valuehl 
40e1				endm 
# End of macro FORTH_DSP_VALUEHL
40e1			 
40e1					; TODO save cursor row 
40e1 7d					ld a,l 
40e2 fe 02				cp 2 
40e4 20 04				jr nz, .crow3aq 
40e6 3e 14				ld a, display_row_2 
40e8 18 12				jr .ccol1aq 
40ea fe 03		.crow3aq:		cp 3 
40ec 20 04				jr nz, .crow4aq 
40ee 3e 28				ld a, display_row_3 
40f0 18 0a				jr .ccol1aq 
40f2 fe 04		.crow4aq:		cp 4 
40f4 20 04				jr nz, .crow1aq 
40f6 3e 3c				ld a, display_row_4 
40f8 18 02				jr .ccol1aq 
40fa 3e 00		.crow1aq:		ld a,display_row_1 
40fc f5			.ccol1aq:		push af			; got row offset 
40fd 6f					ld l,a 
40fe 26 00				ld h,0 
4100					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4100 cd 9b 21			call macro_forth_dsp_pop 
4103				endm 
# End of macro FORTH_DSP_POP
4103					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4103 cd e3 20			call macro_dsp_valuehl 
4106				endm 
# End of macro FORTH_DSP_VALUEHL
4106					; TODO save cursor col 
4106 f1					pop af 
4107 85					add l		; add col offset 
4108			 
4108					; add current frame buffer address 
4108 2a 55 fd				ld hl, (display_fb_active) 
410b cd fb 0e				call addatohl 
410e			 
410e			 
410e			 
410e			 
410e					; get char frame buffer location offset in hl 
410e			 
410e 7e					ld a,(hl) 
410f 26 00				ld h, 0 
4111 6f					ld l, a 
4112			 
4112 cd ec 1e				call forth_push_numhl 
4115			 
4115			 
4115					NEXTW 
4115 c3 5a 22			jp macro_next 
4118				endm 
# End of macro NEXTW
4118			 
4118			.AUTODSP: 
4118				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4118 63				db WORD_SYS_CORE+79             
4119 2e 41			dw .MENU            
411b 05				db 4 + 1 
411c .. 00			db "ADSP",0              
4121				endm 
# End of macro CWHEAD
4121			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4121			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4121			 
4121					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4121 cd e3 20			call macro_dsp_valuehl 
4124				endm 
# End of macro FORTH_DSP_VALUEHL
4124			 
4124			;		push hl 
4124			 
4124					; destroy value TOS 
4124			 
4124					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4124 cd 9b 21			call macro_forth_dsp_pop 
4127				endm 
# End of macro FORTH_DSP_POP
4127			 
4127			;		pop hl 
4127			 
4127 7d					ld a,l 
4128 32 cc fb				ld (cli_autodisplay), a 
412b				       NEXTW 
412b c3 5a 22			jp macro_next 
412e				endm 
# End of macro NEXTW
412e			 
412e			.MENU: 
412e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
412e 70				db WORD_SYS_CORE+92             
412f d7 41			dw .ENDDISPLAY            
4131 05				db 4 + 1 
4132 .. 00			db "MENU",0              
4137				endm 
# End of macro CWHEAD
4137			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4137			 
4137			;		; get number of items on the stack 
4137			; 
4137				 
4137					FORTH_DSP_VALUEHL 
4137 cd e3 20			call macro_dsp_valuehl 
413a				endm 
# End of macro FORTH_DSP_VALUEHL
413a				 
413a					if DEBUG_FORTH_WORDS_KEY 
413a						DMARK "MNU" 
413a f5				push af  
413b 3a 4f 41			ld a, (.dmark)  
413e 32 b4 fe			ld (debug_mark),a  
4141 3a 50 41			ld a, (.dmark+1)  
4144 32 b5 fe			ld (debug_mark+1),a  
4147 3a 51 41			ld a, (.dmark+2)  
414a 32 b6 fe			ld (debug_mark+2),a  
414d 18 03			jr .pastdmark  
414f ..			.dmark: db "MNU"  
4152 f1			.pastdmark: pop af  
4153			endm  
# End of macro DMARK
4153						CALLMONITOR 
4153 cd 78 18			call break_point_state  
4156				endm  
# End of macro CALLMONITOR
4156					endif 
4156			 
4156 45					ld b, l	 
4157 05					dec b 
4158			 
4158					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4158 cd 9b 21			call macro_forth_dsp_pop 
415b				endm 
# End of macro FORTH_DSP_POP
415b			 
415b			 
415b					; go directly through the stack to pluck out the string pointers and build an array 
415b			 
415b			;		FORTH_DSP 
415b			 
415b					; hl contains top most stack item 
415b				 
415b 11 85 f3				ld de, scratch 
415e			 
415e			.mbuild: 
415e			 
415e					FORTH_DSP_VALUEHL 
415e cd e3 20			call macro_dsp_valuehl 
4161				endm 
# End of macro FORTH_DSP_VALUEHL
4161			 
4161					if DEBUG_FORTH_WORDS 
4161						DMARK "MN3" 
4161 f5				push af  
4162 3a 76 41			ld a, (.dmark)  
4165 32 b4 fe			ld (debug_mark),a  
4168 3a 77 41			ld a, (.dmark+1)  
416b 32 b5 fe			ld (debug_mark+1),a  
416e 3a 78 41			ld a, (.dmark+2)  
4171 32 b6 fe			ld (debug_mark+2),a  
4174 18 03			jr .pastdmark  
4176 ..			.dmark: db "MN3"  
4179 f1			.pastdmark: pop af  
417a			endm  
# End of macro DMARK
417a						CALLMONITOR 
417a cd 78 18			call break_point_state  
417d				endm  
# End of macro CALLMONITOR
417d					endif 
417d eb					ex de, hl 
417e 73					ld (hl), e 
417f 23					inc hl 
4180 72					ld (hl), d 
4181 23					inc hl 
4182 eb					ex de, hl 
4183			 
4183					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4183 cd 9b 21			call macro_forth_dsp_pop 
4186				endm 
# End of macro FORTH_DSP_POP
4186			 
4186 10 d6				djnz .mbuild 
4188			 
4188					; done add term 
4188			 
4188 eb					ex de, hl 
4189 36 00				ld (hl), 0 
418b 23					inc hl 
418c 36 00				ld (hl), 0 
418e			 
418e				 
418e					 
418e 21 85 f3				ld hl, scratch 
4191			 
4191					if DEBUG_FORTH_WORDS 
4191						DMARK "MNx" 
4191 f5				push af  
4192 3a a6 41			ld a, (.dmark)  
4195 32 b4 fe			ld (debug_mark),a  
4198 3a a7 41			ld a, (.dmark+1)  
419b 32 b5 fe			ld (debug_mark+1),a  
419e 3a a8 41			ld a, (.dmark+2)  
41a1 32 b6 fe			ld (debug_mark+2),a  
41a4 18 03			jr .pastdmark  
41a6 ..			.dmark: db "MNx"  
41a9 f1			.pastdmark: pop af  
41aa			endm  
# End of macro DMARK
41aa						CALLMONITOR 
41aa cd 78 18			call break_point_state  
41ad				endm  
# End of macro CALLMONITOR
41ad					endif 
41ad			 
41ad			 
41ad			 
41ad 3e 00				ld a, 0 
41af cd f8 0c				call menu 
41b2			 
41b2			 
41b2 6f					ld l, a 
41b3 26 00				ld h, 0 
41b5			 
41b5					if DEBUG_FORTH_WORDS 
41b5						DMARK "MNr" 
41b5 f5				push af  
41b6 3a ca 41			ld a, (.dmark)  
41b9 32 b4 fe			ld (debug_mark),a  
41bc 3a cb 41			ld a, (.dmark+1)  
41bf 32 b5 fe			ld (debug_mark+1),a  
41c2 3a cc 41			ld a, (.dmark+2)  
41c5 32 b6 fe			ld (debug_mark+2),a  
41c8 18 03			jr .pastdmark  
41ca ..			.dmark: db "MNr"  
41cd f1			.pastdmark: pop af  
41ce			endm  
# End of macro DMARK
41ce						CALLMONITOR 
41ce cd 78 18			call break_point_state  
41d1				endm  
# End of macro CALLMONITOR
41d1					endif 
41d1			 
41d1 cd ec 1e				call forth_push_numhl 
41d4			 
41d4			 
41d4			 
41d4			 
41d4				       NEXTW 
41d4 c3 5a 22			jp macro_next 
41d7				endm 
# End of macro NEXTW
41d7			 
41d7			 
41d7			.ENDDISPLAY: 
41d7			 
41d7			; eof 
# End of file forth_words_display.asm
41d7			include "forth_words_str.asm" 
41d7			 
41d7			; | ## String Words 
41d7			 
41d7			.PTR:   
41d7			 
41d7				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41d7 48				db WORD_SYS_CORE+52             
41d8 04 42			dw .STYPE            
41da 04				db 3 + 1 
41db .. 00			db "PTR",0              
41df				endm 
# End of macro CWHEAD
41df			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41df			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41df			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41df			 
41df					if DEBUG_FORTH_WORDS_KEY 
41df						DMARK "PTR" 
41df f5				push af  
41e0 3a f4 41			ld a, (.dmark)  
41e3 32 b4 fe			ld (debug_mark),a  
41e6 3a f5 41			ld a, (.dmark+1)  
41e9 32 b5 fe			ld (debug_mark+1),a  
41ec 3a f6 41			ld a, (.dmark+2)  
41ef 32 b6 fe			ld (debug_mark+2),a  
41f2 18 03			jr .pastdmark  
41f4 ..			.dmark: db "PTR"  
41f7 f1			.pastdmark: pop af  
41f8			endm  
# End of macro DMARK
41f8						CALLMONITOR 
41f8 cd 78 18			call break_point_state  
41fb				endm  
# End of macro CALLMONITOR
41fb					endif 
41fb					FORTH_DSP_VALUEHL 
41fb cd e3 20			call macro_dsp_valuehl 
41fe				endm 
# End of macro FORTH_DSP_VALUEHL
41fe cd ec 1e				call forth_push_numhl 
4201			 
4201			 
4201					NEXTW 
4201 c3 5a 22			jp macro_next 
4204				endm 
# End of macro NEXTW
4204			.STYPE: 
4204				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4204 48				db WORD_SYS_CORE+52             
4205 53 42			dw .UPPER            
4207 06				db 5 + 1 
4208 .. 00			db "STYPE",0              
420e				endm 
# End of macro CWHEAD
420e			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
420e					if DEBUG_FORTH_WORDS_KEY 
420e						DMARK "STY" 
420e f5				push af  
420f 3a 23 42			ld a, (.dmark)  
4212 32 b4 fe			ld (debug_mark),a  
4215 3a 24 42			ld a, (.dmark+1)  
4218 32 b5 fe			ld (debug_mark+1),a  
421b 3a 25 42			ld a, (.dmark+2)  
421e 32 b6 fe			ld (debug_mark+2),a  
4221 18 03			jr .pastdmark  
4223 ..			.dmark: db "STY"  
4226 f1			.pastdmark: pop af  
4227			endm  
# End of macro DMARK
4227						CALLMONITOR 
4227 cd 78 18			call break_point_state  
422a				endm  
# End of macro CALLMONITOR
422a					endif 
422a					FORTH_DSP 
422a cd a9 20			call macro_forth_dsp 
422d				endm 
# End of macro FORTH_DSP
422d					;v5 FORTH_DSP_VALUE 
422d			 
422d 7e					ld a, (hl) 
422e			 
422e f5					push af 
422f			 
422f			; Dont destroy TOS		FORTH_DSP_POP 
422f			 
422f f1					pop af 
4230			 
4230 fe 01				cp DS_TYPE_STR 
4232 28 09				jr z, .typestr 
4234			 
4234 fe 02				cp DS_TYPE_INUM 
4236 28 0a				jr z, .typeinum 
4238			 
4238 21 51 42				ld hl, .tna 
423b 18 0a				jr .tpush 
423d			 
423d 21 4d 42		.typestr:	ld hl, .tstr 
4240 18 05				jr .tpush 
4242 21 4f 42		.typeinum:	ld hl, .tinum 
4245 18 00				jr .tpush 
4247			 
4247			.tpush: 
4247			 
4247 cd 5a 1f				call forth_push_str 
424a			 
424a					NEXTW 
424a c3 5a 22			jp macro_next 
424d				endm 
# End of macro NEXTW
424d .. 00		.tstr:	db "s",0 
424f .. 00		.tinum:  db "i",0 
4251 .. 00		.tna:   db "?", 0 
4253			 
4253			 
4253			.UPPER: 
4253				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4253 48				db WORD_SYS_CORE+52             
4254 8e 42			dw .LOWER            
4256 06				db 5 + 1 
4257 .. 00			db "UPPER",0              
425d				endm 
# End of macro CWHEAD
425d			; | UPPER ( s -- s ) Upper case string s  | DONE 
425d					if DEBUG_FORTH_WORDS_KEY 
425d						DMARK "UPR" 
425d f5				push af  
425e 3a 72 42			ld a, (.dmark)  
4261 32 b4 fe			ld (debug_mark),a  
4264 3a 73 42			ld a, (.dmark+1)  
4267 32 b5 fe			ld (debug_mark+1),a  
426a 3a 74 42			ld a, (.dmark+2)  
426d 32 b6 fe			ld (debug_mark+2),a  
4270 18 03			jr .pastdmark  
4272 ..			.dmark: db "UPR"  
4275 f1			.pastdmark: pop af  
4276			endm  
# End of macro DMARK
4276						CALLMONITOR 
4276 cd 78 18			call break_point_state  
4279				endm  
# End of macro CALLMONITOR
4279					endif 
4279			 
4279					FORTH_DSP 
4279 cd a9 20			call macro_forth_dsp 
427c				endm 
# End of macro FORTH_DSP
427c					 
427c			; TODO check is string type 
427c			 
427c					FORTH_DSP_VALUEHL 
427c cd e3 20			call macro_dsp_valuehl 
427f				endm 
# End of macro FORTH_DSP_VALUEHL
427f			; get pointer to string in hl 
427f			 
427f 7e			.toup:		ld a, (hl) 
4280 fe 00				cp 0 
4282 28 07				jr z, .toupdone 
4284			 
4284 cd 68 12				call to_upper 
4287			 
4287 77					ld (hl), a 
4288 23					inc hl 
4289 18 f4				jr .toup 
428b			 
428b					 
428b			 
428b			 
428b			; for each char convert to upper 
428b					 
428b			.toupdone: 
428b			 
428b			 
428b					NEXTW 
428b c3 5a 22			jp macro_next 
428e				endm 
# End of macro NEXTW
428e			.LOWER: 
428e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
428e 48				db WORD_SYS_CORE+52             
428f c9 42			dw .TCASE            
4291 06				db 5 + 1 
4292 .. 00			db "LOWER",0              
4298				endm 
# End of macro CWHEAD
4298			; | LOWER ( s -- s ) Lower case string s  | DONE 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "LWR" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 b4 fe			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 b5 fe			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 b6 fe			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "LWR"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 78 18			call break_point_state  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4			 
42b4					FORTH_DSP 
42b4 cd a9 20			call macro_forth_dsp 
42b7				endm 
# End of macro FORTH_DSP
42b7					 
42b7			; TODO check is string type 
42b7			 
42b7					FORTH_DSP_VALUEHL 
42b7 cd e3 20			call macro_dsp_valuehl 
42ba				endm 
# End of macro FORTH_DSP_VALUEHL
42ba			; get pointer to string in hl 
42ba			 
42ba 7e			.tolow:		ld a, (hl) 
42bb fe 00				cp 0 
42bd 28 07				jr z, .tolowdone 
42bf			 
42bf cd 71 12				call to_lower 
42c2			 
42c2 77					ld (hl), a 
42c3 23					inc hl 
42c4 18 f4				jr .tolow 
42c6			 
42c6					 
42c6			 
42c6			 
42c6			; for each char convert to low 
42c6					 
42c6			.tolowdone: 
42c6					NEXTW 
42c6 c3 5a 22			jp macro_next 
42c9				endm 
# End of macro NEXTW
42c9			.TCASE: 
42c9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42c9 48				db WORD_SYS_CORE+52             
42ca ff 43			dw .SUBSTR            
42cc 06				db 5 + 1 
42cd .. 00			db "TCASE",0              
42d3				endm 
# End of macro CWHEAD
42d3			; | TCASE ( s -- s ) Title case string s  | DONE 
42d3					if DEBUG_FORTH_WORDS_KEY 
42d3						DMARK "TCS" 
42d3 f5				push af  
42d4 3a e8 42			ld a, (.dmark)  
42d7 32 b4 fe			ld (debug_mark),a  
42da 3a e9 42			ld a, (.dmark+1)  
42dd 32 b5 fe			ld (debug_mark+1),a  
42e0 3a ea 42			ld a, (.dmark+2)  
42e3 32 b6 fe			ld (debug_mark+2),a  
42e6 18 03			jr .pastdmark  
42e8 ..			.dmark: db "TCS"  
42eb f1			.pastdmark: pop af  
42ec			endm  
# End of macro DMARK
42ec						CALLMONITOR 
42ec cd 78 18			call break_point_state  
42ef				endm  
# End of macro CALLMONITOR
42ef					endif 
42ef			 
42ef					FORTH_DSP 
42ef cd a9 20			call macro_forth_dsp 
42f2				endm 
# End of macro FORTH_DSP
42f2					 
42f2			; TODO check is string type 
42f2			 
42f2					FORTH_DSP_VALUEHL 
42f2 cd e3 20			call macro_dsp_valuehl 
42f5				endm 
# End of macro FORTH_DSP_VALUEHL
42f5			; get pointer to string in hl 
42f5			 
42f5					if DEBUG_FORTH_WORDS 
42f5						DMARK "TC1" 
42f5 f5				push af  
42f6 3a 0a 43			ld a, (.dmark)  
42f9 32 b4 fe			ld (debug_mark),a  
42fc 3a 0b 43			ld a, (.dmark+1)  
42ff 32 b5 fe			ld (debug_mark+1),a  
4302 3a 0c 43			ld a, (.dmark+2)  
4305 32 b6 fe			ld (debug_mark+2),a  
4308 18 03			jr .pastdmark  
430a ..			.dmark: db "TC1"  
430d f1			.pastdmark: pop af  
430e			endm  
# End of macro DMARK
430e						CALLMONITOR 
430e cd 78 18			call break_point_state  
4311				endm  
# End of macro CALLMONITOR
4311					endif 
4311			 
4311					; first time in turn to upper case first char 
4311			 
4311 7e					ld a, (hl) 
4312 c3 9c 43				jp .totsiptou 
4315			 
4315			 
4315 7e			.tot:		ld a, (hl) 
4316 fe 00				cp 0 
4318 ca e0 43				jp z, .totdone 
431b			 
431b					if DEBUG_FORTH_WORDS 
431b						DMARK "TC2" 
431b f5				push af  
431c 3a 30 43			ld a, (.dmark)  
431f 32 b4 fe			ld (debug_mark),a  
4322 3a 31 43			ld a, (.dmark+1)  
4325 32 b5 fe			ld (debug_mark+1),a  
4328 3a 32 43			ld a, (.dmark+2)  
432b 32 b6 fe			ld (debug_mark+2),a  
432e 18 03			jr .pastdmark  
4330 ..			.dmark: db "TC2"  
4333 f1			.pastdmark: pop af  
4334			endm  
# End of macro DMARK
4334						CALLMONITOR 
4334 cd 78 18			call break_point_state  
4337				endm  
# End of macro CALLMONITOR
4337					endif 
4337					; check to see if current char is a space 
4337			 
4337 fe 20				cp ' ' 
4339 28 21				jr z, .totsp 
433b cd 71 12				call to_lower 
433e					if DEBUG_FORTH_WORDS 
433e						DMARK "TC3" 
433e f5				push af  
433f 3a 53 43			ld a, (.dmark)  
4342 32 b4 fe			ld (debug_mark),a  
4345 3a 54 43			ld a, (.dmark+1)  
4348 32 b5 fe			ld (debug_mark+1),a  
434b 3a 55 43			ld a, (.dmark+2)  
434e 32 b6 fe			ld (debug_mark+2),a  
4351 18 03			jr .pastdmark  
4353 ..			.dmark: db "TC3"  
4356 f1			.pastdmark: pop af  
4357			endm  
# End of macro DMARK
4357						CALLMONITOR 
4357 cd 78 18			call break_point_state  
435a				endm  
# End of macro CALLMONITOR
435a					endif 
435a 18 63				jr .totnxt 
435c			 
435c			.totsp:         ; on a space, find next char which should be upper 
435c			 
435c					if DEBUG_FORTH_WORDS 
435c						DMARK "TC4" 
435c f5				push af  
435d 3a 71 43			ld a, (.dmark)  
4360 32 b4 fe			ld (debug_mark),a  
4363 3a 72 43			ld a, (.dmark+1)  
4366 32 b5 fe			ld (debug_mark+1),a  
4369 3a 73 43			ld a, (.dmark+2)  
436c 32 b6 fe			ld (debug_mark+2),a  
436f 18 03			jr .pastdmark  
4371 ..			.dmark: db "TC4"  
4374 f1			.pastdmark: pop af  
4375			endm  
# End of macro DMARK
4375						CALLMONITOR 
4375 cd 78 18			call break_point_state  
4378				endm  
# End of macro CALLMONITOR
4378					endif 
4378					;; 
4378			 
4378 fe 20				cp ' ' 
437a 20 20				jr nz, .totsiptou 
437c 23					inc hl 
437d 7e					ld a, (hl) 
437e					if DEBUG_FORTH_WORDS 
437e						DMARK "TC5" 
437e f5				push af  
437f 3a 93 43			ld a, (.dmark)  
4382 32 b4 fe			ld (debug_mark),a  
4385 3a 94 43			ld a, (.dmark+1)  
4388 32 b5 fe			ld (debug_mark+1),a  
438b 3a 95 43			ld a, (.dmark+2)  
438e 32 b6 fe			ld (debug_mark+2),a  
4391 18 03			jr .pastdmark  
4393 ..			.dmark: db "TC5"  
4396 f1			.pastdmark: pop af  
4397			endm  
# End of macro DMARK
4397						CALLMONITOR 
4397 cd 78 18			call break_point_state  
439a				endm  
# End of macro CALLMONITOR
439a					endif 
439a 18 c0				jr .totsp 
439c fe 00		.totsiptou:    cp 0 
439e 28 40				jr z, .totdone 
43a0					; not space and not zero term so upper case it 
43a0 cd 68 12				call to_upper 
43a3			 
43a3					if DEBUG_FORTH_WORDS 
43a3						DMARK "TC6" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 b4 fe			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 b5 fe			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 b6 fe			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "TC6"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd 78 18			call break_point_state  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf			 
43bf			 
43bf			.totnxt: 
43bf			 
43bf 77					ld (hl), a 
43c0 23					inc hl 
43c1					if DEBUG_FORTH_WORDS 
43c1						DMARK "TC7" 
43c1 f5				push af  
43c2 3a d6 43			ld a, (.dmark)  
43c5 32 b4 fe			ld (debug_mark),a  
43c8 3a d7 43			ld a, (.dmark+1)  
43cb 32 b5 fe			ld (debug_mark+1),a  
43ce 3a d8 43			ld a, (.dmark+2)  
43d1 32 b6 fe			ld (debug_mark+2),a  
43d4 18 03			jr .pastdmark  
43d6 ..			.dmark: db "TC7"  
43d9 f1			.pastdmark: pop af  
43da			endm  
# End of macro DMARK
43da						CALLMONITOR 
43da cd 78 18			call break_point_state  
43dd				endm  
# End of macro CALLMONITOR
43dd					endif 
43dd c3 15 43				jp .tot 
43e0			 
43e0					 
43e0			 
43e0			 
43e0			; for each char convert to low 
43e0					 
43e0			.totdone: 
43e0					if DEBUG_FORTH_WORDS 
43e0						DMARK "TCd" 
43e0 f5				push af  
43e1 3a f5 43			ld a, (.dmark)  
43e4 32 b4 fe			ld (debug_mark),a  
43e7 3a f6 43			ld a, (.dmark+1)  
43ea 32 b5 fe			ld (debug_mark+1),a  
43ed 3a f7 43			ld a, (.dmark+2)  
43f0 32 b6 fe			ld (debug_mark+2),a  
43f3 18 03			jr .pastdmark  
43f5 ..			.dmark: db "TCd"  
43f8 f1			.pastdmark: pop af  
43f9			endm  
# End of macro DMARK
43f9						CALLMONITOR 
43f9 cd 78 18			call break_point_state  
43fc				endm  
# End of macro CALLMONITOR
43fc					endif 
43fc					NEXTW 
43fc c3 5a 22			jp macro_next 
43ff				endm 
# End of macro NEXTW
43ff			 
43ff			.SUBSTR: 
43ff				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43ff 48				db WORD_SYS_CORE+52             
4400 5d 44			dw .LEFT            
4402 07				db 6 + 1 
4403 .. 00			db "SUBSTR",0              
440a				endm 
# End of macro CWHEAD
440a			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
440a			 
440a					if DEBUG_FORTH_WORDS_KEY 
440a						DMARK "SST" 
440a f5				push af  
440b 3a 1f 44			ld a, (.dmark)  
440e 32 b4 fe			ld (debug_mark),a  
4411 3a 20 44			ld a, (.dmark+1)  
4414 32 b5 fe			ld (debug_mark+1),a  
4417 3a 21 44			ld a, (.dmark+2)  
441a 32 b6 fe			ld (debug_mark+2),a  
441d 18 03			jr .pastdmark  
441f ..			.dmark: db "SST"  
4422 f1			.pastdmark: pop af  
4423			endm  
# End of macro DMARK
4423						CALLMONITOR 
4423 cd 78 18			call break_point_state  
4426				endm  
# End of macro CALLMONITOR
4426					endif 
4426			; TODO check string type 
4426					FORTH_DSP_VALUEHL 
4426 cd e3 20			call macro_dsp_valuehl 
4429				endm 
# End of macro FORTH_DSP_VALUEHL
4429			 
4429 e5					push hl      ; string length 
442a			 
442a					FORTH_DSP_POP 
442a cd 9b 21			call macro_forth_dsp_pop 
442d				endm 
# End of macro FORTH_DSP_POP
442d			 
442d					FORTH_DSP_VALUEHL 
442d cd e3 20			call macro_dsp_valuehl 
4430				endm 
# End of macro FORTH_DSP_VALUEHL
4430			 
4430 e5					push hl     ; start char 
4431			 
4431					FORTH_DSP_POP 
4431 cd 9b 21			call macro_forth_dsp_pop 
4434				endm 
# End of macro FORTH_DSP_POP
4434			 
4434			 
4434					FORTH_DSP_VALUE 
4434 cd cc 20			call macro_forth_dsp_value 
4437				endm 
# End of macro FORTH_DSP_VALUE
4437			 
4437 d1					pop de    ; get start post offset 
4438			 
4438 19					add hl, de    ; starting offset 
4439			 
4439 c1					pop bc 
443a c5					push bc      ; grab size of string 
443b			 
443b e5					push hl    ; save string start  
443c			 
443c 26 00				ld h, 0 
443e 69					ld l, c 
443f 23					inc hl 
4440 23					inc hl 
4441			 
4441 cd c2 13				call malloc 
4444				if DEBUG_FORTH_MALLOC_GUARD 
4444 cc 2d 55				call z,malloc_error 
4447				endif 
4447			 
4447 eb					ex de, hl      ; save malloc area for string copy 
4448 e1					pop hl    ; get back source 
4449 c1					pop bc    ; get length of string back 
444a			 
444a d5					push de    ; save malloc area for after we push 
444b ed b0				ldir     ; copy substr 
444d			 
444d			 
444d eb					ex de, hl 
444e 3e 00				ld a, 0 
4450 77					ld (hl), a   ; term substr 
4451			 
4451					 
4451 e1					pop hl    ; get malloc so we can push it 
4452 e5					push hl   ; save so we can free it afterwards 
4453			 
4453 cd 5a 1f				call forth_push_str 
4456			 
4456 e1					pop hl 
4457 cd 8c 14				call free 
445a			 
445a					 
445a					 
445a			 
445a			 
445a					NEXTW 
445a c3 5a 22			jp macro_next 
445d				endm 
# End of macro NEXTW
445d			 
445d			.LEFT: 
445d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
445d 48				db WORD_SYS_CORE+52             
445e 85 44			dw .RIGHT            
4460 05				db 4 + 1 
4461 .. 00			db "LEFT",0              
4466				endm 
# End of macro CWHEAD
4466			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4466					if DEBUG_FORTH_WORDS_KEY 
4466						DMARK "LEF" 
4466 f5				push af  
4467 3a 7b 44			ld a, (.dmark)  
446a 32 b4 fe			ld (debug_mark),a  
446d 3a 7c 44			ld a, (.dmark+1)  
4470 32 b5 fe			ld (debug_mark+1),a  
4473 3a 7d 44			ld a, (.dmark+2)  
4476 32 b6 fe			ld (debug_mark+2),a  
4479 18 03			jr .pastdmark  
447b ..			.dmark: db "LEF"  
447e f1			.pastdmark: pop af  
447f			endm  
# End of macro DMARK
447f						CALLMONITOR 
447f cd 78 18			call break_point_state  
4482				endm  
# End of macro CALLMONITOR
4482					endif 
4482			 
4482					NEXTW 
4482 c3 5a 22			jp macro_next 
4485				endm 
# End of macro NEXTW
4485			.RIGHT: 
4485				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4485 48				db WORD_SYS_CORE+52             
4486 ae 44			dw .STR2NUM            
4488 06				db 5 + 1 
4489 .. 00			db "RIGHT",0              
448f				endm 
# End of macro CWHEAD
448f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
448f					if DEBUG_FORTH_WORDS_KEY 
448f						DMARK "RIG" 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 b4 fe			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 b5 fe			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 b6 fe			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "RIG"  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8						CALLMONITOR 
44a8 cd 78 18			call break_point_state  
44ab				endm  
# End of macro CALLMONITOR
44ab					endif 
44ab			 
44ab					NEXTW 
44ab c3 5a 22			jp macro_next 
44ae				endm 
# End of macro NEXTW
44ae			 
44ae			 
44ae			.STR2NUM: 
44ae				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44ae 48				db WORD_SYS_CORE+52             
44af 3a 45			dw .NUM2STR            
44b1 08				db 7 + 1 
44b2 .. 00			db "STR2NUM",0              
44ba				endm 
# End of macro CWHEAD
44ba			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44ba			 
44ba			 
44ba			; TODO STR type check to do 
44ba					if DEBUG_FORTH_WORDS_KEY 
44ba						DMARK "S2N" 
44ba f5				push af  
44bb 3a cf 44			ld a, (.dmark)  
44be 32 b4 fe			ld (debug_mark),a  
44c1 3a d0 44			ld a, (.dmark+1)  
44c4 32 b5 fe			ld (debug_mark+1),a  
44c7 3a d1 44			ld a, (.dmark+2)  
44ca 32 b6 fe			ld (debug_mark+2),a  
44cd 18 03			jr .pastdmark  
44cf ..			.dmark: db "S2N"  
44d2 f1			.pastdmark: pop af  
44d3			endm  
# End of macro DMARK
44d3						CALLMONITOR 
44d3 cd 78 18			call break_point_state  
44d6				endm  
# End of macro CALLMONITOR
44d6					endif 
44d6			 
44d6					;FORTH_DSP 
44d6					FORTH_DSP_VALUE 
44d6 cd cc 20			call macro_forth_dsp_value 
44d9				endm 
# End of macro FORTH_DSP_VALUE
44d9					;inc hl 
44d9			 
44d9 eb					ex de, hl 
44da					if DEBUG_FORTH_WORDS 
44da						DMARK "S2a" 
44da f5				push af  
44db 3a ef 44			ld a, (.dmark)  
44de 32 b4 fe			ld (debug_mark),a  
44e1 3a f0 44			ld a, (.dmark+1)  
44e4 32 b5 fe			ld (debug_mark+1),a  
44e7 3a f1 44			ld a, (.dmark+2)  
44ea 32 b6 fe			ld (debug_mark+2),a  
44ed 18 03			jr .pastdmark  
44ef ..			.dmark: db "S2a"  
44f2 f1			.pastdmark: pop af  
44f3			endm  
# End of macro DMARK
44f3						CALLMONITOR 
44f3 cd 78 18			call break_point_state  
44f6				endm  
# End of macro CALLMONITOR
44f6					endif 
44f6 cd f0 12				call string_to_uint16 
44f9			 
44f9					if DEBUG_FORTH_WORDS 
44f9						DMARK "S2b" 
44f9 f5				push af  
44fa 3a 0e 45			ld a, (.dmark)  
44fd 32 b4 fe			ld (debug_mark),a  
4500 3a 0f 45			ld a, (.dmark+1)  
4503 32 b5 fe			ld (debug_mark+1),a  
4506 3a 10 45			ld a, (.dmark+2)  
4509 32 b6 fe			ld (debug_mark+2),a  
450c 18 03			jr .pastdmark  
450e ..			.dmark: db "S2b"  
4511 f1			.pastdmark: pop af  
4512			endm  
# End of macro DMARK
4512						CALLMONITOR 
4512 cd 78 18			call break_point_state  
4515				endm  
# End of macro CALLMONITOR
4515					endif 
4515			;		push hl 
4515					FORTH_DSP_POP 
4515 cd 9b 21			call macro_forth_dsp_pop 
4518				endm 
# End of macro FORTH_DSP_POP
4518			;		pop hl 
4518					 
4518					if DEBUG_FORTH_WORDS 
4518						DMARK "S2b" 
4518 f5				push af  
4519 3a 2d 45			ld a, (.dmark)  
451c 32 b4 fe			ld (debug_mark),a  
451f 3a 2e 45			ld a, (.dmark+1)  
4522 32 b5 fe			ld (debug_mark+1),a  
4525 3a 2f 45			ld a, (.dmark+2)  
4528 32 b6 fe			ld (debug_mark+2),a  
452b 18 03			jr .pastdmark  
452d ..			.dmark: db "S2b"  
4530 f1			.pastdmark: pop af  
4531			endm  
# End of macro DMARK
4531						CALLMONITOR 
4531 cd 78 18			call break_point_state  
4534				endm  
# End of macro CALLMONITOR
4534					endif 
4534 cd ec 1e				call forth_push_numhl	 
4537			 
4537				 
4537				       NEXTW 
4537 c3 5a 22			jp macro_next 
453a				endm 
# End of macro NEXTW
453a			.NUM2STR: 
453a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
453a 48				db WORD_SYS_CORE+52             
453b 49 45			dw .CONCAT            
453d 08				db 7 + 1 
453e .. 00			db "NUM2STR",0              
4546				endm 
# End of macro CWHEAD
4546			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4546			 
4546			;		; malloc a string to target 
4546			;		ld hl, 10     ; TODO max string size should be fine 
4546			;		call malloc 
4546			;		push hl    ; save malloc location 
4546			; 
4546			; 
4546			;; TODO check int type 
4546			;		FORTH_DSP_VALUEHL 
4546			;		ld a, l 
4546			;		call DispAToASCII   
4546			;;TODO need to chage above call to dump into string 
4546			; 
4546			; 
4546			 
4546				       NEXTW 
4546 c3 5a 22			jp macro_next 
4549				endm 
# End of macro NEXTW
4549			 
4549			.CONCAT: 
4549				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4549 48				db WORD_SYS_CORE+52             
454a fc 45			dw .FIND            
454c 07				db 6 + 1 
454d .. 00			db "CONCAT",0              
4554				endm 
# End of macro CWHEAD
4554			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4554			 
4554			; TODO check string type 
4554			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4554			 
4554					if DEBUG_FORTH_WORDS_KEY 
4554						DMARK "CON" 
4554 f5				push af  
4555 3a 69 45			ld a, (.dmark)  
4558 32 b4 fe			ld (debug_mark),a  
455b 3a 6a 45			ld a, (.dmark+1)  
455e 32 b5 fe			ld (debug_mark+1),a  
4561 3a 6b 45			ld a, (.dmark+2)  
4564 32 b6 fe			ld (debug_mark+2),a  
4567 18 03			jr .pastdmark  
4569 ..			.dmark: db "CON"  
456c f1			.pastdmark: pop af  
456d			endm  
# End of macro DMARK
456d						CALLMONITOR 
456d cd 78 18			call break_point_state  
4570				endm  
# End of macro CALLMONITOR
4570					endif 
4570			 
4570			 
4570					FORTH_DSP_VALUE 
4570 cd cc 20			call macro_forth_dsp_value 
4573				endm 
# End of macro FORTH_DSP_VALUE
4573 e5					push hl   ; s2 
4574			 
4574					FORTH_DSP_POP 
4574 cd 9b 21			call macro_forth_dsp_pop 
4577				endm 
# End of macro FORTH_DSP_POP
4577			 
4577					FORTH_DSP_VALUE 
4577 cd cc 20			call macro_forth_dsp_value 
457a				endm 
# End of macro FORTH_DSP_VALUE
457a			 
457a e5					push hl   ; s1 
457b			 
457b					FORTH_DSP_POP 
457b cd 9b 21			call macro_forth_dsp_pop 
457e				endm 
# End of macro FORTH_DSP_POP
457e					 
457e			 
457e					; copy s1 
457e			 
457e				 
457e					; save ptr 
457e e1					pop hl  
457f e5					push hl 
4580 3e 00				ld a, 0 
4582 cd 64 13				call strlent 
4585					;inc hl    ; zer0 
4585 06 00				ld b, 0 
4587 4d					ld c, l 
4588 e1					pop hl		 
4589 11 85 f3				ld de, scratch	 
458c					if DEBUG_FORTH_WORDS 
458c						DMARK "CO1" 
458c f5				push af  
458d 3a a1 45			ld a, (.dmark)  
4590 32 b4 fe			ld (debug_mark),a  
4593 3a a2 45			ld a, (.dmark+1)  
4596 32 b5 fe			ld (debug_mark+1),a  
4599 3a a3 45			ld a, (.dmark+2)  
459c 32 b6 fe			ld (debug_mark+2),a  
459f 18 03			jr .pastdmark  
45a1 ..			.dmark: db "CO1"  
45a4 f1			.pastdmark: pop af  
45a5			endm  
# End of macro DMARK
45a5						CALLMONITOR 
45a5 cd 78 18			call break_point_state  
45a8				endm  
# End of macro CALLMONITOR
45a8					endif 
45a8 ed b0				ldir 
45aa			 
45aa e1					pop hl 
45ab e5					push hl 
45ac d5					push de 
45ad			 
45ad			 
45ad 3e 00				ld a, 0 
45af cd 64 13				call strlent 
45b2 23					inc hl    ; zer0 
45b3 23					inc hl 
45b4 06 00				ld b, 0 
45b6 4d					ld c, l 
45b7 d1					pop de 
45b8 e1					pop hl		 
45b9					if DEBUG_FORTH_WORDS 
45b9						DMARK "CO2" 
45b9 f5				push af  
45ba 3a ce 45			ld a, (.dmark)  
45bd 32 b4 fe			ld (debug_mark),a  
45c0 3a cf 45			ld a, (.dmark+1)  
45c3 32 b5 fe			ld (debug_mark+1),a  
45c6 3a d0 45			ld a, (.dmark+2)  
45c9 32 b6 fe			ld (debug_mark+2),a  
45cc 18 03			jr .pastdmark  
45ce ..			.dmark: db "CO2"  
45d1 f1			.pastdmark: pop af  
45d2			endm  
# End of macro DMARK
45d2						CALLMONITOR 
45d2 cd 78 18			call break_point_state  
45d5				endm  
# End of macro CALLMONITOR
45d5					endif 
45d5 ed b0				ldir 
45d7			 
45d7			 
45d7			 
45d7 21 85 f3				ld hl, scratch 
45da					if DEBUG_FORTH_WORDS 
45da						DMARK "CO5" 
45da f5				push af  
45db 3a ef 45			ld a, (.dmark)  
45de 32 b4 fe			ld (debug_mark),a  
45e1 3a f0 45			ld a, (.dmark+1)  
45e4 32 b5 fe			ld (debug_mark+1),a  
45e7 3a f1 45			ld a, (.dmark+2)  
45ea 32 b6 fe			ld (debug_mark+2),a  
45ed 18 03			jr .pastdmark  
45ef ..			.dmark: db "CO5"  
45f2 f1			.pastdmark: pop af  
45f3			endm  
# End of macro DMARK
45f3						CALLMONITOR 
45f3 cd 78 18			call break_point_state  
45f6				endm  
# End of macro CALLMONITOR
45f6					endif 
45f6			 
45f6 cd 5a 1f				call forth_push_str 
45f9			 
45f9			 
45f9			 
45f9			 
45f9				       NEXTW 
45f9 c3 5a 22			jp macro_next 
45fc				endm 
# End of macro NEXTW
45fc			 
45fc			 
45fc			.FIND: 
45fc				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45fc 4b				db WORD_SYS_CORE+55             
45fd ba 46			dw .LEN            
45ff 05				db 4 + 1 
4600 .. 00			db "FIND",0              
4605				endm 
# End of macro CWHEAD
4605			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4605			 
4605					if DEBUG_FORTH_WORDS_KEY 
4605						DMARK "FND" 
4605 f5				push af  
4606 3a 1a 46			ld a, (.dmark)  
4609 32 b4 fe			ld (debug_mark),a  
460c 3a 1b 46			ld a, (.dmark+1)  
460f 32 b5 fe			ld (debug_mark+1),a  
4612 3a 1c 46			ld a, (.dmark+2)  
4615 32 b6 fe			ld (debug_mark+2),a  
4618 18 03			jr .pastdmark  
461a ..			.dmark: db "FND"  
461d f1			.pastdmark: pop af  
461e			endm  
# End of macro DMARK
461e						CALLMONITOR 
461e cd 78 18			call break_point_state  
4621				endm  
# End of macro CALLMONITOR
4621					endif 
4621			 
4621			; TODO check string type 
4621					FORTH_DSP_VALUE 
4621 cd cc 20			call macro_forth_dsp_value 
4624				endm 
# End of macro FORTH_DSP_VALUE
4624			 
4624 e5					push hl    
4625 7e					ld a,(hl)    ; char to find   
4626			; TODO change char to substr 
4626			 
4626 f5					push af 
4627					 
4627			 
4627			 
4627					if DEBUG_FORTH_WORDS 
4627						DMARK "FN1" 
4627 f5				push af  
4628 3a 3c 46			ld a, (.dmark)  
462b 32 b4 fe			ld (debug_mark),a  
462e 3a 3d 46			ld a, (.dmark+1)  
4631 32 b5 fe			ld (debug_mark+1),a  
4634 3a 3e 46			ld a, (.dmark+2)  
4637 32 b6 fe			ld (debug_mark+2),a  
463a 18 03			jr .pastdmark  
463c ..			.dmark: db "FN1"  
463f f1			.pastdmark: pop af  
4640			endm  
# End of macro DMARK
4640						CALLMONITOR 
4640 cd 78 18			call break_point_state  
4643				endm  
# End of macro CALLMONITOR
4643					endif 
4643			 
4643					FORTH_DSP_POP 
4643 cd 9b 21			call macro_forth_dsp_pop 
4646				endm 
# End of macro FORTH_DSP_POP
4646			 
4646					; string to search 
4646			 
4646					FORTH_DSP_VALUE 
4646 cd cc 20			call macro_forth_dsp_value 
4649				endm 
# End of macro FORTH_DSP_VALUE
4649			 
4649 d1					pop de  ; d is char to find  
464a			 
464a					if DEBUG_FORTH_WORDS 
464a						DMARK "FN2" 
464a f5				push af  
464b 3a 5f 46			ld a, (.dmark)  
464e 32 b4 fe			ld (debug_mark),a  
4651 3a 60 46			ld a, (.dmark+1)  
4654 32 b5 fe			ld (debug_mark+1),a  
4657 3a 61 46			ld a, (.dmark+2)  
465a 32 b6 fe			ld (debug_mark+2),a  
465d 18 03			jr .pastdmark  
465f ..			.dmark: db "FN2"  
4662 f1			.pastdmark: pop af  
4663			endm  
# End of macro DMARK
4663						CALLMONITOR 
4663 cd 78 18			call break_point_state  
4666				endm  
# End of macro CALLMONITOR
4666					endif 
4666					 
4666 01 00 00				ld bc, 0 
4669 7e			.findchar:      ld a,(hl) 
466a fe 00				cp 0   		 
466c 28 27				jr z, .finddone     
466e ba					cp d 
466f 28 20				jr z, .foundchar 
4671 03					inc bc 
4672 23					inc hl 
4673					if DEBUG_FORTH_WORDS 
4673						DMARK "FN3" 
4673 f5				push af  
4674 3a 88 46			ld a, (.dmark)  
4677 32 b4 fe			ld (debug_mark),a  
467a 3a 89 46			ld a, (.dmark+1)  
467d 32 b5 fe			ld (debug_mark+1),a  
4680 3a 8a 46			ld a, (.dmark+2)  
4683 32 b6 fe			ld (debug_mark+2),a  
4686 18 03			jr .pastdmark  
4688 ..			.dmark: db "FN3"  
468b f1			.pastdmark: pop af  
468c			endm  
# End of macro DMARK
468c						CALLMONITOR 
468c cd 78 18			call break_point_state  
468f				endm  
# End of macro CALLMONITOR
468f					endif 
468f 18 d8				jr .findchar 
4691			 
4691			 
4691 c5			.foundchar:	push bc 
4692 e1					pop hl 
4693 18 03				jr .findexit 
4695			 
4695			 
4695							 
4695			 
4695			.finddone:     ; got to end of string with no find 
4695 21 00 00				ld hl, 0 
4698			.findexit: 
4698			 
4698					if DEBUG_FORTH_WORDS 
4698						DMARK "FNd" 
4698 f5				push af  
4699 3a ad 46			ld a, (.dmark)  
469c 32 b4 fe			ld (debug_mark),a  
469f 3a ae 46			ld a, (.dmark+1)  
46a2 32 b5 fe			ld (debug_mark+1),a  
46a5 3a af 46			ld a, (.dmark+2)  
46a8 32 b6 fe			ld (debug_mark+2),a  
46ab 18 03			jr .pastdmark  
46ad ..			.dmark: db "FNd"  
46b0 f1			.pastdmark: pop af  
46b1			endm  
# End of macro DMARK
46b1						CALLMONITOR 
46b1 cd 78 18			call break_point_state  
46b4				endm  
# End of macro CALLMONITOR
46b4					endif 
46b4 cd ec 1e			call forth_push_numhl 
46b7			 
46b7				       NEXTW 
46b7 c3 5a 22			jp macro_next 
46ba				endm 
# End of macro NEXTW
46ba			 
46ba			.LEN: 
46ba				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
46ba 4c				db WORD_SYS_CORE+56             
46bb 24 47			dw .CHAR            
46bd 06				db 5 + 1 
46be .. 00			db "COUNT",0              
46c4				endm 
# End of macro CWHEAD
46c4			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46c4			 
46c4					if DEBUG_FORTH_WORDS_KEY 
46c4						DMARK "CNT" 
46c4 f5				push af  
46c5 3a d9 46			ld a, (.dmark)  
46c8 32 b4 fe			ld (debug_mark),a  
46cb 3a da 46			ld a, (.dmark+1)  
46ce 32 b5 fe			ld (debug_mark+1),a  
46d1 3a db 46			ld a, (.dmark+2)  
46d4 32 b6 fe			ld (debug_mark+2),a  
46d7 18 03			jr .pastdmark  
46d9 ..			.dmark: db "CNT"  
46dc f1			.pastdmark: pop af  
46dd			endm  
# End of macro DMARK
46dd						CALLMONITOR 
46dd cd 78 18			call break_point_state  
46e0				endm  
# End of macro CALLMONITOR
46e0					endif 
46e0			; TODO check string type 
46e0					FORTH_DSP_VALUE 
46e0 cd cc 20			call macro_forth_dsp_value 
46e3				endm 
# End of macro FORTH_DSP_VALUE
46e3			 
46e3			 
46e3					if DEBUG_FORTH_WORDS 
46e3						DMARK "CN?" 
46e3 f5				push af  
46e4 3a f8 46			ld a, (.dmark)  
46e7 32 b4 fe			ld (debug_mark),a  
46ea 3a f9 46			ld a, (.dmark+1)  
46ed 32 b5 fe			ld (debug_mark+1),a  
46f0 3a fa 46			ld a, (.dmark+2)  
46f3 32 b6 fe			ld (debug_mark+2),a  
46f6 18 03			jr .pastdmark  
46f8 ..			.dmark: db "CN?"  
46fb f1			.pastdmark: pop af  
46fc			endm  
# End of macro DMARK
46fc						CALLMONITOR 
46fc cd 78 18			call break_point_state  
46ff				endm  
# End of macro CALLMONITOR
46ff					endif 
46ff cd 59 13				call strlenz 
4702					if DEBUG_FORTH_WORDS 
4702						DMARK "CNl" 
4702 f5				push af  
4703 3a 17 47			ld a, (.dmark)  
4706 32 b4 fe			ld (debug_mark),a  
4709 3a 18 47			ld a, (.dmark+1)  
470c 32 b5 fe			ld (debug_mark+1),a  
470f 3a 19 47			ld a, (.dmark+2)  
4712 32 b6 fe			ld (debug_mark+2),a  
4715 18 03			jr .pastdmark  
4717 ..			.dmark: db "CNl"  
471a f1			.pastdmark: pop af  
471b			endm  
# End of macro DMARK
471b						CALLMONITOR 
471b cd 78 18			call break_point_state  
471e				endm  
# End of macro CALLMONITOR
471e					endif 
471e			 
471e cd ec 1e				call forth_push_numhl 
4721			 
4721			 
4721			 
4721				       NEXTW 
4721 c3 5a 22			jp macro_next 
4724				endm 
# End of macro NEXTW
4724			.CHAR: 
4724				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4724 4d				db WORD_SYS_CORE+57             
4725 5a 47			dw .ENDSTR            
4727 05				db 4 + 1 
4728 .. 00			db "CHAR",0              
472d				endm 
# End of macro CWHEAD
472d			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
472d					if DEBUG_FORTH_WORDS_KEY 
472d						DMARK "CHR" 
472d f5				push af  
472e 3a 42 47			ld a, (.dmark)  
4731 32 b4 fe			ld (debug_mark),a  
4734 3a 43 47			ld a, (.dmark+1)  
4737 32 b5 fe			ld (debug_mark+1),a  
473a 3a 44 47			ld a, (.dmark+2)  
473d 32 b6 fe			ld (debug_mark+2),a  
4740 18 03			jr .pastdmark  
4742 ..			.dmark: db "CHR"  
4745 f1			.pastdmark: pop af  
4746			endm  
# End of macro DMARK
4746						CALLMONITOR 
4746 cd 78 18			call break_point_state  
4749				endm  
# End of macro CALLMONITOR
4749					endif 
4749					FORTH_DSP 
4749 cd a9 20			call macro_forth_dsp 
474c				endm 
# End of macro FORTH_DSP
474c					;v5 FORTH_DSP_VALUE 
474c 23					inc hl      ; now at start of numeric as string 
474d			 
474d			;		push hl 
474d			 
474d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
474d cd 9b 21			call macro_forth_dsp_pop 
4750				endm 
# End of macro FORTH_DSP_POP
4750			 
4750			;		pop hl 
4750			 
4750					; push the content of a onto the stack as a value 
4750			 
4750 7e					ld a,(hl)   ; get char 
4751 26 00				ld h,0 
4753 6f					ld l,a 
4754 cd ec 1e				call forth_push_numhl 
4757			 
4757				       NEXTW 
4757 c3 5a 22			jp macro_next 
475a				endm 
# End of macro NEXTW
475a			 
475a			 
475a			 
475a			 
475a			.ENDSTR: 
475a			; eof 
475a			 
# End of file forth_words_str.asm
475a			include "forth_words_key.asm" 
475a			 
475a			; | ## Keyboard Words 
475a			 
475a			.KEY: 
475a				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
475a 3e				db WORD_SYS_CORE+42             
475b 8a 47			dw .WAITK            
475d 04				db 3 + 1 
475e .. 00			db "KEY",0              
4762				endm 
# End of macro CWHEAD
4762			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4762			 
4762					if DEBUG_FORTH_WORDS_KEY 
4762						DMARK "KEY" 
4762 f5				push af  
4763 3a 77 47			ld a, (.dmark)  
4766 32 b4 fe			ld (debug_mark),a  
4769 3a 78 47			ld a, (.dmark+1)  
476c 32 b5 fe			ld (debug_mark+1),a  
476f 3a 79 47			ld a, (.dmark+2)  
4772 32 b6 fe			ld (debug_mark+2),a  
4775 18 03			jr .pastdmark  
4777 ..			.dmark: db "KEY"  
477a f1			.pastdmark: pop af  
477b			endm  
# End of macro DMARK
477b						CALLMONITOR 
477b cd 78 18			call break_point_state  
477e				endm  
# End of macro CALLMONITOR
477e					endif 
477e			; TODO currently waits 
477e cd 35 6b				call cin 
4781					;call cin_wait 
4781 6f					ld l, a 
4782 26 00				ld h, 0 
4784 cd ec 1e				call forth_push_numhl 
4787					NEXTW 
4787 c3 5a 22			jp macro_next 
478a				endm 
# End of macro NEXTW
478a			.WAITK: 
478a				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
478a 3f				db WORD_SYS_CORE+43             
478b bc 47			dw .ACCEPT            
478d 06				db 5 + 1 
478e .. 00			db "WAITK",0              
4794				endm 
# End of macro CWHEAD
4794			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4794					if DEBUG_FORTH_WORDS_KEY 
4794						DMARK "WAI" 
4794 f5				push af  
4795 3a a9 47			ld a, (.dmark)  
4798 32 b4 fe			ld (debug_mark),a  
479b 3a aa 47			ld a, (.dmark+1)  
479e 32 b5 fe			ld (debug_mark+1),a  
47a1 3a ab 47			ld a, (.dmark+2)  
47a4 32 b6 fe			ld (debug_mark+2),a  
47a7 18 03			jr .pastdmark  
47a9 ..			.dmark: db "WAI"  
47ac f1			.pastdmark: pop af  
47ad			endm  
# End of macro DMARK
47ad						CALLMONITOR 
47ad cd 78 18			call break_point_state  
47b0				endm  
# End of macro CALLMONITOR
47b0					endif 
47b0 cd 24 6b				call cin_wait 
47b3 6f					ld l, a 
47b4 26 00				ld h, 0 
47b6 cd ec 1e				call forth_push_numhl 
47b9					NEXTW 
47b9 c3 5a 22			jp macro_next 
47bc				endm 
# End of macro NEXTW
47bc			.ACCEPT: 
47bc				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47bc 40				db WORD_SYS_CORE+44             
47bd 1a 48			dw .EDIT            
47bf 07				db 6 + 1 
47c0 .. 00			db "ACCEPT",0              
47c7				endm 
# End of macro CWHEAD
47c7			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47c7					; TODO crashes on push 
47c7					if DEBUG_FORTH_WORDS_KEY 
47c7						DMARK "ACC" 
47c7 f5				push af  
47c8 3a dc 47			ld a, (.dmark)  
47cb 32 b4 fe			ld (debug_mark),a  
47ce 3a dd 47			ld a, (.dmark+1)  
47d1 32 b5 fe			ld (debug_mark+1),a  
47d4 3a de 47			ld a, (.dmark+2)  
47d7 32 b6 fe			ld (debug_mark+2),a  
47da 18 03			jr .pastdmark  
47dc ..			.dmark: db "ACC"  
47df f1			.pastdmark: pop af  
47e0			endm  
# End of macro DMARK
47e0						CALLMONITOR 
47e0 cd 78 18			call break_point_state  
47e3				endm  
# End of macro CALLMONITOR
47e3					endif 
47e3 21 83 f5				ld hl, os_input 
47e6 3e 00				ld a, 0 
47e8 77					ld (hl),a 
47e9 3a ee fb				ld a,(f_cursor_ptr) 
47ec 16 64				ld d, 100 
47ee 0e 00				ld c, 0 
47f0 1e 28				ld e, 40 
47f2 cd 28 0f				call input_str 
47f5					; TODO perhaps do a type check and wrap in quotes if not a number 
47f5 21 83 f5				ld hl, os_input 
47f8					if DEBUG_FORTH_WORDS 
47f8						DMARK "AC1" 
47f8 f5				push af  
47f9 3a 0d 48			ld a, (.dmark)  
47fc 32 b4 fe			ld (debug_mark),a  
47ff 3a 0e 48			ld a, (.dmark+1)  
4802 32 b5 fe			ld (debug_mark+1),a  
4805 3a 0f 48			ld a, (.dmark+2)  
4808 32 b6 fe			ld (debug_mark+2),a  
480b 18 03			jr .pastdmark  
480d ..			.dmark: db "AC1"  
4810 f1			.pastdmark: pop af  
4811			endm  
# End of macro DMARK
4811						CALLMONITOR 
4811 cd 78 18			call break_point_state  
4814				endm  
# End of macro CALLMONITOR
4814					endif 
4814 cd 5a 1f				call forth_push_str 
4817					NEXTW 
4817 c3 5a 22			jp macro_next 
481a				endm 
# End of macro NEXTW
481a			 
481a			.EDIT: 
481a				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
481a 40				db WORD_SYS_CORE+44             
481b bc 48			dw .ENDKEY            
481d 05				db 4 + 1 
481e .. 00			db "EDIT",0              
4823				endm 
# End of macro CWHEAD
4823			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4823			 
4823					; TODO does not copy from stack 
4823					if DEBUG_FORTH_WORDS_KEY 
4823						DMARK "EDT" 
4823 f5				push af  
4824 3a 38 48			ld a, (.dmark)  
4827 32 b4 fe			ld (debug_mark),a  
482a 3a 39 48			ld a, (.dmark+1)  
482d 32 b5 fe			ld (debug_mark+1),a  
4830 3a 3a 48			ld a, (.dmark+2)  
4833 32 b6 fe			ld (debug_mark+2),a  
4836 18 03			jr .pastdmark  
4838 ..			.dmark: db "EDT"  
483b f1			.pastdmark: pop af  
483c			endm  
# End of macro DMARK
483c						CALLMONITOR 
483c cd 78 18			call break_point_state  
483f				endm  
# End of macro CALLMONITOR
483f					endif 
483f			 
483f					;FORTH_DSP 
483f					FORTH_DSP_VALUEHL 
483f cd e3 20			call macro_dsp_valuehl 
4842				endm 
# End of macro FORTH_DSP_VALUEHL
4842			;		inc hl    ; TODO do type check 
4842			 
4842			;		call get_word_hl 
4842 e5					push hl 
4843					if DEBUG_FORTH_WORDS 
4843						DMARK "EDp" 
4843 f5				push af  
4844 3a 58 48			ld a, (.dmark)  
4847 32 b4 fe			ld (debug_mark),a  
484a 3a 59 48			ld a, (.dmark+1)  
484d 32 b5 fe			ld (debug_mark+1),a  
4850 3a 5a 48			ld a, (.dmark+2)  
4853 32 b6 fe			ld (debug_mark+2),a  
4856 18 03			jr .pastdmark  
4858 ..			.dmark: db "EDp"  
485b f1			.pastdmark: pop af  
485c			endm  
# End of macro DMARK
485c						CALLMONITOR 
485c cd 78 18			call break_point_state  
485f				endm  
# End of macro CALLMONITOR
485f					endif 
485f				;	ld a, 0 
485f cd 59 13				call strlenz 
4862 23					inc hl 
4863			 
4863 06 00				ld b, 0 
4865 4d					ld c, l 
4866			 
4866 e1					pop hl 
4867 11 83 f5				ld de, os_input 
486a					if DEBUG_FORTH_WORDS_KEY 
486a						DMARK "EDc" 
486a f5				push af  
486b 3a 7f 48			ld a, (.dmark)  
486e 32 b4 fe			ld (debug_mark),a  
4871 3a 80 48			ld a, (.dmark+1)  
4874 32 b5 fe			ld (debug_mark+1),a  
4877 3a 81 48			ld a, (.dmark+2)  
487a 32 b6 fe			ld (debug_mark+2),a  
487d 18 03			jr .pastdmark  
487f ..			.dmark: db "EDc"  
4882 f1			.pastdmark: pop af  
4883			endm  
# End of macro DMARK
4883						CALLMONITOR 
4883 cd 78 18			call break_point_state  
4886				endm  
# End of macro CALLMONITOR
4886					endif 
4886 ed b0				ldir 
4888			 
4888			 
4888 21 83 f5				ld hl, os_input 
488b					;ld a, 0 
488b					;ld (hl),a 
488b 3a ee fb				ld a,(f_cursor_ptr) 
488e 16 64				ld d, 100 
4890 0e 00				ld c, 0 
4892 1e 28				ld e, 40 
4894 cd 28 0f				call input_str 
4897					; TODO perhaps do a type check and wrap in quotes if not a number 
4897 21 83 f5				ld hl, os_input 
489a					if DEBUG_FORTH_WORDS 
489a						DMARK "ED1" 
489a f5				push af  
489b 3a af 48			ld a, (.dmark)  
489e 32 b4 fe			ld (debug_mark),a  
48a1 3a b0 48			ld a, (.dmark+1)  
48a4 32 b5 fe			ld (debug_mark+1),a  
48a7 3a b1 48			ld a, (.dmark+2)  
48aa 32 b6 fe			ld (debug_mark+2),a  
48ad 18 03			jr .pastdmark  
48af ..			.dmark: db "ED1"  
48b2 f1			.pastdmark: pop af  
48b3			endm  
# End of macro DMARK
48b3						CALLMONITOR 
48b3 cd 78 18			call break_point_state  
48b6				endm  
# End of macro CALLMONITOR
48b6					endif 
48b6 cd 5a 1f				call forth_push_str 
48b9					NEXTW 
48b9 c3 5a 22			jp macro_next 
48bc				endm 
# End of macro NEXTW
48bc			 
48bc			 
48bc			 
48bc			.ENDKEY: 
48bc			; eof 
48bc			 
# End of file forth_words_key.asm
48bc			 
48bc			if STORAGE_SE 
48bc			   	include "forth_words_storage.asm" 
48bc			 
48bc			; | ## Fixed Storage Words 
48bc			 
48bc			.RECORD: 
48bc			  
48bc				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
48bc 3a				db WORD_SYS_CORE+38             
48bd 60 49			dw .BREAD            
48bf 07				db 6 + 1 
48c0 .. 00			db "RECORD",0              
48c7				endm 
# End of macro CWHEAD
48c7			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
48c7			 
48c7					if DEBUG_FORTH_WORDS_KEY 
48c7						DMARK "REC" 
48c7 f5				push af  
48c8 3a dc 48			ld a, (.dmark)  
48cb 32 b4 fe			ld (debug_mark),a  
48ce 3a dd 48			ld a, (.dmark+1)  
48d1 32 b5 fe			ld (debug_mark+1),a  
48d4 3a de 48			ld a, (.dmark+2)  
48d7 32 b6 fe			ld (debug_mark+2),a  
48da 18 03			jr .pastdmark  
48dc ..			.dmark: db "REC"  
48df f1			.pastdmark: pop af  
48e0			endm  
# End of macro DMARK
48e0						CALLMONITOR 
48e0 cd 78 18			call break_point_state  
48e3				endm  
# End of macro CALLMONITOR
48e3					endif 
48e3			 
48e3					FORTH_DSP_VALUEHL 
48e3 cd e3 20			call macro_dsp_valuehl 
48e6				endm 
# End of macro FORTH_DSP_VALUEHL
48e6			 
48e6 e5					push hl    ; id 
48e7			 
48e7					FORTH_DSP_POP 
48e7 cd 9b 21			call macro_forth_dsp_pop 
48ea				endm 
# End of macro FORTH_DSP_POP
48ea			 
48ea					FORTH_DSP_VALUEHL 
48ea cd e3 20			call macro_dsp_valuehl 
48ed				endm 
# End of macro FORTH_DSP_VALUEHL
48ed			 
48ed					FORTH_DSP_POP 
48ed cd 9b 21			call macro_forth_dsp_pop 
48f0				endm 
# End of macro FORTH_DSP_POP
48f0			 
48f0 d1					pop de     ; get file id 
48f1			 
48f1					; e = file id 
48f1					; l = file extent 
48f1			 
48f1			 
48f1					; construct request to access file extent 
48f1			 
48f1			;		ld a, e 
48f1 63					ld h, e 
48f2					 
48f2					 
48f2					 
48f2			 
48f2					; e has id 
48f2			 
48f2 11 07 fc			ld de, store_page 
48f5					if DEBUG_FORTH_WORDS 
48f5						DMARK "REr" 
48f5 f5				push af  
48f6 3a 0a 49			ld a, (.dmark)  
48f9 32 b4 fe			ld (debug_mark),a  
48fc 3a 0b 49			ld a, (.dmark+1)  
48ff 32 b5 fe			ld (debug_mark+1),a  
4902 3a 0c 49			ld a, (.dmark+2)  
4905 32 b6 fe			ld (debug_mark+2),a  
4908 18 03			jr .pastdmark  
490a ..			.dmark: db "REr"  
490d f1			.pastdmark: pop af  
490e			endm  
# End of macro DMARK
490e						CALLMONITOR 
490e cd 78 18			call break_point_state  
4911				endm  
# End of macro CALLMONITOR
4911					endif 
4911 cd 2a 09				call storage_read 
4914 cd 24 0f			call ishlzero 
4917 28 22			jr z, .recnotfound 
4919			 
4919			 
4919					if DEBUG_FORTH_WORDS 
4919						DMARK "REe" 
4919 f5				push af  
491a 3a 2e 49			ld a, (.dmark)  
491d 32 b4 fe			ld (debug_mark),a  
4920 3a 2f 49			ld a, (.dmark+1)  
4923 32 b5 fe			ld (debug_mark+1),a  
4926 3a 30 49			ld a, (.dmark+2)  
4929 32 b6 fe			ld (debug_mark+2),a  
492c 18 03			jr .pastdmark  
492e ..			.dmark: db "REe"  
4931 f1			.pastdmark: pop af  
4932			endm  
# End of macro DMARK
4932						CALLMONITOR 
4932 cd 78 18			call break_point_state  
4935				endm  
# End of macro CALLMONITOR
4935					endif 
4935 cd 5a 1f			call forth_push_str 
4938			 
4938					NEXTW 
4938 c3 5a 22			jp macro_next 
493b				endm 
# End of macro NEXTW
493b			 
493b			.recnotfound: 
493b					if DEBUG_FORTH_WORDS 
493b						DMARK "REf" 
493b f5				push af  
493c 3a 50 49			ld a, (.dmark)  
493f 32 b4 fe			ld (debug_mark),a  
4942 3a 51 49			ld a, (.dmark+1)  
4945 32 b5 fe			ld (debug_mark+1),a  
4948 3a 52 49			ld a, (.dmark+2)  
494b 32 b6 fe			ld (debug_mark+2),a  
494e 18 03			jr .pastdmark  
4950 ..			.dmark: db "REf"  
4953 f1			.pastdmark: pop af  
4954			endm  
# End of macro DMARK
4954						CALLMONITOR 
4954 cd 78 18			call break_point_state  
4957				endm  
# End of macro CALLMONITOR
4957					endif 
4957 21 ff 00			ld hl, 255 
495a cd ec 1e			call forth_push_numhl 
495d				NEXTW 
495d c3 5a 22			jp macro_next 
4960				endm 
# End of macro NEXTW
4960			 
4960			 
4960			.BREAD: 
4960			  
4960				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4960 3a				db WORD_SYS_CORE+38             
4961 e3 49			dw .BWRITE            
4963 06				db 5 + 1 
4964 .. 00			db "BREAD",0              
496a				endm 
# End of macro CWHEAD
496a			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
496a				 
496a					if DEBUG_FORTH_WORDS_KEY 
496a						DMARK "BRD" 
496a f5				push af  
496b 3a 7f 49			ld a, (.dmark)  
496e 32 b4 fe			ld (debug_mark),a  
4971 3a 80 49			ld a, (.dmark+1)  
4974 32 b5 fe			ld (debug_mark+1),a  
4977 3a 81 49			ld a, (.dmark+2)  
497a 32 b6 fe			ld (debug_mark+2),a  
497d 18 03			jr .pastdmark  
497f ..			.dmark: db "BRD"  
4982 f1			.pastdmark: pop af  
4983			endm  
# End of macro DMARK
4983						CALLMONITOR 
4983 cd 78 18			call break_point_state  
4986				endm  
# End of macro CALLMONITOR
4986					endif 
4986			 
4986				FORTH_DSP_VALUEHL 
4986 cd e3 20			call macro_dsp_valuehl 
4989				endm 
# End of macro FORTH_DSP_VALUEHL
4989			 
4989				FORTH_DSP_POP 
4989 cd 9b 21			call macro_forth_dsp_pop 
498c				endm 
# End of macro FORTH_DSP_POP
498c			 
498c				; calc block address 
498c			 
498c eb				ex de, hl 
498d 3e 40			ld a, STORE_BLOCK_PHY 
498f cd 7e 0e			call Mult16 
4992			 
4992			 
4992 11 07 fc			ld de, store_page 
4995			 
4995					if DEBUG_FORTH_WORDS 
4995						DMARK "BR1" 
4995 f5				push af  
4996 3a aa 49			ld a, (.dmark)  
4999 32 b4 fe			ld (debug_mark),a  
499c 3a ab 49			ld a, (.dmark+1)  
499f 32 b5 fe			ld (debug_mark+1),a  
49a2 3a ac 49			ld a, (.dmark+2)  
49a5 32 b6 fe			ld (debug_mark+2),a  
49a8 18 03			jr .pastdmark  
49aa ..			.dmark: db "BR1"  
49ad f1			.pastdmark: pop af  
49ae			endm  
# End of macro DMARK
49ae						CALLMONITOR 
49ae cd 78 18			call break_point_state  
49b1				endm  
# End of macro CALLMONITOR
49b1					endif 
49b1			 
49b1 cd d1 03			call storage_read_block 
49b4			 
49b4 cd 24 0f			call ishlzero 
49b7 20 05			jr nz, .brfound 
49b9			 
49b9 cd ec 1e			call forth_push_numhl 
49bc 18 22			jr .brdone 
49be			 
49be			 
49be			.brfound: 
49be 21 09 fc		        ld hl, store_page+2 
49c1			 
49c1					if DEBUG_FORTH_WORDS 
49c1						DMARK "BR2" 
49c1 f5				push af  
49c2 3a d6 49			ld a, (.dmark)  
49c5 32 b4 fe			ld (debug_mark),a  
49c8 3a d7 49			ld a, (.dmark+1)  
49cb 32 b5 fe			ld (debug_mark+1),a  
49ce 3a d8 49			ld a, (.dmark+2)  
49d1 32 b6 fe			ld (debug_mark+2),a  
49d4 18 03			jr .pastdmark  
49d6 ..			.dmark: db "BR2"  
49d9 f1			.pastdmark: pop af  
49da			endm  
# End of macro DMARK
49da						CALLMONITOR 
49da cd 78 18			call break_point_state  
49dd				endm  
# End of macro CALLMONITOR
49dd					endif 
49dd			 
49dd cd 5a 1f			call forth_push_str 
49e0			 
49e0			 
49e0			.brdone: 
49e0			 
49e0					NEXTW 
49e0 c3 5a 22			jp macro_next 
49e3				endm 
# End of macro NEXTW
49e3			.BWRITE: 
49e3				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
49e3 3a				db WORD_SYS_CORE+38             
49e4 78 4a			dw .BUPD            
49e6 07				db 6 + 1 
49e7 .. 00			db "BWRITE",0              
49ee				endm 
# End of macro CWHEAD
49ee			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
49ee			 
49ee					if DEBUG_FORTH_WORDS_KEY 
49ee						DMARK "BWR" 
49ee f5				push af  
49ef 3a 03 4a			ld a, (.dmark)  
49f2 32 b4 fe			ld (debug_mark),a  
49f5 3a 04 4a			ld a, (.dmark+1)  
49f8 32 b5 fe			ld (debug_mark+1),a  
49fb 3a 05 4a			ld a, (.dmark+2)  
49fe 32 b6 fe			ld (debug_mark+2),a  
4a01 18 03			jr .pastdmark  
4a03 ..			.dmark: db "BWR"  
4a06 f1			.pastdmark: pop af  
4a07			endm  
# End of macro DMARK
4a07						CALLMONITOR 
4a07 cd 78 18			call break_point_state  
4a0a				endm  
# End of macro CALLMONITOR
4a0a					endif 
4a0a			 
4a0a				FORTH_DSP_VALUEHL 
4a0a cd e3 20			call macro_dsp_valuehl 
4a0d				endm 
# End of macro FORTH_DSP_VALUEHL
4a0d			 
4a0d				; calc block address 
4a0d			 
4a0d eb				ex de, hl 
4a0e 3e 40			ld a, STORE_BLOCK_PHY 
4a10 cd 7e 0e			call Mult16 
4a13			 
4a13 e5				push hl         ; address 
4a14			 
4a14				FORTH_DSP_POP 
4a14 cd 9b 21			call macro_forth_dsp_pop 
4a17				endm 
# End of macro FORTH_DSP_POP
4a17			 
4a17				FORTH_DSP_VALUEHL 
4a17 cd e3 20			call macro_dsp_valuehl 
4a1a				endm 
# End of macro FORTH_DSP_VALUEHL
4a1a			 
4a1a				FORTH_DSP_POP 
4a1a cd 9b 21			call macro_forth_dsp_pop 
4a1d				endm 
# End of macro FORTH_DSP_POP
4a1d			 
4a1d cd 07 0c			call storage_clear_page 
4a20			 
4a20				; copy string to store page 
4a20			 
4a20 e5				push hl     ; save string address 
4a21			 
4a21 3e 00			ld a, 0 
4a23 cd 64 13			call strlent 
4a26			 
4a26 23				inc hl 
4a27			 
4a27 4d				ld c, l 
4a28 06 00			ld b, 0 
4a2a			 
4a2a e1				pop hl 
4a2b 11 09 fc			ld de, store_page + 2 
4a2e					if DEBUG_FORTH_WORDS 
4a2e						DMARK "BW1" 
4a2e f5				push af  
4a2f 3a 43 4a			ld a, (.dmark)  
4a32 32 b4 fe			ld (debug_mark),a  
4a35 3a 44 4a			ld a, (.dmark+1)  
4a38 32 b5 fe			ld (debug_mark+1),a  
4a3b 3a 45 4a			ld a, (.dmark+2)  
4a3e 32 b6 fe			ld (debug_mark+2),a  
4a41 18 03			jr .pastdmark  
4a43 ..			.dmark: db "BW1"  
4a46 f1			.pastdmark: pop af  
4a47			endm  
# End of macro DMARK
4a47						CALLMONITOR 
4a47 cd 78 18			call break_point_state  
4a4a				endm  
# End of macro CALLMONITOR
4a4a					endif 
4a4a ed b0			ldir 
4a4c			 
4a4c			 
4a4c				; poke the start of the block with flags to prevent high level file ops hitting the block 
4a4c			 
4a4c 21 ff ff			ld hl, $ffff 
4a4f			 
4a4f 22 07 fc			ld (store_page), hl	 
4a52				 
4a52 e1				pop hl    ; get address 
4a53 11 07 fc			ld de, store_page 
4a56			 
4a56					if DEBUG_FORTH_WORDS 
4a56						DMARK "BW2" 
4a56 f5				push af  
4a57 3a 6b 4a			ld a, (.dmark)  
4a5a 32 b4 fe			ld (debug_mark),a  
4a5d 3a 6c 4a			ld a, (.dmark+1)  
4a60 32 b5 fe			ld (debug_mark+1),a  
4a63 3a 6d 4a			ld a, (.dmark+2)  
4a66 32 b6 fe			ld (debug_mark+2),a  
4a69 18 03			jr .pastdmark  
4a6b ..			.dmark: db "BW2"  
4a6e f1			.pastdmark: pop af  
4a6f			endm  
# End of macro DMARK
4a6f						CALLMONITOR 
4a6f cd 78 18			call break_point_state  
4a72				endm  
# End of macro CALLMONITOR
4a72					endif 
4a72			 
4a72 cd 36 04			call storage_write_block 
4a75			 
4a75					NEXTW 
4a75 c3 5a 22			jp macro_next 
4a78				endm 
# End of macro NEXTW
4a78			 
4a78			.BUPD: 
4a78				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4a78 3a				db WORD_SYS_CORE+38             
4a79 ce 4a			dw .BYID            
4a7b 05				db 4 + 1 
4a7c .. 00			db "BUPD",0              
4a81				endm 
# End of macro CWHEAD
4a81			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4a81			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4a81			; | | or completely different file system structure. 
4a81			 
4a81					if DEBUG_FORTH_WORDS_KEY 
4a81						DMARK "BUD" 
4a81 f5				push af  
4a82 3a 96 4a			ld a, (.dmark)  
4a85 32 b4 fe			ld (debug_mark),a  
4a88 3a 97 4a			ld a, (.dmark+1)  
4a8b 32 b5 fe			ld (debug_mark+1),a  
4a8e 3a 98 4a			ld a, (.dmark+2)  
4a91 32 b6 fe			ld (debug_mark+2),a  
4a94 18 03			jr .pastdmark  
4a96 ..			.dmark: db "BUD"  
4a99 f1			.pastdmark: pop af  
4a9a			endm  
# End of macro DMARK
4a9a						CALLMONITOR 
4a9a cd 78 18			call break_point_state  
4a9d				endm  
# End of macro CALLMONITOR
4a9d					endif 
4a9d			 
4a9d				FORTH_DSP_VALUEHL 
4a9d cd e3 20			call macro_dsp_valuehl 
4aa0				endm 
# End of macro FORTH_DSP_VALUEHL
4aa0			 
4aa0				; calc block address 
4aa0			 
4aa0 eb				ex de, hl 
4aa1 3e 40			ld a, STORE_BLOCK_PHY 
4aa3 cd 7e 0e			call Mult16 
4aa6			 
4aa6				FORTH_DSP_POP 
4aa6 cd 9b 21			call macro_forth_dsp_pop 
4aa9				endm 
# End of macro FORTH_DSP_POP
4aa9			 
4aa9			 
4aa9 11 07 fc			ld de, store_page 
4aac			 
4aac					if DEBUG_FORTH_WORDS 
4aac						DMARK "BUe" 
4aac f5				push af  
4aad 3a c1 4a			ld a, (.dmark)  
4ab0 32 b4 fe			ld (debug_mark),a  
4ab3 3a c2 4a			ld a, (.dmark+1)  
4ab6 32 b5 fe			ld (debug_mark+1),a  
4ab9 3a c3 4a			ld a, (.dmark+2)  
4abc 32 b6 fe			ld (debug_mark+2),a  
4abf 18 03			jr .pastdmark  
4ac1 ..			.dmark: db "BUe"  
4ac4 f1			.pastdmark: pop af  
4ac5			endm  
# End of macro DMARK
4ac5						CALLMONITOR 
4ac5 cd 78 18			call break_point_state  
4ac8				endm  
# End of macro CALLMONITOR
4ac8					endif 
4ac8			 
4ac8 cd 36 04			call storage_write_block 
4acb			 
4acb					NEXTW 
4acb c3 5a 22			jp macro_next 
4ace				endm 
# End of macro NEXTW
4ace			 
4ace			.BYID: 
4ace			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4ace			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4ace			; 
4ace			;		 
4ace			;		if DEBUG_FORTH_WORDS_KEY 
4ace			;			DMARK "BYID" 
4ace			;			CALLMONITOR 
4ace			;		endif 
4ace			; 
4ace			;		; get direct address 
4ace			; 
4ace			;		FORTH_DSP_VALUEHL 
4ace			; 
4ace			;		FORTH_DSP_POP 
4ace			; 
4ace			;	; calc block address 
4ace			; 
4ace			;	ex de, hl 
4ace			;	ld a, STORE_BLOCK_PHY 
4ace			;	call Mult16 
4ace			;	;	do BREAD with number as param 
4ace			;	; push the file name	 
4ace			;	ld de, store_page 
4ace			;	call storage_read_block 
4ace			 ;       ld hl, store_page+2 
4ace			; 
4ace			; 
4ace			;		NEXTW 
4ace			;.BYNAME: 
4ace				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4ace 3a				db WORD_SYS_CORE+38             
4acf e7 4a			dw .DIR            
4ad1 06				db 5 + 1 
4ad2 .. 00			db "GETID",0              
4ad8				endm 
# End of macro CWHEAD
4ad8			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4ad8			 
4ad8					; get pointer to file name to seek 
4ad8			 
4ad8					FORTH_DSP_VALUEHL 
4ad8 cd e3 20			call macro_dsp_valuehl 
4adb				endm 
# End of macro FORTH_DSP_VALUEHL
4adb			 
4adb			 
4adb cd f8 02				call storage_getid  
4ade			 
4ade					FORTH_DSP_POP 
4ade cd 9b 21			call macro_forth_dsp_pop 
4ae1				endm 
# End of macro FORTH_DSP_POP
4ae1			 
4ae1 cd ec 1e				call forth_push_numhl 
4ae4			 
4ae4					NEXTW 
4ae4 c3 5a 22			jp macro_next 
4ae7				endm 
# End of macro NEXTW
4ae7			; 
4ae7			.DIR: 
4ae7				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4ae7 3a				db WORD_SYS_CORE+38             
4ae8 eb 4b			dw .SAVE            
4aea 04				db 3 + 1 
4aeb .. 00			db "DIR",0              
4aef				endm 
# End of macro CWHEAD
4aef			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4aef			 
4aef					if DEBUG_FORTH_WORDS_KEY 
4aef						DMARK "DIR" 
4aef f5				push af  
4af0 3a 04 4b			ld a, (.dmark)  
4af3 32 b4 fe			ld (debug_mark),a  
4af6 3a 05 4b			ld a, (.dmark+1)  
4af9 32 b5 fe			ld (debug_mark+1),a  
4afc 3a 06 4b			ld a, (.dmark+2)  
4aff 32 b6 fe			ld (debug_mark+2),a  
4b02 18 03			jr .pastdmark  
4b04 ..			.dmark: db "DIR"  
4b07 f1			.pastdmark: pop af  
4b08			endm  
# End of macro DMARK
4b08						CALLMONITOR 
4b08 cd 78 18			call break_point_state  
4b0b				endm  
# End of macro CALLMONITOR
4b0b					endif 
4b0b cd 82 04			call storage_get_block_0 
4b0e			 
4b0e 21 07 fc			ld hl, store_page     ; get current id count 
4b11 46				ld b, (hl) 
4b12 0e 00			ld c, 0    ; count of files   
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "DI1" 
4b14 f5				push af  
4b15 3a 29 4b			ld a, (.dmark)  
4b18 32 b4 fe			ld (debug_mark),a  
4b1b 3a 2a 4b			ld a, (.dmark+1)  
4b1e 32 b5 fe			ld (debug_mark+1),a  
4b21 3a 2b 4b			ld a, (.dmark+2)  
4b24 32 b6 fe			ld (debug_mark+2),a  
4b27 18 03			jr .pastdmark  
4b29 ..			.dmark: db "DI1"  
4b2c f1			.pastdmark: pop af  
4b2d			endm  
# End of macro DMARK
4b2d						CALLMONITOR 
4b2d cd 78 18			call break_point_state  
4b30				endm  
# End of macro CALLMONITOR
4b30					endif 
4b30			 
4b30				; check for empty drive 
4b30			 
4b30 3e 00			ld a, 0 
4b32 b8				cp b 
4b33 ca a1 4b			jp z, .dirdone 
4b36			 
4b36				; for each of the current ids do a search for them and if found push to stack 
4b36			 
4b36 c5			.diritem:	push bc 
4b37 21 40 00				ld hl, STORE_BLOCK_PHY 
4b3a 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4b3c 58					ld e,b 
4b3d			 
4b3d			;		if DEBUG_FORTH_WORDS 
4b3d			;			DMARK "DI2" 
4b3d			;			CALLMONITOR 
4b3d			;		endif 
4b3d			 
4b3d cd 04 07				call storage_findnextid 
4b40			 
4b40			;		if DEBUG_FORTH_WORDS 
4b40			;			DMARK "DI3" 
4b40			;			CALLMONITOR 
4b40			;		endif 
4b40			 
4b40					; if found hl will be non zero 
4b40			 
4b40 cd 24 0f				call ishlzero 
4b43			;		ld a, l 
4b43			;		add h 
4b43			; 
4b43			;		cp 0 
4b43 28 59				jr z, .dirnotfound 
4b45			 
4b45					; increase count 
4b45			 
4b45 c1					pop bc	 
4b46 0c					inc c 
4b47 c5					push bc 
4b48					 
4b48			 
4b48					; get file header and push the file name 
4b48			 
4b48 11 07 fc				ld de, store_page 
4b4b cd d1 03				call storage_read_block 
4b4e			 
4b4e					; push file id to stack 
4b4e				 
4b4e 3a 07 fc				ld a, (store_page) 
4b51 26 00				ld h, 0 
4b53 6f					ld l, a 
4b54 cd ec 1e				call forth_push_numhl 
4b57			 
4b57					; push extent count to stack  
4b57				 
4b57 3a 09 fc				ld a, (store_page+2) 
4b5a 26 00				ld h, 0 
4b5c 6f					ld l, a 
4b5d cd ec 1e				call forth_push_numhl 
4b60			 
4b60					; push file name 
4b60			 
4b60 21 0a fc				ld hl, store_page+3 
4b63					if DEBUG_FORTH_WORDS 
4b63						DMARK "DI5" 
4b63 f5				push af  
4b64 3a 78 4b			ld a, (.dmark)  
4b67 32 b4 fe			ld (debug_mark),a  
4b6a 3a 79 4b			ld a, (.dmark+1)  
4b6d 32 b5 fe			ld (debug_mark+1),a  
4b70 3a 7a 4b			ld a, (.dmark+2)  
4b73 32 b6 fe			ld (debug_mark+2),a  
4b76 18 03			jr .pastdmark  
4b78 ..			.dmark: db "DI5"  
4b7b f1			.pastdmark: pop af  
4b7c			endm  
# End of macro DMARK
4b7c						CALLMONITOR 
4b7c cd 78 18			call break_point_state  
4b7f				endm  
# End of macro CALLMONITOR
4b7f					endif 
4b7f cd 5a 1f				call forth_push_str 
4b82					if DEBUG_FORTH_WORDS 
4b82						DMARK "DI6" 
4b82 f5				push af  
4b83 3a 97 4b			ld a, (.dmark)  
4b86 32 b4 fe			ld (debug_mark),a  
4b89 3a 98 4b			ld a, (.dmark+1)  
4b8c 32 b5 fe			ld (debug_mark+1),a  
4b8f 3a 99 4b			ld a, (.dmark+2)  
4b92 32 b6 fe			ld (debug_mark+2),a  
4b95 18 03			jr .pastdmark  
4b97 ..			.dmark: db "DI6"  
4b9a f1			.pastdmark: pop af  
4b9b			endm  
# End of macro DMARK
4b9b						CALLMONITOR 
4b9b cd 78 18			call break_point_state  
4b9e				endm  
# End of macro CALLMONITOR
4b9e					endif 
4b9e			.dirnotfound: 
4b9e c1					pop bc     
4b9f 10 95				djnz .diritem 
4ba1				 
4ba1			.dirdone:	 
4ba1					if DEBUG_FORTH_WORDS 
4ba1						DMARK "DI7" 
4ba1 f5				push af  
4ba2 3a b6 4b			ld a, (.dmark)  
4ba5 32 b4 fe			ld (debug_mark),a  
4ba8 3a b7 4b			ld a, (.dmark+1)  
4bab 32 b5 fe			ld (debug_mark+1),a  
4bae 3a b8 4b			ld a, (.dmark+2)  
4bb1 32 b6 fe			ld (debug_mark+2),a  
4bb4 18 03			jr .pastdmark  
4bb6 ..			.dmark: db "DI7"  
4bb9 f1			.pastdmark: pop af  
4bba			endm  
# End of macro DMARK
4bba						CALLMONITOR 
4bba cd 78 18			call break_point_state  
4bbd				endm  
# End of macro CALLMONITOR
4bbd					endif 
4bbd			 
4bbd					; push a count of the dir items found 
4bbd			 
4bbd 26 00				ld h, 0 
4bbf 69					ld l, c 
4bc0 cd ec 1e				call forth_push_numhl 
4bc3			 
4bc3					; push the bank label 
4bc3			 
4bc3 cd 82 04				call storage_get_block_0 
4bc6			 
4bc6				 
4bc6 21 0a fc		 		ld hl, store_page+3 
4bc9			 
4bc9					if DEBUG_FORTH_WORDS 
4bc9						DMARK "DI8" 
4bc9 f5				push af  
4bca 3a de 4b			ld a, (.dmark)  
4bcd 32 b4 fe			ld (debug_mark),a  
4bd0 3a df 4b			ld a, (.dmark+1)  
4bd3 32 b5 fe			ld (debug_mark+1),a  
4bd6 3a e0 4b			ld a, (.dmark+2)  
4bd9 32 b6 fe			ld (debug_mark+2),a  
4bdc 18 03			jr .pastdmark  
4bde ..			.dmark: db "DI8"  
4be1 f1			.pastdmark: pop af  
4be2			endm  
# End of macro DMARK
4be2						CALLMONITOR 
4be2 cd 78 18			call break_point_state  
4be5				endm  
# End of macro CALLMONITOR
4be5					endif 
4be5 cd 5a 1f				call forth_push_str 
4be8			 
4be8			 
4be8				 
4be8					NEXTW 
4be8 c3 5a 22			jp macro_next 
4beb				endm 
# End of macro NEXTW
4beb			.SAVE: 
4beb			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4beb			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4beb			;		NEXTW 
4beb			;.LOAD: 
4beb			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4beb			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4beb			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4beb			;; > > The LOAD command can not be used in any user words or compound lines. 
4beb			; 
4beb			;		; store_openext use it. If zero it is EOF 
4beb			; 
4beb			;		; read block from current stream id 
4beb			;		; if the block does not contain zero term keep reading blocks until zero found 
4beb			;		; push the block to stack 
4beb			;		; save the block id to stream 
4beb			; 
4beb			; 
4beb			;		FORTH_DSP_VALUEHL 
4beb			; 
4beb			;;		push hl 
4beb			; 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LOA" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;		FORTH_DSP_POP 
4beb			; 
4beb			;;		pop hl 
4beb			; 
4beb			;		ld h, l 
4beb			;		ld l, 0 
4beb			; 
4beb			;		push hl     ; stack holds current file id and extent to work with 
4beb			; 
4beb			; 
4beb			;		ld de, store_page      ; get block zero of file 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LO0" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;		call storage_read 
4beb			; 
4beb			;		ld a, (store_page+2)    ; max extents for this file 
4beb			;		ld  (store_openmaxext),a   ; get our limit 
4beb			; 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LOE" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			; 
4beb			;; TODO dont know why max extents are not present 
4beb			;;		cp 0 
4beb			;;		jp z, .loadeof     ; dont read past eof 
4beb			; 
4beb			;;		ld a, 1   ; start from the head of the file 
4beb			; 
4beb			;.loadline:	pop hl 
4beb			;		inc hl 
4beb			;		ld  a, (store_openmaxext)   ; get our limit 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LOx" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;		inc a 
4beb			;		cp l 
4beb			;		jp z, .loadeof 
4beb			;		push hl    ; save current extent 
4beb			; 
4beb			;		ld de, store_page 
4beb			; 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LO1" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;		call storage_read 
4beb			; 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LO2" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;	call ishlzero 
4beb			;	ld a, l 
4beb			;	add h 
4beb			;	cp 0 
4beb			;	jr z, .loadeof 
4beb			; 
4beb			;	; not eof so hl should point to data to exec 
4beb			; 
4beb			;	; will need to add the FORTH_END_BUFFER flag 
4beb			 ; 
4beb			;	ld hl, store_page+2 
4beb			;	ld bc, 255 
4beb			;	ld a, 0 
4beb			;	cpir 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LOt" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;	dec hl 
4beb			;	ld a, ' ' 
4beb			;	ld (hl), a 
4beb			;	inc hl 
4beb			;	ld (hl), a 
4beb			;	inc hl 
4beb			;	ld (hl), a 
4beb			;	inc hl 
4beb			;	ld a, FORTH_END_BUFFER 
4beb			;	ld (hl), a 
4beb			; 
4beb			;	; TODO handle more than a single block read 
4beb			; 
4beb			; 
4beb			;	ld hl, store_page+2 
4beb			; 
4beb			;	ld (os_tok_ptr), hl 
4beb			; 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LO3" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			; 
4beb			;	call forthparse 
4beb			;	call forthexec 
4beb			;	call forthexec_cleanup 
4beb			; 
4beb			;	; go to next extent 
4beb			; 
4beb			;	; get next block  or mark as eof 
4beb			;	jp .loadline 
4beb			; 
4beb			; 
4beb			; 
4beb			;	       NEXTW 
4beb			;.loadeof:	ld a, 0 
4beb			;		ld (store_openext), a 
4beb			; 
4beb			;	if DEBUG_STORESE 
4beb			;		DMARK "LOF" 
4beb			;		CALLMONITOR 
4beb			;	endif 
4beb			;		ret 
4beb			;		;NEXTW 
4beb			;.BSAVE:   
4beb			; 
4beb			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4beb			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4beb			;		NEXTW 
4beb			;.BLOAD: 
4beb			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4beb			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4beb			;		NEXTW 
4beb			;;;; counter gap 
4beb			 
4beb			 
4beb			.SEO: 
4beb				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4beb 64				db WORD_SYS_CORE+80             
4bec 0a 4c			dw .SEI            
4bee 04				db 3 + 1 
4bef .. 00			db "SEO",0              
4bf3				endm 
# End of macro CWHEAD
4bf3			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4bf3			 
4bf3					; get port 
4bf3			 
4bf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf3 cd e3 20			call macro_dsp_valuehl 
4bf6				endm 
# End of macro FORTH_DSP_VALUEHL
4bf6			 
4bf6 e5					push hl    ; u2 - byte 
4bf7			 
4bf7					; destroy value TOS 
4bf7			 
4bf7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf7 cd 9b 21			call macro_forth_dsp_pop 
4bfa				endm 
# End of macro FORTH_DSP_POP
4bfa			 
4bfa					; get byte to send 
4bfa			 
4bfa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bfa cd e3 20			call macro_dsp_valuehl 
4bfd				endm 
# End of macro FORTH_DSP_VALUEHL
4bfd			 
4bfd e5					push hl    ; u1 - addr 
4bfe			 
4bfe					; destroy value TOS 
4bfe			 
4bfe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bfe cd 9b 21			call macro_forth_dsp_pop 
4c01				endm 
# End of macro FORTH_DSP_POP
4c01			 
4c01					; one value on hl get other one back 
4c01			 
4c01 d1					pop de   ; u1 - byte 
4c02			 
4c02 e1					pop hl   ; u2 - addr 
4c03			 
4c03					; TODO Send SPI byte 
4c03			 
4c03			 
4c03 7b					ld a, e 
4c04 cd d6 01				call se_writebyte 
4c07			 
4c07					 
4c07			 
4c07					NEXTW 
4c07 c3 5a 22			jp macro_next 
4c0a				endm 
# End of macro NEXTW
4c0a			 
4c0a			.SEI: 
4c0a				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4c0a 65				db WORD_SYS_CORE+81             
4c0b 24 4c			dw .SFREE            
4c0d 04				db 3 + 1 
4c0e .. 00			db "SEI",0              
4c12				endm 
# End of macro CWHEAD
4c12			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4c12			 
4c12					; get port 
4c12			 
4c12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c12 cd e3 20			call macro_dsp_valuehl 
4c15				endm 
# End of macro FORTH_DSP_VALUEHL
4c15			 
4c15			;		push hl 
4c15			 
4c15					; destroy value TOS 
4c15			 
4c15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c15 cd 9b 21			call macro_forth_dsp_pop 
4c18				endm 
# End of macro FORTH_DSP_POP
4c18			 
4c18					; one value on hl get other one back 
4c18			 
4c18			;		pop hl 
4c18			 
4c18			 
4c18					; TODO Get SPI byte 
4c18			 
4c18 cd 78 02				call se_readbyte 
4c1b			 
4c1b 26 00				ld h, 0 
4c1d 6f					ld l, a 
4c1e cd ec 1e				call forth_push_numhl 
4c21			 
4c21					NEXTW 
4c21 c3 5a 22			jp macro_next 
4c24				endm 
# End of macro NEXTW
4c24			 
4c24			.SFREE: 
4c24				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4c24 67				db WORD_SYS_CORE+83             
4c25 53 4c			dw .SIZE            
4c27 06				db 5 + 1 
4c28 .. 00			db "FFREE",0              
4c2e				endm 
# End of macro CWHEAD
4c2e			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4c2e					if DEBUG_FORTH_WORDS_KEY 
4c2e						DMARK "FFR" 
4c2e f5				push af  
4c2f 3a 43 4c			ld a, (.dmark)  
4c32 32 b4 fe			ld (debug_mark),a  
4c35 3a 44 4c			ld a, (.dmark+1)  
4c38 32 b5 fe			ld (debug_mark+1),a  
4c3b 3a 45 4c			ld a, (.dmark+2)  
4c3e 32 b6 fe			ld (debug_mark+2),a  
4c41 18 03			jr .pastdmark  
4c43 ..			.dmark: db "FFR"  
4c46 f1			.pastdmark: pop af  
4c47			endm  
# End of macro DMARK
4c47						CALLMONITOR 
4c47 cd 78 18			call break_point_state  
4c4a				endm  
# End of macro CALLMONITOR
4c4a					endif 
4c4a			 
4c4a cd 9e 07				call storage_freeblocks 
4c4d			 
4c4d cd ec 1e				call forth_push_numhl 
4c50			 
4c50				       NEXTW 
4c50 c3 5a 22			jp macro_next 
4c53				endm 
# End of macro NEXTW
4c53			.SIZE: 
4c53				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4c53 67				db WORD_SYS_CORE+83             
4c54 87 4c			dw .CREATE            
4c56 05				db 4 + 1 
4c57 .. 00			db "SIZE",0              
4c5c				endm 
# End of macro CWHEAD
4c5c			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4c5c					if DEBUG_FORTH_WORDS_KEY 
4c5c						DMARK "SIZ" 
4c5c f5				push af  
4c5d 3a 71 4c			ld a, (.dmark)  
4c60 32 b4 fe			ld (debug_mark),a  
4c63 3a 72 4c			ld a, (.dmark+1)  
4c66 32 b5 fe			ld (debug_mark+1),a  
4c69 3a 73 4c			ld a, (.dmark+2)  
4c6c 32 b6 fe			ld (debug_mark+2),a  
4c6f 18 03			jr .pastdmark  
4c71 ..			.dmark: db "SIZ"  
4c74 f1			.pastdmark: pop af  
4c75			endm  
# End of macro DMARK
4c75						CALLMONITOR 
4c75 cd 78 18			call break_point_state  
4c78				endm  
# End of macro CALLMONITOR
4c78					endif 
4c78			 
4c78					FORTH_DSP_VALUEHL 
4c78 cd e3 20			call macro_dsp_valuehl 
4c7b				endm 
# End of macro FORTH_DSP_VALUEHL
4c7b			;		push hl 
4c7b					FORTH_DSP_POP 
4c7b cd 9b 21			call macro_forth_dsp_pop 
4c7e				endm 
# End of macro FORTH_DSP_POP
4c7e			;		pop hl 
4c7e cd 00 04				call storage_file_size 
4c81			 
4c81 cd ec 1e				call forth_push_numhl 
4c84			  
4c84			 
4c84				       NEXTW 
4c84 c3 5a 22			jp macro_next 
4c87				endm 
# End of macro NEXTW
4c87			 
4c87			.CREATE: 
4c87				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4c87 68				db WORD_SYS_CORE+84             
4c88 f5 4c			dw .APPEND            
4c8a 07				db 6 + 1 
4c8b .. 00			db "CREATE",0              
4c92				endm 
# End of macro CWHEAD
4c92			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4c92			; | | e.g.  
4c92			; | | TestProgram CREATE 
4c92			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4c92			; | |  
4c92			; | | Max file IDs are 255. 
4c92			; | |  
4c92					 
4c92					if DEBUG_FORTH_WORDS_KEY 
4c92						DMARK "CRT" 
4c92 f5				push af  
4c93 3a a7 4c			ld a, (.dmark)  
4c96 32 b4 fe			ld (debug_mark),a  
4c99 3a a8 4c			ld a, (.dmark+1)  
4c9c 32 b5 fe			ld (debug_mark+1),a  
4c9f 3a a9 4c			ld a, (.dmark+2)  
4ca2 32 b6 fe			ld (debug_mark+2),a  
4ca5 18 03			jr .pastdmark  
4ca7 ..			.dmark: db "CRT"  
4caa f1			.pastdmark: pop af  
4cab			endm  
# End of macro DMARK
4cab						CALLMONITOR 
4cab cd 78 18			call break_point_state  
4cae				endm  
# End of macro CALLMONITOR
4cae					endif 
4cae			;		call storage_get_block_0 
4cae			 
4cae					; TODO pop hl 
4cae			 
4cae					;v5 FORTH_DSP_VALUE 
4cae					FORTH_DSP_VALUE 
4cae cd cc 20			call macro_forth_dsp_value 
4cb1				endm 
# End of macro FORTH_DSP_VALUE
4cb1			 
4cb1				if DEBUG_STORESE 
4cb1					DMARK "CR1" 
4cb1 f5				push af  
4cb2 3a c6 4c			ld a, (.dmark)  
4cb5 32 b4 fe			ld (debug_mark),a  
4cb8 3a c7 4c			ld a, (.dmark+1)  
4cbb 32 b5 fe			ld (debug_mark+1),a  
4cbe 3a c8 4c			ld a, (.dmark+2)  
4cc1 32 b6 fe			ld (debug_mark+2),a  
4cc4 18 03			jr .pastdmark  
4cc6 ..			.dmark: db "CR1"  
4cc9 f1			.pastdmark: pop af  
4cca			endm  
# End of macro DMARK
4cca					CALLMONITOR 
4cca cd 78 18			call break_point_state  
4ccd				endm  
# End of macro CALLMONITOR
4ccd				endif 
4ccd			;		push hl 
4ccd			;		FORTH_DSP_POP 
4ccd			;		pop hl 
4ccd			 
4ccd			;		inc hl   ; move past the type marker 
4ccd			 
4ccd cd d4 07				call storage_create 
4cd0			 
4cd0				if DEBUG_STORESE 
4cd0					DMARK "CT1" 
4cd0 f5				push af  
4cd1 3a e5 4c			ld a, (.dmark)  
4cd4 32 b4 fe			ld (debug_mark),a  
4cd7 3a e6 4c			ld a, (.dmark+1)  
4cda 32 b5 fe			ld (debug_mark+1),a  
4cdd 3a e7 4c			ld a, (.dmark+2)  
4ce0 32 b6 fe			ld (debug_mark+2),a  
4ce3 18 03			jr .pastdmark  
4ce5 ..			.dmark: db "CT1"  
4ce8 f1			.pastdmark: pop af  
4ce9			endm  
# End of macro DMARK
4ce9					CALLMONITOR 
4ce9 cd 78 18			call break_point_state  
4cec				endm  
# End of macro CALLMONITOR
4cec				endif 
4cec			;		push hl 
4cec					FORTH_DSP_POP 
4cec cd 9b 21			call macro_forth_dsp_pop 
4cef				endm 
# End of macro FORTH_DSP_POP
4cef			;		pop hl 
4cef					; push file id to stack 
4cef cd ec 1e				call forth_push_numhl 
4cf2			 
4cf2			 
4cf2			 
4cf2				       NEXTW 
4cf2 c3 5a 22			jp macro_next 
4cf5				endm 
# End of macro NEXTW
4cf5			 
4cf5			.APPEND: 
4cf5				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4cf5 69				db WORD_SYS_CORE+85             
4cf6 86 4d			dw .SDEL            
4cf8 07				db 6 + 1 
4cf9 .. 00			db "APPEND",0              
4d00				endm 
# End of macro CWHEAD
4d00			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4d00			; | | e.g. 
4d00			; | | Test CREATE      -> $01 
4d00			; | | "A string to add to file" $01 APPEND 
4d00			; | |  
4d00			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4d00					if DEBUG_FORTH_WORDS_KEY 
4d00						DMARK "APP" 
4d00 f5				push af  
4d01 3a 15 4d			ld a, (.dmark)  
4d04 32 b4 fe			ld (debug_mark),a  
4d07 3a 16 4d			ld a, (.dmark+1)  
4d0a 32 b5 fe			ld (debug_mark+1),a  
4d0d 3a 17 4d			ld a, (.dmark+2)  
4d10 32 b6 fe			ld (debug_mark+2),a  
4d13 18 03			jr .pastdmark  
4d15 ..			.dmark: db "APP"  
4d18 f1			.pastdmark: pop af  
4d19			endm  
# End of macro DMARK
4d19						CALLMONITOR 
4d19 cd 78 18			call break_point_state  
4d1c				endm  
# End of macro CALLMONITOR
4d1c					endif 
4d1c			 
4d1c					FORTH_DSP_VALUEHL 
4d1c cd e3 20			call macro_dsp_valuehl 
4d1f				endm 
# End of macro FORTH_DSP_VALUEHL
4d1f e5					push hl 	; save file id 
4d20			 
4d20				if DEBUG_STORESE 
4d20					DMARK "AP1" 
4d20 f5				push af  
4d21 3a 35 4d			ld a, (.dmark)  
4d24 32 b4 fe			ld (debug_mark),a  
4d27 3a 36 4d			ld a, (.dmark+1)  
4d2a 32 b5 fe			ld (debug_mark+1),a  
4d2d 3a 37 4d			ld a, (.dmark+2)  
4d30 32 b6 fe			ld (debug_mark+2),a  
4d33 18 03			jr .pastdmark  
4d35 ..			.dmark: db "AP1"  
4d38 f1			.pastdmark: pop af  
4d39			endm  
# End of macro DMARK
4d39					CALLMONITOR 
4d39 cd 78 18			call break_point_state  
4d3c				endm  
# End of macro CALLMONITOR
4d3c				endif 
4d3c					FORTH_DSP_POP 
4d3c cd 9b 21			call macro_forth_dsp_pop 
4d3f				endm 
# End of macro FORTH_DSP_POP
4d3f			 
4d3f					FORTH_DSP_VALUEHL 
4d3f cd e3 20			call macro_dsp_valuehl 
4d42				endm 
# End of macro FORTH_DSP_VALUEHL
4d42					;v5 FORTH_DSP_VALUE 
4d42 e5					push hl 	; save ptr to string to save 
4d43			 
4d43				if DEBUG_STORESE 
4d43					DMARK "AP1" 
4d43 f5				push af  
4d44 3a 58 4d			ld a, (.dmark)  
4d47 32 b4 fe			ld (debug_mark),a  
4d4a 3a 59 4d			ld a, (.dmark+1)  
4d4d 32 b5 fe			ld (debug_mark+1),a  
4d50 3a 5a 4d			ld a, (.dmark+2)  
4d53 32 b6 fe			ld (debug_mark+2),a  
4d56 18 03			jr .pastdmark  
4d58 ..			.dmark: db "AP1"  
4d5b f1			.pastdmark: pop af  
4d5c			endm  
# End of macro DMARK
4d5c					CALLMONITOR 
4d5c cd 78 18			call break_point_state  
4d5f				endm  
# End of macro CALLMONITOR
4d5f				endif 
4d5f					FORTH_DSP_POP 
4d5f cd 9b 21			call macro_forth_dsp_pop 
4d62				endm 
# End of macro FORTH_DSP_POP
4d62			 
4d62 d1					pop de 
4d63 e1					pop hl 
4d64				if DEBUG_STORESE 
4d64					DMARK "AP2" 
4d64 f5				push af  
4d65 3a 79 4d			ld a, (.dmark)  
4d68 32 b4 fe			ld (debug_mark),a  
4d6b 3a 7a 4d			ld a, (.dmark+1)  
4d6e 32 b5 fe			ld (debug_mark+1),a  
4d71 3a 7b 4d			ld a, (.dmark+2)  
4d74 32 b6 fe			ld (debug_mark+2),a  
4d77 18 03			jr .pastdmark  
4d79 ..			.dmark: db "AP2"  
4d7c f1			.pastdmark: pop af  
4d7d			endm  
# End of macro DMARK
4d7d					CALLMONITOR 
4d7d cd 78 18			call break_point_state  
4d80				endm  
# End of macro CALLMONITOR
4d80				endif 
4d80					;inc de ; skip var type indicator 
4d80			 
4d80					; TODO how to append numerics???? 
4d80			 
4d80 cd bb 0a				call storage_append		 
4d83			 
4d83				       NEXTW 
4d83 c3 5a 22			jp macro_next 
4d86				endm 
# End of macro NEXTW
4d86			.SDEL: 
4d86				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4d86 6a				db WORD_SYS_CORE+86             
4d87 d2 4d			dw .OPEN            
4d89 05				db 4 + 1 
4d8a .. 00			db "ERA",0              
4d8e				endm 
# End of macro CWHEAD
4d8e			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4d8e					FORTH_DSP_VALUEHL 
4d8e cd e3 20			call macro_dsp_valuehl 
4d91				endm 
# End of macro FORTH_DSP_VALUEHL
4d91			;		push hl 	; save file id 
4d91			 
4d91					if DEBUG_FORTH_WORDS_KEY 
4d91						DMARK "ERA" 
4d91 f5				push af  
4d92 3a a6 4d			ld a, (.dmark)  
4d95 32 b4 fe			ld (debug_mark),a  
4d98 3a a7 4d			ld a, (.dmark+1)  
4d9b 32 b5 fe			ld (debug_mark+1),a  
4d9e 3a a8 4d			ld a, (.dmark+2)  
4da1 32 b6 fe			ld (debug_mark+2),a  
4da4 18 03			jr .pastdmark  
4da6 ..			.dmark: db "ERA"  
4da9 f1			.pastdmark: pop af  
4daa			endm  
# End of macro DMARK
4daa						CALLMONITOR 
4daa cd 78 18			call break_point_state  
4dad				endm  
# End of macro CALLMONITOR
4dad					endif 
4dad				if DEBUG_STORESE 
4dad					DMARK "ER1" 
4dad f5				push af  
4dae 3a c2 4d			ld a, (.dmark)  
4db1 32 b4 fe			ld (debug_mark),a  
4db4 3a c3 4d			ld a, (.dmark+1)  
4db7 32 b5 fe			ld (debug_mark+1),a  
4dba 3a c4 4d			ld a, (.dmark+2)  
4dbd 32 b6 fe			ld (debug_mark+2),a  
4dc0 18 03			jr .pastdmark  
4dc2 ..			.dmark: db "ER1"  
4dc5 f1			.pastdmark: pop af  
4dc6			endm  
# End of macro DMARK
4dc6					CALLMONITOR 
4dc6 cd 78 18			call break_point_state  
4dc9				endm  
# End of macro CALLMONITOR
4dc9				endif 
4dc9					FORTH_DSP_POP 
4dc9 cd 9b 21			call macro_forth_dsp_pop 
4dcc				endm 
# End of macro FORTH_DSP_POP
4dcc			 
4dcc			;		pop hl 
4dcc			 
4dcc cd 13 06				call storage_erase 
4dcf				       NEXTW 
4dcf c3 5a 22			jp macro_next 
4dd2				endm 
# End of macro NEXTW
4dd2			 
4dd2			.OPEN: 
4dd2				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4dd2 6b				db WORD_SYS_CORE+87             
4dd3 66 4e			dw .READ            
4dd5 05				db 4 + 1 
4dd6 .. 00			db "OPEN",0              
4ddb				endm 
# End of macro CWHEAD
4ddb			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4ddb			; | | e.g. 
4ddb			; | | $01 OPEN $01 DO $01 READ . LOOP 
4ddb			; | | 
4ddb			; | | Will return with 255 blocks if the file does not exist 
4ddb			 
4ddb					if DEBUG_FORTH_WORDS_KEY 
4ddb						DMARK "OPN" 
4ddb f5				push af  
4ddc 3a f0 4d			ld a, (.dmark)  
4ddf 32 b4 fe			ld (debug_mark),a  
4de2 3a f1 4d			ld a, (.dmark+1)  
4de5 32 b5 fe			ld (debug_mark+1),a  
4de8 3a f2 4d			ld a, (.dmark+2)  
4deb 32 b6 fe			ld (debug_mark+2),a  
4dee 18 03			jr .pastdmark  
4df0 ..			.dmark: db "OPN"  
4df3 f1			.pastdmark: pop af  
4df4			endm  
# End of macro DMARK
4df4						CALLMONITOR 
4df4 cd 78 18			call break_point_state  
4df7				endm  
# End of macro CALLMONITOR
4df7					endif 
4df7					; TODO handle multiple file opens 
4df7			 
4df7 3e 01			       	ld a, 1 
4df9 32 f9 fb				ld (store_openext), a 
4dfc			 
4dfc					; get max extents for this file 
4dfc				 
4dfc								 
4dfc					FORTH_DSP_VALUEHL 
4dfc cd e3 20			call macro_dsp_valuehl 
4dff				endm 
# End of macro FORTH_DSP_VALUEHL
4dff			 
4dff 65					ld h, l 
4e00 2e 00				ld l, 0 
4e02			 
4e02					; store file id 
4e02			 
4e02 7c					ld a, h 
4e03 32 f6 fb				ld (store_filecache), a 
4e06			 
4e06				if DEBUG_STORESE 
4e06					DMARK "OPN" 
4e06 f5				push af  
4e07 3a 1b 4e			ld a, (.dmark)  
4e0a 32 b4 fe			ld (debug_mark),a  
4e0d 3a 1c 4e			ld a, (.dmark+1)  
4e10 32 b5 fe			ld (debug_mark+1),a  
4e13 3a 1d 4e			ld a, (.dmark+2)  
4e16 32 b6 fe			ld (debug_mark+2),a  
4e19 18 03			jr .pastdmark  
4e1b ..			.dmark: db "OPN"  
4e1e f1			.pastdmark: pop af  
4e1f			endm  
# End of macro DMARK
4e1f					CALLMONITOR 
4e1f cd 78 18			call break_point_state  
4e22				endm  
# End of macro CALLMONITOR
4e22				endif 
4e22			;		push hl 
4e22					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4e22 cd 9b 21			call macro_forth_dsp_pop 
4e25				endm 
# End of macro FORTH_DSP_POP
4e25			;		pop hl 
4e25						 
4e25 11 07 fc				ld de, store_page      ; get block zero of file 
4e28 cd 2a 09				call storage_read 
4e2b cd 24 0f			call ishlzero 
4e2e 20 04			jr nz, .opfound 
4e30			 
4e30				; file does not exist so indicate with 255 extents in use 
4e30			 
4e30 3e ff			ld a, 255 
4e32 18 29			jr .skipopeneof 
4e34			 
4e34			 
4e34			.opfound: 
4e34			 
4e34			 
4e34 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
4e37 32 f8 fb				ld  (store_openmaxext), a   ; get our limit and push 
4e3a					 
4e3a				if DEBUG_STORESE 
4e3a					DMARK "OPx" 
4e3a f5				push af  
4e3b 3a 4f 4e			ld a, (.dmark)  
4e3e 32 b4 fe			ld (debug_mark),a  
4e41 3a 50 4e			ld a, (.dmark+1)  
4e44 32 b5 fe			ld (debug_mark+1),a  
4e47 3a 51 4e			ld a, (.dmark+2)  
4e4a 32 b6 fe			ld (debug_mark+2),a  
4e4d 18 03			jr .pastdmark  
4e4f ..			.dmark: db "OPx"  
4e52 f1			.pastdmark: pop af  
4e53			endm  
# End of macro DMARK
4e53					CALLMONITOR 
4e53 cd 78 18			call break_point_state  
4e56				endm  
# End of macro CALLMONITOR
4e56				endif 
4e56 fe 00				cp 0 
4e58 20 03				jr nz, .skipopeneof 
4e5a					; have opened an empty file 
4e5a					 
4e5a 32 f9 fb				ld (store_openext), a 
4e5d			 
4e5d			.skipopeneof: 
4e5d			 
4e5d 6f					ld l, a 
4e5e 26 00				ld h, 0 
4e60 cd ec 1e				call forth_push_numhl 
4e63			 
4e63			 
4e63				       NEXTW 
4e63 c3 5a 22			jp macro_next 
4e66				endm 
# End of macro NEXTW
4e66			.READ: 
4e66				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4e66 6c				db WORD_SYS_CORE+88             
4e67 90 4f			dw .EOF            
4e69 05				db 4 + 1 
4e6a .. 00			db "READ",0              
4e6f				endm 
# End of macro CWHEAD
4e6f			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
4e6f			; | | e.g. 
4e6f			; | | $01 OPEN $01 DO READ . LOOP 
4e6f			; | | 
4e6f			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4e6f			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4e6f			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4e6f			; | | two bytes contain the file id and extent. 
4e6f			; | |  
4e6f			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4e6f			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4e6f			 
4e6f					if DEBUG_FORTH_WORDS_KEY 
4e6f						DMARK "REA" 
4e6f f5				push af  
4e70 3a 84 4e			ld a, (.dmark)  
4e73 32 b4 fe			ld (debug_mark),a  
4e76 3a 85 4e			ld a, (.dmark+1)  
4e79 32 b5 fe			ld (debug_mark+1),a  
4e7c 3a 86 4e			ld a, (.dmark+2)  
4e7f 32 b6 fe			ld (debug_mark+2),a  
4e82 18 03			jr .pastdmark  
4e84 ..			.dmark: db "REA"  
4e87 f1			.pastdmark: pop af  
4e88			endm  
# End of macro DMARK
4e88						CALLMONITOR 
4e88 cd 78 18			call break_point_state  
4e8b				endm  
# End of macro CALLMONITOR
4e8b					endif 
4e8b					; store_openext use it. If zero it is EOF 
4e8b			 
4e8b					; read block from current stream id 
4e8b					; if the block does not contain zero term keep reading blocks until zero found 
4e8b					; push the block to stack 
4e8b					; save the block id to stream 
4e8b			 
4e8b			 
4e8b cd bd 4f				call .testeof 
4e8e 3e 01				ld a, 1 
4e90 bd					cp l 
4e91 ca 6c 4f				jp z, .ateof 
4e94			 
4e94			 
4e94			;		FORTH_DSP_VALUEHL 
4e94			 
4e94			;		push hl 
4e94			 
4e94			;	if DEBUG_STORESE 
4e94			;		DMARK "REA" 
4e94			;		CALLMONITOR 
4e94			;	endif 
4e94			;		FORTH_DSP_POP 
4e94			 
4e94			;		pop hl 
4e94				 
4e94 3a f6 fb				ld a, (store_filecache) 
4e97 67					ld h,a 
4e98			 
4e98 3a f9 fb				ld a, (store_openext) 
4e9b 6f					ld l, a 
4e9c					 
4e9c fe 00				cp 0 
4e9e ca 6c 4f				jp z, .ateof     ; dont read past eof 
4ea1			 
4ea1 cd 07 0c				call storage_clear_page 
4ea4			 
4ea4 11 07 fc				ld de, store_page 
4ea7				if DEBUG_STORESE 
4ea7					DMARK "RE1" 
4ea7 f5				push af  
4ea8 3a bc 4e			ld a, (.dmark)  
4eab 32 b4 fe			ld (debug_mark),a  
4eae 3a bd 4e			ld a, (.dmark+1)  
4eb1 32 b5 fe			ld (debug_mark+1),a  
4eb4 3a be 4e			ld a, (.dmark+2)  
4eb7 32 b6 fe			ld (debug_mark+2),a  
4eba 18 03			jr .pastdmark  
4ebc ..			.dmark: db "RE1"  
4ebf f1			.pastdmark: pop af  
4ec0			endm  
# End of macro DMARK
4ec0					CALLMONITOR 
4ec0 cd 78 18			call break_point_state  
4ec3				endm  
# End of macro CALLMONITOR
4ec3				endif 
4ec3 cd 2a 09				call storage_read 
4ec6			 
4ec6				if DEBUG_STORESE 
4ec6					DMARK "RE2" 
4ec6 f5				push af  
4ec7 3a db 4e			ld a, (.dmark)  
4eca 32 b4 fe			ld (debug_mark),a  
4ecd 3a dc 4e			ld a, (.dmark+1)  
4ed0 32 b5 fe			ld (debug_mark+1),a  
4ed3 3a dd 4e			ld a, (.dmark+2)  
4ed6 32 b6 fe			ld (debug_mark+2),a  
4ed9 18 03			jr .pastdmark  
4edb ..			.dmark: db "RE2"  
4ede f1			.pastdmark: pop af  
4edf			endm  
# End of macro DMARK
4edf					CALLMONITOR 
4edf cd 78 18			call break_point_state  
4ee2				endm  
# End of macro CALLMONITOR
4ee2				endif 
4ee2 cd 24 0f			call ishlzero 
4ee5			;	ld a, l 
4ee5			;	add h 
4ee5			;	cp 0 
4ee5 ca 6c 4f			jp z, .readeof 
4ee8			 
4ee8				; not eof so hl should point to data to push to stack 
4ee8			 
4ee8				if DEBUG_STORESE 
4ee8					DMARK "RE3" 
4ee8 f5				push af  
4ee9 3a fd 4e			ld a, (.dmark)  
4eec 32 b4 fe			ld (debug_mark),a  
4eef 3a fe 4e			ld a, (.dmark+1)  
4ef2 32 b5 fe			ld (debug_mark+1),a  
4ef5 3a ff 4e			ld a, (.dmark+2)  
4ef8 32 b6 fe			ld (debug_mark+2),a  
4efb 18 03			jr .pastdmark  
4efd ..			.dmark: db "RE3"  
4f00 f1			.pastdmark: pop af  
4f01			endm  
# End of macro DMARK
4f01					CALLMONITOR 
4f01 cd 78 18			call break_point_state  
4f04				endm  
# End of macro CALLMONITOR
4f04				endif 
4f04 cd 5a 1f			call forth_push_str 
4f07			 
4f07				if DEBUG_STORESE 
4f07					DMARK "RE4" 
4f07 f5				push af  
4f08 3a 1c 4f			ld a, (.dmark)  
4f0b 32 b4 fe			ld (debug_mark),a  
4f0e 3a 1d 4f			ld a, (.dmark+1)  
4f11 32 b5 fe			ld (debug_mark+1),a  
4f14 3a 1e 4f			ld a, (.dmark+2)  
4f17 32 b6 fe			ld (debug_mark+2),a  
4f1a 18 03			jr .pastdmark  
4f1c ..			.dmark: db "RE4"  
4f1f f1			.pastdmark: pop af  
4f20			endm  
# End of macro DMARK
4f20					CALLMONITOR 
4f20 cd 78 18			call break_point_state  
4f23				endm  
# End of macro CALLMONITOR
4f23				endif 
4f23				; get next block  or mark as eof 
4f23			 
4f23 3a f8 fb			ld a, (store_openmaxext)   ; get our limit 
4f26 4f				ld c, a	 
4f27 3a f9 fb			ld a, (store_openext) 
4f2a			 
4f2a				if DEBUG_STORESE 
4f2a					DMARK "RE5" 
4f2a f5				push af  
4f2b 3a 3f 4f			ld a, (.dmark)  
4f2e 32 b4 fe			ld (debug_mark),a  
4f31 3a 40 4f			ld a, (.dmark+1)  
4f34 32 b5 fe			ld (debug_mark+1),a  
4f37 3a 41 4f			ld a, (.dmark+2)  
4f3a 32 b6 fe			ld (debug_mark+2),a  
4f3d 18 03			jr .pastdmark  
4f3f ..			.dmark: db "RE5"  
4f42 f1			.pastdmark: pop af  
4f43			endm  
# End of macro DMARK
4f43					CALLMONITOR 
4f43 cd 78 18			call break_point_state  
4f46				endm  
# End of macro CALLMONITOR
4f46				endif 
4f46 b9				cp c 
4f47 28 23			jr z, .readeof     ; at last extent 
4f49			 
4f49 3c					inc a 
4f4a 32 f9 fb				ld (store_openext), a 
4f4d			 
4f4d				if DEBUG_STORESE 
4f4d					DMARK "RE6" 
4f4d f5				push af  
4f4e 3a 62 4f			ld a, (.dmark)  
4f51 32 b4 fe			ld (debug_mark),a  
4f54 3a 63 4f			ld a, (.dmark+1)  
4f57 32 b5 fe			ld (debug_mark+1),a  
4f5a 3a 64 4f			ld a, (.dmark+2)  
4f5d 32 b6 fe			ld (debug_mark+2),a  
4f60 18 03			jr .pastdmark  
4f62 ..			.dmark: db "RE6"  
4f65 f1			.pastdmark: pop af  
4f66			endm  
# End of macro DMARK
4f66					CALLMONITOR 
4f66 cd 78 18			call break_point_state  
4f69				endm  
# End of macro CALLMONITOR
4f69				endif 
4f69			 
4f69			 
4f69				       NEXTW 
4f69 c3 5a 22			jp macro_next 
4f6c				endm 
# End of macro NEXTW
4f6c			.ateof: 
4f6c				;	ld hl, .showeof 
4f6c				;	call forth_push_str 
4f6c 3e 00		.readeof:	ld a, 0 
4f6e 32 f9 fb				ld (store_openext), a 
4f71			 
4f71					 
4f71				if DEBUG_STORESE 
4f71					DMARK "REF" 
4f71 f5				push af  
4f72 3a 86 4f			ld a, (.dmark)  
4f75 32 b4 fe			ld (debug_mark),a  
4f78 3a 87 4f			ld a, (.dmark+1)  
4f7b 32 b5 fe			ld (debug_mark+1),a  
4f7e 3a 88 4f			ld a, (.dmark+2)  
4f81 32 b6 fe			ld (debug_mark+2),a  
4f84 18 03			jr .pastdmark  
4f86 ..			.dmark: db "REF"  
4f89 f1			.pastdmark: pop af  
4f8a			endm  
# End of macro DMARK
4f8a					CALLMONITOR 
4f8a cd 78 18			call break_point_state  
4f8d				endm  
# End of macro CALLMONITOR
4f8d				endif 
4f8d				       NEXTW 
4f8d c3 5a 22			jp macro_next 
4f90				endm 
# End of macro NEXTW
4f90			 
4f90			;.showeof:   db "eof", 0 
4f90			 
4f90			 
4f90			.EOF: 
4f90				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4f90 6d				db WORD_SYS_CORE+89             
4f91 d2 4f			dw .FORMAT            
4f93 04				db 3 + 1 
4f94 .. 00			db "EOF",0              
4f98				endm 
# End of macro CWHEAD
4f98			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
4f98			; | | e.g. 
4f98			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
4f98					; TODO if current block id for stream is zero then push true else false 
4f98			 
4f98					if DEBUG_FORTH_WORDS_KEY 
4f98						DMARK "EOF" 
4f98 f5				push af  
4f99 3a ad 4f			ld a, (.dmark)  
4f9c 32 b4 fe			ld (debug_mark),a  
4f9f 3a ae 4f			ld a, (.dmark+1)  
4fa2 32 b5 fe			ld (debug_mark+1),a  
4fa5 3a af 4f			ld a, (.dmark+2)  
4fa8 32 b6 fe			ld (debug_mark+2),a  
4fab 18 03			jr .pastdmark  
4fad ..			.dmark: db "EOF"  
4fb0 f1			.pastdmark: pop af  
4fb1			endm  
# End of macro DMARK
4fb1						CALLMONITOR 
4fb1 cd 78 18			call break_point_state  
4fb4				endm  
# End of macro CALLMONITOR
4fb4					endif 
4fb4			 
4fb4					; TODO handlue multiple file streams 
4fb4			 
4fb4			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
4fb4 cd bd 4f				call .testeof 
4fb7 cd ec 1e				call forth_push_numhl 
4fba			 
4fba			 
4fba				       NEXTW 
4fba c3 5a 22			jp macro_next 
4fbd				endm 
# End of macro NEXTW
4fbd			 
4fbd			.testeof: 
4fbd 2e 01				ld l, 1 
4fbf 3a f8 fb				ld a, (store_openmaxext) 
4fc2 fe 00				cp 0 
4fc4 28 09				jr  z, .eofdone   ; empty file 
4fc6 3a f9 fb				ld a, (store_openext) 
4fc9 fe 00				cp 0 
4fcb 28 02				jr  z, .eofdone 
4fcd 2e 00				ld l, 0 
4fcf 26 00		.eofdone:	ld h, 0 
4fd1 c9					ret 
4fd2			 
4fd2			 
4fd2			 
4fd2			 
4fd2			.FORMAT: 
4fd2				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4fd2 6d				db WORD_SYS_CORE+89             
4fd3 23 50			dw .LABEL            
4fd5 07				db 6 + 1 
4fd6 .. 00			db "FORMAT",0              
4fdd				endm 
# End of macro CWHEAD
4fdd			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4fdd					; TODO if current block id for stream is zero then push true else false 
4fdd				 
4fdd				if DEBUG_STORESE 
4fdd					DMARK "FOR" 
4fdd f5				push af  
4fde 3a f2 4f			ld a, (.dmark)  
4fe1 32 b4 fe			ld (debug_mark),a  
4fe4 3a f3 4f			ld a, (.dmark+1)  
4fe7 32 b5 fe			ld (debug_mark+1),a  
4fea 3a f4 4f			ld a, (.dmark+2)  
4fed 32 b6 fe			ld (debug_mark+2),a  
4ff0 18 03			jr .pastdmark  
4ff2 ..			.dmark: db "FOR"  
4ff5 f1			.pastdmark: pop af  
4ff6			endm  
# End of macro DMARK
4ff6					CALLMONITOR 
4ff6 cd 78 18			call break_point_state  
4ff9				endm  
# End of macro CALLMONITOR
4ff9				endif 
4ff9					; Wipes the bank check flags to cause a reformat on next block 0 read 
4ff9			 
4ff9 21 01 00				ld hl, 1 
4ffc 3e 00				ld a, 0 
4ffe cd d6 01				call se_writebyte 
5001			 
5001				if DEBUG_STORESE 
5001					DMARK "FO0" 
5001 f5				push af  
5002 3a 16 50			ld a, (.dmark)  
5005 32 b4 fe			ld (debug_mark),a  
5008 3a 17 50			ld a, (.dmark+1)  
500b 32 b5 fe			ld (debug_mark+1),a  
500e 3a 18 50			ld a, (.dmark+2)  
5011 32 b6 fe			ld (debug_mark+2),a  
5014 18 03			jr .pastdmark  
5016 ..			.dmark: db "FO0"  
5019 f1			.pastdmark: pop af  
501a			endm  
# End of macro DMARK
501a					CALLMONITOR 
501a cd 78 18			call break_point_state  
501d				endm  
# End of macro CALLMONITOR
501d				endif 
501d					; force bank init 
501d			 
501d cd 82 04				call storage_get_block_0 
5020					 
5020				       NEXTW 
5020 c3 5a 22			jp macro_next 
5023				endm 
# End of macro NEXTW
5023			.LABEL: 
5023				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5023 6d				db WORD_SYS_CORE+89             
5024 71 50			dw .STOREPAGE            
5026 06				db 5 + 1 
5027 .. 00			db "LABEL",0              
502d				endm 
# End of macro CWHEAD
502d			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
502d					; TODO test to see if bank is selected 
502d				 
502d					if DEBUG_FORTH_WORDS_KEY 
502d						DMARK "LBL" 
502d f5				push af  
502e 3a 42 50			ld a, (.dmark)  
5031 32 b4 fe			ld (debug_mark),a  
5034 3a 43 50			ld a, (.dmark+1)  
5037 32 b5 fe			ld (debug_mark+1),a  
503a 3a 44 50			ld a, (.dmark+2)  
503d 32 b6 fe			ld (debug_mark+2),a  
5040 18 03			jr .pastdmark  
5042 ..			.dmark: db "LBL"  
5045 f1			.pastdmark: pop af  
5046			endm  
# End of macro DMARK
5046						CALLMONITOR 
5046 cd 78 18			call break_point_state  
5049				endm  
# End of macro CALLMONITOR
5049					endif 
5049			;	if DEBUG_STORESE 
5049			;		DMARK "LBL" 
5049			;		CALLMONITOR 
5049			;	endif 
5049					FORTH_DSP_VALUEHL 
5049 cd e3 20			call macro_dsp_valuehl 
504c				endm 
# End of macro FORTH_DSP_VALUEHL
504c					;v5FORTH_DSP_VALUE 
504c					 
504c			;		push hl 
504c					FORTH_DSP_POP 
504c cd 9b 21			call macro_forth_dsp_pop 
504f				endm 
# End of macro FORTH_DSP_POP
504f			;		pop hl 
504f			 
504f			;v5		inc hl   ; move past the type marker 
504f			 
504f				if DEBUG_STORESE 
504f					DMARK "LBl" 
504f f5				push af  
5050 3a 64 50			ld a, (.dmark)  
5053 32 b4 fe			ld (debug_mark),a  
5056 3a 65 50			ld a, (.dmark+1)  
5059 32 b5 fe			ld (debug_mark+1),a  
505c 3a 66 50			ld a, (.dmark+2)  
505f 32 b6 fe			ld (debug_mark+2),a  
5062 18 03			jr .pastdmark  
5064 ..			.dmark: db "LBl"  
5067 f1			.pastdmark: pop af  
5068			endm  
# End of macro DMARK
5068					CALLMONITOR 
5068 cd 78 18			call break_point_state  
506b				endm  
# End of macro CALLMONITOR
506b				endif 
506b cd a6 05				call storage_label 
506e			 
506e				       NEXTW 
506e c3 5a 22			jp macro_next 
5071				endm 
# End of macro NEXTW
5071			.STOREPAGE: 
5071				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5071 6d				db WORD_SYS_CORE+89             
5072 a4 50			dw .LABELS            
5074 0a				db 9 + 1 
5075 .. 00			db "STOREPAGE",0              
507f				endm 
# End of macro CWHEAD
507f			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
507f					; TODO test to see if bank is selected 
507f				 
507f					if DEBUG_FORTH_WORDS_KEY 
507f						DMARK "STP" 
507f f5				push af  
5080 3a 94 50			ld a, (.dmark)  
5083 32 b4 fe			ld (debug_mark),a  
5086 3a 95 50			ld a, (.dmark+1)  
5089 32 b5 fe			ld (debug_mark+1),a  
508c 3a 96 50			ld a, (.dmark+2)  
508f 32 b6 fe			ld (debug_mark+2),a  
5092 18 03			jr .pastdmark  
5094 ..			.dmark: db "STP"  
5097 f1			.pastdmark: pop af  
5098			endm  
# End of macro DMARK
5098						CALLMONITOR 
5098 cd 78 18			call break_point_state  
509b				endm  
# End of macro CALLMONITOR
509b					endif 
509b			;	if DEBUG_STORESE 
509b			;		DMARK "STP" 
509b			;		CALLMONITOR 
509b			;	endif 
509b			 
509b 21 07 fc			ld hl, store_page 
509e cd ec 1e			call forth_push_numhl 
50a1			 
50a1			 
50a1				       NEXTW 
50a1 c3 5a 22			jp macro_next 
50a4				endm 
# End of macro NEXTW
50a4			.LABELS: 
50a4				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
50a4 6d				db WORD_SYS_CORE+89             
50a5 2e 51			dw .SCONST1            
50a7 07				db 6 + 1 
50a8 .. 00			db "LABELS",0              
50af				endm 
# End of macro CWHEAD
50af			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
50af					;  
50af			 
50af					; save the current device selected to restore afterwards 
50af				 
50af 3a f0 fb				ld a, (spi_device) 
50b2 f5					push af 
50b3			 
50b3			 
50b3					; run through each of the banks 
50b3			 
50b3 21 01 00				ld hl, 1 
50b6 cd ec 1e				call forth_push_numhl 
50b9 3e ff				ld a, SPI_CE_HIGH 
50bb cb 87				res SPI_CE0, a 
50bd 32 f0 fb				ld (spi_device), a 
50c0 cd 82 04				call storage_get_block_0 
50c3 21 0a fc				ld hl, store_page+3 
50c6 cd 5a 1f				call forth_push_str 
50c9			 
50c9					 
50c9 21 02 00				ld hl, 2 
50cc cd ec 1e				call forth_push_numhl 
50cf 3e ff				ld a, SPI_CE_HIGH 
50d1 cb 8f				res SPI_CE1, a 
50d3 32 f0 fb				ld (spi_device), a 
50d6 cd 82 04				call storage_get_block_0 
50d9 21 0a fc				ld hl, store_page+3 
50dc cd 5a 1f				call forth_push_str 
50df			 
50df					 
50df 21 03 00				ld hl, 3 
50e2 cd ec 1e				call forth_push_numhl 
50e5 3e ff				ld a, SPI_CE_HIGH 
50e7 cb 97				res SPI_CE2, a 
50e9 32 f0 fb				ld (spi_device), a 
50ec cd 82 04				call storage_get_block_0 
50ef 21 0a fc				ld hl, store_page+3 
50f2 cd 5a 1f				call forth_push_str 
50f5			 
50f5			 
50f5 21 04 00				ld hl, 4 
50f8 cd ec 1e				call forth_push_numhl 
50fb 3e ff				ld a, SPI_CE_HIGH 
50fd cb 9f				res SPI_CE3, a 
50ff 32 f0 fb				ld (spi_device), a 
5102 cd 82 04				call storage_get_block_0 
5105 21 0a fc				ld hl, store_page+3 
5108 cd 5a 1f				call forth_push_str 
510b			 
510b					 
510b			 
510b 21 05 00				ld hl, 5 
510e cd ec 1e				call forth_push_numhl 
5111 3e ff				ld a, SPI_CE_HIGH 
5113 cb a7				res SPI_CE4, a 
5115 32 f0 fb				ld (spi_device), a 
5118 cd 82 04				call storage_get_block_0 
511b 21 0a fc				ld hl, store_page+3 
511e cd 5a 1f				call forth_push_str 
5121			 
5121					 
5121					; push fixed count of storage devices (on board) for now 
5121			 
5121 21 05 00				ld hl, 5 
5124 cd ec 1e				call forth_push_numhl 
5127			 
5127					; restore selected device  
5127				 
5127 f1					pop af 
5128 32 f0 fb				ld (spi_device), a 
512b			 
512b				       NEXTW 
512b c3 5a 22			jp macro_next 
512e				endm 
# End of macro NEXTW
512e			 
512e			.SCONST1: 
512e				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
512e 6d				db WORD_SYS_CORE+89             
512f 45 51			dw .SCONST2            
5131 07				db 6 + 1 
5132 .. 00			db "FILEID",0              
5139				endm 
# End of macro CWHEAD
5139			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5139 3a f6 fb				ld a, (store_filecache) 
513c 26 00				ld h, 0 
513e 6f					ld l, a 
513f cd ec 1e				call forth_push_numhl 
5142					NEXTW 
5142 c3 5a 22			jp macro_next 
5145				endm 
# End of macro NEXTW
5145			.SCONST2: 
5145				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5145 6d				db WORD_SYS_CORE+89             
5146 5d 51			dw .SCONST3            
5148 08				db 7 + 1 
5149 .. 00			db "FILEEXT",0              
5151				endm 
# End of macro CWHEAD
5151			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5151 3a f9 fb				ld a, (store_openext) 
5154 26 00				ld h, 0 
5156 6f					ld l, a 
5157 cd ec 1e				call forth_push_numhl 
515a					NEXTW 
515a c3 5a 22			jp macro_next 
515d				endm 
# End of macro NEXTW
515d			.SCONST3: 
515d				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
515d 6d				db WORD_SYS_CORE+89             
515e 75 51			dw .SCONST4            
5160 08				db 7 + 1 
5161 .. 00			db "FILEMAX",0              
5169				endm 
# End of macro CWHEAD
5169			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5169 3a f8 fb				ld a, (store_openmaxext) 
516c 26 00				ld h, 0 
516e 6f					ld l, a 
516f cd ec 1e				call forth_push_numhl 
5172					NEXTW 
5172 c3 5a 22			jp macro_next 
5175				endm 
# End of macro NEXTW
5175			.SCONST4: 
5175				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5175 6d				db WORD_SYS_CORE+89             
5176 8e 51			dw .ENDSTORAGE            
5178 09				db 8 + 1 
5179 .. 00			db "READCONT",0              
5182				endm 
# End of macro CWHEAD
5182			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5182			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5182			; | | a further read should, if applicable, be CONCAT to the previous read. 
5182 3a fa fb				ld a, (store_readcont) 
5185 26 00				ld h, 0 
5187 6f					ld l, a 
5188 cd ec 1e				call forth_push_numhl 
518b					NEXTW 
518b c3 5a 22			jp macro_next 
518e				endm 
# End of macro NEXTW
518e			.ENDSTORAGE: 
518e			; eof 
# End of file forth_words_storage.asm
518e			endif 
518e				include "forth_words_device.asm" 
518e			; Device related words 
518e			 
518e			; | ## Device Words 
518e			 
518e			if SOUND_ENABLE 
518e			.NOTE: 
518e				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
518e			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
518e					if DEBUG_FORTH_WORDS_KEY 
518e						DMARK "NTE" 
518e						CALLMONITOR 
518e					endif 
518e			 
518e				 
518e			 
518e					NEXTW 
518e			.AFTERSOUND: 
518e			endif 
518e			 
518e			 
518e			USE_GPIO: equ 0 
518e			 
518e			if USE_GPIO 
518e			.GP1: 
518e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
518e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
518e					NEXTW 
518e			.GP2: 
518e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
518e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
518e			 
518e					NEXTW 
518e			 
518e			.GP3: 
518e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
518e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
518e			 
518e					NEXTW 
518e			 
518e			.GP4: 
518e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
518e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
518e			 
518e					NEXTW 
518e			.SIN: 
518e			 
518e			 
518e			endif 
518e			 
518e			 
518e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
518e 33				db WORD_SYS_CORE+31             
518f c3 51			dw .SOUT            
5191 03				db 2 + 1 
5192 .. 00			db "IN",0              
5195				endm 
# End of macro CWHEAD
5195			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5195					if DEBUG_FORTH_WORDS_KEY 
5195						DMARK "IN." 
5195 f5				push af  
5196 3a aa 51			ld a, (.dmark)  
5199 32 b4 fe			ld (debug_mark),a  
519c 3a ab 51			ld a, (.dmark+1)  
519f 32 b5 fe			ld (debug_mark+1),a  
51a2 3a ac 51			ld a, (.dmark+2)  
51a5 32 b6 fe			ld (debug_mark+2),a  
51a8 18 03			jr .pastdmark  
51aa ..			.dmark: db "IN."  
51ad f1			.pastdmark: pop af  
51ae			endm  
# End of macro DMARK
51ae						CALLMONITOR 
51ae cd 78 18			call break_point_state  
51b1				endm  
# End of macro CALLMONITOR
51b1					endif 
51b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51b1 cd e3 20			call macro_dsp_valuehl 
51b4				endm 
# End of macro FORTH_DSP_VALUEHL
51b4			 
51b4 e5					push hl 
51b5			 
51b5					; destroy value TOS 
51b5			 
51b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51b5 cd 9b 21			call macro_forth_dsp_pop 
51b8				endm 
# End of macro FORTH_DSP_POP
51b8			 
51b8					; one value on hl get other one back 
51b8			 
51b8 c1					pop bc 
51b9			 
51b9					; do the sub 
51b9			;		ex de, hl 
51b9			 
51b9 ed 68				in l,(c) 
51bb			 
51bb					; save it 
51bb			 
51bb 26 00				ld h,0 
51bd			 
51bd					; TODO push value back onto stack for another op etc 
51bd			 
51bd cd ec 1e				call forth_push_numhl 
51c0					NEXTW 
51c0 c3 5a 22			jp macro_next 
51c3				endm 
# End of macro NEXTW
51c3			.SOUT: 
51c3				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
51c3 34				db WORD_SYS_CORE+32             
51c4 16 52			dw .SPIO            
51c6 04				db 3 + 1 
51c7 .. 00			db "OUT",0              
51cb				endm 
# End of macro CWHEAD
51cb			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
51cb					if DEBUG_FORTH_WORDS_KEY 
51cb						DMARK "OUT" 
51cb f5				push af  
51cc 3a e0 51			ld a, (.dmark)  
51cf 32 b4 fe			ld (debug_mark),a  
51d2 3a e1 51			ld a, (.dmark+1)  
51d5 32 b5 fe			ld (debug_mark+1),a  
51d8 3a e2 51			ld a, (.dmark+2)  
51db 32 b6 fe			ld (debug_mark+2),a  
51de 18 03			jr .pastdmark  
51e0 ..			.dmark: db "OUT"  
51e3 f1			.pastdmark: pop af  
51e4			endm  
# End of macro DMARK
51e4						CALLMONITOR 
51e4 cd 78 18			call break_point_state  
51e7				endm  
# End of macro CALLMONITOR
51e7					endif 
51e7			 
51e7					; get port 
51e7			 
51e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51e7 cd e3 20			call macro_dsp_valuehl 
51ea				endm 
# End of macro FORTH_DSP_VALUEHL
51ea			 
51ea e5					push hl 
51eb			 
51eb					; destroy value TOS 
51eb			 
51eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51eb cd 9b 21			call macro_forth_dsp_pop 
51ee				endm 
# End of macro FORTH_DSP_POP
51ee			 
51ee					; get byte to send 
51ee			 
51ee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51ee cd e3 20			call macro_dsp_valuehl 
51f1				endm 
# End of macro FORTH_DSP_VALUEHL
51f1			 
51f1			;		push hl 
51f1			 
51f1					; destroy value TOS 
51f1			 
51f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51f1 cd 9b 21			call macro_forth_dsp_pop 
51f4				endm 
# End of macro FORTH_DSP_POP
51f4			 
51f4					; one value on hl get other one back 
51f4			 
51f4			;		pop hl 
51f4			 
51f4 c1					pop bc 
51f5			 
51f5					if DEBUG_FORTH_WORDS 
51f5						DMARK "OUT" 
51f5 f5				push af  
51f6 3a 0a 52			ld a, (.dmark)  
51f9 32 b4 fe			ld (debug_mark),a  
51fc 3a 0b 52			ld a, (.dmark+1)  
51ff 32 b5 fe			ld (debug_mark+1),a  
5202 3a 0c 52			ld a, (.dmark+2)  
5205 32 b6 fe			ld (debug_mark+2),a  
5208 18 03			jr .pastdmark  
520a ..			.dmark: db "OUT"  
520d f1			.pastdmark: pop af  
520e			endm  
# End of macro DMARK
520e						CALLMONITOR 
520e cd 78 18			call break_point_state  
5211				endm  
# End of macro CALLMONITOR
5211					endif 
5211			 
5211 ed 69				out (c), l 
5213			 
5213					NEXTW 
5213 c3 5a 22			jp macro_next 
5216				endm 
# End of macro NEXTW
5216			 
5216			 
5216			.SPIO: 
5216			 
5216			if STORAGE_SE 
5216				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5216 51				db WORD_SYS_CORE+61             
5217 27 52			dw .SPICEH            
5219 07				db 6 + 1 
521a .. 00			db "SPICEL",0              
5221				endm 
# End of macro CWHEAD
5221			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5221			 
5221 cd 84 01				call spi_ce_low 
5224			    NEXTW 
5224 c3 5a 22			jp macro_next 
5227				endm 
# End of macro NEXTW
5227			 
5227			.SPICEH: 
5227				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5227 51				db WORD_SYS_CORE+61             
5228 38 52			dw .SPIOb            
522a 07				db 6 + 1 
522b .. 00			db "SPICEH",0              
5232				endm 
# End of macro CWHEAD
5232			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5232			 
5232 cd 73 01				call spi_ce_high 
5235			    NEXTW 
5235 c3 5a 22			jp macro_next 
5238				endm 
# End of macro NEXTW
5238			 
5238			 
5238			.SPIOb: 
5238			 
5238				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5238 51				db WORD_SYS_CORE+61             
5239 4e 52			dw .SPII            
523b 05				db 4 + 1 
523c .. 00			db "SPIO",0              
5241				endm 
# End of macro CWHEAD
5241			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5241			 
5241					; get port 
5241			 
5241			 
5241					; get byte to send 
5241			 
5241					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5241 cd e3 20			call macro_dsp_valuehl 
5244				endm 
# End of macro FORTH_DSP_VALUEHL
5244			 
5244			;		push hl    ; u1  
5244			 
5244					; destroy value TOS 
5244			 
5244					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5244 cd 9b 21			call macro_forth_dsp_pop 
5247				endm 
# End of macro FORTH_DSP_POP
5247			 
5247					; one value on hl get other one back 
5247			 
5247			;		pop hl   ; u2 - addr 
5247			 
5247					; TODO Send SPI byte 
5247			 
5247 7d					ld a, l 
5248 cd a8 00				call spi_send_byte 
524b			 
524b					NEXTW 
524b c3 5a 22			jp macro_next 
524e				endm 
# End of macro NEXTW
524e			 
524e			.SPII: 
524e				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
524e 52				db WORD_SYS_CORE+62             
524f 63 52			dw .SESEL            
5251 06				db 5 + 1 
5252 .. 00			db "SPII",0              
5257				endm 
# End of macro CWHEAD
5257			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5257			 
5257					; TODO Get SPI byte 
5257			 
5257 cd c9 00				call spi_read_byte 
525a			 
525a 26 00				ld h, 0 
525c 6f					ld l, a 
525d cd ec 1e				call forth_push_numhl 
5260			 
5260					NEXTW 
5260 c3 5a 22			jp macro_next 
5263				endm 
# End of macro NEXTW
5263			 
5263			 
5263			 
5263			.SESEL: 
5263				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5263 66				db WORD_SYS_CORE+82             
5264 07 53			dw .CARTDEV            
5266 05				db 4 + 1 
5267 .. 00			db "BANK",0              
526c				endm 
# End of macro CWHEAD
526c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
526c					if DEBUG_FORTH_WORDS_KEY 
526c						DMARK "BNK" 
526c f5				push af  
526d 3a 81 52			ld a, (.dmark)  
5270 32 b4 fe			ld (debug_mark),a  
5273 3a 82 52			ld a, (.dmark+1)  
5276 32 b5 fe			ld (debug_mark+1),a  
5279 3a 83 52			ld a, (.dmark+2)  
527c 32 b6 fe			ld (debug_mark+2),a  
527f 18 03			jr .pastdmark  
5281 ..			.dmark: db "BNK"  
5284 f1			.pastdmark: pop af  
5285			endm  
# End of macro DMARK
5285						CALLMONITOR 
5285 cd 78 18			call break_point_state  
5288				endm  
# End of macro CALLMONITOR
5288					endif 
5288			 
5288 3e ff				ld a, 255 
528a 32 f3 fb				ld (spi_cartdev), a 
528d			 
528d					; get bank 
528d			 
528d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
528d cd e3 20			call macro_dsp_valuehl 
5290				endm 
# End of macro FORTH_DSP_VALUEHL
5290			 
5290			;		push hl 
5290			 
5290					; destroy value TOS 
5290			 
5290					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5290 cd 9b 21			call macro_forth_dsp_pop 
5293				endm 
# End of macro FORTH_DSP_POP
5293			 
5293					; one value on hl get other one back 
5293			 
5293			;		pop hl 
5293			 
5293			 
5293 0e ff				ld c, SPI_CE_HIGH 
5295 06 30				ld b, '0'    ; human readable bank number 
5297			 
5297 7d					ld a, l 
5298			 
5298					if DEBUG_FORTH_WORDS 
5298						DMARK "BNK" 
5298 f5				push af  
5299 3a ad 52			ld a, (.dmark)  
529c 32 b4 fe			ld (debug_mark),a  
529f 3a ae 52			ld a, (.dmark+1)  
52a2 32 b5 fe			ld (debug_mark+1),a  
52a5 3a af 52			ld a, (.dmark+2)  
52a8 32 b6 fe			ld (debug_mark+2),a  
52ab 18 03			jr .pastdmark  
52ad ..			.dmark: db "BNK"  
52b0 f1			.pastdmark: pop af  
52b1			endm  
# End of macro DMARK
52b1						CALLMONITOR 
52b1 cd 78 18			call break_point_state  
52b4				endm  
# End of macro CALLMONITOR
52b4					endif 
52b4			 
52b4					; active low 
52b4			 
52b4 fe 00				cp 0 
52b6 28 28				jr z, .bset 
52b8 fe 01				cp 1 
52ba 20 04				jr nz, .b2 
52bc cb 81				res 0, c 
52be 06 31				ld b, '1'    ; human readable bank number 
52c0 fe 02		.b2:		cp 2 
52c2 20 04				jr nz, .b3 
52c4 cb 89				res 1, c 
52c6 06 32				ld b, '2'    ; human readable bank number 
52c8 fe 03		.b3:		cp 3 
52ca 20 04				jr nz, .b4 
52cc cb 91				res 2, c 
52ce 06 33				ld b, '3'    ; human readable bank number 
52d0 fe 04		.b4:		cp 4 
52d2 20 04				jr nz, .b5 
52d4 cb 99				res 3, c 
52d6 06 34				ld b, '4'    ; human readable bank number 
52d8 fe 05		.b5:		cp 5 
52da 20 04				jr nz, .bset 
52dc cb a1				res 4, c 
52de 06 35				ld b, '5'    ; human readable bank number 
52e0			 
52e0			.bset: 
52e0 79					ld a, c 
52e1 32 f0 fb				ld (spi_device),a 
52e4 78					ld a, b 
52e5 32 ef fb				ld (spi_device_id),a 
52e8					if DEBUG_FORTH_WORDS 
52e8						DMARK "BN2" 
52e8 f5				push af  
52e9 3a fd 52			ld a, (.dmark)  
52ec 32 b4 fe			ld (debug_mark),a  
52ef 3a fe 52			ld a, (.dmark+1)  
52f2 32 b5 fe			ld (debug_mark+1),a  
52f5 3a ff 52			ld a, (.dmark+2)  
52f8 32 b6 fe			ld (debug_mark+2),a  
52fb 18 03			jr .pastdmark  
52fd ..			.dmark: db "BN2"  
5300 f1			.pastdmark: pop af  
5301			endm  
# End of macro DMARK
5301						CALLMONITOR 
5301 cd 78 18			call break_point_state  
5304				endm  
# End of macro CALLMONITOR
5304					endif 
5304			 
5304					NEXTW 
5304 c3 5a 22			jp macro_next 
5307				endm 
# End of macro NEXTW
5307			 
5307			.CARTDEV: 
5307				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5307 66				db WORD_SYS_CORE+82             
5308 b0 53			dw .ENDDEVICE            
530a 08				db 7 + 1 
530b .. 00			db "CARTDEV",0              
5313				endm 
# End of macro CWHEAD
5313			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5313					if DEBUG_FORTH_WORDS_KEY 
5313						DMARK "CDV" 
5313 f5				push af  
5314 3a 28 53			ld a, (.dmark)  
5317 32 b4 fe			ld (debug_mark),a  
531a 3a 29 53			ld a, (.dmark+1)  
531d 32 b5 fe			ld (debug_mark+1),a  
5320 3a 2a 53			ld a, (.dmark+2)  
5323 32 b6 fe			ld (debug_mark+2),a  
5326 18 03			jr .pastdmark  
5328 ..			.dmark: db "CDV"  
532b f1			.pastdmark: pop af  
532c			endm  
# End of macro DMARK
532c						CALLMONITOR 
532c cd 78 18			call break_point_state  
532f				endm  
# End of macro CALLMONITOR
532f					endif 
532f			 
532f					; disable se storage bank selection 
532f			 
532f 3e ff				ld a, SPI_CE_HIGH		; ce high 
5331 32 f0 fb				ld (spi_device), a 
5334			 
5334					; get bank 
5334			 
5334					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5334 cd e3 20			call macro_dsp_valuehl 
5337				endm 
# End of macro FORTH_DSP_VALUEHL
5337			 
5337			;		push hl 
5337			 
5337					; destroy value TOS 
5337			 
5337					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5337 cd 9b 21			call macro_forth_dsp_pop 
533a				endm 
# End of macro FORTH_DSP_POP
533a			 
533a					; one value on hl get other one back 
533a			 
533a			;		pop hl 
533a			 
533a					; active low 
533a			 
533a 0e ff				ld c, 255 
533c			 
533c 7d					ld a, l 
533d					if DEBUG_FORTH_WORDS 
533d						DMARK "CDV" 
533d f5				push af  
533e 3a 52 53			ld a, (.dmark)  
5341 32 b4 fe			ld (debug_mark),a  
5344 3a 53 53			ld a, (.dmark+1)  
5347 32 b5 fe			ld (debug_mark+1),a  
534a 3a 54 53			ld a, (.dmark+2)  
534d 32 b6 fe			ld (debug_mark+2),a  
5350 18 03			jr .pastdmark  
5352 ..			.dmark: db "CDV"  
5355 f1			.pastdmark: pop af  
5356			endm  
# End of macro DMARK
5356						CALLMONITOR 
5356 cd 78 18			call break_point_state  
5359				endm  
# End of macro CALLMONITOR
5359					endif 
5359 fe 00				cp 0 
535b 28 30				jr z, .cset 
535d fe 01				cp 1 
535f 20 02				jr nz, .c2 
5361 cb 81				res 0, c 
5363 fe 02		.c2:		cp 2 
5365 20 02				jr nz, .c3 
5367 cb 89				res 1, c 
5369 fe 03		.c3:		cp 3 
536b 20 02				jr nz, .c4 
536d cb 91				res 2, c 
536f fe 04		.c4:		cp 4 
5371 20 02				jr nz, .c5 
5373 cb 99				res 3, c 
5375 fe 05		.c5:		cp 5 
5377 20 02				jr nz, .c6 
5379 cb a1				res 4, c 
537b fe 06		.c6:		cp 6 
537d 20 02				jr nz, .c7 
537f cb a9				res 5, c 
5381 fe 07		.c7:		cp 7 
5383 20 02				jr nz, .c8 
5385 cb b1				res 6, c 
5387 fe 08		.c8:		cp 8 
5389 20 02				jr nz, .cset 
538b cb b9				res 7, c 
538d 79			.cset:		ld a, c 
538e 32 f3 fb				ld (spi_cartdev),a 
5391			 
5391					if DEBUG_FORTH_WORDS 
5391						DMARK "CD2" 
5391 f5				push af  
5392 3a a6 53			ld a, (.dmark)  
5395 32 b4 fe			ld (debug_mark),a  
5398 3a a7 53			ld a, (.dmark+1)  
539b 32 b5 fe			ld (debug_mark+1),a  
539e 3a a8 53			ld a, (.dmark+2)  
53a1 32 b6 fe			ld (debug_mark+2),a  
53a4 18 03			jr .pastdmark  
53a6 ..			.dmark: db "CD2"  
53a9 f1			.pastdmark: pop af  
53aa			endm  
# End of macro DMARK
53aa						CALLMONITOR 
53aa cd 78 18			call break_point_state  
53ad				endm  
# End of macro CALLMONITOR
53ad					endif 
53ad					NEXTW 
53ad c3 5a 22			jp macro_next 
53b0				endm 
# End of macro NEXTW
53b0			endif 
53b0			 
53b0			.ENDDEVICE: 
53b0			; eof 
53b0			 
# End of file forth_words_device.asm
53b0			 
53b0			; var handler 
53b0			 
53b0			 
53b0			.VARS: 
53b0				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
53b0 78				db WORD_SYS_CORE+100             
53b1 c8 53			dw .V0Q            
53b3 04				db 3 + 1 
53b4 .. 00			db "V0!",0              
53b8				endm 
# End of macro CWHEAD
53b8			;| V0! ( u1 -- )  Store value to v0  | DONE 
53b8			 
53b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53b8 cd e3 20			call macro_dsp_valuehl 
53bb				endm 
# End of macro FORTH_DSP_VALUEHL
53bb			 
53bb 11 b8 fb				ld de, cli_var_array 
53be			 
53be eb					ex de, hl 
53bf 73					ld (hl), e 
53c0 23					inc hl 
53c1 72					ld (hl), d 
53c2			 
53c2					; destroy value TOS 
53c2			 
53c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53c2 cd 9b 21			call macro_forth_dsp_pop 
53c5				endm 
# End of macro FORTH_DSP_POP
53c5			 
53c5				       NEXTW 
53c5 c3 5a 22			jp macro_next 
53c8				endm 
# End of macro NEXTW
53c8			.V0Q: 
53c8				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
53c8 79				db WORD_SYS_CORE+101             
53c9 d9 53			dw .V1S            
53cb 04				db 3 + 1 
53cc .. 00			db "V0@",0              
53d0				endm 
# End of macro CWHEAD
53d0			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
53d0 2a b8 fb				ld hl, (cli_var_array) 
53d3 cd ec 1e				call forth_push_numhl 
53d6			 
53d6				       NEXTW 
53d6 c3 5a 22			jp macro_next 
53d9				endm 
# End of macro NEXTW
53d9			.V1S: 
53d9				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
53d9 7a				db WORD_SYS_CORE+102             
53da f1 53			dw .V1Q            
53dc 04				db 3 + 1 
53dd .. 00			db "V1!",0              
53e1				endm 
# End of macro CWHEAD
53e1			;| V1! ( u1 -- )  Store value to v1 | DONE 
53e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53e1 cd e3 20			call macro_dsp_valuehl 
53e4				endm 
# End of macro FORTH_DSP_VALUEHL
53e4			 
53e4 11 ba fb				ld de, cli_var_array+2 
53e7				 
53e7 eb					ex de, hl 
53e8 73					ld (hl), e 
53e9 23					inc hl 
53ea 72					ld (hl), d 
53eb			 
53eb					; destroy value TOS 
53eb			 
53eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53eb cd 9b 21			call macro_forth_dsp_pop 
53ee				endm 
# End of macro FORTH_DSP_POP
53ee				       NEXTW 
53ee c3 5a 22			jp macro_next 
53f1				endm 
# End of macro NEXTW
53f1			.V1Q: 
53f1				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
53f1 7b				db WORD_SYS_CORE+103             
53f2 02 54			dw .V2S            
53f4 04				db 3 + 1 
53f5 .. 00			db "V1@",0              
53f9				endm 
# End of macro CWHEAD
53f9			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
53f9 2a ba fb				ld hl, (cli_var_array+2) 
53fc cd ec 1e				call forth_push_numhl 
53ff				       NEXTW 
53ff c3 5a 22			jp macro_next 
5402				endm 
# End of macro NEXTW
5402			.V2S: 
5402				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5402 7c				db WORD_SYS_CORE+104             
5403 1a 54			dw .V2Q            
5405 04				db 3 + 1 
5406 .. 00			db "V2!",0              
540a				endm 
# End of macro CWHEAD
540a			;| V2! ( u1 -- )  Store value to v2 | DONE 
540a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
540a cd e3 20			call macro_dsp_valuehl 
540d				endm 
# End of macro FORTH_DSP_VALUEHL
540d			 
540d 11 bc fb				ld de, cli_var_array+4 
5410				 
5410 eb					ex de, hl 
5411 73					ld (hl), e 
5412 23					inc hl 
5413 72					ld (hl), d 
5414			 
5414					; destroy value TOS 
5414			 
5414					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5414 cd 9b 21			call macro_forth_dsp_pop 
5417				endm 
# End of macro FORTH_DSP_POP
5417				       NEXTW 
5417 c3 5a 22			jp macro_next 
541a				endm 
# End of macro NEXTW
541a			.V2Q: 
541a				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
541a 7d				db WORD_SYS_CORE+105             
541b 2b 54			dw .V3S            
541d 04				db 3 + 1 
541e .. 00			db "V2@",0              
5422				endm 
# End of macro CWHEAD
5422			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5422 2a bc fb				ld hl, (cli_var_array+4) 
5425 cd ec 1e				call forth_push_numhl 
5428				       NEXTW 
5428 c3 5a 22			jp macro_next 
542b				endm 
# End of macro NEXTW
542b			.V3S: 
542b				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
542b 7c				db WORD_SYS_CORE+104             
542c 43 54			dw .V3Q            
542e 04				db 3 + 1 
542f .. 00			db "V3!",0              
5433				endm 
# End of macro CWHEAD
5433			;| V3! ( u1 -- )  Store value to v3 | DONE 
5433					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5433 cd e3 20			call macro_dsp_valuehl 
5436				endm 
# End of macro FORTH_DSP_VALUEHL
5436			 
5436 11 be fb				ld de, cli_var_array+6 
5439				 
5439 eb					ex de, hl 
543a 73					ld (hl), e 
543b 23					inc hl 
543c 72					ld (hl), d 
543d			 
543d					; destroy value TOS 
543d			 
543d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
543d cd 9b 21			call macro_forth_dsp_pop 
5440				endm 
# End of macro FORTH_DSP_POP
5440				       NEXTW 
5440 c3 5a 22			jp macro_next 
5443				endm 
# End of macro NEXTW
5443			.V3Q: 
5443				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5443 7d				db WORD_SYS_CORE+105             
5444 54 54			dw .END            
5446 04				db 3 + 1 
5447 .. 00			db "V3@",0              
544b				endm 
# End of macro CWHEAD
544b			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
544b 2a be fb				ld hl, (cli_var_array+6) 
544e cd ec 1e				call forth_push_numhl 
5451				       NEXTW 
5451 c3 5a 22			jp macro_next 
5454				endm 
# End of macro NEXTW
5454			 
5454			 
5454			 
5454			 
5454			 
5454			; end of dict marker 
5454			 
5454 00			.END:    db WORD_SYS_END 
5455 00 00			dw 0 
5457 00				db 0 
5458			 
5458			; use to jp here for user dict words to save on macro expansion  
5458			 
5458			user_dict_next: 
5458				NEXTW 
5458 c3 5a 22			jp macro_next 
545b				endm 
# End of macro NEXTW
545b			 
545b			 
545b			user_exec: 
545b				;    ld hl, <word code> 
545b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
545b				;    call forthexec 
545b				;    jp user_dict_next   (NEXT) 
545b			        ;    <word code bytes> 
545b eb				ex de, hl 
545c 2a 86 f6			ld hl,(os_tok_ptr) 
545f				 
545f				FORTH_RSP_NEXT 
545f cd 93 1e			call macro_forth_rsp_next 
5462				endm 
# End of macro FORTH_RSP_NEXT
5462			 
5462			if DEBUG_FORTH_UWORD 
5462						DMARK "UEX" 
5462 f5				push af  
5463 3a 77 54			ld a, (.dmark)  
5466 32 b4 fe			ld (debug_mark),a  
5469 3a 78 54			ld a, (.dmark+1)  
546c 32 b5 fe			ld (debug_mark+1),a  
546f 3a 79 54			ld a, (.dmark+2)  
5472 32 b6 fe			ld (debug_mark+2),a  
5475 18 03			jr .pastdmark  
5477 ..			.dmark: db "UEX"  
547a f1			.pastdmark: pop af  
547b			endm  
# End of macro DMARK
547b				CALLMONITOR 
547b cd 78 18			call break_point_state  
547e				endm  
# End of macro CALLMONITOR
547e			endif 
547e			 
547e			 
547e			 
547e eb				ex de, hl 
547f 22 86 f6			ld (os_tok_ptr), hl 
5482				 
5482				; Don't use next - Skips the first word in uword. 
5482			 
5482 c3 eb 22			jp exec1 
5485			;	NEXT 
5485			 
5485			 
5485			; eof 
# End of file forth_wordsv4.asm
5485			endif 
5485			;;;;;;;;;;;;;; Debug code 
5485			 
5485			 
5485			;if DEBUG_FORTH_PARSE 
5485 .. 00		.nowordfound: db "No match",0 
548e .. 00		.compword:	db "Comparing word ",0 
549e .. 00		.nextwordat:	db "Next word at",0 
54ab .. 00		.charmatch:	db "Char match",0 
54b6			;endif 
54b6			if DEBUG_FORTH_JP 
54b6			.foundword:	db "Word match. Exec..",0 
54b6			endif 
54b6			;if DEBUG_FORTH_PUSH 
54b6 .. 00		.enddict:	db "Dict end. Push.",0 
54c6 .. 00		.push_str:	db "Pushing string",0 
54d5 .. 00		.push_num:	db "Pushing number",0 
54e4 .. 00		.data_sp:	db "SP:",0 
54e8 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
54fa .. 00		.wordinde:	db "Word in DE (3/0):",0 
550c .. 00		.wordinbc:	db "Word in BC (4/0):",0 
551e			;endif 
551e			;if DEBUG_FORTH_MALLOC 
551e .. 00		.push_malloc:	db "Malloc address",0 
552d			;endif 
552d			 
552d			 
552d			 
552d			; display malloc address and current data stack pointer  
552d			 
552d			malloc_error: 
552d d5				push de 
552e f5				push af 
552f e5				push hl 
5530 cd c7 0c			call clear_display 
5533 11 55 55			ld de, .mallocerr 
5536 3e 00			ld a,0 
5538			;	ld de,os_word_scratch 
5538 cd da 0c			call str_at_display 
553b 3e 11			ld a, display_row_1+17 
553d 11 b4 fe			ld de, debug_mark 
5540 cd da 0c			call str_at_display 
5543 cd ea 0c			call update_display 
5546				;call break_point_state 
5546 cd 24 6b			call cin_wait 
5549			 
5549 3e 20			ld a, ' ' 
554b 32 76 f3			ld (os_view_disable), a 
554e e1				pop hl 
554f f1				pop af 
5550 d1				pop de	 
5551				CALLMONITOR 
5551 cd 78 18			call break_point_state  
5554				endm  
# End of macro CALLMONITOR
5554 c9				ret 
5555			 
5555 .. 00		.mallocerr: 	db "Malloc Error",0 
5562			;if DEBUG_FORTH_PUSH 
5562			display_data_sp: 
5562 f5				push af 
5563			 
5563				; see if disabled 
5563			 
5563 3a 76 f3			ld a, (os_view_disable) 
5566 fe 2a			cp '*' 
5568 28 67			jr z, .skipdsp 
556a			 
556a e5				push hl 
556b e5				push hl 
556c e5			push hl 
556d cd c7 0c			call clear_display 
5570 e1			pop hl 
5571 7c				ld a,h 
5572 21 8a f6			ld hl, os_word_scratch 
5575 cd fc 11			call hexout 
5578 e1				pop hl 
5579 7d				ld a,l 
557a 21 8c f6			ld hl, os_word_scratch+2 
557d cd fc 11			call hexout 
5580 21 8e f6			ld hl, os_word_scratch+4 
5583 3e 00			ld a,0 
5585 77				ld (hl),a 
5586 11 8a f6			ld de,os_word_scratch 
5589 3e 14				ld a, display_row_2 
558b cd da 0c				call str_at_display 
558e 11 e8 54			ld de, .wordinhl 
5591 3e 00			ld a, display_row_1 
5593			 
5593 cd da 0c				call str_at_display 
5596 11 b4 fe			ld de, debug_mark 
5599 3e 11			ld a, display_row_1+17 
559b			 
559b cd da 0c				call str_at_display 
559e			 
559e				; display current data stack pointer 
559e 11 e4 54			ld de,.data_sp 
55a1 3e 1c				ld a, display_row_2 + 8 
55a3 cd da 0c				call str_at_display 
55a6			 
55a6 2a b2 fb			ld hl,(cli_data_sp) 
55a9 e5				push hl 
55aa 7c				ld a,h 
55ab 21 8a f6			ld hl, os_word_scratch 
55ae cd fc 11			call hexout 
55b1 e1				pop hl 
55b2 7d				ld a,l 
55b3 21 8c f6			ld hl, os_word_scratch+2 
55b6 cd fc 11			call hexout 
55b9 21 8e f6			ld hl, os_word_scratch+4 
55bc 3e 00			ld a,0 
55be 77				ld (hl),a 
55bf 11 8a f6			ld de,os_word_scratch 
55c2 3e 1f				ld a, display_row_2 + 11 
55c4 cd da 0c				call str_at_display 
55c7			 
55c7			 
55c7 cd ea 0c			call update_display 
55ca cd 44 0c			call delay1s 
55cd cd 44 0c			call delay1s 
55d0 e1				pop hl 
55d1			.skipdsp: 
55d1 f1				pop af 
55d2 c9				ret 
55d3			 
55d3			display_data_malloc: 
55d3			 
55d3 f5				push af 
55d4 e5				push hl 
55d5 e5				push hl 
55d6 e5			push hl 
55d7 cd c7 0c			call clear_display 
55da e1			pop hl 
55db 7c				ld a,h 
55dc 21 8a f6			ld hl, os_word_scratch 
55df cd fc 11			call hexout 
55e2 e1				pop hl 
55e3 7d				ld a,l 
55e4 21 8c f6			ld hl, os_word_scratch+2 
55e7 cd fc 11			call hexout 
55ea 21 8e f6			ld hl, os_word_scratch+4 
55ed 3e 00			ld a,0 
55ef 77				ld (hl),a 
55f0 11 8a f6			ld de,os_word_scratch 
55f3 3e 14				ld a, display_row_2 
55f5 cd da 0c				call str_at_display 
55f8 11 1e 55			ld de, .push_malloc 
55fb 3e 00			ld a, display_row_1 
55fd			 
55fd cd da 0c				call str_at_display 
5600			 
5600				; display current data stack pointer 
5600 11 e4 54			ld de,.data_sp 
5603 3e 1c				ld a, display_row_2 + 8 
5605 cd da 0c				call str_at_display 
5608			 
5608 2a b2 fb			ld hl,(cli_data_sp) 
560b e5				push hl 
560c 7c				ld a,h 
560d 21 8a f6			ld hl, os_word_scratch 
5610 cd fc 11			call hexout 
5613 e1				pop hl 
5614 7d				ld a,l 
5615 21 8c f6			ld hl, os_word_scratch+2 
5618 cd fc 11			call hexout 
561b 21 8e f6			ld hl, os_word_scratch+4 
561e 3e 00			ld a,0 
5620 77				ld (hl),a 
5621 11 8a f6			ld de,os_word_scratch 
5624 3e 1f				ld a, display_row_2 + 11 
5626 cd da 0c				call str_at_display 
5629			 
5629 cd ea 0c			call update_display 
562c cd 44 0c			call delay1s 
562f cd 44 0c			call delay1s 
5632 e1				pop hl 
5633 f1				pop af 
5634 c9				ret 
5635			;endif 
5635			 
5635			include "forth_autostart.asm" 
5635			; list of commands to perform at system start up 
5635			 
5635			startcmds: 
5635			;	dw test11 
5635			;	dw test12 
5635			;	dw test13 
5635			;	dw test14 
5635			;	dw test15 
5635			;	dw test16 
5635			;	dw test17 
5635			;	dw ifthtest1 
5635			;	dw ifthtest2 
5635			;	dw ifthtest3 
5635			;	dw mmtest1 
5635			;	dw mmtest2 
5635			;	dw mmtest3 
5635			;	dw mmtest4 
5635			;	dw mmtest5 
5635			;	dw mmtest6 
5635			;	dw iftest1 
5635			;	dw iftest2 
5635			;	dw iftest3 
5635			;	dw looptest1 
5635			;	dw looptest2 
5635			;	dw test1 
5635			;	dw test2 
5635			;	dw test3 
5635			;	dw test4 
5635			;	dw game2r 
5635			;	dw game2b1 
5635			;	dw game2b2 
5635			 
5635				; start up words that are actually useful 
5635			 
5635 95 56			dw longread 
5637 dc 56			dw clrstack 
5639 0f 57			dw type 
563b ff 58			dw stest 
563d 33 57			dw strncpy 
563f 95 58			dw list 
5641 94 57			dw start1 
5643 a6 57			dw start2 
5645			;	dw start3 
5645 b9 57			dw start3b 
5647 35 58			dw start3c 
5649			 
5649				; (unit) testing words 
5649			 
5649 76 59			dw mtesta 
564b 2b 5a			dw mtestb 
564d ce 5a			dw mtestc 
564f 83 5b			dw mtestd 
5651 27 5c			dw mteste 
5653			 
5653				; demo/game words 
5653			 
5653 33 63		        dw game3w 
5655 61 63		        dw game3p 
5657 7f 63		        dw game3sc 
5659 b0 63		        dw game3vsi 
565b dc 63		        dw game3vs 
565d				 
565d 26 61			dw game2b 
565f 94 61			dw game2bf 
5661 de 61			dw game2mba 
5663 74 62			dw game2mbas 
5665 b6 62			dw game2mb 
5667			 
5667 e7 5d			dw game1 
5669 f8 5d			dw game1a 
566b 5a 5e			dw game1b 
566d 8f 5e			dw game1c 
566f c5 5e			dw game1d 
5671 f6 5e			dw game1s 
5673 0a 5f			dw game1t 
5675 1f 5f			dw game1f 
5677 53 5f			dw game1z 
5679 97 5f			dw game1zz 
567b			 
567b dd 5c			dw test5 
567d 15 5d			dw test6 
567f 4d 5d			dw test7 
5681 61 5d			dw test8 
5683 8d 5d			dw test9 
5685 a3 5d			dw test10 
5687				 
5687 6e 60		        dw ssv5 
5689 52 60		        dw ssv4 
568b 36 60		        dw ssv3 
568d 00 60		        dw ssv2 
568f 87 60		        dw ssv1 
5691 cf 60		        dw ssv1cpm 
5693			;	dw keyup 
5693			;	dw keydown 
5693			;	dw keyleft 
5693			;	dw keyright 
5693			;	dw 	keyf1 
5693			;	dw keyf2 
5693			;	dw keyf3 
5693			;	dw keyf4 
5693			;	dw keyf5 
5693			;	dw keyf6 
5693			;	dw keyf7 
5693			;	dw keyf8 
5693			;	dw keyf9 
5693			;	dw keyf10 
5693			;	dw keyf11 
5693			;	dw keyf12 
5693			;	dw keytab 
5693			;	dw keycr 
5693			;	dw keyhome 
5693			;	dw keyend 
5693			;	dw keybs 
5693 00 00			db 0, 0	 
5695			 
5695			 
5695			; Long read of currently open file 
5695 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
56dc			 
56dc			; clear stack  
56dc			 
56dc .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
570f			 
570f			; type ( addr count - ) 
570f .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5733			 
5733			; some direct memory words 
5733			; strncpy ( len t f -- t ) 
5733			 
5733 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5794			 
5794 .. 00		start1:     	db ": bpon $0000 bp ;",0 
57a6 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
57b9 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5835 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5895			 
5895			 
5895			; a handy word to list items on the stack 
5895			 
5895 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
58ff			 
58ff			 
58ff			; test stack  
58ff			; rnd8 stest 
58ff			 
58ff .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5976			 
5976			; random malloc and free cycles 
5976			 
5976 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5a2b			 
5a2b			; fixed malloc and free cycles 
5a2b			 
5a2b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5ace			 
5ace			; fixed double string push and drop cycle  
5ace			 
5ace .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5b83			 
5b83			; consistent fixed string push and drop cycle  
5b83			 
5b83 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5c27			 
5c27 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5cdd			 
5cdd			;test1:		db ": aa 1 2 3 ;", 0 
5cdd			;test2:     	db "111 aa 888 999",0 
5cdd			;test3:     	db ": bb 77 ;",0 
5cdd			;test4:     	db "$02 $01 do i . loop bb",0 
5cdd			 
5cdd .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5d15 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5d4d .. 00		test7:     	db ": box hline vline ;",0 
5d61 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5d8d .. 00		test9:     	db ": sw $01 adsp world ;",0 
5da3 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5dc8 .. 00		test11:     	db "hello create .",0 
5dd7 .. 00		test12:     	db "hello2 create .",0 
5de7			 
5de7			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5de7			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5de7			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5de7			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5de7			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5de7			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5de7			 
5de7			;iftest1:     	db "$0001 IF cls .",0 
5de7			;iftest2:     	db "$0000 IF cls .",0 
5de7			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5de7			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5de7			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5de7			 
5de7			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5de7			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5de7			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5de7			 
5de7			 
5de7			 
5de7			; a small guess the number game 
5de7			 
5de7 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5df8 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5e5a			 
5e5a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5e8f .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ec5 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5ef6 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5f0a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5f1f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5f53 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5f97			 
5f97			; Using 'ga' save a high score across multiple runs using external storage 
5f97			 
5f97 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6000			 
6000			 
6000			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6000			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6000			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6000			 
6000			; simple screen saver to test code memory reuse to destruction 
6000			 
6000 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6036 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6052 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
606e .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6087 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
60cf .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6126			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6126			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6126			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6126			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6126			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6126			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6126			 
6126			 
6126			 
6126			; minesweeper/battleship finding game 
6126			; draws a game board of random ship/mine positions 
6126			; user enters coords to see if it hits on 
6126			; game ends when all are hit 
6126			; when hit or miss says how many may be in the area 
6126			 
6126			; setup the game board and then hide it 
6126 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6194 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
61de			; prompt for where to target 
61de .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6274 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6299			; TODO see if the entered coords hits or misses pushes char hit of miss 
6299 .. 00		game2mbht:      db ": mbckht nop ;",0 
62a8 .. 00		game2mbms:      db ": mbcms nop ;",0 
62b6			; TODO how many might be near by 
62b6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6333			 
6333			; Game 3 
6333			 
6333			; Vert scroller ski game - avoid the trees! 
6333			 
6333			; v0 score (ie turns) 
6333			; v1 player pos 
6333			; v2 left wall 
6333			; v3 right wall 
6333			 
6333			; Draw side walls randomly 
6333			 
6333 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6361			 
6361			; Draw player 
6361 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
637f			 
637f			; TODO Get Key 
637f			 
637f			; TODO Move left right 
637f			 
637f			; scroll and move walls a bit 
637f			 
637f .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
63b0			 
63b0			; main game loop 
63b0			 
63b0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
63dc .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
641b			 
641b			; key board defs 
641b			 
641b .. 00		keyup:       db ": keyup $05 ;",0 
6429 .. 00		keydown:       db ": keydown $0a ;",0 
6439 .. 00		keyleft:       db ": keyleft $0b ;",0 
6449 .. 00		keyright:       db ": keyright $0c ;",0 
645a .. 00		keyf1:       db ": keyf1 $10 ;",0 
6468 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6476 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6484 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6492 .. 00		keyf5:       db ": keyf5 $14 ;",0 
64a0 .. 00		keyf6:       db ": keyf6 $15 ;",0 
64ae .. 00		keyf7:       db ": keyf7 $16 ;",0 
64bc .. 00		keyf8:       db ": keyf8 $17 ;",0 
64ca .. 00		keyf9:       db ": keyf9 $18 ;",0 
64d8 .. 00		keyf10:       db ": keyf10 $19 ;",0 
64e7 .. 00		keyf11:       db ": keyf11 $1a ;",0 
64f6 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6505			 
6505 .. 00		keytab:       db ": keytab $09 ;",0 
6514 .. 00		keycr:       db ": keycr $0d ;",0 
6522 .. 00		keyhome:       db ": keyhome $0e ;",0 
6532 .. 00		keyend:       db ": keyend $0f ;",0 
6541 .. 00		keybs:       db ": keybs $08 ;",0 
654f			 
654f			   
654f			 
654f			 
654f			 
654f			; eof 
# End of file forth_autostart.asm
654f			 
654f .. 00		sprompt1: db "Startup load...",0 
655f .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6575			 
6575			 
6575			 
6575			 
6575			forth_startup: 
6575 21 35 56			ld hl, startcmds 
6578 3e 00			ld a, 0 
657a 32 ab f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
657d			 
657d e5			.start1:	push hl 
657e cd c7 0c			call clear_display 
6581 11 4f 65			ld de, sprompt1 
6584 3e 00		        ld a, display_row_1 
6586 cd da 0c			call str_at_display 
6589 11 5f 65			ld de, sprompt2 
658c 3e 14		        ld a, display_row_2 
658e cd da 0c			call str_at_display 
6591 e1				pop hl 
6592 e5				push hl 
6593 5e				ld e,(hl) 
6594 23				inc hl 
6595 56				ld d,(hl) 
6596 3e 28		        ld a, display_row_3 
6598 cd da 0c			call str_at_display 
659b cd ea 0c			call update_display 
659e			 
659e			 
659e 3a ab f7			ld a, (os_last_cmd) 
65a1 fe 00			cp 0 
65a3 28 05			jr z, .startprompt 
65a5 cd 38 0c			call delay250ms 
65a8 18 24			jr .startdo 
65aa				 
65aa				 
65aa			 
65aa			.startprompt: 
65aa			 
65aa 3e 4f			ld a,display_row_4 + display_cols - 1 
65ac 11 62 1e		        ld de, endprg 
65af cd da 0c			call str_at_display 
65b2 cd ea 0c			call update_display 
65b5 cd 44 0c			call delay1s 
65b8 cd 24 6b			call cin_wait 
65bb						 
65bb fe 2a			cp '*' 
65bd 28 5e			jr z, .startupend1 
65bf fe 23			cp '#' 
65c1 20 07			jr nz, .startno 
65c3 3e 01			ld a, 1 
65c5 32 ab f7			ld (os_last_cmd),a 
65c8 18 04			jr .startdo 
65ca fe 31		.startno:	cp '1' 
65cc 28 3a			jr z,.startnxt  
65ce			 
65ce				; exec startup line 
65ce			.startdo:	 
65ce e1				pop hl 
65cf e5				push hl 
65d0				 
65d0 5e				ld e,(hl) 
65d1 23				inc hl 
65d2 56				ld d,(hl) 
65d3 eb				ex de,hl 
65d4			 
65d4 e5				push hl 
65d5			 
65d5 3e 00			ld a, 0 
65d7				;ld a, FORTH_END_BUFFER 
65d7 cd 64 13			call strlent 
65da 23				inc hl   ; include zero term to copy 
65db 06 00			ld b,0 
65dd 4d				ld c,l 
65de e1				pop hl 
65df 11 85 f3			ld de, scratch 
65e2 ed b0			ldir 
65e4			 
65e4			 
65e4 21 85 f3			ld hl, scratch 
65e7 cd a8 22			call forthparse 
65ea cd e8 22			call forthexec 
65ed cd fa 21			call forthexec_cleanup 
65f0			 
65f0 3e 3c			ld a, display_row_4 
65f2 11 06 1c			ld de, endprog 
65f5			 
65f5 cd ea 0c			call update_display		 
65f8			 
65f8 3a ab f7			ld a, (os_last_cmd) 
65fb fe 00			cp 0 
65fd 20 09			jr nz, .startnxt 
65ff cd 64 1e			call next_page_prompt 
6602 cd c7 0c		        call clear_display 
6605 cd ea 0c			call update_display		 
6608			 
6608				; move onto next startup line? 
6608			.startnxt: 
6608			 
6608 cd 38 0c			call delay250ms 
660b e1				pop hl 
660c			 
660c 23				inc hl 
660d 23				inc hl 
660e			 
660e e5				push hl 
660f 5e				ld e, (hl) 
6610 23				inc hl 
6611 56				ld d, (hl) 
6612 e1				pop hl 
6613				; TODO replace 0 test 
6613			 
6613 eb				ex de, hl 
6614 cd 24 0f			call ishlzero 
6617			;	ld a,e 
6617			;	add d 
6617			;	cp 0    ; any left to do? 
6617 eb				ex de, hl 
6618 c2 7d 65			jp nz, .start1 
661b 18 01			jr .startupend 
661d			 
661d e1			.startupend1: pop hl 
661e			.startupend: 
661e			 
661e cd c7 0c			call clear_display 
6621 cd ea 0c			call update_display 
6624 c9				ret 
6625			 
6625			 
6625			; stack over and underflow checks 
6625			 
6625			; init the words to detect the under/overflow 
6625			 
6625			chk_stk_init: 
6625				; a vague random number to check so we dont get any "lucky" hits 
6625 3e 2d			ld a, 45 
6627 6f				ld l, a 
6628 00				nop 
6629 3e 17			ld a, 23 
662b 67				ld h, a 
662c			 
662c 22 6c f3			ld (chk_word), hl     ; the word we need to check against 
662f			 
662f			;	ld (chk_stund), hl	; stack points.... 
662f 22 fd fe			ld (chk_stovr), hl 
6632 22 b0 fb			ld (chk_ret_und), hl 
6635 22 6e fb			ld (chk_ret_ovr), hl 
6638 22 ec fa			ld (chk_loop_ovr), hl 
663b 22 ea f8			ld (chk_data_ovr), hl 
663e c9				ret 
663f				 
663f			check_stacks: 
663f				; check all stack words 
663f			 
663f e5				push hl 
6640 d5				push de 
6641			 
6641			;	ld de,(chk_word) 
6641			;	ld hl, (chk_stund)	; stack points.... 
6641			;	if DEBUG_STK_FAULT 
6641			;		DMARK "FAa" 
6641			;		CALLMONITOR 
6641			;	endif 
6641			;	call cmp16 
6641			;	jp z, .chk_faulta 
6641			; 
6641			;	ld de, sfaultsu 
6641			;	jp .chk_fault 
6641			 
6641 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6644 ed 5b 6c f3		ld de,(chk_word) 
6648				if DEBUG_STK_FAULT 
6648					DMARK "FAb" 
6648					CALLMONITOR 
6648				endif 
6648 cd 19 0f			call cmp16 
664b 28 06			jr z, .chk_fault1 
664d 11 ee 66			ld de, sfaultso 
6650 c3 a2 66			jp .chk_fault 
6653			.chk_fault1:  
6653 2a b0 fb			ld hl, (chk_ret_und) 
6656 ed 5b 6c f3		ld de,(chk_word) 
665a				if DEBUG_STK_FAULT 
665a					DMARK "FAU" 
665a					CALLMONITOR 
665a				endif 
665a cd 19 0f			call cmp16 
665d ca 66 66			jp z, .chk_fault2 
6660 11 fe 66			ld de, sfaultru 
6663 c3 a2 66			jp .chk_fault 
6666			.chk_fault2:  
6666 2a 6e fb			ld hl, (chk_ret_ovr) 
6669 ed 5b 6c f3		ld de,(chk_word) 
666d				if DEBUG_STK_FAULT 
666d					DMARK "FA1" 
666d					CALLMONITOR 
666d				endif 
666d cd 19 0f			call cmp16 
6670 ca 79 66			jp z, .chk_fault3 
6673 11 0c 67			ld de, sfaultro 
6676 c3 a2 66			jp .chk_fault 
6679			.chk_fault3:  
6679 2a ec fa			ld hl, (chk_loop_ovr) 
667c ed 5b 6c f3		ld de,(chk_word) 
6680				if DEBUG_STK_FAULT 
6680					DMARK "FA2" 
6680					CALLMONITOR 
6680				endif 
6680 cd 19 0f			call cmp16 
6683 ca 8c 66			jp z, .chk_fault4 
6686 11 26 67			ld de, sfaultlo 
6689 c3 a2 66			jp .chk_fault 
668c			.chk_fault4:  
668c 2a ea f8			ld hl, (chk_data_ovr) 
668f ed 5b 6c f3		ld de,(chk_word) 
6693				if DEBUG_STK_FAULT 
6693					DMARK "FA3" 
6693					CALLMONITOR 
6693				endif 
6693 cd 19 0f			call cmp16 
6696 ca 9f 66			jp z, .chk_fault5 
6699 11 40 67			ld de, sfaultdo 
669c c3 a2 66			jp .chk_fault 
669f			 
669f			 
669f			.chk_fault5:  
669f d1				pop de 
66a0 e1				pop hl 
66a1			 
66a1 c9				ret 
66a2			 
66a2 cd c7 0c		.chk_fault: 	call clear_display 
66a5 3e 14				ld a, display_row_2 
66a7 cd da 0c				call str_at_display 
66aa 11 d0 66				   ld de, .stackfault 
66ad 3e 00				ld a, display_row_1 
66af cd da 0c				call str_at_display 
66b2 11 b4 fe				    ld de, debug_mark 
66b5 3e 11				ld a, display_row_1+17 
66b7 cd da 0c				call str_at_display 
66ba cd ea 0c				call update_display 
66bd			 
66bd				; prompt before entering montior for investigating issue 
66bd			 
66bd 3e 3c			ld a, display_row_4 
66bf 11 06 1c			ld de, endprog 
66c2			 
66c2 cd ea 0c			call update_display		 
66c5			 
66c5 cd 64 1e			call next_page_prompt 
66c8			 
66c8 d1				pop de 
66c9 e1				pop hl 
66ca cd 5a 1c				call monitor 
66cd c3 51 1b				jp warmstart 
66d0					;jp 0 
66d0					;halt 
66d0			 
66d0			 
66d0			 
66d0 .. 00		.stackfault: 	db "Stack fault:",0 
66dd			 
66dd .. 00		sfaultsu: 	db	"Stack under flow",0 
66ee .. 00		sfaultso: 	db	"Stack over flow",0 
66fe .. 00		sfaultru:	db "RTS underflow",0 
670c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6726 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6740 .. 00		sfaultdo:	db "DTS overflow", 0 
674d			 
674d			 
674d			fault_dsp_under: 
674d 11 5f 67			ld de, .dsp_under 
6750 c3 0f 68			jp .show_fault 
6753			 
6753			fault_rsp_under: 
6753 11 6d 67			ld de, .rsp_under 
6756 c3 0f 68			jp .show_fault 
6759			fault_loop_under: 
6759 11 7b 67			ld de, .loop_under 
675c c3 0f 68			jp .show_fault 
675f			 
675f .. 00		.dsp_under: db "DSP Underflow",0 
676d .. 00		.rsp_under: db "RSP Underflow",0 
677b .. 00		.loop_under: db "LOOP Underflow",0 
678a			 
678a			 
678a d5			type_faultn: 	push de 
678b e5					push hl 
678c cd c7 0c				call clear_display 
678f 11 b6 67				   ld de, .typefaultn 
6792 3e 00				ld a, display_row_1 
6794 cd da 0c				call str_at_display 
6797 11 b4 fe				    ld de, debug_mark 
679a 3e 11				ld a, display_row_1+17 
679c cd da 0c				call str_at_display 
679f cd ea 0c				call update_display 
67a2			 
67a2				; prompt before entering montior for investigating issue 
67a2			 
67a2 3e 3c			ld a, display_row_4 
67a4 11 06 1c			ld de, endprog 
67a7			 
67a7 cd ea 0c			call update_display		 
67aa			 
67aa cd 64 1e			call next_page_prompt 
67ad			 
67ad e5					push hl 
67ae d5					push de 
67af cd 5a 1c				call monitor 
67b2 c3 51 1b				jp warmstart 
67b5 76					halt 
67b6			 
67b6			 
67b6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
67cd			 
67cd d5			type_faults: 	push de 
67ce e5					push hl 
67cf cd c7 0c				call clear_display 
67d2 11 f8 67				   ld de, .typefaults 
67d5 3e 00				ld a, display_row_1 
67d7 cd da 0c				call str_at_display 
67da 11 b4 fe				    ld de, debug_mark 
67dd 3e 11				ld a, display_row_1+17 
67df cd da 0c				call str_at_display 
67e2 cd ea 0c				call update_display 
67e5			 
67e5				; prompt before entering montior for investigating issue 
67e5			 
67e5 3e 3c			ld a, display_row_4 
67e7 11 06 1c			ld de, endprog 
67ea			 
67ea cd ea 0c			call update_display		 
67ed			 
67ed cd 64 1e			call next_page_prompt 
67f0			 
67f0 e1					pop hl 
67f1 d1					pop de 
67f2 cd 5a 1c				call monitor 
67f5 c3 51 1b				jp warmstart 
67f8			 
67f8			 
67f8 .. 00		.typefaults: db "STR Type Expected TOS!",0 
680f			 
680f			.show_fault: 	 
680f d5					push de 
6810 cd c7 0c				call clear_display 
6813 d1					pop de 
6814 3e 00				ld a, display_row_1 
6816 cd da 0c				call str_at_display 
6819 11 b4 fe				    ld de, debug_mark 
681c 3e 11				ld a, display_row_1+17 
681e cd da 0c				call str_at_display 
6821 cd ea 0c				call update_display 
6824			 
6824				; prompt before entering montior for investigating issue 
6824			 
6824 3e 3c			ld a, display_row_4 
6826 11 06 1c			ld de, endprog 
6829			 
6829 cd ea 0c			call update_display		 
682c			 
682c cd 64 1e			call next_page_prompt 
682f			 
682f e1					pop hl 
6830 d1					pop de 
6831 cd 5a 1c				call monitor 
6834			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6834			; TODO Make optional fault restart to cli or warm boot? 
6834					;jp warmstart 
6834 c3 ac 1b				jp cli 
6837 76					halt 
6838			 
6838			; handle the auto run of code from files in storage 
6838			 
6838			 
6838			if STORAGE_SE 
6838			 
6838 .. 00		sprompt3: db "Loading from start-up file?:",0 
6855 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6866			 
6866			 
6866			forth_autoload: 
6866			 
6866				; load block 0 of store 1 
6866				 
6866 3e fe			ld a, $fe      ; bit 0 clear 
6868 32 f0 fb			ld (spi_device), a 
686b			 
686b cd 82 04			call storage_get_block_0 
686e			 
686e 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
6871			 
6871 fe 00			cp 0 
6873 c8				ret z     ; auto start not enabled 
6874			 
6874 cd c7 0c			call clear_display 
6877			 
6877				; set bank 
6877			 
6877 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
687a 32 f0 fb				ld (spi_device), a 
687d			 
687d				; get file id to load from and get the file name to display 
687d			 
687d 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
6880			 
6880 2e 00				ld l, 0 
6882 67					ld h, a 
6883 11 07 fc				ld de, store_page 
6886			 
6886					if DEBUG_FORTH_WORDS 
6886						DMARK "ASp" 
6886 f5				push af  
6887 3a 9b 68			ld a, (.dmark)  
688a 32 b4 fe			ld (debug_mark),a  
688d 3a 9c 68			ld a, (.dmark+1)  
6890 32 b5 fe			ld (debug_mark+1),a  
6893 3a 9d 68			ld a, (.dmark+2)  
6896 32 b6 fe			ld (debug_mark+2),a  
6899 18 03			jr .pastdmark  
689b ..			.dmark: db "ASp"  
689e f1			.pastdmark: pop af  
689f			endm  
# End of macro DMARK
689f						CALLMONITOR 
689f cd 78 18			call break_point_state  
68a2				endm  
# End of macro CALLMONITOR
68a2					endif 
68a2 cd 2a 09				call storage_read 
68a5			 
68a5					if DEBUG_FORTH_WORDS 
68a5						DMARK "ASr" 
68a5 f5				push af  
68a6 3a ba 68			ld a, (.dmark)  
68a9 32 b4 fe			ld (debug_mark),a  
68ac 3a bb 68			ld a, (.dmark+1)  
68af 32 b5 fe			ld (debug_mark+1),a  
68b2 3a bc 68			ld a, (.dmark+2)  
68b5 32 b6 fe			ld (debug_mark+2),a  
68b8 18 03			jr .pastdmark  
68ba ..			.dmark: db "ASr"  
68bd f1			.pastdmark: pop af  
68be			endm  
# End of macro DMARK
68be						CALLMONITOR 
68be cd 78 18			call break_point_state  
68c1				endm  
# End of macro CALLMONITOR
68c1					endif 
68c1			 
68c1 cd 24 0f				call ishlzero 
68c4 c8					ret z             ; file not found 
68c5			 
68c5 3e 1e				ld a, display_row_2 + 10 
68c7 11 0a fc				ld de, store_page+3 
68ca cd da 0c				call str_at_display 
68cd				 
68cd			; 
68cd			 
68cd 3e 05			ld a, display_row_1+5 
68cf 11 38 68			ld de, sprompt3 
68d2 cd da 0c			call str_at_display 
68d5 3e 37			ld a, display_row_3+15 
68d7 11 55 68			ld de, sprompt4 
68da cd da 0c			call str_at_display 
68dd			 
68dd cd ea 0c			call update_display 
68e0			 
68e0 cd 24 6b			call cin_wait 
68e3 fe 6e			cp 'n' 
68e5 c8				ret z 
68e6 fe 4e			cp 'N' 
68e8 c8				ret z 
68e9			 
68e9 cd 44 0c			call delay1s 
68ec			 
68ec 3a 09 fc			ld a, (store_page+2) 
68ef 32 f8 fb			ld (store_openmaxext), a    ; save count of ext 
68f2 3e 01			ld a, 1  
68f4 32 f9 fb			ld (store_openext), a    ; save count of ext 
68f7			 
68f7			.autof:  
68f7 6f				ld l , a 
68f8				 
68f8 3a 07 fc			ld a, (store_page) 
68fb 67				ld h, a	 
68fc 11 07 fc			ld de, store_page 
68ff					if DEBUG_FORTH_WORDS 
68ff						DMARK "ASl" 
68ff f5				push af  
6900 3a 14 69			ld a, (.dmark)  
6903 32 b4 fe			ld (debug_mark),a  
6906 3a 15 69			ld a, (.dmark+1)  
6909 32 b5 fe			ld (debug_mark+1),a  
690c 3a 16 69			ld a, (.dmark+2)  
690f 32 b6 fe			ld (debug_mark+2),a  
6912 18 03			jr .pastdmark  
6914 ..			.dmark: db "ASl"  
6917 f1			.pastdmark: pop af  
6918			endm  
# End of macro DMARK
6918						CALLMONITOR 
6918 cd 78 18			call break_point_state  
691b				endm  
# End of macro CALLMONITOR
691b					endif 
691b cd 2a 09				call storage_read 
691e cd 24 0f			call ishlzero 
6921 c8				ret z 
6922			;	jr z, .autoend 
6922			 
6922					if DEBUG_FORTH_WORDS 
6922						DMARK "ASc" 
6922 f5				push af  
6923 3a 37 69			ld a, (.dmark)  
6926 32 b4 fe			ld (debug_mark),a  
6929 3a 38 69			ld a, (.dmark+1)  
692c 32 b5 fe			ld (debug_mark+1),a  
692f 3a 39 69			ld a, (.dmark+2)  
6932 32 b6 fe			ld (debug_mark+2),a  
6935 18 03			jr .pastdmark  
6937 ..			.dmark: db "ASc"  
693a f1			.pastdmark: pop af  
693b			endm  
# End of macro DMARK
693b						CALLMONITOR 
693b cd 78 18			call break_point_state  
693e				endm  
# End of macro CALLMONITOR
693e					endif 
693e 11 09 fc			ld de, store_page+2 
6941 3e 3c			ld a, display_row_4 
6943 cd da 0c			call str_at_display 
6946			 
6946 cd ea 0c			call update_display 
6949 cd 38 0c			call delay250ms 
694c			 
694c			 
694c			 
694c 21 09 fc			ld hl, store_page+2 
694f cd a8 22			call forthparse 
6952 cd e8 22			call forthexec 
6955 cd fa 21			call forthexec_cleanup 
6958			 
6958				 
6958 3a f9 fb			ld a, (store_openext) 
695b 3c				inc a 
695c 32 f9 fb			ld (store_openext), a    ; save count of ext 
695f			 
695f 18 96			jr .autof 
6961			;.autofdone: 
6961			; 
6961			;		if DEBUG_FORTH_WORDS 
6961			;			DMARK "ASx" 
6961			;			CALLMONITOR 
6961			;		endif 
6961			;;	call clear_display 
6961			;	ret 
6961			 
6961			 
6961			 
6961			endif 
6961			 
6961			 
6961			; eof 
# End of file forth_kernel.asm
6961			;include "nascombasic.asm" 
6961			 
6961			 
6961			; find out where the code ends if loaded into RAM (for SC114) 
6961			;endofcode:  
6961			;	nop 
6961			 
6961			 
6961			; eof 
6961			 
# End of file main.asm
6961			include "firmware_lcd_4x20.asm" 
6961			; **********************************************************************  
6961			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6961			; **********************************************************************  
6961			;  
6961			; **  Written as a Small Computer Monitor App  
6961			; **  www.scc.me.uk  
6961			;  
6961			; History  
6961			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6961			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6961			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6961			;  
6961			; **********************************************************************  
6961			;  
6961			; This program is an example of one of the methods of interfacing an   
6961			; alphanumeric LCD module.   
6961			;  
6961			; In this example the display is connected to either a Z80 PIO or a   
6961			; simple 8-bit output port.   
6961			;  
6961			; This interfacing method uses 4-bit data mode and uses time delays  
6961			; rather than polling the display's ready status. As a result the   
6961			; interface only requires 6 simple output lines:  
6961			;   Output bit 0 = not used  
6961			;   Output bit 1 = not used  
6961			;   Output bit 2 = RS         High = data, Low = instruction  
6961			;   Output bit 3 = E          Active high  
6961			;   Output bit 4 = DB4  
6961			;   Output bit 5 = DB5  
6961			;   Output bit 6 = DB6  
6961			;   Output bit 7 = DB7  
6961			; Display's R/W is connected to 0v so it is always in write mode  
6961			;  
6961			; This set up should work with any system supporting the RC2014 bus  
6961			  
6961			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6961			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6961			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6961			;  
6961			; **********************************************************************  
6961			  
6961			; **********************************************************************  
6961			; **  Constants  
6961			; **********************************************************************  
6961			; LCD constants required by LCD support module  
6961			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6961			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6961			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6961			kLCDWidth:  EQU display_cols             ;Width in characters  
6961			  
6961			; **********************************************************************  
6961			; **  Code library usage  
6961			; **********************************************************************  
6961			  
6961			; send character to current cursor position  
6961			; wraps and/or scrolls screen automatically  
6961			  
6961			  
6961			lcd_init:  
6961			  
6961			; SCMonAPI functions used  
6961			  
6961			; Alphanumeric LCD functions used  
6961			; no need to specify specific functions for this module  
6961			  
6961 3e cf		            LD   A, 11001111b  
6963 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6965 3e 00		            LD   A, 00000000b  
6967 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6969			  
6969			; Initialise alphanumeric LCD module  
6969 cd e2 69		            CALL fLCD_Init      ;Initialise LCD module  
696c			  
696c c9				ret  
696d			  
696d			;  
696d			;;  
696d			; lcd functions  
696d			;  
696d			;  
696d			  
696d			; what is at cursor position   
696d			  
696d			;get_cursor:	ld de, (cursor_row)   ;  row + col  
696d			;		call curptr  
696d			;		ret  
696d			  
696d			  
696d			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
696d			  
696d			curptr:  
696d c5				push bc  
696e 21 4a fe			ld hl, display_fb0  
6971			cpr:	  
6971				; loop for cursor whole row  
6971 0e 14			ld c, display_cols  
6973 23			cpr1:	inc hl  
6974 0d				dec c  
6975 20 fc			jr nz, cpr1  
6977 05				dec b  
6978 20 f7			jr nz, cpr  
697a			  
697a				; add col	  
697a			  
697a 23			cpr2:	inc hl  
697b 1d				dec e  
697c 20 fc			jr nz, cpr2  
697e			  
697e c1				pop bc  
697f c9				ret  
6980				  
6980			  
6980			  
6980			  
6980			  
6980			; write the frame buffer given in hl to hardware   
6980 22 52 fd		write_display: ld (display_write_tmp), hl 	   
6983 3e 00			ld a, kLCD_Line1  
6985 cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6988 06 14			ld b, display_cols  
698a ed 5b 52 fd		ld de, (display_write_tmp)  
698e cd da 69			call write_len_string  
6991				  
6991				  
6991 2a 52 fd			ld hl, (display_write_tmp)  
6994 11 14 00			ld de, display_cols  
6997 19				add hl,de  
6998 22 52 fd			ld (display_write_tmp),hl  
699b			  
699b				  
699b 3e 40			ld a, kLCD_Line2  
699d cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69a0 06 14			ld b, display_cols  
69a2 ed 5b 52 fd		ld de, (display_write_tmp)  
69a6 cd da 69			call write_len_string  
69a9				  
69a9 2a 52 fd			ld hl, (display_write_tmp)  
69ac 11 14 00			ld de, display_cols  
69af 19				add hl,de  
69b0 22 52 fd			ld (display_write_tmp),hl  
69b3			  
69b3				  
69b3 3e 14			ld a, kLCD_Line3  
69b5 cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69b8 06 14			ld b, display_cols  
69ba ed 5b 52 fd		ld de, (display_write_tmp)  
69be cd da 69			call write_len_string  
69c1				  
69c1 2a 52 fd			ld hl, (display_write_tmp)  
69c4 11 14 00			ld de, display_cols  
69c7 19				add hl,de  
69c8 22 52 fd			ld (display_write_tmp),hl  
69cb			  
69cb				  
69cb 3e 54			ld a, kLCD_Line4  
69cd cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69d0 06 14			ld b, display_cols  
69d2 ed 5b 52 fd		ld de, (display_write_tmp)  
69d6 cd da 69			call write_len_string  
69d9 c9					ret  
69da				  
69da				; write out a fixed length string given in b from de  
69da			  
69da 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
69db cd 2c 6a		            CALL fLCD_Data      ;Write character to display  
69de 13				inc de  
69df 10 f9			djnz write_len_string  
69e1 c9				ret  
69e2			  
69e2			; Some other things to do  
69e2			;            LD   A, kLCD_Clear ;Display clear  
69e2			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
69e2			;            LD   A, kLCD_Under ;Display on with underscore cursor  
69e2			;            LD   A, kLCD_On     ;Display on with no cursor  
69e2			;            ;LD   A, kLCD_Off   ;Display off  
69e2			;            CALL fLCD_Inst      ;Send instruction to display  
69e2			;  
69e2			;  
69e2			;            halt  
69e2			;  
69e2			;  
69e2			;MsgHello:   DB  "Hello World!",0  
69e2			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
69e2			  
69e2			; Custom characters 5 pixels wide by 8 pixels high  
69e2			; Up to 8 custom characters can be defined  
69e2			;BitMaps:      
69e2			;; Character 0x00 = Battery icon  
69e2			;            DB  01110b  
69e2			;            DB  11011b  
69e2			;            DB  10001b  
69e2			;            DB  10001b  
69e2			;            DB  11111b  
69e2			;            DB  11111b  
69e2			;            DB  11111b  
69e2			;            DB  11111b  
69e2			;; Character 0x01 = Bluetooth icon  
69e2			;            DB  01100b  
69e2			;            DB  01010b  
69e2			;            DB  11100b  
69e2			;            DB  01000b  
69e2			;            DB  11100b  
69e2			;            DB  01010b  
69e2			;            DB  01100b  
69e2			;            DB  00000b  
69e2			;  
69e2			  
69e2			  
69e2			; **********************************************************************  
69e2			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
69e2			; **********************************************************************  
69e2			;  
69e2			; **  Written as a Small Computer Monitor App   
69e2			; **  Version 0.1 SCC 2018-05-16  
69e2			; **  www.scc.me.uk  
69e2			;  
69e2			; **********************************************************************  
69e2			;  
69e2			; This module provides support for alphanumeric LCD modules using with  
69e2			; *  HD44780 (or compatible) controller  
69e2			; *  5 x 7 pixel fonts  
69e2			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
69e2			; *  Interface via six digital outputs to the display (see below)  
69e2			;  
69e2			; LCD module pinout:  
69e2			;   1  Vss   0v supply  
69e2			;   2  Vdd   5v supply  
69e2			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
69e2			;   4  RS    High = data, Low = instruction  
69e2			;   5  R/W   High = Read, Low = Write  
69e2			;   6  E     Enable signal (active high)  
69e2			;   7  DB0   Data bit 0  
69e2			;   8  DB1   Data bit 1  
69e2			;   9  DB2   Data bit 2  
69e2			;  10  DB3   Data bit 3  
69e2			;  11  DB4   Data bit 4  
69e2			;  12  DB5   Data bit 5  
69e2			;  13  DB6   Data bit 6  
69e2			;  14  DB7   Data bit 7  
69e2			;  15  A     Backlight anode (+)  
69e2			;  16  K     Backlight cathode (-)  
69e2			;  
69e2			; This interfacing method uses 4-bit data mode and uses time delays  
69e2			; rather than polling the display's ready status. As a result the   
69e2			; interface only requires 6 simple output lines:  
69e2			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
69e2			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
69e2			;   LCD DB4 = Microcomputer output port bit 4  
69e2			;   LCD DB5 = Microcomputer output port bit 5  
69e2			;   LCD DB6 = Microcomputer output port bit 6  
69e2			;   LCD DB7 = Microcomputer output port bit 7  
69e2			; Display's R/W is connected to 0v so it is always in write mode  
69e2			; All 6 connections must be on the same port address <kLCDPrt>  
69e2			; This method also allows a decent length of cable from micro to LCD  
69e2			;  
69e2			; **********************************************************************  
69e2			;  
69e2			; To include the code for any given function provided by this module,   
69e2			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
69e2			; the parent source file.  
69e2			; For example:  #REQUIRES   uHexPrefix  
69e2			;  
69e2			; Also #INCLUDE this file at some point after the #REQUIRES statements  
69e2			; in the parent source file.  
69e2			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
69e2			;  
69e2			; These are the function names provided by this module:  
69e2			; fLCD_Init                     ;Initialise LCD  
69e2			; fLCD_Inst                     ;Send instruction to LCD  
69e2			; fLCD_Data                     ;Send data byte to LCD  
69e2			; fLCD_Pos                      ;Position cursor  
69e2			; fLCD_Str                      ;Display string  
69e2			; fLCD_Def                      ;Define custom character  
69e2			;  
69e2			; **********************************************************************  
69e2			;  
69e2			; Requires SCMonAPI.asm to also be included in the project  
69e2			;  
69e2			  
69e2			  
69e2			; **********************************************************************  
69e2			; **  Constants  
69e2			; **********************************************************************  
69e2			  
69e2			; Constants that must be defined externally  
69e2			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
69e2			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
69e2			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
69e2			;kLCDWidth: EQU 20             ;Width in characters  
69e2			  
69e2			; general line offsets in any frame buffer  
69e2			  
69e2			  
69e2			display_row_1: equ 0  
69e2			display_row_2: equ display_row_1+display_cols  
69e2			display_row_3: equ display_row_2 + display_cols  
69e2			display_row_4: equ display_row_3 + display_cols  
69e2			;display_row_4_eol:   
69e2			  
69e2			  
69e2			; Cursor position values for the start of each line  
69e2			kLCD_Line1: EQU 0x00   
69e2			kLCD_Line2: EQU 0x40    
69e2			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
69e2			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
69e2			  
69e2			; Instructions to send as A register to fLCD_Inst  
69e2			kLCD_Clear: EQU 00000001b     ;LCD clear  
69e2			kLCD_Off:   EQU 00001000b     ;LCD off  
69e2			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
69e2			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
69e2			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
69e2			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
69e2			  
69e2			; Constants used by this code module  
69e2			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
69e2			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
69e2			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
69e2			  
69e2			  
69e2			  
69e2			; **********************************************************************  
69e2			; **  LCD support functions  
69e2			; **********************************************************************  
69e2			  
69e2			; Initialise alphanumeric LCD module  
69e2			; LCD control register codes:  
69e2			;   DL   0 = 4-bit mode        1 = 8-bit mode  
69e2			;   N    0 = 1-line mode       1 = 2-line mode  
69e2			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
69e2			;   D    0 = Display off       1 = Display on  
69e2			;   C    0 = Cursor off        1 = Cursor on  
69e2			;   B    0 = Blinking off      1 = Blinking on  
69e2			;   ID   0 = Decrement mode    1 = Increment mode  
69e2			;   SH   0 = Entire shift off  1 = Entire shift on  
69e2 3e 28		fLCD_Init:  LD   A, 40  
69e4 cd 99 6a		            CALL LCDDelay       ;Delay 40ms after power up  
69e7			; For reliable reset set 8-bit mode - 3 times  
69e7 cd 83 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
69ea cd 83 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
69ed cd 83 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
69f0			; Set 4-bit mode  
69f0 cd 7f 6a		            CALL WrFn4bit       ;Function = 4-bit mode  
69f3 cd 97 6a		            CALL LCDDelay1      ;Delay 37 us or more  
69f6			; Function set  
69f6 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
69f8 cd 0b 6a		            CALL fLCD_Inst      ;2 line, display on  
69fb			; Display On/Off control  
69fb 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
69fd cd 0b 6a		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6a00			; Display Clear  
6a00 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6a02 cd 0b 6a		            CALL fLCD_Inst      ;Clear display  
6a05			; Entry mode  
6a05 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6a07 cd 0b 6a		            CALL fLCD_Inst      ;Increment mode, shift off  
6a0a			; Display module now initialised  
6a0a c9			            RET  
6a0b			; ok to here  
6a0b			  
6a0b			; Write instruction to LCD  
6a0b			;   On entry: A = Instruction byte to be written  
6a0b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a0b f5			fLCD_Inst:  PUSH AF  
6a0c f5			            PUSH AF  
6a0d cd 1f 6a		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6a10 f1			            POP  AF  
6a11 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a12 17			            RLA  
6a13 17			            RLA  
6a14 17			            RLA  
6a15 cd 1f 6a		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6a18 3e 02		            LD   A, 2  
6a1a cd 99 6a		            CALL LCDDelay       ;Delay 2 ms to complete   
6a1d f1			            POP  AF  
6a1e c9			            RET  
6a1f e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6a21 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a23 cb df		            SET  kLCDBitE, A  
6a25 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a27 cb 9f		            RES  kLCDBitE, A  
6a29 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a2b c9			            RET  
6a2c			  
6a2c			  
6a2c			; Write data to LCD  
6a2c			;   On entry: A = Data byte to be written  
6a2c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a2c f5			fLCD_Data:  PUSH AF  
6a2d f5			            PUSH AF  
6a2e cd 40 6a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6a31 f1			            POP  AF  
6a32 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a33 17			            RLA  
6a34 17			            RLA  
6a35 17			            RLA  
6a36 cd 40 6a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6a39 3e 96		            LD   A, 150  
6a3b 3d			Wait:      DEC  A              ;Wait a while to allow data   
6a3c 20 fd		            JR   NZ, Wait      ;  write to complete  
6a3e f1			            POP  AF  
6a3f c9			            RET  
6a40 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6a42 cb d7		            SET  kLCDBitRS, A  
6a44 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a46 cb df		            SET  kLCDBitE, A  
6a48 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6a4a cb 9f		            RES  kLCDBitE, A  
6a4c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a4e cb 97		            RES  kLCDBitRS, A  
6a50 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a52 c9			            RET  
6a53			  
6a53			  
6a53			; Position cursor to specified location  
6a53			;   On entry: A = Cursor position  
6a53			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a53 f5			fLCD_Pos:   PUSH AF  
6a54 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6a56 cd 0b 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6a59 f1			            POP  AF  
6a5a c9			            RET  
6a5b			  
6a5b			  
6a5b			; Output text string to LCD  
6a5b			;   On entry: DE = Pointer to null terminated text string  
6a5b			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6a5b 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6a5c b7			            OR   A              ;Null terminator?  
6a5d c8			            RET  Z              ;Yes, so finished  
6a5e cd 2c 6a		            CALL fLCD_Data      ;Write character to display  
6a61 13			            INC  DE             ;Point to next character  
6a62 18 f7		            JR   fLCD_Str       ;Repeat  
6a64 c9					ret  
6a65			  
6a65			; Define custom character  
6a65			;   On entry: A = Character number (0 to 7)  
6a65			;             DE = Pointer to character bitmap data  
6a65			;   On exit:  A = Next character number  
6a65			;             DE = Next location following bitmap  
6a65			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6a65			; Character is   
6a65 c5			fLCD_Def:   PUSH BC  
6a66 f5			            PUSH AF  
6a67 07			            RLCA                ;Calculate location  
6a68 07			            RLCA                ;  for bitmap data  
6a69 07			            RLCA                ;  = 8 x CharacterNumber  
6a6a f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6a6c cd 0b 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6a6f 06 00		            LD   B, 0  
6a71 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6a72 cd 2c 6a		            CALL fLCD_Data      ;Write byte to display  
6a75 13			            INC  DE             ;Point to next byte  
6a76 04			            INC  B              ;Count bytes  
6a77 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6a79 28 f6		            JR   Z, Loop       ;No, so repeat  
6a7b f1			            POP  AF  
6a7c 3c			            INC  A              ;Increment character number  
6a7d c1			            POP  BC  
6a7e c9			            RET  
6a7f			  
6a7f			  
6a7f			; **********************************************************************  
6a7f			; **  Private functions  
6a7f			; **********************************************************************  
6a7f			  
6a7f			; Write function to LCD  
6a7f			;   On entry: A = Function byte to be written  
6a7f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a7f 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6a81 18 02		            JR   WrFunc  
6a83 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6a85 f5			WrFunc:     PUSH AF  
6a86 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a88 cb df		            SET  kLCDBitE, A  
6a8a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a8c cb 9f		            RES  kLCDBitE, A  
6a8e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a90 3e 05		            LD   A, 5  
6a92 cd 99 6a		            CALL LCDDelay       ;Delay 5 ms to complete  
6a95 f1			            POP  AF  
6a96 c9			            RET  
6a97			  
6a97			  
6a97			; Delay in milliseconds  
6a97			;   On entry: A = Number of milliseconds delay  
6a97			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a97 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6a99 d5			LCDDelay:   PUSH DE  
6a9a 5f			            LD   E, A           ;Delay by 'A' ms  
6a9b 16 00		            LD   D, 0  
6a9d cd 29 0c		            CALL aDelayInMS  
6aa0 d1			            POP  DE  
6aa1 c9			            RET  
6aa2			  
6aa2			  
6aa2			  
6aa2			  
6aa2			; eof  
6aa2			  
# End of file firmware_lcd_4x20.asm
6aa2			include "firmware_key_4x4.asm" 
6aa2			  
6aa2			  
6aa2			; bit mask for each scan column and row for teing the matrix  
6aa2			  
6aa2			; out   
6aa2 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
6aa6			; in  
6aa6 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
6aaa			  
6aaa			; row/col to character map  
6aaa			  
6aaa			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
6aaa			;    
6aaa			  
6aaa			; physical key matrix map to face of key  
6aaa			  
6aaa			  
6aaa			;      	1	2	3	A  
6aaa			;   	abc”	def&	ghi$	s1  
6aaa			;			  
6aaa			;	4	5	6	B  
6aaa			; 	jkl,	mno.	pqr:	s2  
6aaa			;			  
6aaa			; 	7	8	9	C  
6aaa			;	stu;	vwx@	yz?!	s3  
6aaa			;			  
6aaa			; 	*	0	#	D  
6aaa			; 	shift lck '	Space < >	Enter ( )	s4  
6aaa			;       tab bs 		  
6aaa			  
6aaa			  
6aaa			  
6aaa			  
6aaa			key_init:  
6aaa			  
6aaa			; SCMonAPI functions used  
6aaa			  
6aaa			; Alphanumeric LCD functions used  
6aaa			; no need to specify specific functions for this module  
6aaa			  
6aaa			  
6aaa 3e cf		            LD   A, 11001111b  
6aac d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6aae			;            LD   A, 00000000b  
6aae 3e 0f		            LD   A, 00001111b  
6ab0 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6ab2			  
6ab2			  
6ab2				; TODO Configure cursor shapes  
6ab2			  
6ab2				; Load cursor shapes   
6ab2 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6ab4 11 c4 6a		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6ab7 06 02		            LD   B, 2           ;Number of characters to define  
6ab9 cd 65 6a		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6abc 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6abe			  
6abe 3e 01				ld a, 1  
6ac0 32 4d fd			ld (cursor_shape),a  
6ac3 c9				ret  
6ac4			  
6ac4			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6ac4			; Up to 8 custom characters can be defined  
6ac4			.cursor_shapes:      
6ac4			;; Character 0x00 = Normal  
6ac4 1f			            DB  11111b  
6ac5 1f			            DB  11111b  
6ac6 1f			            DB  11111b  
6ac7 1f			            DB  11111b  
6ac8 1f			            DB  11111b  
6ac9 1f			            DB  11111b  
6aca 1f			            DB  11111b  
6acb 1f			            DB  11111b  
6acc			;; Character 0x01 = Modifier  
6acc 1f			            DB  11111b  
6acd 1b			            DB  11011b  
6ace 1b			            DB  11011b  
6acf 1b			            DB  11011b  
6ad0 1b			            DB  11011b  
6ad1 1f			            DB  11111b  
6ad2 1b			            DB  11011b  
6ad3 1f			            DB  11111b  
6ad4			  
6ad4			  
6ad4			  
6ad4			  
6ad4			; Display custom character 0  
6ad4			;            LD   A, kLCD_Line1+14  
6ad4			;            CALL fLCD_Pos       ;Position cursor to location in A  
6ad4			;            LD   A, 0  
6ad4			;            CALL fLCD_Data      ;Write character in A at cursor  
6ad4			  
6ad4			; Display custom character 1  
6ad4			;            LD   A, kLCD_Line2+14  
6ad4			;            CALL fLCD_Pos      ;Position cursor to location in A  
6ad4			;            LD   A, 1  
6ad4			;            CALL fLCD_Data     ;Write character in A at cursor  
6ad4			  
6ad4			; keyboard scanning   
6ad4			  
6ad4			  
6ad4			; key_rows: equ 4  
6ad4			; key_cols: equ 4  
6ad4			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
6ad4			  
6ad4			; key_scanr: equ key_row_bitmask  
6ad4			; key_scanc: equ key_col_bitmask  
6ad4			  
6ad4			; key_char_map: equ key_map  
6ad4			  
6ad4			  
6ad4			  
6ad4			; character in from keyboard  
6ad4			  
6ad4 ..			.matrix_to_char: db "D#0*C987B654A321"  
6ae4			  
6ae4			  
6ae4			; map the physical key to a char dependant on state  
6ae4			  
6ae4			.key_map_fa:   
6ae4			  
6ae4 ..					db 'D'  
6ae5 0d					db KEY_CR    ; cr  
6ae6 ..					db ' '  
6ae7 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
6ae8 ..					db 'C'  
6ae9 ..					db 'y'  
6aea ..					db 'v'  
6aeb ..					db 's'  
6aec ..					db 'B'  
6aed ..					db 'p'  
6aee ..					db 'm'  
6aef ..					db 'j'  
6af0 ..					db 'A'  
6af1 ..					db 'g'  
6af2 ..					db 'd'  
6af3 ..					db 'a'  
6af4			  
6af4			.key_map_fb:  
6af4			  
6af4 ..					db 'A'  
6af5 ..					db '+'   
6af6 ..					db '<'  
6af7 ..					db  "'"    
6af8			  
6af8 ..					db 'A'  
6af9 ..					db 'z'  
6afa ..					db 'w'  
6afb ..					db 't'  
6afc ..					db 'A'  
6afd ..					db 'q'  
6afe ..					db 'n'  
6aff ..					db 'k'  
6b00 ..					db 'A'  
6b01 ..					db 'h'  
6b02 ..					db 'e'  
6b03 ..			 		db 'b'  
6b04			  
6b04			.key_map_fc:   
6b04			  
6b04			  
6b04 ..					db 'A'  
6b05 ..					db '-'   
6b06 ..					db '>'  
6b07 ..					db  '='   	  
6b08 ..					db 'A'  
6b09 ..					db '?'  
6b0a ..					db 'x'  
6b0b ..					db 'u'  
6b0c ..					db 'A'  
6b0d ..					db 'r'  
6b0e ..					db 'o'  
6b0f ..					db 'l'  
6b10 ..					db 'A'  
6b11 ..					db 'i'  
6b12 ..					db 'f'  
6b13 ..					db 'c'  
6b14			  
6b14				  
6b14			.key_map_fd:  
6b14			  
6b14 ..					db 'A'  
6b15 ..					db '/'   
6b16 ..					db '%'   
6b17 08					db KEY_BS  ; back space  
6b18 ..					db 'A'  
6b19 ..					db '!'  
6b1a ..					db '@'  
6b1b ..					db ';'  
6b1c ..					db 'A'  
6b1d ..					db ':'  
6b1e ..					db '.'  
6b1f ..					db ','  
6b20 ..					db 'A'  
6b21 ..					db '$'  
6b22 ..					db '&'  
6b23 ..				 	db '"'  
6b24			  
6b24					  
6b24				  
6b24			  
6b24			; add cin and cin_wait  
6b24			  
6b24 cd 35 6b		cin_wait: 	call cin  
6b27 fe 00			cp 0  
6b29 28 f9			jr z, cin_wait   ; block until key press  
6b2b			  
6b2b f5				push af   ; save key pressed  
6b2c			  
6b2c cd 35 6b		.cin_wait1:	call cin  
6b2f fe 00			cp 0  
6b31 20 f9			jr nz, .cin_wait1  	; wait for key release  
6b33			  
6b33 f1				pop af   ; get key  
6b34 c9				ret  
6b35			  
6b35			  
6b35 cd 46 6b		cin: 	call .mtoc  
6b38			  
6b38				; no key held  
6b38 fe 00			cp 0  
6b3a c8				ret z  
6b3b			  
6b3b				; stop key bounce  
6b3b			  
6b3b			;	ld (key_held),a		 ; save it  
6b3b 47				ld b, a  
6b3c			  
6b3c c5			.cina1:	push bc  
6b3d cd 46 6b			call .mtoc  
6b40 c1				pop bc  
6b41 b8				cp b  
6b42 28 f8			jr z, .cina1  
6b44 78				ld a,b		  
6b45 c9				ret  
6b46			  
6b46			; detect keyboard modifier key press and apply new overlay to the face key held  
6b46			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6b46			  
6b46			;.cin_map_modifier:   
6b46			;	ld a, (hl)  
6b46			;	and 255  
6b46			;	ret NZ		; modifier key not flagged  
6b46			;  
6b46			;	; get key face  
6b46			;  
6b46			;	ld b,(key_face_held)  
6b46			;  
6b46			;	ld b, key_cols * key_rows  
6b46			;  
6b46			;	push de  
6b46			;	pop hl  
6b46			;  
6b46			;.mmod1: ld a,(hl)   ; get map test  
6b46			;	cp b  
6b46			;	jr z, .mmod2  
6b46			;  
6b46			;  
6b46			;  
6b46			;.mmod2: inc hl    ;   
6b46			;  
6b46			;	  
6b46			;  
6b46			;	  
6b46			;  
6b46			;	ld hl,key_actual_pressed  
6b46			;	ld (hl),a,  
6b46			;	ret  
6b46			  
6b46				  
6b46			  
6b46			; map matrix key held to char on face of key  
6b46			  
6b46			.mtoc:  
6b46			  
6b46			  
6b46				; TODO optimise the code....  
6b46			  
6b46			; scan keyboard row 1  
6b46 3e 80			ld a, 128  
6b48 21 d3 fe			ld hl, keyscan_table  
6b4b cd 2d 6c			call .rowscan  
6b4e			  
6b4e				   
6b4e			  
6b4e 3e 40			ld a, 64  
6b50 21 d7 fe			ld hl, keyscan_table+key_cols  
6b53 cd 2d 6c			call .rowscan  
6b56			  
6b56			  
6b56			  
6b56			  
6b56 3e 20			ld a, 32  
6b58 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6b5b cd 2d 6c			call .rowscan  
6b5e			  
6b5e			  
6b5e			  
6b5e 3e 10			ld a, 16  
6b60 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6b63 cd 2d 6c			call .rowscan  
6b66			  
6b66			  
6b66				; flag if key D is held down and remove from reporting  
6b66 01 14 6b			ld bc, .key_map_fd    
6b69 21 d3 fe			ld hl, keyscan_table  
6b6c 11 c5 fe			ld de, key_fd  
6b6f cd bf 6b			call .key_shift_hold  
6b72 fe ff			cp 255  
6b74 28 33			jr z, .cinmap  
6b76				; flag if key C is held down and remove from reporting  
6b76 01 04 6b			ld bc, .key_map_fc    
6b79 21 d7 fe			ld hl, keyscan_table+key_cols  
6b7c 11 c6 fe			ld de, key_fc  
6b7f cd bf 6b			call .key_shift_hold  
6b82 fe ff			cp 255  
6b84 28 23			jr z, .cinmap  
6b86				; flag if key B is held down and remove from reporting  
6b86 01 f4 6a			ld bc, .key_map_fb    
6b89 21 db fe			ld hl, keyscan_table+(key_cols*2)  
6b8c 11 c7 fe			ld de, key_fb  
6b8f cd bf 6b			call .key_shift_hold  
6b92 fe ff			cp 255  
6b94 28 13			jr z, .cinmap  
6b96				; flag if key A is held down and remove from reporting  
6b96 01 e4 6a			ld bc, .key_map_fa    
6b99 21 df fe			ld hl, keyscan_table+(key_cols*3)  
6b9c 11 c8 fe			ld de, key_fa  
6b9f cd bf 6b			call .key_shift_hold  
6ba2 fe ff			cp 255  
6ba4 28 03			jr z, .cinmap  
6ba6			  
6ba6 11 d4 6a			ld de, .matrix_to_char  
6ba9			  
6ba9			  
6ba9			.cinmap:   
6ba9				if DEBUG_KEY  
6ba9			            LD   A, kLCD_Line4  
6ba9			            CALL fLCD_Pos       ;Position cursor to location in A  
6ba9					push de  
6ba9			            LD   DE, keyscan_table  
6ba9			            CALL fLCD_Str       ;Display string pointed to by DE  
6ba9					pop de  
6ba9				endif  
6ba9			  
6ba9				; scan key matrix table for any held key  
6ba9			  
6ba9				; de holds either the default matrix or one selected above  
6ba9			  
6ba9 21 d3 fe			ld hl, keyscan_table  
6bac 06 10			ld b,key_cols*key_rows  
6bae			  
6bae 7e			.cin1:	ld a,(hl)  
6baf fe 23			cp '#'  
6bb1 28 08			jr z, .cinhit  
6bb3 23				inc hl  
6bb4 13				inc de  
6bb5 05				dec b  
6bb6 20 f6			jr nz, .cin1  
6bb8				; no key found held  
6bb8 3e 00			ld a,0  
6bba c9				ret  
6bbb d5			.cinhit: push de  
6bbc e1				pop hl  
6bbd 7e				ld a,(hl)  
6bbe c9				ret  
6bbf			  
6bbf			; flag a control key is held   
6bbf			; hl is key pin, de is flag indicator  
6bbf			  
6bbf			.key_shift_hold:  
6bbf c5				push bc  
6bc0 3e 01			ld a, 1  
6bc2 32 4d fd			ld (cursor_shape),a  
6bc5 06 00			ld b, 0  
6bc7 7e				ld a, (hl)  
6bc8 fe 2e			cp '.'  
6bca 28 0a			jr z, .key_shift1  
6bcc 06 ff			ld b, 255  
6bce 3e 2b			ld a, '+'    ; hide key from later scans  
6bd0 77				ld (hl),a  
6bd1 3e 02			ld a, 2  
6bd3 32 4d fd			ld (cursor_shape),a  
6bd6			.key_shift1:  
6bd6				; write flag indicator  
6bd6 78				ld a,b  
6bd7 12				ld (de),a  
6bd8			  
6bd8 d1				pop de    ; de now holds the key map ptr  
6bd9 c9				ret  
6bda			  
6bda				  
6bda				  
6bda			  
6bda			  
6bda			  
6bda			  
6bda			  
6bda			  
6bda			  
6bda			  
6bda			  
6bda			  
6bda c9				ret  
6bdb			  
6bdb			;	push hl  
6bdb			;	push de  
6bdb			;	push bc  
6bdb			;	call keyscan  
6bdb			;	; map key matrix to ascii value of key face  
6bdb			;  
6bdb			;	ld hl, key_face_map  
6bdb			;	ld de, keyscan_table  
6bdb			;  
6bdb			;	; get how many keys to look at  
6bdb			;	ld b, keyscan_table_len  
6bdb			;	  
6bdb			;  
6bdb			;	; at this stage fall out on first key hit  
6bdb			;	; TODO handle multiple key press  
6bdb			;  
6bdb			;map1:	ld a,(hl)  
6bdb			;	cp '#'  
6bdb			;	jr z, keyhit  
6bdb			;	inc hl  
6bdb			;	inc de  
6bdb			;	dec b  
6bdb			;	jr nz, map1  
6bdb			;nohit:	ld a, 0  
6bdb			;	jr keydone  
6bdb			;keyhit: push de  
6bdb			;	pop hl  
6bdb			;	ld a,(hl)  
6bdb			;keydone:  
6bdb			;	push bc  
6bdb			;	push de  
6bdb			; 	push hl  
6bdb			;	ret   
6bdb			;  
6bdb			  
6bdb			  
6bdb			  
6bdb			  
6bdb			; scan physical key matrix  
6bdb			  
6bdb			  
6bdb			;keyscan:  
6bdb			;  
6bdb			;; for each key_row use keyscanr bit mask for out  
6bdb			;; then read in for keyscanc bitmask  
6bdb			;; save result of row scan to keyscantable  
6bdb			;  
6bdb			;; scan keyboard row 1  
6bdb			;  
6bdb			;	ld b, key_rows  
6bdb			;	ld hl, key_scanr  
6bdb			;	ld de, keyscan_table  
6bdb			;  
6bdb			;rowloop:  
6bdb			;  
6bdb			;	ld a,(hl)		; out bit mask to energise keyboard row  
6bdb			;	call rowscan  
6bdb			;	inc hl  
6bdb			;	dec b  
6bdb			;	jr nz, rowloop  
6bdb			;  
6bdb			;	ret  
6bdb			;  
6bdb			;  
6bdb			;; pass a out bitmask, b row number  
6bdb			;arowscan:   
6bdb			;	push bc  
6bdb			;  
6bdb			;	ld d, b  
6bdb			;  
6bdb			;	; calculate buffer location for this row  
6bdb			;  
6bdb			;	ld hl, keyscan_table	  
6bdb			;kbufr:  ld e, key_cols  
6bdb			;kbufc:	inc hl  
6bdb			;	dec e  
6bdb			;	jr nz, kbufc  
6bdb			;	dec d  
6bdb			;	jr nz, kbufr  
6bdb			;  
6bdb			;	; energise row and read columns  
6bdb			;  
6bdb			;	out (portbdata),a  
6bdb			;	in a,(portbdata)  
6bdb			;	ld c,a  
6bdb			;  
6bdb			;  
6bdb			;	; save buffer loc  
6bdb			;  
6bdb			;	ld (keybufptr), hl  
6bdb			;  
6bdb			;	ld hl, key_scanc  
6bdb			;	ld d, key_cols  
6bdb			;  
6bdb			;	; for each column check each bit mask  
6bdb			;  
6bdb			;colloop:  
6bdb			;	  
6bdb			;  
6bdb			;	; reset flags for the row   
6bdb			;  
6bdb			;	ld b,'.'  
6bdb			;	and (hl)  
6bdb			;	jr z, maskskip  
6bdb			;	ld b,'#'  
6bdb			;maskskip:  
6bdb			;	; save  key state  
6bdb			;	push hl  
6bdb			;	ld hl, (keybufptr)  
6bdb			;	ld (hl), b  
6bdb			;	inc hl  
6bdb			;	ld (keybufptr), hl  
6bdb			;  
6bdb			;	; move to next bit mask  
6bdb			;	pop hl  
6bdb			;	inc hl  
6bdb			;  
6bdb			;	dec d  
6bdb			;	jr nz, colloop  
6bdb			;  
6bdb			;	ret  
6bdb			;  
6bdb			;  
6bdb			;;  
6bdb			; lcd functions  
6bdb			;  
6bdb			;  
6bdb			  
6bdb			;if DEBUG_KEY_MATRIX  
6bdb			  
6bdb			; test function to display hardware view of matrix state  
6bdb			  
6bdb			matrix:  
6bdb			  
6bdb			  
6bdb			  
6bdb			; scan keyboard row 1  
6bdb 3e 80			ld a, 128  
6bdd 21 f8 fe			ld hl, keyscan_table_row1  
6be0 cd 2d 6c			call .rowscan  
6be3			  
6be3 3e 40			ld a, 64  
6be5 21 f3 fe			ld hl, keyscan_table_row2  
6be8 cd 2d 6c			call .rowscan  
6beb			  
6beb 3e 20			ld a, 32  
6bed 21 ee fe			ld hl, keyscan_table_row3  
6bf0 cd 2d 6c			call .rowscan  
6bf3			  
6bf3 3e 10			ld a, 16  
6bf5 21 e9 fe			ld hl, keyscan_table_row4  
6bf8 cd 2d 6c			call .rowscan  
6bfb			  
6bfb			; Display text on first line  
6bfb 3e 00		            LD   A, kLCD_Line1  
6bfd cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c00 11 f8 fe		            LD   DE, keyscan_table_row1  
6c03			            ;LD   DE, MsgHello  
6c03 cd 5b 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c06			  
6c06			; Display text on second line  
6c06 3e 40		            LD   A, kLCD_Line2  
6c08 cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c0b 11 f3 fe		            LD   DE, keyscan_table_row2  
6c0e cd 5b 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c11 3e 14		            LD   A, kLCD_Line3  
6c13 cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c16 11 ee fe		            LD   DE, keyscan_table_row3  
6c19 cd 5b 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c1c 3e 54		            LD   A, kLCD_Line4  
6c1e cd 53 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6c21 11 e9 fe		            LD   DE, keyscan_table_row4  
6c24 cd 5b 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6c27			  
6c27 cd 38 0c			call delay250ms  
6c2a c3 db 6b			jp matrix  
6c2d			  
6c2d			; pass de as row display flags  
6c2d			.rowscan:   
6c2d d3 c1			out (portbdata),a  
6c2f db c1			in a,(portbdata)  
6c31 4f				ld c,a  
6c32				; reset flags for the row   
6c32 06 2e			ld b,'.'  
6c34 e6 01			and 1  
6c36 28 02			jr z, .p1on  
6c38 06 23			ld b,'#'  
6c3a			.p1on:  
6c3a 70				ld (hl), b  
6c3b 23				inc hl  
6c3c			  
6c3c 06 2e			ld b,'.'  
6c3e 79				ld a,c  
6c3f e6 02			and 2  
6c41			;	bit 0,a  
6c41 28 02			jr z, .p2on  
6c43 06 23			ld b,'#'  
6c45			.p2on:  
6c45 70				ld (hl), b  
6c46 23				inc hl  
6c47			;  
6c47 06 2e			ld b,'.'  
6c49 79				ld a,c  
6c4a e6 04			and 4  
6c4c			;;	bit 0,a  
6c4c 28 02			jr z, .p3on  
6c4e 06 23			ld b,'#'  
6c50			.p3on:  
6c50 70				ld (hl), b  
6c51 23				inc hl  
6c52			;;  
6c52 06 2e			ld b,'.'  
6c54			;;	bit 0,a  
6c54 79				ld a,c  
6c55 e6 08			and 8  
6c57 28 02			jr z, .p4on  
6c59 06 23			ld b,'#'  
6c5b			.p4on:  
6c5b 70				ld (hl), b  
6c5c 23				inc hl  
6c5d			  
6c5d			; zero term  
6c5d 06 00			ld b,0  
6c5f 70				ld (hl), b  
6c60			  
6c60 c9			.rscandone: ret  
6c61			  
6c61			  
6c61			  
6c61			;endif  
6c61			  
6c61			  
6c61			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6c61
