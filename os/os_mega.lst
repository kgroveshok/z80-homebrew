# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 1f 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd d8 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd d8 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd d8 0a				call clear_display  
0023			  
0023			  
0023 cd 64 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd fb 67			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd af 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 6c 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd fb 0a			call update_display  
0035 cd 58 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd dd 0a			call fill_display  
003d cd fb 0a			call update_display  
0040 cd 58 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd dd 0a			call fill_display  
0048 cd fb 0a			call update_display  
004b cd 58 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd dd 0a			call fill_display  
0053 cd fb 0a			call update_display  
0056 cd 58 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd eb 0a			call str_at_display  
0061 cd fb 0a			call update_display  
0064			  
0064			  
0064 cd 58 0a			call delay1s  
0067 cd 58 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd eb 0a			call str_at_display  
0072 cd fb 0a			call update_display  
0075 cd 58 0a			call delay1s  
0078 cd 58 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 49 f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 49 f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 49 f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 49 f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 49 f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 4b f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 48 f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 48 f8			ld (spi_device), a 
01e3 32 4b f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 49 f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 49 f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 49 f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 49 f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 49 f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 49 f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 49 f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 49 f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 3d 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 49 f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 49 f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 49 f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 49 f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 49 f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 49 f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 49 f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 49 f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 3d 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 49 f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 49 f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 49 f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 49 f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 1f ee			ld hl,scratch+2 
02be cd c3 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 40 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 24 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 40 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 40 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 40 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 40 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 45 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 45 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 40 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 40 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 45 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 40 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 49 17			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 49 17			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 2d 06			call storage_findnextid 
0360			 
0360 cd 35 0d			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 49 17			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 49 17			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 49 17			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 49 17			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 49 17			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b cd 1b 0a			call storage_clear_page 
042e			 
042e 21 62 f8			ld hl, store_page 
0431 3e 00			ld a, 0 
0433				 
0433 77				ld (hl),a   ; reset file counter 
0434			 
0434 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0437 22 63 f8		 	ld (store_page+1), hl	 
043a			 
043a				; set default label 
043a			 
043a 21 d6 04			ld hl, .defaultbanklabl 
043d 11 65 f8		 	ld de, store_page+3 
0440 01 0f 00			ld bc, 15 
0443 ed b0			ldir 
0445			 
0445				; Append the current bank id 
0445 21 6e f8			ld hl, store_page+3+9 
0448 3a 47 f8			ld a, (spi_device_id) 
044b 77				ld (hl), a 
044c			 
044c				; save default page 0 
044c			 
044c 21 00 00			ld hl, 0 
044f 11 62 f8			ld de, store_page 
0452				if DEBUG_STORESE 
0452					DMARK "SB3" 
0452 f5				push af  
0453 3a 67 04			ld a, (.dmark)  
0456 32 77 fb			ld (debug_mark),a  
0459 3a 68 04			ld a, (.dmark+1)  
045c 32 78 fb			ld (debug_mark+1),a  
045f 3a 69 04			ld a, (.dmark+2)  
0462 32 79 fb			ld (debug_mark+2),a  
0465 18 03			jr .pastdmark  
0467 ..			.dmark: db "SB3"  
046a f1			.pastdmark: pop af  
046b			endm  
# End of macro DMARK
046b			;		push af 
046b			;		ld a, 'F' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b					CALLMONITOR 
046b cd 49 17			call break_point_state  
046e				endm  
# End of macro CALLMONITOR
046e				endif 
046e cd 71 03			call storage_write_block 
0471				if DEBUG_STORESE 
0471					DMARK "SB4" 
0471 f5				push af  
0472 3a 86 04			ld a, (.dmark)  
0475 32 77 fb			ld (debug_mark),a  
0478 3a 87 04			ld a, (.dmark+1)  
047b 32 78 fb			ld (debug_mark+1),a  
047e 3a 88 04			ld a, (.dmark+2)  
0481 32 79 fb			ld (debug_mark+2),a  
0484 18 03			jr .pastdmark  
0486 ..			.dmark: db "SB4"  
0489 f1			.pastdmark: pop af  
048a			endm  
# End of macro DMARK
048a			;		push af 
048a			;		ld a, '>' 
048a			;		ld (debug_mark),a 
048a			;		pop af 
048a					CALLMONITOR 
048a cd 49 17			call break_point_state  
048d				endm  
# End of macro CALLMONITOR
048d				endif 
048d			 
048d 00				nop 
048e 00				nop 
048f 00				nop 
0490			 
0490				; now set 0 in every page to mark as a free block 
0490			 
0490 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0492 21 40 00			ld hl, STORE_BLOCK_PHY 
0495			 
0495 3e 00		.setmark1:   	ld a,0 
0497 e5					push hl 
0498 c5					push bc 
0499 cd ea 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 3d 0a			call aDelayInMS 
04a1 23				inc hl 
04a2 cd ea 01				call se_writebyte 
04a5 3e 0a			ld a, 10 
04a7 cd 3d 0a			call aDelayInMS 
04aa 2b				dec hl 
04ab c1					pop bc 
04ac e1					pop hl 
04ad 3e 40				ld a, STORE_BLOCK_PHY 
04af cd 0c 0d				call addatohl 
04b2 10 e1				djnz .setmark1 
04b4			 
04b4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b6 3e 00		.setmark2:   	ld a,0 
04b8 e5					push hl 
04b9 c5					push bc 
04ba cd ea 01				call se_writebyte 
04bd 3e 0a			ld a, 10 
04bf cd 3d 0a			call aDelayInMS 
04c2 23				inc hl 
04c3 cd ea 01				call se_writebyte 
04c6 3e 0a			ld a, 10 
04c8 cd 3d 0a			call aDelayInMS 
04cb 2b				dec hl 
04cc c1					pop bc 
04cd e1					pop hl 
04ce 3e 40				ld a, STORE_BLOCK_PHY 
04d0 cd 0c 0d				call addatohl 
04d3 10 e1				djnz .setmark2 
04d5			 
04d5					 
04d5			 
04d5			 
04d5 c9				ret 
04d6			 
04d6			 
04d6			 
04d6			 
04d6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04e1			 
04e1			 
04e1			 
04e1			; Label Bank 
04e1			; ---------- 
04e1			; 
04e1			; With current bank 
04e1			; Read block 0 
04e1			; Set label 
04e1			; Write block 0 
04e1			 
04e1			; label str pointer in hl 
04e1			 
04e1			storage_label:     
04e1			 
04e1				if DEBUG_STORESE 
04e1					DMARK "LBL" 
04e1 f5				push af  
04e2 3a f6 04			ld a, (.dmark)  
04e5 32 77 fb			ld (debug_mark),a  
04e8 3a f7 04			ld a, (.dmark+1)  
04eb 32 78 fb			ld (debug_mark+1),a  
04ee 3a f8 04			ld a, (.dmark+2)  
04f1 32 79 fb			ld (debug_mark+2),a  
04f4 18 03			jr .pastdmark  
04f6 ..			.dmark: db "LBL"  
04f9 f1			.pastdmark: pop af  
04fa			endm  
# End of macro DMARK
04fa					CALLMONITOR 
04fa cd 49 17			call break_point_state  
04fd				endm  
# End of macro CALLMONITOR
04fd				endif 
04fd			 
04fd e5				push hl 
04fe			 
04fe cd bd 03			call storage_get_block_0 
0501			 
0501				; set default label 
0501			 
0501 e1				pop hl 
0502			 
0502 11 65 f8		 	ld de, store_page+3 
0505 01 0f 00			ld bc, 15 
0508				if DEBUG_STORESE 
0508					DMARK "LB3" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 77 fb			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 78 fb			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 79 fb			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "LB3"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521					CALLMONITOR 
0521 cd 49 17			call break_point_state  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 ed b0			ldir 
0526				; save default page 0 
0526			 
0526 21 00 00			ld hl, 0 
0529 11 62 f8			ld de, store_page 
052c				if DEBUG_STORESE 
052c					DMARK "LBW" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 77 fb			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 78 fb			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 79 fb			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "LBW"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					CALLMONITOR 
0545 cd 49 17			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548				endif 
0548 cd 71 03			call storage_write_block 
054b			 
054b c9				ret 
054c			 
054c			 
054c			 
054c			; Read Block 0 - Config 
054c			; --------------------- 
054c			; 
054c			; With current bank 
054c			; Call presence test 
054c			;    If not present format/init bank  
054c			; Read block 0  
054c			;  
054c			 
054c			 
054c			; Dir 
054c			; --- 
054c			; 
054c			; With current bank 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block read byte 2 
054c			;      if first block of file 
054c			;         Display file name 
054c			;         Display type flags for file 
054c			;        
054c			 
054c			; moving to words as this requires stack control 
054c			 
054c			 
054c			; Delete File 
054c			; ----------- 
054c			; 
054c			; With current bank 
054c			; 
054c			; Load Block 0 Config 
054c			; Get max file id number 
054c			; For each logical block 
054c			;    Read block file id 
054c			;      If first block of file and dont have file id 
054c			;         if file to delete 
054c			;         Save file id 
054c			;         Null file id 
054c			;         Write this block back 
054c			;      If file id is one saved 
054c			;         Null file id 
054c			;         Write this block back 
054c			 
054c			storage_erase: 
054c			 
054c				; hl contains the file id 
054c			 
054c 5d				ld e, l 
054d 16 00			ld d, 0 
054f 21 40 00			ld hl, STORE_BLOCK_PHY 
0552					if DEBUG_FORTH_WORDS 
0552						DMARK "ERA" 
0552 f5				push af  
0553 3a 67 05			ld a, (.dmark)  
0556 32 77 fb			ld (debug_mark),a  
0559 3a 68 05			ld a, (.dmark+1)  
055c 32 78 fb			ld (debug_mark+1),a  
055f 3a 69 05			ld a, (.dmark+2)  
0562 32 79 fb			ld (debug_mark+2),a  
0565 18 03			jr .pastdmark  
0567 ..			.dmark: db "ERA"  
056a f1			.pastdmark: pop af  
056b			endm  
# End of macro DMARK
056b						CALLMONITOR 
056b cd 49 17			call break_point_state  
056e				endm  
# End of macro CALLMONITOR
056e					endif 
056e cd 2d 06			call storage_findnextid 
0571			 
0571 e5				push hl 
0572			 
0572				; TODO check file not found 
0572			 
0572 11 62 f8			ld de, store_page 
0575 cd 0c 03			call storage_read_block 
0578			 
0578					if DEBUG_FORTH_WORDS 
0578						DMARK "ER1" 
0578 f5				push af  
0579 3a 8d 05			ld a, (.dmark)  
057c 32 77 fb			ld (debug_mark),a  
057f 3a 8e 05			ld a, (.dmark+1)  
0582 32 78 fb			ld (debug_mark+1),a  
0585 3a 8f 05			ld a, (.dmark+2)  
0588 32 79 fb			ld (debug_mark+2),a  
058b 18 03			jr .pastdmark  
058d ..			.dmark: db "ER1"  
0590 f1			.pastdmark: pop af  
0591			endm  
# End of macro DMARK
0591						CALLMONITOR 
0591 cd 49 17			call break_point_state  
0594				endm  
# End of macro CALLMONITOR
0594					endif 
0594 3a 62 f8			ld a, (store_page)	; get file id 
0597 32 5b f8			ld (store_tmpid), a 
059a			 
059a 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
059d 32 5a f8			ld (store_tmpext), a 
05a0			 
05a0				; wipe file header 
05a0			 
05a0 e1				pop hl 
05a1 3e 00			ld a, 0 
05a3 32 62 f8			ld (store_page), a 
05a6 32 63 f8			ld (store_page+1),a 
05a9 11 62 f8			ld de, store_page 
05ac					if DEBUG_FORTH_WORDS 
05ac						DMARK "ER2" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 77 fb			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 78 fb			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 79 fb			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "ER2"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5						CALLMONITOR 
05c5 cd 49 17			call break_point_state  
05c8				endm  
# End of macro CALLMONITOR
05c8					endif 
05c8 cd 71 03			call storage_write_block 
05cb			 
05cb			 
05cb				; wipe file extents 
05cb			 
05cb 3a 5a f8			ld a, (store_tmpext) 
05ce 47				ld b, a 
05cf			 
05cf			.eraext:	  
05cf c5				push bc 
05d0			 
05d0 21 40 00			ld hl, STORE_BLOCK_PHY 
05d3 3a 5b f8			ld a,(store_tmpid) 
05d6 5f				ld e, a 
05d7 50				ld d, b	 
05d8					if DEBUG_FORTH_WORDS 
05d8						DMARK "ER3" 
05d8 f5				push af  
05d9 3a ed 05			ld a, (.dmark)  
05dc 32 77 fb			ld (debug_mark),a  
05df 3a ee 05			ld a, (.dmark+1)  
05e2 32 78 fb			ld (debug_mark+1),a  
05e5 3a ef 05			ld a, (.dmark+2)  
05e8 32 79 fb			ld (debug_mark+2),a  
05eb 18 03			jr .pastdmark  
05ed ..			.dmark: db "ER3"  
05f0 f1			.pastdmark: pop af  
05f1			endm  
# End of macro DMARK
05f1						CALLMONITOR 
05f1 cd 49 17			call break_point_state  
05f4				endm  
# End of macro CALLMONITOR
05f4					endif 
05f4 cd 2d 06			call storage_findnextid 
05f7			 
05f7 e5				push hl 
05f8 11 62 f8			ld de, store_page 
05fb cd 0c 03			call storage_read_block 
05fe			 
05fe				; free block	 
05fe			 
05fe 3e 00			ld a, 0 
0600 32 62 f8			ld (store_page), a 
0603 32 63 f8			ld (store_page+1),a 
0606 11 62 f8			ld de, store_page 
0609 e1				pop hl 
060a					if DEBUG_FORTH_WORDS 
060a						DMARK "ER4" 
060a f5				push af  
060b 3a 1f 06			ld a, (.dmark)  
060e 32 77 fb			ld (debug_mark),a  
0611 3a 20 06			ld a, (.dmark+1)  
0614 32 78 fb			ld (debug_mark+1),a  
0617 3a 21 06			ld a, (.dmark+2)  
061a 32 79 fb			ld (debug_mark+2),a  
061d 18 03			jr .pastdmark  
061f ..			.dmark: db "ER4"  
0622 f1			.pastdmark: pop af  
0623			endm  
# End of macro DMARK
0623						CALLMONITOR 
0623 cd 49 17			call break_point_state  
0626				endm  
# End of macro CALLMONITOR
0626					endif 
0626 cd 71 03			call storage_write_block 
0629			 
0629 c1				pop bc 
062a 10 a3			djnz .eraext 
062c			 
062c c9				ret 
062d			 
062d			 
062d			; Find Free Block 
062d			; --------------- 
062d			; 
062d			; With current bank 
062d			;  
062d			; From given starting logical block 
062d			;    Read block  
062d			;    If no file id 
062d			;         Return block id 
062d			 
062d			 
062d			; hl starting page number 
062d			; hl contains free page number or zero if no pages free 
062d			; e contains the file id to locate 
062d			; d contains the block number 
062d			 
062d			; TODO change to find file id and use zero for free block 
062d			 
062d			storage_findnextid: 
062d			 
062d				; now locate first 0 page to mark as a free block 
062d			 
062d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062f			;	ld hl, STORE_BLOCK_PHY 
062f			 
062f					if DEBUG_FORTH_WORDS 
062f					DMARK "FNI" 
062f f5				push af  
0630 3a 44 06			ld a, (.dmark)  
0633 32 77 fb			ld (debug_mark),a  
0636 3a 45 06			ld a, (.dmark+1)  
0639 32 78 fb			ld (debug_mark+1),a  
063c 3a 46 06			ld a, (.dmark+2)  
063f 32 79 fb			ld (debug_mark+2),a  
0642 18 03			jr .pastdmark  
0644 ..			.dmark: db "FNI"  
0647 f1			.pastdmark: pop af  
0648			endm  
# End of macro DMARK
0648						CALLMONITOR 
0648 cd 49 17			call break_point_state  
064b				endm  
# End of macro CALLMONITOR
064b					endif 
064b			.ff1:   	 
064b e5					push hl 
064c c5					push bc 
064d d5					push de 
064e cd 8c 02				call se_readbyte 
0651 5f					ld e,a 
0652 23					inc hl 
0653 cd 8c 02				call se_readbyte 
0656 57					ld d, a 
0657 e1					pop hl 
0658 e5					push hl 
0659 cd 2a 0d				call cmp16 
065c 28 49				jr z, .fffound 
065e			 
065e d1					pop de 
065f c1					pop bc 
0660 e1					pop hl 
0661			 
0661					; is found? 
0661					;cp e 
0661					;ret z 
0661			 
0661 3e 40				ld a, STORE_BLOCK_PHY 
0663 cd 0c 0d				call addatohl 
0666 10 e3				djnz .ff1 
0668			 
0668 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
066a			.ff2:   	 
066a			 
066a e5					push hl 
066b c5					push bc 
066c d5					push de 
066d cd 8c 02				call se_readbyte 
0670 5f					ld e,a 
0671 23					inc hl 
0672 cd 8c 02				call se_readbyte 
0675 57					ld d, a 
0676			 
0676 e1					pop hl 
0677 e5					push hl 
0678 cd 2a 0d				call cmp16 
067b 28 2a				jr z, .fffound 
067d			 
067d d1					pop de 
067e c1					pop bc 
067f e1					pop hl 
0680					; is found? 
0680					;cp e 
0680					;ret z 
0680			 
0680 3e 40				ld a, STORE_BLOCK_PHY 
0682 cd 0c 0d				call addatohl 
0685 10 e3				djnz .ff2 
0687			 
0687			 
0687					if DEBUG_FORTH_WORDS 
0687					DMARK "FN-" 
0687 f5				push af  
0688 3a 9c 06			ld a, (.dmark)  
068b 32 77 fb			ld (debug_mark),a  
068e 3a 9d 06			ld a, (.dmark+1)  
0691 32 78 fb			ld (debug_mark+1),a  
0694 3a 9e 06			ld a, (.dmark+2)  
0697 32 79 fb			ld (debug_mark+2),a  
069a 18 03			jr .pastdmark  
069c ..			.dmark: db "FN-"  
069f f1			.pastdmark: pop af  
06a0			endm  
# End of macro DMARK
06a0					;	push af 
06a0					;	ld a, 'n' 
06a0					;	ld (debug_mark),a 
06a0					;	pop af 
06a0						CALLMONITOR 
06a0 cd 49 17			call break_point_state  
06a3				endm  
# End of macro CALLMONITOR
06a3					endif 
06a3				; no free marks! 
06a3 21 00 00				ld hl, 0 
06a6 c9				ret 
06a7			.fffound: 
06a7				 
06a7			 
06a7 d1					pop de 
06a8 c1					pop bc 
06a9 e1					pop hl 
06aa					if DEBUG_FORTH_WORDS 
06aa					DMARK "FNF" 
06aa f5				push af  
06ab 3a bf 06			ld a, (.dmark)  
06ae 32 77 fb			ld (debug_mark),a  
06b1 3a c0 06			ld a, (.dmark+1)  
06b4 32 78 fb			ld (debug_mark+1),a  
06b7 3a c1 06			ld a, (.dmark+2)  
06ba 32 79 fb			ld (debug_mark+2),a  
06bd 18 03			jr .pastdmark  
06bf ..			.dmark: db "FNF"  
06c2 f1			.pastdmark: pop af  
06c3			endm  
# End of macro DMARK
06c3					;	push af 
06c3					;	ld a, 'n' 
06c3					;	ld (debug_mark),a 
06c3					;	pop af 
06c3						CALLMONITOR 
06c3 cd 49 17			call break_point_state  
06c6				endm  
# End of macro CALLMONITOR
06c6					endif 
06c6 c9				ret 
06c7			 
06c7			 
06c7			 
06c7			; Free Space 
06c7			; ---------- 
06c7			; 
06c7			; With current bank 
06c7			; 
06c7			; Set block count to zero 
06c7			; Starting with first logical block 
06c7			;      Find free block  
06c7			;      If block id given, increment block count 
06c7			; 
06c7			;  
06c7			 
06c7			 
06c7			; hl contains count of free blocks 
06c7			 
06c7			storage_freeblocks: 
06c7			 
06c7				; now locate first 0 page to mark as a free block 
06c7			 
06c7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c9 21 40 00			ld hl, STORE_BLOCK_PHY 
06cc 11 00 00			ld de, 0 
06cf			 
06cf			.fb1:   	 
06cf e5					push hl 
06d0 c5					push bc 
06d1 d5					push de 
06d2 cd 8c 02				call se_readbyte 
06d5 d1					pop de 
06d6 c1					pop bc 
06d7 e1					pop hl 
06d8			 
06d8					; is free? 
06d8 fe 00				cp 0 
06da 20 01				jr nz, .ff1cont 
06dc 13					inc de 
06dd			 
06dd			.ff1cont: 
06dd			 
06dd			 
06dd 3e 40				ld a, STORE_BLOCK_PHY 
06df cd 0c 0d				call addatohl 
06e2 10 eb				djnz .fb1 
06e4			 
06e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e6			.fb2:   	 
06e6 e5					push hl 
06e7 c5					push bc 
06e8 d5					push de 
06e9 cd 8c 02				call se_readbyte 
06ec d1					pop de 
06ed c1					pop bc 
06ee e1					pop hl 
06ef			 
06ef					; is free? 
06ef fe 00				cp 0 
06f1 20 01				jr nz, .ff2cont 
06f3 13					inc de 
06f4			 
06f4			.ff2cont: 
06f4			 
06f4 3e 40				ld a, STORE_BLOCK_PHY 
06f6 cd 0c 0d				call addatohl 
06f9 10 eb				djnz .fb2 
06fb			 
06fb eb				ex de, hl 
06fc c9				ret 
06fd			 
06fd			; Get File ID 
06fd			; ----------- 
06fd			; 
06fd			; With current bank 
06fd			;  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; For each logical block 
06fd			;    Read block file id 
06fd			;      If first block of file and dont have file id 
06fd			;         if file get id and exit 
06fd			 
06fd			 
06fd			 
06fd			 
06fd			; Create File 
06fd			; ----------- 
06fd			; 
06fd			; With current bank  
06fd			; Load Block 0 Config 
06fd			; Get max file id number 
06fd			; Increment file id number 
06fd			; Save Config 
06fd			; Find free block 
06fd			; Set buffer with file name and file id 
06fd			; Write buffer to free block  
06fd			 
06fd			 
06fd			; hl point to file name 
06fd			; hl returns file id 
06fd			 
06fd			; file format: 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent number 
06fd			; byte 2-> data 
06fd			 
06fd			; format for extent number 0: 
06fd			; 
06fd			; byte 0 - file id 
06fd			; byte 1 - extent 0 
06fd			; byte 2 - extent count 
06fd			; byte 3 -> file name and meta data 
06fd			 
06fd			 
06fd			storage_create: 
06fd				if DEBUG_STORESE 
06fd					DMARK "SCR" 
06fd f5				push af  
06fe 3a 12 07			ld a, (.dmark)  
0701 32 77 fb			ld (debug_mark),a  
0704 3a 13 07			ld a, (.dmark+1)  
0707 32 78 fb			ld (debug_mark+1),a  
070a 3a 14 07			ld a, (.dmark+2)  
070d 32 79 fb			ld (debug_mark+2),a  
0710 18 03			jr .pastdmark  
0712 ..			.dmark: db "SCR"  
0715 f1			.pastdmark: pop af  
0716			endm  
# End of macro DMARK
0716					CALLMONITOR 
0716 cd 49 17			call break_point_state  
0719				endm  
# End of macro CALLMONITOR
0719				endif 
0719			 
0719 e5				push hl		; save file name pointer 
071a			 
071a cd bd 03			call storage_get_block_0 
071d			 
071d 3a 62 f8			ld a,(store_page)	; get current file id 
0720 3c				inc a 
0721 32 62 f8			ld (store_page),a 
0724				 
0724 32 5b f8			ld (store_tmpid),a			; save id 
0727			 
0727 21 00 00			ld hl, 0 
072a 11 62 f8			ld de, store_page 
072d				if DEBUG_STORESE 
072d					DMARK "SCw" 
072d f5				push af  
072e 3a 42 07			ld a, (.dmark)  
0731 32 77 fb			ld (debug_mark),a  
0734 3a 43 07			ld a, (.dmark+1)  
0737 32 78 fb			ld (debug_mark+1),a  
073a 3a 44 07			ld a, (.dmark+2)  
073d 32 79 fb			ld (debug_mark+2),a  
0740 18 03			jr .pastdmark  
0742 ..			.dmark: db "SCw"  
0745 f1			.pastdmark: pop af  
0746			endm  
# End of macro DMARK
0746					CALLMONITOR 
0746 cd 49 17			call break_point_state  
0749				endm  
# End of macro CALLMONITOR
0749				endif 
0749 cd 71 03			call storage_write_block	 ; save update 
074c			 
074c				if DEBUG_STORESE 
074c 11 62 f8				ld de, store_page 
074f					DMARK "SCC" 
074f f5				push af  
0750 3a 64 07			ld a, (.dmark)  
0753 32 77 fb			ld (debug_mark),a  
0756 3a 65 07			ld a, (.dmark+1)  
0759 32 78 fb			ld (debug_mark+1),a  
075c 3a 66 07			ld a, (.dmark+2)  
075f 32 79 fb			ld (debug_mark+2),a  
0762 18 03			jr .pastdmark  
0764 ..			.dmark: db "SCC"  
0767 f1			.pastdmark: pop af  
0768			endm  
# End of macro DMARK
0768					CALLMONITOR 
0768 cd 49 17			call break_point_state  
076b				endm  
# End of macro CALLMONITOR
076b				endif 
076b				;  
076b				 
076b 21 40 00			ld hl, STORE_BLOCK_PHY 
076e 11 00 00			ld de, 0 
0771 cd 2d 06			call storage_findnextid 
0774			 
0774 22 4c f8			ld (store_tmppageid), hl    ; save page to use  
0777			 
0777				; TODO detect 0 = no spare blocks 
0777			 
0777				; hl now contains the free page to use for the file header page 
0777			 
0777				if DEBUG_STORESE 
0777				DMARK "SCF" 
0777 f5				push af  
0778 3a 8c 07			ld a, (.dmark)  
077b 32 77 fb			ld (debug_mark),a  
077e 3a 8d 07			ld a, (.dmark+1)  
0781 32 78 fb			ld (debug_mark+1),a  
0784 3a 8e 07			ld a, (.dmark+2)  
0787 32 79 fb			ld (debug_mark+2),a  
078a 18 03			jr .pastdmark  
078c ..			.dmark: db "SCF"  
078f f1			.pastdmark: pop af  
0790			endm  
# End of macro DMARK
0790					CALLMONITOR 
0790 cd 49 17			call break_point_state  
0793				endm  
# End of macro CALLMONITOR
0793				endif 
0793			 
0793 22 4c f8			ld (store_tmppageid), hl 
0796				 
0796 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0799			;	ld a, (store_filecache)			; save to cache 
0799			 
0799 32 62 f8			ld (store_page),a    ; set page id 
079c 3e 00			ld a, 0			 ; extent 0 is file header 
079e 32 63 f8			ld (store_page+1), a   ; set file extent 
07a1			 
07a1 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a4			 
07a4			;	inc hl 		; init block 0 of file 
07a4			;	inc hl   		; skip file and extent id 
07a4			 ;       ld a, 0 
07a4			;	ld (hl),a 
07a4			;	ld a, (store_filecache+1)  	; save to cache 
07a4			 
07a4			;	inc hl    ; file name 
07a4				 
07a4				 
07a4 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a7				if DEBUG_STORESE 
07a7					DMARK "SCc" 
07a7 f5				push af  
07a8 3a bc 07			ld a, (.dmark)  
07ab 32 77 fb			ld (debug_mark),a  
07ae 3a bd 07			ld a, (.dmark+1)  
07b1 32 78 fb			ld (debug_mark+1),a  
07b4 3a be 07			ld a, (.dmark+2)  
07b7 32 79 fb			ld (debug_mark+2),a  
07ba 18 03			jr .pastdmark  
07bc ..			.dmark: db "SCc"  
07bf f1			.pastdmark: pop af  
07c0			endm  
# End of macro DMARK
07c0					CALLMONITOR 
07c0 cd 49 17			call break_point_state  
07c3				endm  
# End of macro CALLMONITOR
07c3				endif 
07c3 e1				pop hl    ; get zero term string 
07c4 e5				push hl 
07c5 3e 00			ld a, 0 
07c7 cd 75 11			call strlent 
07ca 23				inc hl   ; cover zero term 
07cb 06 00			ld b,0 
07cd 4d				ld c,l 
07ce e1				pop hl 
07cf				;ex de, hl 
07cf				if DEBUG_STORESE 
07cf					DMARK "SCa" 
07cf f5				push af  
07d0 3a e4 07			ld a, (.dmark)  
07d3 32 77 fb			ld (debug_mark),a  
07d6 3a e5 07			ld a, (.dmark+1)  
07d9 32 78 fb			ld (debug_mark+1),a  
07dc 3a e6 07			ld a, (.dmark+2)  
07df 32 79 fb			ld (debug_mark+2),a  
07e2 18 03			jr .pastdmark  
07e4 ..			.dmark: db "SCa"  
07e7 f1			.pastdmark: pop af  
07e8			endm  
# End of macro DMARK
07e8					;push af 
07e8					;ld a, 'a' 
07e8					;ld (debug_mark),a 
07e8					;pop af 
07e8					CALLMONITOR 
07e8 cd 49 17			call break_point_state  
07eb				endm  
# End of macro CALLMONITOR
07eb				endif 
07eb ed b0			ldir    ; copy zero term string 
07ed				if DEBUG_STORESE 
07ed					DMARK "SCA" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 77 fb			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 78 fb			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 79 fb			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "SCA"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 49 17			call break_point_state  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809			 
0809				; write file header page 
0809			 
0809 2a 4c f8			ld hl,(store_tmppageid) 
080c 11 62 f8			ld de, store_page 
080f				if DEBUG_STORESE 
080f					DMARK "SCb" 
080f f5				push af  
0810 3a 24 08			ld a, (.dmark)  
0813 32 77 fb			ld (debug_mark),a  
0816 3a 25 08			ld a, (.dmark+1)  
0819 32 78 fb			ld (debug_mark+1),a  
081c 3a 26 08			ld a, (.dmark+2)  
081f 32 79 fb			ld (debug_mark+2),a  
0822 18 03			jr .pastdmark  
0824 ..			.dmark: db "SCb"  
0827 f1			.pastdmark: pop af  
0828			endm  
# End of macro DMARK
0828					;push af 
0828					;ld a, 'b' 
0828					;ld (debug_mark),a 
0828					;pop af 
0828					CALLMONITOR 
0828 cd 49 17			call break_point_state  
082b				endm  
# End of macro CALLMONITOR
082b				endif 
082b cd 71 03			call storage_write_block 
082e			 
082e 3a 5b f8			ld a, (store_tmpid) 
0831 6f				ld l, a 
0832 26 00			ld h,0 
0834				if DEBUG_STORESE 
0834					DMARK "SCz" 
0834 f5				push af  
0835 3a 49 08			ld a, (.dmark)  
0838 32 77 fb			ld (debug_mark),a  
083b 3a 4a 08			ld a, (.dmark+1)  
083e 32 78 fb			ld (debug_mark+1),a  
0841 3a 4b 08			ld a, (.dmark+2)  
0844 32 79 fb			ld (debug_mark+2),a  
0847 18 03			jr .pastdmark  
0849 ..			.dmark: db "SCz"  
084c f1			.pastdmark: pop af  
084d			endm  
# End of macro DMARK
084d					CALLMONITOR 
084d cd 49 17			call break_point_state  
0850				endm  
# End of macro CALLMONITOR
0850				endif 
0850 c9				ret 
0851				 
0851			 
0851			 
0851			; 
0851			; Read File 
0851			; 
0851			; h - file id to locate 
0851			; l - extent to locate 
0851			; de - pointer to string to read into 
0851			; 
0851			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0851			 
0851			.sr_fail: 
0851 d1				pop de 
0852 c9				ret 
0853			 
0853			storage_read: 
0853 d5				push de 
0854			 
0854			; TODO BUG the above push is it popped before the RET Z? 
0854			 
0854			; TODO how to handle multiple part blocks 
0854			 
0854				; locate file extent to read 
0854			 
0854 5c				ld e, h 
0855 55				ld d, l 
0856 21 40 00			ld hl, STORE_BLOCK_PHY 
0859				if DEBUG_STORESE 
0859					DMARK "SRE" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 77 fb			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 78 fb			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 79 fb			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "SRE"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 49 17			call break_point_state  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875 cd 2d 06			call storage_findnextid 
0878			 
0878				if DEBUG_STORESE 
0878					DMARK "SRf" 
0878 f5				push af  
0879 3a 8d 08			ld a, (.dmark)  
087c 32 77 fb			ld (debug_mark),a  
087f 3a 8e 08			ld a, (.dmark+1)  
0882 32 78 fb			ld (debug_mark+1),a  
0885 3a 8f 08			ld a, (.dmark+2)  
0888 32 79 fb			ld (debug_mark+2),a  
088b 18 03			jr .pastdmark  
088d ..			.dmark: db "SRf"  
0890 f1			.pastdmark: pop af  
0891			endm  
# End of macro DMARK
0891					CALLMONITOR 
0891 cd 49 17			call break_point_state  
0894				endm  
# End of macro CALLMONITOR
0894				endif 
0894 cd 35 0d			call ishlzero 
0897			;	ld a, l 
0897			;	add h 
0897			;	cp 0 
0897 28 b8			jr z,.sr_fail			; block not found so EOF 
0899			 
0899				; hl contains page number to load 
0899 d1				pop de   ; get storage 
089a d5				push de 
089b				if DEBUG_STORESE 
089b					DMARK "SRg" 
089b f5				push af  
089c 3a b0 08			ld a, (.dmark)  
089f 32 77 fb			ld (debug_mark),a  
08a2 3a b1 08			ld a, (.dmark+1)  
08a5 32 78 fb			ld (debug_mark+1),a  
08a8 3a b2 08			ld a, (.dmark+2)  
08ab 32 79 fb			ld (debug_mark+2),a  
08ae 18 03			jr .pastdmark  
08b0 ..			.dmark: db "SRg"  
08b3 f1			.pastdmark: pop af  
08b4			endm  
# End of macro DMARK
08b4					CALLMONITOR 
08b4 cd 49 17			call break_point_state  
08b7				endm  
# End of macro CALLMONITOR
08b7				endif 
08b7 cd 0c 03			call storage_read_block 
08ba			 
08ba			 
08ba			; TODO if block has no zeros then need to read next block  
08ba			 
08ba			 
08ba					 
08ba e1				pop hl 		 ; return start of data to show as not EOF 
08bb 23				inc hl   ; past file id 
08bc 23				inc hl   ; past ext 
08bd				if DEBUG_STORESE 
08bd					DMARK "SRe" 
08bd f5				push af  
08be 3a d2 08			ld a, (.dmark)  
08c1 32 77 fb			ld (debug_mark),a  
08c4 3a d3 08			ld a, (.dmark+1)  
08c7 32 78 fb			ld (debug_mark+1),a  
08ca 3a d4 08			ld a, (.dmark+2)  
08cd 32 79 fb			ld (debug_mark+2),a  
08d0 18 03			jr .pastdmark  
08d2 ..			.dmark: db "SRe"  
08d5 f1			.pastdmark: pop af  
08d6			endm  
# End of macro DMARK
08d6					CALLMONITOR 
08d6 cd 49 17			call break_point_state  
08d9				endm  
# End of macro CALLMONITOR
08d9				endif 
08d9 c9					ret 
08da			 
08da			 
08da			 
08da			; 
08da			; Append File 
08da			; 
08da			; hl - file id to locate 
08da			; de - pointer to (multi block) string to write 
08da			 
08da			 
08da			storage_append: 
08da				; hl -  file id to append to 
08da				; de - string to append 
08da			 
08da d5				push de 
08db				 
08db				if DEBUG_STORESE 
08db					DMARK "AP1" 
08db f5				push af  
08dc 3a f0 08			ld a, (.dmark)  
08df 32 77 fb			ld (debug_mark),a  
08e2 3a f1 08			ld a, (.dmark+1)  
08e5 32 78 fb			ld (debug_mark+1),a  
08e8 3a f2 08			ld a, (.dmark+2)  
08eb 32 79 fb			ld (debug_mark+2),a  
08ee 18 03			jr .pastdmark  
08f0 ..			.dmark: db "AP1"  
08f3 f1			.pastdmark: pop af  
08f4			endm  
# End of macro DMARK
08f4					CALLMONITOR 
08f4 cd 49 17			call break_point_state  
08f7				endm  
# End of macro CALLMONITOR
08f7				endif 
08f7			 
08f7 7d				ld a, l 
08f8 32 5b f8			ld (store_tmpid), a 
08fb			 
08fb				; get file header  
08fb			 
08fb 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08fd 3a 5b f8			ld a, (store_tmpid) 
0900 5f				ld e, a 
0901			 
0901 21 40 00				ld hl, STORE_BLOCK_PHY 
0904 cd 2d 06				call storage_findnextid 
0907			 
0907 22 4c f8			ld (store_tmppageid), hl 
090a			 
090a				; TODO handle file id not found 
090a			 
090a				if DEBUG_STORESE 
090a					DMARK "AP2" 
090a f5				push af  
090b 3a 1f 09			ld a, (.dmark)  
090e 32 77 fb			ld (debug_mark),a  
0911 3a 20 09			ld a, (.dmark+1)  
0914 32 78 fb			ld (debug_mark+1),a  
0917 3a 21 09			ld a, (.dmark+2)  
091a 32 79 fb			ld (debug_mark+2),a  
091d 18 03			jr .pastdmark  
091f ..			.dmark: db "AP2"  
0922 f1			.pastdmark: pop af  
0923			endm  
# End of macro DMARK
0923					CALLMONITOR 
0923 cd 49 17			call break_point_state  
0926				endm  
# End of macro CALLMONITOR
0926				endif 
0926			 
0926				; update file extent count 
0926			 
0926 11 62 f8			ld de, store_page 
0929			 
0929 cd 0c 03			call storage_read_block 
092c			 
092c				if DEBUG_STORESE 
092c					DMARK "AP3" 
092c f5				push af  
092d 3a 41 09			ld a, (.dmark)  
0930 32 77 fb			ld (debug_mark),a  
0933 3a 42 09			ld a, (.dmark+1)  
0936 32 78 fb			ld (debug_mark+1),a  
0939 3a 43 09			ld a, (.dmark+2)  
093c 32 79 fb			ld (debug_mark+2),a  
093f 18 03			jr .pastdmark  
0941 ..			.dmark: db "AP3"  
0944 f1			.pastdmark: pop af  
0945			endm  
# End of macro DMARK
0945					CALLMONITOR 
0945 cd 49 17			call break_point_state  
0948				endm  
# End of macro CALLMONITOR
0948				endif 
0948			;	ld (store_tmppageid), hl 
0948			 
0948 3a 64 f8			ld a, (store_page+2) 
094b 3c				inc a 
094c 32 64 f8			ld (store_page+2), a 
094f 32 5a f8			ld (store_tmpext), a 
0952				 
0952				if DEBUG_STORESE 
0952					DMARK "AP3" 
0952 f5				push af  
0953 3a 67 09			ld a, (.dmark)  
0956 32 77 fb			ld (debug_mark),a  
0959 3a 68 09			ld a, (.dmark+1)  
095c 32 78 fb			ld (debug_mark+1),a  
095f 3a 69 09			ld a, (.dmark+2)  
0962 32 79 fb			ld (debug_mark+2),a  
0965 18 03			jr .pastdmark  
0967 ..			.dmark: db "AP3"  
096a f1			.pastdmark: pop af  
096b			endm  
# End of macro DMARK
096b					CALLMONITOR 
096b cd 49 17			call break_point_state  
096e				endm  
# End of macro CALLMONITOR
096e				endif 
096e 2a 4c f8			ld hl, (store_tmppageid) 
0971 11 62 f8			ld de, store_page 
0974 cd 71 03			call storage_write_block 
0977			 
0977				; find free block 
0977			 
0977 11 00 00			ld de, 0			 ; file extent to locate 
097a			 
097a 21 40 00				ld hl, STORE_BLOCK_PHY 
097d cd 2d 06				call storage_findnextid 
0980			 
0980					; TODO handle no space left 
0980					 
0980 22 4c f8				ld (store_tmppageid), hl 
0983			 
0983				if DEBUG_STORESE 
0983					DMARK "AP4" 
0983 f5				push af  
0984 3a 98 09			ld a, (.dmark)  
0987 32 77 fb			ld (debug_mark),a  
098a 3a 99 09			ld a, (.dmark+1)  
098d 32 78 fb			ld (debug_mark+1),a  
0990 3a 9a 09			ld a, (.dmark+2)  
0993 32 79 fb			ld (debug_mark+2),a  
0996 18 03			jr .pastdmark  
0998 ..			.dmark: db "AP4"  
099b f1			.pastdmark: pop af  
099c			endm  
# End of macro DMARK
099c					CALLMONITOR 
099c cd 49 17			call break_point_state  
099f				endm  
# End of macro CALLMONITOR
099f				endif 
099f					; init the buffer with zeros so we can id if the buffer is full or not 
099f			 
099f e5					push hl 
09a0 c5					push bc 
09a1			 
09a1 21 62 f8				ld hl, store_page 
09a4 06 40				ld b, STORE_BLOCK_PHY 
09a6 3e 00				ld a, 0 
09a8 77			.zeroblock:	ld (hl), a 
09a9 23					inc hl 
09aa 10 fc				djnz .zeroblock 
09ac			 
09ac c1					pop bc 
09ad e1					pop hl 
09ae			 
09ae					; construct block 
09ae			 
09ae 3a 5b f8				ld a, (store_tmpid) 
09b1 32 62 f8				ld (store_page), a   ; file id 
09b4 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09b7 32 63 f8				ld (store_page+1), a 
09ba			 
09ba e1					pop hl    ; get string to write 
09bb 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09bd 11 64 f8				ld de, store_page+2 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP5" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 77 fb			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 78 fb			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 79 fb			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP5"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 49 17			call break_point_state  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			 
09dc			 
09dc			 
09dc					; fill buffer with data until end of string or full block 
09dc			 
09dc 7e			.appd:		ld a, (hl) 
09dd 12					ld (de), a 
09de fe 00				cp 0 
09e0 28 04				jr z, .appdone 
09e2 23					inc hl 
09e3 13					inc de 
09e4 10 f6				djnz .appd 
09e6			 
09e6 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e7 f5					push af   		; save last byte dumped 
09e8			 
09e8			 
09e8 2a 4c f8			ld hl, (store_tmppageid) 
09eb 11 62 f8			ld de, store_page 
09ee				if DEBUG_STORESE 
09ee					DMARK "AP6" 
09ee f5				push af  
09ef 3a 03 0a			ld a, (.dmark)  
09f2 32 77 fb			ld (debug_mark),a  
09f5 3a 04 0a			ld a, (.dmark+1)  
09f8 32 78 fb			ld (debug_mark+1),a  
09fb 3a 05 0a			ld a, (.dmark+2)  
09fe 32 79 fb			ld (debug_mark+2),a  
0a01 18 03			jr .pastdmark  
0a03 ..			.dmark: db "AP6"  
0a06 f1			.pastdmark: pop af  
0a07			endm  
# End of macro DMARK
0a07					CALLMONITOR 
0a07 cd 49 17			call break_point_state  
0a0a				endm  
# End of macro CALLMONITOR
0a0a				endif 
0a0a cd 71 03				call storage_write_block 
0a0d			 
0a0d			 
0a0d				; was that a full block of data written? 
0a0d				; any more to write out? 
0a0d			 
0a0d				; if yes then set vars and jump to start of function again 
0a0d			 
0a0d f1					pop af 
0a0e d1					pop de 
0a0f			 
0a0f fe 00				cp 0		 ; no, string was fully written 
0a11 c8					ret z 
0a12			 
0a12					; setup vars for next cycle 
0a12			 
0a12 3a 5b f8				ld a, (store_tmpid) 
0a15 6f					ld l, a 
0a16 26 00				ld h, 0 
0a18			 
0a18 c3 da 08			 	jp storage_append	 ; yes, need to write out some more 
0a1b			 
0a1b			 
0a1b			 
0a1b			 
0a1b			 
0a1b			 
0a1b			 
0a1b			if DEBUG_STORECF 
0a1b			storageput:	 
0a1b					ret 
0a1b			storageread: 
0a1b					ld hl, store_page 
0a1b					ld b, 200 
0a1b					ld a,0 
0a1b			.src:		ld (hl),a 
0a1b					inc hl 
0a1b					djnz .src 
0a1b					 
0a1b			 
0a1b					ld de, 0 
0a1b					ld bc, 1 
0a1b					ld hl, store_page 
0a1b					call cfRead 
0a1b			 
0a1b				call cfGetError 
0a1b				ld hl,scratch 
0a1b				call hexout 
0a1b				ld hl, scratch+2 
0a1b				ld a, 0 
0a1b				ld (hl),a 
0a1b				ld de, scratch 
0a1b				ld a,display_row_1 
0a1b				call str_at_display 
0a1b				call update_display 
0a1b			 
0a1b					ld hl, store_page 
0a1b					ld (os_cur_ptr),hl 
0a1b			 
0a1b					ret 
0a1b			endif 
0a1b			 
0a1b			 
0a1b			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a1b			 
0a1b			storage_clear_page: 
0a1b e5				push hl 
0a1c d5				push de 
0a1d c5				push bc 
0a1e 21 62 f8			ld hl, store_page 
0a21 3e 00			ld a, 0 
0a23 77				ld (hl), a 
0a24			 
0a24 11 63 f8			ld de, store_page+1 
0a27 01 40 00			ld bc, STORE_BLOCK_PHY 
0a2a			 
0a2a ed b0			ldir 
0a2c				 
0a2c c1				pop bc 
0a2d d1				pop de 
0a2e e1				pop hl 
0a2f c9				ret 
0a30			 
0a30			; eof 
# End of file firmware_storage.asm
0a30			  
0a30			; support routines for above hardware abstraction layer  
0a30			  
0a30			include "firmware_general.asm"        ; general support functions  
0a30			 
0a30			; word look up 
0a30			 
0a30			; in 
0a30			; a is the index 
0a30			; hl is pointer start of array 
0a30			; 
0a30			; returns 
0a30			; hl to the word 
0a30			; 
0a30			 
0a30			table_lookup:  
0a30 d5					push de 
0a31 eb					ex de, hl 
0a32			 
0a32 6f					ld l, a 
0a33 26 00				ld h, 0 
0a35 29					add hl, hl 
0a36 19					add hl, de 
0a37 7e					ld a, (hl) 
0a38 23					inc hl 
0a39 66					ld h,(hl) 
0a3a 6f					ld l, a 
0a3b			 
0a3b d1					pop de 
0a3c c9					ret 
0a3d			 
0a3d			; Delay loops 
0a3d			 
0a3d			 
0a3d			 
0a3d			aDelayInMS: 
0a3d c5				push bc 
0a3e 47				ld b,a 
0a3f			msdelay: 
0a3f c5				push bc 
0a40				 
0a40			 
0a40 01 41 00			ld bc,041h 
0a43 cd 5b 0a			call delayloop 
0a46 c1				pop bc 
0a47 05				dec b 
0a48 20 f5			jr nz,msdelay 
0a4a			 
0a4a			;if CPU_CLOCK_8MHZ 
0a4a			;msdelay8: 
0a4a			;	push bc 
0a4a			;	 
0a4a			; 
0a4a			;	ld bc,041h 
0a4a			;	call delayloop 
0a4a			;	pop bc 
0a4a			;	dec b 
0a4a			;	jr nz,msdelay8 
0a4a			;endif 
0a4a			 
0a4a			 
0a4a c1				pop bc 
0a4b c9				ret 
0a4c			 
0a4c			 
0a4c			delay250ms: 
0a4c				;push de 
0a4c 01 00 40			ld bc, 04000h 
0a4f c3 5b 0a			jp delayloop 
0a52			delay500ms: 
0a52				;push de 
0a52 01 00 80			ld bc, 08000h 
0a55 c3 5b 0a			jp delayloop 
0a58			delay1s: 
0a58				;push bc 
0a58			   ; Clobbers A, d and e 
0a58 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a5b			delayloop: 
0a5b c5			    push bc 
0a5c			 
0a5c			if BASE_CPM 
0a5c				ld bc, CPM_DELAY_TUNE 
0a5c			.cpmloop: 
0a5c				push bc 
0a5c			 
0a5c			endif 
0a5c			 
0a5c			 
0a5c			 
0a5c			delayloopi: 
0a5c			;	push bc 
0a5c			;.dl: 
0a5c cb 47		    bit     0,a    	; 8 
0a5e cb 47		    bit     0,a    	; 8 
0a60 cb 47		    bit     0,a    	; 8 
0a62 e6 ff		    and     255  	; 7 
0a64 0b			    dec     bc      	; 6 
0a65 79			    ld      a,c     	; 4 
0a66 b0			    or      b     	; 4 
0a67 c2 5c 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a6a			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a6a				;pop de 
0a6a			;pop bc 
0a6a			 
0a6a			if BASE_CPM 
0a6a				pop bc 
0a6a				 
0a6a			    dec     bc      	; 6 
0a6a			    ld      a,c     	; 4 
0a6a			    or      b     	; 4 
0a6a			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a6a				 
0a6a			 
0a6a			endif 
0a6a			;if CPU_CLOCK_8MHZ 
0a6a			;    pop bc 
0a6a			;    push bc 
0a6a			;.dl8: 
0a6a			;    bit     0,a    	; 8 
0a6a			;    bit     0,a    	; 8 
0a6a			;    bit     0,a    	; 8 
0a6a			;    and     255  	; 7 
0a6a			;    dec     bc      	; 6 
0a6a			;    ld      a,c     	; 4 
0a6a			;    or      b     	; 4 
0a6a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a6a			;endif 
0a6a			 
0a6a			;if CPU_CLOCK_10MHZ 
0a6a			;    pop bc 
0a6a			;    push bc 
0a6a			;.dl8: 
0a6a			;    bit     0,a    	; 8 
0a6a			;    bit     0,a    	; 8 
0a6a			;    bit     0,a    	; 8 
0a6a			;    and     255  	; 7 
0a6a			;    dec     bc      	; 6 
0a6a			;    ld      a,c     	; 4 
0a6a			;    or      b     	; 4 
0a6a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a6a			;endif 
0a6a c1			    pop bc 
0a6b			 
0a6b c9				ret 
0a6c			 
0a6c			 
0a6c			 
0a6c			; eof 
# End of file firmware_general.asm
0a6c			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a6c			; display routines that use the physical hardware abstraction layer 
0a6c			 
0a6c			 
0a6c			; information window 
0a6c			 
0a6c			; pass hl with 1st string to display 
0a6c			; pass de with 2nd string to display 
0a6c			 
0a6c			info_panel: 
0a6c e5				push hl 
0a6d			 
0a6d 2a d8 f8			ld hl, (display_fb_active) 
0a70 e5				push hl    ; future de destination 
0a71 21 bd fa				ld hl, display_fb0 
0a74 22 d8 f8				ld (display_fb_active), hl 
0a77			 
0a77 cd d8 0a			call clear_display 
0a7a			 
0a7a			 
0a7a 3e 55			ld a, display_row_3 + 5 
0a7c cd eb 0a			call str_at_display 
0a7f			 
0a7f e1				pop hl 
0a80 d1				pop de 
0a81			 
0a81 e5				push hl 
0a82			 
0a82			 
0a82 3e 2d			ld a, display_row_2 + 5 
0a84 cd eb 0a			call str_at_display 
0a87			 
0a87			 
0a87 cd fb 0a			call update_display 
0a8a cd 51 1c			call next_page_prompt 
0a8d cd d8 0a			call clear_display 
0a90			 
0a90				 
0a90 21 1c fa				ld hl, display_fb1 
0a93 22 d8 f8				ld (display_fb_active), hl 
0a96 cd fb 0a			call update_display 
0a99			 
0a99			 
0a99 c9				ret 
0a9a			 
0a9a			 
0a9a			 
0a9a			 
0a9a			; TODO windowing? 
0a9a			 
0a9a			; TODO scroll line up 
0a9a			 
0a9a			scroll_up: 
0a9a			 
0a9a e5				push hl 
0a9b d5				push de 
0a9c c5				push bc 
0a9d			 
0a9d				; get frame buffer  
0a9d			 
0a9d 2a d8 f8			ld hl, (display_fb_active) 
0aa0 e5				push hl    ; future de destination 
0aa1			 
0aa1 11 28 00			ld  de, display_cols 
0aa4 19				add hl, de 
0aa5			 
0aa5 d1				pop de 
0aa6			 
0aa6				;ex de, hl 
0aa6 01 9f 00			ld bc, display_fb_len -1  
0aa9			;if DEBUG_FORTH_WORDS 
0aa9			;	DMARK "SCL" 
0aa9			;	CALLMONITOR 
0aa9			;endif	 
0aa9 ed b0			ldir 
0aab			 
0aab				; wipe bottom row 
0aab			 
0aab			 
0aab 2a d8 f8			ld hl, (display_fb_active) 
0aae 11 a0 00			ld de, display_cols*display_rows 
0ab1 19				add hl, de 
0ab2 06 28			ld b, display_cols 
0ab4 3e 20			ld a, ' ' 
0ab6			.scwipe: 
0ab6 77				ld (hl), a 
0ab7 2b				dec hl 
0ab8 10 fc			djnz .scwipe 
0aba			 
0aba				;pop hl 
0aba			 
0aba c1				pop bc 
0abb d1				pop de 
0abc e1				pop hl 
0abd			 
0abd c9				ret 
0abe			 
0abe			 
0abe			;scroll_upo: 
0abe			;	ld de, display_row_1 
0abe			 ;	ld hl, display_row_2 
0abe			;	ld bc, display_cols 
0abe			;	ldir 
0abe			;	ld de, display_row_2 
0abe			 ;	ld hl, display_row_3 
0abe			;	ld bc, display_cols 
0abe			;	ldir 
0abe			;	ld de, display_row_3 
0abe			 ;	ld hl, display_row_4 
0abe			;	ld bc, display_cols 
0abe			;	ldir 
0abe			 
0abe			; TODO clear row 4 
0abe			 
0abe			;	ret 
0abe			 
0abe				 
0abe			scroll_down: 
0abe			 
0abe e5				push hl 
0abf d5				push de 
0ac0 c5				push bc 
0ac1			 
0ac1				; get frame buffer  
0ac1			 
0ac1 2a d8 f8			ld hl, (display_fb_active) 
0ac4			 
0ac4 11 9f 00			ld de, display_fb_len - 1 
0ac7 19				add hl, de 
0ac8			 
0ac8 e5			push hl    ; future de destination 
0ac9			 
0ac9 11 28 00			ld  de, display_cols 
0acc ed 52			sbc hl, de 
0ace			 
0ace			 
0ace d1				pop de 
0acf			 
0acf			;	ex de, hl 
0acf 01 9f 00			ld bc, display_fb_len -1  
0ad2			 
0ad2			 
0ad2				 
0ad2			 
0ad2 ed b0			ldir 
0ad4			 
0ad4				; wipe bottom row 
0ad4			 
0ad4			 
0ad4			;	ld hl, (display_fb_active) 
0ad4			;;	ld de, display_cols*display_rows 
0ad4			;;	add hl, de 
0ad4			;	ld b, display_cols 
0ad4			;	ld a, ' ' 
0ad4			;.scwiped: 
0ad4			;	ld (hl), a 
0ad4			;	dec hl 
0ad4			;	djnz .scwiped 
0ad4			 
0ad4				;pop hl 
0ad4			 
0ad4 c1				pop bc 
0ad5 d1				pop de 
0ad6 e1				pop hl 
0ad7			 
0ad7 c9				ret 
0ad8			;scroll_down: 
0ad8			;	ld de, display_row_4 
0ad8			;	ld hl, display_row_3 
0ad8			;	ld bc, display_cols 
0ad8			;	ldir 
0ad8			;	ld de, display_row_3 
0ad8			; 	ld hl, display_row_2 
0ad8			;	ld bc, display_cols 
0ad8			;	ldir 
0ad8			;	ld de, display_row_2 
0ad8			;	ld hl, display_row_1 
0ad8			;	ld bc, display_cols 
0ad8			;	ldir 
0ad8			;;; TODO clear row 1 
0ad8			;	ret 
0ad8			 
0ad8			 
0ad8			 
0ad8			 
0ad8			 
0ad8			; clear active frame buffer 
0ad8			 
0ad8			clear_display: 
0ad8 3e 20			ld a, ' ' 
0ada c3 dd 0a			jp fill_display 
0add			 
0add			; fill active frame buffer with a char in A 
0add			 
0add			fill_display: 
0add 06 a0			ld b,display_fb_len 
0adf 2a d8 f8			ld hl, (display_fb_active) 
0ae2 77			.fd1:	ld (hl),a 
0ae3 23				inc hl 
0ae4 10 fc			djnz .fd1 
0ae6 23				inc hl 
0ae7 3e 00			ld a,0 
0ae9 77				ld (hl),a 
0aea			 
0aea			 
0aea c9				ret 
0aeb			; Write string (DE) at pos (A) to active frame buffer 
0aeb			 
0aeb 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aee 06 00					ld b,0 
0af0 4f					ld c,a 
0af1 09					add hl,bc 
0af2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0af3 b7			            OR   A              ;Null terminator? 
0af4 c8			            RET  Z              ;Yes, so finished 
0af5 77					ld (hl),a 
0af6 23				inc hl 
0af7 13			            INC  DE             ;Point to next character 
0af8 18 f8		            JR   .sad1     ;Repeat 
0afa c9					ret 
0afb			 
0afb			; using current frame buffer write to physical display 
0afb			 
0afb			update_display: 
0afb e5				push hl 
0afc 2a d8 f8			ld hl, (display_fb_active) 
0aff cd 90 65			call write_display 
0b02 e1				pop hl 
0b03 c9				ret 
0b04			 
0b04			; TODO scrolling 
0b04			 
0b04			 
0b04			; move cursor right one char 
0b04			cursor_right: 
0b04			 
0b04				; TODO shift right 
0b04				; TODO if beyond max col 
0b04				; TODO       cursor_next_line 
0b04			 
0b04 c9				ret 
0b05			 
0b05			 
0b05			cursor_next_line: 
0b05				; TODO first char 
0b05				; TODO line down 
0b05				; TODO if past last row 
0b05				; TODO    scroll up 
0b05			 
0b05 c9				ret 
0b06			 
0b06			cursor_left: 
0b06				; TODO shift left 
0b06				; TODO if beyond left  
0b06				; TODO     cursor prev line 
0b06				 
0b06 c9				ret 
0b07			 
0b07			cursor_prev_line: 
0b07				; TODO last char 
0b07				; TODO line up 
0b07				; TODO if past first row 
0b07				; TODO   scroll down 
0b07			 
0b07 c9				ret 
0b08			 
0b08			 
0b08			cout: 
0b08				; A - char 
0b08 c9				ret 
0b09			 
0b09			 
0b09			; Display a menu and allow item selection (optional toggle items) 
0b09			; 
0b09			; format: 
0b09			; hl pointer to word array with zero term for items 
0b09			; e.g.    db item1 
0b09			;         db .... 
0b09			;         db 0 
0b09			; 
0b09			; a = starting menu item  
0b09			; 
0b09			; de = pointer item toggle array   (todo) 
0b09			; 
0b09			; returns item selected in a 1-... 
0b09			; returns 0 if back button pressed 
0b09			; 
0b09			; NOTE: Uses system frame buffer to display 
0b09			; 
0b09			; LEFT, Q = go back 
0b09			; RIGHT, SPACE, CR = select 
0b09			; UP, A - Up 
0b09			; DOWN, Z - Down 
0b09			 
0b09			 
0b09			 
0b09			 
0b09			 
0b09			menu: 
0b09			 
0b09					; keep array pointer 
0b09			 
0b09 22 60 f8				ld (store_tmp1), hl 
0b0c 32 5e f8				ld (store_tmp2), a 
0b0f			 
0b0f					; check for key bounce 
0b0f			 
0b0f			if BASE_KEV 
0b0f			 
0b0f cd db 68		.mbounce:	call cin 
0b12 fe 00				cp 0 
0b14 20 f9				jr nz, .mbounce 
0b16			endif 
0b16					; for ease use ex 
0b16			 
0b16					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b16 21 bd fa				ld hl, display_fb0 
0b19 22 d8 f8				ld (display_fb_active), hl 
0b1c			 
0b1c cd d8 0a		.mloop:		call clear_display 
0b1f cd fb 0a				call update_display 
0b22			 
0b22					; draw selection id '>' at 1 
0b22			 
0b22					; init start of list display 
0b22			 
0b22 3e 05				ld a, 5 
0b24 32 5c f8				ld (store_tmp3), a   ; display row count 
0b27 3a 5e f8				ld a,( store_tmp2) 
0b2a 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b2d			 
0b2d					 
0b2d			.mitem:	 
0b2d			 
0b2d			 
0b2d 3a 5f f8				ld a,(store_tmp2+1) 
0b30 6f					ld l, a 
0b31 26 00				ld h, 0 
0b33 29					add hl, hl 
0b34 ed 5b 60 f8			ld de, (store_tmp1) 
0b38 19					add hl, de 
0b39 7e					ld a, (hl) 
0b3a 23					inc hl 
0b3b 66					ld h,(hl) 
0b3c 6f					ld l, a 
0b3d			 
0b3d cd 35 0d				call ishlzero 
0b40 28 1a				jr z, .mdone 
0b42			 
0b42 eb					ex de, hl 
0b43 3a 5c f8				ld a, (store_tmp3) 
0b46 cd eb 0a				call str_at_display 
0b49					 
0b49			 
0b49					; next item 
0b49 3a 5f f8				ld a, (store_tmp2+1) 
0b4c 3c					inc a 
0b4d 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b50			 
0b50			 		; next row 
0b50			 
0b50 3a 5c f8				ld a, (store_tmp3) 
0b53 c6 28				add display_cols 
0b55 32 5c f8				ld (store_tmp3), a 
0b58			 
0b58					; at end of screen? 
0b58			 
0b58 fe 10				cp display_rows*4 
0b5a 20 d1				jr nz, .mitem 
0b5c			 
0b5c			 
0b5c			.mdone: 
0b5c cd 35 0d				call ishlzero 
0b5f 28 08				jr z, .nodn 
0b61			 
0b61 3e 78				ld a, display_row_4 
0b63 11 e2 0b				ld de, .mdown 
0b66 cd eb 0a				call str_at_display 
0b69			 
0b69					; draw options to fill the screens with active item on line 1 
0b69					; if current option is 2 or more then display ^ in top 
0b69			 
0b69 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b6c fe 00				cp 0 
0b6e 28 08				jr z, .noup 
0b70			 
0b70 3e 00				ld a, 0 
0b72 11 e0 0b				ld de, .mup 
0b75 cd eb 0a				call str_at_display 
0b78			 
0b78 3e 02		.noup:		ld a, 2 
0b7a 11 de 0b				ld de, .msel 
0b7d cd eb 0a				call str_at_display 
0b80			 
0b80					; if current option + 1 is not null then display V in bottom 
0b80					; get key 
0b80 cd fb 0a				call update_display 
0b83			 
0b83			 
0b83					; handle key 
0b83			 
0b83 cd ca 68				call cin_wait 
0b86			 
0b86 fe 05				cp KEY_UP 
0b88 28 2b				jr z, .mgoup 
0b8a fe 61				cp 'a' 
0b8c 28 27				jr z, .mgoup 
0b8e fe 0a				cp KEY_DOWN 
0b90 28 32				jr z, .mgod 
0b92 fe 7a				cp 'z' 
0b94 28 2e				jr z, .mgod 
0b96 fe 20				cp ' ' 
0b98 28 34				jr z, .goend 
0b9a fe 0c				cp KEY_RIGHT 
0b9c 28 30				jr z, .goend 
0b9e fe 0d				cp KEY_CR 
0ba0 28 2c				jr z, .goend 
0ba2 fe 71				cp 'q' 
0ba4 28 0b				jr z, .goback 
0ba6			 
0ba6 fe 0b				cp KEY_LEFT 
0ba8 28 07				jr z, .goback 
0baa fe 08				cp KEY_BS 
0bac 28 03				jr z, .goback 
0bae c3 1c 0b				jp .mloop 
0bb1			 
0bb1			.goback: 
0bb1 3e 00			ld a, 0 
0bb3 18 1d			jr .goend2 
0bb5			 
0bb5				; move up one 
0bb5			.mgoup: 
0bb5 3a 5e f8				ld a, (store_tmp2) 
0bb8 fe 00				cp 0 
0bba ca 1c 0b				jp z, .mloop 
0bbd 3d					dec a 
0bbe 32 5e f8				ld (store_tmp2), a 
0bc1 c3 1c 0b				jp .mloop 
0bc4			 
0bc4				; move down one 
0bc4			.mgod: 
0bc4 3a 5e f8				ld a, (store_tmp2) 
0bc7 3c					inc a 
0bc8 32 5e f8				ld (store_tmp2), a 
0bcb c3 1c 0b				jp .mloop 
0bce			 
0bce			 
0bce			.goend: 
0bce					; get selected item number 
0bce			 
0bce 3a 5e f8				ld a, (store_tmp2) 
0bd1 3c					inc a 
0bd2			 
0bd2			.goend2: 
0bd2 f5					push af 
0bd3			 
0bd3					; restore active fb 
0bd3					; TODO BUG assumes fb1 
0bd3			 
0bd3 21 1c fa				ld hl, display_fb1 
0bd6 22 d8 f8				ld (display_fb_active), hl 
0bd9			 
0bd9					; restore main regs 
0bd9			 
0bd9			 
0bd9 cd fb 0a				call update_display 
0bdc			 
0bdc f1					pop af 
0bdd			 
0bdd c9				ret 
0bde			 
0bde .. 00		.msel:   db ">",0 
0be0 .. 00		.mup:   db "^",0 
0be2 .. 00		.mdown:   db "v",0 
0be4			 
0be4			 
0be4			; eof 
0be4			 
# End of file firmware_display.asm
0be4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0be4			; random number generators 
0be4			 
0be4			 
0be4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0be4			 
0be4			 
0be4			;-----> Generate a random number 
0be4			; output a=answer 0<=a<=255 
0be4			; all registers are preserved except: af 
0be4			random: 
0be4 e5			        push    hl 
0be5 d5			        push    de 
0be6 2a ba f8		        ld      hl,(randData) 
0be9 ed 5f		        ld      a,r 
0beb 57			        ld      d,a 
0bec 5e			        ld      e,(hl) 
0bed 19			        add     hl,de 
0bee 85			        add     a,l 
0bef ac			        xor     h 
0bf0 22 ba f8		        ld      (randData),hl 
0bf3 d1			        pop     de 
0bf4 e1			        pop     hl 
0bf5 c9			        ret 
0bf6			 
0bf6			 
0bf6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf6			 
0bf6			 
0bf6			 
0bf6			;------LFSR------ 
0bf6			;James Montelongo 
0bf6			;optimized by Spencer Putt 
0bf6			;out: 
0bf6			; a = 8 bit random number 
0bf6			RandLFSR: 
0bf6 21 c0 f8		        ld hl,LFSRSeed+4 
0bf9 5e			        ld e,(hl) 
0bfa 23			        inc hl 
0bfb 56			        ld d,(hl) 
0bfc 23			        inc hl 
0bfd 4e			        ld c,(hl) 
0bfe 23			        inc hl 
0bff 7e			        ld a,(hl) 
0c00 47			        ld b,a 
0c01 cb 13		        rl e  
0c03 cb 12			rl d 
0c05 cb 11		        rl c  
0c07 17				rla 
0c08 cb 13		        rl e  
0c0a cb 12			rl d 
0c0c cb 11		        rl c  
0c0e 17				rla 
0c0f cb 13		        rl e  
0c11 cb 12			rl d 
0c13 cb 11		        rl c  
0c15 17				rla 
0c16 67			        ld h,a 
0c17 cb 13		        rl e  
0c19 cb 12			rl d 
0c1b cb 11		        rl c  
0c1d 17				rla 
0c1e a8			        xor b 
0c1f cb 13		        rl e  
0c21 cb 12			rl d 
0c23 ac			        xor h 
0c24 a9			        xor c 
0c25 aa			        xor d 
0c26 21 c2 f8		        ld hl,LFSRSeed+6 
0c29 11 c3 f8		        ld de,LFSRSeed+7 
0c2c 01 07 00		        ld bc,7 
0c2f ed b8		        lddr 
0c31 12			        ld (de),a 
0c32 c9			        ret 
0c33			 
0c33			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c33			 
0c33			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c33			 
0c33			 
0c33			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c33			 
0c33			prng16: 
0c33			;Inputs: 
0c33			;   (seed1) contains a 16-bit seed value 
0c33			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c33			;Outputs: 
0c33			;   HL is the result 
0c33			;   BC is the result of the LCG, so not that great of quality 
0c33			;   DE is preserved 
0c33			;Destroys: 
0c33			;   AF 
0c33			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c33			;160cc 
0c33			;26 bytes 
0c33 2a b4 f8		    ld hl,(seed1) 
0c36 44			    ld b,h 
0c37 4d			    ld c,l 
0c38 29			    add hl,hl 
0c39 29			    add hl,hl 
0c3a 2c			    inc l 
0c3b 09			    add hl,bc 
0c3c 22 b4 f8		    ld (seed1),hl 
0c3f 2a b2 f8		    ld hl,(seed2) 
0c42 29			    add hl,hl 
0c43 9f			    sbc a,a 
0c44 e6 2d		    and %00101101 
0c46 ad			    xor l 
0c47 6f			    ld l,a 
0c48 22 b2 f8		    ld (seed2),hl 
0c4b 09			    add hl,bc 
0c4c c9			    ret 
0c4d			 
0c4d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c4d			 
0c4d			rand32: 
0c4d			;Inputs: 
0c4d			;   (seed1_0) holds the lower 16 bits of the first seed 
0c4d			;   (seed1_1) holds the upper 16 bits of the first seed 
0c4d			;   (seed2_0) holds the lower 16 bits of the second seed 
0c4d			;   (seed2_1) holds the upper 16 bits of the second seed 
0c4d			;   **NOTE: seed2 must be non-zero 
0c4d			;Outputs: 
0c4d			;   HL is the result 
0c4d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c4d			;Destroys: 
0c4d			;   AF 
0c4d			;Tested and passes all CAcert tests 
0c4d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c4d			;it has a period of 18,446,744,069,414,584,320 
0c4d			;roughly 18.4 quintillion. 
0c4d			;LFSR taps: 0,2,6,7  = 11000101 
0c4d			;291cc 
0c4d			;seed1_0=$+1 
0c4d			;    ld hl,12345 
0c4d			;seed1_1=$+1 
0c4d			;    ld de,6789 
0c4d			;    ld b,h 
0c4d			;    ld c,l 
0c4d			;    add hl,hl \ rl e \ rl d 
0c4d			;    add hl,hl \ rl e \ rl d 
0c4d			;    inc l 
0c4d			;    add hl,bc 
0c4d			;    ld (seed1_0),hl 
0c4d			;    ld hl,(seed1_1) 
0c4d			;    adc hl,de 
0c4d			;    ld (seed1_1),hl 
0c4d			;    ex de,hl 
0c4d			;seed2_0=$+1 
0c4d			;    ld hl,9876 
0c4d			;seed2_1=$+1 
0c4d			;    ld bc,54321 
0c4d			;    add hl,hl \ rl c \ rl b 
0c4d			;    ld (seed2_1),bc 
0c4d			;    sbc a,a 
0c4d			;    and %11000101 
0c4d			;    xor l 
0c4d			;    ld l,a 
0c4d			;    ld (seed2_0),hl 
0c4d			;    ex de,hl 
0c4d			;    add hl,bc 
0c4d			;    ret 
0c4d			; 
0c4d			 
0c4d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c4d			; 20 bytes, 86 cycles (excluding ret) 
0c4d			 
0c4d			; returns   hl = pseudorandom number 
0c4d			; corrupts   a 
0c4d			 
0c4d			; generates 16-bit pseudorandom numbers with a period of 65535 
0c4d			; using the xorshift method: 
0c4d			 
0c4d			; hl ^= hl << 7 
0c4d			; hl ^= hl >> 9 
0c4d			; hl ^= hl << 8 
0c4d			 
0c4d			; some alternative shift triplets which also perform well are: 
0c4d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c4d			 
0c4d			;  org 32768 
0c4d			 
0c4d			xrnd: 
0c4d 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c50 3e 00		  ld a,0 
0c52 bd			  cp l 
0c53 20 02		  jr nz, .xrnd1 
0c55 2e 01		  ld l, 1 
0c57			.xrnd1: 
0c57			 
0c57 7c			  ld a,h 
0c58 1f			  rra 
0c59 7d			  ld a,l 
0c5a 1f			  rra 
0c5b ac			  xor h 
0c5c 67			  ld h,a 
0c5d 7d			  ld a,l 
0c5e 1f			  rra 
0c5f 7c			  ld a,h 
0c60 1f			  rra 
0c61 ad			  xor l 
0c62 6f			  ld l,a 
0c63 ac			  xor h 
0c64 67			  ld h,a 
0c65			 
0c65 22 b8 f8		  ld (xrandc),hl 
0c68			 
0c68 c9			  ret 
0c69			;  
0c69			 
0c69			 
0c69			;;;; int maths 
0c69			 
0c69			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c69			; Divide 16-bit values (with 16-bit result) 
0c69			; In: Divide BC by divider DE 
0c69			; Out: BC = result, HL = rest 
0c69			; 
0c69			Div16: 
0c69 21 00 00		    ld hl,0 
0c6c 78			    ld a,b 
0c6d 06 08		    ld b,8 
0c6f			Div16_Loop1: 
0c6f 17			    rla 
0c70 ed 6a		    adc hl,hl 
0c72 ed 52		    sbc hl,de 
0c74 30 01		    jr nc,Div16_NoAdd1 
0c76 19			    add hl,de 
0c77			Div16_NoAdd1: 
0c77 10 f6		    djnz Div16_Loop1 
0c79 17			    rla 
0c7a 2f			    cpl 
0c7b 47			    ld b,a 
0c7c 79			    ld a,c 
0c7d 48			    ld c,b 
0c7e 06 08		    ld b,8 
0c80			Div16_Loop2: 
0c80 17			    rla 
0c81 ed 6a		    adc hl,hl 
0c83 ed 52		    sbc hl,de 
0c85 30 01		    jr nc,Div16_NoAdd2 
0c87 19			    add hl,de 
0c88			Div16_NoAdd2: 
0c88 10 f6		    djnz Div16_Loop2 
0c8a 17			    rla 
0c8b 2f			    cpl 
0c8c 41			    ld b,c 
0c8d 4f			    ld c,a 
0c8e c9			ret 
0c8f			 
0c8f			 
0c8f			;http://z80-heaven.wikidot.com/math 
0c8f			; 
0c8f			;Inputs: 
0c8f			;     DE and A are factors 
0c8f			;Outputs: 
0c8f			;     A is not changed 
0c8f			;     B is 0 
0c8f			;     C is not changed 
0c8f			;     DE is not changed 
0c8f			;     HL is the product 
0c8f			;Time: 
0c8f			;     342+6x 
0c8f			; 
0c8f			Mult16: 
0c8f			 
0c8f 06 08		     ld b,8          ;7           7 
0c91 21 00 00		     ld hl,0         ;10         10 
0c94 29			       add hl,hl     ;11*8       88 
0c95 07			       rlca          ;4*8        32 
0c96 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c98 19			         add hl,de   ;--         -- 
0c99 10 f9		       djnz $-5      ;13*7+8     99 
0c9b c9			ret 
0c9c			 
0c9c			; 
0c9c			; Square root of 16-bit value 
0c9c			; In:  HL = value 
0c9c			; Out:  D = result (rounded down) 
0c9c			; 
0c9c			;Sqr16: 
0c9c			;    ld de,#0040 
0c9c			;    ld a,l 
0c9c			;    ld l,h 
0c9c			;    ld h,d 
0c9c			;    or a 
0c9c			;    ld b,8 
0c9c			;Sqr16_Loop: 
0c9c			;    sbc hl,de 
0c9c			;    jr nc,Sqr16_Skip 
0c9c			;    add hl,de 
0c9c			;Sqr16_Skip: 
0c9c			;    ccf 
0c9c			;    rl d 
0c9c			;    add a,a 
0c9c			;    adc hl,hl 
0c9c			;    add a,a 
0c9c			;    adc hl,hl 
0c9c			;    djnz Sqr16_Loop 
0c9c			;    ret 
0c9c			; 
0c9c			; 
0c9c			; Divide 8-bit values 
0c9c			; In: Divide E by divider C 
0c9c			; Out: A = result, B = rest 
0c9c			; 
0c9c			Div8: 
0c9c af			    xor a 
0c9d 06 08		    ld b,8 
0c9f			Div8_Loop: 
0c9f cb 13		    rl e 
0ca1 17			    rla 
0ca2 91			    sub c 
0ca3 30 01		    jr nc,Div8_NoAdd 
0ca5 81			    add a,c 
0ca6			Div8_NoAdd: 
0ca6 10 f7		    djnz Div8_Loop 
0ca8 47			    ld b,a 
0ca9 7b			    ld a,e 
0caa 17			    rla 
0cab 2f			    cpl 
0cac c9			    ret 
0cad			 
0cad			; 
0cad			; Multiply 8-bit value with a 16-bit value (unrolled) 
0cad			; In: Multiply A with DE 
0cad			; Out: HL = result 
0cad			; 
0cad			Mult12U: 
0cad 2e 00		    ld l,0 
0caf 87			    add a,a 
0cb0 30 01		    jr nc,Mult12U_NoAdd0 
0cb2 19			    add hl,de 
0cb3			Mult12U_NoAdd0: 
0cb3 29			    add hl,hl 
0cb4 87			    add a,a 
0cb5 30 01		    jr nc,Mult12U_NoAdd1 
0cb7 19			    add hl,de 
0cb8			Mult12U_NoAdd1: 
0cb8 29			    add hl,hl 
0cb9 87			    add a,a 
0cba 30 01		    jr nc,Mult12U_NoAdd2 
0cbc 19			    add hl,de 
0cbd			Mult12U_NoAdd2: 
0cbd 29			    add hl,hl 
0cbe 87			    add a,a 
0cbf 30 01		    jr nc,Mult12U_NoAdd3 
0cc1 19			    add hl,de 
0cc2			Mult12U_NoAdd3: 
0cc2 29			    add hl,hl 
0cc3 87			    add a,a 
0cc4 30 01		    jr nc,Mult12U_NoAdd4 
0cc6 19			    add hl,de 
0cc7			Mult12U_NoAdd4: 
0cc7 29			    add hl,hl 
0cc8 87			    add a,a 
0cc9 30 01		    jr nc,Mult12U_NoAdd5 
0ccb 19			    add hl,de 
0ccc			Mult12U_NoAdd5: 
0ccc 29			    add hl,hl 
0ccd 87			    add a,a 
0cce 30 01		    jr nc,Mult12U_NoAdd6 
0cd0 19			    add hl,de 
0cd1			Mult12U_NoAdd6: 
0cd1 29			    add hl,hl 
0cd2 87			    add a,a 
0cd3 d0			    ret nc 
0cd4 19			    add hl,de 
0cd5 c9			    ret 
0cd6			 
0cd6			; 
0cd6			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd6			; In: Multiply A with DE 
0cd6			;      Put lowest value in A for most efficient calculation 
0cd6			; Out: HL = result 
0cd6			; 
0cd6			Mult12R: 
0cd6 21 00 00		    ld hl,0 
0cd9			Mult12R_Loop: 
0cd9 cb 3f		    srl a 
0cdb 30 01		    jr nc,Mult12R_NoAdd 
0cdd 19			    add hl,de 
0cde			Mult12R_NoAdd: 
0cde cb 23		    sla e 
0ce0 cb 12		    rl d 
0ce2 b7			    or a 
0ce3 c2 d9 0c		    jp nz,Mult12R_Loop 
0ce6 c9			    ret 
0ce7			 
0ce7			; 
0ce7			; Multiply 16-bit values (with 32-bit result) 
0ce7			; In: Multiply BC with DE 
0ce7			; Out: BCHL = result 
0ce7			; 
0ce7			Mult32: 
0ce7 79			    ld a,c 
0ce8 48			    ld c,b 
0ce9 21 00 00		    ld hl,0 
0cec 06 10		    ld b,16 
0cee			Mult32_Loop: 
0cee 29			    add hl,hl 
0cef 17			    rla 
0cf0 cb 11		    rl c 
0cf2 30 07		    jr nc,Mult32_NoAdd 
0cf4 19			    add hl,de 
0cf5 ce 00		    adc a,0 
0cf7 d2 fb 0c		    jp nc,Mult32_NoAdd 
0cfa 0c			    inc c 
0cfb			Mult32_NoAdd: 
0cfb 10 f1		    djnz Mult32_Loop 
0cfd 41			    ld b,c 
0cfe 4f			    ld c,a 
0cff c9			    ret 
0d00			 
0d00			 
0d00			 
0d00			; 
0d00			; Multiply 8-bit values 
0d00			; In:  Multiply H with E 
0d00			; Out: HL = result 
0d00			; 
0d00			Mult8: 
0d00 16 00		    ld d,0 
0d02 6a			    ld l,d 
0d03 06 08		    ld b,8 
0d05			Mult8_Loop: 
0d05 29			    add hl,hl 
0d06 30 01		    jr nc,Mult8_NoAdd 
0d08 19			    add hl,de 
0d09			Mult8_NoAdd: 
0d09 10 fa		    djnz Mult8_Loop 
0d0b c9			    ret 
0d0c			 
0d0c			 
0d0c			 
0d0c			 
0d0c			 
0d0c			 
0d0c			 
0d0c			 
0d0c			;;http://z80-heaven.wikidot.com/math 
0d0c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d0c			; 
0d0c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d0c			;     ld a,16        ;7 
0d0c			;     ld hl,0        ;10 
0d0c			;     jp $+5         ;10 
0d0c			;.DivLoop: 
0d0c			;       add hl,bc    ;-- 
0d0c			;       dec a        ;64 
0d0c			;       jr z,.DivLoopEnd        ;86 
0d0c			; 
0d0c			;       sla e        ;128 
0d0c			;       rl d         ;128 
0d0c			;       adc hl,hl    ;240 
0d0c			;       sbc hl,bc    ;240 
0d0c			;       jr nc,.DivLoop ;23|21 
0d0c			;       inc e        ;-- 
0d0c			;       jp .DivLoop+1 
0d0c			; 
0d0c			;.DivLoopEnd: 
0d0c			 
0d0c			;HL_Div_C: 
0d0c			;Inputs: 
0d0c			;     HL is the numerator 
0d0c			;     C is the denominator 
0d0c			;Outputs: 
0d0c			;     A is the remainder 
0d0c			;     B is 0 
0d0c			;     C is not changed 
0d0c			;     DE is not changed 
0d0c			;     HL is the quotient 
0d0c			; 
0d0c			;       ld b,16 
0d0c			;       xor a 
0d0c			;         add hl,hl 
0d0c			;         rla 
0d0c			;         cp c 
0d0c			;         jr c,$+4 
0d0c			;           inc l 
0d0c			;           sub c 
0d0c			;         djnz $-7 
0d0c			 
0d0c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d0c			 
0d0c			addatohl: 
0d0c 85			    add   a, l    ; A = A+L 
0d0d 6f			    ld    l, a    ; L = A+L 
0d0e 8c			    adc   a, h    ; A = A+L+H+carry 
0d0f 95			    sub   l       ; A = H+carry 
0d10 67			    ld    h, a    ; H = H+carry 
0d11 c9			ret 
0d12			 
0d12			addatode: 
0d12 83			    add   a, e    ; A = A+L 
0d13 5f			    ld    e, a    ; L = A+L 
0d14 8a			    adc   a, d    ; A = A+L+H+carry 
0d15 93			    sub   e       ; A = H+carry 
0d16 57			    ld    d, a    ; H = H+carry 
0d17 c9			ret 
0d18			 
0d18			 
0d18			addatobc: 
0d18 81			    add   a, c    ; A = A+L 
0d19 4f			    ld    c, a    ; L = A+L 
0d1a 88			    adc   a, b    ; A = A+L+H+carry 
0d1b 91			    sub   c       ; A = H+carry 
0d1c 47			    ld    b, a    ; H = H+carry 
0d1d c9			ret 
0d1e			 
0d1e			subafromhl: 
0d1e			   ; If A=0 do nothing 
0d1e			    ; Otherwise flip A's sign. Since 
0d1e			    ; the upper byte becomes -1, also 
0d1e			    ; substract 1 from H. 
0d1e ed 44		    neg 
0d20 ca 29 0d		    jp    z, Skip 
0d23 25			    dec   h 
0d24			     
0d24			    ; Now add the low byte as usual 
0d24			    ; Two's complement takes care of 
0d24			    ; ensuring the result is correct 
0d24 85			    add   a, l 
0d25 6f			    ld    l, a 
0d26 8c			    adc   a, h 
0d27 95			    sub   l 
0d28 67			    ld    h, a 
0d29			Skip: 
0d29 c9				ret 
0d2a			 
0d2a			 
0d2a			; compare hl and de 
0d2a			; returns:  
0d2a			; if hl = de, z=1, s=0, c0=0 
0d2a			; if hl > de, z=0, s=0, c=0 
0d2a			; if hl < de, z=0, s=1, c=1 
0d2a			cmp16:	 
0d2a b7				or a 
0d2b ed 52			sbc hl,de 
0d2d e0				ret po 
0d2e 7c				ld a,h 
0d2f 1f				rra 
0d30 ee 40			xor 01000000B 
0d32 37				scf 
0d33 8f				adc a,a 
0d34 c9				ret 
0d35			 
0d35			 
0d35			; test if hl contains zero   - A is destroyed 
0d35			 
0d35			ishlzero:    
0d35 b7				or a     ; reset flags 
0d36 7c				ld a, h 
0d37 b5				or l        	 
0d38			 
0d38 c9				ret 
0d39			 
0d39			 
0d39			 
0d39			 
0d39			if FORTH_ENABLE_FLOATMATH 
0d39			;include "float/bbcmath.z80" 
0d39			include "float/lpfpcalc.asm" 
0d39			endif 
0d39			 
0d39			 
0d39			; eof 
0d39			 
# End of file firmware_maths.asm
0d39			include "firmware_strings.asm"   ; string handling  
0d39			 
0d39			 
0d39			; TODO string len 
0d39			; input text string, end on cr with zero term 
0d39			; a offset into frame buffer to start prompt 
0d39			; d is max length 
0d39			; e is display size TODO 
0d39			; c is current cursor position 
0d39			; hl is ptr to where string will be stored 
0d39			 
0d39			 
0d39			; TODO check limit of buffer for new inserts 
0d39			; TODO check insert does not push beyond buffer 
0d39			; TODO scroll in a limited display area 
0d39			; TODO scroll whole screen on page wrap 
0d39			 
0d39			 
0d39			; TODO handle KEY_PREVWORD 
0d39			; TODO handle KEY_NEXTWORD 
0d39			; TODO handle KEY_HOME 
0d39			; TODO handle KEY_END 
0d39			; TODO use LCD cursor? 
0d39			 
0d39 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d3c 81					add c 
0d3d 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d40 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d43 79					ld a, c 
0d44 cd 0c 0d				call addatohl 
0d47 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d4a 7a					ld a,d 
0d4b 32 72 fb			        ld (input_size), a       ; save length of input area 
0d4e 79					ld a, c 
0d4f 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d52 7b					ld a,e 
0d53 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d56					 
0d56					 
0d56			 
0d56			;		ld a,(input_ptr) 
0d56			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d56			 
0d56			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d56					; init cursor shape if not set by the cin routines 
0d56 21 d0 f8				ld hl, cursor_shape 
0d59 3e ff				ld a, 255 
0d5b 77					ld (hl), a 
0d5c 23					inc hl 
0d5d 3e 00				ld a, 0 
0d5f 77					ld (hl), a 
0d60			 
0d60 3e 0f				ld a, CUR_BLINK_RATE 
0d62 32 6c fb				ld (input_cur_flash), a 
0d65 3e 01				ld a, 1 
0d67 32 6b fb				ld (input_cur_onoff),a 
0d6a			 
0d6a			;	if DEBUG_INPUT 
0d6a			;		push af 
0d6a			;		ld a, 'I' 
0d6a			;		ld (debug_mark),a 
0d6a			;		pop af 
0d6a			;		CALLMONITOR 
0d6a			;	endif 
0d6a			.is1:		; main entry loop 
0d6a			 
0d6a			 
0d6a			 
0d6a					; pause 1ms 
0d6a			 
0d6a 3e 01				ld a, 1 
0d6c cd 3d 0a				call aDelayInMS 
0d6f			 
0d6f					; dec flash counter 
0d6f 3a 6c fb				ld a, (input_cur_flash) 
0d72 3d					dec a 
0d73 32 6c fb				ld (input_cur_flash), a 
0d76 fe 00				cp 0 
0d78 20 0d				jr nz, .nochgstate 
0d7a			 
0d7a			 
0d7a					; change state 
0d7a 3a 6b fb				ld a,(input_cur_onoff) 
0d7d ed 44				neg 
0d7f 32 6b fb				ld (input_cur_onoff),a 
0d82			 
0d82			 
0d82					; reset on change of state 
0d82 3e 0f				ld a, CUR_BLINK_RATE 
0d84 32 6c fb				ld (input_cur_flash), a 
0d87			 
0d87			.nochgstate: 
0d87					 
0d87					 
0d87			 
0d87					; display cursor  
0d87			 
0d87			;		ld hl, (input_start) 
0d87			;		ld a, (input_cursor) 
0d87			;		call addatohl 
0d87			 
0d87					; get char under cursor and replace with cursor 
0d87 2a 75 fb		ld hl, (input_ptr) 
0d8a			;		ld a, (hl) 
0d8a			;		ld (input_under_cursor),a 
0d8a			;		ld a, '_' 
0d8a			;		ld (hl), a 
0d8a			 
0d8a					; display string 
0d8a			 
0d8a ed 5b 73 fb			ld de, (input_start) 
0d8e 3a 70 fb				ld a, (input_at_pos) 
0d91 cd eb 0a				call str_at_display 
0d94			;	        call update_display 
0d94			 
0d94					; find place to put the cursor 
0d94			;		add h 
0d94			;		ld l, display_row_1 
0d94			;		sub l 
0d94			; (input_at_pos) 
0d94					;ld c, a 
0d94			;		ld a, (input_cursor) 
0d94			;		ld l, (input_at_pos) 
0d94			;		;ld b, h 
0d94			;		add l 
0d94			;		ld (input_at_cursor),a 
0d94					;ld l,h 
0d94			 
0d94			;		ld h, 0 
0d94			;		ld l,(input_at_pos) 
0d94			;		ld a, (input_cursor) 
0d94			;		call addatohl 
0d94			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d94			;		call subafromhl 
0d94			;		ld a,l 
0d94			;		ld (input_at_cursor), a 
0d94			 
0d94				if DEBUG_INPUT 
0d94					ld a, (hardware_diag) 
0d94					cp 0 
0d94					jr z, .skip_input_diag 
0d94			 
0d94					ld a,(input_at_pos) 
0d94					ld hl, LFSRSeed 
0d94					call hexout 
0d94					ld a, (input_cursor) 
0d94					ld hl, LFSRSeed+2 
0d94					call hexout 
0d94					ld a,(input_at_cursor) 
0d94					ld hl, LFSRSeed+4 
0d94					call hexout 
0d94			 
0d94					ld a,(input_cur_onoff) 
0d94					ld hl, LFSRSeed+6 
0d94					call hexout 
0d94			 
0d94					ld a,(input_cur_flash) 
0d94					ld hl, LFSRSeed+8 
0d94					call hexout 
0d94			 
0d94					ld a,(input_len) 
0d94					ld hl, LFSRSeed+10 
0d94					call hexout 
0d94					ld hl, LFSRSeed+12 
0d94					ld a, 0 
0d94					ld (hl),a 
0d94					ld a, display_row_4 
0d94					ld de, LFSRSeed 
0d94					call str_at_display 
0d94					.skip_input_diag: 
0d94				endif 
0d94			 
0d94					; decide on if we are showing the cursor this time round 
0d94			 
0d94 3a 6b fb				ld a, (input_cur_onoff) 
0d97 fe ff				cp 255 
0d99 28 13				jr z, .skipcur 
0d9b			 
0d9b			 
0d9b 3a 6e fb				ld a,(input_at_cursor) 
0d9e 11 d0 f8				ld de, cursor_shape 
0da1 cd eb 0a				call str_at_display 
0da4			 
0da4					; save length of current input string 
0da4 2a 73 fb				ld hl, (input_start) 
0da7 cd 6a 11				call strlenz 
0daa 7d					ld a,l 
0dab 32 66 fb				ld (input_len),a 
0dae			 
0dae			.skipcur: 
0dae			 
0dae cd fb 0a			        call update_display 
0db1					 
0db1			 
0db1			 
0db1					; wait 
0db1				 
0db1					; TODO loop without wait to flash the cursor and char under cursor	 
0db1 cd db 68				call cin    ; _wait 
0db4			 
0db4 fe 00				cp 0 
0db6 ca 6a 0d				jp z, .is1 
0db9			 
0db9					; get ptr to char to input into 
0db9			 
0db9 4f					ld c,a 
0dba 2a 73 fb				ld hl, (input_start) 
0dbd 3a 61 fb				ld a, (input_cursor) 
0dc0 cd 0c 0d				call addatohl 
0dc3 22 75 fb				ld (input_ptr), hl 
0dc6 79					ld a,c 
0dc7			 
0dc7					; replace char under cursor 
0dc7			 
0dc7			;		ld hl, (input_ptr) 
0dc7			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc7			;		ld (hl), a 
0dc7			 
0dc7			;	if DEBUG_INPUT 
0dc7			;		push af 
0dc7			;		ld a, 'i' 
0dc7			;		ld (debug_mark),a 
0dc7			;		pop af 
0dc7			;		CALLMONITOR 
0dc7			;	endif 
0dc7 fe 0e				cp KEY_HOME 
0dc9 20 0e				jr nz, .iske 
0dcb			 
0dcb 3a 70 fb				ld a, (input_at_pos) 
0dce 32 6e fb				ld (input_at_cursor),a 
0dd1 3e 00				ld a, 0 
0dd3 32 61 fb				ld (input_cursor), a 
0dd6 c3 6a 0d				jp .is1 
0dd9					 
0dd9 fe 0f		.iske:		cp KEY_END 
0ddb 20 03				jr nz, .isknw 
0ddd c3 6a 0d				jp .is1 
0de0			 
0de0 fe 06		.isknw:		cp KEY_NEXTWORD 
0de2 20 1b				jr nz, .iskpw 
0de4			 
0de4 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0de7 7e					ld a,(hl)	 
0de8 fe 00				cp 0 
0dea ca 6a 0d				jp z, .is1    ; end of string 
0ded fe 20				cp ' ' 
0def ca 6a 0d				jp z, .is1    ; end of word 
0df2 23					inc hl 
0df3 22 75 fb				ld (input_ptr), hl 
0df6 3a 6e fb				ld a, (input_at_cursor) 
0df9 3c					inc a 
0dfa 32 6e fb				ld (input_at_cursor), a 
0dfd 18 e5				jr .isknwm 
0dff			 
0dff fe 07		.iskpw:		cp KEY_PREVWORD 
0e01 20 1b				jr nz, .iskl 
0e03			.iskpwm:	 
0e03 2a 75 fb				ld hl, (input_ptr) 
0e06 7e					ld a,(hl)	 
0e07 fe 00				cp 0  
0e09 ca 6a 0d				jp z, .is1    ; end of string 
0e0c fe 20				cp ' ' 
0e0e ca 6a 0d				jp z, .is1    ; end of word 
0e11 2b					dec hl 
0e12 22 75 fb				ld (input_ptr), hl 
0e15 3a 6e fb				ld a, (input_at_cursor) 
0e18 3d					dec a 
0e19 32 6e fb				ld (input_at_cursor), a 
0e1c 18 e5				jr .iskpwm 
0e1e			 
0e1e			 
0e1e fe 0b		.iskl:		cp KEY_LEFT 
0e20 20 27				jr nz, .isk1 
0e22			 
0e22 3a 61 fb				ld a, (input_cursor) 
0e25			 
0e25 fe 00				cp 0 
0e27 ca 6a 0d				jp z, .is1 		; at start of line to ignore  
0e2a			 
0e2a 3d					dec  a 		; TODO check underflow 
0e2b 32 61 fb				ld (input_cursor), a 
0e2e			 
0e2e 2a 75 fb				ld hl, (input_ptr) 
0e31 2b					dec hl 
0e32 22 75 fb				ld (input_ptr), hl 
0e35					 
0e35 3a 6e fb				ld a, (input_at_cursor) 
0e38 3d					dec a 
0e39 32 6e fb				ld (input_at_cursor), a 
0e3c			 
0e3c 3e 01				ld a, 1		; show cursor moving 
0e3e 32 6b fb				ld (input_cur_onoff),a 
0e41 3e 0f				ld a, CUR_BLINK_RATE 
0e43 32 6c fb				ld (input_cur_flash), a 
0e46			 
0e46 c3 6a 0d				jp .is1 
0e49			 
0e49 fe 0c		.isk1:		cp KEY_RIGHT 
0e4b 20 2a				jr nz, .isk2 
0e4d			 
0e4d 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e50 5f					ld e,a 
0e51 3a 61 fb				ld a, (input_cursor) 
0e54 bb					cp e 
0e55 ca 6a 0d				jp z, .is1		; at the end of string so dont go right 
0e58			 
0e58 3c					inc  a 		; TODO check overflow 
0e59 32 61 fb				ld (input_cursor), a 
0e5c			 
0e5c 3a 6e fb				ld a, (input_at_cursor) 
0e5f 3c					inc a 
0e60 32 6e fb				ld (input_at_cursor), a 
0e63			 
0e63 2a 75 fb				ld hl, (input_ptr) 
0e66 23					inc hl 
0e67 22 75 fb				ld (input_ptr), hl 
0e6a			 
0e6a 3e 01				ld a, 1		; show cursor moving 
0e6c 32 6b fb				ld (input_cur_onoff),a 
0e6f 3e 0f				ld a, CUR_BLINK_RATE 
0e71 32 6c fb				ld (input_cur_flash), a 
0e74			 
0e74 c3 6a 0d				jp .is1 
0e77			 
0e77 fe 05		.isk2:		cp KEY_UP 
0e79			 
0e79 20 26				jr nz, .isk3 
0e7b			 
0e7b					; swap last command with the current on 
0e7b			 
0e7b					; move cursor to start of string 
0e7b 2a 73 fb				ld hl, (input_start) 
0e7e 22 75 fb				ld (input_ptr), hl 
0e81			 
0e81 3a 70 fb				ld a, (input_at_pos) 
0e84 32 6e fb				ld (input_at_cursor), a 
0e87			 
0e87 3e 00				ld a, 0 
0e89 32 61 fb				ld (input_cursor), a 
0e8c					 
0e8c					; swap input and last command buffers 
0e8c			 
0e8c 21 44 f1				ld hl, os_cli_cmd 
0e8f 11 43 f2				ld de, os_last_cmd 
0e92 06 ff				ld b, 255 
0e94 7e			.swap1:		ld a, (hl) 
0e95 4f					ld c,a 
0e96 1a					ld a, (de) 
0e97 77					ld (hl), a 
0e98 79					ld a,c 
0e99 12					ld (de),a 
0e9a 23					inc hl 
0e9b 13					inc de 
0e9c 10 f6				djnz .swap1 
0e9e			 
0e9e			 
0e9e			 
0e9e			 
0e9e			 
0e9e c3 6a 0d				jp .is1 
0ea1			 
0ea1 fe 08		.isk3:		cp KEY_BS 
0ea3 20 3c				jr nz, .isk4 
0ea5			 
0ea5 3a 61 fb				ld a, (input_cursor) 
0ea8			 
0ea8 fe 00				cp 0 
0eaa ca 6a 0d				jp z, .is1 		; at start of line to ignore  
0ead			 
0ead 3d					dec  a 		; TODO check underflow 
0eae 32 61 fb				ld (input_cursor), a 
0eb1			 
0eb1					; hl is source 
0eb1					; de needs to be source - 1 
0eb1			 
0eb1			;		ld a, 0 
0eb1			;		dec hl 
0eb1			;		ld (hl), a 
0eb1			 
0eb1 2a 75 fb				ld hl, (input_ptr) 
0eb4 2b					dec hl 
0eb5 22 75 fb				ld (input_ptr), hl 
0eb8			 
0eb8					; shift all data 
0eb8			 
0eb8 e5					push hl 
0eb9 23					inc hl 
0eba d1					pop de 
0ebb 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ebe 4f					ld c,a 
0ebf 06 00				ld b,0 
0ec1 ed b0				ldir  
0ec3			 
0ec3			 
0ec3			 
0ec3			 
0ec3 3a 6e fb				ld a, (input_at_cursor) 
0ec6 3d					dec a 
0ec7 32 6e fb				ld (input_at_cursor), a 
0eca			 
0eca			 
0eca 3e 01				ld a, 1		; show cursor moving 
0ecc 32 6b fb				ld (input_cur_onoff),a 
0ecf 3e 0f				ld a, CUR_BLINK_RATE 
0ed1 32 6c fb				ld (input_cur_flash), a 
0ed4			 
0ed4					; remove char 
0ed4 3a 6e fb				ld a, (input_at_cursor) 
0ed7 3c					inc a 
0ed8 11 62 0f				ld de,.iblank 
0edb cd eb 0a				call str_at_display 
0ede			 
0ede c3 6a 0d				jp .is1 
0ee1			 
0ee1 fe 0d		.isk4:		cp KEY_CR 
0ee3 28 6c				jr z, .endinput 
0ee5			 
0ee5					; else add the key press to the end 
0ee5			 
0ee5 4f					ld c, a			; save key pressed 
0ee6			 
0ee6 7e					ld a,(hl)		; get what is currently under char 
0ee7			 
0ee7 fe 00				cp 0			; we are at the end of the string 
0ee9 20 2f				jr nz, .onchar 
0eeb					 
0eeb					; add a char to the end of the string 
0eeb				 
0eeb 71					ld (hl),c 
0eec 23					inc hl 
0eed			;		ld a,' ' 
0eed			;		ld (hl),a 
0eed			;		inc hl 
0eed 3e 00				ld a,0 
0eef 77					ld (hl),a 
0ef0 2b					dec hl 
0ef1			 
0ef1 3a 61 fb				ld a, (input_cursor) 
0ef4 3c					inc a				; TODO check max string length and scroll  
0ef5 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0ef8							 
0ef8 3a 6e fb				ld a, (input_at_cursor) 
0efb 3c					inc a 
0efc 32 6e fb				ld (input_at_cursor), a 
0eff			 
0eff 2a 75 fb				ld hl, (input_ptr) 
0f02 23					inc hl 
0f03 22 75 fb				ld (input_ptr), hl 
0f06			 
0f06 2a 75 fb				ld hl, (input_ptr) 
0f09 23					inc hl 
0f0a 22 75 fb				ld (input_ptr), hl 
0f0d			;	if DEBUG_INPUT 
0f0d			;		push af 
0f0d			;		ld a, '+' 
0f0d			;		ld (debug_mark),a 
0f0d			;		pop af 
0f0d			;		CALLMONITOR 
0f0d			;	endif 
0f0d 3e 01				ld a, 1		; show cursor moving 
0f0f 32 6b fb				ld (input_cur_onoff),a 
0f12 3e 0f				ld a, CUR_BLINK_RATE 
0f14 32 6c fb				ld (input_cur_flash), a 
0f17 c3 6a 0d				jp .is1 
0f1a					 
0f1a			 
0f1a			 
0f1a					; if on a char then insert 
0f1a			.onchar: 
0f1a			 
0f1a					; TODO over flow check: make sure insert does not blow out buffer 
0f1a			 
0f1a					; need to do some maths to use lddr 
0f1a			 
0f1a e5					push hl   ; save char pos 
0f1b c5					push bc 
0f1c			 
0f1c 2a 73 fb				ld hl, (input_start) 
0f1f 3a 66 fb				ld a, (input_len) 
0f22 cd 0c 0d				call addatohl  		; end of string 
0f25 23					inc hl 
0f26 23					inc hl		; past zero term 
0f27 e5					push hl 
0f28 23					inc hl 
0f29 e5					push hl  
0f2a			 
0f2a								; start and end of lddr set, now how much to move? 
0f2a			 
0f2a							 
0f2a 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f2d 47					ld b,a 
0f2e 3a 66 fb				ld a,(input_len) 
0f31 5f					ld e,a 
0f32 90					sub b 
0f33 3c					inc a		;?? 
0f34 3c					inc a		;?? 
0f35 3c					inc a		;?? 
0f36			 
0f36 06 00				ld b,0 
0f38 4f					ld c,a 
0f39			 
0f39				if DEBUG_INPUT 
0f39					push af 
0f39					ld a, 'i' 
0f39					ld (debug_mark),a 
0f39					pop af 
0f39			;		CALLMONITOR 
0f39				endif 
0f39 d1					pop de 
0f3a e1					pop hl 
0f3b				if DEBUG_INPUT 
0f3b					push af 
0f3b					ld a, 'I' 
0f3b					ld (debug_mark),a 
0f3b					pop af 
0f3b			;		CALLMONITOR 
0f3b				endif 
0f3b ed b8				lddr 
0f3d				 
0f3d			 
0f3d			 
0f3d					; TODO have a key for insert/overwrite mode???? 
0f3d c1					pop bc 
0f3e e1					pop hl 
0f3f 71					ld (hl), c		; otherwise overwrite current char 
0f40					 
0f40			 
0f40			 
0f40			 
0f40 3a 61 fb				ld a, (input_cursor) 
0f43 3c					inc  a 		; TODO check overflow 
0f44 32 61 fb				ld (input_cursor), a 
0f47			 
0f47 3a 6e fb				ld a, (input_at_cursor) 
0f4a 3c					inc a 
0f4b 32 6e fb				ld (input_at_cursor), a 
0f4e			 
0f4e c3 6a 0d				jp .is1 
0f51			 
0f51			.endinput:	; TODO look for end of string 
0f51			 
0f51					; add trailing space for end of token 
0f51			 
0f51 2a 73 fb				ld hl, (input_start) 
0f54 3a 66 fb				ld a,(input_len) 
0f57 cd 0c 0d				call addatohl 
0f5a 3e 20				ld a, ' ' 
0f5c 77					ld (hl),a 
0f5d					; TODO eof of parse marker 
0f5d			 
0f5d 23					inc hl 
0f5e 3e 00				ld a, 0 
0f60 77					ld (hl),a 
0f61			 
0f61			 
0f61 c9					ret 
0f62			 
0f62 .. 00		.iblank: db " ",0 
0f64			 
0f64			 
0f64 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f67 22 73 fb				ld (input_start), hl 
0f6a 3e 01				ld a,1			; add cursor 
0f6c 77					ld (hl),a 
0f6d 23					inc hl 
0f6e 3e 00				ld a,0 
0f70 77					ld (hl),a 
0f71 22 75 fb				ld (input_ptr), hl 
0f74 7a					ld a,d 
0f75 32 72 fb				ld (input_size), a 
0f78 3e 00				ld a,0 
0f7a 32 61 fb				ld (input_cursor),a 
0f7d			.instr1:	 
0f7d			 
0f7d					; TODO do block cursor 
0f7d					; TODO switch cursor depending on the modifer key 
0f7d			 
0f7d					; update cursor shape change on key hold 
0f7d			 
0f7d 2a 75 fb				ld hl, (input_ptr) 
0f80 2b					dec hl 
0f81 3a d0 f8				ld a,(cursor_shape) 
0f84 77					ld (hl), a 
0f85			 
0f85					; display entered text 
0f85 3a 70 fb				ld a,(input_at_pos) 
0f88 cd 9f 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f8b ed 5b 73 fb	            	LD   de, (input_start) 
0f8f cd c1 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f92			 
0f92 cd db 68				call cin 
0f95 fe 00				cp 0 
0f97 28 e4				jr z, .instr1 
0f99			 
0f99					; proecess keyboard controls first 
0f99			 
0f99 2a 75 fb				ld hl,(input_ptr) 
0f9c			 
0f9c fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f9e 28 5a				jr z, .instrcr 
0fa0			 
0fa0 fe 08				cp KEY_BS 	; back space 
0fa2 20 0f				jr nz, .instr2 
0fa4					; process back space 
0fa4			 
0fa4					; TODO stop back space if at start of string 
0fa4 2b					dec hl 
0fa5 2b					dec hl ; to over write cursor 
0fa6 3a d0 f8				ld a,(cursor_shape) 
0fa9					;ld a,0 
0fa9 77					ld (hl),a 
0faa 23					inc hl 
0fab 3e 20				ld a," " 
0fad 77					ld (hl),a 
0fae 22 75 fb				ld (input_ptr),hl 
0fb1					 
0fb1			 
0fb1 18 ca				jr .instr1 
0fb3			 
0fb3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fb5 20 06				jr nz, .instr3 
0fb7 2b					dec hl 
0fb8 22 75 fb				ld (input_ptr),hl 
0fbb 18 c0				jr .instr1 
0fbd				 
0fbd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fbf 20 06				jr nz, .instr4 
0fc1 23					inc hl 
0fc2 22 75 fb				ld (input_ptr),hl 
0fc5 18 b6				jr .instr1 
0fc7			 
0fc7 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc9 20 06				jr nz, .instr5 
0fcb 2b					dec hl 
0fcc 22 75 fb				ld (input_ptr),hl 
0fcf 18 ac				jr .instr1 
0fd1			 
0fd1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fd3 20 06				jr nz, .instr6 
0fd5 2b					dec hl 
0fd6 22 75 fb				ld (input_ptr),hl 
0fd9 18 a2				jr .instr1 
0fdb fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fdd 20 0b				jr nz, .instrnew 
0fdf			 
0fdf 21 1d ee			ld hl, scratch 
0fe2 11 43 f2			ld de, os_last_cmd 
0fe5 cd 03 10			call strcpy 
0fe8 18 93				jr .instr1 
0fea			 
0fea			 
0fea			.instrnew:	; no special key pressed to see if we have room to store it 
0fea			 
0fea					; TODO do string size test 
0fea			 
0fea 2b					dec hl ; to over write cursor 
0feb 77					ld (hl),a 
0fec 23					inc hl 
0fed 3a d0 f8				ld a,(cursor_shape) 
0ff0 77					ld (hl),a 
0ff1 23					inc hl 
0ff2 3e 00				ld a,0 
0ff4 77					ld (hl),a 
0ff5			 
0ff5 22 75 fb				ld (input_ptr),hl 
0ff8					 
0ff8 18 83				jr .instr1 
0ffa 2b			.instrcr:	dec hl		; remove cursor 
0ffb 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ffd 77					ld (hl),a 
0ffe 23					inc hl 
0fff 3e 00				ld a,0 
1001 77					ld (hl),a 
1002			 
1002			 
1002					; if at end of line scroll up    
1002					; TODO detecting only end of line 4 for scroll up  
1002			 
1002					;ld   
1002			 
1002 c9					ret 
1003			 
1003			 
1003			; strcpy hl = dest, de source 
1003			 
1003 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1004 b7			            OR   A              ;Null terminator? 
1005 c8			            RET  Z              ;Yes, so finished 
1006 1a					ld a,(de) 
1007 77					ld (hl),a 
1008 13			            INC  DE             ;Point to next character 
1009 23					inc hl 
100a 18 f7		            JR   strcpy       ;Repeat 
100c c9					ret 
100d			 
100d			 
100d			; TODO string_at  
100d			; pass string which starts with lcd offset address and then null term string 
100d			 
100d			; TODO string to dec 
100d			; TODO string to hex 
100d			; TODO byte to string hex 
100d			; TODO byte to string dec 
100d			 
100d			 
100d			 
100d			; from z80uartmonitor 
100d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
100d			; pass hl for where to put the text 
100d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100d c5			hexout:	PUSH BC 
100e f5					PUSH AF 
100f 47					LD B, A 
1010					; Upper nybble 
1010 cb 3f				SRL A 
1012 cb 3f				SRL A 
1014 cb 3f				SRL A 
1016 cb 3f				SRL A 
1018 cd 28 10				CALL tohex 
101b 77					ld (hl),a 
101c 23					inc hl	 
101d					 
101d					; Lower nybble 
101d 78					LD A, B 
101e e6 0f				AND 0FH 
1020 cd 28 10				CALL tohex 
1023 77					ld (hl),a 
1024 23					inc hl	 
1025					 
1025 f1					POP AF 
1026 c1					POP BC 
1027 c9					RET 
1028					 
1028			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1028			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1028			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1028			tohex: 
1028 e5					PUSH HL 
1029 d5					PUSH DE 
102a 16 00				LD D, 0 
102c 5f					LD E, A 
102d 21 35 10				LD HL, .DATA 
1030 19					ADD HL, DE 
1031 7e					LD A, (HL) 
1032 d1					POP DE 
1033 e1					POP HL 
1034 c9					RET 
1035			 
1035			.DATA: 
1035 30					DEFB	30h	; 0 
1036 31					DEFB	31h	; 1 
1037 32					DEFB	32h	; 2 
1038 33					DEFB	33h	; 3 
1039 34					DEFB	34h	; 4 
103a 35					DEFB	35h	; 5 
103b 36					DEFB	36h	; 6 
103c 37					DEFB	37h	; 7 
103d 38					DEFB	38h	; 8 
103e 39					DEFB	39h	; 9 
103f 41					DEFB	41h	; A 
1040 42					DEFB	42h	; B 
1041 43					DEFB	43h	; C 
1042 44					DEFB	44h	; D 
1043 45					DEFB	45h	; E 
1044 46					DEFB	46h	; F 
1045			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1045			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1045			;;    subtract $30, if result > 9 then subtract $7 more 
1045			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1045			atohex: 
1045 d6 30				SUB $30 
1047 fe 0a				CP 10 
1049 f8					RET M		; If result negative it was 0-9 so we're done 
104a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
104c c9					RET		 
104d			 
104d			 
104d			 
104d			 
104d			; Get 2 ASCII characters as hex byte from pointer in hl 
104d			 
104d			BYTERD: 
104d 16 00			LD	D,00h		;Set up 
104f cd 57 10			CALL	HEXCON		;Get byte and convert to hex 
1052 87				ADD	A,A		;First nibble so 
1053 87				ADD	A,A		;multiply by 16 
1054 87				ADD	A,A		; 
1055 87				ADD	A,A		; 
1056 57				LD	D,A		;Save hi nibble in D 
1057			HEXCON: 
1057 7e				ld a, (hl)		;Get next chr 
1058 23				inc hl 
1059 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
105b fe 0a			CP	00Ah		;Is it 0-9 ? 
105d 38 02			JR	C,NALPHA	;If so miss next bit 
105f d6 07			SUB	007h		;Else convert alpha 
1061			NALPHA: 
1061 b2				OR	D		;Add hi nibble back 
1062 c9				RET			; 
1063			 
1063			 
1063			; 
1063			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1063			; Since the routines get_byte and therefore get_nibble are called, only valid 
1063			; characters (0-9a-f) are accepted. 
1063			; 
1063			;get_word        push    af 
1063			;                call    get_byte        ; Get the upper byte 
1063			;                ld      h, a 
1063			;                call    get_byte        ; Get the lower byte 
1063			;                ld      l, a 
1063			;                pop     af 
1063			;                ret 
1063			; 
1063			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1063			; the routine get_nibble is used only valid characters are accepted - the  
1063			; input routine only accepts characters 0-9a-f. 
1063			; 
1063 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1064 7e					ld a,(hl) 
1065 23					inc hl 
1066 cd 8b 10		                call    nibble2val      ; Get upper nibble 
1069 cb 07		                rlc     a 
106b cb 07		                rlc     a 
106d cb 07		                rlc     a 
106f cb 07		                rlc     a 
1071 47			                ld      b, a            ; Save upper four bits 
1072 7e					ld a,(hl) 
1073 cd 8b 10		                call    nibble2val      ; Get lower nibble 
1076 b0			                or      b               ; Combine both nibbles 
1077 c1			                pop     bc              ; Restore B (and C) 
1078 c9			                ret 
1079			; 
1079			; Get a hexadecimal digit from the serial line. This routine blocks until 
1079			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1079			; to the serial line interface. The lower 4 bits of A contain the value of  
1079			; that particular digit. 
1079			; 
1079			;get_nibble      ld a,(hl)           ; Read a character 
1079			;                call    to_upper        ; Convert to upper case 
1079			;                call    is_hex          ; Was it a hex digit? 
1079			;                jr      nc, get_nibble  ; No, get another character 
1079			 ;               call    nibble2val      ; Convert nibble to value 
1079			 ;               call    print_nibble 
1079			 ;               ret 
1079			; 
1079			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1079			; A valid hexadecimal digit is denoted by a set C flag. 
1079			; 
1079			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1079			;                ret     nc              ; Yes 
1079			;                cp      '0'             ; Less than '0'? 
1079			;                jr      nc, is_hex_1    ; No, continue 
1079			;                ccf                     ; Complement carry (i.e. clear it) 
1079			;                ret 
1079			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1079			;                ret     c               ; Yes 
1079			;                cp      'A'             ; Less than 'A'? 
1079			;                jr      nc, is_hex_2    ; No, continue 
1079			;                ccf                     ; Yes - clear carry and return 
1079			;                ret 
1079			;is_hex_2        scf                     ; Set carry 
1079			;                ret 
1079			; 
1079			; Convert a single character contained in A to upper case: 
1079			; 
1079 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
107b d8			                ret     c 
107c fe 7b		                cp      'z' + 1         ; > 'z'? 
107e d0			                ret     nc              ; Nothing to do, either 
107f e6 5f		                and     $5f             ; Convert to upper case 
1081 c9			                ret 
1082			 
1082			 
1082			to_lower: 
1082			 
1082			   ; if char is in [A-Z] make it lower case 
1082			 
1082			   ; enter : a = char 
1082			   ; exit  : a = lower case char 
1082			   ; uses  : af 
1082			 
1082 fe 41		   cp 'A' 
1084 d8			   ret c 
1085			    
1085 fe 5b		   cp 'Z'+1 
1087 d0			   ret nc 
1088			    
1088 f6 20		   or $20 
108a c9			   ret 
108b			 
108b			; 
108b			; Expects a hexadecimal digit (upper case!) in A and returns the 
108b			; corresponding value in A. 
108b			; 
108b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
108d 38 02		                jr      c, nibble2val_1 ; Yes 
108f d6 07		                sub     7               ; Adjust for A-F 
1091 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1093 e6 0f		                and     $f              ; Only return lower 4 bits 
1095 c9			                ret 
1096			; 
1096			; Print_nibble prints a single hex nibble which is contained in the lower  
1096			; four bits of A: 
1096			; 
1096			;print_nibble    push    af              ; We won't destroy the contents of A 
1096			;                and     $f              ; Just in case... 
1096			;                add     a, '0'             ; If we have a digit we are done here. 
1096			;                cp      '9' + 1         ; Is the result > 9? 
1096			;                jr      c, print_nibble_1 
1096			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1096			;print_nibble_1  call    putc            ; Print the nibble and 
1096			;                pop     af              ; restore the original value of A 
1096			;                ret 
1096			;; 
1096			;; Send a CR/LF pair: 
1096			; 
1096			;crlf            push    af 
1096			;                ld      a, cr 
1096			;                call    putc 
1096			;                ld      a, lf 
1096			;                call    putc 
1096			;                pop     af 
1096			;                ret 
1096			; 
1096			; Print_word prints the four hex digits of a word to the serial line. The  
1096			; word is expected to be in HL. 
1096			; 
1096			;print_word      push    hl 
1096			;                push    af 
1096			;                ld      a, h 
1096			;                call    print_byte 
1096			;                ld      a, l 
1096			;                call    print_byte 
1096			;                pop     af 
1096			;                pop     hl 
1096			;                ret 
1096			; 
1096			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1096			; The byte to be printed is expected to be in A. 
1096			; 
1096			;print_byte      push    af              ; Save the contents of the registers 
1096			;                push    bc 
1096			;                ld      b, a 
1096			;                rrca 
1096			;                rrca 
1096			;                rrca 
1096			;                rrca 
1096			;                call    print_nibble    ; Print high nibble 
1096			;                ld      a, b 
1096			;                call    print_nibble    ; Print low nibble 
1096			;                pop     bc              ; Restore original register contents 
1096			;                pop     af 
1096			;                ret 
1096			 
1096			 
1096			 
1096			 
1096			 
1096			fourehexhl:  
1096 7e				ld a,(hl) 
1097 cd 45 10			call atohex 
109a cb 3f				SRL A 
109c cb 3f				SRL A 
109e cb 3f				SRL A 
10a0 cb 3f				SRL A 
10a2 47				ld b, a 
10a3 23				inc hl 
10a4 7e				ld a,(hl) 
10a5 23				inc hl 
10a6 cd 45 10			call atohex 
10a9 80				add b 
10aa 57				ld d,a 
10ab 7e				ld a,(hl) 
10ac cd 45 10			call atohex 
10af cb 3f				SRL A 
10b1 cb 3f				SRL A 
10b3 cb 3f				SRL A 
10b5 cb 3f				SRL A 
10b7 47				ld b, a 
10b8 23				inc hl 
10b9 7e				ld a,(hl) 
10ba 23				inc hl 
10bb cd 45 10			call atohex 
10be 80				add b 
10bf 5f				ld e, a 
10c0 d5				push de 
10c1 e1				pop hl 
10c2 c9				ret 
10c3			 
10c3			; pass hl. returns z set if the byte at hl is a digit 
10c3			;isdigithl:  
10c3			;	push bc 
10c3			;	ld a,(hl) 
10c3			;	cp ':' 
10c3			;	jr nc, .isdf 		; > 
10c3			;	cp '0' 
10c3			;	jr c, .isdf		; < 
10c3			; 
10c3			;	; TODO find a better way to set z 
10c3			; 
10c3			;	ld b,a 
10c3			;	cp b 
10c3			;	pop bc 
10c3			;	ret 
10c3			; 
10c3			;.isdf:	; not digit so clear z 
10c3			; 
10c3			;	; TODO find a better way to unset z 
10c3			; 
10c3			;	ld b,a 
10c3			;	inc b 
10c3			;	cp b 
10c3			; 
10c3			;	pop bc 
10c3			;	ret 
10c3				 
10c3				 
10c3			 
10c3			 
10c3			; pass hl as the four byte address to load 
10c3			 
10c3			get_word_hl:  
10c3 e5				push hl 
10c4 cd 63 10			call get_byte 
10c7				 
10c7 47				ld b, a 
10c8			 
10c8 e1				pop hl 
10c9 23				inc hl 
10ca 23				inc hl 
10cb			 
10cb			; TODO not able to handle a-f  
10cb 7e				ld a,(hl) 
10cc			;	;cp ':' 
10cc			;	cp 'g' 
10cc			;	jr nc, .single_byte_hl 		; > 
10cc			;	cp 'G' 
10cc			;	jr nc, .single_byte_hl 		; > 
10cc			;	cp '0' 
10cc			;	jr c, .single_byte_hl		; < 
10cc			 
10cc				;call isdigithl 
10cc fe 00			cp 0 
10ce 28 06			jr z, .single_byte_hl 
10d0			 
10d0			.getwhln:   ; hex word so get next byte 
10d0			 
10d0 cd 63 10			call get_byte 
10d3 6f				ld l, a 
10d4 60				ld h,b 
10d5 c9				ret 
10d6 68			.single_byte_hl:   ld l,b 
10d7 26 00				ld h,0 
10d9 c9					ret 
10da			 
10da			 
10da			 
10da			 
10da 21 f0 19			ld hl,asc+1 
10dd			;	ld a, (hl) 
10dd			;	call nibble2val 
10dd cd 63 10			call get_byte 
10e0			 
10e0			;	call fourehexhl 
10e0 32 51 ee			ld (scratch+52),a 
10e3				 
10e3 21 4f ee			ld hl,scratch+50 
10e6 22 40 f1			ld (os_cur_ptr),hl 
10e9			 
10e9 c9				ret 
10ea			 
10ea			 
10ea			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10ea			 
10ea			; Decimal Unsigned Version 
10ea			 
10ea			;Number in a to decimal ASCII 
10ea			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10ea			;Example: display a=56 as "056" 
10ea			;input: a = number 
10ea			;Output: a=0,value of a in the screen 
10ea			;destroys af,bc (don't know about hl and de) 
10ea			DispAToASCII: 
10ea 0e 9c			ld	c,-100 
10ec cd f6 10			call	.Na1 
10ef 0e f6			ld	c,-10 
10f1 cd f6 10			call	.Na1 
10f4 0e ff			ld	c,-1 
10f6 06 2f		.Na1:	ld	b,'0'-1 
10f8 04			.Na2:	inc	b 
10f9 81				add	a,c 
10fa 38 fc			jr	c,.Na2 
10fc 91				sub	c		;works as add 100/10/1 
10fd f5				push af		;safer than ld c,a 
10fe 78				ld	a,b		;char is in b 
10ff			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10ff f1				pop af		;safer than ld a,c 
1100 c9				ret 
1101			 
1101			; Decimal Signed Version 
1101			 
1101			; DispA 
1101			; -------------------------------------------------------------- 
1101			; Converts a signed integer value to a zero-terminated ASCII 
1101			; string representative of that value (using radix 10). 
1101			; -------------------------------------------------------------- 
1101			; INPUTS: 
1101			;     HL     Value to convert (two's complement integer). 
1101			;     DE     Base address of string destination. (pointer). 
1101			; -------------------------------------------------------------- 
1101			; OUTPUTS: 
1101			;     None 
1101			; -------------------------------------------------------------- 
1101			; REGISTERS/MEMORY DESTROYED 
1101			; AF HL 
1101			; -------------------------------------------------------------- 
1101			 
1101			;DispHLToASCII: 
1101			;   push    de 
1101			;   push    bc 
1101			; 
1101			;; Detect sign of HL. 
1101			;    bit    7, h 
1101			;    jr     z, ._DoConvert 
1101			; 
1101			;; HL is negative. Output '-' to string and negate HL. 
1101			;    ld     a, '-' 
1101			;    ld     (de), a 
1101			;    inc    de 
1101			; 
1101			;; Negate HL (using two's complement) 
1101			;    xor    a 
1101			;    sub    l 
1101			;    ld     l, a 
1101			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1101			;    sbc    a, h 
1101			;    ld     h, a 
1101			; 
1101			;; Convert HL to digit characters 
1101			;._DoConvert: 
1101			;    ld     b, 0     ; B will count character length of number 
1101			;-   ld     a, 10 
1101			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1101			;    push   af 
1101			;    inc    b 
1101			;    ld     a, h 
1101			;    or     l 
1101			;    jr     nz, - 
1101			; 
1101			;; Retrieve digits from stack 
1101			;-   pop    af 
1101			;    or     $30 
1101			;    ld     (de), a 
1101			;    inc    de 
1101			;    djnz   - 
1101			; 
1101			;; Terminate string with NULL 
1101			;    xor    a 
1101			;    ld     (de), a 
1101			; 
1101			;    pop    bc 
1101			;    pop    de 
1101			;    ret 
1101			 
1101			;Comments 
1101			; 
1101			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1101			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1101			;    Note that the output string will not be fixed-width. 
1101			; 
1101			;Example Usage 
1101			; 
1101			;    ld    hl, -1004 
1101			;    ld    de, OP1 
1101			;    call  DispA 
1101			;    ld    hl, OP1 
1101			;    syscall  PutS 
1101			 
1101			 
1101			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1101			 
1101			 
1101			;Converts an ASCII string to an unsigned 16-bit integer 
1101			;Quits when it reaches a non-decimal digit 
1101			 
1101			string_to_uint16: 
1101			atoui_16: 
1101			;Input: 
1101			;     DE points to the string 
1101			;Outputs: 
1101			;     HL is the result 
1101			;     A is the 8-bit value of the number 
1101			;     DE points to the byte after the number 
1101			;Destroys: 
1101			;     BC 
1101			;       if the string is non-empty, BC is HL/10 
1101			;Size:  24 bytes 
1101			;Speed: 42+d(104+{0,9}) 
1101			;       d is the number of digits in the number 
1101			;       max is 640 cycles for a 5 digit number 
1101			;Assuming no leading zeros: 
1101			;1 digit:  146cc 
1101			;2 digit:  250cc 
1101			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1101			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1101			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1101			;avg: 544.81158447265625cc (544+13297/16384) 
1101			;=============================================================== 
1101 21 00 00		  ld hl,0 
1104			.u16a: 
1104 1a			  ld a,(de) 
1105 d6 30		  sub 30h 
1107 fe 0a		  cp 10 
1109 d0			  ret nc 
110a 13			  inc de 
110b 44			  ld b,h 
110c 4d			  ld c,l 
110d 29			  add hl,hl 
110e 29			  add hl,hl 
110f 09			  add hl,bc 
1110 29			  add hl,hl 
1111 85			  add a,l 
1112 6f			  ld l,a 
1113 30 ef		  jr nc,.u16a 
1115 24			  inc h 
1116 c3 04 11		  jp .u16a 
1119			 
1119			 
1119			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1119			 
1119			;written by Zeda 
1119			;Converts a 16-bit unsigned integer to an ASCII string. 
1119			 
1119			uitoa_16: 
1119			;Input: 
1119			;   DE is the number to convert 
1119			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1119			;Output: 
1119			;   HL points to the null-terminated ASCII string 
1119			;      NOTE: This isn't necessarily the same as the input HL. 
1119 d5			  push de 
111a c5			  push bc 
111b f5			  push af 
111c eb			  ex de,hl 
111d			 
111d 01 f0 d8		  ld bc,-10000 
1120 3e 2f		  ld a,'0'-1 
1122 3c			  inc a 
1123 09			  add hl,bc  
1124 38 fc		   jr c,$-2 
1126 12			  ld (de),a 
1127 13			  inc de 
1128			 
1128 01 e8 03		  ld bc,1000 
112b 3e 3a		  ld a,'9'+1 
112d 3d			  dec a  
112e 09			  add hl,bc  
112f 30 fc		   jr nc,$-2 
1131 12			  ld (de),a 
1132 13			  inc de 
1133			 
1133 01 9c ff		  ld bc,-100 
1136 3e 2f		  ld a,'0'-1 
1138 3c			  inc a  
1139 09			  add hl,bc  
113a 38 fc		   jr c,$-2 
113c 12			  ld (de),a 
113d 13			  inc de 
113e			 
113e 7d			  ld a,l 
113f 26 3a		  ld h,'9'+1 
1141 25			  dec h  
1142 c6 0a		  add a,10  
1144 30 fb		   jr nc,$-3 
1146 c6 30		  add a,'0' 
1148 eb			  ex de,hl 
1149 72			  ld (hl),d 
114a 23			  inc hl 
114b 77			  ld (hl),a 
114c 23			  inc hl 
114d 36 00		  ld (hl),0 
114f			 
114f			;Now strip the leading zeros 
114f 0e fa		  ld c,-6 
1151 09			  add hl,bc 
1152 3e 30		  ld a,'0' 
1154 23			  inc hl  
1155 be			  cp (hl)  
1156 28 fc		  jr z,$-2 
1158			 
1158			;Make sure that the string is non-empty! 
1158 7e			  ld a,(hl) 
1159 b7			  or a 
115a 20 01		  jr nz,.atoub 
115c 2b			  dec hl 
115d			.atoub: 
115d			 
115d f1			  pop af 
115e c1			  pop bc 
115f d1			  pop de 
1160 c9			  ret 
1161			 
1161			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1161			 
1161			toUpper: 
1161			;A is the char. 
1161			;If A is a lowercase letter, this sets it to the matching uppercase 
1161			;18cc or 30cc or 41cc 
1161			;avg: 26.75cc 
1161 fe 61		  cp 'a' 
1163 d8			  ret c 
1164 fe 7b		  cp 'z'+1 
1166 d0			  ret nc 
1167 d6 20		  sub 'a'-'A' 
1169 c9			  ret 
116a			 
116a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
116a			 
116a			; String Length 
116a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
116a			 
116a			; Get the length of the null-terminated string starting at $8000 hl 
116a			;    LD     HL, $8000 
116a			 
116a			strlenz: 
116a			 
116a af			    XOR    A               ; Zero is the value we are looking for. 
116b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
116c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
116d			                           ; 65, 536 bytes (the entire addressable memory space). 
116d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116f			 
116f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1170 6f			    LD     L, A             ; number of bytes 
1171 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1173 2b			    DEC    HL              ; Compensate for null. 
1174 c9				ret 
1175			 
1175			; Get the length of the A terminated string starting at $8000 hl 
1175			;    LD     HL, $8000 
1175			 
1175			strlent: 
1175			 
1175			                  ; A is the value we are looking for. 
1175 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1177 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1179			                           ; 65, 536 bytes (the entire addressable memory space). 
1179 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
117b			 
117b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
117b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
117d 2e 00		    LD     L, 0             ; number of bytes 
117f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1181 2b			    DEC    HL              ; Compensate for null. 
1182 c9				ret 
1183			 
1183			 
1183			;Comparing Strings 
1183			 
1183			;IN    HL     Address of string1. 
1183			;      DE     Address of string2. 
1183			 
1183			; doc given but wrong??? 
1183			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1183			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1183			; tested 
1183			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1183			 
1183			strcmp_old: 
1183 e5			    PUSH   HL 
1184 d5			    PUSH   DE 
1185			 
1185 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1186 be			    CP     (HL)            ; (want to minimize work). 
1187 38 01		    JR     C, Str1IsBigger 
1189 7e			    LD     A, (HL) 
118a			 
118a			Str1IsBigger: 
118a 4f			    LD     C, A             ; Put length in BC 
118b 06 00		    LD     B, 0 
118d 13			    INC    DE              ; Increment pointers to meat of string. 
118e 23			    INC    HL 
118f			 
118f			CmpLoop: 
118f 1a			    LD     A, (DE)          ; Compare bytes. 
1190 ed a1		    CPI 
1192 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1194 13			    INC    DE              ; Update pointer. 
1195 ea 8f 11		    JP     PE, CmpLoop 
1198			 
1198 d1			    POP    DE 
1199 e1			    POP    HL 
119a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
119b be			    CP     (HL) 
119c c9			    RET 
119d			 
119d			NoMatch: 
119d 2b			    DEC    HL 
119e be			    CP     (HL)            ; Compare again to affect carry. 
119f d1			    POP    DE 
11a0 e1			    POP    HL 
11a1 c9			    RET 
11a2			 
11a2			;; test strmp 
11a2			; 
11a2			;ld de, .str1 
11a2			;ld hl, .str2 
11a2			;call strcmp 
11a2			;jr z, .z1 
11a2			;;this 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "NZ1" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			;.z1: 
11a2			; 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "ZZ1" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			; 
11a2			;ld de, .str1 
11a2			;ld hl, .str1 
11a2			;call strcmp 
11a2			;jr z, .z2 
11a2			;;this 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "NZ2" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			;.z2: 
11a2			; 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "ZZ2" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			; 
11a2			;ld de, .str1 
11a2			;ld hl, .str2 
11a2			;call strcmp 
11a2			;jr c, .c1 
11a2			; 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "Nc1" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			;.c1: 
11a2			;;this 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "cc1" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			; 
11a2			;ld de, .str1 
11a2			;ld hl, .str1 
11a2			;call strcmp 
11a2			;jr c, .c2 
11a2			;;this 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "Nc2" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			;.c2: 
11a2			; 
11a2			;	if DEBUG_FORTH_WORDS 
11a2			;		DMARK "cc2" 
11a2			;		CALLMONITOR 
11a2			;	endif 
11a2			;	NEXTW 
11a2			;.str1:   db "string1",0 
11a2			;.str2:   db "string2",0 
11a2			 
11a2			; only care about direct match or not 
11a2			; hl and de strings 
11a2			; zero set if the same 
11a2			 
11a2			strcmp: 
11a2 1a				ld a, (de) 
11a3 be				cp (hl) 
11a4 28 02			jr z, .ssame 
11a6 b7				or a 
11a7 c9				ret 
11a8			 
11a8			.ssame:  
11a8 fe 00			cp 0 
11aa c8				ret z 
11ab			 
11ab 23				inc hl 
11ac 13				inc de 
11ad 18 f3			jr strcmp 
11af				 
11af				 
11af			 
11af			 
11af			 
11af			 
11af			; eof 
11af			 
11af			 
11af			 
11af			 
11af			 
11af			 
# End of file firmware_strings.asm
11af			include "firmware_memory.asm"   ; malloc and free  
11af			 
11af			if DEBUG_FORTH_MALLOC_HIGH 
11af			.mallocsize: db "Wants malloc >256",0 
11af			.mallocasize: db "MALLOC gives >256",0 
11af			.malloczero: db "MALLOC gives zero",0 
11af			 
11af			malloc_guard_zerolen: 
11af				push hl 
11af				push de 
11af				push af 
11af			 
11af				ld de, 0 
11af			        call cmp16 
11af				jr nz, .lowalloz 
11af			 
11af				push hl 
11af				push de 
11af					ld hl, display_fb0 
11af					ld (display_fb_active), hl 
11af				call clear_display 
11af				ld a, 0 
11af				ld de, .malloczero 
11af				call str_at_display 
11af				call update_display 
11af				call delay1s 
11af				call delay1s 
11af				ld a, 0 
11af				ld (os_view_disable), a 
11af			 
11af				pop de 
11af				pop hl 
11af			 
11af				 
11af			 
11af				CALLMONITOR 
11af			.lowalloz: 
11af			 
11af			 
11af				pop af 
11af				pop de 
11af				pop hl 
11af			ret 
11af			 
11af			malloc_guard_entry: 
11af				push hl 
11af				push de 
11af				push af 
11af			 
11af			 	or a      ;clear carry flag 
11af				push hl 
11af				ld de, 255 
11af				sbc hl, de 
11af				jr c, .lowalloc 
11af			 
11af				push de 
11af					ld hl, display_fb0 
11af					ld (display_fb_active), hl 
11af				call clear_display 
11af				ld a, 0 
11af				ld de, .mallocsize 
11af				call str_at_display 
11af				call update_display 
11af				call delay1s 
11af				call delay1s 
11af				ld a, 0 
11af				ld (os_view_disable), a 
11af			 
11af				pop de 
11af				pop hl 
11af			 
11af				 
11af			 
11af				CALLMONITOR 
11af				jr .lowdone 
11af			.lowalloc: 
11af			 
11af			 
11af				pop hl 
11af			.lowdone:	pop af 
11af				pop de 
11af				pop hl 
11af			ret 
11af			 
11af			malloc_guard_exit: 
11af				push hl 
11af				push de 
11af				push af 
11af			 
11af			 	or a      ;clear carry flag 
11af				push hl 
11af				ld de, 255 
11af				sbc hl, de 
11af				jr c, .lowallocx 
11af			 
11af				push de 
11af					ld hl, display_fb0 
11af					ld (display_fb_active), hl 
11af				call clear_display 
11af				ld a, 0 
11af				ld de, .mallocasize 
11af				call str_at_display 
11af				call update_display 
11af				call delay1s 
11af				call delay1s 
11af				ld a, 0 
11af				ld (os_view_disable), a 
11af				pop de 
11af				pop hl 
11af			 
11af				CALLMONITOR 
11af				jr .lowdonex 
11af			.lowallocx: 
11af			 
11af				pop hl 
11af			.lowdonex:	pop af 
11af				pop de 
11af				pop hl 
11af			ret 
11af			endif 
11af			 
11af			if MALLOC_2 
11af			; Z80 Malloc and Free Functions 
11af			 
11af			; Malloc Function: 
11af			; Input: 
11af			;   HL: Size of block to allocate 
11af			; Output: 
11af			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11af			 
11af			malloc: 
11af				 
11af			if DEBUG_FORTH_MALLOC_HIGH 
11af			call malloc_guard_entry 
11af			endif 
11af			 
11af			 
11af			 
11af			 
11af					if DEBUG_FORTH_MALLOC 
11af						DMARK "mal" 
11af						CALLMONITOR 
11af					endif 
11af			    push af            ; Save AF register 
11af			    ld a, l            ; Load low byte of size into A 
11af			    or h               ; Check if size is zero 
11af			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11af			 
11af			    ; Allocate memory 
11af			    ld hl, (heap_start) ; Load start of heap into HL 
11af					if DEBUG_FORTH_MALLOC 
11af						DMARK "ma1" 
11af						CALLMONITOR 
11af					endif 
11af			    call malloc_internal ; Call internal malloc function 
11af			    pop af             ; Restore AF register 
11af			if DEBUG_FORTH_MALLOC_HIGH 
11af			call malloc_guard_exit 
11af			call malloc_guard_zerolen 
11af			endif 
11af			    ret                ; Return 
11af			 
11af			; Free Function: 
11af			; Input: 
11af			;   HL: Pointer to memory block to free 
11af			; Output: 
11af			;   None 
11af			 
11af			free: 
11af			    push af            ; Save AF register 
11af			    ld a, l            ; Load low byte of pointer into A 
11af			    or h               ; Check if pointer is NULL 
11af			    jp z, free_exit    ; If pointer is NULL, exit 
11af			 
11af			    ; Free memory 
11af			    ld hl, (heap_start) ; Load start of heap into HL 
11af			    call free_internal  ; Call internal free function 
11af			    pop af             ; Restore AF register 
11af			    ret                ; Return 
11af			 
11af			; Internal Malloc Function: 
11af			; Input: 
11af			;   HL: Size of block to allocate 
11af			; Output: 
11af			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11af			 
11af			malloc_internal: 
11af			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11af			    add hl, bc         ; Add management overhead to requested size 
11af			    ex de, hl          ; Save total size in DE, and keep it in HL 
11af					if DEBUG_FORTH_MALLOC 
11af						DMARK "ma2" 
11af						CALLMONITOR 
11af					endif 
11af			 
11af			    ; Search for free memory block 
11af			    ld de, (heap_end)  ; Load end of heap into DE 
11af			    ld bc, 0           ; Initialize counter 
11af			 
11af					if DEBUG_FORTH_MALLOC 
11af						DMARK "ma2" 
11af						CALLMONITOR 
11af					endif 
11af			malloc_search_loop: 
11af			    ; Check if current block is free 
11af			    ld a, (hl)         ; Load current block's status (free or used) 
11af			    cp 0               ; Compare with zero (free) 
11af			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11af			 
11af			    ; Check if current block is large enough 
11af			    ld a, (hl+1)       ; Load high byte of block size 
11af			    cp l               ; Compare with low byte of requested size 
11af			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11af			 
11af			    ld a, (hl+2)       ; Load low byte of block size 
11af			    cp h               ; Compare with high byte of requested size 
11af			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11af			 
11af			    ; Mark block as used 
11af			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11af			 
11af			    ; Calculate remaining space in block 
11af			    ld bc, 0           ; Clear BC 
11af			    add hl, bc         ; Increment HL to point to start of data block 
11af			    add hl, de         ; HL = HL + DE (total size) 
11af			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11af			    add hl, bc         ; Add management overhead to start of data block 
11af			 
11af			    ; Save pointer to allocated block in HL 
11af			if DEBUG_FORTH_MALLOC_HIGH 
11af						DMARK "ma5" 
11af			call malloc_guard_exit 
11af			call malloc_guard_zerolen 
11af			endif 
11af			    ret 
11af			 
11af			malloc_skip_block_check: 
11af			    ; Move to the next block 
11af			    ld bc, 3           ; Size of management overhead 
11af			    add hl, bc         ; Move to the next block 
11af			    inc de             ; Increment counter 
11af			 
11af			    ; Check if we have reached the end of heap 
11af			    ld a, e            ; Load low byte of heap end address 
11af			    cp (hl)            ; Compare with low byte of current address 
11af			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11af			    ld a, d            ; Load high byte of heap end address 
11af			    cp 0               ; Check if it's zero (end of memory) 
11af			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11af			 
11af			    ; If we reached here, allocation failed 
11af			    xor a              ; Set result to NULL 
11af			if DEBUG_FORTH_MALLOC_HIGH 
11af						DMARK "ma6" 
11af			call malloc_guard_exit 
11af			call malloc_guard_zerolen 
11af			endif 
11af			    ret 
11af			malloc_exit: 
11af			if DEBUG_FORTH_MALLOC_HIGH 
11af						DMARK "ma7" 
11af			call malloc_guard_exit 
11af			call malloc_guard_zerolen 
11af			endif 
11af			    ret 
11af			 
11af			; Internal Free Function: 
11af			; Input: 
11af			;   HL: Pointer to memory block to free 
11af			; Output: 
11af			;   None 
11af			 
11af			free_internal: 
11af			    ld de, (heap_start) ; Load start of heap into DE 
11af			    ld bc, 0            ; Initialize counter 
11af			 
11af			free_search_loop: 
11af			    ; Check if current block contains the pointer 
11af			    ld a, l             ; Load low byte of pointer 
11af			    cp (hl+1)           ; Compare with high byte of current block's address 
11af			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11af			    ld a, h             ; Load high byte of pointer 
11af			    cp (hl+2)           ; Compare with low byte of current block's address 
11af			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11af			 
11af			    ; Mark block as free 
11af			    ld (hl), 0          ; Set status byte to indicate free block 
11af			    ret                 ; Return 
11af			 
11af			free_skip_block_check: 
11af			    ; Move to the next block 
11af			    ld bc, 3            ; Size of management overhead 
11af			    add hl, bc          ; Move to the next block 
11af			    inc de              ; Increment counter 
11af			 
11af			    ; Check if we have reached the end of heap 
11af			    ld a, e             ; Load low byte of heap end address 
11af			    cp (hl)             ; Compare with low byte of current address 
11af			    jr nz, free_search_loop  ; If not equal, continue searching 
11af			    ld a, d             ; Load high byte of heap end address 
11af			    cp 0                ; Check if it's zero (end of memory) 
11af			    jr nz, free_search_loop  ; If not zero, continue searching 
11af			 
11af			    ; If we reached here, pointer is not found in heap 
11af			    ret 
11af			 
11af			free_exit: 
11af			    ret                 ; Return 
11af			 
11af			; Define heap start and end addresses 
11af			;heap_start:    .dw 0xC000   ; Start of heap 
11af			;heap_end:      .dw 0xE000   ; End of heap 
11af			 
11af			endif 
11af			 
11af			 
11af			if MALLOC_1 
11af			 
11af			 
11af			 
11af			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11af			 
11af			;moved to firmware.asm 
11af			;heap_start        .equ  0x9000      ; Starting address of heap 
11af			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11af			 
11af			;      .org 0 
11af			;      jp    main 
11af			 
11af			 
11af			;      .org  0x100 
11af			;main: 
11af			;      ld    HL, 0x8100 
11af			;      ld    SP, HL 
11af			; 
11af			;      call  heap_init 
11af			; 
11af			;      ; Make some allocations 
11af			;      ld    HL, 12 
11af			;      call  malloc            ; Allocates 0x9004 
11af			; 
11af			;      ld    HL, 12 
11af			;      call  malloc            ; Allocates 0x9014 
11af			; 
11af			;      ld    HL, 12 
11af			;      call  malloc            ; Allocates 0x9024 
11af			; 
11af			;      ; Free some allocations 
11af			;      ld    HL, 0x9014 
11af			;      call  free 
11af			; 
11af			;      ld    HL, 0x9004 
11af			;      call  free 
11af			; 
11af			;      ld    HL, 0x9024 
11af			;      call  free 
11af			; 
11af			; 
11af			;      halt 
11af			 
11af			 
11af			;------------------------------------------------------------------------------ 
11af			;     heap_init                                                               : 
11af			;                                                                             : 
11af			; Description                                                                 : 
11af			;     Initialise the heap and make it ready for malloc and free operations.   : 
11af			;                                                                             : 
11af			;     The heap is maintained as a linked list, starting with an initial       : 
11af			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11af			;     the first free block in the heap. Each block then points to the next    : 
11af			;     free block within the heap, and the free list ends at the first block   : 
11af			;     with a null pointer to the next free block.                             : 
11af			;                                                                             : 
11af			; Parameters                                                                  : 
11af			;     Inputs are compile-time only. Two defines which specify the starting    : 
11af			;     address of the heap and its size are required, along with a memory      : 
11af			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11af			;     principally stores a pointer to the first free block in the heap.       : 
11af			;                                                                             : 
11af			; Returns                                                                     : 
11af			;     Nothing                                                                 : 
11af			;------------------------------------------------------------------------------ 
11af			heap_init: 
11af e5			      push  HL 
11b0			 
11b0			      ; Initialise free list struct 
11b0 21 0e 80		      ld    HL, heap_start 
11b3 22 0a 80		      ld    (free_list), HL 
11b6 21 00 00		      ld    HL, 0 
11b9 22 0c 80		      ld    (free_list+2), HL 
11bc			 
11bc			      ; Insert first free block at bottom of heap, consumes entire heap 
11bc 21 ff ed		      ld    HL, heap_start+heap_size-4 
11bf 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11c2 21 f1 6d		      ld    HL, heap_size-4 
11c5 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c8			 
11c8			      ; Insert end of free list block at top of heap - two null words will 
11c8			      ; terminate the free list 
11c8 21 00 00		      ld    HL, 0 
11cb 22 01 ee		      ld    (heap_start+heap_size-2), HL 
11ce 22 ff ed		      ld    (heap_start+heap_size-4), HL 
11d1			 
11d1 e1			      pop   HL 
11d2			 
11d2 c9			      ret 
11d3			 
11d3			 
11d3			;------------------------------------------------------------------------------ 
11d3			;     malloc                                                                  : 
11d3			;                                                                             : 
11d3			; Description                                                                 : 
11d3			;     Allocates the wanted space from the heap and returns the address of the : 
11d3			;     first useable byte of the allocation.                                   : 
11d3			;                                                                             : 
11d3			;     Allocations can happen in one of two ways:                              : 
11d3			;                                                                             : 
11d3			;     1. A free block may be found which is the exact size wanted. In this    : 
11d3			;        case the block is removed from the free list and retuedn to the      : 
11d3			;        caller.                                                              : 
11d3			;     2. A free block may be found which is larger than the size wanted. In   : 
11d3			;        this case, the larger block is split into two. The first portion of  : 
11d3			;        this block will become the requested space by the malloc call and    : 
11d3			;        is returned to the caller. The second portion becomes a new free     : 
11d3			;        block, and the free list is adjusted to maintain continuity via this : 
11d3			;        newly created block.                                                 : 
11d3			;                                                                             : 
11d3			;     malloc does not set any initial value in the allocated space, the       : 
11d3			;     caller is required to do this as required.                              : 
11d3			;                                                                             : 
11d3			;     This implementation of malloc uses the stack exclusively, and is        : 
11d3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d3			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d3			;     to avoid the use of malloc inside ISRs in general.                      : 
11d3			;                                                                             : 
11d3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d3			;                                                                             : 
11d3			; Parameters                                                                  : 
11d3			;     HL  Number of bytes wanted                                              : 
11d3			;                                                                             : 
11d3			; Returns                                                                     : 
11d3			;     HL  Address of the first useable byte of the allocation                 : 
11d3			;                                                                             : 
11d3			; Flags                                                                       : 
11d3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d3			;                                                                             : 
11d3			; Stack frame                                                                 : 
11d3			;       |             |                                                       : 
11d3			;       +-------------+                                                       : 
11d3			;       |     BC      |                                                       : 
11d3			;       +-------------+                                                       : 
11d3			;       |     DE      |                                                       : 
11d3			;       +-------------+                                                       : 
11d3			;       |     IX      |                                                       : 
11d3			;       +-------------+                                                       : 
11d3			;       |  prev_free  |                                                       : 
11d3			;   +4  +-------------+                                                       : 
11d3			;       |  this_free  |                                                       : 
11d3			;   +2  +-------------+                                                       : 
11d3			;       |  next_free  |                                                       : 
11d3			;   +0  +-------------+                                                       : 
11d3			;       |             |                                                       : 
11d3			;                                                                             : 
11d3			;------------------------------------------------------------------------------ 
11d3			 
11d3			 
11d3			;malloc: 
11d3			; 
11d3			;	SAVESP ON 1 
11d3			; 
11d3			;	call malloc_code 
11d3			; 
11d3			;	CHECKSP ON 1 
11d3			;	ret 
11d3			 
11d3			 
11d3			malloc: 
11d3 c5			      push  BC 
11d4 d5			      push  DE 
11d5 dd e5		      push  IX 
11d7			if DEBUG_FORTH_MALLOC_HIGH 
11d7			call malloc_guard_entry 
11d7			endif 
11d7			 
11d7					if DEBUG_FORTH_MALLOC 
11d7						DMARK "mal" 
11d7						CALLMONITOR 
11d7					endif 
11d7 7c			      ld    A, H                    ; Exit if no space requested 
11d8 b5			      or    L 
11d9 ca 98 12		      jp    Z, malloc_early_exit 
11dc			 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			; 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			;inc hl 
11dc			 
11dc			 
11dc			 
11dc			 
11dc					if DEBUG_FORTH_MALLOC 
11dc						DMARK "maA" 
11dc						CALLMONITOR 
11dc					endif 
11dc			      ; Set up stack frame 
11dc eb			      ex    DE, HL 
11dd 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11e0 39			      add   HL, SP 
11e1 f9			      ld    SP, HL 
11e2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e6 dd 39		      add   IX, SP 
11e8			 
11e8			      ; Setup initial state 
11e8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11eb 19			      add   HL, DE 
11ec			 
11ec 44			      ld    B, H                    ; Move want to BC 
11ed 4d			      ld    C, L 
11ee			 
11ee 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11f1 dd 75 04		      ld    (IX+4), L 
11f4 dd 74 05		      ld    (IX+5), H 
11f7			 
11f7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f8 23			      inc   HL 
11f9 56			      ld    D, (HL) 
11fa dd 73 02		      ld    (IX+2), E 
11fd dd 72 03		      ld    (IX+3), D 
1200 eb			      ex    DE, HL                  ; this_free ptr into HL 
1201			 
1201					if DEBUG_FORTH_MALLOC 
1201						DMARK "maB" 
1201						CALLMONITOR 
1201					endif 
1201			      ; Loop through free block list to find some space 
1201			malloc_find_space: 
1201 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1202 23			      inc   HL 
1203 56			      ld    D, (HL) 
1204			 
1204 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1205 b3			      or    E 
1206 ca 92 12		      jp    Z, malloc_no_space 
1209			 
1209 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
120c dd 72 01		      ld    (IX+1), D 
120f			 
120f			      ; Does this block have enough space to make the allocation? 
120f 23			      inc   HL                      ; Load free block size into DE 
1210 5e			      ld    E, (HL) 
1211 23			      inc   HL 
1212 56			      ld    D, (HL) 
1213			 
1213 eb			      ex    DE, HL                  ; Check size of block against want 
1214 b7			      or    A                       ; Ensure carry flag clear 
1215 ed 42		      sbc   HL, BC 
1217 e5			      push  HL                      ; Store the result for later (new block size) 
1218			 
1218 ca 67 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
121b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121d			 
121d			      ; this_free block is not big enough, setup ptrs to test next free block 
121d e1			      pop   HL                      ; Discard previous result 
121e			 
121e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1221 dd 66 03		      ld    H, (IX+3) 
1224 dd 75 04		      ld    (IX+4), L 
1227 dd 74 05		      ld    (IX+5), H 
122a			 
122a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122d dd 66 01		      ld    H, (IX+1) 
1230 dd 75 02		      ld    (IX+2), L 
1233 dd 74 03		      ld    (IX+3), H 
1236			 
1236					if DEBUG_FORTH_MALLOC 
1236						DMARK "MA>" 
1236						CALLMONITOR 
1236					endif 
1236 18 c9		      jr    malloc_find_space 
1238			 
1238			      ; split a bigger block into two - requested size and remaining size 
1238			malloc_alloc_split: 
1238					if DEBUG_FORTH_MALLOC 
1238						DMARK "MAs" 
1238						CALLMONITOR 
1238					endif 
1238 eb			      ex    DE, HL                  ; Calculate address of new free block 
1239 2b			      dec   HL 
123a 2b			      dec   HL 
123b 2b			      dec   HL 
123c 09			      add   HL, BC 
123d			 
123d			      ; Create a new block and point it at next_free 
123d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1240 dd 56 01		      ld    D, (IX+1) 
1243			 
1243 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1244 23			      inc   HL 
1245 72			      ld    (HL), D 
1246			 
1246 d1			      pop   DE                      ; Store size of new block into new block 
1247 23			      inc   HL 
1248 73			      ld    (HL), E 
1249 23			      inc   HL 
124a 72			      ld    (HL), D 
124b			 
124b			      ; Update this_free ptr to point to new block 
124b 2b			      dec   HL 
124c 2b			      dec   HL 
124d 2b			      dec   HL 
124e			 
124e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1251 dd 56 03		      ld    D, (IX+3) 
1254			 
1254 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1257 dd 74 03		      ld    (IX+3), H 
125a			 
125a			      ; Modify this_free block to be allocation 
125a eb			      ex    DE, HL 
125b af			      xor   A                       ; Null the next block ptr of allocated block 
125c 77			      ld    (HL), A 
125d 23			      inc   HL 
125e 77			      ld    (HL), A 
125f			 
125f 23			      inc   HL                      ; Store want size into allocated block 
1260 71			      ld    (HL), C 
1261 23			      inc   HL 
1262 70			      ld    (HL), B 
1263 23			      inc   HL 
1264 e5			      push  HL                      ; Address of allocation to return 
1265			 
1265 18 19		      jr    malloc_update_links 
1267			 
1267			malloc_alloc_fit: 
1267 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1268			 
1268					if DEBUG_FORTH_MALLOC 
1268						DMARK "MAf" 
1268						CALLMONITOR 
1268					endif 
1268			      ; Modify this_free block to be allocation 
1268 eb			      ex    DE, HL 
1269 2b			      dec   HL 
126a 2b			      dec   HL 
126b 2b			      dec   HL 
126c			 
126c af			      xor   A                       ; Null the next block ptr of allocated block 
126d 77			      ld    (HL), A 
126e 23			      inc   HL 
126f 77			      ld    (HL), A 
1270			 
1270 23			      inc   HL                      ; Store address of allocation to return 
1271 23			      inc   HL 
1272 23			      inc   HL 
1273 e5			      push  HL 
1274			 
1274			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1274 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1277 dd 66 01		      ld    H, (IX+1) 
127a			 
127a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127d dd 74 03		      ld    (IX+3), H 
1280			 
1280			 
1280			malloc_update_links: 
1280			      ; Update prev_free ptr to point to this_free 
1280 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1283 dd 66 05		      ld    H, (IX+5) 
1286			 
1286 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1289 dd 56 03		      ld    D, (IX+3) 
128c			 
128c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128d 23			      inc   HL 
128e 72			      ld    (HL), D 
128f			 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "Mul" 
128f						CALLMONITOR 
128f					endif 
128f			      ; Clear the Z flag to indicate successful allocation 
128f 7a			      ld    A, D 
1290 b3			      or    E 
1291			 
1291 d1			      pop   DE                      ; Address of allocation 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAu" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_no_space: 
1292 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1295 39			      add   HL, SP 
1296 f9			      ld    SP, HL 
1297			 
1297 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1298					if DEBUG_FORTH_MALLOC 
1298						DMARK "MAN" 
1298						CALLMONITOR 
1298					endif 
1298			 
1298			malloc_early_exit: 
1298					if DEBUG_FORTH_MALLOC 
1298						DMARK "MAx" 
1298						CALLMONITOR 
1298					endif 
1298 dd e1		      pop   IX 
129a d1			      pop   DE 
129b c1			      pop   BC 
129c			 
129c			if DEBUG_FORTH_MALLOC_HIGH 
129c			call malloc_guard_exit 
129c			call malloc_guard_zerolen 
129c			endif 
129c c9			      ret 
129d			 
129d			 
129d			;------------------------------------------------------------------------------ 
129d			;     free                                                                    : 
129d			;                                                                             : 
129d			; Description                                                                 : 
129d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129d			;     returned by malloc, otherwise the behaviour is undefined.               : 
129d			;                                                                             : 
129d			;     Where possible, directly adjacent free blocks will be merged together   : 
129d			;     into larger blocks to help ensure that the heap does not become         : 
129d			;     excessively fragmented.                                                 : 
129d			;                                                                             : 
129d			;     free does not clear or set any other value into the freed space, and    : 
129d			;     therefore its contents may be visible through subsequent malloc's. The  : 
129d			;     caller should clear the freed space as required.                        : 
129d			;                                                                             : 
129d			;     This implementation of free uses the stack exclusively, and is          : 
129d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129d			;     advisable to disable interrupts before calling free, and recommended    : 
129d			;     to avoid the use of free inside ISRs in general.                        : 
129d			;                                                                             : 
129d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129d			;                                                                             : 
129d			; Parameters                                                                  : 
129d			;     HL  Pointer to address of first byte of allocation to be freed          : 
129d			;                                                                             : 
129d			; Returns                                                                     : 
129d			;     Nothing                                                                 : 
129d			;                                                                             : 
129d			; Stack frame                                                                 : 
129d			;       |             |                                                       : 
129d			;       +-------------+                                                       : 
129d			;       |     BC      |                                                       : 
129d			;       +-------------+                                                       : 
129d			;       |     DE      |                                                       : 
129d			;       +-------------+                                                       : 
129d			;       |     IX      |                                                       : 
129d			;       +-------------+                                                       : 
129d			;       |  prev_free  |                                                       : 
129d			;   +2  +-------------+                                                       : 
129d			;       |  next_free  |                                                       : 
129d			;   +0  +-------------+                                                       : 
129d			;       |             |                                                       : 
129d			;                                                                             : 
129d			;------------------------------------------------------------------------------ 
129d			free: 
129d c5			      push  BC 
129e d5			      push  DE 
129f dd e5		      push  IX 
12a1			 
12a1 7c			      ld    A, H                    ; Exit if ptr is null 
12a2 b5			      or    L 
12a3 ca 67 13		      jp    Z, free_early_exit 
12a6			 
12a6			      ; Set up stack frame 
12a6 eb			      ex    DE, HL 
12a7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12aa 39			      add   HL, SP 
12ab f9			      ld    SP, HL 
12ac dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12b0 dd 39		      add   IX, SP 
12b2			 
12b2			      ; The address in HL points to the start of the useable allocated space, 
12b2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12b2			      ; address of the block itself. 
12b2 eb			      ex    DE, HL 
12b3 11 fc ff		      ld    DE, -4 
12b6 19			      add   HL, DE 
12b7			 
12b7			      ; An allocated block must have a null next block pointer in it 
12b7 7e			      ld    A, (HL) 
12b8 23			      inc   HL 
12b9 b6			      or    (HL) 
12ba c2 62 13		      jp    NZ, free_done 
12bd			 
12bd 2b			      dec   HL 
12be			 
12be 44			      ld    B, H                    ; Copy HL to BC 
12bf 4d			      ld    C, L 
12c0			 
12c0			      ; Loop through the free list to find the first block with an address 
12c0			      ; higher than the block being freed 
12c0 21 0a 80		      ld    HL, free_list 
12c3			 
12c3			free_find_higher_block: 
12c3 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c4 23			      inc   HL 
12c5 56			      ld    D, (HL) 
12c6 2b			      dec   HL 
12c7			 
12c7 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12ca dd 72 01		      ld    (IX+1), D 
12cd dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12d0 dd 74 03		      ld    (IX+3), H 
12d3			 
12d3 78			      ld    A, B                    ; Check if DE is greater than BC 
12d4 ba			      cp    D                       ; Compare MSB first 
12d5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d7 30 04		      jr    NC, free_find_higher_block_skip 
12d9 79			      ld    A, C 
12da bb			      cp    E                       ; Then compare LSB 
12db 38 08		      jr    C, free_found_higher_block 
12dd			 
12dd			free_find_higher_block_skip: 
12dd 7a			      ld    A, D                    ; Reached the end of the free list? 
12de b3			      or    E 
12df ca 62 13		      jp    Z, free_done 
12e2			 
12e2 eb			      ex    DE, HL 
12e3			 
12e3 18 de		      jr    free_find_higher_block 
12e5			 
12e5			free_found_higher_block: 
12e5			      ; Insert freed block between prev and next free blocks 
12e5 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e6 23			      inc   HL 
12e7 70			      ld    (HL), B 
12e8			 
12e8 60			      ld    H, B                    ; Point freed block at next free block 
12e9 69			      ld    L, C 
12ea 73			      ld    (HL), E 
12eb 23			      inc   HL 
12ec 72			      ld    (HL), D 
12ed			 
12ed			      ; Check if the freed block is adjacent to the next free block 
12ed 23			      inc   HL                      ; Load size of freed block into HL 
12ee 5e			      ld    E, (HL) 
12ef 23			      inc   HL 
12f0 56			      ld    D, (HL) 
12f1 eb			      ex    DE, HL 
12f2			 
12f2 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f3			 
12f3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f6 dd 56 01		      ld    D, (IX+1) 
12f9			 
12f9 b7			      or    A                       ; Clear the carry flag 
12fa ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12fc 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fe			 
12fe			      ; Freed block is adjacent to next, merge into one bigger block 
12fe eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12ff 5e			      ld    E, (HL) 
1300 23			      inc   HL 
1301 56			      ld    D, (HL) 
1302 e5			      push  HL                      ; Save ptr to next block for later 
1303			 
1303 60			      ld    H, B                    ; Store ptr from next block into freed block 
1304 69			      ld    L, C 
1305 73			      ld    (HL), E 
1306 23			      inc   HL 
1307 72			      ld    (HL), D 
1308			 
1308 e1			      pop   HL                      ; Restore ptr to next block 
1309 23			      inc   HL                      ; Load size of next block into DE 
130a 5e			      ld    E, (HL) 
130b 23			      inc   HL 
130c 56			      ld    D, (HL) 
130d d5			      push  DE                      ; Save next block size for later 
130e			 
130e 60			      ld    H, B                    ; Load size of freed block into HL 
130f 69			      ld    L, C 
1310 23			      inc   HL 
1311 23			      inc   HL 
1312 5e			      ld    E, (HL) 
1313 23			      inc   HL 
1314 56			      ld    D, (HL) 
1315 eb			      ex    DE, HL 
1316			 
1316 d1			      pop   DE                      ; Restore size of next block 
1317 19			      add   HL, DE                  ; Add sizes of both blocks 
1318 eb			      ex    DE, HL 
1319			 
1319 60			      ld    H, B                    ; Store new bigger size into freed block 
131a 69			      ld    L, C 
131b 23			      inc   HL 
131c 23			      inc   HL 
131d 73			      ld    (HL), E 
131e 23			      inc   HL 
131f 72			      ld    (HL), D 
1320			 
1320			free_check_adjacent_to_prev: 
1320			      ; Check if the freed block is adjacent to the prev free block 
1320 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1323 dd 66 03		      ld    H, (IX+3) 
1326			 
1326 23			      inc   HL                      ; Size of prev free block into DE 
1327 23			      inc   HL 
1328 5e			      ld    E, (HL) 
1329 23			      inc   HL 
132a 56			      ld    D, (HL) 
132b 2b			      dec   HL 
132c 2b			      dec   HL 
132d 2b			      dec   HL 
132e			 
132e 19			      add   HL, DE                  ; Add prev block addr and size 
132f			 
132f b7			      or    A                       ; Clear the carry flag 
1330 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1332 20 2e		      jr    NZ, free_done 
1334			 
1334			      ; Freed block is adjacent to prev, merge into one bigger block 
1334 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1335 69			      ld    L, C 
1336 5e			      ld    E, (HL) 
1337 23			      inc   HL 
1338 56			      ld    D, (HL) 
1339 e5			      push  HL                      ; Save freed block ptr for later 
133a			 
133a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133d dd 66 03		      ld    H, (IX+3) 
1340 73			      ld    (HL), E 
1341 23			      inc   HL 
1342 72			      ld    (HL), D 
1343			 
1343 e1			      pop   HL                      ; Restore freed block ptr 
1344 23			      inc   HL                      ; Load size of freed block into DE 
1345 5e			      ld    E, (HL) 
1346 23			      inc   HL 
1347 56			      ld    D, (HL) 
1348 d5			      push  DE                      ; Save freed block size for later 
1349			 
1349 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
134c dd 66 03		      ld    H, (IX+3) 
134f 23			      inc   HL 
1350 23			      inc   HL 
1351 5e			      ld    E, (HL) 
1352 23			      inc   HL 
1353 56			      ld    D, (HL) 
1354			 
1354 e1			      pop   HL                      ; Add sizes of both blocks 
1355 19			      add   HL, DE 
1356 eb			      ex    DE, HL 
1357			 
1357 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
135a dd 66 03		      ld    H, (IX+3) 
135d 23			      inc   HL 
135e 23			      inc   HL 
135f 73			      ld    (HL), E 
1360 23			      inc   HL 
1361 72			      ld    (HL), D 
1362			 
1362			free_done: 
1362 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1365 39			      add   HL, SP 
1366 f9			      ld    SP, HL 
1367			 
1367			free_early_exit: 
1367 dd e1		      pop   IX 
1369 d1			      pop   DE 
136a c1			      pop   BC 
136b			 
136b c9			      ret 
136c			 
136c			; moved to firmware.asm 
136c			; 
136c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
136c			;                  .dw   0 
136c			 
136c			 
136c			endif 
136c			 
136c			 
136c			if MALLOC_3 
136c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
136c			;heap_start        .equ  0x9000      ; Starting address of heap 
136c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
136c			; 
136c			 ;     .org 0 
136c			  ;    jp    main 
136c			; 
136c			; 
136c			 ;     .org  0x100 
136c			;main: 
136c			 ;     ld    HL, 0x8100 
136c			  ;    ld    SP, HL 
136c			; 
136c			;      call  heap_init 
136c			 
136c			      ; Make some allocations 
136c			;      ld    HL, 12 
136c			;      call  malloc            ; Allocates 0x9004 
136c			; 
136c			 ;     ld    HL, 12 
136c			;      call  malloc            ; Allocates 0x9014 
136c			 
136c			;      ld    HL, 12 
136c			;      call  malloc            ; Allocates 0x9024 
136c			 
136c			      ; Free some allocations 
136c			;      ld    HL, 0x9014 
136c			;      call  free 
136c			 
136c			;      ld    HL, 0x9004 
136c			;      call  free 
136c			; 
136c			;      ld    HL, 0x9024 
136c			;      call  free 
136c			 
136c			 
136c			 ;     halt 
136c			 
136c			 
136c			;------------------------------------------------------------------------------ 
136c			;     heap_init                                                               : 
136c			;                                                                             : 
136c			; Description                                                                 : 
136c			;     Initialise the heap and make it ready for malloc and free operations.   : 
136c			;                                                                             : 
136c			;     The heap is maintained as a linked list, starting with an initial       : 
136c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
136c			;     the first free block in the heap. Each block then points to the next    : 
136c			;     free block within the heap, and the free list ends at the first block   : 
136c			;     with a null pointer to the next free block.                             : 
136c			;                                                                             : 
136c			; Parameters                                                                  : 
136c			;     Inputs are compile-time only. Two defines which specify the starting    : 
136c			;     address of the heap and its size are required, along with a memory      : 
136c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
136c			;     principally stores a pointer to the first free block in the heap.       : 
136c			;                                                                             : 
136c			; Returns                                                                     : 
136c			;     Nothing                                                                 : 
136c			;------------------------------------------------------------------------------ 
136c			heap_init: 
136c			      push  HL 
136c			 
136c			      ; Initialise free list struct 
136c			      ld    HL, heap_start 
136c			      ld    (free_list), HL 
136c			      ld    HL, 0 
136c			      ld    (free_list+2), HL 
136c			 
136c			      ; Insert first free block at bottom of heap, consumes entire heap 
136c			      ld    HL, heap_start+heap_size-4 
136c			      ld    (heap_start), HL        ; Next block (end of free list) 
136c			      ld    HL, heap_size-4 
136c			      ld    (heap_start+2), HL      ; Block size 
136c			 
136c			      ; Insert end of free list block at top of heap - two null words will 
136c			      ; terminate the free list 
136c			      ld    HL, 0 
136c			      ld    (heap_start+heap_size-2), HL 
136c			      ld    (heap_start+heap_size-4), HL 
136c			 
136c			      pop   HL 
136c			 
136c			      ret 
136c			 
136c			 
136c			;------------------------------------------------------------------------------ 
136c			;     malloc                                                                  : 
136c			;                                                                             : 
136c			; Description                                                                 : 
136c			;     Allocates the wanted space from the heap and returns the address of the : 
136c			;     first useable byte of the allocation.                                   : 
136c			;                                                                             : 
136c			;     Allocations can happen in one of two ways:                              : 
136c			;                                                                             : 
136c			;     1. A free block may be found which is the exact size wanted. In this    : 
136c			;        case the block is removed from the free list and retuedn to the      : 
136c			;        caller.                                                              : 
136c			;     2. A free block may be found which is larger than the size wanted. In   : 
136c			;        this case, the larger block is split into two. The first portion of  : 
136c			;        this block will become the requested space by the malloc call and    : 
136c			;        is returned to the caller. The second portion becomes a new free     : 
136c			;        block, and the free list is adjusted to maintain continuity via this : 
136c			;        newly created block.                                                 : 
136c			;                                                                             : 
136c			;     malloc does not set any initial value in the allocated space, the       : 
136c			;     caller is required to do this as required.                              : 
136c			;                                                                             : 
136c			;     This implementation of malloc uses the stack exclusively, and is        : 
136c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
136c			;     advisable to disable interrupts before calling malloc, and recommended  : 
136c			;     to avoid the use of malloc inside ISRs in general.                      : 
136c			;                                                                             : 
136c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
136c			;                                                                             : 
136c			; Parameters                                                                  : 
136c			;     HL  Number of bytes wanted                                              : 
136c			;                                                                             : 
136c			; Returns                                                                     : 
136c			;     HL  Address of the first useable byte of the allocation                 : 
136c			;                                                                             : 
136c			; Flags                                                                       : 
136c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
136c			;                                                                             : 
136c			; Stack frame                                                                 : 
136c			;       |             |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |     BC      |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |     DE      |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |     IX      |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |  prev_free  |                                                       : 
136c			;   +4  +-------------+                                                       : 
136c			;       |  this_free  |                                                       : 
136c			;   +2  +-------------+                                                       : 
136c			;       |  next_free  |                                                       : 
136c			;   +0  +-------------+                                                       : 
136c			;       |             |                                                       : 
136c			;                                                                             : 
136c			;------------------------------------------------------------------------------ 
136c			malloc: 
136c			      push  BC 
136c			      push  DE 
136c			      push  IX 
136c			 
136c			      ld    A, H                    ; Exit if no space requested 
136c			      or    L 
136c			      jp    Z, malloc_early_exit 
136c			 
136c			      ; Set up stack frame 
136c			      ex    DE, HL 
136c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
136c			      add   HL, SP 
136c			      ld    SP, HL 
136c			      ld    IX, 0                   ; Use IX as a frame pointer 
136c			      add   IX, SP 
136c			 
136c			      ; Setup initial state 
136c			      ld    HL, 4                   ; want must also include space used by block struct 
136c			      add   HL, DE 
136c			 
136c			      ld    B, H                    ; Move want to BC 
136c			      ld    C, L 
136c			 
136c			      ld    HL, free_list           ; Store prev_free ptr to stack 
136c			      ld    (IX+4), L 
136c			      ld    (IX+5), H 
136c			 
136c			      ld    E, (HL)                 ; Store this_free ptr to stack 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      ld    (IX+2), E 
136c			      ld    (IX+3), D 
136c			      ex    DE, HL                  ; this_free ptr into HL 
136c			 
136c			      ; Loop through free block list to find some space 
136c			malloc_find_space: 
136c			      ld    E, (HL)                 ; Load next_free ptr into DE 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			 
136c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
136c			      or    E 
136c			      jp    Z, malloc_no_space 
136c			 
136c			      ld    (IX+0), E               ; Store next_free ptr to stack 
136c			      ld    (IX+1), D 
136c			 
136c			      ; Does this block have enough space to make the allocation? 
136c			      inc   HL                      ; Load free block size into DE 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			 
136c			      ex    DE, HL                  ; Check size of block against want 
136c			      or    A                       ; Ensure carry flag clear 
136c			      sbc   HL, BC 
136c			      push  HL                      ; Store the result for later (new block size) 
136c			 
136c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
136c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
136c			 
136c			      ; this_free block is not big enough, setup ptrs to test next free block 
136c			      pop   HL                      ; Discard previous result 
136c			 
136c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
136c			      ld    H, (IX+3) 
136c			      ld    (IX+4), L 
136c			      ld    (IX+5), H 
136c			 
136c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
136c			      ld    H, (IX+1) 
136c			      ld    (IX+2), L 
136c			      ld    (IX+3), H 
136c			 
136c			      jr    malloc_find_space 
136c			 
136c			      ; split a bigger block into two - requested size and remaining size 
136c			malloc_alloc_split: 
136c			      ex    DE, HL                  ; Calculate address of new free block 
136c			      dec   HL 
136c			      dec   HL 
136c			      dec   HL 
136c			      add   HL, BC 
136c			 
136c			      ; Create a new block and point it at next_free 
136c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
136c			      ld    D, (IX+1) 
136c			 
136c			      ld    (HL), E                 ; Store next_free ptr into new block 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			      pop   DE                      ; Store size of new block into new block 
136c			      inc   HL 
136c			      ld    (HL), E 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			      ; Update this_free ptr to point to new block 
136c			      dec   HL 
136c			      dec   HL 
136c			      dec   HL 
136c			 
136c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
136c			      ld    D, (IX+3) 
136c			 
136c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
136c			      ld    (IX+3), H 
136c			 
136c			      ; Modify this_free block to be allocation 
136c			      ex    DE, HL 
136c			      xor   A                       ; Null the next block ptr of allocated block 
136c			      ld    (HL), A 
136c			      inc   HL 
136c			      ld    (HL), A 
136c			 
136c			      inc   HL                      ; Store want size into allocated block 
136c			      ld    (HL), C 
136c			      inc   HL 
136c			      ld    (HL), B 
136c			      inc   HL 
136c			      push  HL                      ; Address of allocation to return 
136c			 
136c			      jr    malloc_update_links 
136c			 
136c			malloc_alloc_fit: 
136c			      pop   HL                      ; Dont need new block size, want is exact fit 
136c			 
136c			      ; Modify this_free block to be allocation 
136c			      ex    DE, HL 
136c			      dec   HL 
136c			      dec   HL 
136c			      dec   HL 
136c			 
136c			      xor   A                       ; Null the next block ptr of allocated block 
136c			      ld    (HL), A 
136c			      inc   HL 
136c			      ld    (HL), A 
136c			 
136c			      inc   HL                      ; Store address of allocation to return 
136c			      inc   HL 
136c			      inc   HL 
136c			      push  HL 
136c			 
136c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
136c			      ld    L, (IX+0)               ; next_free to HL 
136c			      ld    H, (IX+1) 
136c			 
136c			      ld    (IX+2), L               ; HL to this_free 
136c			      ld    (IX+3), H 
136c			 
136c			 
136c			malloc_update_links: 
136c			      ; Update prev_free ptr to point to this_free 
136c			      ld    L, (IX+4)               ; prev_free ptr to HL 
136c			      ld    H, (IX+5) 
136c			 
136c			      ld    E, (IX+2)               ; this_free ptr to DE 
136c			      ld    D, (IX+3) 
136c			 
136c			      ld    (HL), E                 ; this_free ptr into prev_free 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			      ; Clear the Z flag to indicate successful allocation 
136c			      ld    A, D 
136c			      or    E 
136c			 
136c			      pop   DE                      ; Address of allocation 
136c			 
136c			malloc_no_space: 
136c			      ld    HL, 6                   ; Clean up stack frame 
136c			      add   HL, SP 
136c			      ld    SP, HL 
136c			 
136c			      ex    DE, HL                  ; Alloc addr into HL for return 
136c			 
136c			malloc_early_exit: 
136c			      pop   IX 
136c			      pop   DE 
136c			      pop   BC 
136c			 
136c			      ret 
136c			 
136c			 
136c			;------------------------------------------------------------------------------ 
136c			;     free                                                                    : 
136c			;                                                                             : 
136c			; Description                                                                 : 
136c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
136c			;     returned by malloc, otherwise the behaviour is undefined.               : 
136c			;                                                                             : 
136c			;     Where possible, directly adjacent free blocks will be merged together   : 
136c			;     into larger blocks to help ensure that the heap does not become         : 
136c			;     excessively fragmented.                                                 : 
136c			;                                                                             : 
136c			;     free does not clear or set any other value into the freed space, and    : 
136c			;     therefore its contents may be visible through subsequent malloc's. The  : 
136c			;     caller should clear the freed space as required.                        : 
136c			;                                                                             : 
136c			;     This implementation of free uses the stack exclusively, and is          : 
136c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
136c			;     advisable to disable interrupts before calling free, and recommended    : 
136c			;     to avoid the use of free inside ISRs in general.                        : 
136c			;                                                                             : 
136c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
136c			;                                                                             : 
136c			; Parameters                                                                  : 
136c			;     HL  Pointer to address of first byte of allocation to be freed          : 
136c			;                                                                             : 
136c			; Returns                                                                     : 
136c			;     Nothing                                                                 : 
136c			;                                                                             : 
136c			; Stack frame                                                                 : 
136c			;       |             |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |     BC      |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |     DE      |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |     IX      |                                                       : 
136c			;       +-------------+                                                       : 
136c			;       |  prev_free  |                                                       : 
136c			;   +2  +-------------+                                                       : 
136c			;       |  next_free  |                                                       : 
136c			;   +0  +-------------+                                                       : 
136c			;       |             |                                                       : 
136c			;                                                                             : 
136c			;------------------------------------------------------------------------------ 
136c			free: 
136c			      push  BC 
136c			      push  DE 
136c			      push  IX 
136c			 
136c			      ld    A, H                    ; Exit if ptr is null 
136c			      or    L 
136c			      jp    Z, free_early_exit 
136c			 
136c			      ; Set up stack frame 
136c			      ex    DE, HL 
136c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
136c			      add   HL, SP 
136c			      ld    SP, HL 
136c			      ld    IX, 0                   ; Use IX as a frame pointer 
136c			      add   IX, SP 
136c			 
136c			      ; The address in HL points to the start of the useable allocated space, 
136c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
136c			      ; address of the block itself. 
136c			      ex    DE, HL 
136c			      ld    DE, -4 
136c			      add   HL, DE 
136c			 
136c			      ; An allocated block must have a null next block pointer in it 
136c			      ld    A, (HL) 
136c			      inc   HL 
136c			      or    (HL) 
136c			      jp    NZ, free_done 
136c			 
136c			      dec   HL 
136c			 
136c			      ld    B, H                    ; Copy HL to BC 
136c			      ld    C, L 
136c			 
136c			      ; Loop through the free list to find the first block with an address 
136c			      ; higher than the block being freed 
136c			      ld    HL, free_list 
136c			 
136c			free_find_higher_block: 
136c			      ld    E, (HL)                 ; Load next ptr from free block 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      dec   HL 
136c			 
136c			      ld    (IX+0), E               ; Save ptr to next free block 
136c			      ld    (IX+1), D 
136c			      ld    (IX+2), L               ; Save ptr to prev free block 
136c			      ld    (IX+3), H 
136c			 
136c			      ld    A, B                    ; Check if DE is greater than BC 
136c			      cp    D                       ; Compare MSB first 
136c			      jr    Z, $+4                  ; MSB the same, compare LSB 
136c			      jr    NC, free_find_higher_block_skip 
136c			      ld    A, C 
136c			      cp    E                       ; Then compare LSB 
136c			      jr    C, free_found_higher_block 
136c			 
136c			free_find_higher_block_skip: 
136c			      ld    A, D                    ; Reached the end of the free list? 
136c			      or    E 
136c			      jp    Z, free_done 
136c			 
136c			      ex    DE, HL 
136c			 
136c			      jr    free_find_higher_block 
136c			 
136c			free_found_higher_block: 
136c			      ; Insert freed block between prev and next free blocks 
136c			      ld    (HL), C                 ; Point prev free block to freed block 
136c			      inc   HL 
136c			      ld    (HL), B 
136c			 
136c			      ld    H, B                    ; Point freed block at next free block 
136c			      ld    L, C 
136c			      ld    (HL), E 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			      ; Check if the freed block is adjacent to the next free block 
136c			      inc   HL                      ; Load size of freed block into HL 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      ex    DE, HL 
136c			 
136c			      add   HL, BC                  ; Add addr of freed block and its size 
136c			 
136c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
136c			      ld    D, (IX+1) 
136c			 
136c			      or    A                       ; Clear the carry flag 
136c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
136c			      jr    NZ, free_check_adjacent_to_prev 
136c			 
136c			      ; Freed block is adjacent to next, merge into one bigger block 
136c			      ex    DE, HL                  ; Load next ptr from next block into DE 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      push  HL                      ; Save ptr to next block for later 
136c			 
136c			      ld    H, B                    ; Store ptr from next block into freed block 
136c			      ld    L, C 
136c			      ld    (HL), E 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			      pop   HL                      ; Restore ptr to next block 
136c			      inc   HL                      ; Load size of next block into DE 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      push  DE                      ; Save next block size for later 
136c			 
136c			      ld    H, B                    ; Load size of freed block into HL 
136c			      ld    L, C 
136c			      inc   HL 
136c			      inc   HL 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      ex    DE, HL 
136c			 
136c			      pop   DE                      ; Restore size of next block 
136c			      add   HL, DE                  ; Add sizes of both blocks 
136c			      ex    DE, HL 
136c			 
136c			      ld    H, B                    ; Store new bigger size into freed block 
136c			      ld    L, C 
136c			      inc   HL 
136c			      inc   HL 
136c			      ld    (HL), E 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			free_check_adjacent_to_prev: 
136c			      ; Check if the freed block is adjacent to the prev free block 
136c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
136c			      ld    H, (IX+3) 
136c			 
136c			      inc   HL                      ; Size of prev free block into DE 
136c			      inc   HL 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      dec   HL 
136c			      dec   HL 
136c			      dec   HL 
136c			 
136c			      add   HL, DE                  ; Add prev block addr and size 
136c			 
136c			      or    A                       ; Clear the carry flag 
136c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
136c			      jr    NZ, free_done 
136c			 
136c			      ; Freed block is adjacent to prev, merge into one bigger block 
136c			      ld    H, B                    ; Load next ptr from freed block into DE 
136c			      ld    L, C 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      push  HL                      ; Save freed block ptr for later 
136c			 
136c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
136c			      ld    H, (IX+3) 
136c			      ld    (HL), E 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			      pop   HL                      ; Restore freed block ptr 
136c			      inc   HL                      ; Load size of freed block into DE 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			      push  DE                      ; Save freed block size for later 
136c			 
136c			      ld    L, (IX+2)               ; Load size of prev block into DE 
136c			      ld    H, (IX+3) 
136c			      inc   HL 
136c			      inc   HL 
136c			      ld    E, (HL) 
136c			      inc   HL 
136c			      ld    D, (HL) 
136c			 
136c			      pop   HL                      ; Add sizes of both blocks 
136c			      add   HL, DE 
136c			      ex    DE, HL 
136c			 
136c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
136c			      ld    H, (IX+3) 
136c			      inc   HL 
136c			      inc   HL 
136c			      ld    (HL), E 
136c			      inc   HL 
136c			      ld    (HL), D 
136c			 
136c			free_done: 
136c			      ld    HL, 4                   ; Clean up stack frame 
136c			      add   HL, SP 
136c			      ld    SP, HL 
136c			 
136c			free_early_exit: 
136c			      pop   IX 
136c			      pop   DE 
136c			      pop   BC 
136c			 
136c			      ret 
136c			 
136c			 
136c			;      .org 0x8000 
136c			; 
136c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
136c			 ;                 .dw   0 
136c			 
136c			endif 
136c			 
136c			 
136c			if MALLOC_4 
136c			 
136c			; My memory allocation code. Very very simple.... 
136c			; allocate space under 250 chars 
136c			 
136c			heap_init: 
136c				; init start of heap as zero 
136c				;  
136c			 
136c				ld hl, heap_start 
136c				ld a, 0 
136c				ld (hl), a      ; empty block 
136c				inc hl 
136c				ld a, 0 
136c				ld (hl), a      ; length of block 
136c				; write end of list 
136c				inc hl 
136c				ld a,(hl) 
136c				inc hl 
136c				ld a,(hl) 
136c				 
136c			 
136c				; init some malloc vars 
136c			 
136c				ld hl, 0 
136c				ld (free_list), hl       ; store last malloc location 
136c			 
136c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
136c				ld a, 0 
136c				ld (hl), a 
136c			 
136c			 
136c				ld hl, heap_start 
136c				;  
136c				  
136c				ret 
136c			 
136c			 
136c			;    free block marker 
136c			;    requested size  
136c			;    pointer to next block 
136c			;    .... 
136c			;    next block marker 
136c			 
136c			 
136c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
136c			; 
136c			 
136c			 
136c			malloc:  
136c				push de 
136c				push bc 
136c				push af 
136c			 
136c				; hl space required 
136c				 
136c				ld c, l    ; hold space   (TODO only a max of 255) 
136c			 
136c			;	inc c     ; TODO BUG need to fix memory leak on push str 
136c			;	inc c 
136c			;	inc c 
136c			;	inc c 
136c			;	inc c 
136c			;	inc c 
136c			;	inc c 
136c			 
136c			 
136c			 
136c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
136c			 
136c				ld a, (free_list+3) 
136c				cp 0 
136c				jr z, .contheap 
136c			 
136c				ld hl, (free_list)     ; get last alloc 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "mrs" 
136c						CALLMONITOR 
136c					endif 
136c				jr .startalloc 
136c			 
136c			.contheap: 
136c				ld hl, heap_start 
136c			 
136c			.startalloc: 
136c			 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "mym" 
136c						CALLMONITOR 
136c					endif 
136c			.findblock: 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "mmf" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c				ld a,(hl)  
136c				; if byte is zero then clear to use 
136c			 
136c				cp 0 
136c				jr z, .foundemptyblock 
136c			 
136c				; if byte is not clear 
136c				;     then byte is offset to next block 
136c			 
136c				inc hl 
136c				ld a, (hl) ; get size 
136c			.nextblock:	inc hl 
136c					ld e, (hl) 
136c					inc hl 
136c					ld d, (hl) 
136c					ex de, hl 
136c			;	inc hl  ; move past the store space 
136c			;	inc hl  ; move past zero index  
136c			 
136c				; TODO detect no more space 
136c			 
136c				push hl 
136c				ld de, heap_end 
136c				call cmp16 
136c				pop hl 
136c				jr nc, .nospace 
136c			 
136c				jr .findblock 
136c			 
136c			.nospace: ld hl, 0 
136c				jp .exit 
136c			 
136c			 
136c			.foundemptyblock:	 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "mme" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c			; TODO has block enough space if reusing??? 
136c			 
136c				;  
136c			 
136c			; see if this block has been previously used 
136c				inc hl 
136c				ld a, (hl) 
136c				dec hl 
136c				cp 0 
136c				jr z, .newblock 
136c			 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "meR" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c			; no reusing previously allocated block 
136c			 
136c			; is it smaller than previously used? 
136c				 
136c				inc hl    ; move to size 
136c				ld a, c 
136c				sub (hl)        ; we want c < (hl) 
136c				dec hl    ; move back to marker 
136c			        jr z, .findblock 
136c			 
136c				; update with the new size which should be lower 
136c			 
136c			        ;inc  hl   ; negate next move. move back to size  
136c			 
136c			.newblock: 
136c				; need to be at marker here 
136c			 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "meN" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c			 
136c				ld a, c 
136c			 
136c				ld (free_list+3), a	 ; flag resume from last malloc  
136c				ld (free_list), hl    ; save out last location 
136c			 
136c			 
136c				;inc a     ; space for length byte 
136c				ld (hl), a     ; save block in use marker 
136c			 
136c				inc hl   ; move to space marker 
136c				ld (hl), a    ; save new space 
136c			 
136c				inc hl   ; move to start of allocated area 
136c				 
136c			;	push hl     ; save where we are - 1  
136c			 
136c			;	inc hl  ; move past zero index  
136c				; skip space to set down new marker 
136c			 
136c				; provide some extra space for now 
136c			 
136c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
136c				inc a 
136c				inc a 
136c			 
136c				push hl   ; save where we are in the node block 
136c			 
136c				call addatohl 
136c			 
136c				; write linked list point 
136c			 
136c				pop de     ; get our node position 
136c				ex de, hl 
136c			 
136c				ld (hl), e 
136c				inc hl 
136c				ld (hl), d 
136c			 
136c				inc hl 
136c			 
136c				; now at start of allocated data so save pointer 
136c			 
136c				push hl 
136c			 
136c				; jump to position of next node and setup empty header in DE 
136c			 
136c				ex de, hl 
136c			 
136c			;	inc hl ; move past end of block 
136c			 
136c				ld a, 0 
136c				ld (hl), a   ; empty marker 
136c				inc hl 
136c				ld (hl), a   ; size 
136c				inc hl  
136c				ld (hl), a   ; ptr 
136c				inc hl 
136c				ld (hl), a   ; ptr 
136c			 
136c			 
136c				pop hl 
136c			 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "mmr" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c			.exit: 
136c				pop af 
136c				pop bc 
136c				pop de  
136c				ret 
136c			 
136c			 
136c			 
136c			 
136c			free:  
136c				push hl 
136c				push af 
136c				; get address in hl 
136c			 
136c					if DEBUG_FORTH_MALLOC_INT 
136c						DMARK "fre" 
136c						CALLMONITOR 
136c					endif 
136c				; data is at hl - move to block count 
136c				dec hl 
136c				dec hl    ; get past pointer 
136c				dec hl 
136c			 
136c				ld a, (hl)    ; need this for a validation check 
136c			 
136c				dec hl    ; move to block marker 
136c			 
136c				; now check that the block count and block marker are the same  
136c			        ; this checks that we are on a malloc node and not random memory 
136c			        ; OK a faint chance this could be a problem but rare - famous last words! 
136c			 
136c				ld c, a 
136c				ld a, (hl)    
136c			 
136c				cp c 
136c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
136c			 
136c				; yes good chance we are on a malloc node 
136c			 
136c				ld a, 0      
136c				ld (hl), a   ; mark as free 
136c			 
136c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
136c			 
136c			.freeignore:  
136c			 
136c				pop af 
136c				pop hl 
136c			 
136c				ret 
136c			 
136c			 
136c			 
136c			endif 
136c			 
136c			; eof 
# End of file firmware_memory.asm
136c			  
136c			; device C  
136c			if SOUND_ENABLE  
136c				include "firmware_sound.asm"  
136c			; Sound abstraction layer 
136c			 
136c			; support different sound chips through common interface 
136c			 
136c			SOUND_DEVICE_AY: equ 0 
136c			 
136c			SOUND_DEVICE: equ Device_A 
136c			 
136c			 
136c			 
136c			if SOUND_DEVICE_AY 
136c				include "firmware_sound_ay38910.asm" 
136c			else 
136c				include "firmware_sound_sn76489an.asm" 
136c			 
136c			; Device support for SN76489AN sound chip 
136c			 
136c			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
136c			; http://danceswithferrets.org/geekblog/?p=93 
136c			; https://www.smspower.org/Development/SN76489 
136c			 
136c			; D0 [ 3] 
136c			; D1 [ 2] 
136c			; D2 [ 1] 
136c			; D3 [15] 
136c			; D4 [13] 
136c			; D5 [12] 
136c			; D6 [11] 
136c			; D7 [10] 
136c			; /WE [ 5] 
136c			; CLK [14] 
136c			; /OE [ 6] 
136c			; AUDIO [ 7] 
136c			; GND 8 
136c			; +5 16 
136c			; 
136c			 
136c			; Write sequence: 
136c			; CE low 
136c			; Data bus 
136c			; WE low then high 
136c			; 32 clock cycles / 8ns write time at 4mhz 
136c			; 
136c			; https://github.com/jblang/SN76489 
136c			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
136c			; Tried: 
136c			; 
136c			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
136c			; 
136c			; Connected WE to OR too 
136c			;  
136c			; That enabled the clock when required 
136c			; However still random bus corruption. Need further investigation 
136c			 
136c			 
136c			SOUND_LATCH: equ 10000000B 
136c			SOUND_DATA: equ 0B 
136c			SOUND_CH0:  equ 0B    ; Tone 
136c			SOUND_CH1: equ 0100000B        ; Tone 
136c			SOUND_CH2: equ 1000000B   ; Tone 
136c			SOUND_CH3: equ 1100000B    ; Noise 
136c			SOUND_VOL: equ 10000B 
136c			SOUND_TONE: equ 0B 
136c			 
136c			 
136c			sound_init: 
136c 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
136e cd 83 13			call note_send_byte 
1371 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1373 cd 83 13			call note_send_byte 
1376 cd 4c 0a			call delay250ms 
1379 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
137b cd 83 13			call note_send_byte 
137e cd 4c 0a			call delay250ms 
1381 c9				ret 
1382			 
1382			; Play a note 
1382			; h = note 
1382			; l = duration 
1382			; a = channel 
1382			 
1382			 
1382			;  frequ = clock / ( 2 x reg valu x 32 )  
1382			 
1382			note:  
1382				 
1382			 
1382 c9				ret 
1383			 
1383			note_send_byte: 
1383				; byte in a 
1383			 
1383				; we high 
1383 d3 40			out (Device_B), a 
1385			;	ld a, 1 
1385			;	call aDelayInMS 
1385 00				nop  
1386 00				nop  
1387 00				nop  
1388 00				nop  
1389				; we low 
1389 d3 40			out (Device_B), a 
138b			;	ld a, 1 
138b			;	call aDelayInMS 
138b 00				nop  
138c 00				nop  
138d 00				nop  
138e 00				nop  
138f				; we high 
138f d3 40			out (Device_B), a 
1391			;	ld a, 1 
1391			;	call aDelayInMS 
1391 00				nop  
1392 00				nop  
1393 00				nop  
1394 00				nop  
1395			 
1395			 
1395 c9				ret 
1396			 
1396			;void SilenceAllChannels() 
1396			;{ 
1396			;  SendByte(0x9f); 
1396			;  SendByte(0xbf); 
1396			;  SendByte(0xdf); 
1396			;  SendByte(0xff); 
1396			;} 
1396			 
1396			 
1396			; eof 
1396			 
# End of file firmware_sound_sn76489an.asm
1396			endif 
1396			 
1396			 
1396			; Abstraction entry points 
1396			 
1396			; init  
1396			 
1396			; sound_init in specific hardware files 
1396			 
1396			; Play a note 
1396			; h = note 
1396			; l = duration 
1396			; a = channel 
1396			 
1396			;note:     
1396			;	ret 
1396			 
1396			 
1396			 
1396			 
1396			; eof 
1396			 
# End of file firmware_sound.asm
1396			endif  
1396			  
1396			include "firmware_diags.asm"  
1396			; Hardware diags menu 
1396			 
1396			 
1396			config: 
1396			 
1396 3e 00			ld a, 0 
1398 21 c6 13			ld hl, .configmn 
139b cd 09 0b			call menu 
139e			 
139e fe 00			cp 0 
13a0 c8				ret z 
13a1			 
13a1 fe 01			cp 1 
13a3 cc 30 15			call z, .savetostore 
13a6			 
13a6 fe 02			cp 2 
13a8 cc 7e 14			call z, .selautoload 
13ab fe 03			cp 3 
13ad cc 67 14			call z, .disautoload 
13b0 fe 04			cp 4 
13b2 cc 2e 15			call z, .selbank 
13b5 fe 05			cp 5 
13b7 cc 0b 16			call z, .debug_tog 
13ba fe 06			cp 6 
13bc cc 53 17			call z, .bpsgo 
13bf fe 07			cp 7 
13c1 cc 31 16			call z, hardware_diags 
13c4			 
13c4 18 d0			jr config 
13c6			 
13c6			.configmn: 
13c6 d6 13			dw .c3 
13c8 ed 13			dw .c2 
13ca 02 14			dw .c2a 
13cc 18 14			dw .c2b 
13ce			;	dw .c4 
13ce 35 14			dw .m4 
13d0 50 14			dw .m4b 
13d2 58 14			dw .c1 
13d4 00 00			dw 0 
13d6				 
13d6			 
13d6 .. 00		.c3: db "Add Dictionary To File",0 
13ed .. 00		.c2: db "Select Autoload File",0 
1402 .. 00		.c2a: db "Disable Autoload File", 0 
1418 .. 00		.c2b: db "Select Storage Bank",0 
142c .. 00		.c4: db "Settings",0 
1435 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1450 .. 00		.m4b:   db "Monitor",0 
1458 .. 00		.c1: db "Hardware Diags",0 
1467			 
1467			 
1467			.disautoload: 
1467				if STORAGE_SE 
1467 3e fe			ld a, $fe      ; bit 0 clear 
1469 32 48 f8			ld (spi_device), a 
146c			 
146c cd bd 03			call storage_get_block_0 
146f			 
146f 3e 00			ld a, 0 
1471 32 83 f8			ld (store_page+STORE_0_AUTOFILE), a 
1474			 
1474 21 00 00				ld hl, 0 
1477 11 62 f8				ld de, store_page 
147a cd 71 03			call storage_write_block	 ; save update 
147d				endif 
147d			 
147d			 
147d c9				ret 
147e			 
147e			 
147e			 
147e			; Select auto start 
147e			 
147e			.selautoload: 
147e			 
147e				 
147e				if STORAGE_SE 
147e			 
147e cd 55 15				call config_dir 
1481 21 1d ee			        ld hl, scratch 
1484 3e 00				ld a, 0 
1486 cd 09 0b				call menu 
1489			 
1489 fe 00				cp 0 
148b c8					ret z 
148c			 
148c 3d					dec a 
148d			 
148d			 
148d					; locate menu option 
148d			 
148d 21 1d ee				ld hl, scratch 
1490 cd 30 0a				call table_lookup 
1493			 
1493					if DEBUG_FORTH_WORDS 
1493						DMARK "ALl" 
1493 f5				push af  
1494 3a a8 14			ld a, (.dmark)  
1497 32 77 fb			ld (debug_mark),a  
149a 3a a9 14			ld a, (.dmark+1)  
149d 32 78 fb			ld (debug_mark+1),a  
14a0 3a aa 14			ld a, (.dmark+2)  
14a3 32 79 fb			ld (debug_mark+2),a  
14a6 18 03			jr .pastdmark  
14a8 ..			.dmark: db "ALl"  
14ab f1			.pastdmark: pop af  
14ac			endm  
# End of macro DMARK
14ac						CALLMONITOR 
14ac cd 49 17			call break_point_state  
14af				endm  
# End of macro CALLMONITOR
14af					endif 
14af					; with the pointer to the menu it, the byte following the zero term is the file id 
14af			 
14af 3e 00				ld a, 0 
14b1 01 32 00				ld bc, 50   ; max of bytes to look at 
14b4 ed b1				cpir  
14b6			 
14b6					if DEBUG_FORTH_WORDS 
14b6						DMARK "ALb" 
14b6 f5				push af  
14b7 3a cb 14			ld a, (.dmark)  
14ba 32 77 fb			ld (debug_mark),a  
14bd 3a cc 14			ld a, (.dmark+1)  
14c0 32 78 fb			ld (debug_mark+1),a  
14c3 3a cd 14			ld a, (.dmark+2)  
14c6 32 79 fb			ld (debug_mark+2),a  
14c9 18 03			jr .pastdmark  
14cb ..			.dmark: db "ALb"  
14ce f1			.pastdmark: pop af  
14cf			endm  
# End of macro DMARK
14cf						CALLMONITOR 
14cf cd 49 17			call break_point_state  
14d2				endm  
# End of macro CALLMONITOR
14d2					endif 
14d2					;inc hl 
14d2			 
14d2 7e					ld a, (hl)   ; file id 
14d3					 
14d3				        ; save bank and file ids 
14d3			 
14d3 f5					push af 
14d4			 
14d4			; TODO need to save to block 0 on bank 1	 
14d4			 
14d4 cd bd 03				call storage_get_block_0 
14d7			 
14d7					if DEBUG_FORTH_WORDS 
14d7						DMARK "AL0" 
14d7 f5				push af  
14d8 3a ec 14			ld a, (.dmark)  
14db 32 77 fb			ld (debug_mark),a  
14de 3a ed 14			ld a, (.dmark+1)  
14e1 32 78 fb			ld (debug_mark+1),a  
14e4 3a ee 14			ld a, (.dmark+2)  
14e7 32 79 fb			ld (debug_mark+2),a  
14ea 18 03			jr .pastdmark  
14ec ..			.dmark: db "AL0"  
14ef f1			.pastdmark: pop af  
14f0			endm  
# End of macro DMARK
14f0						CALLMONITOR 
14f0 cd 49 17			call break_point_state  
14f3				endm  
# End of macro CALLMONITOR
14f3					endif 
14f3 f1					pop af 
14f4			 
14f4 32 86 f8				ld (store_page+STORE_0_FILERUN),a 
14f7					 
14f7					; save bank id 
14f7			 
14f7 3a 48 f8				ld a,(spi_device) 
14fa 32 85 f8				ld (store_page+STORE_0_BANKRUN),a 
14fd			 
14fd					; enable auto run of store file 
14fd			 
14fd 3e 01				ld a, 1 
14ff 32 83 f8				ld (store_page+STORE_0_AUTOFILE),a 
1502			 
1502					; save buffer 
1502			 
1502 21 00 00				ld hl, 0 
1505 11 62 f8				ld de, store_page 
1508					if DEBUG_FORTH_WORDS 
1508						DMARK "ALw" 
1508 f5				push af  
1509 3a 1d 15			ld a, (.dmark)  
150c 32 77 fb			ld (debug_mark),a  
150f 3a 1e 15			ld a, (.dmark+1)  
1512 32 78 fb			ld (debug_mark+1),a  
1515 3a 1f 15			ld a, (.dmark+2)  
1518 32 79 fb			ld (debug_mark+2),a  
151b 18 03			jr .pastdmark  
151d ..			.dmark: db "ALw"  
1520 f1			.pastdmark: pop af  
1521			endm  
# End of macro DMARK
1521						CALLMONITOR 
1521 cd 49 17			call break_point_state  
1524				endm  
# End of macro CALLMONITOR
1524					endif 
1524 cd 71 03			call storage_write_block	 ; save update 
1527			  
1527			 
1527			 
1527			 
1527 21 1d ee				ld hl, scratch 
152a cd 42 15				call config_fdir 
152d			 
152d			 
152d				endif 
152d c9				ret 
152e			 
152e			 
152e			 
152e			; Select storage bank 
152e			 
152e			.selbank: 
152e			 
152e				if STORAGE_SE 
152e				endif 
152e				 
152e c9				ret 
152f			 
152f			if STORAGE_SE 
152f			 
152f			.config_ldir:   
152f				; Load storage bank labels into menu array 
152f			 
152f				 
152f			 
152f			 
152f c9				ret 
1530			 
1530			 
1530			endif 
1530			 
1530			 
1530			; Save user words to storage 
1530			 
1530			.savetostore: 
1530			 
1530				if STORAGE_SE 
1530			 
1530 cd 55 15				call config_dir 
1533 21 1d ee			        ld hl, scratch 
1536 3e 00				ld a, 0 
1538 cd 09 0b				call menu 
153b					 
153b 21 1d ee				ld hl, scratch 
153e cd 42 15				call config_fdir 
1541			 
1541			 
1541				endif 
1541			 
1541 c9				ret 
1542			 
1542			 
1542			 
1542			if STORAGE_SE 
1542			 
1542			config_fdir: 
1542				; using the scratch dir go through and release the memory allocated for each string 
1542				 
1542 21 1d ee			ld hl, scratch 
1545 5e			.cfdir:	ld e,(hl) 
1546 23				inc hl 
1547 56				ld d,(hl) 
1548 23				inc hl 
1549			 
1549 eb				ex de, hl 
154a cd 35 0d			call ishlzero 
154d c8				ret z     ; return on null pointer 
154e cd 9d 12			call free 
1551 eb				ex de, hl 
1552 18 f1			jr .cfdir 
1554			 
1554			 
1554 c9				ret 
1555			 
1555			 
1555			config_dir: 
1555			 
1555				; for the config menus that need to build a directory of storage call this routine 
1555				; it will construct a menu in scratch to pass to menu 
1555			 
1555				; open storage device 
1555			 
1555				; execute DIR to build a list of files and their ids into scratch in menu format 
1555				; once the menu has finished then will need to call config_fdir to release the strings 
1555				 
1555				; c = number items 
1555			 
1555				 
1555 cd bd 03			call storage_get_block_0 
1558			 
1558 21 62 f8			ld hl, store_page     ; get current id count 
155b 46				ld b, (hl) 
155c 0e 00			ld c, 0    ; count of files   
155e			 
155e			 
155e 21 1d ee			ld hl, scratch 
1561 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
1564			 
1564				; check for empty drive 
1564			 
1564 3e 00			ld a, 0 
1566 b8				cp b 
1567 ca 01 16			jp z, .dirdone 
156a			 
156a				 
156a					if DEBUG_FORTH_WORDS 
156a						DMARK "Cdc" 
156a f5				push af  
156b 3a 7f 15			ld a, (.dmark)  
156e 32 77 fb			ld (debug_mark),a  
1571 3a 80 15			ld a, (.dmark+1)  
1574 32 78 fb			ld (debug_mark+1),a  
1577 3a 81 15			ld a, (.dmark+2)  
157a 32 79 fb			ld (debug_mark+2),a  
157d 18 03			jr .pastdmark  
157f ..			.dmark: db "Cdc"  
1582 f1			.pastdmark: pop af  
1583			endm  
# End of macro DMARK
1583						CALLMONITOR 
1583 cd 49 17			call break_point_state  
1586				endm  
# End of macro CALLMONITOR
1586					endif 
1586			 
1586			 
1586			.diritem:	 
1586 c5				push bc 
1587				; for each of the current ids do a search for them and if found push to stack 
1587			 
1587 21 40 00				ld hl, STORE_BLOCK_PHY 
158a 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
158c 58					ld e,b 
158d			 
158d cd 2d 06				call storage_findnextid 
1590			 
1590			 
1590					; if found hl will be non zero 
1590			 
1590 cd 35 0d				call ishlzero 
1593 28 69				jr z, .dirnotfound 
1595			 
1595					; increase count 
1595			 
1595 c1					pop bc	 
1596 0c					inc c 
1597 c5					push bc 
1598					 
1598			 
1598					; get file header and push the file name 
1598			 
1598 11 62 f8				ld de, store_page 
159b cd 0c 03				call storage_read_block 
159e			 
159e					; push file id to stack 
159e				 
159e 3a 62 f8				ld a, (store_page) 
15a1 26 00				ld h, 0 
15a3 6f					ld l, a 
15a4			 
15a4					;call forth_push_numhl 
15a4					; TODO store id 
15a4			 
15a4 e5					push hl 
15a5			 
15a5					; push extent count to stack  
15a5				 
15a5 21 65 f8				ld hl, store_page+3 
15a8			 
15a8					; get file name length 
15a8			 
15a8 cd 6a 11				call strlenz   
15ab			 
15ab 23					inc hl   ; cover zero term 
15ac 23					inc hl  ; stick the id at the end of the area 
15ad			 
15ad e5					push hl 
15ae c1					pop bc    ; move length to bc 
15af			 
15af cd d3 11				call malloc 
15b2			 
15b2					; TODO save malloc area to scratch 
15b2			 
15b2 eb					ex de, hl 
15b3 2a 5e f8				ld hl, (store_tmp2) 
15b6 73					ld (hl), e 
15b7 23					inc hl 
15b8 72					ld (hl), d 
15b9 23					inc hl 
15ba 22 5e f8				ld (store_tmp2), hl 
15bd			 
15bd					 
15bd			 
15bd					;pop hl   ; get source 
15bd			;		ex de, hl    ; swap aronund	 
15bd			 
15bd 21 65 f8				ld hl, store_page+3 
15c0					if DEBUG_FORTH_WORDS 
15c0						DMARK "CFd" 
15c0 f5				push af  
15c1 3a d5 15			ld a, (.dmark)  
15c4 32 77 fb			ld (debug_mark),a  
15c7 3a d6 15			ld a, (.dmark+1)  
15ca 32 78 fb			ld (debug_mark+1),a  
15cd 3a d7 15			ld a, (.dmark+2)  
15d0 32 79 fb			ld (debug_mark+2),a  
15d3 18 03			jr .pastdmark  
15d5 ..			.dmark: db "CFd"  
15d8 f1			.pastdmark: pop af  
15d9			endm  
# End of macro DMARK
15d9						CALLMONITOR 
15d9 cd 49 17			call break_point_state  
15dc				endm  
# End of macro CALLMONITOR
15dc					endif 
15dc ed b0				ldir 
15de			 
15de					; de is past string, move back one and store id 
15de					 
15de 1b					dec de 
15df			 
15df					; store file id 
15df			 
15df e1					pop hl 
15e0 eb					ex de,hl 
15e1 73					ld (hl), e 
15e2			 
15e2					if DEBUG_FORTH_WORDS 
15e2						DMARK "Cdi" 
15e2 f5				push af  
15e3 3a f7 15			ld a, (.dmark)  
15e6 32 77 fb			ld (debug_mark),a  
15e9 3a f8 15			ld a, (.dmark+1)  
15ec 32 78 fb			ld (debug_mark+1),a  
15ef 3a f9 15			ld a, (.dmark+2)  
15f2 32 79 fb			ld (debug_mark+2),a  
15f5 18 03			jr .pastdmark  
15f7 ..			.dmark: db "Cdi"  
15fa f1			.pastdmark: pop af  
15fb			endm  
# End of macro DMARK
15fb						CALLMONITOR 
15fb cd 49 17			call break_point_state  
15fe				endm  
# End of macro CALLMONITOR
15fe					endif 
15fe					 
15fe			.dirnotfound: 
15fe c1					pop bc     
15ff 10 85				djnz .diritem 
1601				 
1601			.dirdone:	 
1601			 
1601 3e 00				ld a, 0 
1603 2a 5e f8				ld hl, (store_tmp2) 
1606 77					ld (hl), a 
1607 23					inc hl 
1608 77					ld (hl), a 
1609 23					inc hl 
160a					; push a count of the dir items found 
160a			 
160a			;		ld h, 0 
160a			;		ld l, c 
160a			 
160a c9				ret 
160b			 
160b			endif 
160b			 
160b			 
160b			; Settings 
160b			; Run  
160b			 
160b			 
160b			 
160b			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
160b			;;hd_menu2:   db "        2: Editor",0   
160b			;hd_menu2:   db "        2: Editor       6: Menu",0   
160b			;hd_menu3:   db "        3: Storage",0 
160b			;hd_menu4:   db "0=quit  4: Debug",0 
160b			;hd_don:     db "ON",0 
160b			;hd_doff:     db "OFF",0 
160b			; 
160b			; 
160b			; 
160b			;hardware_diags_old:       
160b			; 
160b			;.diagmenu: 
160b			;	call clear_display 
160b			;	ld a, display_row_1 
160b			;	ld de, hd_menu1 
160b			;	call str_at_display 
160b			; 
160b			;	ld a, display_row_2 
160b			;	ld de, hd_menu2 
160b			;	call str_at_display 
160b			; 
160b			;	ld a, display_row_3 
160b			;	ld de, hd_menu3 
160b			;	call str_at_display 
160b			; 
160b			;	ld a,  display_row_4 
160b			;	ld de, hd_menu4 
160b			;	call str_at_display 
160b			; 
160b			;	; display debug state 
160b			; 
160b			;	ld de, hd_don 
160b			;	ld a, (os_view_disable) 
160b			;	cp 0 
160b			;	jr z, .distog 
160b			;	ld de, hd_doff 
160b			;.distog: ld a, display_row_4+17 
160b			;	call str_at_display 
160b			; 
160b			;	call update_display 
160b			; 
160b			;	call cin_wait 
160b			; 
160b			; 
160b			; 
160b			;	cp '4' 
160b			;	jr nz, .diagn1 
160b			; 
160b			;	; debug toggle 
160b			; 
160b			;	ld a, (os_view_disable) 
160b			;	ld b, '*' 
160b			;	cp 0 
160b			;	jr z, .debtog 
160b			;	ld b, 0 
160b			;.debtog:	 
160b			;	ld a,b 
160b			;	ld (os_view_disable),a 
160b			; 
160b			;.diagn1: cp '0' 
160b			;	 ret z 
160b			; 
160b			;;	cp '1' 
160b			;;       jp z, matrix	 
160b			;;   TODO keyboard matrix test 
160b			; 
160b			;	cp '2' 
160b			;	jp z, .diagedit 
160b			; 
160b			;;	cp '6' 
160b			;;	jp z, .menutest 
160b			;;if ENABLE_BASIC 
160b			;;	cp '6' 
160b			;;	jp z, basic 
160b			;;endif 
160b			 ; 
160b			;	jp .diagmenu 
160b			; 
160b			; 
160b			;	ret 
160b			 
160b			 
160b			.debug_tog: 
160b 21 52 16			ld hl, .menudebug 
160e				 
160e 3a 0e ee			ld a, (os_view_disable) 
1611 fe 2a			cp '*' 
1613 20 04			jr nz,.tdon  
1615 3e 01			ld a, 1 
1617 18 02			jr .tog1 
1619 3e 00		.tdon: ld a, 0 
161b			 
161b			.tog1: 
161b cd 09 0b			call menu 
161e fe 00			cp 0 
1620 c8				ret z 
1621 fe 01			cp 1    ; disable debug 
1623 28 04			jr z, .dtog0 
1625 3e 2a			ld a, '*' 
1627 18 02			jr .dtogset 
1629 3e 00		.dtog0: ld a, 0 
162b 32 0e ee		.dtogset:  ld (os_view_disable), a 
162e c3 0b 16			jp .debug_tog 
1631			 
1631			 
1631			hardware_diags:       
1631			 
1631			.diagm: 
1631 21 44 16			ld hl, .menuitems 
1634 3e 00			ld a, 0 
1636 cd 09 0b			call menu 
1639			 
1639 fe 00		         cp 0 
163b c8				 ret z 
163c			 
163c fe 02			cp 2 
163e ca 9d 16			jp z, .diagedit 
1641			 
1641			;	cp '6' 
1641			;	jp z, .menutest 
1641			;if ENABLE_BASIC 
1641			;	cp '6' 
1641			;	jp z, basic 
1641			;endif 
1641			  
1641 c3 31 16			jp .diagm 
1644			 
1644				 
1644 58 16		.menuitems:   	dw .m1 
1646 63 16				dw .m2 
1648 6a 16				dw .m3 
164a 72 16				dw .m5 
164c 78 16				dw .m5a 
164e 81 16				dw .m5b 
1650 00 00				dw 0 
1652			 
1652			.menudebug: 
1652 8a 16				dw .m6 
1654 93 16				dw .m7 
1656 00 00				dw 0 
1658			 
1658 .. 00		.m1:   db "Key Matrix",0 
1663 .. 00		.m2:   db "Editor",0 
166a .. 00		.m3:   db "Storage",0 
1672 .. 00		.m5:   db "Sound",0 
1678 .. 00		.m5a:  db "RAM Test",0 
1681 .. 00		.m5b:  db "LCD Test",0 
168a			 
168a .. 00		.m6:   db "Debug ON",0 
1693 .. 00		.m7:   db "Debug OFF",0 
169d			 
169d			; debug editor 
169d			 
169d			.diagedit: 
169d			 
169d 21 1d ee			ld hl, scratch 
16a0			;	ld bc, 250 
16a0			;	ldir 
16a0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16a0 3e 00			ld a, 0 
16a2 77				ld (hl), a 
16a3 23				inc hl 
16a4 77				ld (hl), a 
16a5 23				inc hl 
16a6 77				ld (hl), a 
16a7			 
16a7 cd d8 0a		        call clear_display 
16aa cd fb 0a			call update_display 
16ad 3e 01			ld a, 1 
16af 32 7d fb			ld (hardware_diag), a 
16b2			.diloop: 
16b2 3e 00			ld a, display_row_1 
16b4 0e 00			ld c, 0 
16b6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16b8 1e 28			ld e, 40 
16ba			 
16ba 21 1d ee			ld hl, scratch	 
16bd cd 39 0d			call input_str 
16c0			 
16c0 3e 28			ld a, display_row_2 
16c2 11 1d ee			ld de, scratch 
16c5 cd eb 0a			call str_at_display 
16c8 cd fb 0a			call update_display 
16cb			 
16cb c3 b2 16			jp .diloop 
16ce			 
16ce			 
16ce			; pass word in hl 
16ce			; a has display location 
16ce			display_word_at: 
16ce f5				push af 
16cf e5				push hl 
16d0 7c				ld a,h 
16d1 21 22 f1			ld hl, os_word_scratch 
16d4 cd 0d 10			call hexout 
16d7 e1				pop hl 
16d8 7d				ld a,l 
16d9 21 24 f1			ld hl, os_word_scratch+2 
16dc cd 0d 10			call hexout 
16df 21 26 f1			ld hl, os_word_scratch+4 
16e2 3e 00			ld a,0 
16e4 77				ld (hl),a 
16e5 11 22 f1			ld de,os_word_scratch 
16e8 f1				pop af 
16e9 cd eb 0a				call str_at_display 
16ec c9				ret 
16ed			 
16ed			display_ptr_state: 
16ed			 
16ed				; to restore afterwards 
16ed			 
16ed d5				push de 
16ee c5				push bc 
16ef e5				push hl 
16f0 f5				push af 
16f1			 
16f1				; for use in here 
16f1			 
16f1			;	push bc 
16f1			;	push de 
16f1			;	push hl 
16f1			;	push af 
16f1			 
16f1 cd d8 0a			call clear_display 
16f4			 
16f4 11 c7 18			ld de, .ptrstate 
16f7 3e 00			ld a, display_row_1 
16f9 cd eb 0a			call str_at_display 
16fc			 
16fc				; display debug step 
16fc			 
16fc			 
16fc 11 77 fb			ld de, debug_mark 
16ff 3e 26			ld a, display_row_1+display_cols-2 
1701 cd eb 0a			call str_at_display 
1704			 
1704				; display a 
1704 11 d1 18			ld de, .ptrcliptr 
1707 3e 28			ld a, display_row_2 
1709 cd eb 0a			call str_at_display 
170c			 
170c f1				pop af 
170d 2a 28 f8			ld hl,(cli_ptr) 
1710 3e 30			ld a, display_row_2+8 
1712 cd ce 16			call display_word_at 
1715			 
1715			 
1715				; display hl 
1715			 
1715			 
1715 11 d9 18			ld de, .ptrclioptr 
1718 3e 32			ld a, display_row_2+10 
171a cd eb 0a			call str_at_display 
171d			; 
171d			;	pop hl 
171d 3e 35			ld a, display_row_2+13 
171f 2a 26 f8			ld hl,(cli_origptr) 
1722 cd ce 16			call display_word_at 
1725			; 
1725			;	 
1725			;	; display de 
1725			 
1725			;	ld de, .regstatede 
1725			;	ld a, display_row_3 
1725			;	call str_at_display 
1725			 
1725			;	pop de 
1725			;	ld h,d 
1725			;	ld l, e 
1725			;	ld a, display_row_3+3 
1725			;	call display_word_at 
1725			 
1725			 
1725				; display bc 
1725			 
1725			;	ld de, .regstatebc 
1725			;	ld a, display_row_3+10 
1725			;	call str_at_display 
1725			 
1725			;	pop bc 
1725			;	ld h,b 
1725			;	ld l, c 
1725			;	ld a, display_row_3+13 
1725			;	call display_word_at 
1725			 
1725			 
1725				; display dsp 
1725			 
1725			;	ld de, .regstatedsp 
1725			;	ld a, display_row_4 
1725			;	call str_at_display 
1725			 
1725				 
1725			;	ld hl,(cli_data_sp) 
1725			;	ld a, display_row_4+4 
1725			;	call display_word_at 
1725			 
1725				; display rsp 
1725			 
1725 11 08 19			ld de, .regstatersp 
1728 3e 82			ld a, display_row_4+10 
172a cd eb 0a			call str_at_display 
172d			 
172d				 
172d 2a 0e f8			ld hl,(cli_ret_sp) 
1730 3e 86			ld a, display_row_4+14 
1732 cd ce 16			call display_word_at 
1735			 
1735 cd fb 0a			call update_display 
1738			 
1738 cd 58 0a			call delay1s 
173b cd 58 0a			call delay1s 
173e cd 58 0a			call delay1s 
1741			 
1741			 
1741 cd 51 1c			call next_page_prompt 
1744			 
1744				; restore  
1744			 
1744 f1				pop af 
1745 e1				pop hl 
1746 c1				pop bc 
1747 d1				pop de 
1748 c9				ret 
1749			 
1749			break_point_state: 
1749 f5				push af 
174a			 
174a				; see if disabled 
174a			 
174a 3a 0e ee			ld a, (os_view_disable) 
174d fe 2a			cp '*' 
174f 20 02			jr nz, .bpsgo 
1751 f1				pop af 
1752 c9				ret 
1753			 
1753			.bpsgo: 
1753 f1				pop af 
1754 f5				push af 
1755 22 0a ee			ld (os_view_hl), hl 
1758 ed 53 08 ee		ld (os_view_de), de 
175c ed 43 06 ee		ld (os_view_bc), bc 
1760 e5				push hl 
1761 6f				ld l, a 
1762 26 00			ld h, 0 
1764 22 0c ee			ld (os_view_af),hl 
1767			 
1767 21 bd fa				ld hl, display_fb0 
176a 22 d8 f8				ld (display_fb_active), hl 
176d e1				pop hl	 
176e			 
176e 3e 31			ld a, '1' 
1770 fe 2a		.bps1:  cp '*' 
1772 20 03			jr nz, .bps1b 
1774 32 0e ee			ld (os_view_disable),a 
1777 fe 31		.bps1b:  cp '1' 
1779 20 14			jr nz, .bps2 
177b			 
177b				; display reg 
177b			 
177b				 
177b			 
177b 3a 0c ee			ld a, (os_view_af) 
177e 2a 0a ee			ld hl, (os_view_hl) 
1781 ed 5b 08 ee		ld de, (os_view_de) 
1785 ed 4b 06 ee		ld bc, (os_view_bc) 
1789 cd 23 18			call display_reg_state 
178c c3 0f 18			jp .bpschk 
178f			 
178f fe 32		.bps2:  cp '2' 
1791 20 08			jr nz, .bps3 
1793				 
1793				; display hl 
1793 2a 0a ee			ld hl, (os_view_hl) 
1796 cd 0d 19			call display_dump_at_hl 
1799			 
1799 18 74			jr .bpschk 
179b			 
179b fe 33		.bps3:  cp '3' 
179d 20 08			jr nz, .bps4 
179f			 
179f			        ; display de 
179f 2a 08 ee			ld hl, (os_view_de) 
17a2 cd 0d 19			call display_dump_at_hl 
17a5			 
17a5 18 68			jr .bpschk 
17a7 fe 34		.bps4:  cp '4' 
17a9 20 08			jr nz, .bps5 
17ab			 
17ab			        ; display bc 
17ab 2a 06 ee			ld hl, (os_view_bc) 
17ae cd 0d 19			call display_dump_at_hl 
17b1			 
17b1 18 5c			jr .bpschk 
17b3 fe 35		.bps5:  cp '5' 
17b5 20 08		        jr nz, .bps7 
17b7			 
17b7				; display cur ptr 
17b7 2a 28 f8			ld hl, (cli_ptr) 
17ba cd 0d 19			call display_dump_at_hl 
17bd			 
17bd 18 50			jr .bpschk 
17bf fe 36		.bps7:  cp '6' 
17c1 20 08			jr nz, .bps8b 
17c3				 
17c3				; display cur orig ptr 
17c3 2a 26 f8			ld hl, (cli_origptr) 
17c6 cd 0d 19			call display_dump_at_hl 
17c9 18 44			jr .bpschk 
17cb fe 37		.bps8b:  cp '7' 
17cd 20 08			jr nz, .bps9 
17cf				 
17cf				; display dsp 
17cf 2a 0a f8			ld hl, (cli_data_sp) 
17d2 cd 0d 19			call display_dump_at_hl 
17d5			 
17d5 18 38			jr .bpschk 
17d7 fe 39		.bps9:  cp '9' 
17d9 20 05			jr nz, .bps8c 
17db				 
17db				; display SP 
17db			;	ld hl, sp 
17db cd 0d 19			call display_dump_at_hl 
17de			 
17de 18 2f			jr .bpschk 
17e0 fe 38		.bps8c:  cp '8' 
17e2 20 08			jr nz, .bps8d 
17e4				 
17e4				; display rsp 
17e4 2a 0e f8			ld hl, (cli_ret_sp) 
17e7 cd 0d 19			call display_dump_at_hl 
17ea			 
17ea 18 23			jr .bpschk 
17ec fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17ee 20 05			jr nz, .bps8 
17f0 cd 47 1a			call monitor 
17f3			 
17f3 18 1a			jr .bpschk 
17f5 fe 30		.bps8:  cp '0' 
17f7 20 16			jr nz, .bpschk 
17f9			 
17f9 21 1c fa				ld hl, display_fb1 
17fc 22 d8 f8				ld (display_fb_active), hl 
17ff cd fb 0a				call update_display 
1802			 
1802				;ld a, (os_view_af) 
1802 2a 0a ee			ld hl, (os_view_hl) 
1805 ed 5b 08 ee		ld de, (os_view_de) 
1809 ed 4b 06 ee		ld bc, (os_view_bc) 
180d f1				pop af 
180e c9				ret 
180f			 
180f			.bpschk:   
180f cd 58 0a			call delay1s 
1812 3e 9f		ld a,display_row_4 + display_cols - 1 
1814 11 4f 1c		        ld de, endprg 
1817 cd eb 0a			call str_at_display 
181a cd fb 0a			call update_display 
181d cd ca 68			call cin_wait 
1820			 
1820 c3 70 17			jp .bps1 
1823			 
1823			 
1823			display_reg_state: 
1823			 
1823				; to restore afterwards 
1823			 
1823 d5				push de 
1824 c5				push bc 
1825 e5				push hl 
1826 f5				push af 
1827			 
1827				; for use in here 
1827			 
1827 c5				push bc 
1828 d5				push de 
1829 e5				push hl 
182a f5				push af 
182b			 
182b cd d8 0a			call clear_display 
182e			 
182e 11 e3 18			ld de, .regstate 
1831 3e 00			ld a, display_row_1 
1833 cd eb 0a			call str_at_display 
1836			 
1836				; display debug step 
1836			 
1836			 
1836 11 77 fb			ld de, debug_mark 
1839 3e 25			ld a, display_row_1+display_cols-3 
183b cd eb 0a			call str_at_display 
183e			 
183e				; display a 
183e 11 ff 18			ld de, .regstatea 
1841 3e 28			ld a, display_row_2 
1843 cd eb 0a			call str_at_display 
1846			 
1846 e1				pop hl 
1847			;	ld h,0 
1847			;	ld l, a 
1847 3e 2b			ld a, display_row_2+3 
1849 cd ce 16			call display_word_at 
184c			 
184c			 
184c				; display hl 
184c			 
184c			 
184c 11 f3 18			ld de, .regstatehl 
184f 3e 32			ld a, display_row_2+10 
1851 cd eb 0a			call str_at_display 
1854			 
1854 e1				pop hl 
1855 3e 35			ld a, display_row_2+13 
1857 cd ce 16			call display_word_at 
185a			 
185a				 
185a				; display de 
185a			 
185a 11 f7 18			ld de, .regstatede 
185d 3e 50			ld a, display_row_3 
185f cd eb 0a			call str_at_display 
1862			 
1862 e1				pop hl 
1863			;	ld h,d 
1863			;	ld l, e 
1863 3e 53			ld a, display_row_3+3 
1865 cd ce 16			call display_word_at 
1868			 
1868			 
1868				; display bc 
1868			 
1868 11 fb 18			ld de, .regstatebc 
186b 3e 5a			ld a, display_row_3+10 
186d cd eb 0a			call str_at_display 
1870			 
1870 e1				pop hl 
1871			;	ld h,b 
1871			;	ld l, c 
1871 3e 5d			ld a, display_row_3+13 
1873 cd ce 16			call display_word_at 
1876			 
1876			 
1876				; display dsp 
1876			 
1876 11 03 19			ld de, .regstatedsp 
1879 3e 78			ld a, display_row_4 
187b cd eb 0a			call str_at_display 
187e			 
187e				 
187e 2a 0a f8			ld hl,(cli_data_sp) 
1881 3e 7c			ld a, display_row_4+4 
1883 cd ce 16			call display_word_at 
1886			 
1886				; display rsp 
1886			 
1886 11 08 19			ld de, .regstatersp 
1889 3e 82			ld a, display_row_4+10 
188b cd eb 0a			call str_at_display 
188e			 
188e				 
188e 2a 0e f8			ld hl,(cli_ret_sp) 
1891 3e 86			ld a, display_row_4+14 
1893 cd ce 16			call display_word_at 
1896			 
1896 cd fb 0a			call update_display 
1899			 
1899			;	call delay1s 
1899			;	call delay1s 
1899			;	call delay1s 
1899			 
1899			 
1899			;	call next_page_prompt 
1899			 
1899				; restore  
1899			 
1899 f1				pop af 
189a e1				pop hl 
189b c1				pop bc 
189c d1				pop de 
189d c9				ret 
189e			 
189e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18b2 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18c7 .. 00		.ptrstate:	db "Ptr State",0 
18d1 .. 00		.ptrcliptr:     db "cli_ptr",0 
18d9 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18e3 .. 00		.regstate:	db "Reg State (1/0)",0 
18f3 .. 00		.regstatehl:	db "HL:",0 
18f7 .. 00		.regstatede:	db "DE:",0 
18fb .. 00		.regstatebc:	db "BC:",0 
18ff .. 00		.regstatea:	db "A :",0 
1903 .. 00		.regstatedsp:	db "DSP:",0 
1908 .. 00		.regstatersp:	db "RSP:",0 
190d			 
190d			display_dump_at_hl: 
190d e5				push hl 
190e d5				push de 
190f c5				push bc 
1910 f5				push af 
1911			 
1911 22 40 f1			ld (os_cur_ptr),hl	 
1914 cd d8 0a			call clear_display 
1917 cd 59 1b			call dumpcont 
191a			;	call delay1s 
191a			;	call next_page_prompt 
191a			 
191a			 
191a f1				pop af 
191b c1				pop bc 
191c d1				pop de 
191d e1				pop hl 
191e c9				ret 
191f			 
191f			;if ENABLE_BASIC 
191f			;	include "nascombasic.asm" 
191f			;	basic: 
191f			;	include "forth/FORTH.ASM" 
191f			;endif 
191f			 
191f			; eof 
191f			 
191f			 
# End of file firmware_diags.asm
191f			  
191f			  
191f			  
191f			  
191f			; eof  
191f			  
# End of file firmware.asm
191f			 
191f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
191f			;if BASE_KEV  
191f			;baseram: equ 08000h 
191f			;endif 
191f			 
191f			;if BASE_SC114 
191f			;baseram:     equ    endofcode 
191f			;endif 
191f			 
191f			 
191f			; start system 
191f			 
191f			coldstart: 
191f				; set sp 
191f				; di/ei 
191f			 
191f f3				di 
1920 31 fd ff			ld sp, tos 
1923			;	ei 
1923			 
1923			 
1923				; disable breakpoint by default 
1923			 
1923 3e 2a			ld a,'*' 
1925 32 0e ee			ld (os_view_disable),a 
1928			 
1928				; init hardware 
1928			 
1928				; init keyboard and screen hardware 
1928			 
1928 cd 03 00			call hardware_init 
192b			 
192b			 
192b				; detect if any keys are held down to enable breakpoints at start up 
192b			 
192b cd db 68			call cin  
192e fe 00			cp 0 
1930 28 03			jr z, .nokeys 
1932			 
1932				;call hardware_diags 
1932 cd 96 13			call config 
1935			 
1935			;	ld de, .bpen 
1935			;	ld a, display_row_4 
1935			;	call str_at_display 
1935			;	call update_display 
1935			; 
1935			;	ld a,0 
1935			;	ld (os_view_disable),a 
1935			; 
1935			;.bpwait: 
1935			;	call cin 
1935			;	cp 0 
1935			;	jr z, .bpwait 
1935			;	jr .nokeys 
1935			; 
1935			; 
1935			;.bpen:  db "Break points enabled!",0 
1935			 
1935			 
1935			 
1935			 
1935			 
1935			 
1935			.nokeys: 
1935			 
1935			 
1935				 
1935			 
1935			;jp  testkey 
1935			 
1935			;call storage_get_block_0 
1935			; 
1935			;ld hl, 0 
1935			;ld de, store_page 
1935			;call storage_read_block 
1935			 
1935				 
1935			;ld hl, 10 
1935			;ld de, store_page 
1935			;call storage_read_block 
1935			 
1935			 
1935			 
1935			 
1935			 
1935			;stop:	nop 
1935			;	jp stop 
1935			 
1935			 
1935			 
1935			main: 
1935 cd d8 0a			call clear_display 
1938 cd fb 0a			call update_display 
193b			 
193b			 
193b			 
193b			;	call testlcd 
193b			 
193b			 
193b			 
193b cd 17 20			call forth_init 
193e			 
193e			 
193e			warmstart: 
193e cd ed 1f			call forth_warmstart 
1941			 
1941				; run startup word load 
1941			        ; TODO prevent this running at warmstart after crash  
1941			 
1941				if STARTUP_ENABLE 
1941					if STORAGE_SE 
1941 cd 69 64					call forth_autoload 
1944					endif 
1944 cd 78 61				call forth_startup 
1947			 
1947			 
1947				endif 
1947			 
1947				; show free memory after boot 
1947 11 e1 19			ld de, freeram 
194a 3e 00			ld a, display_row_1 
194c cd eb 0a			call str_at_display 
194f			 
194f			; Or use heap_size word???? 
194f 21 03 ee			ld hl, heap_end 
1952 11 0e 80			ld de, heap_start 
1955 ed 52			sbc hl, de 
1957 e5				push hl 
1958 7c				ld a,h	         	 
1959 21 22 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
195c cd 0d 10			call hexout 
195f e1			   	pop hl 
1960			 
1960 7d				ld a,l 
1961 21 24 f1			ld hl, os_word_scratch+2 
1964 cd 0d 10			call hexout 
1967 21 26 f1			ld hl, os_word_scratch+4 
196a 3e 00			ld a, 0 
196c 77				ld (hl),a 
196d 11 22 f1			ld de, os_word_scratch 
1970 3e 0d			ld a, display_row_1 + 13 
1972 cd eb 0a			call str_at_display 
1975 cd fb 0a			call update_display 
1978			 
1978			 
1978				;call demo 
1978			 
1978			 
1978				; init scratch input area for cli commands 
1978			 
1978 21 44 f1			ld hl, os_cli_cmd 
197b 3e 00			ld a,0 
197d 77				ld (hl),a 
197e 23				inc hl 
197f 77				ld (hl),a 
1980			 
1980 3e 00			ld a,0 
1982 32 43 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1985			 
1985 32 40 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1988 32 41 f1			ld (os_cur_ptr+1),a	 
198b			 
198b 32 22 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
198e 32 23 f1			ld (os_word_scratch+1),a	 
1991				 
1991			 
1991				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1991 21 44 f1			ld hl, os_cli_cmd 
1994			 
1994 3e 00			ld a, 0		 ; init cli input 
1996 77				ld (hl), a 
1997 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1999			cli: 
1999				; show cli prompt 
1999				;push af 
1999				;ld a, 0 
1999				;ld de, prompt 
1999				;call str_at_display 
1999			 
1999				;call update_display 
1999				;pop af 
1999				;inc a 
1999				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1999 0e 00			ld c, 0 
199b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
199d 1e 28			ld e, 40 
199f			 
199f 21 44 f1			ld hl, os_cli_cmd 
19a2			 
19a2				STACKFRAME OFF $fefe $9f9f 
19a2				if DEBUG_STACK_IMB 
19a2					if OFF 
19a2						exx 
19a2						ld de, $fefe 
19a2						ld a, d 
19a2						ld hl, curframe 
19a2						call hexout 
19a2						ld a, e 
19a2						ld hl, curframe+2 
19a2						call hexout 
19a2						ld hl, $fefe 
19a2						push hl 
19a2						ld hl, $9f9f 
19a2						push hl 
19a2						exx 
19a2					endif 
19a2				endif 
19a2			endm 
# End of macro STACKFRAME
19a2			 
19a2 cd 39 0d			call input_str 
19a5			 
19a5				STACKFRAMECHK OFF $fefe $9f9f 
19a5				if DEBUG_STACK_IMB 
19a5					if OFF 
19a5						exx 
19a5						ld hl, $9f9f 
19a5						pop de   ; $9f9f 
19a5						call cmp16 
19a5						jr nz, .spnosame 
19a5						ld hl, $fefe 
19a5						pop de   ; $fefe 
19a5						call cmp16 
19a5						jr z, .spfrsame 
19a5						.spnosame: call showsperror 
19a5						.spfrsame: nop 
19a5						exx 
19a5					endif 
19a5				endif 
19a5			endm 
# End of macro STACKFRAMECHK
19a5			 
19a5				; copy input to last command 
19a5			 
19a5 21 44 f1			ld hl, os_cli_cmd 
19a8 11 43 f2			ld de, os_last_cmd 
19ab 01 ff 00			ld bc, 255 
19ae ed b0			ldir 
19b0			 
19b0				; wipe current buffer 
19b0			 
19b0			;	ld a, 0 
19b0			;	ld hl, os_cli_cmd 
19b0			;	ld de, os_cli_cmd+1 
19b0			;	ld bc, 254 
19b0			;	ldir 
19b0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19b0			;	call strcpy 
19b0			;	ld a, 0 
19b0			;	ld (hl), a 
19b0			;	inc hl 
19b0			;	ld (hl), a 
19b0			;	inc hl 
19b0			;	ld (hl), a 
19b0			 
19b0				; switch frame buffer to program  
19b0			 
19b0 21 1c fa				ld hl, display_fb1 
19b3 22 d8 f8				ld (display_fb_active), hl 
19b6			 
19b6			;	nop 
19b6				STACKFRAME ON $fbfe $8f9f 
19b6				if DEBUG_STACK_IMB 
19b6					if ON 
19b6						exx 
19b6						ld de, $fbfe 
19b6						ld a, d 
19b6						ld hl, curframe 
19b6						call hexout 
19b6						ld a, e 
19b6						ld hl, curframe+2 
19b6						call hexout 
19b6						ld hl, $fbfe 
19b6						push hl 
19b6						ld hl, $8f9f 
19b6						push hl 
19b6						exx 
19b6					endif 
19b6				endif 
19b6			endm 
# End of macro STACKFRAME
19b6				; first time into the parser so pass over the current scratch pad 
19b6 21 44 f1			ld hl,os_cli_cmd 
19b9				; tokenise the entered statement(s) in HL 
19b9 cd 90 20			call forthparse 
19bc			        ; exec forth statements in top of return stack 
19bc cd d0 20			call forthexec 
19bf				;call forthexec_cleanup 
19bf			;	call parsenext 
19bf			 
19bf				STACKFRAMECHK ON $fbfe $8f9f 
19bf				if DEBUG_STACK_IMB 
19bf					if ON 
19bf						exx 
19bf						ld hl, $8f9f 
19bf						pop de   ; $8f9f 
19bf						call cmp16 
19bf						jr nz, .spnosame 
19bf						ld hl, $fbfe 
19bf						pop de   ; $fbfe 
19bf						call cmp16 
19bf						jr z, .spfrsame 
19bf						.spnosame: call showsperror 
19bf						.spfrsame: nop 
19bf						exx 
19bf					endif 
19bf				endif 
19bf			endm 
# End of macro STACKFRAMECHK
19bf				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19bf			 
19bf 3e 78			ld a, display_row_4 
19c1 11 f3 19			ld de, endprog 
19c4			 
19c4 cd fb 0a			call update_display		 
19c7			 
19c7 cd 51 1c			call next_page_prompt 
19ca			 
19ca				; switch frame buffer to cli 
19ca			 
19ca 21 bd fa				ld hl, display_fb0 
19cd 22 d8 f8				ld (display_fb_active), hl 
19d0			 
19d0			 
19d0 cd d8 0a		        call clear_display 
19d3 cd fb 0a			call update_display		 
19d6			 
19d6 21 44 f1			ld hl, os_cli_cmd 
19d9			 
19d9 3e 00			ld a, 0		 ; init cli input 
19db 77				ld (hl), a 
19dc			 
19dc				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
19dc			 
19dc				; now on last line 
19dc			 
19dc				; TODO scroll screen up 
19dc			 
19dc				; TODO instead just clear screen and place at top of screen 
19dc			 
19dc			;	ld a, 0 
19dc			;	ld (f_cursor_ptr),a 
19dc			 
19dc				;call clear_display 
19dc				;call update_display 
19dc			 
19dc				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19dc 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19de c3 99 19			jp cli 
19e1			 
19e1 .. 00		freeram: db "Free bytes: $",0 
19ef ..			asc: db "1A2F" 
19f3 .. 00		endprog: db "End prog...",0 
19ff			 
19ff			testenter2:   
19ff 21 4f ee			ld hl,scratch+50 
1a02 22 40 f1			ld (os_cur_ptr),hl 
1a05 c3 99 19			jp cli 
1a08			 
1a08			testenter:  
1a08			 
1a08 21 ef 19			ld hl,asc 
1a0b			;	ld a,(hl) 
1a0b			;	call nibble2val 
1a0b cd 63 10			call get_byte 
1a0e			 
1a0e			 
1a0e			;	ld a,(hl) 
1a0e			;	call atohex 
1a0e			 
1a0e			;	call fourehexhl 
1a0e 32 4f ee			ld (scratch+50),a 
1a11			 
1a11			 
1a11			 
1a11 21 f1 19			ld hl,asc+2 
1a14			;	ld a, (hl) 
1a14			;	call nibble2val 
1a14 cd 63 10			call get_byte 
1a17			 
1a17			;	call fourehexhl 
1a17 32 51 ee			ld (scratch+52),a 
1a1a				 
1a1a 21 4f ee			ld hl,scratch+50 
1a1d 22 40 f1			ld (os_cur_ptr),hl 
1a20 c3 99 19			jp cli 
1a23			 
1a23			enter:	 
1a23 3a 21 ee			ld a,(scratch+4) 
1a26 fe 00			cp 0 
1a28 28 0c			jr z, .entercont 
1a2a				; no, not a null term line so has an address to work out.... 
1a2a			 
1a2a 21 1f ee			ld hl,scratch+2 
1a2d cd c3 10			call get_word_hl 
1a30			 
1a30 22 40 f1			ld (os_cur_ptr),hl	 
1a33 c3 99 19			jp cli 
1a36			 
1a36			 
1a36			.entercont:  
1a36			 
1a36 21 1f ee			ld hl, scratch+2 
1a39 cd 63 10			call get_byte 
1a3c			 
1a3c 2a 40 f1		   	ld hl,(os_cur_ptr) 
1a3f 77					ld (hl),a 
1a40 23					inc hl 
1a41 22 40 f1				ld (os_cur_ptr),hl 
1a44				 
1a44			; get byte  
1a44			 
1a44			 
1a44 c3 99 19			jp cli 
1a47			 
1a47			 
1a47			; basic monitor support 
1a47			 
1a47			monitor: 
1a47				;  
1a47 cd d8 0a			call clear_display 
1a4a 3e 00			ld a, 0 
1a4c 11 94 1a			ld de, .monprompt 
1a4f cd eb 0a			call str_at_display 
1a52 cd fb 0a			call update_display 
1a55			 
1a55				; get a monitor command 
1a55			 
1a55 0e 00			ld c, 0     ; entry at top left 
1a57 16 64			ld d, 100   ; max buffer size 
1a59 1e 0f			ld e, 15    ; input scroll area 
1a5b 3e 00			ld a, 0     ; init string 
1a5d 21 1b f0			ld hl, os_input 
1a60 77				ld (hl), a 
1a61 23				inc hl 
1a62 77				ld (hl), a 
1a63 21 1b f0			ld hl, os_input 
1a66 3e 01			ld a, 1     ; init string 
1a68 cd 39 0d			call input_str 
1a6b			 
1a6b cd d8 0a		        call clear_display 
1a6e cd fb 0a			call update_display		 
1a71			 
1a71 3a 1b f0			ld a, (os_input) 
1a74 cd 61 11			call toUpper 
1a77 fe 48		        cp 'H' 
1a79 28 6f		        jr z, .monhelp 
1a7b fe 44			cp 'D'		; dump 
1a7d ca 0b 1b			jp z, .mondump	 
1a80 fe 43			cp 'C'		; dump 
1a82 ca 25 1b			jp z, .moncdump	 
1a85 fe 4d			cp 'M'		; dump 
1a87 ca 96 1a			jp z, .moneditstart 
1a8a fe 55			cp 'U'		; dump 
1a8c 28 14			jr z, .monedit	 
1a8e fe 51			cp 'Q'		; dump 
1a90 c8				ret z	 
1a91			 
1a91			 
1a91				; TODO "S" to access symbol by name and not need the address 
1a91				; TODO "F" to find a string in memory 
1a91			 
1a91 c3 47 1a			jp monitor 
1a94			 
1a94 .. 00		.monprompt: db ">", 0 
1a96			 
1a96			.moneditstart: 
1a96				; get starting address 
1a96			 
1a96 21 1d f0			ld hl,os_input+2 
1a99 cd c3 10			call get_word_hl 
1a9c			 
1a9c 22 40 f1			ld (os_cur_ptr),hl	 
1a9f			 
1a9f c3 47 1a			jp monitor 
1aa2			 
1aa2			.monedit: 
1aa2				; get byte to load 
1aa2			 
1aa2 21 1d f0			ld hl,os_input+2 
1aa5 cd 63 10			call get_byte 
1aa8			 
1aa8				; get address to update 
1aa8 2a 40 f1			ld hl, (os_cur_ptr) 
1aab			 
1aab				; update byte 
1aab			 
1aab 77				ld (hl), a 
1aac			 
1aac				; move to next address and save it 
1aac			 
1aac 23				inc hl 
1aad 22 40 f1			ld (os_cur_ptr),hl	 
1ab0			 
1ab0 c3 47 1a			jp monitor 
1ab3			 
1ab3			 
1ab3 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ac7 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ae3 .. 00		.monhelptext3:  db "Q-Quit",0 
1aea			        
1aea			.monhelp: 
1aea 3e 00			ld a, display_row_1 
1aec 11 b3 1a		        ld de, .monhelptext1 
1aef			 
1aef cd eb 0a			call str_at_display 
1af2 3e 28			ld a, display_row_2 
1af4 11 c7 1a		        ld de, .monhelptext2 
1af7					 
1af7 cd eb 0a			call str_at_display 
1afa 3e 50			ld a, display_row_3 
1afc 11 e3 1a		        ld de, .monhelptext3 
1aff					 
1aff cd eb 0a			call str_at_display 
1b02 cd fb 0a			call update_display		 
1b05			 
1b05 cd 51 1c			call next_page_prompt 
1b08 c3 47 1a			jp monitor 
1b0b			 
1b0b			.mondump:    
1b0b 21 1d f0			ld hl,os_input+2 
1b0e cd c3 10			call get_word_hl 
1b11			 
1b11 22 40 f1			ld (os_cur_ptr),hl	 
1b14 cd 59 1b			call dumpcont 
1b17 3e 78			ld a, display_row_4 
1b19 11 f3 19			ld de, endprog 
1b1c			 
1b1c cd fb 0a			call update_display		 
1b1f			 
1b1f cd 51 1c			call next_page_prompt 
1b22 c3 47 1a			jp monitor 
1b25			.moncdump: 
1b25 cd 59 1b			call dumpcont 
1b28 3e 78			ld a, display_row_4 
1b2a 11 f3 19			ld de, endprog 
1b2d			 
1b2d cd fb 0a			call update_display		 
1b30			 
1b30 cd 51 1c			call next_page_prompt 
1b33 c3 47 1a			jp monitor 
1b36			 
1b36			 
1b36			; TODO symbol access  
1b36			 
1b36			.symbols:     ;; A list of symbols that can be called up  
1b36 bd fa			dw display_fb0 
1b38 .. 00			db "fb0",0  
1b3c 62 f8		     	dw store_page 
1b3e .. 00			db "store_page",0 
1b49			 
1b49			 
1b49			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b49			 
1b49 3a 1e ee			ld a,(scratch+1) 
1b4c fe 00			cp 0 
1b4e 28 09			jr z, dumpcont 
1b50			 
1b50				; no, not a null term line so has an address to work out.... 
1b50			 
1b50 21 1f ee			ld hl,scratch+2 
1b53 cd c3 10			call get_word_hl 
1b56			 
1b56 22 40 f1			ld (os_cur_ptr),hl	 
1b59			 
1b59			 
1b59			 
1b59			dumpcont: 
1b59			 
1b59				; dump bytes at ptr 
1b59			 
1b59			 
1b59 3e 00			ld a, display_row_1 
1b5b 2a d8 f8			ld hl, (display_fb_active) 
1b5e cd 0c 0d			call addatohl 
1b61 cd 89 1b			call .dumpbyterow 
1b64			 
1b64 3e 28			ld a, display_row_2 
1b66 2a d8 f8			ld hl, (display_fb_active) 
1b69 cd 0c 0d			call addatohl 
1b6c cd 89 1b			call .dumpbyterow 
1b6f			 
1b6f			 
1b6f 3e 50			ld a, display_row_3 
1b71 2a d8 f8			ld hl, (display_fb_active) 
1b74 cd 0c 0d			call addatohl 
1b77 cd 89 1b			call .dumpbyterow 
1b7a			 
1b7a 3e 78			ld a, display_row_4 
1b7c 2a d8 f8			ld hl, (display_fb_active) 
1b7f cd 0c 0d			call addatohl 
1b82 cd 89 1b			call .dumpbyterow 
1b85			 
1b85 cd fb 0a			call update_display 
1b88			;		jp cli 
1b88 c9				ret 
1b89			 
1b89			.dumpbyterow: 
1b89			 
1b89				;push af 
1b89			 
1b89 e5				push hl 
1b8a			 
1b8a				; calc where to poke the ascii 
1b8a			if display_cols == 20 
1b8a				ld a, 16 
1b8a			else 
1b8a 3e 1f			ld a, 31 
1b8c			endif 
1b8c			 
1b8c cd 0c 0d			call addatohl 
1b8f 22 22 f1			ld (os_word_scratch),hl  		; save pos for later 
1b92			 
1b92			 
1b92			; display decoding address 
1b92 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b95			 
1b95 7c				ld a,h 
1b96 e1				pop hl 
1b97 e5				push hl 
1b98			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b98 cd 0d 10			call hexout 
1b9b 2a 40 f1		   	ld hl,(os_cur_ptr) 
1b9e			 
1b9e 7d				ld a,l 
1b9f e1				pop hl 
1ba0 23				inc hl 
1ba1 23				inc hl 
1ba2 e5				push hl 
1ba3			;	ld hl, os_word_scratch+2 
1ba3 cd 0d 10			call hexout 
1ba6 e1				pop hl 
1ba7 23				inc hl 
1ba8 23				inc hl 
1ba9				;ld hl, os_word_scratch+4 
1ba9 3e 3a			ld a, ':' 
1bab 77				ld (hl),a 
1bac 23				inc hl 
1bad				;ld a, 0 
1bad				;ld (hl),a 
1bad				;ld de, os_word_scratch 
1bad				;pop af 
1bad				;push af 
1bad			;		ld a, display_row_2 
1bad			;		call str_at_display 
1bad			;		call update_display 
1bad			 
1bad			 
1bad			;pop af 
1bad			;	add 5 
1bad			 
1bad			if display_cols == 20 
1bad				ld b, 4 
1bad			else 
1bad 06 08			ld b, 8 
1baf			endif	 
1baf			 
1baf			.dumpbyte: 
1baf c5				push bc 
1bb0 e5				push hl 
1bb1			 
1bb1			 
1bb1 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bb4 7e					ld a,(hl) 
1bb5			 
1bb5					; poke the ascii to display 
1bb5 2a 22 f1				ld hl,(os_word_scratch) 
1bb8 77					ld (hl),a 
1bb9 23					inc hl 
1bba 22 22 f1				ld (os_word_scratch),hl 
1bbd			 
1bbd					 
1bbd			 
1bbd			 
1bbd e1					pop hl 
1bbe e5					push hl 
1bbf			 
1bbf cd 0d 10				call hexout 
1bc2			 
1bc2					 
1bc2 2a 40 f1		   	ld hl,(os_cur_ptr) 
1bc5 23				inc hl 
1bc6 22 40 f1		   	ld (os_cur_ptr),hl 
1bc9			 
1bc9 e1					pop hl 
1bca 23					inc hl 
1bcb 23					inc hl 
1bcc 23					inc hl 
1bcd			 
1bcd			 
1bcd			 
1bcd					;ld a,0 
1bcd					;ld (os_word_scratch+2),a 
1bcd					;pop af 
1bcd					;push af 
1bcd			 
1bcd					;ld de, os_word_scratch 
1bcd					;call str_at_display 
1bcd			;		call update_display 
1bcd			;		pop af 
1bcd c1					pop bc 
1bce c6 03				add 3 
1bd0 10 dd			djnz .dumpbyte 
1bd2			 
1bd2				 
1bd2			 
1bd2 c9				ret 
1bd3			 
1bd3			jump:	 
1bd3			 
1bd3 21 1f ee			ld hl,scratch+2 
1bd6 cd c3 10			call get_word_hl 
1bd9				;ld hl,(scratch+2) 
1bd9				;call fourehexhl 
1bd9			 
1bd9 22 40 f1			ld (os_cur_ptr),hl	 
1bdc			 
1bdc e9				jp (hl) 
1bdd			 
1bdd			 
1bdd			 
1bdd			; TODO implement a basic monitor mode to start with 
1bdd			 
1bdd			 
1bdd			 
1bdd			 
1bdd			 
1bdd			 
1bdd			 
1bdd			 
1bdd			 
1bdd			; testing and demo code during development 
1bdd			 
1bdd			 
1bdd .. 00		str1: db "Enter some text...",0 
1bf0 .. 00		clear: db "                    ",0 
1c05			 
1c05			demo: 
1c05			 
1c05			 
1c05			 
1c05			;	call update_display 
1c05			 
1c05				; init scratch input area for testing 
1c05 21 1d ee			ld hl, scratch	 
1c08 3e 00			ld a,0 
1c0a 77				ld (hl),a 
1c0b			 
1c0b			 
1c0b 3e 28		            LD   A, display_row_2 
1c0d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c0d 11 dd 1b		            LD   DE, str1 
1c10 cd eb 0a			call str_at_display 
1c13			 
1c13			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c13			cloop:	 
1c13 3e 50		            LD   A, display_row_3 
1c15			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c15 11 f0 1b		            LD   DE, clear 
1c18			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c18 cd eb 0a				call str_at_display 
1c1b 3e 78			ld a, display_row_4 
1c1d 11 4d 1c			ld de, prompt 
1c20			 
1c20 cd eb 0a				call str_at_display 
1c23 cd fb 0a			call update_display 
1c26			 
1c26 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c28 16 0a			ld d, 10 
1c2a 21 1d ee			ld hl, scratch	 
1c2d cd 39 0d			call input_str 
1c30			 
1c30			;	call clear_display 
1c30			;'	call update_display 
1c30			 
1c30 3e 00		            LD   A, display_row_1 
1c32			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c32 11 f0 1b		            LD   DE, clear 
1c35 cd eb 0a				call str_at_display 
1c38			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c38 3e 00		            LD   A, display_row_1 
1c3a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c3a 11 1d ee		            LD   DE, scratch 
1c3d			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c3d cd eb 0a				call str_at_display 
1c40 cd fb 0a			call update_display 
1c43			 
1c43 3e 00				ld a,0 
1c45 21 1d ee			ld hl, scratch 
1c48 77				ld (hl),a 
1c49			 
1c49 00				nop 
1c4a c3 13 1c			jp cloop 
1c4d			 
1c4d			 
1c4d			 
1c4d			; OS Prompt 
1c4d			 
1c4d .. 00		prompt: db ">",0 
1c4f .. 00		endprg: db "?",0 
1c51			 
1c51			 
1c51			; handy next page prompt 
1c51			next_page_prompt: 
1c51 e5				push hl 
1c52 d5				push de 
1c53 f5				push af 
1c54 c5				push bc 
1c55			 
1c55 3e 9f			ld a,display_row_4 + display_cols - 1 
1c57 11 4f 1c		        ld de, endprg 
1c5a cd eb 0a			call str_at_display 
1c5d cd fb 0a			call update_display 
1c60 cd ca 68			call cin_wait 
1c63 c1				pop bc 
1c64 f1				pop af 
1c65 d1				pop de 
1c66 e1				pop hl 
1c67			 
1c67			 
1c67 c9				ret 
1c68			 
1c68			 
1c68			; forth parser 
1c68			 
1c68			; My forth kernel 
1c68			include "forth_kernel.asm" 
1c68			; 
1c68			; kernel to the forth OS 
1c68			 
1c68			DS_TYPE_STR: equ 1     ; string type 
1c68			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c68			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c68			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c68			 
1c68			FORTH_PARSEV1: equ 0 
1c68			FORTH_PARSEV2: equ 0 
1c68			FORTH_PARSEV3: equ 0 
1c68			FORTH_PARSEV4: equ 0 
1c68			FORTH_PARSEV5: equ 1 
1c68			 
1c68			;if FORTH_PARSEV5 
1c68			;	FORTH_END_BUFFER: equ 0 
1c68			;else 
1c68			FORTH_END_BUFFER: equ 127 
1c68			;endif 
1c68			 
1c68			FORTH_TRUE: equ 1 
1c68			FORTH_FALSE: equ 0 
1c68			 
1c68			if FORTH_PARSEV4 
1c68			include "forth_stackops.asm" 
1c68			endif 
1c68			 
1c68			if FORTH_PARSEV5 
1c68			include "forth_stackopsv5.asm" 
1c68			 
1c68			; Stack operations for v5 parser on wards 
1c68			; * DATA stack 
1c68			; * LOOP stack 
1c68			; * RETURN stack 
1c68			 
1c68			 
1c68			 
1c68			FORTH_CHK_DSP_UNDER: macro 
1c68				push hl 
1c68				push de 
1c68				ld hl,(cli_data_sp) 
1c68				ld de, cli_data_stack 
1c68				call cmp16 
1c68				jp c, fault_dsp_under 
1c68				pop de 
1c68				pop hl 
1c68				endm 
1c68			 
1c68			 
1c68			FORTH_CHK_RSP_UNDER: macro 
1c68				push hl 
1c68				push de 
1c68				ld hl,(cli_ret_sp) 
1c68				ld de, cli_ret_stack 
1c68				call cmp16 
1c68				jp c, fault_rsp_under 
1c68				pop de 
1c68				pop hl 
1c68				endm 
1c68			 
1c68			FORTH_CHK_LOOP_UNDER: macro 
1c68				push hl 
1c68				push de 
1c68				ld hl,(cli_loop_sp) 
1c68				ld de, cli_loop_stack 
1c68				call cmp16 
1c68				jp c, fault_loop_under 
1c68				pop de 
1c68				pop hl 
1c68				endm 
1c68			 
1c68			FORTH_ERR_TOS_NOTSTR: macro 
1c68				; TOSO might need more for checks when used 
1c68				push af 
1c68				ld a,(hl) 
1c68				cp DS_TYPE_STR 
1c68				jp nz, type_faultn   
1c68				pop af 
1c68				endm 
1c68			 
1c68			FORTH_ERR_TOS_NOTNUM: macro 
1c68				push af 
1c68				ld a,(hl) 
1c68				cp DS_TYPE_INUM 
1c68				jp nz, type_faultn   
1c68				pop af 
1c68				endm 
1c68			 
1c68			 
1c68			; increase data stack pointer and save hl to it 
1c68				 
1c68			FORTH_DSP_NEXT: macro 
1c68				call macro_forth_dsp_next 
1c68				endm 
1c68			 
1c68			 
1c68			macro_forth_dsp_next: 
1c68				if DEBUG_FORTH_STACK_GUARD 
1c68 cd 42 62				call check_stacks 
1c6b				endif 
1c6b e5				push hl 
1c6c d5				push de 
1c6d eb				ex de,hl 
1c6e 2a 0a f8			ld hl,(cli_data_sp) 
1c71 23				inc hl 
1c72 23				inc hl 
1c73			 
1c73			; PARSEV5 
1c73 23				inc hl 
1c74 22 0a f8			ld (cli_data_sp),hl 
1c77 73				ld (hl), e 
1c78 23				inc hl 
1c79 72				ld (hl), d 
1c7a d1				pop de 
1c7b e1				pop hl 
1c7c				if DEBUG_FORTH_STACK_GUARD 
1c7c cd 42 62				call check_stacks 
1c7f				endif 
1c7f c9				ret 
1c80			 
1c80			 
1c80			; increase ret stack pointer and save hl to it 
1c80				 
1c80			FORTH_RSP_NEXT: macro 
1c80				call macro_forth_rsp_next 
1c80				endm 
1c80			 
1c80			macro_forth_rsp_next: 
1c80				if DEBUG_FORTH_STACK_GUARD 
1c80 cd 42 62				call check_stacks 
1c83				endif 
1c83 e5				push hl 
1c84 d5				push de 
1c85 eb				ex de,hl 
1c86 2a 0e f8			ld hl,(cli_ret_sp) 
1c89 23				inc hl 
1c8a 23				inc hl 
1c8b 22 0e f8			ld (cli_ret_sp),hl 
1c8e 73				ld (hl), e 
1c8f 23				inc hl 
1c90 72				ld (hl), d 
1c91 d1				pop de 
1c92 e1				pop hl 
1c93				if DEBUG_FORTH_STACK_GUARD 
1c93 cd 42 62				call check_stacks 
1c96				endif 
1c96 c9				ret 
1c97			 
1c97			; get current ret stack pointer and save to hl  
1c97				 
1c97			FORTH_RSP_TOS: macro 
1c97				call macro_forth_rsp_tos 
1c97				endm 
1c97			 
1c97			macro_forth_rsp_tos: 
1c97				;push de 
1c97 2a 0e f8			ld hl,(cli_ret_sp) 
1c9a cd d2 1c			call loadhlptrtohl 
1c9d				;ld e, (hl) 
1c9d				;inc hl 
1c9d				;ld d, (hl) 
1c9d				;ex de, hl 
1c9d					if DEBUG_FORTH_WORDS 
1c9d			;			DMARK "RST" 
1c9d						CALLMONITOR 
1c9d cd 49 17			call break_point_state  
1ca0				endm  
# End of macro CALLMONITOR
1ca0					endif 
1ca0				;pop de 
1ca0 c9				ret 
1ca1			 
1ca1			; pop ret stack pointer 
1ca1				 
1ca1			FORTH_RSP_POP: macro 
1ca1				call macro_forth_rsp_pop 
1ca1				endm 
1ca1			 
1ca1			 
1ca1			macro_forth_rsp_pop: 
1ca1				if DEBUG_FORTH_STACK_GUARD 
1ca1			;		DMARK "RPP" 
1ca1 cd 42 62				call check_stacks 
1ca4					FORTH_CHK_RSP_UNDER 
1ca4 e5				push hl 
1ca5 d5				push de 
1ca6 2a 0e f8			ld hl,(cli_ret_sp) 
1ca9 11 88 f7			ld de, cli_ret_stack 
1cac cd 2a 0d			call cmp16 
1caf da 56 63			jp c, fault_rsp_under 
1cb2 d1				pop de 
1cb3 e1				pop hl 
1cb4				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cb4				endif 
1cb4 e5				push hl 
1cb5 2a 0e f8			ld hl,(cli_ret_sp) 
1cb8			 
1cb8			 
1cb8				if FORTH_ENABLE_FREE 
1cb8			 
1cb8					; get pointer 
1cb8			 
1cb8					push de 
1cb8					push hl 
1cb8			 
1cb8					ld e, (hl) 
1cb8					inc hl 
1cb8					ld d, (hl) 
1cb8			 
1cb8					ex de, hl 
1cb8					call free 
1cb8			 
1cb8					pop hl 
1cb8					pop de 
1cb8			 
1cb8			 
1cb8				endif 
1cb8			 
1cb8			 
1cb8 2b				dec hl 
1cb9 2b				dec hl 
1cba 22 0e f8			ld (cli_ret_sp), hl 
1cbd				; do stack underflow checks 
1cbd e1				pop hl 
1cbe				if DEBUG_FORTH_STACK_GUARD 
1cbe cd 42 62				call check_stacks 
1cc1					FORTH_CHK_RSP_UNDER 
1cc1 e5				push hl 
1cc2 d5				push de 
1cc3 2a 0e f8			ld hl,(cli_ret_sp) 
1cc6 11 88 f7			ld de, cli_ret_stack 
1cc9 cd 2a 0d			call cmp16 
1ccc da 56 63			jp c, fault_rsp_under 
1ccf d1				pop de 
1cd0 e1				pop hl 
1cd1				endm 
# End of macro FORTH_CHK_RSP_UNDER
1cd1				endif 
1cd1 c9				ret 
1cd2			 
1cd2			 
1cd2			 
1cd2			; routine to load word pointed to by hl into hl 
1cd2			 
1cd2			loadhlptrtohl: 
1cd2			 
1cd2 d5				push de 
1cd3 5e				ld e, (hl) 
1cd4 23				inc hl 
1cd5 56				ld d, (hl) 
1cd6 eb				ex de, hl 
1cd7 d1				pop de 
1cd8			 
1cd8 c9				ret 
1cd9			 
1cd9			 
1cd9			 
1cd9			 
1cd9			 
1cd9			; push a number held in HL onto the data stack 
1cd9			; entry point for pushing a value when already in hl used in function above 
1cd9			 
1cd9			forth_push_numhl: 
1cd9			 
1cd9 e5				push hl    ; save value to push 
1cda			 
1cda			if DEBUG_FORTH_PUSH 
1cda				; see if disabled 
1cda			 
1cda			 
1cda f5				push af 
1cdb 3a 0e ee			ld a, (os_view_disable) 
1cde fe 2a			cp '*' 
1ce0 28 34			jr z, .pskip2 
1ce2 e5				push hl 
1ce3 e5			push hl 
1ce4 cd d8 0a			call clear_display 
1ce7 e1			pop hl 
1ce8 7c				ld a,h 
1ce9 21 22 f1			ld hl, os_word_scratch 
1cec cd 0d 10			call hexout 
1cef e1				pop hl 
1cf0 7d				ld a,l 
1cf1 21 24 f1			ld hl, os_word_scratch+2 
1cf4 cd 0d 10			call hexout 
1cf7			 
1cf7 21 26 f1			ld hl, os_word_scratch+4 
1cfa 3e 00			ld a,0 
1cfc 77				ld (hl),a 
1cfd 11 22 f1			ld de,os_word_scratch 
1d00 3e 28				ld a, display_row_2 
1d02 cd eb 0a				call str_at_display 
1d05 11 50 51			ld de, .push_num 
1d08 3e 00			ld a, display_row_1 
1d0a			 
1d0a cd eb 0a				call str_at_display 
1d0d			 
1d0d			 
1d0d cd fb 0a			call update_display 
1d10 cd 58 0a			call delay1s 
1d13 cd 58 0a			call delay1s 
1d16			.pskip2:  
1d16			 
1d16 f1				pop af 
1d17			endif	 
1d17			 
1d17			 
1d17				FORTH_DSP_NEXT 
1d17 cd 68 1c			call macro_forth_dsp_next 
1d1a				endm 
# End of macro FORTH_DSP_NEXT
1d1a			 
1d1a 2a 0a f8			ld hl, (cli_data_sp) 
1d1d			 
1d1d				; save item type 
1d1d 3e 02			ld a,  DS_TYPE_INUM 
1d1f 77				ld (hl), a 
1d20 23				inc hl 
1d21			 
1d21				; get word off stack 
1d21 d1				pop de 
1d22 7b				ld a,e 
1d23 77				ld (hl), a 
1d24 23				inc hl 
1d25 7a				ld a,d 
1d26 77				ld (hl), a 
1d27			 
1d27			if DEBUG_FORTH_PUSH 
1d27 2b				dec hl 
1d28 2b				dec hl 
1d29 2b				dec hl 
1d2a						DMARK "PH5" 
1d2a f5				push af  
1d2b 3a 3f 1d			ld a, (.dmark)  
1d2e 32 77 fb			ld (debug_mark),a  
1d31 3a 40 1d			ld a, (.dmark+1)  
1d34 32 78 fb			ld (debug_mark+1),a  
1d37 3a 41 1d			ld a, (.dmark+2)  
1d3a 32 79 fb			ld (debug_mark+2),a  
1d3d 18 03			jr .pastdmark  
1d3f ..			.dmark: db "PH5"  
1d42 f1			.pastdmark: pop af  
1d43			endm  
# End of macro DMARK
1d43				CALLMONITOR 
1d43 cd 49 17			call break_point_state  
1d46				endm  
# End of macro CALLMONITOR
1d46			endif	 
1d46			 
1d46 c9				ret 
1d47			 
1d47			 
1d47			; Push a string to stack pointed to by hl 
1d47			 
1d47			forth_push_str: 
1d47			 
1d47			if DEBUG_FORTH_PUSH 
1d47						DMARK "PSQ" 
1d47 f5				push af  
1d48 3a 5c 1d			ld a, (.dmark)  
1d4b 32 77 fb			ld (debug_mark),a  
1d4e 3a 5d 1d			ld a, (.dmark+1)  
1d51 32 78 fb			ld (debug_mark+1),a  
1d54 3a 5e 1d			ld a, (.dmark+2)  
1d57 32 79 fb			ld (debug_mark+2),a  
1d5a 18 03			jr .pastdmark  
1d5c ..			.dmark: db "PSQ"  
1d5f f1			.pastdmark: pop af  
1d60			endm  
# End of macro DMARK
1d60				CALLMONITOR 
1d60 cd 49 17			call break_point_state  
1d63				endm  
# End of macro CALLMONITOR
1d63			endif	 
1d63			    
1d63 e5				push hl 
1d64 e5				push hl 
1d65			 
1d65			;	ld a, 0   ; find end of string 
1d65 cd 6a 11			call strlenz 
1d68			if DEBUG_FORTH_PUSH 
1d68						DMARK "PQ2" 
1d68 f5				push af  
1d69 3a 7d 1d			ld a, (.dmark)  
1d6c 32 77 fb			ld (debug_mark),a  
1d6f 3a 7e 1d			ld a, (.dmark+1)  
1d72 32 78 fb			ld (debug_mark+1),a  
1d75 3a 7f 1d			ld a, (.dmark+2)  
1d78 32 79 fb			ld (debug_mark+2),a  
1d7b 18 03			jr .pastdmark  
1d7d ..			.dmark: db "PQ2"  
1d80 f1			.pastdmark: pop af  
1d81			endm  
# End of macro DMARK
1d81				CALLMONITOR 
1d81 cd 49 17			call break_point_state  
1d84				endm  
# End of macro CALLMONITOR
1d84			endif	 
1d84 eb				ex de, hl 
1d85 e1				pop hl   ; get ptr to start of string 
1d86			if DEBUG_FORTH_PUSH 
1d86						DMARK "PQ3" 
1d86 f5				push af  
1d87 3a 9b 1d			ld a, (.dmark)  
1d8a 32 77 fb			ld (debug_mark),a  
1d8d 3a 9c 1d			ld a, (.dmark+1)  
1d90 32 78 fb			ld (debug_mark+1),a  
1d93 3a 9d 1d			ld a, (.dmark+2)  
1d96 32 79 fb			ld (debug_mark+2),a  
1d99 18 03			jr .pastdmark  
1d9b ..			.dmark: db "PQ3"  
1d9e f1			.pastdmark: pop af  
1d9f			endm  
# End of macro DMARK
1d9f				CALLMONITOR 
1d9f cd 49 17			call break_point_state  
1da2				endm  
# End of macro CALLMONITOR
1da2			endif	 
1da2 19				add hl,de 
1da3			if DEBUG_FORTH_PUSH 
1da3						DMARK "PQE" 
1da3 f5				push af  
1da4 3a b8 1d			ld a, (.dmark)  
1da7 32 77 fb			ld (debug_mark),a  
1daa 3a b9 1d			ld a, (.dmark+1)  
1dad 32 78 fb			ld (debug_mark+1),a  
1db0 3a ba 1d			ld a, (.dmark+2)  
1db3 32 79 fb			ld (debug_mark+2),a  
1db6 18 03			jr .pastdmark  
1db8 ..			.dmark: db "PQE"  
1dbb f1			.pastdmark: pop af  
1dbc			endm  
# End of macro DMARK
1dbc				CALLMONITOR 
1dbc cd 49 17			call break_point_state  
1dbf				endm  
# End of macro CALLMONITOR
1dbf			endif	 
1dbf			 
1dbf 2b				dec hl    ; see if there is an optional trailing double quote 
1dc0 7e				ld a,(hl) 
1dc1 fe 22			cp '"' 
1dc3 20 03			jr nz, .strnoq 
1dc5 3e 00			ld a, 0      ; get rid of double quote 
1dc7 77				ld (hl), a 
1dc8 23			.strnoq: inc hl 
1dc9			 
1dc9 3e 00			ld a, 0 
1dcb 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1dcc			 
1dcc 13				inc de ; add one for the type string 
1dcd 13				inc de ; add one for null term??? 
1dce			 
1dce				; tos is get string pointer again 
1dce				; de contains space to allocate 
1dce				 
1dce d5				push de 
1dcf			 
1dcf eb				ex de, hl 
1dd0			 
1dd0				;push af 
1dd0			 
1dd0			if DEBUG_FORTH_PUSH 
1dd0						DMARK "PHm" 
1dd0 f5				push af  
1dd1 3a e5 1d			ld a, (.dmark)  
1dd4 32 77 fb			ld (debug_mark),a  
1dd7 3a e6 1d			ld a, (.dmark+1)  
1dda 32 78 fb			ld (debug_mark+1),a  
1ddd 3a e7 1d			ld a, (.dmark+2)  
1de0 32 79 fb			ld (debug_mark+2),a  
1de3 18 03			jr .pastdmark  
1de5 ..			.dmark: db "PHm"  
1de8 f1			.pastdmark: pop af  
1de9			endm  
# End of macro DMARK
1de9				CALLMONITOR 
1de9 cd 49 17			call break_point_state  
1dec				endm  
# End of macro CALLMONITOR
1dec			endif	 
1dec cd d3 11			call malloc	; on ret hl now contains allocated memory 
1def				if DEBUG_FORTH_MALLOC_GUARD 
1def cc a8 51				call z,malloc_error 
1df2				endif 
1df2			 
1df2				 
1df2 c1				pop bc    ; get length 
1df3 d1				pop de   ;  get string start    
1df4			 
1df4				; hl has destination from malloc 
1df4			 
1df4 eb				ex de, hl    ; prep for ldir 
1df5			 
1df5 d5				push de   ; save malloc area for DSP later 
1df6				;push hl   ; save malloc area for DSP later 
1df6			 
1df6			if DEBUG_FORTH_PUSH 
1df6						DMARK "PHc" 
1df6 f5				push af  
1df7 3a 0b 1e			ld a, (.dmark)  
1dfa 32 77 fb			ld (debug_mark),a  
1dfd 3a 0c 1e			ld a, (.dmark+1)  
1e00 32 78 fb			ld (debug_mark+1),a  
1e03 3a 0d 1e			ld a, (.dmark+2)  
1e06 32 79 fb			ld (debug_mark+2),a  
1e09 18 03			jr .pastdmark  
1e0b ..			.dmark: db "PHc"  
1e0e f1			.pastdmark: pop af  
1e0f			endm  
# End of macro DMARK
1e0f				CALLMONITOR 
1e0f cd 49 17			call break_point_state  
1e12				endm  
# End of macro CALLMONITOR
1e12			endif	 
1e12			 
1e12			 
1e12 ed b0			ldir 
1e14			 
1e14			 
1e14				; push malloc to data stack     macro?????  
1e14			 
1e14				FORTH_DSP_NEXT 
1e14 cd 68 1c			call macro_forth_dsp_next 
1e17				endm 
# End of macro FORTH_DSP_NEXT
1e17			 
1e17				; save value and type 
1e17			 
1e17 2a 0a f8			ld hl, (cli_data_sp) 
1e1a			 
1e1a				; save item type 
1e1a 3e 01			ld a,  DS_TYPE_STR 
1e1c 77				ld (hl), a 
1e1d 23				inc hl 
1e1e			 
1e1e				; get malloc word off stack 
1e1e d1				pop de 
1e1f 73				ld (hl), e 
1e20 23				inc hl 
1e21 72				ld (hl), d 
1e22			 
1e22			 
1e22			 
1e22			if DEBUG_FORTH_PUSH 
1e22 2a 0a f8			ld hl, (cli_data_sp) 
1e25						DMARK "PHS" 
1e25 f5				push af  
1e26 3a 3a 1e			ld a, (.dmark)  
1e29 32 77 fb			ld (debug_mark),a  
1e2c 3a 3b 1e			ld a, (.dmark+1)  
1e2f 32 78 fb			ld (debug_mark+1),a  
1e32 3a 3c 1e			ld a, (.dmark+2)  
1e35 32 79 fb			ld (debug_mark+2),a  
1e38 18 03			jr .pastdmark  
1e3a ..			.dmark: db "PHS"  
1e3d f1			.pastdmark: pop af  
1e3e			endm  
# End of macro DMARK
1e3e				CALLMONITOR 
1e3e cd 49 17			call break_point_state  
1e41				endm  
# End of macro CALLMONITOR
1e41			;	ex de,hl 
1e41			endif	 
1e41				; in case of spaces, skip the ptr past the copied string 
1e41				;pop af 
1e41				;ld (cli_origptr),hl 
1e41			 
1e41 c9				ret 
1e42			 
1e42			 
1e42			 
1e42			; TODO ascii push input onto stack given hl to start of input 
1e42			 
1e42			; identify type 
1e42			; if starts with a " then a string 
1e42			; otherwise it is a number 
1e42			;  
1e42			; if a string 
1e42			;     scan for ending " to get length of string to malloc for + 1 
1e42			;     malloc 
1e42			;     put pointer to string on stack first byte flags as string 
1e42			; 
1e42			; else a number 
1e42			;    look for number format identifier 
1e42			;    $xx hex 
1e42			;    %xxxxx bin 
1e42			;    xxxxx decimal 
1e42			;    convert number to 16bit word.  
1e42			;    malloc word + 1 with flag to identiy as num 
1e42			;    put pointer to number on stack 
1e42			;   
1e42			;  
1e42			  
1e42			forth_apush: 
1e42				; kernel push 
1e42			 
1e42			if DEBUG_FORTH_PUSH 
1e42						DMARK "PSH" 
1e42 f5				push af  
1e43 3a 57 1e			ld a, (.dmark)  
1e46 32 77 fb			ld (debug_mark),a  
1e49 3a 58 1e			ld a, (.dmark+1)  
1e4c 32 78 fb			ld (debug_mark+1),a  
1e4f 3a 59 1e			ld a, (.dmark+2)  
1e52 32 79 fb			ld (debug_mark+2),a  
1e55 18 03			jr .pastdmark  
1e57 ..			.dmark: db "PSH"  
1e5a f1			.pastdmark: pop af  
1e5b			endm  
# End of macro DMARK
1e5b				CALLMONITOR 
1e5b cd 49 17			call break_point_state  
1e5e				endm  
# End of macro CALLMONITOR
1e5e			endif	 
1e5e				; identify input type 
1e5e			 
1e5e 7e				ld a,(hl) 
1e5f fe 22			cp '"' 
1e61 28 0a			jr z, .fapstr 
1e63 fe 24			cp '$' 
1e65 ca 8d 1e			jp z, .faphex 
1e68 fe 25			cp '%' 
1e6a ca 75 1e			jp z, .fapbin 
1e6d			;	cp 'b' 
1e6d			;	jp z, .fabin 
1e6d				; else decimal 
1e6d			 
1e6d				; TODO do decimal conversion 
1e6d				; decimal is stored as a 16bit word 
1e6d			 
1e6d				; by default everything is a string if type is not detected 
1e6d			.fapstr: ; 
1e6d fe 22			cp '"' 
1e6f 20 01			jr nz, .strnoqu 
1e71 23				inc hl 
1e72			.strnoqu: 
1e72 c3 47 1d			jp forth_push_str 
1e75			 
1e75			 
1e75			 
1e75			.fapbin:    ; push a binary string.  
1e75 11 00 00			ld de, 0   ; hold a 16bit value 
1e78			 
1e78 23			.fapbinshift:	inc hl  
1e79 7e				ld a,(hl) 
1e7a fe 00			cp 0     ; done scanning  
1e7c 28 0b			jr z, .fapbdone  	; got it in HL so push  
1e7e			 
1e7e				; left shift de 
1e7e eb				ex de, hl	 
1e7f 29				add hl, hl 
1e80			 
1e80				; is 1 
1e80 fe 31			cp '1' 
1e82 20 02			jr nz, .binzero 
1e84 cb 4d			bit 1, l 
1e86			.binzero: 
1e86 eb				ex de, hl	 ; save current de 
1e87 18 ef			jr .fapbinshift 
1e89			 
1e89			.fapbdone: 
1e89 eb				ex de, hl 
1e8a c3 d9 1c			jp forth_push_numhl 
1e8d			 
1e8d			 
1e8d			.faphex:   ; hex is always stored as a 16bit word 
1e8d				; skip number prefix 
1e8d 23				inc hl 
1e8e				; turn ascii into number 
1e8e cd c3 10			call get_word_hl	; ret 16bit word in hl 
1e91			 
1e91 c3 d9 1c			jp forth_push_numhl 
1e94			 
1e94 00				 nop 
1e95			 
1e95			.fabin:   ; TODO bin conversion 
1e95			 
1e95			 
1e95 c9				ret 
1e96			 
1e96			 
1e96			; get either a string ptr or a 16bit word from the data stack 
1e96			 
1e96			FORTH_DSP: macro 
1e96				call macro_forth_dsp 
1e96				endm 
1e96			 
1e96			macro_forth_dsp: 
1e96				; data stack pointer points to current word on tos 
1e96			 
1e96 2a 0a f8			ld hl,(cli_data_sp) 
1e99			 
1e99				if DEBUG_FORTH_PUSH 
1e99						DMARK "DSP" 
1e99 f5				push af  
1e9a 3a ae 1e			ld a, (.dmark)  
1e9d 32 77 fb			ld (debug_mark),a  
1ea0 3a af 1e			ld a, (.dmark+1)  
1ea3 32 78 fb			ld (debug_mark+1),a  
1ea6 3a b0 1e			ld a, (.dmark+2)  
1ea9 32 79 fb			ld (debug_mark+2),a  
1eac 18 03			jr .pastdmark  
1eae ..			.dmark: db "DSP"  
1eb1 f1			.pastdmark: pop af  
1eb2			endm  
# End of macro DMARK
1eb2			 
1eb2 cd dd 51				call display_data_sp 
1eb5				;call break_point_state 
1eb5				;rst 030h 
1eb5				CALLMONITOR 
1eb5 cd 49 17			call break_point_state  
1eb8				endm  
# End of macro CALLMONITOR
1eb8				endif 
1eb8			 
1eb8 c9				ret 
1eb9			 
1eb9			; return hl to start of value on stack 
1eb9			 
1eb9			FORTH_DSP_VALUE: macro 
1eb9				call macro_forth_dsp_value 
1eb9				endm 
1eb9			 
1eb9			macro_forth_dsp_value: 
1eb9			 
1eb9				FORTH_DSP 
1eb9 cd 96 1e			call macro_forth_dsp 
1ebc				endm 
# End of macro FORTH_DSP
1ebc			 
1ebc d5				push de 
1ebd			 
1ebd 23				inc hl ; skip type 
1ebe			 
1ebe 5e				ld e, (hl) 
1ebf 23				inc hl 
1ec0 56				ld d, (hl) 
1ec1 eb				ex de,hl  
1ec2			 
1ec2 d1				pop de 
1ec3			 
1ec3 c9				ret 
1ec4			 
1ec4			; return hl to start of value to second item on stack 
1ec4			 
1ec4			FORTH_DSP_VALUEM1: macro 
1ec4				call macro_forth_dsp_value_m1 
1ec4				endm 
1ec4			 
1ec4			macro_forth_dsp_value_m1: 
1ec4			 
1ec4				FORTH_DSP 
1ec4 cd 96 1e			call macro_forth_dsp 
1ec7				endm 
# End of macro FORTH_DSP
1ec7			 
1ec7 2b				dec hl 
1ec8 2b				dec hl 
1ec9			;	dec hl 
1ec9			 
1ec9 d5				push de 
1eca			 
1eca 5e				ld e, (hl) 
1ecb 23				inc hl 
1ecc 56				ld d, (hl) 
1ecd eb				ex de,hl  
1ece			 
1ece d1				pop de 
1ecf			 
1ecf c9				ret 
1ed0			 
1ed0				 
1ed0			 
1ed0			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1ed0			 
1ed0			FORTH_DSP_POP: macro 
1ed0				call macro_forth_dsp_pop 
1ed0				endm 
1ed0			 
1ed0			 
1ed0			; get the tos data type 
1ed0			 
1ed0			FORTH_DSP_TYPE:   macro 
1ed0			 
1ed0				;FORTH_DSP_VALUE 
1ed0				FORTH_DSP 
1ed0				 
1ed0				; hl points to value 
1ed0				; check type 
1ed0			 
1ed0				ld a,(hl) 
1ed0			 
1ed0				endm 
1ed0			 
1ed0			; load the tos value into hl 
1ed0			 
1ed0			 
1ed0			FORTH_DSP_VALUEHL:  macro 
1ed0				call macro_dsp_valuehl 
1ed0				endm 
1ed0			 
1ed0			 
1ed0			 
1ed0			macro_dsp_valuehl: 
1ed0				FORTH_DSP_VALUE 
1ed0 cd b9 1e			call macro_forth_dsp_value 
1ed3				endm 
# End of macro FORTH_DSP_VALUE
1ed3			 
1ed3				;FORTH_ERR_TOS_NOTNUM 
1ed3			 
1ed3				;inc hl   ; skip type id 
1ed3			 
1ed3			;	push de 
1ed3			; 
1ed3			;	ld e, (hl) 
1ed3			;	inc hl 
1ed3			;	ld d, (hl) 
1ed3			;	ex de,hl  
1ed3			 
1ed3			;	pop de 
1ed3			 
1ed3				if DEBUG_FORTH_PUSH 
1ed3						DMARK "DVL" 
1ed3 f5				push af  
1ed4 3a e8 1e			ld a, (.dmark)  
1ed7 32 77 fb			ld (debug_mark),a  
1eda 3a e9 1e			ld a, (.dmark+1)  
1edd 32 78 fb			ld (debug_mark+1),a  
1ee0 3a ea 1e			ld a, (.dmark+2)  
1ee3 32 79 fb			ld (debug_mark+2),a  
1ee6 18 03			jr .pastdmark  
1ee8 ..			.dmark: db "DVL"  
1eeb f1			.pastdmark: pop af  
1eec			endm  
# End of macro DMARK
1eec				CALLMONITOR 
1eec cd 49 17			call break_point_state  
1eef				endm  
# End of macro CALLMONITOR
1eef				endif 
1eef c9				ret 
1ef0			 
1ef0			forth_apushstrhl:      
1ef0				; push of string requires use of cli_origptr 
1ef0				; bodge use 
1ef0			 
1ef0				; get current cli_origptr, save, update with temp pointer  
1ef0 ed 5b 26 f8		ld de, (cli_origptr) 
1ef4 22 26 f8			ld (cli_origptr), hl 
1ef7 d5				push de 
1ef8 cd 42 1e			call forth_apush 
1efb d1				pop de 
1efc ed 53 26 f8		ld (cli_origptr), de 
1f00 c9			        ret	 
1f01			 
1f01			 
1f01			; increase loop stack pointer and save hl to it 
1f01				 
1f01			FORTH_LOOP_NEXT: macro 
1f01				call macro_forth_loop_next 
1f01				;nop 
1f01				endm 
1f01			 
1f01			macro_forth_loop_next: 
1f01				if DEBUG_FORTH_STACK_GUARD 
1f01 cd 42 62				call check_stacks 
1f04				endif 
1f04 e5				push hl 
1f05 d5				push de 
1f06 eb				ex de,hl 
1f07 2a 0c f8			ld hl,(cli_loop_sp) 
1f0a 23				inc hl 
1f0b 23				inc hl 
1f0c					if DEBUG_FORTH_WORDS 
1f0c						DMARK "LNX" 
1f0c f5				push af  
1f0d 3a 21 1f			ld a, (.dmark)  
1f10 32 77 fb			ld (debug_mark),a  
1f13 3a 22 1f			ld a, (.dmark+1)  
1f16 32 78 fb			ld (debug_mark+1),a  
1f19 3a 23 1f			ld a, (.dmark+2)  
1f1c 32 79 fb			ld (debug_mark+2),a  
1f1f 18 03			jr .pastdmark  
1f21 ..			.dmark: db "LNX"  
1f24 f1			.pastdmark: pop af  
1f25			endm  
# End of macro DMARK
1f25						CALLMONITOR 
1f25 cd 49 17			call break_point_state  
1f28				endm  
# End of macro CALLMONITOR
1f28					endif 
1f28 22 0c f8			ld (cli_loop_sp),hl 
1f2b 73				ld (hl), e 
1f2c 23				inc hl 
1f2d 72				ld (hl), d 
1f2e d1				pop de    ; been reversed so save a swap on restore 
1f2f e1				pop hl 
1f30				if DEBUG_FORTH_STACK_GUARD 
1f30 cd 42 62				call check_stacks 
1f33				endif 
1f33 c9				ret 
1f34			 
1f34			; get current ret stack pointer and save to hl  
1f34				 
1f34			FORTH_LOOP_TOS: macro 
1f34				call macro_forth_loop_tos 
1f34				endm 
1f34			 
1f34			macro_forth_loop_tos: 
1f34 d5				push de 
1f35 2a 0c f8			ld hl,(cli_loop_sp) 
1f38 5e				ld e, (hl) 
1f39 23				inc hl 
1f3a 56				ld d, (hl) 
1f3b eb				ex de, hl 
1f3c d1				pop de 
1f3d c9				ret 
1f3e			 
1f3e			; pop loop stack pointer 
1f3e				 
1f3e			FORTH_LOOP_POP: macro 
1f3e				call macro_forth_loop_pop 
1f3e				endm 
1f3e			 
1f3e			 
1f3e			macro_forth_loop_pop: 
1f3e				if DEBUG_FORTH_STACK_GUARD 
1f3e					DMARK "LPP" 
1f3e f5				push af  
1f3f 3a 53 1f			ld a, (.dmark)  
1f42 32 77 fb			ld (debug_mark),a  
1f45 3a 54 1f			ld a, (.dmark+1)  
1f48 32 78 fb			ld (debug_mark+1),a  
1f4b 3a 55 1f			ld a, (.dmark+2)  
1f4e 32 79 fb			ld (debug_mark+2),a  
1f51 18 03			jr .pastdmark  
1f53 ..			.dmark: db "LPP"  
1f56 f1			.pastdmark: pop af  
1f57			endm  
# End of macro DMARK
1f57 cd 42 62				call check_stacks 
1f5a					FORTH_CHK_LOOP_UNDER 
1f5a e5				push hl 
1f5b d5				push de 
1f5c 2a 0c f8			ld hl,(cli_loop_sp) 
1f5f 11 86 f5			ld de, cli_loop_stack 
1f62 cd 2a 0d			call cmp16 
1f65 da 5c 63			jp c, fault_loop_under 
1f68 d1				pop de 
1f69 e1				pop hl 
1f6a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f6a				endif 
1f6a e5				push hl 
1f6b 2a 0c f8			ld hl,(cli_loop_sp) 
1f6e 2b				dec hl 
1f6f 2b				dec hl 
1f70 22 0c f8			ld (cli_loop_sp), hl 
1f73				; TODO do stack underflow checks 
1f73 e1				pop hl 
1f74				if DEBUG_FORTH_STACK_GUARD 
1f74 cd 42 62				call check_stacks 
1f77					FORTH_CHK_LOOP_UNDER 
1f77 e5				push hl 
1f78 d5				push de 
1f79 2a 0c f8			ld hl,(cli_loop_sp) 
1f7c 11 86 f5			ld de, cli_loop_stack 
1f7f cd 2a 0d			call cmp16 
1f82 da 5c 63			jp c, fault_loop_under 
1f85 d1				pop de 
1f86 e1				pop hl 
1f87				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f87				endif 
1f87 c9				ret 
1f88			 
1f88			macro_forth_dsp_pop: 
1f88			 
1f88 e5				push hl 
1f89			 
1f89				; release malloc data 
1f89			 
1f89				if DEBUG_FORTH_STACK_GUARD 
1f89 cd 42 62				call check_stacks 
1f8c					FORTH_CHK_DSP_UNDER 
1f8c e5				push hl 
1f8d d5				push de 
1f8e 2a 0a f8			ld hl,(cli_data_sp) 
1f91 11 84 f3			ld de, cli_data_stack 
1f94 cd 2a 0d			call cmp16 
1f97 da 50 63			jp c, fault_dsp_under 
1f9a d1				pop de 
1f9b e1				pop hl 
1f9c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f9c				endif 
1f9c				;ld hl,(cli_data_sp) 
1f9c			if DEBUG_FORTH_DOT 
1f9c				DMARK "DPP" 
1f9c				CALLMONITOR 
1f9c			endif	 
1f9c			 
1f9c			 
1f9c			if FORTH_ENABLE_DSPPOPFREE 
1f9c			 
1f9c				FORTH_DSP 
1f9c cd 96 1e			call macro_forth_dsp 
1f9f				endm 
# End of macro FORTH_DSP
1f9f			 
1f9f 7e				ld a, (hl) 
1fa0 fe 01			cp DS_TYPE_STR 
1fa2 20 07			jr nz, .skippopfree 
1fa4			 
1fa4				FORTH_DSP_VALUEHL 
1fa4 cd d0 1e			call macro_dsp_valuehl 
1fa7				endm 
# End of macro FORTH_DSP_VALUEHL
1fa7 00				nop 
1fa8			if DEBUG_FORTH_DOT 
1fa8				DMARK "DPf" 
1fa8				CALLMONITOR 
1fa8			endif	 
1fa8 cd 9d 12			call free 
1fab			.skippopfree: 
1fab				 
1fab			 
1fab			endif 
1fab			 
1fab			if DEBUG_FORTH_DOT_KEY 
1fab				DMARK "DP2" 
1fab				CALLMONITOR 
1fab			endif	 
1fab			 
1fab				; move pointer down 
1fab			 
1fab 2a 0a f8			ld hl,(cli_data_sp) 
1fae 2b				dec hl 
1faf 2b				dec hl 
1fb0			; PARSEV5 
1fb0 2b				dec hl 
1fb1 22 0a f8			ld (cli_data_sp), hl 
1fb4			 
1fb4				if DEBUG_FORTH_STACK_GUARD 
1fb4 cd 42 62				call check_stacks 
1fb7					FORTH_CHK_DSP_UNDER 
1fb7 e5				push hl 
1fb8 d5				push de 
1fb9 2a 0a f8			ld hl,(cli_data_sp) 
1fbc 11 84 f3			ld de, cli_data_stack 
1fbf cd 2a 0d			call cmp16 
1fc2 da 50 63			jp c, fault_dsp_under 
1fc5 d1				pop de 
1fc6 e1				pop hl 
1fc7				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fc7				endif 
1fc7			 
1fc7 e1				pop hl 
1fc8			 
1fc8 c9				ret 
1fc9			 
1fc9			getwordathl: 
1fc9				; hl points to an address 
1fc9				; load hl with the word at that address 
1fc9			 
1fc9 d5				push de 
1fca			 
1fca 5e				ld e, (hl) 
1fcb 23				inc hl 
1fcc 56				ld d, (hl) 
1fcd eb				ex de, hl 
1fce			 
1fce d1				pop de 
1fcf c9				ret 
1fd0			 
1fd0			 
1fd0			 
1fd0			 
1fd0			 
1fd0			; eof 
1fd0			 
# End of file forth_stackopsv5.asm
1fd0			endif 
1fd0			 
1fd0			user_word_eol:  
1fd0				; hl contains the pointer to where to create a linked list item from the end 
1fd0				; of the user dict to continue on at the system word dict 
1fd0				 
1fd0				; poke the stub of the word list linked list to repoint to rom words 
1fd0			 
1fd0				; stub format 
1fd0				; db   word id 
1fd0				; dw    link to next word 
1fd0			        ; db char length of token 
1fd0				; db string + 0 term 
1fd0				; db exec code....  
1fd0			 
1fd0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1fd2 77				ld (hl), a		; word id 
1fd3 23				inc hl 
1fd4			 
1fd4 11 9a 21			ld de, sysdict 
1fd7 73				ld (hl), e		; next word link ie system dict 
1fd8 23				inc hl 
1fd9 72				ld (hl), d		; next word link ie system dict 
1fda 23				inc hl	 
1fdb			 
1fdb			;	ld (hl), sysdict		; next word link ie system dict 
1fdb			;	inc hl 
1fdb			;	inc hl 
1fdb			 
1fdb			;	inc hl 
1fdb			;	inc hl 
1fdb			 
1fdb 3e 02			ld a, 2			; word length is 0 
1fdd 77				ld (hl), a	 
1fde 23				inc hl 
1fdf			 
1fdf 3e 7e			ld a, '~'			; word length is 0 
1fe1 77				ld (hl), a	 
1fe2 23				inc hl 
1fe3 3e 00			ld a, 0			; save empty word 
1fe5 77				ld (hl), a 
1fe6			 
1fe6 c9				ret 
1fe7			 
1fe7				 
1fe7			 
1fe7			forthexec_cleanup: 
1fe7				FORTH_RSP_POP 
1fe7 cd a1 1c			call macro_forth_rsp_pop 
1fea				endm 
# End of macro FORTH_RSP_POP
1fea c9				ret 
1feb			 
1feb			forth_call_hl: 
1feb				; taking hl 
1feb e5				push hl 
1fec c9				ret 
1fed			 
1fed			; this is called to reset Forth system but keep existing uwords etc 
1fed			 
1fed			forth_warmstart: 
1fed				; setup stack over/under flow checks 
1fed				if DEBUG_FORTH_STACK_GUARD 
1fed cd 28 62				call chk_stk_init 
1ff0				endif 
1ff0			 
1ff0				; init stack pointers  - * these stacks go upwards *  
1ff0 21 88 f7			ld hl, cli_ret_stack 
1ff3 22 0e f8			ld (cli_ret_sp), hl	 
1ff6				; set bottom of stack 
1ff6 3e 00			ld a,0 
1ff8 77				ld (hl),a 
1ff9 23				inc hl 
1ffa 77				ld (hl),a 
1ffb			 
1ffb 21 84 f3			ld hl, cli_data_stack 
1ffe 22 0a f8			ld (cli_data_sp), hl	 
2001				; set bottom of stack 
2001 3e 00			ld a,0 
2003 77				ld (hl),a 
2004 23				inc hl 
2005 77				ld (hl),a 
2006			 
2006 21 86 f5			ld hl, cli_loop_stack 
2009 22 0c f8			ld (cli_loop_sp), hl	 
200c				; set bottom of stack 
200c 3e 00			ld a,0 
200e 77				ld (hl),a 
200f 23				inc hl 
2010 77				ld (hl),a 
2011			 
2011				; init extent of current open file 
2011			 
2011 3e 00			ld a, 0 
2013 32 59 f8			ld (store_openext), a 
2016			 
2016 c9				ret 
2017			 
2017			 
2017			; Cold Start - this is called to setup the whole Forth system 
2017			 
2017			forth_init: 
2017			 
2017				; setup stack over/under flow checks 
2017			 
2017			;	if DEBUG_FORTH_STACK_GUARD 
2017			;		call chk_stk_init 
2017			;	endif 
2017			 
2017				; enable auto display updates (slow.....) 
2017			 
2017 3e 01			ld a, 1 
2019 32 24 f8			ld (cli_autodisplay), a 
201c			 
201c			 
201c			 
201c				; show start up screen 
201c			 
201c cd d8 0a			call clear_display 
201f			 
201f 3e 00			ld a,0 
2021 32 46 f8			ld (f_cursor_ptr), a 
2024			 
2024				; set start of word list in start of ram - for use when creating user words 
2024			 
2024 21 00 80			ld hl, baseram 
2027 22 1a f1			ld (os_last_new_uword), hl 
202a cd d0 1f			call user_word_eol 
202d				 
202d			;		call display_data_sp 
202d			;		call next_page_prompt 
202d			 
202d			 
202d			 
202d			 
202d c9				ret 
202e			 
202e .. 00		.bootforth: db " Forth Kernel Init ",0 
2042			 
2042			; TODO push to stack 
2042			 
2042			;  
2042			 
2042			if FORTH_PARSEV2 
2042			 
2042			 
2042				include "forth_parserv2.asm" 
2042			 
2042			endif 
2042			 
2042			 
2042			; parse cli version 1 
2042			 
2042			if FORTH_PARSEV1 
2042			 
2042			 
2042			 
2042			      include "forth_parserv1.asm" 
2042			endif 
2042				 
2042			if FORTH_PARSEV3 
2042			 
2042			 
2042			 
2042			      include "forth_parserv3.asm" 
2042				include "forth_wordsv3.asm" 
2042			endif 
2042			 
2042			if FORTH_PARSEV4 
2042			 
2042			 
2042			 
2042			      include "forth_parserv4.asm" 
2042				include "forth_wordsv4.asm" 
2042			endif 
2042			 
2042			if FORTH_PARSEV5 
2042			 
2042			 
2042			 
2042			      include "forth_parserv5.asm" 
2042			 
2042			 
2042			; A better parser without using malloc and string copies all over the place.  
2042			; Exec in situ should be faster 
2042			 
2042			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2042			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2042			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2042			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2042			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2042			WORD_SYS_END: equ 0   ; Opcode for all user words 
2042			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2042			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2042			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2042			 
2042			; Core word preamble macro 
2042			 
2042			CWHEAD:   macro nxtword opcode lit len opflags 
2042				db WORD_SYS_CORE+opcode             
2042				; internal op code number 
2042				dw nxtword            
2042				; link to next dict word block 
2042				db len + 1 
2042				; literal length of dict word inc zero term 
2042				db lit,0              
2042				; literal dict word 
2042			        ; TODO db opflags        
2042				endm 
2042			 
2042			 
2042			NEXTW: macro  
2042				jp macro_next 
2042				endm 
2042			 
2042			macro_next: 
2042			if DEBUG_FORTH_PARSE_KEY 
2042				DMARK "NXT" 
2042				CALLMONITOR 
2042			endif	 
2042			;	inc hl  ; skip token null term  
2042 ed 4b 28 f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2046 ed 5b 26 f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
204a 2a 1e f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
204d			if DEBUG_FORTH_PARSE_KEY 
204d				DMARK "}AA" 
204d				CALLMONITOR 
204d			endif	 
204d c3 50 21			jp execnext 
2050				;jp exec1 
2050			       
2050			 
2050			 
2050			; Another go at the parser to compile  
2050			 
2050			 
2050			; TODO rework parser to change all of the string words to byte tokens 
2050			; TODO do a search for  
2050			 
2050			; TODO first run normal parser to zero term sections 
2050			; TODO for each word do a token look up to get the op code 
2050			; TODO need some means to flag to the exec that this is a byte code form    
2050			 
2050			 
2050			forthcompile: 
2050			 
2050			; 
2050			; line parse: 
2050			;       parse raw input buffer 
2050			;       tokenise the words 
2050			;       malloc new copy (for looping etc) 
2050			;       copy to malloc + current pc in line to start of string and add line term 
2050			;       save on new rsp 
2050			; 
2050			 
2050			; hl to point to the line to tokenise 
2050			 
2050			;	push hl 
2050 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2053			 
2053			;	ld a,0		; string term on input 
2053			;	call strlent 
2053			 
2053			;	ld (os_tok_len), hl	 ; save string length 
2053			 
2053			;if DEBUG_FORTH_TOK 
2053			;	ex de,hl		 
2053			;endif 
2053			 
2053			;	pop hl 		; get back string pointer 
2053			 
2053			if DEBUG_FORTH_TOK 
2053						DMARK "TOc" 
2053				CALLMONITOR 
2053			endif 
2053 7e			.cptoken2:    ld a,(hl) 
2054 23				inc hl 
2055 fe 7f			cp FORTH_END_BUFFER 
2057 28 29			jr z, .cptokendone2 
2059 fe 00			cp 0 
205b 28 25			jr z, .cptokendone2 
205d fe 22			cp '"' 
205f 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2061 fe 20			cp ' ' 
2063 20 ee			jr nz,  .cptoken2 
2065			 
2065			; TODO consume comments held between ( and ) 
2065			 
2065				; we have a space so change to zero term for dict match later 
2065 2b				dec hl 
2066 3e 00			ld a,0 
2068 77				ld (hl), a 
2069 23				inc hl 
206a 18 e7			jr .cptoken2 
206c				 
206c			 
206c			.cptokenstr2: 
206c				; skip all white space until either eol (because forgot to term) or end double quote 
206c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
206c				;inc hl ; skip current double quote 
206c 7e				ld a,(hl) 
206d 23				inc hl 
206e fe 22			cp '"' 
2070 28 e1			jr z, .cptoken2 
2072 fe 7f			cp FORTH_END_BUFFER 
2074 28 0c			jr z, .cptokendone2 
2076 fe 00			cp 0 
2078 28 08			jr z, .cptokendone2 
207a fe 20			cp ' ' 
207c 28 02			jr z, .cptmp2 
207e 18 ec			jr .cptokenstr2 
2080			 
2080			.cptmp2:	; we have a space so change to zero term for dict match later 
2080				;dec hl 
2080				;ld a,"-"	; TODO remove this when working 
2080				;ld (hl), a 
2080				;inc hl 
2080 18 ea			jr .cptokenstr2 
2082			 
2082			.cptokendone2: 
2082				;inc hl 
2082 3e 7f			ld a, FORTH_END_BUFFER 
2084 77				ld (hl),a 
2085 23				inc hl 
2086 3e 21			ld a, '!' 
2088 77				ld (hl),a 
2089			 
2089 2a 1e f1			ld hl,(os_tok_ptr) 
208c			         
208c			if DEBUG_FORTH_TOK 
208c						DMARK "Tc1" 
208c				CALLMONITOR 
208c			endif 
208c			 
208c				; push exec string to top of return stack 
208c				FORTH_RSP_NEXT 
208c cd 80 1c			call macro_forth_rsp_next 
208f				endm 
# End of macro FORTH_RSP_NEXT
208f c9				ret 
2090			 
2090			; Another go at the parser need to simplify the process 
2090			 
2090			forthparse: 
2090			 
2090			; 
2090			; line parse: 
2090			;       parse raw input buffer 
2090			;       tokenise the words 
2090			;       malloc new copy (for looping etc) 
2090			;       copy to malloc + current pc in line to start of string and add line term 
2090			;       save on new rsp 
2090			; 
2090			 
2090			; hl to point to the line to tokenise 
2090			 
2090			;	push hl 
2090 22 1e f1			ld (os_tok_ptr), hl  ; save ptr to string 
2093			 
2093			;	ld a,0		; string term on input 
2093			;	call strlent 
2093			 
2093			;	ld (os_tok_len), hl	 ; save string length 
2093			 
2093			;if DEBUG_FORTH_TOK 
2093			;	ex de,hl		 
2093			;endif 
2093			 
2093			;	pop hl 		; get back string pointer 
2093			 
2093			if DEBUG_FORTH_TOK 
2093						DMARK "TOK" 
2093				CALLMONITOR 
2093			endif 
2093 7e			.ptoken2:    ld a,(hl) 
2094 23				inc hl 
2095 fe 7f			cp FORTH_END_BUFFER 
2097 28 29			jr z, .ptokendone2 
2099 fe 00			cp 0 
209b 28 25			jr z, .ptokendone2 
209d fe 22			cp '"' 
209f 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20a1 fe 20			cp ' ' 
20a3 20 ee			jr nz,  .ptoken2 
20a5			 
20a5			; TODO consume comments held between ( and ) 
20a5			 
20a5				; we have a space so change to zero term for dict match later 
20a5 2b				dec hl 
20a6 3e 00			ld a,0 
20a8 77				ld (hl), a 
20a9 23				inc hl 
20aa 18 e7			jr .ptoken2 
20ac				 
20ac			 
20ac			.ptokenstr2: 
20ac				; skip all white space until either eol (because forgot to term) or end double quote 
20ac			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20ac				;inc hl ; skip current double quote 
20ac 7e				ld a,(hl) 
20ad 23				inc hl 
20ae fe 22			cp '"' 
20b0 28 e1			jr z, .ptoken2 
20b2 fe 7f			cp FORTH_END_BUFFER 
20b4 28 0c			jr z, .ptokendone2 
20b6 fe 00			cp 0 
20b8 28 08			jr z, .ptokendone2 
20ba fe 20			cp ' ' 
20bc 28 02			jr z, .ptmp2 
20be 18 ec			jr .ptokenstr2 
20c0			 
20c0			.ptmp2:	; we have a space so change to zero term for dict match later 
20c0				;dec hl 
20c0				;ld a,"-"	; TODO remove this when working 
20c0				;ld (hl), a 
20c0				;inc hl 
20c0 18 ea			jr .ptokenstr2 
20c2			 
20c2			.ptokendone2: 
20c2				;inc hl 
20c2 3e 7f			ld a, FORTH_END_BUFFER 
20c4 77				ld (hl),a 
20c5 23				inc hl 
20c6 3e 21			ld a, '!' 
20c8 77				ld (hl),a 
20c9			 
20c9 2a 1e f1			ld hl,(os_tok_ptr) 
20cc			         
20cc			if DEBUG_FORTH_TOK 
20cc						DMARK "TK1" 
20cc				CALLMONITOR 
20cc			endif 
20cc			 
20cc				; push exec string to top of return stack 
20cc				FORTH_RSP_NEXT 
20cc cd 80 1c			call macro_forth_rsp_next 
20cf				endm 
# End of macro FORTH_RSP_NEXT
20cf c9				ret 
20d0			 
20d0			; 
20d0			;	; malloc size + buffer pointer + if is loop flag 
20d0			;	ld hl,(os_tok_len) 		 ; get string length 
20d0			; 
20d0			;	ld a,l 
20d0			; 
20d0			;	cp 0			; we dont want to use a null string 
20d0			;	ret z 
20d0			; 
20d0			;;	add 3    ; prefix malloc with buffer for current word ptr 
20d0			; 
20d0			;	add 5     ; TODO when certain not over writing memory remove 
20d0			; 
20d0			;		 
20d0			; 
20d0			;if DEBUG_FORTH_TOK 
20d0			;			DMARK "TKE" 
20d0			;	CALLMONITOR 
20d0			;endif 
20d0			; 
20d0			;	ld l,a 
20d0			;	ld h,0 
20d0			;;	push hl   ; save required space for the copy later 
20d0			;	call malloc 
20d0			;if DEBUG_FORTH_TOK 
20d0			;			DMARK "TKM" 
20d0			;	CALLMONITOR 
20d0			;endif 
20d0			;	if DEBUG_FORTH_MALLOC_GUARD 
20d0			;		push af 
20d0			;		call ishlzero 
20d0			;;		ld a, l 
20d0			;;		add h 
20d0			;;		cp 0 
20d0			;		pop af 
20d0			;		 
20d0			;		call z,malloc_error 
20d0			;	endif 
20d0			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20d0			; 
20d0			; 
20d0			;if DEBUG_FORTH_TOK 
20d0			;			DMARK "TKR" 
20d0			;	CALLMONITOR 
20d0			;endif 
20d0			; 
20d0			;	FORTH_RSP_NEXT 
20d0			; 
20d0			;	;inc hl	 ; go past current buffer pointer 
20d0			;	;inc hl 
20d0			;	;inc hl   ; and past if loop flag 
20d0			;		; TODO Need to set flag  
20d0			; 
20d0			;	 
20d0			;	 
20d0			;	ex de,hl	; malloc is dest 
20d0			;	ld hl, (os_tok_len) 
20d0			;;	pop bc 
20d0			;	ld c, l                
20d0			;	ld b,0 
20d0			;	ld hl, (os_tok_ptr) 
20d0			; 
20d0			;if DEBUG_FORTH_TOK 
20d0			;			DMARK "TKT" 
20d0			;	CALLMONITOR 
20d0			;endif 
20d0			; 
20d0			;	; do str cpy 
20d0			; 
20d0			;	ldir      ; copy byte in hl to de 
20d0			; 
20d0			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20d0			; 
20d0			;if DEBUG_FORTH_TOK 
20d0			; 
20d0			;			DMARK "TKY" 
20d0			;	CALLMONITOR 
20d0			;endif 
20d0			;	;ld a,0 
20d0			;	;ld a,FORTH_END_BUFFER 
20d0			;	ex de, hl 
20d0			;	;dec hl			 ; go back over the space delim at the end of word 
20d0			;	;ld (hl),a 
20d0			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20d0			;	ld a,FORTH_END_BUFFER 
20d0			;	ld (hl),a 
20d0			;	inc hl 
20d0			;	ld a,FORTH_END_BUFFER 
20d0			;	ld (hl),a 
20d0			; 
20d0			;	; init the malloc area data 
20d0			;	; set pc for in current area 
20d0			;	;ld hl, (os_tok_malloc) 
20d0			;	;inc hl 
20d0			;	;inc hl 
20d0			;	;inc hl 
20d0			;	;ex de,hl 
20d0			;	;ld hl, (os_tok_malloc) 
20d0			;	;ld (hl),e 
20d0			;	;inc hl 
20d0			;	;ld (hl),d 
20d0			; 
20d0			; 
20d0			;	ld hl,(os_tok_malloc) 
20d0			;if DEBUG_FORTH_PARSE_KEY 
20d0			;			DMARK "TKU" 
20d0			;	CALLMONITOR 
20d0			;endif 
20d0			; 
20d0			;	ret 
20d0			 
20d0			forthexec: 
20d0			 
20d0			; line exec: 
20d0			; forth parser 
20d0			 
20d0			; 
20d0			;       get current exec line on rsp 
20d0			 
20d0				FORTH_RSP_TOS 
20d0 cd 97 1c			call macro_forth_rsp_tos 
20d3				endm 
# End of macro FORTH_RSP_TOS
20d3			 
20d3			;       restore current pc - hl points to malloc of data 
20d3			 
20d3				;ld e, (hl) 
20d3				;inc hl 
20d3				;ld d, (hl) 
20d3				;ex de,hl 
20d3			 
20d3			 
20d3			exec1: 
20d3 22 1e f1			ld (os_tok_ptr), hl 
20d6			 
20d6				; copy our PC to working vars  
20d6 22 28 f8			ld (cli_ptr), hl 
20d9 22 26 f8			ld (cli_origptr), hl 
20dc			 
20dc 7e				ld a,(hl) 
20dd fe 7f			cp FORTH_END_BUFFER 
20df c8				ret z 
20e0			 
20e0				; skip any nulls 
20e0			 
20e0 fe 00			cp 0 
20e2 20 03			jr nz, .execword 
20e4 23				inc hl 
20e5 18 ec			jr exec1 
20e7			 
20e7			 
20e7			.execword: 
20e7			 
20e7			 
20e7			 
20e7			if DEBUG_FORTH_PARSE_KEY 
20e7						DMARK "KYQ" 
20e7				CALLMONITOR 
20e7			endif 
20e7			;       while at start of word: 
20e7			; get start of dict (in user area first) 
20e7			 
20e7 21 00 80		ld hl, baseram 
20ea			;ld hl, sysdict 
20ea 22 2a f8		ld (cli_nextword),hl 
20ed			;           match word at pc 
20ed			;           exec word 
20ed			;           or push to dsp 
20ed			;           forward to next token 
20ed			;           if line term pop rsp and exit 
20ed			;        
20ed			 
20ed			if DEBUG_FORTH_PARSE_KEY 
20ed						DMARK "KYq" 
20ed				CALLMONITOR 
20ed			endif 
20ed			 
20ed			; 
20ed			; word comp 
20ed			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20ed			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20ed			;    move to start of word  
20ed			;    compare word to cli_token 
20ed			 
20ed			.execpnword:	; HL at start of a word in the dictionary to check 
20ed			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20ed			;	ld (cli_ptr), hl 
20ed			 
20ed 2a 2a f8			ld hl,(cli_nextword) 
20f0			 
20f0 cd 93 21			call forth_tok_next 
20f3			; tok next start here 
20f3			;	; TODO skip compiled symbol for now 
20f3			;	inc hl 
20f3			; 
20f3			;	; save pointer to next word 
20f3			; 
20f3			;	; hl now points to the address of the next word pointer  
20f3			;	ld e, (hl) 
20f3			;	inc hl 
20f3			;	ld d, (hl) 
20f3			;	inc l 
20f3			; 
20f3			;	ex de,hl 
20f3			;if DEBUG_FORTH_PARSE_NEXTWORD 
20f3			;	push bc 
20f3			;	ld bc, (cli_nextword) 
20f3			;			DMARK "NXW" 
20f3			;	CALLMONITOR 
20f3			;	pop bc 
20f3			;endif 
20f3			; tok next end here 
20f3 22 2a f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
20f6 eb				ex de, hl 
20f7			 
20f7			 
20f7				; save the pointer of the current token - 1 to check against 
20f7				 
20f7 22 2e f8			ld (cli_token), hl   
20fa				; TODO maybe remove below save if no debug 
20fa				; save token string ptr for any debug later 
20fa 23				inc hl  
20fb 22 30 f8			ld (cli_origtoken), hl 
20fe 2b				dec hl 
20ff				; save pointer to the start of the next dictionay word 
20ff 7e				ld a,(hl)   ; get string length 
2100 47				ld b,a 
2101			.execpnwordinc:  
2101 23				inc hl 
2102 10 fd			djnz .execpnwordinc 
2104 22 2c f8			ld (cli_execword), hl      ; save start of this words code 
2107			 
2107				; now check the word token against the string being parsed 
2107			 
2107 2a 2e f8			ld hl,(cli_token) 
210a 23				inc hl     ; skip string length (use zero term instead to end) 
210b 22 2e f8			ld (cli_token), hl 
210e			 
210e			if DEBUG_FORTH_PARSE_KEY 
210e						DMARK "KY2" 
210e			endif 
210e			if DEBUG_FORTH_PARSE_EXEC 
210e				; see if disabled 
210e			 
210e				ld a, (os_view_disable) 
210e				cp '*' 
210e				jr z, .skip 
210e			 
210e				push hl 
210e				push hl 
210e				call clear_display 
210e				ld de, .compword 
210e				ld a, display_row_1 
210e				call str_at_display 
210e				pop de 
210e				ld a, display_row_2 
210e				call str_at_display 
210e				ld hl,(cli_ptr) 
210e				ld a,(hl) 
210e			        ld hl, os_word_scratch 
210e				ld (hl),a 
210e				ld a,0 
210e				inc hl 
210e				ld (hl),a 	 
210e				ld de, os_word_scratch 
210e				ld a, display_row_2+10 
210e				call str_at_display 
210e				call update_display 
210e				ld a, 100 
210e				call aDelayInMS 
210e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
210e				call delay250ms 
210e				endif 
210e				pop hl 
210e			.skip:  
210e			endif	 
210e			.execpnchar:    ; compare char between token and string to parse 
210e			 
210e			if DEBUG_FORTH_PARSE_KEY 
210e						DMARK "Ky3" 
210e			endif 
210e			if DEBUG_FORTH_PARSE_EXEC 
210e				; see if disabled 
210e			 
210e				ld a, (os_view_disable) 
210e				cp '*' 
210e				jr z, .skip2 
210e			 
210e			;	call clear_display 
210e			ld hl,(cli_token) 
210e			ld a,(hl) 
210e			ld (os_word_scratch),a 
210e				ld hl,(cli_ptr) 
210e			ld a,(hl) 
210e				ld (os_word_scratch+1),a 
210e				ld a,0 
210e				ld (os_word_scratch+2),a 
210e				ld de,os_word_scratch 
210e				ld a,display_row_4 
210e				call str_at_display 
210e				call update_display 
210e			.skip2:  
210e			endif 
210e 2a 2e f8			ld hl,(cli_token) 
2111 7e				ld a, (hl)	 ; char in word token 
2112 23				inc hl 		; move to next char 
2113 22 2e f8			ld (cli_token), hl ; and save it 
2116 47				ld b,a 
2117			 
2117 2a 28 f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
211a 7e				ld a,(hl) 
211b 23				inc hl 
211c 22 28 f8			ld (cli_ptr), hl		; move to next char 
211f cd 61 11			call toUpper 		; make sure the input string matches case 
2122			 
2122			if DEBUG_FORTH_PARSE 
2122			endif 
2122			 
2122				; input stream end of token is a space so get rid of it 
2122			 
2122			;	cp ' ' 
2122			;	jr nz, .pnskipspace 
2122			; 
2122			;	ld a, 0		; make same term as word token term 
2122			; 
2122			;.pnskipspace: 
2122			 
2122			if DEBUG_FORTH_PARSE_KEY 
2122						DMARK "KY7" 
2122			endif 
2122 b8				cp b 
2123 c2 39 21			jp nz, .execpnskipword	 ; no match so move to next word 
2126				 
2126			;    if same 
2126			;       scan for string terms 0 for token and 32 for input 
2126			 
2126				 
2126			if DEBUG_FORTH_PARSE_KEY 
2126						DMARK "KY8" 
2126			endif 
2126			 
2126 80				add b			 
2127 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2129							; TODO need to make sure last word in zero term string is accounted for 
2129 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
212b			 
212b			 
212b				; at end of both strings so both are exact match 
212b			 
212b			;       skip ptr for next word 
212b			 
212b 2a 28 f8			ld hl,(cli_ptr) 	; at input string term 
212e 23				inc hl			 ; at next char 
212f 22 28 f8			ld (cli_ptr), hl     ; save for next round of the parser 
2132 22 26 f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2135				 
2135				 
2135			if DEBUG_FORTH_PARSE_KEY 
2135						DMARK "KY3" 
2135			endif 
2135			 
2135			 
2135			 
2135			;       exec code block 
2135			if DEBUG_FORTH_JP 
2135				call clear_display 
2135				call update_display 
2135				call delay1s 
2135				ld hl, (cli_execword)     ; save for next check if no match on this word 
2135				ld a,h 
2135				ld hl, os_word_scratch 
2135				call hexout 
2135				ld hl, (cli_execword)     ; save for next check if no match on this word 
2135				ld a,l 
2135				ld hl, os_word_scratch+2 
2135				call hexout 
2135				ld hl, os_word_scratch+4 
2135				ld a,0 
2135				ld (hl),a 
2135				ld de,os_word_scratch 
2135				call str_at_display 
2135					ld a, display_row_2 
2135					call str_at_display 
2135				ld de, (cli_origtoken) 
2135				ld a, display_row_1+10 
2135					call str_at_display 
2135			 
2135				ld a,display_row_1 
2135				ld de, .foundword 
2135				ld a, display_row_3 
2135				call str_at_display 
2135				call update_display 
2135				call delay1s 
2135				call delay1s 
2135				call delay1s 
2135			endif 
2135			 
2135			if DEBUG_FORTH_PARSE_KEY 
2135						DMARK "KYj" 
2135			endif 
2135				; TODO save the word pointer in this exec 
2135			 
2135 2a 2c f8			ld hl,(cli_execword) 
2138 e9				jp (hl) 
2139			 
2139			 
2139			;    if not same 
2139			;	scan for zero term 
2139			;	get ptr for next word 
2139			;	goto word comp 
2139			 
2139			.execpnskipword:	; get pointer to next word 
2139 2a 2a f8			ld hl,(cli_nextword) 
213c			 
213c 7e				ld a,(hl) 
213d fe 00			cp WORD_SYS_END 
213f			;	cp 0 
213f 28 09			jr z, .execendofdict			 ; at end of words 
2141			 
2141			if DEBUG_FORTH_PARSE_KEY 
2141						DMARK "KY4" 
2141			endif 
2141			if DEBUG_FORTH_PARSE_EXEC 
2141			 
2141				; see if disabled 
2141			 
2141				ld a, (os_view_disable) 
2141				cp '*' 
2141				jr z, .noskip 
2141			 
2141			 
2141				ld de, .nowordfound 
2141				ld a, display_row_3 
2141				call str_at_display 
2141				call update_display 
2141				ld a, 100 
2141				call aDelayInMS 
2141				 
2141				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2141					call delay250ms 
2141				endif 
2141			.noskip:  
2141			 
2141			endif	 
2141			 
2141 2a 26 f8			ld hl,(cli_origptr) 
2144 22 28 f8			ld (cli_ptr),hl 
2147			 
2147			if DEBUG_FORTH_PARSE_KEY 
2147						DMARK "KY5" 
2147			endif 
2147 c3 ed 20			jp .execpnword			; else go to next word 
214a			 
214a			.execendofdict:  
214a			 
214a			if DEBUG_FORTH_PARSE_KEY 
214a						DMARK "KYe" 
214a			endif 
214a			if DEBUG_FORTH_PARSE_EXEC 
214a				; see if disabled 
214a			 
214a				ld a, (os_view_disable) 
214a				cp '*' 
214a				jr z, .ispskip 
214a			 
214a				call clear_display 
214a				call update_display 
214a				call delay1s 
214a				ld de, (cli_origptr) 
214a				ld a, display_row_1 
214a				call str_at_display 
214a				 
214a				ld de, .enddict 
214a				ld a, display_row_3 
214a				call str_at_display 
214a				call update_display 
214a				ld a, 100 
214a				call aDelayInMS 
214a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
214a				call delay1s 
214a				call delay1s 
214a				call delay1s 
214a				endif 
214a			.ispskip:  
214a				 
214a			endif	 
214a			 
214a			 
214a			 
214a				; if the word is not a keyword then must be a literal so push it to stack 
214a			 
214a			; push token to stack to end of word 
214a			 
214a				STACKFRAME ON $1efe $2f9f 
214a				if DEBUG_STACK_IMB 
214a					if ON 
214a						exx 
214a						ld de, $1efe 
214a						ld a, d 
214a						ld hl, curframe 
214a						call hexout 
214a						ld a, e 
214a						ld hl, curframe+2 
214a						call hexout 
214a						ld hl, $1efe 
214a						push hl 
214a						ld hl, $2f9f 
214a						push hl 
214a						exx 
214a					endif 
214a				endif 
214a			endm 
# End of macro STACKFRAME
214a			 
214a 2a 1e f1		ld hl,(os_tok_ptr) 
214d cd 42 1e		call forth_apush 
2150			 
2150				STACKFRAMECHK ON $1efe $2f9f 
2150				if DEBUG_STACK_IMB 
2150					if ON 
2150						exx 
2150						ld hl, $2f9f 
2150						pop de   ; $2f9f 
2150						call cmp16 
2150						jr nz, .spnosame 
2150						ld hl, $1efe 
2150						pop de   ; $1efe 
2150						call cmp16 
2150						jr z, .spfrsame 
2150						.spnosame: call showsperror 
2150						.spfrsame: nop 
2150						exx 
2150					endif 
2150				endif 
2150			endm 
# End of macro STACKFRAMECHK
2150			 
2150			execnext: 
2150			 
2150			if DEBUG_FORTH_PARSE_KEY 
2150						DMARK "KY>" 
2150			endif 
2150			; move past token to next word 
2150			 
2150 2a 1e f1		ld hl, (os_tok_ptr) 
2153 3e 00		ld a, 0 
2155 01 ff 00		ld bc, 255     ; input buffer size 
2158 ed b1		cpir 
215a			 
215a			if DEBUG_FORTH_PARSE_KEY 
215a						DMARK "KY!" 
215a				CALLMONITOR 
215a			endif	 
215a			; TODO this might place hl on the null, so will need to forward on??? 
215a			;inc hl   ; see if this gets onto the next item 
215a			 
215a			 
215a			; TODO pass a pointer to the buffer to push 
215a			; TODO call function to push 
215a			 
215a			; look for end of input 
215a			 
215a			;inc hl 
215a			;ld a,(hl) 
215a			;cp FORTH_END_BUFFER 
215a			;ret z 
215a			 
215a			 
215a c3 d3 20		jp exec1 
215d			 
215d			 
215d			 
215d			 
215d			 
215d			 
215d			 
215d			 
215d			 
215d			findnexttok: 
215d			 
215d				; hl is pointer to move 
215d				; de is the token to locate 
215d			 
215d					if DEBUG_FORTH 
215d						DMARK "NTK" 
215d						CALLMONITOR 
215d					endif 
215d d5				push de 
215e			 
215e			.fnt1:	 
215e				; find first char of token to locate 
215e			 
215e 1a				ld a, (de) 
215f 4f				ld c,a 
2160 7e				ld a,(hl) 
2161 cd 61 11			call toUpper 
2164					if DEBUG_FORTH 
2164						DMARK "NT1" 
2164						CALLMONITOR 
2164					endif 
2164 b9				cp c 
2165			 
2165 28 03			jr z, .fnt2cmpmorefirst	 
2167			 
2167				; first char not found move to next char 
2167			 
2167 23				inc hl 
2168 18 f4			jr .fnt1 
216a			 
216a			.fnt2cmpmorefirst:	 
216a				; first char of token found.  
216a			 
216a e5				push hl     ; save start of token just in case it is the right one 
216b d9				exx 
216c e1				pop hl        ; save it to hl' 
216d d9				exx 
216e			 
216e			 
216e			.fnt2cmpmore:	 
216e				; compare the rest 
216e				 
216e 23				inc hl 
216f 13				inc de 
2170				 
2170 1a				ld a, (de) 
2171 4f				ld c,a 
2172 7e				ld a,(hl) 
2173 cd 61 11			call toUpper 
2176			 
2176					if DEBUG_FORTH 
2176						DMARK "NT2" 
2176						CALLMONITOR 
2176					endif 
2176				; c has the token to find char 
2176				; a has the mem to scan char 
2176			 
2176 b9				cp c 
2177 28 04			jr z,.fntmatch1 
2179			 
2179				; they are not the same 
2179			 
2179					if DEBUG_FORTH 
2179						DMARK "NT3" 
2179						CALLMONITOR 
2179					endif 
2179 d1				pop de	; reset de token to look for 
217a d5				push de 
217b 18 e1			jr .fnt1 
217d				 
217d			.fntmatch1: 
217d			 
217d				; is the same char a null which means we might have a full hit? 
217d					if DEBUG_FORTH 
217d						DMARK "NT4" 
217d						CALLMONITOR 
217d					endif 
217d			 
217d fe 00			cp 0 
217f 28 0b			jr z, .fntmatchyes 
2181			 
2181				; are we at the end of the token to find? 
2181			 
2181					if DEBUG_FORTH 
2181						DMARK "NT5" 
2181						CALLMONITOR 
2181					endif 
2181 3e 00			ld a, 0 
2183 b9				cp c 
2184			 
2184 c2 6e 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2187			 
2187					if DEBUG_FORTH 
2187						DMARK "NT6" 
2187						CALLMONITOR 
2187					endif 
2187				; token to find is exhusted but no match to stream 
2187			 
2187				; restore tok pointer and continue on 
2187 d1				pop de 
2188 d5				push de 
2189 c3 5e 21			jp .fnt1 
218c			 
218c			 
218c			.fntmatchyes: 
218c			 
218c				; hl now contains the end of the found token 
218c			 
218c				; get rid of saved token pointer to find 
218c			 
218c d1				pop de 
218d			 
218d					if DEBUG_FORTH 
218d						DMARK "NT9" 
218d						CALLMONITOR 
218d					endif 
218d			 
218d				; hl will be on the null term so forward on 
218d			 
218d				; get back the saved start of the token 
218d			 
218d d9				exx 
218e e5				push hl     ; save start of token just in case it is the right one 
218f d9				exx 
2190 e1				pop hl        ; save it to hl 
2191			 
2191 c9				ret 
2192			 
2192			 
2192			; LIST needs to find a specific token   
2192			; FORGET needs to find a spefici token 
2192			 
2192			; SAVE needs to find all tokens by flag 
2192			; WORDS just needs to scan through all  by flag 
2192			; UWORDS needs to scan through all by flag 
2192			 
2192			 
2192			; given hl as pointer to start of dict look up string 
2192			; return hl as pointer to start of word block 
2192			; or 0 if not found 
2192			 
2192			forth_find_tok: 
2192 c9				ret 
2193			 
2193			; given hl as pointer to dict structure 
2193			; move to the next dict block structure 
2193			 
2193			forth_tok_next: 
2193				; hl now points to the address of the next word pointer  
2193				; TODO skip compiled symbol for now 
2193			;	push de 
2193 23				inc hl 
2194 5e				ld e, (hl) 
2195 23				inc hl 
2196 56				ld d, (hl) 
2197 23				inc hl 
2198			 
2198 eb				ex de,hl 
2199			if DEBUG_FORTH_PARSE_NEXTWORD 
2199				push bc 
2199				ld bc, (cli_nextword) 
2199						DMARK "NXW" 
2199				CALLMONITOR 
2199				pop bc 
2199			endif 
2199			;	pop de	 
2199 c9				ret 
219a			 
219a			 
219a			 
219a			; eof 
# End of file forth_parserv5.asm
219a				include "forth_wordsv4.asm" 
219a			 
219a			; the core word dictionary v4 
219a			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
219a			 
219a			; this is a linked list for each of the system words used 
219a			; user defined words will follow the same format but will be in ram 
219a			 
219a			 
219a			; 
219a			; 
219a			; define linked list: 
219a			; 
219a			; 1. compiled byte op code 
219a			; 2. len of text word 
219a			; 3. text word 
219a			; 4. ptr to next dictionary word 
219a			; 5. asm, calls etc for the word 
219a			; 
219a			;  if 1 == 0 then last word in dict  
219a			;   
219a			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
219a			;  
219a			;  
219a			; create basic standard set of words 
219a			; 
219a			;  
219a			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
219a			; 2DUP 2DROP 2SWAP  
219a			; @ C@ - get byte  
219a			; ! C! - store byte 
219a			; 0< true if less than zero 
219a			; 0= true if zero 
219a			; < >  
219a			; = true if same 
219a			; variables 
219a			 
219a			 
219a			; Hardware specific words I may need 
219a			; 
219a			; IN OUT  
219a			; calls to key util functions 
219a			; calls to hardward abstraction stuff 
219a			; easy control of frame buffers and lcd i/o 
219a			; keyboard  
219a			 
219a			 
219a			;DICT: macro 
219a			; op_code, len, word, next 
219a			;    word: 
219a			;    db op_code 
219a			;    ds word zero term 
219a			;    dw next 
219a			;    endm 
219a			 
219a			 
219a			 
219a			 
219a			; op code 1 is a flag for user define words which are to be handled differently 
219a			 
219a			 
219a			; 
219a			; 
219a			;    TODO on entry to a word this should be the expected environment 
219a			;    hl - tos value if number then held, if string this is the ptr 
219a			;    de -  
219a			 
219a			 
219a			; opcode ranges 
219a			; 0 - end of word dict 
219a			; 255 - user define words 
219a			 
219a			sysdict: 
219a			include "forth_opcodes.asm" 
219a			; op codes for forth keywords 
219a			; free to use code 0  
219a				OPCODE_HEAP: equ  1 
219a				OPCODE_EXEC: equ 2 
219a				OPCODE_DUP: equ 3 
219a				OPCODE_SWAP: equ 4 
219a				OPCODE_COLN: equ 5 
219a				OPCODE_SCOLN: equ 6 
219a				OPCODE_DROP: equ 7 
219a				OPCODE_DUP2: equ 8 
219a				OPCODE_DROP2: equ 9 
219a				OPCODE_SWAP2: equ 10 
219a				OPCODE_AT: equ 11 
219a				OPCODE_CAT: equ 12 
219a				OPCODE_BANG: equ 13 
219a				OPCODE_CBANG: equ 14 
219a				OPCODE_SCALL: equ 15 
219a				OPCODE_DEPTH: equ 16 
219a				OPCODE_OVER: equ 17 
219a				OPCODE_PAUSE: equ 18 
219a				OPCODE_PAUSES: equ 19 
219a				OPCODE_ROT: equ 20 
219a			;free to reuse	OPCODE_WORDS: equ 21 
219a			        OPCODE_NOT: equ 21 
219a				OPCODE_UWORDS: equ 22 
219a				OPCODE_BP: equ 23 
219a				OPCODE_MONITOR: equ 24  
219a				OPCODE_MALLOC: equ 25 
219a				OPCODE_FREE: equ 26 
219a				OPCODE_LIST: equ 27 
219a				OPCODE_FORGET: equ 28 
219a				OPCODE_NOP: equ 29 
219a				OPCODE_COMO: equ 30 
219a				OPCODE_COMC: equ 31 
219a			;free to reuse	OPCODE_ENDCORE: equ 32 
219a				OPCODE_AFTERSOUND: equ 33 
219a				OPCODE_GP2: equ 34 
219a				OPCODE_GP3: equ 35 
219a				OPCODE_GP4: equ 36 
219a				OPCODE_SIN: equ 37 
219a				OPCODE_SOUT: equ 38 
219a				OPCODE_SPIO: equ 39 
219a				OPCODE_SPICEH: equ 40 
219a				OPCODE_SPIOb: equ 41 
219a				OPCODE_SPII: equ 42 
219a				OPCODE_SESEL: equ 43 
219a				OPCODE_CARTDEV: equ 44 
219a			; free to reuse	OPCODE_ENDDEVICE: equ 45 
219a				OPCODE_FB: equ 46 
219a				OPCODE_EMIT: equ 47 
219a				OPCODE_DOTH: equ 48 
219a				OPCODE_DOTF: equ 49 
219a				OPCODE_DOT: equ 50 
219a				OPCODE_CLS: equ 51 
219a				OPCODE_DRAW: equ 52 
219a				OPCODE_DUMP: equ 53 
219a				OPCODE_CDUMP: equ 54 
219a				OPCODE_DAT: equ 55 
219a				OPCODE_HOME: equ 56 
219a				OPCODE_SPACE: equ 57 
219a				OPCODE_SPACES: equ 58 
219a				OPCODE_SCROLL: equ 59 
219a				OPCODE_ATQ: equ 60 
219a				OPCODE_AUTODSP: equ 61 
219a				OPCODE_MENU: equ 62 
219a			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
219a				OPCODE_THEN: equ 64 
219a				OPCODE_ELSE: equ 65 
219a				OPCODE_DO: equ 66 
219a				OPCODE_LOOP: equ 67 
219a				OPCODE_I: equ 68 
219a				OPCODE_DLOOP: equ 69  
219a				OPCODE_REPEAT: equ 70  
219a				OPCODE_UNTIL: equ 71 
219a				OPCODE_ENDFLOW: equ 72 
219a				OPCODE_WAITK: equ 73 
219a				OPCODE_ACCEPT: equ 74 
219a				OPCODE_EDIT: equ 75 
219a			;free to reuse	OPCODE_ENDKEY: equ 76 
219a				OPCODE_LZERO: equ 77 
219a				OPCODE_TZERO: equ 78 
219a				OPCODE_LESS: equ 79 
219a				OPCODE_GT: equ 80 
219a				OPCODE_EQUAL: equ 81  
219a			;free to reuse	OPCODE_ENDLOGIC: equ 82 
219a				OPCODE_NEG: equ 83 
219a				OPCODE_DIV: equ 84 
219a				OPCODE_MUL: equ 85 
219a				OPCODE_MIN: equ 86 
219a				OPCODE_MAX: equ 87 
219a				OPCODE_RND16: equ 88 
219a				OPCODE_RND8: equ 89 
219a				OPCODE_RND: equ 90 
219a			;free to reuse	OPCODE_ENDMATHS: equ 91  
219a				OPCODE_BYNAME: equ 92 
219a				OPCODE_DIR: equ 93 
219a				OPCODE_SAVE: equ 94 
219a				OPCODE_LOAD: equ 95 
219a				OPCODE_BSAVE: equ 96 
219a				OPCODE_BLOAD: equ 97 
219a				OPCODE_SEO: equ 98  
219a				OPCODE_SEI: equ 99 
219a				OPCODE_SFREE: equ 100 
219a				OPCODE_SIZE: equ 101 
219a				OPCODE_CREATE: equ 102 
219a				OPCODE_APPEND: equ 103 
219a				OPCODE_SDEL: equ 104 
219a				OPCODE_OPEN: equ 105 
219a				OPCODE_READ: equ 106 
219a				OPCODE_EOF: equ 106 
219a				OPCODE_FORMAT: equ 107 
219a				OPCODE_LABEL: equ 108 
219a				OPCODE_LABELS: equ 109 
219a			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
219a				OPCODE_UPPER: equ 111 
219a				OPCODE_LOWER: equ 112 
219a				OPCODE_SUBSTR: equ 113 
219a				OPCODE_LEFT: equ 114 
219a				OPCODE_RIGHT: equ 115 
219a				OPCODE_STR2NUM: equ 116 
219a				OPCODE_NUM2STR: equ 117 
219a				OPCODE_CONCAT: equ 118 
219a				OPCODE_FIND: equ 119 
219a				OPCODE_LEN: equ 120 
219a				OPCODE_CHAR: equ 121 
219a			; free to reuse	OPCODE_STRLEN: equ 122 
219a			; free to reuse	OPCODE_ENDSTR: equ 123 
219a				OPCODE_V0S: equ 124 
219a				OPCODE_V0Q: equ 125 
219a				OPCODE_V1S: equ 126 
219a				OPCODE_V1Q: equ 127 
219a				OPCODE_V2S: equ 128 
219a				OPCODE_V2Q: equ 129 
219a				OPCODE_V3S: equ 130 
219a				OPCODE_V3Q: equ 131 
219a			;free to reuse	OPCODE_END: equ 132 
219a				OPCODE_ZDUP: equ 133 
219a			 
219a			; eof 
# End of file forth_opcodes.asm
219a			 
219a			include "forth_words_core.asm" 
219a			 
219a			; | ## Core Words 
219a			 
219a			;if MALLOC_4 
219a			 
219a			.HEAP: 
219a				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
219a 15				db WORD_SYS_CORE+OPCODE_HEAP             
219b d9 21			dw .EXEC            
219d 05				db 4 + 1 
219e .. 00			db "HEAP",0              
21a3				endm 
# End of macro CWHEAD
21a3			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21a3			; | | u1 - Current number of bytes in the heap 
21a3			; | | u2 - Remaining bytes left on the heap 
21a3			; | |  
21a3			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21a3			 
21a3			 
21a3					if DEBUG_FORTH_WORDS_KEY 
21a3						DMARK "HEP" 
21a3 f5				push af  
21a4 3a b8 21			ld a, (.dmark)  
21a7 32 77 fb			ld (debug_mark),a  
21aa 3a b9 21			ld a, (.dmark+1)  
21ad 32 78 fb			ld (debug_mark+1),a  
21b0 3a ba 21			ld a, (.dmark+2)  
21b3 32 79 fb			ld (debug_mark+2),a  
21b6 18 03			jr .pastdmark  
21b8 ..			.dmark: db "HEP"  
21bb f1			.pastdmark: pop af  
21bc			endm  
# End of macro DMARK
21bc						CALLMONITOR 
21bc cd 49 17			call break_point_state  
21bf				endm  
# End of macro CALLMONITOR
21bf					endif 
21bf 2a 0a 80				ld hl, (free_list )      
21c2 11 0e 80				ld de, heap_start 
21c5			 
21c5 ed 52				sbc hl, de  
21c7			 
21c7 cd d9 1c				call forth_push_numhl 
21ca			 
21ca			 
21ca ed 5b 0a 80			ld de, (free_list )      
21ce 21 03 ee				ld hl, heap_end 
21d1			 
21d1 ed 52				sbc hl, de 
21d3			 
21d3 cd d9 1c				call forth_push_numhl 
21d6					 
21d6			 
21d6					 
21d6			 
21d6			 
21d6			 
21d6					NEXTW 
21d6 c3 42 20			jp macro_next 
21d9				endm 
# End of macro NEXTW
21d9			;endif 
21d9			 
21d9			.EXEC: 
21d9			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
21d9			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
21d9			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
21d9			;; > > 
21d9			;; > >   
21d9			;	STACKFRAME OFF $5efe $5f9f 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS_KEY 
21d9			;			DMARK "EXE" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			; 
21d9			;	FORTH_DSP_VALUEHL 
21d9			; 
21d9			;	FORTH_DSP_POP 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX1" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;;	ld e,(hl) 
21d9			;;	inc hl 
21d9			;;	ld d,(hl) 
21d9			;;	ex de,hl 
21d9			; 
21d9			;;		if DEBUG_FORTH_WORDS 
21d9			;;			DMARK "EX2" 
21d9			;;			CALLMONITOR 
21d9			;;		endif 
21d9			;	push hl 
21d9			; 
21d9			;	;ld a, 0 
21d9			;	;ld a, FORTH_END_BUFFER 
21d9			;	call strlenz 
21d9			;	inc hl   ; include zero term to copy 
21d9			;	inc hl   ; include term 
21d9			;	inc hl   ; include term 
21d9			;	ld b,0 
21d9			;	ld c,l 
21d9			;	pop hl 
21d9			;	ld de, execscratch 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX3" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	ldir 
21d9			; 
21d9			; 
21d9			;	ld hl, execscratch 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EXe" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			; 
21d9			;	call forthparse 
21d9			;	call forthexec 
21d9			;;	call forthexec_cleanup 
21d9			;;	call forthparse 
21d9			;;	call forthexec 
21d9			; 
21d9			;	STACKFRAMECHK OFF $5efe $5f9f 
21d9			; 
21d9			;	; an immediate word so no need to process any more words 
21d9			;	ret 
21d9			;	NEXTW 
21d9			 
21d9			; dead code - old version  
21d9			;	FORTH_RSP_NEXT 
21d9			 
21d9			;  
21d9			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
21d9			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
21d9			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
21d9			;	push hl 
21d9			;	push de 
21d9			;	push bc 
21d9			; 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS_KEY 
21d9			;			DMARK "EXR" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			; 
21d9			; 
21d9			; 
21d9			;	;v5 FORTH_DSP_VALUE 
21d9			;	FORTH_DSP_VALUEHL 
21d9			; 
21d9			;	; TODO do string type checks 
21d9			; 
21d9			;;v5	inc hl   ; skip type 
21d9			; 
21d9			;	push hl  ; source code  
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX1" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	ld a, 0 
21d9			;	call strlent 
21d9			; 
21d9			;	inc hl 
21d9			;	inc hl 
21d9			;	inc hl 
21d9			;	inc hl 
21d9			; 
21d9			;	push hl    ; size 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX2" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	call malloc 
21d9			; 
21d9			;	ex de, hl    ; de now contains malloc area 
21d9			;	pop bc   	; get byte count 
21d9			;	pop hl      ; get string to copy 
21d9			; 
21d9			;	push de     ; save malloc for free later 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX3" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	ldir       ; duplicate string 
21d9			; 
21d9			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
21d9			;	 
21d9			;	; TODO fix the parse would be better than this...  
21d9			;	ex de, hl 
21d9			;	dec hl 
21d9			;	ld a, 0 
21d9			;	ld (hl), a 
21d9			;	dec hl 
21d9			;	ld a, ' ' 
21d9			;	ld (hl), a 
21d9			;	dec hl 
21d9			;	ld (hl), a 
21d9			; 
21d9			;	dec hl 
21d9			;	ld (hl), a 
21d9			; 
21d9			; 
21d9			;	FORTH_DSP_POP  
21d9			; 
21d9			;	pop hl     
21d9			;	push hl    ; save malloc area 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX4" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			; 
21d9			;	call forthparse 
21d9			;	call forthexec 
21d9			;	 
21d9			;	pop hl 
21d9			;	if DEBUG_FORTH_WORDS 
21d9			;		DMARK "EX5" 
21d9			;		CALLMONITOR 
21d9			;	endif 
21d9			; 
21d9			;	if FORTH_ENABLE_FREE 
21d9			;	call free 
21d9			;	endif 
21d9			; 
21d9			;	if DEBUG_FORTH_WORDS 
21d9			;		DMARK "EX6" 
21d9			;		CALLMONITOR 
21d9			;	endif 
21d9			; 
21d9			;	pop bc 
21d9			;	pop de 
21d9			;	pop hl 
21d9			;;	FORTH_RSP_POP	  
21d9			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
21d9			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
21d9			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
21d9			; 
21d9			;	if DEBUG_FORTH_WORDS 
21d9			;		DMARK "EX7" 
21d9			;		CALLMONITOR 
21d9			;	endif 
21d9			;	NEXTW 
21d9			 
21d9			;.STKEXEC: 
21d9			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
21d9			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
21d9			; 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS_KEY 
21d9			;			DMARK "STX" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			; 
21d9			;	FORTH_DSP_VALUEHL 
21d9			; 
21d9			;	ld (store_tmp1), hl    ; count 
21d9			; 
21d9			;	FORTH_DSP_POP 
21d9			;.stkexec1: 
21d9			;	ld hl, (store_tmp1)   ; count 
21d9			;	ld a, 0 
21d9			;	cp l 
21d9			;	ret z 
21d9			; 
21d9			;	dec hl 
21d9			;	ld (store_tmp1), hl    ; count 
21d9			;	 
21d9			;	FORTH_DSP_VALUEHL 
21d9			;	push hl 
21d9			;	 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EXp" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	FORTH_DSP_POP 
21d9			; 
21d9			;	call strlenz 
21d9			;	inc hl   ; include zero term to copy 
21d9			;	inc hl   ; include zero term to copy 
21d9			;	inc hl   ; include zero term to copy 
21d9			;	ld b,0 
21d9			;	ld c,l 
21d9			;	pop hl 
21d9			;	ld de, execscratch 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EX3" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	ldir 
21d9			; 
21d9			; 
21d9			;	ld hl, execscratch 
21d9			; 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EXP" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			; 
21d9			;	call forthparse 
21d9			;	ld hl, execscratch 
21d9			;		if DEBUG_FORTH_WORDS 
21d9			;			DMARK "EXx" 
21d9			;			CALLMONITOR 
21d9			;		endif 
21d9			;	call forthexec 
21d9			; 
21d9			;	jp .stkexec1 
21d9			; 
21d9			;	ret 
21d9			 
21d9			 
21d9			.DUP: 
21d9				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
21d9 17				db WORD_SYS_CORE+OPCODE_DUP             
21da 4f 22			dw .ZDUP            
21dc 04				db 3 + 1 
21dd .. 00			db "DUP",0              
21e1				endm 
# End of macro CWHEAD
21e1			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21e1			 
21e1					if DEBUG_FORTH_WORDS_KEY 
21e1						DMARK "DUP" 
21e1 f5				push af  
21e2 3a f6 21			ld a, (.dmark)  
21e5 32 77 fb			ld (debug_mark),a  
21e8 3a f7 21			ld a, (.dmark+1)  
21eb 32 78 fb			ld (debug_mark+1),a  
21ee 3a f8 21			ld a, (.dmark+2)  
21f1 32 79 fb			ld (debug_mark+2),a  
21f4 18 03			jr .pastdmark  
21f6 ..			.dmark: db "DUP"  
21f9 f1			.pastdmark: pop af  
21fa			endm  
# End of macro DMARK
21fa						CALLMONITOR 
21fa cd 49 17			call break_point_state  
21fd				endm  
# End of macro CALLMONITOR
21fd					endif 
21fd			 
21fd					FORTH_DSP 
21fd cd 96 1e			call macro_forth_dsp 
2200				endm 
# End of macro FORTH_DSP
2200			 
2200 7e					ld a, (HL) 
2201 fe 01				cp DS_TYPE_STR 
2203 20 25				jr nz, .dupinum 
2205			 
2205					; push another string 
2205			 
2205					FORTH_DSP_VALUEHL     		 
2205 cd d0 1e			call macro_dsp_valuehl 
2208				endm 
# End of macro FORTH_DSP_VALUEHL
2208			 
2208				if DEBUG_FORTH_WORDS 
2208					DMARK "DUs" 
2208 f5				push af  
2209 3a 1d 22			ld a, (.dmark)  
220c 32 77 fb			ld (debug_mark),a  
220f 3a 1e 22			ld a, (.dmark+1)  
2212 32 78 fb			ld (debug_mark+1),a  
2215 3a 1f 22			ld a, (.dmark+2)  
2218 32 79 fb			ld (debug_mark+2),a  
221b 18 03			jr .pastdmark  
221d ..			.dmark: db "DUs"  
2220 f1			.pastdmark: pop af  
2221			endm  
# End of macro DMARK
2221					CALLMONITOR 
2221 cd 49 17			call break_point_state  
2224				endm  
# End of macro CALLMONITOR
2224				endif 
2224 cd 47 1d				call forth_push_str 
2227			 
2227					NEXTW 
2227 c3 42 20			jp macro_next 
222a				endm 
# End of macro NEXTW
222a			 
222a			 
222a			.dupinum: 
222a					 
222a			 
222a			 
222a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
222a cd d0 1e			call macro_dsp_valuehl 
222d				endm 
# End of macro FORTH_DSP_VALUEHL
222d			 
222d				; TODO add floating point number detection 
222d			 
222d				if DEBUG_FORTH_WORDS 
222d					DMARK "DUi" 
222d f5				push af  
222e 3a 42 22			ld a, (.dmark)  
2231 32 77 fb			ld (debug_mark),a  
2234 3a 43 22			ld a, (.dmark+1)  
2237 32 78 fb			ld (debug_mark+1),a  
223a 3a 44 22			ld a, (.dmark+2)  
223d 32 79 fb			ld (debug_mark+2),a  
2240 18 03			jr .pastdmark  
2242 ..			.dmark: db "DUi"  
2245 f1			.pastdmark: pop af  
2246			endm  
# End of macro DMARK
2246					CALLMONITOR 
2246 cd 49 17			call break_point_state  
2249				endm  
# End of macro CALLMONITOR
2249				endif 
2249			 
2249 cd d9 1c				call forth_push_numhl 
224c					NEXTW 
224c c3 42 20			jp macro_next 
224f				endm 
# End of macro NEXTW
224f			.ZDUP: 
224f				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
224f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2250 87 22			dw .SWAP            
2252 05				db 4 + 1 
2253 .. 00			db "?DUP",0              
2258				endm 
# End of macro CWHEAD
2258			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2258			 
2258					if DEBUG_FORTH_WORDS_KEY 
2258						DMARK "qDU" 
2258 f5				push af  
2259 3a 6d 22			ld a, (.dmark)  
225c 32 77 fb			ld (debug_mark),a  
225f 3a 6e 22			ld a, (.dmark+1)  
2262 32 78 fb			ld (debug_mark+1),a  
2265 3a 6f 22			ld a, (.dmark+2)  
2268 32 79 fb			ld (debug_mark+2),a  
226b 18 03			jr .pastdmark  
226d ..			.dmark: db "qDU"  
2270 f1			.pastdmark: pop af  
2271			endm  
# End of macro DMARK
2271						CALLMONITOR 
2271 cd 49 17			call break_point_state  
2274				endm  
# End of macro CALLMONITOR
2274					endif 
2274					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2274 cd d0 1e			call macro_dsp_valuehl 
2277				endm 
# End of macro FORTH_DSP_VALUEHL
2277			 
2277 e5					push hl 
2278			 
2278					; is it a zero? 
2278			 
2278 3e 00				ld a, 0 
227a 84					add h 
227b 85					add l 
227c			 
227c e1					pop hl 
227d			 
227d fe 00				cp 0 
227f 28 03				jr z, .dup2orig 
2281			 
2281			 
2281 cd d9 1c				call forth_push_numhl 
2284			 
2284			 
2284				; TODO add floating point number detection 
2284			 
2284			.dup2orig: 
2284			 
2284					NEXTW 
2284 c3 42 20			jp macro_next 
2287				endm 
# End of macro NEXTW
2287			.SWAP: 
2287				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2287 18				db WORD_SYS_CORE+OPCODE_SWAP             
2288 c6 22			dw .COLN            
228a 05				db 4 + 1 
228b .. 00			db "SWAP",0              
2290				endm 
# End of macro CWHEAD
2290			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2290					if DEBUG_FORTH_WORDS_KEY 
2290						DMARK "SWP" 
2290 f5				push af  
2291 3a a5 22			ld a, (.dmark)  
2294 32 77 fb			ld (debug_mark),a  
2297 3a a6 22			ld a, (.dmark+1)  
229a 32 78 fb			ld (debug_mark+1),a  
229d 3a a7 22			ld a, (.dmark+2)  
22a0 32 79 fb			ld (debug_mark+2),a  
22a3 18 03			jr .pastdmark  
22a5 ..			.dmark: db "SWP"  
22a8 f1			.pastdmark: pop af  
22a9			endm  
# End of macro DMARK
22a9						CALLMONITOR 
22a9 cd 49 17			call break_point_state  
22ac				endm  
# End of macro CALLMONITOR
22ac					endif 
22ac			 
22ac					FORTH_DSP_VALUEHL 
22ac cd d0 1e			call macro_dsp_valuehl 
22af				endm 
# End of macro FORTH_DSP_VALUEHL
22af e5					push hl     ; w2 
22b0			 
22b0					FORTH_DSP_POP 
22b0 cd 88 1f			call macro_forth_dsp_pop 
22b3				endm 
# End of macro FORTH_DSP_POP
22b3			 
22b3					FORTH_DSP_VALUEHL 
22b3 cd d0 1e			call macro_dsp_valuehl 
22b6				endm 
# End of macro FORTH_DSP_VALUEHL
22b6			 
22b6					FORTH_DSP_POP 
22b6 cd 88 1f			call macro_forth_dsp_pop 
22b9				endm 
# End of macro FORTH_DSP_POP
22b9			 
22b9 d1					pop de     ; w2	, hl = w1 
22ba			 
22ba eb					ex de, hl 
22bb d5					push de 
22bc			 
22bc cd d9 1c				call forth_push_numhl 
22bf			 
22bf e1					pop hl 
22c0			 
22c0 cd d9 1c				call forth_push_numhl 
22c3					 
22c3			 
22c3					NEXTW 
22c3 c3 42 20			jp macro_next 
22c6				endm 
# End of macro NEXTW
22c6			.COLN: 
22c6				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22c6 19				db WORD_SYS_CORE+OPCODE_COLN             
22c7 52 24			dw .SCOLN            
22c9 02				db 1 + 1 
22ca .. 00			db ":",0              
22cc				endm 
# End of macro CWHEAD
22cc			; | : ( -- )         Create new word | DONE 
22cc			 
22cc					if DEBUG_FORTH_WORDS_KEY 
22cc						DMARK "CLN" 
22cc f5				push af  
22cd 3a e1 22			ld a, (.dmark)  
22d0 32 77 fb			ld (debug_mark),a  
22d3 3a e2 22			ld a, (.dmark+1)  
22d6 32 78 fb			ld (debug_mark+1),a  
22d9 3a e3 22			ld a, (.dmark+2)  
22dc 32 79 fb			ld (debug_mark+2),a  
22df 18 03			jr .pastdmark  
22e1 ..			.dmark: db "CLN"  
22e4 f1			.pastdmark: pop af  
22e5			endm  
# End of macro DMARK
22e5						CALLMONITOR 
22e5 cd 49 17			call break_point_state  
22e8				endm  
# End of macro CALLMONITOR
22e8					endif 
22e8				STACKFRAME OFF $8efe $989f 
22e8				if DEBUG_STACK_IMB 
22e8					if OFF 
22e8						exx 
22e8						ld de, $8efe 
22e8						ld a, d 
22e8						ld hl, curframe 
22e8						call hexout 
22e8						ld a, e 
22e8						ld hl, curframe+2 
22e8						call hexout 
22e8						ld hl, $8efe 
22e8						push hl 
22e8						ld hl, $989f 
22e8						push hl 
22e8						exx 
22e8					endif 
22e8				endif 
22e8			endm 
# End of macro STACKFRAME
22e8				; get parser buffer length  of new word 
22e8			 
22e8				 
22e8			 
22e8					; move tok past this to start of name defintition 
22e8					; TODO get word to define 
22e8					; TODO Move past word token 
22e8					; TODO get length of string up to the ';' 
22e8			 
22e8 2a 1e f1			ld hl, (os_tok_ptr) 
22eb 23				inc hl 
22ec 23				inc hl 
22ed			 
22ed 3e 3b			ld a, ';' 
22ef cd 75 11			call strlent 
22f2			 
22f2 7d				ld a,l 
22f3 32 19 ee			ld (os_new_parse_len), a 
22f6			 
22f6			 
22f6			if DEBUG_FORTH_UWORD 
22f6 ed 5b 1e f1		ld de, (os_tok_ptr) 
22fa						DMARK ":01" 
22fa f5				push af  
22fb 3a 0f 23			ld a, (.dmark)  
22fe 32 77 fb			ld (debug_mark),a  
2301 3a 10 23			ld a, (.dmark+1)  
2304 32 78 fb			ld (debug_mark+1),a  
2307 3a 11 23			ld a, (.dmark+2)  
230a 32 79 fb			ld (debug_mark+2),a  
230d 18 03			jr .pastdmark  
230f ..			.dmark: db ":01"  
2312 f1			.pastdmark: pop af  
2313			endm  
# End of macro DMARK
2313				CALLMONITOR 
2313 cd 49 17			call break_point_state  
2316				endm  
# End of macro CALLMONITOR
2316			endif 
2316			 
2316			; 
2316			;  new word memory layout: 
2316			;  
2316			;    : adg 6666 ;  
2316			; 
2316			;    db   1     ; user defined word  
2316 23				inc hl    
2317			;    dw   sysdict 
2317 23				inc hl 
2318 23				inc hl 
2319			;    db <word len>+1 (for null) 
2319 23				inc hl 
231a			;    db .... <word> 
231a			; 
231a			 
231a 23				inc hl    ; some extras for the word preamble before the above 
231b 23				inc hl 
231c 23				inc hl 
231d 23				inc hl 
231e 23				inc hl 
231f 23				inc hl 
2320 23				inc hl  
2321 23				inc hl 
2322 23				inc hl 
2323 23				inc hl 
2324 23				inc hl 
2325 23				inc hl 
2326 23				inc hl 
2327 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2328			;       exec word buffer 
2328			;	<ptr word>   
2328 23				inc hl 
2329 23				inc hl 
232a			;       <word list><null term> 7F final term 
232a			 
232a			 
232a			if DEBUG_FORTH_UWORD 
232a						DMARK ":02" 
232a f5				push af  
232b 3a 3f 23			ld a, (.dmark)  
232e 32 77 fb			ld (debug_mark),a  
2331 3a 40 23			ld a, (.dmark+1)  
2334 32 78 fb			ld (debug_mark+1),a  
2337 3a 41 23			ld a, (.dmark+2)  
233a 32 79 fb			ld (debug_mark+2),a  
233d 18 03			jr .pastdmark  
233f ..			.dmark: db ":02"  
2342 f1			.pastdmark: pop af  
2343			endm  
# End of macro DMARK
2343				CALLMONITOR 
2343 cd 49 17			call break_point_state  
2346				endm  
# End of macro CALLMONITOR
2346			endif 
2346			 
2346				 
2346					; malloc the size 
2346			 
2346 cd d3 11				call malloc 
2349 22 1b ee				ld (os_new_malloc), hl     ; save malloc start 
234c			 
234c			;    db   1     ; user defined word  
234c 3e 01				ld a, WORD_SYS_UWORD  
234e 77					ld (hl), a 
234f				 
234f 23				inc hl    
2350			;    dw   sysdict 
2350 11 9a 21			ld de, sysdict       ; continue on with the scan to the system dict 
2353 73				ld (hl), e 
2354 23				inc hl 
2355 72				ld (hl), d 
2356 23				inc hl 
2357			 
2357			 
2357			;    Setup dict word 
2357			 
2357 23				inc hl 
2358 22 15 ee			ld (os_new_work_ptr), hl     ; save start of dict word  
235b			 
235b				; 1. get length of dict word 
235b			 
235b			 
235b 2a 1e f1			ld hl, (os_tok_ptr) 
235e 23				inc hl 
235f 23				inc hl    ; position to start of dict word 
2360 3e 00			ld a, 0 
2362 cd 75 11			call strlent 
2365			 
2365			 
2365 23				inc hl    ; to include null??? 
2366			 
2366				; write length of dict word 
2366			 
2366 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
236a 1b				dec de 
236b eb				ex de, hl 
236c 73				ld (hl), e 
236d eb				ex de, hl 
236e			 
236e				 
236e			 
236e				; copy  
236e 4d				ld c, l 
236f 06 00			ld b, 0 
2371 ed 5b 15 ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2375 2a 1e f1			ld hl, (os_tok_ptr) 
2378 23				inc hl 
2379 23				inc hl    ; position to start of dict word 
237a				 
237a			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
237a				 
237a				; TODO need to convert word to upper case 
237a			 
237a			ucasetok:	 
237a 7e				ld a,(hl) 
237b cd 61 11			call toUpper 
237e 77				ld (hl),a 
237f ed a0			ldi 
2381 f2 7a 23		 	jp p, ucasetok 
2384			 
2384			 
2384			 
2384				; de now points to start of where the word body code should be placed 
2384 ed 53 15 ee		ld (os_new_work_ptr), de 
2388				; hl now points to the words to throw at forthexec which needs to be copied 
2388 22 13 ee			ld (os_new_src_ptr), hl 
238b			 
238b				; TODO add 'call to forthexec' 
238b			 
238b			if DEBUG_FORTH_UWORD 
238b c5				push bc 
238c ed 4b 1b ee		ld bc, (os_new_malloc) 
2390						DMARK ":0x" 
2390 f5				push af  
2391 3a a5 23			ld a, (.dmark)  
2394 32 77 fb			ld (debug_mark),a  
2397 3a a6 23			ld a, (.dmark+1)  
239a 32 78 fb			ld (debug_mark+1),a  
239d 3a a7 23			ld a, (.dmark+2)  
23a0 32 79 fb			ld (debug_mark+2),a  
23a3 18 03			jr .pastdmark  
23a5 ..			.dmark: db ":0x"  
23a8 f1			.pastdmark: pop af  
23a9			endm  
# End of macro DMARK
23a9				CALLMONITOR 
23a9 cd 49 17			call break_point_state  
23ac				endm  
# End of macro CALLMONITOR
23ac c1				pop bc 
23ad			endif 
23ad			 
23ad			 
23ad				; create word preamble which should be: 
23ad			 
23ad			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23ad			 
23ad				;    ld hl, <word code> 
23ad				;    jp user_exec 
23ad			        ;    <word code bytes> 
23ad			 
23ad			 
23ad			;	inc de     ; TODO ??? or are we already past the word's null 
23ad eb				ex de, hl 
23ae			 
23ae 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23b0			 
23b0 23				inc hl 
23b1 22 0f ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23b4 23				inc hl 
23b5			 
23b5 23				inc hl 
23b6 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23b8			 
23b8 01 d6 50			ld bc, user_exec 
23bb 23				inc hl 
23bc 71				ld (hl), c     ; poke address of user_exec 
23bd 23				inc hl 
23be 70				ld (hl), b     
23bf			 ; 
23bf			;	inc hl 
23bf			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23bf			; 
23bf			; 
23bf			;	ld bc, macro_forth_rsp_next 
23bf			;	inc hl 
23bf			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23bf			;	inc hl 
23bf			;	ld (hl), b     
23bf			 ; 
23bf			;	inc hl 
23bf			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23bf			; 
23bf			; 
23bf			;	inc hl 
23bf			;	ld bc, forthexec 
23bf			;	ld (hl), c     ; poke address of forthexec 
23bf			;	inc hl 
23bf			;	ld (hl), b      
23bf			; 
23bf			;	inc hl 
23bf			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23bf			; 
23bf			;	ld bc, user_dict_next 
23bf			;	inc hl 
23bf			;	ld (hl), c     ; poke address of forthexec 
23bf			;	inc hl 
23bf			;	ld (hl), b      
23bf			 
23bf				; hl is now where we need to copy the word byte data to save this 
23bf			 
23bf 23				inc hl 
23c0 22 11 ee			ld (os_new_exec), hl 
23c3				 
23c3				; copy definition 
23c3			 
23c3 eb				ex de, hl 
23c4			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23c4			;	inc de    ; skip the PC for this parse 
23c4 3a 19 ee			ld a, (os_new_parse_len) 
23c7 4f				ld c, a 
23c8 06 00			ld b, 0 
23ca ed b0			ldir		 ; copy defintion 
23cc			 
23cc			 
23cc				; poke the address of where the new word bytes live for forthexec 
23cc			 
23cc 2a 0f ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23cf			 
23cf ed 5b 11 ee		ld de, (os_new_exec)      
23d3				 
23d3 73				ld (hl), e 
23d4 23				inc hl 
23d5 72				ld (hl), d 
23d6			 
23d6					; TODO copy last user dict word next link to this word 
23d6					; TODO update last user dict word to point to this word 
23d6			; 
23d6			; hl f923 de 812a ; bc 811a 
23d6			 
23d6			if DEBUG_FORTH_UWORD 
23d6 c5				push bc 
23d7 ed 4b 1b ee		ld bc, (os_new_malloc) 
23db						DMARK ":0A" 
23db f5				push af  
23dc 3a f0 23			ld a, (.dmark)  
23df 32 77 fb			ld (debug_mark),a  
23e2 3a f1 23			ld a, (.dmark+1)  
23e5 32 78 fb			ld (debug_mark+1),a  
23e8 3a f2 23			ld a, (.dmark+2)  
23eb 32 79 fb			ld (debug_mark+2),a  
23ee 18 03			jr .pastdmark  
23f0 ..			.dmark: db ":0A"  
23f3 f1			.pastdmark: pop af  
23f4			endm  
# End of macro DMARK
23f4				CALLMONITOR 
23f4 cd 49 17			call break_point_state  
23f7				endm  
# End of macro CALLMONITOR
23f7 c1				pop bc 
23f8			endif 
23f8			if DEBUG_FORTH_UWORD 
23f8 c5				push bc 
23f9 ed 4b 1b ee		ld bc, (os_new_malloc) 
23fd 03				inc bc 
23fe 03				inc bc 
23ff 03				inc bc 
2400 03				inc bc 
2401 03				inc bc 
2402 03				inc bc 
2403 03				inc bc 
2404 03				inc bc 
2405			 
2405						DMARK ":0B" 
2405 f5				push af  
2406 3a 1a 24			ld a, (.dmark)  
2409 32 77 fb			ld (debug_mark),a  
240c 3a 1b 24			ld a, (.dmark+1)  
240f 32 78 fb			ld (debug_mark+1),a  
2412 3a 1c 24			ld a, (.dmark+2)  
2415 32 79 fb			ld (debug_mark+2),a  
2418 18 03			jr .pastdmark  
241a ..			.dmark: db ":0B"  
241d f1			.pastdmark: pop af  
241e			endm  
# End of macro DMARK
241e				CALLMONITOR 
241e cd 49 17			call break_point_state  
2421				endm  
# End of macro CALLMONITOR
2421 c1				pop bc 
2422			endif 
2422			 
2422			; update word dict linked list for new word 
2422			 
2422			 
2422 2a 1a f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2425 23			inc hl     ; move to next work linked list ptr 
2426			 
2426 ed 5b 1b ee	ld de, (os_new_malloc)		 ; new next word 
242a 73			ld (hl), e 
242b 23			inc hl 
242c 72			ld (hl), d 
242d			 
242d			if DEBUG_FORTH_UWORD 
242d ed 4b 1a f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2431			endif 
2431			 
2431 ed 53 1a f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2435			 
2435			 
2435			if DEBUG_FORTH_UWORD 
2435						DMARK ":0+" 
2435 f5				push af  
2436 3a 4a 24			ld a, (.dmark)  
2439 32 77 fb			ld (debug_mark),a  
243c 3a 4b 24			ld a, (.dmark+1)  
243f 32 78 fb			ld (debug_mark+1),a  
2442 3a 4c 24			ld a, (.dmark+2)  
2445 32 79 fb			ld (debug_mark+2),a  
2448 18 03			jr .pastdmark  
244a ..			.dmark: db ":0+"  
244d f1			.pastdmark: pop af  
244e			endm  
# End of macro DMARK
244e				CALLMONITOR 
244e cd 49 17			call break_point_state  
2451				endm  
# End of macro CALLMONITOR
2451			endif 
2451			 
2451				STACKFRAMECHK OFF $8efe $989f 
2451				if DEBUG_STACK_IMB 
2451					if OFF 
2451						exx 
2451						ld hl, $989f 
2451						pop de   ; $989f 
2451						call cmp16 
2451						jr nz, .spnosame 
2451						ld hl, $8efe 
2451						pop de   ; $8efe 
2451						call cmp16 
2451						jr z, .spfrsame 
2451						.spnosame: call showsperror 
2451						.spfrsame: nop 
2451						exx 
2451					endif 
2451				endif 
2451			endm 
# End of macro STACKFRAMECHK
2451			 
2451 c9			ret    ; dont process any remaining parser tokens as they form new word 
2452			 
2452			 
2452			 
2452			 
2452			;		NEXT 
2452			.SCOLN: 
2452			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2452 06				db OPCODE_SCOLN 
2453 9e 24			dw .DROP 
2455 02				db 2 
2456 .. 00			db ";",0           
2458			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2458					if DEBUG_FORTH_WORDS_KEY 
2458						DMARK "SCN" 
2458 f5				push af  
2459 3a 6d 24			ld a, (.dmark)  
245c 32 77 fb			ld (debug_mark),a  
245f 3a 6e 24			ld a, (.dmark+1)  
2462 32 78 fb			ld (debug_mark+1),a  
2465 3a 6f 24			ld a, (.dmark+2)  
2468 32 79 fb			ld (debug_mark+2),a  
246b 18 03			jr .pastdmark  
246d ..			.dmark: db "SCN"  
2470 f1			.pastdmark: pop af  
2471			endm  
# End of macro DMARK
2471						CALLMONITOR 
2471 cd 49 17			call break_point_state  
2474				endm  
# End of macro CALLMONITOR
2474					endif 
2474					FORTH_RSP_TOS 
2474 cd 97 1c			call macro_forth_rsp_tos 
2477				endm 
# End of macro FORTH_RSP_TOS
2477 e5					push hl 
2478					FORTH_RSP_POP 
2478 cd a1 1c			call macro_forth_rsp_pop 
247b				endm 
# End of macro FORTH_RSP_POP
247b e1					pop hl 
247c			;		ex de,hl 
247c 22 1e f1				ld (os_tok_ptr),hl 
247f			 
247f			if DEBUG_FORTH_UWORD 
247f						DMARK "SCL" 
247f f5				push af  
2480 3a 94 24			ld a, (.dmark)  
2483 32 77 fb			ld (debug_mark),a  
2486 3a 95 24			ld a, (.dmark+1)  
2489 32 78 fb			ld (debug_mark+1),a  
248c 3a 96 24			ld a, (.dmark+2)  
248f 32 79 fb			ld (debug_mark+2),a  
2492 18 03			jr .pastdmark  
2494 ..			.dmark: db "SCL"  
2497 f1			.pastdmark: pop af  
2498			endm  
# End of macro DMARK
2498				CALLMONITOR 
2498 cd 49 17			call break_point_state  
249b				endm  
# End of macro CALLMONITOR
249b			endif 
249b					NEXTW 
249b c3 42 20			jp macro_next 
249e				endm 
# End of macro NEXTW
249e			 
249e			.DROP: 
249e				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
249e 1b				db WORD_SYS_CORE+OPCODE_DROP             
249f c9 24			dw .DUP2            
24a1 05				db 4 + 1 
24a2 .. 00			db "DROP",0              
24a7				endm 
# End of macro CWHEAD
24a7			; | DROP ( w -- )   drop the TOS item   | DONE 
24a7					if DEBUG_FORTH_WORDS_KEY 
24a7						DMARK "DRP" 
24a7 f5				push af  
24a8 3a bc 24			ld a, (.dmark)  
24ab 32 77 fb			ld (debug_mark),a  
24ae 3a bd 24			ld a, (.dmark+1)  
24b1 32 78 fb			ld (debug_mark+1),a  
24b4 3a be 24			ld a, (.dmark+2)  
24b7 32 79 fb			ld (debug_mark+2),a  
24ba 18 03			jr .pastdmark  
24bc ..			.dmark: db "DRP"  
24bf f1			.pastdmark: pop af  
24c0			endm  
# End of macro DMARK
24c0						CALLMONITOR 
24c0 cd 49 17			call break_point_state  
24c3				endm  
# End of macro CALLMONITOR
24c3					endif 
24c3					FORTH_DSP_POP 
24c3 cd 88 1f			call macro_forth_dsp_pop 
24c6				endm 
# End of macro FORTH_DSP_POP
24c6					NEXTW 
24c6 c3 42 20			jp macro_next 
24c9				endm 
# End of macro NEXTW
24c9			.DUP2: 
24c9				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24c9 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24ca 0e 25			dw .DROP2            
24cc 05				db 4 + 1 
24cd .. 00			db "2DUP",0              
24d2				endm 
# End of macro CWHEAD
24d2			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
24d2					if DEBUG_FORTH_WORDS_KEY 
24d2						DMARK "2DU" 
24d2 f5				push af  
24d3 3a e7 24			ld a, (.dmark)  
24d6 32 77 fb			ld (debug_mark),a  
24d9 3a e8 24			ld a, (.dmark+1)  
24dc 32 78 fb			ld (debug_mark+1),a  
24df 3a e9 24			ld a, (.dmark+2)  
24e2 32 79 fb			ld (debug_mark+2),a  
24e5 18 03			jr .pastdmark  
24e7 ..			.dmark: db "2DU"  
24ea f1			.pastdmark: pop af  
24eb			endm  
# End of macro DMARK
24eb						CALLMONITOR 
24eb cd 49 17			call break_point_state  
24ee				endm  
# End of macro CALLMONITOR
24ee					endif 
24ee					FORTH_DSP_VALUEHL 
24ee cd d0 1e			call macro_dsp_valuehl 
24f1				endm 
# End of macro FORTH_DSP_VALUEHL
24f1 e5					push hl      ; 2 
24f2			 
24f2					FORTH_DSP_POP 
24f2 cd 88 1f			call macro_forth_dsp_pop 
24f5				endm 
# End of macro FORTH_DSP_POP
24f5					 
24f5					FORTH_DSP_VALUEHL 
24f5 cd d0 1e			call macro_dsp_valuehl 
24f8				endm 
# End of macro FORTH_DSP_VALUEHL
24f8			;		push hl      ; 1 
24f8			 
24f8					FORTH_DSP_POP 
24f8 cd 88 1f			call macro_forth_dsp_pop 
24fb				endm 
# End of macro FORTH_DSP_POP
24fb			 
24fb			;		pop hl       ; 1 
24fb d1					pop de       ; 2 
24fc			 
24fc cd d9 1c				call forth_push_numhl 
24ff eb					ex de, hl 
2500 cd d9 1c				call forth_push_numhl 
2503			 
2503					 
2503 eb					ex de, hl 
2504			 
2504 cd d9 1c				call forth_push_numhl 
2507 eb					ex de, hl 
2508 cd d9 1c				call forth_push_numhl 
250b			 
250b			 
250b					NEXTW 
250b c3 42 20			jp macro_next 
250e				endm 
# End of macro NEXTW
250e			.DROP2: 
250e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
250e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
250f 3d 25			dw .SWAP2            
2511 06				db 5 + 1 
2512 .. 00			db "2DROP",0              
2518				endm 
# End of macro CWHEAD
2518			; | 2DROP ( w w -- )    Double drop | DONE 
2518					if DEBUG_FORTH_WORDS_KEY 
2518						DMARK "2DR" 
2518 f5				push af  
2519 3a 2d 25			ld a, (.dmark)  
251c 32 77 fb			ld (debug_mark),a  
251f 3a 2e 25			ld a, (.dmark+1)  
2522 32 78 fb			ld (debug_mark+1),a  
2525 3a 2f 25			ld a, (.dmark+2)  
2528 32 79 fb			ld (debug_mark+2),a  
252b 18 03			jr .pastdmark  
252d ..			.dmark: db "2DR"  
2530 f1			.pastdmark: pop af  
2531			endm  
# End of macro DMARK
2531						CALLMONITOR 
2531 cd 49 17			call break_point_state  
2534				endm  
# End of macro CALLMONITOR
2534					endif 
2534					FORTH_DSP_POP 
2534 cd 88 1f			call macro_forth_dsp_pop 
2537				endm 
# End of macro FORTH_DSP_POP
2537					FORTH_DSP_POP 
2537 cd 88 1f			call macro_forth_dsp_pop 
253a				endm 
# End of macro FORTH_DSP_POP
253a					NEXTW 
253a c3 42 20			jp macro_next 
253d				endm 
# End of macro NEXTW
253d			.SWAP2: 
253d				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
253d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
253e 66 25			dw .AT            
2540 06				db 5 + 1 
2541 .. 00			db "2SWAP",0              
2547				endm 
# End of macro CWHEAD
2547			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2547					if DEBUG_FORTH_WORDS_KEY 
2547						DMARK "2SW" 
2547 f5				push af  
2548 3a 5c 25			ld a, (.dmark)  
254b 32 77 fb			ld (debug_mark),a  
254e 3a 5d 25			ld a, (.dmark+1)  
2551 32 78 fb			ld (debug_mark+1),a  
2554 3a 5e 25			ld a, (.dmark+2)  
2557 32 79 fb			ld (debug_mark+2),a  
255a 18 03			jr .pastdmark  
255c ..			.dmark: db "2SW"  
255f f1			.pastdmark: pop af  
2560			endm  
# End of macro DMARK
2560						CALLMONITOR 
2560 cd 49 17			call break_point_state  
2563				endm  
# End of macro CALLMONITOR
2563					endif 
2563					NEXTW 
2563 c3 42 20			jp macro_next 
2566				endm 
# End of macro NEXTW
2566			.AT: 
2566				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2566 1f				db WORD_SYS_CORE+OPCODE_AT             
2567 98 25			dw .CAT            
2569 02				db 1 + 1 
256a .. 00			db "@",0              
256c				endm 
# End of macro CWHEAD
256c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
256c			 
256c					if DEBUG_FORTH_WORDS_KEY 
256c						DMARK "AT." 
256c f5				push af  
256d 3a 81 25			ld a, (.dmark)  
2570 32 77 fb			ld (debug_mark),a  
2573 3a 82 25			ld a, (.dmark+1)  
2576 32 78 fb			ld (debug_mark+1),a  
2579 3a 83 25			ld a, (.dmark+2)  
257c 32 79 fb			ld (debug_mark+2),a  
257f 18 03			jr .pastdmark  
2581 ..			.dmark: db "AT."  
2584 f1			.pastdmark: pop af  
2585			endm  
# End of macro DMARK
2585						CALLMONITOR 
2585 cd 49 17			call break_point_state  
2588				endm  
# End of macro CALLMONITOR
2588					endif 
2588			.getbyteat:	 
2588					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2588 cd d0 1e			call macro_dsp_valuehl 
258b				endm 
# End of macro FORTH_DSP_VALUEHL
258b					 
258b			;		push hl 
258b				 
258b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
258b cd 88 1f			call macro_forth_dsp_pop 
258e				endm 
# End of macro FORTH_DSP_POP
258e			 
258e			;		pop hl 
258e			 
258e 7e					ld a, (hl) 
258f			 
258f 6f					ld l, a 
2590 26 00				ld h, 0 
2592 cd d9 1c				call forth_push_numhl 
2595			 
2595					NEXTW 
2595 c3 42 20			jp macro_next 
2598				endm 
# End of macro NEXTW
2598			.CAT: 
2598				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2598 20				db WORD_SYS_CORE+OPCODE_CAT             
2599 c1 25			dw .BANG            
259b 03				db 2 + 1 
259c .. 00			db "C@",0              
259f				endm 
# End of macro CWHEAD
259f			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
259f					if DEBUG_FORTH_WORDS_KEY 
259f						DMARK "CAA" 
259f f5				push af  
25a0 3a b4 25			ld a, (.dmark)  
25a3 32 77 fb			ld (debug_mark),a  
25a6 3a b5 25			ld a, (.dmark+1)  
25a9 32 78 fb			ld (debug_mark+1),a  
25ac 3a b6 25			ld a, (.dmark+2)  
25af 32 79 fb			ld (debug_mark+2),a  
25b2 18 03			jr .pastdmark  
25b4 ..			.dmark: db "CAA"  
25b7 f1			.pastdmark: pop af  
25b8			endm  
# End of macro DMARK
25b8						CALLMONITOR 
25b8 cd 49 17			call break_point_state  
25bb				endm  
# End of macro CALLMONITOR
25bb					endif 
25bb c3 88 25				jp .getbyteat 
25be					NEXTW 
25be c3 42 20			jp macro_next 
25c1				endm 
# End of macro NEXTW
25c1			.BANG: 
25c1				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25c1 21				db WORD_SYS_CORE+OPCODE_BANG             
25c2 f7 25			dw .CBANG            
25c4 02				db 1 + 1 
25c5 .. 00			db "!",0              
25c7				endm 
# End of macro CWHEAD
25c7			; | ! ( x w -- ) Store x at address w      | DONE 
25c7					if DEBUG_FORTH_WORDS_KEY 
25c7						DMARK "BNG" 
25c7 f5				push af  
25c8 3a dc 25			ld a, (.dmark)  
25cb 32 77 fb			ld (debug_mark),a  
25ce 3a dd 25			ld a, (.dmark+1)  
25d1 32 78 fb			ld (debug_mark+1),a  
25d4 3a de 25			ld a, (.dmark+2)  
25d7 32 79 fb			ld (debug_mark+2),a  
25da 18 03			jr .pastdmark  
25dc ..			.dmark: db "BNG"  
25df f1			.pastdmark: pop af  
25e0			endm  
# End of macro DMARK
25e0						CALLMONITOR 
25e0 cd 49 17			call break_point_state  
25e3				endm  
# End of macro CALLMONITOR
25e3					endif 
25e3			 
25e3			.storebyteat:		 
25e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25e3 cd d0 1e			call macro_dsp_valuehl 
25e6				endm 
# End of macro FORTH_DSP_VALUEHL
25e6					 
25e6 e5					push hl 
25e7				 
25e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25e7 cd 88 1f			call macro_forth_dsp_pop 
25ea				endm 
# End of macro FORTH_DSP_POP
25ea			 
25ea					; get byte to poke 
25ea			 
25ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ea cd d0 1e			call macro_dsp_valuehl 
25ed				endm 
# End of macro FORTH_DSP_VALUEHL
25ed e5					push hl 
25ee			 
25ee			 
25ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ee cd 88 1f			call macro_forth_dsp_pop 
25f1				endm 
# End of macro FORTH_DSP_POP
25f1			 
25f1			 
25f1 d1					pop de 
25f2 e1					pop hl 
25f3			 
25f3 73					ld (hl),e 
25f4			 
25f4			 
25f4					NEXTW 
25f4 c3 42 20			jp macro_next 
25f7				endm 
# End of macro NEXTW
25f7			.CBANG: 
25f7				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25f7 22				db WORD_SYS_CORE+OPCODE_CBANG             
25f8 20 26			dw .SCALL            
25fa 03				db 2 + 1 
25fb .. 00			db "C!",0              
25fe				endm 
# End of macro CWHEAD
25fe			; | C!  ( x w -- ) Store x at address w  | DONE 
25fe					if DEBUG_FORTH_WORDS_KEY 
25fe						DMARK "CBA" 
25fe f5				push af  
25ff 3a 13 26			ld a, (.dmark)  
2602 32 77 fb			ld (debug_mark),a  
2605 3a 14 26			ld a, (.dmark+1)  
2608 32 78 fb			ld (debug_mark+1),a  
260b 3a 15 26			ld a, (.dmark+2)  
260e 32 79 fb			ld (debug_mark+2),a  
2611 18 03			jr .pastdmark  
2613 ..			.dmark: db "CBA"  
2616 f1			.pastdmark: pop af  
2617			endm  
# End of macro DMARK
2617						CALLMONITOR 
2617 cd 49 17			call break_point_state  
261a				endm  
# End of macro CALLMONITOR
261a					endif 
261a c3 e3 25				jp .storebyteat 
261d					NEXTW 
261d c3 42 20			jp macro_next 
2620				endm 
# End of macro NEXTW
2620			.SCALL: 
2620				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2620 23				db WORD_SYS_CORE+OPCODE_SCALL             
2621 54 26			dw .DEPTH            
2623 05				db 4 + 1 
2624 .. 00			db "CALL",0              
2629				endm 
# End of macro CWHEAD
2629			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2629					if DEBUG_FORTH_WORDS_KEY 
2629						DMARK "CLL" 
2629 f5				push af  
262a 3a 3e 26			ld a, (.dmark)  
262d 32 77 fb			ld (debug_mark),a  
2630 3a 3f 26			ld a, (.dmark+1)  
2633 32 78 fb			ld (debug_mark+1),a  
2636 3a 40 26			ld a, (.dmark+2)  
2639 32 79 fb			ld (debug_mark+2),a  
263c 18 03			jr .pastdmark  
263e ..			.dmark: db "CLL"  
2641 f1			.pastdmark: pop af  
2642			endm  
# End of macro DMARK
2642						CALLMONITOR 
2642 cd 49 17			call break_point_state  
2645				endm  
# End of macro CALLMONITOR
2645					endif 
2645			 
2645					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2645 cd d0 1e			call macro_dsp_valuehl 
2648				endm 
# End of macro FORTH_DSP_VALUEHL
2648			 
2648			;		push hl 
2648			 
2648					; destroy value TOS 
2648			 
2648					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2648 cd 88 1f			call macro_forth_dsp_pop 
264b				endm 
# End of macro FORTH_DSP_POP
264b			 
264b						 
264b			;		pop hl 
264b			 
264b					; how to do a call with hl???? save SP? 
264b cd eb 1f				call forth_call_hl 
264e			 
264e			 
264e					; TODO push value back onto stack for another op etc 
264e			 
264e cd d9 1c				call forth_push_numhl 
2651					NEXTW 
2651 c3 42 20			jp macro_next 
2654				endm 
# End of macro NEXTW
2654			.DEPTH: 
2654				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2654 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2655 91 26			dw .OVER            
2657 06				db 5 + 1 
2658 .. 00			db "DEPTH",0              
265e				endm 
# End of macro CWHEAD
265e			; | DEPTH ( -- u ) Push count of stack | DONE 
265e					; take current TOS and remove from base value div by two to get count 
265e					if DEBUG_FORTH_WORDS_KEY 
265e						DMARK "DEP" 
265e f5				push af  
265f 3a 73 26			ld a, (.dmark)  
2662 32 77 fb			ld (debug_mark),a  
2665 3a 74 26			ld a, (.dmark+1)  
2668 32 78 fb			ld (debug_mark+1),a  
266b 3a 75 26			ld a, (.dmark+2)  
266e 32 79 fb			ld (debug_mark+2),a  
2671 18 03			jr .pastdmark  
2673 ..			.dmark: db "DEP"  
2676 f1			.pastdmark: pop af  
2677			endm  
# End of macro DMARK
2677						CALLMONITOR 
2677 cd 49 17			call break_point_state  
267a				endm  
# End of macro CALLMONITOR
267a					endif 
267a			 
267a			 
267a 2a 0a f8			ld hl, (cli_data_sp) 
267d 11 84 f3			ld de, cli_data_stack 
2680 ed 52			sbc hl,de 
2682				 
2682				; div by size of stack item 
2682			 
2682 5d				ld e,l 
2683 0e 03			ld c, 3 
2685 cd 9c 0c			call Div8 
2688			 
2688 6f				ld l,a 
2689 26 00			ld h,0 
268b			 
268b				;srl h 
268b				;rr l 
268b			 
268b cd d9 1c				call forth_push_numhl 
268e					NEXTW 
268e c3 42 20			jp macro_next 
2691				endm 
# End of macro NEXTW
2691			.OVER: 
2691				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2691 42				db WORD_SYS_CORE+46             
2692 d8 26			dw .PAUSE            
2694 05				db 4 + 1 
2695 .. 00			db "OVER",0              
269a				endm 
# End of macro CWHEAD
269a			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
269a					if DEBUG_FORTH_WORDS_KEY 
269a						DMARK "OVR" 
269a f5				push af  
269b 3a af 26			ld a, (.dmark)  
269e 32 77 fb			ld (debug_mark),a  
26a1 3a b0 26			ld a, (.dmark+1)  
26a4 32 78 fb			ld (debug_mark+1),a  
26a7 3a b1 26			ld a, (.dmark+2)  
26aa 32 79 fb			ld (debug_mark+2),a  
26ad 18 03			jr .pastdmark  
26af ..			.dmark: db "OVR"  
26b2 f1			.pastdmark: pop af  
26b3			endm  
# End of macro DMARK
26b3						CALLMONITOR 
26b3 cd 49 17			call break_point_state  
26b6				endm  
# End of macro CALLMONITOR
26b6					endif 
26b6			 
26b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b6 cd d0 1e			call macro_dsp_valuehl 
26b9				endm 
# End of macro FORTH_DSP_VALUEHL
26b9 e5					push hl    ; n2 
26ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ba cd 88 1f			call macro_forth_dsp_pop 
26bd				endm 
# End of macro FORTH_DSP_POP
26bd			 
26bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bd cd d0 1e			call macro_dsp_valuehl 
26c0				endm 
# End of macro FORTH_DSP_VALUEHL
26c0 e5					push hl    ; n1 
26c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c1 cd 88 1f			call macro_forth_dsp_pop 
26c4				endm 
# End of macro FORTH_DSP_POP
26c4			 
26c4 d1					pop de     ; n1 
26c5 e1					pop hl     ; n2 
26c6			 
26c6 d5					push de 
26c7 e5					push hl 
26c8 d5					push de 
26c9			 
26c9					; push back  
26c9			 
26c9 e1					pop hl 
26ca cd d9 1c				call forth_push_numhl 
26cd e1					pop hl 
26ce cd d9 1c				call forth_push_numhl 
26d1 e1					pop hl 
26d2 cd d9 1c				call forth_push_numhl 
26d5					NEXTW 
26d5 c3 42 20			jp macro_next 
26d8				endm 
# End of macro NEXTW
26d8			 
26d8			.PAUSE: 
26d8				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
26d8 43				db WORD_SYS_CORE+47             
26d9 0d 27			dw .PAUSES            
26db 08				db 7 + 1 
26dc .. 00			db "PAUSEMS",0              
26e4				endm 
# End of macro CWHEAD
26e4			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26e4					if DEBUG_FORTH_WORDS_KEY 
26e4						DMARK "PMS" 
26e4 f5				push af  
26e5 3a f9 26			ld a, (.dmark)  
26e8 32 77 fb			ld (debug_mark),a  
26eb 3a fa 26			ld a, (.dmark+1)  
26ee 32 78 fb			ld (debug_mark+1),a  
26f1 3a fb 26			ld a, (.dmark+2)  
26f4 32 79 fb			ld (debug_mark+2),a  
26f7 18 03			jr .pastdmark  
26f9 ..			.dmark: db "PMS"  
26fc f1			.pastdmark: pop af  
26fd			endm  
# End of macro DMARK
26fd						CALLMONITOR 
26fd cd 49 17			call break_point_state  
2700				endm  
# End of macro CALLMONITOR
2700					endif 
2700					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2700 cd d0 1e			call macro_dsp_valuehl 
2703				endm 
# End of macro FORTH_DSP_VALUEHL
2703			;		push hl    ; n2 
2703					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2703 cd 88 1f			call macro_forth_dsp_pop 
2706				endm 
# End of macro FORTH_DSP_POP
2706			;		pop hl 
2706			 
2706 7d					ld a, l 
2707 cd 3d 0a				call aDelayInMS 
270a				       NEXTW 
270a c3 42 20			jp macro_next 
270d				endm 
# End of macro NEXTW
270d			.PAUSES:  
270d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
270d 44				db WORD_SYS_CORE+48             
270e 7c 27			dw .ROT            
2710 06				db 5 + 1 
2711 .. 00			db "PAUSE",0              
2717				endm 
# End of macro CWHEAD
2717			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2717					if DEBUG_FORTH_WORDS_KEY 
2717						DMARK "PAU" 
2717 f5				push af  
2718 3a 2c 27			ld a, (.dmark)  
271b 32 77 fb			ld (debug_mark),a  
271e 3a 2d 27			ld a, (.dmark+1)  
2721 32 78 fb			ld (debug_mark+1),a  
2724 3a 2e 27			ld a, (.dmark+2)  
2727 32 79 fb			ld (debug_mark+2),a  
272a 18 03			jr .pastdmark  
272c ..			.dmark: db "PAU"  
272f f1			.pastdmark: pop af  
2730			endm  
# End of macro DMARK
2730						CALLMONITOR 
2730 cd 49 17			call break_point_state  
2733				endm  
# End of macro CALLMONITOR
2733					endif 
2733					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2733 cd d0 1e			call macro_dsp_valuehl 
2736				endm 
# End of macro FORTH_DSP_VALUEHL
2736			;		push hl    ; n2 
2736					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2736 cd 88 1f			call macro_forth_dsp_pop 
2739				endm 
# End of macro FORTH_DSP_POP
2739			;		pop hl 
2739 45					ld b, l 
273a					if DEBUG_FORTH_WORDS 
273a						DMARK "PAU" 
273a f5				push af  
273b 3a 4f 27			ld a, (.dmark)  
273e 32 77 fb			ld (debug_mark),a  
2741 3a 50 27			ld a, (.dmark+1)  
2744 32 78 fb			ld (debug_mark+1),a  
2747 3a 51 27			ld a, (.dmark+2)  
274a 32 79 fb			ld (debug_mark+2),a  
274d 18 03			jr .pastdmark  
274f ..			.dmark: db "PAU"  
2752 f1			.pastdmark: pop af  
2753			endm  
# End of macro DMARK
2753						CALLMONITOR 
2753 cd 49 17			call break_point_state  
2756				endm  
# End of macro CALLMONITOR
2756					endif 
2756 c5			.pauses1:	push bc 
2757 cd 58 0a				call delay1s 
275a c1					pop bc 
275b					if DEBUG_FORTH_WORDS 
275b						DMARK "PA1" 
275b f5				push af  
275c 3a 70 27			ld a, (.dmark)  
275f 32 77 fb			ld (debug_mark),a  
2762 3a 71 27			ld a, (.dmark+1)  
2765 32 78 fb			ld (debug_mark+1),a  
2768 3a 72 27			ld a, (.dmark+2)  
276b 32 79 fb			ld (debug_mark+2),a  
276e 18 03			jr .pastdmark  
2770 ..			.dmark: db "PA1"  
2773 f1			.pastdmark: pop af  
2774			endm  
# End of macro DMARK
2774						CALLMONITOR 
2774 cd 49 17			call break_point_state  
2777				endm  
# End of macro CALLMONITOR
2777					endif 
2777 10 dd				djnz .pauses1 
2779			 
2779				       NEXTW 
2779 c3 42 20			jp macro_next 
277c				endm 
# End of macro NEXTW
277c			.ROT: 
277c				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
277c 45				db WORD_SYS_CORE+49             
277d ca 27			dw .UWORDS            
277f 04				db 3 + 1 
2780 .. 00			db "ROT",0              
2784				endm 
# End of macro CWHEAD
2784			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2784					if DEBUG_FORTH_WORDS_KEY 
2784						DMARK "ROT" 
2784 f5				push af  
2785 3a 99 27			ld a, (.dmark)  
2788 32 77 fb			ld (debug_mark),a  
278b 3a 9a 27			ld a, (.dmark+1)  
278e 32 78 fb			ld (debug_mark+1),a  
2791 3a 9b 27			ld a, (.dmark+2)  
2794 32 79 fb			ld (debug_mark+2),a  
2797 18 03			jr .pastdmark  
2799 ..			.dmark: db "ROT"  
279c f1			.pastdmark: pop af  
279d			endm  
# End of macro DMARK
279d						CALLMONITOR 
279d cd 49 17			call break_point_state  
27a0				endm  
# End of macro CALLMONITOR
27a0					endif 
27a0			 
27a0					FORTH_DSP_VALUEHL 
27a0 cd d0 1e			call macro_dsp_valuehl 
27a3				endm 
# End of macro FORTH_DSP_VALUEHL
27a3 e5					push hl    ; u3  
27a4			 
27a4					FORTH_DSP_POP 
27a4 cd 88 1f			call macro_forth_dsp_pop 
27a7				endm 
# End of macro FORTH_DSP_POP
27a7			   
27a7					FORTH_DSP_VALUEHL 
27a7 cd d0 1e			call macro_dsp_valuehl 
27aa				endm 
# End of macro FORTH_DSP_VALUEHL
27aa e5					push hl     ; u2 
27ab			 
27ab					FORTH_DSP_POP 
27ab cd 88 1f			call macro_forth_dsp_pop 
27ae				endm 
# End of macro FORTH_DSP_POP
27ae			 
27ae					FORTH_DSP_VALUEHL 
27ae cd d0 1e			call macro_dsp_valuehl 
27b1				endm 
# End of macro FORTH_DSP_VALUEHL
27b1 e5					push hl     ; u1 
27b2			 
27b2					FORTH_DSP_POP 
27b2 cd 88 1f			call macro_forth_dsp_pop 
27b5				endm 
# End of macro FORTH_DSP_POP
27b5			 
27b5 c1					pop bc      ; u1 
27b6 e1					pop hl      ; u2 
27b7 d1					pop de      ; u3 
27b8			 
27b8			 
27b8 c5					push bc 
27b9 d5					push de 
27ba e5					push hl 
27bb			 
27bb			 
27bb e1					pop hl 
27bc cd d9 1c				call forth_push_numhl 
27bf			 
27bf e1					pop hl 
27c0 cd d9 1c				call forth_push_numhl 
27c3			 
27c3 e1					pop hl 
27c4 cd d9 1c				call forth_push_numhl 
27c7					 
27c7			 
27c7			 
27c7			 
27c7			 
27c7			 
27c7				       NEXTW 
27c7 c3 42 20			jp macro_next 
27ca				endm 
# End of macro NEXTW
27ca			 
27ca			.UWORDS: 
27ca				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27ca 50				db WORD_SYS_CORE+60             
27cb 8c 28			dw .BP            
27cd 07				db 6 + 1 
27ce .. 00			db "UWORDS",0              
27d5				endm 
# End of macro CWHEAD
27d5			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
27d5			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
27d5			; | | Following the count are the individual words. 
27d5			; | | 
27d5			; | | e.g. UWORDS 
27d5			; | | BOX DIRLIST 2 
27d5			; | |  
27d5			; | | Can be used to save the words to storage via: 
27d5			; | | UWORDS $01 DO $01 APPEND LOOP 
27d5				if DEBUG_FORTH_WORDS_KEY 
27d5					DMARK "UWR" 
27d5 f5				push af  
27d6 3a ea 27			ld a, (.dmark)  
27d9 32 77 fb			ld (debug_mark),a  
27dc 3a eb 27			ld a, (.dmark+1)  
27df 32 78 fb			ld (debug_mark+1),a  
27e2 3a ec 27			ld a, (.dmark+2)  
27e5 32 79 fb			ld (debug_mark+2),a  
27e8 18 03			jr .pastdmark  
27ea ..			.dmark: db "UWR"  
27ed f1			.pastdmark: pop af  
27ee			endm  
# End of macro DMARK
27ee					CALLMONITOR 
27ee cd 49 17			call break_point_state  
27f1				endm  
# End of macro CALLMONITOR
27f1				endif 
27f1 21 00 80				ld hl, baseram 
27f4					;ld hl, baseusermem 
27f4 01 00 00				ld bc, 0    ; start a counter 
27f7			 
27f7				; skip dict stub 
27f7			 
27f7 cd 93 21				call forth_tok_next 
27fa			 
27fa			 
27fa			; while we have words to look for 
27fa			 
27fa 7e			.douscan:	ld a, (hl)      
27fb				if DEBUG_FORTH_WORDS 
27fb					DMARK "UWs" 
27fb f5				push af  
27fc 3a 10 28			ld a, (.dmark)  
27ff 32 77 fb			ld (debug_mark),a  
2802 3a 11 28			ld a, (.dmark+1)  
2805 32 78 fb			ld (debug_mark+1),a  
2808 3a 12 28			ld a, (.dmark+2)  
280b 32 79 fb			ld (debug_mark+2),a  
280e 18 03			jr .pastdmark  
2810 ..			.dmark: db "UWs"  
2813 f1			.pastdmark: pop af  
2814			endm  
# End of macro DMARK
2814					CALLMONITOR 
2814 cd 49 17			call break_point_state  
2817				endm  
# End of macro CALLMONITOR
2817				endif 
2817 fe 00				cp WORD_SYS_END 
2819 28 4d				jr z, .udone 
281b fe 01				cp WORD_SYS_UWORD 
281d 20 44				jr nz, .nuword 
281f			 
281f				if DEBUG_FORTH_WORDS 
281f					DMARK "UWu" 
281f f5				push af  
2820 3a 34 28			ld a, (.dmark)  
2823 32 77 fb			ld (debug_mark),a  
2826 3a 35 28			ld a, (.dmark+1)  
2829 32 78 fb			ld (debug_mark+1),a  
282c 3a 36 28			ld a, (.dmark+2)  
282f 32 79 fb			ld (debug_mark+2),a  
2832 18 03			jr .pastdmark  
2834 ..			.dmark: db "UWu"  
2837 f1			.pastdmark: pop af  
2838			endm  
# End of macro DMARK
2838					CALLMONITOR 
2838 cd 49 17			call break_point_state  
283b				endm  
# End of macro CALLMONITOR
283b				endif 
283b					; we have a uword so push its name to the stack 
283b			 
283b e5				   	push hl  ; save so we can move to next dict block 
283c			 
283c					; skip opcode 
283c 23					inc hl  
283d					; skip next ptr 
283d 23					inc hl  
283e 23					inc hl 
283f					; skip len 
283f 23					inc hl 
2840				if DEBUG_FORTH_WORDS 
2840					DMARK "UWt" 
2840 f5				push af  
2841 3a 55 28			ld a, (.dmark)  
2844 32 77 fb			ld (debug_mark),a  
2847 3a 56 28			ld a, (.dmark+1)  
284a 32 78 fb			ld (debug_mark+1),a  
284d 3a 57 28			ld a, (.dmark+2)  
2850 32 79 fb			ld (debug_mark+2),a  
2853 18 03			jr .pastdmark  
2855 ..			.dmark: db "UWt"  
2858 f1			.pastdmark: pop af  
2859			endm  
# End of macro DMARK
2859					CALLMONITOR 
2859 cd 49 17			call break_point_state  
285c				endm  
# End of macro CALLMONITOR
285c				endif 
285c 03					inc bc 
285d			 
285d c5					push bc 
285e cd 47 1d				call forth_push_str 
2861 c1					pop bc 
2862			 
2862 e1					pop hl 	 
2863			 
2863 cd 93 21		.nuword:	call forth_tok_next 
2866 18 92				jr .douscan  
2868			 
2868			.udone:		 ; push count of uwords found 
2868 c5					push bc 
2869 e1					pop hl 
286a			 
286a				if DEBUG_FORTH_WORDS 
286a					DMARK "UWc" 
286a f5				push af  
286b 3a 7f 28			ld a, (.dmark)  
286e 32 77 fb			ld (debug_mark),a  
2871 3a 80 28			ld a, (.dmark+1)  
2874 32 78 fb			ld (debug_mark+1),a  
2877 3a 81 28			ld a, (.dmark+2)  
287a 32 79 fb			ld (debug_mark+2),a  
287d 18 03			jr .pastdmark  
287f ..			.dmark: db "UWc"  
2882 f1			.pastdmark: pop af  
2883			endm  
# End of macro DMARK
2883					CALLMONITOR 
2883 cd 49 17			call break_point_state  
2886				endm  
# End of macro CALLMONITOR
2886				endif 
2886 cd d9 1c				call forth_push_numhl 
2889			 
2889			 
2889				       NEXTW 
2889 c3 42 20			jp macro_next 
288c				endm 
# End of macro NEXTW
288c			 
288c			.BP: 
288c				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
288c 54				db WORD_SYS_CORE+64             
288d c2 28			dw .MONITOR            
288f 03				db 2 + 1 
2890 .. 00			db "BP",0              
2893				endm 
# End of macro CWHEAD
2893			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2893			; | | $00 Will enable the break points within specific code paths 
2893			; | | $01 Will disable break points 
2893			; | |  
2893			; | | By default break points are off. Either the above can be used to enable them 
2893			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2893			; | | and on release of the pressed key a message will be disaplayed to notify 
2893			; | | that break points are enabled. Pressing any key will then continue boot process. 
2893					; get byte count 
2893					if DEBUG_FORTH_WORDS_KEY 
2893						DMARK "BP." 
2893 f5				push af  
2894 3a a8 28			ld a, (.dmark)  
2897 32 77 fb			ld (debug_mark),a  
289a 3a a9 28			ld a, (.dmark+1)  
289d 32 78 fb			ld (debug_mark+1),a  
28a0 3a aa 28			ld a, (.dmark+2)  
28a3 32 79 fb			ld (debug_mark+2),a  
28a6 18 03			jr .pastdmark  
28a8 ..			.dmark: db "BP."  
28ab f1			.pastdmark: pop af  
28ac			endm  
# End of macro DMARK
28ac						CALLMONITOR 
28ac cd 49 17			call break_point_state  
28af				endm  
# End of macro CALLMONITOR
28af					endif 
28af			 
28af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28af cd d0 1e			call macro_dsp_valuehl 
28b2				endm 
# End of macro FORTH_DSP_VALUEHL
28b2			 
28b2			;		push hl 
28b2			 
28b2					; destroy value TOS 
28b2			 
28b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b2 cd 88 1f			call macro_forth_dsp_pop 
28b5				endm 
# End of macro FORTH_DSP_POP
28b5			 
28b5			;		pop hl 
28b5			 
28b5 3e 00				ld a,0 
28b7 bd					cp l 
28b8 28 02				jr z, .bpset 
28ba 3e 2a				ld a, '*' 
28bc			 
28bc 32 0e ee		.bpset:		ld (os_view_disable), a 
28bf			 
28bf			 
28bf					NEXTW 
28bf c3 42 20			jp macro_next 
28c2				endm 
# End of macro NEXTW
28c2			 
28c2			 
28c2			.MONITOR: 
28c2				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28c2 55				db WORD_SYS_CORE+65             
28c3 f5 28			dw .MALLOC            
28c5 08				db 7 + 1 
28c6 .. 00			db "MONITOR",0              
28ce				endm 
# End of macro CWHEAD
28ce			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28ce			; | | At start the current various registers will be displayed with contents. 
28ce			; | | Top right corner will show the most recent debug marker seen. 
28ce			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28ce			; | | and the return stack pointer (RSP). 
28ce			; | | Pressing: 
28ce			; | |    1 - Initial screen 
28ce			; | |    2 - Display a data dump of HL 
28ce			; | |    3 - Display a data dump of DE 
28ce			; | |    4 - Display a data dump of BC 
28ce			; | |    5 - Display a data dump of HL 
28ce			; | |    6 - Display a data dump of DSP 
28ce			; | |    7 - Display a data dump of RSP 
28ce			; | |    8 - Display a data dump of what is at DSP 
28ce			; | |    9 - Display a data dump of what is at RSP 
28ce			; | |    0 - Exit monitor and continue running. This will also enable break points 
28ce			; | |    * - Disable break points 
28ce			; | |    # - Enter traditional monitor mode 
28ce			; | | 
28ce			; | | Monitor Mode 
28ce			; | | ------------ 
28ce			; | | A prompt of '>' will be shown for various commands: 
28ce			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28ce			; | |    C - Continue display a data dump from the last set address 
28ce			; | |    M xxxx - Set start of memory edit at address xx 
28ce			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28ce			; | |    Q - Return to previous 
28ce					if DEBUG_FORTH_WORDS_KEY 
28ce						DMARK "MON" 
28ce f5				push af  
28cf 3a e3 28			ld a, (.dmark)  
28d2 32 77 fb			ld (debug_mark),a  
28d5 3a e4 28			ld a, (.dmark+1)  
28d8 32 78 fb			ld (debug_mark+1),a  
28db 3a e5 28			ld a, (.dmark+2)  
28de 32 79 fb			ld (debug_mark+2),a  
28e1 18 03			jr .pastdmark  
28e3 ..			.dmark: db "MON"  
28e6 f1			.pastdmark: pop af  
28e7			endm  
# End of macro DMARK
28e7						CALLMONITOR 
28e7 cd 49 17			call break_point_state  
28ea				endm  
# End of macro CALLMONITOR
28ea					endif 
28ea 3e 00				ld a, 0 
28ec 32 0e ee				ld (os_view_disable), a 
28ef			 
28ef					CALLMONITOR 
28ef cd 49 17			call break_point_state  
28f2				endm  
# End of macro CALLMONITOR
28f2			 
28f2			;	call monitor 
28f2			 
28f2					NEXTW 
28f2 c3 42 20			jp macro_next 
28f5				endm 
# End of macro NEXTW
28f5			 
28f5			 
28f5			.MALLOC: 
28f5				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28f5 56				db WORD_SYS_CORE+66             
28f6 1e 29			dw .MALLOC2            
28f8 06				db 5 + 1 
28f9 .. 00			db "ALLOT",0              
28ff				endm 
# End of macro CWHEAD
28ff			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28ff					if DEBUG_FORTH_WORDS_KEY 
28ff						DMARK "ALL" 
28ff f5				push af  
2900 3a 14 29			ld a, (.dmark)  
2903 32 77 fb			ld (debug_mark),a  
2906 3a 15 29			ld a, (.dmark+1)  
2909 32 78 fb			ld (debug_mark+1),a  
290c 3a 16 29			ld a, (.dmark+2)  
290f 32 79 fb			ld (debug_mark+2),a  
2912 18 03			jr .pastdmark  
2914 ..			.dmark: db "ALL"  
2917 f1			.pastdmark: pop af  
2918			endm  
# End of macro DMARK
2918						CALLMONITOR 
2918 cd 49 17			call break_point_state  
291b				endm  
# End of macro CALLMONITOR
291b					endif 
291b c3 45 29				jp .mallocc 
291e			.MALLOC2: 
291e				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
291e 56				db WORD_SYS_CORE+66             
291f 5c 29			dw .FREE            
2921 07				db 6 + 1 
2922 .. 00			db "MALLOC",0              
2929				endm 
# End of macro CWHEAD
2929			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2929					; get byte count 
2929					if DEBUG_FORTH_WORDS_KEY 
2929						DMARK "MAL" 
2929 f5				push af  
292a 3a 3e 29			ld a, (.dmark)  
292d 32 77 fb			ld (debug_mark),a  
2930 3a 3f 29			ld a, (.dmark+1)  
2933 32 78 fb			ld (debug_mark+1),a  
2936 3a 40 29			ld a, (.dmark+2)  
2939 32 79 fb			ld (debug_mark+2),a  
293c 18 03			jr .pastdmark  
293e ..			.dmark: db "MAL"  
2941 f1			.pastdmark: pop af  
2942			endm  
# End of macro DMARK
2942						CALLMONITOR 
2942 cd 49 17			call break_point_state  
2945				endm  
# End of macro CALLMONITOR
2945					endif 
2945			.mallocc: 
2945					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2945 cd d0 1e			call macro_dsp_valuehl 
2948				endm 
# End of macro FORTH_DSP_VALUEHL
2948			 
2948			;		push hl 
2948			 
2948					; destroy value TOS 
2948			 
2948					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2948 cd 88 1f			call macro_forth_dsp_pop 
294b				endm 
# End of macro FORTH_DSP_POP
294b			 
294b			;		pop hl 
294b cd d3 11				call malloc 
294e				if DEBUG_FORTH_MALLOC_GUARD 
294e f5					push af 
294f cd 35 0d				call ishlzero 
2952			;		ld a, l 
2952			;		add h 
2952			;		cp 0 
2952 f1					pop af 
2953					 
2953 cc a8 51				call z,malloc_error 
2956				endif 
2956			 
2956 cd d9 1c				call forth_push_numhl 
2959					NEXTW 
2959 c3 42 20			jp macro_next 
295c				endm 
# End of macro NEXTW
295c			 
295c			.FREE: 
295c				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
295c 57				db WORD_SYS_CORE+67             
295d 8d 29			dw .LIST            
295f 05				db 4 + 1 
2960 .. 00			db "FREE",0              
2965				endm 
# End of macro CWHEAD
2965			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2965					if DEBUG_FORTH_WORDS_KEY 
2965						DMARK "FRE" 
2965 f5				push af  
2966 3a 7a 29			ld a, (.dmark)  
2969 32 77 fb			ld (debug_mark),a  
296c 3a 7b 29			ld a, (.dmark+1)  
296f 32 78 fb			ld (debug_mark+1),a  
2972 3a 7c 29			ld a, (.dmark+2)  
2975 32 79 fb			ld (debug_mark+2),a  
2978 18 03			jr .pastdmark  
297a ..			.dmark: db "FRE"  
297d f1			.pastdmark: pop af  
297e			endm  
# End of macro DMARK
297e						CALLMONITOR 
297e cd 49 17			call break_point_state  
2981				endm  
# End of macro CALLMONITOR
2981					endif 
2981					; get address 
2981			 
2981					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2981 cd d0 1e			call macro_dsp_valuehl 
2984				endm 
# End of macro FORTH_DSP_VALUEHL
2984			 
2984			;		push hl 
2984			 
2984					; destroy value TOS 
2984			 
2984					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2984 cd 88 1f			call macro_forth_dsp_pop 
2987				endm 
# End of macro FORTH_DSP_POP
2987			 
2987			;		pop hl 
2987			if FORTH_ENABLE_MALLOCFREE 
2987 cd 9d 12				call free 
298a			endif 
298a					NEXTW 
298a c3 42 20			jp macro_next 
298d				endm 
# End of macro NEXTW
298d			.LIST: 
298d				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
298d 5c				db WORD_SYS_CORE+72             
298e 50 2b			dw .FORGET            
2990 05				db 4 + 1 
2991 .. 00			db "LIST",0              
2996				endm 
# End of macro CWHEAD
2996			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2996			; | | The quoted word must be in upper case. 
2996				if DEBUG_FORTH_WORDS_KEY 
2996					DMARK "LST" 
2996 f5				push af  
2997 3a ab 29			ld a, (.dmark)  
299a 32 77 fb			ld (debug_mark),a  
299d 3a ac 29			ld a, (.dmark+1)  
29a0 32 78 fb			ld (debug_mark+1),a  
29a3 3a ad 29			ld a, (.dmark+2)  
29a6 32 79 fb			ld (debug_mark+2),a  
29a9 18 03			jr .pastdmark  
29ab ..			.dmark: db "LST"  
29ae f1			.pastdmark: pop af  
29af			endm  
# End of macro DMARK
29af					CALLMONITOR 
29af cd 49 17			call break_point_state  
29b2				endm  
# End of macro CALLMONITOR
29b2				endif 
29b2			 
29b2					FORTH_DSP_VALUEHL 
29b2 cd d0 1e			call macro_dsp_valuehl 
29b5				endm 
# End of macro FORTH_DSP_VALUEHL
29b5			 
29b5 e5					push hl 
29b6 c1					pop bc 
29b7			 
29b7			; Start format of scratch string 
29b7			 
29b7 21 1d ee				ld hl, scratch 
29ba			 
29ba 3e 3a				ld a, ':' 
29bc 77					ld (hl),a 
29bd 23					inc hl 
29be 3e 20				ld a, ' ' 
29c0 77					ld (hl), a 
29c1			 
29c1					; Get ptr to the word we need to look up 
29c1			 
29c1			;		FORTH_DSP_VALUEHL 
29c1					;v5 FORTH_DSP_VALUE 
29c1				; TODO type check 
29c1			;		inc hl    ; Skip type check  
29c1			;		push hl 
29c1			;		ex de, hl    ; put into DE 
29c1			 
29c1			 
29c1 21 00 80				ld hl, baseram 
29c4					;ld hl, baseusermem 
29c4			 
29c4 e5			push hl   ; sacreifical push 
29c5			 
29c5			.ldouscanm: 
29c5 e1				pop hl 
29c6			.ldouscan: 
29c6				if DEBUG_FORTH_WORDS 
29c6					DMARK "LSs" 
29c6 f5				push af  
29c7 3a db 29			ld a, (.dmark)  
29ca 32 77 fb			ld (debug_mark),a  
29cd 3a dc 29			ld a, (.dmark+1)  
29d0 32 78 fb			ld (debug_mark+1),a  
29d3 3a dd 29			ld a, (.dmark+2)  
29d6 32 79 fb			ld (debug_mark+2),a  
29d9 18 03			jr .pastdmark  
29db ..			.dmark: db "LSs"  
29de f1			.pastdmark: pop af  
29df			endm  
# End of macro DMARK
29df					CALLMONITOR 
29df cd 49 17			call break_point_state  
29e2				endm  
# End of macro CALLMONITOR
29e2				endif 
29e2				; skip dict stub 
29e2 cd 93 21				call forth_tok_next 
29e5			 
29e5			 
29e5			; while we have words to look for 
29e5			 
29e5 7e				ld a, (hl)      
29e6				if DEBUG_FORTH_WORDS 
29e6					DMARK "LSk" 
29e6 f5				push af  
29e7 3a fb 29			ld a, (.dmark)  
29ea 32 77 fb			ld (debug_mark),a  
29ed 3a fc 29			ld a, (.dmark+1)  
29f0 32 78 fb			ld (debug_mark+1),a  
29f3 3a fd 29			ld a, (.dmark+2)  
29f6 32 79 fb			ld (debug_mark+2),a  
29f9 18 03			jr .pastdmark  
29fb ..			.dmark: db "LSk"  
29fe f1			.pastdmark: pop af  
29ff			endm  
# End of macro DMARK
29ff					CALLMONITOR 
29ff cd 49 17			call break_point_state  
2a02				endm  
# End of macro CALLMONITOR
2a02				endif 
2a02 fe 00				cp WORD_SYS_END 
2a04 ca 37 2b				jp z, .lunotfound 
2a07 fe 01				cp WORD_SYS_UWORD 
2a09 c2 c6 29				jp nz, .ldouscan 
2a0c			 
2a0c				if DEBUG_FORTH_WORDS 
2a0c					DMARK "LSu" 
2a0c f5				push af  
2a0d 3a 21 2a			ld a, (.dmark)  
2a10 32 77 fb			ld (debug_mark),a  
2a13 3a 22 2a			ld a, (.dmark+1)  
2a16 32 78 fb			ld (debug_mark+1),a  
2a19 3a 23 2a			ld a, (.dmark+2)  
2a1c 32 79 fb			ld (debug_mark+2),a  
2a1f 18 03			jr .pastdmark  
2a21 ..			.dmark: db "LSu"  
2a24 f1			.pastdmark: pop af  
2a25			endm  
# End of macro DMARK
2a25					CALLMONITOR 
2a25 cd 49 17			call break_point_state  
2a28				endm  
# End of macro CALLMONITOR
2a28				endif 
2a28			 
2a28					; found a uword but is it the one we want... 
2a28			 
2a28 c5					push bc     ; uword to find is on bc 
2a29 d1					pop de 
2a2a			 
2a2a e5					push hl  ; to save the ptr 
2a2b			 
2a2b					; skip opcode 
2a2b 23					inc hl  
2a2c					; skip next ptr 
2a2c 23					inc hl  
2a2d 23					inc hl 
2a2e					; skip len 
2a2e 23					inc hl 
2a2f			 
2a2f				if DEBUG_FORTH_WORDS 
2a2f					DMARK "LSc" 
2a2f f5				push af  
2a30 3a 44 2a			ld a, (.dmark)  
2a33 32 77 fb			ld (debug_mark),a  
2a36 3a 45 2a			ld a, (.dmark+1)  
2a39 32 78 fb			ld (debug_mark+1),a  
2a3c 3a 46 2a			ld a, (.dmark+2)  
2a3f 32 79 fb			ld (debug_mark+2),a  
2a42 18 03			jr .pastdmark  
2a44 ..			.dmark: db "LSc"  
2a47 f1			.pastdmark: pop af  
2a48			endm  
# End of macro DMARK
2a48					CALLMONITOR 
2a48 cd 49 17			call break_point_state  
2a4b				endm  
# End of macro CALLMONITOR
2a4b				endif 
2a4b cd a2 11				call strcmp 
2a4e c2 c5 29				jp nz, .ldouscanm 
2a51				 
2a51			 
2a51			 
2a51					; we have a uword so push its name to the stack 
2a51			 
2a51			;	   	push hl  ; save so we can move to next dict block 
2a51 e1			pop hl 
2a52			 
2a52				if DEBUG_FORTH_WORDS 
2a52					DMARK "LSm" 
2a52 f5				push af  
2a53 3a 67 2a			ld a, (.dmark)  
2a56 32 77 fb			ld (debug_mark),a  
2a59 3a 68 2a			ld a, (.dmark+1)  
2a5c 32 78 fb			ld (debug_mark+1),a  
2a5f 3a 69 2a			ld a, (.dmark+2)  
2a62 32 79 fb			ld (debug_mark+2),a  
2a65 18 03			jr .pastdmark  
2a67 ..			.dmark: db "LSm"  
2a6a f1			.pastdmark: pop af  
2a6b			endm  
# End of macro DMARK
2a6b					CALLMONITOR 
2a6b cd 49 17			call break_point_state  
2a6e				endm  
# End of macro CALLMONITOR
2a6e				endif 
2a6e			 
2a6e					; skip opcode 
2a6e 23					inc hl  
2a6f					; skip next ptr 
2a6f 23					inc hl  
2a70 23					inc hl 
2a71					; skip len 
2a71 7e					ld a, (hl)   ; save length to add 
2a72				if DEBUG_FORTH_WORDS 
2a72					DMARK "LS2" 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 77 fb			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 78 fb			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 79 fb			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "LS2"  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b					CALLMONITOR 
2a8b cd 49 17			call break_point_state  
2a8e				endm  
# End of macro CALLMONITOR
2a8e				endif 
2a8e			 
2a8e					; save this location 
2a8e				 
2a8e e5					push hl 
2a8f			 
2a8f 23					inc hl 
2a90 11 1f ee				ld de, scratch+2 
2a93 4f					ld c, a 
2a94 06 00				ld b, 0 
2a96			 
2a96				if DEBUG_FORTH_WORDS 
2a96					DMARK "LSn" 
2a96 f5				push af  
2a97 3a ab 2a			ld a, (.dmark)  
2a9a 32 77 fb			ld (debug_mark),a  
2a9d 3a ac 2a			ld a, (.dmark+1)  
2aa0 32 78 fb			ld (debug_mark+1),a  
2aa3 3a ad 2a			ld a, (.dmark+2)  
2aa6 32 79 fb			ld (debug_mark+2),a  
2aa9 18 03			jr .pastdmark  
2aab ..			.dmark: db "LSn"  
2aae f1			.pastdmark: pop af  
2aaf			endm  
# End of macro DMARK
2aaf					CALLMONITOR 
2aaf cd 49 17			call break_point_state  
2ab2				endm  
# End of macro CALLMONITOR
2ab2				endif 
2ab2			 
2ab2					; copy uword name to scratch 
2ab2			 
2ab2 ed b0				ldir 
2ab4			 
2ab4 1b					dec de 
2ab5 3e 20				ld a, ' '    ; change null to space 
2ab7 12					ld (de), a 
2ab8			 
2ab8 13					inc de 
2ab9			 
2ab9 d5					push de 
2aba c1					pop bc     ; move scratch pointer to end of word name and save it 
2abb			 
2abb e1					pop hl 
2abc 7e					ld a, (hl) 
2abd					;inc hl 
2abd					; skip word string 
2abd cd 0c 0d				call addatohl 
2ac0			 
2ac0 23					inc hl 
2ac1			 
2ac1				if DEBUG_FORTH_WORDS 
2ac1					DMARK "LS3" 
2ac1 f5				push af  
2ac2 3a d6 2a			ld a, (.dmark)  
2ac5 32 77 fb			ld (debug_mark),a  
2ac8 3a d7 2a			ld a, (.dmark+1)  
2acb 32 78 fb			ld (debug_mark+1),a  
2ace 3a d8 2a			ld a, (.dmark+2)  
2ad1 32 79 fb			ld (debug_mark+2),a  
2ad4 18 03			jr .pastdmark  
2ad6 ..			.dmark: db "LS3"  
2ad9 f1			.pastdmark: pop af  
2ada			endm  
# End of macro DMARK
2ada					CALLMONITOR 
2ada cd 49 17			call break_point_state  
2add				endm  
# End of macro CALLMONITOR
2add				endif 
2add					; should now be at the start of the machine code to setup the eval of the uword 
2add					; now locate the ptr to the string defintion 
2add			 
2add					; skip ld hl, 
2add					; then load the ptr 
2add			 
2add 23					inc hl 
2ade 5e					ld e, (hl) 
2adf 23					inc hl 
2ae0 56					ld d, (hl) 
2ae1 eb					ex de, hl 
2ae2			 
2ae2			 
2ae2				if DEBUG_FORTH_WORDS 
2ae2					DMARK "LSt" 
2ae2 f5				push af  
2ae3 3a f7 2a			ld a, (.dmark)  
2ae6 32 77 fb			ld (debug_mark),a  
2ae9 3a f8 2a			ld a, (.dmark+1)  
2aec 32 78 fb			ld (debug_mark+1),a  
2aef 3a f9 2a			ld a, (.dmark+2)  
2af2 32 79 fb			ld (debug_mark+2),a  
2af5 18 03			jr .pastdmark  
2af7 ..			.dmark: db "LSt"  
2afa f1			.pastdmark: pop af  
2afb			endm  
# End of macro DMARK
2afb					CALLMONITOR 
2afb cd 49 17			call break_point_state  
2afe				endm  
# End of macro CALLMONITOR
2afe				endif 
2afe			 
2afe			; cant push right now due to tokenised strings  
2afe			 
2afe			; get the destination of where to copy this definition to. 
2afe			 
2afe c5					push bc 
2aff d1					pop de 
2b00			 
2b00 7e			.listl:         ld a,(hl) 
2b01 fe 00				cp 0 
2b03 28 09				jr z, .lreplsp     ; replace zero with space 
2b05 fe 7f				cp FORTH_END_BUFFER 
2b07 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b09				 
2b09					; just copy this char as is then 
2b09			 
2b09 12					ld (de), a 
2b0a			 
2b0a 23			.listnxt:	inc hl 
2b0b 13					inc de 
2b0c 18 f2				jr .listl 
2b0e			 
2b0e 3e 20		.lreplsp:	ld a,' ' 
2b10 12					ld (de), a 
2b11 18 f7				jr .listnxt 
2b13			 
2b13			; close up uword def 
2b13			 
2b13			.listdone: 
2b13 3e 00				ld a, 0 
2b15 12					ld (de), a 
2b16			 
2b16			; now have def so clean up and push to stack 
2b16			 
2b16 21 1d ee				ld hl, scratch 
2b19				if DEBUG_FORTH_WORDS 
2b19					DMARK "Ltp" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 77 fb			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 78 fb			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 79 fb			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "Ltp"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32					CALLMONITOR 
2b32 cd 49 17			call break_point_state  
2b35				endm  
# End of macro CALLMONITOR
2b35				endif 
2b35			 
2b35 18 06			jr .listpush 
2b37			 
2b37			;.lnuword:	pop hl 
2b37			;		call forth_tok_next 
2b37			;		jp .ldouscan  
2b37			 
2b37			.lunotfound:		  
2b37			 
2b37			 
2b37					 
2b37					FORTH_DSP_POP 
2b37 cd 88 1f			call macro_forth_dsp_pop 
2b3a				endm 
# End of macro FORTH_DSP_POP
2b3a 21 43 2b				ld hl, .luno 
2b3d						 
2b3d			 
2b3d			.listpush: 
2b3d cd 47 1d				call forth_push_str 
2b40			 
2b40			 
2b40			 
2b40					NEXTW 
2b40 c3 42 20			jp macro_next 
2b43				endm 
# End of macro NEXTW
2b43			 
2b43 .. 00		.luno:    db "Not found",0 
2b4d			 
2b4d			 
2b4d			 
2b4d			 
2b4d			 
2b4d			;		push hl   ; save pointer to start of uword def string 
2b4d			; 
2b4d			;; look for FORTH_EOL_LINE 
2b4d			;		ld a, FORTH_END_BUFFER 
2b4d			;		call strlent 
2b4d			; 
2b4d			;		inc hl		 ; space for coln def 
2b4d			;		inc hl 
2b4d			;		inc hl          ; space for terms 
2b4d			;		inc hl 
2b4d			; 
2b4d			;		ld a, 20   ; TODO get actual length 
2b4d			;		call addatohl    ; include a random amount of room for the uword name 
2b4d			; 
2b4d			;		 
2b4d			;	if DEBUG_FORTH_WORDS 
2b4d			;		DMARK "Lt1" 
2b4d			;		CALLMONITOR 
2b4d			;	endif 
2b4d			;		 
2b4d			; 
2b4d			;; malloc space for the string because we cant change it 
2b4d			; 
2b4d			;		call malloc 
2b4d			;	if DEBUG_FORTH_MALLOC_GUARD 
2b4d			;		push af 
2b4d			;		call ishlzero 
2b4d			;		pop af 
2b4d			;		 
2b4d			;		call z,malloc_error 
2b4d			;	endif 
2b4d			; 
2b4d			;	if DEBUG_FORTH_WORDS 
2b4d			;		DMARK "Lt2" 
2b4d			;		CALLMONITOR 
2b4d			;	endif 
2b4d			;		pop de 
2b4d			;		push hl    ; push the malloc to release later 
2b4d			;		push hl   ;  push back a copy for the later stack push 
2b4d			;		 
2b4d			;; copy the string swapping out the zero terms for spaces 
2b4d			; 
2b4d			;		; de has our source 
2b4d			;		; hl has our dest 
2b4d			; 
2b4d			;; add the coln def 
2b4d			; 
2b4d			;		ld a, ':' 
2b4d			;		ld (hl), a 
2b4d			;		inc hl 
2b4d			;		ld a, ' ' 
2b4d			;		ld (hl), a 
2b4d			;		inc hl 
2b4d			; 
2b4d			;; add the uname word 
2b4d			;		push de   ; save our string for now 
2b4d			;		ex de, hl 
2b4d			; 
2b4d			;		FORTH_DSP_VALUE 
2b4d			;		;v5 FORTH_DSP_VALUE 
2b4d			; 
2b4d			;		inc hl   ; skip type but we know by now this is OK 
2b4d			; 
2b4d			;.luword:	ld a,(hl) 
2b4d			;		cp 0 
2b4d			;		jr z, .luword2 
2b4d			;		ld (de), a 
2b4d			;		inc de 
2b4d			;		inc hl 
2b4d			;		jr .luword 
2b4d			; 
2b4d			;.luword2:	ld a, ' ' 
2b4d			;		ld (de), a 
2b4d			;;		inc hl 
2b4d			;;		inc de 
2b4d			;;		ld (de), a 
2b4d			;;		inc hl 
2b4d			;		inc de 
2b4d			; 
2b4d			;		ex de, hl 
2b4d			;		pop de 
2b4d			;		 
2b4d			;		 
2b4d			; 
2b4d			;; detoken that string and copy it 
2b4d			; 
2b4d			;	if DEBUG_FORTH_WORDS 
2b4d			;		DMARK "Lt2" 
2b4d			;		CALLMONITOR 
2b4d			;	endif 
2b4d			;.ldetok:	ld a, (de) 
2b4d			;		cp FORTH_END_BUFFER 
2b4d			;		jr z, .ldetokend 
2b4d			;		; swap out any zero term for space 
2b4d			;		cp 0 
2b4d			;		jr nz, .ldetoknext 
2b4d			;		ld a, ' ' 
2b4d			; 
2b4d			;	if DEBUG_FORTH_WORDS 
2b4d			;		DMARK "LtS" 
2b4d			;		CALLMONITOR 
2b4d			;	endif 
2b4d			;.ldetoknext:	ld (hl), a 
2b4d			;		inc de 
2b4d			;		inc hl 
2b4d			;		jr .ldetok 
2b4d			; 
2b4d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b4d			;		ld (hl), a  
2b4d			; 
2b4d			;; free that temp malloc 
2b4d			; 
2b4d			;		pop hl    
2b4d			; 
2b4d			;	if DEBUG_FORTH_WORDS 
2b4d			;		DMARK "Lt4" 
2b4d			;		CALLMONITOR 
2b4d			;	endif 
2b4d			;		call forth_apushstrhl 
2b4d			; 
2b4d			;		; get rid of temp malloc area 
2b4d			; 
2b4d			;		pop hl 
2b4d			;		call free 
2b4d			; 
2b4d			;		jr .ludone 
2b4d			; 
2b4d			;.lnuword:	pop hl 
2b4d			;		call forth_tok_next 
2b4d			;		jp .ldouscan  
2b4d			; 
2b4d			;.ludone:		 pop hl 
2b4d			; 
2b4d					NEXTW 
2b4d c3 42 20			jp macro_next 
2b50				endm 
# End of macro NEXTW
2b50			 
2b50			.FORGET: 
2b50				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b50 5d				db WORD_SYS_CORE+73             
2b51 c9 2b			dw .NOP            
2b53 07				db 6 + 1 
2b54 .. 00			db "FORGET",0              
2b5b				endm 
# End of macro CWHEAD
2b5b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b5b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b5b			; | |  
2b5b			; | | e.g. "MORE" forget 
2b5b					if DEBUG_FORTH_WORDS_KEY 
2b5b						DMARK "FRG" 
2b5b f5				push af  
2b5c 3a 70 2b			ld a, (.dmark)  
2b5f 32 77 fb			ld (debug_mark),a  
2b62 3a 71 2b			ld a, (.dmark+1)  
2b65 32 78 fb			ld (debug_mark+1),a  
2b68 3a 72 2b			ld a, (.dmark+2)  
2b6b 32 79 fb			ld (debug_mark+2),a  
2b6e 18 03			jr .pastdmark  
2b70 ..			.dmark: db "FRG"  
2b73 f1			.pastdmark: pop af  
2b74			endm  
# End of macro DMARK
2b74						CALLMONITOR 
2b74 cd 49 17			call break_point_state  
2b77				endm  
# End of macro CALLMONITOR
2b77					endif 
2b77			 
2b77				; find uword 
2b77			        ; update start of word with "_" 
2b77				; replace uword with deleted flag 
2b77			 
2b77			 
2b77			;	if DEBUG_FORTH_WORDS 
2b77			;		DMARK "FOG" 
2b77			;		CALLMONITOR 
2b77			;	endif 
2b77			 
2b77			 
2b77					; Get ptr to the word we need to look up 
2b77			 
2b77					FORTH_DSP_VALUEHL 
2b77 cd d0 1e			call macro_dsp_valuehl 
2b7a				endm 
# End of macro FORTH_DSP_VALUEHL
2b7a					;v5 FORTH_DSP_VALUE 
2b7a				; TODO type check 
2b7a			;		inc hl    ; Skip type check  
2b7a e5					push hl 
2b7b c1					pop bc 
2b7c			;		ex de, hl    ; put into DE 
2b7c			 
2b7c			 
2b7c 21 00 80				ld hl, baseram 
2b7f					;ld hl, baseusermem 
2b7f			 
2b7f				; skip dict stub 
2b7f			;	call forth_tok_next 
2b7f e5			push hl   ; sacreifical push 
2b80			 
2b80			.fldouscanm: 
2b80 e1				pop hl 
2b81			.fldouscan: 
2b81			;	if DEBUG_FORTH_WORDS 
2b81			;		DMARK "LSs" 
2b81			;		CALLMONITOR 
2b81			;	endif 
2b81				; skip dict stub 
2b81 cd 93 21				call forth_tok_next 
2b84			 
2b84			 
2b84			; while we have words to look for 
2b84			 
2b84 7e				ld a, (hl)      
2b85			;	if DEBUG_FORTH_WORDS 
2b85			;		DMARK "LSk" 
2b85			;		CALLMONITOR 
2b85			;	endif 
2b85 fe 00				cp WORD_SYS_END 
2b87 ca c3 2b				jp z, .flunotfound 
2b8a fe 01				cp WORD_SYS_UWORD 
2b8c c2 81 2b				jp nz, .fldouscan 
2b8f			 
2b8f			;	if DEBUG_FORTH_WORDS 
2b8f			;		DMARK "LSu" 
2b8f			;		CALLMONITOR 
2b8f			;	endif 
2b8f			 
2b8f					; found a uword but is it the one we want... 
2b8f			 
2b8f c5					push bc     ; uword to find is on bc 
2b90 d1					pop de 
2b91			 
2b91 e5					push hl  ; to save the ptr 
2b92			 
2b92					; skip opcode 
2b92 23					inc hl  
2b93					; skip next ptr 
2b93 23					inc hl  
2b94 23					inc hl 
2b95					; skip len 
2b95 23					inc hl 
2b96			 
2b96			;	if DEBUG_FORTH_WORDS 
2b96			;		DMARK "LSc" 
2b96			;		CALLMONITOR 
2b96			;	endif 
2b96 cd a2 11				call strcmp 
2b99 c2 80 2b				jp nz, .fldouscanm 
2b9c			; 
2b9c			; 
2b9c			;; while we have words to look for 
2b9c			; 
2b9c			;.fdouscan:	ld a, (hl)      
2b9c			;	if DEBUG_FORTH_WORDS 
2b9c			;		DMARK "LSs" 
2b9c			;		CALLMONITOR 
2b9c			;	endif 
2b9c			;		cp WORD_SYS_END 
2b9c			;		jp z, .fudone 
2b9c			;		cp WORD_SYS_UWORD 
2b9c			;		jp nz, .fnuword 
2b9c			; 
2b9c			;	if DEBUG_FORTH_WORDS 
2b9c			;		DMARK "FGu" 
2b9c			;		CALLMONITOR 
2b9c			;	endif 
2b9c			; 
2b9c			;		; found a uword but is it the one we want... 
2b9c			; 
2b9c			; 
2b9c			;	        pop de   ; get back the dsp name 
2b9c			;		push de 
2b9c			; 
2b9c			;		push hl  ; to save the ptr 
2b9c			; 
2b9c			;		; skip opcode 
2b9c			;		inc hl  
2b9c			;		; skip next ptr 
2b9c			;		inc hl  
2b9c			;		inc hl 
2b9c			;		; skip len 
2b9c			;		inc hl 
2b9c			; 
2b9c			;	if DEBUG_FORTH_WORDS 
2b9c			;		DMARK "FGc" 
2b9c			;		CALLMONITOR 
2b9c			;	endif 
2b9c			;		call strcmp 
2b9c			;		jp nz, .fnuword 
2b9c			 
2b9c			 
2b9c e1			pop hl 
2b9d			 
2b9d				 
2b9d				if DEBUG_FORTH_WORDS 
2b9d					DMARK "FGm" 
2b9d f5				push af  
2b9e 3a b2 2b			ld a, (.dmark)  
2ba1 32 77 fb			ld (debug_mark),a  
2ba4 3a b3 2b			ld a, (.dmark+1)  
2ba7 32 78 fb			ld (debug_mark+1),a  
2baa 3a b4 2b			ld a, (.dmark+2)  
2bad 32 79 fb			ld (debug_mark+2),a  
2bb0 18 03			jr .pastdmark  
2bb2 ..			.dmark: db "FGm"  
2bb5 f1			.pastdmark: pop af  
2bb6			endm  
# End of macro DMARK
2bb6					CALLMONITOR 
2bb6 cd 49 17			call break_point_state  
2bb9				endm  
# End of macro CALLMONITOR
2bb9				endif 
2bb9			 
2bb9			 
2bb9			 
2bb9					; we have a uword so push its name to the stack 
2bb9			 
2bb9			;	   	push hl  ; save so we can move to next dict block 
2bb9			;pop hl 
2bb9			 
2bb9					; update opcode to deleted 
2bb9 3e 03				ld a, WORD_SYS_DELETED 
2bbb 77					ld (hl), a 
2bbc			 
2bbc 23					inc hl  
2bbd					; skip next ptr 
2bbd 23					inc hl  
2bbe 23					inc hl 
2bbf					; skip len 
2bbf 23					inc hl 
2bc0			 
2bc0					; TODO change parser to skip deleted words but for now mark it out 
2bc0 3e 5f				ld a, "_" 
2bc2 77					ld  (hl),a 
2bc3			 
2bc3			;		jr .fudone 
2bc3			; 
2bc3			;.fnuword:	pop hl 
2bc3			;		call forth_tok_next 
2bc3			;		jp .fdouscan  
2bc3			 
2bc3			.flunotfound:		  
2bc3			 
2bc3			 
2bc3					 
2bc3					FORTH_DSP_POP 
2bc3 cd 88 1f			call macro_forth_dsp_pop 
2bc6				endm 
# End of macro FORTH_DSP_POP
2bc6			;		ld hl, .luno 
2bc6			;.fudone:		 pop hl 
2bc6					NEXTW 
2bc6 c3 42 20			jp macro_next 
2bc9				endm 
# End of macro NEXTW
2bc9			.NOP: 
2bc9				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bc9 61				db WORD_SYS_CORE+77             
2bca f0 2b			dw .COMO            
2bcc 04				db 3 + 1 
2bcd .. 00			db "NOP",0              
2bd1				endm 
# End of macro CWHEAD
2bd1			; | NOP (  --  ) Do nothing | DONE 
2bd1					if DEBUG_FORTH_WORDS_KEY 
2bd1						DMARK "NOP" 
2bd1 f5				push af  
2bd2 3a e6 2b			ld a, (.dmark)  
2bd5 32 77 fb			ld (debug_mark),a  
2bd8 3a e7 2b			ld a, (.dmark+1)  
2bdb 32 78 fb			ld (debug_mark+1),a  
2bde 3a e8 2b			ld a, (.dmark+2)  
2be1 32 79 fb			ld (debug_mark+2),a  
2be4 18 03			jr .pastdmark  
2be6 ..			.dmark: db "NOP"  
2be9 f1			.pastdmark: pop af  
2bea			endm  
# End of macro DMARK
2bea						CALLMONITOR 
2bea cd 49 17			call break_point_state  
2bed				endm  
# End of macro CALLMONITOR
2bed					endif 
2bed				       NEXTW 
2bed c3 42 20			jp macro_next 
2bf0				endm 
# End of macro NEXTW
2bf0			.COMO: 
2bf0				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bf0 6e				db WORD_SYS_CORE+90             
2bf1 42 2c			dw .COMC            
2bf3 02				db 1 + 1 
2bf4 .. 00			db "(",0              
2bf6				endm 
# End of macro CWHEAD
2bf6			; | ( ( -- )  Start of comment | DONE 
2bf6			 
2bf6			 
2bf6 2a 1e f1				ld hl, ( os_tok_ptr) 
2bf9 11 3d 2c			ld de, .closepar 
2bfc					 
2bfc					if DEBUG_FORTH_WORDS 
2bfc						DMARK ").." 
2bfc f5				push af  
2bfd 3a 11 2c			ld a, (.dmark)  
2c00 32 77 fb			ld (debug_mark),a  
2c03 3a 12 2c			ld a, (.dmark+1)  
2c06 32 78 fb			ld (debug_mark+1),a  
2c09 3a 13 2c			ld a, (.dmark+2)  
2c0c 32 79 fb			ld (debug_mark+2),a  
2c0f 18 03			jr .pastdmark  
2c11 ..			.dmark: db ").."  
2c14 f1			.pastdmark: pop af  
2c15			endm  
# End of macro DMARK
2c15						CALLMONITOR 
2c15 cd 49 17			call break_point_state  
2c18				endm  
# End of macro CALLMONITOR
2c18					endif 
2c18 cd 5d 21			call findnexttok  
2c1b			 
2c1b					if DEBUG_FORTH_WORDS 
2c1b						DMARK "IF5" 
2c1b f5				push af  
2c1c 3a 30 2c			ld a, (.dmark)  
2c1f 32 77 fb			ld (debug_mark),a  
2c22 3a 31 2c			ld a, (.dmark+1)  
2c25 32 78 fb			ld (debug_mark+1),a  
2c28 3a 32 2c			ld a, (.dmark+2)  
2c2b 32 79 fb			ld (debug_mark+2),a  
2c2e 18 03			jr .pastdmark  
2c30 ..			.dmark: db "IF5"  
2c33 f1			.pastdmark: pop af  
2c34			endm  
# End of macro DMARK
2c34						CALLMONITOR 
2c34 cd 49 17			call break_point_state  
2c37				endm  
# End of macro CALLMONITOR
2c37					endif 
2c37				; replace below with ) exec using tok_ptr 
2c37 22 1e f1			ld (os_tok_ptr), hl 
2c3a c3 d3 20			jp exec1 
2c3d			 
2c3d .. 00			.closepar:   db ")",0 
2c3f			 
2c3f				       NEXTW 
2c3f c3 42 20			jp macro_next 
2c42				endm 
# End of macro NEXTW
2c42			.COMC: 
2c42				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c42 6f				db WORD_SYS_CORE+91             
2c43 4b 2c			dw .SCRATCH            
2c45 02				db 1 + 1 
2c46 .. 00			db ")",0              
2c48				endm 
# End of macro CWHEAD
2c48			; | ) ( -- )  End of comment |  DONE  
2c48				       NEXTW 
2c48 c3 42 20			jp macro_next 
2c4b				endm 
# End of macro NEXTW
2c4b			 
2c4b			.SCRATCH: 
2c4b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c4b 6f				db WORD_SYS_CORE+91             
2c4c 86 2c			dw .INC            
2c4e 08				db 7 + 1 
2c4f .. 00			db "SCRATCH",0              
2c57				endm 
# End of macro CWHEAD
2c57			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c57			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c57			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c57			; | |  
2c57			; | | e.g.    : score $00 scratch ; 
2c57			; | |  
2c57			; | | $00 score ! 
2c57			; | | $01 score +! 
2c57			; | |  
2c57			; | | e.g.   : varword $0a scratch ;  
2c57			; | | 
2c57			; | | $8000 varword ! 
2c57					if DEBUG_FORTH_WORDS_KEY 
2c57						DMARK "SCR" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 77 fb			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 78 fb			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 79 fb			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "SCR"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70						CALLMONITOR 
2c70 cd 49 17			call break_point_state  
2c73				endm  
# End of macro CALLMONITOR
2c73					endif 
2c73			 
2c73					FORTH_DSP_VALUEHL 
2c73 cd d0 1e			call macro_dsp_valuehl 
2c76				endm 
# End of macro FORTH_DSP_VALUEHL
2c76				 
2c76					FORTH_DSP_POP 
2c76 cd 88 1f			call macro_forth_dsp_pop 
2c79				endm 
# End of macro FORTH_DSP_POP
2c79			 
2c79 7d					ld a, l 
2c7a 21 42 f3				ld hl, os_var_array 
2c7d cd 0c 0d				call addatohl 
2c80			 
2c80 cd d9 1c				call forth_push_numhl 
2c83			 
2c83				       NEXTW 
2c83 c3 42 20			jp macro_next 
2c86				endm 
# End of macro NEXTW
2c86			 
2c86			.INC: 
2c86				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c86 6f				db WORD_SYS_CORE+91             
2c87 da 2c			dw .DEC            
2c89 03				db 2 + 1 
2c8a .. 00			db "+!",0              
2c8d				endm 
# End of macro CWHEAD
2c8d			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c8d					if DEBUG_FORTH_WORDS_KEY 
2c8d						DMARK "+s_" 
2c8d f5				push af  
2c8e 3a a2 2c			ld a, (.dmark)  
2c91 32 77 fb			ld (debug_mark),a  
2c94 3a a3 2c			ld a, (.dmark+1)  
2c97 32 78 fb			ld (debug_mark+1),a  
2c9a 3a a4 2c			ld a, (.dmark+2)  
2c9d 32 79 fb			ld (debug_mark+2),a  
2ca0 18 03			jr .pastdmark  
2ca2 ..			.dmark: db "+s_"  
2ca5 f1			.pastdmark: pop af  
2ca6			endm  
# End of macro DMARK
2ca6						CALLMONITOR 
2ca6 cd 49 17			call break_point_state  
2ca9				endm  
# End of macro CALLMONITOR
2ca9					endif 
2ca9			 
2ca9					FORTH_DSP_VALUEHL 
2ca9 cd d0 1e			call macro_dsp_valuehl 
2cac				endm 
# End of macro FORTH_DSP_VALUEHL
2cac			 
2cac e5					push hl   ; save address 
2cad			 
2cad					FORTH_DSP_POP 
2cad cd 88 1f			call macro_forth_dsp_pop 
2cb0				endm 
# End of macro FORTH_DSP_POP
2cb0			 
2cb0					FORTH_DSP_VALUEHL 
2cb0 cd d0 1e			call macro_dsp_valuehl 
2cb3				endm 
# End of macro FORTH_DSP_VALUEHL
2cb3			 
2cb3					FORTH_DSP_POP 
2cb3 cd 88 1f			call macro_forth_dsp_pop 
2cb6				endm 
# End of macro FORTH_DSP_POP
2cb6			 
2cb6					; hl contains value to add to byte at a 
2cb6				 
2cb6 eb					ex de, hl 
2cb7			 
2cb7 e1					pop hl 
2cb8			 
2cb8					if DEBUG_FORTH_WORDS 
2cb8						DMARK "INC" 
2cb8 f5				push af  
2cb9 3a cd 2c			ld a, (.dmark)  
2cbc 32 77 fb			ld (debug_mark),a  
2cbf 3a ce 2c			ld a, (.dmark+1)  
2cc2 32 78 fb			ld (debug_mark+1),a  
2cc5 3a cf 2c			ld a, (.dmark+2)  
2cc8 32 79 fb			ld (debug_mark+2),a  
2ccb 18 03			jr .pastdmark  
2ccd ..			.dmark: db "INC"  
2cd0 f1			.pastdmark: pop af  
2cd1			endm  
# End of macro DMARK
2cd1						CALLMONITOR 
2cd1 cd 49 17			call break_point_state  
2cd4				endm  
# End of macro CALLMONITOR
2cd4					endif 
2cd4			 
2cd4 7e					ld a,(hl) 
2cd5 83					add e 
2cd6 77					ld (hl),a 
2cd7			 
2cd7			 
2cd7			 
2cd7				       NEXTW 
2cd7 c3 42 20			jp macro_next 
2cda				endm 
# End of macro NEXTW
2cda			 
2cda			.DEC: 
2cda				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cda 6f				db WORD_SYS_CORE+91             
2cdb 2b 2d			dw .INC2            
2cdd 03				db 2 + 1 
2cde .. 00			db "-!",0              
2ce1				endm 
# End of macro CWHEAD
2ce1			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ce1					if DEBUG_FORTH_WORDS_KEY 
2ce1						DMARK "-s_" 
2ce1 f5				push af  
2ce2 3a f6 2c			ld a, (.dmark)  
2ce5 32 77 fb			ld (debug_mark),a  
2ce8 3a f7 2c			ld a, (.dmark+1)  
2ceb 32 78 fb			ld (debug_mark+1),a  
2cee 3a f8 2c			ld a, (.dmark+2)  
2cf1 32 79 fb			ld (debug_mark+2),a  
2cf4 18 03			jr .pastdmark  
2cf6 ..			.dmark: db "-s_"  
2cf9 f1			.pastdmark: pop af  
2cfa			endm  
# End of macro DMARK
2cfa						CALLMONITOR 
2cfa cd 49 17			call break_point_state  
2cfd				endm  
# End of macro CALLMONITOR
2cfd					endif 
2cfd			 
2cfd					FORTH_DSP_VALUEHL 
2cfd cd d0 1e			call macro_dsp_valuehl 
2d00				endm 
# End of macro FORTH_DSP_VALUEHL
2d00			 
2d00 e5					push hl   ; save address 
2d01			 
2d01					FORTH_DSP_POP 
2d01 cd 88 1f			call macro_forth_dsp_pop 
2d04				endm 
# End of macro FORTH_DSP_POP
2d04			 
2d04					FORTH_DSP_VALUEHL 
2d04 cd d0 1e			call macro_dsp_valuehl 
2d07				endm 
# End of macro FORTH_DSP_VALUEHL
2d07			 
2d07					; hl contains value to add to byte at a 
2d07				 
2d07 eb					ex de, hl 
2d08			 
2d08 e1					pop hl 
2d09			 
2d09					if DEBUG_FORTH_WORDS 
2d09						DMARK "DEC" 
2d09 f5				push af  
2d0a 3a 1e 2d			ld a, (.dmark)  
2d0d 32 77 fb			ld (debug_mark),a  
2d10 3a 1f 2d			ld a, (.dmark+1)  
2d13 32 78 fb			ld (debug_mark+1),a  
2d16 3a 20 2d			ld a, (.dmark+2)  
2d19 32 79 fb			ld (debug_mark+2),a  
2d1c 18 03			jr .pastdmark  
2d1e ..			.dmark: db "DEC"  
2d21 f1			.pastdmark: pop af  
2d22			endm  
# End of macro DMARK
2d22						CALLMONITOR 
2d22 cd 49 17			call break_point_state  
2d25				endm  
# End of macro CALLMONITOR
2d25					endif 
2d25			 
2d25 7e					ld a,(hl) 
2d26 93					sub e 
2d27 77					ld (hl),a 
2d28			 
2d28			 
2d28			 
2d28				       NEXTW 
2d28 c3 42 20			jp macro_next 
2d2b				endm 
# End of macro NEXTW
2d2b			 
2d2b			.INC2: 
2d2b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d2b 6f				db WORD_SYS_CORE+91             
2d2c d5 2d			dw .DEC2            
2d2e 04				db 3 + 1 
2d2f .. 00			db "+2!",0              
2d33				endm 
# End of macro CWHEAD
2d33			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d33			 
2d33					if DEBUG_FORTH_WORDS_KEY 
2d33						DMARK "+2s" 
2d33 f5				push af  
2d34 3a 48 2d			ld a, (.dmark)  
2d37 32 77 fb			ld (debug_mark),a  
2d3a 3a 49 2d			ld a, (.dmark+1)  
2d3d 32 78 fb			ld (debug_mark+1),a  
2d40 3a 4a 2d			ld a, (.dmark+2)  
2d43 32 79 fb			ld (debug_mark+2),a  
2d46 18 03			jr .pastdmark  
2d48 ..			.dmark: db "+2s"  
2d4b f1			.pastdmark: pop af  
2d4c			endm  
# End of macro DMARK
2d4c						CALLMONITOR 
2d4c cd 49 17			call break_point_state  
2d4f				endm  
# End of macro CALLMONITOR
2d4f					endif 
2d4f			 
2d4f					; Address 
2d4f			 
2d4f					FORTH_DSP_VALUEHL 
2d4f cd d0 1e			call macro_dsp_valuehl 
2d52				endm 
# End of macro FORTH_DSP_VALUEHL
2d52			 
2d52 e5					push hl    ; save address 
2d53			 
2d53					; load content into de 
2d53			 
2d53 5e					ld e,(hl) 
2d54 23					inc hl 
2d55 56					ld d, (hl) 
2d56			 
2d56					if DEBUG_FORTH_WORDS 
2d56						DMARK "+2a" 
2d56 f5				push af  
2d57 3a 6b 2d			ld a, (.dmark)  
2d5a 32 77 fb			ld (debug_mark),a  
2d5d 3a 6c 2d			ld a, (.dmark+1)  
2d60 32 78 fb			ld (debug_mark+1),a  
2d63 3a 6d 2d			ld a, (.dmark+2)  
2d66 32 79 fb			ld (debug_mark+2),a  
2d69 18 03			jr .pastdmark  
2d6b ..			.dmark: db "+2a"  
2d6e f1			.pastdmark: pop af  
2d6f			endm  
# End of macro DMARK
2d6f						CALLMONITOR 
2d6f cd 49 17			call break_point_state  
2d72				endm  
# End of macro CALLMONITOR
2d72					endif 
2d72			 
2d72					FORTH_DSP_POP 
2d72 cd 88 1f			call macro_forth_dsp_pop 
2d75				endm 
# End of macro FORTH_DSP_POP
2d75			 
2d75					; Get value to add 
2d75			 
2d75					FORTH_DSP_VALUE 
2d75 cd b9 1e			call macro_forth_dsp_value 
2d78				endm 
# End of macro FORTH_DSP_VALUE
2d78			 
2d78					if DEBUG_FORTH_WORDS 
2d78						DMARK "+2v" 
2d78 f5				push af  
2d79 3a 8d 2d			ld a, (.dmark)  
2d7c 32 77 fb			ld (debug_mark),a  
2d7f 3a 8e 2d			ld a, (.dmark+1)  
2d82 32 78 fb			ld (debug_mark+1),a  
2d85 3a 8f 2d			ld a, (.dmark+2)  
2d88 32 79 fb			ld (debug_mark+2),a  
2d8b 18 03			jr .pastdmark  
2d8d ..			.dmark: db "+2v"  
2d90 f1			.pastdmark: pop af  
2d91			endm  
# End of macro DMARK
2d91						CALLMONITOR 
2d91 cd 49 17			call break_point_state  
2d94				endm  
# End of macro CALLMONITOR
2d94					endif 
2d94			 
2d94 19					add hl, de 
2d95			 
2d95					if DEBUG_FORTH_WORDS 
2d95						DMARK "+2+" 
2d95 f5				push af  
2d96 3a aa 2d			ld a, (.dmark)  
2d99 32 77 fb			ld (debug_mark),a  
2d9c 3a ab 2d			ld a, (.dmark+1)  
2d9f 32 78 fb			ld (debug_mark+1),a  
2da2 3a ac 2d			ld a, (.dmark+2)  
2da5 32 79 fb			ld (debug_mark+2),a  
2da8 18 03			jr .pastdmark  
2daa ..			.dmark: db "+2+"  
2dad f1			.pastdmark: pop af  
2dae			endm  
# End of macro DMARK
2dae						CALLMONITOR 
2dae cd 49 17			call break_point_state  
2db1				endm  
# End of macro CALLMONITOR
2db1					endif 
2db1			 
2db1					; move result to de 
2db1			 
2db1 eb					ex de, hl 
2db2			 
2db2					; Address 
2db2			 
2db2 e1					pop hl 
2db3			 
2db3					; save it back 
2db3			 
2db3 73					ld (hl), e 
2db4 23					inc hl 
2db5 72					ld (hl), d 
2db6			 
2db6					if DEBUG_FORTH_WORDS 
2db6						DMARK "+2e" 
2db6 f5				push af  
2db7 3a cb 2d			ld a, (.dmark)  
2dba 32 77 fb			ld (debug_mark),a  
2dbd 3a cc 2d			ld a, (.dmark+1)  
2dc0 32 78 fb			ld (debug_mark+1),a  
2dc3 3a cd 2d			ld a, (.dmark+2)  
2dc6 32 79 fb			ld (debug_mark+2),a  
2dc9 18 03			jr .pastdmark  
2dcb ..			.dmark: db "+2e"  
2dce f1			.pastdmark: pop af  
2dcf			endm  
# End of macro DMARK
2dcf						CALLMONITOR 
2dcf cd 49 17			call break_point_state  
2dd2				endm  
# End of macro CALLMONITOR
2dd2					endif 
2dd2			 
2dd2			 
2dd2			 
2dd2			 
2dd2			 
2dd2				       NEXTW 
2dd2 c3 42 20			jp macro_next 
2dd5				endm 
# End of macro NEXTW
2dd5			 
2dd5			.DEC2: 
2dd5				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dd5 6f				db WORD_SYS_CORE+91             
2dd6 81 2e			dw .GET2            
2dd8 04				db 3 + 1 
2dd9 .. 00			db "-2!",0              
2ddd				endm 
# End of macro CWHEAD
2ddd			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2ddd			 
2ddd			 
2ddd					if DEBUG_FORTH_WORDS_KEY 
2ddd						DMARK "-2s" 
2ddd f5				push af  
2dde 3a f2 2d			ld a, (.dmark)  
2de1 32 77 fb			ld (debug_mark),a  
2de4 3a f3 2d			ld a, (.dmark+1)  
2de7 32 78 fb			ld (debug_mark+1),a  
2dea 3a f4 2d			ld a, (.dmark+2)  
2ded 32 79 fb			ld (debug_mark+2),a  
2df0 18 03			jr .pastdmark  
2df2 ..			.dmark: db "-2s"  
2df5 f1			.pastdmark: pop af  
2df6			endm  
# End of macro DMARK
2df6						CALLMONITOR 
2df6 cd 49 17			call break_point_state  
2df9				endm  
# End of macro CALLMONITOR
2df9					endif 
2df9			 
2df9					; Address 
2df9			 
2df9					FORTH_DSP_VALUEHL 
2df9 cd d0 1e			call macro_dsp_valuehl 
2dfc				endm 
# End of macro FORTH_DSP_VALUEHL
2dfc			 
2dfc e5					push hl    ; save address 
2dfd			 
2dfd					; load content into de 
2dfd			 
2dfd 5e					ld e,(hl) 
2dfe 23					inc hl 
2dff 56					ld d, (hl) 
2e00			 
2e00					if DEBUG_FORTH_WORDS 
2e00						DMARK "-2a" 
2e00 f5				push af  
2e01 3a 15 2e			ld a, (.dmark)  
2e04 32 77 fb			ld (debug_mark),a  
2e07 3a 16 2e			ld a, (.dmark+1)  
2e0a 32 78 fb			ld (debug_mark+1),a  
2e0d 3a 17 2e			ld a, (.dmark+2)  
2e10 32 79 fb			ld (debug_mark+2),a  
2e13 18 03			jr .pastdmark  
2e15 ..			.dmark: db "-2a"  
2e18 f1			.pastdmark: pop af  
2e19			endm  
# End of macro DMARK
2e19						CALLMONITOR 
2e19 cd 49 17			call break_point_state  
2e1c				endm  
# End of macro CALLMONITOR
2e1c					endif 
2e1c			 
2e1c					FORTH_DSP_POP 
2e1c cd 88 1f			call macro_forth_dsp_pop 
2e1f				endm 
# End of macro FORTH_DSP_POP
2e1f			 
2e1f					; Get value to remove 
2e1f			 
2e1f					FORTH_DSP_VALUE 
2e1f cd b9 1e			call macro_forth_dsp_value 
2e22				endm 
# End of macro FORTH_DSP_VALUE
2e22			 
2e22					if DEBUG_FORTH_WORDS 
2e22						DMARK "-2v" 
2e22 f5				push af  
2e23 3a 37 2e			ld a, (.dmark)  
2e26 32 77 fb			ld (debug_mark),a  
2e29 3a 38 2e			ld a, (.dmark+1)  
2e2c 32 78 fb			ld (debug_mark+1),a  
2e2f 3a 39 2e			ld a, (.dmark+2)  
2e32 32 79 fb			ld (debug_mark+2),a  
2e35 18 03			jr .pastdmark  
2e37 ..			.dmark: db "-2v"  
2e3a f1			.pastdmark: pop af  
2e3b			endm  
# End of macro DMARK
2e3b						CALLMONITOR 
2e3b cd 49 17			call break_point_state  
2e3e				endm  
# End of macro CALLMONITOR
2e3e					endif 
2e3e			 
2e3e eb					ex de, hl 
2e3f ed 52				sbc hl, de 
2e41			 
2e41					if DEBUG_FORTH_WORDS 
2e41						DMARK "-2d" 
2e41 f5				push af  
2e42 3a 56 2e			ld a, (.dmark)  
2e45 32 77 fb			ld (debug_mark),a  
2e48 3a 57 2e			ld a, (.dmark+1)  
2e4b 32 78 fb			ld (debug_mark+1),a  
2e4e 3a 58 2e			ld a, (.dmark+2)  
2e51 32 79 fb			ld (debug_mark+2),a  
2e54 18 03			jr .pastdmark  
2e56 ..			.dmark: db "-2d"  
2e59 f1			.pastdmark: pop af  
2e5a			endm  
# End of macro DMARK
2e5a						CALLMONITOR 
2e5a cd 49 17			call break_point_state  
2e5d				endm  
# End of macro CALLMONITOR
2e5d					endif 
2e5d			 
2e5d					; move result to de 
2e5d			 
2e5d eb					ex de, hl 
2e5e			 
2e5e					; Address 
2e5e			 
2e5e e1					pop hl 
2e5f			 
2e5f					; save it back 
2e5f			 
2e5f 73					ld (hl), e 
2e60 23					inc hl 
2e61 72					ld (hl), d 
2e62			 
2e62					if DEBUG_FORTH_WORDS 
2e62						DMARK "-2e" 
2e62 f5				push af  
2e63 3a 77 2e			ld a, (.dmark)  
2e66 32 77 fb			ld (debug_mark),a  
2e69 3a 78 2e			ld a, (.dmark+1)  
2e6c 32 78 fb			ld (debug_mark+1),a  
2e6f 3a 79 2e			ld a, (.dmark+2)  
2e72 32 79 fb			ld (debug_mark+2),a  
2e75 18 03			jr .pastdmark  
2e77 ..			.dmark: db "-2e"  
2e7a f1			.pastdmark: pop af  
2e7b			endm  
# End of macro DMARK
2e7b						CALLMONITOR 
2e7b cd 49 17			call break_point_state  
2e7e				endm  
# End of macro CALLMONITOR
2e7e					endif 
2e7e			 
2e7e			 
2e7e			 
2e7e			 
2e7e			 
2e7e				       NEXTW 
2e7e c3 42 20			jp macro_next 
2e81				endm 
# End of macro NEXTW
2e81			.GET2: 
2e81				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e81 6f				db WORD_SYS_CORE+91             
2e82 b1 2e			dw .BANG2            
2e84 03				db 2 + 1 
2e85 .. 00			db "2@",0              
2e88				endm 
# End of macro CWHEAD
2e88			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e88					if DEBUG_FORTH_WORDS_KEY 
2e88						DMARK "2A_" 
2e88 f5				push af  
2e89 3a 9d 2e			ld a, (.dmark)  
2e8c 32 77 fb			ld (debug_mark),a  
2e8f 3a 9e 2e			ld a, (.dmark+1)  
2e92 32 78 fb			ld (debug_mark+1),a  
2e95 3a 9f 2e			ld a, (.dmark+2)  
2e98 32 79 fb			ld (debug_mark+2),a  
2e9b 18 03			jr .pastdmark  
2e9d ..			.dmark: db "2A_"  
2ea0 f1			.pastdmark: pop af  
2ea1			endm  
# End of macro DMARK
2ea1						CALLMONITOR 
2ea1 cd 49 17			call break_point_state  
2ea4				endm  
# End of macro CALLMONITOR
2ea4					endif 
2ea4			 
2ea4					FORTH_DSP_VALUEHL 
2ea4 cd d0 1e			call macro_dsp_valuehl 
2ea7				endm 
# End of macro FORTH_DSP_VALUEHL
2ea7			 
2ea7 5e					ld e, (hl) 
2ea8 23					inc hl 
2ea9 56					ld d, (hl) 
2eaa			 
2eaa eb					ex de, hl 
2eab			 
2eab cd d9 1c				call forth_push_numhl 
2eae			 
2eae				       NEXTW 
2eae c3 42 20			jp macro_next 
2eb1				endm 
# End of macro NEXTW
2eb1			.BANG2: 
2eb1				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2eb1 6f				db WORD_SYS_CORE+91             
2eb2 e9 2e			dw .CONFIG            
2eb4 03				db 2 + 1 
2eb5 .. 00			db "2!",0              
2eb8				endm 
# End of macro CWHEAD
2eb8			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2eb8					if DEBUG_FORTH_WORDS_KEY 
2eb8						DMARK "2S_" 
2eb8 f5				push af  
2eb9 3a cd 2e			ld a, (.dmark)  
2ebc 32 77 fb			ld (debug_mark),a  
2ebf 3a ce 2e			ld a, (.dmark+1)  
2ec2 32 78 fb			ld (debug_mark+1),a  
2ec5 3a cf 2e			ld a, (.dmark+2)  
2ec8 32 79 fb			ld (debug_mark+2),a  
2ecb 18 03			jr .pastdmark  
2ecd ..			.dmark: db "2S_"  
2ed0 f1			.pastdmark: pop af  
2ed1			endm  
# End of macro DMARK
2ed1						CALLMONITOR 
2ed1 cd 49 17			call break_point_state  
2ed4				endm  
# End of macro CALLMONITOR
2ed4					endif 
2ed4			 
2ed4					FORTH_DSP_VALUEHL 
2ed4 cd d0 1e			call macro_dsp_valuehl 
2ed7				endm 
# End of macro FORTH_DSP_VALUEHL
2ed7			 
2ed7 e5					push hl   ; save address 
2ed8			 
2ed8			 
2ed8					FORTH_DSP_POP 
2ed8 cd 88 1f			call macro_forth_dsp_pop 
2edb				endm 
# End of macro FORTH_DSP_POP
2edb			 
2edb					 
2edb					FORTH_DSP_VALUEHL 
2edb cd d0 1e			call macro_dsp_valuehl 
2ede				endm 
# End of macro FORTH_DSP_VALUEHL
2ede			 
2ede					FORTH_DSP_POP 
2ede cd 88 1f			call macro_forth_dsp_pop 
2ee1				endm 
# End of macro FORTH_DSP_POP
2ee1			 
2ee1 eb					ex de, hl    ; value now in de 
2ee2			 
2ee2 e1					pop hl 
2ee3			 
2ee3 73					ld (hl), e 
2ee4			 
2ee4 23					inc hl 
2ee5			 
2ee5 72					ld (hl), d 
2ee6			 
2ee6			 
2ee6				       NEXTW 
2ee6 c3 42 20			jp macro_next 
2ee9				endm 
# End of macro NEXTW
2ee9			.CONFIG: 
2ee9				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2ee9 6f				db WORD_SYS_CORE+91             
2eea fa 2e			dw .ENDCORE            
2eec 07				db 6 + 1 
2eed .. 00			db "CONFIG",0              
2ef4				endm 
# End of macro CWHEAD
2ef4			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ef4			 
2ef4 cd 96 13				call config 
2ef7					NEXTW 
2ef7 c3 42 20			jp macro_next 
2efa				endm 
# End of macro NEXTW
2efa			.ENDCORE: 
2efa			 
2efa			; eof 
2efa			 
2efa			 
# End of file forth_words_core.asm
2efa			include "forth_words_flow.asm" 
2efa			 
2efa			; | ## Program Flow Words 
2efa			 
2efa			.IF: 
2efa				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2efa 1e				db WORD_SYS_CORE+10             
2efb ef 2f			dw .THEN            
2efd 03				db 2 + 1 
2efe .. 00			db "IF",0              
2f01				endm 
# End of macro CWHEAD
2f01			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f01			; 
2f01					if DEBUG_FORTH_WORDS_KEY 
2f01						DMARK "IF." 
2f01 f5				push af  
2f02 3a 16 2f			ld a, (.dmark)  
2f05 32 77 fb			ld (debug_mark),a  
2f08 3a 17 2f			ld a, (.dmark+1)  
2f0b 32 78 fb			ld (debug_mark+1),a  
2f0e 3a 18 2f			ld a, (.dmark+2)  
2f11 32 79 fb			ld (debug_mark+2),a  
2f14 18 03			jr .pastdmark  
2f16 ..			.dmark: db "IF."  
2f19 f1			.pastdmark: pop af  
2f1a			endm  
# End of macro DMARK
2f1a						CALLMONITOR 
2f1a cd 49 17			call break_point_state  
2f1d				endm  
# End of macro CALLMONITOR
2f1d					endif 
2f1d			; eval TOS 
2f1d			 
2f1d				FORTH_DSP_VALUEHL 
2f1d cd d0 1e			call macro_dsp_valuehl 
2f20				endm 
# End of macro FORTH_DSP_VALUEHL
2f20			 
2f20			;	push hl 
2f20				FORTH_DSP_POP 
2f20 cd 88 1f			call macro_forth_dsp_pop 
2f23				endm 
# End of macro FORTH_DSP_POP
2f23			;	pop hl 
2f23			 
2f23					if DEBUG_FORTH_WORDS 
2f23						DMARK "IF1" 
2f23 f5				push af  
2f24 3a 38 2f			ld a, (.dmark)  
2f27 32 77 fb			ld (debug_mark),a  
2f2a 3a 39 2f			ld a, (.dmark+1)  
2f2d 32 78 fb			ld (debug_mark+1),a  
2f30 3a 3a 2f			ld a, (.dmark+2)  
2f33 32 79 fb			ld (debug_mark+2),a  
2f36 18 03			jr .pastdmark  
2f38 ..			.dmark: db "IF1"  
2f3b f1			.pastdmark: pop af  
2f3c			endm  
# End of macro DMARK
2f3c						CALLMONITOR 
2f3c cd 49 17			call break_point_state  
2f3f				endm  
# End of macro CALLMONITOR
2f3f					endif 
2f3f b7				or a        ; clear carry flag 
2f40 11 00 00			ld de, 0 
2f43 eb				ex de,hl 
2f44 ed 52			sbc hl, de 
2f46 c2 d0 2f			jp nz, .iftrue 
2f49			 
2f49					if DEBUG_FORTH_WORDS 
2f49						DMARK "IF2" 
2f49 f5				push af  
2f4a 3a 5e 2f			ld a, (.dmark)  
2f4d 32 77 fb			ld (debug_mark),a  
2f50 3a 5f 2f			ld a, (.dmark+1)  
2f53 32 78 fb			ld (debug_mark+1),a  
2f56 3a 60 2f			ld a, (.dmark+2)  
2f59 32 79 fb			ld (debug_mark+2),a  
2f5c 18 03			jr .pastdmark  
2f5e ..			.dmark: db "IF2"  
2f61 f1			.pastdmark: pop af  
2f62			endm  
# End of macro DMARK
2f62						CALLMONITOR 
2f62 cd 49 17			call break_point_state  
2f65				endm  
# End of macro CALLMONITOR
2f65					endif 
2f65			 
2f65			; if not true then skip to THEN 
2f65			 
2f65				; TODO get tok_ptr 
2f65				; TODO consume toks until we get to THEN 
2f65			 
2f65 2a 1e f1			ld hl, (os_tok_ptr) 
2f68					if DEBUG_FORTH_WORDS 
2f68						DMARK "IF3" 
2f68 f5				push af  
2f69 3a 7d 2f			ld a, (.dmark)  
2f6c 32 77 fb			ld (debug_mark),a  
2f6f 3a 7e 2f			ld a, (.dmark+1)  
2f72 32 78 fb			ld (debug_mark+1),a  
2f75 3a 7f 2f			ld a, (.dmark+2)  
2f78 32 79 fb			ld (debug_mark+2),a  
2f7b 18 03			jr .pastdmark  
2f7d ..			.dmark: db "IF3"  
2f80 f1			.pastdmark: pop af  
2f81			endm  
# End of macro DMARK
2f81						CALLMONITOR 
2f81 cd 49 17			call break_point_state  
2f84				endm  
# End of macro CALLMONITOR
2f84						 
2f84					endif 
2f84 11 cb 2f			ld de, .ifthen 
2f87					if DEBUG_FORTH_WORDS 
2f87						DMARK "IF4" 
2f87 f5				push af  
2f88 3a 9c 2f			ld a, (.dmark)  
2f8b 32 77 fb			ld (debug_mark),a  
2f8e 3a 9d 2f			ld a, (.dmark+1)  
2f91 32 78 fb			ld (debug_mark+1),a  
2f94 3a 9e 2f			ld a, (.dmark+2)  
2f97 32 79 fb			ld (debug_mark+2),a  
2f9a 18 03			jr .pastdmark  
2f9c ..			.dmark: db "IF4"  
2f9f f1			.pastdmark: pop af  
2fa0			endm  
# End of macro DMARK
2fa0						CALLMONITOR 
2fa0 cd 49 17			call break_point_state  
2fa3				endm  
# End of macro CALLMONITOR
2fa3					endif 
2fa3 cd 5d 21			call findnexttok  
2fa6			 
2fa6					if DEBUG_FORTH_WORDS 
2fa6						DMARK "IF5" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 77 fb			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 78 fb			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 79 fb			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "IF5"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd 49 17			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2					endif 
2fc2				; TODO replace below with ; exec using tok_ptr 
2fc2 22 1e f1			ld (os_tok_ptr), hl 
2fc5 c3 d3 20			jp exec1 
2fc8				NEXTW 
2fc8 c3 42 20			jp macro_next 
2fcb				endm 
# End of macro NEXTW
2fcb			 
2fcb .. 00		.ifthen:  db "THEN",0 
2fd0			 
2fd0			.iftrue:		 
2fd0				; Exec next words normally 
2fd0			 
2fd0				; if true then exec following IF as normal 
2fd0					if DEBUG_FORTH_WORDS 
2fd0						DMARK "IFT" 
2fd0 f5				push af  
2fd1 3a e5 2f			ld a, (.dmark)  
2fd4 32 77 fb			ld (debug_mark),a  
2fd7 3a e6 2f			ld a, (.dmark+1)  
2fda 32 78 fb			ld (debug_mark+1),a  
2fdd 3a e7 2f			ld a, (.dmark+2)  
2fe0 32 79 fb			ld (debug_mark+2),a  
2fe3 18 03			jr .pastdmark  
2fe5 ..			.dmark: db "IFT"  
2fe8 f1			.pastdmark: pop af  
2fe9			endm  
# End of macro DMARK
2fe9						CALLMONITOR 
2fe9 cd 49 17			call break_point_state  
2fec				endm  
# End of macro CALLMONITOR
2fec					endif 
2fec			 
2fec					NEXTW 
2fec c3 42 20			jp macro_next 
2fef				endm 
# End of macro NEXTW
2fef			.THEN: 
2fef				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fef 1f				db WORD_SYS_CORE+11             
2ff0 17 30			dw .ELSE            
2ff2 05				db 4 + 1 
2ff3 .. 00			db "THEN",0              
2ff8				endm 
# End of macro CWHEAD
2ff8			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2ff8					if DEBUG_FORTH_WORDS_KEY 
2ff8						DMARK "THN" 
2ff8 f5				push af  
2ff9 3a 0d 30			ld a, (.dmark)  
2ffc 32 77 fb			ld (debug_mark),a  
2fff 3a 0e 30			ld a, (.dmark+1)  
3002 32 78 fb			ld (debug_mark+1),a  
3005 3a 0f 30			ld a, (.dmark+2)  
3008 32 79 fb			ld (debug_mark+2),a  
300b 18 03			jr .pastdmark  
300d ..			.dmark: db "THN"  
3010 f1			.pastdmark: pop af  
3011			endm  
# End of macro DMARK
3011						CALLMONITOR 
3011 cd 49 17			call break_point_state  
3014				endm  
# End of macro CALLMONITOR
3014					endif 
3014					NEXTW 
3014 c3 42 20			jp macro_next 
3017				endm 
# End of macro NEXTW
3017			.ELSE: 
3017				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3017 20				db WORD_SYS_CORE+12             
3018 3f 30			dw .DO            
301a 03				db 2 + 1 
301b .. 00			db "ELSE",0              
3020				endm 
# End of macro CWHEAD
3020			; | ELSE ( -- ) Not supported - does nothing | TODO 
3020			 
3020					if DEBUG_FORTH_WORDS_KEY 
3020						DMARK "ELS" 
3020 f5				push af  
3021 3a 35 30			ld a, (.dmark)  
3024 32 77 fb			ld (debug_mark),a  
3027 3a 36 30			ld a, (.dmark+1)  
302a 32 78 fb			ld (debug_mark+1),a  
302d 3a 37 30			ld a, (.dmark+2)  
3030 32 79 fb			ld (debug_mark+2),a  
3033 18 03			jr .pastdmark  
3035 ..			.dmark: db "ELS"  
3038 f1			.pastdmark: pop af  
3039			endm  
# End of macro DMARK
3039						CALLMONITOR 
3039 cd 49 17			call break_point_state  
303c				endm  
# End of macro CALLMONITOR
303c					endif 
303c			 
303c			 
303c					NEXTW 
303c c3 42 20			jp macro_next 
303f				endm 
# End of macro NEXTW
303f			.DO: 
303f				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
303f 21				db WORD_SYS_CORE+13             
3040 66 31			dw .LOOP            
3042 03				db 2 + 1 
3043 .. 00			db "DO",0              
3046				endm 
# End of macro CWHEAD
3046			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3046			 
3046					if DEBUG_FORTH_WORDS_KEY 
3046						DMARK "DO." 
3046 f5				push af  
3047 3a 5b 30			ld a, (.dmark)  
304a 32 77 fb			ld (debug_mark),a  
304d 3a 5c 30			ld a, (.dmark+1)  
3050 32 78 fb			ld (debug_mark+1),a  
3053 3a 5d 30			ld a, (.dmark+2)  
3056 32 79 fb			ld (debug_mark+2),a  
3059 18 03			jr .pastdmark  
305b ..			.dmark: db "DO."  
305e f1			.pastdmark: pop af  
305f			endm  
# End of macro DMARK
305f						CALLMONITOR 
305f cd 49 17			call break_point_state  
3062				endm  
# End of macro CALLMONITOR
3062					endif 
3062			;  push pc to rsp stack past the DO 
3062			 
3062 2a 1e f1				ld hl, (os_tok_ptr) 
3065 23					inc hl   ; D 
3066 23					inc hl  ; O 
3067 23					inc hl   ; null 
3068					if DEBUG_FORTH_WORDS 
3068						DMARK "DO2" 
3068 f5				push af  
3069 3a 7d 30			ld a, (.dmark)  
306c 32 77 fb			ld (debug_mark),a  
306f 3a 7e 30			ld a, (.dmark+1)  
3072 32 78 fb			ld (debug_mark+1),a  
3075 3a 7f 30			ld a, (.dmark+2)  
3078 32 79 fb			ld (debug_mark+2),a  
307b 18 03			jr .pastdmark  
307d ..			.dmark: db "DO2"  
3080 f1			.pastdmark: pop af  
3081			endm  
# End of macro DMARK
3081						CALLMONITOR 
3081 cd 49 17			call break_point_state  
3084				endm  
# End of macro CALLMONITOR
3084					endif 
3084					FORTH_RSP_NEXT 
3084 cd 80 1c			call macro_forth_rsp_next 
3087				endm 
# End of macro FORTH_RSP_NEXT
3087					if DEBUG_FORTH_WORDS 
3087						DMARK "DO3" 
3087 f5				push af  
3088 3a 9c 30			ld a, (.dmark)  
308b 32 77 fb			ld (debug_mark),a  
308e 3a 9d 30			ld a, (.dmark+1)  
3091 32 78 fb			ld (debug_mark+1),a  
3094 3a 9e 30			ld a, (.dmark+2)  
3097 32 79 fb			ld (debug_mark+2),a  
309a 18 03			jr .pastdmark  
309c ..			.dmark: db "DO3"  
309f f1			.pastdmark: pop af  
30a0			endm  
# End of macro DMARK
30a0						CALLMONITOR 
30a0 cd 49 17			call break_point_state  
30a3				endm  
# End of macro CALLMONITOR
30a3					endif 
30a3			 
30a3					;if DEBUG_FORTH_WORDS 
30a3				;		push hl 
30a3			;		endif  
30a3			 
30a3			; get counters from data stack 
30a3			 
30a3			 
30a3					FORTH_DSP_VALUEHL 
30a3 cd d0 1e			call macro_dsp_valuehl 
30a6				endm 
# End of macro FORTH_DSP_VALUEHL
30a6 e5					push hl		 ; hl now has starting counter which needs to be tos 
30a7			 
30a7					if DEBUG_FORTH_WORDS 
30a7						DMARK "DO4" 
30a7 f5				push af  
30a8 3a bc 30			ld a, (.dmark)  
30ab 32 77 fb			ld (debug_mark),a  
30ae 3a bd 30			ld a, (.dmark+1)  
30b1 32 78 fb			ld (debug_mark+1),a  
30b4 3a be 30			ld a, (.dmark+2)  
30b7 32 79 fb			ld (debug_mark+2),a  
30ba 18 03			jr .pastdmark  
30bc ..			.dmark: db "DO4"  
30bf f1			.pastdmark: pop af  
30c0			endm  
# End of macro DMARK
30c0						CALLMONITOR 
30c0 cd 49 17			call break_point_state  
30c3				endm  
# End of macro CALLMONITOR
30c3					endif 
30c3					FORTH_DSP_POP 
30c3 cd 88 1f			call macro_forth_dsp_pop 
30c6				endm 
# End of macro FORTH_DSP_POP
30c6			 
30c6					if DEBUG_FORTH_WORDS 
30c6						DMARK "DO5" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 77 fb			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 78 fb			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 79 fb			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "DO5"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd 49 17			call break_point_state  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2			 
30e2					FORTH_DSP_VALUEHL 
30e2 cd d0 1e			call macro_dsp_valuehl 
30e5				endm 
# End of macro FORTH_DSP_VALUEHL
30e5			;		push hl		 ; hl now has starting limit counter 
30e5			 
30e5					if DEBUG_FORTH_WORDS 
30e5						DMARK "DO6" 
30e5 f5				push af  
30e6 3a fa 30			ld a, (.dmark)  
30e9 32 77 fb			ld (debug_mark),a  
30ec 3a fb 30			ld a, (.dmark+1)  
30ef 32 78 fb			ld (debug_mark+1),a  
30f2 3a fc 30			ld a, (.dmark+2)  
30f5 32 79 fb			ld (debug_mark+2),a  
30f8 18 03			jr .pastdmark  
30fa ..			.dmark: db "DO6"  
30fd f1			.pastdmark: pop af  
30fe			endm  
# End of macro DMARK
30fe						CALLMONITOR 
30fe cd 49 17			call break_point_state  
3101				endm  
# End of macro CALLMONITOR
3101					endif 
3101					FORTH_DSP_POP 
3101 cd 88 1f			call macro_forth_dsp_pop 
3104				endm 
# End of macro FORTH_DSP_POP
3104			 
3104			; put counters on the loop stack 
3104			 
3104			;		pop hl			 ; limit counter 
3104 d1					pop de			; start counter 
3105			 
3105					; push limit counter 
3105			 
3105					if DEBUG_FORTH_WORDS 
3105						DMARK "DO7" 
3105 f5				push af  
3106 3a 1a 31			ld a, (.dmark)  
3109 32 77 fb			ld (debug_mark),a  
310c 3a 1b 31			ld a, (.dmark+1)  
310f 32 78 fb			ld (debug_mark+1),a  
3112 3a 1c 31			ld a, (.dmark+2)  
3115 32 79 fb			ld (debug_mark+2),a  
3118 18 03			jr .pastdmark  
311a ..			.dmark: db "DO7"  
311d f1			.pastdmark: pop af  
311e			endm  
# End of macro DMARK
311e						CALLMONITOR 
311e cd 49 17			call break_point_state  
3121				endm  
# End of macro CALLMONITOR
3121					endif 
3121					FORTH_LOOP_NEXT 
3121 cd 01 1f			call macro_forth_loop_next 
3124				endm 
# End of macro FORTH_LOOP_NEXT
3124			 
3124					; push start counter 
3124			 
3124 eb					ex de, hl 
3125					if DEBUG_FORTH_WORDS 
3125						DMARK "DO7" 
3125 f5				push af  
3126 3a 3a 31			ld a, (.dmark)  
3129 32 77 fb			ld (debug_mark),a  
312c 3a 3b 31			ld a, (.dmark+1)  
312f 32 78 fb			ld (debug_mark+1),a  
3132 3a 3c 31			ld a, (.dmark+2)  
3135 32 79 fb			ld (debug_mark+2),a  
3138 18 03			jr .pastdmark  
313a ..			.dmark: db "DO7"  
313d f1			.pastdmark: pop af  
313e			endm  
# End of macro DMARK
313e						CALLMONITOR 
313e cd 49 17			call break_point_state  
3141				endm  
# End of macro CALLMONITOR
3141					endif 
3141					FORTH_LOOP_NEXT 
3141 cd 01 1f			call macro_forth_loop_next 
3144				endm 
# End of macro FORTH_LOOP_NEXT
3144			 
3144			 
3144					; init first round of I counter 
3144			 
3144 22 42 f1				ld (os_current_i), hl 
3147			 
3147					if DEBUG_FORTH_WORDS 
3147						DMARK "DO8" 
3147 f5				push af  
3148 3a 5c 31			ld a, (.dmark)  
314b 32 77 fb			ld (debug_mark),a  
314e 3a 5d 31			ld a, (.dmark+1)  
3151 32 78 fb			ld (debug_mark+1),a  
3154 3a 5e 31			ld a, (.dmark+2)  
3157 32 79 fb			ld (debug_mark+2),a  
315a 18 03			jr .pastdmark  
315c ..			.dmark: db "DO8"  
315f f1			.pastdmark: pop af  
3160			endm  
# End of macro DMARK
3160						CALLMONITOR 
3160 cd 49 17			call break_point_state  
3163				endm  
# End of macro CALLMONITOR
3163					endif 
3163			 
3163					NEXTW 
3163 c3 42 20			jp macro_next 
3166				endm 
# End of macro NEXTW
3166			.LOOP: 
3166				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3166 22				db WORD_SYS_CORE+14             
3167 7e 32			dw .I            
3169 05				db 4 + 1 
316a .. 00			db "LOOP",0              
316f				endm 
# End of macro CWHEAD
316f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
316f			 
316f				; pop tos as current loop count to hl 
316f			 
316f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
316f			 
316f				FORTH_LOOP_TOS 
316f cd 34 1f			call macro_forth_loop_tos 
3172				endm 
# End of macro FORTH_LOOP_TOS
3172 e5				push hl 
3173			 
3173					if DEBUG_FORTH_WORDS_KEY 
3173						DMARK "LOP" 
3173 f5				push af  
3174 3a 88 31			ld a, (.dmark)  
3177 32 77 fb			ld (debug_mark),a  
317a 3a 89 31			ld a, (.dmark+1)  
317d 32 78 fb			ld (debug_mark+1),a  
3180 3a 8a 31			ld a, (.dmark+2)  
3183 32 79 fb			ld (debug_mark+2),a  
3186 18 03			jr .pastdmark  
3188 ..			.dmark: db "LOP"  
318b f1			.pastdmark: pop af  
318c			endm  
# End of macro DMARK
318c						CALLMONITOR 
318c cd 49 17			call break_point_state  
318f				endm  
# End of macro CALLMONITOR
318f					endif 
318f				; next item on the stack is the limit. get it 
318f			 
318f			 
318f				FORTH_LOOP_POP 
318f cd 3e 1f			call macro_forth_loop_pop 
3192				endm 
# End of macro FORTH_LOOP_POP
3192			 
3192				FORTH_LOOP_TOS 
3192 cd 34 1f			call macro_forth_loop_tos 
3195				endm 
# End of macro FORTH_LOOP_TOS
3195			 
3195 d1				pop de		 ; de = i, hl = limit 
3196			 
3196					if DEBUG_FORTH_WORDS 
3196						DMARK "LP1" 
3196 f5				push af  
3197 3a ab 31			ld a, (.dmark)  
319a 32 77 fb			ld (debug_mark),a  
319d 3a ac 31			ld a, (.dmark+1)  
31a0 32 78 fb			ld (debug_mark+1),a  
31a3 3a ad 31			ld a, (.dmark+2)  
31a6 32 79 fb			ld (debug_mark+2),a  
31a9 18 03			jr .pastdmark  
31ab ..			.dmark: db "LP1"  
31ae f1			.pastdmark: pop af  
31af			endm  
# End of macro DMARK
31af						CALLMONITOR 
31af cd 49 17			call break_point_state  
31b2				endm  
# End of macro CALLMONITOR
31b2					endif 
31b2			 
31b2				; go back to previous word 
31b2			 
31b2 d5				push de    ; save I for inc later 
31b3			 
31b3			 
31b3				; get limit 
31b3				;  is I at limit? 
31b3			 
31b3			 
31b3					if DEBUG_FORTH_WORDS 
31b3						DMARK "LP1" 
31b3 f5				push af  
31b4 3a c8 31			ld a, (.dmark)  
31b7 32 77 fb			ld (debug_mark),a  
31ba 3a c9 31			ld a, (.dmark+1)  
31bd 32 78 fb			ld (debug_mark+1),a  
31c0 3a ca 31			ld a, (.dmark+2)  
31c3 32 79 fb			ld (debug_mark+2),a  
31c6 18 03			jr .pastdmark  
31c8 ..			.dmark: db "LP1"  
31cb f1			.pastdmark: pop af  
31cc			endm  
# End of macro DMARK
31cc						CALLMONITOR 
31cc cd 49 17			call break_point_state  
31cf				endm  
# End of macro CALLMONITOR
31cf					endif 
31cf			 
31cf ed 52			sbc hl, de 
31d1			 
31d1			 
31d1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
31d1			 
31d1 20 26				jr nz, .loopnotdone 
31d3			 
31d3 e1				pop hl   ; get rid of saved I 
31d4				FORTH_LOOP_POP     ; get rid of limit 
31d4 cd 3e 1f			call macro_forth_loop_pop 
31d7				endm 
# End of macro FORTH_LOOP_POP
31d7			 
31d7				FORTH_RSP_POP     ; get rid of DO ptr 
31d7 cd a1 1c			call macro_forth_rsp_pop 
31da				endm 
# End of macro FORTH_RSP_POP
31da			 
31da			if DEBUG_FORTH_WORDS 
31da						DMARK "LP>" 
31da f5				push af  
31db 3a ef 31			ld a, (.dmark)  
31de 32 77 fb			ld (debug_mark),a  
31e1 3a f0 31			ld a, (.dmark+1)  
31e4 32 78 fb			ld (debug_mark+1),a  
31e7 3a f1 31			ld a, (.dmark+2)  
31ea 32 79 fb			ld (debug_mark+2),a  
31ed 18 03			jr .pastdmark  
31ef ..			.dmark: db "LP>"  
31f2 f1			.pastdmark: pop af  
31f3			endm  
# End of macro DMARK
31f3				CALLMONITOR 
31f3 cd 49 17			call break_point_state  
31f6				endm  
# End of macro CALLMONITOR
31f6			endif 
31f6			 
31f6					NEXTW 
31f6 c3 42 20			jp macro_next 
31f9				endm 
# End of macro NEXTW
31f9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31f9			 
31f9			.loopnotdone: 
31f9			 
31f9 e1				pop hl    ; get I 
31fa 23				inc hl 
31fb			 
31fb			   	; save new I 
31fb			 
31fb			 
31fb					; set I counter 
31fb			 
31fb 22 42 f1				ld (os_current_i), hl 
31fe			 
31fe					if DEBUG_FORTH_WORDS 
31fe						DMARK "LPN" 
31fe f5				push af  
31ff 3a 13 32			ld a, (.dmark)  
3202 32 77 fb			ld (debug_mark),a  
3205 3a 14 32			ld a, (.dmark+1)  
3208 32 78 fb			ld (debug_mark+1),a  
320b 3a 15 32			ld a, (.dmark+2)  
320e 32 79 fb			ld (debug_mark+2),a  
3211 18 03			jr .pastdmark  
3213 ..			.dmark: db "LPN"  
3216 f1			.pastdmark: pop af  
3217			endm  
# End of macro DMARK
3217					CALLMONITOR 
3217 cd 49 17			call break_point_state  
321a				endm  
# End of macro CALLMONITOR
321a					endif 
321a					 
321a				FORTH_LOOP_NEXT 
321a cd 01 1f			call macro_forth_loop_next 
321d				endm 
# End of macro FORTH_LOOP_NEXT
321d			 
321d			 
321d					if DEBUG_FORTH_WORDS 
321d eb						ex de,hl 
321e					endif 
321e			 
321e			;	; get DO ptr 
321e			; 
321e					if DEBUG_FORTH_WORDS 
321e						DMARK "LP7" 
321e f5				push af  
321f 3a 33 32			ld a, (.dmark)  
3222 32 77 fb			ld (debug_mark),a  
3225 3a 34 32			ld a, (.dmark+1)  
3228 32 78 fb			ld (debug_mark+1),a  
322b 3a 35 32			ld a, (.dmark+2)  
322e 32 79 fb			ld (debug_mark+2),a  
3231 18 03			jr .pastdmark  
3233 ..			.dmark: db "LP7"  
3236 f1			.pastdmark: pop af  
3237			endm  
# End of macro DMARK
3237					CALLMONITOR 
3237 cd 49 17			call break_point_state  
323a				endm  
# End of macro CALLMONITOR
323a					endif 
323a				FORTH_RSP_TOS 
323a cd 97 1c			call macro_forth_rsp_tos 
323d				endm 
# End of macro FORTH_RSP_TOS
323d			 
323d					if DEBUG_FORTH_WORDS 
323d						DMARK "LP8" 
323d f5				push af  
323e 3a 52 32			ld a, (.dmark)  
3241 32 77 fb			ld (debug_mark),a  
3244 3a 53 32			ld a, (.dmark+1)  
3247 32 78 fb			ld (debug_mark+1),a  
324a 3a 54 32			ld a, (.dmark+2)  
324d 32 79 fb			ld (debug_mark+2),a  
3250 18 03			jr .pastdmark  
3252 ..			.dmark: db "LP8"  
3255 f1			.pastdmark: pop af  
3256			endm  
# End of macro DMARK
3256					CALLMONITOR 
3256 cd 49 17			call break_point_state  
3259				endm  
# End of macro CALLMONITOR
3259					endif 
3259				;push hl 
3259			 
3259				; not going to DO any more 
3259				; get rid of the RSP pointer as DO will add it back in 
3259				;FORTH_RSP_POP 
3259				;pop hl 
3259			 
3259				;ld hl,(cli_ret_sp) 
3259				;ld e, (hl) 
3259				;inc hl 
3259				;ld d, (hl) 
3259				;ex de,hl 
3259 22 1e f1			ld (os_tok_ptr), hl 
325c					if DEBUG_FORTH_WORDS 
325c						DMARK "LP<" 
325c f5				push af  
325d 3a 71 32			ld a, (.dmark)  
3260 32 77 fb			ld (debug_mark),a  
3263 3a 72 32			ld a, (.dmark+1)  
3266 32 78 fb			ld (debug_mark+1),a  
3269 3a 73 32			ld a, (.dmark+2)  
326c 32 79 fb			ld (debug_mark+2),a  
326f 18 03			jr .pastdmark  
3271 ..			.dmark: db "LP<"  
3274 f1			.pastdmark: pop af  
3275			endm  
# End of macro DMARK
3275					CALLMONITOR 
3275 cd 49 17			call break_point_state  
3278				endm  
# End of macro CALLMONITOR
3278				endif 
3278 c3 d3 20			jp exec1 
327b			 
327b					 
327b			 
327b			 
327b					NEXTW 
327b c3 42 20			jp macro_next 
327e				endm 
# End of macro NEXTW
327e			.I:  
327e			 
327e				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
327e 5e				db WORD_SYS_CORE+74             
327f a9 32			dw .DLOOP            
3281 02				db 1 + 1 
3282 .. 00			db "I",0              
3284				endm 
# End of macro CWHEAD
3284			; | I ( -- ) Current loop counter | DONE 
3284					if DEBUG_FORTH_WORDS_KEY 
3284						DMARK "I.." 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 77 fb			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 78 fb			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 79 fb			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "I.."  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd 49 17			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0			 
32a0 2a 42 f1				ld hl,(os_current_i) 
32a3 cd d9 1c				call forth_push_numhl 
32a6			 
32a6					NEXTW 
32a6 c3 42 20			jp macro_next 
32a9				endm 
# End of macro NEXTW
32a9			.DLOOP: 
32a9				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32a9 5f				db WORD_SYS_CORE+75             
32aa 8a 33			dw .REPEAT            
32ac 06				db 5 + 1 
32ad .. 00			db "-LOOP",0              
32b3				endm 
# End of macro CWHEAD
32b3			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32b3				; pop tos as current loop count to hl 
32b3					if DEBUG_FORTH_WORDS_KEY 
32b3						DMARK "-LP" 
32b3 f5				push af  
32b4 3a c8 32			ld a, (.dmark)  
32b7 32 77 fb			ld (debug_mark),a  
32ba 3a c9 32			ld a, (.dmark+1)  
32bd 32 78 fb			ld (debug_mark+1),a  
32c0 3a ca 32			ld a, (.dmark+2)  
32c3 32 79 fb			ld (debug_mark+2),a  
32c6 18 03			jr .pastdmark  
32c8 ..			.dmark: db "-LP"  
32cb f1			.pastdmark: pop af  
32cc			endm  
# End of macro DMARK
32cc						CALLMONITOR 
32cc cd 49 17			call break_point_state  
32cf				endm  
# End of macro CALLMONITOR
32cf					endif 
32cf			 
32cf				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
32cf			 
32cf				FORTH_LOOP_TOS 
32cf cd 34 1f			call macro_forth_loop_tos 
32d2				endm 
# End of macro FORTH_LOOP_TOS
32d2 e5				push hl 
32d3			 
32d3					if DEBUG_FORTH_WORDS 
32d3						DMARK "-LP" 
32d3 f5				push af  
32d4 3a e8 32			ld a, (.dmark)  
32d7 32 77 fb			ld (debug_mark),a  
32da 3a e9 32			ld a, (.dmark+1)  
32dd 32 78 fb			ld (debug_mark+1),a  
32e0 3a ea 32			ld a, (.dmark+2)  
32e3 32 79 fb			ld (debug_mark+2),a  
32e6 18 03			jr .pastdmark  
32e8 ..			.dmark: db "-LP"  
32eb f1			.pastdmark: pop af  
32ec			endm  
# End of macro DMARK
32ec						CALLMONITOR 
32ec cd 49 17			call break_point_state  
32ef				endm  
# End of macro CALLMONITOR
32ef					endif 
32ef				; next item on the stack is the limit. get it 
32ef			 
32ef			 
32ef				FORTH_LOOP_POP 
32ef cd 3e 1f			call macro_forth_loop_pop 
32f2				endm 
# End of macro FORTH_LOOP_POP
32f2			 
32f2				FORTH_LOOP_TOS 
32f2 cd 34 1f			call macro_forth_loop_tos 
32f5				endm 
# End of macro FORTH_LOOP_TOS
32f5			 
32f5 d1				pop de		 ; de = i, hl = limit 
32f6			 
32f6					if DEBUG_FORTH_WORDS 
32f6						DMARK "-L1" 
32f6 f5				push af  
32f7 3a 0b 33			ld a, (.dmark)  
32fa 32 77 fb			ld (debug_mark),a  
32fd 3a 0c 33			ld a, (.dmark+1)  
3300 32 78 fb			ld (debug_mark+1),a  
3303 3a 0d 33			ld a, (.dmark+2)  
3306 32 79 fb			ld (debug_mark+2),a  
3309 18 03			jr .pastdmark  
330b ..			.dmark: db "-L1"  
330e f1			.pastdmark: pop af  
330f			endm  
# End of macro DMARK
330f						CALLMONITOR 
330f cd 49 17			call break_point_state  
3312				endm  
# End of macro CALLMONITOR
3312					endif 
3312			 
3312				; go back to previous word 
3312			 
3312 d5				push de    ; save I for inc later 
3313			 
3313			 
3313				; get limit 
3313				;  is I at limit? 
3313			 
3313			 
3313					if DEBUG_FORTH_WORDS 
3313						DMARK "-L1" 
3313 f5				push af  
3314 3a 28 33			ld a, (.dmark)  
3317 32 77 fb			ld (debug_mark),a  
331a 3a 29 33			ld a, (.dmark+1)  
331d 32 78 fb			ld (debug_mark+1),a  
3320 3a 2a 33			ld a, (.dmark+2)  
3323 32 79 fb			ld (debug_mark+2),a  
3326 18 03			jr .pastdmark  
3328 ..			.dmark: db "-L1"  
332b f1			.pastdmark: pop af  
332c			endm  
# End of macro DMARK
332c						CALLMONITOR 
332c cd 49 17			call break_point_state  
332f				endm  
# End of macro CALLMONITOR
332f					endif 
332f			 
332f ed 52			sbc hl, de 
3331			 
3331			 
3331				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3331			 
3331 20 26				jr nz, .mloopnotdone 
3333			 
3333 e1				pop hl   ; get rid of saved I 
3334				FORTH_LOOP_POP     ; get rid of limit 
3334 cd 3e 1f			call macro_forth_loop_pop 
3337				endm 
# End of macro FORTH_LOOP_POP
3337			 
3337				FORTH_RSP_POP     ; get rid of DO ptr 
3337 cd a1 1c			call macro_forth_rsp_pop 
333a				endm 
# End of macro FORTH_RSP_POP
333a			 
333a			if DEBUG_FORTH_WORDS 
333a						DMARK "-L>" 
333a f5				push af  
333b 3a 4f 33			ld a, (.dmark)  
333e 32 77 fb			ld (debug_mark),a  
3341 3a 50 33			ld a, (.dmark+1)  
3344 32 78 fb			ld (debug_mark+1),a  
3347 3a 51 33			ld a, (.dmark+2)  
334a 32 79 fb			ld (debug_mark+2),a  
334d 18 03			jr .pastdmark  
334f ..			.dmark: db "-L>"  
3352 f1			.pastdmark: pop af  
3353			endm  
# End of macro DMARK
3353				CALLMONITOR 
3353 cd 49 17			call break_point_state  
3356				endm  
# End of macro CALLMONITOR
3356			endif 
3356			 
3356					NEXTW 
3356 c3 42 20			jp macro_next 
3359				endm 
# End of macro NEXTW
3359				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3359			 
3359			.mloopnotdone: 
3359			 
3359 e1				pop hl    ; get I 
335a 2b				dec hl 
335b			 
335b			   	; save new I 
335b			 
335b			 
335b					; set I counter 
335b			 
335b 22 42 f1				ld (os_current_i), hl 
335e			 
335e					 
335e				FORTH_LOOP_NEXT 
335e cd 01 1f			call macro_forth_loop_next 
3361				endm 
# End of macro FORTH_LOOP_NEXT
3361			 
3361			 
3361					if DEBUG_FORTH_WORDS 
3361 eb						ex de,hl 
3362					endif 
3362			 
3362			;	; get DO ptr 
3362			; 
3362				FORTH_RSP_TOS 
3362 cd 97 1c			call macro_forth_rsp_tos 
3365				endm 
# End of macro FORTH_RSP_TOS
3365			 
3365				;push hl 
3365			 
3365				; not going to DO any more 
3365				; get rid of the RSP pointer as DO will add it back in 
3365				;FORTH_RSP_POP 
3365				;pop hl 
3365			 
3365			 
3365 22 1e f1			ld (os_tok_ptr), hl 
3368					if DEBUG_FORTH_WORDS 
3368						DMARK "-L<" 
3368 f5				push af  
3369 3a 7d 33			ld a, (.dmark)  
336c 32 77 fb			ld (debug_mark),a  
336f 3a 7e 33			ld a, (.dmark+1)  
3372 32 78 fb			ld (debug_mark+1),a  
3375 3a 7f 33			ld a, (.dmark+2)  
3378 32 79 fb			ld (debug_mark+2),a  
337b 18 03			jr .pastdmark  
337d ..			.dmark: db "-L<"  
3380 f1			.pastdmark: pop af  
3381			endm  
# End of macro DMARK
3381					CALLMONITOR 
3381 cd 49 17			call break_point_state  
3384				endm  
# End of macro CALLMONITOR
3384				endif 
3384 c3 d3 20			jp exec1 
3387			 
3387					 
3387			 
3387			 
3387			 
3387				NEXTW 
3387 c3 42 20			jp macro_next 
338a				endm 
# End of macro NEXTW
338a			 
338a			 
338a			 
338a			 
338a			.REPEAT: 
338a				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
338a 71				db WORD_SYS_CORE+93             
338b dd 33			dw .UNTIL            
338d 06				db 5 + 1 
338e .. 00			db "REPEAT",0              
3395				endm 
# End of macro CWHEAD
3395			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3395			;  push pc to rsp stack past the REPEAT 
3395					if DEBUG_FORTH_WORDS_KEY 
3395						DMARK "REP" 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 77 fb			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 78 fb			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 79 fb			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "REP"  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae						CALLMONITOR 
33ae cd 49 17			call break_point_state  
33b1				endm  
# End of macro CALLMONITOR
33b1					endif 
33b1			 
33b1 2a 1e f1				ld hl, (os_tok_ptr) 
33b4 23					inc hl   ; R 
33b5 23					inc hl  ; E 
33b6 23					inc hl   ; P 
33b7 23					inc hl   ; E 
33b8 23					inc hl   ; A 
33b9 23					inc hl   ; T 
33ba 23					inc hl   ; zero 
33bb					FORTH_RSP_NEXT 
33bb cd 80 1c			call macro_forth_rsp_next 
33be				endm 
# End of macro FORTH_RSP_NEXT
33be			 
33be			 
33be					if DEBUG_FORTH_WORDS 
33be						DMARK "REP" 
33be f5				push af  
33bf 3a d3 33			ld a, (.dmark)  
33c2 32 77 fb			ld (debug_mark),a  
33c5 3a d4 33			ld a, (.dmark+1)  
33c8 32 78 fb			ld (debug_mark+1),a  
33cb 3a d5 33			ld a, (.dmark+2)  
33ce 32 79 fb			ld (debug_mark+2),a  
33d1 18 03			jr .pastdmark  
33d3 ..			.dmark: db "REP"  
33d6 f1			.pastdmark: pop af  
33d7			endm  
# End of macro DMARK
33d7						;pop bc    ; TODO BUG ?????? what is this for???? 
33d7						CALLMONITOR 
33d7 cd 49 17			call break_point_state  
33da				endm  
# End of macro CALLMONITOR
33da					endif 
33da			 
33da					NEXTW 
33da c3 42 20			jp macro_next 
33dd				endm 
# End of macro NEXTW
33dd			;	       NEXTW 
33dd			 
33dd			.UNTIL: 
33dd				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
33dd 72				db WORD_SYS_CORE+94             
33de 74 34			dw .ENDFLOW            
33e0 06				db 5 + 1 
33e1 .. 00			db "UNTIL",0              
33e7				endm 
# End of macro CWHEAD
33e7			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33e7			 
33e7				; pop tos as check 
33e7			 
33e7				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33e7			 
33e7				FORTH_DSP_VALUEHL 
33e7 cd d0 1e			call macro_dsp_valuehl 
33ea				endm 
# End of macro FORTH_DSP_VALUEHL
33ea			 
33ea					if DEBUG_FORTH_WORDS_KEY 
33ea						DMARK "UNT" 
33ea f5				push af  
33eb 3a ff 33			ld a, (.dmark)  
33ee 32 77 fb			ld (debug_mark),a  
33f1 3a 00 34			ld a, (.dmark+1)  
33f4 32 78 fb			ld (debug_mark+1),a  
33f7 3a 01 34			ld a, (.dmark+2)  
33fa 32 79 fb			ld (debug_mark+2),a  
33fd 18 03			jr .pastdmark  
33ff ..			.dmark: db "UNT"  
3402 f1			.pastdmark: pop af  
3403			endm  
# End of macro DMARK
3403						CALLMONITOR 
3403 cd 49 17			call break_point_state  
3406				endm  
# End of macro CALLMONITOR
3406					endif 
3406			 
3406			;	push hl 
3406				FORTH_DSP_POP 
3406 cd 88 1f			call macro_forth_dsp_pop 
3409				endm 
# End of macro FORTH_DSP_POP
3409			 
3409			;	pop hl 
3409			 
3409				; test if true 
3409			 
3409 cd 35 0d			call ishlzero 
340c			;	ld a,l 
340c			;	add h 
340c			; 
340c			;	cp 0 
340c			 
340c 20 3e			jr nz, .untilnotdone 
340e			 
340e					if DEBUG_FORTH_WORDS 
340e						DMARK "UNf" 
340e f5				push af  
340f 3a 23 34			ld a, (.dmark)  
3412 32 77 fb			ld (debug_mark),a  
3415 3a 24 34			ld a, (.dmark+1)  
3418 32 78 fb			ld (debug_mark+1),a  
341b 3a 25 34			ld a, (.dmark+2)  
341e 32 79 fb			ld (debug_mark+2),a  
3421 18 03			jr .pastdmark  
3423 ..			.dmark: db "UNf"  
3426 f1			.pastdmark: pop af  
3427			endm  
# End of macro DMARK
3427						CALLMONITOR 
3427 cd 49 17			call break_point_state  
342a				endm  
# End of macro CALLMONITOR
342a					endif 
342a			 
342a			 
342a			 
342a				FORTH_RSP_POP     ; get rid of DO ptr 
342a cd a1 1c			call macro_forth_rsp_pop 
342d				endm 
# End of macro FORTH_RSP_POP
342d			 
342d			if DEBUG_FORTH_WORDS 
342d						DMARK "UN>" 
342d f5				push af  
342e 3a 42 34			ld a, (.dmark)  
3431 32 77 fb			ld (debug_mark),a  
3434 3a 43 34			ld a, (.dmark+1)  
3437 32 78 fb			ld (debug_mark+1),a  
343a 3a 44 34			ld a, (.dmark+2)  
343d 32 79 fb			ld (debug_mark+2),a  
3440 18 03			jr .pastdmark  
3442 ..			.dmark: db "UN>"  
3445 f1			.pastdmark: pop af  
3446			endm  
# End of macro DMARK
3446				CALLMONITOR 
3446 cd 49 17			call break_point_state  
3449				endm  
# End of macro CALLMONITOR
3449			endif 
3449			 
3449					NEXTW 
3449 c3 42 20			jp macro_next 
344c				endm 
# End of macro NEXTW
344c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
344c			 
344c			.untilnotdone: 
344c			 
344c			 
344c			;	; get DO ptr 
344c			; 
344c				FORTH_RSP_TOS 
344c cd 97 1c			call macro_forth_rsp_tos 
344f				endm 
# End of macro FORTH_RSP_TOS
344f			 
344f				;push hl 
344f			 
344f				; not going to DO any more 
344f				; get rid of the RSP pointer as DO will add it back in 
344f				;FORTH_RSP_POP 
344f				;pop hl 
344f			 
344f			 
344f 22 1e f1			ld (os_tok_ptr), hl 
3452					if DEBUG_FORTH_WORDS 
3452						DMARK "UN<" 
3452 f5				push af  
3453 3a 67 34			ld a, (.dmark)  
3456 32 77 fb			ld (debug_mark),a  
3459 3a 68 34			ld a, (.dmark+1)  
345c 32 78 fb			ld (debug_mark+1),a  
345f 3a 69 34			ld a, (.dmark+2)  
3462 32 79 fb			ld (debug_mark+2),a  
3465 18 03			jr .pastdmark  
3467 ..			.dmark: db "UN<"  
346a f1			.pastdmark: pop af  
346b			endm  
# End of macro DMARK
346b					CALLMONITOR 
346b cd 49 17			call break_point_state  
346e				endm  
# End of macro CALLMONITOR
346e				endif 
346e c3 d3 20			jp exec1 
3471			 
3471					 
3471			 
3471			 
3471					NEXTW 
3471 c3 42 20			jp macro_next 
3474				endm 
# End of macro NEXTW
3474			 
3474			 
3474			.ENDFLOW: 
3474			 
3474			; eof 
3474			 
# End of file forth_words_flow.asm
3474			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3474			include "forth_words_logic.asm" 
3474			 
3474			; | ## Logic Words 
3474			 
3474			.NOT: 
3474				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3474 2d				db WORD_SYS_CORE+25             
3475 bc 34			dw .IS            
3477 04				db 3 + 1 
3478 .. 00			db "NOT",0              
347c				endm 
# End of macro CWHEAD
347c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
347c					if DEBUG_FORTH_WORDS_KEY 
347c						DMARK "NOT" 
347c f5				push af  
347d 3a 91 34			ld a, (.dmark)  
3480 32 77 fb			ld (debug_mark),a  
3483 3a 92 34			ld a, (.dmark+1)  
3486 32 78 fb			ld (debug_mark+1),a  
3489 3a 93 34			ld a, (.dmark+2)  
348c 32 79 fb			ld (debug_mark+2),a  
348f 18 03			jr .pastdmark  
3491 ..			.dmark: db "NOT"  
3494 f1			.pastdmark: pop af  
3495			endm  
# End of macro DMARK
3495						CALLMONITOR 
3495 cd 49 17			call break_point_state  
3498				endm  
# End of macro CALLMONITOR
3498					endif 
3498					FORTH_DSP 
3498 cd 96 1e			call macro_forth_dsp 
349b				endm 
# End of macro FORTH_DSP
349b 7e					ld a,(hl)	; get type of value on TOS 
349c fe 02				cp DS_TYPE_INUM  
349e 28 03				jr z, .noti 
34a0					NEXTW 
34a0 c3 42 20			jp macro_next 
34a3				endm 
# End of macro NEXTW
34a3			.noti:          FORTH_DSP_VALUEHL 
34a3 cd d0 1e			call macro_dsp_valuehl 
34a6				endm 
# End of macro FORTH_DSP_VALUEHL
34a6			;		push hl 
34a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34a6 cd 88 1f			call macro_forth_dsp_pop 
34a9				endm 
# End of macro FORTH_DSP_POP
34a9			;		pop hl 
34a9 3e 00				ld a,0 
34ab bd					cp l 
34ac 28 04				jr z, .not2t 
34ae 2e 00				ld l, 0 
34b0 18 02				jr .notip 
34b2			 
34b2 2e ff		.not2t:		ld l, 255 
34b4			 
34b4 26 00		.notip:		ld h, 0	 
34b6			 
34b6 cd d9 1c				call forth_push_numhl 
34b9					NEXTW 
34b9 c3 42 20			jp macro_next 
34bc				endm 
# End of macro NEXTW
34bc			 
34bc			.IS: 
34bc				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34bc 2d				db WORD_SYS_CORE+25             
34bd e2 34			dw .LZERO            
34bf 03				db 2 + 1 
34c0 .. 00			db "IS",0              
34c3				endm 
# End of macro CWHEAD
34c3			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34c3					if DEBUG_FORTH_WORDS_KEY 
34c3						DMARK "IS." 
34c3 f5				push af  
34c4 3a d8 34			ld a, (.dmark)  
34c7 32 77 fb			ld (debug_mark),a  
34ca 3a d9 34			ld a, (.dmark+1)  
34cd 32 78 fb			ld (debug_mark+1),a  
34d0 3a da 34			ld a, (.dmark+2)  
34d3 32 79 fb			ld (debug_mark+2),a  
34d6 18 03			jr .pastdmark  
34d8 ..			.dmark: db "IS."  
34db f1			.pastdmark: pop af  
34dc			endm  
# End of macro DMARK
34dc						CALLMONITOR 
34dc cd 49 17			call break_point_state  
34df				endm  
# End of macro CALLMONITOR
34df					endif 
34df					NEXTW 
34df c3 42 20			jp macro_next 
34e2				endm 
# End of macro NEXTW
34e2			.LZERO: 
34e2				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
34e2 2d				db WORD_SYS_CORE+25             
34e3 ec 34			dw .TZERO            
34e5 03				db 2 + 1 
34e6 .. 00			db "0<",0              
34e9				endm 
# End of macro CWHEAD
34e9			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34e9					NEXTW 
34e9 c3 42 20			jp macro_next 
34ec				endm 
# End of macro NEXTW
34ec			.TZERO: 
34ec				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34ec 2e				db WORD_SYS_CORE+26             
34ed 33 35			dw .LESS            
34ef 03				db 2 + 1 
34f0 .. 00			db "0=",0              
34f3				endm 
# End of macro CWHEAD
34f3			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
34f3				; TODO add floating point number detection 
34f3					;v5 FORTH_DSP_VALUE 
34f3					if DEBUG_FORTH_WORDS_KEY 
34f3						DMARK "0=." 
34f3 f5				push af  
34f4 3a 08 35			ld a, (.dmark)  
34f7 32 77 fb			ld (debug_mark),a  
34fa 3a 09 35			ld a, (.dmark+1)  
34fd 32 78 fb			ld (debug_mark+1),a  
3500 3a 0a 35			ld a, (.dmark+2)  
3503 32 79 fb			ld (debug_mark+2),a  
3506 18 03			jr .pastdmark  
3508 ..			.dmark: db "0=."  
350b f1			.pastdmark: pop af  
350c			endm  
# End of macro DMARK
350c						CALLMONITOR 
350c cd 49 17			call break_point_state  
350f				endm  
# End of macro CALLMONITOR
350f					endif 
350f					FORTH_DSP 
350f cd 96 1e			call macro_forth_dsp 
3512				endm 
# End of macro FORTH_DSP
3512 7e					ld a,(hl)	; get type of value on TOS 
3513 fe 02				cp DS_TYPE_INUM  
3515 28 00				jr z, .tz_inum 
3517			 
3517				if FORTH_ENABLE_FLOATMATH 
3517					jr .tz_done 
3517			 
3517				endif 
3517					 
3517			 
3517			.tz_inum: 
3517					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3517 cd d0 1e			call macro_dsp_valuehl 
351a				endm 
# End of macro FORTH_DSP_VALUEHL
351a			 
351a			;		push hl 
351a			 
351a					; destroy value TOS 
351a			 
351a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
351a cd 88 1f			call macro_forth_dsp_pop 
351d				endm 
# End of macro FORTH_DSP_POP
351d			 
351d			;		pop hl 
351d			 
351d 3e 00				ld a,0 
351f			 
351f bd					cp l 
3520 20 08				jr nz, .tz_notzero 
3522			 
3522 bc					cp h 
3523			 
3523 20 05				jr nz, .tz_notzero 
3525			 
3525			 
3525 21 01 00				ld hl, FORTH_TRUE 
3528 18 03				jr .tz_done 
352a			 
352a 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
352d			 
352d					; push value back onto stack for another op etc 
352d			 
352d			.tz_done: 
352d cd d9 1c				call forth_push_numhl 
3530			 
3530					NEXTW 
3530 c3 42 20			jp macro_next 
3533				endm 
# End of macro NEXTW
3533			.LESS: 
3533				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3533 2f				db WORD_SYS_CORE+27             
3534 9c 35			dw .GT            
3536 02				db 1 + 1 
3537 .. 00			db "<",0              
3539				endm 
# End of macro CWHEAD
3539			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3539				; TODO add floating point number detection 
3539					if DEBUG_FORTH_WORDS_KEY 
3539						DMARK "LES" 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 77 fb			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 78 fb			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 79 fb			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "LES"  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552						CALLMONITOR 
3552 cd 49 17			call break_point_state  
3555				endm  
# End of macro CALLMONITOR
3555					endif 
3555					FORTH_DSP 
3555 cd 96 1e			call macro_forth_dsp 
3558				endm 
# End of macro FORTH_DSP
3558					;v5 FORTH_DSP_VALUE 
3558 7e					ld a,(hl)	; get type of value on TOS 
3559 fe 02				cp DS_TYPE_INUM  
355b 28 00				jr z, .less_inum 
355d			 
355d				if FORTH_ENABLE_FLOATMATH 
355d					jr .less_done 
355d			 
355d				endif 
355d					 
355d			 
355d			.less_inum: 
355d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
355d cd d0 1e			call macro_dsp_valuehl 
3560				endm 
# End of macro FORTH_DSP_VALUEHL
3560			 
3560 e5					push hl  ; u2 
3561			 
3561					; destroy value TOS 
3561			 
3561					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3561 cd 88 1f			call macro_forth_dsp_pop 
3564				endm 
# End of macro FORTH_DSP_POP
3564			 
3564			 
3564					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3564 cd d0 1e			call macro_dsp_valuehl 
3567				endm 
# End of macro FORTH_DSP_VALUEHL
3567			 
3567 e5					push hl    ; u1 
3568			 
3568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3568 cd 88 1f			call macro_forth_dsp_pop 
356b				endm 
# End of macro FORTH_DSP_POP
356b			 
356b			 
356b b7			 or a      ;clear carry flag 
356c 01 00 00		 ld bc, FORTH_FALSE 
356f e1			  pop hl    ; u1 
3570 d1			  pop de    ; u2 
3571 ed 52		  sbc hl,de 
3573 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3575			 
3575 01 01 00		 ld bc, FORTH_TRUE 
3578			.lscont:  
3578 c5					push bc 
3579 e1					pop hl 
357a			 
357a					if DEBUG_FORTH_WORDS 
357a						DMARK "LT1" 
357a f5				push af  
357b 3a 8f 35			ld a, (.dmark)  
357e 32 77 fb			ld (debug_mark),a  
3581 3a 90 35			ld a, (.dmark+1)  
3584 32 78 fb			ld (debug_mark+1),a  
3587 3a 91 35			ld a, (.dmark+2)  
358a 32 79 fb			ld (debug_mark+2),a  
358d 18 03			jr .pastdmark  
358f ..			.dmark: db "LT1"  
3592 f1			.pastdmark: pop af  
3593			endm  
# End of macro DMARK
3593						CALLMONITOR 
3593 cd 49 17			call break_point_state  
3596				endm  
# End of macro CALLMONITOR
3596					endif 
3596 cd d9 1c				call forth_push_numhl 
3599			 
3599					NEXTW 
3599 c3 42 20			jp macro_next 
359c				endm 
# End of macro NEXTW
359c			.GT: 
359c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
359c 30				db WORD_SYS_CORE+28             
359d 05 36			dw .EQUAL            
359f 02				db 1 + 1 
35a0 .. 00			db ">",0              
35a2				endm 
# End of macro CWHEAD
35a2			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35a2				; TODO add floating point number detection 
35a2					if DEBUG_FORTH_WORDS_KEY 
35a2						DMARK "GRT" 
35a2 f5				push af  
35a3 3a b7 35			ld a, (.dmark)  
35a6 32 77 fb			ld (debug_mark),a  
35a9 3a b8 35			ld a, (.dmark+1)  
35ac 32 78 fb			ld (debug_mark+1),a  
35af 3a b9 35			ld a, (.dmark+2)  
35b2 32 79 fb			ld (debug_mark+2),a  
35b5 18 03			jr .pastdmark  
35b7 ..			.dmark: db "GRT"  
35ba f1			.pastdmark: pop af  
35bb			endm  
# End of macro DMARK
35bb						CALLMONITOR 
35bb cd 49 17			call break_point_state  
35be				endm  
# End of macro CALLMONITOR
35be					endif 
35be					FORTH_DSP 
35be cd 96 1e			call macro_forth_dsp 
35c1				endm 
# End of macro FORTH_DSP
35c1					;FORTH_DSP_VALUE 
35c1 7e					ld a,(hl)	; get type of value on TOS 
35c2 fe 02				cp DS_TYPE_INUM  
35c4 28 00				jr z, .gt_inum 
35c6			 
35c6				if FORTH_ENABLE_FLOATMATH 
35c6					jr .gt_done 
35c6			 
35c6				endif 
35c6					 
35c6			 
35c6			.gt_inum: 
35c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35c6 cd d0 1e			call macro_dsp_valuehl 
35c9				endm 
# End of macro FORTH_DSP_VALUEHL
35c9			 
35c9 e5					push hl  ; u2 
35ca			 
35ca					; destroy value TOS 
35ca			 
35ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ca cd 88 1f			call macro_forth_dsp_pop 
35cd				endm 
# End of macro FORTH_DSP_POP
35cd			 
35cd			 
35cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35cd cd d0 1e			call macro_dsp_valuehl 
35d0				endm 
# End of macro FORTH_DSP_VALUEHL
35d0			 
35d0 e5					push hl    ; u1 
35d1			 
35d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35d1 cd 88 1f			call macro_forth_dsp_pop 
35d4				endm 
# End of macro FORTH_DSP_POP
35d4			 
35d4			 
35d4 b7			 or a      ;clear carry flag 
35d5 01 00 00		 ld bc, FORTH_FALSE 
35d8 e1			  pop hl    ; u1 
35d9 d1			  pop de    ; u2 
35da ed 52		  sbc hl,de 
35dc 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
35de			 
35de 01 01 00		 ld bc, FORTH_TRUE 
35e1			.gtcont:  
35e1 c5					push bc 
35e2 e1					pop hl 
35e3			 
35e3					if DEBUG_FORTH_WORDS 
35e3						DMARK "GT1" 
35e3 f5				push af  
35e4 3a f8 35			ld a, (.dmark)  
35e7 32 77 fb			ld (debug_mark),a  
35ea 3a f9 35			ld a, (.dmark+1)  
35ed 32 78 fb			ld (debug_mark+1),a  
35f0 3a fa 35			ld a, (.dmark+2)  
35f3 32 79 fb			ld (debug_mark+2),a  
35f6 18 03			jr .pastdmark  
35f8 ..			.dmark: db "GT1"  
35fb f1			.pastdmark: pop af  
35fc			endm  
# End of macro DMARK
35fc						CALLMONITOR 
35fc cd 49 17			call break_point_state  
35ff				endm  
# End of macro CALLMONITOR
35ff					endif 
35ff cd d9 1c				call forth_push_numhl 
3602			 
3602					NEXTW 
3602 c3 42 20			jp macro_next 
3605				endm 
# End of macro NEXTW
3605			.EQUAL: 
3605				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3605 31				db WORD_SYS_CORE+29             
3606 70 36			dw .ENDLOGIC            
3608 02				db 1 + 1 
3609 .. 00			db "=",0              
360b				endm 
# End of macro CWHEAD
360b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
360b				; TODO add floating point number detection 
360b					if DEBUG_FORTH_WORDS_KEY 
360b						DMARK "EQ." 
360b f5				push af  
360c 3a 20 36			ld a, (.dmark)  
360f 32 77 fb			ld (debug_mark),a  
3612 3a 21 36			ld a, (.dmark+1)  
3615 32 78 fb			ld (debug_mark+1),a  
3618 3a 22 36			ld a, (.dmark+2)  
361b 32 79 fb			ld (debug_mark+2),a  
361e 18 03			jr .pastdmark  
3620 ..			.dmark: db "EQ."  
3623 f1			.pastdmark: pop af  
3624			endm  
# End of macro DMARK
3624						CALLMONITOR 
3624 cd 49 17			call break_point_state  
3627				endm  
# End of macro CALLMONITOR
3627					endif 
3627					FORTH_DSP 
3627 cd 96 1e			call macro_forth_dsp 
362a				endm 
# End of macro FORTH_DSP
362a					;v5 FORTH_DSP_VALUE 
362a 7e					ld a,(hl)	; get type of value on TOS 
362b fe 02				cp DS_TYPE_INUM  
362d 28 00				jr z, .eq_inum 
362f			 
362f				if FORTH_ENABLE_FLOATMATH 
362f					jr .eq_done 
362f			 
362f				endif 
362f					 
362f			 
362f			.eq_inum: 
362f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
362f cd d0 1e			call macro_dsp_valuehl 
3632				endm 
# End of macro FORTH_DSP_VALUEHL
3632			 
3632 e5					push hl 
3633			 
3633					; destroy value TOS 
3633			 
3633					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3633 cd 88 1f			call macro_forth_dsp_pop 
3636				endm 
# End of macro FORTH_DSP_POP
3636			 
3636			 
3636					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3636 cd d0 1e			call macro_dsp_valuehl 
3639				endm 
# End of macro FORTH_DSP_VALUEHL
3639			 
3639					; one value on hl get other one back 
3639			 
3639 e5					push hl 
363a			 
363a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
363a cd 88 1f			call macro_forth_dsp_pop 
363d				endm 
# End of macro FORTH_DSP_POP
363d			 
363d 0e 00				ld c, FORTH_FALSE 
363f			 
363f e1					pop hl 
3640 d1					pop de 
3641			 
3641 7b					ld a, e 
3642 bd					cp l 
3643			 
3643 20 06				jr nz, .eq_done 
3645			 
3645 7a					ld a, d 
3646 bc					cp h 
3647			 
3647 20 02				jr nz, .eq_done 
3649			 
3649 0e 01				ld c, FORTH_TRUE 
364b					 
364b			 
364b			 
364b			.eq_done: 
364b			 
364b					; TODO push value back onto stack for another op etc 
364b			 
364b 26 00				ld h, 0 
364d 69					ld l, c 
364e					if DEBUG_FORTH_WORDS 
364e						DMARK "EQ1" 
364e f5				push af  
364f 3a 63 36			ld a, (.dmark)  
3652 32 77 fb			ld (debug_mark),a  
3655 3a 64 36			ld a, (.dmark+1)  
3658 32 78 fb			ld (debug_mark+1),a  
365b 3a 65 36			ld a, (.dmark+2)  
365e 32 79 fb			ld (debug_mark+2),a  
3661 18 03			jr .pastdmark  
3663 ..			.dmark: db "EQ1"  
3666 f1			.pastdmark: pop af  
3667			endm  
# End of macro DMARK
3667						CALLMONITOR 
3667 cd 49 17			call break_point_state  
366a				endm  
# End of macro CALLMONITOR
366a					endif 
366a cd d9 1c				call forth_push_numhl 
366d			 
366d					NEXTW 
366d c3 42 20			jp macro_next 
3670				endm 
# End of macro NEXTW
3670			 
3670			 
3670			.ENDLOGIC: 
3670			; eof 
3670			 
3670			 
# End of file forth_words_logic.asm
3670			include "forth_words_maths.asm" 
3670			 
3670			; | ## Maths Words 
3670			 
3670			.PLUS:	 
3670				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3670 15				db WORD_SYS_CORE+1             
3671 b2 36			dw .NEG            
3673 02				db 1 + 1 
3674 .. 00			db "+",0              
3676				endm 
# End of macro CWHEAD
3676			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3676					if DEBUG_FORTH_WORDS_KEY 
3676						DMARK "PLU" 
3676 f5				push af  
3677 3a 8b 36			ld a, (.dmark)  
367a 32 77 fb			ld (debug_mark),a  
367d 3a 8c 36			ld a, (.dmark+1)  
3680 32 78 fb			ld (debug_mark+1),a  
3683 3a 8d 36			ld a, (.dmark+2)  
3686 32 79 fb			ld (debug_mark+2),a  
3689 18 03			jr .pastdmark  
368b ..			.dmark: db "PLU"  
368e f1			.pastdmark: pop af  
368f			endm  
# End of macro DMARK
368f						CALLMONITOR 
368f cd 49 17			call break_point_state  
3692				endm  
# End of macro CALLMONITOR
3692					endif 
3692					; add top two values and push back result 
3692			 
3692					;for v5 FORTH_DSP_VALUE 
3692					FORTH_DSP 
3692 cd 96 1e			call macro_forth_dsp 
3695				endm 
# End of macro FORTH_DSP
3695 7e					ld a,(hl)	; get type of value on TOS 
3696 fe 02				cp DS_TYPE_INUM  
3698 28 03				jr z, .dot_inum 
369a			 
369a					NEXTW 
369a c3 42 20			jp macro_next 
369d				endm 
# End of macro NEXTW
369d			 
369d			; float maths 
369d			 
369d				if FORTH_ENABLE_FLOATMATH 
369d						inc hl      ; now at start of numeric as string 
369d			 
369d					if DEBUG_FORTH_MATHS 
369d						DMARK "ADD" 
369d				CALLMONITOR 
369d					endif 
369d			 
369d					;ld ix, hl 
369d					call CON 
369d			 
369d			 
369d					push hl 
369d					 
369d					 
369d			 
369d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
369d			 
369d					; get next number 
369d			 
369d						FORTH_DSP_VALUE 
369d			 
369d						inc hl      ; now at start of numeric as string 
369d			 
369d					;ld ix, hl 
369d					call CON 
369d			 
369d					push hl 
369d			 
369d			 
369d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
369d			 
369d						; TODO do add 
369d			 
369d						call IADD 
369d			 
369d						; TODO get result back as ascii 
369d			 
369d						; TODO push result  
369d			 
369d			 
369d			 
369d						jr .dot_done 
369d				endif 
369d			 
369d			.dot_inum: 
369d			 
369d			 
369d					if DEBUG_FORTH_DOT 
369d						DMARK "+IT" 
369d				CALLMONITOR 
369d					endif 
369d			 
369d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
369d cd d0 1e			call macro_dsp_valuehl 
36a0				endm 
# End of macro FORTH_DSP_VALUEHL
36a0			 
36a0				; TODO add floating point number detection 
36a0			 
36a0 e5					push hl 
36a1			 
36a1					; destroy value TOS 
36a1			 
36a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a1 cd 88 1f			call macro_forth_dsp_pop 
36a4				endm 
# End of macro FORTH_DSP_POP
36a4			 
36a4			 
36a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36a4 cd d0 1e			call macro_dsp_valuehl 
36a7				endm 
# End of macro FORTH_DSP_VALUEHL
36a7			 
36a7					; one value on hl get other one back 
36a7			 
36a7 d1					pop de 
36a8			 
36a8					; do the add 
36a8			 
36a8 19					add hl,de 
36a9			 
36a9					; save it 
36a9			 
36a9			;		push hl	 
36a9			 
36a9					; 
36a9			 
36a9					; destroy value TOS 
36a9			 
36a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36a9 cd 88 1f			call macro_forth_dsp_pop 
36ac				endm 
# End of macro FORTH_DSP_POP
36ac			 
36ac					; TODO push value back onto stack for another op etc 
36ac			 
36ac			;		pop hl 
36ac			 
36ac			.dot_done: 
36ac cd d9 1c				call forth_push_numhl 
36af			 
36af					NEXTW 
36af c3 42 20			jp macro_next 
36b2				endm 
# End of macro NEXTW
36b2			.NEG: 
36b2			 
36b2				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36b2 17				db WORD_SYS_CORE+3             
36b3 f5 36			dw .DIV            
36b5 02				db 1 + 1 
36b6 .. 00			db "-",0              
36b8				endm 
# End of macro CWHEAD
36b8			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36b8					if DEBUG_FORTH_WORDS_KEY 
36b8						DMARK "SUB" 
36b8 f5				push af  
36b9 3a cd 36			ld a, (.dmark)  
36bc 32 77 fb			ld (debug_mark),a  
36bf 3a ce 36			ld a, (.dmark+1)  
36c2 32 78 fb			ld (debug_mark+1),a  
36c5 3a cf 36			ld a, (.dmark+2)  
36c8 32 79 fb			ld (debug_mark+2),a  
36cb 18 03			jr .pastdmark  
36cd ..			.dmark: db "SUB"  
36d0 f1			.pastdmark: pop af  
36d1			endm  
# End of macro DMARK
36d1						CALLMONITOR 
36d1 cd 49 17			call break_point_state  
36d4				endm  
# End of macro CALLMONITOR
36d4					endif 
36d4			 
36d4			 
36d4				; TODO add floating point number detection 
36d4					; v5 FORTH_DSP_VALUE 
36d4					FORTH_DSP 
36d4 cd 96 1e			call macro_forth_dsp 
36d7				endm 
# End of macro FORTH_DSP
36d7 7e					ld a,(hl)	; get type of value on TOS 
36d8 fe 02				cp DS_TYPE_INUM  
36da 28 03				jr z, .neg_inum 
36dc			 
36dc					NEXTW 
36dc c3 42 20			jp macro_next 
36df				endm 
# End of macro NEXTW
36df			 
36df			; float maths 
36df			 
36df				if FORTH_ENABLE_FLOATMATH 
36df					jr .neg_done 
36df			 
36df				endif 
36df					 
36df			 
36df			.neg_inum: 
36df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36df cd d0 1e			call macro_dsp_valuehl 
36e2				endm 
# End of macro FORTH_DSP_VALUEHL
36e2			 
36e2 e5					push hl 
36e3			 
36e3					; destroy value TOS 
36e3			 
36e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e3 cd 88 1f			call macro_forth_dsp_pop 
36e6				endm 
# End of macro FORTH_DSP_POP
36e6			 
36e6			 
36e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e6 cd d0 1e			call macro_dsp_valuehl 
36e9				endm 
# End of macro FORTH_DSP_VALUEHL
36e9			 
36e9					; one value on hl get other one back 
36e9			 
36e9 d1					pop de 
36ea			 
36ea					; do the sub 
36ea			;		ex de, hl 
36ea			 
36ea ed 52				sbc hl,de 
36ec			 
36ec					; save it 
36ec			 
36ec			;		push hl	 
36ec			 
36ec					; 
36ec			 
36ec					; destroy value TOS 
36ec			 
36ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ec cd 88 1f			call macro_forth_dsp_pop 
36ef				endm 
# End of macro FORTH_DSP_POP
36ef			 
36ef					; TODO push value back onto stack for another op etc 
36ef			 
36ef			;		pop hl 
36ef			 
36ef cd d9 1c				call forth_push_numhl 
36f2			.neg_done: 
36f2			 
36f2					NEXTW 
36f2 c3 42 20			jp macro_next 
36f5				endm 
# End of macro NEXTW
36f5			.DIV: 
36f5				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36f5 18				db WORD_SYS_CORE+4             
36f6 42 37			dw .MUL            
36f8 02				db 1 + 1 
36f9 .. 00			db "/",0              
36fb				endm 
# End of macro CWHEAD
36fb			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36fb					if DEBUG_FORTH_WORDS_KEY 
36fb						DMARK "DIV" 
36fb f5				push af  
36fc 3a 10 37			ld a, (.dmark)  
36ff 32 77 fb			ld (debug_mark),a  
3702 3a 11 37			ld a, (.dmark+1)  
3705 32 78 fb			ld (debug_mark+1),a  
3708 3a 12 37			ld a, (.dmark+2)  
370b 32 79 fb			ld (debug_mark+2),a  
370e 18 03			jr .pastdmark  
3710 ..			.dmark: db "DIV"  
3713 f1			.pastdmark: pop af  
3714			endm  
# End of macro DMARK
3714						CALLMONITOR 
3714 cd 49 17			call break_point_state  
3717				endm  
# End of macro CALLMONITOR
3717					endif 
3717				; TODO add floating point number detection 
3717					; v5 FORTH_DSP_VALUE 
3717					FORTH_DSP 
3717 cd 96 1e			call macro_forth_dsp 
371a				endm 
# End of macro FORTH_DSP
371a 7e					ld a,(hl)	; get type of value on TOS 
371b fe 02				cp DS_TYPE_INUM  
371d 28 03				jr z, .div_inum 
371f			 
371f				if FORTH_ENABLE_FLOATMATH 
371f					jr .div_done 
371f			 
371f				endif 
371f					NEXTW 
371f c3 42 20			jp macro_next 
3722				endm 
# End of macro NEXTW
3722			.div_inum: 
3722			 
3722					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3722 cd d0 1e			call macro_dsp_valuehl 
3725				endm 
# End of macro FORTH_DSP_VALUEHL
3725			 
3725 e5					push hl    ; to go to bc 
3726			 
3726					; destroy value TOS 
3726			 
3726					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3726 cd 88 1f			call macro_forth_dsp_pop 
3729				endm 
# End of macro FORTH_DSP_POP
3729			 
3729			 
3729					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3729 cd d0 1e			call macro_dsp_valuehl 
372c				endm 
# End of macro FORTH_DSP_VALUEHL
372c			 
372c					; hl to go to de 
372c			 
372c e5					push hl 
372d			 
372d c1					pop bc 
372e d1					pop de		 
372f			 
372f			 
372f					if DEBUG_FORTH_MATHS 
372f						DMARK "DIV" 
372f				CALLMONITOR 
372f					endif 
372f					; one value on hl but move to a get other one back 
372f			 
372f			        
372f cd 69 0c			call Div16 
3732			 
3732			;	push af	 
3732 e5				push hl 
3733 c5				push bc 
3734			 
3734					if DEBUG_FORTH_MATHS 
3734						DMARK "DI1" 
3734				CALLMONITOR 
3734					endif 
3734			 
3734					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3734 cd 88 1f			call macro_forth_dsp_pop 
3737				endm 
# End of macro FORTH_DSP_POP
3737			 
3737			 
3737			 
3737 e1					pop hl    ; result 
3738			 
3738 cd d9 1c				call forth_push_numhl 
373b			 
373b e1					pop hl    ; reminder 
373c			;		ld h,0 
373c			;		ld l,d 
373c			 
373c cd d9 1c				call forth_push_numhl 
373f			.div_done: 
373f					NEXTW 
373f c3 42 20			jp macro_next 
3742				endm 
# End of macro NEXTW
3742			.MUL: 
3742				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3742 19				db WORD_SYS_CORE+5             
3743 87 37			dw .MIN            
3745 02				db 1 + 1 
3746 .. 00			db "*",0              
3748				endm 
# End of macro CWHEAD
3748			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3748				; TODO add floating point number detection 
3748					if DEBUG_FORTH_WORDS_KEY 
3748						DMARK "MUL" 
3748 f5				push af  
3749 3a 5d 37			ld a, (.dmark)  
374c 32 77 fb			ld (debug_mark),a  
374f 3a 5e 37			ld a, (.dmark+1)  
3752 32 78 fb			ld (debug_mark+1),a  
3755 3a 5f 37			ld a, (.dmark+2)  
3758 32 79 fb			ld (debug_mark+2),a  
375b 18 03			jr .pastdmark  
375d ..			.dmark: db "MUL"  
3760 f1			.pastdmark: pop af  
3761			endm  
# End of macro DMARK
3761						CALLMONITOR 
3761 cd 49 17			call break_point_state  
3764				endm  
# End of macro CALLMONITOR
3764					endif 
3764					FORTH_DSP 
3764 cd 96 1e			call macro_forth_dsp 
3767				endm 
# End of macro FORTH_DSP
3767					; v5 FORTH_DSP_VALUE 
3767 7e					ld a,(hl)	; get type of value on TOS 
3768 fe 02				cp DS_TYPE_INUM  
376a 28 03				jr z, .mul_inum 
376c			 
376c				if FORTH_ENABLE_FLOATMATH 
376c					jr .mul_done 
376c			 
376c				endif 
376c			 
376c					NEXTW 
376c c3 42 20			jp macro_next 
376f				endm 
# End of macro NEXTW
376f			.mul_inum:	 
376f			 
376f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376f cd d0 1e			call macro_dsp_valuehl 
3772				endm 
# End of macro FORTH_DSP_VALUEHL
3772			 
3772 e5					push hl 
3773			 
3773					; destroy value TOS 
3773			 
3773					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3773 cd 88 1f			call macro_forth_dsp_pop 
3776				endm 
# End of macro FORTH_DSP_POP
3776			 
3776			 
3776					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3776 cd d0 1e			call macro_dsp_valuehl 
3779				endm 
# End of macro FORTH_DSP_VALUEHL
3779			 
3779					; one value on hl but move to a get other one back 
3779			 
3779 7d					ld a, l 
377a			 
377a d1					pop de 
377b			 
377b					; do the mull 
377b			;		ex de, hl 
377b			 
377b cd 8f 0c				call Mult16 
377e					; save it 
377e			 
377e			;		push hl	 
377e			 
377e					; 
377e			 
377e					; destroy value TOS 
377e			 
377e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
377e cd 88 1f			call macro_forth_dsp_pop 
3781				endm 
# End of macro FORTH_DSP_POP
3781			 
3781					; TODO push value back onto stack for another op etc 
3781			 
3781			;		pop hl 
3781			 
3781 cd d9 1c				call forth_push_numhl 
3784			 
3784			.mul_done: 
3784					NEXTW 
3784 c3 42 20			jp macro_next 
3787				endm 
# End of macro NEXTW
3787			 
3787			 
3787			 
3787			 
3787			.MIN: 
3787				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3787 49				db WORD_SYS_CORE+53             
3788 08 38			dw .MAX            
378a 04				db 3 + 1 
378b .. 00			db "MIN",0              
378f				endm 
# End of macro CWHEAD
378f			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
378f					if DEBUG_FORTH_WORDS_KEY 
378f						DMARK "MIN" 
378f f5				push af  
3790 3a a4 37			ld a, (.dmark)  
3793 32 77 fb			ld (debug_mark),a  
3796 3a a5 37			ld a, (.dmark+1)  
3799 32 78 fb			ld (debug_mark+1),a  
379c 3a a6 37			ld a, (.dmark+2)  
379f 32 79 fb			ld (debug_mark+2),a  
37a2 18 03			jr .pastdmark  
37a4 ..			.dmark: db "MIN"  
37a7 f1			.pastdmark: pop af  
37a8			endm  
# End of macro DMARK
37a8						CALLMONITOR 
37a8 cd 49 17			call break_point_state  
37ab				endm  
# End of macro CALLMONITOR
37ab					endif 
37ab					; get u2 
37ab			 
37ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ab cd d0 1e			call macro_dsp_valuehl 
37ae				endm 
# End of macro FORTH_DSP_VALUEHL
37ae			 
37ae e5					push hl   ; u2 
37af			 
37af					; destroy value TOS 
37af			 
37af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37af cd 88 1f			call macro_forth_dsp_pop 
37b2				endm 
# End of macro FORTH_DSP_POP
37b2			 
37b2					; get u1 
37b2			 
37b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b2 cd d0 1e			call macro_dsp_valuehl 
37b5				endm 
# End of macro FORTH_DSP_VALUEHL
37b5			 
37b5 e5					push hl  ; u1 
37b6			 
37b6					; destroy value TOS 
37b6			 
37b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b6 cd 88 1f			call macro_forth_dsp_pop 
37b9				endm 
# End of macro FORTH_DSP_POP
37b9			 
37b9 b7			 or a      ;clear carry flag 
37ba e1			  pop hl    ; u1 
37bb d1			  pop de    ; u2 
37bc e5				push hl   ; saved in case hl is lowest 
37bd ed 52		  sbc hl,de 
37bf 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37c1			 
37c1 e1				pop hl 
37c2					if DEBUG_FORTH_WORDS 
37c2						DMARK "MIN" 
37c2 f5				push af  
37c3 3a d7 37			ld a, (.dmark)  
37c6 32 77 fb			ld (debug_mark),a  
37c9 3a d8 37			ld a, (.dmark+1)  
37cc 32 78 fb			ld (debug_mark+1),a  
37cf 3a d9 37			ld a, (.dmark+2)  
37d2 32 79 fb			ld (debug_mark+2),a  
37d5 18 03			jr .pastdmark  
37d7 ..			.dmark: db "MIN"  
37da f1			.pastdmark: pop af  
37db			endm  
# End of macro DMARK
37db						CALLMONITOR 
37db cd 49 17			call break_point_state  
37de				endm  
# End of macro CALLMONITOR
37de					endif 
37de cd d9 1c				call forth_push_numhl 
37e1			 
37e1				       NEXTW 
37e1 c3 42 20			jp macro_next 
37e4				endm 
# End of macro NEXTW
37e4			 
37e4			.mincont:  
37e4 c1				pop bc   ; tidy up 
37e5 eb				ex de , hl  
37e6					if DEBUG_FORTH_WORDS 
37e6						DMARK "MI1" 
37e6 f5				push af  
37e7 3a fb 37			ld a, (.dmark)  
37ea 32 77 fb			ld (debug_mark),a  
37ed 3a fc 37			ld a, (.dmark+1)  
37f0 32 78 fb			ld (debug_mark+1),a  
37f3 3a fd 37			ld a, (.dmark+2)  
37f6 32 79 fb			ld (debug_mark+2),a  
37f9 18 03			jr .pastdmark  
37fb ..			.dmark: db "MI1"  
37fe f1			.pastdmark: pop af  
37ff			endm  
# End of macro DMARK
37ff						CALLMONITOR 
37ff cd 49 17			call break_point_state  
3802				endm  
# End of macro CALLMONITOR
3802					endif 
3802 cd d9 1c				call forth_push_numhl 
3805			 
3805				       NEXTW 
3805 c3 42 20			jp macro_next 
3808				endm 
# End of macro NEXTW
3808			.MAX: 
3808				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3808 4a				db WORD_SYS_CORE+54             
3809 89 38			dw .RND16            
380b 04				db 3 + 1 
380c .. 00			db "MAX",0              
3810				endm 
# End of macro CWHEAD
3810			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3810					if DEBUG_FORTH_WORDS_KEY 
3810						DMARK "MAX" 
3810 f5				push af  
3811 3a 25 38			ld a, (.dmark)  
3814 32 77 fb			ld (debug_mark),a  
3817 3a 26 38			ld a, (.dmark+1)  
381a 32 78 fb			ld (debug_mark+1),a  
381d 3a 27 38			ld a, (.dmark+2)  
3820 32 79 fb			ld (debug_mark+2),a  
3823 18 03			jr .pastdmark  
3825 ..			.dmark: db "MAX"  
3828 f1			.pastdmark: pop af  
3829			endm  
# End of macro DMARK
3829						CALLMONITOR 
3829 cd 49 17			call break_point_state  
382c				endm  
# End of macro CALLMONITOR
382c					endif 
382c					; get u2 
382c			 
382c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382c cd d0 1e			call macro_dsp_valuehl 
382f				endm 
# End of macro FORTH_DSP_VALUEHL
382f			 
382f e5					push hl   ; u2 
3830			 
3830					; destroy value TOS 
3830			 
3830					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3830 cd 88 1f			call macro_forth_dsp_pop 
3833				endm 
# End of macro FORTH_DSP_POP
3833			 
3833					; get u1 
3833			 
3833					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3833 cd d0 1e			call macro_dsp_valuehl 
3836				endm 
# End of macro FORTH_DSP_VALUEHL
3836			 
3836 e5					push hl  ; u1 
3837			 
3837					; destroy value TOS 
3837			 
3837					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3837 cd 88 1f			call macro_forth_dsp_pop 
383a				endm 
# End of macro FORTH_DSP_POP
383a			 
383a b7			 or a      ;clear carry flag 
383b e1			  pop hl    ; u1 
383c d1			  pop de    ; u2 
383d e5				push hl   ; saved in case hl is lowest 
383e ed 52		  sbc hl,de 
3840 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3842			 
3842 e1				pop hl 
3843					if DEBUG_FORTH_WORDS 
3843						DMARK "MAX" 
3843 f5				push af  
3844 3a 58 38			ld a, (.dmark)  
3847 32 77 fb			ld (debug_mark),a  
384a 3a 59 38			ld a, (.dmark+1)  
384d 32 78 fb			ld (debug_mark+1),a  
3850 3a 5a 38			ld a, (.dmark+2)  
3853 32 79 fb			ld (debug_mark+2),a  
3856 18 03			jr .pastdmark  
3858 ..			.dmark: db "MAX"  
385b f1			.pastdmark: pop af  
385c			endm  
# End of macro DMARK
385c						CALLMONITOR 
385c cd 49 17			call break_point_state  
385f				endm  
# End of macro CALLMONITOR
385f					endif 
385f cd d9 1c				call forth_push_numhl 
3862			 
3862				       NEXTW 
3862 c3 42 20			jp macro_next 
3865				endm 
# End of macro NEXTW
3865			 
3865			.maxcont:  
3865 c1				pop bc   ; tidy up 
3866 eb				ex de , hl  
3867					if DEBUG_FORTH_WORDS 
3867						DMARK "MA1" 
3867 f5				push af  
3868 3a 7c 38			ld a, (.dmark)  
386b 32 77 fb			ld (debug_mark),a  
386e 3a 7d 38			ld a, (.dmark+1)  
3871 32 78 fb			ld (debug_mark+1),a  
3874 3a 7e 38			ld a, (.dmark+2)  
3877 32 79 fb			ld (debug_mark+2),a  
387a 18 03			jr .pastdmark  
387c ..			.dmark: db "MA1"  
387f f1			.pastdmark: pop af  
3880			endm  
# End of macro DMARK
3880						CALLMONITOR 
3880 cd 49 17			call break_point_state  
3883				endm  
# End of macro CALLMONITOR
3883					endif 
3883 cd d9 1c				call forth_push_numhl 
3886				       NEXTW 
3886 c3 42 20			jp macro_next 
3889				endm 
# End of macro NEXTW
3889			 
3889			.RND16: 
3889				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3889 4e				db WORD_SYS_CORE+58             
388a b8 38			dw .RND8            
388c 06				db 5 + 1 
388d .. 00			db "RND16",0              
3893				endm 
# End of macro CWHEAD
3893			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3893					if DEBUG_FORTH_WORDS_KEY 
3893						DMARK "R16" 
3893 f5				push af  
3894 3a a8 38			ld a, (.dmark)  
3897 32 77 fb			ld (debug_mark),a  
389a 3a a9 38			ld a, (.dmark+1)  
389d 32 78 fb			ld (debug_mark+1),a  
38a0 3a aa 38			ld a, (.dmark+2)  
38a3 32 79 fb			ld (debug_mark+2),a  
38a6 18 03			jr .pastdmark  
38a8 ..			.dmark: db "R16"  
38ab f1			.pastdmark: pop af  
38ac			endm  
# End of macro DMARK
38ac						CALLMONITOR 
38ac cd 49 17			call break_point_state  
38af				endm  
# End of macro CALLMONITOR
38af					endif 
38af cd 33 0c				call prng16  
38b2 cd d9 1c				call forth_push_numhl 
38b5				       NEXTW 
38b5 c3 42 20			jp macro_next 
38b8				endm 
# End of macro NEXTW
38b8			.RND8: 
38b8				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38b8 60				db WORD_SYS_CORE+76             
38b9 ed 38			dw .RND            
38bb 05				db 4 + 1 
38bc .. 00			db "RND8",0              
38c1				endm 
# End of macro CWHEAD
38c1			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38c1					if DEBUG_FORTH_WORDS_KEY 
38c1						DMARK "RN8" 
38c1 f5				push af  
38c2 3a d6 38			ld a, (.dmark)  
38c5 32 77 fb			ld (debug_mark),a  
38c8 3a d7 38			ld a, (.dmark+1)  
38cb 32 78 fb			ld (debug_mark+1),a  
38ce 3a d8 38			ld a, (.dmark+2)  
38d1 32 79 fb			ld (debug_mark+2),a  
38d4 18 03			jr .pastdmark  
38d6 ..			.dmark: db "RN8"  
38d9 f1			.pastdmark: pop af  
38da			endm  
# End of macro DMARK
38da						CALLMONITOR 
38da cd 49 17			call break_point_state  
38dd				endm  
# End of macro CALLMONITOR
38dd					endif 
38dd 2a b8 f8				ld hl,(xrandc) 
38e0 23					inc hl 
38e1 cd 4d 0c				call xrnd 
38e4 6f					ld l,a	 
38e5 26 00				ld h,0 
38e7 cd d9 1c				call forth_push_numhl 
38ea				       NEXTW 
38ea c3 42 20			jp macro_next 
38ed				endm 
# End of macro NEXTW
38ed			.RND: 
38ed				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38ed 60				db WORD_SYS_CORE+76             
38ee f3 39			dw .ENDMATHS            
38f0 04				db 3 + 1 
38f1 .. 00			db "RND",0              
38f5				endm 
# End of macro CWHEAD
38f5			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38f5			 
38f5					if DEBUG_FORTH_WORDS_KEY 
38f5						DMARK "RND" 
38f5 f5				push af  
38f6 3a 0a 39			ld a, (.dmark)  
38f9 32 77 fb			ld (debug_mark),a  
38fc 3a 0b 39			ld a, (.dmark+1)  
38ff 32 78 fb			ld (debug_mark+1),a  
3902 3a 0c 39			ld a, (.dmark+2)  
3905 32 79 fb			ld (debug_mark+2),a  
3908 18 03			jr .pastdmark  
390a ..			.dmark: db "RND"  
390d f1			.pastdmark: pop af  
390e			endm  
# End of macro DMARK
390e						CALLMONITOR 
390e cd 49 17			call break_point_state  
3911				endm  
# End of macro CALLMONITOR
3911					endif 
3911					 
3911					FORTH_DSP_VALUEHL    ; upper range 
3911 cd d0 1e			call macro_dsp_valuehl 
3914				endm 
# End of macro FORTH_DSP_VALUEHL
3914			 
3914 22 bc f8				ld (LFSRSeed), hl	 
3917			 
3917					if DEBUG_FORTH_WORDS 
3917						DMARK "RN1" 
3917 f5				push af  
3918 3a 2c 39			ld a, (.dmark)  
391b 32 77 fb			ld (debug_mark),a  
391e 3a 2d 39			ld a, (.dmark+1)  
3921 32 78 fb			ld (debug_mark+1),a  
3924 3a 2e 39			ld a, (.dmark+2)  
3927 32 79 fb			ld (debug_mark+2),a  
392a 18 03			jr .pastdmark  
392c ..			.dmark: db "RN1"  
392f f1			.pastdmark: pop af  
3930			endm  
# End of macro DMARK
3930						CALLMONITOR 
3930 cd 49 17			call break_point_state  
3933				endm  
# End of macro CALLMONITOR
3933					endif 
3933					FORTH_DSP_POP 
3933 cd 88 1f			call macro_forth_dsp_pop 
3936				endm 
# End of macro FORTH_DSP_POP
3936			 
3936					FORTH_DSP_VALUEHL    ; low range 
3936 cd d0 1e			call macro_dsp_valuehl 
3939				endm 
# End of macro FORTH_DSP_VALUEHL
3939			 
3939					if DEBUG_FORTH_WORDS 
3939						DMARK "RN2" 
3939 f5				push af  
393a 3a 4e 39			ld a, (.dmark)  
393d 32 77 fb			ld (debug_mark),a  
3940 3a 4f 39			ld a, (.dmark+1)  
3943 32 78 fb			ld (debug_mark+1),a  
3946 3a 50 39			ld a, (.dmark+2)  
3949 32 79 fb			ld (debug_mark+2),a  
394c 18 03			jr .pastdmark  
394e ..			.dmark: db "RN2"  
3951 f1			.pastdmark: pop af  
3952			endm  
# End of macro DMARK
3952						CALLMONITOR 
3952 cd 49 17			call break_point_state  
3955				endm  
# End of macro CALLMONITOR
3955					endif 
3955 22 be f8				ld (LFSRSeed+2), hl 
3958			 
3958					FORTH_DSP_POP 
3958 cd 88 1f			call macro_forth_dsp_pop 
395b				endm 
# End of macro FORTH_DSP_POP
395b			 
395b e5					push hl 
395c			 
395c e1			.inrange:	pop hl 
395d cd 33 0c				call prng16  
3960					if DEBUG_FORTH_WORDS 
3960						DMARK "RN3" 
3960 f5				push af  
3961 3a 75 39			ld a, (.dmark)  
3964 32 77 fb			ld (debug_mark),a  
3967 3a 76 39			ld a, (.dmark+1)  
396a 32 78 fb			ld (debug_mark+1),a  
396d 3a 77 39			ld a, (.dmark+2)  
3970 32 79 fb			ld (debug_mark+2),a  
3973 18 03			jr .pastdmark  
3975 ..			.dmark: db "RN3"  
3978 f1			.pastdmark: pop af  
3979			endm  
# End of macro DMARK
3979						CALLMONITOR 
3979 cd 49 17			call break_point_state  
397c				endm  
# End of macro CALLMONITOR
397c					endif 
397c					 
397c					; if the range is 8bit knock out the high byte 
397c			 
397c ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3980			 
3980 3e 00				ld a, 0 
3982 ba					cp d  
3983 20 1e				jr nz, .hirange 
3985 26 00				ld h, 0   ; knock it down to 8bit 
3987			 
3987					if DEBUG_FORTH_WORDS 
3987						DMARK "RNk" 
3987 f5				push af  
3988 3a 9c 39			ld a, (.dmark)  
398b 32 77 fb			ld (debug_mark),a  
398e 3a 9d 39			ld a, (.dmark+1)  
3991 32 78 fb			ld (debug_mark+1),a  
3994 3a 9e 39			ld a, (.dmark+2)  
3997 32 79 fb			ld (debug_mark+2),a  
399a 18 03			jr .pastdmark  
399c ..			.dmark: db "RNk"  
399f f1			.pastdmark: pop af  
39a0			endm  
# End of macro DMARK
39a0						CALLMONITOR 
39a0 cd 49 17			call break_point_state  
39a3				endm  
# End of macro CALLMONITOR
39a3					endif 
39a3			.hirange:   
39a3 e5					push hl  
39a4 b7					or a  
39a5 ed 52		                sbc hl, de 
39a7			 
39a7					;call cmp16 
39a7			 
39a7 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39a9 e1					pop hl 
39aa e5					push hl 
39ab			 
39ab					if DEBUG_FORTH_WORDS 
39ab						DMARK "RN4" 
39ab f5				push af  
39ac 3a c0 39			ld a, (.dmark)  
39af 32 77 fb			ld (debug_mark),a  
39b2 3a c1 39			ld a, (.dmark+1)  
39b5 32 78 fb			ld (debug_mark+1),a  
39b8 3a c2 39			ld a, (.dmark+2)  
39bb 32 79 fb			ld (debug_mark+2),a  
39be 18 03			jr .pastdmark  
39c0 ..			.dmark: db "RN4"  
39c3 f1			.pastdmark: pop af  
39c4			endm  
# End of macro DMARK
39c4						CALLMONITOR 
39c4 cd 49 17			call break_point_state  
39c7				endm  
# End of macro CALLMONITOR
39c7					endif 
39c7 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
39cb					;call cmp16 
39cb				 
39cb b7					or a  
39cc ed 52		                sbc hl, de 
39ce 38 8c				jr c, .inrange 
39d0			 
39d0 e1					pop hl 
39d1					 
39d1					if DEBUG_FORTH_WORDS 
39d1						DMARK "RNd" 
39d1 f5				push af  
39d2 3a e6 39			ld a, (.dmark)  
39d5 32 77 fb			ld (debug_mark),a  
39d8 3a e7 39			ld a, (.dmark+1)  
39db 32 78 fb			ld (debug_mark+1),a  
39de 3a e8 39			ld a, (.dmark+2)  
39e1 32 79 fb			ld (debug_mark+2),a  
39e4 18 03			jr .pastdmark  
39e6 ..			.dmark: db "RNd"  
39e9 f1			.pastdmark: pop af  
39ea			endm  
# End of macro DMARK
39ea						CALLMONITOR 
39ea cd 49 17			call break_point_state  
39ed				endm  
# End of macro CALLMONITOR
39ed					endif 
39ed			 
39ed			 
39ed cd d9 1c				call forth_push_numhl 
39f0				       NEXTW 
39f0 c3 42 20			jp macro_next 
39f3				endm 
# End of macro NEXTW
39f3			 
39f3			.ENDMATHS: 
39f3			 
39f3			; eof 
39f3			 
# End of file forth_words_maths.asm
39f3			include "forth_words_display.asm" 
39f3			 
39f3			; | ## Display Words 
39f3			 
39f3			.ATP: 
39f3				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
39f3 62				db WORD_SYS_CORE+78             
39f4 6a 3a			dw .FB            
39f6 04				db 3 + 1 
39f7 .. 00			db "AT?",0              
39fb				endm 
# End of macro CWHEAD
39fb			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
39fb					if DEBUG_FORTH_WORDS_KEY 
39fb						DMARK "AT?" 
39fb f5				push af  
39fc 3a 10 3a			ld a, (.dmark)  
39ff 32 77 fb			ld (debug_mark),a  
3a02 3a 11 3a			ld a, (.dmark+1)  
3a05 32 78 fb			ld (debug_mark+1),a  
3a08 3a 12 3a			ld a, (.dmark+2)  
3a0b 32 79 fb			ld (debug_mark+2),a  
3a0e 18 03			jr .pastdmark  
3a10 ..			.dmark: db "AT?"  
3a13 f1			.pastdmark: pop af  
3a14			endm  
# End of macro DMARK
3a14						CALLMONITOR 
3a14 cd 49 17			call break_point_state  
3a17				endm  
# End of macro CALLMONITOR
3a17					endif 
3a17 3a 46 f8				ld a, (f_cursor_ptr) 
3a1a			 
3a1a			if DEBUG_FORTH_WORDS 
3a1a				DMARK "AT?" 
3a1a f5				push af  
3a1b 3a 2f 3a			ld a, (.dmark)  
3a1e 32 77 fb			ld (debug_mark),a  
3a21 3a 30 3a			ld a, (.dmark+1)  
3a24 32 78 fb			ld (debug_mark+1),a  
3a27 3a 31 3a			ld a, (.dmark+2)  
3a2a 32 79 fb			ld (debug_mark+2),a  
3a2d 18 03			jr .pastdmark  
3a2f ..			.dmark: db "AT?"  
3a32 f1			.pastdmark: pop af  
3a33			endm  
# End of macro DMARK
3a33				CALLMONITOR 
3a33 cd 49 17			call break_point_state  
3a36				endm  
# End of macro CALLMONITOR
3a36			endif	 
3a36					; count the number of rows 
3a36			 
3a36 06 00				ld b, 0 
3a38 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a39 d6 28				sub display_cols 
3a3b f2 41 3a				jp p, .atprunder 
3a3e 04					inc b 
3a3f 18 f7				jr .atpr 
3a41			.atprunder:	 
3a41			if DEBUG_FORTH_WORDS 
3a41				DMARK "A?2" 
3a41 f5				push af  
3a42 3a 56 3a			ld a, (.dmark)  
3a45 32 77 fb			ld (debug_mark),a  
3a48 3a 57 3a			ld a, (.dmark+1)  
3a4b 32 78 fb			ld (debug_mark+1),a  
3a4e 3a 58 3a			ld a, (.dmark+2)  
3a51 32 79 fb			ld (debug_mark+2),a  
3a54 18 03			jr .pastdmark  
3a56 ..			.dmark: db "A?2"  
3a59 f1			.pastdmark: pop af  
3a5a			endm  
# End of macro DMARK
3a5a				CALLMONITOR 
3a5a cd 49 17			call break_point_state  
3a5d				endm  
# End of macro CALLMONITOR
3a5d			endif	 
3a5d 26 00				ld h, 0 
3a5f 69					ld l, c 
3a60 cd d9 1c				call forth_push_numhl 
3a63 68					ld l, b  
3a64 cd d9 1c				call forth_push_numhl 
3a67			 
3a67			 
3a67				NEXTW 
3a67 c3 42 20			jp macro_next 
3a6a				endm 
# End of macro NEXTW
3a6a			 
3a6a			.FB: 
3a6a				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3a6a 1b				db WORD_SYS_CORE+7             
3a6b b8 3a			dw .EMIT            
3a6d 03				db 2 + 1 
3a6e .. 00			db "FB",0              
3a71				endm 
# End of macro CWHEAD
3a71			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a71			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a71			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a71			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a71					if DEBUG_FORTH_WORDS_KEY 
3a71						DMARK "FB." 
3a71 f5				push af  
3a72 3a 86 3a			ld a, (.dmark)  
3a75 32 77 fb			ld (debug_mark),a  
3a78 3a 87 3a			ld a, (.dmark+1)  
3a7b 32 78 fb			ld (debug_mark+1),a  
3a7e 3a 88 3a			ld a, (.dmark+2)  
3a81 32 79 fb			ld (debug_mark+2),a  
3a84 18 03			jr .pastdmark  
3a86 ..			.dmark: db "FB."  
3a89 f1			.pastdmark: pop af  
3a8a			endm  
# End of macro DMARK
3a8a						CALLMONITOR 
3a8a cd 49 17			call break_point_state  
3a8d				endm  
# End of macro CALLMONITOR
3a8d					endif 
3a8d			 
3a8d					FORTH_DSP_VALUEHL 
3a8d cd d0 1e			call macro_dsp_valuehl 
3a90				endm 
# End of macro FORTH_DSP_VALUEHL
3a90			 
3a90 7d					ld a, l 
3a91 fe 01				cp 1 
3a93 20 05				jr nz, .fbn1 
3a95 21 1c fa				ld hl, display_fb1 
3a98 18 15				jr .fbset 
3a9a fe 02		.fbn1:		cp 2 
3a9c 20 05				jr nz, .fbn2 
3a9e 21 da f8				ld hl, display_fb2 
3aa1 18 0c				jr .fbset 
3aa3 fe 03		.fbn2:		cp 3 
3aa5 20 05				jr nz, .fbn3 
3aa7 21 7b f9				ld hl, display_fb3 
3aaa 18 03				jr .fbset 
3aac			.fbn3:		 ; if invalid number select first 
3aac 21 1c fa				ld hl, display_fb1 
3aaf 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3ab2			 
3ab2					FORTH_DSP_POP 
3ab2 cd 88 1f			call macro_forth_dsp_pop 
3ab5				endm 
# End of macro FORTH_DSP_POP
3ab5			 
3ab5					NEXTW 
3ab5 c3 42 20			jp macro_next 
3ab8				endm 
# End of macro NEXTW
3ab8			 
3ab8			 
3ab8			.EMIT: 
3ab8				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ab8 1b				db WORD_SYS_CORE+7             
3ab9 09 3b			dw .DOTH            
3abb 05				db 4 + 1 
3abc .. 00			db "EMIT",0              
3ac1				endm 
# End of macro CWHEAD
3ac1			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3ac1					; get value off TOS and display it 
3ac1			 
3ac1					if DEBUG_FORTH_WORDS_KEY 
3ac1						DMARK "EMT" 
3ac1 f5				push af  
3ac2 3a d6 3a			ld a, (.dmark)  
3ac5 32 77 fb			ld (debug_mark),a  
3ac8 3a d7 3a			ld a, (.dmark+1)  
3acb 32 78 fb			ld (debug_mark+1),a  
3ace 3a d8 3a			ld a, (.dmark+2)  
3ad1 32 79 fb			ld (debug_mark+2),a  
3ad4 18 03			jr .pastdmark  
3ad6 ..			.dmark: db "EMT"  
3ad9 f1			.pastdmark: pop af  
3ada			endm  
# End of macro DMARK
3ada						CALLMONITOR 
3ada cd 49 17			call break_point_state  
3add				endm  
# End of macro CALLMONITOR
3add					endif 
3add			 
3add					FORTH_DSP_VALUEHL 
3add cd d0 1e			call macro_dsp_valuehl 
3ae0				endm 
# End of macro FORTH_DSP_VALUEHL
3ae0			 
3ae0 7d					ld a,l 
3ae1			 
3ae1					; TODO write to display 
3ae1			 
3ae1 32 1b f0				ld (os_input), a 
3ae4 3e 00				ld a, 0 
3ae6 32 1c f0				ld (os_input+1), a 
3ae9					 
3ae9 3a 46 f8				ld a, (f_cursor_ptr) 
3aec 11 1b f0				ld de, os_input 
3aef cd eb 0a				call str_at_display 
3af2			 
3af2			 
3af2 3a 24 f8				ld a,(cli_autodisplay) 
3af5 fe 00				cp 0 
3af7 28 03				jr z, .enoupdate 
3af9 cd fb 0a						call update_display 
3afc					.enoupdate: 
3afc			 
3afc 3a 46 f8				ld a, (f_cursor_ptr) 
3aff 3c					inc a 
3b00 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3b03			 
3b03			 
3b03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b03 cd 88 1f			call macro_forth_dsp_pop 
3b06				endm 
# End of macro FORTH_DSP_POP
3b06			  
3b06			 
3b06					NEXTW 
3b06 c3 42 20			jp macro_next 
3b09				endm 
# End of macro NEXTW
3b09			.DOTH: 
3b09				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b09 1c				db WORD_SYS_CORE+8             
3b0a 39 3b			dw .DOTF            
3b0c 03				db 2 + 1 
3b0d .. 00			db ".-",0              
3b10				endm 
# End of macro CWHEAD
3b10			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b10					; get value off TOS and display it 
3b10					if DEBUG_FORTH_WORDS_KEY 
3b10						DMARK "DTD" 
3b10 f5				push af  
3b11 3a 25 3b			ld a, (.dmark)  
3b14 32 77 fb			ld (debug_mark),a  
3b17 3a 26 3b			ld a, (.dmark+1)  
3b1a 32 78 fb			ld (debug_mark+1),a  
3b1d 3a 27 3b			ld a, (.dmark+2)  
3b20 32 79 fb			ld (debug_mark+2),a  
3b23 18 03			jr .pastdmark  
3b25 ..			.dmark: db "DTD"  
3b28 f1			.pastdmark: pop af  
3b29			endm  
# End of macro DMARK
3b29						CALLMONITOR 
3b29 cd 49 17			call break_point_state  
3b2c				endm  
# End of macro CALLMONITOR
3b2c					endif 
3b2c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b2e 3e 00			ld a, 0 
3b30 32 25 f8			ld (cli_mvdot), a 
3b33 c3 90 3b			jp .dotgo 
3b36				NEXTW 
3b36 c3 42 20			jp macro_next 
3b39				endm 
# End of macro NEXTW
3b39			.DOTF: 
3b39				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b39 1c				db WORD_SYS_CORE+8             
3b3a 67 3b			dw .DOT            
3b3c 03				db 2 + 1 
3b3d .. 00			db ".>",0              
3b40				endm 
# End of macro CWHEAD
3b40			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b40					; get value off TOS and display it 
3b40			        ; TODO BUG adds extra spaces 
3b40			        ; TODO BUG handle numerics? 
3b40					if DEBUG_FORTH_WORDS_KEY 
3b40						DMARK "DTC" 
3b40 f5				push af  
3b41 3a 55 3b			ld a, (.dmark)  
3b44 32 77 fb			ld (debug_mark),a  
3b47 3a 56 3b			ld a, (.dmark+1)  
3b4a 32 78 fb			ld (debug_mark+1),a  
3b4d 3a 57 3b			ld a, (.dmark+2)  
3b50 32 79 fb			ld (debug_mark+2),a  
3b53 18 03			jr .pastdmark  
3b55 ..			.dmark: db "DTC"  
3b58 f1			.pastdmark: pop af  
3b59			endm  
# End of macro DMARK
3b59						CALLMONITOR 
3b59 cd 49 17			call break_point_state  
3b5c				endm  
# End of macro CALLMONITOR
3b5c					endif 
3b5c 3e 01			ld a, 1 
3b5e 32 25 f8			ld (cli_mvdot), a 
3b61 c3 90 3b			jp .dotgo 
3b64				NEXTW 
3b64 c3 42 20			jp macro_next 
3b67				endm 
# End of macro NEXTW
3b67			 
3b67			.DOT: 
3b67				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3b67 1c				db WORD_SYS_CORE+8             
3b68 f3 3b			dw .CLS            
3b6a 02				db 1 + 1 
3b6b .. 00			db ".",0              
3b6d				endm 
# End of macro CWHEAD
3b6d			        ; | . ( u -- ) Display TOS | DONE 
3b6d					; get value off TOS and display it 
3b6d			 
3b6d					if DEBUG_FORTH_WORDS_KEY 
3b6d						DMARK "DOT" 
3b6d f5				push af  
3b6e 3a 82 3b			ld a, (.dmark)  
3b71 32 77 fb			ld (debug_mark),a  
3b74 3a 83 3b			ld a, (.dmark+1)  
3b77 32 78 fb			ld (debug_mark+1),a  
3b7a 3a 84 3b			ld a, (.dmark+2)  
3b7d 32 79 fb			ld (debug_mark+2),a  
3b80 18 03			jr .pastdmark  
3b82 ..			.dmark: db "DOT"  
3b85 f1			.pastdmark: pop af  
3b86			endm  
# End of macro DMARK
3b86						CALLMONITOR 
3b86 cd 49 17			call break_point_state  
3b89				endm  
# End of macro CALLMONITOR
3b89					endif 
3b89 3e 00			ld a, 0 
3b8b 32 25 f8			ld (cli_mvdot), a 
3b8e 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b90				 
3b90			 
3b90			.dotgo: 
3b90			 
3b90			; move up type to on stack for parserv5 
3b90					FORTH_DSP 
3b90 cd 96 1e			call macro_forth_dsp 
3b93				endm 
# End of macro FORTH_DSP
3b93				;FORTH_DSP_VALUE  
3b93			 
3b93			if DEBUG_FORTH_DOT 
3b93				DMARK "DOT" 
3b93				CALLMONITOR 
3b93			endif	 
3b93			;		.print: 
3b93			 
3b93 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b94 23				inc hl   ; position to the actual value 
3b95 fe 01			cp DS_TYPE_STR 
3b97 20 06			jr nz, .dotnum1  
3b99			 
3b99			; display string 
3b99				FORTH_DSP_VALUE  
3b99 cd b9 1e			call macro_forth_dsp_value 
3b9c				endm 
# End of macro FORTH_DSP_VALUE
3b9c eb				ex de,hl 
3b9d 18 11			jr .dotwrite 
3b9f			 
3b9f			.dotnum1: 
3b9f fe 02			cp DS_TYPE_INUM 
3ba1 20 0c			jr nz, .dotflot 
3ba3			 
3ba3			 
3ba3			; display number 
3ba3			 
3ba3			;	push hl 
3ba3			;	call clear_display 
3ba3			;	pop hl 
3ba3			 
3ba3 5e				ld e, (hl) 
3ba4 23				inc hl 
3ba5 56				ld d, (hl) 
3ba6 21 1d ee			ld hl, scratch 
3ba9			if DEBUG_FORTH_DOT 
3ba9				DMARK "DT1" 
3ba9				CALLMONITOR 
3ba9			endif	 
3ba9			 
3ba9 cd 19 11			call uitoa_16 
3bac eb				ex de,hl 
3bad			 
3bad			if DEBUG_FORTH_DOT 
3bad				DMARK "DT2" 
3bad				CALLMONITOR 
3bad			endif	 
3bad			 
3bad			;	ld de, os_word_scratch 
3bad 18 01			jr .dotwrite 
3baf			 
3baf 00			.dotflot:   nop 
3bb0			; TODO print floating point number 
3bb0			 
3bb0			.dotwrite:		 
3bb0			 
3bb0					; if c is set then set all '-' to spaces 
3bb0					; need to also take into account .>  
3bb0			 
3bb0 3e 01				ld a, 1 
3bb2 b9					cp c 
3bb3 20 13				jr nz, .nodashswap 
3bb5			 
3bb5					; DE has the string to write, working with HL 
3bb5			 
3bb5 06 ff				ld b, 255 
3bb7 d5					push de 
3bb8 e1					pop hl 
3bb9			 
3bb9			if DEBUG_FORTH_DOT 
3bb9				DMARK "DT-" 
3bb9				CALLMONITOR 
3bb9			endif	 
3bb9 7e			.dashscan:	ld a, (hl) 
3bba fe 00				cp 0 
3bbc 28 0a				jr z, .nodashswap 
3bbe fe 2d				cp '-' 
3bc0 20 03				jr nz, .dashskip 
3bc2 3e 20				ld a, ' ' 
3bc4 77					ld (hl), a 
3bc5 23			.dashskip:	inc hl 
3bc6			if DEBUG_FORTH_DOT 
3bc6				DMARK "D-2" 
3bc6				CALLMONITOR 
3bc6			endif	 
3bc6 10 f1				djnz .dashscan 
3bc8			 
3bc8			if DEBUG_FORTH_DOT 
3bc8				DMARK "D-1" 
3bc8				CALLMONITOR 
3bc8			endif	 
3bc8			 
3bc8			.nodashswap: 
3bc8			 
3bc8 e5					push hl   ; save string start in case we need to advance print 
3bc9			 
3bc9 3a 46 f8				ld a, (f_cursor_ptr) 
3bcc cd eb 0a				call str_at_display 
3bcf 3a 24 f8				ld a,(cli_autodisplay) 
3bd2 fe 00				cp 0 
3bd4 28 03				jr z, .noupdate 
3bd6 cd fb 0a						call update_display 
3bd9					.noupdate: 
3bd9			 
3bd9			 
3bd9					; see if we need to advance the print position 
3bd9			 
3bd9 e1					pop hl   ; get back string 
3bda			 
3bda 3a 25 f8				ld a, (cli_mvdot) 
3bdd			if DEBUG_FORTH_DOT 
3bdd					ld e,a 
3bdd				DMARK "D>1" 
3bdd				CALLMONITOR 
3bdd			endif	 
3bdd fe 00				cp 0 
3bdf 28 0c				jr z, .noadv 
3be1					; yes, lets advance the print position 
3be1 3e 00				ld a, 0 
3be3 cd 75 11				call strlent 
3be6 3a 46 f8				ld a, (f_cursor_ptr) 
3be9 85					add a,l 
3bea					;call addatohl 
3bea					;ld a, l 
3bea 32 46 f8				ld (f_cursor_ptr), a   ; save new pos 
3bed			 
3bed			if DEBUG_FORTH_DOT 
3bed				DMARK "D->" 
3bed				CALLMONITOR 
3bed			endif	 
3bed			 
3bed			.noadv:	 
3bed			 
3bed					if DEBUG_FORTH_DOT_WAIT 
3bed							call next_page_prompt 
3bed					endif	 
3bed			; TODO this pop off the stack causes a crash. i dont know why 
3bed			 
3bed			 
3bed			if DEBUG_FORTH_DOT 
3bed				DMARK "DTh" 
3bed				CALLMONITOR 
3bed			endif	 
3bed			 
3bed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bed cd 88 1f			call macro_forth_dsp_pop 
3bf0				endm 
# End of macro FORTH_DSP_POP
3bf0			 
3bf0			if DEBUG_FORTH_DOT 
3bf0				DMARK "DTi" 
3bf0				CALLMONITOR 
3bf0			endif	 
3bf0			 
3bf0			 
3bf0					NEXTW 
3bf0 c3 42 20			jp macro_next 
3bf3				endm 
# End of macro NEXTW
3bf3			 
3bf3			.CLS: 
3bf3				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3bf3 35				db WORD_SYS_CORE+33             
3bf4 20 3c			dw .DRAW            
3bf6 04				db 3 + 1 
3bf7 .. 00			db "CLS",0              
3bfb				endm 
# End of macro CWHEAD
3bfb			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3bfb					if DEBUG_FORTH_WORDS_KEY 
3bfb						DMARK "CLS" 
3bfb f5				push af  
3bfc 3a 10 3c			ld a, (.dmark)  
3bff 32 77 fb			ld (debug_mark),a  
3c02 3a 11 3c			ld a, (.dmark+1)  
3c05 32 78 fb			ld (debug_mark+1),a  
3c08 3a 12 3c			ld a, (.dmark+2)  
3c0b 32 79 fb			ld (debug_mark+2),a  
3c0e 18 03			jr .pastdmark  
3c10 ..			.dmark: db "CLS"  
3c13 f1			.pastdmark: pop af  
3c14			endm  
# End of macro DMARK
3c14						CALLMONITOR 
3c14 cd 49 17			call break_point_state  
3c17				endm  
# End of macro CALLMONITOR
3c17					endif 
3c17 cd d8 0a				call clear_display 
3c1a c3 2e 3d				jp .home		; and home cursor 
3c1d					NEXTW 
3c1d c3 42 20			jp macro_next 
3c20				endm 
# End of macro NEXTW
3c20			 
3c20			.DRAW: 
3c20				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c20 36				db WORD_SYS_CORE+34             
3c21 4b 3c			dw .DUMP            
3c23 05				db 4 + 1 
3c24 .. 00			db "DRAW",0              
3c29				endm 
# End of macro CWHEAD
3c29			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c29					if DEBUG_FORTH_WORDS_KEY 
3c29						DMARK "DRW" 
3c29 f5				push af  
3c2a 3a 3e 3c			ld a, (.dmark)  
3c2d 32 77 fb			ld (debug_mark),a  
3c30 3a 3f 3c			ld a, (.dmark+1)  
3c33 32 78 fb			ld (debug_mark+1),a  
3c36 3a 40 3c			ld a, (.dmark+2)  
3c39 32 79 fb			ld (debug_mark+2),a  
3c3c 18 03			jr .pastdmark  
3c3e ..			.dmark: db "DRW"  
3c41 f1			.pastdmark: pop af  
3c42			endm  
# End of macro DMARK
3c42						CALLMONITOR 
3c42 cd 49 17			call break_point_state  
3c45				endm  
# End of macro CALLMONITOR
3c45					endif 
3c45 cd fb 0a				call update_display 
3c48					NEXTW 
3c48 c3 42 20			jp macro_next 
3c4b				endm 
# End of macro NEXTW
3c4b			 
3c4b			.DUMP: 
3c4b				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c4b 37				db WORD_SYS_CORE+35             
3c4c 83 3c			dw .CDUMP            
3c4e 05				db 4 + 1 
3c4f .. 00			db "DUMP",0              
3c54				endm 
# End of macro CWHEAD
3c54			; | DUMP ( x -- ) With address x display dump   | DONE 
3c54			; TODO pop address to use off of the stack 
3c54					if DEBUG_FORTH_WORDS_KEY 
3c54						DMARK "DUM" 
3c54 f5				push af  
3c55 3a 69 3c			ld a, (.dmark)  
3c58 32 77 fb			ld (debug_mark),a  
3c5b 3a 6a 3c			ld a, (.dmark+1)  
3c5e 32 78 fb			ld (debug_mark+1),a  
3c61 3a 6b 3c			ld a, (.dmark+2)  
3c64 32 79 fb			ld (debug_mark+2),a  
3c67 18 03			jr .pastdmark  
3c69 ..			.dmark: db "DUM"  
3c6c f1			.pastdmark: pop af  
3c6d			endm  
# End of macro DMARK
3c6d						CALLMONITOR 
3c6d cd 49 17			call break_point_state  
3c70				endm  
# End of macro CALLMONITOR
3c70					endif 
3c70 cd d8 0a				call clear_display 
3c73			 
3c73					; get address 
3c73			 
3c73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c73 cd d0 1e			call macro_dsp_valuehl 
3c76				endm 
# End of macro FORTH_DSP_VALUEHL
3c76				 
3c76					; save it for cdump 
3c76			 
3c76 22 40 f1				ld (os_cur_ptr),hl 
3c79			 
3c79					; destroy value TOS 
3c79			 
3c79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c79 cd 88 1f			call macro_forth_dsp_pop 
3c7c				endm 
# End of macro FORTH_DSP_POP
3c7c			 
3c7c cd 59 1b				call dumpcont	; skip old style of param parsing	 
3c7f c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c80					NEXTW 
3c80 c3 42 20			jp macro_next 
3c83				endm 
# End of macro NEXTW
3c83			.CDUMP: 
3c83				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c83 38				db WORD_SYS_CORE+36             
3c84 b3 3c			dw .DAT            
3c86 06				db 5 + 1 
3c87 .. 00			db "CDUMP",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c8d					if DEBUG_FORTH_WORDS_KEY 
3c8d						DMARK "CDP" 
3c8d f5				push af  
3c8e 3a a2 3c			ld a, (.dmark)  
3c91 32 77 fb			ld (debug_mark),a  
3c94 3a a3 3c			ld a, (.dmark+1)  
3c97 32 78 fb			ld (debug_mark+1),a  
3c9a 3a a4 3c			ld a, (.dmark+2)  
3c9d 32 79 fb			ld (debug_mark+2),a  
3ca0 18 03			jr .pastdmark  
3ca2 ..			.dmark: db "CDP"  
3ca5 f1			.pastdmark: pop af  
3ca6			endm  
# End of macro DMARK
3ca6						CALLMONITOR 
3ca6 cd 49 17			call break_point_state  
3ca9				endm  
# End of macro CALLMONITOR
3ca9					endif 
3ca9 cd d8 0a				call clear_display 
3cac cd 59 1b				call dumpcont	 
3caf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3cb0					NEXTW 
3cb0 c3 42 20			jp macro_next 
3cb3				endm 
# End of macro NEXTW
3cb3			 
3cb3			 
3cb3			 
3cb3			 
3cb3			.DAT: 
3cb3				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cb3 3d				db WORD_SYS_CORE+41             
3cb4 09 3d			dw .HOME            
3cb6 03				db 2 + 1 
3cb7 .. 00			db "AT",0              
3cba				endm 
# End of macro CWHEAD
3cba			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cba					if DEBUG_FORTH_WORDS_KEY 
3cba						DMARK "AT." 
3cba f5				push af  
3cbb 3a cf 3c			ld a, (.dmark)  
3cbe 32 77 fb			ld (debug_mark),a  
3cc1 3a d0 3c			ld a, (.dmark+1)  
3cc4 32 78 fb			ld (debug_mark+1),a  
3cc7 3a d1 3c			ld a, (.dmark+2)  
3cca 32 79 fb			ld (debug_mark+2),a  
3ccd 18 03			jr .pastdmark  
3ccf ..			.dmark: db "AT."  
3cd2 f1			.pastdmark: pop af  
3cd3			endm  
# End of macro DMARK
3cd3						CALLMONITOR 
3cd3 cd 49 17			call break_point_state  
3cd6				endm  
# End of macro CALLMONITOR
3cd6					endif 
3cd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd6 cd d0 1e			call macro_dsp_valuehl 
3cd9				endm 
# End of macro FORTH_DSP_VALUEHL
3cd9			 
3cd9			 
3cd9					; TODO save cursor row 
3cd9 7d					ld a,l 
3cda fe 02				cp 2 
3cdc 20 04				jr nz, .crow3 
3cde 3e 28				ld a, display_row_2 
3ce0 18 12				jr .ccol1 
3ce2 fe 03		.crow3:		cp 3 
3ce4 20 04				jr nz, .crow4 
3ce6 3e 50				ld a, display_row_3 
3ce8 18 0a				jr .ccol1 
3cea fe 04		.crow4:		cp 4 
3cec 20 04				jr nz, .crow1 
3cee 3e 78				ld a, display_row_4 
3cf0 18 02				jr .ccol1 
3cf2 3e 00		.crow1:		ld a,display_row_1 
3cf4 f5			.ccol1:		push af			; got row offset 
3cf5 6f					ld l,a 
3cf6 26 00				ld h,0 
3cf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf8 cd 88 1f			call macro_forth_dsp_pop 
3cfb				endm 
# End of macro FORTH_DSP_POP
3cfb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cfb cd d0 1e			call macro_dsp_valuehl 
3cfe				endm 
# End of macro FORTH_DSP_VALUEHL
3cfe					; TODO save cursor col 
3cfe f1					pop af 
3cff 85					add l		; add col offset 
3d00 32 46 f8				ld (f_cursor_ptr), a 
3d03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d03 cd 88 1f			call macro_forth_dsp_pop 
3d06				endm 
# End of macro FORTH_DSP_POP
3d06			 
3d06					; calculate  
3d06			 
3d06					NEXTW 
3d06 c3 42 20			jp macro_next 
3d09				endm 
# End of macro NEXTW
3d09			 
3d09			 
3d09			.HOME: 
3d09				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d09 41				db WORD_SYS_CORE+45             
3d0a 36 3d			dw .SPACE            
3d0c 05				db 4 + 1 
3d0d .. 00			db "HOME",0              
3d12				endm 
# End of macro CWHEAD
3d12			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d12					if DEBUG_FORTH_WORDS_KEY 
3d12						DMARK "HOM" 
3d12 f5				push af  
3d13 3a 27 3d			ld a, (.dmark)  
3d16 32 77 fb			ld (debug_mark),a  
3d19 3a 28 3d			ld a, (.dmark+1)  
3d1c 32 78 fb			ld (debug_mark+1),a  
3d1f 3a 29 3d			ld a, (.dmark+2)  
3d22 32 79 fb			ld (debug_mark+2),a  
3d25 18 03			jr .pastdmark  
3d27 ..			.dmark: db "HOM"  
3d2a f1			.pastdmark: pop af  
3d2b			endm  
# End of macro DMARK
3d2b						CALLMONITOR 
3d2b cd 49 17			call break_point_state  
3d2e				endm  
# End of macro CALLMONITOR
3d2e					endif 
3d2e 3e 00		.home:		ld a, 0		; and home cursor 
3d30 32 46 f8				ld (f_cursor_ptr), a 
3d33					NEXTW 
3d33 c3 42 20			jp macro_next 
3d36				endm 
# End of macro NEXTW
3d36			 
3d36			 
3d36			.SPACE: 
3d36				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d36 46				db WORD_SYS_CORE+50             
3d37 64 3d			dw .SPACES            
3d39 03				db 2 + 1 
3d3a .. 00			db "BL",0              
3d3d				endm 
# End of macro CWHEAD
3d3d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d3d					if DEBUG_FORTH_WORDS_KEY 
3d3d						DMARK "BL." 
3d3d f5				push af  
3d3e 3a 52 3d			ld a, (.dmark)  
3d41 32 77 fb			ld (debug_mark),a  
3d44 3a 53 3d			ld a, (.dmark+1)  
3d47 32 78 fb			ld (debug_mark+1),a  
3d4a 3a 54 3d			ld a, (.dmark+2)  
3d4d 32 79 fb			ld (debug_mark+2),a  
3d50 18 03			jr .pastdmark  
3d52 ..			.dmark: db "BL."  
3d55 f1			.pastdmark: pop af  
3d56			endm  
# End of macro DMARK
3d56						CALLMONITOR 
3d56 cd 49 17			call break_point_state  
3d59				endm  
# End of macro CALLMONITOR
3d59					endif 
3d59 21 62 3d				ld hl, .blstr 
3d5c cd 47 1d				call forth_push_str 
3d5f					 
3d5f				       NEXTW 
3d5f c3 42 20			jp macro_next 
3d62				endm 
# End of macro NEXTW
3d62			 
3d62 .. 00		.blstr: db " ", 0 
3d64			 
3d64			.SPACES: 
3d64				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d64 47				db WORD_SYS_CORE+51             
3d65 ff 3d			dw .SCROLL            
3d67 07				db 6 + 1 
3d68 .. 00			db "SPACES",0              
3d6f				endm 
# End of macro CWHEAD
3d6f			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d6f					if DEBUG_FORTH_WORDS_KEY 
3d6f						DMARK "SPS" 
3d6f f5				push af  
3d70 3a 84 3d			ld a, (.dmark)  
3d73 32 77 fb			ld (debug_mark),a  
3d76 3a 85 3d			ld a, (.dmark+1)  
3d79 32 78 fb			ld (debug_mark+1),a  
3d7c 3a 86 3d			ld a, (.dmark+2)  
3d7f 32 79 fb			ld (debug_mark+2),a  
3d82 18 03			jr .pastdmark  
3d84 ..			.dmark: db "SPS"  
3d87 f1			.pastdmark: pop af  
3d88			endm  
# End of macro DMARK
3d88						CALLMONITOR 
3d88 cd 49 17			call break_point_state  
3d8b				endm  
# End of macro CALLMONITOR
3d8b					endif 
3d8b			 
3d8b			 
3d8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8b cd d0 1e			call macro_dsp_valuehl 
3d8e				endm 
# End of macro FORTH_DSP_VALUEHL
3d8e			 
3d8e			;		push hl    ; u 
3d8e					if DEBUG_FORTH_WORDS 
3d8e						DMARK "SPA" 
3d8e f5				push af  
3d8f 3a a3 3d			ld a, (.dmark)  
3d92 32 77 fb			ld (debug_mark),a  
3d95 3a a4 3d			ld a, (.dmark+1)  
3d98 32 78 fb			ld (debug_mark+1),a  
3d9b 3a a5 3d			ld a, (.dmark+2)  
3d9e 32 79 fb			ld (debug_mark+2),a  
3da1 18 03			jr .pastdmark  
3da3 ..			.dmark: db "SPA"  
3da6 f1			.pastdmark: pop af  
3da7			endm  
# End of macro DMARK
3da7						CALLMONITOR 
3da7 cd 49 17			call break_point_state  
3daa				endm  
# End of macro CALLMONITOR
3daa					endif 
3daa			 
3daa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3daa cd 88 1f			call macro_forth_dsp_pop 
3dad				endm 
# End of macro FORTH_DSP_POP
3dad			;		pop hl 
3dad 4d					ld c, l 
3dae 06 00				ld b, 0 
3db0 21 1d ee				ld hl, scratch  
3db3			 
3db3					if DEBUG_FORTH_WORDS 
3db3						DMARK "SP2" 
3db3 f5				push af  
3db4 3a c8 3d			ld a, (.dmark)  
3db7 32 77 fb			ld (debug_mark),a  
3dba 3a c9 3d			ld a, (.dmark+1)  
3dbd 32 78 fb			ld (debug_mark+1),a  
3dc0 3a ca 3d			ld a, (.dmark+2)  
3dc3 32 79 fb			ld (debug_mark+2),a  
3dc6 18 03			jr .pastdmark  
3dc8 ..			.dmark: db "SP2"  
3dcb f1			.pastdmark: pop af  
3dcc			endm  
# End of macro DMARK
3dcc						CALLMONITOR 
3dcc cd 49 17			call break_point_state  
3dcf				endm  
# End of macro CALLMONITOR
3dcf					endif 
3dcf 3e 20				ld a, ' ' 
3dd1 c5			.spaces1:	push bc 
3dd2 77					ld (hl),a 
3dd3 23					inc hl 
3dd4 c1					pop bc 
3dd5 10 fa				djnz .spaces1 
3dd7 3e 00				ld a,0 
3dd9 77					ld (hl),a 
3dda 21 1d ee				ld hl, scratch 
3ddd					if DEBUG_FORTH_WORDS 
3ddd						DMARK "SP3" 
3ddd f5				push af  
3dde 3a f2 3d			ld a, (.dmark)  
3de1 32 77 fb			ld (debug_mark),a  
3de4 3a f3 3d			ld a, (.dmark+1)  
3de7 32 78 fb			ld (debug_mark+1),a  
3dea 3a f4 3d			ld a, (.dmark+2)  
3ded 32 79 fb			ld (debug_mark+2),a  
3df0 18 03			jr .pastdmark  
3df2 ..			.dmark: db "SP3"  
3df5 f1			.pastdmark: pop af  
3df6			endm  
# End of macro DMARK
3df6						CALLMONITOR 
3df6 cd 49 17			call break_point_state  
3df9				endm  
# End of macro CALLMONITOR
3df9					endif 
3df9 cd 42 1e				call forth_apush 
3dfc			 
3dfc				       NEXTW 
3dfc c3 42 20			jp macro_next 
3dff				endm 
# End of macro NEXTW
3dff			 
3dff			 
3dff			 
3dff			.SCROLL: 
3dff				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3dff 53				db WORD_SYS_CORE+63             
3e00 2c 3e			dw .SCROLLD            
3e02 07				db 6 + 1 
3e03 .. 00			db "SCROLL",0              
3e0a				endm 
# End of macro CWHEAD
3e0a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e0a					if DEBUG_FORTH_WORDS_KEY 
3e0a						DMARK "SCR" 
3e0a f5				push af  
3e0b 3a 1f 3e			ld a, (.dmark)  
3e0e 32 77 fb			ld (debug_mark),a  
3e11 3a 20 3e			ld a, (.dmark+1)  
3e14 32 78 fb			ld (debug_mark+1),a  
3e17 3a 21 3e			ld a, (.dmark+2)  
3e1a 32 79 fb			ld (debug_mark+2),a  
3e1d 18 03			jr .pastdmark  
3e1f ..			.dmark: db "SCR"  
3e22 f1			.pastdmark: pop af  
3e23			endm  
# End of macro DMARK
3e23						CALLMONITOR 
3e23 cd 49 17			call break_point_state  
3e26				endm  
# End of macro CALLMONITOR
3e26					endif 
3e26			 
3e26 cd 9a 0a			call scroll_up 
3e29			;	call update_display 
3e29			 
3e29					NEXTW 
3e29 c3 42 20			jp macro_next 
3e2c				endm 
# End of macro NEXTW
3e2c			 
3e2c			 
3e2c			 
3e2c			;		; get dir 
3e2c			; 
3e2c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e2c			; 
3e2c			;		push hl 
3e2c			; 
3e2c			;		; destroy value TOS 
3e2c			; 
3e2c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e2c			; 
3e2c			;		; get count 
3e2c			; 
3e2c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e2c			; 
3e2c			;		push hl 
3e2c			; 
3e2c			;		; destroy value TOS 
3e2c			; 
3e2c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e2c			; 
3e2c			;		; one value on hl get other one back 
3e2c			; 
3e2c			;		pop bc    ; count 
3e2c			; 
3e2c			;		pop de   ; dir 
3e2c			; 
3e2c			; 
3e2c			;		ld b, c 
3e2c			; 
3e2c			;.scrolldir:     push bc 
3e2c			;		push de 
3e2c			; 
3e2c			;		ld a, 0 
3e2c			;		cp e 
3e2c			;		jr z, .scrollup  
3e2c			;		call scroll_down 
3e2c			;		jr .scrollnext 
3e2c			;.scrollup:	call scroll_up 
3e2c			; 
3e2c			;		 
3e2c			;.scrollnext: 
3e2c			;		pop de 
3e2c			;		pop bc 
3e2c			;		djnz .scrolldir 
3e2c			; 
3e2c			; 
3e2c			; 
3e2c			; 
3e2c			; 
3e2c			;		NEXTW 
3e2c			 
3e2c			.SCROLLD: 
3e2c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e2c 53				db WORD_SYS_CORE+63             
3e2d 5a 3e			dw .ATQ            
3e2f 08				db 7 + 1 
3e30 .. 00			db "SCROLLD",0              
3e38				endm 
# End of macro CWHEAD
3e38			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e38					if DEBUG_FORTH_WORDS_KEY 
3e38						DMARK "SCD" 
3e38 f5				push af  
3e39 3a 4d 3e			ld a, (.dmark)  
3e3c 32 77 fb			ld (debug_mark),a  
3e3f 3a 4e 3e			ld a, (.dmark+1)  
3e42 32 78 fb			ld (debug_mark+1),a  
3e45 3a 4f 3e			ld a, (.dmark+2)  
3e48 32 79 fb			ld (debug_mark+2),a  
3e4b 18 03			jr .pastdmark  
3e4d ..			.dmark: db "SCD"  
3e50 f1			.pastdmark: pop af  
3e51			endm  
# End of macro DMARK
3e51						CALLMONITOR 
3e51 cd 49 17			call break_point_state  
3e54				endm  
# End of macro CALLMONITOR
3e54					endif 
3e54			 
3e54 cd be 0a			call scroll_down 
3e57			;	call update_display 
3e57			 
3e57					NEXTW 
3e57 c3 42 20			jp macro_next 
3e5a				endm 
# End of macro NEXTW
3e5a			 
3e5a			 
3e5a			.ATQ: 
3e5a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e5a 62				db WORD_SYS_CORE+78             
3e5b b8 3e			dw .AUTODSP            
3e5d 04				db 3 + 1 
3e5e .. 00			db "AT@",0              
3e62				endm 
# End of macro CWHEAD
3e62			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e62					if DEBUG_FORTH_WORDS_KEY 
3e62						DMARK "ATA" 
3e62 f5				push af  
3e63 3a 77 3e			ld a, (.dmark)  
3e66 32 77 fb			ld (debug_mark),a  
3e69 3a 78 3e			ld a, (.dmark+1)  
3e6c 32 78 fb			ld (debug_mark+1),a  
3e6f 3a 79 3e			ld a, (.dmark+2)  
3e72 32 79 fb			ld (debug_mark+2),a  
3e75 18 03			jr .pastdmark  
3e77 ..			.dmark: db "ATA"  
3e7a f1			.pastdmark: pop af  
3e7b			endm  
# End of macro DMARK
3e7b						CALLMONITOR 
3e7b cd 49 17			call break_point_state  
3e7e				endm  
# End of macro CALLMONITOR
3e7e					endif 
3e7e			 
3e7e			 
3e7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e7e cd d0 1e			call macro_dsp_valuehl 
3e81				endm 
# End of macro FORTH_DSP_VALUEHL
3e81			 
3e81					; TODO save cursor row 
3e81 7d					ld a,l 
3e82 fe 02				cp 2 
3e84 20 04				jr nz, .crow3aq 
3e86 3e 28				ld a, display_row_2 
3e88 18 12				jr .ccol1aq 
3e8a fe 03		.crow3aq:		cp 3 
3e8c 20 04				jr nz, .crow4aq 
3e8e 3e 50				ld a, display_row_3 
3e90 18 0a				jr .ccol1aq 
3e92 fe 04		.crow4aq:		cp 4 
3e94 20 04				jr nz, .crow1aq 
3e96 3e 78				ld a, display_row_4 
3e98 18 02				jr .ccol1aq 
3e9a 3e 00		.crow1aq:		ld a,display_row_1 
3e9c f5			.ccol1aq:		push af			; got row offset 
3e9d 6f					ld l,a 
3e9e 26 00				ld h,0 
3ea0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea0 cd 88 1f			call macro_forth_dsp_pop 
3ea3				endm 
# End of macro FORTH_DSP_POP
3ea3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea3 cd d0 1e			call macro_dsp_valuehl 
3ea6				endm 
# End of macro FORTH_DSP_VALUEHL
3ea6					; TODO save cursor col 
3ea6 f1					pop af 
3ea7 85					add l		; add col offset 
3ea8			 
3ea8					; add current frame buffer address 
3ea8 2a d8 f8				ld hl, (display_fb_active) 
3eab cd 0c 0d				call addatohl 
3eae			 
3eae			 
3eae			 
3eae			 
3eae					; get char frame buffer location offset in hl 
3eae			 
3eae 7e					ld a,(hl) 
3eaf 26 00				ld h, 0 
3eb1 6f					ld l, a 
3eb2			 
3eb2 cd d9 1c				call forth_push_numhl 
3eb5			 
3eb5			 
3eb5					NEXTW 
3eb5 c3 42 20			jp macro_next 
3eb8				endm 
# End of macro NEXTW
3eb8			 
3eb8			.AUTODSP: 
3eb8				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3eb8 63				db WORD_SYS_CORE+79             
3eb9 ce 3e			dw .MENU            
3ebb 05				db 4 + 1 
3ebc .. 00			db "ADSP",0              
3ec1				endm 
# End of macro CWHEAD
3ec1			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3ec1			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3ec1			 
3ec1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ec1 cd d0 1e			call macro_dsp_valuehl 
3ec4				endm 
# End of macro FORTH_DSP_VALUEHL
3ec4			 
3ec4			;		push hl 
3ec4			 
3ec4					; destroy value TOS 
3ec4			 
3ec4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec4 cd 88 1f			call macro_forth_dsp_pop 
3ec7				endm 
# End of macro FORTH_DSP_POP
3ec7			 
3ec7			;		pop hl 
3ec7			 
3ec7 7d					ld a,l 
3ec8 32 24 f8				ld (cli_autodisplay), a 
3ecb				       NEXTW 
3ecb c3 42 20			jp macro_next 
3ece				endm 
# End of macro NEXTW
3ece			 
3ece			.MENU: 
3ece				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3ece 70				db WORD_SYS_CORE+92             
3ecf 77 3f			dw .ENDDISPLAY            
3ed1 05				db 4 + 1 
3ed2 .. 00			db "MENU",0              
3ed7				endm 
# End of macro CWHEAD
3ed7			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3ed7			 
3ed7			;		; get number of items on the stack 
3ed7			; 
3ed7				 
3ed7					FORTH_DSP_VALUEHL 
3ed7 cd d0 1e			call macro_dsp_valuehl 
3eda				endm 
# End of macro FORTH_DSP_VALUEHL
3eda				 
3eda					if DEBUG_FORTH_WORDS_KEY 
3eda						DMARK "MNU" 
3eda f5				push af  
3edb 3a ef 3e			ld a, (.dmark)  
3ede 32 77 fb			ld (debug_mark),a  
3ee1 3a f0 3e			ld a, (.dmark+1)  
3ee4 32 78 fb			ld (debug_mark+1),a  
3ee7 3a f1 3e			ld a, (.dmark+2)  
3eea 32 79 fb			ld (debug_mark+2),a  
3eed 18 03			jr .pastdmark  
3eef ..			.dmark: db "MNU"  
3ef2 f1			.pastdmark: pop af  
3ef3			endm  
# End of macro DMARK
3ef3						CALLMONITOR 
3ef3 cd 49 17			call break_point_state  
3ef6				endm  
# End of macro CALLMONITOR
3ef6					endif 
3ef6			 
3ef6 45					ld b, l	 
3ef7 05					dec b 
3ef8			 
3ef8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ef8 cd 88 1f			call macro_forth_dsp_pop 
3efb				endm 
# End of macro FORTH_DSP_POP
3efb			 
3efb			 
3efb					; go directly through the stack to pluck out the string pointers and build an array 
3efb			 
3efb			;		FORTH_DSP 
3efb			 
3efb					; hl contains top most stack item 
3efb				 
3efb 11 1d ee				ld de, scratch 
3efe			 
3efe			.mbuild: 
3efe			 
3efe					FORTH_DSP_VALUEHL 
3efe cd d0 1e			call macro_dsp_valuehl 
3f01				endm 
# End of macro FORTH_DSP_VALUEHL
3f01			 
3f01					if DEBUG_FORTH_WORDS 
3f01						DMARK "MN3" 
3f01 f5				push af  
3f02 3a 16 3f			ld a, (.dmark)  
3f05 32 77 fb			ld (debug_mark),a  
3f08 3a 17 3f			ld a, (.dmark+1)  
3f0b 32 78 fb			ld (debug_mark+1),a  
3f0e 3a 18 3f			ld a, (.dmark+2)  
3f11 32 79 fb			ld (debug_mark+2),a  
3f14 18 03			jr .pastdmark  
3f16 ..			.dmark: db "MN3"  
3f19 f1			.pastdmark: pop af  
3f1a			endm  
# End of macro DMARK
3f1a						CALLMONITOR 
3f1a cd 49 17			call break_point_state  
3f1d				endm  
# End of macro CALLMONITOR
3f1d					endif 
3f1d eb					ex de, hl 
3f1e 73					ld (hl), e 
3f1f 23					inc hl 
3f20 72					ld (hl), d 
3f21 23					inc hl 
3f22 eb					ex de, hl 
3f23			 
3f23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f23 cd 88 1f			call macro_forth_dsp_pop 
3f26				endm 
# End of macro FORTH_DSP_POP
3f26			 
3f26 10 d6				djnz .mbuild 
3f28			 
3f28					; done add term 
3f28			 
3f28 eb					ex de, hl 
3f29 36 00				ld (hl), 0 
3f2b 23					inc hl 
3f2c 36 00				ld (hl), 0 
3f2e			 
3f2e				 
3f2e					 
3f2e 21 1d ee				ld hl, scratch 
3f31			 
3f31					if DEBUG_FORTH_WORDS 
3f31						DMARK "MNx" 
3f31 f5				push af  
3f32 3a 46 3f			ld a, (.dmark)  
3f35 32 77 fb			ld (debug_mark),a  
3f38 3a 47 3f			ld a, (.dmark+1)  
3f3b 32 78 fb			ld (debug_mark+1),a  
3f3e 3a 48 3f			ld a, (.dmark+2)  
3f41 32 79 fb			ld (debug_mark+2),a  
3f44 18 03			jr .pastdmark  
3f46 ..			.dmark: db "MNx"  
3f49 f1			.pastdmark: pop af  
3f4a			endm  
# End of macro DMARK
3f4a						CALLMONITOR 
3f4a cd 49 17			call break_point_state  
3f4d				endm  
# End of macro CALLMONITOR
3f4d					endif 
3f4d			 
3f4d			 
3f4d			 
3f4d 3e 00				ld a, 0 
3f4f cd 09 0b				call menu 
3f52			 
3f52			 
3f52 6f					ld l, a 
3f53 26 00				ld h, 0 
3f55			 
3f55					if DEBUG_FORTH_WORDS 
3f55						DMARK "MNr" 
3f55 f5				push af  
3f56 3a 6a 3f			ld a, (.dmark)  
3f59 32 77 fb			ld (debug_mark),a  
3f5c 3a 6b 3f			ld a, (.dmark+1)  
3f5f 32 78 fb			ld (debug_mark+1),a  
3f62 3a 6c 3f			ld a, (.dmark+2)  
3f65 32 79 fb			ld (debug_mark+2),a  
3f68 18 03			jr .pastdmark  
3f6a ..			.dmark: db "MNr"  
3f6d f1			.pastdmark: pop af  
3f6e			endm  
# End of macro DMARK
3f6e						CALLMONITOR 
3f6e cd 49 17			call break_point_state  
3f71				endm  
# End of macro CALLMONITOR
3f71					endif 
3f71			 
3f71 cd d9 1c				call forth_push_numhl 
3f74			 
3f74			 
3f74			 
3f74			 
3f74				       NEXTW 
3f74 c3 42 20			jp macro_next 
3f77				endm 
# End of macro NEXTW
3f77			 
3f77			 
3f77			.ENDDISPLAY: 
3f77			 
3f77			; eof 
# End of file forth_words_display.asm
3f77			include "forth_words_str.asm" 
3f77			 
3f77			; | ## String Words 
3f77			 
3f77			.PTR:   
3f77			 
3f77				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f77 48				db WORD_SYS_CORE+52             
3f78 a4 3f			dw .STYPE            
3f7a 04				db 3 + 1 
3f7b .. 00			db "PTR",0              
3f7f				endm 
# End of macro CWHEAD
3f7f			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f7f			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f7f			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f7f			 
3f7f					if DEBUG_FORTH_WORDS_KEY 
3f7f						DMARK "PTR" 
3f7f f5				push af  
3f80 3a 94 3f			ld a, (.dmark)  
3f83 32 77 fb			ld (debug_mark),a  
3f86 3a 95 3f			ld a, (.dmark+1)  
3f89 32 78 fb			ld (debug_mark+1),a  
3f8c 3a 96 3f			ld a, (.dmark+2)  
3f8f 32 79 fb			ld (debug_mark+2),a  
3f92 18 03			jr .pastdmark  
3f94 ..			.dmark: db "PTR"  
3f97 f1			.pastdmark: pop af  
3f98			endm  
# End of macro DMARK
3f98						CALLMONITOR 
3f98 cd 49 17			call break_point_state  
3f9b				endm  
# End of macro CALLMONITOR
3f9b					endif 
3f9b					FORTH_DSP_VALUEHL 
3f9b cd d0 1e			call macro_dsp_valuehl 
3f9e				endm 
# End of macro FORTH_DSP_VALUEHL
3f9e cd d9 1c				call forth_push_numhl 
3fa1			 
3fa1			 
3fa1					NEXTW 
3fa1 c3 42 20			jp macro_next 
3fa4				endm 
# End of macro NEXTW
3fa4			.STYPE: 
3fa4				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fa4 48				db WORD_SYS_CORE+52             
3fa5 f3 3f			dw .UPPER            
3fa7 06				db 5 + 1 
3fa8 .. 00			db "STYPE",0              
3fae				endm 
# End of macro CWHEAD
3fae			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fae					if DEBUG_FORTH_WORDS_KEY 
3fae						DMARK "STY" 
3fae f5				push af  
3faf 3a c3 3f			ld a, (.dmark)  
3fb2 32 77 fb			ld (debug_mark),a  
3fb5 3a c4 3f			ld a, (.dmark+1)  
3fb8 32 78 fb			ld (debug_mark+1),a  
3fbb 3a c5 3f			ld a, (.dmark+2)  
3fbe 32 79 fb			ld (debug_mark+2),a  
3fc1 18 03			jr .pastdmark  
3fc3 ..			.dmark: db "STY"  
3fc6 f1			.pastdmark: pop af  
3fc7			endm  
# End of macro DMARK
3fc7						CALLMONITOR 
3fc7 cd 49 17			call break_point_state  
3fca				endm  
# End of macro CALLMONITOR
3fca					endif 
3fca					FORTH_DSP 
3fca cd 96 1e			call macro_forth_dsp 
3fcd				endm 
# End of macro FORTH_DSP
3fcd					;v5 FORTH_DSP_VALUE 
3fcd			 
3fcd 7e					ld a, (hl) 
3fce			 
3fce f5					push af 
3fcf			 
3fcf			; Dont destroy TOS		FORTH_DSP_POP 
3fcf			 
3fcf f1					pop af 
3fd0			 
3fd0 fe 01				cp DS_TYPE_STR 
3fd2 28 09				jr z, .typestr 
3fd4			 
3fd4 fe 02				cp DS_TYPE_INUM 
3fd6 28 0a				jr z, .typeinum 
3fd8			 
3fd8 21 f1 3f				ld hl, .tna 
3fdb 18 0a				jr .tpush 
3fdd			 
3fdd 21 ed 3f		.typestr:	ld hl, .tstr 
3fe0 18 05				jr .tpush 
3fe2 21 ef 3f		.typeinum:	ld hl, .tinum 
3fe5 18 00				jr .tpush 
3fe7			 
3fe7			.tpush: 
3fe7			 
3fe7 cd 47 1d				call forth_push_str 
3fea			 
3fea					NEXTW 
3fea c3 42 20			jp macro_next 
3fed				endm 
# End of macro NEXTW
3fed .. 00		.tstr:	db "s",0 
3fef .. 00		.tinum:  db "i",0 
3ff1 .. 00		.tna:   db "?", 0 
3ff3			 
3ff3			 
3ff3			.UPPER: 
3ff3				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3ff3 48				db WORD_SYS_CORE+52             
3ff4 2e 40			dw .LOWER            
3ff6 06				db 5 + 1 
3ff7 .. 00			db "UPPER",0              
3ffd				endm 
# End of macro CWHEAD
3ffd			; | UPPER ( s -- s ) Upper case string s  | DONE 
3ffd					if DEBUG_FORTH_WORDS_KEY 
3ffd						DMARK "UPR" 
3ffd f5				push af  
3ffe 3a 12 40			ld a, (.dmark)  
4001 32 77 fb			ld (debug_mark),a  
4004 3a 13 40			ld a, (.dmark+1)  
4007 32 78 fb			ld (debug_mark+1),a  
400a 3a 14 40			ld a, (.dmark+2)  
400d 32 79 fb			ld (debug_mark+2),a  
4010 18 03			jr .pastdmark  
4012 ..			.dmark: db "UPR"  
4015 f1			.pastdmark: pop af  
4016			endm  
# End of macro DMARK
4016						CALLMONITOR 
4016 cd 49 17			call break_point_state  
4019				endm  
# End of macro CALLMONITOR
4019					endif 
4019			 
4019					FORTH_DSP 
4019 cd 96 1e			call macro_forth_dsp 
401c				endm 
# End of macro FORTH_DSP
401c					 
401c			; TODO check is string type 
401c			 
401c					FORTH_DSP_VALUEHL 
401c cd d0 1e			call macro_dsp_valuehl 
401f				endm 
# End of macro FORTH_DSP_VALUEHL
401f			; get pointer to string in hl 
401f			 
401f 7e			.toup:		ld a, (hl) 
4020 fe 00				cp 0 
4022 28 07				jr z, .toupdone 
4024			 
4024 cd 79 10				call to_upper 
4027			 
4027 77					ld (hl), a 
4028 23					inc hl 
4029 18 f4				jr .toup 
402b			 
402b					 
402b			 
402b			 
402b			; for each char convert to upper 
402b					 
402b			.toupdone: 
402b			 
402b			 
402b					NEXTW 
402b c3 42 20			jp macro_next 
402e				endm 
# End of macro NEXTW
402e			.LOWER: 
402e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
402e 48				db WORD_SYS_CORE+52             
402f 69 40			dw .TCASE            
4031 06				db 5 + 1 
4032 .. 00			db "LOWER",0              
4038				endm 
# End of macro CWHEAD
4038			; | LOWER ( s -- s ) Lower case string s  | DONE 
4038					if DEBUG_FORTH_WORDS_KEY 
4038						DMARK "LWR" 
4038 f5				push af  
4039 3a 4d 40			ld a, (.dmark)  
403c 32 77 fb			ld (debug_mark),a  
403f 3a 4e 40			ld a, (.dmark+1)  
4042 32 78 fb			ld (debug_mark+1),a  
4045 3a 4f 40			ld a, (.dmark+2)  
4048 32 79 fb			ld (debug_mark+2),a  
404b 18 03			jr .pastdmark  
404d ..			.dmark: db "LWR"  
4050 f1			.pastdmark: pop af  
4051			endm  
# End of macro DMARK
4051						CALLMONITOR 
4051 cd 49 17			call break_point_state  
4054				endm  
# End of macro CALLMONITOR
4054					endif 
4054			 
4054					FORTH_DSP 
4054 cd 96 1e			call macro_forth_dsp 
4057				endm 
# End of macro FORTH_DSP
4057					 
4057			; TODO check is string type 
4057			 
4057					FORTH_DSP_VALUEHL 
4057 cd d0 1e			call macro_dsp_valuehl 
405a				endm 
# End of macro FORTH_DSP_VALUEHL
405a			; get pointer to string in hl 
405a			 
405a 7e			.tolow:		ld a, (hl) 
405b fe 00				cp 0 
405d 28 07				jr z, .tolowdone 
405f			 
405f cd 82 10				call to_lower 
4062			 
4062 77					ld (hl), a 
4063 23					inc hl 
4064 18 f4				jr .tolow 
4066			 
4066					 
4066			 
4066			 
4066			; for each char convert to low 
4066					 
4066			.tolowdone: 
4066					NEXTW 
4066 c3 42 20			jp macro_next 
4069				endm 
# End of macro NEXTW
4069			.TCASE: 
4069				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4069 48				db WORD_SYS_CORE+52             
406a 9f 41			dw .SUBSTR            
406c 06				db 5 + 1 
406d .. 00			db "TCASE",0              
4073				endm 
# End of macro CWHEAD
4073			; | TCASE ( s -- s ) Title case string s  | DONE 
4073					if DEBUG_FORTH_WORDS_KEY 
4073						DMARK "TCS" 
4073 f5				push af  
4074 3a 88 40			ld a, (.dmark)  
4077 32 77 fb			ld (debug_mark),a  
407a 3a 89 40			ld a, (.dmark+1)  
407d 32 78 fb			ld (debug_mark+1),a  
4080 3a 8a 40			ld a, (.dmark+2)  
4083 32 79 fb			ld (debug_mark+2),a  
4086 18 03			jr .pastdmark  
4088 ..			.dmark: db "TCS"  
408b f1			.pastdmark: pop af  
408c			endm  
# End of macro DMARK
408c						CALLMONITOR 
408c cd 49 17			call break_point_state  
408f				endm  
# End of macro CALLMONITOR
408f					endif 
408f			 
408f					FORTH_DSP 
408f cd 96 1e			call macro_forth_dsp 
4092				endm 
# End of macro FORTH_DSP
4092					 
4092			; TODO check is string type 
4092			 
4092					FORTH_DSP_VALUEHL 
4092 cd d0 1e			call macro_dsp_valuehl 
4095				endm 
# End of macro FORTH_DSP_VALUEHL
4095			; get pointer to string in hl 
4095			 
4095					if DEBUG_FORTH_WORDS 
4095						DMARK "TC1" 
4095 f5				push af  
4096 3a aa 40			ld a, (.dmark)  
4099 32 77 fb			ld (debug_mark),a  
409c 3a ab 40			ld a, (.dmark+1)  
409f 32 78 fb			ld (debug_mark+1),a  
40a2 3a ac 40			ld a, (.dmark+2)  
40a5 32 79 fb			ld (debug_mark+2),a  
40a8 18 03			jr .pastdmark  
40aa ..			.dmark: db "TC1"  
40ad f1			.pastdmark: pop af  
40ae			endm  
# End of macro DMARK
40ae						CALLMONITOR 
40ae cd 49 17			call break_point_state  
40b1				endm  
# End of macro CALLMONITOR
40b1					endif 
40b1			 
40b1					; first time in turn to upper case first char 
40b1			 
40b1 7e					ld a, (hl) 
40b2 c3 3c 41				jp .totsiptou 
40b5			 
40b5			 
40b5 7e			.tot:		ld a, (hl) 
40b6 fe 00				cp 0 
40b8 ca 80 41				jp z, .totdone 
40bb			 
40bb					if DEBUG_FORTH_WORDS 
40bb						DMARK "TC2" 
40bb f5				push af  
40bc 3a d0 40			ld a, (.dmark)  
40bf 32 77 fb			ld (debug_mark),a  
40c2 3a d1 40			ld a, (.dmark+1)  
40c5 32 78 fb			ld (debug_mark+1),a  
40c8 3a d2 40			ld a, (.dmark+2)  
40cb 32 79 fb			ld (debug_mark+2),a  
40ce 18 03			jr .pastdmark  
40d0 ..			.dmark: db "TC2"  
40d3 f1			.pastdmark: pop af  
40d4			endm  
# End of macro DMARK
40d4						CALLMONITOR 
40d4 cd 49 17			call break_point_state  
40d7				endm  
# End of macro CALLMONITOR
40d7					endif 
40d7					; check to see if current char is a space 
40d7			 
40d7 fe 20				cp ' ' 
40d9 28 21				jr z, .totsp 
40db cd 82 10				call to_lower 
40de					if DEBUG_FORTH_WORDS 
40de						DMARK "TC3" 
40de f5				push af  
40df 3a f3 40			ld a, (.dmark)  
40e2 32 77 fb			ld (debug_mark),a  
40e5 3a f4 40			ld a, (.dmark+1)  
40e8 32 78 fb			ld (debug_mark+1),a  
40eb 3a f5 40			ld a, (.dmark+2)  
40ee 32 79 fb			ld (debug_mark+2),a  
40f1 18 03			jr .pastdmark  
40f3 ..			.dmark: db "TC3"  
40f6 f1			.pastdmark: pop af  
40f7			endm  
# End of macro DMARK
40f7						CALLMONITOR 
40f7 cd 49 17			call break_point_state  
40fa				endm  
# End of macro CALLMONITOR
40fa					endif 
40fa 18 63				jr .totnxt 
40fc			 
40fc			.totsp:         ; on a space, find next char which should be upper 
40fc			 
40fc					if DEBUG_FORTH_WORDS 
40fc						DMARK "TC4" 
40fc f5				push af  
40fd 3a 11 41			ld a, (.dmark)  
4100 32 77 fb			ld (debug_mark),a  
4103 3a 12 41			ld a, (.dmark+1)  
4106 32 78 fb			ld (debug_mark+1),a  
4109 3a 13 41			ld a, (.dmark+2)  
410c 32 79 fb			ld (debug_mark+2),a  
410f 18 03			jr .pastdmark  
4111 ..			.dmark: db "TC4"  
4114 f1			.pastdmark: pop af  
4115			endm  
# End of macro DMARK
4115						CALLMONITOR 
4115 cd 49 17			call break_point_state  
4118				endm  
# End of macro CALLMONITOR
4118					endif 
4118					;; 
4118			 
4118 fe 20				cp ' ' 
411a 20 20				jr nz, .totsiptou 
411c 23					inc hl 
411d 7e					ld a, (hl) 
411e					if DEBUG_FORTH_WORDS 
411e						DMARK "TC5" 
411e f5				push af  
411f 3a 33 41			ld a, (.dmark)  
4122 32 77 fb			ld (debug_mark),a  
4125 3a 34 41			ld a, (.dmark+1)  
4128 32 78 fb			ld (debug_mark+1),a  
412b 3a 35 41			ld a, (.dmark+2)  
412e 32 79 fb			ld (debug_mark+2),a  
4131 18 03			jr .pastdmark  
4133 ..			.dmark: db "TC5"  
4136 f1			.pastdmark: pop af  
4137			endm  
# End of macro DMARK
4137						CALLMONITOR 
4137 cd 49 17			call break_point_state  
413a				endm  
# End of macro CALLMONITOR
413a					endif 
413a 18 c0				jr .totsp 
413c fe 00		.totsiptou:    cp 0 
413e 28 40				jr z, .totdone 
4140					; not space and not zero term so upper case it 
4140 cd 79 10				call to_upper 
4143			 
4143					if DEBUG_FORTH_WORDS 
4143						DMARK "TC6" 
4143 f5				push af  
4144 3a 58 41			ld a, (.dmark)  
4147 32 77 fb			ld (debug_mark),a  
414a 3a 59 41			ld a, (.dmark+1)  
414d 32 78 fb			ld (debug_mark+1),a  
4150 3a 5a 41			ld a, (.dmark+2)  
4153 32 79 fb			ld (debug_mark+2),a  
4156 18 03			jr .pastdmark  
4158 ..			.dmark: db "TC6"  
415b f1			.pastdmark: pop af  
415c			endm  
# End of macro DMARK
415c						CALLMONITOR 
415c cd 49 17			call break_point_state  
415f				endm  
# End of macro CALLMONITOR
415f					endif 
415f			 
415f			 
415f			.totnxt: 
415f			 
415f 77					ld (hl), a 
4160 23					inc hl 
4161					if DEBUG_FORTH_WORDS 
4161						DMARK "TC7" 
4161 f5				push af  
4162 3a 76 41			ld a, (.dmark)  
4165 32 77 fb			ld (debug_mark),a  
4168 3a 77 41			ld a, (.dmark+1)  
416b 32 78 fb			ld (debug_mark+1),a  
416e 3a 78 41			ld a, (.dmark+2)  
4171 32 79 fb			ld (debug_mark+2),a  
4174 18 03			jr .pastdmark  
4176 ..			.dmark: db "TC7"  
4179 f1			.pastdmark: pop af  
417a			endm  
# End of macro DMARK
417a						CALLMONITOR 
417a cd 49 17			call break_point_state  
417d				endm  
# End of macro CALLMONITOR
417d					endif 
417d c3 b5 40				jp .tot 
4180			 
4180					 
4180			 
4180			 
4180			; for each char convert to low 
4180					 
4180			.totdone: 
4180					if DEBUG_FORTH_WORDS 
4180						DMARK "TCd" 
4180 f5				push af  
4181 3a 95 41			ld a, (.dmark)  
4184 32 77 fb			ld (debug_mark),a  
4187 3a 96 41			ld a, (.dmark+1)  
418a 32 78 fb			ld (debug_mark+1),a  
418d 3a 97 41			ld a, (.dmark+2)  
4190 32 79 fb			ld (debug_mark+2),a  
4193 18 03			jr .pastdmark  
4195 ..			.dmark: db "TCd"  
4198 f1			.pastdmark: pop af  
4199			endm  
# End of macro DMARK
4199						CALLMONITOR 
4199 cd 49 17			call break_point_state  
419c				endm  
# End of macro CALLMONITOR
419c					endif 
419c					NEXTW 
419c c3 42 20			jp macro_next 
419f				endm 
# End of macro NEXTW
419f			 
419f			.SUBSTR: 
419f				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
419f 48				db WORD_SYS_CORE+52             
41a0 fd 41			dw .LEFT            
41a2 07				db 6 + 1 
41a3 .. 00			db "SUBSTR",0              
41aa				endm 
# End of macro CWHEAD
41aa			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41aa			 
41aa					if DEBUG_FORTH_WORDS_KEY 
41aa						DMARK "SST" 
41aa f5				push af  
41ab 3a bf 41			ld a, (.dmark)  
41ae 32 77 fb			ld (debug_mark),a  
41b1 3a c0 41			ld a, (.dmark+1)  
41b4 32 78 fb			ld (debug_mark+1),a  
41b7 3a c1 41			ld a, (.dmark+2)  
41ba 32 79 fb			ld (debug_mark+2),a  
41bd 18 03			jr .pastdmark  
41bf ..			.dmark: db "SST"  
41c2 f1			.pastdmark: pop af  
41c3			endm  
# End of macro DMARK
41c3						CALLMONITOR 
41c3 cd 49 17			call break_point_state  
41c6				endm  
# End of macro CALLMONITOR
41c6					endif 
41c6			; TODO check string type 
41c6					FORTH_DSP_VALUEHL 
41c6 cd d0 1e			call macro_dsp_valuehl 
41c9				endm 
# End of macro FORTH_DSP_VALUEHL
41c9			 
41c9 e5					push hl      ; string length 
41ca			 
41ca					FORTH_DSP_POP 
41ca cd 88 1f			call macro_forth_dsp_pop 
41cd				endm 
# End of macro FORTH_DSP_POP
41cd			 
41cd					FORTH_DSP_VALUEHL 
41cd cd d0 1e			call macro_dsp_valuehl 
41d0				endm 
# End of macro FORTH_DSP_VALUEHL
41d0			 
41d0 e5					push hl     ; start char 
41d1			 
41d1					FORTH_DSP_POP 
41d1 cd 88 1f			call macro_forth_dsp_pop 
41d4				endm 
# End of macro FORTH_DSP_POP
41d4			 
41d4			 
41d4					FORTH_DSP_VALUE 
41d4 cd b9 1e			call macro_forth_dsp_value 
41d7				endm 
# End of macro FORTH_DSP_VALUE
41d7			 
41d7 d1					pop de    ; get start post offset 
41d8			 
41d8 19					add hl, de    ; starting offset 
41d9			 
41d9 c1					pop bc 
41da c5					push bc      ; grab size of string 
41db			 
41db e5					push hl    ; save string start  
41dc			 
41dc 26 00				ld h, 0 
41de 69					ld l, c 
41df 23					inc hl 
41e0 23					inc hl 
41e1			 
41e1 cd d3 11				call malloc 
41e4				if DEBUG_FORTH_MALLOC_GUARD 
41e4 cc a8 51				call z,malloc_error 
41e7				endif 
41e7			 
41e7 eb					ex de, hl      ; save malloc area for string copy 
41e8 e1					pop hl    ; get back source 
41e9 c1					pop bc    ; get length of string back 
41ea			 
41ea d5					push de    ; save malloc area for after we push 
41eb ed b0				ldir     ; copy substr 
41ed			 
41ed			 
41ed eb					ex de, hl 
41ee 3e 00				ld a, 0 
41f0 77					ld (hl), a   ; term substr 
41f1			 
41f1					 
41f1 e1					pop hl    ; get malloc so we can push it 
41f2 e5					push hl   ; save so we can free it afterwards 
41f3			 
41f3 cd 47 1d				call forth_push_str 
41f6			 
41f6 e1					pop hl 
41f7 cd 9d 12				call free 
41fa			 
41fa					 
41fa					 
41fa			 
41fa			 
41fa					NEXTW 
41fa c3 42 20			jp macro_next 
41fd				endm 
# End of macro NEXTW
41fd			 
41fd			.LEFT: 
41fd				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
41fd 48				db WORD_SYS_CORE+52             
41fe 25 42			dw .RIGHT            
4200 05				db 4 + 1 
4201 .. 00			db "LEFT",0              
4206				endm 
# End of macro CWHEAD
4206			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4206					if DEBUG_FORTH_WORDS_KEY 
4206						DMARK "LEF" 
4206 f5				push af  
4207 3a 1b 42			ld a, (.dmark)  
420a 32 77 fb			ld (debug_mark),a  
420d 3a 1c 42			ld a, (.dmark+1)  
4210 32 78 fb			ld (debug_mark+1),a  
4213 3a 1d 42			ld a, (.dmark+2)  
4216 32 79 fb			ld (debug_mark+2),a  
4219 18 03			jr .pastdmark  
421b ..			.dmark: db "LEF"  
421e f1			.pastdmark: pop af  
421f			endm  
# End of macro DMARK
421f						CALLMONITOR 
421f cd 49 17			call break_point_state  
4222				endm  
# End of macro CALLMONITOR
4222					endif 
4222			 
4222					NEXTW 
4222 c3 42 20			jp macro_next 
4225				endm 
# End of macro NEXTW
4225			.RIGHT: 
4225				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4225 48				db WORD_SYS_CORE+52             
4226 4e 42			dw .STR2NUM            
4228 06				db 5 + 1 
4229 .. 00			db "RIGHT",0              
422f				endm 
# End of macro CWHEAD
422f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
422f					if DEBUG_FORTH_WORDS_KEY 
422f						DMARK "RIG" 
422f f5				push af  
4230 3a 44 42			ld a, (.dmark)  
4233 32 77 fb			ld (debug_mark),a  
4236 3a 45 42			ld a, (.dmark+1)  
4239 32 78 fb			ld (debug_mark+1),a  
423c 3a 46 42			ld a, (.dmark+2)  
423f 32 79 fb			ld (debug_mark+2),a  
4242 18 03			jr .pastdmark  
4244 ..			.dmark: db "RIG"  
4247 f1			.pastdmark: pop af  
4248			endm  
# End of macro DMARK
4248						CALLMONITOR 
4248 cd 49 17			call break_point_state  
424b				endm  
# End of macro CALLMONITOR
424b					endif 
424b			 
424b					NEXTW 
424b c3 42 20			jp macro_next 
424e				endm 
# End of macro NEXTW
424e			 
424e			 
424e			.STR2NUM: 
424e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
424e 48				db WORD_SYS_CORE+52             
424f da 42			dw .NUM2STR            
4251 08				db 7 + 1 
4252 .. 00			db "STR2NUM",0              
425a				endm 
# End of macro CWHEAD
425a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
425a			 
425a			 
425a			; TODO STR type check to do 
425a					if DEBUG_FORTH_WORDS_KEY 
425a						DMARK "S2N" 
425a f5				push af  
425b 3a 6f 42			ld a, (.dmark)  
425e 32 77 fb			ld (debug_mark),a  
4261 3a 70 42			ld a, (.dmark+1)  
4264 32 78 fb			ld (debug_mark+1),a  
4267 3a 71 42			ld a, (.dmark+2)  
426a 32 79 fb			ld (debug_mark+2),a  
426d 18 03			jr .pastdmark  
426f ..			.dmark: db "S2N"  
4272 f1			.pastdmark: pop af  
4273			endm  
# End of macro DMARK
4273						CALLMONITOR 
4273 cd 49 17			call break_point_state  
4276				endm  
# End of macro CALLMONITOR
4276					endif 
4276			 
4276					;FORTH_DSP 
4276					FORTH_DSP_VALUE 
4276 cd b9 1e			call macro_forth_dsp_value 
4279				endm 
# End of macro FORTH_DSP_VALUE
4279					;inc hl 
4279			 
4279 eb					ex de, hl 
427a					if DEBUG_FORTH_WORDS 
427a						DMARK "S2a" 
427a f5				push af  
427b 3a 8f 42			ld a, (.dmark)  
427e 32 77 fb			ld (debug_mark),a  
4281 3a 90 42			ld a, (.dmark+1)  
4284 32 78 fb			ld (debug_mark+1),a  
4287 3a 91 42			ld a, (.dmark+2)  
428a 32 79 fb			ld (debug_mark+2),a  
428d 18 03			jr .pastdmark  
428f ..			.dmark: db "S2a"  
4292 f1			.pastdmark: pop af  
4293			endm  
# End of macro DMARK
4293						CALLMONITOR 
4293 cd 49 17			call break_point_state  
4296				endm  
# End of macro CALLMONITOR
4296					endif 
4296 cd 01 11				call string_to_uint16 
4299			 
4299					if DEBUG_FORTH_WORDS 
4299						DMARK "S2b" 
4299 f5				push af  
429a 3a ae 42			ld a, (.dmark)  
429d 32 77 fb			ld (debug_mark),a  
42a0 3a af 42			ld a, (.dmark+1)  
42a3 32 78 fb			ld (debug_mark+1),a  
42a6 3a b0 42			ld a, (.dmark+2)  
42a9 32 79 fb			ld (debug_mark+2),a  
42ac 18 03			jr .pastdmark  
42ae ..			.dmark: db "S2b"  
42b1 f1			.pastdmark: pop af  
42b2			endm  
# End of macro DMARK
42b2						CALLMONITOR 
42b2 cd 49 17			call break_point_state  
42b5				endm  
# End of macro CALLMONITOR
42b5					endif 
42b5			;		push hl 
42b5					FORTH_DSP_POP 
42b5 cd 88 1f			call macro_forth_dsp_pop 
42b8				endm 
# End of macro FORTH_DSP_POP
42b8			;		pop hl 
42b8					 
42b8					if DEBUG_FORTH_WORDS 
42b8						DMARK "S2b" 
42b8 f5				push af  
42b9 3a cd 42			ld a, (.dmark)  
42bc 32 77 fb			ld (debug_mark),a  
42bf 3a ce 42			ld a, (.dmark+1)  
42c2 32 78 fb			ld (debug_mark+1),a  
42c5 3a cf 42			ld a, (.dmark+2)  
42c8 32 79 fb			ld (debug_mark+2),a  
42cb 18 03			jr .pastdmark  
42cd ..			.dmark: db "S2b"  
42d0 f1			.pastdmark: pop af  
42d1			endm  
# End of macro DMARK
42d1						CALLMONITOR 
42d1 cd 49 17			call break_point_state  
42d4				endm  
# End of macro CALLMONITOR
42d4					endif 
42d4 cd d9 1c				call forth_push_numhl	 
42d7			 
42d7				 
42d7				       NEXTW 
42d7 c3 42 20			jp macro_next 
42da				endm 
# End of macro NEXTW
42da			.NUM2STR: 
42da				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
42da 48				db WORD_SYS_CORE+52             
42db e9 42			dw .CONCAT            
42dd 08				db 7 + 1 
42de .. 00			db "NUM2STR",0              
42e6				endm 
# End of macro CWHEAD
42e6			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
42e6			 
42e6			;		; malloc a string to target 
42e6			;		ld hl, 10     ; TODO max string size should be fine 
42e6			;		call malloc 
42e6			;		push hl    ; save malloc location 
42e6			; 
42e6			; 
42e6			;; TODO check int type 
42e6			;		FORTH_DSP_VALUEHL 
42e6			;		ld a, l 
42e6			;		call DispAToASCII   
42e6			;;TODO need to chage above call to dump into string 
42e6			; 
42e6			; 
42e6			 
42e6				       NEXTW 
42e6 c3 42 20			jp macro_next 
42e9				endm 
# End of macro NEXTW
42e9			 
42e9			.CONCAT: 
42e9				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
42e9 48				db WORD_SYS_CORE+52             
42ea 9c 43			dw .FIND            
42ec 07				db 6 + 1 
42ed .. 00			db "CONCAT",0              
42f4				endm 
# End of macro CWHEAD
42f4			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
42f4			 
42f4			; TODO check string type 
42f4			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
42f4			 
42f4					if DEBUG_FORTH_WORDS_KEY 
42f4						DMARK "CON" 
42f4 f5				push af  
42f5 3a 09 43			ld a, (.dmark)  
42f8 32 77 fb			ld (debug_mark),a  
42fb 3a 0a 43			ld a, (.dmark+1)  
42fe 32 78 fb			ld (debug_mark+1),a  
4301 3a 0b 43			ld a, (.dmark+2)  
4304 32 79 fb			ld (debug_mark+2),a  
4307 18 03			jr .pastdmark  
4309 ..			.dmark: db "CON"  
430c f1			.pastdmark: pop af  
430d			endm  
# End of macro DMARK
430d						CALLMONITOR 
430d cd 49 17			call break_point_state  
4310				endm  
# End of macro CALLMONITOR
4310					endif 
4310			 
4310			 
4310					FORTH_DSP_VALUE 
4310 cd b9 1e			call macro_forth_dsp_value 
4313				endm 
# End of macro FORTH_DSP_VALUE
4313 e5					push hl   ; s2 
4314			 
4314					FORTH_DSP_POP 
4314 cd 88 1f			call macro_forth_dsp_pop 
4317				endm 
# End of macro FORTH_DSP_POP
4317			 
4317					FORTH_DSP_VALUE 
4317 cd b9 1e			call macro_forth_dsp_value 
431a				endm 
# End of macro FORTH_DSP_VALUE
431a			 
431a e5					push hl   ; s1 
431b			 
431b					FORTH_DSP_POP 
431b cd 88 1f			call macro_forth_dsp_pop 
431e				endm 
# End of macro FORTH_DSP_POP
431e					 
431e			 
431e					; copy s1 
431e			 
431e				 
431e					; save ptr 
431e e1					pop hl  
431f e5					push hl 
4320 3e 00				ld a, 0 
4322 cd 75 11				call strlent 
4325					;inc hl    ; zer0 
4325 06 00				ld b, 0 
4327 4d					ld c, l 
4328 e1					pop hl		 
4329 11 1d ee				ld de, scratch	 
432c					if DEBUG_FORTH_WORDS 
432c						DMARK "CO1" 
432c f5				push af  
432d 3a 41 43			ld a, (.dmark)  
4330 32 77 fb			ld (debug_mark),a  
4333 3a 42 43			ld a, (.dmark+1)  
4336 32 78 fb			ld (debug_mark+1),a  
4339 3a 43 43			ld a, (.dmark+2)  
433c 32 79 fb			ld (debug_mark+2),a  
433f 18 03			jr .pastdmark  
4341 ..			.dmark: db "CO1"  
4344 f1			.pastdmark: pop af  
4345			endm  
# End of macro DMARK
4345						CALLMONITOR 
4345 cd 49 17			call break_point_state  
4348				endm  
# End of macro CALLMONITOR
4348					endif 
4348 ed b0				ldir 
434a			 
434a e1					pop hl 
434b e5					push hl 
434c d5					push de 
434d			 
434d			 
434d 3e 00				ld a, 0 
434f cd 75 11				call strlent 
4352 23					inc hl    ; zer0 
4353 23					inc hl 
4354 06 00				ld b, 0 
4356 4d					ld c, l 
4357 d1					pop de 
4358 e1					pop hl		 
4359					if DEBUG_FORTH_WORDS 
4359						DMARK "CO2" 
4359 f5				push af  
435a 3a 6e 43			ld a, (.dmark)  
435d 32 77 fb			ld (debug_mark),a  
4360 3a 6f 43			ld a, (.dmark+1)  
4363 32 78 fb			ld (debug_mark+1),a  
4366 3a 70 43			ld a, (.dmark+2)  
4369 32 79 fb			ld (debug_mark+2),a  
436c 18 03			jr .pastdmark  
436e ..			.dmark: db "CO2"  
4371 f1			.pastdmark: pop af  
4372			endm  
# End of macro DMARK
4372						CALLMONITOR 
4372 cd 49 17			call break_point_state  
4375				endm  
# End of macro CALLMONITOR
4375					endif 
4375 ed b0				ldir 
4377			 
4377			 
4377			 
4377 21 1d ee				ld hl, scratch 
437a					if DEBUG_FORTH_WORDS 
437a						DMARK "CO5" 
437a f5				push af  
437b 3a 8f 43			ld a, (.dmark)  
437e 32 77 fb			ld (debug_mark),a  
4381 3a 90 43			ld a, (.dmark+1)  
4384 32 78 fb			ld (debug_mark+1),a  
4387 3a 91 43			ld a, (.dmark+2)  
438a 32 79 fb			ld (debug_mark+2),a  
438d 18 03			jr .pastdmark  
438f ..			.dmark: db "CO5"  
4392 f1			.pastdmark: pop af  
4393			endm  
# End of macro DMARK
4393						CALLMONITOR 
4393 cd 49 17			call break_point_state  
4396				endm  
# End of macro CALLMONITOR
4396					endif 
4396			 
4396 cd 47 1d				call forth_push_str 
4399			 
4399			 
4399			 
4399			 
4399				       NEXTW 
4399 c3 42 20			jp macro_next 
439c				endm 
# End of macro NEXTW
439c			 
439c			 
439c			.FIND: 
439c				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
439c 4b				db WORD_SYS_CORE+55             
439d 5a 44			dw .LEN            
439f 05				db 4 + 1 
43a0 .. 00			db "FIND",0              
43a5				endm 
# End of macro CWHEAD
43a5			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43a5			 
43a5					if DEBUG_FORTH_WORDS_KEY 
43a5						DMARK "FND" 
43a5 f5				push af  
43a6 3a ba 43			ld a, (.dmark)  
43a9 32 77 fb			ld (debug_mark),a  
43ac 3a bb 43			ld a, (.dmark+1)  
43af 32 78 fb			ld (debug_mark+1),a  
43b2 3a bc 43			ld a, (.dmark+2)  
43b5 32 79 fb			ld (debug_mark+2),a  
43b8 18 03			jr .pastdmark  
43ba ..			.dmark: db "FND"  
43bd f1			.pastdmark: pop af  
43be			endm  
# End of macro DMARK
43be						CALLMONITOR 
43be cd 49 17			call break_point_state  
43c1				endm  
# End of macro CALLMONITOR
43c1					endif 
43c1			 
43c1			; TODO check string type 
43c1					FORTH_DSP_VALUE 
43c1 cd b9 1e			call macro_forth_dsp_value 
43c4				endm 
# End of macro FORTH_DSP_VALUE
43c4			 
43c4 e5					push hl    
43c5 7e					ld a,(hl)    ; char to find   
43c6			; TODO change char to substr 
43c6			 
43c6 f5					push af 
43c7					 
43c7			 
43c7			 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "FN1" 
43c7 f5				push af  
43c8 3a dc 43			ld a, (.dmark)  
43cb 32 77 fb			ld (debug_mark),a  
43ce 3a dd 43			ld a, (.dmark+1)  
43d1 32 78 fb			ld (debug_mark+1),a  
43d4 3a de 43			ld a, (.dmark+2)  
43d7 32 79 fb			ld (debug_mark+2),a  
43da 18 03			jr .pastdmark  
43dc ..			.dmark: db "FN1"  
43df f1			.pastdmark: pop af  
43e0			endm  
# End of macro DMARK
43e0						CALLMONITOR 
43e0 cd 49 17			call break_point_state  
43e3				endm  
# End of macro CALLMONITOR
43e3					endif 
43e3			 
43e3					FORTH_DSP_POP 
43e3 cd 88 1f			call macro_forth_dsp_pop 
43e6				endm 
# End of macro FORTH_DSP_POP
43e6			 
43e6					; string to search 
43e6			 
43e6					FORTH_DSP_VALUE 
43e6 cd b9 1e			call macro_forth_dsp_value 
43e9				endm 
# End of macro FORTH_DSP_VALUE
43e9			 
43e9 d1					pop de  ; d is char to find  
43ea			 
43ea					if DEBUG_FORTH_WORDS 
43ea						DMARK "FN2" 
43ea f5				push af  
43eb 3a ff 43			ld a, (.dmark)  
43ee 32 77 fb			ld (debug_mark),a  
43f1 3a 00 44			ld a, (.dmark+1)  
43f4 32 78 fb			ld (debug_mark+1),a  
43f7 3a 01 44			ld a, (.dmark+2)  
43fa 32 79 fb			ld (debug_mark+2),a  
43fd 18 03			jr .pastdmark  
43ff ..			.dmark: db "FN2"  
4402 f1			.pastdmark: pop af  
4403			endm  
# End of macro DMARK
4403						CALLMONITOR 
4403 cd 49 17			call break_point_state  
4406				endm  
# End of macro CALLMONITOR
4406					endif 
4406					 
4406 01 00 00				ld bc, 0 
4409 7e			.findchar:      ld a,(hl) 
440a fe 00				cp 0   		 
440c 28 27				jr z, .finddone     
440e ba					cp d 
440f 28 20				jr z, .foundchar 
4411 03					inc bc 
4412 23					inc hl 
4413					if DEBUG_FORTH_WORDS 
4413						DMARK "FN3" 
4413 f5				push af  
4414 3a 28 44			ld a, (.dmark)  
4417 32 77 fb			ld (debug_mark),a  
441a 3a 29 44			ld a, (.dmark+1)  
441d 32 78 fb			ld (debug_mark+1),a  
4420 3a 2a 44			ld a, (.dmark+2)  
4423 32 79 fb			ld (debug_mark+2),a  
4426 18 03			jr .pastdmark  
4428 ..			.dmark: db "FN3"  
442b f1			.pastdmark: pop af  
442c			endm  
# End of macro DMARK
442c						CALLMONITOR 
442c cd 49 17			call break_point_state  
442f				endm  
# End of macro CALLMONITOR
442f					endif 
442f 18 d8				jr .findchar 
4431			 
4431			 
4431 c5			.foundchar:	push bc 
4432 e1					pop hl 
4433 18 03				jr .findexit 
4435			 
4435			 
4435							 
4435			 
4435			.finddone:     ; got to end of string with no find 
4435 21 00 00				ld hl, 0 
4438			.findexit: 
4438			 
4438					if DEBUG_FORTH_WORDS 
4438						DMARK "FNd" 
4438 f5				push af  
4439 3a 4d 44			ld a, (.dmark)  
443c 32 77 fb			ld (debug_mark),a  
443f 3a 4e 44			ld a, (.dmark+1)  
4442 32 78 fb			ld (debug_mark+1),a  
4445 3a 4f 44			ld a, (.dmark+2)  
4448 32 79 fb			ld (debug_mark+2),a  
444b 18 03			jr .pastdmark  
444d ..			.dmark: db "FNd"  
4450 f1			.pastdmark: pop af  
4451			endm  
# End of macro DMARK
4451						CALLMONITOR 
4451 cd 49 17			call break_point_state  
4454				endm  
# End of macro CALLMONITOR
4454					endif 
4454 cd d9 1c			call forth_push_numhl 
4457			 
4457				       NEXTW 
4457 c3 42 20			jp macro_next 
445a				endm 
# End of macro NEXTW
445a			 
445a			.LEN: 
445a				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
445a 4c				db WORD_SYS_CORE+56             
445b 8f 44			dw .CHAR            
445d 06				db 5 + 1 
445e .. 00			db "COUNT",0              
4464				endm 
# End of macro CWHEAD
4464			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4464			 
4464					if DEBUG_FORTH_WORDS_KEY 
4464						DMARK "CNT" 
4464 f5				push af  
4465 3a 79 44			ld a, (.dmark)  
4468 32 77 fb			ld (debug_mark),a  
446b 3a 7a 44			ld a, (.dmark+1)  
446e 32 78 fb			ld (debug_mark+1),a  
4471 3a 7b 44			ld a, (.dmark+2)  
4474 32 79 fb			ld (debug_mark+2),a  
4477 18 03			jr .pastdmark  
4479 ..			.dmark: db "CNT"  
447c f1			.pastdmark: pop af  
447d			endm  
# End of macro DMARK
447d						CALLMONITOR 
447d cd 49 17			call break_point_state  
4480				endm  
# End of macro CALLMONITOR
4480					endif 
4480			; TODO check string type 
4480					FORTH_DSP 
4480 cd 96 1e			call macro_forth_dsp 
4483				endm 
# End of macro FORTH_DSP
4483					;v5FORTH_DSP_VALUE 
4483			 
4483 23					inc hl 
4484			 
4484 3e 00				ld a, 0 
4486 cd 75 11				call strlent 
4489			 
4489 cd d9 1c				call forth_push_numhl 
448c			 
448c			 
448c			 
448c				       NEXTW 
448c c3 42 20			jp macro_next 
448f				endm 
# End of macro NEXTW
448f			.CHAR: 
448f				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
448f 4d				db WORD_SYS_CORE+57             
4490 c5 44			dw .ENDSTR            
4492 05				db 4 + 1 
4493 .. 00			db "CHAR",0              
4498				endm 
# End of macro CWHEAD
4498			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4498					if DEBUG_FORTH_WORDS_KEY 
4498						DMARK "CHR" 
4498 f5				push af  
4499 3a ad 44			ld a, (.dmark)  
449c 32 77 fb			ld (debug_mark),a  
449f 3a ae 44			ld a, (.dmark+1)  
44a2 32 78 fb			ld (debug_mark+1),a  
44a5 3a af 44			ld a, (.dmark+2)  
44a8 32 79 fb			ld (debug_mark+2),a  
44ab 18 03			jr .pastdmark  
44ad ..			.dmark: db "CHR"  
44b0 f1			.pastdmark: pop af  
44b1			endm  
# End of macro DMARK
44b1						CALLMONITOR 
44b1 cd 49 17			call break_point_state  
44b4				endm  
# End of macro CALLMONITOR
44b4					endif 
44b4					FORTH_DSP 
44b4 cd 96 1e			call macro_forth_dsp 
44b7				endm 
# End of macro FORTH_DSP
44b7					;v5 FORTH_DSP_VALUE 
44b7 23					inc hl      ; now at start of numeric as string 
44b8			 
44b8			;		push hl 
44b8			 
44b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b8 cd 88 1f			call macro_forth_dsp_pop 
44bb				endm 
# End of macro FORTH_DSP_POP
44bb			 
44bb			;		pop hl 
44bb			 
44bb					; push the content of a onto the stack as a value 
44bb			 
44bb 7e					ld a,(hl)   ; get char 
44bc 26 00				ld h,0 
44be 6f					ld l,a 
44bf cd d9 1c				call forth_push_numhl 
44c2			 
44c2				       NEXTW 
44c2 c3 42 20			jp macro_next 
44c5				endm 
# End of macro NEXTW
44c5			 
44c5			 
44c5			 
44c5			 
44c5			.ENDSTR: 
44c5			; eof 
44c5			 
# End of file forth_words_str.asm
44c5			include "forth_words_key.asm" 
44c5			 
44c5			; | ## Keyboard Words 
44c5			 
44c5			.KEY: 
44c5				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
44c5 3e				db WORD_SYS_CORE+42             
44c6 f5 44			dw .WAITK            
44c8 04				db 3 + 1 
44c9 .. 00			db "KEY",0              
44cd				endm 
# End of macro CWHEAD
44cd			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44cd			 
44cd					if DEBUG_FORTH_WORDS_KEY 
44cd						DMARK "KEY" 
44cd f5				push af  
44ce 3a e2 44			ld a, (.dmark)  
44d1 32 77 fb			ld (debug_mark),a  
44d4 3a e3 44			ld a, (.dmark+1)  
44d7 32 78 fb			ld (debug_mark+1),a  
44da 3a e4 44			ld a, (.dmark+2)  
44dd 32 79 fb			ld (debug_mark+2),a  
44e0 18 03			jr .pastdmark  
44e2 ..			.dmark: db "KEY"  
44e5 f1			.pastdmark: pop af  
44e6			endm  
# End of macro DMARK
44e6						CALLMONITOR 
44e6 cd 49 17			call break_point_state  
44e9				endm  
# End of macro CALLMONITOR
44e9					endif 
44e9			; TODO currently waits 
44e9 cd db 68				call cin 
44ec					;call cin_wait 
44ec 6f					ld l, a 
44ed 26 00				ld h, 0 
44ef cd d9 1c				call forth_push_numhl 
44f2					NEXTW 
44f2 c3 42 20			jp macro_next 
44f5				endm 
# End of macro NEXTW
44f5			.WAITK: 
44f5				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
44f5 3f				db WORD_SYS_CORE+43             
44f6 27 45			dw .ACCEPT            
44f8 06				db 5 + 1 
44f9 .. 00			db "WAITK",0              
44ff				endm 
# End of macro CWHEAD
44ff			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
44ff					if DEBUG_FORTH_WORDS_KEY 
44ff						DMARK "WAI" 
44ff f5				push af  
4500 3a 14 45			ld a, (.dmark)  
4503 32 77 fb			ld (debug_mark),a  
4506 3a 15 45			ld a, (.dmark+1)  
4509 32 78 fb			ld (debug_mark+1),a  
450c 3a 16 45			ld a, (.dmark+2)  
450f 32 79 fb			ld (debug_mark+2),a  
4512 18 03			jr .pastdmark  
4514 ..			.dmark: db "WAI"  
4517 f1			.pastdmark: pop af  
4518			endm  
# End of macro DMARK
4518						CALLMONITOR 
4518 cd 49 17			call break_point_state  
451b				endm  
# End of macro CALLMONITOR
451b					endif 
451b cd ca 68				call cin_wait 
451e 6f					ld l, a 
451f 26 00				ld h, 0 
4521 cd d9 1c				call forth_push_numhl 
4524					NEXTW 
4524 c3 42 20			jp macro_next 
4527				endm 
# End of macro NEXTW
4527			.ACCEPT: 
4527				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4527 40				db WORD_SYS_CORE+44             
4528 85 45			dw .EDIT            
452a 07				db 6 + 1 
452b .. 00			db "ACCEPT",0              
4532				endm 
# End of macro CWHEAD
4532			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4532					; TODO crashes on push 
4532					if DEBUG_FORTH_WORDS_KEY 
4532						DMARK "ACC" 
4532 f5				push af  
4533 3a 47 45			ld a, (.dmark)  
4536 32 77 fb			ld (debug_mark),a  
4539 3a 48 45			ld a, (.dmark+1)  
453c 32 78 fb			ld (debug_mark+1),a  
453f 3a 49 45			ld a, (.dmark+2)  
4542 32 79 fb			ld (debug_mark+2),a  
4545 18 03			jr .pastdmark  
4547 ..			.dmark: db "ACC"  
454a f1			.pastdmark: pop af  
454b			endm  
# End of macro DMARK
454b						CALLMONITOR 
454b cd 49 17			call break_point_state  
454e				endm  
# End of macro CALLMONITOR
454e					endif 
454e 21 1b f0				ld hl, os_input 
4551 3e 00				ld a, 0 
4553 77					ld (hl),a 
4554 3a 46 f8				ld a,(f_cursor_ptr) 
4557 16 64				ld d, 100 
4559 0e 00				ld c, 0 
455b 1e 28				ld e, 40 
455d cd 39 0d				call input_str 
4560					; TODO perhaps do a type check and wrap in quotes if not a number 
4560 21 1b f0				ld hl, os_input 
4563					if DEBUG_FORTH_WORDS 
4563						DMARK "AC1" 
4563 f5				push af  
4564 3a 78 45			ld a, (.dmark)  
4567 32 77 fb			ld (debug_mark),a  
456a 3a 79 45			ld a, (.dmark+1)  
456d 32 78 fb			ld (debug_mark+1),a  
4570 3a 7a 45			ld a, (.dmark+2)  
4573 32 79 fb			ld (debug_mark+2),a  
4576 18 03			jr .pastdmark  
4578 ..			.dmark: db "AC1"  
457b f1			.pastdmark: pop af  
457c			endm  
# End of macro DMARK
457c						CALLMONITOR 
457c cd 49 17			call break_point_state  
457f				endm  
# End of macro CALLMONITOR
457f					endif 
457f cd 47 1d				call forth_push_str 
4582					NEXTW 
4582 c3 42 20			jp macro_next 
4585				endm 
# End of macro NEXTW
4585			 
4585			.EDIT: 
4585				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4585 40				db WORD_SYS_CORE+44             
4586 27 46			dw .ENDKEY            
4588 05				db 4 + 1 
4589 .. 00			db "EDIT",0              
458e				endm 
# End of macro CWHEAD
458e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
458e			 
458e					; TODO does not copy from stack 
458e					if DEBUG_FORTH_WORDS_KEY 
458e						DMARK "EDT" 
458e f5				push af  
458f 3a a3 45			ld a, (.dmark)  
4592 32 77 fb			ld (debug_mark),a  
4595 3a a4 45			ld a, (.dmark+1)  
4598 32 78 fb			ld (debug_mark+1),a  
459b 3a a5 45			ld a, (.dmark+2)  
459e 32 79 fb			ld (debug_mark+2),a  
45a1 18 03			jr .pastdmark  
45a3 ..			.dmark: db "EDT"  
45a6 f1			.pastdmark: pop af  
45a7			endm  
# End of macro DMARK
45a7						CALLMONITOR 
45a7 cd 49 17			call break_point_state  
45aa				endm  
# End of macro CALLMONITOR
45aa					endif 
45aa			 
45aa					;FORTH_DSP 
45aa					FORTH_DSP_VALUEHL 
45aa cd d0 1e			call macro_dsp_valuehl 
45ad				endm 
# End of macro FORTH_DSP_VALUEHL
45ad			;		inc hl    ; TODO do type check 
45ad			 
45ad			;		call get_word_hl 
45ad e5					push hl 
45ae					if DEBUG_FORTH_WORDS 
45ae						DMARK "EDp" 
45ae f5				push af  
45af 3a c3 45			ld a, (.dmark)  
45b2 32 77 fb			ld (debug_mark),a  
45b5 3a c4 45			ld a, (.dmark+1)  
45b8 32 78 fb			ld (debug_mark+1),a  
45bb 3a c5 45			ld a, (.dmark+2)  
45be 32 79 fb			ld (debug_mark+2),a  
45c1 18 03			jr .pastdmark  
45c3 ..			.dmark: db "EDp"  
45c6 f1			.pastdmark: pop af  
45c7			endm  
# End of macro DMARK
45c7						CALLMONITOR 
45c7 cd 49 17			call break_point_state  
45ca				endm  
# End of macro CALLMONITOR
45ca					endif 
45ca				;	ld a, 0 
45ca cd 6a 11				call strlenz 
45cd 23					inc hl 
45ce			 
45ce 06 00				ld b, 0 
45d0 4d					ld c, l 
45d1			 
45d1 e1					pop hl 
45d2 11 1b f0				ld de, os_input 
45d5					if DEBUG_FORTH_WORDS_KEY 
45d5						DMARK "EDc" 
45d5 f5				push af  
45d6 3a ea 45			ld a, (.dmark)  
45d9 32 77 fb			ld (debug_mark),a  
45dc 3a eb 45			ld a, (.dmark+1)  
45df 32 78 fb			ld (debug_mark+1),a  
45e2 3a ec 45			ld a, (.dmark+2)  
45e5 32 79 fb			ld (debug_mark+2),a  
45e8 18 03			jr .pastdmark  
45ea ..			.dmark: db "EDc"  
45ed f1			.pastdmark: pop af  
45ee			endm  
# End of macro DMARK
45ee						CALLMONITOR 
45ee cd 49 17			call break_point_state  
45f1				endm  
# End of macro CALLMONITOR
45f1					endif 
45f1 ed b0				ldir 
45f3			 
45f3			 
45f3 21 1b f0				ld hl, os_input 
45f6					;ld a, 0 
45f6					;ld (hl),a 
45f6 3a 46 f8				ld a,(f_cursor_ptr) 
45f9 16 64				ld d, 100 
45fb 0e 00				ld c, 0 
45fd 1e 28				ld e, 40 
45ff cd 39 0d				call input_str 
4602					; TODO perhaps do a type check and wrap in quotes if not a number 
4602 21 1b f0				ld hl, os_input 
4605					if DEBUG_FORTH_WORDS 
4605						DMARK "ED1" 
4605 f5				push af  
4606 3a 1a 46			ld a, (.dmark)  
4609 32 77 fb			ld (debug_mark),a  
460c 3a 1b 46			ld a, (.dmark+1)  
460f 32 78 fb			ld (debug_mark+1),a  
4612 3a 1c 46			ld a, (.dmark+2)  
4615 32 79 fb			ld (debug_mark+2),a  
4618 18 03			jr .pastdmark  
461a ..			.dmark: db "ED1"  
461d f1			.pastdmark: pop af  
461e			endm  
# End of macro DMARK
461e						CALLMONITOR 
461e cd 49 17			call break_point_state  
4621				endm  
# End of macro CALLMONITOR
4621					endif 
4621 cd 47 1d				call forth_push_str 
4624					NEXTW 
4624 c3 42 20			jp macro_next 
4627				endm 
# End of macro NEXTW
4627			 
4627			 
4627			 
4627			.ENDKEY: 
4627			; eof 
4627			 
# End of file forth_words_key.asm
4627			 
4627			if STORAGE_SE 
4627			   	include "forth_words_storage.asm" 
4627			 
4627			; | ## Fixed Storage Words 
4627			 
4627			 
4627			.BREAD: 
4627			  
4627				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4627 3a				db WORD_SYS_CORE+38             
4628 a0 46			dw .BWRITE            
462a 06				db 5 + 1 
462b .. 00			db "BREAD",0              
4631				endm 
# End of macro CWHEAD
4631			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4631				 
4631					if DEBUG_FORTH_WORDS_KEY 
4631						DMARK "BRD" 
4631 f5				push af  
4632 3a 46 46			ld a, (.dmark)  
4635 32 77 fb			ld (debug_mark),a  
4638 3a 47 46			ld a, (.dmark+1)  
463b 32 78 fb			ld (debug_mark+1),a  
463e 3a 48 46			ld a, (.dmark+2)  
4641 32 79 fb			ld (debug_mark+2),a  
4644 18 03			jr .pastdmark  
4646 ..			.dmark: db "BRD"  
4649 f1			.pastdmark: pop af  
464a			endm  
# End of macro DMARK
464a						CALLMONITOR 
464a cd 49 17			call break_point_state  
464d				endm  
# End of macro CALLMONITOR
464d					endif 
464d			 
464d				FORTH_DSP_VALUEHL 
464d cd d0 1e			call macro_dsp_valuehl 
4650				endm 
# End of macro FORTH_DSP_VALUEHL
4650			 
4650				FORTH_DSP_POP 
4650 cd 88 1f			call macro_forth_dsp_pop 
4653				endm 
# End of macro FORTH_DSP_POP
4653			 
4653				; calc block address 
4653			 
4653 eb				ex de, hl 
4654 3e 40			ld a, STORE_BLOCK_PHY 
4656 cd 8f 0c			call Mult16 
4659			 
4659			 
4659 11 62 f8			ld de, store_page 
465c			 
465c					if DEBUG_FORTH_WORDS 
465c						DMARK "BR1" 
465c f5				push af  
465d 3a 71 46			ld a, (.dmark)  
4660 32 77 fb			ld (debug_mark),a  
4663 3a 72 46			ld a, (.dmark+1)  
4666 32 78 fb			ld (debug_mark+1),a  
4669 3a 73 46			ld a, (.dmark+2)  
466c 32 79 fb			ld (debug_mark+2),a  
466f 18 03			jr .pastdmark  
4671 ..			.dmark: db "BR1"  
4674 f1			.pastdmark: pop af  
4675			endm  
# End of macro DMARK
4675						CALLMONITOR 
4675 cd 49 17			call break_point_state  
4678				endm  
# End of macro CALLMONITOR
4678					endif 
4678			 
4678 cd 0c 03			call storage_read_block 
467b			 
467b 21 64 f8		        ld hl, store_page+2 
467e					if DEBUG_FORTH_WORDS 
467e						DMARK "BR2" 
467e f5				push af  
467f 3a 93 46			ld a, (.dmark)  
4682 32 77 fb			ld (debug_mark),a  
4685 3a 94 46			ld a, (.dmark+1)  
4688 32 78 fb			ld (debug_mark+1),a  
468b 3a 95 46			ld a, (.dmark+2)  
468e 32 79 fb			ld (debug_mark+2),a  
4691 18 03			jr .pastdmark  
4693 ..			.dmark: db "BR2"  
4696 f1			.pastdmark: pop af  
4697			endm  
# End of macro DMARK
4697						CALLMONITOR 
4697 cd 49 17			call break_point_state  
469a				endm  
# End of macro CALLMONITOR
469a					endif 
469a cd 47 1d			call forth_push_str 
469d			 
469d			 
469d					NEXTW 
469d c3 42 20			jp macro_next 
46a0				endm 
# End of macro NEXTW
46a0			.BWRITE: 
46a0				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46a0 3a				db WORD_SYS_CORE+38             
46a1 35 47			dw .BUPD            
46a3 07				db 6 + 1 
46a4 .. 00			db "BWRITE",0              
46ab				endm 
# End of macro CWHEAD
46ab			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46ab			 
46ab					if DEBUG_FORTH_WORDS_KEY 
46ab						DMARK "BWR" 
46ab f5				push af  
46ac 3a c0 46			ld a, (.dmark)  
46af 32 77 fb			ld (debug_mark),a  
46b2 3a c1 46			ld a, (.dmark+1)  
46b5 32 78 fb			ld (debug_mark+1),a  
46b8 3a c2 46			ld a, (.dmark+2)  
46bb 32 79 fb			ld (debug_mark+2),a  
46be 18 03			jr .pastdmark  
46c0 ..			.dmark: db "BWR"  
46c3 f1			.pastdmark: pop af  
46c4			endm  
# End of macro DMARK
46c4						CALLMONITOR 
46c4 cd 49 17			call break_point_state  
46c7				endm  
# End of macro CALLMONITOR
46c7					endif 
46c7			 
46c7				FORTH_DSP_VALUEHL 
46c7 cd d0 1e			call macro_dsp_valuehl 
46ca				endm 
# End of macro FORTH_DSP_VALUEHL
46ca			 
46ca				; calc block address 
46ca			 
46ca eb				ex de, hl 
46cb 3e 40			ld a, STORE_BLOCK_PHY 
46cd cd 8f 0c			call Mult16 
46d0			 
46d0 e5				push hl         ; address 
46d1			 
46d1				FORTH_DSP_POP 
46d1 cd 88 1f			call macro_forth_dsp_pop 
46d4				endm 
# End of macro FORTH_DSP_POP
46d4			 
46d4				FORTH_DSP_VALUEHL 
46d4 cd d0 1e			call macro_dsp_valuehl 
46d7				endm 
# End of macro FORTH_DSP_VALUEHL
46d7			 
46d7				FORTH_DSP_POP 
46d7 cd 88 1f			call macro_forth_dsp_pop 
46da				endm 
# End of macro FORTH_DSP_POP
46da			 
46da cd 1b 0a			call storage_clear_page 
46dd			 
46dd				; copy string to store page 
46dd			 
46dd e5				push hl     ; save string address 
46de			 
46de 3e 00			ld a, 0 
46e0 cd 75 11			call strlent 
46e3			 
46e3 23				inc hl 
46e4			 
46e4 4d				ld c, l 
46e5 06 00			ld b, 0 
46e7			 
46e7 e1				pop hl 
46e8 11 64 f8			ld de, store_page + 2 
46eb					if DEBUG_FORTH_WORDS 
46eb						DMARK "BW1" 
46eb f5				push af  
46ec 3a 00 47			ld a, (.dmark)  
46ef 32 77 fb			ld (debug_mark),a  
46f2 3a 01 47			ld a, (.dmark+1)  
46f5 32 78 fb			ld (debug_mark+1),a  
46f8 3a 02 47			ld a, (.dmark+2)  
46fb 32 79 fb			ld (debug_mark+2),a  
46fe 18 03			jr .pastdmark  
4700 ..			.dmark: db "BW1"  
4703 f1			.pastdmark: pop af  
4704			endm  
# End of macro DMARK
4704						CALLMONITOR 
4704 cd 49 17			call break_point_state  
4707				endm  
# End of macro CALLMONITOR
4707					endif 
4707 ed b0			ldir 
4709			 
4709			 
4709				; poke the start of the block with flags to prevent high level file ops hitting the block 
4709			 
4709 21 ff ff			ld hl, $ffff 
470c			 
470c 22 62 f8			ld (store_page), hl	 
470f				 
470f e1				pop hl    ; get address 
4710 11 62 f8			ld de, store_page 
4713			 
4713					if DEBUG_FORTH_WORDS 
4713						DMARK "BW2" 
4713 f5				push af  
4714 3a 28 47			ld a, (.dmark)  
4717 32 77 fb			ld (debug_mark),a  
471a 3a 29 47			ld a, (.dmark+1)  
471d 32 78 fb			ld (debug_mark+1),a  
4720 3a 2a 47			ld a, (.dmark+2)  
4723 32 79 fb			ld (debug_mark+2),a  
4726 18 03			jr .pastdmark  
4728 ..			.dmark: db "BW2"  
472b f1			.pastdmark: pop af  
472c			endm  
# End of macro DMARK
472c						CALLMONITOR 
472c cd 49 17			call break_point_state  
472f				endm  
# End of macro CALLMONITOR
472f					endif 
472f			 
472f cd 71 03			call storage_write_block 
4732			 
4732					NEXTW 
4732 c3 42 20			jp macro_next 
4735				endm 
# End of macro NEXTW
4735			 
4735			.BUPD: 
4735				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4735 3a				db WORD_SYS_CORE+38             
4736 8b 47			dw .BYID            
4738 05				db 4 + 1 
4739 .. 00			db "BUPD",0              
473e				endm 
# End of macro CWHEAD
473e			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
473e			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
473e			; | | or completely different file system structure. 
473e			 
473e					if DEBUG_FORTH_WORDS_KEY 
473e						DMARK "BUD" 
473e f5				push af  
473f 3a 53 47			ld a, (.dmark)  
4742 32 77 fb			ld (debug_mark),a  
4745 3a 54 47			ld a, (.dmark+1)  
4748 32 78 fb			ld (debug_mark+1),a  
474b 3a 55 47			ld a, (.dmark+2)  
474e 32 79 fb			ld (debug_mark+2),a  
4751 18 03			jr .pastdmark  
4753 ..			.dmark: db "BUD"  
4756 f1			.pastdmark: pop af  
4757			endm  
# End of macro DMARK
4757						CALLMONITOR 
4757 cd 49 17			call break_point_state  
475a				endm  
# End of macro CALLMONITOR
475a					endif 
475a			 
475a				FORTH_DSP_VALUEHL 
475a cd d0 1e			call macro_dsp_valuehl 
475d				endm 
# End of macro FORTH_DSP_VALUEHL
475d			 
475d				; calc block address 
475d			 
475d eb				ex de, hl 
475e 3e 40			ld a, STORE_BLOCK_PHY 
4760 cd 8f 0c			call Mult16 
4763			 
4763				FORTH_DSP_POP 
4763 cd 88 1f			call macro_forth_dsp_pop 
4766				endm 
# End of macro FORTH_DSP_POP
4766			 
4766			 
4766 11 62 f8			ld de, store_page 
4769			 
4769					if DEBUG_FORTH_WORDS 
4769						DMARK "BUe" 
4769 f5				push af  
476a 3a 7e 47			ld a, (.dmark)  
476d 32 77 fb			ld (debug_mark),a  
4770 3a 7f 47			ld a, (.dmark+1)  
4773 32 78 fb			ld (debug_mark+1),a  
4776 3a 80 47			ld a, (.dmark+2)  
4779 32 79 fb			ld (debug_mark+2),a  
477c 18 03			jr .pastdmark  
477e ..			.dmark: db "BUe"  
4781 f1			.pastdmark: pop af  
4782			endm  
# End of macro DMARK
4782						CALLMONITOR 
4782 cd 49 17			call break_point_state  
4785				endm  
# End of macro CALLMONITOR
4785					endif 
4785			 
4785 cd 71 03			call storage_write_block 
4788			 
4788					NEXTW 
4788 c3 42 20			jp macro_next 
478b				endm 
# End of macro NEXTW
478b			 
478b			.BYID: 
478b			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
478b			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
478b			; 
478b			;		 
478b			;		if DEBUG_FORTH_WORDS_KEY 
478b			;			DMARK "BYID" 
478b			;			CALLMONITOR 
478b			;		endif 
478b			; 
478b			;		; get direct address 
478b			; 
478b			;		FORTH_DSP_VALUEHL 
478b			; 
478b			;		FORTH_DSP_POP 
478b			; 
478b			;	; calc block address 
478b			; 
478b			;	ex de, hl 
478b			;	ld a, STORE_BLOCK_PHY 
478b			;	call Mult16 
478b			;	;	do BREAD with number as param 
478b			;	; push the file name	 
478b			;	ld de, store_page 
478b			;	call storage_read_block 
478b			 ;       ld hl, store_page+2 
478b			; 
478b			; 
478b			;		NEXTW 
478b			;.BYNAME: 
478b			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
478b			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
478b			;		NEXTW 
478b			; 
478b			.DIR: 
478b				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
478b 3a				db WORD_SYS_CORE+38             
478c 8f 48			dw .SAVE            
478e 04				db 3 + 1 
478f .. 00			db "DIR",0              
4793				endm 
# End of macro CWHEAD
4793			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4793			 
4793					if DEBUG_FORTH_WORDS_KEY 
4793						DMARK "DIR" 
4793 f5				push af  
4794 3a a8 47			ld a, (.dmark)  
4797 32 77 fb			ld (debug_mark),a  
479a 3a a9 47			ld a, (.dmark+1)  
479d 32 78 fb			ld (debug_mark+1),a  
47a0 3a aa 47			ld a, (.dmark+2)  
47a3 32 79 fb			ld (debug_mark+2),a  
47a6 18 03			jr .pastdmark  
47a8 ..			.dmark: db "DIR"  
47ab f1			.pastdmark: pop af  
47ac			endm  
# End of macro DMARK
47ac						CALLMONITOR 
47ac cd 49 17			call break_point_state  
47af				endm  
# End of macro CALLMONITOR
47af					endif 
47af cd bd 03			call storage_get_block_0 
47b2			 
47b2 21 62 f8			ld hl, store_page     ; get current id count 
47b5 46				ld b, (hl) 
47b6 0e 00			ld c, 0    ; count of files   
47b8					if DEBUG_FORTH_WORDS 
47b8						DMARK "DI1" 
47b8 f5				push af  
47b9 3a cd 47			ld a, (.dmark)  
47bc 32 77 fb			ld (debug_mark),a  
47bf 3a ce 47			ld a, (.dmark+1)  
47c2 32 78 fb			ld (debug_mark+1),a  
47c5 3a cf 47			ld a, (.dmark+2)  
47c8 32 79 fb			ld (debug_mark+2),a  
47cb 18 03			jr .pastdmark  
47cd ..			.dmark: db "DI1"  
47d0 f1			.pastdmark: pop af  
47d1			endm  
# End of macro DMARK
47d1						CALLMONITOR 
47d1 cd 49 17			call break_point_state  
47d4				endm  
# End of macro CALLMONITOR
47d4					endif 
47d4			 
47d4				; check for empty drive 
47d4			 
47d4 3e 00			ld a, 0 
47d6 b8				cp b 
47d7 ca 45 48			jp z, .dirdone 
47da			 
47da				; for each of the current ids do a search for them and if found push to stack 
47da			 
47da c5			.diritem:	push bc 
47db 21 40 00				ld hl, STORE_BLOCK_PHY 
47de 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
47e0 58					ld e,b 
47e1			 
47e1			;		if DEBUG_FORTH_WORDS 
47e1			;			DMARK "DI2" 
47e1			;			CALLMONITOR 
47e1			;		endif 
47e1			 
47e1 cd 2d 06				call storage_findnextid 
47e4			 
47e4			;		if DEBUG_FORTH_WORDS 
47e4			;			DMARK "DI3" 
47e4			;			CALLMONITOR 
47e4			;		endif 
47e4			 
47e4					; if found hl will be non zero 
47e4			 
47e4 cd 35 0d				call ishlzero 
47e7			;		ld a, l 
47e7			;		add h 
47e7			; 
47e7			;		cp 0 
47e7 28 59				jr z, .dirnotfound 
47e9			 
47e9					; increase count 
47e9			 
47e9 c1					pop bc	 
47ea 0c					inc c 
47eb c5					push bc 
47ec					 
47ec			 
47ec					; get file header and push the file name 
47ec			 
47ec 11 62 f8				ld de, store_page 
47ef cd 0c 03				call storage_read_block 
47f2			 
47f2					; push file id to stack 
47f2				 
47f2 3a 62 f8				ld a, (store_page) 
47f5 26 00				ld h, 0 
47f7 6f					ld l, a 
47f8 cd d9 1c				call forth_push_numhl 
47fb			 
47fb					; push extent count to stack  
47fb				 
47fb 3a 64 f8				ld a, (store_page+2) 
47fe 26 00				ld h, 0 
4800 6f					ld l, a 
4801 cd d9 1c				call forth_push_numhl 
4804			 
4804					; push file name 
4804			 
4804 21 65 f8				ld hl, store_page+3 
4807					if DEBUG_FORTH_WORDS 
4807						DMARK "DI5" 
4807 f5				push af  
4808 3a 1c 48			ld a, (.dmark)  
480b 32 77 fb			ld (debug_mark),a  
480e 3a 1d 48			ld a, (.dmark+1)  
4811 32 78 fb			ld (debug_mark+1),a  
4814 3a 1e 48			ld a, (.dmark+2)  
4817 32 79 fb			ld (debug_mark+2),a  
481a 18 03			jr .pastdmark  
481c ..			.dmark: db "DI5"  
481f f1			.pastdmark: pop af  
4820			endm  
# End of macro DMARK
4820						CALLMONITOR 
4820 cd 49 17			call break_point_state  
4823				endm  
# End of macro CALLMONITOR
4823					endif 
4823 cd 47 1d				call forth_push_str 
4826					if DEBUG_FORTH_WORDS 
4826						DMARK "DI6" 
4826 f5				push af  
4827 3a 3b 48			ld a, (.dmark)  
482a 32 77 fb			ld (debug_mark),a  
482d 3a 3c 48			ld a, (.dmark+1)  
4830 32 78 fb			ld (debug_mark+1),a  
4833 3a 3d 48			ld a, (.dmark+2)  
4836 32 79 fb			ld (debug_mark+2),a  
4839 18 03			jr .pastdmark  
483b ..			.dmark: db "DI6"  
483e f1			.pastdmark: pop af  
483f			endm  
# End of macro DMARK
483f						CALLMONITOR 
483f cd 49 17			call break_point_state  
4842				endm  
# End of macro CALLMONITOR
4842					endif 
4842			.dirnotfound: 
4842 c1					pop bc     
4843 10 95				djnz .diritem 
4845				 
4845			.dirdone:	 
4845					if DEBUG_FORTH_WORDS 
4845						DMARK "DI7" 
4845 f5				push af  
4846 3a 5a 48			ld a, (.dmark)  
4849 32 77 fb			ld (debug_mark),a  
484c 3a 5b 48			ld a, (.dmark+1)  
484f 32 78 fb			ld (debug_mark+1),a  
4852 3a 5c 48			ld a, (.dmark+2)  
4855 32 79 fb			ld (debug_mark+2),a  
4858 18 03			jr .pastdmark  
485a ..			.dmark: db "DI7"  
485d f1			.pastdmark: pop af  
485e			endm  
# End of macro DMARK
485e						CALLMONITOR 
485e cd 49 17			call break_point_state  
4861				endm  
# End of macro CALLMONITOR
4861					endif 
4861			 
4861					; push a count of the dir items found 
4861			 
4861 26 00				ld h, 0 
4863 69					ld l, c 
4864 cd d9 1c				call forth_push_numhl 
4867			 
4867					; push the bank label 
4867			 
4867 cd bd 03				call storage_get_block_0 
486a			 
486a				 
486a 21 65 f8		 		ld hl, store_page+3 
486d			 
486d					if DEBUG_FORTH_WORDS 
486d						DMARK "DI8" 
486d f5				push af  
486e 3a 82 48			ld a, (.dmark)  
4871 32 77 fb			ld (debug_mark),a  
4874 3a 83 48			ld a, (.dmark+1)  
4877 32 78 fb			ld (debug_mark+1),a  
487a 3a 84 48			ld a, (.dmark+2)  
487d 32 79 fb			ld (debug_mark+2),a  
4880 18 03			jr .pastdmark  
4882 ..			.dmark: db "DI8"  
4885 f1			.pastdmark: pop af  
4886			endm  
# End of macro DMARK
4886						CALLMONITOR 
4886 cd 49 17			call break_point_state  
4889				endm  
# End of macro CALLMONITOR
4889					endif 
4889 cd 47 1d				call forth_push_str 
488c			 
488c			 
488c				 
488c					NEXTW 
488c c3 42 20			jp macro_next 
488f				endm 
# End of macro NEXTW
488f			.SAVE: 
488f			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
488f			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
488f			;		NEXTW 
488f			;.LOAD: 
488f			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
488f			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
488f			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
488f			;; > > The LOAD command can not be used in any user words or compound lines. 
488f			; 
488f			;		; store_openext use it. If zero it is EOF 
488f			; 
488f			;		; read block from current stream id 
488f			;		; if the block does not contain zero term keep reading blocks until zero found 
488f			;		; push the block to stack 
488f			;		; save the block id to stream 
488f			; 
488f			; 
488f			;		FORTH_DSP_VALUEHL 
488f			; 
488f			;;		push hl 
488f			; 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LOA" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;		FORTH_DSP_POP 
488f			; 
488f			;;		pop hl 
488f			; 
488f			;		ld h, l 
488f			;		ld l, 0 
488f			; 
488f			;		push hl     ; stack holds current file id and extent to work with 
488f			; 
488f			; 
488f			;		ld de, store_page      ; get block zero of file 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LO0" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;		call storage_read 
488f			; 
488f			;		ld a, (store_page+2)    ; max extents for this file 
488f			;		ld  (store_openmaxext),a   ; get our limit 
488f			; 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LOE" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			; 
488f			;; TODO dont know why max extents are not present 
488f			;;		cp 0 
488f			;;		jp z, .loadeof     ; dont read past eof 
488f			; 
488f			;;		ld a, 1   ; start from the head of the file 
488f			; 
488f			;.loadline:	pop hl 
488f			;		inc hl 
488f			;		ld  a, (store_openmaxext)   ; get our limit 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LOx" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;		inc a 
488f			;		cp l 
488f			;		jp z, .loadeof 
488f			;		push hl    ; save current extent 
488f			; 
488f			;		ld de, store_page 
488f			; 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LO1" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;		call storage_read 
488f			; 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LO2" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;	call ishlzero 
488f			;	ld a, l 
488f			;	add h 
488f			;	cp 0 
488f			;	jr z, .loadeof 
488f			; 
488f			;	; not eof so hl should point to data to exec 
488f			; 
488f			;	; will need to add the FORTH_END_BUFFER flag 
488f			 ; 
488f			;	ld hl, store_page+2 
488f			;	ld bc, 255 
488f			;	ld a, 0 
488f			;	cpir 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LOt" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;	dec hl 
488f			;	ld a, ' ' 
488f			;	ld (hl), a 
488f			;	inc hl 
488f			;	ld (hl), a 
488f			;	inc hl 
488f			;	ld (hl), a 
488f			;	inc hl 
488f			;	ld a, FORTH_END_BUFFER 
488f			;	ld (hl), a 
488f			; 
488f			;	; TODO handle more than a single block read 
488f			; 
488f			; 
488f			;	ld hl, store_page+2 
488f			; 
488f			;	ld (os_tok_ptr), hl 
488f			; 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LO3" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			; 
488f			;	call forthparse 
488f			;	call forthexec 
488f			;	call forthexec_cleanup 
488f			; 
488f			;	; go to next extent 
488f			; 
488f			;	; get next block  or mark as eof 
488f			;	jp .loadline 
488f			; 
488f			; 
488f			; 
488f			;	       NEXTW 
488f			;.loadeof:	ld a, 0 
488f			;		ld (store_openext), a 
488f			; 
488f			;	if DEBUG_STORESE 
488f			;		DMARK "LOF" 
488f			;		CALLMONITOR 
488f			;	endif 
488f			;		ret 
488f			;		;NEXTW 
488f			;.BSAVE:   
488f			; 
488f			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
488f			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
488f			;		NEXTW 
488f			;.BLOAD: 
488f			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
488f			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
488f			;		NEXTW 
488f			;;;; counter gap 
488f			 
488f			 
488f			.SEO: 
488f				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
488f 64				db WORD_SYS_CORE+80             
4890 ae 48			dw .SEI            
4892 04				db 3 + 1 
4893 .. 00			db "SEO",0              
4897				endm 
# End of macro CWHEAD
4897			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4897			 
4897					; get port 
4897			 
4897					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4897 cd d0 1e			call macro_dsp_valuehl 
489a				endm 
# End of macro FORTH_DSP_VALUEHL
489a			 
489a e5					push hl    ; u2 - byte 
489b			 
489b					; destroy value TOS 
489b			 
489b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
489b cd 88 1f			call macro_forth_dsp_pop 
489e				endm 
# End of macro FORTH_DSP_POP
489e			 
489e					; get byte to send 
489e			 
489e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
489e cd d0 1e			call macro_dsp_valuehl 
48a1				endm 
# End of macro FORTH_DSP_VALUEHL
48a1			 
48a1 e5					push hl    ; u1 - addr 
48a2			 
48a2					; destroy value TOS 
48a2			 
48a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48a2 cd 88 1f			call macro_forth_dsp_pop 
48a5				endm 
# End of macro FORTH_DSP_POP
48a5			 
48a5					; one value on hl get other one back 
48a5			 
48a5 d1					pop de   ; u1 - byte 
48a6			 
48a6 e1					pop hl   ; u2 - addr 
48a7			 
48a7					; TODO Send SPI byte 
48a7			 
48a7			 
48a7 7b					ld a, e 
48a8 cd ea 01				call se_writebyte 
48ab			 
48ab					 
48ab			 
48ab					NEXTW 
48ab c3 42 20			jp macro_next 
48ae				endm 
# End of macro NEXTW
48ae			 
48ae			.SEI: 
48ae				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48ae 65				db WORD_SYS_CORE+81             
48af c8 48			dw .SFREE            
48b1 04				db 3 + 1 
48b2 .. 00			db "SEI",0              
48b6				endm 
# End of macro CWHEAD
48b6			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48b6			 
48b6					; get port 
48b6			 
48b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48b6 cd d0 1e			call macro_dsp_valuehl 
48b9				endm 
# End of macro FORTH_DSP_VALUEHL
48b9			 
48b9			;		push hl 
48b9			 
48b9					; destroy value TOS 
48b9			 
48b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48b9 cd 88 1f			call macro_forth_dsp_pop 
48bc				endm 
# End of macro FORTH_DSP_POP
48bc			 
48bc					; one value on hl get other one back 
48bc			 
48bc			;		pop hl 
48bc			 
48bc			 
48bc					; TODO Get SPI byte 
48bc			 
48bc cd 8c 02				call se_readbyte 
48bf			 
48bf 26 00				ld h, 0 
48c1 6f					ld l, a 
48c2 cd d9 1c				call forth_push_numhl 
48c5			 
48c5					NEXTW 
48c5 c3 42 20			jp macro_next 
48c8				endm 
# End of macro NEXTW
48c8			 
48c8			.SFREE: 
48c8				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
48c8 67				db WORD_SYS_CORE+83             
48c9 f7 48			dw .SIZE            
48cb 06				db 5 + 1 
48cc .. 00			db "FFREE",0              
48d2				endm 
# End of macro CWHEAD
48d2			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
48d2					if DEBUG_FORTH_WORDS_KEY 
48d2						DMARK "FFR" 
48d2 f5				push af  
48d3 3a e7 48			ld a, (.dmark)  
48d6 32 77 fb			ld (debug_mark),a  
48d9 3a e8 48			ld a, (.dmark+1)  
48dc 32 78 fb			ld (debug_mark+1),a  
48df 3a e9 48			ld a, (.dmark+2)  
48e2 32 79 fb			ld (debug_mark+2),a  
48e5 18 03			jr .pastdmark  
48e7 ..			.dmark: db "FFR"  
48ea f1			.pastdmark: pop af  
48eb			endm  
# End of macro DMARK
48eb						CALLMONITOR 
48eb cd 49 17			call break_point_state  
48ee				endm  
# End of macro CALLMONITOR
48ee					endif 
48ee			 
48ee cd c7 06				call storage_freeblocks 
48f1			 
48f1 cd d9 1c				call forth_push_numhl 
48f4			 
48f4				       NEXTW 
48f4 c3 42 20			jp macro_next 
48f7				endm 
# End of macro NEXTW
48f7			.SIZE: 
48f7				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
48f7 67				db WORD_SYS_CORE+83             
48f8 2b 49			dw .CREATE            
48fa 05				db 4 + 1 
48fb .. 00			db "SIZE",0              
4900				endm 
# End of macro CWHEAD
4900			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4900					if DEBUG_FORTH_WORDS_KEY 
4900						DMARK "SIZ" 
4900 f5				push af  
4901 3a 15 49			ld a, (.dmark)  
4904 32 77 fb			ld (debug_mark),a  
4907 3a 16 49			ld a, (.dmark+1)  
490a 32 78 fb			ld (debug_mark+1),a  
490d 3a 17 49			ld a, (.dmark+2)  
4910 32 79 fb			ld (debug_mark+2),a  
4913 18 03			jr .pastdmark  
4915 ..			.dmark: db "SIZ"  
4918 f1			.pastdmark: pop af  
4919			endm  
# End of macro DMARK
4919						CALLMONITOR 
4919 cd 49 17			call break_point_state  
491c				endm  
# End of macro CALLMONITOR
491c					endif 
491c			 
491c					FORTH_DSP_VALUEHL 
491c cd d0 1e			call macro_dsp_valuehl 
491f				endm 
# End of macro FORTH_DSP_VALUEHL
491f			;		push hl 
491f					FORTH_DSP_POP 
491f cd 88 1f			call macro_forth_dsp_pop 
4922				endm 
# End of macro FORTH_DSP_POP
4922			;		pop hl 
4922 cd 3b 03				call storage_file_size 
4925			 
4925 cd d9 1c				call forth_push_numhl 
4928			  
4928			 
4928				       NEXTW 
4928 c3 42 20			jp macro_next 
492b				endm 
# End of macro NEXTW
492b			 
492b			.CREATE: 
492b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
492b 68				db WORD_SYS_CORE+84             
492c 99 49			dw .APPEND            
492e 07				db 6 + 1 
492f .. 00			db "CREATE",0              
4936				endm 
# End of macro CWHEAD
4936			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4936			; | | e.g.  
4936			; | | TestProgram CREATE 
4936			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4936			; | |  
4936			; | | Max file IDs are 255. 
4936			; | |  
4936					 
4936					if DEBUG_FORTH_WORDS_KEY 
4936						DMARK "CRT" 
4936 f5				push af  
4937 3a 4b 49			ld a, (.dmark)  
493a 32 77 fb			ld (debug_mark),a  
493d 3a 4c 49			ld a, (.dmark+1)  
4940 32 78 fb			ld (debug_mark+1),a  
4943 3a 4d 49			ld a, (.dmark+2)  
4946 32 79 fb			ld (debug_mark+2),a  
4949 18 03			jr .pastdmark  
494b ..			.dmark: db "CRT"  
494e f1			.pastdmark: pop af  
494f			endm  
# End of macro DMARK
494f						CALLMONITOR 
494f cd 49 17			call break_point_state  
4952				endm  
# End of macro CALLMONITOR
4952					endif 
4952			;		call storage_get_block_0 
4952			 
4952					; TODO pop hl 
4952			 
4952					;v5 FORTH_DSP_VALUE 
4952					FORTH_DSP_VALUE 
4952 cd b9 1e			call macro_forth_dsp_value 
4955				endm 
# End of macro FORTH_DSP_VALUE
4955			 
4955				if DEBUG_STORESE 
4955					DMARK "CR1" 
4955 f5				push af  
4956 3a 6a 49			ld a, (.dmark)  
4959 32 77 fb			ld (debug_mark),a  
495c 3a 6b 49			ld a, (.dmark+1)  
495f 32 78 fb			ld (debug_mark+1),a  
4962 3a 6c 49			ld a, (.dmark+2)  
4965 32 79 fb			ld (debug_mark+2),a  
4968 18 03			jr .pastdmark  
496a ..			.dmark: db "CR1"  
496d f1			.pastdmark: pop af  
496e			endm  
# End of macro DMARK
496e					CALLMONITOR 
496e cd 49 17			call break_point_state  
4971				endm  
# End of macro CALLMONITOR
4971				endif 
4971			;		push hl 
4971			;		FORTH_DSP_POP 
4971			;		pop hl 
4971			 
4971			;		inc hl   ; move past the type marker 
4971			 
4971 cd fd 06				call storage_create 
4974			 
4974				if DEBUG_STORESE 
4974					DMARK "CT1" 
4974 f5				push af  
4975 3a 89 49			ld a, (.dmark)  
4978 32 77 fb			ld (debug_mark),a  
497b 3a 8a 49			ld a, (.dmark+1)  
497e 32 78 fb			ld (debug_mark+1),a  
4981 3a 8b 49			ld a, (.dmark+2)  
4984 32 79 fb			ld (debug_mark+2),a  
4987 18 03			jr .pastdmark  
4989 ..			.dmark: db "CT1"  
498c f1			.pastdmark: pop af  
498d			endm  
# End of macro DMARK
498d					CALLMONITOR 
498d cd 49 17			call break_point_state  
4990				endm  
# End of macro CALLMONITOR
4990				endif 
4990			;		push hl 
4990					FORTH_DSP_POP 
4990 cd 88 1f			call macro_forth_dsp_pop 
4993				endm 
# End of macro FORTH_DSP_POP
4993			;		pop hl 
4993					; push file id to stack 
4993 cd d9 1c				call forth_push_numhl 
4996			 
4996			 
4996			 
4996				       NEXTW 
4996 c3 42 20			jp macro_next 
4999				endm 
# End of macro NEXTW
4999			 
4999			.APPEND: 
4999				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4999 69				db WORD_SYS_CORE+85             
499a 2a 4a			dw .SDEL            
499c 07				db 6 + 1 
499d .. 00			db "APPEND",0              
49a4				endm 
# End of macro CWHEAD
49a4			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49a4			; | | e.g. 
49a4			; | | Test CREATE      -> $01 
49a4			; | | "A string to add to file" $01 APPEND 
49a4			; | |  
49a4			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49a4					if DEBUG_FORTH_WORDS_KEY 
49a4						DMARK "APP" 
49a4 f5				push af  
49a5 3a b9 49			ld a, (.dmark)  
49a8 32 77 fb			ld (debug_mark),a  
49ab 3a ba 49			ld a, (.dmark+1)  
49ae 32 78 fb			ld (debug_mark+1),a  
49b1 3a bb 49			ld a, (.dmark+2)  
49b4 32 79 fb			ld (debug_mark+2),a  
49b7 18 03			jr .pastdmark  
49b9 ..			.dmark: db "APP"  
49bc f1			.pastdmark: pop af  
49bd			endm  
# End of macro DMARK
49bd						CALLMONITOR 
49bd cd 49 17			call break_point_state  
49c0				endm  
# End of macro CALLMONITOR
49c0					endif 
49c0			 
49c0					FORTH_DSP_VALUEHL 
49c0 cd d0 1e			call macro_dsp_valuehl 
49c3				endm 
# End of macro FORTH_DSP_VALUEHL
49c3 e5					push hl 	; save file id 
49c4			 
49c4				if DEBUG_STORESE 
49c4					DMARK "AP1" 
49c4 f5				push af  
49c5 3a d9 49			ld a, (.dmark)  
49c8 32 77 fb			ld (debug_mark),a  
49cb 3a da 49			ld a, (.dmark+1)  
49ce 32 78 fb			ld (debug_mark+1),a  
49d1 3a db 49			ld a, (.dmark+2)  
49d4 32 79 fb			ld (debug_mark+2),a  
49d7 18 03			jr .pastdmark  
49d9 ..			.dmark: db "AP1"  
49dc f1			.pastdmark: pop af  
49dd			endm  
# End of macro DMARK
49dd					CALLMONITOR 
49dd cd 49 17			call break_point_state  
49e0				endm  
# End of macro CALLMONITOR
49e0				endif 
49e0					FORTH_DSP_POP 
49e0 cd 88 1f			call macro_forth_dsp_pop 
49e3				endm 
# End of macro FORTH_DSP_POP
49e3			 
49e3					FORTH_DSP_VALUEHL 
49e3 cd d0 1e			call macro_dsp_valuehl 
49e6				endm 
# End of macro FORTH_DSP_VALUEHL
49e6					;v5 FORTH_DSP_VALUE 
49e6 e5					push hl 	; save ptr to string to save 
49e7			 
49e7				if DEBUG_STORESE 
49e7					DMARK "AP1" 
49e7 f5				push af  
49e8 3a fc 49			ld a, (.dmark)  
49eb 32 77 fb			ld (debug_mark),a  
49ee 3a fd 49			ld a, (.dmark+1)  
49f1 32 78 fb			ld (debug_mark+1),a  
49f4 3a fe 49			ld a, (.dmark+2)  
49f7 32 79 fb			ld (debug_mark+2),a  
49fa 18 03			jr .pastdmark  
49fc ..			.dmark: db "AP1"  
49ff f1			.pastdmark: pop af  
4a00			endm  
# End of macro DMARK
4a00					CALLMONITOR 
4a00 cd 49 17			call break_point_state  
4a03				endm  
# End of macro CALLMONITOR
4a03				endif 
4a03					FORTH_DSP_POP 
4a03 cd 88 1f			call macro_forth_dsp_pop 
4a06				endm 
# End of macro FORTH_DSP_POP
4a06			 
4a06 d1					pop de 
4a07 e1					pop hl 
4a08				if DEBUG_STORESE 
4a08					DMARK "AP2" 
4a08 f5				push af  
4a09 3a 1d 4a			ld a, (.dmark)  
4a0c 32 77 fb			ld (debug_mark),a  
4a0f 3a 1e 4a			ld a, (.dmark+1)  
4a12 32 78 fb			ld (debug_mark+1),a  
4a15 3a 1f 4a			ld a, (.dmark+2)  
4a18 32 79 fb			ld (debug_mark+2),a  
4a1b 18 03			jr .pastdmark  
4a1d ..			.dmark: db "AP2"  
4a20 f1			.pastdmark: pop af  
4a21			endm  
# End of macro DMARK
4a21					CALLMONITOR 
4a21 cd 49 17			call break_point_state  
4a24				endm  
# End of macro CALLMONITOR
4a24				endif 
4a24					;inc de ; skip var type indicator 
4a24			 
4a24					; TODO how to append numerics???? 
4a24			 
4a24 cd da 08				call storage_append		 
4a27			 
4a27				       NEXTW 
4a27 c3 42 20			jp macro_next 
4a2a				endm 
# End of macro NEXTW
4a2a			.SDEL: 
4a2a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a2a 6a				db WORD_SYS_CORE+86             
4a2b 76 4a			dw .OPEN            
4a2d 05				db 4 + 1 
4a2e .. 00			db "ERA",0              
4a32				endm 
# End of macro CWHEAD
4a32			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a32					FORTH_DSP_VALUEHL 
4a32 cd d0 1e			call macro_dsp_valuehl 
4a35				endm 
# End of macro FORTH_DSP_VALUEHL
4a35			;		push hl 	; save file id 
4a35			 
4a35					if DEBUG_FORTH_WORDS_KEY 
4a35						DMARK "ERA" 
4a35 f5				push af  
4a36 3a 4a 4a			ld a, (.dmark)  
4a39 32 77 fb			ld (debug_mark),a  
4a3c 3a 4b 4a			ld a, (.dmark+1)  
4a3f 32 78 fb			ld (debug_mark+1),a  
4a42 3a 4c 4a			ld a, (.dmark+2)  
4a45 32 79 fb			ld (debug_mark+2),a  
4a48 18 03			jr .pastdmark  
4a4a ..			.dmark: db "ERA"  
4a4d f1			.pastdmark: pop af  
4a4e			endm  
# End of macro DMARK
4a4e						CALLMONITOR 
4a4e cd 49 17			call break_point_state  
4a51				endm  
# End of macro CALLMONITOR
4a51					endif 
4a51				if DEBUG_STORESE 
4a51					DMARK "ER1" 
4a51 f5				push af  
4a52 3a 66 4a			ld a, (.dmark)  
4a55 32 77 fb			ld (debug_mark),a  
4a58 3a 67 4a			ld a, (.dmark+1)  
4a5b 32 78 fb			ld (debug_mark+1),a  
4a5e 3a 68 4a			ld a, (.dmark+2)  
4a61 32 79 fb			ld (debug_mark+2),a  
4a64 18 03			jr .pastdmark  
4a66 ..			.dmark: db "ER1"  
4a69 f1			.pastdmark: pop af  
4a6a			endm  
# End of macro DMARK
4a6a					CALLMONITOR 
4a6a cd 49 17			call break_point_state  
4a6d				endm  
# End of macro CALLMONITOR
4a6d				endif 
4a6d					FORTH_DSP_POP 
4a6d cd 88 1f			call macro_forth_dsp_pop 
4a70				endm 
# End of macro FORTH_DSP_POP
4a70			 
4a70			;		pop hl 
4a70			 
4a70 cd 4c 05				call storage_erase 
4a73				       NEXTW 
4a73 c3 42 20			jp macro_next 
4a76				endm 
# End of macro NEXTW
4a76			 
4a76			.OPEN: 
4a76				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a76 6b				db WORD_SYS_CORE+87             
4a77 fd 4a			dw .READ            
4a79 05				db 4 + 1 
4a7a .. 00			db "OPEN",0              
4a7f				endm 
# End of macro CWHEAD
4a7f			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a7f			; | | e.g. 
4a7f			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a7f			 
4a7f					if DEBUG_FORTH_WORDS_KEY 
4a7f						DMARK "OPN" 
4a7f f5				push af  
4a80 3a 94 4a			ld a, (.dmark)  
4a83 32 77 fb			ld (debug_mark),a  
4a86 3a 95 4a			ld a, (.dmark+1)  
4a89 32 78 fb			ld (debug_mark+1),a  
4a8c 3a 96 4a			ld a, (.dmark+2)  
4a8f 32 79 fb			ld (debug_mark+2),a  
4a92 18 03			jr .pastdmark  
4a94 ..			.dmark: db "OPN"  
4a97 f1			.pastdmark: pop af  
4a98			endm  
# End of macro DMARK
4a98						CALLMONITOR 
4a98 cd 49 17			call break_point_state  
4a9b				endm  
# End of macro CALLMONITOR
4a9b					endif 
4a9b					; TODO handle multiple file opens 
4a9b			 
4a9b 3e 01			       	ld a, 1 
4a9d 32 59 f8				ld (store_openext), a 
4aa0			 
4aa0					; get max extents for this file 
4aa0				 
4aa0								 
4aa0					FORTH_DSP_VALUEHL 
4aa0 cd d0 1e			call macro_dsp_valuehl 
4aa3				endm 
# End of macro FORTH_DSP_VALUEHL
4aa3			 
4aa3 65					ld h, l 
4aa4 2e 00				ld l, 0 
4aa6			 
4aa6				if DEBUG_STORESE 
4aa6					DMARK "OPN" 
4aa6 f5				push af  
4aa7 3a bb 4a			ld a, (.dmark)  
4aaa 32 77 fb			ld (debug_mark),a  
4aad 3a bc 4a			ld a, (.dmark+1)  
4ab0 32 78 fb			ld (debug_mark+1),a  
4ab3 3a bd 4a			ld a, (.dmark+2)  
4ab6 32 79 fb			ld (debug_mark+2),a  
4ab9 18 03			jr .pastdmark  
4abb ..			.dmark: db "OPN"  
4abe f1			.pastdmark: pop af  
4abf			endm  
# End of macro DMARK
4abf					CALLMONITOR 
4abf cd 49 17			call break_point_state  
4ac2				endm  
# End of macro CALLMONITOR
4ac2				endif 
4ac2			;		push hl 
4ac2					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4ac2 cd 88 1f			call macro_forth_dsp_pop 
4ac5				endm 
# End of macro FORTH_DSP_POP
4ac5			;		pop hl 
4ac5						 
4ac5 11 62 f8				ld de, store_page      ; get block zero of file 
4ac8 cd 53 08				call storage_read 
4acb			 
4acb			 
4acb 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4ace 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4ad1					 
4ad1				if DEBUG_STORESE 
4ad1					DMARK "OPx" 
4ad1 f5				push af  
4ad2 3a e6 4a			ld a, (.dmark)  
4ad5 32 77 fb			ld (debug_mark),a  
4ad8 3a e7 4a			ld a, (.dmark+1)  
4adb 32 78 fb			ld (debug_mark+1),a  
4ade 3a e8 4a			ld a, (.dmark+2)  
4ae1 32 79 fb			ld (debug_mark+2),a  
4ae4 18 03			jr .pastdmark  
4ae6 ..			.dmark: db "OPx"  
4ae9 f1			.pastdmark: pop af  
4aea			endm  
# End of macro DMARK
4aea					CALLMONITOR 
4aea cd 49 17			call break_point_state  
4aed				endm  
# End of macro CALLMONITOR
4aed				endif 
4aed fe 00				cp 0 
4aef 20 03				jr nz, .skipopeneof 
4af1					; have opened an empty file 
4af1					 
4af1 32 59 f8				ld (store_openext), a 
4af4			 
4af4			.skipopeneof: 
4af4			 
4af4 6f					ld l, a 
4af5 26 00				ld h, 0 
4af7 cd d9 1c				call forth_push_numhl 
4afa			 
4afa			 
4afa				       NEXTW 
4afa c3 42 20			jp macro_next 
4afd				endm 
# End of macro NEXTW
4afd			.READ: 
4afd				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4afd 6c				db WORD_SYS_CORE+88             
4afe 44 4c			dw .EOF            
4b00 05				db 4 + 1 
4b01 .. 00			db "READ",0              
4b06				endm 
# End of macro CWHEAD
4b06			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b06			; | | e.g. 
4b06			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b06			 
4b06					if DEBUG_FORTH_WORDS_KEY 
4b06						DMARK "REA" 
4b06 f5				push af  
4b07 3a 1b 4b			ld a, (.dmark)  
4b0a 32 77 fb			ld (debug_mark),a  
4b0d 3a 1c 4b			ld a, (.dmark+1)  
4b10 32 78 fb			ld (debug_mark+1),a  
4b13 3a 1d 4b			ld a, (.dmark+2)  
4b16 32 79 fb			ld (debug_mark+2),a  
4b19 18 03			jr .pastdmark  
4b1b ..			.dmark: db "REA"  
4b1e f1			.pastdmark: pop af  
4b1f			endm  
# End of macro DMARK
4b1f						CALLMONITOR 
4b1f cd 49 17			call break_point_state  
4b22				endm  
# End of macro CALLMONITOR
4b22					endif 
4b22					; store_openext use it. If zero it is EOF 
4b22			 
4b22					; read block from current stream id 
4b22					; if the block does not contain zero term keep reading blocks until zero found 
4b22					; push the block to stack 
4b22					; save the block id to stream 
4b22			 
4b22			 
4b22					FORTH_DSP_VALUEHL 
4b22 cd d0 1e			call macro_dsp_valuehl 
4b25				endm 
# End of macro FORTH_DSP_VALUEHL
4b25			 
4b25			;		push hl 
4b25			 
4b25				if DEBUG_STORESE 
4b25					DMARK "REA" 
4b25 f5				push af  
4b26 3a 3a 4b			ld a, (.dmark)  
4b29 32 77 fb			ld (debug_mark),a  
4b2c 3a 3b 4b			ld a, (.dmark+1)  
4b2f 32 78 fb			ld (debug_mark+1),a  
4b32 3a 3c 4b			ld a, (.dmark+2)  
4b35 32 79 fb			ld (debug_mark+2),a  
4b38 18 03			jr .pastdmark  
4b3a ..			.dmark: db "REA"  
4b3d f1			.pastdmark: pop af  
4b3e			endm  
# End of macro DMARK
4b3e					CALLMONITOR 
4b3e cd 49 17			call break_point_state  
4b41				endm  
# End of macro CALLMONITOR
4b41				endif 
4b41					FORTH_DSP_POP 
4b41 cd 88 1f			call macro_forth_dsp_pop 
4b44				endm 
# End of macro FORTH_DSP_POP
4b44			 
4b44			;		pop hl 
4b44				 
4b44 65					ld h,l 
4b45			 
4b45 3a 59 f8				ld a, (store_openext) 
4b48 6f					ld l, a 
4b49					 
4b49 fe 00				cp 0 
4b4b ca 16 4c				jp z, .ateof     ; dont read past eof 
4b4e			 
4b4e			 
4b4e 11 62 f8				ld de, store_page 
4b51				if DEBUG_STORESE 
4b51					DMARK "RE1" 
4b51 f5				push af  
4b52 3a 66 4b			ld a, (.dmark)  
4b55 32 77 fb			ld (debug_mark),a  
4b58 3a 67 4b			ld a, (.dmark+1)  
4b5b 32 78 fb			ld (debug_mark+1),a  
4b5e 3a 68 4b			ld a, (.dmark+2)  
4b61 32 79 fb			ld (debug_mark+2),a  
4b64 18 03			jr .pastdmark  
4b66 ..			.dmark: db "RE1"  
4b69 f1			.pastdmark: pop af  
4b6a			endm  
# End of macro DMARK
4b6a					CALLMONITOR 
4b6a cd 49 17			call break_point_state  
4b6d				endm  
# End of macro CALLMONITOR
4b6d				endif 
4b6d cd 53 08				call storage_read 
4b70			 
4b70				if DEBUG_STORESE 
4b70					DMARK "RE2" 
4b70 f5				push af  
4b71 3a 85 4b			ld a, (.dmark)  
4b74 32 77 fb			ld (debug_mark),a  
4b77 3a 86 4b			ld a, (.dmark+1)  
4b7a 32 78 fb			ld (debug_mark+1),a  
4b7d 3a 87 4b			ld a, (.dmark+2)  
4b80 32 79 fb			ld (debug_mark+2),a  
4b83 18 03			jr .pastdmark  
4b85 ..			.dmark: db "RE2"  
4b88 f1			.pastdmark: pop af  
4b89			endm  
# End of macro DMARK
4b89					CALLMONITOR 
4b89 cd 49 17			call break_point_state  
4b8c				endm  
# End of macro CALLMONITOR
4b8c				endif 
4b8c cd 35 0d			call ishlzero 
4b8f			;	ld a, l 
4b8f			;	add h 
4b8f			;	cp 0 
4b8f ca 1c 4c			jp z, .readeof 
4b92			 
4b92				; not eof so hl should point to data to push to stack 
4b92			 
4b92				if DEBUG_STORESE 
4b92					DMARK "RE3" 
4b92 f5				push af  
4b93 3a a7 4b			ld a, (.dmark)  
4b96 32 77 fb			ld (debug_mark),a  
4b99 3a a8 4b			ld a, (.dmark+1)  
4b9c 32 78 fb			ld (debug_mark+1),a  
4b9f 3a a9 4b			ld a, (.dmark+2)  
4ba2 32 79 fb			ld (debug_mark+2),a  
4ba5 18 03			jr .pastdmark  
4ba7 ..			.dmark: db "RE3"  
4baa f1			.pastdmark: pop af  
4bab			endm  
# End of macro DMARK
4bab					CALLMONITOR 
4bab cd 49 17			call break_point_state  
4bae				endm  
# End of macro CALLMONITOR
4bae				endif 
4bae cd 47 1d			call forth_push_str 
4bb1			 
4bb1				if DEBUG_STORESE 
4bb1					DMARK "RE4" 
4bb1 f5				push af  
4bb2 3a c6 4b			ld a, (.dmark)  
4bb5 32 77 fb			ld (debug_mark),a  
4bb8 3a c7 4b			ld a, (.dmark+1)  
4bbb 32 78 fb			ld (debug_mark+1),a  
4bbe 3a c8 4b			ld a, (.dmark+2)  
4bc1 32 79 fb			ld (debug_mark+2),a  
4bc4 18 03			jr .pastdmark  
4bc6 ..			.dmark: db "RE4"  
4bc9 f1			.pastdmark: pop af  
4bca			endm  
# End of macro DMARK
4bca					CALLMONITOR 
4bca cd 49 17			call break_point_state  
4bcd				endm  
# End of macro CALLMONITOR
4bcd				endif 
4bcd				; get next block  or mark as eof 
4bcd			 
4bcd 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4bd0 4f				ld c, a	 
4bd1 3a 59 f8			ld a, (store_openext) 
4bd4			 
4bd4				if DEBUG_STORESE 
4bd4					DMARK "RE5" 
4bd4 f5				push af  
4bd5 3a e9 4b			ld a, (.dmark)  
4bd8 32 77 fb			ld (debug_mark),a  
4bdb 3a ea 4b			ld a, (.dmark+1)  
4bde 32 78 fb			ld (debug_mark+1),a  
4be1 3a eb 4b			ld a, (.dmark+2)  
4be4 32 79 fb			ld (debug_mark+2),a  
4be7 18 03			jr .pastdmark  
4be9 ..			.dmark: db "RE5"  
4bec f1			.pastdmark: pop af  
4bed			endm  
# End of macro DMARK
4bed					CALLMONITOR 
4bed cd 49 17			call break_point_state  
4bf0				endm  
# End of macro CALLMONITOR
4bf0				endif 
4bf0 b9				cp c 
4bf1 28 29			jr z, .readeof     ; at last extent 
4bf3			 
4bf3 3c					inc a 
4bf4 32 59 f8				ld (store_openext), a 
4bf7			 
4bf7				if DEBUG_STORESE 
4bf7					DMARK "RE6" 
4bf7 f5				push af  
4bf8 3a 0c 4c			ld a, (.dmark)  
4bfb 32 77 fb			ld (debug_mark),a  
4bfe 3a 0d 4c			ld a, (.dmark+1)  
4c01 32 78 fb			ld (debug_mark+1),a  
4c04 3a 0e 4c			ld a, (.dmark+2)  
4c07 32 79 fb			ld (debug_mark+2),a  
4c0a 18 03			jr .pastdmark  
4c0c ..			.dmark: db "RE6"  
4c0f f1			.pastdmark: pop af  
4c10			endm  
# End of macro DMARK
4c10					CALLMONITOR 
4c10 cd 49 17			call break_point_state  
4c13				endm  
# End of macro CALLMONITOR
4c13				endif 
4c13			 
4c13			 
4c13				       NEXTW 
4c13 c3 42 20			jp macro_next 
4c16				endm 
# End of macro NEXTW
4c16			.ateof: 
4c16 21 40 4c				ld hl, .showeof 
4c19 cd 47 1d				call forth_push_str 
4c1c 3e 00		.readeof:	ld a, 0 
4c1e 32 59 f8				ld (store_openext), a 
4c21			 
4c21					 
4c21				if DEBUG_STORESE 
4c21					DMARK "REF" 
4c21 f5				push af  
4c22 3a 36 4c			ld a, (.dmark)  
4c25 32 77 fb			ld (debug_mark),a  
4c28 3a 37 4c			ld a, (.dmark+1)  
4c2b 32 78 fb			ld (debug_mark+1),a  
4c2e 3a 38 4c			ld a, (.dmark+2)  
4c31 32 79 fb			ld (debug_mark+2),a  
4c34 18 03			jr .pastdmark  
4c36 ..			.dmark: db "REF"  
4c39 f1			.pastdmark: pop af  
4c3a			endm  
# End of macro DMARK
4c3a					CALLMONITOR 
4c3a cd 49 17			call break_point_state  
4c3d				endm  
# End of macro CALLMONITOR
4c3d				endif 
4c3d				       NEXTW 
4c3d c3 42 20			jp macro_next 
4c40				endm 
# End of macro NEXTW
4c40			 
4c40 .. 00		.showeof:   db "eof", 0 
4c44			 
4c44			 
4c44			.EOF: 
4c44				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c44 6d				db WORD_SYS_CORE+89             
4c45 85 4c			dw .FORMAT            
4c47 04				db 3 + 1 
4c48 .. 00			db "EOF",0              
4c4c				endm 
# End of macro CWHEAD
4c4c			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c4c			; | | e.g. 
4c4c			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c4c					; TODO if current block id for stream is zero then push true else false 
4c4c			 
4c4c					if DEBUG_FORTH_WORDS_KEY 
4c4c						DMARK "EOF" 
4c4c f5				push af  
4c4d 3a 61 4c			ld a, (.dmark)  
4c50 32 77 fb			ld (debug_mark),a  
4c53 3a 62 4c			ld a, (.dmark+1)  
4c56 32 78 fb			ld (debug_mark+1),a  
4c59 3a 63 4c			ld a, (.dmark+2)  
4c5c 32 79 fb			ld (debug_mark+2),a  
4c5f 18 03			jr .pastdmark  
4c61 ..			.dmark: db "EOF"  
4c64 f1			.pastdmark: pop af  
4c65			endm  
# End of macro DMARK
4c65						CALLMONITOR 
4c65 cd 49 17			call break_point_state  
4c68				endm  
# End of macro CALLMONITOR
4c68					endif 
4c68			 
4c68					; TODO handlue multiple file streams 
4c68			 
4c68					FORTH_DSP_POP     ; for now just get rid of stream id 
4c68 cd 88 1f			call macro_forth_dsp_pop 
4c6b				endm 
# End of macro FORTH_DSP_POP
4c6b			 
4c6b 2e 01				ld l, 1 
4c6d 3a 58 f8				ld a, (store_openmaxext) 
4c70 fe 00				cp 0 
4c72 28 09				jr  z, .eofdone   ; empty file 
4c74 3a 59 f8				ld a, (store_openext) 
4c77 fe 00				cp 0 
4c79 28 02				jr  z, .eofdone 
4c7b 2e 00				ld l, 0 
4c7d 26 00		.eofdone:	ld h, 0 
4c7f cd d9 1c				call forth_push_numhl 
4c82			 
4c82			 
4c82				       NEXTW 
4c82 c3 42 20			jp macro_next 
4c85				endm 
# End of macro NEXTW
4c85			 
4c85			.FORMAT: 
4c85				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4c85 6d				db WORD_SYS_CORE+89             
4c86 d6 4c			dw .LABEL            
4c88 07				db 6 + 1 
4c89 .. 00			db "FORMAT",0              
4c90				endm 
# End of macro CWHEAD
4c90			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4c90					; TODO if current block id for stream is zero then push true else false 
4c90				 
4c90				if DEBUG_STORESE 
4c90					DMARK "FOR" 
4c90 f5				push af  
4c91 3a a5 4c			ld a, (.dmark)  
4c94 32 77 fb			ld (debug_mark),a  
4c97 3a a6 4c			ld a, (.dmark+1)  
4c9a 32 78 fb			ld (debug_mark+1),a  
4c9d 3a a7 4c			ld a, (.dmark+2)  
4ca0 32 79 fb			ld (debug_mark+2),a  
4ca3 18 03			jr .pastdmark  
4ca5 ..			.dmark: db "FOR"  
4ca8 f1			.pastdmark: pop af  
4ca9			endm  
# End of macro DMARK
4ca9					CALLMONITOR 
4ca9 cd 49 17			call break_point_state  
4cac				endm  
# End of macro CALLMONITOR
4cac				endif 
4cac					; Wipes the bank check flags to cause a reformat on next block 0 read 
4cac			 
4cac 21 01 00				ld hl, 1 
4caf 3e 00				ld a, 0 
4cb1 cd ea 01				call se_writebyte 
4cb4			 
4cb4				if DEBUG_STORESE 
4cb4					DMARK "FO0" 
4cb4 f5				push af  
4cb5 3a c9 4c			ld a, (.dmark)  
4cb8 32 77 fb			ld (debug_mark),a  
4cbb 3a ca 4c			ld a, (.dmark+1)  
4cbe 32 78 fb			ld (debug_mark+1),a  
4cc1 3a cb 4c			ld a, (.dmark+2)  
4cc4 32 79 fb			ld (debug_mark+2),a  
4cc7 18 03			jr .pastdmark  
4cc9 ..			.dmark: db "FO0"  
4ccc f1			.pastdmark: pop af  
4ccd			endm  
# End of macro DMARK
4ccd					CALLMONITOR 
4ccd cd 49 17			call break_point_state  
4cd0				endm  
# End of macro CALLMONITOR
4cd0				endif 
4cd0					; force bank init 
4cd0			 
4cd0 cd bd 03				call storage_get_block_0 
4cd3					 
4cd3				       NEXTW 
4cd3 c3 42 20			jp macro_next 
4cd6				endm 
# End of macro NEXTW
4cd6			.LABEL: 
4cd6				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4cd6 6d				db WORD_SYS_CORE+89             
4cd7 24 4d			dw .STOREPAGE            
4cd9 06				db 5 + 1 
4cda .. 00			db "LABEL",0              
4ce0				endm 
# End of macro CWHEAD
4ce0			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4ce0					; TODO test to see if bank is selected 
4ce0				 
4ce0					if DEBUG_FORTH_WORDS_KEY 
4ce0						DMARK "LBL" 
4ce0 f5				push af  
4ce1 3a f5 4c			ld a, (.dmark)  
4ce4 32 77 fb			ld (debug_mark),a  
4ce7 3a f6 4c			ld a, (.dmark+1)  
4cea 32 78 fb			ld (debug_mark+1),a  
4ced 3a f7 4c			ld a, (.dmark+2)  
4cf0 32 79 fb			ld (debug_mark+2),a  
4cf3 18 03			jr .pastdmark  
4cf5 ..			.dmark: db "LBL"  
4cf8 f1			.pastdmark: pop af  
4cf9			endm  
# End of macro DMARK
4cf9						CALLMONITOR 
4cf9 cd 49 17			call break_point_state  
4cfc				endm  
# End of macro CALLMONITOR
4cfc					endif 
4cfc			;	if DEBUG_STORESE 
4cfc			;		DMARK "LBL" 
4cfc			;		CALLMONITOR 
4cfc			;	endif 
4cfc					FORTH_DSP_VALUEHL 
4cfc cd d0 1e			call macro_dsp_valuehl 
4cff				endm 
# End of macro FORTH_DSP_VALUEHL
4cff					;v5FORTH_DSP_VALUE 
4cff					 
4cff			;		push hl 
4cff					FORTH_DSP_POP 
4cff cd 88 1f			call macro_forth_dsp_pop 
4d02				endm 
# End of macro FORTH_DSP_POP
4d02			;		pop hl 
4d02			 
4d02			;v5		inc hl   ; move past the type marker 
4d02			 
4d02				if DEBUG_STORESE 
4d02					DMARK "LBl" 
4d02 f5				push af  
4d03 3a 17 4d			ld a, (.dmark)  
4d06 32 77 fb			ld (debug_mark),a  
4d09 3a 18 4d			ld a, (.dmark+1)  
4d0c 32 78 fb			ld (debug_mark+1),a  
4d0f 3a 19 4d			ld a, (.dmark+2)  
4d12 32 79 fb			ld (debug_mark+2),a  
4d15 18 03			jr .pastdmark  
4d17 ..			.dmark: db "LBl"  
4d1a f1			.pastdmark: pop af  
4d1b			endm  
# End of macro DMARK
4d1b					CALLMONITOR 
4d1b cd 49 17			call break_point_state  
4d1e				endm  
# End of macro CALLMONITOR
4d1e				endif 
4d1e cd e1 04				call storage_label 
4d21			 
4d21				       NEXTW 
4d21 c3 42 20			jp macro_next 
4d24				endm 
# End of macro NEXTW
4d24			.STOREPAGE: 
4d24				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d24 6d				db WORD_SYS_CORE+89             
4d25 57 4d			dw .LABELS            
4d27 0a				db 9 + 1 
4d28 .. 00			db "STOREPAGE",0              
4d32				endm 
# End of macro CWHEAD
4d32			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d32					; TODO test to see if bank is selected 
4d32				 
4d32					if DEBUG_FORTH_WORDS_KEY 
4d32						DMARK "STP" 
4d32 f5				push af  
4d33 3a 47 4d			ld a, (.dmark)  
4d36 32 77 fb			ld (debug_mark),a  
4d39 3a 48 4d			ld a, (.dmark+1)  
4d3c 32 78 fb			ld (debug_mark+1),a  
4d3f 3a 49 4d			ld a, (.dmark+2)  
4d42 32 79 fb			ld (debug_mark+2),a  
4d45 18 03			jr .pastdmark  
4d47 ..			.dmark: db "STP"  
4d4a f1			.pastdmark: pop af  
4d4b			endm  
# End of macro DMARK
4d4b						CALLMONITOR 
4d4b cd 49 17			call break_point_state  
4d4e				endm  
# End of macro CALLMONITOR
4d4e					endif 
4d4e			;	if DEBUG_STORESE 
4d4e			;		DMARK "STP" 
4d4e			;		CALLMONITOR 
4d4e			;	endif 
4d4e			 
4d4e 21 62 f8			ld hl, store_page 
4d51 cd d9 1c			call forth_push_numhl 
4d54			 
4d54			 
4d54				       NEXTW 
4d54 c3 42 20			jp macro_next 
4d57				endm 
# End of macro NEXTW
4d57			.LABELS: 
4d57				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d57 6d				db WORD_SYS_CORE+89             
4d58 e1 4d			dw .ENDSTORAGE            
4d5a 07				db 6 + 1 
4d5b .. 00			db "LABELS",0              
4d62				endm 
# End of macro CWHEAD
4d62			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d62					;  
4d62			 
4d62					; save the current device selected to restore afterwards 
4d62				 
4d62 3a 48 f8				ld a, (spi_device) 
4d65 f5					push af 
4d66			 
4d66			 
4d66					; run through each of the banks 
4d66			 
4d66 21 01 00				ld hl, 1 
4d69 cd d9 1c				call forth_push_numhl 
4d6c 3e ff				ld a, SPI_CE_HIGH 
4d6e cb 87				res SPI_CE0, a 
4d70 32 48 f8				ld (spi_device), a 
4d73 cd bd 03				call storage_get_block_0 
4d76 21 65 f8				ld hl, store_page+3 
4d79 cd 47 1d				call forth_push_str 
4d7c			 
4d7c					 
4d7c 21 02 00				ld hl, 2 
4d7f cd d9 1c				call forth_push_numhl 
4d82 3e ff				ld a, SPI_CE_HIGH 
4d84 cb 8f				res SPI_CE1, a 
4d86 32 48 f8				ld (spi_device), a 
4d89 cd bd 03				call storage_get_block_0 
4d8c 21 65 f8				ld hl, store_page+3 
4d8f cd 47 1d				call forth_push_str 
4d92			 
4d92					 
4d92 21 03 00				ld hl, 3 
4d95 cd d9 1c				call forth_push_numhl 
4d98 3e ff				ld a, SPI_CE_HIGH 
4d9a cb 97				res SPI_CE2, a 
4d9c 32 48 f8				ld (spi_device), a 
4d9f cd bd 03				call storage_get_block_0 
4da2 21 65 f8				ld hl, store_page+3 
4da5 cd 47 1d				call forth_push_str 
4da8			 
4da8			 
4da8 21 04 00				ld hl, 4 
4dab cd d9 1c				call forth_push_numhl 
4dae 3e ff				ld a, SPI_CE_HIGH 
4db0 cb 9f				res SPI_CE3, a 
4db2 32 48 f8				ld (spi_device), a 
4db5 cd bd 03				call storage_get_block_0 
4db8 21 65 f8				ld hl, store_page+3 
4dbb cd 47 1d				call forth_push_str 
4dbe			 
4dbe					 
4dbe			 
4dbe 21 05 00				ld hl, 5 
4dc1 cd d9 1c				call forth_push_numhl 
4dc4 3e ff				ld a, SPI_CE_HIGH 
4dc6 cb a7				res SPI_CE4, a 
4dc8 32 48 f8				ld (spi_device), a 
4dcb cd bd 03				call storage_get_block_0 
4dce 21 65 f8				ld hl, store_page+3 
4dd1 cd 47 1d				call forth_push_str 
4dd4			 
4dd4					 
4dd4					; push fixed count of storage devices (on board) for now 
4dd4			 
4dd4 21 05 00				ld hl, 5 
4dd7 cd d9 1c				call forth_push_numhl 
4dda			 
4dda					; restore selected device  
4dda				 
4dda f1					pop af 
4ddb 32 48 f8				ld (spi_device), a 
4dde			 
4dde				       NEXTW 
4dde c3 42 20			jp macro_next 
4de1				endm 
# End of macro NEXTW
4de1			 
4de1			.ENDSTORAGE: 
4de1			; eof 
# End of file forth_words_storage.asm
4de1			endif 
4de1				include "forth_words_device.asm" 
4de1			; Device related words 
4de1			 
4de1			; | ## Device Words 
4de1			 
4de1			if SOUND_ENABLE 
4de1			.NOTE: 
4de1				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4de1 33				db WORD_SYS_CORE+31             
4de2 09 4e			dw .AFTERSOUND            
4de4 05				db 4 + 1 
4de5 .. 00			db "NOTE",0              
4dea				endm 
# End of macro CWHEAD
4dea			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4dea					if DEBUG_FORTH_WORDS_KEY 
4dea						DMARK "NTE" 
4dea f5				push af  
4deb 3a ff 4d			ld a, (.dmark)  
4dee 32 77 fb			ld (debug_mark),a  
4df1 3a 00 4e			ld a, (.dmark+1)  
4df4 32 78 fb			ld (debug_mark+1),a  
4df7 3a 01 4e			ld a, (.dmark+2)  
4dfa 32 79 fb			ld (debug_mark+2),a  
4dfd 18 03			jr .pastdmark  
4dff ..			.dmark: db "NTE"  
4e02 f1			.pastdmark: pop af  
4e03			endm  
# End of macro DMARK
4e03						CALLMONITOR 
4e03 cd 49 17			call break_point_state  
4e06				endm  
# End of macro CALLMONITOR
4e06					endif 
4e06			 
4e06				 
4e06			 
4e06					NEXTW 
4e06 c3 42 20			jp macro_next 
4e09				endm 
# End of macro NEXTW
4e09			.AFTERSOUND: 
4e09			endif 
4e09			 
4e09			 
4e09			USE_GPIO: equ 0 
4e09			 
4e09			if USE_GPIO 
4e09			.GP1: 
4e09				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e09			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e09					NEXTW 
4e09			.GP2: 
4e09				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e09			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e09			 
4e09					NEXTW 
4e09			 
4e09			.GP3: 
4e09				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e09			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e09			 
4e09					NEXTW 
4e09			 
4e09			.GP4: 
4e09				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e09			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e09			 
4e09					NEXTW 
4e09			.SIN: 
4e09			 
4e09			 
4e09			endif 
4e09			 
4e09			 
4e09				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e09 33				db WORD_SYS_CORE+31             
4e0a 3e 4e			dw .SOUT            
4e0c 03				db 2 + 1 
4e0d .. 00			db "IN",0              
4e10				endm 
# End of macro CWHEAD
4e10			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e10					if DEBUG_FORTH_WORDS_KEY 
4e10						DMARK "IN." 
4e10 f5				push af  
4e11 3a 25 4e			ld a, (.dmark)  
4e14 32 77 fb			ld (debug_mark),a  
4e17 3a 26 4e			ld a, (.dmark+1)  
4e1a 32 78 fb			ld (debug_mark+1),a  
4e1d 3a 27 4e			ld a, (.dmark+2)  
4e20 32 79 fb			ld (debug_mark+2),a  
4e23 18 03			jr .pastdmark  
4e25 ..			.dmark: db "IN."  
4e28 f1			.pastdmark: pop af  
4e29			endm  
# End of macro DMARK
4e29						CALLMONITOR 
4e29 cd 49 17			call break_point_state  
4e2c				endm  
# End of macro CALLMONITOR
4e2c					endif 
4e2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e2c cd d0 1e			call macro_dsp_valuehl 
4e2f				endm 
# End of macro FORTH_DSP_VALUEHL
4e2f			 
4e2f e5					push hl 
4e30			 
4e30					; destroy value TOS 
4e30			 
4e30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e30 cd 88 1f			call macro_forth_dsp_pop 
4e33				endm 
# End of macro FORTH_DSP_POP
4e33			 
4e33					; one value on hl get other one back 
4e33			 
4e33 c1					pop bc 
4e34			 
4e34					; do the sub 
4e34			;		ex de, hl 
4e34			 
4e34 ed 68				in l,(c) 
4e36			 
4e36					; save it 
4e36			 
4e36 26 00				ld h,0 
4e38			 
4e38					; TODO push value back onto stack for another op etc 
4e38			 
4e38 cd d9 1c				call forth_push_numhl 
4e3b					NEXTW 
4e3b c3 42 20			jp macro_next 
4e3e				endm 
# End of macro NEXTW
4e3e			.SOUT: 
4e3e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e3e 34				db WORD_SYS_CORE+32             
4e3f 91 4e			dw .SPIO            
4e41 04				db 3 + 1 
4e42 .. 00			db "OUT",0              
4e46				endm 
# End of macro CWHEAD
4e46			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e46					if DEBUG_FORTH_WORDS_KEY 
4e46						DMARK "OUT" 
4e46 f5				push af  
4e47 3a 5b 4e			ld a, (.dmark)  
4e4a 32 77 fb			ld (debug_mark),a  
4e4d 3a 5c 4e			ld a, (.dmark+1)  
4e50 32 78 fb			ld (debug_mark+1),a  
4e53 3a 5d 4e			ld a, (.dmark+2)  
4e56 32 79 fb			ld (debug_mark+2),a  
4e59 18 03			jr .pastdmark  
4e5b ..			.dmark: db "OUT"  
4e5e f1			.pastdmark: pop af  
4e5f			endm  
# End of macro DMARK
4e5f						CALLMONITOR 
4e5f cd 49 17			call break_point_state  
4e62				endm  
# End of macro CALLMONITOR
4e62					endif 
4e62			 
4e62					; get port 
4e62			 
4e62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e62 cd d0 1e			call macro_dsp_valuehl 
4e65				endm 
# End of macro FORTH_DSP_VALUEHL
4e65			 
4e65 e5					push hl 
4e66			 
4e66					; destroy value TOS 
4e66			 
4e66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e66 cd 88 1f			call macro_forth_dsp_pop 
4e69				endm 
# End of macro FORTH_DSP_POP
4e69			 
4e69					; get byte to send 
4e69			 
4e69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e69 cd d0 1e			call macro_dsp_valuehl 
4e6c				endm 
# End of macro FORTH_DSP_VALUEHL
4e6c			 
4e6c			;		push hl 
4e6c			 
4e6c					; destroy value TOS 
4e6c			 
4e6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e6c cd 88 1f			call macro_forth_dsp_pop 
4e6f				endm 
# End of macro FORTH_DSP_POP
4e6f			 
4e6f					; one value on hl get other one back 
4e6f			 
4e6f			;		pop hl 
4e6f			 
4e6f c1					pop bc 
4e70			 
4e70					if DEBUG_FORTH_WORDS 
4e70						DMARK "OUT" 
4e70 f5				push af  
4e71 3a 85 4e			ld a, (.dmark)  
4e74 32 77 fb			ld (debug_mark),a  
4e77 3a 86 4e			ld a, (.dmark+1)  
4e7a 32 78 fb			ld (debug_mark+1),a  
4e7d 3a 87 4e			ld a, (.dmark+2)  
4e80 32 79 fb			ld (debug_mark+2),a  
4e83 18 03			jr .pastdmark  
4e85 ..			.dmark: db "OUT"  
4e88 f1			.pastdmark: pop af  
4e89			endm  
# End of macro DMARK
4e89						CALLMONITOR 
4e89 cd 49 17			call break_point_state  
4e8c				endm  
# End of macro CALLMONITOR
4e8c					endif 
4e8c			 
4e8c ed 69				out (c), l 
4e8e			 
4e8e					NEXTW 
4e8e c3 42 20			jp macro_next 
4e91				endm 
# End of macro NEXTW
4e91			 
4e91			 
4e91			.SPIO: 
4e91			 
4e91			if STORAGE_SE 
4e91				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4e91 51				db WORD_SYS_CORE+61             
4e92 a2 4e			dw .SPICEH            
4e94 07				db 6 + 1 
4e95 .. 00			db "SPICEL",0              
4e9c				endm 
# End of macro CWHEAD
4e9c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4e9c			 
4e9c cd 98 01				call spi_ce_low 
4e9f			    NEXTW 
4e9f c3 42 20			jp macro_next 
4ea2				endm 
# End of macro NEXTW
4ea2			 
4ea2			.SPICEH: 
4ea2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ea2 51				db WORD_SYS_CORE+61             
4ea3 b3 4e			dw .SPIOb            
4ea5 07				db 6 + 1 
4ea6 .. 00			db "SPICEH",0              
4ead				endm 
# End of macro CWHEAD
4ead			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ead			 
4ead cd 87 01				call spi_ce_high 
4eb0			    NEXTW 
4eb0 c3 42 20			jp macro_next 
4eb3				endm 
# End of macro NEXTW
4eb3			 
4eb3			 
4eb3			.SPIOb: 
4eb3			 
4eb3				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4eb3 51				db WORD_SYS_CORE+61             
4eb4 c9 4e			dw .SPII            
4eb6 05				db 4 + 1 
4eb7 .. 00			db "SPIO",0              
4ebc				endm 
# End of macro CWHEAD
4ebc			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4ebc			 
4ebc					; get port 
4ebc			 
4ebc			 
4ebc					; get byte to send 
4ebc			 
4ebc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ebc cd d0 1e			call macro_dsp_valuehl 
4ebf				endm 
# End of macro FORTH_DSP_VALUEHL
4ebf			 
4ebf			;		push hl    ; u1  
4ebf			 
4ebf					; destroy value TOS 
4ebf			 
4ebf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ebf cd 88 1f			call macro_forth_dsp_pop 
4ec2				endm 
# End of macro FORTH_DSP_POP
4ec2			 
4ec2					; one value on hl get other one back 
4ec2			 
4ec2			;		pop hl   ; u2 - addr 
4ec2			 
4ec2					; TODO Send SPI byte 
4ec2			 
4ec2 7d					ld a, l 
4ec3 cd bc 00				call spi_send_byte 
4ec6			 
4ec6					NEXTW 
4ec6 c3 42 20			jp macro_next 
4ec9				endm 
# End of macro NEXTW
4ec9			 
4ec9			.SPII: 
4ec9				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ec9 52				db WORD_SYS_CORE+62             
4eca de 4e			dw .SESEL            
4ecc 06				db 5 + 1 
4ecd .. 00			db "SPII",0              
4ed2				endm 
# End of macro CWHEAD
4ed2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ed2			 
4ed2					; TODO Get SPI byte 
4ed2			 
4ed2 cd dd 00				call spi_read_byte 
4ed5			 
4ed5 26 00				ld h, 0 
4ed7 6f					ld l, a 
4ed8 cd d9 1c				call forth_push_numhl 
4edb			 
4edb					NEXTW 
4edb c3 42 20			jp macro_next 
4ede				endm 
# End of macro NEXTW
4ede			 
4ede			 
4ede			 
4ede			.SESEL: 
4ede				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4ede 66				db WORD_SYS_CORE+82             
4edf 82 4f			dw .CARTDEV            
4ee1 05				db 4 + 1 
4ee2 .. 00			db "BANK",0              
4ee7				endm 
# End of macro CWHEAD
4ee7			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4ee7					if DEBUG_FORTH_WORDS_KEY 
4ee7						DMARK "BNK" 
4ee7 f5				push af  
4ee8 3a fc 4e			ld a, (.dmark)  
4eeb 32 77 fb			ld (debug_mark),a  
4eee 3a fd 4e			ld a, (.dmark+1)  
4ef1 32 78 fb			ld (debug_mark+1),a  
4ef4 3a fe 4e			ld a, (.dmark+2)  
4ef7 32 79 fb			ld (debug_mark+2),a  
4efa 18 03			jr .pastdmark  
4efc ..			.dmark: db "BNK"  
4eff f1			.pastdmark: pop af  
4f00			endm  
# End of macro DMARK
4f00						CALLMONITOR 
4f00 cd 49 17			call break_point_state  
4f03				endm  
# End of macro CALLMONITOR
4f03					endif 
4f03			 
4f03 3e ff				ld a, 255 
4f05 32 4b f8				ld (spi_cartdev), a 
4f08			 
4f08					; get bank 
4f08			 
4f08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f08 cd d0 1e			call macro_dsp_valuehl 
4f0b				endm 
# End of macro FORTH_DSP_VALUEHL
4f0b			 
4f0b			;		push hl 
4f0b			 
4f0b					; destroy value TOS 
4f0b			 
4f0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f0b cd 88 1f			call macro_forth_dsp_pop 
4f0e				endm 
# End of macro FORTH_DSP_POP
4f0e			 
4f0e					; one value on hl get other one back 
4f0e			 
4f0e			;		pop hl 
4f0e			 
4f0e			 
4f0e 0e ff				ld c, SPI_CE_HIGH 
4f10 06 30				ld b, '0'    ; human readable bank number 
4f12			 
4f12 7d					ld a, l 
4f13			 
4f13					if DEBUG_FORTH_WORDS 
4f13						DMARK "BNK" 
4f13 f5				push af  
4f14 3a 28 4f			ld a, (.dmark)  
4f17 32 77 fb			ld (debug_mark),a  
4f1a 3a 29 4f			ld a, (.dmark+1)  
4f1d 32 78 fb			ld (debug_mark+1),a  
4f20 3a 2a 4f			ld a, (.dmark+2)  
4f23 32 79 fb			ld (debug_mark+2),a  
4f26 18 03			jr .pastdmark  
4f28 ..			.dmark: db "BNK"  
4f2b f1			.pastdmark: pop af  
4f2c			endm  
# End of macro DMARK
4f2c						CALLMONITOR 
4f2c cd 49 17			call break_point_state  
4f2f				endm  
# End of macro CALLMONITOR
4f2f					endif 
4f2f			 
4f2f					; active low 
4f2f			 
4f2f fe 00				cp 0 
4f31 28 28				jr z, .bset 
4f33 fe 01				cp 1 
4f35 20 04				jr nz, .b2 
4f37 cb 81				res 0, c 
4f39 06 31				ld b, '1'    ; human readable bank number 
4f3b fe 02		.b2:		cp 2 
4f3d 20 04				jr nz, .b3 
4f3f cb 89				res 1, c 
4f41 06 32				ld b, '2'    ; human readable bank number 
4f43 fe 03		.b3:		cp 3 
4f45 20 04				jr nz, .b4 
4f47 cb 91				res 2, c 
4f49 06 33				ld b, '3'    ; human readable bank number 
4f4b fe 04		.b4:		cp 4 
4f4d 20 04				jr nz, .b5 
4f4f cb 99				res 3, c 
4f51 06 34				ld b, '4'    ; human readable bank number 
4f53 fe 05		.b5:		cp 5 
4f55 20 04				jr nz, .bset 
4f57 cb a1				res 4, c 
4f59 06 35				ld b, '5'    ; human readable bank number 
4f5b			 
4f5b			.bset: 
4f5b 79					ld a, c 
4f5c 32 48 f8				ld (spi_device),a 
4f5f 78					ld a, b 
4f60 32 47 f8				ld (spi_device_id),a 
4f63					if DEBUG_FORTH_WORDS 
4f63						DMARK "BN2" 
4f63 f5				push af  
4f64 3a 78 4f			ld a, (.dmark)  
4f67 32 77 fb			ld (debug_mark),a  
4f6a 3a 79 4f			ld a, (.dmark+1)  
4f6d 32 78 fb			ld (debug_mark+1),a  
4f70 3a 7a 4f			ld a, (.dmark+2)  
4f73 32 79 fb			ld (debug_mark+2),a  
4f76 18 03			jr .pastdmark  
4f78 ..			.dmark: db "BN2"  
4f7b f1			.pastdmark: pop af  
4f7c			endm  
# End of macro DMARK
4f7c						CALLMONITOR 
4f7c cd 49 17			call break_point_state  
4f7f				endm  
# End of macro CALLMONITOR
4f7f					endif 
4f7f			 
4f7f					NEXTW 
4f7f c3 42 20			jp macro_next 
4f82				endm 
# End of macro NEXTW
4f82			 
4f82			.CARTDEV: 
4f82				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4f82 66				db WORD_SYS_CORE+82             
4f83 2b 50			dw .ENDDEVICE            
4f85 08				db 7 + 1 
4f86 .. 00			db "CARTDEV",0              
4f8e				endm 
# End of macro CWHEAD
4f8e			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4f8e					if DEBUG_FORTH_WORDS_KEY 
4f8e						DMARK "CDV" 
4f8e f5				push af  
4f8f 3a a3 4f			ld a, (.dmark)  
4f92 32 77 fb			ld (debug_mark),a  
4f95 3a a4 4f			ld a, (.dmark+1)  
4f98 32 78 fb			ld (debug_mark+1),a  
4f9b 3a a5 4f			ld a, (.dmark+2)  
4f9e 32 79 fb			ld (debug_mark+2),a  
4fa1 18 03			jr .pastdmark  
4fa3 ..			.dmark: db "CDV"  
4fa6 f1			.pastdmark: pop af  
4fa7			endm  
# End of macro DMARK
4fa7						CALLMONITOR 
4fa7 cd 49 17			call break_point_state  
4faa				endm  
# End of macro CALLMONITOR
4faa					endif 
4faa			 
4faa					; disable se storage bank selection 
4faa			 
4faa 3e ff				ld a, SPI_CE_HIGH		; ce high 
4fac 32 48 f8				ld (spi_device), a 
4faf			 
4faf					; get bank 
4faf			 
4faf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4faf cd d0 1e			call macro_dsp_valuehl 
4fb2				endm 
# End of macro FORTH_DSP_VALUEHL
4fb2			 
4fb2			;		push hl 
4fb2			 
4fb2					; destroy value TOS 
4fb2			 
4fb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fb2 cd 88 1f			call macro_forth_dsp_pop 
4fb5				endm 
# End of macro FORTH_DSP_POP
4fb5			 
4fb5					; one value on hl get other one back 
4fb5			 
4fb5			;		pop hl 
4fb5			 
4fb5					; active low 
4fb5			 
4fb5 0e ff				ld c, 255 
4fb7			 
4fb7 7d					ld a, l 
4fb8					if DEBUG_FORTH_WORDS 
4fb8						DMARK "CDV" 
4fb8 f5				push af  
4fb9 3a cd 4f			ld a, (.dmark)  
4fbc 32 77 fb			ld (debug_mark),a  
4fbf 3a ce 4f			ld a, (.dmark+1)  
4fc2 32 78 fb			ld (debug_mark+1),a  
4fc5 3a cf 4f			ld a, (.dmark+2)  
4fc8 32 79 fb			ld (debug_mark+2),a  
4fcb 18 03			jr .pastdmark  
4fcd ..			.dmark: db "CDV"  
4fd0 f1			.pastdmark: pop af  
4fd1			endm  
# End of macro DMARK
4fd1						CALLMONITOR 
4fd1 cd 49 17			call break_point_state  
4fd4				endm  
# End of macro CALLMONITOR
4fd4					endif 
4fd4 fe 00				cp 0 
4fd6 28 30				jr z, .cset 
4fd8 fe 01				cp 1 
4fda 20 02				jr nz, .c2 
4fdc cb 81				res 0, c 
4fde fe 02		.c2:		cp 2 
4fe0 20 02				jr nz, .c3 
4fe2 cb 89				res 1, c 
4fe4 fe 03		.c3:		cp 3 
4fe6 20 02				jr nz, .c4 
4fe8 cb 91				res 2, c 
4fea fe 04		.c4:		cp 4 
4fec 20 02				jr nz, .c5 
4fee cb 99				res 3, c 
4ff0 fe 05		.c5:		cp 5 
4ff2 20 02				jr nz, .c6 
4ff4 cb a1				res 4, c 
4ff6 fe 06		.c6:		cp 6 
4ff8 20 02				jr nz, .c7 
4ffa cb a9				res 5, c 
4ffc fe 07		.c7:		cp 7 
4ffe 20 02				jr nz, .c8 
5000 cb b1				res 6, c 
5002 fe 08		.c8:		cp 8 
5004 20 02				jr nz, .cset 
5006 cb b9				res 7, c 
5008 79			.cset:		ld a, c 
5009 32 4b f8				ld (spi_cartdev),a 
500c			 
500c					if DEBUG_FORTH_WORDS 
500c						DMARK "CD2" 
500c f5				push af  
500d 3a 21 50			ld a, (.dmark)  
5010 32 77 fb			ld (debug_mark),a  
5013 3a 22 50			ld a, (.dmark+1)  
5016 32 78 fb			ld (debug_mark+1),a  
5019 3a 23 50			ld a, (.dmark+2)  
501c 32 79 fb			ld (debug_mark+2),a  
501f 18 03			jr .pastdmark  
5021 ..			.dmark: db "CD2"  
5024 f1			.pastdmark: pop af  
5025			endm  
# End of macro DMARK
5025						CALLMONITOR 
5025 cd 49 17			call break_point_state  
5028				endm  
# End of macro CALLMONITOR
5028					endif 
5028					NEXTW 
5028 c3 42 20			jp macro_next 
502b				endm 
# End of macro NEXTW
502b			endif 
502b			 
502b			.ENDDEVICE: 
502b			; eof 
502b			 
# End of file forth_words_device.asm
502b			 
502b			; var handler 
502b			 
502b			 
502b			.VARS: 
502b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
502b 78				db WORD_SYS_CORE+100             
502c 43 50			dw .V0Q            
502e 04				db 3 + 1 
502f .. 00			db "V0!",0              
5033				endm 
# End of macro CWHEAD
5033			;| V0! ( u1 -- )  Store value to v0  | DONE 
5033			 
5033					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5033 cd d0 1e			call macro_dsp_valuehl 
5036				endm 
# End of macro FORTH_DSP_VALUEHL
5036			 
5036 11 10 f8				ld de, cli_var_array 
5039			 
5039 eb					ex de, hl 
503a 73					ld (hl), e 
503b 23					inc hl 
503c 72					ld (hl), d 
503d			 
503d					; destroy value TOS 
503d			 
503d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
503d cd 88 1f			call macro_forth_dsp_pop 
5040				endm 
# End of macro FORTH_DSP_POP
5040			 
5040				       NEXTW 
5040 c3 42 20			jp macro_next 
5043				endm 
# End of macro NEXTW
5043			.V0Q: 
5043				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5043 79				db WORD_SYS_CORE+101             
5044 54 50			dw .V1S            
5046 04				db 3 + 1 
5047 .. 00			db "V0@",0              
504b				endm 
# End of macro CWHEAD
504b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
504b 2a 10 f8				ld hl, (cli_var_array) 
504e cd d9 1c				call forth_push_numhl 
5051			 
5051				       NEXTW 
5051 c3 42 20			jp macro_next 
5054				endm 
# End of macro NEXTW
5054			.V1S: 
5054				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5054 7a				db WORD_SYS_CORE+102             
5055 6c 50			dw .V1Q            
5057 04				db 3 + 1 
5058 .. 00			db "V1!",0              
505c				endm 
# End of macro CWHEAD
505c			;| V1! ( u1 -- )  Store value to v1 | DONE 
505c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
505c cd d0 1e			call macro_dsp_valuehl 
505f				endm 
# End of macro FORTH_DSP_VALUEHL
505f			 
505f 11 12 f8				ld de, cli_var_array+2 
5062				 
5062 eb					ex de, hl 
5063 73					ld (hl), e 
5064 23					inc hl 
5065 72					ld (hl), d 
5066			 
5066					; destroy value TOS 
5066			 
5066					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5066 cd 88 1f			call macro_forth_dsp_pop 
5069				endm 
# End of macro FORTH_DSP_POP
5069				       NEXTW 
5069 c3 42 20			jp macro_next 
506c				endm 
# End of macro NEXTW
506c			.V1Q: 
506c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
506c 7b				db WORD_SYS_CORE+103             
506d 7d 50			dw .V2S            
506f 04				db 3 + 1 
5070 .. 00			db "V1@",0              
5074				endm 
# End of macro CWHEAD
5074			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5074 2a 12 f8				ld hl, (cli_var_array+2) 
5077 cd d9 1c				call forth_push_numhl 
507a				       NEXTW 
507a c3 42 20			jp macro_next 
507d				endm 
# End of macro NEXTW
507d			.V2S: 
507d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
507d 7c				db WORD_SYS_CORE+104             
507e 95 50			dw .V2Q            
5080 04				db 3 + 1 
5081 .. 00			db "V2!",0              
5085				endm 
# End of macro CWHEAD
5085			;| V2! ( u1 -- )  Store value to v2 | DONE 
5085					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5085 cd d0 1e			call macro_dsp_valuehl 
5088				endm 
# End of macro FORTH_DSP_VALUEHL
5088			 
5088 11 14 f8				ld de, cli_var_array+4 
508b				 
508b eb					ex de, hl 
508c 73					ld (hl), e 
508d 23					inc hl 
508e 72					ld (hl), d 
508f			 
508f					; destroy value TOS 
508f			 
508f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
508f cd 88 1f			call macro_forth_dsp_pop 
5092				endm 
# End of macro FORTH_DSP_POP
5092				       NEXTW 
5092 c3 42 20			jp macro_next 
5095				endm 
# End of macro NEXTW
5095			.V2Q: 
5095				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5095 7d				db WORD_SYS_CORE+105             
5096 a6 50			dw .V3S            
5098 04				db 3 + 1 
5099 .. 00			db "V2@",0              
509d				endm 
# End of macro CWHEAD
509d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
509d 2a 14 f8				ld hl, (cli_var_array+4) 
50a0 cd d9 1c				call forth_push_numhl 
50a3				       NEXTW 
50a3 c3 42 20			jp macro_next 
50a6				endm 
# End of macro NEXTW
50a6			.V3S: 
50a6				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50a6 7c				db WORD_SYS_CORE+104             
50a7 be 50			dw .V3Q            
50a9 04				db 3 + 1 
50aa .. 00			db "V3!",0              
50ae				endm 
# End of macro CWHEAD
50ae			;| V3! ( u1 -- )  Store value to v3 | DONE 
50ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ae cd d0 1e			call macro_dsp_valuehl 
50b1				endm 
# End of macro FORTH_DSP_VALUEHL
50b1			 
50b1 11 16 f8				ld de, cli_var_array+6 
50b4				 
50b4 eb					ex de, hl 
50b5 73					ld (hl), e 
50b6 23					inc hl 
50b7 72					ld (hl), d 
50b8			 
50b8					; destroy value TOS 
50b8			 
50b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b8 cd 88 1f			call macro_forth_dsp_pop 
50bb				endm 
# End of macro FORTH_DSP_POP
50bb				       NEXTW 
50bb c3 42 20			jp macro_next 
50be				endm 
# End of macro NEXTW
50be			.V3Q: 
50be				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50be 7d				db WORD_SYS_CORE+105             
50bf cf 50			dw .END            
50c1 04				db 3 + 1 
50c2 .. 00			db "V3@",0              
50c6				endm 
# End of macro CWHEAD
50c6			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50c6 2a 16 f8				ld hl, (cli_var_array+6) 
50c9 cd d9 1c				call forth_push_numhl 
50cc				       NEXTW 
50cc c3 42 20			jp macro_next 
50cf				endm 
# End of macro NEXTW
50cf			 
50cf			 
50cf			 
50cf			 
50cf			 
50cf			; end of dict marker 
50cf			 
50cf 00			.END:    db WORD_SYS_END 
50d0 00 00			dw 0 
50d2 00				db 0 
50d3			 
50d3			; use to jp here for user dict words to save on macro expansion  
50d3			 
50d3			user_dict_next: 
50d3				NEXTW 
50d3 c3 42 20			jp macro_next 
50d6				endm 
# End of macro NEXTW
50d6			 
50d6			 
50d6			user_exec: 
50d6				;    ld hl, <word code> 
50d6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
50d6				;    call forthexec 
50d6				;    jp user_dict_next   (NEXT) 
50d6			        ;    <word code bytes> 
50d6 eb				ex de, hl 
50d7 2a 1e f1			ld hl,(os_tok_ptr) 
50da				 
50da				FORTH_RSP_NEXT 
50da cd 80 1c			call macro_forth_rsp_next 
50dd				endm 
# End of macro FORTH_RSP_NEXT
50dd			 
50dd			if DEBUG_FORTH_UWORD 
50dd						DMARK "UEX" 
50dd f5				push af  
50de 3a f2 50			ld a, (.dmark)  
50e1 32 77 fb			ld (debug_mark),a  
50e4 3a f3 50			ld a, (.dmark+1)  
50e7 32 78 fb			ld (debug_mark+1),a  
50ea 3a f4 50			ld a, (.dmark+2)  
50ed 32 79 fb			ld (debug_mark+2),a  
50f0 18 03			jr .pastdmark  
50f2 ..			.dmark: db "UEX"  
50f5 f1			.pastdmark: pop af  
50f6			endm  
# End of macro DMARK
50f6				CALLMONITOR 
50f6 cd 49 17			call break_point_state  
50f9				endm  
# End of macro CALLMONITOR
50f9			endif 
50f9			 
50f9			 
50f9			 
50f9 eb				ex de, hl 
50fa 22 1e f1			ld (os_tok_ptr), hl 
50fd				 
50fd				; Don't use next - Skips the first word in uword. 
50fd			 
50fd c3 d3 20			jp exec1 
5100			;	NEXT 
5100			 
5100			 
5100			; eof 
# End of file forth_wordsv4.asm
5100			endif 
5100			;;;;;;;;;;;;;; Debug code 
5100			 
5100			 
5100			;if DEBUG_FORTH_PARSE 
5100 .. 00		.nowordfound: db "No match",0 
5109 .. 00		.compword:	db "Comparing word ",0 
5119 .. 00		.nextwordat:	db "Next word at",0 
5126 .. 00		.charmatch:	db "Char match",0 
5131			;endif 
5131			if DEBUG_FORTH_JP 
5131			.foundword:	db "Word match. Exec..",0 
5131			endif 
5131			;if DEBUG_FORTH_PUSH 
5131 .. 00		.enddict:	db "Dict end. Push.",0 
5141 .. 00		.push_str:	db "Pushing string",0 
5150 .. 00		.push_num:	db "Pushing number",0 
515f .. 00		.data_sp:	db "SP:",0 
5163 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5175 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5187 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5199			;endif 
5199			;if DEBUG_FORTH_MALLOC 
5199 .. 00		.push_malloc:	db "Malloc address",0 
51a8			;endif 
51a8			 
51a8			 
51a8			 
51a8			; display malloc address and current data stack pointer  
51a8			 
51a8			malloc_error: 
51a8 d5				push de 
51a9 f5				push af 
51aa e5				push hl 
51ab cd d8 0a			call clear_display 
51ae 11 d0 51			ld de, .mallocerr 
51b1 3e 00			ld a,0 
51b3			;	ld de,os_word_scratch 
51b3 cd eb 0a			call str_at_display 
51b6 3e 11			ld a, display_row_1+17 
51b8 11 77 fb			ld de, debug_mark 
51bb cd eb 0a			call str_at_display 
51be cd fb 0a			call update_display 
51c1				;call break_point_state 
51c1 cd ca 68			call cin_wait 
51c4			 
51c4 3e 20			ld a, ' ' 
51c6 32 0e ee			ld (os_view_disable), a 
51c9 e1				pop hl 
51ca f1				pop af 
51cb d1				pop de	 
51cc				CALLMONITOR 
51cc cd 49 17			call break_point_state  
51cf				endm  
# End of macro CALLMONITOR
51cf c9				ret 
51d0			 
51d0 .. 00		.mallocerr: 	db "Malloc Error",0 
51dd			;if DEBUG_FORTH_PUSH 
51dd			display_data_sp: 
51dd f5				push af 
51de			 
51de				; see if disabled 
51de			 
51de 3a 0e ee			ld a, (os_view_disable) 
51e1 fe 2a			cp '*' 
51e3 28 67			jr z, .skipdsp 
51e5			 
51e5 e5				push hl 
51e6 e5				push hl 
51e7 e5			push hl 
51e8 cd d8 0a			call clear_display 
51eb e1			pop hl 
51ec 7c				ld a,h 
51ed 21 22 f1			ld hl, os_word_scratch 
51f0 cd 0d 10			call hexout 
51f3 e1				pop hl 
51f4 7d				ld a,l 
51f5 21 24 f1			ld hl, os_word_scratch+2 
51f8 cd 0d 10			call hexout 
51fb 21 26 f1			ld hl, os_word_scratch+4 
51fe 3e 00			ld a,0 
5200 77				ld (hl),a 
5201 11 22 f1			ld de,os_word_scratch 
5204 3e 28				ld a, display_row_2 
5206 cd eb 0a				call str_at_display 
5209 11 63 51			ld de, .wordinhl 
520c 3e 00			ld a, display_row_1 
520e			 
520e cd eb 0a				call str_at_display 
5211 11 77 fb			ld de, debug_mark 
5214 3e 11			ld a, display_row_1+17 
5216			 
5216 cd eb 0a				call str_at_display 
5219			 
5219				; display current data stack pointer 
5219 11 5f 51			ld de,.data_sp 
521c 3e 30				ld a, display_row_2 + 8 
521e cd eb 0a				call str_at_display 
5221			 
5221 2a 0a f8			ld hl,(cli_data_sp) 
5224 e5				push hl 
5225 7c				ld a,h 
5226 21 22 f1			ld hl, os_word_scratch 
5229 cd 0d 10			call hexout 
522c e1				pop hl 
522d 7d				ld a,l 
522e 21 24 f1			ld hl, os_word_scratch+2 
5231 cd 0d 10			call hexout 
5234 21 26 f1			ld hl, os_word_scratch+4 
5237 3e 00			ld a,0 
5239 77				ld (hl),a 
523a 11 22 f1			ld de,os_word_scratch 
523d 3e 33				ld a, display_row_2 + 11 
523f cd eb 0a				call str_at_display 
5242			 
5242			 
5242 cd fb 0a			call update_display 
5245 cd 58 0a			call delay1s 
5248 cd 58 0a			call delay1s 
524b e1				pop hl 
524c			.skipdsp: 
524c f1				pop af 
524d c9				ret 
524e			 
524e			display_data_malloc: 
524e			 
524e f5				push af 
524f e5				push hl 
5250 e5				push hl 
5251 e5			push hl 
5252 cd d8 0a			call clear_display 
5255 e1			pop hl 
5256 7c				ld a,h 
5257 21 22 f1			ld hl, os_word_scratch 
525a cd 0d 10			call hexout 
525d e1				pop hl 
525e 7d				ld a,l 
525f 21 24 f1			ld hl, os_word_scratch+2 
5262 cd 0d 10			call hexout 
5265 21 26 f1			ld hl, os_word_scratch+4 
5268 3e 00			ld a,0 
526a 77				ld (hl),a 
526b 11 22 f1			ld de,os_word_scratch 
526e 3e 28				ld a, display_row_2 
5270 cd eb 0a				call str_at_display 
5273 11 99 51			ld de, .push_malloc 
5276 3e 00			ld a, display_row_1 
5278			 
5278 cd eb 0a				call str_at_display 
527b			 
527b				; display current data stack pointer 
527b 11 5f 51			ld de,.data_sp 
527e 3e 30				ld a, display_row_2 + 8 
5280 cd eb 0a				call str_at_display 
5283			 
5283 2a 0a f8			ld hl,(cli_data_sp) 
5286 e5				push hl 
5287 7c				ld a,h 
5288 21 22 f1			ld hl, os_word_scratch 
528b cd 0d 10			call hexout 
528e e1				pop hl 
528f 7d				ld a,l 
5290 21 24 f1			ld hl, os_word_scratch+2 
5293 cd 0d 10			call hexout 
5296 21 26 f1			ld hl, os_word_scratch+4 
5299 3e 00			ld a,0 
529b 77				ld (hl),a 
529c 11 22 f1			ld de,os_word_scratch 
529f 3e 33				ld a, display_row_2 + 11 
52a1 cd eb 0a				call str_at_display 
52a4			 
52a4 cd fb 0a			call update_display 
52a7 cd 58 0a			call delay1s 
52aa cd 58 0a			call delay1s 
52ad e1				pop hl 
52ae f1				pop af 
52af c9				ret 
52b0			;endif 
52b0			 
52b0			include "forth_autostart.asm" 
52b0			; list of commands to perform at system start up 
52b0			 
52b0			startcmds: 
52b0			;	dw test11 
52b0			;	dw test12 
52b0			;	dw test13 
52b0			;	dw test14 
52b0			;	dw test15 
52b0			;	dw test16 
52b0			;	dw test17 
52b0			;	dw ifthtest1 
52b0			;	dw ifthtest2 
52b0			;	dw ifthtest3 
52b0			;	dw mmtest1 
52b0			;	dw mmtest2 
52b0			;	dw mmtest3 
52b0			;	dw mmtest4 
52b0			;	dw mmtest5 
52b0			;	dw mmtest6 
52b0			;	dw iftest1 
52b0			;	dw iftest2 
52b0			;	dw iftest3 
52b0			;	dw looptest1 
52b0			;	dw looptest2 
52b0			;	dw test1 
52b0			;	dw test2 
52b0			;	dw test3 
52b0			;	dw test4 
52b0			;	dw game2r 
52b0			;	dw game2b1 
52b0			;	dw game2b2 
52b0			 
52b0				; start up words that are actually useful 
52b0			 
52b0 0e 53			dw clrstack 
52b2 41 53			dw type 
52b4 02 55			dw stest 
52b6 65 53			dw strncpy 
52b8 a3 54			dw list 
52ba c6 53			dw start1 
52bc d8 53			dw start2 
52be			;	dw start3 
52be eb 53			dw start3b 
52c0 43 54			dw start3c 
52c2			 
52c2				; (unit) testing words 
52c2			 
52c2 79 55			dw mtesta 
52c4 2e 56			dw mtestb 
52c6 d1 56			dw mtestc 
52c8 86 57			dw mtestd 
52ca 2a 58			dw mteste 
52cc			 
52cc				; demo/game words 
52cc			 
52cc 36 5f		        dw game3w 
52ce 64 5f		        dw game3p 
52d0 82 5f		        dw game3sc 
52d2 b3 5f		        dw game3vsi 
52d4 df 5f		        dw game3vs 
52d6				 
52d6 29 5d			dw game2b 
52d8 97 5d			dw game2bf 
52da e1 5d			dw game2mba 
52dc 77 5e			dw game2mbas 
52de b9 5e			dw game2mb 
52e0			 
52e0 ea 59			dw game1 
52e2 fb 59			dw game1a 
52e4 5d 5a			dw game1b 
52e6 92 5a			dw game1c 
52e8 c8 5a			dw game1d 
52ea f9 5a			dw game1s 
52ec 0d 5b			dw game1t 
52ee 22 5b			dw game1f 
52f0 56 5b			dw game1z 
52f2 9a 5b			dw game1zz 
52f4			 
52f4 e0 58			dw test5 
52f6 18 59			dw test6 
52f8 50 59			dw test7 
52fa 64 59			dw test8 
52fc 90 59			dw test9 
52fe a6 59			dw test10 
5300				 
5300 71 5c		        dw ssv5 
5302 55 5c		        dw ssv4 
5304 39 5c		        dw ssv3 
5306 03 5c		        dw ssv2 
5308 8a 5c		        dw ssv1 
530a d2 5c		        dw ssv1cpm 
530c			;	dw keyup 
530c			;	dw keydown 
530c			;	dw keyleft 
530c			;	dw keyright 
530c			;	dw 	keyf1 
530c			;	dw keyf2 
530c			;	dw keyf3 
530c			;	dw keyf4 
530c			;	dw keyf5 
530c			;	dw keyf6 
530c			;	dw keyf7 
530c			;	dw keyf8 
530c			;	dw keyf9 
530c			;	dw keyf10 
530c			;	dw keyf11 
530c			;	dw keyf12 
530c			;	dw keytab 
530c			;	dw keycr 
530c			;	dw keyhome 
530c			;	dw keyend 
530c			;	dw keybs 
530c 00 00			db 0, 0	 
530e			 
530e			 
530e			; clear stack  
530e			 
530e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5341			 
5341			; type ( addr count - ) 
5341 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5365			 
5365			; some direct memory words 
5365			; strncpy ( len t f -- t ) 
5365			 
5365 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53c6			 
53c6 .. 00		start1:     	db ": bpon $0000 bp ;",0 
53d8 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
53eb			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
53eb .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5443 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54a3			 
54a3			 
54a3			; a handy word to list items on the stack 
54a3			 
54a3 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5502			 
5502			 
5502			; test stack  
5502			; rnd8 stest 
5502			 
5502 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5579			 
5579			; random malloc and free cycles 
5579			 
5579 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
562e			 
562e			; fixed malloc and free cycles 
562e			 
562e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56d1			 
56d1			; fixed double string push and drop cycle  
56d1			 
56d1 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5786			 
5786			; consistent fixed string push and drop cycle  
5786			 
5786 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
582a			 
582a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58e0			 
58e0			;test1:		db ": aa 1 2 3 ;", 0 
58e0			;test2:     	db "111 aa 888 999",0 
58e0			;test3:     	db ": bb 77 ;",0 
58e0			;test4:     	db "$02 $01 do i . loop bb",0 
58e0			 
58e0 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5918 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5950 .. 00		test7:     	db ": box hline vline ;",0 
5964 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5990 .. 00		test9:     	db ": sw $01 adsp world ;",0 
59a6 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59cb .. 00		test11:     	db "hello create .",0 
59da .. 00		test12:     	db "hello2 create .",0 
59ea			 
59ea			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
59ea			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
59ea			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
59ea			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
59ea			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
59ea			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
59ea			 
59ea			;iftest1:     	db "$0001 IF cls .",0 
59ea			;iftest2:     	db "$0000 IF cls .",0 
59ea			;iftest3:     	db "$0002 $0003 - IF cls .",0 
59ea			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
59ea			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
59ea			 
59ea			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59ea			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59ea			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59ea			 
59ea			 
59ea			 
59ea			; a small guess the number game 
59ea			 
59ea .. 00		game1:          db ": gsn rnd8 v1! ;",0 
59fb .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a5d			 
5a5d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5a92 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ac8 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5af9 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b0d .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b22 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b56 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5b9a			 
5b9a			; Using 'ga' save a high score across multiple runs using external storage 
5b9a			 
5b9a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c03			 
5c03			 
5c03			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c03			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c03			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c03			 
5c03			; simple screen saver to test code memory reuse to destruction 
5c03			 
5c03 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c39 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c55 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c71 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5c8a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cd2 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d29			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d29			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d29			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d29			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d29			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d29			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d29			 
5d29			 
5d29			 
5d29			; minesweeper/battleship finding game 
5d29			; draws a game board of random ship/mine positions 
5d29			; user enters coords to see if it hits on 
5d29			; game ends when all are hit 
5d29			; when hit or miss says how many may be in the area 
5d29			 
5d29			; setup the game board and then hide it 
5d29 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5d97 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5de1			; prompt for where to target 
5de1 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e77 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5e9c			; TODO see if the entered coords hits or misses pushes char hit of miss 
5e9c .. 00		game2mbht:      db ": mbckht nop ;",0 
5eab .. 00		game2mbms:      db ": mbcms nop ;",0 
5eb9			; TODO how many might be near by 
5eb9 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f36			 
5f36			; Game 3 
5f36			 
5f36			; Vert scroller ski game - avoid the trees! 
5f36			 
5f36			; v0 score (ie turns) 
5f36			; v1 player pos 
5f36			; v2 left wall 
5f36			; v3 right wall 
5f36			 
5f36			; Draw side walls randomly 
5f36			 
5f36 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f64			 
5f64			; Draw player 
5f64 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5f82			 
5f82			; TODO Get Key 
5f82			 
5f82			; TODO Move left right 
5f82			 
5f82			; scroll and move walls a bit 
5f82			 
5f82 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fb3			 
5fb3			; main game loop 
5fb3			 
5fb3 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5fdf .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
601e			 
601e			; key board defs 
601e			 
601e .. 00		keyup:       db ": keyup $05 ;",0 
602c .. 00		keydown:       db ": keydown $0a ;",0 
603c .. 00		keyleft:       db ": keyleft $0b ;",0 
604c .. 00		keyright:       db ": keyright $0c ;",0 
605d .. 00		keyf1:       db ": keyf1 $10 ;",0 
606b .. 00		keyf2:       db ": keyf2 $11 ;",0 
6079 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6087 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6095 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60a3 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60b1 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60bf .. 00		keyf8:       db ": keyf8 $17 ;",0 
60cd .. 00		keyf9:       db ": keyf9 $18 ;",0 
60db .. 00		keyf10:       db ": keyf10 $19 ;",0 
60ea .. 00		keyf11:       db ": keyf11 $1a ;",0 
60f9 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6108			 
6108 .. 00		keytab:       db ": keytab $09 ;",0 
6117 .. 00		keycr:       db ": keycr $0d ;",0 
6125 .. 00		keyhome:       db ": keyhome $0e ;",0 
6135 .. 00		keyend:       db ": keyend $0f ;",0 
6144 .. 00		keybs:       db ": keybs $08 ;",0 
6152			 
6152			   
6152			 
6152			 
6152			 
6152			; eof 
# End of file forth_autostart.asm
6152			 
6152 .. 00		sprompt1: db "Startup load...",0 
6162 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6178			 
6178			 
6178			 
6178			 
6178			forth_startup: 
6178 21 b0 52			ld hl, startcmds 
617b 3e 00			ld a, 0 
617d 32 43 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6180			 
6180 e5			.start1:	push hl 
6181 cd d8 0a			call clear_display 
6184 11 52 61			ld de, sprompt1 
6187 3e 00		        ld a, display_row_1 
6189 cd eb 0a			call str_at_display 
618c 11 62 61			ld de, sprompt2 
618f 3e 28		        ld a, display_row_2 
6191 cd eb 0a			call str_at_display 
6194 e1				pop hl 
6195 e5				push hl 
6196 5e				ld e,(hl) 
6197 23				inc hl 
6198 56				ld d,(hl) 
6199 3e 50		        ld a, display_row_3 
619b cd eb 0a			call str_at_display 
619e cd fb 0a			call update_display 
61a1			 
61a1			 
61a1 3a 43 f2			ld a, (os_last_cmd) 
61a4 fe 00			cp 0 
61a6 28 05			jr z, .startprompt 
61a8 cd 4c 0a			call delay250ms 
61ab 18 24			jr .startdo 
61ad				 
61ad				 
61ad			 
61ad			.startprompt: 
61ad			 
61ad 3e 9f			ld a,display_row_4 + display_cols - 1 
61af 11 4f 1c		        ld de, endprg 
61b2 cd eb 0a			call str_at_display 
61b5 cd fb 0a			call update_display 
61b8 cd 58 0a			call delay1s 
61bb cd ca 68			call cin_wait 
61be						 
61be fe 2a			cp '*' 
61c0 28 5e			jr z, .startupend1 
61c2 fe 23			cp '#' 
61c4 20 07			jr nz, .startno 
61c6 3e 01			ld a, 1 
61c8 32 43 f2			ld (os_last_cmd),a 
61cb 18 04			jr .startdo 
61cd fe 31		.startno:	cp '1' 
61cf 28 3a			jr z,.startnxt  
61d1			 
61d1				; exec startup line 
61d1			.startdo:	 
61d1 e1				pop hl 
61d2 e5				push hl 
61d3				 
61d3 5e				ld e,(hl) 
61d4 23				inc hl 
61d5 56				ld d,(hl) 
61d6 eb				ex de,hl 
61d7			 
61d7 e5				push hl 
61d8			 
61d8 3e 00			ld a, 0 
61da				;ld a, FORTH_END_BUFFER 
61da cd 75 11			call strlent 
61dd 23				inc hl   ; include zero term to copy 
61de 06 00			ld b,0 
61e0 4d				ld c,l 
61e1 e1				pop hl 
61e2 11 1d ee			ld de, scratch 
61e5 ed b0			ldir 
61e7			 
61e7			 
61e7 21 1d ee			ld hl, scratch 
61ea cd 90 20			call forthparse 
61ed cd d0 20			call forthexec 
61f0 cd e7 1f			call forthexec_cleanup 
61f3			 
61f3 3e 78			ld a, display_row_4 
61f5 11 f3 19			ld de, endprog 
61f8			 
61f8 cd fb 0a			call update_display		 
61fb			 
61fb 3a 43 f2			ld a, (os_last_cmd) 
61fe fe 00			cp 0 
6200 20 09			jr nz, .startnxt 
6202 cd 51 1c			call next_page_prompt 
6205 cd d8 0a		        call clear_display 
6208 cd fb 0a			call update_display		 
620b			 
620b				; move onto next startup line? 
620b			.startnxt: 
620b			 
620b cd 4c 0a			call delay250ms 
620e e1				pop hl 
620f			 
620f 23				inc hl 
6210 23				inc hl 
6211			 
6211 e5				push hl 
6212 5e				ld e, (hl) 
6213 23				inc hl 
6214 56				ld d, (hl) 
6215 e1				pop hl 
6216				; TODO replace 0 test 
6216			 
6216 eb				ex de, hl 
6217 cd 35 0d			call ishlzero 
621a			;	ld a,e 
621a			;	add d 
621a			;	cp 0    ; any left to do? 
621a eb				ex de, hl 
621b c2 80 61			jp nz, .start1 
621e 18 01			jr .startupend 
6220			 
6220 e1			.startupend1: pop hl 
6221			.startupend: 
6221			 
6221 cd d8 0a			call clear_display 
6224 cd fb 0a			call update_display 
6227 c9				ret 
6228			 
6228			 
6228			; stack over and underflow checks 
6228			 
6228			; init the words to detect the under/overflow 
6228			 
6228			chk_stk_init: 
6228				; a vague random number to check so we dont get any "lucky" hits 
6228 3e 2d			ld a, 45 
622a 6f				ld l, a 
622b 00				nop 
622c 3e 17			ld a, 23 
622e 67				ld h, a 
622f			 
622f 22 04 ee			ld (chk_word), hl     ; the word we need to check against 
6232			 
6232			;	ld (chk_stund), hl	; stack points.... 
6232 22 fd fb			ld (chk_stovr), hl 
6235 22 08 f8			ld (chk_ret_und), hl 
6238 22 86 f7			ld (chk_ret_ovr), hl 
623b 22 84 f5			ld (chk_loop_ovr), hl 
623e 22 82 f3			ld (chk_data_ovr), hl 
6241 c9				ret 
6242				 
6242			check_stacks: 
6242				; check all stack words 
6242			 
6242 e5				push hl 
6243 d5				push de 
6244			 
6244			;	ld de,(chk_word) 
6244			;	ld hl, (chk_stund)	; stack points.... 
6244			;	if DEBUG_STK_FAULT 
6244			;		DMARK "FAa" 
6244			;		CALLMONITOR 
6244			;	endif 
6244			;	call cmp16 
6244			;	jp z, .chk_faulta 
6244			; 
6244			;	ld de, sfaultsu 
6244			;	jp .chk_fault 
6244			 
6244 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6247 ed 5b 04 ee		ld de,(chk_word) 
624b				if DEBUG_STK_FAULT 
624b					DMARK "FAb" 
624b					CALLMONITOR 
624b				endif 
624b cd 2a 0d			call cmp16 
624e 28 06			jr z, .chk_fault1 
6250 11 f1 62			ld de, sfaultso 
6253 c3 a5 62			jp .chk_fault 
6256			.chk_fault1:  
6256 2a 08 f8			ld hl, (chk_ret_und) 
6259 ed 5b 04 ee		ld de,(chk_word) 
625d				if DEBUG_STK_FAULT 
625d					DMARK "FAU" 
625d					CALLMONITOR 
625d				endif 
625d cd 2a 0d			call cmp16 
6260 ca 69 62			jp z, .chk_fault2 
6263 11 01 63			ld de, sfaultru 
6266 c3 a5 62			jp .chk_fault 
6269			.chk_fault2:  
6269 2a 86 f7			ld hl, (chk_ret_ovr) 
626c ed 5b 04 ee		ld de,(chk_word) 
6270				if DEBUG_STK_FAULT 
6270					DMARK "FA1" 
6270					CALLMONITOR 
6270				endif 
6270 cd 2a 0d			call cmp16 
6273 ca 7c 62			jp z, .chk_fault3 
6276 11 0f 63			ld de, sfaultro 
6279 c3 a5 62			jp .chk_fault 
627c			.chk_fault3:  
627c 2a 84 f5			ld hl, (chk_loop_ovr) 
627f ed 5b 04 ee		ld de,(chk_word) 
6283				if DEBUG_STK_FAULT 
6283					DMARK "FA2" 
6283					CALLMONITOR 
6283				endif 
6283 cd 2a 0d			call cmp16 
6286 ca 8f 62			jp z, .chk_fault4 
6289 11 29 63			ld de, sfaultlo 
628c c3 a5 62			jp .chk_fault 
628f			.chk_fault4:  
628f 2a 82 f3			ld hl, (chk_data_ovr) 
6292 ed 5b 04 ee		ld de,(chk_word) 
6296				if DEBUG_STK_FAULT 
6296					DMARK "FA3" 
6296					CALLMONITOR 
6296				endif 
6296 cd 2a 0d			call cmp16 
6299 ca a2 62			jp z, .chk_fault5 
629c 11 43 63			ld de, sfaultdo 
629f c3 a5 62			jp .chk_fault 
62a2			 
62a2			 
62a2			.chk_fault5:  
62a2 d1				pop de 
62a3 e1				pop hl 
62a4			 
62a4 c9				ret 
62a5			 
62a5 cd d8 0a		.chk_fault: 	call clear_display 
62a8 3e 28				ld a, display_row_2 
62aa cd eb 0a				call str_at_display 
62ad 11 d3 62				   ld de, .stackfault 
62b0 3e 00				ld a, display_row_1 
62b2 cd eb 0a				call str_at_display 
62b5 11 77 fb				    ld de, debug_mark 
62b8 3e 11				ld a, display_row_1+17 
62ba cd eb 0a				call str_at_display 
62bd cd fb 0a				call update_display 
62c0			 
62c0				; prompt before entering montior for investigating issue 
62c0			 
62c0 3e 78			ld a, display_row_4 
62c2 11 f3 19			ld de, endprog 
62c5			 
62c5 cd fb 0a			call update_display		 
62c8			 
62c8 cd 51 1c			call next_page_prompt 
62cb			 
62cb d1				pop de 
62cc e1				pop hl 
62cd cd 47 1a				call monitor 
62d0 c3 3e 19				jp warmstart 
62d3					;jp 0 
62d3					;halt 
62d3			 
62d3			 
62d3			 
62d3 .. 00		.stackfault: 	db "Stack fault:",0 
62e0			 
62e0 .. 00		sfaultsu: 	db	"Stack under flow",0 
62f1 .. 00		sfaultso: 	db	"Stack over flow",0 
6301 .. 00		sfaultru:	db "RTS underflow",0 
630f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6329 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6343 .. 00		sfaultdo:	db "DTS overflow", 0 
6350			 
6350			 
6350			fault_dsp_under: 
6350 11 62 63			ld de, .dsp_under 
6353 c3 12 64			jp .show_fault 
6356			 
6356			fault_rsp_under: 
6356 11 70 63			ld de, .rsp_under 
6359 c3 12 64			jp .show_fault 
635c			fault_loop_under: 
635c 11 7e 63			ld de, .loop_under 
635f c3 12 64			jp .show_fault 
6362			 
6362 .. 00		.dsp_under: db "DSP Underflow",0 
6370 .. 00		.rsp_under: db "RSP Underflow",0 
637e .. 00		.loop_under: db "LOOP Underflow",0 
638d			 
638d			 
638d d5			type_faultn: 	push de 
638e e5					push hl 
638f cd d8 0a				call clear_display 
6392 11 b9 63				   ld de, .typefaultn 
6395 3e 00				ld a, display_row_1 
6397 cd eb 0a				call str_at_display 
639a 11 77 fb				    ld de, debug_mark 
639d 3e 11				ld a, display_row_1+17 
639f cd eb 0a				call str_at_display 
63a2 cd fb 0a				call update_display 
63a5			 
63a5				; prompt before entering montior for investigating issue 
63a5			 
63a5 3e 78			ld a, display_row_4 
63a7 11 f3 19			ld de, endprog 
63aa			 
63aa cd fb 0a			call update_display		 
63ad			 
63ad cd 51 1c			call next_page_prompt 
63b0			 
63b0 e5					push hl 
63b1 d5					push de 
63b2 cd 47 1a				call monitor 
63b5 c3 3e 19				jp warmstart 
63b8 76					halt 
63b9			 
63b9			 
63b9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
63d0			 
63d0 d5			type_faults: 	push de 
63d1 e5					push hl 
63d2 cd d8 0a				call clear_display 
63d5 11 fb 63				   ld de, .typefaults 
63d8 3e 00				ld a, display_row_1 
63da cd eb 0a				call str_at_display 
63dd 11 77 fb				    ld de, debug_mark 
63e0 3e 11				ld a, display_row_1+17 
63e2 cd eb 0a				call str_at_display 
63e5 cd fb 0a				call update_display 
63e8			 
63e8				; prompt before entering montior for investigating issue 
63e8			 
63e8 3e 78			ld a, display_row_4 
63ea 11 f3 19			ld de, endprog 
63ed			 
63ed cd fb 0a			call update_display		 
63f0			 
63f0 cd 51 1c			call next_page_prompt 
63f3			 
63f3 e1					pop hl 
63f4 d1					pop de 
63f5 cd 47 1a				call monitor 
63f8 c3 3e 19				jp warmstart 
63fb			 
63fb			 
63fb .. 00		.typefaults: db "STR Type Expected TOS!",0 
6412			 
6412			.show_fault: 	 
6412 d5					push de 
6413 cd d8 0a				call clear_display 
6416 d1					pop de 
6417 3e 00				ld a, display_row_1 
6419 cd eb 0a				call str_at_display 
641c 11 77 fb				    ld de, debug_mark 
641f 3e 11				ld a, display_row_1+17 
6421 cd eb 0a				call str_at_display 
6424 cd fb 0a				call update_display 
6427			 
6427				; prompt before entering montior for investigating issue 
6427			 
6427 3e 78			ld a, display_row_4 
6429 11 f3 19			ld de, endprog 
642c			 
642c cd fb 0a			call update_display		 
642f			 
642f cd 51 1c			call next_page_prompt 
6432			 
6432 e1					pop hl 
6433 d1					pop de 
6434 cd 47 1a				call monitor 
6437			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6437			; TODO Make optional fault restart to cli or warm boot? 
6437					;jp warmstart 
6437 c3 99 19				jp cli 
643a 76					halt 
643b			 
643b			; handle the auto run of code from files in storage 
643b			 
643b			 
643b			if STORAGE_SE 
643b			 
643b .. 00		sprompt3: db "Loading from start-up file?:",0 
6458 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6469			 
6469			 
6469			forth_autoload: 
6469			 
6469				; load block 0 of store 1 
6469				 
6469 3e fe			ld a, $fe      ; bit 0 clear 
646b 32 48 f8			ld (spi_device), a 
646e			 
646e cd bd 03			call storage_get_block_0 
6471			 
6471 3a 83 f8			ld a, (store_page+STORE_0_AUTOFILE) 
6474			 
6474 fe 00			cp 0 
6476 c8				ret z     ; auto start not enabled 
6477			 
6477 cd d8 0a			call clear_display 
647a			 
647a				; set bank 
647a			 
647a 3a 85 f8				ld a, (store_page+STORE_0_BANKRUN) 
647d 32 48 f8				ld (spi_device), a 
6480			 
6480				; get file id to load from and get the file name to display 
6480			 
6480 3a 86 f8				ld a, (store_page+STORE_0_FILERUN) 
6483			 
6483 2e 00				ld l, 0 
6485 67					ld h, a 
6486 11 62 f8				ld de, store_page 
6489			 
6489					if DEBUG_FORTH_WORDS 
6489						DMARK "ASp" 
6489 f5				push af  
648a 3a 9e 64			ld a, (.dmark)  
648d 32 77 fb			ld (debug_mark),a  
6490 3a 9f 64			ld a, (.dmark+1)  
6493 32 78 fb			ld (debug_mark+1),a  
6496 3a a0 64			ld a, (.dmark+2)  
6499 32 79 fb			ld (debug_mark+2),a  
649c 18 03			jr .pastdmark  
649e ..			.dmark: db "ASp"  
64a1 f1			.pastdmark: pop af  
64a2			endm  
# End of macro DMARK
64a2						CALLMONITOR 
64a2 cd 49 17			call break_point_state  
64a5				endm  
# End of macro CALLMONITOR
64a5					endif 
64a5 cd 53 08				call storage_read 
64a8			 
64a8					if DEBUG_FORTH_WORDS 
64a8						DMARK "ASr" 
64a8 f5				push af  
64a9 3a bd 64			ld a, (.dmark)  
64ac 32 77 fb			ld (debug_mark),a  
64af 3a be 64			ld a, (.dmark+1)  
64b2 32 78 fb			ld (debug_mark+1),a  
64b5 3a bf 64			ld a, (.dmark+2)  
64b8 32 79 fb			ld (debug_mark+2),a  
64bb 18 03			jr .pastdmark  
64bd ..			.dmark: db "ASr"  
64c0 f1			.pastdmark: pop af  
64c1			endm  
# End of macro DMARK
64c1						CALLMONITOR 
64c1 cd 49 17			call break_point_state  
64c4				endm  
# End of macro CALLMONITOR
64c4					endif 
64c4			 
64c4 cd 35 0d				call ishlzero 
64c7 c8					ret z             ; file not found 
64c8			 
64c8 3e 32				ld a, display_row_2 + 10 
64ca 11 65 f8				ld de, store_page+3 
64cd cd eb 0a				call str_at_display 
64d0				 
64d0			; 
64d0			 
64d0 3e 05			ld a, display_row_1+5 
64d2 11 3b 64			ld de, sprompt3 
64d5 cd eb 0a			call str_at_display 
64d8 3e 5f			ld a, display_row_3+15 
64da 11 58 64			ld de, sprompt4 
64dd cd eb 0a			call str_at_display 
64e0			 
64e0 cd fb 0a			call update_display 
64e3			 
64e3 cd ca 68			call cin_wait 
64e6 fe 6e			cp 'n' 
64e8 c8				ret z 
64e9 fe 4e			cp 'N' 
64eb c8				ret z 
64ec			 
64ec cd 58 0a			call delay1s 
64ef			 
64ef 3a 64 f8			ld a, (store_page+2) 
64f2 32 58 f8			ld (store_openmaxext), a    ; save count of ext 
64f5 3e 01			ld a, 1  
64f7 32 59 f8			ld (store_openext), a    ; save count of ext 
64fa			 
64fa			.autof:  
64fa 6f				ld l , a 
64fb				 
64fb 3a 62 f8			ld a, (store_page) 
64fe 67				ld h, a	 
64ff 11 62 f8			ld de, store_page 
6502					if DEBUG_FORTH_WORDS 
6502						DMARK "ASl" 
6502 f5				push af  
6503 3a 17 65			ld a, (.dmark)  
6506 32 77 fb			ld (debug_mark),a  
6509 3a 18 65			ld a, (.dmark+1)  
650c 32 78 fb			ld (debug_mark+1),a  
650f 3a 19 65			ld a, (.dmark+2)  
6512 32 79 fb			ld (debug_mark+2),a  
6515 18 03			jr .pastdmark  
6517 ..			.dmark: db "ASl"  
651a f1			.pastdmark: pop af  
651b			endm  
# End of macro DMARK
651b						CALLMONITOR 
651b cd 49 17			call break_point_state  
651e				endm  
# End of macro CALLMONITOR
651e					endif 
651e cd 53 08				call storage_read 
6521 cd 35 0d			call ishlzero 
6524 c8				ret z 
6525			;	jr z, .autoend 
6525			 
6525					if DEBUG_FORTH_WORDS 
6525						DMARK "ASc" 
6525 f5				push af  
6526 3a 3a 65			ld a, (.dmark)  
6529 32 77 fb			ld (debug_mark),a  
652c 3a 3b 65			ld a, (.dmark+1)  
652f 32 78 fb			ld (debug_mark+1),a  
6532 3a 3c 65			ld a, (.dmark+2)  
6535 32 79 fb			ld (debug_mark+2),a  
6538 18 03			jr .pastdmark  
653a ..			.dmark: db "ASc"  
653d f1			.pastdmark: pop af  
653e			endm  
# End of macro DMARK
653e						CALLMONITOR 
653e cd 49 17			call break_point_state  
6541				endm  
# End of macro CALLMONITOR
6541					endif 
6541 11 64 f8			ld de, store_page+2 
6544 3e 78			ld a, display_row_4 
6546 cd eb 0a			call str_at_display 
6549			 
6549 cd fb 0a			call update_display 
654c cd 4c 0a			call delay250ms 
654f			 
654f			 
654f			 
654f 21 64 f8			ld hl, store_page+2 
6552 cd 90 20			call forthparse 
6555 cd d0 20			call forthexec 
6558 cd e7 1f			call forthexec_cleanup 
655b			 
655b				 
655b 3a 59 f8			ld a, (store_openext) 
655e 3c				inc a 
655f 32 59 f8			ld (store_openext), a    ; save count of ext 
6562			 
6562 18 96			jr .autof 
6564			;.autofdone: 
6564			; 
6564			;		if DEBUG_FORTH_WORDS 
6564			;			DMARK "ASx" 
6564			;			CALLMONITOR 
6564			;		endif 
6564			;;	call clear_display 
6564			;	ret 
6564			 
6564			 
6564			 
6564			endif 
6564			 
6564			 
6564			; eof 
# End of file forth_kernel.asm
6564			;include "nascombasic.asm" 
6564			 
6564			 
6564			; find out where the code ends if loaded into RAM (for SC114) 
6564			;endofcode:  
6564			;	nop 
6564			 
6564			 
6564			; eof 
6564			 
# End of file main.asm
6564			include "firmware_lcd_4x40.asm" 
6564			; **********************************************************************  
6564			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6564			; **********************************************************************  
6564			;  
6564			; **  Written as a Small Computer Monitor App  
6564			; **  www.scc.me.uk  
6564			;  
6564			; History  
6564			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6564			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6564			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6564			;  
6564			; **********************************************************************  
6564			;  
6564			; This program is an example of one of the methods of interfacing an   
6564			; alphanumeric LCD module.   
6564			;  
6564			; In this example the display is connected to either a Z80 PIO or a   
6564			; simple 8-bit output port.   
6564			;  
6564			; This interfacing method uses 4-bit data mode and uses time delays  
6564			; rather than polling the display's ready status. As a result the   
6564			; interface only requires 6 simple output lines:  
6564			;   Output bit 0 = not used  
6564			;   Output bit 1 = not used  
6564			;   Output bit 2 = RS         High = data, Low = instruction  
6564			;   Output bit 3 = E          Active high  
6564			;   Output bit 4 = DB4  
6564			;   Output bit 5 = DB5  
6564			;   Output bit 6 = DB6  
6564			;   Output bit 7 = DB7  
6564			; Display's R/W is connected to 0v so it is always in write mode  
6564			;  
6564			; This set up should work with any system supporting the RC2014 bus  
6564			  
6564			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6564			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6564			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6564			;  
6564			; **********************************************************************  
6564			  
6564			; Additonal for 4x40. E1 and E2 instead of just E   
6564			; TODO swipe vidout signal on port a to activate E2  
6564			  
6564			; **********************************************************************  
6564			; **  Constants  
6564			; **********************************************************************  
6564			; LCD constants required by LCD support module  
6564			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6564			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6564			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6564			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6564			; TODO Decide which E is being set  
6564			kLCDWidth:  EQU display_cols             ;Width in characters  
6564			  
6564			; **********************************************************************  
6564			; **  Code library usage  
6564			; **********************************************************************  
6564			  
6564			; send character to current cursor position  
6564			; wraps and/or scrolls screen automatically  
6564			  
6564			  
6564			  
6564			lcd_init:  
6564			  
6564			; SCMonAPI functions used  
6564			  
6564			; Alphanumeric LCD functions used  
6564			; no need to specify specific functions for this module  
6564			  
6564 3e cf		            LD   A, 11001111b  
6566 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6568 3e 00		            LD   A, 00000000b  
656a d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
656c			  
656c			; Initialise alphanumeric LCD module  
656c 3e 00				ld a, 0  
656e 32 d7 f8				ld (display_lcde1e2), a  
6571 cd f2 65		            CALL fLCD_Init      ;Initialise LCD module  
6574 3e 01				ld a, 1  
6576 32 d7 f8				ld (display_lcde1e2), a  
6579 cd f2 65		            CALL fLCD_Init      ;Initialise LCD module  
657c			  
657c c9				ret  
657d			  
657d			;  
657d			;;  
657d			; lcd functions  
657d			;  
657d			;  
657d			  
657d			; what is at cursor position   
657d			  
657d			;get_cursor:	ld de, (cursor_row)   ;  row + col  
657d			;		call curptr  
657d			;		ret  
657d			  
657d			  
657d			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
657d			  
657d			curptr:  
657d c5				push bc  
657e 21 bd fa			ld hl, display_fb0  
6581			cpr:	  
6581				; loop for cursor whole row  
6581 0e 28			ld c, display_cols  
6583 23			cpr1:	inc hl  
6584 0d				dec c  
6585 20 fc			jr nz, cpr1  
6587 05				dec b  
6588 20 f7			jr nz, cpr  
658a			  
658a				; add col	  
658a			  
658a 23			cpr2:	inc hl  
658b 1d				dec e  
658c 20 fc			jr nz, cpr2  
658e			  
658e c1				pop bc  
658f c9				ret  
6590				  
6590			  
6590			  
6590			  
6590			  
6590			; write the frame buffer given in hl to hardware   
6590 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
6593 3e 00			ld a, kLCD_Line1  
6595 cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6598 06 28			ld b, display_cols  
659a ed 5b d5 f8		ld de, (display_write_tmp)  
659e cd ea 65			call write_len_string  
65a1				  
65a1				  
65a1 2a d5 f8			ld hl, (display_write_tmp)  
65a4 11 28 00			ld de, display_cols  
65a7 19				add hl,de  
65a8 22 d5 f8			ld (display_write_tmp),hl  
65ab			  
65ab				  
65ab 3e 28			ld a, kLCD_Line2  
65ad cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65b0 06 28			ld b, display_cols  
65b2 ed 5b d5 f8		ld de, (display_write_tmp)  
65b6 cd ea 65			call write_len_string  
65b9				  
65b9 2a d5 f8			ld hl, (display_write_tmp)  
65bc 11 28 00			ld de, display_cols  
65bf 19				add hl,de  
65c0 22 d5 f8			ld (display_write_tmp),hl  
65c3			  
65c3				  
65c3 3e 50			ld a, kLCD_Line3  
65c5 cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65c8 06 28			ld b, display_cols  
65ca ed 5b d5 f8		ld de, (display_write_tmp)  
65ce cd ea 65			call write_len_string  
65d1				  
65d1 2a d5 f8			ld hl, (display_write_tmp)  
65d4 11 28 00			ld de, display_cols  
65d7 19				add hl,de  
65d8 22 d5 f8			ld (display_write_tmp),hl  
65db			  
65db				  
65db 3e 78			ld a, kLCD_Line4  
65dd cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
65e0 06 28			ld b, display_cols  
65e2 ed 5b d5 f8		ld de, (display_write_tmp)  
65e6 cd ea 65			call write_len_string  
65e9 c9					ret  
65ea				  
65ea				; write out a fixed length string given in b from de  
65ea			  
65ea 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
65eb cd 57 66		            CALL fLCD_Data      ;Write character to display  
65ee 13				inc de  
65ef 10 f9			djnz write_len_string  
65f1 c9				ret  
65f2			  
65f2			; Some other things to do  
65f2			;            LD   A, kLCD_Clear ;Display clear  
65f2			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
65f2			;            LD   A, kLCD_Under ;Display on with underscore cursor  
65f2			;            LD   A, kLCD_On     ;Display on with no cursor  
65f2			;            ;LD   A, kLCD_Off   ;Display off  
65f2			;            CALL fLCD_Inst      ;Send instruction to display  
65f2			;  
65f2			;  
65f2			;            halt  
65f2			;  
65f2			;  
65f2			;MsgHello:   DB  "Hello World!",0  
65f2			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
65f2			  
65f2			; Custom characters 5 pixels wide by 8 pixels high  
65f2			; Up to 8 custom characters can be defined  
65f2			;BitMaps:      
65f2			;; Character 0x00 = Battery icon  
65f2			;            DB  01110b  
65f2			;            DB  11011b  
65f2			;            DB  10001b  
65f2			;            DB  10001b  
65f2			;            DB  11111b  
65f2			;            DB  11111b  
65f2			;            DB  11111b  
65f2			;            DB  11111b  
65f2			;; Character 0x01 = Bluetooth icon  
65f2			;            DB  01100b  
65f2			;            DB  01010b  
65f2			;            DB  11100b  
65f2			;            DB  01000b  
65f2			;            DB  11100b  
65f2			;            DB  01010b  
65f2			;            DB  01100b  
65f2			;            DB  00000b  
65f2			;  
65f2			  
65f2			  
65f2			; **********************************************************************  
65f2			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
65f2			; **********************************************************************  
65f2			;  
65f2			; **  Written as a Small Computer Monitor App   
65f2			; **  Version 0.1 SCC 2018-05-16  
65f2			; **  www.scc.me.uk  
65f2			;  
65f2			; **********************************************************************  
65f2			;  
65f2			; This module provides support for alphanumeric LCD modules using with  
65f2			; *  HD44780 (or compatible) controller  
65f2			; *  5 x 7 pixel fonts  
65f2			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
65f2			; *  Interface via six digital outputs to the display (see below)  
65f2			;  
65f2			; LCD module pinout:  
65f2			;   1  Vss   0v supply  
65f2			;   2  Vdd   5v supply  
65f2			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
65f2			;   4  RS    High = data, Low = instruction  
65f2			;   5  R/W   High = Read, Low = Write  
65f2			;   6  E     Enable signal (active high)  
65f2			;   7  DB0   Data bit 0  
65f2			;   8  DB1   Data bit 1  
65f2			;   9  DB2   Data bit 2  
65f2			;  10  DB3   Data bit 3  
65f2			;  11  DB4   Data bit 4  
65f2			;  12  DB5   Data bit 5  
65f2			;  13  DB6   Data bit 6  
65f2			;  14  DB7   Data bit 7  
65f2			;  15  A     Backlight anode (+)  
65f2			;  16  K     Backlight cathode (-)  
65f2			;  
65f2			; This interfacing method uses 4-bit data mode and uses time delays  
65f2			; rather than polling the display's ready status. As a result the   
65f2			; interface only requires 6 simple output lines:  
65f2			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
65f2			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
65f2			;   LCD DB4 = Microcomputer output port bit 4  
65f2			;   LCD DB5 = Microcomputer output port bit 5  
65f2			;   LCD DB6 = Microcomputer output port bit 6  
65f2			;   LCD DB7 = Microcomputer output port bit 7  
65f2			; Display's R/W is connected to 0v so it is always in write mode  
65f2			; All 6 connections must be on the same port address <kLCDPrt>  
65f2			; This method also allows a decent length of cable from micro to LCD  
65f2			;  
65f2			; **********************************************************************  
65f2			;  
65f2			; To include the code for any given function provided by this module,   
65f2			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
65f2			; the parent source file.  
65f2			; For example:  #REQUIRES   uHexPrefix  
65f2			;  
65f2			; Also #INCLUDE this file at some point after the #REQUIRES statements  
65f2			; in the parent source file.  
65f2			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
65f2			;  
65f2			; These are the function names provided by this module:  
65f2			; fLCD_Init                     ;Initialise LCD  
65f2			; fLCD_Inst                     ;Send instruction to LCD  
65f2			; fLCD_Data                     ;Send data byte to LCD  
65f2			; fLCD_Pos                      ;Position cursor  
65f2			; fLCD_Str                      ;Display string  
65f2			; fLCD_Def                      ;Define custom character  
65f2			;  
65f2			; **********************************************************************  
65f2			;  
65f2			; Requires SCMonAPI.asm to also be included in the project  
65f2			;  
65f2			  
65f2			  
65f2			; **********************************************************************  
65f2			; **  Constants  
65f2			; **********************************************************************  
65f2			  
65f2			; Constants that must be defined externally  
65f2			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
65f2			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
65f2			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
65f2			;kLCDWidth: EQU 20             ;Width in characters  
65f2			  
65f2			; general line offsets in any frame buffer  
65f2			  
65f2			  
65f2			display_row_1: equ 0  
65f2			display_row_2: equ display_row_1+display_cols  
65f2			display_row_3: equ display_row_2 + display_cols  
65f2			display_row_4: equ display_row_3 + display_cols  
65f2			;display_row_4_eol:   
65f2			  
65f2			  
65f2			; Cursor position values for the start of each line  
65f2			  
65f2			; E  
65f2			kLCD_Line1: EQU 0x00   
65f2			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
65f2			; E1  
65f2			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
65f2			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
65f2			  
65f2			; Instructions to send as A register to fLCD_Inst  
65f2			kLCD_Clear: EQU 00000001b     ;LCD clear  
65f2			kLCD_Off:   EQU 00001000b     ;LCD off  
65f2			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
65f2			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
65f2			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
65f2			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
65f2			  
65f2			; Constants used by this code module  
65f2			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
65f2			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
65f2			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
65f2			  
65f2			  
65f2			  
65f2			; **********************************************************************  
65f2			; **  LCD support functions  
65f2			; **********************************************************************  
65f2			  
65f2			; Initialise alphanumeric LCD module  
65f2			; LCD control register codes:  
65f2			;   DL   0 = 4-bit mode        1 = 8-bit mode  
65f2			;   N    0 = 1-line mode       1 = 2-line mode  
65f2			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
65f2			;   D    0 = Display off       1 = Display on  
65f2			;   C    0 = Cursor off        1 = Cursor on  
65f2			;   B    0 = Blinking off      1 = Blinking on  
65f2			;   ID   0 = Decrement mode    1 = Increment mode  
65f2			;   SH   0 = Entire shift off  1 = Entire shift on  
65f2 3e 28		fLCD_Init:  LD   A, 40  
65f4 cd 19 67		            CALL LCDDelay       ;Delay 40ms after power up  
65f7			; For reliable reset set 8-bit mode - 3 times  
65f7 cd e9 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65fa cd e9 66		            CALL WrFn8bit       ;Function = 8-bit mode  
65fd cd e9 66		            CALL WrFn8bit       ;Function = 8-bit mode  
6600			; Set 4-bit mode  
6600 cd e5 66		            CALL WrFn4bit       ;Function = 4-bit mode  
6603 cd 17 67		            CALL LCDDelay1      ;Delay 37 us or more  
6606			; Function set  
6606 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6608 cd 1b 66		            CALL fLCD_Inst      ;2 line, display on  
660b			; Display On/Off control  
660b 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
660d cd 1b 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6610			; Display Clear  
6610 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6612 cd 1b 66		            CALL fLCD_Inst      ;Clear display  
6615			; Entry mode  
6615 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6617 cd 1b 66		            CALL fLCD_Inst      ;Increment mode, shift off  
661a			; Display module now initialised  
661a c9			            RET  
661b			; ok to here  
661b			  
661b			; Write instruction to LCD  
661b			;   On entry: A = Instruction byte to be written  
661b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
661b f5			fLCD_Inst:  PUSH AF  
661c f5			            PUSH AF  
661d cd 2f 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6620 f1			            POP  AF  
6621 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6622 17			            RLA  
6623 17			            RLA  
6624 17			            RLA  
6625 cd 2f 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6628 3e 02		            LD   A, 2  
662a cd 19 67		            CALL LCDDelay       ;Delay 2 ms to complete   
662d f1			            POP  AF  
662e c9			            RET  
662f			Wr4bits:   
662f f5					push af  
6630 3a d7 f8				ld a, (display_lcde1e2)  
6633 fe 00				cp 0     ; e  
6635 20 10				jr nz, .wea2	  
6637 f1					pop af  
6638 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
663a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
663c cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
663e cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6640 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6642 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6644 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6646 c9			            RET  
6647 f1			.wea2:		pop af  
6648 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
664a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
664c cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
664e cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6650 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6652 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6654 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6656 c9			            RET  
6657			  
6657			  
6657			; Write data to LCD  
6657			;   On entry: A = Data byte to be written  
6657			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6657 f5			fLCD_Data:  PUSH AF  
6658 f5			            PUSH AF  
6659 cd 6b 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
665c f1			            POP  AF  
665d 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
665e 17			            RLA  
665f 17			            RLA  
6660 17			            RLA  
6661 cd 6b 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6664 3e 96		            LD   A, 150  
6666 3d			Wait:      DEC  A              ;Wait a while to allow data   
6667 20 fd		            JR   NZ, Wait      ;  write to complete  
6669 f1			            POP  AF  
666a c9			            RET  
666b			Wr4bitsa:     
666b f5					push af  
666c 3a d7 f8				ld a, (display_lcde1e2)  
666f fe 00				cp 0     ; e1  
6671 20 16				jr nz, .we2	  
6673 f1					pop af  
6674 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6676 cb d7		            SET  kLCDBitRS, A  
6678 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
667a cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
667c cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
667e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6680 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6682 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6684 cb 97		            RES  kLCDBitRS, A  
6686 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6688 c9			            RET  
6689 f1			.we2:		pop af  
668a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
668c cb d7		            SET  kLCDBitRS, A  
668e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6690 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6692 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6694 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6696 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6698 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
669a cb 97		            RES  kLCDBitRS, A  
669c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
669e c9			            RET  
669f			  
669f			  
669f			; Position cursor to specified location  
669f			;   On entry: A = Cursor position  
669f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
669f f5			fLCD_Pos:   PUSH AF  
66a0					; at this point set the E1 or E2 flag depending on position  
66a0			  
66a0 c5					push bc  
66a1			;		push af  
66a1 06 00				ld b, 0  
66a3 4f					ld c, a  
66a4 3e 4f				ld a, kLCD_Line3-1  
66a6 b7			 		or a      ;clear carry flag  
66a7 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
66a8 38 04				jr c, .pe1  
66aa			  
66aa					; E selection  
66aa cb 80				res 0, b         ; bit 0 unset e  
66ac			;		pop af    ; before line 3 so recover orig pos  
66ac			;		ld c, a    ; save for poking back  
66ac 18 06				jr .peset	          
66ae			.pe1:          	; E2 selection  
66ae cb c0				set 0, b         ; bit 0 set e1  
66b0 79					ld a, c  
66b1 de 4f				sbc a, kLCD_Line3-1  
66b3 4f					ld c, a	         ; save caculated offset  
66b4			;		pop af     ; bin this original value now we have calculated form  
66b4			  
66b4			.peset:		; set bit  
66b4 78					ld a, b  
66b5 32 d7 f8				ld (display_lcde1e2), a 	  
66b8 79					ld a, c  
66b9 c1					pop bc  
66ba			  
66ba f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
66bc cd 1b 66		            CALL fLCD_Inst      ;Write instruction to LCD  
66bf f1			            POP  AF  
66c0 c9			            RET  
66c1			  
66c1			  
66c1			; Output text string to LCD  
66c1			;   On entry: DE = Pointer to null terminated text string  
66c1			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
66c1 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
66c2 b7			            OR   A              ;Null terminator?  
66c3 c8			            RET  Z              ;Yes, so finished  
66c4 cd 57 66		            CALL fLCD_Data      ;Write character to display  
66c7 13			            INC  DE             ;Point to next character  
66c8 18 f7		            JR   fLCD_Str       ;Repeat  
66ca c9					ret  
66cb			  
66cb			; Define custom character  
66cb			;   On entry: A = Character number (0 to 7)  
66cb			;             DE = Pointer to character bitmap data  
66cb			;   On exit:  A = Next character number  
66cb			;             DE = Next location following bitmap  
66cb			;             BC HL IX IY I AF' BC' DE' HL' preserved  
66cb			; Character is   
66cb c5			fLCD_Def:   PUSH BC  
66cc f5			            PUSH AF  
66cd 07			            RLCA                ;Calculate location  
66ce 07			            RLCA                ;  for bitmap data  
66cf 07			            RLCA                ;  = 8 x CharacterNumber  
66d0 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
66d2 cd 1b 66		            CALL fLCD_Inst      ;Write instruction to LCD  
66d5 06 00		            LD   B, 0  
66d7 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
66d8 cd 57 66		            CALL fLCD_Data      ;Write byte to display  
66db 13			            INC  DE             ;Point to next byte  
66dc 04			            INC  B              ;Count bytes  
66dd cb 58		            BIT  3, B           ;Finish all 8 bytes?  
66df 28 f6		            JR   Z, Loop       ;No, so repeat  
66e1 f1			            POP  AF  
66e2 3c			            INC  A              ;Increment character number  
66e3 c1			            POP  BC  
66e4 c9			            RET  
66e5			  
66e5			  
66e5			; **********************************************************************  
66e5			; **  Private functions  
66e5			; **********************************************************************  
66e5			  
66e5			; Write function to LCD  
66e5			;   On entry: A = Function byte to be written  
66e5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66e5 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
66e7 18 02		            JR   WrFunc  
66e9 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
66eb f5			WrFunc:     PUSH AF  
66ec f5					push af  
66ed 3a d7 f8				ld a, (display_lcde1e2)  
66f0 fe 00				cp 0     ; e1  
66f2 20 0f				jr nz, .wfea2	  
66f4 f1					pop af  
66f5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66f7 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
66f9 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
66fb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66fd cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
66ff d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6701 18 0d			jr .wfskip  
6703 f1			.wfea2:		pop af  
6704 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6706 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6708 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
670a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
670c cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
670e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6710 3e 05		.wfskip:            LD  A, 5  
6712 cd 19 67		            CALL LCDDelay       ;Delay 5 ms to complete  
6715 f1			            POP  AF  
6716 c9			            RET  
6717			  
6717			  
6717			; Delay in milliseconds  
6717			;   On entry: A = Number of milliseconds delay  
6717			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6717 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6719 d5			LCDDelay:   PUSH DE  
671a 5f			            LD   E, A           ;Delay by 'A' ms  
671b 16 00		            LD   D, 0  
671d cd 3d 0a		            CALL aDelayInMS  
6720 d1			            POP  DE  
6721 c9			            RET  
6722			  
6722			  
6722			testlcd:  
6722 3e 00			ld a, kLCD_Line1  
6724 cd 9f 66			call fLCD_Pos  
6727 06 28			ld b, 40  
6729 11 57 67			ld de, .ttext1  
672c cd ea 65			call write_len_string  
672f			  
672f 3e 28			ld a, kLCD_Line2  
6731 cd 9f 66			call fLCD_Pos  
6734 06 28			ld b, 40  
6736 11 80 67			ld de, .ttext2  
6739 cd ea 65			call write_len_string  
673c 3e 50			ld a, kLCD_Line3  
673e cd 9f 66			call fLCD_Pos  
6741 06 28			ld b, 40  
6743 11 a9 67			ld de, .ttext3  
6746 cd ea 65			call write_len_string  
6749 3e 78			ld a, kLCD_Line4  
674b cd 9f 66			call fLCD_Pos  
674e 06 28			ld b, 40  
6750 11 d2 67			ld de, .ttext4  
6753 cd ea 65			call write_len_string  
6756			  
6756 76				halt  
6757			  
6757			  
6757 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6780 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
67a9 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
67d2 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
67fb			   
67fb			  
67fb			  
67fb			; eof  
67fb			  
# End of file firmware_lcd_4x40.asm
67fb			;include "firmware_lcd_4x20.asm" 
67fb			include "firmware_key_5x10.asm" 
67fb			; 5 x 10 decade counter scanner  
67fb			  
67fb			  
67fb			; TODO do cursor shape change for shift keys  
67fb			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
67fb			  
67fb			  
67fb			; bit mask for each scan column and row for teing the matrix  
67fb			  
67fb			  
67fb			key_init:  
67fb			  
67fb			; SCMonAPI functions used  
67fb			  
67fb			; Alphanumeric LCD functions used  
67fb			; no need to specify specific functions for this module  
67fb			  
67fb			  
67fb 3e cf		            LD   A, 11001111b  
67fd d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
67ff			;            LD   A, 00000000b  
67ff 3e 1f		            LD   A, 00011111b  
6801 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6803			  
6803			  
6803				; TODO Configure cursor shapes  
6803			  
6803				; Load cursor shapes   
6803 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6805 11 15 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6808 06 02		            LD   B, 2           ;Number of characters to define  
680a cd cb 66		.DefLoop:   CALL fLCD_Def       ;Define custom character  
680d 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
680f			  
680f 3e 01				ld a, 1  
6811 32 d0 f8			ld (cursor_shape),a  
6814 c9				ret  
6815			  
6815			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6815			; Up to 8 custom characters can be defined  
6815			.cursor_shapes:      
6815			;; Character 0x00 = Normal  
6815 1f			            DB  11111b  
6816 1f			            DB  11111b  
6817 1f			            DB  11111b  
6818 1f			            DB  11111b  
6819 1f			            DB  11111b  
681a 1f			            DB  11111b  
681b 1f			            DB  11111b  
681c 1f			            DB  11111b  
681d			;; Character 0x01 = Modifier  
681d 1f			            DB  11111b  
681e 1b			            DB  11011b  
681f 1b			            DB  11011b  
6820 1b			            DB  11011b  
6821 1b			            DB  11011b  
6822 1f			            DB  11111b  
6823 1b			            DB  11011b  
6824 1f			            DB  11111b  
6825			  
6825			  
6825			  
6825			  
6825			; Display custom character 0  
6825			;            LD   A, kLCD_Line1+14  
6825			;            CALL fLCD_Pos       ;Position cursor to location in A  
6825			;            LD   A, 0  
6825			;            CALL fLCD_Data      ;Write character in A at cursor  
6825			  
6825			; Display custom character 1  
6825			;            LD   A, kLCD_Line2+14  
6825			;            CALL fLCD_Pos      ;Position cursor to location in A  
6825			;            LD   A, 1  
6825			;            CALL fLCD_Data     ;Write character in A at cursor  
6825			  
6825			; keyboard scanning   
6825			  
6825			; character in from keyboard  
6825			  
6825			; mapping for the pcb layout  
6825			  
6825			.matrix_to_char:  
6825 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6830 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
683b 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6846 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6851 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
685c			.matrix_to_shift:  
685c			  
685c .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6867 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6872 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
687d 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6888 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6893			  
6893			.matrix_to_symbolshift:  
6893			  
6893 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
689e .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
68a9 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
68b4			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
68b4 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
68bf .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
68ca			  
68ca			  
68ca			  
68ca			; mapping for a simple straight through breadboard layout  
68ca			  
68ca			;.matrix_to_char:  
68ca			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
68ca			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
68ca			;		db "asdfghjkl",KEY_CR,0  
68ca			;		db "qwertyuiop",0  
68ca			;		 db "1234567890",0  
68ca			;.matrix_to_shift:  
68ca			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
68ca			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
68ca			;		db "ASDFGHJKL",KEY_CR,0  
68ca			;		db "QWERTYUIOP",0  
68ca			;		 db "!",'"',"#$%^&*()",0  
68ca			;.matrix_to_symbolshift:  
68ca			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
68ca			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
68ca			;		db "_?*fghjk=",KEY_CR,0  
68ca			;		db "-/+*[]{}@#",0  
68ca			;		 db "1234567890",0  
68ca			  
68ca			;.matrix_to_char: db "D#0*C987B654A321"  
68ca			  
68ca			  
68ca				  
68ca			  
68ca			; add cin and cin_wait  
68ca			  
68ca cd db 68		cin_wait: 	call cin  
68cd						if DEBUG_KEYCINWAIT  
68cd							push af  
68cd							  
68cd							ld hl,key_repeat_ct  
68cd							ld (hl),a  
68cd							inc hl  
68cd							call hexout  
68cd							ld hl,key_repeat_ct+3  
68cd							ld a,0  
68cd							ld (hl),a  
68cd			  
68cd							    LD   A, kLCD_Line1+11  
68cd							    CALL fLCD_Pos       ;Position cursor to location in A  
68cd							    LD   DE, key_repeat_ct  
68cd							    ;LD   DE, MsgHello  
68cd							    CALL fLCD_Str       ;Display string pointed to by DE  
68cd			  
68cd			  
68cd			  
68cd							pop af  
68cd						endif  
68cd fe 00			cp 0  
68cf 28 f9			jr z, cin_wait   ; block until key press  
68d1			  
68d1							if DEBUG_KEYCINWAIT  
68d1								push af  
68d1			  
68d1								ld a, 'A'	  
68d1								ld hl,key_repeat_ct  
68d1								ld (hl),a  
68d1								inc hl  
68d1								ld a,0  
68d1								ld (hl),a  
68d1			  
68d1								    LD   A, kLCD_Line2+11  
68d1								    CALL fLCD_Pos       ;Position cursor to location in A  
68d1								    LD   DE, key_repeat_ct  
68d1								    ;LD   DE, MsgHello  
68d1								    CALL fLCD_Str       ;Display string pointed to by DE  
68d1			  
68d1							call delay500ms  
68d1			  
68d1								pop af  
68d1							endif  
68d1 f5				push af   ; save key pressed  
68d2			  
68d2			.cin_wait1:	  
68d2							if DEBUG_KEYCINWAIT  
68d2								push af  
68d2			  
68d2								ld a, 'b'	  
68d2								ld hl,key_repeat_ct  
68d2								ld (hl),a  
68d2								inc hl  
68d2								ld a,0  
68d2								ld (hl),a  
68d2			  
68d2								    LD   A, kLCD_Line2+11  
68d2								    CALL fLCD_Pos       ;Position cursor to location in A  
68d2								    LD   DE, key_repeat_ct  
68d2								    ;LD   DE, MsgHello  
68d2								    CALL fLCD_Str       ;Display string pointed to by DE  
68d2			  
68d2			  
68d2							call delay500ms  
68d2			  
68d2								pop af  
68d2							endif  
68d2			  
68d2 cd db 68		call cin  
68d5 fe 00			cp 0  
68d7 20 f9			jr nz, .cin_wait1  	; wait for key release  
68d9			if DEBUG_KEYCINWAIT  
68d9				push af  
68d9			  
68d9				ld a, '3'	  
68d9				ld hl,key_repeat_ct  
68d9				ld (hl),a  
68d9				inc hl  
68d9				ld a,0  
68d9				ld (hl),a  
68d9			  
68d9			            LD   A, kLCD_Line2+11  
68d9			            CALL fLCD_Pos       ;Position cursor to location in A  
68d9			            LD   DE, key_repeat_ct  
68d9			            ;LD   DE, MsgHello  
68d9			            CALL fLCD_Str       ;Display string pointed to by DE  
68d9			  
68d9			  
68d9			call delay500ms  
68d9			  
68d9				pop af  
68d9			endif  
68d9			  
68d9 f1				pop af   ; get key  
68da c9				ret  
68db			  
68db			  
68db cd ef 68		cin: 	call .mtoc  
68de			  
68de			if DEBUG_KEYCIN  
68de				push af  
68de				  
68de				ld hl,key_repeat_ct  
68de				ld (hl),a  
68de				inc hl  
68de				call hexout  
68de				ld hl,key_repeat_ct+3  
68de				ld a,0  
68de				ld (hl),a  
68de			  
68de			            LD   A, kLCD_Line3+15  
68de			            CALL fLCD_Pos       ;Position cursor to location in A  
68de			            LD   DE, key_repeat_ct  
68de			            ;LD   DE, MsgHello  
68de			            CALL fLCD_Str       ;Display string pointed to by DE  
68de			  
68de			  
68de			call delay500ms  
68de			  
68de				pop af  
68de			endif  
68de			  
68de			  
68de				; no key held  
68de fe 00			cp 0  
68e0 c8				ret z  
68e1			  
68e1			if DEBUG_KEYCIN  
68e1				push af  
68e1			  
68e1				ld a, '1'	  
68e1				ld hl,key_repeat_ct  
68e1				ld (hl),a  
68e1				inc hl  
68e1				ld a,0  
68e1				ld (hl),a  
68e1			  
68e1			            LD   A, kLCD_Line4+15  
68e1			            CALL fLCD_Pos       ;Position cursor to location in A  
68e1			            LD   DE, key_repeat_ct  
68e1			            ;LD   DE, MsgHello  
68e1			            CALL fLCD_Str       ;Display string pointed to by DE  
68e1			  
68e1			  
68e1			call delay500ms  
68e1			  
68e1				pop af  
68e1			endif  
68e1			  
68e1				; stop key bounce  
68e1			  
68e1 32 88 fb			ld (key_held),a		 ; save it  
68e4 47				ld b, a  
68e5			  
68e5 c5			.cina1:	push bc  
68e6			if DEBUG_KEYCIN  
68e6				push af  
68e6			  
68e6				ld hl,key_repeat_ct  
68e6				inc hl  
68e6				call hexout  
68e6				ld hl,key_repeat_ct+3  
68e6				ld a,0  
68e6				ld (hl),a  
68e6				ld hl,key_repeat_ct  
68e6				ld a, '2'	  
68e6				ld (hl),a  
68e6			  
68e6			            LD   A, kLCD_Line4+15  
68e6			            CALL fLCD_Pos       ;Position cursor to location in A  
68e6			            LD   DE, key_repeat_ct  
68e6			            ;LD   DE, MsgHello  
68e6			            CALL fLCD_Str       ;Display string pointed to by DE  
68e6			  
68e6				pop af  
68e6			endif  
68e6 cd ef 68			call .mtoc  
68e9 c1				pop bc  
68ea b8				cp b  
68eb 28 f8			jr z, .cina1  
68ed 78				ld a,b		  
68ee			if DEBUG_KEYCIN  
68ee				push af  
68ee			  
68ee				ld hl,key_repeat_ct  
68ee				inc hl  
68ee				call hexout  
68ee				ld hl,key_repeat_ct+3  
68ee				ld a,0  
68ee				ld (hl),a  
68ee				ld hl,key_repeat_ct  
68ee				ld a, '3'	  
68ee				ld (hl),a  
68ee			  
68ee			            LD   A, kLCD_Line4+15  
68ee			            CALL fLCD_Pos       ;Position cursor to location in A  
68ee			            LD   DE, key_repeat_ct  
68ee			            ;LD   DE, MsgHello  
68ee			            CALL fLCD_Str       ;Display string pointed to by DE  
68ee			  
68ee				pop af  
68ee			endif  
68ee c9				ret  
68ef			  
68ef			; detect keyboard modifier key press and apply new overlay to the face key held  
68ef			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
68ef			  
68ef			;.cin_map_modifier:   
68ef			;	ld a, (hl)  
68ef			;	and 255  
68ef			;	ret NZ		; modifier key not flagged  
68ef			;  
68ef			;	; get key face  
68ef			;  
68ef			;	ld b,(key_face_held)  
68ef			;  
68ef			;	ld b, key_cols * key_rows  
68ef			;  
68ef			;	push de  
68ef			;	pop hl  
68ef			;  
68ef			;.mmod1: ld a,(hl)   ; get map test  
68ef			;	cp b  
68ef			;	jr z, .mmod2  
68ef			;  
68ef			;  
68ef			;  
68ef			;.mmod2: inc hl    ;   
68ef			;  
68ef			;	  
68ef			;  
68ef			;	  
68ef			;  
68ef			;	ld hl,key_actual_pressed  
68ef			;	ld (hl),a,  
68ef			;	ret  
68ef			  
68ef			; map matrix key held to char on face of key  
68ef			  
68ef			.mtoc:  
68ef			  
68ef			; test decade counter strobes  
68ef			  
68ef			;.decadetest1:  
68ef			  
68ef			; reset counter  
68ef			;ld a, 128  
68ef			;out (portbdata),a  
68ef			  
68ef			  
68ef			;ld b, 5  
68ef			;.dec1:  
68ef			;ld a, 0  
68ef			;out (portbdata),a  
68ef			;call delay1s  
68ef			  
68ef			;ld a, 32  
68ef			;out (portbdata),a  
68ef			;call delay1s  
68ef			;call delay1s  
68ef			;call delay1s  
68ef			;  
68ef			;ld a, 64+32  
68ef			;out (portbdata),a  
68ef			;call delay1s  
68ef			;;djnz .dec1  
68ef			;  
68ef			;jp .decadetest1  
68ef			  
68ef			  
68ef			  
68ef			  
68ef			  
68ef			  
68ef			  
68ef			  
68ef			  
68ef			  
68ef				; scan keyboard matrix and generate raw scan map  
68ef cd 82 69			call matrix  
68f2			  
68f2				; reuse c bit 0 left modifer button - ie shift  
68f2			        ; reuse c bit 1 for right modifer button - ie symbol shift  
68f2				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
68f2			  
68f2 0e 00			ld c, 0  
68f4			  
68f4				; TODO set flags for modifer key presses   
68f4				; TODO do a search for modifer key...  
68f4			  
68f4				;ld hl,keyscan_table_row4  
68f4 21 e7 fb			ld hl,keyscan_table_row2  
68f7			  
68f7 7e				ld a, (hl)  
68f8 fe 23			cp '#'  
68fa 20 07			jr nz, .nextmodcheck  
68fc cb c1			set 0, c  
68fe 21 5c 68			ld hl, .matrix_to_shift  
6901 18 21			jr .dokeymap  
6903				; TODO for now igonre  
6903			.nextmodcheck:  
6903 21 dc fb			ld hl,keyscan_table_row3  
6906			  
6906 7e				ld a, (hl)  
6907 fe 23			cp '#'  
6909 20 07			jr nz, .nextmodcheck2  
690b cb c9			set 1, c   
690d 21 93 68			ld hl, .matrix_to_symbolshift  
6910 18 12			jr .dokeymap  
6912			.nextmodcheck2:  
6912 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6915			  
6915 7e				ld a, (hl)  
6916 fe 23			cp '#'  
6918 20 07			jr nz, .donemodcheck  
691a cb c9			set 1, c   
691c 21 5c 68			ld hl, .matrix_to_shift  
691f 18 03			jr .dokeymap  
6921			  
6921				; no modifer found so just map to normal keys  
6921				; get mtoc map matrix to respective keys  
6921			;	ld hl, .matrix_to_char  
6921			;	ld hl, .matrix_to_char  
6921			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6921			;	ld a, KEY_SHIFT  
6921			;	call findchar  
6921			;  
6921			;	; got offset to key modifer in b  
6921			;  
6921			;	ld hl,keyscan_table_row5  
6921			;  
6921			;	ld a,b  
6921			;	call addatohl  
6921			;	ld a,(hl)  
6921			;  
6921			;	cp '#'  
6921			;	jr nz, .nextmodcheck  
6921			;	set 0, c  
6921			;	ld hl, .matrix_to_char  
6921			;	jr .dokeymap  
6921			;	; TODO for now igonre  
6921			;.nextmodcheck:  
6921			;	ld hl, .matrix_to_symbolshift  
6921			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6921			;	ld a, KEY_SYMBOLSHIFT  
6921			;	call findchar  
6921			;  
6921			;  
6921			;	; got offset to key modifer in b  
6921			;  
6921			;	ld hl,keyscan_table_row5  
6921			;  
6921			;	ld a,b  
6921			;	call addatohl  
6921			;	ld a,(hl)  
6921			;  
6921			;	cp '#'  
6921			;	jr nz, .donemodcheck  
6921			;	set 1, c   
6921			;	ld hl, .matrix_to_symbolshift  
6921			;	jr .dokeymap  
6921			  
6921			  
6921			  
6921			.donemodcheck:  
6921				; no modifer found so just map to normal keys  
6921				; get mtoc map matrix to respective keys  
6921 21 25 68			ld hl, .matrix_to_char  
6924			  
6924			.dokeymap:  
6924				;ld (key_fa), c   
6924 cd 3d 69			call .mapkeys  
6927			  
6927			  
6927			if DEBUG_KEY  
6927			  
6927			; Display text on first line  
6927			            LD   A, kLCD_Line1  
6927			            CALL fLCD_Pos       ;Position cursor to location in A  
6927			            LD   DE, keyscan_table_row1  
6927			            ;LD   DE, MsgHello  
6927			            CALL fLCD_Str       ;Display string pointed to by DE  
6927			  
6927			; Display text on second line  
6927			            LD   A, kLCD_Line2  
6927			            CALL fLCD_Pos       ;Position cursor to location in A  
6927			            LD   DE, keyscan_table_row2  
6927			            CALL fLCD_Str       ;Display string pointed to by DE  
6927			            LD   A, kLCD_Line3  
6927			            CALL fLCD_Pos       ;Position cursor to location in A  
6927			            LD   DE, keyscan_table_row3  
6927			            CALL fLCD_Str       ;Display string pointed to by DE  
6927			            LD   A, kLCD_Line4  
6927			            CALL fLCD_Pos       ;Position cursor to location in A  
6927			            LD   DE, keyscan_table_row4  
6927			            CALL fLCD_Str       ;Display string pointed to by DE  
6927			            LD   A, kLCD_Line1+10  
6927			            CALL fLCD_Pos       ;Position cursor to location in A  
6927			            LD   DE, keyscan_table_row5  
6927			            CALL fLCD_Str       ;Display string pointed to by DE  
6927			  
6927				;call delay250ms  
6927			endif  
6927			;	jp testkey  
6927			  
6927			; get first char reported  
6927			  
6927 21 c6 fb			ld hl,keyscan_table_row5  
692a			  
692a				;ld b, 46   ; 30 keys to remap + 8 nulls   
692a 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
692c			.findkey:  
692c 7e				ld a,(hl)  
692d fe 00			cp 0  
692f 28 04			jr z, .nextkey  
6931 fe 7e			cp KEY_MATRIX_NO_PRESS  
6933 20 06			jr nz, .foundkey  
6935			.nextkey:  
6935 23				inc hl  
6936 10 f4			djnz .findkey  
6938 3e 00			ld a,0  
693a c9				ret  
693b			.foundkey:  
693b 7e				ld a,(hl)  
693c c9				ret  
693d				  
693d			  
693d			; convert the raw key map given hl for destination key  
693d			.mapkeys:  
693d 11 c6 fb			ld de,keyscan_table_row5  
6940			  
6940 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6942			.remap:  
6942 1a				ld a,(de)  
6943 fe 23			cp '#'  
6945 20 02			jr nz, .remapnext  
6947				;CALLMONITOR  
6947 7e				ld a,(hl)  
6948 12				ld (de),a  
6949			  
6949			  
6949			  
6949			.remapnext:  
6949 23				inc hl  
694a 13				inc de  
694b 10 f5			djnz .remap  
694d				  
694d c9				ret  
694e			  
694e			  
694e			  
694e			.mtocold2:  
694e			  
694e			;	; flag if key D is held down and remove from reporting  
694e			;	ld bc, .key_map_fd    
694e			;	ld hl, keyscan_table  
694e			;	ld de, key_fd  
694e			;	call .key_shift_hold  
694e			;	cp 255  
694e			;	jr z, .cinmap  
694e			;	; flag if key C is held down and remove from reporting  
694e			;	ld bc, .key_map_fc    
694e			;	ld hl, keyscan_table+key_cols  
694e			;	ld de, key_fc  
694e			;	call .key_shift_hold  
694e			;	cp 255  
694e			;	jr z, .cinmap  
694e			;	; flag if key B is held down and remove from reporting  
694e			;	ld bc, .key_map_fb    
694e			;	ld hl, keyscan_table+(key_cols*2)  
694e			;	ld de, key_fb  
694e			;	call .key_shift_hold  
694e			;	cp 255  
694e			;	jr z, .cinmap  
694e			;	; flag if key A is held down and remove from reporting  
694e			;	ld bc, .key_map_fa    
694e			;	ld hl, keyscan_table+(key_cols*3)  
694e			;	ld de, key_fa  
694e			;	call .key_shift_hold  
694e			;	cp 255  
694e			;	jr z, .cinmap  
694e			  
694e 11 25 68			ld de, .matrix_to_char  
6951			  
6951			  
6951			.cinmap1:   
6951				if DEBUG_KEY  
6951			            LD   A, kLCD_Line4  
6951			            CALL fLCD_Pos       ;Position cursor to location in A  
6951					push de  
6951			            LD   DE, keyscan_table  
6951			            CALL fLCD_Str       ;Display string pointed to by DE  
6951					pop de  
6951				endif  
6951			  
6951				; scan key matrix table for any held key  
6951			  
6951				; de holds either the default matrix or one selected above  
6951			  
6951 21 93 fb			ld hl, keyscan_table  
6954 06 32			ld b,key_cols*key_rows  
6956			  
6956 7e			.cin11:	ld a,(hl)  
6957 fe 23			cp '#'  
6959 28 08			jr z, .cinhit1  
695b 23				inc hl  
695c 13				inc de  
695d 05				dec b  
695e 20 f6			jr nz, .cin11  
6960				; no key found held  
6960 3e 00			ld a,0  
6962 c9				ret  
6963 d5			.cinhit1: push de  
6964 e1				pop hl  
6965 7e				ld a,(hl)  
6966 c9				ret  
6967			  
6967			; flag a control key is held   
6967			; hl is key pin, de is flag indicator  
6967			  
6967			.key_shift_hold1:  
6967 c5				push bc  
6968 3e 01			ld a, 1  
696a 32 d0 f8			ld (cursor_shape),a  
696d 06 00			ld b, 0  
696f 7e				ld a, (hl)  
6970 fe 2e			cp '.'  
6972 28 0a			jr z, .key_shift11  
6974 06 ff			ld b, 255  
6976 3e 2b			ld a, '+'    ; hide key from later scans  
6978 77				ld (hl),a  
6979 3e 02			ld a, 2  
697b 32 d0 f8			ld (cursor_shape),a  
697e			.key_shift11:  
697e				; write flag indicator  
697e 78				ld a,b  
697f 12				ld (de),a  
6980			  
6980 d1				pop de    ; de now holds the key map ptr  
6981 c9				ret  
6982			  
6982				  
6982			  
6982			; scans keyboard matrix and flags key press in memory array	  
6982				  
6982			matrix:  
6982				;call matrix  
6982				; TODO optimise the code....  
6982			  
6982			  
6982			;ld hl, keyscan_table_row1  
6982			;ld de, keyscan_table_row1+1  
6982			;ld bc,46  
6982			;ld a,KEY_MATRIX_NO_PRESS  
6982			;ldir  
6982			  
6982			  
6982			  
6982			; reset counter  
6982 3e 80		ld a, 128  
6984 d3 c1		out (portbdata),a  
6986			  
6986 06 0a		ld b, 10  
6988 0e 00		ld c, 0       ; current clock toggle  
698a			  
698a			.colscan:  
698a			  
698a			; set current column  
698a			; disable clock enable and set clock low  
698a			  
698a			;ld a, 0  
698a			;out (portbdata),a  
698a			  
698a			; For each column scan for switches  
698a			  
698a c5			push bc  
698b 21 89 fb		ld hl, keyscan_scancol  
698e cd 97 6a		call .rowscan  
6991 c1			pop bc  
6992			  
6992			  
6992			; get back current column  
6992			  
6992			; translate the row scan  
6992			  
6992			;   
6992			; row 1  
6992			  
6992 78			ld a,b  
6993			  
6993 21 fc fb		LD   hl, keyscan_table_row1+10  
6996			  
6996 cd 1e 0d		call subafromhl  
6999			;call addatohl  
6999			  
6999 11 89 fb		ld de, keyscan_scancol  
699c			  
699c 1a			ld a,(de)  
699d 77			ld (hl),a  
699e			  
699e			  
699e			  
699e			  
699e			; row 2  
699e			  
699e 78			ld a,b  
699f			  
699f 21 f1 fb		LD   hl, keyscan_table_row2+10  
69a2			  
69a2			;call addatohl  
69a2 cd 1e 0d		call subafromhl  
69a5			  
69a5			  
69a5 11 8a fb		ld de, keyscan_scancol+1  
69a8			  
69a8 1a			ld a,(de)  
69a9 77			ld (hl),a  
69aa			  
69aa			  
69aa			; row 3  
69aa			  
69aa 78			ld a,b  
69ab			  
69ab 21 e6 fb		LD   hl, keyscan_table_row3+10  
69ae			  
69ae			;call addatohl  
69ae cd 1e 0d		call subafromhl  
69b1			  
69b1 11 8b fb		ld de, keyscan_scancol+2  
69b4			  
69b4 1a			ld a,(de)  
69b5 77			ld (hl),a  
69b6			  
69b6			  
69b6			  
69b6			; row 4  
69b6			  
69b6 78			ld a,b  
69b7			  
69b7 21 db fb		LD   hl, keyscan_table_row4+10  
69ba			  
69ba			;call addatohl  
69ba cd 1e 0d		call subafromhl  
69bd			  
69bd 11 8c fb		ld de, keyscan_scancol+3  
69c0			  
69c0 1a			ld a,(de)  
69c1 77			ld (hl),a  
69c2			  
69c2			; row 5  
69c2			  
69c2 78			ld a,b  
69c3			  
69c3 21 d0 fb		LD   hl, keyscan_table_row5+10  
69c6			  
69c6			;call addatohl  
69c6 cd 1e 0d		call subafromhl  
69c9			  
69c9 11 8d fb		ld de, keyscan_scancol+4  
69cc			  
69cc 1a			ld a,(de)  
69cd 77			ld (hl),a  
69ce			  
69ce			; handshake next column  
69ce			  
69ce			  
69ce 3e 40		ld a, 64  
69d0 d3 c1		out (portbdata),a  
69d2			  
69d2 3e 00		ld a, 0  
69d4 d3 c1		out (portbdata),a  
69d6			  
69d6			; toggle clk and move to next column  
69d6			;ld a, 64  
69d6			;cp c  
69d6			;  
69d6			;jr z, .coltoglow  
69d6			;ld c, a  
69d6			;jr .coltog  
69d6			;.coltoglow:  
69d6			;ld c, 0  
69d6			;.coltog:  
69d6			;ld a, c  
69d6			;out (portbdata),a  
69d6			  
69d6 10 b2		djnz .colscan  
69d8			  
69d8 3e 0a		ld a,10  
69da 21 f2 fb		LD   hl, keyscan_table_row1  
69dd cd 0c 0d		call addatohl  
69e0 3e 00		ld a, 0  
69e2 77			ld (hl), a  
69e3			  
69e3			  
69e3 3e 0a		ld a,10  
69e5 21 e7 fb		LD   hl, keyscan_table_row2  
69e8 cd 0c 0d		call addatohl  
69eb 3e 00		ld a, 0  
69ed 77			ld (hl), a  
69ee			  
69ee 3e 0a		ld a,10  
69f0 21 dc fb		LD   hl, keyscan_table_row3  
69f3 cd 0c 0d		call addatohl  
69f6 3e 00		ld a, 0  
69f8 77			ld (hl), a  
69f9			  
69f9 3e 0a		ld a,10  
69fb 21 d1 fb		LD   hl, keyscan_table_row4  
69fe cd 0c 0d		call addatohl  
6a01 3e 00		ld a, 0  
6a03 77			ld (hl), a  
6a04			  
6a04 3e 0a		ld a,10  
6a06 21 c6 fb		LD   hl, keyscan_table_row5  
6a09 cd 0c 0d		call addatohl  
6a0c 3e 00		ld a, 0  
6a0e 77			ld (hl), a  
6a0f			  
6a0f			if DEBUG_KEY_MATRIX  
6a0f			  
6a0f			; Display text on first line  
6a0f			            LD   A, kLCD_Line1  
6a0f			            CALL fLCD_Pos       ;Position cursor to location in A  
6a0f			            LD   DE, keyscan_table_row1  
6a0f			            ;LD   DE, MsgHello  
6a0f			            CALL fLCD_Str       ;Display string pointed to by DE  
6a0f			  
6a0f			; Display text on second line  
6a0f			            LD   A, kLCD_Line2  
6a0f			            CALL fLCD_Pos       ;Position cursor to location in A  
6a0f			            LD   DE, keyscan_table_row2  
6a0f			            CALL fLCD_Str       ;Display string pointed to by DE  
6a0f			            LD   A, kLCD_Line3  
6a0f			            CALL fLCD_Pos       ;Position cursor to location in A  
6a0f			            LD   DE, keyscan_table_row3  
6a0f			            CALL fLCD_Str       ;Display string pointed to by DE  
6a0f			            LD   A, kLCD_Line4  
6a0f			            CALL fLCD_Pos       ;Position cursor to location in A  
6a0f			            LD   DE, keyscan_table_row4  
6a0f			            CALL fLCD_Str       ;Display string pointed to by DE  
6a0f			            LD   A, kLCD_Line4+10  
6a0f			            CALL fLCD_Pos       ;Position cursor to location in A  
6a0f			            LD   DE, keyscan_table_row5  
6a0f			            CALL fLCD_Str       ;Display string pointed to by DE  
6a0f			  
6a0f			;call delay250ms  
6a0f				jp matrix  
6a0f			endif  
6a0f c9			ret  
6a10			  
6a10			; using decade counter....  
6a10			  
6a10			  
6a10			; TODO reset decade counter to start of scan  
6a10			  
6a10			; reset 15  
6a10			; clock 14  
6a10			; ce 13  
6a10			  
6a10			; 1 - q5  
6a10			; 2 - q1  
6a10			; 3 - q0  
6a10			; 4 - q2  
6a10			; 5 - q6  
6a10			; 6 - q7  
6a10			; 7 - q3  
6a10			; 8 - vss  
6a10			; 9 - q8  
6a10			; 10 - q4  
6a10			; 11 - q9  
6a10			; 12 - cout  
6a10			; 16 - vdd  
6a10			  
6a10			; clock      ce       reset     output  
6a10			; 0          x        0         n  
6a10			; x          1        0         n  
6a10			; x          x        1         q0  
6a10			; rising     0        0         n+1  
6a10			; falling    x        0         n  
6a10			; x          rising   0         n  
6a10			; 1          falling  0         x+1  
6a10			;  
6a10			; x = dont care, if n < 5 carry = 1 otherwise 0  
6a10			  
6a10			;   
6a10			; reset   
6a10			; 13=0, 14=0, 15=1 .. 15=0  
6a10			;  
6a10			; handshake line  
6a10			; 14=1.... read line 14=0  
6a10			  
6a10			  
6a10			  
6a10			  
6a10			  
6a10			; TODO hand shake clock for next column scan  
6a10			; TODO detect each row  
6a10			  
6a10			  
6a10			  
6a10			  
6a10			; reset 128  
6a10			; clock 64  
6a10			; ce 32  
6a10			  
6a10			  
6a10			.cyclestart:  
6a10			  
6a10			; reset counter  
6a10 3e 80		ld a, 128  
6a12 d3 c1		out (portbdata),a  
6a14			  
6a14			; loop leds  
6a14 06 0a		ld b,10  
6a16			  
6a16			.cycle1:  
6a16 c5			push bc  
6a17 3e 00		ld a, 0  
6a19 d3 c1		out (portbdata),a  
6a1b cd 4c 0a		call delay250ms  
6a1e			  
6a1e 3e 40		ld a, 64  
6a20 d3 c1		out (portbdata),a  
6a22 cd 4c 0a		call delay250ms  
6a25			  
6a25 3e 00		ld a, 0  
6a27 d3 c1		out (portbdata),a  
6a29 cd 4c 0a		call delay250ms  
6a2c			  
6a2c c1			pop bc  
6a2d 10 e7		djnz .cycle1  
6a2f			  
6a2f			  
6a2f 18 df		jr .cyclestart  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			; map matrix key held to char on face of key  
6a31			  
6a31			;.mtocold:  
6a31			;  
6a31			;  
6a31			;; reset counter  
6a31			;ld a, 128  
6a31			;out (portbdata),a  
6a31			;  
6a31			;  
6a31			;; scan keyboard row 1  
6a31			;ld a, 0  
6a31			;out (portbdata),a  
6a31			;;ld a, 64  
6a31			;;out (portbdata),a  
6a31			;  
6a31			;  
6a31			;	ld a, 128  
6a31			;	ld hl, keyscan_table  
6a31			;	call .rowscan  
6a31			;  
6a31			;;ld a, 0  
6a31			;;out (portbdata),a  
6a31			;ld a, 64  
6a31			;out (portbdata),a  
6a31			;  
6a31			;	ld a, 64  
6a31			;	ld hl, keyscan_table+key_cols  
6a31			;	call .rowscan  
6a31			;  
6a31			;ld a, 0  
6a31			;out (portbdata),a  
6a31			;;ld a, 64  
6a31			;;out (portbdata),a  
6a31			;	ld a, 32  
6a31			;	ld hl, keyscan_table+(key_cols*2)  
6a31			;	call .rowscan  
6a31			;  
6a31			;  
6a31			;;ld a, 0  
6a31			;;out (portbdata),a  
6a31			;ld a, 64  
6a31			;out (portbdata),a  
6a31			;  
6a31			;	ld a, 16  
6a31			;	ld hl, keyscan_table+(key_cols*3)  
6a31			;	call .rowscan  
6a31			;  
6a31			;  
6a31			;	; flag if key D is held down and remove from reporting  
6a31			;	ld bc, .key_map_fd    
6a31			;	ld hl, keyscan_table  
6a31			;	ld de, key_fd  
6a31			;	call .key_shift_hold  
6a31			;	cp 255  
6a31			;	jr z, .cinmap  
6a31			;	; flag if key C is held down and remove from reporting  
6a31			;	ld bc, .key_map_fc    
6a31			;	ld hl, keyscan_table+key_cols  
6a31			;	ld de, key_fc  
6a31			;	call .key_shift_hold  
6a31			;	cp 255  
6a31			;	jr z, .cinmap  
6a31			;	; flag if key B is held down and remove from reporting  
6a31			;	ld bc, .key_map_fb    
6a31			;	ld hl, keyscan_table+(key_cols*2)  
6a31			;	ld de, key_fb  
6a31			;	call .key_shift_hold  
6a31			;	cp 255  
6a31			;	jr z, .cinmap  
6a31			;	; flag if key A is held down and remove from reporting  
6a31			;	ld bc, .key_map_fa    
6a31			;	ld hl, keyscan_table+(key_cols*3)  
6a31			;	ld de, key_fa  
6a31			;	call .key_shift_hold  
6a31			;	cp 255  
6a31			;	jr z, .cinmap  
6a31			;  
6a31			;	ld de, .matrix_to_char  
6a31			;  
6a31			;  
6a31			;.cinmap:   
6a31			;	if DEBUG_KEY  
6a31			;            LD   A, kLCD_Line4  
6a31			;            CALL fLCD_Pos       ;Position cursor to location in A  
6a31			;		push de  
6a31			;            LD   DE, keyscan_table  
6a31			;            CALL fLCD_Str       ;Display string pointed to by DE  
6a31			;		pop de  
6a31			;	endif  
6a31			  
6a31				; scan key matrix table for any held key  
6a31			  
6a31				; de holds either the default matrix or one selected above  
6a31			  
6a31			;	ld hl, keyscan_table  
6a31			;	ld b,key_cols*key_rows  
6a31			;  
6a31			;.cin1:	ld a,(hl)  
6a31			;	cp '#'  
6a31			;	jr z, .cinhit  
6a31			;	inc hl  
6a31			;	inc de  
6a31			;	dec b  
6a31			;	jr nz, .cin1  
6a31			;	; no key found held  
6a31			;	ld a,0  
6a31			;	ret  
6a31			;.cinhit: push de  
6a31			;	pop hl  
6a31			;	ld a,(hl)  
6a31			;	ret  
6a31			  
6a31			; flag a control key is held   
6a31			; hl is key pin, de is flag indicator  
6a31			  
6a31			;.key_shift_hold:  
6a31			;	push bc  
6a31			;	ld a, 1  
6a31			;	ld (cursor_shape),a  
6a31			;	ld b, 0  
6a31			;	ld a, (hl)  
6a31			;	cp '.'  
6a31			;	jr z, .key_shift1  
6a31			;	ld b, 255  
6a31			;	ld a, '+'    ; hide key from later scans  
6a31			;	ld (hl),a  
6a31			;	ld a, 2  
6a31			;	ld (cursor_shape),a  
6a31			;.key_shift1:  
6a31			;	; write flag indicator  
6a31			;	ld a,b  
6a31			;	ld (de),a  
6a31			;  
6a31			;	pop de    ; de now holds the key map ptr  
6a31			;	ret  
6a31			  
6a31				  
6a31				  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			;	push hl  
6a31			;	push de  
6a31			;	push bc  
6a31			;	call keyscan  
6a31			;	; map key matrix to ascii value of key face  
6a31			;  
6a31			;	ld hl, key_face_map  
6a31			;	ld de, keyscan_table  
6a31			;  
6a31			;	; get how many keys to look at  
6a31			;	ld b, keyscan_table_len  
6a31			;	  
6a31			;  
6a31			;	; at this stage fall out on first key hit  
6a31			;	; TODO handle multiple key press  
6a31			;  
6a31			;map1:	ld a,(hl)  
6a31			;	cp '#'  
6a31			;	jr z, keyhit  
6a31			;	inc hl  
6a31			;	inc de  
6a31			;	dec b  
6a31			;	jr nz, map1  
6a31			;nohit:	ld a, 0  
6a31			;	jr keydone  
6a31			;keyhit: push de  
6a31			;	pop hl  
6a31			;	ld a,(hl)  
6a31			;keydone:  
6a31			;	push bc  
6a31			;	push de  
6a31			; 	push hl  
6a31			;	ret   
6a31			;  
6a31			  
6a31			  
6a31			  
6a31			  
6a31			; scan physical key matrix  
6a31			  
6a31			  
6a31			;keyscan:  
6a31			;  
6a31			;; for each key_row use keyscanr bit mask for out  
6a31			;; then read in for keyscanc bitmask  
6a31			;; save result of row scan to keyscantable  
6a31			;  
6a31			;; scan keyboard row 1  
6a31			;  
6a31			;	ld b, key_rows  
6a31			;	ld hl, key_scanr  
6a31			;	ld de, keyscan_table  
6a31			;  
6a31			;rowloop:  
6a31			;  
6a31			;	ld a,(hl)		; out bit mask to energise keyboard row  
6a31			;	call rowscan  
6a31			;	inc hl  
6a31			;	dec b  
6a31			;	jr nz, rowloop  
6a31			;  
6a31			;	ret  
6a31			;  
6a31			;  
6a31			;; pass a out bitmask, b row number  
6a31			;arowscan:   
6a31			;	push bc  
6a31			;  
6a31			;	ld d, b  
6a31			;  
6a31			;	; calculate buffer location for this row  
6a31			;  
6a31			;	ld hl, keyscan_table	  
6a31			;kbufr:  ld e, key_cols  
6a31			;kbufc:	inc hl  
6a31			;	dec e  
6a31			;	jr nz, kbufc  
6a31			;	dec d  
6a31			;	jr nz, kbufr  
6a31			;  
6a31			;	; energise row and read columns  
6a31			;  
6a31			;	out (portbdata),a  
6a31			;	in a,(portbdata)  
6a31			;	ld c,a  
6a31			;  
6a31			;  
6a31			;	; save buffer loc  
6a31			;  
6a31			;	ld (keybufptr), hl  
6a31			;  
6a31			;	ld hl, key_scanc  
6a31			;	ld d, key_cols  
6a31			;  
6a31			;	; for each column check each bit mask  
6a31			;  
6a31			;colloop:  
6a31			;	  
6a31			;  
6a31			;	; reset flags for the row   
6a31			;  
6a31			;	ld b,'.'  
6a31			;	and (hl)  
6a31			;	jr z, maskskip  
6a31			;	ld b,'#'  
6a31			;maskskip:  
6a31			;	; save  key state  
6a31			;	push hl  
6a31			;	ld hl, (keybufptr)  
6a31			;	ld (hl), b  
6a31			;	inc hl  
6a31			;	ld (keybufptr), hl  
6a31			;  
6a31			;	; move to next bit mask  
6a31			;	pop hl  
6a31			;	inc hl  
6a31			;  
6a31			;	dec d  
6a31			;	jr nz, colloop  
6a31			;  
6a31			;	ret  
6a31			;  
6a31			;  
6a31			;;  
6a31			; lcd functions  
6a31			;  
6a31			;  
6a31			  
6a31			;if DEBUG_KEY_MATRIX  
6a31			  
6a31			; test function to display hardware view of matrix state  
6a31			  
6a31			matrixold:  
6a31			  
6a31			  
6a31			  
6a31			; reset counter  
6a31 3e 80		ld a, 128  
6a33 d3 c1		out (portbdata),a  
6a35			; scan keyboard row 1  
6a35 3e 00		ld a, 0  
6a37 d3 c1		out (portbdata),a  
6a39			;ld a, 64  
6a39			;out (portbdata),a  
6a39 3e 80			ld a, 128  
6a3b 21 f2 fb			ld hl, keyscan_table_row1  
6a3e cd 97 6a			call .rowscan  
6a41			  
6a41			;ld a, 0  
6a41			;out (portbdata),a  
6a41 3e 40		ld a, 64  
6a43 d3 c1		out (portbdata),a  
6a45 3e 40			ld a, 64  
6a47 21 e7 fb			ld hl, keyscan_table_row2  
6a4a cd 97 6a			call .rowscan  
6a4d			  
6a4d 3e 00		ld a, 0  
6a4f d3 c1		out (portbdata),a  
6a51			;ld a, 64  
6a51			;out (portbdata),a  
6a51 3e 20			ld a, 32  
6a53 21 dc fb			ld hl, keyscan_table_row3  
6a56 cd 97 6a			call .rowscan  
6a59			  
6a59			;ld a, 0  
6a59			;out (portbdata),a  
6a59 3e 40		ld a, 64  
6a5b d3 c1		out (portbdata),a  
6a5d 3e 10			ld a, 16  
6a5f 21 d1 fb			ld hl, keyscan_table_row4  
6a62 cd 97 6a			call .rowscan  
6a65			  
6a65			; Display text on first line  
6a65 3e 00		            LD   A, kLCD_Line1  
6a67 cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a6a 11 f2 fb		            LD   DE, keyscan_table_row1  
6a6d			            ;LD   DE, MsgHello  
6a6d cd c1 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a70			  
6a70			; Display text on second line  
6a70 3e 28		            LD   A, kLCD_Line2  
6a72 cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a75 11 e7 fb		            LD   DE, keyscan_table_row2  
6a78 cd c1 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a7b 3e 50		            LD   A, kLCD_Line3  
6a7d cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a80 11 dc fb		            LD   DE, keyscan_table_row3  
6a83 cd c1 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a86 3e 78		            LD   A, kLCD_Line4  
6a88 cd 9f 66		            CALL fLCD_Pos       ;Position cursor to location in A  
6a8b 11 d1 fb		            LD   DE, keyscan_table_row4  
6a8e cd c1 66		            CALL fLCD_Str       ;Display string pointed to by DE  
6a91			  
6a91 cd 4c 0a			call delay250ms  
6a94 c3 82 69			jp matrix  
6a97			  
6a97			; pass de as row display flags  
6a97			.rowscan:   
6a97			;	out (portbdata),a  
6a97 db c1			in a,(portbdata)  
6a99 4f				ld c,a  
6a9a				; reset flags for the row   
6a9a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6a9c e6 01			and 1  
6a9e 28 02			jr z, .p1on  
6aa0 06 23			ld b,'#'  
6aa2			.p1on:  
6aa2 70				ld (hl), b  
6aa3 23				inc hl  
6aa4			  
6aa4 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6aa6 79				ld a,c  
6aa7 e6 02			and 2  
6aa9			;	bit 0,a  
6aa9 28 02			jr z, .p2on  
6aab 06 23			ld b,'#'  
6aad			.p2on:  
6aad 70				ld (hl), b  
6aae 23				inc hl  
6aaf			;  
6aaf 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ab1 79				ld a,c  
6ab2 e6 04			and 4  
6ab4			;;	bit 0,a  
6ab4 28 02			jr z, .p3on  
6ab6 06 23			ld b,'#'  
6ab8			.p3on:  
6ab8 70				ld (hl), b  
6ab9 23				inc hl  
6aba			;;  
6aba 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6abc			;;	bit 0,a  
6abc 79				ld a,c  
6abd e6 08			and 8  
6abf 28 02			jr z, .p4on  
6ac1 06 23			ld b,'#'  
6ac3			.p4on:  
6ac3 70				ld (hl), b  
6ac4 23				inc hl  
6ac5			  
6ac5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ac7			;;	bit 0,a  
6ac7 79				ld a,c  
6ac8 e6 10			and 16  
6aca 28 02			jr z, .p5on  
6acc 06 23			ld b,'#'  
6ace			.p5on:  
6ace 70				ld (hl), b  
6acf 23				inc hl  
6ad0			; zero term  
6ad0 06 00			ld b,0  
6ad2 70				ld (hl), b  
6ad3			  
6ad3 c9			.rscandone: ret  
6ad4			  
6ad4			;addatohl:  
6ad4			;  
6ad4			 ;add   a, l    ; A = A+L  
6ad4			  ;  ld    l, a    ; L = A+L  
6ad4			   ; adc   a, h    ; A = A+L+H+carry  
6ad4			   ; sub   l       ; A = H+carry  
6ad4			   ; ld    h, a    ; H = H+carry  
6ad4			  
6ad4			;ret  
6ad4			; eof  
# End of file firmware_key_5x10.asm
6ad4			;include "firmware_key_4x10.asm" 
6ad4			 
6ad4			heap_size:    equ heap_end - heap_start 
6ad4			;eof 
# End of file os_mega.asm
6ad4
